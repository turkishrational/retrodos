     1                                  ;*****************************************************************************
     2                                  ; MSDOS6.BIN (MSDOS 6.0 Kernel) - RETRO DOS v4.0 by ERDOGAN TAN - 03/11/2022
     3                                  ; ----------------------------------------------------------------------------
     4                                  ; Last Update: 29/09/2023 - Retro DOS v4.2 ((Previous: 27/09/2023))
     5                                  ; ----------------------------------------------------------------------------
     6                                  ; Beginning: 07/07/2018 (Retro DOS 3.0), 22/04/2019 (Retro DOS 4.0)
     7                                  ; ----------------------------------------------------------------------------
     8                                  ; Assembler: NASM version 2.15 (2.11)  
     9                                  ; ----------------------------------------------------------------------------
    10                                  ;	   ((nasm msdos6.s -l msdos6.lst -o MSDOS6.BIN -Z error.txt)) 	
    11                                  ; ----------------------------------------------------------------------------
    12                                  ; Modified from 'msdos3.s' file of Retro DOS 3.0 source code (10/09/2018)
    13                                  ; ----------------------------------------------------------------------------
    14                                  ; Derived from 'msdos2.s' file of Retro DOS 2.0 source code (04/05/2018)
    15                                  ; ----------------------------------------------------------------------------
    16                                  ; Derived from 'MSCODE.ASM' file of MSDOS 2.0 (IBM PCDOS v2.0) source code
    17                                  ; by Microsoft, 25/08/1983 (DOSLINK - 'MSDOS.ASM')
    18                                  ;*****************************************************************************
    19                                  ; main file: 'retrodos4.s'
    20                                  ; incbin 'MSDOS5.BIN'
    21                                  ;=============================================================================
    22                                  ; Modified from 'msdos6.s' (modified MSDOS 6.21 kernel src as Retro DOS v4.0)
    23                                  ; 28/07/2019  /// Retro DOS v4.0 (2022) -> Modified MSDOS 5.0 IO.SYS+MSDOS.SYS
    24                                  ;=============================================================================
    25                                  
    26                                  ; 30/12/2022 - Retro DOS v4.2 Kernel ('msdos6.s')
    27                                  ; Modified from 'msdos5.s' (29/12/2022, Retro DOS v4.1 Kernel) file
    28                                  ; as below:
    29                                  ;	1) MS-DOS version has been changed to 6.22 (It was 5.0) 
    30                                  ;	2) Retro DOS version has been changed to 4.2 (It was 4.1)
    31                                  ; (The content has not been changed except kernel version because the kernel
    32                                  ;  code is already compatible with MSDOS 6.x and it is optimized before.
    33                                  ;	(But IO.SYS part of the kernel is not same with Retro DOS v4.1 code.)	
    34                                  
    35                                  ; ----------------------------------------------------------------------------
    36                                  
    37                                  ; 03/11/2022 - Erdogan Tan (Istanbul)
    38                                  
    39                                  ; Note:	This code is a part of Retro DOS 4.0 kernel source code
    40                                  ;	(as included binary, 'MSDOS5.BIN') 
    41                                  ;	Equivalent of MSDOS 5.0 MSDOS.SYS kernel file 
    42                                  ;	
    43                                  ;	((MSDOS 6.0 kernel source code has been modified by using disassembled
    44                                  ;	MSDOS 5.0 MSDOS.SYS)) -- Disassembler: HEX-RAYS IDA Pro --
    45                                  ;	((Disassembly -Reverse engineering- reference: MSDOS 6.0 kernel src))
    46                                        
    47                                  ;------ Retro DOS v2 (v3) boot sector loads RETRODOS.SYS (MSDOS.SYS)
    48                                  ;	at 1000h:0000h and loader (initialization) part of RETRODOS kernel
    49                                  ;	moves IO.SYS (DOSBIOSCODE & DOSBIOSDATA, 'IOSYS5.BIN') to 70h:0000h.
    50                                  ;	Then SYSINIT code to the next segment (4D6h for current version)..
    51                                  ;	SYSINIT code relocates itself and DOSBIOSCODE and MSDOS.SYS
    52                                  ;	(MSDOS5.BIN) according to request/setting in 'config.sys' file.
    53                                  
    54                                  ;=============================================================================
    55                                  ; Most of comments in this file are from the original MSDOS 6.0 source code
    56                                  ;-----------------------------------------------------------------------------
    57                                  
    58                                  ; MSDOS 6.0 Kernel source files:
    59                                  ;	MSDATA.ASM, 
    60                                  ; 		(MSHEAD.ASM, MSCONST.ASM,CONST2.ASM, MS_DATA.ASM,
    61                                  ;		DOSTAB.ASM, LMSTUB.ASM, WPATCH.INC, MPATCH.ASM)
    62                                  ;	MSTABLE.ASM, MSCODE.ASM, MSDOSME.ASM (DOSMES.INC), TIME.ASM,
    63                                  ;	GETSET.ASM, PARSE.ASM, MISC.ASM, MISC2.ASM, CRIT.ASM, CPMIO.ASM,
    64                                  ;	CPMIO2.ASM, FCBIO.ASM, FCBIO2.ASM, SEARCH.ASM, PATH.ASM, IOCTL.ASM,
    65                                  ;	DELETE.ASM, RENAME.ASM, FINFO.ASM, DUP.ASM, CREATE.ASM, OPEN.ASM,
    66                                  ;	DINFO.ASM, ISEARCH.ASM, BUF.ASM, ABORT.ASM,CLOSE.ASM, DIRCALL.ASM,
    67                                  ;	DISK.ASM, DISK2.ASM, DISK3.ASM, DIR.ASM, DIR2.ASM, DEV.ASM,
    68                                  ;	MKNODE.ASM, ROM.ASM, FCB.ASM, MSCTRLC.ASM, FAT.ASM, MSPROC.ASM
    69                                  ;	ALLOC.ASM, SRVCALL.ASM, UTIL.ASM, MACRO.ASM, MACRO2.ASM, HANDLE.ASM
    70                                  ;	FILE.ASM, LOCK.ASM, ROMFIND.ASM, SHARE.ASM, MSINIT.ASM, ORIGIN.ASM
    71                                  ;
    72                                  ; MSDOS 2.0 Kernel source files:
    73                                  ; 	MSDOS.ASM (STDSW.ASM + MSHEAD.ASM + MSDATA.ASM)
    74                                  ;	MSCODE.ASM
    75                                  ;	DOSMES.ASM ... STDIO.ASM, TIME.ASM, XENIX.ASM, XENIX2.ASM
    76                                  
    77                                  ;============================================================================
    78                                  ; DOSLINK
    79                                  ;============================================================================
    80                                  ;msdos mscode dosmes misc getset dircall alloc dev dir +
    81                                  ;disk fat rom stdbuf stdcall stdctrlc stdfcb stdproc +
    82                                  ;stdio time xenix xenix2
    83                                  
    84                                  ;============================================================================
    85                                  ; This MSDOS source code is verified & modified by using IDA Pro Disassembler
    86                                  ; output in TASM syntax (July 2018 -> NASM syntax) [ IBMDOS.COM, 17/03/1987 ]
    87                                  ;============================================================================
    88                                  ;
    89                                  ; ###########################################################################
    90                                  ; #	This file is generated by The Interactive Disassembler (IDA)	    #
    91                                  ; #	Copyright (c) 2010 by Hex-Rays SA, <support@hex-rays.com>	    #
    92                                  ; #			 Licensed to: Freeware version			    #
    93                                  ; ###########################################################################
    94                                  ;
    95                                  ; Input	MD5   :	75959BC417C19135B982F7959EE9C92A
    96                                  
    97                                  ; ---------------------------------------------------------------------------
    98                                  ; File Name   :	C:\Documents and Settings\Erdoðan Tan\Desktop\MSDOS621.BIN
    99                                  ; Format      :	Binary file
   100                                  ;============================================================================
   101                                  ; MSDOS621.BIN = MSDOS.SYS, 13/02/1994, 38138 bytes (MSDOS 6.21 kernel) 2019
   102                                  ;----------------------------------------------------------------------------
   103                                  ; MSDOS5.BIN = MSDOS.SYS, 11/11/1991, 37394 bytes (MSDOS 5.0 kernel) 2022
   104                                  
   105                                  ;============================================================================
   106                                  ; MSDOS.ASM
   107                                  ;============================================================================
   108                                  
   109                                  ;TITLE   Standard MSDOS
   110                                  ;NAME    MSDOS_2
   111                                  
   112                                  ; Number of disk I/O buffers
   113                                  
   114                                  ;	INCLUDE STDSW.ASM
   115                                  ;       INCLUDE MSHEAD.ASM
   116                                  ;       INCLUDE MSDATA.ASM
   117                                  
   118                                  ;	END
   119                                  
   120                                  ;============================================================================
   121                                  ; STDSW.ASM
   122                                  ;============================================================================
   123                                  
   124                                  TRUE    EQU     0FFFFH
   125                                  FALSE   EQU     ~TRUE ; NOT TRUE
   126                                  
   127                                  ; Use the switches below to produce the standard Microsoft version or the IBM
   128                                  ; version of the operating system
   129                                  ;MSVER   EQU	false
   130                                  ;IBM     EQU	true
   131                                  ;WANG    EQU	FALSE
   132                                  ;ALTVECT EQU	FALSE
   133                                  
   134                                  ; Set this switch to cause DOS to move itself to the end of memory
   135                                  ;HIGHMEM EQU     FALSE
   136                                  
   137                                  ;	IF      IBM
   138                                  ESCCH    EQU	 0			;character to begin escape seq.
   139                                  CANCEL   EQU	 27			;Cancel with escape
   140                                  TOGLINS  EQU	TRUE			;One key toggles insert mode
   141                                  TOGLPRN  EQU	TRUE			;One key toggles printer echo
   142                                  ZEROEXT  EQU	TRUE
   143                                  ;       ELSE
   144                                  ;       IF      WANG			;Are we assembling for WANG?
   145                                  ;ESCCH	 EQU	1FH			;Yes. Use 1FH for escape character
   146                                  ;       ELSE
   147                                  ;ESCCH	 EQU	1BH
   148                                  ;       ENDIF
   149                                  ;CANCEL  EQU	"X"-"@"			;Cancel with Ctrl-X
   150                                  ;TOGLINS EQU	WANG			;Separate keys for insert mode on
   151                                  					;and off if not WANG
   152                                  ;TOGLPRN EQU	FALSE			;Separate keys for printer echo on
   153                                  					;and off
   154                                  ;ZEROEXT EQU	TRUE
   155                                  ;        ENDIF
   156                                  
   157                                  ;============================================================================
   158                                  ; MSHEAD.ASM
   159                                  ;============================================================================
   160                                  
   161                                  ;--------------------------------------------------------------
   162                                  ; TITLE   MSHEAD.ASM -- MS-DOS DEFINITIONS
   163                                  ;--------------------------------------------------------------
   164                                  
   165                                  ; MS-DOS High-performance operating system for the 8086  version 1.28
   166                                  ;        by Microsoft MSDOS development group:
   167                                  ;           Tim Paterson (Ret.)
   168                                  ;           Aaron Reynolds
   169                                  ;           Nancy Panners (Parenting)
   170                                  ;           Mark Zbikowski
   171                                  ;           Chris Peters (BIOS) (ret.)
   172                                  
   173                                  ; ****************** Revision History *************************
   174                                  ;          >> EVERY change must noted below!! <<
   175                                  ;
   176                                  ; 0.34 12/29/80 General release, updating all past customers
   177                                  ; 0.42 02/25/81 32-byte directory entries added
   178                                  ; 0.56 03/23/81 Variable record and sector sizes
   179                                  ; 0.60 03/27/81 Ctrl-C exit changes, including register save on user stack
   180                                  ; 0.74 04/15/81 Recognize I/O devices with file names
   181                                  ; 0.75 04/17/81 Improve and correct buffer handling
   182                                  ; 0.76 04/23/81 Correct directory size when not 2^N entries
   183                                  ; 0.80 04/27/81 Add console input without echo, Functions 7 & 8
   184                                  ; 1.00 04/28/81 Renumber for general release
   185                                  ; 1.01 05/12/81 Fix bug in `STORE'
   186                                  ; 1.10 07/21/81 Fatal error trapping, NUL device, hidden files, date & time,
   187                                  ;               RENAME fix, general cleanup
   188                                  ; 1.11 09/03/81 Don't set CURRENT BLOCK to 0 on open; fix SET FILE SIZE
   189                                  ; 1.12 10/09/81 Zero high half of CURRENT BLOCK after all (CP/M programs don't)
   190                                  ; 1.13 10/29/81 Fix classic "no write-through" error in buffer handling
   191                                  ; 1.20 12/31/81 Add time to FCB; separate FAT from DPT; Kill SMALLDIR; Add
   192                                  ;               FLUSH and MAPDEV calls; allow disk mapping in DSKCHG; Lots
   193                                  ;               of smaller improvements
   194                                  ; 1.21 01/06/82 HIGHMEM switch to run DOS in high memory
   195                                  ; 1.22 01/12/82 Add VERIFY system call to enable/disable verify after write
   196                                  ; 1.23 02/11/82 Add defaulting to parser; use variable escape character Don't
   197                                  ;               zero extent field in IBM version (back to 1.01!)
   198                                  ; 1.24 03/01/82 Restore fcn. 27 to 1.0 level; add fcn. 28
   199                                  ; 1.25 03/03/82 Put marker (00) at end of directory to speed searches
   200                                  ; 1.26 03/03/82 Directory buffers searched as a circular queue, current buffer
   201                                  ;               is searched first when possible to minimize I/O
   202                                  ;      03/03/82 STORE routine optimized to tack on partial sector tail as
   203                                  ;               full sector write when file is growing
   204                                  ;      03/09/82 Multiple I/O buffers
   205                                  ;      03/29/82 Two bugs:  Delete all case resets search to start at beginning
   206                                  ;               of directory (infinite loop possible otherwise), DSKRESET
   207                                  ;               must invalidate all buffers (disk and directory).
   208                                  ; 1.27 03/31/82 Installable device drivers
   209                                  ;                 Function call 47 - Get pointer to device table list
   210                                  ;                 Function call 48 - Assign CON AUX LIST
   211                                  ;      04/01/82 Spooler interrupt (INT 28) added.
   212                                  ; 1.28 04/15/82 DOS retructured to use ASSUMEs and PROC labels around system
   213                                  ;               call entries.  Most CS relative references changed to SS
   214                                  ;               relative with an eye toward putting a portion of the DOS in
   215                                  ;               ROM.  DOS source also broken into header, data and code pieces
   216                                  ;      04/15/82 GETDMA and GETVECT calls added as 24 and 32.  These calls
   217                                  ;               return the current values.
   218                                  ;      04/15/82 INDOS flag implemented for interrupt processing along with
   219                                  ;               call to return flag location (call 29)
   220                                  ;      04/15/82 Volume ID attribute added
   221                                  ;      04/17/82 Changed ABORT return to user to a long ret from a long jump to
   222                                  ;               avoid a CS relative reference.
   223                                  ;      04/17/82 Put call to STATCHK in dispatcher to catch ^C more often
   224                                  ;      04/20/82 Added INT int_upooler into loop ^S wait
   225                                  ;      04/22/82 Dynamic disk I/O buffer allocation and call to manage them
   226                                  ;               call 49.
   227                                  ;      04/23/82 Added GETDSKPTDL as call 50, similar to GETFATPT(DL), returns
   228                                  ;               address of DPB
   229                                  ;      04/29/82 Mod to WRTDEV to look for ^C or ^S at console input when
   230                                  ;               writting to console device via file I/O.  Added a console
   231                                  ;               output attribute to devices.
   232                                  ;      04/30/82 Call to en/dis able ^C check in dispatcher Call 51
   233                                  ;      04/30/82 Code to allow assignment of func 1-12 to disk files as well
   234                                  ;               as devices....  pipes, redirection now possible
   235                                  ;      04/30/82 Expanded GETLIST call to 2.0 standard
   236                                  ;      05/04/82 Change to INT int_fatal_abort callout int HARDERR.  DOS SS
   237                                  ;               (data segment) stashed in ES, INT int_fatal_abort routines must
   238                                  ;               preserve ES.  This mod so HARDERR can be ROMed.
   239                                  ; 1.29 06/01/82 Installable block and character devices as per 2.0 spec
   240                                  ;      06/04/82 Fixed Bug in CLOSE regarding call to CHKFATWRT.  It got left
   241                                  ;               out back about 1.27 or so (oops).  ARR
   242                                  ; 1.30 06/07/82 Directory sector buffering added to main DOS buffer queue
   243                                  ; 1.40 06/15/82 Tree structured directories.  XENIX Path Parser MKDIR CHDIR
   244                                  ;               RMDIR Xenix calls
   245                                  ; 1.41 06/13/82 Made GETBUFFR call PLACEBUF
   246                                  ; 1.50 06/17/82 FATs cached in buffer pool, get FAT pointer calls disappear
   247                                  ;               Frees up lots of memory.
   248                                  ; 1.51 06/24/82 BREAKDOWN modified to do EXACT one sector read/write through
   249                                  ;               system buffers
   250                                  ; 1.52 06/30/82 OPEN, CLOSE, READ, WRITE, DUP, DUP2, LSEEK implemented
   251                                  ; 1.53 07/01/82 OPEN CLOSE mod for Xenix calls, saves and gets remote dir
   252                                  ; 1.54 07/11/82 Function calls 1-12 make use of new 2.0 PDB. Init code
   253                                  ;               changed to set file handle environment.
   254                                  ; 2.00 08/01/82 Number for IBM release
   255                                  ;      01/19/83 No environ bug in EXEC
   256                                  ;      01/19/83 MS-DOS OEM INT 21 extensions (SET_OEM_HANDLER)
   257                                  ;      01/19/83 Performance bug fix in cooked write to NUL
   258                                  ;      01/27/83 Growcnt fixed for 32-bits
   259                                  ;      01/27/83 Find-first problem after create
   260                                  ; 2.01 02/17/83 International DOS
   261                                  ; 2.11 08/12/83 Dos split into several more modules for assembly on
   262                                  ;               an IBM PC
   263                                  ; 08/07/2018 - Retro DOS v3.0 by Erdogan Tan
   264                                  ; (MSHEAD.ASM, MSDOS 6.0, 1991) - mshead.asm 1.1 85/04/10 -
   265                                  ; 2.10 03/09/83 Start of NETWORK support
   266                                  ;		New Buffer structure
   267                                  ;		New Sytem file table structure
   268                                  ;		FCB moved to internal representation
   269                                  ;		DOS re-organized
   270                                  ; 2.11 04/21/83 Continuation of 2.10, preliminary Network
   271                                  ;		device interface.
   272                                  ; 2.11 08/12/83 Dos split into several more modules for assembly on
   273                                  ;               an IBM PC
   274                                  ; 2.50 09/12/83 More network stuff
   275                                  ;
   276                                  ; *************************************************************
   277                                  
   278                                  ; ----------------------------------------------------------------------------
   279                                  ; EQUATES
   280                                  
   281                                  ; Interrupt Entry Points:
   282                                  
   283                                  ; INTBASE:      ABORT
   284                                  ; INTBASE+4:    COMMAND
   285                                  ; INTBASE+8:    BASE EXIT ADDRESS
   286                                  ; INTBASE+C:    CONTROL-C ABORT
   287                                  ; INTBASE+10H:  FATAL ERROR ABORT
   288                                  ; INTBASE+14H:  BIOS DISK READ
   289                                  ; INTBASE+18H:  BIOS DISK WRITE
   290                                  ; INTBASE+1CH:  END BUT STAY RESIDENT (NOT SET BY DOS)
   291                                  ; INTBASE+20H:  SPOOLER INTERRUPT
   292                                  ; INTBASE+40H:  Long jump to CALL entry point
   293                                  
   294                                  ENTRYPOINTSEG   EQU     0Ch
   295                                  MAXDIF          EQU     0FFFh
   296                                  SAVEXIT         EQU     10
   297                                  ; 06/05/2019
   298                                  WRAPOFFSET	EQU	0FEF0h  ; (MISC.ASM, MSDOS 6.0, 1991)
   299                                  
   300                                         ; INCLUDE DOSSYM.ASM
   301                                         ; INCLUDE DEVSYM.ASM
   302                                  
   303                                  ; SUBTTL ^C, terminate/abort/exit and Hard error actions
   304                                  ; PAGE
   305                                  ; There are three kinds of context resets that can occur during normal DOS
   306                                  ; functioning:  ^C trap, terminate/abort/exit, and Hard-disk error.  These must
   307                                  ; be handles in a clean fashion that allows nested executions along with the
   308                                  ; ability to trap one's own errors.
   309                                  ;
   310                                  ; ^C trap - A process may elect to catch his own ^Cs.  This is achieved by
   311                                  ;           using the $GET_INTERRUPT_VECTOR and $SET_INTERRUPT_VECTOR as
   312                                  ;           follows:
   313                                  ;
   314                                  ;           $GET_INTERRUPT_VECTOR for INT int_ctrl_c
   315                                  ;           Save it in static memory.
   316                                  ;           $SET_INTERRUPT_VECTOR for INT int_ctrl_c
   317                                  ;
   318                                  ;           The interrupt service routine must preserve all registers and
   319                                  ;           return carry set iff the operation is to be aborted (via abort
   320                                  ;           system call), otherwise, carry is reset and the operation is
   321                                  ;           restarted.  ANY DEVIATION FROM THIS WILL LEAD TO UNRELIABLE
   322                                  ;           RESULTS.
   323                                  ;
   324                                  ;           To restore original ^C processing (done on terminate/abort/exit),
   325                                  ;           restore INT int_ctrl_c from the saved vector.
   326                                  ;
   327                                  ; Hard-disk error -- The interrupt service routine for INT int_fatal_abort must
   328                                  ;           also preserve registers and return one of three values in AL: 0 and
   329                                  ;           1 imply retry and ignore (???)  and 2 indicates an abort.  The user
   330                                  ;           himself is not to issue the abort, rather, the dos will do it for
   331                                  ;           him by simulating a normal abort/exit system call.  ANY DEVIATION
   332                                  ;           FROM THIS WILL LEAD TO UNRELIABLE RESULTS.
   333                                  ;
   334                                  ; terminate/abort/exit -- The user may not, under any circumstances trap an
   335                                  ;           abort call.  This is reserved for knowledgeable system programs.
   336                                  ;           ANY DEVIATION FROM THIS WILL LEAD TO UNRELIABLE RESULTS.
   337                                  
   338                                  ;SUBTTL SEGMENT DECLARATIONS
   339                                  
   340                                  ; The following are all of the segments used.  They are declared in the order
   341                                  ; that they should be placed in the executable
   342                                  
   343                                  ;
   344                                  ; segment ordering for MSDOS
   345                                  ;
   346                                  
   347                                  ;START           SEGMENT BYTE PUBLIC 'START'
   348                                  ;START           ENDS
   349                                  
   350                                  ;CONSTANTS       SEGMENT BYTE PUBLIC 'CONST'
   351                                  ;CONSTANTS       ENDS
   352                                  
   353                                  ;DATA            SEGMENT WORD PUBLIC 'DATA'
   354                                  ;DATA            ENDS
   355                                  
   356                                  ;CODE            SEGMENT BYTE PUBLIC 'CODE'
   357                                  ;CODE            ENDS
   358                                  
   359                                  ;LAST            SEGMENT BYTE PUBLIC 'LAST'
   360                                  ;LAST            ENDS
   361                                  
   362                                  ;DOSGROUP    GROUP   CODE,CONSTANTS,DATA,LAST
   363                                  
   364                                  ; The following segment is defined such that the data/const classes appear
   365                                  ; before the code class for ROMification
   366                                  
   367                                  ;START		SEGMENT BYTE PUBLIC 'START'
   368                                  ;           	ASSUME  CS:DOSGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING
   369                                  ;		JMP     DOSINIT
   370                                  ;START		ENDS
   371                                  
   372                                  ;============================================================================
   373                                  ; BPB.INC, MSDOS 6.0, 1991
   374                                  ;============================================================================
   375                                  ; 09/07/2018 - Retro DOS v3.0
   376                                  
   377                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   378                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   379                                  ;									   ;
   380                                  
   381                                  ;**	BIOS PARAMETER BLOCK DEFINITION
   382                                  ;
   383                                  ;	The BPB contains information about the disk structure. It dates
   384                                  ;	back to the earliest FAT systems and so FAT information is
   385                                  ;	intermingled with physical driver information.
   386                                  ;
   387                                  ;	A boot sector contains a BPB for its device; for other disks
   388                                  ;	the driver creates a BPB. DOS keeps copies of some of this
   389                                  ;	information in the DPB.
   390                                  ;
   391                                  ;	The BDS structure contains a BPB within it. 
   392                                  
   393                                  struc A_BPB
   394 00000000 ????                    .BPB_BYTESPERSECTOR:	resw	1
   395 00000002 ??                      .BPB_SECTORSPERCLUSTER:	resb	1
   396 00000003 ????                    .BPB_RESERVEDSECTORS:	resw	1
   397 00000005 ??                      .BPB_NUMBEROFFATS:	resb	1
   398 00000006 ????                    .BPB_ROOTENTRIES: 	resw	1
   399 00000008 ????                    .BPB_TOTALSECTORS:	resw	1
   400 0000000A ??                      .BPB_MEDIADESCRIPTOR:	resb	1
   401 0000000B ????                    .BPB_SECTORSPERFAT:	resw	1
   402 0000000D ????                    .BPB_SECTORSPERTRACK:	resw	1
   403 0000000F ????                    .BPB_HEADS:		resw	1
   404 00000011 ????                    .BPB_HIDDENSECTORS:	resw	1
   405 00000013 ????                    			resw	1
   406 00000015 ????                    .BPB_BIGTOTALSECTORS:	resw	1
   407 00000017 ????                    			resw	1
   408 00000019 ????????????            			resb	6	; NOTE:  many times these
   409                                  ;					; 	 6 bytes are omitted
   410                                  ;					;	 when BPB manipulations
   411                                  ;					;	 are performed!
   412                                  .size:
   413                                  endstruc
   414                                  
   415                                  ;                                                                          ;
   416                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   417                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   418                                  
   419                                  ;============================================================================
   420                                  ; BUFFER.INC, MSDOS 6.0, 1991
   421                                  ;============================================================================
   422                                  ; 04/05/2019 - Retro DOS v4.0
   423                                  
   424                                  ; <Disk I/O Buffer Header>
   425                                  
   426                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   427                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   428                                  ;									   ;
   429                                  
   430                                  ; Field definition for I/O buffer information
   431                                  
   432                                  struc BUFFINFO
   433 00000000 ????                    .buf_next:	resw 1		; Pointer to next buffer in list
   434 00000002 ????                    .buf_prev:	resw 1		; Pointer to prev buffer in list
   435 00000004 ??                      .buf_ID:	resb 1		; Drive of buffer (bit 7 = 0)
   436                                  				; SFT table index (bit 7 = 1)
   437                                  				; = FFH if buffer free
   438 00000005 ??                      .buf_flags:	resb 1		; Bit 7 = 1 if Remote file buffer
   439                                  				;	= 0 if Local device buffer
   440                                  				; Bit 6 = 1 if buffer dirty
   441                                  				; Bit 5 = Reserved
   442                                  				; Bit 4 = Search bit (bit 7 = 1)
   443                                  				; Bit 3 = 1 if buffer is DATA
   444                                  				; Bit 2 = 1 if buffer is DIR
   445                                  				; Bit 1 = 1 if buffer is FAT
   446                                  				; Bit 0 = Reserved
   447 00000006 ????????                .buf_sector:	resd 1		; Sector number of buffer (flags bit 7 = 0)
   448                                  ; The next two items are often refed as a word (flags bit 7 = 0)
   449 0000000A ??                      .buf_wrtcnt:	resb 1		; For FAT sectors, # times sector written out
   450 0000000B ????                    .buf_wrtcntinc:	resw 1		; "   "     "   , # sectors between each write
   451 0000000D ????????                .buf_DPB:	resd 1		; Pointer to drive parameters
   452 00000011 ????                    .buf_fill:	resw 1		; How full buffer is (flags bit 7 = 1)
   453 00000013 ??                      .buf_reserved:	resb 1		; make DWORD boundary for 386
   454                                  .size:	; 20 bytes
   455                                  endstruc
   456                                  
   457                                  %define buf_offset	BUFFINFO.buf_sector ; 22/07/2019
   458                                  				;For buf_flags bit 7 = 1, this is the byte
   459                                  				;offset of the start of the buffer in
   460                                  				;the file pointed to by buf_ID. Thus
   461                                  				;the buffer starts at location
   462                                  				;buf_offset in the file and contains
   463                                  				;buf_fill bytes.
   464                                  
   465                                  BUFINSIZ        EQU     BUFFINFO.size
   466                                  
   467                                  buf_Free	EQU	0FFh	; buf_id of free buffer
   468                                  
   469                                  ;Flag byte masks
   470                                  buf_isnet	EQU	10000000B
   471                                  buf_dirty	EQU	01000000B
   472                                  ;***
   473                                  buf_visit	EQU	00100000B
   474                                  ;***
   475                                  buf_snbuf	EQU	00010000B
   476                                  
   477                                  buf_isDATA	EQU	00001000B
   478                                  buf_isDIR	EQU	00000100B
   479                                  buf_isFAT	EQU	00000010B
   480                                  buf_type_0	EQU	11110001B	; AND sets type to "none"
   481                                  
   482                                  buf_NetID	EQU	BUFINSIZ
   483                                  
   484                                  ;                                                                          ;
   485                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   486                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   487                                  
   488                                  ;============================================================================
   489                                  ; DOSSSYM.INC, MSDOS 6.0, 1991
   490                                  ;============================================================================
   491                                  ; 04/05/2019 - Retro DOS v4.0
   492                                  
   493                                  ; <Control character definitions>
   494                                  
   495                                  c_DEL	    EQU     7Fh 	;    ASCII rubout or delete previous char
   496                                  c_BS	    EQU     08h 	; ^H ASCII backspace
   497                                  c_CR	    EQU     0Dh 	; ^M ASCII carriage return
   498                                  c_LF	    EQU     0Ah 	; ^J ASCII linefeed
   499                                  c_ETB	    EQU     17h 	; ^W ASCII end of transmission
   500                                  c_NAK	    EQU     15h 	; ^U ASCII negative acknowledge
   501                                  c_ETX	    EQU     03h 	; ^C ASCII end of text
   502                                  c_HT	    EQU     09h 	; ^I ASCII tab
   503                                  
   504                                  ; <User stack inside of system call>
   505                                  ; Location of user registers relative user stack pointer
   506                                  
   507                                  struc	user_env   ; user_environ
   508 00000000 ????                    .user_AX: resw 1
   509 00000002 ????                    .user_BX: resw 1
   510 00000004 ????                    .user_CX: resw 1
   511 00000006 ????                    .user_DX: resw 1
   512 00000008 ????                    .user_SI: resw 1
   513 0000000A ????                    .user_DI: resw 1
   514 0000000C ????                    .user_BP: resw 1
   515 0000000E ????                    .user_DS: resw 1
   516 00000010 ????                    .user_ES: resw 1
   517 00000012 ????                    .user_IP: resw 1
   518 00000014 ????                    .user_CS: resw 1
   519 00000016 ????                    .user_F:  resw 1
   520                                  .size:
   521                                  endstruc
   522                                  
   523                                  ; ---- <Disk map> ----
   524                                  
   525                                  ;	MSDOS partitions the disk into 4 sections:
   526                                  ;
   527                                  ;  phys sector 0:   +-------------------+
   528                                  ;	|	    | boot/reserved	|
   529                                  ;	|	    +-------------------+
   530                                  ;	|	    |  File allocation	|
   531                                  ;	v	    |	   table(s)	|
   532                                  ;		    |  (multiple copies |
   533                                  ;		    |	  are kept)	|
   534                                  ;		    +-------------------+
   535                                  ;		    |	  Directory	|
   536                                  ;		    +-------------------+
   537                                  ;		    |	  File space	|
   538                                  ;		    +-------------------+
   539                                  ;		    |	Unaddressable	|
   540                                  ;		    |  (to end of disk) |
   541                                  ;		    +-------------------+
   542                                  ;
   543                                  ; All partition boundaries are sector boundaries.  The size of the FAT is
   544                                  ; adjusted to maximize the file space addressable.
   545                                  
   546                                  ; <File allocation Table information>
   547                                  
   548                                  ; The File Allocation Table uses a 12-bit entry for each allocation unit on
   549                                  ; the disk.  These entries are packed, two for every three bytes.  The contents
   550                                  ; of entry number N is found by 1) multiplying N by 1.5; 2) adding the result
   551                                  ; to the base address of the Allocation Table; 3) fetching the 16-bit word
   552                                  ; at this address; 4) If N was odd (so that N*1.5 was not an integer), shift
   553                                  ; the word right four bits; 5) mask to 12 bits (AND with 0FFF hex).  Entry
   554                                  ; number zero is used as an end-of-file trap in the OS and is passed to the
   555                                  ; BIOS to help determine disk format.  Entry 1 is reserved for future use.
   556                                  ; The first available allocation unit is assigned entry number two, and even
   557                                  ; though it is the first, is called cluster 2.	Entries greater than 0FF8H
   558                                  ; (12-bit fats) or 0FFF8H (16-bit fats) are end of file marks; entries of zero
   559                                  ; are unallocated.  Otherwise, the contents of a FAT entry is the number of
   560                                  ; the next cluster in the file.
   561                                  ;
   562                                  ; Clusters with bad sectors are tagged with FF7H.  Any non-zero number would
   563                                  ; do because these clusters show as allocated, but are not part of any
   564                                  ; allocation chain and thus will never be allocated to a file.	A particular
   565                                  ; number is selected so that disk checking programs know what to do (ie.  a
   566                                  ; cluster with entry FF7H which is not in a chain is not an error).
   567                                  
   568                                  ;**	Character Type Flags
   569                                  ;
   570                                  ;	These flags are used in a lookup table indexed by the character code.
   571                                  ;	They're used to quickly classify characters when parsing paths.
   572                                  ;	I think that these are only used to parse FCBs - jgl
   573                                  
   574                                  FCHK	equ 1		; I think this means "normal name char, no chks needed" -jgl
   575                                  FDELIM	equ 2		; is a delimiter
   576                                  FSPCHK	equ 4		; set if character is not a space or equivalent
   577                                  FFCB	equ 8		; is valid in an FCB
   578                                  
   579                                  ;** Bit definitions for DOS_FLAG
   580                                  ;
   581                                  ; Bit 0 - this is set when a $open call is made from $exec. This is used in
   582                                  ;	  $open to indicate to the redirector that this open is being made
   583                                  ;	  by an exec call.
   584                                  ;
   585                                  ; Bit 2
   586                                  ;
   587                                  ; M003, M027:
   588                                  ;
   589                                  ; The start up code of MS PASCAL 3.2 programs depend on the 1M address wrap 
   590                                  ; if they load below 64K. This is a likely possiblity in DOS 5.x with DOS in
   591                                  ; the HMA. By default DOS will turn A20 OFF before Xferring control to the
   592                                  ; user program in the case of an Exec call. The next call to DOS will turn
   593                                  ; A20 line ON. It has been observed that MS PASCAL 3.2 start up does an int
   594                                  ; 21 ah=25h call before executing the faulty code. This will turn A20 On. 
   595                                  ; In order to support this we will set Bit 2 of this flag in the DOS exec
   596                                  ; call (msproc.asm) if DOS is running in the HMA. In $set_interrupt_vector in
   597                                  ; getset.asm A20OFF_COUNT is set to 1 if bit 2 of DOS_FLAG was previously set 
   598                                  ; by a call to exec and if A20OFF_COUNT is 0. In msdisp.asm, if A20OFF_COUNT 
   599                                  ; is non zero then A20 will be turned OFF before returning to the user. 
   600                                  ; Bit 2 will be unconditionally cleared here.
   601                                  ;
   602                                  ; M009, M027:
   603                                  ;
   604                                  ; Mace utilities MKEYRATE.COM version 1.0 copyright 1987 is an execpacked 
   605                                  ; program converted to a com file. Therefore if DOS is loaded high and if 
   606                                  ; this program is loaded below 64K it will blurt out "packed file is corrupt".
   607                                  ; This program does an int 21 ah=49h before executing the buggy execpacked
   608                                  ; code. This int21 call turns a20 on and hence the problem. In $dealloc
   609                                  ; alloc.asm A20OFF_COUNT is set to 1 if bit 2 of DOS_FLAG was previously set 
   610                                  ; by a call to exec and if A20OFF_COUNT is 0. In msdisp.asm, if A20OFF_COUNT 
   611                                  ; is non zero then A20 will be turned OFF before returning to the user. 
   612                                  ; Bit 2 will be unconditionally cleared here.
   613                                  
   614                                  EXECOPEN	EQU	00000001b	; bit 0 of DOS_FLAG
   615                                  SUPPRESS_WINA20	EQU	00000010b	; M025
   616                                  EXECA20OFF	EQU	00000100b	; bit 2 of DOS_FLAG
   617                                  
   618                                  ;============================================================================
   619                                  ; VECTOR.INC, MSDOS 6.0, 1991
   620                                  ;============================================================================
   621                                  ; 04/05/2019 - Retro DOS v4.0
   622                                  
   623                                  ; 09/07/2018 - Retro DOS v3.0 (VECTOR.INC, MSDOS 3.3, 1987)
   624                                  
   625                                  ; <interrupt definitions>
   626                                  
   627                                  INTTAB          EQU     20H
   628                                  INTBASE         EQU     4 * INTTAB
   629                                  ENTRYPOINT      EQU     INTBASE+40H
   630                                  
   631                                  ;	IF      ALTVECT
   632                                  ;ALTTAB  EQU     0F0H
   633                                  ;ALTBASE EQU     4 * ALTTAB
   634                                  ;	ENDIF
   635                                  
   636                                  ;
   637                                  ; interrupt assignments
   638                                  ;
   639                                  ;	IF	NOT ALTVECT
   640                                  int_abort	    EQU     INTTAB	; abort process
   641                                  int_command	    EQU     int_abort+1 ; call MSDOS
   642                                  int_terminate	    EQU     int_abort+2 ; int to terminate address
   643                                  int_ctrl_c	    EQU     int_abort+3 ; ^c trapper
   644                                  int_fatal_abort     EQU     int_abort+4 ; hard disk error
   645                                  int_disk_read	    EQU     int_abort+5 ; logical sector disk read
   646                                  int_disk_write	    EQU     int_abort+6 ; logical sector disk write
   647                                  int_keep_process    EQU     int_abort+7 ; terminate program and stay
   648                                  					; resident
   649                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   650                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   651                                  ;									   ;
   652                                  int_spooler	    EQU     int_abort+8 ; spooler call
   653                                  int_fastcon	    EQU     int_abort+9 ; fast CON interrupt
   654                                  int_IBM 	    EQU     int_abort+10; critical section maintenance
   655                                  ;									   ;
   656                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   657                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   658                                  ;	ELSE
   659                                  ;int_abort	    EQU     INTTAB	; abort process
   660                                  ;int_command	    EQU     int_abort+1 ; call MSDOS
   661                                  ;int_terminate	    EQU     ALTTAB	; int to terminate address
   662                                  ;int_ctrl_c	    EQU     int_terminate+1 ; ^c trapper
   663                                  ;int_fatal_abort    EQU     int_terminate+2 ; hard disk error
   664                                  ;int_disk_read	    EQU     int_abort+5 ; logical sector disk read
   665                                  ;int_disk_write	    EQU     int_abort+6 ; logical sector disk write
   666                                  ;int_keep_process   EQU     int_abort+7 ; terminate program and stay resident
   667                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   668                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   669                                  ;									   ;
   670                                  ;int_spooler	    EQU     int_terminate+3 ; spooler call
   671                                  ;int_fastcon	    EQU     int_abort+9 ; fast CON interrupt
   672                                  ;									   ;
   673                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   674                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   675                                  ;	ENDIF
   676                                  
   677                                  addr_int_abort		EQU    4 * int_abort
   678                                  addr_int_command	EQU    4 * int_command
   679                                  addr_int_terminate	EQU    4 * int_terminate
   680                                  addr_int_ctrl_c 	EQU    4 * int_ctrl_c
   681                                  addr_int_fatal_abort	EQU    4 * int_fatal_abort
   682                                  addr_int_disk_read	EQU    4 * int_disk_read
   683                                  addr_int_disk_write	EQU    4 * int_disk_write
   684                                  addr_int_keep_process	EQU    4 * int_keep_process
   685                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   686                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   687                                  ;									   ;
   688                                  addr_int_spooler	EQU    4 * int_spooler
   689                                  addr_int_fastcon	EQU    4 * int_fastcon
   690                                  addr_int_ibm		EQU    4 * int_IBM
   691                                  ;									   ;
   692                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   693                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   694                                  
   695                                  ;============================================================================
   696                                  ; DIRENT.INC, MSDOS 6.0, 1991
   697                                  ;============================================================================
   698                                  ; 04/05/2019 - Retro DOS v4.0
   699                                  
   700                                  ; BREAK <Directory entry>
   701                                  
   702                                  ;
   703                                  ;       +---------------------------+
   704                                  ;       |  (12 BYTE) filename/ext   |       0       0
   705                                  ;       +---------------------------+
   706                                  ;       |     (BYTE) attributes     |       11      B
   707                                  ;       +---------------------------+
   708                                  ;       |    (10 BYTE) reserved     |       12      C
   709                                  ;       +---------------------------+
   710                                  ;       | (WORD) time of last write |       22      16
   711                                  ;       +---------------------------+
   712                                  ;       | (WORD) date of last write |       24      18
   713                                  ;       +---------------------------+
   714                                  ;       |   (WORD) First cluster    |       26      1A
   715                                  ;       +---------------------------+
   716                                  ;       |     (DWORD) file size     |       28      1C
   717                                  ;       +---------------------------+
   718                                  ;
   719                                  ;   First byte of filename  = E5 -> free directory entry
   720                                  ;                           = 00 -> end of allocated directory
   721                                  ;   Time:   Bits 0-4=seconds/2, bits 5-10=minute, 11-15=hour
   722                                  ;   Date:   Bits 0-4=day, bits 5-8=month, bits 9-15=year-1980
   723                                  ;
   724                                  struc dir_entry
   725 00000000 <res Bh>                .dir_name:	resb 11			; file name
   726 0000000B ??                      .dir_attr:	resb 1			; attribute bits
   727 0000000C ????                    .dir_codepg:	resw 1			; code page DOS 4.00
   728 0000000E ????                    .dir_extcluster: resw 1			; extended attribute starting cluster
   729 00000010 ??                      .dir_attr2:	resb 1			; reserved
   730 00000011 ??????????              .dir_pad:	resb 5			; reserved for expansion
   731 00000016 ????                    .dir_time:	resw 1			; time of last write
   732 00000018 ????                    .dir_date:	resw 1			; date of last write
   733 0000001A ????                    .dir_first:	resw 1			; first allocation unit of file
   734 0000001C ????                    .dir_size_l:	resw 1			; low 16 bits of file size
   735 0000001E ????                    .dir_size_h:	resw 1			; high 16 bits of file size
   736                                  .size:
   737                                  endstruc
   738                                  
   739                                  attr_read_only      EQU      1h
   740                                  attr_hidden         EQU      2h
   741                                  attr_system         EQU      4h
   742                                  attr_volume_id      EQU      8h
   743                                  attr_directory      EQU     10h
   744                                  attr_archive        EQU     20h
   745                                  attr_device	    EQU     40h	; This is a VERY special bit.
   746                                  				;   NO directory entry on a disk EVER
   747                                  				;   has this bit set. It is set non-zero
   748                                  				;   when a device is found by GETPATH
   749                                  
   750                                  attr_all            EQU     attr_hidden+attr_system+attr_directory
   751                                                                          ; OR of hard attributes for FINDENTRY
   752                                  
   753                                  attr_ignore         EQU     attr_read_only+attr_archive
   754                                                                          ; ignore this(ese) attribute(s)
   755                                                                          ; during search first/next
   756                                  
   757                                  attr_changeable     EQU     attr_read_only+attr_hidden+attr_system+attr_archive
   758                                                                          ; changeable via CHMOD
   759                                  
   760                                  DIRFREE		equ	0E5h	; stored in dir_name[0] to indicate free slot
   761                                  
   762                                  ;============================================================================
   763                                  ; DPB.INC, MSDOS 6.0, 1991
   764                                  ;============================================================================
   765                                  ; 24/04/2019 - Retro DOS v4.0
   766                                  
   767                                  ; 19/07/2018 - Retro DOS v3.0 (DPB.INC, MSDOS 3.3, 1987)
   768                                  ; 07/07/2018 - Retro DOS v3.0 (DPB.INC, MSDOS 6.0, 1991)
   769                                  
   770                                  ; ---------------------------------------------------------------------------
   771                                  ;**	DPB - Drive Parameter Block
   772                                  ;
   773                                  ;	BUGBUG - this isn't authorative - it's my probably incomplete and
   774                                  ;	possibly inaccurate deductions from code study... - jgl
   775                                  ;
   776                                  ;	The DPB is DOS's main structure for describing block devices.
   777                                  ;	It contains info about the "Drive" intermingled with info about
   778                                  ;	the FAT file system which is presumably on the drive.  I don't know
   779                                  ;	how those fields are used if it's not the FAT file system - BUGBUG
   780                                  ;
   781                                  ;	The DPBs are statically allocated and chained off of DPBHead.
   782                                  ;	Users scan this chain looking for a match on DPB_DRIVE.
   783                                  ;	The DPBs are built at init time from info in the SYSDEV structure.
   784                                  ; ---------------------------------------------------------------------------
   785                                  
   786                                  struc	DPB
   787 00000000 ??                      .DRIVE:		resb 1		; Logical drive # assoc with DPB (A=0,B=1,...)
   788 00000001 ??                      .UNIT:		resb 1		; Driver unit number of DPB
   789 00000002 ????                    .SECTOR_SIZE:	resw 1		; Size of physical sector in bytes
   790 00000004 ??                      .CLUSTER_MASK:	resb 1		; Sectors/cluster - 1
   791 00000005 ??                      .CLUSTER_SHIFT:	resb 1		; Log2 of sectors/cluster
   792 00000006 ????                    .FIRST_FAT:	resw 1		; Starting record of FATs
   793 00000008 ??                      .FAT_COUNT:	resb 1		; Number of FATs for this drive
   794 00000009 ????                    .ROOT_ENTRIES:	resw 1		; Number of directory entries
   795 0000000B ????                    .FIRST_SECTOR:	resw 1		; First sector of first cluster
   796 0000000D ????                    .MAX_CLUSTER:	resw 1		; Number of clusters on drive + 1
   797                                  ; MSDOS 3.3
   798                                  ;.FAT_SIZE:	resb 1		; Number of records occupied by FAT
   799                                  ; MSDOS 6.0
   800 0000000F ????                    .FAT_SIZE:	resw 1		; Number of records occupied by FAT
   801 00000011 ????                    .DIR_SECTOR:	resw 1		; Starting record of directory
   802 00000013 ????????                .DRIVER_ADDR:	resd 1		; Pointer to driver
   803 00000017 ??                      .MEDIA:		resb 1		; Media byte
   804 00000018 ??                      .FIRST_ACCESS:	resb 1		; This is initialized to -1 to force a media
   805                                  				; check the first time this DPB is used
   806 00000019 ????????                .NEXT_DPB:	resd 1		; Pointer to next Drive parameter block
   807 0000001D ????                    .NEXT_FREE:	resw 1		; Cluster # of last allocated cluster
   808 0000001F ????                    .FREE_CNT:	resw 1		; Count of free clusters, -1 if unknown
   809                                  .size:
   810                                  endstruc
   811                                  
   812                                  DPBSIZ  EQU     DPB.size	; Size of the structure in bytes
   813                                  
   814                                  DSKSIZ  EQU	DPB.MAX_CLUSTER	; Size of disk (temp used during init only)
   815                                  
   816                                  ;                                                                          ;
   817                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   818                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   819                                  
   820                                  ;============================================================================
   821                                  ; SF.INC, MSDOS 6.0, 1991
   822                                  ;============================================================================
   823                                  ; 25/04/2019 - Retro DOS v4.0
   824                                  ; 07/07/2018 - Retro DOS v3.0
   825                                  
   826                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   827                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   828                                  ;                                                                          ;
   829                                  
   830                                  ; ---------------------------------------------------------------------------
   831                                  ;**	SF.INC - System File Table
   832                                  ;
   833                                  ;   AN000   version 4.00   Jan. 1988
   834                                  ;   AN003   PTM 3680 --  make NAME offset the same as before (<=3.30)
   835                                  ;   AN009   PTM 3839	 reorder SFT for MS WINDOWS
   836                                  ; ---------------------------------------------------------------------------
   837                                  ;**	System File Table SuperStructure
   838                                  ;
   839                                  ;	The system file table entries are allocated in contiguous groups.
   840                                  ;	There may be more than one such groups; the SF "superstructure"
   841                                  ;	tracks the groups.
   842                                  ; ---------------------------------------------------------------------------
   843                                  
   844                                  struc	SFT
   845 00000000 ????????                .SFLink:	resd 1
   846 00000004 ????                    .SFCount:	resw 1		; number of entries
   847 00000006 ????                    .SFTable:	resw 1		; beginning of array of the following
   848                                  .size:
   849                                  endstruc
   850                                  
   851                                  ; ---------------------------------------------------------------------------
   852                                  ;**	System file table entry
   853                                  ;
   854                                  ;	These are the structures which are at SFTABLE in the SF structure.
   855                                  ; ---------------------------------------------------------------------------
   856                                  
   857                                  ; 25/04/2019 - Retro DOS v4.0
   858                                  
   859                                  struc SF_ENTRY
   860 00000000 ????                    .sf_ref_count:	resw 1		; number of processes sharing entry
   861                                  				;   if FCB then ref count
   862 00000002 ????                    .sf_mode:	resw 1		; mode of access or high bit on if FCB
   863 00000004 ??                      .sf_attr:	resb 1		; attribute of file
   864 00000005 ????                    .sf_flags:	resw 1		;Bits 8-15
   865                                  				; Bit 15 = 1 if remote file
   866                                  				;	 = 0 if local file or device
   867                                  				; Bit 14 = 1 if date/time is not to be
   868                                  				;   set from clock at CLOSE.  Set by
   869                                  				;   FILETIMES and FCB_CLOSE.  Reset by
   870                                  				;   other reseters of the dirty bit
   871                                  				;   (WRITE)
   872                                  				; Bit 13 = Pipe bit (reserved)
   873                                  				;
   874                                  				; Bits 0-7 (old FCB_devid bits)
   875                                  				; If remote file or local file, bit
   876                                  				; 6=0 if dirty Device ID number, bits
   877                                  				; 0-5 if local file.
   878                                  				; bit 7=0 for local file, bit 7
   879                                  				;      =1 for local I/O device
   880                                  				; If local I/O device, bit 6=0 if EOF (input)
   881                                  				;		Bit 5=1 if Raw mode
   882                                  				;		Bit 0=1 if console input device
   883                                  				;		Bit 1=1 if console output device
   884                                  				;		Bit 2=1 if null device
   885                                  				;		Bit 3=1 if clock device
   886 00000007 ????????                .sf_devptr:	resd	1	; Points to DPB if local file, points
   887                                  				; to device header if local device,
   888                                  				; points to net device header if
   889                                  				; remote
   890 0000000B ????                    .sf_firclus:	resw	1	; First cluster of file (bit 15 = 0)
   891 0000000D ????                    .sf_time:	resw	1	; Time associated with file
   892 0000000F ????                    .sf_date:	resw	1	; Date associated with file
   893 00000011 ????????                .sf_size:	resd 	1	; Size associated with file
   894 00000015 ????????                .sf_position:	resd	1	; Read/Write pointer or LRU count for FCBs
   895                                  
   896                                  ; Starting here, the next 7 bytes may be used by the file system to store
   897                                  ; an ID
   898                                  
   899                                  ; 09/07/2018 - Retro DOS v3.0
   900                                  
   901                                  ; MSDOS 3.3 SF.INC, 1987
   902                                  ;.sf_cluspos:	resw	1	; Position of last cluster accessed
   903                                  ;.sf_lstclus	resw	1	; Last cluster accessed
   904                                  ;.sf_dirsec:	resw	1	; Sector number of directory sector
   905                                  ;				; for this file
   906                                  ;.sf_dirpos:	resb	1	; Offset of this entry in the above
   907                                  
   908                                  ; MSDOS 6.0, SF.INC, 1991
   909 00000019 ????                    .sf_cluspos:	resw	1	; Position of last cluster accessed
   910 0000001B ????????                .sf_dirsec:	resd	1	; Sector number of directory sector
   911                                  				; for this file
   912 0000001F ??                      .sf_dirpos:	resb	1	; Offset of this entry in the above
   913                                  
   914                                  ; End of 7 bytes of file-system specific info.
   915                                  
   916 00000020 <res Bh>                .sf_name:	resb	11	; 11 character name that is in the
   917                                  				; directory entry.  This is used by
   918                                  				; close to detect file deleted and
   919                                  				; disk changed errors.
   920                                  ; SHARING INFO
   921 0000002B ????????                .sf_chain:	resd	1	; link to next SF
   922 0000002F ????                    .sf_UID:	resw	1
   923 00000031 ????                    .sf_PID:	resw	1
   924 00000033 ????                    .sf_MFT:	resw	1
   925                                  
   926                                  ; MSDOS 6.0, SF.INC, 1991
   927 00000035 ????                    .sf_lstclus:	resw	1	;AN009; Last cluster accessed
   928 00000037 ????????                .sf_IFS_HDR:	resd	1
   929                                  
   930                                  .size:
   931                                  endstruc
   932                                  
   933                                  ; 20/07/2018
   934                                  ; MSDOS 3.3, SF.INC, 1987
   935                                  %define sf_netid   SF_ENTRY.sf_cluspos    ; byte
   936                                  %define sf_OpenAge SF_ENTRY.sf_position+2 ; word
   937                                  %define sf_LRU	   SF_ENTRY.sf_position	  ; word
   938                                  ; MSDOS 6.0, SF.INC, 1991
   939                                  %define sf_fsda	     SF_ENTRY.sf_cluspos  ; byte ;DOS 4.00
   940                                  %define sf_serial_ID SF_ENTRY.sf_firclus  ; word ;DOS 4.00
   941                                  
   942                                  ; 19/07/2018
   943                                  ; MSDOS 3.3, SF.INC, 1987
   944                                  
   945                                  sf_default_number  EQU	5
   946                                  
   947                                  ; Note that we need to mark an SFT as being busy for OPEN/CREATE.  This is
   948                                  ; because an INT 24 may prevent us from 'freeing' it.  We mark this as such
   949                                  ; by placing a -1 in the ref_count field.
   950                                  
   951                                  sf_busy EQU -1
   952                                  
   953                                  ; mode mask for FCB detection
   954                                  sf_isFCB		EQU	1000000000000000B
   955                                  
   956                                  ; Flag word masks
   957                                  sf_isnet		EQU	1000000000000000B
   958                                  sf_close_nodate 	EQU	0100000000000000B
   959                                  sf_pipe 		EQU	0010000000000000B
   960                                  sf_no_inherit		EQU	0001000000000000B
   961                                  sf_net_spool		EQU	0000100000000000B
   962                                  
   963                                  ; 25/04/2019
   964                                  sf_entry_size equ SF_ENTRY.size ; 59 (MSDOS 6.0)
   965                                  
   966                                  ; ---------------------------------------------------------------------------
   967                                  ; Local file/device flag masks
   968                                  ; ---------------------------------------------------------------------------
   969                                  
   970                                  devid_file_clean        EQU     40h     ; true if file and not written
   971                                  devid_file_mask_drive   EQU     3Fh     ; mask for drive number
   972                                  
   973                                  devid_device            EQU     80h     ; true if a device
   974                                  devid_device_EOF        EQU     40h     ; true if end of file reached
   975                                  devid_device_raw        EQU     20h     ; true if in raw mode
   976                                  devid_device_special    EQU     10h     ; true if special device
   977                                  devid_device_clock      EQU     08h     ; true if clock device
   978                                  devid_device_null       EQU     04h     ; true if null device
   979                                  devid_device_con_out    EQU     02h     ; true if console output
   980                                  devid_device_con_in     EQU     01h     ; true if consle input
   981                                  
   982                                  ; ---------------------------------------------------------------------------
   983                                  ; structure of devid field as returned by IOCTL is:
   984                                  ;
   985                                  ;       BIT     7   6   5   4   3   2   1   0
   986                                  ;             |---|---|---|---|---|---|---|---|
   987                                  ;             | I | E | R | S | I | I | I | I |
   988                                  ;             | S | O | A | P | S | S | S | S |
   989                                  ;             | D | F | W | E | C | N | C | C |
   990                                  ;             | E |   |   | C | L | U | O | I |
   991                                  ;             | V |   |   | L | K | L | T | N |
   992                                  ;             |---|---|---|---|---|---|---|---|
   993                                  ;       ISDEV = 1 if this channel is a device
   994                                  ;             = 0 if this channel is a disk file
   995                                  ;
   996                                  ;       If ISDEV = 1
   997                                  ;
   998                                  ;             EOF = 0 if End Of File on input
   999                                  ;             RAW = 1 if this device is in Raw mode
  1000                                  ;                 = 0 if this device is cooked
  1001                                  ;             ISCLK = 1 if this device is the clock device
  1002                                  ;             ISNUL = 1 if this device is the null device
  1003                                  ;             ISCOT = 1 if this device is the console output
  1004                                  ;             ISCIN = 1 if this device is the console input
  1005                                  ;
  1006                                  ;       If ISDEV = 0
  1007                                  ;             EOF = 0 if channel has been written
  1008                                  ;             Bits 0-5  are  the  block  device  number  for
  1009                                  ;                 the channel (0 = A, 1 = B, ...)
  1010                                  ; ---------------------------------------------------------------------------
  1011                                  
  1012                                  devid_ISDEV     EQU     80h
  1013                                  devid_EOF       EQU     40h
  1014                                  devid_RAW       EQU     20h
  1015                                  devid_SPECIAL   EQU     10H
  1016                                  devid_ISCLK     EQU     08h
  1017                                  devid_ISNUL     EQU     04h
  1018                                  devid_ISCOT     EQU     02h
  1019                                  devid_ISCIN     EQU     01h
  1020                                  
  1021                                  devid_block_dev EQU     1Fh             ; mask for block device number
  1022                                  
  1023                                  ;============================================================================
  1024                                  ; PDB.INC, MSDOS 6.0, 1991
  1025                                  ;============================================================================
  1026                                  ; 04/05/2019 - Retro DOS v4.0
  1027                                  ; 08/07/2018 - Retro DOS v3.0
  1028                                  
  1029                                  ; ---------------------------------------------------------------------------
  1030                                  ; BREAK <Process data block>
  1031                                  ; ---------------------------------------------------------------------------
  1032                                  ;**	Process data block (otherwise known as program header)
  1033                                  ;
  1034                                  
  1035                                  ;	These offset are documented in the MSDOS Encyclopedia, so nothing
  1036                                  ;	can be rearranged here, ever. Reserved areas are probably safe
  1037                                  ;	for use.
  1038                                  ; ---------------------------------------------------------------------------
  1039                                  
  1040                                  FILPERPROC	EQU     20
  1041                                  
  1042                                  struc PDB	; Process_data_block
  1043 00000000 ????                    .EXIT_CALL:	resw 1   	; INT int_abort system terminate
  1044 00000002 ????                    .BLOCK_LEN:	resw 1		; size of execution block
  1045 00000004 ??                                      resb 1
  1046 00000005 ??????????              .CPM_CALL:	resb 5		; ancient call to system
  1047 0000000A ????????                .EXIT:		resd 1		; pointer to exit routine
  1048 0000000E ????????                .CTRL_C:	resd 1		; pointer to ^C routine
  1049 00000012 ????????                .FATAL_ABORT:	resd 1		; pointer to fatal error
  1050 00000016 ????                    .PARENT_PID:	resw 1		; PID of parent (terminate PID)
  1051 00000018 <res 14h>               .JFN_TABLE:     resb FILPERPROC ; indices into system table
  1052 0000002C ????                    .ENVIRON:	resw 1		; seg addr of environment
  1053 0000002E ????????                .USER_STACK:	resd 1		; stack of self during system calls
  1054 00000032 ????                    .JFN_Length:	resw 1		; number of handles allowed
  1055 00000034 ????????                .JFN_Pointer:	resd 1		; pointer to JFN table
  1056 00000038 ????????                .Next_PDB:	resd 1		; pointer to nested PDB's
  1057 0000003C ??                      .InterCon:	resb 1	; MSDOS 6.0 ; *** jh-3/28/90 *** 
  1058 0000003D ??                      .Append:	resb 1	; MSDOS 6.0 ; *** Not sure if still used ***
  1059 0000003E ????                    .Novell_Used:	resb 2	; MSDOS 6.0 ; Novell shell (redir) uses these
  1060 00000040 ????                    .Version:	resw 1	; MSDOS 6.0 ; DOS version reported to this app
  1061 00000042 <res Eh>                .PAD1:		resb 14 ; 0Eh
  1062 00000050 ??????????              .CALL_SYSTEM:	resb 5		; portable method of system call
  1063 00000055 ??????????????          .PAD2:		resb 7		; reserved so FCB 1 can be used as
  1064                                  				;  an extended FCB
  1065                                  ;endstruc 	; MSDOS 3.3
  1066                                  	  	; MSDOS 6.0
  1067 0000005C <res 10h>               .FCB1:		resb 16 ; 10h	; default FCB 1
  1068 0000006C <res 10h>               .FCB2:		resb 16 ; 10h	; default FCB 2
  1069 0000007C ????????                .PAD3:		resb 4		; not sure if this is used by PDB_FCB2
  1070 00000080 <res 80h>               .TAIL:		resb 128	; command tail and default DTA
  1071                                  endstruc
  1072                                  
  1073                                  ;============================================================================
  1074                                  ; EXE.INC, MSDOS 6.0, 1991
  1075                                  ;============================================================================
  1076                                  ; 04/05/2019 - Retro DOS v4.0
  1077                                  
  1078                                  ;**	EXE.INC - Definitions for the EXEC command and EXE files
  1079                                  ; ---------------------------------------------------------------------------
  1080                                  ; The following get used as arguments to the EXEC system call.  They indicate
  1081                                  ; whether or not the program is executed or whether or not a program header
  1082                                  ; gets created.
  1083                                  
  1084                                  exec_func_no_execute EQU 1	; no execute bit
  1085                                  exec_func_overlay    EQU 2	; overlay bit
  1086                                  
  1087                                  struc EXEC0
  1088 00000000 ????                    .ENVIRON:	resw 1		; seg addr of environment
  1089 00000002 ????????                .COM_LINE:	resd 1		; pointer to asciz command line
  1090 00000006 ????????                .5C_FCB:	resd 1		; default fcb at 5C
  1091 0000000A ????????                .6C_FCB:	resd 1		; default fcb at 6C
  1092                                  .size:
  1093                                  endstruc
  1094                                  
  1095                                  struc EXEC1
  1096 00000000 ????                    .ENVIRON:	resw 1		; seg addr of environment
  1097 00000002 ????????                .COM_LINE:	resd 1		; pointer to asciz command line
  1098 00000006 ????????                .5C_FCB:	resd 1		; default fcb at 5C
  1099 0000000A ????????                .6C_FCB:	resd 1		; default fcb at 6C
  1100 0000000E ????                    .SP:		resw 1		; stack pointer of program
  1101 00000010 ????                    .SS:		resw 1		; stack seg register of program
  1102 00000012 ????                    .IP:		resw 1		; entry point IP
  1103 00000014 ????                    .CS:		resw 1		; entry point CS
  1104                                  .size:
  1105                                  endstruc
  1106                                  
  1107                                  struc EXEC3
  1108 00000000 ????                    .load_addr:	resw 1		; seg address of load point
  1109 00000002 ????                    .reloc_fac:	resw 1		; relocation factor
  1110                                  endstruc
  1111                                  
  1112                                  ;**	Exit codes (in upper byte) for terminating programs
  1113                                  
  1114                                  EXIT_TERMINATE		EQU	0
  1115                                  EXIT_ABORT		EQU	0
  1116                                  EXIT_CTRL_C		EQU	1
  1117                                  EXIT_HARD_ERROR 	EQU	2
  1118                                  EXIT_KEEP_PROCESS	EQU	3
  1119                                  
  1120                                  ;**	EXE File Header Description
  1121                                  
  1122                                  struc EXE
  1123 00000000 ????                    .signature:   resw 1		; must contain 4D5A (yay zibo!)
  1124 00000002 ????                    .len_mod_512: resw 1		; low 9 bits of length
  1125 00000004 ????                    .pages:       resw 1		; number of 512b pages in file
  1126 00000006 ????                    .rle_count:   resw 1		; count of reloc entries
  1127 00000008 ????                    .par_dir:     resw 1		; number of paragraphs before image
  1128 0000000A ????                    .min_BSS:     resw 1		; minimum number of para of BSS
  1129 0000000C ????                    .max_BSS:     resw 1		; max number of para of BSS
  1130 0000000E ????                    .SS:          resw 1		; stack of image
  1131 00000010 ????                    .SP:          resw 1		; SP of image
  1132 00000012 ????                    .chksum:      resw 1		; checksum of file (ignored)
  1133 00000014 ????                    .IP:          resw 1		; IP of entry
  1134 00000016 ????                    .CS:          resw 1		; CS of entry
  1135 00000018 ????                    .rle_table:   resw 1		; byte offset of reloc table
  1136 0000001A ????                    .iov:         resw 1		; overlay number (0 for root)
  1137 0000001C ????????                .sym_tab:     resd 1		; offset of symbol table in file
  1138                                  .size:
  1139                                  endstruc
  1140                                  
  1141                                  exe_valid_signature     EQU 5A4Dh
  1142                                  exe_valid_old_signature EQU 4D5Ah
  1143                                  
  1144                                  ;**	EXE file symbol info definitions
  1145                                  
  1146                                  struc symbol_entry
  1147 00000000 ????????                .value:	resd 1
  1148 00000004 ????                    .type:	resw 1
  1149 00000006 ??                      .len:	resb 1
  1150 00000007 <res FFh>               .name:	resb 255
  1151                                  endstruc
  1152                                  
  1153                                  ;**	Data structure passed for ExecReady call
  1154                                  
  1155                                  struc ERStruc
  1156 00000000 ????                     .ER_Reserved:	resw	1	; reserved, should be zero
  1157 00000002 ????                     .ER_Flags:	resw	1
  1158 00000004 ????????                 .ER_ProgName:	resd	1	; ptr to ASCIIZ str of prog name
  1159 00000008 ????                     .ER_PSP:	resw	1	; PSP of the program
  1160 0000000A ????????                 .ER_StartAddr:	resd	1	; Start CS:IP of the program
  1161 0000000E ????????                 .ER_ProgSize:	resd	1	; Program size including PSP
  1162                                   .size:
  1163                                  endstruc
  1164                                  
  1165                                  ;** bit fields in ER_Flags
  1166                                  
  1167                                  ER_EXE		equ	0001h
  1168                                  ER_OVERLAY	equ	0002h
  1169                                  
  1170                                  
  1171                                  ;============================================================================
  1172                                  ; ARENA.INC, MSDOS 6.0, 1991
  1173                                  ;============================================================================
  1174                                  ; 24/04/2019 - Retro DOS v4.0
  1175                                  ; 04/08/2018 - Retro DOS v3.0
  1176                                  
  1177                                  ;BREAK <Memory arena structure>
  1178                                  
  1179                                  ;**	Arena Header
  1180                                  
  1181                                  struc ARENA
  1182 00000000 ??                      .SIGNATURE:	resb 1		; 4D for valid item, 5A for last item
  1183 00000001 ????                    .OWNER:		resw 1		; owner of arena item
  1184 00000003 ????                    .SIZE:		resw 1		; size in paragraphs of item
  1185 00000005 ??????                  .RESERVED:	resb 3		; reserved
  1186 00000008 ????????????????        .NAME:		resb 8		; owner file name
  1187                                  .headersize:			
  1188                                  endstruc
  1189                                  
  1190                                  ; 20/05/2019 - Retro DOS v4.0
  1191                                  ARENAHEADERSIZE equ ARENA.headersize 
  1192                                  
  1193                                  ; CAUTION: The routines in ALLOC.ASM rely on the fact that arena_signature
  1194                                  ; and arena_owner_system are all equal to zero and are contained in DI.
  1195                                  ; Change them and change ALLOC.ASM.
  1196                                  
  1197                                  arena_owner_system  EQU 0               ; free block indication
  1198                                  
  1199                                  arena_signature_normal	EQU 4Dh		; valid signature, not end of arena
  1200                                  arena_signature_end     EQU 5Ah         ; valid signature, last block in arena
  1201                                  
  1202                                  FIRST_FIT	EQU	00000000B
  1203                                  BEST_FIT	EQU	00000001B
  1204                                  LAST_FIT	EQU	00000010B
  1205                                  
  1206                                  ; MSDOS 6.0
  1207                                  LOW_FIRST	EQU	00000000B	; M001
  1208                                  HIGH_FIRST	EQU	10000000B	; M001
  1209                                  HIGH_ONLY	EQU	01000000B	; M001
  1210                                  
  1211                                  LINKSTATE	EQU	00000001B	; M002
  1212                                  
  1213                                  HF_MASK		EQU	~HIGH_FIRST	; M001
  1214                                  HO_MASK		EQU	~HIGH_ONLY	; M001
  1215                                  
  1216                                  STRAT_MASK	EQU	HF_MASK & HO_MASK	; M001;
  1217                                  						; M026: used to mask of bits
  1218                                  						; M026: 6 & 7 of AllocMethod
  1219                                  
  1220                                  ;============================================================================
  1221                                  ; MI.INC, MSDOS 6.0, 1991
  1222                                  ;============================================================================
  1223                                  ; 07/07/2018 - Retro DOS v3.0
  1224                                  
  1225                                  ;BREAK <Machine instruction, flag definitions and character types>
  1226                                  
  1227                                  mi_INT		EQU	0CDh
  1228                                  mi_long_jmp	EQU	0EAh
  1229                                  mi_Long_CALL	EQU	09Ah
  1230                                  mi_Long_RET	EQU	0CBh
  1231                                  mi_Near_RET	EQU	0C3h
  1232                                  
  1233                                  ;			xxxxoditszxaxpxc
  1234                                  f_Overflow	EQU	0000100000000000B
  1235                                  f_Direction	EQU	0000010000000000B
  1236                                  f_Interrupt	EQU	0000001000000000B
  1237                                  f_Trace 	EQU	0000000100000000B
  1238                                  f_Sign		EQU	0000000010000000B
  1239                                  f_Zero		EQU	0000000001000000B
  1240                                  f_Aux		EQU	0000000000010000B
  1241                                  f_Parity	EQU	0000000000000100B
  1242                                  f_Carry 	EQU	0000000000000001B
  1243                                  
  1244                                  ;============================================================================
  1245                                  ; FILEMODE.INC, MSDOS 6.0, 1991
  1246                                  ;============================================================================
  1247                                  ; 13/07/2018 - Retro DOS v3.0
  1248                                  ; 29/04/2019 - Retro DOS v4.0
  1249                                  
  1250                                  ;**	Standard I/O file handles
  1251                                  
  1252                                  stdin       EQU     0
  1253                                  stdout      EQU     1
  1254                                  stderr      EQU     2
  1255                                  stdaux      EQU     3
  1256                                  stdprn      EQU     4
  1257                                  
  1258                                  ;**	File Modes
  1259                                  ; <Xenix subfunction assignments>  ; MSDOS 3.3 FILEMODE.INC
  1260                                  
  1261                                  open_for_read   EQU 0
  1262                                  open_for_write  EQU 1
  1263                                  open_for_both   EQU 2
  1264                                  
  1265                                  ; MSDOS 6.0
  1266                                  OPEN_FOR_BOTH	equ 2
  1267                                  EXEC_OPEN	equ 3	; access code of 3 indicates that open was 
  1268                                  				; made from exec
  1269                                  
  1270                                  access_mask	EQU 0Fh ; 09/08/2018
  1271                                  
  1272                                  SHARING_MASK	    equ 0F0h
  1273                                  SHARING_COMPAT	    equ 000h
  1274                                  SHARING_DENY_BOTH   equ 010h
  1275                                  SHARING_DENY_WRITE  equ 020h
  1276                                  SHARING_DENY_READ   equ 030h
  1277                                  SHARING_DENY_NONE   equ 040h
  1278                                  SHARING_NET_FCB     equ 070h
  1279                                  SHARING_NO_INHERIT  equ 080h
  1280                                  
  1281                                  ; 29/04/2019
  1282                                  
  1283                                  ;**	Extended Open Definitions
  1284                                  
  1285                                  RESERVED_BITS_MASK equ 0FE00h	; reserved bits for extended open flags
  1286                                  EXISTS_MASK	   equ 0Fh 	; "file exists" action field
  1287                                  NOT_EXISTS_MASK    equ 0F0h
  1288                                  
  1289                                  ;*	SF_MODE values
  1290                                  
  1291                                  AUTO_COMMIT_WRITE	equ 4000h
  1292                                  INT_24_ERROR		equ 2000h
  1293                                  
  1294                                  ;*	Flags in EXTOPEN_ON
  1295                                  
  1296                                  EXT_OPEN_ON		equ 01h
  1297                                  EXT_FILE_NOT_EXISTS	equ 04h
  1298                                  EXT_OPEN_I24_OFF	equ 02h
  1299                                  
  1300                                  ;*	Flags in EXTOPEN_FLAG
  1301                                  
  1302                                  ACTION_OPENED		equ 01h
  1303                                  ACTION_CREATED_OPENED	equ 02h
  1304                                  ACTION_REPLACED_OPENED	equ 03h
  1305                                  EXT_EXISTS_OPEN 	equ 01h
  1306                                  EXT_EXISTS_FAIL 	equ 00h
  1307                                  EXT_NEXISTS_CREATE	equ 10h
  1308                                  
  1309                                  ;**	Extended Open Structure
  1310                                  
  1311                                  struc EXT_OPEN_PARM
  1312 00000000 ????????                .SET_LIST:	resd 1
  1313 00000004 ????                    .NUM_OF_PARM:	resw 1
  1314                                  endstruc
  1315                                  
  1316                                  ;============================================================================
  1317                                  ; SYSCALL.INC, MSDOS 6.0, 1991
  1318                                  ;============================================================================
  1319                                  ; 29/04/2019 - Retro DOS v4.0
  1320                                  ; 09/07/2018 - Retro DOS v3.0 (SYSCALL.INC, MSDOS 3.3, 1987)
  1321                                  
  1322                                  ; <system call definitions>
  1323                                  
  1324                                  ABORT                           EQU 0   ;  0      0
  1325                                  STD_CON_INPUT                   EQU 1   ;  1      1
  1326                                  STD_CON_OUTPUT                  EQU 2   ;  2      2
  1327                                  STD_AUX_INPUT                   EQU 3   ;  3      3
  1328                                  STD_AUX_OUTPUT                  EQU 4   ;  4      4
  1329                                  STD_PRINTER_OUTPUT              EQU 5   ;  5      5
  1330                                  RAW_CON_IO                      EQU 6   ;  6      6
  1331                                  RAW_CON_INPUT                   EQU 7   ;  7      7
  1332                                  STD_CON_INPUT_NO_ECHO           EQU 8   ;  8      8
  1333                                  STD_CON_STRING_OUTPUT           EQU 9   ;  9      9
  1334                                  STD_CON_STRING_INPUT            EQU 10  ; 10      A
  1335                                  STD_CON_INPUT_STATUS            EQU 11  ; 11      B
  1336                                  STD_CON_INPUT_FLUSH             EQU 12  ; 12      C
  1337                                  DISK_RESET                      EQU 13  ; 13      D
  1338                                  SET_DEFAULT_DRIVE               EQU 14  ; 14      E
  1339                                  FCB_OPEN                        EQU 15  ; 15      F
  1340                                  FCB_CLOSE                       EQU 16  ; 16     10
  1341                                  DIR_SEARCH_FIRST                EQU 17  ; 17     11
  1342                                  DIR_SEARCH_NEXT                 EQU 18  ; 18     12
  1343                                  FCB_DELETE                      EQU 19  ; 19     13
  1344                                  FCB_SEQ_READ                    EQU 20  ; 20     14
  1345                                  FCB_SEQ_WRITE                   EQU 21  ; 21     15
  1346                                  FCB_CREATE                      EQU 22  ; 22     16
  1347                                  FCB_RENAME                      EQU 23  ; 23     17
  1348                                  GET_DEFAULT_DRIVE               EQU 25  ; 25     19
  1349                                  SET_DMA                         EQU 26  ; 26     1A
  1350                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1351                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1352                                  ;                                                                          ;
  1353                                  GET_DEFAULT_DPB                 EQU 31  ; 31     1F
  1354                                  ;                                                                          ;
  1355                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1356                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1357                                  FCB_RANDOM_READ                 EQU 33  ; 33     21
  1358                                  FCB_RANDOM_WRITE                EQU 34  ; 34     22
  1359                                  GET_FCB_FILE_LENGTH             EQU 35  ; 35     23
  1360                                  GET_FCB_POSITION                EQU 36  ; 36     24
  1361                                  SET_INTERRUPT_VECTOR            EQU 37  ; 37     25
  1362                                  CREATE_PROCESS_DATA_BLOCK       EQU 38  ; 38     26
  1363                                  FCB_RANDOM_READ_BLOCK           EQU 39  ; 39     27
  1364                                  FCB_RANDOM_WRITE_BLOCK          EQU 40  ; 40     28
  1365                                  PARSE_FILE_DESCRIPTOR           EQU 41  ; 41     29
  1366                                  GET_DATE                        EQU 42  ; 42     2A
  1367                                  SET_DATE                        EQU 43  ; 43     2B
  1368                                  GET_TIME                        EQU 44  ; 44     2C
  1369                                  SET_TIME                        EQU 45  ; 45     2D
  1370                                  SET_VERIFY_ON_WRITE             EQU 46  ; 46     2E
  1371                                  ; Extended functionality group
  1372                                  GET_DMA                         EQU 47  ; 47     2F
  1373                                  GET_VERSION                     EQU 48  ; 48     30
  1374                                  KEEP_PROCESS                    EQU 49  ; 49     31
  1375                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1376                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1377                                  ;                                                                          ;
  1378                                  GET_DPB                         EQU 50  ; 50     32
  1379                                  ;                                                                          ;
  1380                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1381                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1382                                  SET_CTRL_C_TRAPPING             EQU 51  ; 51     33
  1383                                  GET_INDOS_FLAG                  EQU 52  ; 52     34
  1384                                  GET_INTERRUPT_VECTOR            EQU 53  ; 53     35
  1385                                  GET_DRIVE_FREESPACE             EQU 54  ; 54     36
  1386                                  CHAR_OPER                       EQU 55  ; 55     37
  1387                                  INTERNATIONAL                   EQU 56  ; 56     38
  1388                                  ; XENIX CALLS
  1389                                  ;   Directory Group
  1390                                  MKDIR                           EQU 57  ; 57     39
  1391                                  RMDIR                           EQU 58  ; 58     3A
  1392                                  CHDIR                           EQU 59  ; 59     3B
  1393                                  ;   File Group
  1394                                  CREAT                           EQU 60  ; 60     3C
  1395                                  OPEN                            EQU 61  ; 61     3D
  1396                                  CLOSE                           EQU 62  ; 62     3E
  1397                                  READ                            EQU 63  ; 63     3F
  1398                                  WRITE                           EQU 64  ; 64     40
  1399                                  UNLINK                          EQU 65  ; 65     41
  1400                                  LSEEK                           EQU 66  ; 66     42
  1401                                  CHMOD                           EQU 67  ; 67     43
  1402                                  IOCTL                           EQU 68  ; 68     44
  1403                                  XDUP                            EQU 69  ; 69     45
  1404                                  XDUP2                           EQU 70  ; 70     46
  1405                                  CURRENT_DIR                     EQU 71  ; 71     47
  1406                                  ;    Memory Group
  1407                                  ALLOC                           EQU 72  ; 72     48
  1408                                  DEALLOC                         EQU 73  ; 73     49
  1409                                  SETBLOCK                        EQU 74  ; 74     4A
  1410                                  ;    Process Group
  1411                                  EXEC                            EQU 75  ; 75     4B
  1412                                  EXIT                            EQU 76  ; 76     4C
  1413                                  _WAIT				EQU 77  ; 77     4D
  1414                                  FIND_FIRST                      EQU 78  ; 78     4E
  1415                                  ;   Special Group
  1416                                  FIND_NEXT                       EQU 79  ; 79     4F
  1417                                  ; SPECIAL SYSTEM GROUP
  1418                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1419                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1420                                  ;                                                                          ;
  1421                                  SET_CURRENT_PDB                 EQU 80  ; 80     50
  1422                                  GET_CURRENT_PDB                 EQU 81  ; 81     51
  1423                                  GET_IN_VARS                     EQU 82  ; 82     52
  1424                                  SETDPB                          EQU 83  ; 83     53
  1425                                  ;                                                                          ;
  1426                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1427                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1428                                  GET_VERIFY_ON_WRITE             EQU 84  ; 84     54
  1429                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1430                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1431                                  ;                                                                          ;
  1432                                  DUP_PDB                         EQU 85  ; 85     55
  1433                                  ;                                                                          ;
  1434                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1435                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1436                                  RENAME                          EQU 86  ; 86     56
  1437                                  FILE_TIMES                      EQU 87  ; 87     57
  1438                                  ALLOCOPER			EQU 88	; 88	 58
  1439                                  ; Network extention system calls
  1440                                  GETEXTENDEDERROR		EQU 89	; 89	 59
  1441                                  CREATETEMPFILE			EQU 90	; 90	 5A
  1442                                  CREATENEWFILE			EQU 91	; 91	 5B
  1443                                  LOCKOPER			EQU 92	; 92	 5C Lock and Unlock
  1444                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1445                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  1446                                  ;									   ;
  1447                                  SERVERCALL			EQU 93	; 93	 5D CommitAll, ServerDOSCall,
  1448                                  					;	    CloseByName, CloseUser,
  1449                                  					;	    CloseUserProcess,
  1450                                  					;	    GetOpenFileList
  1451                                  ;									   ;
  1452                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  1453                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1454                                  USEROPER			EQU 94	; 94	 5E Get and Set
  1455                                  ASSINGOPER			EQU 95	; 95	 5F On, Off, Get, Set, Cancel
  1456                                  XNAMETRANS			EQU 96	; 96	 60
  1457                                  PATHPARSE			EQU 97	; 97	 61
  1458                                  GETCURRENTPSP			EQU 98	; 98	 62
  1459                                  HONGEUL 			EQU 99	; 99	 63
  1460                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1461                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  1462                                  ;									   ;
  1463                                  SET_PRINTER_FLAG		EQU 100 ; 100	 64
  1464                                  ;									   ;
  1465                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  1466                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1467                                  GETEXTCNTRY			EQU 101 ; 101	 65 
  1468                                  GETSETCDPG			EQU 102 ; 102	 66
  1469                                  EXTHANDLE			EQU 103 ; 103	 67
  1470                                  COMMIT				EQU 104 ; 104	 68
  1471                                  
  1472                                  ; 29/04/2019 - Retro DOS v4.0
  1473                                  ; (MSDOS 6.0, SYSCALL.INC, 1987)
  1474                                  
  1475                                  GetSetMediaID			EQU 105 ; 105	 69
  1476                                  IFS_IOCTL			EQU 107 ; 107	 6B
  1477                                  ExtOpen 			EQU 108 ; 108	 6C
  1478                                  
  1479                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1480                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1481                                  ;                                                                          ;
  1482                                  ;ifdef ROMEXEC
  1483                                  ;ROM_FIND_FIRST			EQU 109 ; 109    6D
  1484                                  ;ROM_FIND_NEXT			EQU 110 ; 110    6E
  1485                                  ;ROM_EXCLUDE			EQU 111 ; 111	 6F		; M035
  1486                                  ;endif
  1487                                  ;                                                                          ;
  1488                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1489                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1490                                  
  1491                                  SET_OEM_HANDLER			EQU 248 ; 248    F8
  1492                                  ;OEM_C1				EQU 249 ; 249    F9
  1493                                  ;OEM_C2				EQU 250 ; 250    FA
  1494                                  ;OEM_C3				EQU 251 ; 251    FB
  1495                                  ;OEM_C4				EQU 252 ; 252    FC
  1496                                  ;OEM_C5				EQU 253 ; 253    FD
  1497                                  ;OEM_C6				EQU 254 ; 254    FE
  1498                                  ;OEM_C7				EQU 255 ; 255    FF
  1499                                  
  1500                                  ;============================================================================
  1501                                  ; VERSIONA.INC (MSDOS 6.0, 1991)
  1502                                  ;============================================================================
  1503                                  ; 24/04/2019 - Retro DOS 4.0
  1504                                  
  1505                                  ;MAJOR_VERSION	EQU     6
  1506                                  ;;MINOR_VERSION	EQU	00
  1507                                  ;MINOR_VERSION	EQU     21  ; MSDOS 6.21
  1508                                  
  1509                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  1510                                  ;MAJOR_VERSION	EQU     5
  1511                                  ;MINOR_VERSION	EQU     0
  1512                                  
  1513                                  ; 30/12/2022 - Retro DOS v4.2
  1514                                  MAJOR_VERSION	EQU     6
  1515                                  MINOR_VERSION	EQU     22
  1516                                  
  1517                                  ;============================================================================
  1518                                  ; INTNAT.INC, MSDOS 3.3, 1987
  1519                                  ;============================================================================
  1520                                  ; 09/07/2018 - Retro DOS 3.0
  1521                                  
  1522                                  ; Current structure of the data returned by the international call
  1523                                  
  1524                                  struc	INTERNAT_BLOCK		; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
  1525                                  .Date_tim_format:
  1526 00000000 ????                    		RESW 1		; 0-USA, 1-EUR, 2-JAP
  1527                                  .Currency_sym:
  1528 00000002 ??????????              		RESB 5		; Currency Symbol 5 bytes
  1529                                  .Thous_sep:
  1530 00000007 ????                    		RESB 2		; Thousands separator 2 bytes
  1531                                  .Decimal_sep:
  1532 00000009 ????                    		RESB 2		; Decimal separator 2 bytes
  1533                                  .Date_sep:
  1534 0000000B ????                    		RESB 2		; Date separator 2 bytes
  1535                                  .Time_sep:
  1536 0000000D ????                    		RESB 2		; Time separator 2 bytes
  1537                                  .Bit_field:	
  1538 0000000F ??                      		RESB 1		; Bit values
  1539                                                                     ;   Bit 0 = 0 if currency symbol first
  1540                                                                     ;         = 1 if currency symbol last
  1541                                                                     ;   Bit 1 = 0 if No space after currency symbol
  1542                                                                     ;         = 1 if space after currency symbol
  1543                                  .Currency_cents:
  1544 00000010 ??                      		RESB 	1	; Number of places after currency dec point
  1545                                  .Time_24:
  1546 00000011 ??                      		RESB 	1	; 1 if 24 hour time, 0 if 12 hour time
  1547                                  .Map_call:
  1548 00000012 ????                    		RESW	1	; Address of case mapping call (DWORD)
  1549 00000014 ????                                    RESW	1       ; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
  1550                                  				;  in pieces.
  1551                                  .Data_sep:
  1552 00000016 ????                    		RESB	2	; Data list separator character
  1553                                  .size:		
  1554                                  endstruc
  1555                                  
  1556                                  ; Max size of the block returned by the INTERNATIONAL call
  1557                                  
  1558                                  internat_block_max	EQU	32
  1559                                  
  1560                                  ;============================================================================
  1561                                  ; SYSVAR.INC (MSDOS 6.0, 1991)
  1562                                  ;============================================================================
  1563                                  ; 08/07/2018 - Retro DOS v3.0
  1564                                  
  1565                                  ;SysInitVars STRUC
  1566                                  struc SYSI
  1567 00000000 ????????                .DPB:	    resd 1		; DPB chain
  1568 00000004 ????????                .SFT:	    resd 1		; SFT chain
  1569 00000008 ????????                .CLOCK:	    resd 1		; CLOCK device
  1570 0000000C ????????                .CON:	    resd 1		; CON device
  1571 00000010 ????                    .MAXSEC:    resw 1		; maximum sector size
  1572 00000012 ????????                .BUF:	    resd 1		; points to Hashinitvar
  1573 00000016 ????????                .CDS:	    resd 1		; CDS list
  1574 0000001A ????????                .FCB:	    resd 1		; FCB chain
  1575 0000001E ????                    .Keep:	    resw 1		; keep count
  1576 00000020 ??                      .NUMIO:	    resb 1		; Number of block devices
  1577 00000021 ??                      .NCDS:	    resb 1		; number of CDS's
  1578 00000022 ????????                .DEV:	    resd 1		; device list
  1579                                  ; 09/07/2018
  1580                                  ; Above parameters are described in MSDOS 3.3 SYSVAR.INC (85/04/10)
  1581                                  ; Following parameters are used with MSDOS 6.0 (Retro DOS v4.0)
  1582 00000026 ????                    .ATTR:	    resw 1		; null device attribute word
  1583 00000028 ????                    .STRAT:	    resw 1		; null device strategy entry point
  1584 0000002A ????                    .INTER:	    resw 1		; null device interrupt entry point
  1585 0000002C ????????????????        .NAME:	    resb 8		; null device name
  1586 00000034 ??                      .SPLICE:    resb 1		; TRUE -> splicees being done
  1587 00000035 ????                    .IBMDOS_SIZE: resw 1		; DOS size in paragraphs
  1588 00000037 ????????                .IFS_DOSCALL@: resd 1		; IFS DOS service rountine entry
  1589 0000003B ????????                .IFS:	    resd 1		; IFS header chain
  1590 0000003F ????????                .BUFFERS:   resw 2		; BUFFERS= values (m,n)
  1591 00000043 ??                      .BOOT_DRIVE: resb 1		; boot drive A=1 B=2,..
  1592 00000044 ??                      .DWMOVE:    resb 1		; 1 if 386 machine
  1593 00000045 ????                    .EXT_MEM:   resw 1		; Extended memory size in KB.
  1594                                  endstruc
  1595                                  ;SysInitVars ENDS
  1596                                  
  1597                                  ;This is added for more information exchange between DOS, BIOS.
  1598                                  ;DOS will give the pointer to SysInitTable in ES:DI. - J.K. 5/29/86
  1599                                  
  1600                                  ;SysInitVars_Ext struc
  1601                                  struc SYSI_EXT
  1602 00000000 ????????                .SysInitVars:	resd 1		; Points to the above structure.
  1603 00000004 ????????                .Country_Tab:	resd 1		; DOS_Country_cdpg_info
  1604                                  endstruc
  1605                                  ;SysInitVars_Ext ends
  1606                                  
  1607                                  ;============================================================================
  1608                                  ; IOCTL.INC - MSDOS 6.0 - 1991
  1609                                  ;============================================================================
  1610                                  ; 09/07/2018 - Retro DOS v3.0
  1611                                  
  1612                                  ;*** J.K.
  1613                                  ;General Guide -
  1614                                  ;Category Code:
  1615                                  ; 0... .... DOS Defined
  1616                                  ; 1... .... User defined
  1617                                  ; .xxx xxxx Code
  1618                                  
  1619                                  ;Function Code:
  1620                                  ; 0... .... Return error if unsupported
  1621                                  ; 1... .... Ignore if unsupported
  1622                                  ; .0.. .... Intercepted by DOS
  1623                                  ; .1.. .... Passed to driver
  1624                                  ; ..0. .... Sends data/commands to device
  1625                                  ; ..1. .... Quries data/info from device
  1626                                  ; ...x .... Subfunction
  1627                                  ;
  1628                                  ; Note that "Sends/queries" data bit is intended only to regularize the
  1629                                  ; function set.  It plays no critical role; some functions may contain both
  1630                                  ; command and query elements. The convention is that such commands are
  1631                                  ; defined as "sends data".
  1632                                  
  1633                                  ;*****************************;*
  1634                                  ; BLOCK DRIVERS 	      ;*
  1635                                  ;*****************************;*
  1636                                  
  1637                                  ; IOCTL SUB-FUNCTIONS
  1638                                  ; (MSDOS 3.3 + MSDOS 6.0)
  1639                                  IOCTL_GET_DEVICE_INFO	EQU	0
  1640                                  IOCTL_SET_DEVICE_INFO	EQU	1
  1641                                  IOCTL_READ_HANDLE	EQU	2
  1642                                  IOCTL_WRITE_HANDLE	EQU	3
  1643                                  IOCTL_READ_DRIVE	EQU	4
  1644                                  IOCTL_WRITE_DRIVE	EQU	5
  1645                                  IOCTL_GET_INPUT_STATUS	EQU	6
  1646                                  IOCTL_GET_OUTPUT_STATUS EQU	7
  1647                                  IOCTL_CHANGEABLE?	EQU	8
  1648                                  IOCTL_DeviceLocOrRem?	EQU	9
  1649                                  IOCTL_HandleLocOrRem?	EQU	0Ah   ;10
  1650                                  IOCTL_SHARING_RETRY	EQU	0Bh   ;11
  1651                                  GENERIC_IOCTL_HANDLE	EQU	0Ch   ;12
  1652                                  GENERIC_IOCTL		EQU	0Dh   ;13
  1653                                  ; (MSDOS 6.0 + MSDOS 3.3)
  1654                                  IOCTL_GET_DRIVE_MAP 	EQU	0Eh   ;14
  1655                                  IOCTL_SET_DRIVE_MAP	EQU	0Fh   ;15
  1656                                  ; (MSDOS 6.0)
  1657                                  IOCTL_QUERY_HANDLE	EQU	10h   ;16
  1658                                  IOCTL_QUERY_BLOCK	EQU	11h   ;17
  1659                                  
  1660                                  ; GENERIC IOCTL CATEGORY CODES
  1661                                  IOC_OTHER		EQU	0	; Other device control J.K. 4/29/86
  1662                                  IOC_SE			EQU	1	; SERIAL DEVICE CONTROL
  1663                                  IOC_TC			EQU	2	; TERMINAL CONTROL
  1664                                  IOC_SC			EQU	3	; SCREEN CONTROL
  1665                                  IOC_KC			EQU	4	; KEYBOARD CONTROL
  1666                                  IOC_PC			EQU	5	; PRINTER CONTROL
  1667                                  IOC_DC			EQU	8	; DISK CONTROL (SAME AS RAWIO)
  1668                                  
  1669                                  ; GENERIC IOCTL SUB-FUNCTIONS
  1670                                  RAWIO			EQU	8
  1671                                  
  1672                                  ; RAWIO SUB-FUNCTIONS
  1673                                  ; (MSDOS 3.3 + MSDOS 6.0)
  1674                                  GET_DEVICE_PARAMETERS	EQU	60H
  1675                                  SET_DEVICE_PARAMETERS	EQU	40H
  1676                                  READ_TRACK		EQU	61H
  1677                                  WRITE_TRACK		EQU	41H
  1678                                  VERIFY_TRACK		EQU	62H
  1679                                  FORMAT_TRACK		EQU	42H
  1680                                  ; (MSDOS 6.0)
  1681                                  GET_MEDIA_ID		EQU	66h	;AN000;AN003;changed from 63h
  1682                                  SET_MEDIA_ID		EQU	46h	;AN000;AN003;changed from 43h
  1683                                  GET_ACCESS_FLAG 	EQU	67h	;AN002;AN003;Unpublished function.Changed from 64h
  1684                                  SET_ACCESS_FLAG 	EQU	47h	;AN002;AN003;Unpublished function.Changed from 44h
  1685                                  SENSE_MEDIA_TYPE	EQU	68H	;Added for 5.00
  1686                                  
  1687                                  ; SPECIAL FUNCTION FOR GET DEVICE PARAMETERS
  1688                                  BUILD_DEVICE_BPB	EQU	000000001B
  1689                                  
  1690                                  ; SPECIAL FUNCTIONS FOR SET DEVICE PARAMETERS
  1691                                  INSTALL_FAKE_BPB	EQU	000000001B
  1692                                  ONLY_SET_TRACKLAYOUT	EQU	000000010B
  1693                                  TRACKLAYOUT_IS_GOOD	EQU	000000100B
  1694                                  
  1695                                  ; SPECIAL FUNCTION FOR FORMAT TRACK
  1696                                  ; (MSDOS 3.3 + MSDOS 6.0)
  1697                                  STATUS_FOR_FORMAT	EQU	000000001B
  1698                                  ; (MSDOS 6.0)
  1699                                  DO_FAST_FORMAT		EQU	000000010B ;AN001;
  1700                                  
  1701                                  ; CODES RETURNED FROM FORMAT STATUS CALL
  1702                                  FORMAT_NO_ROM_SUPPORT	EQU	000000001B
  1703                                  FORMAT_COMB_NOT_SUPPORTED EQU	000000010B
  1704                                  
  1705                                  ; DEVICETYPE VALUES
  1706                                  ; (MSDOS 3.3 + MSDOS 6.0)
  1707                                  MAX_SECTORS_IN_TRACK	EQU	63	; MAXIMUM SECTORS ON A DISK.(Was 40 in DOS 3.2)
  1708                                  DEV_5INCH		EQU	0
  1709                                  DEV_5INCH96TPI		EQU	1
  1710                                  DEV_3INCH720KB		EQU	2
  1711                                  DEV_8INCHSS		EQU	3
  1712                                  DEV_8INCHDS		EQU	4
  1713                                  DEV_HARDDISK		EQU	5
  1714                                  DEV_OTHER		EQU	7
  1715                                  ; (MSDOS 6.0)
  1716                                  ;DEV_3INCH1440KB	EQU	7
  1717                                  DEV_3INCH2880KB		EQU	9
  1718                                  ; Retro DOS v2.0 - 26/03/2018
  1719                                  ;;DEV_TAPE		EQU	6
  1720                                  ;;DEV_ERIMO		EQU	8
  1721                                  ;DEV_3INCH2880KB	EQU	9
  1722                                  DEV_3INCH1440KB		EQU	10
  1723                                  
  1724                                  ; (MSDOS 3.3)
  1725                                  ;MAX_DEV_TYPE		EQU	7
  1726                                  
  1727                                  ; (MSDOS 6.0)
  1728                                  MAX_DEV_TYPE		EQU	10	; MAXIMUM DEVICE TYPE THAT WE
  1729                                  					; CURRENTLY SUPPORT.
  1730                                  struc A_SECTORTABLE
  1731 00000000 ????                    .ST_SECTORNUMBER:	resw	1
  1732 00000002 ????                    .ST_SECTORSIZE:		resw	1
  1733                                  .size:
  1734                                  endstruc
  1735                                  
  1736                                  ;============================================================================
  1737                                  ; DEVSYM.INC
  1738                                  ;============================================================================
  1739                                  ; 07/07/2018 - Retro DOS v3.0
  1740                                  ; 30/04/2019 - Retro DOS v4.0 (DEVSYM.INC, MSDOS 6.0, 1991)
  1741                                  
  1742                                  ;**	DevSym.inc - Device Symbols
  1743                                  
  1744                                  ; The device table list has the form:
  1745                                  struc	SYSDEV
  1746 00000000 ????????                .NEXT:		resd 1		;Pointer to next device header
  1747 00000004 ????                    .ATT:		resw 1		;Attributes of the device
  1748 00000006 ????                    .STRAT:		resw 1		;Strategy entry point
  1749 00000008 ????                    .INT:		resw 1		;Interrupt entry point
  1750 0000000A ????????????????        .NAME:		resb 8		;Name of device (only first byte used for block)
  1751                                  .size:
  1752                                  endstruc
  1753                                  
  1754                                  ;
  1755                                  ; ATTRIBUTE BIT MASKS
  1756                                  ;
  1757                                  ; CHARACTER DEVICES:
  1758                                  ;
  1759                                  ; BIT 15 -> MUST BE 1
  1760                                  ;     14 -> 1 IF THE DEVICE UNDERSTANDS IOCTL CONTROL STRINGS
  1761                                  ;     13 -> 1 IF THE DEVICE SUPPORTS OUTPUT-UNTIL-BUSY
  1762                                  ;     12 -> UNUSED
  1763                                  ;     11 -> 1 IF THE DEVICE UNDERSTANDS OPEN/CLOSE
  1764                                  ;     10 -> MUST BE 0
  1765                                  ;      9 -> MUST BE 0
  1766                                  ;      8 -> UNUSED
  1767                                  ;      7 -> UNUSED
  1768                                  ;      6 -> UNUSED
  1769                                  ;      5 -> UNUSED
  1770                                  ;      4 -> 1 IF DEVICE IS RECIPIENT OF INT 29H
  1771                                  ;      3 -> 1 IF DEVICE IS CLOCK DEVICE
  1772                                  ;      2 -> 1 IF DEVICE IS NULL DEVICE
  1773                                  ;      1 -> 1 IF DEVICE IS CONSOLE OUTPUT
  1774                                  ;      0 -> 1 IF DEVICE IS CONSOLE INPUT
  1775                                  ;
  1776                                  ; BLOCK DEVICES:
  1777                                  ;
  1778                                  ; BIT 15 -> MUST BE 0
  1779                                  ;     14 -> 1 IF THE DEVICE UNDERSTANDS IOCTL CONTROL STRINGS
  1780                                  ;     13 -> 1 IF THE DEVICE DETERMINES MEDIA BY EXAMINING THE FAT ID BYTE.
  1781                                  ;	    THIS REQUIRES THE FIRST SECTOR OF THE FAT TO *ALWAYS* RESIDE IN
  1782                                  ;	    THE SAME PLACE.
  1783                                  ;     12 -> UNUSED
  1784                                  ;     11 -> 1 IF THE DEVICE UNDERSTANDS OPEN/CLOSE/REMOVABLE MEDIA
  1785                                  ;     10 -> MUST BE 0
  1786                                  ;      9 -> MUST BE 0
  1787                                  ;      8 -> UNUSED
  1788                                  ;      7 -> UNUSED
  1789                                  ;      6 -> IF DEVICE HAS SUPPORT FOR GETMAP/SETMAP OF LOGICAL DRIVES.
  1790                                  ;	    IF THE DEVICE UNDERSTANDS GENERIC IOCTL FUNCTION CALLS.
  1791                                  ;      5 -> UNUSED
  1792                                  ;      4 -> UNUSED
  1793                                  ;      3 -> UNUSED
  1794                                  ;      2 -> UNUSED
  1795                                  ;      1 -> UNUSED
  1796                                  ;      0 -> UNUSED
  1797                                  ;
  1798                                  
  1799                                  ;Attribute bit masks
  1800                                  DEVTYP	EQU     8000H           ;Bit 15 - 1 if Char, 0 if block
  1801                                  DEVIOCTL EQU    4000H           ;Bit 14 - CONTROL mode bit
  1802                                  ISFATBYDEV EQU  2000H           ;Bit 13 - Device uses FAT ID bytes, comp media.
  1803                                  
  1804                                  ; 09/07/2018 - Retro DOS (DEVSYM.INC, MSDOS 3.3, 1987) 
  1805                                  
  1806                                  OUTTILBUSY EQU	2000H		; OUTPUT UNTIL BUSY IS ENABLED
  1807                                  ISNET	   EQU	1000H		; BIT 12 - 1 IF A NET DEVICE, 0 IF
  1808                                  				;  NOT.  CURRENTLY BLOCK ONLY.
  1809                                  DEVOPCL    EQU	0800H		; BIT 11 - 1 IF THIS DEVICE HAS
  1810                                  				;  OPEN,CLOSE AND REMOVABLE MEDIA
  1811                                  				;  ENTRY POINTS, 0 IF NOT
  1812                                  
  1813                                  EXTENTBIT  EQU	0400H		; BIT 10 - CURRENTLY 0 ON ALL DEVS
  1814                                  				;  THIS BIT IS RESERVED FOR FUTURE USE
  1815                                  				;  TO EXTEND THE DEVICE HEADER BEYOND
  1816                                  				;  ITS CURRENT FORM.
  1817                                  
  1818                                  ; NOTE BIT 9 IS CURRENTLY USED ON IBM SYSTEMS TO INDICATE "DRIVE IS SHARED".
  1819                                  ;    SEE IOCTL FUNCTION 9. THIS USE IS NOT DOCUMENTED, IT IS USED BY SOME
  1820                                  ;    OF THE UTILITIES WHICH ARE SUPPOSED TO FAIL ON SHARED DRIVES ON SERVER
  1821                                  ;    MACHINES (FORMAT,CHKDSK,RECOVER,..).
  1822                                  
  1823                                  IOQUERY	EQU	0080H		;Bit 7 - Supports generic IOCtl query
  1824                                  
  1825                                  DEV320	EQU	0040H		;BIT 6 - FOR BLOCK DEVICES, THIS
  1826                                  				;DEVICE SUPPORTS SET/GET MAP OF
  1827                                  				;LOGICAL DRIVES, AND SUPPORTS
  1828                                  				;GENERIC IOCTL CALLS.
  1829                                  				;FOR CHARACTER DEVICES, THIS
  1830                                  				;DEVICE SUPPORTS GENERIC IOCTL.
  1831                                  				;THIS IS A DOS 3.2 DEVICE DRIVER.
  1832                                  
  1833                                  ISSPEC	EQU     0010H		;Bit 4 - This device is special ; 15/03/2018
  1834                                  ;ISIBM	EQU     0010H		;Bit 4 - This device is special
  1835                                  ISCLOCK EQU     0008H           ;Bit 3 - This device is the clock device.
  1836                                  ISNULL  EQU     0004H           ;Bit 2 - This device is the null device.
  1837                                  ISCOUT  EQU     0002H           ;Bit 1 - This device is the console output.
  1838                                  ISCIN   EQU     0001H           ;Bit 0 - This device is the console input.
  1839                                  
  1840                                  EXTDRVR	EQU	0002h		;BIT 1 - BLOCK DEVICE EXTENDED DRIVER
  1841                                  				; (MSDOS 6.0, DEVSYM.INC, 1991) ; 30/04/2019
  1842                                  
  1843                                  ;Static Reguest Header
  1844                                  struc	SRHEAD
  1845 00000000 ??                      .REQLEN:	resb 1		;Length in bytes of request block
  1846 00000001 ??                      .REQUNIT:	resb 1		;Device unit number
  1847 00000002 ??                      .REQFUNC:	resb 1		;Type of request
  1848 00000003 ????                    .REQSTAT:	resw 1		;Status Word
  1849 00000005 ????????????????                	resb 8		;Reserved for queue links
  1850                                  .size:
  1851                                  endstruc
  1852                                  
  1853                                  ;Status word masks
  1854                                  STERR   EQU     8000H           ;Bit 15 - Error
  1855                                  STBUI   EQU     0200H           ;Bit 9 - Buisy
  1856                                  STDON   EQU     0100H           ;Bit 8 - Done
  1857                                  STECODE EQU     00FFH           ;Error code
  1858                                  WRECODE EQU     0
  1859                                  
  1860                                  ;Function codes
  1861                                  DINITHL EQU     26              ;Size of init header
  1862                                  DMEDHL  EQU     15              ;Size of media check header
  1863                                  DBPBHL  EQU     22              ;Size of Get BPB header
  1864                                  DRDWRHL EQU     22              ;Size of RD/WR header
  1865                                  DRDNDHL EQU     14              ;Size of non destructive read header
  1866                                  DSTATHL EQU     13              ;Size of status header
  1867                                  DFLSHL  EQU     15              ;Size of flush header
  1868                                  
  1869                                  DEVINIT EQU     0               ;Initialization
  1870                                  DEVMDCH EQU     1               ;Media check
  1871                                  DEVBPB  EQU     2               ;Get BPB
  1872                                  DEVRDIOCTL EQU  3               ;IOCTL read
  1873                                  DEVRD   EQU     4               ;Read
  1874                                  DEVRDND EQU     5               ;Non destructive read no wait (character devs)
  1875                                  DEVIST  EQU     6               ;Input status
  1876                                  DEVIFL  EQU     7               ;Input flush
  1877                                  DEVWRT  EQU     8               ;Write
  1878                                  DEVWRTV EQU     9               ;Write with verify
  1879                                  DEVOST  EQU     10              ;Output status
  1880                                  DEVOFL  EQU     11              ;Output flush
  1881                                  DEVWRIOCTL EQU  12              ;IOCTL write
  1882                                  
  1883                                  ; 09/07/2018 - Retro DOS v3.0 (DEVSYM.INC, MSDOS 3.3, 1987) 
  1884                                  DEVOPN	EQU	13		;DEVICE OPEN
  1885                                  DEVCLS	EQU	14		;DEVICE CLOSE
  1886                                  DOPCLHL EQU	13		;SIZE OF OPEN/CLOSE HEADER
  1887                                  DEVRMD	EQU	15		;REMOVABLE MEDIA
  1888                                  ; 07/08/2018 - Retro DOS v3.0
  1889                                  REMHL	EQU	13		;SIZE OF REMOVABLE MEDIA HEADER
  1890                                  GENIOCTL EQU	19
  1891                                  
  1892                                  ; THE NEXT THREE ARE USED IN DOS 4.0
  1893                                  ;		     20
  1894                                  ;		     21
  1895                                  ;		     22
  1896                                  
  1897                                  DEVGETOWN      EQU   23		;GET DEVICE OWNER
  1898                                  DEVSETOWN      EQU   24		;SET DEVICE OWNER
  1899                                  ; 18/05/2019 - Retro DOS v4.0
  1900                                  IOCTL_QUERY    EQU   25		;Query generic ioctl support
  1901                                  
  1902                                  OWNHL	       EQU   13		;SIZE OF DEVICE OWNER HEADER
  1903                                  
  1904                                  DEVOUT	       EQU   16		; OUTPUT UNTIL BUSY.
  1905                                  DEVOUTL        EQU   DEVWRT	; LENGTH OF OUTPUT UNTIL BUSY
  1906                                  
  1907                                  ; ADDED FOR DOS 5.00
  1908                                  
  1909                                  ; GENERIC IOCTL REQUEST STRUCTURE
  1910                                  ;	SEE THE DOS 4.0 DEVICE DRIVER SPEC FOR FURTHER ELABORATION.
  1911                                  
  1912                                  struc IOCTL_REQ
  1913 00000000 <res Dh>                .SRHEAD:	resb SRHEAD.size
  1914                                  				; GENERIC IOCTL ADDITION.
  1915 0000000D ??                      .MAJORFUNCTION: resb 1		;FUNCTION CODE
  1916 0000000E ??                      .MINORFUNCTION: resb 1		;FUNCTION CATEGORY
  1917 0000000F ????                    .REG_SI:	resw 1
  1918 00000011 ????                    .REG_DI:	resw 1
  1919 00000013 ????????                .GENERICIOCTL_PACKET: resd 1	; POINTER TO DATA BUFFER
  1920                                  .size: ; 07/08/2018
  1921                                  endstruc
  1922                                  
  1923                                  ; DEFINITIONS FOR IOCTL_REQ.MINORFUNCTION
  1924                                  GEN_IOCTL_WRT_TRK EQU	40H
  1925                                  GEN_IOCTL_RD_TRK  EQU	60H
  1926                                  GEN_IOCTL_FN_TST  EQU	20H	; USED TO DIFF. BET READS AND WRTS
  1927                                  
  1928                                  ;; 32-bit absolute read/write input list structure
  1929                                  
  1930                                  struc ABS_32RW
  1931 00000000 ????????                .SECTOR_RBA:	resd 1		; relative block address
  1932 00000004 ????                    .ABS_RW_COUNT:	resw 1		; number of sectors to be transferred
  1933 00000006 ????????                .BUFFER_ADDR:	resd 1		; data addrress
  1934                                  .size:
  1935                                  endstruc
  1936                                  
  1937                                  ;; media ID info
  1938                                  
  1939                                  struc MEDIA_ID_INFO
  1940 00000000 ????                    .MEDIA_level:	resw	1	; info level
  1941 00000002 ????????                .MEDIA_Serial:	resd	1	; serial #
  1942 00000006 <res Bh>                .MEDIA_Label:	resb	11	; volume label
  1943 00000011 ????????????????        .MEDIA_System:	resb	8	; system type
  1944                                  .size:
  1945                                  endstruc
  1946                                  
  1947                                  ; equates for DOS34_FLAG
  1948                                  ; (BUGBUG: why are bits 0,1,3 and 4 not defined.)
  1949                                  
  1950                                  FROM_DISK_RESET       EQU   000000000100b   ;from disk reset
  1951                                  Force_I24_Fail	      EQU   000000100000b   ;form IFS CALL BACK
  1952                                  Disable_EOF_I24       EQU   000001000000b   ;disable EOF int24 for input status
  1953                                  DBCS_VOLID	      EQU   000010000000b   ;indicate from volume id
  1954                                  DBCS_VOLID2	      EQU   000100000000b   ;indicate 8th char is DBCS
  1955                                  CTRL_BREAK_FLAG       EQU   001000000000b   ;indicate control break is input
  1956                                  SEARCH_FASTOPEN       EQU   010000000000b   ;set fastopen flag for search
  1957                                  EXEC_AWARE_REDIR      EQU   100000000000b   ;M018: this bit is set by a redir 
  1958                                  					    ;M018: that knows how to handle 
  1959                                  					    ;M018: open for exec
  1960                                  
  1961                                  NO_FROM_DISK_RESET    EQU   ~FROM_DISK_RESET	;not from disk reset
  1962                                  NO_Force_I24_Fail     EQU   ~Force_I24_Fail	;not form IFS CALL BACK
  1963                                  NO_Disable_EOF_I24    EQU   ~Disable_EOF_I24
  1964                                  
  1965                                  ;============================================================================
  1966                                  ; ERROR.INC (MSDOS 6.0, 1991)
  1967                                  ;============================================================================
  1968                                  ; 16/07/2018 - Retro DOS v3.0 
  1969                                  
  1970                                  ;**	ERROR.INC - DOS Error Codes
  1971                                  ;
  1972                                  ;    The newer (DOS 2.0 and above) "XENIX-style" calls
  1973                                  ;    return error codes through AX. If an error occurred then
  1974                                  ;    the carry bit will be set and the error code is in AX. If no error
  1975                                  ;    occurred then the carry bit is reset and AX contains returned info.
  1976                                  ;
  1977                                  ;    Since the set of error codes is being extended as we extend the operating
  1978                                  ;    system, we have provided a means for applications to ask the system for a
  1979                                  ;    recommended course of action when they receive an error.
  1980                                  ;
  1981                                  ;    The GetExtendedError system call returns a universal error, an error
  1982                                  ;    location and a recommended course of action. The universal error code is
  1983                                  ;    a symptom of the error REGARDLESS of the context in which GetExtendedError
  1984                                  ;    is issued.
  1985                                  
  1986                                  ;	2.0 error codes
  1987                                  
  1988                                  error_invalid_function		EQU	1
  1989                                  error_file_not_found		EQU	2
  1990                                  error_path_not_found		EQU	3
  1991                                  error_too_many_open_files	EQU	4
  1992                                  error_access_denied		EQU	5
  1993                                  error_invalid_handle		EQU	6
  1994                                  error_arena_trashed		EQU	7
  1995                                  error_not_enough_memory 	EQU	8
  1996                                  error_invalid_block		EQU	9
  1997                                  error_bad_environment		EQU	10
  1998                                  error_bad_format		EQU	11
  1999                                  error_invalid_access		EQU	12
  2000                                  error_invalid_data		EQU	13
  2001                                  ;**** reserved			EQU	14	; *****
  2002                                  error_invalid_drive		EQU	15
  2003                                  error_current_directory 	EQU	16
  2004                                  error_not_same_device		EQU	17
  2005                                  error_no_more_files		EQU	18
  2006                                  
  2007                                  ;	These are the universal int 24 mappings for the old INT 24 set of errors
  2008                                  
  2009                                  error_write_protect		EQU	19
  2010                                  error_bad_unit			EQU	20
  2011                                  error_not_ready 		EQU	21
  2012                                  error_bad_command		EQU	22
  2013                                  error_CRC			EQU	23
  2014                                  error_bad_length		EQU	24
  2015                                  error_seek			EQU	25
  2016                                  error_not_DOS_disk		EQU	26
  2017                                  error_sector_not_found		EQU	27
  2018                                  error_out_of_paper		EQU	28
  2019                                  error_write_fault		EQU	29
  2020                                  error_read_fault		EQU	30
  2021                                  error_gen_failure		EQU	31
  2022                                  
  2023                                  ;	the new 3.0 error codes reported through INT 24
  2024                                  
  2025                                  error_sharing_violation 	EQU	32
  2026                                  error_lock_violation		EQU	33
  2027                                  error_wrong_disk		EQU	34
  2028                                  error_FCB_unavailable		EQU	35
  2029                                  error_sharing_buffer_exceeded	EQU	36
  2030                                  error_Code_Page_Mismatched	EQU	37    ; DOS 4.00  ;AN000;
  2031                                  error_handle_EOF		EQU	38    ; DOS 4.00  ;AN000;
  2032                                  error_handle_Disk_Full		EQU	39    ; DOS 4.00  ;AN000;
  2033                                  
  2034                                  ;	New OEM network-related errors are 50-79
  2035                                  
  2036                                  error_not_supported		EQU	50
  2037                                  
  2038                                  error_net_access_denied		EQU	65	;M028
  2039                                  
  2040                                  ;	End of INT 24 reportable errors
  2041                                  
  2042                                  error_file_exists		EQU	80
  2043                                  error_DUP_FCB			EQU	81	; *****
  2044                                  error_cannot_make		EQU	82
  2045                                  error_FAIL_I24			EQU	83
  2046                                  
  2047                                  ;	New 3.0 network related error codes
  2048                                  
  2049                                  error_out_of_structures 	EQU	84
  2050                                  error_already_assigned		EQU	85
  2051                                  error_invalid_password		EQU	86
  2052                                  error_invalid_parameter 	EQU	87
  2053                                  error_NET_write_fault		EQU	88
  2054                                  error_sys_comp_not_loaded	EQU	90    ; DOS 4.00  ;AN000;
  2055                                  
  2056                                  ;	BREAK <Interrupt 24 error codes>
  2057                                  
  2058                                  ;**	Int24 Error Codes
  2059                                  
  2060                                  error_I24_write_protect 	EQU	0
  2061                                  error_I24_bad_unit		EQU	1
  2062                                  error_I24_not_ready		EQU	2
  2063                                  error_I24_bad_command		EQU	3
  2064                                  error_I24_CRC			EQU	4
  2065                                  error_I24_bad_length		EQU	5
  2066                                  error_I24_Seek			EQU	6
  2067                                  error_I24_not_DOS_disk		EQU	7
  2068                                  error_I24_sector_not_found	EQU	8
  2069                                  error_I24_out_of_paper		EQU	9
  2070                                  error_I24_write_fault		EQU	0Ah
  2071                                  error_I24_read_fault		EQU	0Bh
  2072                                  error_I24_gen_failure		EQU	0Ch
  2073                                  ; NOTE: Code 0DH is used by MT-DOS.
  2074                                  error_I24_wrong_disk		EQU	0Fh
  2075                                  
  2076                                  ;	THE FOLLOWING ARE MASKS FOR THE AH REGISTER ON Int 24
  2077                                  ;
  2078                                  ;	NOTE: ABORT is ALWAYS allowed
  2079                                  
  2080                                  Allowed_FAIL			EQU	00001000B
  2081                                  Allowed_RETRY			EQU	00010000B
  2082                                  Allowed_IGNORE			EQU	00100000B
  2083                                  
  2084                                  I24_operation			EQU	00000001B  ;Z if READ,NZ if Write
  2085                                  I24_area			EQU	00000110B  ; 00 if DOS
  2086                                  						   ; 01 if FAT
  2087                                  						   ; 10 if root DIR
  2088                                  						   ; 11 if DATA
  2089                                  I24_class			EQU	10000000B  ;Z if DISK, NZ if FAT or char
  2090                                  
  2091                                  ;	BREAK <GetExtendedError CLASSes ACTIONs LOCUSs>
  2092                                  
  2093                                  ;**	The GetExtendedError call takes an error code and returns CLASS,
  2094                                  ;	ACTION and LOCUS codes to help programs determine the proper action
  2095                                  ;	to take for error codes that they don't explicitly understand.
  2096                                  
  2097                                  ;	Values for error CLASS
  2098                                  
  2099                                  errCLASS_OutRes 	EQU	1	; Out of Resource
  2100                                  errCLASS_TempSit	EQU	2	; Temporary Situation
  2101                                  errCLASS_Auth		EQU	3	; Permission problem
  2102                                  errCLASS_Intrn		EQU	4	; Internal System Error
  2103                                  errCLASS_HrdFail	EQU	5	; Hardware Failure
  2104                                  errCLASS_SysFail	EQU	6	; System Failure
  2105                                  errCLASS_Apperr 	EQU	7	; Application Error
  2106                                  errCLASS_NotFnd 	EQU	8	; Not Found
  2107                                  errCLASS_BadFmt 	EQU	9	; Bad Format
  2108                                  errCLASS_Locked 	EQU	10	; Locked
  2109                                  errCLASS_Media		EQU	11	; Media Failure
  2110                                  errCLASS_Already	EQU	12	; Collision with Existing Item
  2111                                  errCLASS_Unk		EQU	13	; Unknown/other
  2112                                  
  2113                                  ;	Values for error ACTION
  2114                                  
  2115                                  errACT_Retry		EQU	1	; Retry
  2116                                  errACT_DlyRet		EQU	2	; Delay Retry, retry after pause
  2117                                  errACT_User		EQU	3	; Ask user to regive info
  2118                                  errACT_Abort		EQU	4	; abort with clean up
  2119                                  errACT_Panic		EQU	5	; abort immediately
  2120                                  errACT_Ignore		EQU	6	; ignore
  2121                                  errACT_IntRet		EQU	7	; Retry after User Intervention
  2122                                  
  2123                                  ;	Values for error LOCUS
  2124                                  
  2125                                  errLOC_Unk		EQU	1	; No appropriate value
  2126                                  errLOC_Disk		EQU	2	; Random Access Mass Storage
  2127                                  errLOC_Net		EQU	3	; Network
  2128                                  errLOC_SerDev		EQU	4	; Serial Device
  2129                                  errLOC_Mem		EQU	5	; Memory
  2130                                  
  2131                                  ;============================================================================
  2132                                  ; INT2A.INC (MSDOS 6.0, 1991)
  2133                                  ;============================================================================
  2134                                  ; 04/05/2019 - Retro DOS v4.0
  2135                                  
  2136                                  ;**	Int 2A functions
  2137                                  ; ---------------------------------------------------------------------------
  2138                                  ;	Int 2A is an interface to the network code; it's also overloaded
  2139                                  ;		as a critical section handler since critical sections
  2140                                  ;		were originally created to support the net.
  2141                                  ; ---------------------------------------------------------------------------
  2142                                  
  2143                                  ; ---------------------------------------------------------------------------
  2144                                  ;**	This table was created by examining the source and may not be
  2145                                  ;	complete or completely accurate - JGL
  2146                                  ;
  2147                                  ;	M010	MD	8/31/90 - Added definition for AH = 5
  2148                                  
  2149                                  ;	(ah) = 0	installation check
  2150                                  ;			   (returns ah !=0 if installed)
  2151                                  ;	(ah) = 1	cooked net bios call
  2152                                  ;	(ah) = 3	query drive shared
  2153                                  ;			   (ds:si) = "n:" asciz string
  2154                                  ;	(ah) = 4	net bios
  2155                                  ;	       (al) = 0	   cooked net bios call
  2156                                  ;	       (al) = 1	   raw net bios call
  2157                                  ;	       (al) = 2	   ???
  2158                                  ;
  2159                                  ;	(ah) = 5	Get Net Adaptor Resources. CX returns the number of
  2160                                  ;			NCBs available/outstanding. DX returns the number of
  2161                                  ;			sessions. Supposedly, this is documented in an old
  2162                                  ;			IBM PC-LAN reference. Lotus Notes uses it. DOS LAN
  2163                                  ;			Manager 2.0 Enhanced responds to it. But it should
  2164                                  ;			not be used, as it is a hack, only to get Lotus
  2165                                  ;			Notes running.
  2166                                  ;
  2167                                  ;	(ah) = 80h	enter critical section
  2168                                  ;	(ah) = 81h	leave critical section
  2169                                  ;	(ah) = 82h	free all critical sections (Leave-all)
  2170                                  ;	(ah) = 84h	entering idle loop (don't understand how this works)
  2171                                  ; ---------------------------------------------------------------------------
  2172                                  
  2173                                  ;**	Critical section definitions
  2174                                  ; ---------------------------------------------------------------------------
  2175                                  ;	Although DOS is not designed to be reentrant there are some hacks
  2176                                  ;	which various programs use to make it so, in a limited fashion.
  2177                                  ;	Both WIN386 and some servers block copy a section of the DOS data
  2178                                  ;	area so that DOS can be reentered on behalf of another thread/program.
  2179                                  ;	DOS's global data structures, such as the memory arena, are not
  2180                                  ;	in this area, so critical section indicators are used to protect
  2181                                  ;	those areas.  DOS flags a critical section by issuing an INT_IBM
  2182                                  ;	(int 2Ah) at each critical section entry and exit.  Some clients
  2183                                  ;	(such as WIN386) just don't "context switch" the DOS when one
  2184                                  ;	of these is in effect, others, such as the IBM server, go ahead
  2185                                  ;	and reenter the DOS and if they get an int 2A to reenter the same
  2186                                  ;	critical section they then switch away from that second thread and
  2187                                  ;	let the first one finish and exit the section.
  2188                                  ; ---------------------------------------------------------------------------
  2189                                  
  2190                                  ; These below are subject to leave-all sections
  2191                                  critDisk    EQU     1			; Disk I/O critical section
  2192                                  critShare   EQU     1			; Sharer I/O critical section
  2193                                  critMem     EQU     1			; memory maintenance critical section
  2194                                  critSFT     EQU     1			; sft table allocation
  2195                                  critDevice  EQU     2			; Device I/O critical section
  2196                                  critNet     EQU     5			; network critical section
  2197                                  critIFS     EQU     6			; ifsfunc critical section
  2198                                  ; These below are not subject to leave-all sections
  2199                                  critASSIGN  EQU     8			; Assign has munged a system call
  2200                                  
  2201                                  ;============================================================================
  2202                                  ; MULT.INC (MSDOS 6.0, 1991)
  2203                                  ;============================================================================
  2204                                  ; 04/05/2019 - Retro DOS v4.0
  2205                                  
  2206                                  ;Break <Multiplex channels>
  2207                                  
  2208                                  ; ---------------------------------------------------------------------------
  2209                                  ; The current set of defined multiplex channels is (* means documented):
  2210                                  ;
  2211                                  ;   Channel(h)  Issuer          Receiver    Function
  2212                                  ;      00       server          PSPRINT     print job control
  2213                                  ;     *01       print/apps      PRINT       Queueing of files
  2214                                  ;      02       BIOS            REDIR       signal open/close of printers
  2215                                  ;
  2216                                  ;      05       command         REDIR       obtain text of net int 24 message
  2217                                  ;     *06       server/assign   ASSIGN      Install check
  2218                                  ;
  2219                                  ;      08       external driver IBMBIO      interface to internal routines
  2220                                  ;
  2221                                  ;      10       sharer/server   Sharer      install check
  2222                                  ;      11       DOS/server      Redir       install check/redirection funcs
  2223                                  ;      12       sharer/redir    DOS         dos functions and structure maint
  2224                                  ;      13       MSNET           MSNET       movement of NCBs
  2225                                  ;      13       external driver IBMBIO      Reset_Int_13, allows installation
  2226                                  ;                                           of alternative INT_13 drivers after
  2227                                  ;                                           boot_up
  2228                                  ;      14 (IBM) DOS             NLSFUNC     down load NLS country info,DOS 3.3
  2229                                  ;      14 (MS)  APPS            POPUP       MSDOS 4 popup screen functions
  2230                                  ;      15       APPS            MSCDEX      CD-ROM extensions interface
  2231                                  ;      16       WIN386          WIN386      Windows communications
  2232                                  ;      17       Clipboard       WINDOWS     Clipboard interface
  2233                                  ;     *18       Applications    MS-Manger   Toggle interface to manager
  2234                                  ;      19       Shell
  2235                                  ;      1A       Ansi.sys
  2236                                  ;      1B       Fastopen,Vdisk   IBMBIO     EMS INT 67H stub handler
  2237                                  ;
  2238                                  ;      40h      OS/2
  2239                                  ;      41h      Lanman
  2240                                  ;      42h      Lanman
  2241                                  ;      43h      Himem
  2242                                  ;                               AL = 20h    reserved for Mach 20 Himem support
  2243                                  ;                               AL = 30h    reserved for Himem external A20 code
  2244                                  ;      44h      Dosextender
  2245                                  ;      45H      Windows profiler
  2246                                  ;      46h      Windows/286 DOS extender
  2247                                  ;      47h      Basic Compiler Vn. 7.0
  2248                                  ;      48h      Doskey
  2249                                  ;      49h      DOS 5.x install 
  2250                                  ;      4Ah      Multi Purpose
  2251                                  ;                multMULTSWPDSK         0 - Swap Disk in drive A (BIOS)
  2252                                  ;                multMULTGETHMAPTR      1 - Get available HMA & ptr
  2253                                  ;                multMULTALLOCHMA       2 - Allocate HMA (bx == no of bytes)
  2254                                  ;                multMULTTASKSHELL      5 - Shell/switcher API
  2255                                  ;                multMULTRPLTOM         6 - Top Of Memory for RPL support
  2256                                  ;
  2257                                  ;                multSmartdrv           10h
  2258                                  ;                multMagicdrv           11h
  2259                                  ;      4Bh      Task Switcher API
  2260                                  ;
  2261                                  ;      4Ch      APPS            APM         Advanced power management
  2262                                  ;      4Dh      Kana Kanji Converter, MSKK
  2263                                  ;
  2264                                  ;      51h      ODI real mode support driver (for Chicago)
  2265                                  ;
  2266                                  ;      53h      POWER.EXE - used for broadcasting APM events    ; M036
  2267                                  ;      54h      POWER.EXE - used for POWER API                  ; M036
  2268                                  ;
  2269                                  ;      55h      COMMAND.COM
  2270                                  ;                multCOMFIRST           0 - API to determine whether 1st
  2271                                  ;                                           instance of command.com
  2272                                  ;                multCOMFIRSTROM        1 - API to determine whether 1st
  2273                                  ;                                           instance of ROM COMMAND
  2274                                  ;      56h      Sewell Development
  2275                                  ;               INTERLNK
  2276                                  ;
  2277                                  ;      57h      Iomega Corp.
  2278                                  ;
  2279                                  ;      ABh      Unspecified IBM use
  2280                                  ;      ACh      Graphics
  2281                                  ;      ADh      NLS (toronto)
  2282                                  ;      AEh
  2283                                  ;      AFh      Mode
  2284                                  ;      B0h      GRAFTABL        GRAFTABL
  2285                                  ;
  2286                                  ;      D7h      Banyan VINES
  2287                                  ; ---------------------------------------------------------------------------
  2288                                  
  2289                                  ;MUX 00-3F reserverd for IBM
  2290                                  ;MUX 80-BF reserverd for IBM
  2291                                  
  2292                                  ;MUX 40-7F reserved for Microsoft
  2293                                  
  2294                                  ;MUX C0-FF users
  2295                                  
  2296                                  MultSHARE   EQU     10h 		; sharer
  2297                                      ;	1   MFT_enter
  2298                                      ;	2   MFTClose
  2299                                      ;	3   MFTclU
  2300                                      ;	4   MFTCloseP
  2301                                      ;	5   MFTCloN
  2302                                      ;	6   set_block
  2303                                      ;	7   clr_block
  2304                                      ;	8   chk_block
  2305                                      ;	9   MFT_get
  2306                                      ;	10  ShSave
  2307                                      ;	11  ShChk
  2308                                      ;	12  ShCol
  2309                                      ;	13  ShCloseFile
  2310                                  
  2311                                  MultNET     EQU     11h 		; Network support
  2312                                  MultIFS     EQU     11h                 ; Network support
  2313                                      ;   1   IFS_RMDIR
  2314                                      ;   2   IFS_SEQ_RMDIR
  2315                                      ;   3   IFS_MKDIR
  2316                                      ;   4   IFS_SEQ_MKDIR
  2317                                      ;   5   IFS_CHDIR
  2318                                      ;   6   IFS_CLOSE
  2319                                      ;   7   IFS_COMMIT
  2320                                      ;   8   IFS_READ
  2321                                      ;   9   IFS_WRITE
  2322                                      ;   10  IFS_LOCK
  2323                                      ;   11  IFS_UNLOCK
  2324                                      ;   12  IFS_DISK_INFO
  2325                                      ;   13  IFS_SET_FILE_ATTRIBUTE
  2326                                      ;   14  IFS_SEQ_SET_FILE_ATTRIBUTE
  2327                                      ;   15  IFS_GET_FILE_INFO
  2328                                      ;   16  IFS_SEQ_GET_FILE_INFO
  2329                                      ;   17  IFS_RENAME
  2330                                      ;   18  IFS_SEQ_RENAME
  2331                                      ;   19  IFS_DELETE
  2332                                      ;   20  IFS_SEQ_DELETE
  2333                                      ;   21  IFS_OPEN
  2334                                      ;   22  IFS_SEQ_OPEN
  2335                                      ;   23  IFS_CREATE
  2336                                      ;   24  IFS_SEQ_CREATE
  2337                                      ;   25  IFS_SEQ_SEARCH_FIRST
  2338                                      ;   26  IFS_SEQ_SEARCH_NEXT
  2339                                      ;   27  IFS_SEARCH_FIRST
  2340                                      ;   28  IFS_SEARCH_NEXT
  2341                                      ;   29  IFS_ABORT
  2342                                      ;   30  IFS_ASSOPER
  2343                                      ;   31  Printer_SET_STRING
  2344                                      ;   32  IFSFlushBuf
  2345                                      ;   33  IFSBufWrite
  2346                                      ;   34  IFSResetEnvironment
  2347                                      ;   35  IFSSpoolCheck
  2348                                      ;   36  IFSSpoolClose
  2349                                      ;   37  IFSDeviceOper
  2350                                      ;   38  IFSSpoolEchoCheck
  2351                                      ;   39      - - -   Unused   - - -
  2352                                      ;   40      - - -   Unused   - - -
  2353                                      ;   41      - - -   Unused   - - -
  2354                                      ;   42  SERVER_DOSCALL_CLOSEFILES_FOR_UID
  2355                                      ;   43  DEVICE_IOCTL
  2356                                      ;   44  IFS_UPDATE_CB
  2357                                      ;   45  IFS_FILE_XATTRIBUTES
  2358                                      ;   46  IFS_XOPEN
  2359                                      ;   47  IFS_DEPENDENT_IOCTL
  2360                                  
  2361                                  MultDOS     EQU     12h 		; DOS call back
  2362                                      ;	1   DOS_CLOSE
  2363                                      ;	2   RECSET
  2364                                      ;	3   Get DOSGROUP
  2365                                      ;	4   PATHCHRCMP
  2366                                      ;	5   OUT
  2367                                      ;	6   NET_I24_ENTRY
  2368                                      ;	7   PLACEBUF
  2369                                      ;	8   FREE_SFT
  2370                                      ;	9   BUFWRITE
  2371                                      ;	10  SHARE_VIOLATION
  2372                                      ;	11  SHARE_ERROR
  2373                                      ;	12  SET_SFT_MODE
  2374                                      ;	13  DATE16
  2375                                      ;	14  SETVISIT
  2376                                      ;	15  SCANPLACE
  2377                                      ;	16  SKIPVISIT
  2378                                      ;	17  StrCpy
  2379                                      ;	18  StrLen
  2380                                      ;	19  UCase
  2381                                      ;	20  POINTCOMP
  2382                                      ;	21  CHECKFLUSH
  2383                                      ;	22  SFFromSFN
  2384                                      ;	23  GetCDSFromDrv
  2385                                      ;	24  Get_User_Stack
  2386                                      ;	25  GetThisDrv
  2387                                      ;	26  DriveFromText
  2388                                      ;	27  SETYEAR
  2389                                      ;	28  DSUM
  2390                                      ;	29  DSLIDE
  2391                                      ;	30  StrCmp
  2392                                      ;	31  initcds
  2393                                      ;	32  pjfnfromhandle
  2394                                      ;	33  $NameTrans
  2395                                      ;	34  CAL_LK
  2396                                      ;	35  DEVNAME
  2397                                      ;	36  Idle
  2398                                      ;   37  DStrLen
  2399                                      ;   38  NLS_OPEN      DOS 3.3
  2400                                      ;   39  $CLOSE        DOS 3.3
  2401                                      ;   40  NLS_LSEEK     DOS 3.3
  2402                                      ;   41  $READ         DOS 3.3
  2403                                      ;   42  FastInit      DOS 4.0
  2404                                      ;   43  NLS_IOCTL     DOS 3.3
  2405                                      ;   44  GetDevList    DOS 3.3
  2406                                      ;   45  NLS_GETEXT    DOS 3.3
  2407                                      ;   46  MSG_RETRIEVAL DOS 4.0
  2408                                      ;   47  FAKE_VERSION  DOS 4.0
  2409                                  
  2410                                  NLSFUNC     EQU     14h 		; NLSFUNC CALL , DOS 3.3
  2411                                      ;	0   NLSInstall
  2412                                      ;	1   ChgCodePage
  2413                                      ;	2   GetExtInfo
  2414                                      ;	3   SetCodePage
  2415                                      ;	4   GetCntry
  2416                                  
  2417                                  multANSI    EQU     1Ah                 ; ANSI multiplex number
  2418                                      ;   0   INSTALL_CHECK               ; install check for ANSI
  2419                                      ;   1   IOCTL_2F                    ; 2F interface to IOCTL
  2420                                      ;   2   DA_INFO_2F                  ; J.K. Information passing to ANSI.
  2421                                  
  2422                                  multMULT        EQU     4Ah
  2423                                  multMAGIC       EQU     256*multMULT + 11h
  2424                                  multMULTRPLTOM  EQU     06h
  2425                                  
  2426                                      ;   0   swap disk function for single floppy drive m/cs
  2427                                      ;       BIOS broadcasts with cx==0, and apps who handle
  2428                                      ;       swap disk messaging set cx == -1. BIOS sets dl == requested
  2429                                      ;       drive
  2430                                      ;
  2431                                      ;   1   Get available HMA & pointer to it. Returns in BX & ES:DI
  2432                                      ;   2   Allocate HMA. BX == number of bytes in HMA to be allocated
  2433                                      ;       returns pointer in ES:DI
  2434                                      ;
  2435                                      ;   3-4 currently used by nobody
  2436                                      ;   5   Switcher API
  2437                                      ;   6   Top of Memory for RPL.
  2438                                      ;           BIOS issues INT 2f AX=4a06 & DX = Top of Mem and any RPL
  2439                                      ;           code present in TOM should respond with a new TOM in DX
  2440                                      ;           to protect itself from MSLOAD & SYSINIT tromping over it.
  2441                                      ;           SYSINIT builds an arena with owner type 8 & name 'RPL' to
  2442                                      ;           protect the RPL code from COMMAND.COM transient protion.
  2443                                      ;           It is the responsibility of RPL program to release the mem.
  2444                                      ;   7   Reserved for PROTMAN support.
  2445                                      ;  10   smartdrv 4.0
  2446                                      ;  11   dblspace api
  2447                                      ;  12   MRCI     api
  2448                                      ;  13   dblspace/mrci stealth packet api
  2449                                  
  2450                                  MultAPM     EQU     4ch             ; Obselete ???
  2451                                      ;       00h     APM_VER_CHK
  2452                                      ;       01h     APM_SUS_SYS_REQ
  2453                                      ;       FFh     APM_SUS_RES_BATT_NOTIFY
  2454                                  
  2455                                  MultPWR_BRDCST  EQU     53h     ; Used by POWER.EXE to broadcast      ; M036
  2456                                  				;  APM events                         ; M036
  2457                                  MultPWR_API     EQU     54h     ; Used for accessing POWER.EXE's API  ; M036
  2458                                  
  2459                                  ;FASTOPEN is not chained through INT 2F   ; DOS 3.3 F.C.
  2460                                  ;	  it calls Multdos 42 to set up an entry routine address
  2461                                      ;	0   Install status  (reserved)
  2462                                      ;	1   Lookup
  2463                                      ;	2   Insert
  2464                                      ;	3   Delete
  2465                                      ;	4   Purge	    (reserved)
  2466                                  
  2467                                  ;============================================================================
  2468                                  ; FIND.INC (MSDOS 6.0, 1991)
  2469                                  ;============================================================================
  2470                                  ; 17/05/2019 - Retro DOS v4.0
  2471                                  ; 09/07/2018 - Retro DOS v3.0 (MSDOS 3.3, 1987)
  2472                                  
  2473                                  ;Break	<find first/next buffer>
  2474                                  
  2475                                  struc find_buf
  2476 00000000 ??                      .drive:	    resb 1		; drive of search
  2477 00000001 <res Bh>                .name:	    resb 11		; formatted name
  2478 0000000C ??                      .sattr:	    resb 1		; attribute of search
  2479 0000000D ????                    .LastEnt:   resw 1		; LastEnt
  2480 0000000F ????                    .DirStart:  resw 1		; DirStart
  2481 00000011 ????????                .NETID:	    resb 4 ; MSDOS 6.0 	; Reserved for NET
  2482 00000015 ??                      .attr:	    resb 1		; attribute found
  2483 00000016 ????                    .time:	    resw 1		; time
  2484 00000018 ????                    .date:	    resw 1		; date
  2485 0000001A ????                    .size_l:    resw 1		; low(size)
  2486 0000001C ????                    .size_h:    resw 1		; high(size)
  2487 0000001E <res Dh>                .pname:	    resb 13		; packed name
  2488                                  .size:
  2489                                  endstruc
  2490                                  
  2491                                  ;============================================================================
  2492                                  ; DOSCNTRY.INC (MSDOS 6.0, 1991)
  2493                                  ;============================================================================
  2494                                  ; 29/04/2019 - Retro DOS v4.0
  2495                                  ; 09/07/2018 - Retro DOS v3.0 (MSDOS 3.3, 1987)
  2496                                  
  2497                                  ;Equates for COUNTRY INFORMATION.
  2498                                  SetCountryInfo	EQU	1	;country info
  2499                                  SetUcase	EQU	2	;uppercase table
  2500                                  SetLcase	EQU	3	;lowercase table (Reserved)
  2501                                  SetUcaseFile	EQU	4	;uppercase file spec table
  2502                                  SetFileList	EQU	5	;valid file character list
  2503                                  SetCollate	EQU	6	;collating sequence
  2504                                  SetDBCS 	EQU	7	;double byte character set
  2505                                  SetALL		EQU	-1	;all the entries
  2506                                  
  2507                                  ;DOS country and code page information table structure.
  2508                                  ;Internally, IBMDOS gives a pointer to this table.
  2509                                  ;IBMBIO, MODE and NLSFUNC modules communicate with IBMDOS through
  2510                                  ;this structure.
  2511                                  
  2512                                  struc  DOS_CCDPG	; DOS_country_cdpg_info
  2513 00000000 ????????????????        .ccInfo_reserved: 	resb 8	;reserved for internal use
  2514 00000008 <res 40h>               .ccPath_CountrySys:	resb 64 ;path and filename for country info
  2515 00000048 ????                    .ccSysCodePage:		resw 1	;system code page id
  2516 0000004A ????                    .ccNumber_of_entries:	resw 1  ; (default value = 6)
  2517 0000004C ??                      .ccSetUcase:		resb 1  ; (default value = SetUcase)
  2518 0000004D ????????                .ccUcase_ptr:		resd 1	;pointer to Ucase table
  2519                                  
  2520 00000051 ??                      .ccSetUcaseFile:	resb 1	; (default value = SetUcaseFile)
  2521 00000052 ????????                .ccFileUcase_ptr: 	resd 1	;pointer to File Ucase table
  2522                                  
  2523 00000056 ??                      .ccSetFileList:		resb 1 	; (default value = SetFileList)
  2524 00000057 ????????                .ccFileChar_ptr:	resd 1	;pointer to File char list table
  2525                                  
  2526 0000005B ??                      .ccSetCollate:		resb 1	; (default value = SetCollate)
  2527 0000005C ????????                .ccCollate_ptr:		resd 1	;pointer to collate table
  2528                                  
  2529                                  ; MSDOS 6.0
  2530 00000060 ??                      .ccSetDBCS:		resb 1	; (default value = SetDBCS)
  2531 00000061 ????????                .ccDBCS_ptr:		resd 1	; pointer to DBCS table
  2532                                  
  2533 00000065 ??                      .ccSetCountryInfo:	resb 1  ; (default value = SetCountryInfo)
  2534 00000066 ????                    .ccCountryInfoLen:	resw 1	;length of country info
  2535 00000068 ????                    .ccDosCountry:		resw 1	;system country code id
  2536 0000006A ????                    .ccDosCodePage:		resw 1	;system code page id
  2537 0000006C ????                    .ccDFormat:		resw 1	;date format
  2538 0000006E ??????????              .ccCurSymbol:		resb 5	;5 byte of (currency symbol+0)
  2539 00000073 ????                    .cc1000Sep:		resb 2	;2 byte of (1000 sep. + 0)
  2540 00000075 ????                    .ccDecSep:		resb 2	;2 byte of (Decimal sep. + 0)
  2541 00000077 ????                    .ccDateSep:		resb 2	;2 byte of (date sep. + 0)
  2542 00000079 ????                    .ccTimeSep:		resb 2	;2 byte of (time sep. + 0)
  2543 0000007B ??                      .ccCFormat:		resb 1	;currency format flags
  2544 0000007C ??                      .ccCSigDigits:		resb 1	;# of digits in currency
  2545 0000007D ??                      .ccTFormat:		resb 1	;time format
  2546 0000007E ????????                .ccMono_ptr:		resd 1	;monocase routine entry point
  2547 00000082 ????                    .ccListSep:		resb 2	;data list separator
  2548 00000084 <res Ah>                .ccReserved_area: 	resw 5	;reserved
  2549                                  .size:
  2550                                  endstruc
  2551                                  
  2552                                  ;Ucase table
  2553                                  struc CC_UCASE_TAB
  2554 00000000 ????                    .ccUcase_leng:		resw 1	; (default value = 128)
  2555 00000002 <res 80h>               .ccUcase_data:		resb 128
  2556                                  endstruc
  2557                                  
  2558                                  ;File Ucase table
  2559                                  struc CC_FILE_UCASE_TAB
  2560 00000000 ????                    .ccFileucase_leng:	resw 1	; (default value = 128)
  2561 00000002 <res 80h>               .ccFileucase_data:	resb 128
  2562                                  endstruc
  2563                                  
  2564                                  ;File char list
  2565                                  struc CC_FILE_CHAR_TAB
  2566 00000000 ????                    .ccFilechar_leng:	resw 1
  2567 00000002 <res 2Eh>               .ccFilechar_data:	resb 46
  2568                                  endstruc
  2569                                  
  2570                                  ;collate table
  2571                                  struc CC_COLLATE_TAB
  2572 00000000 ????                    .ccCollate_leng:	resw 1	; (default value = 128)
  2573 00000002 <res 100h>              .ccCollate_data:	resb 256
  2574                                  endstruc
  2575                                  
  2576                                  OLD_COUNTRY_SIZE  equ	(DOS_CCDPG.size - DOS_CCDPG.ccDFormat - 10)
  2577                                  NEW_COUNTRY_SIZE  equ	(DOS_CCDPG.size - DOS_CCDPG.ccDosCountry) ; 38
  2578                                  
  2579                                  ; 06/08/2018
  2580                                  ; DOSCNTRY.INC (MSDOS 6.0, 1991)
  2581                                  
  2582                                  ;CAPITALIZATION equates
  2583                                  CAP_ONE_CHAR	equ	20H
  2584                                  CAP_STRING	equ	21H
  2585                                  CAP_ASCIIZ	equ	22H
  2586                                  CHECK_YES_NO	equ	23H
  2587                                  UPPER_TABLE	equ	80H
  2588                                  
  2589                                  ;NLS_YES	equ	59H  ; 'Y'
  2590                                  ;NLS_yes2	equ	79H  ; 'y' 	
  2591                                  ;NLS_NO		equ	4EH  ; 'N'	
  2592                                  ;NLS_no2	equ	6EH  ; 'n'	
  2593                                  
  2594                                  ;============================================================================
  2595                                  ; CURDIR.INC (MSDOS 6.0, 1991)
  2596                                  ;============================================================================
  2597                                  ; 25/04/2019 - Retro DOS v4.0
  2598                                  ; 09/07/2018 - Retro DOS v3.0 (CURDIR.INC, MSDOS 3.3, 1987)
  2599                                  
  2600                                  ;BREAK <Current directory list structure>
  2601                                  
  2602                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  2603                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  2604                                  ;									   ;
  2605                                  ; CDS items are used bu the internal routines to store cluster numbers and ;
  2606                                  ; network identifiers for each logical name.  The ID field is used dually, ;
  2607                                  ; both as net ID and for a cluster number for local devices.  In the case  ;
  2608                                  ; of local devices, the cluster number will be -1 if there is a potential  ;
  2609                                  ; of the disk being changed or if the path must be recracked.		   ;
  2610                                  ;
  2611                                  ;	Some pathnames have special preambles, such as
  2612                                  ;
  2613                                  ;		\\machine\sharename\...
  2614                                  ;	For these pathnames we can't allow ".." processing to back us
  2615                                  ;	up into the special front part of the name.  The CURDIR_END field
  2616                                  ;	holds the address of the seperator character which marks
  2617                                  ;	the split between the special preamble and the regular
  2618                                  ;	path list; ".." processing isn't allowed to back us up past
  2619                                  ;	(i.e., before) CURDIR_END
  2620                                  ;	For the root, it points at the leading /.  For net
  2621                                  ;	assignments it points at the end (nul) of the initial assignment:
  2622                                  ;	A:/	\\foo\bar	    \\foo\bar\blech\bozo
  2623                                  ;	  ^		 ^		     ^
  2624                                  
  2625                                  DIRSTRLEN	EQU	64+3		; Max length in bytes of directory strings
  2626                                  TEMPLEN 	EQU	DIRSTRLEN*2
  2627                                  
  2628                                  struc curdir	; curdir_list
  2629 00000000 <res 43h>               .text:		resb DIRSTRLEN		; text of assignment and curdir
  2630 00000043 ????                    .flags:		resw 1			; various flags
  2631 00000045 ????????                .devptr:	resd 1			; local pointer to DPB or net device
  2632 00000049 ????????                .ID:		resw 2			; cluster of current dir (net ID)
  2633 0000004D ????                    .user_word:	resw 1
  2634 0000004F ????                    .end:		resw 1			; index to ".." backup limit - see above
  2635                                  ; MSDOS 6.0
  2636 00000051 ??                      .type:		resb 1			; IFS drive (2=ifs, 4=netuse)
  2637 00000052 ????????                .ifs_hdr:	resd 1			; Ptr to File System Header
  2638 00000056 ????                    .fsda:		resb 2			; File System Dependent Data Area
  2639                                  .size:
  2640                                  endstruc
  2641                                  
  2642                                  curdirLen	EQU curdir.size	; 88	; Needed for screwed up
  2643                                  
  2644                                  %define curdir_netID curdir_ID  ; dword
  2645                                  
  2646                                  ;**	Flag values for CURDIR_FLAGS
  2647                                  
  2648                                  curdir_isnet	EQU	1000000000000000B
  2649                                  CURDIR_isifs	EQU	1000000000000000B ; MSDOS 6.0	
  2650                                  curdir_inuse	EQU	0100000000000000B
  2651                                  curdir_splice	EQU	0010000000000000B
  2652                                  curdir_local	EQU	0001000000000000B
  2653                                  
  2654                                  ;									   ;
  2655                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  2656                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  2657                                  
  2658                                  ;============================================================================
  2659                                  ; CPMFCB.INC (MSDOS 3.3, 1987)
  2660                                  ;============================================================================
  2661                                  ; 09/07/2018 - Retro DOS v3.0
  2662                                  
  2663                                  ;BREAK <File Control Block definition>
  2664                                  
  2665                                  ;
  2666                                  ; Field definition for FCBs
  2667                                  ; The FCB has the following structure:
  2668                                  ;
  2669                                  ;	+---------------------------+
  2670                                  ;	|   Drive indicator(byte)   |
  2671                                  ;	+---------------------------+
  2672                                  ;	|    Filename (8 chars)     |
  2673                                  ;	+---------------------------+
  2674                                  ;	|    Extension (3 chars)    |
  2675                                  ;	+---------------------------+
  2676                                  ;	|   Current Extent(word)    |
  2677                                  ;	+---------------------------+
  2678                                  ;	|    Record size (word)     |
  2679                                  ;	+---------------------------+
  2680                                  ;	|    File Size (2 words)    |
  2681                                  ;	+---------------------------+
  2682                                  ;	|	Date of write	    |
  2683                                  ;	+---------------------------+
  2684                                  ;	|	Time of write	    |
  2685                                  ;	+---------------------------+
  2686                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  2687                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  2688                                  ;									   ;
  2689                                  ;	+---------------------------+
  2690                                  ;	|   8 bytes reserved	    |
  2691                                  ;	+---------------------------+
  2692                                  ;									   ;
  2693                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  2694                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  2695                                  ;	|    next record number     |
  2696                                  ;	+---------------------------+
  2697                                  ;	|   random record number    |
  2698                                  ;	+---------------------------+
  2699                                  ;
  2700                                  
  2701                                  struc	SYS_FCB
  2702 00000000 ??                      .drive:	resb 1
  2703 00000001 ????????????????        .name:	resb 8
  2704 00000009 ??????                  .ext:	resb 3
  2705 0000000C ????                    .EXTENT: resw 1
  2706 0000000E ????                    .RECSIZ: resw 1			; Size of record (user settable)
  2707 00000010 ????                    .FILSIZ: resw 1			; Size of file in bytes; used with the
  2708                                  				; following word
  2709 00000012 ????                    .DRVBP:	resw 1			; BP for SEARCH FIRST and SEARCH NEXT
  2710 00000014 ????                    .FDATE:	resw 1			; Date of last writing
  2711 00000016 ????                    .FTIME:	resw 1			; Time of last writing
  2712                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  2713                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  2714                                  ;									   ;
  2715 00000018 ????????????????        .reserved: resb 8		; RESERVED
  2716                                  ;									   ;
  2717                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  2718                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  2719 00000020 ??                      .NR:	resb 1			; Next record
  2720 00000021 ????????                .RR:	resb 4			; Random record
  2721                                  .size:
  2722                                  endstruc
  2723                                  
  2724                                  FILDIRENT EQU SYS_FCB.FILSIZ	; Used only by SEARCH FIRST and SEARCH
  2725                                  				; NEXT
  2726                                  ; 20/07/2018
  2727                                  %define fcb_sfn	SYS_FCB.reserved ; byte
  2728                                  
  2729                                  ; Note that fcb_net_handle, fcb_nsl_drive, fcb_nsld_drive and fcb_l_drive
  2730                                  ; all must point to the same byte.  Otherwise, the FCBRegen will fail.
  2731                                  ; NOTE about this byte (fcb_nsl_drive)
  2732                                  ;   The high two bits of this byte are used as follows to indicate the FCB type
  2733                                  ;	00 means a local file or device with sharing loaded
  2734                                  ;	10 means a remote (network) file
  2735                                  ;	01 means a local file with no sharing loaded
  2736                                  ;	11 means a local device with no sharing loaded
  2737                                  
  2738                                  ; 20/07/2018
  2739                                  
  2740                                  ;
  2741                                  ; Network FCB
  2742                                  ;
  2743                                  
  2744                                  %define fcb_net_drive	SYS_FCB.reserved+1  ; byte
  2745                                  %define fcb_net_handle	SYS_FCB.reserved+2  ; word
  2746                                  %define fcb_netID	SYS_FCB.reserved+4  ; dword		
  2747                                  
  2748                                  ;
  2749                                  ; No sharing local file FCB
  2750                                  ;
  2751                                  
  2752                                  %define fcb_nsl_drive	SYS_FCB.reserved+1  ; byte
  2753                                  %define fcb_nsl_bits	SYS_FCB.reserved+2  ; byte	
  2754                                  %define fcb_nsl_firclus SYS_FCB.reserved+3  ; word	
  2755                                  %define fcb_nsl_dirsec	SYS_FCB.reserved+5  ; word
  2756                                  %define fcb_nsl_dirpos  SYS_FCB.reserved+7  ; byte
  2757                                  
  2758                                  ;
  2759                                  ; No sharing local device FCB
  2760                                  ;
  2761                                  
  2762                                  %define fcb_nsld_drive	SYS_FCB.reserved+1  ; byte	
  2763                                  %define fcb_nsld_drvptr SYS_FCB.reserved+2  ; dword
  2764                                  
  2765                                  ;
  2766                                  ; Sharing local FCB
  2767                                  ;
  2768                                  
  2769                                  %define fcb_l_drive	SYS_FCB.reserved+1  ; byte
  2770                                  %define fcb_l_firclus	SYS_FCB.reserved+2  ; word
  2771                                  %define fcb_l_mfs	SYS_FCB.reserved+4  ; word
  2772                                  %define fcb_l_attr	SYS_FCB.reserved+6  ; byte
  2773                                  
  2774                                  ;
  2775                                  ; Bogusness:  the four cases are:
  2776                                  ;
  2777                                  ;   local file	    00
  2778                                  ;   local device    40
  2779                                  ;   local sharing   C0
  2780                                  ;   network	    80
  2781                                  ;
  2782                                  ; Since sharing and network collide, we cannot use a test instruction for
  2783                                  ; deciding whether a network or a share check in involved
  2784                                  ;
  2785                                  FCBDEVICE   EQU 040h
  2786                                  FCBNETWORK  EQU 080h
  2787                                  FCBSHARE    EQU 0C0h
  2788                                  
  2789                                  ; FCBSPECIAL must be able to mask off both net and share
  2790                                  FCBSPECIAL  EQU 080h
  2791                                  FCBMASK     EQU 0C0h
  2792                                  
  2793                                  ;============================================================================
  2794                                  ; FASTOPEN.INC, MSDOS 6.0, 1991
  2795                                  ;============================================================================
  2796                                  ; 11/07/2018 - Retro DOS v3.0
  2797                                  ; 25/04/2019 - Retro DOS v4.0
  2798                                  
  2799                                  struc FEI	; FASTOPEN_EXTENDED_INFO
  2800 00000000 ??                      .dirpos:	resb 1
  2801 00000001 ????????                .dirsec:	resd 1 ; MSDOS 6.0
  2802                                  ;.dirsec:	resw 1 ; MSDOS 3.3
  2803 00000005 ????                    .clusnum:	resw 1
  2804 00000007 ????                    .lastent:	resw 1	; for search first ; MSDOS 6.0
  2805 00000009 ????                    .dirstart:	resw 1	; for search first ; MSDOS 6.0
  2806                                  .size:
  2807                                  endstruc
  2808                                  
  2809                                  ; 23/07/2018
  2810                                  ;FASTOPEN NAME CACHING Subfunctions
  2811                                  FONC_Look_up	equ	1
  2812                                  FONC_insert	equ	2
  2813                                  FONC_delete	equ	3
  2814                                  FONC_update	equ	4
  2815                                  FONC_purge	equ	5	;reserved for the future use.
  2816                                  FONC_Rename	equ	6	;AN001
  2817                                  
  2818                                  ; 27/07/2018
  2819                                  ;FastOpen Data Structure
  2820                                  struc fastopen_entry	;Fastopen Entry pointer in DOS
  2821 00000000 ????                    .entry_size:	resw 1	; = 4	; size of the following
  2822 00000002 ????????                .name_caching:	resd 1
  2823                                  ; MSDOS 6.0
  2824                                  ;.fatchain_caching: resd 1	;reserved for future use
  2825                                  .size:
  2826                                  endstruc
  2827                                  
  2828                                  ; 27/07/2018
  2829                                  ;Equates used in DOS.
  2830                                  FastOpen_Set	       equ     00000001b
  2831                                  FastOpen_Reset	       equ     11111110b
  2832                                  Lookup_Success	       equ     00000010b
  2833                                  Lookup_Reset	       equ     11111101b
  2834                                  Special_Fill_Set       equ     00000100b
  2835                                  Special_Fill_Reset     equ     11111011b
  2836                                  No_Lookup	       equ     00001000b
  2837                                  Set_For_Search	       equ     00010000b	;DCR 167
  2838                                  
  2839                                  ; 09/08/2018 
  2840                                  ; (FASTXXXX.INC, MSDOS 6.0, 1991)
  2841                                  ; Fastxxx equates
  2842                                  FastOpen_ID	   equ	   1
  2843                                  FastSeek_ID	   equ	   2
  2844                                  Fast_yes	   equ	   10000000B	 ; fastxxx flag
  2845                                  
  2846                                  ;Structure definitions
  2847                                  ;
  2848                                  struc Fasttable_Entry	 ; Fastxxx  Entry pointer in DOS
  2849 00000000 ????                    .Fast_Entry_Num: resw 1	 ; number of entries
  2850 00000002 ????????                .FastOpen_Seek:	 resd 1	 ; fastopen & fastseek entry address
  2851                                  endstruc
  2852                                  
  2853                                  ;============================================================================
  2854                                  ; LOCK.INC, MSDOS 6.0, 1991
  2855                                  ;============================================================================
  2856                                  ; 14/07/2018 - Retro DOS v3.0
  2857                                  
  2858                                  ;**	LOCK.INC - Definitions for Record Locking
  2859                                  
  2860                                  ;**	LOCK functions
  2861                                  
  2862                                  LOCK_ALL	    equ    0
  2863                                  UNLOCK_ALL	    equ    1
  2864                                  LOCK_MUL_RANGE	    equ    2
  2865                                  UNLOCK_MUL_RANGE    equ    3
  2866                                  LOCK_READ	    equ    4
  2867                                  WRITE_UNLOCK	    equ    5
  2868                                  LOCK_ADD	    equ    6
  2869                                  
  2870                                  ;**	Structure for Lock buffer
  2871                                  
  2872                                  struc LockBuf
  2873 00000000 ????????                .Lock_position:	resd 1		; file position for LOCK
  2874 00000004 ????????                .Lock_length:	resd 1		; number of bytes to LOCK
  2875                                  endstruc
  2876                                  
  2877                                  ;============================================================================
  2878                                  ; DPL.ASM, MSDOS 6.0, 1991
  2879                                  ;============================================================================
  2880                                  ; 04/08/2018 - Retro DOS v3.0
  2881                                  
  2882                                  ; (SRVCALL.ASM)
  2883                                  
  2884                                  struc DPL
  2885 00000000 ????                    .AX:	resw	1	; AX register
  2886 00000002 ????                    .BX:	resw	1	; BX register
  2887 00000004 ????                    .CX:	resw	1	; CX register
  2888 00000006 ????                    .DX:	resw	1	; DX register
  2889 00000008 ????                    .SI:	resw	1	; SI register
  2890 0000000A ????                    .DI:	resw	1	; DI register
  2891 0000000C ????                    .DS:	resw	1	; DS register
  2892 0000000E ????                    .ES:	resw	1	; ES register
  2893 00000010 ????                    .rsrvd: resw	1	; Reserved
  2894 00000012 ????                    .UID:	resw	1	; User (Machine) ID (0 = local macine)
  2895 00000014 ????                    .PID:	resw	1	; Process ID (0 = local user PID)
  2896                                  .size:
  2897                                  endstruc
  2898                                   
  2899                                  ;----------------------------------------------------------------------------
  2900                                  ; DOSDATA
  2901                                  ;----------------------------------------------------------------------------
  2902                                  ;============================================================================
  2903                                  ; 24/04/2019 - Retro DOS v4.0
  2904                                  
  2905                                  DosDataSg equ 3 ; DOS Data Segment address (dw in 'retrodos4.s')
  2906                                  		; ((just after resident IO.SYS code&data))
  2907                                  
  2908                                  ;============================================================================
  2909                                  ; WIN386.INC, MSDOS 6.0, 1991
  2910                                  ;============================================================================
  2911                                  ; 24/04/2019 - Retro DOS 4.0
  2912                                  
  2913                                  ;
  2914                                  ;  Symbols and structures relating to WIN386 support.
  2915                                  ;
  2916                                  ;  Used by files in both the DOS and the BIOS.
  2917                                  ;
  2918                                  ;  Created: 7-13-89 by MRW
  2919                                  ;
  2920                                  
  2921                                  ; WIN386 broadcast int 2fh multiplex number and subfunction numbers
  2922                                  
  2923                                  MultWin386		equ     16h	; Int 2f multiplex number
  2924                                  
  2925                                  Win386_Init		equ	05h	; Win386 initialization
  2926                                  Win386_Exit		equ	06h	; Win386 exit
  2927                                  Win386_Devcall		equ	07h	; Win386 device call out
  2928                                  Win386_InitDone		equ	08h	; Win386 initialization is complete
  2929                                  
  2930                                  ; When Win386_Devcall is broadcast, BX is the Device ID. DOS must 
  2931                                  ; answer call outs from the DOSMGR
  2932                                  
  2933                                  Win386_DOSMGR		equ	15H
  2934                                  
  2935                                  ; The following structures are used to communicate instance data to 
  2936                                  ; Win386 from the DOS and the BIOS. See Win386 API documentation
  2937                                  ; (chapter 3, "Call Out Interfaces") for further description.
  2938                                  
  2939                                  struc Win386_SIS	; Startup Info Structure
  2940 00000000 ????                     .Version:		resb	2	; db 3, 0
  2941 00000002 ????????                 .Next_Dev_Ptr:		resd	1	; pointer to next SIS in list
  2942 00000006 ????????                 .Virt_Dev_File_Ptr:	resd	1
  2943 0000000A ????????                 .Reference_Data:	resd	1
  2944 0000000E ????????                 .Instance_Data_Ptr:	resd	1	; pointer to instance data array
  2945                                  endstruc
  2946                                  
  2947                                  size_of_Win386_SIS equ 18 ; 24/04/2019 - Retro DOS v4.0
  2948                                  
  2949                                  struc Win386_IIS	; Instance Item Structure
  2950 00000000 ????????                .Ptr:			resd	1	; pointer to an instance item
  2951 00000004 ????                    .Size:			resw	1	; size of an instance item
  2952                                  endstruc
  2953                                  
  2954                                  size_of_Win386_IIS equ 6 ; 24/04/2019 - Retro DOS v4.0
  2955                                  
  2956                                  ;Win386 DOSMGR function return values to indicate operation done
  2957                                  
  2958                                  WIN_OP_DONE		equ	0B97Ch	; 
  2959                                  DOSMGR_OP_DONE		equ	0A2ABh	;
  2960                                  
  2961                                  ;M021
  2962                                  ; WInoldap callout multiplex number
  2963                                  
  2964                                  WINOLDAP		equ	46h	;
  2965                                  
  2966                                  ;============================================================================
  2967                                  ;----------------------------------------------------------------------------
  2968                                  ; DOSCODE
  2969                                  ;----------------------------------------------------------------------------
  2970                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  2971                                  
  2972                                  ;============================================================================
  2973                                  ; MSHEAD.ASM (MSDOS 6.0, 1991)
  2974                                  ;============================================================================
  2975                                  ; 16/07/2018 - Retro DOS 3.0
  2976                                  ;----------------------------------------------------------------------------
  2977                                  ; 24/04/2019 - Retro DOS 4.0
  2978                                  
  2979                                  ; MSDOS 6.0
  2980                                  ;----------------------------------------------------------------------------
  2981                                  ; FILE : ORIGIN.INC
  2982                                  ;----------------------------------------------------------------------------
  2983                                  ; This is included in origin.asm and mshead.asm. Contains the equate that
  2984                                  ; is used for ORGing the DOS code.
  2985                                  ;
  2986                                  ; Brief Description of the necessacity of this ORG:
  2987                                  ; -------------------------------------------------
  2988                                  ;
  2989                                  ; A special problem exits when running out of the HMA. The HMA starts at 
  2990                                  ; address FFFF:10. There is no place in the HMA with an offset of zero.
  2991                                  ; This means programs running out off the HMA must use non-zero offset base
  2992                                  ; addresses. It also means that if we're running multiple programs from the
  2993                                  ; HMA, the base offset of each segment must atleast be as big as all of the
  2994                                  ; HMA segments that precede it.
  2995                                  ; 
  2996                                  ; One solution to this problem to ORG each module at 64K minus its size.
  2997                                  ; For instance a code segment 1234h bytes in length would org'd at edcbh.
  2998                                  ; This gives max. flexibility regarding it's location in the HMA. By 
  2999                                  ; selecting segment values between f124h and ffffh it could be located 
  3000                                  ; anywhere in the HMA. The problem with this is that programs with such 
  3001                                  ; high ORGs would not be able to run in low RAM.
  3002                                  ;
  3003                                  ; A compromise solution is to set the ORG address somewhere between 0010h
  3004                                  ; and ffffh - their size. In the particular case of the BIOS and the DOS 
  3005                                  ; the following solution has been implemented:
  3006                                  ;
  3007                                  ; The Bios Code segment will have a very small offset and run at the very
  3008                                  ; front of the HMA, after the VDISK header. THE Dos Code segment will have 
  3009                                  ; a base offset of (700+<min. size off RAM based BIOS>+<min. size of the DOS
  3010                                  ; DATA segment when DOS is running low>). This will reflect the lowest 
  3011                                  ; possible physical address at which DOS code will run, while still providing
  3012                                  ; max. possible flexibility in HMA positioning. This offset MUST NOT be 
  3013                                  ; smaller then that 20+size of Bios Code segment when running high. This is 
  3014                                  ; mostly true.
  3015                                  ;
  3016                                  ; Also this ORG'd value must be communicated to the BIOS. This is done by
  3017                                  ; putting this value after the first jmp instruction in the DOS code in
  3018                                  ; mshead.asm. 
  3019                                  ;
  3020                                  ; In order for the stripz utility to know how many zeroes to be stripped 
  3021                                  ; out, this value is placed at the beginning of the binary in origin.asm.
  3022                                  ;
  3023                                  ; Revision History:
  3024                                  ;
  3025                                  ; Currently this is being done manually. Therefore any change in the DOS DATA
  3026                                  ; Size or the BIOS size should be reflected here. --- Feb 90
  3027                                  ;
  3028                                  ; BDSIZE.INC contains the equates for BIODATASIZE, BIOCODESIZ and DOSDATASIZ.
  3029                                  ; A utility called getsize will obtain the corresponding values from msdos
  3030                                  ; and msbio.map and update the values in BDSIZ.INC if they are different. 
  3031                                  ; DOS should now be built using the batch file makedos.bat which invokes this
  3032                                  ; utility. The FORMAT of BDSIZE.INC should not be changed as getsize is 
  3033                                  ; dependant on that.				  --- Apr 3 '90
  3034                                  ;
  3035                                  ; For ROMDOS, however, there is no need to org the doscode to any location
  3036                                  ; other than zero.  Therefore the stripz utility will not need to be used,
  3037                                  ; so the offset will not need to be included at the beginning of the code
  3038                                  ; segment.  Also, the BIOS can just assume that the resident code begins
  3039                                  ; at offset zero within the segment.
  3040                                  ; 
  3041                                  ;
  3042                                  ;--------------------------------------------------------------------------
  3043                                  
  3044                                  BIODATASTART	EQU	00700h
  3045                                  ;include	bdsize.inc	; this sets the values:
  3046                                  				;	BIODATASIZ
  3047                                  				;	BIOCODESIZ
  3048                                  				;	DOSDATASIZ
  3049                                  
  3050                                  ; 05/12/2022
  3051                                  ;BIODATASIZ EQU 00910H	; 0900h for MSDOS 6.21 IO.SYS
  3052                                  			; 0900h for MSDOS 5.0 IO.SYS
  3053                                  ;BIOCODESIZ EQU 01A70H	; 1A70h for MSDOS 6.21 IO.SYS
  3054                                  			; 1A60h for MSDOS 5.0 IO.SYS
  3055                                  ;DOSDATASIZ EQU 01370H	; 1370h for MSDOS 6.21 IO.SYS
  3056                                  			; 1370h for MSDOS 5.0 IO.SYS
  3057                                  ;ifndef ROMDOS
  3058                                  ;
  3059                                  ;BYTSTART	EQU    	BIODATASTART+BIODATASIZ+BIOCODESIZ+DOSDATASIZ
  3060                                  ;PARASTART	EQU	(BYTSTART + 0FH) AND (NOT 0FH)	
  3061                                  ;
  3062                                  ;else
  3063                                  ;
  3064                                  ;BYTSTART	EQU	0
  3065                                  ;PARASTART	EQU	0
  3066                                  ;
  3067                                  ;endif ; ROMDOS
  3068                                  
  3069                                  ; 24/04/2019 - Retro DOS v4.0 - Modification
  3070                                  ; -----------------------------------------------------------------
  3071                                  ;MSDAT001E equ 136Ah ; 4970 ; for MSDOS 6.21	
  3072                                  ;MSDAT001E equ 1370h ; 4976 ; for Retro DOS v4.0 modif. 25/05/2019	
  3073                                  ;DOSDATASIZE equ MSDAT001E
  3074                                  ; 05/12/2022
  3075                                  ;DOSDATASIZE equ $ ; 29/04/2019 ; -only- for RETRO DOS v4.0 :
  3076                                  ;_PARASTART_ equ DOSDATASIZE ; segment value will point to start of
  3077                                  			    ; of DOSDATA (in low memory) while
  3078                                  			    ; dos/kernel code starts just after 
  3079                                  			    ; this data block ((org = DOSDATASIZE))
  3080                                  			    ; (in low memory or in HMA)	
  3081                                  ; -----------------------------------------------------------------
  3082                                  
  3083                                  ; 04/11/2022	
  3084                                  ; -----------------------------------------------------------------	
  3085                                  ; NOTE:
  3086                                  ; Microsoft dos programmers were calling 'IO.SYS' as dos 'BIOS'
  3087                                  ; (Also, they were calling 'ROMBIOS' as 'ROM' only!)
  3088                                  ; -----------------------------------------------------------------
  3089                                  
  3090                                  ; ----------------------------------------------------------------------------
  3091                                  ; 06/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  3092                                  ; ----------------------------------------------------------------------------
  3093                                  
  3094                                  ;segment .code vstart=3DD0h ; 06/12/2022
  3095                                  ; 29/09/2023
  3096                                  segment .code vstart=3DE0h ; 19/09/2023 - Retro DOS v4.2 (Modified MSDOS 6.22)
  3097                                  								
  3098                                  ; ============================================================================
  3099                                  
  3100                                  
  3101                                  ;[ORG 3DE0h]
  3102                                  
  3103                                  ;[ORG _PARASTART_]     ; [org 136Ah]
  3104                                  
  3105                                  ;[ORG 1370h] ; 25/05/2019 - Retro DOS v4.0
  3106                                  
  3107                                  	; 05/12/2022 - RetroDOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  3108                                  	;PARASTART equ 3DD0h ; BIOSDATASTART+BIOSDATASIZE
  3109                                  			     ; +BIOSCODESIZE+DOSDATASIZE (rounded up)
  3110                                  	
  3111                                  	; 29/09/2023 
  3112                                  	; 19/09/2023 - Retro DOS v4.2 (Modified MSDOS 6.22 MSDOS.SYS)
  3113                                  	PARASTART equ 3DE0h	; (MSDOS 6.22 MSDOS.SYS)
  3114                                  
  3115                                  	[ORG PARASTART]	
  3116                                  
  3117                                  _$STARTCODE:
  3118                                  
  3119                                  ;PARASTART:
  3120 00000000 E92A77                          JMP     DOSINIT
  3121                                  
  3122                                  	;dw	PARASTART	; PARASTART = 3DE0h for MSDOS 6.0, 6.22
  3123                                  	; 04/11/2022
  3124 00000003 [0000]                  	dw	_$STARTCODE	; PARASTART = 3DD0h for MSDOS 5.0
  3125                                  
  3126                                  BioDataSeg:
  3127 00000005 7000                    	dw	0070h		; Bios data segment fixed at 70h
  3128                                  
  3129                                  ; DosDSeg is a data word in the DOSCODE segment that is loaded with
  3130                                  ; the segment address of DOSDATA. This is purely an optimization, that
  3131                                  ; allows getting the DOS data segment without going through the 
  3132                                  ; BIOS data segment. It is used by the "getdseg" macro.
  3133                                  
  3134                                  DosDSeg:
  3135 00000007 0000                    	dw	0
  3136                                  	
  3137                                  ;============================================================================
  3138                                  ; MSTABLE.ASM (MSDOS 6.0, 1991)
  3139                                  ;============================================================================
  3140                                  ; 16/07/2018 - Retro DOS 3.0
  3141                                  ; 29/04/2019 - Retro DOS 4.0
  3142                                  
  3143                                  	; (MSDOS version)
  3144                                  	; DOSCODE:3DE9h (MSDOS 6.21, MSDOS.SYS)
  3145                                  	;db	6
  3146                                  	;db	20
  3147                                  	; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS) 
  3148                                  	; DOSCODE:3DD9h (MSDOS 5.0, MSDOS.SYS)
  3149                                  	;db	5
  3150                                  	;db	0	
  3151                                  
  3152                                  	; Offset 0C78h in IBMDOS.COM (MSDOS 3.3, 1987)
  3153                                  MSVERS:				; MS-DOS version in hex for $GET_VERSION
  3154 00000009 06                      MSMAJOR: DB	MAJOR_VERSION	; DOS_MAJOR_VERSION
  3155 0000000A 16                      MSMINOR: DB	MINOR_VERSION	; DOS_MINOR_VERSION  
  3156                                  
  3157                                  ;;hkn YRTAB & MONTAB moved to DOSDATA in ms_data.asm
  3158                                  ;	I_am	YRTAB,8,<200,166,200,165,200,165,200,165>   ; [SYSTEM]
  3159                                  ;	I_am	MONTAB,12,<31,28,31,30,31,30,31,31,30,31,30,31> ; [SYSTEM]
  3160                                  
  3161                                  ; DOSTAB.ASM (MSDOS 6.0, 1991)
  3162                                  ; YRTAB & MONTAB moved from TABLE segment in ms_table.asm
  3163                                  ;
  3164                                  ;	I_am    YRTAB,8,<200,166,200,165,200,165,200,165>   
  3165                                  ;	I_am    MONTAB,12,<31,28,31,30,31,30,31,31,30,31,30,31> 
  3166                                  
  3167                                  ; This is the error code mapping table for INT 21 errors. This table defines
  3168                                  ; those error codes which are "allowed" for each system call. If the error
  3169                                  ; code ABOUT to be returned is not "allowed" for the call, the correct action
  3170                                  ; is to return the "real" error via Extended error, and one of the allowed
  3171                                  ; errors on the actual call.
  3172                                  ;
  3173                                  ; The table is organized as follows:
  3174                                  ;
  3175                                  ;    Each entry in the table is of variable size, but the first
  3176                                  ;       two bytes are always:
  3177                                  ;
  3178                                  ;       Call#,Cnt of bytes following this byte
  3179                                  ;
  3180                                  ; EXAMPLE:
  3181                                  ;       Call 61 (OPEN)
  3182                                  ;
  3183                                  ;       DB      61,5,12,3,2,4,5
  3184                                  ;
  3185                                  ;       61 is the AH INT 21 call value for OPEN.
  3186                                  ;        5 indicates that there are 5 bytes after this byte (12,3,2,4,5).
  3187                                  ;       Next five bytes are those error codes which are "allowed" on OPEN.
  3188                                  ;       The order of these values is not important EXCEPT FOR THE LAST ONE (in
  3189                                  ;       this case 5).  The last value will be the one returned on the call if
  3190                                  ;       the "real" error is not one of the allowed ones.
  3191                                  ;
  3192                                  ; There are a number of calls (for instance all of the FCB calls) for which
  3193                                  ;   there is NO entry.  This means that NO error codes are returned on this
  3194                                  ;   call, so set up an Extended error and leave the current error code alone.
  3195                                  ;
  3196                                  ; The table is terminated by a call value of 0FFh
  3197                                  
  3198                                  ;PUBLIC I21_MAP_E_TAB
  3199                                  	; 10/08/2018
  3200                                  
  3201                                  ; 29/04/2019
  3202                                  ; DOSCODE:3DE9h (MSDOS 6.21, MSDOS.SYS)
  3203                                  ; 04/11/2022
  3204                                  ; DOSCODE:3DDBh	(MSDOS 5.0 MSDOS.SYS)
  3205                                  
  3206                                  I21_MAP_E_TAB:	; LABEL	BYTE
  3207 0000000B 38020102                    DB  INTERNATIONAL,2,error_invalid_function,error_file_not_found
  3208 0000000F 3903030205                  DB  MKDIR,3,error_path_not_found,error_file_not_found,error_access_denied
  3209 00000014 3A041003                    DB  RMDIR,4,error_current_directory,error_path_not_found
  3210 00000018 0205                        DB          error_file_not_found,error_access_denied
  3211 0000001A 3B020203                    DB  CHDIR,2,error_file_not_found,error_path_not_found
  3212 0000001E 3C040302                    DB  CREAT,4,error_path_not_found,error_file_not_found
  3213 00000022 04                          DB          error_too_many_open_files
  3214 00000023 05                          DB          error_access_denied
  3215                                      ; MSDOS 6.0
  3216 00000024 3D0603020C                  DB	OPEN,6,error_path_not_found,error_file_not_found,error_invalid_access
  3217 00000029 04                          DB          error_too_many_open_files
  3218 0000002A 1A05                        DB          error_not_DOS_disk,error_access_denied
  3219                                      ; MSDOS 3.3
  3220                                      ;DB	OPEN,5,error_path_not_found,error_file_not_found,error_invalid_access
  3221                                      ;DB		error_too_many_open_files,error_access_denied
  3222 0000002C 3E0106                      DB  CLOSE,1,error_invalid_handle
  3223 0000002F 3F020605                    DB  READ,2,error_invalid_handle,error_access_denied
  3224 00000033 40020605                    DB  WRITE,2,error_invalid_handle,error_access_denied
  3225 00000037 4103030205                  DB  UNLINK,3,error_path_not_found,error_file_not_found,error_access_denied
  3226 0000003C 42020601                    DB  LSEEK,2,error_invalid_handle,error_invalid_function
  3227 00000040 4304030201                  DB  CHMOD,4,error_path_not_found,error_file_not_found,error_invalid_function
  3228 00000045 05                          DB          error_access_denied
  3229 00000046 44050F0D01                  DB  IOCTL,5,error_invalid_drive,error_invalid_data,error_invalid_function
  3230 0000004B 0605                        DB          error_invalid_handle,error_access_denied
  3231 0000004D 45020604                    DB  XDUP,2,error_invalid_handle,error_too_many_open_files
  3232 00000051 46020604                    DB  XDUP2,2,error_invalid_handle,error_too_many_open_files
  3233                                      ; MSDOS 6.0	
  3234 00000055 47021A0F                    DB  CURRENT_DIR,2,error_not_DOS_disk,error_invalid_drive
  3235                                      ; MSDOS 3.3	
  3236                                      ;DB  CURRENT_DIR,1,error_invalid_drive
  3237 00000059 48020708                    DB  ALLOC,2,error_arena_trashed,error_not_enough_memory
  3238 0000005D 49020709                    DB  DEALLOC,2,error_arena_trashed,error_invalid_block
  3239 00000061 4A03070908                  DB  SETBLOCK,3,error_arena_trashed,error_invalid_block,error_not_enough_memory
  3240 00000066 4B08030102                  DB  EXEC,8,error_path_not_found,error_invalid_function,error_file_not_found
  3241 0000006B 040B0A                      DB          error_too_many_open_files,error_bad_format,error_bad_environment
  3242 0000006E 0805                        DB          error_not_enough_memory,error_access_denied
  3243 00000070 4E03030212                  DB  FIND_FIRST,3,error_path_not_found,error_file_not_found,error_no_more_files
  3244 00000075 4F0112                      DB  FIND_NEXT,1,error_no_more_files
  3245                                      ; MSDOS 6.0
  3246 00000078 5605110302                  DB  RENAME,5,error_not_same_device,error_path_not_found,error_file_not_found
  3247 0000007D 1005                        DB		error_current_directory,error_access_denied
  3248                                      ; MSDOS 3.3
  3249                                      ;DB  RENAME,4,error_not_same_device,error_path_not_found,error_file_not_found
  3250                                      ;DB		error_access_denied
  3251                                      ; MSDOS 6.0	
  3252 0000007F 57040608                    DB  FILE_TIMES,4,error_invalid_handle,error_not_enough_memory
  3253 00000083 0D01                        DB		error_invalid_data,error_invalid_function
  3254                                      ; MSDOS 3.3	
  3255                                      ;DB  FILE_TIMES,2,error_invalid_handle,error_invalid_function
  3256 00000085 580101                      DB  ALLOCOPER,1,error_invalid_function
  3257 00000088 5A040302                    DB  CREATETEMPFILE,4,error_path_not_found,error_file_not_found
  3258 0000008C 0405                        DB          error_too_many_open_files,error_access_denied
  3259 0000008E 5B055003                    DB  CREATENEWFILE,5,error_file_exists,error_path_not_found
  3260 00000092 020405                      DB          error_file_not_found,error_too_many_open_files,error_access_denied
  3261 00000095 5C040601                    DB  LOCKOPER,4,error_invalid_handle,error_invalid_function
  3262 00000099 2421                        DB          error_sharing_buffer_exceeded,error_lock_violation
  3263 0000009B 65020102                    DB  GETEXTCNTRY,2,error_invalid_function,error_file_not_found	;DOS 3.3
  3264 0000009F 66020102                    DB  GETSETCDPG,2,error_invalid_function,error_file_not_found        ;DOS 3.3
  3265 000000A3 680106                      DB  COMMIT,1,error_invalid_handle                                   ;DOS 3.3
  3266 000000A6 67030408                    DB  EXTHANDLE,3,error_too_many_open_files,error_not_enough_memory
  3267 000000AA 01                          DB              error_invalid_function
  3268                                      ; MSDOS 6.0		
  3269 000000AB 6C0A                        DB	ExtOpen,10
  3270 000000AD 03020C                      DB	  error_path_not_found,error_file_not_found,error_invalid_access
  3271 000000B0 045008                      DB		error_too_many_open_files,error_file_exists,error_not_enough_memory
  3272 000000B3 1A0D                        DB		error_not_DOS_disk,error_invalid_data
  3273 000000B5 0105                        DB		error_invalid_function,error_access_denied
  3274 000000B7 69040F0D                    DB	GetSetMediaID,4,error_invalid_drive,error_invalid_data
  3275 000000BB 0105                        DB		error_invalid_function,error_access_denied
  3276 000000BD FF                          DB  0FFh
  3277                                  
  3278                                  ;19/09/2023
  3279                                  ;22/12/2022
  3280                                  ;04/11/2022	
  3281                                  ;29/04/2019 - Retro DOS v4.0
  3282                                  ;============================================================================
  3283                                  ; 	Retro DOS v4.0
  3284                                  ;============================================================================
  3285 000000BE 00                      	db 	0
  3286                                  RETRODOSMSG:
  3287 000000BF 0D0A                    	db	13,10
  3288                                  	;;;;db	"Retro DOS v4.0 by Erdogan Tan [2019]"
  3289                                  	;;;db	"Retro DOS v4.0 by Erdogan Tan [2022]"
  3290                                  	;;db	"Retro DOS v4.1 by Erdogan Tan [2022]" ; 28/12/2022
  3291                                  	;db	"Retro DOS v4.2 by Erdogan Tan [2022]" ; 30/12/2022
  3292 000000C1 526574726F20444F53-     	db	"Retro DOS v4.2 by Erdogan Tan [2023]"
  3292 000000CA 2076342E3220627920-
  3292 000000D3 4572646F67616E2054-
  3292 000000DC 616E205B323032335D 
  3293 000000E5 0D0A2400                	db	13,10,"$", 0 
  3294                                  
  3295                                  ;============================================================================
  3296                                  ; MSTABLE.ASM, MSDOS 6.0, 1991
  3297                                  ;============================================================================
  3298                                  ; 11/07/2018 - Retro DOS v3.0
  3299                                  
  3300                                  	%define short_addr dw  ; 03/03/2018 - Retro DOS v2.0
  3301 000000E9 90                      align 2
  3302                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 0E00h
  3303                                  
  3304                                  ; Standard Functions
  3305                                  ;DISPATCH  LABEL WORD
  3306                                  DISPATCH:
  3307                                  	; 16/07/2018 - Retro DOS v3.0
  3308                                  	; (MSDOS 3.3)
  3309                                  
  3310                                  ; 29/04/2019
  3311                                  ; DOSCODE:3E9Eh (MSDOS 6.21, MSDOS.SYS)
  3312                                  
  3313                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  3314                                  ; DOSCODE:3E8Eh (MSDOS 5.0, MSDOS.SYS)
  3315                                  
  3316 000000EA [5F62]                          short_addr  _$ABORT			    ;  0      0
  3317 000000EC [A816]                          short_addr  _$STD_CON_INPUT		    ;  1      1
  3318 000000EE [B116]                          short_addr  _$STD_CON_OUTPUT		    ;  2      2
  3319 000000F0 [6317]                          short_addr  _$STD_AUX_INPUT		    ;  3      3
  3320 000000F2 [7E17]                          short_addr  _$STD_AUX_OUTPUT		    ;  4      4
  3321 000000F4 [8417]                          short_addr  _$STD_PRINTER_OUTPUT	    ;  5      5
  3322 000000F6 [F015]                          short_addr  _$RAW_CON_IO		    ;  6      6
  3323 000000F8 [1C16]                          short_addr  _$RAW_CON_INPUT		    ;  7      7
  3324 000000FA [C113]                          short_addr  _$STD_CON_INPUT_NO_ECHO	    ;  8      8
  3325 000000FC [1A14]                          short_addr  _$STD_CON_STRING_OUTPUT	    ;  9      9
  3326 000000FE [2614]                          short_addr  _$STD_CON_STRING_INPUT	    ; 10      A
  3327 00000100 [9817]                          short_addr  _$STD_CON_INPUT_STATUS	    ; 11      B
  3328 00000102 [A217]                          short_addr  _$STD_CON_INPUT_FLUSH	    ; 12      C
  3329 00000104 [E40F]                          short_addr  _$DISK_RESET		    ; 13      D
  3330 00000106 [BA0E]                          short_addr  _$SET_DEFAULT_DRIVE		    ; 14      E
  3331 00000108 [7E1E]                          short_addr  _$FCB_OPEN			    ; 15      F
  3332 0000010A [4818]                          short_addr  _$FCB_CLOSE			    ; 16     10
  3333 0000010C [901F]                          short_addr  _$DIR_SEARCH_FIRST		    ; 17     11
  3334 0000010E [2220]                          short_addr  _$DIR_SEARCH_NEXT		    ; 18     12
  3335 00000110 [E717]                          short_addr  _$FCB_DELETE		    ; 19     13
  3336 00000112 [7C1F]                          short_addr  _$FCB_SEQ_READ		    ; 20     14
  3337 00000114 [811F]                          short_addr  _$FCB_SEQ_WRITE	            ; 21     15
  3338 00000116 [621F]                          short_addr  _$FCB_CREATE		    ; 22     16
  3339 00000118 [B818]                          short_addr  _$FCB_RENAME		    ; 23     17
  3340                                  	; 16/07/2018
  3341                                          ;short_addr _CPMFUNC			    ; 24     18	
  3342 0000011A [6606]                          short_addr  NO_OP			    ; 24     18
  3343 0000011C [B50E]                          short_addr  _$GET_DEFAULT_DRIVE		    ; 25     19
  3344 0000011E [AA0E]                          short_addr  _$SET_DMA			    ; 26     1A
  3345                                  
  3346                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3347                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3348                                  ;                                                                          ;
  3349 00000120 [700F]                          short_addr  _$SLEAZEFUNC		    ; 27     1B
  3350 00000122 [720F]                          short_addr  _$SLEAZEFUNCDL		    ; 28     1C
  3351                                  ;                                                                          ;
  3352                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3353                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3354                                  
  3355                                          ;short_addr  _CPMFUNC			    ; 29     1D
  3356                                          ;short_addr  _CPMFUNC			    ; 30     1E
  3357                                  
  3358                                  ; 08/07/2018 - Retro DOS v3.0
  3359                                  ; MSDOS 6.0 - MSTABLE.ASM, 1991
  3360                                  
  3361 00000124 [6606]                  	short_addr  NO_OP			    ; 29     1D
  3362 00000126 [6606]                  	short_addr  NO_OP			    ; 30     1E
  3363                                  
  3364                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3365                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3366                                  ;                                                                          ;
  3367 00000128 [B40F]                          short_addr  _$GET_DEFAULT_DPB               ; 31     1F
  3368                                  ;                                                                          ;
  3369                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3370                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3371                                          ;short_addr _CPMFUNC			    ; 32     20
  3372                                  
  3373                                  ; 08/07/2018 - Retro DOS v3.0
  3374                                  ; MSDOS 6.0 - MSTABLE.ASM, 1991
  3375                                  
  3376 0000012A [6606]                  	short_addr  NO_OP			    ; 32     20
  3377                                  
  3378 0000012C [861F]                          short_addr  _$FCB_RANDOM_READ               ; 33     21
  3379 0000012E [8B1F]                          short_addr  _$FCB_RANDOM_WRITE              ; 34     22
  3380 00000130 [F917]                          short_addr  _$GET_FCB_FILE_LENGTH	    ; 35     23
  3381 00000132 [CF17]                          short_addr  _$GET_FCB_POSITION		    ; 36     24
  3382                                  
  3383                                  ;MAXCALL = ($-DISPATCH)/2 - 1
  3384                                  MAXCALL EQU ($-DISPATCH)/2 - 1
  3385                                  
  3386                                  ; Extended Functions
  3387 00000134 [DC0E]                          short_addr  _$SET_INTERRUPT_VECTOR	    ; 37     25
  3388                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3389                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3390                                  ;                                                                          ;
  3391 00000136 [F010]                          short_addr  _$CREATE_PROCESS_DATA_BLOCK	    ; 38     26
  3392                                  ;                                                                          ;
  3393                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3394                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3395 00000138 [771F]                          short_addr  _$FCB_RANDOM_READ_BLOCK	    ; 39     27
  3396 0000013A [721F]                          short_addr  _$FCB_RANDOM_WRITE_BLOCK        ; 40     28
  3397 0000013C [650F]                          short_addr  _$PARSE_FILE_DESCRIPTOR	    ; 41     29
  3398 0000013E [7C0A]                          short_addr  _$GET_DATE                      ; 42     2A
  3399 00000140 [990A]                          short_addr  _$SET_DATE                      ; 43     2B
  3400 00000142 [B80A]                          short_addr  _$GET_TIME                      ; 44     2C
  3401 00000144 [C90A]                          short_addr  _$SET_TIME                      ; 45     2D
  3402 00000146 [880C]                          short_addr  _$SET_VERIFY_ON_WRITE           ; 46     2E
  3403                                  
  3404                                  ; Extended functionality group
  3405 00000148 [960E]                          short_addr  _$GET_DMA                       ; 47     2F
  3406 0000014A [5E0C]                          short_addr  _$GET_VERSION                   ; 48     30
  3407 0000014C [0362]                          short_addr  _$KEEP_PROCESS		    ; 49     31
  3408                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3409                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3410                                  ;                                                                          ;
  3411 0000014E [B60F]                          short_addr  _$GET_DPB			    ; 50     32
  3412                                  ;                                                                          ;
  3413                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3414                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3415 00000150 [6702]                          short_addr  _$SET_CTRL_C_TRAPPING           ; 51     33
  3416 00000152 [9C0F]                          short_addr  _$GET_INDOS_FLAG                ; 52     34
  3417 00000154 [CC0E]                          short_addr  _$GET_INTERRUPT_VECTOR          ; 53     35
  3418 00000156 [6D0E]                          short_addr  _$GET_DRIVE_FREESPACE           ; 54     36
  3419 00000158 [090F]                          short_addr  _$CHAR_OPER                     ; 55     37
  3420 0000015A [8F0C]                          short_addr  _$INTERNATIONAL                 ; 56     38
  3421                                  ; XENIX CALLS
  3422                                  ;   Directory Group
  3423 0000015C [7C22]                          short_addr  _$MKDIR			    ; 57     39
  3424 0000015E [C821]                          short_addr  _$RMDIR			    ; 58     3A
  3425 00000160 [0322]                          short_addr  _$CHDIR			    ; 59     3B
  3426                                  ;   File Group
  3427 00000162 [2170]                          short_addr  _$CREAT			    ; 60     3C
  3428 00000164 [4A6F]                          short_addr  _$OPEN			    ; 61     3D
  3429 00000166 [7B67]                          short_addr  _$CLOSE		 	    ; 62     3E
  3430 00000168 [8C68]                          short_addr  _$READ			    ; 63     3F
  3431 0000016A [F268]                          short_addr  _$WRITE			    ; 64     40
  3432 0000016C [7170]                          short_addr  _$UNLINK			    ; 65     41
  3433 0000016E [F768]                          short_addr  _$LSEEK			    ; 66     42
  3434 00000170 [2E70]                          short_addr  _$CHMOD			    ; 67     43
  3435 00000172 [DD22]                          short_addr  _$IOCTL			    ; 68     44
  3436 00000174 [AC69]                          short_addr  _$DUP			    ; 69     45
  3437 00000176 [CA69]                          short_addr  _$DUP2			    ; 70     46
  3438 00000178 [5921]                          short_addr  _$CURRENT_DIR		    ; 71     47
  3439                                  ;   Memory Group
  3440 0000017A [F662]                          short_addr  _$ALLOC			    ; 72     48
  3441 0000017C [7064]                          short_addr  _$DEALLOC                       ; 73     49
  3442 0000017E [4C64]                          short_addr  _$SETBLOCK                      ; 74     4A
  3443                                  ;   Process Group
  3444 00000180 [DD5B]                          short_addr  _$EXEC			    ; 75     4B
  3445 00000182 [3B62]                          short_addr  _$EXIT			    ; 76     4C
  3446 00000184 [D35B]                          short_addr  _$WAIT			    ; 77     4D
  3447 00000186 [9520]                          short_addr  _$FIND_FIRST		    ; 78     4E
  3448                                  ;   Special Group
  3449 00000188 [EB20]                          short_addr  _$FIND_NEXT			    ; 79     4F
  3450                                  ; SPECIAL SYSTEM GROUP
  3451                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3452                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3453                                  ;                                                                          ;
  3454 0000018A [BE02]                          short_addr  _$SET_CURRENT_PDB		    ; 80     50
  3455 0000018C [CA02]                          short_addr  _$GET_CURRENT_PDB               ; 81     51
  3456 0000018E [A80F]                          short_addr  _$GET_IN_VARS                   ; 82     52
  3457 00000190 [1910]                          short_addr  _$SETDPB			    ; 83     53
  3458                                  ;                                                                          ;
  3459                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3460                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3461 00000192 [830C]                          short_addr  _$GET_VERIFY_ON_WRITE	    ; 84     54
  3462                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3463                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3464                                  ;                                                                          ;
  3465 00000194 [DF10]                          short_addr  _$DUP_PDB                       ; 85     55
  3466                                  ;                                                                          ;
  3467                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3468                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3469 00000196 [9770]                          short_addr  _$RENAME			    ; 86     56
  3470 00000198 [5E69]                          short_addr  _$FILE_TIMES                    ; 87     57
  3471 0000019A [A564]                          short_addr  _$ALLOCOPER                     ; 88     58
  3472                                  
  3473                                  ; 08/07/2018 - Retro DOS v3.0
  3474                                  ; -------------------------------------------------------------------------;
  3475                                  ; MSDOS 6.0 - MSTABLE.ASM, 1991
  3476                                  
  3477                                  ; Network extention system calls
  3478 0000019C [1D0F]                          short_addr  _$GetExtendedError              ; 89     59
  3479 0000019E [2271]                          short_addr  _$CreateTempFile                ; 90     5A
  3480 000001A0 [0A71]                          short_addr  _$CreateNewFile                 ; 91     5B
  3481 000001A2 [0373]                          short_addr  _$LockOper                      ; 92     5C
  3482 000001A4 [8B65]                          short_addr  _$ServerCall                    ; 93     5D
  3483 000001A6 [946A]                          short_addr  _$UserOper                      ; 94     5E
  3484 000001A8 [F969]                          short_addr  _$AssignOper                    ; 95     5F
  3485 000001AA [E56E]                          short_addr  _$NameTrans                     ; 96     60
  3486 000001AC [6606]                  	short_addr  NO_OP			    ; 97     61
  3487 000001AE [CA02]                          short_addr  _$GET_CURRENT_PDB		    ; 98     62
  3488                                  ; the next call is reserved for hangool sys call
  3489                                  	; 29/04/2019 - Retro DOS v4.0 (MSDOS 6.0)
  3490 000001B0 [4A0F]                  	short_addr  _$ECS_Call			    ; 99     63
  3491                                  	;short_addr  NO_OP  ;  MSDOS 3.3	    ; 99     63
  3492                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3493                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3494                                  ;                                                                          ;
  3495 000001B2 [D602]                          short_addr  _$SET_PRINTER_FLAG              ; 100    64
  3496                                  ;                                                                          ;
  3497                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3498                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3499 000001B4 [1A0D]                          short_addr  _$GetExtCntry                   ; 101    65
  3500 000001B6 [190E]                          short_addr  _$GetSetCdPg                    ; 102    66
  3501 000001B8 [C867]                          short_addr  _$ExtHandle                     ; 103    67
  3502 000001BA [AE67]                          short_addr  _$COMMIT                        ; 104    68
  3503                                  
  3504                                  ; 08/07/2018
  3505                                  ; Above system calls are valid for Retro DOS v3.0 (MSDOS 3.3) 
  3506                                  ; Following system calls are valid for Retro DOS v4.0 (MSDOS 6.0)
  3507                                  
  3508                                  ; 29/04/2019 - Retro DOS v4.0 (MSDOS 6.0)
  3509 000001BC [E211]                  	short_addr  _$GSetMediaID                   ; 105    69   ;AN000;
  3510 000001BE [AE67]                  	short_addr  _$COMMIT                        ; 106    6A   ;AN000;
  3511 000001C0 [6606]                  	short_addr  NO_OP                           ; 107    6B   
  3512                                  						    ; IFS_IOCTL no longer 
  3513                                  						    ; supported
  3514 000001C2 [B871]                  	short_addr  _$Extended_Open                 ; 108    6C   ;AN000;
  3515                                  
  3516                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3517                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3518                                  ;                                                                          ;
  3519                                  ;ifdef ROMEXEC
  3520                                  ;       short_addr  $ROM_FIND_FIRST	   	    ; 109    6D
  3521                                  ;       short_addr  $ROM_FIND_NEXT	   	    ; 110    6E
  3522                                  ;	short_addr  $ROM_EXCLUDE		    ; 111    6F	  ; M078
  3523                                  ;endif
  3524                                  ;                                                                          ;
  3525                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3526                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3527                                  
  3528                                  ;MAXCOM  = ($-DISPATCH)/2 - 1
  3529                                  
  3530                                  MAXCOM  EQU ($-DISPATCH)/2 - 1
  3531                                  
  3532                                  ; 08/07/2018 - Retro DOS v3.0
  3533                                  ; MSDOS 6.0 - MSTABLE.ASM, 1991
  3534                                  
  3535                                  ;	If 	Installed
  3536                                  
  3537                                  align 2
  3538                                  
  3539                                  ;PUBLIC FOO
  3540                                  
  3541                                  FOO:	; LABEL WORD
  3542 000001C4 [2307]                          short_addr  Leave2F
  3543                                  
  3544 000001C6 [C801]                  DTab:	DW  DOSTable
  3545                                  
  3546                                  	;PUBLIC FOO,DTAB
  3547                                  
  3548                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 0ED6h
  3549                                  
  3550                                  ; 29/04/2019
  3551                                  ; DOSCODE:3F7Ch (MSDOS 6.21, MSDOS.SYS)
  3552                                  
  3553                                  
  3554                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  3555                                  ; DOSCODE:3F6Ch (MSDOS 5.0, MSDOS.SYS)
  3556                                         
  3557                                  DOSTable:  ; LABEL  WORD
  3558 000001C8 30                              DB      (DOSTableEnd-DOSTable-1)/2 ; db  48
  3559 000001C9 [5209]                          short_addr  DOSInstall          ;   0 install check
  3560 000001CB [9A2F]                          short_addr  DOS_CLOSE           ;   1   DOS_CLOSE
  3561 000001CD [FE0E]                          short_addr  RECSET              ;   2   RECSET
  3562 000001CF [4C09]                          short_addr  DosGetGroup         ;   3   Get DOSGROUP
  3563 000001D1 [0151]                          short_addr  PATHCHRCMP          ;   4   PATHCHRCMP
  3564 000001D3 [B316]                          short_addr  OUTT                ;   5   OUT
  3565 000001D5 [D753]                          short_addr  NET_I24_ENTRY       ;   6   NET_I24_ENTRY
  3566 000001D7 [5D59]                          short_addr  PLACEBUF            ;   7   PLACEBUF
  3567 000001D9 [9830]                          short_addr  FREE_SFT            ;   8   FREE_SFT
  3568 000001DB [225B]                          short_addr  BUFWRITE            ;   9   BUFWRITE
  3569 000001DD [B773]                          short_addr  SHARE_VIOLATION     ;   10  SHARE_VIOLATION
  3570 000001DF [E32C]                          short_addr  SHARE_ERROR         ;   11  SHARE_ERROR
  3571 000001E1 [CD2C]                          short_addr  SET_SFT_MODE        ;   12  SET_SFT_MODE
  3572 000001E3 [100B]                          short_addr  DATE16              ;   13  DATE16
  3573 000001E5 [4E12]                          short_addr  Idle		;   14      empty slot
  3574 000001E7 [5659]                          short_addr  SCANPLACE           ;   15  SCANPLACE
  3575 000001E9 [4E12]                          short_addr  Idle		;   16      empty slot
  3576 000001EB [1B12]                          short_addr  StrCpy              ;   17  StrCpy
  3577 000001ED [3312]                          short_addr  StrLen              ;   18  StrLen
  3578 000001EF [AC50]                          short_addr  UCase		;   19  UCase
  3579 000001F1 [9A59]                          short_addr  POINTCOMP           ;   20  POINTCOMP
  3580 000001F3 [F95A]                          short_addr  CHECKFLUSH          ;   21  CHECKFLUSH
  3581 000001F5 [F666]                          short_addr  SFFromSFN           ;   22  SFFromSFN
  3582 000001F7 [596B]                          short_addr  GetCDSFromDrv       ;   23  GetCDSFromDrv
  3583 000001F9 [9004]                          short_addr  Get_User_Stack      ;   24  Get_User_Stack
  3584 000001FB [046B]                          short_addr  GETTHISDRV          ;   25  GetThisDrv
  3585 000001FD [0A6F]                          short_addr  DriveFromText       ;   26  DriveFromText
  3586 000001FF [BA0B]                          short_addr  SETYEAR             ;   27  SETYEAR
  3587 00000201 [540C]                          short_addr  DSUM                ;   28  DSUM
  3588 00000203 [AE0B]                          short_addr  DSLIDE              ;   29  DSLIDE
  3589 00000205 [F911]                          short_addr  StrCmp              ;   30  StrCmp
  3590 00000207 [476A]                          short_addr  InitCDS             ;   31  initcds
  3591 00000209 [C366]                          short_addr  pJFNFromHandle      ;   32  pJfnFromHandle
  3592 0000020B [E56E]                          short_addr  _$NameTrans		;   33  $NameTrans
  3593 0000020D [8D06]                          short_addr  CAL_LK              ;   34  CAL_LK
  3594 0000020F [3A42]                          short_addr  DEVNAME             ;   35  DEVNAME
  3595 00000211 [4E12]                          short_addr  Idle                ;   36  Idle
  3596 00000213 [4112]                          short_addr  DStrLen             ;   37  DStrLen
  3597 00000215 [F212]                          short_addr  NLS_OPEN            ;   38  NLS_OPEN      DOS 3.3
  3598 00000217 [7B67]                          short_addr  _$CLOSE		;   39  $CLOSE        DOS 3.3
  3599 00000219 [F812]                          short_addr  NLS_LSEEK           ;   40  NLS_LSEEK     DOS 3.3
  3600 0000021B [8C68]                          short_addr  _$READ		;   41  $READ         DOS 3.3
  3601 0000021D [B212]                          short_addr  FastInit            ;   42  FastInit      DOS 3.4  ;AN000;
  3602 0000021F [3513]                          short_addr  NLS_IOCTL           ;   43  NLS_IOCTL     DOS 3.3
  3603 00000221 [2413]                          short_addr  GetDevList          ;   44  GetDevList    DOS 3.3
  3604 00000223 [5213]                          short_addr  NLS_GETEXT          ;   45  NLS_GETEXT    DOS 3.3
  3605                                          
  3606                                  	; 29/04/2019 - Retro DOS v4.0
  3607 00000225 [5613]                  	short_addr  MSG_RETRIEVAL	;   46  MSG_RETRIEVAL DOS 4.0  ;AN000;
  3608                                  
  3609 00000227 [6606]                  	short_addr  NO_OP		;   M006: 47  no longer supported
  3610                                  ;*** 	short_addr  Fake_Version	;   47  Fake_Version  DOS 4.0  ;AN006;
  3611                                  
  3612                                  DOSTableEnd:  ; LABEL BYTE
  3613                                  
  3614                                  	;ENDIF
  3615                                  
  3616                                  ; ----------------------------------------------------------------------------
  3617                                  ; BREAK   <Copyright notice and version>
  3618                                  ; ----------------------------------------------------------------------------
  3619                                  
  3620                                  ;CODSTRT EQU	$
  3621                                  
  3622                                  ; 08/07/2018 - Retro DOS v3.0 by Erdogan Tan
  3623                                  ; (MSTABLE.ASM, MSDOS 6.0, 1991)
  3624                                  
  3625                                  ; NOTE WARNING: This declaration of HEADER must be THE LAST thing in this
  3626                                  ;       module. The reason is so that the data alignments are the same in
  3627                                  ;       IBM-DOS and MS-DOS up through header.
  3628                                  
  3629                                  	;PUBLIC	HEADER
  3630                                  
  3631                                  HEADER:	; LABEL	BYTE
  3632                                          ;IF	DEBUG
  3633                                          ;DB	13,10,"Debugging DOS version "
  3634                                          ;DB	MAJOR_VERSION + "0"
  3635                                          ;DB	"."
  3636                                          ;DB	(MINOR_VERSION / 10) + "0"
  3637                                          ;DB	(MINOR_VERSION MOD 10) + "0"
  3638                                          ;ENDIF
  3639                                  
  3640                                  ; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  3641                                  ; (MSDOS 5.0 MSDOS.SYS compatibility)
  3642                                  %if 0
  3643                                          ;IF	NOT IBM
  3644                                          DB	13,10,"MS-DOS version "
  3645                                          DB	MAJOR_VERSION + "0"
  3646                                          DB	"."
  3647                                          DB	(MINOR_VERSION / 10) + "0"
  3648                                          ;DB	(MINOR_VERSION MOD 10) + "0"
  3649                                          DB	(MINOR_VERSION % 10) + "0"
  3650                                  
  3651                                          ;IF	HIGHMEM
  3652                                          ;DB	"H"
  3653                                          ;ENDIF
  3654                                  
  3655                                  	;DB	13,10,"Copyright 1981,82,83,84,88 Microsoft Corp.",13,10,"$"
  3656                                  	; 30/04/2019 - Retro DOS v4.0
  3657                                  	DB	13,10,"Copyright 1981-1993 Microsoft Corp.",13,10,"$"	
  3658                                  
  3659                                  	;ENDIF
  3660                                  
  3661                                  %endif
  3662                                  
  3663                                  ;IF DEBUG
  3664                                  ;	DB	13,10,"$"
  3665                                  ;ENDIF
  3666                                  
  3667                                  ;include copyrigh.inc
  3668                                  
  3669                                  ; DOSCODE:3FDDh (MSDOS 6.21, MSDOS.SYS)
  3670                                  
  3671                                  	;DB	"MS DOS Version 6 (C)Copyright 1981-1993 Microsoft Corp "
  3672                                  	;DB	"Licensed Material - Property of Microsoft "
  3673                                  	;DB	"All rights reserved "
  3674                                  
  3675                                  ; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  3676                                  ; DOSCODE:3FCDh (MSDOS 5.0, MSDOS.SYS)
  3677                                  
  3678                                  ; 28/12/2022 - Retro DOS v4.1
  3679                                  %if 0
  3680                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  3681                                  ms_copyright:
  3682                                  	db	'MS DOS Version 5.00 (C)Copyright 1981-1991 Microsoft Corp '
  3683                                  	db	'Licensed Material - Property of Microsoft '
  3684                                  	db	'All rights reserved '
  3685                                  
  3686                                  %endif
  3687                                  	;; 28/12/2022 - Retro DOS v4.1
  3688                                  ;ms_copyright:	
  3689                                    	;db	13,10,"MS DOS Version 5.0"
  3690                                  	;db	13,10,"Copyright 1981-1991 Microsoft Corp.",13,10,"$",0	
  3691                                  
  3692                                  ;	; 21/09/2023 - Retro DOS v4.2 MSDOS.SYS
  3693                                  ;	; (MSDOS 6.22 MSDOS.SYS - DOSCODE:3FDDh (File offset: 509))
  3694                                  ;ms_copyright:
  3695                                  ;	db 'MS DOS Version 6 (C)Copyright 1981-1994 Microsoft Corp '
  3696                                  ;	db 'Licensed Material - Property of Microsoft All rights reserved '
  3697                                  
  3698                                  	; 20/09/2023 - Retro DOS v4.2
  3699                                  ms_copyright:	
  3700 00000229 0D0A4D5320444F5320-       	db	13,10,"MS DOS Version 6.22"
  3700 00000232 56657273696F6E2036-
  3700 0000023B 2E3232             
  3701 0000023E 0D0A436F7079726967-     	db	13,10,"Copyright 1981-1994 Microsoft Corp.",13,10,"$",0	
  3701 00000247 687420313938312D31-
  3701 00000250 393934204D6963726F-
  3701 00000259 736F667420436F7270-
  3701 00000262 2E0D0A2400         
  3702                                  
  3703                                  ;============================================================================
  3704                                  ; MSCODE.ASM
  3705                                  ;============================================================================
  3706                                  
  3707                                  ; Retro DOS v2.0 (NASM 2.11) source code modifications by Erdogan Tan
  3708                                  ; 03/03/2018
  3709                                  
  3710                                  ;
  3711                                  ; MSCODE.ASM -- MSDOS code
  3712                                  ;
  3713                                  
  3714                                  ;INCLUDE DOSSEG.ASM
  3715                                  ;INCLUDE STDSW.ASM
  3716                                  
  3717                                  ;CODE    SEGMENT BYTE PUBLIC  'CODE'
  3718                                  ;ASSUME  CS:DOSGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING
  3719                                  
  3720                                  ;.xcref
  3721                                  ;INCLUDE DOSSYM.ASM
  3722                                  ;INCLUDE DEVSYM.ASM
  3723                                  ;.cref
  3724                                  ;.list
  3725                                  
  3726                                  ;IFNDEF  KANJI
  3727                                  ;KANJI   EQU     0       ; FALSE
  3728                                  ;ENDIF
  3729                                  
  3730                                  ;IFNDEF  IBM
  3731                                  ;IBM     EQU     0
  3732                                  ;ENDIF
  3733                                  
  3734                                  ;IFNDEF  HIGHMEM
  3735                                  ;HIGHMEM  EQU     0
  3736                                  ;ENDIF
  3737                                  
  3738                                          ;i_need  USER_SP,WORD
  3739                                          ;i_need  USER_SS,WORD
  3740                                          ;i_need  SAVEDS,WORD
  3741                                          ;i_need  SAVEBX,WORD
  3742                                          ;i_need  INDOS,BYTE
  3743                                          ;i_need  NSP,WORD
  3744                                          ;i_need  NSS,WORD
  3745                                          ;i_need  CURRENTPDB,WORD
  3746                                          ;i_need  AUXSTACK,BYTE
  3747                                          ;i_need  CONSWAP,BYTE
  3748                                          ;i_need  IDLEINT,BYTE
  3749                                          ;i_need  NOSETDIR,BYTE
  3750                                          ;i_need  ERRORMODE,BYTE
  3751                                          ;i_need  IOSTACK,BYTE
  3752                                          ;i_need  WPERR,BYTE
  3753                                          ;i_need  DSKSTACK,BYTE
  3754                                          ;i_need  CNTCFLAG,BYTE
  3755                                          ;i_need  LEAVEADDR,WORD
  3756                                          ;i_need  NULLDEVPT,DWORD
  3757                                  
  3758                                          ;IF NOT IBM
  3759                                          ;i_need  OEM_HANDLER,DWORD
  3760                                          ;ENDIF
  3761                                  
  3762                                          ;EXTRN   DSKSTATCHK:NEAR,GETBP:NEAR,DSKREAD:NEAR,DSKWRITE:NEAR
  3763                                  
  3764                                  ;============================================================================
  3765                                  ; MSDISP.ASM, MSDOS 6.0, 1991
  3766                                  ;============================================================================
  3767                                  ; 11/07/2018 - Retro DOS v3.0
  3768                                  ; 01/05/2019 - Retro DOS v4.0
  3769                                  
  3770                                  ; DosCode SEGMENT
  3771                                  
  3772                                  ; ==========================================================================
  3773                                  ;
  3774                                  ; $Set_CTRL_C_Trapping
  3775                                  ;
  3776                                  ; Function:
  3777                                  ;	Enable disable ^C checking in dispatcher
  3778                                  ;
  3779                                  ; Inputs:
  3780                                  ;		AL = 0 read ^C status
  3781                                  ;		AL = 1 Set ^C status, DL = 0/1 for ^C off/on
  3782                                  ;		AL = 2 Set ^C status to contents of DL.	Output is old state.
  3783                                  ;		AL = 5 get DOS boot drive
  3784                                  ;		AL = 6 Get version number
  3785                                  ;			RETURNS:
  3786                                  ;				BH = Minor version number
  3787                                  ;				BL = Major version number
  3788                                  ;				DL = DOS internal revision
  3789                                  ;				DH = DOS type flags
  3790                                  ;					Bit 3 	- DOS in ROM
  3791                                  ;					Bit 4 	- DOS in HMA
  3792                                  ;					Bit 0-2, 5-7 - Reserved
  3793                                  ; Outputs:
  3794                                  ;		If AL = 0 then DL = 0/1 for ^C off/on
  3795                                  ;
  3796                                  ; History:
  3797                                  ;      removed	AL = 3 Get CPSW state to DL	    DOS 3.4
  3798                                  ;      removed	AL = 4 Set CPSW state from DL	    DOS 3.4
  3799                                  ; ==========================================================================
  3800                                  
  3801                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  3802                                  ; DOSCODE:4045h (MSDOS 5.0, MSDOS.SYS)
  3803                                  
  3804                                  _$SET_CTRL_C_TRAPPING:
  3805                                  	; 01/05/2019 - Retro DOS v4.0
  3806                                  
  3807 00000267 3C06                    	cmp	AL,6			; Is this a valid subfunction?
  3808 00000269 7603                    	jbe	short scct_1		; If yes continue processing
  3809                                  
  3810 0000026B B0FF                    	mov	AL,0FFh			; Else set AL to -1 and
  3811 0000026D CF                      	iret
  3812                                  scct_1:
  3813 0000026E 1E                      	push	DS
  3814                                  
  3815                                  	;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
  3816 0000026F 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  3817                                  	
  3818 00000274 50                      	push	AX			; DL only register that can change
  3819 00000275 56                      	push	SI
  3820                                  
  3821 00000276 BE[3703]                	mov	SI,CNTCFLAG		; DS:SI --> Ctrl C Status byte
  3822 00000279 30E4                    	xor	AH,AH			; Clear high byte of AX
  3823 0000027B 09C0                    	or	AX,AX			; Check for subfunction 0
  3824 0000027D 7504                    	jnz	short scct_2		; If not 0 jmp to next check
  3825                                  
  3826 0000027F 8A14                    	mov	DL,[SI]			; Else move current ctrl C status
  3827 00000281 EB35                    	jmp	SHORT scct_9s		; into DL and jmp to exit
  3828                                  scct_2:
  3829 00000283 48                      	dec	AX			; Now dec AX and see if it was 1
  3830 00000284 7507                    	jnz	short scct_3		; If not 0 it wasn't 1 so do next chk
  3831                                  
  3832 00000286 80E201                  	and	DL,1			; Else mask off bit 0 of DL and
  3833 00000289 8814                    	mov	[SI],DL			; save it as new Ctrl C status
  3834 0000028B EB2B                    	jmp	SHORT scct_9s		; Jmp to exit
  3835                                  scct_3:
  3836 0000028D 48                      	dec	AX			; Dec AX again to see if it was 2
  3837 0000028E 7507                    	jnz	short scct_4		; If not 0 wasn't 2 so go to next chk
  3838                                  
  3839 00000290 80E201                  	and	DL,1			; Else mask off bit 0 of DL and
  3840 00000293 8614                    	xchg	[SI],DL			; Exchange DL with old status byte
  3841 00000295 EB21                    	jmp	SHORT scct_9s		; Jump to exit (returning old status)
  3842                                  scct_4:
  3843 00000297 83F803                  	cmp	AX,3 			; Test for 5 after it was dec twice
  3844 0000029A 7506                    	jne	short scct_5		; If not equal then not get boot drv
  3845 0000029C 8A16[6900]              	mov	DL,[BOOTDRIVE]		; Else return boot drive in DL
  3846 000002A0 EB16                    	jmp	SHORT scct_9s		; Jump to exit (returning boot drive)
  3847                                  scct_5:
  3848 000002A2 83F804                  	cmp	AX,4 			; Test for 6 after it was dec twice
  3849 000002A5 7511                    	jne	short scct_9s		; If not equal then not get version
  3850                                  	
  3851                                  	;mov	BX,(Minor_Version SHL 8) + Major_Version
  3852                                  	;mov	bx,1406h	; DOSCODE:4092h (MSDOS 6.21, MSDOS.SYS)	
  3853 000002A7 BB0616                  	mov	bx,(MINOR_VERSION<<8)+MAJOR_VERSION
  3854 000002AA B200                    	mov	dl,0
  3855                                  	;mov	DL,DOSREVNM ; 0
  3856                                  
  3857 000002AC 30F6                    	xor	dh,dh			; assume vanilla DOS
  3858 000002AE 803E[F211]00            	cmp	byte [DosHasHMA],0	; is DOS in HMA?  (M021)
  3859                                  	;je	short @F
  3860 000002B3 7403                    	je	short scct_6
  3861 000002B5 80CE10                  	or	dh,10h
  3862                                  	;or	DH,DOSINHMA ; 10h
  3863                                  ;@@:
  3864                                  scct_6:
  3865                                  
  3866                                  ;ifdef ROMDOS
  3867                                  ;	or	DH, DOSINROM
  3868                                  ;endif ; ROMDOS
  3869                                  
  3870                                  scct_9s:
  3871 000002B8 5E                      	pop	SI
  3872 000002B9 58                      	pop	AX
  3873 000002BA 1F                      	pop	DS
  3874                                  scct_9f:
  3875 000002BB CF                      	iret
  3876                                  
  3877                                  SetCtrlShortEntry:			; This allows a conditional entry
  3878                                  					; from main dispatch code
  3879 000002BC EBA9                    	jmp	SHORT _$SET_CTRL_C_TRAPPING
  3880                                  
  3881                                  ; ==========================================================================
  3882                                  ;									   
  3883                                  ; The following two routines are dispatched to directly with ints disabled
  3884                                  ; immediately after the int 21h entry.	no DIS state is set.
  3885                                  ;
  3886                                  ; $Set_current_PDB takes BX and sets it to be the current process
  3887                                  ;   *** THIS FUNCTION CALL IS SUBJECT TO CHANGE!!! ***
  3888                                  ;
  3889                                  ; ==========================================================================
  3890                                  
  3891                                  _$SET_CURRENT_PDB:
  3892 000002BE 1E                      	push	DS
  3893                                  	;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
  3894 000002BF 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  3895 000002C4 891E[3003]              	mov	[CurrentPDB],BX		; Set new PSP segment from caller's BX
  3896 000002C8 1F                      	pop	DS
  3897 000002C9 CF                      	iret
  3898                                  
  3899                                  ; ==========================================================================
  3900                                  ;
  3901                                  ; $get_current_PDB returns in BX the current process
  3902                                  ;   *** THIS FUNCTION CALL IS SUBJECT TO CHANGE!!! ***
  3903                                  ;
  3904                                  ; ==========================================================================
  3905                                  
  3906                                  _$GET_CURRENT_PDB:
  3907 000002CA 1E                      	push	DS
  3908                                  	;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
  3909 000002CB 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  3910 000002D0 8B1E[3003]              	mov	BX,[CurrentPDB]		; Return current PSP segment in BX
  3911 000002D4 1F                      	pop	DS
  3912 000002D5 CF                      	iret
  3913                                  
  3914                                  ; ==========================================================================
  3915                                  ;
  3916                                  ; Sets the Printer Flag to whatever is in AL.
  3917                                  ; NOTE: THIS PROCEDURE IS SUBJECT TO CHANGE!!!
  3918                                  ;
  3919                                  ; ==========================================================================
  3920                                  
  3921                                  _$SET_PRINTER_FLAG:
  3922 000002D6 1E                      	push	ds
  3923                                  	;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
  3924 000002D7 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  3925 000002DC A2[A00A]                	mov	[PRINTER_FLAG],AL 	; Set printer flag from caller's AL
  3926 000002DF 1F                      	pop	ds
  3927 000002E0 CF                      	iret
  3928                                  
  3929                                  ; 01/05/2019 - Retro DOS v4.0
  3930                                  ; 08/07/2018 - Retro DOS v3.0
  3931                                  ; (MSDISP.ASM, MSDOS 6.0, 1991)
  3932                                  
  3933                                  ; ----------------------------------------------------------------------------
  3934                                  ; BREAK   <System call entry points and dispatcher>
  3935                                  ; ----------------------------------------------------------------------------
  3936                                  
  3937                                  ; DOSCODE:40CCh (MSDOS 6.21, MSDOS.SYS)
  3938                                  
  3939                                  ; ==========================================================================
  3940                                  ;
  3941                                  ; The Quit entry point is where all INT 20h's come from. These are old- style
  3942                                  ; exit system calls. The CS of the caller indicates which Process is dying.
  3943                                  ; The error code is presumed to be 0. We simulate an ABORT system call.
  3944                                  ;
  3945                                  ; ==========================================================================
  3946                                  
  3947                                  SYSTEM_CALL:    ; PROC NEAR
  3948                                  
  3949                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  3950                                  ; DOSCODE:40BFh (MSDOS 5.0, MSDOS.SYS)
  3951                                  
  3952                                  ;entry	QUIT				
  3953                                  QUIT:				; INT 20H entry point	
  3954                                  	;MOV	AH,0
  3955 000002E1 30E4                    	xor	ah,ah ; 08/07/2018
  3956 000002E3 EB36                    	JMP     SHORT SAVREGS
  3957                                  
  3958                                  ; ---------------------------------------------------------------------------
  3959                                  
  3960                                  	; The system call in AH is out of the range that we know how
  3961                                  	; to handle. We arbitrarily set the contents of AL to 0 and
  3962                                  	; IRET. Note that we CANNOT set the carry flag to indicate an
  3963                                  	; error as this may break some programs compatability.
  3964                                  
  3965                                  BADCALL:
  3966                                          ;MOV	AL,0
  3967 000002E5 30C0                    	xor	al,al ; 08/07/2018
  3968                                  IRETT:	; 06/05/2019
  3969                                  _IRET:
  3970 000002E7 CF                              IRET
  3971                                  
  3972                                  ; ---------------------------------------------------------------------------
  3973                                  
  3974                                  ; 01/05/2019 - Retro DOS v4.0
  3975                                  ; DOSCODE:40D3h (MSDOS 6.21 MSDOS.SYS)
  3976                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  3977                                  ; DOSCODE:40C6h (MSDOS 5.0 MSDOS.SYS)
  3978                                  
  3979                                  	; An alternative method of entering the system is to perform a
  3980                                  	; CALL 5 in the program segment prefix with the contents of CL
  3981                                  	; indicating what system call the user would like. A subset of
  3982                                  	; the possible system calls is allowed here only the
  3983                                  	; CPM-compatible calls may get dispatched.
  3984                                  
  3985                                  		; System call entry point and dispatcher
  3986                                  CALL_ENTRY:
  3987 000002E8 1E                      	push	DS
  3988                                  	;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
  3989 000002E9 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  3990 000002EE 8F06[EC05]              	pop	word [SAVEDS]		; Save original DS
  3991                                  
  3992 000002F2 58                              POP     AX                      ; IP from the long call at 5
  3993 000002F3 58                              POP     AX                      ; Segment from the long call at 5
  3994 000002F4 8F06[8405]              	POP	WORD [USER_SP]		; IP from the CALL 5
  3995                                  
  3996                                  		; Re-order the stack to simulate an interrupt 21.
  3997                                  
  3998 000002F8 9C                      	PUSHF				; Start re-ordering the stack
  3999 000002F9 FA                      	CLI
  4000 000002FA 50                              PUSH    AX                      ; Save segment
  4001 000002FB FF36[8405]                      PUSH	WORD [USER_SP]		; Stack now ordered as if INT had been used
  4002                                  	; 04/11/2022
  4003                                  	; DOSCODE:40EAh (MSDOS 6.21 MSDOS.SYS)
  4004                                  	; DOSCODE:40DDh (MSDOS 5.0 MSDOS.SYS)
  4005 000002FF FF36[EC05]              	push	word [SAVEDS]
  4006 00000303 1F                      	pop	ds
  4007                                  	;
  4008                                  	;cmp	cl,36
  4009 00000304 80F924                          CMP     CL,MAXCALL              ; This entry point doesn't get as many calls
  4010 00000307 77DC                            JA      SHORT BADCALL
  4011 00000309 88CC                            MOV     AH,CL
  4012                                  	; 08/07/2018
  4013 0000030B EB0E                    	jmp	short SAVREGS
  4014                                  
  4015                                  ; ---------------------------------------------------------------------------
  4016                                  
  4017                                  ; 01/05/2019 - Retro DOS v4.0
  4018                                  
  4019                                  	; This is the normal INT 21 entry point. We first perform a
  4020                                  	; quick test to see if we need to perform expensive DOS-entry
  4021                                  	; functions. Certain system calls are done without interrupts
  4022                                  	; being enabled.
  4023                                  
  4024                                  	;entry	COMMAND 		; Interrupt call entry point (int 21h)
  4025                                  
  4026                                  ; DOSCODE:40F8h (MSDOS 6.21, MSDOS.SYS)
  4027                                  ; 04/11/2022
  4028                                  ; DOSCODE:40EBh (MSDOS 5.0, MSDOS.SYS)
  4029                                  
  4030                                  COMMAND:
  4031                                  	; 22/12/2022
  4032 0000030D FA                      	cli
  4033                                  
  4034                                  	; 01/05/2019 - Retro DOS v4.0
  4035                                  	; 08/07/2018 - Retro DOS v3.0
  4036                                  
  4037                                  ; 22/12/2022
  4038                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  4039                                  	;IF	NOT IBM
  4040 0000030E 80FCF8                  	CMP	AH,SET_OEM_HANDLER
  4041 00000311 7203                    	JB	SHORT NOTOEM
  4042 00000313 E98401                  	JMP	_$SET_OEM_HANDLER
  4043                                  
  4044                                  NOTOEM:
  4045                                  	;ENDIF
  4046                                  
  4047                                  ; DOSCODE:40F8h (MSDOS 6.21, MSDOS.SYS)
  4048                                  ; DOSCODE:40EBh (MSDOS 5.0, MSDOS.SYS)
  4049                                  
  4050                                  	; 22/12/2022
  4051                                  	;cli	; 08/07/2018
  4052                                  
  4053                                  _COMMAND: ; MSDOS 3.3 (IBM)
  4054                                  	;cmp	ah,6Ch   ; MSDOS 6.21 ; Max int 21h function call number
  4055                                  	; 04/11/2022
  4056 00000316 80FC6C                  	CMP     AH,MAXCOM  ; 6Ch for MSDOS 6.0 (6.21,6.22) & MSDOS 5.0
  4057                                  	;JBE	SHORT SAVREGS
  4058 00000319 77CA                            JA	SHORT BADCALL ; 08/07/2018
  4059                                  
  4060                                  	; 31/05/2019
  4061                                  
  4062                                  	; The following set of calls are issued by the server at
  4063                                  	; *arbitrary* times and, therefore, must be executed on
  4064                                  	; the user's entry stack and executed with interrupts off.
  4065                                  
  4066                                  SAVREGS:
  4067                                  	; 01/05/2019 - Retro DOS v4.0
  4068                                  	; 10/08/2018
  4069                                  	; 08/07/2018 - Retro DOS v3.0
  4070 0000031B 80FC33                  	cmp	ah,33h			; Check Minimum special case #
  4071                                  	;;je	_$SET_CTRL_C_TRAPPING
  4072                                  	;je	short SetCtrlShortEntry ; If equal jmp directly to function
  4073 0000031E 7218                    	jb	short SaveAllRegs	; Not special case so continue	
  4074                                  	; 04/11/2022
  4075 00000320 749A                    	je	short SetCtrlShortEntry ; If equal jmp directly to function
  4076 00000322 80FC64                  	cmp	ah,64h			; Check Max case number
  4077 00000325 7711                    	ja	short SaveAllRegs	; Not special case so continue
  4078 00000327 74AD                    	je	short _$SET_PRINTER_FLAG ; If equal jmp directly to function
  4079 00000329 80FC51                  	cmp	ah,51h			; Is this a Get PSP call (51h)?
  4080 0000032C 749C                    	je	short _$GET_CURRENT_PDB	; Yes, jmp directly to function
  4081 0000032E 80FC62                  	cmp	ah,62h			; Is this a Get PSP call (62h)?
  4082 00000331 7497                    	je	short _$GET_CURRENT_PDB	; Yes, jmp directly to function
  4083 00000333 80FC50                  	cmp     ah,50h			; Is this a Set PSP call (50h) ?
  4084 00000336 7486                    	je	short _$SET_CURRENT_PDB	; Yes, jmp directly to function
  4085                                  
  4086                                  SaveAllRegs:
  4087                                  	; 01/05/2019 - Retro DOS v4.0
  4088                                  
  4089 00000338 06                              push	ES
  4090 00000339 1E                      	push	DS
  4091 0000033A 55                      	push	BP
  4092 0000033B 57                      	push	DI
  4093 0000033C 56                      	push	SI
  4094 0000033D 52                      	push	DX
  4095 0000033E 51                      	push	CX
  4096 0000033F 53                      	push	BX
  4097 00000340 50                      	push	AX
  4098                                  
  4099 00000341 8CD8                    	mov	AX,DS
  4100                                  	;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
  4101 00000343 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  4102 00000348 A3[EC05]                	mov	[SAVEDS],AX		; save caller's DS
  4103 0000034B 891E[EA05]              	mov	[SAVEBX],BX
  4104                                  
  4105                                          ;INC     BYTE [INDOS]		; Flag that we're in the DOS
  4106                                  	
  4107                                  	; 08/07/2018 - Retro DOS v3.0        
  4108                                  	;xor     ax,ax
  4109                                  	;mov     [USER_ID],ax
  4110                                  	;mov     ax,[CurrentPDB]
  4111                                  	;mov     [PROC_ID],ax
  4112                                  
  4113                                  	; 01/05/2019
  4114                                  
  4115                                  	; Note: Nsp and Nss have to be unconditionally initialized here 
  4116                                  	; even if InDOS is zero. Programs like CROSSTALK 3.7 depend on
  4117                                  	; this!!!
  4118                                  
  4119 0000034F A1[8405]                	MOV     AX,[USER_SP]
  4120 00000352 A3[F205]                        MOV     [NSP],AX
  4121 00000355 A1[8605]                        MOV     AX,[USER_SS]
  4122 00000358 A3[F005]                        MOV     [NSS],AX
  4123                                  
  4124 0000035B 31C0                    	xor	AX,AX ; 0
  4125 0000035D A2[7205]                	mov	[FSHARING],AL		; allow redirection
  4126                                  
  4127 00000360 F606[2F10]01            	test	byte [IsWin386],1	; WIN386 patch. Do not update USER_ID
  4128 00000365 7503                    	jnz	short set_indos_flag	; if win386 present
  4129 00000367 A3[3E03]                	mov	[USER_ID],AX
  4130                                  set_indos_flag:
  4131 0000036A FE06[2103]              	INC     BYTE [INDOS]		; Flag that we're in the DOS
  4132                                  
  4133 0000036E 8926[8405]                      MOV     [USER_SP],SP
  4134 00000372 8C16[8605]                      MOV     [USER_SS],SS
  4135                                  
  4136 00000376 A1[3003]                	mov	AX,[CurrentPDB]
  4137 00000379 A3[3C03]                	mov	[PROC_ID],AX
  4138 0000037C 8ED8                    	mov	DS,AX
  4139 0000037E 58                      	pop	AX
  4140 0000037F 50                      	push	AX
  4141                                  
  4142                                  	; save user stack in his area for later returns (possibly from EXEC)
  4143                                  
  4144 00000380 89262E00                        MOV     [PDB.USER_STACK],SP
  4145 00000384 8C163000                        MOV     [PDB.USER_STACK+2],SS
  4146                                  
  4147                                  	; 18/07/2018
  4148                                  	;mov	byte [CS:FSHARING], 0
  4149                                  
  4150                                  	;MOV     BX,CS			; no holes here.
  4151                                  	;MOV     SS,BX
  4152                                  
  4153                                  	;getdseg <ss>			; ss -> dosdat, already flag is CLI
  4154 00000388 2E8E16[0700]            	mov	ss,[cs:DosDSeg]
  4155                                  					;entry	REDISP
  4156                                  REDISP:
  4157 0000038D BC[A007]                        MOV     SP,AUXSTACK		; Enough stack for interrupts
  4158 00000390 FB                              STI                             ; stack is in our space now...
  4159                                  
  4160 00000391 8CD3                    	mov	bx,ss
  4161 00000393 8EDB                    	mov	ds,bx
  4162                                  
  4163 00000395 93                      	xchg	ax,bx
  4164                                  
  4165 00000396 31C0                    	xor	ax,ax ; 0
  4166                                  
  4167                                  	; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  4168                                  	; MSDOS 5.0 MSDOS.SYS - DOSCODE:416Eh  (from org 3DD0h)
  4169                                  	; MSDOS 6.21 MSDOS.SYS - DOSCODE:417Bh (from org 3DE0h)
  4170                                  
  4171                                  	; (Note: ss: segment prefix was not needed here! ds=ss ! -04/11/2022-)
  4172                                  
  4173                                  	;mov	[ss:EXTOPEN_ON],al ; 0	; Clear extended open flag
  4174                                  	;;and	word [ss:DOS34_FLAG],EXEC_AWARE_REDIR
  4175                                  	;and	word [ss:DOS34_FLAG],800h ; clear all bits except bit 11
  4176                                  	;mov	[ss:CONSWAP],al  ; 0	; random clean up of possibly mis-set flags
  4177                                  	;mov	[ss:NoSetDir],al ; 0	; set directories on search
  4178                                  	;mov	[ss:FAILERR],al ; 0	; FAIL not in progress
  4179                                  	;inc	ax
  4180                                  	;;inc	AL			; AL = 1
  4181                                  	;mov	[ss:IDLEINT],al		; presume that we can issue INT 28
  4182                                  
  4183                                  	; 15/12/2022
  4184 00000398 A2[F605]                	mov	[EXTOPEN_ON],al ; 0	; Clear extended open flag
  4185                                  	;and	word [DOS34_FLAG],EXEC_AWARE_REDIR
  4186 0000039B 8126[1106]0008          	and	word [DOS34_FLAG],800h	; clear all bits except bit 11
  4187 000003A1 A2[5703]                	mov	[CONSWAP],al  ; 0	; random clean up of possibly mis-set flags
  4188                                  	;mov	byte [IDLEINT],1
  4189 000003A4 A2[4C03]                	mov	[NoSetDir],al ; 0	; set directories on search
  4190 000003A7 A2[4A03]                	mov	[FAILERR],al ; 0	; FAIL not in progress
  4191 000003AA 40                      	inc	ax
  4192                                  	;inc	al			; AL = 1
  4193 000003AB A2[5803]                	mov	[IDLEINT],al		; presume that we can issue INT 28
  4194                                  
  4195 000003AE 93                      	XCHG	AX,BX			; Restore AX and BX = 1		
  4196                                  
  4197 000003AF 88E3                    	MOV     BL,AH			
  4198 000003B1 D1E3                            SHL     BX,1			; 2 bytes per call in table
  4199                                         
  4200 000003B3 FC                      	CLD
  4201                                  		; Since the DOS maintains mucho state information across system
  4202                                  		; calls, we must be very careful about which stack we use.
  4203                                  		; First, all abort operations must be on the disk stack. This
  4204                                  		; is due to the fact that we may be hitting the disk (close
  4205                                  		; operations, flushing) and may need to report an INT 24.
  4206                                          
  4207 000003B4 08E4                    	OR      AH,AH
  4208 000003B6 7416                            JZ      SHORT DSKROUT		; ABORT
  4209                                  
  4210                                          ;CMP	AH,12
  4211                                          ;JBE	SHORT IOROUT		; Character I/O
  4212                                          ;CMP	AH,GET_CURRENT_PDB      ; INT 24 needs GET,SET PDB
  4213                                          ;JZ	SHORT IOROUT
  4214                                          ;CMP	AH,SET_CURRENT_PDB
  4215                                          ;JNZ	SHORT DSKROUT
  4216                                  
  4217                                  		; Second, PRINT and PSPRINT and the server issue
  4218                                  		; GetExtendedError calls at INT 28 and INT 24 time.
  4219                                  		; This call MUST, therefore, use the AUXSTACK.
  4220                                  
  4221                                  	; 10/08/2018
  4222 000003B8 80FC59                  	cmp     ah,GETEXTENDEDERROR ; 59h
  4223 000003BB 743D                    	je      short DISPCALL
  4224                                  	
  4225                                  	; 01/05/2019
  4226                                  	
  4227                                  		; Old 1-12 system calls may be either on the IOSTACK (normal
  4228                                  		; operation) or on the AUXSTACK (at INT 24 time).
  4229                                  
  4230 000003BD 80FC0C                  	cmp     ah,12 ; STD_CON_INPUT_FLUSH ; 0Ch
  4231 000003C0 770C                    	ja      short DSKROUT
  4232                                  
  4233                                  IOROUT:
  4234                                  	; 04/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  4235                                  	; (ss: prefix was not needed here! ds=ss)
  4236                                  	;cmp	byte [ss:ERRORMODE],0	; Are we in an INT 24? 
  4237                                  	; 15/12/2022
  4238 000003C2 803E[2003]00            	cmp     BYTE [ERRORMODE],0	; Are we in an INT 24?
  4239 000003C7 7531                            JNZ     SHORT DISPCALL		; Stay on AUXSTACK if INT 24
  4240 000003C9 BC[A00A]                        MOV     SP,IOSTACK
  4241 000003CC EB2C                            JMP     SHORT DISPCALL
  4242                                  
  4243                                  		; We are on a system call that is classified as "the rest".
  4244                                  		; We place ourselves onto the DSKSTACK and away we go.
  4245                                  		; We know at this point:
  4246                                  		; *  An INT 24 cannot be in progress. Therefore we reset
  4247                                  		;    ErrorMode and WpErr
  4248                                  		; *  That there can be no critical sections in effect.
  4249                                  		;    We signal the server to remove all the resources.
  4250                                  
  4251                                  DSKROUT:
  4252                                  	; 15/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  4253                                  	; 08/07/2018 - Retro DOS v3.0
  4254 000003CE A3[3A03]                	mov     [USER_IN_AX],ax		; Remember what user is doing
  4255 000003D1 C606[2303]01            	mov     byte [EXTERR_LOCUS],1	; errLOC_Unk (Default)
  4256                                  	
  4257 000003D6 C606[2003]00            	MOV     BYTE [ERRORMODE],0	; Cannot make non 1-12 calls in
  4258 000003DB C606[2203]FF            	MOV     BYTE [WPERR],-1		; error mode, so good place to
  4259                                  	                   		; make sure flags are reset
  4260                                  
  4261                                  	; 04/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  4262                                  	; (ss: prefix was not needed here! ds=ss)
  4263                                  
  4264                                  	;mov	[ss:USER_IN_AX],ax	; Remember what user is doing
  4265                                  	;mov	byte [ss:EXTERR_LOCUS],1 ; errLOC_Unk (Default)
  4266                                  	;mov	byte [ss:ERRORMODE],0	; Cannot make non 1-12 calls in
  4267                                  	;mov	byte [ss:WPERR],-1	; error mode, so good place to
  4268                                                                          ; make sure flags are reset
  4269 000003E0 50                      	push    ax
  4270 000003E1 B482                    	mov     ah,82h			; Release all resource information
  4271 000003E3 CD2A                    	int     2Ah 		; Microsoft Networks 
  4272                                  				; END DOS CRITICAL SECTIONS 0 THROUGH 7
  4273 000003E5 58                      	pop     ax
  4274                                  
  4275                                  		; Since we are going to be running on the DSKStack and since
  4276                                  		; INT 28 people will use the DSKStack, we must turn OFF the
  4277                                  		; generation of INT 28's.
  4278                                  
  4279                                  	; 15/12/2022
  4280                                  	;mov     byte [ss:IDLEINT],0
  4281                                  	;
  4282                                          ;mov	sp,DSKSTACK
  4283                                  	;test	byte [ss:CNTCFLAG],-1  ; 0FFh
  4284                                          ;jz	short DISPCALL
  4285                                  
  4286 000003E6 C606[5803]00            	mov     byte [IDLEINT],0
  4287                                  
  4288 000003EB BC[2009]                	MOV     SP,DSKSTACK
  4289 000003EE F606[3703]FF            	TEST    BYTE [CNTCFLAG],-1
  4290 000003F3 7405                    	JZ      SHORT DISPCALL
  4291                                  
  4292 000003F5 50                              PUSH    AX
  4293                                          ;invoke	DSKSTATCHK
  4294 000003F6 E8214D                          CALL	DSKSTATCHK
  4295 000003F9 58                      	POP     AX
  4296                                  DISPCALL:
  4297                                  	; 01/05/2019 - Retro DOS v4.0
  4298 000003FA 2E8B9F[EA00]            	mov	bx,[CS:BX+DISPATCH]
  4299                                  
  4300                                  	; 15/12/2022
  4301 000003FF 871E[EA05]              	xchg	bx,[SAVEBX]
  4302 00000403 8E1E[EC05]              	MOV	DS,[SAVEDS]
  4303                                  
  4304                                  	; 04/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  4305                                  	; (ss: prefix was not needed here! ds=ss)        
  4306                                  	;xchg	bx,[ss:SAVEBX]
  4307                                  	;mov	ds,[ss:SAVEDS]
  4308                                  
  4309 00000407 36FF16[EA05]            	call	word [SS:SAVEBX] ; near call
  4310                                  
  4311                                  	; The EXEXA20OFF bit of DOS_FLAG will now be unconditionally cleared
  4312                                  	; here. Please see under M003, M009 and M068 tags in dossym.inc
  4313                                  	; for explanation. Also NOTE that a call to ExecReady (ax=4b05) will
  4314                                  	; return to LeaveDos and hence will not clear this bit. This is 
  4315                                  	; because this bit is used to indicate to the next int 21 call that
  4316                                  	; the previous int 21 was an exec.
  4317                                  	;
  4318                                  	; So do not add any code between the call above and the label 
  4319                                  	; LeaveDOS if it needs to be executed even for ax=4b05
  4320                                  
  4321                                  	;and	byte [ss:DOS_FLAG],~EXECA20OFF
  4322 0000040C 368026[8600]FB          	and	byte [ss:DOS_FLAG],0FBh
  4323                                  
  4324                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  4325                                  ; DOSCODE:41F7h
  4326                                  
  4327                                  ;entry LEAVE
  4328                                  ;;;_LEAVE:				; Exit from a system call
  4329                                  LeaveDOS: ; 18/07/2018 
  4330                                  ;ASSUME	SS:NOTHING			; User routines may misbehave
  4331 00000412 FA                      	CLI
  4332                                  
  4333                                  	; 01/05/2019
  4334                                  	;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
  4335 00000413 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  4336 00000418 803E[8500]00            	cmp	byte [A20OFF_COUNT],0	; M068: Q: is count 0
  4337 0000041D 7527                    	jne	short disa20		; M068: N: dec count and turn a20 off
  4338                                  
  4339                                  LeaveA20On:
  4340 0000041F FE0E[2103]                      DEC     BYTE [INDOS]
  4341                                          ; 04/11/2022
  4342 00000423 8E16[8605]              	mov	ss,[USER_SS]
  4343 00000427 8B26[8405]              	MOV     SP,[USER_SP]
  4344                                  	;MOV	SS,[USER_SS]
  4345 0000042B 89E5                    	MOV     BP,SP
  4346                                  	;MOV	[BP.user_AX],AL	
  4347                                          ; 04/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  4348                                  	;;mov	[bp+0],al ; MSDOS 5.0 MSDOS.SYS - DOSCODE:4212h	
  4349                                  	;MOV	[BP+user_env.user_AX],AL  ; user_env.user_AX = 0
  4350                                  	; 15/12/2022
  4351 0000042D 884600                  	MOV	[BP],AL
  4352 00000430 A1[F205]                	MOV     AX,[NSP]
  4353 00000433 A3[8405]                        MOV     [USER_SP],AX
  4354 00000436 A1[F005]                        MOV     AX,[NSS]
  4355 00000439 A3[8605]                        MOV     [USER_SS],AX
  4356                                  
  4357 0000043C 58                      	pop	AX
  4358 0000043D 5B                      	pop	BX
  4359 0000043E 59                      	pop	CX
  4360 0000043F 5A                      	pop	DX
  4361 00000440 5E                      	pop	SI
  4362 00000441 5F                      	pop	DI
  4363 00000442 5D                      	pop	BP
  4364 00000443 1F                      	pop	DS
  4365 00000444 07                      	pop	ES
  4366                                  
  4367 00000445 CF                              IRET
  4368                                  
  4369                                  disa20:	   				; M068 - Start
  4370 00000446 8B1E[6300]              	mov	bx,[A20OFF_PSP]		; bx = PSP for which a20 to be off'd
  4371 0000044A 3B1E[3003]              	cmp	bx,[CurrentPDB]		; Q: do the PSP's match
  4372 0000044E 75CF                    	jne	short LeaveA20On	; N: don't clear bit and don't turn 
  4373                                  					;    a20 off
  4374                                  					; Y: turn a20 off and dec a20off_count
  4375 00000450 FE0E[8500]              	dec	byte [A20OFF_COUNT]	; M068 - End
  4376                                   					; Start - M004
  4377 00000454 1E                      	push	ds			; segment of stub
  4378 00000455 BB[1311]                	mov	bx,disa20_iret		; offset in stub
  4379 00000458 53                      	push	bx
  4380 00000459 CB                      	retf	  			; go to stub
  4381                                  					; End - M004
  4382                                  ;SYSTEM_CALL ENDP
  4383                                  
  4384                                  ; DOSCODE:424Ch (MSDOS 6.21, MSDOS.SYS)
  4385                                  ; 04/11/2022
  4386                                  ; DOSCODE:423Fh (MSDOS 5.0, MSDOS.SYS)
  4387                                  
  4388                                  ; ==========================================================================
  4389                                  ;
  4390                                  ; Restore_World restores all registers ('cept SS:SP, CS:IP, flags) from
  4391                                  ; the stack prior to giving the user control
  4392                                  ;
  4393                                  ; ==========================================================================
  4394                                  
  4395                                  ; 01/05/2019 - Retro DOS v4.0
  4396                                  
  4397                                          ;procedure restore_world,NEAR
  4398                                  restore_world:
  4399                                  	;getdseg <es>		; es -> dosdata
  4400 0000045A 2E8E06[0700]            	mov	es,[cs:DosDSeg]
  4401                                  
  4402 0000045F 268F06[EE05]                    POP	WORD [ES:RESTORE_TMP]
  4403                                  
  4404 00000464 58                              POP     AX
  4405 00000465 5B                              POP     BX
  4406 00000466 59                              POP     CX
  4407 00000467 5A                              POP     DX
  4408 00000468 5E                              POP     SI
  4409 00000469 5F                              POP     DI
  4410 0000046A 5D                              POP     BP
  4411 0000046B 1F                              POP     DS
  4412                                  
  4413 0000046C 26FF26[EE05]                   	jmp	word [ES:RESTORE_TMP]
  4414                                  
  4415                                  ;restore_world	ENDP
  4416                                  
  4417                                  ; 01/05/2019 - Retro DOS v4.0 (MSDOS 6.0, MSDISP.ASM, 1991)
  4418                                  
  4419                                  ; DOSCODE:4263h (MSDOS 6.21, MSDOS.SYS)
  4420                                  ; 04/11/2022
  4421                                  ; DOSCODE:4256h (MSDOS 5.0, MSDOS.SYS)
  4422                                  
  4423                                  ; ==========================================================================
  4424                                  ;
  4425                                  ; Save_World saves complete registers on the stack
  4426                                  ;
  4427                                  ; ==========================================================================
  4428                                  
  4429                                          ;procedure save_world,NEAR
  4430                                  save_world:
  4431                                  	;getdseg <es>		; es -> dosdata
  4432 00000471 2E8E06[0700]            	mov	es,[cs:DosDSeg]
  4433                                  
  4434 00000476 268F06[EE05]                    POP	WORD [ES:RESTORE_TMP]
  4435                                  
  4436                                  	; 12/05/2019
  4437                                          
  4438 0000047B 1E                      	PUSH    DS
  4439 0000047C 55                              PUSH    BP
  4440 0000047D 57                              PUSH    DI
  4441 0000047E 56                              PUSH    SI
  4442 0000047F 52                              PUSH    DX
  4443 00000480 51                              PUSH    CX
  4444 00000481 53                              PUSH    BX
  4445 00000482 50                              PUSH    AX
  4446                                  
  4447 00000483 26FF36[EE05]            	push	word [ES:RESTORE_TMP]
  4448                                  
  4449 00000488 55                      	push	BP		
  4450 00000489 89E5                    	mov	BP,SP
  4451 0000048B 8E4614                  	mov	ES,[BP+20]	; es was pushed before call
  4452 0000048E 5D                      	pop	BP
  4453                                  	
  4454 0000048F C3                      	retn
  4455                                  
  4456                                  ;save_world	ENDP
  4457                                  
  4458                                  ; 01/05/2019
  4459                                  
  4460                                  ; DOSCODE:4282h (MSDOS 6.21, MSDOS.SYS)
  4461                                  ; 04/11/2022
  4462                                  ; DOSCODE:4275h (MSDOS 5.0, MSDOS.SYS)
  4463                                  
  4464                                  ; ==========================================================================
  4465                                  ;
  4466                                  ; Get_User_Stack returns the user's stack (and hence registers) in DS:SI
  4467                                  ;
  4468                                  ; ==========================================================================
  4469                                  
  4470                                          ;procedure get_user_stack,NEAR
  4471                                  Get_User_Stack:
  4472                                          ;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
  4473 00000490 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  4474 00000495 C536[8405]                      lds	si,[USER_SP]
  4475 00000499 C3                      	retn
  4476                                  
  4477                                  ;get_user_stack  ENDP
  4478                                  
  4479                                  ; 22/12/2022
  4480                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0, MSDOS.SYS)
  4481                                  ;%if 0
  4482                                  
  4483                                  ; ---------------------------------------------------------------------------
  4484                                  ;
  4485                                  ; Set_OEM_Handler -- Set OEM sys call address and handle OEM Calls
  4486                                  ; Inputs:
  4487                                  ;	User registers, User Stack, INTS disabled
  4488                                  ;	If CALL F8, DS:DX is new handler address
  4489                                  ; Function:
  4490                                  ;	Process OEM INT 21 extensions
  4491                                  ; Outputs:
  4492                                  ;	Jumps to OEM_HANDLER if appropriate
  4493                                  ;
  4494                                  ; ---------------------------------------------------------------------------
  4495                                  
  4496                                  ;IF	NOT IBM
  4497                                  
  4498                                  _$SET_OEM_HANDLER:
  4499                                  	; 01/05/2019 - Retro DOS v4.0
  4500                                  	
  4501                                  	;(cmp	ah,SET OEM HANDLER  ; 0F8h)
  4502                                  	;(jb	short NOTOOEM)
  4503                                  
  4504 0000049A 06                      	push	es ; *
  4505                                  	;getdseg <es>			; es -> dosdata
  4506 0000049B 2E8E06[0700]            	mov	es,[cs:DosDSeg]
  4507                                  
  4508 000004A0 750C                    	jne	short check_trueversion_request ; check Retro DOS true version
  4509                                  						; (message) request	
  4510                                  	; AH = 0F8h = SET OEM HANDLER
  4511                                  
  4512 000004A2 268916[1400]            	MOV     [es:OEM_HANDLER],DX	; Set Handler
  4513 000004A7 268C1E[1600]            	MOV     [es:OEM_HANDLER+2],DS
  4514                                  
  4515 000004AC 07                      	pop	es ; *
  4516                                  
  4517 000004AD CF                      	IRET                            ; Quick return, Have altered no registers
  4518                                  
  4519                                  check_trueversion_request:
  4520                                  	; 18/07/2019 - Retro DOS v3.0
  4521                                  
  4522                                  	; Retro DOS v2.0 - 20/04/2018
  4523 000004AE 83F8FF                  	CMP	AX,0FFFFh
  4524                                  	; 18/07/2018
  4525 000004B1 7520                    	jne	short DO_OEM_FUNC ; 01/05/2019
  4526                                  
  4527                                  	; 01/05/2019
  4528 000004B3 07                      	pop	es ; *
  4529                                  
  4530 000004B4 B40E                    	mov	ah,0Eh
  4531                                  
  4532                                  	; Retro DOS v4.0 feature only!
  4533 000004B6 81FBA101                	cmp	bx,417  ; Signature to bypass
  4534                                  			; Retro DOS true version message	
  4535 000004BA 7414                    	je	short true_version_iret
  4536                                  
  4537 000004BC 56                      	push	si
  4538 000004BD 53                      	push	bx
  4539                                  
  4540 000004BE BE[BF00]                	mov	si,RETRODOSMSG
  4541                                  wrdosmsg:
  4542                                  	;movb	ah,0Eh
  4543 000004C1 BB0700                  	mov	bx,7
  4544                                  wrdosmsg_nxt:
  4545 000004C4 2EAC                    	cs	lodsb
  4546 000004C6 3C24                    	cmp	al,'$'
  4547 000004C8 7404                    	je	short wrdosmsg_ok		
  4548 000004CA CD10                    	int	10h
  4549 000004CC EBF6                    	jmp	short wrdosmsg_nxt
  4550                                  
  4551                                  wrdosmsg_ok:
  4552 000004CE 5B                      	pop	bx
  4553 000004CF 5E                      	pop	si
  4554                                  
  4555                                  true_version_iret:
  4556                                  	; ah = 0Eh
  4557                                  	;mov	al,40h ; Retro DOS v4.0
  4558                                  	; 
  4559                                  	;mov	al,41h ; Retro DOS v4.1 
  4560                                  	; 30/12/2022
  4561 000004D0 B042                    	mov	al,42h ; Retro DOS v4.2
  4562 000004D2 CF                      	iret
  4563                                  
  4564                                  	; If above F8 try to jump to handler
  4565                                  
  4566                                  DO_OEM_FUNC:
  4567                                  	; 01/05/2019
  4568 000004D3 26833E[1400]FF          	cmp     word [es:OEM_HANDLER],-1
  4569 000004D9 7504                    	JNE     short OEM_JMP
  4570 000004DB 07                      	pop	es ; *
  4571 000004DC E906FE                  	JMP     BADCALL                 ; Handler not initialized
  4572                                  OEM_JMP:
  4573 000004DF 06                      	push	es
  4574 000004E0 1F                      	pop	ds ; DOSDATA segment !
  4575 000004E1 07                      	pop	es ; *
  4576                                  
  4577                                  	; 22/12/2022
  4578 000004E2 FB                      	sti	; (enable interrupts before jumping to private handler)  
  4579                                  
  4580 000004E3 FF2E[1400]              	JMP     FAR [OEM_HANDLER]
  4581                                  
  4582                                  ;       ENDIF
  4583                                  
  4584                                  ; ---------------------------------------------------------------------------
  4585                                  
  4586                                  ;%endif
  4587                                  
  4588                                  ;============================================================================
  4589                                  ; MCODE.ASM, MSDOS 6.0, 1991
  4590                                  ;============================================================================
  4591                                  ; 17/07/2018 - Retro DOS v3.0
  4592                                  
  4593                                  ;	TITLE	MISC DOS ROUTINES - Int 25 and 26 handlers and other
  4594                                  ;	NAME	IBMCODE
  4595                                  
  4596                                  ;BREAK <NullDev -- Driver for null device>
  4597                                  
  4598                                  ; ROMDOS note:
  4599                                  ;	NUL device driver used to be here, but it was removed and placed in
  4600                                  ;	DOSDATA, because the entry points have to be in the segment as the
  4601                                  ;	header, which is also in DOSDATA.
  4602                                  
  4603                                  ;BREAK <AbsDRD, AbsDWRT -- INT int_disk_read, int_disk_write handlers>
  4604                                  
  4605                                  ;----------------------------------------------------------------------------
  4606                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0, MSDOS.SYS)
  4607                                  ;----------------------------------------------------------------------------
  4608                                  ; DOSCODE:428Ch (MSDOS 6.21 MSDOS.SYS)
  4609                                  ; DOSCODE:427Fh (MSDOS 5.0 MSDOS.SYS)
  4610                                  
  4611                                  ;Public MSC001S,MSC001E
  4612                                  ;MSC001S label byte
  4613                                  	;IF	IBM
  4614                                  ; Codes returned by BIOS
  4615                                  ERRIN:
  4616 000004E7 02                      	DB	2			; NO RESPONSE
  4617 000004E8 06                      	DB	6			; SEEK FAILURE
  4618 000004E9 0C                      	DB	12			; GENERAL ERROR
  4619 000004EA 04                      	DB	4			; BAD CRC
  4620 000004EB 08                      	DB	8			; SECTOR NOT FOUND
  4621 000004EC 00                      	DB	0			; WRITE ATTEMPT ON WRITE-PROTECT DISK
  4622                                  ERROUT:
  4623                                  ; DISK ERRORS RETURNED FROM INT 25 and 26
  4624 000004ED 80                      	DB	80H			; NO RESPONSE
  4625 000004EE 40                      	DB	40H			; Seek failure
  4626 000004EF 02                      	DB	2			; Address Mark not found
  4627 000004F0 10                      	DB	10H			; BAD CRC
  4628 000004F1 04                      	DB	4			; SECTOR NOT FOUND
  4629 000004F2 03                      	DB	3			; WRITE ATTEMPT TO WRITE-PROTECT DISK
  4630                                  
  4631                                  NUMERR	EQU	$-ERROUT
  4632                                  	;ENDIF
  4633                                  ;MSC001E label byte
  4634                                  ;----------------------------------------------------------------------------
  4635                                  
  4636                                  ;============================================================================
  4637                                  ; MSCODE.ASM - MSDOS 6.0 - 1991
  4638                                  ;============================================================================
  4639                                  ; 18/07/2018 - Retro DOS v3.0
  4640                                  ; 15/05/2019 - Retro DOS v4.0
  4641                                  
  4642                                  ;BREAK <AbsDRD, AbsDWRT -- INT int_disk_read, int_disk_write handlers>>
  4643                                  
  4644                                  ;   AbsSetup - setup for abs disk functions
  4645                                  ;----------------------------------------------------------------------------
  4646                                  
  4647                                  AbsSetup:
  4648 000004F3 36FE06[2103]            	INC	byte [SS:INDOS]		; SS override
  4649 000004F8 FB                      	STI
  4650 000004F9 FC                      	CLD
  4651 000004FA 1E                      	PUSH	DS
  4652 000004FB 16                      	push	ss
  4653 000004FC 1F                      	pop	ds
  4654 000004FD E80C01                  	CALL	GETBP
  4655 00000500 7206                    	JC	short errdriv 		; PM. error drive ;AN000;
  4656                                  	;mov	word [es:bp+1Fh]
  4657 00000502 26C7461FFFFF            	MOV	WORD [ES:BP+DPB.FREE_CNT],-1 ; do not trust user at all.
  4658                                  errdriv:
  4659 00000508 1F                      	POP	DS
  4660 00000509 7301                    	jnc	short AbsSetup2
  4661                                  AbsSetup_retn:
  4662 0000050B C3                      	retn
  4663                                  
  4664                                  AbsSetup2:
  4665                                  	; 15/05/2019 - Retro DOS v4.0
  4666                                  	; MSDOS 6.0
  4667                                  					; SS override
  4668 0000050C 36C706[0706]0000        	MOV	word [SS:HIGH_SECTOR],0 ;>32mb	from API		;AN000;
  4669 00000513 E83F04                  	CALL	RW32_CONVERT		;>32mb convert 32bit format to 16bit ;AN000;
  4670 00000516 72F3                    	jc	short AbsSetup_retn
  4671 00000518 E89156                  	call	SET_RQ_SC_PARMS 	;LB. set up SC parms		;AN000;
  4672                                  
  4673                                  	; MSDOS 3.3 (& MSDOS 6.0)
  4674 0000051B 1E                      	PUSH	DS
  4675 0000051C 56                      	PUSH	SI
  4676 0000051D 50                      	PUSH	AX
  4677                                  
  4678 0000051E 16                      	push	ss
  4679 0000051F 1F                      	pop	ds
  4680                                  	
  4681 00000520 BE[BE03]                	MOV	SI,OPENBUF
  4682 00000523 8804                    	MOV	[SI],AL
  4683 00000525 800441                  	ADD	BYTE [SI],"A"
  4684 00000528 C744013A00              	MOV	WORD [SI+1],003AH ; ":",0
  4685 0000052D B80003                  	MOV	AX,0300H
  4686 00000530 F8                      	CLC
  4687 00000531 CD2A                    	INT	int_IBM ; int 2Ah	; Will set carry if shared
  4688                                  		
  4689                                  		; 04/11/2022
  4690                                  		; (INT 2Ah - AX = 0300h)
  4691                                  		; Microsoft Networks - CHECK DIRECT I/O
  4692                                  		; DS:SI -> ASCIIZ disk device name (may be full path or
  4693                                  		;    only drive specifier--must include the colon)
  4694                                  		; Return: CF clear if absolute disk access allowed
  4695                                  
  4696 00000533 58                      	POP	AX
  4697 00000534 5E                      	POP	SI
  4698 00000535 1F                      	POP	DS
  4699 00000536 73D3                    	jnc	short AbsSetup_retn
  4700                                  
  4701                                  	;mov	word [ss:EXTERR],32h
  4702 00000538 36C706[2403]3200        	MOV	word [ss:EXTERR],error_not_supported
  4703 0000053F C3                      	retn
  4704                                  
  4705                                  ;---------------------------------------------------------------------------
  4706                                  ;
  4707                                  ; Procedure Name : ABSDRD
  4708                                  ;
  4709                                  ; Interrupt 25 handler. Performs absolute disk read.
  4710                                  ; Inputs:	AL - 0-based drive number
  4711                                  ;		DS:BX point to destination buffer
  4712                                  ;		CX number of logical sectors to read
  4713                                  ;		DX starting logical sector number (0-based)
  4714                                  ; Outputs:	Original flags still on stack
  4715                                  ;		Carry set
  4716                                  ;		    AH error from BIOS
  4717                                  ;		    AL same as low byte of DI from INT 24
  4718                                  ;
  4719                                  ;---------------------------------------------------------------------------
  4720                                          ;procedure   ABSDRD,FAR
  4721                                  ABSDRD:
  4722                                  	; 15/05/2019 - Retro DOS v4.0
  4723                                  	; MSDOS 6.21 (DOSCODE:42E5h)
  4724                                  	; 04/11/2022
  4725                                  	; MSDOS 5.0 (DOSCODE:42D8h)
  4726                                  	
  4727                                  	; MSDOS 6.0
  4728 00000540 FA                      	CLI
  4729                                  	
  4730                                  ;	set up ds to point to DOSDATA
  4731                                  
  4732 00000541 50                      	push	ax			; preserve AX value
  4733 00000542 8CD8                    	mov	ax,ds			; store DS value in AX
  4734                                  	;getdseg <ds>
  4735 00000544 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  4736 00000549 A3[0A0D]                	mov	[TEMPSEG],ax		; store DS value in TEMPSEG
  4737 0000054C 58                      	pop	ax			; restore AX value
  4738                                  
  4739                                  	; M072:
  4740                                  	; We shall save es on the user stack here. We need to use ES in
  4741                                  	; order to access the DOSDATA variables AbsRdWr_SS/SP at exit 
  4742                                  	; time in order to restore the user stack.
  4743                                  
  4744 0000054D 06                      	push	es  ; ****		; M072
  4745                                  
  4746 0000054E 8C16[1B06]              	MOV	[AbsRdWr_SS],SS		; M013
  4747 00000552 8926[1D06]              	MOV	[AbsRdWr_SP],SP		; M013
  4748                                  
  4749                                  ; 	set up ss to point to DOSDATA
  4750                                  ;
  4751                                  ; NOTE! Due to an obscure bug in the 80286, you cannot use the ROMDOS
  4752                                  ; version of the getdseg macro with the SS register! An interrupt will
  4753                                  ; sneak through.
  4754                                  
  4755                                  ;ifndef ROMDOS
  4756                                  	;getdseg <ss>			; cli in entry of routine
  4757 00000556 2E8E16[0700]            	mov     ss,[cs:DosDSeg]
  4758                                  ;else
  4759                                  ;	mov	ds, cs:[BioDataSeg]
  4760                                  ;	assume	ds:bdata
  4761                                  ;
  4762                                  ;	mov	ss, ds:[DosDataSg]
  4763                                  ;	assume	ss:DOSDATA
  4764                                  ;
  4765                                  ;endif ; ROMDOS
  4766                                  
  4767 0000055B BC[2009]                	MOV	SP,DSKSTACK
  4768                                  
  4769 0000055E 8E1E[0A0D]              	mov	ds,[TEMPSEG]		; restore DS value
  4770                                  
  4771 00000562 06                      	push	es ; *** (MSDOS 6.21)
  4772 00000563 E80BFF                  	call	save_world		; save all regs
  4773                                  
  4774 00000566 06                      	PUSH	ES ; **
  4775 00000567 E889FF                  	CALL	AbsSetup
  4776 0000056A 723D                    	JC	short ILEAVE
  4777                                  
  4778                                  	; Here is a gross temporary fix to get around a serious design flaw in
  4779                                  	;  the secondary cache. The secondary cache does not check for media
  4780                                  	;  changed (it should). Hence, you can change disks, do an absolute
  4781                                  	;  read, and get data from the previous disk. To get around this,
  4782                                  	;  we just won't use the secondary cache for absolute disk reads.
  4783                                  	;                                                      -mw 8/5/88
  4784                                  
  4785                                  	;EnterCrit critDisk
  4786 0000056C E8E80D                  	call	ECritDisk
  4787 0000056F 36C606[B00D]FF          	MOV	byte [ss:CurSC_DRIVE],-1 ; invalidate SC  ;AN000;
  4788                                  	;LeaveCrit critDisk
  4789 00000575 E8FA0D                  	call	LCritDisk
  4790                                  
  4791                                          ;invoke	DSKREAD
  4792 00000578 E84A32                  	CALL	DSKREAD
  4793 0000057B 7513                            jnz	short ERR_LEAVE		;Jump if read unsuccessful.
  4794                                  
  4795 0000057D 89F9                            mov     cx,di
  4796 0000057F 368C1E[0E06]                    mov     [ss:TEMP_VAR2],ds
  4797 00000584 36891E[0C06]                    mov     [ss:TEMP_VAR],bx
  4798                                  
  4799                                  ;       CX = # of contiguous sectors read. (These constitute a block of
  4800                                  ;            sectors, also termed an "Extent".)
  4801                                  ;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
  4802                                  ;       [TEMP_VAR2]:[TEMP_VAR] = Transfer address (destination data address).
  4803                                  ;       ES:BP -> Drive Parameter Block (DPB).
  4804                                  ;
  4805                                  ;	The Buffer Queue must now be scanned: the contents of any dirty
  4806                                  ;	buffers must be "read" into the transfer memory block, so that the
  4807                                  ;       transfer memory reflects the most recent data.
  4808                                  
  4809                                  	;invoke	DskRdBufScan		;This trashes DS, but don't care.
  4810 00000589 E88934                          call	DskRdBufScan
  4811 0000058C EB1B                    	jmp     short ILEAVE
  4812                                  
  4813                                  TLEAVE:
  4814 0000058E 7419                    	JZ	short ILEAVE
  4815                                  
  4816                                  ERR_LEAVE:				; M039
  4817                                  	; 15/07/2018 - Retro DOS v3.0
  4818                                          ;IF	IBM
  4819                                  ; Translate the error code to ancient 1.1 codes
  4820 00000590 06                              PUSH    ES ; *
  4821 00000591 0E                              PUSH    CS
  4822 00000592 07                              POP     ES
  4823 00000593 30E4                            XOR     AH,AH			; Nul error code
  4824                                  	;mov	cx,6
  4825 00000595 B90600                          MOV     CX,NUMERR		; Number of possible error conditions
  4826 00000598 BF[E704]                        MOV     DI,ERRIN		; Point to error conditions
  4827 0000059B F2AE                            REPNE   SCASB
  4828 0000059D 7504                            JNZ     SHORT LEAVECODE		; Not found
  4829                                  	;mov	ah,[ES:DI+5]
  4830 0000059F 268A6505                        MOV     AH,[ES:DI+NUMERR-1]	; Get translation
  4831                                  LEAVECODE:
  4832 000005A3 07                              POP     ES ; *
  4833                                  	; 15/05/2019 - Retro DOS v4.0
  4834 000005A4 36A3[B80D]              	mov	[ss:AbsDskErr],ax
  4835                                          ;ENDIF
  4836                                  
  4837 000005A8 F9                              STC
  4838                                  ILEAVE:
  4839                                  	; 15/05/2019
  4840 000005A9 07                              POP     ES ; **
  4841 000005AA E8ADFE                  	call	restore_world
  4842 000005AD 07                              pop	es ; *** (MSDOS 6.21)
  4843 000005AE FA                      	CLI
  4844 000005AF 36A1[B80D]              	mov     ax,[ss:AbsDskErr]	; restore error
  4845 000005B3 36FE0E[2103]            	DEC	BYTE [SS:INDOS]
  4846 000005B8 16                              push	ss			; M072 - Start
  4847 000005B9 07                      	pop	es			; es - dosdata
  4848 000005BA 268E16[1B06]                    mov	ss,[es:AbsRdWr_SS]	; M013
  4849 000005BF 268B26[1D06]            	mov	sp,[es:AbsRdWr_SP]	; M013
  4850 000005C4 07                      	pop	es  ; ****		; Note es was saved on user
  4851                                  					; stack at entry 
  4852                                  					; M072 - End
  4853 000005C5 FB                              STI
  4854 000005C6 CB                      	RETF   ; ! FAR return !
  4855                                  
  4856                                  ;ABSDRD	ENDP
  4857                                  
  4858                                  ;---------------------------------------------------------------------------
  4859                                  ;
  4860                                  ; Procedure Name : ABSDWRT
  4861                                  ;
  4862                                  ; Interrupt 26 handler. Performs absolute disk write.
  4863                                  ; Inputs:	AL - 0-based drive number
  4864                                  ;		DS:BX point to source buffer
  4865                                  ;		CX number of logical sectors to write
  4866                                  ;		DX starting logical sector number (0-based)
  4867                                  ; Outputs:	Original flags still on stack
  4868                                  ;		Carry set
  4869                                  ;		    AH error from BIOS
  4870                                  ;		    AL same as low byte of DI from INT 24
  4871                                  ;
  4872                                  ;---------------------------------------------------------------------------
  4873                                          ;procedure   ABSDWRT,FAR
  4874                                  ABSDWRT:
  4875                                  	; 15/05/2019 - Retro DOS v4.0
  4876                                  	; MSDOS 6.21 (DOSCODE:436Ch)
  4877                                  	; 04/11/2022
  4878                                  	; MSDOS 5.0 (DOSCODE:435Fh)
  4879                                  
  4880 000005C7 FA                      	CLI
  4881                                  
  4882                                  ;	set up ds to point to DOSDATA
  4883                                  
  4884 000005C8 50                      	push	ax
  4885 000005C9 8CD8                    	mov	ax,ds
  4886                                  	;getdseg <ds>
  4887 000005CB 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  4888 000005D0 A3[0A0D]                	mov	[TEMPSEG],ax
  4889 000005D3 58                      	pop	ax
  4890                                  
  4891                                  	; M072:
  4892                                  	; We shall save es on the user stack here. We need to use ES in
  4893                                  	; order to access the DOSDATA variables AbsRdWr_SS/SP at exit 
  4894                                  	; time in order to restore the user stack.
  4895                                  
  4896 000005D4 06                      	push	es ; ****		; M072
  4897                                  
  4898 000005D5 8C16[1B06]              	MOV	[AbsRdWr_SS],SS		; M013
  4899 000005D9 8926[1D06]              	MOV	[AbsRdWr_SP],SP		; M013
  4900                                  
  4901                                  	; set up ss to point to DOSDATA
  4902                                  	;
  4903                                  	; NOTE! Due to an obscure bug in the 80286, you cannot use the 
  4904                                  	; ROMDOS version of the getdseg macro with the SS register!
  4905                                  	; An interrupt will sneak through.
  4906                                  
  4907                                  ;ifndef ROMDOS
  4908                                  	;getdseg <ss>			; cli in entry of routine
  4909 000005DD 2E8E16[0700]            	mov     ss,[cs:DosDSeg]
  4910                                  ;else
  4911                                  ;	mov	ds, cs:[BioDataSeg]
  4912                                  ;	assume	ds:bdata
  4913                                  ;
  4914                                  ;	mov	ss, ds:[DosDataSg]
  4915                                  ;	assume	ss:DOSDATA
  4916                                  ;
  4917                                  ;endif ; ROMDOS
  4918                                  
  4919 000005E2 BC[2009]                	MOV	SP,DSKSTACK
  4920                                  		; we are now switched to DOS's disk stack
  4921                                  
  4922 000005E5 8E1E[0A0D]              	mov	ds,[TEMPSEG]		; restore user's ds
  4923                                  
  4924 000005E9 06                      	push	es ; *** (MSDOS 6.21)
  4925                                  
  4926 000005EA E884FE                  	call	save_world	      	; save all regs
  4927                                  
  4928 000005ED 06                      	PUSH	ES ; **
  4929 000005EE E802FF                  	CALL	AbsSetup
  4930 000005F1 72B6                    	JC	short ILEAVE
  4931                                  
  4932                                  	;EnterCrit critDisk
  4933 000005F3 E8610D                  	call	ECritDisk
  4934 000005F6 36C606[B00D]FF          	MOV	byte [ss:CurSC_DRIVE],-1 ; invalidate SC ;AN000;
  4935 000005FC E89C03                  	CALL	Fastxxx_Purge		 ; purge fatopen ;AN000;
  4936                                  	;LeaveCrit critDisk
  4937 000005FF E8700D                  	call	LCritDisk
  4938                                  
  4939                                  ;M039
  4940                                  ;       DS:BX = transfer address (source data address).
  4941                                  ;       CX = # of contiguous sectors to write. (These constitute a block of
  4942                                  ;	     sectors, also termed an "Extent".)
  4943                                  ;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
  4944                                  ;       ES:BP -> Drive Parameter Block (DPB).
  4945                                  ;       [CURSC_DRIVE] = -1 (invalid drive).
  4946                                  ;
  4947                                  ;       Free any buffered sectors which are in Extent; they are being over-
  4948                                  ;       written. Note that all the above registers are preserved for
  4949                                  ;       DSKWRITE.
  4950                                  
  4951 00000602 1E                              push    ds
  4952                                  	;invoke	DskWrtBufPurge          ;This trashes DS.
  4953 00000603 E82637                  	call	DskWrtBufPurge
  4954 00000606 1F                              pop     ds
  4955                                  ;M039
  4956                                  	;invoke	DSKWRITE
  4957 00000607 E8E431                  	call	DSKWRITE
  4958 0000060A EB82                    	JMP	short TLEAVE
  4959                                  
  4960                                  ;ABSDWRT ENDP
  4961                                  
  4962                                  ;----------------------------------------------------------------------------
  4963                                  ;
  4964                                  ; Procedure Name : GETBP
  4965                                  ;
  4966                                  ; Inputs:
  4967                                  ;	AL = Logical unit number (A = 0)
  4968                                  ; Function:
  4969                                  ;	Find Drive Parameter Block
  4970                                  ; Outputs:
  4971                                  ;	ES:BP points to DPB
  4972                                  ;	[THISDPB] = ES:BP
  4973                                  ;	Carry set if unit number bad or unit is a NET device.
  4974                                  ;		Later case sets extended error error_I24_not_supported
  4975                                  ; No other registers alteredjjj
  4976                                  ;
  4977                                  ;----------------------------------------------------------------------------
  4978                                  
  4979                                  	; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  4980                                  GETBP:
  4981                                  	; 15/05/2019 - Retro DOS v4.0
  4982                                  	; 11/07/2018 - Retro DOS v3.0
  4983 0000060C 50                      	PUSH	AX
  4984 0000060D 0401                    	ADD	AL, 1		; No increment; need carry flag
  4985 0000060F 7216                    	JC	SHORT SKIPGET
  4986 00000611 E8F064                  	CALL	GETTHISDRV
  4987                                  	; MSDOS 6.0
  4988 00000614 7311                    	JNC	SHORT SKIPGET		;PM. good drive		;AN000;
  4989 00000616 30E4                    	XOR	AH,AH			;DCR. ax= error code 	;AN000;
  4990 00000618 83F81A                  	CMP	AX,error_not_DOS_disk	;DCR. is unknown media ? ;AN000;
  4991 0000061B 740A                    	JZ	SHORT SKIPGET 		;DCR. yes, let it go 	;AN000;
  4992 0000061D F9                      	STC				;DCR.			;AN000;
  4993 0000061E A3[2403]                	MOV	[EXTERR],AX	;PM. invalid drive or Non DOS drive ;AN000;
  4994 00000621 C706[B80D]0102          	MOV	WORD [AbsDskErr],201h
  4995                                  SKIPGET:
  4996 00000627 58                      	POP	AX
  4997 00000628 7212                    	JC	SHORT GETBP_RETN ; 15/12/2022
  4998                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  4999                                  	;jnc	short getbp_t
  5000                                  	;retn
  5001                                  getbp_t:
  5002 0000062A C42E[A205]              	LES	BP,[THISCDS]
  5003                                  	; 15/12/2022
  5004 0000062E 26F6464480              	test	byte [es:bp+curdir.flags+1],curdir_isnet>>8
  5005                                  	; 07/12/2022
  5006                                  	;TEST	WORD [ES:BP+43H],8000H
  5007                                  	;TEST	WORD [ES:BP+curdir.flags],curdir_isnet ; Clears carry
  5008 00000633 7408                    	JZ	SHORT GETBP_CDS
  5009 00000635 C706[2403]3200          	MOV	WORD [EXTERR],error_not_supported  ; 32h
  5010 0000063B F9                      	STC
  5011                                  GETBP_RETN:
  5012 0000063C C3                      	RETN
  5013                                  
  5014                                  GETBP_CDS:
  5015                                  	;LES	BP,[ES:BP+45H]
  5016 0000063D 26C46E45                	LES	BP,[ES:BP+curdir.devptr]
  5017                                  GOTDPB:
  5018                                  	; Load THISDPB from ES:BP
  5019 00000641 892E[8A05]              	MOV	[THISDPB],BP
  5020 00000645 8C06[8C05]              	MOV	[THISDPB+2],ES
  5021 00000649 C3                      	RETN
  5022                                  
  5023                                  ;BREAK <SYS_RET_OK SYS_RET_ERR CAL_LK ETAB_LK set system call returns>
  5024                                  
  5025                                  ;----------------------------------------------------------------------------
  5026                                  ;
  5027                                  ; Procedure Name : SYS_RETURN
  5028                                  ;
  5029                                  ; These are the general system call exit mechanisms. All internal system
  5030                                  ; calls will transfer (jump) to one of these at the end. Their sole purpose
  5031                                  ; is to set the user's flags and set his AX register for return.
  5032                                  ;
  5033                                  ;----------------------------------------------------------------------------
  5034                                  
  5035                                          ;procedure   SYS_RETURN,NEAR
  5036                                  SYS_RETURN:        
  5037                                          ;entry	SYS_RET_OK
  5038                                  SYS_RET_OK:   
  5039 0000064A E843FE                  	call    Get_User_Stack
  5040                                  		; turn off user's carry flag
  5041                                  SYS_RET_OK_clc: ; 25/06/2019 
  5042                                          ;;and	word [SI+16h],0FFFEh 
  5043                                  	;and	word [SI+user_env.user_F],~f_Carry 
  5044                                          ; 25/06/2019
  5045 0000064D 806416FE                	and	byte [SI+user_env.user_F],~f_Carry ; 0FEh
  5046 00000651 EB10                    	JMP     SHORT DO_RET
  5047                                  
  5048                                          ;entry   SYS_RET_ERR
  5049                                  SYS_RET_ERR:        
  5050 00000653 30E4                    	XOR     AH,AH 		; hack to allow for smaller error rets
  5051 00000655 E86C00                  	call	ETAB_LK 	; Make sure code is OK, EXTERR gets set
  5052 00000658 E81A00                  	CALL	ErrorMap
  5053                                  
  5054                                  	;entry	From_GetSet
  5055                                  From_GetSet:
  5056 0000065B E832FE                          call    Get_User_Stack
  5057                                  		 ; signal carry to user
  5058                                  	;;or	word [SI+16h],1
  5059                                  	;OR	word [SI+user_env.user_F],f_Carry
  5060                                  	; 25/06/2019
  5061 0000065E 804C1601                	or	byte [SI+user_env.user_F],f_Carry
  5062 00000662 F9                      	STC			; also, signal internal error
  5063                                  DO_RET:
  5064                                          ;MOV	[SI+user_env.user_AX],AX ; Really only sets AH
  5065 00000663 8904                    	MOV	[SI],AX
  5066 00000665 C3                      	RETN
  5067                                  
  5068                                  	;entry	FCB_RET_OK
  5069                                  FCB_RET_OK:
  5070                                  	;entry	NO_OP		; obsolete system calls dispatch to here
  5071                                  NO_OP:
  5072 00000666 30C0                    	XOR	AL,AL
  5073 00000668 C3                      	retn
  5074                                  
  5075                                  	;entry	FCB_RET_ERR
  5076                                  FCB_RET_ERR:
  5077 00000669 30E4                    	XOR	AH,AH
  5078 0000066B 36A3[2403]              	mov	[ss:EXTERR],AX
  5079 0000066F E80300                  	CALL	ErrorMap
  5080 00000672 B0FF                    	MOV	AL,-1
  5081 00000674 C3                      	retn
  5082                                  
  5083                                  	;entry	ErrorMap
  5084                                  ErrorMap:
  5085 00000675 56                      	PUSH	SI
  5086                                  				; ERR_TABLE_21 is now in DOSDATA
  5087 00000676 BE[DA0D]                	MOV	SI,ERR_TABLE_21
  5088                                  				; SS override for FAILERR and EXTERR
  5089 00000679 36803E[4A03]00          	CMP	byte [SS:FAILERR],0 ; Check for SPECIAL case.
  5090 0000067F 7407                    	JZ	short EXTENDED_NORMAL ; All is OK.
  5091                                  		 ; Ooops, this is the REAL reason
  5092                                  	;mov	word [SS:EXTERR],53h
  5093 00000681 36C706[2403]5300        	MOV	word [SS:EXTERR],error_FAIL_I24
  5094                                  EXTENDED_NORMAL:
  5095 00000688 E80200                  	call	CAL_LK		; Set CLASS,ACTION,LOCUS for EXTERR
  5096 0000068B 5E                      	POP	SI
  5097 0000068C C3                      	retn
  5098                                  
  5099                                  	;EndProc SYS_RETURN
  5100                                  
  5101                                  ;---------------------------------------------------------------------------
  5102                                  ;
  5103                                  ; Procedure Name : CAL_LK
  5104                                  ;
  5105                                  ; Inputs:
  5106                                  ;	SI is OFFSET in DOSDATA of CLASS,ACTION,LOCUS Table to use
  5107                                  ;		(DS NEED not be DOSDATA)
  5108                                  ;	[EXTERR] is set with error
  5109                                  ; Function:
  5110                                  ;	Look up and set CLASS ACTION and LOCUS values for GetExtendedError
  5111                                  ; Outputs:
  5112                                  ;	[EXTERR_CLASS] set
  5113                                  ;	[EXTERR_ACTION] set
  5114                                  ;	[EXTERR_LOCUS] set  (EXCEPT on certain errors as determined by table)
  5115                                  ; Destroys SI, FLAGS
  5116                                  ;
  5117                                  ;---------------------------------------------------------------------------
  5118                                  
  5119                                  	;procedure CAL_LK,NEAR
  5120                                  CAL_LK:
  5121 0000068D 1E                      	PUSH	DS
  5122 0000068E 50                      	PUSH	AX
  5123 0000068F 53                      	PUSH	BX
  5124                                  
  5125                                  ;M048	Context DS		; DS:SI -> Table
  5126                                  ;
  5127                                  ; Since this function can be called thru int 2f we shall not assume that SS
  5128                                  ; is DOSDATA
  5129                                  
  5130                                  	;getdseg  <ds>	; M048: DS:SI -> Table
  5131                                  	; 15/05/2019 - Retro DOS v4.0
  5132 00000690 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  5133                                  
  5134                                  	; 18/07/2018
  5135                                  	;push	ss
  5136                                  	;pop	ds
  5137                                  
  5138 00000695 8B1E[2403]              	MOV	BX,[EXTERR]	; Get error in BL
  5139                                  TABLK1:
  5140 00000699 AC                      	LODSB
  5141                                  
  5142 0000069A 3CFF                    	CMP	AL,0FFH
  5143 0000069C 7409                    	JZ	short GOT_VALS	; End of table
  5144 0000069E 38D8                    	CMP	AL,BL
  5145 000006A0 7405                    	JZ	short GOT_VALS	; Got entry
  5146 000006A2 83C603                  	ADD	SI,3		; Next table entry
  5147                                  	; 15/08/2018
  5148 000006A5 EBF2                    	JMP	short TABLK1
  5149                                  
  5150                                  GOT_VALS:
  5151 000006A7 AD                      	LODSW			; AL is CLASS, AH is ACTION
  5152                                  
  5153 000006A8 80FCFF                  	CMP	AH,0FFH
  5154 000006AB 7404                    	JZ	short NO_SET_ACT
  5155 000006AD 8826[2603]              	MOV	[EXTERR_ACTION],AH ; Set ACTION
  5156                                  NO_SET_ACT:
  5157 000006B1 3CFF                    	CMP	AL,0FFH
  5158 000006B3 7403                    	JZ	short NO_SET_CLS
  5159 000006B5 A2[2703]                	MOV	[EXTERR_CLASS],AL ; Set CLASS
  5160                                  NO_SET_CLS:
  5161 000006B8 AC                      	LODSB			; Get LOCUS
  5162                                  
  5163 000006B9 3CFF                    	CMP	AL,0FFH
  5164 000006BB 7403                    	JZ	short NO_SET_LOC
  5165 000006BD A2[2303]                	MOV	[EXTERR_LOCUS],AL
  5166                                  NO_SET_LOC:
  5167 000006C0 5B                      	POP	BX
  5168 000006C1 58                      	POP	AX
  5169 000006C2 1F                      	POP	DS
  5170 000006C3 C3                      	retn
  5171                                  
  5172                                  	;EndProc CAL_LK
  5173                                  
  5174                                  ;---------------------------------------------------------------------------
  5175                                  ;
  5176                                  ; Procedure Name : ETAB_LK
  5177                                  ;
  5178                                  ; Inputs:
  5179                                  ;	AX is error code
  5180                                  ;	[USER_IN_AX] has AH value of system call involved
  5181                                  ; Function:
  5182                                  ;	Make sure error code is appropriate to this call.
  5183                                  ; Outputs:
  5184                                  ;	AX MAY be mapped error code
  5185                                  ;	[EXTERR] = Input AX
  5186                                  ; Destroys ONLY AX and FLAGS
  5187                                  ;
  5188                                  ;---------------------------------------------------------------------------
  5189                                  
  5190                                  	;procedure ETAB_LK,NEAR
  5191                                  
  5192                                  ETAB_LK: ; 10/08/2018 - Retro DOS v3.0
  5193 000006C4 1E                      	PUSH	DS
  5194 000006C5 56                      	PUSH	SI
  5195 000006C6 51                      	PUSH	CX
  5196 000006C7 53                      	PUSH	BX
  5197                                  
  5198                                  	;Context DS			; SS is DOSDATA
  5199                                  
  5200 000006C8 16                      	push	ss
  5201 000006C9 1F                      	pop	ds
  5202                                  
  5203 000006CA A3[2403]                	MOV	[EXTERR],AX		; Set EXTERR with "real" error
  5204                                  
  5205                                  					; I21_MAP_E_TAB is now in DOSCODE
  5206 000006CD BE[0B00]                	MOV	SI,I21_MAP_E_TAB
  5207 000006D0 88C7                    	MOV	BH,AL			; Real code to BH
  5208 000006D2 8A1E[3B03]              	MOV	BL,[USER_IN_AX+1]	; Sys call to BL
  5209                                  TABLK2:
  5210                                  	; 15/05/2019 - Retro DOS v4.0
  5211 000006D6 2E                      	cs
  5212 000006D7 AD                      	lodsw	; MSDOS 6.0 (MSDOS 6.21 - MSDOS.SYS, DOSCODE:447Dh)
  5213                                  	
  5214                                  	; 18/07/2018 - Retro DOS v3.0
  5215                                  	;lodsw		; IBMDOS.COM (MSDOS 3.3) - Offset 16F7h
  5216                                  
  5217 000006D8 3CFF                    	CMP	AL,0FFH 		; End of table?
  5218 000006DA 740C                    	JZ	short NOT_IN_TABLE	; Yes
  5219 000006DC 38D8                    	CMP	AL,BL			; Found call?
  5220 000006DE 740C                    	JZ	short GOT_CALL		; Yes
  5221 000006E0 86E0                    	XCHG	AH,AL			; Count to AL
  5222 000006E2 30E4                    	XOR	AH,AH			; Make word for add
  5223 000006E4 01C6                    	ADD	SI,AX			; Next table entry
  5224 000006E6 EBEE                    	JMP	short TABLK2
  5225                                  
  5226                                  NOT_IN_TABLE:
  5227 000006E8 88F8                    	MOV	AL,BH			; Restore original code
  5228 000006EA EB0C                    	JMP	SHORT NO_MAP
  5229                                  
  5230                                  GOT_CALL:
  5231 000006EC 88E1                    	MOV	CL,AH
  5232 000006EE 30ED                    	XOR	CH,CH			; Count of valid err codes to CX
  5233                                  CHECK_CODE:
  5234                                  	; 15/05/2019 - Retro DOS v4.0
  5235 000006F0 2E                      	cs
  5236 000006F1 AC                      	lodsb	; MSDOS 6.0 (MSDOS 6.21 - MSDOS.SYS, DOSCODE:4497h)
  5237                                  
  5238                                  	; 18/07/2018
  5239                                  	;lodsb		; IBMDOS.COM (MSDOS 3.3) - Offset 1710h
  5240                                  
  5241 000006F2 38F8                    	CMP	AL,BH			; Code OK?
  5242 000006F4 7402                    	JZ	short NO_MAP		; Yes
  5243 000006F6 E2F8                    	LOOP	CHECK_CODE
  5244                                  NO_MAP:
  5245 000006F8 30E4                    	XOR	AH,AH			; AX is now valid code
  5246 000006FA 5B                      	POP	BX
  5247 000006FB 59                      	POP	CX
  5248 000006FC 5E                      	POP	SI
  5249 000006FD 1F                      	POP	DS
  5250 000006FE C3                      	retn
  5251                                  
  5252                                  	;EndProc ETAB_LK
  5253                                  
  5254                                  ; 18/07/2018 - Retro DOS v3.0
  5255                                  ;---------------------------------------------------------------------------
  5256                                  ; BREAK <DOS 2F Handler and default NET 2F handler>
  5257                                  
  5258                                  ;IF installed ; (*)
  5259                                  
  5260                                  ;---------------------------------------------------------------------------
  5261                                  ;
  5262                                  ; Procedure Name : SetBad
  5263                                  ;
  5264                                  ; SetBad sets up info for bad functions
  5265                                  ;
  5266                                  ;---------------------------------------------------------------------------
  5267                                  
  5268                                  SetBad:
  5269                                  	;mov	ax,1
  5270 000006FF B80100                  	MOV	AX,error_invalid_function ; ALL NET REQUESTS get inv func
  5271                                  
  5272                                  	; MSDOS 3.3
  5273                                  	;;mov	byte [cs:EXTERR_LOCUS],1
  5274                                  	;MOV	byte [CS:EXTERR_LOCUS],errLOC_Unk
  5275                                  
  5276                                  ;	set up ds to point to DOSDATA
  5277                                  
  5278                                  	; 15/05/2019 - Retro DOS v4.0
  5279                                  	; MSDOS 6.0
  5280 00000702 1E                      	push	ds
  5281                                  
  5282                                  	;getdseg <ds>
  5283 00000703 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  5284                                  
  5285 00000708 C606[2303]01            	MOV	byte [EXTERR_LOCUS],errLOC_Unk ; 1	
  5286                                  
  5287 0000070D 1F                      	pop	ds	  	;hkn; restore ds
  5288                                  
  5289 0000070E F9                      	STC
  5290 0000070F C3                      	retn
  5291                                  
  5292                                  ;--------------------------------------------------------------------------
  5293                                  ;
  5294                                  ; Procedure Name : BadCall
  5295                                  ;
  5296                                  ; BadCall is the initial routine for bad function calls
  5297                                  ;
  5298                                  ;--------------------------------------------------------------------------
  5299                                  
  5300                                  BadCall:
  5301 00000710 E8ECFF                  	call	SetBad
  5302 00000713 CB                      	retf
  5303                                  
  5304                                  ;--------------------------------------------------------------------------
  5305                                  ;
  5306                                  ; OKCall always sets carry to off.
  5307                                  ;
  5308                                  ;-----------------------------------------------------------------------
  5309                                  
  5310                                  OKCall:
  5311 00000714 F8                      	CLC
  5312 00000715 CB                      	retf
  5313                                  
  5314                                  ;---------------------------------------------------------------------------
  5315                                  ;
  5316                                  ; Procedure Name : INT2F
  5317                                  ;
  5318                                  ; INT 2F handler works as follows:
  5319                                  ;   PUSH    AX
  5320                                  ;   MOV     AX,multiplex:function
  5321                                  ;   INT     2F
  5322                                  ;   POP     ...
  5323                                  ; The handler itself needs to make the AX available for the various routines.
  5324                                  ;
  5325                                  ;----------------------------------------------------------------------------
  5326                                  
  5327                                  ; 15/05/2019 - Retro DOS v4.0
  5328                                  
  5329                                  ;KERNEL_SEGMENT equ 70h
  5330                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  5331                                  DOSBIODATASEG equ 70h
  5332                                  
  5333                                  ; retrodos4.s - offset in BIOSDATA
  5334                                  bios_i2f equ 5
  5335                                  
  5336                                  ;PUBLIC	Int2F
  5337                                  ;INT2F	PROC	FAR
  5338                                  
  5339                                  ; 15/05/2019
  5340                                  ; DOSCODE:44BDh (MSDOS 6.21, MSDOS.SYS)
  5341                                  
  5342                                  ; 04/11/2022
  5343                                  ; DOSCODE:44B0h (MSDOS 5.0, MSDOS.SYS)
  5344                                  
  5345                                  	; 15/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  5346                                  	; 18/07/2018 - Retro DOS v3.0
  5347                                  INT2F:
  5348                                  	; Offset 172Fh in IBMDOS.COM (MSDOS 3.3), 1987
  5349                                  INT2FNT:
  5350                                  	;ASSUME	CS:DOSCODE,DS:NOTHING,ES:NOTHING,SS:NOTHING
  5351 00000716 FB                      	STI
  5352                                  	;cmp	ah,11h
  5353 00000717 80FC11                  	CMP	AH,MultNET
  5354 0000071A 750A                    	JNZ	short INT2FSHR
  5355                                  TestInstall:
  5356 0000071C 08C0                    	OR	AL,AL
  5357 0000071E 7403                    	JZ	short Leave2F
  5358                                  BadFunc:
  5359 00000720 E8DCFF                  	CALL	SetBad
  5360                                  
  5361                                  	;entry	Leave2F
  5362                                  Leave2F:
  5363 00000723 CA0200                  	RETF	2			; long return + clear flags off stack
  5364                                  
  5365                                  INT2FSHR:
  5366                                  	;cmp	ah,10h
  5367 00000726 80FC10                  	CMP	AH,MultSHARE		; is this a share request
  5368 00000729 74F1                    	JZ	short TestInstall	; yes, check for installation
  5369                                  INT2FNLS:
  5370                                  	;cmp	ah,14h
  5371 0000072B 80FC14                  	CMP	AH,NLSFUNC		; is this a DOS 3.3 NLSFUNC request
  5372 0000072E 74EC                    	JZ	short TestInstall	; yes check for installation
  5373                                  INT2FDOS:
  5374                                  	;ASSUME	CS:DOSCODE,DS:NOTHING,ES:NOTHING,SS:NOTHING
  5375                                  
  5376                                  	; 18/07/2018
  5377                                  	; MSDOS 3.3
  5378                                  	;;cmp	ah,12h	
  5379                                  	;CMP	AH,MultDOS
  5380                                  	;jz	short DispatchDOS
  5381                                  	;iret
  5382                                  
  5383                                  	; 15/05/2019
  5384                                  	; MSDOS 6.0
  5385                                  	;cmp	ah,12h	; 07/12/2022
  5386 00000730 80FC12                  	CMP	AH,MultDOS
  5387 00000733 7503                    	JNZ	short check_win		;check if win386 broadcast
  5388 00000735 E9FC01                  	jmp	DispatchDOS
  5389                                  
  5390                                  	; .... win386 .... 
  5391                                  
  5392                                  check_win:
  5393                                  	;cmp	ah,16h
  5394 00000738 80FC16                  	cmp	ah,MultWin386		; Is this a broadcast from Win386?
  5395 0000073B 7408                    	je	short Win386_Msg
  5396                                  
  5397                                  	; M044
  5398                                  	; Check if the callout is from Winoldap indicating swapping out or in 
  5399                                  	; of Windows. If so, do special action of going and saving last para
  5400                                  	; of the Windows memory arena which Winoldap does not save due to a 
  5401                                  	; bug
  5402                                  
  5403 0000073D 80FC46                  	cmp	ah,WINOLDAP ; 46h	; from Winoldap?
  5404                                  	;jne	short next_i2f		; no, chain on
  5405                                  	; 15/12/2022
  5406                                  	;jmp	winold_swap		; yes, do desired action
  5407 00000740 7442                    	je	short winold_swap
  5408 00000742 E90701                  	jmp	next_i2f
  5409                                  
  5410                                  	; 15/12/2022
  5411                                  ;next_i2f:
  5412                                  ;	;;;jmp	bios_i2f
  5413                                  ;	;;jmp	far ptr 70h:5 ; MSDOS 6.21 (MSDOS.SYS, DOSCODE:44F1h)
  5414                                  ;	;jmp	KERNEL_SEGMENT:bios_i2f
  5415                                  ;	; 04/11/2022
  5416                                  ;	jmp	DOSBIODATASEG:bios_i2f
  5417                                  
  5418                                  ;	IRET				; This assume that we are at the head
  5419                                  					; of the list
  5420                                  ;INT2F	ENDP
  5421                                  
  5422                                  ; 15/05/2019 - Retro DOS v4.0
  5423                                  
  5424                                  ; We have received a message from Win386. There are three possible
  5425                                  ; messages we could get from Win386:
  5426                                  ;
  5427                                  ; Init 		- for this, we set the IsWin386 flag and return a pointer
  5428                                  ;		  to the Win386 startup info structure.
  5429                                  ; Exit		- for this, we clear the IsWin386 flag.
  5430                                  ; DOSMGR query 	- for this, we need to indicate that instance data
  5431                                  ;		  has already been handled. this is indicated by setting
  5432                                  ;		  CX to a non-zero value.
  5433                                  
  5434                                  Win386_Msg:
  5435 00000745 1E                      	push	ds
  5436                                  
  5437                                  	;getdseg <DS>			; ds is DOSDATA
  5438 00000746 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  5439                                  
  5440                                  	; For WIN386 2.xx instance data
  5441                                  
  5442 0000074B 3C03                    	cmp	al,3			; win386 2.xx instance data call?
  5443 0000074D 7503                    	jne	short Win386_Msg_exit
  5444 0000074F E92C01                  	jmp	OldWin386Init		; yes, return instance data
  5445                                  Win386_Msg_exit:
  5446 00000752 3C06                    	cmp	al,Win386_Exit	 ; 6	; is it an exit call?
  5447 00000754 7503                    	jne	short Win386_Msg_devcall
  5448 00000756 E92E01                  	jmp	Win386_Leaving
  5449                                  Win386_Msg_devcall:
  5450 00000759 3C07                    	cmp	al,Win386_Devcall ; 7	; is it call from DOSMGR?
  5451 0000075B 7503                    	jne	short Win386_Msg_init
  5452 0000075D E96501                  	jmp	Win386_Query
  5453                                  Win386_Msg_init:
  5454 00000760 3C05                    	cmp	al,Win386_Init	; 5	; is it an init call?
  5455 00000762 7403                    	je	short Win386_Starting
  5456 00000764 E9E400                  	jmp	win_nexti2f		; no, return
  5457                                  Win386_Starting:
  5458                                  	; 17/12/2022
  5459 00000767 F6C201                  	test	dl,1
  5460                                  	;test	dx,1			; is this really win386?
  5461 0000076A 7403                    	jz	short Win386_vchk	; YES! go and handle it
  5462 0000076C E9DC00                  	jmp	win_nexti2f		; NO! It's win 286 dos extender! M002
  5463                                  Win386_vchk:
  5464                                  	; M018 -- start of block changes
  5465                                  	; The VxD needs to be loaded only for Win 3.0. If version is greater 
  5466                                  	; than 030Ah, we skip the VxD presence check
  5467                                  
  5468                                  ;M067 -- Begin changes
  5469                                  ; If Win 3.0 is run, the VxD ptr has been initialized. If Win 3.1 is now
  5470                                  ;run, it tries to unnecesarily load the VxD even though it is not needed.
  5471                                  ;So, we null out the VxD ptr before the check.
  5472                                  
  5473                                  	;mov	word [Win386_Info+6],0
  5474 0000076F C706[E70F]0000          	mov	word [Win386_Info+Win386_SIS.Virt_Dev_File_Ptr],0
  5475                                  	;mov	word [Win386_Info+8],0
  5476 00000775 C706[E90F]0000          	mov	word [Win386_Info+Win386_SIS.Virt_Dev_File_Ptr+2],0
  5477                                  
  5478                                  ;M067 -- End changes
  5479                                  
  5480                                  ;ifdef JAPAN
  5481                                  ;	cmp	di,0300h		; version >= 300 i.e 3.10 ;M037
  5482                                  ;else
  5483 0000077B 81FF0A03                	cmp	di,030Ah		; version >= 30a i.e 3.10 ;M037
  5484                                  ;endif
  5485                                  	;ljae	noVxD31			; yes, VxD not needed 	 ;M037
  5486 0000077F 724E                    	jb	short Win386_vxd
  5487 00000781 E9DF00                  	jmp	noVxD31
  5488                                  
  5489                                  	; 15/12/2022
  5490                                  winold_swap:
  5491 00000784 1E                      	push	ds
  5492 00000785 06                      	push	es
  5493 00000786 56                      	push	si
  5494 00000787 57                      	push	di
  5495 00000788 51                      	push	cx
  5496                                  
  5497                                  	;getdseg <ds>			;ds = DOSDATA
  5498 00000789 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  5499                                  
  5500 0000078E 3C01                    	cmp	al,1			;swap Windows out call
  5501 00000790 751B                    	jne	short swapin		;no, check if Swap in call
  5502 00000792 E89201                  	call	getwinlast
  5503 00000795 1E                      	push	ds
  5504 00000796 07                      	pop	es
  5505 00000797 8EDE                    	mov	ds,si			;ds = memory arena of Windows
  5506 00000799 31F6                    	xor	si,si
  5507 0000079B BF[0600]                	mov	di,WinoldPatch1
  5508 0000079E B90800                  	mov	cx,8
  5509 000007A1 FC                      	cld
  5510 000007A2 51                      	push	cx
  5511 000007A3 F3A4                    	rep	movsb			;save first 8 bytes
  5512 000007A5 59                      	pop	cx
  5513 000007A6 BF[CC0D]                	mov	di,WinoldPatch2
  5514 000007A9 F3A4                    	rep	movsb			;save next 8 bytes
  5515 000007AB EB1B                    	jmp	short winold_done
  5516                                  swapin:
  5517 000007AD 3C02                    	cmp	al,2			;swap Windows in call?
  5518 000007AF 7517                    	jne	short winold_done	;no, something else, pass it on
  5519 000007B1 E87301                  	call	getwinlast
  5520 000007B4 8EC6                    	mov	es,si
  5521 000007B6 31FF                    	xor	di,di
  5522 000007B8 BE[0600]                	mov	si,WinoldPatch1
  5523 000007BB B90800                  	mov	cx,8
  5524 000007BE FC                      	cld
  5525 000007BF 51                      	push	cx
  5526 000007C0 F3A4                    	rep	movsb			;restore first 8 bytes
  5527 000007C2 59                      	pop	cx
  5528 000007C3 BE[CC0D]                	mov	si,WinoldPatch2
  5529 000007C6 F3A4                    	rep	movsb			;restore next 8 bytes
  5530                                  winold_done:
  5531 000007C8 59                      	pop	cx
  5532 000007C9 5F                      	pop	di
  5533 000007CA 5E                      	pop	si
  5534 000007CB 07                      	pop	es
  5535 000007CC 1F                      	pop	ds
  5536 000007CD EB7D                    	jmp	short next_i2f		;chain on
  5537                                  	; 15/12/2022
  5538                                  	;jmp	next_i2f	
  5539                                  
  5540                                  Win386_vxd:
  5541 000007CF 50                      	push	ax
  5542 000007D0 53                      	push	bx
  5543 000007D1 51                      	push	cx
  5544 000007D2 52                      	push	dx
  5545 000007D3 56                      	push	si
  5546 000007D4 57                      	push	di			; save regs !!dont change order!!
  5547                                  
  5548 000007D5 8B1E[8C00]              	mov	bx,[UMB_HEAD]		; M062 - Start
  5549 000007D9 83FBFF                  	cmp	bx,0FFFFh    		; Q: have umbs been initialized
  5550 000007DC 7421                    	je	short Vxd31		; N: continue
  5551                                  					; Y: save arena associated with 
  5552                                  					;    umb_head
  5553                                  
  5554 000007DE C606[D90D]01            	mov	byte [UmbSaveFlag],1	; indicate that we're saving 
  5555                                  					; umb_arena
  5556 000007E3 1E                      	push	ds
  5557 000007E4 06                      	push	es
  5558                                  
  5559 000007E5 8CD8                    	mov	ax,ds
  5560 000007E7 8EC0                    	mov	es,ax			; es - > dosdata
  5561                                  
  5562 000007E9 8EDB                    	mov	ds,bx
  5563 000007EB 31F6                    	xor	si,si			; ds:si -> umb_head
  5564                                  
  5565 000007ED FC                      	cld
  5566                                  
  5567 000007EE BF[F511]                	mov	di,UmbSave1
  5568 000007F1 B90B00                  	mov	cx,11
  5569 000007F4 F3A4                    	rep	movsb
  5570                                  
  5571 000007F6 BF[D40D]                	mov	di,UmbSave2
  5572                                  	;mov	cx,5
  5573                                  	; 18/12/2022
  5574 000007F9 B105                    	mov	cl,5
  5575 000007FB F3A4                    	rep	movsb	
  5576                                  
  5577 000007FD 07                      	pop	es
  5578 000007FE 1F                      	pop	ds			; M062 - End
  5579                                  
  5580                                  Vxd31:
  5581                                  	;test	byte [DOS_FLAG],2
  5582 000007FF F606[8600]02            	test	byte [DOS_FLAG],SUPPRESS_WINA20	; M066
  5583 00000804 7408                    	jz	short Dont_Supress		; M066
  5584 00000806 5F                      	pop	di				; M066
  5585 00000807 5E                      	pop	si				; M066
  5586 00000808 5A                      	pop	dx				; M066
  5587 00000809 59                      	pop	cx				; M066
  5588 0000080A 5B                      	pop	bx				; M066
  5589 0000080B 58                      	pop	ax				; M066
  5590 0000080C EB55                    	jmp	short noVxD31			; M066
  5591                                  
  5592                                  	; We check here if the VxD is available in the root of the boot drive. 
  5593                                  	; We do an extended open to suppress any error messages
  5594                                  	
  5595                                  Dont_Supress:
  5596 0000080E A0[6900]                	mov	al,[BOOTDRIVE]
  5597 00000811 0440                    	add	al,'A' - 1		; get drive letter
  5598 00000813 A2[3010]                	mov	[VxDpath],al		; path is root of bootdrive
  5599                                  	;mov	ah,ExtOpen  ;6Ch	; extended open
  5600                                  	;mov	al,0			; no extended attributes
  5601                                  	; 18/12/2022
  5602 00000816 B8006C                  	mov	ax,ExtOpen<<8 ; 6C00h
  5603 00000819 BB8020                  	mov	bx,2080h		; read access, compatibility mode
  5604                                  					; no inherit, suppress crit err
  5605 0000081C B90700                  	mov	cx,7			; hidden,system,read-only attr
  5606 0000081F BA0100                  	mov	dx,1			; fail if file does not exist
  5607 00000822 BE[3010]                	mov	si,VxDpath	
  5608                                  					; path of VxD file
  5609 00000825 BFFFFF                  	mov	di,0FFFFh		; no extended attributes
  5610                                  
  5611 00000828 CD21                    	int	21h			; do extended open
  5612                                  
  5613 0000082A 5F                      	pop	di
  5614 0000082B 5E                      	pop	si
  5615 0000082C 5A                      	pop	dx
  5616 0000082D 59                      	pop	cx
  5617                                  
  5618 0000082E 7321                    	jnc	short VxDthere		; we found the VxD, go ahead
  5619                                  
  5620                                  	; We could not find the VxD. Cannot let windows load. Return cx != 0 
  5621                                  	; to indicate error to Windows after displaying message to user that 
  5622                                  	; VxD needs to be present to run Windows in enhanced mode.
  5623                                  
  5624 00000830 52                      	push	dx
  5625 00000831 1E                      	push	ds
  5626 00000832 56                      	push	si
  5627 00000833 BE[D009]                	mov	si,NoVxDErrMsg
  5628 00000836 0E                      	push	cs
  5629 00000837 1F                      	pop	ds
  5630 00000838 B96300                  	mov	cx,VxDMesLen ; 99	;
  5631 0000083B B402                    	mov	ah,2			; write char to console
  5632 0000083D FC                      	cld
  5633                                  vxdlp:
  5634 0000083E AC                      	lodsb
  5635 0000083F 86D0                    	xchg	dl,al			; get char in dl
  5636 00000841 CD21                    	int	21h
  5637 00000843 E2F9                    	loop	vxdlp
  5638                                  
  5639 00000845 5E                      	pop	si
  5640 00000846 1F                      	pop	ds
  5641 00000847 5A                      	pop	dx
  5642 00000848 5B                      	pop	bx
  5643 00000849 58                      	pop	ax			;all registers restored
  5644 0000084A 41                      	inc	cx			;cx != 0 to indicate error
  5645                                  	; 15/12/22022
  5646                                  	;jmp	win_nexti2f		;chain on
  5647                                  	;jmp	short win_nexti2f
  5648                                  
  5649                                  	; 15/12/2022
  5650                                  win_nexti2f:
  5651 0000084B 1F                      	pop	ds
  5652                                  	;jmp	short next_i2f		; go to BIOS i2f handler
  5653                                  	; 15/12/2022
  5654                                  next_i2f:
  5655                                  	;;;jmp	bios_i2f
  5656                                  	;;jmp	far ptr 70h:5 ; MSDOS 6.21 (MSDOS.SYS, DOSCODE:44F1h)
  5657                                  	;jmp	KERNEL_SEGMENT:bios_i2f
  5658                                  	; 04/11/2022
  5659 0000084C EA05007000              	jmp	DOSBIODATASEG:bios_i2f
  5660                                  
  5661                                  VxDthere:
  5662 00000851 89C3                    	mov	bx,ax
  5663 00000853 B43E                    	mov	ah,CLOSE ; 3Eh
  5664 00000855 CD21                    	int	21h			;close the file
  5665                                  
  5666                                  	; Update the VxD ptr in the instance data structure with path to VxD
  5667                                  
  5668                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  5669                                  	;mov	bx,Win386_Info
  5670                                  	;mov	word [bx+Win386_SIS.Virt_Dev_File_Ptr],VxDpath
  5671                                  	;mov	word [bx+Win386_SIS.Virt_Dev_File_Ptr+2],ds
  5672                                  	; 15/12/2022
  5673 00000857 C706[E70F][3010]        	mov	word [Win386_Info+Win386_SIS.Virt_Dev_File_Ptr],VxDpath
  5674 0000085D 8C1E[E90F]              	mov	word [Win386_Info+Win386_SIS.Virt_Dev_File_Ptr+2],ds
  5675                                  
  5676 00000861 5B                      	pop	bx
  5677 00000862 58                      	pop	ax
  5678                                  noVxD31:
  5679                                  	; M018; End of block changes
  5680                                  
  5681 00000863 800E[2F10]01            	or	byte [IsWin386],1 	; Indicate WIN386 present
  5682 00000868 800E[0C0D]01            	or	byte [redir_patch],1	; Enable critical sections; M002
  5683                                  
  5684                                  	; M002;
  5685                                  	; Save the previous es:bx (instance data ptr) into our instance table
  5686                                  
  5687 0000086D 52                      	push	dx			; M002
  5688 0000086E 89DA                    	mov	dx,bx			; M002
  5689                                  					; point ES:BX to Win386_Info ; M002
  5690 00000870 BB[E10F]                	mov	bx,Win386_Info 
  5691 00000873 895702                  	mov	[bx+2],dx		; M002
  5692 00000876 8C4704                  	mov	[bx+4],es		; M002
  5693 00000879 5A                      	pop	dx			; M002
  5694 0000087A 1E                      	push	ds			; M002
  5695 0000087B 07                      	pop	es			; M002
  5696                                  	;jmp	win_nexti2f		; M002
  5697                                  	; 15/12/2022
  5698 0000087C EBCD                    	jmp	short win_nexti2f
  5699                                  
  5700                                  	; 15/12/2022
  5701                                  	; Code to return Win386 2.xx instance table
  5702                                  OldWin386Init:
  5703 0000087E 58                      	pop	ax			; discard ds pushed on stack
  5704 0000087F BE[C811]                	mov	si,OldInstanceJunk 
  5705                                  					; ds:si = instance table
  5706 00000882 B84852                  	mov	ax,5248h ; 'RH'		; indicate instance data present
  5707                                  	;jmp	next_i2f
  5708                                  	; 15/12/2022
  5709 00000885 EBC5                    	jmp	short next_i2f
  5710                                  
  5711                                  Win386_Leaving:
  5712                                  	; 15/12/2022
  5713 00000887 F6C201                  	test 	dl,1
  5714                                  	;test	dx,1			; is this really win386?
  5715                                  	;jz	short Win386_Leaving_c
  5716                                  	;jmp	win_nexti2f		; NO! It's win 286 dos extender! M002
  5717                                  	; 15/12/2022
  5718 0000088A 75BF                    	jnz	short win_nexti2f	
  5719                                  
  5720                                  Win386_Leaving_c:
  5721                                  					; M062 - Start
  5722 0000088C 803E[D90D]01            	cmp	byte [UmbSaveFlag], 1	; Q: was umb_arena saved at win start
  5723                                  					;    up.
  5724 00000891 7526                    	jne	short noumb		; N: not saved 
  5725 00000893 C606[D90D]00            	mov	byte [UmbSaveFlag], 0	; Y: clear UmbSaveFlag and restore 
  5726                                  					;    previously saved umb_head
  5727 00000898 50                      	push	ax
  5728 00000899 06                      	push	es
  5729 0000089A 51                      	push	cx
  5730 0000089B 56                      	push	si
  5731 0000089C 57                      	push	di
  5732                                  
  5733 0000089D A1[8C00]                	mov	ax,[UMB_HEAD]	
  5734 000008A0 8EC0                    	mov	es,ax
  5735 000008A2 31FF                    	xor	di,di			; es:di -> umb_head
  5736                                  
  5737 000008A4 FC                      	cld
  5738                                  
  5739 000008A5 BE[F511]                	mov	si,UmbSave1
  5740 000008A8 B90B00                  	mov	cx,11
  5741 000008AB F3A4                    	rep	movsb
  5742 000008AD BE[D40D]                	mov	si,UmbSave2
  5743                                  	;mov	cx,5
  5744                                  	; 18/12/2022
  5745 000008B0 B105                    	mov	cl,5
  5746 000008B2 F3A4                    	rep	movsb
  5747                                  
  5748 000008B4 5F                      	pop	di
  5749 000008B5 5E                      	pop	si
  5750 000008B6 59                      	pop	cx
  5751 000008B7 07                      	pop	es
  5752 000008B8 58                      	pop	ax
  5753                                  noumb:					; M062 - End
  5754 000008B9 8026[2F10]00            	and	byte [IsWin386],0	; Win386 is gone
  5755 000008BE 8026[0C0D]00            	and	byte [redir_patch],0	; Disable critical sections ; M002
  5756 000008C3 EB86                    	jmp	short win_nexti2f
  5757                                  
  5758                                  ;	; 15/12/2022
  5759                                  ;	; Code to return Win386 2.xx instance table
  5760                                  ;OldWin386Init:
  5761                                  ;	pop	ax			; discard ds pushed on stack
  5762                                  ;	mov	si,OldInstanceJunk 
  5763                                  ;					; ds:si = instance table
  5764                                  ;	mov	ax,5248h ; 'RH'		; indicate instance data present
  5765                                  ;	;jmp	next_i2f
  5766                                  ;	; 15/12/2022
  5767                                  ;	jmp	short _next_i2f
  5768                                  
  5769                                  Win386_Query:
  5770 000008C5 83FB15                  	cmp	bx,Win386_DOSMGR ; 15h	; is this from DOSMGR?
  5771 000008C8 7581                    	jne	short win_nexti2f     	; no, ignore it & chain to next
  5772 000008CA 09C9                    	or	cx,cx			; is it an instance query?
  5773 000008CC 7508                    	jne	short dosmgr_func	; no, some DOSMGR query
  5774 000008CE 41                      	inc	cx			; indicate that data is instanced
  5775                                  ;
  5776                                  ; M001; We were previously returning a null ptr in es:bx. This will not work.
  5777                                  ; M001; WIN386 needs a ptr to a table in es:bx with the following offsets:
  5778                                  ; M001;  
  5779                                  ; M001; OFFSETS STRUC
  5780                                  ; M001; 	Major_version	db	?
  5781                                  ; M001; 	Minor_version	db	?
  5782                                  ; M001; 	SaveDS		dw	?
  5783                                  ; M001; 	SaveBX		dw	?
  5784                                  ; M001; 	Indos		dw	?
  5785                                  ; M001; 	User_id		dw	?
  5786                                  ; M001; 	CritPatch	dw	?
  5787                                  ; M001; OFFSETS	ENDS
  5788                                  ; M001; 
  5789                                  ; M001; User_Id is the only variable really important for proper functioning  
  5790                                  ; M001; of Win386. The other variables are used at init time to patch stuff
  5791                                  ; M001; out. In DOS 5.0, we do the patching ourselves. But we still need to 
  5792                                  ; M001; pass this table because Win386 depends on this table to get the 
  5793                                  ; M001; User_Id offset.
  5794                                  ; M001; 
  5795 000008CF BB[2110]                	mov	bx,Win386_DOSVars	; M001 
  5796 000008D2 1E                      	push	ds			; M001
  5797 000008D3 07                      	pop	es			; es:bx points at offset table ; M001
  5798 000008D4 EB41                    	jmp	short PopIret		; M001
  5799                                  
  5800                                  ; 15/12/2022
  5801                                  ;	; Code to return Win386 2.xx instance table
  5802                                  ;OldWin386Init:
  5803                                  ;	pop	ax			; discard ds pushed on stack
  5804                                  ;	mov	si,OldInstanceJunk 
  5805                                  ;					; ds:si = instance table
  5806                                  ;	mov	ax,5248h ; 'RH'		; indicate instance data present
  5807                                  ;	;jmp	next_i2f
  5808                                  ;	; 15/12/2022
  5809                                  ;	jmp	short _next_i2f
  5810                                  
  5811                                  dosmgr_func:
  5812 000008D6 49                      	dec	cx
  5813 000008D7 7436                    	jz	short win386_patch	; call to patch DOS
  5814 000008D9 49                      	dec	cx
  5815 000008DA 743B                    	jz	short PopIret		; remove DOS patches, ignore
  5816 000008DC 49                      	dec	cx
  5817 000008DD 743A                    	jz	short win386_size	; get size of DOS data structures
  5818 000008DF 49                      	dec	cx
  5819 000008E0 7441                    	jz	short win386_inst	; instance more data
  5820 000008E2 49                      	dec	cx
  5821 000008E3 7532                    	jnz	short PopIret		; no functions above this
  5822                                  
  5823                                  	; Get DOS device driver size -- es:di points at device driver header
  5824                                  	; In DOS 4.x, the para before the device header contains an arena 
  5825                                  	; header for the driver.
  5826                                  
  5827 000008E5 8CC0                    	mov	ax,es			; ax = device header segment
  5828                                  
  5829                                  	; We check to see if we have a memory arena for this device driver. 
  5830                                  	; The way to do this would be to look at the previous para to see if
  5831                                  	; it has a 'D' marking it as an arena and also see if the owner-field 
  5832                                  	; in the arena is the same as the device header segment. These two 
  5833                                  	; checks together should take care of all cases
  5834                                  
  5835 000008E7 48                      	dec	ax			; get arena header
  5836 000008E8 06                      	push	es
  5837 000008E9 8EC0                    	mov	es,ax			; arena header for device driver
  5838                                  
  5839 000008EB 26803D44                	cmp	byte [es:di],'D'	; is it a device arena?
  5840 000008EF 7517                    	jnz	short cantsize		; no, cant size this driver
  5841 000008F1 40                      	inc	ax			; get back device header segment
  5842 000008F2 26394501                	cmp	[es:di+1],ax		; owner field pointing at driver?
  5843 000008F6 7510                    	jnz	short cantsize		; no, not a proper arena
  5844                                  
  5845 000008F8 268B4503                	mov	ax,[es:di+3]		; get arena size in paras
  5846 000008FC 07                      	pop	es
  5847                                  
  5848                                  	; We have to multiply by 16 to get the number of bytes in (bx:cx)
  5849                                  	; Speed is not critical and so we choose the shortest method 
  5850                                  	; -- use "mul"
  5851                                  
  5852 000008FD BB1000                  	mov	bx,16
  5853 00000900 F7E3                    	mul	bx
  5854 00000902 89C1                    	mov	cx,ax
  5855 00000904 89D3                    	mov	bx,dx
  5856 00000906 EB09                    	jmp	short win386_done	; return with device driver size
  5857                                  cantsize:
  5858 00000908 07                      	pop	es
  5859 00000909 31C0                    	xor	ax,ax
  5860 0000090B 31D2                    	xor	dx,dx			; ask DOSMGR to use its methods
  5861 0000090D EB08                    	jmp	short PopIret		; return
  5862                                  
  5863                                  win386_patch:
  5864                                  	; dx contains bits marking the patches to be applied. We return 
  5865                                  	; the field with all bits set to indicate that all patches have been
  5866                                  	; done
  5867                                  
  5868 0000090F 89D3                    	mov	bx,dx			; move patch bitfield to bx
  5869                                   	;jmp	short win386_done	; done, return
  5870                                  	; 15/12/2022
  5871                                  	; 15/12/2022
  5872                                  win386_done:
  5873 00000911 B87CB9                  	mov	ax,WIN_OP_DONE		; 0B97Ch
  5874 00000914 BAABA2                  	mov	dx,DOSMGR_OP_DONE	; 0A2ABh
  5875                                  PopIret:
  5876 00000917 1F                      	pop	ds
  5877 00000918 CF                      	iret	
  5878                                  
  5879                                  win386_size:
  5880                                  	;Return the size of DOS data structures -- currently only CDS size
  5881                                  
  5882                                  	; 17/12/2022
  5883 00000919 F6C201                  	test	dl,1
  5884                                  	;test	dx,1			; check for CDS size bit
  5885 0000091C 74F9                    	jz	short PopIret		; no, unknown structure -- return
  5886                                  
  5887 0000091E B95800                  	mov	cx,curdirLen	; 88 	; cx = CDS size
  5888 00000921 EBEE                    	jmp	short win386_done	; return with the size
  5889                                  
  5890                                  win386_inst:
  5891                                  	; WIN386 check to see if DOS has identified the CDS,SFT and device 
  5892                                  	; chain as instance data. Currently, we let the WIN386 DOSMGR handle
  5893                                  	; this by returning a status of not previously instanced. The basic 
  5894                                  	; structure of these things have not changed and so the current 
  5895                                  	; DOSMGR code should be able to work it out
  5896                                  
  5897 00000923 31D2                    	xor	dx,dx			; make sure dx has a not done value
  5898 00000925 EBF0                    	jmp	short PopIret		; skip done indication
  5899                                  
  5900                                  	; 15/12/2022
  5901                                  ;win386_done:
  5902                                  ;	mov	ax,WIN_OP_DONE		; 0B97Ch
  5903                                  ;	mov	dx,DOSMGR_OP_DONE	; 0A2ABh
  5904                                  ;PopIret:
  5905                                  ;	pop	ds
  5906                                  ;	iret				; return back up the chain
  5907                                  
  5908                                  	; 15/12/2022
  5909                                  ;win_nexti2f:
  5910                                  	;pop	ds
  5911                                  	;jmp	next_i2f		; go to BIOS i2f handler
  5912                                  
  5913                                  ;End WIN386 support
  5914                                  
  5915                                  ; 15/05/2019
  5916                                  
  5917                                  ;M044; Start of changes
  5918                                  ; Winoldap has a bug in that its calculations for the Windows memory image
  5919                                  ; to save is off by 1 para. This para can happen to be a Windows arena if the
  5920                                  ; DOS top of memory happens to be at an odd boundary (as is the case when
  5921                                  ; UMBs are present). This is because Windows builds its arenas only at even
  5922                                  ; para boundaries. This arena now gets trashed when Windows is swapped back
  5923                                  ; in leading to a crash. Winoldap issues callouts when it swaps WIndows out
  5924                                  ; and back in. We sit on these callouts. On the Windows swapout, we save the
  5925                                  ; last para of the Windows memory block and then restore this para on the
  5926                                  ; Windows swapin callout. 
  5927                                  
  5928                                  getwinlast:
  5929                                  	; 07/12/2022
  5930 00000927 8B36[3003]              	mov	si,[CurrentPDB]
  5931 0000092B 4E                      	dec	si
  5932 0000092C 8EC6                    	mov	es,si
  5933 0000092E 2603360300              	add	si,[es:3]
  5934 00000933 C3                      	retn
  5935                                  
  5936                                  ; 15/12/2022
  5937                                  %if 0
  5938                                  winold_swap:
  5939                                  	push	ds
  5940                                  	push	es
  5941                                  	push	si
  5942                                  	push	di
  5943                                  	push	cx
  5944                                  
  5945                                  	;getdseg <ds>			;ds = DOSDATA
  5946                                  	mov	ds,[cs:DosDSeg]
  5947                                  
  5948                                  	cmp	al,1			;swap Windows out call
  5949                                  	jne	short swapin		;no, check if Swap in call
  5950                                  	call	getwinlast
  5951                                  	push	ds
  5952                                  	pop	es
  5953                                  	mov	ds,si			;ds = memory arena of Windows
  5954                                  	xor	si,si
  5955                                  	mov	di,WinoldPatch1
  5956                                  	mov	cx,8
  5957                                  	cld
  5958                                  	push	cx
  5959                                  	rep	movsb			;save first 8 bytes
  5960                                  	pop	cx
  5961                                  	mov	di,WinoldPatch2
  5962                                  	rep	movsb			;save next 8 bytes
  5963                                  	jmp	short winold_done
  5964                                  swapin:
  5965                                  	cmp	al,2			;swap Windows in call?
  5966                                  	jne	short winold_done	;no, something else, pass it on
  5967                                  	call	getwinlast
  5968                                  	mov	es,si
  5969                                  	xor	di,di
  5970                                  	mov	si,WinoldPatch1
  5971                                  	mov	cx,8
  5972                                  	cld
  5973                                  	push	cx
  5974                                  	rep	movsb			;restore first 8 bytes
  5975                                  	pop	cx
  5976                                  	mov	si,WinoldPatch2
  5977                                  	rep	movsb			;restore next 8 bytes
  5978                                  winold_done:
  5979                                  	pop	cx
  5980                                  	pop	di
  5981                                  	pop	si
  5982                                  	pop	es
  5983                                  	pop	ds
  5984                                  	jmp	next_i2f		;chain on
  5985                                  
  5986                                  %endif
  5987                                  
  5988                                  ;M044; End of changes
  5989                                  
  5990                                  ; 15/05/2019
  5991                                  
  5992                                  DispatchDOS:
  5993 00000934 2EFF36[C401]            	PUSH	word [CS:FOO]		; push return address
  5994 00000939 2EFF36[C601]            	PUSH	word [CS:DTab]		; push table address
  5995 0000093E 50                      	PUSH	AX			; push index
  5996 0000093F 55                      	PUSH	BP
  5997 00000940 89E5                    	MOV	BP,SP
  5998                                  		; stack looks like:
  5999                                  		;   0	BP
  6000                                  		;   2	DISPATCH
  6001                                  		;   4	TABLE
  6002                                  		;   6	RETURN
  6003                                  		;   8	LONG-RETURN
  6004                                  		;   C	FLAGS
  6005                                  		;   E	AX
  6006                                  	
  6007 00000942 8B460E                  	MOV	AX,[BP+0Eh]		; get AX value
  6008 00000945 5D                      	POP	BP
  6009 00000946 E81F09                  	call	TableDispatch
  6010 00000949 E9D4FD                  	JMP	BadFunc 		; return indicates invalid function
  6011                                  
  6012                                  INT2F_etcetera:
  6013                                  	;entry	DosGetGroup
  6014                                  DosGetGroup:
  6015                                  	; MSDOS 3.3
  6016                                  	;push	cs
  6017                                  	;pop	ds
  6018                                  	;retn
  6019                                  
  6020                                  	; MSDOS 6.0
  6021                                  ;SR; Cannot use CS now
  6022                                  ;
  6023                                  ;	PUSH	CS
  6024                                  ;	POP	DS
  6025                                  
  6026                                  	; 04/11/2022
  6027                                  	; (MSDOS 5.0 MSDOS.SYS - DOSCODE:46FBh)
  6028                                  
  6029                                  	;getdseg <ds>
  6030 0000094C 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  6031 00000951 C3                      	retn
  6032                                  
  6033                                  	;entry	DOSInstall
  6034                                  DOSInstall:
  6035 00000952 B0FF                    	MOV	AL,0FFh
  6036 00000954 C3                      	retn
  6037                                  
  6038                                  ;ENDIF ; (*)
  6039                                  
  6040                                  
  6041                                  ; 15/05/2019 - Retro DOS v4.0
  6042                                  
  6043                                  ;------------------------------------------------------------------------
  6044                                  ;
  6045                                  ; Procedure Name : RW32_CONVERT
  6046                                  ;
  6047                                  ;Input: same as ABSDRD and ABSDWRT
  6048                                  ;	 ES:BP -> DPB
  6049                                  ;Functions: convert 32bit absolute RW input parms to 16bit input parms
  6050                                  ;Output: carry set when CX=-1 and drive is less then 32mb
  6051                                  ;	 carry clear, parms ok
  6052                                  ;
  6053                                  ;------------------------------------------------------------------------
  6054                                  
  6055                                  RW32_CONVERT:
  6056 00000955 83F9FF                  	CMP	CX,-1			   ;>32mb  new format ?	;AN000;
  6057 00000958 7429                    	JZ	short new32format	   ;>32mb  yes		;AN000;
  6058 0000095A 50                      	PUSH	AX			   ;>32mb  save ax	;AN000;
  6059 0000095B 52                      	PUSH	DX			   ;>32mb  save dx	;AN000;
  6060 0000095C 268B460D                	MOV	AX,[ES:BP+DPB.MAX_CLUSTER] ;>32mb  get max cluster # ;AN000;
  6061 00000960 268A5604                	MOV	DL,[ES:BP+DPB.CLUSTER_MASK] ;>32mb		;AN000;
  6062 00000964 80FAFE                  	CMP	DL,0FEh 		;>32mb  removable ?	;AN000;
  6063 00000967 7407                    	JZ	short letold		;>32mb  yes		;AN000;
  6064                                  	;INC	DL			;>32mb			;AN000;
  6065                                  	; 17/12/2022
  6066 00000969 42                      	inc	dx
  6067 0000096A 30F6                    	XOR	DH,DH			;>32mb  dx = sector/cluster ;AN000;
  6068 0000096C F7E2                    	MUL	DX			;>32mb  dx:ax= max sector # ;AN000;
  6069 0000096E 09D2                    	OR	DX,DX			;>32mb  > 32mb ?	;AN000;
  6070                                  letold:
  6071 00000970 5A                      	POP	DX			;>32mb  restore dx	;AN000;
  6072 00000971 58                      	POP	AX			;>32mb  restore ax 	;AN000;
  6073 00000972 7425                    	JZ	short old_style		;>32mb  no 		;AN000;
  6074                                  
  6075 00000974 1E                      	push	ds
  6076                                  	;getdseg <ds>
  6077 00000975 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  6078 0000097A C706[B80D]0702          	mov	word [AbsDskErr],207h	;>32mb  bad address mark
  6079 00000980 1F                      	pop	ds
  6080                                  
  6081 00000981 F9                      	STC				;>32mb			;AN000;
  6082 00000982 C3                      	retn				;>32mb			;AN000;
  6083                                  
  6084                                  new32format:
  6085                                  	;mov	dx,[bx+2]
  6086 00000983 8B5702                  	MOV	DX,[BX+ABS_32RW.SECTOR_RBA+2] ;>32mb		;AN000;
  6087                                  
  6088 00000986 1E                      	push	ds			; set up ds to DOSDATA
  6089                                  	;getdseg <ds>
  6090 00000987 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  6091 0000098C 8916[0706]              	MOV	[HIGH_SECTOR],DX	;>32mb			;AN000;
  6092 00000990 1F                      	pop	ds
  6093                                  
  6094 00000991 8B17                    	mov	dx,[bx]
  6095                                  	;MOV	DX,[BX+ABS_32RW.SECTOR_RBA]  ;>32mb		;AN000;
  6096                                  	;mov	cx,[bx+4]
  6097 00000993 8B4F04                  	MOV	CX,[BX+ABS_32RW.ABS_RW_COUNT] ;>32mb		;AN000;
  6098                                  	;lds	bx,[bx+6]
  6099 00000996 C55F06                  	LDS	BX,[BX+ABS_32RW.BUFFER_ADDR] ;>32mb		;AN000;
  6100                                  old_style:				;>32mb			;AN000;
  6101 00000999 F8                      	CLC				;>32mb			;AN000;
  6102 0000099A C3                      	retn				;>32mb			;AN000;
  6103                                  
  6104                                  ;------------------------------------------------------------------------
  6105                                  ;
  6106                                  ; Procedure Name : Fastxxx_Purge
  6107                                  ;
  6108                                  ; Input: None
  6109                                  ; Functions: Purge Fastopen/ Cache Buffers
  6110                                  ; Output: None
  6111                                  ;
  6112                                  ;------------------------------------------------------------------------
  6113                                  
  6114                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  6115                                  
  6116                                  Fastxxx_Purge:
  6117 0000099B 50                      	PUSH	AX			; save regs.	;AN000;
  6118 0000099C 56                      	PUSH	SI						;AN000;
  6119 0000099D 52                      	PUSH	DX						;AN000;
  6120                                  topen:
  6121 0000099E 1E                      	push	ds			; set up ds to DOSDATA
  6122                                  	;getdseg <ds>
  6123 0000099F 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  6124                                  
  6125 000009A4 F606[3A0D]80            	TEST	byte [FastOpenFlg],Fast_yes ; 80h 
  6126                                  					; fastopen installed ?	;AN000;
  6127 000009A9 1F                      	pop	ds
  6128 000009AA 740B                    	JZ	short nofast		; no			;AN000;
  6129 000009AC B401                    	MOV	AH,FastOpen_ID	; 1				;AN000;
  6130                                  dofast:
  6131 000009AE B005                    	MOV	AL,FONC_purge  ;5	; purge			;AN000;
  6132                                  	;;mov	dl,[es:bp+0]
  6133                                  	; 05/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  6134                                  	;MOV	DL,[ES:BP+DPB.DRIVE]	; set up drive number	;AN000;
  6135                                  	; 15/12/2022
  6136 000009B0 268A5600                	mov	dl,[es:bp]
  6137                                  	;invoke	Fast_Dispatch		; call fastopen/seek	;AN000;
  6138 000009B4 E8B11D                  	call	Fast_Dispatch
  6139                                  nofast:
  6140 000009B7 5A                      	POP	DX						;AN000;
  6141 000009B8 5E                      	POP	SI			; restore regs		;AN000;
  6142 000009B9 58                      	POP	AX			 			;AN000;
  6143 000009BA C3                      	retn				; exit
  6144                                  
  6145                                  ;============================================================================
  6146                                  ; DOSMES.INC (MSDOS 6.0, 1991)
  6147                                  ;============================================================================
  6148                                  ; 29/04/2019 - Retro DOS v4.0
  6149                                  
  6150                                  ;include dossym.inc
  6151                                  ;include dosmac.inc
  6152                                  ;include doscntry.inc
  6153                                  
  6154                                  ; DOSCODE Segment
  6155                                  
  6156                                  ; 17/07/2018 - Retro DOS v3.0  [ DOSMES.INC (MSDOS 3.3, 1987) ]
  6157                                  ; ---------------------------------------------------------------------------
  6158                                  ;include divmes.inc
  6159                                  
  6160                                  ; DOSCODE:4778h (MSDOS 6.21, MSDOS.SYS)
  6161                                  ; -------------------------------------
  6162                                  ; DOSCODE:476Bh (MSDOS 5.0, MSDOS.SYS) - 05/11/2022 -
  6163                                  
  6164                                  ; THIS IS THE ONLY DOS "MESSAGE". IT DOES NOT NEED A TERMINATOR.
  6165                                  	;PUBLIC	DIVMES
  6166                                  
  6167 000009BB 0D0A44697669646520-     DIVMES:	DB	13,10,"Divide overflow",13,10
  6167 000009C4 6F766572666C6F770D-
  6167 000009CD 0A                 
  6168                                  
  6169                                  	;PUBLIC	DivMesLen
  6170                                  DivMesLen:
  6171 000009CE 1300                    	DW	$-DIVMES  ; 19	; Length of the above message in bytes
  6172                                  
  6173                                  ; DOSCODE:478Dh (MSDOS 6.21, MSDOS.SYS)
  6174                                  ; -------------------------------------
  6175                                  ; DOSCODE:4780h (MSDOS 5.0, MSDOS.SYS) - 05/11/2022 -
  6176                                  
  6177                                  ; (MSDOS 6.0)
  6178                                  ; VxD not found error message
  6179                                  
  6180                                  NoVxDErrMsg:
  6181 000009D0 596F75206D75737420-     	db  'You must have the file WINA20.386 in the root of your boot drive'
  6181 000009D9 686176652074686520-
  6181 000009E2 66696C652057494E41-
  6181 000009EB 32302E33383620696E-
  6181 000009F4 2074686520726F6F74-
  6181 000009FD 206F6620796F757220-
  6181 00000A06 626F6F742064726976-
  6181 00000A0F 65                 
  6182 00000A10 0D0A746F2072756E20-     	db  0Dh,0Ah,'to run Windows in Enhanced Mode',0Dh,0Ah
  6182 00000A19 57696E646F77732069-
  6182 00000A22 6E20456E68616E6365-
  6182 00000A2B 64204D6F64650D0A   
  6183                                  
  6184                                  VxDMesLen equ $ - NoVxDErrMsg  ; 99
  6185                                  
  6186                                  ; 13/05/2019 - Retro DOS v4.0
  6187                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  6188                                  
  6189                                  ;include yesno.asm  (MNSDOS 6.0)
  6190                                  ; -------------------------------------
  6191                                  ; DOSCODE:47F0h (MSDOS 6.21, MSDOS.SYS)
  6192                                  ; DOSCODE:47E3h (MSDOS 5.0, MSDOS.SYS) - 05/11/2022 -
  6193                                  
  6194                                  ; This is for country Yes and No
  6195                                  
  6196 00000A33 59                      NLS_YES:	db 'Y'
  6197 00000A34 4E                      NLS_NO:		db 'N'
  6198 00000A35 79                      NLS_yes2:	db 'y'
  6199 00000A36 6E                      NLS_no2:	db 'n'
  6200                                  
  6201                                  ; ---------------------------------------------------------------------------
  6202                                  
  6203                                  ; DOSCODE:47F4h (MSDOS 6.21, MSDOS.SYS)
  6204                                  ; DOSCODE:47E7h (MSDOS 5.0, MSDOS.SYS) - 05/11/2022 -
  6205                                  
  6206                                  ;SUBTTL EDIT FUNCTION ASSIGNMENTS AND HEADERS
  6207                                  
  6208                                  ; The following two tables implement the current buffered input editing
  6209                                  ; routines. The tables are pairwise associated in reverse order for ease
  6210                                  ; in indexing. That is; The first entry in ESCTAB corresponds to the last
  6211                                  ; entry in ESCFUNC, and the last entry in ESCTAB to the first entry in ESCFUNC.
  6212                                  
  6213                                  	;PUBLIC	CANCHAR
  6214                                  CANCHAR:
  6215 00000A37 1B                      	DB	CANCEL	; 1Bh	;Cancel line character
  6216                                  	
  6217                                  	;PUBLIC	ESCCHAR
  6218                                  ESCCHAR:
  6219 00000A38 00                      	DB	ESCCH	; 0	;Lead-in character for escape sequences
  6220                                  	
  6221                                  	;IF	NOT Rainbow
  6222                                  
  6223                                  ESCTAB:	; LABEL BYTE
  6224                                  
  6225                                  	;IF	IBM
  6226 00000A39 40                      	DB	64		; Ctrl-Z - F6
  6227 00000A3A 4D                      	DB	77		; Copy one char - -->
  6228 00000A3B 3B                      	DB	59		; Copy one char - F1
  6229 00000A3C 53                      	DB	83		; Skip one char - DEL
  6230 00000A3D 3C                      	DB	60		; Copy to char - F2
  6231 00000A3E 3E                      	DB	62		; Skip to char - F4
  6232 00000A3F 3D                      	DB	61		; Copy line - F3
  6233 00000A40 3D                      	DB	61		; Kill line (no change to template ) - Not used
  6234 00000A41 3F                      	DB	63		; Reedit line (new template) - F5
  6235 00000A42 4B                      	DB	75		; Backspace - <--
  6236 00000A43 52                      	DB	82		; Enter insert mode - INS (toggle)
  6237 00000A44 52                      	DB	82		; Exit insert mode - INS (toggle)
  6238 00000A45 41                      	DB	65		; Escape character - F7
  6239 00000A46 41                      	DB	65		; End of table
  6240                                  	;ENDIF
  6241                                  
  6242                                  ESCEND: ; LABEL BYTE
  6243                                  
  6244                                  ESCTABLEN EQU ESCEND-ESCTAB
  6245                                  
  6246                                  ESCFUNC: ; LABEL WORD
  6247                                  	
  6248 00000A47 [6114]                  	short_addr  GETCH	; Ignore the escape sequence
  6249 00000A49 [5115]                  	short_addr  TWOESC
  6250 00000A4B [D915]                  	short_addr  EXITINS
  6251 00000A4D [D915]                  	short_addr  ENTERINS
  6252 00000A4F [DB14]                  	short_addr  BACKSP
  6253 00000A51 [C515]                  	short_addr  REEDIT
  6254 00000A53 [C814]                  	short_addr  KILNEW
  6255 00000A55 [5815]                  	short_addr  COPYLIN
  6256 00000A57 [8B15]                  	short_addr  SKIPSTR
  6257 00000A59 [5E15]                  	short_addr  COPYSTR
  6258 00000A5B [8115]                  	short_addr  SKIPONE
  6259 00000A5D [6315]                  	short_addr  COPYONE
  6260 00000A5F [6315]                  	short_addr  COPYONE
  6261 00000A61 [E115]                  	short_addr  CTRLZ
  6262                                  
  6263                                  	;ENDIF
  6264                                  
  6265                                  ; DOSMES.INC (MSDOS 6.0, 1991)
  6266                                  ; ---------------------------------------------------------------------------
  6267                                  ; DOSMES.ASM (MSDOS 2.11, 1983)
  6268                                  
  6269                                  ; OEMFunction key is expected to process a single function
  6270                                  ;   key input from a device and dispatch to the proper
  6271                                  ;   routines leaving all registers UNTOUCHED.
  6272                                  ;
  6273                                  ; Inputs:   CS, SS are DOSGROUP
  6274                                  ; Outputs:  None. This function is expected to JMP to onw of
  6275                                  ;           the following labels:
  6276                                  ;
  6277                                  ;           GetCh       - ignore the sequence
  6278                                  ;           TwoEsc      - insert an ESCChar in the buffer
  6279                                  ;           ExitIns     - toggle insert mode
  6280                                  ;           EnterIns    - toggle insert mode
  6281                                  ;           BackSp      - move backwards one space
  6282                                  ;           ReEdit      - reedit the line with a new template
  6283                                  ;           KilNew      - discard the current line and start from scratch
  6284                                  ;           CopyLin     - copy the rest of the template into the line
  6285                                  ;           SkipStr     - read the next character and skip to it in the template
  6286                                  ;           CopyStr     - read next char and copy from template to line until char
  6287                                  ;           SkipOne     - advance position in template one character
  6288                                  ;           CopyOne     - copy next character in template into line
  6289                                  ;           CtrlZ       - place a ^Z into the template
  6290                                  ; Registers that are allowed to be modified by this function are:
  6291                                  ;           AX, CX, BP
  6292                                  
  6293                                  ; 13/05/2019 - Retro DOS v4.0
  6294                                  ; -------------------------------------
  6295                                  ; DOSCODE:4820h (MSDOS 6.21, MSDOS.SYS)
  6296                                  
  6297                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  6298                                  ; -------------------------------------
  6299                                  ; DOSCODE:4813h (MSDOS 5.0, MSDOS.SYS)
  6300                                  
  6301                                  OEMFunctionKey:
  6302 00000A63 E85B09                  	CALL	_$STD_CON_INPUT_NO_ECHO  ; Get the second byte of the sequence
  6303 00000A66 B10E                    	MOV     CL,ESCTABLEN ; 14	; length of table for scan
  6304 00000A68 57                      	PUSH    DI                      ; save DI (cannot change it!)
  6305 00000A69 BF[390A]                	MOV     DI,ESCTAB		; offset of second byte table
  6306 00000A6C 06                      	push	es
  6307 00000A6D 0E                      	push	cs
  6308 00000A6E 07                      	pop	es
  6309 00000A6F F2AE                    	REPNE   SCASB                   ; Look it up in the table
  6310 00000A71 07                      	pop	es
  6311 00000A72 5F                      	POP     DI                      ; restore DI
  6312 00000A73 D1E1                    	SHL     CX,1                    ; convert byte offset to word
  6313 00000A75 89CD                    	MOV     BP,CX                   ; move to indexable register
  6314                                  	;JMP	word [BP+ESCFUNC]	; Go to the right routine
  6315 00000A77 2EFFA6[470A]            	JMP	word [CS:BP+ESCFUNC]
  6316                                  
  6317                                  ;DOSCODE ENDS
  6318                                  	
  6319                                  ;============================================================================
  6320                                  ; TIME.ASM (MSDOS 6.0, 1991)
  6321                                  ;============================================================================
  6322                                  ; Retro DOS v3.0 - 18/07/2018
  6323                                  
  6324                                  ; SYSCALL.ASM (MSDOS 2.11, 1983)
  6325                                  ;----------------------------------------------------------------------------
  6326                                  ; Retro DOS v2.0 - 13/03/2018
  6327                                  
  6328                                  ;**	TIME.ASM - System Calls and low level routines for DATE and TIME
  6329                                  
  6330                                  	;BREAK <DATE AND TIME - SYSTEM CALLS 42,43,44,45>
  6331                                  
  6332                                  ;**	$GET_DATE - Get Current Date
  6333                                  ;----------------------------------------
  6334                                  ;	ENTRY	none
  6335                                  ;	EXIT	(cx:dx) = current date
  6336                                  ;	USES	all
  6337                                  
  6338                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  6339                                  
  6340                                  _$GET_DATE:	;System call 42
  6341                                  
  6342 00000A7C 16                              PUSH    SS
  6343 00000A7D 1F                              POP     DS
  6344 00000A7E E8B900                          CALL	READTIME        ;Check for rollover to next day
  6345 00000A81 A1[5203]                        MOV     AX,[YEAR]
  6346                                  
  6347                                  ;	WARNING!!!! DAY and MONTH must be adjacently allocated!
  6348                                  
  6349 00000A84 8B1E[5003]                      MOV     BX,[DAY]	; fetch both day and month
  6350 00000A88 E805FA                  	CALL	Get_User_Stack	;Get pointer to user registers
  6351                                          ;MOV    [SI+6],BX  	;DH=month, DL=day
  6352 00000A8B 895C06                  	MOV	[SI+user_env.user_DX],BX
  6353 00000A8E 05BC07                          ADD     AX,1980         ;Put bias back
  6354                                          ;MOV    [SI+4],AX  	;CX=year
  6355 00000A91 894404                  	MOV	[SI+user_env.user_CX],AX
  6356 00000A94 36A0[5603]                      MOV	AL,[SS:WEEKDAY]	;hkn; SS override
  6357                                  RET20:	; 05/11/2022
  6358                                  RET24:	; 18/12/2022
  6359 00000A98 C3                      	RETN
  6360                                  
  6361                                  ;**	$SET_DATE - Set Current Date
  6362                                  ;----------------------------------------
  6363                                  ;	ENTRY	(cx:dx) = current date
  6364                                  ;	EXIT	(al) = -1 iff bad date
  6365                                  ;		(al) = 0 if ok
  6366                                  ;	USES	all
  6367                                  
  6368                                  _$SET_DATE:			;System call 43
  6369                                  
  6370 00000A99 B0FF                            MOV     AL,-1           ;Be ready to flag error
  6371 00000A9B 81E9BC07                        SUB     CX,1980         ;Fix bias in year
  6372                                  	;JC	SHORT RET24	;Error if not big enough
  6373                                          ; 05/11/2022
  6374 00000A9F 72F7                    	jc	short RET20
  6375 00000AA1 83F977                  	CMP     CX,119          ;Year must be less than 2100
  6376 00000AA4 77F2                            JA      SHORT RET24
  6377 00000AA6 08F6                            OR      DH,DH
  6378                                          ;JZ	SHORT RET24
  6379                                   	; 05/11/2022
  6380 00000AA8 74EE                    	jz	short RET20
  6381 00000AAA 08D2                            OR      DL,DL
  6382                                          ;JZ	SHORT RET24	;Error if either month or day is 0
  6383                                  	; 05/11/2022
  6384 00000AAC 74EA                    	jz	short RET20
  6385 00000AAE 80FE0C                          CMP     DH,12           ;Check against max. month
  6386 00000AB1 77E5                            JA      SHORT RET24
  6387 00000AB3 16                              PUSH    SS
  6388 00000AB4 1F                              POP     DS
  6389                                  	;CALL	DODATE
  6390                                  	; 18/12/2022
  6391 00000AB5 E91801                  	jmp	DODATE
  6392                                  ;RET24:  
  6393                                  	;RETN
  6394                                  
  6395                                  ;**	$GET_TIME - Get Current Time
  6396                                  ;----------------------------------------
  6397                                  ;	ENTRY	none
  6398                                  ;	EXIT	(cx:dx) = current time
  6399                                  ;	USES	all
  6400                                  
  6401                                  _$GET_TIME:			;System call 44
  6402                                  
  6403 00000AB8 16                              PUSH    SS
  6404 00000AB9 1F                              POP     DS
  6405 00000ABA E87D00                  	CALL	READTIME
  6406 00000ABD E8D0F9                  	CALL	Get_User_Stack           ;Get pointer to user registers
  6407                                         ;MOV     [SI+6],DX
  6408 00000AC0 895406                  	MOV	[SI+user_env.user_DX],DX
  6409                                         ;MOV     [SI+4],CX
  6410 00000AC3 894C04                  	MOV	[SI+user_env.user_CX],CX
  6411 00000AC6 30C0                            XOR     AL,AL
  6412                                  RET26:  
  6413 00000AC8 C3                      	RETN
  6414                                  
  6415                                  ;**	$SET_TIME - Set Current Time
  6416                                  ;----------------------------------------
  6417                                  ;	ENTRY	(cx:dx) = time
  6418                                  ;	EXIT	(al) = 0 if 0k
  6419                                  ;		(al) = -1 if invalid
  6420                                  ;	USES	ALL
  6421                                  
  6422                                  _$SET_TIME:			;System call 45
  6423                                  
  6424 00000AC9 B0FF                            MOV     AL,-1           ;Flag in case of error
  6425 00000ACB 80FD18                          CMP     CH,24           ;Check hours
  6426 00000ACE 73F8                            JAE     SHORT RET26
  6427 00000AD0 80F93C                          CMP     CL,60           ;Check minutes
  6428 00000AD3 73F3                            JAE     SHORT RET26
  6429 00000AD5 80FE3C                          CMP     DH,60           ;Check seconds
  6430 00000AD8 73EE                            JAE     SHORT RET26
  6431 00000ADA 80FA64                          CMP     DL,100          ;Check 1/100's
  6432 00000ADD 73E9                            JAE     SHORT RET26
  6433 00000ADF 51                              PUSH    CX
  6434 00000AE0 52                              PUSH    DX
  6435 00000AE1 16                              PUSH    SS
  6436 00000AE2 1F                              POP     DS
  6437 00000AE3 BB[B603]                        MOV     BX,TIMEBUF
  6438 00000AE6 B90600                          MOV     CX,6
  6439 00000AE9 31D2                            XOR     DX,DX
  6440 00000AEB 89D0                            MOV     AX,DX
  6441 00000AED 53                              PUSH    BX
  6442 00000AEE E85C3C                  	CALL	SETREAD
  6443 00000AF1 1E                              PUSH    DS
  6444 00000AF2 C536[2E00]                      LDS     SI,[BCLOCK]
  6445 00000AF6 E8DE3B                  	CALL	DEVIOCALL2      ;Get correct day count
  6446 00000AF9 1F                              POP     DS
  6447 00000AFA 5B                              POP     BX
  6448 00000AFB E8823C                  	CALL	SETWRITE
  6449 00000AFE 8F06[BA03]                      POP     WORD [TIMEBUF+4]
  6450 00000B02 8F06[B803]                      POP     WORD [TIMEBUF+2]
  6451 00000B06 C536[2E00]                      LDS     SI,[BCLOCK]
  6452 00000B0A E8CA3B                  	CALL	DEVIOCALL2      ;Set the time
  6453 00000B0D 30C0                            XOR     AL,AL
  6454 00000B0F C3                              RETN
  6455                                  
  6456                                  ; 11/07/2018 - Retro DOS v3.0
  6457                                  ; Retro DOS v2.0 - 14/03/2018
  6458                                  
  6459                                  FOURYEARS EQU 3*365 + 366  ; = 1461 
  6460                                  
  6461                                  ;SUBTTL DATE16, READTIME, DODATE -- GUTS OF TIME AND DATE
  6462                                  ;----------------------------------------------------------
  6463                                  ; Date16 returns the current date in AX, current time in DX
  6464                                  ;   AX - YYYYYYYMMMMDDDDD  years months days
  6465                                  ;   DX - HHHHHMMMMMMSSSSS  hours minutes seconds/2
  6466                                  
  6467                                  DATE16:
  6468                                  	
  6469                                  ;M048	Context DS
  6470                                  ;
  6471                                  ; Since this function can be called thru int 2f we shall not assume that SS
  6472                                  ; is DOSDATA
  6473                                  
  6474                                  	;push	ss
  6475                                  	;pop	ds
  6476                                  
  6477                                  	;getdseg <ds>		; M048
  6478                                  
  6479                                  	; 13/05/2019 - Retro DOS v4.0
  6480 00000B10 2E8E1E[0700]            	mov	ds, [cs:DosDSeg]	
  6481                                  
  6482 00000B15 51                              PUSH    CX
  6483 00000B16 06                              PUSH    ES
  6484 00000B17 E82000                          CALL    READTIME
  6485 00000B1A 07                              POP     ES
  6486 00000B1B D0E1                            SHL     CL,1            ;Minutes to left part of byte
  6487 00000B1D D0E1                            SHL     CL,1
  6488 00000B1F D1E1                            SHL     CX,1            ;Push hours and minutes to left end
  6489 00000B21 D1E1                            SHL     CX,1
  6490 00000B23 D1E1                            SHL     CX,1
  6491 00000B25 D0EE                            SHR     DH,1            ;Count every two seconds
  6492 00000B27 08F1                            OR      CL,DH           ;Combine seconds with hours and minutes
  6493 00000B29 89CA                            MOV     DX,CX
  6494                                  
  6495                                  ;	WARNING! MONTH and YEAR must be adjacently allocated
  6496                                  
  6497 00000B2B A1[5103]                        MOV     AX,[MONTH]	;Fetch month and year
  6498 00000B2E B104                            MOV     CL,4
  6499 00000B30 D2E0                            SHL     AL,CL		;Push month to left to make room for day
  6500 00000B32 D1E0                            SHL     AX,1
  6501 00000B34 59                              POP     CX
  6502 00000B35 0A06[5003]                      OR      AL,[DAY]
  6503                                  RET21:
  6504 00000B39 C3                              RETN
  6505                                  
  6506                                  ;----------------------------------------------------------
  6507                                  
  6508                                  READTIME:
  6509                                  
  6510                                  ;Gets time in CX:DX. Figures new date if it has changed.
  6511                                  ;Uses AX, CX, DX.
  6512                                  
  6513 00000B3A C706[910D]0000          	MOV	word [DATE_FLAG],0 ; reset date flag for CPMIO
  6514 00000B40 56                              PUSH    SI
  6515 00000B41 53                              PUSH    BX
  6516                                  
  6517 00000B42 BB[B603]                        MOV     BX,TIMEBUF
  6518                                  
  6519 00000B45 B90600                          MOV     CX,6
  6520 00000B48 31D2                            XOR     DX,DX
  6521 00000B4A 89D0                            MOV     AX,DX
  6522 00000B4C E8FE3B                  	CALL	SETREAD
  6523 00000B4F 1E                              PUSH    DS
  6524 00000B50 C536[2E00]                      LDS     SI,[BCLOCK]
  6525 00000B54 E8803B                  	CALL	DEVIOCALL2      ;Get correct date and time
  6526 00000B57 1F                              POP     DS
  6527 00000B58 5B                              POP     BX
  6528 00000B59 5E                              POP     SI
  6529 00000B5A A1[B603]                        MOV     AX,[TIMEBUF]
  6530 00000B5D 8B0E[B803]                      MOV     CX,[TIMEBUF+2]
  6531 00000B61 8B16[BA03]                      MOV     DX,[TIMEBUF+4]
  6532 00000B65 3B06[5403]                      CMP     AX,[DAYCNT]     ;See if day count is the same
  6533                                          ;JZ	SHORT RET22
  6534 00000B69 74CE                    	JZ	SHORT RET21 ; 18/07/2018
  6535                                  	;cmp	ax,43830
  6536 00000B6B 3D36AB                          CMP     AX,FOURYEARS*30 ;Number of days in 120 years
  6537 00000B6E 733D                            JAE     SHORT RET22	;Ignore if too large
  6538 00000B70 A3[5403]                        MOV     [DAYCNT],AX
  6539 00000B73 56                              PUSH    SI
  6540 00000B74 51                              PUSH    CX
  6541 00000B75 52                              PUSH    DX              ;Save time
  6542 00000B76 31D2                            XOR     DX,DX
  6543                                  	;mov	cx,1461
  6544 00000B78 B9B505                          MOV     CX,FOURYEARS    ;Number of days in 4 years
  6545 00000B7B F7F1                            DIV     CX              ;Compute number of 4-year units
  6546 00000B7D D1E0                            SHL     AX,1
  6547 00000B7F D1E0                            SHL     AX,1
  6548 00000B81 D1E0                            SHL     AX,1            ;Multiply by 8 (no. of half-years)
  6549 00000B83 89C1                            MOV     CX,AX           ;<240 implies AH=0
  6550                                  
  6551 00000B85 BE[140D]                        MOV     SI,YRTAB        ;Table of days in each year
  6552                                  
  6553 00000B88 E82300                          CALL    DSLIDE          ;Find out which of four years we're in
  6554 00000B8B D1E9                            SHR     CX,1            ;Convert half-years to whole years
  6555 00000B8D 7304                            JNC     SHORT SK	;Extra half-year?
  6556 00000B8F 81C2C800                        ADD     DX,200
  6557                                  SK:
  6558 00000B93 E82400                          CALL    SETYEAR
  6559 00000B96 B101                            MOV     CL,1            ;At least at first month in year
  6560                                  
  6561 00000B98 BE[1C0D]                        MOV     SI,MONTAB       ;Table of days in each month
  6562                                          
  6563 00000B9B E81000                  	CALL    DSLIDE          ;Find out which month we're in
  6564 00000B9E 880E[5103]                      MOV     [MONTH],CL
  6565 00000BA2 42                              INC     DX              ;Remainder is day of month (start with one)
  6566 00000BA3 8816[5003]                      MOV     [DAY],DL
  6567 00000BA7 E89700                          CALL    WKDAY           ;Set day of week
  6568 00000BAA 5A                              POP     DX
  6569 00000BAB 59                              POP     CX
  6570 00000BAC 5E                              POP     SI
  6571                                  RET22:  
  6572 00000BAD C3                      	RETN
  6573                                  
  6574                                  ;----------------------------------------------------------
  6575                                  
  6576                                  DSLIDE:
  6577 00000BAE B400                            MOV     AH,0
  6578                                  DSLIDE1:
  6579 00000BB0 AC                              LODSB			;Get count of days
  6580 00000BB1 39C2                            CMP     DX,AX           ;See if it will fit
  6581                                          ;JB	SHORT RET23	;If not, done
  6582 00000BB3 72F8                    	jb	short RET22 ; 13/05/2019 - Retro DOS v4.0
  6583 00000BB5 29C2                            SUB     DX,AX
  6584 00000BB7 41                              INC     CX              ;Count one more month/year
  6585 00000BB8 EBF6                            JMP     SHORT DSLIDE1
  6586                                  
  6587                                  ;----------------------------------------------------------
  6588                                  
  6589                                  SETYEAR:
  6590                                  
  6591                                  ;Set year with value in CX. Adjust length of February for this year.
  6592                                  
  6593                                  ; NOTE: This can also be called thru int 2f. If this is called then it will
  6594                                  ;       set DS to DOSDATA. Since the only guy calling this should be the DOS
  6595                                  ;	redir, DS will be DOSDATA anyway. It is going to be in-efficient to
  6596                                  ;	preserve DS as CHKYR is also called as a routine.
  6597                                  
  6598                                  	; MSDOS 6.0 (18/07/2018) ; *
  6599                                  
  6600                                  	;GETDSEG DS
  6601                                  
  6602                                  	;PUSH	CS  ; *
  6603                                  	;POP	DS  ; *
  6604                                  
  6605                                  	; 13/05/2019 - Retro DOS v4.0
  6606 00000BBA 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  6607                                  
  6608                                  	; Offset 18CEh in IBMDOS.COM (MSDOS 3.3), 1987
  6609                                  	; 05/11/2022 
  6610                                  	; DOSCODE:4970h in MSDOS.SYS (MSDOS 5.0), 1991 
  6611                                  
  6612 00000BBF 880E[5203]                      MOV     [YEAR],CL
  6613                                  CHKYR:
  6614 00000BC3 F6C103                          TEST    CL,3            ;Check for leap year
  6615 00000BC6 B01C                            MOV     AL,28
  6616 00000BC8 7502                            JNZ     SHORT SAVFEB	;28 days if no leap year
  6617 00000BCA FEC0                            INC     AL              ;Add leap day
  6618                                  SAVFEB:
  6619 00000BCC A2[1D0D]                	mov	[february],al
  6620                                          ;MOV	[MONTAB+1],AL   ;Store for February
  6621                                  RET23:  
  6622 00000BCF C3                      	RETN
  6623                                  
  6624                                  ;----------------------------------------------------------
  6625                                  
  6626                                  DODATE:
  6627 00000BD0 E8F0FF                          CALL    CHKYR           ;Set Feb. up for new year
  6628 00000BD3 88F0                            MOV     AL,DH
  6629                                  
  6630 00000BD5 BB[1B0D]                        MOV     BX,MONTAB-1	;DOSDATA:0D1Bh for MSDOS 6.21
  6631                                  
  6632 00000BD8 D7                              XLAT                    ;Look up days in month
  6633 00000BD9 38D0                            CMP     AL,DL
  6634 00000BDB B0FF                            MOV     AL,-1           ;Restore error flag, just in case
  6635                                          ;JB	SHORT RET25	;Error if too many days
  6636 00000BDD 72F0                            jb	short RET23 ; 18/07/2018
  6637 00000BDF E8D8FF                  	CALL    SETYEAR
  6638                                  ;
  6639                                  ; WARNING! DAY and MONTH must be adjacently allocated
  6640                                  ;
  6641 00000BE2 8916[5003]                      MOV     [DAY],DX	;Set both day and month
  6642 00000BE6 D1E9                            SHR     CX,1
  6643 00000BE8 D1E9                            SHR     CX,1
  6644                                  	;mov	ax,1461
  6645 00000BEA B8B505                          MOV     AX,FOURYEARS
  6646 00000BED 89D3                            MOV     BX,DX
  6647 00000BEF F7E1                            MUL     CX
  6648 00000BF1 8A0E[5203]                      MOV     CL,[YEAR]
  6649 00000BF5 80E103                          AND     CL,3
  6650                                  
  6651 00000BF8 BE[140D]                        MOV     SI,YRTAB
  6652                                  
  6653 00000BFB 89C2                            MOV     DX,AX
  6654 00000BFD D1E1                            SHL     CX,1            ;Two entries per year, so double count
  6655 00000BFF E85200                          CALL    DSUM            ;Add up the days in each year
  6656 00000C02 88F9                            MOV     CL,BH           ;Month of year
  6657                                  
  6658 00000C04 BE[1C0D]                        MOV     SI,MONTAB
  6659                                  
  6660 00000C07 49                              DEC     CX              ;Account for months starting with one
  6661 00000C08 E84900                          CALL    DSUM            ;Add up days in each month
  6662 00000C0B 88D9                            MOV     CL,BL           ;Day of month
  6663 00000C0D 49                              DEC     CX              ;Account for days starting with one
  6664 00000C0E 01CA                            ADD     DX,CX           ;Add in to day total
  6665 00000C10 92                              XCHG    AX,DX           ;Get day count in AX
  6666 00000C11 A3[5403]                        MOV     [DAYCNT],AX
  6667 00000C14 56                              PUSH    SI
  6668 00000C15 53                              PUSH    BX
  6669 00000C16 50                              PUSH    AX
  6670                                  
  6671 00000C17 BB[B603]                        MOV     BX,TIMEBUF
  6672                                  
  6673 00000C1A B90600                          MOV     CX,6
  6674 00000C1D 31D2                            XOR     DX,DX
  6675 00000C1F 89D0                            MOV     AX,DX
  6676 00000C21 53                              PUSH    BX
  6677 00000C22 E8283B                  	CALL	SETREAD
  6678                                  
  6679 00000C25 1E                              PUSH    DS
  6680 00000C26 C536[2E00]                      LDS     SI,[BCLOCK]
  6681 00000C2A E8AA3A                  	CALL	DEVIOCALL2	;Get correct date and time
  6682 00000C2D 1F                              POP     DS
  6683 00000C2E 5B                              POP     BX
  6684 00000C2F E84E3B                  	CALL	SETWRITE
  6685 00000C32 8F06[B603]                      POP     WORD [TIMEBUF]
  6686 00000C36 1E                              PUSH    DS
  6687 00000C37 C536[2E00]                      LDS     SI,[BCLOCK]
  6688 00000C3B E8993A                  	CALL	DEVIOCALL2      ;Set the date
  6689 00000C3E 1F                              POP     DS
  6690 00000C3F 5B                              POP     BX
  6691 00000C40 5E                              POP     SI
  6692                                  WKDAY:
  6693 00000C41 A1[5403]                        MOV     AX,[DAYCNT]
  6694 00000C44 31D2                            XOR     DX,DX
  6695 00000C46 B90700                          MOV     CX,7
  6696 00000C49 40                              INC     AX
  6697 00000C4A 40                              INC     AX              ;First day was Tuesday
  6698 00000C4B F7F1                            DIV     CX              ;Compute day of week
  6699 00000C4D 8816[5603]                      MOV     [WEEKDAY],DL
  6700 00000C51 30C0                            XOR     AL,AL           ;Flag OK
  6701                                  RET25:
  6702 00000C53 C3                      	RETN
  6703                                  
  6704                                  ;----------------------------------------------------------
  6705                                  
  6706                                  ;**	DSUM - Compute the sum of a string of bytes
  6707                                  ;
  6708                                  ;	ENTRY	(cx) = byte count
  6709                                  ;		(ds:si) = byte address
  6710                                  ;		(dx) = sum register, initialized by caller
  6711                                  ;	EXIT	(dx) updated
  6712                                  ;	USES	ax, cx, dx, si, flags
  6713                                  
  6714                                  DSUM:
  6715 00000C54 B400                            MOV     AH,0
  6716 00000C56 E305                    	JCXZ	DSUM9 ; 13/05/2019 - Retro DOS v4.0
  6717                                         ;JCXZ	RET25 ; 18/07/2018
  6718                                  DSUM1:
  6719 00000C58 AC                              LODSB
  6720 00000C59 01C2                            ADD     DX,AX
  6721 00000C5B E2FB                            LOOP    DSUM1
  6722                                  DSUM9:
  6723 00000C5D C3                              RETN
  6724                                  
  6725                                  ;============================================================================
  6726                                  ; GETSET.ASM (MSDOS 6.0, 1991)
  6727                                  ;============================================================================
  6728                                  ; 29/04/2019 - Retro DOS v4.0
  6729                                  ; 18/07/2018 - Retro DOS v3.0 (GETSET.ASM, MSDOS 6.0, 1991)
  6730                                  
  6731                                  ; 12/03/2018 - Retro DOS v2.0 
  6732                                  
  6733                                  ;TITLE	GETSET - GETting and SETting MS-DOS system calls
  6734                                  ;NAME	GETSET
  6735                                  
  6736                                  ;CODE	SEGMENT BYTE PUBLIC  'CODE'
  6737                                  ;       ASSUME  SS:DOSGROUP,CS:DOSGROUP
  6738                                  
  6739                                  ;USERNUM:
  6740                                  ;	DW	0			; 24 bit user number
  6741                                  ;       DB      0
  6742                                  ;;	IF      IBM
  6743                                  ;;OEMNUM: DB    0			; 8 bit OEM number
  6744                                  ;;	ELSE
  6745                                  ;OEMNUM: DB     0FFH			; 8 bit OEM number
  6746                                  ;;	ENDIF
  6747                                  
  6748                                  ;MSVERS:		; MS-DOS version in hex for $GET_VERSION
  6749                                  ;; 08/07/2018 - Retro DOS v3.0
  6750                                  ;MSMAJOR: DB	MAJOR_VERSION	; DOS_MAJOR_VERSION
  6751                                  ;MSMINOR: DB	MINOR_VERSION	; DOS_MINOR_VERSION  
  6752                                  
  6753                                  ;BREAK <$Get_Version -- Return MSDOS version number>
  6754                                  ;----------------------------------------------------------------------------
  6755                                  
  6756                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  6757                                  ; DOSCODE:4A0Fh (MSDOS 5.0 MSDOS.SYS)
  6758                                  
  6759                                  _$GET_VERSION:
  6760                                  
  6761                                  ; Inputs:
  6762                                  ;       None
  6763                                  ; Function:
  6764                                  ;       Return MS-DOS version number
  6765                                  ; Outputs:
  6766                                  ;       OEM number in BH
  6767                                  ;       User number in BL:CX (24 bits)
  6768                                  ;       Version number as AL.AH in binary
  6769                                  ;       NOTE: On pre 1.28 DOSs AL will be zero
  6770                                  
  6771                                  ; MSDOS 6.0
  6772                                  ;
  6773                                  ;	Fake_Count is used to lie about the version numbers to support
  6774                                  ;	old binarys. See ms_table.asm for more info.
  6775                                  ;
  6776                                  ;		if input al = 00
  6777                                  ;		  (bh) = OEM number			
  6778                                  ;		else if input al = 01
  6779                                  ;		  (bh) = version flags
  6780                                  ;		 
  6781                                  ;		       	 bits 0-2 = DOS internal revision
  6782                                  ;		       	 bits 3-7 = DOS type flags
  6783                                  ;		              bit 3    = DOS is in ROM
  6784                                  ;		              bit 4    = DOS in in HMA
  6785                                  ;		              bits 5-7 = reserved
  6786                                  ;               M007 change - only bit 3 is now valid. Other bits
  6787                                  ;               are 0 when AL = 1
  6788                                  
  6789                                  	; MSDOS 3.3 (IBMDOS.COM, offset 196Dh)
  6790                                  	;--------------------------------------
  6791                                  	; MSDOS 6.21 (MSDOS.SYS, DOSCODE:4A1Ch)
  6792                                  
  6793 00000C5E 16                              PUSH    SS
  6794 00000C5F 1F                              POP     DS
  6795 00000C60 8B1E[B403]                      MOV     BX,[USERNUM+2]
  6796 00000C64 8B0E[B203]                      MOV     CX,[USERNUM]
  6797                                  
  6798                                  	; 13/05/2019 - Retro DOS v4.0
  6799                                  
  6800                                  	;If AL == 1, ROMDOS will return BH = dos internal version # &
  6801                                  	;DOS flags
  6802                                  
  6803 00000C68 3C01                    	cmp	AL,1
  6804 00000C6A 7502                    	jne	short Norm_Vers
  6805                                  
  6806                                  ;ifdef ROMDOS
  6807                                  ;	mov	BH,DOSINROM 	; Just set the bit for ROM version
  6808                                  ;				(DOSINROM = 8)
  6809                                  ;else
  6810 00000C6C 30FF                            xor     bh,bh		; Otherwise return 0
  6811                                  ;endif				;M007 end
  6812                                  
  6813                                  Norm_Vers:
  6814                                  	;MOV	AX,[MSVERS]  ; MSDOS 3.3
  6815                                  
  6816                                          	; MSDOS 6.0	; MSVERS is a label in TABLE segment	
  6817                                  	; 13/05/2019 - Retro DOS v4.0
  6818 00000C6E 1E                      	push	ds		; Get the version number from the
  6819 00000C6F 8E1E[3003]              	mov	ds,[CurrentPDB]	; current app's PSP segment
  6820                                  	;mov	ax,[40h]
  6821 00000C73 A14000                  	mov	ax,[PDB.Version] ; AX = DOS version number	
  6822                                  	; 07/12/2022
  6823 00000C76 1F                      	pop	ds
  6824 00000C77 E816F8                  	call	Get_User_Stack
  6825                                  				; Put values for return registers
  6826                                  				; in the proper place on the user's	 
  6827                                  				; stack addressed by DS:SI
  6828                                          ;MOV	[SI+user_env.user_AX],AX
  6829 00000C7A 8904                            MOV	[SI],AX			 
  6830                                  	;MOV	[SI+2],BX		 
  6831 00000C7C 895C02                  	mov	[SI+user_env.user_BX],BX 
  6832                                          ;MOV	[SI+4],CX
  6833 00000C7F 894C04                  	mov	[SI+user_env.user_CX],CX
  6834                                  
  6835 00000C82 C3                      	RETN
  6836                                  
  6837                                  ; 18/07/2018 - Retro DOS v3.0
  6838                                  
  6839                                  ;BREAK <$Get/Set_Verify_on_Write - return/set verify-after-write flag>
  6840                                  ;----------------------------------------------------------------------------
  6841                                  
  6842                                  ;**	$Get_Verify_On_Write - Get Status of Verify on write flag
  6843                                  ;
  6844                                  ;	ENTRY	none
  6845                                  ;	EXIT	(al) = value of VERIFY flag
  6846                                  ;	USES	all
  6847                                  
  6848                                  
  6849                                  _$GET_VERIFY_ON_WRITE:
  6850                                  
  6851                                  ;hkn; SS override
  6852 00000C83 36A0[FF02]              	MOV	AL,[SS:VERFLG]	; Retro DOS v2.0 - 12/03/2018
  6853 00000C87 C3                      	retn
  6854                                  
  6855                                  ;**	$Set_Verify_On_Write - Set Status of Verify on write flag
  6856                                  ;
  6857                                  ;	ENTRY	(al) = value of VERIFY flag
  6858                                  ;	EXIT	none
  6859                                  ;	USES	all
  6860                                  
  6861                                  _$SET_VERIFY_ON_WRITE:
  6862                                  
  6863 00000C88 2401                    	AND	AL,1
  6864                                  ;hkn; SS override
  6865 00000C8A 36A2[FF02]              	MOV	[SS:VERFLG],AL	; Retro DOS v2.0 - 12/03/2018
  6866                                  RET27:	; 18/07/2018
  6867 00000C8E C3                      	retn
  6868                                  
  6869                                  ; 19/07/2018 - Retro DOS v3.0
  6870                                  
  6871                                  ;BREAK <$International - return country-dependent information>
  6872                                  ;----------------------------------------------------------------------------
  6873                                  ;
  6874                                  ; Procedure Name : $INTERNATIONAL
  6875                                  ;
  6876                                  ; Inputs:
  6877                                  ;	MOV	AH,International
  6878                                  ;	MOV	AL,country	(al = 0 => current country)
  6879                                  ;      [MOV	BX,country]
  6880                                  ;	LDS	DX,block
  6881                                  ;	INT	21
  6882                                  ; Function:
  6883                                  ;	give users an idea of what country the application is running
  6884                                  ; Outputs:
  6885                                  ;	IF DX != -1 on input (get country)
  6886                                  ;	  AL = 0 means return current country table.
  6887                                  ;	  0<AL<0FFH means return country table for country AL
  6888                                  ;	  AL = 0FF means return country table for country BX
  6889                                  ;	  No Carry:
  6890                                  ;	     Register BX will contain the 16-bit country code.
  6891                                  ;	     Register AL will contain the low 8 bits of the country code.
  6892                                  ;	     The block pointed to by DS:DX is filled in with the information
  6893                                  ;	     for the particular country.
  6894                                  ;		BYTE  Size of this table excluding this byte and the next
  6895                                  ;		BYTE  Country code represented by this table
  6896                                  ;			A sequence of n bytes, where n is the number specified
  6897                                  ;			by the first byte above and is not > internat_block_max,
  6898                                  ;			in the correct order for being returned by the
  6899                                  ;			INTERNATIONAL call as follows:
  6900                                  ;		WORD	Date format 0=mdy, 1=dmy, 2=ymd
  6901                                  ;		5 BYTE	Currency symbol null terminated
  6902                                  ;		2 BYTE	thousands separator null terminated
  6903                                  ;		2 BYTE	Decimal point null terminated
  6904                                  ;		2 BYTE	Date separator null terminated
  6905                                  ;		2 BYTE	Time separator null terminated
  6906                                  ;		1 BYTE	Bit field.  Currency format.
  6907                                  ;			Bit 0.	=0 $ before #  =1 $ after #
  6908                                  ;			Bit 1.	no. of spaces between # and $ (0 or 1)
  6909                                  ;		1 BYTE	No. of significant decimal digits in currency
  6910                                  ;		1 BYTE	Bit field.  Time format.
  6911                                  ;			Bit 0.	=0 12 hour clock  =1 24 hour
  6912                                  ;		DWORD	Call address of case conversion routine
  6913                                  ;		2 BYTE	Data list separator null terminated.
  6914                                  ;	  Carry:
  6915                                  ;	     Register AX has the error code.
  6916                                  ;	IF DX = -1 on input (set current country)
  6917                                  ;	  AL = 0 is an error
  6918                                  ;	  0<AL<0FFH means set current country to country AL
  6919                                  ;	  AL = 0FF means set current country to country BX
  6920                                  ;	  No Carry:
  6921                                  ;	    Current country SET
  6922                                  ;	    Register AL will contain the low 8 bits of the country code.
  6923                                  ;	  Carry:
  6924                                  ;	     Register AX has the error code.
  6925                                  ;-----------------------------------------------------------------------------
  6926                                  
  6927                                  ;procedure   $INTERNATIONAL,NEAR   ; DOS 3.3
  6928                                  
  6929                                  ; 13/05/2019 - Retro DOS v4.0
  6930                                  ; DOSCODE:4A4Dh (MSDOS 6.21, MSDOS.SYS)
  6931                                  
  6932                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  6933                                  ; DOSCODE:4A40h (MSDOS 5.0, MSDOS.SYS)
  6934                                  
  6935                                  _$INTERNATIONAL:  ; IBMDOS.COM (MSDOS 3.3), offset 1992h
  6936                                  	 
  6937 00000C8F 3CFF                    	CMP	AL,0FFH
  6938 00000C91 7404                    	JZ	short BX_HAS_CODE	; -1 means country code is in BX
  6939 00000C93 88C3                    	MOV	BL,AL			; Put AL country code in BX
  6940 00000C95 30FF                    	XOR	BH,BH
  6941                                  BX_HAS_CODE:
  6942 00000C97 1E                      	PUSH	DS
  6943 00000C98 07                      	POP	ES
  6944 00000C99 52                      	PUSH	DX
  6945 00000C9A 5F                      	POP	DI			; User buffer to ES:DI
  6946                                  
  6947                                  ;hkn; SS is DOSDATA
  6948                                  ;	context DS
  6949                                  
  6950 00000C9B 16                      	push	ss
  6951 00000C9C 1F                      	pop	ds
  6952                                  
  6953 00000C9D 83FFFF                  	CMP	DI,-1
  6954 00000CA0 7465                    	JZ	short international_set
  6955 00000CA2 09DB                    	OR	BX,BX
  6956 00000CA4 7505                    	JNZ	short international_find
  6957                                  
  6958                                  ;hkn; country_cdpg is in DOSDATA segment.
  6959 00000CA6 BE[0012]                	MOV	SI,COUNTRY_CDPG
  6960                                  
  6961 00000CA9 EB41                    	JMP	SHORT international_copy
  6962                                  
  6963                                  international_find:
  6964 00000CAB BD0000                  	MOV	BP,0			 ; flag it for GetCntry only
  6965 00000CAE E80B00                  	CALL	international_get
  6966 00000CB1 725C                    	JC	short errtn
  6967 00000CB3 83FB00                  	CMP	BX,0			 ; nlsfunc finished it ?
  6968 00000CB6 7534                    	JNZ	SHORT international_copy ; no, copy by myself
  6969 00000CB8 89D3                    	MOV	BX,DX			 ; put country back
  6970 00000CBA EB40                    	JMP	SHORT international_ok3
  6971                                  
  6972                                  international_get:
  6973 00000CBC BE[0012]                	MOV	SI,COUNTRY_CDPG
  6974                                  
  6975                                  ;hkn; country_cdpg is in DOSDATA segment.
  6976                                  ;hkn; use ss override to access COUNTRY_CDPG fields
  6977                                  
  6978                                  	; MSDOS 3.3
  6979                                  	;;cmp	bx,[SI+63h]
  6980                                  	;CMP	BX,[SI+DOS_CCDPG.ccDosCountry]
  6981                                  	;jz	short RET27
  6982                                  
  6983                                  	; 13/05/2019 - Retro DOS v4.0
  6984                                  
  6985                                  	; MSDOS 6.0
  6986                                  	;cmp	bx,[ss:si+68h]
  6987 00000CBF 363B5C68                	CMP	BX,[ss:SI+DOS_CCDPG.ccDosCountry] ; = current country id
  6988 00000CC3 74C9                    	jz	short RET27			; return if equal
  6989                                  
  6990 00000CC5 89DA                    	MOV	DX,BX
  6991 00000CC7 31DB                    	XOR	BX,BX			; bx = 0, default code page
  6992                                  	;CallInstall NLSInstall,NLSFUNC,0 ; check if NLSFUNC in memory
  6993 00000CC9 B80014                  	mov	ax,1400h
  6994 00000CCC CD2F                    	int     2Fh	; - Multiplex - NLSFUNC.COM - INSTALLATION CHECK
  6995                                  			; Return: AL = 00h not installed, OK to install
  6996                                  			; 01h not installed, not OK
  6997                                  			; FFh installed
  6998 00000CCE 3CFF                    	CMP	AL,0FFH
  6999 00000CD0 7516                    	JNZ	short interr		; not in memory
  7000                                  	;cmp	bp,0
  7001 00000CD2 09ED                    	or	bp,bp			; GetCntry ?
  7002 00000CD4 7507                    	JNZ	short stcdpg
  7003                                  	
  7004                                  	;CallInstall GetCntry,NLSFUNC,4	; get country info
  7005 00000CD6 B80414                  	mov     ax,1404h
  7006 00000CD9 CD2F                    	int     2Fh	; - Multiplex - NLSFUNC.COM - GET COUNTRY INFO
  7007                                  			; BX = code page, DX = country code,
  7008                                  			; DS:SI -> internal code page structure
  7009                                  			; ES:DI -> user buffer
  7010                                  			; Return: AL = status
  7011                                  
  7012 00000CDB EB05                    	JMP	short chkok
  7013                                  	
  7014                                  	;nop
  7015                                  
  7016                                  stcdpg:
  7017                                  	;CallInstall SetCodePage,NLSFUNC,3  ; set country info
  7018 00000CDD B80314                  	mov     ax,1403h
  7019 00000CE0 CD2F                    	int     2Fh	; - Multiplex - NLSFUNC.COM - SET COUNTRY INFO
  7020                                  			; DS:SI -> internal code page structure
  7021                                  			; BX = code page, DX = country code
  7022                                  			; Return: AL = status
  7023                                  chkok:
  7024 00000CE2 08C0                    	or	al,al			; success ?
  7025                                  	;retz				; yes
  7026 00000CE4 74A8                    	jz	short RET27
  7027                                  
  7028                                  setcarry:
  7029 00000CE6 F9                      	STC				; set carry
  7030 00000CE7 C3                      	retn
  7031                                  interr:
  7032 00000CE8 B0FF                    	MOV	AL,0FFH			; flag nlsfunc error
  7033 00000CEA EBFA                    	JMP	short setcarry
  7034                                  
  7035                                  international_copy:
  7036                                  
  7037                                  ;hkn; country_cdpg is in DOSDATA segment.
  7038                                  ;hkn; use ss override to access COUNTRY_CDPG fields
  7039                                  
  7040                                  	; MSDOS 3.3
  7041                                  	;;mov	bx,[SI+63h]
  7042                                  	;mov	BX,[SI+DOS_CCDPG.ccDosCountry]
  7043                                  	;mov	SI,COUNTRY_CDPG+DOS_CCDPG.ccDFormat ; 08/09/2018
  7044                                  
  7045                                  	; 13/05/2019 - Retro DOS v4.0
  7046                                  
  7047                                  	; MSDOS 6.0
  7048                                  	;mov	bx,[ss:si+68h]
  7049 00000CEC 368B5C68                	MOV	BX,[ss:SI+DOS_CCDPG.ccDosCountry] ; = current country id
  7050 00000CF0 BE[6C12]                	MOV	SI,COUNTRY_CDPG+DOS_CCDPG.ccDFormat ; COUNTRY_CDPG + 108
  7051                                  
  7052                                  	;mov	cx,24
  7053 00000CF3 B91800                  	MOV	CX,OLD_COUNTRY_SIZE
  7054                                  
  7055                                  	; MSDOS 6.0
  7056                                  
  7057                                  ;hkn;	must set up DS to SS so that international info can be copied
  7058                                  	
  7059 00000CF6 1E                      	push	ds
  7060                                  
  7061 00000CF7 16                      	push	ss			; cs -> ss
  7062 00000CF8 1F                      	pop	ds
  7063                                  
  7064 00000CF9 F3A4                    	REP	MOVSB			; copy country info
  7065                                  
  7066                                  	; MSDOS 6.0
  7067                                  
  7068 00000CFB 1F                      	pop	ds	;hkn;	restore ds
  7069                                  
  7070                                  international_ok3:
  7071 00000CFC E891F7                  	call	Get_User_Stack
  7072                                  ;ASSUME	DS:NOTHING
  7073                                  	;MOV	[SI+2],BX
  7074 00000CFF 895C02                  	MOV	[SI+user_env.user_BX],BX
  7075                                  international_ok:
  7076 00000D02 89D8                    	MOV	AX,BX			; Return country code in AX too.
  7077                                  ;SYS_RET_OK_jmp:
  7078                                  	; 05/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  7079                                  nono:	; 15/12/2022
  7080                                  SYS_RET_OK_jmp:
  7081 00000D04 E943F9                  	jmp	SYS_RET_OK
  7082                                  
  7083                                  international_set:
  7084                                  
  7085                                  ;hkn; ASSUME	DS:DOSGROUP
  7086                                  ;ASSUME	DS:DOSDATA
  7087                                  
  7088 00000D07 BD0100                  	MOV	BP,1			; flag it for SetCodePage only
  7089 00000D0A E8AFFF                  	CALL	international_get
  7090 00000D0D 73F3                    	JNC	short international_ok
  7091                                  errtn:
  7092 00000D0F 3CFF                    	CMP	AL,0FFH
  7093 00000D11 7403                    	JZ	short errtn2
  7094                                  errtn1:
  7095 00000D13 E93DF9                  	jmp	SYS_RET_ERR		; return what we got from NLSFUNC
  7096                                  errtn2:
  7097                                  	;error	error_invalid_function	; NLSFUNC not existent
  7098                                  
  7099                                  	;mov	al,1
  7100 00000D16 B001                    	mov	al,error_invalid_function 
  7101 00000D18 EBF9                    	jmp	short errtn1 ; 13/05/2019 - Retro DOS v4.0
  7102                                  ;errtn3:
  7103                                  ;	jmp	SYS_RET_ERR
  7104                                  
  7105                                  ;EndProc $INTERNATIONAL
  7106                                  
  7107                                  ; 19/07/2018
  7108                                  
  7109                                  ;BREAK <$GetExtCntry - return extended country-dependent information>
  7110                                  
  7111                                  ;----------------------------------------------------------------------------
  7112                                  ;
  7113                                  ; Procedure Name : $GetExtCntry
  7114                                  ;
  7115                                  ; Inputs:
  7116                                  ;	if AL >= 20H
  7117                                  ;	  AL= 20H    capitalize single char, DL= char
  7118                                  ;	      21H    capitalize string, CX= string length
  7119                                  ;	      22H    capitalize ASCIIZ string
  7120                                  ;	      23H    YES/NO check, DL=1st char DH= 2nd char (DBCS)
  7121                                  ;	      80H bit 0 = use normal upper case table
  7122                                  ;		      1 = use file upper case table
  7123                                  ;	   DS:DX points to string
  7124                                  ;
  7125                                  ;	else
  7126                                  ;
  7127                                  ;	MOV	AH,GetExtCntry	 ; DOS 3.3
  7128                                  ;	MOV	AL,INFO_ID	( info type,-1 selects all )
  7129                                  ;	MOV	BX,CODE_PAGE	( -1 = active code page )
  7130                                  ;	MOV	DX,COUNTRY_ID	( -1 = active country )
  7131                                  ;	MOV	CX,SIZE 	( amount of data to return )
  7132                                  ;	LES	DI,COUNTRY_INFO ( buffer for returned data )
  7133                                  ;	INT	21
  7134                                  ; Function:
  7135                                  ;	give users extended country dependent information
  7136                                  ;	or capitalize chars
  7137                                  ; Outputs:
  7138                                  ;	  No Carry:
  7139                                  ;	     extended country info is succesfully returned
  7140                                  ;	  Carry:
  7141                                  ;	     Register AX has the error code.
  7142                                  ;	     AX=0, NO	 for YES/NO CHECK
  7143                                  ;		1, YES
  7144                                  ;----------------------------------------------------------------------------
  7145                                  
  7146                                  ;procedure   $GetExtCntry,NEAR	; DOS 3.3
  7147                                  
  7148                                  	; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  7149                                  
  7150                                  	; MSDOS 6.0
  7151                                  _$GetExtCntry:
  7152 00000D1A 3C20                    	CMP	AL,CAP_ONE_CHAR 	; < 20H ?
  7153 00000D1C 7269                    	JB	short notcap
  7154                                  capcap: 				;
  7155 00000D1E A880                    	TEST	AL,UPPER_TABLE	; 80h	; which upper case table
  7156 00000D20 7505                    	JNZ	short fileupper		; file upper case
  7157                                  
  7158                                  ;hkn; UCASE_TAB in DOSDATA
  7159 00000D22 BB[AF0A]                	MOV	BX,UCASE_TAB+2		; get normal upper case
  7160 00000D25 EB03                    	JMP	SHORT capit
  7161                                  
  7162                                  fileupper:
  7163                                  ;hkn; FILE_UCASE_TAB in DOSDATA
  7164 00000D27 BB[310B]                	MOV	BX,FILE_UCASE_TAB+2 ; get file upper case
  7165                                  capit:					;
  7166 00000D2A 3C20                    	CMP	AL,CAP_ONE_CHAR 	; cap one char ?
  7167 00000D2C 750D                    	JNZ	short chkyes		; no
  7168 00000D2E 88D0                    	MOV	AL,DL			; set up AL
  7169 00000D30 E89E43                  	call	GETLET3 		; upper case it
  7170 00000D33 E85AF7                  	call	Get_User_Stack		; get user stack
  7171                                  	;mov	[si+6],al
  7172 00000D36 884406                  	MOV	[SI+user_env.user_DX],AL ; user's DL=AL
  7173 00000D39 EBC9                    	JMP	SHORT nono		; done
  7174                                  chkyes: 				;
  7175 00000D3B 3C23                    	CMP	AL,CHECK_YES_NO	; 23h	; check YES or NO ?
  7176 00000D3D 7522                    	JNZ	short capstring		; no
  7177                                  
  7178 00000D3F 31C0                    	XOR	AX,AX			; presume NO
  7179                                  		      
  7180                                  ;hkn; NLS_YES, NLS_NO, NLS_yes2, NLS_no2 is defined in msdos.cl3 which is
  7181                                  ;hkn; included in yesno.asm in the DOSCODE segment.
  7182                                  
  7183                                  	; 06/08/2018 - Retro DOS v3.0
  7184                                  	; 13/05/2019 - Retro DOS v4.0
  7185                                  	;cmp	dl,'Y'
  7186 00000D41 2E3A16[330A]            	CMP	DL,[cs:NLS_YES]		; is 'Y' ?
  7187 00000D46 7416                    	JZ	short yesyes		; yes
  7188                                  	;cmp	dl,'y'
  7189 00000D48 2E3A16[350A]            	CMP	DL,[cs:NLS_yes2]	; is 'y' ?
  7190 00000D4D 740F                    	JZ	short yesyes		; yes
  7191                                  	;cmp	dl,'N'
  7192 00000D4F 2E3A16[340A]            	CMP	DL,[cs:NLS_NO]		; is  'N'?
  7193 00000D54 74AE                    	JZ	short nono		; no
  7194                                  	;cmp	dl,'n'
  7195 00000D56 2E3A16[360A]            	CMP	DL,[cs:NLS_no2]		; is 'n' ?
  7196 00000D5B 74A7                    	JZ	short nono		; no
  7197                                  ;dbcs_char:				;
  7198 00000D5D 40                      	INC	AX			; not YES or NO
  7199                                  yesyes: 				;
  7200 00000D5E 40                      	INC	AX			; return 1
  7201                                  	; 15/12/2022
  7202                                  ;nono:	
  7203 00000D5F EBA3                    	jmp	short SYS_RET_OK_jmp	;
  7204                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  7205                                  	;jmp	SYS_RET_OK		; done
  7206                                  
  7207                                  capstring:				;
  7208 00000D61 89D6                    	MOV	SI,DX			; si=dx
  7209 00000D63 3C21                    	CMP	AL,CAP_STRING	; 21h	; cap string ?
  7210 00000D65 750F                    	JNZ	short capascii		; no
  7211 00000D67 09C9                    	OR	CX,CX			; check count 0
  7212 00000D69 7499                    	JZ	short nono		; yes finished
  7213                                  concap: 				;
  7214 00000D6B AC                      	LODSB				; get char
  7215 00000D6C E86243                  	call	GETLET3 		; upper case it
  7216 00000D6F 8844FF                  	MOV	byte [SI-1],AL		; store back
  7217                                  ;next99: 				;
  7218 00000D72 E2F7                    	LOOP	concap			; continue
  7219 00000D74 EB8E                    	JMP	short nono		; done
  7220                                  capascii:				;
  7221 00000D76 3C22                    	CMP	AL,CAP_ASCIIZ	; 22h	; cap ASCIIZ string ?
  7222 00000D78 7545                    	JNZ	short capinval		; no
  7223                                  concap2:				;
  7224 00000D7A AC                      	LODSB				; get char
  7225 00000D7B 08C0                    	or	al,al			; end of string ?
  7226 00000D7D 7485                    	JZ	short nono		; yes
  7227 00000D7F E84F43                  	call	GETLET3 		; upper case it
  7228 00000D82 8844FF                  	MOV	[SI-1],AL		; store back
  7229 00000D85 EBF3                    	JMP	short concap2 		; continue
  7230                                  
  7231                                  	; MSDOS 3.3 (& MSDOS 6.0)
  7232                                  
  7233                                  ; Offset 1A19h in IBMDOS.COM (MSDOS 3.3), 1987 	
  7234                                  ; _$GetExtCntry:
  7235                                  
  7236                                  notcap:
  7237 00000D87 83F905                  	CMP	CX,5			; minimum size is 5
  7238 00000D8A 7279                    	jb	short sizeerror
  7239                                  
  7240                                  GEC_CONT:
  7241                                  ;hkn; SS is DOSDATA
  7242                                  	;context DS
  7243                                  
  7244 00000D8C 16                      	push	ss
  7245                                  	;pop	es  ; ! (Retro DOS v3.0 BUG) !
  7246 00000D8D 1F                      	pop	ds  ; 13/05/2019 - Retro DOS v4.0	
  7247                                  	
  7248                                  ;hkn; COUNTRY_CDPG is in DOSDATA
  7249 00000D8E BE[0012]                	MOV	SI,COUNTRY_CDPG
  7250                                  
  7251 00000D91 83FAFF                  	CMP	DX,-1			; active country ?
  7252 00000D94 7503                    	JNZ	short GETCDPG 		; no
  7253                                  
  7254                                  ;hkn; use DS override to accesss country_cdpg fields
  7255                                  	;;mov	dx,[si+63h] ; MSDOS 3.3
  7256                                  	;mov	dx,[si+68h] ; MSDOS 6.0
  7257 00000D96 8B5468                  	MOV	DX,[SI+DOS_CCDPG.ccDosCountry]
  7258                                  					; get active country id;smr;use DS
  7259                                  GETCDPG:
  7260 00000D99 83FBFF                  	CMP	BX,-1			; active code page?
  7261 00000D9C 7503                    	JNZ	short CHKAGAIN		; no, check again
  7262                                  
  7263                                  ;hkn; use DS override to accesss country_cdpg fields
  7264                                  	;;mov	bx,[si+65h] ; MSDOS 3.3	
  7265                                  	;mov	bx,[si+6Ah] ; MSDOS 6.0
  7266 00000D9E 8B5C6A                  	MOV	BX,[SI+DOS_CCDPG.ccDosCodePage]
  7267                                  					; get active code page id;smr;Use DS
  7268                                  CHKAGAIN:
  7269                                  	;cmp	dx,[si+68h] ; MSDOS 6.0
  7270 00000DA1 3B5468                  	CMP	DX,[SI+DOS_CCDPG.ccDosCountry]
  7271                                  					; same as active country id?;smr;use DS
  7272 00000DA4 7552                    	JNZ	short CHKNLS		; no
  7273                                  	;cmp	bx,[si+6Ah] ; MSDOS 6.0	
  7274 00000DA6 3B5C6A                  	CMP	BX,[SI+DOS_CCDPG.ccDosCodePage]	
  7275                                  					; same as active code pg id?;smr;use DS
  7276 00000DA9 754D                    	JNZ	short CHKNLS		; no
  7277                                  CHKTYPE:
  7278                                  	;mov	bx,[si+48h]
  7279 00000DAB 8B5C48                  	MOV	BX,[SI+DOS_CCDPG.ccSysCodePage]	
  7280                                  					; bx = sys code page id;smr;use DS
  7281 00000DAE 51                      	PUSH	CX			; save cx
  7282                                  	;mov	cx,[si+4Ah]
  7283 00000DAF 8B4C4A                  	MOV	CX,[SI+DOS_CCDPG.ccNumber_of_entries]  ;smr;use DS
  7284                                  	;mov	si,COUNTRY_CDPG+76
  7285 00000DB2 BE[4C12]                	MOV	SI,COUNTRY_CDPG+DOS_CCDPG.ccSetUcase   ;smr;CDPG in DOSDATA
  7286                                  NXTENTRY:
  7287 00000DB5 3A04                    	CMP	AL,[SI] 		; compare info type;smr;use DS
  7288 00000DB7 740B                    	JZ	short FOUNDIT
  7289 00000DB9 83C605                  	ADD	SI,5			; next entry
  7290 00000DBC E2F7                    	LOOP	NXTENTRY
  7291 00000DBE 59                      	POP	CX
  7292                                  capinval:
  7293                                  	;error	error_invalid_function	; info type not found
  7294                                  	;mov	al,1
  7295 00000DBF B001                    	mov	al,error_invalid_function
  7296                                  ;SYS_RET_ERR_jmp:
  7297                                  	;jmp	SYS_RET_ERR
  7298                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  7299                                  SYS_RET_ERR_jmp:
  7300 00000DC1 E98FF8                  	jmp	SYS_RET_ERR	
  7301                                  
  7302                                  FOUNDIT:
  7303 00000DC4 A4                      	MOVSB				; move info id byte
  7304 00000DC5 59                      	POP	CX			; restore char count
  7305                                  	;cmp	al,1
  7306 00000DC6 3C01                    	CMP	AL,SetCountryInfo	; select country info type ?
  7307 00000DC8 7415                    	JZ	short setsize
  7308 00000DCA B90400                  	MOV	CX,4			; 4 bytes will be moved
  7309 00000DCD B80500                  	MOV	AX,5			; 5 bytes will be returned in CX
  7310                                  OK_RETN:
  7311 00000DD0 F3A4                    	REP	MOVSB			; copy info
  7312 00000DD2 89C1                    	MOV	CX,AX			; CX = actual length returned
  7313 00000DD4 89D8                    	MOV	AX,BX			; return sys code page in ax
  7314                                  GETDONE:
  7315 00000DD6 E8B7F6                  	call	Get_User_Stack		; return actual length to user's CX
  7316                                  	;mov	[si+4],cx 
  7317 00000DD9 894C04                  	MOV	[SI+user_env.user_CX],CX
  7318                                  	;jmp	SYS_RET_OK
  7319                                  	; 15/12/2022
  7320                                  	; 25/06/2019
  7321 00000DDC E96EF8                  	jmp	SYS_RET_OK_clc
  7322                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  7323                                  	; 15/12/2022
  7324                                  ;nono_jmp:
  7325                                  	;jmp	short nono
  7326                                  setsize:
  7327 00000DDF 83E903                  	SUB	CX,3			; size after length field
  7328 00000DE2 390C                    	CMP	[SI],CX			; less than table size ;smr;use ds
  7329 00000DE4 7302                    	JAE	short setsize2		; no
  7330 00000DE6 8B0C                    	MOV	CX,[SI]			; truncate to table size ;smr;use ds
  7331                                  setsize2:
  7332 00000DE8 26890D                  	MOV	[ES:DI],CX		; copy actual length to user's
  7333 00000DEB 83C702                  	ADD	DI,2			; update index
  7334 00000DEE 83C602                  	ADD	SI,2
  7335 00000DF1 89C8                    	MOV	AX,CX
  7336 00000DF3 83C003                  	ADD	AX,3			; AX has the actual length
  7337 00000DF6 EBD8                    	JMP	short OK_RETN 		; go move it
  7338                                  CHKNLS:
  7339 00000DF8 30E4                    	XOR	AH,AH
  7340 00000DFA 50                      	PUSH	AX			; save info type
  7341 00000DFB 5D                      	POP	BP			; bp = info type
  7342                                  	
  7343                                  	;CallInstall NLSInstall,NLSFUNC,0 ; check if NLSFUNC in memory
  7344 00000DFC B80014                  	mov     ax,1400h
  7345 00000DFF CD2F                    	int     2Fh     ; - Multiplex - NLSFUNC.COM - INSTALLATION CHECK
  7346                                  			; Return: AL = 00h not installed, OK to install
  7347                                  			; 01h not installed, not OK
  7348                                  			; FFh installed
  7349 00000E01 3CFF                    	CMP	AL,0FFH
  7350 00000E03 7404                    	JZ	short NLSNXT		; in memory
  7351                                  
  7352                                  sizeerror:
  7353                                  	;error	error_invalid_function
  7354                                  	;mov	al,1
  7355 00000E05 B001                    	mov	al,error_invalid_function
  7356                                  	;jmp	SYS_RET_ERR
  7357                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  7358                                  sys_ret_err_jmp2:
  7359 00000E07 EBB8                    	jmp	short SYS_RET_ERR_jmp
  7360                                  
  7361                                  NLSNXT: 
  7362                                  	;CallInstall GetExtInfo,NLSFUNC,2 ;get extended info
  7363 00000E09 B80214                  	mov     ax,1402h
  7364 00000E0C CD2F                    	int     2Fh	; - Multiplex - NLSFUNC.COM - GET COUNTRY INFO
  7365                                  			; BP = subfunction, BX = code page
  7366                                  			; DX = country code, DS:SI -> internal code page structure
  7367                                  			; ES:DI -> user buffer, CX = size of user buffer
  7368                                  			; Return: AL = status
  7369                                  			; 00h successful
  7370                                  			; else DOS error code
  7371                                  
  7372 00000E0E 3C00                    	CMP	AL,0			; success ?
  7373 00000E10 7505                    	JNZ	short NLSERROR
  7374                                  	;mov	ax,[si+48h] ; 13/05/2019 
  7375 00000E12 8B4448                  	MOV	AX,[SI+DOS_CCDPG.ccSysCodePage]	
  7376                                  			; ax = sys code page id;smr;use ds;
  7377                                  			;BUGBUG;check whether DS is OK after the above calls
  7378 00000E15 EBBF                    	JMP	short GETDONE
  7379                                  seterr:
  7380                                  	; 15/12/2022
  7381                                  NLSERROR:
  7382                                  	;jmp	SYS_RET_ERR		; return what is got from NLSFUNC
  7383                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  7384                                  	;jmp	short sys_ret_err_jmp2
  7385                                  	; 15/12/2022
  7386 00000E17 EBA8                    	jmp	short SYS_RET_ERR_jmp
  7387                                  
  7388                                  ;EndProc $GetExtCntry
  7389                                  
  7390                                  ; 13/05/2019 - Retro DOS v4.0
  7391                                  ; DOSCODE:4BD6h (MSDOS 6.21, MSDOS.SYS)
  7392                                  
  7393                                  ;BREAK <$GetSetCdPg - get or set global code page>
  7394                                  ;----------------------------------------------------------------------------
  7395                                  ;**	$GetSetCdPg - Get or Set Global Code Page
  7396                                  ;
  7397                                  ;   System call format:
  7398                                  ;
  7399                                  ;	MOV	AH,GetSetCdPg	; DOS 3.3
  7400                                  ;	MOV	AL,n		; n = 1 : get code page, n = 2 : set code page
  7401                                  ;	MOV	BX,CODE_PAGE	(set code page only)
  7402                                  ;	INT	21
  7403                                  ;
  7404                                  ;	ENTRY	(al) = n
  7405                                  ;		(bx) = code page
  7406                                  ;	EXIT	'C' clear
  7407                                  ;		  global code page is set	(set global code page)
  7408                                  ;		  (BX) = active code page id	(get global code page)
  7409                                  ;		  (DX) = system code page id	(get global code page)
  7410                                  ;		'C' set
  7411                                  ;		  (AX) = error code
  7412                                  
  7413                                  ;procedure  $GetSetCdPg,NEAR   ; DOS 3.3
  7414                                  
  7415                                  	; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  7416                                  	; DOSCODE:4BC9h
  7417                                  
  7418                                  _$GetSetCdPg:
  7419                                  
  7420                                  ;hkn; SS is DOSDATA
  7421                                  	;context DS
  7422                                  
  7423 00000E19 16                      	push	ss
  7424 00000E1A 1F                      	pop	ds
  7425                                  
  7426                                  ;hkn; COUNTRY_CDPG is in DOSDATA
  7427 00000E1B BE[0012]                	MOV	SI,COUNTRY_CDPG	  ; (DOSDATA:122Ah for MSDOS 6.21)
  7428                                  
  7429 00000E1E 3C01                    	CMP	AL,1		       ; get global code page
  7430 00000E20 7512                    	JNZ	short setglpg 	       ; set global cod epage
  7431                                  	
  7432                                  	;;mov	bx,[si+65h] ; MSDOS 3.3
  7433                                  	;mov	bx,[si+6Ah] ; MSDOS 6.0
  7434 00000E22 8B5C6A                  	MOV	BX,[SI+DOS_CCDPG.ccDosCodePage]
  7435                                  					; get active code page id;smr;use ds
  7436                                  	;mov	dx,[si+48h]
  7437 00000E25 8B5448                  	MOV	DX,[SI+DOS_CCDPG.ccSysCodePage]
  7438                                  				  	; get sys code page id;smr;use ds
  7439 00000E28 E865F6                  	call	Get_User_Stack
  7440                                  ;ASSUME DS:NOTHING
  7441                                  	;mov	[si+2],bx
  7442 00000E2B 895C02                  	MOV	[SI+user_env.user_BX],BX ; update returned bx
  7443                                  	;mov	[si+6],dx
  7444 00000E2E 895406                  	MOV	[SI+user_env.user_DX],DX ; update returned dx
  7445                                  OK_RETURN:
  7446                                  	; 15/12/2022
  7447                                  	;transfer SYS_RET_OK
  7448 00000E31 E916F8                  	jmp	SYS_RET_OK
  7449                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  7450                                  	;jmp	short nono_jmp
  7451                                  
  7452                                  ;hkn; ASSUME DS:DOSGROUP
  7453                                  ;ASSUME	DS:DOSDATA
  7454                                  
  7455                                  setglpg:
  7456 00000E34 3C02                    	CMP	AL,2
  7457 00000E36 7531                    	JNZ	short nomem
  7458                                  	
  7459                                  	;;mov	dx,[si+63h] ; MSDOS 3.3
  7460                                  	;mov	dx,[si+68h] ; MSDOS 6.0
  7461 00000E38 8B5468                  	MOV	DX,[SI+DOS_CCDPG.ccDosCountry]	;smr;use ds
  7462                                  	
  7463                                  	;CallInstall NLSInstall,NLSFUNC,0 ; check if NLSFUNC in memory
  7464 00000E3B B80014                  	mov     ax,1400h
  7465 00000E3E CD2F                    	int     2Fh	; - Multiplex - NLSFUNC.COM - INSTALLATION CHECK
  7466                                  			; Return: AL = 00h not installed, OK to install
  7467                                  			; 01h not installed, not OK
  7468                                  			; FFh installed
  7469 00000E40 3CFF                    	CMP	AL,0FFH
  7470 00000E42 7525                    	JNZ	short nomem		; not in memory
  7471                                  
  7472                                  	;CallInstall SetCodePage,NLSFUNC,1 ;set the code page
  7473 00000E44 B80114                  	mov     ax,1401h
  7474 00000E47 CD2F                    	int     2Fh	; - Multiplex - NLSFUNC.COM - CHANGE CODE PAGE
  7475                                  			; DS:SI -> internal code page structure
  7476                                  			; BX = new code page, DX = country code???
  7477                                  			; Return: AL = status
  7478                                  			; 00h successful
  7479                                  			; else DOS error code
  7480                                  	;cmp	al,0
  7481 00000E49 08C0                    	or	al,al			; success ?
  7482 00000E4B 74E4                    	JZ	short OK_RETURN		; yes
  7483                                  
  7484 00000E4D 3C41                    	CMP	AL,65			; set device code page failed
  7485 00000E4F 75C6                    	JNZ	short seterr
  7486 00000E51 B84100                  	MOV	AX,65
  7487 00000E54 A3[2403]                	MOV	[EXTERR],AX
  7488                                  	;mov	byte [EXTERR_ACTION],6
  7489                                  	;mov	byte [EXTERR_CLASS],5
  7490                                  	;mov	byte [EXTERR_LOCUS],4
  7491 00000E57 C606[2603]06            	MOV	byte [EXTERR_ACTION],errACT_Ignore
  7492 00000E5C C606[2703]05            	MOV	byte [EXTERR_CLASS],errCLASS_HrdFail
  7493 00000E61 C606[2303]04            	MOV	byte [EXTERR_LOCUS],errLOC_SerDev
  7494                                  	;transfer From_GetSet
  7495 00000E66 E9F2F7                  	jmp	From_GetSet
  7496                                  
  7497                                  	; 15/12/2022
  7498                                  ;seterr:
  7499                                  	;;;transfer SYS_RET_ERR
  7500                                  	;;jmp	SYS_RET_ERR
  7501                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  7502                                  	;jmp	short NLSERROR
  7503                                  
  7504                                  nomem:
  7505                                  	;error	error_invalid_function ; function not defined
  7506                                  	;mov	al,1
  7507 00000E69 B001                    	mov	al,error_invalid_function
  7508 00000E6B EBAA                    	jmp	short seterr
  7509                                  
  7510                                  ;EndProc $GetSetCdPg
  7511                                  
  7512                                  ; 13/05/2019 - Retro DOS v4.0
  7513                                  ; DOSCODE:4C2Bh (MSDOS 6.21, MSDOS.SYS)
  7514                                  
  7515                                  ;BREAK <$Get_Drive_Freespace -- Return bytes of free disk space on a drive>
  7516                                  ;----------------------------------------------------------------------------
  7517                                  ;**	$Get_Drive_Freespace - Return amount of drive free space
  7518                                  ;
  7519                                  ;	$Get_Drive_Freespace returns the # of free allocation units on a
  7520                                  ;		drive.
  7521                                  ;
  7522                                  ;	This call returns the same info in the same registers (except for the
  7523                                  ;	FAT pointer) as the old FAT pointer calls
  7524                                  ;
  7525                                  ;	ENTRY	DL = Drive number
  7526                                  ;	EXIT	AX = Sectors per allocation unit
  7527                                  ;		   = -1 if bad drive specified
  7528                                  ;		On User Stack
  7529                                  ;		    BX = Number of free allocation units
  7530                                  ;		    DX = Total Number of allocation units on disk
  7531                                  ;		    CX = Sector size
  7532                                  
  7533                                  ;procedure   $GET_DRIVE_FREESPACE,NEAR
  7534                                  
  7535                                  _$GET_DRIVE_FREESPACE:
  7536                                  
  7537                                  ;hkn; SS is DOSDATA
  7538                                  	;context DS
  7539 00000E6D 16                      	push	ss
  7540 00000E6E 1F                      	pop	ds
  7541                                  
  7542 00000E6F 88D0                    	MOV	AL,DL
  7543                                  	;invoke	GetThisDrv		; Get drive
  7544 00000E71 E8905C                  	call	GETTHISDRV
  7545                                  SET_AX_RET:
  7546 00000E74 7218                    	JC	short BADFDRV
  7547                                  	;invoke	DISK_INFO
  7548 00000E76 E8D01E                  	call	DISK_INFO
  7549 00000E79 87D3                    	XCHG	DX,BX
  7550 00000E7B 72F7                    	JC	short SET_AX_RET	; User FAILed to I 24
  7551 00000E7D 30E4                    	XOR	AH,AH			; Chuck Fat ID byte
  7552                                  DoSt:
  7553 00000E7F E80EF6                  	call	Get_User_Stack
  7554                                  ;ASSUME	DS:NOTHING
  7555                                  	;mov	[si+6],dx
  7556                                  	;mov	[si+4],cx
  7557                                  	;mov	[si+2],bx
  7558 00000E82 895406                  	MOV	[SI+user_env.user_DX],DX
  7559 00000E85 894C04                  	MOV	[SI+user_env.user_CX],CX
  7560 00000E88 895C02                  	MOV	[SI+user_env.user_BX],BX
  7561                                  	;MOV	[SI+user_env.user_AX],AX
  7562 00000E8B 8904                    	mov     [si],ax
  7563                                  	;return
  7564 00000E8D C3                      	retn
  7565                                  
  7566                                  BADFDRV:
  7567                                  	; MSDOS 3.3
  7568                                  	;;mov	al,0Fh
  7569                                  	;mov	al,error_invalid_drive	; Assume error
  7570                                  
  7571                                  	; 13/05/2019 - Retro DOS v4.0
  7572                                  
  7573                                  	; MSDOS 6.0 & MSDOS 3.3
  7574                                  	;invoke	FCB_RET_ERR
  7575 00000E8E E8D8F7                  	call	FCB_RET_ERR
  7576                                  	
  7577 00000E91 B8FFFF                  	MOV	AX,-1
  7578 00000E94 EBE9                    	JMP	short DoSt
  7579                                  
  7580                                  ;EndProc $GET_DRIVE_FREESPACE
  7581                                  
  7582                                  ;	BREAK <$Get_DMA, $Set_DMA -- Get/Set current DMA address>
  7583                                  ;----------------------------------------------------------------------------
  7584                                  ;**	$Get_DMA - Get Disk Transfer Address
  7585                                  ;
  7586                                  ;	ENTRY	none
  7587                                  ;	EXIT	ES:BX is current transfer address
  7588                                  ;	USES	all
  7589                                  
  7590                                  _$GET_DMA:
  7591 00000E96 368B1E[2C03]            	MOV	BX,[SS:DMAADD]
  7592 00000E9B 368B0E[2E03]            	MOV	CX,[SS:DMAADD+2]
  7593 00000EA0 E8EDF5                  	call	Get_User_Stack
  7594                                  	;mov	[si+2],bx
  7595                                  	;mov	[si+10h],cx
  7596 00000EA3 895C02                  	MOV	[SI+user_env.user_BX],BX
  7597 00000EA6 894C10                  	MOV	[SI+user_env.user_ES],CX
  7598 00000EA9 C3                      	retn
  7599                                  
  7600                                  ;**	$Set_DMA - Set Disk Transfer Address
  7601                                  ;----------------------------------------------------------------------------
  7602                                  ;	ENTRY	DS:DX is current transfer address
  7603                                  ;	EXIT	none
  7604                                  ;	USES	all
  7605                                  
  7606                                  _$SET_DMA:
  7607 00000EAA 368916[2C03]            	MOV	[SS:DMAADD],DX
  7608 00000EAF 368C1E[2E03]            	MOV	[SS:DMAADD+2],DS
  7609 00000EB4 C3                      	retn
  7610                                  
  7611                                  ;	BREAK <$Get_Default_Drive, $Set_Default_Drive -- Set/Get default drive>
  7612                                  ;------------------------------------------------------------------------------
  7613                                  
  7614                                  ;**	$Get_Default_Drive - Get Current Default Drive
  7615                                  ;-----------------------------------------------------
  7616                                  ;	ENTRY	none
  7617                                  ;	EXIT	(AL) = drive number
  7618                                  ;	USES	all
  7619                                  
  7620                                  _$GET_DEFAULT_DRIVE:
  7621 00000EB5 36A0[3603]              	MOV	AL,[SS:CURDRV]
  7622 00000EB9 C3                      	retn
  7623                                  
  7624                                  ;**	$Set_Default_Drive - Specify new Default Drive
  7625                                  ;-----------------------------------------------------
  7626                                  ;	ENTRY	(DL) = Drive number for new default drive
  7627                                  ;	EXIT	(AL) = Number of drives, NO ERROR RETURN IF DRIVE NUMBER BAD
  7628                                  
  7629                                  _$SET_DEFAULT_DRIVE:
  7630 00000EBA 88D0                    	MOV	AL,DL
  7631 00000EBC FEC0                    	INC	AL			; A=1, B=2...
  7632 00000EBE E8275C                  	call	GetVisDrv		; see if visible drive
  7633 00000EC1 7204                    	JC	short SETRET		; errors do not set
  7634 00000EC3 36A2[3603]              	MOV	[SS:CURDRV],AL		; no, set
  7635                                  
  7636                                  SETRET:
  7637 00000EC7 36A0[4700]              	MOV	AL,[SS:CDSCOUNT]	; let user see what the count really is
  7638 00000ECB C3                      	retn
  7639                                  
  7640                                  ;BREAK <$Get/Set_Interrupt_Vector - Get/Set interrupt vectors>
  7641                                  ;----------------------------------------------------------------------------
  7642                                  
  7643                                  ;**	$Get_Interrupt_Vector - Get Interrupt Vector
  7644                                  ;---------------------------------------------------
  7645                                  ;	$Get_Interrupt_Vector is the official way for user pgms to get the
  7646                                  ;	contents of an interrupt vector.
  7647                                  ;
  7648                                  ;	ENTRY	(AL) = interrupt number
  7649                                  ;	EXIT	(ES:BX) = current interrupt vector
  7650                                  
  7651                                  _$GET_INTERRUPT_VECTOR:
  7652 00000ECC E82F00                  	CALL	RECSET
  7653 00000ECF 26C41F                  	LES	BX,[ES:BX]
  7654 00000ED2 E8BBF5                  	call	Get_User_Stack
  7655                                  	;mov	[si+2],bx
  7656                                  	;mov	[si+10h],es
  7657 00000ED5 895C02                  	MOV	[SI+user_env.user_BX],BX
  7658 00000ED8 8C4410                  	MOV	[SI+user_env.user_ES],ES
  7659 00000EDB C3                      	retn
  7660                                  
  7661                                  ;**	$Set_Interrupt_Vector - Set Interrupt Vector
  7662                                  ;---------------------------------------------------
  7663                                  ;	$Set_Interrupt_Vector is the official way for user pgms to set the
  7664                                  ;	contents of an interrupt vector.
  7665                                  ;
  7666                                  ;	M004, M068: Also set A20OFF_COUNT to 1 if EXECA20OFF bit has been set 
  7667                                  ;	and if A20OFF_COUNT is non-zero. See under tag M003 in inc\dossym.inc 
  7668                                  ;	for explanation.
  7669                                  ;
  7670                                  ;	ENTRY	(AL) = interrupt number
  7671                                  ;		(ds:dx) = desired new vector value
  7672                                  ;	EXIT	none
  7673                                  ;	USES	all
  7674                                  
  7675                                  ; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  7676                                  ; 13/05/2019 - Retro DOS v4.0
  7677                                  
  7678                                  _$SET_INTERRUPT_VECTOR:
  7679 00000EDC E81F00                  	CALL	RECSET
  7680 00000EDF FA                      	CLI				; Watch out!!!!! Folks sometimes use
  7681 00000EE0 268917                  	MOV	[ES:BX],DX		;   this for hardware ints (like timer).
  7682 00000EE3 268C5F02                	MOV	[ES:BX+2],DS
  7683 00000EE7 FB                      	STI
  7684                                  					; M004, M068 - Start
  7685                                  	; MSDOS 6.0
  7686 00000EE8 36F606[8600]04          	test	byte [ss:DOS_FLAG],EXECA20OFF ; 4
  7687                                  					; Q: was the previous call an int 21
  7688                                  					;    exec call
  7689                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  7690                                  	;jnz	short siv_1		; Y: go set count
  7691                                  	;retn				; N: return
  7692                                  	; 15/12/2022
  7693 00000EEE 740D                    	jz	short siv_2
  7694                                  siv_1:	
  7695 00000EF0 36803E[8500]00          	cmp	byte [ss:A20OFF_COUNT],0 ; Q: is count 0
  7696 00000EF6 7505                    	jne	short siv_2		 ; N: done 
  7697                                  	; 20/09/2023
  7698 00000EF8 36FE06[8500]            	inc	byte [ss:A20OFF_COUNT]	
  7699                                  	;mov	byte [ss:A20OFF_COUNT],1 ; Y: set it to 1 to indicate to dos 
  7700                                  					 ; dispatcher to turn A20 Off before 
  7701                                  					 ; returning to user.
  7702                                  siv_2:
  7703                                  	; 07/12/2022
  7704 00000EFD C3                      	retn				; M004, M068 - End
  7705                                  	
  7706                                  RECSET:
  7707 00000EFE 31DB                    	XOR	BX,BX
  7708 00000F00 8EC3                    	MOV	ES,BX
  7709 00000F02 88C3                    	MOV	BL,AL
  7710 00000F04 D1E3                    	SHL	BX,1
  7711 00000F06 D1E3                    	SHL	BX,1
  7712 00000F08 C3                      	retn
  7713                                  
  7714                                  ;	BREAK <$Char_Oper - hack on paths, switches so that xenix can look like PCDOS>
  7715                                  ;-------------------------------------------------------------------------------------
  7716                                  
  7717                                  ;**	$Char_Oper - Manipulate Switch Character
  7718                                  ;
  7719                                  ;	This function was put in to facilitate XENIX path/switch compatibility
  7720                                  ;
  7721                                  ;	ENTRY	AL = function:
  7722                                  ;		    0 - read switch char
  7723                                  ;		    1 - set switch char (char in DL)
  7724                                  ;		    2 - read device availability
  7725                                  ;			Always returns available
  7726                                  ;		    3 - set device availability
  7727                                  ;			No longer supported (NOP)
  7728                                  ;	EXIT	(al) = 0xff iff error
  7729                                  ;		(al) != 0xff if ok
  7730                                  ;		  (dl) = character/flag, if "read switch char" subfunction
  7731                                  ;	USES	AL, DL
  7732                                  ;
  7733                                  ;	NOTE	This already obsolete function has been deactivated in DOS 5.0
  7734                                  ;		The character / is always returned for subfunction 0,
  7735                                  ;		subfunction 2 always returns -1, all other subfunctions are ignored.
  7736                                  
  7737                                  ; 13/05/2019 - Retro DOS v4.0
  7738                                  ; DOSCODE:4CC9h (MSDOS 6.21, MSDOS.SYS)
  7739                                  
  7740                                  ; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  7741                                  ; DOSCODE:4CBCh (MSDOS 5.0, MSDOS.SYS)
  7742                                  
  7743                                  _$CHAR_OPER:
  7744                                  	; MSDOS 6.0
  7745 00000F09 08C0                    	or	al,al				; get switch?
  7746 00000F0B B22F                    	mov	dl,'/'				; assume yes
  7747 00000F0D 7407                    	jz	short chop_1			; jump if yes
  7748 00000F0F 3C02                    	cmp	al,2				; check device availability?
  7749 00000F11 B2FF                    	mov	dl,-1				; assume yes
  7750 00000F13 7401                    	jz	short chop_1			; jump if yes
  7751 00000F15 C3                      	retn					; otherwise just quit
  7752                                  
  7753                                  ; subfunctions requiring return of value to user come here. DL holds
  7754                                  ; value to return
  7755                                  
  7756                                  chop_1:
  7757 00000F16 E877F5                  	call	Get_User_Stack
  7758 00000F19 895406                  	mov	[SI+user_env.user_DX],dx	; store value for user
  7759 00000F1C C3                      	retn
  7760                                  
  7761                                  	; MSDOS 3.3
  7762                                  	; Offset 1B87h in IBMDOS.COM (MSDOS 3.3), 1987
  7763                                  	;push	ss
  7764                                  	;pop	ds
  7765                                  	;cmp	al,1
  7766                                  	;jb	short chop_1
  7767                                  	;jz	short chop_2
  7768                                  	;cmp	al,3
  7769                                  	;jb	short chop_3
  7770                                  	;jz	short chop_5
  7771                                  	;mov	al,0FFh
  7772                                  	;retn
  7773                                  ;chop_1:
  7774                                  	;mov	dl,[chSwitch]
  7775                                  	;jmp	short chop_4
  7776                                  ;chop_2:
  7777                                  	;mov	[chSwitch],dl
  7778                                  	;retn
  7779                                  ;chop_3:
  7780                                  	;mov	dl, FFh
  7781                                  ;chop_4:
  7782                                  	;call	Get_User_Stack
  7783                                  	;mov	[si+6],dx
  7784                                  ;chop_5:
  7785                                  	;retn
  7786                                  
  7787                                  ;**	$GetExtendedError - Return Extended error code
  7788                                  ;----------------------------------------------------------------------------
  7789                                  ;	This function reads up the extended error info from the static
  7790                                  ;	variables where it was stored.
  7791                                  ;
  7792                                  ;	ENTRY	none
  7793                                  ;	EXIT	AX = Extended error code (0 means no extended error)
  7794                                  ;		BL = recommended action
  7795                                  ;		BH = class of error
  7796                                  ;		CH = locus of error
  7797                                  ;		ES:DI = may be pointer
  7798                                  ;	USES	ALL
  7799                                  
  7800                                  	; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  7801                                  
  7802                                  _$GetExtendedError:
  7803 00000F1D 16                      	push	ss
  7804 00000F1E 1F                      	pop	ds
  7805 00000F1F A1[2403]                	MOV	AX,[EXTERR]
  7806 00000F22 C43E[2803]              	LES	DI,[EXTERRPT]
  7807 00000F26 8B1E[2603]              	MOV	BX,[EXTERR_ACTION]	; BL = Action, BH = Class
  7808 00000F2A 8A2E[2303]              	MOV	CH,[EXTERR_LOCUS]
  7809 00000F2E E85FF5                  	call	Get_User_Stack
  7810                                  	;mov	[si+0Ah],di
  7811 00000F31 897C0A                  	MOV	[SI+user_env.user_DI],DI
  7812                                  	;mov	[si+10h],es
  7813 00000F34 8C4410                  	MOV	[SI+user_env.user_ES],ES
  7814                                  	;mov	[si+2],bx
  7815 00000F37 895C02                  	MOV	[SI+user_env.user_BX],BX
  7816                                  	;mov	[si+4],cx
  7817 00000F3A 894C04                  	MOV	[SI+user_env.user_CX],CX
  7818                                  jmp_SYS_RET_OK:
  7819                                  	; 15/12/2022
  7820                                  	;jmp	SYS_RET_OK
  7821                                  	; 25/06/2019
  7822 00000F3D E90DF7                  	jmp	SYS_RET_OK_clc ; 15/12/2022
  7823                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  7824                                  ;jmp_SYS_RET_OK:
  7825                                  	;jmp	SYS_RET_OK
  7826                                  
  7827                                  ; --------------------------------------------------------------------------
  7828                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  7829                                  	; DOSCODE:4CF3h
  7830                                  ;patch_or_unknown:
  7831                                  ;get_code_page:
  7832 00000F40 56                      	push    si
  7833 00000F41 BE[0012]                	mov     si, COUNTRY_CDPG
  7834                                  	;mov	ax, [si+DOS_CCDPG.ccDosCodePage]
  7835 00000F44 368B446A                	mov     ax, [ss:si+6Ah]
  7836 00000F48 5E                      	pop     si
  7837 00000F49 C3                      	retn
  7838                                  ; --------------------------------------------------------------------------	
  7839                                  
  7840                                  ; 29/04/2019 - Retro DOS v4.0
  7841                                  
  7842                                  ;BREAK	<ECS_call - Extended Code System support function>
  7843                                  ;---------------------------------------------------------------------------
  7844                                  ; Inputs:
  7845                                  ;	AL = 0	get lead byte table
  7846                                  ;		on return DS:SI has the table location
  7847                                  ;
  7848                                  ;	AL = 1	set / reset interim console flag
  7849                                  ;		DL = flag (00H or 01H)
  7850                                  ;		no return
  7851                                  ;
  7852                                  ;	AL = 2	get interim console flag
  7853                                  ;		on return DL = current flag value
  7854                                  ;
  7855                                  ;	AL = OTHER then error, and returns with:
  7856                                  ;		AX = error_invalid_function
  7857                                  ;
  7858                                  ;  NOTE: THIS CALL DOES GUARANTEE THAT REGISTER OTHER THAN
  7859                                  ;	 SS:SP WILL BE PRESERVED!
  7860                                  ;---------------------------------------------------------------------------
  7861                                  
  7862                                  _$ECS_Call:
  7863 00000F4A 08C0                    	or	al,al			; AL = 0 (get table)?
  7864                                  	;jnz	short _okok
  7865                                  	; 15/12/2022
  7866 00000F4C 7403                    	jz	short get_lbt
  7867                                  ;_okok:
  7868 00000F4E E9F9F6                  	jmp	SYS_RET_OK
  7869                                  get_lbt:
  7870 00000F51 E83CF5                  	call	Get_User_Stack		; *
  7871                                  
  7872                                  ;hkn; dbcs_table moved low to dosdata
  7873                                  	;mov	word [si+8],DBCS_TAB+2
  7874 00000F54 C74408[E50C]            	mov	word [si+user_env.user_SI],DBCS_TAB+2
  7875                                  
  7876 00000F59 06                      	push	es
  7877                                  	;getdseg <es>			; es = DOSDATA
  7878 00000F5A 2E8E06[0700]            	mov	es,[cs:DosDSeg]
  7879                                  	;mov	[si+14],es
  7880 00000F5F 8C440E                  	mov	[SI+user_env.user_DS],es
  7881 00000F62 07                      	pop	es
  7882                                  
  7883                                  	; 15/12/2022
  7884 00000F63 EBD8                    	jmp	short jmp_SYS_RET_OK ; jmp SYS_RET_OK_clc ; *
  7885                                  ;_okok:
  7886                                  	; 15/12/2022	
  7887                                  	;;transfer SYS_RET_OK
  7888                                  	;jmp	short jmp_SYS_RET_OK
  7889                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  7890                                  	;;jmp	SYS_RET_OK
  7891                                  	;jmp	short jmp_SYS_RET_OK
  7892                                  
  7893                                  ;============================================================================
  7894                                  ; PARSE.ASM, MSDOS 6.0, 1991
  7895                                  ;============================================================================
  7896                                  ; 19/07/2018 - Retro DOS v3.0
  7897                                  ; 15/05/2019 - Retro DOS v4.0
  7898                                  
  7899                                  ; System calls for parsing command lines
  7900                                  ;
  7901                                  ;   $PARSE_FILE_DESCRIPTOR
  7902                                  ;
  7903                                  ;   Modification history:
  7904                                  ;
  7905                                  ;       Created: ARR 30 March 1983
  7906                                  ;               EE PathParse 10 Sept 1983
  7907                                  ;
  7908                                  
  7909                                  ;BREAK <$Parse_File_Descriptor -- Parse an arbitrary string into an FCB>
  7910                                  ;---------------------------------------------------------------------------
  7911                                  ; Inputs:
  7912                                  ;       DS:SI Points to a command line
  7913                                  ;       ES:DI Points to an empty FCB
  7914                                  ;       Bit 0 of AL = 1 At most one leading separator scanned off
  7915                                  ;                   = 0 Parse stops if separator encountered
  7916                                  ;       Bit 1 of AL = 1 If drive field blank in command line - leave FCB
  7917                                  ;                   = 0  "    "    "     "         "      "  - put 0 in FCB
  7918                                  ;       Bit 2 of AL = 1 If filename field blank - leave FCB
  7919                                  ;                   = 0  "       "      "       - put blanks in FCB
  7920                                  ;       Bit 3 of AL = 1 If extension field blank - leave FCB
  7921                                  ;                   = 0  "       "      "        - put blanks in FCB
  7922                                  ; Function:
  7923                                  ;       Parse command line into FCB
  7924                                  ; Returns:
  7925                                  ;       AL = 1 if '*' or '?' in filename or extension, 0 otherwise
  7926                                  ;       DS:SI points to first character after filename
  7927                                  ;---------------------------------------------------------------------------
  7928                                  
  7929                                  _$PARSE_FILE_DESCRIPTOR:
  7930 00000F65 E80B40                  	call	MAKEFCB
  7931 00000F68 56                      	PUSH    SI
  7932 00000F69 E824F5                  	call	Get_User_Stack
  7933                                  	;pop	word [si+8]
  7934 00000F6C 8F4408                  	POP     word [SI+user_env.user_SI]
  7935 00000F6F C3                      	retn
  7936                                  
  7937                                  ;============================================================================
  7938                                  ; MISC.ASM, MSDOS 6.0, 1991
  7939                                  ;============================================================================
  7940                                  ; 19/07/2018 - Retro DOS v3.0
  7941                                  
  7942                                  ; 29/04/2019 - Retro DOS v4.0
  7943                                  
  7944                                  ;ENTRYPOINTSEG	EQU	0CH
  7945                                  ;MAXDIF		EQU	0FFFH
  7946                                  ;SAVEXIT 	EQU	10
  7947                                  ;WRAPOFFSET	EQU	0FEF0h
  7948                                  
  7949                                  ;
  7950                                  ;----------------------------------------------------------------------------
  7951                                  ;
  7952                                  ;**	$SLEAZEFUNC - Get a Pointer to the Media Byte
  7953                                  ;
  7954                                  ;	Return Stuff sort of like old get fat call
  7955                                  ;
  7956                                  ;	ENTRY	none
  7957                                  ;	EXIT	DS:BX = Points to FAT ID byte (IBM only)
  7958                                  ;			GOD help anyone who tries to do ANYTHING except
  7959                                  ;			READ this ONE byte.
  7960                                  ;		DX = Total Number of allocation units on disk
  7961                                  ;		CX = Sector size
  7962                                  ;		AL = Sectors per allocation unit
  7963                                  ;		   = -1 if bad drive specified
  7964                                  ;	USES	all
  7965                                  ;
  7966                                  ;**	$SLEAZEFUNCDL - Get a Pointer to the Media Byte
  7967                                  ;
  7968                                  ;	Identical to $SLEAZEFUNC except (dl) = drive
  7969                                  ;
  7970                                  ;	ENTRY	(dl) = drive (0=default, 1=A, 2=B, etc.)
  7971                                  ;	EXIT	DS:BX = Points to FAT ID byte (IBM only)
  7972                                  ;			GOD help anyone who tries to do ANYTHING except
  7973                                  ;			READ this ONE byte.
  7974                                  ;		DX = Total Number of allocation units on disk
  7975                                  ;		CX = Sector size
  7976                                  ;		AL = Sectors per allocation unit
  7977                                  ;		   = -1 if bad drive specified
  7978                                  ;	USES	all
  7979                                  ;
  7980                                  ;----------------------------------------------------------------------------
  7981                                  ;
  7982                                  
  7983                                  _$SLEAZEFUNC:
  7984                                  	; 15/05/2019 - Retro DOS v4.0
  7985 00000F70 B200                    	MOV	DL,0
  7986                                  _$SLEAZEFUNCDL:
  7987 00000F72 16                      	push	ss
  7988 00000F73 1F                      	pop	ds
  7989                                  	
  7990 00000F74 88D0                    	MOV	AL,DL
  7991 00000F76 E88B5B                  	call	GETTHISDRV		; Get CDS structure
  7992                                  SET_AL_RET:
  7993                                  	; MSDOS 3.3
  7994                                  	;;mov	al, 0Fh
  7995                                  	;MOV	AL,error_invalid_drive	; Assume error	;AC000;
  7996                                  	
  7997                                  	; MSDOS 6.0 & MSDOS 3.3
  7998 00000F79 721E                    	JC	short BADSLDRIVE
  7999                                  
  8000 00000F7B E8CB1D                  	call	DISK_INFO
  8001                                  	;JC	short SET_AL_RET	; User FAILed to I 24
  8002 00000F7E 7219                    	jc	short BADSLDRIVE
  8003 00000F80 8826[9805]              	MOV	[FATBYTE],AH
  8004                                  
  8005                                  ; NOTE THAT A FIXED MEMORY CELL IS USED --> THIS CALL IS NOT
  8006                                  ; RE-ENTRANT. USERS BETTER GET THE ID BYTE BEFORE THEY MAKE THE
  8007                                  ; CALL AGAIN
  8008                                  
  8009 00000F84 BF[9805]                	MOV	DI,FATBYTE
  8010 00000F87 30E4                    	XOR	AH,AH			; AL has sectors/cluster
  8011 00000F89 E804F5                  	call	Get_User_Stack
  8012                                  	;mov	[si+4],cx
  8013                                  	;mov	[si+6],bx
  8014                                  	;mov	[si+2],di
  8015 00000F8C 894C04                  	MOV	[SI+user_env.user_CX],CX
  8016 00000F8F 895C06                  	MOV	[SI+user_env.user_DX],BX
  8017 00000F92 897C02                  	MOV	[SI+user_env.user_BX],DI
  8018                                  	
  8019                                  	;mov	[si+0Eh],ss
  8020 00000F95 8C540E                  	MOV     [SI+user_env.user_DS],SS ; stash correct pointer
  8021                                  
  8022 00000F98 C3                      	retn
  8023                                  
  8024                                  BADSLDRIVE:
  8025 00000F99 E9CDF6                  	jmp	FCB_RET_ERR
  8026                                  
  8027                                  ;
  8028                                  ;----------------------------------------------------------------------------
  8029                                  ;
  8030                                  ;**	$Get_INDOS_Flag - Return location of DOS Critical Section Flag
  8031                                  ;
  8032                                  ;	Returns location of DOS status for interrupt routines
  8033                                  ;									   ;
  8034                                  ;	ENTRY	none
  8035                                  ;	EXIT	(es:bx) = flag location
  8036                                  ;	USES	all
  8037                                  ;
  8038                                  ;----------------------------------------------------------------------------
  8039                                  ;
  8040                                  
  8041                                  _$GET_INDOS_FLAG:
  8042 00000F9C E8F1F4                          CALL	Get_User_Stack
  8043                                          ;MOV	WORD [SI+2],INDOS
  8044 00000F9F C74402[2103]            	MOV     word [SI+user_env.user_BX],INDOS
  8045                                          ;MOV	[SI+10H],SS
  8046 00000FA4 8C5410                  	MOV	[SI+user_env.user_ES],SS
  8047 00000FA7 C3                      	RETN 
  8048                                  
  8049                                  ;
  8050                                  ;----------------------------------------------------------------------------
  8051                                  ;
  8052                                  ;**	$Get_IN_Vars - Return Pointer to DOS Variables
  8053                                  ;
  8054                                  ;	Return a pointer to interesting DOS variables This call is version
  8055                                  ;	dependent and is subject to change without notice in future versions.
  8056                                  ;	Use at risk.
  8057                                  ;
  8058                                  ;	ENTRY	none
  8059                                  ;	EXIT	(es:bx) = address of SYSINITVAR
  8060                                  ;	uses	ALL
  8061                                  ;
  8062                                  ;----------------------------------------------------------------------------
  8063                                  ;
  8064                                  
  8065                                  _$GET_IN_VARS:
  8066 00000FA8 E8E5F4                          CALL	Get_User_Stack
  8067                                          ;MOV	WORD [SI+2],SYSINITVAR
  8068                                  	;MOV	word [SI+user_env.user_BX],SYSINITVAR
  8069 00000FAB C74402[2600]            	MOV	word [SI+user_env.user_BX],SYSINITVARS
  8070                                          ;MOV	[SI+10H],SS
  8071 00000FB0 8C5410                  	MOV	[SI+user_env.user_ES],SS
  8072 00000FB3 C3                      	RETN
  8073                                  
  8074                                  ;
  8075                                  ;----------------------------------------------------------------------------
  8076                                  ;
  8077                                  ;**	$Get_Default_DPB - Return a pointer to the Default DPB
  8078                                  ;
  8079                                  ;	Return pointer to drive parameter table for default drive
  8080                                  ;
  8081                                  ;	ENTRY	none
  8082                                  ;	EXIT	(ds:bx) = DPB address
  8083                                  ;	USES	all
  8084                                  ;
  8085                                  ;**	$Get_DPB - Return a pointer to a specified DPB
  8086                                  ;
  8087                                  ;	Return pointer to a specified drive parameter table
  8088                                  ;
  8089                                  ;	ENTRY	(dl) = drive # (0 = default, 1=A, 2=B, etc.)
  8090                                  ;	EXIT	(al) = 0 iff ok
  8091                                  ;		  (ds:bx) = DPB address
  8092                                  ;		(al) = -1 if bad drive
  8093                                  ;	USES	all
  8094                                  ;
  8095                                  ;----------------------------------------------------------------------------
  8096                                  ;
  8097                                  
  8098                                  ; 15/05/2019 - Retro DOS v4.0
  8099                                  
  8100                                  _$GET_DEFAULT_DPB:
  8101 00000FB4 B200                    	MOV	DL,0
  8102                                  _$GET_DPB:
  8103 00000FB6 16                      	push	ss
  8104 00000FB7 1F                      	pop	ds
  8105                                  
  8106 00000FB8 88D0                    	MOV	AL,DL
  8107 00000FBA E8475B                  	call	GETTHISDRV		; Get CDS structure
  8108 00000FBD 7222                    	JC	short ISNODRV 		; no valid drive
  8109 00000FBF C43E[A205]              	LES	DI,[THISCDS]		; check for net CDS
  8110                                  	;;test	word [es:di+43h],8000h
  8111                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet
  8112                                  	;test	byte [es:di+44h],80h
  8113 00000FC3 26F6454480              	test	byte [ES:DI+curdir.flags+1],(curdir_isnet>>8)
  8114 00000FC8 7517                    	JNZ	short ISNODRV 		; No DPB to point at on NET stuff
  8115 00000FCA E88A03                  	call	ECritDisk
  8116 00000FCD E86B47                  	call	FATREAD_CDS		; Force Media Check and return DPB
  8117 00000FD0 E89F03                  	call	LCritDisk
  8118 00000FD3 720C                    	JC	short ISNODRV 		; User FAILed to I 24, only error we
  8119                                  					;   have.
  8120 00000FD5 E8B8F4                  	call	Get_User_Stack
  8121                                  	;mov	[si+2],bp
  8122 00000FD8 896C02                  	MOV	[SI+user_env.user_BX],BP
  8123                                  	;mov	[si+0Eh],es
  8124 00000FDB 8C440E                  	MOV	[SI+user_env.user_DS],ES
  8125 00000FDE 30C0                    	XOR	AL,AL
  8126 00000FE0 C3                      	retn
  8127                                  ISNODRV:
  8128 00000FE1 B0FF                    	MOV	AL,-1
  8129 00000FE3 C3                      	retn
  8130                                  
  8131                                  ;
  8132                                  ;----------------------------------------------------------------------------
  8133                                  ;
  8134                                  ;**	$Disk_Reset - Flush out Dirty Buffers
  8135                                  ;
  8136                                  ;	$DiskReset flushes and invalidates all buffers.  BUGBUG - do
  8137                                  ;		we really invalidate?  SHould we?  THis screws non-removable
  8138                                  ;		caching.  Maybe CHKDSK relies upon it, though....
  8139                                  ;
  8140                                  ;	ENTRY	none
  8141                                  ;	EXIT	none
  8142                                  ;	USES	all
  8143                                  ;
  8144                                  ;----------------------------------------------------------------------------
  8145                                  ;
  8146                                  
  8147                                  	; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  8148                                  	; DOSCODE:4D94h
  8149                                  _$DISK_RESET:
  8150                                  	; 15/05/2019 - Retro DOS v4.0
  8151 00000FE4 B0FF                    	mov	al,0FFh	; -1
  8152 00000FE6 16                      	push	ss
  8153 00000FE7 1F                      	pop	ds
  8154                                  	; 06/11/2022
  8155                                  	;MOV	AL,-1
  8156 00000FE8 E86C03                  	call	ECritDisk
  8157                                  	; MSDOS 6.0
  8158                                  	;;or	word [DOS34_FLAG],4
  8159                                  	;or	word [DOS34_FLAG],FROM_DISK_RESET    ;AN000;
  8160 00000FEB 800E[1106]04            	or	byte [DOS34_FLAG],FROM_DISK_RESET ; 4 ; 15/05/2019
  8161 00000FF0 E8C74A                  	call	FLUSHBUF
  8162                                  	; MSDOS 6.0
  8163                                  	;and	word [DOS34_FLAG],0FFFBh
  8164                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8165                                  	;and	word [DOS34_FLAG],NO_FROM_DISK_RESET ;AN000;
  8166                                  	; 15/12/2022
  8167 00000FF3 8026[1106]FB            	and	byte [DOS34_FLAG],NO_FROM_DISK_RESET ; 0FBh ; 15/05/2019
  8168 00000FF8 C706[B50D]0000          	mov	word [SC_STATUS],0	; Throw out secondary cache M041
  8169                                  ;
  8170                                  ; We will "ignore" any errors on the flush, and go ahead and invalidate.  This
  8171                                  ; call doesn't return any errors and it is supposed to FORCE a known state, so
  8172                                  ; let's do it.
  8173                                  ;
  8174                                  ; Invalidate 'last-buffer' used
  8175                                  ;
  8176 00000FFE BBFFFF                  	MOV	BX,-1 ; 0FFFFh	
  8177 00001001 891E[2000]              	MOV	[LastBuffer+2],BX
  8178 00001005 891E[1E00]              	MOV	[LastBuffer],BX
  8179                                  
  8180                                  	; MSDOS 3.3 
  8181                                  	; IBMDOS.COM, Offset 1C66h
  8182                                  	;;;;
  8183                                  	;lds	si,[BUFFHEAD]
  8184                                  	;mov	ax,20FFh	; .buf_ID,    AL = FFh (Free buffer)
  8185                                  				; .buf_flags, AH = 0, reset/clear
  8186                                  ;DRST_1:
  8187                                  	;;mov	[si+4],ax
  8188                                  	;mov	[si+BUFFINFO.buf_ID],ax
  8189                                  	;lds	si,[SI]
  8190                                  	;cmp	si,bx ; -1
  8191                                  	;je	short DRST_2
  8192                                  	;;mov	[si+4],ax
  8193                                  	;mov	[si+BUFFINFO.buf_ID],ax
  8194                                  	;lds	si,[SI]
  8195                                  	;cmp	si,bx
  8196                                  	;jne	short DRST_1
  8197                                  	;;;;
  8198                                  ;DRST_2:
  8199 00001009 E86603                  	call	LCritDisk
  8200 0000100C B8FFFF                  	MOV	AX,-1
  8201                                  	; 07/12/2022
  8202                                  	;mov	ax,0FFFFh
  8203                                  	;CallInstall NetFlushBuf,MultNET,32,AX,AX
  8204 0000100F 50                      	push	ax ; * MSDOS 6.0 ; 15/05/2019
  8205 00001010 B82011                  	mov     ax,1120h
  8206 00001013 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - FLUSH ALL DISK BUFFERS
  8207                                  			; DS = DOS CS
  8208                                  			; Return: CF clear (successful)
  8209 00001015 58                      	pop	ax ; * MSDOS 6.0 ; 15/05/2019
  8210                                  	
  8211 00001016 C3                      	retn
  8212                                  
  8213                                  	; 19/07/2018 - Retro DOS v3.0
  8214                                  
  8215                                  ;
  8216                                  ;	BREAK <$SetDPB - Create a valid DPB from a user-specified BPB>
  8217                                  ;
  8218                                  ;----------------------------------------------------------------------------
  8219                                  ;
  8220                                  ;**	$SetDPB - Create a DPB
  8221                                  ;
  8222                                  ;	SetDPB Creates a valid DPB from a user-specified BPB
  8223                                  ;
  8224                                  ;	ENTRY	ES:BP Points to DPB
  8225                                  ;		DS:SI Points to BPB
  8226                                  ;	EXIT	DPB setup
  8227                                  ;	USES	ALL but BP, DS, ES
  8228                                  ;
  8229                                  ;----------------------------------------------------------------------------
  8230                                  ;
  8231                                  
  8232                                  ; 10/05/2019 - Retro DOS v4.0
  8233                                  
  8234                                  ; DOSCODE:4DD6h (MSDOS 6.21, MSDOS.SYS)
  8235                                  
  8236                                  ; MSDOS 6.0
  8237 00001017 0300                    word3:	dw	3			; M008 -- word value for divides
  8238                                  
  8239                                  ; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  8240                                  ; DOSCODE:4DC9h (MSDOS 5.0, MSDOS.SYS)
  8241                                  
  8242                                  ;procedure   $SETDPB,NEAR
  8243                                  
  8244                                  _$SETDPB:
  8245 00001019 89EF                    	MOV	DI,BP
  8246 0000101B 83C702                  	ADD	DI,2			; Skip over dpb_drive and dpb_UNIT
  8247 0000101E AD                      	LODSW
  8248 0000101F AB                      	STOSW				; dpb_sector_size
  8249                                  	; MSDOS 6.0
  8250                                  	;cmp	byte [si+3],0
  8251 00001020 807C0300                	CMP	BYTE [SI+A_BPB.BPB_NUMBEROFFATS-2],0 ; FAT file system drive ;AN000;
  8252 00001024 7507                    	JNZ	short yesfat			     ; yes		;AN000;
  8253                                  	;mov	byte [es:di+4],0
  8254 00001026 26C6450400              	MOV	BYTE [ES:DI+DPB.FAT_COUNT-4],0
  8255 0000102B EB70                    	JMP	short setend			     ; NO		;AN000;
  8256                                  
  8257                                  yesfat: ; 10/08/2018
  8258 0000102D 89C2                    	MOV	DX,AX
  8259 0000102F AC                      	LODSB
  8260                                  	;DEC	AL
  8261                                  	; 17/12/2022
  8262 00001030 48                      	dec	ax
  8263 00001031 AA                      	STOSB				; dpb_cluster_mask
  8264                                  	;INC	AL
  8265 00001032 40                      	inc	ax
  8266 00001033 30E4                    	XOR	AH,AH
  8267                                  LOG2LOOP:
  8268 00001035 A801                    	test	AL,1
  8269 00001037 7506                    	JNZ	short SAVLOG
  8270 00001039 FEC4                    	INC	AH
  8271 0000103B D0E8                    	SHR	AL,1
  8272 0000103D EBF6                    	JMP	SHORT LOG2LOOP
  8273                                  SAVLOG:
  8274 0000103F 88E0                    	MOV	AL,AH
  8275 00001041 AA                      	STOSB				; dpb_cluster_shift
  8276 00001042 88C3                    	MOV	BL,AL
  8277 00001044 A5                      	MOVSW				; dpb_first_FAT Start of FAT (# of reserved sectors)
  8278 00001045 AC                      	LODSB
  8279 00001046 AA                      	STOSB				; dpb_FAT_count Number of FATs
  8280                                  ;	OR	AL,AL			; NONFAT ?				;AN000;
  8281                                  ;	JZ	short setend		; yes, don't do anything                ;AN000;
  8282 00001047 88C7                    	MOV	BH,AL
  8283 00001049 AD                      	LODSW
  8284 0000104A AB                      	STOSW				; dpb_root_entries Number of directory entries
  8285 0000104B B105                    	MOV	CL,5
  8286 0000104D D3EA                    	SHR	DX,CL			; Directory entries per sector
  8287 0000104F 48                      	DEC	AX
  8288 00001050 01D0                    	ADD	AX,DX			; Cause Round Up
  8289 00001052 89D1                    	MOV	CX,DX
  8290 00001054 31D2                    	XOR	DX,DX
  8291 00001056 F7F1                    	DIV	CX
  8292 00001058 89C1                    	MOV	CX,AX			; Number of (root) directory sectors
  8293 0000105A 47                      	INC	DI
  8294 0000105B 47                      	INC	DI			; Skip dpb_first_sector
  8295 0000105C A5                      	MOVSW			; Total number of sectors in DSKSIZ (temp as dpb_max_cluster)
  8296 0000105D AC                      	LODSB
  8297                                  	;mov	[es:bp+17h],al
  8298 0000105E 26884617                	MOV	[ES:BP+DPB.MEDIA],AL	; Media byte
  8299 00001062 AD                      	LODSW				; Number of sectors in a FAT
  8300                                  	
  8301                                  	;;;
  8302                                  	;MSDOS 3.3
  8303                                  	;
  8304                                  	;STOSB		; DPB.FAT_SIZE
  8305                                  	;MUL	BH
  8306                                  	
  8307                                  	;MSDOS 6.0
  8308                                  	;
  8309 00001063 AB                      	STOSW		; DPB.FAT_SIZE	;AC000;;>32mb dpb_FAT_size
  8310 00001064 88FA                    	MOV	DL,BH			;AN000;;>32mb
  8311 00001066 30F6                    	XOR	DH,DH			;AN000;;>32mb
  8312 00001068 F7E2                    	MUL	DX			;AC000;;>32mb Space occupied by all FATs
  8313                                  	;;;
  8314                                  	
  8315                                  	;add	ax,[es:bp+6]
  8316 0000106A 26034606                	ADD	AX,[ES:BP+DPB.FIRST_FAT]
  8317 0000106E AB                      	STOSW				; dpb_dir_sector
  8318 0000106F 01C8                    	ADD	AX,CX			; Add number of (root) directory sectors
  8319                                  	;mov	[es:bp+0Bh],ax
  8320 00001071 2689460B                	MOV	[ES:BP+DPB.FIRST_SECTOR],AX
  8321                                  	
  8322                                  	; MSDOS 6.0
  8323 00001075 88D9                    	MOV	CL,BL			;F.C. >32mb				;AN000;
  8324                                  	;;cmp	word [es:bp+0Dh],0
  8325                                  	;CMP	WORD [ES:BP+DSKSIZ],0	;F.C. >32mb				;AN000;
  8326                                  	;JNZ	short normal_dpb	;F.C. >32mb				;AN000;
  8327                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8328                                  	; 15/12/2022
  8329                                  	; 28/07/2019
  8330 00001077 268B5E0D                	mov	bx,[ES:BP+DSKSIZ]
  8331 0000107B 09DB                    	or	bx,bx
  8332 0000107D 751A                    	JNZ	short normal_dpb	;F.C. >32mb				;AN000;
  8333                                  	;CMP	WORD [ES:BP+DSKSIZ],0	;F.C. >32mb				;AN000;
  8334                                  	;JNZ	short normal_dpb	;F.C. >32mb				;AN000;
  8335                                  	
  8336                                  
  8337 0000107F 30ED                    	XOR	CH,CH			;F.C. >32mb				;AN000;
  8338                                  	;mov	bx,[si+8]
  8339 00001081 8B5C08                  	MOV	BX,[SI+A_BPB.BPB_BIGTOTALSECTORS-A_BPB.BPB_SECTORSPERTRACK]	;AN000;
  8340                                  	;mov	dx,[si+10]
  8341 00001084 8B540A                  	MOV	DX,[SI+A_BPB.BPB_BIGTOTALSECTORS-A_BPB.BPB_SECTORSPERTRACK+2]	;AN000;
  8342 00001087 29C3                    	SUB	BX,AX			;AN000;;F.C. >32mb
  8343 00001089 83DA00                  	SBB	DX,0			;AN000;;F.C. >32mb
  8344 0000108C 09C9                    	OR	CX,CX			;AN000;;F.C. >32mb
  8345 0000108E 7407                    	JZ	short norot		;AN000;;F.C. >32mb
  8346                                  rott:					;AN000;;F.C. >32mb
  8347 00001090 F8                      	CLC				;AN000;;F.C. >32mb
  8348 00001091 D1DA                    	RCR	DX,1			;AN000;;F.C. >32mb
  8349 00001093 D1DB                    	RCR	BX,1			;AN000;;F.C. >32mb
  8350 00001095 E2F9                    	LOOP	rott			;AN000;;F.C. >32mb
  8351                                  norot:					;AN000;
  8352                                  	; 15/12/2022
  8353                                  	;MOV	AX,BX			;AN000;;F.C. >32mb
  8354 00001097 EB04                    	JMP	short setend		;AN000;;F.C. >32mb
  8355                                  normal_dpb:
  8356                                  	;;sub	ax,[es:bp+0Dh]
  8357                                  	;SUB	AX,[ES:BP+DSKSIZ]
  8358                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8359                                  	; 15/12/2022
  8360                                  	; bx = [es:bp+DSKSIZ]
  8361                                  	;sub	ax,bx ; 28/07/2019
  8362                                  	;;SUB	AX,[ES:BP+DSKSIZ]
  8363                                  	; 15/12/2022
  8364 00001099 29C3                    	sub	bx,ax
  8365                                  	;NEG	AX			; Sectors in data area
  8366                                  ;;	MOV	CL,BL			; dpb_cluster_shift
  8367                                  	; 15/12/2022
  8368                                  	; CL = cluster shift
  8369                                  	; BX = number of data sectors 
  8370                                  	;SHR	AX,CL			; Div by sectors/cluster
  8371 0000109B D3EB                    	shr	bx,cl 
  8372                                  setend:
  8373                                  ;	M008 - CAS
  8374                                  ;
  8375                                  	; 15/12/2022
  8376 0000109D 43                      	inc	bx
  8377                                  	;INC	AX			; +2 (reserved), -1 (count -> max)
  8378                                  ;
  8379                                  ;	There has been a bug in our fatsize calculation for so long
  8380                                  ;	  that we can't correct it now without causing some user to
  8381                                  ;	  experience data loss. There are even cases where allowing
  8382                                  ;	  the number of clusters to exceed the fats is the optimal
  8383                                  ;	  case -- where adding 2 more fat sectors would make the
  8384                                  ;	  data field smaller so that there's nothing to use the extra
  8385                                  ;	  fat sectors for.
  8386                                  ;
  8387                                  ;	Note that this bug had very minor known symptoms. CHKDSK would
  8388                                  ;	  still report that there was a cluster left when the disk was
  8389                                  ;	  actually full. Very graceful failure for a corrupt system
  8390                                  ;	  configuration. There may be worse cases that were never
  8391                                  ;	  properly traced back to this bug. The problem cases only
  8392                                  ;	  occurred when partition sizes were very near FAT sector
  8393                                  ;	  rounding boundaries, which were rare cases.
  8394                                  ;
  8395                                  ;	Also, it's possible that some third-party partition program might
  8396                                  ;	  create a partition that had a less-than-perfect FAT calculation
  8397                                  ;	  scheme. In this hypothetical case, the number of allocation
  8398                                  ;	  clusters which don't actually have FAT entries to represent
  8399                                  ;	  them might be larger and might create a more catastrophic
  8400                                  ;	  failure. So we'll provide the safeguard of limiting the
  8401                                  ;	  max_cluster to the amount that will fit in the FATs.
  8402                                  ;
  8403                                  ;	ax = maximum legal cluster, ES:BP -> dpb
  8404                                  
  8405                                  ;	make sure the number of fat sectors is actually enough to
  8406                                  ;	  hold that many clusters. otherwise, back the number of
  8407                                  ;	  clusters down
  8408                                  
  8409                                  	; 15/12/2022
  8410                                  	; bx = number of clusters
  8411                                  
  8412                                  	; 19/07/2018 - Retro DOS v3.0
  8413                                  	; MSDOS 6.0
  8414                                  	; 15/12/2022
  8415                                  	;mov	bx,ax			; remember calculated # clusters
  8416                                  
  8417                                  	; 01/08/2018 (MSDOS 3.3)
  8418                                  	;mov	al,[ES:BP+DPB.FAT_SIZE]
  8419                                  	;xor	ah,ah 
  8420                                  
  8421                                  	; 10/05/2019 - Retro DOS v4.0
  8422                                  	;mov	ax,[ES:BP+0Fh]
  8423 0000109E 268B460F                	mov	ax,[ES:BP+DPB.FAT_SIZE]
  8424                                  
  8425                                  	;mul	word [es:bp+2]	
  8426 000010A2 26F76602                	mul	word [ES:BP+DPB.SECTOR_SIZE] ; how big is the FAT?
  8427 000010A6 81FBF60F                	cmp	bx,4096-10  ; 0FF6h	; test for 12 vs. 16 bit fat
  8428 000010AA 720D                    	jb	short setend_fat12
  8429 000010AC D1EA                    	shr	dx,1
  8430                                  
  8431                                  ; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8432                                  	; 15/12/2022
  8433                                  ;cs3 7/2/92
  8434 000010AE 751C                    	jnz	short setend_faterr	; some bonehead gave us more fatspace
  8435                                  					; than enough for the maximum FAT,
  8436                                  					; so go ahead and use the calculated
  8437                                  					; number of clusters.
  8438                                  ;cs3 7/2/92
  8439                                  
  8440 000010B0 D1D8                    	rcr	ax,1			; find number of entries
  8441 000010B2 3DF70F                  	cmp	ax,4096-10+1		; would this truncation move us
  8442                                  ;					;  into 12-bit fatland?
  8443 000010B5 7215                    	jb	short setend_faterr	; then go ahead and let the
  8444                                  ;					;  inconsistency pass through
  8445                                  ;					;  rather than lose data by
  8446                                  ;					;  correcting the fat type
  8447 000010B7 EB0E                    	jmp	short setend_fat16
  8448                                  
  8449                                  setend_fat12:
  8450 000010B9 01C0                    	add	ax,ax			; (fatsiz*2)/3 = # of fat entries
  8451 000010BB 11D2                    	adc	dx,dx
  8452                                  
  8453                                  ; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8454                                  ;cs3 7/2/92
  8455                                  	; 15/12/2022
  8456 000010BD 83FA03                  	cmp	dx,3			; if our fatspace is WAY more than
  8457 000010C0 730A                    	jnb	short setend_faterr	; we need, we may get an overflow
  8458                                  					; here. Check for it and use
  8459                                  					; the calculated size in this case.
  8460                                  ;cs3 7/2/92
  8461                                  
  8462 000010C2 2EF736[1710]            	div	word [cs:word3]
  8463                                  
  8464                                  setend_fat16:
  8465 000010C7 48                      	dec	ax			; limit at 1
  8466 000010C8 39D8                    	cmp	ax,bx			; is fat big enough?
  8467 000010CA 7602                    	jbe	short setend_fat	; use max value that'll fit
  8468                                  
  8469                                  setend_faterr:
  8470 000010CC 89D8                    	mov	ax,bx			; use calculated value
  8471                                  
  8472                                  setend_fat:
  8473                                  
  8474                                  ;	now ax = maximum legal cluster
  8475                                  
  8476                                  ;	end M008
  8477                                  
  8478                                  	;mov	[es:bp+0Dh], ax
  8479 000010CE 2689460D                	MOV	[ES:BP+DPB.MAX_CLUSTER],AX
  8480                                  	;;mov	word [es:bp+1Ch],0  ; MSDOS 3.3
  8481                                  	;mov	word [es:bp+1Dh],0  ; MSDOS 6.0
  8482 000010D2 26C7461D0000            	MOV	word [ES:BP+DPB.NEXT_FREE],0 
  8483                                  					; Init so first ALLOC starts at
  8484                                  					; begining of FAT
  8485                                  	;;mov	word [es:bp+1Eh],-1 ; MSDOS 3.3
  8486                                  	;mov	word [es:bp+1Fh],-1 ; MSDOS 6.0
  8487 000010D8 26C7461FFFFF            	MOV	word [ES:BP+DPB.FREE_CNT],-1 ; current count is invalid.
  8488                                  
  8489 000010DE C3                      	retn
  8490                                  
  8491                                  ;EndProc $SETDPB
  8492                                  
  8493                                  ;BREAK <$Create_Process_Data_Block,SetMem -- Set up process data block>
  8494                                  
  8495                                  ;
  8496                                  ;----------------------------------------------------------------------------
  8497                                  ;
  8498                                  ;**	$Dup_PDB
  8499                                  ;
  8500                                  ; Inputs:   DX is new segment address of process
  8501                                  ;	    SI is end of new allocation block
  8502                                  ;
  8503                                  ;----------------------------------------------------------------------------
  8504                                  ;
  8505                                  
  8506                                  _$DUP_PDB:
  8507                                  
  8508                                  ;hkn;	CreatePDB would have a CS override. This is not valid.
  8509                                  ;hkn;	Must set up ds in order to acess CreatePDB. Also SS is 
  8510                                  ;hkn;	has been assumed to be NOTHING. It may not have DOSDATA.
  8511                                  
  8512                                  	; MSDOS 3.3
  8513                                  	;MOV	byte [CS:CreatePDB],0FFh  ; indicate a new process
  8514                                  	;MOV	DS,[CS:CurrentPDB]
  8515                                  
  8516                                  	; 15/05/2019 - Retro DOS v4.0
  8517                                  	; MSDOS 6.0
  8518 000010DF 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  8519 000010E4 C606[A803]FF            	MOV	byte [CreatePDB],0FFh
  8520 000010E9 8E1E[3003]              	MOV	DS,[CurrentPDB]
  8521                                  
  8522 000010ED 56                      	PUSH	SI
  8523 000010EE EB0A                    	JMP	SHORT CreateCopy
  8524                                  
  8525                                  ;
  8526                                  ;----------------------------------------------------------------------------
  8527                                  ;
  8528                                  ; Inputs:
  8529                                  ;	DX = Segment number of new base
  8530                                  ; Function:
  8531                                  ;	Set up program base and copy term and ^C from int area
  8532                                  ; Returns:
  8533                                  ;	None
  8534                                  ; Called at DOS init
  8535                                  ;
  8536                                  ;----------------------------------------------------------------------------
  8537                                  ;
  8538                                  
  8539                                  ; 15/05/2019 - Retro DOS v4.0
  8540                                  ; DOSCODE:4EB6h (MSDOS 6.21, MSDOS.SYS)
  8541                                  
  8542                                  ; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  8543                                  ; DOSCODE:4EA2h (MSDOS 5.0, MSDOS.SYS)
  8544                                  
  8545                                  _$CREATE_PROCESS_DATA_BLOCK:
  8546                                  			; Offset 1D02h in IBMDOS.COM (MSDOS 3.3), 1987
  8547 000010F0 E89DF3                  	CALL	Get_User_Stack
  8548                                  	;mov	ds,[si+14h]
  8549 000010F3 8E5C14                  	MOV	DS,[SI+user_env.user_CS]
  8550                                  	;push	word [2]
  8551 000010F6 FF360200                	PUSH	word [PDB.BLOCK_LEN] ;*
  8552                                  CreateCopy:
  8553 000010FA 8EC2                    	MOV	ES,DX
  8554                                  
  8555 000010FC 31F6                    	XOR	SI,SI			; copy entire PDB
  8556 000010FE 89F7                    	MOV	DI,SI
  8557 00001100 B98000                  	MOV	CX,128
  8558 00001103 F3A5                    	REP	MOVSW
  8559                                  
  8560                                  ; DOS 3.3 7/9/86
  8561                                  	;mov	cx,20
  8562                                  	;MOV	CX,FILPERPROC		; copy handles in case of
  8563                                  	; 15/12/2022
  8564 00001105 B114                    	mov	cl,FILPERPROC ; 06/07/2019
  8565                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8566                                  	;mov	cx,FILPERPROC
  8567                                  
  8568                                  	;mov	di,18h
  8569 00001107 BF1800                  	MOV	DI,PDB.JFN_TABLE	; Set Handle Count has been issued
  8570                                  	;;PUSH	DS ; * 15/05/2019
  8571                                  	;;lds	si,[34h]
  8572                                  	;LDS	SI,[PDB.JFN_Pointer]
  8573                                  	;REP	MOVSB
  8574                                  	;;POP	DS ; * 15/05/2019
  8575                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8576                                  	; 05/12/2022
  8577                                  	; (push ds then pop ds is not needed here!)
  8578                                  	;push	ds
  8579                                  	;lds	si,[34h]
  8580 0000110A C5363400                	lds	si,[PDB.JFN_Pointer]
  8581 0000110E F3A4                    	rep	movsb
  8582                                  	;pop	ds
  8583                                  
  8584                                  ; DOS 3.3 7/9/86
  8585                                  	;hkn ;CreatePDB would have a CS override. This is not valid.
  8586                                  	;hkn ;Must set up ds in order to access CreatePDB. Also SS is 
  8587                                  	;hkn ;has been assumed to be NOTHING. It may not have DOSDATA.
  8588                                  
  8589 00001110 2E8E1E[0700]            	mov	ds,[cs:DosDSeg] ; 15/05/2019
  8590                                  
  8591                                  	;;test	byte [cs:CreatePDB],0FFh
  8592                                  	;cmp	byte [CS:CreatePDB],0	; Shall we create a process?
  8593                                  	; 17/12/2022
  8594 00001115 380E[A803]              	cmp	[CreatePDB],cl ; 0
  8595                                  	;cmp	byte [CreatePDB],0 ; 15/05/2019
  8596 00001119 744A                    	JZ	short Create_PDB_cont 	; nope, old style call
  8597                                  
  8598                                  ; Here we set up for a new process...
  8599                                  
  8600                                  	;PUSH	CS			; Called at DOSINIT time, NO SS
  8601                                  	;POP	DS
  8602                                  
  8603                                  	; MSDOS 6.0
  8604                                  	;;getdseg <ds>			; ds -> dosdata
  8605                                  	;mov	ds,[cs:DosDSeg] ; 15/05/2019
  8606                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8607                                  	; (nonsense! but i put this for addr compatibility as temporary)
  8608                                  	; 15/12/2022
  8609                                  	;mov	ds,[cs:DosDSeg] ; 15/05/2019
  8610                                  
  8611 0000111B 31DB                    	XOR	BX,BX			; dup all jfns
  8612                                  	;mov	cx,20
  8613                                  	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8614                                  	;MOV	CX,FILPERPROC		; only 20 of them
  8615                                  	; 15/12/2022
  8616 0000111D B114                    	mov	cl,FILPERPROC ; 06/07/2019
  8617                                  
  8618                                  Create_dup_jfn:
  8619 0000111F 06                      	PUSH	ES ;**			; save new PDB
  8620 00001120 E8BD55                  	call	SFFromHandle		; get sf pointer
  8621 00001123 B0FF                    	MOV	AL,-1			; unassigned JFN
  8622 00001125 7224                    	JC	short CreateStash	; file was not really open
  8623                                  	;;test	word [es:di+5],1000h
  8624                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_no_inherit
  8625                                  	; 15/05/2019
  8626                                  	;test	byte [es:di+6],10h
  8627 00001127 26F6450610              	test	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_no_inherit>>8)
  8628 0000112C 751D                    	JNZ	short CreateStash	; if no-inherit bit is set, skip dup.
  8629                                  
  8630                                  ; We do not inherit network file handles.
  8631                                  
  8632                                  	;mov	ah,[es:di+2]
  8633 0000112E 268A6502                	MOV	AH,[ES:DI+SF_ENTRY.sf_mode]
  8634                                  	;and	ah,0F0h
  8635 00001132 80E4F0                  	AND	AH,SHARING_MASK
  8636                                  	;cmp	ah,70h
  8637 00001135 80FC70                  	CMP	AH,SHARING_NET_FCB
  8638 00001138 7411                    	jz	short CreateStash
  8639                                  
  8640                                  ; The handle we have found is duplicatable (and inheritable). Perform
  8641                                  ; duplication operation.
  8642                                  
  8643 0000113A 893E[9E05]              	MOV	[THISSFT],DI
  8644 0000113E 8C06[A005]              	MOV	[THISSFT+2],ES
  8645 00001142 E85C19                  	call	DOS_DUP 		; signal duplication
  8646                                  
  8647                                  ; get the old sfn for copy
  8648                                  
  8649 00001145 E87B55                  	call	pJFNFromHandle		; ES:DI is jfn
  8650 00001148 268A05                  	MOV	AL,[ES:DI]		; get sfn
  8651                                  
  8652                                  ; Take AL (old sfn or -1) and stash it into the new position
  8653                                  
  8654                                  CreateStash:
  8655 0000114B 07                      	POP	ES ;**
  8656                                  	;mov	[es:bx+18h],al
  8657 0000114C 26884718                	MOV	[ES:BX+PDB.JFN_TABLE],AL ; copy into new place!
  8658 00001150 43                      	INC	BX			; next jfn...
  8659 00001151 E2CC                    	LOOP	Create_dup_jfn
  8660                                  
  8661 00001153 8B1E[3003]              	MOV	BX,[CurrentPDB]		; get current process
  8662                                  	; 06/11/2022
  8663                                  	;mov	[es:16h],bx
  8664 00001157 26891E1600              	MOV	[ES:PDB.PARENT_PID],BX	; stash in child
  8665 0000115C 8C06[3003]              	MOV	[CurrentPDB],ES
  8666                                  	;MOV	DS,BX ; 28/07/2019
  8667                                  	; 07/12/2022
  8668                                  	;mov	ds,[cs:DosDSeg]
  8669                                  	; 15/12/2022
  8670                                  	; ds = [cs:DosDSeg]
  8671 00001160 C606[A803]00            	mov	byte [CreatePDB],0	; reset flag
  8672                                  	;mov	ds,bx
  8673                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8674                                  	; 15/12/2022
  8675                                  	;mov	ds,bx
  8676                                  
  8677                                  ; end of new process create
  8678                                  
  8679                                  Create_PDB_cont:
  8680                                  	;MOV	BYTE [CS:CreatePDB],0	; reset flag
  8681                                  
  8682                                  ;hkn; It comes to this point from 2 places. So, change to DOSDATA temporarily	
  8683                                  
  8684                                  	;; 28/07/2019
  8685                                  	;;push	ds
  8686                                  	;;mov	ds,[cs:DosDSeg]
  8687                                  	;mov	byte [CreatePDB],0
  8688                                  	;;pop	ds
  8689                                  
  8690                                  ; 05/12/2022
  8691                                  ;	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  8692                                  ;	; (push-pop ds is nonsense here! 
  8693                                  ;	;  but i am using same code with original MSDOS.SYS
  8694                                  ;	;  for address compatibility.)
  8695                                  ;	push	ds
  8696                                  ;	; ds = [cs:DosDSeg] !
  8697                                  ;	mov	ds,[cs:DosDSeg]  ; again !
  8698                                  ;	mov	byte [CreatePDB],0
  8699                                  ;	pop	ds
  8700                                  
  8701 00001165 58                      	POP	AX ;*
  8702                                  
  8703                                  	;entry	SETMEM
  8704                                  
  8705                                  	; 17/12/2022
  8706                                  	; cx = 0
  8707                                  
  8708                                  ;---------------------------------------------------------------------------
  8709                                  ; Inputs:
  8710                                  ;	AX = Size of memory in paragraphs
  8711                                  ;	DX = Segment
  8712                                  ; Function:
  8713                                  ;	Completely prepares a program base at the
  8714                                  ;	specified segment.
  8715                                  ; Called at DOS init
  8716                                  ; Outputs:
  8717                                  ;	DS = DX
  8718                                  ;	ES = DX
  8719                                  ;	[0] has INT int_abort
  8720                                  ;	[2] = First unavailable segment
  8721                                  ;	[5] to [9] form a long call to the entry point
  8722                                  ;	[10] to [13] have exit address (from int_terminate)
  8723                                  ;	[14] to [17] have ctrl-C exit address (from int_ctrl_c)
  8724                                  ;	[18] to [21] have fatal error address (from int_fatal_abort)
  8725                                  ; DX,BP unchanged. All other registers destroyed.
  8726                                  ;---------------------------------------------------------------------------
  8727                                  
  8728                                  SETMEM:
  8729                                  	;XOR	CX,CX
  8730                                  	; 17/12/2022
  8731                                  	; cx = 0
  8732 00001166 8ED9                    	MOV	DS,CX
  8733 00001168 8EC2                    	MOV	ES,DX
  8734                                  	;mov	si,88h
  8735 0000116A BE8800                  	MOV	SI,addr_int_terminate
  8736                                  	;mov	di,10 ; 0Ah
  8737 0000116D BF0A00                  	MOV	DI,SAVEXIT
  8738                                  	;MOV	CX,6
  8739                                  	; 15/12/2022
  8740 00001170 B106                    	mov	cl,6
  8741 00001172 F3A5                    	REP	MOVSW
  8742 00001174 26A30200                	MOV	[ES:2],AX
  8743 00001178 29D0                    	SUB	AX,DX
  8744 0000117A 3DFF0F                  	CMP	AX,MAXDIF ; 0FFFh
  8745 0000117D 7603                    	JBE	short HAVDIF
  8746 0000117F B8FF0F                  	MOV	AX,MAXDIF
  8747                                  HAVDIF:
  8748 00001182 83E810                  	SUB	AX,10h			; Allow for 100h byte "stack"
  8749 00001185 BB0C00                  	MOV	BX,ENTRYPOINTSEG ; 0Ch	;	in .COM files
  8750 00001188 29C3                    	SUB	BX,AX
  8751 0000118A B104                    	MOV	CL,4
  8752 0000118C D3E0                    	SHL	AX,CL
  8753 0000118E 8EDA                    	MOV	DS,DX
  8754                                  
  8755                                  	; (MSDOS 6.0 note)
  8756                                  	;
  8757                                  	; The address in BX:AX will be F01D:FEF0 if there is 64K or more 
  8758                                  	; memory in the system. This is equivalent to 0:c0 if A20 is OFF.
  8759                                  	; If DOS is in HMA this equivalence is no longer valid as A20 is ON.
  8760                                  	; But the BIOS which now resides in FFFF:30 has 5 bytes in FFFF:D0
  8761                                  	; (F01D:FEF0) which is the same as the ones in 0:C0, thereby 
  8762                                  	; making this equvalence valid for this particular case. If however
  8763                                  	; there is less than 64K remaining the address in BX:AX will not 
  8764                                  	; be the same as above. We will then stuff 0:c0, the call 5 address
  8765                                  	; into the PSP.
  8766                                  	;
  8767                                  	; Therefore for the case where there is less than 64K remaining in 
  8768                                  	; the system old CPM Apps that look at PSP:6 to determine memory
  8769                                  	; requirements will not work. Call 5, however will continue to work
  8770                                  	; for all cases.
  8771                                  	;
  8772                                  
  8773                                  	;mov	[6],ax
  8774                                  	;mov	[8],bx
  8775                                  
  8776 00001190 A30600                  	MOV	[PDB.CPM_CALL+1],AX
  8777 00001193 891E0800                	MOV	[PDB.CPM_CALL+3],BX
  8778                                  
  8779                                  	; 06/05/2019 - Retro DOS v4.0
  8780 00001197 3DF0FE                  	cmp	ax,WRAPOFFSET ; 0FEF0h	; Q: does the system have >= 64k of
  8781                                  					;    memory left
  8782 0000119A 740C                    	je	short addr_ok		; Y: the above calculated address is
  8783                                  					;    OK
  8784                                  					; N: 
  8785                                  
  8786 0000119C C7060600C000            	MOV	WORD [PDB.CPM_CALL+1],0C0h
  8787 000011A2 C70608000000            	MOV	WORD [PDB.CPM_CALL+3],0
  8788                                  addr_ok:
  8789                                  	;mov	word [0],20CDh
  8790 000011A8 C7060000CD20            	MOV	word [PDB.EXIT_CALL],(int_abort*256) + mi_INT
  8791                                  	;mov	byte [5],9Ah
  8792 000011AE C60605009A              	MOV	BYTE [PDB.CPM_CALL],mi_Long_CALL
  8793                                  	;mov	word [50h],21CDh
  8794 000011B3 C7065000CD21            	MOV	WORD [PDB.CALL_SYSTEM],(int_command*256) + mi_INT
  8795                                  	;mov	byte [52h],0CBh
  8796 000011B9 C6065200CB              	MOV	BYTE [PDB.CALL_SYSTEM+2],mi_Long_RET
  8797                                  	;mov	word [34h],18h
  8798 000011BE C70634001800            	MOV	WORD [PDB.JFN_Pointer],PDB.JFN_TABLE
  8799                                  	;mov	word [36h],ds
  8800 000011C4 8C1E3600                	MOV	WORD [PDB.JFN_Pointer+2],DS
  8801                                  	;mov	word [32h],20
  8802 000011C8 C70632001400            	MOV	WORD [PDB.JFN_Length],FILPERPROC
  8803                                  ;
  8804                                  ; The server runs several PDB's without creating them VIA EXEC.  We need to
  8805                                  ; enumerate all PDB's at CPS time in order to find all references to a
  8806                                  ; particular SFT.  We perform this by requiring that the server link together
  8807                                  ; for us all sub-PDB's that he creates. The requirement for us, now, is to
  8808                                  ; initialize this pointer.
  8809                                  ;
  8810                                   	;mov	word [38h],-1
  8811 000011CE C7063800FFFF            	MOV	word [PDB.Next_PDB],-1
  8812                                  	;mov	word [3Ah],-1
  8813 000011D4 C7063A00FFFF            	MOV	word [PDB.Next_PDB+2],-1
  8814                                  
  8815                                  	; 06/05/2019
  8816                                  	; Set the real version number in the PSP - 5.00
  8817                                  
  8818                                  	;mov	word [es:PDB.Version],1406h ; MSDOS 6.21 (DOSCODE:4FB6h)
  8819                                  	; 07/12/2022
  8820 000011DA 26C70640000616          	mov	word [ES:PDB.Version],(MINOR_VERSION*256)+MAJOR_VERSION
  8821                                  
  8822 000011E1 C3                      	retn
  8823                                  
  8824                                  ; 29/04/2019 - Retro DOS v4.0
  8825                                  
  8826                                  ;BREAK <$GSetMediaID -- get set media ID>
  8827                                  
  8828                                  ;---------------------------------------------------------------------------
  8829                                  ; Inputs:
  8830                                  ;	BL= drive number as defined in IOCTL
  8831                                  ;	AL= 0 get media ID
  8832                                  ;	    1 set media ID
  8833                                  ;	DS:DX= buffer containing information
  8834                                  ;		DW  0  info level (set on input)
  8835                                  ;		DD  ?  serial #
  8836                                  ;		DB  11 dup(?)  volume id
  8837                                  ;		DB   8 dup(?)  file system type
  8838                                  ; Function:
  8839                                  ;	Get or set media ID
  8840                                  ; Returns:
  8841                                  ;	carry clear, DS:DX is filled
  8842                                  ;	carry set, error
  8843                                  ;---------------------------------------------------------------------------
  8844                                  
  8845                                  	; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  8846                                  _$GSetMediaID:
  8847                                  	; RAWIO - GET_MEDIA_ID
  8848 000011E2 B96608                  	mov	cx,0866h	      ;AN000;MS.; assume get  for IOCTL
  8849 000011E5 3C00                    	cmp	al,0		      ;AN001;MS.; get ?
  8850 000011E7 7406                    	je	short doioctl 	      ;AN000;MS.; yes
  8851                                  	;cmp	al,1		      ;AN000;MS.; set ?
  8852                                  	;jne	short errorfunc	      ;AN000;MS.; no
  8853                                  	; 15/12/2022
  8854 000011E9 FEC8                    	dec	al
  8855 000011EB 7507                    	jnz	short errorfunc ; al > 1
  8856                                  	; RAWIO - SET_MEDIA_ID
  8857                                  	;mov	cx,0846h	      ;AN001;MS.;
  8858                                  	; 15/12/2022
  8859 000011ED B146                    	mov	cl,46h	; cx = 0846h 
  8860                                  doioctl:			      ;AN000;
  8861 000011EF B00D                    	mov	al,0Dh		      ;AN000;MS.; generic IOCTL
  8862                                  	;invoke	$IOCTL		      ;AN000;MS.; let IOCTL take care of it
  8863                                  	;call	_$IOCTL
  8864                                  	;retn			      ;AN000;MS.;
  8865                                  	; 15/12/2022
  8866 000011F1 E9E910                  	jmp	_$IOCTL
  8867                                  errorfunc:			      ;AN000;
  8868                                  	;error	error_invalid_function;AN000;MS. ; invalid function
  8869                                  	;mov	al,1
  8870 000011F4 B001                    	mov	al,error_invalid_function
  8871 000011F6 E95AF4                  	jmp	SYS_RET_ERR
  8872                                  
  8873                                  ; 16/05/2019 - Retro DOS v4.0
  8874                                  
  8875                                  ;============================================================================
  8876                                  ; MISC2.ASM, MSDOS 6.0, 1991
  8877                                  ;============================================================================
  8878                                  ; 20/07/2018 - Retro DOS v3.0
  8879                                  ; 29/04/2019 - Retro DOS v4.0
  8880                                  
  8881                                  ; Break <STRCMP - compare two ASCIZ strings DS:SI to ES:DI>
  8882                                  ;----------------------------------------------------------------------------
  8883                                  ;
  8884                                  ;   Strcmp - compare ASCIZ DS:SI to ES:DI. Case INSENSITIVE. '/' = '\'
  8885                                  ;	     Strings of different lengths don't match.
  8886                                  ;   Inputs:  DS:SI - pointer to source string  ES:DI - pointer to dest string
  8887                                  ;   Outputs: Z if strings same, NZ if different
  8888                                  ;   Registers modified: NONE
  8889                                  ;----------------------------------------------------------------------------
  8890                                  
  8891                                  	; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  8892                                  StrCmp:
  8893 000011F9 56                      	push	si
  8894 000011FA 57                      	push	di
  8895 000011FB 50                      	push	ax
  8896                                  
  8897                                  Cmplp:
  8898 000011FC AC                      	LODSB
  8899 000011FD E8AC3E                  	call	UCase			; convert to upper case
  8900 00001200 E8FE3E                  	call	PATHCHRCMP		; convert '/' to '\' ; 07/12/2022 ('\')
  8901 00001203 88C4                    	MOV	AH,AL
  8902 00001205 268A05                  	MOV	AL,[ES:DI]
  8903 00001208 47                      	INC	DI
  8904 00001209 E8A03E                  	call	UCase			; convert to upper case
  8905 0000120C E8F23E                  	call	PATHCHRCMP		; convert '/' to '\' ; 07/12/2022 ('\')
  8906 0000120F 38C4                    	CMP	AH,AL
  8907 00001211 7504                    	JNZ	short PopRet		; Strings dif
  8908                                  
  8909 00001213 08C0                    	OR	AL,AL
  8910 00001215 75E5                    	JNZ	short Cmplp		; More string
  8911                                  PopRet:
  8912 00001217 58                      	pop	ax
  8913 00001218 5F                      	pop	di
  8914 00001219 5E                      	pop	si
  8915 0000121A C3                      	retn
  8916                                  
  8917                                  ;Break <STRCPY - copy ASCIZ string from DS:SI to ES:DI>
  8918                                  ;----------------------------------------------------------------------------
  8919                                  ;
  8920                                  ;   Strcpy - copy an ASCIZ string from DS:SI to ES:DI and make uppercase
  8921                                  ;   FStrcpy - copy an ASCIZ string from DS:SI to ES:DI. no modification of
  8922                                  ;	characters.
  8923                                  ;
  8924                                  ;   Inputs:	DS:SI - pointer to source string
  8925                                  ;		ES:DI - pointer to destination string
  8926                                  ;   Outputs:	ES:DI point byte after nul byte at end of dest string
  8927                                  ;		DS:SI point byte after nul byte at end of source string
  8928                                  ;   Registers modified: SI,DI
  8929                                  ;----------------------------------------------------------------------------
  8930                                  
  8931                                  StrCpy:
  8932 0000121B 50                      	push	ax
  8933                                  CPYLoop:
  8934 0000121C AC                      	LODSB
  8935 0000121D E88C3E                  	call	UCase			; convert to upper case
  8936 00001220 E8DE3E                  	call	PATHCHRCMP		; convert / to \ ;
  8937 00001223 AA                      	STOSB
  8938                                  
  8939 00001224 08C0                    	OR	AL,AL
  8940 00001226 75F4                    	JNZ	short CPYLoop
  8941 00001228 58                      	pop	ax
  8942 00001229 C3                      	retn
  8943                                  
  8944                                  ;----------------------------------------------------------------------------
  8945                                  ; Procedure Name : FStrCpy
  8946                                  ;----------------------------------------------------------------------------
  8947                                  
  8948                                  FStrCpy:
  8949 0000122A 50                      	push	ax
  8950                                  FCPYLoop:
  8951 0000122B AC                      	LODSB
  8952 0000122C AA                      	STOSB
  8953 0000122D 08C0                    	OR	AL,AL
  8954 0000122F 75FA                    	JNZ	short FCPYLoop
  8955 00001231 58                      	pop	ax
  8956 00001232 C3                      	retn
  8957                                  
  8958                                  ; 20/07/2018 - Retro DOS v3.0
  8959                                  ;----------------------------------------------------------------------------
  8960                                  ; UCase, IBMDOS.COM (MSDOS 3.3), 1987 - Offset 1E2Fh
  8961                                  ;----------------------------------------------------------------------------
  8962                                  ;
  8963                                  ;UCase:	
  8964                                  ;	call	_UCase	 ; Offset 5518h (GetLet, Offset 5517h)
  8965                                  ;	retn
  8966                                  
  8967                                  ;Break <StrLen - compute length of string ES:DI>
  8968                                  ;----------------------------------------------------------------------------
  8969                                  ;**	StrLen - Compute Length of String
  8970                                  ;
  8971                                  ;	StrLen computes the length of a string, including the trailing 00
  8972                                  ;
  8973                                  ;	ENTRY	(es:di) = address of string
  8974                                  ;	EXIT	(cx) = size of string
  8975                                  ;	USES	cx, flags
  8976                                  ;----------------------------------------------------------------------------
  8977                                  
  8978                                  StrLen:
  8979 00001233 57                      	push	di
  8980 00001234 50                      	push	ax
  8981                                  	;MOV	CX,-1
  8982 00001235 B9FFFF                  	mov	cx,65535
  8983 00001238 30C0                    	XOR	AL,AL
  8984 0000123A F2AE                    	REPNE	SCASB
  8985 0000123C F7D1                    	NOT	CX
  8986 0000123E 58                      	pop	ax
  8987 0000123F 5F                      	pop	di
  8988 00001240 C3                      	retn
  8989                                  
  8990                                  ;----------------------------------------------------------------------------
  8991                                  ;**	DStrLen - Compute Length of String
  8992                                  ;
  8993                                  ;	ENTRY	(ds:si) = address of string
  8994                                  ;	EXIT	(cx) = size of string, including trailing NUL
  8995                                  ;	USES	cx, flags
  8996                                  ;----------------------------------------------------------------------------
  8997                                  
  8998                                  DStrLen:	; BUGBUG - this guy is a pig, who uses him?
  8999 00001241 E80300                  	CALL	XCHGP
  9000 00001244 E8ECFF                  	CALL	StrLen
  9001                                  	;CALL	XCHGP
  9002                                  	;retn
  9003                                  	; 18/12/2022
  9004                                  	;jmp	short XCHGP
  9005                                  
  9006                                  ;----------------------------------------------------------------------------
  9007                                  ;**	XCHGP - Exchange Source and Destination Pointers
  9008                                  ;
  9009                                  ;	XCHGP exchanges (DS:SI) and (ES:DI)
  9010                                  ;
  9011                                  ;	ENTRY	none
  9012                                  ;	EXIT	pairs exchanged
  9013                                  ;	USES	SI, DI, DS, ES
  9014                                  ;----------------------------------------------------------------------------
  9015                                  
  9016                                  XCHGP:
  9017 00001247 1E                      	push	ds
  9018 00001248 06                      	push	es
  9019 00001249 1F                      	pop	ds
  9020 0000124A 07                      	pop	es
  9021 0000124B 87F7                    	XCHG	SI,DI
  9022                                  xchgp_retn:
  9023 0000124D C3                      	retn
  9024                                  
  9025                                  ;Break	<Idle - wait for a specified amount of time>
  9026                                  ;----------------------------------------------------------------------------
  9027                                  ;
  9028                                  ;   Idle - when retrying an operation due to a lock/sharing violation,
  9029                                  ;   	   we spin until RetryLoop is exhausted.
  9030                                  ;
  9031                                  ;   Inputs:	RetryLoop is the number of times we spin
  9032                                  ;   Outputs:	Wait
  9033                                  ;   Registers modified: none
  9034                                  ;----------------------------------------------------------------------------
  9035                                  
  9036                                  Idle:
  9037                                  	;test	byte [SS:FSHARING],0FFh
  9038 0000124E 36803E[7205]00          	cmp	byte [SS:FSHARING],0	;hkn; SS override
  9039                                  	;retnz
  9040 00001254 75F7                    	jnz	short xchgp_retn
  9041                                  	;SAVE	<CX>
  9042 00001256 51                      	push	cx
  9043 00001257 368B0E[1C00]            	MOV	CX,[ss:RetryLoop]	;hkn; SS override
  9044 0000125C E308                    	JCXZ	Idle3
  9045                                  Idle1:	
  9046 0000125E 51                      	PUSH	CX
  9047 0000125F 31C9                    	XOR	CX,CX
  9048                                  Idle2:	
  9049 00001261 E2FE                    	LOOP	Idle2
  9050 00001263 59                      	POP	CX
  9051 00001264 E2F8                    	LOOP	Idle1
  9052                                  Idle3:	
  9053                                  	;RESTORE <CX>
  9054 00001266 59                      	pop	cx
  9055 00001267 C3                      	retn
  9056                                  
  9057                                  ;Break	<TableDispatch - dispatch to a table>
  9058                                  ;----------------------------------------------------------------------------
  9059                                  ;
  9060                                  ;   TableDispatch - given a table and an index, jmp to the approptiate
  9061                                  ;   routine. Preserve all input registers to the routine.
  9062                                  ;
  9063                                  ;   Inputs:	Push	return address
  9064                                  ;		Push	Table address
  9065                                  ;		Push	index (byte)
  9066                                  ;   Outputs:	appropriate routine gets jumped to.
  9067                                  ;		return indicates invalid index
  9068                                  ;   Registers modified: none.
  9069                                  ;----------------------------------------------------------------------------
  9070                                  
  9071                                  struc TFrame	 ; TableFrame
  9072 00000000 ????                    .OldBP:	 resw 1  ; 0
  9073 00000002 ????                    .OldRet: resw 1  ; 2
  9074 00000004 ??                      .Index:	 resb 1  ; 4
  9075 00000005 ??                      .Pad:	 resb 1  ; 5  
  9076 00000006 ????                    .Tab:	 resw 1  ; 6
  9077 00000008 ????                    .NewRet: resw 1  ; 8
  9078                                  endstruc
  9079                                  
  9080                                  TableDispatch:
  9081 00001268 55                      	PUSH	BP
  9082 00001269 89E5                    	MOV	BP,SP
  9083 0000126B 53                      	PUSH	BX			; save BX
  9084                                  	;mov	bx,[bp+6]
  9085 0000126C 8B5E06                  	MOV	BX,[BP+TFrame.Tab]	; get pointer to table
  9086 0000126F 2E8A1F                  	MOV	BL,[CS:BX]		; maximum index
  9087                                  	;cmp	[bp+4],bl
  9088 00001272 385E04                  	CMP	[BP+TFrame.Index],BL	; table error?
  9089 00001275 7317                    	JAE	short TableError	; yes
  9090                                  	;mov	bl,[bp+4]
  9091 00001277 8A5E04                  	MOV	BL,[BP+TFrame.Index]	; get desired table index
  9092 0000127A 30FF                    	XOR	BH,BH			; convert to word
  9093 0000127C D1E3                    	SHL	BX,1			; convert to word pointer
  9094 0000127E 43                      	INC	BX			; point past first length byte
  9095                                  	; 17/08/2018
  9096                                  	;add	bx,[bp+6]
  9097 0000127F 035E06                  	ADD	BX,[BP+TFrame.Tab]	; get real offset
  9098 00001282 2E8B1F                  	MOV	BX,[CS:BX]		; get contents of table entry
  9099                                  	;mov	[bp+6],bx
  9100 00001285 895E06                  	MOV	[BP+TFrame.Tab],BX	; put table entry into return address
  9101 00001288 5B                      	POP	BX			; restore BX
  9102 00001289 5D                      	POP	BP			; restore BP
  9103 0000128A 83C404                  	ADD	SP,4			; clean off Index and our return addr
  9104 0000128D C3                      	retn				; do operation
  9105                                  TableError:
  9106 0000128E 5B                      	POP	BX			; restore BX
  9107 0000128F 5D                      	POP	BP			; restore BP
  9108 00001290 C20600                  	RETN	6			; clean off Index, Table and RetAddr
  9109                                  
  9110                                  
  9111                                  ;Break	<TestNet - determine if a CDS is for the network>
  9112                                  ;----------------------------------------------------------------------------
  9113                                  ;
  9114                                  ;   TestNet - examine CDS pointed to by ThisCDS and see if it indicates a
  9115                                  ;	network CDS. This will handle NULL cds also.
  9116                                  ;
  9117                                  ;   Inputs:	ThisCDS points to CDS or NULL
  9118                                  ;   Outputs:	ES:DI = ThisCDS
  9119                                  ;		carry Set => network
  9120                                  ;		carry Clear => local
  9121                                  ;   Registers modified: none.
  9122                                  ;----------------------------------------------------------------------------
  9123                                  
  9124                                  TestNet:
  9125                                  	;LES	DI,[CS:THISCDS]
  9126                                  
  9127                                  	; 16/05/2019 - Retro DOS v4.0
  9128 00001293 2E8E06[0700]            	mov	es,[cs:DosDSeg]
  9129 00001298 26C43E[A205]            	LES	DI,[ES:THISCDS]
  9130 0000129D 83FFFF                  	CMP	DI,-1
  9131 000012A0 7408                    	JZ	short CMCRet		; UNC? carry is clear
  9132                                  	;;test	word [es:di+43h],8000h
  9133                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet
  9134                                  	;test	byte [es:di+44h],80h
  9135 000012A2 26F6454480              	TEST	byte [ES:DI+curdir.flags+1],(curdir_isnet>>8)
  9136 000012A7 7501                    	JNZ	short CMCRet		; jump has carry clear
  9137 000012A9 C3                      	retn				; carry is clear
  9138                                  CMCRet: 
  9139 000012AA F5                      	CMC
  9140 000012AB C3                      	retn
  9141                                  
  9142                                  ;Break	<IsSFTNet - see if an sft is for the network>
  9143                                  ;----------------------------------------------------------------------------
  9144                                  ;
  9145                                  ;   IsSFTNet - examine SF pointed to by ES:DI and see if it indicates a
  9146                                  ;	network file.
  9147                                  ;
  9148                                  ;   Inputs:	ES:DI point to SFT
  9149                                  ;   Outputs:	Zero set if not network sft
  9150                                  ;		zero reset otherwise
  9151                                  ;		Carry CLEAR!!!
  9152                                  ;   Registers modified: none.
  9153                                  ;----------------------------------------------------------------------------
  9154                                  
  9155                                  IsSFTNet:
  9156                                  	;;test	word [es:di+5],8000h
  9157                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
  9158                                  	; 16/05/2019 
  9159                                  	;test	byte [es:di+6],80h
  9160 000012AC 26F6450680              	TEST	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
  9161 000012B1 C3                      	retn
  9162                                  
  9163                                  ;Break	<FastInit - Initialize FastTable entries >
  9164                                  ;----------------------------------------------------------------------------
  9165                                  ;   DOS 4.00   2/9/87
  9166                                  ;   FastInit  - initialize the FASTXXX routine entry
  9167                                  ;		  in the FastTable
  9168                                  ;
  9169                                  ;   Inputs:	BX = FASTXXX ID ( 1=fastopen )
  9170                                  ;		DS:SI = address of FASTXXX routine entry
  9171                                  ;		   SI = -1 for query only
  9172                                  ;   Outputs:	Carry flag clear, if success
  9173                                  ;		Carry flag set,   if failure
  9174                                  ;
  9175                                  ;
  9176                                  ;----------------------------------------------------------------------------
  9177                                  
  9178                                  ;Procedure FastInit,NEAR
  9179                                  ;	ASSUME	CS:DOSCODE,SS:NOTHING
  9180                                  
  9181                                  ;	; MSDOS 3.3
  9182                                  ;	; IBMDOS.COM (1987) - Offset 1EB3h
  9183                                  ;FastInit:
  9184                                  ;	mov	di,FastTable ; FastOpenTable
  9185                                  ;	mov	ax,[cs:di+4]		; Entry segment
  9186                                  ;	mov	bx,cs			; get DOS segment
  9187                                  ;	cmp	ax,bx			; first time installed ?	
  9188                                  ;	je	short ok_install	; yes
  9189                                  ;	stc				; set carry
  9190                                  ;	retn				; (cf=1 means) already installed !
  9191                                  ;
  9192                                  ;ok_install:
  9193                                  ;	mov	bx,FastTable ; FastOpenTable
  9194                                  ;	mov	cx,ds
  9195                                  ;	; set address of FASTXXX (FASTOPEN) routine entry
  9196                                  ;	mov	[cs:bx+4],cx
  9197                                  ;	mov	[cs:bx+2],si
  9198                                  ;	retn
  9199                                  
  9200                                  ; 16/05/2019 - Retro DOS v4.0
  9201                                  
  9202                                  FastInit:
  9203                                  	; MSDOS 6.0
  9204                                  	;hkn; set up es to dosdataseg.
  9205 000012B2 06                      	push	es
  9206                                  	;getdseg <es>			; es -> dosdata
  9207 000012B3 2E8E06[0700]            	mov	es,[cs:DosDSeg]
  9208                                  
  9209                                  	;hkn; FastTable is in DOSDATA
  9210 000012B8 BF[320D]                	MOV	DI,FastTable+2		;AN000;FO. points to fastxxx entry
  9211 000012BB 4B                      	DEC	BX			;AN000;FO.;; decrement index
  9212 000012BC 89DA                    	MOV	DX,BX			;AN000;FO.;; save bx
  9213 000012BE D1E3                    	SHL	BX,1			;AN000;FO.;; times 4 , each entry is DWORD
  9214 000012C0 D1E3                    	SHL	BX,1			;AN000;FO.
  9215 000012C2 01DF                    	ADD	DI,BX			;AN000;FO. index to the entry
  9216 000012C4 268B4502                	MOV	AX,[ES:DI+2]		;AN000;FO. get entry segment
  9217                                  fcheck: 				;AN000;
  9218 000012C8 8CC9                    	MOV	CX,CS			;AN000;FO.;; get DOS segment
  9219 000012CA 39C8                    	CMP	AX,CX			;AN000;FO.;; first time installed ?
  9220 000012CC 7407                    	JZ	short ok_install	;AN000;FO.;; yes
  9221 000012CE 09C0                    	OR	AX,AX			;AN000;FO.;
  9222 000012D0 7403                    	JZ	short ok_install	;AN000;FO.;
  9223 000012D2 F9                      	STC				;AN000;FO.;; already installed !
  9224 000012D3 EB17                    	JMP	SHORT FSret		;AN000;FO. set carry
  9225                                  ok_install:				;AN000;
  9226 000012D5 83FEFF                  	CMP	SI,-1			;AN000;FO.; Query only ?
  9227 000012D8 7412                    	JZ	short FSret		;AN000;FO.; yes
  9228 000012DA 8CD9                    	MOV	CX,DS			;AN000;FO.; get FASTXXX entry segment
  9229 000012DC 26894D02                	MOV	[ES:DI+2],CX		;AN000;FO.; initialize routine entry
  9230 000012E0 268935                  	MOV	[ES:DI],SI		;AN000;FO.; initialize routine offset
  9231                                  
  9232                                  ;hkn; FastFlg moved to DOSDATA
  9233 000012E3 BF[3A0D]                	MOV	DI,FastFlg		;AN000;FO.; get addr of FASTXXX flags
  9234 000012E6 01D7                    	ADD	DI,DX			;AN000;FO.; index to a FASTXXX flag
  9235                                  	;or	byte [es:di],80h
  9236 000012E8 26800D80                	OR	byte [ES:DI],Fast_yes	;AN000;FO.; indicate installed
  9237                                  FSret:					;AN000;
  9238 000012EC 07                      	pop	es
  9239 000012ED C3                      	retn				;AN000;FO.
  9240                                  
  9241                                  ;EndProc FastInit
  9242                                  
  9243                                  ;Break	<FastRet - initial routine in FastOpenTable >
  9244                                  ;----------------------------------------------------------------------------
  9245                                  ;   DOS 3.3   6/10/86
  9246                                  ;   FastRet	- indicate FASTXXXX  not in memory
  9247                                  ;
  9248                                  ;   Inputs:	None
  9249                                  ;   Outputs:	AX = -1 and carry flag set
  9250                                  ;
  9251                                  ;   Registers modified: none.
  9252                                  ;----------------------------------------------------------------------------
  9253                                  
  9254                                  FastRet:
  9255                                  	;mov	ax,-1
  9256                                  	;stc
  9257                                  	;retf
  9258 000012EE F9                      	STC
  9259 000012EF 19C0                    	sbb	ax,ax		; (ax) = -1, 'C' set
  9260 000012F1 CB                      	RETF
  9261                                  
  9262                                  ;Break	<NLS_OPEN - do $open for NLSFUNC>
  9263                                  ;----------------------------------------------------------------------------
  9264                                  ;   DOS 3.3   6/10/86
  9265                                  ;   NLS_OPEN	- call $OPEN for NLSFUNC
  9266                                  ;
  9267                                  ;   Inputs:	Same input as $OPEN except CL = mode
  9268                                  ;   Outputs:	same output as $OPEN
  9269                                  ;
  9270                                  ;----------------------------------------------------------------------------
  9271                                  
  9272                                  ;hkn; NOTE! SS MUST HAVE BEEN SET UP TO DOSDATA BY THE TIME THESE
  9273                                  ;hkn; NLS FUNCTIONS ARE CALLED!!! THERE FORE WE WILL USE SS OVERRIDES
  9274                                  ;hkn; IN ORDER TO ACCESS DOS DATA VARIABLES!
  9275                                  
  9276                                  NLS_OPEN:
  9277                                  ;	MOV	BL,[CPSWFLAG]	 ; disable code page matching logic
  9278                                  ;	MOV	BYTE [CPSWFLAG],0
  9279                                  ;	PUSH	BX		 ; save current state
  9280                                  
  9281 000012F2 88C8                    	MOV	AL,CL		 ; set up correct interface for $OPEN
  9282 000012F4 E8535C                  	call	_$OPEN
  9283                                  
  9284                                  ;	POP	BX		 ; restore current state
  9285                                  ;	MOV	[CPSWFLAG],BL
  9286                                  
  9287 000012F7 C3                      	RETN
  9288                                  
  9289                                  ;Break	<NLS_LSEEK - do $LSEEK for NLSFUNC>
  9290                                  ;----------------------------------------------------------------------------
  9291                                  ;   DOS 3.3   6/10/86
  9292                                  ;   NLS_LSEEK	- call $LSEEK for NLSFUNC
  9293                                  ;
  9294                                  ;   Inputs:	BP = open mode
  9295                                  ;   Outputs:	same output as $LSEEK
  9296                                  ;
  9297                                  ;----------------------------------------------------------------------------
  9298                                  
  9299                                  ; 16/05/2019 - Retro DOS v4.0
  9300                                  
  9301                                  NLS_LSEEK:
  9302 000012F8 36FF36[8405]            	PUSH	word [SS:USER_SP] ; save user stack
  9303 000012FD 36FF36[8605]            	PUSH	word [SS:USER_SS]
  9304 00001302 E81000                  	CALL	Fake_User_Stack
  9305 00001305 89E8                    	MOV	AX,BP		; set up correct interface for $LSEEK
  9306 00001307 E8ED55                  	call	_$LSEEK
  9307 0000130A 368F06[8605]            	POP	word [SS:USER_SS] ; restore user stack
  9308 0000130F 368F06[8405]            	POP	word [SS:USER_SP]
  9309 00001314 C3                      	RETN
  9310                                  
  9311                                  ;Break	<Fake_User_Stack - save user stack>
  9312                                  ;----------------------------------------------------------------------------
  9313                                  ;   DOS 3.3   6/10/86
  9314                                  ;   Fake_User_Stack - save user stack pointer
  9315                                  ;
  9316                                  ;----------------------------------------------------------------------------
  9317                                  
  9318                                  Fake_User_Stack:
  9319 00001315 36A1[6A0D]              	MOV	AX,[SS:USER_SP_2F] ; replace with INT 2F stack
  9320 00001319 36A3[8405]              	MOV	[SS:USER_SP],AX
  9321 0000131D 8CD0                    	MOV	AX,SS
  9322 0000131F 36A3[8605]              	MOV	[SS:USER_SS],AX
  9323 00001323 C3                      	RETN
  9324                                  
  9325                                  ;Break	<GetDevList - get device header list pointer>
  9326                                  ;----------------------------------------------------------------------------
  9327                                  ;   DOS 3.3   7/25/86
  9328                                  ;   GetDevList - get device header list pointer
  9329                                  ;
  9330                                  ;   Output: AX:BX points to the device header list
  9331                                  ;----------------------------------------------------------------------------
  9332                                  
  9333                                  GetDevList:
  9334                                  	; 16/05/2019 - Retro DOS v4.0
  9335 00001324 BE[280D]                	MOV	SI,SysInitTable
  9336 00001327 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
  9337 0000132C C534                    	LDS	SI,[SI]
  9338                                  	;mov	ax,[si+34]  ; SSYSINITVARS offset 34 = [SI+SYSI.DEV]
  9339 0000132E 8B4422                  	MOV	AX,[SI+SYSI.DEV]
  9340                                  	;mov	bx,[si+36]  ; SSYSINITVARS offset 36 = [SI+SYSI.DEV+2]
  9341 00001331 8B5C24                  	MOV	BX,[SI+SYSI.DEV+2]
  9342 00001334 C3                      	RETN
  9343                                  
  9344                                  ;Break	<NLS_IOCTL - do $IOCTL for NLSFUNC   >
  9345                                  ;----------------------------------------------------------------------------
  9346                                  ;   DOS 3.3   7/25/86
  9347                                  ;   NLS_IOCTL	- call $IOCTL for NLSFUNC
  9348                                  ;
  9349                                  ;   Inputs:	BP = function code 0CH
  9350                                  ;   Outputs:	same output as generic $IOCTL
  9351                                  ;
  9352                                  ;----------------------------------------------------------------------------
  9353                                  
  9354                                  NLS_IOCTL:
  9355                                  	; 16/05/2019 - Retro DOS v4.0
  9356 00001335 36FF36[8405]            	PUSH	word [SS:USER_SP] ; save user stack
  9357 0000133A 36FF36[8605]            	PUSH	word [SS:USER_SS]
  9358 0000133F E8D3FF                  	CALL	Fake_User_Stack
  9359 00001342 89E8                    	MOV	AX,BP	     ; set up correct interface for $LSEEK
  9360 00001344 E8960F                  	call	_$IOCTL
  9361 00001347 368F06[8605]            	POP	word [SS:USER_SS] ; restore user stack
  9362 0000134C 368F06[8405]            	POP	word [SS:USER_SP]
  9363 00001351 C3                      	RETN
  9364                                  
  9365                                  ;Break	<NLS_GETEXT- get extended error for NLSFUNC>
  9366                                  ;----------------------------------------------------------------------------
  9367                                  ;   DOS 3.3   7/25/86
  9368                                  ;   NLS_GETEXT	-
  9369                                  ;
  9370                                  ;   Inputs:	none
  9371                                  ;   Outputs:	AX = extended error
  9372                                  ;
  9373                                  ;----------------------------------------------------------------------------
  9374                                  
  9375                                  NLS_GETEXT:
  9376                                  	; 16/05/2019 - Retro DOS v4.0
  9377 00001352 36A1[2403]              	MOV	AX,[SS:EXTERR]	 ; return extended error
  9378                                  	; 23/09/2023
  9379                                  MSG_RETRIEVAL:
  9380 00001356 C3                      	RETN
  9381                                  
  9382                                  ; 29/04/2019 - Retro DOS v4.0
  9383                                  
  9384                                  ;Break	<MSG_RETRIEVAL- get beginning addr of system and parser messages>
  9385                                  
  9386                                  ;----------------------------------------------------------------------------
  9387                                  ;   DOS 4.00
  9388                                  ;
  9389                                  ;   Inputs:	DL=0 get extended error message addr
  9390                                  ;		  =1 set extended error message addr
  9391                                  ;		  =2 get parser error message addr
  9392                                  ;		  =3 set parser error message addr
  9393                                  ;		  =4 get critical error message addr
  9394                                  ;		  =5 set critical error message addr
  9395                                  ;		  =6 get file system error message addr
  9396                                  ;		  =7 set file system error message addr
  9397                                  ;		  =8 get address for code reduction
  9398                                  ;		  =9 set address for code reduction
  9399                                  ;   Function:	get/set message address
  9400                                  ;   Outputs:	ES:DI points to addr when get
  9401                                  ;----------------------------------------------------------------------------
  9402                                  
  9403                                  ;Procedure MSG_RETRIEVAL,NEAR
  9404                                  ;	ASSUME	CS:DOSCODE,SS:NOTHING
  9405                                  
  9406                                  ; 23/09/2023
  9407                                  ;MSG_RETRIEVAL:
  9408                                  
  9409                                  ;;	NOTE:  This function lives in command.com resident code now.
  9410                                  ;;	If the int 2F ever gets this far, we'll return registers
  9411                                  ;;	unchanged, which produces the same result as before, if
  9412                                  ;;	command.com wasn't present (and therefore no messages available).
  9413                                  ;;
  9414                                  ;;	I didn't point the entry in the 2F table to No_Op because
  9415                                  ;;	No_Op zeroes AL.
  9416                                  ;;
  9417                                  ;;;hkn; set up ds to point to DOSDATA
  9418                                  ;;	push	ds
  9419                                  ;;	getdseg	<ds>			; ds -> dosdata
  9420                                  ;;
  9421                                  ;;	PUSH	AX		    ;AN000;;MS. save regs
  9422                                  ;;	PUSH	SI		    ;AN000;;MS. save regs
  9423                                  ;;	MOV	AX,DX		    ;AN000;;MS.
  9424                                  ;;	MOV	SI,OFFSET DOSDATA:MSG_EXTERROR ;AN000;;MS.
  9425                                  ;;	test	AL,1		    ;AN000;;MS. get ?
  9426                                  ;;	JZ	toget		    ;AN000;;MS. yes
  9427                                  ;;	DEC	AL		    ;AN000;;MS.
  9428                                  ;;toget:				    ;AN000;
  9429                                  ;;	SHL	AL,1		    ;AN000;;MS. times 2
  9430                                  ;;	XOR	AH,AH		    ;AN000;;MS.
  9431                                  ;;	ADD	SI,AX		    ;AN000;;MS. position to the entry
  9432                                  ;;	test	DL,1		    ;AN000;;MS. get ?
  9433                                  ;;	JZ	getget			     ;AN000;;MS. yes
  9434                                  ;;	MOV	WORD PTR DS:[SI],DI    ;AN000;;MS. set MSG
  9435                                  ;;	MOV	WORD PTR DS:[SI+2],ES  ;AN000;;MS. address to ES:DI
  9436                                  ;;	JMP	SHORT MSGret		     ;AN000;;MS. exit
  9437                                  ;;getget: 				     ;AN000;
  9438                                  ;;	LES	DI,DWORD PTR DS:[SI]	     ;AN000;;MS. get msg addr
  9439                                  ;;MSGret: 				     ;AN000;
  9440                                  ;;	POP	SI			     ;AN000;;MS.
  9441                                  ;;	POP	AX			     ;AN000;;MS.
  9442                                  ;;
  9443                                  ;;	pop	ds
  9444                                  
  9445                                  ;	return				     ;AN000;;MS. exit
  9446                                  
  9447                                  ; 23/09/2023
  9448                                  ;	retn	; 29/04/2019
  9449                                  
  9450                                  ;============================================================================
  9451                                  ; ECritDisk, LCritDisk, ECritDevice, LCritDevice
  9452                                  ; IBMDOS.COM (MSDOS 3.3), 1987 - Offset 1F36h
  9453                                  ;============================================================================
  9454                                  ; 20/07/2018 - Retro DOS v3.0
  9455                                  
  9456                                  ;	; MSDOS 3.3
  9457                                  ;	; 08/08/2018 - Retro DOS v3.0
  9458                                  ;ECritMEM:
  9459                                  ;ECritSFT:
  9460                                  ;	;
  9461                                  ;ECritDisk:
  9462                                  ;	retn
  9463                                  ;	;push	ax
  9464                                  ;	
  9465                                  ;	mov	ax,8001h
  9466                                  ;	int	2Ah	; Microsoft Networks - BEGIN DOS CRITICAL SECTION
  9467                                  ;			; AL = critical section number (00h-0Fh)
  9468                                  ;	pop	ax
  9469                                  ;	retn
  9470                                  ;
  9471                                  ;	; MSDOS 3.3
  9472                                  ;	; 08/08/2018 - Retro DOS v3.0
  9473                                  ;LCritMEM:
  9474                                  ;LCritSFT:
  9475                                  ;	;
  9476                                  ;LCritDisk:
  9477                                  ;	retn
  9478                                  ;	;push	ax
  9479                                  ;	
  9480                                  ;	mov	ax,8101h
  9481                                  ;	int	2Ah	; Microsoft Networks - END DOS CRITICAL SECTION
  9482                                  ;			; AL = critical section number (00h-0Fh)
  9483                                  ;	pop	ax
  9484                                  ;	retn
  9485                                  ;
  9486                                  ;ECritDevice:
  9487                                  ;	retn
  9488                                  ;	;push	ax
  9489                                  ;	
  9490                                  ;	mov	ax,8002h
  9491                                  ;	int	2Ah	; Microsoft Networks - BEGIN DOS CRITICAL SECTION
  9492                                  ;			; AL = critical section number (00h-0Fh)
  9493                                  ;	pop	ax
  9494                                  ;	retn
  9495                                  ;
  9496                                  ;LCritDevice:
  9497                                  ;	retn
  9498                                  ;	;push	ax
  9499                                  ;	
  9500                                  ;	mov	ax,8102h
  9501                                  ;	int	2Ah	; Microsoft Networks - END DOS CRITICAL SECTION
  9502                                  ;			; AL = critical section number (00h-0Fh)
  9503                                  ;	pop	ax
  9504                                  ;	retn
  9505                                  
  9506                                  ;============================================================================
  9507                                  ; CRIT.ASM, MSDOS 6.0, 1991
  9508                                  ;============================================================================
  9509                                  ; 12/05/2019 - Retro DOS v4.0
  9510                                  
  9511                                  ; Critical Section Routines
  9512                                  
  9513                                  ; MSDOS 6.21 - MSDOS.SYS - DOSCODE:513Ah
  9514                                  
  9515                                  ; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  9516                                  ; DOSCODE:5126h (MSDOS 5.0 MSDOS.SYS)
  9517                                  
  9518                                  ; ---------------------------------------------------------------------------
  9519                                  ; Each handler must leave everything untouched; including flags!
  9520                                  ;
  9521                                  ; Sleaze for time savings:  first instruction is a return. This is patched
  9522                                  ; by the sharer to be a PUSH AX to complete the correct routines.
  9523                                  ; ---------------------------------------------------------------------------
  9524                                  
  9525                                  ; (DOSMAC.INC, MSDOS 6.0, 1991)
  9526                                  ; ---------------------------------------------------------------------------
  9527                                  ; Some old versions of the 80286 have a bug in the chip. The popf instruction
  9528                                  ; will enable interrupts. Therefore in a section of code with interrupts
  9529                                  ; disabled and you need a popf instruction use the 'popff' macro instead.
  9530                                  ; ---------------------------------------------------------------------------
  9531                                  
  9532                                  ;%macro POPFF 0
  9533                                  ;	jmp	$+3
  9534                                  ;	iret
  9535                                  ;	push	cs
  9536                                  ;	call	$-2
  9537                                  ;%endmacro
  9538                                  
  9539                                  ; ---------------------------
  9540                                  
  9541                                  ;Procedure  ECritDisk,NEAR
  9542                                  	;public  ECritMEM
  9543                                  	;public  ECritSFT
  9544                                  ECritMEM:
  9545                                  ECritSFT:
  9546                                  ;
  9547                                  ECritDisk:
  9548                                  
  9549                                  ;SR; Check if critical section is to be entered
  9550                                  
  9551 00001357 9C                      	pushf
  9552 00001358 36803E[0C0D]00          	cmp	byte [ss:redir_patch],0
  9553 0000135E 740D                    	jz	short ECritDisk_2
  9554                                  
  9555                                  ; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  9556                                  ;	;popff  ; * (macro)
  9557                                  ;	jmp	short ECritDisk_1 ; *
  9558                                  ;
  9559                                  ;ECritDisk_iret: ; *
  9560                                  ;	iret ; *
  9561                                  
  9562                                  	; 16/12/2022
  9563                                  	; 13/11/2022
  9564                                  	;jmp	short ECritDisk_1
  9565                                  	; 06/11/2022
  9566                                  ;ECritDisk_iret:
  9567                                  ;	iret	
  9568                                  
  9569                                  	; 06/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  9570                                  ECritDisk_1:
  9571 00001360 0E                      	push	cs ; *
  9572 00001361 E80800                  	call	ECritDisk_iret ; *		
  9573                                  	
  9574                                  ECritDisk_0:
  9575 00001364 50                      	PUSH    AX
  9576                                  	;MOV	AX,8000h+critDisk
  9577                                  	;INT	int_IBM
  9578 00001365 B80180                  	mov	ax,8001h
  9579 00001368 CD2A                    	int	2Ah	; Microsoft Networks - BEGIN DOS CRITICAL SECTION
  9580                                  			; AL = critical section number (00h-0Fh)
  9581 0000136A 58                      	POP     AX
  9582 0000136B C3                      	retn
  9583                                  
  9584                                  	; 16/12/2022
  9585                                  	; 13/11/2022
  9586                                  ECritDisk_iret:  ; 12/05/2019 - Retro DOS v4.0
  9587                                  LCritDisk_iret: 
  9588 0000136C CF                      	iret
  9589                                  
  9590                                  ECritDisk_2:
  9591                                  	;;popff ; *
  9592                                  	;;retn
  9593                                  ;	jmp	short ECritDisk_3 ; *
  9594                                  ;ECritDisk_iret2: ; *
  9595                                  ;	iret
  9596                                  	
  9597                                  	; 16/12/2022
  9598                                  	; 13/11/2022
  9599                                  	;jmp	short ECritDisk_3
  9600                                  ;ECritDisk_iret2:
  9601                                  	;iret
  9602                                  
  9603                                  ECritDisk_3:
  9604 0000136D 0E                      	push    cs ; *
  9605                                  	; 13/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  9606                                  	;call	ECritDisk_iret2 ; *
  9607                                  	;retn
  9608                                  	; 16/12/2022
  9609 0000136E E8FBFF                  	call	ECritDisk_iret
  9610 00001371 C3                      	retn
  9611                                  
  9612                                  ;EndProc ECritDisk
  9613                                  
  9614                                  ; ---------------------------
  9615                                  
  9616                                  ;Procedure   LCritDisk,NEAR
  9617                                  	;public  LCritMEM
  9618                                  	;public  LCritSFT
  9619                                  LCritMEM:
  9620                                  LCritSFT:
  9621                                  ;
  9622                                  LCritDisk:
  9623                                  
  9624                                  ;SR; Check if critical section is to be entered
  9625                                  
  9626 00001372 9C                      	pushf
  9627 00001373 36803E[0C0D]00          	cmp	byte [ss:redir_patch],0
  9628 00001379 740C                    	jz	short LCritDisk_2
  9629                                  	;popff  ; * (macro)
  9630                                  ;	jmp	short LCritDisk_1 ; *
  9631                                  ;
  9632                                  ;LCritDisk_iret: ; *
  9633                                  ;	iret ; *
  9634                                  
  9635                                  	; 16/12/2022
  9636                                  	; 13/11/2022
  9637                                  	;jmp	short LCritDisk_1
  9638                                  ;LCritDisk_iret:
  9639                                  	;iret
  9640                                  
  9641                                  LCritDisk_1:
  9642 0000137B 0E                      	push	cs ; *
  9643 0000137C E8EDFF                  	call	LCritDisk_iret ; *		
  9644                                  	
  9645                                  LCritDisk_0:
  9646 0000137F 50                      	PUSH	AX
  9647                                  	;MOV	AX,8100h+critDisk
  9648                                  	;INT	int_IBM
  9649 00001380 B80181                  	mov	ax,8101h
  9650 00001383 CD2A                    	int	2Ah	; Microsoft Networks - END DOS CRITICAL SECTION
  9651                                  			; AL = critical section number (00h-0Fh)
  9652 00001385 58                      	POP	AX
  9653 00001386 C3                      	retn
  9654                                  
  9655                                  ;LCritDisk_iret:  ; 12/05/2019 - Retro DOS v4.0 
  9656                                  ;	iret
  9657                                  
  9658                                  LCritDisk_2:
  9659                                  	;;popff ; *
  9660                                  	;;retn
  9661                                  ;	jmp	short LCritDisk_3 ; *
  9662                                  ;LCritDisk_iret2: ; *
  9663                                  ;	iret
  9664                                  
  9665                                  	; 16/12/2022
  9666                                  	; 13/11/2022
  9667                                  	;jmp	short LCritDisk_3
  9668                                  ;LCritDisk_iret2:
  9669                                  	;iret
  9670                                  
  9671                                  LCritDisk_3:
  9672 00001387 0E                      	push    cs ; *
  9673                                  	; 13/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  9674                                  	;call	LCritDisk_iret2 ; *
  9675                                  	;retn
  9676                                  	; 16/12/2022
  9677 00001388 E8E1FF                  	call	LCritDisk_iret
  9678 0000138B C3                      	retn
  9679                                  
  9680                                  ;EndProc LCritDisk
  9681                                  
  9682                                  ; ---------------------------
  9683                                  
  9684                                  ;Procedure   ECritDevice,NEAR
  9685                                  
  9686                                  ECritDevice:
  9687                                  
  9688                                  ;SR; Check if critical section is to be entered
  9689                                  
  9690 0000138C 9C                      	pushf
  9691 0000138D 36803E[0C0D]00          	cmp	byte [ss:redir_patch],0
  9692 00001393 740D                    	jz	short ECritDevice_2
  9693                                  	;popff  ; * (macro)
  9694                                  ;	jmp	short ECritDevice_1 ; *
  9695                                  ;
  9696                                  ;ECritDevice_iret: ; *
  9697                                  ;	iret ; *
  9698                                  
  9699                                  	; 16/12/2022	
  9700                                  	; 13/11/2022
  9701                                  	;jmp	short ECritDevice_1
  9702                                  ;ECritDevice_iret:
  9703                                  	;iret
  9704                                  
  9705                                  ECritDevice_1:
  9706 00001395 0E                      	push	cs ; *
  9707 00001396 E80800                  	call	ECritDevice_iret ; *		
  9708                                  	
  9709                                  ECritDevice_0:
  9710 00001399 50                      	PUSH	AX
  9711                                  	;MOV	AX,8000h+critDevice
  9712                                  	;INT	int_IBM
  9713 0000139A B80280                  	mov	ax,8002h
  9714 0000139D CD2A                    	int	2Ah	; Microsoft Networks - BEGIN DOS CRITICAL SECTION
  9715                                  			; AL = critical section number (00h-0Fh)
  9716 0000139F 58                      	POP     AX
  9717 000013A0 C3                      	retn
  9718                                  
  9719                                  	; 16/12/2022
  9720                                  	; 06/12/2022
  9721                                  ECritDevice_iret:  ; 12/05/2019 - Retro DOS v4.0
  9722                                  LCritDevice_iret: 
  9723 000013A1 CF                      	iret
  9724                                  
  9725                                  ECritDevice_2:
  9726                                  	;;popff ; *
  9727                                  	;;retn
  9728                                  ;	jmp	short ECritDevice_3 ; *
  9729                                  ;ECritDevice_iret2: ; *
  9730                                  ;	iret
  9731                                  
  9732                                  	; 16/12/2022
  9733                                  	; 13/11/2022
  9734                                  	;jmp	short ECritDevice_3
  9735                                  ;ECritDevice_iret2:
  9736                                  	;iret
  9737                                  
  9738                                  ECritDevice_3:
  9739 000013A2 0E                      	push    cs ; *
  9740                                  	; 13/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  9741                                  	;call	ECritDevice_iret2 ; *
  9742                                  	;retn
  9743                                  	; 16/12/2022
  9744 000013A3 E8FBFF                  	call	ECritDevice_iret
  9745 000013A6 C3                      	retn
  9746                                  
  9747                                  ;EndProc ECritDevice
  9748                                  
  9749                                  ; ---------------------------
  9750                                  
  9751                                  ;Procedure   LCritDevice,NEAR
  9752                                  
  9753                                  LCritDevice:
  9754                                  
  9755                                  ;SR; Check if critical section is to be entered
  9756                                  
  9757 000013A7 9C                      	pushf
  9758 000013A8 36803E[0C0D]00          	cmp	byte [ss:redir_patch],0
  9759 000013AE 740C                    	jz	short LCritDevice_2
  9760                                  	;popff  ; * (macro)
  9761                                  ;	jmp	short LCritDevice_1 ; *
  9762                                  ;
  9763                                  ;LCritDevice_iret: ; *
  9764                                  ;	iret ; *
  9765                                  
  9766                                  	; 16/12/2022
  9767                                  	; 13/11/2022
  9768                                  	;jmp	short LCritDevice_1
  9769                                  ;LCritDevice_iret:
  9770                                  	;iret
  9771                                  
  9772                                  LCritDevice_1:
  9773 000013B0 0E                      	push	cs ; *
  9774 000013B1 E8EDFF                  	call	LCritDevice_iret ; *		
  9775                                  	
  9776                                  LCritDevice_0:
  9777 000013B4 50                      	PUSH	AX
  9778                                  	;MOV	AX,8100h+critDevice
  9779                                  	;INT	int_IBM
  9780 000013B5 B80281                  	mov	ax,8102h
  9781 000013B8 CD2A                    	int	2Ah	; Microsoft Networks - END DOS CRITICAL SECTION
  9782                                  			; AL = critical section number (00h-0Fh)
  9783 000013BA 58                      	POP     AX
  9784 000013BB C3                      	retn
  9785                                  
  9786                                  ;LCritDevice_iret:  ; 12/05/2019 - Retro DOS v4.0 
  9787                                  ;	iret
  9788                                  
  9789                                  LCritDevice_2:
  9790                                  	;;popff ; *
  9791                                  	;;retn
  9792                                  ;	jmp	short LCritDevice_3 ; *
  9793                                  ;LCritDevice_iret2: ; *
  9794                                  ;	iret
  9795                                  
  9796                                  	; 16/12/2022
  9797                                  	; 13/11/2022
  9798                                  	;jmp	short LCritDevice_3
  9799                                  ;LCritDevice_iret2:
  9800                                  	;iret
  9801                                  
  9802                                  LCritDevice_3:
  9803 000013BC 0E                      	push    cs ; *
  9804                                  	; 13/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
  9805                                  	;call	LCritDevice_iret2 ; *
  9806                                  	;retn
  9807                                  	; 16/12/2022
  9808 000013BD E8E1FF                  	call	LCritDevice_iret
  9809 000013C0 C3                      	retn
  9810                                  
  9811                                  ;EndProc LCritDevice
  9812                                  
  9813                                  ;============================================================================
  9814                                  ; CPMIO.ASM, MSDOS 6.0, 1991
  9815                                  ;============================================================================
  9816                                  ; 20/07/2018 - Retro DOS v3.0
  9817                                  
  9818                                  ;============================================================================
  9819                                  ; STDIO.ASM - (MSDOS 2.0)
  9820                                  ;============================================================================
  9821                                  
  9822                                  ;
  9823                                  ; Standard device IO for MSDOS (first 12 function calls)
  9824                                  ;
  9825                                  
  9826                                  ;.xlist
  9827                                  ;.xcref
  9828                                  ;INCLUDE STDSW.ASM
  9829                                  ;INCLUDE DOSSEG.ASM
  9830                                  ;.cref
  9831                                  ;.list
  9832                                  
  9833                                  ;TITLE   STDIO - device IO for MSDOS
  9834                                  ;NAME    STDIO
  9835                                  
  9836                                  ;INCLUDE IO.ASM
  9837                                  
  9838                                  ; ---------------------------------------------------------------------------
  9839                                  ;
  9840                                  ; NOTE for Retro DOS v2.0 :  (ERDOGAN TAN - 13/03/2018)
  9841                                  ;	  I0.ASM is missing in MSDOS 2.0 kernel source code files !!!
  9842                                  ;	  INSTEAD of IO.ASM, I have disassembled IBMDOS.COM (MSDOS 2.0)
  9843                                  ;			    and I have used CPMIO.ASM (MSDOS 6.0 source code)
  9844                                  ;			    to restore MSDOS 2.0 device IO source code 
  9845                                  ;
  9846                                  ;		(STRIN.ASM has '$STD_CON_STRING_INPUT' code.)	
  9847                                  	
  9848                                  ;============================================================================
  9849                                  ; STDIO.ASM - (MSDOS 2.0)
  9850                                  ;============================================================================
  9851                                  
  9852                                  ;
  9853                                  ; Standard device IO for MSDOS (first 12 function calls)
  9854                                  ;
  9855                                  
  9856                                  ;.xlist
  9857                                  ;.xcref
  9858                                  ;INCLUDE STDSW.ASM
  9859                                  ;INCLUDE DOSSEG.ASM
  9860                                  ;.cref
  9861                                  ;.list
  9862                                  
  9863                                  ;TITLE   STDIO - device IO for MSDOS
  9864                                  ;NAME    STDIO
  9865                                  
  9866                                  ;INCLUDE IO.ASM
  9867                                  
  9868                                  ; ---------------------------------------------------------------------------
  9869                                  ;
  9870                                  ; NOTE for Retro DOS v2.0 :  (ERDOGAN TAN - 13/03/2018)
  9871                                  ;	  I0.ASM is missing in MSDOS 2.0 kernel source code files !!!
  9872                                  ;	  INSTEAD of IO.ASM, I have disassembled IBMDOS.COM (MSDOS 2.0)
  9873                                  ;			    and I have used CPMIO.ASM (MSDOS 6.0 source code)
  9874                                  ;			    to restore MSDOS 2.0 device IO source code 
  9875                                  ;
  9876                                  ;		(STRIN.ASM has '$STD_CON_STRING_INPUT' code.)		
  9877                                  ;
  9878                                  ;============================================================================
  9879                                  ; IO.ASM (MSDOS 2.0) (IBMDOS.COM 2.0) - STRIN.ASM (MSDOS 2.0, 19/08/1983)
  9880                                  ;============================================================================
  9881                                  ; Retro DOS v2.0 by Erdogan Tan, 13/03/2018 - 14/03/2018
  9882                                  
  9883                                  ; (Disassembled code of IBMDOS.COM, 08/03/1983) - Dissassembler: IDA Pro Free
  9884                                  ; (Comments are from CPMIO.ASM - 1991, MSDOS 6.0) 
  9885                                  
  9886                                  ;============================================================================
  9887                                  ; CPMIO.ASM (MSDOS 6.0, 1991)
  9888                                  ;============================================================================
  9889                                  ; Retro DOS v4.0 by Erdogan Tan, 04/05/2019
  9890                                  
  9891                                  	; 08/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
  9892                                  
  9893                                  ;**	Standard device IO for MSDOS (first 12 function calls)
  9894                                  ;
  9895                                  ;	TITLE	IBMCPMIO - device IO for MSDOS
  9896                                  ;	NAME	IBMCPMIO
  9897                                  
  9898                                  ;	Old style CP/M 1-12 system calls to talk to reserved devices
  9899                                  ;
  9900                                  ;	$Std_Con_Input_No_Echo
  9901                                  ;	$Std_Con_String_Output
  9902                                  ;	$Std_Con_String_Input
  9903                                  ;	$RawConIO
  9904                                  ;	$RawConInput
  9905                                  ;	RAWOUT
  9906                                  ;	RAWOUT2
  9907                                  ;
  9908                                  
  9909                                  ; The following routines form the console I/O group (funcs 1,2,6,7,8,9,10,11).
  9910                                  ; They assume ES and DS NOTHING, while not strictly correct, this forces data
  9911                                  ; references to be SS or CS relative which is desired.
  9912                                  
  9913                                  ; ---------------------------------------------------------------------------
  9914                                  
  9915                                  ;	TITLE	CPMIO2 - device IO for MSDOS
  9916                                  ;	NAME	CPMIO2
  9917                                  
  9918                                  ;
  9919                                  ;	Microsoft Confidential
  9920                                  ;	Copyright (C) Microsoft Corporation 1991
  9921                                  ;	All Rights Reserved.
  9922                                  ;
  9923                                  
  9924                                  ;**	Old style CP/M 1-12 system calls to talk to reserved devices
  9925                                  ;
  9926                                  ;	$Std_Con_Input
  9927                                  ;	$Std_Con_Output
  9928                                  ;	OUTT
  9929                                  ;	TAB
  9930                                  ;	BUFOUT
  9931                                  ;	$Std_Aux_Input
  9932                                  ;	$Std_Aux_Output
  9933                                  ;	$Std_Printer_Output
  9934                                  ;	$Std_Con_Input_Status
  9935                                  ;	$Std_Con_Input_Flush
  9936                                  ;
  9937                                  ;	Revision History:
  9938                                  ;
  9939                                  ;	  AN000	 version 4.00 - Jan. 1988
  9940                                  
  9941                                  ; The following routines form the console I/O group (funcs 1,2,6,7,8,9,10,11).
  9942                                  ; They assume ES and DS NOTHING, while not strictly correct, this forces data
  9943                                  ; references to be SS or CS relative which is desired.
  9944                                  
  9945                                  ;DOSCODE SEGMENT
  9946                                  ;	ASSUME	SS:DOSDATA,CS:DOSCODE
  9947                                  
  9948                                  
  9949                                  ;hkn; 	All the variables use SS override or DS. Therefore there is
  9950                                  ;hkn;	no need to specifically set up any seg regs unless SS assumption is
  9951                                  ;hkn;	not valid. 
  9952                                  
  9953                                  ; DOSCODE:51BAh (MSDOS 6.21, MSDOS.SYS)
  9954                                  ; 08/11/2022
  9955                                  ; DOSCODE:51A6h (MSDOS 5.0, MSDOS.SYS)
  9956                                  
  9957                                  ;
  9958                                  ;----------------------------------------------------------------------------
  9959                                  ;
  9960                                  ; Procedure : $Std_Con_Input_No_Echo
  9961                                  ;
  9962                                  ;----------------------------------------------------------------------------
  9963                                  ;
  9964                                  
  9965                                  _$STD_CON_INPUT_NO_ECHO:   ;System call 8
  9966                                  
  9967                                  ; Inputs:
  9968                                  ;	None
  9969                                  ; Function:
  9970                                  ;	Input character from console, no echo
  9971                                  ; Returns:
  9972                                  ;	AL = character
  9973                                  
  9974 000013C1 1E                      	push	ds
  9975 000013C2 56                      	push	si
  9976                                  INTEST:
  9977 000013C3 E8053E                  	call	STATCHK
  9978 000013C6 753B                    	jnz	short GET ; 08/09/2018
  9979                                  ;*************************************************************************
  9980                                  ;hkn; SS override
  9981 000013C8 36803E[A00A]00          	cmp	byte [SS:PRINTER_FLAG],0  ; is printer idle?
  9982 000013CE 7505                    	jnz	short no_sys_wait
  9983 000013D0 B405                    	mov	ah,5			; get input status with system wait
  9984 000013D2 E82D31                  	call	IOFUNC
  9985                                  no_sys_wait:
  9986                                  ;**************************************************************************
  9987 000013D5 B484                    	MOV	AH,84h
  9988 000013D7 CD2A                    	INT	int_IBM	 ; int 2Ah
  9989                                  
  9990                                  ;;; 7/15/86  update the date in the idle loop
  9991                                  ;;; Dec 19, 1986 D.C.L. changed following CMP to Byte Ptr from Word Ptr
  9992                                  ;;;;		 to shorten loop in consideration of the PC Convertible
  9993                                  
  9994                                  ;hkn; SS override
  9995 000013D9 36803E[910D]FF          	CMP	byte [SS:DATE_FLAG],-1	; date is updated may be every
  9996 000013DF 751B                    	JNZ	short NoUpdate		; 65535 x ? ms if no one calls
  9997                                  
  9998 000013E1 50                      	PUSH	AX
  9999 000013E2 53                      	PUSH	BX			; following is tricky,
 10000 000013E3 51                      	PUSH	CX			; it may be called by critical handler
 10001 000013E4 52                      	PUSH	DX			; at that time, DEVCALL is used by
 10002                                  					; other's READ or WRITE
 10003 000013E5 1E                      	PUSH	DS			; save DS = SFT's segment
 10004                                  
 10005                                  ;hkn; READTIME must use ds = DOSDATA
 10006                                  ;hkn;	PUSH	CS			; READTIME must use DS=CS
 10007                                  
 10008 000013E6 16                      	PUSH	SS ; 04/05/2019
 10009 000013E7 1F                      	POP	DS
 10010                                  
 10011 000013E8 B80000                  	MOV	AX,0			; therefore, we save DEVCALL
 10012 000013EB E89A02                  	CALL	Save_Restore_Packet	; save DEVCALL packet
 10013                                  	;invoke	READTIME		; readtime
 10014 000013EE E849F7                  	call	READTIME
 10015 000013F1 B80100                  	MOV	AX,1
 10016 000013F4 E89102                  	CALL	Save_Restore_Packet	; restore DEVCALL packet
 10017                                  
 10018                                  ;	; MSDOS 3.3 (IBMDOS.COM, Offset 1F8Ch)
 10019                                  ;	; (MSDOS 6.0 code does not contain IBM DOS FETCHI_TAG check)
 10020                                  ;	push	bx
 10021                                  ;	mov	bx,DATE_FLAG
 10022                                  ;	add	bx,2  ; mov bx,FETCHI_FLAG
 10023                                  ;	cmp	word [cs:bx],5872h
 10024                                  ;	jz	short FETCHI_TAG_chk_ok
 10025                                  ;	call	DOSINIT
 10026                                  ;FETCHI_TAG_chk_ok:
 10027                                  ;	pop	bx
 10028                                  
 10029 000013F7 1F                      	POP	DS			; restore DS
 10030 000013F8 5A                      	POP	DX
 10031 000013F9 59                      	POP	CX
 10032 000013FA 5B                      	POP	BX
 10033 000013FB 58                      	POP	AX
 10034                                  NoUpdate:
 10035                                  
 10036                                  ;hkn; SS override
 10037 000013FC 36FF06[910D]            	INC	word [SS:DATE_FLAG]
 10038                                  
 10039                                  ;;; 7/15/86 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 10040 00001401 EBC0                    	JMP	short INTEST
 10041                                  GET:
 10042 00001403 30E4                    	XOR	AH,AH
 10043 00001405 E8FA30                  	call	IOFUNC
 10044 00001408 5E                      	POP	SI
 10045 00001409 1F                      	POP	DS
 10046                                  ;;; 7/15/86
 10047                                  
 10048                                  ;hkn; SS override
 10049                                  	; MSDOS 6.0
 10050 0000140A 36C606[900D]00          	MOV	BYTE [SS:SCAN_FLAG],0
 10051                                  	;
 10052 00001410 3C00                    	CMP	AL,0	    ; extended code ( AL )
 10053 00001412 7505                    	JNZ	short noscan
 10054                                  
 10055                                  ;hkn; SS override
 10056                                  	;MOV	BYTE [SS:SCAN_FLAG],1 ; set this flag for ALT_Q key
 10057                                  	; 20/06/2023
 10058 00001414 36FE06[900D]            	inc	byte [SS:SCAN_FLAG]
 10059                                  noscan:
 10060 00001419 C3                      	retn
 10061                                  ;
 10062                                  ;----------------------------------------------------------------------------
 10063                                  ;
 10064                                  ;**	$STD_CON_STRING_OUTPUT - Console String Output
 10065                                  ;
 10066                                  ;
 10067                                  ;	ENTRY	(DS:DX) Point to output string '$' terminated
 10068                                  ;	EXIT	none
 10069                                  ;	USES	ALL
 10070                                  ;
 10071                                  ;----------------------------------------------------------------------------
 10072                                  ;
 10073                                  
 10074                                  _$STD_CON_STRING_OUTPUT:	;System call 9
 10075                                  
 10076 0000141A 89D6                    	mov	si,dx
 10077                                  STRING_OUT1:	
 10078 0000141C AC                      	lodsb
 10079 0000141D 3C24                    	cmp	al,'$'
 10080 0000141F 74F8                    	je	short noscan
 10081                                  NEXT_STR1:
 10082 00001421 E88F02                  	call	OUTT
 10083 00001424 EBF6                    	jmp	short STRING_OUT1
 10084                                  
 10085                                  ;----------------------------------------------------------------------------
 10086                                  ;
 10087                                  ;**	$STD_CON_STRING_INPUT - Input Line from Console
 10088                                  ;
 10089                                  ;	$STD_CON_STRING_INPUT Fills a buffer from console input until CR
 10090                                  ;
 10091                                  ;	ENTRY	(ds:dx) = input buffer
 10092                                  ;	EXIT	none
 10093                                  ;	USES	ALL
 10094                                  ;
 10095                                  ;----------------------------------------------------------------------------
 10096                                  
 10097                                  _$STD_CON_STRING_INPUT:		;System call 10
 10098                                  
 10099 00001426 8CD0                    	mov	ax,ss
 10100 00001428 8EC0                    	mov	es,ax
 10101 0000142A 89D6                    	mov	si,dx
 10102 0000142C 30ED                    	xor	ch,ch
 10103 0000142E AD                      	lodsw
 10104                                  
 10105                                  ;	(AL) = the buffer length
 10106                                  ;	(AH) = the template length
 10107                                  
 10108 0000142F 08C0                            or	al,al
 10109 00001431 74E6                            jz	short noscan	;Buffer is 0 length!!?
 10110 00001433 88E3                    	mov	bl,ah		;Init template counter
 10111 00001435 88EF                            mov	bh,ch		;Init template counter
 10112                                  
 10113                                  ;	(BL) = the number of bytes in the template
 10114                                  
 10115 00001437 38D8                            cmp	al,bl
 10116 00001439 7605                            jbe	short NOEDIT	;If length of buffer inconsistent with contents
 10117 0000143B 80380D                          cmp	byte [bx+si],c_CR ; 0Dh
 10118 0000143E 7402                            jz	short EDITON	;If CR correctly placed EDIT is OK
 10119                                  
 10120                                  ; The number of chars in the template is >= the number of chars in buffer or
 10121                                  ; there is no CR at the end of the template.  This is an inconsistant state
 10122                                  ; of affairs.  Pretend that the template was empty:
 10123                                  ;
 10124                                  
 10125                                  NOEDIT:	
 10126 00001440 88EB                    	mov	bl,ch		;Reset buffer
 10127                                  EDITON: 
 10128 00001442 88C2                    	mov	dl,al
 10129 00001444 4A                      	dec	dx		;DL is # of bytes we can put in the buffer
 10130                                  
 10131                                  ;	Top level. We begin to read a line in.
 10132                                  
 10133                                  NEWLIN: 
 10134 00001445 36A0[F901]              	mov	al,[SS:CARPOS]
 10135 00001449 36A2[FA01]              	mov	[SS:STARTPOS],al ;Remember position in raw buffer
 10136                                  
 10137 0000144D 56                      	push	si
 10138 0000144E BF[FB01]                	mov	di,INBUF ;Build the new line here
 10139 00001451 36882E[7905]            	mov	byte [SS:INSMODE],ch ;Insert mode off
 10140 00001456 88EF                    	mov	bh,ch		;No chars from template yet
 10141 00001458 88EE                    	mov	dh,ch		;No chars to new line yet
 10142 0000145A E864FF                  	call	_$STD_CON_INPUT_NO_ECHO ;Get first char
 10143 0000145D 3C0A                    	cmp	al,c_LF		; 0Ah	;Linefeed 
 10144 0000145F 7503                    	jnz	short GOTCH
 10145                                  
 10146                                  ;	This is the main loop of reading in a character and processing it.
 10147                                  ;
 10148                                  ;	(BH) = the index of the next byte in the template
 10149                                  ;	(BL) = the length of the template
 10150                                  ;	(DH) = the number of bytes in the buffer
 10151                                  ;	(DL) = the length of the buffer
 10152                                  
 10153                                  GETCH:
 10154 00001461 E85DFF                  	call	_$STD_CON_INPUT_NO_ECHO
 10155                                  GOTCH:
 10156                                  ;
 10157                                  ; Brain-damaged Tim Patterson ignored ^F in case his BIOS did not flush the
 10158                                  ; input queue.
 10159                                  ;
 10160 00001464 3C06                            cmp	al,"F"-"@"  ; CMP AL, 6  ; Ignore ^F
 10161 00001466 74F9                    	jz	short GETCH
 10162                                  
 10163                                  ;	If the leading char is the function-key lead byte
 10164                                  
 10165                                  	;cmp	al,[SS:ESCCHAR]
 10166                                  
 10167                                  	; 04/05/2019 - Retro DOS v4.0
 10168                                  
 10169                                  ;hkn; 	ESCCHAR is in TABLE seg (DOSCODE)
 10170                                  
 10171 00001468 2E3A06[380A]            	CMP	AL,[cs:ESCCHAR]
 10172 0000146D 743B                            jz	short ESCAPE	;change reserved keyword DBM 5-7-87
 10173                                  
 10174                                  ;	Rubout and ^H are both destructive backspaces.
 10175                                  
 10176 0000146F 3C7F                            cmp	al,c_DEL ; 7FH
 10177 00001471 742E                            jz	short BACKSPJ
 10178 00001473 3C08                            cmp	al,c_BS  ; 8
 10179 00001475 742A                            jz	short BACKSPJ
 10180                                  
 10181                                  	; 04/05/2019 -	MSDOS 6.0, also MSDOS 6.21 has bug (bullshit) here. 
 10182                                  	;		Two NOPs -instead of a JMP short, as two bytes-
 10183                                  	;	   	after CMP and a CMP again!
 10184                                  	;		
 10185                                  	;		-It would be better if they use a 'JMP short' to 
 10186                                  	;	      	DOSCODE:5279h from DOSCODE:5271h and leave NOPs
 10187                                  	;		between them. Then, they would be able use a patch
 10188                                  	;		between 5271h and 5279h when if it will be required.
 10189                                  	;		I think Tim Patterson would not do this CMP mistake!-
 10190                                  	;	
 10191                                  	; (MSDOS.SYS, from DOSCODE:5271h to DOSCODE:5279h)
 10192                                  
 10193                                  	; 08/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 10194                                  	;
 10195                                  	; (Note: nops below might be used for patching code for Windows 3.1)
 10196                                  
 10197                                  ;DOSCODE:526D	cmp     al, 8
 10198                                  ;DOSCODE:526F	jz      short BACKSPJ
 10199                                  ;DOSCODE:5271	cmp     al, 17h
 10200                                  ;DOSCODE:5273	nop
 10201                                  ;DOSCODE:5274	nop
 10202                                  ;DOSCODE:5275	cmp     al, 15h
 10203                                  ;DOSCODE:5277	nop
 10204                                  ;DOSCODE:5278	nop
 10205                                  ;DOSCODE:5279	cmp     al, 0Dh
 10206                                  ;DOSCODE:527B	jz      short ENDLIN
 10207                                  ;DOSCODE:527D	cmp     al, 0Ah
 10208                                  ;DOSCODE:527F	jz      short PHYCRLF
 10209                                  	
 10210                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 10211                                  	; DOSCODE:525Dh
 10212                                  
 10213                                  ; 16/12/2022
 10214                                  %if 0
 10215                                  	; MSDOS 6.0
 10216                                  ;	^W deletes backward once and then backs up until a letter is before the
 10217                                  ;	cursor
 10218                                  
 10219                                  	CMP     AL,"W"-"@" ; 17h
 10220                                  
 10221                                  ;	The removal of the comment characters before the jump statement will
 10222                                  ;	cause ^W to backup a word.
 10223                                  
 10224                                  ;***	JZ	short WordDel
 10225                                  	NOP
 10226                                  	NOP
 10227                                  
 10228                                  	CMP     AL,"U"-"@" ; 15h
 10229                                  
 10230                                  ;	The removal of the comment characters before the jump statement will
 10231                                  ;	cause ^U to clear a line.
 10232                                  
 10233                                  ;***	JZ	short LineDel
 10234                                  	NOP
 10235                                  	NOP
 10236                                  
 10237                                  %endif
 10238                                  
 10239                                  ;	CR terminates the line.
 10240                                  
 10241 00001477 3C0D                            cmp	al,c_CR ; 0Dh
 10242 00001479 7432                            jz	short ENDLIN
 10243                                  
 10244                                  ;	LF goes to a new line and keeps on reading.
 10245                                  
 10246 0000147B 3C0A                            cmp	al,c_LF ; 0Ah
 10247 0000147D 7444                    	jz	short PHYCRLF
 10248                                  
 10249                                  ;	^X (or ESC) deletes the line and starts over
 10250                                  
 10251                                  	; MSDOS 3.3
 10252                                  	;cmp	al,[ss:CANCHAR] ; 1Bh
 10253                                  	;jz	short KILNEW
 10254                                  
 10255                                  	; MSDOS 6.0 (& MSDOS 6.21)
 10256                                  
 10257                                  ;hkn; 	CANCHAR is in TABLE seg (DOSCODE), so CS override
 10258                                  
 10259 0000147F 2E3A06[370A]            	cmp	al,[cs:CANCHAR] ; 1Bh
 10260 00001484 7442                    	jz	short KILNEW
 10261                                  	
 10262                                  	;cmp	al,CANCEL ; 1Bh	; Retro DOS v3.0
 10263                                  	;jz	short KILNEW
 10264                                  
 10265                                  ; Otherwise, we save the input character.
 10266                                  
 10267                                  SAVCH:	
 10268 00001486 38D6                    	cmp	dh,dl
 10269 00001488 7319                    	jnb	short BUFFUL		; buffer is full.
 10270 0000148A AA                              stosb
 10271 0000148B FEC6                    	inc	dh                      ; increment count in buffer.
 10272 0000148D E8B702                  	call	BUFOUT			; Print control chars nicely
 10273                                  
 10274 00001490 36803E[7905]00                  cmp	byte [SS:INSMODE], 0
 10275 00001496 75C9                    	jnz	short GETCH		; insertmode => don't advance template
 10276 00001498 38DF                            cmp	bh,bl
 10277 0000149A 73C5                            jnb	short GETCH		; no more characters in template
 10278 0000149C 46                              inc	si                      ; Skip to next char in template
 10279 0000149D FEC7                            inc	bh                      ; remember position in template
 10280 0000149F EBC0                            jmp	short GETCH
 10281                                  
 10282                                  BACKSPJ: 
 10283 000014A1 EB38                    	jmp	short BACKSP
 10284                                  
 10285                                  BUFFUL: 
 10286 000014A3 B007                    	mov	al, 7			; Bell to signal full buffer
 10287 000014A5 E80B02                  	call	OUTT
 10288 000014A8 EBB7                    	jmp	short GETCH
 10289                                  
 10290                                  ESCAPE: 
 10291                                  	;transfer OEMFunctionKey
 10292 000014AA E9B6F5                  	JMP	OEMFunctionKey		; let the OEM's handle the key dispatch
 10293                                  
 10294                                  ENDLIN:
 10295 000014AD AA                              stosb				; Put the CR in the buffer
 10296 000014AE E80202                  	call	OUTT                    ; Echo it
 10297 000014B1 5F                              pop	di                      ; Get start of user buffer
 10298 000014B2 8875FF                          mov	[di-1], dh		; Tell user how many bytes
 10299 000014B5 FEC6                            inc	dh			; DH is length including CR
 10300                                  
 10301                                  COPYNEW:
 10302                                  	; (IBMDOS.COM, MSDOS 2.0, STRIN.ASM)
 10303                                  	;mov	bp, es
 10304                                  	;mov	bx, ds
 10305                                  	;mov	es, bx
 10306                                  	;mov	ds, bp
 10307                                  	;mov	si, INBUF
 10308                                  	;mov	cl, dh
 10309                                  	;rep	movsb
 10310                                  	;retn
 10311                                  
 10312                                  	; CPMIO.ASM (MSDOS 6.0)
 10313                                  	; (IBMDOS.COM, MSDOS 3.3, Offset 2061h) 
 10314                                  	;SAVE	<DS,ES>
 10315 000014B7 1E                      	PUSH	DS
 10316 000014B8 06                      	PUSH	ES
 10317                                  	;RESTORE <DS,ES>		; XCHG ES,DS
 10318 000014B9 1F                      	POP	DS
 10319 000014BA 07                      	POP	ES
 10320                                  
 10321                                  ;;hkn; INBUF is in DOSDATA
 10322 000014BB BE[FB01]                        MOV     SI,INBUF
 10323 000014BE 88F1                            MOV     CL,DH                   ; set up count
 10324 000014C0 F3A4                            REP     MOVSB                   ; Copy final line to user buffer
 10325                                  OLDBAK_RETN:
 10326 000014C2 C3                              RETN
 10327                                  
 10328                                  ;	Output a CRLF to the user screen and do NOT store it into the buffer
 10329                                  
 10330                                  PHYCRLF:
 10331 000014C3 E82001                  	CALL	CRLF
 10332 000014C6 EB99                            JMP	short GETCH
 10333                                  
 10334                                  	; MSDOS 6.0 (& MSDOS 3.3, IBMDOS.COM, 1987)
 10335                                  
 10336                                  ; DOSCODE:52CAh (MSDOS 621, MSDOS.SYS)
 10337                                  
 10338                                  	; Note: Following routines were not used in IBMDOS.COM
 10339                                  	;	-CRTL+W, CRTL+U is not activated-
 10340                                  	;	but they were in the kernel code!?)
 10341                                  
 10342                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 10343                                  	; DOSCODE:52B6h
 10344                                  
 10345                                  ;;;;;;;;
 10346                                  
 10347                                  ; 16/12/2022
 10348                                  %if 0
 10349                                  ;
 10350                                  ; Delete the previous line
 10351                                  ;
 10352                                  LineDel:
 10353                                  	OR      DH,DH
 10354                                  	JZ	short GETCH	 ; 06/12/2022
 10355                                  	Call    BackSpace
 10356                                  	JMP	short LineDel
 10357                                  
 10358                                  %endif
 10359                                  
 10360                                  ;
 10361                                  ; delete the previous word.
 10362                                  ;
 10363                                  WordDel:
 10364                                  WordLoop:
 10365                                  ;	Call    BackSpace               ; backspace the one spot
 10366                                  ;	OR      DH,DH
 10367                                  ;	JZ	short GetChj
 10368                                  ;	MOV     AL,[ES:DI-1]
 10369                                  ;	cmp     al,'0'
 10370                                  ;	jb	short GetChj
 10371                                  ;	cmp     al,'9'
 10372                                  ;	jbe	short WordLoop
 10373                                  ;	OR      AL,20h
 10374                                  ;	CMP     AL,'a'
 10375                                  ;	JB	short GetChj
 10376                                  ;	CMP     AL,'z'
 10377                                  ;	JBE	short WordLoop
 10378                                  ;GetChj: 
 10379                                  ;	JMP	GETCH
 10380                                  
 10381                                  ; 16/12/2022
 10382                                  %if 0
 10383                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 10384                                  	; (Worddel is not called or jumped from anywhere!)
 10385                                  WordDel:
 10386                                  WordLoop:
 10387                                  	Call    BackSpace               ; backspace the one spot
 10388                                  	OR      DH,DH
 10389                                  	JZ	short GetChj
 10390                                  	MOV     AL,[ES:DI-1]
 10391                                  	cmp     al,'0'
 10392                                  	jb	short GetChj
 10393                                  	cmp     al,'9'
 10394                                  	jbe	short WordLoop
 10395                                  	OR      AL,20h
 10396                                  	CMP     AL,'a'
 10397                                  	JB	short GetChj
 10398                                  	CMP     AL,'z'
 10399                                  	JBE	short WordLoop
 10400                                  GetChj: 
 10401                                  	JMP	GETCH
 10402                                  
 10403                                  %endif
 10404                                  
 10405                                  ;;;;;;;;
 10406                                  
 10407                                  ; DOSCODE:52F3h (MSDOS 621, MSDOS.SYS)
 10408                                  
 10409                                  ; The user wants to throw away what he's typed in and wants to start over.
 10410                                  ; We print the backslash and then go to the next line and tab to the correct
 10411                                  ; spot to begin the buffered input.
 10412                                  
 10413                                  KILNEW:
 10414 000014C8 B05C                            mov	al,'\'
 10415 000014CA E8E601                          call	OUTT            ;Print the CANCEL indicator
 10416 000014CD 5E                              pop	si		;Remember start of edit buffer
 10417                                  PUTNEW:
 10418 000014CE E81501                  	call	CRLF            ;Go to next line on screen
 10419 000014D1 36A0[FA01]              	mov	al,[SS:STARTPOS]
 10420 000014D5 E84F02                  	call	TAB             ;Tab over
 10421 000014D8 E96AFF                          JMP     NEWLIN		;Start over again
 10422                                  
 10423                                  ;	Destructively back up one character position
 10424                                  
 10425                                  BACKSP:
 10426                                  	; 09/09/2018
 10427 000014DB E80200                  	Call    BackSpace
 10428 000014DE EB81                    	JMP     GETCH
 10429                                  
 10430                                  BackSpace:
 10431 000014E0 08F6                    	or	dh,dh
 10432 000014E2 7419                    	jz	short OLDBAK	;No chars in line, do nothing to line
 10433 000014E4 E85800                  	call	BACKUP          ;Do the backup
 10434 000014E7 268A05                  	mov	al,[es:di]	;Get the deleted char
 10435 000014EA 3C20                            cmp	al,20h	; ' '
 10436 000014EC 730F                    	jnb	short OLDBAK	;Was a normal char
 10437 000014EE 3C09                            cmp	al,c_HT ; 9
 10438 000014F0 741B                    	jz	short BAKTAB	;Was a tab, fix up users display
 10439                                  ;; 9/27/86 fix for ctrl-U backspace
 10440 000014F2 3C15                    	CMP     AL,"U"-"@" ; 15h ; ctrl-U is a section symbol not ^U
 10441 000014F4 7407                    	JZ	short OLDBAK
 10442 000014F6 3C14                           	CMP     AL,"T"-"@" ; 14h ; ctrl-T is a paragraphs symbol not ^T
 10443 000014F8 7403                    	JZ	short OLDBAK
 10444                                  ;; 9/27/86 fix for ctrl-U backspace
 10445 000014FA E84500                          call	BACKMES         ;Was a control char, zap the '^'
 10446                                  OLDBAK:
 10447 000014FD 36803E[7905]00                  cmp	byte [SS:INSMODE], 0
 10448 00001503 75BD                    	jnz	short OLDBAK_RETN ;In insert mode, done
 10449 00001505 08FF                    	or	bh,bh
 10450 00001507 74B9                            jz	short OLDBAK_RETN 
 10451                                  				;Not advanced in template, stay where we are
 10452 00001509 FECF                    	dec	bh		;Go back in template
 10453 0000150B 4E                              dec	si
 10454 0000150C C3                      	retn
 10455                                  BAKTAB:
 10456 0000150D 57                              push	di
 10457 0000150E 4F                              dec	di		;Back up one char
 10458 0000150F FD                              std			;Go backward
 10459 00001510 88F1                            mov	cl,dh		;Number of chars currently in line
 10460 00001512 B020                            mov	al,20h	; ' '
 10461 00001514 53                              push	bx
 10462 00001515 B307                            mov	bl,7		;Max
 10463 00001517 E30E                            jcxz	FIGTAB		;At start, do nothing
 10464                                  FNDPOS:
 10465 00001519 AE                              scasb			;Look back
 10466 0000151A 7609                    	jbe	short CHKCNT
 10467 0000151C 26807D0109              	cmp	byte [es:di+1],9
 10468 00001521 7409                    	jz	short HAVTAB	;Found a tab
 10469 00001523 FECB                    	dec	bl		;Back one char if non tab control char
 10470                                  CHKCNT:
 10471 00001525 E2F2                            loop	FNDPOS
 10472                                  FIGTAB:		
 10473 00001527 362A1E[FA01]            	sub	bl,[SS:STARTPOS]
 10474                                  HAVTAB:
 10475 0000152C 28F3                    	sub	bl,dh
 10476 0000152E 00D9                    	add	cl,bl
 10477 00001530 80E107                  	and	cl,7		;CX has correct number to erase
 10478 00001533 FC                      	cld			;Back to normal
 10479 00001534 5B                      	pop	bx
 10480 00001535 5F                      	pop	di
 10481 00001536 74C5                    	jz	short OLDBAK	;Nothing to erase
 10482                                  TABBAK:
 10483 00001538 E80700                  	call	BACKMES
 10484 0000153B E2FB                    	loop	TABBAK		;Erase correct number of chars
 10485 0000153D EBBE                    	jmp	short OLDBAK
 10486                                  
 10487                                  BACKUP:
 10488 0000153F FECE                            dec	dh		;Back up in line
 10489 00001541 4F                              dec	di
 10490                                  BACKMES:
 10491 00001542 B008                            mov	al,c_BS ; 8	;Backspace
 10492 00001544 E86C01                          call	OUTT
 10493 00001547 B020                            mov	al,20h ; ' '	;Erase
 10494 00001549 E86701                          call	OUTT
 10495 0000154C B008                            mov	al,c_BS ; 8	;Backspace
 10496 0000154E E96201                  	jmp	OUTT		;Done
 10497                                  
 10498                                  ;User really wants an ESC character in his line
 10499                                  TWOESC:	
 10500 00001551 2EA0[380A]              	mov	al,[cs:ESCCHAR] ; 10/06/2019
 10501 00001555 E92EFF                  	jmp	SAVCH
 10502                                  
 10503                                  ;Copy the rest of the template
 10504                                  COPYLIN:
 10505 00001558 88D9                            mov	cl,bl		;Total size of template
 10506 0000155A 28F9                    	sub	cl,bh		;Minus position in template, is number to move
 10507 0000155C EB07                            jmp	short COPYEACH
 10508                                  
 10509                                  COPYSTR:
 10510 0000155E E83400                  	call	FINDOLD         ;Find the char
 10511 00001561 EB02                    	jmp	short COPYEACH  ;Copy up to it
 10512                                  
 10513                                  ;Copy one char from template to line
 10514                                  COPYONE:
 10515 00001563 B101                            mov	cl,1
 10516                                  ;Copy CX chars from template to line
 10517                                  COPYEACH:
 10518 00001565 36C606[7905]00                  mov	byte [SS:INSMODE],0	;All copies turn off insert mode
 10519 0000156B 38D6                    	cmp	dh,dl
 10520 0000156D 740F                            jz	short GETCH2		;At end of line, can't do anything
 10521 0000156F 38DF                            cmp	bh,bl
 10522 00001571 740B                            jz	short GETCH2		;At end of template, can't do anything
 10523 00001573 AC                              lodsb
 10524 00001574 AA                              stosb
 10525 00001575 E8CF01                  	call	BUFOUT
 10526 00001578 FEC7                            inc	bh			;Ahead in template
 10527 0000157A FEC6                            inc	dh			;Ahead in line
 10528 0000157C E2E7                            loop	COPYEACH
 10529                                  GETCH2:
 10530 0000157E E9E0FE                          jmp	GETCH
 10531                                  
 10532                                  ;Skip one char in template
 10533                                  SKIPONE:
 10534 00001581 38DF                    	cmp	bh,bl
 10535 00001583 74F9                    	jz	short GETCH2		;At end of template
 10536 00001585 FEC7                    	inc	bh			;Ahead in templat
 10537 00001587 46                      	inc	si
 10538 00001588 E9D6FE                  	jmp	GETCH
 10539                                  
 10540                                  SKIPSTR:
 10541 0000158B E80700                  	call	FINDOLD                 ;Find out how far to go
 10542 0000158E 01CE                            add	si,cx			;Go there
 10543 00001590 00CF                            add	bh,cl
 10544 00001592 E9CCFE                          jmp	GETCH
 10545                                  
 10546                                  ;Get the next user char, and look ahead in template for a match
 10547                                  ;CX indicates how many chars to skip to get there on output
 10548                                  ;NOTE: WARNING: If the operation cannot be done, the return
 10549                                  ;       address is popped off and a jump to GETCH is taken.
 10550                                  ;       Make sure nothing extra on stack when this routine
 10551                                  ;       is called!!! (no PUSHes before calling it).
 10552                                  
 10553                                  FINDOLD:
 10554 00001595 E829FE                          call	_$STD_CON_INPUT_NO_ECHO
 10555                                  
 10556                                  	; STRIN.ASM (MSDOS 2.11, 19/07/2018) 
 10557                                  
 10558                                  	;CMP     AL,[SS:ESCCHAR]	
 10559                                  	;JNZ     SHORT FINDSETUP
 10560                                  
 10561                                  	; CPMIO.ASM (MSDOS 6.0, 04/05/2019 - Retro DOS v4.0)
 10562                                  
 10563                                  ;hkn; ESCCHAR is in TABLE seg (DOSCODE), so CS override
 10564                                  
 10565 00001598 2E3A06[380A]            	CMP	AL,[CS:ESCCHAR]		; did he type a function key?
 10566 0000159D 7505                    	JNZ     SHORT FINDSETUP		; no, set up for scan
 10567                                  
 10568 0000159F E81FFE                  	CALL	_$STD_CON_INPUT_NO_ECHO	; eat next char
 10569 000015A2 EB1D                            JMP     SHORT NOTFND		; go try again
 10570                                  FINDSETUP:
 10571 000015A4 88D9                    	mov	cl,bl
 10572 000015A6 28F9                            sub	cl,bh		;CX is number of chars to end of template
 10573 000015A8 7417                    	jz	short NOTFND	;At end of template
 10574 000015AA 49                              dec	cx		;Cannot point past end, limit search
 10575 000015AB 7414                            jz	short NOTFND	 ;If only one char in template, forget it
 10576 000015AD 06                      	push	es
 10577 000015AE 1E                      	push	ds
 10578 000015AF 07                      	pop	es
 10579 000015B0 57                      	push	di
 10580 000015B1 89F7                    	mov	di,si		;Template to ES:DI
 10581 000015B3 47                      	inc	di
 10582 000015B4 F2AE                    	repne	scasb		;Look
 10583 000015B6 5F                      	pop	di
 10584 000015B7 07                      	pop	es
 10585 000015B8 7507                    	jnz	short NOTFND	;Didn't find the char
 10586 000015BA F6D1                            not	cl		;Turn how far to go into how far we went
 10587 000015BC 00D9                            add	cl,bl		;Add size of template
 10588 000015BE 28F9                            sub	cl,bh		;Subtract current pos, result distance to skip
 10589                                  FINDOLD_RETN:
 10590 000015C0 C3                      	retn
 10591                                  
 10592                                  NOTFND:
 10593 000015C1 5D                              pop	bp              ;Chuck return address
 10594 000015C2 E99CFE                          jmp	GETCH
 10595                                  
 10596                                  REEDIT:
 10597 000015C5 B040                    	mov	al,'@'		;Output re-edit character
 10598 000015C7 E8E900                  	call	OUTT
 10599 000015CA 5F                      	pop	di
 10600 000015CB 57                      	push	di
 10601 000015CC 06                      	push	es
 10602 000015CD 1E                      	push	ds
 10603 000015CE E8E6FE                  	call	COPYNEW		;Copy current line into template
 10604 000015D1 1F                      	pop	ds
 10605 000015D2 07                      	pop	es
 10606 000015D3 5E                      	pop	si
 10607 000015D4 88F3                    	mov	bl,dh		;Size of line is new size template
 10608 000015D6 E9F5FE                  	jmp	PUTNEW		;Start over again
 10609                                  
 10610                                  EXITINS:
 10611                                  ENTERINS:
 10612 000015D9 36F616[7905]            	not	byte [SS:INSMODE]
 10613 000015DE E980FE                  	jmp	GETCH
 10614                                  
 10615                                  ;Put a real live ^Z in the buffer (embedded)
 10616                                  CTRLZ:
 10617 000015E1 B01A                    	mov	al,"Z"-"@" ; 1Ah
 10618 000015E3 E9A0FE                          jmp	SAVCH
 10619                                  
 10620                                  ;Output a CRLF
 10621                                  CRLF:
 10622 000015E6 B00D                    	mov	al,c_CR ; 0Dh 
 10623 000015E8 E8C800                  	call	OUTT
 10624 000015EB B00A                    	mov	al,c_LF ; 0Ah
 10625 000015ED E9C300                  	jmp	OUTT
 10626                                  
 10627                                  ;
 10628                                  ;----------------------------------------------------------------------------
 10629                                  ;
 10630                                  ;**	$RAW_CON_IO - Do Raw Console I/O
 10631                                  ;
 10632                                  ;	Input or output raw character from console, no echo
 10633                                  ;
 10634                                  ;	ENTRY	DL = -1 if input
 10635                                  ;		   =  output character if output
 10636                                  ;	EXIT	(AL) = input character if input
 10637                                  ;	USES	all
 10638                                  ;
 10639                                  ;----------------------------------------------------------------------------
 10640                                  ; 20/07/2018 - Retro DOS v3.0
 10641                                  
 10642                                  ; 04/05/2019 - Retro DOS v4.0
 10643                                  ; DOSCODE:541Ch (MSDOS 6.21, MSDOS.SYS)
 10644                                  
 10645                                  ; 08/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 10646                                  ; DOSCODE:5408h (MSDOS 5.0, MSDOS.SYS)
 10647                                  
 10648                                  _$RAW_CON_IO:			; System call 6
 10649                                  
 10650 000015F0 88D0                            MOV     AL,DL
 10651 000015F2 3CFF                            CMP     AL,-1
 10652 000015F4 7541                    	JNZ	SHORT RAWOUT ; 16/12/2022
 10653                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 10654                                  	;jz	short rci1
 10655                                  	;jmp	short RAWOUT
 10656                                  	; 16/12/202
 10657                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 10658                                  	;nop
 10659                                  rci1:	        
 10660                                  			; Get pointer to register save area
 10661 000015F6 36C43E[8405]                    LES     DI,[SS:USER_SP] ; 12/03/2018
 10662 000015FB 31DB                    	XOR     BX,BX
 10663                                      	;CALL	GET_IO_FCB	; MSDOS 2.11 (Retro DOS v2.0)
 10664 000015FD E8BD20                  	CALL	GET_IO_SFT	; MSDOS 3.3 & MSDOS 6.0
 10665                                          ;JC	SHORT RET17
 10666 00001600 72BE                            jc	short FINDOLD_RETN
 10667 00001602 B401                    	MOV     AH,1
 10668 00001604 E8FB2E                          CALL	IOFUNC
 10669 00001607 750B                            JNZ     SHORT RESFLG
 10670 00001609 E8913B                          CALL	SPOOLINT
 10671                                          ;OR	BYTE [ES:DI+16H],40H
 10672 0000160C 26804D1640              	OR	BYTE [ES:DI+user_env.user_F],40H ; Set user's zero flag
 10673 00001611 30C0                            XOR     AL,AL
 10674                                  RET17:
 10675 00001613 C3                              RETN
 10676                                  
 10677                                  RESFLG:
 10678                                  	;AND	BYTE [ES:DI+16H],0FFH-40H  ; 0BFh
 10679 00001614 26806516BF              	AND	BYTE [ES:DI+user_env.user_F],0FFH-40H
 10680                                  				; Reset user's zero flag
 10681                                  ;RILP:
 10682                                  rci0:
 10683 00001619 E8813B                       	CALL	SPOOLINT
 10684                                  ;
 10685                                  ;----------------------------------------------------------------------------
 10686                                  ;
 10687                                  ;**	$Raw_CON_INPUT - Raw Console Input
 10688                                  ;
 10689                                  ;	Input raw character from console, no echo
 10690                                  ;
 10691                                  ;	ENTRY	none
 10692                                  ;	EXIT	(al) = character
 10693                                  ;	USES	all
 10694                                  ;
 10695                                  ;----------------------------------------------------------------------------
 10696                                  ;
 10697                                  
 10698                                  ;rci0:	invoke	SPOOLINT
 10699                                  
 10700                                  	;entry	$RAW_CON_INPUT
 10701                                  
 10702                                  	; 04/05/2019 - Retro DOS v4.0
 10703                                  
 10704                                  ; DOSCODE:544Bh (MSDOS 6.21, MSDOS.SYS)
 10705                                  
 10706                                  _$RAW_CON_INPUT:		; System call 7
 10707 0000161C 53                      	push	bx
 10708 0000161D 31DB                            XOR     BX,BX
 10709                                          ;CALL	GET_IO_FCB	; MSDOS 2.11 (Retro DOS v2.0)
 10710 0000161F E89B20                  	CALL	GET_IO_SFT	; MSDOS 3.3 & MSDOS 6.0
 10711 00001622 5B                              pop	bx
 10712 00001623 72EE                    	JC	SHORT RET17
 10713 00001625 B401                            MOV     AH,1
 10714 00001627 E8D82E                          CALL	IOFUNC
 10715                                  	;JZ	SHORT RILP	; MSDOS 2.11
 10716                                  	;XOR	AH,AH
 10717                                          ;CALL	IOFUNC
 10718                                          ;RETN
 10719 0000162A 7506                    	jnz	short rci5	; MSDOS 3.3 & MSDOS 6.0
 10720 0000162C B484                    	MOV	AH,84h
 10721 0000162E CD2A                    	INT	int_IBM  ; int 2Ah
 10722 00001630 EBE7                    	JMP	short rci0
 10723                                  rci5:	
 10724 00001632 30E4                            XOR     AH,AH
 10725                                          ;CALL	IOFUNC
 10726                                          ;RETN
 10727                                  	; 18/12/2022
 10728 00001634 E9CB2E                  	jmp	IOFUNC
 10729                                  
 10730                                  ;       Output the character in AL to stdout
 10731                                  ;
 10732                                  	;entry   RAWOUT
 10733                                  RAWOUT:
 10734 00001637 53                              PUSH    BX
 10735 00001638 BB0100                          MOV     BX,1
 10736                                  
 10737                                          ;CALL	GET_IO_FCB	; MSDOS 2.11 (Retro DOS v2.0)
 10738 0000163B E87F20                  	CALL	GET_IO_SFT	; MSDOS 3.3 & MSDOS 6.0
 10739 0000163E 721B                            JC      SHORT RAWRET1
 10740                                  
 10741                                  	;
 10742                                  	; MSDOS 2.11
 10743                                          ;TEST	BYTE [SI+18H],080H	; output to file?
 10744                                          ;JZ	SHORT RAWNORM		; if so, do normally
 10745                                          ;PUSH	DS
 10746                                          ;PUSH	SI
 10747                                          ;LDS	SI,[SI+19H]		; output to special?
 10748                                  	;TEST	BYTE [SI+4],ISSPEC
 10749                                  	;POP	SI
 10750                                  	;
 10751                                          
 10752                                  	; MSDOS 3.3 & MSDOS 6.0
 10753                                  	;mov	bx,[si+5]
 10754 00001640 8B5C05                  	MOV	BX,[SI+SF_ENTRY.sf_flags] ;hkn; DS set up by get_io_sft
 10755                                   ;
 10756                                   ; If we are a network handle OR if we are not a local device then go do the
 10757                                   ; output the hard way.
 10758                                   ;	
 10759                                  	;and	bx,8080h
 10760 00001643 81E38080                	AND	BX,sf_isnet+devid_device
 10761                                  	;cmp	bx,80h
 10762 00001647 81FB8000                	CMP	BX,devid_device
 10763 0000164B 7510                    	jnz     short RAWNORM
 10764 0000164D 1E                      	push    ds
 10765                                  	;lds	bx,[si+7]
 10766 0000164E C55C07                  	LDS	BX,[SI+SF_ENTRY.sf_devptr] ; output to special?
 10767                                  	;test	byte [bx+4],10h
 10768 00001651 F6470410                	TEST	BYTE [BX+SYSDEV.ATT],ISSPEC
 10769                                  	;
 10770                                  
 10771 00001655 1F                              POP     DS
 10772 00001656 7405                            JZ      SHORT RAWNORM		; if not, do normally
 10773                                  
 10774 00001658 CD29                            INT	int_fastcon  ; int 29h	; quickly output the char
 10775                                  
 10776                                          ;JMP	SHORT RAWRET
 10777                                  ;RAWNORM:
 10778                                  ;	CALL    RAWOUT3
 10779                                  RAWRET: 
 10780 0000165A F8                      	CLC
 10781                                  RAWRET1:
 10782 0000165B 5B                              POP     BX
 10783                                  RAWRET2:
 10784 0000165C C3                      	RETN
 10785                                  RAWNORM:
 10786 0000165D E80700                  	CALL    RAWOUT3
 10787 00001660 EBF8                    	jmp	short RAWRET
 10788                                  
 10789                                  ;       Output the character in AL to handle in BX
 10790                                  ;
 10791                                  ;	entry   RAWOUT2
 10792                                  
 10793                                  RAWOUT2:
 10794                                  	;CALL	GET_IO_FCB	; MSDOS 2.11 (Retro DOS v2.0)
 10795                                  	;JC	SHORT RET18
 10796 00001662 E85820                  	CALL	GET_IO_SFT	; MSDOS 3.3 & MSDOS 6.0
 10797 00001665 72F5                    	JC	SHORT RAWRET2
 10798                                  RAWOUT3:
 10799 00001667 50                              PUSH    AX
 10800 00001668 EB0C                            JMP     SHORT RAWOSTRT
 10801                                  ROLP:
 10802 0000166A E8303B                          CALL	SPOOLINT
 10803                                  
 10804                                  	; 01/05/2019 - Retro DOS v4.0
 10805                                  
 10806                                  	; MSDOS 6.0
 10807                                  	;OR	word [ss:DOS34_FLAG],CTRL_BREAK_FLAG ; 001000000000b
 10808                                  	; 17/12/2022
 10809 0000166D 36800E[1206]02          	or	byte [ss:DOS34_FLAG+1],(CTRL_BREAK_FLAG>>8) ; 02h	
 10810                                  	;or	word [ss:DOS34_FLAG],200h
 10811                                  				;AN002; set control break
 10812                                  	;invoke DSKSTATCHK
 10813 00001673 E8A43A                  	call	DSKSTATCHK	;AN002; check control break
 10814                                  RAWOSTRT:
 10815 00001676 B403                            MOV     AH,3
 10816 00001678 E8872E                          CALL    IOFUNC
 10817 0000167B 74ED                            JZ      SHORT ROLP
 10818                                  
 10819                                  	; MSDOS 6.0
 10820                                  ;SR;
 10821                                  ; IOFUNC now returns ax = 0ffffh if there was an I24 on a status call and
 10822                                  ;the user failed. We do not send a char if this happens. We however return 
 10823                                  ;to the caller with carry clear because this DOS call does not return any
 10824                                  ;status. 
 10825                                  ;
 10826 0000167D 40                      	inc	ax		;fail on I24 if ax = -1
 10827 0000167E 58                      	POP	AX
 10828 0000167F 7405                    	jz	short nosend	;yes, do not send char
 10829 00001681 B402                    	MOV	AH,2
 10830 00001683 E87C2E                  	call	IOFUNC
 10831                                  nosend:
 10832 00001686 F8                      	CLC			; Clear carry indicating successful
 10833 00001687 C3                      	retn
 10834                                  
 10835                                  	; MSDOS 3.3 & MSDOS 2.11
 10836                                  	;POP	AX
 10837                                  	;MOV	AH,2
 10838                                          ;CALL	IOFUNC
 10839                                  	;CLC			; Clear carry indicating successful
 10840                                  ;RET18:    
 10841                                  	;RETN
 10842                                  
 10843                                  ;;10/08/2018
 10844                                  ; 20/07/2018 - Retro DOS v3.0
 10845                                  ; ---------------------------------------------------------------------------
 10846                                  ; Retro DOS v2.0 (MSDOS 2.11) - OUTMES
 10847                                  ; ---------------------------------------------------------------------------
 10848                                  
 10849                                  ; This routine is called at DOS init
 10850                                  
 10851                                  ;;	;procedure OUTMES,NEAR ; String output for internal messages
 10852                                  ;;OUTMES:
 10853                                  ;;	;LODS	CS:BYTE PTR [SI]
 10854                                  ;;	CS	LODSB
 10855                                  ;;	CMP     AL,"$" ; 24h
 10856                                  ;;	JZ	SHORT RET18
 10857                                  ;;	CALL	OUTT
 10858                                  ;;	JMP     SHORT OUTMES
 10859                                  
 10860                                  ; ---------------------------------------------------------------------------
 10861                                  
 10862                                  ; 20/07/2018 - Retro DOS v3.0
 10863                                  
 10864                                  ; IBMDOS.COM (MSDOS 3.3 kernel) - Offset 2252h
 10865                                  
 10866                                  ;
 10867                                  ;----------------------------------------------------------------------------
 10868                                  ;
 10869                                  ; Inputs:
 10870                                  ;	AX=0 save the DEVCALL request packet
 10871                                  ;	  =1 restore the DEVCALL request packet
 10872                                  ; Function:
 10873                                  ;	save or restore the DEVCALL packet
 10874                                  ; Returns:
 10875                                  ;	none
 10876                                  ;
 10877                                  ;----------------------------------------------------------------------------
 10878                                  ;
 10879                                  
 10880                                  ; 04/05/2019 - Retro DOS v4.0
 10881                                  ; DOSCODE:54B9h (MSDOS 6.21, MSDOS.SYS)
 10882                                  
 10883                                  ; 08/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 10884                                  ; DOSCODE:54A5h (MSDOS 5.0, MSDOS.SYS)
 10885                                  
 10886                                  ; 12/05/2019
 10887                                  
 10888                                  Save_Restore_Packet:
 10889 00001688 1E                      	PUSH	DS
 10890 00001689 06                      	PUSH	ES
 10891 0000168A 56                      	PUSH	SI
 10892 0000168B 57                      	PUSH	DI
 10893                                  
 10894                                  	; 16/12/2022
 10895                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 10896                                  	; 09/09/2018
 10897 0000168C BF[6C0D]                	mov	di,FAKE_STACK_2F 
 10898 0000168F BE[5A03]                	mov	si,DEVCALL
 10899                                  	;
 10900                                  	; 21/09/2023
 10901 00001692 09C0                    	or	ax,ax 
 10902                                  	;CMP	AX,0		; save packet
 10903 00001694 7402                    	JZ	short save_packet ; 16/12/2022
 10904                                  	;je	short set_seg
 10905                                  
 10906                                  	; MSDOS 6.0
 10907                                  restore_packet:
 10908                                  ;	MOV	SI,OFFSET DOSDATA:Packet_Temp	;source
 10909                                  ;	MOV	DI,OFFSET DOSDATA:DEVCALL	;destination
 10910                                  	; MSDOS 3.3
 10911                                  	;mov	si,FAKE_STACK_2F ; DOS_TEMP ; Packed_Temp 
 10912                                  	;mov	di,DEVCALL  ; 09/09/2018
 10913                                  	;
 10914                                  	;JMP	short set_seg
 10915                                  
 10916                                  	; 16/12/2022	
 10917                                  	; 09/09/2018
 10918 00001696 87F7                    	xchg	si,di  ; DI = offset DEVCALL, SI = offset FAKE_STACK_2F
 10919                                  
 10920                                  ; 16/12/2022
 10921                                  %if 0
 10922                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 10923                                  	cmp	ax,0		; save packet
 10924                                  	jz	short save_packet
 10925                                  	mov	si,FAKE_STACK_2F ; 07/12/2022
 10926                                  	mov	di,DEVCALL 
 10927                                  	jmp	short set_seg
 10928                                  
 10929                                  	; MSDOS 6.0
 10930                                  save_packet:
 10931                                  ;	MOV	DI,OFFSET DOSDATA:Packet_Temp	;destination
 10932                                  ;	MOV	SI,OFFSET DOSDATA:DEVCALL	;source
 10933                                  	; 09/09/2018
 10934                                  	; MSDOS 3.3
 10935                                  	;mov	di,FAKE_STACK_2F ; DOS_TEMP ; Packed_Temp 
 10936                                  	;mov	si,DEVCALL ; 09/09/2018
 10937                                  
 10938                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 10939                                  	mov	di,FAKE_STACK_2F ; DOS_TEMP ; Packed_Temp 
 10940                                  	mov	si,DEVCALL
 10941                                  %endif
 10942                                  
 10943                                  ; 16/12/2022
 10944                                  save_packet:
 10945                                  ;set_seg:
 10946                                  	; MSDOS 3.3
 10947                                  	;mov	ax,cs
 10948                                  
 10949                                  	; MSDOS 6.0
 10950 00001698 8CD0                    	MOV	AX,SS		; set DS,ES to DOSDATA	
 10951                                  
 10952 0000169A 8ED8                    	MOV	DS,AX
 10953 0000169C 8EC0                    	MOV	ES,AX
 10954 0000169E B90B00                  	MOV	CX,11		; 11 words to move
 10955 000016A1 F3A5                    	REP	MOVSW
 10956                                  
 10957 000016A3 5F                      	POP	DI
 10958 000016A4 5E                      	POP	SI
 10959 000016A5 07                      	POP	ES
 10960 000016A6 1F                      	POP	DS
 10961 000016A7 C3                      	retn
 10962                                  
 10963                                  ;============================================================================
 10964                                  ; CPMIO2.ASM, MSDOS 6.0, 1991
 10965                                  ;============================================================================
 10966                                  ; 20/07/2018 - Retro DOS v3.0
 10967                                  ; 01/05/2019 - Retro DOS v4.0
 10968                                  
 10969                                  ;hkn; 	All the variables use SS override or DS. Therefore there is
 10970                                  ;hkn;	no need to specifically set up any seg regs unless SS assumption is
 10971                                  ;hkn;	not valid. 
 10972                                  
 10973                                  ;
 10974                                  ;----------------------------------------------------------------------------
 10975                                  ;
 10976                                  ;**	$STD_CON_INPUT - System Call 1
 10977                                  ;
 10978                                  ;	Input character from console, echo
 10979                                  ;
 10980                                  ;	ENTRY	none
 10981                                  ;	EXIT	(al) = character
 10982                                  ;	USES	ALL
 10983                                  ;
 10984                                  ;----------------------------------------------------------------------------
 10985                                  ;
 10986                                  
 10987                                  _$STD_CON_INPUT:	;System call 1
 10988                                  	
 10989 000016A8 E816FD                  	CALL	_$STD_CON_INPUT_NO_ECHO
 10990 000016AB 50                      	PUSH	AX
 10991 000016AC E80400                  	CALL	OUTT
 10992 000016AF 58                      	POP	AX
 10993                                  CON_INPUT_RETN:	
 10994 000016B0 C3                      	RETN
 10995                                  
 10996                                  ;
 10997                                  ;----------------------------------------------------------------------------
 10998                                  ;
 10999                                  ;**	$STD_CON_OUTPUT - System Call 2
 11000                                  ;
 11001                                  ;	Output character to console
 11002                                  ;
 11003                                  ;	ENTRY	(dl) = character
 11004                                  ;	EXIT	none
 11005                                  ;	USES	all
 11006                                  ;
 11007                                  ;----------------------------------------------------------------------------
 11008                                  ;
 11009                                  
 11010                                  ; DOSCODE:54E9h (MSDOS 6.21, MSDOS.SYS)
 11011                                  
 11012                                  ; 08/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 11013                                  ; DOSCODE:54D5h (MSDOS 5.0, MSDOS.SYS)
 11014                                  
 11015                                  _$STD_CON_OUTPUT:	;System call 2
 11016                                  
 11017 000016B1 88D0                    	MOV	AL,DL
 11018                                  OUTT:
 11019 000016B3 3C20                    	CMP	AL,20H ; " "
 11020 000016B5 725C                    	JB	SHORT CTRLOUT
 11021 000016B7 3C7F                    	CMP	AL,c_DEL ; 7Fh
 11022 000016B9 7405                    	JZ	SHORT OUTCH
 11023                                  OUTCHA:	
 11024                                  	;INC	BYTE PTR [CARPOS]
 11025 000016BB 36FE06[F901]            	INC	BYTE [SS:CARPOS]
 11026                                  OUTCH:
 11027 000016C0 1E                      	PUSH	DS
 11028 000016C1 56                      	PUSH	SI
 11029                                  	;INC	BYTE PTR [CHARCO]		;invoke  statchk...
 11030                                  	;AND	BYTE PTR [CHARCO],00111111B	;AN000; every 64th char
 11031 000016C2 36FE06[0003]            	INC	BYTE [SS:CHARCO]	
 11032                                  	;AND	BYTE [SS:CHARCO],00111111B
 11033                                  	; 01/05/2019 - Retro DOS v4.0
 11034 000016C7 368026[0003]3F          	and	byte [SS:CHARCO],3Fh
 11035 000016CD 7505                    	JNZ	SHORT OUTSKIP
 11036                                  
 11037 000016CF 50                      	PUSH	AX
 11038 000016D0 E8F83A                  	CALL	STATCHK
 11039 000016D3 58                      	POP	AX
 11040                                  OUTSKIP:
 11041 000016D4 E860FF                  	CALL	RAWOUT				;output the character
 11042                                  
 11043 000016D7 5E                      	POP	SI
 11044 000016D8 1F                      	POP	DS
 11045                                  
 11046                                  	;TEST	BYTE PTR [PFLAG],-1
 11047                                  	;retz
 11048 000016D9 36F606[FE02]FF          	TEST	BYTE [SS:PFLAG],0FFh
 11049 000016DF 74CF                    	JZ	SHORT CON_INPUT_RETN
 11050                                  
 11051 000016E1 53                      	PUSH	BX
 11052 000016E2 1E                      	PUSH	DS
 11053 000016E3 56                      	PUSH	SI
 11054 000016E4 BB0100                  	MOV	BX,1
 11055                                  	; 20/07/2018 - Retro DOS v3.0
 11056                                  	; MSDOS 3.3
 11057                                  	; MSDOS 6.0 (CPMIO2.ASM)
 11058 000016E7 E8D31F                  	CALL	GET_IO_SFT		;hkn; GET_IO_SFT will set up DS:SI 
 11059                                  					;hkn; to sft entry
 11060 000016EA 7224                    	JC	SHORT TRIPOPJ
 11061                                  
 11062                                  	; 01/05/2019 - Retro DOS v4.0
 11063                                  
 11064                                  	;mov	bx,[si+5]
 11065 000016EC 8B5C05                  	MOV	BX,[SI+SF_ENTRY.sf_flags]
 11066                                  	;test	bx,8000h
 11067                                  	;TEST	BX,sf_isnet	; 8000h		; output to NET?
 11068 000016EF F6C780                  	test	bh,(sf_isnet>>8) ; 80h
 11069 000016F2 751C                    	JNZ	short TRIPOPJ 			; if so, no echo
 11070                                  	;;test	bx,80h
 11071                                  	;TEST	BX,devid_device 		; output to file?
 11072 000016F4 F6C380                  	test	bl,devid_device ; 80h
 11073 000016F7 7417                    	JZ	SHORT TRIPOPJ 			; if so, no echo
 11074                                  	; 14/03/2018
 11075                                  	;call	GET_IO_FCB	 	; IBMDOS.COM, MSDOS 2.11
 11076                                  	;jc	short TRIPOPJ
 11077                                  	; MSDOS 2.11
 11078                                  	;test	byte [SI+18H], 80h
 11079                                  	;jz	short TRIPOPJ
 11080 000016F9 BB0400                  	MOV	BX,4
 11081 000016FC E8BE1F                  	CALL	GET_IO_SFT
 11082 000016FF 720F                    	JC	SHORT TRIPOPJ
 11083                                  	;;test	word [si+5], 800h
 11084                                  	;TEST	word [SI+SF_ENTRY.sf_flags],sf_net_spool ; 800H
 11085                                  	;test	byte [si+6],8 ; 08/11/2022
 11086 00001701 F6440608                	test	byte [SI+SF_ENTRY.sf_flags+1],(sf_net_spool>>8) ; 8 
 11087                                  						; StdPrn redirected?
 11088                                  	;;JZ	SHORT LISSTRT2J			; No, OK to echo
 11089                                  	;jz	LISSTRT2 ; 10/08/2018 
 11090                                  	; 16/12/2022
 11091 00001705 7503                    	jnz	short outch1
 11092 00001707 E98700                  	jmp	LISSTRT2
 11093                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 11094                                  	;jz	short LISSTRT2J
 11095                                  outch1:
 11096                                  	;MOV	BYTE [PFLAG],0			
 11097 0000170A 36C606[FE02]00          	MOV	BYTE [SS:PFLAG],0		; If a spool, NEVER echo
 11098                                  	; MSDOS 2.11
 11099                                  	;mov	bx,4
 11100                                  	;jmp	short LISSTRT2
 11101                                  	
 11102                                  TRIPOPJ:
 11103                                  	; 20/07/2018
 11104 00001710 E98100                  	JMP	TRIPOP
 11105                                  
 11106                                  	; 16/12/2022
 11107                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 11108                                  ;LISSTRT2J:
 11109                                  ;	JMP	LISSTRT2
 11110                                  
 11111                                  CTRLOUT:
 11112 00001713 3C0D                    	CMP	AL,c_CR ; 0Dh
 11113 00001715 7420                    	JZ	SHORT ZERPOS
 11114 00001717 3C08                    	CMP	AL,c_BS ; 8
 11115 00001719 7424                    	JZ	SHORT BACKPOS
 11116 0000171B 3C09                    	CMP	AL,c_HT ; 9
 11117 0000171D 75A1                    	JNZ	SHORT OUTCH
 11118                                  	;MOV	AL,[CARPOS]
 11119 0000171F 36A0[F901]              	MOV	AL,[SS:CARPOS]
 11120 00001723 0CF8                    	OR	AL,0F8H
 11121 00001725 F6D8                    	NEG	AL
 11122                                  TAB:
 11123 00001727 51                      	PUSH	CX
 11124 00001728 88C1                    	MOV	CL,AL
 11125 0000172A B500                    	MOV	CH,0
 11126 0000172C E307                    	JCXZ	POPTAB
 11127                                  TABLP:
 11128 0000172E B020                    	MOV	AL," "
 11129 00001730 E880FF                  	CALL	OUTT
 11130 00001733 E2F9                    	LOOP	TABLP
 11131                                  POPTAB:
 11132 00001735 59                      	POP	CX
 11133                                  
 11134 00001736 C3                      	RETN
 11135                                  
 11136                                  ZERPOS:
 11137                                  	;MOV	BYTE PTR [CARPOS],0
 11138 00001737 36C606[F901]00          	MOV	BYTE [SS:CARPOS],0
 11139                                  	; 10/08/2018
 11140 0000173D EB81                    	JMP	short OUTCH ; 04/05/2019
 11141                                  	
 11142                                  	; 18/12/2022
 11143                                  ;OUTJ:	
 11144                                  	;JMP	OUTT
 11145                                  
 11146                                  BACKPOS:
 11147                                  	;DEC	BYTE PTR [CARPOS]
 11148 0000173F 36FE0E[F901]            	DEC	BYTE [SS:CARPOS]
 11149 00001744 E979FF                  	JMP	OUTCH
 11150                                  
 11151                                  BUFOUT:
 11152 00001747 3C20                    	CMP	AL," "
 11153 00001749 7315                    	JAE	SHORT OUTJ		;Normal char
 11154 0000174B 3C09                    	CMP	AL,9
 11155 0000174D 7411                    	JZ	SHORT OUTJ		;OUT knows how to expand tabs
 11156                                  	;DOS 3.3  7/14/86
 11157 0000174F 3C15                    	CMP	AL,"U"-"@" ; 15h	; turn ^U to section symbol
 11158 00001751 740D                    	JZ	short CTRLU
 11159 00001753 3C14                    	CMP	AL,"T"-"@" ; 14h	; turn ^T to paragraph symbol
 11160 00001755 7409                    	JZ	short CTRLU
 11161                                  NOT_CTRLU:
 11162                                  	;DOS 3.3  7/14/86
 11163 00001757 50                      	PUSH	AX
 11164 00001758 B05E                    	MOV	AL,"^"
 11165 0000175A E856FF                  	CALL	OUTT		;Print '^' before control chars
 11166 0000175D 58                      	POP	AX
 11167 0000175E 0C40                    	OR	AL,40H		;Turn it into Upper case mate
 11168                                  CTRLU:
 11169                                  	;CALL	OUTT
 11170                                  	; 18/12/2022
 11171                                  OUTJ:
 11172 00001760 E950FF                  	jmp	OUTT
 11173                                  ;BUFOUT_RETN:
 11174                                  	;RETN
 11175                                  
 11176                                  ;
 11177                                  ;----------------------------------------------------------------------------
 11178                                  ;
 11179                                  ;**	$STD_AUX_INPUT - System Call 3
 11180                                  ;
 11181                                  ;	$STD_AUX_INPUT returns a character from Aux Input
 11182                                  ;
 11183                                  ;	ENTRY	none
 11184                                  ;	EXIT	(al) = character
 11185                                  ;	USES	all
 11186                                  ;
 11187                                  ;----------------------------------------------------------------------------
 11188                                  ;
 11189                                  
 11190                                  	; 08/11/2022 Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 11191                                  
 11192                                  _$STD_AUX_INPUT:	;System call 3
 11193                                  
 11194 00001763 E8653A                  	CALL	STATCHK
 11195 00001766 BB0300                  	MOV	BX,3
 11196 00001769 E8511F                  	CALL	GET_IO_SFT	; 20/07/2018 - MSDOS 3.3 (MSDOS 6.0)
 11197                                  	;CALL	GET_IO_FCB	; 14/03/2018 - MSDOS 2.11
 11198                                  	;retc
 11199                                  	; 16/12/2022
 11200                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 11201                                  	;JC	SHORT BUFOUT_RETN
 11202                                  	;JMP	SHORT TAISTRT
 11203                                  	; 07/12/2022
 11204 0000176C 7304                    	jnc	SHORT TAISTRT
 11205 0000176E C3                      	retn	
 11206                                  
 11207                                  AUXILP:
 11208 0000176F E82B3A                  	CALL	SPOOLINT
 11209                                  TAISTRT:
 11210 00001772 B401                    	MOV	AH,1
 11211 00001774 E88B2D                  	CALL	IOFUNC
 11212 00001777 74F6                    	JZ	SHORT AUXILP
 11213 00001779 30E4                    	XOR	AH,AH
 11214                                  	; 16/12/2022
 11215                                  	;CALL	IOFUNC
 11216                                  	;RETN
 11217                                  	; 07/12/2022
 11218 0000177B E9842D                  	jmp	IOFUNC
 11219                                  
 11220                                  ;
 11221                                  ;----------------------------------------------------------------------------
 11222                                  ;
 11223                                  ;**	$STD_AUX_OUTPUT - Output character to AUX
 11224                                  ;
 11225                                  ;	ENTRY	(dl) = character
 11226                                  ;	EXIT	none
 11227                                  ;	USES	all
 11228                                  ;
 11229                                  ;----------------------------------------------------------------------------
 11230                                  ;
 11231                                  
 11232                                  _$STD_AUX_OUTPUT:	;System call 4
 11233                                  
 11234 0000177E 53                      	PUSH	BX
 11235 0000177F BB0300                  	MOV	BX,3
 11236 00001782 EB04                    	JMP	SHORT SENDOUT
 11237                                  
 11238                                  ;
 11239                                  ;----------------------------------------------------------------------------
 11240                                  ;
 11241                                  ;**	$STD_PRINTER_OUTPUT - Output character to printer
 11242                                  ;
 11243                                  ;	ENTRY	(dl) = character
 11244                                  ;	EXIT	none
 11245                                  ;	USES	all
 11246                                  ;
 11247                                  ;----------------------------------------------------------------------------
 11248                                  ;
 11249                                  
 11250                                  _$STD_PRINTER_OUTPUT:	;System call 5
 11251                                  
 11252 00001784 53                      	PUSH	BX
 11253 00001785 BB0400                  	MOV	BX,4
 11254                                  
 11255                                  SENDOUT:
 11256 00001788 88D0                    	MOV	AL,DL
 11257 0000178A 50                      	PUSH	AX
 11258 0000178B E83D3A                  	CALL	STATCHK
 11259 0000178E 58                      	POP	AX
 11260 0000178F 1E                      	PUSH	DS
 11261 00001790 56                      	PUSH	SI
 11262                                  LISSTRT2:
 11263 00001791 E8CEFE                  	CALL	RAWOUT2
 11264                                  TRIPOP:
 11265 00001794 5E                      	POP	SI
 11266 00001795 1F                      	POP	DS
 11267 00001796 5B                      	POP	BX
 11268                                  SCIS_RETN:	; 20/07/2018
 11269 00001797 C3                      	RETN
 11270                                  ;
 11271                                  ;----------------------------------------------------------------------------
 11272                                  ;
 11273                                  ;**	$STD_CON_INPUT_STATUS - System Call 11
 11274                                  ;
 11275                                  ;	Check console input status
 11276                                  ;
 11277                                  ;	ENTRY	none
 11278                                  ;	EXIT	AL = -1 character available, = 0 no character
 11279                                  ;	USES	all
 11280                                  ;
 11281                                  ;----------------------------------------------------------------------------
 11282                                  ;
 11283                                  
 11284                                  _$STD_CON_INPUT_STATUS:		;System call 11
 11285                                  
 11286 00001798 E8303A                  	CALL	STATCHK
 11287 0000179B B000                    	MOV	AL,0		; no xor!!
 11288                                  	;retz
 11289 0000179D 74F8                    	JZ	SHORT SCIS_RETN ; 15/04/2018
 11290 0000179F 0CFF                    	OR	AL,-1
 11291                                  ;SCIS_RETN:
 11292 000017A1 C3                      	RETN
 11293                                  
 11294                                  ;
 11295                                  ;----------------------------------------------------------------------------
 11296                                  ;
 11297                                  ;**	$STD_CON_INPUT_FLUSH - System Call 12
 11298                                  ;
 11299                                  ;	Flush console input buffer and perform call in AL
 11300                                  ;
 11301                                  ;	ENTRY	(AL) = DOS function to be called after flush (1,6,7,8,10)
 11302                                  ;	EXIT	(al) = 0 iff (al) was not one of the supported fcns
 11303                                  ;		return arguments for the fcn supplied in (AL)
 11304                                  ;	USES	all
 11305                                  ;
 11306                                  ;----------------------------------------------------------------------------
 11307                                  ;
 11308                                  
 11309                                  _$STD_CON_INPUT_FLUSH:		;System call 12
 11310                                  
 11311 000017A2 50                      	PUSH	AX
 11312 000017A3 52                      	PUSH	DX
 11313 000017A4 31DB                    	XOR	BX,BX
 11314 000017A6 E8141F                  	CALL	GET_IO_SFT	; 20/07/2018 - MSDOS 3.3 (MSDOS 6.0)
 11315                                  	;CALL	GET_IO_FCB	; 14/03/2018 - MSDOS 2.11
 11316 000017A9 7205                    	JC	SHORT BADJFNCON
 11317 000017AB B404                    	MOV	AH,4
 11318 000017AD E8522D                  	CALL	IOFUNC
 11319                                  
 11320                                  BADJFNCON:
 11321 000017B0 5A                      	POP	DX
 11322 000017B1 58                      	POP	AX
 11323 000017B2 88C4                    	MOV	AH,AL
 11324 000017B4 3C01                    	CMP	AL,1
 11325 000017B6 7413                    	JZ	SHORT REDISPJ
 11326 000017B8 3C06                    	CMP	AL,6
 11327 000017BA 740F                    	JZ	SHORT REDISPJ
 11328 000017BC 3C07                    	CMP	AL,7
 11329 000017BE 740B                    	JZ	SHORT REDISPJ
 11330 000017C0 3C08                    	CMP	AL,8
 11331 000017C2 7407                    	JZ	SHORT REDISPJ
 11332 000017C4 3C0A                    	CMP	AL,10
 11333 000017C6 7403                    	JZ	SHORT REDISPJ
 11334 000017C8 B000                    	MOV	AL,0
 11335 000017CA C3                      	RETN
 11336                                  
 11337                                  REDISPJ:
 11338 000017CB FA                      	CLI
 11339                                  	;transfer REDISP
 11340 000017CC E9BEEB                  	JMP	REDISP
 11341                                  
 11342                                  ;============================================================================
 11343                                  ; FCBIO.ASM, MSDOS 6.0, 1991
 11344                                  ;============================================================================
 11345                                  ; 20/07/2018 - Retro DOS v3.0
 11346                                  ; 17/05/2019 - Retro DOS v4.0
 11347                                  
 11348                                  ;**	FCBIO.ASM - Ancient 1.0 1.1 FCB system calls
 11349                                  ;
 11350                                  ;	$GET_FCB_POSITION
 11351                                  ;	$FCB_DELETE
 11352                                  ;	$GET_FCB_FILE_LENGTH
 11353                                  ;	$FCB_CLOSE
 11354                                  ;	$FCB_RENAME
 11355                                  ;	SaveFCBInfo
 11356                                  ;	ResetLRU
 11357                                  ;	SetOpenAge
 11358                                  ;	LRUFCB
 11359                                  ;	FCBRegen
 11360                                  ;	BlastSFT
 11361                                  ;	CheckFCB
 11362                                  ;	SFTFromFCB
 11363                                  ;	FCBHardErr
 11364                                  ;
 11365                                  ;	Revision history:
 11366                                  ;
 11367                                  ;		Created: ARR 4 April 1983"
 11368                                  ;			 MZ  6 June  1983 completion of functions
 11369                                  ;			 MZ 15 Dec   1983 Brain damaged programs close FCBs multiple
 11370                                  ;					  times.  Change so successive closes work by
 11371                                  ;					  always returning OK.	Also, detect I/O to
 11372                                  ;					  already closed FCB and return EOF.
 11373                                  ;			 MZ 16 Jan   1984 More braindamage.  Need to separate info
 11374                                  ;					  out of sft into FCB for reconnection
 11375                                  ;
 11376                                  ;		A000	 version 4.00  Jan. 1988
 11377                                  
 11378                                  ;Break <$Get_FCB_Position - set random record fields to current pos>
 11379                                  ;----------------------------------------------------------------------------
 11380                                  ;
 11381                                  ;   $Get_FCB_Position - look at an FCB, retrieve the current position from the
 11382                                  ;	extent and next record field and set the random record field to point
 11383                                  ;	to that record
 11384                                  ;
 11385                                  ;   Inputs:	DS:DX point to a possible extended FCB
 11386                                  ;   Outputs:	The random record field of the FCB is set to the current record
 11387                                  ;   Registers modified: all
 11388                                  ;
 11389                                  ;----------------------------------------------------------------------------
 11390                                  ;
 11391                                  
 11392                                  _$GET_FCB_POSITION:
 11393 000017CF E8F204                  	call	GetExtended		; point to FCB
 11394 000017D2 E8C204                  	call	GetExtent		; DX:AX is current record
 11395                                  	;mov	[si+21h],ax
 11396 000017D5 894421                  	MOV	[SI+SYS_FCB.RR],AX 	; drop in low order piece
 11397                                  	;mov	[si+23h],dl
 11398 000017D8 885423                  	MOV	[SI+SYS_FCB.RR+2],DL	; drop in high order piece
 11399                                  	;cmp	word [si+0Eh],64
 11400 000017DB 837C0E40                	CMP	word [SI+SYS_FCB.RECSIZ],64
 11401 000017DF 7303                    	JAE	short GetFCBBye
 11402                                  	;mov	[si+24h],dh
 11403 000017E1 887424                  	MOV	[SI+SYS_FCB.RR+2+1],DH	; Set 4th byte only if record size < 64
 11404                                  GoodPath:	; 16/12/2022
 11405                                  GetFCBBye:
 11406 000017E4 E97FEE                  	jmp	FCB_RET_OK
 11407                                  
 11408                                  ;Break <$FCB_Delete - remove several files that match the input FCB>
 11409                                  ;----------------------------------------------------------------------------
 11410                                  ;
 11411                                  ;**	$FCB_Delete - Delete from FCB Template
 11412                                  ;
 11413                                  ;	given an FCB, remove all directory entries in the current
 11414                                  ;	directory that have names that match the FCB's ?  marks.
 11415                                  ;
 11416                                  ;	ENTRY	(DS:DX) = address of FCB
 11417                                  ;	EXIT	entries matching the FCB are deleted
 11418                                  ;		(al) = ff iff no entries were deleted
 11419                                  ;	USES	all
 11420                                  ;
 11421                                  ;----------------------------------------------------------------------------
 11422                                  ;
 11423                                  	; 08/11/2022 Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 11424                                  
 11425                                  _$FCB_DELETE:		; System call 19
 11426                                  					; OpenBuf is in DOSDATA
 11427 000017E7 BF[BE03]                	MOV	DI,OPENBUF 		; appropriate place 
 11428                                  
 11429 000017EA E88C53                  	call	TransFCB		; convert FCB to path
 11430 000017ED 7207                    	JC	short BadPath 		; signal no deletions
 11431                                  
 11432 000017EF 16                      	push	SS
 11433 000017F0 1F                      	pop	DS			; SS is DOSDATA
 11434                                  
 11435 000017F1 E89D0D                  	call	DOS_DELETE		; wham
 11436                                  	;JC	short BadPath
 11437                                  	; 16/12/2022
 11438 000017F4 73EE                    	jnc 	short GoodPath
 11439                                  ;GoodPath:
 11440                                  ;	;jmp	FCB_RET_OK		; do a good return
 11441                                  ;	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 11442                                  ;	jmp	short GetFCBBye
 11443                                  
 11444                                  BadPath:
 11445                                  	; Error code is in AX
 11446                                  
 11447 000017F6 E970EE                  	jmp	FCB_RET_ERR		; let someone else signal the error
 11448                                  
 11449                                  ;Break <$Get_FCB_File_Length - return the length of a file>
 11450                                  ;----------------------------------------------------------------------------
 11451                                  ;
 11452                                  ;   $Get_FCB_File_Length - set the random record field to the length of the
 11453                                  ;	file in records (rounded up if partial).
 11454                                  ;
 11455                                  ;   Inputs:	DS:DX - point to a possible extended FCB
 11456                                  ;   Outputs:	Random record field updated to reflect the number of records
 11457                                  ;   Registers modified: all
 11458                                  ;
 11459                                  ;----------------------------------------------------------------------------
 11460                                  ;
 11461                                  
 11462                                  _$GET_FCB_FILE_LENGTH:
 11463                                  
 11464 000017F9 E8C804                  	call	GetExtended		; get real FCB pointer
 11465                                  					; DX points to Input FCB
 11466                                  
 11467                                  					; OpenBuf is in DOSDATA
 11468 000017FC BF[BE03]                	MOV	DI,OPENBUF		; appropriate buffer
 11469                                  
 11470 000017FF 1E                      	push	ds			; save pointer to true FCB
 11471 00001800 56                      	push	si
 11472 00001801 E87553                  	call	TransFCB		; Trans name DS:DX, sets SATTRIB
 11473 00001804 5E                      	pop	si
 11474 00001805 1F                      	pop	ds
 11475 00001806 72EE                    	JC	short BadPath
 11476 00001808 1E                      	push	ds			; save pointer
 11477 00001809 56                      	push	si
 11478 0000180A 16                      	push	ss		
 11479 0000180B 1F                      	pop	ds
 11480 0000180C E89211                  	call	GET_FILE_INFO		; grab the info
 11481 0000180F 5E                      	pop	si			; get pointer back
 11482 00001810 1F                      	pop	ds
 11483 00001811 72E3                    	JC	short BadPath 		; invalid something
 11484 00001813 89DA                    	MOV	DX,BX			; get high order size
 11485 00001815 89F8                    	MOV	AX,DI			; get low order size
 11486                                  	;mov	bx,[si+0Eh]
 11487 00001817 8B5C0E                  	MOV	BX,[SI+SYS_FCB.RECSIZ]	; get his record size
 11488 0000181A 09DB                    	OR	BX,BX			; empty record => 0 size for file
 11489 0000181C 7503                    	JNZ	short GetSize 		; not empty
 11490 0000181E BB8000                  	MOV	BX,128
 11491                                  GetSize:
 11492 00001821 89C7                    	MOV	DI,AX			; save low order word
 11493 00001823 89D0                    	MOV	AX,DX			; move high order for divide
 11494 00001825 31D2                    	XOR	DX,DX			; clear out high
 11495 00001827 F7F3                    	DIV	BX			; wham
 11496 00001829 50                      	PUSH	AX			; save dividend
 11497 0000182A 89F8                    	MOV	AX,DI			; get low order piece
 11498 0000182C F7F3                    	DIV	BX			; wham
 11499 0000182E 89D1                    	MOV	CX,DX			; save remainder
 11500 00001830 5A                      	POP	DX			; get high order dividend
 11501 00001831 E306                    	JCXZ	LengthStore		; no roundup
 11502 00001833 83C001                  	ADD	AX,1
 11503 00001836 83D200                  	ADC	DX,0			; 32-bit increment
 11504                                  LengthStore:
 11505                                  	;mov	[si+21h],ax
 11506 00001839 894421                  	MOV	[SI+SYS_FCB.RR],AX	; store low order
 11507                                  	;mov	[si+23h],dl
 11508 0000183C 885423                  	MOV	[SI+SYS_FCB.RR+2],DL	; store high order
 11509 0000183F 08F6                    	OR	DH,DH
 11510 00001841 74A1                    	JZ	short GoodPath		; not storing insignificant zero
 11511                                  	;mov	[si+24h],dh
 11512 00001843 887424                  	MOV	[SI+SYS_FCB.RR+3],DH	; save that high piece
 11513                                  	; 16/12/2022
 11514                                  GoodRet:
 11515                                  	;jmp	FCB_RET_OK
 11516 00001846 EB9C                    	jmp	short GoodPath
 11517                                  
 11518                                  ;Break <$FCB_Close - close a file>
 11519                                  ;----------------------------------------------------------------------------
 11520                                  ;
 11521                                  ;   $FCB_Close - given an FCB, look up the SFN and close it.  Do not free it
 11522                                  ;	as the FCB may be used for further I/O
 11523                                  ;
 11524                                  ;   Inputs:	DS:DX point to FCB
 11525                                  ;   Outputs:	AL = FF if file was not found on disk
 11526                                  ;   Registers modified: all
 11527                                  ;
 11528                                  ;----------------------------------------------------------------------------
 11529                                  ;
 11530                                  
 11531                                  _$FCB_CLOSE:		; System call 16
 11532                                  
 11533 00001848 30C0                    	XOR	AL,AL			; default search attributes
 11534 0000184A E87704                  	call	GetExtended		; DS:SI point to real FCB
 11535 0000184D 7403                    	JZ	short NoAttr		; not extended
 11536 0000184F 8A44FF                  	MOV	AL,[SI-1]		; get attributes
 11537                                  NoAttr:
 11538                                  					; SS override
 11539 00001852 36A2[6B05]              	MOV	[SS:ATTRIB],AL		; stash away found attributes
 11540 00001856 E8D903                  	call	SFTFromFCB
 11541 00001859 72EB                    	JC	short GoodRet 		; MZ 16 Jan Assume death
 11542                                  
 11543                                  	; If the sharer is present, then the SFT is not regenable. Thus, 
 11544                                  	; there is no need to set the SFT's attribute.
 11545                                  
 11546                                  	;;; 9/8/86 F.C. save SFT attribute and restore it back when close is 
 11547                                  	;;; done
 11548                                  
 11549                                  	;mov	al,[es:di+4]
 11550 0000185B 268A4504                	MOV	AL,[ES:DI+SF_ENTRY.sf_attr]
 11551 0000185F 30E4                    	XOR	AH,AH
 11552 00001861 50                      	PUSH	AX
 11553                                  
 11554                                  	;;; 9/8/86 F.C. save SFT attribute and restore it back when close is 
 11555                                  	;;; done
 11556                                  
 11557 00001862 E8405B                  	call	CheckShare
 11558 00001865 7508                    	JNZ	short NoStash
 11559 00001867 36A0[6B05]              	MOV	AL,[SS:ATTRIB]
 11560                                  	;mov	[es:di+4],al
 11561 0000186B 26884504                	MOV	[ES:DI+SF_ENTRY.sf_attr],AL ; attempted attribute for close
 11562                                  NoStash:
 11563                                  	;mov	ax,[si+14h]
 11564 0000186F 8B4414                  	MOV	AX,[SI+SYS_FCB.FDATE] ; move in the time and date
 11565                                  	;mov	[es:di+0Fh],ax
 11566 00001872 2689450F                	MOV	[ES:DI+SF_ENTRY.sf_date],AX
 11567                                  	;mov	ax,[si+16h]
 11568 00001876 8B4416                  	MOV	AX,[SI+SYS_FCB.FTIME]
 11569                                  	;mov	[es:di+0Dh],ax
 11570 00001879 2689450D                	MOV	[ES:DI+SF_ENTRY.sf_time],AX
 11571                                  	;mov	ax,[si+10h]
 11572 0000187D 8B4410                  	MOV	AX,[SI+SYS_FCB.FILSIZ]
 11573                                  	;mov	[es:di+11h],ax
 11574 00001880 26894511                	MOV	[ES:DI+SF_ENTRY.sf_size],AX
 11575                                  	;mov	ax,[si+12h]
 11576 00001884 8B4412                  	MOV	AX,[SI+SYS_FCB.FILSIZ+2]
 11577                                  	;mov	[es:di+13h],ax
 11578 00001887 26894513                	MOV	[ES:DI+SF_ENTRY.sf_size+2],AX
 11579                                  	;or	word [es:di+5],4000h
 11580                                  	; 17/12/2022
 11581 0000188B 26804D0640              	or	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_close_nodate>>8) ; 40h
 11582                                  	;OR	word [ES:DI+SF_ENTRY.sf_flags],sf_close_nodate
 11583 00001890 16                      	push	ss
 11584 00001891 1F                      	pop	ds
 11585 00001892 E80517                  	call	DOS_CLOSE	; wham
 11586 00001895 C43E[9E05]              	LES	DI,[THISSFT]
 11587                                  
 11588                                  	;;; 9/8/86 F.C. restore SFT attribute
 11589 00001899 59                      	POP	CX
 11590                                  	;mov	[es:di+4],cl
 11591 0000189A 26884D04                	MOV	[ES:DI+SF_ENTRY.sf_attr],CL
 11592                                  	;;; 9/8/86 F.C. restore SFT attribute
 11593                                  
 11594 0000189E 9C                      	PUSHF
 11595                                  	;test	word [es:di],0FFFFh
 11596                                  	;cmp	word [ES:DI+SF_ENTRY.sf_ref_count],0
 11597                                  				; zero ref count gets blasted
 11598 0000189F 26833D00                	cmp	word [ES:DI],0
 11599 000018A3 7507                    	jnz     short CloseOK
 11600 000018A5 50                      	PUSH	AX
 11601 000018A6 B04D                    	MOV	AL,'M'
 11602 000018A8 E8FC02                  	call	BlastSFT
 11603 000018AB 58                      	POP	AX
 11604                                  CloseOK:
 11605 000018AC 9D                      	POPF
 11606 000018AD 7397                    	JNC	short GoodRet
 11607                                  	;cmp	al,6
 11608 000018AF 3C06                    	CMP	AL,error_invalid_handle
 11609 000018B1 7493                    	JZ	short GoodRet
 11610                                  	;mov	al,2
 11611 000018B3 B002                    	MOV	AL,error_file_not_found
 11612                                  fren90:
 11613                                  	; 16/12/2022
 11614                                  fcb_close_err:
 11615 000018B5 E9B1ED                  	jmp	FCB_RET_ERR
 11616                                  
 11617                                  ;
 11618                                  ;----------------------------------------------------------------------------
 11619                                  ;
 11620                                  ;**	$FCB_Rename - Rename a File
 11621                                  ;
 11622                                  ;	$FCB_Rename - rename a file in place within a directory. Renames
 11623                                  ;	multiple files copying from the meta characters.
 11624                                  ;
 11625                                  ;	ENTRY	DS:DX point to an FCB. The normal name field is the source
 11626                                  ;		    name of the files to be renamed. Starting at offset 11h
 11627                                  ;		    in the FCB is the destination name.
 11628                                  ;	EXIT	AL = 0 -> no error occurred and all files were renamed
 11629                                  ;		AL = FF -> some files may have been renamed but:
 11630                                  ;			rename to existing file or source file not found
 11631                                  ;	USES	ALL
 11632                                  ;
 11633                                  ;----------------------------------------------------------------------------
 11634                                  ;
 11635                                  	; 08/11/2022 Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 11636                                  
 11637                                  _$FCB_RENAME:		; System call 23
 11638                                  
 11639 000018B8 E80904                  	call	GetExtended		; get pointer to real FCB
 11640 000018BB 52                      	push	dx
 11641 000018BC 8A04                    	MOV	AL,[SI] 		; get drive byte
 11642 000018BE 83C610                  	ADD	SI,10h			; point to destination
 11643                                  
 11644                                  					; RenBuf is in DOSDATA
 11645 000018C1 BF[3E04]                	MOV	DI,RENBUF		; point to destination buffer
 11646 000018C4 FF34                    	push	word [SI]
 11647 000018C6 1E                      	push	ds
 11648 000018C7 57                      	push	di			; save source pointer for TransFCB
 11649 000018C8 8804                    	MOV	[SI],AL			; drop in real drive
 11650 000018CA 89F2                    	MOV	DX,SI			; let TransFCB know where the FCB is
 11651 000018CC E8AA52                  	call	TransFCB		; munch this pathname
 11652 000018CF 5E                      	pop	si
 11653 000018D0 1F                      	pop	ds	
 11654 000018D1 8F04                    	pop	WORD [SI]		; get path back
 11655 000018D3 5A                      	pop	dx			; Original FCB pointer
 11656 000018D4 72DF                    	JC	short fren90		; bad path -> error
 11657                                  
 11658                                  					; SS override for WFP_Start & Ren_WFP
 11659 000018D6 368B36[B205]            	MOV	SI,[ss:WFP_START]	; get pointer
 11660 000018DB 368936[B405]            	MOV	[ss:REN_WFP],SI		; stash it
 11661                                  
 11662                                  					; OpenBuf is in DOSDATA
 11663 000018E0 BF[BE03]                	MOV	DI,OPENBUF		; appropriate spot
 11664 000018E3 E89352                  	call	TransFCB		; wham
 11665                                  					; NOTE that this call is pointing
 11666                                  					;  back to the ORIGINAL FCB so
 11667                                  					;  SATTRIB gets set correctly
 11668 000018E6 72CD                    	JC	short fren90		; error
 11669 000018E8 E8840E                  	call	DOS_RENAME
 11670 000018EB 72C8                    	JC	short fren90
 11671                                  	; 16/12/2022
 11672 000018ED E976ED                  	jmp	FCB_RET_OK
 11673                                  	
 11674                                  ;	Error -
 11675                                  ;
 11676                                  ;	(al) = error code
 11677                                  
 11678                                  	; 16/12/2022
 11679                                  ;fren90:	
 11680                                  ;	;jmp	FCB_RET_ERR
 11681                                  ;	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 11682                                  ;	jmp	short fcb_close_err
 11683                                  
 11684                                  ;Break <Misbehavior fixers>
 11685                                  ;
 11686                                  ;   FCBs suffer from several problems. First, they are maintained in the
 11687                                  ;   user's space so he may move them at will. Second, they have a small
 11688                                  ;   reserved area that may be used for system information. Third, there was
 11689                                  ;   never any "rules for behavior" for FCBs; there was no protocol for their
 11690                                  ;   usage.
 11691                                  ;
 11692                                  ;   This results in the following misbehavior:
 11693                                  ;
 11694                                  ;	infinite opens of the same file:
 11695                                  ;
 11696                                  ;	While (TRUE) {			While (TRUE) {
 11697                                  ;	    FCBOpen (FCB);		    FCBOpen (FCB);
 11698                                  ;	    Read (FCB); 		    Write (FCB);
 11699                                  ;	    }				    }
 11700                                  ;
 11701                                  ;	infinite opens of different files:
 11702                                  ;
 11703                                  ;	While (TRUE) {			While (TRUE) {
 11704                                  ;	    FCBOpen (FCB[i++]); 	    FCBOpen (FCB[i++]);
 11705                                  ;	    Read (FCB); 		    Write (FCB);
 11706                                  ;	    }				    }
 11707                                  ;
 11708                                  ;	multiple closes of the same file:
 11709                                  ;
 11710                                  ;	FCBOpen (FCB);
 11711                                  ;	while (TRUE)
 11712                                  ;	    FCBClose (FCB);
 11713                                  ;
 11714                                  ;	I/O after closing file:
 11715                                  ;
 11716                                  ;	FCBOpen (FCB);
 11717                                  ;	while (TRUE) {
 11718                                  ;	    FCBWrite (FCB);
 11719                                  ;	    FCBClose (FCB);
 11720                                  ;	    }
 11721                                  ;
 11722                                  ;   The following is am implementation of a methodology for emulating the
 11723                                  ;   above with the exception of I/O after close. We are NOT attempting to
 11724                                  ;   resolve that particular misbehavior. We will enforce correct behaviour in
 11725                                  ;   FCBs when they refer to a network file or when there is file sharing on
 11726                                  ;   the local machine.
 11727                                  ;
 11728                                  ;   The reserved fields of the FCB (10 bytes worth) is divided up into various
 11729                                  ;   structures depending on the file itself and the state of operations of the
 11730                                  ;   OS. The information contained in this reserved field is enough to
 11731                                  ;   regenerate the SFT for the local non-shared file. It is assumed that this
 11732                                  ;   regeneration procedure may be expensive. The SFT for the FCB is
 11733                                  ;   maintained in a LRU cache as the ONLY performance inprovement.
 11734                                  ;
 11735                                  ;   No regeneration of SFTs is attempted for network FCBs.
 11736                                  ;
 11737                                  ;   To regenerate the SFT for a local FCB, it is necessary to determine if the
 11738                                  ;   file sharer is working. If the file sharer is present then the SFT is not
 11739                                  ;   regenerated.
 11740                                  ;
 11741                                  ;   Finally, if there is no local sharing, the full name of the file is no
 11742                                  ;   longer available. We can make up for this by using the following
 11743                                  ;   information:
 11744                                  ;
 11745                                  ;	The Drive number (from the DPB).
 11746                                  ;	The physical sector of the directory that contains the entry.
 11747                                  ;	The relative position of the entry in the sector.
 11748                                  ;	The first cluster field.
 11749                                  ;	The last used SFT.
 11750                                  ;      OR In the case of a device FCB
 11751                                  ;	The low 6 bits of sf_flags (indicating device type)
 11752                                  ;	The pointer to the device header
 11753                                  ;
 11754                                  ;   We read in the particular directory sector and examine the indicated
 11755                                  ;   directory entry. If it matches, then we are kosher; otherwise, we fail.
 11756                                  ;
 11757                                  ;   Some key items need to be remembered:
 11758                                  ;
 11759                                  ;	Even though we are caching SFTs, they may contain useful sharing
 11760                                  ;	information. We enforce good behavior on the FCBs.
 11761                                  ;
 11762                                  ;	Network support must not treat FCBs as impacting the ref counts on
 11763                                  ;	open VCs. The VCs may be closed only at process termination.
 11764                                  ;
 11765                                  ;	If this is not an installed version of the DOS, file sharing will
 11766                                  ;	always be present.
 11767                                  ;
 11768                                  ;	We MUST always initialize lstclus to = firclus when regenerating a
 11769                                  ;	file. Otherwise we start allocating clusters up the wazoo.
 11770                                  ;
 11771                                  ;	Always initialize, during regeneration, the mode field to both isFCB
 11772                                  ;	and open_for_both. This is so the FCB code in the sharer can find the
 11773                                  ;	proper OI record.
 11774                                  ;
 11775                                  ;   The test bits are:
 11776                                  ;
 11777                                  ;	00 -> local file
 11778                                  ;	40 -> sharing local
 11779                                  ;	80 -> network
 11780                                  ;	C0 -> local device
 11781                                  
 11782                                  ;Break	<SaveFCBInfo - store pertinent information from an SFT into the FCB>
 11783                                  ;----------------------------------------------------------------------------
 11784                                  ;
 11785                                  ;   SaveFCBInfo - given an FCB and its associated SFT, copy the relevant
 11786                                  ;	pieces of information into the FCB to allow for subsequent
 11787                                  ;	regeneration. Poke LRU also.
 11788                                  ;
 11789                                  ;   Inputs:	ThisSFT points to a complete SFT.
 11790                                  ;		DS:SI point to the FCB (not an extended one)
 11791                                  ;   Outputs:	The relevant reserved fields in the FCB are filled in.
 11792                                  ;		DS:SI preserved
 11793                                  ;		ES:DI point to sft
 11794                                  ;   Registers modified: All
 11795                                  ;
 11796                                  ;
 11797                                  ;----------------------------------------------------------------------------
 11798                                  ;
 11799                                  
 11800                                  	; 08/11/2022 Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 11801                                  
 11802                                  SaveFCBInfo:
 11803                                  
 11804 000018F0 36C43E[9E05]            	LES	DI,[SS:THISSFT]		; SS override
 11805 000018F5 E8B4F9                  	call	IsSFTNet
 11806 000018F8 740B                    	JZ	short SaveLocal		; if not network then save local info
 11807                                  ;
 11808                                  ;----- In net support -----
 11809                                  ;
 11810                                  	; 17/05/2019 - Retro DOS v4.0
 11811                                  
 11812                                  	; MSDOS 3.3
 11813                                  	;;mov	ax,[es:di+1Dh]
 11814                                  	;mov	ax,[es:di+SF_ENTRY.sf_dirsec]
 11815                                  	;;mov	[si+1Ah],ax
 11816                                  	;mov	[si+fcb_net_handle],ax
 11817                                  	;push	es
 11818                                  	;push	di
 11819                                  	;;les	di,[es:di+19h]
 11820                                  	;LES	DI,[ES:DI+sf_netid]
 11821                                  	;;mov	[si+1Ch],di
 11822                                  	;MOV	[SI+fcb_netID],DI	; save net ID
 11823                                  	;;mov 	[si+1Eh],es
 11824                                  	;MOV	[SI+fcb_netID+2],ES
 11825                                  	;pop	di
 11826                                  	;pop	es
 11827                                  
 11828                                  	; MSDOS 6.0
 11829                                  	;mov	ax,[es:di+0Bh]
 11830 000018FA 268B450B                	MOV	AX,[ES:DI+sf_serial_ID] ;AN000;;IFS. save IFS ID
 11831                                  	;mov	[si+1Ch],ax
 11832 000018FE 89441C                  	MOV	[SI+fcb_netID],ax	;AN000;;IFS.
 11833                                  	
 11834                                  	;mov	bl,80h
 11835 00001901 B380                    	MOV	BL,FCBNETWORK
 11836                                  ;
 11837                                  ;----- END In net support -----
 11838                                  ;
 11839 00001903 EB65                    	jmp	SHORT SaveSFN
 11840                                  
 11841                                  SaveLocal:
 11842                                  	;IF	Installed
 11843 00001905 E89D5A                  	call	CheckShare
 11844                                  	;JZ	short SaveNoShare	; no sharer
 11845                                  	;JMP	short SaveShare		; sharer present
 11846                                  	; 16/12/2022
 11847                                  	; 28/07/2019
 11848 00001908 755B                    	jnz	short SaveShare
 11849                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 11850                                  	;JZ	short SaveNoShare	; no sharer
 11851                                  	;JMP	short SaveShare		; sharer present
 11852                                  
 11853                                  SaveNoShare:
 11854                                  	;;test 	word [es:di+5],80h
 11855                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
 11856 0000190A 26F6450580              	test	byte [ES:DI+SF_ENTRY.sf_flags],devid_device ; 80h	
 11857 0000190F 7542                    	JNZ	short SaveNoShareDev	; Device
 11858                                  
 11859                                  	; Save no sharing local file information
 11860                                  
 11861                                  	;;mov	ax,[es:di+1Dh]  ; MSDOS 3.3
 11862                                  	;mov	ax,[es:di+1Bh]  ; MSDOS 6.0
 11863 00001911 268B451B                	MOV	AX,[ES:DI+SF_ENTRY.sf_dirsec] ; get directory sector F.C.
 11864                                  	;mov	[si+1Dh],ax
 11865 00001915 89441D                  	MOV	[SI+fcb_nsl_dirsec],AX
 11866                                  
 11867                                  	; MSDOS 6.0
 11868                                  
 11869                                  	;SR; Store high byte of directory sector
 11870                                  	;mov	ax,[es:di+1Dh]
 11871 00001918 268B451D                	mov	ax,[es:di+SF_ENTRY.sf_dirsec+2] ; get high word
 11872                                  	
 11873                                  	; SR;
 11874                                  	; We have to store the read-only and archive attributes of the file.
 11875                                  	; We extract it from the SFT and store it in the top two bits of the 
 11876                                  	; sector number ( sector number == 22 bits only )
 11877                                  
 11878                                  	;mov	bl,[es:di+4]
 11879 0000191C 268A5D04                	mov	bl,[es:di+SF_ENTRY.sf_attr]
 11880 00001920 88DF                    	mov	bh,bl
 11881 00001922 D0CB                    	ror	bl,1
 11882 00001924 D0E7                    	shl	bh,1
 11883 00001926 08FB                    	or	bl,bh
 11884 00001928 80E3C0                  	and	bl,0C0h
 11885 0000192B 08D8                    	or	al,bl
 11886                                  	;mov	[si+18h],al ; 08/11/2022
 11887 0000192D 884418                  	mov	[si+fcb_sfn],al	; sector number = 22 bits
 11888                                  
 11889                                  	; MSDOS 6.0 (& MSDOS 3.3)
 11890                                  	;mov	al,[es:di+1Fh]
 11891 00001930 268A451F                	MOV	AL,[ES:DI+SF_ENTRY.sf_dirpos] ; location in sector
 11892                                  	;mov	[si+1Fh],al
 11893 00001934 88441F                  	MOV	[SI+fcb_nsl_dirpos],AL
 11894                                  	;mov	ax,[es:di+0Bh]
 11895 00001937 268B450B                	MOV	AX,[ES:DI+SF_ENTRY.sf_firclus] ; first cluster
 11896                                  	;mov	[si+1Bh],ax
 11897 0000193B 89441B                  	MOV	[SI+fcb_nsl_firclus],AX
 11898 0000193E B300                    	MOV	BL,0
 11899                                  
 11900                                  	; Create the bits field from the dirty/device bits of the flags word 
 11901                                  	; and the mode byte
 11902                                  
 11903                                  SetFCBBits:
 11904                                  	;mov	ax,[es:di+5]
 11905 00001940 268B4505                	MOV	AX,[ES:DI+SF_ENTRY.sf_flags]
 11906 00001944 24C0                    	AND	AL,0C0h 		; mask off drive bits
 11907                                  	;or	al,[es:di+2]
 11908 00001946 260A4502                	OR	AL,[ES:DI+SF_ENTRY.sf_mode] ; stick in open mode
 11909                                  	;mov	[si+1Ah], al
 11910 0000194A 88441A                  	MOV	[SI+fcb_nsl_bits],AL	; save dirty info
 11911                                  
 11912                                  	; MSDOS 6.0
 11913                                  	
 11914                                  	; SR;
 11915                                  	; Check if we came here for local file or device. If for local file, 
 11916                                  	; skip setting of SFT index
 11917                                  	
 11918 0000194D 08DB                    	or	bl,bl
 11919 0000194F 742A                    	jz	short SaveNoSFN		; do not save SFN if local file
 11920                                  
 11921 00001951 EB17                    	JMP	short SaveSFN 		; go and save SFN
 11922                                  
 11923                                  	; Save no sharing local device information
 11924                                  
 11925                                  SaveNoShareDev:
 11926                                  	;mov	ax,[es:di+7]
 11927 00001953 268B4507                	MOV	AX,[ES:DI+SF_ENTRY.sf_devptr]
 11928                                  	;mov	[si+1Ah],ax
 11929 00001957 89441A                  	MOV	[SI+fcb_nsld_drvptr],AX
 11930                                  	;mov	ax,[es:di+9]
 11931 0000195A 268B4509                	MOV	AX,[ES:DI+SF_ENTRY.sf_devptr+2]
 11932 0000195E 89441C                  	MOV	[SI+fcb_nsld_drvptr+2],AX
 11933                                  	;mov	bl,40h
 11934 00001961 B340                    	MOV	BL,FCBDEVICE
 11935                                  	; 28/12/2022
 11936 00001963 EBDB                    	JMP	short SetFCBBits	; go and save SFN
 11937                                  
 11938                                  SaveShare:
 11939                                  	;ENDIF
 11940                                  
 11941                                  ;----- In share support -----
 11942                                  
 11943                                  	;call	far [ss:ShSave]
 11944 00001965 36FF1E[B800]            	Call	far [ss:JShare+(10*4)] ; 10 = ShSave ; SS Override
 11945                                  
 11946                                  ;----- end in share support -----
 11947                                  
 11948                                  	; 17/05/2019
 11949                                  
 11950                                  SaveSFN:
 11951                                  	;lea	ax,[di-6]
 11952 0000196A 8D45FA                  	LEA	AX,[DI-SFT.SFTable]
 11953                                  	
 11954                                  	; Adjust for offset to table.
 11955                                  	
 11956 0000196D 362B06[4000]            	SUB	AX,[SS:SFTFCB]		; SS override for SftFCB
 11957                                  
 11958 00001972 53                      	push	bx			;bx = FCB type (net/Share or local)
 11959                                  	;;mov	bl,53 ; MSDOS 3.3
 11960                                  	;mov	bl,59 ; MSDOS 6.0
 11961 00001973 B33B                    	MOV	BL,SF_ENTRY.size
 11962 00001975 F6F3                    	DIV	BL
 11963                                  	;mov	[si+18h],al
 11964 00001977 884418                  	MOV	[SI+fcb_sfn],AL		; last used SFN
 11965 0000197A 5B                      	pop	bx			;restore bx
 11966                                  
 11967                                  SaveNoSFN:
 11968                                  	;mov	ax,[es:di+5]
 11969 0000197B 268B4505                	MOV	AX,[ES:DI+SF_ENTRY.sf_flags]
 11970 0000197F 243F                    	AND	AL,3Fh			; get real drive
 11971 00001981 08D8                    	OR	AL,BL
 11972                                  	;mov	[si+19h],al
 11973 00001983 884419                  	MOV	[SI+fcb_l_drive],AL
 11974                                  
 11975 00001986 36A1[1000]              	MOV	AX,[SS:FCBLRU]		; get lru count
 11976 0000198A 40                      	INC	AX
 11977                                  	;mov	[es:di+15h],ax
 11978 0000198B 26894515                	MOV	[ES:DI+sf_LRU],AX
 11979 0000198F 7506                    	JNZ	short SimpleStuff
 11980                                  	
 11981                                  	; lru flag overflowed. Run through all FCB sfts and adjust:  
 11982                                  	; LRU < 8000H get set to 0. Others -= 8000h. This LRU = 8000h
 11983                                  	
 11984                                  	;mov	bx,15h
 11985 00001991 BB1500                  	MOV	BX,SF_ENTRY.sf_position
 11986 00001994 E80500                  	call	ResetLRU
 11987                                  
 11988                                  	; Set new LRU to AX
 11989                                  SimpleStuff:
 11990 00001997 36A3[1000]              	MOV	[SS:FCBLRU],AX
 11991 0000199B C3                      	retn
 11992                                  
 11993                                  ;Break	<ResetLRU - reset overflowed lru counts>
 11994                                  ;----------------------------------------------------------------------------
 11995                                  ;
 11996                                  ;   ResetLRU - during lru updates, we may wrap at 64K. We must walk the
 11997                                  ;   entire set of SFTs and subtract 8000h from their lru counts and truncate
 11998                                  ;   at 0.
 11999                                  ;
 12000                                  ;   Inputs:	BX is offset into SFT field where lru firld is kept
 12001                                  ;		ES:DI point to SFT currently being updated
 12002                                  ;   Outputs:	All FCB SFTs have their lru fields truncated
 12003                                  ;		AX has 8000h
 12004                                  ;   Registers modified: none
 12005                                  ;
 12006                                  ;----------------------------------------------------------------------------
 12007                                  ;
 12008                                  
 12009                                  	; 17/05/2019 - Retro DOS v4.0
 12010                                  ResetLRU:
 12011                                  	; ResetLRU is only called from fcbio.asm. So SS can be assumed to be 
 12012                                  	; DOSDATA
 12013                                  
 12014 0000199C B80080                  	MOV	AX,8000h
 12015 0000199F 06                      	push	es
 12016 000019A0 57                      	push	di
 12017                                  	;LES	DI,[CS:SFTFCB]		; get pointer to head
 12018 000019A1 36C43E[4000]            	LES	DI,[SS:SFTFCB] ; MSDOS 6.0
 12019                                  	;mov	cx,[es:di+4]
 12020 000019A6 268B4D04                	MOV	CX,[ES:DI+SFT.SFCount]
 12021                                  	;lea	di,[di+6]
 12022 000019AA 8D7D06                  	LEA	DI,[DI+SFT.SFTable] 	; point at table
 12023                                  ovScan:
 12024 000019AD 262901                  	SUB	[ES:DI+BX],AX		; decrement lru count
 12025 000019B0 7703                    	JA	short ovLoop
 12026 000019B2 268901                  	MOV	[ES:DI+BX],AX		; truncate at 0
 12027                                  ovLoop:
 12028                                  	;;add	di,53	; MSDOS 3.3
 12029                                  	;add	di,59	; MSDOS 6.0	
 12030 000019B5 83C73B                  	ADD	DI,SF_ENTRY.size	; advance to next
 12031 000019B8 E2F3                    	LOOP	ovScan
 12032 000019BA 5F                      	pop	di
 12033 000019BB 07                      	pop	es
 12034 000019BC 268901                  	MOV	[ES:DI+BX],AX
 12035 000019BF C3                      	retn
 12036                                  
 12037                                  ;IF  0  ; We dont need this routine any more.
 12038                                  ;
 12039                                  ;Break	<SetOpenAge - update the open age of a SFT>
 12040                                  ;----------------------------------------------------------------------------
 12041                                  ;
 12042                                  ;   SetOpenAge - In order to maintain the first N open files in the FCB cache,
 12043                                  ;   we keep the 'open age' or an LRU count based on opens. We update the
 12044                                  ;   count here and fill in the appropriate field.
 12045                                  ;
 12046                                  ;   Inputs:	ES:DI point to SFT
 12047                                  ;   Outputs:	ES:DI has the open age field filled in.
 12048                                  ;		If open age has wraparound, we will have subtracted 8000h
 12049                                  ;		    from all open ages.
 12050                                  ;   Registers modified: AX
 12051                                  ;
 12052                                  ;----------------------------------------------------------------------------
 12053                                  ;
 12054                                  ;SetOpenAge:
 12055                                  ;	; 20/07/2018 - Retro DOS v3.0
 12056                                  ;	; MSDOS 3.3 - IBMDOS.COM, Offset 2597h 
 12057                                  ;	; (& MSDOS 6.0, FCBIO.ASM)
 12058                                  ;
 12059                                  ;	; SetOpenAge is called from fcbio2.asm. SS can be assumed to be valid.
 12060                                  ;
 12061                                  ;	MOV	AX,[CS:OpenLRU]	; SS override
 12062                                  ;	INC	AX
 12063                                  ;	;mov	[es:di+17h],ax
 12064                                  ;	MOV	[ES:DI+sf_OpenAge],AX
 12065                                  ;	JNZ	short SetDone
 12066                                  ;	;mov	bx,17h
 12067                                  ;	MOV	BX,SF_ENTRY.sf_position+2 ; mov bx,sf_OpenAge
 12068                                  ;	call	ResetLRU
 12069                                  ;SetDone:
 12070                                  ;	MOV	[CS:OpenLRU],AX
 12071                                  ;	retn
 12072                                  ;
 12073                                  ;ENDIF	; SetOpenAge no longer needed
 12074                                  
 12075                                  ; 21/07/2018 - Retro DOS v3.0
 12076                                  ; LRUFCB for MSDOS 6.0 !
 12077                                  
 12078                                  ;Break	<LRUFCB - perform LRU on FCB sfts>
 12079                                  ;----------------------------------------------------------------------------
 12080                                  ;
 12081                                  ;   LRUFCB - find LRU fcb in cache. Set ThisSFT and return it. We preserve
 12082                                  ;	the first keepcount sfts if they are network sfts or if sharing is
 12083                                  ;	loaded.  If carry is set then NO BLASTING is NECESSARY.
 12084                                  ;
 12085                                  ;   Inputs:	none
 12086                                  ;   Outputs:	ES:DI point to SFT
 12087                                  ;		ThisSFT points to SFT
 12088                                  ;		SFT is zeroed
 12089                                  ;		Carry set of closes failed
 12090                                  ;   Registers modified: none
 12091                                  ;
 12092                                  ;----------------------------------------------------------------------------
 12093                                  ;
 12094                                  ; MSDOS 6.0
 12095                                  ;IF 0	; rewritten this routine
 12096                                  ;
 12097                                  ;LRUFCB: ; MSDOS 3.3 - IBMDOS.COM (1987) - Offset 25ADh
 12098                                  ;	call	save_world
 12099                                  ;	
 12100                                  ; Find nth oldest NET/SHARE FCB. We want to find its age for the second scan
 12101                                  ; to find the lease recently used one that is younger than the open age.  We
 12102                                  ; operate be scanning the list n times finding the least age that is greater
 12103                                  ; or equal to the previous minimum age.
 12104                                  ;
 12105                                  ;   BP is the count of times we need to go through this loop.
 12106                                  ;   AX is the current acceptable minimum age to consider
 12107                                  ;
 12108                                  ;	mov	bp,[CS:KEEPCOUNT]	; k = keepcount;
 12109                                  ;	XOR	AX,AX			; low = 0;
 12110                                  ;
 12111                                  ; If we've scanned the table n times, then we are done.
 12112                                  ;
 12113                                  ;lru1:
 12114                                  ;	CMP	bp,0			; while (k--) {
 12115                                  ;	JZ	short lru75
 12116                                  ;	DEC	bp
 12117                                  ;
 12118                                  ; Set up for scan.
 12119                                  ;
 12120                                  ;   AX is the minimum age for consideration
 12121                                  ;   BX is the minimum age found during the scan
 12122                                  ;   SI is the position of the entry that corresponds to BX
 12123                                  ;
 12124                                  ;	MOV	BX,-1			;     min = 0xffff;
 12125                                  ;	MOV	si,BX			;     pos = 0xffff;
 12126                                  ;	LES	DI,[CS:SFTFCB]		;     for (CX=FCBCount; CX>0; CX--)
 12127                                  ;	;mov	cx,[es:di+4]
 12128                                  ;	MOV	CX,[ES:DI+SFT.SFCount]
 12129                                  ;	;lea	di,[di+6]
 12130                                  ;	LEA	DI,[DI+SFT.SFTable]
 12131                                  ;
 12132                                  ; Innermost loop.  If the current entry is free, then we are done.  Or, if the
 12133                                  ; current entry is busy (indicating a previous aborted allocation), then we
 12134                                  ; are done.  In both cases, we use the found entry.
 12135                                  ;
 12136                                  ;lru2:
 12137                                  ;	cmp	word [es:di],0
 12138                                  ;	;cmp	word [es:di+SF_ENTRY.sf_ref_count],0
 12139                                  ;	jz	short lru25
 12140                                  ;	;cmp	word [es:di],-1
 12141                                  ;	;cmp	word [es:di+SFT_ENTRY.sf_ref_count],sf_busy
 12142                                  ;	cmp	word [es:di],sf_busy
 12143                                  ;	jnz	short lru3
 12144                                  ;
 12145                                  ; The entry is usable without further scan.  Go and use it.
 12146                                  ;
 12147                                  ;lru25:
 12148                                  ;	MOV	si,DI			;	      pos = i;
 12149                                  ;	JMP	short lru11		;	      goto got;
 12150                                  ;
 12151                                  ; See if the entry is for the network or for the sharer.
 12152                                  ;
 12153                                  ;  If for the sharer or network then
 12154                                  ;	if the age < current minimum AND >= allowed minimum then
 12155                                  ;	    this entry becomes current minimum
 12156                                  ;
 12157                                  ;lru3:
 12158                                  ;	;test	word [es:di+5],8000h
 12159                                  ;	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet 
 12160                                  ;					;	  if (!net[i]
 12161                                  ;	JNZ	short lru35
 12162                                  ;if installed
 12163                                  ;	call	CheckShare		;		&& !sharing)
 12164                                  ;	JZ	short lru5		;	  else
 12165                                  ;ENDIF
 12166                                  ;
 12167                                  ; This SFT is for the net or is for the sharer. See if it less than the
 12168                                  ; current minimum.
 12169                                  ;
 12170                                  ;lru35:
 12171                                  ;	;mov	dx,[es:di+17h]
 12172                                  ;	MOV	DX,[ES:DI+sf_OpenAge]
 12173                                  ;	CMP	DX,AX			;	  if (age[i] >= low &&
 12174                                  ;	JB	short lru5
 12175                                  ;	CMP	DX,BX
 12176                                  ;	JAE	short lru5		;	      age[i] < min) {
 12177                                  ;
 12178                                  ; entry is new minimum.  Remember his age.
 12179                                  ;
 12180                                  ;	mov	bx,DX			;	      min = age[i];
 12181                                  ;	mov	si,di			;	      pos = i;
 12182                                  ;
 12183                                  ; End of loop.	gp back for more
 12184                                  ;
 12185                                  ;lru5:
 12186                                  ;	;add	di,53
 12187                                  ;	add	di,SF_ENTRY.size
 12188                                  ;	loop	lru2			;	      }
 12189                                  ;
 12190                                  ; The scan is complete. If we have successfully found a new minimum (pos != -1)
 12191                                  ; set then threshold value to this new minimum + 1. Otherwise, the scan is
 12192                                  ; complete.  Go find LRU.
 12193                                  ;
 12194                                  ;lru6:	
 12195                                  ;	cmp	si,-1			; position not -1?
 12196                                  ;	jz	short lru75		; no, done with everything
 12197                                  ;	lea	ax,[bx+1]		; set new threshold age
 12198                                  ;	jmp	short lru1		; go and loop for more
 12199                                  ;lru65:	
 12200                                  ;	stc
 12201                                  ;	jmp	short LRUDead		;	  return -1;
 12202                                  ;
 12203                                  ; Main loop is done. We have AX being the age+1 of the nth oldest sharer or
 12204                                  ; network entry. We now make a second pass through to find the LRU entry
 12205                                  ; that is local-no-share or has age >= AX
 12206                                  ;
 12207                                  ;lru75:
 12208                                  ;	mov	bx,-1			; min = 0xffff;
 12209                                  ;	mov	si,bx			; pos = 0xffff;
 12210                                  ;	LES	DI,[CS:SFTFCB]		; for (CX=FCBCount; CX>0; CX--)
 12211                                  ;	;mov	cx,[es:di+4]
 12212                                  ;	MOV	CX,[ES:DI+SFT.SFCount]
 12213                                  ;	;lea	di,[di+6]
 12214                                  ;	LEA	DI,[DI+SFT.SFTable]
 12215                                  ;
 12216                                  ; If this is is local-no-share then go check for LRU else if age >= threshold
 12217                                  ; then check for lru.
 12218                                  ;
 12219                                  ;lru8:
 12220                                  ;	;test	word [es:di+5],8000h
 12221                                  ;	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 12222                                  ;	jnz	short lru85		; is for network, go check age
 12223                                  ;	call	CheckShare		; sharer here?
 12224                                  ;	jz	short lru86		; no, go check lru
 12225                                  ;
 12226                                  ; Network or sharer.  Check age
 12227                                  ;
 12228                                  ;lru85:
 12229                                  ;	;cmp	[es:di+17h],ax
 12230                                  ;	cmp	[es:di+sf_OpenAge],ax
 12231                                  ;	jb	short lru9		; age is before threshold, skip it
 12232                                  ;
 12233                                  ; Check LRU
 12234                                  ;
 12235                                  ;lru86:
 12236                                  ;	;cmp	[es:di+15h],bx
 12237                                  ;	cmp	[es:di+sf_LRU],bx	; is LRU less than current LRU?
 12238                                  ;	jae	short lru9		; no, skip this
 12239                                  ;	mov	si,di			; remember position
 12240                                  ;	;mov	bx,[es:di+15h]
 12241                                  ;	mov	bx,[es:di+sf_LRU]	; remember new minimum LRU
 12242                                  ;
 12243                                  ; Done with this entry, go back for more.
 12244                                  ;
 12245                                  ;lru9:
 12246                                  ;	;add	di, 53
 12247                                  ;	add	di,SF_ENTRY.size
 12248                                  ;	loop	lru8
 12249                                  ;
 12250                                  ; Scan is complete. If we found NOTHING that satisfied us then we bomb
 12251                                  ; out. The conditions here are:
 12252                                  ;
 12253                                  ;  No local-no-shares AND all net/share entries are older than threshold
 12254                                  ;
 12255                                  ;lru10:
 12256                                  ;	cmp	si,-1			; if no one f
 12257                                  ;	jz	short lru65		;     return -1;
 12258                                  ;lru11:
 12259                                  ;	mov	di,si
 12260                                  ;	MOV	[CS:THISSFT],DI		; set thissft
 12261                                  ;	MOV	[CS:THISSFT+2],ES
 12262                                  ;
 12263                                  ; If we have sharing or thisSFT is a net sft, then close it until ref count
 12264                                  ; is 0.
 12265                                  ;
 12266                                  ;	;test	word [es:di+5],8000h
 12267                                  ;	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 12268                                  ;	JNZ	short LRUClose
 12269                                  ;IF INSTALLED
 12270                                  ;	call	CheckShare
 12271                                  ;	JZ	short LRUDone
 12272                                  ;ENDIF
 12273                                  ;
 12274                                  ; Repeat close until ref count is 0
 12275                                  ;
 12276                                  ;LRUClose:
 12277                                  ;	push	ss
 12278                                  ;	pop	ds
 12279                                  ;	LES	DI,[THISSFT]
 12280                                  ;	cmp     word [es:di],0
 12281                                  ;	;CMP	word [ES:DI+SFT.sf_ref_count],0 ; is ref count still <> 0?
 12282                                  ;	JZ	short LRUDone 		; nope, all done
 12283                                  ;	call	DOS_CLOSE
 12284                                  ;	jnc	short LRUClose		; no error => clean up
 12285                                  ;	;cmp	al,6
 12286                                  ;	cmp	al,error_invalid_handle
 12287                                  ;	jz	short LRUClose
 12288                                  ;	stc
 12289                                  ;	JMP	short LRUDead
 12290                                  ;LRUDone:
 12291                                  ;	XOR	AL,AL
 12292                                  ;	call	BlastSFT		; fill SFT with 0 (AL), 'C' cleared
 12293                                  ;
 12294                                  ;LRUDead:
 12295                                  ;	call	restore_world
 12296                                  ;	LES     DI,[CS:THISSFT]
 12297                                  ;	jnc	short LRUFCB_retn
 12298                                  ;LRUFCB_err:
 12299                                  ;	; mov	al, 23h	
 12300                                  ;	MOV	AL,error_FCB_unavailable
 12301                                  ;LRUFCB_retn:	
 12302                                  ;	retn:
 12303                                  ;
 12304                                  ;ENDIF	; LRUFCB has been rewritten below.
 12305                                  
 12306                                  ; 17/05/2019 - Retro DOS v4.0
 12307                                  ; LRUFCB for MSDOS 6.0 !
 12308                                  ;----------------------------------------------------------------------------
 12309                                  ;
 12310                                  ; LruFCB -- allocate the LRU SFT from the SFT Table. The LRU scheme
 12311                                  ; maintains separate counts for net/Share and local SFTs. We allocate a 
 12312                                  ; net/Share SFT only if we do not find a local SFT. This helps keep
 12313                                  ; net/Share SFTs which cannot be regenerated for as long as possible. We
 12314                                  ; optimize regeneration operations by keeping track of the current local
 12315                                  ; SFT. This avoids scanning of the SFTs as long as we have at least one 
 12316                                  ; local SFT in the SFT Block.
 12317                                  ;
 12318                                  ; Inputs: al = 0 => Regenerate SFT operation
 12319                                  ;	    = 1 => Allocate new SFT for Open/Create
 12320                                  ;
 12321                                  ; Outputs: Carry clear
 12322                                  ;	 	es:di = Address of allocated SFT
 12323                                  ;	  	ThisSFT = Address of allocated SFT
 12324                                  ;
 12325                                  ;	  carry set if closes of net/Share files failed 
 12326                                  ;		al = error_FCB_unavailable
 12327                                  ;
 12328                                  ; Registers affected: None
 12329                                  ;
 12330                                  ;----------------------------------------------------------------------------
 12331                                  
 12332                                  ;LruFCB	PROC	NEAR
 12333                                  LRUFCB:
 12334                                  	; 17/05/2019 - Retro DOS v4.0
 12335                                  	; DOSCODE:5805h (MSDOS 6.21, MSDOS.SYS)
 12336                                  
 12337                                  	; 08/11/2022 Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 12338                                  	; DOSCODE:57F1h (MSDOS 5.0, MSDOS.SYS)
 12339                                  
 12340 000019C0 06                      	push	es	; * (MSDOS 6.21)
 12341                                  	
 12342 000019C1 E8ADEA                  	call	save_world
 12343                                  	
 12344                                  	;getdseg <ds>		;ds = DOSDATA
 12345 000019C4 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 12346                                  
 12347 000019C9 08C0                    	or	al,al		;Check if regenerate allocation
 12348 000019CB 751A                    	jnz	short lru1	;Try to find SFT to use
 12349                                  
 12350                                  	; This is a regen call. If LocalSFT contains the address of a valid 
 12351                                  	; local SFT, just return that SFT to reuse
 12352                                  
 12353 000019CD 8B3E[4310]              	mov	di,[LocalSFT]
 12354 000019D1 0B3E[4510]              	or	di,[LocalSFT+2]	;is address == 0?
 12355 000019D5 7410                    	jz	short lru1	;invalid local SFT, find one
 12356                                  
 12357                                  	; We have found a valid local SFT. Recycle this SFT
 12358                                  
 12359 000019D7 C43E[4310]              	les	di,[LocalSFT]
 12360                                  
 12361                                  gotlocalSFT:
 12362 000019DB 893E[9E05]              	mov	[THISSFT],di
 12363 000019DF 8C06[A005]              	mov	[THISSFT+2],es
 12364 000019E3 F8                      	clc
 12365 000019E4 E9AD00                  	jmp	LRUDone		;clear up SFT and return
 12366                                  
 12367                                  lru1:
 12368 000019E7 C43E[4000]              	les	di,[SFTFCB]	;es:di = SF Table for FCBs
 12369                                  	;mov	cx,[es:di+4]
 12370 000019EB 268B4D04                	mov	cx,[es:di+SFT.SFCount]	;cx = number of SFTs
 12371                                  	;lea	di,[di+6]
 12372 000019EF 8D7D06                  	lea	di,[di+SFT.SFTable]	;es:di = first SFT
 12373                                  
 12374                                  	; We scan through all the SFTs scanning for a free one. It also 
 12375                                  	; remembers the LRU SFT for net/Share SFTs and local SFTs separately. 
 12376                                  	; bx = min. LRU for local SFTs
 12377                                  	; si = pos. of local SFT with min. LRU
 12378                                  	; dx = min. LRU for net/Share SFTs
 12379                                  	; bp = pos. of net/Share SFT with min. LRU
 12380                                  
 12381 000019F2 BBFFFF                  	mov	bx,-1		; init. to 0xffff ( max. LRU value )
 12382 000019F5 89DE                    	mov	si,bx
 12383 000019F7 89DA                    	mov	dx,bx
 12384 000019F9 89DD                    	mov	bp,bx
 12385                                  
 12386                                  findSFT:
 12387                                  	;See if this SFT is a free one. If so, return it
 12388 000019FB 26830D00                	or	word [es:di],0
 12389                                  	;or	word [es:di+SF_ENTRY.sf_ref_count],0 ;reference count = 0 ?
 12390 000019FF 744D                    	jz	short gotSFT	;yes, SFT is free
 12391                                  	;;cmp	word [es:di],-1
 12392                                  	;cmp	word [es:di+SF_ENTRY.sf_ref_count],sf_busy ;Is it busy?
 12393 00001A01 26833DFF                	cmp	word [es:di],sf_busy ; -1 
 12394 00001A05 7447                    	jz	short gotSFT	;no, can use it
 12395                                  
 12396                                  	; Check if this SFT is local and store its address in LocalSFT. Can be 
 12397                                  	; used for a later regen.
 12398                                  
 12399                                  	; 16/12/2022
 12400                                  	; 08/11/2022
 12401                                  	;test	byte [es:di+6],80h
 12402 00001A07 26F6450680              	test	byte [es:di+SF_ENTRY.sf_flags+1],(sf_isnet>>8) ; 80h
 12403                                  	; 08/11/2022 Retro DOS v4.0 (MSDOS 5.0 MSDOS.SYS compatibility)
 12404                                  	;;test	word [es:di+5],8000h
 12405                                  	;test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet ; network SFT?
 12406 00001A0C 7532                    	jnz	short lru5	;yes, get net/Share LRU
 12407                                  
 12408                                  ;IF installed
 12409 00001A0E E89459                  	call	CheckShare	;Share present?
 12410                                  ;ENDIF
 12411 00001A11 752D                    	jnz	short lru5	;yes, get net/Share LRU
 12412                                  
 12413                                  	;Local SFT, register its address
 12414                                  
 12415                                  	; !!HACK!!!
 12416                                  	; There is a slightly dirty hack out here in a desperate bid to save  
 12417                                  	; code space. There is similar code duplicated at label 'gotSFT'. We 
 12418                                  	; enter from there if al = 0, update the LocalSFT variable, and since 
 12419                                  	; al = 0, we jump out of the loop to the exit point. I have commented 
 12420                                  	; out the code that previously existed at label 'gotSFT'
 12421                                  
 12422                                  hackpoint:
 12423 00001A13 893E[4310]              	mov	[LocalSFT],di
 12424 00001A17 8C06[4510]              	mov	[LocalSFT+2],es	;store local SFT address
 12425                                  
 12426 00001A1B 08C0                    	or	al,al		;Is operation = REGEN?
 12427 00001A1D 74BC                    	jz	short gotlocalSFT ;yes, return this SFT for reuse
 12428                                  
 12429                                  	;Get LRU for local files
 12430                                  	
 12431                                  	;cmp	[es:di+15h],bx
 12432 00001A1F 26395D15                	cmp	[es:di+sf_LRU],bx ;SFT.LRU < min?
 12433 00001A23 7306                    	jae	short lru4	;no, skip 
 12434                                  
 12435                                  	;mov	bx,[es:di+15h]
 12436 00001A25 268B5D15                	mov	bx,[es:di+sf_LRU] ;yes, store new minimum
 12437 00001A29 89FE                    	mov	si,di		;store SFT position
 12438                                  lru4:
 12439                                  	;add	di,59
 12440 00001A2B 83C73B                  	add	di,SF_ENTRY.size ;go to next SFT
 12441 00001A2E E2CB                    	loop	findSFT
 12442                                  
 12443                                  	; Check whether we got a net/Share or local SFT. If local SFT 
 12444                                  	; available, we will reuse it instead of net/Share LRU
 12445                                  
 12446 00001A30 89F7                    	mov	di,si
 12447 00001A32 83FEFF                  	cmp	si,-1		;local SFT available?
 12448 00001A35 7517                    	jnz	short gotSFT	;yes, return it
 12449                                  
 12450                                  	;No local SFT, see if we got a net/Share SFT
 12451                                  
 12452 00001A37 89EF                    	mov	di,bp
 12453 00001A39 83FDFF                  	cmp	bp,-1		;net/Share SFT available?
 12454 00001A3C 7530                    	jnz	short gotnetSFT	;yes, return it
 12455                                  noSFT:
 12456                                  	; NB: This error should never occur. We always must have an LRU SFT. 
 12457                                  	; This error can occur only if the SFT has been corrupted or the LRU 
 12458                                  	; count is not maintained properly.
 12459                                  
 12460 00001A3E EB51                    	jmp	short errorbadSFT ;error, no FCB available.
 12461                                  
 12462                                  	; Handle the LRU for net/Share SFTs
 12463                                  lru5:
 12464                                  	;cmp	[es:di+15h],dx
 12465 00001A40 26395515                	cmp	[es:di+sf_LRU],dx ;SFT.LRU < min?
 12466 00001A44 73E5                    	jae	short lru4	;no, skip 
 12467                                  
 12468                                  	;mov	dx,[es:di+15h]
 12469 00001A46 268B5515                	mov	dx,[es:di+sf_LRU] ;yes, store new minimum
 12470                                  
 12471 00001A4A 89FD                    	mov	bp,di		;store SFT position
 12472 00001A4C EBDD                    	jmp	short lru4	;continue with next SFT
 12473                                  
 12474                                  gotSFT:
 12475 00001A4E 08C0                    	or	al,al
 12476 00001A50 74C1                    	jz	short hackpoint	;save es:di in LocalSFT
 12477                                  
 12478                                  	; HACK!!!
 12479                                  	; The code here differs from the code at 'hackpoint' only in the 
 12480                                  	; order of the check for al. If al = 0, we can jump to 'hackpoint' 
 12481                                  	; and then from there jump out to 'gotlocalSFT'. The original code 
 12482                                  	; has been commented out below and replaced by the code just above.
 12483                                  
 12484                                  ;If regen, then this SFT can be registered as a local one ( even if free ).
 12485                                  ;
 12486                                  ;	or	al,al		  ;Regen?
 12487                                  ;	jnz	short notlocaluse ;yes, register it and return
 12488                                  ;
 12489                                  ;Register this SFT as a local one
 12490                                  ;
 12491                                  ;	mov	[LocalSFT],di
 12492                                  ;	mov	[LocalSFT+2],es
 12493                                  ;	jmp	gotlocalSFT	;return to caller
 12494                                  ;
 12495                                  ;notlocaluse:
 12496                                  
 12497                                  	; The caller is probably going to use this SFT for a net/Share file. 
 12498                                  	; We will come here only on a Open/Create when the caller($FCB_OPEN) 
 12499                                  	; does not really know whether it is a local file or not. We 
 12500                                  	; invalidate LocalSFT if the SFT we are going to use was previously 
 12501                                  	; registered as a local SFT that can be recycled.
 12502                                  
 12503 00001A52 8CC0                    	mov	ax,es
 12504 00001A54 393E[4310]              	cmp	[LocalSFT],di		;Offset same?
 12505 00001A58 7506                    	jne	short notinvalid
 12506 00001A5A 3906[4510]              	cmp	[LocalSFT+2],ax		;Segments same?
 12507 00001A5E 7403                    	je	short zerolocalSFT	;no, no need to invalidate
 12508                                  notinvalid:
 12509 00001A60 E978FF                  	jmp	gotlocalSFT
 12510                                  
 12511                                  	; The SFT we are going to use was registered in the LocalSFT variable. 
 12512                                  	; Invalidate this variable i.e LocalSFT = NULL
 12513                                  
 12514                                  zerolocalSFT:
 12515 00001A63 31C0                    	xor	ax,ax ; 0
 12516 00001A65 A3[4310]                	mov	[LocalSFT],ax
 12517 00001A68 A3[4510]                	mov	[LocalSFT+2],ax
 12518                                  
 12519 00001A6B E96DFF                  	jmp	gotlocalSFT
 12520                                  
 12521                                  gotnetSFT:
 12522                                  	; We have an SFT that is currently net/Share. If it is going to be 
 12523                                  	; used for a regen, we know it has to be a local SFT. Update the 
 12524                                  	; LocalSFT variable
 12525                                  
 12526 00001A6E 08C0                    	or	al,al
 12527 00001A70 7508                    	jnz	short closenet
 12528                                  
 12529 00001A72 893E[4310]              	mov	[LocalSFT],di
 12530 00001A76 8C06[4510]              	mov	[LocalSFT+2],es	;store local SFT address
 12531                                  closenet:
 12532 00001A7A 893E[9E05]              	mov	[THISSFT],di	; set thissft
 12533 00001A7E 8C06[A005]              	mov	[THISSFT+2],es	
 12534                                  
 12535                                  	; If we have sharing or thisSFT is a net sft, then close it until ref 
 12536                                  	; count is 0.
 12537                                  	; NB: We come here only if it is a net/Share SFT that is going to be 
 12538                                  	; recycled -- no need to check for this.
 12539                                  
 12540                                  LRUClose:
 12541 00001A82 26833D00                	cmp	word [es:di],0
 12542                                  	;cmp	word [es:di+SF_ENTRY.sf_ref_count],0 ; is ref count still <> 0?
 12543 00001A86 740C                    	jz	short LRUDone	; nope, all done
 12544                                  
 12545 00001A88 E80F15                  	call	DOS_CLOSE
 12546 00001A8B 73F5                    	jnc	short LRUClose	; no error => clean up
 12547                                  
 12548                                  	; Bugbug: I dont know why we are trying to close after we get an 
 12549                                  	; error closing. Seems like we could have a potential infinite loop  
 12550                                  	; here. This has to be verified.
 12551                                  
 12552 00001A8D 3C06                    	cmp	al,error_invalid_handle ; 6
 12553 00001A8F 74F1                    	je	short LRUClose
 12554                                  errorbadSFT:
 12555 00001A91 F9                      	stc
 12556 00001A92 EB05                    	JMP	short LRUDead
 12557                                  LRUDone:
 12558 00001A94 30C0                    	XOR	AL,AL
 12559 00001A96 E80E01                  	call	BlastSFT		; fill SFT with 0 (AL), 'C' cleared
 12560                                  
 12561                                  LRUDead:
 12562 00001A99 E8BEE9                  	call	restore_world		; use macro
 12563                                  	
 12564 00001A9C 07                      	pop	es ; * (MSDOS 6.21)
 12565                                  
 12566                                  	;getdseg <es>
 12567 00001A9D 2E8E06[0700]            	mov	es,[cs:DosDSeg]
 12568 00001AA2 26C43E[9E05]            	les	di,[es:THISSFT]		;es:di points at allocated SFT
 12569                                  
 12570                                  	;;retnc
 12571                                  	;jc	short LruFCB_err
 12572                                  	;retn
 12573                                  
 12574                                  	; 16/12/2022
 12575                                  	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 12576 00001AA7 7302                    	jnc	short LruFCB_retn
 12577                                  	;jc	short LruFCB_err
 12578                                  	;retn
 12579                                  		
 12580                                  LruFCB_err:
 12581 00001AA9 B023                    	MOV	AL,error_FCB_unavailable ; 23h
 12582                                  LruFCB_retn:
 12583 00001AAB C3                      	retn
 12584                                  	
 12585                                  ;LruFCB	ENDP
 12586                                  
 12587                                  ; 17/05/2019 - Retro DOS v4.0
 12588                                  
 12589                                  ; DOSCODE:58F3h (MSDOS 6.21, MSDOS.SYS)
 12590                                  
 12591                                  ; --------------------------------------------------------------------------
 12592                                  ;**** RegenCopyName -- This function copies the filename from the FCB to
 12593                                  ; SFT and also to DOS local buffers. There was duplicate code in FCBRegen
 12594                                  ; to copy the name to different destinations
 12595                                  ;
 12596                                  ; Inputs: ds:si = source string
 12597                                  ;	 es:di = destination string
 12598                                  ;	 cx = length of string
 12599                                  ;
 12600                                  ; Outputs: String copied to destination
 12601                                  ;
 12602                                  ; Registers affected: cx,di,si
 12603                                  ; --------------------------------------------------------------------------
 12604                                  
 12605                                  RegenCopyName:
 12606                                  CopyName:
 12607 00001AAC AC                      	lodsb			;load character
 12608 00001AAD E8FC35                  	call	UCase		; convert char to upper case
 12609                                  StuffChar2:
 12610 00001AB0 AA                      	STOSB			;store converted character
 12611 00001AB1 E2F9                    	LOOP	CopyName	;
 12612                                  DoneName:
 12613 00001AB3 C3                      	retn
 12614                                  
 12615                                  ; --------------------------------------------------------------------------
 12616                                  
 12617                                  	; 09/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 12618                                  FCBRegen:
 12619                                  	; called from SFTFromFCB. SS already DOSDATA
 12620                                  
 12621                                  	; General data filling. Mode is sf_isFCB + open_for_both, date/time 
 12622                                  	; we do not fill, size we do no fill, position we do not fill,
 12623                                  	; bit 14 of flags = TRUE, other bits = FALSE
 12624                                  
 12625                                  	;mov	al,[si+19h]
 12626 00001AB4 8A4419                  	MOV	AL,[SI+fcb_l_drive]
 12627                                  
 12628                                  	; We discriminate based on the first two bits in the reserved field.
 12629                                  	
 12630                                  	;test	al,80h
 12631 00001AB7 A880                    	test	AL,FCBSPECIAL		; check for no sharing test
 12632 00001AB9 741C                    	JZ	short RegenNoSharing	; yes, go regen from no sharing
 12633                                  
 12634                                  	; The FCB is for a network or a sharing based system. At this point 
 12635                                  	; we have already closed the SFT for this guy and reconnection is 
 12636                                  	; impossible.
 12637                                  	;
 12638                                  	; Remember that he may have given us a FCB with bogus information in
 12639                                  	; it. Check to see if sharing is present or if the redir is present.
 12640                                  	; If either is around, presume that we have cycled out the FCB and 
 12641                                  	; give the hard error. Otherwise, just return with carry set.
 12642                                  
 12643 00001ABB E8E758                  	call	CheckShare		; test for sharer
 12644 00001ABE 7509                    	JNZ	short RegenFail		; yep, fail this.
 12645                                  	
 12646                                  	;mov	ax,1100h
 12647 00001AC0 B80011                  	MOV	AX,MultNET<<8		; install check on multnet
 12648 00001AC3 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - INSTALLATION CHECK
 12649                                  			; Return: AL = 00h  not installed, OK to install
 12650                                  			; 01h  not installed, not OK to install
 12651                                  			; FFh  installed
 12652 00001AC5 08C0                    	OR	AL,AL			; is it there?
 12653 00001AC7 740C                    	JZ	short RegenDead		; no, just fail the operation
 12654                                  RegenFail:
 12655                                  	; 17/05/2019 - Retro DOS v4.0
 12656                                  	;MOV	AX,[CS:USER_IN_AX]	; SS override
 12657 00001AC9 36A1[3A03]              	mov	ax,[SS:USER_IN_AX] ; MSDOS 6.0
 12658                                  
 12659                                  	;cmp	ah,10h
 12660 00001ACD 80FC10                  	cmp	AH,FCB_CLOSE
 12661 00001AD0 7403                    	jz	short RegenDead
 12662 00001AD2 E89301                  	call	FCBHardErr		; massive hard error.
 12663                                  RegenDead:
 12664 00001AD5 F9                      	STC				; carry set
 12665                                  FCBRegen_retn:
 12666 00001AD6 C3                      	retn
 12667                                  
 12668                                  	; Local FCB without sharing. Check to see if sharing is loaded. If 
 12669                                  	; so fail the operation.
 12670                                  
 12671                                  RegenNoSharing:
 12672 00001AD7 E8CB58                  	call	CheckShare		; Sharing around?
 12673 00001ADA 75ED                    	JNZ	short RegenFail
 12674                                  	
 12675                                  	; Find an SFT for this guy.
 12676                                  	
 12677                                  	; 17/05/2019 - Retro DOS v4.0
 12678                                  
 12679                                  	; MSDOS 3.3
 12680                                  	;call	LRUFCB
 12681                                  	;jc	short FCBRegen_retn
 12682                                  	
 12683                                  	; MSDOS 6.0
 12684 00001ADC 50                      	push	ax
 12685 00001ADD B000                    	mov	al,0			;indicate it is a regen operation
 12686 00001ADF E8DEFE                  	call	LRUFCB
 12687 00001AE2 58                      	pop	ax
 12688 00001AE3 72F1                    	jc	short FCBRegen_retn
 12689                                  
 12690                                  	;mov	word [es:di+2],8002h
 12691 00001AE5 26C745020280            	MOV	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB+open_for_both+SHARING_COMPAT
 12692 00001AEB 243F                    	AND	AL,3Fh			; get drive number for flags
 12693 00001AED 98                      	CBW
 12694                                  	;or	ax,4000h
 12695 00001AEE 0D0040                  	OR	AX,sf_close_nodate	; normal FCB operation
 12696                                  
 12697                                  	; The bits field consists of the upper two bits (dirty and device) 
 12698                                  	; from the SFT and the low 4 bits from the open mode.
 12699                                  
 12700                                  	;mov	cl,[si+1Ah]
 12701 00001AF1 8A4C1A                  	MOV	CL,[SI+fcb_nsl_bits]	; stick in dirty bits.
 12702 00001AF4 88CD                    	MOV	CH,CL
 12703 00001AF6 80E5C0                  	AND	CH,0C0h 		; mask off the dirty/device bits
 12704 00001AF9 08E8                    	OR	AL,CH
 12705                                  	;and	cl,0Fh
 12706 00001AFB 80E10F                  	AND	CL,access_mask		; get the mode bits
 12707                                  	;mov	[es:di+2],cl
 12708 00001AFE 26884D02                	MOV	[ES:DI+SF_ENTRY.sf_mode],CL
 12709                                  	;mov	[es:di+5],ax
 12710 00001B02 26894505                	MOV	[ES:DI+SF_ENTRY.sf_flags],AX ; initial flags
 12711                                  	;MOV	AX,[CS:PROC_ID]		; SS override
 12712 00001B06 36A1[3C03]              	mov	ax,[ss:PROC_ID] ; MSDOS 6.0
 12713                                  	;mov	[es:di+31h],ax
 12714 00001B0A 26894531                	MOV	[ES:DI+SF_ENTRY.sf_PID],AX
 12715 00001B0E 1E                      	push	ds
 12716 00001B0F 56                      	push	si
 12717 00001B10 06                      	push	es
 12718 00001B11 57                      	push	di
 12719 00001B12 16                      	push	ss
 12720 00001B13 07                      	pop	es
 12721 00001B14 BF[4B05]                	MOV	DI,NAME1		; NAME1 is in DOSDATA
 12722                                  
 12723 00001B17 B90800                  	MOV	CX,8
 12724 00001B1A 46                      	INC	SI			; Skip past drive byte to name in FCB
 12725                                  
 12726                                  	; MSDOS 3.3
 12727                                  ;RegenCopyName:
 12728                                  	;lodsb
 12729                                  	;call	UCase
 12730                                  	;stosb
 12731                                  	;loop	RegenCopyName
 12732                                  
 12733                                  	; MSDOS 6.0
 12734 00001B1B E88EFF                  	call	RegenCopyName		;copy the name to NAME1
 12735                                  
 12736 00001B1E 16                      	push	ss	; SS is DOSDATA
 12737 00001B1F 1F                      	pop	ds
 12738                                  
 12739                                  	;mov	byte [ATTRIB],16h
 12740 00001B20 C606[6B05]16            	MOV	byte [ATTRIB],attr_hidden+attr_system+attr_directory
 12741                                  					; Must set this to something interesting
 12742                                  					; to call DEVNAME.
 12743 00001B25 E81227                  	call	DEVNAME 		; check for device
 12744 00001B28 5E                      	pop	si
 12745 00001B29 07                      	pop	es
 12746 00001B2A 5E                      	pop	si
 12747 00001B2B 1F                      	pop	ds
 12748 00001B2C 7219                    	JC	short RegenFileNoSharing ; not found on device list => file
 12749                                  
 12750                                  	; Device found. We can ignore disk-specific info
 12751                                  
 12752                                  	;mov	[es:di+5],bh
 12753 00001B2E 26887D05                	MOV	[ES:DI+SF_ENTRY.sf_flags],BH ; device parms
 12754                                  	;mov	byte [es:di+4],0
 12755 00001B32 26C6450400              	MOV	byte [ES:DI+SF_ENTRY.sf_attr],0 ; attribute
 12756                                  					; SS override
 12757                                  	;LDS	SI,[CS:DEVPT]		; get device driver
 12758 00001B37 36C536[9A05]            	lds	si,[ss:DEVPT] ; MSDOS 6.0
 12759                                  	;mov	[es:di+7],si
 12760 00001B3C 26897507                	MOV	[ES:DI+SF_ENTRY.sf_devptr],SI
 12761                                  	;mov	[es:di+9],ds
 12762 00001B40 268C5D09                	MOV	[ES:DI+SF_ENTRY.sf_devptr+2],DS
 12763 00001B44 C3                      	retn				; carry is clear
 12764                                  
 12765                                  RegenDeadJ:
 12766 00001B45 EB8E                    	JMP	short RegenDead
 12767                                  
 12768                                  	; File found. Just copy in the remaining pieces.
 12769                                  
 12770                                  RegenFileNoSharing:
 12771                                  	;mov	ax,[es:di+5]
 12772 00001B47 268B4505                	MOV	AX,[ES:DI+SF_ENTRY.sf_flags]
 12773 00001B4B 83E03F                  	AND	AX,03Fh
 12774 00001B4E 1E                      	push	ds
 12775 00001B4F 56                      	push	si
 12776 00001B50 E8DF4E                  	call	FIND_DPB
 12777                                  	;mov	[es:di+7],si
 12778 00001B53 26897507                	MOV	[ES:DI+SF_ENTRY.sf_devptr],SI
 12779                                  	;mov	[es:di+9],ds
 12780 00001B57 268C5D09                	MOV	[ES:DI+SF_ENTRY.sf_devptr+2],DS
 12781 00001B5B 5E                      	pop	si
 12782 00001B5C 1F                      	pop	ds
 12783 00001B5D 72E6                    	jc	short RegenDeadJ	; if find DPB fails, then drive
 12784                                  					; indicator was bogus
 12785                                  	;mov	ax,[si+1Dh]
 12786 00001B5F 8B441D                  	MOV	AX,[SI+fcb_nsl_dirsec]
 12787                                  	;;mov	[es:di+1Dh],ax ; MSDOS 3.3
 12788                                  	;mov	[es:di+1Bh],ax ; MSDOS 6.0
 12789 00001B62 2689451B                	MOV	[ES:DI+SF_ENTRY.sf_dirsec],AX
 12790                                  
 12791                                  	; MSDOS 6.0
 12792                                  
 12793                                  	; SR;
 12794                                  	; Extract the read-only and archive bits from the top 2 bits of the sector
 12795                                  	; number
 12796                                  
 12797                                  	;mov	al,[si+18h]
 12798 00001B66 8A4418                  	mov	al,[si+fcb_sfn]
 12799 00001B69 24C0                    	and	al,0C0h		;get the 2 attribute bits
 12800 00001B6B 88C4                    	mov	ah,al
 12801 00001B6D D0C4                    	rol	ah,1
 12802 00001B6F D0E8                    	shr	al,1
 12803 00001B71 08E0                    	or	al,ah
 12804 00001B73 243F                    	and	al,03Fh		;mask off unused bits
 12805                                  	;mov	[es:di+4],al
 12806 00001B75 26884504                	mov	[es:di+SF_ENTRY.sf_attr],al
 12807                                  
 12808                                  	; SR;
 12809                                  	; Update the higher word of the directory sector from the FCB
 12810                                  
 12811                                  	;;mov	al,[si+18h]
 12812 00001B79 8A4418                  	mov	al,[si+fcb_sfn]
 12813 00001B7C 243F                    	and	al,03Fh		;mask off top 2 bits -- attr bits
 12814 00001B7E 28E4                    	sub	ah,ah
 12815                                  	;mov	[es:di+1Dh],ax
 12816 00001B80 2689451D                	mov	[es:di+SF_ENTRY.sf_dirsec+2],ax ;update high word
 12817                                  
 12818                                  	; MSDOS 6.0 (& MSDOS 3.3)
 12819                                  	;mov	ax,[si+1Bh]
 12820 00001B84 8B441B                  	MOV	AX,[SI+fcb_nsl_firclus]
 12821                                  	;mov	[es:di+0Bh],ax
 12822 00001B87 2689450B                	MOV	[ES:DI+SF_ENTRY.sf_firclus],AX
 12823                                  	;;mov	[es:di+1Bh],ax ; MSDOS 3.3
 12824                                  	;mov	[es:di+35h],ax ; MSDOS 6.0
 12825 00001B8B 26894535                	MOV	[ES:DI+SF_ENTRY.sf_lstclus],AX
 12826                                  	;mov	al,[si+1Fh]
 12827 00001B8F 8A441F                  	MOV	AL,[SI+fcb_nsl_dirpos]
 12828                                  	;mov  	[es:di+1Fh],al
 12829 00001B92 2688451F                	MOV	[ES:DI+SF_ENTRY.sf_dirpos],AL
 12830                                  	;INC	word [ES:DI+SF_ENTRY.sf_ref_count]
 12831 00001B96 26FF05                  	inc	word [ES:DI]		; Increment reference count.
 12832                                  					; Existing FCB entries would be
 12833                                  					; flushed unnecessarily because of
 12834                                  					; check in CheckFCB of the ref_count.
 12835                                  					; July 22/85 - BAS
 12836                                  	;lea	si,[si+1]
 12837 00001B99 8D7401                  	LEA	SI,[SI+SYS_FCB.name]
 12838                                  	;lea	di,[di+20h]
 12839 00001B9C 8D7D20                  	LEA	DI,[DI+SF_ENTRY.sf_name]
 12840                                  	;mov	cx,11
 12841 00001B9F B90B00                  	MOV	CX,SYS_FCB.EXTENT-SYS_FCB.name ; 12-1
 12842                                  	
 12843                                  	; MSDOS 6.0
 12844 00001BA2 E807FF                  	call	RegenCopyName	;copy name to SFT 
 12845                                  	
 12846                                  	; MSDOS 3.3
 12847                                  ;RegenCopyName2:
 12848                                  	;lodsb
 12849                                  	;call    UCase
 12850                                  	;stosb
 12851                                  	;loop    RegenCopyName2
 12852                                  
 12853 00001BA5 F8                      	clc
 12854 00001BA6 C3                      	retn
 12855                                  
 12856                                  ; 17/05/2019 - Retro DOS v4.0
 12857                                  
 12858                                  ;**	BlastSFT - FIll SFT with Garbage
 12859                                  ; --------------------------------------------------------------------------
 12860                                  ;	BlastSFT is used when an SFT is no longer needed; it's called with
 12861                                  ;	various garbage values to put into the SFT.  I don't know why,
 12862                                  ;	presumably to help with debugging (jgl).  We clear the few fields
 12863                                  ;	necessary to show that the SFT is free after filling it.
 12864                                  ;
 12865                                  ;	ENTRY	(es:di) = address of SFT
 12866                                  ;		(al) = fill character
 12867                                  ;	EXIT	(ax) = -1
 12868                                  ;		'C' clear
 12869                                  ;	USES	AX, CX, Flags
 12870                                  
 12871                                  BlastSFT:
 12872 00001BA7 57                      	push	di
 12873                                  	;mov	cx,53 ; MSDOS 3.3
 12874                                  	;mov	cx,59 ; MSDOS 6.0
 12875 00001BA8 B93B00                  	mov	cx,SF_ENTRY.size
 12876 00001BAB F3AA                    	rep	stosb
 12877 00001BAD 5F                      	pop	di
 12878 00001BAE 29C0                    	sub	ax,ax	; 0		; clear 'C'-----------------;
 12879 00001BB0 268905                  	mov	[es:di],ax
 12880                                  	;mov	[es:di+SFT_ENTRY.sf_ref_count],ax ; set ref count   ;
 12881                                  	;mov	[es:di+15h],ax
 12882 00001BB3 26894515                	mov	[es:di+sf_LRU],ax	; set lru		    ;
 12883 00001BB7 48                      	dec	ax	; -1					    ;
 12884                                  	;mov	[es:di+17h],ax ; 0FFFFh ; -1
 12885 00001BB8 26894517                	mov	[es:di+sf_OpenAge],ax	; set open age to -1	    ;
 12886                                  BlastSFT_retn:
 12887 00001BBC C3                      	retn				; return with 'C' clear     ;
 12888                                  
 12889                                  ;Break	<CheckFCB - see if the SFT pointed to by the FCB is still OK>
 12890                                  ; --------------------------------------------------------------------------
 12891                                  ;
 12892                                  ;   CheckFCB - examine an FCB and its contents to see if it needs to be
 12893                                  ;   regenerated.
 12894                                  ;
 12895                                  ;   Inputs:	DS:SI point to FCB (not extended)
 12896                                  ;		AL is SFT index
 12897                                  ;   Outputs:	Carry Set - FCB needs to be regened
 12898                                  ;		Carry clear - FCB is OK. ES:DI point to SFT
 12899                                  ;   Registers modified: AX and BX
 12900                                  ;
 12901                                  ; --------------------------------------------------------------------------
 12902                                  
 12903                                  	; 09/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 12904                                  	; DOSCODE:59F0h (MSDOS 5.0, MSDOS.SYS)
 12905                                  CheckFCB:
 12906                                  		
 12907                                  	; called from $fcb_open and sftfromfcb. SS already set up to DOSDATA
 12908                                  
 12909                                  	; MSDOS 3.3
 12910                                  
 12911                                  	; LES	DI,[CS:SFTFCB]
 12912                                  
 12913                                  	; MSDOS 6.0
 12914                                  	
 12915                                  	; SR;
 12916                                  	; We check if the given FCB is for a local file. If so, we return a 
 12917                                  	; bad SFT status forcing the caller to regenerate the SFT.
 12918                                  
 12919                                  	;test	byte [si+19h],0C0h
 12920 00001BBD F64419C0                	test	byte [si+fcb_l_drive],FCBNETWORK|FCBSHARE|FCBDEVICE
 12921 00001BC1 744F                    	jz	short BadSFT		;Local file, return bad SFT
 12922 00001BC3 36C43E[4000]            	LES     DI,[SS:SFTFCB]		; SS override
 12923                                  
 12924                                  	; MSDOS 6.0 (& MSDOS 3.3)
 12925                                  	;cmp	[es:di+4],al
 12926 00001BC8 26384504                	CMP	[ES:DI+SFT.SFCount],AL
 12927 00001BCC 7244                    	JC	short BadSFT
 12928                                  	;;mov	bl,53 ; MSDOS 3.3
 12929                                  	;mov	bl,59 ; MSDOS 6.0
 12930 00001BCE B33B                    	MOV	BL,SF_ENTRY.size
 12931 00001BD0 F6E3                    	MUL	BL
 12932                                  	;lea	di,[di+6]
 12933 00001BD2 8D7D06                  	LEA	DI,[DI+SFT.SFTable]
 12934 00001BD5 01C7                    	ADD	DI,AX
 12935                                  	;MOV	AX,[CS:PROC_ID]	; MSDOS 3.3
 12936 00001BD7 36A1[3C03]              	mov	ax,[SS:PROC_ID] ; MSDOS 6.0  ; SS override
 12937                                  	;cmp	[es:di+31h],ax
 12938 00001BDB 26394531                	CMP	[ES:DI+SF_ENTRY.sf_PID],AX
 12939 00001BDF 7531                    	JNZ	short BadSFT		; must match process
 12940 00001BE1 26833D00                	cmp	word [es:di],0
 12941                                  	;CMP	word [ES:DI+SF_ENTRY.sf_ref_count],0
 12942 00001BE5 742B                    	JZ	short BadSFT		; must also be in use
 12943                                  	;mov	al,[si+19h]
 12944 00001BE7 8A4419                  	MOV	AL,[SI+fcb_l_drive]
 12945                                  	;test	al,80h
 12946 00001BEA A880                    	test	AL,FCBSPECIAL		; a special FCB?
 12947 00001BEC 7430                    	JZ	short CheckNoShare	; No. try local or device
 12948                                  
 12949                                  	; Since we are a special FCB, try NOT to use a bogus test instruction.
 12950                                  	; FCBSHARE is a superset of FCBNETWORK.
 12951                                  
 12952 00001BEE 50                      	PUSH	AX
 12953                                  	;and	al,0C0h
 12954 00001BEF 24C0                    	AND	AL,FCBMASK
 12955                                  	;cmp	al,0C0h
 12956 00001BF1 3CC0                    	CMP	AL,FCBSHARE		; net FCB?
 12957 00001BF3 58                      	POP	AX
 12958 00001BF4 751E                    	JNZ	short CheckNet		; yes
 12959                                  ;
 12960                                  ;----- In share support -----
 12961                                  ;
 12962                                  	;call	far [cs:JShare+(11*4)]
 12963 00001BF6 36FF1E[BC00]            	Call    far [ss:JShare+(11*4)] ; 11 = ShChk ; SS Override
 12964 00001BFB 7215                    	JC	short BadSFT
 12965 00001BFD EB06                    	JMP	SHORT CheckD
 12966                                  ;
 12967                                  ;----- End in share support -----
 12968                                  ;
 12969                                  	; 09/11/2022
 12970                                  	; (There is not any procedure/sub
 12971                                  	;  which calls or jumps to CheckFirClus here)
 12972                                  	;;;
 12973                                  CheckFirClus:
 12974                                  	;cmp     bx,[es:di+0Bh]
 12975                                  	; 07/12/2022
 12976 00001BFF 263B5D0B                	CMP	BX,[ES:DI+SF_ENTRY.sf_firclus]
 12977 00001C03 750D                    	JNZ	short BadSFT
 12978                                  	;;;
 12979                                  CheckD: 
 12980 00001C05 243F                    	AND	AL,3Fh
 12981                                  	;mov	ah,[es:di+5]
 12982 00001C07 268A6505                	MOV	AH,[ES:DI+SF_ENTRY.sf_flags]
 12983 00001C0B 80E43F                  	AND	AH,3Fh
 12984 00001C0E 38C4                    	CMP	AH,AL
 12985                                  	; 16/12/2022
 12986 00001C10 74AA                    	jz	short BlastSFT_retn	; carry is clear
 12987                                  	; 09/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 12988                                  	;jnz	short BadSFT
 12989                                  ;CheckD_retn:
 12990                                  	;retn
 12991                                  BadSFT: 
 12992 00001C12 F9                      	STC
 12993 00001C13 C3                      	retn
 12994                                  				
 12995                                  CheckNet:
 12996                                  	; 17/05/2019 - Retro DOS v4.0
 12997                                  	
 12998                                  ;----- In net support -----
 12999                                  
 13000                                  	; MSDOS 3.3
 13001                                  	;;mov	ax,[si+1Ah]
 13002                                  	;mov	ax,[si+fcb_net_handle]
 13003                                  	;;cmp	ax,[es:di+1Dh]
 13004                                  	;cmp	ax,[ES:DI+SF_ENTRY.sf_dirsec]
 13005                                  	;jnz	short BadSFT
 13006                                  	;;cmp	ax,[es:di+19h]
 13007                                  	;cmp	ax,[ES:DI+sf_netid]
 13008                                  	;jnz     short BadSFT
 13009                                  	;;mov	ax,[si+1Eh]
 13010                                  	;mov	ax,[si+fcb_l_attr]
 13011                                  	;;cmp	ax,[es:di+1Bh]
 13012                                  	;cmp	ax,[es:di+SF_ENTRY.sf_lstclus]
 13013                                  	;jnz     short BadSFT
 13014                                  
 13015                                  	; MSDOS 6.0
 13016                                  	;mov	ax,[si+1Ch]
 13017 00001C14 8B441C                  	MOV	AX,[SI+fcb_netID]	;AN000;IFS.DOS 4.00
 13018                                  	; 09/11/2022
 13019                                  	;cmp	ax,[es:di+0Bh] 
 13020 00001C17 263B450B                	CMP	AX,[ES:DI+sf_serial_ID]	;AN000;IFS.DOS 4.00
 13021 00001C1B 75F5                    	JNZ	short BadSFT
 13022                                  
 13023                                  ;----- END In net support -----
 13024                                  
 13025                                  CheckNet_retn:
 13026 00001C1D C3                      	retn
 13027                                  
 13028                                  CheckNoShare:
 13029                                  
 13030                                  ; 16/12/2022
 13031                                  ;	; 09/11/2022 (following test instruction is nonsense!)
 13032                                  ;	; (I am leaving it here for MSDOS 5.0 MSDOS.SYS compatibility)
 13033                                  ;	;test	al,40h
 13034                                  ;	test	AL,FCBDEVICE		; Device?
 13035                                  ;	;jnz	short $+2 ; 09/11/2022
 13036                                  ;	JNZ	short CheckNoShareDev 	; Yes
 13037                                  
 13038                                  	; MSDOS 3.3 - IBMDOS.COM - Offset 27EFh
 13039                                  	;;mov	bx,[si+1Dh]
 13040                                  	;MOV	BX,[SI+fcb_nsl_dirsec]
 13041                                  	;;cmp	bx,[es:di+1Dh]
 13042                                  	;cmp	bx,[ES:DI+SF_ENTRY.sf_dirsec]
 13043                                  	;jnz	short BadSFT
 13044                                  	;;mov	bl,[si+1Fh]
 13045                                  	;MOV	bl,[SI+fcb_nsl_dirpos]
 13046                                  	;;cmp	bl,[es:di+1Fh]
 13047                                  	;cmp	bl,[ES:DI+SF_ENTRY.sf_dirpos]
 13048                                  	;jnz	short BadSFT
 13049                                  	;;mov	bl,[si+1Ah]
 13050                                  	;MOV	bl,[SI+fcb_nsl_bits]
 13051                                  	;;mov	bh,[es:di+5]
 13052                                  	;MOV	bh,[ES:DI+SF_ENTRY.sf_flags]
 13053                                  	;xor	bh,bl
 13054                                  	;and	bh,0C0h
 13055                                  	;jnz	short BadSFT
 13056                                  	;;xor	bl,[es:di+2]
 13057                                  	;xor	bl,[ES:DI+SF_ENTRY.sf_mode]
 13058                                  	;and	bl,0Fh
 13059                                  	;jnz	short BadSFT
 13060                                  	;push	di
 13061                                  	;push	si
 13062                                  	;;lea	di,[di+20h]  ; MSDOS 3.3
 13063                                  	;LEA	DI,[DI+SF_ENTRY.sf_name]
 13064                                  	;;lea	si,[si+1]
 13065                                  	;LEA	SI,[SI+SYS_FCB.name]
 13066                                  	;;mov	cx,11
 13067                                  	;MOV	CX,SYS_FCB.EXTENT-SYS_FCB.name ; 12-1
 13068                                  	;repe	cmpsb
 13069                                  	;pop	si
 13070                                  	;pop	di
 13071                                  	;jnz	short BadSFT
 13072                                  	;;mov	bx,[si+1Bh]
 13073                                  	;MOV	bX,[SI+fcb_nsl_firclus]
 13074                                  	;jmp	short CheckFirClus
 13075                                  
 13076                                  	; MSDOS 6.0
 13077                                  
 13078                                  	; SR;
 13079                                  	; The code below to match a local FCB with its SFT can no longer be
 13080                                  	; used. We just return a no-match status. This check is done right
 13081                                  	; at the top.
 13082                                  
 13083                                  CheckNoShareDev:
 13084                                  	;mov	bx,[si+1Ah]
 13085 00001C1E 8B5C1A                  	MOV	BX,[SI+fcb_nsld_drvptr]
 13086                                  	;cmp	bx,[es:di+7]
 13087 00001C21 263B5D07                	CMP	BX,[ES:DI+SF_ENTRY.sf_devptr]
 13088 00001C25 75EB                    	JNZ	short BadSFT
 13089                                  	;mov	bx,[si+1Ch]
 13090 00001C27 8B5C1C                  	MOV	BX,[SI+fcb_nsld_drvptr+2]
 13091                                  	;cmp	bx,[es:di+9]
 13092 00001C2A 263B5D09                	CMP	BX,[ES:DI+SF_ENTRY.sf_devptr+2]
 13093 00001C2E 75E2                    	JNZ	short BadSFT
 13094 00001C30 EBD3                    	JMP	short CheckD
 13095                                  
 13096                                  ;Break	<SFTFromFCB - take a FCB and obtain a SFT from it>
 13097                                  ;----------------------------------------------------------------------------
 13098                                  ;
 13099                                  ;   SFTFromFCB - the workhorse of this compatability crap. Check to see if
 13100                                  ;	the SFT for the FCB is Good. If so, make ThisSFT point to it. If not
 13101                                  ;	good, get one from the cache and regenerate it. Overlay the LRU field
 13102                                  ;	with PID
 13103                                  ;
 13104                                  ;   Inputs:	DS:SI point to FCB
 13105                                  ;   Outputs:	ThisSFT point to appropriate SFT
 13106                                  ;		Carry clear -> OK ES:DI -> SFT
 13107                                  ;		Carry set -> error in ax
 13108                                  ;   Registers modified: ES,DI, AX
 13109                                  ;
 13110                                  ;----------------------------------------------------------------------------
 13111                                  
 13112                                  SFTFromFCB:
 13113                                  	; called from fcbio and $fcb_close. SS already set up to DOSDATA
 13114                                  
 13115                                  	; 17/05/2019 - Retro DOS v4.0
 13116                                  
 13117 00001C32 50                      	push	ax
 13118 00001C33 53                      	push	bx
 13119                                  	;mov	al,[si+18h]
 13120 00001C34 8A4418                  	MOV	AL,[SI+fcb_sfn] 	; set SFN for check
 13121 00001C37 E883FF                  	call	CheckFCB
 13122 00001C3A 5B                      	pop	bx
 13123 00001C3B 58                      	pop	ax
 13124                                  	;MOV	[CS:THISSFT],DI		; SS override
 13125                                  	;MOV	[CS:THISSFT+2],ES
 13126 00001C3C 36893E[9E05]            	MOV	[SS:THISSFT],DI		; SS override
 13127 00001C41 368C06[A005]            	MOV	[SS:THISSFT+2],ES
 13128 00001C46 7311                    	JNC	short Set_SFT		; no problems, just set thissft
 13129                                  	
 13130                                  	; 09/11/2022 (MSDOS 5.0)
 13131                                  	; 31/05/2019
 13132 00001C48 06                      	push	es ; * (MSDOS 6.21) & (MSDOS 5.0)
 13133 00001C49 E825E8                  	call	save_world
 13134 00001C4C E865FE                  	call	FCBRegen
 13135 00001C4F E808E8                  	call	restore_world		; use macro restore world
 13136 00001C52 07                      	pop	es ; * (MSDOS 6.21) ; 31/05/2019 ; 09/11/2022 (MSDOS 5.0)	
 13137                                  
 13138                                  	;MOV	AX,[CS:EXTERR]		; SS override
 13139 00001C53 36A1[2403]              	MOV	AX,[SS:EXTERR]		; SS override
 13140 00001C57 72C4                    	jc	short CheckNet_retn
 13141                                  
 13142                                  Set_SFT: 
 13143                                  	;LES	DI,[CS:THISSFT]		; SS override for THISSFT & PROC_ID
 13144 00001C59 36C43E[9E05]            	les	di,[ss:THISSFT]
 13145                                  	;PUSH	word [CS:PROC_ID]	; set process id
 13146 00001C5E 36FF36[3C03]            	push	word [ss:PROC_ID]
 13147                                  	;pop	word [es:di+31h]
 13148 00001C63 268F4531                	POP     word [ES:DI+SF_ENTRY.sf_PID]
 13149 00001C67 C3                      	retn				; carry is clear
 13150                                  
 13151                                  ;Break	<FCBHardErr - generate INT 24 for hard errors on FCBS>
 13152                                  ;----------------------------------------------------------------------------
 13153                                  ;
 13154                                  ;   FCBHardErr - signal to a user app that he is trying to use an
 13155                                  ;	unavailable FCB.
 13156                                  ;
 13157                                  ;   Inputs:	none.
 13158                                  ;   Outputs:	none.
 13159                                  ;   Registers modified: all
 13160                                  ;
 13161                                  ;----------------------------------------------------------------------------
 13162                                  
 13163                                  FCBHardErr:
 13164                                  	; 17/05/2019 - Retro DOS v4.0
 13165 00001C68 2E8E06[0700]            	mov	es,[cs:DosDSeg]
 13166                                  	;
 13167                                  	;mov	ax,23h
 13168 00001C6D B82300                  	MOV	AX,error_FCB_unavailable
 13169                                  	;;mov	byte [cs:ALLOWED],8
 13170                                  	;MOV	byte [CS:ALLOWED],Allowed_FAIL
 13171 00001C70 26C606[4B03]08          	mov	byte [es:ALLOWED],Allowed_FAIL	
 13172                                  	
 13173                                  	;LES	BP,[CS:THISDPB]
 13174 00001C76 26C42E[8A05]            	les	bp,[es:THISDPB]
 13175                                  	
 13176 00001C7B BF0100                  	MOV	DI,1			; Fake some registers
 13177 00001C7E 89F9                    	MOV	CX,DI
 13178                                  	;mov	dx,[es:bp+0Bh]
 13179 00001C80 268B560B                	MOV	DX,[ES:BP+DPB.FIRST_SECTOR]
 13180 00001C84 E8E336                  	call	HARDERR
 13181 00001C87 F9                      	STC
 13182 00001C88 C3                      	retn
 13183                                  
 13184                                  ;============================================================================
 13185                                  ; FCBIO2.ASM, MSDOS 6.0, 1991
 13186                                  ;============================================================================
 13187                                  ; 21/07/2018 - Retro DOS v3.0
 13188                                  ; 17/05/2019 - Retro DOS v4.0
 13189                                  
 13190                                  ;**	FCBIO2.ASM - Ancient 1.0 1.1 FCB system calls
 13191                                  ;
 13192                                  ;	GetRR
 13193                                  ;	GetExtent
 13194                                  ;	SetExtent
 13195                                  ;	GetExtended
 13196                                  ;	GetRecSize
 13197                                  ;	FCBIO
 13198                                  ;	$FCB_OPEN
 13199                                  ;	$FCB_CREATE
 13200                                  ;	$FCB_RANDOM_WRITE_BLOCK
 13201                                  ;	$FCB_RANDOM_READ_BLOCK
 13202                                  ;	$FCB_SEQ_READ
 13203                                  ;	$FCB_SEQ_WRITE
 13204                                  ;	$FCB_RANDOM_READ
 13205                                  ;	$FCB_RANDOM_WRITE
 13206                                  ;
 13207                                  ;	Revision history:
 13208                                  ;
 13209                                  ;		Created: ARR 4 April 1983
 13210                                  ;			 MZ  6 June  1983 completion of functions
 13211                                  ;			 MZ 15 Dec   1983 Brain damaged programs close FCBs multiple
 13212                                  ;				  times.  Change so successive closes work by
 13213                                  ;				  always returning OK.	Also, detect I/O to
 13214                                  ;				  already closed FCB and return EOF.
 13215                                  ;		 MZ 16 Jan   1984 More braindamage.  Need to separate info
 13216                                  ;				  out of sft into FCB for reconnection
 13217                                  ;
 13218                                  ;	    A000   version 4.00	Jan. 1988
 13219                                  
 13220                                  ; Defintions for FCBOp flags
 13221                                  
 13222                                  RANDOM	equ 2				; random operation
 13223                                  FCBREAD equ 4				; doing a read
 13224                                  BLOCK	equ 8				; doing a block I/O
 13225                                  
 13226                                  ;Break <GetRR - return the random record field in DX:AX>
 13227                                  ;---------------------------------------------------------------------------
 13228                                  ;
 13229                                  ;   GetRR - correctly load DX:AX with the random record field (3 or 4 bytes)
 13230                                  ;	from the FCB pointed to by DS:SI
 13231                                  ;
 13232                                  ;   Inputs:	DS:SI point to an FCB
 13233                                  ;		BX has record size
 13234                                  ;   Outputs:	DX:AX contain the contents of the random record field
 13235                                  ;   Registers modified: none
 13236                                  ;---------------------------------------------------------------------------
 13237                                  
 13238                                  GetRR:
 13239                                  	;mov	ax,[si+21h]
 13240 00001C89 8B4421                  	MOV	AX,[SI+SYS_FCB.RR]	; get low order part
 13241                                  	;mov	dx,[si+23h]
 13242 00001C8C 8B5423                  	MOV	DX,[SI+SYS_FCB.RR+2]	; get high order part
 13243 00001C8F 83FB40                  	CMP	BX,64			; ignore MSB of RR if recsiz > 64
 13244 00001C92 7202                    	JB	short GetRRBye
 13245 00001C94 30F6                    	XOR	DH,DH
 13246                                  GetRRBye:
 13247 00001C96 C3                      	retn
 13248                                  
 13249                                  ;Break <GetExtent - retrieve next location for sequential IO>
 13250                                  ;---------------------------------------------------------------------------
 13251                                  ;
 13252                                  ;   GetExtent - Construct the next record to perform I/O from the EXTENT and
 13253                                  ;	NR fields in the FCB.
 13254                                  ;
 13255                                  ;   Inputs:	DS:SI - point to FCB
 13256                                  ;   Outputs:	DX:AX contain the contents of the random record field
 13257                                  ;   Registers modified: none
 13258                                  ;---------------------------------------------------------------------------
 13259                                  
 13260                                  GetExtent:
 13261                                  	;mov	al,[si+20h]
 13262 00001C97 8A4420                  	MOV	AL,[SI+SYS_FCB.NR]	; get low order piece
 13263                                  	;mov	dx,[si+0Ch]
 13264 00001C9A 8B540C                  	MOV	DX,[SI+SYS_FCB.EXTENT]	; get high order piece
 13265 00001C9D D0E0                    	SHL	AL,1
 13266 00001C9F D1EA                    	SHR	DX,1
 13267 00001CA1 D0D8                    	RCR	AL,1	; move low order bit of DL to high order of AH
 13268 00001CA3 88D4                    	MOV	AH,DL
 13269 00001CA5 88F2                    	MOV	DL,DH
 13270 00001CA7 30F6                    	XOR	DH,DH
 13271 00001CA9 C3                      	retn
 13272                                  
 13273                                  ;Break <SetExtent - update the extent/NR field>
 13274                                  ;---------------------------------------------------------------------------
 13275                                  ;
 13276                                  ;   SetExtent - change the position of an FCB by filling in the extent/NR
 13277                                  ;	fields
 13278                                  ;
 13279                                  ;   Inputs:	DS:SI point to FCB
 13280                                  ;		DX:AX is a record location in file
 13281                                  ;   Outputs:	Extent/NR fields are filled in
 13282                                  ;   Registers modified: CX
 13283                                  ;---------------------------------------------------------------------------
 13284                                  
 13285                                  SetExtent:
 13286 00001CAA 50                      	push	ax
 13287 00001CAB 52                      	push	dx
 13288 00001CAC 89C1                    	MOV	CX,AX
 13289 00001CAE 247F                    	AND	AL,7FH			; next rec field
 13290                                  	;mov	[si+20h],al
 13291 00001CB0 884420                  	MOV	[SI+SYS_FCB.NR],AL
 13292 00001CB3 80E180                  	AND	CL,80H			; save upper bit
 13293 00001CB6 D1E1                    	SHL	CX,1
 13294 00001CB8 D1D2                    	RCL	DX,1			; move high bit of CX to low bit of DX
 13295 00001CBA 88E8                    	MOV	AL,CH
 13296 00001CBC 88D4                    	MOV	AH,DL
 13297                                  	;mov	[si+0Ch], ax
 13298 00001CBE 89440C                  	MOV	[SI+SYS_FCB.EXTENT],AX	; all done
 13299 00001CC1 5A                      	pop	dx
 13300 00001CC2 58                      	pop	ax
 13301 00001CC3 C3                      	retn
 13302                                  
 13303                                  ;Break <GetExtended - find FCB in potential extended fcb>
 13304                                  ;---------------------------------------------------------------------------
 13305                                  ;
 13306                                  ;   GetExtended - Make DS:SI point to FCB from DS:DX
 13307                                  ;
 13308                                  ;   Inputs:	DS:DX point to a possible extended FCB
 13309                                  ;   Outputs:	DS:SI point to the FCB part
 13310                                  ;		zeroflag set if not extended fcb
 13311                                  ;   Registers modified: SI
 13312                                  ;---------------------------------------------------------------------------
 13313                                  
 13314                                  GetExtended:
 13315 00001CC4 89D6                    	MOV	SI,DX			; point to Something
 13316 00001CC6 803CFF                  	CMP	BYTE [SI],-1		; look for extention
 13317 00001CC9 7503                    	JNZ	short GetBye		; not there
 13318 00001CCB 83C607                  	ADD	SI,7			; point to FCB
 13319                                  GetBye:
 13320 00001CCE 39D6                    	CMP	SI,DX			; set condition codes
 13321                                  getextd_retn:
 13322 00001CD0 C3                      	retn
 13323                                  
 13324                                  ;Break <GetRecSize - return in BX the FCB record size>
 13325                                  ;---------------------------------------------------------------------------
 13326                                  ;
 13327                                  ;   GetRecSize - return in BX the record size from the FCB at DS:SI
 13328                                  ;
 13329                                  ;   Inputs:	DS:SI point to a non-extended FCB
 13330                                  ;   Outputs:	BX contains the record size
 13331                                  ;   Registers modified: None
 13332                                  ;---------------------------------------------------------------------------
 13333                                  
 13334                                  	; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 13335                                  GetRecSize:
 13336                                  	;mov	bx,[si+0Eh]
 13337 00001CD1 8B5C0E                  	MOV	BX,[SI+SYS_FCB.RECSIZ]	; get his record size
 13338 00001CD4 09DB                    	OR	BX,BX			; is it nul?
 13339 00001CD6 74F8                    	jz	short getextd_retn
 13340 00001CD8 BB8000                  	MOV	BX,128			; use default size
 13341                                  	;mov	[si+0Eh],bx
 13342 00001CDB 895C0E                  	MOV	[SI+SYS_FCB.RECSIZ],BX	; stuff it back
 13343 00001CDE C3                      	retn
 13344                                  
 13345                                  ;BREAK <FCBIO - do internal FCB I/O>
 13346                                  ;---------------------------------------------------------------------------
 13347                                  ;
 13348                                  ;   FCBIO - look at FCBOP and merge all FCB operations into a single routine.
 13349                                  ;
 13350                                  ;   Inputs:	FCBOP flags which operations need to be performed
 13351                                  ;		DS:DX point to FCB
 13352                                  ;		CX may have count of number of records to xfer
 13353                                  ;   Outputs:	AL has error code
 13354                                  ;   Registers modified: all
 13355                                  ;---------------------------------------------------------------------------
 13356                                  
 13357                                  	; 09/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 13358                                  	; DOSCODE:5B17h (MSDOS 5.0 MSDOS.SYS)
 13359                                  FCBIO:
 13360                                  
 13361                                  FEOF	EQU	1
 13362                                  FTRIM	EQU	2
 13363                                  
 13364                                  %define	FCBErr	byte [bp-1]  ; byte	
 13365                                  %define	cRec	word [bp-3]  ; word	
 13366                                  ;%define RecPos	word [bp-7]  ; dword
 13367                                  %define RecPosL	word [bp-7]  ; word
 13368                                  %define RecPosH	word [bp-5]  ; word
 13369                                  %define	RecSize	word [bp-9]  ; word
 13370                                  ;%define bPos	word [bp-13] ; dword
 13371                                  %define bPosL	word [bp-13] ; word
 13372                                  %define bPosH	word [bp-11] ; word
 13373                                  %define cByte	word [bp-15] ; word	
 13374                                  %define cResult word [bp-17] ; word	
 13375                                  %define	cRecRes	word [bp-19] ; word
 13376                                  %define	FCBOp	byte [bp-20] ; byte
 13377                                  
 13378                                  	;Enter
 13379                                  
 13380 00001CDF 55                      	push	bp
 13381 00001CE0 89E5                    	mov	bp,sp
 13382 00001CE2 83EC14                  	sub	sp,20
 13383                                  	;mov	[bp-20],al
 13384 00001CE5 8846EC                  	MOV	FCBOp,AL
 13385                                  	;mov	byte [bp-1],0
 13386 00001CE8 C646FF00                	MOV	FCBErr,0		;   FCBErr = 0;
 13387 00001CEC E8D5FF                  	call	GetExtended		;   FCB = GetExtended ();
 13388                                  	;test	byte [bp-20],8
 13389 00001CEF F646EC08                	TEST	FCBOp,BLOCK		;   if ((OP&BLOCK) == 0)
 13390 00001CF3 7503                    	JNZ	short GetPos
 13391 00001CF5 B90100                  	MOV	CX,1			;	cRec = 1;
 13392                                  GetPos:
 13393                                  	;mov	[bp-3],cx
 13394 00001CF8 894EFD                  	MOV	cRec,CX 		;*Tail coalesce
 13395 00001CFB E899FF                  	call	GetExtent		;   RecPos = GetExtent ();
 13396 00001CFE E8D0FF                  	call	GetRecSize		;   RecSize = GetRecSize ();
 13397                                  	;mov	[bp-9],bx
 13398 00001D01 895EF7                  	MOV	RecSize,BX
 13399                                  	;test	byte [bp-20],2
 13400 00001D04 F646EC02                	TEST	FCBOp,RANDOM		;   if ((OP&RANDOM) <> 0)
 13401 00001D08 7403                    	JZ	short GetRec
 13402 00001D0A E87CFF                  	call	GetRR			;	RecPos = GetRR ();
 13403                                  GetRec:
 13404                                  	;mov	[bp-7],ax
 13405 00001D0D 8946F9                  	MOV	RecPosL,AX		;*Tail coalesce
 13406                                  	;mov	[bp-5],dx
 13407 00001D10 8956FB                  	MOV	RecPosH,DX
 13408 00001D13 E894FF                  	call	SetExtent		;   SetExtent (RecPos);
 13409                                  	;mov	ax,[bp-5]
 13410 00001D16 8B46FB                  	MOV	AX,RecPosH		;   bPos = RecPos * RecSize;
 13411 00001D19 F7E3                    	MUL	BX
 13412 00001D1B 89C7                    	MOV	DI,AX
 13413                                  	;mov	ax,[bp-7]
 13414 00001D1D 8B46F9                  	MOV	AX,RecPosL
 13415 00001D20 F7E3                    	MUL	BX
 13416 00001D22 01FA                    	ADD	DX,DI
 13417                                  	;mov	[bp-13],ax
 13418 00001D24 8946F3                  	MOV	bPosL,AX
 13419                                  	;mov	[bp-11],dx
 13420 00001D27 8956F5                  	MOV	bPosH,DX
 13421                                  	;mov	ax,[bp-3]
 13422 00001D2A 8B46FD                  	MOV	AX,cRec 		;   cByte = cRec * RecSize;
 13423 00001D2D F7E3                    	MUL	BX
 13424                                  	;mov	[bp-15],ax
 13425 00001D2F 8946F1                  	MOV	cByte,AX
 13426                                  
 13427                                  ;hkn; 	SS override
 13428 00001D32 360306[2C03]            	ADD	AX,[SS:DMAADD]		;   if (cByte+DMA > 64K) {
 13429 00001D37 83D200                  	ADC	DX,0
 13430 00001D3A 7419                    	JZ	short DoOper
 13431                                  	;mov	byte [bp-1],2
 13432 00001D3C C646FF02                	MOV	FCBErr,FTRIM		;	FCBErr = FTRIM;
 13433                                  
 13434                                  ;hkn; 	SS override
 13435 00001D40 36A1[2C03]              	MOV	AX,[SS:DMAADD]		;	cRec = (64K-DMA)/RecSize;
 13436 00001D44 F7D8                    	NEG	AX
 13437 00001D46 7501                    	JNZ	short DoDiv
 13438 00001D48 48                      	DEC	AX
 13439                                  DoDiv:
 13440 00001D49 31D2                    	XOR	DX,DX
 13441 00001D4B F7F3                    	DIV	BX
 13442                                  	;mov	[bp-3],ax
 13443 00001D4D 8946FD                  	MOV	cRec,AX
 13444 00001D50 F7E3                    	MUL	BX			;	cByte = cRec * RecSize;
 13445                                  	;mov	[bp-15],ax
 13446 00001D52 8946F1                  	MOV	cByte,AX		;	}
 13447                                  DoOper:
 13448 00001D55 31DB                    	XOR	BX,BX
 13449                                  	;mov	[bp-17],bx
 13450 00001D57 895EEF                  	MOV	cResult,BX		;   cResult = 0;
 13451                                  	;cmp	[bp-15],bx
 13452 00001D5A 395EF1                  	CMP	cByte,BX		;   if (cByte <> 0 ||
 13453 00001D5D 7506                    	JNZ	short DoGetExt
 13454                                  	;test	byte [bp-1],2
 13455 00001D5F F646FF02                	TEST	FCBErr,FTRIM		;	(FCBErr&FTRIM) == 0) {
 13456                                  	;JZ	short DoGetExt
 13457                                  	;JMP	short SkipOp
 13458                                  	; 16/12/2022
 13459 00001D63 7576                    	jnz	short SkipOp
 13460                                  	; 09/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 13461                                  	;JZ	short DoGetExt
 13462                                  	;JMP	short SkipOp
 13463                                  DoGetExt:
 13464 00001D65 E8CAFE                  	call	SFTFromFCB		;	if (!SFTFromFCB (SFT,FCB))
 13465 00001D68 730F                    	JNC	short ContinueOp
 13466                                  FCBDeath:
 13467 00001D6A E8FCE8                  	call	FCB_RET_ERR		; signal error, map for extended
 13468                                  	;mov	word [bp-19],0
 13469 00001D6D C746ED0000              	MOV	cRecRes,0		; no bytes transferred
 13470                                  	;mov	byte [bp-1],1
 13471 00001D72 C646FF01                	MOV	FCBErr,FEOF		;	    return FTRIM;
 13472 00001D76 E9EF00                  	JMP	FCBSave 		; bam!
 13473                                  ContinueOp:
 13474                                  	;mov	ax,[si+10h]
 13475 00001D79 8B4410                  	MOV	AX,[SI+SYS_FCB.FILSIZ]
 13476                                  	;mov	[es:di+11h],ax
 13477 00001D7C 26894511                	MOV	[ES:DI+SF_ENTRY.sf_size],AX
 13478                                  	;mov	ax,[si+12h]
 13479 00001D80 8B4412                  	MOV	AX,[SI+SYS_FCB.FILSIZ+2]
 13480                                  	;mov	[es:di+13h],ax
 13481 00001D83 26894513                	MOV	[ES:DI+SF_ENTRY.sf_size+2],AX
 13482                                  	;mov	ax,[bp-13]
 13483 00001D87 8B46F3                  	MOV	AX,bPosL
 13484                                  	;mov	dx,[bp-11]
 13485 00001D8A 8B56F5                  	MOV	DX,bPosH
 13486                                  	;mov	[es:di+15h],ax
 13487 00001D8D 26894515                	MOV	[ES:DI+SF_ENTRY.sf_position],AX
 13488                                  	;xchg	dx,[es:di+17h]
 13489 00001D91 26875517                	XCHG	[ES:DI+SF_ENTRY.sf_position+2],DX
 13490 00001D95 52                      	PUSH	DX			; save away Open age.
 13491                                  	;mov	cx,[bp-15]
 13492 00001D96 8B4EF1                  	MOV	CX,cByte		;	cResult =
 13493                                  
 13494                                  ;hkn; DOS_Read is in DOSCODE
 13495 00001D99 BF[4133]                	MOV	DI,DOS_READ		;	    *(OP&FCBRead ? DOS_Read
 13496                                  	;test	byte [bp-20],4
 13497 00001D9C F646EC04                	TEST	FCBOp,FCBREAD		;		 : DOS_Write)(cRec);
 13498 00001DA0 7503                    	JNZ	short DoContext
 13499                                  
 13500                                  ;hkn; DOS_Write is in DOSCODE
 13501 00001DA2 BF[6A35]                	MOV	DI,DOS_WRITE
 13502                                  DoContext:
 13503 00001DA5 55                      	push	bp
 13504 00001DA6 1E                      	push	ds
 13505 00001DA7 56                      	push	si
 13506                                  
 13507                                  ;hkn; SS is DOSDATA
 13508 00001DA8 16                      	push	ss
 13509 00001DA9 1F                      	pop	ds
 13510                                  
 13511                                  ;; Fix for disk full
 13512 00001DAA FFD7                    	CALL	DI	; DOS_READ or DOS_WRITE	
 13513                                  	
 13514 00001DAC 5E                      	pop	si
 13515 00001DAD 1F                      	pop	ds
 13516 00001DAE 5D                      	pop	bp
 13517 00001DAF 72B9                    	JC	short FCBDeath
 13518                                  	
 13519 00001DB1 36803E[0B06]00          	CMP	BYTE [SS:DISK_FULL],0	; treat disk full as error
 13520 00001DB7 740A                    	JZ	short NODSKFULL
 13521 00001DB9 36C606[0B06]00          	MOV	BYTE [SS:DISK_FULL],0	; clear the flag
 13522                                  	;mov	byte [bp-1],1 
 13523 00001DBF C646FF01                	MOV	FCBErr,FEOF		; set disk full flag
 13524                                  NODSKFULL:
 13525                                  ;; Fix for disk full
 13526                                  	;mov	[bp-17],cx
 13527 00001DC3 894EEF                  	MOV	cResult,CX
 13528 00001DC6 E827FB                  	call	SaveFCBInfo		;	SaveFCBInfo (FCB);
 13529                                  	;pop	word [es:di+17h]	
 13530 00001DC9 268F4517                	POP	WORD [ES:DI+SF_ENTRY.sf_position+2] ; restore open age
 13531                                  			       ; (sf_OpenAge = SF_ENTRY.sf_position+2)			
 13532                                  	;mov	ax,[es:di+11h]
 13533 00001DCD 268B4511                	MOV	AX,[ES:DI+SF_ENTRY.sf_size]
 13534                                  	;mov	[si+10h],ax
 13535 00001DD1 894410                  	MOV	[SI+SYS_FCB.FILSIZ],AX
 13536                                  	;mov	ax,[es:di+13h]
 13537 00001DD4 268B4513                	MOV	AX,[ES:DI+SF_ENTRY.sf_size+2]
 13538                                  	;mov	[si+12h],ax
 13539 00001DD8 894412                  	MOV	[SI+SYS_FCB.FILSIZ+2],AX
 13540                                  					;	}
 13541                                  SkipOp:
 13542                                  	;mov	ax,[bp-17]
 13543 00001DDB 8B46EF                  	MOV	AX,cResult		;   cRecRes = cResult / RecSize;
 13544 00001DDE 31D2                    	XOR	DX,DX
 13545                                  	;div	word [bp-9]
 13546 00001DE0 F776F7                  	DIV	RecSize
 13547                                  	;mov	[bp-19],ax
 13548 00001DE3 8946ED                  	MOV	cRecRes,AX
 13549                                  	;add	[bp-7],ax
 13550 00001DE6 0146F9                  	ADD	RecPosL,AX		;   RecPos += cRecResult;
 13551                                  	;adc	word [bp-5],0
 13552 00001DE9 8356FB00                	ADC	RecPosH,0
 13553                                  
 13554                                  ; If we have not gotten the expected number of records, we signal an EOF
 13555                                  ; condition. On input, this is EOF. On output this is usually disk full.
 13556                                  ; BUT... Under 2.0 and before, all device output IGNORED this condition. So
 13557                                  ; do we.
 13558                                  
 13559                                  	;cmp	ax,[bp-3]
 13560 00001DED 3B46FD                  	CMP	AX,cRec 		;   if (cRecRes <> cRec)
 13561 00001DF0 7411                    	JZ	short TryBlank
 13562                                  	;test	byte [bp-20],4
 13563 00001DF2 F646EC04                	TEST	FCBOp,FCBREAD		;	if (OP&FCBRead || !DEVICE)
 13564 00001DF6 7507                    	JNZ	short SetEOF
 13565                                  	; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 13566                                  	; MSDOS 3.3
 13567                                  	;;test	word [es:di+5],80h
 13568                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
 13569                                  	;JNZ	short TryBlank
 13570                                  	; MSDOS 5.0 & MSDOS 6.0
 13571                                  	;test	byte [es:di+5],80h
 13572 00001DF8 26F6450580              	test	byte [ES:DI+SF_ENTRY.sf_flags],devid_device
 13573 00001DFD 7504                    	jnz	short TryBlank
 13574                                  
 13575                                  SetEOF:
 13576                                  	;mov	byte [bp-1],1
 13577 00001DFF C646FF01                	MOV	FCBErr,FEOF		;	FCBErr = FEOF;
 13578                                  TryBlank:				;
 13579 00001E03 09D2                    	OR	DX,DX			;   if (cResult%RecSize <> 0) {
 13580 00001E05 7426                    	JZ	short SetExt
 13581                                  	;add	word [bp-7],1
 13582 00001E07 8346F901                	ADD	RecPosL,1		;	RecPos++;
 13583                                  	;adc	word [bp-5],0
 13584 00001E0B 8356FB00                	ADC	RecPosH,0
 13585                                  	;test	byte [bp-20],4
 13586 00001E0F F646EC04                	TEST	FCBOp,FCBREAD		;	if(OP&FCBRead) <> 0) {
 13587 00001E13 7418                    	JZ	short SetExt
 13588                                  	;inc	word [bp-19]
 13589 00001E15 FF46ED                  	INC	cRecRes 		;	cRecRes++;
 13590                                  	;mov	byte [bp-1],3
 13591 00001E18 C646FF03                	MOV	FCBErr,FTRIM+FEOF	;	FCBErr = FTRIM | FEOF;
 13592                                  	;mov	cx,[bp-9]
 13593 00001E1C 8B4EF7                  	MOV	CX,RecSize		;	Blank (RecSize-cResult%RecSize,
 13594 00001E1F 29D1                    	SUB	CX,DX			;	       DMA+cResult);
 13595 00001E21 30C0                    	XOR	AL,AL
 13596                                  ;hkn; 	SS override
 13597 00001E23 36C43E[2C03]            	les     di,[ss:DMAADD]
 13598                                  	;add	di,[bp-17]
 13599 00001E28 037EEF                  	ADD	DI,cResult
 13600 00001E2B F3AA                    	REP	STOSB			;   }	}
 13601                                  SetExt:
 13602                                  	;mov	dx,[bp-5]
 13603 00001E2D 8B56FB                  	MOV	DX,RecPosH
 13604                                  	;mov	ax,[bp-7]
 13605 00001E30 8B46F9                  	MOV	AX,RecPosL
 13606                                  	;test	byte [bp-20],2
 13607 00001E33 F646EC02                	TEST	FCBOp,RANDOM		;   if ((OP&Random) == 0 ||
 13608 00001E37 7406                    	JZ	short DoSetExt
 13609                                  	;test	byte [bp-20],8
 13610 00001E39 F646EC08                	TEST	FCBOp,BLOCK		;	(OP&BLOCK) <> 0)
 13611 00001E3D 7403                    	JZ	short TrySetRR
 13612                                  DoSetExt:
 13613 00001E3F E868FE                  	call	SetExtent		;	SetExtent (RecPos, FCB);
 13614                                  TrySetRR:
 13615                                  	;test	byte [bp-20],8
 13616 00001E42 F646EC08                	TEST	FCBOp,BLOCK		;   if ((op&BLOCK) <> 0)
 13617 00001E46 740F                    	JZ	short TryReturn
 13618                                  	;mov	[si+21h],ax
 13619 00001E48 894421                  	MOV	[SI+SYS_FCB.RR],AX	;	FCB->RR = RecPos;
 13620                                  	;mov	[si+23h],dl
 13621 00001E4B 885423                  	MOV	[SI+SYS_FCB.RR+2],DL
 13622                                  	;cmp	word [si+0Eh],64
 13623 00001E4E 837C0E40                	CMP	word [SI+SYS_FCB.RECSIZ],64
 13624 00001E52 7303                    	JAE	short TryReturn
 13625                                  	;mov	[si+24h],dh
 13626 00001E54 887424                  	MOV	[SI+SYS_FCB.RR+2+1],DH	; Set 4th byte only if record size < 64
 13627                                  TryReturn: 
 13628                                  	;test	byte [bp-20],4
 13629 00001E57 F646EC04                	TEST	FCBOp,FCBREAD		;   if (!(FCBOP & FCBREAD)) {
 13630 00001E5B 750B                    	JNZ	short FCBSave
 13631 00001E5D 1E                      	push	ds			;	FCB->FDate = date;
 13632 00001E5E E8AFEC                  	call	DATE16			;	FCB->FTime = time;
 13633 00001E61 1F                      	pop	ds
 13634                                  	;mov	[si+14h],ax
 13635 00001E62 894414                  	MOV	[SI+SYS_FCB.FDATE],AX
 13636                                  	;mov	[si+16h],dx
 13637 00001E65 895416                  	MOV	[SI+SYS_FCB.FTIME],DX	;	}
 13638                                  FCBSave: 
 13639                                  	;test	byte [bp-20],8
 13640 00001E68 F646EC08                	TEST	FCBOp,BLOCK		;   if ((op&BLOCK) <> 0)
 13641 00001E6C 7409                    	jz	short DoReturn
 13642                                  	;mov	cx,[bp-19]
 13643 00001E6E 8B4EED                  	MOV	CX,cRecRes		;	user_CX = cRecRes;
 13644 00001E71 E81CE6                  	call    Get_User_Stack
 13645                                  	;mov	[si+4],cx
 13646 00001E74 894C04                  	MOV	[SI+user_env.user_CX],CX
 13647                                  DoReturn:
 13648                                  	;mov	al,[bp-1]
 13649 00001E77 8A46FF                  	MOV	AL,FCBErr		;   return (FCBERR);
 13650                                  	;Leave	
 13651 00001E7A 89EC                    	mov     sp,bp
 13652 00001E7C 5D                      	pop     bp
 13653 00001E7D C3                      	retn
 13654                                  
 13655                                  ; 22/07/2018 - Retro DOS v3.0
 13656                                  
 13657                                  ;Break <$FCB_Open - open an old-style FCB>
 13658                                  ;---------------------------------------------------------------------------
 13659                                  ;
 13660                                  ;   $FCB_Open - CPM compatability file open. The user has formatted an FCB
 13661                                  ;	for us and asked to have the rest filled in.
 13662                                  ;
 13663                                  ;   Inputs:	DS:DX point to an unopenned FCB
 13664                                  ;   Outputs:	AL indicates status 0 is ok FF is error
 13665                                  ;		FCB has the following fields filled in:
 13666                                  ;		    Time/Date Extent/NR Size
 13667                                  ;---------------------------------------------------------------------------
 13668                                  
 13669                                  _$FCB_OPEN:			; System call 15
 13670                                  
 13671 00001E7E B80200                  	MOV	AX,SHARING_COMPAT+open_for_both
 13672                                  
 13673                                  ;hkn; DOS_Open is in DOSCODE
 13674 00001E81 B9[E12B]                	MOV	CX,DOS_OPEN
 13675                                  
 13676                                  ; The following is common code for Creation and openning of FCBs. AX is
 13677                                  ; either attributes (for create) or open mode (for open)... DS:DX points to
 13678                                  ; the FCB
 13679                                  
 13680                                  DoAccess:
 13681 00001E84 1E                      	push	ds
 13682 00001E85 52                      	push	dx
 13683 00001E86 51                      	push	cx
 13684 00001E87 50                      	push	ax			; save FCB pointer away
 13685                                  
 13686                                  ;hkn; 	OpenBuf is in DOSDATA
 13687 00001E88 BF[BE03]                	MOV	DI,OPENBUF
 13688 00001E8B E8EB4C                  	call	TransFCB		; crunch the fcb
 13689 00001E8E 58                      	pop	ax
 13690 00001E8F 59                      	pop	cx
 13691 00001E90 5A                      	pop	dx
 13692 00001E91 1F                      	pop	ds			; get fcb
 13693 00001E92 7303                    	JNC	short FindFCB		; everything seems ok
 13694                                  FCBOpenErr:
 13695                                  	; AL has error code
 13696 00001E94 E9D2E7                  	jmp	FCB_RET_ERR
 13697                                  FindFCB:
 13698 00001E97 E82AFE                  	call	GetExtended		; DS:SI will point to FCB
 13699                                  
 13700                                  	; 17/05/2019 - Retro DOS v4.0
 13701                                  
 13702                                  	; MSDOS 3.3
 13703                                  	;call	LRUFCB
 13704                                  	;jc	short HardMessage
 13705                                  
 13706                                  	; MSDOS 6.0
 13707 00001E9A 50                      	push	ax
 13708 00001E9B B001                    	mov	al,1			;indicate Open/Create operation
 13709 00001E9D E820FB                  	call	LRUFCB			; get a sft entry (no error)
 13710 00001EA0 58                      	pop	ax
 13711 00001EA1 722A                    	jc	short HardMessage
 13712                                  	
 13713                                  	;mov	word [es:di+2],8000h
 13714 00001EA3 26C745020080            	mov	word [es:di+SF_ENTRY.sf_mode],sf_isFCB
 13715 00001EA9 1E                      	push	ds
 13716 00001EAA 56                      	push	si	
 13717 00001EAB 53                      	push	bx			; save fcb pointer
 13718 00001EAC 89CE                    	MOV	SI,CX
 13719                                  
 13720                                  ;hkn; SS is DOSDATA
 13721 00001EAE 16                      	push	ss
 13722 00001EAF 1F                      	pop	ds			    ; let DOS_Open see variables
 13723 00001EB0 FFD6                    	CALL	SI ; DOS_OPEN or DOS_CREATE ; go open the file
 13724 00001EB2 5B                      	pop	bx
 13725 00001EB3 5E                      	pop	si
 13726 00001EB4 1F                      	pop	ds			; get fcb
 13727                                  
 13728                                  ;hkn; SS override
 13729 00001EB5 36C43E[9E05]            	LES	DI,[SS:THISSFT]		; get sf pointer
 13730 00001EBA 7318                    	JNC	short FCBOK		; operation succeeded
 13731                                  failopen:
 13732 00001EBC 50                      	PUSH	AX
 13733 00001EBD B052                    	MOV	AL,"R"	; 52h		; clear out field (free sft)
 13734 00001EBF E8E5FC                  	call	BlastSFT
 13735 00001EC2 58                      	POP	AX
 13736                                  	;cmp	ax,4
 13737 00001EC3 83F804                  	CMP	AX,error_too_many_open_files
 13738 00001EC6 7405                    	JZ	short HardMessage
 13739                                  	;cmp	ax,24h
 13740 00001EC8 83F824                  	CMP	AX,error_sharing_buffer_exceeded
 13741 00001ECB 7505                    	jnz	short DeadFCB
 13742                                  HardMessage:
 13743 00001ECD 50                      	PUSH	AX
 13744 00001ECE E897FD                  	call	FCBHardErr
 13745 00001ED1 58                      	POP	AX
 13746                                  DeadFCB:
 13747                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 13748                                  	;jmp	FCB_RET_ERR
 13749 00001ED2 EBC0                    	jmp	short FCBOpenErr
 13750                                  FCBOK:
 13751                                  	; MSDOS 6.0
 13752 00001ED4 E8D5F3                  	call	IsSFTNet		;AN007;F.C. >32mb  Non Fat file?
 13753 00001ED7 750F                    	JNZ	short FCBOK2		;AN007;F.C. >32mb  yes
 13754 00001ED9 E8C954                  	call	CheckShare		;AN000;F.C. >32mb  share around?
 13755 00001EDC 750A                    	JNZ	short FCBOK2		;AN000;F.C. >32mb  yes
 13756                                  ;SR;
 13757                                  ; If we reach here, we know we have got a local SFT. Let's update the 
 13758                                  ; LocalSFT variable to reflect this.
 13759                                  
 13760 00001EDE 36893E[4310]            	mov	[ss:LocalSFT],di
 13761 00001EE3 368C06[4510]            	mov	[ss:LocalSFT+2],es; Store the SFT address
 13762                                  ;;SR;
 13763                                  ;; The check below is not valid anymore since we regenerate for media > 32M.
 13764                                  ;;
 13765                                  ;;	CMP	WORD [ES:DI+SF_ENTRY.sf_dirsec+2],0 
 13766                                  ;;					       ;AN000;F.C. >32mb  if dirsec >32mb
 13767                                  ;;	JZ	short FCBOK2		       ;AN000;F.C. >32mb    then error
 13768                                  ;;	MOV	AX,error_sys_comp_not_loaded   ;AN000;F.C. >32mb
 13769                                  ;;	JMP	short failopen		       ;AN000;F.C. >32mb
 13770                                  
 13771                                  FCBOK2:
 13772                                  	; MSDOS 6.0 (& MSDOS 3.3)
 13773 00001EE8 26FF05                  	inc	word [es:di]
 13774                                  	;INC	word [ES:DI+SF_ENTRY.sf_ref_count] ; increment reference count
 13775 00001EEB E802FA                  	call	SaveFCBInfo
 13776                                  	; MSDOS 3.3
 13777                                  	;call	SetOpenAge
 13778                                  	; MSDOS 6.0 (& MSDOS 3.3)
 13779                                  	;test	word [es:di+5],80h
 13780                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
 13781 00001EEE 26F6450580              	test	byte [ES:DI+SF_ENTRY.sf_flags],devid_device  ; 28/07/2019
 13782 00001EF3 7508                    	JNZ	short FCBNoDrive	; do not munge drive on devices
 13783 00001EF5 8A04                    	MOV	AL,[SI]			; get drive byte
 13784 00001EF7 E80A4C                  	call	GETTHISDRV		; convert
 13785                                  	;INC	AL
 13786                                  	; 17/12/2022
 13787 00001EFA 40                      	inc	ax
 13788 00001EFB 8804                    	MOV	[SI],AL			; stash in good drive letter
 13789                                  FCBNoDrive:
 13790                                  	;mov	word [si+0Eh],128
 13791 00001EFD C7440E8000              	MOV	word [SI+SYS_FCB.RECSIZ],80h ; stuff in default record size
 13792                                  
 13793                                  	;mov	ax,[es:di+0Dh]
 13794 00001F02 268B450D                	MOV	AX,[ES:DI+SF_ENTRY.sf_time] ; set time
 13795                                  	;mov	[si+16h],ax
 13796 00001F06 894416                  	MOV	[SI+SYS_FCB.FTIME],AX
 13797                                  	;mov	ax,[es:di+0Fh]
 13798 00001F09 268B450F                	MOV	AX,[ES:DI+SF_ENTRY.sf_date] ; set date
 13799                                  	;mov	[si+14h],ax
 13800 00001F0D 894414                  	MOV	[SI+SYS_FCB.FDATE],AX
 13801                                  	;mov	ax,[es:di+11h]
 13802 00001F10 268B4511                	MOV	AX,[ES:DI+SF_ENTRY.sf_size] ; set sizes
 13803                                  	;mov	[si+10h],ax
 13804 00001F14 894410                  	MOV	[SI+SYS_FCB.FILSIZ],AX
 13805                                  	;mov	ax,[es:di+13h]
 13806 00001F17 268B4513                	MOV	AX,[ES:DI+SF_ENTRY.sf_size+2]
 13807                                  	;mov	[si+12h],ax
 13808 00001F1B 894412                  	MOV	[SI+SYS_FCB.FILSIZ+2],AX
 13809 00001F1E 31C0                    	XOR	AX,AX			; convenient zero
 13810                                  	;mov	[si+0Ch],ax
 13811 00001F20 89440C                  	MOV	[SI+SYS_FCB.EXTENT],AX	; point to beginning of file
 13812                                  
 13813                                  ; We must scan the set of FCB SFTs for one that appears to match the current
 13814                                  ; one.	We cheat and use CheckFCB to match the FCBs.
 13815                                  
 13816                                  ;hkn; 	SS override
 13817 00001F23 36C43E[4000]            	LES	DI,[SS:SFTFCB]		; get the pointer to head of the list
 13818                                  	;mov	ah,[es:di+4]
 13819 00001F28 268A6504                	MOV	AH,[ES:DI+SFT.SFCount]	; get number of SFTs to scan
 13820                                  OpenScan:
 13821                                  	;cmp	al,[si+18h]
 13822 00001F2C 3A4418                  	CMP	AL,[SI+fcb_sfn]		; don't compare ourselves
 13823 00001F2F 7407                    	JZ	short SkipCheck
 13824 00001F31 50                      	push	ax			; preserve count
 13825 00001F32 E888FC                  	call	CheckFCB		; do they match
 13826 00001F35 58                      	pop	ax			; get count back
 13827 00001F36 7309                    	JNC	short OpenFound		; found a match!
 13828                                  SkipCheck:
 13829 00001F38 FEC0                    	INC	AL			; advance to next FCB
 13830 00001F3A 38E0                    	CMP	AL,AH			; table full?
 13831 00001F3C 75EE                    	JNZ	short OpenScan		; no, go for more
 13832                                  OpenDone:
 13833 00001F3E 30C0                    	xor	al,al			; return success
 13834 00001F40 C3                      	retn
 13835                                  
 13836                                  ; The SFT at ES:DI is the one that is already in use for this FCB. We set the
 13837                                  ; FCB to use this one. We increment its ref count. We do NOT close it at all.
 13838                                  ; Consider:
 13839                                  ;
 13840                                  ;   open (foo)	delete (foo) open (bar)
 13841                                  ;
 13842                                  ; This causes us to recycle (potentially) bar through the same local SFT as
 13843                                  ; foo even though foo is no longer needed; this is due to the server closing
 13844                                  ; foo for us when we delete it. Unfortunately, we cannot see this closure.
 13845                                  ; If we were to CLOSE bar, the server would then close the only reference to
 13846                                  ; bar and subsequent I/O would be lost to the redirector.
 13847                                  ;
 13848                                  ; This gets solved by NOT closing the sft, but zeroing the ref count
 13849                                  ; (effectively freeing the SFT) and informing the sharer (if relevant) that
 13850                                  ; the SFT is no longer in use. Note that the SHARER MUST keep its ref counts
 13851                                  ; around. This will allow us to access the same file through multiple network
 13852                                  ; connections and NOT prematurely terminate when the ref count on one
 13853                                  ; connection goes to zero.
 13854                                  
 13855                                  OpenFound:
 13856                                  	;mov	[si+18h],al
 13857 00001F41 884418                  	MOV	[SI+fcb_sfn],AL 	; assign with this
 13858 00001F44 26FF05                  	inc	word [es:di]
 13859                                  	;INC	word [ES:DI+SF_ENTRY.sf_ref_count]
 13860                                  					; remember this new invocation
 13861 00001F47 36A1[1000]              	MOV	AX,[SS:FCBLRU]		; update LRU counts
 13862                                  	;mov	[es:di+15h],ax
 13863 00001F4B 26894515                	MOV	[ES:DI+sf_LRU],AX
 13864                                  ;
 13865                                  ; We have an FCB sft that is now of no use.  We release sharing info and then
 13866                                  ; blast it to prevent other reuse.
 13867                                  ;
 13868 00001F4F 16                      	push	ss
 13869 00001F50 1F                      	pop	ds
 13870 00001F51 C43E[9E05]              	LES	DI,[THISSFT]
 13871 00001F55 26FF0D                  	dec	word [es:di]
 13872                                  	;DEC	word [ES:DI+SF_ENTRY.sf_ref_count]
 13873                                  					; free the newly allocated SFT
 13874 00001F58 E88254                  	call	ShareEnd
 13875 00001F5B B043                    	MOV	AL,'C'	 ; 43h
 13876 00001F5D E847FC                  	call	BlastSFT
 13877 00001F60 EBDC                    	JMP	short OpenDone
 13878                                  
 13879                                  ;BREAK	<$FCB_Create - create a new directory entry>
 13880                                  ;----------------------------------------------------------------------------
 13881                                  ;
 13882                                  ;   $FCB_Create - CPM compatability file create. The user has formatted an
 13883                                  ;	FCB for us and asked to have the rest filled in.
 13884                                  ;
 13885                                  ;   Inputs:	DS:DX point to an unopenned FCB
 13886                                  ;   Outputs:	AL indicates status 0 is ok FF is error
 13887                                  ;		FCB has the following fields filled in:
 13888                                  ;		    Time/Date Extent/NR Size
 13889                                  ;----------------------------------------------------------------------------
 13890                                  
 13891                                  _$FCB_CREATE:		; System call 22
 13892                                  
 13893                                  ;hkn; DOS_Create is in DOSCODE
 13894 00001F62 B9[B72A]                	MOV	CX,DOS_CREATE		; routine to call
 13895 00001F65 31C0                    	XOR	AX,AX			; attributes to create
 13896 00001F67 E85AFD                  	call	GetExtended		; get extended FCB
 13897 00001F6A 7403                    	JZ	short DoAccessJ		; not an extended FCB
 13898 00001F6C 8A44FF                  	MOV	AL,[SI-1]		; get attributes
 13899                                  DoAccessJ:
 13900 00001F6F E912FF                  	JMP	DoAccess		; do dirty work
 13901                                  
 13902                                  ; 22/07/2018 - Retro DOS v3.0
 13903                                  
 13904                                  ;BREAK <$FCB_Random_write_Block - write a block of records to a file >
 13905                                  ;----------------------------------------------------------------------------
 13906                                  ;
 13907                                  ;   $FCB_Random_Write_Block - retrieve a location from the FCB, seek to it
 13908                                  ;	and write a number of blocks from it.
 13909                                  ;
 13910                                  ;   Inputs:	DS:DX point to an FCB
 13911                                  ;   Outputs:	AL = 0 write was successful and the FCB position is updated
 13912                                  ;		AL <> 0 Not enough room on disk for the output
 13913                                  ;
 13914                                  ;----------------------------------------------------------------------------
 13915                                  
 13916                                  _$FCB_RANDOM_WRITE_BLOCK:
 13917                                  	;mov	AL,0Ah	
 13918 00001F72 B00A                    	MOV	AL,RANDOM+BLOCK
 13919 00001F74 E968FD                  	JMP	FCBIO
 13920                                  
 13921                                  ;BREAK <$FCB_Random_Read_Block - read a block of records to a file >
 13922                                  ;----------------------------------------------------------------------------
 13923                                  ;
 13924                                  ;   $FCB_Random_Read_Block - retrieve a location from the FCB, seek to it
 13925                                  ;	and read a number of blocks from it.
 13926                                  ;
 13927                                  ;   Inputs:	DS:DX point to an FCB
 13928                                  ;   Outputs:	AL = error codes defined above
 13929                                  ;
 13930                                  ;----------------------------------------------------------------------------
 13931                                  
 13932                                  _$FCB_RANDOM_READ_BLOCK:
 13933                                  	;mov	AL,0Eh	
 13934 00001F77 B00E                    	MOV	AL,RANDOM+FCBREAD+BLOCK
 13935 00001F79 E963FD                  	JMP	FCBIO
 13936                                  
 13937                                  ;BREAK <$FCB_Seq_Read - read the next record from a file >
 13938                                  ;----------------------------------------------------------------------------
 13939                                  ;
 13940                                  ;   $FCB_Seq_Read - retrieve the next record from an FCB and read it into
 13941                                  ;	memory
 13942                                  ;
 13943                                  ;   Inputs:	DS:DX point to an FCB
 13944                                  ;   Outputs:	AL = error codes defined above
 13945                                  ;
 13946                                  ;----------------------------------------------------------------------------
 13947                                  
 13948                                  _$FCB_SEQ_READ:
 13949                                  	;mov	AL,4	
 13950 00001F7C B004                    	MOV	AL,FCBREAD
 13951 00001F7E E95EFD                  	JMP	FCBIO
 13952                                  
 13953                                  ;BREAK <$FCB_Seq_Write - write the next record to a file >
 13954                                  ;----------------------------------------------------------------------------
 13955                                  ;
 13956                                  ;   $FCB_Seq_Write - retrieve the next record from an FCB and write it to the
 13957                                  ;	file
 13958                                  ;
 13959                                  ;   Inputs:	DS:DX point to an FCB
 13960                                  ;   Outputs:	AL = error codes defined above
 13961                                  ;
 13962                                  ;----------------------------------------------------------------------------
 13963                                  
 13964                                  _$FCB_SEQ_WRITE:
 13965 00001F81 B000                    	MOV	AL,0
 13966 00001F83 E959FD                  	jmp	FCBIO
 13967                                  
 13968                                  ;BREAK <$FCB_Random_Read - Read a single record from a file >
 13969                                  ;----------------------------------------------------------------------------
 13970                                  ;
 13971                                  ;   $FCB_Random_Read - retrieve a location from the FCB, seek to it and read a
 13972                                  ;	record from it.
 13973                                  ;
 13974                                  ;   Inputs:	DS:DX point to an FCB
 13975                                  ;   Outputs:	AL = error codes defined above
 13976                                  ;
 13977                                  ;----------------------------------------------------------------------------
 13978                                  
 13979                                  _$FCB_RANDOM_READ:
 13980                                  	;mov	AL,6	
 13981 00001F86 B006                    	MOV	AL,RANDOM+FCBREAD
 13982 00001F88 E954FD                  	jmp	FCBIO			; single block
 13983                                  
 13984                                  ;BREAK <$FCB_Random_Write - write a single record to a file >
 13985                                  ;----------------------------------------------------------------------------
 13986                                  ;
 13987                                  ;   $FCB_Random_Write - retrieve a location from the FCB, seek to it and write
 13988                                  ;	a record to it.
 13989                                  ;
 13990                                  ;   Inputs:	DS:DX point to an FCB
 13991                                  ;   Outputs:	AL = error codes defined above
 13992                                  ;
 13993                                  ;----------------------------------------------------------------------------
 13994                                  
 13995                                  _$FCB_RANDOM_WRITE:
 13996                                  	;mov	AL,2	
 13997 00001F8B B002                    	MOV	AL,RANDOM
 13998 00001F8D E94FFD                  	jmp	FCBIO
 13999                                  
 14000                                  ;============================================================================
 14001                                  ; SEARCH.ASM, MSDOS 6.0, 1991
 14002                                  ;============================================================================
 14003                                  ; 22/07/2018 - Retro DOS v3.0
 14004                                  ; 17/05/2019 - Retro DOS v4.0
 14005                                  
 14006                                  ; DOSCODE:5DDFh (MSDOS 6.21, MSDOS.SYS)
 14007                                  
 14008                                  ; 09/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 14009                                  ; DOSCODE:5DCBh (MSDOS 5.0, MSDOS.SYS)
 14010                                  
 14011                                  ;**	Search.asm
 14012                                  ;----------------------------------------------------------------------------
 14013                                  ;	Directory search system calls.
 14014                                  ;	These will be passed direct text of the pathname from the user. 
 14015                                  ;	They will need to be passed through the macro expander prior to
 14016                                  ;	being sent through the low-level stuff. 
 14017                                  ;	I/O specs are defined in DISPATCH. The system calls are:
 14018                                  ;
 14019                                  ;	$Dir_Search_First	  written
 14020                                  ;	$Dir_Search_Next	  written
 14021                                  ;	$Find_First	  written
 14022                                  ;	$Find_Next		  written
 14023                                  ;	PackName		  written
 14024                                  ;
 14025                                  ;	Modification history:
 14026                                  ;
 14027                                  ;	  Created: ARR 4 April 1983
 14028                                  
 14029                                  ;----------------------------------------------------------------------------
 14030                                  ; Procedure Name : $DIR_SEARCH_FIRST
 14031                                  ;
 14032                                  ; Inputs:
 14033                                  ;	DS:DX Points to unopenned FCB
 14034                                  ; Function:
 14035                                  ;	Directory is searched for first matching entry and the directory
 14036                                  ;	entry is loaded at the disk transfer address
 14037                                  ; Returns:
 14038                                  ;	AL = -1 if no entries matched, otherwise 0
 14039                                  ;----------------------------------------------------------------------------
 14040                                  
 14041                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 2B88h
 14042                                  
 14043                                  _$DIR_SEARCH_FIRST:
 14044 00001F90 368916[A605]            	MOV	[SS:THISFCB],DX
 14045 00001F95 368C1E[A805]            	MOV	[SS:THISFCB+2],DS
 14046 00001F9A 89D6                    	MOV	SI,DX
 14047 00001F9C 803CFF                  	CMP	BYTE [SI],0FFH
 14048 00001F9F 7503                    	JNZ	short NORMFCB4
 14049 00001FA1 83C607                  	ADD	SI,7			; Point to drive select byte
 14050                                  NORMFCB4:
 14051 00001FA4 FF34                    	push	word [SI]		; Save original drive byte for later
 14052                                  
 14053 00001FA6 16                      	push	ss
 14054 00001FA7 07                      	pop	es			; get es to address DOSGroup
 14055                                  
 14056 00001FA8 BF[BE03]                	MOV	DI,OPENBUF		; appropriate buffer
 14057 00001FAB E8CB4B                  	call	TransFCB		; convert the FCB, set SATTRIB EXTFCB
 14058 00001FAE 7304                    	JNC	short SearchIt		; no error, go and look
 14059 00001FB0 5B                      	pop	bx			; Clean stack
 14060                                  
 14061                                  ; Error code is in AX
 14062                                  
 14063                                  	; 09/11/2022
 14064                                  dcf_errj:
 14065 00001FB1 E9B5E6                  	jmp	FCB_RET_ERR		; error
 14066                                  
 14067                                  SearchIt:
 14068 00001FB4 16                      	push	ss
 14069 00001FB5 1F                      	pop	ds			; get ready for search
 14070 00001FB6 FF36[2C03]              	push	word [DMAADD]
 14071 00001FBA FF36[2E03]              	push	word [DMAADD+2]
 14072 00001FBE C706[2C03][BE04]        	MOV	WORD [DMAADD],SEARCHBUF
 14073 00001FC4 8C1E[2E03]              	MOV	WORD [DMAADD+2],DS
 14074                                  	; MSDOS 3.3
 14075                                  	;call	DOS_SEARCH_FIRST
 14076                                  	; MSDOS 6.0
 14077 00001FC8 E88501                  	call	GET_FAST_SEARCH		; search
 14078 00001FCB 8F06[2E03]              	pop	word [DMAADD+2]
 14079 00001FCF 8F06[2C03]              	pop	word [DMAADD]
 14080 00001FD3 7303                    	JNC	short SearchSet		; no error, transfer info
 14081 00001FD5 5B                      	pop	bx			; Clean stack
 14082                                  
 14083                                  ; Error code is in AX
 14084                                  
 14085                                  	; 09/11/2022
 14086                                  	;jmp	FCB_RET_ERR
 14087 00001FD6 EBD9                    	jmp	short dcf_errj
 14088                                  
 14089                                  ; The search was successful (or the search-next). We store the information
 14090                                  ; into the user's FCB for continuation.
 14091                                  
 14092                                  SearchSet:
 14093 00001FD8 BE[BE04]                	MOV	SI,SEARCHBUF
 14094 00001FDB C43E[A605]              	LES	DI,[THISFCB]		; point to the FCB
 14095 00001FDF F606[6C05]FF            	TEST	byte [EXTFCB],0FFh		;
 14096 00001FE4 7403                    	JZ	short NORMFCB1
 14097 00001FE6 83C707                  	ADD	DI,7			; Point past the extension
 14098                                  NORMFCB1:
 14099 00001FE9 5B                      	pop	bx			; Get original drive byte
 14100 00001FEA 08DB                    	OR	BL,BL
 14101 00001FEC 7506                    	JNZ	short SearchDrv
 14102 00001FEE 8A1E[3603]              	MOV	BL,[CURDRV]
 14103 00001FF2 FEC3                    	INC	BL
 14104                                  SearchDrv:
 14105 00001FF4 AC                      	LODSB				; Get correct search contin drive byte
 14106 00001FF5 86C3                    	XCHG	AL,BL			; Search byte to BL, user byte to AL
 14107 00001FF7 47                      	INC	DI
 14108                                  	;STOSB				; Store the correct "user" drive byte
 14109                                  					;  at the start of the search info
 14110 00001FF8 B90A00                  	MOV	CX,20/2
 14111 00001FFB F3A5                    	REP	MOVSW			; Rest of search cont info, SI -> entry
 14112 00001FFD 86C3                    	XCHG	AL,BL			; User drive byte back to BL, search
 14113                                  					;   byte to AL
 14114 00001FFF AA                      	STOSB				; Search contin drive byte at end of
 14115                                  					;   contin info
 14116 00002000 C43E[2C03]              	LES	DI,[DMAADD]
 14117 00002004 F606[6C05]FF            	TEST	byte [EXTFCB],0FFh
 14118 00002009 740D                    	JZ	short NORMFCB2
 14119 0000200B B0FF                    	MOV	AL,0FFh
 14120 0000200D AA                      	STOSB
 14121 0000200E FEC0                    	INC	AL
 14122                                  	;MOV	CX,5
 14123                                  	; 17/12/2022
 14124 00002010 B105                    	mov	cl,5
 14125 00002012 F3AA                    	REP	STOSB
 14126 00002014 A0[6D05]                	MOV	AL,[SATTRIB]
 14127 00002017 AA                      	STOSB
 14128                                  NORMFCB2:
 14129 00002018 88D8                    	MOV	AL,BL			; User Drive byte
 14130 0000201A AA                      	STOSB
 14131                                  	;MOV	CX,16			; 32 / 2 words of dir entry
 14132                                  	; 17/12/2022
 14133 0000201B B110                    	mov	cl,16
 14134 0000201D F3A5                    	REP	MOVSW
 14135 0000201F E944E6                  	jmp	FCB_RET_OK
 14136                                  
 14137                                  ;----------------------------------------------------------------------------
 14138                                  ;
 14139                                  ; Procedure Name : $DIR_SEARCH_NEXT
 14140                                  ;
 14141                                  ; Inputs:
 14142                                  ;	DS:DX points to unopenned FCB returned by $DIR_SEARCH_FIRST
 14143                                  ; Function:
 14144                                  ;	Directory is searched for the next matching entry and the directory
 14145                                  ;	entry is loaded at the disk transfer address
 14146                                  ; Returns:
 14147                                  ;	AL = -1 if no entries matched, otherwise 0
 14148                                  ;----------------------------------------------------------------------------
 14149                                  
 14150                                  _$DIR_SEARCH_NEXT:
 14151 00002022 368916[A605]            	MOV	[SS:THISFCB],DX
 14152 00002027 368C1E[A805]            	MOV	[SS:THISFCB+2],DS
 14153 0000202C 36C606[6D05]00          	MOV	byte [SS:SATTRIB],0
 14154 00002032 36C606[6C05]00          	MOV	byte [SS:EXTFCB],0
 14155                                  
 14156 00002038 16                      	push	ss
 14157 00002039 07                      	pop	es
 14158                                  
 14159 0000203A BF[BE04]                	MOV	DI,SEARCHBUF
 14160                                  
 14161 0000203D 89D6                    	MOV	SI,DX
 14162 0000203F 803CFF                  	CMP	BYTE [SI],0FFh
 14163 00002042 750D                    	JNZ	short NORMFCB6
 14164 00002044 83C606                  	ADD	SI,6
 14165 00002047 AC                      	LODSB
 14166                                  
 14167 00002048 36A2[6D05]              	MOV	[SS:SATTRIB],AL
 14168 0000204C 36FE0E[6C05]            	DEC	byte [SS:EXTFCB]
 14169                                  NORMFCB6:
 14170 00002051 AC                      	LODSB				; Get original user drive byte
 14171 00002052 50                      	push	ax			; Put it on stack
 14172 00002053 8A4414                  	MOV	AL,[SI+20]		; Get correct search contin drive byte
 14173 00002056 AA                      	STOSB				; Put in correct place
 14174 00002057 B90A00                  	MOV	CX,20/2
 14175 0000205A F3A5                    	REP	MOVSW			; Transfer in rest of search contin info
 14176                                  
 14177 0000205C 16                      	push	ss
 14178 0000205D 1F                      	pop	ds
 14179                                  
 14180 0000205E FF36[2C03]              	push	word [DMAADD]
 14181 00002062 FF36[2E03]              	push	word [DMAADD+2]
 14182 00002066 C706[2C03][BE04]        	MOV	WORD [DMAADD],SEARCHBUF
 14183 0000206C 8C1E[2E03]              	MOV	WORD [DMAADD+2],DS
 14184 00002070 E8220E                  	call	DOS_SEARCH_NEXT 	; Find it
 14185 00002073 8F06[2E03]              	pop	word [DMAADD+2]
 14186 00002077 8F06[2C03]              	pop	word [DMAADD]
 14187 0000207B 7203                    	JC	short SearchNoMore
 14188 0000207D E958FF                  	JMP	SearchSet		; Ok set return
 14189                                  
 14190                                  SearchNoMore:
 14191 00002080 C43E[A605]              	LES	DI,[THISFCB]
 14192 00002084 F606[6C05]FF            	TEST	byte [EXTFCB],0FFh
 14193 00002089 7403                    	JZ	short NORMFCB8
 14194 0000208B 83C707                  	ADD	DI,7			; Point past the extension
 14195                                  NORMFCB8:
 14196 0000208E 5B                      	pop	bx			; Get original drive byte
 14197 0000208F 26881D                  	MOV	[ES:DI],BL		; Store the correct "user" drive byte
 14198                                  					;  at the right spot
 14199                                  ; error code is in AX
 14200                                  
 14201 00002092 E9D4E5                  	jmp	FCB_RET_ERR
 14202                                  
 14203                                  ; 17/05/2019 - Retro DOS v4.0
 14204                                  
 14205                                  ; DOSCODE:5EE6h (MSDOS 6.21, MSDOS.SYS)
 14206                                  
 14207                                  ;---------------------------------------------------------------------------
 14208                                  ;
 14209                                  ;   Procedure Name : $FIND_FIRST
 14210                                  ; 
 14211                                  ;   Assembler usage:
 14212                                  ;	    MOV AH, FindFirst
 14213                                  ;	    LDS DX, name
 14214                                  ;	    MOV CX, attr
 14215                                  ;	    INT 21h
 14216                                  ;	; DMA address has datablock
 14217                                  ;
 14218                                  ;   Error Returns:
 14219                                  ;	    AX = error_path_not_found
 14220                                  ;	       = error_no_more_files
 14221                                  ;---------------------------------------------------------------------------
 14222                                  
 14223                                  	; 09/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 14224                                  	; DOSCODE:5ED2h (MSDOS 5.0, MSDOS.SYS)
 14225                                  
 14226                                  _$FIND_FIRST:
 14227 00002095 89D6                    	MOV	SI,DX			; get name in appropriate place
 14228 00002097 36880E[6D05]            	MOV	[SS:SATTRIB],CL		; Search attribute to correct loc
 14229                                  
 14230 0000209C BF[BE03]                	MOV	DI,OPENBUF		; appropriate buffer
 14231                                  
 14232 0000209F E83D4B                  	call	TransPathSet		; convert the path
 14233 000020A2 7305                    	JNC	short Find_it 		; no error, go and look
 14234                                  FindError:
 14235                                  	;mov	al,3
 14236 000020A4 B003                    	mov	al, error_path_not_found ; error and map into one.
 14237                                  	; 09/11/2022
 14238                                  FF_errj:
 14239 000020A6 E9AAE5                  	jmp	SYS_RET_ERR
 14240                                  Find_it:
 14241 000020A9 16                      	push	ss
 14242 000020AA 1F                      	pop	ds
 14243                                  
 14244 000020AB FF36[2C03]              	push	word [DMAADD]
 14245 000020AF FF36[2E03]              	push	word [DMAADD+2]
 14246 000020B3 C706[2C03][BE04]        	MOV	WORD [DMAADD],SEARCHBUF
 14247 000020B9 8C1E[2E03]              	MOV	WORD [DMAADD+2],DS
 14248                                  	; MSDOS 3.3
 14249                                  	;call	DOS_SEARCH_FIRST
 14250                                  	; MSDOS 6.0
 14251 000020BD E89000                  	call	GET_FAST_SEARCH 	; search
 14252 000020C0 8F06[2E03]              	pop	word [DMAADD+2]
 14253 000020C4 8F06[2C03]              	pop	word [DMAADD]
 14254                                  	
 14255                                  	; 16/12/2022
 14256                                  	;JNC	short FindSet 		; no error, transfer info
 14257 000020C8 72DC                    	jc	short FF_errj	; jmp SYS_RET_ERR
 14258                                  	;
 14259                                  	;jmp	SYS_RET_ERR
 14260                                  	; 09/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 14261                                  ;FFF_errj:
 14262                                  	;jmp	short FF_errj	; jmp SYS_RET_ERR
 14263                                  
 14264                                  FindSet:
 14265 000020CA BE[BE04]                	MOV	SI,SEARCHBUF
 14266 000020CD C43E[2C03]              	LES	DI,[DMAADD]
 14267 000020D1 B91500                  	MOV	CX,21
 14268 000020D4 F3A4                    	REP	MOVSB
 14269 000020D6 56                      	PUSH	SI			; Save pointer to start of entry
 14270                                  	;mov	al,[si+0Bh]
 14271 000020D7 8A440B                  	MOV	AL,[SI+dir_entry.dir_attr]
 14272 000020DA AA                      	STOSB
 14273                                  	;add	si,16h ; 22
 14274 000020DB 83C616                  	ADD	SI,dir_entry.dir_time
 14275 000020DE A5                      	MOVSW				; dir_time
 14276 000020DF A5                      	MOVSW				; dir_date
 14277 000020E0 46                      	INC	SI
 14278 000020E1 46                      	INC	SI			; Skip dir_first
 14279 000020E2 A5                      	MOVSW				; dir_size (2 words)
 14280 000020E3 A5                      	MOVSW
 14281 000020E4 5E                      	POP	SI			; Point back to dir_name
 14282 000020E5 E83500                   	CALL	PackName
 14283 000020E8 E95FE5                  	jmp	SYS_RET_OK		; bye with no errors
 14284                                  
 14285                                  ;---------------------------------------------------------------------------
 14286                                  ;
 14287                                  ;   Procedure Name : $FIND_NEXT
 14288                                  ;
 14289                                  ;   Assembler usage:
 14290                                  ;	; dma points at area returned by find_first
 14291                                  ;	    MOV AH, findnext
 14292                                  ;	    INT 21h
 14293                                  ;	; next entry is at dma
 14294                                  ;
 14295                                  ;   Error Returns:
 14296                                  ;	    AX = error_no_more_files
 14297                                  ;---------------------------------------------------------------------------
 14298                                  
 14299                                  	; 09/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 14300                                  _$FIND_NEXT:
 14301 000020EB 16                      	push	ss
 14302 000020EC 07                      	pop	es
 14303                                  
 14304 000020ED BF[BE04]                	MOV	DI,SEARCHBUF
 14305                                  
 14306 000020F0 36C536[2C03]            	LDS	SI,[SS:DMAADD]
 14307                                  
 14308 000020F5 B91500                  	MOV	CX,21
 14309 000020F8 F3A4                    	REP	MOVSB			; Put the search continuation info
 14310                                  					;  in the right place
 14311 000020FA 16                      	push	ss
 14312 000020FB 1F                      	pop	ds			; get ready for search
 14313                                  	
 14314 000020FC FF36[2C03]              	push	word [DMAADD]
 14315 00002100 FF36[2E03]              	push	word [DMAADD+2]
 14316 00002104 C706[2C03][BE04]        	MOV	WORD [DMAADD],SEARCHBUF
 14317 0000210A 8C1E[2E03]              	MOV	WORD [DMAADD+2],DS
 14318 0000210E E8840D                  	call	DOS_SEARCH_NEXT 	; Find it
 14319 00002111 8F06[2E03]              	pop	word [DMAADD+2]
 14320 00002115 8F06[2C03]              	pop	word [DMAADD]
 14321 00002119 73AF                    	JNC	short FindSet 		; No error, set info
 14322                                  	;jmp	SYS_RET_ERR
 14323                                  	; 16/12/2022
 14324 0000211B EB89                    	jmp	short FF_errj	; jmp SYS_RET_ERR
 14325                                  	; 09/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 14326                                  	;jmp	short FFF_errj	; jmp SYS_RET_ERR
 14327                                  
 14328                                  ;---------------------------------------------------------------------------
 14329                                  ;**	PackName - Convert file names from FCB to ASCIZ format.
 14330                                  ;
 14331                                  ;	PackName transfers a file name from DS:SI to ES:DI and converts it to
 14332                                  ;	the ASCIZ format.
 14333                                  ;
 14334                                  ;	ENTRY	(DS:SI) = 11 character FCB or dir entry name
 14335                                  ;		(ES:DI) = destination area (13 bytes)
 14336                                  ;	EXIT	(ds:SI) and (es:DI) advanced
 14337                                  ;	USES	al, CX, SI, DI, Flags  (BUGBUG - not verified - jgl)
 14338                                  ;---------------------------------------------------------------------------
 14339                                  
 14340                                  PackName:
 14341                                  ;	Move over 8 characters to cover the name component, then trim it's
 14342                                  ;	trailing blanks.
 14343                                  
 14344 0000211D B90800                  	MOV	CX,8			; Pack the name
 14345 00002120 F3A4                    	REP	MOVSB			; Move all of it
 14346                                  main_kill_tail:
 14347 00002122 26807DFF20              	CMP	BYTE [ES:DI-1]," "
 14348 00002127 7507                    	JNZ	short find_check_dot
 14349 00002129 4F                      	DEC	DI			; Back up over trailing space
 14350 0000212A 41                      	INC	CX
 14351 0000212B 83F908                  	CMP	CX,8
 14352 0000212E 72F2                    	JB	short main_kill_tail
 14353                                  find_check_dot:
 14354                                  	;CMP	WORD [SI],(" " << 8) | " "
 14355 00002130 813C2020                	cmp     word [si],2020h 
 14356 00002134 7506                    	JNZ	short got_ext 		; Some chars in extension
 14357 00002136 807C0220                	CMP	BYTE [SI+2]," "
 14358 0000213A 7410                    	JZ	short find_done		; No extension
 14359                                  got_ext:
 14360 0000213C B02E                    	MOV	AL,"."	; 2Eh
 14361 0000213E AA                      	STOSB
 14362                                  	;MOV	CX,3
 14363                                  	; 18/12/2022
 14364                                  	;mov	cl,3
 14365                                  	;REP	MOVSB
 14366 0000213F A4                      	movsb
 14367 00002140 A4                      	movsb
 14368 00002141 A4                      	movsb
 14369                                  ext_kill_tail:
 14370 00002142 26807DFF20              	CMP	BYTE [ES:DI-1]," "
 14371 00002147 7503                    	JNZ	short find_done
 14372 00002149 4F                      	DEC	DI			; Back up over trailing space
 14373 0000214A EBF6                    	JMP	short ext_kill_tail
 14374                                  find_done:
 14375 0000214C 31C0                    	XOR	AX,AX
 14376 0000214E AA                      	STOSB				; NUL terminate
 14377 0000214F C3                      	retn
 14378                                  
 14379                                  ;---------------------------------------------------------------------------
 14380                                  
 14381                                  	; 17/05/2019 - Retro DOS v4.0
 14382                                  GET_FAST_SEARCH:
 14383                                  	; 22/07/2018
 14384                                  	; MSDOS 6.0
 14385                                  	; 17/12/2022
 14386 00002150 36800E[1206]04          	OR	byte [ss:DOS34_FLAG+1],(SEARCH_FASTOPEN>>8)  ; 04h
 14387                                  	;OR	word [ss:DOS34_FLAG],SEARCH_FASTOPEN  ; 400h
 14388                                  					;FO.trigger fastopen ;AN000;
 14389                                  	;call	DOS_SEARCH_FIRST
 14390                                  	;retn
 14391                                  	; 17/12/2022
 14392 00002156 E9500C                  	jmp	DOS_SEARCH_FIRST
 14393                                  
 14394                                  ;============================================================================
 14395                                  ; PATH.ASM, MSDOS 6.0, 1991
 14396                                  ;============================================================================
 14397                                  ; 06/08/2018 - Retro DOS v3.0
 14398                                  ; 17/05/2019 - Retro DOS v4.0
 14399                                  
 14400                                  ; DOSCODE:5FB0h (MSDOS 6.21, MSDOS.SYS)
 14401                                  
 14402                                  ;**	Directory related system calls. These will be passed direct text of the
 14403                                  ;	pathname from the user. They will need to be passed through the macro
 14404                                  ;	expander prior to being sent through the low-level stuff. I/O specs are
 14405                                  ;	defined in DISPATCH. The system calls are:
 14406                                  ;
 14407                                  ;	$CURRENT_DIR  Written
 14408                                  ;	$RMDIR	  Written
 14409                                  ;	$CHDIR	  Written
 14410                                  ;	$MKDIR	  Written
 14411                                  ;
 14412                                  ;
 14413                                  ;	Modification history:
 14414                                  ;
 14415                                  ;	    Created: ARR 4 April 1983
 14416                                  ;		 MZ 10 May 1983     CurrentDir implemented
 14417                                  ;		 MZ 11 May 1983     RmDir, ChDir, MkDir implemented
 14418                                  ;		 EE 19 Oct 1983     RmDir no longer allows you to delete a
 14419                                  ;				    current directory.
 14420                                  ;		 MZ 19 Jan 1983     Brain damaged applications rely on success
 14421                                  
 14422                                  ;	I_Need	ThisCDS,DWORD		; pointer to Current CDS
 14423                                  ;	I_Need	WFP_Start,WORD		; pointer to beginning of directory text
 14424                                  ;	I_Need	Curr_Dir_End,WORD	; offset to end of directory part
 14425                                  ;	I_Need	OpenBuf,128		; temp spot for translated name
 14426                                  ;	I_need	fSplice,BYTE		; TRUE => do splice
 14427                                  ;	I_Need	NoSetDir,BYTE		; TRUE => no exact match on splice
 14428                                  ;	I_Need	cMeta,BYTE
 14429                                  ;	I_Need	DrvErr,BYTE					;AN000;
 14430                                  
 14431                                  ;BREAK <$CURRENT_DIR - dump the current directory into user space>
 14432                                  ;----------------------------------------------------------------------------
 14433                                  ;
 14434                                  ;   Procedure Name : $CURRENT_DIR
 14435                                  ;
 14436                                  ;   Assembler usage:
 14437                                  ;		LDS	SI,area
 14438                                  ;		MOV	DL,drive
 14439                                  ;		INT	21h
 14440                                  ;	    ; DS:SI is a pointer to 64 byte area that contains drive
 14441                                  ;	    ; current directory.
 14442                                  ;   Error returns:
 14443                                  ;	    AX = error_invalid_drive
 14444                                  ;
 14445                                  ;----------------------------------------------------------------------------
 14446                                  
 14447                                  _$CURRENT_DIR:
 14448                                  	;06/08/2018 - Retro DOS v3.0
 14449                                  	;IBMDOS.COM (MSDOS 3.3, 1987) - Offset 2D4Eh
 14450 00002159 E8FBF1                  	call	ECritDisk
 14451 0000215C 88D0                    	MOV	AL,DL			; get drive number (0=def, 1=A)
 14452 0000215E E88749                  	call	GetVisDrv		; grab it
 14453 00002161 7310                    	JNC	short CurrentValidate 	; no error -> go and validate dir
 14454                                  CurdirErr:
 14455 00002163 E80CF2                  	call	LCritDisk
 14456                                  
 14457                                  	; MSDOS 3.3
 14458                                  	;mov	al,0Fh
 14459                                  	
 14460                                  	; MSDOS 6.0
 14461 00002166 1E                      	push	ds
 14462 00002167 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 14463 0000216C A0[1006]                	mov	al,[DrvErr]		;IFS.			;AN000;
 14464 0000216F 1F                      	pop	ds
 14465                                  
 14466                                  curdir_errj:
 14467 00002170 E9E0E4                  	jmp	SYS_RET_ERR		;IFS. make noise	;AN000;
 14468                                  
 14469                                  CurrentValidate:
 14470 00002173 1E                      	push	ds			; save destination
 14471 00002174 56                      	push	si
 14472                                  	
 14473                                  	;LDS	SI,[CS:THISCDS] ; MSDOS 3.3
 14474                                  	
 14475                                  	; MSDOS 6.0
 14476 00002175 2E8E1E[0700]            	mov     ds,[cs:DosDSeg]
 14477 0000217A C536[A205]              	lds     si,[THISCDS]
 14478                                  
 14479                                  ; 16/12/2022
 14480                                  %if 0
 14481                                  	; 09/11/2022 (following test instruction is nonsense!)
 14482                                  	; (I am leaving it here for MSDOS 5.0 MSDOS.SYS compatibility)
 14483                                  
 14484                                  	;test	word [si+43h],8000h
 14485                                  	TEST	word [SI+curdir.flags],curdir_isnet
 14486                                  	;jnz	short $+2  ; 09/11/2022	
 14487                                  	jnz	short DoCheck
 14488                                  %endif
 14489                                  
 14490                                  ; Random optimization nuked due to some utilities using GetCurrentDir to do
 14491                                  ; media check.
 14492                                  ;	CMP	word [SI+curdir.ID],0
 14493                                  ;	JZ	short GetDst
 14494                                  DoCheck:
 14495                                  	;MOV	byte [cs:NoSetDir],0	; interested only in contents
 14496                                  
 14497                                  	; MSDOS 6.0
 14498 0000217E 1E                      	push	ds
 14499 0000217F 2E8E1E[0700]            	mov     ds,[cs:DosDSeg]
 14500 00002184 C606[4C03]00            	mov	byte [NoSetDir],0
 14501 00002189 1F                      	pop	ds
 14502                                  
 14503 0000218A BF[BE03]                	MOV	DI,OPENBUF
 14504 0000218D E83721                  	call	ValidateCDS		; output is ES:DI -> CDS
 14505                                  
 14506 00002190 06                      	push	es	 		; swap source and destination
 14507 00002191 57                      	push	di
 14508 00002192 5E                      	pop	si
 14509 00002193 1F                      	pop	ds
 14510                                  GetDst:
 14511 00002194 5F                      	pop	di
 14512 00002195 07                      	pop	es			; get real destination
 14513 00002196 72CB                    	JC	short CurdirErr
 14514                                  	;ADD	SI,curdir.text ; add si,0 ; 09/08/2018
 14515                                  	;
 14516                                  	; 09/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 14517                                  	; DOSCODE:5FE2h (MSDOS 5.0, MSDOS.SYS)
 14518                                  	; 16/12/2022
 14519                                  	;add	si,0  ; add si,curdir.text
 14520                                  	;
 14521                                  	;add	si,[si+4Fh] ; 17/05/2019
 14522 00002198 03744F                  	ADD	SI,[SI+curdir.end]
 14523 0000219B 803C5C                  	CMP	BYTE [SI],'\'	; 5Ch	; root or subdirs present?
 14524 0000219E 7501                    	JNZ	short CurrentCopy
 14525 000021A0 46                      	INC	SI
 14526                                  CurrentCopy:
 14527                                  ;	call	FStrCpy
 14528                                  ;; 10/29/86 E5 char
 14529 000021A1 50                      	PUSH	AX
 14530 000021A2 AC                      	LODSB				; get char
 14531 000021A3 08C0                    	OR	AL,AL
 14532 000021A5 7413                    	JZ	short FOK
 14533 000021A7 3C05                    	CMP	AL,05H
 14534 000021A9 740D                    	JZ	short FCHANGE
 14535 000021AB EB01                    	JMP	short FFF
 14536                                  FCPYNEXT:
 14537 000021AD AC                      	LODSB				; get char
 14538                                  FFF:
 14539 000021AE 3C5C                    	CMP	AL,'\'			; beginning of directory
 14540 000021B0 7508                    	JNZ	short FOK		; no
 14541 000021B2 AA                      	STOSB				; put into user's buffer
 14542 000021B3 AC                      	LODSB				; 1st char of dir is 05?
 14543 000021B4 3C05                    	CMP	AL,05H
 14544 000021B6 7502                    	JNZ	short FOK		; no
 14545                                  FCHANGE:
 14546 000021B8 B0E5                    	MOV	AL,0E5H			; make it E5
 14547                                  FOK:
 14548 000021BA AA                      	STOSB				; put into user's buffer
 14549 000021BB 08C0                    	OR	AL,AL			; final char
 14550 000021BD 75EE                    	JNZ	short FCPYNEXT		; no
 14551 000021BF 58                      	POP	AX
 14552                                  
 14553                                  ;; 10/29/86 E5 char
 14554 000021C0 30C0                    	xor	AL,AL			; MZ 19 Jan 84
 14555 000021C2 E8ADF1                  	call	LCritDisk
 14556 000021C5 E982E4                  	jmp	SYS_RET_OK		; no more, bye!
 14557                                  
 14558                                  ; 17/05/2019 - Retro DOS v4.0
 14559                                  
 14560                                  ; DOSCODE:6029h (MSDOS 6.21, MSDOS.SYS)
 14561                                  
 14562                                  ;BREAK <$RmDir -- Remove a directory>
 14563                                  ;----------------------------------------------------------------------------
 14564                                  ;
 14565                                  ; Procedure Name : $RmDir
 14566                                  ;
 14567                                  ; Inputs:
 14568                                  ;	DS:DX Points to asciz name
 14569                                  ; Function:
 14570                                  ;	Delete directory if empty
 14571                                  ; Returns:
 14572                                  ;	STD XENIX Return
 14573                                  ;	AX = error_path_not_found If path bad
 14574                                  ;	AX = error_access_denied If
 14575                                  ;		Directory not empty
 14576                                  ;		Path not directory
 14577                                  ;		Root directory specified
 14578                                  ;		Directory malformed (. and .. not first two entries)
 14579                                  ;		User tries to delete a current directory
 14580                                  ;	AX = error_current_directory
 14581                                  ;
 14582                                  ;----------------------------------------------------------------------------
 14583                                  
 14584                                  	; 10/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 14585                                  	; DOSCODE:6015h (MSDOS 5.0, MSDOS.SYS)
 14586                                  
 14587                                  _$RMDIR:
 14588 000021C8 52                      	push	dx			; Save ptr to name
 14589 000021C9 1E                      	push	ds
 14590 000021CA 89D6                    	mov	si,dx			; Load ptr into si
 14591 000021CC BF[BE03]                	mov	di,OPENBUF		; di = ptr to buf for trans name
 14592 000021CF 57                      	push	di
 14593 000021D0 E8144A                  	call	TransPathNoSet		; Translate the name
 14594 000021D3 5F                      	pop	di			; di = ptr to buf for trans name
 14595 000021D4 7306                    	jnc	short rmlset		; If transpath succeeded, continue
 14596 000021D6 1F                      	pop	ds
 14597 000021D7 5A                      	pop	dx			; Restore the name
 14598                                  	;mov	al,3
 14599 000021D8 B003                    	mov	al,error_path_not_found ; Otherwise, return an error
 14600                                  	; 16/12/2022
 14601                                  rmdir_errj: ; 10/08/2018
 14602                                  chdir_errj:
 14603 000021DA EB94                    	jmp	short curdir_errj
 14604                                  	;jmp	SYS_RET_ERR
 14605                                  rmlset:
 14606 000021DC 36803E[7A05]FF          	CMP	byte [ss:CMETA],-1	;   if (cMeta >= 0)
 14607 000021E2 7512                    	Jnz	short rmerr		;	return (-1);
 14608 000021E4 16                      	push	ss
 14609 000021E5 07                      	pop	es
 14610 000021E6 30C0                    	xor	al,al			; al = 0 , ie drive a:
 14611                                  rmloop: 
 14612 000021E8 E86E49                  	call	GetCDSFromDrv		; Get curdir for drive in al
 14613 000021EB 720F                    	jc	short rmcont		; If error, exit loop & cont normally
 14614 000021ED E809F0                  	call	StrCmp			; Are the 2 paths the same?
 14615 000021F0 7404                    	jz	short rmerr		; Yes, report error.
 14616 000021F2 FEC0                    	inc	al			; No, inc al to next drive number
 14617 000021F4 EBF2                    	jmp	short rmloop		; Go check next drive.
 14618                                  rmerr:
 14619 000021F6 1F                      	pop	ds
 14620 000021F7 5A                      	pop	dx			; Restore the name
 14621                                  	;mov	al,10h
 14622 000021F8 B010                    	mov	al,error_current_directory ; error
 14623                                  	; 16/12/2022
 14624                                  	; 10/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 14625                                  ;chdir_errj:
 14626 000021FA EBDE                    	jmp	short rmdir_errj
 14627                                  rmcont:
 14628 000021FC 1F                      	pop	ds
 14629 000021FD 5A                      	pop	dx			; Restore the name
 14630 000021FE BE[6A32]                	MOV	SI,DOS_RMDIR
 14631 00002201 EB7C                    	JMP	DoDirCall
 14632                                  
 14633                                  ; 17/05/2019 - Retro DOS v4.0
 14634                                  
 14635                                  ; DOSCODE:6065h (MSDOS 6.21, MSDOS.SYS)
 14636                                  
 14637                                  ;BREAK <$ChDir -- Change current directory on a drive>
 14638                                  ;----------------------------------------------------------------------------
 14639                                  ;
 14640                                  ; $ChDir - Top-level change directory system call.  This call is responsible
 14641                                  ; for setting up the CDS for the specified drive appropriately.  There are
 14642                                  ; several cases to consider:
 14643                                  ;
 14644                                  ;   o	Local, simple CDS.  In this case, we take the input path and convert
 14645                                  ;	it into a WFP.	We verify the existance of this directory and then
 14646                                  ;	copy the WFP into the CDS and set up the ID field to point to the
 14647                                  ;	directory cluster.
 14648                                  ;   o	Net CDS.  We form the path from the root (including network prefix)
 14649                                  ;	and verify its existance (via DOS_Chdir).  If successful, we copy the
 14650                                  ;	WFP back into the CDS.
 14651                                  ;   o	SUBST'ed CDS.  This is no different than the local, simple CDS.
 14652                                  ;   o	JOIN'ed CDS.  This is trouble as there are two CDS's at work.  If we
 14653                                  ;	call TransPath, we will get the PHYSICAL CDS that the path refers to
 14654                                  ;	and the PHYSICAL WFP that the input path refers to.  This is perfectly
 14655                                  ;	good for the validation but not for currency.  We call TransPathNoSet
 14656                                  ;	to process the path but to return the logical CDS and the logical
 14657                                  ;	path.  We then copy the logical path into the logical CDS.
 14658                                  ;
 14659                                  ; Inputs:
 14660                                  ;	DS:DX Points to asciz name
 14661                                  ; Returns:
 14662                                  ;	STD XENIX Return
 14663                                  ;	AX = chdir_path_not_found if error
 14664                                  ;
 14665                                  ;----------------------------------------------------------------------------
 14666                                  
 14667                                  _$CHDIR:
 14668 00002203 BF[BE03]                	MOV	DI,OPENBUF		; spot for translated name
 14669 00002206 89D6                    	MOV	SI,DX			; get source
 14670 00002208 E8D049                  	call	TransPath		; go munge the path and get real CDS
 14671 0000220B 7304                    	JNC	short ChDirCrack	; no errors, try path
 14672                                  ChDirErrP:
 14673                                  	;mov	al,3
 14674 0000220D B003                    	MOV	AL,error_path_not_found
 14675                                  ChDirErr:
 14676                                  	;jmp	SYS_RET_ERR 	; oops!
 14677                                  	; 10/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 14678 0000220F EBC9                    	jmp	short chdir_errj
 14679                                  
 14680                                  ChDirCrack:
 14681 00002211 803E[7A05]FF            	CMP	byte [CMETA],-1		; No meta chars allowed.
 14682 00002216 75F5                    	JNZ	short ChDirErrP
 14683                                  
 14684                                  ; We cannot do a ChDir (yet) on a raw CDS. This is treated as a path not
 14685                                  ; found.
 14686                                  
 14687 00002218 C43E[A205]              	LES	DI,[THISCDS]
 14688 0000221C 83FFFF                  	CMP	DI,-1			;   if (ThisCDS == NULL)
 14689 0000221F 74EC                    	JZ	short ChDirErrP		;	error ();
 14690                                  
 14691                                  ; Find out if the directory exists.
 14692                                  
 14693 00002221 E80310                  	call	DOS_CHDIR
 14694                                  	;Jc	short ChDirErr
 14695                                  	; 16/12/2022
 14696 00002224 72B4                    	jc	short chdir_errj
 14697                                  ;
 14698                                  ; Get back CDS to see if a join as seen. Set the currency pointer (only if
 14699                                  ; not network). If one was seen, all we need to do is copy in the text
 14700                                  ;
 14701 00002226 C43E[A205]              	LES	DI,[THISCDS]
 14702                                  	;test	word [es:di+43h],2000h
 14703                                  	; 17/12/2022
 14704 0000222A 26F6454420              	test	byte [ES:DI+curdir.flags+1],curdir_splice>>8
 14705                                  	;TEST	word [ES:DI+curdir.flags],curdir_splice
 14706 0000222F 7425                    	JZ	short GotCDS
 14707                                  
 14708                                  ; The CDS was joined. Let's go back and grab the logical CDS.
 14709                                  
 14710 00002231 06                      	push	es	
 14711 00002232 57                      	push	di
 14712 00002233 51                      	push	cx			; save CDS and cluster...
 14713 00002234 E859E2                  	call	Get_User_Stack		; get original text
 14714                                  	
 14715                                  	;mov	di,[si+6]
 14716 00002237 8B7C06                  	MOV	DI,[SI+user_env.user_DX]
 14717                                  	;mov	ds,[si+0Eh]
 14718 0000223A 8E5C0E                  	MOV	DS,[SI+user_env.user_DS]
 14719                                  	
 14720 0000223D BE[BE03]                	MOV	SI,OPENBUF		; spot for translated name
 14721 00002240 87F7                    	XCHG	SI,DI
 14722 00002242 30C0                    	XOR	AL,AL			; do no splicing
 14723 00002244 57                      	push	di
 14724 00002245 E89F49                  	call	TransPathNoSet		; Munge path
 14725 00002248 5E                      	pop	si
 14726                                  
 14727                                  ; There should NEVER be an error here.
 14728                                  
 14729                                  ;IF FALSE
 14730                                  ;	JNC SKipErr
 14731                                  ;	fmt <>,<>,<"$p: Internal CHDIR error\n">
 14732                                  ;SkipErr:
 14733                                  ;ENDIF
 14734 00002249 C43E[A205]              	LES	DI,[THISCDS]		; get new CDS
 14735                                  	;mov	word [es:di+49h],-1
 14736 0000224D 26C74549FFFF            	MOV	word [ES:DI+curdir.ID],-1
 14737                                  					; no valid cluster here...
 14738 00002253 59                      	pop	cx
 14739 00002254 5F                      	pop	di
 14740 00002255 07                      	pop	es
 14741                                  
 14742                                  ; ES:DI point to the physical CDS, CX is the ID (local only)
 14743                                  
 14744                                  GotCDS:
 14745                                  
 14746                                  ; wfp_start points to the text. See if it is long enough
 14747                                  
 14748                                  	; MSDOS 3.3
 14749                                  	;push	ss
 14750                                  	;pop	ds
 14751                                  	;mov	si,[WFP_START]
 14752                                  	;push	cx
 14753                                  	;call	DStrLen
 14754                                  	;cmp	cx,67 ; cmp cx,DIRSTRLEN
 14755                                  	;pop	cx
 14756                                  	;ja	short ChDirErrP
 14757                                  
 14758                                  	; MSDOS 6.0
 14759 00002256 E85000                  	CALL	Check_PathLen		;PTM.		;AN000;
 14760 00002259 77B2                    	JA	short ChDirErrP
 14761                                  	; MSDOS 3.3 & MSDOS 6.0
 14762                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet ; 8000h
 14763                                  	; 17/12/2022
 14764 0000225B 26F6454480              	test	byte [ES:DI+curdir.flags+1],curdir_isnet>>8
 14765 00002260 7512                    	JNZ	short SkipRecency
 14766                                  	; MSDOS 6.0
 14767                                  	;test	word [es:di+43h],2000h
 14768                                  	; 17/12/2022
 14769 00002262 26F6454420              	test	byte [ES:DI+curdir.flags+1],curdir_splice>>8
 14770                                  	;TEST	word [ES:DI+curdir.flags],curdir_splice 
 14771                                  					;PTM. for Join and Subst ;AN000;
 14772 00002267 7403                    	JZ	short setdirclus	;PTM.		;AN000;
 14773 00002269 B9FFFF                  	MOV	CX,-1			;PTM.		;AN000;
 14774                                  setdirclus:
 14775                                  	;mov	[es:di+49h],cx
 14776 0000226C 26894D49                	MOV	[ES:DI+curdir.ID],CX
 14777 00002270 C43E[A205]              	LES	DI,[THISCDS]		; get logical CDS
 14778                                  SkipRecency:
 14779 00002274 E8B3EF                  	call	FStrCpy
 14780 00002277 30C0                    	XOR	AL,AL
 14781                                  mkdir_ok:
 14782 00002279 E9CEE3                  	jmp	SYS_RET_OK
 14783                                  
 14784                                  ; 17/05/2019 - Retro DOS v4.0
 14785                                  
 14786                                  ; DOSCODE:60E1h (MSDOS 6.21, MSDOS.SYS)
 14787                                  
 14788                                  ;BREAK <$MkDir - Make a directory entry>
 14789                                  ;---------------------------------------------------------------------------
 14790                                  ;
 14791                                  ; Procedure Name : $MkDir
 14792                                  ; Inputs:
 14793                                  ;	DS:DX Points to asciz name
 14794                                  ; Function:
 14795                                  ;	Make a new directory
 14796                                  ; Returns:
 14797                                  ;	STD XENIX Return
 14798                                  ;	AX = mkdir_path_not_found if path bad
 14799                                  ;	AX = mkdir_access_denied  If
 14800                                  ;		Directory cannot be created
 14801                                  ;		Node already exists
 14802                                  ;		Device name given
 14803                                  ;		Disk or directory(root) full
 14804                                  ;---------------------------------------------------------------------------
 14805                                  
 14806                                  	; 10/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 14807                                  
 14808                                  _$MKDIR:
 14809 0000227C BE[3731]                	MOV	SI,DOS_MKDIR
 14810                                  DoDirCall:
 14811 0000227F BF[BE03]                	MOV	DI,OPENBUF		; spot for translated name
 14812                                  
 14813 00002282 56                      	push	si
 14814 00002283 89D6                    	MOV	SI,DX			; get source
 14815 00002285 E85349                  	call	TransPath		; go munge the path
 14816 00002288 5E                      	pop	si
 14817 00002289 7305                    	JNC	short MkDirCrack	; no errors, try path
 14818                                  MkErrP:
 14819 0000228B B003                    	MOV	AL,error_path_not_found	; oops!
 14820                                  MkErr:
 14821 0000228D E9C3E3                  	jmp	SYS_RET_ERR
 14822                                  MkDirCrack:
 14823 00002290 36803E[7A05]FF          	CMP	byte [SS:CMETA],-1
 14824 00002296 75F3                    	JNZ	short MkErrP
 14825                                  
 14826                                  	; MSDOS 3.3
 14827                                  	;push	ss
 14828                                  	;pop	ds
 14829                                  	;call	si
 14830                                  	;jb	short MkErr
 14831                                  	;;jmp	short mkdir_ok
 14832                                  	;jmp	SYS_RET_OK
 14833                                  
 14834                                  	; MSDOS 6.0
 14835 00002298 56                      	PUSH	SI			;PTM.			;AN000;
 14836 00002299 E80D00                  	CALL	Check_PathLen		;PTM. check path len > 67 ? ;AN000;
 14837 0000229C 5E                      	POP	SI			;PTM.			;AN000;
 14838 0000229D 7604                    	JBE	short pathok		;PTM.			;AN000;
 14839                                  	;mov	al,5
 14840 0000229F B005                    	MOV	AL,error_access_denied	;PTM. ops!
 14841                                  	;jmp	SYS_RET_ERR		;PTM.
 14842 000022A1 EBEA                    	jmp	short MkErr
 14843                                  pathok:
 14844 000022A3 FFD6                    	CALL	SI			; go get file
 14845 000022A5 72E6                    	JC	short MkErr		; no errors
 14846                                  	; 16/12/2022
 14847                                  	; 10/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 14848 000022A7 EBD0                    	jmp	short mkdir_ok
 14849                                  	;jmp	SYS_RET_OK
 14850                                  
 14851                                  ;----------------------------------------------------------------------------
 14852                                  ;
 14853                                  ; Procedure Name : Check_PathLen
 14854                                  ;
 14855                                  ; Inputs:
 14856                                  ;	nothing
 14857                                  ; Function:
 14858                                  ;	check if final path length greater than 67
 14859                                  ; Returns:
 14860                                  ;	Above flag set if > 67
 14861                                  ;
 14862                                  ;---------------------------------------------------------------------------
 14863                                  
 14864                                  Check_PathLen:
 14865                                  	; 09/09/2018
 14866                                  	;mov	SI,[WFP_START]
 14867 000022A9 368B36[B205]            	MOV	SI,[SS:WFP_START] ; MSDOS 6.0
 14868                                  Check_PathLen2:
 14869 000022AE 16                      	push	ss
 14870 000022AF 1F                      	pop	ds
 14871                                  	;mov	SI,[WFP_START]	  ; MSDOS 3.3
 14872 000022B0 51                      	push	CX	
 14873 000022B1 E88DEF                  	CALL	DStrLen
 14874 000022B4 83F943                  	CMP	CX,DIRSTRLEN ; 67
 14875 000022B7 59                      	POP	CX
 14876 000022B8 C3                      	retn
 14877                                  
 14878                                  ;============================================================================
 14879                                  ; IOCTL.ASM, MSDOS 6.0, 1991
 14880                                  ;============================================================================
 14881                                  ; 07/08/2018 - Retro DOS v3.0
 14882                                  ; 17/05/2019 - Retro DOS v4.0
 14883                                  
 14884                                  ;**	IOCTL system call.
 14885                                  ;----------------------------------------------------------------------------
 14886                                  ;	$IOCTL
 14887                                  ;
 14888                                  ;	  Revision history:
 14889                                  ;
 14890                                  ;		Created: ARR 4 April 1983
 14891                                  ;
 14892                                  ;		GenericIOCTL added:		KGS	22 April 1985
 14893                                  ;
 14894                                  ;		A000	version 4.00	Jan. 1988
 14895                                  ;
 14896                                  ;		Used jump table to dispatch IOCTL functions. HKN 3/12/90
 14897                                  ;
 14898                                  
 14899                                  ;BREAK <IOCTL - munge on a handle to do device specific stuff>
 14900                                  ;---------------------------------------------------------------------------
 14901                                  ;
 14902                                  ;   Assembler usage:
 14903                                  ;	    MOV     BX, Handle
 14904                                  ;	    MOV     DX, Data
 14905                                  ;
 14906                                  ;	(or LDS     DX,BUF
 14907                                  ;	    MOV     CX,COUNT)
 14908                                  ;
 14909                                  ;	    MOV     AH, Ioctl
 14910                                  ;	    MOV     AL, Request
 14911                                  ;	    INT     21h
 14912                                  ;
 14913                                  ;   AH = 0  Return a combination of low byte of sf_flags and device driver
 14914                                  ;	    attribute word in DX, handle in BX:
 14915                                  ;	    DH = high word of device driver attributes
 14916                                  ;	    DL = low byte of sf_flags
 14917                                  ;	 1  Set the bits contained in DX to sf_flags.  DH MUST be 0.  Handle
 14918                                  ;	    in BX.
 14919                                  ;	 2  Read CX bytes from the device control channel for handle in BX
 14920                                  ;	    into DS:DX.  Return number read in AX.
 14921                                  ;	 3  Write CX bytes to the device control channel for handle in BX from
 14922                                  ;	    DS:DX.  Return bytes written in AX.
 14923                                  ;	 4  Read CX bytes from the device control channel for drive in BX
 14924                                  ;	    into DS:DX.  Return number read in AX.
 14925                                  ;	 5  Write CX bytes to the device control channel for drive in BX from
 14926                                  ;	    DS:DX.  Return bytes written in AX.
 14927                                  ;	 6  Return input status of handle in BX. If a read will go to the
 14928                                  ;	    device, AL = 0FFh, otherwise 0.
 14929                                  ;	 7  Return output status of handle in BX. If a write will go to the
 14930                                  ;	    device, AL = 0FFh, otherwise 0.
 14931                                  ;	 8  Given a drive in BX, return 1 if the device contains non-
 14932                                  ;	    removable media, 0 otherwise.
 14933                                  ;	 9  Return the contents of the device attribute word in DX for the
 14934                                  ;	    drive in BX.  0200h is the bit for shared.	1000h is the bit for
 14935                                  ;	    network. 8000h is the bit for local use.
 14936                                  ;	 A  Return 8000h if the handle in BX is for the network or not.
 14937                                  ;	 B  Change the retry delay and the retry count for the system. BX is
 14938                                  ;	    the count and CX is the delay.
 14939                                  ;
 14940                                  ;   Error returns:
 14941                                  ;	    AX = error_invalid_handle
 14942                                  ;	       = error_invalid_function
 14943                                  ;	       = error_invalid_data
 14944                                  ;
 14945                                  ;-------------------------------------------------------------------------------
 14946                                  ;
 14947                                  ;   This is the documentation copied from DOS 4.0 it is much better
 14948                                  ;   than the above
 14949                                  ;
 14950                                  ;	There are several basic forms of IOCTL calls:
 14951                                  ;
 14952                                  ;
 14953                                  ;	** Get/Set device information:	**
 14954                                  ;
 14955                                  ;	ENTRY	(AL) = function code
 14956                                  ;		  0 - Get device information
 14957                                  ;		  1 - Set device information
 14958                                  ;		(BX) = file handle
 14959                                  ;		(DX) = info for "Set Device Information"
 14960                                  ;	EXIT	'C' set if error
 14961                                  ;		  (AX) = error code
 14962                                  ;		'C' clear if OK
 14963                                  ;		  (DX) = info for "Get Device Information"
 14964                                  ;	USES	ALL
 14965                                  ;
 14966                                  ;
 14967                                  ;	**  Read/Write Control Data From/To Handle  **
 14968                                  ;
 14969                                  ;	ENTRY	(AL) = function code
 14970                                  ;		  2 - Read device control info
 14971                                  ;		  3 - Write device control info
 14972                                  ;		(BX) = file handle
 14973                                  ;		(CX) = transfer count
 14974                                  ;		(DS:DX) = address for data
 14975                                  ;	EXIT	'C' set if error
 14976                                  ;		  (AX) = error code
 14977                                  ;		'C' clear if OK
 14978                                  ;		  (AX) = count of bytes transfered
 14979                                  ;	USES	ALL
 14980                                  ;
 14981                                  ;
 14982                                  ;	**  Read/Write Control Data From/To Block Device  **
 14983                                  ;
 14984                                  ;	ENTRY	(AL) = function code
 14985                                  ;		  4 - Read device control info
 14986                                  ;		  5 - Write device control info
 14987                                  ;		(BL) = Drive number (0=default, 1='A', 2='B', etc)
 14988                                  ;		(CX) = transfer count
 14989                                  ;		(DS:DX) = address for data
 14990                                  ;	EXIT	'C' set if error
 14991                                  ;		  (AX) = error code
 14992                                  ;		'C' clear if OK
 14993                                  ;		  (AX) = count of bytes transfered
 14994                                  ;	USES	ALL
 14995                                  ;
 14996                                  ;
 14997                                  ;	**  Get Input/Output Status  **
 14998                                  ;
 14999                                  ;	ENTRY	(AL) = function code
 15000                                  ;		  6 - Get Input status
 15001                                  ;		  7 - Get Output Status
 15002                                  ;		(BX) = file handle
 15003                                  ;	EXIT	'C' set if error
 15004                                  ;		  (AX) = error code
 15005                                  ;		'C' clear if OK
 15006                                  ;		  (AL) = 00 if not ready
 15007                                  ;		  (AL) = FF if ready
 15008                                  ;	USES	ALL
 15009                                  ;
 15010                                  ;
 15011                                  ;	**  Get Drive Information  **
 15012                                  ;
 15013                                  ;	ENTRY	(AL) = function code
 15014                                  ;		  8 - Check for removable media
 15015                                  ;		  9 - Get device attributes
 15016                                  ;		(BL) = Drive number (0=default, 1='A', 2='B', etc)
 15017                                  ;	EXIT	'C' set if error
 15018                                  ;		  (AX) = error code
 15019                                  ;		'C' clear if OK
 15020                                  ;		  (AX) = 0/1 media is removable/fixed (func. 8)
 15021                                  ;		  (DX) = device attribute word (func. 9)
 15022                                  ;	USES	ALL
 15023                                  ;
 15024                                  ;
 15025                                  ;	**  Get Redirected bit	**
 15026                                  ;
 15027                                  ;	ENTRY	(AL) = function code
 15028                                  ;		  0Ah - Network stuff
 15029                                  ;		(BX) = file handle
 15030                                  ;	EXIT	'C' set if error
 15031                                  ;		  (AX) = error code
 15032                                  ;		'C' clear if OK
 15033                                  ;		  (DX) = SFT flags word, 8000h set if network file
 15034                                  ;	USES	ALL
 15035                                  ;
 15036                                  ;
 15037                                  ;	**  Change sharer retry parameters  **
 15038                                  ;
 15039                                  ;	ENTRY	(AL) = function code
 15040                                  ;		  0Bh - Set retry parameters
 15041                                  ;		(CX) = retry loop count
 15042                                  ;		(DX) = number of retries
 15043                                  ;	EXIT	'C' set if error
 15044                                  ;		  (AX) = error code
 15045                                  ;		'C' clear if OK
 15046                                  ;	USES	ALL
 15047                                  ;
 15048                                  ;
 15049                                  ;   =================================================================
 15050                                  ;
 15051                                  ;	**  New Standard Control  **
 15052                                  ;
 15053                                  ;	ALL NEW IOCTL FACILITIES SHOULD USE THIS FORM.	THE OTHER
 15054                                  ;	FORMS ARE OBSOLETE.
 15055                                  ;
 15056                                  ;   =================================================================
 15057                                  ;
 15058                                  ;	ENTRY	(AL) = function code
 15059                                  ;		  0Ch - Control Function subcode
 15060                                  ;		(BX) = File Handle
 15061                                  ;		(CH) = Category Indicator
 15062                                  ;		(CL) = Function within category
 15063                                  ;		(DS:DX) = address for data, if any
 15064                                  ;		(SI) = Passed to device as argument, use depends upon function
 15065                                  ;		(DI) = Passed to device as argument, use depends upon function
 15066                                  ;	EXIT	'C' set if error
 15067                                  ;		  (AX) = error code
 15068                                  ;		'C' clear if OK
 15069                                  ;		  (SI) = Return value, meaning is function dependent
 15070                                  ;		  (DI) = Return value, meaning is function dependent
 15071                                  ;		  (DS:DX) = Return address, use is function dependent
 15072                                  ;	USES	ALL
 15073                                  ;
 15074                                  ;    ============== Generic IOCTL Definitions for DOS 3.2 ============
 15075                                  ;     (See inc\ioctl.inc for more info)
 15076                                  ;
 15077                                  ;	ENTRY	(AL) = function code
 15078                                  ;		  0Dh - Control Function subcode
 15079                                  ;		(BL) = Drive Number (0 = Default, 1= 'A')
 15080                                  ;		(CH) = Category Indicator
 15081                                  ;		(CL) = Function within category
 15082                                  ;		(DS:DX) = address for data, if any
 15083                                  ;		(SI) = Passed to device as argument, use depends upon function
 15084                                  ;		(DI) = Passed to device as argument, use depends upon function
 15085                                  ;
 15086                                  ;	EXIT	'C' set if error
 15087                                  ;		  (AX) = error code
 15088                                  ;		'C' clear if OK
 15089                                  ;		  (DS:DX) = Return address, use is function dependent
 15090                                  ;	USES	ALL
 15091                                  ;
 15092                                  ;---------------------------------------------------------------------------
 15093                                  	
 15094                                  	; 17/05/2019 - Retro DOS v4.0
 15095                                  	; DOSCODE:611Eh (MSDOS 6.21, MSDOS.SYS)
 15096                                  
 15097                                  	; 11/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 15098                                  	; DOSCODE:610Ah (MSDOS 5.0, MSDOS.SYS)
 15099                                  
 15100                                  IOCTLJMPTABLE:	;label	word
 15101                                  	; MSDOS 3.3 (& MSDOS 6.0)
 15102 000022B9 [F722]                  	dw	ioctl_getset_data	; 0
 15103 000022BB [F722]                  	dw	ioctl_getset_data   	; 1
 15104 000022BD [4723]                  	dw	ioctl_control_string	; 2
 15105 000022BF [4723]                  	dw	ioctl_control_string	; 3
 15106 000022C1 [9B24]                  	dw	ioctl_get_dev		; 4
 15107 000022C3 [9B24]                  	dw	ioctl_get_dev		; 5
 15108 000022C5 [6123]                  	dw	ioctl_status		; 6
 15109 000022C7 [6123]                  	dw	ioctl_status		; 7
 15110 000022C9 [0224]                  	dw	ioctl_rem_media		; 8
 15111 000022CB [4024]                  	dw	ioctl_drive_attr	; 9
 15112 000022CD [8D24]                  	dw	ioctl_handle_redir	; A
 15113 000022CF [7D23]                  	dw	Set_Retry_Parameters	; B
 15114 000022D1 [8B23]                  	dw	GENERICIOCTLHANDLE	; C
 15115 000022D3 [A223]                  	dw	GENERICIOCTL		; D
 15116                                  	; MSDOS 6.0 (& MSDOS 3.3)
 15117 000022D5 [4C25]                  	dw	ioctl_drive_owner	; E
 15118 000022D7 [4C25]                  	dw	ioctl_drive_owner	; F
 15119                                  	; MSDOS 6.0
 15120 000022D9 [8B23]                  	dw	query_handle_support	; 10h
 15121 000022DB [A223]                  	dw	query_device_support	; 11h
 15122                                  
 15123                                  	; 11/11/2022
 15124                                  _$IOCTL:
 15125 000022DD 8CDE                    	MOV	SI,DS			; Stash DS for calls 2,3,4 and 5
 15126 000022DF 16                      	push	ss
 15127 000022E0 1F                      	pop	ds			;hkn; SS is DOSDATA
 15128                                  
 15129                                  	; MSDOS 3.3
 15130                                  	;cmp	al,0Fh 
 15131                                  	; MSDOS 6.0
 15132 000022E1 3C11                    	cmp	al,11h			; al must be between 0 & 11h
 15133 000022E3 770F                    	ja	short ioctl_bad_funj2	; if not bad function #
 15134                                  
 15135                                  	; 28/05/2019
 15136 000022E5 50                      	push	AX			; Need to save AL for generic IOCTL
 15137 000022E6 89C7                    	mov	di,ax			; di NOT a PARM
 15138 000022E8 81E7FF00                	and	di,0FFh			; di = al
 15139 000022EC D1E7                    	shl	di,1			; di = index into jmp table
 15140 000022EE 58                      	pop	AX			; Restore AL for generic IOCTL
 15141                                  
 15142 000022EF 2EFFA5[B922]            	jmp	word [CS:DI+IOCTLJMPTABLE]
 15143                                  
 15144                                  ioctl_bad_funj2:
 15145 000022F4 E90301                  	JMP	ioctl_bad_fun  ; 10/08/2018
 15146                                  
 15147                                  ;--------------------------------------------------------------------------
 15148                                  ;
 15149                                  ; IOCTL: AL = 0,1
 15150                                  ;
 15151                                  ; ENTRY: DS = DOSDATA
 15152                                  ;
 15153                                  ;--------------------------------------------------------------------------
 15154                                  
 15155                                  ioctl_getset_data:
 15156                                  	; MSDOS 6.0
 15157 000022F7 E8E643                  	call	SFFromHandle		; ES:DI -> SFT
 15158 000022FA 7305                    	JNC	short ioctl_check_permissions ; have valid handle
 15159                                  ioctl_bad_handle:
 15160                                  	;mov	al,6
 15161 000022FC B006                    	mov	al,error_invalid_handle
 15162                                  ioctl_error:
 15163 000022FE E952E3                  	jmp	SYS_RET_ERR
 15164                                  
 15165                                  ioctl_check_permissions:
 15166 00002301 3C00                    	CMP	AL,0
 15167                                  	;mov	al,[es:di+5]
 15168 00002303 268A4505                	MOV	AL,[ES:DI+SF_ENTRY.sf_flags]; Get low byte of flags
 15169 00002307 741B                    	JZ	short ioctl_read	; read the byte
 15170                                  
 15171 00002309 08F6                    	or	dh,dh
 15172 0000230B 7404                    	JZ	short ioctl_check_device ; can I set with this data?
 15173                                  	;mov	al,0Dh
 15174 0000230D B00D                    	mov	al,error_invalid_data	; no DH <> 0
 15175                                  	;jmp	SYS_RET_ERR
 15176 0000230F EBED                    	jmp	short ioctl_error
 15177                                  
 15178                                  ioctl_check_device:
 15179 00002311 A880                    	test	AL,devid_device  ; 80h	; can I set this handle?
 15180 00002313 74DF                    	jz	short ioctl_bad_funj2
 15181 00002315 80CA80                  	OR	DL,devid_device 	; Make sure user doesn't turn off the
 15182                                  					;   device bit!! He can muck with the
 15183                                  					;   others at will.
 15184 00002318 C606[2303]04            	MOV	byte [EXTERR_LOCUS],errLOC_SerDev ; 4
 15185 0000231D 26885505                	MOV	BYTE [ES:DI+SF_ENTRY.sf_flags],DL  ;AC000;MS.; Set flags
 15186                                  ioctl_ok:
 15187 00002321 E926E3                  	jmp	SYS_RET_OK
 15188                                  
 15189                                  ioctl_read:
 15190 00002324 C606[2303]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk  ; 2
 15191 00002329 30E4                    	XOR	AH,AH
 15192 0000232B A880                    	test	AL,devid_device 	; Should I set high byte
 15193 0000232D 740D                    	JZ	short ioctl_no_high	; no
 15194 0000232F C606[2303]04            	MOV	byte [EXTERR_LOCUS],errLOC_SerDev ; 4
 15195                                  	;les	di,[es:di+7]
 15196 00002334 26C47D07                	LES	DI,[ES:DI+SF_ENTRY.sf_devptr] ; Get device pointer
 15197                                  	;mov	ah,[es:di+5]
 15198 00002338 268A6505                	MOV	AH,[ES:DI+SYSDEV.ATT+1] ; Get high byte
 15199                                  ioctl_no_high:
 15200 0000233C 89C2                    	MOV	DX,AX
 15201                                  ioctl_set_dx:	; 16/12/2022
 15202 0000233E E84FE1                  	call	Get_User_Stack
 15203                                  	;mov	[si+6],dx
 15204 00002341 895406                  	MOV	[SI+user_env.user_DX],DX
 15205                                  	;;jmp	SYS_RET_OK
 15206                                  	; 11/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 15207                                  ioctl_ok_j:
 15208                                  	; 16/12/2022
 15209 00002344 E906E3                  	jmp	SYS_RET_OK_clc	 ; (after 'Get_User_Stack') 
 15210                                  	;jmp	short ioctl_ok
 15211                                  	; 26/07/2019
 15212                                  	;jmp	SYS_RET_OK_clc
 15213                                  
 15214                                  ;--------------------------------------------------------------------------
 15215                                  ;
 15216                                  ; IOCTL: AL = 2,3
 15217                                  ;
 15218                                  ; ENTRY: DS = DOSDATA
 15219                                  ;	 SI = user's DS
 15220                                  ;
 15221                                  ;--------------------------------------------------------------------------
 15222                                  
 15223                                  	; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 15224                                  ioctl_control_string:
 15225 00002347 E89643                  	call	SFFromHandle		; ES:DI -> SFT
 15226 0000234A 72B0                    	JC	short ioctl_bad_handle	; invalid handle
 15227                                  	; 07/12/2022
 15228                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device ; can I?
 15229                                  	;jz	short ioctl_bad_funj2			; No it is a file
 15230                                  	; MSDOS 5.0 & MSDOS 6.0
 15231 0000234C 26F6450580              	test	byte [ES:DI+SF_ENTRY.sf_flags],devid_device ; can I?
 15232 00002351 74A1                    	jz	short ioctl_bad_funj2			; No it is a file
 15233 00002353 C606[2303]04            	MOV	byte [EXTERR_LOCUS],errLOC_SerDev
 15234 00002358 26C47D07                	LES	DI,[ES:DI+SF_ENTRY.sf_devptr] ; Get device pointer
 15235 0000235C 30DB                    	XOR	BL,BL			; Unit number of char dev = 0
 15236 0000235E E94201                  	JMP	ioctl_do_string
 15237                                  
 15238                                  ;--------------------------------------------------------------------------
 15239                                  ;
 15240                                  ; IOCTL: AL = 6,7
 15241                                  ;
 15242                                  ; ENTRY: DS = DOSDATA
 15243                                  ;
 15244                                  ;--------------------------------------------------------------------------
 15245                                  
 15246                                  ioctl_status:
 15247 00002361 B401                    	MOV	AH,1
 15248 00002363 2C06                    	SUB	AL,6			; 6=0,7=1
 15249 00002365 7402                    	JZ	short ioctl_get_status
 15250 00002367 B403                    	MOV	AH,3
 15251                                  ioctl_get_status:
 15252 00002369 50                      	PUSH	AX
 15253 0000236A E85013                  	call	GET_IO_SFT
 15254 0000236D 58                      	POP	AX
 15255                                  	;JNC	short DO_IOFUNC
 15256                                  	;JMP	short ioctl_bad_handle	; invalid SFT
 15257                                  	; 16/12/2022
 15258 0000236E 728C                    	jc	short ioctl_bad_handle
 15259                                  DO_IOFUNC:
 15260 00002370 E88F21                  	call	IOFUNC
 15261 00002373 88C4                    	MOV	AH,AL
 15262 00002375 B0FF                    	MOV	AL,0FFH
 15263 00002377 7502                    	JNZ	short ioctl_status_ret
 15264 00002379 FEC0                    	INC	AL
 15265                                  ioctl_status_ret:
 15266                                  	;jmp	SYS_RET_OK
 15267                                  	; 11/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 15268                                  	;jmp	short ioctl_ok_j
 15269                                  	; 16/12/2022
 15270 0000237B EBA4                    	jmp	short ioctl_ok
 15271                                  
 15272                                  ;--------------------------------------------------------------------------
 15273                                  ;
 15274                                  ; IOCTL: AL = B
 15275                                  ;
 15276                                  ; ENTRY: DS = DOSDATA
 15277                                  ;
 15278                                  ;--------------------------------------------------------------------------
 15279                                  
 15280                                  Set_Retry_Parameters:
 15281                                  	; 09/09/2018
 15282 0000237D 890E[1C00]              	MOV	[RetryLoop],CX		; 0 retry loop count allowed
 15283 00002381 09D2                    	OR	DX,DX			; zero retries not allowed
 15284 00002383 7475                    	JZ	short ioctl_bad_fun
 15285 00002385 8916[1A00]              	MOV	[RetryCount],DX		; Set new retry count
 15286                                  doneok:
 15287                                  	;jmp	SYS_RET_OK		; Done
 15288                                  	; 11/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 15289                                  	;jmp	short ioctl_status_ret
 15290                                  	; 16/12/2022
 15291 00002389 EB96                    	jmp	short ioctl_ok	 ; jmp SYS_RET_OK
 15292                                  
 15293                                  ;--------------------------------------------------------------------------
 15294                                  ;
 15295                                  ; Generic IOCTL entry point. AL = C, D, 10h, 11h
 15296                                  ;
 15297                                  ;	here we invoke the Generic IOCTL using the IOCTL_Req structure.
 15298                                  ;	SI:DX -> Users Device Parameter Table
 15299                                  ;	IOCALL -> IOCTL_Req structure
 15300                                  ;
 15301                                  ; 	If on entry AL >= IOCTL_QUERY_HANDLE the function is a
 15302                                  ;	QueryIOCtlSupport call ELSE it's a standard generic IOCtl
 15303                                  ;	call.
 15304                                  ;
 15305                                  ; BUGBUG: Don't push anything on the stack between GENERIOCTL: and 
 15306                                  ;         the call to Check_If_Net because Check_If_Net gets our
 15307                                  ;         return address off the stack if the drive is invalid.
 15308                                  ;
 15309                                  ;--------------------------------------------------------------------------
 15310                                  
 15311                                  query_handle_support:	; Entry point for handles
 15312                                  GENERICIOCTLHANDLE:
 15313 0000238B E85243                  	call	SFFromHandle		; Get SFT for device.
 15314 0000238E 726F                    	jc	short ioctl_bad_handlej
 15315                                  
 15316                                  	;test	word [es:di+5],8000h
 15317                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet	; M031;
 15318                                  	;test	byte [es:di+6],80h
 15319 00002390 26F6450680              	test	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
 15320 00002395 7563                    	jnz	short ioctl_bad_fun	; Cannot do this over net.
 15321                                  
 15322 00002397 C606[2303]04            	mov	byte [EXTERR_LOCUS],errLOC_SerDev ; 4
 15323                                  	;les	di,[es:di+7]
 15324 0000239C 26C47D07                	les	di,[es:di+SF_ENTRY.sf_devptr]	; Get pointer to device.
 15325 000023A0 EB0F                    	jmp	short Do_GenIOCTL
 15326                                  
 15327                                  query_device_support:	; Entry point for devices:
 15328                                  GENERICIOCTL:
 15329 000023A2 C606[2303]02            	mov	byte [EXTERR_LOCUS],errLOC_Disk ; 2
 15330 000023A7 80FD08                  	cmp	ch,IOC_DC ; 8		; Only disk devices are allowed to use
 15331 000023AA 754E                    	jne	short ioctl_bad_fun	; no handles with Generic IOCTL.
 15332                                  
 15333 000023AC E88101                  	CALL	Check_If_Net		; ES:DI := Get_hdr_block of device in BL
 15334 000023AF 7549                    	JNZ	short ioctl_bad_fun	; There are no "net devices", and they
 15335                                  
 15336                                  Do_GenIOCTL:
 15337                                  	;TEST	word [ES:DI+SYSDEV.ATT],DEV320 
 15338                                  					; Can device handle Generic IOCTL funcs
 15339                                  	; 09/09/2018
 15340                                  	;test	byte [es:di+4],40h
 15341 000023B1 26F6450440              	TEST	byte [ES:DI+SYSDEV.ATT],DEV320 ; 0040h
 15342 000023B6 7442                    	jz	short ioctl_bad_fun
 15343                                  
 15344                                  	; 17/05/2019 - Retro DOS v4.0
 15345                                  
 15346                                  	; MSDOS 6.0
 15347                                  	;mov	byte [IOCALL_REQFUNC],19 ; 13h
 15348 000023B8 C606[7E03]13            	mov	byte [IOCALL_REQFUNC],GENIOCTL ; Assume real Request
 15349                                  	;cmp	al,10h
 15350 000023BD 3C10                    	cmp	AL,IOCTL_QUERY_HANDLE	; See if this is just a query
 15351 000023BF 7C0C                    	jl	short SetIOCtlBlock
 15352                                  	
 15353                                  	;TEST	word [ES:DI+SYSDEV.ATT],IOQUERY ; See if device supports a query
 15354                                  	;test	byte [es:di+4],80h 
 15355 000023C1 26F6450480              	TEST	byte [ES:DI+SYSDEV.ATT],IOQUERY ; See if device supports a query
 15356 000023C6 7432                    	jz	short ioctl_bad_fun	; No support for query 
 15357                                  	;
 15358                                  	;mov	byte [IOCALL_REQFUNC],19h	
 15359 000023C8 C606[7E03]19            	mov	byte [IOCALL_REQFUNC],IOCTL_QUERY ; Just a query (5.00)
 15360                                  
 15361                                  SetIOCtlBlock:
 15362 000023CD 06                      	PUSH	ES			; DEVIOCALL2 expects Device header block
 15363 000023CE 57                      	PUSH	DI			; in DS:SI
 15364                                  					; Setup Generic IOCTL Request Block
 15365                                  	;mov	byte [IOCALL_REQLEN],23
 15366 000023CF C606[7C03]17            	mov	byte [IOCALL_REQLEN],IOCTL_REQ.size
 15367                                  	; 07/09/2018 (MSDOS 3.3)
 15368                                  	;;mov	byte [IOCALL_REQFUNC],19
 15369                                  	;mov	byte [IOCALL_REQFUNC],GENIOCTL ; 07/09/2018
 15370                                  	;
 15371 000023D4 881E[7D03]              	MOV	[IOCALL_REQUNIT],BL
 15372 000023D8 882E[8903]              	MOV	[IOCALL+IOCTL_REQ.MAJORFUNCTION],CH
 15373 000023DC 880E[8A03]              	MOV	[IOCALL+IOCTL_REQ.MINORFUNCTION],CL
 15374 000023E0 8936[8B03]              	MOV	[IOCALL+IOCTL_REQ.REG_SI],SI
 15375 000023E4 893E[8D03]              	MOV	[IOCALL+IOCTL_REQ.REG_DI],DI
 15376 000023E8 8916[8F03]              	MOV	[IOCALL+IOCTL_REQ.GENERICIOCTL_PACKET],DX
 15377 000023EC 8936[9103]              	MOV	[IOCALL+IOCTL_REQ.GENERICIOCTL_PACKET+2],SI
 15378                                  
 15379                                  ;hkn; IOCALL is in DOSDATA
 15380 000023F0 BB[7C03]                	MOV	BX,IOCALL
 15381                                  
 15382 000023F3 16                      	PUSH	SS
 15383 000023F4 07                      	POP	ES
 15384                                  					; DS:SI -> Device header.
 15385 000023F5 5E                      	POP	SI
 15386 000023F6 1F                      	POP	DS
 15387                                  	; 10/08/2018
 15388 000023F7 E9E200                  	jmp	ioctl_do_IO		; Perform Call to device driver
 15389                                  
 15390                                  ioctl_bad_fun:
 15391 000023FA B001                    	mov	al, error_invalid_function  ; 1
 15392 000023FC E954E2                  	jmp	SYS_RET_ERR	
 15393                                  
 15394                                  ioctl_bad_handlej:
 15395 000023FF E9FAFE                  	jmp	ioctl_bad_handle
 15396                                  
 15397                                  ;---------------------------------------------------------------------------
 15398                                  ;
 15399                                  ; IOCTL: AL = 8
 15400                                  ;
 15401                                  ; ENTRY: DS = DOSDATA
 15402                                  ;
 15403                                  ; BUGBUG: Don't push anything on the stack between ioctl_rem_media: and 
 15404                                  ;         the call to Check_If_Net because Check_If_Net gets our
 15405                                  ;         return address off the stack if the drive is invalid.
 15406                                  ;
 15407                                  ;-------------------------------------------------------------------------
 15408                                  
 15409                                  ioctl_rem_media:
 15410                                  	; MSDOS 3.3 (& MSDOS 6.0)
 15411 00002402 E82B01                  	CALL	Check_If_Net
 15412 00002405 75F3                    	JNZ	short ioctl_bad_fun	; There are no "net devices", and they
 15413                                  					;   certainly don't know how to do this
 15414                                  					;   call.
 15415                                  	;test	word [es:di+4],800h
 15416                                  	;TEST	word [ES:DI+SYSDEV.ATT],DEVOPCL ; See if device can
 15417                                  	;test	byte [es:di+5],8
 15418 00002407 26F6450508              	TEST	byte [es:di+SYSDEV.ATT+1],(DEVOPCL>>8)
 15419 0000240C 74EC                    	JZ	short ioctl_bad_fun		; NO
 15420                                  
 15421                                  ;hkn; SS override for IOCALL
 15422 0000240E 36C606[7E03]0F          	MOV	byte [SS:IOCALL_REQFUNC],DEVRMD ; 15
 15423 00002414 B00D                    	MOV	AL,REMHL  ; 13
 15424 00002416 88DC                    	MOV	AH,BL			; Unit number
 15425 00002418 36A3[7C03]              	MOV	[SS:IOCALL_REQLEN],AX
 15426 0000241C 31C0                    	XOR	AX,AX
 15427 0000241E 36A3[7F03]              	MOV	[SS:IOCALL_REQSTAT],AX
 15428 00002422 06                      	PUSH	ES
 15429 00002423 1F                      	POP	DS
 15430 00002424 89FE                    	MOV	SI,DI			; DS:SI -> driver
 15431 00002426 16                      	PUSH	SS
 15432 00002427 07                      	POP	ES
 15433                                  
 15434                                  ;hkn; IOCALL is in DOSDATA (msconst.asm)
 15435 00002428 BB[7C03]                	MOV	BX,IOCALL		; ES:BX -> Call header
 15436 0000242B 1E                      	push	ds
 15437 0000242C 56                      	push	si
 15438 0000242D E8A722                  	call	DEVIOCALL2
 15439 00002430 5E                      	pop	si
 15440 00002431 1F                      	pop	ds
 15441                                  
 15442                                  ;hkn; SS override
 15443 00002432 36A1[7F03]              	MOV	AX,[SS:IOCALL_REQSTAT]	; Get Status word
 15444 00002436 250002                  	AND	AX,STBUI ; 200h		; Mask to busy bit
 15445 00002439 B109                    	MOV	CL,9
 15446 0000243B D3E8                    	SHR	AX,CL			; Busy bit to bit 0
 15447                                  ioctl_da_ok_j:	; 11/11/2022
 15448 0000243D E90AE2                  	jmp	SYS_RET_OK
 15449                                  
 15450                                  ;-------------------------------------------------------------------------
 15451                                  ;
 15452                                  ; IOCTL: AL = 9
 15453                                  ;
 15454                                  ; ENTRY: DS = DOSDATA
 15455                                  ;
 15456                                  ;-------------------------------------------------------------------------
 15457                                  
 15458                                  ioctl_drive_attr:
 15459                                  	; MSDOS 3.3 (& MSDOS 6.0)
 15460 00002440 88D8                    	mov	al,bl
 15461 00002442 E8BF46                  	call	GETTHISDRV
 15462 00002445 7241                    	jc	short ioctl_drv_err
 15463 00002447 E8B800                  	call	Get_Driver_BL
 15464                                  	; MSDOS 6.0
 15465 0000244A 723C                    	JC	short ioctl_drv_err	; drive not valid
 15466                                  
 15467                                  	;mov	dx,[es:di+4]
 15468 0000244C 268B5504                	mov	dx,[es:di+SYSDEV.ATT]	
 15469                                  					; get device attribute word
 15470 00002450 88C3                    	MOV	BL,AL			; Phys letter to BL (A=0)
 15471                                  
 15472                                  ;hkn; SS override
 15473 00002452 36C43E[A205]            	LES	DI,[SS:THISCDS]
 15474                                  	;test	word [es:di+43h],8000h
 15475                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet
 15476                                  	;test	byte [es:di+44h],80h
 15477 00002457 26F6454480              	TEST	byte [ES:DI+curdir.flags+1],(curdir_isnet>>8)
 15478 0000245C 7403                    	JZ	short IOCTLShare
 15479                                  
 15480                                  	;or	dx,1000h ; (MSDOS 3.3)
 15481                                  
 15482                                  ;	Net devices don't return a device attribute word.
 15483                                  ;	Bit 12 = 1, meaning net device, all others = 0.
 15484                                  
 15485 0000245E BA0010                  	MOV	DX,1000h ; MSDOS 6.0
 15486                                  IOCTLShare:
 15487 00002461 16                      	push	ss
 15488 00002462 1F                      	pop	ds
 15489 00002463 BE[BE03]                	MOV	SI,OPENBUF
 15490 00002466 80C341                  	ADD	BL,"A"	; 41h
 15491 00002469 881C                    	MOV	[SI],BL
 15492 0000246B C744013A00              	MOV	WORD [SI+1],003AH ; ":",0
 15493 00002470 B80003                  	MOV	AX,0300h
 15494 00002473 F8                      	CLC
 15495                                  	;INT	int_IBM
 15496 00002474 CD2A                    	int     2Ah	; Microsoft Networks - CHECK DIRECT I/O
 15497                                  			; DS:SI -> ASCIZ disk device name 
 15498                                  			; (may be full path or only drive
 15499                                  			; specifier--must include the colon)
 15500                                  			; Return: CF clear if absolute disk access allowed
 15501 00002476 7303                    	JNC	short IOCTLLocal	; Not shared
 15502                                  	;OR	DX,0200H		; Shared, bit 9
 15503                                  	; 17/12/2022
 15504 00002478 80CE02                  	or	dh,02h
 15505                                  IOCTLLocal:
 15506                                  	;test	word [es:di+43h],1000h
 15507                                  	;TEST	word [ES:DI+curdir.flags],curdir_local
 15508                                  	;test	byte [es:di+44h],10h
 15509 0000247B 26F6454410              	TEST	byte [ES:DI+curdir.flags+1],(curdir_local>>8)
 15510                                  	;JZ	short ioctl_set_DX
 15511                                  	; 16/12/2022
 15512 00002480 7403                    	jz	short _ioctl_set_DX
 15513                                  	;OR	DX,8000h
 15514                                  	; 17/12/2022
 15515 00002482 80CE80                  	or	dh,80h
 15516                                  ;ioctl_set_DX:
 15517                                  _ioctl_set_DX:
 15518                                  	; 16/12/2022
 15519 00002485 E9B6FE                  	jmp	ioctl_set_dx
 15520                                  ; 16/12/2022
 15521                                  %if 0	
 15522                                  	call	Get_User_Stack
 15523                                  	MOV	[SI+user_env.user_DX],DX
 15524                                  	;;jmp	SYS_RET_OK
 15525                                  	;; 25/06/2019
 15526                                  	;jmp	SYS_RET_OK_clc
 15527                                  	; 11/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 15528                                  ioctl_gd_ok_j:
 15529                                  	jmp	short ioctl_da_ok_j
 15530                                  %endif
 15531                                  
 15532                                  ioctl_drv_err:
 15533 00002488 B00F                    	mov	al,error_invalid_drive ; 0Fh
 15534                                  ioctl_gd_err_j:	; 11/11/2022
 15535 0000248A E9C6E1                  	jmp	SYS_RET_ERR
 15536                                  
 15537                                  ;--------------------------------------------------------------------------
 15538                                  ;
 15539                                  ; IOCTL: AL = A
 15540                                  ;
 15541                                  ; ENTRY: DS = DOSDATA
 15542                                  ;
 15543                                  ;--------------------------------------------------------------------------
 15544                                  
 15545                                  ioctl_handle_redir:
 15546 0000248D E85042                  	call	SFFromHandle		; ES:DI -> SFT
 15547 00002490 7303                    	JNC	short ioctl_got_sft	; have valid handle
 15548 00002492 E967FE                  	jmp	ioctl_bad_handle ; 10/08/2018
 15549                                  
 15550                                  ioctl_got_sft:
 15551                                  	;mov	dx,[es:di+5]
 15552 00002495 268B5505                	MOV	DX,[ES:DI+SF_ENTRY.sf_flags] ; Get flags
 15553                                  	;JMP	short ioctl_set_DX	; pass dx to user and return
 15554                                  	; 16/12/2022
 15555 00002499 EBEA                    	jmp	short _ioctl_set_DX
 15556                                  
 15557                                  	; 16/12/2022
 15558                                  ;ioctl_bad_funj:
 15559                                  	;JMP	ioctl_bad_fun
 15560                                  
 15561                                  ;--------------------------------------------------------------------------
 15562                                  ;
 15563                                  ; IOCTL: AL= 4,5
 15564                                  ;
 15565                                  ; ENTRY: DS = DOSDATA
 15566                                  ;	 SI = user's DS
 15567                                  ;
 15568                                  ;
 15569                                  ; BUGBUG: Don't push anything on the stack between ioctl_get_dev: and 
 15570                                  ;         the call to Check_If_Net because Check_If_Net gets our
 15571                                  ;         return address off the stack if the drive is invalid.
 15572                                  ;
 15573                                  ;-------------------------------------------------------------------------
 15574                                  
 15575                                  ioctl_get_dev:
 15576 0000249B E89200                  	CALL	Check_If_Net
 15577                                  	;JNZ	short ioctl_bad_funj	; There are no "net devices", and they
 15578                                  					; certainly don't know how to do this
 15579                                  					; call.
 15580                                  	; 16/12/2022
 15581 0000249E 7403                    	jz	short ioctl_do_string
 15582                                  ioctl_bad_funj:
 15583 000024A0 E957FF                  	JMP	ioctl_bad_fun
 15584                                  
 15585                                  ioctl_do_string:
 15586                                  	;test	word [es:di+4],4000h
 15587                                  	;TEST	word [ES:DI+SYSDEV.ATT],DEVIOCTL; See if device accepts control
 15588                                  	;test	byte [es:di+5],40h
 15589 000024A3 26F6450540              	TEST	byte [ES:DI+SYSDEV.ATT+1],(DEVIOCTL>>8)
 15590 000024A8 74F6                    	JZ	short ioctl_bad_funj		; NO
 15591                                  					; assume IOCTL read
 15592 000024AA C606[7E03]03            	MOV	byte [IOCALL_REQFUNC],DEVRDIOCTL  ; 3
 15593                                  
 15594 000024AF A801                    	TEST	AL,1			; is it func. 4/5 or 2/3
 15595 000024B1 7405                    	JZ	short ioctl_control_call ; it is read. goto ioctl_control_call
 15596                                  
 15597                                  					; it is an IOCTL write
 15598 000024B3 C606[7E03]0C            	MOV	byte [IOCALL_REQFUNC],DEVWRIOCTL ; 12
 15599                                  
 15600                                  ioctl_control_call:
 15601 000024B8 B016                    	MOV	AL,DRDWRHL ; 22
 15602                                  ioctl_setup_pkt:
 15603 000024BA 88DC                    	MOV	AH,BL			; Unit number
 15604 000024BC A3[7C03]                	MOV	[IOCALL_REQLEN],AX
 15605 000024BF 31C0                    	XOR	AX,AX
 15606 000024C1 A3[7F03]                	MOV	[IOCALL_REQSTAT],AX
 15607 000024C4 A2[8903]                	MOV	[IOMED],AL
 15608 000024C7 890E[8E03]              	MOV	[IOSCNT],CX
 15609 000024CB 8916[8A03]              	MOV	[IOXAD],DX
 15610 000024CF 8936[8C03]              	MOV	[IOXAD+2],SI
 15611 000024D3 06                      	PUSH	ES
 15612 000024D4 1F                      	POP	DS
 15613 000024D5 89FE                    	MOV	SI,DI			; DS:SI -> driver
 15614 000024D7 16                      	PUSH	SS
 15615 000024D8 07                      	POP	ES
 15616                                  
 15617 000024D9 BB[7C03]                	MOV	BX,IOCALL		; ES:BX -> Call header
 15618                                  ioctl_do_IO:
 15619 000024DC E8F821                  	call	DEVIOCALL2
 15620                                  
 15621                                  ;hkn; SS override for IOCALL
 15622                                  	;test	word [SS:IOCALL_REQSTAT],8000h
 15623                                  	;TEST	word [SS:IOCALL_REQSTAT],STERR ;Error?
 15624                                  	;test	byte [SS:IOCALL_REQSTAT+1],80h
 15625 000024DF 36F606[8003]80          	TEST	byte [SS:IOCALL_REQSTAT+1],(STERR>>8)
 15626 000024E5 7507                    	JNZ	short ioctl_string_err
 15627                                  
 15628                                  ;hkn; SS override
 15629 000024E7 36A1[8E03]              	MOV	AX,[SS:IOSCNT]		; Get actual bytes transferred
 15630                                  	; 16/12/2022
 15631 000024EB E95CE1                  	jmp	SYS_RET_OK
 15632                                  	; 11/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 15633                                  	;jmp	short ioctl_gd_ok_j
 15634                                  
 15635                                  ioctl_string_err:
 15636 000024EE 368B3E[7F03]            	MOV	DI,[SS:IOCALL_REQSTAT]	;Get Error
 15637                                  device_err:
 15638 000024F3 81E7FF00                	AND	DI,STECODE ; 00FFh	; mask out irrelevant bits
 15639 000024F7 89F8                    	MOV	AX,DI
 15640 000024F9 E86A30                  	call	SET_I24_EXTENDED_ERROR
 15641                                  
 15642                                  ;hkn; use SS override
 15643                                  ;hkn;	mov	ax,[CS:EXTERR]
 15644 000024FC 36A1[2403]              	mov	ax,[SS:EXTERR]
 15645                                  	;jmp	SYS_RET_ERR
 15646                                  	; 11/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 15647 00002500 EB88                    	jmp	short ioctl_gd_err_j
 15648                                  
 15649                                  ; 17/05/2019 - Retro DOS v4.0
 15650                                  
 15651                                  ;--------------------------------------------------------------------------
 15652                                  ; Proc name : Get_Driver_BL
 15653                                  ;
 15654                                  ;	DS is DOSDATA
 15655                                  ;	BL is drive number (0=default)
 15656                                  ;	Returns pointer to device in ES:DI, unit number in BL if carry clear
 15657                                  ;	No regs modified
 15658                                  ;
 15659                                  ;---------------------------------------------------------------------------
 15660                                  
 15661                                  Get_Driver_BL:
 15662 00002502 50                      	PUSH	AX
 15663 00002503 88D8                    	MOV	AL,BL			; Drive
 15664 00002505 E8FC45                  	call	GETTHISDRV
 15665 00002508 7224                    	jc	short ioctl_bad_drv
 15666 0000250A 30DB                    	XOR	BL,BL			; Unit zero on Net device
 15667 0000250C C606[2303]03            	MOV	byte [EXTERR_LOCUS],errLOC_Net ; 3
 15668 00002511 C43E[A205]              	LES	DI,[THISCDS]
 15669                                  	;test	word [es:di+43h],8000h
 15670                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet
 15671                                  	;test	byte [es:di+44h],80h
 15672 00002515 26F6454480              	TEST	byte [ES:DI+curdir.flags+1],(curdir_isnet>>8)
 15673                                  	;les	di,[es:di+45h]
 15674 0000251A 26C47D45                	LES	DI,[ES:DI+curdir.devptr] ; ES:DI -> Dpb or net dev
 15675 0000251E 750D                    	JNZ	short got_dev_ptr	 ; Is net
 15676 00002520 C606[2303]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk ; 2
 15677                                  	;mov	bl,[es:di+1]
 15678 00002525 268A5D01                	MOV	BL,[ES:DI+DPB.UNIT]	; Unit number
 15679                                  	;les	di,[es:di+13h]
 15680 00002529 26C47D13                	LES	DI,[ES:DI+DPB.DRIVER_ADDR] ; Driver addr
 15681                                  got_dev_ptr:
 15682 0000252D F8                      	CLC
 15683                                  ioctl_bad_drv:
 15684 0000252E 58                      	POP	AX
 15685 0000252F C3                      	retn
 15686                                  
 15687                                  ;-------------------------------------------------------------------------
 15688                                  ; Proc Name : Check_If_Net:
 15689                                  ;
 15690                                  ;
 15691                                  ; Checks if the device is over the net or not. Returns result in ZERO flag.
 15692                                  ; If no device is found, the return address is popped off the stack, and a
 15693                                  ; jump is made to ioctl_drv_err.
 15694                                  ;
 15695                                  ; On Entry:
 15696                                  ; Registers same as those for Get_Driver_BL
 15697                                  ;
 15698                                  ; On Exit:
 15699                                  ; ZERO flag	- set if not a net device
 15700                                  ;		- reset if net device
 15701                                  ; ES:DI -> the device
 15702                                  ;
 15703                                  ;
 15704                                  ; BUGBUG: This function assumes the following stack setup on entry
 15705                                  ;
 15706                                  ;	  SP+2 -> Error return address
 15707                                  ;	  SP   -> Normal return address
 15708                                  ;
 15709                                  ;-------------------------------------------------------------------------
 15710                                  
 15711                                  Check_If_Net:
 15712                                  	; MSDOS 3.3 (& MSDOS 6.0)
 15713 00002530 E8CFFF                  	CALL	Get_Driver_BL
 15714 00002533 720E                    	JC	short ioctl_drv_err_pop	; invalid drive letter
 15715 00002535 06                      	PUSH	ES
 15716 00002536 57                      	PUSH	DI
 15717 00002537 C43E[A205]              	LES	DI,[THISCDS]
 15718                                  	;test	word [es:di+43h],8000h
 15719                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet
 15720                                  	;test	byte [es:di+44h],80h
 15721 0000253B 26F6454480              	TEST	byte [ES:DI+curdir.flags+1],(curdir_isnet>>8)
 15722 00002540 5F                      	POP	DI
 15723 00002541 07                      	POP	ES
 15724 00002542 C3                      	retn
 15725                                  
 15726                                  ioctl_drv_err_pop:
 15727 00002543 58                      	pop	ax			; pop off return address
 15728 00002544 E941FF                  	jmp	ioctl_drv_err
 15729                                  
 15730                                  ioctl_bad_funj3:
 15731 00002547 E9B0FE                  	jmp	ioctl_bad_fun
 15732                                  
 15733                                  ioctl_string_errj:
 15734 0000254A EBA2                    	jmp	short ioctl_string_err  ; 25/05/2019
 15735                                  
 15736                                  ;--------------------------------------------------------------------------
 15737                                  ;
 15738                                  ; IOCTL: AL = E, F
 15739                                  ;
 15740                                  ; ENTRY: DS = DOSDATA
 15741                                  ;
 15742                                  ;
 15743                                  ; BUGBUG: Don't push anything on the stack between ioctl_drive_owner: and 
 15744                                  ;         the call to Check_If_Net because Check_If_Net gets our
 15745                                  ;         return address off the stack if the drive is invalid.
 15746                                  ;
 15747                                  ;--------------------------------------------------------------------------
 15748                                  
 15749                                  ioctl_drive_owner:
 15750                                  	; MSDOS 3.3 (& MSDOS 6.0)
 15751 0000254C E8E1FF                  	Call	Check_If_Net
 15752 0000254F 75F6                    	JNZ	short ioctl_bad_funj3 	; There are no "net devices", and they
 15753                                  					;   certainly don't know how to do this
 15754                                  					;   call.
 15755                                  	;TEST	word [ES:DI+SYSDEV.ATT],DEV320	; See if device can handle this
 15756                                  	; 09/09/2018
 15757                                  	;test	byte [es:di+4],40h
 15758 00002551 26F6450440              	TEST	byte [ES:DI+SYSDEV.ATT],DEV320 ; 0040h
 15759 00002556 74EF                    	JZ	short ioctl_bad_funj3 	; NO
 15760                                  	;mov	byte [IOCALL_REQFUNC],23
 15761 00002558 C606[7E03]17            	mov	byte [IOCALL_REQFUNC],DEVGETOWN	; default to get owner
 15762 0000255D 3C0E                    	cmp	al,0Eh			; Get Owner ?
 15763 0000255F 7405                    	jz	short GetOwner
 15764                                  SetOwner:
 15765 00002561 C606[7E03]18            	MOV	byte [IOCALL_REQFUNC],DEVSETOWN ; 24
 15766                                  GetOwner:
 15767 00002566 B00D                    	MOV	AL,OWNHL ; 13
 15768 00002568 88DC                    	MOV	AH,BL			; Unit number
 15769 0000256A A3[7C03]                	MOV	[IOCALL_REQLEN],AX
 15770 0000256D 31C0                    	XOR	AX,AX
 15771 0000256F A3[7F03]                	MOV	[IOCALL_REQSTAT],AX
 15772 00002572 06                      	PUSH	ES
 15773 00002573 1F                      	POP	DS
 15774 00002574 89FE                    	MOV	SI,DI			; DS:SI -> driver
 15775 00002576 16                      	PUSH	SS
 15776 00002577 07                      	POP	ES
 15777 00002578 BB[7C03]                	MOV	BX,IOCALL		; ES:BX -> Call header
 15778 0000257B 1E                      	push	ds
 15779 0000257C 56                      	push	si
 15780 0000257D E85721                  	call	DEVIOCALL2
 15781 00002580 5E                      	pop	si
 15782 00002581 1F                      	pop	ds
 15783                                  ;hkn; SS override
 15784                                  	;TEST	word [SS:IOCALL_REQSTAT],STERR ;Error?
 15785                                  	;test	byte [SS:IOCALL_REQSTAT+1],80h
 15786 00002582 36F606[8003]80          	TEST	byte [SS:IOCALL_REQSTAT+1],(STERR>>8)
 15787 00002588 75C0                    	jnz	short ioctl_string_errj
 15788 0000258A 36A0[7D03]              	MOV	AL,[SS:IOCALL_REQUNIT]	; Get owner returned by device
 15789                                  					; owner returned is 1-based.
 15790 0000258E E9B9E0                  	jmp	SYS_RET_OK
 15791                                  
 15792                                  ;============================================================================
 15793                                  ; DELETE.ASM, MSDOS 6.0, 1991
 15794                                  ;============================================================================
 15795                                  ; 07/08/2018 - Retro DOS v3.0
 15796                                  ; 17/05/2019 - Retro DOS v4.0
 15797                                  
 15798                                  ;	TITLE	DOS_DELETE - Internal DELETE call for MS-DOS
 15799                                  ;	NAME	DOS_DELETE
 15800                                  
 15801                                  ;
 15802                                  ;	Microsoft Confidential
 15803                                  ;	Copyright (C) Microsoft Corporation 1991
 15804                                  ;	All Rights Reserved.
 15805                                  ;
 15806                                  
 15807                                  ;**	DELETE.ASM - Low level routine for deleting files
 15808                                  ;----------------------------------------------------------------------------
 15809                                  ;		DOS_DELETE
 15810                                  ;		REN_DEL_Check
 15811                                  ;		FastOpen_Delete	       ; DOS 3.3
 15812                                  ;		FastOpen_Update	       ; DOS 3.3
 15813                                  
 15814                                  ;   Revision history:
 15815                                  ;
 15816                                  ;   A000  version 4.00	Jan. 1988
 15817                                  ;   A001  Fastopen Rename fix	April 1989
 15818                                  
 15819                                  ;Installed = TRUE
 15820                                  
 15821                                  ;	i_need	NoSetDir,BYTE
 15822                                  ;	i_need	Creating,BYTE
 15823                                  ;	i_need	DELALL,BYTE
 15824                                  ;	i_need	THISDPB,DWORD
 15825                                  ;	i_need	THISSFT,DWORD
 15826                                  ;	i_need	THISCDS,DWORD
 15827                                  ;	i_need	CURBUF,DWORD
 15828                                  ;	i_need	ATTRIB,BYTE
 15829                                  ;	i_need	SATTRIB,BYTE
 15830                                  ;	i_need	WFP_START,WORD
 15831                                  ;	i_need	REN_WFP,WORD			 ;BN001
 15832                                  ;	i_need	NAME1,BYTE			 ;BN001
 15833                                  ;	i_need	FoundDel,BYTE
 15834                                  ;	i_need	AUXSTACK,BYTE
 15835                                  ;	i_need	VOLCHNG_FLAG,BYTE
 15836                                  ;	i_need	JShare,DWORD
 15837                                  ;	i_need	FastOpenTable,BYTE		  ; DOS 3.3
 15838                                  ;	i_need	FastTable,BYTE			  ; DOS 4.00
 15839                                  ;
 15840                                  ;	i_need	Del_ExtCluster,WORD		  ; DOS 4.00
 15841                                  ;
 15842                                  ;	i_need	SAVE_BX,WORD			  ; DOS 4.00
 15843                                  ;	i_need	DMAADD,DWORD
 15844                                  ;	i_need	RENAMEDMA,BYTE
 15845                                  
 15846                                  ;----------------------------------------------------------------------------
 15847                                  ;
 15848                                  ; Procedure Name : DOS_DELETE
 15849                                  ;
 15850                                  ; Inputs:
 15851                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 15852                                  ;		terminated)
 15853                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 15854                                  ;		( = -1 if current dir not involved, else
 15855                                  ;		 Points to first char after last "/" of current dir part)
 15856                                  ;	[THISCDS] Points to CDS being used
 15857                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 15858                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 15859                                  ; Function:
 15860                                  ;	Delete the specified file(s)
 15861                                  ; Outputs:
 15862                                  ;	CARRY CLEAR
 15863                                  ;		OK
 15864                                  ;	CARRY SET
 15865                                  ;	    AX is error code
 15866                                  ;		error_file_not_found
 15867                                  ;			Last element of path not found
 15868                                  ;		error_path_not_found
 15869                                  ;			Bad path (not in curr dir part if present)
 15870                                  ;		error_bad_curr_dir
 15871                                  ;			Bad path in current directory part of path
 15872                                  ;		error_access_denied
 15873                                  ;			Attempt to delete device or directory
 15874                                  ;		***error_sharing_violation***
 15875                                  ;			Deny both access required, generates an INT 24.
 15876                                  ;			This error is NOT returned. The INT 24H is generated,
 15877                                  ;			  and the file is ignored (not deleted). Delete will
 15878                                  ;			  simply continue on looking for more files.
 15879                                  ;			  Carry will NOT be set in this case.
 15880                                  ; DS preserved, others destroyed
 15881                                  ;
 15882                                  ;----------------------------------------------------------------------------
 15883                                  
 15884                                  FILEFOUND   equ 01h
 15885                                  FILEDELETED equ 10h
 15886                                  
 15887                                  
 15888                                  	; 12/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 15889                                  	; DOSCODE:63E9h (MSDOS 5.0, MSDOS.SYS)
 15890                                  
 15891                                  DOS_DELETE:
 15892                                  
 15893                                  ;hkn; DOS_Delete is called from file.asm and fcbio.asm. DS has been set up 
 15894                                  ;hkn; appropriately at this point.
 15895                                  
 15896 00002591 E8FFEC                  	call	TestNet
 15897 00002594 7306                    	JNC	short LOCAL_DELETE
 15898                                  
 15899                                  ;IF NOT Installed
 15900                                  ;	transfer NET_DELETE
 15901                                  ;ELSE
 15902                                  	;MOV	AX,(MultNET SHL 8) | 19
 15903                                  	;INT	2FH
 15904                                  	;return
 15905                                  
 15906 00002596 B81311                  	mov	ax,1113h
 15907 00002599 CD2F                    	int     2Fh 	; Multiplex - NETWORK REDIRECTOR - DELETE REMOTE FILE
 15908                                  			; SS = DS = DOS CS, SDA first filename pointer -> 
 15909                                  			;		fully-qualified filename in DOS CS
 15910                                  			; SDA CDS pointer -> current directory structure for drive with file
 15911                                  			; Return: CF set on error
 15912 0000259B C3                      	retn
 15913                                  ;ENDIF
 15914                                  
 15915                                  LOCAL_DELETE:
 15916 0000259C C606[6F05]00            	MOV	byte [FOUNDDEL],0	; No files found and no files deleted
 15917 000025A1 E8B3ED                  	call	ECritDisk
 15918                                  	;mov	word [CREATING],0E500h
 15919 000025A4 C706[7E05]00E5          	MOV	WORD [CREATING],DIRFREE*256+0 ; Assume not del *.*
 15920 000025AA 8B36[B205]              	MOV	SI,[WFP_START]
 15921                                  SKPNUL:
 15922 000025AE AC                      	LODSB
 15923 000025AF 08C0                    	OR	AL,AL
 15924 000025B1 75FB                    	JNZ	short SKPNUL		; go to end
 15925 000025B3 83EE04                  	SUB	SI,4			; Back over possible "*.*"
 15926 000025B6 813C2A2E                	CMP	WORD [SI],2E2Ah ; "*."
 15927 000025BA 7506                    	JNZ	short TEST_QUEST
 15928 000025BC 807C022A                	CMP	BYTE [SI+2],"*"
 15929 000025C0 741F                    	JZ	short CHECK_ATTS
 15930                                  TEST_QUEST:
 15931 000025C2 83EE09                  	SUB	SI,9		; Back over possible "????????.???"
 15932 000025C5 87FE                    	XCHG	DI,SI
 15933                                  
 15934 000025C7 16                      	push	ss
 15935                                  	;pop	ds ; ! Retro DOS v3.0 BUG !
 15936 000025C8 07                      	pop	es ; 17/05/2019
 15937                                  
 15938 000025C9 B83F3F                  	MOV	AX,"??" ; 3F3Fh
 15939 000025CC B90400                  	MOV	CX,4		; four sets of "??"
 15940 000025CF F3AF                    	REPE	SCASW
 15941 000025D1 751C                    	JNZ	short NOT_ALL
 15942 000025D3 87FE                    	XCHG	DI,SI
 15943 000025D5 AD                      	LODSW
 15944 000025D6 3D2E3F                  	CMP	AX,3F2Eh ; ".?"
 15945 000025D9 7514                    	JNZ	short NOT_ALL
 15946 000025DB AD                      	LODSW
 15947 000025DC 3D3F3F                  	CMP	AX,"??"
 15948 000025DF 750E                    	JNZ	short NOT_ALL
 15949                                  CHECK_ATTS:
 15950 000025E1 A0[6D05]                	MOV	AL,[SATTRIB]
 15951                                  	;and	al,1Fh
 15952 000025E4 241F                    	AND	AL,attr_hidden+attr_system+attr_directory+attr_volume_id+attr_read_only
 15953                                  					; Look only at hidden bits
 15954                                  	;cmp	al,1Fh
 15955 000025E6 3C1F                    	CMP	AL,attr_hidden+attr_system+attr_directory+attr_volume_id+attr_read_only
 15956                                  					; All must be set
 15957 000025E8 7505                    	JNZ	short NOT_ALL
 15958                                  
 15959                                  ; NOTE WARNING DANGER-----
 15960                                  ;    This DELALL stuff is not safe. It allows directories to be deleted.
 15961                                  ;	It should ONLY be used by FORMAT in the ROOT directory.
 15962                                  
 15963 000025EA C606[7F05]00            	MOV	byte [DELALL],0		; DEL *.* - flag deleting all
 15964                                  NOT_ALL:
 15965 000025EF C606[4C03]01            	MOV	byte [NoSetDir],1
 15966 000025F4 E89519                  	call	GetPathNoSet
 15967 000025F7 7312                    	JNC	short Del_found
 15968 000025F9 750B                    	JNZ	short _bad_path
 15969 000025FB 08C9                    	OR	CL,CL
 15970 000025FD 7407                    	JZ	short _bad_path
 15971                                  No_file:
 15972 000025FF B80200                  	MOV	AX,error_file_not_found
 15973                                  ErrorReturn:
 15974 00002602 F9                      	STC
 15975                                  	;call	LCritDisk
 15976                                  	;retn
 15977                                  	; 18/12/2022
 15978 00002603 E96CED                  	jmp	LCritDisk
 15979                                  
 15980                                  _bad_path:
 15981 00002606 B80300                  	MOV	AX,error_path_not_found
 15982 00002609 EBF7                    	JMP	short ErrorReturn
 15983                                  
 15984                                  Del_found:
 15985 0000260B 750C                    	JNZ	short NOT_DIR		; Check for dir specified
 15986 0000260D 803E[7F05]00            	CMP	byte [DELALL],0		; DelAll = 0 allows delete of dir.
 15987 00002612 7405                    	JZ	short NOT_DIR
 15988                                  Del_access_err:
 15989 00002614 B80500                  	MOV	AX,error_access_denied
 15990 00002617 EBE9                    	JMP	short ErrorReturn
 15991                                  
 15992                                  NOT_DIR:
 15993 00002619 08E4                    	OR	AH,AH			; Check if device name
 15994 0000261B 78F7                    	JS	short Del_access_err	; Can't delete I/O devices
 15995                                  
 15996                                  ; Main delete loop. CURBUF+2:BX points to a matching directory entry.
 15997                                  
 15998                                  DELFILE:
 15999 0000261D 800E[6F05]01            	OR	byte [FOUNDDEL],FILEFOUND ; file found, not deleted yet
 16000                                  
 16001                                  ; If we are deleting the Volume ID, then we set VOLUME_CHNG flag to make
 16002                                  ; DOS issue a build BPB call the next time this drive is accessed.
 16003                                  
 16004 00002622 1E                      	PUSH	DS
 16005 00002623 8A26[7F05]              	MOV	AH,[DELALL]
 16006 00002627 C53E[E205]              	LDS	DI,[CURBUF]
 16007                                  	
 16008                                  ;hkn; SS override
 16009 0000262B 36F606[6B05]01          	TEST	byte [SS:ATTRIB],attr_read_only ; are we deleting RO files too?
 16010 00002631 7509                    	JNZ	short DoDelete		; yes
 16011                                  
 16012 00002633 F6470B01                	TEST	byte [BX+dir_entry.dir_attr],attr_read_only
 16013 00002637 7403                    	JZ	short DoDelete		; not read only
 16014                                  
 16015 00002639 1F                      	POP	DS
 16016 0000263A EB32                    	JMP	SHORT DELNXT		; Skip it (Note ES:BP not set)
 16017                                  
 16018                                  DoDelete:
 16019 0000263C E88400                  	call	REN_DEL_Check		; Sets ES:BP = [THISDPB]
 16020 0000263F 7303                    	JNC	short DEL_SHARE_OK
 16021 00002641 1F                      	POP	DS
 16022 00002642 EB2A                    	JMP	SHORT DELNXT		; Skip it
 16023                                  
 16024                                  DEL_SHARE_OK:
 16025                                  	; 17/05/2019 - Retro DOS v4.0
 16026                                  	; MSDOS 6.0
 16027                                  	;test	byte [di+5],40h
 16028 00002644 F6450540                	TEST	byte [DI+BUFFINFO.buf_flags],buf_dirty
 16029                                  					;LB. if already dirty		  ;AN000;
 16030 00002648 7507                    	JNZ	short yesdirty		;LB.  don't increment dirty count ;AN000;
 16031 0000264A E87235                  	call	INC_DIRTY_COUNT		;LB.				  ;AN000;
 16032                                  	;or	byte [di+5],40h
 16033 0000264D 804D0540                	OR	byte [DI+BUFFINFO.buf_flags],buf_dirty
 16034                                  yesdirty:
 16035 00002651 8827                    	mov	[bx],ah 
 16036                                  	;MOV	[BX+dir_entry.dir_name],AH ; Put in E5H or 0
 16037 00002653 8B1C                    	MOV	BX,[SI] 		; Get firclus pointer
 16038 00002655 1F                      	POP	DS
 16039 00002656 800E[6F05]10            	OR	byte [FOUNDDEL],FILEDELETED ; 10h ; Deleted file
 16040                                  
 16041 0000265B 83FB02                  	CMP	BX,2
 16042 0000265E 720E                    	JB	short DELNXT		; File has invalid FIRCLUS (too small)
 16043                                  	;cmp	bx,[es:bp+0Dh]
 16044 00002660 263B5E0D                	CMP	BX,[ES:BP+DPB.MAX_CLUSTER]
 16045 00002664 7708                    	JA	short DELNXT		; File has invalid FIRCLUS (too big)
 16046                                  
 16047 00002666 E8BD28                  	call	RELEASE 		; Free file data
 16048 00002669 7252                    	JC	short No_fileJ
 16049                                  
 16050                                  ; DOS 3.3  FastOpen
 16051                                  
 16052 0000266B E8C300                  	CALL	FastOpen_Delete 	; delete the dir info in fastopen
 16053                                  
 16054                                  ; DOS 3.3  FastOpen
 16055                                  
 16056                                  DELNXT:
 16057 0000266E C42E[8A05]              	LES	BP,[THISDPB]		; Possible to get here without this set
 16058 00002672 E88218                  	call	GETENTRY		; Registers need to be reset
 16059 00002675 7246                    	JC	short No_fileJ
 16060 00002677 E8BB17                  	call	NEXTENT
 16061 0000267A 73A1                    	JNC	short DELFILE
 16062 0000267C C42E[8A05]              	LES	BP,[THISDPB]		; NEXTENT sets ES=DOSGROUP
 16063                                  	; 12/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 16064                                  	;MOV	AL,[ES:BP+DPB.DRIVE]
 16065                                  	;;mov	al,[es:bp+0]
 16066                                  	; 15/12/2022
 16067 00002680 268A4600                	MOV	AL,[ES:BP]
 16068 00002684 E83334                  	call	FLUSHBUF
 16069 00002687 7234                    	JC	short No_fileJ
 16070                                  ;
 16071                                  ; Now we need to test FoundDel for our flags. The cases to consider are:
 16072                                  ;
 16073                                  ;   not found not deleted		file not found
 16074                                  ;   not found	  deleted		*** impossible ***
 16075                                  ;	found not deleted		access denied (read-only)
 16076                                  ;	found	  deleted		no error
 16077                                  ;
 16078 00002689 F606[6F05]10            	TEST	byte [FOUNDDEL],FILEDELETED ; did we delete a file?
 16079 0000268E 7426                    	JZ	short DelError		; no, figure out what's wrong.
 16080                                  ; We set VOLCHNG_FLAG to indicate that we have changed the volume label
 16081                                  ; and to force the DOS to issue a media check.
 16082 00002690 F606[6B05]08            	TEST	byte [ATTRIB],attr_volume_id ; 8
 16083 00002695 741C                    	jz	short No_Set_Flag
 16084 00002697 50                      	PUSH	AX
 16085 00002698 06                      	PUSH	ES
 16086 00002699 57                      	PUSH	DI
 16087 0000269A C43E[A205]              	LES	DI,[THISCDS]
 16088 0000269E 268A25                  	MOV	AH,[ES:DI]		; Get drive
 16089 000026A1 80EC41                  	SUB	AH,'A'                  ; Convert to 0-based
 16090 000026A4 8826[A10A]              	mov	[VOLCHNG_FLAG],AH
 16091                                  	
 16092                                  	; MSDOS 6.0
 16093 000026A8 30FF                    	XOR	BH,BH			;>32mb delete volume id from boot record ;AN000;
 16094 000026AA E8DC04                  	call	Set_Media_ID		;>32mb set volumme id to boot record	 ;AN000;
 16095                                  	 
 16096 000026AD E88B30                  	call	FATREAD_CDS		; force media check
 16097 000026B0 5F                      	POP	DI
 16098 000026B1 07                      	POP	ES
 16099 000026B2 58                      	POP	AX
 16100                                  No_Set_Flag:
 16101                                  	;call	LCritDisk		; carry is clear
 16102                                  	;retn
 16103                                  	; 18/12/2022
 16104 000026B3 E9BCEC                  	jmp	LCritDisk
 16105                                  DelError:
 16106 000026B6 F606[6F05]01            	TEST	byte [FOUNDDEL],FILEFOUND ; not deleted. Did we find file?
 16107 000026BB 7503                    	JNZ	short Del_access_errJ 	; yes. Access denied
 16108                                  No_fileJ:
 16109 000026BD E93FFF                  	JMP	No_file ; 10/08/2018 		; Nope
 16110                                  Del_access_errJ:
 16111 000026C0 E951FF                  	JMP	Del_access_err ; 10/08/2018
 16112                                  
 16113                                  ; 08/08/2018 - Retro DOS v3.0
 16114                                  
 16115                                  ;Break	<REN_DEL_Check - check for access for rename and delete>
 16116                                  ;---------------------------------------------------------------------------
 16117                                  ; Procedure Name : REN_DEL_Check
 16118                                  ;
 16119                                  ; Inputs:
 16120                                  ;	[THISDPB] set
 16121                                  ;	[CURBUF+2]:BX points to entry
 16122                                  ;	[CURBUF+2]:SI points to firclus field of entry
 16123                                  ;	[WFP_Start] points to name
 16124                                  ; Function:
 16125                                  ;	Check for Exclusive access on given file.
 16126                                  ;	  Used by RENAME, SET_FILE_INFO, and DELETE.
 16127                                  ; Outputs:
 16128                                  ;	ES:BP = [THISDPB]
 16129                                  ;	NOTE: The WFP string pointed to by [WFP_Start] Will be Modified.  The
 16130                                  ;		last element will be loaded from the directory entry.  This is
 16131                                  ;		so the name given to the sharer doesn't have any meta chars in
 16132                                  ;		it.
 16133                                  ;	Carry set if sharing violation, INT 24H generated
 16134                                  ;	    NOTE THAT AX IS NOT error_sharing_violation.
 16135                                  ;		This is because input AX is preserved.
 16136                                  ;		Caller must set the error if needed.
 16137                                  ;	Carry clear
 16138                                  ;		OK
 16139                                  ; AX,DS,BX,SI,DI preserved
 16140                                  ;---------------------------------------------------------------------------
 16141                                  
 16142                                  REN_DEL_Check:
 16143                                  
 16144 000026C3 1E                      	PUSH	DS
 16145 000026C4 57                      	PUSH	DI
 16146 000026C5 50                      	PUSH	AX
 16147 000026C6 53                      	PUSH	BX
 16148 000026C7 56                      	PUSH	SI		; Save CURBUF pointers
 16149                                  	
 16150 000026C8 16                      	push	ss
 16151 000026C9 07                      	pop	es
 16152                                  
 16153                                  ;hkn; context ES will assume ES to DOSDATA
 16154                                  ;hkn; ASSUME	ES:DOSGROUP
 16155                                  
 16156                                  ;hkn; SS override
 16157 000026CA 368B3E[B205]            	MOV	DI,[SS:WFP_START] ; ES:DI -> WFP
 16158 000026CF 89DE                    	MOV	SI,BX
 16159                                  
 16160                                  ;hkn; SS override
 16161 000026D1 368E1E[E405]            	MOV	DS,[SS:CURBUF+2] ; DS:SI -> entry (FCB style name)
 16162 000026D6 89FB                    	MOV	BX,DI		; Set backup limit for skipback
 16163 000026D8 83C302                  	ADD	BX,2		; Skip over d: to point to leading '\'
 16164 000026DB E855EB                  	call	StrLen		; CX is length of ES:DI including NUL
 16165 000026DE 49                      	DEC	CX		; Don't include nul in count
 16166 000026DF 01CF                    	ADD	DI,CX		; Point to NUL at end of string
 16167 000026E1 E8DA46                  	call	SkipBack	; Back up one element
 16168 000026E4 47                      	INC	DI		; Point to start of last element
 16169                                  
 16170                                  	; 17/05/2019 - Retro DOS v4.0
 16171                                  ;hkn; SS override
 16172                                  	; MSDOS 6.0
 16173 000026E5 36893E[0106]            	MOV	[SS:SAVE_BX],DI	;IFS. save for DOS_RENAME   ;AN000;
 16174                                  	;
 16175 000026EA E830FA                  	call	PackName	; Transfer name from entry to ASCIZ tail.
 16176 000026ED 5E                      	POP	SI		; Get back entry pointers
 16177 000026EE 5B                      	POP	BX
 16178 000026EF 53                      	PUSH	BX
 16179 000026F0 56                      	PUSH	SI		; Back on stack
 16180                                  	
 16181 000026F1 16                      	push	ss
 16182 000026F2 1F                      	pop	ds
 16183                                  
 16184                                  ;hkn; context DS will assume ES to DOSDATA
 16185                                  ;hkn; ASSUME	DS:DOSGROUP
 16186                                  
 16187                                  ; Close the file if possible by us.
 16188                                  ;
 16189                                  ;if installed
 16190 000026F3 FF1E[C400]              	Call	far [JShare+(13*4)] ; 13 = ShCloseFile
 16191                                  ;else
 16192                                  ;	Call	ShCloseFile
 16193                                  ;endif
 16194 000026F7 8C1E[A005]              	MOV	[THISSFT+2],DS
 16195                                  
 16196                                  ;hkn; AUXSTACK is in DOSDATA
 16197 000026FB C706[9E05][6507]        	MOV	word [THISSFT],AUXSTACK-SF_ENTRY.size  ; RENAMEDMA+(384-59)
 16198                                  				; Scratch space
 16199 00002701 30E4                    	XOR	AH,AH		; Indicate file to DOOPEN (high bit off)
 16200 00002703 E8AA24                  	call	DOOPEN		; Fill in SFT for share check
 16201 00002706 C43E[9E05]              	LES	DI,[THISSFT]
 16202                                  	;mov	word [es:di+2],10h
 16203 0000270A 26C745021000            	MOV	word [ES:DI+SF_ENTRY.sf_mode],SHARING_DENY_BOTH ; 10h
 16204                                  				; requires exclusive access
 16205                                  	;MOV	word [ES:DI+SF_ENTRY.sf_ref_count],1 ; Pretend open
 16206 00002710 26C7050100              	mov	word [ES:DI],1
 16207 00002715 E8CA4C                  	call	ShareEnter
 16208 00002718 720D                    	jc	short CheckDone
 16209 0000271A C43E[9E05]              	LES	DI,[THISSFT]
 16210                                  	;MOV	word [ES:DI+SF_ENTRY.sf_ref_count],0
 16211 0000271E 26C7050000              	mov	word [ES:DI],0	; Pretend closed and free
 16212                                  	
 16213 00002723 E8B74C                  	call	ShareEnd	; Tell sharer we're done with THISSFT
 16214 00002726 F8                      	CLC
 16215                                  CheckDone:
 16216 00002727 C42E[8A05]              	LES	BP,[THISDPB]
 16217 0000272B 5E                      	POP	SI
 16218 0000272C 5B                      	POP	BX
 16219 0000272D 58                      	POP	AX
 16220 0000272E 5F                      	POP	DI
 16221 0000272F 1F                      	POP	DS
 16222 00002730 C3                      	retn
 16223                                  
 16224                                  ;Break	<FastOpen_Delete - delete dir info in fastopen>
 16225                                  ;---------------------------------------------------------------------------
 16226                                  ; Procedure Name : FastOpen_Delete
 16227                                  ; Inputs:
 16228                                  ;	None
 16229                                  ; Function:
 16230                                  ;	Call FastOpen to delete the dir info.
 16231                                  ; Outputs:
 16232                                  ;	None
 16233                                  ;---------------------------------------------------------------------------
 16234                                  
 16235                                  FastOpen_Delete:
 16236 00002731 9C                      	PUSHF			; save flag
 16237 00002732 56                      	PUSH	SI		; save registers
 16238 00002733 53                      	PUSH	BX
 16239 00002734 50                      	PUSH	AX
 16240                                  	;mov	si,[WFP_START] ; MSDOS 3.3
 16241                                  ;hkn; SS override
 16242                                  	; 17/05/2019 - Retro DOS v4.0
 16243                                  	; MSDOS 6.0
 16244 00002735 368B36[B205]            	MOV	SI,[ss:WFP_START] ; ds:si points to path name
 16245                                  	
 16246 0000273A B003                    	MOV	AL,FONC_delete	; al = 3
 16247                                  fastinvoke:
 16248                                  ;hkn; FastTable is in DOSDATA
 16249 0000273C BB[320D]                	MOV	BX,FastTable+2
 16250 0000273F FF1F                    	CALL	far [BX]	; call fastopen
 16251 00002741 58                      	POP	AX		; restore registers
 16252 00002742 5B                      	POP	BX
 16253 00002743 5E                      	POP	SI
 16254 00002744 9D                      	POPF			; restore flag
 16255 00002745 C3                      	retn
 16256                                  
 16257                                  	; 13/11/2022 Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 16258                                  	; DOSCODE:65A0h (MSDOS 5.0 MSDOS.SYS)
 16259                                  
 16260                                  ;Break	<FastOpen_Rename - Rename directory>	   ; PTR 5622
 16261                                  ;---------------------------------------------------------------------------
 16262                                  ; PROCEDURE Name : FastOpen_Rename
 16263                                  ;
 16264                                  ; Inputs:
 16265                                  ;	 REN_WFP   = Path Name
 16266                                  ;	 NAME1	   = New Name
 16267                                  ; Function:
 16268                                  ;	Call FastOpen to rename the dir entry in the cache
 16269                                  ; Outputs:
 16270                                  ;	None
 16271                                  ;---------------------------------------------------------------------------
 16272                                  
 16273                                  FastOpen_Rename:
 16274                                  	; 17/05/2019 - Retro DOS v4.0
 16275                                  	; 08/08/2018 - Retro DOS v3.0
 16276                                  	; MSDOS 6.0
 16277 00002746 9C                      	PUSHF			;AN001 save flag
 16278 00002747 56                      	PUSH	SI		;AN001 save registers
 16279 00002748 57                      	PUSH	DI		;AN001
 16280 00002749 53                      	PUSH	BX		;AN001
 16281 0000274A 50                      	PUSH	AX		;AN001
 16282                                  	;
 16283                                  ;hkn; SS override
 16284 0000274B 368B36[B405]            	MOV	SI,[SS:REN_WFP]	;AN001	;;AN001  ds:si-->Path name addrs
 16285                                  
 16286                                  ;hkn; NAME1 is in DOSDATA
 16287 00002750 BF[4B05]                	MOV	DI,NAME1	;;AN001  ds:di-->New name addrs
 16288                                  	;mov	al,6
 16289 00002753 B006                    	MOV	AL,FONC_Rename	;;AN001  al = 6
 16290                                  	
 16291                                  ;hkn; FastTable is in DOSDATA
 16292 00002755 BB[320D]                	MOV	BX,FastTable+2
 16293 00002758 FF1F                    	CALL	far [BX]	;;AN001  call fastopen
 16294                                  	
 16295 0000275A 58                      	POP	AX		; restore registers  ;AN001
 16296 0000275B 5B                      	POP	BX				     ;AN001
 16297 0000275C 5F                      	POP	DI				     ;AN001
 16298 0000275D 5E                      	POP	SI				     ;AN001
 16299 0000275E 9D                      	POPF			; restore flag	     ;AN001
 16300 0000275F C3                      	retn					     ;AN001
 16301                                  
 16302                                  ;Break	<FastOpen_Update - update dir info in fastopen>
 16303                                  ;---------------------------------------------------------------------------
 16304                                  ; Procedure Name : FastOpen_Update
 16305                                  ;
 16306                                  ; Inputs:
 16307                                  ;	DL     drive number (A=0,B=1,,,)
 16308                                  ;	CX     first cluster #
 16309                                  ;	AH     0 updates dir entry
 16310                                  ;	       1 updates CLUSNUM , BP = new CLUSNUM
 16311                                  ;	ES:DI  directory entry
 16312                                  ; Function:
 16313                                  ;	Call FastOpen to update the dir info.
 16314                                  ; Outputs:
 16315                                  ;	None
 16316                                  ;---------------------------------------------------------------------------
 16317                                  
 16318                                  FastOpen_Update:
 16319 00002760 9C                      	PUSHF			; save flag
 16320 00002761 56                      	PUSH	SI
 16321 00002762 53                      	PUSH	BX		; save regs
 16322 00002763 50                      	PUSH	AX
 16323 00002764 B004                    	MOV	AL,FONC_update	; al = 4
 16324 00002766 EBD4                    	JMP	short fastinvoke
 16325                                  
 16326                                  	; 17/05/2019
 16327                                  
 16328                                  	; MSDOS 6.0
 16329                                  ;entry Fast_Dispatch		; future fastxxxx entry	;AN000;
 16330                                  ;---------------------------------------------------------------------------
 16331                                  Fast_Dispatch:
 16332                                  ;hkn; FastTable is in DOSDATA
 16333 00002768 BE[320D]                	MOV	SI,FastTable+2	; index to the	     ;AN000;
 16334                                  ;hkn; use SS override
 16335 0000276B 36FF1C                  	CALL	far [SS:SI]	; RMFD call fastopen
 16336 0000276E C3                      	retn
 16337                                  
 16338                                  ;============================================================================
 16339                                  ; RENAME.ASM, MSDOS 6.0, 1991
 16340                                  ;============================================================================
 16341                                  ; 08/08/2018 - Retro DOS v3.0
 16342                                  ; 17/05/2019 - Retro DOS v4.0
 16343                                  
 16344                                  ;	TITLE	DOS_RENAME - Internal RENAME call for MS-DOS
 16345                                  ;	NAME	DOS_RENAME
 16346                                  
 16347                                  ;**	Low level routine for renaming files
 16348                                  ;----------------------------------------------------------------------------
 16349                                  ;	DOS_RENAME
 16350                                  ;
 16351                                  ;	Modification history:
 16352                                  ;
 16353                                  ;	    Created: ARR 30 March 1983
 16354                                  
 16355                                  ;----------------------------------------------------------------------------
 16356                                  ;
 16357                                  ; Procedure Name : DOS_RENAME
 16358                                  ;
 16359                                  ; Inputs:
 16360                                  ;	[WFP_START] Points to SOURCE WFP string ("d:/" must be first 3
 16361                                  ;		chars, NUL terminated)
 16362                                  ;	[CURR_DIR_END] Points to end of Current dir part of string [SOURCE]
 16363                                  ;		( = -1 if current dir not involved, else
 16364                                  ;		 Points to first char after last "/" of current dir part)
 16365                                  ;	[REN_WFP] Points to DEST WFP string ("d:/" must be first 3
 16366                                  ;		chars, NUL terminated)
 16367                                  ;	[THISCDS] Points to CDS being used
 16368                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 16369                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 16370                                  ; Function:
 16371                                  ;	Rename the specified file(s)
 16372                                  ;	NOTE: This routine uses most of AUXSTACK as a temp buffer.
 16373                                  ; Outputs:
 16374                                  ;	CARRY CLEAR
 16375                                  ;	    OK
 16376                                  ;	CARRY SET
 16377                                  ;	    AX is error code
 16378                                  ;		error_file_not_found
 16379                                  ;			No match for source, or dest path invalid
 16380                                  ;		error_not_same_device
 16381                                  ;			Source and dest are on different devices
 16382                                  ;		error_access_denied
 16383                                  ;			Directory specified (not simple rename),
 16384                                  ;			Device name given, Destination exists.
 16385                                  ;			NOTE: In third case some renames may have
 16386                                  ;			 been done if metas.
 16387                                  ;		error_path_not_found
 16388                                  ;			Bad path (not in curr dir part if present)
 16389                                  ;			SOURCE ONLY
 16390                                  ;		error_bad_curr_dir
 16391                                  ;			Bad path in current directory part of path
 16392                                  ;			SOURCE ONLY
 16393                                  ;		error_sharing_violation
 16394                                  ;			Deny both access required, generates an INT 24.
 16395                                  ; DS preserved, others destroyed
 16396                                  ;
 16397                                  ;----------------------------------------------------------------------------
 16398                                  
 16399                                  	; 14/11/2022 Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 16400                                  
 16401                                  DOS_RENAME:
 16402                                  
 16403                                  ;hkn; DOS_RENAME is called from file.asm and fcbio.asm. DS has been set up
 16404                                  ;hkn; at this point to DOSDATA.
 16405                                  
 16406 0000276F E821EB                  	call	TestNet
 16407 00002772 7306                    	JNC	short LOCAL_RENAME
 16408                                  
 16409                                  ;IF NOT Installed
 16410                                  ;	transfer NET_RENAME
 16411                                  ;ELSE
 16412                                  	;MOV	AX,(MultNET SHL 8) OR 17
 16413                                  	;INT	2FH
 16414                                  	;return
 16415                                  
 16416 00002774 B81111                  	mov     ax, 1111h
 16417 00002777 CD2F                    	int     2Fh 	; Multiplex - NETWORK REDIRECTOR - RENAME REMOTE FILE
 16418                                  			; SS = DS = DOS CS, 
 16419                                  			; SDA first filename pointer = offset of fully-qualified old name
 16420                                  			; SDA CDS pointer -> current directory
 16421                                  			; Return: CF set on error
 16422 00002779 C3                      	retn
 16423                                  ;ENDIF
 16424                                  
 16425                                  LOCAL_RENAME:
 16426 0000277A C606[2303]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk ; 2
 16427 0000277F 8B36[B205]              	MOV	SI,[WFP_START]
 16428 00002783 8B3E[B405]              	MOV	DI,[REN_WFP]
 16429 00002787 8A04                    	MOV	AL,[SI]
 16430 00002789 8A25                    	MOV	AH,[DI]
 16431 0000278B 0D2020                  	OR	AX,2020H		; Lower case
 16432 0000278E 38E0                    	CMP	AL,AH
 16433 00002790 7405                    	JZ	short SAMEDRV
 16434 00002792 B81100                  	MOV	AX,error_not_same_device ; 11h
 16435 00002795 F9                      	STC
 16436 00002796 C3                      	retn
 16437                                  
 16438                                  SAMEDRV:
 16439 00002797 FF36[2E03]              	PUSH	WORD [DMAADD+2]
 16440 0000279B FF36[2C03]              	PUSH	WORD [DMAADD]
 16441 0000279F 8C1E[2E03]              	MOV	[DMAADD+2],DS
 16442                                  
 16443                                  ;hkn; RENAMEDMA is in DOSDATA
 16444 000027A3 C706[2C03][2006]        	MOV	WORD [DMAADD],RENAMEDMA
 16445 000027A9 C606[7005]00            	MOV	byte [FOUND_DEV],0	; Rename fails on DEVS, assume not a dev
 16446 000027AE E8A6EB                  	call	ECritDisk
 16447 000027B1 E8F505                  	call	DOS_SEARCH_FIRST	; Sets [NoSetDir] to 1, [CURBUF+2]:BX
 16448                                  					;    points to entry
 16449 000027B4 7314                    	JNC	short Check_Dev
 16450 000027B6 83F812                  	CMP	AX,error_no_more_files ; 12h
 16451 000027B9 7503                    	JNZ	short GOTERR
 16452 000027BB B80200                  	MOV	AX,error_file_not_found ; 2
 16453                                  GOTERR:
 16454 000027BE F9                      	STC
 16455                                  RENAME_POP:
 16456 000027BF 8F06[2C03]              	POP	WORD [DMAADD]
 16457 000027C3 8F06[2E03]              	POP	WORD [DMAADD+2]
 16458                                  	;call	LCritDisk
 16459                                  	;retn
 16460                                  	; 16/12/2022
 16461 000027C7 E9A8EB                  	jmp	LCritDisk
 16462                                  
 16463                                  Check_Dev:
 16464                                  	; 17/05/2019 - Retro DOS v4.0
 16465                                  	;mov	ax,5
 16466 000027CA B80500                  	MOV	AX,error_access_denied	; Assume error
 16467                                  	
 16468                                  	; MSDOS 6.0
 16469 000027CD 1E                      	PUSH	DS			      ;PTM.			    ;AN000;
 16470 000027CE C536[2C03]              	LDS	SI,[DMAADD]		      ;PTM.  chek if source a dir   ;AN000;
 16471                                  	;add	si,21
 16472 000027D2 83C615                  	ADD	SI,find_buf.attr	      ;PTM.			    ;AN000;
 16473                                  	;test	byte [si+11],10h
 16474 000027D5 F6440B10                	TEST	byte [SI+dir_entry.dir_attr],attr_directory ;PTM.	    ;AN000;
 16475 000027D9 7407                    	JZ	short notdir		      ;PTM.			    ;AN000;
 16476 000027DB 8B36[B405]              	MOV	SI,[REN_WFP]		      ;PTM.  if yes, make sure path ;AN000;
 16477 000027DF E8CCFA                  	call	Check_PathLen2		      ;PTM.   length < 67	    ;AN000;
 16478                                  notdir:
 16479 000027E2 1F                      	POP	DS			      ;PTM.			    ;AN000;
 16480 000027E3 77D9                    	JA	short GOTERR		      ;PTM.			    ;AN000;
 16481                                  
 16482                                  	; MSDOS 3.3 & MSDOS 6.0
 16483 000027E5 803E[7005]00            	CMP	byte [FOUND_DEV],0
 16484 000027EA 75D2                    	JNZ	short GOTERR
 16485                                  
 16486                                  ; At this point a source has been found. There is search continuation info (a
 16487                                  ; la DOS_SEARCH_NEXT) for the source at RENAMEDMA, together with the first
 16488                                  ; directory entry found.
 16489                                  ; [THISCDS], [THISDPB], and [THISDRV] are set and will remain correct
 16490                                  ; throughout the RENAME since it is known at this point that the source and
 16491                                  ; destination are both on the same device.
 16492                                  ; [SATTRIB] is also set.
 16493                                  
 16494 000027EC 89DE                    	MOV	SI,BX
 16495                                  	;add	si,26
 16496 000027EE 83C61A                  	ADD	SI,dir_entry.dir_first
 16497 000027F1 E8CFFE                  	call	REN_DEL_Check
 16498 000027F4 7305                    	JNC	short REN_OK1
 16499 000027F6 B82000                  	MOV	AX,error_sharing_violation  ; 20h
 16500 000027F9 EBC4                    	JMP	short RENAME_POP
 16501                                  
 16502                                  ;------------------------------------------------------------------------------
 16503                                  ; Check if the source is a file or directory. If file, delete the entry
 16504                                  ; from the Fastopen cache. If directory, rename it later
 16505                                  ;------------------------------------------------------------------------------
 16506                                  
 16507                                  REN_OK1:				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 16508                                  	; MSDOS 6.0
 16509 000027FB 56                      	PUSH	SI
 16510 000027FC C536[2C03]              	LDS	SI,[DMAADD]		;BN00X; PTM. check if source a dir ;AN000;
 16511                                  	;add	si,21
 16512 00002800 83C615                  	ADD	SI,find_buf.attr	;;BN00XPTM.P5520		;AN000;
 16513                                  	;test	byte [si+11],10h
 16514 00002803 F6440B10                	TEST	byte [SI+dir_entry.dir_attr],attr_directory ;;BN00XPTM. ;AN000;
 16515 00002807 7403                    	JZ	short NOT_DIR1		;;BN00XPTM.			;AN000;
 16516 00002809 5E                      	POP	SI			;BN00X
 16517 0000280A EB04                    	JMP	SHORT SWAP_SOURCE	;BN00X
 16518                                  NOT_DIR1:				;;BN00X it is a file, delete the entry
 16519 0000280C 5E                      	POP	SI
 16520                                  
 16521                                  	; MSDOS 3.3 (& MSDOS 6.0)	
 16522 0000280D E821FF                  	call	FastOpen_Delete 	; delete dir info in fastopen DOS 3.3
 16523                                  SWAP_SOURCE:
 16524                                  	; MSDOS 3.3
 16525                                  	;MOV	SI,[REN_WFP]
 16526                                  	;MOV	[WFP_START],SI
 16527                                  	; MSDOS 6.0
 16528 00002810 A1[B205]                	MOV	AX,[WFP_START]		; Swap source and destination
 16529 00002813 8B36[B405]              	MOV	SI,[REN_WFP]		; Swap source and destination
 16530 00002817 8936[B205]              	MOV	[WFP_START],SI		; WFP_START = Destination path
 16531 0000281B A3[B405]                	MOV	[REN_WFP],AX		; REN_WFP   = Source path
 16532                                  	; MSDOS 3.3 (& MSDOS 6.0)
 16533 0000281E C706[B605]FFFF          	MOV	word [CURR_DIR_END],-1	; No current dir on dest
 16534                                  	;mov	word [CREATING],0E5FFh
 16535 00002824 C706[7E05]FFE5          	MOV	WORD [CREATING],DIRFREE*256+0FFh  ; Creating, not DEL *.*
 16536                                  					; A rename is like a CREATE_NEW as far
 16537                                  					; as the destination is concerned.
 16538 0000282A E85F17                  	call	GetPathNoSet
 16539                                  
 16540                                  ;   If this GETPATH fails due to file not found, we know all renames will work
 16541                                  ;   since no files match the destination name. If it fails for any other
 16542                                  ;   reason, the rename fails on a path not found, or whatever (also fails if
 16543                                  ;   we find a device or directory). If the GETPATH succeeds, we aren't sure
 16544                                  ;   if the rename should fail because we haven't built an explicit name by
 16545                                  ;   substituting for the meta chars in it. In this case the destination file
 16546                                  ;   spec with metas is in [NAME1] and the explicit source name is at RENAMEDMA
 16547                                  ;   in the directory entry part.
 16548                                  	
 16549 0000282D 7223                    	JC	short NODEST
 16550                                  	
 16551                                  	; MSDOS 6.0
 16552                                  	;JZ	short BAD_ACC 		; Dest string is a directory	;AC000;
 16553                                  	; !! MSDOS 3.3 !!
 16554                                  	;JZ	short BAD_ACC ; !!	; Dest string is a directory
 16555                                  
 16556 0000282F 08E4                    	OR	AH,AH			; Device?
 16557 00002831 792C                    	JNS	short SAVEDEST		; No, continue
 16558                                  BAD_ACC:
 16559 00002833 B80500                  	MOV	AX,error_access_denied
 16560 00002836 F9                      	STC
 16561                                  RENAME_CLEAN:
 16562 00002837 9C                      	PUSHF				; Save carry state
 16563 00002838 50                      	PUSH	AX			; and error code (if carry set)
 16564 00002839 A0[7605]                	MOV	AL,[THISDRV]
 16565 0000283C E87B32                  	call	FLUSHBUF
 16566 0000283F 58                      	POP	AX
 16567 00002840 803E[4A03]00            	CMP	byte [FAILERR],0
 16568 00002845 7504                    	JNZ	short BAD_ERR		; User FAILed to I 24
 16569 00002847 9D                      	POPF
 16570 00002848 E974FF                  	JMP	RENAME_POP
 16571                                  
 16572                                  BAD_ERR:
 16573 0000284B 58                      	POP	AX			; Saved flags
 16574                                  	; 16/12/202
 16575                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 16576                                  BAD_PATH: ; *
 16577 0000284C B80300                  	MOV	AX,error_path_not_found
 16578 0000284F E96CFF                  	JMP	GOTERR
 16579                                  
 16580                                  NODEST:
 16581 00002852 75F8                    	JNZ	short BAD_PATH
 16582 00002854 803E[4A03]00            	CMP	byte [FAILERR],0
 16583 00002859 75F1                    	JNZ	short BAD_PATH		; Search for dest failed 
 16584                                  					; because user FAILed on I 24
 16585                                  	; 14/11/2022
 16586 0000285B 08C9                    	OR	CL,CL
 16587                                  	;JNZ	short SAVEDEST
 16588                                  	; 17/05/2019
 16589 0000285D 74ED                    	jz	short BAD_PATH ; *
 16590                                  ;BAD_PATH: ; *
 16591                                  ;	MOV	AX,error_path_not_found
 16592                                  ;	;STC
 16593                                  ;	;JMP	RENAME_POP
 16594                                  ;	; 17/05/2019
 16595                                  ;	jmp	GOTERR 
 16596                                  
 16597                                  ; 16/12/2022
 16598                                  %if 0
 16599                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 16600                                  	or	cl,cl
 16601                                  	jnz	short SAVEDEST
 16602                                  	;jz	short BAD_PATH ; *
 16603                                  BAD_PATH: ; *
 16604                                  	;mov	ax,3
 16605                                  	mov	ax,error_path_not_found
 16606                                  	stc
 16607                                  	jmp	RENAME_POP
 16608                                  %endif
 16609                                  
 16610                                  SAVEDEST:
 16611 0000285F 16                      	push	ss
 16612 00002860 07                      	pop	es
 16613                                  
 16614                                  ;hkn; NAME1 & NAME2 is in DOSDATA
 16615 00002861 BF[5705]                	MOV	DI,NAME2
 16616 00002864 BE[4B05]                	MOV	SI,NAME1
 16617                                  
 16618 00002867 B90B00                  	MOV	CX,11
 16619 0000286A F3A4                    	REP	MOVSB			; Save dest with metas at NAME2
 16620 0000286C A1[C205]                	MOV	AX,[DIRSTART]
 16621 0000286F A3[6405]                	MOV	[DESTSTART],AX
 16622                                  BUILDDEST:
 16623 00002872 16                      	push	ss
 16624 00002873 07                      	pop	es			; needed due to JMP BUILDDEST below
 16625                                  
 16626                                  ;hkn; RENAMEDMA, NAME1, NAME2 in DOSDATA
 16627 00002874 BB[3506]                	MOV	BX,RENAMEDMA+21		; Source of replace chars
 16628 00002877 BF[4B05]                	MOV	DI,NAME1		; Real dest name goes here
 16629 0000287A BE[5705]                	MOV	SI,NAME2		; Raw dest
 16630                                  
 16631 0000287D B90B00                  	MOV	CX,11
 16632                                  
 16633                                  	; 17/05/2019 - Retro DOS v4.0
 16634                                  	
 16635                                  	; MSDOS 6.0
 16636 00002880 E81201                  	CALL	NEW_RENAME		;IFS. replace ? chars	;AN000;
 16637                                  
 16638                                  	; MSDOS 3.3
 16639                                  
 16640                                  ; 08/08/2018 - Retro DOS v3.0
 16641                                  ; MSDOS 6.0 
 16642                                  ;---------------------------------------------------------------------------
 16643                                  ;Procedure: NEW_RENAME
 16644                                  ;
 16645                                  ;Input: DS:SI -> raw string with ?
 16646                                  ;	ES:DI -> destination string
 16647                                  ;	DS:BX -> source string
 16648                                  ;Function: replace ? chars of raw string with chars in source string and
 16649                                  ;	   put in destination string
 16650                                  ;Output: ES:DI-> new string
 16651                                  ;---------------------------------------------------------------------------
 16652                                  ;
 16653                                  ;NEW_RENAME:
 16654                                  ;NEWNAM:
 16655                                  ;	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 341Ah
 16656                                  ;	LODSB
 16657                                  ;	CMP	AL,"?"
 16658                                  ;	JNZ	short NOCHG
 16659                                  ;	MOV	AL,[BX] 		; Get replace char
 16660                                  ;NOCHG:
 16661                                  ;	STOSB
 16662                                  ;	INC	BX			; Next replace char
 16663                                  ;	LOOP	NEWNAM
 16664                                  ;	; MSDOS 6.0
 16665                                  ;	;retn
 16666                                  
 16667                                  	; MSDOS 3.3 & MSDOS 6.0
 16668                                  	;mov	byte [ATTRIB],16h
 16669 00002883 C606[6B05]16            	MOV	byte [ATTRIB],attr_all	; Stop duplicates with any attributes
 16670 00002888 C606[7E05]FF            	MOV	byte [CREATING],0FFH
 16671 0000288D E8AA19                  	call	DEVNAME 		; Check if we built a device name
 16672 00002890 73A1                    	JNC	short BAD_ACC
 16673 00002892 8B1E[6405]              	MOV	BX,[DESTSTART]
 16674 00002896 C42E[8A05]              	LES	BP,[THISDPB]
 16675 0000289A E88C16                  	call	SETDIRSRCH		; Reset search to start of dir
 16676 0000289D 7294                    	JC	short BAD_ACC 		; Screw up
 16677 0000289F E84615                  	call	FINDENTRY		; See if new name already exists
 16678 000028A2 738F                    	JNC	short BAD_ACC 		; Error if found
 16679 000028A4 803E[4A03]00            	CMP	byte [FAILERR],0
 16680 000028A9 752A                    	JNZ	short BAD_ACCJ		; Find failed because user FAILed to I 24
 16681 000028AB A1[6405]                	MOV	AX,[DESTSTART]		; DIRSTART of dest
 16682 000028AE 3B06[2F06]              	CMP	AX,[RENAMEDMA+15]	; DIRSTART of source
 16683 000028B2 745D                    	JZ	short SIMPLE_RENAME	; If =, just give new name
 16684                                  
 16685                                  	;mov	al,[RENAMEDMA+32]
 16686 000028B4 A0[4006]                	MOV	AL,[RENAMEDMA+21+dir_entry.dir_attr]
 16687 000028B7 A810                    	TEST	AL,attr_directory ; 10h
 16688 000028B9 751A                    	JNZ	short BAD_ACCJ		; Can only do a simple rename on dirs,
 16689                                  					; otherwise the . and .. entries get
 16690                                  					; wiped.
 16691 000028BB A2[6B05]                	MOV	[ATTRIB],AL
 16692 000028BE 8C1E[A005]              	MOV	[THISSFT+2],DS
 16693                                  
 16694                                  ;hkn; AUXSTACK is in DOSDATA
 16695                                  	;mov	si,[RENAMEDMA+145h]
 16696 000028C2 BE[6507]                	MOV	SI,AUXSTACK-SF_ENTRY.size  ; RENAMEDMA+325
 16697 000028C5 8936[9E05]              	MOV	[THISSFT],SI
 16698                                  	;mov	word [SI+2],2
 16699 000028C9 C744020200              	MOV	word [SI+SF_ENTRY.sf_mode],SHARING_COMPAT+open_for_both
 16700 000028CE 31C9                    	XOR	CX,CX			; Set "device ID" for call into makenode
 16701 000028D0 E84521                  	call	RENAME_MAKE		; This is in mknode
 16702 000028D3 7303                    	JNC	short GOT_DEST
 16703                                  BAD_ACCJ:
 16704 000028D5 E95BFF                  	JMP	BAD_ACC
 16705                                  
 16706                                  GOT_DEST:
 16707 000028D8 53                      	push	bx
 16708 000028D9 C43E[9E05]              	LES	DI,[THISSFT]		; RENAME_MAKE entered this into sharing
 16709 000028DD E8FD4A                  	call	ShareEnd		; we need to remove it.
 16710 000028E0 5B                      	pop	bx
 16711                                  
 16712                                  ; A zero length entry with the correct new name has now been made at
 16713                                  ;   [CURBUF+2]:BX.
 16714                                  
 16715 000028E1 C43E[E205]              	LES	DI,[CURBUF]
 16716                                  
 16717                                  	; MSDOS 6.0
 16718                                  	;test	byte [es:di+5],40h
 16719 000028E5 26F6450540              	TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty  
 16720                                  					;LB. if already dirty		  ;AN000;
 16721 000028EA 7508                    	JNZ	short yesdirty1		;LB.  don't increment dirty count ;AN000;
 16722 000028EC E8D032                  	call	INC_DIRTY_COUNT 	;LB.				  ;AN000;
 16723                                  	;or	byte [es:di+5],40h
 16724 000028EF 26804D0540              	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
 16725                                  yesdirty1:
 16726 000028F4 89DF                    	MOV	DI,BX
 16727                                  	;add	di,11
 16728 000028F6 83C70B                  	ADD	DI,dir_entry.dir_attr	; Skip name
 16729                                  
 16730                                  ;hkn; RENAMEDMA is in DOSDATA
 16731                                  	;mov	si,[RENAMEDMA+32]
 16732 000028F9 BE[4006]                	MOV	SI,RENAMEDMA+21+dir_entry.dir_attr
 16733                                  	;mov	cx,21
 16734 000028FC B91500                  	MOV	CX,dir_entry.size-dir_entry.dir_attr
 16735 000028FF F3A4                    	REP	MOVSB
 16736 00002901 E87B00                  	CALL	GET_SOURCE
 16737 00002904 7276                    	JC	short RENAME_OVER
 16738 00002906 89DF                    	MOV	DI,BX
 16739 00002908 8E06[E405]              	MOV	ES,[CURBUF+2]
 16740 0000290C B0E5                    	MOV	AL,DIRFREE ; 0E5h
 16741 0000290E AA                      	STOSB				; "free" the source
 16742 0000290F EB13                    	JMP	SHORT DIRTY_IT
 16743                                  
 16744                                  SIMPLE_RENAME:
 16745 00002911 E86B00                  	CALL	GET_SOURCE		; Get the source back
 16746 00002914 7266                    	JC	short RENAME_OVER
 16747 00002916 89DF                    	MOV	DI,BX
 16748 00002918 8E06[E405]              	MOV	ES,[CURBUF+2]
 16749                                  
 16750                                  ;hkn; NAME1 is in DOSDATA
 16751 0000291C BE[4B05]                	MOV	SI,NAME1		; New Name
 16752 0000291F B90B00                  	MOV	CX,11
 16753 00002922 F3A4                    	REP	MOVSB
 16754                                  DIRTY_IT:
 16755 00002924 8B3E[E205]              	MOV	DI,[CURBUF]
 16756                                  
 16757                                  	; MSDOS 6.0
 16758 00002928 26F6450540              	TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty  
 16759                                  					;LB. if already dirty		  ;AN000;
 16760 0000292D 7508                    	JNZ	short yesdirty2		;LB.  don't increment dirty count ;AN000;
 16761 0000292F E88D32                  	call	INC_DIRTY_COUNT 	;LB.				  ;AN000;
 16762                                  	
 16763 00002932 26804D0540              	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
 16764                                  
 16765                                  ;------------------------------------------------------------------------------
 16766                                  ; Check if the source is a directory of file. If directory rename it to the
 16767                                  ; the new name in the Fastopen cache buffer. If file name it has been
 16768                                  ; previously deleted.
 16769                                  ;------------------------------------------------------------------------------
 16770                                  
 16771                                  yesdirty2:
 16772                                  	; MSDOS 6.0
 16773 00002937 56                      	PUSH	SI
 16774 00002938 C536[2C03]              	LDS	SI,[DMAADD]		;;BN00XPTM. chek if source a dir ;AN000;
 16775 0000293C 83C615                  	ADD	SI,find_buf.attr	;;BN00XPTM.P5520		;AN000;
 16776 0000293F F6440B10                	TEST	byte [SI+dir_entry.dir_attr],attr_directory ;;BN00XPTM.	;AN000;
 16777 00002943 7406                    	JZ	short NOT_DIR2		;;BN00XPTM.			;AN000;
 16778 00002945 E8FEFD                  	call	FastOpen_Rename		;;BN00X rename dir entry in fastopen
 16779 00002948 5E                      	POP	SI
 16780 00002949 EB01                    	JMP	SHORT NOT_DIRTY1
 16781                                  NOT_DIR2:				;;BN00X it is a file, delete the entry
 16782 0000294B 5E                      	POP	SI
 16783                                  NOT_DIRTY1:				;;BN00X
 16784                                  NEXT_SOURCE:
 16785                                  ;hkn; RENAMEDMA is in DOSDATA
 16786 0000294C BE[2106]                	MOV	SI,RENAMEDMA+1		;Name
 16787                                  
 16788                                  ; WARNING! Rename_Next leaves the disk critical section *ALWAYS*. We need
 16789                                  ; to enter it before going to RENAME_Next.
 16790                                  
 16791 0000294F E805EA                  	call	ECritDisk
 16792 00002952 C606[7E05]00            	MOV	byte [CREATING],0 ; Correct setting for search (we changed it
 16793                                  				  ;  to FF when we made the prev new file).
 16794 00002957 E88705                  	call	RENAME_NEXT
 16795                                  
 16796                                  ; Note, now, that we have exited the previous ENTER and so are back to where
 16797                                  ; we were before.
 16798                                  
 16799 0000295A 7220                    	JC	short RENAME_OVER
 16800                                  
 16801                                  	;lea	si,[bx+26]
 16802 0000295C 8D771A                  	LEA	SI,[BX+dir_entry.dir_first]
 16803 0000295F E861FD                  	call	REN_DEL_Check
 16804 00002962 7306                    	JNC	short REN_OK2
 16805 00002964 B82000                  	MOV	AX,error_sharing_violation ; 20h
 16806                                  jmp_to_rename_clean: ; 28/12/2022
 16807 00002967 E9CDFE                  	JMP	RENAME_CLEAN ; 10/08/2018
 16808                                  
 16809                                  ;------------------------------------------------------------------------------
 16810                                  ; Check if file or directory. If file, delete file from the Fastopen cache,
 16811                                  ; if directory, rename directory name in the Fastopen cache.
 16812                                  ;-----------------------------------------------------------------------------
 16813                                  
 16814                                  REN_OK2:
 16815                                  	; MSDOS 6.0
 16816                                  	;mov	al,[RERNAMEDMA+32]
 16817 0000296A A0[4006]                	MOV	AL,[RENAMEDMA+21+dir_entry.dir_attr] ; PTR P5622
 16818                                  	;test	al,10h
 16819 0000296D A810                    	TEST	AL,attr_directory	;;BN00X directory
 16820 0000296F 7406                    	JZ	short Ren_Directory	;;BN00X no - file, delete it
 16821                                  	
 16822                                  	; MSDOS 3.3 & MSDOS 6.0
 16823 00002971 E8BDFD                  	call	FastOpen_Delete 	;;BN00X delete dir info in fastopen DOS 3.3
 16824                                  jmp_to_builddest: ; 28/12/2022
 16825 00002974 E9FBFE                  	JMP	BUILDDEST		;;BN00X
 16826                                  
 16827                                  	; MSDOS 6.0
 16828                                  Ren_Directory:
 16829 00002977 E8CCFD                  	call	FastOpen_Rename 	;;BN00X delete dir info in fastopen DOS 3.3
 16830                                  	;JMP	BUILDDEST
 16831                                  	; 28/12/2022
 16832 0000297A EBF8                    	jmp	short jmp_to_builddest
 16833                                  
 16834                                  RENAME_OVER:
 16835 0000297C F8                      	CLC
 16836                                  	;JMP	RENAME_CLEAN ; 10/08/2018
 16837                                  	; 28/12/2022
 16838 0000297D EBE8                    	jmp	short jmp_to_rename_clean
 16839                                  
 16840                                  ;----------------------------------------------------------------------------
 16841                                  ; Procedure: GET_SOURCE
 16842                                  ;
 16843                                  ; Inputs:
 16844                                  ;	RENAMEDMA has source info
 16845                                  ; Function:
 16846                                  ;	Re-find the source
 16847                                  ; Output:
 16848                                  ;	[CURBUF] set
 16849                                  ;	[CURBUF+2]:BX points to entry
 16850                                  ;	Carry set if error (currently user FAILed to I 24)
 16851                                  ; DS preserved, others destroyed
 16852                                  ;----------------------------------------------------------------------------
 16853                                  
 16854                                  GET_SOURCE:
 16855 0000297F 8B1E[2F06]              	MOV	BX,[RENAMEDMA+15]	; DirStart
 16856 00002983 C42E[8A05]              	LES	BP,[THISDPB]
 16857 00002987 E89F15                  	call	SETDIRSRCH
 16858 0000298A 7214                    	JC	short gs_ret_label	; retc
 16859 0000298C E88A18                  	call	STARTSRCH
 16860 0000298F A1[2D06]                	MOV	AX,[RENAMEDMA+13]	; Lastent
 16861                                  	;call	GETENT
 16862                                  	; 18/12/2022
 16863 00002992 E96515                  	jmp	GETENT
 16864                                  ;gs_ret_label:
 16865                                  	;retn
 16866                                  
 16867                                  ; MSDOS 6.0 
 16868                                  ;---------------------------------------------------------------------------
 16869                                  ;Procedure: NEW_RENAME
 16870                                  ;
 16871                                  ;Input: DS:SI -> raw string with ?
 16872                                  ;	ES:DI -> destination string
 16873                                  ;	DS:BX -> source string
 16874                                  ;Function: replace ? chars of raw string with chars in source string and
 16875                                  ;	   put in destination string
 16876                                  ;Output: ES:DI-> new string
 16877                                  ;---------------------------------------------------------------------------
 16878                                  
 16879                                  NEW_RENAME:
 16880                                  	; 17/05/2019 - Retro DOS v4.0
 16881                                  NEWNAM:
 16882                                  	; DOSCODE:680Eh (MSDOS 6.21, MSDOS.SYS)
 16883 00002995 AC                      	LODSB
 16884 00002996 3C3F                    	CMP	AL,"?" ; 3Fh
 16885 00002998 7502                    	JNZ	short NOCHG
 16886 0000299A 8A07                    	MOV	AL,[BX] 		; Get replace char
 16887                                  NOCHG:
 16888 0000299C AA                      	STOSB
 16889 0000299D 43                      	INC	BX			; Next replace char
 16890 0000299E E2F5                    	LOOP	NEWNAM
 16891                                  	; MSDOS 6.0
 16892                                  gs_ret_label:	; 18/12/2022
 16893 000029A0 C3                      	retn
 16894                                  
 16895                                  ;============================================================================
 16896                                  ; FINFO.ASM, MSDOS 6.0, 1991
 16897                                  ;============================================================================
 16898                                  ; 08/08/2018 - Retro DOS v3.0
 16899                                  ; 17/05/2019 - Retro DOS v4.0
 16900                                  
 16901                                  ;**	Low level routines for returning file information and setting file
 16902                                  ;	attributes
 16903                                  ;
 16904                                  ;	GET_FILE_INFO
 16905                                  ;	SET_FILE_ATTRIBUTE
 16906                                  ;
 16907                                  ;	Modification history:
 16908                                  ;
 16909                                  ;	    Created: ARR 30 March 1983
 16910                                  ;
 16911                                  ;	M025: Return access_denied if attempting to set
 16912                                  ;	      attribute of root directory.
 16913                                  ;
 16914                                  
 16915                                  ;SUBTTL GET_FILE_INFO -- Get File Information
 16916                                  
 16917                                  ;---------------------------------------------------------------------------
 16918                                  ; Procedure Name : GET_FILE_INFO
 16919                                  ;
 16920                                  ; Inputs:
 16921                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 16922                                  ;		terminated)
 16923                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 16924                                  ;		( = -1 if current dir not involved, else
 16925                                  ;		 Points to first char after last "/" of current dir part)
 16926                                  ;	[THISCDS] Points to CDS being used
 16927                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 16928                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 16929                                  ; Function:
 16930                                  ;	Get Information about a file
 16931                                  ; Returns:
 16932                                  ;	CARRY CLEAR
 16933                                  ;	    AX = Attribute of file
 16934                                  ;	    CX = Time stamp of file
 16935                                  ;	    DX = Date stamp of file
 16936                                  ;	    BX:DI = Size of file (32 bit)
 16937                                  ;	CARRY SET
 16938                                  ;	    AX is error code
 16939                                  ;		error_file_not_found
 16940                                  ;			Last element of path not found
 16941                                  ;		error_path_not_found
 16942                                  ;			Bad path (not in curr dir part if present)
 16943                                  ;		error_bad_curr_dir
 16944                                  ;			Bad path in current directory part of path
 16945                                  ; DS preserved, others destroyed
 16946                                  ;---------------------------------------------------------------------------
 16947                                  
 16948                                  	; 14/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 16949                                  
 16950                                  GET_FILE_INFO:
 16951                                  
 16952                                  ;hkn; get_file_info is called from file.asm and fcbio.asm. DS has been set 
 16953                                  ;hkn; to DOSDATA at this point. So DOSassume is OK.
 16954                                  
 16955 000029A1 E8EFE8                  	call	TestNet
 16956 000029A4 7306                    	JNC	short LOCAL_INFO
 16957                                  
 16958                                  ;IF NOT Installed
 16959                                  ;	transfer NET_GET_FILE_INFO
 16960                                  ;ELSE
 16961                                  ;	MOV	AX,(MultNET SHL 8) OR 15
 16962                                  ;	INT	2FH
 16963                                  ;	return
 16964                                  
 16965 000029A6 B80F11                  	mov     ax, 110Fh
 16966 000029A9 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - GET REMOTE FILE'S ATTRIBUTES
 16967                                  			; SS = DOS CS, SDA first filename pointer -> fully-qualified name of file
 16968                                  			; SDA CDS pointer -> current directory
 16969                                  			; Return: CF set on error, AX = file attributes
 16970 000029AB C3                      	retn
 16971                                  ;ENDIF
 16972                                  
 16973                                  LOCAL_INFO:
 16974 000029AC E8A8E9                  	call	ECritDisk
 16975 000029AF C606[4C03]01            	MOV	byte [NoSetDir],1	; if we find a dir, don't change to it
 16976                                  	; MSDOS 3.3
 16977                                  	;call	GETPATH
 16978                                  	; MSDOS 6.0
 16979 000029B4 E8D800                  	call	GET_FAST_PATH
 16980                                  	; MSDOS 3.3 & MSDOS 6.0
 16981 000029B7 7312                    	JNC	short info_check_dev
 16982                                  NO_PATH:
 16983 000029B9 750B                    	JNZ	short bad_path1
 16984 000029BB 08C9                    	OR	CL,CL
 16985 000029BD 7407                    	JZ	short bad_path1
 16986                                  info_no_file:
 16987 000029BF B80200                  	MOV	AX,error_file_not_found
 16988                                  BadRet:
 16989 000029C2 F9                      	STC
 16990                                  JustRet:
 16991                                  	;call	LCritDisk
 16992                                  	;retn
 16993                                  	; 18/12/2022
 16994 000029C3 E9ACE9                  	jmp	LCritDisk
 16995                                  
 16996                                  bad_path1:
 16997 000029C6 B80300                  	MOV	AX,error_path_not_found
 16998 000029C9 EBF7                    	jmp	short BadRet
 16999                                  
 17000                                  info_check_dev:
 17001 000029CB 08E4                    	OR	AH,AH
 17002 000029CD 78F0                    	JS	short info_no_file	; device
 17003                                  
 17004                                  	; MSDOS 6.0
 17005                                  ;SR;
 17006                                  ; If root dir then CurBuf == -1. Check for this case and return subdir attr
 17007                                  ;for a root dir
 17008                                  
 17009 000029CF 833E[E205]FF            	cmp	word [CURBUF],-1	;is it a root dir?
 17010 000029D4 7506                    	jne	short not_root		;no, CurBuf ptr is valid
 17011                                  
 17012 000029D6 30E4                    	xor	ah,ah
 17013 000029D8 B010                    	mov	al,attr_directory ; 10h
 17014                                  	;clc
 17015                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 17016                                  	; (DOSCODE:683Eh)
 17017                                  	; 16/12/2022
 17018                                  	;clc
 17019 000029DA EBE7                    	jmp	short JustRet
 17020                                  
 17021                                  not_root:
 17022                                  	; MSDOS 3.3 (& MSDOS 6.0)
 17023 000029DC 1E                      	PUSH	DS
 17024 000029DD 8E1E[E405]              	MOV	DS,[CURBUF+2]
 17025 000029E1 89DE                    	MOV	SI,BX
 17026 000029E3 31DB                    	XOR	BX,BX			; Assume size=0 (dir)
 17027 000029E5 89DF                    	MOV	DI,BX
 17028                                  	;mov	cx,[si+16h]
 17029 000029E7 8B4C16                  	MOV	CX,[SI+dir_entry.dir_time]
 17030                                  	;mov	dx,[si+18h]
 17031 000029EA 8B5418                  	MOV	DX,[SI+dir_entry.dir_date]
 17032 000029ED 30E4                    	XOR	AH,AH
 17033                                  	;mov	al,[si+0Bh]
 17034 000029EF 8A440B                  	MOV	AL,[SI+dir_entry.dir_attr]
 17035                                  	;test	al,10h
 17036 000029F2 A810                    	TEST	AL,attr_directory
 17037 000029F4 7506                    	JNZ	short NO_SIZE
 17038                                  	;mov	di,[si+1Ch]
 17039 000029F6 8B7C1C                  	MOV	DI,[SI+dir_entry.dir_size_l]
 17040                                  	;mov	bx,[si+1Eh]
 17041 000029F9 8B5C1E                  	MOV	BX,[SI+dir_entry.dir_size_h]
 17042                                  NO_SIZE:
 17043 000029FC 1F                      	POP	DS
 17044                                  	;CLC
 17045                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 17046                                  	; (DOSCODE:6864h)
 17047                                  	; 16/12/2022
 17048                                  	;clc
 17049 000029FD EBC4                    	jmp	short JustRet
 17050                                  
 17051                                  ;Break	<SET_FILE_ATTRIBUTE -- Set File Attribute>
 17052                                  ;-------------------------------------------------------------------------------
 17053                                  ; Procedure Name : SET_FILE_ATTRIBUTE
 17054                                  ; Inputs:
 17055                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 17056                                  ;		terminated)
 17057                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 17058                                  ;		( = -1 if current dir not involved, else
 17059                                  ;		 Points to first char after last "/" of current dir part)
 17060                                  ;	[THISCDS] Points to CDS being used
 17061                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 17062                                  ;	[SATTRIB] is attribute of search (determines what files may be found)
 17063                                  ;	AX is new attributes to give to file
 17064                                  ; Function:
 17065                                  ;	Set File Attributes
 17066                                  ; Returns:
 17067                                  ;	CARRY CLEAR
 17068                                  ;	    No error
 17069                                  ;	CARRY SET
 17070                                  ;	    AX is error code
 17071                                  ;		error_file_not_found
 17072                                  ;			Last element of path not found
 17073                                  ;		error_path_not_found
 17074                                  ;			Bad path (not in curr dir part if present)
 17075                                  ;		error_bad_curr_dir
 17076                                  ;			Bad path in current directory part of path
 17077                                  ;		error_access_denied
 17078                                  ;			Attempt to set an attribute which cannot be set
 17079                                  ;			(attr_directory, attr_volume_ID)
 17080                                  ;		error_sharing_violation
 17081                                  ;			Sharing mode of file did not allow the change
 17082                                  ;			(this request requires exclusive write/read access)
 17083                                  ;			(INT 24H generated)
 17084                                  ; DS preserved, others destroyed
 17085                                  ;----------------------------------------------------------------------------
 17086                                  
 17087                                  SET_FILE_ATTRIBUTE:
 17088                                  
 17089                                  ;hkn; set_file_attr is called from file.asm. DS has been set 
 17090                                  ;hkn; to DOSDATA at this point. So DOSassume is OK.
 17091                                  
 17092 000029FF A9D8FF                  	TEST	AX,~attr_changeable ; 0FFD8h
 17093 00002A02 7414                    	JZ	short set_look
 17094                                  _BAD_ACC:
 17095 00002A04 C606[2303]01            	MOV	byte [EXTERR_LOCUS],errLOC_Unk ; 1
 17096 00002A09 C606[2703]07            	MOV	byte [EXTERR_CLASS],errCLASS_Apperr ; 7
 17097 00002A0E C606[2603]04            	MOV	byte [EXTERR_ACTION],errACT_Abort ; 4
 17098 00002A13 B80500                  	MOV	AX,error_access_denied ; 5
 17099 00002A16 F9                      	STC
 17100 00002A17 C3                      	retn
 17101                                  
 17102                                  set_look:
 17103 00002A18 E878E8                  	call	TestNet
 17104 00002A1B 7308                    	JNC	short LOCAL_SET
 17105                                  
 17106                                  ;IF NOT Installed
 17107                                  ;	transfer NET_SEQ_SET_FILE_ATTRIBUTE
 17108                                  ;ELSE
 17109 00002A1D 50                      	PUSH	AX
 17110                                  	
 17111                                  	;MOV	AX,(MultNET SHL 8) OR 14
 17112                                  	;INT	2FH
 17113                                  
 17114 00002A1E B80E11                  	mov     ax, 110Eh
 17115 00002A21 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - SET REMOTE FILE'S ATTRIBUTES
 17116                                  			; SS = DOS CS, SDA first filename pointer -> fully-qualified name of file
 17117                                  			; SDA CDS pointer -> current directory
 17118                                  			; STACK: WORD new file attributes
 17119                                  			; Return: CF set on error
 17120                                  
 17121 00002A23 5B                      	POP	BX			; clean stack
 17122 00002A24 C3                      	retn
 17123                                  ;ENDIF
 17124                                  
 17125                                  LOCAL_SET:
 17126 00002A25 E82FE9                  	call	ECritDisk
 17127 00002A28 50                      	PUSH	AX			; Save new attributes
 17128 00002A29 C606[4C03]01            	MOV	byte [NoSetDir],1	; if we find a dir, don't change to it
 17129 00002A2E E85515                  	call	GETPATH 		; get path through fastopen if there	;AC000;
 17130 00002A31 7303                    	JNC	short set_check_device
 17131 00002A33 5B                      	POP	BX			; Clean stack (don't zap AX)
 17132 00002A34 EB83                    	JMP	short NO_PATH
 17133                                  
 17134                                  set_check_device:
 17135 00002A36 08E4                    	OR	AH,AH
 17136 00002A38 7906                    	JNS	short set_check_share
 17137 00002A3A 58                      	POP	AX
 17138 00002A3B E834E9                  	call	LCritDisk
 17139 00002A3E EBC4                    	JMP	short _BAD_ACC 		; device
 17140                                  
 17141                                  set_check_share:
 17142 00002A40 58                      	POP	AX			; Get new attributes
 17143                                  
 17144                                  	; MSDOS 6.0
 17145 00002A41 833E[E205]FF            	cmp	word [CURBUF], -1	; M025: Q: is this the root dir
 17146 00002A46 740A                    	je	short cannot_set_root	; M025: Y: return error
 17147                                  
 17148                                  	; MSDOS 3.3 & MSDOS 6.0
 17149 00002A48 E878FC                  	call	REN_DEL_Check
 17150 00002A4B 730B                    	JNC	short set_do
 17151 00002A4D B82000                  	MOV	AX,error_sharing_violation ; 32
 17152 00002A50 EB3A                    	jmp	short OK_BYE
 17153                                  
 17154                                  	; MSDOS 6.0
 17155                                  cannot_set_root:			; M025:
 17156 00002A52 B80500                  	mov	ax,error_access_denied	; M025: return error is attempting
 17157 00002A55 F9                      	stc				; M025: to set attr. of root
 17158 00002A56 EB34                    	jmp	short OK_BYE		; M025:
 17159                                  
 17160                                  set_do:
 17161                                  	; MSDOS 3.3 & MSDOS 6.0
 17162 00002A58 C43E[E205]              	LES	DI,[CURBUF]
 17163 00002A5C 2680670BD8              	AND	BYTE [ES:BX+dir_entry.dir_attr],~attr_changeable ; 0D8h
 17164 00002A61 2608470B                	OR	BYTE [ES:BX+dir_entry.dir_attr],AL
 17165                                  
 17166                                  	; MSDOS 6.0
 17167 00002A65 26F6450540              	TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty  
 17168                                  					;LB. if already dirty		  ;AN000;
 17169 00002A6A 7508                    	JNZ	short yesdirty3		;LB.  don't increment dirty count ;AN000;
 17170 00002A6C E85031                  	call	INC_DIRTY_COUNT 	;LB.				  ;AN000;
 17171                                  	
 17172 00002A6F 26804D0540              	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
 17173                                  yesdirty3:
 17174 00002A74 A0[7605]                	MOV	AL,[THISDRV]
 17175                                  ;;;; 10/1/86 F.C update fastopen cache
 17176 00002A77 52                      	PUSH	DX
 17177 00002A78 57                      	PUSH	DI
 17178 00002A79 B400                    	MOV	AH,0		  ; dir entry update
 17179 00002A7B 88C2                    	MOV	DL,AL		  ; drive number A=0,B=1,,
 17180 00002A7D 89DF                    	MOV	DI,BX		  ; ES:DI -> dir entry
 17181 00002A7F E8DEFC                  	call	FastOpen_Update
 17182 00002A82 5F                      	POP	DI
 17183 00002A83 5A                      	POP	DX
 17184                                  ;;;; 9/11/86 F.C update fastopen cache
 17185 00002A84 E83330                  	call	FLUSHBUF
 17186 00002A87 7303                    	JNC	short OK_BYE
 17187 00002A89 B80200                  	MOV	AX,error_file_not_found
 17188                                  OK_BYE:
 17189                                  	;call	LCritDisk
 17190                                  	;retn
 17191                                  	; 16/12/2022
 17192 00002A8C E9E3E8                  	jmp	LCritDisk
 17193                                  
 17194                                  	; 17/05/2019 - Retro DOS v4.0
 17195                                  
 17196                                  	; MSDOS 6.0
 17197                                  GET_FAST_PATH:
 17198                                  ;hkn; use SS override for FastOpenFlg
 17199 00002A8F 36800E[3A0D]01          	OR	byte [ss:FastOpenFlg],FastOpen_Set
 17200                                  					;FO. trigger fastopen	;AN000;
 17201 00002A95 E8EE14                  	call	GETPATH
 17202 00002A98 9C                      	PUSHF			 	;FO.			;AN000;
 17203 00002A99 368026[3A0D]80          	AND	byte [ss:FastOpenFlg],Fast_yes 
 17204                                  					;FO. clear all fastopen flags ;AN000;
 17205 00002A9F 9D                      	POPF				;FO.			;AN000;
 17206 00002AA0 C3                      	retn
 17207                                  
 17208                                  ;============================================================================
 17209                                  ; DUP.ASM, MSDOS 6.0, 1991
 17210                                  ;============================================================================
 17211                                  ; 08/08/2018 - Retro DOS v3.0
 17212                                  ; 17/05/2019 - Retro DOS v4.0
 17213                                  
 17214                                  ;** 	Low level DUP routine for use by EXEC when creating a new process.
 17215                                  ;   	Exports the DUP to the server machine and increments the SFT ref count
 17216                                  ;
 17217                                  ;	DOS_DUP
 17218                                  ;
 17219                                  ;	Modification history:
 17220                                  ;
 17221                                  ;	  Created: ARR 30 March 1983
 17222                                  
 17223                                  ;BREAK <DOS_DUP -- DUP SFT across network>
 17224                                  ;---------------------------------------------------------------------------
 17225                                  ; Procedure Name : DOS_DUP
 17226                                  ;
 17227                                  ; Inputs:
 17228                                  ;	[THISSFT] set to the SFT for the file being DUPed
 17229                                  ;		(a non net SFT is OK, in this case the ref
 17230                                  ;		 count is simply incremented)
 17231                                  ; Function:
 17232                                  ;	Signal to the devices that a logical open is occurring
 17233                                  ; Returns:
 17234                                  ;	ES:DI point to SFT
 17235                                  ;    Carry clear
 17236                                  ;	SFT ref_count is incremented
 17237                                  ; Registers modified: None.
 17238                                  ; NOTE:
 17239                                  ;	This routine is called from $CREATE_PROCESS_DATA_BLOCK at DOSINIT
 17240                                  ;	time with SS NOT DOSGROUP. There will be no Network handles at
 17241                                  ;	that time.
 17242                                  ;---------------------------------------------------------------------------
 17243                                  
 17244                                  DOS_DUP:
 17245                                  	;LES	DI,[CS:THISSFT]  ; MSDOS 3.3
 17246                                  
 17247                                  	; MSDOS 6.0
 17248 00002AA1 2E8E06[0700]            	mov	es,[cs:DosDSeg]
 17249 00002AA6 26C43E[9E05]            	les	di,[es:THISSFT]
 17250                                  
 17251                                  	;Entry	Dos_Dup_Direct
 17252                                  DOS_Dup_Direct:
 17253 00002AAB E8FEE7                  	call	IsSFTNet
 17254 00002AAE 7503                    	JNZ	short DO_INC
 17255 00002AB0 E8A01B                  	call	DEV_OPEN_SFT
 17256                                  DO_INC:
 17257                                  	;INC	word [ES:DI+SF_ENTRY.sf_ref_count]
 17258 00002AB3 26FF05                  	inc	word [ES:DI]		; Clears carry (if this ever wraps
 17259                                  					;   we're in big trouble anyway)
 17260 00002AB6 C3                      	retn
 17261                                  
 17262                                  ;============================================================================
 17263                                  ; CREATE.ASM, MSDOS 6.0, 1991
 17264                                  ;============================================================================
 17265                                  ; 08/08/2018 - Retro DOS v3.0
 17266                                  ; 18/05/2019 - Retro DOS v4.0
 17267                                  
 17268                                  ;TITLE	DOS_CREATE/DOS_CREATE_NEW - Internal CREATE calls for MS-DOS
 17269                                  ;NAME	DOS_CREATE
 17270                                  ;----------------------------------------------------------------------------
 17271                                  ;**	Internal Create and Create new to create a local or NET file and SFT.
 17272                                  ;
 17273                                  ;	DOS_CREATE
 17274                                  ;	DOS_CREATE_NEW
 17275                                  ;	SET_MKND_ERR
 17276                                  ;	SET_Media_ID
 17277                                  ;	SET_EXT_Mode
 17278                                  ;
 17279                                  ;	Revision history:
 17280                                  ;
 17281                                  ;	    A000 version 4.00	  Jan. 1988
 17282                                  ;	    A001  D490 -- Change IOCTL subfunctios from 63h,43h to 66h, 46h
 17283                                  
 17284                                  ;Installed = TRUE
 17285                                  
 17286                                  ;	i_need	THISSFT,DWORD
 17287                                  ;	i_need	THISCDS,DWORD
 17288                                  ;	I_need	EXTERR,WORD
 17289                                  ;	I_Need	ExtErr_locus,BYTE
 17290                                  ;	I_need	JShare,DWORD
 17291                                  ;	I_need	VOLCHNG_FLAG,BYTE
 17292                                  ;	I_need	SATTRIB,BYTE
 17293                                  ;	I_need	CALLVIDM,DWORD
 17294                                  ;	I_need	EXTOPEN_ON,BYTE 		  ;AN000; extended open
 17295                                  ;	I_need	NAME1,BYTE			  ;AN000;
 17296                                  ;	I_need	NO_NAME_ID,BYTE 		  ;AN000;
 17297                                  ;	I_need	Packet_Temp,WORD		  ;AN000;
 17298                                  ;	I_need	DOS34_FLAG,WORD 		  ;AN000;
 17299                                  ;	I_need	SAVE_BX,WORD			  ;AN000;
 17300                                  
 17301                                  ;***	DOS_CREATE - Create a File
 17302                                  ;----------------------------------------------------------------------------
 17303                                  ;	DOS_Create is called to create the specified file, truncating
 17304                                  ;	the old one if it exists.
 17305                                  ;
 17306                                  ;	ENTRY	AX is Attribute to create
 17307                                  ;		(ds) = DOSDATA
 17308                                  ;		[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 17309                                  ;			terminated)
 17310                                  ;		[CURR_DIR_END] Points to end of Current dir part of string
 17311                                  ;			( = -1 if current dir not involved, else
 17312                                  ;			 Points to first char after last "/" of current dir part)
 17313                                  ;		[THISCDS] Points to CDS being used
 17314                                  ;			(Low word = -1 if NUL CDS (Net direct request))
 17315                                  ;		[THISSFT] Points to SFT to fill in if file created
 17316                                  ;			(sf_mode field set so that FCB may be detected)
 17317                                  ;		[SATTRIB] Is attribute of search, determines what files can be found
 17318                                  ;
 17319                                  ;	EXIT	sf_ref_count is NOT altered
 17320                                  ;		CARRY CLEAR
 17321                                  ;		    THISSFT filled in.
 17322                                  ;			sf_mode = unchanged for FCB, sharing_compat + open_for_both
 17323                                  ;		CARRY SET
 17324                                  ;		    AX is error code
 17325                                  ;			error_path_not_found
 17326                                  ;				Bad path (not in curr dir part if present)
 17327                                  ;			error_bad_curr_dir
 17328                                  ;				Bad path in current directory part of path
 17329                                  ;			error_access_denied
 17330                                  ;				Attempt to re-create read only file , or
 17331                                  ;				create a second volume id or create a dir
 17332                                  ;			error_sharing_violation
 17333                                  ;				The sharing mode was correct but not allowed
 17334                                  ;				generates an INT 24
 17335                                  ;	USES	all but DS
 17336                                  ;----------------------------------------------------------------------------
 17337                                  
 17338                                  	; 14/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 17339                                  	; DOSCODE:6920h (MSDOS 5.0, MSDOS.SYS)
 17340                                  
 17341                                  DOS_CREATE:
 17342                                  	; 18/05/2019 - Retro DOS v4.0
 17343                                  	; DOSCODE:6934h (MSDOS 6.21, MSDOS.SYS)
 17344                                  
 17345                                  ;hkn; dispatched to from file.asm and fcbio.asm. DS set up to DOSDATA at 
 17346                                  ;hkn; this point.
 17347                                  
 17348 00002AB7 30E4                    	XOR	AH,AH		; Truncate is OK
 17349                                  
 17350                                  ;	Enter here from Dos_Create_New
 17351                                  ;
 17352                                  ;	(ah) = 0 iff truncate OK
 17353                                  
 17354                                  Create_inter:
 17355 00002AB9 A8C0                    	TEST	AL,~(attr_all+attr_ignore+attr_volume_id) ; 80h
 17356                                  				; Mask out any meaningless bits
 17357 00002ABB 7511                    	JNZ	short AttErr
 17358 00002ABD A808                    	TEST	AL,attr_volume_id
 17359 00002ABF 7407                    	JZ	short NoReset
 17360                                  	
 17361                                  	; MSDOS 6.0
 17362                                  	; 16/12/2022
 17363 00002AC1 800E[1106]80            	OR	byte [DOS34_FLAG],DBCS_VOLID ; 80h ;AN000;FOR dbcs volid
 17364                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 17365                                  	;or	word [DOS34_FLAG],DBCS_VOLID ; 80h 
 17366                                  	
 17367 00002AC6 B008                    	MOV	AL,attr_volume_id ; 8
 17368                                  NoReset:
 17369 00002AC8 0C20                    	OR	AL,attr_archive ; File changed  ; 20 h
 17370 00002ACA A850                    	TEST	AL,attr_directory+attr_device ; 50h
 17371 00002ACC 740A                    	JZ	short ATT_OK
 17372                                  AttErr:
 17373 00002ACE B80500                  	MOV	AX,5		; Attribute problem
 17374 00002AD1 C606[2303]01            	MOV	byte [EXTERR_LOCUS],errLOC_Unk ; 1
 17375 00002AD6 EB66                    	JMP	SHORT SET_MKND_ERR ; Gotta use MKDIR to make dirs, NEVER allow
 17376                                  				   ;	attr_device to be set.
 17377                                  ATT_OK:
 17378 00002AD8 C43E[9E05]              	LES	DI,[THISSFT]
 17379 00002ADC 06                      	PUSH	ES
 17380 00002ADD C436[A205]              	LES	SI,[THISCDS]
 17381 00002AE1 83FEFF                  	CMP	SI,-1
 17382 00002AE4 751D                    	JNE	short TEST_RE_NET
 17383                                  
 17384                                  ;	No CDS, it must be redirected.
 17385                                  
 17386 00002AE6 07                      	POP	ES
 17387                                  
 17388                                  	; MSDOS 6.0
 17389                                  ;Extended open hooks
 17390                                  	;test	byte [EXTOPEN_ON],1
 17391 00002AE7 F606[F605]01            	TEST	byte [EXTOPEN_ON],EXT_OPEN_ON ;AN000;EO. from extended open
 17392 00002AEC 740D                    	JZ	short NOEXTOP 		    ;AN000;EO. no, do normal
 17393                                  IFS_extopen:				    ;AN000;EO.
 17394 00002AEE 50                      	PUSH	AX			    ;AN000;EO. pass create attr
 17395                                  	;MOV	AX,(MultNET SHL 8) OR 46    ;AN000;EO. issue extended open verb
 17396 00002AEF B82E11                  	mov	ax,112Eh
 17397 00002AF2 CD2F                    	INT	2FH			    ;AN000;EO.
 17398 00002AF4 5B                      	POP	BX			    ;AN000;EO. trash bx
 17399 00002AF5 C606[F605]00            	MOV	byte [EXTOPEN_ON],0	    ;AN000;EO.
 17400 00002AFA C3                      	retn				    ;AN000;EO.
 17401                                  NOEXTOP:				    ;AN000;
 17402                                  ;Extended open hooks
 17403                                  
 17404                                  ;IF NOT Installed
 17405                                  ;	transfer NET_SEQ_CREATE
 17406                                  ;ELSE
 17407 00002AFB 50                      	PUSH	AX
 17408                                  
 17409                                  	;MOV	AX,(MultNET SHL 8) OR 24
 17410                                  	;INT	2FH
 17411                                  
 17412 00002AFC B81811                  	mov     ax,1118h
 17413 00002AFF CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - CREATE/TRUNCATE FILE
 17414                                  			; ES:DI -> uninitialized SFT, SS = DOS CS
 17415                                  			; SDA first filename pointer -> fully-qualified name of file
 17416                                  			; STACK: WORD file creation mode???
 17417                                  
 17418 00002B01 5B                      	POP	BX			; BX is trashed anyway
 17419 00002B02 C3                      	retn
 17420                                  ;ENDIF
 17421                                  
 17422                                  ;	We have a CDS. See if it's network
 17423                                  
 17424                                  TEST_RE_NET:
 17425                                  	;;test	word [es:si+43h],8000h
 17426                                  	;TEST	word [ES:SI+curdir.flags],curdir_isnet
 17427                                  	; 07/12/2022
 17428                                  	;test	byte [es:si+44h],80h
 17429                                  	; 17/12/2022
 17430 00002B03 26F6444480              	test	byte [ES:SI+curdir.flags+1],curdir_isnet>>8
 17431 00002B08 07                      	POP	ES
 17432 00002B09 7419                    	JZ	short LOCAL_CREATE
 17433                                  
 17434                                  	; MSDOS 6.0
 17435 00002B0B E8BF00                  	CALL	Set_EXT_mode		    ;AN000;EO.
 17436 00002B0E 7205                    	JC	SHORT dochk		    ;AN000;EO.
 17437                                  	;;or	word [es:di+2],2
 17438                                  	;OR	word [ES:DI+SF_ENTRY.sf_mode],SHARING_COMPAT+open_for_both ;IFS.
 17439                                  	; 17/12/2022
 17440 00002B10 26804D0202              	or	byte [ES:DI+SF_ENTRY.sf_mode],SHARING_COMPAT+open_for_both ;IFS.
 17441                                  
 17442                                  ;Extended open hooks
 17443                                  dochk:
 17444 00002B15 F606[F605]01            	TEST	byte [EXTOPEN_ON],EXT_OPEN_ON ;AN000;EO. from extended open
 17445 00002B1A 75D2                    	JNZ	short IFS_extopen	    ;AN000;EO. yes, issue extended open
 17446                                  ;Extended open hooks
 17447                                  
 17448                                  ;IF NOT Installed
 17449                                  ;	transfer NET_CREATE
 17450                                  ;ELSE
 17451 00002B1C 50                      	PUSH	AX
 17452                                  	
 17453                                  	;MOV	AX,(MultNET SHL 8) OR 23
 17454                                  	;INT	2FH
 17455                                  	
 17456 00002B1D B81711                  	mov     ax,1117h
 17457 00002B20 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - CREATE/TRUNCATE REMOTE FILE
 17458                                  			; ES:DI -> uninitialized SFT, SS = DOS CS
 17459                                  			; SDA first filename pointer -> fully-qualified name of file to open
 17460                                  			; SDA CDS pointer -> current directory
 17461                                  			; Return: CF set on error
 17462                                  
 17463 00002B22 5B                      	POP	BX			; BX is trashed anyway
 17464                                  ;nomore:
 17465 00002B23 C3                      	retn
 17466                                  ;ENDIF
 17467                                  
 17468                                  ;**	It's a local create. We have a local CDS for it.
 17469                                  
 17470                                  LOCAL_CREATE:
 17471                                  	; MSDOS 6.0
 17472 00002B24 E8A600                  	CALL	Set_EXT_mode	;AN000;EO. set mode if from extended open
 17473 00002B27 7205                    	JC	short setdone	;AN000;EO.
 17474                                  	
 17475                                  	; MSDOS 3.3 & MSDOS 6.0
 17476                                  	; 17/12/2022
 17477                                  	;;or	word [es:di+2],2
 17478                                  	;OR	word [ES:DI+SF_ENTRY.sf_mode],SHARING_COMPAT+open_for_both
 17479                                  	;or	byte [es:di+2],2
 17480 00002B29 26804D0202              	or	byte [ES:DI+SF_ENTRY.sf_mode],SHARING_COMPAT+open_for_both	
 17481                                  setdone:
 17482 00002B2E E826E8                  	call	ECritDisk
 17483 00002B31 E8BE1E                  	call	MakeNode
 17484 00002B34 7317                    	JNC	short Create_ok
 17485 00002B36 C606[A10A]FF            	mov	byte [VOLCHNG_FLAG],-1	; indicate no change in volume label
 17486 00002B3B E834E8                  	call	LCritDisk
 17487                                  
 17488                                  	;entry	SET_MKND_ERR
 17489                                  SET_MKND_ERR:
 17490                                  
 17491                                  ;	Looks up MakeNode errors and converts them. AL is MakeNode
 17492                                  ;	error, SI is GETPATH bad spot return if path_not_found error.
 17493                                  
 17494                                  ;hkn; CRTERRTAB is in TABLE seg (DOSCODE)
 17495 00002B3E BB[452B]                	MOV     BX,CRTERRTAB
 17496                                  	;XLAT  ; MSDOS 3.3
 17497                                  	; 18/05/2019 - Retro DOS v4.0
 17498 00002B41 2E                      	CS
 17499 00002B42 D7                      	XLAT
 17500                                  CreatBadRet:
 17501 00002B43 F9                      	STC
 17502 00002B44 C3                      	retn
 17503                                  
 17504                                  ; 13/05/2019 - Retro DOS v4.0
 17505                                  ; DOSCODE:69C4h (MSDOS 6.21, MSDOS.SYS)
 17506                                  ; ---------------------------------------------------------------------------
 17507                                  
 17508                                  ;** Internal Create and Create new to create a local or NET file and SFT.
 17509                                  
 17510                                  ; 17/07/2018 - Retro DOS v3.0
 17511                                  ; Offset 12B1h of IBMDOS.COM (MSDOS 3.3), 1987
 17512                                  
 17513                                  ;CRTERRTAB: ; 19/07/2018 - MSDOS 3.3	
 17514                                  ;	db	0,5,52h,50h,3,5,20h
 17515                                  
 17516                                  ;CRTERRTAB: ; 18/05/2019 - MSDOS 6.0	
 17517                                  ;	db	0,5,52h,50h,3,5,20h,2
 17518                                  
 17519                                  ; 08/08/2018
 17520                                  
 17521                                  CRTERRTAB:	;LABEL BYTE	; Lookup table for MakeNode returns
 17522 00002B45 00                      	DB	0			; none
 17523 00002B46 05                      	DB	error_access_denied	; MakeNode error 1
 17524 00002B47 52                      	DB	error_cannot_make	; MakeNode error 2
 17525 00002B48 50                      	DB	error_file_exists	; MakeNode error 3
 17526 00002B49 03                      	DB	error_path_not_found	; MakeNode error 4
 17527 00002B4A 05                      	DB	error_access_denied	; MakeNode error 5
 17528 00002B4B 20                      	DB	error_sharing_violation ; MakeNode error 6
 17529                                  	; MSDOS 6.0
 17530 00002B4C 02                      	DB	error_file_not_found	; MakeNode error 7
 17531                                  
 17532                                  ; ---------------------------------------------------------------------------
 17533                                  
 17534                                  ; We have just created a new file. This results in the truncation of old
 17535                                  ; files. We must inform the sharer to slash all the open SFT's for this
 17536                                  ; file to the current size.
 17537                                  
 17538                                  ; If we created a volume id on the diskette, set the VOLCHNG_FLAG to logical
 17539                                  ; drive number to force a Build BPB after Media Check.
 17540                                  
 17541                                  ;;; FASTOPEN 8/29/86
 17542                                  Create_ok:
 17543 00002B4D E8E1FB                  	call	FastOpen_Delete
 17544                                  ;;; FASTOPEN 8/29/86
 17545 00002B50 A0[6D05]                	mov	al,[SATTRIB]
 17546 00002B53 A808                    	test	al,attr_volume_id
 17547 00002B55 741C                    	jz	short NoVolLabel
 17548 00002B57 C43E[A205]              	LES	DI,[THISCDS]
 17549                                  	;mov	ah,[ES:DI+curdir.text]	; get drive letter
 17550 00002B5B 268A25                  	mov	ah,[ES:DI] ; 09/08/2018
 17551 00002B5E 80EC41                  	sub	ah,'A'	; 41h		; convert to drive number
 17552 00002B61 8826[A10A]              	mov	[VOLCHNG_FLAG],ah	;Set flag to indicate volid change
 17553                                  	
 17554                                  	; 18/05/2019 - Retro DOS v4.0
 17555                                  
 17556                                  	; MSDOS 6.0
 17557 00002B65 B701                    	MOV	BH,1			;AN000;>32mb set volume id to boot record
 17558 00002B67 E81F00                  	CALL	Set_Media_ID		;AN000;>32mb
 17559                                  	
 17560 00002B6A E8EAE7                  	call	ECritDisk
 17561 00002B6D E8CB2B                  	call	FATREAD_CDS		; force a media check
 17562 00002B70 E8FFE7                  	call	LCritDisk
 17563                                  
 17564                                  NoVolLabel:
 17565 00002B73 B80200                  	MOV	ax,2
 17566 00002B76 C43E[9E05]              	LES	DI,[THISSFT]
 17567                                  ;if installed
 17568                                  	;call	JShare + 14 * 4
 17569 00002B7A FF1E[C800]              	call	far [JShare+(14*4)] ; 14 = ShSU
 17570                                  ;else
 17571                                  ;	Call	ShSU
 17572                                  ;endif
 17573 00002B7E E8F1E7                  	call	LCritDisk
 17574 00002B81 E94901                  	jmp	SET_SFT_MODE
 17575                                  
 17576                                  ;---------------------------------------------------------------------------
 17577                                  ; Procedure Name : Dos_Create_New
 17578                                  ;
 17579                                  ; Inputs:
 17580                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 17581                                  ;		terminated)
 17582                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 17583                                  ;		( = -1 if current dir not involved, else
 17584                                  ;		 Points to first char after last "/" of current dir part)
 17585                                  ;	[THISCDS] Points to CDS being used
 17586                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 17587                                  ;	[THISSFT] Points to SFT to fill in if file created
 17588                                  ;		(sf_mode field set so that FCB may be detected)
 17589                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 17590                                  ;	AX is Attribute to create
 17591                                  ; Function:
 17592                                  ;	Try to create the specified file truncating an old one that exists
 17593                                  ; Outputs:
 17594                                  ;	sf_ref_count is NOT altered
 17595                                  ;	CARRY CLEAR
 17596                                  ;	    THISSFT filled in.
 17597                                  ;		sf_mode = sharing_compat + open_for_both for Non-FCB SFT
 17598                                  ;	CARRY SET
 17599                                  ;	    AX is error code
 17600                                  ;		error_path_not_found
 17601                                  ;			Bad path (not in curr dir part if present)
 17602                                  ;		error_bad_curr_dir
 17603                                  ;			Bad path in current directory part of path
 17604                                  ;		error_access_denied
 17605                                  ;			Create a second volume id or create a dir
 17606                                  ;		error_file_exists
 17607                                  ;			Already a file by this name
 17608                                  ; DS preserved, others destroyed
 17609                                  ;---------------------------------------------------------------------------
 17610                                  
 17611                                  DOS_Create_New:
 17612 00002B84 B401                    	MOV	AH,1		; Truncate is NOT OK
 17613 00002B86 E930FF                  	JMP	Create_inter
 17614                                  
 17615                                  ; MSDOS 6.0
 17616                                  ;---------------------------------------------------------------------------
 17617                                  ; Procedure Name : Set_Media_ID
 17618                                  ;
 17619                                  ; Inputs:
 17620                                  ;	NAME1= Volume ID
 17621                                  ;	BH= 0, delete volume id
 17622                                  ;	    1, set new volume id
 17623                                  ;	DS= DOSGROUP
 17624                                  ; Function:
 17625                                  ;	Set Volume ID to DOS 4.00 Boot record.
 17626                                  ; Outputs:
 17627                                  ;	CARRY CLEAR
 17628                                  ;	    volume id set
 17629                                  ;	CARRY SET
 17630                                  ;	    AX is error code
 17631                                  ;---------------------------------------------------------------------------
 17632                                  
 17633                                  	; 18/05/2019 - Retro DOS v4.0
 17634                                  Set_Media_ID:
 17635 00002B89 50                      	PUSH	AX		;AN000;;>32mb
 17636 00002B8A 06                      	PUSH	ES		;AN000;;>32mb
 17637 00002B8B 57                      	PUSH	DI		;AN000;;>32mb
 17638                                  
 17639 00002B8C FEC4                    	INC	AH		;AN000;;>32mb  bl=drive #
 17640 00002B8E 88E3                    	MOV	BL,AH		;AN000;;>32mb  bl=drive # (A=1,B=2,,,)
 17641 00002B90 B00D                    	MOV	AL,0DH		;AN000;;>32mb  generic IOCTL
 17642 00002B92 B96608                  	MOV	CX,0866H	;AN001;;>32mb  get media id
 17643                                  
 17644                                  ;hkn; PACKET_TEMP is in DOSDATA
 17645 00002B95 BA[6C0D]                	MOV	DX,Packet_Temp	;AN000;>32mb
 17646                                  
 17647 00002B98 53                      	PUSH	BX		;AN000;;>32mb
 17648 00002B99 52                      	PUSH	DX		;AN000;;>32mb
 17649 00002B9A 30FF                    	XOR	BH,BH		;AN000;;>32mb
 17650                                  
 17651                                  	;invoke	$IOCTL		;AN000;;>32mb
 17652 00002B9C E83EF7                  	call	_$IOCTL	
 17653                                  
 17654 00002B9F 5A                      	POP	DX		;AN000;;>32mb
 17655 00002BA0 5B                      	POP	BX		;AN000;;>32mb
 17656 00002BA1 7224                    	JC	short geterr	;AN000;;>32mb
 17657                                  
 17658 00002BA3 08FF                    	OR	BH,BH		;AN000;;>32mb delete volume id
 17659 00002BA5 7405                    	JZ	short NoName	;AN000;>32mb yes
 17660                                  
 17661                                  ;hkn; NAME1 is in DOSDATA
 17662 00002BA7 BE[4B05]                	MOV	SI,NAME1	;AN000;>32mb
 17663                                  
 17664 00002BAA EB03                    	JMP	SHORT doset	;AN000;>32mb yes
 17665                                  NoName: 			;AN000;
 17666                                  
 17667                                  ;hkn; NO_NAME_ID is in DOSDATA
 17668 00002BAC BE[BA0D]                	MOV	SI,NO_NAME_ID	;AN000;>32mb
 17669                                  
 17670                                  doset:				;AN000;
 17671 00002BAF 89D7                    	MOV	DI,DX		;AN000;;>32mb
 17672                                  	;add	di,6
 17673 00002BB1 83C706                  	ADD	DI,MEDIA_ID_INFO.MEDIA_Label ;AN000;;>32mb
 17674                                  
 17675                                  ;hkn; ES & DS must point to SS
 17676                                  ;hkn;	PUSH	CS		;AN000;;>32mb  move new volume id to packet
 17677 00002BB4 16                      	PUSH	SS		;AN000;;>32mb  move new volume id to packet
 17678                                  
 17679 00002BB5 1F                      	POP	DS		;AN000;;>32mb
 17680                                  
 17681                                  ;hkn;	PUSH	CS		;AN000;;>32mb
 17682 00002BB6 16                      	PUSH	SS		;AN000;;>32mb
 17683                                  
 17684 00002BB7 07                      	POP	ES		;AN000;;>32mb
 17685 00002BB8 B90B00                  	MOV	CX,11		;AN000;;>32mb
 17686 00002BBB F3A4                    	REP	MOVSB		;AN000;;>32mb
 17687 00002BBD B94608                  	MOV	CX,0846H	;AN001;;>32mb
 17688 00002BC0 B00D                    	MOV	AL,0DH		;AN000;;>32mb
 17689 00002BC2 30FF                    	XOR	BH,BH		;AN000;;>32mb
 17690                                  	;invoke	$IOCTL		;AN000;;>32mb  set volume id
 17691 00002BC4 E816F7                  	call	_$IOCTL	
 17692                                  geterr: 			;AN000;
 17693                                  ;hkn;	PUSH	CS		;AN000;>32mb
 17694 00002BC7 16                      	PUSH	SS		;AN000;>32mb
 17695                                  
 17696 00002BC8 1F                      	POP	DS		;AN000;>32mb   ds= dosgroup
 17697                                  
 17698 00002BC9 5F                      	POP	DI		;AN000;;>32mb
 17699 00002BCA 07                      	POP	ES		;AN000;;>32mb
 17700 00002BCB 58                      	POP	AX		;AN000;;>32mb
 17701 00002BCC C3                      	retn			;AN000;>32mb
 17702                                  
 17703                                  ; MSDOS 6.0
 17704                                  ;---------------------------------------------------------------------------
 17705                                  ; Procedure Name : Set_EXT_mode
 17706                                  ;
 17707                                  ; Inputs:
 17708                                  ;	[EXTOPEN_ON]= flag for extended open
 17709                                  ;	SAVE_BX= mode specified in Extended Open
 17710                                  ; Function:
 17711                                  ;	Set mode in ThisSFT
 17712                                  ; Outputs:
 17713                                  ;	carry set,mode is set if from Extended Open
 17714                                  ;	carry clear, mode not set yet
 17715                                  ;---------------------------------------------------------------------------
 17716                                  
 17717                                  ; 13/05/2019 - Retro DOS v4.0
 17718                                  
 17719                                  Set_EXT_mode:
 17720                                  
 17721                                  ;hkn; SS override
 17722 00002BCD 36F606[F605]01          	TEST	byte [ss:EXTOPEN_ON],EXT_OPEN_ON ;AN000;EO. from extended open
 17723 00002BD3 740B                    	JZ	short NOTEX		    ;AN000;EO. no, do normal
 17724 00002BD5 50                      	PUSH	AX			    ;AN000;EO.
 17725                                  
 17726                                  ;hkn; SS override
 17727 00002BD6 36A1[0106]              	MOV	AX,[ss:SAVE_BX]		    ;AN000;EO.
 17728                                  	;or	[es:di+2],ax
 17729 00002BDA 26094502                	OR	[ES:DI+SF_ENTRY.sf_mode],AX ;AN000;EO.
 17730 00002BDE 58                      	POP	AX			    ;AN000;EO.
 17731 00002BDF F9                      	STC				    ;AN000;EO.
 17732                                  NOTEX:					    ;AN000;
 17733 00002BE0 C3                      	retn				    ;AN000;EO.
 17734                                  
 17735                                  ;============================================================================
 17736                                  ; OPEN.ASM, MSDOS 6.0, 1991
 17737                                  ;============================================================================
 17738                                  ; 08/08/2018 - Retro DOS v3.0
 17739                                  ; 18/05/2019 - Retro DOS v4.0
 17740                                  
 17741                                  ;	TITLE	DOS_OPEN - Internal OPEN call for MS-DOS
 17742                                  ;	NAME	DOS_OPEN
 17743                                  
 17744                                  ;**	OPEN.ASM - File Open
 17745                                  ;----------------------------------------------------------------------------
 17746                                  ;	Low level routines for openning a file from a file spec.
 17747                                  ;	Also misc routines for sharing errors
 17748                                  ;
 17749                                  ;	DOS_Open
 17750                                  ;	Check_Access_AX
 17751                                  ;	SHARE_ERROR
 17752                                  ;	SET_SFT_MODE
 17753                                  ;	Code_Page_Mismatched_Error		   ; DOS 4.00
 17754                                  ;
 17755                                  ;	Revision history:
 17756                                  ;
 17757                                  ;	    Created: ARR 30 March 1983
 17758                                  ;	    A000	version 4.00   Jan. 1988
 17759                                  ;
 17760                                  ;	M034 - The value in save_bx must be pushed on to the stack for
 17761                                  ; 	       remote extended opens and not save_cx.
 17762                                  ;
 17763                                  ;	M035 - if open made from exec then we must set the appropriate bits
 17764                                  ;	       on the stack before calling off to the redir.
 17765                                  ;	M042 - Bit 11 of DOS34_FLAG set indicates that the redir knows how 
 17766                                  ;	       to handle open from exec. In this case set the appropriate bit
 17767                                  ;	       else do not.
 17768                                  ;----------------------------------------------------------------------------	
 17769                                  
 17770                                  ;Installed = TRUE
 17771                                  
 17772                                  ;	i_need	NoSetDir,BYTE
 17773                                  ;	i_need	THISSFT,DWORD
 17774                                  ;	i_need	THISCDS,DWORD
 17775                                  ;	i_need	CURBUF,DWORD
 17776                                  ;	i_need	CurrentPDB,WORD
 17777                                  ;	i_need	CURR_DIR_END,WORD
 17778                                  ;	I_need	RetryCount,WORD
 17779                                  ;	I_need	Open_Access,BYTE
 17780                                  ;	I_need	fSharing,BYTE
 17781                                  ;	i_need	JShare,DWORD
 17782                                  ;	I_need	FastOpenFlg,byte
 17783                                  ;	I_need	EXTOPEN_ON,BYTE 		  ;AN000;; DOS 4.00
 17784                                  ;	I_need	ALLOWED,BYTE			  ;AN000;; DOS 4.00
 17785                                  ;	I_need	EXTERR,WORD			  ;AN000;; DOS 4.00
 17786                                  ;	I_need	EXTERR_LOCUS,BYTE		  ;AN000;; DOS 4.00
 17787                                  ;	I_need	EXTERR_ACTION,BYTE		  ;AN000;; DOS 4.00
 17788                                  ;	I_need	EXTERR_CLASS,BYTE		  ;AN000;; DOS 4.00
 17789                                  ;	I_need	CPSWFLAG,BYTE			  ;AN000;; DOS 4.00
 17790                                  ;	I_need	EXITHOLD,DWORD			  ;AN000;; DOS 4.00
 17791                                  ;	I_need	THISDPB,DWORD			  ;AN000;; DOS 4.00
 17792                                  ;	I_need	SAVE_CX,WORD			  ;AN000;; DOS 4.00
 17793                                  ;	I_need	SAVE_BX,WORD			  ;M034
 17794                                  ;
 17795                                  ;	I_need	DOS_FLAG,BYTE
 17796                                  ;	I_need	DOS34_FLAG,WORD			  ;M042
 17797                                  
 17798                                  ;Break	<DOS_Open - internal file access>
 17799                                  ;---------------------------------------------------------------------------
 17800                                  ; Procedure Name : DOS_Open
 17801                                  ;
 17802                                  ; Inputs:
 17803                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 17804                                  ;		terminated)
 17805                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 17806                                  ;		( = -1 if current dir not involved, else
 17807                                  ;		 Points to first char after last "/" of current dir part)
 17808                                  ;	[THISCDS] Points to CDS being used
 17809                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 17810                                  ;	[THISSFT] Points to SFT to fill in if file found
 17811                                  ;		(sf_mode field set so that FCB may be detected)
 17812                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 17813                                  ;	AX is Access and Sharing mode
 17814                                  ;	  High NIBBLE of AL (Sharing Mode)
 17815                                  ;		sharing_compat	   file is opened in compatibility mode
 17816                                  ;		sharing_deny_none  file is opened Multi reader, Multi writer
 17817                                  ;		sharing_deny_read  file is opened Only reader, Multi writer
 17818                                  ;		sharing_deny_write file is opened Multi reader, Only writer
 17819                                  ;		sharing_deny_both  file is opened Only reader, Only writer
 17820                                  ;	  Low NIBBLE of AL (Access Mode)
 17821                                  ;		open_for_read	file is opened for reading
 17822                                  ;		open_for_write	file is opened for writing
 17823                                  ;		open_for_both	file is opened for both reading and writing.
 17824                                  ;
 17825                                  ;	  For FCB SFTs AL should = sharing_compat + open_for_both
 17826                                  ;		(not checked)
 17827                                  ; Function:
 17828                                  ;	Try to open the specified file
 17829                                  ; Outputs:
 17830                                  ;	sf_ref_count is NOT altered
 17831                                  ;	CARRY CLEAR
 17832                                  ;	    THISSFT filled in.
 17833                                  ;	CARRY SET
 17834                                  ;	    AX is error code
 17835                                  ;		error_file_not_found
 17836                                  ;			Last element of path not found
 17837                                  ;		error_path_not_found
 17838                                  ;			Bad path (not in curr dir part if present)
 17839                                  ;		error_bad_curr_dir
 17840                                  ;			Bad path in current directory part of path
 17841                                  ;		error_invalid_access
 17842                                  ;			Bad sharing mode or bad access mode or bad combination
 17843                                  ;		error_access_denied
 17844                                  ;			Attempt to open read only file for writting, or
 17845                                  ;			open a directory
 17846                                  ;		error_sharing_violation
 17847                                  ;			The sharing mode was correct but not allowed
 17848                                  ;			generates an INT 24 on compatibility mode SFTs
 17849                                  ; DS preserved, others destroyed
 17850                                  ;----------------------------------------------------------------------------
 17851                                  
 17852                                  ; 18/05/2019 - Retro DOS v4.0
 17853                                  ; DOSCODE:6A60h (MSDOS 6.21, MSDOS.SYS)
 17854                                  ; 14/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 17855                                  ; DOSCODE:6A4Ch (MSDOS 5.0, MSDOS.SYS)
 17856                                  
 17857                                  DOS_OPEN:
 17858                                  	; DS has been set up to DOSDATA in file.asm and fcbio2.asm. 
 17859                                  
 17860 00002BE1 C606[4C03]00            	MOV	byte [NoSetDir],0
 17861 00002BE6 E83301                  	CALL	Check_Access_AX
 17862 00002BE9 722B                    	JC	short do_ret_label	    ; retc
 17863                                  
 17864 00002BEB C43E[9E05]              	LES	DI,[THISSFT]
 17865 00002BEF 30E4                    	XOR	AH,AH
 17866                                  
 17867                                  	; sleaze! move only access/sharing mode in. Leave sf_isFCB unchanged
 17868                                  
 17869 00002BF1 26884502                	MOV	[ES:DI+SF_ENTRY.sf_mode],AL ; For moment do this on FCBs too
 17870 00002BF5 06                      	PUSH	ES
 17871 00002BF6 C436[A205]              	LES	SI,[THISCDS]
 17872                                  	; 18/08/2018
 17873 00002BFA 83FEFF                  	CMP	SI,-1
 17874 00002BFD 7530                    	JNZ	short TEST_RE_NET1
 17875 00002BFF 07                      	POP	ES
 17876                                  
 17877                                  	; MSDOS 6.0
 17878                                  ;Extended open hooks
 17879 00002C00 F606[F605]01            	TEST	byte [EXTOPEN_ON],EXT_OPEN_ON ;FT. from extnded open		;AN000;
 17880 00002C05 7410                    	JZ	short _NOEXTOP 		    ;FT. no, do normal			;AN000;
 17881                                  _IFS_extopen:									;AN000;
 17882 00002C07 A0[0106]                	MOV	AL,[SAVE_BX]		    ; M034 - save_bx has original bx  
 17883                                  					    ; with which call was made. This
 17884                                  					    ; has the open access bits. 
 17885                                  	;;MOV	AL,[SAVE_CX]		    ; M034 - FT. al= create attribute
 17886                                  	
 17887 00002C0A 50                      	PUSH	AX			    ;FT. pass create attr to IFS	;AN000;
 17888                                  	;mov	ax,112Eh
 17889                                  	;MOV	AX,(MultNET SHL 8) OR 46    ;FT. issue extended open verb	;AN000;
 17890 00002C0B B82E11                  	mov	ax,(MultNET*256)+46 
 17891 00002C0E CD2F                    	INT	2FH			    ;FT.				;AN000;
 17892 00002C10 5B                      	POP	BX			    ;FT. trash bx			;AN000;
 17893 00002C11 C606[F605]00            	MOV	byte [EXTOPEN_ON],0	    ;FT.				;AN000;
 17894                                  
 17895                                  do_ret_label:
 17896 00002C16 C3                      	retn				    ;FT.				;AN000;
 17897                                  _NOEXTOP:
 17898                                  ;Extended open hooks
 17899                                  	;
 17900                                  ;IF NOT Installed
 17901                                  	;transfer NET_SEQ_OPEN
 17902                                  ;ELSE
 17903                                  	
 17904                                  do_net_int2f:
 17905 00002C17 F606[8600]01            	test	byte [DOS_FLAG],EXECOPEN ; Q: was this open call made from exec
 17906 00002C1C 7409                    	jz	short not_exec_open	; N: just do net open
 17907                                  					; Y: check to see if redir is aware
 17908                                  					;    of this 
 17909                                  	
 17910                                  					; M042 - start
 17911                                  	;test	word [DOS34_FLAG],EXEC_AWARE_REDIR ; 800h
 17912 00002C1E F606[1206]08            	test	byte [DOS34_FLAG+1],(EXEC_AWARE_REDIR>>8)
 17913                                  					; Q: does this redir know how to 
 17914                                  					;    this
 17915 00002C23 7402                    	jz	short not_exec_open	; N: just do net open
 17916                                  					; Y: set bit 3 of access byte and 
 17917                                  					;    set sharing mode to DENY_WRITE
 17918                                  					; M042 - end
 17919                                  	
 17920                                  	; NOTE: This specific mode has not been set for the code assembled
 17921                                  	; under the "NOT Installed" conditional. Currently Installed is 
 17922                                  	; always one.
 17923                                  					; M035 - set the bits on the stack
 17924                                  	;mov	al,23h
 17925 00002C25 B023                    	mov	AL,SHARING_DENY_WRITE+EXEC_OPEN
 17926                                  	
 17927                                  not_exec_open:
 17928                                  	; MSDOS 3.3 & MSDOS 6.0
 17929 00002C27 50                      	PUSH	AX
 17930                                  
 17931                                  	;MOV	AX,(MultNET SHL 8) OR 22
 17932                                  	;INT	2FH
 17933                                  
 17934 00002C28 B81611                  	mov     ax,1116h
 17935 00002C2B CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - OPEN EXISTING REMOTE FILE
 17936                                  			; ES:DI -> uninitialized SFT, SS = DOS CS
 17937                                  			; SDA first filename pointer -> fully-qualified name of file to open
 17938                                  			; STACK: WORD file open mode
 17939                                  			; Return: CF set on error
 17940                                  
 17941 00002C2D 5B                      	POP	BX			; clean stack
 17942                                  ;do_ret_label: ; 09/08/2018
 17943 00002C2E C3                      	retn
 17944                                  ;ENDIF
 17945                                  
 17946                                  TEST_RE_NET1:
 17947                                  	;TEST	word [ES:SI+curdir.flags],curdir_isnet
 17948                                  	; 17/12/2022
 17949 00002C2F 26F6444480              	test	byte [ES:SI+curdir.flags+1],curdir_isnet>>8
 17950 00002C34 07                      	POP	ES
 17951                                  	; 18/05/2019
 17952 00002C35 7409                    	JZ	short LOCAL_OPEN
 17953                                  
 17954                                  ;Extended open hooks
 17955                                  	; MSDOS 6.0
 17956 00002C37 F606[F605]01            	TEST	byte [EXTOPEN_ON],EXT_OPEN_ON ;FT. from extended open	;AN000;
 17957 00002C3C 75C9                    	JNZ	short _IFS_extopen	      ;FT. isuue extended open	;AN000;
 17958                                  ;Extended open hooks
 17959                                  
 17960                                  ;IF NOT Installed
 17961                                  ;	transfer NET_OPEN
 17962                                  ;ELSE
 17963 00002C3E EBD7                    	jmp	short do_net_int2f
 17964                                  ;ENDIF
 17965                                  
 17966                                  LOCAL_OPEN:
 17967                                  	; MSDOS 3.3 & MSDOS 6.0
 17968 00002C40 E814E7                  	call	ECritDisk
 17969                                  
 17970                                  ; DOS 3.3 FastOPen 6/16/86
 17971                                  
 17972                                  	;or	byte [FastOpenFlg],5
 17973 00002C43 800E[3A0D]05            	OR	byte [FastOpenFlg],FastOpen_Set+Special_Fill_Set ; only open can
 17974                                  
 17975 00002C48 E83B13                  	call	GETPATH
 17976                                  
 17977                                  ; DOS 3.3 FastOPen 6/16/86
 17978                                  
 17979 00002C4B 731D                    	JNC	short Open_found
 17980 00002C4D 7511                    	JNZ	short bad_path2
 17981 00002C4F 08C9                    	OR	CL,CL
 17982 00002C51 740D                    	JZ	short bad_path2
 17983                                  OpenFNF:
 17984 00002C53 B80200                  	MOV	AX,error_file_not_found	; 2
 17985                                  OpenBadRet:
 17986                                  ;hkn; FastOpenFlg is in DOSDATA use SS override
 17987                                  	; 12/08/2018
 17988                                  	;mov	byte [cs:FastOpenFlg],0 ; IBMDOS.COM (MSDOS 3.3) offset 36CAh
 17989                                  	; MSDOS 6.0
 17990 00002C56 368026[3A0D]80          	AND	BYTE [SS:FastOpenFlg],Fast_yes    ;; DOS 3.3
 17991 00002C5C F9                      	STC
 17992                                  	;call	LCritDisk
 17993                                  	; 16/12/2022
 17994 00002C5D E912E7                  	jmp	LCritDisk
 17995                                  	;;JMP	Clear_FastOpen ; 10/08/2018
 17996                                  	;retn 	; 08/09/2018
 17997                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 17998                                  	;jmp	Clear_FastOpen
 17999                                  
 18000                                  bad_path2:
 18001 00002C60 B80300                  	MOV	AX,error_path_not_found	; 3
 18002 00002C63 EBF1                    	JMP	short OpenBadRet
 18003                                  
 18004                                  Open_Bad_Access:
 18005 00002C65 B80500                  	MOV	AX,error_access_denied	; 5
 18006 00002C68 EBEC                    	JMP	short OpenBadRet
 18007                                  
 18008                                  Open_found:
 18009 00002C6A 74F9                    	JZ	short Open_Bad_Access 	; test for directories
 18010 00002C6C 08E4                    	OR	AH,AH
 18011 00002C6E 783E                    	JS	short open_ok		; Devices don't have attributes
 18012 00002C70 8E06[E405]              	MOV	ES,[CURBUF+2]		; get buffer location
 18013                                  	;mov	al,[es:bx+0Bh]
 18014 00002C74 268A470B                	MOV	AL,[ES:BX+dir_entry.dir_attr]
 18015 00002C78 A808                    	TEST	AL,attr_volume_id	; can't open volume ids
 18016 00002C7A 75E9                    	JNZ	short Open_Bad_Access
 18017 00002C7C A801                    	TEST	AL,attr_read_only	; check write on read only
 18018 00002C7E 742E                    	JZ	short open_ok
 18019                                  
 18020                                  ; The file is marked READ-ONLY. We verify that the open mode allows access to
 18021                                  ; the read-only file. Unfortunately, with FCB's and net-FCB's we cannot
 18022                                  ; determine at the OPEN time if such access is allowed. Thus, we defer such
 18023                                  ; processing until the actual write operation:
 18024                                  ;
 18025                                  ; If FCB, then we change the mode to be read_only.
 18026                                  ; If net_FCB, then we change the mode to be read_only.
 18027                                  ; If not open for read then error.
 18028                                  
 18029 00002C80 1E                      	push	ds
 18030 00002C81 56                      	push	si
 18031 00002C82 C536[9E05]              	LDS	SI,[THISSFT]
 18032                                  	;mov	cx,[si+2]
 18033 00002C86 8B4C02                  	MOV	CX,[SI+SF_ENTRY.sf_mode]
 18034                                  	; 17/12/2022
 18035                                  	;test	ch,80h
 18036 00002C89 F6C580                  	test	ch,sf_isFCB>>8
 18037                                  	;TEST	CX,sf_isFCB ; 8000h	; is it FCB?
 18038 00002C8C 750A                    	JNZ	short ResetAccess	; yes, reset the access
 18039 00002C8E 88CA                    	MOV	DL,CL
 18040 00002C90 80E2F0                  	AND	DL,SHARING_MASK	; 0F0h
 18041 00002C93 80FA70                  	CMP	DL,SHARING_NET_FCB ; 70h ; is it net FCB?
 18042 00002C96 7508                    	JNZ	short NormalOpen	; no
 18043                                  ResetAccess:
 18044                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)	
 18045                                  	;AND	CX,~access_mask	; 0FFF0h ; clear access
 18046                                  	; 16/12/2022
 18047 00002C98 80E1F0                  	and	cl,0F0h ; 18/05/2019
 18048                                  ;	OR	CX,open_for_read ; 0	; stick in open_for_read
 18049 00002C9B 894C02                  	MOV	[SI+SF_ENTRY.sf_mode],CX
 18050 00002C9E EB0C                    	JMP	SHORT FillSFT
 18051                                  
 18052                                  ; The SFT is normal. See if the requested access is open_for_read
 18053                                  
 18054                                  NormalOpen:
 18055 00002CA0 80E10F                  	AND	CL,access_mask	;0Fh	; remove extras
 18056 00002CA3 80F900                  	CMP	CL,open_for_read ; 0	; is it open for read?
 18057 00002CA6 7404                    	JZ	short FillSFT
 18058 00002CA8 5E                      	pop	si
 18059 00002CA9 1F                      	pop	ds
 18060 00002CAA EBB9                    	JMP	short Open_Bad_Access
 18061                                  ;
 18062                                  ; All done, restore registers and fill the SFT.
 18063                                  ;
 18064                                  FillSFT:
 18065 00002CAC 5E                      	pop	si
 18066 00002CAD 1F                      	pop	ds
 18067                                  open_ok:
 18068 00002CAE E8FF1E                  	call	DOOPEN			; Fill in SFT
 18069                                  
 18070                                  ;hkn; FastOpenFlg is in DOSDATA. use SS override
 18071                                  	; 18/05/2019
 18072                                  	;and	byte [ss:FastOpenFlag],80h
 18073 00002CB1 368026[3A0D]80          	AND	BYTE [SS:FastOpenFlg],Fast_yes	;; DOS 3.3
 18074                                  	; 12/08/2018
 18075                                  	;and	byte [FastOpenFlg],Fast_yes	
 18076                                  
 18077                                  	; MSDOS 6.0
 18078 00002CB7 E84300                  	CALL	DO_SHARE_CHECK
 18079 00002CBA 7303                    	JNC	short SHARE_OK
 18080                                  	;call	LCritDisk
 18081                                  	; 16/12/2022
 18082 00002CBC E9B3E6                  	jmp	LCritDisk
 18083                                  	;;JMP	short Clear_FastOpen
 18084                                  	;retn	; 18/05/2019
 18085                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 18086                                  	;jmp	short Clear_FastOpen	
 18087                                  
 18088                                  	; MSDOS 3.3
 18089                                  ;DO_SHARE_CHECK:
 18090                                  ;	MOV	CX,[RetryCount]		; Get # tries to do
 18091                                  ;OpenShareRetry:
 18092                                  ;	push	cx			; Save number left to do
 18093                                  ;	call	SHARE_CHECK		; Final Check
 18094                                  ;	pop	cx			; CX = # left
 18095                                  ;	JNC	short SHARE_OK		; No problem with access
 18096                                  ;	call	Idle
 18097                                  ;	LOOP	OpenShareRetry		; One more retry used up
 18098                                  ;OpenShareFail:
 18099                                  ;	LES	DI,[THISSFT]
 18100                                  ;	call	SHARE_ERROR
 18101                                  ;	JNC	short DO_SHARE_CHECK	; User wants more retry
 18102                                  	
 18103                                  	;12/08/2018
 18104                                  	;mov	byte [ss:FastOpenFlg],0
 18105                                  	;08/09/2018
 18106                                  	;mov	byte [FastOpenFlg],0
 18107                                  	;call	LCritDisk
 18108                                  	;JMP	short Clear_FastOpen
 18109                                  	;retn
 18110                                  
 18111                                  SHARE_OK:
 18112                                  	; MSDOS 3.3 & MSDOS 6.0
 18113 00002CBF B80300                  	MOV	AX,3
 18114 00002CC2 C43E[9E05]              	LES	DI,[THISSFT]
 18115                                  ;if installed
 18116                                  	;call	JShare + 14 * 4
 18117 00002CC6 FF1E[C800]              	call	far [JShare+(14*4)]  ; 14 = ShSU
 18118                                  ;else
 18119                                  ;	Call	ShSU
 18120                                  ;endif
 18121 00002CCA E8A5E6                  	call	LCritDisk
 18122                                  	
 18123                                  	;FallThru Set_SFT_Mode
 18124                                  
 18125                                  ;----------------------------------------------------------------------------
 18126                                  ; Procedure Name : SET_SFT_MODE
 18127                                  ;
 18128                                  ; Finish SFT initialization for new reference. Set the correct mode.
 18129                                  ;
 18130                                  ;   Inputs:
 18131                                  ;	ThisSFT points to SFT
 18132                                  ;
 18133                                  ;   Outputs:
 18134                                  ;	Carry clear
 18135                                  ;   Registers modified: AX.
 18136                                  ;---------------------------------------------------------------------------
 18137                                  
 18138                                  ;hkn; called from create. DS already set up to DOSDATA.
 18139                                  
 18140                                  SET_SFT_MODE:
 18141 00002CCD C43E[9E05]              	LES	DI,[THISSFT]
 18142 00002CD1 E87F19                  	call	DEV_OPEN_SFT
 18143                                  	;test	word [es:di+2],8000h
 18144                                  	; 17/12/2022
 18145                                  	;test	byte [es:di+3],80h
 18146 00002CD4 26F6450380              	test	byte [ES:DI+SF_ENTRY.sf_mode+1],sf_isFCB>>8
 18147                                  	;TEST	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB ; Clears carry
 18148 00002CD9 7407                    	JZ	short Clear_FastOpen	; sf_mode correct (retz)
 18149 00002CDB A1[3003]                	MOV	AX,[CurrentPDB]
 18150                                  	;mov	[es:di+31h],ax
 18151 00002CDE 26894531                	MOV	[ES:DI+SF_ENTRY.sf_PID],AX ; For FCB sf_PID=PDB
 18152                                  
 18153                                  Clear_FastOpen:
 18154 00002CE2 C3                      	retn			       ;;;;; DOS 3.3
 18155                                  
 18156                                  ;----------------------------------------------------------------------------
 18157                                  ; Procedure Name : SHARE_ERROR
 18158                                  ;
 18159                                  ; Called on sharing violations. ES:DI points to SFT. AX has error code
 18160                                  ; If SFT is FCB or compatibility mode gens INT 24 error.
 18161                                  ; Returns carry set AX=error_sharing_violation if user says ignore (can't
 18162                                  ; really ignore). Carry clear if user wants a retry. ES, DI, DS preserved
 18163                                  ;---------------------------------------------------------------------------
 18164                                  
 18165                                  SHARE_ERROR:
 18166                                  	; 17/12/2022
 18167                                  	;test	byte [es:di+3],80h
 18168 00002CE3 26F6450380              	test	byte [ES:DI+SF_ENTRY.sf_mode+1],sf_isFCB>>8 ; 80h
 18169                                  	;TEST	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB ; 8000h
 18170 00002CE8 7509                    	JNZ	short _HARD_ERR
 18171 00002CEA 268A4D02                	MOV	CL,[ES:DI+SF_ENTRY.sf_mode]
 18172 00002CEE 80E1F0                  	AND	CL,SHARING_MASK  ; 0F0h
 18173                                  	;CMP	CL,SHARING_COMPAT ; 0
 18174                                  	;JNE	short _NO_HARD_ERR
 18175                                  	; 21/09/2023
 18176 00002CF1 7505                    	jnz	short _NO_HARD_ERR
 18177                                  _HARD_ERR:
 18178 00002CF3 E8C146                  	call	SHARE_VIOLATION
 18179                                  	;retnc				; User wants retry
 18180 00002CF6 73EA                    	jnc	short Clear_FastOpen
 18181                                  _NO_HARD_ERR:
 18182 00002CF8 B82000                  	MOV	AX,error_sharing_violation  ; 20h
 18183 00002CFB F9                      	STC
 18184 00002CFC C3                      	retn
 18185                                  
 18186                                  ; MSDOS 6.0
 18187                                  ;----------------------------------------------------------------------------
 18188                                  ; Procedure Name : DO_SHARE_CHECK
 18189                                  ;
 18190                                  ; Input: THISDPB, WFP_Start, THISSFT set
 18191                                  ; Functions: check file sharing mode is valid
 18192                                  ; Output: carry set, error
 18193                                  ;	  carry clear, share ok
 18194                                  ;----------------------------------------------------------------------------
 18195                                  
 18196                                  	; 18/05/2019 - Retro DOS v4.0
 18197                                  DO_SHARE_CHECK:
 18198 00002CFD E857E6                  	call	ECritDisk		; enter critical section
 18199                                  OPN_RETRY:
 18200 00002D00 8B0E[1A00]              	MOV	CX,[RetryCount]		; Get # tries to do
 18201                                  OpenShareRetry:
 18202 00002D04 51                      	push	cx			; Save number left to do
 18203 00002D05 E8AA46                  	call	SHARE_CHECK		; Final Check
 18204 00002D08 59                      	pop	cx			; CX = # left
 18205 00002D09 730E                    	JNC	short Share_Ok2		; No problem with access
 18206 00002D0B E840E5                  	call	Idle
 18207 00002D0E E2F4                    	LOOP	OpenShareRetry		; One more retry used up
 18208                                  OpenShareFail:
 18209 00002D10 C43E[9E05]              	LES	DI,[THISSFT]
 18210 00002D14 E8CCFF                  	call	SHARE_ERROR
 18211 00002D17 73E7                    	JNC	short OPN_RETRY		; User wants more retry
 18212                                  Share_Ok2:
 18213                                  	;call	LCritDisk		; leave critical section
 18214                                  	;retn
 18215                                  	; 18/12/2022
 18216 00002D19 E956E6                  	jmp	LCritDisk
 18217                                  
 18218                                  ;-----------------------------------------------------------------------------
 18219                                  ; Procedure Name : Check_Access
 18220                                  ;
 18221                                  ; Inputs:
 18222                                  ;	AX is mode
 18223                                  ;	  High NIBBLE of AL (Sharing Mode)
 18224                                  ;		sharing_compat	   file is opened in compatibility mode
 18225                                  ;		sharing_deny_none  file is opened Multi reader, Multi writer
 18226                                  ;		sharing_deny_read  file is opened Only reader, Multi writer
 18227                                  ;		sharing_deny_write file is opened Multi reader, Only writer
 18228                                  ;		sharing_deny_both  file is opened Only reader, Only writer
 18229                                  ;	  Low NIBBLE of AL (Access Mode)
 18230                                  ;		open_for_read	file is opened for reading
 18231                                  ;		open_for_write	file is opened for writing
 18232                                  ;		open_for_both	file is opened for both reading and writing.
 18233                                  ; Function:
 18234                                  ;	Check this access mode for correctness
 18235                                  ; Outputs:
 18236                                  ;	[open_access] = AL input
 18237                                  ;	Carry Clear
 18238                                  ;		Mode is correct
 18239                                  ;		AX unchanged
 18240                                  ;	Carry Set
 18241                                  ;		Mode is bad
 18242                                  ;		AX = error_invalid_access
 18243                                  ; No other registers effected
 18244                                  ;----------------------------------------------------------------------------
 18245                                  
 18246                                  Check_Access_AX:
 18247 00002D1C A2[6E05]                	MOV	[OPEN_ACCESS],AL
 18248 00002D1F 53                      	PUSH	BX
 18249                                  
 18250                                  ;	If sharing, then test for special sharing mode for FCBs
 18251                                  
 18252 00002D20 88C3                    	MOV	BL,AL
 18253 00002D22 80E3F0                  	AND	BL,SHARING_MASK ; 0F0h
 18254 00002D25 803E[7205]FF            	CMP	byte [FSHARING],-1
 18255 00002D2A 7505                    	JNZ	short CheckShareMode	; not through server call, must be ok
 18256 00002D2C 80FB70                  	CMP	BL,SHARING_NET_FCB
 18257 00002D2F 7405                    	JZ	short CheckAccessMode	; yes, we have an FCB
 18258                                  CheckShareMode:
 18259 00002D31 80FB40                  	CMP	BL,40h			; is this a good sharing mode?
 18260 00002D34 770D                    	JA	short Make_Bad_Access
 18261                                  CheckAccessMode:
 18262 00002D36 88C3                    	MOV	BL,AL
 18263 00002D38 80E30F                  	AND	BL,access_mask
 18264 00002D3B 80FB02                  	CMP	BL,2
 18265 00002D3E 7703                    	JA	short Make_Bad_Access
 18266 00002D40 5B                      	POP	BX
 18267 00002D41 F8                      	CLC
 18268 00002D42 C3                      	retn
 18269                                  
 18270                                  Make_Bad_Access:
 18271 00002D43 B80C00                  	MOV	AX,error_invalid_access ; 0Ch
 18272 00002D46 5B                      	POP	BX
 18273 00002D47 F9                      	STC
 18274 00002D48 C3                      	retn
 18275                                  
 18276                                  ;============================================================================
 18277                                  ; DINFO.ASM, MSDOS 6.0, 1991
 18278                                  ;============================================================================
 18279                                  ; 08/08/2018 - Retro DOS v3.0
 18280                                  ; 18/05/2019 - Retro DOS v4.0
 18281                                  
 18282                                  ;**	Low level routine for returning disk drive information from a local
 18283                                  ;	  or NET device
 18284                                  ;
 18285                                  ;	DISK_INFO
 18286                                  ;
 18287                                  ;	  Modification history:
 18288                                  ;
 18289                                  ;		Created: ARR 30 March 1983
 18290                                  
 18291                                  ;	Break	<DISK_INFO -- Get Disk Drive Information>
 18292                                  ;---------------------------------------------------------------------------
 18293                                  ; Procedure Name : DISK_INFO
 18294                                  ;
 18295                                  ; Inputs:
 18296                                  ;	[THISCDS] Points to the Macro List Structure of interest
 18297                                  ;		(It MAY NOT be NUL, error not detected)
 18298                                  ; Function:
 18299                                  ;	Get Interesting Drive Information
 18300                                  ; Returns:
 18301                                  ;	DX = Number of free allocation units
 18302                                  ;	BX = Total Number of allocation units on disk
 18303                                  ;	CX = Sector size
 18304                                  ;	AL = Sectors per allocation unit
 18305                                  ;	AH = FAT ID BYTE
 18306                                  ;	Carry set if error (currently user FAILed to I 24)
 18307                                  ; Segs except ES preserved, others destroyed
 18308                                  ;----------------------------------------------------------------------------
 18309                                  
 18310                                  ;hkn; called from getset.asm and misc.asm. DS has already been set up to 
 18311                                  ;hkn; DOSDATA. 
 18312                                  
 18313                                  DISK_INFO:
 18314                                  	; 08/08/2018 - Retro DOS v3.0
 18315                                  	; IBM DOS.COM (MSDOS 3.3, 1987) - Offset 37C5h
 18316                                  
 18317 00002D49 E847E5                  	call	TestNet
 18318 00002D4C 7306                    	JNC	short LOCAL_DSK_INFO
 18319                                  
 18320                                  ;IF NOT Installed
 18321                                  ;	transfer NET_DISK_INFO
 18322                                  ;ELSE
 18323                                  	;MOV	AX,(MultNET SHL 8) OR 12
 18324                                  	;INT	2FH
 18325                                  	;return
 18326                                  
 18327 00002D4E B80C11                  	mov     ax,110Ch
 18328 00002D51 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - GET DISK SPACE
 18329                                  			; ES:DI -> current directory
 18330                                  			; Return: AL = sectors per cluster, BX = total clusters
 18331                                  			; CX = bytes per sector, DX = number of available clusters
 18332 00002D53 C3                      	retn
 18333                                  ;ENDIF
 18334                                  
 18335                                  LOCAL_DSK_INFO:
 18336 00002D54 C606[2303]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk
 18337 00002D59 E8FBE5                  	call	ECritDisk
 18338 00002D5C E8DC29                  	call	FATREAD_CDS		; perform media check.
 18339 00002D5F 7241                    	JC	short CRIT_LEAVE
 18340 00002D61 BB0200                  	MOV	BX,2
 18341 00002D64 E83D28                  	call	UNPACK			; Get first FAT sector into CURBUF
 18342 00002D67 7239                    	JC	short CRIT_LEAVE
 18343 00002D69 C536[E205]              	LDS	SI,[CURBUF]
 18344                                  	;mov	ah,[si+20]
 18345 00002D6D 8A6414                  	MOV	AH,[SI+BUFINSIZ]	; get FAT ID BYTE
 18346                                  
 18347                                  ;hkn; SS is DOSDATA
 18348 00002D70 16                      	push	ss
 18349 00002D71 1F                      	pop	ds
 18350                                  	;mov	cx,[es:bp+0Dh]
 18351 00002D72 268B4E0D                	MOV	CX,[ES:BP+DPB.MAX_CLUSTER]
 18352                                  
 18353                                  ; Examine the current free count. If it indicates that we have an invalid
 18354                                  ; count, do the expensive calculation.
 18355                                  
 18356                                  	;mov	dx,[es:bp+1Fh]
 18357 00002D76 268B561F                	MOV	DX,[ES:BP+DPB.FREE_CNT] ; get free count
 18358 00002D7A 83FAFF                  	CMP	DX,-1			; is it valid?
 18359 00002D7D 7404                    	JZ	short DoScan
 18360                                  
 18361                                  ; Check to see if it is in a reasonable range. If so, trust it and return.
 18362                                  ; Otherwise, we need to blast out an internal error message and then recompute
 18363                                  ; the count.
 18364                                  
 18365 00002D7F 39CA                    	CMP	DX,CX			; is it in a reasonable range?
 18366 00002D81 7222                    	JB	short GotVal		; yes, trust it.
 18367                                  DoScan:
 18368 00002D83 31D2                    	XOR	DX,DX
 18369 00002D85 49                      	DEC	CX
 18370                                  SCANFREE:
 18371 00002D86 E81B28                  	call	UNPACK
 18372 00002D89 7217                    	JC	short CRIT_LEAVE
 18373 00002D8B 7501                    	JNZ	short NOTFREECLUS
 18374 00002D8D 42                      	INC	DX			; A free one
 18375                                  NOTFREECLUS:
 18376 00002D8E 43                      	INC	BX			; Next cluster
 18377 00002D8F E2F5                    	LOOP	SCANFREE
 18378 00002D91 4B                      	DEC	BX			; BX was next cluster. Convert to
 18379                                  ReturnVals:
 18380 00002D92 4B                      	DEC	BX			; count
 18381                                  	;mov	al,[es:bp+4]
 18382 00002D93 268A4604                	MOV	AL,[ES:BP+DPB.CLUSTER_MASK]
 18383 00002D97 FEC0                    	INC	AL			; Sectors/cluster
 18384                                  	;mov	cx,[es:bp+2]
 18385 00002D99 268B4E02                	MOV	CX,[ES:BP+DPB.SECTOR_SIZE] ; Bytes/sector
 18386                                  	;mov	[es:bp+1Fh],dx
 18387 00002D9D 2689561F                	MOV	[ES:BP+DPB.FREE_CNT],DX
 18388 00002DA1 F8                      	CLC
 18389                                  CRIT_LEAVE:
 18390                                  	;call	LCritDisk
 18391                                  	;retn
 18392                                  	; 17/12/2022
 18393 00002DA2 E9CDE5                  	jmp	LCritDisk
 18394                                  
 18395                                  ; We have correctly computed everything previously. Load up registers for
 18396                                  ; return.
 18397                                  
 18398                                  GotVal: 
 18399 00002DA5 89CB                    	MOV	BX,CX			; get cluster count
 18400 00002DA7 EBE9                    	JMP	short ReturnVals
 18401                                  
 18402                                  ;============================================================================
 18403                                  ; ISEARCH.ASM, MSDOS 6.0, 1991
 18404                                  ;============================================================================
 18405                                  ; 22/07/2018 - Retro DOS v3.0
 18406                                  
 18407                                  ;	TITLE	DOS_SEARCH - Internal SEARCH calls for MS-DOS
 18408                                  ;	NAME	DOS_SEARCH
 18409                                  
 18410                                  ;**	Low level routines for doing local and NET directory searches
 18411                                  ;
 18412                                  ;	DOS_SEARCH_FIRST
 18413                                  ;	DOS_SEARCH_NEXT
 18414                                  ;	RENAME_NEXT
 18415                                  ;
 18416                                  ;	Revision history:
 18417                                  ;
 18418                                  ;	    Created: ARR 30 March 1983
 18419                                  ;	    A000	version 4.00  Jan. 1988
 18420                                  ;	    A001	PTM 3564 -- search for fastopen
 18421                                  
 18422                                  ;Installed = TRUE
 18423                                  
 18424                                  ;--------------------------------------------------------------------------
 18425                                  ;
 18426                                  ; Procedure Name : DOS_SEARCH_FIRST
 18427                                  ;
 18428                                  ; Inputs:
 18429                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 18430                                  ;		terminated)
 18431                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 18432                                  ;		( = -1 if current dir not involved, else
 18433                                  ;		 Points to first char after last "/" of current dir part)
 18434                                  ;	[THISCDS] Points to CDS being used
 18435                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 18436                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 18437                                  ;	[DMAADD] Points to 53 byte buffer
 18438                                  ; Function:
 18439                                  ;	Initiate a search for the given file spec
 18440                                  ; Outputs:
 18441                                  ;	CARRY CLEAR
 18442                                  ;	    The 53 bytes ot DMAADD are filled in as follows:
 18443                                  ;
 18444                                  ;	LOCAL
 18445                                  ;	    Drive Byte (A=1, B=2, ...) High bit clear
 18446                                  ;		NEVER STORE DRIVE BYTE AFTER  found_it
 18447                                  ;	    11 byte search name with Meta chars in it
 18448                                  ;	    Search Attribute Byte, attribute of search
 18449                                  ;	    WORD LastEnt value
 18450                                  ;	    WORD DirStart
 18451                                  ;	    4 byte pad
 18452                                  ;	    32 bytes of the directory entry found
 18453                                  ;	NET
 18454                                  ;	    21 bytes First byte has high bit set
 18455                                  ;	    32 bytes of the directory entry found
 18456                                  ;
 18457                                  ;	CARRY SET
 18458                                  ;	    AX = error code
 18459                                  ;		error_no_more_files
 18460                                  ;			No match for this file
 18461                                  ;		error_path_not_found
 18462                                  ;			Bad path (not in curr dir part if present)
 18463                                  ;		error_bad_curr_dir
 18464                                  ;			Bad path in current directory part of path
 18465                                  ; DS preserved, others destroyed
 18466                                  ;---------------------------------------------------------------------------
 18467                                  
 18468                                  	; 14/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 18469                                  	; DOSCODE:6C22h (MSDOS 5.0, MSDOS.SYS)
 18470                                  
 18471                                  DOS_SEARCH_FIRST:
 18472                                  	; IBMDOS.COM (MSDOS 3.3 kernel) - Offset 3826h
 18473                                  
 18474 00002DA9 C43E[A205]              	LES	DI,[THISCDS]
 18475 00002DAD 83FFFF                  	CMP	DI,-1
 18476 00002DB0 7506                    	JNZ	short TEST_RE_NET2
 18477                                  
 18478                                  ;IF NOT Installed
 18479                                  ;	transfer NET_SEQ_SEARCH_FIRST
 18480                                  ;ELSE
 18481                                  	;mov	ax,1119h
 18482 00002DB2 B81911                  	MOV	AX,(MultNET<<8)|25
 18483 00002DB5 CD2F                    	INT	2Fh
 18484 00002DB7 C3                      	retn
 18485                                  ;ENDIF
 18486                                  
 18487                                  TEST_RE_NET2:
 18488                                  	;test	word [es:di+43h],8000h
 18489                                  	; 17/12/2022
 18490                                  	;test	byte [es:di+44h],80h
 18491                                  	; 28/12/2022
 18492 00002DB8 26F6454480              	test	byte [ES:DI+curdir.flags+1],curdir_isnet>>8	
 18493                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet
 18494 00002DBD 7406                    	JZ	short LOCAL_SEARCH_FIRST
 18495                                  
 18496                                  ;IF NOT Installed
 18497                                  ;	transfer NET_SEARCH_FIRST
 18498                                  ;ELSE
 18499                                  	;mov	ax,111Bh
 18500 00002DBF B81B11                  	MOV	AX,(MultNET<<8)|27
 18501 00002DC2 CD2F                    	INT	2FH
 18502 00002DC4 C3                      	retn
 18503                                  ;ENDIF
 18504                                  	; 18/05/2019 - Retro DOS v4.0
 18505                                  LOCAL_SEARCH_FIRST:
 18506 00002DC5 E88FE5                  	call	ECritDisk
 18507                                  	; MSDOS 6.0
 18508                                  	;;test	word [DOS34_FLAG],400h
 18509                                  	; 17/12/2022
 18510                                  	;test	byte [DOS34_FLAG+1],04h
 18511 00002DC8 F606[1206]04            	test	byte [DOS34_FLAG+1],(SEARCH_FASTOPEN>>8)
 18512                                  	;TEST	word [DOS34_FLAG],SEARCH_FASTOPEN ;AN000;
 18513 00002DCD 7405                    	JZ	short NOFN			;AN000;
 18514                                  	;or	byte [FastOpenFlg],1
 18515 00002DCF 800E[3A0D]01            	OR	byte [FastOpenFlg],FastOpen_Set	;AN000;
 18516                                  NOFN:						;AN000;
 18517 00002DD4 C606[4C03]01            	MOV	byte [NoSetDir],1	; if we find a dir, don't change to it
 18518                                  	; MSDOS 6.0
 18519 00002DD9 E84101                  	CALL	CHECK_QUESTION		;AN000;;FO. is '?' in path
 18520 00002DDC 7305                    	JNC	short norm_GETPATH	;AN000;;FO. no
 18521                                  	;and	byte [FastOpenFlg],80h
 18522 00002DDE 8026[3A0D]80            	AND	byte [FastOpenFlg],Fast_yes ;AN000;;FO. reset fastopen
 18523                                  norm_GETPATH:
 18524 00002DE3 E8A011                  	call	GETPATH
 18525                                  	; BX = offset NAME1
 18526                                  ;_getdone:
 18527 00002DE6 7318                    	JNC	short find_check_dev
 18528 00002DE8 7511                    	JNZ	short bad_path3
 18529 00002DEA 08C9                    	OR	CL,CL
 18530 00002DEC 740D                    	JZ	short bad_path3
 18531                                  find_no_more:
 18532                                  	;mov	ax,12h
 18533 00002DEE B81200                  	MOV	AX,error_no_more_files
 18534                                  BadBye:
 18535                                  	; MSDOS 6.0
 18536 00002DF1 368026[3A0D]80          	AND	byte [SS:FastOpenFlg],Fast_yes  ;AN000;;FO. reset fastopen
 18537                                  
 18538 00002DF7 F9                      	STC
 18539                                  	;call	LCritDisk
 18540                                  	;retn
 18541                                  	; 18/12/2022
 18542 00002DF8 E977E5                  	jmp	LCritDisk
 18543                                  
 18544                                  bad_path3:
 18545                                  	;mov	ax,3
 18546 00002DFB B80300                  	MOV	AX,error_path_not_found
 18547 00002DFE EBF1                    	JMP	short BadBye
 18548                                  
 18549                                  find_check_dev:
 18550 00002E00 08E4                    	OR	AH,AH
 18551 00002E02 790A                    	JNS	short found_entry
 18552 00002E04 C706[4803]FFFF          	MOV	word [LASTENT],-1	; Cause DOS_SEARCH_NEXT to fail
 18553 00002E0A FE06[7005]              	INC	byte [FOUND_DEV]	; Tell DOS_RENAME we found a device
 18554                                  found_entry:
 18555                                  
 18556                                  ; We set the physical drive byte here Instead of after found_it; Doing
 18557                                  ; a search-next may not have wfp_start set correctly
 18558                                  
 18559 00002E0E C43E[2C03]              	LES	DI,[DMAADD]
 18560 00002E12 8B36[B205]              	MOV	SI,[WFP_START]		; get pointer to beginning
 18561 00002E16 AC                      	LODSB
 18562 00002E17 2C40                    	SUB	AL,'A'-1                ; logical drive
 18563 00002E19 AA                      	STOSB				; High bit not set (local)
 18564                                  found_it:
 18565 00002E1A C43E[2C03]              	LES	DI,[DMAADD]
 18566 00002E1E 47                      	INC	DI
 18567                                  
 18568                                  	; MSDOS 6.0
 18569 00002E1F 1E                      	PUSH	DS				  ;FO.;AN001; save ds
 18570                                  	;test	byte [FastOpenFlg],10h
 18571 00002E20 F606[3A0D]10            	TEST	byte [FastOpenFlg],Set_For_Search ;FO.;AN001; from fastopen
 18572 00002E25 7408                    	JZ	short notfast			  ;FO.;AN001;
 18573 00002E27 89DE                    	MOV	SI,BX				  ;FO.;AN001;
 18574 00002E29 8E1E[E405]              	MOV	DS,[CURBUF+2]			  ;FO.;AN001;
 18575 00002E2D EB03                    	JMP	SHORT movmov			  ;FO.;AN001;
 18576                                  
 18577                                  notfast:
 18578 00002E2F BE[4B05]                	MOV	SI,NAME1		; find_buf 2 = formatted name
 18579                                  movmov:
 18580                                  ; Special E5 code
 18581 00002E32 A4                      	MOVSB
 18582 00002E33 26807DFF05              	CMP	BYTE [ES:DI-1],5
 18583 00002E38 7505                    	JNZ	short NOTKANJB
 18584 00002E3A 26C645FFE5              	MOV	BYTE [ES:DI-1],0E5H
 18585                                  NOTKANJB:
 18586 00002E3F B90A00                  	MOV	CX,10
 18587 00002E42 F3A4                    	REP	MOVSB
 18588                                  
 18589                                  	; 08/09/2018
 18590 00002E44 1F                      	POP	DS			;FO.;AN001; restore ds
 18591                                  
 18592 00002E45 A0[6B05]                	MOV	AL,[ATTRIB]
 18593 00002E48 AA                      	STOSB
 18594 00002E49 50                      	PUSH	AX			; Save AH device info
 18595 00002E4A A1[4803]                	MOV	AX,[LASTENT]
 18596 00002E4D AB                      	STOSW
 18597 00002E4E A1[C205]                	MOV	AX,[DIRSTART]
 18598 00002E51 AB                      	STOSW
 18599                                  ; 4 bytes of 21 byte cont structure left for NET stuff
 18600 00002E52 83C704                  	ADD	DI,4
 18601 00002E55 58                      	POP	AX			; Recover AH device info
 18602 00002E56 08E4                    	OR	AH,AH
 18603 00002E58 781B                    	JS	short DOSREL		; Device entry is DOSGROUP relative
 18604 00002E5A 833E[E205]FF            	CMP	WORD [CURBUF],-1
 18605 00002E5F 7510                    	JNZ	short OKSTORE
 18606                                  
 18607                                  	; MSDOS 6.0
 18608 00002E61 F606[3A0D]10            	TEST	byte [FastOpenFlg],Set_For_Search
 18609                                  					;AN000;;FO. from fastopen and is good
 18610 00002E66 7509                    	JNZ	short OKSTORE		;AN000;;FO.
 18611                                  
 18612                                  	; The user has specified the root directory itself, rather than some
 18613                                  	; contents of it. We can't "find" that.
 18614                                  
 18615 00002E68 26C745F8FFFF            	MOV	WORD [ES:DI-8],-1	; Cause DOS_SEARCH_NEXT to fail by
 18616                                  					;   stuffing a -1 at Lastent
 18617 00002E6E E97DFF                  	JMP	find_no_more
 18618                                  
 18619                                  OKSTORE:
 18620 00002E71 8E1E[E405]              	MOV	DS,[CURBUF+2]
 18621                                  DOSREL:
 18622                                  	; BX = offset NAME1 (from GETPATH)
 18623 00002E75 89DE                    	MOV	SI,BX			; SI-> start of entry
 18624                                  
 18625                                  ; NOTE: DOS_RENAME depends on BX not being altered after this point
 18626                                  
 18627                                  	;mov	cx,32
 18628 00002E77 B92000                  	MOV	CX,dir_entry.size
 18629                                  ;;;;; 7/29/86
 18630 00002E7A 89F8                    	MOV	AX,DI			; save the 1st byte addr
 18631 00002E7C F3A4                    	REP	MOVSB
 18632 00002E7E 89C7                    	MOV	DI,AX			; restore 1st byte addr
 18633 00002E80 26803D05                	CMP	BYTE [ES:DI],05H	; special char check
 18634 00002E84 7504                    	JNZ	short NO05
 18635 00002E86 26C605E5                	MOV	BYTE [ES:DI],0E5H	; convert it back to E5
 18636                                  NO05:
 18637                                  
 18638                                  ;;;;; 7/29/86
 18639                                  
 18640                                  ;hkn; FastOpenflg is in DOSDATA use SS
 18641                                  	; 16/12/2022
 18642                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 18643                                  	; MSDOS 6.0
 18644                                  	;AND	byte [SS:FastOpenFlg],Fast_yes ;AN000;;FO. reset fastopen
 18645                                  	; 18/05/2019 - Retro DOS v4.0
 18646 00002E8A 16                      	push	ss
 18647 00002E8B 1F                      	pop	ds
 18648                                  	; 16/12/2022
 18649 00002E8C 8026[3A0D]80            	AND	byte [FastOpenFlg],Fast_yes
 18650                                  
 18651                                  ;hkn; SS is DOSDATA
 18652                                  	;push	ss
 18653                                  	;pop	ds
 18654 00002E91 F8                      	CLC
 18655                                  	;call	LCritDisk
 18656                                  	;retn
 18657                                  	; 16/12/2022
 18658 00002E92 E9DDE4                  	jmp	LCritDisk
 18659                                  
 18660                                  ;BREAK <DOS_SEARCH_NEXT - scan for subsequent matches>
 18661                                  ;----------------------------------------------------------------------------
 18662                                  ;
 18663                                  ; Procedure Name : DOS_SEARCH_NEXT
 18664                                  ;
 18665                                  ; Inputs:
 18666                                  ;	[DMAADD] Points to 53 byte buffer returned by DOS_SEARCH_FIRST
 18667                                  ;	    (only first 21 bytes must have valid information)
 18668                                  ; Function:
 18669                                  ;	Look for subsequent matches
 18670                                  ; Outputs:
 18671                                  ;	CARRY CLEAR
 18672                                  ;	    The 53 bytes at DMAADD are updated for next call
 18673                                  ;		(see DOS_SEARCH_FIRST)
 18674                                  ;	CARRY SET
 18675                                  ;	    AX = error code
 18676                                  ;		error_no_more_files
 18677                                  ;			No more files to find
 18678                                  ; DS preserved, others destroyed
 18679                                  ;---------------------------------------------------------------------------
 18680                                  
 18681                                  ;hkn; called from search.asm. DS already set up at this point.
 18682                                  
 18683                                  DOS_SEARCH_NEXT:
 18684 00002E95 C43E[2C03]              	LES	DI,[DMAADD]
 18685 00002E99 268A05                  	MOV	AL,[ES:DI]
 18686 00002E9C A880                    	TEST	AL,80H			; Test for NET
 18687 00002E9E 7406                    	JZ	short LOCAL_SEARCH_NEXT
 18688                                  ;IF NOT Installed
 18689                                  ;	transfer NET_SEARCH_NEXT
 18690                                  ;ELSE
 18691                                  	;mov	ax,111Ch
 18692 00002EA0 B81C11                  	MOV	AX,(MultNET<<8)|28
 18693 00002EA3 CD2F                    	INT	2FH  ; Multiplex - NETWORK REDIRECTOR - FINDNEXT
 18694                                  		     ; SS = DS = DOS CS, [DTA] = 21-byte findfirst search data
 18695                                  		     ; Return: CF set on error, AX = DOS error code
 18696                                  		     ; CF clear if successful
 18697 00002EA5 C3                      	retn
 18698                                  ;ENDIF
 18699                                  
 18700                                  LOCAL_SEARCH_NEXT:
 18701                                  	;AL is drive A=1
 18702                                  	;mov	byte [EXTERR_LOCUS],2
 18703 00002EA6 C606[2303]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk
 18704 00002EAB E8A9E4                  	call	ECritDisk
 18705                                  
 18706                                  ;hkn; DummyCDS is in DOSDATA
 18707 00002EAE C706[A205][F304]        	MOV     word [THISCDS],DUMMYCDS
 18708                                  ;hkn; Segment address is DOSDATA - use ds
 18709                                  ;hkn;	MOV     WORD [THISCDS+2],CS
 18710 00002EB4 8C1E[A405]              	mov	[THISCDS+2],DS
 18711                                  
 18712 00002EB8 0440                    	ADD	AL,'A'-1
 18713 00002EBA E88A3B                  	call	InitCDS
 18714                                  
 18715                                  ;	call	GETTHISDRV		; Set CDS pointer
 18716                                  
 18717 00002EBD 7236                    	JC	short No_files		; Bogus drive letter
 18718 00002EBF C43E[A205]              	LES	DI,[THISCDS]		; Get CDS pointer
 18719                                  	;les	bp,[es:di+45h]
 18720 00002EC3 26C46D45                	LES	BP,[ES:DI+curdir.devptr] ; Get DPB pointer
 18721 00002EC7 E877D7                  	call	GOTDPB			; [THISDPB] = ES:BP
 18722                                  
 18723                                  	 ;16/12/2022
 18724 00002ECA 268A4600                	mov	al,[ES:BP]
 18725                                  	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 18726                                  	;mov	AL,[ES:BP+DPB.DRIVE] ; mov al,[ES:BP+0]
 18727 00002ECE A2[7605]                	mov	[THISDRV],AL
 18728                                  	;mov	word [CREATING],0E500h
 18729 00002ED1 C706[7E05]00E5          	MOV	WORD [CREATING],(DIRFREE*256)+0
 18730 00002ED7 C606[4C03]01            	MOV	byte [NoSetDir],1	; if we find a dir, don't change to it
 18731 00002EDC C536[2C03]              	LDS	SI,[DMAADD]
 18732 00002EE0 AC                      	LODSB				; Drive Byte
 18733                                  
 18734                                  	;entry	RENAME_NEXT		; Entry used by DOS_RENAME
 18735                                  RENAME_NEXT:
 18736                                  	;context ES
 18737 00002EE1 16                      	push	ss
 18738 00002EE2 07                      	pop	es			; THIS BLOWS ES:BP POINTER TO DPB
 18739                                  
 18740                                  ;hkn; NAME1 is in DOSDATA
 18741 00002EE3 BF[4B05]                	MOV	DI,NAME1
 18742                                  
 18743 00002EE6 B90B00                  	MOV	CX,11
 18744 00002EE9 F3A4                    	REP	MOVSB			; Search name
 18745 00002EEB AC                      	LODSB				; Attribute
 18746                                  
 18747                                  ;hkn; SS override
 18748 00002EEC 36A2[6B05]              	MOV	[SS:ATTRIB],AL
 18749 00002EF0 AD                      	LODSW				; LastEnt
 18750 00002EF1 09C0                    	OR	AX,AX
 18751 00002EF3 7903                    	JNS	short cont_load
 18752                                  No_files:
 18753 00002EF5 E9F6FE                  	JMP	find_no_more
 18754                                  
 18755                                  cont_load:
 18756 00002EF8 50                      	PUSH	AX			; Save LastEnt
 18757 00002EF9 AD                      	LODSW				; DirStart
 18758 00002EFA 89C3                    	MOV	BX,AX
 18759                                  
 18760                                  ;hkn; SS is DOSDATA
 18761                                  	;context DS
 18762 00002EFC 16                      	push	ss
 18763 00002EFD 1F                      	pop	ds
 18764 00002EFE C42E[8A05]              	LES	BP,[THISDPB]		; Recover ES:BP
 18765                                  	;invoke	SetDirSrch
 18766 00002F02 E82410                  	call	SETDIRSRCH
 18767 00002F05 7303                    	JNC	short SEARCH_GOON
 18768 00002F07 58                      	POP	AX			; Clean stack
 18769 00002F08 EBEB                    	JMP	short No_files
 18770                                  
 18771                                  SEARCH_GOON:
 18772 00002F0A E80C13                  	call	STARTSRCH
 18773 00002F0D 58                      	POP	AX
 18774 00002F0E E8E90F                  	call	GETENT
 18775 00002F11 72E2                    	JC	short No_files
 18776 00002F13 E81F0F                  	call	NEXTENT
 18777 00002F16 72DD                    	JC	short No_files
 18778 00002F18 30E4                    	XOR	AH,AH			; If Search_Next, can't be a DEV
 18779 00002F1A E9FDFE                  	JMP	found_it ; 10/08/2018
 18780                                  
 18781                                  ; MSDOS 6.0
 18782                                  ;---------------------------------------------------------------------------
 18783                                  ;
 18784                                  ; Procedure Name : CHECK_QUESTION
 18785                                  ;
 18786                                  ; Input: [WFP_START]= pointer to final path
 18787                                  ; Function: check '?' char
 18788                                  ; Output: carry clear, if no '?'
 18789                                  ;	 carry set, if '?' exists
 18790                                  ;---------------------------------------------------------------------------
 18791                                  
 18792                                  	; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 18793                                  CHECK_QUESTION:
 18794                                  ;hkn;	wfp_start is in DOSDATA;hkn;	MOV	WORD PTR ThisCDS+2,CS
 18795                                  ;hkn;	PUSH	CS			;AN000;;FO.
 18796 00002F1D 16                      	push	ss
 18797 00002F1E 1F                      	POP	DS			;AN000;;FO. ds:si -> final path
 18798                                  	; 16/12/2022
 18799                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 18800 00002F1F 8B36[B205]              	MOV	SI,[WFP_START]		;AN000;;FO.
 18801                                  	;mov	si,[ss:WFP_START]
 18802                                  getnext:				;AN000;
 18803 00002F23 AC                      	LODSB				;AN000;;FO. get char
 18804 00002F24 08C0                    	OR	AL,AL			;AN000;;FO. is it null
 18805 00002F26 7405                    	JZ	short NO_Question	;AN000;;FO. yes
 18806 00002F28 3C3F                    	CMP	AL,'?'                  ;AN000;;FO. is '?'
 18807 00002F2A 75F7                    	JNZ	short getnext 		;AN000;;FO. no
 18808 00002F2C F9                      	STC				;AN000;;FO.
 18809                                  NO_Question:				;AN000;
 18810 00002F2D C3                      	retn				;AN000;;FO.
 18811                                  
 18812                                  ;============================================================================
 18813                                  ; ABORT.ASM, MSDOS 6.0, 1991
 18814                                  ;============================================================================
 18815                                  ; 23/07/2018 - Retro DOS v3.0
 18816                                  ; 18/05/2019 - Retro DOS v4.0
 18817                                  
 18818                                  ;**
 18819                                  ;
 18820                                  ; Internal Abort call closes all handles and FCBs associated with a process.
 18821                                  ;  If process has NET resources a close all is sent out over the net.
 18822                                  ;
 18823                                  ;   DOS_ABORT
 18824                                  ;
 18825                                  ;   Modification history:
 18826                                  ;
 18827                                  ;       Created: ARR 30 March 1983
 18828                                  ;
 18829                                  ;	M038	SR	10/16/90	Free SFT with the PSP of the process
 18830                                  ;				being terminated only if it is busy.
 18831                                  ;
 18832                                  
 18833                                  ;Break   <DOS_ABORT -- CLOSE all files for process>
 18834                                  ;--------------------------------------------------------------------------
 18835                                  ;
 18836                                  ; Procedure Name : DOS_ABORT
 18837                                  ;
 18838                                  ; Inputs:
 18839                                  ;       [CurrentPDB] set to PID of process aborting
 18840                                  ; Function:
 18841                                  ;       Close all files and free all SFTs for this PID
 18842                                  ; Returns:
 18843                                  ;       None
 18844                                  ; All destroyed except stack
 18845                                  ;---------------------------------------------------------------------------
 18846                                  
 18847                                  DOS_ABORT:
 18848 00002F2E 368E06[3003]            	MOV     ES,[SS:CurrentPDB]	; SS override
 18849 00002F33 268B0E3200              	MOV     CX,[ES:PDB.JFN_Length]  ; Number of JFNs
 18850                                  reset_free_jfn:
 18851 00002F38 89CB                    	MOV     BX,CX
 18852 00002F3A 51                      	PUSH    CX
 18853 00002F3B 4B                      	DEC     BX                      ; get jfn (start with last one)
 18854                                  
 18855 00002F3C E83C38                  	CALL	_$CLOSE
 18856 00002F3F 59                      	POP     CX
 18857 00002F40 E2F6                    	LOOP    reset_free_jfn          ; and do 'em all
 18858                                  
 18859                                  ; Note: We do need to explicitly close FCBs. Reasons are as follows: If we
 18860                                  ; are running in the no-sharing no-network environment, we are simulating the
 18861                                  ; 2.0 world and thus if the user doesn't close the file, that is his problem
 18862                                  ; BUT... the cache remains in a state with garbage that may be reused by the
 18863                                  ; next process. We scan the set and blast the ref counts of the FCBs we own.
 18864                                  ;
 18865                                  ; If sharing is loaded, then the following call to close process will
 18866                                  ; correctly close all FCBs. We will then need to walk the list AFTER here.
 18867                                  ;
 18868                                  ; Finally, the following call to NET_Abort will cause an EOP to be sent to all
 18869                                  ; known network resources. These resources are then responsible for cleaning
 18870                                  ; up after this process.
 18871                                  ;
 18872                                  ; Sleazy, eh?
 18873                                  
 18874                                  	;context DS			; SS is DOSDATA
 18875 00002F42 16                      	push	ss
 18876 00002F43 1F                      	pop	ds  ; 09/09/2018
 18877                                  
 18878                                  	;CallInstall Net_Abort, MultNET, 29
 18879 00002F44 B81D11                  	mov	ax, 111Dh
 18880 00002F47 CD2F                    	int     2Fh 	; Multiplex - NETWORK REDIRECTOR 
 18881                                  			;	    - CLOSE ALL REMOTE FILES FOR PROCESS
 18882                                  			; DS???, SS = DOS CS
 18883                                  ;if installed
 18884 00002F49 FF1E[A000]              	call	far [JShare+(4*4)]	; 4 = MFTCloseP
 18885                                  ;else
 18886                                  ;	call 	MFTCloseP
 18887                                  ;endif
 18888                                  
 18889                                  ; Scan the FCB cache for guys that belong to this process and zap their ref
 18890                                  ; counts.
 18891                                  					; SS override
 18892 00002F4D 36C43E[4000]            	les     di,[ss:SFTFCB]		; grab the pointer to the table
 18893                                  	;mov	cx,[es:di+4]
 18894 00002F52 268B4D04                	mov     cx,[es:di+SFT.SFCount]
 18895 00002F56 E317                    	jcxz    FCBScanDone
 18896                                  	;lea	di,[di+6]
 18897 00002F58 8D7D06                  	LEA     DI,[DI+SFT.SFTable]	; point at table
 18898 00002F5B 36A1[3C03]              	mov     ax,[SS:PROC_ID]		; SS override
 18899                                  FCBTest:
 18900                                  	;cmp	[es:di+31h],ax
 18901 00002F5F 26394531                	cmp	[es:di+SF_ENTRY.sf_PID],ax ; is this one of ours
 18902 00002F63 7505                    	jnz	short FCBNext		; no, skip it
 18903 00002F65 26C7050000              	mov	word [es:di],0
 18904                                  	;mov	word [es:di+SF_ENTRY.sf_ref_count],0  ; yes, blast ref count
 18905                                  FCBNext:
 18906 00002F6A 83C73B                  	add     di,SF_ENTRY.size ; 59 (for MSDOS 6.0)
 18907 00002F6D E2F0                    	loop    FCBTest
 18908                                  FCBScanDone:
 18909                                  
 18910                                  ; Walk the SFT to eliminate all busy SFT's for this process.
 18911                                  
 18912 00002F6F 31DB                    	XOR     BX,BX
 18913                                  Scan:
 18914 00002F71 53                      	push    bx
 18915 00002F72 E88137                  	call	SFFromSFN
 18916 00002F75 5B                      	pop     bx
 18917                                  	;jnc	short Scan1
 18918                                  	;retn
 18919                                  	; 18/12/2022
 18920 00002F76 72B5                    	jc	short NO_Question ; retn
 18921                                  
 18922                                  ;M038
 18923                                  ; Do what the comment above says, check for busy state
 18924                                  
 18925                                  Scan1:
 18926                                  	;cmp	word [es:di],0
 18927                                  	;jz	short scan_next  ; MSDOS 3.3
 18928                                  	; MSDOS 6.0
 18929 00002F78 26833DFF                	cmp	word [es:di],sf_busy ; -1
 18930                                  	;cmp	word [es:di+SF_ENTRY.sf_ref_count],sf_busy
 18931                                  				; Is Sft busy? ;M038
 18932 00002F7C 7519                    	jnz	short scan_next
 18933                                  ;
 18934                                  ; we have a SFT that is busy. See if it is for the current process
 18935                                  ;
 18936 00002F7E 36A1[3C03]              	mov     ax,[SS:PROC_ID]		; SS override
 18937                                  	;cmp	[es:di+31h],ax
 18938 00002F82 26394531                	cmp	[es:di+SF_ENTRY.sf_PID],ax
 18939 00002F86 750F                    	jnz	short scan_next
 18940 00002F88 36A1[3E03]              	mov     ax,[SS:USER_ID]		; SS override
 18941                                  	;cmp	[es:di+2Fh],ax
 18942 00002F8C 2639452F                	cmp	[es:di+SF_ENTRY.sf_UID],ax
 18943 00002F90 7505                    	jnz	short scan_next
 18944                                  
 18945                                  ; This SFT is labelled as ours.
 18946                                  
 18947 00002F92 26C7050000              	mov	word [es:di],0
 18948                                  	;mov	word [es:di+SF_ENTRY.sf_ref_count],0
 18949                                  scan_next:
 18950 00002F97 43                      	inc     bx
 18951 00002F98 EBD7                    	jmp     short Scan
 18952                                  
 18953                                  ;============================================================================
 18954                                  ; CLOSE.ASM, MSDOS 6.0, 1991
 18955                                  ;============================================================================
 18956                                  ; 23/07/2018 - Retro DOS v3.0
 18957                                  ; 18/05/2019 - Retro DOS v4.0
 18958                                  
 18959                                  ;**	Internal Close and Commit calls to close a local or NET SFT.
 18960                                  ;
 18961                                  ;	DOS_CLOSE
 18962                                  ;	DOS_COMMIT
 18963                                  ;	FREE_SFT
 18964                                  ;	SetSFTTimes
 18965                                  ;
 18966                                  ;	Revision history:
 18967                                  ;
 18968                                  ;	   AN000  version 4.00	Jan. 1988
 18969                                  ;	   A005   PTM 3718 --- lost clusters when fastopen installed
 18970                                  ;	   A011   PTM 4766 --- C2 fastopen problem
 18971                                  
 18972                                  ;Installed = TRUE
 18973                                  
 18974                                  ;Break <DOS_CLOSE -- CLOSE FILE from SFT>
 18975                                  ;---------------------------------------------------------------------------
 18976                                  ;
 18977                                  ; Procedure Name : DOS_CLOSE
 18978                                  ;
 18979                                  ; Inputs:
 18980                                  ;	[THISSFT] set to the SFT for the file being used
 18981                                  ; Function:
 18982                                  ;	Close the indicated file via the SFT
 18983                                  ; Returns:
 18984                                  ;	sf_ref_count decremented otherwise
 18985                                  ;	ES:DI point to SFT
 18986                                  ;	Carry set if error
 18987                                  ;	    AX has error code
 18988                                  ; DS preserved, others destroyed
 18989                                  ;---------------------------------------------------------------------------
 18990                                  
 18991                                  ;hkn; DOS_CLOSE called from fcbio.asm and handle.asm. DS alreday set up.
 18992                                  
 18993                                  ; 18/05/2019 - Retro DOS v4.0
 18994                                  ; DOSCODE:6E2Eh (MSDOS 6.21, MSDOS.SYS)
 18995                                  
 18996                                  ; 14/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 18997                                  ; DOSCODE:6E1Ah (MSDOS 5.0, MSDOS.SYS)
 18998                                  
 18999                                  ; 23/07/2018 - IBMDOS.COM (MSDOS 3.3), 1987 - Offset 39D0h
 19000                                  
 19001                                  DOS_CLOSE:
 19002 00002F9A C43E[9E05]              	LES	DI,[THISSFT]
 19003                                  	;mov	bx,[ES:DI+5]
 19004 00002F9E 268B5D05                	MOV	BX,[ES:DI+SF_ENTRY.sf_flags]
 19005                                  
 19006                                  ; Network closes are handled entirely by the net code.
 19007                                  
 19008                                  	;;test	bx,8000h
 19009                                  	;TEST	BX,sf_isnet
 19010                                  	; 17/12/2022
 19011                                  	;test	bh,80h
 19012 00002FA2 F6C780                  	test	bh,(sf_isnet>>8)
 19013 00002FA5 7406                    	JZ	short LocalClose
 19014                                  
 19015                                  	;CallInstall Net_Close,MultNET,6
 19016 00002FA7 B80611                  	mov     ax,1106h
 19017 00002FAA CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - CLOSE REMOTE FILE
 19018                                  			; ES:DI -> SFT
 19019                                  			; SFT DPB field -> DPB of drive containing file
 19020                                  			; Return: CF set on error, AX = DOS error code
 19021                                  			; CF clear if successful
 19022 00002FAC C3                      	retn
 19023                                  
 19024                                  ; All closes release the sharing information.
 19025                                  ; No commit releases sharing information
 19026                                  ;
 19027                                  ; All closes decrement the ref count.
 19028                                  ; No commit decrements the ref count.
 19029                                  
 19030                                  LocalClose:
 19031 00002FAD E8A7E3                  	call	ECritDisk
 19032 00002FB0 E86401                  	CALL	SetSFTTimes
 19033 00002FB3 E8E200                  	CALL	FREE_SFT		; dec ref count or mark as busy
 19034                                  
 19035                                  ;hkn; SS is DOSDATA
 19036                                  	;Context DS
 19037 00002FB6 16                      	push	ss
 19038 00002FB7 1F                      	pop	ds
 19039                                  
 19040 00002FB8 50                      	push	ax
 19041 00002FB9 53                      	push	bx
 19042 00002FBA E82044                  	call	ShareEnd
 19043 00002FBD 5B                      	pop	bx
 19044 00002FBE 58                      	pop	ax
 19045                                  
 19046                                  ; Commit enters here. AX from commit MUST be <> 1, BX is flags word
 19047                                  
 19048                                  CloseEntry:
 19049 00002FBF 50                      	PUSH	AX
 19050                                  
 19051                                  ; File clean or device does not get stamped nor disk looked at.
 19052                                  
 19053                                  	;test	bx,0C0h
 19054                                  	; 17/12/2022
 19055 00002FC0 F6C3C0                  	test	bl,devid_file_clean+devid_device
 19056                                  	;TEST	BX,devid_file_clean+devid_device
 19057 00002FC3 7403                    	JZ	short rdir
 19058                                  	; 14/11/2022
 19059 00002FC5 E9BD00                  	JMP	FREE_SFT_OK		; either clean or device
 19060                                  	;jnz	short FREE_SFT_OK ; 24/07/2019	
 19061                                  
 19062                                  ; Retrieve the directory entry for the file
 19063                                  
 19064                                  rdir:
 19065 00002FC8 E8DA00                  	CALL	DirFromSFT
 19066                                  	;mov	al,5
 19067 00002FCB B005                    	MOV	AL,error_access_denied
 19068 00002FCD 7303                    	JNC	short clook
 19069                                  	; 14/11/2022
 19070 00002FCF E9B400                  	JMP	CloseFinish		; pretend the close worked.
 19071                                  	;jc	short CloseFinish ; 24/07/2019
 19072                                  clook:
 19073                                  
 19074                                  ; ES:DI points to entry
 19075                                  ; DS:SI points to SFT
 19076                                  ; ES:BX points to buffer header
 19077                                  
 19078 00002FD2 57                      	push	di
 19079 00002FD3 56                      	push	si
 19080                                  	;lea	si,[si+20h]
 19081 00002FD4 8D7420                  	LEA	SI,[SI+SF_ENTRY.sf_name]
 19082                                  
 19083                                  ; ES:DI point to directory entry
 19084                                  ; DS:SI point to unpacked name
 19085                                  
 19086 00002FD7 E86DE2                  	call	XCHGP
 19087                                  
 19088                                  ; ES:DI point to unpacked name
 19089                                  ; DS:SI point to directory entry
 19090                                  
 19091 00002FDA E8B60E                  	call	MetaCompare
 19092 00002FDD E867E2                  	call	XCHGP
 19093 00002FE0 5E                      	pop	si
 19094 00002FE1 5F                      	pop	di
 19095 00002FE2 740C                    	JZ	short CLOSE_GO		; Name OK
 19096                                  Bye:	
 19097 00002FE4 89F7                    	MOV	DI,SI
 19098 00002FE6 1E                      	PUSH	DS
 19099 00002FE7 07                      	POP	ES			; ES:DI points to SFT
 19100 00002FE8 16                      	PUSH	SS
 19101 00002FE9 1F                      	POP	DS
 19102 00002FEA F9                      	STC
 19103                                  	;mov	al,2
 19104 00002FEB B002                    	MOV	AL,error_file_not_found
 19105 00002FED E99600                  	JMP	CloseFinish ; 24/07/2019
 19106                                  
 19107                                  	; 18/05/2019 - Retro DOS v4.0
 19108                                  CLOSE_GO:
 19109                                  	; MSDOS 6.0
 19110                                  	;test	word [si+2],8000h
 19111                                  	;TEST	word [SI+SF_ENTRY.sf_mode],sf_isFCB ; FCB ?
 19112                                  	; 17/12/2022
 19113                                  	;test	byte [si+3],80h
 19114 00002FF0 F6440380                	test	byte [SI+SF_ENTRY.sf_mode+1],(sf_isFCB>>8) ; FCB ?
 19115 00002FF4 740D                    	JZ	short nofcb		; no, set dir attr, sf_attr
 19116                                  	; MSDOS 3.3 & MSDOS 6.0
 19117                                  	;mov	ch,[es:di+0Bh]
 19118 00002FF6 268A6D0B                	MOV	CH,[ES:DI+dir_entry.dir_attr]
 19119                                  	;mov	al,[si+4]
 19120 00002FFA 8A4404                  	MOV	AL,[SI+SF_ENTRY.sf_attr]
 19121                                  
 19122                                  ;hkn; SS override
 19123 00002FFD 36A2[6B05]              	MOV	[SS:ATTRIB],AL
 19124                                  	; MSDOS 3.3
 19125                                  	;;call	MatchAttributes
 19126                                  	;;JNZ	short Bye		; attributes do not match
 19127                                  	; 18/05/2019
 19128 00003001 EB07                    	JMP	SHORT setattr		;FT.
 19129                                  nofcb:
 19130                                  	; MSDOS 6.0
 19131                                  	;mov	al,[si+4]
 19132 00003003 8A4404                  	MOV	AL,[SI+SF_ENTRY.sf_attr] ;FT.		;AN000;
 19133 00003006 2688450B                	MOV	[ES:DI+dir_entry.dir_attr],AL ;FT.	;AN000;
 19134                                  setattr:
 19135                                  	; MSDOS 3.3 (& MSDOS 6.0)
 19136                                  	;or	byte [es:di+0Bh],20h
 19137 0000300A 26804D0B20              	OR	BYTE [ES:DI+dir_entry.dir_attr],attr_archive ;Set archive
 19138                                  	; MSDOS 6.0
 19139                                  	;mov	ax,[es:di+1Ah]
 19140 0000300F 268B451A                	MOV	AX,[ES:DI+dir_entry.dir_first] ;AN011
 19141                                  					;F.O. save old first cluster
 19142                                  ;hkn; SS override
 19143 00003013 36A3[BD0F]              	MOV	[SS:OLD_FIRSTCLUS],AX	;AN011;F.O. save old first cluster
 19144                                  
 19145                                  	;mov	ax,[si+0Bh]
 19146 00003017 8B440B                  	MOV	AX,[SI+SF_ENTRY.sf_firclus]
 19147                                  	;mov	[es:di+1Ah],ax
 19148 0000301A 2689451A                	MOV	[ES:DI+dir_entry.dir_first],AX	;Set firclus pointer
 19149                                  	;mov	ax,[si+11h]
 19150 0000301E 8B4411                  	MOV	AX,[SI+SF_ENTRY.sf_size]
 19151                                  	;mov	[es:di+1Ch],ax
 19152 00003021 2689451C                	MOV	[ES:DI+dir_entry.dir_size_l],AX	;Set size
 19153                                  	;mov	ax,[si+13h]
 19154 00003025 8B4413                  	MOV	AX,[SI+SF_ENTRY.sf_size+2]
 19155                                  	;mov	[es:di+1Eh],ax
 19156 00003028 2689451E                	MOV	[ES:DI+dir_entry.dir_size_h],AX
 19157                                  	;mov	ax,[si+0Fh]
 19158 0000302C 8B440F                  	MOV	AX,[SI+SF_ENTRY.sf_date]
 19159                                  	;mov	[es:di+18h],ax
 19160 0000302F 26894518                	MOV	[ES:DI+dir_entry.dir_date],AX	;Set date
 19161                                  	;mov	ax,[si+0Dh]
 19162 00003033 8B440D                  	MOV	AX,[SI+SF_ENTRY.sf_time]
 19163                                  	;mov	[es:di+16h],ax
 19164 00003036 26894516                	MOV	[ES:DI+dir_entry.dir_time],AX	;Set time
 19165                                  
 19166                                  	; MSDOS 6.0
 19167                                  ;; File Tagging
 19168 0000303A 26F6470540              	TEST	byte [ES:BX+BUFFINFO.buf_flags],buf_dirty  
 19169                                  				  ;LB. if already dirty		    ;AN000;
 19170 0000303F 7508                    	JNZ	short yesdirty4	  ;LB.  don't increment dirty count ;AN000;
 19171                                  	; 02/06/2019
 19172 00003041 E87B2B                  	call	INC_DIRTY_COUNT   ;LB.				    ;AN000;
 19173                                  	; MSDOS 3.3 (& MSDOS 6.0)
 19174                                  	;or	byte [es:bx+5],40h
 19175 00003044 26804F0540              	OR	byte [ES:BX+BUFFINFO.buf_flags],buf_dirty ;Buffer dirty
 19176                                  yesdirty4:
 19177 00003049 1E                      	push	ds
 19178 0000304A 56                      	push	si
 19179                                  	; MSDOS 6.0
 19180                                  	;mov	cx,[si+0Bh]
 19181                                  	; 07/12/2022
 19182 0000304B 8B4C0B                  	MOV	CX,[SI+SF_ENTRY.sf_firclus] ; do this for Fastopen
 19183                                  ;hkn; SS override
 19184 0000304E 36A0[7605]              	MOV	AL,[SS:THISDRV]
 19185                                  	; MSDOS 3.3 
 19186                                  	;push	ss
 19187                                  	;pop	ds
 19188                                  	;MOV	AL,[THISDRV]
 19189                                  ;;; 10/1/86  update fastopen cache
 19190                                  	; MSDOS 3.3 & MSDOS 6.0
 19191 00003052 52                      	PUSH	DX
 19192 00003053 B400                    	MOV	AH,0			; dir entry update
 19193 00003055 88C2                    	MOV	DL,AL			; drive number A=0, B=1,,,
 19194                                  	; MSDOS 6.0
 19195 00003057 09C9                    	OR	CX,CX			;AN005; first cluster 0; may be truncated
 19196 00003059 750D                    	JNZ	short do_update2	;AN005; no, do update
 19197 0000305B B403                    	MOV	AH,3			;AN005; do a delete cache entry
 19198                                  	;mov	di,[si+1Bh]
 19199 0000305D 8B7C1B                  	MOV	DI,[SI+SF_ENTRY.sf_dirsec] ;AN005; cx:di = dir sector
 19200                                  	;mov	cx,[si+1Dh]
 19201 00003060 8B4C1D                  	MOV	CX,[SI+SF_ENTRY.sf_dirsec+2] ;AN005;
 19202                                  	;mov	dh,[si+1Fh]
 19203 00003063 8A741F                  	MOV	DH,[SI+SF_ENTRY.sf_dirpos] ;AN005; dh = dir pos
 19204 00003066 EB0E                    	JMP	SHORT do_update 	;AN011;F.O.
 19205                                  do_update2:				;AN011;F.O.
 19206                                  ;hkn; SS override fort OLD_FIRSTCLUS
 19207                                  	; 
 19208 00003068 363B0E[BD0F]            	CMP	CX,[SS:OLD_FIRSTCLUS]	;AN011;F.O. same as old first clusetr?
 19209 0000306D 7407                    	JZ	short do_update		;AN011;F.O. yes
 19210 0000306F B402                    	MOV	AH,2			;AN011;F.O. delete the old entry
 19211 00003071 368B0E[BD0F]            	MOV	CX,[SS:OLD_FIRSTCLUS]	;AN011;F.O.
 19212                                  do_update:				;AN005;
 19213                                  ;hkn; SS is DOSDATA
 19214                                  	;Context DS
 19215 00003076 16                      	push	ss
 19216 00003077 1F                      	pop	ds	
 19217                                  	; MSDOS 3.3 & MSDOS 6.0
 19218 00003078 E8E5F6                  	call	FastOpen_Update 	; invoke fastopen
 19219 0000307B 5A                      	POP	DX
 19220                                  
 19221                                  ;;; 10/1/86  update fastopen cache
 19222 0000307C E83B2A                  	call	FLUSHBUF		; flush all relevant buffers
 19223 0000307F 5F                      	pop	di
 19224 00003080 07                      	pop	es
 19225                                  	;mov	al,5
 19226 00003081 B005                    	MOV	AL,error_access_denied
 19227 00003083 7201                    	JC	short CloseFinish
 19228                                  FREE_SFT_OK:
 19229 00003085 F8                      	CLC				; signal no error.
 19230                                  CloseFinish:
 19231                                  
 19232                                  ; Indicate to the device that the SFT is being closed.
 19233                                  
 19234                                  ;;;; 7/21/86
 19235 00003086 9C                      	PUSHF				; save flag from DirFromSFT
 19236 00003087 E8D115                  	call	DEV_CLOSE_SFT
 19237 0000308A 9D                      	POPF
 19238                                  ;;;; 7/21/86
 19239                                  ;
 19240                                  ; See if the ref count indicates that we have busied the SFT. If so, mark the
 19241                                  ; SFT as being free. Note that we do NOT need to be in critSFT as we are ONLY
 19242                                  ; going to be moving from busy to free.
 19243                                  ;
 19244 0000308B 59                      	POP	CX			; get old ref count
 19245 0000308C 9C                      	PUSHF
 19246 0000308D 49                      	DEC	CX			; if cx != 1
 19247 0000308E 7503                    	JNZ	short NoFree		; then do NOT free SFT
 19248 00003090 26890D                  	mov	[es:di],cx
 19249                                  	;MOV	[ES:DI+SF_ENTRY.sf_ref_Count],CX ; mov [es:di+0],cx
 19250                                  NoFree:
 19251 00003093 E8DCE2                  	call	LCritDisk
 19252 00003096 9D                      	POPF
 19253 00003097 C3                      	retn
 19254                                  
 19255                                  ;---------------------------------------------------------------------------
 19256                                  ;
 19257                                  ; Procedure Name : FREE_SFT
 19258                                  ;
 19259                                  ; ES:DI -> SFT. Decs sft_ref_count. If the count goes to 0, mark it as busy.
 19260                                  ; Flags preserved. Return old ref count in AX
 19261                                  ;
 19262                                  ; Note that busy is indicated by the SFT ref count being -1.
 19263                                  ;
 19264                                  ;---------------------------------------------------------------------------
 19265                                  
 19266                                  FREE_SFT:
 19267 00003098 9C                      	PUSHF		; Save carry state
 19268 00003099 268B05                  	mov	ax,[es:di]
 19269                                  	;MOV	AX,[ES:DI+SF_ENTRY.sf_ref_count]
 19270 0000309C 48                      	DEC	AX
 19271 0000309D 7501                    	JNZ	short SetCount
 19272 0000309F 48                      	DEC	AX
 19273                                  SetCount:
 19274 000030A0 268705                  	xchg	ax,[es:di]
 19275                                  	;XCHG	AX,[ES:DI+SF_ENTRY.sf_ref_count]
 19276 000030A3 9D                      	POPF
 19277 000030A4 C3                      	retn
 19278                                  
 19279                                  	; 18/05/2019 - Retro DOS v4.0
 19280                                  
 19281                                  ;----------------------------------------------------------------------------
 19282                                  ;
 19283                                  ; Procedure Name : DirFromSFT
 19284                                  ;
 19285                                  ;   DirFromSFT - locate a directory entry given an SFT.
 19286                                  ;
 19287                                  ;   Inputs:	ES:DI point to SFT
 19288                                  ;		DS = DOSDATA
 19289                                  ;   Outputs:
 19290                                  ;		EXTERR_LOCUS = errLOC_Disk
 19291                                  ;		CurBuf points to buffer
 19292                                  ;		Carry Clear -> operation OK
 19293                                  ;		    ES:DI point to entry
 19294                                  ;		    ES:BX point to buffer
 19295                                  ;		    DS:SI point to SFT
 19296                                  ;		Carry SET   -> operation failed
 19297                                  ;		    registers trashified
 19298                                  ;   Registers modified: ALL
 19299                                  ;----------------------------------------------------------------------------
 19300                                  
 19301                                  DirFromSFT:
 19302                                  	;mov	byte [EXTERR_LOCUS],2
 19303 000030A5 C606[2303]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk
 19304 000030AA 06                      	push	es
 19305 000030AB 57                      	push	di
 19306                                  	; MSDOS 3.3
 19307                                  	;;mov	dx,[es:di+1Dh]
 19308                                  	;MOV	dx,[ES:DI+SF_ENTRY.sf_dirsec]
 19309                                  	; MSDOS 6.0
 19310                                  	;mov	dx,[es:[di+1Dh]
 19311 000030AC 268B551D                	MOV	DX,[ES:DI+SF_ENTRY.sf_dirsec+2]  ;F.C. >32mb
 19312 000030B0 8916[0706]              	MOV	[HIGH_SECTOR],DX		 ;F.C. >32mb
 19313                                  	;mov	dx,[es:di+1Bh]
 19314 000030B4 268B551B                	MOV	DX,[ES:DI+SF_ENTRY.sf_dirsec]
 19315                                  	; 19/05/2019
 19316 000030B8 FF36[0706]              	PUSH	word [HIGH_SECTOR]	;F.C. >32mb
 19317                                  	; MSDOS 3.3 & MSDOS 6.0
 19318 000030BC 52                      	PUSH	DX
 19319 000030BD E86B26                  	call	FATREAD_SFT		; ES:BP points to DPB, [THISDRV] set
 19320                                  					; [THISDPB] set
 19321 000030C0 5A                      	POP	DX
 19322 000030C1 8F06[0706]              	POP	word [HIGH_SECTOR]	;F.C. >32mb
 19323 000030C5 721E                    	JC	short PopDone
 19324                                  	; 22/09/2023
 19325                                  	;XOR	AL,AL	; *		; Pre read
 19326                                  	;;mov	byte [ALLOWED],18h
 19327                                  	;MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY ; *
 19328                                  	;call	GETBUFFR
 19329                                  	; 22/09/2023
 19330 000030C7 E8EC28                  	call	GETBUFFER ; * 		; Pre read
 19331 000030CA 7219                    	JC	short PopDone
 19332 000030CC 5E                      	pop	si
 19333 000030CD 1F                      	pop	ds			; Get back SFT pointer
 19334                                  
 19335                                  ;hkn; SS override
 19336 000030CE 36C43E[E205]            	LES	DI,[SS:CURBUF]
 19337                                  	;or	byte [es:di+5],4
 19338 000030D3 26804D0504              	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_isDIR
 19339 000030D8 89FB                    	MOV	BX,DI			; ES:BX point to buffer header
 19340                                  	;;lea	di,[di+16] ; MSDOS 3.3
 19341                                  	;lea	di,[di+20] ; MSDOS 6.0
 19342 000030DA 8D7D14                  	LEA	DI,[DI+BUFINSIZ] 	; Point to buffer
 19343                                  	;mov	al,32
 19344 000030DD B020                    	MOV	AL,dir_entry.size
 19345                                  	;mul	byte [si+1Fh] ; MSDOS 6.0
 19346 000030DF F6641F                  	MUL	byte [SI+SF_ENTRY.sf_dirpos]
 19347 000030E2 01C7                    	ADD	DI,AX			; Point at the entry
 19348 000030E4 C3                      	retn				; carry is clear
 19349                                  PopDone:
 19350 000030E5 5F                      	pop	di
 19351 000030E6 07                      	pop	es
 19352                                  PopDone_retn:
 19353 000030E7 C3                      	retn
 19354                                  
 19355                                  ;----------------------------------------------------------------------------
 19356                                  ;
 19357                                  ;**	DOS_Commit - UPdate Directory Entries
 19358                                  ;
 19359                                  ;	ENTRY	same as DOS_CLOSE (??? BUGBUG - update this jgl)
 19360                                  ;		(DS) = DOSGROUP
 19361                                  ;	EXIT	Same as DOS_CLOSE except ref_count field is not altered
 19362                                  ;	USES	all but DS
 19363                                  ;
 19364                                  ;----------------------------------------------------------------------------
 19365                                  
 19366                                  ; 14/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 19367                                  ; DOSCODE:6F72h (MSDOS 5.0, MSDOS.SYS)
 19368                                  
 19369                                  DOS_COMMIT:
 19370                                  	;hkn; called from srvcall. DS already set up.
 19371 000030E8 C43E[9E05]              	LES	DI,[THISSFT]
 19372                                  	;mov	bx,[es:di+5]
 19373 000030EC 268B5D05                	MOV	BX,[ES:DI+SF_ENTRY.sf_flags]
 19374                                  	;test	bx,0C0h
 19375                                  	; 17/12/2022
 19376 000030F0 F6C3C0                  	test	bl,devid_file_clean+devid_device ;Clears carry
 19377                                  	;TEST	BX,devid_file_clean+devid_device ;Clears carry
 19378 000030F3 75F2                    	jnz	short PopDone_retn
 19379                                  	;test	bx,8000h
 19380                                  	; 17/12/2022
 19381                                  	;test	bh,80h
 19382 000030F5 F6C780                  	test	bh,(sf_isnet>>8) ; 80h
 19383                                  	;TEST	BX,sf_isnet ; 8000h
 19384 000030F8 7406                    	JZ	short LOCAL_COMMIT
 19385                                  
 19386                                  ;IF NOT Installed
 19387                                  ;	transfer NET_COMMIT
 19388                                  ;ELSE
 19389                                  	;mov	ax,1107h
 19390 000030FA B80711                  	MOV	AX,(MultNET<<8)|7
 19391 000030FD CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - COMMIT REMOTE FILE
 19392                                  			; ES:DI -> SFT
 19393                                  			; SFT DPB field -> DPB of drive containing file
 19394                                  			; Return: CF set on error, AX = DOS error code
 19395                                  			; CF clear if successful
 19396                                  localcommit_retn: ; 18/12/2022	
 19397 000030FF C3                      	retn
 19398                                  ;ENDIF
 19399                                  
 19400                                  ; Perform local commit operation by doing a close but not releaseing the SFT.
 19401                                  ; There are three ways we can do this. One is to enter a critical section to
 19402                                  ; protect a potential free. The second is to increment the ref count to mask
 19403                                  ; the close decrementing.
 19404                                  ;
 19405                                  ; The proper way is to let the caller's of close decide if a decrement should
 19406                                  ; be done. We do this by providing another entry into close after the
 19407                                  ; decrement and after the share information release.
 19408                                  
 19409                                  ; DOSCODE:6FA0h (MSDOS 6.21, MSDOS.SYS)
 19410                                  ; DOSCODE:6F8Ch (MSDOS 5.0, MSDOS.SYS) 
 19411                                  
 19412                                  LOCAL_COMMIT:
 19413 00003100 E854E2                  	call	ECritDisk
 19414                                  	; MSDOS 6.0
 19415 00003103 E851E2                  	call	ECritDisk	;PTM.
 19416 00003106 E80E00                  	call	SetSFTTimes
 19417 00003109 B8FFFF                  	MOV	AX,-1
 19418 0000310C E8B0FE                  	call	CloseEntry
 19419                                  	; MSDOS 6.0
 19420 0000310F 9C                      	PUSHF			;PTM.				;AN000;
 19421 00003110 E84015                  	call	DEV_OPEN_SFT	;PTM.  increment device count	;AN000;
 19422 00003113 9D                      	POPF			;PTM.				;AN000;
 19423                                  	;call	LCritDisk	;PTM.				;AN000;
 19424                                  	; 18/12/2022
 19425 00003114 E95BE2                  	jmp	LCritDisk
 19426                                  ;localcommit_retn:
 19427                                  ;	retn
 19428                                  
 19429                                  ;Break	<SetSFTTimes - signal a change in the times for an SFT>
 19430                                  ;----------------------------------------------------------------------------
 19431                                  ;
 19432                                  ; Procedure Name : SetSFTTimes
 19433                                  ;
 19434                                  ;   SetSFTTimes - Examine the flags for a SFT and set the time appropriately.
 19435                                  ;   Reflect these times in other SFT's for the same file.
 19436                                  ;
 19437                                  ;   Inputs:	ES:DI point to SFT
 19438                                  ;		BX = sf_flags set apprpriately
 19439                                  ;   Outputs:	Set sft times to current time if File & dirty & !nodate
 19440                                  ;   Registers modified: All except ES:DI, BX, AX
 19441                                  ;
 19442                                  ;----------------------------------------------------------------------------
 19443                                  
 19444                                  SetSFTTimes:
 19445                                  ;	File clean or device does not get stamped nor disk looked at.
 19446                                  	
 19447                                  	;test	bx,0C0h
 19448                                  	; 17/12/2022
 19449 00003117 F6C3C0                  	test	bl,devid_file_clean+devid_device
 19450                                  	;TEST	BX,devid_file_clean+devid_device
 19451                                  	;retnz				; clean or device => no timestamp
 19452 0000311A 75E3                    	jnz	short localcommit_retn
 19453                                  
 19454                                  ;	file and dirty. See if date is good
 19455                                  
 19456                                  	;test	bx,4000h
 19457                                  	; 17/12/2022
 19458                                  	;test	bh,40h
 19459 0000311C F6C740                  	test	bh,(sf_close_nodate>>8)
 19460                                  	;TEST	BX,sf_close_nodate
 19461                                  	;retnz				; nodate => no timestamp
 19462 0000311F 75DE                    	jnz	short localcommit_retn
 19463                                  
 19464 00003121 50                      	push	ax
 19465 00003122 53                      	push	bx
 19466 00003123 E8EAD9                  	call	DATE16			; Date/Time to AX/DX
 19467                                  	;mov	[es:di+0Fh],ax
 19468 00003126 2689450F                	MOV	[ES:DI+SF_ENTRY.sf_date],AX
 19469                                  	;mov	[es:di+0Dh],dx
 19470 0000312A 2689550D                	MOV	[ES:DI+SF_ENTRY.sf_time],DX
 19471 0000312E 31C0                    	XOR	AX,AX
 19472                                  ;if installed
 19473                                  	;call	JShare + 14 * 4
 19474 00003130 FF1E[C800]              	call	far [JShare+(14*4)]	; 14 = ShSU
 19475                                  ;else
 19476                                  ;	call	ShSU
 19477                                  ;endif
 19478 00003134 5B                      	pop	bx
 19479 00003135 58                      	pop	ax
 19480 00003136 C3                      	retn
 19481                                  
 19482                                  ;============================================================================
 19483                                  ; DIRCALL.ASM, MSDOS 6.0, 1991
 19484                                  ;============================================================================
 19485                                  ; 23/07/2018 - Retro DOS v3.0
 19486                                  ; 18/05/2019 - Retro DOS v4.0
 19487                                  
 19488                                  ; DOSCODE:6FDAh (MSDOS 6.21, MSDOS.SYS)
 19489                                  
 19490                                  ;TITLE DIRCALL - Directory manipulation internal calls
 19491                                  ;NAME  DIRCALL
 19492                                  
 19493                                  ;**	Low level directory manipulation routines for making removing and
 19494                                  ;	  verifying local or NET directories
 19495                                  ;
 19496                                  ;	DOS_MKDIR
 19497                                  ;	DOS_CHDIR
 19498                                  ;	DOS_RMDIR
 19499                                  ;
 19500                                  ;	Modification history:
 19501                                  ;
 19502                                  ;		Created: ARR 30 March 1983
 19503                                  
 19504                                  ;BREAK <DOS_MkDir - Make a directory entry>
 19505                                  ;---------------------------------------------------------------------------
 19506                                  ;
 19507                                  ; Procedure Name : DOS_MkDir
 19508                                  ;
 19509                                  ; Inputs:
 19510                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 19511                                  ;		terminated)
 19512                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 19513                                  ;		( = -1 if current dir not involved, else
 19514                                  ;		 Points to first char after last "/" of current dir part)
 19515                                  ;	[THISCDS] Points to CDS being used
 19516                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 19517                                  ; Function:
 19518                                  ;	Make a new directory
 19519                                  ; Returns:
 19520                                  ;	Carry Clear
 19521                                  ;		No error
 19522                                  ;	Carry Set
 19523                                  ;	    AX is error code
 19524                                  ;		error_path_not_found
 19525                                  ;			Bad path (not in curr dir part if present)
 19526                                  ;		error_bad_curr_dir
 19527                                  ;			Bad path in current directory part of path
 19528                                  ;		error_access_denied
 19529                                  ;			Already exists, device name
 19530                                  ; DS preserved, Others destroyed
 19531                                  ;---------------------------------------------------------------------------
 19532                                  
 19533                                  ;hkn; called from path.asm. DS already set up.
 19534                                  
 19535                                  ; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 19536                                  ; DOSCODE:6FC6h (MSDOS 5.0, MSDOS.SYS)
 19537                                  
 19538                                  DOS_MKDIR:
 19539 00003137 E859E1                  	call	TestNet
 19540 0000313A 7313                    	JNC	short LOCAL_MKDIR
 19541                                  
 19542                                  ;IF NOT Installed
 19543                                  ;	transfer NET_MKDIR
 19544                                  ;ELSE
 19545                                  	;mov	ax,1103h
 19546 0000313C B80311                  	MOV	AX,(MultNET<<8)|3
 19547 0000313F CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - MAKE REMOTE DIRECTORY
 19548                                  			; SS = DOS CS
 19549                                  			; SDA first filename pointer -> fully-qualified directory name
 19550                                  			; SDA CDS pointer -> current directory
 19551                                  			; Return: CF set on error, AX = DOS error code
 19552                                  			; CF clear if successful
 19553 00003141 C3                      	retn
 19554                                  ;ENDIF
 19555                                  
 19556                                  NODEACCERRJ:
 19557                                  	;mov	ax,5
 19558 00003142 B80500                  	MOV	AX,error_access_denied
 19559                                  _BadRet:
 19560 00003145 F9                      	STC
 19561                                  	;call	LCritDisk
 19562                                  	;retn
 19563                                  	; 18/12/2022
 19564 00003146 E929E2                  	jmp	LCritDisk
 19565                                  
 19566                                  PATHNFJ:
 19567 00003149 E826E2                  	call	LCritDisk
 19568 0000314C E9EFF9                  	jmp	SET_MKND_ERR	; Map the MakeNode error and return
 19569                                  
 19570                                  LOCAL_MKDIR:
 19571 0000314F E805E2                  	call	ECritDisk
 19572                                  
 19573                                  ; MakeNode requires an SFT to fiddle with. We Use a temp spot (RENBUF)
 19574                                  
 19575 00003152 8C16[A005]              	MOV	[THISSFT+2],SS
 19576                                  
 19577                                  ;hkn; DOSDATA
 19578 00003156 C706[9E05][3E04]        	MOV	WORD [THISSFT],RENBUF
 19579                                  
 19580                                  ;  NOTE: Need WORD PTR because MASM takes type of
 19581                                  ;   TempSFT (byte) instead of type of sf_mft (word).
 19582                                  
 19583                                  	;mov	word [RENBUF+33h],0 ; MSDOS 6.0
 19584 0000315C C706[7104]0000          	MOV	WORD [RENBUF+SF_ENTRY.sf_MFT],0
 19585                                  				; make sure SHARER won't complain.
 19586                                  	;mov	al,10h
 19587 00003162 B010                    	MOV	AL,attr_directory
 19588 00003164 E88B18                  	call	MakeNode
 19589 00003167 72E0                    	JC	short PATHNFJ
 19590 00003169 83F803                  	CMP	AX,3
 19591 0000316C 74D4                    	JZ	short NODEACCERRJ ; Can't make a device into a directory
 19592 0000316E C42E[8A05]              	LES	BP,[THISDPB]	; Makenode zaps this
 19593 00003172 C53E[E205]              	LDS	DI,[CURBUF]
 19594 00003176 29FE                    	SUB	SI,DI
 19595 00003178 56                      	PUSH	SI		; Pointer to dir_first
 19596                                  	; MSDOS 6.0
 19597                                  	;push	word [DI+8]
 19598 00003179 FF7508                  	PUSH	WORD [DI+BUFFINFO.buf_sector+2]	;F.C. >32mb
 19599                                  	; MSDOS 3.3 & MSDOS 6.0
 19600                                  	;push	word [di+6]
 19601 0000317C FF7506                  	PUSH	WORD [DI+BUFFINFO.buf_sector] ; Sector of new node
 19602 0000317F 16                      	push	ss
 19603 00003180 1F                      	pop	ds
 19604 00003181 FF36[C205]              	PUSH	word [DIRSTART]	; Parent for .. entry
 19605 00003185 31C0                    	XOR	AX,AX
 19606 00003187 A3[C205]                	MOV	[DIRSTART],AX	; Null directory
 19607 0000318A E8A117                  	call	NEWDIR
 19608 0000318D 726F                    	JC	short NODEEXISTSPOPDEL ; No room
 19609 0000318F E8680D                  	call	GETENT		; First entry
 19610 00003192 726A                    	JC	short NODEEXISTSPOPDEL ; Screw up
 19611 00003194 C43E[E205]              	LES	DI,[CURBUF]
 19612                                  
 19613                                  	; MSDOS 6.0
 19614 00003198 26F6450540              	TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty  
 19615                                  				 ;LB. if already dirty		    ;AN000;
 19616 0000319D 7508                    	JNZ	short yesdirty5	 ;LB.   don't increment dirty count ;AN000;
 19617 0000319F E81D2A                  	call	INC_DIRTY_COUNT  ;LB.				    ;AN000;
 19618                                  	
 19619                                  	; MSDOS 3.3 & MSDOS 6.0
 19620                                  	;or	byte [es:di+5],40h  ; 07/12/2022
 19621 000031A2 26804D0540              	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
 19622                                  yesdirty5:
 19623                                  	;;add	di,16 ; MSDOS 3.3
 19624                                  	;add	di,20 ; MSDOS 6.0
 19625 000031A7 83C714                  	ADD	DI,BUFINSIZ	; Point at buffer
 19626 000031AA B82E20                  	MOV	AX,202EH	; ". "
 19627 000031AD 8B16[C205]              	MOV	DX,[DIRSTART]	; Point at itself
 19628 000031B1 E81A18                  	call	SETDOTENT
 19629 000031B4 B82E2E                  	MOV	AX,2E2EH	; ".."
 19630 000031B7 5A                      	POP	DX		; Parent
 19631 000031B8 E81318                  	call	SETDOTENT
 19632 000031BB C42E[8A05]              	LES	BP,[THISDPB]
 19633                                  	; 22/09/2023
 19634                                  	;;mov	byte [ALLOWED],18h
 19635                                  	;MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY ; *
 19636 000031BF 5A                      	POP	DX		; Entry sector
 19637                                  	; MSDOS 6.0
 19638 000031C0 8F06[0706]              	POP	word [HIGH_SECTOR] ;F.C. >32mb
 19639                                  
 19640                                  	;XOR	AL,AL ; *	; Pre read
 19641                                  	;call	GETBUFFR
 19642                                  	; 22/09/2023
 19643 000031C4 E8EF27                  	call	GETBUFFER ; *	; Pre read
 19644 000031C7 725B                    	JC	short NODEEXISTSP
 19645 000031C9 8B16[C205]              	MOV	DX,[DIRSTART]
 19646 000031CD C53E[E205]              	LDS	DI,[CURBUF]
 19647                                  	;or	byte [di+5],4
 19648 000031D1 804D0504                	OR	byte [DI+BUFFINFO.buf_flags],buf_isDIR
 19649 000031D5 5E                      	POP	SI		; dir_first pointer
 19650 000031D6 01FE                    	ADD	SI,DI
 19651 000031D8 8914                    	MOV	[SI],DX
 19652 000031DA 31D2                    	XOR	DX,DX
 19653 000031DC 895402                  	MOV	[SI+2],DX	; Zero size
 19654 000031DF 895404                  	MOV	[SI+4],DX
 19655                                  DIRUP:
 19656                                  	; MSDOS 6.0
 19657 000031E2 F6450540                	TEST	byte [DI+BUFFINFO.buf_flags],buf_dirty  
 19658                                  	;			 ;LB. if already dirty 		   ;AN000;
 19659 000031E6 7507                    	JNZ	short yesdirty6	 ;LB.  don't increment dirty count ;AN000;
 19660 000031E8 E8D429                  	call	INC_DIRTY_COUNT  ;LB.				   ;AN000;
 19661                                  	
 19662                                  	; MSDOS 3.3 & MSDOS 6.0
 19663                                  	;or	byte [di+5],40h
 19664 000031EB 804D0540                	OR	byte [DI+BUFFINFO.buf_flags],buf_dirty	; Dirty buffer
 19665                                  yesdirty6:
 19666 000031EF 16                      	push	ss
 19667 000031F0 1F                      	pop	ds
 19668 000031F1 268A4600                	mov	al,[es:bp]
 19669                                  	;MOV	AL,[ES:BP+DPB.DRIVE]  ; mov al,[es:bp+0]
 19670 000031F5 E8C228                  	call	FLUSHBUF
 19671                                  	;mov	ax,5
 19672 000031F8 B80500                  	MOV	AX,error_access_denied
 19673                                  	;call	LCritDisk
 19674                                  	;retn
 19675                                  	; 18/12/2022
 19676 000031FB E974E1                  	jmp	LCritDisk
 19677                                  
 19678                                  NODEEXISTSPOPDEL:
 19679 000031FE 5A                      	POP	DX		; Parent
 19680 000031FF 5A                      	POP	DX		; Entry sector
 19681                                  	; MSDOS 6.0 
 19682 00003200 8F06[0706]              	POP	word [HIGH_SECTOR] ; F.C. >32mb
 19683 00003204 C42E[8A05]              	LES	BP,[THISDPB]
 19684                                  	; 22/09/2023
 19685                                  	;;mov	byte [ALLOWED],18h
 19686                                  	;MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY ; *
 19687                                  	;XOR	AL,AL ; *	; Pre read
 19688                                  	;call	GETBUFFR
 19689                                  	; 22/09/2023
 19690 00003208 E8AB27                  	call	GETBUFFER ; *	; Pre read
 19691 0000320B 7217                    	JC	short NODEEXISTSP
 19692 0000320D C53E[E205]              	LDS	DI,[CURBUF]
 19693                                  	;or	byte [di+5],4
 19694 00003211 804D0504                	OR	byte [DI+BUFFINFO.buf_flags],buf_isDIR
 19695 00003215 5E                      	POP	SI		; dir_first pointer
 19696 00003216 01FE                    	ADD	SI,DI
 19697                                  	;sub	si,1Ah ; 26
 19698 00003218 83EE1A                  	SUB	SI,dir_entry.dir_first	;Point back to start of dir entry
 19699 0000321B C604E5                  	MOV	BYTE [SI],0E5H	; Free the entry
 19700 0000321E E8C1FF                  	CALL	DIRUP		; Error doesn't matter since erroring anyway
 19701                                  NODEEXISTS:
 19702 00003221 E91EFF                  	JMP	NODEACCERRJ ; 10/08/2018
 19703                                  
 19704                                  NODEEXISTSP:
 19705 00003224 5E                      	POP	SI		; Clean stack
 19706 00003225 EBFA                    	JMP	short NODEEXISTS
 19707                                  
 19708                                  ; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 19709                                  
 19710                                  ;BREAK <DOS_ChDir -- Verify a directory>
 19711                                  ;----------------------------------------------------------------------------
 19712                                  ;
 19713                                  ; Procedure Name : DOS_ChDir
 19714                                  ;
 19715                                  ; Inputs:
 19716                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 19717                                  ;		terminated)
 19718                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 19719                                  ;		( = -1 if current dir not involved, else
 19720                                  ;		 Points to first char after last "/" of current dir part)
 19721                                  ;	[THISCDS] Points to CDS being used May not be NUL
 19722                                  ; Function:
 19723                                  ;	Validate the path for potential new current directory
 19724                                  ; Returns:
 19725                                  ;	NOTE:
 19726                                  ;	    [SATTRIB] is modified by this call
 19727                                  ;	Carry Clear
 19728                                  ;	    CX is cluster number of the DIR, LOCAL CDS ONLY
 19729                                  ;		Caller must NOT set ID fields on a NET CDS.
 19730                                  ;	Carry Set
 19731                                  ;	    AX is error code
 19732                                  ;		error_path_not_found
 19733                                  ;			Bad path
 19734                                  ;		error_access_denied
 19735                                  ;			device or file name
 19736                                  ; DS preserved, Others destroyed
 19737                                  ;----------------------------------------------------------------------------
 19738                                  
 19739                                  ;hkn; called from path.asm and dir2.asm. DS already set up.
 19740                                  
 19741                                  ; 18/05/2019 - Retro DOS v4.0
 19742                                  ; DOSCODE:70DAh (MSDOS 6.21, MSDOS.SYS)
 19743                                  
 19744                                  ; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 19745                                  ; DOSCODE:70C6h (MSDOS 5.0, MSDOS.SYS)
 19746                                  
 19747                                  DOS_CHDIR:
 19748 00003227 E869E0                  	call	TestNet
 19749 0000322A 7306                    	JNC	short LOCAL_CHDIR
 19750                                  
 19751                                  ;IF NOT Installed
 19752                                  ;	transfer NET_CHDIR
 19753                                  ;ELSE
 19754                                  	;mov	ax,1105h
 19755 0000322C B80511                  	MOV	AX,(MultNET<<8)|5
 19756 0000322F CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - CHDIR
 19757                                  			; SS = DOS CS
 19758                                  			; SDA first filename pointer -> fully-qualified directory name
 19759                                  			; SDA CDS pointer -> current directory
 19760                                  			; Return: CF set on error, AX = DOS error code
 19761                                  			; CF clear if successful
 19762 00003231 C3                      	retn
 19763                                  ;ENDIF
 19764                                  
 19765                                  LOCAL_CHDIR:
 19766 00003232 E822E1                  	call	ECritDisk
 19767                                  	; MSDOS 6.0
 19768                                  	;;test	word [es:di+43h],2000h
 19769                                  	;TEST	word [ES:DI+curdir.flags],curdir_splice ;PTM.
 19770                                  	; 17/12/2022
 19771                                  	;test	byte [es:di+44h],20h
 19772 00003235 26F6454420              	test	byte [ES:DI+curdir.flags+1],(curdir_splice>>8) ;PTM.
 19773 0000323A 7406                    	JZ	short nojoin		   ;PTM.
 19774                                  	;mov	word [es:di+49h], 0FFFFh
 19775 0000323C 26C74549FFFF            	MOV	word [ES:DI+curdir.ID],0FFFFH ;PTM.
 19776                                  nojoin:
 19777                                  	; MSDOS 3.3 & MSDOS 6.0
 19778 00003242 C606[4C03]00            	MOV	byte [NoSetDir],0 ; FALSE
 19779                                  	;mov	byte [SATTRIB],16h
 19780 00003247 C606[6D05]16            	MOV	byte [SATTRIB],attr_directory+attr_system+attr_hidden
 19781                                  				; Dir calls can find these
 19782                                  ; DOS 3.3  6/24/86 FastOpen
 19783 0000324C 800E[3A0D]01            	OR	byte [FastOpenFlg],FastOpen_Set	; set fastopen flag
 19784 00003251 E8320D                  	call	GETPATH
 19785 00003254 9C                      	PUSHF						;AN000;
 19786 00003255 8026[3A0D]80            	AND	byte [FastOpenFlg],Fast_yes ; clear it all ;AC000;
 19787 0000325A 9D                      	POPF						;AN000;
 19788                                  ; DOS 3.3  6/24/86 FastOpen
 19789                                  
 19790                                  	; MSDOS 3.3
 19791                                  	;mov	byte [FastOpenFlg],0
 19792                                  	
 19793                                  	;mov	ax,3
 19794 0000325B B80300                  	MOV	AX,error_path_not_found
 19795 0000325E 7207                    	JC	short ChDirDone
 19796 00003260 753A                    	JNZ	short NOTDIRPATH	; Path not a DIR
 19797 00003262 8B0E[C205]              	MOV	CX,[DIRSTART]		; Get cluster number
 19798 00003266 F8                      	CLC
 19799                                  ChDirDone:
 19800                                  	;call	LCritDisk
 19801                                  	;retn
 19802                                  	; 18/12/2022
 19803 00003267 E908E1                  	jmp	LCritDisk
 19804                                  
 19805                                  ;BREAK <DOS_RmDir -- Remove a directory>
 19806                                  ;----------------------------------------------------------------------------
 19807                                  ;
 19808                                  ; Procedure Name : DOS_RmDir
 19809                                  ;
 19810                                  ; Inputs:
 19811                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 19812                                  ;		terminated)
 19813                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 19814                                  ;		( = -1 if current dir not involved, else
 19815                                  ;		 Points to first char after last "/" of current dir part)
 19816                                  ;	[THISCDS] Points to CDS being used
 19817                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 19818                                  ; Function:
 19819                                  ;	Remove a directory
 19820                                  ;	NOTE: Attempt to remove current directory must be detected by caller
 19821                                  ; Returns:
 19822                                  ;	NOTE:
 19823                                  ;	    [SATTRIB] is modified by this call
 19824                                  ;	Carry Clear
 19825                                  ;		No error
 19826                                  ;	Carry Set
 19827                                  ;	    AX is error code
 19828                                  ;		error_path_not_found
 19829                                  ;			Bad path (not in curr dir part if present)
 19830                                  ;		error_bad_curr_dir
 19831                                  ;			Bad path in current directory part of path
 19832                                  ;		error_access_denied
 19833                                  ;			device or file name, root directory
 19834                                  ;			Bad directory ('.' '..' messed up)
 19835                                  ; DS preserved, Others destroyed
 19836                                  ;----------------------------------------------------------------------------
 19837                                  
 19838                                  ;hkn; called from path.asm. DS already set up.
 19839                                  
 19840                                  ; 18/05/2019 - Retro DOS v4.0
 19841                                  ; DOSCODE:711Fh (MSDOS 6.21, MSDOS.SYS)
 19842                                  
 19843                                  ; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 19844                                  ; DOSCODE:710Bh (MSDOS 5.0, MSDOS.SYS)
 19845                                  
 19846                                  DOS_RMDIR:
 19847 0000326A E826E0                  	call	TestNet
 19848 0000326D 7306                    	JNC	short LOCAL_RMDIR
 19849                                  
 19850                                  ;IF NOT Installed
 19851                                  ;	transfer NET_RMDIR
 19852                                  ;ELSE
 19853                                  	;mov	ax,1101h
 19854 0000326F B80111                  	MOV	AX,(MultNET<<8)|1
 19855 00003272 CD2F                    	int	2Fh	; Multiplex - NETWORK REDIRECTOR - REMOVE REMOTE DIRECTORY
 19856                                  			; SS = DOS CS
 19857                                  			; SDA first filename pointer -> fully-qualified directory name
 19858                                  			; SDA CDS pointer -> current directory
 19859                                  			; Return: CF set on error, AX = DOS error code
 19860                                  			; CF clear if successful
 19861 00003274 C3                      	retn
 19862                                  ;ENDIF
 19863                                  
 19864                                  LOCAL_RMDIR:
 19865 00003275 E8DFE0                  	call	ECritDisk
 19866 00003278 C606[4C03]00            	MOV	byte [NoSetDir],0
 19867                                  	;mov	byte [SATTRIB],16h
 19868 0000327D C606[6D05]16            	MOV	byte [SATTRIB],attr_directory+attr_system+attr_hidden
 19869                                  					; Dir calls can find these
 19870 00003282 E8010D                  	call	GETPATH
 19871 00003285 720C                    	JC	short NOPATH		; Path not found
 19872 00003287 7513                    	JNZ	short NOTDIRPATH	; Path not a DIR
 19873 00003289 8B3E[C205]              	MOV	DI,[DIRSTART]
 19874 0000328D 09FF                    	OR	DI,DI			; Root ?
 19875 0000328F 750E                    	JNZ	short rmdir_get_buf	; No
 19876 00003291 EB09                    	JMP	SHORT NOTDIRPATH
 19877                                  
 19878                                  NOPATH:
 19879                                  	;mov	ax,3
 19880 00003293 B80300                  	MOV	AX,error_path_not_found
 19881 00003296 E9ACFE                  	JMP	_BadRet
 19882                                  
 19883                                  NOTDIRPATHPOP:
 19884 00003299 58                      	POP	AX  ; MSDOS 6.0		;F.C. >32mb
 19885 0000329A 58                      	POP	AX
 19886                                  NOTDIRPATHPOP2:
 19887 0000329B 58                      	POP	AX
 19888                                  NOTDIRPATH:
 19889 0000329C E9A3FE                  	JMP	NODEACCERRJ
 19890                                  
 19891                                  rmdir_get_buf:
 19892 0000329F C53E[E205]              	LDS	DI,[CURBUF]
 19893 000032A3 29FB                    	SUB	BX,DI		; Compute true offset
 19894 000032A5 53                      	PUSH	BX		; Save entry pointer
 19895                                  	
 19896                                  	; MSDOS 6.0
 19897                                  	;push	word [di+8]
 19898 000032A6 FF7508                  	PUSH	WORD [DI+BUFFINFO.buf_sector+2] ;F.C. >32mb
 19899                                  	
 19900                                  	; MSDOS 3.3 (& MSDOS 6.0)
 19901                                  	;push	word [di+6]
 19902 000032A9 FF7506                  	PUSH	WORD [DI+BUFFINFO.buf_sector] ; Save sector number
 19903                                  
 19904                                  ;hkn; SS is DOSDATA
 19905                                  	;context DS
 19906 000032AC 16                      	push	ss
 19907 000032AD 1F                      	pop	ds
 19908                                  	;context ES
 19909 000032AE 16                      	push	ss
 19910 000032AF 07                      	pop	es
 19911                                  
 19912                                  ;hkn; NAME1 is in DOSDATA
 19913 000032B0 BF[4B05]                	MOV	DI,NAME1
 19914 000032B3 B03F                    	MOV	AL,'?'
 19915 000032B5 B90B00                  	MOV	CX,11
 19916 000032B8 F3AA                    	REP	STOSB
 19917 000032BA 30C0                    	XOR	AL,AL
 19918 000032BC AA                      	STOSB				; Nul terminate it
 19919 000032BD E8590F                  	call	STARTSRCH		; Set search
 19920 000032C0 E8340C                  	call	GETENTRY		; Get start of directory
 19921 000032C3 72D4                    	JC	short NOTDIRPATHPOP	; Screw up
 19922 000032C5 8E1E[E405]              	MOV	DS,[CURBUF+2]
 19923 000032C9 89DE                    	MOV	SI,BX
 19924 000032CB AD                      	LODSW
 19925                                  	;CMP	AX,(' ' SHL 8) OR '.'   ; First entry '.'?
 19926 000032CC 3D2E20                  	cmp	ax,202Eh ; ". "
 19927 000032CF 75C8                    	JNZ	short NOTDIRPATHPOP	; Nope
 19928                                  	;add	si,30
 19929 000032D1 83C61E                  	ADD	SI,dir_entry.size-2 ; Next entry
 19930 000032D4 AD                      	LODSW
 19931                                  	;CMP	AX,('.' SHL 8) OR '.'   ; Second entry '..'?
 19932                                  	;cmp	ax, '..'
 19933 000032D5 3D2E2E                  	cmp	ax,2E2Eh
 19934 000032D8 75BF                    	JNZ	short NOTDIRPATHPOP	; Nope
 19935                                  
 19936                                  ;hkn; SS is DOSDATA
 19937                                  	;context DS
 19938 000032DA 16                      	push	ss
 19939 000032DB 1F                      	pop	ds
 19940 000032DC C706[4803]0200          	MOV	word [LASTENT],2	; Skip . and ..
 19941 000032E2 E8120C                  	call	GETENTRY		; Get next entry
 19942 000032E5 72B2                    	JC	short NOTDIRPATHPOP	; Screw up
 19943                                  	;mov	byte [ATTRIB],16h
 19944 000032E7 C606[6B05]16            	MOV	byte [ATTRIB],attr_directory+attr_hidden+attr_system
 19945 000032EC E8100B                  	call	SRCH			; Do a search
 19946 000032EF 73A8                    	JNC	short NOTDIRPATHPOP	; Found another entry!
 19947 000032F1 803E[4A03]00            	CMP	byte [FAILERR],0
 19948 000032F6 75A1                    	JNZ	short NOTDIRPATHPOP	; Failure of search due to I 24 FAIL
 19949 000032F8 C42E[8A05]              	LES	BP,[THISDPB]
 19950 000032FC 8B1E[C205]              	MOV	BX,[DIRSTART]
 19951 00003300 E8231C                  	call	RELEASE 		; Release data in sub dir
 19952 00003303 7294                    	JC	short NOTDIRPATHPOP	; Screw up
 19953 00003305 5A                      	POP	DX			; Sector # of entry
 19954 00003306 8F06[0706]              	POP	word [HIGH_SECTOR] ; MSDOS 6.0	; F.C. >32mb
 19955                                  	; 22/09/2023
 19956                                  	;;mov	byte [ALLOWED],18h
 19957                                  	;MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY ; *
 19958                                  	;XOR	AL,AL ; *		; Pre read
 19959                                  	;call	GETBUFFR		; Get sector back
 19960 0000330A E8A926                  	call	GETBUFFER ; *		; Pre Read
 19961 0000330D 728C                    	JC	short NOTDIRPATHPOP2	; Screw up
 19962 0000330F C53E[E205]              	LDS	DI,[CURBUF]
 19963                                  	;or	byte [di+5],4
 19964 00003313 804D0504                	OR	byte [DI+BUFFINFO.buf_flags],buf_isDIR
 19965 00003317 5B                      	POP	BX			; Pointer to start of entry
 19966 00003318 01FB                    	ADD	BX,DI			; Corrected
 19967 0000331A C607E5                  	MOV	BYTE [BX],0E5H		; Free the entry
 19968                                  
 19969                                  ;DOS 3.3 FastOpen  6/16/86  F.C.
 19970 0000331D 1E                      	PUSH	DS
 19971                                  
 19972                                  ;hkn; SS is DOSDATA
 19973                                  	;context DS
 19974 0000331E 16                      	push	ss
 19975 0000331F 1F                      	pop	ds
 19976                                  
 19977                                  	; MSDOS 6.0
 19978 00003320 E80EF4                  	call	FastOpen_Delete 	; call fastopen to delete an entry
 19979                                  
 19980                                  ;	; MSDOS 3.3
 19981                                  ;_FastOpen_Delete:
 19982                                  ;	push	ax
 19983                                  ;	mov	si,[WFP_START]
 19984                                  ;	mov	bx,FastTable
 19985                                  ;	;mov	al,3  ; FONC_delete
 19986                                  ;	mov	al,FONC_delete
 19987                                  ;	call	far [BX+2]  ; FastTable+2
 19988                                  ;	pop	ax
 19989                                  
 19990 00003323 1F                      	POP	DS
 19991                                  ;DOS 3.3 FastOpen  6/16/86  F.C.
 19992                                  
 19993 00003324 E9BBFE                  	JMP	DIRUP			; In MKDIR, dirty buffer and flush
 19994                                  
 19995                                  ;============================================================================
 19996                                  ; DISK.ASM, MSDOS 6.0, 1991
 19997                                  ;============================================================================
 19998                                  ; 23/07/2018 - Retro DOS v3.0 
 19999                                  ; 04/05/2019 - Retro DOS v4.0
 20000                                  
 20001                                  ;	TITLE	DISK - Disk utility routines
 20002                                  ;	NAME	Disk
 20003                                  
 20004                                  ;**	Low level Read and write routines for local SFT I/O on files and devs
 20005                                  ;
 20006                                  ;	SWAPCON
 20007                                  ;	SWAPBACK
 20008                                  ;	DOS_READ
 20009                                  ;	DOS_WRITE
 20010                                  ;	get_io_sft
 20011                                  ;	DirRead
 20012                                  ;	FIRSTCLUSTER
 20013                                  ;	SET_BUF_AS_DIR
 20014                                  ;	FATSecRd
 20015                                  ;	DREAD
 20016                                  ;	CHECK_WRITE_LOCK
 20017                                  ;	CHECK_READ_LOCK
 20018                                  ;
 20019                                  ;	Revision history:
 20020                                  ;
 20021                                  ;		A000   version 4.00  Jan. 1988
 20022                                  ;
 20023                                  ;----------------------------------------------------------------------------
 20024                                  ;
 20025                                  ; M065 : B#5276. On raw read/write of a block of characters if a critical
 20026                                  ;		error happens, DOS retries the entire block assuming that
 20027                                  ;		zero characters were transferred. Modified the code to take
 20028                                  ;		into account the number of characters transfered before
 20029                                  ;		retrying the operation.
 20030                                  ;
 20031                                  ;----------------------------------------------------------------------------
 20032                                  ;
 20033                                  
 20034                                  ;Installed = TRUE
 20035                                  
 20036                                  ;Break	<SwapCon, Swap Back - Old-style I/O to files>
 20037                                  
 20038                                  ; **** Drivers for file input from devices ****
 20039                                  ;----------------------------------------------------------------------------
 20040                                  ;   Indicate that there is no more I/O occurring through another SFT outside
 20041                                  ;   of handles 0 and 1
 20042                                  ;
 20043                                  ;   Inputs:	DS is DOSDATA
 20044                                  ;   Outputs:	CONSWAP is set to false.
 20045                                  ;   Registers modified: none
 20046                                  ;----------------------------------------------------------------------------
 20047                                  
 20048                                  ; IBMDOS.COM (MSDOS 3.3) - Offset 3CF8h
 20049                                  
 20050                                  ; DOSCODE:71E3h (MSDOS 6.21, MSDOS.SYS)
 20051                                  ; 04/05/2019 - Retro DOS v4.0
 20052                                  
 20053                                  ; DOSCODE:71CFh (MSDOS 5.0, MSDOS.SYS)
 20054                                  ; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 20055                                  
 20056                                  SWAPBACK:
 20057 00003327 C606[5703]00            	MOV	BYTE [CONSWAP],0	; signal no conswaps
 20058 0000332C C3                      	retn
 20059                                  
 20060                                  ;----------------------------------------------------------------------------
 20061                                  ;
 20062                                  ; Procedure Name : SWAPCON
 20063                                  ;
 20064                                  ;   Copy ThisSFT to CONSFT for use by the 1-12 primitives.
 20065                                  ;
 20066                                  ;   Inputs:	ThisSFT as the sft of the desired file
 20067                                  ;		DS is DOSDATA
 20068                                  ;   Outputs:	CONSWAP is set.  CONSFT = ThisSFT.
 20069                                  ;   Registers modified: none
 20070                                  ;--------------------------------------------------------------------------
 20071                                  
 20072                                  SWAPCON:
 20073                                  	; MSDOS 3.3
 20074                                  	;push	es
 20075                                  	;push	di
 20076                                  	;mov	byte [CONSWAP],1
 20077                                  	;les	di,[THISSFT]
 20078                                  	;mov	word [CONSFT],di
 20079                                  	;mov	word [CONSFT+2],es
 20080                                  	;pop	di
 20081                                  	;pop	es
 20082                                  	;retn
 20083                                  
 20084                                  	; MSDOS 6.0
 20085 0000332D C606[5703]01            	mov	byte [CONSWAP],1	; ConSwap = TRUE
 20086 00003332 50                      	push	ax
 20087 00003333 A1[9E05]                	mov	ax,[THISSFT]
 20088 00003336 A3[E605]                	mov	[CONSFT],ax
 20089 00003339 A1[A005]                	mov	ax,[THISSFT+2]
 20090 0000333C A3[E805]                	mov	[CONSFT+2],ax
 20091 0000333F 58                      	pop	ax
 20092 00003340 C3                      	retn
 20093                                  
 20094                                  ; DOSCODE:71FDh (MSDOS 6.21, MSDOS.SYS)
 20095                                  ; 04/05/2019 - Retro DOS v4.0
 20096                                  
 20097                                  ;Break	<DOS_READ -- MAIN READ ROUTINE AND DEVICE IN ROUTINES>
 20098                                  ;-----------------------------------------------------------------------------
 20099                                  ;
 20100                                  ; Inputs:
 20101                                  ;	ThisSFT set to the SFT for the file being used
 20102                                  ;	[DMAADD] contains transfer address
 20103                                  ;	CX = No. of bytes to read
 20104                                  ;	DS = DOSDATA
 20105                                  ; Function:
 20106                                  ;	Perform read operation
 20107                                  ; Outputs:
 20108                                  ;    Carry clear
 20109                                  ;	SFT Position and cluster pointers updated
 20110                                  ;	CX = No. of bytes read
 20111                                  ;	ES:DI point to SFT
 20112                                  ;    Carry set
 20113                                  ;	AX is error code
 20114                                  ;	CX = 0
 20115                                  ;	ES:DI point to SFT
 20116                                  ; DS preserved, all other registers destroyed
 20117                                  ;
 20118                                  ;-----------------------------------------------------------------------------
 20119                                  
 20120                                  ;hkn; called from fcbio.asm, handle.asm and dev.asm. DS is be set up.
 20121                                  
 20122                                  ; DOSCODE:71E9h (MSDOS 5.0, MSDOS.SYS)
 20123                                  ; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 20124                                  
 20125                                  DOS_READ:
 20126 00003341 C43E[9E05]              	LES	DI,[THISSFT]
 20127                                  
 20128                                  ; Verify that the sft has been opened in a mode that allows reading.
 20129                                  
 20130                                  	;mov	al,[es:di+2]
 20131 00003345 268A4502                	MOV	AL,[ES:DI+SF_ENTRY.sf_mode]
 20132                                  	;and	al,0Fh
 20133 00003349 240F                    	AND	AL,access_mask
 20134                                  	;cmp	al,1
 20135 0000334B 3C01                    	CMP	AL,open_for_write
 20136 0000334D 7503                    	JNE	short READ_NO_MODE	; Is read or both
 20137 0000334F E90306                  	jmp	SET_ACC_ERR
 20138                                  
 20139                                  READ_NO_MODE:
 20140 00003352 E8E104                  	call	SETUP
 20141 00003355 E30B                    	JCXZ	NoIORet 		; no bytes to read - fast return
 20142 00003357 E852DF                  	call	IsSFTNet
 20143 0000335A 7408                    	JZ	short LOCAL_READ
 20144                                  
 20145                                  ;IF NOT Installed
 20146                                  ;	transfer NET_READ
 20147                                  ;ELSE
 20148                                  	;mov	ax,1108h
 20149 0000335C B80811                  	MOV	AX,(MultNET<<8)|8
 20150 0000335F CD2F                    	int	2Fh	; Multiplex - NETWORK REDIRECTOR - READ FROM REMOTE FILE
 20151                                  			; ES:DI -> SFT
 20152                                  			; SFT DPB field -> DPB of drive containing file
 20153                                  			; CX = number of bytes, SS = DOS CS, SDA DTA field -> user buffer
 20154                                  			; Return: CF set on error, CX = bytes read
 20155 00003361 C3                      	retn
 20156                                  ;ENDIF
 20157                                  
 20158                                  ; The user ended up requesting 0 bytes of input. We do nothing for this case
 20159                                  ; except return immediately.
 20160                                  
 20161                                  NoIORet:
 20162 00003362 F8                      	CLC
 20163 00003363 C3                      	retn
 20164                                  
 20165                                  LOCAL_READ:
 20166                                  	;test	word [es:di+5],80h
 20167                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device  ; Check for named device I/O
 20168 00003364 26F6450580              	test	byte [ES:DI+SF_ENTRY.sf_flags],devid_device ; 02/06/2019
 20169 00003369 750E                    	JNZ	short READDEV
 20170                                  
 20171                                  	;mov	byte [EXTERR_LOCUS],2
 20172 0000336B C606[2303]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk
 20173 00003370 E8E4DF                  	call	ECritDisk
 20174 00003373 E89B05                  	call	DISKREAD
 20175                                  
 20176                                  critexit:
 20177                                  	;call	LCritDisk
 20178                                  	;retn
 20179                                  	; 16/12/2022
 20180 00003376 E9F9DF                  	jmp	LCritDisk
 20181                                  
 20182                                  ; We are reading from a device. Examine the status of the device to see if we
 20183                                  ; can short-circuit the I/O. If the device in the EOF state or if it is the
 20184                                  ; null device, we can safely indicate no transfer.
 20185                                  
 20186                                  READDEV:
 20187                                  	;mov	byte [EXTERR_LOCUS],4
 20188 00003379 C606[2303]04            	MOV	byte [EXTERR_LOCUS],errLOC_SerDev
 20189                                  	;mov	bl,[es:di+5]
 20190 0000337E 268A5D05                	MOV	BL,[ES:DI+SF_ENTRY.sf_flags]
 20191 00003382 C43E[2C03]              	LES	DI,[DMAADD]
 20192                                  	;test	bl,40h
 20193 00003386 F6C340                  	test	BL,devid_device_EOF	; End of file?
 20194 00003389 7407                    	JZ	short ENDRDDEVJ3
 20195                                  	;test	bl,4
 20196 0000338B F6C304                  	test	BL,devid_device_null	; NUL device?
 20197 0000338E 7405                    	JZ	short TESTRAW 		; NO
 20198 00003390 30C0                    	XOR	AL,AL			; Indicate EOF by setting zero
 20199                                  ENDRDDEVJ3:
 20200                                  	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility!)
 20201                                  	;JMP	short ENDRDDEVJ2
 20202                                  	; 16/12/2022
 20203 00003392 E96701                  	jmp	ENDRDDEV ; 04/05/2019
 20204                                  
 20205                                  ; We need to hit the device. Figure out if we do a raw read or we do the
 20206                                  ; bizarre std_con_string_input.
 20207                                  
 20208                                  TESTRAW:
 20209                                  	;test	bl,20h
 20210 00003395 F6C320                  	test	BL,devid_device_raw	; Raw mode?
 20211 00003398 7508                    	JNZ	short DVRDRAW 		; Yes, let the device do all local editing
 20212                                  	;test	bl,1
 20213 0000339A F6C301                  	test	BL,devid_device_con_in	; Is it console device?
 20214 0000339D 7461                    	JZ	short NOTRDCON
 20215 0000339F E98F01                  	JMP	READCON
 20216                                  
 20217                                  DVRDRAW:
 20218 000033A2 06                      	PUSH	ES
 20219 000033A3 1F                      	POP	DS			; Xaddr to DS:DI
 20220                                  
 20221                                  	; 04/05/2019 - Retro DOS v4.0
 20222                                  
 20223                                  	; MSDOS 6.0
 20224                                  ;SR;
 20225                                  ;Check for win386 presence -- if present, do polled read of characters
 20226                                  
 20227 000033A4 36F606[2F10]01          	test	byte [ss:IsWin386],1 ; 19/05/2019
 20228 000033AA 7408                    	jz	short ReadRawRetry	;not present
 20229 000033AC F6C301                  	test	bl,devid_device_con_in	;is it console device
 20230 000033AF 7403                    	jz	short ReadRawRetry	;no, do normal read
 20231 000033B1 E9BA00                  	jmp	do_polling		;yes, do win386 polling loop
 20232                                  
 20233                                  ReadRawRetry:
 20234 000033B4 89FB                    	MOV	BX,DI			; DS:BX transfer addr
 20235 000033B6 31C0                    	XOR	AX,AX			; Media Byte, unit = 0
 20236 000033B8 89C2                    	MOV	DX,AX			; Start at 0
 20237 000033BA E89013                  	call	SETREAD
 20238 000033BD 1E                      	PUSH	DS			; Save Seg part of Xaddr
 20239                                  
 20240                                  ;hkn; SS override
 20241 000033BE 36C536[9E05]            	LDS	SI,[SS:THISSFT]
 20242 000033C3 E80E13                  	call	DEVIOCALL
 20243 000033C6 89FA                    	MOV	DX,DI			; DS:DX is preserved by INT 24
 20244 000033C8 B486                    	MOV	AH,86H			; Read error
 20245                                  
 20246                                  ;hkn; SS override
 20247 000033CA 368B3E[5D03]            	MOV	DI,[SS:DEVCALL_REQSTAT]
 20248                                  	; MSDOS 3.3
 20249                                  	;test	di,8000h
 20250                                  	;jz	short CRDROK
 20251                                  	; MSDOS 6.0
 20252 000033CF 09FF                    	or	di,di
 20253 000033D1 7923                    	jns	short CRDROK		; no errors
 20254                                  	; MSDOS 3.3 (& MSDOS 6.0)
 20255 000033D3 E8631F                  	call	CHARHARD
 20256 000033D6 89D7                    	MOV	DI,DX			; DS:DI is Xaddr
 20257                                  
 20258                                  	; 04/05/2019
 20259                                  
 20260                                  	; MSDOS 6.0
 20261 000033D8 36033E[6C03]            	add	di,[ss:CALLSCNT]	; update ptr and count to reflect the	M065
 20262 000033DD 362B0E[6C03]            	sub	cx,[ss:CALLSCNT]	; number of chars xferred		M065
 20263                                  
 20264                                  	; MSDOS 3.3 (& MSDOS 6.0)
 20265 000033E2 08C0                    	OR	AL,AL
 20266 000033E4 7410                    	JZ	short CRDROK		; Ignore
 20267 000033E6 3C03                    	CMP	AL,3
 20268 000033E8 7403                    	JZ	short CRDFERR 		; fail.
 20269 000033EA 1F                      	POP	DS			; Recover saved seg part of Xaddr
 20270 000033EB EBC7                    	JMP	short ReadRawRetry	; Retry
 20271                                  
 20272                                  ; We have encountered a device-driver error. We have informed the user of it
 20273                                  ; and he has said for us to fail the system call.
 20274                                  
 20275                                  CRDFERR:
 20276 000033ED 5F                      	POP	DI			; Clean stack
 20277                                  DEVIOFERR:
 20278                                  
 20279                                  ;hkn; SS override
 20280 000033EE 36C43E[9E05]            	LES	DI,[SS:THISSFT]
 20281 000033F3 E95D05                  	jmp	SET_ACC_ERR_DS
 20282                                  
 20283                                  CRDROK:
 20284 000033F6 5F                      	POP	DI			; Chuck saved seg of Xaddr
 20285 000033F7 89D7                    	MOV	DI,DX
 20286                                  
 20287                                  ;hkn; SS override
 20288 000033F9 36033E[6C03]            	ADD	DI,[ss:CALLSCNT]	; Amount transferred
 20289                                  	;JMP	SHORT ENDRDDEVJ3
 20290                                  	; 16/12/2022
 20291 000033FE EB6B                    	jmp	short ENDRDDEVJ2
 20292                                  
 20293                                  ; We are going to do a cooked read on some character device. There is a
 20294                                  ; problem here, what does the data look like? Is it a terminal device, line
 20295                                  ; CR line CR line CR, or is it file data, line CR LF line CR LF? Does it have
 20296                                  ; a ^Z at the end which is data, or is the ^Z not data?  In any event we're
 20297                                  ; going to do this: Read in pieces up to CR (CRs included in data) or ^z (^z
 20298                                  ; included in data). this "simulates" the way con works in cooked mode
 20299                                  ; reading one line at a time. With file data, however, the lines will look
 20300                                  ; like, LF line CR. This is a little weird.
 20301                                  
 20302                                  NOTRDCON:
 20303 00003400 8CC0                    	MOV	AX,ES
 20304 00003402 8ED8                    	MOV	DS,AX
 20305 00003404 89FB                    	MOV	BX,DI
 20306 00003406 31D2                    	XOR	DX,DX
 20307 00003408 89D0                    	MOV	AX,DX
 20308 0000340A 51                      	PUSH	CX
 20309 0000340B B90100                  	MOV	CX,1
 20310 0000340E E83C13                  	call	SETREAD
 20311 00003411 59                      	POP	CX
 20312                                  
 20313                                  ;hkn; SS override
 20314 00003412 36C536[9E05]            	LDS	SI,[SS:THISSFT]
 20315                                  	;lds	si,[si+7]
 20316 00003417 C57407                  	LDS	SI,[SI+SF_ENTRY.sf_devptr]
 20317                                  DVRDLP:
 20318 0000341A E8FD1C                  	call	DSKSTATCHK
 20319 0000341D E8B712                  	call	DEVIOCALL2
 20320 00003420 57                      	PUSH	DI		; Save "count" done
 20321 00003421 B486                    	MOV	AH,86H
 20322                                  
 20323                                  ;hkn; SS override
 20324 00003423 368B3E[5D03]            	MOV	DI,[SS:DEVCALL_REQSTAT]
 20325                                  	
 20326                                  	; MSDOS 3.3
 20327                                  	;test	di,8000h
 20328                                  	;jz	short CRDOK
 20329                                  	; MSDOS 6.0
 20330 00003428 09FF                    	or	di,di
 20331 0000342A 7917                    	jns	short CRDOK
 20332                                  	
 20333 0000342C E80A1F                  	call	CHARHARD
 20334 0000342F 5F                      	POP	DI
 20335                                  
 20336                                  ;hkn; SS override
 20337 00003430 36C706[6C03]0100        	MOV	word [SS:CALLSCNT],1
 20338 00003437 3C01                    	CMP	AL,1
 20339 00003439 74DF                    	JZ	short DVRDLP		;Retry
 20340 0000343B 3C03                    	CMP	AL,3
 20341 0000343D 74AF                    	JZ	short DEVIOFERR		; FAIL
 20342 0000343F 30C0                    	XOR	AL,AL			; Ignore, Pick some random character
 20343 00003441 EB12                    	JMP	SHORT DVRDIGN
 20344                                  
 20345                                  CRDOK:
 20346 00003443 5F                      	POP	DI
 20347                                  
 20348                                  ;hkn; SS override
 20349 00003444 36833E[6C03]01          	CMP	word [SS:CALLSCNT],1
 20350                                  	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility!)
 20351 0000344A 751F                    	JNZ	short ENDRDDEVJ2
 20352                                  	; 16/12/2022
 20353                                  	;jnz	short ENDRDDEV ; 24/07/2019
 20354                                  
 20355 0000344C 1E                      	PUSH	DS
 20356                                  
 20357                                  ;hkn; SS override
 20358 0000344D 368E1E[6A03]            	MOV	DS,[SS:CALLXAD+2]
 20359 00003452 8A05                    	MOV	AL,[DI]			; Get the character we just read
 20360 00003454 1F                      	POP	DS
 20361                                  DVRDIGN:
 20362                                  
 20363                                  ;hkn; SS override
 20364 00003455 36FF06[6803]            	INC	WORD [SS:CALLXAD]	; Next character
 20365 0000345A 36C706[5D03]0000        	MOV	word [SS:DEVCALL_REQSTAT],0
 20366 00003461 47                      	INC	DI			; Next character
 20367 00003462 3C1A                    	CMP	AL,1Ah			; ^Z?
 20368                                  	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility!)
 20369 00003464 7405                    	JZ	short ENDRDDEVJ2	; Yes, done zero set (EOF)
 20370                                  	; 16/12/2022
 20371                                  	;jz	short ENDRDDEV ; 24/07/2019	
 20372 00003466 3C0D                    	CMP	AL,c_CR  ; 0Dh		; CR?
 20373 00003468 E0B0                    	LOOPNZ	DVRDLP			; Loop if no, else done
 20374 0000346A 40                      	INC	AX			; Resets zero flag so NOT EOF, unless
 20375                                  					;  AX=FFFF which is not likely
 20376                                  ENDRDDEVJ2:
 20377                                  	; 16/12/2022
 20378                                  	;JMP	short ENDRDDEV		; changed short to long for win386
 20379                                  	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 20380 0000346B E98E00                  	jmp	ENDRDDEV
 20381                                  
 20382                                  	; 04/05/2019
 20383                                  
 20384                                  	; MSDOS 6.0
 20385                                  ;SR;
 20386                                  ;Polling code for raw read on CON when WIN386 is present
 20387                                  ;
 20388                                  ;At this point -- ds:di is transfer address
 20389                                  ;		  cx is count
 20390                                  
 20391                                  do_polling:
 20392 0000346E 89FB                    	mov	bx,di			;ds:bx is Xfer address
 20393 00003470 31C0                    	xor	ax,ax
 20394 00003472 89C2                    	mov	dx,ax
 20395 00003474 E8D612                  	call	SETREAD			;prepare device packet
 20396                                  
 20397                                  do_io:
 20398                                  ;Change read to a NON-DESTRUCTIVE READ, NO WAIT
 20399                                  
 20400 00003477 26C6470205              	mov	byte [es:bx+2],DEVRDND ; 5 ;Change command code
 20401 0000347C 1E                      	push	ds
 20402 0000347D 36C536[9E05]            	lds	si,[ss:THISSFT]		;get device header
 20403 00003482 E84F12                  	call	DEVIOCALL		;call device driver
 20404 00003485 1F                      	pop	ds
 20405                                  	
 20406                                  	;test	word [es:bx+3],8000h
 20407                                  	; 16/12/2022
 20408                                  	;test	byte [es:bx+4],80h
 20409 00003486 26F6470480              	test	byte [es:bx+SRHEAD.REQSTAT+1],STERR>>8 
 20410                                  	;test	word [es:bx+SRHEAD.REQSTAT],STERR ;check if error
 20411 0000348B 7413                    	jz	short check_busy	;no
 20412                                  
 20413 0000348D 1E                      	push	ds
 20414 0000348E 89FA                    	mov	dx,di
 20415                                  	;invoke charhard		;invoke int 24h handler
 20416 00003490 E8A61E                  	call	CHARHARD
 20417 00003493 89D7                    	mov	di,dx
 20418 00003495 08C0                    	or	al,al
 20419 00003497 745D                    	jz	short pop_done_read	;ignore by user, assume read done
 20420 00003499 3C03                    	cmp	al,3
 20421 0000349B 7448                    	jz	short devrderr		;user asked to fail
 20422 0000349D 1F                      	pop	ds
 20423 0000349E EBD7                    	jmp	short do_io		;user asked to retry
 20424                                  
 20425                                  check_busy:
 20426                                  	;test	word [es:bx+3],200h
 20427                                  	; 16/12/2022
 20428 000034A0 26F6470402              	test	byte [es:bx+SRHEAD.REQSTAT+1],02h
 20429                                  	;test	word [es:bx+SRHEAD.REQSTAT],0200h ;see if busy bit set
 20430 000034A5 7547                    	jnz	short no_char		;yes, no character available
 20431                                  
 20432                                  ;Character is available. Read in 1 character at a time until all characters
 20433                                  ;are read in or no character is available
 20434                                  
 20435 000034A7 26C6470204              	mov	byte [es:bx+2],DEVRD ; 4 ;command code is READ now
 20436 000034AC 26C747120100            	mov	word [es:bx+18],1	;change count to 1 character
 20437 000034B2 1E                      	push	ds
 20438 000034B3 36C536[9E05]            	lds	si,[ss:THISSFT]
 20439 000034B8 E81912                  	call	DEVIOCALL
 20440                                  
 20441 000034BB 89FA                    	mov	dx,di
 20442 000034BD B486                    	mov	ah,86h
 20443                                  	;mov	di,[es:bx+3]
 20444 000034BF 268B7F03                	mov	di,[es:bx+SRHEAD.REQSTAT] ;get returned status
 20445 000034C3 F7C70080                	test	di,STERR ; 8000h	;was there an error during read?
 20446 000034C7 7410                    	jz	short next_char		;no,read next character
 20447                                  
 20448                                  	;invoke	charhard		;invoke int 24h handler
 20449 000034C9 E86D1E                  	call	CHARHARD
 20450 000034CC 89D7                    	mov	di,dx			;restore di
 20451 000034CE 08C0                    	or	al,al			;
 20452 000034D0 7424                    	jz	short pop_done_read	;ignore by user,assume read is done
 20453 000034D2 3C03                    	cmp	al,3
 20454 000034D4 740F                    	jz	short devrderr		;user issued a 'fail',indicate error
 20455 000034D6 1F                      	pop	ds
 20456 000034D7 EB9E                    	jmp	short do_io		;user issued a retry
 20457                                  
 20458                                  next_char:
 20459 000034D9 1F                      	pop	ds
 20460 000034DA 89D7                    	mov	di,dx
 20461 000034DC 49                      	dec	cx			;decrement count
 20462 000034DD E318                    	jcxz	done_read		;all characters read in
 20463 000034DF 26FF470E                	inc	word [es:bx+14]		;update transfer address
 20464 000034E3 EB92                    	jmp	short do_io			;read next character in
 20465                                  
 20466                                  devrderr:
 20467 000034E5 5F                      	pop	di			;discard segment address
 20468 000034E6 36C43E[9E05]            	les	di,[ss:THISSFT]
 20469                                  	;transfer SET_ACC_ERR_DS	;indicate error
 20470 000034EB E96504                  	jmp     SET_ACC_ERR_DS
 20471                                  
 20472                                  no_char:
 20473                                  ;Since no character is available, we let win386 switch the VM out
 20474                                  
 20475 000034EE 50                      	push	ax
 20476 000034EF B484                    	mov	ah,84h	; Microsoft Networks - KEYBOARD BUSY LOOP
 20477 000034F1 CD2A                    	int	2Ah			;indicate idle to WIN386
 20478                                  
 20479                                  ;When control returns from WIN386, we continue the raw read
 20480                                  
 20481 000034F3 58                      	pop	ax
 20482 000034F4 EB81                    	jmp	do_io
 20483                                  
 20484                                  pop_done_read:
 20485 000034F6 1F                      	pop	ds
 20486                                  done_read:
 20487 000034F7 36033E[6C03]            	add	di,[ss:CALLSCNT] ; 19/05/2019
 20488                                  
 20489                                  	; 16/12/2022
 20490                                  
 20491                                  	;jmp	ENDRDDEVJ3	;jump back to normal DOS raw read exit
 20492                                  	;jmp	ENDRDDEV ; 04/05/2019
 20493                                  
 20494                                  	; 04/05/2019 - Retro DOS v4.0
 20495                                  ENDRDDEV:
 20496 000034FC 16                      	push	ss
 20497 000034FD 1F                      	pop	ds
 20498 000034FE EB1F                    	jmp	short endrddev1
 20499                                  
 20500                                  	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 20501                                  	;jmp	ENDRDDEVJ3	;jump back to normal DOS raw read exit
 20502                                  
 20503                                  TRANBUF:
 20504 00003500 AC                      	LODSB
 20505 00003501 AA                      	STOSB
 20506 00003502 3C0D                    	CMP	AL,c_CR ; 0Dh	; Check for carriage return
 20507 00003504 7503                    	JNZ	short NORMCH
 20508 00003506 C6040A                  	MOV	BYTE [SI],c_LF ; 0Ah
 20509                                  NORMCH:
 20510 00003509 3C0A                    	CMP	AL,c_LF ; 0Ah
 20511 0000350B E0F3                    	LOOPNZ	TRANBUF
 20512 0000350D 7507                    	JNZ	short ENDRDCON
 20513 0000350F 31F6                    	XOR	SI,SI		; Cause a new buffer to be read
 20514 00003511 E89FE1                  	call	OUTT		; Transmit linefeed
 20515 00003514 0C01                    	OR	AL,1		; Clear zero flag--not end of file
 20516                                  ENDRDCON:
 20517                                  ;hkn; SS is DOSDATA
 20518 00003516 16                      	push	ss
 20519 00003517 1F                      	pop	ds
 20520 00003518 E80CFE                  	CALL	SWAPBACK
 20521 0000351B 8936[2200]              	MOV	[CONTPOS],SI
 20522                                  
 20523                                  	; 16/12/2022
 20524                                  ;ENDRDDEV:
 20525                                  ;;hkn; SS is DOSDATA
 20526                                  ;	push	ss
 20527                                  ;	pop	ds
 20528                                  endrddev1:	; 04/05/2019
 20529 0000351F 893E[B805]              	MOV	[NEXTADD],DI
 20530 00003523 7509                    	JNZ	short SETSFTC 	; Zero set if Ctrl-Z found in input
 20531 00003525 C43E[9E05]              	LES	DI,[THISSFT]
 20532                                  	;and	byte [es:di+5],0BFh
 20533 00003529 26806505BF              	AND	BYTE [ES:DI+SF_ENTRY.sf_flags],~devid_device_EOF 
 20534                                  				; Mark as no more data available
 20535                                  SETSFTC:
 20536                                  	; 31/07/2019
 20537                                  	;call	SETSFT
 20538                                  	;retn
 20539 0000352E E9B604                  	jmp	SETSFT
 20540                                  
 20541                                  ; 16/12/2022
 20542                                  %if 0
 20543                                  	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 20544                                  ENDRDDEV:
 20545                                  ;hkn; SS is DOSDATA
 20546                                  	push	ss
 20547                                  	pop	ds
 20548                                  	MOV	[NEXTADD],DI
 20549                                  	JNZ	short SETSFTC 	; Zero set if Ctrl-Z found in input
 20550                                  	LES	DI,[THISSFT]
 20551                                  	;and	byte [es:di+5],0BFh
 20552                                  	AND	BYTE [ES:DI+SF_ENTRY.sf_flags],~devid_device_EOF 
 20553                                  				; Mark as no more data available
 20554                                  SETSFTC:
 20555                                  	;call	SETSFT
 20556                                  	;retn
 20557                                  	jmp	SETSFT	
 20558                                  %endif
 20559                                  
 20560                                  READCON:
 20561 00003531 E8F9FD                  	CALL	SWAPCON
 20562 00003534 8B36[2200]              	MOV	SI,[CONTPOS]
 20563 00003538 09F6                    	OR	SI,SI
 20564 0000353A 75C4                    	JNZ	short TRANBUF
 20565 0000353C 803E[7B02]80            	CMP	BYTE [CONBUF],128 ; 80h
 20566 00003541 7406                    	JZ	short GETBUF
 20567 00003543 C706[7B02]80FF          	MOV	WORD [CONBUF],0FF80H ; Set up 128-byte buffer with no template
 20568                                  GETBUF:
 20569 00003549 51                      	PUSH	CX
 20570 0000354A 06                      	PUSH	ES
 20571 0000354B 57                      	PUSH	DI
 20572                                  
 20573                                  ;hkn; CONBUF is in DOSDATA
 20574 0000354C BA[7B02]                	MOV	DX,CONBUF
 20575                                  
 20576 0000354F E8D4DE                  	call	_$STD_CON_STRING_INPUT	; Get input buffer
 20577 00003552 5F                      	POP	DI
 20578 00003553 07                      	POP	ES
 20579 00003554 59                      	POP	CX
 20580                                  
 20581                                  ;hkn; CONBUF is in DOSDATA
 20582 00003555 BE[7D02]                	MOV	SI,CONBUF+2
 20583                                  
 20584 00003558 803C1A                  	CMP	BYTE [SI],1AH	; Check for Ctrl-Z in first character
 20585 0000355B 75A3                    	JNZ	short TRANBUF
 20586 0000355D B01A                    	MOV	AL,1AH
 20587 0000355F AA                      	STOSB
 20588 00003560 4F                      	DEC	DI
 20589 00003561 B00A                    	MOV	AL,c_LF
 20590 00003563 E84DE1                  	call	OUTT		; Send linefeed
 20591 00003566 31F6                    	XOR	SI,SI
 20592 00003568 EBAC                    	JMP	short ENDRDCON ; 04/05/2019
 20593                                  
 20594                                  ; 24/07/2018 - Retro DOS v3.0
 20595                                  
 20596                                  ;Break	<DOS_WRITE -- MAIN WRITE ROUTINE AND DEVICE OUT ROUTINES>
 20597                                  ;---------------------------------------------------------------------------
 20598                                  ;
 20599                                  ; Procedure Name : DOS_WRITE
 20600                                  ;
 20601                                  ; Inputs:
 20602                                  ;	ThisSFT set to the SFT for the file being used
 20603                                  ;	[DMAADD] contains transfer address
 20604                                  ;	CX = No. of bytes to write
 20605                                  ; Function:
 20606                                  ;	Perform write operation
 20607                                  ;	NOTE: If CX = 0 on input, file is truncated or grown
 20608                                  ;		to current sf_position
 20609                                  ; Outputs:
 20610                                  ;    Carry clear
 20611                                  ;	SFT Position and cluster pointers updated
 20612                                  ;	CX = No. of bytes written
 20613                                  ;	ES:DI point to SFT
 20614                                  ;    Carry set
 20615                                  ;	AX is error code
 20616                                  ;	CX = 0
 20617                                  ;	ES:DI point to SFT
 20618                                  ; DS preserved, all other registers destroyed
 20619                                  ;---------------------------------------------------------------------------
 20620                                  
 20621                                  ;hkn; called from fcbio2.asm, handle.asm and dev.asm. DS is set up at this 
 20622                                  ;hkn; point to DOSDATA.
 20623                                  
 20624                                  ; 04/05/2019 - Retro DOS v4.0
 20625                                  ; DOSCODE:742Ch (MSDOS 6.21, MSDOS.SYS)
 20626                                  
 20627                                  ; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 20628                                  ; DOSCODE:7418h (MSDOS 5.0, MSDOS.SYS)
 20629                                  
 20630                                  DOS_WRITE:
 20631 0000356A C43E[9E05]              	LES	DI,[THISSFT]
 20632                                  	;mov	al,[ES:DI+2]
 20633 0000356E 268A4502                	MOV	AL,[ES:DI+SF_ENTRY.sf_mode]
 20634                                  	;and	al,0Fh
 20635 00003572 240F                    	AND	AL,access_mask
 20636                                  	;cmp	al,0
 20637 00003574 3C00                    	CMP	AL,open_for_read
 20638 00003576 7503                    	JNE	short Check_FCB_RO		 ;Is write or both
 20639                                  BadMode:
 20640 00003578 E9DA03                  	jmp	SET_ACC_ERR
 20641                                  
 20642                                  ; NOTE: The following check for writting to a Read Only File is performed
 20643                                  ;	    ONLY on FCBs!!!!
 20644                                  ;	We ALLOW writes to Read Only files via handles to allow a CREATE
 20645                                  ;	    of a read only file which can then be written to.
 20646                                  ;	This is OK because we are NOT ALLOWED to OPEN a RO file via handles
 20647                                  ;	    for writting, or RE-CREATE an EXISTING RO file via handles. Thus,
 20648                                  ;	    CREATing a NEW RO file, or RE-CREATing an existing file which
 20649                                  ;	    is NOT RO to be RO, via handles are the only times we can write
 20650                                  ;	    to a read-only file.
 20651                                  
 20652                                  Check_FCB_RO:
 20653                                  	;;test	word [es:di+2],8000h
 20654                                  	;TEST	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB
 20655                                  	;JZ	short WRITE_NO_MODE	; Not an FCB
 20656                                  	
 20657                                  	;test	byte [es:di+3],80h
 20658 0000357B 26F6450380              	TEST	byte [ES:DI+SF_ENTRY.sf_mode+1],(sf_isFCB>>8)
 20659 00003580 7407                    	JZ	short WRITE_NO_MODE	; Not an FCB
 20660                                  
 20661                                  	;test	byte [es:di+4],1
 20662 00003582 26F6450401              	TEST	byte [ES:DI+SF_ENTRY.sf_attr],attr_read_only
 20663 00003587 75EF                    	JNZ	short BadMode 		; Can't write to Read_Only files via FCB
 20664                                  WRITE_NO_MODE:
 20665 00003589 E8AA02                  	call	SETUP
 20666 0000358C E81DDD                  	call	IsSFTNet
 20667 0000358F 7406                    	JZ	short LOCAL_WRITE
 20668                                  
 20669                                  ;IF NOT Installed
 20670                                  ;	transfer NET_WRITE
 20671                                  ;ELSE
 20672                                  	;mov	ax,1109h
 20673 00003591 B80911                  	MOV	AX,(MultNET<<8)|9
 20674 00003594 CD2F                    	int	2Fh	; Multiplex - NETWORK REDIRECTOR - WRITE TO REMOTE FILE
 20675                                  			; ES:DI -> SFT
 20676                                  			; SFT DPB field -> DPB of drive containing file
 20677                                  			; CX = number of bytes, SS = DOS CS, SDA DTA field -> user buffer
 20678                                  			; Return: CF set on error, CX = bytes written
 20679 00003596 C3                      	retn
 20680                                  ;ENDIF
 20681                                  
 20682                                  LOCAL_WRITE:
 20683                                  	;;test	word [es:di+5],80h
 20684                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
 20685                                  	;jnz	short WRTDEV
 20686                                  
 20687                                  	;test	byte [es:di+5],80h
 20688 00003597 26F6450580              	TEST	byte [ES:DI+SF_ENTRY.sf_flags],devid_device ; Check for named device I/O
 20689 0000359C 756E                    	jnz	short WRTDEV
 20690                                  
 20691                                  	;mov	byte [EXTERR_LOCUS],2
 20692 0000359E C606[2303]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk
 20693 000035A3 E8B1DD                  	call	ECritDisk
 20694                                  
 20695 000035A6 E8F404                  	call	DISKWRITE
 20696                                  
 20697                                  	; 04/05/2019 - Retro DOS v4.0
 20698                                  
 20699                                  	; MSDOS 6.0
 20700                                  ; Extended Open
 20701 000035A9 7210                    	JC	short nocommit
 20702                                  	
 20703 000035AB C43E[9E05]              	LES	DI,[THISSFT]
 20704                                  	
 20705                                  	;;test	word [ES:DI+2],4000h
 20706                                  	;TEST	word [ES:DI+SF_ENTRY.sf_mode],AUTO_COMMIT_WRITE
 20707                                  	;JZ	short nocommit
 20708                                  	
 20709                                  	;test	byte [ES:DI+3],40h
 20710 000035AF 26F6450340              	TEST	byte [ES:DI+SF_ENTRY.sf_mode+1],(AUTO_COMMIT_WRITE>>8)
 20711 000035B4 7405                    	JZ	short nocommit
 20712                                  	
 20713 000035B6 51                      	PUSH	CX
 20714 000035B7 E82EFB                  	call	DOS_COMMIT
 20715 000035BA 59                      	POP	CX
 20716                                  nocommit:
 20717                                  ; Extended Open
 20718                                  	;call	LCritDisk
 20719                                  	;retn
 20720                                  	; 18/12/2022
 20721 000035BB E9B4DD                  	jmp	LCritDisk
 20722                                  
 20723                                  DVWRTRAW:
 20724 000035BE 31C0                    	XOR	AX,AX			; Media Byte, unit = 0
 20725 000035C0 E8BD11                  	call	SETWRITE
 20726 000035C3 1E                      	PUSH	DS			; Save seg of transfer
 20727                                  
 20728                                  ;hkn; SS override
 20729 000035C4 36C536[9E05]            	LDS	SI,[SS:THISSFT]
 20730 000035C9 E80811                  	call	DEVIOCALL		; DS:SI -> DEVICE
 20731                                  
 20732 000035CC 89FA                    	MOV	DX,DI			; Offset part of Xaddr saved in DX
 20733 000035CE B487                    	MOV	AH,87H
 20734                                  
 20735                                  ;hkn; SS override
 20736 000035D0 368B3E[5D03]            	MOV	DI,[SS:DEVCALL_REQSTAT]
 20737                                  
 20738                                  	; MSDOS 3.3
 20739                                  	;test	di,8000h
 20740                                  	;jz	short CWRTROK
 20741                                  
 20742                                  	; MSDOS 6.0
 20743 000035D5 09FF                    	or	di,di
 20744 000035D7 7920                    	jns	short CWRTROK
 20745                                  	
 20746                                  	; MSDOS 3.3 (& MSDOS 6.0)
 20747 000035D9 E85D1D                  	call	CHARHARD
 20748                                  
 20749                                  	; 04/05/2019  - Retro DOS v4.0
 20750                                  
 20751                                  	; MSDOS 6.0
 20752 000035DC 362B0E[6C03]            	sub	cx,[ss:CALLSCNT]	; update ptr & count to reflect	M065
 20753 000035E1 89D3                    	mov	bx,dx			; number of chars xferred	M065
 20754 000035E3 36031E[6C03]            	add	bx,[ss:CALLSCNT]	;				M065
 20755 000035E8 89DF                    	mov	di,bx			;				M065
 20756                                  	
 20757                                  	; MSDOS 3.3
 20758                                  	;MOV	BX,DX			; Recall transfer addr		M065
 20759                                  
 20760                                  	; MSDOS 3.3 (& MSDOS 6.0)
 20761 000035EA 08C0                    	OR	AL,AL
 20762 000035EC 740B                    	JZ	short CWRTROK 		; Ignore
 20763 000035EE 3C03                    	CMP	AL,3
 20764 000035F0 7403                    	JZ	short CWRFERR
 20765 000035F2 1F                      	POP	DS			; Recover saved seg of transfer
 20766 000035F3 EBC9                    	JMP	short DVWRTRAW		; Try again
 20767                                  CWRFERR:
 20768 000035F5 58                      	POP	AX			; Chuck saved seg of transfer
 20769 000035F6 E9F4FD                  	JMP	CRDFERR 		; Will pop one more stack element
 20770                                  CWRTROK:
 20771 000035F9 58                      	POP	AX			; Chuck saved seg of transfer
 20772 000035FA 1F                      	POP	DS
 20773 000035FB A1[6C03]                	MOV	AX,[CALLSCNT]		; Get actual number of bytes transferred
 20774                                  ENDWRDEV:
 20775 000035FE C43E[9E05]              	LES	DI,[THISSFT]
 20776 00003602 89C1                    	MOV	CX,AX
 20777                                  	;call	ADDREC
 20778                                  	;retn
 20779                                  	; 16/12/2022
 20780                                  	; 10/06/2019
 20781 00003604 E90104                  	jmp	ADDREC
 20782                                  	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 20783                                  	;call	ADDREC
 20784                                  	;retn
 20785                                  	
 20786                                  WRTNUL:
 20787 00003607 89CA                    	MOV	DX,CX			; Entire transfer done
 20788                                  WRTCOOKJ:
 20789 00003609 E98D00                  	JMP	WRTCOOKDONE
 20790                                  WRTDEV:
 20791                                  	;mov	byte [EXTERR_LOCUS],4
 20792 0000360C C606[2303]04            	MOV	byte [EXTERR_LOCUS],errLOC_SerDev
 20793                                  	;or	byte [es:di+5],40h
 20794 00003611 26804D0540              	OR	BYTE [ES:DI+SF_ENTRY.sf_flags],devid_device_EOF
 20795                                  					; Reset EOF for input
 20796                                  	;mov	bl,[es:di+5]
 20797 00003616 268A5D05                	MOV	BL,[ES:DI+SF_ENTRY.sf_flags]
 20798 0000361A 31C0                    	XOR	AX,AX
 20799 0000361C E3E0                    	JCXZ	ENDWRDEV		; problem of creating on a device.
 20800 0000361E 1E                      	PUSH	DS
 20801 0000361F 88D8                    	MOV	AL,BL
 20802 00003621 C51E[2C03]              	LDS	BX,[DMAADD]		; Xaddr to DS:BX
 20803 00003625 89DF                    	MOV	DI,BX			; Xaddr to DS:DI
 20804 00003627 31D2                    	XOR	DX,DX			; Set starting point
 20805                                  	;test	al,20h
 20806 00003629 A820                    	test	AL,devid_device_raw	; Raw?
 20807                                  	;JZ	short TEST_DEV_CON
 20808                                  	;JMP	DVWRTRAW
 20809                                  	; 16/12/2022
 20810 0000362B 7591                    	jnz	short DVWRTRAW
 20811                                  	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 20812                                  	;JZ	short TEST_DEV_CON
 20813                                  	;JMP	short DVWRTRAW
 20814                                  
 20815                                  TEST_DEV_CON:
 20816                                  	;test	al,2
 20817 0000362D A802                    	test	AL,devid_device_con_out ; Console output device?
 20818 0000362F 756E                    	jnz	short WRITECON
 20819                                  	;test	al,4
 20820 00003631 A804                    	test	AL,devid_device_null
 20821 00003633 75D2                    	JNZ	short WRTNUL
 20822 00003635 89D0                    	MOV	AX,DX
 20823 00003637 803F1A                  	CMP	BYTE [BX],1Ah		; ^Z?
 20824 0000363A 74CD                    	JZ	short WRTCOOKJ		; Yes, transfer nothing
 20825 0000363C 51                      	PUSH	CX
 20826 0000363D B90100                  	MOV	CX,1
 20827 00003640 E83D11                  	call	SETWRITE
 20828 00003643 59                      	POP	CX
 20829                                  
 20830                                  ;hkn; SS override
 20831 00003644 36C536[9E05]            	LDS	SI,[SS:THISSFT]
 20832                                  ;
 20833                                  ;SR; Removed X25 support from here
 20834                                  ;
 20835                                  	;lds	si,[si+7]
 20836 00003649 C57407                  	LDS	SI,[SI+SF_ENTRY.sf_devptr]
 20837                                  DVWRTLP:
 20838 0000364C E8CB1A                  	call	DSKSTATCHK
 20839 0000364F E88510                  	call	DEVIOCALL2
 20840 00003652 57                      	PUSH	DI
 20841 00003653 B487                    	MOV	AH,87H
 20842                                  
 20843                                  ;hkn; SS override
 20844 00003655 368B3E[5D03]            	MOV	DI,[SS:DEVCALL_REQSTAT]
 20845                                  	
 20846                                  	; MSDOS 3.3
 20847                                  	;test	di,8000h
 20848                                  	;jz	short CWROK
 20849                                  
 20850                                  	; MSDOS 6.0
 20851 0000365A 09FF                    	or	di,di
 20852 0000365C 7916                    	jns	short CWROK
 20853                                  	
 20854                                  	; MSDOS 3.3 (& MSDOS 6.0)
 20855 0000365E E8D81C                  	call	CHARHARD
 20856 00003661 5F                      	POP	DI
 20857                                  
 20858                                  ;hkn; SS override
 20859 00003662 36C706[6C03]0100        	MOV	word [SS:CALLSCNT],1
 20860 00003669 3C01                    	CMP	AL,1
 20861 0000366B 74DF                    	JZ	short DVWRTLP 	; Retry
 20862 0000366D 08C0                    	OR	AL,AL
 20863 0000366F 740C                    	JZ	short DVWRTIGN	; Ignore
 20864                                  	; 10/08/2018
 20865 00003671 E979FD                  	JMP	CRDFERR 	; Fail, pops one stack element
 20866                                  CWROK:
 20867 00003674 5F                      	POP	DI
 20868                                  
 20869                                  ;hkn; SS override
 20870 00003675 36833E[6C03]00          	CMP	word [SS:CALLSCNT],0
 20871 0000367B 741C                    	JZ	short WRTCOOKDONE
 20872                                  DVWRTIGN:
 20873 0000367D 42                      	INC	DX
 20874                                  
 20875                                  ;hkn; SS override for CALLXAD
 20876 0000367E 36FF06[6803]            	INC	WORD [SS:CALLXAD]
 20877 00003683 47                      	INC	DI
 20878 00003684 1E                      	PUSH	DS
 20879 00003685 368E1E[6A03]            	MOV	DS,[SS:CALLXAD+2]
 20880 0000368A 803D1A                  	CMP	BYTE [DI],1Ah	; ^Z?
 20881 0000368D 1F                      	POP	DS
 20882 0000368E 7409                    	JZ	short WRTCOOKDONE
 20883                                  
 20884                                  ;hkn; SS override
 20885 00003690 36C706[5D03]0000        	MOV	word [SS:DEVCALL_REQSTAT],0
 20886 00003697 E2B3                    	LOOP	DVWRTLP
 20887                                  WRTCOOKDONE:
 20888 00003699 89D0                    	MOV	AX,DX
 20889 0000369B 1F                      	POP	DS
 20890 0000369C E95FFF                  	JMP	ENDWRDEV ; 10/08/2018
 20891                                  
 20892                                  WRITECON:
 20893 0000369F 1E                      	PUSH	DS
 20894                                  
 20895                                  ;hkn; SS is DOSDATA
 20896 000036A0 16                      	push	ss
 20897 000036A1 1F                      	pop	ds
 20898 000036A2 E888FC                  	CALL	SWAPCON
 20899 000036A5 1F                      	POP	DS
 20900 000036A6 89DE                    	MOV	SI,BX
 20901 000036A8 51                      	PUSH	CX
 20902                                  WRCONLP:
 20903 000036A9 AC                      	LODSB
 20904 000036AA 3C1A                    	CMP	AL,1Ah		; ^Z?
 20905 000036AC 7405                    	JZ	short CONEOF
 20906 000036AE E802E0                  	call	OUTT
 20907 000036B1 E2F6                    	LOOP	WRCONLP
 20908                                  CONEOF:
 20909 000036B3 58                      	POP	AX			; Count
 20910 000036B4 29C8                    	SUB	AX,CX			; Amount actually written
 20911 000036B6 1F                      	POP	DS
 20912 000036B7 E86DFC                  	CALL	SWAPBACK
 20913 000036BA E941FF                  	JMP	ENDWRDEV
 20914                                  
 20915                                  ;---------------------------------------------------------------------------
 20916                                  ;
 20917                                  ; Procedure Name : get_io_sft
 20918                                  ;
 20919                                  ;   Convert JFN number in BX to sf_entry in DS:SI We get the normal SFT if
 20920                                  ;   CONSWAP is FALSE or if the handle desired is 2 or more. Otherwise, we
 20921                                  ;   retrieve the sft from ConSFT which is set by SwapCon.
 20922                                  ;
 20923                                  ;---------------------------------------------------------------------------
 20924                                  
 20925                                  ; 04/05/2019 - Retro DOS v4.0
 20926                                  ; DOSCODE:7583h (MSDOS 6.21, MSDOS.SYS)
 20927                                  ; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 20928                                  ; DOSCODE:756Fh (MSDOS 5.0, MSDOS.SYS)
 20929                                  
 20930                                  GET_IO_SFT:
 20931                                  	;test	byte [SS:CONSWAP],0FFh
 20932 000036BD 36803E[5703]00          	cmp	byte [SS:CONSWAP],0			;smr;SS Override
 20933 000036C3 7512                    	JNZ	short GetRedir
 20934                                  GetNormal:
 20935 000036C5 16                      	push	ss
 20936 000036C6 1F                      	pop	ds
 20937 000036C7 06                      	PUSH	ES
 20938 000036C8 57                      	PUSH	DI
 20939 000036C9 E81430                  	call	SFFromHandle
 20940 000036CC 7206                    	JC	short RET44P
 20941 000036CE 8CC6                    	MOV	SI,ES
 20942 000036D0 8EDE                    	MOV	DS,SI
 20943 000036D2 89FE                    	MOV	SI,DI
 20944                                  RET44P:
 20945 000036D4 5F                      	POP	DI
 20946 000036D5 07                      	POP	ES
 20947 000036D6 C3                      	retn
 20948                                  GetRedir:
 20949 000036D7 83FB01                  	CMP	BX,1
 20950 000036DA 77E9                    	JA	short GetNormal
 20951 000036DC 36C536[E605]            	LDS	SI,[SS:CONSFT]
 20952 000036E1 F8                      	CLC
 20953                                  get_io_sft_retn:
 20954 000036E2 C3                      	retn
 20955                                  
 20956                                  ;Break	<DIRREAD -- READ A DIRECTORY SECTOR>
 20957                                  ;---------------------------------------------------------------------------
 20958                                  ;
 20959                                  ; Procedure Name : DIRREAD
 20960                                  ;
 20961                                  ; Inputs:
 20962                                  ;	AX = Directory block number (relative to first block of directory)
 20963                                  ;	ES:BP = Base of drive parameters
 20964                                  ;	[DIRSEC] = First sector of first cluster of directory
 20965                                  ;	[CLUSNUM] = Next cluster
 20966                                  ;	[CLUSFAC] = Sectors/Cluster
 20967                                  ; Function:
 20968                                  ;	Read the directory block into [CURBUF].
 20969                                  ; Outputs:
 20970                                  ;	[NXTCLUSNUM] = Next cluster (after the one skipped to)
 20971                                  ;	[SECCLUSPOS] Set
 20972                                  ;	ES:BP unchanged
 20973                                  ;	[CURBUF] Points to Buffer with dir sector
 20974                                  ;	Carry set if error (user said FAIL to I 24)
 20975                                  ; DS preserved, all other registers destroyed.
 20976                                  ;---------------------------------------------------------------------------
 20977                                  
 20978                                  ;hkn; called from dir.asm. DS already set up to DOSDATA.
 20979                                  
 20980                                  DIRREAD:
 20981                                  
 20982                                  ; Note that ClusFac is the sectors per cluster. This is NOT necessarily
 20983                                  ; the same as what is in the DPB! In the case of the root directory, we have
 20984                                  ; ClusFac = # sectors in the root directory. The root directory is detected
 20985                                  ; by DIRStart = 0.
 20986                                  
 20987 000036E3 31D2                    	XOR	DX,DX
 20988                                  	;CMP	word [DIRSTART],0
 20989                                  	; 21/09/2023
 20990 000036E5 3916[C205]              	cmp	[DIRSTART],dx ; 0
 20991 000036E9 7503                    	jnz	short SubDir
 20992 000036EB 92                      	XCHG	AX,DX
 20993 000036EC EB0C                    	JMP	short DoRead
 20994                                  
 20995                                  ; Convert the sector number in AX into cluster and sector-within-cluster pair
 20996                                  
 20997                                  SubDir:
 20998 000036EE 88C2                    	MOV	DL,AL
 20999                                  	;and	dl,[es:bp+4]
 21000 000036F0 26225604                	AND	DL,[ES:BP+DPB.CLUSTER_MASK]
 21001                                  
 21002                                  ;	(DX) = sector-in-cluster
 21003                                  
 21004                                  	;mov	cl,[es:bp+5]
 21005 000036F4 268A4E05                	MOV	CL,[ES:BP+DPB.CLUSTER_SHIFT]
 21006 000036F8 D3E8                    	SHR	AX,CL
 21007                                  
 21008                                  ;	(DX) = position in cluster
 21009                                  ;	(AX) = number of clusters to skip
 21010                                  
 21011                                  DoRead:
 21012 000036FA 8816[7305]              	MOV	[SECCLUSPOS],DL
 21013 000036FE 89C1                    	MOV	CX,AX
 21014 00003700 88D4                    	MOV	AH,DL
 21015                                  
 21016                                  ;	(CX) = number of clusters to skip.
 21017                                  ;	(AH) = remainder
 21018                                  
 21019                                  	; 04/05/2019 - Retro DOS v4.0
 21020                                  	 
 21021                                  	; MSDOS 6.0
 21022                                  	;MOV	DX,[DIRSEC+2]	     	  ;>32mb
 21023                                  	;MOV	[HIGH_SECTOR],DX	  ;>32mb
 21024                                  	;MOV	DX,[DIRSEC]
 21025                                  	;ADD	DL,AH
 21026                                  	;ADC	DH,0
 21027                                  	;ADC	word [HIGH_SECTOR],0	  ;>32mb
 21028                                  	; 21/09/2023
 21029 00003702 31DB                    	xor	bx,bx ; 0
 21030 00003704 8B16[BE05]              	mov	dx,[DIRSEC]
 21031 00003708 00E2                    	add	dl,ah
 21032 0000370A 10DE                    	adc	dh,bl ; 0
 21033 0000370C 131E[C005]              	adc	bx,[DIRSEC+2]
 21034 00003710 891E[0706]              	mov	[HIGH_SECTOR],bx
 21035                                  
 21036 00003714 8B1E[BC05]              	MOV	BX,[CLUSNUM]
 21037 00003718 891E[DC05]              	MOV	[NXTCLUSNUM],BX
 21038 0000371C E319                    	JCXZ	FIRSTCLUSTER
 21039                                  SKPCLLP:
 21040 0000371E E8831E                  	call	UNPACK
 21041 00003721 72BF                    	jc	short get_io_sft_retn
 21042 00003723 87DF                    	XCHG	BX,DI
 21043 00003725 E8651E                  	call	IsEOF			; test for eof based on fat size
 21044 00003728 7302                    	JAE	short HAVESKIPPED
 21045 0000372A E2F2                    	LOOP	SKPCLLP
 21046                                  HAVESKIPPED:
 21047 0000372C 891E[DC05]              	MOV	[NXTCLUSNUM],BX
 21048 00003730 89FA                    	MOV	DX,DI
 21049 00003732 88E3                    	MOV	BL,AH
 21050 00003734 E81617                  	call	FIGREC
 21051                                  
 21052                                  	;entry	FIRSTCLUSTER
 21053                                  
 21054                                  FIRSTCLUSTER:
 21055                                  	; 22/09/2023
 21056                                  	;;mov	byte [ALLOWED],18h
 21057                                  	;MOV	byte [ALLOWED],Allowed_RETRY+Allowed_FAIL ; *
 21058                                  	;XOR	AL,AL ; *	; Indicate pre-read
 21059                                  	;call	GETBUFFR
 21060 00003737 E87C22                  	call	GETBUFFER ; *	; pre-read
 21061 0000373A 72A6                    	jc	short get_io_sft_retn
 21062                                  
 21063                                  	;entry	SET_BUF_AS_DIR
 21064                                  
 21065                                  SET_BUF_AS_DIR:
 21066                                  
 21067                                  ;	Set the type of CURBUF to be a directory sector.
 21068                                  ;	Only flags are modified.
 21069                                  
 21070 0000373C 1E                      	PUSH	DS
 21071 0000373D 56                      	PUSH	SI
 21072 0000373E C536[E205]              	LDS	SI,[CURBUF]
 21073                                  	;or	byte [si+5],4
 21074 00003742 804C0504                	OR	byte [SI+BUFFINFO.buf_flags],buf_isDIR	; Clears carry
 21075 00003746 5E                      	POP	SI
 21076 00003747 1F                      	POP	DS
 21077                                  dirread_retn:
 21078 00003748 C3                      	retn
 21079                                  
 21080                                  ;Break	<FATSECRD -- READ A FAT SECTOR>
 21081                                  ;----------------------------------------------------------------------------
 21082                                  ;
 21083                                  ; Procedure Name : FATSECRD
 21084                                  ; Inputs:
 21085                                  ;	Same as DREAD
 21086                                  ;	DS:BX = Transfer address
 21087                                  ;	CX = Number of sectors
 21088                                  ;	DX = Absolute record number
 21089                                  ;	ES:BP = Base of drive parameters
 21090                                  ; Function:
 21091                                  ;	Calls BIOS to perform FAT read.
 21092                                  ; Outputs:
 21093                                  ;	Same as DREAD
 21094                                  ;---------------------------------------------------------------------------
 21095                                  
 21096                                  	; 04/05/2019 - Retro DOS v4.0
 21097                                  	; 18/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)	
 21098                                  
 21099                                  FATSECRD:
 21100                                  ;hkn; SS override
 21101                                  	;mov	byte [ss:ALLOWED],18h
 21102 00003749 36C606[4B03]18          	MOV	byte [SS:ALLOWED],Allowed_RETRY+Allowed_FAIL
 21103 0000374F 89CF                    	MOV	DI,CX
 21104                                  	;mov	cl,[es:bp+8]
 21105 00003751 268A4E08                	MOV	CL,[ES:BP+DPB.FAT_COUNT]
 21106                                  	; MSDOS 3.3
 21107                                  	;;mov	al,[es:bp+0Fh]
 21108                                  	;MOV	AL,[ES:BP+DPB.FAT_SIZE] 				
 21109                                  	;XOR	AH,AH
 21110                                  	; MSDOS 6.0
 21111                                  	;mov	ax,[es:bp+0Fh]
 21112 00003755 268B460F                	MOV	AX,[ES:BP+DPB.FAT_SIZE] ;>32mb
 21113 00003759 30ED                    	XOR	CH,CH	
 21114 0000375B 52                      	PUSH	DX
 21115                                  NXTFAT:
 21116                                  	; MSDOS 6.0
 21117                                  ;hkn; SS override
 21118 0000375C 36C706[0706]0000        	MOV	word [SS:HIGH_SECTOR],0	;>32mb FAT sectors cannot exceed
 21119 00003763 51                      	PUSH	CX			;32mb
 21120 00003764 50                      	PUSH	AX
 21121 00003765 89F9                    	MOV	CX,DI
 21122 00003767 E85B00                  	call	DSKREAD
 21123 0000376A 58                      	POP	AX
 21124 0000376B 59                      	POP	CX
 21125 0000376C 7420                    	JZ	short RET41P		; Carry clear
 21126 0000376E 01C2                    	ADD	DX,AX
 21127 00003770 E2EA                    	LOOP	NXTFAT
 21128 00003772 5A                      	POP	DX
 21129 00003773 89F9                    	MOV	CX,DI
 21130                                  
 21131                                  ; NOTE FALL THROUGH
 21132                                  
 21133                                  ;Break	<DREAD -- DO A DISK READ>
 21134                                  ;---------------------------------------------------------------------------
 21135                                  ;
 21136                                  ; Procedure Name : DREAD
 21137                                  ;
 21138                                  ; Inputs:
 21139                                  ;	DS:BX = Transfer address
 21140                                  ;	CX = Number of sectors
 21141                                  ;	DX = Absolute record number	      (LOW)
 21142                                  ;	[HIGH_SECTOR] = Absolute record number (HIGH)
 21143                                  ;	ES:BP = Base of drive parameters
 21144                                  ;	[ALLOWED] must be set in case call to HARDERR needed
 21145                                  ; Function:
 21146                                  ;	Calls BIOS to perform disk read. If BIOS reports
 21147                                  ;	errors, will call HARDERRRW for further action.
 21148                                  ; Outputs:
 21149                                  ;	Carry set if error (currently user FAILED to INT 24)
 21150                                  ; DS,ES:BP preserved. All other registers destroyed.
 21151                                  ;---------------------------------------------------------------------------
 21152                                  
 21153                                  	;entry	DREAD
 21154                                  DREAD:
 21155 00003775 E84D00                  	call	DSKREAD
 21156 00003778 74CE                    	jz	short dirread_retn	; Carry clear
 21157                                  ;hkn; SS override
 21158 0000377A 36C606[7505]00          	MOV	BYTE [SS:READOP],0
 21159 00003780 E89A00                  	call	HARDERRRW
 21160 00003783 3C01                    	CMP	AL,1			; Check for retry
 21161 00003785 74EE                    	JZ	short DREAD
 21162 00003787 3C03                    	CMP	AL,3			; Check for FAIL
 21163 00003789 F8                      	CLC
 21164 0000378A 7501                    	JNZ	short NO_CAR		; Ignore
 21165 0000378C F9                      	STC
 21166                                  NO_CAR:
 21167 0000378D C3                      	retn
 21168                                  RET41P: 
 21169 0000378E 5A                      	POP	DX
 21170 0000378F C3                      	retn
 21171                                  
 21172                                  ; 24/07/2018 - Retro DOS v3.0
 21173                                  
 21174                                  ;Break	<CHECK_WRITE_LOCK>
 21175                                  ;---------------------------------------------------------------------------
 21176                                  ;
 21177                                  ; Procedure Name : CHECK_WRITE_LOCK
 21178                                  ;
 21179                                  ; Inputs:
 21180                                  ;	output of SETUP
 21181                                  ;	ES:DI -> SFT
 21182                                  ; Function:
 21183                                  ;	check write lock
 21184                                  ; Outputs:
 21185                                  ;	Carry set if error
 21186                                  ;	Carry clear if ok
 21187                                  ;
 21188                                  ;----------------------------------------------------------------------------
 21189                                  
 21190                                  	; 04/05/2019 - Retro DOS v4.0
 21191                                  	; 18/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 21192                                  
 21193                                  CHECK_WRITE_LOCK:
 21194                                  	; MSDOS 6.0
 21195                                  	;test	byte [es:di+4],8
 21196 00003790 26F6450408              	TEST	byte [ES:DI+SF_ENTRY.sf_attr],attr_volume_id ;volume id
 21197                                  	;JZ	short write_cont			     ;no
 21198                                  	;;call	SET_ACC_ERR_DS
 21199                                  	;;retn
 21200                                  	;;jnz	SET_ACC_ERR_DS
 21201                                  	; 19/08/2018
 21202                                  	;jz	short write_cont
 21203                                  	;jmp	SET_ACC_ERR_DS
 21204                                  	; 18/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 21205 00003795 7403                    	JZ	short write_cont
 21206                                  	;call	SET_ACC_ERR_DS
 21207                                  	;retn
 21208                                  	; 16/12/2022
 21209 00003797 E9B901                  	jmp	SET_ACC_ERR_DS
 21210                                  
 21211                                  write_cont:				;
 21212 0000379A 51                      	PUSH	CX			;save reg
 21213 0000379B 09C9                    	OR	CX,CX			;
 21214 0000379D 7501                    	JNZ	short Not_Truncate	;
 21215 0000379F 49                      	dec	cx			;(cx) = -1; check for lock on whole file
 21216                                  Not_Truncate:				;
 21217 000037A0 B080                    	MOV	AL,80H			;check write access
 21218 000037A2 E8C43B                  	call	LOCK_CHECK		;check lock
 21219 000037A5 59                      	POP	CX			;restore reg
 21220 000037A6 7305                    	JNC	short WRITE_OK		;lock ok
 21221 000037A8 E85F01                  	call	WRITE_LOCK_VIOLATION	;issue I24
 21222 000037AB 73ED                    	JNC	short write_cont	;retry
 21223                                  WRITE_OK:				;
 21224 000037AD C3                      	retn				;
 21225                                  
 21226                                  ;Break	<CHECK_READ_LOCK>
 21227                                  ;---------------------------------------------------------------------------
 21228                                  ;
 21229                                  ; Procedure Name : CHECK_READ_LOC
 21230                                  ;
 21231                                  ; Inputs:
 21232                                  ;	ES:DI -> SFT
 21233                                  ;	output of SETUP
 21234                                  ; Function:
 21235                                  ;	check read lock
 21236                                  ; Outputs:
 21237                                  ;	Carry set if error
 21238                                  ;	Carry clear if ok
 21239                                  ;----------------------------------------------------------------------------
 21240                                  
 21241                                  CHECK_READ_LOCK:
 21242                                  	; MSDOS 6.0
 21243                                  	;test	byte [es:di+4],8
 21244 000037AE 26F6450408              	TEST	byte [ES:DI+SF_ENTRY.sf_attr],attr_volume_id ;volume id
 21245                                  	;JZ	short do_retry			   	     ; no
 21246                                  	;;call	SET_ACC_ERR
 21247                                  	;;retn
 21248                                  	;;jnz	SET_ACC_ERR
 21249                                  	; 16/12/2022
 21250                                  	; 28/07/2019
 21251 000037B3 7403                    	jz	short do_retry
 21252 000037B5 E99D01                  	jmp	SET_ACC_ERR
 21253                                  	; 18/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 21254                                  	;JZ	short do_retry
 21255                                  	;call	SET_ACC_ERR
 21256                                  	;retn
 21257                                  do_retry:				;
 21258 000037B8 30C0                    	xor	al,al			;check read access
 21259 000037BA E8AC3B                  	call	LOCK_CHECK		;check lock
 21260 000037BD 7305                    	JNC	short READLOCK_OK 	;lock ok
 21261 000037BF E82801                  	call	READ_LOCK_VIOLATION	;issue I24
 21262 000037C2 73F4                    	JNC	short do_retry		;retry
 21263                                  READLOCK_OK:				;
 21264 000037C4 C3                      	retn				;
 21265                                  
 21266                                  ;============================================================================
 21267                                  ; DISK2.ASM, MSDOS 6.0, 1991
 21268                                  ;============================================================================
 21269                                  ; 24/07/2018 - Retro DOS v3.0
 21270                                  ; 04/05/2019 - Retro DOS v4.0
 21271                                  
 21272                                  ;	TITLE	DISK2 - Disk utility routines
 21273                                  ;	NAME	Disk2
 21274                                  
 21275                                  ;**	Low level Read and write routines for local SFT I/O on files and devs
 21276                                  ;
 21277                                  ;	DskRead
 21278                                  ;	DWRITE
 21279                                  ;	DSKWRITE
 21280                                  ;	HarderrRW
 21281                                  ;	SETUP
 21282                                  ;	BREAKDOWN
 21283                                  ;	READ_LOCK_VIOLATION
 21284                                  ;	WRITE_LOCK_VIOLATION
 21285                                  ;	DISKREAD
 21286                                  ;	SET_ACC_ERR_DS
 21287                                  ;	SET_ACC_ERR
 21288                                  ;	SETSFT
 21289                                  ;	SETCLUS
 21290                                  ;	AddRec
 21291                                  ;
 21292                                  ;	Revision history:
 21293                                  ;
 21294                                  ;		AN000 version 4.00 Jan. 1988
 21295                                  ;		M039 DB 10/17/90 - Disk read/write optimization
 21296                                  
 21297                                  ; 04/05/2019 - Retro DOS v4.0
 21298                                  ; DOSCODE:7699h (MSDOS 6.21, MSDOS.SYS)
 21299                                  ; 18/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 21300                                  ; DOSCODE:7685h (MSDOS 5.0, MSDOS.SYS)
 21301                                  
 21302                                  ;Break	<DSKREAD -- PHYSICAL DISK READ>
 21303                                  ;---------------------------------------------------------------------------
 21304                                  ;
 21305                                  ; Procedure Name : DSKREAD
 21306                                  ;
 21307                                  ; Inputs:
 21308                                  ;	DS:BX = Transfer addr
 21309                                  ;	CX = Number of sectors
 21310                                  ;	[HIGH_SECTOR] = Absolute record number (HIGH)
 21311                                  ;	DX = Absolute record number	       (LOW)
 21312                                  ;	ES:BP = Base of drive parameters
 21313                                  ; Function:
 21314                                  ;	Call BIOS to perform disk read
 21315                                  ; Outputs:
 21316                                  ;	DI = CX on entry
 21317                                  ;	CX = Number of sectors unsuccessfully transfered
 21318                                  ;	AX = Status word as returned by BIOS (error code in AL if error)
 21319                                  ;	Zero set if OK (from BIOS) (carry clear)
 21320                                  ;	Zero clear if error (carry clear)
 21321                                  ; SI Destroyed, others preserved
 21322                                  ;---------------------------------------------------------------------------
 21323                                  
 21324                                  DSKREAD:
 21325 000037C5 51                      	PUSH	CX
 21326                                  	;mov	ah,[es:bp+17h] ; 04/05/2019
 21327 000037C6 268A6617                	MOV	AH,[ES:BP+DPB.MEDIA]
 21328                                  	;mov	al,[es:bp+1]
 21329 000037CA 268A4601                	MOV	AL,[ES:BP+DPB.UNIT]
 21330 000037CE 53                      	PUSH	BX
 21331 000037CF 06                      	PUSH	ES
 21332 000037D0 E87A0F                  	call	SETREAD
 21333 000037D3 EB27                    	JMP	short DODSKOP
 21334                                  
 21335                                  ;Break	<DWRITE -- SEE ABOUT WRITING>
 21336                                  ;--------------------------------------------------------------------------
 21337                                  ;
 21338                                  ; Procedure Name : DWRITE
 21339                                  ;
 21340                                  ; Inputs:
 21341                                  ;	DS:BX = Transfer address
 21342                                  ;	CX = Number of sectors
 21343                                  ;	[HIGH_SECTOR] = Absolute record number (HIGH)
 21344                                  ;	DX = Absolute record number	       (LOW)
 21345                                  ;	ES:BP = Base of drive parameters
 21346                                  ;	[ALLOWED] must be set in case HARDERR called
 21347                                  ; Function:
 21348                                  ;	Calls BIOS to perform disk write. If BIOS reports
 21349                                  ;	errors, will call HARDERRRW for further action.
 21350                                  ; Output:
 21351                                  ;	Carry set if error (currently, user FAILed to I 24)
 21352                                  ; BP preserved. All other registers destroyed.
 21353                                  ;----------------------------------------------------------------------------
 21354                                  
 21355                                  	;entry	DWRITE
 21356                                  DWRITE:
 21357 000037D5 E81600                  	CALL	DSKWRITE
 21358 000037D8 7413                    	jz	short dw_ret_label	; Carry clear (retz)
 21359                                  
 21360                                  ;hkn; SS override
 21361 000037DA 36C606[7505]01          	MOV	BYTE [SS:READOP],1
 21362 000037E0 E83A00                  	call	HARDERRRW
 21363 000037E3 3C01                    	CMP	AL,1		; Check for retry
 21364 000037E5 74EE                    	JZ	short DWRITE
 21365 000037E7 3C03                    	CMP	AL,3		; Check for FAIL
 21366 000037E9 F8                      	CLC
 21367 000037EA 7501                    	JNZ	short NO_CAR2 	; Ignore
 21368 000037EC F9                      	STC
 21369                                  NO_CAR2:
 21370                                  dw_ret_label:
 21371 000037ED C3                      	retn
 21372                                  
 21373                                  ;Break	<DSKWRITE -- PHYSICAL DISK WRITE>
 21374                                  ;---------------------------------------------------------------------------
 21375                                  ;
 21376                                  ; Procedure Name : DSKWRITE
 21377                                  ;
 21378                                  ; Inputs:
 21379                                  ;	DS:BX = Transfer addr
 21380                                  ;	CX = Number of sectors
 21381                                  ;	DX = Absolute record number	       (LOW)
 21382                                  ;	[HIGH_SECTOR] = Absolute record number (HIGH)
 21383                                  ;	ES:BP = Base of drive parameters
 21384                                  ; Function:
 21385                                  ;	Call BIOS to perform disk read
 21386                                  ; Outputs:
 21387                                  ;	DI = CX on entry
 21388                                  ;	CX = Number of sectors unsuccessfully transfered
 21389                                  ;	AX = Status word as returned by BIOS (error code in AL if error)
 21390                                  ;	Zero set if OK (from BIOS) (carry clear)
 21391                                  ;	Zero clear if error (carry clear)
 21392                                  ; SI Destroyed, others preserved
 21393                                  ;
 21394                                  ;----------------------------------------------------------------------------
 21395                                  
 21396                                  	;entry	DSKWRITE
 21397                                  DSKWRITE:
 21398 000037EE 51                      	PUSH	CX
 21399                                  	;mov	ah,[es:bp+17h] ; 04/05/2019
 21400 000037EF 268A6617                	MOV	AH,[ES:BP+DPB.MEDIA]
 21401                                  	;mov	al,[es:bp+1]
 21402 000037F3 268A4601                	MOV	AL,[ES:BP+DPB.UNIT]
 21403 000037F7 53                      	PUSH	BX
 21404 000037F8 06                      	PUSH	ES
 21405 000037F9 E8840F                  	call	SETWRITE
 21406                                  DODSKOP:
 21407 000037FC 8CD9                    	MOV	CX,DS		; Save DS
 21408 000037FE 1F                      	POP	DS		; DS:BP points to DPB
 21409 000037FF 1E                      	PUSH	DS
 21410                                  
 21411                                  	;lds	si,[ds:bp+13h] ; 04/05/2019
 21412 00003800 3EC57613                	LDS	SI,[ds:BP+DPB.DRIVER_ADDR] ; 07/09/2018
 21413 00003804 E8D00E                  	call	DEVIOCALL2
 21414                                  
 21415 00003807 8ED9                    	MOV	DS,CX		; Restore DS
 21416 00003809 07                      	POP	ES		; Restore ES
 21417 0000380A 5B                      	POP	BX
 21418                                  
 21419                                  ;hkn; SS override
 21420 0000380B 368B0E[6C03]            	MOV	CX,[SS:CALLSCNT] ; Number of sectors transferred
 21421 00003810 5F                      	POP	DI
 21422 00003811 29F9                    	SUB	CX,DI
 21423 00003813 F7D9                    	NEG	CX		; Number of sectors not transferred
 21424                                  
 21425                                  ;hkn; SS override
 21426 00003815 36A1[5D03]              	MOV	AX,[SS:DEVCALL_REQSTAT]
 21427                                  	;test	ax,8000h
 21428                                  	; 17/12/2022
 21429                                  	;test	ah,80h
 21430 00003819 F6C480                  	test	ah,(STERR>>8)
 21431                                  	;test	AX,STERR
 21432 0000381C C3                      	retn
 21433                                  
 21434                                  ;Break	<HardErrRW - map extended errors and call harderr>
 21435                                  ;---------------------------------------------------------------------------
 21436                                  ;
 21437                                  ; Procedure Name : HardErrRW
 21438                                  ;
 21439                                  ; Inputs:
 21440                                  ;	AX is error code from read or write
 21441                                  ;	Other registers set as per HARDERR
 21442                                  ; Function:
 21443                                  ;	Checks the error code for special extended
 21444                                  ;	errors and maps them if needed. Then invokes
 21445                                  ;	Harderr
 21446                                  ; Outputs:
 21447                                  ;	Of HARDERR
 21448                                  ; AX may be modified prior to call to HARDERR.
 21449                                  ; No other registers altered.
 21450                                  ;
 21451                                  ;---------------------------------------------------------------------------
 21452                                  
 21453                                  	; 18/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 21454                                  HARDERRRW:
 21455                                  	;cmp	al,0Fh
 21456 0000381D 3C0F                    	CMP	AL,error_I24_wrong_disk
 21457 0000381F 7512                    	JNZ	short DO_ERR				; Nothing to do
 21458                                  
 21459                                  	; MSDOS 3.3
 21460                                  	;push	ds
 21461                                  	;push	si
 21462                                  	;lds	si,[ss:CALLVIDRW]
 21463                                  	;mov	[ss:EXTERRPT+2], ds
 21464                                  	;mov	[ss:EXTERRPT], si
 21465                                  	;pop	si
 21466                                  	;pop	ds
 21467                                  
 21468                                  	; MSDOS 6.0
 21469 00003821 50                      	push	ax
 21470 00003822 36A1[7003]              	mov	ax,[SS:CALLVIDRW]		; get ptr lo  ;smr;SS Override
 21471 00003826 36A3[2803]              	mov	[ss:EXTERRPT],ax		; set ext err ptr lo
 21472 0000382A 36A1[7203]              	mov	ax,[SS:CALLVIDRW+2]		; get ptr hi from dev
 21473 0000382E 36A3[2A03]              	mov	[ss:EXTERRPT+2],ax		; set ext err ptr hi
 21474 00003832 58                      	pop	ax
 21475                                  DO_ERR:
 21476                                  	;;call	HARDERR
 21477                                  	;;retn
 21478                                  	; 16/12/2022
 21479                                  	; 10/06/2019
 21480 00003833 E9341B                  	jmp	HARDERR	
 21481                                  	; 18/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 21482                                  	;call	HARDERR
 21483                                  	;retn
 21484                                  
 21485                                  ; 24/07/2018 - Retro DOS v3.0
 21486                                  
 21487                                  ;Break	<SETUP -- SETUP A DISK READ OR WRITE FROM USER>
 21488                                  ;----------------------------------------------------------------------------
 21489                                  ;
 21490                                  ; Procedure Name : SETUP
 21491                                  ;
 21492                                  ; Inputs:
 21493                                  ;	ES:DI point to SFT (value also in THISSFT)
 21494                                  ;	DMAAdd contains transfer address
 21495                                  ;	CX = Byte count
 21496                                  ;	DS = DOSDATA
 21497                                  ;   WARNING Stack must be clean, two ret addrs on stack, 1st of caller,
 21498                                  ;		2nd of caller of caller.
 21499                                  ; Outputs:
 21500                                  ;	    CX = byte count
 21501                                  ;	    [THISDPB] = Base of drive parameters if file
 21502                                  ;		      = Pointer to device header if device or NET
 21503                                  ;	    ES:DI Points to SFT
 21504                                  ;	    [NEXTADD] = Displacement of disk transfer within segment
 21505                                  ;	    [TRANS] = 0 (No transfers yet)
 21506                                  ;	    BytPos = Byte position in file
 21507                                  ;
 21508                                  ;	The following fields are relevant to local files (not devices) only:
 21509                                  ;
 21510                                  ;	    SecPos = Position of first sector (local files only)
 21511                                  ;	    [BYTSECPOS] = Byte position in first sector (local files only)
 21512                                  ;	    [CLUSNUM] = First cluster (local files only)
 21513                                  ;	    [SECCLUSPOS] = Sector within first cluster (local files only)
 21514                                  ;	    [THISDRV] = Physical unit number (local files only)
 21515                                  ;
 21516                                  ;      RETURNS ONE LEVEL UP WITH:
 21517                                  ;	   CX = 0
 21518                                  ;	   CARRY = Clear
 21519                                  ;	IF AN ERROR IS DETECTED
 21520                                  ; All other registers destroyed
 21521                                  ;----------------------------------------------------------------------------
 21522                                  
 21523                                  ;hkn; called from disk.asm. DS has been set up to DOSDATA.
 21524                                  
 21525                                  ; DOSCODE:770Bh (MSDOS 6.21, MSDOS.SYS)
 21526                                  
 21527                                  ; 18/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 21528                                  ; DOSCODE:76F7h (MSDOS 5.0, MSDOS.SYS)
 21529                                  
 21530                                  SETUP:
 21531                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 411Bh
 21532                                  
 21533                                  	;lds 	si,[es:di+7]
 21534 00003836 26C57507                	LDS	SI,[ES:DI+SF_ENTRY.sf_devptr]
 21535                                  
 21536                                  ;hkn; SS override
 21537 0000383A 368C1E[8C05]            	MOV	[SS:THISDPB+2],DS
 21538                                  
 21539                                  ;hkn; SS is DOSDATA
 21540 0000383F 16                      	push	ss
 21541 00003840 1F                      	pop	ds
 21542                                  
 21543 00003841 8936[8A05]              	MOV	[THISDPB],SI
 21544                                  
 21545 00003845 8B1E[2C03]              	MOV	BX,[DMAADD]
 21546 00003849 891E[B805]              	MOV	[NEXTADD],BX		;Set NEXTADD to start of Xaddr
 21547 0000384D C606[7405]00            	MOV	BYTE [TRANS],0		;No transferes
 21548                                  	;mov	ax,[es:di+15h]
 21549 00003852 268B4515                	MOV	AX,[ES:DI+SF_ENTRY.sf_position]
 21550                                  	;mov	dx,[es:di+17h]
 21551 00003856 268B5517                	MOV	DX,[ES:DI+SF_ENTRY.sf_position+2]
 21552 0000385A 8916[D005]              	MOV	[BYTPOS+2],DX		;Set it
 21553 0000385E A3[CE05]                	MOV	[BYTPOS],AX
 21554                                  	;test	word [es:di+5],8080h
 21555 00003861 26F745058080            	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet+devid_device
 21556 00003867 753C                    	JNZ	short NOSETSTUFF	;Following not done on devs or NET
 21557 00003869 06                      	PUSH	ES
 21558 0000386A C42E[8A05]              	LES	BP,[THISDPB]		;Point at the DPB
 21559                                  
 21560                                  	; 18/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 21561                                  	;;mov	bl,[es:bp+0]
 21562                                  	;MOV	BL,[ES:BP+DPB.DRIVE]
 21563                                  	; 05/12/2022
 21564 0000386E 268A5E00                	mov	bl,[es:bp]
 21565                                  	
 21566 00003872 881E[7605]              	MOV	[THISDRV],BL		;Set THISDRV
 21567                                  	;mov	bx,[es:bp+2]
 21568 00003876 268B5E02                	MOV	BX,[ES:BP+DPB.SECTOR_SIZE]
 21569                                  
 21570                                  	;; MSDOS 3.3
 21571                                  	;cmp	dx,bx
 21572                                  	;jnb	short EOFERR
 21573                                  	;div	bx
 21574                                  	;mov	[SECPOS],ax
 21575                                  	;mov	[BYTSECPOS],dx
 21576                                  	;mov	dx,ax
 21577                                  	;;and	al,[es:bp+4]
 21578                                  	;AND	AL,[ES:BP+DPB.CLUSTER_MASK]
 21579                                  	;mov	[SECCLUSPOS],al
 21580                                  	;mov	ax,cx
 21581                                  	;;mov	cl,[es:bp+5]
 21582                                  	;MOV	CL,[ES:BP+DPB.CLUSTER_SHIFT]
 21583                                  	;shr	dx,cl
 21584                                  	;mov	[CLUSNUM],dx
 21585                                  	;pop	es
 21586                                  	;mov	cx,ax
 21587                                  
 21588                                  	; 04/05/2019 - Retro DOS v4.0
 21589                                  
 21590                                  	; MSDOS 6.0
 21591                                  ;M039: Optimized this section.
 21592 0000387A 51                              PUSH    CX			;SHR32 and DIV32 use CX.
 21593 0000387B E83405                  	call	DIV32			;DX:AX/BX = CX:AX + DX (rem)
 21594 0000387E 8916[CC05]              	MOV	[BYTSECPOS],DX
 21595 00003882 A3[C405]                	MOV	[SECPOS],AX
 21596 00003885 890E[C605]              	MOV	[SECPOS+2],CX
 21597 00003889 89CA                    	MOV	DX,CX
 21598                                  
 21599 0000388B 89C3                    	MOV	BX,AX
 21600                                  	;and	bl,[es:bp+4]
 21601 0000388D 26225E04                	AND	BL,[ES:BP+DPB.CLUSTER_MASK]
 21602 00003891 881E[7305]              	MOV	[SECCLUSPOS],BL
 21603                                  
 21604 00003895 E84105                  	call	SHR32			;(DX:AX SHR dpb_cluster_shift)
 21605 00003898 59                      	POP	CX			;CX = byte count.
 21606 00003899 751F                    	JNZ	short EOFERR		;cluster number above 64k
 21607                                  	;cmp	ax,[es:bp+0Dh]
 21608 0000389B 263B460D                	CMP	AX,[ES:BP+DPB.MAX_CLUSTER] ;>32mb  if > disk size ;AN000;
 21609 0000389F 7719                    	JA	short EOFERR		   ;>32mb  then EOF       ;AN000;
 21610                                  
 21611 000038A1 A3[BC05]                	MOV	[CLUSNUM],AX
 21612 000038A4 07                      	POP	ES			; ES:DI point to SFT
 21613                                  ;M039
 21614                                  
 21615                                  NOSETSTUFF:
 21616 000038A5 89C8                    	MOV	AX,CX		; AX = Byte count.
 21617 000038A7 0306[2C03]              	ADD	AX,[DMAADD]	; See if it will fit in one segment
 21618 000038AB 730C                    	JNC	short setup_OK	; Must be less than 64
 21619 000038AD A1[2C03]                	MOV	AX,[DMAADD]
 21620 000038B0 F7D8                    	NEG	AX		; Amount of room left in segment (know
 21621                                  				;    less than 64K since max value of CX
 21622                                  				;    is FFFF).
 21623 000038B2 7501                    	JNZ	short NoDec
 21624 000038B4 48                      	DEC	AX
 21625                                  NoDec:
 21626 000038B5 89C1                    	MOV	CX,AX		; Can do this much
 21627 000038B7 E304                    	JCXZ	NOROOM		; Silly user gave Xaddr of FFFF in segment
 21628                                  setup_OK:
 21629 000038B9 C3                      	retn
 21630                                  
 21631                                  EOFERR:
 21632 000038BA 07                      	POP	ES		; ES:DI point to SFT
 21633 000038BB 31C9                    	XOR	CX,CX		; No bytes read
 21634                                  ;;;;;;;;;;; 7/18/86
 21635                                  	; MSDOS 3.3
 21636                                  	;MOV	BYTE [DISK_FULL],1 ; set disk full flag
 21637                                  ;;;;;;;;;;;
 21638                                  NOROOM:
 21639 000038BD 5B                      	POP	BX		; Kill return address
 21640 000038BE F8                      	CLC
 21641 000038BF C3                      	retn			; RETURN TO CALLER OF CALLER
 21642                                  
 21643                                  ;Break	<BREAKDOWN -- CUT A USER READ OR WRITE INTO PIECES>
 21644                                  ;---------------------------------------------------------------------------
 21645                                  ;
 21646                                  ; Procedure Name : BREAKDOWN
 21647                                  ;
 21648                                  ; Inputs:
 21649                                  ;	CX = Length of disk transfer in bytes
 21650                                  ;	ES:BP = Base of drive parameters
 21651                                  ;	[BYTSECPOS] = Byte position within first sector
 21652                                  ;	DS = DOSDATA
 21653                                  ; Outputs:
 21654                                  ;	[BYTCNT1] = Bytes to transfer in first sector
 21655                                  ;	[SECCNT] = No. of whole sectors to transfer
 21656                                  ;	[BYTCNT2] = Bytes to transfer in last sector
 21657                                  ; AX, BX, DX destroyed. No other registers affected.
 21658                                  ;---------------------------------------------------------------------------
 21659                                  
 21660                                  BREAKDOWN:
 21661 000038C0 A1[CC05]                	MOV	AX,[BYTSECPOS]
 21662 000038C3 89CB                    	MOV	BX,CX
 21663 000038C5 09C0                    	OR	AX,AX
 21664 000038C7 740E                    	JZ	short SAVFIR	; Partial first sector?
 21665                                  	;sub	ax,[es:bp+2]
 21666 000038C9 262B4602                	SUB	AX,[ES:BP+DPB.SECTOR_SIZE]
 21667 000038CD F7D8                    	NEG	AX		; Max number of bytes left in first sector
 21668 000038CF 29C3                    	SUB	BX,AX		; Subtract from total length
 21669 000038D1 7304                    	JAE	short SAVFIR
 21670 000038D3 01D8                    	ADD	AX,BX		; Don't use all of the rest of the sector
 21671 000038D5 31DB                    	XOR	BX,BX		; And no bytes are left
 21672                                  SAVFIR:
 21673 000038D7 A3[D205]                	MOV	[BYTCNT1],AX
 21674 000038DA 89D8                    	MOV	AX,BX
 21675 000038DC 31D2                    	XOR	DX,DX
 21676                                  	;div	word [ES:BP+2]
 21677 000038DE 26F77602                	DIV	word [ES:BP+DPB.SECTOR_SIZE]  ; How many whole sectors?
 21678 000038E2 A3[D605]                	MOV	[SECCNT],AX
 21679 000038E5 8916[D405]              	MOV	[BYTCNT2],DX	; Bytes remaining for last sector
 21680                                  	; MSDOS 3.3
 21681                                  	;OR	DX,[BYTCNT1]	; SMR ONESECTORFIX BUGBUG
 21682                                  	;retnz			; NOT (BYTCNT1 = BYTCNT2 = 0)
 21683                                  	;CMP	AX,1
 21684                                  	;retnz
 21685                                  	;MOV	AX,[ES:BP+DPB.SECTOR_SIZE] ; Buffer EXACT one sector I/O
 21686                                  	;MOV	[BYTCNT2],AX
 21687                                  	;MOV	[SECCNT],DX	; DX = 0
 21688                                  _RET45:
 21689 000038E9 C3                      	retn
 21690                                  
 21691                                  ; DOSCODE:77BFh (MSDOS 6.21, MSDOS.SYS)
 21692                                  
 21693                                  ;----------------------------------------------------------------------------
 21694                                  ;
 21695                                  ; Procedure Name : READ_LOCK_VIOLATION
 21696                                  ;
 21697                                  ; ES:DI points to SFT. This entry used by NET_READ
 21698                                  ; Carry set if to return error (CX=0,AX=error_sharing_violation).
 21699                                  ; Else do retrys.
 21700                                  ; ES:DI,DS,CX preserved
 21701                                  ;
 21702                                  ;----------------------------------------------------------------------------
 21703                                  
 21704                                  READ_LOCK_VIOLATION:
 21705 000038EA C606[7505]00            	MOV	byte [READOP],0
 21706                                  ERR_ON_CHECK:
 21707                                  	;;test	word [es:di+2],8000h
 21708                                  	;TEST	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB
 21709                                  	;JNZ	short HARD_ERR
 21710                                  
 21711                                  	; 04/05/2019
 21712                                  	;test	byte [es:di+3],80h
 21713 000038EF 26F6450380              	TEST	byte [ES:DI+SF_ENTRY.sf_mode+1],(sf_isFCB>>8)
 21714 000038F4 7508                    	JNZ	short HARD_ERR
 21715                                  
 21716                                  	;PUSH	CX
 21717                                  	;;mov	cl,[es:di+2]
 21718                                  	;MOV	CL,[ES:DI+SF_ENTRY.sf_mode]
 21719                                  	;;and	cl,0F0h
 21720                                  	;AND	CL,SHARING_MASK
 21721                                  	;;cmp	cl,0
 21722                                  	;CMP	CL,SHARING_COMPAT
 21723                                  	;POP	CX
 21724                                  	;JNE	short NO_HARD_ERR
 21725                                  	; 21/09/2023
 21726 000038F6 268A4502                	mov	al,[ES:DI+SF_ENTRY.sf_mode]
 21727 000038FA 24F0                    	and	al,SHARING_MASK
 21728                                  	;cmp	al,SHARING_COMPAT
 21729                                  	;jne	short NO_HARD_ERR
 21730 000038FC 7505                    	jnz	short NO_HARD_ERR
 21731                                  HARD_ERR:
 21732 000038FE E87E3A                  	call	LOCK_VIOLATION
 21733 00003901 73E6                    	jnc	short _RET45		; User wants Retrys
 21734                                  NO_HARD_ERR:
 21735 00003903 31C9                    	XOR	CX,CX			;No bytes transferred
 21736                                  	;mov	ax,21h
 21737 00003905 B82100                  	MOV	AX,error_lock_violation
 21738 00003908 F9                      	STC
 21739 00003909 C3                      	retn
 21740                                  
 21741                                  ;----------------------------------------------------------------------------
 21742                                  ;
 21743                                  ; Procedure Name : WRITE_LOCK_VIOLATION
 21744                                  ;
 21745                                  ; Same as READ_LOCK_VIOLATION except for READOP.
 21746                                  ; This entry used by NET_WRITE
 21747                                  ;
 21748                                  ;----------------------------------------------------------------------------
 21749                                  
 21750                                  WRITE_LOCK_VIOLATION:
 21751 0000390A C606[7505]01            	MOV	byte [READOP],1
 21752 0000390F EBDE                    	JMP	short ERR_ON_CHECK
 21753                                  
 21754                                  ; 04/05/2019 - Retro DOS v4.0
 21755                                  
 21756                                  ; DOSCODE:77ECh (MSDOS 6.21, MSDOS.SYS)
 21757                                  
 21758                                  ;Break	<DISKREAD -- PERFORM USER DISK READ>
 21759                                  ;----------------------------------------------------------------------------
 21760                                  ;
 21761                                  ; Procedure Name : DISKREAD
 21762                                  ;
 21763                                  ; Inputs:
 21764                                  ;	Outputs of SETUP
 21765                                  ; Function:
 21766                                  ;	Perform disk read
 21767                                  ; Outputs:
 21768                                  ;    Carry clear
 21769                                  ;	CX = No. of bytes read
 21770                                  ;	ES:DI point to SFT
 21771                                  ;	SFT offset and cluster pointers updated
 21772                                  ;    Carry set
 21773                                  ;	CX = 0
 21774                                  ;	ES:DI point to SFT
 21775                                  ;	AX has error code
 21776                                  ;----------------------------------------------------------------------------
 21777                                  
 21778                                  ;hkn; called from disk.asm. DS already set up.
 21779                                  
 21780                                  ; 18/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 21781                                  ; DOSCODE:77D8h (MSDOS 5.0, MSDOS.SYS)
 21782                                  
 21783                                  DISKREAD:
 21784                                  	;mov	ax,[es:di+11h]
 21785 00003911 268B4511                	MOV	AX,[ES:DI+SF_ENTRY.sf_size]
 21786                                  	;mov	bx,[es:di+13h]
 21787 00003915 268B5D13                	MOV	BX,[ES:DI+SF_ENTRY.sf_size+2]
 21788 00003919 2B06[CE05]              	SUB	AX,[BYTPOS]
 21789 0000391D 1B1E[D005]              	SBB	BX,[BYTPOS+2]
 21790 00003921 7226                    	JB	short RDERR		;Read starts past EOF
 21791 00003923 750A                    	JNZ	short ENUF		;More than 64k to EOF
 21792 00003925 09C0                    	OR	AX,AX
 21793 00003927 7420                    	JZ	short RDERR		;Read starts at EOF
 21794 00003929 39C8                    	CMP	AX,CX
 21795 0000392B 7302                    	JAE	short ENUF		;I/O fits
 21796 0000392D 89C1                    	MOV	CX,AX			;Limit read to up til EOF
 21797                                  ENUF:
 21798                                  	; MSDOS 3.3
 21799                                  	;test	byte [es:di+4],8
 21800                                  	;TEST	byte [ES:DI+SF_ENTRY.sf_attr],attr_volume_id
 21801                                  	;jnz	short SET_ACC_ERR
 21802                                  	;call	LOCK_CHECK
 21803                                  	;jnb	short _READ_OK
 21804                                  	;call	READ_LOCK_VIOLATION
 21805                                  	;jnb	short ENUF
 21806                                  	;retn
 21807                                  
 21808                                  	; MSDOS 6.0
 21809 0000392F E87CFE                  	call	CHECK_READ_LOCK		;IFS. check read lock	;AN000;
 21810 00003932 7301                    	JNC	short _READ_OK 		; There are no locks
 21811 00003934 C3                      	retn
 21812                                  
 21813                                  _READ_OK:
 21814 00003935 C42E[8A05]              	LES	BP,[THISDPB]
 21815 00003939 E884FF                  	CALL	BREAKDOWN
 21816 0000393C 8B0E[BC05]              	MOV	CX,[CLUSNUM]
 21817                                  
 21818 00003940 E87013                  	call	FNDCLUS
 21819                                       	; MSDOS 6.0			;M022 conditional removed here
 21820 00003943 720E                    	JC	short SET_ACC_ERR_DS	; fix to take care of I24 fail
 21821                                  					; migrated from 330a - HKN
 21822 00003945 09C9                    	OR	CX,CX
 21823 00003947 7413                    	JZ	short SKIPERR
 21824                                  RDERR:
 21825 00003949 B40E                    	MOV	AH,0EH			;MS. read/data/fail ;AN000;
 21826 0000394B E92102                  	jmp	WRTERR22
 21827                                  
 21828                                  ;RDLASTJ: 
 21829                                  	;JMP	RDLAST                  ;M039
 21830                                  
 21831                                  SETSFTJ2: 
 21832 0000394E E99600                  	JMP	SETSFT
 21833                                  
 21834                                  CANOT_READ:
 21835                                  	; MSDOS 3.3
 21836                                  	;POP	CX		;M039.
 21837                                  	; MSDOS 3.3 & MSDOS 6.0
 21838 00003951 59                      	POP	CX              ;Clean stack.
 21839 00003952 5B                      	POP	BX
 21840                                  
 21841                                  	;entry	SET_ACC_ERR_DS
 21842                                  SET_ACC_ERR_DS:
 21843                                  
 21844                                  ;hkn; SS is DOSDATA
 21845                                  	;Context DS
 21846 00003953 16                      	push	ss
 21847 00003954 1F                      	pop	ds
 21848                                  
 21849                                  	;entry	SET_ACC_ERR
 21850                                  SET_ACC_ERR:
 21851 00003955 31C9                    	XOR	CX,CX
 21852                                  	;mov	ax,5
 21853 00003957 B80500                  	MOV	AX,error_access_denied
 21854 0000395A F9                      	STC
 21855 0000395B C3                      	retn
 21856                                  
 21857                                  SKIPERR:
 21858 0000395C 8916[BA05]              	MOV	[LASTPOS],DX
 21859 00003960 891E[BC05]              	MOV	[CLUSNUM],BX
 21860 00003964 833E[D205]00            	CMP	word [BYTCNT1],0
 21861 00003969 7405                    	JZ	short RDMID
 21862                                  
 21863 0000396B E8BB13                  	call	BUFRD
 21864 0000396E 72E3                    	JC	short SET_ACC_ERR_DS
 21865                                  
 21866                                  RDMID:
 21867 00003970 833E[D605]00            	CMP	word [SECCNT],0
 21868                                  	;JZ	RDLAST ; 10/08/2018
 21869 00003975 7453                    	jz	short RDLAST
 21870                                  
 21871 00003977 E84414                  	call	NEXTSEC
 21872 0000397A 72D2                    	JC	short SETSFTJ2
 21873                                  
 21874 0000397C C606[7405]01            	MOV	BYTE [TRANS],1		; A transfer is taking place
 21875                                  ONSEC:
 21876 00003981 8A16[7305]              	MOV	DL,[SECCLUSPOS]	; (dx/DL = Extent start) ((dh = ?))
 21877 00003985 8B0E[D605]              	MOV	CX,[SECCNT]
 21878 00003989 8B1E[BC05]              	MOV	BX,[CLUSNUM]
 21879                                  RDLP:
 21880 0000398D E85F14                  	call	OPTIMIZE
 21881 00003990 72C1                    	JC	short SET_ACC_ERR_DS
 21882                                  
 21883 00003992 57                      	PUSH	DI                      ;DI = Next physical cluster.
 21884 00003993 50                      	PUSH	AX                      ;AX = # of sectors remaining.
 21885 00003994 53                      	PUSH	BX			;[DMAADD+2]:BX = Transfer address.
 21886                                  	;mov	byte [ALLOWED],38h
 21887 00003995 C606[4B03]38            	MOV	byte [ALLOWED],Allowed_RETRY+Allowed_FAIL+Allowed_IGNORE
 21888 0000399A 8E1E[2E03]              	MOV	DS,[DMAADD+2]
 21889                                  
 21890 0000399E 52                      	PUSH	DX                      ;[HIGH_SECTOR]:DX = phys. sector #.
 21891 0000399F 51                      	PUSH	CX                      ;CX = # of contiguous sectors to read.
 21892                                  
 21893                                  	; 04/05/2019 - Retro DOS v4.0
 21894                                  
 21895                                  	; MSDOS 6.0
 21896 000039A0 E80922                  	call	SET_RQ_SC_PARMS		;LB. do this for SC ;AN000;
 21897                                  
 21898                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21899 000039A3 E8CFFD                  	call	DREAD
 21900                                  
 21901                                  	; MSDOS 3.3 
 21902                                  	;pop	bx
 21903                                  	;pop	dx
 21904                                  	;jc	short CANOT_READ
 21905                                  	;add	bx,dx	; (bx = Extent end)
 21906                                  	;mov	al,[es:bp] ; mov al,[es:bp+0]
 21907                                  	;;mov	al,[ES:BP+DPB.DRIVE] 
 21908                                  	;call	SETVISIT
 21909                                  	; ->***
 21910                                  ;M039
 21911                                  	; MSDOS 6.0 
 21912 000039A6 59                      	pop	cx
 21913 000039A7 5A                      	pop	dx
 21914 000039A8 368F06[0C06]            	pop	WORD [ss:TEMP_VAR]
 21915 000039AD 72A2                    	jc	short CANOT_READ
 21916                                  
 21917 000039AF 368C1E[0E06]            	mov	[ss:TEMP_VAR2],ds
 21918                                  
 21919                                  ;       CX = # of contiguous sectors read. (These constitute a block of
 21920                                  ;            sectors, also termed an "Extent".)
 21921                                  ;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
 21922                                  ;       [TEMP_VAR2]:[TEMP_VAR] = Transfer address (destination data address).
 21923                                  ;       ES:BP -> Drive Parameter Block (DPB).
 21924                                  ;
 21925                                  ;	The Buffer Queue must now be scanned: the contents of any dirty
 21926                                  ;	buffers must be "read" into the transfer memory block, so that the
 21927                                  ;       transfer memory reflects the most recent data.
 21928                                  
 21929 000039B4 E85E00                  	call	DskRdBufScan
 21930                                  
 21931                                  	;Context DS
 21932 000039B7 16                      	push	ss
 21933 000039B8 1F                      	pop	ds
 21934                                          
 21935 000039B9 59                      	pop	cx
 21936 000039BA 5B                              pop	bx
 21937                                  
 21938                                  ;       CX = # of sector remaining.
 21939                                  ;       BX = Next physical cluster.
 21940                                  
 21941                                  ;M039
 21942                                  
 21943                                  ;;;;;;;;
 21944                                  ;	; 25/07/2018 - Retro DOS v3.0
 21945                                  ;	; ***->
 21946                                  ;	; MSDOS 3.3
 21947                                  ;	; IBMDOS.COM (1987) - Offset 42BDh
 21948                                  ;bufq:
 21949                                  ;;	DX = Extent start.
 21950                                  ;;	BX = Extent end.
 21951                                  ;;	 AL = Drive #.
 21952                                  ;;     DS:DI-> 1st buffer in queue.
 21953                                  ;
 21954                                  ;	;or	byte [di+5],20h
 21955                                  ;	or	byte [DI+BUFFINFO.buf_flags],buf_visit ; Bit 5 = reserved
 21956                                  ;	;cmp	al,[di+4]	
 21957                                  ;	cmp	al,[DI+BUFFINFO.buf_ID]
 21958                                  ;	jnz	short bufq3
 21959                                  ;	;cmp	[di+6],dx
 21960                                  ;	cmp	[DI+BUFFINFO.buf_sector],dx
 21961                                  ;	jb	short bufq3	; Jump if Extent start > buffer sector.
 21962                                  ;	;cmp	[di+6],bx
 21963                                  ;	cmp	[DI+BUFFINFO.buf_sector],bx
 21964                                  ;	jnb	short bufq3	; Jump if Extent end >= buffer sector.
 21965                                  ;	
 21966                                  ;	; Buffer sector is in the Extent (contiguous sectors to read)
 21967                                  ;
 21968                                  ;;      Buffer's sector is in Extent: if it is dirty, copy its contents to
 21969                                  ;;      transfer memory; otherwise, just re-position it in the buffer queue
 21970                                  ;;      as MRU (Most Recently Used).
 21971                                  ;
 21972                                  ;	;test	byte [di+5],40h
 21973                                  ;	test	byte [DI+BUFFINFO.buf_flags],buf_dirty ; Bit 6 = dirty flag
 21974                                  ;	jz	short bufq2	; clear buffer, check the next buff sec
 21975                                  ;	pop	ax ; transfer address
 21976                                  ;	push	ax
 21977                                  ;	push	di
 21978                                  ;	push	dx
 21979                                  ;	;sub	dx,[di+6]
 21980                                  ;	sub	dx,[DI+BUFFINFO.buf_sector]
 21981                                  ;	neg	dx
 21982                                  ;
 21983                                  ;;      DX = offset (in sectors) of buffer sector within Transfer memory
 21984                                  ;;           block.
 21985                                  ;
 21986                                  ;	mov	si,di
 21987                                  ;	mov	di,ax
 21988                                  ;	mov	ax,dx
 21989                                  ;	;mov	cx,[es:bp+6]	
 21990                                  ;	mov     cx,[ES:BP+DPB.SECTOR_SIZE] ; CX = sector size (in bytes).
 21991                                  ;	mul	cx
 21992                                  ;	add	di,ax
 21993                                  ;
 21994                                  ;	lea	si,[si+16]
 21995                                  ;	lea	si,[SI+BUFINSIZ] ;DS:SI -> buffer data.
 21996                                  ;	shr	cx,1
 21997                                  ;	push	es
 21998                                  ;	mov	es,[SS:DMAADD+2]
 21999                                  ;
 22000                                  ;;      CX = sector size (in WORDs) ; CF=1 if odd # of bytes.
 22001                                  ;;      DS:SI-> Buffer sector data.
 22002                                  ;;      ES:DI-> Destination within Transfer memory block.
 22003                                  ;
 22004                                  ;	rep	movsw			;Copy buffer sector to Transfer memory
 22005                                  ;	;adc	cx,0                    ;CX=1 if odd # of bytes, else CX=0.
 22006                                  ;	;rep	movsb                   ;Copy last byte.
 22007                                  ;	jnc	short bufq1
 22008                                  ;	movsb
 22009                                  ;bufq1:
 22010                                  ;	pop	es
 22011                                  ;	pop	dx
 22012                                  ;	pop	di
 22013                                  ;	mov	al,[es:bp]  ; mov al,[es:bp+0]
 22014                                  ;	;mov	al,[ES:BP+DPB.DRIVE]
 22015                                  ;bufq2:
 22016                                  ;	call	SCANPLACE
 22017                                  ;bufq3:
 22018                                  ;	call	SKIPVISIT
 22019                                  ;	jnz	short bufq
 22020                                  ;	
 22021                                  ;	push	ss
 22022                                  ;	pop	ds
 22023                                  ;	pop	cx
 22024                                  ;	pop	cx
 22025                                  ;	pop	bx	
 22026                                  ;bufq4:
 22027                                  ;;;;;;;
 22028 000039BB E30D                    	JCXZ	RDLAST
 22029                                  
 22030 000039BD E8CD1B                  	call	IsEOF			; test for eof on fat size
 22031 000039C0 7325                    	JAE	short SETSFT
 22032                                  
 22033 000039C2 B200                    	MOV	DL,0
 22034 000039C4 FF06[BA05]              	INC	word [LASTPOS]		; We'll be using next cluster
 22035 000039C8 EBC3                    	JMP	short RDLP ; 19/05/2019
 22036                                  
 22037                                  RDLAST:
 22038 000039CA A1[D405]                	MOV	AX,[BYTCNT2]
 22039 000039CD 09C0                    	OR	AX,AX
 22040 000039CF 7416                    	JZ	short SETSFT
 22041 000039D1 A3[D205]                	MOV	[BYTCNT1],AX
 22042                                  
 22043 000039D4 E8E713                  	call	NEXTSEC
 22044 000039D7 720E                    	JC	short SETSFT
 22045                                  
 22046 000039D9 C706[CC05]0000          	MOV	word [BYTSECPOS],0
 22047 000039DF E84713                  	call	BUFRD
 22048                                  	; 10/08/2018
 22049                                  
 22050 000039E2 7303                    	JNC	short SETSFT
 22051 000039E4 E96CFF                  	JMP	SET_ACC_ERR_DS
 22052                                  
 22053                                  ;------------------------------------------------------------------------------
 22054                                  ;
 22055                                  ; Procedure Name : SETSFT
 22056                                  ; Inputs:
 22057                                  ;	[NEXTADD],[CLUSNUM],[LASTPOS] set to determine transfer size
 22058                                  ;		and set cluster fields
 22059                                  ; Function:
 22060                                  ;	Update [THISSFT] based on the transfer
 22061                                  ; Outputs:
 22062                                  ;	sf_position, sf_lstclus, and sf_cluspos updated
 22063                                  ;	ES:DI points to [THISSFT]
 22064                                  ;	CX No. of bytes transferred
 22065                                  ;	Carry clear
 22066                                  ;
 22067                                  ;----------------------------------------------------------------------------
 22068                                  
 22069                                  	;entry	SETSFT
 22070                                  
 22071                                  ; 26/07/2018 - Retro DOS v3.0
 22072                                  SETSFT:
 22073 000039E7 C43E[9E05]              	LES	DI,[THISSFT]
 22074                                  
 22075                                  ; Same as SETSFT except ES:DI already points to SFT
 22076                                  	;entry	SETCLUS
 22077                                  SETCLUS:	
 22078 000039EB 8B0E[B805]              	MOV	CX,[NEXTADD]
 22079 000039EF 2B0E[2C03]              	SUB	CX,[DMAADD]		; Number of bytes transfered
 22080                                  	;;test	word [es:di+5],80h
 22081                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
 22082                                  	;JNZ	short ADDREC		; don't set clusters if device
 22083                                  
 22084                                  	; 04/05/2019 - Retro DOS v4.0
 22085                                  	;test	byte [es:di+5],80h
 22086 000039F3 26F6450580              	TEST	byte [ES:DI+SF_ENTRY.sf_flags],devid_device
 22087 000039F8 750E                    	JNZ	short ADDREC		; don't set clusters if device
 22088                                  
 22089 000039FA A1[BC05]                	MOV	AX,[CLUSNUM]
 22090                                  	;;mov	[es:di+1Bh],ax ; MSDOS 3.3
 22091                                  	;mov	[es:di+35h],ax ; MSDOS 6.0 (& MSDOS 6.21)
 22092 000039FD 26894535                	MOV	[ES:DI+SF_ENTRY.sf_lstclus],AX
 22093 00003A01 A1[BA05]                	MOV	AX,[LASTPOS]
 22094                                  	;mov	[es:di+19h],ax
 22095 00003A04 26894519                	MOV	[ES:DI+SF_ENTRY.sf_cluspos],AX
 22096                                  
 22097                                  ;----------------------------------------------------------------------------
 22098                                  ;
 22099                                  ; Procedure : AddRec
 22100                                  ; Inputs:
 22101                                  ;	ES:DI points to SFT
 22102                                  ;	CX is No. Bytes transferred
 22103                                  ; Function:
 22104                                  ;	Update the SFT offset based on the transfer
 22105                                  ; Outputs:
 22106                                  ;	sf_position updated to point to first byte after transfer
 22107                                  ;	ES:DI points to SFT
 22108                                  ;	CX No. of bytes transferred
 22109                                  ;	Carry clear
 22110                                  ;----------------------------------------------------------------------------
 22111                                  
 22112                                  	;entry	AddRec
 22113                                  ADDREC:
 22114 00003A08 E309                    	JCXZ	RET28		; If no records read,  don't change position
 22115                                  	;add	[es:di+15h],cx
 22116 00003A0A 26014D15                	ADD	[ES:DI+SF_ENTRY.sf_position],CX  ; Update current position
 22117                                  	;adc	word [es:di+17h], 0
 22118 00003A0E 2683551700              	ADC	WORD [ES:DI+SF_ENTRY.sf_position+2],0
 22119                                  RET28:	
 22120 00003A13 F8                      	CLC
 22121 00003A14 C3                      	retn
 22122                                  
 22123                                  ; 25/07/2018
 22124                                  ; MSDOS 6.0
 22125                                  ;Break   <DskRdBufScan -- Disk Read Buffer Scan>
 22126                                  ;----------------------------------------------------------------------------
 22127                                  ;
 22128                                  ; Procedure Name : DskRdBufScan
 22129                                  ;
 22130                                  ; Inputs:
 22131                                  ;       CX = # of contiguous sectors read. (These constitute a block of
 22132                                  ;            sectors, also termed an "Extent".)
 22133                                  ;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
 22134                                  ;       [TEMP_VAR2]:[TEMP_VAR] = Transfer address (destination data address).
 22135                                  ;       ES:BP -> Drive Parameter Block (DPB).
 22136                                  ;
 22137                                  ; Function:
 22138                                  ;	The Buffer Queue is scanned: the contents of any dirty buffers are
 22139                                  ;	"read" into the transfer memory block, so that the transfer memory
 22140                                  ;	reflects the most recent data.
 22141                                  ;
 22142                                  ; Outputs:
 22143                                  ;       Transfer memory updated as required.
 22144                                  ;
 22145                                  ; Uses:
 22146                                  ;       DS,AX,BX,CX,SI,DI destroyed.
 22147                                  ;       SS override for all global variables.
 22148                                  ;
 22149                                  ; Notes:
 22150                                  ;       FIRST_BUFF_ADDR is set-up to contain the LAST buffer to check, rather
 22151                                  ;	than the FIRST.
 22152                                  ;----------------------------------------------------------------------------
 22153                                  ;M039: Created
 22154                                  
 22155                                  ; 04/05/2019 - Retro DOS v4.0
 22156                                  ; DOSCODE:78F0h (MSDOS 6.21, MSDOS.SYS)
 22157                                  
 22158                                  ; 18/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 22159                                  ; DOSCODE:78DCh (MSDOS 5.0, MSDOS.SYS) 
 22160                                  
 22161                                  ;procedure DskRdBufScan,NEAR
 22162                                  ;
 22163                                  ;ASSUME  DS:NOTHING
 22164                                  
 22165                                  DskRdBufScan:
 22166 00003A15 36833E[7100]00          	cmp	word [ss:DirtyBufferCount],0 ; Any dirty buffers?
 22167 00003A1B 743C                    	je	short bufx		     ; -no, skip all work.
 22168                                  
 22169 00003A1D 368B1E[0706]            	mov     bx,[ss:HIGH_SECTOR]
 22170 00003A22 89DE                    	mov     si,bx
 22171 00003A24 01D1                    	add     cx,dx
 22172 00003A26 83D600                  	adc     si,0
 22173                                  
 22174 00003A29 E8181F                  	call	GETCURHEAD		;DS:DI -> 1st buf in queue.
 22175                                  	;mov	ax,[di+2]
 22176 00003A2C 8B4502                  	mov     ax,[di+BUFFINFO.buf_prev]
 22177 00003A2F 36A3[BA0E]              	mov     [ss:FIRST_BUFF_ADDR],ax
 22178                                  		
 22179                                  	; 18/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 22180                                  	;;mov	al,[es:bp+0]
 22181                                  	;mov	al,[es:bp+DPB.DRIVE]
 22182                                  	; 15/12/2022
 22183 00003A33 268A4600                	mov	al,[es:bp]
 22184                                  
 22185                                  ;       BX:DX = Extent start.
 22186                                  ;       SI:CX = Extent end + 1.
 22187                                  ;          AL = Drive #.
 22188                                  ;       DS:DI-> 1st buffer in queue.
 22189                                  ;[FIRST_BUFF_ADDR] = Address offset of last buffer in queue.
 22190                                  
 22191                                  bufq:	
 22192                                  	;cmp	al,[di+4]
 22193 00003A37 3A4504                  	cmp     al,[di+BUFFINFO.buf_ID] ;Same drive?
 22194 00003A3A 7514                    	jne	short bufq1        	;  -no, jump.
 22195                                  
 22196                                  ;       Cmp32   bx,dx,<WORD PTR [di.buf_sector+2]>,<WORD PTR [di.buf_sector]>
 22197                                  ;       ja	short bufq1		;Jump if Extent start > buffer sector.
 22198                                  
 22199                                  	;cmp	bx,[di+8]
 22200 00003A3C 3B5D08                  	cmp	bx,[di+BUFFINFO.buf_sector+2]
 22201 00003A3F 7503                    	jne	short bufq01
 22202                                  	;cmp	dx,[di+6]
 22203 00003A41 3B5506                  	cmp	dx,[di+BUFFINFO.buf_sector]
 22204                                  bufq01:
 22205 00003A44 770A                    	ja	short bufq1
 22206                                  
 22207                                  ;       Cmp32   si,cx,<WORD PTR [di.buf_sector+2]>,<WORD PTR [di.buf_sector]>
 22208                                  ;       ja	short bufq2		;Jump if Extent end >= buffer sector.
 22209                                  
 22210                                  	;cmp	si,[di+8]
 22211 00003A46 3B7508                  	cmp	si,[di+BUFFINFO.buf_sector+2]
 22212 00003A49 7503                    	jne	short bufq02
 22213                                  	;cmp	cx,[di+6]
 22214 00003A4B 3B4D06                  	cmp	cx,[di+BUFFINFO.buf_sector]
 22215                                  bufq02:
 22216 00003A4E 770A                    	ja	short bufq2
 22217                                  bufq1:	
 22218 00003A50 363B3E[BA0E]            	cmp     di,[ss:FIRST_BUFF_ADDR]	;Scanned entire buffer queue?
 22219 00003A55 8B3D                    	mov	di,[di]
 22220                                  	;mov	di,[di+BUFFINFO.buf_next] ; Set-up for next buffer.
 22221 00003A57 75DE                    	jne	short bufq		; -no, do next buffer
 22222                                  bufx:
 22223 00003A59 C3                      	retn				;Exit.
 22224                                  
 22225                                  ;       Buffer's sector is in Extent: if it is dirty, copy its contents to
 22226                                  ;	transfer memory; otherwise, just re-position it in the buffer queue
 22227                                  ;       as MRU (Most Recently Used).
 22228                                  
 22229                                  bufq2:	
 22230 00003A5A 50                      	push	ax
 22231                                  	;test	byte [di+5],40h
 22232 00003A5B F6450540                	test	byte [di+BUFFINFO.buf_flags],buf_dirty ;Buffer dirty?
 22233 00003A5F 742D                    	jz	short bufq3                    ; -no, jump.
 22234                                  
 22235                                  ;       SaveReg <cx,dx,si,di,es>
 22236 00003A61 51                      	push	cx
 22237 00003A62 52                      	push	dx
 22238 00003A63 56                      	push	si
 22239 00003A64 57                      	push	di
 22240 00003A65 06                      	push	es
 22241                                  
 22242 00003A66 89D0                    	mov     ax,dx
 22243                                  	;sub	ax,[di+6]
 22244 00003A68 2B4506                  	sub	ax,[di+BUFFINFO.buf_sector]
 22245 00003A6B F7D8                    	neg	ax
 22246                                  
 22247                                  ;       AX = offset (in sectors) of buffer sector within Transfer memory
 22248                                  ;            block. (Note: the upper word of the sector # may be ignored
 22249                                  ;	     since no more than 64k bytes will ever be read. This 64k limit
 22250                                  ;            is imposed by the input parameters of the disk read operation.)
 22251                                  
 22252                                  	;lea	si,[di+20]
 22253 00003A6D 8D7514                  	lea	si,[di+BUFINSIZ]	;DS:SI -> buffer data.
 22254                                  	;mov	cx,[es:bp+2]
 22255 00003A70 268B4E02                	mov     cx,[es:bp+DPB.SECTOR_SIZE] ;CX = sector size (in bytes).
 22256 00003A74 F7E1                    	mul     cx			;AX = offset (in bytes) of buf. sector
 22257 00003A76 368B3E[0C06]            	mov     di,[ss:TEMP_VAR]
 22258 00003A7B 01C7                    	add	di,ax
 22259 00003A7D 368E06[0E06]            	mov	es,[ss:TEMP_VAR2]
 22260 00003A82 D1E9                    	shr	cx,1
 22261                                  
 22262                                  ;	   CX = sector size (in WORDs) ; CF=1 if odd # of bytes.
 22263                                  ;       DS:SI-> Buffer sector data.
 22264                                  ;       ES:DI-> Destination within Transfer memory block.
 22265                                  
 22266 00003A84 F3A5                    	rep	movsw			;Copy buffer sector to Transfer memory
 22267                                  	;; 04/05/2019
 22268                                  	;;adc	cx,0                    ;CX=1 if odd # of bytes, else CX=0.
 22269                                  	;;rep	movsb                   ;Copy last byte.
 22270                                  	;jnc	short bufq03	
 22271                                  	;movsb
 22272                                  	; 18/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 22273                                  	;adc	cx,0
 22274                                  	;rep	movsb
 22275                                  	; 22/09/2023
 22276 00003A86 7301                    	jnc	short bufq03
 22277 00003A88 A4                      	movsb
 22278                                  bufq03:
 22279                                  	;RestoreReg <es,di,si,dx,cx>
 22280 00003A89 07                      	pop	es
 22281 00003A8A 5F                      	pop	di
 22282 00003A8B 5E                      	pop	si
 22283 00003A8C 5A                      	pop	dx
 22284 00003A8D 59                      	pop	cx
 22285                                  
 22286                                  ;       DS:DI -> current buffer.
 22287                                  bufq3:	
 22288 00003A8E 89F8                    	mov     ax,di			;DS:AX -> Current buffer.
 22289                                          ;invoke SCANPLACE
 22290 00003A90 E8C31E                  	call	SCANPLACE
 22291 00003A93 363B06[BA0E]            	cmp	ax,[ss:FIRST_BUFF_ADDR] ;Last buffer?
 22292 00003A98 58                      	pop	ax
 22293                                  	;jne	short bufq		; -no, jump.
 22294                                  	;;jmp	short bufx		; -yes, exit.
 22295                                  	;; 12/06/2019
 22296                                  	;retn
 22297                                  	; 18/11/2022 (MSDOS 5.0 MSDOS.SYS compability)
 22298 00003A99 759C                    	jne	short bufq
 22299 00003A9B EBBC                    	jmp	short bufx
 22300                                  
 22301                                  ;EndProc DskRdBufScan
 22302                                  
 22303                                  ;============================================================================
 22304                                  ; DISK3.ASM, MSDOS 6.0, 1991
 22305                                  ;============================================================================
 22306                                  ; 04/05/2019 - Retro DOS v4.0
 22307                                  ; 24/07/2018 - Retro DOS v3.0
 22308                                  
 22309                                  ;Break   <DISKWRITE -- PERFORM USER DISK WRITE>
 22310                                  ;----------------------------------------------------------------------------
 22311                                  ;
 22312                                  ; Procedure Name : DISKWRITE
 22313                                  ;
 22314                                  ; Inputs:
 22315                                  ;       Outputs of SETUP
 22316                                  ; Function:
 22317                                  ;       Perform disk write
 22318                                  ; Outputs:
 22319                                  ;    Carry clear
 22320                                  ;       CX = No. of bytes written
 22321                                  ;       ES:DI point to SFT
 22322                                  ;       SFT offset and cluster pointers updated
 22323                                  ;    Carry set
 22324                                  ;       CX = 0
 22325                                  ;       ES:DI point to SFT
 22326                                  ;       AX has error code
 22327                                  ;----------------------------------------------------------------------------
 22328                                  
 22329                                  ;hkn; called by DOS_WRITE. DS already set up at this point.
 22330                                  
 22331                                  ; DOSCODE:797Ah (MSDOS 6.21, MSDOS.SYS)
 22332                                  
 22333                                  ; 20/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 22334                                  ; DOSCODE:7966h (MSDOS 5.0, MSDOS.SYS) 
 22335                                  
 22336                                  DISKWRITE:
 22337                                  	; MSDOS 3.3
 22338                                  	; IBMDOS.COM - Offset 436Dh
 22339                                  	;;test	byte [es:di+4],8
 22340                                  	;TEST	byte [ES:DI+SF_ENTRY.sf_attr],attr_volume_id
 22341                                  	;jz	short write_cont
 22342                                  	;jmp	SET_ACC_ERR_DS
 22343                                  ;write_cont:
 22344                                  	;push	cx
 22345                                  	;or	cx,cx
 22346                                  	;jnz	short Not_Truncate
 22347                                  	;;mov	cx,-1
 22348                                  	;dec	cx
 22349                                  ;Not_Truncate:
 22350                                  	;call	LOCK_CHECK
 22351                                  	;pop	cx
 22352                                  	;jnb	short _WRITE_OK
 22353                                  	;call	WRITE_LOCK_VIOLATION
 22354                                  	;jnb	short DISKWRITE
 22355                                  	;retn
 22356                                  
 22357                                  	; MSDOS 6.0
 22358 00003A9D E8F0FC                  	call	CHECK_WRITE_LOCK	;IFS. check write lock	;AN000;
 22359                                  	; 19/08/2018
 22360 00003AA0 7304                    	JNC	short _WRITE_OK		;IFS. lock check ok	;AN000;
 22361 00003AA2 C3                      	retn
 22362                                  
 22363                                  WRTEOFJ:
 22364 00003AA3 E9DC01                  	JMP     WRTEOF
 22365                                  
 22366                                  _WRITE_OK:
 22367                                   	; 27/07/2018
 22368                                  	; IBMDOS.COM - Offset 438Eh
 22369                                  	
 22370                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22371                                  	;and	word [es:di+5],0BFBFh
 22372 00003AA6 26816505BFBF            	AND     word [ES:DI+SF_ENTRY.sf_flags],~(sf_close_nodate|devid_file_clean)
 22373                                  				; Mark file as dirty, clear no date on close
 22374                                  
 22375                                  	; 04/05/2019 - Retro DOS v4.0	
 22376                                  
 22377                                  	; MSDOS 6.0
 22378                                  	; mov 	ax,[es:di+11h]
 22379 00003AAC 268B4511                	MOV	AX,[ES:DI+SF_ENTRY.sf_size]		;M039
 22380 00003AB0 A3[0C06]                        MOV	[TEMP_VAR],AX                           ;M039
 22381                                  	;mov	ax,[es:di+13h]
 22382 00003AB3 268B4513                	MOV	AX,[ES:DI+SF_ENTRY.sf_size+2]		;M039
 22383 00003AB7 A3[0E06]                        MOV	[TEMP_VAR2],AX                          ;M039
 22384                                  
 22385                                  ;	TEMP_VAR2:TEMP_VAR = Current file size (sf_size);M039
 22386                                  
 22387                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22388 00003ABA C42E[8A05]              	LES     BP,[THISDPB]
 22389                                  
 22390 00003ABE E8FFFD                  	call	BREAKDOWN
 22391                                  
 22392 00003AC1 A1[CE05]                	MOV     AX,[BYTPOS]
 22393 00003AC4 8B16[D005]              	MOV     DX,[BYTPOS+2]
 22394 00003AC8 E3D9                    	JCXZ    WRTEOFJ                 ;Make the file length = sf_position
 22395 00003ACA 01C8                    	ADD     AX,CX
 22396 00003ACC 83D200                  	ADC     DX,0                    ;DX:AX = last byte to write + 1.
 22397                                  
 22398                                  	;mov	bx,[es:bp+2]
 22399 00003ACF 268B5E02                	MOV     BX,[ES:BP+DPB.SECTOR_SIZE]
 22400                                  
 22401                                  	; MSDOS 3.3
 22402                                  	;cmp	dx,bx
 22403                                  	;jnb	short WRTERR33
 22404                                  	;div	bx
 22405                                  	;mov	bx,ax
 22406                                  	;OR	DX,DX
 22407                                  	;JNZ	short CALCLUS
 22408                                  	;dec	ax
 22409                                  ;CALCLUS:
 22410                                  	; MSDOS 3.3
 22411                                  	;mov	cl,[es:bp+5]
 22412                                  	;MOV	CL,[ES:BP+DPB.CLUSTER_SHIFT]
 22413                                  	;shr	ax,cl
 22414                                  	;push	ax
 22415                                  	;push	dx
 22416                                  	;push	es
 22417                                  	;les	di,[THISSFT]
 22418                                  	;;mov	ax,[es:di+11h]
 22419                                  	;;mov	dx,[es:di+13h]
 22420                                  	;mov	ax,[ES:DI+SF_ENTRY.sf_size]
 22421                                  	;mov	dx,[ES:DI+SF_ENTRY.sf_size+2]
 22422                                  	;pop	es
 22423                                  	;;DX:AX = current file size (in bytes).
 22424                                  	;;div	word [es:bp+2]
 22425                                  	;div	word [ES:BP+DPB.SECTOR_SIZE]
 22426                                  	;mov	cx,ax
 22427                                  	;or	dx,dx
 22428                                  	;jz	short NORND
 22429                                  	;inc	ax
 22430                                  ;NORND:
 22431                                  	; MSDOS 6.0
 22432 00003AD3 E8DC02                  	CALL	DIV32                   ;DX:AX/BX = CX:AX + DX (rem.).
 22433 00003AD6 89C6                    	MOV	SI,AX
 22434 00003AD8 890E[0706]                      MOV	[HIGH_SECTOR],CX
 22435                                  
 22436                                  ;       [HIGH_SECTOR]:SI = Last full sector to write.
 22437                                  
 22438 00003ADC 09D2                    	OR	DX,DX
 22439 00003ADE 52                      	PUSH	DX			;M039: Free DX for use by SHR32
 22440 00003ADF 89CA                    	MOV	DX,CX			;M039
 22441 00003AE1 7506                    	JNZ	short CALCLUS
 22442 00003AE3 83E801                  	SUB	AX,1                    ;AX must be zero base indexed	;AC000;
 22443 00003AE6 83DA00                  	SBB	DX,0			;M039 ;F.C. >32mb		;AN000;
 22444                                  
 22445                                  CALCLUS:
 22446                                  	; MSDOS 6.0
 22447 00003AE9 E8ED02                  	CALL	SHR32                   ;F.C. >32mb			;AN000;
 22448 00003AEC 5A                      	POP	DX
 22449                                  
 22450                                  ;       AX = Last cluster to write.
 22451                                  ;       DX = # of bytes in last sector to write (the "tail").
 22452                                  ;       BX = [ES:BP+DPB.SECTOR_SIZE]
 22453                                  
 22454 00003AED 50                      	PUSH	AX
 22455 00003AEE 52                      	PUSH	DX
 22456                                  ;M039
 22457 00003AEF 8B16[0E06]              	mov	dx,[TEMP_VAR2]
 22458 00003AF3 A1[0C06]                	mov	ax,[TEMP_VAR]           ;DX:AX = current file size (in bytes).
 22459 00003AF6 E8B902                  	call	DIV32           	;DX:AX/BX = CX:AX + DX (rem.)
 22460 00003AF9 890E[0E06]              	mov	[TEMP_VAR2],cx
 22461 00003AFD 890E[CA05]              	mov	[VALSEC+2],cx
 22462 00003B01 89C1                    	mov	cx,ax
 22463 00003B03 89F3                    	mov	bx,si
 22464                                  
 22465                                  ;       [HIGH_SECTOR]:BX = Last full sector to write.
 22466                                  ;          [VALSEC+2]:CX = Last full sector of current file.
 22467                                  ;         [TEMP_VAR2]:CX = Last full sector of current file.
 22468                                  ;                     DX = # of bytes in last sector of current file.
 22469                                  ;M039
 22470 00003B05 09D2                    	OR	DX,DX
 22471 00003B07 7407                    	JZ	short NORND
 22472                                  	;ADD	AX,1            	;Round up if any remainder	;AC000;
 22473                                  	;ADC	word [VALSEC+2],0
 22474                                  	; 22/09/2023
 22475 00003B09 40                      	inc	ax  ; 0FFFFh -> 0
 22476 00003B0A 7504                    	jnz	short NORND
 22477 00003B0C FF06[CA05]              	inc	word [VALSEC+2]
 22478                                  NORND:	
 22479                                  	; MSDOS 3.3 & MSDOS 6.0
 22480 00003B10 A3[C805]                	MOV     [VALSEC],AX
 22481                                  
 22482                                  ;       [VALSEC] = Last sector of current file.
 22483                                  
 22484 00003B13 31C0                    	XOR     AX,AX
 22485 00003B15 A3[DE05]                	MOV     [GROWCNT],AX
 22486 00003B18 A3[E005]                	MOV     [GROWCNT+2],AX
 22487 00003B1B 58                      	POP     AX
 22488                                  
 22489                                  	; MSDOS 6.0
 22490 00003B1C 8B3E[0706]              	MOV	DI,[HIGH_SECTOR]        ;F.C. >32mb			;AN000;
 22491 00003B20 3B3E[0E06]              	CMP	DI,[TEMP_VAR2]		;M039; F.C. >32mb		;AN000;
 22492 00003B24 7263                    	JB	short NOGROW		;F.C. >32mb                     ;AN000;
 22493 00003B26 7408                    	JZ	short lowsec		;F.C. >32mb                     ;AN000;
 22494 00003B28 29CB                    	SUB	BX,CX                   ;F.C. >32mb                     ;AN000;
 22495 00003B2A 1B3E[0E06]              	SBB	DI,[TEMP_VAR2]   	;M039; F.C. >32mb di:bx no. of sectors ;AN000;
 22496 00003B2E EB08                    	JMP	short yesgrow           ;F.C. >32mb                     ;AN000;
 22497                                  lowsec:
 22498                                  	;MOV	DI,0			;F.C. >32mb
 22499                                  	; 22/09/2023
 22500 00003B30 31FF                    	xor	di,di
 22501                                  	; MSDOS 3.3 & MSDOS 6.0
 22502 00003B32 29CB                    	SUB	BX,CX			; Number of full sectors
 22503 00003B34 7253                    	JB	short NOGROW
 22504 00003B36 7444                    	JZ	short TESTTAIL
 22505                                  yesgrow:
 22506                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22507 00003B38 89D1                    	MOV     CX,DX
 22508 00003B3A 93                      	XCHG    AX,BX
 22509                                  	;mul	word [es:bp+2]
 22510 00003B3B 26F76602                	MUL	word [ES:BP+DPB.SECTOR_SIZE]  ; Bytes of full sector growth
 22511                                  	
 22512                                  	; MSDOS 6.0
 22513 00003B3F 8916[0706]              	MOV	[HIGH_SECTOR],DX         ;F.C. >32mb save dx                    ;AN000;
 22514 00003B43 A3[0E06]                	MOV	[TEMP_VAR2],AX    	 ;M039; F.C. >32mb save ax		;AN000;
 22515 00003B46 89F8                    	MOV	AX,DI                    ;F.C. >32mb                            ;AN000;
 22516                                  	;mul	word [es:bp+2]
 22517 00003B48 26F76602                	MUL	word [ES:BP+DPB.SECTOR_SIZE] ;F.C. >32mb do higher word multiply ;AN000;
 22518                                  	
 22519 00003B4C 0306[0706]              	ADD	AX,[HIGH_SECTOR]         ;F.C. >32mb add lower value            ;AN000;
 22520 00003B50 89C2                    	MOV	DX,AX                    ;F.C. >32mb DX:AX is the result of     ;AN000;
 22521 00003B52 A1[0E06]                	MOV	AX,[TEMP_VAR2]    	 ;M039; F.C. >32mb a 32 bit multiply	;AN000;
 22522                                  
 22523                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22524 00003B55 29C8                    	SUB     AX,CX			; Take off current "tail"
 22525 00003B57 83DA00                  	SBB     DX,0			; 32-bit extension
 22526 00003B5A 01D8                    	ADD     AX,BX			; Add on new "tail"
 22527 00003B5C 83D200                  	ADC     DX,0			; ripple tim's head off
 22528 00003B5F EB21                    	JMP     SHORT SETGRW
 22529                                  
 22530                                  HAVSTART:
 22531                                  	;int 3
 22532 00003B61 89C1                    	MOV     CX,AX
 22533 00003B63 E86D11                  	call	SKPCLP
 22534                                  	;JCXZ	DOWRTJ
 22535                                  	; 16/12/2022
 22536 00003B66 E357                    	jcxz	DOWRT
 22537                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 22538                                  	;jcxz	DOWRTJ
 22539                                  
 22540 00003B68 E80F13                  	call	ALLOCATE
 22541                                  	;JNC	short DOWRTJ
 22542                                  	; 16/12/2022
 22543 00003B6B 7352                    	jnc	short DOWRT
 22544                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 22545                                  	;jnc	short DOWRTJ
 22546                                  
 22547                                  	;entry   WRTERR
 22548                                  WRTERR:
 22549 00003B6D B40F                    	MOV     AH,0FH			;MS. write/data/fail/abort      ;AN000;
 22550                                  
 22551                                  	;entry WRTERR22
 22552                                  WRTERR22:
 22553 00003B6F A0[7605]                	MOV     AL,[THISDRV]		;MS.                            ;AN000;
 22554                                  
 22555                                  	; 27/07/2018
 22556                                  WRTERR33:
 22557                                  	;MOV	CX,0			;No bytes transferred
 22558 00003B72 31C9                    	XOR     CX,CX
 22559                                  					
 22560 00003B74 C43E[9E05]              	LES     DI,[THISSFT]
 22561                                  	;CLC ; 19/05/2019
 22562                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 22563                                  	; 16/12/2022
 22564                                  	;clc
 22565 00003B78 C3                      	retn
 22566                                  
 22567                                  	; 16/12/2022
 22568                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 22569                                  ;DOWRTJ:
 22570                                  	;JMP	short DOWRT
 22571                                  
 22572                                  ACC_ERRWJ:
 22573                                  	; 10/08/2018
 22574                                  	;JMP	SET_ACC_ERRW
 22575                                  	; 16/12/2022
 22576 00003B79 E9D7FD                  	jmp	SET_ACC_ERR_DS
 22577                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 22578                                  	;jmp	SET_ACC_ERRW	
 22579                                  
 22580                                  TESTTAIL:
 22581 00003B7C 29D0                    	SUB     AX,DX
 22582 00003B7E 7609                    	JBE	short NOGROW
 22583 00003B80 31D2                    	XOR     DX,DX
 22584                                  SETGRW:
 22585 00003B82 A3[DE05]                	MOV	[GROWCNT],AX
 22586 00003B85 8916[E005]              	MOV	[GROWCNT+2],DX
 22587                                  NOGROW:
 22588 00003B89 58                      	POP     AX
 22589 00003B8A 8B0E[BC05]              	MOV     CX,[CLUSNUM]    ; First cluster accessed
 22590 00003B8E E82211                  	call	FNDCLUS
 22591 00003B91 72E6                    	JC	short ACC_ERRWJ
 22592 00003B93 891E[BC05]              	MOV     [CLUSNUM],BX
 22593 00003B97 8916[BA05]              	MOV     [LASTPOS],DX
 22594                                  
 22595 00003B9B 29D0                    	SUB     AX,DX           ; Last cluster minus current cluster
 22596 00003B9D 7420                    	JZ	short DOWRT	; If we have last clus, we must have first
 22597 00003B9F E3C0                    	JCXZ    HAVSTART        ; See if no more data
 22598 00003BA1 51                      	PUSH    CX              ; No. of clusters short of first
 22599 00003BA2 89C1                    	MOV     CX,AX
 22600 00003BA4 E8D312                  	call	ALLOCATE
 22601 00003BA7 59                      	POP     CX
 22602 00003BA8 72C3                    	JC	short WRTERR
 22603 00003BAA 8B16[BA05]              	MOV     DX,[LASTPOS]
 22604 00003BAE 42                      	INC     DX
 22605 00003BAF 49                      	DEC     CX
 22606 00003BB0 7405                    	JZ	short NOSKIP
 22607 00003BB2 E81E11                  	call	SKPCLP
 22608 00003BB5 72C2                    	JC	short ACC_ERRWJ
 22609                                  NOSKIP:
 22610 00003BB7 891E[BC05]              	MOV     [CLUSNUM],BX
 22611 00003BBB 8916[BA05]              	MOV     [LASTPOS],DX
 22612                                  DOWRT:
 22613 00003BBF 833E[D205]00            	CMP     word [BYTCNT1],0
 22614 00003BC4 7409                    	JZ	short WRTMID
 22615 00003BC6 8B1E[BC05]              	MOV     BX,[CLUSNUM]
 22616 00003BCA E89511                  	call	BUFWRT
 22617 00003BCD 72AA                    	JC	short ACC_ERRWJ
 22618                                  WRTMID:
 22619 00003BCF A1[D605]                	MOV     AX,[SECCNT]
 22620 00003BD2 09C0                    	OR      AX,AX
 22621                                  	; 20/11/2022
 22622 00003BD4 746F                    	JZ	short WRTLAST	; 24/07/2019	;M039
 22623 00003BD6 0106[C405]              	ADD     [SECPOS],AX
 22624                                  	; 19/05/2019
 22625                                  	; MSDOS 6.0
 22626 00003BDA 8316[C605]00            	ADC	WORD [SECPOS+2],0	;F.C. >32mb 	;AN000;
 22627 00003BDF E8DC11                  	call	NEXTSEC
 22628                                  	; 16/12/2022
 22629 00003BE2 7295                    	JC	short ACC_ERRWJ
 22630                                  	;JC	short SET_ACC_ERRW	;M039
 22631 00003BE4 C606[7405]01            	MOV     BYTE [TRANS],1		; A transfer is taking place
 22632 00003BE9 8A16[7305]              	MOV     DL,[SECCLUSPOS] 	; (dx/DL = Extent start) ((dh = ?))
 22633 00003BED 8B1E[BC05]              	MOV     BX,[CLUSNUM]
 22634 00003BF1 8B0E[D605]              	MOV     CX,[SECCNT]
 22635                                  WRTLP:
 22636 00003BF5 E8F711                  	call	OPTIMIZE
 22637 00003BF8 7248                    	JC	short SET_ACC_ERRW
 22638                                  	; 16/12/2022
 22639                                  	;JC	short ACC_ERRWJ
 22640                                  
 22641                                  ;M039
 22642                                  ;       DI = Next physical cluster.
 22643                                  ;       AX = # sectors remaining.
 22644                                  ;       [DMAADD+2]:BX = transfer address (source data address).
 22645                                  ;       CX = # of contiguous sectors to write. (These constitute a block of
 22646                                  ;	     sectors, also termed an "Extent".)
 22647                                  ;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
 22648                                  ;       ES:BP -> Drive Parameter Block (DPB).
 22649                                  ;
 22650                                  ;       Purge the Buffer Queue and the Secondary Cache of any buffers which
 22651                                  ;	are in Extent; they are being over-written.
 22652                                  
 22653 00003BFA 57                      	push    di
 22654 00003BFB 50                      	push    ax
 22655                                  
 22656                                  	; MSDOS 3.3
 22657                                  	; IBMDOS.COM (1987) - Offset 4497h
 22658                                  	;push	dx
 22659                                  	;push	bx
 22660                                  	;mov	al,[es:bp]
 22661                                  	;;mov	AL,[ES:BP+DPB.DRIVE] ; mov al,[es:bp+0]
 22662                                  	;mov	bx,cx
 22663                                  	;add	bx,dx	; (bx = Extent end)
 22664                                  
 22665                                  ;	DX = Extent start.
 22666                                  ;	BX = Extent end.
 22667                                  ;	AL = Drive #.
 22668                                  
 22669                                  	;call	SETVISIT
 22670                                  
 22671                                  ;wbufq1:
 22672                                  	;;or	byte [di+5],20h
 22673                                  	;or	byte [DI+BUFFINFO.buf_flags],buf_visit ; Bit 5 = reserved
 22674                                  	;;cmp	al,[di+4]	
 22675                                  	;cmp	al,[DI+BUFFINFO.buf_ID]
 22676                                  	;jnz	short wbufq2	; Jump if Extent start > buffer sector.
 22677                                  	;;cmp	[di+6],dx
 22678                                  	;cmp	[DI+BUFFINFO.buf_sector],dx
 22679                                  	;jb	short wbufq2
 22680                                  	;;cmp	[di+6],bx
 22681                                  	;cmp	[DI+BUFFINFO.buf_sector],bx
 22682                                  	;jnb	short wbufq2	; Jump if Extent end >= buffer sector.
 22683                                  
 22684                                  	;; Buffer sector is in the Extent
 22685                                  
 22686                                  	;;mov	word [di+4],20FFh
 22687                                  	;mov	word [DI+BUFFINFO.buf_ID],20FFh
 22688                                  	;				; .buf_ID,    AL = FFh (Free buffer)
 22689                                  	;				; .buf_flags, AH = 0, reset/clear
 22690                                  	;call	SCANPLACE
 22691                                  ;wbufq2:
 22692                                  	;call	SKIPVISIT
 22693                                  	;jnz	short wbufq1
 22694                                  	;pop	bx
 22695                                  	;pop	dx
 22696                                  
 22697                                          ; MSDOS 6.0
 22698 00003BFC E82D01                  	call	DskWrtBufPurge		;DS trashed.
 22699                                  
 22700                                  ;ASSUME DS:NOTHING
 22701                                  ;M039
 22702                                  	; MSDOS 3.3 & MSDOS 6.0
 22703                                  ;hkn; SS override for DMAADD and ALLOWED
 22704 00003BFF 368E1E[2E03]            	MOV     DS,[SS:DMAADD+2]
 22705                                  	;mov	byte [ss:ALLOWED],38h
 22706 00003C04 36C606[4B03]38          	MOV	byte [SS:ALLOWED],Allowed_RETRY+Allowed_FAIL+Allowed_IGNORE
 22707                                  
 22708                                  ;	put logic from DWRITE in-line here so we can modify it
 22709                                  ;	for DISK FULL conditions.
 22710                                  
 22711                                  	; 20/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 22712                                  	; DOSCODE:7AD8h (MSDOS 5.0 MSDOS.SYS)
 22713                                  
 22714                                  	; 16/12/2022
 22715                                  	; MSDOS 3.3 (& MSDOS 5.0)
 22716                                  	;call	DWRITE
 22717                                  
 22718                                  ;DWRITE_OKAY:
 22719                                  
 22720                                  	; 16/12/2022
 22721                                  	; MSDOS 5.0 (& MSDOS 3.3)
 22722                                  	;pop     cx
 22723                                  	;pop     bx
 22724                                  	;push    ss
 22725                                  	;pop     ds
 22726                                  	;jc      short SET_ACC_ERRW
 22727                                  	;jcxz    WRTLAST
 22728                                  	;mov     dl, 0
 22729                                  	;inc     word [LASTPOS]
 22730                                  	;jmp     short WRTLP
 22731                                  
 22732                                  	; 16/12/2022
 22733                                  	; 20/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 22734                                  DWRITE_LUP:
 22735                                  	; 23/07/2019 - Retro DOS v3.2
 22736                                  
 22737                                  	; MSDOS 6.0
 22738 00003C0A E8E1FB                  	call	DSKWRITE
 22739 00003C0D 7417                    	jz	short DWRITE_OKAY
 22740                                  
 22741                                  ;;	int	3
 22742                                  
 22743 00003C0F 3C27                    	cmp	al,error_handle_Disk_Full	; compressed volume full?
 22744 00003C11 7423                    	jz	short DWRITE_DISK_FULL
 22745                                  
 22746                                  	; 16/12/2022
 22747                                  
 22748                                  ;;hkn; SS override
 22749 00003C13 36C606[7505]01          	MOV	BYTE [SS:READOP],1
 22750 00003C19 E801FC                  	call	HARDERRRW
 22751 00003C1C 3C01                    	CMP	AL,1		; Check for retry
 22752 00003C1E 74EA                    	JZ	short DWRITE_LUP
 22753                                  
 22754                                  	; 16/12/2022
 22755                                  	; 23/07/2019
 22756                                  	;POP	CX ; *4*
 22757                                  	;POP	BX ; *5*
 22758                                  	;
 22759                                  	;push	ss
 22760                                  	;pop	ds
 22761                                  	;
 22762                                  
 22763                                  	; 20/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 22764                                  
 22765                                  	; 16/12/2022
 22766 00003C20 3C03                    	CMP	AL,3		; Check for FAIL
 22767 00003C22 F8                      	CLC
 22768 00003C23 7501                    	JNZ	short DWRITE_OKAY ; Ignore
 22769 00003C25 F9                      	STC
 22770                                  
 22771                                  DWRITE_OKAY:
 22772                                  	; 16/12/2022
 22773                                  	; 23/07/2019
 22774                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22775 00003C26 59                      	POP	CX ; *4*
 22776 00003C27 5B                      	POP	BX ; *5*
 22777                                  
 22778                                  ;       CX = # sectors remaining.
 22779                                  ;       BX = Next physical cluster.
 22780                                  
 22781                                  ;hkn; SS override
 22782                                          ;Context DS
 22783                                  	; 16/12/2022
 22784                                  	;push	ss
 22785                                  	;pop	ds
 22786                                  
 22787                                  	; 16/12/2022
 22788 00003C28 7218                    	jc	short SET_ACC_ERRW
 22789                                  
 22790                                  	; 16/12/2022
 22791 00003C2A 16                      	push	ss
 22792 00003C2B 1F                      	pop	ds
 22793                                  
 22794 00003C2C E317                    	JCXZ    WRTLAST
 22795                                  
 22796                                  	;MOV	DL,0
 22797 00003C2E 30D2                    	xor	dl,dl ; 23/07/2019
 22798 00003C30 FF06[BA05]              	INC     word [LASTPOS]	; We'll be using next cluster
 22799 00003C34 EBBF                    	JMP     short WRTLP
 22800                                  
 22801                                  	; 23/07/2019 - Retro DOS v3.2
 22802                                  	; 09/08/2018
 22803                                  	; MSDOS 6.0
 22804                                  DWRITE_DISK_FULL:
 22805                                  	;Context DS		;SQ 3-5-93 DS must be setup on return!
 22806                                  	; 16/12/2022
 22807 00003C36 16                      	push	ss
 22808 00003C37 1F                      	pop	ds
 22809 00003C38 59                      	pop	cx		; unjunk stack
 22810 00003C39 5B                      	pop	bx
 22811 00003C3A C606[0B06]01            	mov	byte [DISK_FULL],1
 22812                                  	;stc
 22813 00003C3F E92BFF                  	jmp	WRTERR ; 24/07/2019 ; go to disk full exit
 22814                                  
 22815                                  	; 16/12/2022
 22816                                  SET_ACC_ERRW:
 22817 00003C42 E90EFD                  	jmp	SET_ACC_ERR_DS
 22818                                  
 22819                                  WRTLAST:
 22820 00003C45 A1[D405]                	MOV     AX,[BYTCNT2]
 22821 00003C48 09C0                    	OR      AX,AX
 22822 00003C4A 7413                    	JZ	short FINWRT
 22823 00003C4C A3[D205]                	MOV     [BYTCNT1],AX
 22824 00003C4F E86C11                  	call	NEXTSEC
 22825 00003C52 72EE                    	JC	short SET_ACC_ERRW
 22826 00003C54 C706[CC05]0000          	MOV     word [BYTSECPOS],0
 22827 00003C5A E80511                  	call	BUFWRT
 22828 00003C5D 72E3                    	JC	short SET_ACC_ERRW
 22829                                  FINWRT:
 22830 00003C5F C43E[9E05]              	LES     DI,[THISSFT]
 22831 00003C63 A1[DE05]                	MOV     AX,[GROWCNT]
 22832 00003C66 8B0E[E005]              	MOV     CX,[GROWCNT+2]
 22833 00003C6A 09C0                    	OR      AX,AX
 22834 00003C6C 7502                    	JNZ	short UPDATE_size
 22835 00003C6E E30F                    	JCXZ    SAMSIZ
 22836                                  UPDATE_size:
 22837                                  	;add	[es:di+11h],ax
 22838 00003C70 26014511                	ADD     [ES:DI+SF_ENTRY.sf_size],AX
 22839                                  	;adc	[es:di+13h],cx
 22840 00003C74 26114D13                	ADC     [ES:DI+SF_ENTRY.sf_size+2],CX
 22841                                  
 22842                                  ; Make sure that all other SFT's see this growth also.
 22843                                  
 22844 00003C78 B80100                  	MOV     AX,1
 22845                                  ;if installed
 22846                                  	;Call	JShare + 14 * 4
 22847 00003C7B FF1E[C800]              	call    far [JShare+(14*4)]	; 14 = ShSU
 22848                                  ;else
 22849                                  ;	Call    ShSU
 22850                                  ;endif
 22851                                  
 22852                                  SAMSIZ:
 22853 00003C7F E969FD                  	jmp	SETCLUS	; ES:DI already points to SFT
 22854                                  
 22855                                  	; 16/12/2022
 22856                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 22857                                  ;SET_ACC_ERRW:
 22858                                  	;jmp	SET_ACC_ERR_DS
 22859                                  
 22860                                  WRTEOF:
 22861 00003C82 89C1                    	MOV     CX,AX
 22862 00003C84 09D1                    	OR      CX,DX
 22863 00003C86 746C                    	JZ	short KILLFIL
 22864 00003C88 83E801                  	SUB     AX,1
 22865 00003C8B 83DA00                  	SBB     DX,0
 22866                                  
 22867                                  	; MSDOS 3.3
 22868                                  	;;div	word [es:bp+2]
 22869                                  	;div	word [ES:BP+DPB.SECTOR_SIZE]
 22870                                  	;;mov	cl,[es:bp+5]
 22871                                  	;mov	cl,[ES:BP+DPB.CLUSTER_SHIFT] 
 22872                                  	;shr	ax,cl
 22873                                  
 22874                                  	; MSDOS 6.0
 22875 00003C8E 53                      	PUSH	BX
 22876                                  	;mov	bx,[es:bp+2]
 22877 00003C8F 268B5E02                	MOV	BX,[ES:BP+DPB.SECTOR_SIZE]    ;F.C. >32mb                       ;AN000;
 22878 00003C93 E81C01                  	CALL	DIV32                         ;F.C. >32mb                       ;AN000;
 22879 00003C96 5B                      	POP	BX			      ;F.C. >32mb			;AN000;
 22880 00003C97 89CA                    	MOV	DX,CX			      ;M039
 22881 00003C99 890E[0706]                      MOV	[HIGH_SECTOR],CX              ;M039: Probably extraneous, but not sure.
 22882 00003C9D E83901                  	CALL	SHR32                         ;F.C. >32mb                       ;AN000;
 22883                                  
 22884 00003CA0 89C1                    	MOV     CX,AX
 22885 00003CA2 E80E10                  	call	FNDCLUS
 22886                                  SET_ACC_ERRWJ2:
 22887 00003CA5 729B                    	JC	short SET_ACC_ERRW
 22888                                  
 22889 00003CA7 E326                    	JCXZ    RELFILE
 22890 00003CA9 E8CE11                  	call	ALLOCATE
 22891                                  	;JC	short WRTERRJ              ;;;;;;;;; disk full
 22892                                  	; 16/12/2022
 22893 00003CAC 7303                    	jnc	short UPDATE
 22894 00003CAE E9BCFE                  	JMP	WRTERR
 22895                                  UPDATE:
 22896 00003CB1 C43E[9E05]              	LES	DI,[THISSFT]
 22897 00003CB5 A1[CE05]                	MOV	AX,[BYTPOS]
 22898                                  	;mov	[es:di+11h],ax
 22899 00003CB8 26894511                	MOV	[ES:DI+SF_ENTRY.sf_size],AX
 22900 00003CBC A1[D005]                	MOV	AX,[BYTPOS+2]
 22901                                  	;mov	[es:di+13h],ax
 22902 00003CBF 26894513                	MOV	[ES:DI+SF_ENTRY.sf_size+2],AX
 22903                                  ;
 22904                                  ; Make sure that all other SFT's see this growth also.
 22905                                  ;
 22906 00003CC3 B80200                  	MOV     AX,2
 22907                                  ;if installed
 22908                                  	;Call	JShare + 14 * 4
 22909 00003CC6 FF1E[C800]              	call    far [JShare+(14*4)]	; 14 = ShSU
 22910                                  ;else
 22911                                  ;	Call    ShSU
 22912                                  ;endif
 22913 00003CCA 31C9                    	XOR     CX,CX
 22914 00003CCC E939FD                  	jmp	ADDREC
 22915                                  
 22916                                  	; 16/12/2022
 22917                                  ;WRTERRJ: 
 22918                                  	;JMP	WRTERR
 22919                                  
 22920                                  ;;;;;;;;;;;;;;;; 7/18/86
 22921                                  ;;;;;;;;;;;;;;;;
 22922                                  
 22923                                  RELFILE:
 22924                                  	; MSDOS 6.0
 22925 00003CCF 06                      	PUSH    ES                    ;AN002; BL Reset Lstclus and cluspos to
 22926 00003CD0 C43E[9E05]              	LES     DI,[THISSFT]          ;AN002; BL beginning of file if current
 22927                                  	;cmp	dx,[es:di+19h]
 22928 00003CD4 263B5519                	CMP     DX,[ES:DI+SF_ENTRY.sf_cluspos]	;AN002; BL cluspos is past EOF.
 22929 00003CD8 730E                    	JAE	short SKIPRESET	      		;AN002; BL
 22930                                  	;mov	[es:di+19h],0
 22931 00003CDA 26C745190000            	MOV     word [ES:DI+SF_ENTRY.sf_cluspos],0 ;AN002; BL
 22932                                  	;mov	dx,[es:di+0Bh]
 22933 00003CE0 268B550B                	MOV     DX,[ES:DI+SF_ENTRY.sf_firclus]	;AN002; BL
 22934                                  	;mov	[es:di+35h],dx
 22935 00003CE4 26895535                	MOV     [ES:DI+SF_ENTRY.sf_lstclus],DX	;AN002; BL
 22936                                  SKIPRESET:                            		;AN002; BL
 22937 00003CE8 07                      	POP     ES                    		;AN002; BL
 22938                                  ;
 22939 00003CE9 BAFFFF                  	MOV     DX,0FFFFH
 22940 00003CEC E83912                  	call	RELBLKS
 22941                                  	; 16/12/2022
 22942                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 22943 00003CEF 73C0                    	jnc	short UPDATE
 22944                                  SET_ACC_ERRWJ:
 22945                                  	;JC	short SET_ACC_ERRWJ2
 22946                                  	;JMP	SHORT UPDATE
 22947                                  	; 16/12/2022
 22948 00003CF1 E95FFC                  	jmp	SET_ACC_ERR_DS
 22949                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 22950                                  	;JC	short SET_ACC_ERRWJ2
 22951                                  	;JMP	SHORT UPDATE
 22952                                  
 22953                                  KILLFIL:
 22954 00003CF4 31DB                    	XOR     BX,BX
 22955 00003CF6 06                      	PUSH    ES
 22956 00003CF7 C43E[9E05]              	LES     DI,[THISSFT]
 22957                                  	;mov	[es:di+19h],bx
 22958 00003CFB 26895D19                	MOV	[ES:DI+SF_ENTRY.sf_cluspos],BX
 22959                                  	;mov	[es:di+35h],bx ; 04/05/2019
 22960 00003CFF 26895D35                	MOV	[ES:DI+SF_ENTRY.sf_lstclus],BX
 22961                                  	;xchg	bx,[es:di+0Bh]
 22962 00003D03 26875D0B                	XCHG    BX,[ES:DI+SF_ENTRY.sf_firclus]
 22963 00003D07 07                      	POP	ES
 22964                                  
 22965 00003D08 09DB                    	OR	BX,BX
 22966                                  	;JZ	short UPDATEJ
 22967                                  	; 16/12/2022
 22968 00003D0A 74A5                    	jz	short UPDATE
 22969                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 22970                                  	;jz	short UPDATEJ
 22971                                  
 22972                                  ;; 10/23/86 FastOpen update
 22973 00003D0C 06                      	PUSH	ES              ; since first cluster # is 0
 22974 00003D0D 55                      	PUSH	BP              ; we must delete the old cache entry
 22975 00003D0E 50                      	PUSH	AX
 22976 00003D0F 51                      	PUSH	CX
 22977 00003D10 52                      	PUSH	DX
 22978 00003D11 C42E[8A05]              	LES	BP,[THISDPB]             ; get current DPB
 22979                                  	; 15/12/2022
 22980 00003D15 268A5600                	mov	dl,[ES:BP] ; mov dl,[es:bp+0]
 22981                                  	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 22982                                  	;MOV	DL,[ES:BP+DPB.DRIVE]	; get current drive
 22983 00003D19 89D9                    	MOV	CX,BX                    ; first cluster #
 22984 00003D1B B402                    	MOV	AH,2                     ; delete cache entry by drive:firclus
 22985 00003D1D E840EA                  	call	FastOpen_Update          ; call fastopen
 22986 00003D20 5A                      	POP	DX
 22987 00003D21 59                      	POP	CX
 22988 00003D22 58                      	POP	AX
 22989 00003D23 5D                      	POP	BP
 22990 00003D24 07                      	POP	ES
 22991                                  ;; 10/23/86 FastOpen update
 22992                                  
 22993 00003D25 E8FE11                  	call	RELEASE
 22994 00003D28 72C7                    	JC	short SET_ACC_ERRWJ
 22995                                  UPDATEJ:
 22996                                  	; 20/11/2022
 22997 00003D2A EB85                    	JMP	short UPDATE ; 10/08/2018
 22998                                  
 22999                                  ;Break   <DskWrtBufPurge -- Disk Write Buffer Purge>
 23000                                  ;----------------------------------------------------------------------------
 23001                                  ;
 23002                                  ; Procedure Name : DskWrtBufPurge
 23003                                  ;
 23004                                  ; Inputs:
 23005                                  ;       CX = # of contiguous sectors to write. (These constitute a block of
 23006                                  ;	     sectors, also termed an "Extent".)
 23007                                  ;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
 23008                                  ;       ES:BP -> Drive Parameter Block (DPB).
 23009                                  ;
 23010                                  ; Function:
 23011                                  ;       Purge the Buffer Queue and the Secondary Cache of any buffers which
 23012                                  ;	are in Extent; they are being over-written.
 23013                                  ;
 23014                                  ; Outputs:
 23015                                  ;       (Same as Input.)
 23016                                  ; Uses:
 23017                                  ;       All registers except DS,AX,SI,DI preserved.
 23018                                  ;       SS override for all global variables.
 23019                                  ;----------------------------------------------------------------------------
 23020                                  ;M039: Created
 23021                                  
 23022                                  ;procedure   DskWrtBufPurge,NEAR
 23023                                  ;
 23024                                  ;ASSUME  DS:NOTHING
 23025                                  
 23026                                  ; 04/05/2019 - Retro DOS v4.0
 23027                                  ; DOSCODE:7C0Eh (MSDOS 6.21, MSDOS.SYS)
 23028                                  
 23029                                  ; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 23030                                  ; DOSCODE:7BD4h (MSDOS 5.0, MSDOS.SYS) 
 23031                                  
 23032                                  DskWrtBufPurge:
 23033                                  	;SaveReg <bx,cx>
 23034 00003D2C 53                      	push	bx
 23035 00003D2D 51                      	push	cx
 23036                                  
 23037 00003D2E 368B1E[0706]            	mov	bx,[ss:HIGH_SECTOR]	;BX:DX = Extent start (sector #).
 23038 00003D33 89DE                    	mov	si,bx
 23039 00003D35 01D1                    	add	cx,dx
 23040 00003D37 83D600                  	adc	si,0                    ;SI:CX = Extent end + 1.
 23041                                  
 23042                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 23043                                  	;;mov	al,[es:bp+0]
 23044                                  	;mov	al,[es:bp+DPB.DRIVE]
 23045                                  	; 15/12/2022
 23046 00003D3A 268A4600                	mov	al,[es:bp]
 23047                                  
 23048                                  ;	BX:DX = Extent start.
 23049                                  ;	SI:CX = Extent end + 1.
 23050                                  ;	AL = Drive #
 23051                                  
 23052 00003D3E 36833E[7700]00          	cmp	word [ss:SC_CACHE_COUNT],0 ;Secondary cache in-use?
 23053 00003D44 7431                    	je	short nosc		; -no, jump.
 23054                                  
 23055                                  ;	If any of the sectors to be written are in the secondary cache (SC),
 23056                                  ;	invalidate the entire SC. (This is an optimization; we really only
 23057                                  ;	need to invalidate those sectors which intersect, but that's slower.)
 23058                                  
 23059 00003D46 363A06[B00D]            	cmp	al,[ss:CurSC_DRIVE]	;Same drive?
 23060 00003D4B 752A                    	jne	short nosc		; -no, jump.
 23061                                  
 23062 00003D4D 50                      	push    ax
 23063 00003D4E 36A1[B10D]              	mov     ax,[ss:CurSC_SECTOR]
 23064 00003D52 368B3E[B30D]            	mov     di,[ss:CurSC_SECTOR+2]	;DI:AX = SC start.
 23065                                  
 23066                                  	;Cmp32	si,cx,di,ax		;Extent end < SC start?
 23067                                  	;jbe	short sc5		; -yes, jump.
 23068                                  
 23069 00003D57 39FE                    	cmp	si,di
 23070 00003D59 7502                    	jne	short sc01
 23071 00003D5B 39C1                    	cmp	cx,ax
 23072                                  sc01: 
 23073 00003D5D 7617                    	jbe	short sc5	
 23074                                  
 23075 00003D5F 360306[7700]            	add	ax,[ss:SC_CACHE_COUNT]
 23076 00003D64 83D700                  	adc	di,0                    ;DI:AX = SC end + 1.
 23077                                  	
 23078                                  	;Cmp32	bx,dx,di,ax             ;Extent start > SC end?
 23079                                  	;jae	short sc5		; -yes, jump.
 23080                                  
 23081 00003D67 39FB                    	cmp	bx,di
 23082 00003D69 7502                    	jne	short sc02
 23083 00003D6B 39C2                    	cmp	dx,ax
 23084                                  sc02:
 23085 00003D6D 7307                    	jnb	short sc5
 23086                                  
 23087 00003D6F 36C706[B50D]0000        	mov	word [ss:SC_STATUS],0	;Extent intersects SC: invalidate SC.
 23088                                  sc5:	
 23089 00003D76 58                      	pop     ax
 23090                                  
 23091                                  ;	Free any buffered sectors which are in Extent; they are being over-
 23092                                  ;	written.
 23093                                  
 23094                                  nosc:	
 23095 00003D77 E8CA1B                  	call	GETCURHEAD		;DS:DI -> first buffer in queue.
 23096                                  
 23097                                  _bufq:	
 23098                                  	;cmpo	al,[di+4]
 23099 00003D7A 3A4504                  	cmp     al,[di+BUFFINFO.buf_ID] ;Same drive?
 23100 00003D7D 7527                    	jne	short bufq5		; -no, jump.
 23101                                  
 23102                                  ;       Cmp32   bx,dx,<WORD PTR [di.buf_sector+2]>,<WORD PTR [di.buf_sector]>
 23103                                  ;       ja	short bufq5		;Jump if Extent start > buffer sector.
 23104                                  
 23105                                  	;cmp	bx,[di+8]
 23106 00003D7F 3B5D08                  	cmp	bx,[di+BUFFINFO.buf_sector+2]
 23107 00003D82 7503                    	jne	short bufq04
 23108                                  	;cmp	dx,[di+6]
 23109 00003D84 3B5506                  	cmp	dx,[di+BUFFINFO.buf_sector]
 23110                                  bufq04:
 23111 00003D87 771D                    	ja	short bufq5
 23112                                  
 23113                                  ;       Cmp32   si,cx,<WORD PTR [di.buf_sector+2]>,<WORD PTR [di.buf_sector]>
 23114                                  ;       jbe	short bufq5		;Jump if Extent end < buffer sector.
 23115                                  
 23116                                  	;cmp	si,[di+8]
 23117 00003D89 3B7508                  	cmp	si,[di+BUFFINFO.buf_sector+2]
 23118 00003D8C 7503                    	jne	short bufq05
 23119                                  	;cmp	cx,[di+6]
 23120 00003D8E 3B4D06                  	cmp	cx,[di+BUFFINFO.buf_sector]
 23121                                  bufq05:
 23122 00003D91 7613                    	jbe	short bufq5
 23123                                  
 23124                                  ;	Buffer's sector is in Extent, so free it; it is being over-written.
 23125                                  
 23126                                  	;test	byte [di+5],40h
 23127 00003D93 F6450540                	test	byte [di+BUFFINFO.buf_flags],buf_dirty ;Buffer dirty?
 23128 00003D97 7403                    	jz	short bufq4		; -no, jump.
 23129 00003D99 E8291E                  	call	DEC_DIRTY_COUNT		; -yes, decrement dirty count.
 23130                                  bufq4:
 23131                                  	;mov	word [di+4],20FFh
 23132 00003D9C C74504FF20              	mov     word [di+BUFFINFO.buf_ID],((buf_visit<<8)|0FFh)
 23133                                  
 23134 00003DA1 E8B21B                  	call	SCANPLACE
 23135 00003DA4 EB02                    	jmp     short bufq6
 23136                                  bufq5: 
 23137 00003DA6 8B3D                    	mov     di,[di]
 23138                                  	;mov	di,[di+BUFFINFO.buf_next]
 23139                                  bufq6: 
 23140 00003DA8 363B3E[BA0E]            	cmp	di,[ss:FIRST_BUFF_ADDR]	;Scanned entire buffer queue?
 23141 00003DAD 75CB                    	jne	short _bufq		; --no, go do next buffer.
 23142                                  	
 23143                                  	;RestoreReg <cx,bx>
 23144 00003DAF 59                      	pop	cx
 23145 00003DB0 5B                      	pop	bx
 23146 00003DB1 C3                      	retn
 23147                                  
 23148                                  ;EndProc DskWrtBufPurge
 23149                                  
 23150                                  ;Break   <DIV32 -- PERFORM 32 BIT DIVIDE>
 23151                                  ;----------------------------------------------------------------------------
 23152                                  ;
 23153                                  ; Procedure Name : DIV32
 23154                                  ;
 23155                                  ; Inputs:
 23156                                  ;       DX:AX = 32 bit dividend   BX= divisor
 23157                                  ; Function:
 23158                                  ;       Perform 32 bit division:  DX:AX/BX = CX:AX + DX (rem.)
 23159                                  ; Outputs:
 23160                                  ;       CX:AX = quotient , DX= remainder
 23161                                  ; Uses:
 23162                                  ;       All registers except AX,CX,DX preserved.
 23163                                  ;----------------------------------------------------------------------------
 23164                                  ;M039: DIV32 optimized for divisor of 512 (common sector size).
 23165                                  
 23166                                  ; 04/05/2019 - Retro DOS v4.0
 23167                                  ; DOSCODE:7C94h (MSDOS 6.21, MSDOS.SYS)
 23168                                  
 23169                                  ; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 23170                                  ; DOSCODE:7C5Ah (MSDOS 5.0, MSDOS.SYS) 
 23171                                  
 23172                                  DIV32:
 23173 00003DB2 81FB0002                	cmp	bx,512
 23174 00003DB6 7515                    	jne	short div5
 23175                                  
 23176 00003DB8 89D1                    	mov	cx,dx
 23177 00003DBA 89C2                    	mov	dx,ax           ; CX:AX = Dividend
 23178 00003DBC 81E2FF01                	and	dx,(512-1)      ; DX = Remainder
 23179 00003DC0 88E0                    	mov	al,ah
 23180 00003DC2 88CC                    	mov	ah,cl
 23181 00003DC4 88E9                    	mov	cl,ch
 23182 00003DC6 30ED                    	xor	ch,ch
 23183 00003DC8 D1E9                    	shr	cx,1
 23184 00003DCA D1D8                    	rcr	ax,1
 23185 00003DCC C3                      	retn
 23186                                  div5:	
 23187 00003DCD 89C1                    	mov	cx,ax
 23188 00003DCF 89D0                    	mov	ax,dx
 23189 00003DD1 31D2                    	xor	dx,dx
 23190 00003DD3 F7F3                    	div	bx              ; 0:AX/BX
 23191 00003DD5 91                      	xchg	cx,ax
 23192 00003DD6 F7F3                    	div	bx              ; DX:AX/BX
 23193 00003DD8 C3                      	retn
 23194                                  
 23195                                  ;Break   <SHR32 -- PERFORM 32 BIT SHIFT RIGHT>
 23196                                  ;----------------------------------------------------------------------------
 23197                                  ;
 23198                                  ; Procedure Name : SHR32
 23199                                  ;
 23200                                  ; Inputs:
 23201                                  ;	DX:AX = 32 bit sector number
 23202                                  ; Function:
 23203                                  ;       Perform 32 bit shift right
 23204                                  ; Outputs:
 23205                                  ;	AX = cluster number
 23206                                  ;	ZF = 1 if no error
 23207                                  ;	   = 0 if error (cluster number > 64k)
 23208                                  ; Uses:
 23209                                  ;       DX,CX
 23210                                  ;---------------------------------------------------------------------------
 23211                                  ; M017	- SHR32 rewritten for better performance
 23212                                  ; M039	- Additional optimization
 23213                                  
 23214                                  ; 04/05/2019 - Retro DOS v4.0
 23215                                  ; DOSCODE:7CBBh (MSDOS 6.21, MSDOS.SYS)
 23216                                  ; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 23217                                  ; DOSCODE:7C81h (MSDOS 5.0, MSDOS.SYS) 
 23218                                  
 23219                                  SHR32:
 23220                                  	;mov	cl,[es:bp+5]
 23221 00003DD9 268A4E05                	mov	cl,[ES:BP+DPB.CLUSTER_SHIFT]
 23222 00003DDD 30ED                    	xor	ch,ch	    ;ZF=1
 23223 00003DDF E306                    	jcxz	norota
 23224                                  
 23225                                  rotashft2:
 23226 00003DE1 D1EA                    	shr	dx,1	    ;ZF reflects state of DX.
 23227 00003DE3 D1D8                    	rcr	ax,1	    ;ZF not affected.
 23228 00003DE5 E2FA                    	loop	rotashft2
 23229                                  norota:
 23230 00003DE7 C3                      	retn
 23231                                  
 23232                                  ;============================================================================
 23233                                  ; DIR.ASM, MSDOS 6.0, 1991
 23234                                  ;============================================================================
 23235                                  ; 27/07/2018 - Retro DOS v3.0
 23236                                  ; 19/05/2019 - Retro DOS v4.0 
 23237                                  
 23238                                  ;	TITLE	DIR - Directory and path cracking
 23239                                  ;	NAME	Dir
 23240                                  
 23241                                  ;Break	<FINDENTRY -- LOOK FOR AN ENTRY>
 23242                                  ;---------------------------------------------------------------------------
 23243                                  ;
 23244                                  ; Procedure Name : FINDENTRY,SEARCH
 23245                                  ;
 23246                                  ; Inputs:
 23247                                  ;	[THISDPB] set
 23248                                  ;	[SECCLUSPOS] = 0
 23249                                  ;	[DIRSEC] = Starting directory sector number
 23250                                  ;	[CLUSNUM] = Next cluster of directory
 23251                                  ;	[CLUSFAC] = Sectors/Cluster
 23252                                  ;	[NAME1] = Name to look for
 23253                                  ; Function:
 23254                                  ;	Find file name in disk directory.
 23255                                  ;	"?" matches any character.
 23256                                  ; Outputs:
 23257                                  ;	Carry set if name not found
 23258                                  ;	ELSE
 23259                                  ;	Zero set if attributes match (always except when creating)
 23260                                  ;	AH = Device ID (bit 7 set if not disk)
 23261                                  ;	[THISDPB] = Base of drive parameters
 23262                                  ;	DS = DOSGROUP
 23263                                  ;	ES = DOSGROUP
 23264                                  ;	[CURBUF+2]:BX = Pointer into directory buffer
 23265                                  ;	[CURBUF+2]:SI = Pointer to First Cluster field in directory entry
 23266                                  ;	[CURBUF] has directory record with match
 23267                                  ;	[NAME1] has file name
 23268                                  ;	[LASTENT] is entry number of the entry
 23269                                  ; All other registers destroyed.
 23270                                  ;----------------------------------------------------------------------------
 23271                                  
 23272                                  ;hkn; called from rename.asm and dir2.asm. DS must be already set up at
 23273                                  ;hkn; this point.
 23274                                  
 23275                                  SEARCH:
 23276                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 23277                                  	; DOSCODE:7C90h (MSDOS 5.0, MSDOS.SYS) 
 23278                                  
 23279                                  	; 19/05/2019 - Retro DOS v4.0
 23280                                  	; DOSCODE:7CCA (MSDOS 6.21, MSDOS.SYS)
 23281                                  
 23282                                  	; 27/07/2018 - Retro DOS v3.0
 23283                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 45B3h 
 23284                                  	; 15/03/2018 - Retro DOS v2.0
 23285                                  
 23286                                  	;entry	FindEntry
 23287                                  FINDENTRY:
 23288 00003DE8 E82E04                  	call	STARTSRCH
 23289 00003DEB A0[6B05]                	MOV	AL,[ATTRIB]
 23290                                  	;and	al,9Eh
 23291 00003DEE 24DE                    	AND	AL,~attr_ignore		; Ignore useless bits
 23292                                  	;cmp	al,8
 23293 00003DF0 3C08                    	CMP	AL,attr_volume_id	; Looking for vol ID only ?
 23294 00003DF2 7503                    	JNZ	short NOTVOLSRCH	; No
 23295 00003DF4 E86D01                  	CALL	SETROOTSRCH		; Yes force search of root
 23296                                  NOTVOLSRCH:
 23297 00003DF7 E8FD00                  	CALL	GETENTRY
 23298 00003DFA 7303                    	JNC	short SRCH
 23299 00003DFC E99100                  	JMP	SETESRET
 23300                                  
 23301                                  	;entry	Srch
 23302                                  SRCH:
 23303 00003DFF 1E                      	PUSH	DS
 23304 00003E00 8E1E[E405]              	MOV	DS,[CURBUF+2]
 23305                                  
 23306                                  ;	(DS:BX) = directory entry address
 23307                                  
 23308 00003E04 8A27                    	mov	ah,[BX]
 23309                                  	;MOV	AH,[BX+dir_entry.dir_name] ; mov ah,[bx+0]
 23310 00003E06 08E4                    	OR	AH,AH			; End of directory?
 23311 00003E08 7436                    	JZ	short FREE
 23312                                  
 23313                                  ;hkn; SS override
 23314 00003E0A 363A26[7F05]            	CMP	AH,[SS:DELALL]		; Free entry?
 23315 00003E0F 742F                    	JZ	short FREE
 23316                                  	;test	byte [bx+0Bh],8
 23317 00003E11 F6470B08                	TEST	byte [BX+dir_entry.dir_attr],attr_volume_id
 23318                                  					; Volume ID file?
 23319 00003E15 7405                    	JZ	short CHKFNAM 		; NO
 23320                                  
 23321                                  ;hkn; SS override
 23322 00003E17 36FE06[7B05]            	INC	BYTE [SS:VOLID]
 23323                                  CHKFNAM:
 23324                                  ;	Context ES
 23325 00003E1C 8CD6                    	MOV	SI,SS
 23326 00003E1E 8EC6                    	MOV	ES,SI
 23327 00003E20 89DE                    	MOV	SI,BX
 23328                                  
 23329                                  ;hkn; NAME1 is in DOSDATA
 23330 00003E22 BF[4B05]                	MOV	DI,NAME1
 23331                                  ;;;;; 7/29/86
 23332                                  
 23333                                  ;hkn; SS override for NAME1
 23334                                  	;CMP	BYTE [SS:NAME1],0E5H	; special char check
 23335                                  	;JNZ	short NO_E5
 23336                                  	;MOV	BYTE [SS:NAME1],05H
 23337                                  	; 22/09/2023
 23338 00003E25 26803DE5                	cmp	byte [es:di],0E5h
 23339 00003E29 7504                    	jnz	short NO_E5
 23340 00003E2B 26C60505                	mov	byte [es:di],05h
 23341                                  NO_E5:
 23342                                  ;;;;; 7/29/86
 23343 00003E2F E86100                  	CALL	MetaCompare
 23344 00003E32 7428                    	JZ	short FOUND
 23345 00003E34 1F                      	POP	DS
 23346                                  
 23347                                  	;entry	NEXTENT
 23348                                  NEXTENT:
 23349 00003E35 C42E[8A05]              	LES	BP,[THISDPB]
 23350 00003E39 E86600                  	CALL	NEXTENTRY
 23351 00003E3C 73C1                    	JNC	short SRCH
 23352 00003E3E EB50                    	JMP	SHORT SETESRET
 23353                                  
 23354                                  FREE:
 23355 00003E40 1F                      	POP	DS
 23356 00003E41 8B0E[4803]              	MOV	CX,[LASTENT]
 23357 00003E45 3B0E[D805]              	CMP	CX,[ENTFREE]
 23358 00003E49 7304                    	JAE	short TSTALL
 23359 00003E4B 890E[D805]              	MOV	[ENTFREE],CX
 23360                                  TSTALL:
 23361 00003E4F 3A26[7F05]              	CMP	AH,[DELALL]		; At end of directory?
 23362                                  NEXTENTJ:
 23363 00003E53 74E0                    	je	short NEXTENT 		; No - continue search
 23364 00003E55 890E[DA05]              	MOV	[ENTLAST],CX
 23365 00003E59 F9                      	STC
 23366 00003E5A EB34                    	JMP	SHORT SETESRET
 23367                                  
 23368                                  FOUND:
 23369                                  ; We have a file with a matching name. We must now consider the attributes:
 23370                                  ; ATTRIB	Action
 23371                                  ; ------	------
 23372                                  ; Volume_ID	Is Volume_ID in test?
 23373                                  ; Otherwise	If no create then Is ATTRIB+extra superset of test?
 23374                                  ;		If create then Is ATTRIB equal to test?
 23375                                  
 23376 00003E5C 8A2C                    	MOV	CH,[SI] 		; Attributes of file
 23377 00003E5E 1F                      	POP	DS
 23378 00003E5F 8A26[6B05]              	MOV	AH,[ATTRIB]		; Attributes of search
 23379                                  	;and	ah,9Eh
 23380 00003E63 80E4DE                  	AND	AH,~attr_ignore
 23381                                  	;lea	si,[si+15]
 23382 00003E66 8D740F                  	LEA	SI,[SI+dir_entry.dir_first-dir_entry.dir_attr]
 23383                                  					; point to first cluster field
 23384                                  	;test	ch,8
 23385 00003E69 F6C508                  	TEST	CH,attr_volume_id	; Volume ID file?
 23386 00003E6C 7409                    	JZ	short check_one_volume_id ; Nope check other attributes
 23387                                  	;test	ah,8
 23388 00003E6E F6C408                  	TEST	AH,attr_volume_id	; Can we find Volume ID?
 23389                                  	;JZ	short NEXTENTJ		; Nope, (not even $FCB_CREATE)
 23390                                  	; 16/12/2022
 23391 00003E71 74C2                    	jz	short NEXTENT ; 19/05/2019
 23392                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 23393                                  	;JZ	short NEXTENTJ
 23394 00003E73 30E4                    	XOR	AH,AH			; Set zero flag for $FCB_CREATE
 23395 00003E75 EB11                    	JMP	SHORT RETFF		; Found Volume ID
 23396                                  check_one_volume_id:
 23397                                  	;CMP	ah,8
 23398 00003E77 80FC08                  	CMP	AH,attr_volume_id	; Looking only for Volume ID?
 23399                                  	;JZ	short NEXTENTJ		; Yes, continue search
 23400                                  	; 16/12/2022
 23401 00003E7A 74B9                    	je	short NEXTENT ; 19/05/2019
 23402                                  	;JZ	short NEXTENTJ
 23403 00003E7C E8AE03                  	CALL	MatchAttributes
 23404 00003E7F 7407                    	JZ	SHORT RETFF
 23405 00003E81 F606[7E05]FF            	TEST	BYTE [CREATING],-1	; Pass back mismatch if creating
 23406                                  	; 16/12/2022
 23407                                  	;JZ	short NEXTENTJ		; Otherwise continue searching
 23408 00003E86 74AD                    	jz	short NEXTENT ; 19/05/2019
 23409                                  RETFF:
 23410 00003E88 C42E[8A05]              	LES	BP,[THISDPB]
 23411                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 23412                                  	;MOV	AH,[ES:BP+DPB.DRIVE]  ; mov ah,[es:bp+0]
 23413                                  	; 15/12/2022
 23414 00003E8C 268A6600                	MOV	AH,[ES:BP]
 23415                                  SETESRET:
 23416 00003E90 16                      	PUSH	SS
 23417 00003E91 07                      	POP	ES
 23418 00003E92 C3                      	retn
 23419                                  
 23420                                  ;----------------------------------------------------------------------------
 23421                                  ;
 23422                                  ; Procedure Name : MetaCompare
 23423                                  ;
 23424                                  ; Inputs:
 23425                                  ;	DS:SI -> 11 character FCB style name NO '?'
 23426                                  ;	    Typically this is a directory entry. It MUST be in upper case
 23427                                  ;	ES:DI -> 11 character FCB style name with possible '?'
 23428                                  ;	    Typically this is a FCB or SFT. It MUST be in upper case
 23429                                  ; Function:
 23430                                  ;	Compare FCB style names allowing for ? match to any char
 23431                                  ; Outputs:
 23432                                  ;	Zero if match else NZ
 23433                                  ; Destroys CX,SI,DI all others preserved
 23434                                  ;----------------------------------------------------------------------------
 23435                                  
 23436                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 23437                                  	; DOSCODE:7D3Fh (MSDOS 5.0, MSDOS.SYS) 
 23438                                  
 23439                                  MetaCompare:
 23440 00003E93 B90B00                  	MOV	CX,11
 23441                                  WILDCRD:
 23442 00003E96 F3A6                    	REPE	CMPSB
 23443 00003E98 7407                    	JZ	short MetaRet 		; most of the time we will fail.
 23444                                  CHECK_META:
 23445 00003E9A 26807DFF3F              	CMP	BYTE [ES:DI-1],"?"
 23446 00003E9F 74F5                    	JZ	short WILDCRD
 23447                                  MetaRet:
 23448 00003EA1 C3                       	retn				; Zero set, Match
 23449                                  
 23450                                  ;Break	<NEXTENTRY -- STEP THROUGH DIRECTORY>
 23451                                  ;----------------------------------------------------------------------------
 23452                                  ;
 23453                                  ; Procedure Name : NEXTENTRY
 23454                                  ;
 23455                                  ; Inputs:
 23456                                  ;	Same as outputs of GETENTRY, above
 23457                                  ; Function:
 23458                                  ;	Update BX, and [LASTENT] for next directory entry.
 23459                                  ;	Carry set if no more.
 23460                                  ;----------------------------------------------------------------------------
 23461                                  
 23462                                  NEXTENTRY:
 23463                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 23464                                  	; DOSCODE:7D4Eh (MSDOS 5.0, MSDOS.SYS) 
 23465                                  
 23466                                  	; 19/05/2019 - Retro DOS v4.0
 23467                                  	; DOSCODE:7D88h (MSDOS 6.21, MSDOS.SYS)
 23468                                  
 23469                                  	; 27/07/2018 - Retro DOS v3.0
 23470                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 4671h 
 23471                                  	; 15/03/2018 - Retro DOS v2.0
 23472                                  
 23473 00003EA2 A1[4803]                	MOV	AX,[LASTENT]
 23474 00003EA5 3B06[DA05]              	CMP	AX,[ENTLAST]
 23475 00003EA9 7422                    	JZ	short NONE
 23476 00003EAB 40                      	INC	AX
 23477                                  	;ADD	BX,32
 23478 00003EAC 8D5F20                  	LEA	BX,[BX+32]
 23479 00003EAF 39D3                    	CMP	BX,DX
 23480                                  	; 21/11/2022 - MSDOS 5.0 MSDOS.SYS (DOSCODE:7D5Dh)
 23481                                  	;JB	short HAVIT ; MSDOS 6.0 src (dir.asm)
 23482                                  	; 16/12/2022
 23483 00003EB1 751C                    	jne	short HAVIT ; MSDOS 6.21 (DOSCODE:7D97h)
 23484 00003EB3 8A1E[7305]              	MOV	BL,[SECCLUSPOS]
 23485 00003EB7 FEC3                    	INC	BL
 23486 00003EB9 3A1E[7705]              	CMP	BL,[CLUSFAC]
 23487 00003EBD 7215                    	JB	short SAMECLUS
 23488 00003EBF 8B1E[DC05]              	MOV	BX,[NXTCLUSNUM]
 23489 00003EC3 E8C716                  	call	IsEOF
 23490 00003EC6 7305                    	JAE	short NONE
 23491                                  	; 23/07/2019
 23492 00003EC8 83FB02                  	CMP	BX,2
 23493                                  	;JB	short NONE
 23494                                  	;JMP	short GETENT
 23495                                  	; 16/12/2022
 23496 00003ECB 732D                    	jnb	short GETENT
 23497                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 23498                                  	;JB	short NONE
 23499                                  	;JMP	short GETENT
 23500                                  NONE:
 23501 00003ECD F9                      	STC
 23502 00003ECE C3                      	retn
 23503                                  HAVIT:
 23504 00003ECF A3[4803]                	MOV	[LASTENT],AX
 23505 00003ED2 F8                      	CLC
 23506                                  nextentry_retn:
 23507 00003ED3 C3                      	retn
 23508                                  SAMECLUS:
 23509 00003ED4 881E[7305]              	MOV	[SECCLUSPOS],BL
 23510 00003ED8 A3[4803]                	MOV	[LASTENT],AX
 23511 00003EDB 1E                      	PUSH	DS
 23512 00003EDC C53E[E205]              	LDS	DI,[CURBUF]
 23513                                  	; 19/05/2019
 23514                                  	; MSDOS 6.0
 23515                                  	;;mov	dx,[di+8]
 23516                                  	; 23/09/2023
 23517                                  	;MOV	DX,[DI+BUFFINFO.buf_sector+2]	;AN000; >32mb
 23518                                  ;hkn; SS override
 23519                                  	;MOV	[SS:HIGH_SECTOR],DX 		;AN000; >32mb
 23520                                  	; 23/09/2023
 23521 00003EE0 8B7508                  	mov	si,[di+BUFFINFO.buf_sector+2]	
 23522                                  	
 23523                                  	;mov	dx,[di+6]
 23524 00003EE3 8B5506                  	MOV	DX,[DI+BUFFINFO.buf_sector]	;AN000; >32mb
 23525                                  	;inc	dx ; MSDOS 3.3
 23526                                  	; MSDOS 6.0
 23527                                  	;ADD	DX,1				;AN000; >32mb
 23528                                  	;ADC	word [SS:HIGH_SECTOR],0 	;AN000; >32mb
 23529                                  	; 23/09/2023
 23530 00003EE6 42                      	inc	dx
 23531 00003EE7 7501                    	jnz	short nextexntry_fc
 23532 00003EE9 46                      	inc	si
 23533                                  	;inc	word [SS:HIGH_SECTOR]
 23534                                  nextexntry_fc:
 23535                                  	; 23/09/2023
 23536 00003EEA 368936[0706]            	mov	[SS:HIGH_SECTOR],si
 23537                                  	; MSDOS 3.3 & MSDOS 6.0
 23538 00003EEF 1F                      	POP	DS
 23539 00003EF0 E844F8                  	call	FIRSTCLUSTER
 23540 00003EF3 31DB                    	XOR	BX,BX
 23541 00003EF5 EB23                    	JMP	short SETENTRY
 23542                                  
 23543                                  ;----------------------------------------------------------------------------
 23544                                  ;
 23545                                  ; Procedure Name : GETENTRY
 23546                                  ;
 23547                                  ; Inputs:
 23548                                  ;	[LASTENT] has directory entry
 23549                                  ;	ES:BP points to drive parameters
 23550                                  ;	[DIRSEC],[CLUSNUM],[CLUSFAC],[ENTLAST] set for DIR involved
 23551                                  ; Function:
 23552                                  ;	Locates directory entry in preparation for search
 23553                                  ;	GETENT provides entry for passing desired entry in AX
 23554                                  ; Outputs:
 23555                                  ;	[CURBUF+2]:BX = Pointer to next directory entry in CURBUF
 23556                                  ;	[CURBUF+2]:DX = Pointer to first byte after end of CURBUF
 23557                                  ;	[LASTENT] = New directory entry number
 23558                                  ;	[NXTCLUSNUM],[SECCLUSPOS] set via DIRREAD
 23559                                  ;	Carry set if error (currently user FAILed to I 24)
 23560                                  ;----------------------------------------------------------------------------
 23561                                  
 23562                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 23563                                  GETENTRY:
 23564                                  	; 27/07/2018 - Retro DOS v3.0
 23565 00003EF7 A1[4803]                	MOV	AX,[LASTENT]
 23566                                  
 23567                                  	;entry	GETENT
 23568                                  GETENT:
 23569 00003EFA A3[4803]                	MOV	[LASTENT],AX
 23570                                  ;
 23571                                  ; Convert the entry number in AX into a byte offset from the beginning of the
 23572                                  ; directory.
 23573                                  ;
 23574 00003EFD B105                    	mov	cl,5			; shift left by 5 = mult by 32
 23575 00003EFF D3C0                    	rol	ax,cl			; keep hight order bits
 23576 00003F01 89C2                    	mov	dx,ax
 23577                                  	; 19/05/2019 - Retro DOS v4.0
 23578                                  	;and	ax,0FFE0h
 23579                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 23580                                  	;and	ax,~(32-1)		; mask off high order bits
 23581                                  	; 16/12/2022
 23582 00003F03 24E0                    	and	al,0E0h ; ~31
 23583 00003F05 83E21F                  	and	dx,1Fh
 23584                                  	;and	dx,32-1			; mask off low order bits
 23585                                  ;
 23586                                  ; DX:AX contain the byte offset of the required directory entry from the
 23587                                  ; beginning of the directory. Convert this to a sector number. Round the
 23588                                  ; sector size down to a multiple of 32.
 23589                                  ;
 23590                                  	;mov	bx,[es:bp+2]
 23591 00003F08 268B5E02                	MOV	BX,[ES:BP+DPB.SECTOR_SIZE]
 23592 00003F0C 80E3E0                  	and	bl,0E0h
 23593                                  	;AND	BL,255-31		; Must be multiple of 32
 23594 00003F0F F7F3                    	DIV	BX
 23595 00003F11 89D3                    	MOV	BX,DX			; Position within sector
 23596 00003F13 53                      	PUSH	BX
 23597 00003F14 E8CCF7                  	call	DIRREAD
 23598 00003F17 5B                      	POP	BX
 23599                                  	;retc
 23600 00003F18 72B9                    	jc	short nextentry_retn	
 23601                                  SETENTRY:
 23602 00003F1A 8B16[E205]              	MOV	DX,[CURBUF]
 23603                                  	;add	dx,16 ; MSDOS 3.3
 23604                                  	;add	dx,20 ; MSDOS 6.0 
 23605 00003F1E 83C214                  	ADD	DX,BUFINSIZ
 23606 00003F21 01D3                    	ADD	BX,DX
 23607                                  	;add	dx,[es:bp+2]
 23608 00003F23 26035602                	ADD	DX,[ES:BP+DPB.SECTOR_SIZE]  ; Always clears carry
 23609                                  	; 29/12/2022
 23610                                  	; MSDOS 6.21 MSDOS.SYS contains a 'CLC' here, at DOSCODE:7E15h
 23611 00003F27 F8                      	clc
 23612 00003F28 C3                      	retn
 23613                                  
 23614                                  ;Break	<SETDIRSRCH SETROOTSRCH -- Set Search environments>
 23615                                  ;----------------------------------------------------------------------------
 23616                                  ;
 23617                                  ; Procedure Name : SETDIRSRCH,SETROOTSRCH
 23618                                  ;
 23619                                  ; Inputs:
 23620                                  ;	BX cluster number of start of directory
 23621                                  ;	ES:BP Points to DPB
 23622                                  ;	DI next cluster number from fastopen extended info. DOS 3.3 only
 23623                                  ; Function:
 23624                                  ;	Set up a directory search
 23625                                  ; Outputs:
 23626                                  ;	[DIRSTART] = BX
 23627                                  ;	[CLUSFAC],[CLUSNUM],[SECCLUSPOS],[DIRSEC] set
 23628                                  ;	Carry set if error (currently user FAILed to I 24)
 23629                                  ; destroys AX,DX,BX
 23630                                  ;----------------------------------------------------------------------------
 23631                                  
 23632                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 23633                                  SETDIRSRCH:
 23634 00003F29 09DB                    	OR	BX,BX
 23635 00003F2B 7437                    	JZ	short SETROOTSRCH
 23636 00003F2D 891E[C205]              	MOV	[DIRSTART],BX
 23637                                  	;mov	al,[es:bp+4]
 23638 00003F31 268A4604                	MOV	AL,[ES:BP+DPB.CLUSTER_MASK]
 23639 00003F35 FEC0                    	INC	AL
 23640 00003F37 A2[7705]                	MOV	[CLUSFAC],AL
 23641                                  
 23642                                  ; DOS 3.3 for FastOPen	F.C. 6/12/86
 23643                                  	;SAVE	<SI>
 23644 00003F3A 56                      	push	si
 23645                                  	;test	byte [FastOpenFlg],2
 23646 00003F3B F606[3A0D]02            	TEST	byte [FastOpenFlg],Lookup_Success
 23647 00003F40 7507                    	JNZ	short UNP_OK
 23648                                  
 23649                                  ; DOS 3.3 for FastOPen	F.C. 6/12/86
 23650                                  	;invoke	UNPACK
 23651 00003F42 E85F16                  	call	UNPACK
 23652 00003F45 7302                    	JNC	short UNP_OK
 23653                                  	;RESTORE <SI>
 23654 00003F47 5E                      	pop	si
 23655                                  	;return
 23656 00003F48 C3                      	retn
 23657                                  
 23658                                  UNP_OK:
 23659 00003F49 893E[BC05]              	MOV	[CLUSNUM],DI
 23660 00003F4D 89DA                    	MOV	DX,BX
 23661 00003F4F 30DB                    	XOR	BL,BL
 23662 00003F51 881E[7305]              	MOV	[SECCLUSPOS],BL
 23663                                  	;invoke	FIGREC
 23664 00003F55 E8F50E                  	call	FIGREC
 23665                                  	;RESTORE <SI>
 23666 00003F58 5E                      	pop	si
 23667                                  	
 23668                                  	; 19/05/2019 - Retro DOS v4.0
 23669                                  
 23670                                  	; MSDOS 6.0
 23671                                  	;PUSH	DX			   ;AN000; >32mb
 23672                                  	;MOV	DX,[HIGH_SECTOR]	   ;AN000; >32mb
 23673                                  	;MOV	[DIRSEC+2],DX		   ;AN000; >32mb
 23674                                  	;POP	DX			   ;AN000; >32mb
 23675                                  
 23676                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 23677                                  	;push	dx
 23678                                  	;mov	dx,[HIGH_SECTOR]
 23679                                  	;mov	[DIRSEC+2],dx
 23680                                  	;pop	dx
 23681                                  	;MOV	[DIRSEC],dx
 23682                                  	; 16/12/2022
 23683 00003F59 A1[0706]                	mov	ax,[HIGH_SECTOR]
 23684 00003F5C A3[C005]                	mov	[DIRSEC+2],AX
 23685 00003F5F 8916[BE05]              	MOV	[DIRSEC],DX
 23686                                  
 23687                                  	; 16/12/2022
 23688                                  	; cf=0 (at the return of FIGREC)
 23689                                  	;CLC
 23690 00003F63 C3                      	retn
 23691                                  
 23692                                  	;entry	SETROOTSRCH
 23693                                  SETROOTSRCH:
 23694 00003F64 31C0                    	XOR	AX,AX
 23695 00003F66 A3[C205]                	MOV	[DIRSTART],AX
 23696                                  	; 22/09/2023
 23697 00003F69 A3[C005]                	mov	[DIRSEC+2],ax ; 0
 23698 00003F6C A2[7305]                	MOV	[SECCLUSPOS],AL
 23699 00003F6F 48                      	DEC	AX
 23700 00003F70 A3[BC05]                	MOV	[CLUSNUM],AX
 23701                                  	;mov	ax,[es:bp+0Bh]
 23702 00003F73 268B460B                	MOV	AX,[ES:BP+DPB.FIRST_SECTOR]
 23703                                  	; 19/05/2019
 23704                                  	;;mov	dx,[es:bp+10h] ; MSDOS 3.3
 23705                                  	;mov	dx,[es:bp+11h] ; MSDOS 6.0
 23706 00003F77 268B5611                	MOV	DX,[ES:BP+DPB.DIR_SECTOR]
 23707 00003F7B 29D0                    	SUB	AX,DX
 23708 00003F7D A2[7705]                	MOV	[CLUSFAC],AL
 23709 00003F80 8916[BE05]              	MOV	[DIRSEC],DX		      ;F.C. >32mb
 23710                                  	; 22/09/2023
 23711                                  	; MSDOS 6.0
 23712                                  	;MOV	WORD [DIRSEC+2],0	      ;F.C. >32mb
 23713 00003F84 F8                      	CLC
 23714 00003F85 C3                      	retn
 23715                                  
 23716                                  ;============================================================================
 23717                                  ; DIR2.ASM, MSDOS 6.0, 1991
 23718                                  ;============================================================================
 23719                                  ; 27/07/2018 - Retro DOS v3.0
 23720                                  ; 19/05/2019 - Retro DOS v4.0 
 23721                                  
 23722                                  ;	TITLE	DIR2 - Directory and path cracking
 23723                                  ;	NAME	Dir2
 23724                                  
 23725                                  ;Break	<GETPATH -- PARSE A WFP>
 23726                                  ;----------------------------------------------------------------------------
 23727                                  ;
 23728                                  ; Procedure Name : GETPATH
 23729                                  ;
 23730                                  ; Inputs:
 23731                                  ;	[WFP_START] Points to WFP string ("d:\" must be first 3 chars, NUL
 23732                                  ;		terminated; d:/ (note forward slash) indicates a real device).
 23733                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 23734                                  ;		( = -1 if current dir not involved, else
 23735                                  ;		 Points to first char after last "/" of current dir part)
 23736                                  ;	[THISCDS] Points to CDS being used
 23737                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 23738                                  ;	[NoSetDir] set
 23739                                  ;	[THISDPB] set to DPB if disk otherwise garbage.
 23740                                  ; Function:
 23741                                  ;	Crack the path
 23742                                  ; Outputs:
 23743                                  ;	Sets EXTERR_LOCUS = errLOC_Disk if disk file
 23744                                  ;	Sets EXTERR_LOCUS = errLOC_Unk if char device
 23745                                  ;	ID1 field of [THISCDS] updated appropriately
 23746                                  ;	[ATTRIB] = [SATTRIB]
 23747                                  ;	ES:BP Points to DPB
 23748                                  ;	Carry set if bad path
 23749                                  ;	   SI Points to path element causing failure
 23750                                  ;	   Zero set
 23751                                  ;	      [DIRSTART],[DIRSEC],[CLUSNUM], and [CLUSFAC] are set up to
 23752                                  ;	      start a search on the last directory
 23753                                  ;	      CL is zero if there is a bad name in the path
 23754                                  ;	      CL is non-zero if the name was simply not found
 23755                                  ;		 [ENTFREE] may have free spot in directory
 23756                                  ;		 [NAME1] is the name.
 23757                                  ;		 CL = 81H if '*'s or '?' in NAME1, 80H otherwise
 23758                                  ;	   Zero reset
 23759                                  ;	      File in middle of path or bad name in path or attribute mismatch
 23760                                  ;		or path too long or malformed path
 23761                                  ;	ELSE
 23762                                  ;	   [CurBuf] = -1 if root directory
 23763                                  ;	   [CURBUF] contains directory record with match
 23764                                  ;	   [CURBUF+2]:BX Points into [CURBUF] to start of entry
 23765                                  ;	   [CURBUF+2]:SI Points into [CURBUF] to dir_first field for entry
 23766                                  ;	   AH = device ID
 23767                                  ;	      bit 7 of AH set if device SI and BX
 23768                                  ;	      will point DOSGROUP relative The firclus
 23769                                  ;	      field of the device entry contains the device pointer
 23770                                  ;	   [NAME1] Has name looked for
 23771                                  ;	   If last element is a directory zero is set and:
 23772                                  ;	      [DIRSTART],[SECCLUSPOS],[DIRSEC],[CLUSNUM], and [CLUSFAC]
 23773                                  ;	      are set up to start a search on it.
 23774                                  ;	      unless [NoSetDir] is non zero in which case the return is
 23775                                  ;	      like that for a file (except for zero flag)
 23776                                  ;	   If last element is a file zero is reset
 23777                                  ;	      [DIRSEC],[CLUSNUM],[CLUSFAC],[NXTCLUSNUM],[SECCLUSPOS],
 23778                                  ;	      [LASTENT], [ENTLAST] are set to continue search of last
 23779                                  ;	      directory for furthur matches on NAME1 via the NEXTENT
 23780                                  ;	      entry point in FindEntry (or GETENT entry in GETENTRY in
 23781                                  ;	      which case [NXTCLUSNUM] and [SECCLUSPOS] need not be valid)
 23782                                  ; DS preserved, Others destroyed
 23783                                  ;---------------------------------------------------------------------------
 23784                                  
 23785                                  ;hkn; called from delete.asm, finfo.asm, mknode.asm and rename.asm.
 23786                                  ;hkn; DS already set up at this point.
 23787                                  
 23788                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 23789                                  GETPATH:
 23790                                  	;mov	word [CREATING],0E500h
 23791 00003F86 C706[7E05]00E5          	MOV	WORD [CREATING],DIRFREE*256+0 ; Not Creating, not DEL *.*
 23792                                  
 23793                                  ; Same as GetPath only CREATING and DELALL already set
 23794                                  
 23795                                  	;entry	GetPathNoSet
 23796                                  GetPathNoSet:
 23797                                  	;mov	byte [EXTERR_LOCUS],2	
 23798 00003F8C C606[2303]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk
 23799 00003F91 C706[E205]FFFF          	MOV	word [CURBUF],-1	; initial setting
 23800                                  
 23801                                  ; See if the input indicates a device that has already been detected. If so,
 23802                                  ; go build the guy quickly. Otherwise, let findpath find the device.
 23803                                  
 23804 00003F97 8B3E[B205]              	MOV	DI,[WFP_START]		; point to the beginning of the name
 23805                                  	;cmp	word [DI+1],5C3Ah
 23806                                  	;CMP	WORD [DI+1],'\' << 8 + ':'
 23807 00003F9B 817D013A5C              	cmp	word [DI+1],':\'
 23808 00003FA0 7438                    	JZ	short CrackIt
 23809                                  
 23810                                  ; Let ChkDev find it in the device list
 23811                                  
 23812 00003FA2 83C703                  	ADD	DI,3
 23813                                  	; 18/08/2018
 23814                                  	;MOV	SI,DI			; let CHKDEV see the original name
 23815                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 23816                                  	; 16/12/2022
 23817                                  	;mov	si,di ; not required ! (it is written in CHKDEV proc already!)
 23818 00003FA5 E8AB00                  	CALL	CHKDEV
 23819 00003FA8 722E                    	JC	short InternalError
 23820                                  
 23821                                  Build_devJ:
 23822 00003FAA A0[6D05]                	MOV	AL,[SATTRIB]
 23823 00003FAD A2[6B05]                	MOV	[ATTRIB],AL
 23824                                  	;mov	byte [EXTERR_LOCUS],1
 23825 00003FB0 C606[2303]01            	MOV	byte [EXTERR_LOCUS],errLOC_Unk ; In the particular case of
 23826                                  					; "finding" a char device
 23827                                  					; set LOCUS to Unknown. This makes
 23828                                  					; certain idiotic problems reported
 23829                                  					; by a certain 3 letter OEM go away.
 23830                                  
 23831                                  ; Take name in name1 and pack it back into where wfp_start points. This
 23832                                  ; guarantees wfp_start pointing to a canonical representation of a device.
 23833                                  ; We are allowed to do this as GetPath is *ALWAYS* called before entering a
 23834                                  ; wfp into the share set.
 23835                                  ;
 23836                                  ; We copy chars from name1 to wfp_start remembering the position of the last
 23837                                  ; non-space seen +1.  This position is kept in DX.
 23838                                  
 23839                                  ;hkn; SS is DOSDATA
 23840 00003FB5 16                      	push	ss
 23841 00003FB6 07                      	pop	es
 23842                                  
 23843                                  ;hkn; NAME1 is in DOSDATA
 23844 00003FB7 BE[4B05]                	mov	si,NAME1
 23845 00003FBA 8B3E[B205]              	mov	di,[WFP_START]
 23846 00003FBE 89FA                    	mov	dx,di
 23847 00003FC0 B90800                  	mov	cx,8			; 8 chars in device name
 23848                                  MoveLoop:
 23849 00003FC3 AC                      	lodsb
 23850 00003FC4 AA                      	stosb
 23851 00003FC5 3C20                    	cmp	al," "
 23852 00003FC7 7402                    	jz	short NoSave
 23853                                  
 23854 00003FC9 89FA                    	mov	dx,di
 23855                                  NoSave:
 23856 00003FCB E2F6                    	loop	MoveLoop
 23857                                  
 23858                                  ; DX is the position of the last seen non-space + 1. We terminate the name
 23859                                  ; at this point.
 23860                                  
 23861 00003FCD 89D7                    	mov	di,dx
 23862 00003FCF C60500                  	mov	byte [di],0		; end of string
 23863 00003FD2 E8C402                  	call	Build_device_ent	; Clears carry sets zero
 23864 00003FD5 FEC0                    	INC	AL			; reset zero
 23865 00003FD7 C3                      	retn
 23866                                  
 23867                                  InternalError:
 23868                                  InternalError_loop:
 23869 00003FD8 EBFE                    	JMP	short InternalError_loop	; freeze
 23870                                  
 23871                                  ; Start off at the correct spot. Optimize if the current dir part is valid.
 23872                                  
 23873                                  CrackIt:
 23874 00003FDA 8B36[B605]              	MOV	SI,[CURR_DIR_END]	; get current directory pointer
 23875 00003FDE 83FEFF                  	CMP	SI,-1			; valid?
 23876 00003FE1 7503                    	JNZ	short LOOK_SING		; Yes, use it.
 23877 00003FE3 8D7503                  	LEA	SI,[DI+3]		; skip D:\.
 23878                                  LOOK_SING:
 23879                                  	;mov	byte [ATTRIB],16h
 23880 00003FE6 C606[6B05]16            	MOV	byte [ATTRIB],attr_directory+attr_system+attr_hidden
 23881                                  					; Attributes to search through Dirs
 23882 00003FEB C43E[A205]              	LES	DI,[THISCDS]
 23883 00003FEF B8FFFF                  	MOV	AX,-1
 23884                                  	;mov	bx,[es:di+73]
 23885 00003FF2 268B5D49                	MOV	BX,[ES:DI+curdir.ID]
 23886 00003FF6 8B36[B605]              	MOV	SI,[CURR_DIR_END]
 23887                                  
 23888                                  ; AX = -1
 23889                                  ; BX = cluster number of current directory. THis number is -1 if the media
 23890                                  ;      has been uncertainly changed.
 23891                                  ; SI = offset in DOSGroup into path to end of current directory text. This
 23892                                  ;      may be -1 if no current directory part has been used.
 23893                                  
 23894 00003FFA 39C6                    	CMP	SI,AX			; if Current directory is not part
 23895 00003FFC 743B                    	JZ	short NO_CURR_D		; then we must crack from root
 23896 00003FFE 39C3                    	CMP	BX,AX			; is the current directory cluster valid
 23897                                  
 23898                                  ; DOS 3.3  6/25/86
 23899 00004000 7437                    	JZ	short NO_CURR_D		; no, crack form the root
 23900                                  	;test	byte [FastOpenFlg],1
 23901 00004002 F606[3A0D]01            	TEST	byte [FastOpenFlg],FastOpen_Set ; for fastopen ?
 23902 00004007 743D                    	JZ	short GOT_SEARCH_CLUSTER	; no
 23903 00004009 06                      	PUSH	ES			; save registers
 23904 0000400A 57                      	PUSH	DI
 23905 0000400B 51                      	PUSH	CX
 23906 0000400C FF74FF                  	PUSH	word [SI-1]		; save \ and 1st char of next element
 23907 0000400F 56                      	PUSH	SI
 23908 00004010 53                      	PUSH	BX
 23909                                  
 23910 00004011 C644FF00                	MOV	BYTE [SI-1],0		; call fastopen to look up cur dir info
 23911 00004015 8B36[B205]              	MOV	SI,[WFP_START]
 23912                                  
 23913                                  ;hkn; FastOpenTable, Dir_Info_Buff & FastOpen_Ext_Info are in DOSDATA
 23914 00004019 BB[300D]                	MOV	BX,FastOpenTable
 23915 0000401C BF[460D]                	MOV	DI,Dir_Info_Buff
 23916 0000401F B9[3B0D]                	MOV	CX,FastOpen_Ext_Info
 23917                                  	;mov	al,1
 23918 00004022 B001                    	MOV	AL,FONC_Look_up
 23919 00004024 1E                      	PUSH	DS
 23920 00004025 07                      	POP	ES
 23921                                  	;call	far [BX+2]
 23922 00004026 FF5F02                  	CALL	far [BX+fastopen_entry.name_caching]
 23923 00004029 7203                    	JC	short GO_Chk_end1 	;fastopen not installed, or wrong drive.
 23924                                  					; Go to Got_Srch_cluster
 23925                                  	; 29/12/2022
 23926                                  	;CMP	BYTE [SI],0		;fastopen has current dir info?
 23927                                  	;JE	short GO_Chk_end	;yes. Go to got_search_cluster
 23928                                  	;stc
 23929                                  	;jmp	short GO_Chk_end	;Go to No_Curr_D
 23930                                  
 23931 0000402B 803C01                  	cmp	byte [si],1
 23932                                  GO_Chk_end1:	; 29/12/2022
 23933 0000402E F5                      	cmc 
 23934                                  	; [si] = 0 -> cf = 0
 23935                                  	; [si] > 0 -> cf = 1
 23936                                  
 23937                                  ;GO_Chk_end1:
 23938                                  	; 29/12/2022
 23939                                  	;clc
 23940                                  
 23941                                  GO_Chk_end:				; restore registers
 23942 0000402F 5B                      	POP	BX
 23943 00004030 5E                      	POP	SI
 23944 00004031 8F44FF                  	POP	word [SI-1]
 23945 00004034 59                      	POP	CX
 23946 00004035 5F                      	POP	DI
 23947 00004036 07                      	POP	ES
 23948 00004037 730D                    	JNC	short GOT_SEARCH_CLUSTER ; crack based on cur dir
 23949                                  
 23950                                  ; DOS 3.3  6/25/86
 23951                                  ;
 23952                                  ; We must cract the path beginning at the root. Advance pointer to beginning
 23953                                  ; of path and go crack from root.
 23954                                  
 23955                                  NO_CURR_D:
 23956 00004039 8B36[B205]              	MOV	SI,[WFP_START]
 23957 0000403D 8D7403                  	LEA	SI,[SI+3]		; Skip "d:/"
 23958 00004040 C42E[8A05]              	LES	BP,[THISDPB]		; Get ES:BP
 23959 00004044 EB3B                    	JMP	short ROOTPATH
 23960                                  
 23961                                  ; We are able to crack from the current directory part. Go set up for search
 23962                                  ; of specified cluster.
 23963                                  
 23964                                  GOT_SEARCH_CLUSTER:
 23965 00004046 C42E[8A05]              	LES	BP,[THISDPB]		; Get ES:BP
 23966 0000404A E8DCFE                  	call	SETDIRSRCH
 23967                                  	;JC	short SETFERR
 23968                                  	;JMP	short FINDPATH
 23969                                  	; 16/12/2022
 23970 0000404D 7342                    	jnc	short FINDPATH ; 17/08/2018
 23971                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 23972                                  	;JC	short SETFERR
 23973                                  	;JMP	short FINDPATH
 23974                                  SETFERR:
 23975 0000404F 30C9                    	XOR	CL,CL			; set zero
 23976 00004051 F9                      	STC
 23977 00004052 C3                      	retn
 23978                                  
 23979                                  ;---------------------------------------------------------------------------
 23980                                  ;
 23981                                  ; Procedure Name : ChkDev
 23982                                  ;
 23983                                  ; Check to see if the name at DS:DI is a device. Returns carry set if not a
 23984                                  ;   device.
 23985                                  ; Blasts CX,SI,DI,AX,BX
 23986                                  ;---------------------------------------------------------------------------
 23987                                  
 23988                                  CHKDEV:
 23989 00004053 89FE                    	MOV	SI,DI
 23990 00004055 8CD7                    	MOV	DI,SS
 23991 00004057 8EC7                    	MOV	ES,DI
 23992                                  
 23993 00004059 BF[4B05]                	MOV	DI,NAME1
 23994 0000405C B90900                  	MOV	CX,9
 23995                                  TESTLOOP:
 23996 0000405F E84910                  	call	GETLET
 23997                                  
 23998 00004062 3C2E                    	CMP	AL,'.'
 23999 00004064 740E                    	JZ	short TESTDEVICE
 24000 00004066 E89810                  	call	PATHCHRCMP
 24001 00004069 7407                    	JZ	short NOTDEV
 24002 0000406B 08C0                    	OR	AL,AL
 24003 0000406D 7405                    	JZ	short TESTDEVICE
 24004                                  
 24005 0000406F AA                      	STOSB
 24006 00004070 E2ED                    	LOOP	TESTLOOP
 24007                                  NOTDEV:
 24008 00004072 F9                      	STC
 24009 00004073 C3                      	retn
 24010                                  
 24011                                  TESTDEVICE:
 24012                                  	;ADD	CX,2
 24013                                  	; 24/09/2023
 24014 00004074 41                      	inc	cx
 24015 00004075 41                      	inc	cx
 24016 00004076 B020                    	MOV	AL,' '
 24017 00004078 F3AA                    	REP	STOSB
 24018 0000407A 8CD0                    	MOV	AX,SS
 24019 0000407C 8ED8                    	MOV	DS,AX
 24020                                  	;call	DEVNAME
 24021                                  	;retn
 24022                                  	; 18/12/2022
 24023 0000407E E9B901                  	jmp	DEVNAME
 24024                                  
 24025                                  ;Break	<ROOTPATH, FINDPATH -- PARSE A PATH>
 24026                                  ;----------------------------------------------------------------------------
 24027                                  ;
 24028                                  ; Procedure Name : ROOTPATH,FINDPATH
 24029                                  ;
 24030                                  ; Inputs:
 24031                                  ;	Same as FINDPATH but,
 24032                                  ;	SI Points to asciz string of path which is assumed to start at
 24033                                  ;		the root (no leading '/').
 24034                                  ; Function:
 24035                                  ;	Search from root for path
 24036                                  ; Outputs:
 24037                                  ;	Same as FINDPATH but:
 24038                                  ;	If root directory specified, [CURBUF] and [NAME1] are NOT set, and
 24039                                  ;	[NoSetDir] is ignored.
 24040                                  ;----------------------------------------------------------------------------
 24041                                  
 24042                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 24043                                  	; DOSCODE:7F47h (MSDOS 5.0, MSDOS.SYS)
 24044                                  
 24045                                  ROOTPATH:
 24046 00004081 E8E0FE                  	call	SETROOTSRCH
 24047                                  	; 24/09/2023
 24048 00004084 30E4                    	xor	ah,ah
 24049                                  	;CMP	BYTE [SI],0
 24050 00004086 3824                    	cmp	[si],ah ; 0
 24051 00004088 7507                    	JNZ	short FINDPATH
 24052                                  
 24053                                  ; Root dir specified
 24054 0000408A A0[6D05]                	MOV	AL,[SATTRIB]
 24055 0000408D A2[6B05]                	MOV	[ATTRIB],AL
 24056                                  	; 24/09/2023
 24057                                  	;XOR	AH,AH			; Sets "device ID" byte, sets zero
 24058                                  					; (dir), clears carry.
 24059 00004090 C3                      	retn
 24060                                  
 24061                                  ; Inputs:
 24062                                  ;	[ATTRIB] Set to get through directories
 24063                                  ;	[SATTRIB] Set to find last element
 24064                                  ;	ES:BP Points to DPB
 24065                                  ;	SI Points to asciz string of path (no leading '/').
 24066                                  ;	[SECCLUSPOS] = 0
 24067                                  ;	[DIRSEC] = Phys sec # of first sector of directory
 24068                                  ;	[CLUSNUM] = Cluster # of next cluster
 24069                                  ;	[CLUSFAC] = Sectors per cluster
 24070                                  ;	[NoSetDir] set
 24071                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 24072                                  ;		( = -1 if current dir not involved, else
 24073                                  ;		 Points to first char after last "/" of current dir part)
 24074                                  ;	[THISCDS] Points to CDS being used
 24075                                  ;	[CREATING] and [DELALL] set
 24076                                  ; Function:
 24077                                  ;	Parse path name
 24078                                  ; Outputs:
 24079                                  ;	ID1 field of [THISCDS] updated appropriately
 24080                                  ;	[ATTRIB] = [SATTRIB]
 24081                                  ;	ES:BP Points to DPB
 24082                                  ;	[THISDPB] = ES:BP
 24083                                  ;	Carry set if bad path
 24084                                  ;	   SI Points to path element causing failure
 24085                                  ;	   Zero set
 24086                                  ;	      [DIRSTART],[DIRSEC],[CLUSNUM], and [CLUSFAC] are set up to
 24087                                  ;	      start a search on the last directory
 24088                                  ;	      CL is zero if there is a bad name in the path
 24089                                  ;	      CL is non-zero if the name was simply not found
 24090                                  ;		 [ENTFREE] may have free spot in directory
 24091                                  ;		 [NAME1] is the name.
 24092                                  ;		 CL = 81H if '*'s or '?' in NAME1, 80H otherwise
 24093                                  ;	   Zero reset
 24094                                  ;	      File in middle of path or bad name in path
 24095                                  ;		or path too long or malformed path
 24096                                  ;	ELSE
 24097                                  ;	   [CURBUF] contains directory record with match
 24098                                  ;	   [CURBUF+2]:BX Points into [CURBUF] to start of entry
 24099                                  ;	   [CURBUF+2]:SI Points to fcb_FIRCLUS field for entry
 24100                                  ;	   [NAME1] Has name looked for
 24101                                  ;	   AH = device ID
 24102                                  ;	      bit 7 of AH set if device SI and BX
 24103                                  ;	      will point DOSGROUP relative The firclus
 24104                                  ;	      field of the device entry contains the device pointer
 24105                                  ;	   If last element is a directory zero is set and:
 24106                                  ;	      [DIRSTART],[SECCLUSPOS],[DIRSEC],[CLUSNUM], and [CLUSFAC]
 24107                                  ;	      are set up to start a search on it,
 24108                                  ;	      unless [NoSetDir] is non zero in which case the return is
 24109                                  ;	      like that for a file (except for zero flag)
 24110                                  ;	   If last element is a file zero is reset
 24111                                  ;	      [DIRSEC],[CLUSNUM],[CLUSFAC],[NXTCLUSNUM],[SECCLUSPOS],
 24112                                  ;	      [LASTENT], [ENTLAST] are set to continue search of last
 24113                                  ;	      directory for furthur matches on NAME1 via the NEXTENT
 24114                                  ;	      entry point in FindEntry (or GETENT entry in GETENTRY in
 24115                                  ;	      which case [NXTCLUSNUM] and [SECCLUSPOS] need not be valid)
 24116                                  ; Destroys all other registers
 24117                                  
 24118                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 24119                                  	; DOSCODE:7F58h (MSDOS 5.0, MSDOS.SYS)
 24120                                  
 24121                                      	;entry	FINDPATH
 24122                                  FINDPATH:
 24123 00004091 06                      	PUSH	ES			; Save ES:BP
 24124 00004092 56                      	PUSH	SI
 24125 00004093 89F7                    	MOV	DI,SI
 24126 00004095 8B0E[C205]              	MOV	CX,[DIRSTART]		; Get start clus of dir being searched
 24127 00004099 833E[B605]FF            	CMP	word [CURR_DIR_END],-1
 24128 0000409E 740E                    	JZ	short NOIDS		; No current dir part
 24129 000040A0 3B3E[B605]              	CMP	DI,[CURR_DIR_END]
 24130 000040A4 7508                    	JNZ	short NOIDS		; Not to current dir end yet
 24131 000040A6 C43E[A205]              	LES	DI,[THISCDS]
 24132                                  	;mov	[es:di+73],cx
 24133 000040AA 26894D49                	MOV	[ES:DI+curdir.ID],CX	; Set current directory currency
 24134                                  NOIDS:
 24135                                  
 24136                                  ; Parse the name off of DS:SI into NAME1. AL = 1 if there was a meta
 24137                                  ; character in the string. CX,DI may be destroyed.
 24138                                  ;
 24139                                  ;	invoke	NAMETRANS
 24140                                  ;	MOV	CL,AL
 24141                                  ;
 24142                                  ; The above is the slow method. The name has *already* been munged by
 24143                                  ; TransPath so no special casing needs to be done. All we do is try to copy
 24144                                  ; the name until ., \ or 0 is hit.
 24145                                  
 24146 000040AE 8CD0                    	MOV	AX,SS
 24147 000040B0 8EC0                    	MOV	ES,AX
 24148                                  
 24149                                  ;hkn; Name1 is in DOSDATA
 24150 000040B2 BF[4B05]                	MOV	DI,NAME1
 24151 000040B5 B82020                  	MOV	AX,'  ' ; 2020h
 24152 000040B8 AA                      	STOSB
 24153 000040B9 AB                      	STOSW
 24154 000040BA AB                      	STOSW
 24155 000040BB AB                      	STOSW
 24156 000040BC AB                      	STOSW
 24157 000040BD AB                      	STOSW
 24158                                  
 24159                                  ;hkn; Name1 is in DOSDATA
 24160 000040BE BF[4B05]                	MOV	DI,NAME1
 24161 000040C1 30E4                    	XOR	AH,AH			; bits for CL
 24162                                  GetNam:
 24163                                  	; 19/05/2019 - Retro DOS v4.0
 24164                                  	;INC	CL ; ?*! ; MSDOS 6.0	;AN000; KK increment volid count
 24165                                  
 24166                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 24167                                  	; 16/12/2022
 24168                                  	;inc	cl ; not required !	
 24169                                  	
 24170 000040C3 AC                      	LODSB
 24171 000040C4 3C2E                    	CMP	AL,'.'	; 2Eh
 24172 000040C6 7412                    	JZ	short _SetExt
 24173 000040C8 08C0                    	OR	AL,AL
 24174 000040CA 7424                    	JZ	short _GetDone
 24175 000040CC 3C5C                    	CMP	AL,'\'	; 5Ch
 24176 000040CE 7420                    	JZ	short _GetDone
 24177 000040D0 3C3F                    	CMP	AL,'?'	; 3Fh
 24178 000040D2 7503                    	JNZ	short StoNam
 24179 000040D4 80CC01                  	OR	AH,1
 24180                                  StoNam: 
 24181 000040D7 AA                      	STOSB
 24182 000040D8 EBE9                    	JMP	short GetNam
 24183                                  _SetExt:
 24184 000040DA BF[5305]                	MOV	DI,NAME1+8
 24185                                  GetExt:
 24186 000040DD AC                      	LODSB
 24187 000040DE 08C0                    	OR	AL,AL
 24188 000040E0 740E                    	JZ	short _GetDone
 24189 000040E2 3C5C                    	CMP	AL,'\'
 24190 000040E4 740A                    	JZ	short _GetDone
 24191 000040E6 3C3F                    	CMP	AL,'?'
 24192 000040E8 7503                    	JNZ	short StoExt
 24193 000040EA 80CC01                  	OR	AH,1
 24194                                  StoExt: 
 24195 000040ED AA                      	STOSB
 24196 000040EE EBED                    	JMP	short GetExt
 24197                                  _GetDone:
 24198 000040F0 4E                      	DEC	SI
 24199 000040F1 88E1                    	MOV	CL,AH  ; 0 or 1 ; 29/12/2022
 24200 000040F3 80C980                  	OR	CL,80H
 24201 000040F6 5F                      	POP	DI			; Start of this element
 24202 000040F7 07                      	POP	ES			; Restore ES:BP
 24203 000040F8 39FE                    	CMP	SI,DI
 24204 000040FA 7503                    	JNZ	short check_device
 24205 000040FC E9E200                  	JMP	_BADPATH		; NUL parse (two delims most likely)
 24206                                  check_device:
 24207 000040FF 56                      	PUSH	SI			; Start of next element
 24208                                  	;MOV	AL,[SI]
 24209                                  	;OR	AL,AL
 24210                                  	; 23/09/2023
 24211 00004100 803C00                  	cmp	byte [si],0
 24212 00004103 7508                    	JNZ	short NOT_LAST
 24213                                  
 24214                                  ; for last element of the path switch to the correct search attributes
 24215                                  
 24216 00004105 8A3E[6D05]              	MOV	BH,[SATTRIB]
 24217 00004109 883E[6B05]              	MOV	[ATTRIB],BH
 24218                                  
 24219                                  NOT_LAST:
 24220                                  
 24221                                  ; check name1 to see if we have a device...
 24222                                  
 24223 0000410D 06                      	PUSH	ES			; Save ES:BP
 24224                                  
 24225                                  ;hkn; SS is DOSDATA
 24226                                  	;context ES
 24227 0000410E 16                      	push	ss
 24228 0000410F 07                      	pop	es
 24229 00004110 E82701                  	call	DEVNAME 		; blast BX
 24230 00004113 07                      	POP	ES			; Restore ES:BP
 24231 00004114 720B                    	JC	short FindFile		; Not a device
 24232 00004116 08C0                    	OR	AL,AL			; Test next char again
 24233 00004118 7403                    	JZ	short GO_BDEV
 24234 0000411A E9C800                  	JMP	FILEINPATH		; Device name in middle of path
 24235                                  
 24236                                  GO_BDEV:
 24237 0000411D 5E                      	POP	SI			; Points to NUL at end of path
 24238 0000411E E989FE                  	JMP	Build_devJ
 24239                                  
 24240                                  FindFile:
 24241                                  ;;;; 7/28/86
 24242 00004121 803E[4B05]E5            	CMP	BYTE [NAME1],0E5H	; if 1st char = E5
 24243 00004126 7505                    	JNZ	short NOE5		; no
 24244 00004128 C606[4B05]05            	MOV	BYTE [NAME1],05H	; change it to 05
 24245                                  NOE5:
 24246                                  ;;;; 7/28/86
 24247 0000412D 57                      	PUSH	DI			; Start of this element
 24248 0000412E 06                      	PUSH	ES			; Save ES:BP
 24249 0000412F 51                      	PUSH	CX			; CL return from NameTrans
 24250                                  ;DOS 3.3 FastOPen 6/12/86 F.C.
 24251                                  
 24252 00004130 E89502                  	CALL	LookupPath		; call fastopen to get dir entry
 24253 00004133 7303                    	JNC	short DIR_FOUND		; found dir entry
 24254                                  
 24255                                  ;DOS 3.3 FastOPen 6/12/86 F.C.
 24256 00004135 E8B0FC                  	call	FINDENTRY
 24257                                  DIR_FOUND:
 24258 00004138 59                      	POP	CX
 24259 00004139 07                      	POP	ES
 24260 0000413A 5F                      	POP	DI
 24261 0000413B 7303                    	JNC	short LOAD_BUF
 24262 0000413D E9CA00                  	JMP	BADPATHPOP
 24263                                  
 24264                                  LOAD_BUF:
 24265 00004140 C53E[E205]              	LDS	DI,[CURBUF]
 24266                                  	;test	byte [bx+0Bh],10h
 24267 00004144 F6470B10                	TEST	BYTE [BX+dir_entry.dir_attr],attr_directory
 24268 00004148 7503                    	JNZ	short GO_NEXT 		; DOS 3.3
 24269 0000414A E99800                  	JMP	FILEINPATH		; Error or end of path
 24270                                  
 24271                                  ; if we are not setting the directory, then check for end of string
 24272                                  
 24273                                  GO_NEXT:
 24274                                  ;hkn; SS override
 24275 0000414D 36803E[4C03]00          	CMP	BYTE [SS:NoSetDir],0
 24276 00004153 7423                    	JZ	short SetDir
 24277 00004155 89FA                    	MOV	DX,DI			; Save pointer to entry
 24278 00004157 8CD9                    	MOV	CX,DS
 24279                                  
 24280                                  ;hkn; SS is DOSDATA
 24281                                  	;context DS
 24282 00004159 16                      	push	ss
 24283 0000415A 1F                      	pop	ds
 24284 0000415B 5F                      	POP	DI			; Start of next element
 24285                                  	; 19/05/2019 - Retro DOS v4.0
 24286                                  	; MSDOS 6.0
 24287 0000415C F606[3A0D]01            	TEST	byte [FastOpenFlg],FastOpen_Set ;only DOSOPEN can take advantage of
 24288 00004161 740B                    	JZ	short _nofast			; the FastOpen
 24289 00004163 F606[3A0D]02            	TEST	byte [FastOpenFlg],Lookup_Success ; Lookup just happened
 24290 00004168 7404                    	JZ	short _nofast			; no
 24291 0000416A 8B3E[660D]              	MOV	DI,[Next_Element_Start]	; no need to insert it again
 24292                                  _nofast:
 24293 0000416E 803D00                  	CMP	BYTE [DI],0
 24294                                  	;;JNZ	short NEXT_ONE		; DOS 3.3
 24295                                  	;;JMP	_SETRET  ; retn		; Got it
 24296                                  	;retn	; 05/09/2018
 24297                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 24298                                  	;jmp	_SETRET
 24299                                  	; 16/12/2022
 24300 00004171 7421                    	jz	short _SETRET
 24301                                  
 24302                                  NEXT_ONE:
 24303 00004173 57                      	PUSH	DI			; Put start of next element back on stack
 24304 00004174 89D7                    	MOV	DI,DX
 24305 00004176 8ED9                    	MOV	DS,CX			; Get back pointer to entry
 24306                                  SetDir:
 24307 00004178 8B14                    	MOV	DX,[SI] 		; Dir_first
 24308                                  
 24309                                  ;DOS 3.3 FastOPen 6/12/86 F.C.
 24310 0000417A 1E                      	PUSH	DS		      ; save [curbuf+2]
 24311                                  ;hkn; SS is DOSDATA
 24312 0000417B 16                      	push	ss
 24313 0000417C 1F                      	pop	ds		      ; set DS Dosgroup
 24314                                  	;test	byte [FastOpenFlg],2
 24315 0000417D F606[3A0D]02            	TEST	byte [FastOpenFlg],Lookup_Success
 24316 00004182 7411                    	JZ	short DO_NORMAL	      ; fastopen not in memory or path not
 24317 00004184 89D3                    	MOV	BX,DX		      ; not found
 24318 00004186 8B3E[BC05]              	MOV	DI,[CLUSNUM]	      ; clusnum was set in LookupPath
 24319 0000418A 50                      	PUSH	AX		      ; save device id (AH)
 24320 0000418B E89BFD                  	call	SETDIRSRCH
 24321 0000418E 58                      	POP	AX		      ; restore device id (AH)
 24322 0000418F 83C402                  	ADD	SP,2		      ; pop ds in stack
 24323 00004192 EB37                    	JMP	short FAST_OPEN_SKIP
 24324                                  
 24325                                  	; 16/12/2022
 24326                                  _SETRET:
 24327 00004194 C3                      	retn
 24328                                  
 24329                                  DO_NORMAL:
 24330 00004195 1F                      	POP	DS			; DS = [curbuf + 2]
 24331                                  ;DOS 3.3 FastOPen 6/12/86 F.C.
 24332                                  
 24333 00004196 29FB                    	SUB	BX,DI			; Offset into sector of start of entry
 24334 00004198 29FE                    	SUB	SI,DI			; Offset into sector of dir_first
 24335 0000419A 53                      	PUSH	BX
 24336 0000419B 50                      	PUSH	AX
 24337 0000419C 56                      	PUSH	SI
 24338 0000419D 51                      	PUSH	CX
 24339                                  	;push	word [di+6]
 24340 0000419E FF7506                  	PUSH	WORD [DI+BUFFINFO.buf_sector]	;AN000;>32mb
 24341                                  	; 19/05/2019
 24342                                  	; MSDOS 6.0
 24343                                  	;push	word [di+8]
 24344 000041A1 FF7508                  	PUSH	WORD [DI+BUFFINFO.buf_sector+2]	;AN000;>32mb
 24345 000041A4 89D3                    	MOV	BX,DX
 24346                                  
 24347                                  ;hkn; SS is DOSDATA
 24348                                  	;context DS
 24349 000041A6 16                      	push	ss
 24350 000041A7 1F                      	pop	ds
 24351                                  	;invoke	SETDIRSRCH		; This uses UNPACK which might blow
 24352 000041A8 E87EFD                  	call	SETDIRSRCH		; the entry sector buffer
 24353                                  	; 19/05/2019
 24354                                  	; MSDOS 6.0
 24355 000041AB 8F06[0706]              	POP	word [HIGH_SECTOR]
 24356 000041AF 5A                      	POP	DX
 24357 000041B0 7203                    	JC	short SKIP_GETB
 24358                                  	; 22/09/2023
 24359                                  	;;mov	byte [ALLOWED],18h
 24360                                  	;MOV	byte [ALLOWED],Allowed_RETRY+Allowed_FAIL ; *
 24361                                  	;XOR	AL,AL ; *
 24362                                  	;;invoke GETBUFFR		; Get the entry buffer back
 24363                                  	;call	GETBUFFR
 24364 000041B2 E80118                  	call	GETBUFFER ; * ; pre-read
 24365                                  SKIP_GETB:
 24366 000041B5 59                      	POP	CX
 24367 000041B6 5E                      	POP	SI
 24368 000041B7 58                      	POP	AX
 24369 000041B8 5B                      	POP	BX
 24370 000041B9 7305                    	JNC	short SET_THE_BUF
 24371 000041BB 5F                      	POP	DI			; Start of next element
 24372 000041BC 89FE                    	MOV	SI,DI			; Point with SI
 24373 000041BE EB21                    	JMP	SHORT _BADPATH
 24374                                  
 24375                                  SET_THE_BUF:
 24376 000041C0 E879F5                  	call	SET_BUF_AS_DIR
 24377 000041C3 8B3E[E205]              	MOV	DI,[CURBUF]
 24378 000041C7 01FE                    	ADD	SI,DI			; Get the offsets back
 24379 000041C9 01FB                    	ADD	BX,DI
 24380                                  ; DOS 3.3 FastOpen 6/12/86  F.C.
 24381                                  FAST_OPEN_SKIP:
 24382 000041CB 5F                      	POP	DI			; Start of next element
 24383 000041CC E89D02                  	CALL	InsertPath		; insert dir entry info
 24384                                  ; DOS 3.3 FastOpen 6/12/86  F.C.
 24385 000041CF 8A05                    	MOV	AL,[DI]
 24386 000041D1 08C0                    	OR	AL,AL
 24387 000041D3 74BF                    	JZ	short _SETRET		; At end
 24388 000041D5 47                      	INC	DI			; Skip over "/"
 24389 000041D6 89FE                    	MOV	SI,DI			; Point with SI
 24390 000041D8 E8260F                  	call	PATHCHRCMP
 24391 000041DB 7503                    	JNZ	short find_bad_name	; oops
 24392 000041DD E9B1FE                  	JMP	FINDPATH		; Next element
 24393                                  
 24394                                  find_bad_name:
 24395 000041E0 4E                      	DEC	SI			; Undo above INC to get failure point
 24396                                  _BADPATH:
 24397 000041E1 30C9                    	XOR	CL,CL			; Set zero
 24398 000041E3 EB2C                    	JMP	SHORT BADPRET
 24399                                  
 24400                                  FILEINPATH:
 24401 000041E5 5F                      	POP	DI			; Start of next element
 24402                                  
 24403                                  ;hkn; SS is DOSDATA
 24404                                  	;context DS			; Got to from one place with DS gone
 24405 000041E6 16                      	push	ss
 24406 000041E7 1F                      	pop	ds
 24407                                  
 24408                                  ; DOS 3.3 FastOpen
 24409                                  	;test	byte [FastOpenFlg],1
 24410 000041E8 F606[3A0D]01            	TEST	byte [FastOpenFlg],FastOpen_Set  ; do this here is we don't want to
 24411 000041ED 740B                    	JZ	short NO_FAST		; device info to fastopen
 24412                                  	;test	byte [FastOpenFlg],2
 24413 000041EF F606[3A0D]02            	TEST	byte [FastOpenFlg],Lookup_Success
 24414 000041F4 7404                    	JZ	short NO_FAST
 24415 000041F6 8B3E[660D]              	MOV	DI,[Next_Element_Start]  ; This takes care of one time lookup
 24416                                  					 ; success
 24417                                  NO_FAST:
 24418                                  ; DOS 3.3 FastOpen
 24419 000041FA 8A05                    	MOV	AL,[DI]
 24420 000041FC 08C0                    	OR	AL,AL
 24421 000041FE 7404                    	JZ	short INCRET
 24422 00004200 89FE                    	MOV	SI,DI			; Path too long
 24423 00004202 EB0D                    	JMP	SHORT BADPRET
 24424                                  
 24425                                  INCRET:
 24426                                  ; DOS 3.3 FasOpen 6/12/86  F.C.
 24427                                  
 24428 00004204 E86502                  	CALL   InsertPath		; insert dir entry info
 24429                                  
 24430                                  ; DOS 3.3 FasOpen 6/12/86  F.C.
 24431 00004207 FEC0                    	INC	AL			; Reset zero
 24432                                  	; 16/12/2022	
 24433                                  ;_SETRET:
 24434 00004209 C3                      	retn
 24435                                  
 24436                                  BADPATHPOP:
 24437 0000420A 5E                      	POP	SI			; Start of next element
 24438 0000420B 8A04                    	MOV	AL,[SI]
 24439 0000420D 89FE                    	MOV	SI,DI			; Start of bad element
 24440 0000420F 08C0                    	OR	AL,AL			; zero if bad element is last, non-zero if path too long
 24441                                  BADPRET:
 24442 00004211 A0[6D05]                	MOV	AL,[SATTRIB]
 24443 00004214 A2[6B05]                	MOV	[ATTRIB],AL		; Make sure return correct
 24444 00004217 F9                      	STC
 24445 00004218 C3                      	retn
 24446                                  
 24447                                  ;Break	<STARTSRCH -- INITIATE DIRECTORY SEARCH>
 24448                                  ;---------------------------------------------------------------------------
 24449                                  ;
 24450                                  ; Procedure Name : STARTSRCH
 24451                                  ;
 24452                                  ; Inputs:
 24453                                  ;	[THISDPB] Set
 24454                                  ; Function:
 24455                                  ;	Set up a search for GETENTRY and NEXTENTRY
 24456                                  ; Outputs:
 24457                                  ;	ES:BP = Drive parameters
 24458                                  ;	Sets up LASTENT, ENTFREE=ENTLAST=-1, VOLID=0
 24459                                  ; Destroys ES,BP,AX
 24460                                  ;--------------------------------------------------------------------------
 24461                                  
 24462                                  STARTSRCH:
 24463 00004219 C42E[8A05]              	LES	BP,[THISDPB]
 24464 0000421D 31C0                    	XOR	AX,AX
 24465 0000421F A3[4803]                	MOV	[LASTENT],AX
 24466 00004222 A2[7B05]                	MOV	[VOLID],AL		; No volume ID found
 24467 00004225 48                      	DEC	AX
 24468 00004226 A3[D805]                	MOV	[ENTFREE],AX
 24469 00004229 A3[DA05]                	MOV	[ENTLAST],AX
 24470 0000422C C3                      	retn
 24471                                  
 24472                                  ;BREAK <MatchAttributes - the final check for attribute matching>
 24473                                  ;----------------------------------------------------------------------------
 24474                                  ; Procedure Name : MatchAttributes
 24475                                  ;
 24476                                  ; Input:    [Attrib] = attribute to search for
 24477                                  ;	    CH = found attribute
 24478                                  ; Output:   JZ <match>
 24479                                  ;	    JNZ <nomatch>
 24480                                  ; Registers modified: noneski
 24481                                  ;----------------------------------------------------------------------------
 24482                                  
 24483                                  MatchAttributes:
 24484 0000422D 50                      	PUSH	AX
 24485                                  
 24486                                  ;hkn; SS override
 24487 0000422E 36A0[6B05]              	MOV	AL,[ss:ATTRIB]		; AL <- SearchSet
 24488 00004232 F6D0                    	NOT	AL			; AL <- SearchSet'
 24489 00004234 20E8                    	AND	AL,CH			; AL <- SearchSet' and FoundSet
 24490                                  	;and	al,16h
 24491 00004236 2416                    	AND	AL,attr_all	; AL <- SearchSet' and FoundSet and Important
 24492                                  ;
 24493                                  ; the result is non-zero if an attribute is not in the search set
 24494                                  ; and in the found set and in the important set. This means that we do not
 24495                                  ; have a match. Do a JNZ <nomatch> or JZ <match>
 24496                                  ;
 24497 00004238 58                      	POP	AX
 24498 00004239 C3                      	retn
 24499                                  
 24500                                  ; 19/05/2019 - Retro DOS v4.0
 24501                                  ; DOSCODE:8148h (MSDOS 6.21, MSDOS.SYS)
 24502                                  
 24503                                  ; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 24504                                  ; DOSCODE:810Dh (MSDOS 5.0, MSDOS.SYS)
 24505                                  
 24506                                  ;Break <DevName - Look for name of device>
 24507                                  ;---------------------------------------------------------------------------
 24508                                  ;
 24509                                  ; Procedure Name : DevName
 24510                                  ;
 24511                                  ; Inputs:
 24512                                  ;	DS,ES:DOSDATA
 24513                                  ;	Filename in NAME1
 24514                                  ;	ATTRIB set so that we can error out if looking for Volume IDs
 24515                                  ; Function:
 24516                                  ;	Determine if file is in list of I/O drivers
 24517                                  ; Outputs:
 24518                                  ;	Carry set if not a device
 24519                                  ;	ELSE
 24520                                  ;	Zero flag set
 24521                                  ;	BH = Bit 7,6 = 1, bit 5 = 0 (cooked mode)
 24522                                  ;	     bits 0-4 set from low byte of attribute word
 24523                                  ;	DEVPT = DWORD pointer to Device header of device
 24524                                  ; BX destroyed, others preserved
 24525                                  ;---------------------------------------------------------------------------
 24526                                  
 24527                                  DEVNAME:
 24528                                  	; 28/07/2018 - Retro DOS v3.0
 24529                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 49FBh
 24530                                  
 24531 0000423A 56                      	PUSH	SI
 24532 0000423B 57                      	PUSH	DI
 24533 0000423C 51                      	PUSH	CX
 24534 0000423D 50                      	PUSH	AX
 24535                                  
 24536                                  ; E5 special code
 24537 0000423E FF36[4B05]              	PUSH	WORD [NAME1]
 24538 00004242 803E[4B05]05            	CMP	byte [NAME1],5
 24539 00004247 7505                    	JNZ	short NOKTR
 24540 00004249 C606[4B05]E5            	MOV	byte [NAME1],0E5h
 24541                                  NOKTR:
 24542                                  	;test	byte [ATTRIB],8
 24543 0000424E F606[6B05]08            	TEST	byte [ATTRIB],attr_volume_id
 24544                                  					; If looking for VOL id don't find devs
 24545 00004253 7521                    	JNZ	short RET31
 24546                                  
 24547                                  ;hkn; NULDEV is in DOSDATA
 24548 00004255 BE[4800]                	MOV	SI,NULDEV
 24549                                  LOOKIO:
 24550                                  	; 21/11/2022
 24551                                  	;test	byte [SI+SYSDEV.ATT+1],80h
 24552                                  	; 17/12/2022
 24553                                  	;test	byte [si+5],80h
 24554 00004258 F6440580                	test	byte [SI+SYSDEV.ATT+1],(DEVTYP>>8)
 24555                                  	;;test	word [si+4],8000h
 24556                                  	;TEST	word [SI+SYSDEV.ATT],DEVTYP
 24557 0000425C 7411                    	JZ	short SKIPDEV 		; Skip block devices (NET and LOCAL)
 24558 0000425E 89F0                    	MOV	AX,SI
 24559                                  	;add	si,10
 24560 00004260 83C60A                  	ADD	SI,SYSDEV.NAME
 24561                                  
 24562                                  ;hkn; NAME1 is in DOSDATA
 24563 00004263 BF[4B05]                	MOV	DI,NAME1
 24564 00004266 B90400                  	MOV	CX,4			; All devices are 8 letters
 24565 00004269 F3A7                    	REPE	CMPSW			; Check for name in list
 24566 0000426B 89C6                    	MOV	SI,AX
 24567 0000426D 7415                    	JZ	short IOCHK		; Found it?
 24568                                  SKIPDEV:
 24569 0000426F C534                    	LDS	SI,[SI]			; Get address of next device
 24570 00004271 83FEFF                  	CMP	SI,-1			; At end of list?
 24571 00004274 75E2                    	JNZ	short LOOKIO
 24572                                  RET31:	
 24573 00004276 F9                      	STC				; Not found
 24574                                  RETNV:	
 24575 00004277 8CD1                    	MOV	CX,SS
 24576 00004279 8ED9                    	MOV	DS,CX
 24577                                  
 24578 0000427B 8F06[4B05]              	POP	WORD [NAME1]
 24579 0000427F 58                      	POP	AX
 24580 00004280 59                      	POP	CX
 24581 00004281 5F                      	POP	DI
 24582 00004282 5E                      	POP	SI
 24583 00004283 C3                      	RETN
 24584                                  
 24585                                  IOCHK:
 24586                                  ;hkn; SS override for DEVPT
 24587 00004284 368C1E[9C05]            	MOV	[SS:DEVPT+2],DS		; Save pointer to device
 24588                                  	;mov	bh,[si+4]
 24589 00004289 8A7C04                  	MOV	BH,[SI+SYSDEV.ATT]
 24590 0000428C 80CFC0                  	OR	BH,0C0h
 24591 0000428F 80E7DF                  	and	bh,0DFh
 24592                                  	;AND	BH,~(020h)		; Clears Carry
 24593 00004292 368936[9A05]            	MOV	[SS:DEVPT],SI
 24594 00004297 EBDE                    	JMP	short RETNV
 24595                                  
 24596                                  ;BREAK <Build_device_ent - Make a Directory entry>
 24597                                  ;---------------------------------------------------------------------------
 24598                                  ; Procedure Name : Build_device_ent
 24599                                  ;
 24600                                  ; Inputs:
 24601                                  ;	[NAME1] has name
 24602                                  ;	BH is attribute field (supplied by DEVNAME)
 24603                                  ;	[DEVPT] points to device header (supplied by DEVNAME)
 24604                                  ; Function:
 24605                                  ;	Build a directory entry for a device at DEVFCB
 24606                                  ; Outputs:
 24607                                  ;	BX points to DEVFCB
 24608                                  ;	SI points to dir_first field
 24609                                  ;	AH = input BH
 24610                                  ;	AL = 0
 24611                                  ;	dir_first = DEVPT
 24612                                  ;	Zero Set, Carry Clear
 24613                                  ; DS,ES,BP preserved, others destroyed
 24614                                  ;--------------------------------------------------------------------------
 24615                                  
 24616                                  Build_device_ent:
 24617 00004299 B82020                  	MOV	AX,"  " ; 2020h
 24618                                  
 24619                                  ;hkn; DEVFCB is in DOSDATA
 24620 0000429C BF[5305]                	MOV	DI,DEVFCB+8		; Point to extent field
 24621                                  
 24622                                  ;	Fill dir_ext  BUGBUG - use ERRNZs for this stuff!
 24623                                  
 24624 0000429F AB                      	STOSW
 24625 000042A0 AA                      	STOSB				; Blank out extent field
 24626                                  	;mov	al,40h
 24627 000042A1 B040                    	MOV	AL,attr_device
 24628                                  
 24629                                  ;	Fill Dir_attr
 24630                                  
 24631 000042A3 AA                      	STOSB				; Set attribute field
 24632 000042A4 31C0                    	XOR	AX,AX
 24633 000042A6 B90A00                  	MOV	CX,10
 24634                                  
 24635                                  ; Fill dir_pad
 24636                                  
 24637 000042A9 F3AB                    	REP	STOSW			; Fill rest with zeros
 24638 000042AB E862C8                  	call	DATE16
 24639                                  
 24640                                  ;hkn; DEVFCB is in DOSDATA
 24641 000042AE BF[6105]                	MOV	DI,DEVFCB+dir_entry.dir_time ; 09/08/2018
 24642 000042B1 92                      	XCHG	AX,DX
 24643                                  
 24644                                  ; Fill dir_time
 24645                                  
 24646 000042B2 AB                      	STOSW
 24647 000042B3 92                      	XCHG	AX,DX
 24648                                  
 24649                                  ; Fill dir_date
 24650                                  
 24651 000042B4 AB                      	STOSW
 24652 000042B5 89FE                    	MOV	SI,DI			; SI points to dir_first field
 24653 000042B7 A1[9A05]                	MOV	AX,[DEVPT]
 24654                                  
 24655                                  ; Fill dir_first
 24656                                  
 24657 000042BA AB                      	STOSW				; Dir_first points to device
 24658 000042BB A1[9C05]                	MOV	AX,[DEVPT+2]
 24659                                  ;
 24660                                  ; Fill dir_size_l
 24661                                  ;
 24662 000042BE AB                      	STOSW
 24663 000042BF 88FC                    	MOV	AH,BH			; Put device atts in AH
 24664                                  
 24665                                  ;hkn; DEVFCB is in DOSDATA
 24666 000042C1 BB[4B05]                	MOV	BX,DEVFCB
 24667 000042C4 30C0                    	XOR	AL,AL			; Set zero, clear carry
 24668 000042C6 C3                      	retn
 24669                                  
 24670                                  ;Break	<ValidateCDS - given a CDS, validate the media and the current directory>
 24671                                  ;----------------------------------------------------------------------------
 24672                                  ;
 24673                                  ;   ValidateCDS - Get current CDS. Splice it. Call FatReadCDS to check
 24674                                  ;   media. If media has been changed, do DOS_Chdir to validate path.
 24675                                  ;   If invalid, reset original CDS to root.
 24676                                  ;
 24677                                  ;   Inputs:	ThisCDS points to CDS of interest
 24678                                  ;		SS:DI points to temp buffer
 24679                                  ;   Outputs:	The current directory string is validated on the appropriate
 24680                                  ;		    drive
 24681                                  ;		ThisDPB changed
 24682                                  ;		ES:DI point to CDS
 24683                                  ;		Carry set if error (currently user FAILed to I 24)
 24684                                  ;   Registers modified: all
 24685                                  ;----------------------------------------------------------------------------
 24686                                  
 24687                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 24688                                  	; DOSCODE:819Bh (MSDOS 5.0, MSDOS.SYS)
 24689                                  
 24690                                  ValidateCDS:
 24691                                  	; 19/05/2019 - Retro DOS v4.0
 24692                                  	; 28/07/2018 - Retro DOS v3.0
 24693                                  
 24694                                     %define  Temp	[bp-2]	; word
 24695                                     %define  SaveCDS	[bp-6]	; dword
 24696                                     %define  SaveCDSL	[bp-6]	; word
 24697                                     %define  SaveCDSH	[bp-4]	; word
 24698                                  
 24699                                  	;Enter
 24700 000042C7 55                      	push	bp
 24701 000042C8 89E5                    	mov	bp,sp
 24702 000042CA 83EC06                  	sub	sp,6
 24703                                  
 24704 000042CD 897EFE                  	MOV	Temp,DI
 24705                                  
 24706                                  ;hkn; SS override
 24707 000042D0 36C536[A205]            	LDS	SI,[SS:THISCDS]
 24708 000042D5 8976FA                  	MOV	SaveCDSL,SI
 24709 000042D8 8C5EFC                  	MOV	SaveCDSH,DS
 24710                                  	;EnterCrit critDisk
 24711 000042DB E879D0                  	call	ECritDisk
 24712                                  	; 21/11/2022
 24713                                  	;test	byte [SI+curdir.flags+1],80h
 24714                                  	;test	word [si+67],8000h
 24715                                  	; 17/12/2022
 24716                                  	;test	byte [SI+68],80h
 24717 000042DE F6444480                	test	byte [SI+curdir.flags+1],(curdir_isnet>>8)
 24718                                  	;TEST	word [SI+curdir.flags],curdir_isnet	; Clears carry
 24719 000042E2 7403                    	JZ	short _DoSplice
 24720 000042E4 E99200                  	JMP	FatFail
 24721                                  _DoSplice:
 24722 000042E7 30D2                    	XOR	DL,DL
 24723 000042E9 368616[4C03]            	XCHG	DL,[SS:NoSetDir]
 24724                                  
 24725                                  ;hkn; SS is DOSDATA
 24726                                  	;Context ES
 24727 000042EE 16                      	push	ss
 24728 000042EF 07                      	pop	es
 24729                                  	;Invoke	FStrcpy
 24730 000042F0 E837CF                  	call	FStrCpy
 24731 000042F3 8B76FE                  	MOV	SI,Temp
 24732                                  
 24733                                  ;hkn; SS is DOSDATA
 24734                                  	;Context DS
 24735 000042F6 16                      	push	ss
 24736 000042F7 1F                      	pop	ds	
 24737                                  	;Invoke	Splice
 24738 000042F8 E8642B                  	call	Splice
 24739                                  
 24740                                   ;hkn; SS is DOSDATA
 24741                                  	;Context DS			;   FatReadCDS (ThisCDS);
 24742 000042FB 16                      	push	ss
 24743 000042FC 1F                      	pop	ds
 24744 000042FD 8816[4C03]              	MOV	[NoSetDir],DL
 24745 00004301 C43E[A205]              	LES	DI,[THISCDS]
 24746                                  	;SAVE	<BP>
 24747 00004305 55                      	push	bp
 24748                                  	;Invoke	FATREAD_CDS
 24749 00004306 E83214                  	call	FATREAD_CDS	
 24750                                  	;RESTORE <BP>
 24751 00004309 5D                      	pop	bp
 24752 0000430A 726D                    	JC	short FatFail
 24753                                  
 24754 0000430C C536[A205]              	LDS	SI,[THISCDS]		;   if (ThisCDS->ID == -1) {
 24755                                  	;cmp	word [si+73],-1
 24756 00004310 837C49FF                	CMP	word [SI+curdir.ID],-1
 24757 00004314 7555                    	JNZ	short RestoreCDS
 24758                                  
 24759                                  ;hkn; SS is DOSDATA
 24760                                  	;Context ES
 24761 00004316 16                      	push	ss
 24762 00004317 07                      	pop	es
 24763                                  
 24764                                  ;hkn; SS override
 24765                                  	;SAVE	<wfp_Start>		;	t = wfp_Start;
 24766 00004318 36FF36[B205]            	push	word [SS:WFP_START]
 24767                                  	;cmp	si,[bp-6]
 24768 0000431D 3B76FA                  	CMP	SI,SaveCDSL		; if not spliced
 24769 00004320 750B                    	JNZ	short DoChdir
 24770                                  	;mov	di,[bp-2]
 24771 00004322 8B7EFE                  	MOV	DI,Temp
 24772                                  
 24773                                  ;hkn; SS override
 24774 00004325 36893E[B205]            	MOV	[SS:WFP_START],DI	;	wfp_start = d;
 24775                                  	;Invoke	FStrCpy 		;	strcpy (d, ThisCDS->Text);
 24776 0000432A E8FDCE                  	call	FStrCpy
 24777                                  DoChdir:
 24778                                  ;hkn; SS is DOSDATA
 24779                                  	;Context DS
 24780 0000432D 16                      	push	ss
 24781 0000432E 1F                      	pop	ds
 24782                                  	;SAVE	<<WORD PTR SAttrib>,BP> ;	c = DOSChDir ();
 24783 0000432F FF36[6D05]              	push	word [SATTRIB]
 24784 00004333 55                      	push	bp
 24785                                  	;Invoke	DOS_ChDir
 24786 00004334 E8F0EE                  	call	DOS_CHDIR
 24787                                  	;RESTORE <BP,BX,wfp_start>	;	wfp_Start = t;
 24788 00004337 5D                      	pop	bp
 24789 00004338 5B                      	pop	bx
 24790 00004339 8F06[B205]              	pop	word [WFP_START]
 24791 0000433D 881E[6D05]              	MOV	[SATTRIB],BL
 24792 00004341 C576FA                  	LDS	SI,SaveCDS
 24793 00004344 730F                    	JNC	short SetCluster	;	if (c == -1) {
 24794                                  
 24795                                  ;hkn; SS override for THISCDS
 24796 00004346 368936[A205]            	MOV	[SS:THISCDS],SI		;	    ThisCDS = TmpCDS;
 24797 0000434B 368C1E[A405]            	MOV	[SS:THISCDS+2],DS
 24798 00004350 31C9                    	XOR	CX,CX			;	    TmpCDS->text[3] = c = 0;
 24799 00004352 884C03                  	MOV	[SI+3],CL		;	    }
 24800                                  SetCluster:
 24801                                  	;mov	word [si+73],0FFFFh
 24802 00004355 C74449FFFF              	MOV	word [SI+curdir.ID],-1	;	TmpCDS->ID = -1;
 24803 0000435A 36C536[A205]            	LDS	SI,[SS:THISCDS]		;	ThisCDS->ID = c;
 24804                                  	; 21/11/2022
 24805                                  	;test	byte [si+curdir.flags+1],20h
 24806                                  	; 19/05/2019
 24807                                  	; MSDOS 6.0
 24808                                  	; 17/12/2022
 24809                                  	;test	byte [si+68],20h
 24810 0000435F F6444420                	test	byte [SI+curdir.flags+1],(curdir_splice>>8)	
 24811                                  	;;test	word [si+67],2000h
 24812                                  	;TEST	word [SI+curdir.flags],curdir_splice ;AN000;;MS. for Join and Subst
 24813 00004363 7403                    	JZ	short _setdirclus		     ;AN000;;MS.
 24814 00004365 B9FFFF                  	MOV	CX,-1				     ;AN000;;MS.
 24815                                  _setdirclus:
 24816                                  	;mov	[si+73],cx
 24817 00004368 894C49                  	MOV	[SI+curdir.ID],CX	;	}
 24818                                  RestoreCDS:
 24819 0000436B C47EFA                  	LES	DI,SaveCDS
 24820 0000436E 36893E[A205]            	MOV	[SS:THISCDS],DI
 24821 00004373 368C06[A405]            	MOV	[SS:THISCDS+2],ES
 24822 00004378 F8                      	CLC
 24823                                  FatFail:
 24824                                  	;LeaveCrit critDisk
 24825 00004379 E8F6CF                  	call	LCritDisk
 24826                                  
 24827                                  	;les	di,[bp-6]
 24828 0000437C C47EFA                  	LES	DI,SaveCDS
 24829                                  	;Leave
 24830 0000437F 89EC                    	mov	sp,bp
 24831 00004381 5D                      	pop	bp
 24832 00004382 C3                      	retn
 24833                                  
 24834                                  ; 28/07/2018 - Retro DOS v3.0
 24835                                  ; IBMDOS.COM (MSDOS 3.3, 1987) - offset 43BDh
 24836                                  
 24837                                  ;Break	<CheckThisDevice - Check for being a device>
 24838                                  ;---------------------------------------------------------------------------
 24839                                  ;
 24840                                  ;   CheckThisDevice - Examine the area at DS:SI to see if there is a valid
 24841                                  ;   device specified. We will return carry if there is a device present. 
 24842                                  ;   The forms of devices we will recognize are:
 24843                                  ;
 24844                                  ;	[path]device
 24845                                  ;
 24846                                  ;   Note that the drive letter has *already* been removed. All other forms
 24847                                  ;   are not considered to be devices. If such a device is found we change
 24848                                  ;   the source pointer to point to the device component.
 24849                                  ;
 24850                                  ;   Inputs:	ES is DOSDATA
 24851                                  ;		DS:SI contains name
 24852                                  ;   Outputs:	ES is DOSDATA
 24853                                  ;		DS:SI point to name or device
 24854                                  ;		Carry flag set if device was found
 24855                                  ;		Carry flag reset otherwise
 24856                                  ;   Registers Modified: all except ES:DI, DS
 24857                                  ;----------------------------------------------------------------------------
 24858                                  
 24859                                  CheckThisDevice:
 24860 00004383 57                      	push	di
 24861 00004384 56                      	push	si
 24862 00004385 89F7                    	MOV	DI,SI
 24863                                  
 24864                                  ; Check for presence of \dev\ (Dam multiplan!)
 24865                                  
 24866 00004387 8A04                    	MOV	AL,[SI]
 24867 00004389 E8750D                  	call	PATHCHRCMP		; is it a path char?
 24868 0000438C 7517                    	JNZ	short ParseDev		; no, go attempt to parse device
 24869 0000438E 46                      	INC	SI			; simulate LODSB
 24870                                  
 24871                                  ; We have the leading path separator. Look for DEV part.
 24872                                  
 24873 0000438F AD                      	LODSW
 24874 00004390 0D2020                  	OR	AX,2020h
 24875 00004393 3D6465                  	cmp	ax,"de"
 24876                                  	;CMP	AX,"e"<< 8 + "d"
 24877 00004396 752D                    	JNZ	short NotDevice		; not "de", assume not device
 24878 00004398 AC                      	LODSB
 24879 00004399 0C20                    	OR	AL,20h
 24880 0000439B 3C76                    	CMP	AL,"v"                  ; Not "v", assume not device
 24881 0000439D 7526                    	JNZ	short NotDevice
 24882 0000439F AC                      	LODSB
 24883 000043A0 E85E0D                  	call	PATHCHRCMP		; do we have the last path separator?
 24884 000043A3 7520                    	JNZ	short NotDevice		; no. go for it.
 24885                                  
 24886                                  ; DS:SI now points to a potential drive. Preserve them as NameTrans advances
 24887                                  ; SI and DevName may destroy DS.
 24888                                  
 24889                                  ParseDev:
 24890 000043A5 1E                      	push	ds
 24891 000043A6 56                      	push	si			; preserve the source pointer
 24892 000043A7 E8950C                  	call	NameTrans		; advance DS:SI
 24893 000043AA 803C00                  	CMP	BYTE [SI],0		; parse entire string?
 24894 000043AD F9                      	STC				; simulate a Carry return from DevName
 24895 000043AE 750B                    	JNZ	short SkipSearch	; no parse. simulate a file return.
 24896                                  
 24897                                  ;hkn; SS is DOSDATA
 24898 000043B0 16                      	push	ss
 24899 000043B1 1F                      	pop	ds
 24900                                  
 24901                                  ; M026 - start - fix ported from ROMDOS2 for bug # 2849
 24902                                  ;
 24903                                  ; SR;
 24904                                  ; We have to set Attrib before invoking DevName. Otherwise, the value from
 24905                                  ; a previous DOS call is used and DevName thinks it is not a device if the
 24906                                  ; old call set the volume attribute bit.
 24907                                  
 24908 000043B2 A0[6D05]                	mov	al,[SATTRIB]
 24909 000043B5 A2[6B05]                	mov	[ATTRIB],al		;set Attrib for DevName
 24910                                  
 24911                                  ; M026 - end
 24912                                  
 24913 000043B8 E87FFE                  	call	DEVNAME
 24914                                  
 24915                                  SkipSearch:
 24916 000043BB 5E                      	pop	si
 24917 000043BC 1F                      	pop	ds
 24918                                  
 24919                                  ; SI points to the beginning of the potential device. If we have a device
 24920                                  ; then we do not change SI. If we have a file, then we reset SI back to the
 24921                                  ; original value. At this point Carry set indicates FILE.
 24922                                  
 24923                                  CheckReturn:
 24924 000043BD 5F                      	pop	di			; get original SI
 24925 000043BE 7302                    	JNC	short Check_Done	; if device then do not reset pointer
 24926 000043C0 89FE                    	MOV	SI,DI
 24927                                  Check_Done:
 24928 000043C2 5F                      	pop	di
 24929 000043C3 F5                      	CMC				; invert carry. Carry => device
 24930 000043C4 C3                      	retn
 24931                                  NotDevice:
 24932 000043C5 F9                      	STC
 24933 000043C6 EBF5                    	JMP	short CheckReturn
 24934                                  
 24935                                  ;BREAK <LookupPath - call fastopen to get dir entry info>
 24936                                  ;-----------------------------------------------------------------------------
 24937                                  ;
 24938                                  ; Procedure Name : LookupPath
 24939                                  ;
 24940                                  ; Output  DS:SI -> path name,
 24941                                  ;	  ES:DI -> dir entry info buffer
 24942                                  ;	  ES:CX -> extended dir info buffer
 24943                                  ;
 24944                                  ;	  carry flag clear : tables pointed by ES:DI and ES:CX are filled by
 24945                                  ;			     FastOpen, DS:SI points to char just one after
 24946                                  ;			     the last char of path name which is fully or
 24947                                  ;			     partially found in FastOPen
 24948                                  ;	  carry flag set : FastOpen not in memory or path name not found
 24949                                  ;
 24950                                  ;----------------------------------------------------------------------------
 24951                                  
 24952                                  LookupPath:
 24953                                  ;	PUSH	AX
 24954                                  
 24955                                  ;hkn; SS override
 24956                                  	;test	byte [ss:FastOpenFlg],1
 24957 000043C8 36F606[3A0D]01          	TEST	byte [ss:FastOpenFlg],FastOpen_Set  ; flg is set in DOSOPEN
 24958 000043CE 7503                    	JNZ	short FASTINST			    ; and this routine is
 24959                                  NOLOOK:
 24960 000043D0 E99700                  	JMP	NOLOOKUP			    ; executed once
 24961                                  
 24962                                  FASTINST:
 24963                                  ;hkn; SS override
 24964                                  	;test	byte [ss:FastOpenFlg],8
 24965 000043D3 36F606[3A0D]08          	TEST	byte [ss:FastOpenFlg],No_Lookup	    ; no more lookup?
 24966 000043D9 75F5                    	JNZ	short NOLOOK			    ; yes
 24967                                  
 24968 000043DB BB[300D]                	MOV	BX,FastOpenTable		    ; get fastopen related tab
 24969                                  
 24970                                  ;hkn; SS override
 24971 000043DE 368B36[B205]            	MOV	SI,[SS:WFP_START]		    ; si points to path name
 24972 000043E3 BF[460D]                	MOV	DI,Dir_Info_Buff
 24973 000043E6 B9[3B0D]                	MOV	CX,FastOpen_Ext_Info
 24974 000043E9 B001                    	MOV	AL,FONC_Look_up 		    ; al = 1
 24975 000043EB 1E                      	PUSH	DS
 24976 000043EC 07                      	POP	ES
 24977                                  
 24978                                  ;hkn; SS override
 24979                                  	;call	far [bx+2]
 24980 000043ED FF5F02                  	CALL	far [BX+fastopen_entry.name_caching] ;call fastopen
 24981 000043F0 7267                    	JC	short NOTFOUND			    ; fastopen not in memory
 24982                                  
 24983 000043F2 8D5CFE                  	LEA	BX,[SI-2]
 24984                                  
 24985                                  ;hkn; SS override
 24986 000043F5 363B1E[B205]            	CMP	BX,[SS:WFP_START]		    ; path found ?
 24987 000043FA 745D                    	JZ	short NOTFOUND			    ; no
 24988                                  
 24989                                  	; 19/05/2019 - Retro DOS v4.0
 24990                                  
 24991                                  	; MSDOS 6.0				    ; fully or partially found
 24992 000043FC 803C00                  	CMP	BYTE [SI],0			    ;AN000;FO.
 24993 000043FF 751A                    	JNZ	short parfnd			    ;AN000;FO.; partiallyfound
 24994 00004401 51                      	PUSH	CX				    ;AN000;FO.; is attribute matched ?
 24995                                  
 24996                                  ;hkn; SS override for attrib/sattrib
 24997 00004402 368A0E[6B05]            	MOV	CL,[ss:ATTRIB]			    ;AN000;FO.;
 24998 00004407 368A2E[6D05]            	MOV	CH,[ss:SATTRIB]			    ;AN000;FO.; attrib=sattrib
 24999 0000440C 36882E[6B05]            	MOV	[ss:ATTRIB],CH			    ;AN000;FO.;
 25000                                  	;mov	ch,[es:di+0Bh]
 25001 00004411 268A6D0B                	MOV	CH,[ES:DI+dir_entry.dir_attr]	    ;AN000;FO.;
 25002 00004415 E815FE                  	call	MatchAttributes 		    ;AN000;FO.;
 25003                                  ;;;	MOV	[ss:ATTRIB],CL			    ;AN001;FO.; restore attrib
 25004 00004418 59                      	POP	CX				    ;AN000;FO.;
 25005 00004419 754F                    	JNZ	short NOLOOKUP			    ;AN000;FO.; not matched
 25006                                  parfnd:
 25007                                  
 25008                                  ;hkn; SS override
 25009 0000441B 368936[660D]            	MOV	[SS:Next_Element_Start],SI	    ; save si
 25010 00004420 89CB                    	MOV	BX,CX
 25011                                  	; MSDOS 6.0
 25012                                  	;mov	ax,[bx+7]
 25013 00004422 8B4707                  	MOV	AX,[BX+FEI.lastent]		    ;AN000;;FO. restore lastentry
 25014                                  ;hkn; SS override for LASTENT, DIRSTART, CLUSNUM
 25015 00004425 36A3[4803]              	MOV	[SS:LASTENT],AX			    ;AN000;;FO.
 25016 00004429 8B4709                  	MOV	AX,[BX+FEI.dirstart]		    ;AN001;;FO. restore dirstart
 25017 0000442C 36A3[C205]              	MOV	[SS:DIRSTART],AX		    ;AN001;;FO.
 25018                                  	; MSDOS 3.3 (& MSDOS 6.0)
 25019                                  	;;mov	ax,[bx+3] ; MSDOS 3.3
 25020                                  	;mov	ax,[bx+5] ; MSDOS 6.0
 25021 00004430 8B4705                  	MOV	AX,[BX+FEI.clusnum]		    ; restore next cluster num
 25022 00004433 36A3[BC05]              	MOV	[SS:CLUSNUM],AX			    ;
 25023                                  
 25024 00004437 06                      	PUSH	ES				    ; save ES
 25025                                  ;hkn; SS override
 25026 00004438 36C41E[8A05]            	LES	BX,[SS:THISDPB]			    ; put drive id
 25027 0000443D 268A27                  	mov	ah,[ES:BX] ; 15/08/2018
 25028                                  	;MOV	AH,[ES:BX+DPB.DRIVE]		    ; in AH for DOOPEN
 25029 00004440 07                      	POP	ES				    ; pop ES
 25030                                  ;SR;
 25031                                  ; We cannot have a root dir if we have come here. So, we zero out CurBuf to
 25032                                  ;indicate it is not a root dir
 25033                                  
 25034 00004441 36C706[E205]0000        	mov	word [SS:CURBUF],0		    ; indicate not root dir
 25035 00004448 368C06[E405]            	MOV	WORD [SS:CURBUF+2],ES		    ; [curbuf+2].bx points to
 25036 0000444D 89FB                    	MOV	BX,DI				    ; start of entry
 25037                                  	;lea	si,[di+1Ah]
 25038 0000444F 8D751A                  	LEA	SI,[DI+dir_entry.dir_first]	    ; [curbuf+2]:si points to
 25039                                  						    ; dir_first field in the
 25040                                  						    ; dir entry
 25041                                  ;hkn; SS override for FastOpenFlg
 25042                                  	;or	byte [ss:FastOpenFlg],12h ; 29/12/2022
 25043 00004452 36800E[3A0D]12          	OR	byte [SS:FastOpenFlg],Lookup_Success+Set_For_Search
 25044                                  ;	POP	AX
 25045 00004458 C3                      	RETN
 25046                                  NOTFOUND:
 25047 00004459 83F8FF                  	CMP	AX,-1				    ; not in memory ?
 25048 0000445C 7506                    	JNZ	short Partial_Success 		    ; yes, in memory
 25049 0000445E 36C606[3A0D]00          	MOV	byte [SS:FastOpenFlg],0		    ; no more fastopen
 25050                                  Partial_Success:
 25051                                  	;and	byte [SS:FastOpenFlg],0FBh
 25052 00004464 368026[3A0D]FB          	AND	byte [SS:FastOpenFlg],Special_Fill_Reset
 25053                                  NOLOOKUP:
 25054                                  ;	POP	AX
 25055 0000446A F9                      	STC
 25056 0000446B C3                      	RETN
 25057                                  
 25058                                  ;BREAK <InsertPath - call fastopen to insert dir entry info>
 25059                                  ;-----------------------------------------------------------------------------
 25060                                  ;
 25061                                  ; Procedure Name : InsertPath
 25062                                  ; Input:  FastOpen_Set flag set when from DOSOPEN otherwise 0
 25063                                  ;	  Lookup_Success flag set when got dir entry info from FASTOPEN
 25064                                  ;	  DS = DOSDATA
 25065                                  ; Output: FastOPen_Ext_Info is set and path dir info is inserted
 25066                                  ;
 25067                                  ;-----------------------------------------------------------------------------
 25068                                  
 25069                                  	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 25070                                  
 25071                                  InsertPath:
 25072 0000446C 9C                      	PUSHF
 25073                                  ;hkn; SS override for FastOpenFlag
 25074                                  	;test	byte [SS:FastOpenFlg], 1
 25075 0000446D 36F606[3A0D]01          	TEST	byte [SS:FastOpenFlg],FastOpen_Set ;only DOSOPEN can take advantage of
 25076 00004473 7479                    	JZ	short GET_NEXT_ELEMENT		; the FastOpen
 25077                                  	;test	byte [ss:FastOpenFlg],2
 25078 00004475 36F606[3A0D]02          	TEST	byte [SS:FastOpenFlg],Lookup_Success ; Lookup just happened
 25079 0000447B 740D                    	JZ	short INSERT_DIR_INFO		; no
 25080                                  	;and	byte [ss:FastOpenFlg],0FDh
 25081 0000447D 368026[3A0D]FD          	AND	byte [SS:FastOpenFlg],Lookup_Reset  ; we got dir info from fastopen so
 25082 00004483 368B3E[660D]            	MOV	DI,[SS:Next_Element_Start]	; no need to insert it again
 25083 00004488 EB5E                    	JMP	short GET_NEXT2
 25084                                  INSERT_DIR_INFO:				; save registers
 25085 0000448A 1E                      	PUSH	DS
 25086 0000448B 06                      	PUSH	ES
 25087 0000448C 53                      	PUSH	BX
 25088 0000448D 56                      	PUSH	SI
 25089 0000448E 57                      	PUSH	DI
 25090 0000448F 51                      	PUSH	CX
 25091 00004490 50                      	PUSH	AX
 25092                                  
 25093                                  ;hkn; SS override
 25094 00004491 36C53E[E205]            	LDS	DI,[SS:CURBUF]			; DS:DI -> buffer header
 25095 00004496 BE[3B0D]                	MOV	SI,FastOpen_Ext_Info
 25096                                  	;mov	ax,[di+6]
 25097 00004499 8B4506                  	MOV	AX,[DI+BUFFINFO.buf_sector]	; get directory sector
 25098                                  	; MSDOS 6.0
 25099                                  	;mov	[ss:si+1],ax
 25100 0000449C 36894401                	MOV	[SS:SI+FEI.dirsec],AX 		;AN000; >32mb save dir sector
 25101                                  	; 19/05/2019 - Retro DOS v4.0
 25102 000044A0 8B4508                  	MOV	AX,[DI+BUFFINFO.buf_sector+2]	;AN000; >32mb
 25103                                  
 25104                                  ;hkn; SS is DOSDATA
 25105 000044A3 16                      	push	ss
 25106 000044A4 1F                      	pop	ds
 25107                                  	; MSDOS 3.3	
 25108                                  	;;mov	[si+1],ax	
 25109                                  	;MOV	[SI+FEI.dirsec],AX
 25110                                  	; MSDOS 6.0
 25111                                  	;mov	[si+3],ax
 25112 000044A5 894403                  	MOV	[SI+FEI.dirsec+2],AX		;AN000;>32mb save high dir sector
 25113                                  	; MSDOS 3.3 (& MSDOS 6.0)
 25114 000044A8 A1[BC05]                	MOV	AX,[CLUSNUM]		; save next cluster number
 25115                                  	;;mov	[si+5],ax ; MSDOS 6.0
 25116                                  	;mov	[si+3],ax ; MSDOS 3.3
 25117 000044AB 894405                  	MOV	[SI+FEI.clusnum],AX
 25118                                  	; MSDOS 6.0
 25119 000044AE A1[4803]                	MOV	AX,[LASTENT]		;AN000;FO. save lastentry for search first
 25120                                  	;mov	[si+7],ax
 25121 000044B1 894407                  	MOV	[SI+FEI.lastent],AX	;AN000;FO.
 25122 000044B4 A1[C205]                	MOV	AX,[DIRSTART]		;AN001;FO. save  for search first
 25123                                  	;mov	[si+9],ax
 25124 000044B7 894409                  	MOV	[SI+FEI.dirstart],AX	;AN001;FO.
 25125                                  	; MSDOS 3.3 (& MSDOS 6.0)
 25126 000044BA 89D8                    	MOV	AX,BX
 25127                                  	;;add	di,16  ; MSDOS 3.3
 25128                                  	;add	di,20  ; MSDOS 6.0
 25129 000044BC 83C714                  	ADD	DI,BUFINSIZ		; DS:DI -> start of data in buffer
 25130 000044BF 29F8                    	SUB	AX,DI			; AX=BX relative to start of sector
 25131                                  	;mov	cl,32
 25132 000044C1 B120                    	MOV	CL,dir_entry.size
 25133 000044C3 F6F1                    	DIV	CL
 25134                                  	;MOV	[SI+FEI.dirpos],AL	; save directory entry # in buffer
 25135 000044C5 8804                    	mov	[si],al
 25136                                  
 25137 000044C7 1E                      	PUSH	DS
 25138 000044C8 07                      	POP	ES
 25139                                  
 25140 000044C9 8E1E[E405]              	MOV	DS,[CURBUF+2]
 25141 000044CD 89DF                    	MOV	DI,BX			; DS:DI -> dir entry info
 25142                                  	;cmp	word [di+1Ah],0
 25143 000044CF 837D1A00                	CMP	word [DI+dir_entry.dir_first],0 
 25144                                  					; never insert info when file is empty
 25145 000044D3 740C                    	JZ	short SKIP_INSERT	; e.g. newly created file
 25146                                  
 25147 000044D5 56                      	PUSH	SI			; ES:BX -> extended info
 25148 000044D6 5B                      	POP	BX
 25149                                  
 25150                                  	;mov	al,2
 25151 000044D7 B002                    	MOV	AL,FONC_insert		; call fastopen insert operation
 25152 000044D9 BE[300D]                	MOV	SI,FastOpenTable
 25153                                  	;call	far [es:si+2]	 ; call dword ptr es:[si+2] ; 29/12/2022
 25154                                  	; 07/12/2022
 25155 000044DC 26FF5C02                	CALL	far [ES:SI+fastopen_entry.name_caching]
 25156                                  
 25157 000044E0 F8                      	CLC
 25158                                  SKIP_INSERT:
 25159 000044E1 58                      	POP	AX
 25160 000044E2 59                      	POP	CX			; restore registers
 25161 000044E3 5F                      	POP	DI
 25162 000044E4 5E                      	POP	SI
 25163 000044E5 5B                      	POP	BX
 25164 000044E6 07                      	POP	ES
 25165 000044E7 1F                      	POP	DS
 25166                                  GET_NEXT2:
 25167                                  	;or	[ss:FastOpenFlg],8
 25168 000044E8 36800E[3A0D]08          	OR	byte [SS:FastOpenFlg],No_Lookup
 25169                                  					; we got dir info from fastopen so
 25170                                  GET_NEXT_ELEMENT:
 25171 000044EE 9D                      	POPF
 25172 000044EF C3                      	RETN
 25173                                  
 25174                                  ;============================================================================
 25175                                  ; DEV.ASM (MSDOS 6.0, 1991)
 25176                                  ;============================================================================
 25177                                  ; 17/07/2018 - Retro DOS v3.0
 25178                                  ; 30/04/2019 - Retro DOS v4.0
 25179                                  
 25180                                  ;**	Misc Routines to do 1-12 low level I/O and call devices
 25181                                  
 25182                                  ; Offset 12B8h of IBMDOS.COM (MSDOS 3.3), 1987
 25183                                  
 25184                                  ;DOSCODE:8401h (MSDOS 6.21, MSDOS.SYS)
 25185                                  
 25186                                  ;Public DEV001S, DEV001E 		; Pathgen labels
 25187                                  ;DEV001s:
 25188                                  ;		length of packets
 25189 000044F0 160E160D0F0E            LenTab:	 DB	DRDWRHL, DRDNDHL, DRDWRHL, DSTATHL, DFLSHL, DRDNDHL
 25190                                  ;LenTab: db	22,14,22,13,15,14
 25191                                  
 25192                                  ;	Error Function
 25193                                  
 25194                                  CmdTab:
 25195 000044F6 8604                    	DB	86h, DEVRD	; 0 input
 25196 000044F8 8605                    	DB	86h, DEVRDND	; 1 input status
 25197 000044FA 8708                    	DB	87h, DEVWRT	; 2 output
 25198 000044FC 870A                    	DB	87h, DEVOST	; 3 output status
 25199 000044FE 8607                    	DB	86h, DEVIFL	; 4 input flush
 25200 00004500 8605                    	DB	86h, DEVRDND	; 5 input status with system WAIT
 25201                                  
 25202                                  ; Offset 12BEh of IBMDOS.COM (MSDOS 3.3), 1987
 25203                                  
 25204                                  ;CmdTab:
 25205                                  ;	db	86h, 4
 25206                                  ;	db	86h, 5
 25207                                  ;	db	87h, 8
 25208                                  ;	db	87h, 10
 25209                                  ;	db	86h, 7
 25210                                  ;	db	86h, 5
 25211                                  
 25212                                  ;DEV001E:
 25213                                  
 25214                                  ; 30/04/2019 - Retro DOS v4.0
 25215                                  ; DOSCODE:8413h (MSDOS 6.21, MSDOS.SYS)
 25216                                  
 25217                                  ;Break	<IOFUNC -- DO FUNCTION 1-12 I/O>
 25218                                  ;----------------------------------------------------------------------------
 25219                                  ;
 25220                                  ; Procedure Name : IOFUNC
 25221                                  ;
 25222                                  ; Inputs:
 25223                                  ;	DS:SI Points to SFT
 25224                                  ;	AH is function code
 25225                                  ;		= 0 Input
 25226                                  ;		= 1 Input Status
 25227                                  ;		= 2 Output
 25228                                  ;		= 3 Output Status
 25229                                  ;		= 4 Flush
 25230                                  ;		= 5 Input Status - System WAIT invoked for K09 if no char
 25231                                  ;				   present.
 25232                                  ;	AL = character if output
 25233                                  ; Function:
 25234                                  ;	Perform indicated I/O to device or file
 25235                                  ; Outputs:
 25236                                  ;	AL is character if input
 25237                                  ;	If a status call
 25238                                  ;		zero set if not ready
 25239                                  ;		zero reset if ready (character in AL for input status)
 25240                                  ; For regular files:
 25241                                  ;	Input Status
 25242                                  ;		Gets character but restores position
 25243                                  ;		Zero set on EOF
 25244                                  ;	Input
 25245                                  ;		Gets character advances position
 25246                                  ;		Returns ^Z on EOF
 25247                                  ;	Output Status
 25248                                  ;		Always ready
 25249                                  ; AX altered, all other registers preserved
 25250                                  ;----------------------------------------------------------------------------
 25251                                  
 25252                                  ; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 25253                                  ; DOSCODE:83D8h (MSDOS 5.0, MSDOS.SYS)
 25254                                  
 25255                                  IOFUNC:
 25256 00004502 368C16[8C03]            	MOV	[SS:IOXAD+2],SS		; SS override for IOXAD, IOSCNT, 
 25257                                  					; DEVIOBUF
 25258 00004507 36C706[8A03][BC03]      	MOV	WORD [SS:IOXAD],DEVIOBUF
 25259 0000450E 36C706[8E03]0100        	MOV	WORD [SS:IOSCNT],1
 25260 00004515 36A3[BC03]              	MOV	WORD [SS:DEVIOBUF],AX
 25261                                  	;test	byte [si+6],80h
 25262                                  	;TEST	word [SI+SF_ENTRY.sf_flags],sf_isnet ; 8000h
 25263 00004519 F6440680                	test	byte [SI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
 25264 0000451D 7403                    	JZ	short IOTO22		;AN000;
 25265 0000451F E9A500                  	JMP	IOTOFILE		;AN000;
 25266                                  IOTO22:
 25267                                  	;test	word [si+5],80h
 25268                                  	;TEST	word [SI+SF_ENTRY.sf_flags],devid_device 
 25269 00004522 F6440580                	test	byte [SI+SF_ENTRY.sf_flags],devid_device	
 25270 00004526 7503                    	JNZ	short IOTO33		;AN000;
 25271 00004528 E99C00                  	JMP	IOTOFILE		;AN000;
 25272                                  IOTO33:
 25273 0000452B 06                      	push	es ; * (MSDOS 6.21)
 25274 0000452C E842BF                  	call	save_world
 25275 0000452F 8CDA                    	MOV	DX,DS
 25276 00004531 8CD3                    	MOV	BX,SS
 25277 00004533 8EDB                    	MOV	DS,BX
 25278 00004535 8EC3                    	MOV	ES,BX
 25279 00004537 31DB                    	XOR	BX,BX
 25280 00004539 80FC05                  	cmp	ah,5		    ; system wait enabled?
 25281 0000453C 7503                    	jnz	short _no_sys_wait
 25282                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 25283                                  	; 16/12/2022
 25284 0000453E 80CF04                  	or	bh,04h
 25285                                  	;or	bx,0400H	    ; Set bit 10 in status word for driver
 25286                                  				    ; It is up to device driver to carry out
 25287                                  				    ; appropriate action.
 25288                                  _no_sys_wait:
 25289 00004541 891E[7F03]              	MOV	[IOCALL_REQSTAT],BX
 25290 00004545 31DB                    	XOR	BX,BX
 25291 00004547 881E[8903]              	MOV	[IOMED],BL
 25292                                  
 25293 0000454B 88E3                    	MOV	BL,AH		 	; get function
 25294 0000454D 2E8AA7[F044]            	MOV	AH,[cs:BX+LenTab]
 25295 00004552 D1E3                    	SHL	BX,1
 25296 00004554 2E8B8F[F644]            	MOV	CX,[cs:BX+CmdTab]
 25297 00004559 BB[7C03]                	MOV	BX,IOCALL ; DOSDATA:037Ch
 25298 0000455C 8826[7C03]              	MOV	[IOCALL_REQLEN],AH
 25299 00004560 882E[7E03]              	MOV	[IOCALL_REQFUNC],CH
 25300                                  
 25301 00004564 8EDA                    	MOV	DS,DX
 25302 00004566 E86B01                  	CALL	DEVIOCALL
 25303 00004569 368B3E[7F03]            	MOV	DI,[SS:IOCALL_REQSTAT]	; SS override
 25304 0000456E 21FF                    	and	di,di
 25305 00004570 7834                    	js	short DevErr
 25306                                  OKDevIO:
 25307 00004572 8CD0                    	MOV	AX,SS
 25308 00004574 8ED8                    	MOV	DS,AX
 25309                                  
 25310                                  	;cmp	ch,5
 25311 00004576 80FD05                  	CMP	CH,DEVRDND
 25312 00004579 7506                    	JNZ	short DNODRD
 25313 0000457B A0[8903]                	MOV	AL,[IORCHR]
 25314 0000457E A2[BC03]                	MOV	[DEVIOBUF],AL
 25315                                  
 25316                                  DNODRD: 
 25317 00004581 8A26[8003]              	MOV	AH,[IOCALL_REQSTAT+1]
 25318 00004585 F6D4                    	NOT	AH			; Zero = busy, not zero = ready
 25319                                  	;and	ah,2
 25320 00004587 80E402                  	AND	AH,STBUI>>8
 25321                                  
 25322                                  QuickReturn:				;AN000; 2/13/KK
 25323 0000458A E8CDBE                  	call	restore_world
 25324 0000458D 07                      	pop	es ; * (MSDOS 6.21)
 25325                                  
 25326                                  	; SR;
 25327                                  	; We return ax = -1 if the user failed on I24. This is the case if 
 25328                                  	; IoStatFail = -1 (set after return from the I24)
 25329                                  
 25330                                  	; MSDOS 6.0
 25331 0000458E 9C                      	pushf
 25332 0000458F 36A0[8300]              	mov	al,[ss:IoStatFail]	;assume fail error
 25333 00004593 98                      	cbw				;sign extend to word
 25334 00004594 83F8FF                  	cmp	ax,-1
 25335 00004597 7507                    	jne	short not_fail_ret
 25336 00004599 36FE06[8300]            	inc	byte [ss:IoStatFail]
 25337 0000459E 9D                      	popf
 25338 0000459F C3                      	retn
 25339                                  
 25340                                  not_fail_ret:
 25341 000045A0 36A1[BC03]              	mov	ax,[ss:DEVIOBUF]	;ss override
 25342 000045A4 9D                      	popf
 25343 000045A5 C3                      	retn
 25344                                  
 25345                                  DevErr:
 25346 000045A6 88CC                    	MOV	AH,CL
 25347 000045A8 E88E0D                  	call	CHARHARD
 25348 000045AB 3C01                    	CMP	AL,1
 25349 000045AD 7507                    	JNZ	short NO_RETRY
 25350 000045AF E8A8BE                  	call	restore_world
 25351                                  	; 12/05/2019
 25352 000045B2 07                      	pop	es ; * (MSDOS 6.21)		
 25353 000045B3 E94CFF                  	JMP	IOFUNC	; 10/08/2018
 25354                                  
 25355                                  NO_RETRY:
 25356                                  	; Know user must have wanted Ignore OR Fail. Make sure device shows ready
 25357                                  	; ready so that DOS doesn't get caught in a status loop when user 
 25358                                  	; simply wants to ignore the error.
 25359                                  	;
 25360                                  	; SR; If fail wanted by user set ax to special value (ax = -1). This 
 25361                                  	; should be checked by the caller on return
 25362                                  
 25363                                  					; SS override
 25364 000045B6 368026[8003]FD          	and	byte [SS:IOCALL_REQSTAT+1],0FDh
 25365                                  	;AND	BYTE [SS:IOCALL_REQSTAT+1],~(STBUI>>8)
 25366                                  
 25367                                  	; SR;
 25368                                  	; Check if user failed
 25369                                  
 25370                                  	; MSDOS 6.0
 25371 000045BC 3C03                    	cmp	al,3
 25372 000045BE 7505                    	jnz	short not_fail
 25373 000045C0 36FE0E[8300]            	dec	byte [ss:IoStatFail]	;set flag indicating fail on I24
 25374                                  not_fail:
 25375 000045C5 EBAB                    	JMP	short OKDevIO
 25376                                  
 25377                                  IOTOFILE:
 25378 000045C7 08E4                    	OR	AH,AH
 25379 000045C9 7421                    	JZ	short IOIN
 25380 000045CB FECC                    	DEC	AH
 25381 000045CD 7405                    	JZ	short IOIST
 25382 000045CF FECC                    	DEC	AH
 25383 000045D1 7411                    	JZ	short IOUT
 25384                                  IOUT_retn:	; 18/12/2022
 25385 000045D3 C3                      	retn				; NON ZERO FLAG FOR OUTPUT STATUS
 25386                                  IOIST:
 25387                                  	;push	word [si+15h]
 25388 000045D4 FF7415                  	PUSH	WORD [SI+SF_ENTRY.sf_position]   ; Save position
 25389                                  	;push	word [si+17h]
 25390 000045D7 FF7417                  	PUSH	WORD [SI+SF_ENTRY.sf_position+2]
 25391 000045DA E80F00                  	CALL	IOIN
 25392                                  	;pop	word [si+17h]
 25393 000045DD 8F4417                  	POP	WORD [SI+SF_ENTRY.sf_position+2] ; Restore position
 25394                                  	;pop	word [si+15h]
 25395 000045E0 8F4415                  	POP	WORD [SI+SF_ENTRY.sf_position]
 25396 000045E3 C3                      	retn
 25397                                  IOUT:
 25398 000045E4 E82500                  	CALL	SETXADDR
 25399 000045E7 E880EF                  	call	DOS_WRITE
 25400                                  	;CALL	RESTXADDR	; If you change this into a jmp don't
 25401                                  	; 18/12/2022
 25402 000045EA EB52                    	jmp	RESTXADDR
 25403                                  ;IOUT_retn:
 25404                                  	;retn			; come crying to me when things don't
 25405                                  				; work ARR
 25406                                  IOIN:
 25407 000045EC E81D00                  	CALL	SETXADDR
 25408                                  					; SS override for DOS34_FLAG
 25409                                  	;OR	word [SS:DOS34_FLAG],Disable_EOF_I24	;AN000;
 25410                                  	;or	word [ss:DOS34_FLAG],40h
 25411                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 25412                                  	; 16/12/2022
 25413 000045EF 36800E[1106]40          	or	byte [ss:DOS34_FLAG],40h 
 25414 000045F5 E849ED                  	CALL	DOS_READ
 25415                                  	;AND	word [SS:DOS34_FLAG],NO_Disable_EOF_I24 ;AN000;
 25416                                  	;and	word [SS:DOS34_FLAG],0FFBFh
 25417                                  	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 25418                                  	; 16/12/2022
 25419 000045F8 368026[1106]BF          	and	byte [SS:DOS34_FLAG],0BFh ; 07/12/2022
 25420 000045FE 09C9                    	OR	CX,CX			; Check EOF
 25421 00004600 E83B00                  	CALL	RESTXADDR
 25422                                  					; SS override
 25423 00004603 36A0[BC03]              	MOV	AL,[SS:DEVIOBUF]	; Get byte from trans addr
 25424 00004607 75CA                    	jnz	short IOUT_retn	
 25425 00004609 B01A                    	MOV	AL,1AH			; ^Z if no bytes
 25426 0000460B C3                      	retn
 25427                                  
 25428                                  SETXADDR:
 25429                                  					; SS override
 25430 0000460C 368F06[6C03]            	POP	WORD [SS:CALLSCNT]	; Return address
 25431                                  
 25432 00004611 06                      	push	es ; * (MSDOS 6.21)
 25433                                  
 25434 00004612 E85CBE                  	call	save_world
 25435                                  					; SS override for DMAADD and THISSFT
 25436                                  	; 24/09/2023
 25437                                  	;PUSH	WORD [SS:DMAADD]	; Save Disk trans addr
 25438                                  	;PUSH	WORD [SS:DMAADD+2]
 25439 00004615 368C1E[A005]            	MOV	[SS:THISSFT+2],DS
 25440                                  
 25441 0000461A 16                      	push	ss
 25442 0000461B 1F                      	pop	ds
 25443                                  
 25444                                  	; 24/09/2023
 25445 0000461C FF36[2C03]              	push	word [DMAADD]
 25446 00004620 FF36[2E03]              	push	word [DMAADD+2]
 25447                                  
 25448 00004624 8936[9E05]              	MOV	[THISSFT],SI		; Finish setting SFT pointer
 25449 00004628 8B0E[8C03]              	MOV	CX,[IOXAD+2]
 25450 0000462C 890E[2E03]              	MOV	[DMAADD+2],CX
 25451 00004630 8B0E[8A03]              	MOV	CX,[IOXAD]
 25452 00004634 890E[2C03]              	MOV	[DMAADD],CX		; Set byte trans addr
 25453 00004638 8B0E[8E03]              	MOV	CX,[IOSCNT]		; ioscnt specifies length of buffer
 25454 0000463C EB10                    	JMP	SHORT RESTRET		; RETURN ADDRESS
 25455                                  
 25456                                  RESTXADDR:
 25457 0000463E 8F06[6C03]              	POP	WORD [CALLSCNT]		; Return address
 25458 00004642 8F06[2E03]              	POP	WORD [DMAADD+2]		; Restore Disk trans addr
 25459 00004646 8F06[2C03]              	POP	WORD [DMAADD]
 25460                                  
 25461 0000464A E80DBE                  	call	restore_world
 25462                                  
 25463 0000464D 07                      	pop	es ; * (MSDOS 6.21)
 25464                                  					; SS override
 25465                                  RESTRET:
 25466 0000464E 36FF26[6C03]            	JMP	WORD [SS:CALLSCNT]	; Return address
 25467                                  
 25468                                  ; DOSCODE:8569h (MSDOS 6.21, MSDOS.SYS)
 25469                                  ; 21/11/2022
 25470                                  ; DOSCODE:852Eh (MSDOS 5.0, MSDOS.SYS)
 25471                                  
 25472                                  ;Break <DEV_OPEN_SFT, DEV_CLOSE_SFT - OPEN or CLOSE A DEVICE>
 25473                                  
 25474                                  ;----------------------------------------------------------------------------
 25475                                  ;**	Dev_Open_SFT - Open the Device for an SFT
 25476                                  ;
 25477                                  ;	Dev_Open_SFT issues an open call to the device associated with
 25478                                  ;	the SFT.
 25479                                  ;
 25480                                  ;	ENTRY	(ES:DI) = SFT
 25481                                  ;	EXIT	none
 25482                                  ;	USES	all
 25483                                  ;----------------------------------------------------------------------------
 25484                                  
 25485                                  DEV_OPEN_SFT:
 25486 00004653 06                      	push	es ; * (MSDOS 6.21)
 25487 00004654 E81ABE                  	call	save_world
 25488                                  	;mov	al,0Dh	
 25489 00004657 B00D                    	MOV	AL,DEVOPN
 25490 00004659 EB06                    	JMP	SHORT DO_OPCLS
 25491                                  
 25492                                  ;----------------------------------------------------------------------------
 25493                                  ; Procedure Name : DEV_CLOSE_SFT
 25494                                  ;
 25495                                  ; Inputs:
 25496                                  ;	ES:DI Points to SFT
 25497                                  ; Function:
 25498                                  ;	Issue a CLOSE call to the correct device
 25499                                  ; Outputs:
 25500                                  ;	None
 25501                                  ; ALL preserved
 25502                                  ;----------------------------------------------------------------------------
 25503                                  
 25504                                  DEV_CLOSE_SFT:
 25505 0000465B 06                      	push	es ; * (MSDOS 6.21)
 25506 0000465C E812BE                  	call	save_world
 25507                                  	;mov	al,0Eh	
 25508 0000465F B00E                    	MOV	AL,DEVCLS
 25509                                  
 25510                                  	; Main entry for device open and close. AL contains the function 
 25511                                  	; requested. Subtlety: if Sharing is NOT loaded then we do NOT issue 
 25512                                  	; open/close to block devices. This allows networks to function but 
 25513                                  	; does NOT hang up with bogus change-line code.
 25514                                  
 25515                                  	;entry	DO_OPCLS
 25516                                  DO_OPCLS:
 25517                                  	; Is the SFT for the net? If so, no action necessary.
 25518                                  
 25519                                  	; MSDOS 6.0
 25520                                  	;test	word [es:di+5],8000h
 25521                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 25522 00004661 26F6450680              	test	byte [es:di+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
 25523 00004666 7567                    	jnz	short OPCLS_DONE	; NOP on net SFTs
 25524 00004668 30E4                    	XOR	AH,AH			; Unit
 25525                                  	;test	byte [es:di+5],80h
 25526 0000466A 26F6450580              	TEST	byte [ES:DI+SF_ENTRY.sf_flags],devid_device
 25527                                  	;les	di,[es:di+7]
 25528 0000466F 26C47D07                	LES	DI,[ES:DI+SF_ENTRY.sf_devptr] ; Get DPB or device
 25529 00004673 7513                    	JNZ	short GOT_DEV_ADDR
 25530                                  
 25531                                  	; We are about to call device open/close on a block driver. If no 
 25532                                  	; sharing then just short circuit to done.
 25533                                  	
 25534                                  	; MSDOS 6.0
 25535                                  					; SS override
 25536 00004675 36803E[0303]01          	CMP	byte [ss:fShare],1	;AN010; /NC or no SHARE
 25537 0000467B 7652                    	JBE	short OPCLS_DONE	;AN010; yes
 25538                                  
 25539                                  	; MSDOS 3.3 (& MSDOS 6.0)
 25540                                  	;mov	ah,[es:di+1]
 25541 0000467D 268A6501                	MOV	AH,[ES:DI+DPB.UNIT]	; (ah) = unit
 25542 00004681 268A0D                  	mov	cl,[es:di]
 25543                                  	;MOV	CL,[ES:DI+DPB.DRIVE]	; (cl) = drive
 25544                                  	;;les	di,[es:di+12h] ; MSDOS 3.3
 25545                                  	;les	di,[es:di+13h] ; MSDOS 6.0
 25546 00004684 26C47D13                	LES	DI,[ES:DI+DPB.DRIVER_ADDR] ; Get device
 25547                                  GOT_DEV_ADDR:				; ES:DI -> device
 25548                                  	;test	word [es:di+4],800h
 25549                                  	;TEST	word [ES:DI+SYSDEV.ATT],DEVOPCL
 25550 00004688 26F6450508              	test	byte [ES:DI+SYSDEV.ATT+1],(DEVOPCL>>8)
 25551 0000468D 7440                    	JZ	short OPCLS_DONE	; Device can't
 25552 0000468F 06                      	PUSH	ES
 25553 00004690 1F                      	POP	DS
 25554 00004691 89FE                    	MOV	SI,DI			; DS:SI -> device
 25555                                  
 25556                                  OPCLS_RETRY:
 25557                                  	;Context ES
 25558 00004693 16                      	push	ss
 25559 00004694 07                      	pop	es
 25560                                  					; DEVCALL is in DOSDATA
 25561 00004695 BF[5A03]                	MOV	DI,DEVCALL
 25562                                  
 25563 00004698 89FB                    	MOV	BX,DI
 25564 0000469A 50                      	PUSH	AX
 25565                                  	;mov	al,13
 25566 0000469B B00D                    	MOV	AL,DOPCLHL
 25567 0000469D AA                      	STOSB				; Length
 25568 0000469E 58                      	POP	AX
 25569 0000469F 86E0                    	XCHG	AH,AL
 25570 000046A1 AA                      	STOSB				; Unit
 25571 000046A2 86E0                    	XCHG	AH,AL
 25572 000046A4 AA                      	STOSB				; Command
 25573 000046A5 26C7050000              	MOV	WORD [ES:DI],0		; Status
 25574 000046AA 50                      	PUSH	AX			; Save Unit,Command
 25575                                  	;invoke	DEVIOCALL2
 25576 000046AB E82900                  	call	DEVIOCALL2
 25577                                  
 25578                                  	;mov	di,[es:bx+3]
 25579 000046AE 268B7F03                	MOV	DI,[ES:BX+SRHEAD.REQSTAT]
 25580                                  	;test	di,8000h
 25581                                  	;jz	short OPCLS_DONEP	
 25582 000046B2 21FF                    	and	di,di
 25583 000046B4 7918                    	jns	short OPCLS_DONEP	; No error
 25584                                  	; 21/11/2022
 25585                                  	;test	word [si+4],8000h
 25586                                  	;TEST	word [SI+SYSDEV.ATT],DEVTYP
 25587                                  	;test	word [si+5],80h
 25588 000046B6 F6440580                	test	byte [SI+SYSDEV.ATT+1],(DEVTYP>>8)
 25589 000046BA 7404                    	JZ	short BLKDEV
 25590 000046BC B486                    	MOV	AH,86H			; Read error in data, Char dev
 25591 000046BE EB04                    	JMP	SHORT HRDERR
 25592                                  BLKDEV:
 25593 000046C0 88C8                    	MOV	AL,CL			; Drive # in AL
 25594 000046C2 B406                    	MOV	AH,6			; Read error in data, Blk dev
 25595                                  HRDERR:
 25596                                  	;invoke	CHARHARD
 25597 000046C4 E8720C                  	call	CHARHARD
 25598 000046C7 3C01                    	cmp	al,1
 25599 000046C9 7503                    	jne	short OPCLS_DONEP	; IGNORE or FAIL
 25600                                  					;  Note that FAIL is essentually IGNORED
 25601 000046CB 58                      	POP	AX			; Get back Unit, Command
 25602 000046CC EBC5                    	JMP	short OPCLS_RETRY
 25603                                  OPCLS_DONEP:
 25604 000046CE 58                      	POP	AX			; Clean stack
 25605                                  OPCLS_DONE:
 25606 000046CF E888BD                  	call	restore_world
 25607 000046D2 07                      	pop	es ; * (MSDOS 6.21)
 25608 000046D3 C3                      	retn
 25609                                  
 25610                                  ; 30/04/2019 - Retro DOS v4.0
 25611                                  ; DOSCODE:85EAh (MSDOS 6.21, MSDOS.SYS)
 25612                                  
 25613                                  ; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 25614                                  ; DOSCODE:85AFh (MSDOS 5.0, MSDOS.SYS)
 25615                                  
 25616                                  ;Break	<DEVIOCALL, DEVIOCALL2 - CALL A DEVICE>
 25617                                  ;----------------------------------------------------------------------------
 25618                                  ;**	DevIoCall  - Call Device
 25619                                  ;
 25620                                  ;	ENTRY	DS:SI Points to device SFT
 25621                                  ;		ES:BX Points to request data
 25622                                  ;	EXIT	DS:SI -> Device driver
 25623                                  ;	USES	DS:SI,AX
 25624                                  ;----------------------------------------------------------------------------
 25625                                  ;**	DevIoCall2 - Call Device
 25626                                  ;
 25627                                  ;	ENTRY	DS:SI Points to DPB
 25628                                  ;		ES:BX Points to request data
 25629                                  ;	EXIT	DS:SI -> Device driver
 25630                                  ;	USES	DS:SI,AX
 25631                                  ;----------------------------------------------------------------------------
 25632                                  
 25633                                  DEVIOCALL:
 25634                                  					; SS override for CALLSSEC, 
 25635                                  	;lds	si,[si+7]		; CALLNEWSC, HIGH_SECTOR & CALLDEVAD
 25636 000046D4 C57407                  	LDS	SI,[SI+SF_ENTRY.sf_devptr]
 25637                                  
 25638                                  	;entry	DEVIOCALL2
 25639                                  DEVIOCALL2:
 25640                                  	;EnterCrit critDevice
 25641 000046D7 E8B2CC                  	call	ECritDevice
 25642                                  
 25643                                  	; MSDOS 6.0
 25644                                  	;TEST	word [SI+SYSDEV.ATT],DEVTYP ;AN000; >32mb block device ?
 25645                                  	;test	byte [si+5],80h
 25646 000046DA F6440580                	test	byte [si+SYSDEV.ATT+1],(DEVTYP>>8)
 25647 000046DE 7548                    	jnz	short chardev2		;AN000; >32mb no
 25648                                  
 25649                                  	; 16/12/2022
 25650                                  	; 22/11/2022
 25651 000046E0 268A4702                	mov	al,[ES:BX+SRHEAD.REQFUNC] ; [es:bx+2]
 25652 000046E4 3C04                    	cmp	al,DEVRD	; 4
 25653 000046E6 7408                    	je	short chkext	
 25654 000046E8 3C08                    	cmp	al,DEVWRT	; 8
 25655 000046EA 7404                    	je	short chkext
 25656 000046EC 3C09                    	cmp	al,DEVWRTV	; 9
 25657 000046EE 7538                    	jne	short chardev2
 25658                                  
 25659                                  	; 16/12/2022
 25660                                  	; 22/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 25661                                  	;;cmp	byte [es:bx+2],4
 25662                                  	;CMP	byte [ES:BX+SRHEAD.REQFUNC],DEVRD  ;AN000; >32mb read ?
 25663                                  	;JZ	short chkext		;AN000; >32mb   yes
 25664                                  	;;cmp	byte [es:bx+2],8
 25665                                  	;CMP	byte [ES:BX+SRHEAD.REQFUNC],DEVWRT ;AN000; >32mb write ?
 25666                                  	;JZ	short chkext		;AN000; >32mb   yes
 25667                                  	;;cmp	byte [es:bx+2],9
 25668                                  	;CMP	byte [ES:BX+SRHEAD.REQFUNC],DEVWRTV
 25669                                  	;				;AN000; >32mb write/verify ?
 25670                                  	;JNZ	short chardev2		;AN000; >32mb no
 25671                                  chkext:
 25672 000046F0 E89900                  	CALL	RW_SC			;AN000;LB. use secondary cache if there
 25673 000046F3 7255                    	JC	short dev_exit		;AN000;LB. done
 25674                                  
 25675                                  	;test	byte [si+4],2
 25676 000046F5 F6440402                	TEST	byte [SI+SYSDEV.ATT],EXTDRVR ;AN000;>32mb extended driver?
 25677 000046F9 741D                    	JZ	short chksector		;AN000;>32mb   no
 25678 000046FB 26800708                	ADD	BYTE [ES:BX],8		;AN000;>32mb   make length to 30
 25679 000046FF 36A1[6E03]              	MOV	AX,[SS:CALLSSEC]	;AN000;>32mb
 25680 00004703 36C706[6E03]FFFF        	MOV	word [SS:CALLSSEC],-1	;AN000;>32mb   old sector  =-1
 25681 0000470A 36A3[7403]              	MOV	[SS:CALLNEWSC],AX	;AN000;>32mb   new sector  =
 25682 0000470E 36A1[0706]              	MOV	AX,[SS:HIGH_SECTOR]	;AN000; >32mb  low sector,high sector
 25683 00004712 36A3[7603]              	MOV	[SS:CALLNEWSC+2],AX	;AN000; >32mb
 25684 00004716 EB10                    	JMP	short chardev2		;AN000; >32mb
 25685                                  chksector:				;AN000; >32mb
 25686 00004718 36833E[0706]00          	CMP	word [SS:HIGH_SECTOR],0	;AN000; >32mb   if >32mb
 25687 0000471E 7408                    	JZ	short chardev2		;AN000; >32mb   then fake error
 25688                                  	;mov	word [es:bx+3],8107h
 25689 00004720 26C747030781            	MOV	word [ES:BX+SRHEAD.REQSTAT],STERR+STDON+error_I24_not_DOS_disk 
 25690                                  					;AN000; >32mb
 25691 00004726 EB22                    	JMP	SHORT dev_exit		;AN000; >32mb
 25692                                  
 25693                                  chardev2:				;AN000;
 25694                                  	; As above only DS:SI points to device header on entry, and DS:SI is 
 25695                                  	; preserved
 25696                                  
 25697                                  	;mov	ax,[si+6]
 25698 00004728 8B4406                  	MOV	AX,[SI+SYSDEV.STRAT]
 25699 0000472B 36A3[7803]              	MOV	[SS:CALLDEVAD],AX
 25700 0000472F 368C1E[7A03]            	MOV	[SS:CALLDEVAD+2],DS
 25701 00004734 36FF1E[7803]            	CALL	far [SS:CALLDEVAD]
 25702                                  
 25703                                  	;mov	ax,[si+8]
 25704 00004739 8B4408                  	MOV	AX,[SI+SYSDEV.INT]
 25705 0000473C 36A3[7803]              	MOV	[SS:CALLDEVAD],AX
 25706 00004740 36FF1E[7803]            	CALL	far [SS:CALLDEVAD]
 25707                                  
 25708                                  	; MSDOS 6.0
 25709 00004745 E83A01                  	CALL	VIRREAD 		;AN000;LB. move data from SC to buffer
 25710 00004748 72DE                    	JC	short chardev2		;AN000;LB. bad sector or exceeds max sec
 25711                                  
 25712                                  dev_exit:
 25713                                  	;LeaveCrit critDevice
 25714                                  	;call	LCritDevice
 25715                                  	;retn
 25716                                  	; 18/12/2022
 25717 0000474A E95ACC                  	jmp	LCritDevice
 25718                                  
 25719                                  ; DOSCODE:8669h (MSDOS 6.21, MSDOS.SYS)
 25720                                  ; 22/11/2022
 25721                                  ; DOSCODE:862Eh (MSDOS 5.0, MSDOS.SYS)
 25722                                  
 25723                                  ;Break	<SETREAD, SETWRITE -- SET UP HEADER BLOCK>
 25724                                  ;---------------------------------------------------------------------------
 25725                                  ;
 25726                                  ; Procedure Name : SETREAD, SETWRITE
 25727                                  ;
 25728                                  ; Inputs:
 25729                                  ;	DS:BX = Transfer Address
 25730                                  ;	CX = Record Count
 25731                                  ;	DX = Starting Record
 25732                                  ;	AH = Media Byte
 25733                                  ;	AL = Unit Code
 25734                                  ; Function:
 25735                                  ;	Set up the device call header at DEVCALL
 25736                                  ; Output:
 25737                                  ;	ES:BX Points to DEVCALL
 25738                                  ; No other registers effected
 25739                                  ;
 25740                                  ;---------------------------------------------------------------------------
 25741                                  
 25742                                  SETREAD:
 25743 0000474D 57                      	PUSH	DI
 25744 0000474E 51                      	PUSH	CX
 25745 0000474F 50                      	PUSH	AX
 25746 00004750 B104                    	MOV	CL,DEVRD ; mov cl,4
 25747                                  SETCALLHEAD:
 25748 00004752 B016                    	MOV	AL,DRDWRHL ; mov al,16h
 25749 00004754 16                      	PUSH	SS
 25750 00004755 07                      	POP	ES
 25751                                  					; DEVCALL is in DOSDATA
 25752 00004756 BF[5A03]                	MOV	DI,DEVCALL
 25753                                  
 25754 00004759 AA                      	STOSB				; length
 25755 0000475A 58                      	POP	AX			; 
 25756 0000475B AA                      	STOSB				; Unit
 25757 0000475C 50                      	PUSH	AX
 25758 0000475D 88C8                    	MOV	AL,CL
 25759 0000475F AA                      	STOSB				; Command code
 25760 00004760 31C0                    	XOR	AX,AX
 25761 00004762 AB                      	STOSW				; Status
 25762 00004763 83C708                  	ADD	DI,8			; Skip link fields
 25763 00004766 58                      	POP	AX
 25764 00004767 86E0                    	XCHG	AH,AL
 25765 00004769 AA                      	STOSB				; Media byte
 25766 0000476A 86C4                    	XCHG	AL,AH
 25767 0000476C 50                      	PUSH	AX
 25768 0000476D 89D8                    	MOV	AX,BX
 25769 0000476F AB                      	STOSW
 25770                                  
 25771 00004770 8CD8                    	MOV	AX,DS
 25772 00004772 AB                      	STOSW				; Transfer addr
 25773                                  
 25774 00004773 59                      	POP	CX			; Real AX
 25775 00004774 58                      	POP	AX			; Real CX
 25776 00004775 AB                      	STOSW				; Count
 25777                                  
 25778 00004776 92                      	XCHG	AX,DX			; AX=Real DX, DX=real CX, CX=real AX
 25779 00004777 AB                      	STOSW				; Start
 25780 00004778 91                      	XCHG	AX,CX
 25781 00004779 87D1                    	XCHG	DX,CX
 25782 0000477B 5F                      	POP	DI
 25783                                  					; DEVCALL is in DOSDATA
 25784 0000477C BB[5A03]                	MOV	BX,DEVCALL
 25785 0000477F C3                      	retn
 25786                                  
 25787                                  	;entry	SETWRITE
 25788                                  SETWRITE:
 25789                                  
 25790                                  ; Inputs:
 25791                                  ;	DS:BX = Transfer Address
 25792                                  ;	CX = Record Count
 25793                                  ;	DX = Starting Record
 25794                                  ;	AH = Media Byte
 25795                                  ;	AL = Unit Code
 25796                                  ; Function:
 25797                                  ;	Set up the device call header at DEVCALL
 25798                                  ; Output:
 25799                                  ;	ES:BX Points to DEVCALL
 25800                                  ; No other registers effected
 25801                                  
 25802 00004780 57                      	PUSH	DI
 25803 00004781 51                      	PUSH	CX
 25804 00004782 50                      	PUSH	AX
 25805 00004783 B108                    	MOV	CL,DEVWRT ; mov cl,8
 25806 00004785 36020E[FF02]            	ADD	CL,[SS:VERFLG]		; SS override
 25807 0000478A EBC6                    	JMP	SHORT SETCALLHEAD
 25808                                  
 25809                                  ; 30/04/2019 - Retro DOS v4.0
 25810                                  ; DOSCODE:86A8h (MSDOS 6.21, MSDOS.SYS)
 25811                                  ; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 25812                                  ; DOSCODE:866Dh (MSDOS 5.0, MSDOS.SYS)
 25813                                  
 25814                                  ;Break	<RW_SC -- Read Write Secondary Cache>
 25815                                  ;---------------------------------------------------------------------------
 25816                                  ;
 25817                                  ; Procedure Name : RW_SC
 25818                                  ;
 25819                                  ; Inputs:
 25820                                  ;	 [SC_CACHE_COUNT]= secondary cache count
 25821                                  ;	 [SC_STATUS]= SC validity status
 25822                                  ;	 [SEQ_SECTOR]= last sector read
 25823                                  ; Function:
 25824                                  ;	Read from or write through secondary cache
 25825                                  ; Output:
 25826                                  ;	ES:BX Points to DEVCALL
 25827                                  ;	carry clear, I/O is not done
 25828                                  ;		     [SC_FLAG]=1 if continuos sectors will be read
 25829                                  ;	carry set, I/O is done
 25830                                  ;
 25831                                  ;----------------------------------------------------------------------------
 25832                                  
 25833                                  RW_SC:
 25834                                  	; SS override for all variables used.
 25835                                  	
 25836 0000478C 36833E[7700]00          	CMP	word [ss:SC_CACHE_COUNT],0  ;AN000;LB. secondary cache exists?
 25837 00004792 7421                    	JZ	short scexit4		    ;AN000;LB. no, do nothing
 25838 00004794 36833E[6C03]01          	CMP	word [ss:CALLSCNT],1	    ;AN000;LB. sector count = 1 (buffer I/O)
 25839 0000479A 7519                    	JNZ	short scexit4 		    ;AN000;LB. no, do nothing
 25840 0000479C 51                      	PUSH	CX			    ;AN000;LB.
 25841 0000479D 52                      	PUSH	DX			    ;AN000;LB. yes
 25842 0000479E 1E                      	PUSH	DS			    ;AN000;LB. save registers
 25843 0000479F 56                      	PUSH	SI			    ;AN000;LB.
 25844 000047A0 06                      	PUSH	ES			    ;AN000;LB.
 25845 000047A1 57                      	PUSH	DI			    ;AN000;LB.
 25846                                  
 25847 000047A2 368B16[6E03]            	MOV	DX,[ss:CALLSSEC]	    ;AN000;LB. starting sector
 25848 000047A7 36803E[5C03]04          	CMP	BYTE [ss:DEVCALL_REQFUNC],DEVRD ;AN000;LB. read ?
 25849 000047AD 7408                    	JZ	short doread		    ;AN000;LB. yes
 25850 000047AF E8BE00                  	CALL	INVALIDATE_SC		    ;AN000;LB. invalidate SC
 25851 000047B2 E98B00                  	JMP	scexit2 		    ;AN000;LB. back to normal
 25852                                  scexit4:				    ;AN000;
 25853 000047B5 F8                      	CLC				    ;AN000;LB. I/O not done yet
 25854 000047B6 C3                      	retn				    ;AN000;LB.
 25855                                  doread: 				    ;AN000;
 25856 000047B7 E82001                  	CALL	SC2BUF			    ;AN000;LB. check if in SC
 25857 000047BA 720A                    	JC	short readSC		    ;AN000;LB.
 25858 000047BC 36C706[5D03]0001        	MOV	word [ss:DEVCALL_REQSTAT],STDON ;AN000;LB. fake done and ok
 25859 000047C3 F9                      	STC				    ;AN000;LB. set carry
 25860 000047C4 EB68                    	JMP	short saveseq 		    ;AN000;LB. save seq. sector #
 25861                                  readSC: 				    ;AN000;
 25862 000047C6 36A1[0706]              	MOV	AX,[ss:HIGH_SECTOR]   	    ;AN000;LB. subtract sector num from
 25863 000047CA 368B0E[6E03]            	MOV	CX,[ss:CALLSSEC]	    ;AN000;LB. saved sequential sector
 25864 000047CF 362B0E[A90D]            	SUB	CX,[ss:SEQ_SECTOR]    	    ;AN000;LB. number
 25865 000047D4 361B06[AB0D]            	SBB	AX,[ss:SEQ_SECTOR+2]  	    ;AN000;LB.
 25866                                  	; 24/09/2023
 25867                                  	;CMP	AX,0			    ;AN000;LB. greater than 64K
 25868 000047D9 7552                    	JNZ	short saveseq2		    ;AN000;LB. yes,save seq. sector #
 25869                                  chklow: 						
 25870 000047DB 83F901                  	CMP	CX,1			    ;AN000;LB. <= 1
 25871 000047DE 774D                    	JA	short saveseq2		    ;AN000;LB. no, not sequential
 25872 000047E0 36C706[B50D]FFFF        	MOV	word [ss:SC_STATUS],-1	    ;AN000;LB. presume all SC valid
 25873 000047E7 36A1[7700]              	MOV	AX,[ss:SC_CACHE_COUNT]	    ;AN000;LB. yes, sequential
 25874 000047EB 36A3[6C03]              	MOV	[ss:CALLSCNT],AX	    ;AN000;LB. read continuous sectors
 25875                                  readsr:
 25876 000047EF 36A1[6A03]              	MOV	AX,[ss:CALLXAD+2]	    ;AN000;LB. save buffer addr
 25877 000047F3 36A3[0E06]              	MOV	[ss:TEMP_VAR2],AX	    ;AN000;LB. in temp vars
 25878 000047F7 36A1[6803]              	MOV	AX,[ss:CALLXAD]	    	    ;AN000;LB.
 25879 000047FB 36A3[0C06]              	MOV	[ss:TEMP_VAR],AX	    ;AN000;LB.
 25880                                  
 25881 000047FF 36A1[7300]              	MOV	AX,[ss:SC_CACHE_PTR]	    ;AN000;LB. use SC cache addr as
 25882 00004803 36A3[6803]              	MOV	[ss:CALLXAD],AX		    ;AN000;LB. transfer addr
 25883 00004807 36A1[7500]              	MOV	AX,[ss:SC_CACHE_PTR+2]	    ;AN000;LB.
 25884 0000480B 36A3[6A03]              	MOV	[ss:CALLXAD+2],AX	    ;AN000;LB.
 25885 0000480F 36C606[B70D]01          	MOV	byte [ss:SC_FLAG],1	    ;AN000;LB. flag it for later;
 25886 00004815 36A0[AF0D]              	MOV	AL,[ss:SC_DRIVE]	    ;AN000;LB. current drive
 25887 00004819 36A2[B00D]              	MOV	[ss:CurSC_DRIVE],AL	    ;AN000;LB. set current drive
 25888 0000481D 36A1[6E03]              	MOV	AX,[ss:CALLSSEC]	    ;AN000;LB. current sector
 25889 00004821 36A3[B10D]              	MOV	[ss:CurSC_SECTOR],AX	    ;AN000;LB. set current sector
 25890 00004825 36A1[0706]              	MOV	AX,[ss:HIGH_SECTOR]	    ;AN000;LB.
 25891 00004829 36A3[B30D]              	MOV	[ss:CurSC_SECTOR+2],AX	    ;AN000;LB.
 25892                                  saveseq2:				    ;AN000;
 25893 0000482D F8                      	CLC				    ;AN000;LB. clear carry
 25894                                  saveseq:				    ;AN000;	
 25895 0000482E 36A1[0706]              	MOV	AX,[ss:HIGH_SECTOR]	    ;AN000;LB. save current sector #
 25896 00004832 36A3[AB0D]              	MOV	[ss:SEQ_SECTOR+2],AX	    ;AN000;LB. for access mode ref.
 25897 00004836 36A1[6E03]              	MOV	AX,[ss:CALLSSEC]	    ;AN000;LB.	
 25898 0000483A 36A3[A90D]              	MOV	[ss:SEQ_SECTOR],AX 	    ;AN000;LB.	
 25899 0000483E EB01                    	JMP	short scexit 		    ;AN000;LB.	
 25900                                  scexit2:				    ;AN000;LB.
 25901 00004840 F8                      	CLC				    ;AN000;LB.	clear carry
 25902                                  scexit: 				    ;AN000;		
 25903 00004841 5F                      	POP	DI			    ;AN000;LB.
 25904 00004842 07                      	POP	ES			    ;AN000;LB. restore registers
 25905 00004843 5E                      	POP	SI			    ;AN000;LB.
 25906 00004844 1F                      	POP	DS			    ;AN000;LB.
 25907 00004845 5A                      	POP	DX			    ;AN000;LB.
 25908 00004846 59                      	POP	CX			    ;AN000;LB.
 25909 00004847 C3                      	retn				    ;AN000;LB.
 25910                                  
 25911                                  ;Break	<IN_SC -- check if in secondary cache>
 25912                                  ;--------------------------------------------------------------------------
 25913                                  ;
 25914                                  ; Procedure Name : IN_SC
 25915                                  ;
 25916                                  ; Inputs:  [SC_DRIVE]= requesting drive
 25917                                  ;	   [CURSC_DRIVE]= current SC drive
 25918                                  ;	   [CURSC_SECTOR]= starting scetor # of SC
 25919                                  ;	   [SC_CACHE_COUNT]= SC count
 25920                                  ;	   [HIGH_SECTOR]:DX= sector number
 25921                                  ; Function:
 25922                                  ;	Check if the sector is in secondary cache
 25923                                  ; Output:
 25924                                  ;	carry clear, in SC
 25925                                  ;	   CX= the index in the secondary cache
 25926                                  ;	carry set, not in SC
 25927                                  ;
 25928                                  ;---------------------------------------------------------------------------
 25929                                  
 25930                                  	; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 25931                                  IN_SC:
 25932                                  	; SS override for all variables used
 25933 00004848 36A0[AF0D]              	MOV	AL,[ss:SC_DRIVE]	    ;AN000;;LB. current drive
 25934 0000484C 363A06[B00D]            	CMP	AL,[ss:CurSC_DRIVE]	    ;AN000;;LB. same as SC drive
 25935 00004851 751B                    	JNZ	short outrange2		    ;AN000;;LB. no
 25936 00004853 36A1[0706]              	MOV	AX,[ss:HIGH_SECTOR]	    ;AN000;;LB. subtract sector num from
 25937 00004857 89D1                    	MOV	CX,DX			    ;AN000;;LB. secondary starting sector
 25938 00004859 362B0E[B10D]            	SUB	CX,[ss:CurSC_SECTOR]        ;AN000;;LB. number
 25939 0000485E 361B06[B30D]            	SBB	AX,[ss:CurSC_SECTOR+2]      ;AN000;;LB.
 25940                                  	; 24/09/2023
 25941                                  	;CMP	AX,0			    ;AN000;;LB. greater than 64K
 25942 00004863 7509                    	JNZ	short outrange2		    ;AN000;;LB. yes
 25943 00004865 363B0E[7700]            	CMP	CX,[ss:SC_CACHE_COUNT]	    ;AN000;;LB. greater than SC count
 25944 0000486A 7302                    	JAE	short outrange2		    ;AN000;;LB. yes
 25945 0000486C F8                      	CLC				    ;AN000;;LB. clear carry
 25946                                  	;JMP	short inexit		    ;AN000;;LB. in SC
 25947                                  	; 16/12/2022
 25948 0000486D C3                      	retn	; 30/04/2019
 25949                                  	; 22/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 25950                                  	;jmp	short inexit
 25951                                  
 25952                                  outrange2:				    ;AN000;;LB. set carry
 25953 0000486E F9                      	STC				    ;AN000;;LB.
 25954                                  inexit: 				    ;AN000;;LB.
 25955 0000486F C3                      	retn				    ;AN000;;LB.
 25956                                  
 25957                                  ;Break	<INVALIDATE_SC - invalide secondary cache>
 25958                                  ;---------------------------------------------------------------------------
 25959                                  ;
 25960                                  ; Procedure Name : Invalidate_Sc
 25961                                  ;
 25962                                  ; Inputs:  [SC_DRIVE]= requesting drive
 25963                                  ;	   [CURSC_DRIVE]= current SC drive
 25964                                  ;	   [CURSC_SECTOR]= starting scetor # of SC
 25965                                  ;	   [SC_CACHE_COUNT]= SC count
 25966                                  ;	   [SC_STATUS]= SC status word
 25967                                  ;	   [HIGH_SECTOR]:DX= sector number
 25968                                  ;
 25969                                  ; Function:
 25970                                  ;	invalidate secondary cache if in there
 25971                                  ; Output:
 25972                                  ;	[SC_STATUS] is updated
 25973                                  ;---------------------------------------------------------------------------
 25974                                  
 25975                                  INVALIDATE_SC:
 25976                                  	; SS override for all variables used
 25977                                  
 25978 00004870 E8D5FF                  	CALL	IN_SC			    ;AN000;;LB. in secondary cache
 25979 00004873 720C                    	JC	short outrange		    ;AN000;;LB. no
 25980 00004875 B80100                  	MOV	AX,1			    ;AN000;;LB. invalidate the sector
 25981 00004878 D3E0                    	SHL	AX,CL			    ;AN000;;LB. in the secondary cache
 25982 0000487A F7D0                    	NOT	AX			    ;AN000;;LB.
 25983 0000487C 362106[B50D]            	AND	[ss:SC_STATUS],AX	    ;AN000;;LB. save the status
 25984                                  outrange:				    ;AN000;;LB.
 25985 00004881 C3                      	retn				    ;AN000;;LB.
 25986                                  
 25987                                  ; DOSCODE:87A5h (MSDOS 6.21, MSDOS.SYS)
 25988                                  ; 22/11/2022
 25989                                  ; DOSCODE:876Ah (MSDOS 5.0, MSDOS.SYS)
 25990                                  
 25991                                  ;Break	<VIRREAD- virtually read data into buffer>
 25992                                  ;--------------------------------------------------------------------------
 25993                                  ;
 25994                                  ; Procedure Name : SC_FLAG
 25995                                  ;
 25996                                  ; Inputs:  SC_FLAG = 0, no sectors were read into SC
 25997                                  ;		     1, continuous sectors were read into SC
 25998                                  ; Function:
 25999                                  ;	   Move data from SC to buffer
 26000                                  ; Output:
 26001                                  ;	 carry clear, data is moved to buffer
 26002                                  ;	 carry set, bad sector or exceeds maximum sector
 26003                                  ;	   SC_FLAG =0
 26004                                  ;	   CALLSCNT=1
 26005                                  ;	   SC_STATUS= -1 if succeeded
 26006                                  ;     
 26007                                  ;		       0 if failed
 26008                                  ;--------------------------------------------------------------------------
 26009                                  
 26010                                  VIRREAD:
 26011                                  	; SS override for all variables used
 26012                                  
 26013 00004882 36803E[B70D]00          	CMP	byte [ss:SC_FLAG],0	    ;AN000;;LB. from SC fill
 26014 00004888 744E                    	JZ	short sc2end		    ;AN000;;LB. no
 26015 0000488A 36A1[0E06]              	MOV	AX,[ss:TEMP_VAR2]	    ;AN000;;LB. restore buffer addr
 26016 0000488E 36A3[6A03]              	MOV	[ss:CALLXAD+2],AX	    ;AN000;;LB.
 26017 00004892 36A1[0C06]              	MOV	AX,[ss:TEMP_VAR]	    ;AN000;;LB.
 26018 00004896 36A3[6803]              	MOV	[ss:CALLXAD],AX		    ;AN000;;LB.
 26019 0000489A 36C606[B70D]00          	MOV	byte [ss:SC_FLAG],0	    ;AN000;;LB. reset sc_flag
 26020 000048A0 36C706[6C03]0100        	MOV	word [ss:CALLSCNT],1	    ;AN000;;LB. one sector transferred
 26021                                  
 26022                                  	;TEST	word [SS:DEVCALL_REQSTAT],STERR ;AN000;;LB. error?
 26023 000048A7 36F606[5E03]80          	test	byte [ss:DEVCALL_REQSTAT+1],(STERR>>8) ; 80h
 26024 000048AD 7513                    	JNZ	short scerror 		    ;AN000;;LB. yes
 26025 000048AF 1E                      	PUSH	DS			    ;AN000;;LB.
 26026 000048B0 56                      	PUSH	SI			    ;AN000;;LB.
 26027 000048B1 06                      	PUSH	ES			    ;AN000;;LB.
 26028 000048B2 57                      	PUSH	DI			    ;AN000;;LB.
 26029 000048B3 52                      	PUSH	DX			    ;AN000;;LB.
 26030 000048B4 51                      	PUSH	CX			    ;AN000;;LB.
 26031 000048B5 31C9                    	XOR	CX,CX			    ;AN000;;LB. we want first sector in SC
 26032 000048B7 E83100                  	CALL	SC2BUF2 		    ;AN000;;LB. move data from SC to buf
 26033 000048BA 59                      	POP	CX
 26034 000048BB 5A                      	POP	DX			    ;AN000;;LB.
 26035 000048BC 5F                      	POP	DI			    ;AN000;;LB.
 26036 000048BD 07                      	POP	ES			    ;AN000;;LB.
 26037 000048BE 5E                      	POP	SI			    ;AN000;;LB.
 26038 000048BF 1F                      	POP	DS			    ;AN000;;LB.
 26039 000048C0 EB16                    	JMP	SHORT sc2end		    ;AN000;;LB. return
 26040                                  scerror:				    ;AN000;
 26041 000048C2 36C706[6C03]0100        	MOV	word [ss:CALLSCNT],1	    ;AN000;;LB. reset sector count to 1
 26042 000048C9 36C706[B50D]0000        	MOV	word [ss:SC_STATUS],0	    ;AN000;;LB. invalidate all SC sectors
 26043 000048D0 36C606[B00D]FF          	MOV	byte [ss:CurSC_DRIVE],-1    ;AN000;;LB. invalidate drive
 26044 000048D6 F9                      	STC				    ;AN000;;LB. carry set
 26045 000048D7 C3                      	retn				    ;AN000;;LB.
 26046                                  sc2end: 				    ;AN000;
 26047 000048D8 F8                      	CLC				    ;AN000;;LB. carry clear
 26048 000048D9 C3                      	retn				    ;AN000;;LB.
 26049                                  
 26050                                  ; 30/04/2019 - Retro  DOS v4.0
 26051                                  ; DOSCODE:87FDh (MSDOS 6.21, MSDOS.SYS)
 26052                                  ; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 26053                                  ; DOSCODE:87C2h (MSDOS 5.0, MSDOS.SYS)
 26054                                  
 26055                                  ;Break	<SC2BUF- move data from SC to buffer>
 26056                                  ;----------------------------------------------------------------------------
 26057                                  ;
 26058                                  ; Procedure Name : SC2BUF
 26059                                  ;
 26060                                  ; Inputs:  [SC_STATUS] = SC validity status
 26061                                  ;	   [SC_SECTOR_SIZE] = request sector size
 26062                                  ;	   [SC_CACHE_PTR] = pointer to SC
 26063                                  ; Function:
 26064                                  ;	   Move data from SC to buffer
 26065                                  ; Output:
 26066                                  ;	   carry clear, in SC  and data is moved
 26067                                  ;	   carry set, not in SC and data is not moved
 26068                                  ;---------------------------------------------------------------------------
 26069                                  
 26070                                  SC2BUF:
 26071                                  	; SS override for all variables used
 26072 000048DA E86BFF                  	CALL	IN_SC			    ;AN000;LB. in secondary cache
 26073                                  	;JC	short noSC		    ;AN000;LB. no
 26074                                  	; 24/09/2023
 26075 000048DD 723D                    	jc	short sexit
 26076 000048DF B80100                  	MOV	AX,1			    ;AN000;LB. check if valid sector
 26077 000048E2 D3E0                    	SHL	AX,CL			    ;AN000;LB. in the secondary cache
 26078 000048E4 368506[B50D]            	TEST	[ss:SC_STATUS],AX	    ;AN000;LB.
 26079 000048E9 7430                    	JZ	short noSC		    ;AN000;LB. invalid
 26080                                  ;entry SC2BUF2
 26081                                  SC2BUF2:				    ;AN000;
 26082                                  	;MOV	AX,CX			    ;AN000;LB. times index with
 26083                                  	;MUL	word [ss:SC_SECTOR_SIZE]    ;AN000;LB. sector size
 26084                                  	; 24/09/2023
 26085 000048EB 36A1[AD0D]              	mov	ax,[ss:SC_SECTOR_SIZE]
 26086 000048EF 91                      	xchg	ax,cx ; cx = [ss:SC_SECTOR_SIZE]
 26087 000048F0 F7E1                    	mul	cx
 26088 000048F2 360306[7300]            	ADD	AX,[ss:SC_CACHE_PTR]	    ;AN000;LB. add SC starting addr
 26089 000048F7 361316[7500]            	ADC	DX,[ss:SC_CACHE_PTR+2]	    ;AN000;LB.
 26090 000048FC 8EDA                    	MOV	DS,DX			    ;AN000;LB. DS:SI-> SC sector addr
 26091 000048FE 89C6                    	MOV	SI,AX			    ;AN000;LB.
 26092 00004900 368E06[6A03]            	MOV	ES,[ss:CALLXAD+2]		    ;AN000;LB. ES:DI-> buffer addr
 26093 00004905 368B3E[6803]            	MOV	DI,[ss:CALLXAD]		    ;AN000;LB.
 26094                                  	; 24/09/2023
 26095                                  	;MOV	CX,[ss:SC_SECTOR_SIZE]	    ;AN000;LB. count= sector size
 26096 0000490A D1E9                    	SHR	CX,1			    ;AN000;LB. may use DWORD move for 386
 26097                                  ;entry MOVWORDS
 26098                                  MOVWORDS:				    ;AN000;
 26099 0000490C 36803E[6A00]00          	CMP	byte [ss:DDMOVE],0	    ;AN000;LB. 386 ?
 26100 00004912 7403                    	JZ	short nodd		    ;AN000;LB. no
 26101 00004914 D1E9                    	SHR	CX,1			    ;AN000;LB. words/2
 26102 00004916 66                      	DB	66H			    ;AN000;LB. use double word move
 26103                                  nodd:
 26104 00004917 F3A5                    	REP	MOVSW			    ;AN000;LB. move to buffer
 26105 00004919 F8                      	CLC				    ;AN000;LB. clear carry
 26106 0000491A C3                      	retn				    ;AN000;LB. exit
 26107                                  noSC:					    ;AN000;
 26108 0000491B F9                      	STC				    ;AN000;LB. set carry
 26109                                  sexit:					    ;AN000;
 26110 0000491C C3                      	retn				    ;AN000;LB.
 26111                                  
 26112                                  ;============================================================================
 26113                                  ; MKNODE.ASM, MSDOS 6.0, 1991
 26114                                  ;============================================================================
 26115                                  ; 29/07/2018 - Retro DOS v3.0
 26116                                  ; 19/05/2019 - Retro DOS v4.0
 26117                                  
 26118                                  ;	TITLE	MKNODE - Node maker
 26119                                  ;	NAME	MKNODE
 26120                                  
 26121                                  ;**	MKNODE.ASM
 26122                                  ;----------------------------------------------------------------------------
 26123                                  ;	Low level routines for making a new local file system node
 26124                                  ;	and filling in an SFT from a directory entry
 26125                                  ;
 26126                                  ;	BUILDDIR
 26127                                  ;	SETDOTENT
 26128                                  ;	MakeNode
 26129                                  ;	NEWENTRY
 26130                                  ;	FREEENT
 26131                                  ;	NEWDIR
 26132                                  ;	DOOPEN
 26133                                  ;	RENAME_MAKE
 26134                                  ;	CHECK_VIRT_OPEN
 26135                                  ;
 26136                                  ;	Revision history:
 26137                                  ;
 26138                                  ;	 AN000	version 4.0  Jan. 1988
 26139                                  ;	 A004	PTM 3680  --- Make SFT NAME field offset same as 3.30
 26140                                  
 26141                                  ;Break   <BUILDDIR,NEWDIR -- ALLOCATE DIRECTORIES>
 26142                                  ;----------------------------------------------------------------------------
 26143                                  ;
 26144                                  ; Procedure Name : BUILDDIR,NEWDIR
 26145                                  ;
 26146                                  ; Inputs:
 26147                                  ;       ES:BP Points to DPB
 26148                                  ;       [THISSFT] Set if using NEWDIR entry point
 26149                                  ;               (used by ALLOCATE)
 26150                                  ;       [LASTENT] current last valid entry number in directory if no free
 26151                                  ;               entries
 26152                                  ;       [DIRSTART] Points to first cluster of dir (0 means root)
 26153                                  ; Function:
 26154                                  ;       Grow directory if no free entries and not root
 26155                                  ; Outputs:
 26156                                  ;       CARRY SET IF FAILURE
 26157                                  ;       ELSE
 26158                                  ;          AX entry number of new entry
 26159                                  ;          If a new dir [DIRSTART],[CLUSFAC],[CLUSNUM],[DIRSEC] set
 26160                                  ;               AX = first entry of new dir
 26161                                  ;       GETENT should be called to set [LASTENT]
 26162                                  ;
 26163                                  ;----------------------------------------------------------------------------
 26164                                  
 26165                                  ; 19/05/2019 - Retro DOS v4.0
 26166                                  ; DOSCODE:8845h (MSDOS 6.21, MSDOS.SYS)
 26167                                  ; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 26168                                  ; DOSCODE:880Ah (MSDOS 6.21, MSDOS.SYS)
 26169                                  
 26170                                  ; 24/09/2023 - Retro DOS v4.2 (Modified MSDOS 6.21 MSDOS.SYS)
 26171                                  ; DOSCODE:8845h (MSDOS 6.22, MSDOS.SYS)
 26172                                  
 26173                                  BUILDDIR:
 26174                                  	; 29/07/2018 - Retro DOS v3.0
 26175                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 4E66h
 26176                                  
 26177 0000491D A1[D805]                        MOV     AX,[ENTFREE]
 26178 00004920 83F8FF                          CMP     AX,-1 ; 0FFFFh
 26179                                  	;JZ	short CHECK_IF_ROOT
 26180                                          ;CLC
 26181                                          ;retn
 26182                                  	; 24/09/2023
 26183 00004923 7507                    	jne	short builddir_cmc_retn  ; cf=1 (will be 0)
 26184                                  
 26185                                  CHECK_IF_ROOT:
 26186 00004925 833E[C205]00                    CMP     word [DIRSTART],0
 26187 0000492A 7502                            JNZ	short NEWDIR
 26188                                          ;STC
 26189                                  	; 24/09/2023
 26190                                  	; [DIRSTART]=0, cf=0, zf=1 (cf will be 1 after cmc instruction)
 26191                                  builddir_cmc_retn:
 26192                                  	; 24/09/2023
 26193 0000492C F5                      	cmc	; cf=1 <-> cf=0
 26194                                  builddir_retn:
 26195 0000492D C3                              retn				; Can't grow root
 26196                                  
 26197                                  	;entry   NEWDIR
 26198                                  NEWDIR: 
 26199 0000492E 8B1E[C205]              	MOV     BX,[DIRSTART]
 26200 00004932 09DB                            OR      BX,BX
 26201 00004934 7405                            JZ	short NULLDIR
 26202 00004936 E82806                  	call	GETEOF
 26203 00004939 72F2                            jc	short builddir_retn	; Screw up
 26204                                  NULLDIR:
 26205 0000493B B90100                          MOV     CX,1
 26206 0000493E E83905                  	call	ALLOCATE
 26207 00004941 72EA                            jc	short  builddir_retn
 26208 00004943 8B16[C205]                      MOV     DX,[DIRSTART]
 26209 00004947 09D2                            OR      DX,DX
 26210 00004949 750D                            JNZ	short ADDINGDIR
 26211 0000494B E8DBF5                  	call	SETDIRSRCH
 26212 0000494E 72DD                            jc	short  builddir_retn
 26213 00004950 C706[4803]FFFF                  MOV     word [LASTENT],-1
 26214 00004956 EB29                            JMP     SHORT GOTDIRREC
 26215                                  ADDINGDIR:
 26216 00004958 53                              PUSH    BX
 26217 00004959 8B1E[BC05]                      MOV     BX,[CLUSNUM]
 26218 0000495D E82D0C                          call	IsEOF
 26219 00004960 5B                              POP     BX
 26220 00004961 7217                            JB	short NOTFIRSTGROW
 26221                                  ;;;; 10/17/86 update CLUSNUM in the fastopen cache
 26222 00004963 891E[BC05]                      MOV     [CLUSNUM],BX
 26223                                  	; 24/09/2023
 26224                                  	;PUSH	CX ; (not necessary)
 26225 00004967 50                      	PUSH	AX
 26226 00004968 55                      	PUSH	BP
 26227 00004969 B401                            MOV     AH,1			; CLUSNUM update
 26228                                  	; 15/12/2022
 26229 0000496B 268A5600                	mov	dl,[ES:BP] ; 09/09/2018
 26230                                          ; 22/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 26231                                  	;;mov	dl,[es:bp+0]
 26232                                  	;MOV	DL,[ES:BP+DPB.DRIVE]	; drive #
 26233 0000496F 8B0E[C205]                      MOV     CX,[DIRSTART]		; first cluster #
 26234 00004973 89DD                            MOV     BP,BX 			; CLUSNUM
 26235 00004975 E8E8DD                  	call	FastOpen_Update
 26236 00004978 5D                              POP     BP
 26237 00004979 58                              POP     AX
 26238                                  	; 24/09/2023
 26239                                          ;POP	CX
 26240                                  
 26241                                  ;;;; 10/17/86 update CLUSNUM in the fastopen cache
 26242                                  NOTFIRSTGROW:
 26243 0000497A 89DA                            MOV     DX,BX
 26244 0000497C 30DB                            XOR     BL,BL
 26245 0000497E E8CC04                  	call	FIGREC
 26246                                  GOTDIRREC:
 26247                                  	;mov	cl,[es:bp+4]
 26248 00004981 268A4E04                        MOV     CL,[ES:BP+DPB.CLUSTER_MASK]
 26249 00004985 FEC1                            INC     CL
 26250 00004987 30ED                            XOR     CH,CH
 26251                                  ZERODIR:
 26252 00004989 51                              PUSH    CX
 26253                                  	; 22/09/2023
 26254                                  	;;mov	byte [ALLOWED],18h
 26255                                          ;MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY ; *
 26256 0000498A B0FF                            MOV     AL,0FFH
 26257                                          ;call	GETBUFFR
 26258 0000498C E82910                          call	GETBUFFRD ; *
 26259 0000498F 7302                    	JNC	short GET_SSIZE
 26260 00004991 59                              POP     CX
 26261 00004992 C3                              retn
 26262                                  
 26263                                  GET_SSIZE:
 26264                                  	;mov	cx,[es:bp+2]
 26265 00004993 268B4E02                        MOV     CX,[ES:BP+DPB.SECTOR_SIZE]
 26266 00004997 06                              PUSH    ES
 26267 00004998 C43E[E205]                      LES     DI,[CURBUF]
 26268                                  	;or	byte [es:di+5],4
 26269 0000499C 26804D0504                      OR      byte [ES:DI+BUFFINFO.buf_flags],buf_isDIR
 26270 000049A1 57                              PUSH    DI
 26271                                  	;;add	di,16	; MSDOS 3.3
 26272                                  	;add	di,20	; MSDOS 6.0	
 26273 000049A2 83C714                          ADD     DI,BUFINSIZ
 26274 000049A5 31C0                            XOR     AX,AX
 26275 000049A7 D1E9                            SHR     CX,1
 26276 000049A9 F3AB                            REP     STOSW
 26277 000049AB 7301                            JNC	short EVENZ
 26278 000049AD AA                              STOSB
 26279                                  EVENZ:
 26280 000049AE 5F                              POP     DI
 26281                                  
 26282                                  	; MSDOS 6.0
 26283 000049AF 26F6450540              	TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
 26284                                  					;LB. if already dirty		  ;AN000;
 26285 000049B4 7508                            JNZ	short yesdirty7		;LB.  don't increment dirty count ;AN000;
 26286 000049B6 E80612                          call	INC_DIRTY_COUNT		;LB. 				  ;AN000;
 26287                                          
 26288                                  	;or	byte [es:di+5],40h
 26289 000049B9 26804D0540              	OR      byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
 26290                                  yesdirty7:
 26291 000049BE 07                              POP	ES
 26292 000049BF 59                              POP	CX
 26293                                  
 26294                                  	; 19/05/2019 - Retro DOS v4.0
 26295                                  
 26296                                  	; MSDOS 3.3
 26297                                  	;INC	DX
 26298                                  
 26299                                  	; MSDOS 6.0
 26300                                  	; 24/09/2023
 26301                                  	;add	dx,1
 26302                                  	;;adc	word [HIGH_SECTOR],0
 26303                                  	;; 24/09/2023
 26304                                  	;; ax=0
 26305                                  	;adc	[HIGH_SECTOR],ax ; 0
 26306                                  	; 24/09/2023
 26307 000049C0 42                      	inc	dx
 26308 000049C1 7504                    	jnz	short loop_zerodir
 26309 000049C3 FF06[0706]              	inc	word [HIGH_SECTOR]
 26310                                  loop_zerodir:
 26311 000049C7 E2C0                            LOOP    ZERODIR
 26312                                  
 26313 000049C9 A1[4803]                        MOV     AX,[LASTENT]
 26314 000049CC 40                              INC     AX
 26315                                  	; 24/09/2023
 26316                                  	; cf=0
 26317                                  	;CLC
 26318 000049CD C3                              retn
 26319                                  
 26320                                  ;--------------------------------------------------------------------------
 26321                                  ;
 26322                                  ; Procedure Name : SETDOTENT
 26323                                  ;
 26324                                  ; set up a . or .. directory entry for a directory.
 26325                                  ;
 26326                                  ;   Inputs:     ES:DI point to the beginning of a directory entry.
 26327                                  ;               AX contains ". " or ".."
 26328                                  ;               DX contains first cluster of entry
 26329                                  ;
 26330                                  ;----------------------------------------------------------------------------
 26331                                  
 26332                                  SETDOTENT:
 26333                                  ;	Fill in name field
 26334 000049CE AB                              STOSW
 26335 000049CF B90400                          MOV     CX,4
 26336 000049D2 B82020                          MOV     AX,"  " ; 2020h
 26337 000049D5 F3AB                            REP     STOSW
 26338 000049D7 AA                              STOSB
 26339                                  
 26340                                  ;	Set up attribute
 26341                                  	;mov	al, 10h
 26342 000049D8 B010                            MOV     AL,attr_directory
 26343 000049DA AA                              STOSB
 26344                                  
 26345                                  ;	Initialize time and date of creation
 26346 000049DB 83C70A                          ADD     DI,10
 26347 000049DE 8B36[9E05]                      MOV     SI,[THISSFT]
 26348                                  	;mov	ax,[si+0Dh]
 26349 000049E2 8B440D                          MOV     AX,[SI+SF_ENTRY.sf_time]
 26350 000049E5 AB                              STOSW
 26351                                  	;mov	ax,[si+0Fh]
 26352 000049E6 8B440F                          MOV     AX,[SI+SF_ENTRY.sf_date]
 26353 000049E9 AB                      	STOSW
 26354                                  
 26355                                  ;	Set up first cluster field
 26356 000049EA 89D0                            MOV     AX,DX
 26357 000049EC AB                              STOSW
 26358                                  
 26359                                  ;	0 file size
 26360 000049ED 31C0                            XOR     AX,AX
 26361 000049EF AB                              STOSW
 26362 000049F0 AB                              STOSW
 26363 000049F1 C3                              retn
 26364                                  
 26365                                  ;Break   <MAKENODE -- CREATE A NEW NODE>
 26366                                  ;---------------------------------------------------------------------------
 26367                                  ;
 26368                                  ; Procedure Name : MakeNode
 26369                                  ;
 26370                                  ; Inputs:
 26371                                  ;       AL - attribute to create
 26372                                  ;       AH = 0 if it is ok to truncate a file already by this name
 26373                                  ;	AH != 0 if truncation not allowed (prexisting file is an error)
 26374                                  ;               (AH ignored on dirs and devices)
 26375                                  ;
 26376                                  ;        NOTE: When making a DIR or volume ID, AH need not be set since
 26377                                  ;               a name already existant is ALWAYS an error in these cases.
 26378                                  ;
 26379                                  ;       [WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 26380                                  ;               terminated)
 26381                                  ;       [CURR_DIR_END] Points to end of Current dir part of string
 26382                                  ;               ( = -1 if current dir not involved, else
 26383                                  ;                Points to first char after last "/" of current dir part)
 26384                                  ;       [THISCDS] Points to CDS being used
 26385                                  ;       [THISSFT] Points to an empty SFT. EXCEPT sf_mode filled in.
 26386                                  ; Function:
 26387                                  ;       Make a new node
 26388                                  ; Outputs:
 26389                                  ;       Sets EXTERR_LOCUS = errLOC_Disk or errLOC_Unk via GetPathNoset
 26390                                  ;       CARRY SET IF ERROR
 26391                                  ;          AX = 1 A node by this name exists and is a directory
 26392                                  ;          AX = 2 A new node could not be created
 26393                                  ;          AX = 3 A node by this name exists and is a disk file
 26394                                  ;               (AH was NZ on input)
 26395                                  ;          AX = 4 Bad Path
 26396                                  ;               SI return from GetPath maintained
 26397                                  ;          AX = 5 Attribute mismatch
 26398                                  ;          AX = 6 Sharing Violation
 26399                                  ;               (INT 24 generated ALWAYS since create is always compat mode
 26400                                  ;          AX = 7 file not found for Extended Open (not exists and fails)
 26401                                  ;       ELSE
 26402                                  ;          AX = 0 Disk Node
 26403                                  ;          AX = 3 Device Node (error in some cases)
 26404                                  ;          [DIRSTART],[DIRSEC],[CLUSFAC],[CLUSNUM] set to directory
 26405                                  ;               containing new node.
 26406                                  ;          [CURBUF+2]:BX Points to entry
 26407                                  ;          [CURBUF+2]:SI Points to entry.dir_first
 26408                                  ;          [THISSFT] is filled in
 26409                                  ;               sf_mode = unchanged.
 26410                                  ;          Attribute byte in entry is input AL
 26411                                  ; DS preserved, others destroyed
 26412                                  ;
 26413                                  ;-------------------------------------------------------------------------
 26414                                  
 26415                                  ; 19/05/2019 - Retro DOS v4.0
 26416                                  ; DOSCODE:8925h (MSDOS 6.21, MSDOS.SYS)
 26417                                  
 26418                                  ; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 26419                                  ; DOSCODE:88EAh (MSDOS 5.0, MSDOS.SYS)
 26420                                  
 26421                                  MakeNode:
 26422                                  	;mov	word [CREATING],0E5FFh
 26423 000049F2 C706[7E05]FFE5          	MOV	WORD [CREATING],DIRFREE*256 + 0FFh ; Creating, not DEL *.*
 26424 000049F8 50                              PUSH    AX              ; Save AH value
 26425 000049F9 C606[4C03]00            	MOV	byte [NoSetDir],0
 26426 000049FE A2[6D05]                	MOV	[SATTRIB],AL
 26427 00004A01 E888F5                  	call	GetPathNoSet
 26428 00004A04 88CA                            MOV     DL,CL           ; Save CL info
 26429 00004A06 89C1                            MOV     CX,AX           ; Device ID to CH
 26430 00004A08 58                              POP     AX              ; Get back AH
 26431 00004A09 732E                            JNC	short make_exists ; File existed
 26432 00004A0B 7505                            JNZ	short make_err_4 ; Path bad
 26433 00004A0D 80FA80                          CMP     DL,80h          ; Check "CL" return from GETPATH
 26434 00004A10 7406                            JZ	short make_type	; Name simply not found, and no metas
 26435                                  make_err_4:
 26436 00004A12 B004                            MOV     AL,4            ; case 1 bad path
 26437                                  make_err_ret:
 26438 00004A14 30E4                            XOR     AH,AH
 26439 00004A16 F9                              STC
 26440                                  ;make_retn:	; 22/11/2022
 26441 00004A17 C3                              retn
 26442                                  
 26443                                          ;entry	RENAME_MAKE     ; Used by DOS_RENAME to "copy" a node
 26444                                  RENAME_MAKE:
 26445                                  make_type:
 26446                                  ;Extended Open hooks
 26447                                  	; MSDOS 6.0
 26448                                  	;TESTB	EXTOPEN_ON,EXT_OPEN_ON	;FT. from extended open		;AN000;
 26449 00004A18 F606[F605]01            	test	byte [EXTOPEN_ON],EXT_OPEN_ON ; 1
 26450 00004A1D 7411                    	JZ	short make_type2	;FT. no				;AN000;
 26451 00004A1F 800E[F605]04            	OR	byte [EXTOPEN_ON],EXT_FILE_NOT_EXISTS ; 4
 26452                                  					;FT. set for extended open ;AN000;
 26453                                  	;TESTB	EXTOPEN_FLAG,0F0H	;FT. not exists and fails	;AN000;
 26454 00004A24 F606[F405]F0            	test	byte [EXTOPEN_FLAG],0F0h
 26455 00004A29 7505                    	JNZ	short make_type2	;FT. no				;AN000;
 26456 00004A2B F9                      	STC				;FT. set carry			;AN000;
 26457 00004A2C B80700                  	MOV    AX,7			;FT. file not found		;AN000;
 26458                                  	; 22/11/2022
 26459                                  make_retn:
 26460                                  	;return
 26461 00004A2F C3                      	retn				;FT.				;AN000;
 26462                                  
 26463                                  ;	Extended Open hooks
 26464                                  
 26465                                  make_type2:
 26466 00004A30 C43E[9E05]                      LES     DI,[THISSFT]
 26467 00004A34 31C0                            XOR     AX,AX           ; nothing exists Disk Node
 26468 00004A36 F9                              STC                     ; Not found
 26469 00004A37 EB5A                            JMP     short make_new
 26470                                  
 26471                                  ; The node exists. It may be either a device, directory or file:
 26472                                  ;   Zero set => directory
 26473                                  ;   High bit of CH on => device
 26474                                  ;   else => file
 26475                                  
 26476                                  make_exists:
 26477 00004A39 7448                            JZ	short make_exists_dir
 26478 00004A3B B003                            MOV     AL,3            ; file exists type 3  (error or device node)
 26479                                  	;test	byte [ATTRIB],18h
 26480 00004A3D F606[6B05]18            	TEST	byte [ATTRIB],attr_volume_id+attr_directory
 26481 00004A42 753B                            JNZ	short make_err_ret_5
 26482                                  				; Cannot already exist as Disk or Device Node
 26483                                                                  ;       if making DIR or Volume ID
 26484 00004A44 08ED                            OR      CH,CH
 26485 00004A46 781A                            JS	short make_share ; No further checks on attributes if device
 26486 00004A48 08E4                            OR      AH,AH
 26487 00004A4A 75C8                            JNZ	short make_err_ret ; truncating NOT OK (AL = 3)
 26488 00004A4C 51                              PUSH    CX              ; Save device ID
 26489 00004A4D 8E06[E405]                      MOV     ES,[CURBUF+2]
 26490                                  	;mov	ch,[es:bx+0Bh]
 26491 00004A51 268A6F0B                        MOV     CH,[ES:BX+dir_entry.dir_attr] ; Get file attributes
 26492                                  	;test	ch,1
 26493 00004A55 F6C501                  	test	CH,attr_read_only
 26494 00004A58 7524                            JNZ	short make_err_ret_5P ; Cannot create on read only files
 26495 00004A5A E8D0F7                  	call	MatchAttributes
 26496 00004A5D 59                              POP     CX              ; Devid back in CH
 26497 00004A5E 751F                            JNZ	short make_err_ret_5 ; Attributes not ok
 26498 00004A60 30C0                            XOR     AL,AL           ; AL = 0, Disk Node
 26499                                  make_share:
 26500 00004A62 30E4                            XOR     AH,AH
 26501 00004A64 50                              PUSH    AX              ; Save Disk or Device node
 26502 00004A65 51                              PUSH    CX              ; Save Device ID
 26503 00004A66 88EC                            MOV     AH,CH           ; Device ID to AH
 26504 00004A68 E84501                          CALL    DOOPEN          ; Fill in SFT for share check
 26505 00004A6B C43E[9E05]                      LES     DI,[THISSFT]
 26506 00004A6F 56                      	push	si
 26507 00004A70 53                      	push	bx		; Save CURBUF pointers
 26508 00004A71 E86E29                  	call	ShareEnter
 26509 00004A74 735A                            jnc	short MakeEndShare
 26510                                  
 26511                                  ; User failed request.
 26512 00004A76 5B                      	pop	bx
 26513 00004A77 5E                      	pop	si
 26514 00004A78 59                      	pop	cx
 26515 00004A79 58                      	pop	ax
 26516                                  
 26517                                  Make_Share_ret:
 26518 00004A7A B006                            MOV     AL,6
 26519 00004A7C EB96                            JMP	short make_err_ret
 26520                                  
 26521                                  make_err_ret_5P:
 26522 00004A7E 59                              POP     CX              ; Get back device ID
 26523                                  make_err_ret_5:
 26524 00004A7F B005                            MOV     AL,5            ; Attribute mismatch
 26525                                          ; 22/11/2022
 26526 00004A81 EB91                    	JMP     short make_err_ret
 26527                                  
 26528                                  make_exists_dir:
 26529 00004A83 B001                            MOV     AL,1            ; exists as directory, always an error
 26530                                  	; 22/11/2022
 26531 00004A85 EB8D                    	JMP     short make_err_ret
 26532                                  
 26533                                  make_save:
 26534 00004A87 50                              PUSH    AX              ; Save whether Disk or File
 26535 00004A88 89C8                            MOV     AX,CX           ; Device ID to AH
 26536 00004A8A E87400                          CALL    NEWENTRY
 26537 00004A8D 58                              POP     AX              ; 0 if Disk, 3 if File
 26538 00004A8E 739F                            jnc	short make_retn
 26539 00004A90 B002                            MOV     AL,2            ; create failed case 2
 26540                                  make_save_retn:
 26541 00004A92 C3                              retn
 26542                                  
 26543                                  make_new:
 26544 00004A93 E8F1FF                          call    make_save
 26545 00004A96 72FA                            jc	short make_save_retn	; case 2 fail
 26546                                  	;test	byte [ATTRIB],10h
 26547 00004A98 F606[6B05]10            	test	BYTE [ATTRIB],attr_directory
 26548 00004A9D 75F3                            jnz	short make_save_retn	; Don't "open" directories,
 26549                                  					; so don't tell the sharer about them
 26550 00004A9F 50                      	push	ax
 26551 00004AA0 53                      	push	bx
 26552 00004AA1 56                      	push	si		
 26553 00004AA2 E83D29                          call	ShareEnter
 26554 00004AA5 5E                      	pop	si
 26555 00004AA6 5B                      	pop	bx
 26556 00004AA7 58                      	pop	ax
 26557 00004AA8 73E8                    	jnc	short make_save_retn
 26558                                  
 26559                                  ; We get here by having the user FAIL a share problem. Typically a failure of
 26560                                  ; this nature is an out-of-space or an internal error. We clean up as best as
 26561                                  ; possible: delete the newly created directory entry and return share_error.
 26562                                  
 26563 00004AAA 50                              PUSH    AX
 26564 00004AAB C43E[E205]                      LES     DI,[CURBUF]
 26565                                  	;mov	byte [es:bx],0E5h
 26566 00004AAF 26C607E5                	MOV	BYTE [ES:BX],DIRFREE	; nuke newly created entry.
 26567                                  	
 26568                                  	; MSDOS 6.0
 26569                                  	;test	byte [es:di+5],40h
 26570 00004AB3 26F6450540              	TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty  
 26571                                  					;LB. if already dirty		  ;AN000;
 26572 00004AB8 7508                            JNZ	short yesdirty8		;LB.  don't increment dirty count ;AN000;
 26573                                  	; 22/11/2022
 26574 00004ABA E80211                  	call	INC_DIRTY_COUNT		;LB.				  ;AN000;
 26575                                  	;or	byte [es:di+5],40h
 26576 00004ABD 26804D0540                      OR      byte [ES:DI+BUFFINFO.buf_flags],buf_dirty ; flag buffer as dirty
 26577                                  yesdirty8:
 26578 00004AC2 C42E[8A05]                      LES     BP,[THISDPB]
 26579                                  	; 15/12/2022
 26580 00004AC6 268A4600                        mov	al,[ES:BP]
 26581                                  	; 22/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 26582                                  	;;mov	al,[es:bp+0]
 26583                                  	;MOV	AL,[ES:BP+DPB.DRIVE]	; get drive for flush
 26584 00004ACA E8ED0F                          call	FLUSHBUF		; write out buffer.
 26585 00004ACD 58                              POP     AX
 26586 00004ACE EBAA                            jmp	short Make_Share_ret
 26587                                  
 26588                                  ; We have found an existing file. We have also entered it into the share set.
 26589                                  ; At this point we need to call newentry to correctly address the problem of
 26590                                  ; getting rid of old data (create an existing file) or creating a new
 26591                                  ; directory entry (create a new file). Unfortunately, this operation may
 26592                                  ; result in an INT 24 that the user doesn't return from, thus locking the file
 26593                                  ; irretrievably into the share set. The correct solution is for us to LEAVE
 26594                                  ; the share set now, do the operation and then reassert the share access.
 26595                                  ;
 26596                                  ; We are allowed to do this! There is no window! After all, we are in
 26597                                  ; critDisk here and for someone else to get in, they must enter critDisk also.
 26598                                  
 26599                                  	; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 26600                                  	; DOSCODE:89C8h (MSDOS 5.0, MSDOS.SYS)
 26601                                  
 26602                                  MakeEndShare:
 26603 00004AD0 C43E[9E05]                      LES     DI,[THISSFT]		; grab SFT
 26604 00004AD4 31C0                            XOR     AX,AX
 26605 00004AD6 E87EC8                  	call	ECritSFT
 26606 00004AD9 268705                  	xchg	AX,[ES:DI]
 26607                                  	;XCHG	AX,[ES:DI+SF_ENTRY.sf_ref_count]
 26608 00004ADC 50                      	push	ax
 26609 00004ADD 57                      	push	di
 26610 00004ADE 06                      	push	es
 26611 00004ADF 9C                              PUSHF
 26612 00004AE0 E8FA28                          call	ShareEnd                ; remove sharing
 26613 00004AE3 9D                              POPF
 26614 00004AE4 07                      	pop	es
 26615 00004AE5 5F                      	pop	di
 26616 00004AE6 268F05                          pop	word [ES:DI]	
 26617                                  	;pop	word [ES:DI+SF_ENTRY.sf_ref_count]
 26618 00004AE9 E886C8                  	call	LCritSFT
 26619                                  	; 22/11/2022
 26620                                  	; DOSCODE:89E4h (MSDOS 5.0, MSDOS.SYS)
 26621 00004AEC 5B                      	pop	bx
 26622 00004AED 5E                      	pop	si
 26623 00004AEE 59                      	pop	cx
 26624 00004AEF 58                      	pop	ax
 26625 00004AF0 E894FF                          CALL    make_save
 26626                                  
 26627                                  ; If the user failed, we do not reenter into the sharing set.
 26628                                  
 26629 00004AF3 729D                            jc	short make_save_retn	; bye if error
 26630 00004AF5 50                      	push	ax
 26631 00004AF6 53                      	push	bx
 26632 00004AF7 56                      	push	si
 26633 00004AF8 9C                              PUSHF
 26634 00004AF9 E8E628                          call	ShareEnter
 26635 00004AFC 9D                              POPF
 26636 00004AFD 5E                      	pop	si
 26637 00004AFE 5B                      	pop	bx
 26638 00004AFF 58                      	pop	ax
 26639                                  
 26640                                  ; If Share_check fails, then we have an internal ERROR!!!!!
 26641                                  
 26642                                  makeendshare_retn:
 26643 00004B00 C3                              retn
 26644                                  
 26645                                  ;---------------------------------------------------------------------------
 26646                                  ;
 26647                                  ; Procedure Name : NEWENTRY
 26648                                  ;
 26649                                  ; Inputs:
 26650                                  ;       [THISSFT] set
 26651                                  ;       [THISDPB] set
 26652                                  ;       [LASTENT] current last valid entry number in directory if no free
 26653                                  ;               entries
 26654                                  ;       [VOLID] set if a volume ID was found during search
 26655                                  ;	Attrib Contains attributes for new file
 26656                                  ;       [DIRSTART] Points to first cluster of dir (0 means root)
 26657                                  ;       CARRY FLAG INDICATES STATUS OF SEARCH FOR FILE
 26658                                  ;               NC means file existed (device)
 26659                                  ;               C  means file did not exist
 26660                                  ;       AH = Device ID byte
 26661                                  ;       If FILE
 26662                                  ;           [CURBUF+2]:BX points to start of directory entry
 26663                                  ;           [CURBUF+2]:SI points to dir_first of directory entry
 26664                                  ;       If device
 26665                                  ;           DS:BX points to start of "fake" directory entry
 26666                                  ;           DS:SI points to dir_first of "fake" directory entry
 26667                                  ;               (has DWORD pointer to device header)
 26668                                  ; Function:
 26669                                  ;       Make a new directory entry
 26670                                  ;       If an old one existed it is truncated first
 26671                                  ; Outputs:
 26672                                  ;       Carry set if error
 26673                                  ;               Can't grow dir, atts didn't match, attempt to make 2nd
 26674                                  ;               vol ID, user FAILed to I 24
 26675                                  ;       else
 26676                                  ;               outputs of DOOPEN
 26677                                  ; DS, BX, SI preserved (meaning on SI BX, not value), others destroyed
 26678                                  ;
 26679                                  ;----------------------------------------------------------------------------
 26680                                  
 26681                                  	; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 26682                                  	; DOSCODE:89F9h (MSDOS 5.0, MSDOS.SYS)
 26683                                  
 26684                                  NEWENTRY:
 26685 00004B01 C42E[8A05]                      LES     BP,[THISDPB]
 26686 00004B05 7315                            JNC	short EXISTENT	
 26687 00004B07 803E[4A03]00                    CMP     byte [FAILERR],0
 26688                                  	;STC
 26689                                          ;jnz	short makeendshare_retn	; User FAILed, node might exist
 26690                                          ; 24/09/2023
 26691 00004B0C 750C                    	jnz	short ERRRET3
 26692 00004B0E E80CFE                  	CALL    BUILDDIR        ; Try to build dir
 26693 00004B11 72ED                            jc	short makeendshare_retn	; Failed
 26694 00004B13 E8E4F3                          call	GETENT          ; Point at that free entry
 26695 00004B16 72E8                            jc	short makeendshare_retn	; Failed
 26696 00004B18 EB0E                            JMP     SHORT FREESPOT
 26697                                  
 26698                                  ERRRET3:
 26699 00004B1A F9                              STC
 26700                                  newentry_retn:
 26701 00004B1B C3                              retn
 26702                                  
 26703                                  EXISTENT:
 26704 00004B1C 08E4                            OR      AH,AH           ; Check if file is I/O device
 26705 00004B1E 7903                            JNS	short NOT_DEV1
 26706 00004B20 E98D00                          JMP     DOOPEN          ; If so, proceed with open
 26707                                  
 26708                                  NOT_DEV1:
 26709 00004B23 E82901                          call	FREEENT		; Free cluster chain
 26710 00004B26 72F3                            jc	short newentry_retn ; Failed
 26711                                  FREESPOT:
 26712                                  	;test	byte [ATTRIB],8
 26713 00004B28 F606[6B05]08            	test	BYTE [ATTRIB],attr_volume_id
 26714 00004B2D 7407                            JZ	short NOTVOLID
 26715 00004B2F 803E[7B05]00                    CMP     BYTE [VOLID],0
 26716 00004B34 75E4                            JNZ	short ERRRET3	; Can't create a second volume ID
 26717                                  NOTVOLID:
 26718 00004B36 8E06[E405]                      MOV     ES,[CURBUF+2]
 26719 00004B3A 89DF                            MOV     DI,BX
 26720                                  
 26721 00004B3C BE[4B05]                        MOV     SI,NAME1
 26722                                  
 26723 00004B3F B90500                          MOV     CX,5
 26724 00004B42 F3A5                            REP     MOVSW
 26725 00004B44 A4                              MOVSB                   ; Move name into dir entry
 26726 00004B45 A0[6B05]                	MOV	AL,[ATTRIB]
 26727 00004B48 AA                      	STOSB                   ; Attributes
 26728                                  
 26729                                  ;; File Tagging for Create DOS 4.00
 26730 00004B49 B105                            MOV     CL,5            ;FT. assume normal FBUGBUG	;AN000;
 26731                                  ;; File Tagging for Create DOS 4.00
 26732                                  
 26733 00004B4B 31C0                            XOR     AX,AX
 26734 00004B4D F3AB                            REP     STOSW           ; Zero pad
 26735 00004B4F E8BEBF                          call	DATE16
 26736 00004B52 92                              XCHG    AX,DX
 26737 00004B53 AB                              STOSW                   ; dir_time
 26738 00004B54 92                              XCHG    AX,DX
 26739 00004B55 AB                              STOSW                   ; dir_date
 26740 00004B56 31C0                            XOR     AX,AX
 26741 00004B58 57                              PUSH    DI              ; Correct SI input value
 26742                                  				; 	(recomputed for new buffer)
 26743 00004B59 AB                              STOSW                   ; Zero dir_first and size
 26744 00004B5A AB                              STOSW
 26745 00004B5B AB                              STOSW
 26746                                  updnxt:
 26747 00004B5C 8B36[E205]              	MOV	SI,[CURBUF]
 26748                                  
 26749                                  	; 19/05/2019 - Retro DOS v4.0
 26750                                  
 26751                                  	; MSDOS 6.0
 26752 00004B60 26F6440540              	TEST	byte [ES:SI+BUFFINFO.buf_flags],buf_dirty
 26753                                  				;LB. if already dirty		  ;AN000;
 26754 00004B65 7508                            JNZ	short yesdirty9	;LB.  don't increment dirty count ;AN000;
 26755 00004B67 E85510                          call	INC_DIRTY_COUNT	;LB.				  ;AN000;
 26756                                          
 26757                                  	;or	byte [es:si+5],40h
 26758 00004B6A 26804C0540              	OR      byte [ES:SI+BUFFINFO.buf_flags],buf_dirty
 26759                                  yesdirty9:
 26760 00004B6F C42E[8A05]                      LES     BP,[THISDPB]
 26761                                  	; 15/12/2022
 26762 00004B73 268A4600                	MOV	AL,[ES:BP]
 26763                                  	; 22/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 26764                                  	;;mov	al,[es:bp+0]
 26765                                  	;MOV	AL,[ES:BP+DPB.DRIVE] ; Sets AH value again (in AL)
 26766 00004B77 50                              PUSH    AX
 26767 00004B78 53                              PUSH    BX
 26768                                  
 26769                                  ; If we have a file, we need to increment the open ref. count so that
 26770                                  ; we have some protection against invalid media changes if an Int 24
 26771                                  ; error occurs.
 26772                                  ; Do nothing for a device.
 26773                                  
 26774 00004B79 06                      	push	es
 26775 00004B7A 57                      	push	di
 26776 00004B7B C43E[9E05]                      LES     DI,[THISSFT]
 26777                                  	;test	word [es:di+5],80h
 26778                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
 26779 00004B7F 26F6450580              	test	byte [ES:DI+SF_ENTRY.sf_flags],devid_device
 26780 00004B84 751A                            jnz	short GotADevice
 26781 00004B86 1E                      	push	ds
 26782 00004B87 53                      	push	bx
 26783 00004B88 C51E[8A05]                      LDS     BX,[THISDPB]
 26784                                  	;mov	[es:di+7],bx
 26785 00004B8C 26895D07                        MOV     [ES:DI+SF_ENTRY.sf_devptr],BX
 26786 00004B90 8CDB                            MOV     BX,DS
 26787                                  	;mov	[es:di+9],bx
 26788 00004B92 26895D09                        MOV     [ES:DI+SF_ENTRY.sf_devptr+2],BX
 26789 00004B96 5B                      	pop	bx
 26790 00004B97 1F                      	pop	ds ; need to use DS for segment later on
 26791 00004B98 E8B8FA                  	call	DEV_OPEN_SFT    ; increment ref. count
 26792 00004B9B C606[A20A]01                    mov	byte [VIRTUAL_OPEN],1; set flag
 26793                                  GotADevice:
 26794 00004BA0 5F                      	pop	di
 26795 00004BA1 07                      	pop	es
 26796                                  
 26797 00004BA2 E8150F                          call	FLUSHBUF
 26798 00004BA5 E8EF00                          Call    CHECK_VIRT_OPEN ; decrement ref. count            ;AN000;
 26799 00004BA8 5B                              POP     BX
 26800 00004BA9 58                              POP     AX
 26801 00004BAA 5E                              POP     SI              ; Get SI input back
 26802 00004BAB 88C4                            MOV     AH,AL           ; Get I/O driver number back
 26803 00004BAD 7301                    	jnc	short DOOPEN    ; Failed
 26804 00004BAF C3                      	retn
 26805                                  	
 26806                                  ;NOTE FALL THROUGH
 26807                                  
 26808                                  ; DOSCODE:8AE4h (MSDOS 6.21, MSDOS.SYS)
 26809                                  
 26810                                  ; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 26811                                  ; DOSCODE:8AA9h (MSDOS 5.0, MSDOS.SYS)
 26812                                  
 26813                                  ; DOOPEN
 26814                                  ;----------------------------------------------------------------------------
 26815                                  ;
 26816                                  ; Inputs:
 26817                                  ;       [THISDPB] points to DPB if file
 26818                                  ;       [THISSFT] points to SFT being used
 26819                                  ;       AH = Device ID byte
 26820                                  ;       If FILE
 26821                                  ;           [CURBUF+2]:BX points to start of directory entry
 26822                                  ;           [CURBUF+2]:SI points to dir_first of directory entry
 26823                                  ;       If device
 26824                                  ;           DS:BX points to start of "fake" directory entry
 26825                                  ;           DS:SI points to dir_first of "fake" directory entry
 26826                                  ;               (has DWORD pointer to device header)
 26827                                  ; Function:
 26828                                  ;       Fill in SFT from dir entry
 26829                                  ; Outputs:
 26830                                  ;       CARRY CLEAR
 26831                                  ;       sf_ref_count and sf_mode fields not altered
 26832                                  ;       sf_flags high byte = 0
 26833                                  ;       sf_flags low byte = AH except
 26834                                  ;       sf_flags Bit 6 set (not dirty or not EOF)
 26835                                  ;       sf_attr sf_date sf_time sf_name set from entry
 26836                                  ;       sf_position = 0
 26837                                  ;       If device
 26838                                  ;           sf_devptr = dword at dir_first (pointer to device header)
 26839                                  ;           sf_size = 0
 26840                                  ;       If file
 26841                                  ;           sf_firclus sf_size set from entry
 26842                                  ;           sf_devptr = [THISDPB]
 26843                                  ;           sf_cluspos = 0
 26844                                  ;           sf_lstclus = sf_firclus
 26845                                  ;           sf_dirsec sf_dirpos set
 26846                                  ; DS,SI,BX preserved, others destroyed
 26847                                  ;
 26848                                  ;----------------------------------------------------------------------------
 26849                                  
 26850                                  	;entry	DOOPEN
 26851                                  DOOPEN:
 26852                                  ;	Generate and store attribute
 26853                                  
 26854 00004BB0 88E6                            MOV     DH,AH           ; AH to different place
 26855 00004BB2 C43E[9E05]                      LES     DI,[THISSFT]
 26856                                  	;add	di,4
 26857 00004BB6 83C704                          ADD     DI,SF_ENTRY.sf_attr ; Skip ref_count and mode fields
 26858                                  	; 24/09/2023
 26859 00004BB9 31C0                    	xor	ax,ax
 26860                                  	;XOR	AL,AL		; Assume it's a device, devices have an
 26861                                  				;   attribute of 0 (for R/O testing etc).
 26862 00004BBB 08F6                            OR      DH,DH           ; See if our assumption good.
 26863 00004BBD 7807                            JS	short DEV_SFT1	; If device DS=DOSGROUP
 26864 00004BBF 8E1E[E405]                      MOV     DS,[CURBUF+2]
 26865                                  	;mov	al,[BX+0Bh]
 26866 00004BC3 8A470B                          MOV     AL,[BX+dir_entry.dir_attr]
 26867                                  				; If file, get attrib from dir entry
 26868                                  DEV_SFT1:
 26869 00004BC6 AA                              STOSB                   ; sf_attr, ES:DI -> sf_flags
 26870                                  
 26871                                  ;	Generate and store flags word
 26872                                  
 26873                                  	; 24/09/2023
 26874                                  	;XOR	AX,AX
 26875                                          ; ah=0
 26876 00004BC7 88F0                    	MOV     AL,DH
 26877                                  	;or	al,40h
 26878 00004BC9 0C40                            OR      AL,devid_file_clean
 26879 00004BCB AB                              STOSW                   ; sf_flags, ES:DI -> sf_devptr
 26880                                  
 26881                                  ;	Generate and store device pointer
 26882                                  
 26883 00004BCC 1E                              PUSH    DS
 26884                                  	;lds	ax,[bx+1Ah]
 26885 00004BCD C5471A                          LDS     AX,[BX+dir_entry.dir_first] ; Assume device
 26886 00004BD0 08F6                            OR      DH,DH
 26887 00004BD2 7805                            JS	short DEV_SFT2
 26888                                  
 26889                                  ;hkn; SS override
 26890 00004BD4 36C506[8A05]                    LDS     AX,[SS:THISDPB]	; Was file
 26891                                  DEV_SFT2:
 26892 00004BD9 AB                              STOSW 			; store offset
 26893 00004BDA 8CD8                            MOV     AX,DS
 26894 00004BDC 1F                              POP     DS
 26895 00004BDD AB                      	STOSW			; store segment
 26896                                  				; ES:DI -> sf_firclus
 26897                                  
 26898                                  ;	Generate pointer to, generate and store first cluster 
 26899                                  ;	(irrelevant for devices)
 26900                                  
 26901 00004BDE 56                              PUSH    SI              ; Save pointer to dir_first
 26902 00004BDF A5                              MOVSW                   ; dir_first -> sf_firclus
 26903                                                                  ; DS:SI -> dir_size_l, ES:DI -> sf_time
 26904                                  
 26905                                  ;	Copy time/date of last modification
 26906                                  
 26907                                  	;sub	si,6
 26908 00004BE0 83EE06                          SUB     SI,dir_entry.dir_size_l - dir_entry.dir_time 
 26909                                  				; DS:SI->dir_time
 26910 00004BE3 A5                              MOVSW                   ; dir_time -> sf_time
 26911                                                                  ; DS:SI -> dir_date, ES:DI -> sf_date
 26912 00004BE4 A5                              MOVSW                   ; dir_date -> sf_date
 26913                                                                  ; DS:SI -> dir_first, ES:DI -> sf_size
 26914                                  
 26915                                  ;	Generate and store file size (0 for devices)
 26916                                  
 26917 00004BE5 AD                              LODSW                   ; skip dir_first, DS:SI -> dir_size_l
 26918 00004BE6 AD                              LODSW                   ; dir_size_l in AX , DS:SI -> dir_size_h
 26919 00004BE7 89C1                            MOV     CX,AX           ; dir_size_l in CX
 26920 00004BE9 AD                              LODSW                   ; dir_size_h (size AX:CX), DS:SI -> ????
 26921 00004BEA 08F6                            OR      DH,DH
 26922 00004BEC 7904                            JNS	short FILE_SFT1
 26923 00004BEE 31C0                            XOR     AX,AX
 26924 00004BF0 89C1                            MOV     CX,AX           ; Devices are open ended
 26925                                  FILE_SFT1:
 26926 00004BF2 91                              XCHG    AX,CX
 26927 00004BF3 AB                              STOSW                   ; Low word of sf_size
 26928 00004BF4 91                              XCHG    AX,CX
 26929 00004BF5 AB                              STOSW                   ; High word of sf_size
 26930                                                                  ; ES:DI -> sf_position
 26931                                  ; Initialize position to 0
 26932                                  
 26933 00004BF6 31C0                            XOR     AX,AX
 26934 00004BF8 AB                              STOSW
 26935 00004BF9 AB                              STOSW                   ; sf_position
 26936                                                                  ; ES:DI -> sf_cluspos
 26937                                  
 26938                                  ; Generate cluster optimizations for files
 26939                                  
 26940 00004BFA 08F6                            OR      DH,DH
 26941 00004BFC 7843                            JS	short DEV_SFT3
 26942 00004BFE AB                              STOSW                   ; sf_cluspos ; 19h
 26943                                  	;mov	ax,[bx+1Ah]
 26944 00004BFF 8B471A                          MOV     AX,[BX+dir_entry.dir_first]
 26945                                  	; 19/05/2019
 26946                                  	; MSDOS 3.3
 26947                                  	;STOSW 			; sf_lstclus ; 1Bh
 26948                                  	; MSDOS 6.0
 26949 00004C02 57                              PUSH	DI              ;AN004; save dirsec offset
 26950                                  	;sub	di,1Bh
 26951 00004C03 83EF1B                          SUB	DI,SF_ENTRY.sf_dirsec	;AN004; es:di -> SFT
 26952                                  	;mov	[es:di+35h],ax
 26953 00004C06 26894535                        MOV	[ES:DI+SF_ENTRY.sf_lstclus],AX	;AN004; save it
 26954 00004C0A 5F                              POP	DI              ;AN004; restore dirsec offset
 26955                                  
 26956                                  ; DOS 3.3  FastOpen  6/13/86
 26957                                  
 26958 00004C0B 1E                      	PUSH	DS
 26959                                  
 26960                                  ;hkn; SS is DOSDATA
 26961 00004C0C 16                      	push	ss
 26962 00004C0D 1F                      	pop	ds
 26963                                  	;test	byte [FastOpenFlg],4
 26964 00004C0E F606[3A0D]04            	TEST	byte [FastOpenFlg],Special_Fill_Set
 26965 00004C13 7411                    	JZ	short Not_FastOpen
 26966                                  
 26967                                  ;hkn; FastOpen_Ext_Info is in DOSDATA
 26968 00004C15 BE[3B0D]                        MOV     SI,FastOpen_Ext_Info
 26969                                  
 26970                                  	;mov	ax,[si+1]
 26971 00004C18 8B4401                          MOV     AX,[SI+FEI.dirsec]
 26972 00004C1B AB                              STOSW                   ; sf_dirsec
 26973                                  	; MSDOS 6.0
 26974                                  	;mov	ax,[si+3]
 26975 00004C1C 8B4403                          MOV	AX,[SI+FEI.dirsec+2]
 26976                                  				;;; changed for >32mb
 26977 00004C1F AB                              STOSW                   ; sf_dirsec
 26978                                  	; 19/08//2018
 26979 00004C20 8A04                    	mov	al,[SI]
 26980                                          ;MOV	AL,[SI+FEI.dirpos] ; mov al,[SI+0]
 26981 00004C22 AA                              STOSB                   ; sf_dirpos
 26982 00004C23 1F                              POP	DS
 26983                                          ;JMP	short Next_Name
 26984                                  	; 24/09/2023
 26985 00004C24 EB1E                    	jmp	short FILE_SFT2  ; cf=0 (after 'test' instruction)
 26986                                  
 26987                                  ; DOS 3.3  FastOpen  6/13/86
 26988                                  
 26989                                  Not_FastOpen:
 26990                                          ;POP     DS		; normal path
 26991                                  
 26992                                  ;hkn; SS override
 26993                                  	;MOV	SI,[SS:CURBUF]	; DS:SI->buffer header
 26994                                  	; 16/12/2022
 26995                                  	; 28/07/2019
 26996 00004C26 8B36[E205]              	mov	si,[CURBUF]
 26997 00004C2A 1F                      	pop	ds
 26998                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 26999                                  	;pop	ds
 27000                                  	;mov	si,[ss:CURBUF]
 27001                                  	
 27002                                  	;mov	ax,[si+6]
 27003 00004C2B 8B4406                          MOV     AX,[SI+BUFFINFO.buf_sector]     ;F.C. >32mb ;AN000;
 27004 00004C2E AB                              STOSW                   ; sf_dirsec     ;F.C. >32mb ;AN000;
 27005                                  	; 19/05/2019        
 27006                                  	; MSDOS 6.0
 27007                                  	;mov	ax,[si+8]
 27008 00004C2F 8B4408                  	MOV	AX,[SI+BUFFINFO.buf_sector+2]	;F.C. >32mb ;AN000;
 27009 00004C32 AB                              STOSW                   ; sf_dirsec     ;F.C. >32mb ;AN000;
 27010                                          
 27011 00004C33 89D8                    	MOV     AX,BX
 27012                                  	;;add	si,16	; MSDOS 3.3	
 27013                                  	;add	si,20	; MSDOS 6.0
 27014 00004C35 83C614                          ADD     SI,BUFINSIZ     ; DS:SI-> start of data in buffer
 27015 00004C38 29F0                            SUB     AX,SI           ; AX = BX relative to start of sector
 27016                                          ;mov	cl,32
 27017 00004C3A B120                    	MOV     CL,dir_entry.size
 27018 00004C3C F6F1                            DIV     CL
 27019 00004C3E AA                              STOSB                   ; sf_dirpos
 27020                                  Next_Name:
 27021 00004C3F EB03                            JMP     SHORT FILE_SFT2
 27022                                  
 27023                                  	; 24/09/2023
 27024                                  	; cf=0 (after 'or' instruction)
 27025                                  DEV_SFT3:
 27026                                  	;add	di,7
 27027 00004C41 83C707                          ADD     DI,SF_ENTRY.sf_name-SF_ENTRY.sf_cluspos
 27028                                  FILE_SFT2:
 27029                                  
 27030                                  ; Copy in the object's name
 27031                                  
 27032 00004C44 89DE                            MOV     SI,BX           ; DS:SI points to dir_name
 27033 00004C46 B90B00                          MOV     CX,11
 27034 00004C49 F3A4                            REP     MOVSB           ; sf_name
 27035 00004C4B 5E                              POP     SI              ; recover DS:SI -> dir_first
 27036                                  
 27037                                  ;hkn; SS is DOSDATA
 27038 00004C4C 16                              push	ss
 27039 00004C4D 1F                      	pop	ds
 27040                                  	; 24/09/2023
 27041                                  	; cf=0
 27042                                          ;CLC
 27043 00004C4E C3                              retn
 27044                                  
 27045                                  ;---------------------------------------------------------------------------
 27046                                  ;
 27047                                  ; Procedure Name : FREEENT
 27048                                  ;
 27049                                  ; Inputs:
 27050                                  ;       ES:BP -> DPB
 27051                                  ;       [CURBUF] Set
 27052                                  ;       [CURBUF+2]:BX points to directory entry
 27053                                  ;       [CURBUF+2]:SI points to above dir_first
 27054                                  ; Function:
 27055                                  ;       Free the cluster chain for the entry if present
 27056                                  ; Outputs:
 27057                                  ;       Carry set if error (currently user FAILed to I 24)
 27058                                  ;       (NOTE dir_firclus and dir_size_l/h are wrong)
 27059                                  ; DS BX SI ES BP preserved (BX,SI in meaning, not value) others destroyed
 27060                                  ;---------------------------------------------------------------------------
 27061                                  
 27062                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 27063                                  FREEENT:
 27064 00004C4F 1E                              PUSH    DS
 27065 00004C50 C53E[E205]                      LDS     DI,[CURBUF]
 27066 00004C54 8B0C                            MOV     CX,[SI]         ; Get pointer to clusters
 27067                                  	; 19/05/2019 - Retro DOS v4.0
 27068                                  	; MSDOS 6.0
 27069 00004C56 8B5508                  	MOV	DX,[DI+BUFFINFO.buf_sector+2]  ;F.C. >32mb	;AN000;
 27070                                  ;hkn; SS override
 27071 00004C59 368916[0706]                    MOV	[SS:HIGH_SECTOR],DX		;F.C. >32mb	;AN000;
 27072 00004C5E 8B5506                          MOV     DX,[DI+BUFFINFO.buf_sector]
 27073 00004C61 1F                              POP     DS
 27074 00004C62 83F902                  	CMP	CX,2
 27075 00004C65 722E                            JB	short RET1	; Was 0 length file (or mucked Firclus if CX=1)
 27076                                  	;cmp	cx,[es:bp+0Dh]
 27077 00004C67 263B4E0D                        CMP     CX,[ES:BP+DPB.MAX_CLUSTER]
 27078 00004C6B 7728                            JA	short RET1	; Treat like zero length file (firclus mucked)
 27079 00004C6D 29FB                            SUB     BX,DI
 27080 00004C6F 53                              PUSH    BX              ; Save offset
 27081 00004C70 FF36[0706]              	PUSH	word [HIGH_SECTOR] ;F.C. >32mb	;AN000;
 27082 00004C74 52                              PUSH    DX              ; Save sector number
 27083 00004C75 89CB                            MOV     BX,CX
 27084 00004C77 E8AC02                          call	RELEASE         ; Free any data allocated
 27085 00004C7A 5A                              POP     DX
 27086 00004C7B 8F06[0706]                      POP	word [HIGH_SECTOR] ;F.C. >32mb	;AN000;
 27087 00004C7F 7302                            JNC	short GET_BUF_BACK
 27088 00004C81 5B                              POP     BX
 27089                                  freeent_retn:
 27090 00004C82 C3                              retn			; Screw up
 27091                                  
 27092                                  GET_BUF_BACK:
 27093                                  	; 22/09/2023
 27094                                  	;;mov	byte [ALLOWED],18h
 27095                                          ;MOV	byte [ALLOWED],Allowed_RETRY+Allowed_FAIL ; *
 27096                                          ;XOR	AL,AL ; *
 27097                                  	;call	GETBUFFR        ; Get sector back
 27098 00004C83 E8300D                  	call	GETBUFFER ; * ; pre read      
 27099                                  
 27100 00004C86 5B                      	POP     BX              ; Get offset back
 27101 00004C87 72F9                            jc	short freeent_retn
 27102 00004C89 E8B0EA                  	call	SET_BUF_AS_DIR
 27103 00004C8C 031E[E205]                      ADD     BX,[CURBUF]	; Correct it for new buffer
 27104 00004C90 89DE                            MOV     SI,BX
 27105                                  	;add	si,1Ah
 27106 00004C92 83C61A                          ADD     SI,dir_entry.dir_first	; Get corrected SI
 27107                                  RET1:
 27108 00004C95 F8                              CLC
 27109 00004C96 C3                              retn
 27110                                  
 27111                                  ;---------------------------------------------------------------------------
 27112                                  ;
 27113                                  ; Procedure Name : CHECK_VIRT_OPEN
 27114                                  ;
 27115                                  ; CHECK_VIRT_OPEN checks to see if we had performed a "virtual open" (by
 27116                                  ; examining the flag [VIRTUAL_OPEN] to see if it is 1). If we did, then
 27117                                  ; it calls Dev_Close_SFT to decrement the ref. count. It also resets the
 27118                                  ; flag [VIRTUAL_OPEN].
 27119                                  ; No registers affected (including flags).
 27120                                  ; On input, [THISSFT] points to current SFT.
 27121                                  ;
 27122                                  ;---------------------------------------------------------------------------
 27123                                  
 27124                                  CHECK_VIRT_OPEN:
 27125 00004C97 50                      	PUSH    AX
 27126 00004C98 9F                              lahf                    ; preserve flags
 27127 00004C99 803E[A20A]00                    CMP     byte [VIRTUAL_OPEN],0
 27128 00004C9E 7410                            JZ	short ALL_CLOSED
 27129 00004CA0 C606[A20A]00                    mov     byte [VIRTUAL_OPEN],0	; reset flag
 27130 00004CA5 06                      	push	es
 27131 00004CA6 57                      	push	di
 27132 00004CA7 C43E[9E05]                      LES     DI,[THISSFT]
 27133 00004CAB E8ADF9                          call	DEV_CLOSE_SFT
 27134 00004CAE 5F                      	pop	di
 27135 00004CAF 07                      	pop	es
 27136                                  
 27137                                  ALL_CLOSED:
 27138 00004CB0 9E                              sahf                    ; restore flags
 27139 00004CB1 58                              POP     AX
 27140 00004CB2 C3                              retn
 27141                                  
 27142                                  ;============================================================================
 27143                                  ; ROM.ASM, MSDOS 6.0, 1991
 27144                                  ;============================================================================
 27145                                  ; 29/07/2018 - Retro DOS v3.0
 27146                                  ; 20/05/2019 - Retro DOS v4.0
 27147                                  
 27148                                  ;	TITLE	ROM - Miscellaneous routines
 27149                                  ;	NAME	ROM
 27150                                  
 27151                                  ;**	Misc Low level routines for doing simple FCB computations, Cache
 27152                                  ;       reads and writes, I/O optimization, and FAT allocation/deallocation
 27153                                  ;
 27154                                  ;	SKPCLP
 27155                                  ;	FNDCLUS
 27156                                  ;	BUFSEC
 27157                                  ;	BUFRD
 27158                                  ;	BUFWRT
 27159                                  ;	NEXTSEC
 27160                                  ;	OPTIMIZE
 27161                                  ;	FIGREC
 27162                                  ;	ALLOCATE
 27163                                  ;	RESTFATBYT
 27164                                  ;	RELEASE
 27165                                  ;	RELBLKS
 27166                                  ;	GETEOF
 27167                                  ;
 27168                                  ;	Modification history:
 27169                                  ;
 27170                                  ;		Created: ARR 30 March 1983
 27171                                  ;               M039: DB 10/25/90 - Disk read/write optimization.
 27172                                  
 27173                                  ;Break   <FNDCLUS -- Skip over allocation units>
 27174                                  ;--------------------------------------------------------------------------
 27175                                  ;
 27176                                  ; Procedure Name : FNDCLUS
 27177                                  ;
 27178                                  ; Inputs:
 27179                                  ;       CX = No. of clusters to skip
 27180                                  ;       ES:BP = Base of drive parameters
 27181                                  ;       [THISSFT] point to SFT
 27182                                  ; Outputs:
 27183                                  ;       BX = Last cluster skipped to
 27184                                  ;       CX = No. of clusters remaining (0 unless EOF)
 27185                                  ;       DX = Position of last cluster
 27186                                  ;       Carry set if error (currently user FAILed to I 24)
 27187                                  ; DI destroyed. No other registers affected.
 27188                                  ;--------------------------------------------------------------------------
 27189                                  
 27190                                  ; 20/05/2019 - Retro DOS v4.0
 27191                                  ; DOSCODE:8BF2h (MSDOS 6.21, MSDOS.SYS)
 27192                                  ; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 27193                                  ; DOSCODE:8BB7h (MSDOS 5.0, MSDOS.SYS)
 27194                                  
 27195                                  FNDCLUS:
 27196 00004CB3 06                      	PUSH	ES
 27197 00004CB4 C43E[9E05]                      LES     DI,[THISSFT]		; setup addressability to SFT
 27198                                  	;;mov	bx,[es:di+1Bh] ; MSDOS 3.3
 27199                                  	;mov	bx,[es:di+35h] ; MSDOS 6.0
 27200 00004CB8 268B5D35                	MOV	BX,[ES:DI+SF_ENTRY.sf_lstclus]
 27201                                  	;mov	dx,[es:di+19h]
 27202 00004CBC 268B5519                        MOV     DX,[ES:DI+SF_ENTRY.sf_cluspos]
 27203 00004CC0 09DB                    	OR	BX,BX
 27204 00004CC2 7424                    	JZ	short NOCLUS
 27205                                  
 27206 00004CC4 29D1                            SUB     CX,DX
 27207 00004CC6 7308                            JNB	short FINDIT
 27208                                  
 27209 00004CC8 01D1                            ADD     CX,DX
 27210 00004CCA 31D2                            XOR     DX,DX
 27211                                  	;mov	bx,[es:di+0Bh]
 27212 00004CCC 268B5D0B                        MOV     BX,[ES:DI+SF_ENTRY.sf_firclus]
 27213                                  FINDIT:
 27214 00004CD0 07                              POP	ES
 27215 00004CD1 E313                    	JCXZ	RET9
 27216                                  
 27217                                  	;entry	SKPCLP
 27218                                  SKPCLP:
 27219 00004CD3 E8CE08                  	call	UNPACK
 27220 00004CD6 7214                            jc	short fndclus_retn	; retc
 27221                                  
 27222                                  	; 09/09/2018
 27223                                  
 27224                                  	; MSDOS 3.3
 27225                                  	;push	bx
 27226                                  	;mov	bx,di
 27227                                  	;call	IsEOF
 27228                                  	;pop	bx	
 27229                                  	;jae	short RET9
 27230                                  
 27231                                  	; 20/05/2019 - Retro DOS v4.0
 27232                                  
 27233                                  	; MSDOS 6.0
 27234 00004CD8 87DF                    	xchg	bx,di
 27235 00004CDA E8B008                  	call	IsEOF
 27236 00004CDD 87DF                    	xchg	bx,di
 27237 00004CDF 7305                    	jae	short RET9
 27238                                  
 27239 00004CE1 87DF                            XCHG    BX,DI
 27240 00004CE3 42                              INC     DX
 27241                                  
 27242 00004CE4 E2ED                    	LOOP	SKPCLP			; RMFS
 27243                                  RET9:	
 27244 00004CE6 F8                      	CLC
 27245 00004CE7 C3                              retn
 27246                                  NOCLUS:
 27247 00004CE8 07                              POP	ES
 27248 00004CE9 41                              INC	CX
 27249 00004CEA 4A                              DEC	DX
 27250 00004CEB F8                              CLC
 27251                                  
 27252                                  fndclus_retn:
 27253 00004CEC C3                              retn
 27254                                  
 27255                                  ;Break  <BUFSEC -- BUFFER A SECTOR AND SET UP A TRANSFER>
 27256                                  ;--------------------------------------------------------------------------
 27257                                  ;
 27258                                  ; Procedure Name : BUFSEC
 27259                                  ;
 27260                                  ; Inputs:
 27261                                  ;       AH = priority of buffer
 27262                                  ;       AL = 0 if buffer must be read, 1 if no pre-read needed
 27263                                  ;       ES:BP = Base of drive parameters
 27264                                  ;       [CLUSNUM] = Physical cluster number
 27265                                  ;       [SECCLUSPOS] = Sector position of transfer within cluster
 27266                                  ;       [BYTCNT1] = Size of transfer
 27267                                  ; Function:
 27268                                  ;       Insure specified sector is in buffer, flushing buffer before
 27269                                  ;       read if necessary.
 27270                                  ; Outputs:
 27271                                  ;       ES:DI = Pointer to buffer
 27272                                  ;       SI = Pointer to transfer address
 27273                                  ;       CX = Number of bytes
 27274                                  ;       [NEXTADD] updated
 27275                                  ;       [TRANS] set to indicate a transfer will occur
 27276                                  ;       Carry set if error (user FAILed to I 24)
 27277                                  ;--------------------------------------------------------------------------
 27278                                  
 27279                                  BUFSEC:
 27280 00004CED 8B16[BC05]                      MOV     DX,[CLUSNUM]
 27281 00004CF1 8A1E[7305]                      MOV     BL,[SECCLUSPOS]
 27282                                  	;mov	byte [ALLOWED],38h
 27283 00004CF5 C606[4B03]38                    MOV     byte [ALLOWED],Allowed_FAIL+Allowed_RETRY+Allowed_IGNORE
 27284 00004CFA E85001                          CALL    FIGREC
 27285 00004CFD E8BD0C                  	call	GETBUFFR
 27286 00004D00 72EA                            jc	short fndclus_retn
 27287                                  
 27288 00004D02 C606[7405]01                    MOV     BYTE [TRANS],1	; A transfer is taking place
 27289 00004D07 8B36[B805]                      MOV     SI,[NEXTADD]
 27290 00004D0B 89F7                            MOV     DI,SI
 27291 00004D0D 8B0E[D205]                      MOV     CX,[BYTCNT1]
 27292 00004D11 01CF                            ADD     DI,CX
 27293 00004D13 893E[B805]                      MOV     [NEXTADD],DI
 27294 00004D17 C43E[E205]                      LES     DI,[CURBUF]
 27295                                  	;or	byte [es:di+5],8
 27296 00004D1B 26804D0508                      OR      byte [ES:DI+BUFFINFO.buf_flags],buf_isDATA
 27297                                  	;;lea	di,[di+16] ; MSDOS 3.3 
 27298                                  	;lea	di,[di+20] ; MSDOS 6.0
 27299 00004D20 8D7D14                          LEA     DI,[DI+BUFINSIZ]        ; Point to buffer
 27300 00004D23 033E[CC05]                      ADD     DI,[BYTSECPOS]
 27301 00004D27 F8                              CLC
 27302 00004D28 C3                              retn
 27303                                  
 27304                                  ;Break   <BUFRD, BUFWRT -- PERFORM BUFFERED READ AND WRITE>
 27305                                  
 27306                                  ;---------------------------------------------------------------------------
 27307                                  ;
 27308                                  ; Procedure Name : BUFRD
 27309                                  ;
 27310                                  ; Do a partial sector read via one of the system buffers
 27311                                  ; ES:BP Points to DPB
 27312                                  ; Carry set if error (currently user FAILed to I 24)
 27313                                  ;
 27314                                  ; DS - set to DOSDATA
 27315                                  ;
 27316                                  ;----------------------------------------------------------------------------
 27317                                  
 27318                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 27319                                  	; 20/05/2019 - Retro DOS v4.0
 27320                                  BUFRD:
 27321 00004D29 06                              PUSH	ES
 27322 00004D2A 31C0                            xor	ax, ax			; pre-read sector
 27323 00004D2C E8BEFF                          CALL    BUFSEC
 27324 00004D2F 7303                            JNC	short BUF_OK
 27325                                  
 27326                                  BUF_IO_FAIL:				; this label used by BUFWRT also
 27327 00004D31 07                              POP	ES
 27328 00004D32 EB2B                            JMP     SHORT RBUFPLACED
 27329                                  
 27330                                  BUF_OK:
 27331 00004D34 8CC3                            MOV     BX,ES
 27332 00004D36 8E06[2E03]                      MOV     ES,[DMAADD+2]
 27333 00004D3A 8EDB                            MOV     DS,BX
 27334 00004D3C 87FE                    	XCHG    DI,SI
 27335 00004D3E D1E9                            SHR     CX,1
 27336                                  ;M039
 27337                                  	; MSDOS 3.3
 27338                                  	;JNC	short EVENRD
 27339                                  	;MOVSB
 27340                                  ;EVENRD:
 27341                                  	;REP     MOVSW
 27342                                  
 27343                                  ;	CX = # of whole WORDs ; CF=1 if odd # of bytes.
 27344                                  ;       DS:SI-> Source within Buffer.
 27345                                  ;       ES:DI-> Destination within Transfer memory block.
 27346                                  
 27347                                  	; MSDOS 6.0
 27348 00004D40 F3A5                    	rep	movsw			;Copy Buffer to Transfer memory.
 27349                                  	;adc	cx,0                    ;CX=1 if odd # of bytes, else CX=0.
 27350                                  	;rep	movsb                   ;Copy last byte.
 27351                                  	; 16/12/2022
 27352 00004D42 7301                    	jnc	short EVENRD ; **** 20/05/2019
 27353 00004D44 A4                      	movsb ; ****
 27354                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 27355                                  	;adc	cx,0
 27356                                  	;rep	movsb
 27357                                  ;M039
 27358                                  EVENRD: ; ****
 27359 00004D45 07                              POP	ES
 27360                                  ;hkn; SS override
 27361 00004D46 36C53E[E205]                    LDS     DI,[SS:CURBUF]
 27362                                  	;;lea	bx,[di+16]
 27363                                  	;lea	bx,[di+20] ; MSDOS 6.0
 27364 00004D4B 8D5D14                  	LEA     BX,[DI+BUFINSIZ]
 27365 00004D4E 29DE                            SUB     SI,BX                   ; Position in buffer
 27366 00004D50 E80A0C                          call	PLACEBUF
 27367                                  	;cmp	si,[es:bp+2]
 27368 00004D53 263B7602                	CMP	SI,[ES:BP+DPB.SECTOR_SIZE] ; Read Last byte?
 27369 00004D57 7205                            JB	short RBUFPLACEDC	; No, leave buf where it is
 27370                                  ;M039
 27371                                  	; MSDOS 3.3
 27372                                  	;call	PLACEHEAD               ; Make it prime candidate for chucking
 27373                                                                          ;  even though it is MRU.
 27374                                          ; MSDOS 6.0
 27375 00004D59 36893E[6D00]            	MOV	[ss:BufferQueue],DI	; Make it prime candidate for
 27376                                  ;M039					; chucking even though it is MRU.
 27377                                  
 27378                                  RBUFPLACEDC:
 27379 00004D5E F8                              CLC
 27380                                  RBUFPLACED:
 27381 00004D5F 16                      	push	ss
 27382 00004D60 1F                      	pop	ds
 27383 00004D61 C3                              retn
 27384                                  
 27385                                  ;----------------------------------------------------------------------------
 27386                                  ;
 27387                                  ; Procedure : BUFWRT
 27388                                  ;
 27389                                  ; Do a partial sector write via one of the system buffers
 27390                                  ; ES:BP Points to DPB
 27391                                  ; Carry set if error (currently user FAILed to I 24)
 27392                                  ;
 27393                                  ; DS - set to DOSDATA
 27394                                  ;
 27395                                  ;----------------------------------------------------------------------------
 27396                                  
 27397                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 27398                                  	; 20/05/2019 - Retro DOS v4.0
 27399                                  BUFWRT:
 27400                                          ;MOV     AX,[SECPOS]
 27401                                          ; MSDOS 6.0
 27402                                  	;ADD	AX,1            	; Set for next sector
 27403                                          ;MOV	[SECPOS],AX 		;F.C. >32mb	;AN000;
 27404                                          ;ADC	word [SECPOS+2],0	;F.C. >32mb	;AN000;
 27405                                          ; 24/09/2023
 27406 00004D62 FF06[C405]              	inc	word [SECPOS]
 27407 00004D66 7504                    	jnz	short bufw_secpos
 27408 00004D68 FF06[C605]              	inc	word [SECPOS+2]
 27409                                  bufw_secpos:
 27410 00004D6C A1[C605]                	MOV	AX,[SECPOS+2]		;F.C. >32mb	;AN000;
 27411 00004D6F 3B06[CA05]                      CMP	AX,[VALSEC+2]		;F.C. >32mb	;AN000;
 27412 00004D73 B001                            MOV	AL,1			;F.C. >32mb	;AN000;
 27413 00004D75 770F                            JA	short NOREAD		;F.C. >32mb	;AN000;
 27414 00004D77 720B                            JB	short _doread		;F.C. >32mb	;AN000;
 27415 00004D79 A1[C405]                        MOV	AX,[SECPOS]		;F.C. >32mb	;AN000;
 27416                                  
 27417                                  	; MSDOS 3.3
 27418                                  	;INC	AX
 27419                                  	;MOV	[SECPOS],AX ; 09/09/2018
 27420                                  
 27421                                  	; 20/05/2019
 27422                                  	; MSDOS 3.3 & MSDOS 6.0
 27423 00004D7C 3B06[C805]                      CMP     AX,[VALSEC]		; Has sector been written before?
 27424 00004D80 B001                            MOV     AL,1
 27425 00004D82 7702                            JA	short NOREAD		; Skip preread if SECPOS>VALSEC
 27426                                  _doread:
 27427 00004D84 30C0                            XOR     AL,AL
 27428                                  NOREAD:
 27429 00004D86 06                              PUSH	ES
 27430 00004D87 E863FF                          CALL    BUFSEC
 27431 00004D8A 72A5                    	JC	short BUF_IO_FAIL
 27432 00004D8C 8E1E[2E03]                      MOV     DS,[DMAADD+2]
 27433 00004D90 D1E9                            SHR     CX,1
 27434                                  ;M039
 27435                                  	; MSDOS 3.3
 27436                                  	;JNC	short EVENWRT ; 09/09/2018
 27437                                  	;MOVSB
 27438                                  ;EVENWRT:
 27439                                  	;REP	MOVSW
 27440                                  
 27441                                  ;	CX = # of whole WORDs; CF=1 if odd # of bytes.
 27442                                  ;       DS:SI-> Source within Transfer memory block.
 27443                                  ;       ES:DI-> Destination within Buffer.
 27444                                  
 27445                                  	; MSDOS 6.0
 27446 00004D92 F3A5                    	rep	movsw			;Copy Transfer memory to Buffer.
 27447                                  	;adc	cx,0                    ;CX=1 if odd # of bytes, else CX=0.
 27448                                  	;rep	movsb                   ;Copy last byte.
 27449                                  	; 16/12/2022
 27450 00004D94 7301                    	jnc	short EVENWRT ; **** 20/05/2019
 27451 00004D96 A4                      	movsb ; ****
 27452                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 27453                                  	;adc	cx,0
 27454                                  	;rep	movsb
 27455                                  ;M039
 27456                                  EVENWRT: ; ****
 27457 00004D97 07                              POP	ES
 27458                                  
 27459                                  ;hkn; SS override
 27460 00004D98 36C51E[E205]                    LDS     BX,[SS:CURBUF]
 27461                                  
 27462                                  	; MSDOS 6.0
 27463 00004D9D F6470540                        TEST	byte [BX+BUFFINFO.buf_flags],buf_dirty
 27464                                  					;LB. if already dirty		  ;AN000;
 27465 00004DA1 7507                            JNZ	short yesdirty10	;LB.  don't increment dirty count ;AN000;
 27466 00004DA3 E8190E                  	call	INC_DIRTY_COUNT		;LB.				  ;AN000;
 27467                                  	
 27468                                  	;or	byte [bx+5],40h
 27469 00004DA6 804F0540                        OR	byte [BX+BUFFINFO.buf_flags],buf_dirty
 27470                                  yesdirty10:
 27471                                  	;;lea	si,[bx+16]
 27472                                  	;lea	si,[bx+20] ; MSDOS 6.0
 27473 00004DAA 8D7714                          LEA     SI,[BX+BUFINSIZ]
 27474 00004DAD 29F7                            SUB     DI,SI                   ; Position in buffer
 27475                                  ;M039
 27476                                  	; MSDOS 3.3
 27477                                  	;MOV	SI,DI
 27478                                  	;MOV	DI,BX
 27479                                  	;call	PLACEBUF
 27480                                  	;;cmp	si,[es:bp+2]
 27481                                  	;CMP	SI,[ES:BP+DPB.SECTOR_SIZE] ; Written last byte?
 27482                                  	;JB	short WBUFPLACED	; No, leave buf where it is
 27483                                  	;call	PLACEHEAD               ; Make it prime candidate for chucking
 27484                                                                          ;  even though it is MRU.
 27485                                  	; MSDOS 6.0
 27486                                  	;cmp	di,[es:bp+2]
 27487 00004DAF 263B7E02                	CMP	di,[ES:BP+DPB.SECTOR_SIZE] ; Written last byte?
 27488 00004DB3 7205                            JB	short WBUFPLACED	; No, leave buf where it is
 27489 00004DB5 36891E[6D00]                    MOV	[ss:BufferQueue],BX	; Make it prime candidate for
 27490                                  					; chucking even though it is MRU.
 27491                                  ;M039
 27492                                  
 27493                                  WBUFPLACED:
 27494 00004DBA F8                              CLC
 27495 00004DBB 16                      	push	ss
 27496 00004DBC 1F                      	pop	ds
 27497 00004DBD C3                              retn
 27498                                  
 27499                                  ;Break   <NEXTSEC -- Compute next sector to read or write>
 27500                                  ;---------------------------------------------------------------------------
 27501                                  ;
 27502                                  ; Procedure Name : NEXTSEC
 27503                                  ;
 27504                                  ; Compute the next sector to read or write
 27505                                  ; ES:BP Points to DPB
 27506                                  ;
 27507                                  ;---------------------------------------------------------------------------
 27508                                  
 27509                                  NEXTSEC:
 27510 00004DBE F606[7405]FF            	test	byte [TRANS],0FFh ; -1 
 27511 00004DC3 7426                            JZ	short CLRET
 27512                                  
 27513 00004DC5 A0[7305]                        MOV     AL,[SECCLUSPOS]
 27514 00004DC8 FEC0                            INC     AL
 27515                                  	;cmp	al,[es:bp+4]
 27516 00004DCA 263A4604                        CMP     AL,[ES:BP+DPB.CLUSTER_MASK]
 27517 00004DCE 7618                            JBE	short SAVPOS
 27518                                  
 27519 00004DD0 8B1E[BC05]                      MOV     BX,[CLUSNUM]
 27520 00004DD4 E8B607                          call	IsEOF
 27521 00004DD7 7314                            JAE	short NONEXT
 27522                                  
 27523 00004DD9 E8C807                          call	UNPACK
 27524 00004DDC 720F                            JC	short NONEXT
 27525                                  clusgot:
 27526 00004DDE 893E[BC05]                      MOV     [CLUSNUM],DI
 27527 00004DE2 FF06[BA05]                      INC     word [LASTPOS]
 27528 00004DE6 B000                            MOV     AL,0
 27529                                  SAVPOS:
 27530 00004DE8 A2[7305]                        MOV     [SECCLUSPOS],AL
 27531                                  CLRET:
 27532 00004DEB F8                              CLC
 27533 00004DEC C3                              retn
 27534                                  NONEXT:
 27535 00004DED F9                              STC
 27536 00004DEE C3                              retn
 27537                                  
 27538                                  ;Break	<OPTIMIZE -- DO A USER DISK REQUEST WELL>
 27539                                  ;----------------------------------------------------------------------------
 27540                                  ;
 27541                                  ; Procedure Name : OPTIMIZE
 27542                                  ;
 27543                                  ; Inputs:
 27544                                  ;       BX = Physical cluster
 27545                                  ;       CX = No. of records
 27546                                  ;       DL = sector within cluster
 27547                                  ;       ES:BP = Base of drive parameters
 27548                                  ;       [NEXTADD] = transfer address
 27549                                  ; Outputs:
 27550                                  ;       AX = No. of records remaining
 27551                                  ;       BX = Transfer address
 27552                                  ;       CX = No. or records to be transferred
 27553                                  ;       DX = Physical sector address            (LOW)
 27554                                  ;       [HIGH_SECTOR] = Physical sector address (HIGH)
 27555                                  ;       DI = Next cluster
 27556                                  ;       [CLUSNUM] = Last cluster accessed
 27557                                  ;       [NEXTADD] updated
 27558                                  ;       Carry set if error (currently user FAILed to I 24)
 27559                                  ; ES:BP unchanged. Note that segment of transfer not set.
 27560                                  ;
 27561                                  ;---------------------------------------------------------------------------
 27562                                  
 27563                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 27564                                  OPTIMIZE:
 27565 00004DEF 52                      	PUSH    DX
 27566 00004DF0 53                              PUSH    BX
 27567                                  	;mov	al,[es:bp+4]
 27568 00004DF1 268A4604                        MOV     AL,[ES:BP+DPB.CLUSTER_MASK]
 27569 00004DF5 FEC0                            INC     AL              ; Number of sectors per cluster
 27570 00004DF7 88C4                            MOV     AH,AL
 27571 00004DF9 28D0                            SUB     AL,DL           ; AL = Number of sectors left in first cluster
 27572 00004DFB 89CA                            MOV     DX,CX
 27573                                  	;MOV	CX,0
 27574                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 27575                                  	; 16/12/2022
 27576 00004DFD 31C9                    	xor	cx,cx	; sub cx,cx
 27577                                  OPTCLUS:
 27578                                  ; AL has number of sectors available in current cluster
 27579                                  ; AH has number of sectors available in next cluster
 27580                                  ; BX has current physical cluster
 27581                                  ; CX has number of sequential sectors found so far
 27582                                  ; DX has number of sectors left to transfer
 27583                                  ; ES:BP Points to DPB
 27584                                  ; ES:SI has FAT pointer
 27585                                  
 27586                                  do_norm3:
 27587 00004DFF E8A207                          call	UNPACK
 27588 00004E02 7236                            JC	short OP_ERR
 27589                                  clusgot2:
 27590 00004E04 00C1                    	ADD	CL,AL
 27591 00004E06 80D500                          ADC     CH,0
 27592 00004E09 39D1                            CMP     CX,DX
 27593 00004E0B 7332                            JAE	short BLKDON
 27594 00004E0D 88E0                            MOV     AL,AH
 27595 00004E0F 43                              INC     BX
 27596 00004E10 39DF                            CMP     DI,BX
 27597 00004E12 74EB                            JZ	short OPTCLUS
 27598 00004E14 4B                              DEC     BX
 27599                                  FINCLUS:
 27600 00004E15 891E[BC05]                      MOV     [CLUSNUM],BX    ; Last cluster accessed
 27601 00004E19 29CA                            SUB     DX,CX           ; Number of sectors still needed
 27602 00004E1B 52                              PUSH    DX
 27603 00004E1C 89C8                            MOV     AX,CX
 27604                                  	;mul	word[ES:BP+2]
 27605 00004E1E 26F76602                        MUL	word [ES:BP+DPB.SECTOR_SIZE] 
 27606                                  				; Number of sectors times sector size
 27607 00004E22 8B36[B805]                      MOV     SI,[NEXTADD]
 27608 00004E26 01F0                            ADD     AX,SI           ; Adjust by size of transfer
 27609 00004E28 A3[B805]                        MOV     [NEXTADD],AX
 27610 00004E2B 58                              POP     AX              ; Number of sectors still needed
 27611 00004E2C 5A                              POP     DX              ; Starting cluster
 27612 00004E2D 29D3                            SUB     BX,DX           ; Number of new clusters accessed
 27613 00004E2F 011E[BA05]                      ADD     [LASTPOS],BX
 27614 00004E33 5B                              POP     BX              ; BL = sector position within cluster
 27615 00004E34 E81600                  	call	FIGREC
 27616 00004E37 89F3                            MOV     BX,SI
 27617                                  	; 24/09/2023
 27618                                  	; cf=0 (at the return of FIGREC)
 27619                                  	;CLC
 27620 00004E39 C3                              retn
 27621                                  OP_ERR:
 27622 00004E3A 83C404                          ADD     SP,4
 27623 00004E3D F9                      	STC
 27624 00004E3E C3                              retn
 27625                                  BLKDON:
 27626 00004E3F 29D1                            SUB     CX,DX           ; Number of sectors in cluster we don't want
 27627 00004E41 28CC                            SUB     AH,CL           ; Number of sectors in cluster we accepted
 27628 00004E43 FECC                            DEC     AH              ; Adjust to mean position within cluster
 27629 00004E45 8826[7305]                      MOV     [SECCLUSPOS],AH
 27630 00004E49 89D1                            MOV     CX,DX           ; Anyway, make the total equal to the request
 27631 00004E4B EBC8                            JMP     SHORT FINCLUS
 27632                                  
 27633                                  ;Break	<FIGREC -- Figure sector in allocation unit>
 27634                                  ;---------------------------------------------------------------------------
 27635                                  ;
 27636                                  ; Procedure Name : FIGREC
 27637                                  ;
 27638                                  ; Inputs:
 27639                                  ;       DX = Physical cluster number
 27640                                  ;       BL = Sector position within cluster
 27641                                  ;       ES:BP = Base of drive parameters
 27642                                  ; Outputs:
 27643                                  ;       DX = physical sector number           (LOW)
 27644                                  ;       [HIGH_SECTOR] Physical sector address (HIGH)
 27645                                  ; No other registers affected.
 27646                                  ;
 27647                                  ;---------------------------------------------------------------------------
 27648                                  
 27649                                  	; 10/06/2019
 27650                                  	; 20/05/2019 - Retro DOS v4.0
 27651                                  	; DOSCODE:8D96h (MSDOS 6.21, MSDOS.SYS)
 27652                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 27653                                  	; DOSCODE:8D5Bh (MSDOS 5.0, MSDOS.SYS)	
 27654                                  FIGREC:
 27655 00004E4D 51                              PUSH    CX
 27656                                  	;mov	cl,[es:bp+5]
 27657 00004E4E 268A4E05                        MOV     CL,[ES:BP+DPB.CLUSTER_SHIFT]
 27658 00004E52 4A                              DEC     DX
 27659 00004E53 4A                              DEC     DX
 27660                                  
 27661                                  	; MSDOS 3.3
 27662                                  	;SHL	DX,CL
 27663                                  
 27664                                  ;hkn; SS override HIGH_SECTOR
 27665                                  	; MSDOS 6.0
 27666 00004E54 36C706[0706]0000        	MOV	word [SS:HIGH_SECTOR],0		;F.C. >32mb
 27667                                  	; 24/09/2023
 27668 00004E5B 30ED                    	xor	ch,ch				;F.C. >32mb
 27669 00004E5D 08C9                    	OR	CL,CL				;F.C. >32mb
 27670 00004E5F 740C                    	JZ	short noshift			;F.C. >32mb
 27671 00004E61 30ED                    	XOR	CH,CH				;F.C. >32mb
 27672                                  rotleft:					;F.C. >32mb
 27673 00004E63 F8                      	CLC					;F.C. >32mb
 27674 00004E64 D1D2                    	RCL	DX,1				;F.C. >32mb
 27675                                  	; 10/06/2019
 27676 00004E66 36D116[0706]            	RCL	word [ss:HIGH_SECTOR],1		;F.C. >32mb
 27677 00004E6B E2F6                    	LOOP	rotleft				;F.C. >32mb
 27678                                  noshift:
 27679                                  	; MSDOS 3.3 & MSDOS 6.0
 27680 00004E6D 08DA                            OR      DL,BL
 27681                                  	;add	dx,[es:bp+0Bh]
 27682 00004E6F 2603560B                        ADD     DX,[ES:BP+DPB.FIRST_SECTOR]
 27683                                  	; MSDOS 6.0
 27684                                  	; 10/06/2019
 27685                                  	;ADC	word [ss:HIGH_SECTOR],0		;F.C. >32mb
 27686                                  	; 24/09/2023
 27687                                  	; cx=0
 27688 00004E73 36110E[0706]            	ADC	word [ss:HIGH_SECTOR],cx ; 0
 27689                                  
 27690                                  	; MSDOS 3.3 & MSDOS 6.0
 27691 00004E78 59                      	POP     CX
 27692                                  figrec_retn:
 27693 00004E79 C3                              retn
 27694                                  
 27695                                  ; 20/05/2019 - Retro DOS v4.0
 27696                                  ; DOSCODE:8DC2h (MSDOS 6.21, MSDOS.SYS)
 27697                                  
 27698                                  ; 30/07/2018 - Retro DOS v3.0
 27699                                  ; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 
 27700                                  
 27701                                  ;Break   <ALLOCATE -- Assign disk space>
 27702                                  ;---------------------------------------------------------------------------
 27703                                  ;
 27704                                  ; Procedure Name : ALLOCATE - Allocate Disk Space
 27705                                  ;
 27706                                  ;   ALLOCATE is called to allocate disk clusters. The new clusters are
 27707                                  ;   FAT-chained onto the end of the existing file.
 27708                                  ;
 27709                                  ;   The DPB contains the cluster # of the last free cluster allocated
 27710                                  ;   (dpb_next_free). We start at this cluster and scan towards higher
 27711                                  ;   numbered clusters, looking for the necessary free blocks.
 27712                                  ;
 27713                                  ;   Once again, fancy terminology gets in the way of correct coding. When
 27714                                  ;   using next_free, start scanning AT THAT POINT and not the one following it.
 27715                                  ;   This fixes the boundary condition bug when only free = next_free = 2.
 27716                                  ;
 27717                                  ;       If we get to the end of the disk without satisfaction:
 27718                                  ;
 27719                                  ;           if (dpb_next_free == 2) then we've scanned the whole disk.
 27720                                  ;               return (insufficient_disk_space)
 27721                                  ;           ELSE
 27722                                  ;               dpb_next_free = 2; start scan over from the beginning.
 27723                                  ;
 27724                                  ;   Note that there is no multitasking interlock. There is no race when
 27725                                  ;   examining the entrys in an in-core FAT block since there will be no
 27726                                  ;   context switch. When UNPACK context switches while waiting for a FAT read
 27727                                  ;   we are done with any in-core FAT blocks, so again there is no race. The
 27728                                  ;   only special concern is that V2 and V3 MSDOS left the last allocated
 27729                                  ;   cluster as "00"; marking it EOF only when the entire alloc request was
 27730                                  ;   satisfied. We can't allow another activation to think this cluster is
 27731                                  ;   free, so we give it a special temporary mark to show that it is, indeed,
 27732                                  ;   allocated.
 27733                                  ;
 27734                                  ;   Note that when we run out of space this algorithem will scan from
 27735                                  ;   dpb_next_free to the end, then scan from cluster 2 through the end,
 27736                                  ;   redundantly scanning the later part of the disk. This only happens when
 27737                                  ;   we run out of space, so sue me.
 27738                                  ;
 27739                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
 27740                                  ;            C  A  V  E  A  T     P  A  T  T  E  R  S  O  N                ;
 27741                                  ;                                                                          ;
 27742                                  ;   The use of FATBYT and RESTFATBYT is somewhat mysterious. Here is the
 27743                                  ;   explanation:
 27744                                  ;
 27745                                  ;   In the NUL file case (sf_firclus currently 0) ALLOCATE is called with
 27746                                  ;   entry BX = 0. What needs to be done in this case is to stuff the cluster
 27747                                  ;   number of the first cluster allocated in sf_firclus when the ALLOCATE is
 27748                                  ;   complete. THIS VALUE IS SAVED TEMPORARILY IN CLUSTER 0, HENCE THE CURRENT
 27749                                  ;   VALUE IN CLUSTER 0 MUST BE SAVED AND RESTORED. This is a side effect of
 27750                                  ;   the fact that PACK and UNPACK don't treat requests for clusters 0 and 1 as
 27751                                  ;   errors. This "stuff" is done by the call to PACK which is right before
 27752                                  ;   the
 27753                                  ;           LOOP   findfre         ; alloc more if needed
 27754                                  ;   instruction when the first cluster is allocated to the nul file. The
 27755                                  ;   value is recalled from cluster 0 and stored at sf_firclus at ads4:
 27756                                  ;
 27757                                  ;   This method is obviously useless (because it is non-reentrant) for
 27758                                  ;   multitasking, and will have to be changed. Storing the required value on
 27759                                  ;   the stack is recommended. Setting sf_firclus at the PACK of cluster 0
 27760                                  ;   (instead of actually doing the PACK) is BAD because it doesn't handle
 27761                                  ;   problems with INT 24 well.
 27762                                  ;
 27763                                  ;            C  A  V  E  A  T     P  A  T  T  E  R  S  O  N                ;
 27764                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
 27765                                  ;                                                                          ;
 27766                                  ;       ENTRY   BX = Last cluster of file (0 if null file)
 27767                                  ;               CX = No. of clusters to allocate
 27768                                  ;               ES:BP = Base of drive parameters
 27769                                  ;               [THISSFT] = Points to SFT
 27770                                  ;
 27771                                  ;       EXIT    'C' set if insufficient space
 27772                                  ;                 [FAILERR] can be tested to see the reason for failure
 27773                                  ;                 CX = max. no. of clusters that could be added to file
 27774                                  ;               'C' clear if space allocated
 27775                                  ;                 BX = First cluster allocated
 27776                                  ;                 FAT is fully updated
 27777                                  ;                 sf_FIRCLUS field of SFT set if file was null
 27778                                  ;
 27779                                  ;       USES    ALL but SI, BP
 27780                                  
 27781                                  ;callmagic  proc near
 27782                                  ;       push    ds                             ;push segment of routine 
 27783                                  ;       push    Offset MagicPatch              ;push offset for routine
 27784                                  ;       retf                                   ;simulate jmp far
 27785                                  ;                                              ;far return address is on
 27786                                  ;                                              ;stack, so far return from
 27787                                  ;                                              ;call will return this routine
 27788                                  ;callmagic  endp
 27789                                  
 27790                                  
 27791                                  ; 25/09/2023
 27792                                  %if 0
 27793                                  callmagic:
 27794                                  	push	ds
 27795                                  	push	MagicPatch
 27796                                  	retf	
 27797                                  %endif
 27798                                  
 27799                                  ALLOCATE:
 27800                                  	; 10/09/2018
 27801                                  ;BEGIN MAGICDRV MODIFICATIONS
 27802                                  ;
 27803                                  ;7/5/92 scottq
 27804                                  ;
 27805                                  ;This is the disk compression patch location which allows
 27806                                  ;the disk compression software to fail allocations if the
 27807                                  ;FAT would allows allocation, but the free space for compressed
 27808                                  ;data would not.
 27809                                  ;        
 27810                                  ;;;	call    far ptr MAGICPATCH
 27811                                  ;;; We cannot do a far call since we cannot have fix-ups[romdos,hidos],
 27812                                  ;;; but we do know the segment and offset of the routine
 27813                                  ;;; so simulate a far call to dosdata:magicpatch
 27814                                  ;;; note dosassume above, so DS -> dosdata
 27815                                  
 27816                                  	; MSDOS 6.0
 27817                                          ;clc				;clear carry so we fall through
 27818                                  	;				;if no patch is present
 27819                                  	;push	cs			;push segment for far return
 27820                                          ;call	callmagic		;this is a near call
 27821                                          ;jnc	short Regular_Allocate_Path
 27822                                  	;jmp	Disk_Full_Return
 27823                                  
 27824                                  ; 25/09/2023
 27825                                  %if 0
 27826                                  	clc
 27827                                  	push	cs
 27828                                  	call	callmagic
 27829                                  	jnc	short Regular_Allocate_Path
 27830                                  	jmp	Disk_Full_Return
 27831                                  Regular_Allocate_Path:
 27832                                  %endif
 27833                                  
 27834                                  	; 20/05/2019 - Retro DOS v4.0
 27835                                  ;END MAGICDRV MODIFICATIONS
 27836                                  
 27837                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 27838                                  	; DOSCODE:8D87h (MSDOS 5.0, MSDOS.SYS)
 27839                                  
 27840 00004E7A 53                              PUSH    BX                      ; save (bx)
 27841 00004E7B 31DB                            XOR     BX,BX
 27842 00004E7D E82407                  	call	UNPACK
 27843 00004E80 893E[9605]                      MOV     [FATBYT],DI             ; save correct cluster 0 value
 27844 00004E84 5B                              POP     BX
 27845 00004E85 72F2                            jc	short figrec_retn	; abort if error   [INTERR?]
 27846                                  
 27847 00004E87 51                              PUSH    CX
 27848 00004E88 53                              PUSH    BX
 27849                                  
 27850 00004E89 89DA                            MOV     DX,BX
 27851                                  	;;mov	bx,[es:bp+1Ch]  ; MSDOS 3.3
 27852                                  	;mov	bx,[es:bp+1Dh]	; MSDOS 6.0
 27853 00004E8B 268B5E1D                        mov     bx,[ES:BP+DPB.NEXT_FREE]
 27854 00004E8F 83FB02                          cmp     bx,2
 27855 00004E92 7709                            ja	short FINDFRE
 27856                                  
 27857                                  ;   couldn't find enough free space beyond dpb_next_free, or dpb_next_free is
 27858                                  ;   <2 or >dpb_max_clus. Reset it and restart the scan
 27859                                  
 27860                                  ads1:
 27861                                  	;;mov	word [es:bp+1Ch],2 ; MSDOS 3.3
 27862                                  	;mov	word [es:bp+1Dh],2 ; MSDOS 6.0
 27863 00004E94 26C7461D0200                    mov     word [ES:BP+DPB.NEXT_FREE],2
 27864 00004E9A BB0100                          mov     bx,1                    ; Counter next instruction so first
 27865                                                                          ;       cluster examined is 2
 27866                                  
 27867                                  ;   Scanning both forwards and backwards for a free cluster
 27868                                  ;
 27869                                  ;       (BX) = forwards scan pointer
 27870                                  ;       (CX) = clusters remaining to be allocated
 27871                                  ;       (DX) = current last cluster in file
 27872                                  ;       (TOS) = last cluster of file
 27873                                  
 27874                                  FINDFRE:
 27875 00004E9D 43                              INC     BX
 27876                                  	;cmp	bx,[es:bp+0Dh]
 27877 00004E9E 263B5E0D                        CMP	BX,[ES:BP+DPB.MAX_CLUSTER]
 27878 00004EA2 7757                    	ja	short ads7	; at end of disk
 27879 00004EA4 E8FD06                          call	UNPACK          ; check out this cluster
 27880 00004EA7 722F                            jc	short ads4	; FAT error             [INTERR?]
 27881 00004EA9 75F2                            jnz	short FINDFRE	; not free, keep on truckin
 27882                                  
 27883                                  ;   Have found a free cluster. Chain it to the file
 27884                                  ;
 27885                                  ;       (BX) = found free cluster #
 27886                                  ;       (DX) = current last cluster in file
 27887                                  
 27888                                  	;;mov	[es:bp+1Ch],bx
 27889                                  	;mov	[es:bp+1Dh],bx ; MSDOS 6.0
 27890 00004EAB 26895E1D                        mov	[ES:BP+DPB.NEXT_FREE],bx ; next time start search here
 27891 00004EAF 92                              xchg    ax,dx           ; save (dx) in ax
 27892 00004EB0 BA0100                          mov     dx,1            ; mark this free guy as "1"
 27893 00004EB3 E84207                  	call	PACK            ; set special "temporary" mark
 27894 00004EB6 7220                            jc	short ads4	; FAT error             [INTERR?]
 27895                                  	;;cmp	word [es:bp+1Eh],-1
 27896                                          ;cmp	word [es:bp+1Fh],-1 ; MSDOS 6.0
 27897 00004EB8 26837E1FFF              	CMP	word [ES:BP+DPB.FREE_CNT],-1 ; Free count valid?
 27898 00004EBD 7404                            JZ	short NO_ALLOC	; No
 27899                                  	;;dec	word [es:bp+1Eh]
 27900                                          ;dec	word [es:bp+1Fh] ; MSDOS 6.0
 27901 00004EBF 26FF4E1F                        DEC     word [ES:BP+DPB.FREE_CNT] ; Reduce free count by 1
 27902                                  NO_ALLOC:
 27903 00004EC3 92                              xchg    ax,dx           ; (dx) = current last cluster in file
 27904 00004EC4 87DA                            XCHG    BX,DX
 27905 00004EC6 89D0                            MOV     AX,DX
 27906 00004EC8 E82D07                  	call	PACK            ; link free cluster onto file
 27907                                                                  ;  CAVEAT.. On Nul file, first pass stuffs
 27908                                                                  ;    cluster 0 with FIRCLUS value.
 27909 00004ECB 720B                            jc	short ads4	; FAT error [INTERR?]
 27910 00004ECD 93                              xchg    BX,AX           ; (BX) = last one we looked at
 27911 00004ECE 89DA                            mov     dx,bx           ; (dx) = current end of file
 27912 00004ED0 E2CB                            LOOP    FINDFRE         ; alloc more if needed
 27913                                  
 27914                                  ;   We've successfully extended the file. Clean up and exit
 27915                                  ;
 27916                                  ;       (BX) = last cluster in file
 27917                                  
 27918 00004ED2 BAFFFF                          MOV     DX,0FFFFH
 27919 00004ED5 E82007                  	call	PACK            ; mark last cluster EOF
 27920                                  
 27921                                  ;   Note that FAT errors jump here to clean the stack and exit. This saves us
 27922                                  ;   2 whole bytes. Hope its worth it...
 27923                                  ;
 27924                                  ;       'C' set if error
 27925                                  ;       calling (BX) and (CX) pushed on stack
 27926                                  
 27927                                  ads4:   
 27928 00004ED8 5B                      	POP     BX
 27929 00004ED9 59                              POP     CX              ; Don't need this stuff since we're successful
 27930 00004EDA 729D                            jc	short figrec_retn
 27931 00004EDC E8C506                          call	UNPACK          ; Get first cluster allocated for return
 27932                                                                  ; CAVEAT... In nul file case, UNPACKs cluster 0.
 27933 00004EDF 7298                            jc	short figrec_retn
 27934 00004EE1 E83200                  	call	RESTFATBYT      ; Restore correct cluster 0 value
 27935 00004EE4 7293                            jc	short figrec_retn
 27936 00004EE6 87DF                            XCHG    BX,DI           ; (DI) = last cluster in file upon our entry
 27937 00004EE8 09FF                            OR      DI,DI           ; clear 'C'
 27938 00004EEA 758D                    	jnz	short figrec_retn ; we were extending an existing file
 27939                                  
 27940                                  ;   We were doing the first allocation for a new file. Update the SFT cluster
 27941                                  ;   info
 27942                                  dofastk:
 27943                                  	; 20/05/2019
 27944                                  	; MSDOS 6.0
 27945                                  	;push	dx ; * MSDOS 6.0
 27946                                  	;;mov	dl,[es:bp+0]
 27947                                  	;;MOV	DL,[ES:BP+DPB.DRIVE]	; get drive #
 27948                                  	;mov	dl,[es:bp]
 27949                                  
 27950                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 27951                                  	; DOSCODE:8DF9h (MSDOS 5.0, MSDOS.SYS)
 27952                                  	
 27953                                  	; 16/12/2022
 27954                                  	;push	dx ; *
 27955                                  	;mov	dl,[ES:BP+DPB.DRIVE] 
 27956                                  	; 15/12/2022
 27957                                  	;mov	dl,[es:bp]
 27958                                  	
 27959                                  	; MSDOS 3.3 & MSDOS 6.0
 27960 00004EEC 06                      	PUSH	ES
 27961 00004EED C43E[9E05]              	LES     DI,[THISSFT]
 27962                                  	;mov	[es:di+0Bh],bx
 27963 00004EF1 26895D0B                	MOV     [ES:DI+SF_ENTRY.sf_firclus],BX
 27964                                  	;;mov	[es:di+1Bh],bx ; MSDOS 3.3
 27965                                  	;mov	[es:di+35h],bx ; MSDOS 6.0
 27966 00004EF5 26895D35                	MOV     [ES:DI+SF_ENTRY.sf_lstclus],BX
 27967 00004EF9 07                      	POP	ES
 27968                                  	;retn
 27969                                  
 27970                                  	;pop	dx ; * MSDOS 6.0
 27971                                  
 27972                                  	; 16/12/2022
 27973                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 27974                                  	;pop	dx ; *
 27975                                  
 27976 00004EFA C3                      	retn	
 27977                                  
 27978                                  ;** we're at the end of the disk, and not satisfied. See if we've scanned ALL
 27979                                  ;   of the disk...
 27980                                  
 27981                                  ads7:   
 27982 00004EFB 26837E1D02              	cmp	word [ES:BP+DPB.NEXT_FREE],2
 27983 00004F00 7592                    	jnz	short ads1	; start scan from front of disk
 27984                                  
 27985                                  ;   Sorry, we've gone over the whole disk, with insufficient luck. Lets give
 27986                                  ;   the space back to the free list and tell the caller how much he could have
 27987                                  ;   had.  We have to make sure we remove the "special mark" we put on the last
 27988                                  ;   cluster we were able to allocate, so it doesn't become orphaned.
 27989                                  ;
 27990                                  ;       (CX) = clusters remaining to be allocated
 27991                                  ;       (TOS) = last cluster of file (before call to ALLOCATE)
 27992                                  ;       (TOS+1) = # of clusters wanted to allocate
 27993                                  
 27994 00004F02 5B                              POP     BX              ; (BX) = last cluster of file
 27995 00004F03 BAFFFF                          MOV     DX,0FFFFH
 27996 00004F06 E81F00                  	call	RELBLKS         ; give back any clusters just alloced
 27997 00004F09 58                              POP     AX              ; No. of clusters requested
 27998                                                                  ; Don't "retc". We are setting Carry anyway,
 27999                                                                  ;   Alloc failed, so proceed with return CX
 28000                                                                  ;   setup.
 28001 00004F0A 29C8                            SUB     AX,CX           ; AX=No. of clusters allocated
 28002 00004F0C E80700                  	call	RESTFATBYT      ; Don't "retc". We are setting Carry anyway,
 28003                                                                  ;   Alloc failed.
 28004                                  Disk_Full_Return:               ;label added for magic patch 8-6-92 scottq
 28005                                          ; MSDOS 6.0
 28006 00004F0F C606[0B06]01            	MOV	byte [DISK_FULL],1 ;MS. indicating disk full
 28007 00004F14 F9                              STC
 28008 00004F15 C3                              retn
 28009                                  
 28010                                  ;-----------------------------------------------------------------------
 28011                                  ;
 28012                                  ; Procedure Name : RESTFATBYT
 28013                                  ;
 28014                                  ; SEE ALLOCATE CAVEAT
 28015                                  ;       Carry set if error (currently user FAILed to I 24)
 28016                                  ;-----------------------------------------------------------------------
 28017                                  
 28018                                  RESTFATBYT:
 28019 00004F16 53                              PUSH    BX
 28020 00004F17 52                              PUSH    DX
 28021 00004F18 57                              PUSH    DI
 28022 00004F19 31DB                            XOR     BX,BX
 28023 00004F1B 8B16[9605]                      MOV     DX,[FATBYT]
 28024 00004F1F E8D606                  	call	PACK
 28025 00004F22 5F                              POP     DI
 28026 00004F23 5A                              POP     DX
 28027 00004F24 5B                              POP     BX
 28028                                  ; 16/12/2022
 28029                                  ; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 28030                                  ;RELEASE_flush:
 28031 00004F25 C3                      	retn
 28032                                  
 28033                                  ;Break	<RELEASE -- DEASSIGN DISK SPACE>
 28034                                  ;---------------------------------------------------------------------------
 28035                                  ;
 28036                                  ; Procedure Name : RELEASE
 28037                                  ;
 28038                                  ; Inputs:
 28039                                  ;       BX = Cluster in file
 28040                                  ;       ES:BP = Base of drive parameters
 28041                                  ; Function:
 28042                                  ;       Frees cluster chain starting with [BX]
 28043                                  ;       Carry set if error (currently user FAILed to I 24)
 28044                                  ; AX,BX,DX,DI all destroyed. Other registers unchanged.
 28045                                  ;
 28046                                  ;-----------------------------------------------------------------------------
 28047                                  
 28048                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 28049                                  	; 20/05/2019 - Retro DOS v4.0
 28050                                  RELEASE:
 28051 00004F26 31D2                            XOR     DX,DX
 28052                                  
 28053                                  	;entry	RELBLKS
 28054                                  RELBLKS:
 28055                                  
 28056                                  ;   Enter here with DX=0FFFFH to put an end-of-file mark in the first cluster
 28057                                  ;   and free the rest in the chain.
 28058                                  
 28059 00004F28 E87906                  	call	UNPACK
 28060 00004F2B 7224                    	jc	short RELEASE_flush
 28061 00004F2D 7422                    	jz	short RELEASE_flush
 28062 00004F2F 89F8                            MOV     AX,DI
 28063 00004F31 52                              PUSH    DX
 28064 00004F32 E8C306                  	call	PACK
 28065 00004F35 5A                              POP     DX
 28066 00004F36 7219                    	jc	short RELEASE_flush
 28067 00004F38 09D2                            OR      DX,DX
 28068 00004F3A 750B                            JNZ	short NO_DEALLOC	; Was putting EOF mark
 28069                                  	;;cmp	word [es:bp+1Eh],-1 ; MSDOS 3.3
 28070                                  	;cmp	word [es:bp+1Fh],-1 ; MSDOS 6.0
 28071 00004F3C 26837E1FFF              	CMP     word [ES:BP+DPB.FREE_CNT],-1 ; Free count valid?
 28072 00004F41 7404                            JZ	short NO_DEALLOC	; No
 28073 00004F43 26FF461F                        INC	word [ES:BP+DPB.FREE_CNT] ; Increase free count by 1
 28074                                  NO_DEALLOC:
 28075 00004F47 89C3                            MOV     BX,AX
 28076 00004F49 48                              dec     ax              ; check for "1"
 28077 00004F4A 7405                    	jz	short RELEASE_flush	; is last cluster of incomplete chain
 28078 00004F4C E83E06                  	call	IsEOF
 28079 00004F4F 72D5                            JB	short RELEASE	; Carry clear if JMP not taken
 28080                                  
 28081                                  	; 16/12/2022
 28082                                  ; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 28083                                  ;%if 0
 28084                                  RELEASE_flush:
 28085                                  	; MSDOS 6.0
 28086 00004F51 268A4600                	mov	al,[es:bp]
 28087                                  	;MOV	AL,[ES:BP+DPB.DRIVE]
 28088 00004F55 56                      	push	si		; FLUSHBUF may trash these and we guarantee
 28089 00004F56 51                      	push	cx		;  them to be preserved.
 28090 00004F57 06                      	push	es
 28091 00004F58 55                      	push	bp
 28092 00004F59 E85E0B                  	call	FLUSHBUF	; commit buffers for this drive
 28093 00004F5C 5D                      	pop	bp
 28094 00004F5D 07                      	pop	es
 28095 00004F5E 59                      	pop	cx
 28096 00004F5F 5E                      	pop	si
 28097                                  ;%endif
 28098                                  RET12:
 28099 00004F60 C3                      	retn
 28100                                  
 28101                                  ;Break	<GETEOF -- Find the end of a file>
 28102                                  ;------------------------------------------------------------------------
 28103                                  ;
 28104                                  ; Procedure Name : GETEOF
 28105                                  ;
 28106                                  ; Inputs:
 28107                                  ;       ES:BP Points to DPB
 28108                                  ;       BX = Cluster in a file
 28109                                  ;       DS = CS
 28110                                  ; Outputs:
 28111                                  ;       BX = Last cluster in the file
 28112                                  ;       Carry set if error (currently user FAILed to I 24)
 28113                                  ; DI destroyed. No other registers affected.
 28114                                  ;
 28115                                  ;--------------------------------------------------------------------------
 28116                                  
 28117                                  GETEOF:
 28118 00004F61 E84006                  	call	UNPACK
 28119 00004F64 72FA                            jc	short RET12
 28120 00004F66 53                              PUSH    BX
 28121 00004F67 89FB                            MOV     BX,DI
 28122 00004F69 E82106                  	call	IsEOF
 28123 00004F6C 5B                              POP     BX
 28124 00004F6D 73F1                            JAE     short RET12
 28125 00004F6F 89FB                            MOV     BX,DI
 28126 00004F71 EBEE                            JMP     short GETEOF
 28127                                  
 28128                                  ;============================================================================
 28129                                  ; FCB.ASM, MSDOS 6.0, 1991
 28130                                  ;============================================================================
 28131                                  ; 30/07/2018 - Retro DOS v3.0
 28132                                  ; 20/05/2019 - Retro DOS v4.0
 28133                                  
 28134                                  ;	TITLE	FCB - FCB parse calls for MSDOS
 28135                                  ;	NAME	FCB
 28136                                  
 28137                                  ;**	FCB.ASM - Low level routines for parsing names into FCBs and analyzing
 28138                                  ;		  filename characters
 28139                                  ;
 28140                                  ;	MakeFcb
 28141                                  ;	NameTrans
 28142                                  ;	PATHCHRCMP
 28143                                  ;	GetLet
 28144                                  ;	UCase
 28145                                  ;	GetLet3
 28146                                  ;	GetCharType
 28147                                  ;	TESTKANJ
 28148                                  ;	NORMSCAN
 28149                                  ;	DELIM
 28150                                  ;
 28151                                  ;	Revision history:
 28152                                  ;
 28153                                  ;		A000  version 4.00  Jan. 1988
 28154                                  ;	
 28155                                  ;	M048 - access FILE_UCASE_TAB using DS rather than SS.
 28156                                  
 28157                                  TableLook	EQU	-1
 28158                                  
 28159                                  SCANSEPARATOR	EQU	1
 28160                                  DRVBIT		EQU	2
 28161                                  NAMBIT		EQU	4
 28162                                  EXTBIT		EQU	8
 28163                                  
 28164                                  ;----------------------------------------------------------------------------
 28165                                  ;
 28166                                  ; Procedure : MakeFcb
 28167                                  ;
 28168                                  ;----------------------------------------------------------------------------
 28169                                  
 28170                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 28171                                  	; DOSCODE:8E77h (MSDOS 5.0, MSDOS.SYS)
 28172                                  MAKEFCB:
 28173                                  ;hkn; SS override
 28174 00004F73 36C606[4E03]00          	MOV	BYTE [SS:SpaceFlag],0
 28175 00004F79 30D2                    	XOR	DL,DL		; Flag--not ambiguous file name
 28176                                  	;test	al,2
 28177 00004F7B A802                    	test	AL,DRVBIT	; Use current drive field if default?
 28178 00004F7D 7504                    	JNZ	short DEFDRV
 28179 00004F7F 26C60500                	MOV	BYTE [ES:DI],0	; No - use default drive
 28180                                  DEFDRV:
 28181 00004F83 47                      	INC	DI
 28182 00004F84 B90800                  	MOV	CX,8
 28183                                  	;test	al,4
 28184 00004F87 A804                    	test	AL,NAMBIT	; Use current name fields as default?
 28185 00004F89 93                      	XCHG	AX,BX		; Save bits in BX
 28186 00004F8A B020                    	MOV	AL," "
 28187 00004F8C 7404                    	JZ	short FILLB	; If not, go fill with blanks
 28188 00004F8E 01CF                    	ADD	DI,CX
 28189 00004F90 31C9                    	XOR	CX,CX		; Don't fill any
 28190                                  FILLB:
 28191 00004F92 F3AA                    	REP	STOSB
 28192 00004F94 B103                    	MOV	CL,3
 28193 00004F96 F6C308                  	test	BL,EXTBIT	; Use current extension as default
 28194 00004F99 7404                    	JZ	short FILLB2
 28195 00004F9B 01CF                    	ADD	DI,CX
 28196 00004F9D 31C9                    	XOR	CX,CX
 28197                                  FILLB2:
 28198 00004F9F F3AA                    	REP	STOSB
 28199 00004FA1 91                      	XCHG	AX,CX		; Put zero in AX
 28200 00004FA2 AB                      	STOSW
 28201 00004FA3 AB                      	STOSW			; Initialize two words after to zero
 28202 00004FA4 83EF10                  	SUB	DI,16		; Point back at start
 28203                                  	;test	bl,1
 28204 00004FA7 F6C301                  	test	BL,SCANSEPARATOR; Scan off separators if not zero
 28205 00004FAA 7409                    	JZ	short SKPSPC
 28206 00004FAC E88800                  	CALL	SCANB		; Peel off blanks and tabs
 28207 00004FAF E82201                  	CALL	DELIM		; Is it a one-time-only delimiter?
 28208 00004FB2 7504                    	JNZ	short NOSCAN
 28209 00004FB4 46                      	INC	SI		; Skip over the delimiter
 28210                                  SKPSPC:
 28211 00004FB5 E87F00                  	CALL	SCANB		; Always kill preceding blanks and tabs
 28212                                  NOSCAN:
 28213 00004FB8 E8F000                  	CALL	GETLET
 28214 00004FBB 761E                    	JBE	short NODRV	; Quit if termination character
 28215 00004FBD 803C3A                  	CMP	BYTE [SI],":"	; Check for potential drive specifier
 28216 00004FC0 7519                    	JNZ	short NODRV
 28217 00004FC2 46                      	INC	SI		; Skip over colon
 28218 00004FC3 2C40                    	SUB	AL,"@"          ; Convert drive letter to drive number (A=1)
 28219 00004FC5 760F                    	JBE	short BADDRV	; Drive letter out of range
 28220                                  
 28221 00004FC7 50                      	PUSH	AX
 28222 00004FC8 E81D1B                  	call	GetVisDrv
 28223 00004FCB 58                      	POP	AX
 28224 00004FCC 730A                    	JNC	short HAVDRV
 28225                                  
 28226                                  	; 20/05/2019 - Retro DOS v4.0
 28227                                  	; MSDOS 6.0
 28228                                  ;hkn; SS override
 28229 00004FCE 36803E[1006]1A          	CMP	byte [SS:DrvErr],error_not_DOS_disk ; 1Ah
 28230                                  					; if not FAT drive ;AN000;
 28231 00004FD4 7402                    	JZ	short HAVDRV		; assume ok	   ;AN000;
 28232                                  BADDRV:
 28233 00004FD6 B2FF                    	MOV	DL,-1
 28234                                  HAVDRV:
 28235 00004FD8 AA                      	STOSB			; Put drive specifier in first byte
 28236 00004FD9 46                      	INC	SI
 28237 00004FDA 4F                      	DEC	DI		; Counteract next two instructions
 28238                                  NODRV:
 28239 00004FDB 4E                      	DEC	SI		; Back up
 28240 00004FDC 47                      	INC	DI		; Skip drive byte
 28241                                  
 28242                                  	;entry	NORMSCAN
 28243                                  NORMSCAN:
 28244 00004FDD B90800                  	MOV	CX,8
 28245 00004FE0 E82200                  	CALL	GETWORD 	; Get 8-letter file name
 28246 00004FE3 803C2E                  	CMP	BYTE [SI],"."
 28247 00004FE6 7510                    	JNZ	short NODOT
 28248 00004FE8 46                      	INC	SI		; Skip over dot if present
 28249                                  
 28250                                  	; 24/09/2023
 28251                                  	;mov	cx,3
 28252 00004FE9 B103                    	mov	cl,3	; ch=0
 28253                                  
 28254                                  	; MSDOS 6.0
 28255                                  ;hkn; SS override
 28256                                  	;TEST	word [SS:DOS34_FLAG],DBCS_VOLID2 ; 100h ;AN000;
 28257                                  	; 10/06/2019
 28258 00004FEB 36F606[1206]01          	test	byte [SS:DOS34_FLAG+1],(DBCS_VOLID2>>8) ; 1
 28259 00004FF1 7402                    	JZ	short VOLOK				;AN000;
 28260 00004FF3 A4                      	MOVSB			; 2nd byte of DBCS	;AN000;
 28261                                  	; 24/09/2023
 28262                                  	;MOV	CX,2					;AN000;
 28263 00004FF4 49                      	dec	cx  ; cx=2
 28264                                  	;JMP	SHORT contvol				;AN000;
 28265                                  VOLOK:
 28266                                  	;MOV	CX,3		; Get 3-letter extension
 28267                                  contvol:
 28268 00004FF5 E81300                  	CALL	MUSTGETWORD
 28269                                  NODOT:
 28270 00004FF8 88D0                    	MOV	AL,DL
 28271                                  
 28272                                  	; MSDOS 6.0
 28273                                  	;and	word [ss:DOS34_FLAG],0FEFFh
 28274                                  	; 18/12/2022
 28275 00004FFA 368026[1206]FE          	and	byte [ss:DOS34_FLAG+1],0FEh ; (~DBCS_VOLID2)>>8
 28276                                  	;and	word [ss:DOS34_FLAG],~DBCS_VOLID2 ; ### BUG FIX ###
 28277                                  
 28278 00005000 C3                      	retn
 28279                                  
 28280                                  NONAM:
 28281 00005001 01CF                    	ADD	DI,CX
 28282 00005003 4E                      	DEC	SI
 28283 00005004 C3                      	retn
 28284                                  
 28285                                  GETWORD:
 28286 00005005 E8A300                  	CALL	GETLET		
 28287 00005008 76F7                    	JBE	short NONAM	; Exit if invalid character
 28288 0000500A 4E                      	DEC	SI
 28289                                  
 28290                                  ;	UGH!!! Horrible bug here that should be fixed at some point:
 28291                                  ;	If the name we are scanning is longer than CX, we keep on reading!
 28292                                  
 28293                                  MUSTGETWORD:
 28294 0000500B E89D00                  	CALL	GETLET
 28295                                  
 28296                                  ;	If spaceFlag is set then we allow spaces in a pathname
 28297                                  
 28298                                  ;IF NOT TABLELOOK
 28299                                  ;	JB	short FILLNAM  ; MSDOS 3.3
 28300                                  ;ENDIF
 28301 0000500E 750C                    	JNZ	short MustCheckCX
 28302                                  
 28303                                  ;hkn; SS override
 28304 00005010 36F606[4E03]FF          	test	BYTE [SS:SpaceFlag],0FFh
 28305 00005016 7419                    	JZ	short FILLNAM
 28306 00005018 3C20                    	CMP	AL," "
 28307 0000501A 7515                    	JNZ	short FILLNAM
 28308                                  
 28309                                  MustCheckCX:
 28310 0000501C E3ED                    	JCXZ	MUSTGETWORD
 28311 0000501E 49                      	DEC	CX
 28312 0000501F 3C2A                    	CMP	AL,"*"          ; Check for ambiguous file specifier
 28313 00005021 7504                    	JNZ	short NOSTAR
 28314 00005023 B03F                    	MOV	AL,"?"
 28315 00005025 F3AA                    	REP	STOSB
 28316                                  NOSTAR:
 28317 00005027 AA                      	STOSB
 28318 00005028 3C3F                    	CMP	AL,"?"
 28319 0000502A 75DF                    	JNZ	short MUSTGETWORD
 28320 0000502C 80CA01                  	OR	DL,1		; Flag ambiguous file name
 28321 0000502F EBDA                    	JMP	short MUSTGETWORD
 28322                                  FILLNAM:
 28323 00005031 B020                    	MOV	AL," "
 28324 00005033 F3AA                    	REP	STOSB
 28325 00005035 4E                      	DEC	SI
 28326 00005036 C3                      	retn
 28327                                  
 28328                                  SCANB:
 28329 00005037 AC                      	LODSB
 28330 00005038 E8A100                  	CALL	SPCHK
 28331 0000503B 74FA                    	JZ	short SCANB
 28332 0000503D 4E                      	DEC	SI
 28333                                  scanb_retn:
 28334 0000503E C3                      	retn
 28335                                  
 28336                                  ;----------------------------------------------------------------------------
 28337                                  ;
 28338                                  ; Procedure Name : NameTrans
 28339                                  ;
 28340                                  ; NameTrans is used by FindPath to scan off an element of a path. We must
 28341                                  ; allow spaces in pathnames
 28342                                  ;
 28343                                  ;   Inputs:	DS:SI points to start of path element
 28344                                  ;   Outputs:	Name1 has unpacked name, uppercased
 28345                                  ;		ES = DOSGroup
 28346                                  ;		DS:SI advanced after name
 28347                                  ;   Registers modified: DI,AX,DX,CX
 28348                                  ;
 28349                                  ;----------------------------------------------------------------------------
 28350                                  
 28351                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 28352                                  	; 20/05/2019 - Retro DOS v4.0
 28353                                  NameTrans:
 28354                                  ;hkn; SS override
 28355 0000503F 36C606[4E03]01          	MOV	BYTE [SS:SpaceFlag],1
 28356 00005045 16                      	push	ss
 28357 00005046 07                      	pop	es
 28358                                  
 28359                                  ;hkn; NAME1 is in DOSDATA
 28360 00005047 BF[4B05]                	MOV	DI,NAME1
 28361 0000504A 57                      	PUSH	DI
 28362 0000504B B82020                  	MOV	AX,'  '
 28363 0000504E B90500                  	MOV	CX,5
 28364 00005051 AA                      	STOSB
 28365 00005052 F3AB                    	REP	STOSW		; Fill "FCB" at NAME1 with spaces
 28366 00005054 30C0                    	XOR	AL,AL		; Set stuff for NORMSCAN
 28367 00005056 88C2                    	MOV	DL,AL
 28368 00005058 AA                      	STOSB
 28369 00005059 5F                      	POP	DI
 28370                                  
 28371 0000505A E880FF                  	CALL	NORMSCAN
 28372                                  
 28373                                  ;hkn; SS override for NAME1
 28374 0000505D 36803E[4B05]E5          	CMP	byte [SS:NAME1],0E5H
 28375 00005063 75D9                    	jnz	short scanb_retn
 28376 00005065 36C606[4B05]05          	MOV	byte [SS:NAME1],5 ; Magic name translation
 28377 0000506B C3                      	retn
 28378                                  
 28379                                  ;Break	<GETLET, DELIM -- CHECK CHARACTERS AND CONVERT>
 28380                                  ;============================================================================
 28381                                  
 28382                                  ; 20/05/2019 - Retro DOS v4.0
 28383                                  ; DOSCODE:8FD2h (MSDOS 6.21, MSDOS.SYS)
 28384                                  
 28385                                  ;If TableLook
 28386                                  
 28387                                  ;hkn; Table	SEGMENT
 28388                                  ;	PUBLIC	CharType
 28389                                  ;----------------------------------------------------------------------------
 28390                                  
 28391                                  ; Character type table for file name scanning
 28392                                  ; Table provides a mapping of characters to validity bits.
 28393                                  ; Four bits are provided for each character. Values 7Dh and above
 28394                                  ; have all bits set, so that part of the table is chopped off, and
 28395                                  ; the translation routine is responsible for screening these values.
 28396                                  ; The bit values are defined in DOSSYM.INC
 28397                                  
 28398                                  ;	      ; ^A and NUL
 28399                                  ;CharType:
 28400                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 28401                                  ;	      ; ^C and ^B
 28402                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 28403                                  ;	      ; ^E and ^D
 28404                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 28405                                  ;	      ; ^G and ^F
 28406                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 28407                                  ;	      ; TAB and BS
 28408                                  ;	 db   LOW ((NOT FFCB+FCHK+FDELIM+FSPCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 28409                                  ;	      ; ^K and ^J
 28410                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 28411                                  ;	      ; ^M and ^L
 28412                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 28413                                  ;	      ; ^O and ^N
 28414                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 28415                                  ;	      ; ^Q and ^P
 28416                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 28417                                  ;	      ; ^S and ^R
 28418                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 28419                                  ;	      ; ^U and ^T
 28420                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 28421                                  ;	      ; ^W and ^V
 28422                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 28423                                  ;	      ; ^Y and ^X
 28424                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 28425                                  ;	      ; ESC and ^Z
 28426                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 28427                                  ;	      ; ^] and ^;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 28429                                  ;	      ; ^_ and ^^
 28430                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 28431                                  ;	      ; ! and SPACE
 28432                                  ;	 db   LOW (NOT FCHK+FDELIM+FSPCHK)
 28433                                  ;	      ; # and "
 28434                                  ;	 db   LOW (NOT FFCB+FCHK)
 28435                                  ;	      ; $ - )
 28436                                  ;	 db   3 dup (0FFh)
 28437                                  ;	      ; + and *
 28438                                  ;	 db   LOW ((NOT FFCB+FCHK+FDELIM) SHL 4) OR 0Fh
 28439                                  ;	      ; - and '
 28440                                  ;	 db   NOT (FFCB+FCHK+FDELIM)
 28441                                  ;	      ; / and .
 28442                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FCHK) AND 0Fh
 28443                                  ;	      ; 0 - 9
 28444                                  ;	 db   5 dup (0FFh)
 28445                                  ;	      ; ; and :
 28446                                  ;	 db   LOW ((NOT FFCB+FCHK+FDELIM) SHL 4) OR LOW (NOT FFCB+FCHK+FDELIM) AND 0Fh
 28447                                  ;	      ; = and <
 28448                                  ;	 db   LOW ((NOT FFCB+FCHK+FDELIM) SHL 4) OR LOW (NOT FFCB+FCHK+FDELIM) AND 0Fh
 28449                                  ;	      ; ? and >
 28450                                  ;	 db   NOT FFCB+FCHK+FDELIM
 28451                                  ;	      ; A - Z
 28452                                  ;	 db   13 dup (0FFh)
 28453                                  ;	      ; \ and [
 28454                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR 0Fh
 28455                                  ;	      ; ^ and ]
 28456                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
 28457                                  ;	      ; _ - {
 28458                                  ;	 db   15 dup (0FFh)
 28459                                  ;	      ; } and |
 28460                                  ;	 db   NOT FFCB+FCHK+FDELIM
 28461                                  
 28462                                  ;CharType_last equ ($ - CharType) * 2	; This is the value of the last
 28463                                  ;					; character in the table
 28464                                  
 28465                                  ;FCHK	equ 1		; normal name char, no chks needed
 28466                                  ;FDELIM	equ 2		; is a delimiter
 28467                                  ;FSPCHK	equ 4		; set if character is not a space or equivalent
 28468                                  ;FFCB	equ 8		; is valid in an FCB
 28469                                  
 28470                                  ; DOSCODE:8FD2h (MSDOS 6.21, MSDOS.SYS)
 28471                                  ;----------------------------------------------------------------------------
 28472                                  ; DOSCODE:8F76h (MSDOS 5.0, MSDOS.SYS)
 28473                                  
 28474                                  CharType: ; 63 bytes
 28475 0000506C 6666666606666666                db  66h, 66h, 66h, 66h, 06h, 66h, 66h, 66h ; 0-7
 28476 00005074 6666666666666666        	db  66h, 66h, 66h, 66h, 66h, 66h, 66h, 66h ; 8-15
 28477 0000507C F8F6FFFFFF4FF46E        	db 0F8h,0F6h,0FFh,0FFh,0FFh, 4Fh,0F4h, 6Eh ; 16-23
 28478 00005084 FFFFFFFFFF4444F4        	db 0FFh,0FFh,0FFh,0FFh,0FFh, 44h, 44h,0F4h ; 24-31
 28479 0000508C FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh ; 32-39
 28480 00005094 FFFFFFFFFF6F66FF        	db 0FFh,0FFh,0FFh,0FFh,0FFh, 6Fh, 66h,0FFh ; 40-47
 28481 0000509C FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh ; 48-55
 28482 000050A4 FFFFFFFFFFFFF4          	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0F4h	   ; 56-62
 28483                                  
 28484                                  CharType_last equ ($ - CharType) * 2
 28485                                  
 28486                                  ; Offset 12CAh of IBMDOS.COM (MSDOS 3.3), 1987
 28487                                  ;----------------------------------------------------------------------------
 28488                                  ;CharType:
 28489                                  ;       db 0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h
 28490                                  ;	db 0F6h,0F0h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h
 28491                                  ;	db 0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h
 28492                                  ;	db 0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h
 28493                                  ;	db 0F8h,0FFh,0F6h,0FFh,0FFh,0FFh,0FFh,0FFh
 28494                                  ;	db 0FFh,0FFh,0FFh,0F4h,0F4h,0FFh,0FEh,0F6h
 28495                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28496                                  ;	db 0FFh,0FFh,0F4h,0F4h,0F4h,0F4h,0F4h,0FFh
 28497                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28498                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28499                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28500                                  ;	db 0FFh,0FFh,0FFh,0F6h,0F6h,0F6h,0FFh,0FFh
 28501                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28502                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28503                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28504                                  ;	db 0FFh,0FFh,0FFh,0FFh,0F4h,0FFh,0FFh,0FFh
 28505                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28506                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28507                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28508                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28509                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28510                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28511                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28512                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28513                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28514                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28515                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28516                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28517                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28518                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28519                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28520                                  ;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
 28521                                  
 28522                                  ;hkn; Table	ENDS
 28523                                  
 28524                                  ;ENDIF
 28525                                  
 28526                                  ; 20/05/2019 - Retro DOS v4.0
 28527                                  ; DOSCODE:9011h (MSDOS 6.21, MSDOS.SYS)
 28528                                  
 28529                                  ; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 28530                                  ; DOSCODE:8FB5h (MSDOS 5.0, MSDOS.SYS)
 28531                                  
 28532                                  ;----------------------------------------------------------------------------
 28533                                  ;
 28534                                  ; Procedure Names : GetLet, UCase, GetLet3
 28535                                  ;
 28536                                  ; These routines take a character, convert it to upper case, and check
 28537                                  ; for delimiters.  Three different entry points:
 28538                                  ;	GetLet -  DS:[SI] = character to convert
 28539                                  ;	UCase  -  AL = character to convert
 28540                                  ;	GetLet3 - AL = character
 28541                                  ;		  [BX] = translation table to use
 28542                                  ;
 28543                                  ;	Exit (in all cases) : AL = upper case character
 28544                                  ;			      CY set if char is control char other than TAB
 28545                                  ;			      ZF set if char is a delimiter
 28546                                  ;	Uses : AX, flags
 28547                                  ;
 28548                                  ; NOTE: This routine exists in a fast table lookup version, and a slow
 28549                                  ; inline version.  Return with carry set is only possible in the inline
 28550                                  ; version. The table lookup version is the one in use.
 28551                                  ;
 28552                                  ;----------------------------------------------------------------------------
 28553                                  
 28554                                  ; This entry point has character at [SI]
 28555                                  
 28556                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5517h
 28557                                  GETLET:	
 28558 000050AB AC                      	LODSB
 28559                                  
 28560                                  ; This entry point has character in AL
 28561                                  
 28562                                  	;entry	UCase
 28563                                  UCase:	
 28564                                  	; 09/08/2018
 28565                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5518h
 28566                                  _UCase:
 28567 000050AC 53                      	PUSH	BX
 28568 000050AD BB[310B]                	MOV	BX,FILE_UCASE_TAB+2
 28569                                  
 28570                                  ; Convert the character in AL to upper case
 28571                                  
 28572                                  gl_0:
 28573 000050B0 3C61                    	CMP	AL,"a"
 28574 000050B2 7214                    	JB	short gl_2	; Already upper case, go check type
 28575 000050B4 3C7A                    	CMP	AL,"z"
 28576 000050B6 7702                    	JA	short gl_1
 28577 000050B8 2C20                    	SUB	AL,20H		; Convert to upper case
 28578                                  
 28579                                  ; Map European character to upper case
 28580                                  
 28581                                  gl_1:
 28582 000050BA 3C80                    	CMP	AL,80H
 28583 000050BC 720A                    	JB	short gl_2	; Not EuroChar, go check type
 28584 000050BE 2C80                    	SUB	AL,80H		; translate to upper case with this index
 28585                                  
 28586                                  	; M048 - Start 
 28587                                  	; Lantastic call Ucase thru int 2f without setting SS to DOSDATA.
 28588                                  	; So we shall set up DS and to access FILE_UCASE_TAB in BX and also 
 28589                                  	; preserve it.
 28590                                  
 28591                                  	; 09/08/2018 - Retro DOS v3.0
 28592                                  	; MSDOS 3.3
 28593                                  	;;XLAT	BYTE [CS:BX]	; ds as file_ucase_tab is in DOSDATA
 28594                                  	;CS	XLAT
 28595                                  
 28596                                  	; 20/05/2019 - Retro DOS v4.0
 28597                                  
 28598                                  	; MSDOS 6.0
 28599 000050C0 1E                      	push	ds
 28600                                  	;getdseg <ds>
 28601 000050C1 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 28602 000050C6 D7                      	XLAT			; ds as file_ucase_tab is in DOSDATA
 28603 000050C7 1F                      	pop	ds
 28604                                  
 28605                                  	; M048 - End
 28606                                  
 28607                                  ; Now check the type
 28608                                  
 28609                                  ;If TableLook
 28610                                  gl_2:
 28611                                  	; 20/05/2019 - Retro DOS v4.0
 28612 000050C8 50                      	PUSH	AX
 28613                                  
 28614                                  	; MSDOS 3.3
 28615                                  	;mov	bx,CharType
 28616                                  	;; 09/08/2018
 28617                                  	;;xlat	byte [cs:bx]
 28618                                  	;cs	xlat	
 28619                                  	
 28620                                  	; MSDOS 6.0
 28621 000050C9 E81800                  	CALL	GetCharType	; returns type flags in AL
 28622                                  	
 28623                                  	;test	al,1	
 28624 000050CC A801                    	TEST	AL,FCHK 	; test for normal character
 28625 000050CE 58                      	POP	AX
 28626                                  
 28627 000050CF 5B                      	POP	BX
 28628 000050D0 C3                      	RETN
 28629                                  
 28630                                  ; This entry has character in AL and lookup table in BX
 28631                                  
 28632                                  	; MSDOS 6.0
 28633                                  ;	;entry GetLet3
 28634                                  GETLET3: ; 10/08/2018
 28635 000050D1 53                      	PUSH	BX
 28636 000050D2 EBDC                    	JMP	short gl_0
 28637                                  ;ELSE
 28638                                  ;
 28639                                  ;gl_2:
 28640                                  ;	POP	BX
 28641                                  ;	CMP	AL,"."
 28642                                  ;	retz
 28643                                  ;	CMP	AL,'"'
 28644                                  ;	retz
 28645                                  ;	CALL	PATHCHRCMP
 28646                                  ;	retz
 28647                                  ;	CMP	AL,"["
 28648                                  ;	retz
 28649                                  ;	CMP	AL,"]"
 28650                                  ;	retz
 28651                                  ;ENDIF
 28652                                  
 28653                                  ;---------------------------------------------------------------------
 28654                                  ;
 28655                                  ; DELIM - check if character is a delimiter
 28656                                  ;	Entry : AX = character to check
 28657                                  ;	Exit  : ZF set if character is not a delimiter
 28658                                  ;	Uses  : Flags
 28659                                  ;
 28660                                  ;--------------------------------------------------------------------
 28661                                  
 28662                                  	;entry	DELIM
 28663                                  DELIM:
 28664                                  ;IF TableLook
 28665                                  	; 20/05/2019 - Retro DOS v4.0
 28666 000050D4 50                      	PUSH	AX
 28667                                  
 28668                                  	; MSDOS 3.3
 28669                                  	;push	bx
 28670                                  	;mov	bx,CharType
 28671                                  	;;09/08/2018
 28672                                  	;;xlat	byte [cs:bx]
 28673                                  	;cs	xlat
 28674                                  	;pop	bx
 28675                                  
 28676                                  	; MSDOS 6.0
 28677 000050D5 E80C00                  	CALL	GetCharType
 28678                                  	
 28679                                  	;test	al,2
 28680 000050D8 A802                    	TEST	AL,FDELIM
 28681 000050DA 58                      	POP	AX
 28682 000050DB C3                      	RETN
 28683                                  ;ELSE
 28684                                  ;	CMP	AL,":"
 28685                                  ;	retz
 28686                                  ;
 28687                                  ;	CMP	AL,"<"
 28688                                  ;	retz
 28689                                  ;	CMP	AL,"|"
 28690                                  ;	retz
 28691                                  ;	CMP	AL,">"
 28692                                  ;	retz
 28693                                  ;
 28694                                  ;	CMP	AL,"+"
 28695                                  ;	retz
 28696                                  ;	CMP	AL,"="
 28697                                  ;	retz
 28698                                  ;	CMP	AL,";"
 28699                                  ;	retz
 28700                                  ;	CMP	AL,","
 28701                                  ;	retz
 28702                                  ;ENDIF
 28703                                  
 28704                                  ;-------------------------------------------------------------------------
 28705                                  ;
 28706                                  ;  SPCHK - checks to see if a character is a space or equivalent
 28707                                  ;	Entry : AL = character to check
 28708                                  ;	Exit  : ZF set if character is a space
 28709                                  ;	Uses  : flags
 28710                                  ;
 28711                                  ;-------------------------------------------------------------------------
 28712                                  
 28713                                  	;entry SPCHK
 28714                                  SPCHK:
 28715                                  ;IF TableLook
 28716                                  	; 20/05/2019 - Retro DOS v4.0
 28717 000050DC 50                      	PUSH	AX
 28718                                  
 28719                                  	; MSDOS 3.3
 28720                                  	;push	bx
 28721                                  	;mov	bx,CharType
 28722                                  	;; 09/08/2018
 28723                                  	;;xlat	byte [cs:bx]
 28724                                  	;cs	xlat
 28725                                  	;pop	bx
 28726                                  
 28727                                  	; MSDOS 6.0
 28728 000050DD E80400                  	CALL	GetCharType
 28729                                  	
 28730                                  	;test	al,4
 28731 000050E0 A804                    	TEST	AL,FSPCHK
 28732 000050E2 58                      	POP	AX
 28733 000050E3 C3                      	RETN
 28734                                  ;ELSE
 28735                                  ;	CMP	AL,9		; Filter out tabs too
 28736                                  ;	retz
 28737                                  ;; WARNING! " " MUST be the last compare
 28738                                  ;	CMP	AL," "
 28739                                  ;	return
 28740                                  ;ENDIF
 28741                                  
 28742                                  ;-------------------------------------------------------------------------
 28743                                  ;
 28744                                  ;  GetCharType - return flag bits indicating character type
 28745                                  ;	Bits are defined in DOSSYM.INC. Uses lookup table
 28746                                  ;	defined above at label CharType.
 28747                                  ;
 28748                                  ;	Entry : AL = character to return type flags for
 28749                                  ;	Exit  : AL = type flags
 28750                                  ;	Uses  : AL, flags
 28751                                  ;
 28752                                  ;-------------------------------------------------------------------------
 28753                                  
 28754                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 28755                                  
 28756                                  	; 20/05/2019 - Retro DOS v4.0
 28757                                  	; MSDOS 6.0
 28758                                  GetCharType:
 28759                                  	;cmp	al,7Eh
 28760 000050E4 3C7E                    	cmp	al,CharType_last 	; beyond end of table?
 28761 000050E6 7316                    	jae	short gct_90		; return standard value
 28762                                  
 28763 000050E8 53                      	push	bx
 28764 000050E9 BB[6C50]                	mov	bx,CharType		; load lookup table
 28765 000050EC D0E8                    	shr	al,1			; adjust for half-byte table entry size
 28766                                  	;xlat	cs:[bx] 		; get flags
 28767 000050EE 2ED7                    	cs	xlat	
 28768 000050F0 5B                      	pop	bx
 28769                                  
 28770                                  ; carry clear from previous shift means we want the low nibble.  Otherwise
 28771                                  ; we have to shift the flags down to the low nibble
 28772                                  
 28773 000050F1 7308                    	jnc	short gct_80		; carry clear, no shift needed
 28774                                  
 28775 000050F3 D0E8                    	shr	al,1			; we want high nibble, shift it down
 28776 000050F5 D0E8                    	shr	al,1
 28777 000050F7 D0E8                    	shr	al,1
 28778 000050F9 D0E8                    	shr	al,1
 28779                                  gct_80:
 28780 000050FB 240F                    	and	al,0Fh			; clear the unused nibble
 28781 000050FD C3                      	retn
 28782                                  gct_90:
 28783 000050FE B00F                    	mov	al,0Fh			; set all flags
 28784 00005100 C3                      	retn
 28785                                  
 28786                                  ;----------------------------------------------------------------------------
 28787                                  ;
 28788                                  ; Procedure : PATHCHRCMP
 28789                                  ;
 28790                                  ;----------------------------------------------------------------------------
 28791                                  
 28792                                  PATHCHRCMP:
 28793 00005101 3C2F                    	CMP	AL,'/'
 28794 00005103 7606                    	JBE	short PathRet
 28795 00005105 3C5C                    	CMP	AL,'\'
 28796 00005107 C3                      	retn
 28797                                  GotFor:
 28798 00005108 B05C                    	MOV	AL,'\'
 28799 0000510A C3                      	retn
 28800                                  PathRet:
 28801 0000510B 74FB                    	JZ	short GotFor
 28802 0000510D C3                      	retn
 28803                                  
 28804                                  ;============================================================================
 28805                                  ; MSCRTLC.ASM, MSDOS 6.0, 1991
 28806                                  ;============================================================================
 28807                                  ; 30/07/2018 - Retro DOS v3.0
 28808                                  ; 29/04/2019 - Retro DOS v4.0
 28809                                  
 28810                                  ; 15/03/2018 - Retro DOS v2.0 (MSDOS 2.11, CTRLC.ASM, 1983)
 28811                                  
 28812                                  ;**	MSCTRLC.ASM - ^C and error handler for MSDOS
 28813                                  
 28814                                  ;	TITLE	Control C detection, Hard error and EXIT routines
 28815                                  ;	NAME	IBMCTRLC
 28816                                  
 28817                                  ;**	Low level routines for detecting special characters on CON input,
 28818                                  ;	the ^C exit/int code, the Hard error INT 24 code, the
 28819                                  ;	process termination code, and the INT 0 divide overflow handler.
 28820                                  ;
 28821                                  ;	FATAL
 28822                                  ;	FATAL1
 28823                                  ;	reset_environment
 28824                                  ;	DSKSTATCHK
 28825                                  ;	SPOOLINT
 28826                                  ;	STATCHK
 28827                                  ;	CNTCHAND
 28828                                  ;	DIVOV
 28829                                  ;	CHARHARD
 28830                                  ;	HardErr
 28831                                  ;
 28832                                  ;	Revision history:
 28833                                  ;
 28834                                  ;	    AN000	version 4.0   Jan 1988
 28835                                  ;	    A002	PTM    -- dir >lpt3 hangs
 28836                                  ;	    A003	PTM 3957- fake version for IBMCAHE.COM
 28837                                  ;
 28838                                  ; 	M011: NEC's 8086 clone chip uses Intel's undocumented bit number in
 28839                                  ;	      flags register. In order to return to user normally DOS used to
 28840                                  ;	      move F202 into flags, which sets bit number 1 in flags uncondit-
 28841                                  ;	      ionally. Now it is modified to maintain the state of bit 1.
 28842                                  ;
 28843                                  ; 	M024: suppressed fail and ignore options if not in the middle of int 
 28844                                  ;	      24 and if Ctrl P or ctrl printscrn is pressed in routine 
 28845                                  ;	      charhard.
 28846                                  
 28847                                  ; 29/04/2019 - Retro DOS v4.0
 28848                                  	; MSDOS 6.0
 28849                                  ;		public	LowInt23Addr		
 28850                                  LowInt23Addr: ;	LABEL	DWORD
 28851 0000510E [CD10]0000              	DW	LowInt23, 0
 28852                                  
 28853                                  ;		public	LowInt24Addr
 28854                                  LowInt24Addr: ;	LABEL	DWORD
 28855 00005112 [E110]0000              	DW	LowInt24, 0
 28856                                  
 28857                                  ;		public	LowInt28Addr
 28858                                  LowInt28Addr: ;	LABEL	DWORD
 28859 00005116 [F510]0000              	DW	LowInt28, 0
 28860                                  
 28861                                  ;Break	<Checks for ^C in CON I/O>
 28862                                  
 28863                                  ; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 28864                                  ; 05/05/2019 - Retro DOS v4.0
 28865                                  
 28866                                  ;---------------------------------------------------------------------------
 28867                                  ;
 28868                                  ; Procedure Name : DSKSTATCHK
 28869                                  ;
 28870                                  ; Check for ^C if only one level in
 28871                                  ;
 28872                                  ;---------------------------------------------------------------------------
 28873                                  
 28874                                          ;procedure DSKSTATCHK,NEAR ; Check for ^C if only one level in
 28875                                  
 28876                                  DSKSTATCHK:        
 28877                                  	;CMP	BYTE [INDOS],1
 28878 0000511A 36803E[2103]01                  CMP     BYTE [SS:INDOS],1 ; 15/03/2018
 28879                                  	;retnz			; Do NOTHING
 28880                                  	; 16/12/2022
 28881 00005120 7534                    	JNZ	SHORT _RET37 ; Retro DOS v2.0 - 04/03/2018         
 28882                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 28883                                  	;jz	short _RET37 ; dskstatchk1
 28884                                  	;retn
 28885                                  ;_RET37:
 28886                                  ;dskstatchk1:
 28887 00005122 51                      	PUSH    CX
 28888 00005123 06                              PUSH    ES
 28889 00005124 53                              PUSH    BX
 28890 00005125 1E                              PUSH    DS
 28891 00005126 56                              PUSH    SI
 28892                                          
 28893                                  	;PUSH	CS
 28894                                          ;POP	ES
 28895                                          ;PUSH	CS
 28896                                          ;POP	DS
 28897                                  
 28898 00005127 8CD3                    	MOV	BX,SS		; SS is DOSDATA. ES:BX must be set up
 28899 00005129 8EC3                    	MOV	ES,BX		; for deviocall2
 28900 0000512B 8EDB                    	MOV	DS,BX
 28901                                  
 28902                                  	; 16/12/2022
 28903                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 28904                                  
 28905                                  	; 05/05/2019
 28906                                  	;MOV	BYTE [ss:DSKSTCOM],DEVRDND
 28907                                          ;MOV	BYTE [ss:DSKSTCALL],DRDNDHL
 28908                                  	;mov	word [ss:DSKSTST],0
 28909                                  
 28910                                  	; 16/12/2022
 28911                                  	; 25/06/2019
 28912 0000512D C606[9403]05            	MOV	BYTE [DSKSTCOM],DEVRDND	 ; 5
 28913 00005132 C606[9203]0E                    MOV	BYTE [DSKSTCALL],DRDNDHL ; 14
 28914 00005137 C706[9503]0000          	mov	word [DSKSTST],0
 28915                                  
 28916 0000513D BB[9203]                        MOV     BX,DSKSTCALL
 28917                                  
 28918                                  	;LDS	SI,[ss:BCON]
 28919                                          ; 25/062019
 28920 00005140 C536[3200]              	lds	si,[BCON]
 28921                                  
 28922                                  ; 16/12/2022
 28923                                  ;	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 28924                                  ;	mov	byte [ss:DSKSTCOM],DEVRDND  ; 5
 28925                                  ;       mov	byte [ss:DSKSTCALL],DRDNDHL ; 14
 28926                                  ;	mov	word [ss:DSKSTST],0
 28927                                  ;	mov	bx,DSKSTCALL
 28928                                  ;	lds	si,[ss:BCON]
 28929                                  
 28930 00005144 E890F5                  	CALL	DEVIOCALL2
 28931                                   	; 15/03/2018
 28932                                  	;;test	word [ss:DSKSTST],200h
 28933                                          ;TEST	WORD [SS:DSKSTST],STBUI
 28934                                  	; 05/05/2019
 28935 00005147 36F606[9603]02          	test	byte [ss:DSKSTST+1],(STBUI>>8) ; 2
 28936 0000514D 7408                    	jz	short _GotCh		; No characters available
 28937                                  
 28938 0000514F 30C0                            XOR     AL,AL                   ; Set zero
 28939                                  RET36:
 28940 00005151 5E                              POP     SI
 28941 00005152 1F                              POP     DS
 28942 00005153 5B                              POP     BX
 28943 00005154 07                              POP     ES
 28944 00005155 59                              POP     CX
 28945                                  	; 16/12/2022
 28946                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 28947                                  _RET37:
 28948 00005156 C3                              RETN
 28949                                  
 28950                                  _GotCh:
 28951 00005157 36A0[9F03]                      MOV     AL,[SS:DSKCHRET]	; SS override
 28952                                  
 28953 0000515B 3C03                            CMP     AL,"C"-"@" ; cmp al,3
 28954 0000515D 75F2                            JNZ     SHORT RET36
 28955 0000515F 36C606[9403]04                  MOV     BYTE [SS:DSKSTCOM],DEVRD
 28956 00005165 36C606[9203]16                  MOV     BYTE [SS:DSKSTCALL],DRDWRHL
 28957 0000516B 36880E[9F03]                    MOV     [SS:DSKCHRET],CL
 28958                                  	; 09/09/2018
 28959 00005170 36C706[9503]0000        	MOV	word [SS:DSKSTST],0
 28960 00005177 36C706[A403]0100        	MOV	word [SS:DSKSTCNT],1
 28961 0000517E E856F5                  	CALL	DEVIOCALL2              ; Eat the ^C
 28962 00005181 5E                              POP     SI
 28963 00005182 1F                              POP     DS
 28964 00005183 5B                              POP     BX                      ; Clean stack
 28965 00005184 07                              POP     ES
 28966 00005185 59                              POP     CX
 28967 00005186 E9CF00                          JMP	CNTCHAND ; 10/08/2018
 28968                                  
 28969                                  	; 05/05/2019
 28970                                  NOSTOP:
 28971                                  	; MSDOS 6.0
 28972 00005189 3C10                    	CMP	AL,"P"-"@"
 28973 0000518B 7509                    	JNZ	short check_next
 28974                                  				    	; SS override
 28975 0000518D 36803E[900D]00          	CMP	BYTE [SS:SCAN_FLAG],0	; ALT_Q ?
 28976 00005193 7405                    	JZ	short INCHKJ		; no
 28977                                  check_end:	; 24/09/2023
 28978 00005195 C3                      	retn
 28979                                  check_next:
 28980                                  	;IF	NOT TOGLPRN
 28981                                  	;CMP	AL,"N"-"@"
 28982                                  	;JZ	short INCHKJ
 28983                                  	;ENDIF
 28984                                  
 28985 00005196 3C03                    	CMP	AL,"C"-"@"
 28986                                  	; 24/09/2023
 28987                                  	;JZ	short INCHKJ
 28988                                  ;check_end:
 28989                                  	;retn
 28990 00005198 75FB                    	jnz	short check_end
 28991                                  
 28992                                  	; 24/09/2023
 28993                                  	; 08/09/2018
 28994                                  INCHKJ:	; 10/08/2018
 28995 0000519A E9A500                  	jmp	INCHK
 28996                                  
 28997                                  	; MSDOS 3.3
 28998                                          ;CMP     AL,"P"-"@"  ; cmp al,16
 28999                                          ;JZ	short INCHKJ
 29000                                  
 29001                                  	; 15/04/2018
 29002                                          ;;IF	NOT TOGLPRN
 29003                                          ;CMP	AL,"N"-"@"
 29004                                          ;JZ	SHORT INCHKJ
 29005                                          ;;ENDIF
 29006                                  	
 29007                                  	;CMP     AL,"C"-"@"  ; cmp al,3
 29008                                          ;JZ	short INCHKJ
 29009                                  	;RETN
 29010                                  
 29011                                  ;	; 08/09/2018
 29012                                  ;INCHKJ:; 10/08/2018
 29013                                  ;	JMP	INCHK
 29014                                  
 29015                                  ;----------------------------------------------------------------------------
 29016                                  ;
 29017                                  ; Procedure Name : SpoolInt
 29018                                  ;
 29019                                  ; SpoolInt - signal processes that the DOS is truly idle. We are allowed to
 29020                                  ; do this ONLY if we are working on a 1-12 system call AND if we are not in
 29021                                  ; the middle of an INT 24.
 29022                                  ;
 29023                                  ;----------------------------------------------------------------------------
 29024                                  
 29025                                  SPOOLINT:
 29026 0000519D 9C                              PUSHF
 29027                                  	; 15/03/2018
 29028 0000519E 36803E[5803]00                  CMP     BYTE [SS:IDLEINT],0	; SS override
 29029 000051A4 7423                            JZ      SHORT POPFRET
 29030 000051A6 36803E[2003]00                  CMP     BYTE [SS:ERRORMODE],0
 29031 000051AC 751B                            JNZ     SHORT POPFRET		;No spool ints in error mode
 29032                                  
 29033                                  	; 30/07/2018
 29034                                  
 29035                                  	; Note that we are going to allow an external program to issue system 
 29036                                  	; calls at this time. We MUST preserve IdleInt across this.
 29037                                  
 29038 000051AE 36FF36[5803]            	PUSH	WORD [SS:IDLEINT]
 29039                                  
 29040                                  	; 05/05/2019 - Retro DOS v4.0
 29041                                   
 29042                                  	; MSDOS 6.0
 29043 000051B3 36803E[F211]00          	cmp	byte [SS:DosHasHMA],0	; Q: is dos running in HMA (M021)
 29044 000051B9 7504                    	jne	short do_low_int28	; Y: the int must be done from low mem
 29045 000051BB CD28                    	INT	int_spooler  ; int 28h 	; N: Execute user int 28 handler
 29046 000051BD EB05                    	jmp	short spool_ret_addr
 29047                                  
 29048                                  do_low_int28:
 29049                                  	;call	far [ss:LowInt28Addr]
 29050 000051BF 2EFF1E[1651]            	call	far [cs:LowInt28Addr]	; 05/05/2019
 29051                                  
 29052                                  spool_ret_addr:
 29053                                  	;INT	int_spooler		; INT 28h
 29054                                  
 29055 000051C4 368F06[5803]            	POP	WORD [SS:IDLEINT]
 29056                                  POPFRET:
 29057 000051C9 9D                              POPF
 29058                                  _RET18:  
 29059 000051CA C3                      	RETN
 29060                                  
 29061                                  ; 05/05/2019 - Retro DOS v4.0
 29062                                  ; DOSCODE:9137h (MSDOS 6.21, MSDOS.SYS)
 29063                                  ; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 29064                                  ; DOSCODE:90DBh (MSDOS 5.0, MSDOS.SYS)
 29065                                  
 29066                                  ;----------------------------------------------------------------------------
 29067                                  ;
 29068                                  ; Procedure Name : STATCHK
 29069                                  ;
 29070                                  ;----------------------------------------------------------------------------
 29071                                  
 29072                                  STATCHK:
 29073 000051CB E84CFF                          CALL	DSKSTATCHK              ; Allows ^C to be detected under
 29074                                                                          ; input redirection
 29075 000051CE 53                              PUSH    BX
 29076 000051CF 31DB                            XOR     BX,BX
 29077 000051D1 E8E9E4                          CALL	GET_IO_SFT
 29078 000051D4 5B                              POP     BX
 29079 000051D5 72F3                            JC      SHORT _RET18
 29080                                  
 29081 000051D7 B401                            MOV     AH,1
 29082 000051D9 E826F3                          CALL	IOFUNC
 29083 000051DC 74BF                            JZ      SHORT SPOOLINT
 29084 000051DE 3C13                            CMP     AL,'S'-'@'
 29085 000051E0 75A7                            JNZ     SHORT NOSTOP
 29086                                  
 29087                                  	; 05/05/2019
 29088                                  	; MSDOS 6.0			; SS override
 29089 000051E2 36803E[900D]00          	CMP	BYTE [SS:SCAN_FLAG],0	; AN000; ALT_R ?
 29090 000051E8 75AB                    	JNZ	short check_end		; AN000; yes
 29091                                  
 29092 000051EA 30E4                            XOR     AH,AH
 29093 000051EC E813F3                          CALL	IOFUNC                  ; Eat Cntrl-S
 29094 000051EF EB4A                            JMP     SHORT PAUSOSTRT
 29095                                  PRINTOFF:
 29096                                  PRINTON:
 29097 000051F1 36F616[FE02]            	NOT	BYTE [SS:PFLAG] ; 14/03/2018
 29098                                  
 29099                                  	; 30/07/2018 - Retro DOS v3.0
 29100 000051F6 53                      	PUSH	BX
 29101 000051F7 BB0400                  	MOV	BX,4
 29102 000051FA E8C0E4                  	call	GET_IO_SFT
 29103 000051FD 5B                      	POP	BX
 29104 000051FE 72CA                    	jc	short _RET18
 29105 00005200 06                      	PUSH	ES
 29106 00005201 57                      	PUSH	DI
 29107 00005202 1E                      	PUSH	DS
 29108 00005203 07                      	POP	ES
 29109 00005204 89F7                    	MOV	DI,SI			; ES:DI -> SFT
 29110                                  	;test	word [es:di+5],800h
 29111                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_net_spool
 29112                                  	; 05/05/2019
 29113 00005206 26F6450608              	test	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_net_spool>>8)
 29114 0000520B 7418                    	JZ	short NORM_PR 		; Not redirected, echo is OK
 29115                                  
 29116                                  	;Callinstall NetSpoolEchoCheck,MultNet,38,<AX>,<AX> 
 29117                                  					; See if allowed
 29118 0000520D 50                      	push	ax
 29119 0000520E B82611                  	mov	ax,1126h
 29120 00005211 CD2F                    	int	2Fh	; Multiplex - NETWORK REDIRECTOR - ???
 29121                                  			; Return: CF set on error, AX = error code
 29122                                  			; STACK unchanged
 29123 00005213 58                      	pop	ax
 29124                                  
 29125 00005214 730F                    	JNC	short NORM_PR 		; Echo is OK
 29126                                  
 29127                                  					; SS override
 29128 00005216 36C606[FE02]00          	MOV	BYTE [SS:PFLAG],0	; If not allowed, disable echo
 29129                                  
 29130                                  	;Callinstall NetSpoolClose,MultNet,36,<AX>,<AX> ; and close
 29131                                  
 29132 0000521C 50                      	push    ax
 29133 0000521D B82411                  	mov     ax,1124h
 29134 00005220 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - ???
 29135                                  			; ES:DI -> SFT, SS = DOS CS
 29136 00005222 58                      	pop     ax
 29137                                  
 29138 00005223 EB10                    	JMP	SHORT RETP6
 29139                                  NORM_PR:
 29140 00005225 36803E[FE02]00          	CMP	BYTE [SS:PFLAG],0	; SS override
 29141 0000522B 7505                    	JNZ	short PRNOPN
 29142 0000522D E82BF4                  	call	DEV_CLOSE_SFT
 29143 00005230 EB03                    	JMP	SHORT RETP6
 29144                                  PRNOPN:
 29145 00005232 E81EF4                  	call	DEV_OPEN_SFT
 29146                                  RETP6:
 29147 00005235 5F                      	POP	DI
 29148 00005236 07                      	POP	ES
 29149                                  STATCHK_RETN:
 29150 00005237 C3                              RETN
 29151                                  PAUSOLP:
 29152 00005238 E862FF                          CALL    SPOOLINT
 29153                                  PAUSOSTRT:
 29154 0000523B B401                            MOV     AH,1
 29155 0000523D E8C2F2                          CALL	IOFUNC
 29156 00005240 74F6                            JZ      SHORT PAUSOLP
 29157                                  INCHK:
 29158 00005242 53                              PUSH    BX
 29159 00005243 31DB                            XOR     BX,BX
 29160 00005245 E875E4                          CALL	GET_IO_SFT
 29161 00005248 5B                              POP     BX
 29162 00005249 72EC                            JC      SHORT STATCHK_RETN ; 30/07/2018
 29163 0000524B 30E4                            XOR     AH,AH
 29164 0000524D E8B2F2                          CALL	IOFUNC
 29165                                  	; 30/07/2018
 29166                                  	; MSDOS 3.3
 29167                                          ;CMP	AL,'P'-'@' ;cmp al,16
 29168                                          ;JNZ	SHORT NOPRINT
 29169                                  
 29170                                  	;cmp	byte [SS:SCAN_FLAG],0
 29171                                  	;JZ	SHORT PRINTON	
 29172                                  	;mov	byte [ss:SCAN_FLAG],0
 29173                                  
 29174                                  	; 05/05/2019
 29175                                  	; MSDOS 6.0
 29176 00005250 3C10                    	CMP	AL,"P"-"@"
 29177                                  	;;;;  7/14/86	ALT_Q key fix
 29178 00005252 749D                    	JZ	short PRINTON		; no! must be CTRL_P
 29179                                  ;NOPRINT:	
 29180                                  	;IF	NOT TOGLPRN
 29181                                  	;CMP	AL,"N"-"@"
 29182                                  	;JZ	short PRINTOFF
 29183                                  	;ENDIF
 29184 00005254 3C03                    	CMP	AL,"C"-"@" ; cmp al,3 
 29185                                  	;retnz
 29186 00005256 75DF                    	jnz	short STATCHK_RETN
 29187                                  
 29188                                  	; !! NOTE: FALL THROUGH !!
 29189                                  
 29190                                  ;---------------------------------------------------------------------------
 29191                                  ;
 29192                                  ; Procedure Name : CNTHAND ( CTRLC_C HANDLER )
 29193                                  ;
 29194                                  ; "^C" and CR/LF is printed. Then the user registers are restored and the
 29195                                  ; user CTRL-C handler is executed. At this point the top of the stack has 1)
 29196                                  ; the interrupt return address should the user CTRL-C handler wish to allow
 29197                                  ; processing to continue; 2) the original interrupt return address to the code
 29198                                  ; that performed the function call in the first place. If the user CTRL-C
 29199                                  ; handler wishes to continue, it must leave all registers unchanged and RET
 29200                                  ; (not IRET) with carry CLEAR. If carry is SET then an terminate system call
 29201                                  ; is simulated.
 29202                                  ;
 29203                                  ;---------------------------------------------------------------------------
 29204                                  
 29205                                  CNTCHAND:
 29206                                  	; MSDOS 6.0			; SS override
 29207                                  					; AN002; from RAWOUT
 29208                                  	;TEST	word [SS:DOS34_FLAG],CTRL_BREAK_FLAG  
 29209                                  	;JNZ	short around_deadlock 	; AN002;
 29210                                  
 29211                                  	; 05/05/2019 - Retro DOS v4.0
 29212                                  	; (MSDOS 6.21 MSDOS.SYS DOSCODE:91C4h, 29/12/2022)
 29213 00005258 36F606[1206]02          	TEST	byte [SS:DOS34_FLAG+1],(CTRL_BREAK_FLAG>>8)  ; 2 
 29214 0000525E 7508                    	JNZ	short around_deadlock 	; AN002;
 29215                                  
 29216 00005260 B003                            MOV     AL,3			; Display "^C"
 29217 00005262 E8E2C4                          CALL	BUFOUT
 29218 00005265 E87EC3                          CALL	CRLF
 29219                                  around_deadlock:
 29220 00005268 16                              PUSH    SS
 29221 00005269 1F                              POP     DS
 29222 0000526A 803E[5703]00                    CMP     BYTE [CONSWAP],0
 29223 0000526F 7403                            JZ      SHORT NOSWAP
 29224 00005271 E8B3E0                          CALL	SWAPBACK
 29225                                  NOSWAP:
 29226 00005274 FA                      	CLI				; Prepare to play with stack
 29227 00005275 8E16[8605]              	MOV	SS,[USER_SS]		; User stack now restored
 29228 00005279 8B26[8405]              	MOV	SP,[USER_SP]
 29229 0000527D E8DAB1                          CALL	restore_world       ; User registers now restored
 29230                                  
 29231                                  	; 30/07/2018 - Retro DOS v3.0 
 29232                                  	; MSDOS 3.3 (IBMDOS.COM - Offset 56ACh)
 29233                                          ; 14/03/2018 - Retro DOS v2.0
 29234                                  	;MOV	BYTE [CS:INDOS],0	
 29235                                          ;MOV	BYTE [CS:ERRORMODE],0
 29236                                          ;MOV	[CS:ConC_Spsave],SP
 29237                                  	;clc	;30/07/2018
 29238                                          ;INT	int_ctrl_c ; 23h    ; Execute user Ctrl-C handler
 29239                                  	;;int	23h	; DOS - CONTROL "C" EXIT ADDRESS
 29240                                  			; Return: return via RETF 2 with CF set
 29241                                  			; DOS will abort program with errorlevel 0
 29242                                  			; else
 29243                                  			; interrupted DOS call continues
 29244                                  
 29245                                  	; 05/05/2019 - Retro DOS v4.0
 29246                                  	; MSDOS 6.0 (MSDOS 6.21, MSDOS.SYS,91ECh) 
 29247                                  
 29248                                  	; CS was used to address these variables. We have to use DOSDATA
 29249                                  	
 29250 00005280 07                      	pop	es ; *	; MSDOS 6.21 (MSDOS.SYS, DOSCODE:91ECh)
 29251                                  			; (pop es, after 'call restore_world')	
 29252 00005281 1E                      	push	ds
 29253                                  	;getdseg <ds>			; ds -> dosdata
 29254 00005282 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 29255 00005287 C606[2103]00            	mov	byte [INDOS],0		; Go to known state
 29256 0000528C C606[2003]00            	mov	byte [ERRORMODE],0
 29257 00005291 8926[3203]              	mov	[ConC_Spsave],SP	; save his SP
 29258                                  	; User SP has changed because of push. Adjust for it
 29259 00005295 8306[3203]02            	add	word [ConC_Spsave],2
 29260                                  
 29261 0000529A 803E[F211]00            	cmp	byte [DosHasHMA],0	; Q: is dos running in HMA (M021)
 29262 0000529F 1F                       	pop	ds	; restore ds
 29263 000052A0 7505                    	jne	short do_low_int23	; Y: the int must be done from low mem
 29264 000052A2 F8                      	CLC				
 29265 000052A3 CD23                    	INT	int_ctrl_c  ; int 23h	; N: Execute user Ctrl-C handler
 29266 000052A5 EB06                    	jmp	short ctrlc_ret_addr
 29267                                  
 29268                                  	; 05/05/2019
 29269                                  do_low_int23:
 29270 000052A7 F8                      	clc
 29271 000052A8 2EFF1E[0E51]            	call	far [cs:LowInt23Addr]	
 29272                                  
 29273                                  	; 30/07/2018 
 29274                                  
 29275                                  	; MSDOS 3.3 (IBMDOS.COM - Offset 56C0h)
 29276                                  
 29277                                  ; The user has returned to us. The circumstances we allow are:
 29278                                  ;
 29279                                  ;   IRET	We retry the operation by redispatching the system call
 29280                                  ;   CLC/RETF	POP the stack and retry
 29281                                  ;   ... 	Exit the current process with ^C exit
 29282                                  ;
 29283                                  ; User's may RETURN to us and leave interrupts on. 
 29284                                  ; Turn 'em off just to be sure
 29285                                  
 29286                                  ctrlc_ret_addr: ; 05/05/2019
 29287                                  
 29288 000052AD FA                      	CLI
 29289                                  
 29290                                  	; MSDOS 3.3 
 29291                                  	;MOV	[CS:USER_IN_AX],ax	; save the AX
 29292                                  	;PUSHF				; and the flags (maybe new call)
 29293                                  	;POP	AX
 29294                                  
 29295                                  	; 05/05/2019
 29296                                  	; MSDOS 6.0
 29297                                  
 29298                                  	; We have to use DOSDATA for these variables. Previously CS was used 
 29299                                  
 29300 000052AE 50                      	push	ax
 29301 000052AF 8CD8                    	mov	ax,ds
 29302                                  	;getdseg <ds>			; ds -> dosdata
 29303 000052B1 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 29304 000052B6 A3[0A0D]                	mov	[TEMPSEG],ax
 29305 000052B9 58                      	pop	ax
 29306 000052BA A3[3A03]                	MOV	[USER_IN_AX],ax		; save the AX
 29307 000052BD 9C                      	pushf				; and the flags (maybe new call)
 29308 000052BE 58                      	pop	ax
 29309                                  
 29310                                  ; See if the input stack is identical to the output stack
 29311                                  
 29312                                  	; MSDOS 3.3
 29313                                  	;CMP	SP,[CS:ConC_Spsave]
 29314                                  	;JNZ     SHORT ctrlc_try_new ; current SP not the same as saved SP
 29315                                  
 29316                                  	; MSDOS 6.0
 29317 000052BF 3B26[3203]              	CMP	SP,[ConC_Spsave]
 29318 000052C3 750A                    	JNZ     SHORT ctrlc_try_new ; current SP not the same as saved SP
 29319                                  
 29320                                  ; Repeat the operation by redispatching the system call.
 29321                                  
 29322                                  ctrlc_repeat:
 29323                                  	; MSDOS 3.3
 29324                                  	;MOV	AX,[CS:USER_IN_AX]
 29325                                  	; 05/05/2019
 29326                                  	; MSDOS 6.0
 29327 000052C5 A1[3A03]                	mov	ax,[USER_IN_AX]
 29328 000052C8 8E1E[0A0D]              	mov	ds,[TEMPSEG]		; restore ds and original sp
 29329                                  	; MSDOS 3.3 & MSDOS 6.0 
 29330                                  	;transfer COMMAND
 29331                                  COMMANDJ:
 29332 000052CC E93EB0                  	JMP	COMMAND
 29333                                  
 29334                                  ; The current SP is NOT the same as the input SP. Presume that he 
 29335                                  ; RETF'd leaving some flags on the stack and examine the input
 29336                                  
 29337                                  ctrlc_try_new:
 29338 000052CF 83C402                  	ADD	SP,2			; pop those flags
 29339                                  	;;test	ax,1
 29340                                  	;TEST	AX,f_Carry		; did he return with carry?
 29341 000052D2 A801                    	test	al,f_Carry ; test al,1
 29342 000052D4 74EF                    	JZ	short ctrlc_repeat	; no carry set, just retry
 29343                                  
 29344                                  	; MSDOS 6.0
 29345 000052D6 8E1E[0A0D]              	mov	ds,[TEMPSEG]		; restore ds
 29346                                  
 29347                                  	; Well...  time to abort the user.  
 29348                                  	; Signal a ^C exit and use the EXIT system call..
 29349                                  
 29350                                  ctrlc_abort:
 29351                                  	; MSDOS 3.3
 29352                                          ;;MOV	AX,(EXIT SHL 8) + 0
 29353                                          ;MOV	AX, (EXIT*256) + 0  ; 4C00h
 29354                                  	;mov	byte [CS:DidCTRLC],0FFh ; 14/03/2018
 29355                                          ;transfer COMMAND	    ; give up by faking $EXIT
 29356                                  	;;JMP	SHORT COMMANDJ
 29357                                  	;JMP	COMMAND
 29358                                  
 29359                                  	; 05/05/2019 - Retro DOS v4.0
 29360                                  	; MSDOS 6.0
 29361 000052DA B8004C                  	MOV	AX,(EXIT<<8)+0  ; 4C00h
 29362 000052DD 1E                      	push	ds
 29363                                  	;getdseg <ds>			; ds -> dosdata
 29364 000052DE 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]	
 29365 000052E3 C606[4D03]FF            	MOV	byte [DidCTRLC],-1 ; 0FFh
 29366 000052E8 1F                      	pop	ds
 29367                                  	;transfer COMMAND		; give up by faking $EXIT
 29368 000052E9 EBE1                    	JMP	SHORT COMMANDJ
 29369                                  	;JMP	COMMAND
 29370                                  
 29371                                  ;Break	<DIVISION OVERFLOW INTERRUPT>
 29372                                  ;----------------------------------------------------------------------------
 29373                                  ;
 29374                                  ; Procedure Name : DIVOV
 29375                                  ;
 29376                                  ; Default handler for division overflow trap
 29377                                  ;
 29378                                  ;----------------------------------------------------------------------------
 29379                                  
 29380                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 29381                                  DIVOV: 
 29382                                  	; 05/05/2019 - Retro DOS v4.0
 29383                                  	; 30/07/2018
 29384                                  	; 07/07/2018 - Retro DOS v3.0
 29385 000052EB BE[BB09]                	mov	si,DIVMES
 29386 000052EE 2E8B1E[CE09]            	mov	bx,[cs:DivMesLen]
 29387                                  	;mov	ax,cs
 29388                                  	;mov	ss,ax
 29389                                  	; 05/05/2019
 29390                                  	;getdseg <ss>		; we are in an ISR, flag is CLI
 29391 000052F3 2E8E16[0700]            	mov	ss,[cs:DosDSeg]
 29392 000052F8 BC[A007]                	mov     sp,AUXSTACK
 29393                                  	;call	RealDivOv ; MSDOS 3.3
 29394 000052FB E80200                  	call	_OUTMES ; MSDOS 6.0
 29395 000052FE EBDA                    	jmp	short ctrlc_abort  ; Use Ctrl-C abort on divide overflow
 29396                                  
 29397                                  ; 30/07/2018
 29398                                  
 29399                                  ; MSDOS 6.0
 29400                                  ;---------------------------------------------------------------------------
 29401                                  ;
 29402                                  ; Procedure Name : OutMes
 29403                                  ;
 29404                                  ;
 29405                                  ; OutMes: perform message output
 29406                                  ; Inputs:   SS:SI points to message
 29407                                  ;	    BX has message length
 29408                                  ; Outputs:  message to BCON
 29409                                  ;
 29410                                  ;Actually, cs:si points to the message now. The segment address is filled in
 29411                                  ;at init. time ([dskchret+2]). This will be temporarily changed to DOSCODE. 
 29412                                  ;NB. This procedure is called only from DIVOV. -SR
 29413                                  ;
 29414                                  ;---------------------------------------------------------------------------
 29415                                  
 29416                                  ;MSDOS 3.3
 29417                                  ;---------------------------------------------------------------------------
 29418                                  ; RealDivOv: perform actual divide overflow stuff.
 29419                                  ; Inputs:   none
 29420                                  ; Outputs:  message to BCON
 29421                                  ;---------------------------------------------------------------------------
 29422                                  
 29423                                  	; 05/05/2019 - Retro DOS v4.0
 29424                                  	; DOSCODE:926Ch (MSDOS 6.21, MSDOS.SYS)
 29425                                  
 29426                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 29427                                  	; DOSCODE:9210h (MSDOS 5.0, MSDOS.SYS)
 29428                                  
 29429                                  ;---------------------------------------------------------------------------
 29430                                  ;
 29431                                  ; Procedure Name : OutMes
 29432                                  ;
 29433                                  ; OutMes: perform message output
 29434                                  ; Inputs:   SS:SI points to message
 29435                                  ;	    BX has message length
 29436                                  ; Outputs:  message to BCON
 29437                                  ;
 29438                                  ;Actually, cs:si points to the message now. The segment address is filled in
 29439                                  ;at init. time ([dskchret+2]). This will be temporarily changed to DOSCODE. 
 29440                                  ;NB. This procedure is called only from DIVOV. -SR
 29441                                  ;
 29442                                  ;---------------------------------------------------------------------------
 29443                                  
 29444                                  	; 30/07/2018
 29445                                  	; MSDOS 6.0
 29446                                  _OUTMES:
 29447                                  	; MSDOS 3.3
 29448                                  ;RealDivOv:
 29449                                  	; 07/07/2018 - Retro DOS v3.0
 29450                                          ;Context ES
 29451 00005300 16                      	push	ss ; 05/05/2019
 29452                                  	;PUSH	CS ; 30/07/2018		; get ES addressability
 29453 00005301 07                      	POP	ES
 29454                                          ;Context DS
 29455 00005302 16                      	push	ss ; 05/05/2019	
 29456                                  	;PUSH	CS ; 30/07/2018		; get DS addressability
 29457 00005303 1F                      	POP	DS
 29458 00005304 C606[9403]08                    MOV     BYTE [DSKSTCOM],DEVWRT
 29459 00005309 C606[9203]16                    MOV     BYTE [DSKSTCALL],DRDWRHL
 29460 0000530E C706[9503]0000                  MOV     WORD [DSKSTST],0
 29461                                  	; BX = [DivMesLen] = 19
 29462 00005314 891E[A403]                      MOV     [DSKSTCNT],BX
 29463 00005318 BB[9203]                        MOV     BX,DSKSTCALL
 29464 0000531B 8936[A003]                      MOV     [DSKCHRET+1],SI		; transfer address (need an EQU)
 29465                                  	; 08/09/2018
 29466                                  	;mov	[DEVIOBUF_PTR],si
 29467                                  	; MSDOS 6.0
 29468                                  					; CS is used for string, fill in 
 29469                                  					; segment address 
 29470 0000531F 8C0E[A203]              	MOV	[DSKCHRET+3],CS
 29471                                  
 29472 00005323 C536[3200]                      LDS     SI,[BCON]
 29473 00005327 E8ADF3                          CALL	DEVIOCALL2
 29474                                  
 29475                                  	;; 14/03/2018
 29476                                          ;;MOV	WORD [CS:DSKCHRET+1],DEVIOBUF
 29477                                  	;; 08/09/2018
 29478                                  	;mov	word [CS:DEVIOBUF_PTR],DEVIOBUF
 29479                                          ;MOV	WORD [CS:DSKSTCNT],1
 29480                                          
 29481                                  	; 05/05/2019 - Retro DOS v4.0 (MSDOS 6.0, MSDOS 6.21)
 29482                                  
 29483                                  	; ES still points to DOSDATA. ES is
 29484                                  					; not destroyed by deviocall2. So use
 29485                                  					; ES override.
 29486                                  
 29487 0000532A 26C706[A003][BC03]      	MOV	WORD [ES:DSKCHRET+1],DEVIOBUF
 29488 00005331 26C706[A403]0100        	MOV	WORD [ES:DSKSTCNT],1
 29489                                  
 29490 00005338 C3                      	RETN
 29491                                  
 29492                                  ;Break	<CHARHRD,HARDERR,ERROR -- HANDLE DISK ERRORS AND RETURN TO USER>
 29493                                  ;---------------------------------------------------------------------------
 29494                                  ;
 29495                                  ; Procedure Name : CHARHARD
 29496                                  ;
 29497                                  ;
 29498                                  ; Character device error handler
 29499                                  ; Same function as HARDERR
 29500                                  ;
 29501                                  ;---------------------------------------------------------------------------
 29502                                  
 29503                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 29504                                  CHARHARD:
 29505                                  	; 05/05/2019 - Retro DOS v4.0
 29506                                  	; 30/07/2018
 29507                                  	; 08/07/2018 - Retro DOS v3.0
 29508                                  
 29509                                  	; MSDOS 6.0
 29510                                  		   			; M024 - start
 29511 00005339 36803E[2003]00          	cmp	byte [SS:ERRORMODE], 0	; Q: are we in the middle of int 24
 29512                                  	;jne	short @f		; Y: allow fail
 29513 0000533F 750B                    	jne	short chard1
 29514                                  
 29515 00005341 80CC10                  	OR	AH,Allowed_RETRY ; 10h	; assume ctrl p
 29516                                  
 29517 00005344 36F606[FE02]FF          	test	byte [ss:PFLAG],-1	; Q: has ctrl p been pressed
 29518 0000534A 7503                    	jnz	short ctrlp		; Y: 
 29519                                  ;@@:
 29520                                  chard1:					; M024 - end
 29521                                  	; MSDOS 6.0 & MSDOS 3.3
 29522                                  
 29523                                  ; Character device error handler
 29524                                  ; Same function as HARDERR
 29525                                  
 29526                                  	;or	ah,38h
 29527 0000534C 80CC38                  	or	ah,Allowed_IGNORE+Allowed_RETRY+Allowed_FAIL
 29528                                  ctrlp:			; SS override for Allowed and EXITHOLD
 29529 0000534F 368826[4B03]            	mov	[SS:ALLOWED],ah
 29530                                  
 29531                                  	; 15/03/2018
 29532 00005354 368C06[8205]                    MOV     [SS:EXITHOLD+2],ES
 29533 00005359 36892E[8005]                    MOV     [SS:EXITHOLD],BP
 29534 0000535E 56                              PUSH    SI
 29535                                  	;and	di,0FFh
 29536 0000535F 81E7FF00                        AND     DI,STECODE
 29537 00005363 8CDD                            MOV     BP,DS                   ;Device pointer is BP:SI
 29538 00005365 E86400                          CALL    FATALC
 29539 00005368 5E                              POP     SI
 29540                                  	;return
 29541 00005369 C3                              RETN
 29542                                  
 29543                                  ;---------------------------------------------------------------------------
 29544                                  ;
 29545                                  ; Procedure Name : HardErr
 29546                                  ;
 29547                                  ; Hard disk error handler. Entry conditions:
 29548                                  ;	DS:BX = Original disk transfer address
 29549                                  ;	DX = Original logical sector number
 29550                                  ;	CX = Number of sectors to go (first one gave the error)
 29551                                  ;	AX = Hardware error code
 29552                                  ;	DI = Original sector transfer count	
 29553                                  ;	ES:BP = Base of drive parameters
 29554                                  ;	[READOP] = 0 for read, 1 for write
 29555                                  ;	Allowed Set with allowed responses to this error (other bits MUST BE 0)
 29556                                  ; Output:
 29557                                  ;	[FAILERR] will be set if user responded FAIL
 29558                                  ;
 29559                                  ;--------------------------------------------------------------------------
 29560                                  
 29561                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 29562                                  HARDERR:
 29563                                  	; 05/05/2019 - Retro DOS v4.0
 29564                                  	; 30/07/2018
 29565                                  	; 08/07/2018 - Retro DOS v3.0
 29566 0000536A 97                      	XCHG    AX,DI                   ; Error code in DI, count in AX
 29567                                          ;and	di,0FFh
 29568 0000536B 81E7FF00                	AND     DI,STECODE              ; And off status bits
 29569                                          ;CMP	DI,WRECODE		; Write Protect Error?
 29570                                  	;cmp	di,0
 29571 0000536F 83FF00                  	cmp	DI,error_I24_write_protect ; Write Protect Error?
 29572 00005372 750A                            JNZ     short NOSETWRPERR
 29573 00005374 50                              PUSH    AX
 29574                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 29575                                  	;MOV	AL,[ES:BP+DPB.DRIVE]
 29576                                          ;;MOV	AL,[ES:BP+0]
 29577                                  	; 15/12/2022
 29578 00005375 268A4600                	mov	al,[ES:BP]
 29579                                          	; 15/03/2018
 29580 00005379 36A2[2203]                      MOV     [SS:WPERR],AL		; Flag drive with WP error
 29581 0000537D 58                              POP     AX
 29582                                  NOSETWRPERR:
 29583 0000537E 29C8                            SUB     AX,CX                   ; Number of sectors successfully transferred
 29584 00005380 01C2                            ADD     DX,AX                   ; First sector number to retry
 29585 00005382 52                              PUSH    DX
 29586                                  	; 08/07/2018
 29587                                          ;MUL	word [ES:BP+2] 		; Number of bytes transferred
 29588 00005383 26F76602                	MUL	word [ES:BP+DPB.SECTOR_SIZE]
 29589 00005387 5A                              POP     DX
 29590 00005388 01C3                            ADD     BX,AX                   ; First address for retry
 29591 0000538A 30E4                            XOR     AH,AH                   ; Flag disk section in error
 29592                                          ;CMP	DX,[ES:BP+6] 		; In reserved area?
 29593 0000538C 263B5606                	CMP	DX,[ES:BP+DPB.FIRST_FAT]
 29594 00005390 721A                            JB      SHORT ERRINT
 29595 00005392 FEC4                            INC     AH                      ; Flag for FAT
 29596                                          ;CMP	DX,[ES:BP+10H] ; MSDOS 3.3
 29597                                  	;cmp	dx,[ES:BP+11h] ; MSDOS 6.0 - 05/05/2019 	
 29598 00005394 263B5611                	CMP	DX,[ES:BP+DPB.DIR_SECTOR]  ; In FAT?  
 29599 00005398 7308                    	JAE	short TESTDIR 		; No
 29600                                  		 ; Err in FAT must force recomp of freespace
 29601                                  	;mov	word [ES:BP+1Eh],-1 ; MSDOS 3.3
 29602                                  	;mov	word [ES:BP+1Fh],-1 ; MSDOS 6.0 - 05/05/2019 
 29603 0000539A 26C7461FFFFF            	MOV	word [ES:BP+DPB.FREE_CNT],-1
 29604 000053A0 EB0A                    	JMP	SHORT ERRINT
 29605                                  TESTDIR:
 29606 000053A2 FEC4                            INC     AH
 29607                                          ;CMP	DX,[ES:BP+0BH]		; In directory?
 29608 000053A4 263B560B                	CMP	DX,[ES:BP+DPB.FIRST_SECTOR] 
 29609 000053A8 7202                            JB      SHORT ERRINT
 29610 000053AA FEC4                            INC     AH                      ; Must be in data area
 29611                                  ERRINT:
 29612 000053AC D0E4                            SHL     AH,1                    ; Make room for read/write bit
 29613 000053AE 360A26[7505]                    OR      AH,[SS:READOP] ; 15/03/2018
 29614                                  
 29615                                  	; 15/08/2018
 29616                                  					; SS override for allowed and EXITHOLD
 29617 000053B3 360A26[4B03]            	OR	AH,[SS:ALLOWED]		; Set the allowed_ bits
 29618                                  
 29619                                          ;entry   FATAL
 29620                                  FATAL:
 29621                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 29622                                  	;MOV	AL,[ES:BP+DPB.DRIVE]
 29623                                          ;;MOV	AL,[ES:BP+0]		; Get drive number
 29624                                  	; 15/12/2022
 29625 000053B8 268A4600                	MOV	AL,[ES:BP]        
 29626                                  
 29627                                  	;entry   FATAL1
 29628                                  FATAL1:  
 29629                                  	; 15/03/2018      
 29630 000053BC 368C06[8205]            	MOV     [SS:EXITHOLD+2],ES
 29631 000053C1 36892E[8005]                    MOV     [SS:EXITHOLD],BP	; The only things we preserve	
 29632                                  	;LES	SI,[ES:BP+12H] ; MSDOS 3.3
 29633                                  	;LES	SI,[ES:BP+13H] ; MSDOS 6.0 - 05/05/2019
 29634 000053C6 26C47613                	LES	SI,[ES:BP+DPB.DRIVER_ADDR]
 29635 000053CA 8CC5                            MOV     BP,ES                   ; BP:SI points to the device involved
 29636                                  
 29637                                  	; DI has the INT-24-style extended error. We now map the error code 
 29638                                  	; for this into the normalized get extended error set by using the 
 29639                                  	; ErrMap24 table as a translate table. Note that we translate ONLY 
 29640                                  	; the device returned codes and leave all others beyond the look up 
 29641                                  	; table alone.
 29642                                  
 29643                                  	; 08/07/2018 - Retro DOS v3.0
 29644                                  FATALC:
 29645 000053CC E89701                  	call	SET_I24_EXTENDED_ERROR
 29646                                  	;cmp	di,0Ch
 29647 000053CF 83FF0C                  	CMP	DI,error_I24_gen_failure
 29648 000053D2 7603                    	JBE	short GOT_RIGHT_CODE	; Error codes above gen_failure get
 29649 000053D4 BF0C00                  	MOV	DI,error_I24_gen_failure; mapped to gen_failure. Real codes
 29650                                  					;  Only come via GetExtendedError
 29651                                  ;** ----------------------------------------------------------------
 29652                                  ;
 29653                                  ; Entry point used by REDIRector on Network I 24 errors.
 29654                                  ;
 29655                                  ;	ASSUME	DS:NOTHING,ES:NOTHING,SS:DOSDATA
 29656                                  ;
 29657                                  ; ALL I 24 regs set up. ALL Extended error info SET. ALLOWED Set.
 29658                                  ;     EXITHOLD set for restore of ES:BP.
 29659                                  ; ------------------------------------------------------------------
 29660                                  	;entry	NET_I24_ENTRY
 29661                                  NET_I24_ENTRY:
 29662                                  GOT_RIGHT_CODE:
 29663 000053D7 36803E[2003]00          	CMP     BYTE [SS:ERRORMODE],0	; No INT 24s if already INT 24
 29664 000053DD 7404                            JZ	SHORT NoSetFail
 29665 000053DF B003                    	MOV	AL,3
 29666 000053E1 EB6C                    	JMP	short FailRet
 29667                                  NoSetFail:
 29668 000053E3 368926[8805]                    MOV     [SS:CONTSTK],SP		; SS override
 29669 000053E8 16                              PUSH	SS
 29670 000053E9 07                              POP	ES
 29671                                      
 29672                                  	; Wango!!! We may need to free some user state info... In 
 29673                                  	; particular, we may have locked down a JFN for a user and he may 
 29674                                  	; NEVER return to us. Thus,we need to free it here and then 
 29675                                  	; reallocate it when we come back.
 29676                                  
 29677 000053EA 36833E[AA05]FF          	CMP	word [SS:SFN],-1 ; 0FFFFh
 29678 000053F0 740C                    	JZ	short _NoFree
 29679 000053F2 1E                      	push	ds
 29680 000053F3 56                      	push	si
 29681 000053F4 36C536[AE05]            	LDS	SI,[SS:PJFN]
 29682 000053F9 C604FF                  	MOV	BYTE [SI],0FFH
 29683 000053FC 5E                      	pop	si
 29684 000053FD 1F                      	pop	ds
 29685                                  
 29686                                  _NoFree:
 29687 000053FE FA                      	CLI
 29688                                  					; Prepare to play with stack
 29689 000053FF 36FE06[2003]                    INC     BYTE [SS:ERRORMODE]	; Flag INT 24 in progress
 29690 00005404 36FE0E[2103]                    DEC     BYTE [SS:INDOS]		; INT 24 handler might not return
 29691                                  
 29692                                  	; 05/05/2019 - Retro DOS v4.0 (MSDOS 6.0, MSDOS 6.21)
 29693                                  
 29694                                  	;; Extended Open hooks
 29695                                  					; AN000;IFS.I24 error disabled
 29696                                  	;test	byte [ss:EXTOPEN_ON],2
 29697 00005409 36F606[F605]02          	TEST	byte [ss:EXTOPEN_ON],EXT_OPEN_I24_OFF 
 29698 0000540F 7404                    	JZ	short i24yes		; AN000;IFS.no
 29699                                  faili24:				; AN000;
 29700 00005411 B003                    	MOV	AL,3			; AN000;IFS.fake fail
 29701 00005413 EB29                    	JMP	short passi24 		; AN000;IFS.exit
 29702                                  i24yes: 				; AN000;
 29703                                  	;; Extended Open hooks
 29704                                  
 29705 00005415 368E16[8605]                    MOV     SS,[SS:USER_SS]
 29706 0000541A 268B26[8405]                    MOV     SP,[ES:USER_SP]         ; User stack pointer restored
 29707                                  
 29708                                  	;;int	24h	
 29709                                          ;IN	int_fatal_abort		; Fatal error interrupt vector,
 29710                                  					; must preserve ES
 29711                                  	; 05/05/2019
 29712 0000541F 26803E[F211]00          	cmp	byte [es:DosHasHMA], 0	; Q: is dos running in HMA (M021)
 29713 00005425 7504                    	jne	short do_low_int24	; Y: the int must be done from low mem
 29714 00005427 CD24                    	INT	int_fatal_abort 	; Fatal error interrupt vector, 
 29715                                  					; must preserve ES
 29716 00005429 EB05                    	jmp	short criterr_ret_addr
 29717                                  
 29718                                  do_low_int24:
 29719                                  	; 05/05/2019
 29720                                  	; MSDOS 6.0
 29721 0000542B 2EFF1E[1251]            	call    far [cs:LowInt24Addr]
 29722                                  criterr_ret_addr:
 29723 00005430 268926[8405]                    MOV     [ES:USER_SP],SP         ; restore our stack
 29724 00005435 268C16[8605]                    MOV     [ES:USER_SS],SS
 29725 0000543A 8CC5                            MOV     BP,ES
 29726 0000543C 8ED5                            MOV     SS,BP
 29727                                  passi24:
 29728 0000543E 368B26[8805]                    MOV     SP,[SS:CONTSTK]
 29729 00005443 36FE06[2103]                    INC     BYTE [SS:INDOS]		; Back in the DOS
 29730 00005448 36C606[2003]00                  MOV     BYTE [SS:ERRORMODE],0	; Back from INT 24
 29731 0000544E FB                              STI
 29732                                  FailRet:
 29733 0000544F 36C42E[8005]                    LES     BP,[SS:EXITHOLD]
 29734                                  	
 29735                                  	; 08/07/2018
 29736                                  
 29737                                  	; Triage the user's reply.
 29738                                  
 29739 00005454 3C01                    	CMP	AL,1
 29740 00005456 723D                    	JB	short CheckIgnore	; 0 => ignore
 29741 00005458 7445                    	JZ	short CheckRetry	; 1 => retry
 29742 0000545A 3C03                    	CMP	AL,3			; 3 => fail
 29743 0000545C 754B                    	JNZ	short DoAbort 		; 2, invalid => abort
 29744                                  
 29745                                  	; The reply was fail. See if we are allowed to fail.
 29746                                  
 29747                                  				; SS override for ALLOWED, EXTOPEN_ON, 
 29748                                  				; ALLOWED, FAILERR, WPERR, SFN, pJFN
 29749                                  	;test	byte [ss:ALLOWED],8
 29750 0000545E 36F606[4B03]08          	test	byte [ss:ALLOWED],Allowed_FAIL ; Can we?
 29751 00005464 7443                    	jz	short DoAbort	; No, do abort
 29752                                  DoFail:
 29753 00005466 B003                    	MOV	AL,3		; just in case...
 29754                                  				; AN000;EO. I24 error disabled
 29755                                  	; 05/05/2019
 29756                                  	;(MSDOS 6.0, MSCTRLC.ASM, 1991)
 29757 00005468 36F606[F605]02          	test	byte [ss:EXTOPEN_ON],EXT_OPEN_I24_OFF ; 2
 29758 0000546E 7505                    	jnz	short CleanUp 		; AN000;EO. no
 29759                                  	
 29760 00005470 36FE06[4A03]            	inc	byte [SS:FAILERR]	; Tell everybody
 29761                                  CleanUp:
 29762 00005475 36C606[2203]FF          	MOV	byte [SS:WPERR],-1
 29763 0000547B 36833E[AA05]FF          	CMP	word [SS:SFN],-1
 29764                                  	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 29765                                  	;jnz	short CleanUp2
 29766                                  	;retn
 29767                                  	; 17/12/2022
 29768 00005481 7411                    	jz	short Cleanup_retn ; 08/07/2018 - Retro DOS v3.0
 29769                                  CleanUp2:
 29770 00005483 1E                      	push	ds
 29771 00005484 56                      	push	si
 29772 00005485 50                      	push	ax
 29773 00005486 36A1[AA05]              	MOV	AX,[ss:SFN]
 29774 0000548A 36C536[AE05]            	LDS	SI,[ss:PJFN]
 29775 0000548F 8804                    	MOV	[SI],AL
 29776 00005491 58                      	pop	ax
 29777 00005492 5E                      	pop	si
 29778 00005493 1F                      	pop	ds
 29779                                  Cleanup_retn:
 29780 00005494 C3                      	retn
 29781                                  
 29782                                  	; The reply was IGNORE. See if we are allowed to ignore.
 29783                                  
 29784                                  CheckIgnore:
 29785                                  	;test	byte [ss:ALLOWED],20h
 29786 00005495 36F606[4B03]20          	test	byte [ss:ALLOWED],Allowed_IGNORE ; Can we?
 29787 0000549B 74C9                    	jz	short DoFail			 ; No, do fail
 29788 0000549D EBD6                    	jmp	short CleanUp
 29789                                  
 29790                                  	; The reply was RETRY. See if we are allowed to retry.
 29791                                  
 29792                                  CheckRetry:
 29793                                  	;test	byte [ss:ALLOWED],10h
 29794 0000549F 36F606[4B03]10          	test	byte [ss:ALLOWED],Allowed_RETRY	; Can we?
 29795 000054A5 74BF                    	jz	short DoFail			; No, do fail
 29796 000054A7 EBCC                    	JMP	short CleanUp
 29797                                  
 29798                                  	; The reply was ABORT.
 29799                                  DoAbort:
 29800 000054A9 16                      	push	ss
 29801 000054AA 1F                      	pop	ds
 29802                                  
 29803 000054AB 803E[5703]00            	CMP	byte [CONSWAP],0
 29804 000054B0 7403                    	JZ	short NOSWAP2
 29805 000054B2 E872DE                  	call	SWAPBACK
 29806                                  NOSWAP2:
 29807                                  	; See if we are to truly abort. If we are in the process of aborting, 
 29808                                  	; turn this abort into a fail.
 29809                                  
 29810                                  	;test	[fAborting],0FFh
 29811                                  	;jnz	short DoFail
 29812                                  
 29813 000054B5 803E[5903]00            	cmp	byte [fAborting],0
 29814 000054BA 75AA                    	JNZ	short DoFail
 29815                                  
 29816                                  	; Set return code
 29817                                  
 29818 000054BC C606[7C05]02            	MOV	BYTE [EXIT_TYPE],EXIT_HARD_ERROR ; 2
 29819 000054C1 30C0                    	XOR	AL,AL
 29820                                  
 29821                                  	; we are truly aborting the process. Go restore information from 
 29822                                  	; the PDB as necessary.
 29823                                  
 29824 000054C3 E98C0D                  	jmp	exit_inner
 29825                                  
 29826                                  ;** --------------------------------------------------------------------------
 29827                                  ;
 29828                                  ; reset_environment checks the DS value against the CurrentPDB. If they are
 29829                                  ; different, then an old-style return is performed. If they are the same,
 29830                                  ; then we release jfns and restore to parent. We still use the PDB at DS:0 as
 29831                                  ; the source of the terminate addresses.
 29832                                  ;
 29833                                  ; Some subtlety: We are about to issue a bunch of calls that *may* generate
 29834                                  ; INT 24s. We *cannot* allow the user to restart the abort process; we may
 29835                                  ; end up aborting the wrong process or turn a terminate/stay/resident into a
 29836                                  ; normal abort and leave interrupt handlers around. What we do is to set a
 29837                                  ; flag that will indicate that if any abort code is seen, we just continue the
 29838                                  ; operation. In essence, we dis-allow the abort response.
 29839                                  ;
 29840                                  ; output:   none.
 29841                                  ; ----------------------------------------------------------------------------
 29842                                  
 29843                                  	;entry	reset_environment
 29844                                  	
 29845                                  reset_environment:
 29846                                  	; 30/07/2018 - Retro DOS v3.0
 29847                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 588Ah 
 29848                                  
 29849                                  ;***	invoke	Reset_Version		; AN007 ;MS. reset version number
 29850                                  
 29851 000054C6 1E                      	PUSH	DS			; save PDB of process
 29852                                  
 29853                                  	; There are no critical sections in force. Although we may enter 
 29854                                  	; here with critical sections locked down, they are no longer 
 29855                                  	; relevant. We may safely free all allocated resources.
 29856                                  
 29857 000054C7 B482                    	MOV	AH,82h
 29858                                  		; Microsoft Networks - END DOS CRITICAL SECTIONS 0 THROUGH 7
 29859                                  	;int	2Ah 	
 29860 000054C9 CD2A                    	INT	int_IBM
 29861                                  
 29862                                  					; SS override
 29863 000054CB 36C606[5903]FF          	MOV	byte [SS:fAborting],-1	; signal abort in progress
 29864                                  
 29865                                  					; DOS 4.00 doesn't need it
 29866                                  	;CallInstall NetResetEnvironment, MultNET, 34  
 29867                                  					; Allow REDIR to clear some stuff
 29868                                  					; On process exit.
 29869 000054D1 B82211                  	mov     ax, 1122h
 29870 000054D4 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - PROCESS TERMINATION HOOK
 29871                                  			; SS = DOS CS
 29872                                  	;mov	al,22h	
 29873 000054D6 B022                    	MOV	AL,int_terminate
 29874 000054D8 E8F1B9                  	call	_$GET_INTERRUPT_VECTOR	; and who to go to
 29875                                  
 29876 000054DB 59                      	POP	CX			; get ThisPDB
 29877 000054DC 06                      	push	es
 29878 000054DD 53                      	push	bx			; save return address
 29879                                  
 29880 000054DE 368B1E[3003]            	MOV	BX,[SS:CurrentPDB] 	; get currentPDB
 29881 000054E3 8EDB                    	MOV	DS,BX
 29882 000054E5 A11600                  	MOV	AX,[PDB.PARENT_PID]	; get parentPDB
 29883                                  
 29884                                  	; AX = parentPDB, BX = CurrentPDB, CX = ThisPDB
 29885                                  	; Only free handles if AX <> BX and BX = CX and [exit_code].upper 
 29886                                  	; is not Exit_keep_process
 29887                                  	
 29888 000054E8 39D8                    	CMP	AX,BX
 29889 000054EA 7418                    	JZ	short reset_return	; parentPDB = CurrentPDB
 29890 000054EC 39CB                    	CMP	BX,CX
 29891 000054EE 7514                    	JNZ	short reset_return	; CurrentPDB <> ThisPDB
 29892 000054F0 50                      	PUSH	AX			; save parent
 29893                                  
 29894                                  					; SS override
 29895                                  	;cmp	byte [SS:EXIT_TYPE],3
 29896 000054F1 36803E[7C05]03          	CMP	BYTE [SS:EXIT_TYPE],EXIT_KEEP_PROCESS ; 15/08/2018
 29897 000054F7 7406                    	JZ	short reset_to_parent 	; keeping this process
 29898                                  
 29899                                  	; We are truly removing a process. Free all allocation blocks 
 29900                                  	; belonging to this PDB
 29901                                  
 29902                                  	;invoke	arena_free_process
 29903 000054F9 E88E0D                  	call	arena_free_process
 29904                                  
 29905                                  	; Kill off remainder of this process. Close file handles and signal 
 29906                                  	; to relevant network folks that this process is dead. Remember that 
 29907                                  	; CurrentPDB is STILL the current process!
 29908                                  
 29909                                  	;invoke	DOS_ABORT
 29910 000054FC E82FDA                  	call	DOS_ABORT
 29911                                  
 29912                                  reset_to_parent:
 29913                                  					; SS override
 29914 000054FF 368F06[3003]            	POP	word [SS:CurrentPDB]	; set up process as parent
 29915                                  
 29916                                  reset_return:				; come here for normal return
 29917                                  	;Context DS			; DS is used to refer to DOSDATA  
 29918 00005504 16                      	push	ss
 29919 00005505 1F                      	pop	ds	
 29920                                  
 29921 00005506 B0FF                    	MOV	AL,-1
 29922                                  
 29923                                  	; make sure that everything is clean In this case ignore any errors, 
 29924                                  	; we cannot "FAIL" the abort, the program being aborted is dead.
 29925                                  
 29926                                  	;EnterCrit critDisk
 29927 00005508 E84CBE                  	call	ECritDisk
 29928                                  	;invoke	FLUSHBUF
 29929 0000550B E8AC05                  	call	FLUSHBUF
 29930                                  	;LeaveCrit critDisk
 29931 0000550E E861BE                  	call	LCritDisk
 29932                                  
 29933                                  	; Decrement open ref. count if we had done a virtual open earlier.
 29934                                  
 29935 00005511 E883F7                  	call	CHECK_VIRT_OPEN
 29936 00005514 FA                      	CLI
 29937 00005515 C606[2103]00            	MOV	BYTE [INDOS],0		; Go to known state
 29938 0000551A C606[2203]FF            	MOV	BYTE [WPERR],-1		; Forget about WP error
 29939 0000551F C606[5903]00            	MOV	byte [fAborting],0	; let aborts occur
 29940 00005524 8F06[8005]              	POP	WORD [EXITHOLD]
 29941 00005528 8F06[8205]              	POP	WORD [EXITHOLD+2]
 29942                                  
 29943                                  	; Snake into multitasking... Get stack from CurrentPDB person
 29944                                  
 29945 0000552C 8E1E[3003]              	MOV	DS,[CurrentPDB]
 29946 00005530 8E163000                	MOV	SS,[PDB.USER_STACK+2]
 29947 00005534 8B262E00                	MOV	SP,[PDB.USER_STACK]
 29948                                  
 29949 00005538 E81FAF                  	call	restore_world
 29950                                  
 29951                                  	; 05/05/2019
 29952 0000553B 07                      	pop	es ; * ; MSDOS 6.21 (DOSCODE:94A8h, MSDOS.SYS)
 29953                                  
 29954                                  	; MSDOS 6.0
 29955 0000553C 50                      	push	ax			; set up ds, but save ds in TEMPSEG 
 29956 0000553D 8CD8                    	mov	ax,ds			; and not on stack.
 29957                                  	;getdseg <ds>			; ds -> dosdata
 29958 0000553F 2E8E1E[0700]            	mov	ds,[cs:DosDSeg] 
 29959 00005544 A3[0A0D]                	mov	[TEMPSEG],ax
 29960 00005547 58                      	pop	ax
 29961                                  					; set up ds to DOSDATA
 29962                                  	;MOV	[CS:USER_SP],AX ; MSDOS 3.3
 29963 00005548 A3[8405]                	mov	[USER_SP],ax
 29964                                  
 29965 0000554B 58                      	POP	AX			; suck off CS:IP of interrupt...
 29966 0000554C 58                      	POP	AX
 29967 0000554D 58                      	POP	AX
 29968                                  
 29969                                  ; M011 : BEGIN
 29970                                  
 29971                                  	; MSDOS 3.3
 29972                                  ;	MOV	AX,0F202h	; STI
 29973                                  
 29974                                  	; MSDOS 6.0
 29975 0000554E 9F                      	LAHF
 29976 0000554F 86E0                    	XCHG	AH,AL
 29977 00005551 2402                    	AND	AL,2
 29978 00005553 B4F2                    	MOV	AH,0F2h
 29979                                  
 29980                                  ; M011 : END
 29981                                  
 29982                                  	; MSDOS 3.3 (& MSDOS 6.0)
 29983 00005555 50                      	PUSH	AX
 29984                                   
 29985                                  	;PUSH	word [CS:EXITHOLD+2]
 29986                                  	;PUSH	word [CS:EXITHOLD]
 29987                                  	
 29988                                  	; MSDOS 6.0
 29989 00005556 FF36[8205]              	PUSH	word [EXITHOLD+2]
 29990 0000555A FF36[8005]              	PUSH	word [EXITHOLD]
 29991                                  
 29992                                  	;MOV	AX,[CS:USER_SP]
 29993                                  
 29994                                  	; MSDOS 6.0
 29995 0000555E A1[8405]                	MOV	AX,[USER_SP]
 29996 00005561 8E1E[0A0D]              	mov	ds,[TEMPSEG]	; restore ds
 29997                                  
 29998 00005565 CF                      	IRET			; Long return back to user terminate address
 29999                                  
 30000                                  ;---------------------------------------------------------------------------
 30001                                  ;
 30002                                  ; Procedure Name : SET_I24_EXTENDED_ERROR
 30003                                  ;
 30004                                  ; This routine handles extended error codes.
 30005                                  ; Input : DI = error code from device
 30006                                  ; Output: All EXTERR fields are set
 30007                                  ;
 30008                                  ;--------------------------------------------------------------------------
 30009                                  
 30010                                  SET_I24_EXTENDED_ERROR:
 30011 00005566 50                      	PUSH	AX
 30012                                  					; ErrMap24End is in DOSDATA
 30013 00005567 B8[BA0E]                	MOV	AX,ErrMap24End
 30014 0000556A 2D[AA0E]                	SUB	AX,ErrMap24
 30015                                  					; Change to dosdata to access 
 30016                                  					; ErrMap24 and EXTERR -SR
 30017                                  	; 05/05/2019 - Retro DOS v4.0
 30018                                  	
 30019                                  	; MSDOS 6.0
 30020 0000556D 1E                      	push	ds
 30021                                  	;getdseg <ds>			; ds ->dosdata
 30022 0000556E 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 30023                                  
 30024                                  	; AX is the index of the first unavailable error. Do not translate 
 30025                                  	; if greater or equal to AX.
 30026                                  
 30027 00005573 39C7                    	CMP	DI,AX
 30028 00005575 89F8                    	MOV	AX,DI
 30029 00005577 7306                    	JAE	short NoTrans
 30030                                  
 30031                                  	;MOV	AL,[CS:DI+ErrMap24]  ; MSDOS 3.3
 30032 00005579 8A85[AA0E]              	mov	al,[ErrMap24+di] ; MSDOS 6.0
 30033 0000557D 30E4                    	XOR	AH,AH
 30034                                  NoTrans:
 30035                                  	;MOV	[CS:EXTERR],AX
 30036 0000557F A3[2403]                	mov	[EXTERR],AX
 30037 00005582 1F                      	pop	ds
 30038                                  	;assume	ds:nothing
 30039 00005583 58                      	POP	AX
 30040                                  
 30041                                  	; Now Extended error is set correctly. Translate it to get correct 
 30042                                  	; error locus class and recommended action.
 30043                                  
 30044 00005584 56                      	PUSH	SI
 30045                                  					; ERR_TABLE_24 is in DOSCODE 
 30046 00005585 BE[5A0E]                	MOV	SI,ERR_TABLE_24
 30047 00005588 E802B1                  	call	CAL_LK			; Set other extended error fields
 30048 0000558B 5E                      	POP	SI
 30049 0000558C C3                      	retn
 30050                                  
 30051                                  ;============================================================================
 30052                                  ; FAT.ASM, MSDOS 6.0, 1991
 30053                                  ;============================================================================
 30054                                  ; 30/07/2018 - Retro DOS v3.0
 30055                                  ; 20/05/2019 - Retro DOS v4.0
 30056                                  
 30057                                  ;	TITLE	FAT - FAT maintenance routines
 30058                                  ;	NAME	FAT
 30059                                  
 30060                                  ;**	FAT.ASM
 30061                                  ;----------------------------------------------------------------------------
 30062                                  ;	Low level local device routines for performing disk change sequence,
 30063                                  ;	setting cluster validity, and manipulating the FAT
 30064                                  ;
 30065                                  ;	IsEof
 30066                                  ;	UNPACK
 30067                                  ;	PACK
 30068                                  ;	MAPCLUSTER
 30069                                  ;	FATREAD_SFT
 30070                                  ;	FATREAD_CDS
 30071                                  ;	FAT_operation
 30072                                  ;
 30073                                  ;	Revision history:
 30074                                  ;
 30075                                  ;	  AN000  version Jan. 1988
 30076                                  ;	   A001  PTM	      -- disk changed for look ahead buffers
 30077                                  ;
 30078                                  ;	M014 - if a request for pack\unpack cluster 0 is made we write\read
 30079                                  ;	       from CL0FATENTRY rather than disk.
 30080                                  
 30081                                  ; DOSCODE:94FAh (MSDOS 6.21, MSDOS.SYS)
 30082                                  
 30083                                  ;Break <IsEOF - check the quantity in BX for EOF>
 30084                                  ;----------------------------------------------------------------------------
 30085                                  ;
 30086                                  ; Procedure Name : IsEOF
 30087                                  ;
 30088                                  ; IsEOF - check the fat value in BX for eof.
 30089                                  ;
 30090                                  ;   Inputs:	ES:BP point to DPB
 30091                                  ;		BX has fat value
 30092                                  ;   Outputs:	JAE eof
 30093                                  ;   Registers modified: none
 30094                                  ;
 30095                                  ;---------------------------------------------------------------------------
 30096                                  
 30097                                  IsEOF:
 30098                                  	;cmp	word [es:bp+0Dh],0FF6h
 30099 0000558D 26817E0DF60F            	CMP	word [ES:BP+DPB.MAX_CLUSTER],4096-10 ; is this 16 bit fat?
 30100 00005593 730B                    	JAE	short EOF16			; yes, check for eof there
 30101                                  
 30102                                  ;J.K. 8/27/86
 30103                                  ;Modified to accept 0FF0h as an eof. This is to handle the diskfull case
 30104                                  ;of any media that has "F0"(Other) as a MediaByte.
 30105                                  ;Hopely, this does not create any side effect for those who may use any value
 30106                                  ;other than "FF8-FFF" as an EOF for their own file.
 30107                                  
 30108 00005595 81FBF00F                	cmp	bx,0FF0h
 30109 00005599 7404                    	je	short IsEOF_other
 30110                                  
 30111 0000559B 81FBF80F                	CMP	BX,0FF8h		; do the 12 bit compare
 30112                                  IsEOF_other:
 30113 0000559F C3                      	retn
 30114                                  EOF16:
 30115 000055A0 83FBF8                  	CMP	BX,0FFF8h		; 16 bit compare
 30116 000055A3 C3                      	retn
 30117                                  
 30118                                  ; DOSCODE:9511h (MSDOS 6.21, MSDOS.SYS)
 30119                                  
 30120                                  ;Break	<UNPACK -- UNPACK FAT ENTRIES>
 30121                                  ;---------------------------------------------------------------------------
 30122                                  ;
 30123                                  ; Procedur Name : UNPACK
 30124                                  ;
 30125                                  ; Inputs:
 30126                                  ;	BX = Cluster number (may be full 16-bit quantity)
 30127                                  ;	ES:BP = Base of drive parameters
 30128                                  ; Outputs:
 30129                                  ;	DI = Contents of FAT for given cluster (may be full 16-bit quantity)
 30130                                  ;	Zero set means DI=0 (free cluster)
 30131                                  ;	Carry set means error (currently user FAILed to I 24)
 30132                                  ; SI Destroyed, No other registers affected. Fatal error if cluster too big.
 30133                                  ;
 30134                                  ; NOTE: if BX = 0 then DI = contents of CL0FATENTRY
 30135                                  ;
 30136                                  ;----------------------------------------------------------------------------
 30137                                  	
 30138                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 30139                                  	; DOSCODE:94B5h (MSDOS 5.0, MSDOS.SYS)
 30140                                  
 30141                                  	; 20/05/2019 - Retro DOS v4.0
 30142                                  UNPACK:
 30143                                  	; MSDOS 6.0			; M014 - Start
 30144 000055A4 09DB                    	or	bx, bx			; Q: are we unpacking cluster 0
 30145 000055A6 7507                    	jnz	short up_cont		; N: proceed with normal unpack
 30146 000055A8 8B3E[8100]              	mov	di,[CL0FATENTRY]	; Y: return value in CL0FATENTRY
 30147 000055AC 09FF                    	or	di,di 			; return z if di=0
 30148 000055AE C3                      	retn				; done
 30149                                  up_cont:				; M014 - End
 30150                                  	; MSDOS 3.3 & MSDOS 6.0
 30151                                  	;cmp	bx,[es:bp+0Dh]
 30152 000055AF 263B5E0D                	CMP	BX,[ES:BP+DPB.MAX_CLUSTER]
 30153 000055B3 7726                    	JA	short HURTFAT
 30154 000055B5 E8D700                  	CALL	MAPCLUSTER
 30155 000055B8 721E                    	jc	short _DoContext
 30156 000055BA 8B3D                    	MOV	DI,[DI]
 30157 000055BC 750E                    	JNZ	short High12		; MZ if high 12 bits, go get 'em
 30158 000055BE 268B760D                	MOV	SI,[ES:BP+DPB.MAX_CLUSTER] ; MZ is this 16-bit fat?
 30159 000055C2 81FEF60F                	CMP	SI,4096-10
 30160 000055C6 720C                    	JB	short Unpack12		; MZ No, go 'AND' off bits
 30161 000055C8 09FF                    	OR	DI,DI			; MZ set zero condition code, clears carry
 30162 000055CA EB0C                    	JMP	SHORT _DoContext 	; MZ go do context
 30163                                  High12:
 30164 000055CC D1EF                    	SHR	DI,1
 30165 000055CE D1EF                    	SHR	DI,1
 30166 000055D0 D1EF                    	SHR	DI,1
 30167 000055D2 D1EF                    	SHR	DI,1
 30168                                  Unpack12:
 30169 000055D4 81E7FF0F                	AND	DI,0FFFh		; Clears carry
 30170                                  _DoContext:
 30171 000055D8 16                      	PUSH	SS
 30172 000055D9 1F                      	POP	DS
 30173 000055DA C3                      	retn
 30174                                  HURTFAT:
 30175                                  	;;mov	word [es:bp+1Eh],0FFFFh
 30176                                  	;mov	word [es:bp+1Fh],0FFFFh  ; MSDOS 6.0
 30177 000055DB 26C7461FFFFF            	MOV	word [ES:BP+DPB.FREE_CNT],-1 ; Err in FAT must force recomp of freespace
 30178 000055E1 50                      	PUSH	AX
 30179 000055E2 B488                    	MOV	AH,Allowed_FAIL+80h ; 88h
 30180                                  
 30181                                  ;hkn; SS override
 30182 000055E4 36C606[4B03]08          	MOV	byte [SS:ALLOWED],Allowed_FAIL ; 8
 30183                                  ;
 30184                                  ; Signal Bad FAT to INT int_fatal_abort handler. We have an invalid cluster.
 30185                                  ;
 30186 000055EA BFFF0F                  	MOV	DI,0FFFh		; In case INT int_fatal_abort returns (it shouldn't)
 30187 000055ED E8C8FD                  	call	FATAL
 30188 000055F0 3C03                    	CMP	AL,3
 30189 000055F2 F8                      	CLC
 30190 000055F3 7501                    	JNZ	short OKU_RET 		; Try to ignore bad FAT
 30191 000055F5 F9                      	STC				; User said FAIL
 30192                                  OKU_RET:
 30193 000055F6 58                      	POP	AX
 30194                                  hurtfat_retn:
 30195 000055F7 C3                      	retn
 30196                                  
 30197                                  ; DOSCODE:9565h (MSDOS 6.21, MSDOS.SYS)
 30198                                  
 30199                                  ;Break	<PACK -- PACK FAT ENTRIES>
 30200                                  ;----------------------------------------------------------------------------
 30201                                  ;
 30202                                  ; Procedure Name : PACK
 30203                                  ;
 30204                                  ; Inputs:
 30205                                  ;	BX = Cluster number
 30206                                  ;	DX = Data
 30207                                  ;	ES:BP = Pointer to drive DPB
 30208                                  ; Outputs:
 30209                                  ;	The data is stored in the FAT at the given cluster.
 30210                                  ;	SI,DX,DI all destroyed
 30211                                  ;	Carry set means error (currently user FAILed to I 24)
 30212                                  ;	No other registers affected
 30213                                  ;
 30214                                  ; NOTE: if BX = 0 then data in DX is atored in CL0FATENTRY.
 30215                                  ;
 30216                                  ;---------------------------------------------------------------------------
 30217                                  
 30218                                  	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 30219                                  	; 20/05/2019 - Retro DOS v4.0
 30220                                  PACK:
 30221                                  	; MSDOS 6.0			; M014 - start
 30222 000055F8 09DB                    	or	bx,bx			; Q: are we packing cluster 0
 30223 000055FA 7505                    	jnz	short p_cont		; N: proceed with normal pack
 30224 000055FC 8916[8100]              	mov	[CL0FATENTRY],dx	; Y: place value in CL0FATENTRY
 30225 00005600 C3                      	retn				; done
 30226                                  p_cont:					; M014 - end
 30227                                  	; MSDOS 3.3 & MSDOS 6.0
 30228 00005601 E88B00                  	CALL	MAPCLUSTER
 30229 00005604 72D2                    	JC	short _DoContext
 30230 00005606 8B35                    	MOV	SI,[DI]
 30231 00005608 740B                    	JZ	short ALIGNED 		; byte (not nibble) aligned
 30232 0000560A 51                      	PUSH	CX			; move data to upper 12 bits
 30233 0000560B B104                    	MOV	CL,4
 30234 0000560D D3E2                    	SHL	DX,CL
 30235 0000560F 59                      	POP	CX
 30236 00005610 83E60F                  	AND	SI,0FH			; leave in original low 4 bits
 30237 00005613 EB14                    	JMP	SHORT PACKIN
 30238                                  ALIGNED:
 30239                                  	;cmp	word [es:bp+0Dh],0FF6h
 30240 00005615 26817E0DF60F            	CMP	word [ES:BP+DPB.MAX_CLUSTER],4096-10 ; MZ 16 bit fats?
 30241 0000561B 730A                    	JAE	short Pack16		; MZ yes, go clobber original data
 30242 0000561D 81E600F0                	AND	SI,0F000h		; MZ leave in upper 4 bits of original
 30243 00005621 81E2FF0F                	AND	DX,0FFFh		; MZ store only 12 bits
 30244 00005625 EB02                    	JMP	SHORT PACKIN		; MZ go store
 30245                                  Pack16:
 30246 00005627 31F6                    	XOR	SI,SI			; MZ no original data
 30247                                  PACKIN:
 30248 00005629 09D6                    	OR	SI,DX
 30249 0000562B 8935                    	MOV	[DI],SI
 30250                                  
 30251                                  ;hkn; SS override
 30252 0000562D 36C536[E205]            	LDS	SI,[SS:CURBUF]
 30253                                  	; MSDOS 6.0
 30254 00005632 F6440540                	TEST	byte [SI+BUFFINFO.buf_flags],buf_dirty  
 30255                                  					;LB. if already dirty		  ;AN000;
 30256 00005636 7507                    	JNZ	short yesdirty11	;LB.  don't increment dirty count ;AN000;
 30257                                  	; 10/06/2019
 30258 00005638 E88405                  	call	INC_DIRTY_COUNT		;LB.				  ;AN000;
 30259                                  	
 30260                                  	;or	byte [si+5],40h
 30261 0000563B 804C0540                	OR	byte [SI+BUFFINFO.buf_flags],buf_dirty  
 30262                                  yesdirty11:				;LB.				;AN000;
 30263                                  ;hkn; SS override
 30264 0000563F 36803E[7805]00          	CMP	BYTE [SS:CLUSSPLIT],0	; 15/08/2018
 30265                                  ;hkn; SS is DOSDATA
 30266 00005645 16                      	push	ss
 30267 00005646 1F                      	pop	ds
 30268 00005647 74AE                    	jz	short hurtfat_retn	; Carry clear
 30269 00005649 50                      	PUSH	AX
 30270 0000564A 53                      	PUSH	BX
 30271 0000564B 51                      	PUSH	CX
 30272 0000564C A1[8E05]                	MOV	AX,[CLUSSAVE]
 30273 0000564F 8E1E[E405]              	MOV	DS,[CURBUF+2]
 30274                                  	;;add	si,16 ; MSDOS 3.3
 30275                                  	;add	si,20 ; MSDOS 6.0
 30276 00005653 83C614                  	ADD	SI,BUFINSIZ
 30277 00005656 8824                    	MOV	[SI],AH
 30278                                  ;hkn; SS is DOSDATA
 30279                                  	;Context DS
 30280 00005658 16                      	push	ss
 30281 00005659 1F                      	pop	ds
 30282                                  	
 30283 0000565A 50                      	PUSH	AX
 30284                                  	
 30285                                  	; MSDOS 6.0
 30286 0000565B 8B16[9205]              	MOV	DX,[CLUSSEC+2]		;F.C. >32mb			;AN000;
 30287 0000565F 8916[0706]              	MOV	[HIGH_SECTOR],DX	;F.C. >32mb			;AN000;
 30288                                  
 30289                                  	; MSDOS 3.3 & MSDOS 6.0
 30290 00005663 8B16[9005]              	MOV	DX,[CLUSSEC]
 30291                                  
 30292                                  	;MOV	SI,1	  ; *
 30293                                  	;XOR	AL,AL     ; *
 30294                                  	;call	GETBUFFRB ; *
 30295                                  	; 22/09/2023
 30296 00005667 E84503                  	call	GETBUFFRA ; *
 30297                                  
 30298 0000566A 58                      	POP	AX
 30299 0000566B 721C                    	JC	short POPP_RET
 30300 0000566D C53E[E205]              	LDS	DI,[CURBUF]
 30301                                  	
 30302                                  	; MSDOS 6.0
 30303 00005671 F6450540                	TEST	byte [DI+BUFFINFO.buf_flags],buf_dirty  
 30304                                  					;LB. if already dirty		  ;AN000;
 30305 00005675 7507                    	JNZ	short yesdirty12	;LB.  don't increment dirty count ;AN000;
 30306 00005677 E84505                  	call	INC_DIRTY_COUNT 	;LB.				  ;AN000;
 30307                                  	
 30308                                  	;or	byte [di+5],40h
 30309 0000567A 804D0540                	OR	byte [DI+BUFFINFO.buf_flags],buf_dirty 
 30310                                  yesdirty12:
 30311                                  	;;add	di,16
 30312                                  	;add	di,20 ; MSDOS 6.0
 30313 0000567E 83C714                  	ADD	DI,BUFINSIZ
 30314 00005681 4F                      	DEC	DI
 30315                                  	;add	di,[es:bp+2]
 30316 00005682 26037E02                	ADD	DI,[ES:BP+DPB.SECTOR_SIZE]
 30317 00005686 8805                    	MOV	[DI],AL
 30318 00005688 F8                      	CLC
 30319                                  POPP_RET:
 30320 00005689 16                      	PUSH	SS
 30321 0000568A 1F                      	POP	DS
 30322 0000568B 59                      	POP	CX
 30323 0000568C 5B                      	POP	BX
 30324 0000568D 58                      	POP	AX
 30325 0000568E C3                      	retn
 30326                                  
 30327                                  ; 31/07/2018 - Retro DOS v3.0
 30328                                  
 30329                                  ;Break	<MAPCLUSTER - BUFFER A FAT SECTOR>
 30330                                  ;---------------------------------------------------------------------------
 30331                                  ;
 30332                                  ; Procedure Name : MAPCLUSTER
 30333                                  ;
 30334                                  ; Inputs:
 30335                                  ;	ES:BP Points to DPB
 30336                                  ;	BX Is cluster number
 30337                                  ; Function:
 30338                                  ;	Get a pointer to the cluster
 30339                                  ; Outputs:
 30340                                  ;	DS:DI Points to contents of FAT for given cluster
 30341                                  ;	DS:SI Points to start of buffer
 30342                                  ;	Zero Not set if cluster data is in high 12 bits of word
 30343                                  ;	Zero set if cluster data is in low 12 or 16 bits
 30344                                  ;	Carry set if failed.
 30345                                  ; SI is destroyed.
 30346                                  ;
 30347                                  ;---------------------------------------------------------------------------
 30348                                  
 30349                                  	; 20/05/2019 - Retro DOS v4.0
 30350                                  	; DOSCODE:9601h (MSDOS 6.21, MSDOS.SYS)
 30351                                  	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 30352                                  	; DOSCODE:95A5h (MSDOS 5.0, MSDOS.SYS)
 30353                                  
 30354                                  MAPCLUSTER:
 30355                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5A15h
 30356 0000568F C606[7805]00            	MOV	BYTE [CLUSSPLIT],0
 30357                                  	;SAVE	<AX,BX,CX,DX>
 30358 00005694 50                      	push	ax
 30359 00005695 53                      	push	bx
 30360 00005696 51                      	push	cx
 30361 00005697 52                      	push	dx
 30362 00005698 89D8                    	MOV	AX,BX			; AX = BX
 30363 0000569A 26817E0DF60F            	CMP	word [ES:BP+DPB.MAX_CLUSTER],4096-10  ; MZ 16 bit fat?
 30364 000056A0 7302                    	JAE	short Map16		; MZ yes, do 16 bit algorithm
 30365 000056A2 D1E8                    	SHR	AX,1			; AX = BX/2
 30366                                  Map16:	
 30367                                  	; MSDOS 6.0			; MZ skip prev => AX=2*BX
 30368 000056A4 31FF                    	XOR	DI,DI ; *		; >32mb fat ;AN000;
 30369                                  	; MSDOS 3.3 (& MSDOS 6.0)
 30370 000056A6 01D8                    	ADD	AX,BX			; AX = 1.5*fat = byte offset in fat
 30371 000056A8 11FF                    	ADC	DI,DI ; * MSDOS 6.0	; >32mb fat ;DI is zero before op;AN000;
 30372 000056AA 268B4E02                	MOV	CX,[ES:BP+DPB.SECTOR_SIZE]
 30373                                  
 30374                                  ;IF FastDiv
 30375                                  ;
 30376                                  ; Gross hack: 99% of all disks have 512 bytes per sector. We test for this
 30377                                  ; case and apply a really fast algorithm to get the desired results
 30378                                  ;
 30379                                  ; Divide method takes 157+4*4=173 (MOV and DIV)
 30380                                  ; Fast method takes 39+20*4=119
 30381                                  ;
 30382                                  ; This saves a bunch.
 30383                                  
 30384 000056AE 81F90002                	CMP	CX,512			; 4  Is this 512 byte sector?
 30385 000056B2 7510                    	jne	short _DoDiv		; 4  for no jump
 30386 000056B4 89C2                    	MOV	DX,AX			; 2  get set for remainder
 30387 000056B6 81E2FF01                	AND	DX,512-1		; 4  Form remainder
 30388 000056BA 88E0                    	MOV	AL,AH			; 2  Quotient in formation in AL
 30389                                  	; MDOS 3.3
 30390                                  	;shr	al,1	
 30391                                  	; MDOS 6.0
 30392 000056BC D1EF                    	shr	di,1			; 2
 30393 000056BE D0D8                    	rcr	al,1			; 2
 30394                                  	; MDOS 3.3 (& MSDOS 6.0)
 30395 000056C0 30E4                    	xor	ah,ah			; 3
 30396 000056C2 EB04                    	jmp	short DivDone		; 16
 30397                                  _DoDiv:
 30398                                  ;ENDIF
 30399                                  	; MSDOS 3.3
 30400                                  	;xor	dx,dx
 30401                                  	; MSDOS 6.0
 30402 000056C4 89FA                    	mov	dx,di			; 2
 30403                                  	; MSDOS 3.3 (& MSDOS 6.0)	
 30404 000056C6 F7F1                    	DIV	CX			; 155 AX is FAT sector # DX is sector index
 30405                                  ;IF FastDiv
 30406                                  DivDone:
 30407                                  ;ENDIF
 30408                                  	;add	ax,[es:bp+6]
 30409 000056C8 26034606                	ADD	AX,[ES:BP+DPB.FIRST_FAT]
 30410 000056CC 49                      	DEC	CX			; CX is sector size - 1
 30411                                  	;SAVE	<AX,DX,CX>
 30412 000056CD 50                      	push	ax
 30413 000056CE 52                      	push	dx
 30414 000056CF 51                      	push	cx
 30415 000056D0 89C2                    	MOV	DX,AX
 30416                                  
 30417                                  	; MSDOS 6.0
 30418                                  	; 22/09/2023
 30419                                  	;MOV	word [HIGH_SECTOR],0 ; *! ;F.C. >32mb  low sector #
 30420                                  	;
 30421                                  	; MDOS 3.3 (& MSDOS 6.0)
 30422                                  	;XOR	AL,AL	   ; *
 30423                                  	;MOV	SI,1	   ; *
 30424                                  	;;invoke GETBUFFRB ; *
 30425                                  	;call	GETBUFFRB  ; *
 30426                                  	; 22/09/2023
 30427 000056D2 E8D402                  	call	GETBUFFRC  ; *!
 30428                                  
 30429                                  	;RESTORE <CX,AX,DX>		; CX is sec siz-1, AX is offset in sec
 30430 000056D5 59                      	pop	cx
 30431 000056D6 58                      	pop	ax
 30432 000056D7 5A                      	pop	dx
 30433 000056D8 724C                    	JC	short MAP_POP
 30434                                  
 30435 000056DA C536[E205]              	LDS	SI,[CURBUF]
 30436                                  	;;lea	di,[si+16]
 30437                                  	;lea	di,[si+20] ; MSDOS 6.0
 30438 000056DE 8D7C14                  	LEA	DI,[SI+BUFINSIZ]
 30439 000056E1 01C7                    	ADD	DI,AX
 30440 000056E3 39C8                    	CMP	AX,CX
 30441 000056E5 752C                    	JNZ	short MAPRET
 30442 000056E7 8A05                    	MOV	AL,[DI]
 30443                                  	;Context DS		 	;hkn; SS is DOSDATA
 30444 000056E9 16                      	push	ss
 30445 000056EA 1F                      	pop	ds	
 30446 000056EB FE06[7805]              	INC	BYTE [CLUSSPLIT]
 30447 000056EF A2[8E05]                	MOV	[CLUSSAVE],AL
 30448 000056F2 8916[9005]              	MOV	[CLUSSEC],DX
 30449                                  	; MSDOS 6.0
 30450 000056F6 C706[9205]0000          	MOV	WORD [CLUSSEC+2],0      ;F.C. >32mb	;AN000;
 30451 000056FC 42                      	INC	DX
 30452                                  
 30453                                  	; 22/09/2023
 30454                                  	;MOV	word [HIGH_SECTOR],0 ; *! ;F.C. >32mb FAT sector <32mb ;AN000;
 30455                                  	;
 30456                                  	; MDOS 3.3 (& MSDOS 6.0)
 30457                                  	;XOR	AL,AL	   ; *
 30458                                  	;MOV	SI,1	   ; *
 30459                                  	;;invoke GETBUFFRB ; *
 30460                                  	;call	GETBUFFRB  ; *
 30461                                  	; 22/09/2023
 30462 000056FD E8A902                  	call	GETBUFFRC  ; *!
 30463 00005700 7224                    	JC	short MAP_POP
 30464                                  
 30465 00005702 C536[E205]              	LDS	SI,[CURBUF]
 30466 00005706 8D7C14                  	LEA	DI,[SI+BUFINSIZ]
 30467 00005709 8A05                    	MOV	AL,[DI]
 30468                                  	;Context DS			;hkn; SS is DOSDATA
 30469 0000570B 16                      	push	ss
 30470 0000570C 1F                      	pop	ds
 30471 0000570D A2[8F05]                	MOV	[CLUSSAVE+1],AL
 30472                                  
 30473                                  ;hkn; CLUSSAVE is in DOSDATA
 30474 00005710 BF[8E05]                	MOV	DI,CLUSSAVE
 30475                                  MAPRET:
 30476                                  	;RESTORE <DX,CX,BX>
 30477 00005713 5A                      	pop	dx
 30478 00005714 59                      	pop	cx
 30479 00005715 5B                      	pop	bx
 30480 00005716 31C0                    	XOR	AX,AX			; MZ allow shift to clear carry
 30481 00005718 26817E0DF60F            	CMP	word [ES:BP+DPB.MAX_CLUSTER],4096-10 ; MZ is this 16-bit fat?
 30482 0000571E 7302                    	JAE	short MapSet		; MZ no, set flags
 30483 00005720 89D8                    	MOV	AX,BX
 30484                                  MapSet:
 30485 00005722 A801                    	TEST	AL,1			; set zero flag if not on boundary
 30486                                  	;RESTORE <AX>
 30487 00005724 58                      	pop	ax
 30488 00005725 C3                      	retn
 30489                                  
 30490                                  MAP_POP:
 30491                                  	;RESTORE <DX,CX,BX,AX>
 30492 00005726 5A                      	pop	dx
 30493 00005727 59                      	pop	cx
 30494 00005728 5B                      	pop	bx
 30495 00005729 58                      	pop	ax
 30496                                  fatread_sft_retn: ; 17/12/2022
 30497 0000572A C3                      	retn
 30498                                  
 30499                                  ; 20/05/2019 - Retro DOS v4.0
 30500                                  ; DOSCODE:96B3h (MSDOS 6.21, MSDOS.SYS)
 30501                                  ; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 30502                                  ; DOSCODE:9657h (MSDOS 5.0, MSDOS.SYS)
 30503                                  
 30504                                  ;Break	<FATREAD_SFT/FATREAD_CDS -- CHECK DRIVE GET FAT>
 30505                                  ;----------------------------------------------------------------------------
 30506                                  ;
 30507                                  ; Procedure Name : FATREAD_SFT
 30508                                  ;
 30509                                  ; Inputs:
 30510                                  ;	ES:DI points to an SFT for the drive of intrest (local only,
 30511                                  ;		giving a NET SFT will produce system crashing results).
 30512                                  ;	DS DOSDATA
 30513                                  ; Function:
 30514                                  ;	Can be used by an SFT routine (like CLOSE) to invalidate buffers
 30515                                  ;	if disk changed.
 30516                                  ;	In other respects, same as FATREAD_CDS.
 30517                                  ;	(note ES:DI destroyed!)
 30518                                  ; Outputs:
 30519                                  ;	Carry set if error (currently user FAILed to I 24)
 30520                                  ; NOTE: This routine may cause FATREAD_CDS to "miss" a disk change
 30521                                  ;	as far as invalidating curdir_ID is concerned.
 30522                                  ;	Since getting a true disk changed on this call is a screw up
 30523                                  ;	anyway, that's the way it goes.
 30524                                  ;
 30525                                  ;---------------------------------------------------------------------------
 30526                                  
 30527                                  FATREAD_SFT:
 30528 0000572B 26C46D07                	LES	BP,[ES:DI+SF_ENTRY.sf_devptr]
 30529                                  	; 27/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 30530                                  	;MOV	AL,[ES:BP+DPB.DRIVE] ; [es:bp+0]
 30531                                  	; 15/12/2022
 30532 0000572F 268A4600                	mov	AL,[ES:BP]
 30533 00005733 A2[7605]                	MOV	[THISDRV],AL
 30534 00005736 E808AF                  	call	GOTDPB			;Set THISDPB
 30535                                  	;CALL	FAT_GOT_DPB
 30536                                  	; 17/12/2022
 30537 00005739 EB78                    	jmp	FAT_GOT_DPB
 30538                                  ;fatread_sft_retn:
 30539                                  	;retn
 30540                                  
 30541                                  ;----------------------------------------------------------------------------
 30542                                  ;
 30543                                  ; Procedure Name : FATREAD_CDS
 30544                                  ;
 30545                                  ; Inputs:
 30546                                  ;	DS:DOSDATA
 30547                                  ;	ES:DI points to an CDS for the drive of intrest (local only,
 30548                                  ;		giving a NET or NUL CDS will produce system crashing results).
 30549                                  ; Function:
 30550                                  ;	If disk may have been changed, media is determined and buffers are
 30551                                  ;	flagged invalid. If not, no action is taken.
 30552                                  ; Outputs:
 30553                                  ;	ES:BP = Drive parameter block
 30554                                  ;	THISDPB = ES:BP
 30555                                  ;	THISDRV set
 30556                                  ;	Carry set if error (currently user FAILed to I 24)
 30557                                  ; DS preserved , all other registers destroyed
 30558                                  ;
 30559                                  ;---------------------------------------------------------------------------
 30560                                  
 30561                                  	; 20/05/2019 - Retro DOS v4.0
 30562                                  	; DOSCODE:96C5h (MSDOS 6.21, MSDOS.SYS)
 30563                                  	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 30564                                  	; DOSCODE:9669h (MSDOS 5.0, MSDOS.SYS)
 30565                                  
 30566                                  FATREAD_CDS:
 30567 0000573B 06                      	PUSH	ES
 30568 0000573C 57                      	PUSH	DI
 30569                                  	;les	bp,[es:di+45h]
 30570 0000573D 26C46D45                	LES	BP,[ES:DI+curdir.devptr]
 30571                                  	; 27/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 30572                                  	;MOV	AL,[ES:BP+DPB.DRIVE] ; [es:bp+0]
 30573                                  	; 15/12/2022
 30574 00005741 268A4600                	mov	AL,[ES:BP]
 30575 00005745 A2[7605]                	MOV	[THISDRV],AL
 30576 00005748 E8F6AE                  	call	GOTDPB			;Set THISDPB
 30577 0000574B E86500                  	CALL	FAT_GOT_DPB
 30578 0000574E 5F                      	POP	DI			;Get back CDS pointer
 30579 0000574F 07                      	POP	ES
 30580 00005750 72D8                    	jc	short fatread_sft_retn
 30581 00005752 7538                    	JNZ	short NO_CHANGE		;Media NOT changed
 30582                                  
 30583                                  ;	Media changed. We now need to find all CDS structures which use this
 30584                                  ;	DPB and invalidate their ID pointers.
 30585                                  
 30586                                  MED_CHANGE:
 30587 00005754 31C0                    	XOR	AX,AX
 30588 00005756 48                      	DEC	AX			; AX = -1
 30589 00005757 1E                      	PUSH	DS
 30590 00005758 8A0E[4700]              	MOV	CL,[CDSCOUNT]
 30591 0000575C 30ED                    	XOR	CH,CH			; CX is number of structures
 30592                                  	;lds	si,[es:di+45h]
 30593 0000575E 26C57545                	LDS	SI,[ES:DI+curdir.devptr] ; Find all CDS with this devptr
 30594                                  
 30595                                  ;hkn; SS override
 30596                                  
 30597                                  ;	Find all CDSs with this DevPtr
 30598                                  ;
 30599                                  ;	(ax) = -1
 30600                                  ;	(ds:si) = DevPtr
 30601                                  
 30602 00005762 36C43E[3C00]            	LES	DI,[SS:CDSADDR]		; (es:di) = CDS pointer
 30603                                  frcd20: 
 30604                                  	;;test	word [es:di+43h],8000h
 30605                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet
 30606 00005767 26F6454480              	TEST	byte [ES:DI+curdir.flags+1],(curdir_isnet>>8)
 30607 0000576C 7518                    	JNZ	short frcd25		; Leave NET guys alone!!
 30608                                  
 30609                                  	; MSDOS 3.3
 30610                                  	;push	es
 30611                                  	;push	di
 30612                                  	;les	di,[es:di+45h]
 30613                                  	;;les	di,[ES:DI+curdir.devptr]
 30614                                  	;call	POINTCOMP
 30615                                  	;pop	di
 30616                                  	;pop	es
 30617                                  	;jnz	short frcd25
 30618                                  
 30619                                  	; MSDOS 6.0
 30620 0000576E 263B7545                	cmp	si,[ES:DI+curdir.devptr]
 30621 00005772 7512                    	jne	short frcd25		; no match
 30622 00005774 8CDB                    	mov	bx,ds
 30623 00005776 263B5D47                	cmp	bx,[ES:DI+curdir.devptr+2]
 30624 0000577A 750A                    	jne	short frcd25		; CDS not for this drive
 30625                                  
 30626                                  	; MSDOS 3.3 (& MSDOS 6.0)
 30627                                  	;test	[es:di+49h],ax
 30628 0000577C 26854549                	test	[ES:DI+curdir.ID],AX
 30629 00005780 7404                    	JZ	short frcd25		; If root (0), leave root
 30630                                  	;mov	[es:di+49h],ax
 30631 00005782 26894549                	MOV	[ES:DI+curdir.ID],AX	; else invalid
 30632                                  frcd25:	
 30633                                  	;;add	di,81  ; MSDOS 3.3
 30634                                  	;add	di,88  ; MSDOS 6.0	 
 30635 00005786 83C758                  	ADD	DI,curdir.size		; Point to next CDS
 30636 00005789 E2DC                    	LOOP	frcd20
 30637 0000578B 1F                      	POP	DS
 30638                                  NO_CHANGE:
 30639 0000578C C42E[8A05]              	LES	BP,[THISDPB]
 30640 00005790 F8                      	CLC
 30641 00005791 C3                      	retn
 30642                                  
 30643                                  ;Break	<Fat_Operation - miscellaneous fat stuff>
 30644                                  ;----------------------------------------------------------------------------
 30645                                  ;
 30646                                  ; Procedure Name : FAT_operation
 30647                                  ;
 30648                                  ;----------------------------------------------------------------------------
 30649                                  
 30650                                  	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 30651                                  
 30652                                  FAT_operation:
 30653                                  	; 31/07/2018 - Retro DOS v3.0
 30654                                  FATERR:
 30655                                  	;mov	word [es:bp+1Eh],-1
 30656                                  	;mov	word [es:bp+1Fh],-1 ; MSDOS 6.0
 30657 00005792 26C7461FFFFF            	MOV	word [ES:BP+DPB.FREE_CNT],-1 
 30658                                  					; Err in FAT must force recomp of freespace
 30659                                  	;and	di,0FFh
 30660 00005798 81E7FF00                	AND	DI,STECODE		; Put error code in DI
 30661                                  	;mov	byte [ALLOWED],18h
 30662 0000579C C606[4B03]18            	MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
 30663                                  	;mov	ah,1Ah
 30664 000057A1 B41A                    	MOV	AH,2+Allowed_FAIL+Allowed_RETRY ; While trying to read FAT
 30665 000057A3 A0[7605]                	MOV	AL,[THISDRV]		; Tell which drive
 30666 000057A6 E813FC                  	call	FATAL1
 30667 000057A9 C42E[8A05]              	LES	BP,[THISDPB]
 30668 000057AD 3C03                    	CMP	AL,3
 30669 000057AF 7502                    	JNZ	short FAT_GOT_DPB	; User said retry
 30670 000057B1 F9                      	STC				; User said FAIL
 30671 000057B2 C3                      	retn
 30672                                  
 30673                                  FAT_GOT_DPB:
 30674                                  	;Context DS			;hkn; SS is DOSDATA
 30675 000057B3 16                      	push	ss			
 30676 000057B4 1F                      	pop	ds
 30677                                  	;mov	al,0Fh
 30678 000057B5 B00F                    	MOV	AL,DMEDHL
 30679                                  	;mov	ah,[es:bp+1]
 30680 000057B7 268A6601                	MOV	AH,[ES:BP+DPB.UNIT] 
 30681 000057BB A3[5A03]                	MOV	[DEVCALL_REQLEN],AX ; 09/09/2018 
 30682 000057BE C606[5C03]01            	MOV	BYTE [DEVCALL_REQFUNC],DEVMDCH
 30683 000057C3 C706[5D03]0000          	MOV	word [DEVCALL_REQSTAT],0
 30684                                  	;;mov	al,[es:bp+16h]
 30685                                  	;mov	al,[es:bp+17h] ; MSDOS 6.0
 30686 000057C9 268A4617                	MOV	AL,[ES:BP+DPB.MEDIA]
 30687 000057CD A2[6703]                	MOV	[CALLMED],AL
 30688 000057D0 06                      	PUSH	ES
 30689 000057D1 1E                      	PUSH	DS
 30690                                  
 30691                                  ;hkn; DEVCALL is in DOSDATA
 30692 000057D2 BB[5A03]                	MOV	BX,DEVCALL
 30693                                  	;;lds	si,[es:bp+12h]
 30694                                  	;lds	si,[es:bp+13h] ; MSDOS 6.0
 30695 000057D5 26C57613                	LDS	SI,[ES:BP+DPB.DRIVER_ADDR] ; DS:SI Points to device header
 30696 000057D9 07                      	POP	ES			; ES:BX Points to call header
 30697 000057DA E8FAEE                  	call	DEVIOCALL2
 30698                                  	;Context DS		 	;hkn; SS is DOSDATA
 30699 000057DD 16                      	push	ss
 30700 000057DE 1F                      	pop	ds
 30701 000057DF 07                      	POP	ES			; Restore ES:BP
 30702 000057E0 8B3E[5D03]              	MOV	DI,[DEVCALL_REQSTAT]
 30703                                  	;test	di,8000h
 30704                                  	;jnz	short FATERR
 30705 000057E4 09FF                    	or	di,di
 30706 000057E6 78AA                    	js	short FATERR		; have error
 30707 000057E8 30E4                    	XOR	AH,AH
 30708                                  	;xchg	ah,[es:bp+17h] ; MSDOS 3.3
 30709                                  	;xchg	ah,[es:bp+18h] ; MSDOS 6.0
 30710 000057EA 26866618                	XCHG	AH,[ES:BP+DPB.FIRST_ACCESS] ; Reset dpb_first_access
 30711 000057EE A0[7605]                	MOV	AL,[THISDRV]		; Use physical unit number
 30712                                  ; See if we had changed volume id by creating one on the diskette
 30713 000057F1 3806[A10A]              	cmp	[VOLCHNG_FLAG],AL
 30714 000057F5 7508                    	jnz	short CHECK_BYT
 30715 000057F7 C606[A10A]FF            	mov	byte [VOLCHNG_FLAG],-1
 30716 000057FC E9A500                  	jmp	GOGETBPB		; Need to get device driver to read in
 30717                                  					; new volume label.
 30718                                  CHECK_BYT:
 30719 000057FF 0A26[6803]              	OR	AH,[CALLRBYT]
 30720                                  	;JNS	short CHECK_ZR		; ns = 0 or 1
 30721                                  	;JMP	short NEWDSK
 30722                                  	; 17/12/2022
 30723 00005803 7863                    	js	short NEWDSK
 30724                                  	; 27/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 30725                                  	;JNS	short CHECK_ZR		; ns = 0 or 1
 30726                                  	;JMP	short NEWDSK
 30727                                  
 30728                                  CHECK_ZR:
 30729 00005805 743B                    	JZ	short CHKBUFFDIRT	; jump if I don't know
 30730                                  	; 24/09/2023
 30731                                  	; cf=0 (after 'or' instruction)
 30732                                  	;CLC
 30733 00005807 C3                      	retn				; If Media not changed (NZ)
 30734                                  
 30735                                  DISK_CHNG_ERR:
 30736 00005808 06                      	PUSH	ES
 30737 00005809 55                      	PUSH	BP
 30738                                  	;;les	bp,[es:bp+12h]
 30739                                  	;les	bp,[es:bp+13h] ; MSDOS 6.0
 30740 0000580A 26C46E13                	LES	BP,[ES:BP+DPB.DRIVER_ADDR] ; Get device pointer
 30741                                  	;;test	word [es:bp+4],800h
 30742                                  	;TEST	word [ES:BP+SYSDEV.ATT],DEVOPCL ; Did it set vol id?
 30743 0000580E 26F6460508              	test	byte [es:bp+SYSDEV.ATT+1],(DEVOPCL>>8)
 30744 00005813 5D                      	POP	BP
 30745 00005814 07                      	POP	ES
 30746 00005815 7426                    	JZ	short FAIL_OPJ2		; Nope, FAIL
 30747 00005817 1E                      	PUSH	DS			; Save buffer pointer for ignore
 30748 00005818 57                      	PUSH	DI
 30749 00005819 16                      	push	ss			;hkn; SS is DOSDATA
 30750 0000581A 1F                      	pop	ds
 30751                                  	;mov	byte [ALLOWED],18h
 30752 0000581B C606[4B03]18            	MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
 30753 00005820 06                      	PUSH	ES
 30754 00005821 C43E[6903]              	LES	DI,[CALLVIDM]		; Get volume ID pointer
 30755 00005825 8C06[2A03]              	MOV	[EXTERRPT+2],ES
 30756 00005829 07                      	POP	ES
 30757 0000582A 893E[2803]              	MOV	[EXTERRPT],DI
 30758                                  	;mov	ax,0Fh
 30759 0000582E B80F00                  	MOV	AX,error_I24_wrong_disk
 30760 00005831 C606[7505]01            	MOV	byte [READOP],1		; Write
 30761                                  	;invoke	HARDERR
 30762 00005836 E831FB                  	call	HARDERR
 30763 00005839 5F                      	POP	DI			; Get back buffer for ignore
 30764 0000583A 1F                      	POP	DS
 30765 0000583B 3C03                    	CMP	AL,3
 30766                                  FAIL_OPJ2:
 30767 0000583D 741C                    	JZ	short FAIL_OP
 30768 0000583F E971FF                  	JMP	FAT_GOT_DPB		; Retry
 30769                                  
 30770                                  CHKBUFFDIRT:
 30771                                  	; 20/05/2019 - Retro DOS v4.0
 30772                                  
 30773                                  	; MSDOS 3.3
 30774                                  	;lds	di,[BUFFHEAD]
 30775                                  
 30776                                  	; MSDOS 6.0
 30777 00005842 36833E[7100]00          	cmp	word [ss:DirtyBufferCount],0	; any dirty buffers ? ;hkn;
 30778 00005848 741E                    	je	short NEWDSK			; no, skip the check
 30779 0000584A E8F700                  	call	GETCURHEAD			; get pointer to first buffer
 30780                                  nbuffer:
 30781                                  	;cmp	al,[di+4]
 30782 0000584D 384504                  	cmp	[di+BUFFINFO.buf_ID],al	; Unit OK ?
 30783 00005850 750D                    	jne	short lfnxt			; no, go for next buffer
 30784                                  	;test   byte [di+5],40h
 30785 00005852 F6450540                	TEST	byte [di+BUFFINFO.buf_flags],buf_dirty	; is the buffer dirty ?
 30786 00005856 7407                    	jz	short lfnxt			; no, go for next buffer
 30787                                  	;Context DS
 30788 00005858 16                      	push	ss
 30789 00005859 1F                      	pop	ds
 30790                                  	; 24/09/2023
 30791                                  	; cf=0 (after 'test' instruction)
 30792                                  	;clc
 30793 0000585A C3                      	retn
 30794                                  
 30795                                  FAIL_OP:					; This label & code is here
 30796                                  	;Context DS				;  for reachability
 30797 0000585B 16                      	push	ss
 30798 0000585C 1F                      	pop	ds
 30799 0000585D F9                      	STC
 30800 0000585E C3                      	retn
 30801                                  
 30802                                  lfnxt:
 30803                                  	; 15/08/2018 - Retro DOS v3.0
 30804                                  	; MSDOS 3.3
 30805                                  	;lds	di,[di]
 30806                                  
 30807                                  	; 20/05/2019 - Retro DOS v4.0
 30808 0000585F 8B3D                    	mov	di,[di]
 30809                                  	;;mov	di,[di+BUFFINFO.buf_next]	; get next buffer
 30810                                  	
 30811                                  	; MSDOS 3.3
 30812                                  	;cmp	di,-1
 30813                                  	;jne	short nbuffer
 30814                                  	
 30815                                  	; MSDOS 6.0
 30816 00005861 36393E[BA0E]            	cmp	[ss:FIRST_BUFF_ADDR],di		; is this where we started ?;hkn;
 30817 00005866 75E5                    	jne	short nbuffer			; no, check this guy also
 30818                                  
 30819                                  ; If no dirty buffers, assume Media changed
 30820                                  NEWDSK:
 30821                                  	;;mov	word [es:bp+1Eh],0FFFFh  ; MSDOS 3.3
 30822                                  	;mov	word [es:bp+1Fh],0FFFFh  ; MSDOS 6.0
 30823 00005868 26C7461FFFFF            	mov	word [ES:BP+DPB.FREE_CNT],-1	; Media changed, must
 30824                                  						;  recompute
 30825                                  	; MSDOS 3.3
 30826                                  	;call	SETVISIT
 30827                                  	; MSDOS 6.0
 30828 0000586E E8D300                  	call	 GETCURHEAD
 30829                                  nxbuffer:
 30830                                  	; MSDOS 3.3
 30831                                  	;or 	byte [di+5],20h
 30832                                  	; MSDOS 3.3 & MSDOS 6.0
 30833                                  	;cmp	[di+4],al
 30834 00005871 384504                  	cmp	[DI+BUFFINFO.buf_ID],al		; This drive ?
 30835 00005874 7510                    	jne	short lfnxt2
 30836                                  	;test	byte [di+5],40h
 30837 00005876 F6450540                	TEST	byte [DI+BUFFINFO.buf_flags],buf_dirty
 30838 0000587A 758C                    	jnz	short DISK_CHNG_ERR
 30839                                  	;mov	word [di+4],20FFh
 30840 0000587C C74504FF20              	mov	word [DI+BUFFINFO.buf_ID],(buf_visit*256)+0FFh ; free up
 30841 00005881 E8D200                  	call	SCANPLACE
 30842                                  	; MSDOS 6.0
 30843 00005884 EB02                    	jmp	short skpbuff
 30844                                  lfnxt2:
 30845 00005886 8B3D                    	mov	di,[di]
 30846                                  	;mov	di,[di+BUFFINFO.buf_next]
 30847                                  skpbuff:
 30848                                  	; MSDOS 6.0
 30849 00005888 363B3E[BA0E]            	cmp	di,[ss:FIRST_BUFF_ADDR]					;hkn;
 30850 0000588D 75E2                    	jne	short nxbuffer
 30851                                  
 30852 0000588F 36833E[7700]00          	CMP	word [ss:SC_CACHE_COUNT],0 ;LB.  look ahead buffers ?	;AN001;
 30853 00005895 740D                    	JZ	short GOGETBPB		;LB.  no			;AN001;
 30854 00005897 363A06[B00D]            	CMP	AL,[ss:CurSC_DRIVE]	;LB.  same as changed drive	;AN001;
 30855 0000589C 7506                    	JNZ	short GOGETBPB		;LB.  no			;AN001;
 30856 0000589E 36C606[B00D]FF          	MOV	byte [ss:CurSC_DRIVE],-1 ;LB.  invalidate look ahead buffers ;AN000;
 30857                                  ;lfnxt2:
 30858                                  	; MSDOS 3.3
 30859                                  	;call	SKIPVISIT
 30860                                  	;jnz	short nxbuffer
 30861                                  GOGETBPB:
 30862                                  	; MSDOS 3.3 & MSDOS 6.0
 30863                                  	;;lds	di,[es:bp+12h]
 30864                                  	;lds	di,[es:bp+13h] ; MSDOS 6.0	
 30865 000058A4 26C57E13                	LDS	DI,[ES:BP+DPB.DRIVER_ADDR]
 30866                                  	; 20/05/2019
 30867                                  	;test	word [di+4],2000h
 30868                                  	;TEST	word [DI+SYSDEV.ATT],ISFATBYDEV
 30869 000058A8 F6450520                	TEST	byte [DI+SYSDEV.ATT+1],(ISFATBYDEV>>8)
 30870 000058AC 7510                    	JNZ	short GETFREEBUF
 30871                                  	;context DS	    		;hkn; SS is DOSDATA
 30872 000058AE 16                      	push	ss
 30873 000058AF 1F                      	pop	ds
 30874 000058B0 BB0200                  	MOV	BX,2
 30875 000058B3 E8EEFC                  	CALL	UNPACK			; Read the first FAT sector into CURBUF
 30876                                  FAIL_OPJ:
 30877 000058B6 72A3                    	JC	short FAIL_OP
 30878 000058B8 C53E[E205]              	LDS	DI,[CURBUF]
 30879 000058BC EB13                    	JMP	SHORT GOTGETBUF
 30880                                  
 30881                                  GETFREEBUF:
 30882 000058BE 06                      	PUSH	ES			; Get a free buffer for BIOS to use
 30883 000058BF 55                      	PUSH	BP
 30884                                  	; MSDOS 3.3
 30885                                  	;LDS	DI,[SS:BUFFHEAD] ; 15/08/2018
 30886                                  	; MSDOS 6.0
 30887 000058C0 31D2                    	XOR	DX,DX			;LB.  fake to get 1st	  ;AN000;
 30888                                  ;hkn; SS override
 30889 000058C2 368916[0706]            	MOV	[SS:HIGH_SECTOR],DX ; 0	;LB.  buffer addr	  ;AN000;
 30890 000058C7 E87A00                  	call	GETCURHEAD		;LB.			  ;AN000;
 30891                                  	; MSDOS 3.3 & MSDOS 6.0
 30892 000058CA E85502                  	call	BUFWRITE
 30893 000058CD 5D                      	POP	BP
 30894 000058CE 07                      	POP	ES
 30895                                  	;JC	short FAIL_OPJ
 30896 000058CF 728A                    	jc	short FAIL_OP
 30897                                  GOTGETBUF:
 30898                                  	;;add	di,16
 30899                                  	;add	di,20 ; MSDOS 6.0
 30900 000058D1 83C714                  	ADD	DI,BUFINSIZ
 30901                                  
 30902                                  ;hkn; SS override
 30903 000058D4 368C1E[6A03]            	MOV	[SS:CALLXAD+2],DS
 30904                                  	;Context DS			;hkn; SS is DOSDATA
 30905 000058D9 16                      	push	ss
 30906 000058DA 1F                      	pop	ds
 30907 000058DB 893E[6803]              	MOV	[CALLXAD],DI
 30908                                  	;mov	al,16h
 30909 000058DF B016                    	MOV	AL,DBPBHL
 30910                                  	;mov	ah,[es:bp+1]
 30911 000058E1 268A6601                	MOV	AH,[ES:BP+DPB.UNIT]
 30912 000058E5 A3[5A03]                	MOV	[DEVCALL_REQLEN],AX ; 09/09/2018
 30913 000058E8 C606[5C03]02            	MOV	BYTE [DEVCALL_REQFUNC],DEVBPB
 30914 000058ED C706[5D03]0000          	MOV	word [DEVCALL_REQSTAT],0
 30915                                  	;;mov	al,[es:bp+16h]
 30916                                  	;mov	al,[es:bp+17h]
 30917 000058F3 268A4617                	MOV	AL,[ES:BP+DPB.MEDIA]
 30918 000058F7 A2[6703]                	MOV	[CALLMED],AL
 30919 000058FA 06                      	PUSH	ES
 30920 000058FB 1E                      	PUSH	DS
 30921                                  	;;push	word [es:bp+14h]
 30922                                  	;push	word [es:bp+15h] ; MSDOS 6.0
 30923 000058FC 26FF7615                	PUSH	WORD [ES:BP+DPB.DRIVER_ADDR+2]
 30924                                  	;;push	word [es:bp+12h]
 30925                                  	;push	word [es:bp+13h] ; MSDOS 6.0
 30926 00005900 26FF7613                	PUSH	WORD [ES:BP+DPB.DRIVER_ADDR]
 30927                                  
 30928                                  ;hkn; DEVCALL is in DOSDATA
 30929 00005904 BB[5A03]                	MOV	BX,DEVCALL
 30930 00005907 5E                      	POP	SI
 30931 00005908 1F                      	POP	DS			; DS:SI Points to device header
 30932 00005909 07                      	POP	ES			; ES:BX Points to call header
 30933                                  	;invoke	DEVIOCALL2
 30934 0000590A E8CAED                  	call	DEVIOCALL2
 30935 0000590D 07                      	POP	ES			; Restore ES:BP
 30936                                  	;Context DS
 30937 0000590E 16                      	push	ss		 	;hkn; SS is DOSDATA
 30938 0000590F 1F                      	pop	ds
 30939 00005910 8B3E[5D03]              	MOV	DI,[DEVCALL_REQSTAT]
 30940                                  	; MSDOS 3.3
 30941                                  	;test	di,8000h
 30942                                  	;jnz	short FATERRJ
 30943                                  	; MSDOS 6.0
 30944 00005914 09FF                    	or	di,di
 30945 00005916 7829                    	js	short FATERRJ 		; have error
 30946                                  	;;mov	al,[es:bp+16h]
 30947                                  	;mov	al,[es:bp+17h]  ; MSDOS 6.0
 30948 00005918 268A4617                	MOV	AL,[ES:BP+DPB.MEDIA]
 30949 0000591C C536[6C03]              	LDS	SI,[CALLBPB]
 30950                                  	;;mov	word [es:bp+1Ch],0
 30951                                  	;mov	word [es:bp+1Dh],0 ; MSDOS 6.0
 30952 00005920 26C7461D0000            	MOV	word [ES:BP+DPB.NEXT_FREE],0 ; recycle scanning pointer
 30953                                  	;invoke	$SETDPB
 30954 00005926 E8F0B6                  	call	_$SETDPB
 30955                                  
 30956                                  ;hkn; SS override
 30957 00005929 36C53E[6803]            	LDS	DI,[SS:CALLXAD]		; Get back buffer pointer
 30958                                  	;mov	al,[es:bp+8]
 30959 0000592E 268A4608                	MOV	AL,[ES:BP+DPB.FAT_COUNT]
 30960                                  
 30961                                  	; MSDOS 3.3
 30962                                  	;;mov	ah,[es:bp+0Fh]
 30963                                  	;MOV	AH,[ES:BP+DPB.FAT_SIZE]
 30964                                  	;;mov	[DI-8],ax
 30965                                  	;MOV	[DI+BUFFINFO.buf_wrtcnt-BUFINSIZ],AX
 30966                                  
 30967                                  	; MSDOS 6.0
 30968                                  	;mov	[di-0Ah],al
 30969 00005932 8845F6                  	MOV	[DI+BUFFINFO.buf_wrtcnt-BUFINSIZ],AL 
 30970                                  						;>32mb		  ;AN000;
 30971                                  	;mov	ax,[es:bp+0Fh]
 30972 00005935 268B460F                	MOV	AX,[ES:BP+DPB.FAT_SIZE]		;>32mb
 30973                                  	;mov	[di-9h],ax			  ;AC000;
 30974 00005939 8945F7                  	MOV	[DI+BUFFINFO.buf_wrtcntinc-BUFINSIZ],AX 
 30975                                  					;>32mb Correct buffer info ;AC000;
 30976                                  	;Context DS			;hkn; SS is DOSDATA
 30977 0000593C 16                      	push	ss
 30978 0000593D 1F                      	pop	ds
 30979 0000593E 30C0                    	XOR	AL,AL			;Media changed (Z), Carry clear
 30980 00005940 C3                      	retn
 30981                                  
 30982                                  FATERRJ: 
 30983 00005941 E94EFE                  	JMP	FATERR
 30984                                  
 30985                                  ;============================================================================
 30986                                  ; STDBUF.ASM
 30987                                  ;============================================================================
 30988                                  ; Retro DOS v2.0 - 12/03/2018
 30989                                  
 30990                                  ;
 30991                                  ; Standard buffer management for MSDOS
 30992                                  ;
 30993                                  
 30994                                  ;.xlist
 30995                                  ;.xcref
 30996                                  ;INCLUDE STDSW.ASM
 30997                                  ;.cref
 30998                                  ;.list
 30999                                  
 31000                                  ;TITLE	STDBUF - MSDOS buffer management
 31001                                  ;NAME	STDBUF
 31002                                  
 31003                                  ;INCLUDE BUF.ASM
 31004                                  
 31005                                  ;============================================================================
 31006                                  ; BUF.ASM
 31007                                  ;============================================================================
 31008                                  ; 31/07/2018 - Retro DOS v3.0
 31009                                  ; Retro DOS v2.0 - 12/03/2018
 31010                                  ;
 31011                                  ; buffer management for MSDOS
 31012                                  ;
 31013                                  ;CODE	SEGMENT BYTE PUBLIC  'CODE'
 31014                                  ;       ASSUME  SS:DOSGROUP,CS:DOSGROUP
 31015                                  ;
 31016                                  ;SUBTTL SETVISIT,SKIPVISIT -- MANAGE BUFFER SCANS
 31017                                  ;
 31018                                  ;SETVISIT:
 31019                                  ;	; 31/07/2018 - Retro DOS v3.0
 31020                                  ;	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5CAFh
 31021                                  ;; Inputs:
 31022                                  ;;      None
 31023                                  ;; Function:
 31024                                  ;;      Set up a scan of I/O buffers
 31025                                  ;; Outputs:
 31026                                  ;;      All visit flags = 0
 31027                                  ;;              NOTE: This pre-scan is needed because a hard disk error
 31028                                  ;;                    may cause a scan to stop in the middle leaving some
 31029                                  ;;                    visit flags set, and some not set.
 31030                                  ;;      DS:DI Points to [BUFFHEAD]
 31031                                  ;; No other registers altered
 31032                                  ;
 31033                                  ;       LDS     DI,[SS:BUFFHEAD] ; 15/03/2018
 31034                                  ;	PUSH    AX
 31035                                  ;       ;;XOR	AX,AX	  ;; MSDOS 2.11
 31036                                  ;	;mov	al,0DFh
 31037                                  ;	mov	al,~buf_visit
 31038                                  ;SETLOOP:
 31039                                  ;       ;;MOV	[DI+7],AL ;; MSDOS 2.11
 31040                                  ;	;and	[DI+5],al
 31041                                  ;	AND	[DI+BUFFINFO.buf_flags],AL
 31042                                  ;       LDS     DI,[DI]
 31043                                  ;       CMP     DI,-1
 31044                                  ;       JNZ     SHORT SETLOOP
 31045                                  ;       POP     AX ; 09/09/2018
 31046                                  ;	LDS     DI,[SS:BUFFHEAD] ; 15/03/2018
 31047                                  ;SVISIT_RETN:
 31048                                  ;       RETN
 31049                                  ;
 31050                                  ;SKIPVISIT:
 31051                                  ;	; 31/07/2018 - Retro DOS v3.0
 31052                                  ;	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5CC8h
 31053                                  ;
 31054                                  ;; Inputs:
 31055                                  ;;      DS:DI Points to a buffer
 31056                                  ;; Function:
 31057                                  ;;      Skip visited buffers
 31058                                  ;; Outputs:
 31059                                  ;;      DS:DI Points to next unvisited buffer
 31060                                  ;;      Zero is set if skip to LAST buffer
 31061                                  ;; No other registers altered
 31062                                  ;
 31063                                  ;       CMP     DI,-1
 31064                                  ;       ;retz
 31065                                  ;       JZ	SHORT SVISIT_RETN
 31066                                  ;
 31067                                  ;	;;CMP	BYTE [DI+7],1 ;; MSDOS 2.11
 31068                                  ;       ;;;retnz
 31069                                  ;       ;;JNZ	SHORT SVISIT_RETN
 31070                                  ;
 31071                                  ;	;test	byte [di+5],20h
 31072                                  ;	TEST	byte [DI+BUFFINFO.buf_flags],buf_visit	
 31073                                  ;	JNZ	short SKIPLOOP
 31074                                  ;	
 31075                                  ;	push	ax
 31076                                  ;	or	al,1
 31077                                  ;	pop	ax
 31078                                  ;	retn	
 31079                                  ;
 31080                                  ;SKIPLOOP:
 31081                                  ;	LDS     DI,[DI]
 31082                                  ;       JMP     SHORT SKIPVISIT
 31083                                  
 31084                                  ;============================================================================
 31085                                  ; BUF.ASM, MSDOS 6.0, 1991
 31086                                  ;============================================================================
 31087                                  ; 31/07/2018 - Retro DOS v3.0
 31088                                  ; 04/05/2019 - Retro DOS v4.0
 31089                                  
 31090                                  ;	TITLE	BUF - MSDOS buffer management
 31091                                  ;	NAME	BUF
 31092                                  
 31093                                  ;**	BUF.ASM - Low level routines for buffer cache management
 31094                                  ;
 31095                                  ;	GETCURHEAD
 31096                                  ;	ScanPlace
 31097                                  ;	PLACEBUF
 31098                                  ;	PLACEHEAD
 31099                                  ;	PointComp
 31100                                  ;	GETBUFFR
 31101                                  ;	GETBUFFRB
 31102                                  ;	FlushBuf
 31103                                  ;	BufWrite
 31104                                  ;	SET_RQ_SC_PARMS
 31105                                  ;
 31106                                  ;	Revision history:
 31107                                  ;
 31108                                  ;		AN000  version 4.00  Jan. 1988
 31109                                  ;		A004   PTM 3765 -- Disk reset failed
 31110                                  ;		M039 DB 10/17/90 - Disk write optimization
 31111                                  ;		I001   5.0 PTR 722211 - Preserve CY when in buffer in HMA
 31112                                  
 31113                                  ;Break	<GETCURHEAD -- Get current buffer header>
 31114                                  ;----------------------------------------------------------------------------
 31115                                  ; Procedure Name : GetCurHead
 31116                                  ; Inputs:
 31117                                  ;	 No Inputs
 31118                                  ; Function:
 31119                                  ;	Returns the pointer to the first buffer in Queue
 31120                                  ;	and updates FIRST_BUFF_ADDR
 31121                                  ;       and invalidates LASTBUFFER (recency pointer)
 31122                                  ; Outputs:
 31123                                  ;	DS:DI = pointer to the first buffer in Queue
 31124                                  ;	FIRST_BUFF_ADDR = offset ( DI ) of First buffer in Queue
 31125                                  ;       LASTBUFFER = -1
 31126                                  ; No other registers altered
 31127                                  ;----------------------------------------------------------------------------
 31128                                  
 31129                                  ; 04/05/2019 - Retro DOS v4.0
 31130                                  ; DOSCODE:98D2h (MSDOS 6.21, MSDOS.SYS)
 31131                                  ; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 31132                                  ; DOSCODE:9876h (MSDOS 5.0, MSDOS.SYS)
 31133                                  
 31134                                  GETCURHEAD:
 31135 00005944 36C53E[6D00]            	lds	di,[ss:BufferQueue]	; Pointer to the first buffer
 31136 00005949 36C706[1E00]FFFF        	mov	word [ss:LastBuffer],-1	; invalidate last buffer
 31137 00005950 36893E[BA0E]            	mov	[ss:FIRST_BUFF_ADDR],di	;save first buffer addr
 31138 00005955 C3                      	retn
 31139                                  
 31140                                  ;Break	<SCANPLACE, PLACEBUF -- PUT A BUFFER BACK IN THE POOL>
 31141                                  ;----------------------------------------------------------------------------
 31142                                  ; Procedure Name : ScanPlace
 31143                                  ; Inputs:
 31144                                  ;	Same as PLACEBUF
 31145                                  ; Function:
 31146                                  ;	Save scan location and call PLACEBUF
 31147                                  ; Outputs:
 31148                                  ;	DS:DI Points to saved scan location
 31149                                  ; All registers, except DS:DI, preserved.
 31150                                  ;----------------------------------------------------------------------------
 31151                                  ;M039: Rewritten to preserve registers.
 31152                                  
 31153                                  ;SCANPLACE:
 31154                                  ;	; 31/07/2018 - Retro DOS v3.0
 31155                                  ;	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5DDCh
 31156                                  ;	push	es
 31157                                  ;	les	si,[di]
 31158                                  ;	;les	si,[DI+BUFFINFO.buf_link]
 31159                                  ;	call	PLACEBUF
 31160                                  ;	push	es
 31161                                  ;	pop	ds
 31162                                  ;	mov	di,si
 31163                                  ;	pop	es
 31164                                  ;scanplace_retn:
 31165                                  ;	retn	
 31166                                  	
 31167                                  	; MSDOS 6.0
 31168                                  SCANPLACE:
 31169 00005956 FF35                    	push	word [di]
 31170                                  	;push	word [di+BUFFINFO.buf_next] ;Save scan location
 31171 00005958 E80200                  	call	PLACEBUF
 31172 0000595B 5F                      	pop	di
 31173 0000595C C3                      	retn
 31174                                  
 31175                                  ;----------------------------------------------------------------------------
 31176                                  ; Procedure Name : PlaceBuf
 31177                                  ; Input:
 31178                                  ;	DS:DI points to buffer (DS->BUFFINFO array, DI=offset in array)
 31179                                  ; Function:
 31180                                  ;	Remove buffer from queue and re-insert it in proper place.
 31181                                  ; NO registers altered
 31182                                  ;----------------------------------------------------------------------------
 31183                                  
 31184                                  ;procedure PLACEBUF,NEAR
 31185                                  
 31186                                  	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 31187                                  	; 20/05/2019 - Retro DOS v4.0
 31188                                  PLACEBUF:
 31189                                  	; 31/07/2018 - Retro DOS v3.0
 31190                                  
 31191                                  	; MSDOS 6.0
 31192 0000595D 50                      	push	AX			;Save only regs we modify	;AN000;
 31193 0000595E 53                      	push	BX							;AN000;
 31194                                  	; 23/09/2023
 31195                                  	;push	SI							;AN000;
 31196                                  	
 31197 0000595F 8B05                    	mov	ax,[di]
 31198                                  	;mov	ax,[di+BUFFINFO.buf_next]
 31199 00005961 368B1E[6D00]            	mov	bx,[ss:BufferQueue]	; bx = offset of head of list;smr;SS Override
 31200                                  	
 31201 00005966 39D8                    	cmp	ax,bx				;Buf = last?		;AN000;
 31202 00005968 7422                    	je	short nret			;Yes, special case	;AN000;
 31203 0000596A 39DF                    	cmp	di,bx				;Buf = first?		;AN000;
 31204 0000596C 7506                    	jne	short not_first 		;Yes, special case	;AN000;
 31205 0000596E 36A3[6D00]              	mov	[ss:BufferQueue],ax		;smr;SS Override
 31206 00005972 EB18                    	jmp	short nret 			;Continue with repositioning;AN000;
 31207                                  not_first:
 31208                                  	; 23/09/2023
 31209 00005974 56                      	push	si
 31210                                  	;mov	si,[di+2]
 31211 00005975 8B7502                  	mov	SI,[DI+BUFFINFO.buf_prev]	;No, SI = prior Buf	;AN000;
 31212 00005978 8904                    	mov	[si],ax
 31213                                  	;mov	[SI+BUFFINFO.buf_next],AX	; ax has di->buf_next	;AN000;
 31214 0000597A 96                      	xchg	si,ax
 31215                                  	;mov	[si+2],ax
 31216 0000597B 894402                  	mov	[SI+BUFFINFO.buf_prev],AX	;			;AN000;
 31217                                  	
 31218 0000597E 8B7702                  	mov	SI,[BX+BUFFINFO.buf_prev]	;SI-> last buffer	;AN000;
 31219 00005981 893C                    	mov	[si],di
 31220                                  	;mov	[SI+BUFFINFO.buf_next],DI	;Add Buf to end of list ;AN000;
 31221 00005983 897F02                  	mov	[BX+BUFFINFO.buf_prev],DI				;AN000;
 31222 00005986 897502                  	mov	[DI+BUFFINFO.buf_prev],SI	;Update link in Buf too	;AN000;
 31223 00005989 891D                    	mov	[di],bx
 31224                                  	;mov	[DI+BUFFINFO.buf_next],BX				;AN000;
 31225                                  	; 23/09/2023
 31226 0000598B 5E                      	pop	si
 31227                                  nret:	
 31228                                  	; 23/09/2023							;AN000;
 31229                                  	;pop	SI							;AN000;
 31230 0000598C 5B                      	pop	BX							;AN000;
 31231 0000598D 58                      	pop	AX							;AN000;
 31232                                  									;AN000;
 31233                                  	;cmp	byte [di+4],0FFh
 31234 0000598E 807D04FF                	cmp	byte [di+BUFFINFO.buf_ID],-1	; Buffer FREE?		;AN000;
 31235 00005992 7505                            jne	short pbx			; M039: -no, jump.
 31236 00005994 36893E[6D00]            	mov	[ss:BufferQueue],di		; M039: -yes, make it LRU.
 31237                                  pbx:	
 31238 00005999 C3                      	retn								;AN000;
 31239                                  
 31240                                  	; 31/07/2018 - Retro DOS v3.0
 31241                                  
 31242                                  	; MSDOS 3.3
 31243                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5DDCh
 31244                                  
 31245                                  ;PLACEBUF:
 31246                                  ;	; 15/03/2018 - Retro DOS v2.0 (MSDOS 2.11)
 31247                                  ;	
 31248                                  ;       CALL	save_world
 31249                                  ;       LES     CX,[DI]
 31250                                  ;       CMP     CX,-1           	; Buf is LAST?
 31251                                  ;       JZ      SHORT NRET		; Buffer already last
 31252                                  ;       MOV     BP,ES           	; Pointsave = Buf.nextbuf
 31253                                  ;       PUSH    DS
 31254                                  ;       POP     ES              	; Buf is ES:DI
 31255                                  ;	; 15/03/2018
 31256                                  ;       LDS     SI,[SS:BUFFHEAD] 	; Curbuf = HEAD
 31257                                  ;       CALL    POINTCOMP       	; Buf == HEAD?
 31258                                  ;       JNZ     SHORT BUFLOOP
 31259                                  ;       MOV     [SS:BUFFHEAD],CX
 31260                                  ;       MOV     [SS:BUFFHEAD+2],BP	; HEAD = Pointsave
 31261                                  ;       JMP     SHORT LOOKEND
 31262                                  ;BUFLOOP:
 31263                                  ;	; 31/07/2018
 31264                                  ;	mov	ax,ds
 31265                                  ;	mov	bx,si
 31266                                  ;	;lds	si,[SI+BUFFINFO.buf_link]
 31267                                  ;       LDS     SI,[SI]
 31268                                  ;       CALL    POINTCOMP
 31269                                  ;       jnz	short BUFLOOP
 31270                                  ;	;
 31271                                  ;	mov	ds,ax
 31272                                  ;	mov	si,bx
 31273                                  ;	mov	[SI],cx
 31274                                  ;	;mov	[SI+BUFFINFO.buf_link],cx   ; If Curbuf.nextbuf == buf
 31275                                  ;	mov	[SI+2],bp
 31276                                  ;	;mov	[BX+BUFFINFO.buf_link+2],bp ; Curbuf.nextbuf = Pointsave
 31277                                  ;LOOKEND:
 31278                                  ;	mov	ax,ds
 31279                                  ;	mov	bx,si
 31280                                  ;       LDS     SI,[SI]
 31281                                  ;       CMP     SI,-1
 31282                                  ;       jnz     short LOOKEND
 31283                                  ;GOTHEEND:
 31284                                  ;       mov	ds,ax
 31285                                  ;	mov	[BX],di
 31286                                  ;	MOV     [BX+2],ES 		; Curbuf.nextbuf = Buf
 31287                                  ;       MOV     WORD [ES:DI],-1
 31288                                  ;	;mov	word [ES:DI+BUFFINFO.buf_link],-1
 31289                                  ;       MOV     WORD [ES:DI+2],-1 	; Buf is LAST
 31290                                  ;	;mov	word [ES:DI+BUFFINFO.buf_link+2],-1
 31291                                  ;NRET:
 31292                                  ;       CALL	restore_world
 31293                                  ;	
 31294                                  ;	;cmp	byte [di+4],-1
 31295                                  ;	cmp	byte [DI+BUFFINFO.buf_ID],-1  ; Free buffer ?
 31296                                  ;	jnz     short scanplace_retn
 31297                                  ;	call    PLACEHEAD
 31298                                  ;	retn
 31299                                  
 31300                                  ;EndProc PLACEBUF
 31301                                  
 31302                                  ;M039 - Removed PLACEHEAD.
 31303                                  ;----------------------------------------------------------------------------
 31304                                  ; places buffer at head
 31305                                  ;  NOTE:::::: ASSUMES THAT BUFFER IS CURRENTLY THE LAST
 31306                                  ;	ONE IN THE LIST!!!!!!!
 31307                                  ; BUGBUG ---- this routine can be removed because it has only
 31308                                  ; BUGBUG ---- one instruction. This routine is called from
 31309                                  ; BUGBUG ---- 3 places. ( Size = 3*3+6 = 15 bytes )
 31310                                  ; BUGBUG ---- if coded in line = 3 * 5 = 15 bytes
 31311                                  ; BUGBUG ---- But kept as it is for modularity
 31312                                  ;----------------------------------------------------------------------------
 31313                                  ;procedure   PLACEHEAD,NEAR
 31314                                  ;	mov	word ptr [BufferQueue], di
 31315                                  ;	ret
 31316                                  ;EndProc PLACEHEAD
 31317                                  ;M039
 31318                                  
 31319                                  ;----------------------------------------------------------------------------
 31320                                  ; Procedure Name : PLACEHEAD
 31321                                  ;
 31322                                  ; SAME AS PLACEBUF except places buffer at head
 31323                                  ;----------------------------------------------------------------------------
 31324                                  
 31325                                  	; MSDOS 3.3 (Retro DOS v3.0)
 31326                                  	; 05/09/2018
 31327                                  	; MSDOS 2.11 (Retro DOS v2.0)
 31328                                  ;PLACEHEAD:
 31329                                  ;	; 31/07/2018 - Retro DOS v3.0
 31330                                  ;	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5D4Ah
 31331                                  ;
 31332                                  ;       CALL	save_world
 31333                                  ;       PUSH	DS
 31334                                  ;       POP	ES
 31335                                  ;	; 15/03/2018 - Retro DOS v2.0 (MSDOS 2.11)
 31336                                  ;       LDS     SI,[SS:BUFFHEAD]
 31337                                  ;	; 31/07/2018 - Retro DOS v3.0 (MSDOS 3.3)
 31338                                  ;	CALL    POINTCOMP
 31339                                  ;       JZ      SHORT GOTHEEND2
 31340                                  ;	MOV	[ES:DI],SI
 31341                                  ;	;mov	[ES:DI+BUFFINFO.buf_link],si
 31342                                  ;       MOV	[ES:DI+2],DS
 31343                                  ;	;mov	[ES:DI+BUFFINFO.buf_link+2],ds
 31344                                  ;       MOV	[SS:BUFFHEAD],DI
 31345                                  ;       MOV	[SS:BUFFHEAD+2],ES
 31346                                  ;LOOKEND2:
 31347                                  ;       mov	ax,ds
 31348                                  ;	mov	bx,si
 31349                                  ;	;lds	si,[SI+BUFFINFO.buf_link]
 31350                                  ;       LDS     SI,[SI]
 31351                                  ;       CALL    POINTCOMP
 31352                                  ;       JNZ	SHORT LOOKEND2 ; 05/09/2018
 31353                                  ;       mov	ds,ax
 31354                                  ;	mov	word [bx],-1
 31355                                  ;	;mov	word [BX+BUFFINFO.buf_link],-1
 31356                                  ;	mov	word [bx+2],-1
 31357                                  ;	;mov	word [BX+BUFFINFO.buf_link+2],-1
 31358                                  ;GOTHEEND2:
 31359                                  ;      	call	restore_world
 31360                                  ;placehead_retn:
 31361                                  ;	retn
 31362                                  
 31363                                  ; 20/05/2019 - Retro DOS v4.0
 31364                                  ; DOSCODE:9928h (MSDOS 6.21, MSDOS.SYS)
 31365                                  
 31366                                  ;Break	<POINTCOMP -- 20 BIT POINTER COMPARE>
 31367                                  ;----------------------------------------------------------------------------
 31368                                  ;
 31369                                  ; Procedure Name : PointComp
 31370                                  ; Inputs:
 31371                                  ;         DS:SI & ES:DI
 31372                                  ; Function:
 31373                                  ;          Checks for ((SI==DI) && (ES==DS))
 31374                                  ;	   Assumes that pointers are normalized for the
 31375                                  ;	   same segment
 31376                                  ;
 31377                                  ; Compare DS:SI to ES:DI (or DS:DI to ES:SI) for equality
 31378                                  ; DO NOT USE FOR < or >
 31379                                  ; No Registers altered
 31380                                  ;
 31381                                  ;----------------------------------------------------------------------------
 31382                                  
 31383                                  POINTCOMP:
 31384                                  	; 31/07/2018 - Retro DOS v3.0
 31385                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5D84h
 31386 0000599A 39FE                    	CMP	SI,DI
 31387 0000599C 750A                    	jnz	short _ret_label	; return if nz
 31388                                  	;jnz	short placehead_retn 
 31389 0000599E 51                      	PUSH	CX
 31390 0000599F 52                      	PUSH	DX
 31391 000059A0 8CD9                    	MOV	CX,DS
 31392 000059A2 8CC2                    	MOV	DX,ES
 31393 000059A4 39D1                    	CMP	CX,DX
 31394 000059A6 5A                      	POP	DX
 31395 000059A7 59                      	POP	CX
 31396                                  _ret_label:
 31397 000059A8 C3                      	retn
 31398                                  
 31399                                  ; 01/08/2018 - Retro DOS v3.0
 31400                                  ; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5D93h 
 31401                                  
 31402                                  ;Break	<GETBUFFR, GETBUFFRB -- GET A SECTOR INTO A BUFFER>
 31403                                  
 31404                                  ;**	GetBuffr - Get a non-FAT Sector into a Buffer
 31405                                  ;----------------------------------------------------------------------------
 31406                                  ;	GetBuffr does normal ( non-FAT ) sector buffering
 31407                                  ;	It gets the specified local sector into one of the I/O buffers
 31408                                  ;	and shuffles the queue
 31409                                  ; 
 31410                                  ;	ENTRY	(AL) = 0 means sector must be pre-read
 31411                                  ;		       ELSE no pre-read
 31412                                  ;		(DX) = Desired physical sector number	      (LOW)
 31413                                  ;		HIGH_SECTOR = Desired physical sector number (HIGH)
 31414                                  ;		(ES:BP) = Pointer to drive parameters
 31415                                  ;		ALLOWED set in case of INT 24
 31416                                  ;	EXIT	'C' set if error (user FAIL response to INT24)
 31417                                  ;		'C' clear if OK
 31418                                  ;		CURBUF Points to the Buffer for the sector
 31419                                  ;		    the buffer type bits OF buf_flags = 0, caller must set it
 31420                                  ;	USES	AX, BX, CX, SI, DI, Flags
 31421                                  ;----------------------------------------------------------------------------
 31422                                  
 31423                                  ;**	GetBuffrb - Get a FAT Sector into a Buffer
 31424                                  ;----------------------------------------------------------------------------
 31425                                  ;	GetBuffrb reads a sector from the FAT file system's FAT table.
 31426                                  ;	It gets the specified sector into one of the I/O buffers
 31427                                  ;	and shuffles the queue. We need a special entry point so that
 31428                                  ;	we can read the alternate FAT sector if the first read fails, also
 31429                                  ;	so we can mark the buffer as a FAT sector.
 31430                                  ; 
 31431                                  ;	ENTRY	(AL) = 0 means sector must be pre-read
 31432                                  ;		       ELSE no pre-read
 31433                                  ;		(DX) = Desired physical sector number	     (LOW)
 31434                                  ;		(SI) != 0
 31435                                  ;		HIGH_SECTOR = Desired physical sector number (HIGH)
 31436                                  ;		(ES:BP) = Pointer to drive parameters
 31437                                  ;		ALLOWED set in case of INT 24
 31438                                  ;	EXIT	'C' set if error (user FAIL response to INT24)
 31439                                  ;		'C' clear if OK
 31440                                  ;		CUR ddBUF Points to the Buffer for the sector
 31441                                  ;		    the buffer type bits OF buf_flags = 0, caller must set it
 31442                                  ;	USES	AX, BX, CX, SI, DI, Flags
 31443                                  ;----------------------------------------------------------------------------
 31444                                  
 31445                                  	; 22/09/2023 - RetroDOS v4.2 MSDOS.SYS (optimization)
 31446                                  GETBUFFRC:
 31447 000059A9 C706[0706]0000          	mov	word [HIGH_SECTOR],0
 31448                                  GETBUFFRA:
 31449 000059AF 30C0                    	xor	al,al
 31450 000059B1 BE0100                  	mov	si,1
 31451 000059B4 EB09                    	jmp	short GETBUFFRB
 31452                                  
 31453                                  	; 22/09/2023
 31454                                  GETBUFFER:
 31455 000059B6 30C0                    	xor	al,al
 31456                                  GETBUFFRD:
 31457                                  	;mov	byte [ALLOWED],18h
 31458 000059B8 C606[4B03]18            	mov	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
 31459                                  
 31460                                  	; 20/05/2019 - Retro DOS v4.0
 31461                                  	; DOSCODE:9937h (MSDOS 6.21, MSDOS.SYS)
 31462                                  	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 31463                                  	; DOSCODE:98DBh (MSDOS 5.0, MSDOS.SYS)
 31464                                  GETBUFFR:
 31465 000059BD 31F6                    	XOR	SI,SI
 31466                                  
 31467                                  ;	This entry point is called for FAT buffering with SI != 0
 31468                                  
 31469                                  GETBUFFRB:
 31470 000059BF A3[9405]                	MOV	[PREREAD],AX			; save pre-read flag
 31471                                  	; 15/12/2022
 31472 000059C2 268A4600                	mov	al,[ES:BP]
 31473                                  	; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 31474                                  	;MOV	AL,[ES:BP+DPB.DRIVE] ; mov al,[es:bp+0]
 31475 000059C6 C53E[1E00]              	LDS	DI,[LastBuffer]			; Get the recency pointer
 31476                                  	; MSDOS 6.0
 31477                                  ;hkn; SS override
 31478 000059CA 368B0E[0706]            	MOV	CX,[SS:HIGH_SECTOR]		; F.C. >32mb	;AN000;
 31479                                  
 31480                                  ;	See if this is the buffer that was most recently returned.
 31481                                  ;	A big performance win if it is.
 31482                                  
 31483 000059CF 83FFFF                  	CMP	DI,-1				; Recency pointer valid?
 31484 000059D2 7412                    	je	short getb5			; No
 31485                                  	;cmp	dx,[di+6]
 31486 000059D4 3B5506                  	CMP	DX,[DI+BUFFINFO.buf_sector]
 31487 000059D7 750D                    	JNZ	short getb5			; Wrong sector
 31488                                  	
 31489                                  	; MSDOS 6.0
 31490                                  	;cmp	cx,[di+8]
 31491 000059D9 3B4D08                  	CMP	CX,[DI+BUFFINFO.buf_sector+2]	; F.C. >32mb	;AN000;
 31492 000059DC 7508                    	JNZ	short getb5			; F.C. >32mb	;AN000;
 31493                                  	
 31494                                  	;cmp	al,[di+4]
 31495 000059DE 3A4504                  	CMP	AL,[DI+BUFFINFO.buf_ID]
 31496                                  	;JZ	getb35				; Just asked for same buffer
 31497 000059E1 7503                    	jnz	short getb5
 31498                                  	;jmp	getb35
 31499                                  	; 17/12/2022
 31500                                  	; 28/07/2019
 31501 000059E3 E9C700                  	jmp	getb35x
 31502                                  	; 07/12/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 31503                                  	;jmp	getb35
 31504                                  
 31505                                  ;	It's not the buffer most recently returned. See if it's in the
 31506                                  ;	cache.
 31507                                  ;
 31508                                  ;	(cx:dx) = sector #
 31509                                  ;	(al) = drive #
 31510                                  ;	(si) = 0 iff non fat sector, != 0 if FAT sector read
 31511                                  ;	??? list may be incomplete ???
 31512                                  
 31513                                  getb5:	
 31514                                  	; MSDOS 3.3
 31515                                  	;lds	di,[SS:BUFFHEAD]
 31516                                  	; MSDOS 6.0
 31517 000059E6 E85BFF                  	CALL	GETCURHEAD			; get Q Head
 31518                                  getb10:	
 31519                                  	;cmp	dx,[di+6]
 31520 000059E9 3B5506                  	CMP	DX,[DI+BUFFINFO.buf_sector]
 31521 000059EC 750D                    	jne	short getb12			; wrong sector lo
 31522                                  	
 31523                                  	; MSDOS 6.0
 31524                                  	;cmp	cx,[di+8]
 31525 000059EE 3B4D08                  	CMP	CX,[DI+BUFFINFO.buf_sector+2]
 31526 000059F1 7508                    	jne	short getb12			; wrong sector hi
 31527                                  	
 31528                                  	;cmp	al,[di+4]
 31529 000059F3 3A4504                  	CMP	AL,[DI+BUFFINFO.buf_ID]
 31530                                  	;je	short getb25 ; 05/09/2018	; Found the requested sector
 31531 000059F6 7503                    	jne	short getb12
 31532 000059F8 E98C00                  	jmp	getb25
 31533                                  getb12:	
 31534                                  	; MSDOS 3.3
 31535                                  	;;mov	di,[DI]
 31536                                  	;;;mov	di,[DI+BUFFINFO.buf_link]
 31537                                  	;
 31538                                  	; 15/08/2018
 31539                                  	;lds	di,[di]
 31540                                  
 31541                                  	;cmp	di,-1 ; 0FFFFh
 31542                                  	;jne	short getb10
 31543                                  	;lds	di,[SS:BUFFHEAD]
 31544                                  
 31545                                  	; MSDOS 6.0
 31546 000059FB 8B3D                    	mov	di,[di]
 31547                                  	;mov	DI,[DI+BUFFINFO.BUF_NEXT]
 31548 000059FD 363B3E[BA0E]            	cmp	DI,[SS:FIRST_BUFF_ADDR]		; back at the front again?
 31549 00005A02 75E5                    	jne	short getb10			; no, continue looking
 31550                                  
 31551                                  ;	The requested sector is not available in the buffers. DS:DI now points
 31552                                  ;	to the first buffer in the Queue. Flush the first buffer & read in the
 31553                                  ;	new sector into it.
 31554                                  ;
 31555                                  ;	BUGBUG - what goes on here? Isn't the first guy the most recently
 31556                                  ;	used guy? Shuld be for fast lookup. If he is, we shouldn't take
 31557                                  ;	him, we should take LRU. And the above lookup shouldn't be
 31558                                  ;	down a chain, but should be hashed.
 31559                                  ;
 31560                                  ;	(DS:DI) = first buffer in the queue
 31561                                  ;	(CX:DX) = sector # we want
 31562                                  ;	(si) = 0 iff non fat sector, != 0 if FAT sector read
 31563                                  
 31564                                  	; MSDOS 3.3 & MSDOS 6.0
 31565                                  ;hkn; SS override
 31566 00005A04 51                      	PUSH	CX  ; MSDOS 6.0
 31567 00005A05 56                      	push	si
 31568 00005A06 52                      	push	dx
 31569 00005A07 55                      	push	bp
 31570 00005A08 06                      	push	es
 31571 00005A09 E81601                  	CALL	BUFWRITE			; Write out the dirty buffer
 31572 00005A0C 07                      	pop	es
 31573 00005A0D 5D                      	pop	bp
 31574 00005A0E 5A                      	pop	dx
 31575 00005A0F 5E                      	pop	si
 31576 00005A10 368F06[0706]            	POP	word [SS:HIGH_SECTOR]  ; MSDOS 6.0
 31577                                  	;jc	short getbx			; if got hard error
 31578 00005A15 7303                    	jnc	short getb13
 31579 00005A17 E99D00                  	jmp	getbx
 31580                                  
 31581                                  getb13:
 31582                                  	; MSDOS 6.0
 31583 00005A1A E88F01                  	CALL	SET_RQ_SC_PARMS 		; set parms for secondary cache
 31584                                  
 31585                                  ;	We're ready to read in the buffer, if need be. If the caller
 31586                                  ;	wanted to just *write* the buffer then we'll skip reading it in.
 31587                                  
 31588 00005A1D 30E4                    	XOR	AH,AH				; initial flags
 31589                                  ;hkn; SS override
 31590                                  	;test	byte [ss:PREREAD],0FFh
 31591                                  	;jnz	short getb20
 31592 00005A1F 363826[9405]            	CMP	[SS:PREREAD],ah ; 0		; am to Read in the new sector?
 31593 00005A24 7549                    	JNZ	short getb20			; no, we're done
 31594                                  	;;lea	bx,[di+16] ; MSDOS 3.3
 31595                                  	;lea	bx,[di+20] ; MSDOS 6.0
 31596 00005A26 8D5D14                  	LEA	BX,[DI+BUFINSIZ] 		; (ds:bx) = data address
 31597                                  	;MOV	CX,1
 31598                                  	; 22/09/2023
 31599 00005A29 29C9                    	sub	cx,cx ; 0
 31600 00005A2B 56                      	push	si
 31601 00005A2C 57                      	push	di
 31602 00005A2D 52                      	push	dx
 31603                                  	; MSDOS 6.0
 31604 00005A2E 06                      	push	es ; ***
 31605                                  
 31606                                  ; Note: As far as I can tell, all disk reads into buffers go through
 31607                                  ;	this point. -mrw 10/88
 31608                                  	
 31609                                  	;cmp	byte [ss:BuffInHMA],0	; is buffers in HMA?
 31610                                  	; 22/09/2023
 31611 00005A2F 36380E[7900]            	cmp	[ss:BuffInHMA],cl ; 0
 31612 00005A34 7407                    	jz	short getb14
 31613 00005A36 1E                      	push	ds ; **
 31614 00005A37 53                      	push	bx ; *
 31615 00005A38 36C51E[7A00]            	lds	bx,[ss:LoMemBuff]	; Then let's read it into scratch buff
 31616                                  getb14:
 31617                                  ;M039: Eliminated redundant HMA code.
 31618                                  
 31619                                  	; 22/09/2023
 31620 00005A3D 41                      	inc	cx ; cx = 1
 31621                                  
 31622                                  	; MSDOS 3.3 (& MSDOS 6.0)
 31623 00005A3E 09F6                    	OR	SI,SI			; FAT sector ?
 31624 00005A40 7407                    	JZ	short getb15		
 31625                                  
 31626 00005A42 E804DD                  	call	FATSECRD
 31627                                  	;mov	ah,2
 31628 00005A45 B402                    	MOV	AH,buf_isFAT		; Set buf_flags
 31629                                  
 31630 00005A47 EB05                    	JMP	SHORT getb17		; Buffer is marked free if read barfs
 31631                                  
 31632                                  getb15:
 31633 00005A49 E829DD                  	call	DREAD			; Buffer is marked free if read barfs
 31634 00005A4C B400                    	MOV	AH,0			; Set buf_flags to no type, DO NOT XOR!
 31635                                  getb17:
 31636                                  	; 17/12/2022	
 31637                                  ; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 31638                                  ;%if 0
 31639                                  	; MSDOS 6.0							  ;I001
 31640 00005A4E 9C                      	pushf								  ;I001
 31641 00005A4F 36803E[7900]00          	cmp	byte [SS:BuffInHMA],0	; did we read into scratch buff ? ;I001
 31642 00005A55 7411                    	jz	short not_in_hma	; no				  ;I001
 31643                                  	;mov	cx,[es:bp+2]
 31644 00005A57 268B4E02                	mov	cx,[ES:BP+DPB.SECTOR_SIZE]				  ;I001
 31645 00005A5B D1E9                    	shr	cx,1							  ;I001
 31646 00005A5D 9D                      	popf				; Retrieve possible CY from DREAD ;I001
 31647 00005A5E 89DE                    	mov	si,bx							  ;I001
 31648 00005A60 5F                      	pop	di ; *							  ;I001
 31649 00005A61 07                      	pop	es ; **							  ;I001
 31650 00005A62 FC                      	cld								  ;I001
 31651 00005A63 9C                      	pushf				; Preserve possible CY from DREAD ;I001
 31652 00005A64 F3A5                    	rep	movsw			; move the contents of scratch buf;I001
 31653 00005A66 06                      	push	es							  ;I001
 31654 00005A67 1F                      	pop	ds							  ;I001
 31655                                  ;%endif
 31656                                  
 31657                                  ; 17/12/2022
 31658                                  %if 0
 31659                                  	; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 31660                                  	; MSDOS 5.0
 31661                                  	pushf
 31662                                  	cmp	byte [SS:BuffInHMA],0	; did we read into scratch buff ?
 31663                                  	jz	short not_in_hma	; no
 31664                                  	popf
 31665                                  	mov	cx,[ES:BP+DPB.SECTOR_SIZE]
 31666                                  	shr	cx,1
 31667                                  	mov	si,bx
 31668                                  	pop	di ; *
 31669                                  	pop	es ; **
 31670                                  	cld
 31671                                  	rep	movsw
 31672                                  	push	es
 31673                                  	pop	ds
 31674                                  	jmp	short getb19 ; 27/11/2022
 31675                                  %endif
 31676                                  
 31677                                  not_in_hma:								  ;I001
 31678 00005A68 9D                      	popf							 	  ;I001
 31679                                  getb19:
 31680 00005A69 07                      	pop	es ; ***
 31681 00005A6A 5A                      	pop	dx
 31682 00005A6B 5F                      	pop	di
 31683 00005A6C 5E                      	pop	si
 31684 00005A6D 7248                    	JC	short getbx
 31685                                  
 31686                                  ;	The buffer has the data setup in it (if we were to read)
 31687                                  ;	Setup the various buffer fields
 31688                                  ;
 31689                                  ;	(ds:di) = buffer address
 31690                                  ;	(es:bp) = DPB address
 31691                                  ;	(HIGH_SECTOR:DX) = sector #
 31692                                  ;	(ah) = BUF_FLAGS value
 31693                                  ;	(si) = 0 if non fat sector, != 0 if FAT sector read
 31694                                  
 31695                                  ;hkn; SS override
 31696                                  getb20:	; MSDOS 6.0
 31697 00005A6F 368B0E[0706]            	MOV	CX,[SS:HIGH_SECTOR]
 31698                                  	;mov	[di+8],cx
 31699 00005A74 894D08                  	MOV	[DI+BUFFINFO.buf_sector+2],CX
 31700                                  	; MSDOS 3.3 (& MSDOS 6.0)	
 31701                                   	;mov	[di+6],dx
 31702 00005A77 895506                  	MOV	[DI+BUFFINFO.buf_sector],DX
 31703                                  	;;mov	[di+0Ah],bp  ; MSDOS 3.3
 31704                                  	;mov	[di+0Dh],bp  ; MSDOS 6.0
 31705 00005A7A 896D0D                  	MOV	[DI+BUFFINFO.buf_DPB],BP
 31706                                  	;;mov	[di+0Ch],es
 31707                                  	;mov	[di+0Fh],es  ; MSDOS 6.0
 31708 00005A7D 8C450F                  	MOV	[DI+BUFFINFO.buf_DPB+2],ES
 31709                                  	; 15/12/2022
 31710 00005A80 268A4600                	mov	al,[es:bp]
 31711                                  	;mov	al,[es:bp+0]
 31712                                  	; 27/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 31713                                  	;MOV	AL,[ES:BP+DPB.DRIVE]
 31714                                  	;mov	[di+4],ax
 31715 00005A84 894504                  	MOV	[DI+BUFFINFO.buf_ID],AX		; Set ID and Flags
 31716                                  getb25:	
 31717                                  	; MSDOS 3.3
 31718                                  	;mov     ax,1
 31719                                  
 31720                                  	; MSDOS 6.0
 31721                                  	;mov	byte [di+0Ah],1
 31722 00005A87 C6450A01                	MOV	byte [DI+BUFFINFO.buf_wrtcnt],1	; Default to not a FAT sector ;AC000;
 31723 00005A8B 31C0                    	XOR	AX,AX
 31724                                  
 31725                                  	; MSDOS 3.3 (& MSDOS 6.0)
 31726 00005A8D 09F6                    	OR	SI,SI				; FAT sector ?
 31727 00005A8F 740B                    	JZ	short getb30
 31728                                  
 31729                                  	;mov	al,[es:bp+8]
 31730 00005A91 268A4608                	MOV	AL,[ES:BP+DPB.FAT_COUNT]	; update number of copies of
 31731                                  	
 31732                                  	; MSDOS 6.0
 31733 00005A95 88450A                  	MOV	[DI+BUFFINFO.buf_wrtcnt],AL	;  this sector present on disk
 31734                                  	;mov	ax,[es:bp+0Fh]
 31735 00005A98 268B460F                	MOV	AX,[ES:BP+DPB.FAT_SIZE]		; offset of identical FAT
 31736                                  						;  sectors
 31737                                  	; MSDOS 3.3
 31738                                  	;;mov	ah,[es:bp+0Fh]
 31739                                  	;MOV	AH,[ES:BP+DPB.FAT_SIZE]
 31740                                  
 31741                                  ;	BUGBUG - dos 6 can clean this up by not setting wrtcntinc unless wrtcnt
 31742                                  ;		is set
 31743                                  
 31744                                  getb30:	
 31745                                  	; MSDOS 6.0
 31746                                  	;mov	[di+0Bh],ax
 31747 00005A9C 89450B                  	MOV	[DI+BUFFINFO.buf_wrtcntinc],AX
 31748                                  
 31749                                  	; MSDOS 3.3
 31750                                  	;;mov	[di+8],ax ; 15/08/2018	
 31751                                  	;MOV	[DI+BUFFINFO.buf_wrtcnt],AX
 31752                                  
 31753 00005A9F E8BBFE                  	CALL	PLACEBUF
 31754                                  
 31755                                  ;hkn; SS override for next 4
 31756                                  getb35: 
 31757                                  	; 17/12/2022
 31758                                  	; 07/12/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 31759                                  	; MSDOS 3.3 & MSDOS 5.0 & MSDOS 6.0
 31760                                  	;MOV	[SS:CURBUF+2],DS
 31761                                  	;MOV	[SS:LastBuffer+2],DS
 31762                                  	;MOV	[SS:CURBUF],DI
 31763                                  	;MOV	[SS:LastBuffer],DI
 31764                                  	;CLC
 31765                                  
 31766                                  	; 17/12/2022
 31767                                  	; 07/12/2022
 31768                                  	; Retro DOS v4.0
 31769 00005AA2 368C1E[2000]            	mov	[ss:LastBuffer+2],ds
 31770 00005AA7 36893E[1E00]            	mov	[ss:LastBuffer],di
 31771 00005AAC F8                      	clc
 31772                                  getb35x: ; 28/07/2019
 31773 00005AAD 368C1E[E405]            	MOV	[ss:CURBUF+2],ds
 31774 00005AB2 36893E[E205]            	MOV	[ss:CURBUF],di
 31775                                  
 31776                                  ;	Return with 'C' set appropriately
 31777                                  ;	(dx) = caller's original value
 31778                                  
 31779                                  getbx:	
 31780 00005AB7 16                      	push	ss
 31781 00005AB8 1F                      	pop	ds
 31782                                  	;retn
 31783                                  	; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 31784                                  getbuffrb_retn:
 31785                                  ;flushbuf_retn:	; 17/12/2022
 31786 00005AB9 C3                      	retn
 31787                                  
 31788                                  ;Break	<FLUSHBUF -- WRITE OUT DIRTY BUFFERS>
 31789                                  ;----------------------------------------------------------------------------
 31790                                  ; Input:
 31791                                  ;	DS = DOSGROUP
 31792                                  ;	AL = Physical unit number local buffers only
 31793                                  ;	   = -1 for all units and all remote buffers
 31794                                  ; Function:
 31795                                  ;	Write out all dirty buffers for unit, and flag them as clean
 31796                                  ;	Carry set if error (user FAILed to I 24)
 31797                                  ;	    Flush operation completed.
 31798                                  ; DS Preserved, all others destroyed (ES too)
 31799                                  ;----------------------------------------------------------------------------
 31800                                  
 31801                                  	; 20/05/2019 - Retro DOS v4.0
 31802                                  	; DOSCODE:9A35h (MSDOS 6.21, MSDOS.SYS)
 31803                                  
 31804                                  	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 31805                                  	; DOSCODE:99DAh (MSDOS 5.0, MSDOS.SYS)
 31806                                  FLUSHBUF:
 31807                                  	; MSDOS 3.3
 31808                                  	;;mov	ah,-1 ; 01/08/2018 - Retro DOS v3.0
 31809                                  	;lds	di,[BUFFHEAD]
 31810                                  
 31811                                  	; MSDOS 6.0
 31812 00005ABA E887FE                  	call	GETCURHEAD
 31813                                  	;TEST	word [ss:DOS34_FLAG],FROM_DISK_RESET ; from disk reset ? ;hkn;
 31814 00005ABD 36F606[1106]04          	TEST	byte [ss:DOS34_FLAG],FROM_DISK_RESET ; 4
 31815 00005AC3 7508                    	jnz	short scan_buf_queue
 31816 00005AC5 36833E[7100]00          	cmp	word [ss:DirtyBufferCount],0			;hkn;
 31817 00005ACB 7423                    	je	short end_scan
 31818                                  	
 31819                                  scan_buf_queue:
 31820 00005ACD E82900                  	call	CHECKFLUSH
 31821                                  	;push	ax  ; MSDOS 3.3
 31822                                  	; MSDOS 6.0
 31823                                  	;mov	ah,[di+4]
 31824 00005AD0 8A6504                  	mov	ah,[DI+BUFFINFO.buf_ID]
 31825 00005AD3 363826[2203]            	cmp	[SS:WPERR],ah					;hkn;
 31826 00005AD8 7408                    	je	short free_the_buf
 31827                                  	;TEST	word [ss:DOS34_FLAG],FROM_DISK_RESET ; from disk reset ? ;hkn;
 31828 00005ADA 36F606[1106]04          	TEST	byte [ss:DOS34_FLAG],FROM_DISK_RESET ; 4
 31829 00005AE0 7405                    	jz	short dont_free_the_buf
 31830                                  	; MSDOS 3.3
 31831                                  	;;mov	al,[di+4]
 31832                                  	;mov	al,[DI+BUFFINFO.buf_ID]
 31833                                  	;cmp	[SS:WPERR],al					;hkn;
 31834                                  	; 15/08/2018
 31835                                  	;jne	short dont_free_the_buf	
 31836                                  free_the_buf:
 31837                                  	; MSDOS 6.0 (& MSDOS 3.3)
 31838 00005AE2 C74504FF00              	mov	word [DI+BUFFINFO.buf_ID],00FFh
 31839                                  dont_free_the_buf:
 31840                                  	;pop	ax  ; MSDOS 3.3 	   	
 31841                                  
 31842                                  	; MSDOS 3.3
 31843                                  	;mov	di,[DI]
 31844                                  	;;mov	di,[DI+BUFFINFO.buf_link] ; .buf_next
 31845                                  	;
 31846                                  	; 15/08/2018
 31847                                  	;lds	di,[di]
 31848                                  	;
 31849                                  	;cmp	di,-1 ; 0FFFFh
 31850                                  	;jnz	short scan_buf_queue 
 31851                                  	
 31852                                  	; MSDOS 6.0
 31853 00005AE7 8B3D                    	mov	di,[di]
 31854                                  	;mov	di,[DI+BUFFINFO.buf_next] ; .buf_link
 31855 00005AE9 363B3E[BA0E]            	cmp	di,[SS:FIRST_BUFF_ADDR]				;hkn;
 31856 00005AEE 75DD                    	jne	short scan_buf_queue
 31857                                  
 31858                                  end_scan:
 31859 00005AF0 16                      	push	ss
 31860 00005AF1 1F                      	pop	ds
 31861                                  	; 01/08/2018 - Retro DOS v3.0
 31862                                  	;cmp	byte [FAILERR],0
 31863                                  	;jne	short bad_flush
 31864                                  	;retn
 31865                                  ;bad_flush:
 31866                                  	;stc
 31867                                  	;retn
 31868                                  
 31869                                  	; 17/12/2022
 31870                                  	; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 31871                                  	; 01/08/2018 - Retro DOS v3.0
 31872 00005AF2 803E[4A03]01            	cmp	byte [FAILERR],1
 31873 00005AF7 F5                      	cmc
 31874                                  flushbuf_retn:
 31875 00005AF8 C3                      	retn
 31876                                  	
 31877                                  	; 17/12/2022
 31878                                  	; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 31879                                  	;cmp	byte [FAILERR],0
 31880                                  	;jne	short bad_flush
 31881                                  	;retn
 31882                                  ;bad_flush:
 31883                                  	;stc
 31884                                  	;retn
 31885                                  
 31886                                  ;----------------------------------------------------------------------------
 31887                                  ;
 31888                                  ; Procedure Name : CHECKFLUSH
 31889                                  ;
 31890                                  ; Inputs : AL - Drive number, -1 means do not check for drive
 31891                                  ;	   DS:DI - pointer to buffer
 31892                                  ;
 31893                                  ; Function : Write out a buffer if it is dirty
 31894                                  ;
 31895                                  ; Carry set if problem (currently user FAILed to I 24)
 31896                                  ;
 31897                                  ;----------------------------------------------------------------------------
 31898                                  
 31899                                  CHECKFLUSH:
 31900                                  	; MSDOS 6.0
 31901 00005AF9 B4FF                    	mov	ah,-1	; 01/08/2018 Retro DOS v3.0
 31902                                  	;cmp	[di+4],ah
 31903 00005AFB 386504                  	CMP	[DI+BUFFINFO.buf_ID],AH
 31904 00005AFE 74F8                    	jz	short flushbuf_retn	; Skip free buffer, carry clear
 31905 00005B00 38C4                    	CMP	AH,AL			; 
 31906 00005B02 7406                    	JZ	short DOBUFFER		; do this buffer
 31907                                  	;cmp	al,[di+4]
 31908 00005B04 3A4504                  	CMP	AL,[DI+BUFFINFO.buf_ID]
 31909 00005B07 F8                      	CLC
 31910 00005B08 75EE                    	jnz	short flushbuf_retn	; Buffer not for this unit or SFT
 31911                                  DOBUFFER:
 31912                                  	;test	byte [di+5],40h
 31913 00005B0A F6450540                	TEST	byte [DI+BUFFINFO.buf_flags],buf_dirty
 31914 00005B0E 74E8                    	jz	short flushbuf_retn	; Buffer not dirty, carry clear by TEST
 31915 00005B10 50                      	PUSH	AX
 31916                                  	;push	word [di+4]
 31917 00005B11 FF7504                  	PUSH	WORD [DI+BUFFINFO.buf_ID]
 31918 00005B14 E80B00                  	CALL	BUFWRITE
 31919 00005B17 58                      	POP	AX
 31920 00005B18 7206                    	JC	short LEAVE_BUF		; Leave buffer marked free (lost).
 31921                                  	;and	ah,0BFh
 31922 00005B1A 80E4BF                  	AND	AH,~buf_dirty		; Buffer is clean, clears carry
 31923                                  	;mov	[di+4],ax
 31924 00005B1D 894504                  	MOV	[DI+BUFFINFO.buf_ID],AX
 31925                                  LEAVE_BUF:
 31926 00005B20 58                      	POP	AX			; Search info
 31927                                  checkflush_retn:
 31928 00005B21 C3                      	retn
 31929                                  
 31930                                  ;Break	<BUFWRITE -- WRITE OUT A BUFFER IF DIRTY>
 31931                                  ;----------------------------------------------------------------------------
 31932                                  ;
 31933                                  ;	BufWrite writes a buffer to the disk, if it's dirty.
 31934                                  ;
 31935                                  ;	ENTRY	DS:DI Points to the buffer
 31936                                  ;
 31937                                  ;	EXIT	Buffer marked free
 31938                                  ;		Carry set if error (currently user FAILed to I 24)
 31939                                  ;
 31940                                  ;	USES	All buf DS:DI
 31941                                  ;		HIGH_SECTOR
 31942                                  ;----------------------------------------------------------------------------
 31943                                  
 31944                                  	; 20/05/2019 - Retro DOS v4.0
 31945                                  	; DOSCODE:9AA0h (MSDOS 6.21, MSDOS.SYS)
 31946                                  
 31947                                  
 31948                                  	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 31949                                  	; DOSCODE:9A45h (MSDOS 5.0, MSDOS.SYS)
 31950                                  
 31951                                  BUFWRITE:
 31952                                  	; 10/09/2018
 31953                                  	; 01/08/2018 - Retro DOS v3.0
 31954                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5E94h
 31955 00005B22 B8FF00                  	MOV	AX,00FFH
 31956                                  	;xchg	ax,[di+4]
 31957 00005B25 874504                  	XCHG	AX,[DI+BUFFINFO.buf_ID]	; Free, in case write barfs
 31958 00005B28 3CFF                    	CMP	AL,0FFH
 31959 00005B2A 74F5                    	jz      short checkflush_retn	; Buffer is free, carry clear.
 31960                                  	;test	ah,40h
 31961 00005B2C F6C440                  	test	AH,buf_dirty
 31962 00005B2F 74F0                    	jz      short checkflush_retn	; Buffer is clean, carry clear.
 31963                                  	; MSDOS 6.0
 31964 00005B31 E89100                  	call	DEC_DIRTY_COUNT 	; LB. decrement dirty count
 31965                                  
 31966                                  ;hkn; SS override
 31967 00005B34 363A06[2203]            	CMP	AL,[SS:WPERR]
 31968 00005B39 74E6                    	jz      short checkflush_retn	; If in WP error zap buffer
 31969                                  
 31970                                  ;hkn; SS override
 31971                                  	; MSDOS 6.0
 31972 00005B3B 36A2[AF0D]              	MOV	[SS:SC_DRIVE],AL	;LB. set it for invalidation ;AN000;
 31973                                  	
 31974                                  	;;les	bp,[di+10] ; MSDOS 3.3
 31975                                  	;les	bp,[di+13] ; MSDOS 6.0
 31976 00005B3F C46D0D                  	LES	BP,[DI+BUFFINFO.buf_DPB]
 31977                                  	;;lea	bx,[di+16]
 31978                                  	;lea	bx,[di+20] ; MSDOS 6.0
 31979 00005B42 8D5D14                  	LEA	BX,[DI+BUFINSIZ]	; Point at buffer
 31980                                  	;mov	dx,[di+6]
 31981 00005B45 8B5506                  	MOV	DX,[DI+BUFFINFO.buf_sector] ;F.C. >32mb		;AN000;
 31982                                  	
 31983                                  	; MSDOS 6.0
 31984                                  	;mov	cx,[di+8]
 31985 00005B48 8B4D08                  	MOV	CX,[DI+BUFFINFO.buf_sector+2] ;F.C. >32mb	;AN000;
 31986                                  
 31987                                  ;hkn; SS override
 31988 00005B4B 36890E[0706]            	MOV	[SS:HIGH_SECTOR],CX	;F.C. >32mb		;AN000;
 31989 00005B50 8A4D0A                  	MOV	CL,[DI+BUFFINFO.buf_wrtcnt] ;>32mb		;AC000;
 31990                                  	; MSDOS 3.3
 31991                                  	;; mov	cx,[DI+8]
 31992                                  	;mov	cx,[DI+BUFFINFO.buf_wrtcnt]
 31993                                  	;MOV	AL,CH			; [DI+BUFFINFO.buf_wrtcntinc]
 31994 00005B53 30ED                    	XOR	CH,CH
 31995                                  	;;mov	ah,ch ; MSDOS 3.3
 31996                                  
 31997                                  ;hkn; SS override for ALLOWED
 31998                                  	;mov	byte [SS:ALLOWED],18h
 31999 00005B55 36C606[4B03]18          	MOV	byte [SS:ALLOWED],Allowed_RETRY+Allowed_FAIL
 32000                                  	;test	byte [di+5],8
 32001                                  	; MSDOS 6.0 (& Retro DOS 3.0)
 32002                                  	;test	ah,8
 32003 00005B5B F6C408                  	test	AH,buf_isDATA
 32004 00005B5E 7406                    	JZ	short NO_IGNORE
 32005                                  	;or	byte [SS:ALLOWED],20h
 32006 00005B60 36800E[4B03]20          	OR	byte [SS:ALLOWED],Allowed_IGNORE
 32007                                  NO_IGNORE:
 32008                                  	;xor	ah,ah ; 10/09/2018 (MSDOS 3.3, Retro DOS v3.0)
 32009                                  	; MSDOS 6.0
 32010                                  	;mov	ax,[di+11]
 32011 00005B66 8B450B                  	MOV	AX,[DI+BUFFINFO.buf_wrtcntinc]	;>32mb		;AC000;
 32012                                  
 32013 00005B69 57                      	PUSH	DI		; Save buffer pointer
 32014 00005B6A 31FF                    	XOR	DI,DI		; Indicate failure
 32015                                  
 32016 00005B6C 1E                      	push	ds ; *
 32017 00005B6D 53                      	push	bx ; **
 32018                                  WRTAGAIN:
 32019 00005B6E 57                      	push	di ; ***
 32020 00005B6F 51                      	push	cx ; ****
 32021 00005B70 50                      	push	ax ; *****
 32022                                  	;MOV	CX,1
 32023                                  	; 17/12/2022
 32024                                  	; ch = 0
 32025 00005B71 B101                    	mov	cl,1 ; 24/07/2019
 32026                                  	; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 32027                                  	;mov	cx,1
 32028 00005B73 53                      	push	bx ; ******
 32029 00005B74 52                      	push	dx ; *******
 32030 00005B75 1E                      	push	ds ; ********
 32031                                  
 32032                                  ; Note: As far as I can tell, all disk reads into buffers go through this point. -mrw 10/88
 32033                                  
 32034                                  	; MSDOS 6.0
 32035                                  	;cmp	byte [ss:BuffInHMA],0 ; 10/06/2019
 32036                                  	; 22/09/2023
 32037 00005B76 36382E[7900]            	cmp	[ss:BuffInHMA],ch ; 0
 32038 00005B7B 7418                    	jz	short NBUFFINHMA
 32039 00005B7D 51                      	push	cx
 32040 00005B7E 06                      	push	es
 32041 00005B7F 89DE                    	mov	si,bx
 32042 00005B81 268B4E02                	mov	cx,[es:bp+DPB.SECTOR_SIZE]
 32043 00005B85 D1E9                    	shr	cx,1
 32044 00005B87 36C43E[7A00]            	les	di,[ss:LoMemBuff] ; 10/06/2019
 32045 00005B8C 89FB                    	mov	bx,di
 32046 00005B8E FC                      	cld
 32047 00005B8F F3A5                    	rep	movsw
 32048 00005B91 06                      	push	es
 32049 00005B92 1F                      	pop	ds
 32050 00005B93 07                      	pop	es
 32051 00005B94 59                      	pop	cx
 32052                                  NBUFFINHMA:
 32053 00005B95 E83DDC                  	call	DWRITE		; Write out the dirty buffer
 32054 00005B98 1F                      	pop	ds ; ********
 32055 00005B99 5A                      	pop	dx ; *******
 32056 00005B9A 5B                      	pop	bx ; ******
 32057 00005B9B 58                      	pop	ax ; *****
 32058 00005B9C 59                      	pop	cx ; ****
 32059 00005B9D 5F                      	pop	di ; ***
 32060 00005B9E 7201                    	JC	short NOSET
 32061 00005BA0 47                      	INC	DI		; If at least ONE write succeedes, the operation
 32062                                  NOSET:				;	succeedes.
 32063 00005BA1 01C2                    	ADD	DX,AX
 32064 00005BA3 E2C9                    	LOOP	WRTAGAIN
 32065 00005BA5 5B                      	pop	bx ; **
 32066 00005BA6 1F                      	pop	ds ; *
 32067                                  	;OR	DI,DI		; Clears carry
 32068                                  	;JNZ	short BWROK	; At least one write worked
 32069                                  	;STC			; DI never got INCed, all writes failed.
 32070                                  	; 22/09/2023
 32071 00005BA7 83FF01                  	cmp	di,1
 32072                                  BWROK:	
 32073 00005BAA 5F                      	POP	DI
 32074 00005BAB C3                      	retn
 32075                                  
 32076                                  ;**	Set_RQ_SC_Parms - Set Secondary Cache Parameters
 32077                                  ;----------------------------------------------------------------------------
 32078                                  ;	Set_RQ_SC_Parms sets the sector size and drive number value
 32079                                  ;	for the secondary cache. This updates SC_SECTOR_SIZE &
 32080                                  ;	SC_DRIVE even if SC is disabled to save the testing
 32081                                  ;	code and time
 32082                                  ;
 32083                                  ;	ENTRY	ES:BP = drive parameter block
 32084                                  ;
 32085                                  ;	EXIT	[SC_SECTOR_SIZE]= drive sector size
 32086                                  ;		[SC_DRIVE]= drive #
 32087                                  ;
 32088                                  ;	USES	Flags
 32089                                  ;----------------------------------------------------------------------------
 32090                                  
 32091                                  ; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 32092                                  ; 04/05/2019 - Retro DOS v4.0
 32093                                  
 32094                                  SET_RQ_SC_PARMS:
 32095                                  ;hkn; SS override for all variables used in this procedure.
 32096 00005BAC 50                      	push	ax
 32097                                  	;mov	ax,[es:bp+2]
 32098 00005BAD 268B4602                	MOV	ax,[ES:BP+DPB.SECTOR_SIZE]	; save sector size
 32099 00005BB1 36A3[AD0D]              	MOV	[ss:SC_SECTOR_SIZE],ax
 32100                                  	;;mov	al,[es:bp+0]
 32101                                  	; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
 32102                                  	;MOV	al,[ES:BP+DPB.DRIVE]		; save drive #
 32103                                  	; 15/12/2022
 32104 00005BB5 268A4600                	mov	al,[ES:BP]
 32105 00005BB9 36A2[AF0D]              	MOV	[ss:SC_DRIVE],al
 32106 00005BBD 58                      	pop	ax
 32107                                  srspx:	
 32108 00005BBE C3                      	retn					;LB. return
 32109                                  
 32110                                  ;Break	<INC_DIRTY_COUNT-increment dirty count>
 32111                                  ;----------------------------------------------------------------------------
 32112                                  ; Input:
 32113                                  ;	none
 32114                                  ; Function:
 32115                                  ;	increment dirty buffers count
 32116                                  ; Output:
 32117                                  ;	dirty buffers count is incremented
 32118                                  ;
 32119                                  ; All registers preserved
 32120                                  ;----------------------------------------------------------------------------
 32121                                  
 32122                                  INC_DIRTY_COUNT:
 32123                                  ;; BUGBUG  ---- remove this routine
 32124                                  ;; BUGBUG ---- only one instruction is needed (speed win, space loose)
 32125 00005BBF 36FF06[7100]            	inc	word [ss:DirtyBufferCount]	;hkn;
 32126 00005BC4 C3                      	retn
 32127                                  
 32128                                  ;Break	<DEC_DIRTY_COUNT-decrement dirty count>
 32129                                  ;----------------------------------------------------------------------------
 32130                                  ; Input:
 32131                                  ;	none
 32132                                  ; Function:
 32133                                  ;	decrement dirty buffers count
 32134                                  ; Output:
 32135                                  ;	dirty buffers count is decremented
 32136                                  ;
 32137                                  ; All registers preserved
 32138                                  ;----------------------------------------------------------------------------
 32139                                  
 32140                                  DEC_DIRTY_COUNT:
 32141 00005BC5 36833E[7100]00          	cmp	word [ss:DirtyBufferCount],0 ;hkn;
 32142 00005BCB 7405                    	jz	short ddcx		; BUGBUG - shouldn't it be an
 32143 00005BCD 36FF0E[7100]            	dec	word [ss:DirtyBufferCount] 
 32144                                  					; error condition to underflow here? ;hkn;
 32145                                  ddcx:	
 32146 00005BD2 C3                      	retn
 32147                                  
 32148                                  ;============================================================================
 32149                                  ; MSPROC.ASM, MSDOS 6.0, 1992
 32150                                  ;============================================================================
 32151                                  ; 02/08/2018 - Retro DOS v3.0
 32152                                  ; 29/04/2019 - Retro DOS v4.0
 32153                                  
 32154                                  ; (15/04/2018 - RetrO DOS v2.0, MSDOS 2.11 - PROC.ASM - 1983)
 32155                                  
 32156                                  ; Pseudo EXEC system call for DOS
 32157                                  
 32158                                  ;	TITLE	MSPROC - process maintenance
 32159                                  ;	NAME	MSPROC
 32160                                  
 32161                                  ; =========================================================================
 32162                                  ;**	Process related system calls and low level routines for DOS 2.X.
 32163                                  ;	I/O specs are defined in DISPATCH.
 32164                                  ;
 32165                                  ;	$WAIT
 32166                                  ;	$EXEC
 32167                                  ;	$Keep_process
 32168                                  ;	Stay_resident
 32169                                  ;	$EXIT
 32170                                  ;	$ABORT
 32171                                  ;	abort_inner
 32172                                  ;
 32173                                  ;	Modification history:
 32174                                  ;
 32175                                  ;		Created: ARR 30 March 1983
 32176                                  ;		AN000	version 4.0 jan. 1988
 32177                                  ;		A007	PTM 3957 - fake vesrion for IBMCACHE.COM
 32178                                  ;		A008	PTM 4070 - fake version for MS WINDOWS
 32179                                  ;
 32180                                  ;		M000	added support for loading programs into UMBs 7/9/90
 32181                                  ;
 32182                                  ;		M004 - MS PASCAL 3.2 support. Please see under tag M003 in 
 32183                                  ;		       dossym.inc. 7/30/90
 32184                                  ;		M005 - Support for EXE programs with out STACK segment and 
 32185                                  ;		       with resident size < 64K - 256 bytes. A 256 byte 
 32186                                  ;		       stack is provided at the end of the program. Note that
 32187                                  ;		       only SP is changed.
 32188                                  ;		M020 - Fix for Rational bug for details see exepatch.asm
 32189                                  ;
 32190                                  ;		M028 - 4b04 implementation
 32191                                  ;
 32192                                  ;		M029 - Support for EXEs without stack rewritten. If EXE is
 32193                                  ;			in memory block >= 64K, sp = 0. If memory block
 32194                                  ;			obtained is <64K, point sp at the end of the memory
 32195                                  ;			block. For EXEs smaller than 64K, 256 bytes are still
 32196                                  ;			added for a stack segment which may be needed if it
 32197                                  ;			is loaded in low memory situations.
 32198                                  ;
 32199                                  ;		M030 - Fixing bug in EXEPACPATCH & changing 4b04 to 4b05
 32200                                  ;
 32201                                  ;		M040 - Bug #3052. The environment sizing code would flag a
 32202                                  ;			a bad environment if it reached 32767 bytes. Changed
 32203                                  ;			to allow 32768 bytes of environment.
 32204                                  ;
 32205                                  ;		M047 - Release the allocated UMB when we failed to load a 
 32206                                  ;		       COM file high. Also ensure that if the biggest block
 32207                                  ;		       into which we load the com file is less than 64K then
 32208                                  ;		       we provide atleast 256 bytes of stack to the user.
 32209                                  ;
 32210                                  ;		M050 - Made Lie table search CASE insensitive
 32211                                  ;
 32212                                  ;		M060 - Removed special version table from the kernal and
 32213                                  ;                      put it in a device drive which puts the address
 32214                                  ;                      in the DOS DATA area location UU_IFS_DOS_CALL
 32215                                  ;		       as a DWORD.
 32216                                  ;
 32217                                  ;		M063 - Modified UMB support. If the HIGH_ONLY bit is set on
 32218                                  ;		       entry do not try to load low if there is no space in
 32219                                  ;		       UMBs.
 32220                                  ;
 32221                                  ;		M068 - Support for copy protect apps. Call ChkCopyProt to 
 32222                                  ;		       set a20off_count. Set bit EXECA20BIT in DOS_FLAG. Also
 32223                                  ;		       change return address to LeaveDos if AL=5.
 32224                                  ;
 32225                                  ;               20-Jul-1992 bens  Added ifdef RESTRICTED_BUILD code that
 32226                                  ;                      controls building a version of MSDOS.SYS that only
 32227                                  ;                      runs programs from a fixed list (defined in the
 32228                                  ;                      file RESTRICT.INC).  Search for "RESTRICTED_BUILD"
 32229                                  ;                      for details.  This feature is used to build a
 32230                                  ;                      "special" version of DOS that can be handed out to
 32231                                  ;                      OEM/ISV customers as part of a "service" disk.
 32232                                  ;
 32233                                  ; =========================================================================
 32234                                  
 32235                                  ;SAVEXIT  EQU  10
 32236                                  
 32237                                  ;BREAK	<$WAIT - return previous process error code>
 32238                                  ; =========================================================================
 32239                                  ;	$WAIT - Return previous process error code.
 32240                                  ;
 32241                                  ;	Assembler usage:
 32242                                  ;
 32243                                  ;	    MOV     AH, WaitProcess
 32244                                  ;	    INT     int_command
 32245                                  ;
 32246                                  ;	ENTRY	none
 32247                                  ;	EXIT	(ax) = exit code
 32248                                  ;	USES	all
 32249                                  ; =========================================================================
 32250                                  
 32251                                  	; 20/05/2019 - Retro DOS v4.0
 32252                                  	; DOSCODE:9B55h (MSDOS 6.21, MSDOS.SYS)
 32253                                  
 32254                                  	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 32255                                  	; DOSCODE:9A5Ah (MSDOS 5.0, MSDOS.SYS)	
 32256                                  _$WAIT:
 32257                                  	; 02/08/2018 - Retro DOS v3.0
 32258                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5E1h
 32259                                  
 32260 00005BD3 31C0                    	xor	AX,AX
 32261 00005BD5 368706[3403]            	xchg	AX,[ss:exit_code]
 32262 00005BDA E96DAA                  	jmp	SYS_RET_OK
 32263                                  
 32264                                  ; =========================================================================
 32265                                  ;BREAK <$exec - load/go a program>
 32266                                  ;	EXEC.ASM - EXEC System Call
 32267                                  ;
 32268                                  ;
 32269                                  ; Assembler usage:
 32270                                  ;	    lds     DX, Name
 32271                                  ;	    les     BX, Blk
 32272                                  ;	    mov     AH, Exec
 32273                                  ;	    mov     AL, FUNC
 32274                                  ;	    int     INT_COMMAND
 32275                                  ;
 32276                                  ;	AL  Function
 32277                                  ;	--  --------
 32278                                  ;	 0  Load and execute the program.
 32279                                  ;	 1  Load, create the program header but do not
 32280                                  ;	    begin execution.
 32281                                  ;	 3  Load overlay. No header created.
 32282                                  ;
 32283                                  ;	    AL = 0 -> load/execute program
 32284                                  ;
 32285                                  ;	    +---------------------------+
 32286                                  ;	    | WORD segment address of	|
 32287                                  ;	    | environment.		|
 32288                                  ;	    +---------------------------+
 32289                                  ;	    | DWORD pointer to ASCIZ	|
 32290                                  ;	    | command line at 80h	|
 32291                                  ;	    +---------------------------+
 32292                                  ;	    | DWORD pointer to default	|
 32293                                  ;	    | FCB to be passed at 5Ch	|
 32294                                  ;	    +---------------------------+
 32295                                  ;	    | DWORD pointer to default	|
 32296                                  ;	    | FCB to be passed at 6Ch	|
 32297                                  ;	    +---------------------------+
 32298                                  ;
 32299                                  ;	    AL = 1 -> load program
 32300                                  ;
 32301                                  ;	    +---------------------------+
 32302                                  ;	    | WORD segment address of	|
 32303                                  ;	    | environment.		|
 32304                                  ;	    +---------------------------+
 32305                                  ;	    | DWORD pointer to ASCIZ	|
 32306                                  ;	    | command line at 80h	|
 32307                                  ;	    +---------------------------+
 32308                                  ;	    | DWORD pointer to default	|
 32309                                  ;	    | FCB to be passed at 5Ch	|
 32310                                  ;	    +---------------------------+
 32311                                  ;	    | DWORD pointer to default	|
 32312                                  ;	    | FCB to be passed at 6Ch	|
 32313                                  ;	    +---------------------------+
 32314                                  ;	    | DWORD returned value of	|
 32315                                  ;	    | CS:IP			|
 32316                                  ;	    +---------------------------+
 32317                                  ;	    | DWORD returned value of	|
 32318                                  ;	    | SS:IP			|
 32319                                  ;	    +---------------------------+
 32320                                  ;
 32321                                  ;	    AL = 3 -> load overlay
 32322                                  ;
 32323                                  ;	    +---------------------------+
 32324                                  ;	    | WORD segment address where|
 32325                                  ;	    | file will be loaded.	|
 32326                                  ;	    +---------------------------+
 32327                                  ;	    | WORD relocation factor to |
 32328                                  ;	    | be applied to the image.	|
 32329                                  ;	    +---------------------------+
 32330                                  ;
 32331                                  ; Returns:
 32332                                  ;	    AX = error_invalid_function
 32333                                  ;	       = error_bad_format
 32334                                  ;	       = error_bad_environment
 32335                                  ;	       = error_not_enough_memory
 32336                                  ;	       = error_file_not_found
 32337                                  ; =========================================================================
 32338                                  ;
 32339                                  ;   Revision history:
 32340                                  ;
 32341                                  ;	 A000	version 4.00  Jan. 1988
 32342                                  ;
 32343                                  ; =========================================================================
 32344                                  
 32345                                  Exec_Internal_Buffer		EQU	OPENBUF
 32346                                  Exec_Internal_Buffer_Size	EQU	(128+128+53+curdirLen)
 32347                                  
 32348                                  ; =========================================================================
 32349                                  
 32350                                  ;IF1		; warning message on buffers
 32351                                  ;%out	Please make sure that the following are contiguous and of the
 32352                                  ;%out	following sizes:
 32353                                  ;%out
 32354                                  ;%out	OpenBuf     128
 32355                                  ;%out	RenBuf	    128
 32356                                  ;%out	SearchBuf    53
 32357                                  ;%out	DummyCDS    curdirLen
 32358                                  ;ENDIF
 32359                                  
 32360                                  ; =========================================================================
 32361                                  
 32362                                  ; =========================================================================
 32363                                  ;
 32364                                  ; =========================================================================
 32365                                  
 32366                                  	; 20/05/2019 - Retro DOS v4.0
 32367                                  	; DOSCODE:9B5Fh (MSDOS 6.21, MSDOS.SYS)
 32368                                  
 32369                                  	; 30/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 32370                                  	; DOSCODE:9B04h (MSDOS 5.0, MSDOS.SYS)
 32371                                  	
 32372                                  _$EXEC:
 32373                                  	; 02/08/2018 - Retro DOS v3.0
 32374                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5EF1h
 32375                                  
 32376                                  EXEC001S:
 32377                                  	;LocalVar    Exec_Blk		,DWORD
 32378                                  	;LocalVar    Exec_Func		,BYTE
 32379                                  	;LocalVar    Exec_Load_High	,BYTE
 32380                                  	;LocalVar    Exec_FH		,WORD
 32381                                  	;LocalVar    Exec_Rel_Fac	,WORD
 32382                                  	;LocalVar    Exec_Res_Len_Para	,WORD
 32383                                  	;LocalVar    Exec_Environ	,WORD
 32384                                  	;LocalVar    Exec_Size		,WORD
 32385                                  	;LocalVar    Exec_Load_Block	,WORD
 32386                                  	;LocalVar    Exec_DMA		,WORD
 32387                                  	;LocalVar    ExecNameLen 	,WORD
 32388                                  	;LocalVar    ExecName		,DWORD
 32389                                  	;
 32390                                  	;LocalVar    Exec_DMA_Save	,WORD
 32391                                  	;LocalVar    Exec_NoStack	,BYTE
 32392                                  
 32393                                  	; MSDOS 3.3 (& MSDOS 6.0)
 32394                                  	;%define	Exec_Blk	dword [bp-4]
 32395                                  	%define		Exec_Blk	[bp-4] ; 09/08/2018
 32396                                  	%define		Exec_BlkL	word [bp-4]	
 32397                                  	%define		Exec_BlkH	word [bp-2]
 32398                                  	%define		Exec_Func	byte [bp-5]
 32399                                  	%define		Exec_Load_High	byte [bp-6]
 32400                                  	%define		Exec_FH		word [bp-8]
 32401                                  	%define		Exec_Rel_Fac	word [bp-10]
 32402                                  	%define		Exec_Res_Len_Para word [bp-12]
 32403                                  	%define		Exec_Environ	word [bp-14]
 32404                                  	%define		Exec_Size	word [bp-16]
 32405                                  	%define		Exec_Load_Block	word [bp-18]
 32406                                  	%define		Exec_DMA	word [bp-20]
 32407                                  	%define		ExecNameLen	word [bp-22]
 32408                                  	;%define	ExecName	dword [bp-26]
 32409                                  	%define		ExecName	[bp-26] ; 09/08/2018
 32410                                  	%define		ExecNameL	word [bp-26]	
 32411                                  	%define		ExecNameH	word [bp-24]
 32412                                  	; MSDOS 6.0
 32413                                  	%define		Exec_DMA_Save	word [bp-28]
 32414                                  	%define		Exec_NoStack	byte [bp-29]
 32415                                  	
 32416                                  	; ==================================================================
 32417                                  	; validate function
 32418                                  	; ==================================================================
 32419                                  		      	
 32420                                  	; M068 - Start
 32421                                  	;
 32422                                  	; Reset the A20OFF_COUNT to 0. This is done as there is a 
 32423                                  	; possibility that the count may not be decremented all the way to
 32424                                  	; 0. A typical case is if the program for which we intended to keep 
 32425                                  	; the A20  off for a sufficiently long time (A20OFF_COUNT int 21 
 32426                                  	; calls), exits pre-maturely due to error conditions.
 32427                                  
 32428                                  	; MSDOS 6.0
 32429 00005BDD 36C606[8500]00          	mov	byte [SS:A20OFF_COUNT], 0
 32430                                  
 32431                                  	; If al=5 (ExecReady) we'll change the return address on the stack	
 32432                                  	; to be LeaveDos in msdisp.asm. This ensures that the EXECA20OFF
 32433                                  	; bit set in DOS_FLAG by ExceReady is not cleared in msdisp.asm
 32434                                  
 32435 00005BE3 3C05                    	cmp	al,5			; Q: is this ExecReady call
 32436                                  	;jne	short @f
 32437 00005BE5 7505                    	jne	short Exec_@f		; N: continue
 32438                                  					; Y: change ret addr. to LeaveDos.
 32439 00005BE7 59                      	pop	cx			; Note CX is not input to ExecReady
 32440 00005BE8 B9[1204]                	mov	cx,LeaveDOS
 32441 00005BEB 51                      	push	cx
 32442                                  ;@@:
 32443                                  Exec_@f:
 32444                                  	; M068 - End
 32445                                  	
 32446                                  	;Enter
 32447                                  
 32448 00005BEC 55                      	push	bp
 32449 00005BED 89E5                    	mov	bp,sp
 32450                                  	;;sub	sp,26	; MSDOS 3.3
 32451                                  	; 30/11/2022 (MSDOS 5.0, MSDOS.SYS compatibility)	
 32452                                  	;sub	sp,29	; MSDOS 6.0 (& MSDOS 6.21)
 32453                                  	; 17/12/2022
 32454                                  	; 20/05/2019
 32455 00005BEF 83EC1E                  	sub	sp,30	; Retro DOS v4.0	
 32456                                  
 32457                                  	; MSDOS 6.0
 32458 00005BF2 3C05                    	cmp	AL,5			; only 0, 1, 3 or 5 are allowed ;M028
 32459                                  					; M030
 32460 00005BF4 7614                    	jna	short Exec_Check_2
 32461                                  
 32462                                  	; MSDOS 3.3
 32463                                  	;cmp	AL,3
 32464                                  	;jna	short Exec_Check_2
 32465                                  
 32466                                  Exec_Bad_Fun:
 32467 00005BF6 36C606[2303]01          	mov	byte [ss:EXTERR_LOCUS],errLOC_Unk ; 1
 32468                                  					; Extended Error Locus	;smr;SS Override
 32469                                  	;mov	al,1
 32470 00005BFC B001                    	mov	al,error_invalid_function
 32471                                  
 32472                                  Exec_Ret_Err:
 32473                                  	;Leave
 32474 00005BFE 89EC                    	mov	sp,bp
 32475 00005C00 5D                      	pop	bp
 32476                                  	;transfer SYS_RET_ERR
 32477 00005C01 E94FAA                  	jmp	SYS_RET_ERR
 32478                                  
 32479                                  	; MSDOS 6.0
 32480                                  ExecReadyJ:
 32481 00005C04 E8FD17                  	call	ExecReady		; M028
 32482 00005C07 E90504                  	jmp	norm_ovl		; do a Leave & xfer sysret_OK ; M028
 32483                                  
 32484                                  Exec_Check_2:
 32485 00005C0A 3C02                    	cmp	AL,2			
 32486 00005C0C 74E8                    	je	short Exec_Bad_Fun
 32487                                  
 32488                                  	; MSDOS 6.0
 32489 00005C0E 3C04                    	cmp	al,4			; 2 & 4 are not allowed
 32490 00005C10 74E4                    	je	short Exec_Bad_Fun
 32491                                  	
 32492 00005C12 3C05                    	cmp	al,5			; M028 ; M030
 32493 00005C14 74EE                    	je	short ExecReadyJ	; M028
 32494                                  
 32495                                  	;mov	[bp-4],bx
 32496 00005C16 895EFC                  	mov	Exec_BlkL,BX		; stash args
 32497                                  	;mov	[bp-2],es
 32498 00005C19 8C46FE                  	mov	Exec_BlkH,ES
 32499                                  	;mov	[bp-5],al
 32500 00005C1C 8846FB                  	mov	Exec_Func,AL
 32501                                  	;mov	byte [bp-6],0
 32502 00005C1F C646FA00                	mov	Exec_Load_High,0
 32503                                  
 32504                                  	;mov	[bp-26],dx
 32505 00005C23 8956E6                  	mov	ExecNameL,DX		; set up length of exec name
 32506                                  	;mov	[bp-24],ds
 32507 00005C26 8C5EE8                  	mov	ExecNameH,DS
 32508 00005C29 89D6                    	mov	SI,DX			; move pointer to convenient place
 32509                                  	;invoke	DStrLen
 32510 00005C2B E813B6                  	call	DStrLen
 32511                                  	;mov	[bp-22],cx
 32512 00005C2E 894EEA                  	mov	ExecNameLen,CX		; save length
 32513                                  
 32514                                  	; MSDOS 6.0
 32515 00005C31 36A0[0203]              	mov	al,[ss:AllocMethod]	; M063: save alloc method in 
 32516 00005C35 36A2[8400]              	mov	[ss:ALLOCMSAVE],al	; M063: AllocMsave
 32517                                  
 32518 00005C39 30C0                    	xor	AL,AL			; open for reading
 32519 00005C3B 55                      	push	BP
 32520                                  
 32521                                  	; MSDOS 6.0
 32522                                  	;or	byte [ss:DOS_FLAG],1
 32523 00005C3C 36800E[8600]01          	or	byte [ss:DOS_FLAG],EXECOPEN ; this flag is set to indicate to 
 32524                                  					; the redir that this open call is
 32525                                  					; due to an exec.
 32526                                  
 32527                                  	;invoke	$OPEN			; is the file there?
 32528 00005C42 E80513                  	call	_$OPEN
 32529                                  
 32530                                  	; MSDOS 6.0
 32531 00005C45 9C                      	pushf
 32532                                  	; 02/06/2019
 32533                                  	;and	byte [ss:DOS_FLAG],0FEh
 32534 00005C46 368026[8600]FE          	and	byte [ss:DOS_FLAG],~EXECOPEN ; reset flag
 32535 00005C4C 9D                      	popf
 32536                                  
 32537 00005C4D 5D                      	pop	BP
 32538                                  
 32539                                  	; MSDOS 3.3 & MSDOS 6.0
 32540 00005C4E 72AE                    	jc	short Exec_Ret_Err
 32541                                  
 32542                                  	;mov	[bp-8],ax
 32543 00005C50 8946F8                  	mov	Exec_FH,AX
 32544 00005C53 89C3                    	mov	BX,AX
 32545 00005C55 30C0                    	xor	AL,AL
 32546                                  	;invoke	$Ioctl
 32547 00005C57 E883C6                  	call	_$IOCTL
 32548 00005C5A 7207                    	jc	short Exec_BombJ
 32549                                  
 32550                                  	;test	dl,80h
 32551 00005C5C F6C280                  	test	DL,devid_ISDEV
 32552 00005C5F 740A                    	jz	short Exec_Check_Environ
 32553                                  
 32554                                  	;mov	al,2
 32555 00005C61 B002                    	mov	AL,error_file_not_found
 32556                                  Exec_BombJ:
 32557 00005C63 E9CA00                  	jmp	Exec_Bomb
 32558                                  
 32559                                  BadEnv:
 32560                                  	;mov	al,0Ah
 32561 00005C66 B00A                    	mov	AL,error_bad_environment
 32562 00005C68 E9C500                  	jmp	Exec_Bomb
 32563                                  
 32564                                  Exec_Check_Environ:
 32565                                  	;mov	word [bp-18],0
 32566 00005C6B C746EE0000              	mov	Exec_Load_Block,0
 32567                                  	;mov	word [bp-14],0
 32568 00005C70 C746F20000              	mov	Exec_Environ,0
 32569                                  					; overlays... no environment
 32570                                  	;test	byte [bp-5],2
 32571 00005C75 F646FB02                	test	Exec_Func,exec_func_overlay
 32572 00005C79 7552                    	jnz	short Exec_Read_Header
 32573                                  
 32574                                  	;lds	si,[bp-4]
 32575 00005C7B C576FC                  	lds	SI,Exec_Blk		; get block
 32576 00005C7E 8B04                    	mov	ax,[SI]
 32577                                  	;mov	AX,[SI+EXEC1.ENVIRON]	; address of environ
 32578 00005C80 09C0                    	or	AX,AX
 32579 00005C82 750C                    	jnz	short Exec_Scan_Env
 32580                                  
 32581 00005C84 368E1E[3003]            	mov	DS,[SS:CurrentPDB]	;smr;SS Override
 32582                                  	;mov	ax,[44]
 32583 00005C89 A12C00                  	mov	AX,[PDB.ENVIRON]
 32584                                  
 32585                                  ; MSDOS 6.0
 32586                                  ;---------------------------------------------BUG 92 4/30/90-----------------
 32587                                  ;
 32588                                  ; Exec_environ is being correctly initialized after the environment has been
 32589                                  ; allocated and copied form the parent's env. It must not be initialized here.
 32590                                  ; Because if the call to $alloc below fails Exec_dealloc will deallocate the
 32591                                  ; parent's environment.
 32592                                  ;	mov	Exec_Environ,AX
 32593                                  ;
 32594                                  ;----------------------------------------------------------------------------
 32595                                  
 32596                                  	;mov	[bp-14],ax
 32597                                  	;mov	Exec_Environ,ax
 32598                                  
 32599 00005C8C 09C0                    	or	AX,AX
 32600 00005C8E 743D                    	jz	short Exec_Read_Header
 32601                                  
 32602                                  Exec_Scan_Env:
 32603 00005C90 8EC0                    	mov	ES,AX
 32604 00005C92 31FF                    	xor	DI,DI
 32605                                  	;mov	cx,7FFFh ; MSDOS 3.3
 32606 00005C94 B90080                  	mov	CX,8000h ; MSDOS 6.0	; at most 32k of environment ;M040
 32607 00005C97 30C0                    	xor	AL,AL
 32608                                  
 32609                                  Exec_Get_Environ_Len:
 32610 00005C99 F2AE                    	repnz	scasb			; find that nul byte
 32611 00005C9B 75C9                    	jnz	short BadEnv
 32612                                  
 32613 00005C9D 49                      	dec	CX			; Dec CX for the next nul byte test
 32614 00005C9E 78C6                    	js	short BadEnv		; gone beyond the end of the environment
 32615                                  
 32616 00005CA0 AE                      	scasb				; is there another nul byte?
 32617 00005CA1 75F6                    	jnz	short Exec_Get_Environ_Len ; no, scan some more
 32618                                  
 32619 00005CA3 57                      	push	DI
 32620                                  	;lea	bx,[DI+11h]
 32621 00005CA4 8D5D11                  	lea	BX,[DI+0Fh+2]
 32622                                  	;add	bx,[bp-22]
 32623 00005CA7 035EEA                  	add	BX,ExecNameLen		; BX <- length of environment
 32624                                  					; remember argv[0] length
 32625                                  					; round up and remember argc
 32626 00005CAA B104                    	mov	CL,4
 32627 00005CAC D3EB                    	shr	BX,CL			; number of paragraphs needed
 32628 00005CAE 06                      	push	ES
 32629                                  	;invoke	$Alloc			; can we get the space?
 32630 00005CAF E84406                  	call	_$ALLOC
 32631 00005CB2 1F                      	pop	DS
 32632 00005CB3 59                      	pop	CX
 32633                                  
 32634                                  	;jnc	short Exec_Save_Environ
 32635                                  	;jmp	SHORT Exec_No_Mem	; nope... cry and sob
 32636                                  	; 17/12/2022
 32637 00005CB4 7274                    	jc	short Exec_No_Mem ; 02/06/2019
 32638                                  	; 30/11/2022 (MSDOS 5.0, MSDOS.SYS compatibility)
 32639                                  	;jnc	short Exec_Save_Environ
 32640                                  	;jmp	SHORT Exec_No_Mem
 32641                                  
 32642                                  Exec_Save_Environ:
 32643 00005CB6 8EC0                    	mov	ES,AX
 32644                                  	;mov	[bp-14],ax
 32645 00005CB8 8946F2                  	mov	Exec_Environ,AX 	; save him for a rainy day
 32646 00005CBB 31F6                    	xor	SI,SI
 32647 00005CBD 89F7                    	mov	DI,SI
 32648 00005CBF F3A4                    	rep	movsb			; copy the environment
 32649 00005CC1 B80100                  	mov	AX,1
 32650 00005CC4 AB                      	stosw
 32651                                  	;lds	si,[bp-26]
 32652 00005CC5 C576E6                  	lds	SI,ExecName
 32653                                  	;mov	cx,[bp-22]
 32654 00005CC8 8B4EEA                  	mov	CX,ExecNameLen
 32655 00005CCB F3A4                    	rep	movsb
 32656                                  
 32657                                  Exec_Read_Header:
 32658                                  	; We read in the program header into the above data area and
 32659                                  	; determine where in this memory the image will be located.
 32660                                  
 32661                                  	;Context DS
 32662 00005CCD 16                      	push	ss
 32663 00005CCE 1F                      	pop	ds
 32664                                  	;mov	cx,26
 32665 00005CCF B91A00                  	mov	CX,exec_header_len	; header size
 32666 00005CD2 BA[C70F]                	mov	DX,exec_signature
 32667 00005CD5 06                      	push	ES
 32668 00005CD6 1E                      	push	DS
 32669 00005CD7 E88304                  	call	ExecRead
 32670 00005CDA 1F                      	pop	DS
 32671 00005CDB 07                      	pop	ES
 32672 00005CDC 7250                    	jc	short Exec_Bad_File
 32673                                  
 32674 00005CDE 09C0                    	or	AX,AX
 32675 00005CE0 744C                    	jz	short Exec_Bad_File
 32676                                  	;cmp	ax,26
 32677 00005CE2 83F81A                  	cmp	AX,exec_header_len	; did we read the right number?
 32678 00005CE5 7519                    	jnz	short Exec_Com_Filej	; yep... continue
 32679                                  
 32680 00005CE7 F706[D30F]FFFF          	test	word [exec_max_BSS],-1 	; indicate load high?
 32681 00005CED 7504                    	jnz	short Exec_Check_Sig
 32682                                  
 32683                                  	;mov	byte [bp-6],0FFh
 32684 00005CEF C646FAFF                	mov	Exec_Load_High,-1
 32685                                  
 32686                                  Exec_Check_Sig:
 32687 00005CF3 A1[C70F]                	mov	AX,[exec_signature]	; rms;NSS
 32688                                  	;cmp	ax,5A4Dh ; 'MZ'
 32689 00005CF6 3D4D5A                  	cmp	AX,exe_valid_signature	; zibo arises!
 32690 00005CF9 7408                    	jz	short Exec_Save_Start 	; assume com file if no signature
 32691                                  
 32692                                  	;cmp	ax,4D5Ah ; 'ZM'
 32693 00005CFB 3D5A4D                  	cmp	AX,exe_valid_old_signature  ; zibo arises!
 32694 00005CFE 7403                    	jz	short Exec_Save_Start 	; assume com file if no signature
 32695                                  
 32696                                  Exec_Com_Filej:
 32697 00005D00 E9E901                  	jmp	Exec_Com_File
 32698                                  
 32699                                  	; We have the program header... determine memory requirements
 32700                                  
 32701                                  Exec_Save_Start:
 32702 00005D03 A1[CB0F]                	mov	AX,[exec_pages]		; get 512-byte pages	;rms;NSS
 32703 00005D06 B105                    	mov	CL,5			; convert to paragraphs
 32704 00005D08 D3E0                    	shl	AX,CL
 32705 00005D0A 2B06[CF0F]              	sub	AX,[exec_par_dir] 	; AX = size in paragraphs ;rms;NSS
 32706                                  	;mov	[bp-12],ax
 32707 00005D0E 8946F4                  	mov	Exec_Res_Len_Para,AX
 32708                                  
 32709                                  		; Do we need to allocate memory?
 32710                                  		; Yes if function is not load-overlay
 32711                                  
 32712                                  	;test	byte [bp-5],2
 32713 00005D11 F646FB02                	test	Exec_Func,exec_func_overlay
 32714 00005D15 7445                    	jz	short Exec_Allocate	; allocation of space
 32715                                  
 32716                                  		; get load address from block
 32717                                  
 32718                                  	;les	di,[bp-4]
 32719 00005D17 C47EFC                  	les	DI,Exec_Blk
 32720 00005D1A 268B05                  	mov	ax,[es:di]
 32721                                  	;mov	AX,[ES:DI+EXEC3.load_addr]
 32722                                  	;mov	[bp-20],ax
 32723 00005D1D 8946EC                  	mov	Exec_DMA,AX
 32724                                  
 32725                                  	; 17/12/2022
 32726                                  	;;mov	ax,[es:di+2]
 32727                                  	;mov	AX,[ES:DI+EXEC3.reloc_fac]
 32728                                  	;;mov	[bp-10],ax
 32729                                  	;mov	Exec_Rel_Fac,AX
 32730                                  
 32731                                  	; 17/12/2022
 32732                                  	; 30/11/2022 (!most proper code!)
 32733                                  	;mov	dx,[es:di+2]
 32734 00005D20 268B5502                	mov	dx,[ES:DI+EXEC3.reloc_fac]
 32735                                  	;mov	[bp-10],dx
 32736 00005D24 8956F6                  	mov	Exec_Rel_Fac,dx
 32737                                  	; ax = Exec_DMA
 32738 00005D27 E9DE00                  	jmp	Exec_Find_Res
 32739                                  
 32740                                  ; 17/12/2022
 32741                                  ; 30/11/2022 (MSDOS 5.0, MSDOS.SYS compatibility)
 32742                                  ; 27/09/2023
 32743                                  %if 0
 32744                                  	; 02/06/2019 - Retro DOS v4.0
 32745                                  	;mov	ax,[bp-20]  ; *+*
 32746                                  	mov	AX,Exec_DMA ; *+*
 32747                                  	; 10/08/2018
 32748                                  	jmp	Exec_Find_Res		; M000
 32749                                  %endif
 32750                                  
 32751                                  Exec_No_Mem:
 32752                                  	;mov	al,8
 32753 00005D2A B008                    	mov	AL,error_not_enough_memory
 32754 00005D2C EB02                    	jmp	short Exec_Bomb
 32755                                  
 32756                                  Exec_Bad_File:
 32757                                  	;mov	al,0Bh
 32758 00005D2E B00B                    	mov	AL,error_bad_format
 32759                                  
 32760                                  Exec_Bomb:
 32761                                  	;mov	bx,[bp-8]
 32762 00005D30 8B5EF8                  	mov	BX,Exec_FH
 32763 00005D33 E84004                  	call	Exec_Dealloc
 32764                                  	;LeaveCrit CritMem
 32765 00005D36 E839B6                  	call	LCritMEM
 32766                                  	;save	<AX,BP>
 32767 00005D39 50                      	push	ax
 32768 00005D3A 55                      	push	bp
 32769                                  	;invoke	$CLOSE
 32770 00005D3B E83D0A                  	call	_$CLOSE
 32771                                  	;restore <BP,AX>
 32772 00005D3E 5D                      	pop	bp
 32773 00005D3F 58                      	pop	ax
 32774 00005D40 E9BBFE                  	jmp	Exec_Ret_Err
 32775                                  
 32776                                  Exec_Chk_Mem: 
 32777                                  
 32778                                  	; 24/09/2023
 32779                                  	; ds = DOSDATA
 32780                                  ; 17/12/2022
 32781                                  ; 30/11/2022 (MSDOS 5.0, MSDOS.SYS compatibility)
 32782                                  ;%if 0
 32783                                  	; MSDOS 6.0    			; M063 - Start
 32784                                  	;mov	al,[ss:AllocMethod]	; save current alloc method in ax
 32785                                  	; 10/06/2019
 32786 00005D43 A0[0203]                	mov	al,[AllocMethod]
 32787                                  	;mov	bl,[ss:ALLOCMSAVE]
 32788 00005D46 8A1E[8400]              	mov	bl,[ALLOCMSAVE]
 32789                                  	;mov	[ss:AllocMethod],bl	; restore original allocmethod
 32790 00005D4A 881E[0203]              	mov	[AllocMethod],bl
 32791                                  	
 32792 00005D4E F6C340                  	test	bl,HIGH_ONLY ; 40h	; Q: was the HIGH_ONLY bit already set
 32793 00005D51 75D7                    	jnz	short Exec_No_Mem	; Y: no space in UMBs. Quit
 32794                                  	;				; N: continue
 32795                                  	;
 32796 00005D53 A840                    	test	al,HIGH_ONLY		; Q: did we set the HIGH_ONLY bit
 32797 00005D55 74D3                    	jz	short Exec_No_Mem	; N: no memory 
 32798                                  	; 02/06/2019
 32799                                  	;mov	ax,[ss:SAVE_AX]		; Y: restore ax and
 32800 00005D57 A1[8A00]                	mov	ax,[SAVE_AX]
 32801                                  	;jmp	short Exec_Norm_Alloc	;    Try again
 32802                                  					; M063 - End
 32803 00005D5A EB2B                    	jmp	short Exec_Norm_Alloc1
 32804                                  ;%endif
 32805                                  
 32806                                  ; 17/12/2022
 32807                                  %if 0
 32808                                  	; 30/11/2022 (MSDOS 5.0, MSDOS.SYS compatibility)
 32809                                  	; MSDOS 6.0    			; M063 - Start
 32810                                  	mov	al,[ss:AllocMethod]	; save current alloc method in ax
 32811                                  	mov	bl,[ss:ALLOCMSAVE]
 32812                                  	mov	[ss:AllocMethod],bl	; restore original allocmethod
 32813                                  
 32814                                  	test	bl,HIGH_ONLY ; 40h	; Q: was the HIGH_ONLY bit already set
 32815                                  	jnz	short Exec_No_Mem	; Y: no space in UMBs. Quit
 32816                                  	;				; N: continue
 32817                                  	;
 32818                                  	test	al,HIGH_ONLY		; Q: did we set the HIGH_ONLY bit
 32819                                  	jz	short Exec_No_Mem	; N: no memory 
 32820                                  
 32821                                  	mov	ax,[ss:SAVE_AX]		; Y: restore ax and
 32822                                  	jmp	short Exec_Norm_Alloc	;    Try again
 32823                                  					; M063 - End
 32824                                  %endif
 32825                                  
 32826                                  Exec_Allocate:
 32827                                  	; 09/09/2018
 32828                                  
 32829                                  	; M005 - START
 32830                                  	; If there is no STACK segment for this exe file and if this
 32831                                  	; not an overlay and the resident size is less than 64K - 
 32832                                  	; 256 bytes we shall add 256 bytes to the programs 
 32833                                  	; resident memory requirement and set Exec_SP to this value.
 32834                                  	
 32835                                  	; 17/12/2022
 32836 00005D5C 29DB                    	sub	bx,bx ; 0	
 32837                                  
 32838                                  	; MSDOS 6.0
 32839                                  	;;mov	byte [bp-29],0
 32840                                  	;mov	Exec_NoStack,0
 32841                                  	; 17/12/2022
 32842 00005D5E 885EE3                  	mov	Exec_NoStack,bl ; 0
 32843 00005D61 391E[D50F]              	cmp	[exec_SS],bx ; 0
 32844                                  	;cmp	word [exec_SS],0	; Q: is there a stack seg
 32845 00005D65 7511                    	jne	short ea1		; Y: continue normal processing
 32846 00005D67 391E[D70F]              	cmp	[exec_SP],bx ; 0
 32847                                  	;cmp	word [exec_SP],0	; Q: is there a stack ptr
 32848 00005D6B 750B                    	jne	short ea1		; Y: continue normal processing
 32849                                  
 32850                                  	;inc	byte [bp-29]
 32851 00005D6D FE46E3                  	inc	Exec_NoStack
 32852 00005D70 3DF00F                  	cmp	ax,1000h-10h		; Q: is this >= 64K-256 bytes
 32853 00005D73 7303                    	jae	short ea1		; Y: don't set Exec_SP
 32854                                  
 32855 00005D75 83C010                  	add	ax,10h			; add 10h paras to mem requirement
 32856                                  ea1:
 32857                                  	; M005 - END
 32858                                  
 32859                                  	; MSDOS 6.0			; M000 - start
 32860                                  	; 20/05/2019
 32861                                  	; (ds = ss = DOSDATA)
 32862 00005D78 F606[0203]80            	test	byte [AllocMethod],HIGH_FIRST ; 80h
 32863                                  					; Q: is the alloc strat high_first
 32864 00005D7D 7405                    	jz	short Exec_Norm_Alloc	; N: normal allocate
 32865                                  					; Y: set high_only bit
 32866 00005D7F 800E[0203]40            	or	byte [AllocMethod],HIGH_ONLY ; 40h
 32867                                  					; M000 - end
 32868                                  Exec_Norm_Alloc:
 32869 00005D84 A3[8A00]                	mov	[SAVE_AX],ax		; M000: save ax for possible 2nd  
 32870                                  Exec_Norm_Alloc1:	; 02/06/2019
 32871                                  					; M000: attempt at allocating memory
 32872                                  	; MSDOS 3.3
 32873                                  	;push	ax			; M000
 32874                                  
 32875 00005D87 BBFFFF                  	mov	BX,0FFFFh		; see how much room in arena
 32876 00005D8A 1E                      	push	DS
 32877                                  	;invoke	$Alloc			; should have carry set and BX has max
 32878 00005D8B E86805                  	call	_$ALLOC
 32879 00005D8E 1F                      	pop	DS
 32880                                  
 32881                                  	; MSDOS 6.0
 32882 00005D8F A1[8A00]                	mov	AX,[SAVE_AX]		; M000
 32883                                  	; MSDOS 3.3
 32884                                  	;pop	ax			; M000
 32885                                  
 32886 00005D92 83C010                  	add	AX,10h			; room for header
 32887 00005D95 83FB11                  	cmp	BX,11h			; enough room for a header
 32888                                  	; MSDOS 6.0
 32889 00005D98 72A9                    	jb	short Exec_Chk_Mem	; M000
 32890                                  	; MSDOS 3.3	
 32891                                  	;jb	short Exec_No_Mem
 32892                                  
 32893 00005D9A 39D8                    	cmp	AX,BX			; is there enough for bare image?
 32894                                  	; MSDOS 6.0
 32895 00005D9C 77A5                    	ja	short Exec_Chk_Mem	; M000
 32896                                  	; MSDOS 3.3
 32897                                  	;ja	short Exec_No_Mem
 32898                                  
 32899                                  	;test	byte [bp-6],0FFh
 32900 00005D9E F646FAFF                	test	Exec_Load_High,-1	; if load high, use max
 32901 00005DA2 7518                    	jnz	short Exec_BX_Max	; use max
 32902                                  
 32903                                  	; 09/09/2018
 32904                                  
 32905 00005DA4 0306[D10F]              	add	AX,[exec_min_BSS] 	; go for min allocation;rms;NSS
 32906                                  	; MSDOS 6.0
 32907 00005DA8 7299                    	jc	short Exec_Chk_Mem		; M000
 32908                                  	; MSDOS 3.3
 32909                                  	;jc	short Exec_No_Mem
 32910                                  
 32911 00005DAA 39D8                    	cmp	AX,BX			; enough space?
 32912                                  	; MSDOS 6.0
 32913 00005DAC 7795                    	ja	short Exec_Chk_Mem	; M000: nope...	
 32914                                  	; MSDOS 3.3
 32915                                  	;ja	short Exec_No_Mem
 32916                                  
 32917 00005DAE 2B06[D10F]              	sub	AX,[exec_min_BSS] 	; rms;NSS
 32918 00005DB2 0306[D30F]              	add	AX,[exec_max_BSS] 	; go for the MAX
 32919 00005DB6 7204                    	jc	short Exec_BX_Max
 32920                                  
 32921 00005DB8 39D8                    	cmp	AX,BX
 32922 00005DBA 7602                    	jbe	short Exec_Got_Block
 32923                                  
 32924                                  Exec_BX_Max:
 32925 00005DBC 89D8                    	mov	AX,BX
 32926                                  
 32927                                  Exec_Got_Block:
 32928                                  	; 03/08/2018 - Retro DOS v3.0
 32929                                  
 32930 00005DBE 1E                      	push	DS
 32931 00005DBF 89C3                    	mov	BX,AX
 32932                                  	;mov	[bp-16],bx
 32933 00005DC1 895EF0                  	mov	Exec_Size,BX
 32934                                  	;invoke	$Alloc			; get the space
 32935 00005DC4 E82F05                  	call	_$ALLOC
 32936 00005DC7 1F                      	pop	DS
 32937                                  	; MSDOS 6.0
 32938                                  	;jc	short Exec_Chk_Mem	; M000
 32939                                  	; MSDOS 3.3
 32940                                  	;;jc	short Exec_No_Mem
 32941                                  	; 20/05/2019
 32942 00005DC8 7303                    	jnc	short ea0
 32943 00005DCA E976FF                  	jmp	Exec_Chk_Mem
 32944                                  ea0:
 32945                                  	; MSDOS 6.0
 32946 00005DCD 8A0E[8400]              	mov	cl,[ALLOCMSAVE]		; M063: 
 32947 00005DD1 880E[0203]              	mov	[AllocMethod],cl	; M063: restore allocmethod
 32948                                  
 32949                                  ;M029; Begin changes
 32950                                  ; This code does special handling for programs with no stack segment. If so,
 32951                                  ;check if the current block is larger than 64K. If so, we do not modify
 32952                                  ;Exec_SP. If smaller than 64K, we make Exec_SP = top of block. In either
 32953                                  ;case Exec_SS is not changed.
 32954                                  
 32955                                  	; MSDOS 6.0
 32956                                  	;cmp	byte [bp-29],0
 32957 00005DD5 807EE300                	cmp	Exec_NoStack,0
 32958                                  	;je	@f
 32959 00005DD9 7412                    	je	short ea2
 32960                                  
 32961 00005DDB 81FB0010                	cmp	bx,1000h		; Q: >= 64K memory block
 32962                                  	;jae	@f			; Y: Exec_SP = 0
 32963 00005DDF 730C                    	jae	short ea2
 32964                                  
 32965                                  ;Make Exec_SP point at the top of the memory block
 32966                                  
 32967 00005DE1 B104                    	mov	cl,4
 32968 00005DE3 D3E3                    	shl	bx,cl			; get byte offset
 32969 00005DE5 81EB0001                	sub	bx,100h			; take care of PSP
 32970 00005DE9 891E[D70F]              	mov	[exec_SP],bx		; Exec_SP = top of block
 32971                                  ea2:
 32972                                  ;@@:
 32973                                  ;M029; end changes
 32974                                  
 32975                                  	;mov	[bp-18],ax
 32976 00005DED 8946EE                  	mov	Exec_Load_Block,AX
 32977 00005DF0 83C010                  	add	AX,10h
 32978                                  	;test	byte [bp-6],0FFh
 32979 00005DF3 F646FAFF                	test	Exec_Load_High,-1
 32980 00005DF7 7409                    	jz	short Exec_Use_AX	; use ax for load info
 32981                                  
 32982                                  	;add	ax,[bp-16]
 32983 00005DF9 0346F0                  	add	AX,Exec_Size		; go to end
 32984                                  	;sub	ax,[bp-12]
 32985 00005DFC 2B46F4                  	sub	AX,Exec_Res_Len_Para	; drop off header
 32986 00005DFF 83E810                  	sub	AX,10h			; drop off pdb
 32987                                  
 32988                                  Exec_Use_AX:
 32989                                  	;mov	[bp-10],ax
 32990 00005E02 8946F6                  	mov	Exec_Rel_Fac,AX 	; new segment
 32991                                  	;mov	[bp-20],ax
 32992 00005E05 8946EC                  	mov	Exec_DMA,AX ; *+*	; beginning of dma
 32993                                  
 32994                                  	; Determine the location in the file of the beginning of
 32995                                  	; the resident
 32996                                  
 32997                                  ; 17/12/2022
 32998                                  ; 30/11/2022 (MSDOS 5.0, MSDOS.SYS compatibility)
 32999                                  ;%if 0
 33000                                  
 33001                                  Exec_Find_Res:
 33002                                  	; MSDOS 6.0
 33003                                  	;;mov	dx,[bp-20]
 33004                                  	;mov	DX,Exec_DMA ; *+*
 33005                                  	;;mov	[bp-28],dx
 33006                                  	;mov	Exec_DMA_Save,DX
 33007                                  
 33008                                  	; 17/12/2022
 33009                                  	; AX = Exec_DMA
 33010                                  
 33011                                  	; 02/06/2019 - Retro DOS v4.0
 33012                                  	;mov	[bp-28],ax ; *+*
 33013 00005E08 8946E4                  	mov	Exec_DMA_Save,AX ; *+*
 33014                                  
 33015                                  ;%endif
 33016                                  
 33017                                  ; 17/12/2022
 33018                                  %if 0
 33019                                  	; 30/11/2022 (MSDOS 5.0, MSDOS.SYS compatibility)
 33020                                  Exec_Find_Res:
 33021                                  	;mov	dx,[bp-20]
 33022                                  	mov	DX,Exec_DMA ; *+*
 33023                                  	;mov	[bp-28],dx
 33024                                  	mov	Exec_DMA_Save,DX
 33025                                  %endif
 33026                                  
 33027                                  	; MSDOS 3.3 (& MSDOS 6.0)
 33028 00005E0B 8B16[CF0F]              	mov	DX,[exec_par_dir]
 33029 00005E0F 52                      	push	DX
 33030 00005E10 B104                    	mov	CL,4
 33031 00005E12 D3E2                    	shl	DX,CL			; low word of location
 33032 00005E14 58                      	pop	AX
 33033 00005E15 B10C                    	mov	CL,12
 33034 00005E17 D3E8                    	shr	AX,CL			; high word of location
 33035 00005E19 89C1                    	mov	CX,AX			; CX <- high
 33036                                  
 33037                                  		; Read in the resident image (first, seek to it)
 33038                                  	;mov	bx,[bp-8]
 33039 00005E1B 8B5EF8                  	mov	BX,Exec_FH
 33040 00005E1E 1E                      	push	DS
 33041 00005E1F 30C0                    	xor	AL,AL
 33042                                  	;invoke	$Lseek			; Seek to resident
 33043 00005E21 E8D30A                  	call	_$LSEEK
 33044 00005E24 1F                      	pop	DS
 33045 00005E25 7303                    	jnc	short Exec_Big_Read
 33046                                  
 33047 00005E27 E906FF                  	jmp	Exec_Bomb
 33048                                  
 33049                                  Exec_Big_Read:				; Read resident into memory
 33050                                  	;mov	bx,[bp-12]
 33051 00005E2A 8B5EF4                  	mov	BX,Exec_Res_Len_Para
 33052 00005E2D 81FB0010                	cmp	BX,1000h		; Too many bytes to read?
 33053 00005E31 7203                    	jb	short Exec_Read_OK
 33054                                  
 33055 00005E33 BBE00F                  	mov	BX,0FE0h		; Max in one chunk FE00 bytes
 33056                                  
 33057                                  Exec_Read_OK:
 33058                                  	;sub	[bp-12],bx
 33059 00005E36 295EF4                  	sub	Exec_Res_Len_Para,BX	; We read (soon) this many
 33060 00005E39 53                      	push	BX
 33061 00005E3A B104                    	mov	CL,4
 33062 00005E3C D3E3                    	shl	BX,CL			; Get count in bytes from paras
 33063 00005E3E 89D9                    	mov	CX,BX			; Count in correct register
 33064 00005E40 1E                      	push	DS
 33065                                  	;mov	ds,[bp-20]
 33066 00005E41 8E5EEC                  	mov	DS,Exec_DMA		; Set up read buffer
 33067                                  
 33068 00005E44 31D2                    	xor	DX,DX
 33069 00005E46 51                      	push	CX			; Save our count
 33070 00005E47 E81303                  	call	ExecRead
 33071 00005E4A 59                      	pop	CX			; Get old count to verify
 33072 00005E4B 1F                      	pop	DS
 33073 00005E4C 7248                    	jc	short Exec_Bad_FileJ
 33074                                  
 33075 00005E4E 39C1                    	cmp	CX,AX			; Did we read enough?
 33076 00005E50 5B                      	pop	BX			; Get paragraph count back
 33077 00005E51 7408                    	jz	short ExecCheckEnd	; and do reloc if no more to read
 33078                                  
 33079                                  	; The read did not match the request. If we are off by 512
 33080                                  	; bytes or more then the header lied and we have an error.
 33081                                  
 33082 00005E53 29C1                    	sub	CX,AX
 33083 00005E55 81F90002                	cmp	CX,512
 33084 00005E59 733B                    	jae	short Exec_Bad_FileJ
 33085                                  
 33086                                  	; We've read in CX bytes... bump DTA location
 33087                                  
 33088                                  ExecCheckEnd:
 33089                                  	;add	[bp-20],bx
 33090 00005E5B 015EEC                  	add	Exec_DMA,BX		; Bump dma address
 33091                                  	;test	word [bp-12],0FFFFh
 33092 00005E5E F746F4FFFF              	test	Exec_Res_Len_Para,-1
 33093 00005E63 75C5                    	jnz	short Exec_Big_Read
 33094                                  
 33095                                  	; The image has now been read in. We must perform relocation
 33096                                  	; to the current location.
 33097                                  
 33098                                  exec_do_reloc:
 33099                                  	;mov	cx,[bp-10]
 33100 00005E65 8B4EF6                  	mov	CX,Exec_Rel_Fac
 33101 00005E68 A1[D50F]                	mov	AX,[exec_SS]		; get initial SS ;rms;NSS
 33102 00005E6B 01C8                    	add	AX,CX			; and relocate him
 33103 00005E6D A3[C10F]                	mov	[exec_init_SS],AX 	; rms;NSS
 33104                                  
 33105 00005E70 A1[D70F]                	mov	AX,[exec_SP]		; initial SP ;rms;NSS
 33106 00005E73 A3[BF0F]                	mov	[exec_init_SP],AX 	; rms;NSS
 33107                                  
 33108 00005E76 C406[DB0F]              	les	AX,[exec_IP]		; rms;NSS
 33109 00005E7A A3[C30F]                	mov	[exec_init_IP],AX 	; rms;NSS
 33110 00005E7D 8CC0                    	mov	AX,ES			; rms;NSS
 33111 00005E7F 01C8                    	add	AX,CX			; relocated...
 33112 00005E81 A3[C50F]                	mov	[exec_init_CS],AX 	; rms;NSS
 33113                                  
 33114 00005E84 31C9                    	xor	CX,CX
 33115 00005E86 8B16[DF0F]              	mov	DX,[exec_rle_table]	; rms;NSS
 33116                                  	;mov	bx,[bp-8]
 33117 00005E8A 8B5EF8                  	mov	BX,Exec_FH
 33118 00005E8D 1E                      	push	DS
 33119 00005E8E 31C0                    	xor	AX,AX
 33120                                  	;invoke	$Lseek
 33121 00005E90 E8640A                  	call	_$LSEEK
 33122 00005E93 1F                      	pop	DS
 33123 00005E94 7303                    	jnc	short exec_get_entries
 33124                                  
 33125                                  Exec_Bad_FileJ:
 33126 00005E96 E995FE                  	jmp	Exec_Bad_File
 33127                                  
 33128                                  exec_get_entries:
 33129 00005E99 8B16[CD0F]              	mov	DX,[exec_rle_count]	; Number of entries left ;rms;NSS
 33130                                  
 33131                                  exec_read_reloc:
 33132 00005E9D 52                      	push	DX
 33133                                  	;mov	dx,OPENBUF
 33134 00005E9E BA[BE03]                	mov	DX,Exec_Internal_Buffer
 33135                                  	;;mov	cx,388 ; MSDOS 3.3 ; (390>>2)<<2
 33136                                  	;mov	cx,396 ; MSDOS 6.0
 33137 00005EA1 B98C01                  	mov	CX,((Exec_Internal_Buffer_Size)/4)*4 ; (397>>2)<<2
 33138 00005EA4 1E                      	push	DS
 33139 00005EA5 E8B502                  	call	ExecRead
 33140 00005EA8 07                      	pop	ES
 33141 00005EA9 5A                      	pop	DX
 33142 00005EAA 72EA                    	jc	short Exec_Bad_FileJ
 33143                                  
 33144                                  	;;mov	cx,97 ;  MSDOS 3.3 ; (390>>2)
 33145                                  	;mov	cx,99 ;  MSDOS 6.0
 33146 00005EAC B96300                  	mov	CX,(Exec_Internal_Buffer_Size)/4 ; (397>>2)
 33147                                  					; Pointer to byte location in header
 33148                                  	;mov	di,OPENBUF
 33149 00005EAF BF[BE03]                	mov	DI,Exec_Internal_Buffer
 33150                                  	;mov	si,[bp-10]
 33151 00005EB2 8B76F6                  	mov	SI,Exec_Rel_Fac 	; Relocate a single address
 33152                                  
 33153                                  exec_reloc_one:
 33154 00005EB5 09D2                    	or	DX,DX			; Any more entries?
 33155 00005EB7 7416                    	jz	short Exec_Set_PDBJ
 33156                                  
 33157                                  exec_get_addr:
 33158 00005EB9 26C51D                  	lds	BX,[ES:DI]		; Get ra/sa of entry
 33159 00005EBC 8CD8                    	mov	AX,DS			; Relocate address of item
 33160                                  
 33161                                  	; MSDOS 6.0
 33162                                  ;;;;;;	add	AX,SI  ; MSDOS 3.3
 33163                                  	;add	ax,[bp-28]
 33164 00005EBE 0346E4                  	add	AX,Exec_DMA_Save
 33165                                  
 33166 00005EC1 8ED8                    	mov	DS,AX
 33167 00005EC3 0137                    	add	[BX],SI
 33168 00005EC5 83C704                  	add	DI,4
 33169 00005EC8 4A                      	dec	DX
 33170 00005EC9 E2EA                    	loop	exec_reloc_one		; End of internal buffer?
 33171                                  
 33172                                  	; We've exhausted a single buffer's worth. Read in the next
 33173                                  	; piece of the relocation table.
 33174                                  
 33175 00005ECB 06                      	push	ES
 33176 00005ECC 1F                      	pop	DS
 33177 00005ECD EBCE                    	jmp	short exec_read_reloc
 33178                                  
 33179                                  Exec_Set_PDBJ:
 33180                                  	; MSDOS 6.0
 33181                                  	
 33182                                  	; We now determine if this is a buggy exe packed file and if 
 33183                                  	; so we patch in the right code. Note that fixexepatch will
 33184                                  	; point to a ret if dos loads low. The load segment as 
 33185                                  	; determined above will be in exec_dma_save
 33186                                  	
 33187 00005ECF 06                      	push	es
 33188 00005ED0 50                      	push	ax			; M030
 33189 00005ED1 51                      	push	cx			; M030
 33190                                  	;mov	es,[bp-28]
 33191 00005ED2 8E46E4                  	mov	es,Exec_DMA_Save
 33192 00005ED5 36A1[C50F]              	mov	ax,[ss:exec_init_CS]	; M030
 33193 00005ED9 368B0E[C30F]            	mov	cx,[ss:exec_init_IP]	; M030
 33194 00005EDE 36FF16[F311]            	call	word [ss:FixExePatch]
 33195                                  	; 30/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 33196                                  	; (MSDOS 5.0 MSDOS.SYS does not contain 'Rational386Patch')
 33197                                  	;call	word [ss:Rational386PatchPtr]
 33198 00005EE3 59                      	pop	cx			; M030
 33199 00005EE4 58                      	pop	ax			; M030
 33200 00005EE5 07                      	pop	es
 33201                                  
 33202 00005EE6 E9DE00                  	jmp	Exec_Set_PDB
 33203                                  
 33204                                  Exec_No_Memj:
 33205 00005EE9 E93EFE                  	jmp	Exec_No_Mem
 33206                                  
 33207                                  	; we have a .COM file. First, determine if we are merely
 33208                                  	; loading an overlay.
 33209                                  
 33210                                  Exec_Com_File:
 33211                                  	;test	byte [bp-5],2
 33212 00005EEC F646FB02                	test	Exec_Func,exec_func_overlay
 33213 00005EF0 742D                    	jz	short Exec_Alloc_Com_File
 33214                                  	;lds	si,[bp-4]
 33215 00005EF2 C576FC                  	lds	SI,Exec_Blk		; get arg block
 33216 00005EF5 AD                      	lodsw				; get load address
 33217                                  	;mov	[bp-20],ax
 33218 00005EF6 8946EC                  	mov	Exec_DMA,AX
 33219 00005EF9 B8FFFF                  	mov	AX,0FFFFh
 33220 00005EFC EB63                    	jmp	short Exec_Read_Block	; read it all!
 33221                                  
 33222                                  Exec_Chk_Com_Mem:			
 33223                                  	; MSDOS 6.0	     		; M063 - Start
 33224 00005EFE 36A0[0203]              	mov	al,[ss:AllocMethod]	; save current alloc method in ax
 33225 00005F02 368A1E[8400]            	mov	bl,[ss:ALLOCMSAVE]
 33226 00005F07 36881E[0203]            	mov	[ss:AllocMethod],bl	; restore original allocmethod
 33227 00005F0C F6C340                  	test	bl,HIGH_ONLY ; 40h	; Q: was the HIGH_ONLY bit already set
 33228 00005F0F 75D8                    	jnz	short Exec_No_Memj	; Y: no space in UMBs. Quit
 33229                                  					; N: continue
 33230                                  	
 33231 00005F11 A840                    	test	al,HIGH_ONLY		; Q: did we set the HIGH_ONLY bit
 33232 00005F13 74D4                    	jz	short Exec_No_Memj	; N: no memory 
 33233                                  	
 33234                                  	;mov	ax,[bp-18]
 33235 00005F15 8B46EE                  	mov	ax,Exec_Load_Block	; M047: ax = block we just allocated	
 33236 00005F18 31DB                    	xor	bx,bx			; M047: bx => free arena
 33237 00005F1A E87502                  	call	ChangeOwner		; M047: free this block
 33238                                  	
 33239 00005F1D EB0E                    	jmp	short Exec_Norm_Com_Alloc
 33240                                  					; M063 - End
 33241                                  	
 33242                                  	; We must allocate the max possible size block (ick!)
 33243                                  	; and set up CS=DS=ES=SS=PDB pointer, IP=100, SP=max
 33244                                  	; size of block.
 33245                                  
 33246                                  Exec_Alloc_Com_File:
 33247                                  	; MSDOS 6.0			; M000 -start
 33248 00005F1F 36F606[0203]80          	test	byte [ss:AllocMethod],HIGH_FIRST ; 80h
 33249                                  					; Q: is the alloc strat high_first
 33250 00005F25 7406                    	jz	short Exec_Norm_Com_Alloc ; N: normal allocate
 33251                                  					; Y: set high_only bit
 33252 00005F27 36800E[0203]40          	or	byte [ss:AllocMethod],HIGH_ONLY ; 40h
 33253                                  					; M000 - end
 33254                                  Exec_Norm_Com_Alloc:			; M000
 33255                                  	; MSDOS 3.3 (& MSDOS 6.0)
 33256 00005F2D BBFFFF                  	mov	BX,0FFFFh
 33257                                  	;invoke	$Alloc			; largest piece available as error
 33258 00005F30 E8C303                  	call	_$ALLOC
 33259 00005F33 09DB                    	or	BX,BX
 33260                                  	; MSDOS 6.0
 33261 00005F35 74C7                    	jz	short Exec_Chk_Com_Mem	; M000
 33262                                  	; MSDOS 3.3
 33263                                  	;jz	short Exec_No_Memj
 33264                                  
 33265                                  	;mov	[bp-16],bx
 33266 00005F37 895EF0                  	mov	Exec_Size,BX		; save size of allocation block
 33267 00005F3A 53                      	push	BX
 33268                                  	;invoke	$ALLOC			; largest piece available
 33269 00005F3B E8B803                  	call	_$ALLOC
 33270 00005F3E 5B                      	pop	BX			; get size of block...
 33271                                  	;mov	[bp-18],ax
 33272 00005F3F 8946EE                  	mov	Exec_Load_Block,AX
 33273                                  
 33274 00005F42 83C010                  	add	AX,10h			; increment for header
 33275                                  	;mov	[bp-20],ax
 33276 00005F45 8946EC                  	mov	Exec_DMA,AX
 33277                                  
 33278 00005F48 31C0                    	xor	AX,AX			; presume 64K read...
 33279 00005F4A 81FB0010                	cmp	BX,1000h		; 64k or more in block?
 33280 00005F4E 730E                    	jae	short Exec_Read_Com	; yes, read only 64k
 33281                                  
 33282 00005F50 89D8                    	mov	AX,BX			; convert size to bytes
 33283 00005F52 B104                    	mov	CL,4
 33284 00005F54 D3E0                    	shl	AX,CL
 33285                                  	; 17/12/2022
 33286                                  	; 30/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 33287                                  	;			(MSDOS 5.0, MSDOS.SYS compatibility)
 33288                                  	; MSDOS 5.0
 33289                                  	;cmp	AX,100h   
 33290                                  	; 02/06/2019 - Retro DOS v4.0
 33291                                  	; MSDOS 6.0
 33292                                          ; 17/12/2022
 33293 00005F56 3D0002                  	cmp	AX,200h                 ; enough memory for PSP and stack?
 33294 00005F59 76A3                    	jbe	short Exec_Chk_Com_Mem	; M000: jump if not
 33295                                  	;;jbe	short Exec_No_Memj	; M000: jump if not
 33296                                  	;; Retro DOS v3.0 modification (on MSDOS 6.0 code) -03/08/2018-
 33297                                  	;;jbe	short Exec_Chk_Com_Mem	; M000: jump if not
 33298                                  	;jbe	short Exec_No_Memj	; M000: jump if not
 33299                                  
 33300                                  					; M047: size of the block is < 64K
 33301 00005F5B 2D0001                  	sub	ax,100h			; M047: reserve 256 bytes for stack
 33302                                  
 33303                                  Exec_Read_Com:
 33304                                  	; MSDOS 3.3 (& MSDOS 6.0)
 33305 00005F5E 2D0001                  	sub	AX,100h 		; remember size of psp
 33306                                  Exec_Read_Block:
 33307 00005F61 50                      	push	AX			; save number to read
 33308                                  	;mov	bx,[bp-8]
 33309 00005F62 8B5EF8                  	mov	BX,Exec_FH		; of com file
 33310 00005F65 31C9                    	xor	CX,CX			; but seek to 0:0
 33311 00005F67 89CA                    	mov	DX,CX
 33312 00005F69 31C0                    	xor	AX,AX			; seek relative to beginning
 33313                                  	;invoke	$Lseek			; back to beginning of file
 33314 00005F6B E88909                  	call	_$LSEEK
 33315 00005F6E 59                      	pop	CX			; number to read
 33316                                  	;mov	ds,[bp-20]
 33317 00005F6F 8E5EEC                  	mov	DS,Exec_DMA
 33318 00005F72 31D2                    	xor	DX,DX
 33319 00005F74 51                      	push	CX
 33320 00005F75 E8E501                  	call	ExecRead
 33321 00005F78 5E                      	pop	SI			; get number of bytes to read
 33322 00005F79 7303                    	jnc	short OkRead
 33323 00005F7B E9B0FD                  	jmp	Exec_Bad_File
 33324                                  
 33325                                  	; 10/09/2018
 33326                                  OkRead:
 33327 00005F7E 39F0                    	cmp	AX,SI			; did we read them all?
 33328                                  	; MSDOS 6.0
 33329                                  	;jz	short Exec_Chk_Com_Mem	; M00: exactly the wrong number...no 
 33330                                  	; MSDOS 3.3
 33331                                  	;;jz	short Exec_No_Memj	; M00: exactly the wrong number...
 33332 00005F80 7503                    	jne	short OkRead2
 33333 00005F82 E979FF                  	jmp	Exec_Chk_Com_Mem
 33334                                  OkRead2:
 33335                                  	; MSDOS 6.0
 33336 00005F85 368A1E[8400]            	mov	bl,[ss:ALLOCMSAVE]	; M063
 33337 00005F8A 36881E[0203]            	mov	[ss:AllocMethod],bl	; M063: restore alloc method
 33338                                  
 33339                                  	; MSDOS 3.3 (& MSDOS 6.0)
 33340                                  	;test	byte [bp-5],2
 33341 00005F8F F646FB02                	test	Exec_Func,exec_func_overlay
 33342 00005F93 7532                    	jnz	short Exec_Set_PDB	; no starto, chumo!
 33343                                  
 33344                                  	;mov	ax,[bp-20]
 33345 00005F95 8B46EC                  	mov	AX,Exec_DMA
 33346 00005F98 83E810                  	sub	AX,10h
 33347 00005F9B 36A3[C50F]              	mov	[SS:exec_init_CS],AX
 33348 00005F9F 36C706[C30F]0001        	mov	word [SS:exec_init_IP],100h ; initial IP is 100h
 33349                                  
 33350                                  	; SI is AT MOST FF00h. Add FE to account for PSP - word
 33351                                  	; of 0 on stack.
 33352                                  
 33353 00005FA6 81C6FE00                	add	SI,0FEh 		; make room for stack
 33354                                  
 33355                                  	; MSDOS 6.0
 33356 00005FAA 83FEFE                  	cmp	si,0FFFEh		; M047: Q: was there >= 64K available
 33357 00005FAD 7404                    	je	short Exec_St_Ok	; M047: Y: stack is fine
 33358 00005FAF 81C60001                	add	si,100h			; M047: N: add the xtra 100h for stack
 33359                                  
 33360                                  Exec_St_Ok:
 33361                                  	; MSDOS 3.3 (& MSDOS 6.0)
 33362 00005FB3 368936[BF0F]            	mov	[SS:exec_init_SP],SI 	; max value for read is also SP!;smr;SS Override
 33363 00005FB8 36A3[C10F]              	mov	[SS:exec_init_SS],AX 					;smr;SS Override
 33364 00005FBC 8ED8                    	mov	DS,AX
 33365 00005FBE C7040000                	mov	WORD [SI],0		; 0 for return
 33366                                  
 33367                                  	; MSDOS 6.0
 33368                                  
 33369                                  	; M068
 33370                                  	;
 33371                                  	; We now determine if this is a Copy Protected App. If so the 
 33372                                  	; A20OFF_COUNT is set to 6. Note that ChkCopyProt will point to a 
 33373                                  	; a ret if DOS is loaded low. Also DS contains the load segment.
 33374                                  
 33375 00005FC2 36FF16[6100]            	call	word [ss:ChkCopyProt]	
 33376                                  
 33377                                  Exec_Set_PDB:
 33378                                  	; MSDOS 3.3 (& MSDOS 6.0)
 33379                                  	;mov	bx,[bp-8]
 33380 00005FC7 8B5EF8                  	mov	BX,Exec_FH		; we are finished with the file.
 33381 00005FCA E8A901                  	call	Exec_Dealloc
 33382 00005FCD 55                      	push	BP
 33383                                  	;invoke	$Close			; release the jfn
 33384 00005FCE E8AA07                  	call	_$CLOSE
 33385 00005FD1 5D                      	pop	BP
 33386 00005FD2 E89301                  	call	Exec_Alloc
 33387                                  	;test	byte [bp-5],2
 33388 00005FD5 F646FB02                	test	Exec_Func,exec_func_overlay
 33389 00005FD9 743A                    	jz	short Exec_Build_Header
 33390                                  
 33391                                  	; MSDOS 6.0
 33392 00005FDB E8C201                  	call	Scan_Execname
 33393 00005FDE E8D601                  	call	Scan_Special_Entries
 33394                                  ;SR;
 33395                                  ;The current lie strategy uses the PSP to store the lie version. However,
 33396                                  ;device drivers are loaded as overlays and have no PSP. To handle them, we
 33397                                  ;use the Sysinit flag provided by the BIOS as part of a structure pointed at
 33398                                  ;by BiosDataPtr. If this flag is set, the overlay call has been issued from
 33399                                  ;Sysinit and therefore must be a device driver load. We then get the lie 
 33400                                  ;version for this driver and put it into the Sysinit PSP. When the driver
 33401                                  ;issues the version check, it gets the lie version until the next overlay
 33402                                  ;call is issued.
 33403                                  
 33404 00005FE1 36803E[3E10]00          	cmp	byte [ss:DriverLoad],0	;was Sysinit processing done?
 33405 00005FE7 7426                    	je	short norm_ovl		;yes, no special handling
 33406 00005FE9 56                      	push	si
 33407 00005FEA 06                      	push	es
 33408 00005FEB 36C436[3F10]            	les	si,[ss:BiosDataPtr]	;get ptr to BIOS data block
 33409                                  	 
 33410                                  	; (es:si points to 'SysinitPresent' address/flag in retrodos4.s) 
 33411 00005FF0 26803C00                	cmp	byte [es:si],0		;in Sysinit?
 33412 00005FF4 7411                    	je	short sysinit_done	;no, Sysinit is finished
 33413                                  	
 33414 00005FF6 368E06[3003]            	mov	es,[ss:CurrentPDB]	;es = current PSP (Sysinit PSP)
 33415 00005FFB 36FF36[BC0E]            	push	word [ss:SPECIAL_VERSION]
 33416 00006000 268F064000              	pop	word [es:PDB.Version]	;store lie version in Sysinit PSP
 33417                                  		;;; PDB.VERSION
 33418 00006005 EB06                    	jmp	short setver_done
 33419                                  sysinit_done:
 33420 00006007 36C606[3E10]00          	mov	byte [ss:DriverLoad],0	;Sysinit done,special handling off
 33421                                  setver_done:
 33422 0000600D 07                      	pop	es
 33423 0000600E 5E                      	pop	si
 33424                                  norm_ovl:
 33425                                  	;leave
 33426 0000600F 89EC                    	mov	sp,bp		
 33427 00006011 5D                      	pop	bp
 33428                                  
 33429                                  	;transfer SYS_RET_OK		; overlay load -> done
 33430 00006012 E935A6                  	jmp	SYS_RET_OK
 33431                                  
 33432                                  Exec_Build_Header:
 33433                                  	;mov	dx,[bp-18]
 33434 00006015 8B56EE                  	mov	DX,Exec_Load_Block
 33435                                  					; assign the space to the process
 33436                                  	;mov	si,1
 33437 00006018 BE0100                  	mov	SI,ARENA.OWNER		; pointer to owner field
 33438                                  	;mov	ax,[bp-14]
 33439 0000601B 8B46F2                  	mov	AX,Exec_Environ 	; get environ pointer
 33440 0000601E 09C0                    	or	AX,AX
 33441 00006020 7405                    	jz	short No_Owner		; no environment
 33442                                  
 33443 00006022 48                      	dec	AX			; point to header
 33444 00006023 8ED8                    	mov	DS,AX
 33445 00006025 8914                    	mov	[SI],DX 		; assign ownership
 33446                                  No_Owner:
 33447                                  	;mov	ax,[bp-18]
 33448                                  	;mov	AX,Exec_Load_Block	; get load block pointer
 33449                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 33450                                  	; 17/12/2022
 33451 00006027 89D0                    	mov	ax,dx ; 06/06/2019
 33452                                  	;mov	ax,Exec_Load_Block	; get load block pointer
 33453                                  	
 33454 00006029 48                      	dec	AX
 33455 0000602A 8ED8                    	mov	DS,AX			; point to header
 33456 0000602C 8914                    	mov	[SI],DX 		; assign ownership
 33457                                  
 33458                                  	; MSDOS 6.0
 33459 0000602E 1E                      	push	DS			;AN000;MS. make ES=DS
 33460 0000602F 07                      	pop	ES			;AN000;MS.
 33461                                  	;mov	di,8
 33462 00006030 BF0800                  	mov	DI,ARENA.NAME		;AN000;MS. ES:DI points to destination
 33463 00006033 E86A01                  	call	Scan_Execname		;AN007;MS. parse execname
 33464                                  					;	   ds:si->name, cx=name length
 33465 00006036 51                      	push	CX			;AN007;;MS. save for fake version
 33466 00006037 56                      	push	SI			;AN007;;MS. save for fake version
 33467                                  
 33468                                  MoveName:				;AN000;
 33469 00006038 AC                      	lodsb				;AN000;;MS. get char
 33470 00006039 3C2E                    	cmp	AL,'.'			;AN000;;MS. is '.' ,may be name.exe
 33471 0000603B 7408                    	jz	short Mem_Done		;AN000;;MS. no, move to header
 33472                                  					;AN000;
 33473 0000603D AA                      	stosb				;AN000;;MS. move char
 33474                                  					; MSKK bug fix - limit length copied
 33475 0000603E 83FF10                  	cmp	di,16 ; ARENAHEADERSIZE	; end of memory arena block?
 33476 00006041 7302                    	jae	short Mem_Done		; jump if so
 33477                                  	;
 33478 00006043 E2F3                    	loop	MoveName		;AN000;;MS. continue
 33479                                  Mem_Done:				;AN000;
 33480 00006045 30C0                    	xor	AL,AL			;AN000;;MS. make ASCIIZ
 33481                                  	;cmp	di,16
 33482 00006047 83FF10                  	cmp	DI,ARENAHEADERSIZE ; 16 ;AN000;MS. if not all filled
 33483 0000604A 7301                    	jae	short Fill8		;AN000;MS.
 33484                                  	
 33485 0000604C AA                      	stosb				;AN000;MS.
 33486                                  	
 33487                                  Fill8:					;AN000;
 33488 0000604D 5E                      	pop	SI			;AN007;MS. ds:si -> file name
 33489 0000604E 59                      	pop	CX			;AN007;MS.
 33490                                  	
 33491 0000604F E86501                  	call	Scan_Special_Entries	;AN007;MS.
 33492                                  
 33493                                  	; MSDOS 3.3 (& MSDOS 6.0)
 33494 00006052 52                      	push	DX
 33495                                  	;mov	si,[bp-16]
 33496 00006053 8B76F0                  	mov	SI,Exec_Size
 33497 00006056 01D6                    	add	SI,DX
 33498                                  	;Invoke	$Dup_PDB		; ES is now PDB
 33499 00006058 E884B0                  	call	_$DUP_PDB
 33500 0000605B 5A                      	pop	DX
 33501                                  
 33502                                  	;push	word [bp-14]
 33503 0000605C FF76F2                  	push	Exec_Environ
 33504                                  	;pop	WORD [ES:2Ch]
 33505 0000605F 268F062C00              	pop	word [ES:PDB.ENVIRON]
 33506                                  
 33507                                  	; MSDOS 6.0			; *** Added for DOS 5.00
 33508                                  					; version number in PSP
 33509 00006064 36FF36[BC0E]             	push	word [ss:SPECIAL_VERSION] ; Set the DOS version number to
 33510 00006069 268F064000              	pop	word [ES:PDB.Version]	; to be used for this application
 33511                                  		; PDB.VERSION
 33512                                  
 33513                                  	; MSDOS 3.3 (& MSDOS 6.0)	; set up proper command line stuff
 33514                                  	;lds	si,[bp-4]
 33515 0000606E C576FC                  	lds	SI,Exec_Blk		; get the block
 33516 00006071 1E                      	push	DS			; save its location
 33517 00006072 56                      	push	SI
 33518                                  	;lds	si,[si+6]
 33519 00006073 C57406                  	lds	SI,[SI+EXEC0.5C_FCB]	; get the 5c fcb
 33520                                  
 33521                                  	; DS points to user space 5C FCB
 33522                                  
 33523 00006076 B90C00                  	mov	CX,12			; copy drive, name and ext
 33524 00006079 51                      	push	CX
 33525 0000607A BF5C00                  	mov	DI,5Ch
 33526 0000607D 8A1C                    	mov	BL,[SI]
 33527 0000607F F3A4                    	rep	movsb
 33528                                  
 33529                                  	; DI = 5Ch + 12 = 5Ch + 0Ch = 68h
 33530                                  
 33531 00006081 31C0                    	xor	AX,AX			; zero extent, etc for CPM
 33532 00006083 AB                      	stosw
 33533 00006084 AB                      	stosw
 33534                                  
 33535                                  	; DI = 5Ch + 12 + 4 = 5Ch + 10h = 6Ch
 33536                                  
 33537 00006085 59                      	pop	CX
 33538 00006086 5E                      	pop	SI			; get block
 33539 00006087 1F                      	pop	DS
 33540 00006088 1E                      	push	DS			; save (again)
 33541 00006089 56                      	push	SI
 33542                                  	;lds	si,[si+0Ah]
 33543 0000608A C5740A                  	lds	SI,[SI+EXEC0.6C_FCB]	; get 6C FCB
 33544                                  
 33545                                  	; DS points to user space 6C FCB
 33546                                  
 33547 0000608D 8A3C                    	mov	BH,[SI] 		; do same as above
 33548 0000608F F3A4                    	rep	movsb
 33549 00006091 AB                      	stosw
 33550 00006092 AB                      	stosw
 33551 00006093 5E                      	pop	SI			; get block (last time)
 33552 00006094 1F                      	pop	DS
 33553                                  	;ld	si,[si+2]
 33554 00006095 C57402                  	lds	SI,[SI+EXEC0.COM_LINE]	; command line
 33555                                  
 33556                                  	; DS points to user space 80 command line
 33557                                  
 33558 00006098 80C980                  	or	CL,80h
 33559 0000609B 89CF                    	mov	DI,CX
 33560 0000609D F3A4                    	rep	movsb			; Wham!
 33561                                  
 33562                                  	; Process BX into default AX (validity of drive specs on args).
 33563                                  	; We no longer care about DS:SI.
 33564                                  
 33565 0000609F FEC9                    	dec	CL			; get 0FFh in CL
 33566 000060A1 88F8                    	mov	AL,BH
 33567 000060A3 30FF                    	xor	BH,BH
 33568                                  	;invoke	GetVisDrv
 33569 000060A5 E8400A                  	call	GetVisDrv
 33570 000060A8 7302                    	jnc	short Exec_BL
 33571                                  
 33572 000060AA 88CF                    	mov	BH,CL
 33573                                  
 33574                                  Exec_BL:
 33575 000060AC 88D8                    	mov	AL,BL
 33576 000060AE 30DB                    	xor	BL,BL
 33577                                  	;invoke	GetVisDrv
 33578 000060B0 E8350A                  	call	GetVisDrv
 33579 000060B3 7302                    	jnc	short Exec_Set_Return
 33580                                  
 33581 000060B5 88CB                    	mov	BL,CL
 33582                                  
 33583                                  Exec_Set_Return:
 33584                                  	;invoke	Get_User_Stack			; get his return address
 33585 000060B7 E8D6A3                  	call	Get_User_Stack
 33586                                  
 33587                                  	;push	word [si+14h]
 33588 000060BA FF7414                  	push	word [SI+user_env.user_CS]	; suck out the CS and IP
 33589                                  	;push	word [si+12h]
 33590 000060BD FF7412                  	push	word [SI+user_env.user_IP]
 33591                                  	;push	word [si+14h]
 33592 000060C0 FF7414                  	push	word [SI+user_env.user_CS]	; suck out the CS and IP
 33593                                  	;push	word [si+12h]
 33594 000060C3 FF7412                  	push	word [SI+user_env.user_IP]
 33595                                  	;pop	word [ES:0Ah]
 33596 000060C6 268F060A00              	pop	WORD [ES:PDB.EXIT]
 33597                                  	;pop	word [ES:0Ch]
 33598 000060CB 268F060C00              	pop	WORD [ES:PDB.EXIT+2]
 33599                                  
 33600 000060D0 31C0                    	xor	AX,AX
 33601 000060D2 8ED8                    	mov	DS,AX
 33602                                  					; save them where we can get them
 33603                                  					; later when the child exits.
 33604                                  	;pop	word [88h]
 33605 000060D4 8F068800                	pop	word [addr_int_terminate] ; 22h*4
 33606                                  	;pop	word [90h]
 33607 000060D8 8F068A00                	pop	word [addr_int_terminate+2] ; (22h*4)+2
 33608                                  
 33609 000060DC 36C706[2C03]8000        	mov	WORD [SS:DMAADD],80h	; SS Override
 33610 000060E3 368E1E[3003]            	mov	DS,[SS:CurrentPDB]	; SS Override
 33611 000060E8 368C1E[2E03]            	mov	[SS:DMAADD+2],DS	; SS Override
 33612                                  
 33613                                  	;test	byte [bp-5],1
 33614 000060ED F646FB01                	test	Exec_Func,exec_func_no_execute
 33615 000060F1 7427                    	jz	short exec_go
 33616                                  
 33617 000060F3 36C536[BF0F]            	lds	SI,[SS:exec_init_SP]	; get stack SS Override
 33618                                  	;les	di,[bp-4]
 33619 000060F8 C47EFC                  	les	DI,Exec_Blk		; and block for return
 33620                                  	;mov	[es:di+10h],ds
 33621 000060FB 268C5D10                	mov	[ES:DI+EXEC1.SS],DS	; return SS
 33622                                  
 33623 000060FF 4E                      	dec	SI			; 'push' default AX
 33624 00006100 4E                      	dec	SI
 33625 00006101 891C                    	mov	[SI],BX 		; save default AX reg
 33626                                  	;mov	[es:di+0Eh], si
 33627 00006103 2689750E                	mov	[ES:DI+EXEC1.SP],SI	; return 'SP'
 33628                                  
 33629 00006107 36C506[C30F]            	lds	AX,[SS:exec_init_IP]	; SS Override
 33630                                  	;mov	[es:di+14h],ds
 33631 0000610C 268C5D14                	mov	[ES:DI+EXEC1.CS],DS	; initial entry stuff
 33632                                  	;mov	[es:di+12h],ax
 33633 00006110 26894512                	mov	[ES:DI+EXEC1.IP],AX
 33634                                  	
 33635                                  	;leave
 33636 00006114 89EC                    	mov	sp,bp
 33637 00006116 5D                      	pop	bp	
 33638                                  
 33639                                  	;transfer SYS_RET_OK
 33640 00006117 E930A5                  	jmp	SYS_RET_OK
 33641                                  
 33642                                  exec_go:
 33643 0000611A 36C536[C30F]            	lds	SI,[SS:exec_init_IP]	; get entry point SS Override
 33644 0000611F 36C43E[BF0F]            	les	DI,[SS:exec_init_SP]	; new stack SS Override
 33645 00006124 8CC0                    	mov	AX,ES
 33646                                  
 33647                                  	; MSDOS 6.0
 33648 00006126 36803E[F211]00          	cmp	byte [SS:DosHasHMA],0	; Q: is dos in HMA (M021)
 33649 0000612C 741A                    	je	short Xfer_To_User	; N: transfer control to user
 33650                                  
 33651 0000612E 1E                      	push	ds			; Y: control must go to low mem stub
 33652                                  		
 33653 0000612F 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]		;    where we disable a20 and Xfer 
 33654                                  					;    control to user 
 33655 00006134 800E[8600]04            	or	byte [DOS_FLAG],EXECA20OFF ; M068:
 33656                                  					; M004: Set bit to signal int 21
 33657                                  					; ah = 25 & ah= 49. See dossym.inc 
 33658                                  					; under TAG M003 & M009 for 
 33659                                  					; explanation
 33660 00006139 8916[6300]              	mov	[A20OFF_PSP],dx		; M068: set the PSP for which A20 is
 33661                                  					; M068: going to be turned OFF.
 33662                                  	
 33663 0000613D 8CD8                    	mov	ax,ds			; ax = segment of low mem stub
 33664 0000613F 1F                      	pop	ds
 33665                                  	
 33666 00006140 50                      	push	ax			; ret far into the low mem stub
 33667 00006141 B8[FB10]                	mov	ax,disa20_xfer
 33668 00006144 50                      	push	ax
 33669 00006145 8CC0                    	mov	AX,ES			; restore ax
 33670 00006147 CB                      	retf
 33671                                  
 33672                                  Xfer_To_User:
 33673                                  	; DS:SI points to entry point
 33674                                  	; AX:DI points to initial stack
 33675                                  	; DX has PDB pointer
 33676                                  	; BX has initial AX value
 33677                                  
 33678 00006148 FA                      	cli
 33679                                  	; 15/08/2018
 33680 00006149 36C606[2103]00          	mov	BYTE [SS:INDOS],0	; SS Override
 33681                                  
 33682 0000614F 8ED0                    	mov	SS,AX			; set up user's stack
 33683 00006151 89FC                    	mov	SP,DI			; and SP
 33684 00006153 FB                      	sti
 33685                                  
 33686 00006154 1E                      	push	DS			; fake long call to entry
 33687 00006155 56                      	push	SI
 33688 00006156 8EC2                    	mov	ES,DX			; set up proper seg registers
 33689 00006158 8EDA                    	mov	DS,DX
 33690 0000615A 89D8                    	mov	AX,BX			; set up proper AX
 33691                                  
 33692 0000615C CB                      	retf
 33693                                  
 33694                                  ; 04/08/2018 - Retro DOS v3.0
 33695                                  
 33696                                  ;----------------------------------------------------------------------------
 33697                                  ;
 33698                                  ;----------------------------------------------------------------------------
 33699                                  
 33700                                  ExecRead:
 33701 0000615D E81600                  	CALL	Exec_Dealloc
 33702                                  	;mov	bx,[bp-8]
 33703 00006160 8B5EF8                  	MOV	bx,Exec_FH
 33704                                  
 33705 00006163 55                      	PUSH	BP
 33706 00006164 E82507                  	call	_$READ
 33707 00006167 5D                      	POP	BP
 33708                                  
 33709                                  	;CALL	Exec_Alloc
 33710                                  	;retn
 33711                                  	; 18/12/2022
 33712                                  	;jmp	short Exec_Alloc
 33713                                  
 33714                                  ; 18/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS) 
 33715                                  
 33716                                  ;----------------------------------------------------------------------------
 33717                                  ;
 33718                                  ;----------------------------------------------------------------------------
 33719                                  
 33720                                  Exec_Alloc:
 33721 00006168 53                      	push	BX
 33722                                  	;mov	BX,[CS:CurrentPDB]  ; MSDOS 3.3
 33723                                  	; 20/05/2019 - Retro DOS v4.0
 33724                                  	; MSDOS 6.0
 33725 00006169 368B1E[3003]            	mov	bx,[SS:CurrentPDB]  ; SS Override
 33726 0000616E E81000                  	call	ChangeOwners
 33727 00006171 E8FEB1                  	call	LCritMEM
 33728 00006174 5B                      	pop	BX
 33729 00006175 C3                      	retn
 33730                                  
 33731                                  ;----------------------------------------------------------------------------
 33732                                  ;
 33733                                  ;----------------------------------------------------------------------------
 33734                                  
 33735                                  Exec_Dealloc:
 33736 00006176 53                      	push	BX
 33737                                  	;mov	bx,0
 33738 00006177 29DB                    	sub	BX,BX		; (bx) = ARENA_OWNER_SYSTEM
 33739 00006179 E8DBB1                  	call	ECritMEM
 33740 0000617C E80200                  	call	ChangeOwners
 33741 0000617F 5B                      	pop	BX
 33742 00006180 C3                      	retn
 33743                                  
 33744                                  ; 18/12/2022
 33745                                  %if 0
 33746                                  ;----------------------------------------------------------------------------
 33747                                  ;
 33748                                  ;----------------------------------------------------------------------------
 33749                                  
 33750                                  Exec_Alloc:
 33751                                  	push	BX
 33752                                  	;mov	BX,[CS:CurrentPDB]  ; MSDOS 3.3
 33753                                  	; 20/05/2019 - Retro DOS v4.0
 33754                                  	; MSDOS 6.0
 33755                                  	mov	bx,[SS:CurrentPDB]  ; SS Override
 33756                                  	call	ChangeOwners
 33757                                  	call	LCritMEM
 33758                                  	pop	BX
 33759                                  	retn
 33760                                  
 33761                                  %endif
 33762                                  
 33763                                  ;----------------------------------------------------------------------------
 33764                                  ;
 33765                                  ;----------------------------------------------------------------------------
 33766                                  
 33767                                  ChangeOwners:
 33768 00006181 9C                      	pushf
 33769 00006182 50                      	push	AX
 33770                                  	;mov	ax,[bp-14]
 33771 00006183 8B46F2                  	mov	AX,Exec_Environ
 33772 00006186 E80900                  	call	ChangeOwner
 33773                                  	;mov	ax,[bp-18]
 33774 00006189 8B46EE                  	mov	AX,Exec_Load_Block
 33775 0000618C E80300                  	call	ChangeOwner
 33776 0000618F 58                      	pop	AX
 33777 00006190 9D                      	popf
 33778                                  chgown_retn:
 33779 00006191 C3                      	retn
 33780                                  
 33781                                  ;----------------------------------------------------------------------------
 33782                                  ;
 33783                                  ;----------------------------------------------------------------------------
 33784                                  
 33785                                  ChangeOwner:
 33786 00006192 09C0                    	or	AX,AX			; is area allocated?
 33787 00006194 74FB                    	jz	short chgown_retn	; no, do nothing
 33788 00006196 48                      	dec	AX
 33789 00006197 1E                      	push	DS
 33790 00006198 8ED8                    	mov	DS,AX
 33791 0000619A 891E0100                	mov	[ARENA.OWNER],BX
 33792 0000619E 1F                      	pop	DS
 33793 0000619F C3                      	retn
 33794                                  
 33795                                  ;----------------------------------------------------------------------------
 33796                                  ;
 33797                                  ;----------------------------------------------------------------------------
 33798                                  
 33799                                  ; 20/05/2019 - Retro DOS v4.0
 33800                                  
 33801                                  	; MSDOS 6.0
 33802                                  Scan_Execname:
 33803 000061A0 C576E6                  	lds	SI,ExecName		; DS:SI points to name
 33804                                  Scan_Execname1:				; M028
 33805                                  Save_Begin:				;
 33806 000061A3 89F1                    	mov	CX,SI			; CX= starting addr
 33807                                  Scan0:					;
 33808 000061A5 AC                      	lodsb				; get char
 33809                                  
 33810 000061A6 3C3A                    	cmp	AL,':'			; is ':' , may be A:name
 33811 000061A8 74F9                    	jz	short Save_Begin	; yes, save si
 33812 000061AA 3C5C                    	cmp	AL,'\'                  ; is '\', may be A:\name
 33813 000061AC 74F5                    	jz	short Save_Begin	; yes, save si
 33814 000061AE 3C00                    	cmp	AL,0			; is end of name
 33815 000061B0 75F3                    	jnz	short Scan0		; no, continue scanning
 33816 000061B2 29CE                    	sub	SI,CX			; get name's length
 33817 000061B4 87F1                    	xchg	SI,CX			; cx= length, si= starting addr
 33818                                  
 33819 000061B6 C3                      	retn
 33820                                  
 33821                                  ;----------------------------------------------------------------------------
 33822                                  ;
 33823                                  ;----------------------------------------------------------------------------
 33824                                  
 33825                                  ; 20/05/2019 - Retro DOS v4.0
 33826                                  
 33827                                  ; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 33828                                  ; DOSCODE:A0EDh (MSDOS 5.0, MSDOS.SYS)
 33829                                  
 33830                                  	; MSDOS 6.0
 33831                                  
 33832                                  Scan_Special_Entries:
 33833                                  
 33834 000061B7 49                      	dec	CX			; cx= name length
 33835                                  ;M060	mov	DI,[Special_Entries]	; es:di -> addr of special entries
 33836                                  					;reset to current version
 33837                                  	;mov	word [ss:SPECIAL_VERSION],1406h 
 33838                                  				; (MSDOS 6.21, MSDOS.SYS, DOSCODE:A14Eh)
 33839                                  	;mov	word [ss:SPECIAL_VERSION],5
 33840                                  				; (MSDOS 5.0, MSDOS.SYS, DOSCODE:A0EEh)
 33841                                  
 33842                                  				; 5 for Retro DOS 4.0 (01/12/2022, MSDOS 5.0)
 33843 000061B8 36C706[BC0E]0616        	mov	word [ss:SPECIAL_VERSION],(MINOR_VERSION<<8)+MAJOR_VERSION
 33844                                  				; 0005h for Retro DOS v4.1 (MSDOS 5.0)
 33845                                  				; 24/09/2023
 33846                                  				; 1606h for Retro DOS v4.2 (MSDOS 6.22)
 33847                                  ;***	call	Reset_Version
 33848                                  
 33849                                  ;M060	push	SS
 33850                                  ;M060	pop	ES
 33851                                  
 33852 000061BF 36C43E[5D00]            	les	DI,[SS:UU_IFS_DOS_CALL]	;M060; ES:DI --> Table in SETVER.SYS
 33853 000061C4 8CC0                    	mov	AX,ES			;M060; First do a NULL ptr check to
 33854 000061C6 09F8                    	or	AX,DI			;M060; be sure the table exists
 33855 000061C8 7427                    	jz	short End_List		;M060; If ZR then no table
 33856                                  
 33857                                  GetEntries:
 33858 000061CA 268A05                  	mov	AL,[ES:DI]		; end of list
 33859 000061CD 08C0                    	or	AL,AL
 33860 000061CF 7420                    	jz	short End_List		; yes
 33861                                  
 33862 000061D1 36893E[0E06]            	mov	[ss:TEMP_VAR2],DI	; save di
 33863 000061D6 38C8                    	cmp	AL,CL			; same length ?
 33864 000061D8 751B                    	jnz	short SkipOne 		; no
 33865                                  
 33866 000061DA 47                      	inc	DI			; es:di -> special name
 33867 000061DB 51                      	push	CX			; save length and name addr
 33868 000061DC 56                      	push	SI
 33869                                  
 33870                                  ; M050 - BEGIN
 33871                                  
 33872 000061DD 50                      	push	ax			; save len
 33873                                  sse_next_char:
 33874 000061DE AC                      	lodsb
 33875 000061DF E8CAEE                  	call	UCase
 33876 000061E2 AE                      	scasb
 33877 000061E3 750D                    	jne	short Not_Matched
 33878 000061E5 E2F7                    	loop	sse_next_char
 33879                                  	
 33880                                  ;	repz	cmpsb			; same name ?
 33881                                  ;	jnz	short Not_Matched	; no
 33882                                  
 33883 000061E7 58                      	pop	ax			; take len off the stack
 33884                                  
 33885                                  ; M050 - END
 33886                                  
 33887 000061E8 268B05                  	mov	AX,[ES:DI]		; get special version
 33888 000061EB 36A3[BC0E]              	mov	[ss:SPECIAL_VERSION],AX	; save it
 33889                                  
 33890                                  ;***	mov	AL,[ES:DI+2]		; get fake count
 33891                                  ;***	mov	[ss:FAKE_COUNT],AL 	; save it
 33892                                  
 33893 000061EF 5E                      	pop	SI
 33894 000061F0 59                      	pop	CX
 33895                                  	; 18/12/2022
 33896                                  	;jmp	SHORT End_List
 33897                                  
 33898                                  	; 18/12/2022
 33899                                  End_List:
 33900 000061F1 C3                      	retn
 33901                                  
 33902                                  Not_Matched:
 33903 000061F2 58                      	pop	ax			; get len from stack ; M050
 33904 000061F3 5E                      	pop	SI			; restore si,cx
 33905 000061F4 59                      	pop	CX
 33906                                  
 33907                                  SkipOne:
 33908 000061F5 368B3E[0E06]            	mov	DI,[ss:TEMP_VAR2]	; restore old di use SS Override
 33909 000061FA 30E4                    	xor	AH,AH			; position to next entry
 33910 000061FC 01C7                    	add	DI,AX
 33911                                  
 33912 000061FE 83C703                  	add	DI,3			; DI -> next entry length
 33913                                  ;***	add	DI,4			; DI -> next entry length
 33914                                  
 33915 00006201 EBC7                    	jmp	short GetEntries
 33916                                  
 33917                                  	; 18/12/2022
 33918                                  ;End_List:
 33919                                  	;retn
 33920                                  
 33921                                  ; 04/08/2018 - Retro DOS v3.0
 33922                                  ; IBMDOS.COm (MSDOS 3.3, 1987) - Offset 633Dh
 33923                                  
 33924                                  ;----------------------------------------------------------------------------
 33925                                  ;SUBTTL Terminate and stay resident handler
 33926                                  ;
 33927                                  ; Input:    DX is  an  offset  from  CurrentPDB  at which to
 33928                                  ;	    truncate the current block.
 33929                                  ;
 33930                                  ; output:   The current block is truncated (expanded) to be [DX+15]/16
 33931                                  ;	    paragraphs long.  An exit is simulated via resetting CurrentPDB
 33932                                  ;	    and restoring the vectors.
 33933                                  ;
 33934                                  ;----------------------------------------------------------------------------
 33935                                  
 33936                                  	; 20/05/2019 - Retro DOS v4.0
 33937                                  	; DOSCODE:A19Bh (MSDOS 6.21, MSDOS.SYS)
 33938                                  
 33939                                  	; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS5.0 MSDOS.SYS)
 33940                                  	; DOSCODE:A13Bh (MSDOS 5.0, MSDOS.SYS)
 33941                                  
 33942                                  _$KEEP_PROCESS:
 33943 00006203 50                      	push	AX			; keep exit code around
 33944                                  	;mov	byte [SS:EXIT_TYPE],3
 33945 00006204 36C606[7C05]03          	mov	BYTE [SS:EXIT_TYPE],EXIT_KEEP_PROCESS
 33946 0000620A 368E06[3003]            	mov	ES,[SS:CurrentPDB]
 33947 0000620F 83FA06                  	cmp	DX,6h			; keep enough space around for system
 33948 00006212 7303                    	jae	short Keep_Shrink	; info
 33949                                  
 33950 00006214 BA0600                  	mov	DX,6h
 33951                                  
 33952                                  Keep_Shrink:
 33953 00006217 89D3                    	mov	BX,DX
 33954 00006219 53                      	push	BX
 33955 0000621A 06                      	push	ES
 33956 0000621B E82E02                  	call	_$SETBLOCK		; ignore return codes.
 33957 0000621E 1F                      	pop	DS
 33958 0000621F 5B                      	pop	BX
 33959 00006220 7207                    	jc	short Keep_Done		; failed on modification
 33960                                  
 33961 00006222 8CD8                    	mov	AX,DS
 33962 00006224 01D8                    	add	AX,BX
 33963                                  	;mov	[2],ax
 33964 00006226 A30200                  	mov	[PDB.BLOCK_LEN],AX	;PBUGBUG
 33965                                  
 33966                                  Keep_Done:
 33967 00006229 58                      	pop	AX
 33968 0000622A EB26                    	jmp	SHORT exit_inner	; and let abort take care of the rest
 33969                                  
 33970                                  ;----------------------------------------------------------------------------
 33971                                  ;
 33972                                  ;----------------------------------------------------------------------------
 33973                                  
 33974                                  STAY_RESIDENT:
 33975                                  	;mov	ax,3100h
 33976 0000622C B80031                  	mov	AX,(KEEP_PROCESS<<8)+0 ; Lower part is return code;PBUGBUG
 33977 0000622F 83C20F                  	add	DX,15
 33978 00006232 D1DA                    	rcr	DX,1
 33979 00006234 B103                    	mov	CL,3
 33980 00006236 D3EA                    	shr	DX,CL
 33981                                  
 33982 00006238 E9D2A0                  	jmp	COMMAND
 33983                                  
 33984                                  ;----------------------------------------------------------------------------
 33985                                  ;SUBTTL $EXIT - return to parent process
 33986                                  ;   Assembler usage:
 33987                                  ;	    MOV     AL, code
 33988                                  ;	    MOV     AH, Exit
 33989                                  ;	    INT     int_command
 33990                                  ;   Error return:
 33991                                  ;	    None.
 33992                                  ;
 33993                                  ;----------------------------------------------------------------------------
 33994                                  
 33995                                  	; 20/05/2019 - Retro DOS v4.0
 33996                                  	; DOSCODE:A1D3h (MSDOS 6.21, MSDOS.SYS)
 33997                                  
 33998                                  	; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS5.0 MSDOS.SYS)
 33999                                  	; DOSCODE:A173h (MSDOS 5.0, MSDOS.SYS)
 34000                                  _$EXIT:
 34001                                  	; 04/08/2018 - Retro DOS v3.0
 34002                                  	; IBMDOSDOS.COM (MSDOS 3.3, 1987) - Offset 6375h
 34003 0000623B 30E4                    	xor	AH,AH
 34004 0000623D 368626[4D03]            	xchg	AH,[SS:DidCTRLC]
 34005 00006242 08E4                    	or	AH,AH
 34006                                  	;mov	BYTE [SS:EXIT_TYPE],0
 34007 00006244 36C606[7C05]00          	mov	BYTE [SS:EXIT_TYPE],EXIT_TERMINATE
 34008 0000624A 7406                    	jz	short exit_inner
 34009                                  	;mov	BYTE [SS:EXIT_TYPE],1
 34010 0000624C 36C606[7C05]01          	mov	BYTE [SS:EXIT_TYPE],EXIT_CTRL_C
 34011                                  
 34012                                  	;entry	Exit_inner
 34013                                  exit_inner:
 34014 00006252 E83BA2                  	call	Get_User_Stack		;PBUGBUG
 34015                                  
 34016 00006255 36FF36[3003]            	push	word [ss:CurrentPDB]
 34017                                  	;pop	word [si+14h]
 34018 0000625A 8F4414                  	pop	word [SI+user_env.user_CS] ;PBUGBUG
 34019 0000625D EB08                    	jmp	short abort_inner
 34020                                  
 34021                                  ;BREAK <$ABORT -- Terminate a process>
 34022                                  ;----------------------------------------------------------------------------
 34023                                  ; Inputs:
 34024                                  ;	user_CS:00 must point to valid program header block
 34025                                  ; Function:
 34026                                  ;	Restore terminate and Cntrl-C addresses, flush buffers and transfer
 34027                                  ;	to the terminate address
 34028                                  ; Returns:
 34029                                  ;	TO THE TERMINATE ADDRESS
 34030                                  ;----------------------------------------------------------------------------
 34031                                  
 34032                                  _$ABORT:
 34033 0000625F 30C0                    	xor	AL,AL
 34034                                  	;mov	byte [SS:EXIT_TYPE],0
 34035                                  	;mov	byte [SS:EXIT_TYPE],AL ; = 0
 34036 00006261 36C606[7C05]00          	mov	byte [SS:EXIT_TYPE],EXIT_ABORT
 34037                                  
 34038                                  	; abort_inner must have AL set as the exit code! The exit type
 34039                                  	; is retrieved from exit_type. Also, the PDB at user_CS needs
 34040                                  	; to be correct as the one that is terminating.
 34041                                  
 34042                                  abort_inner:
 34043 00006267 368A26[7C05]            	mov	AH,[SS:EXIT_TYPE]
 34044 0000626C 36A3[3403]              	mov	[SS:exit_code],AX
 34045 00006270 E81DA2                  	call	Get_User_Stack
 34046                                  
 34047                                  	;mov	ds,[si+14h]
 34048 00006273 8E5C14                  	mov	DS,[SI+user_env.user_CS] ; set up old interrupts ;PBUGBUG
 34049 00006276 31C0                    	xor	AX,AX
 34050 00006278 8EC0                    	mov	ES,AX
 34051                                  	;mov	si,10
 34052 0000627A BE0A00                  	mov	SI,SAVEXIT
 34053                                  	;mov	di,88h
 34054 0000627D BF8800                  	mov	DI,addr_int_terminate
 34055 00006280 A5                      	movsw
 34056 00006281 A5                      	movsw
 34057 00006282 A5                      	movsw
 34058 00006283 A5                      	movsw
 34059 00006284 A5                      	movsw
 34060 00006285 A5                      	movsw
 34061 00006286 E93DF2                  	jmp	reset_environment
 34062                                  
 34063                                  ;----------------------------------------------------------------------------
 34064                                  ;
 34065                                  ; fixexepatch will point to this is DOS loads low. 
 34066                                  ;
 34067                                  ;----------------------------------------------------------------------------
 34068                                  ; MSDOS 6.0
 34069                                  
 34070                                  ; 29/04/2019 - Retro DOS v4.0
 34071                                  ; DOSCODE:A221h (MSDOS 6.21, MSDOS.SYS)
 34072                                  
 34073                                  ; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS5.0 MSDOS.SYS)
 34074                                  ; DOSCODE:A1C1h (MSDOS 5.0, MSDOS.SYS)
 34075                                  
 34076                                  RetExePatch: ; proc near
 34077                                  	
 34078 00006289 C3                      	retn
 34079                                  
 34080                                  ;============================================================================
 34081                                  ; ALLOC.ASM, MSDOS 6.0, 1991
 34082                                  ;============================================================================
 34083                                  ; 04/08/2018 - Retro DOS v3.0
 34084                                  ; 14/05/2019 - Retro DOS v4.0
 34085                                  
 34086                                  ;	TITLE ALLOC.ASM - memory arena manager	NAME Alloc
 34087                                  
 34088                                  ;**
 34089                                  ;	Microsoft Confidential
 34090                                  ;	Copyright (C) Microsoft Corporation 1991
 34091                                  ;	All Rights Reserved.
 34092                                  ;
 34093                                  ;	Memory related system calls and low level routines for MSDOS 2.X.
 34094                                  ;	I/O specs are defined in DISPATCH.
 34095                                  ;
 34096                                  ;	$ALLOC
 34097                                  ;	$SETBLOCK
 34098                                  ;	$DEALLOC
 34099                                  ;	$AllocOper
 34100                                  ;	arena_free_process
 34101                                  ;	arena_next
 34102                                  ;	check_signature
 34103                                  ;	Coalesce
 34104                                  ;
 34105                                  ;	Modification history:
 34106                                  ;
 34107                                  ;	    Created: ARR 30 March 1983
 34108                                  ;
 34109                                  ;	    Revision: M000 - added support for allocing UMBs. 7/9/90
 34110                                  ;		      M003 - added support for link/unlink UMBs from
 34111                                  ;			     DOS arena chain. 7/18/90
 34112                                  ;		      M009 - Added error returns invalid function and 
 34113                                  ;			     arena trashed in set link state call.
 34114                                  ;		      M010 - Release UMB arenas allocated to current PDB
 34115                                  ;			     if UMB_HEAD is initialized.
 34116                                  ;
 34117                                  ;		      M016 - MACE utilities mkeyrate.com version 1.0 
 34118                                  ;			     support. Please see under M009 in 
 34119                                  ;			     ..\inc\dossym.inc. 8/31/90.
 34120                                  ;
 34121                                  ;		      M061 - In GetLastArena, if linking in UMBs check to make
 34122                                  ;			     sure that umb_head arena is valid and also make
 34123                                  ;			     sure that the previous arena is pointing to 
 34124                                  ;			     umb_head.
 34125                                  ;
 34126                                  ;		      M064 - allow HIGH_ONLY bit to be set by a call to 
 34127                                  ;			     set allloc strategy.
 34128                                  ;			     use STRAT_MASK to mask out bits 6 & 7 of 
 34129                                  ;			     bx in AllocSetStrat.
 34130                                  ;
 34131                                  ;		      M068 - use a count value (A20OFF_COUNT) rather than
 34132                                  ;			     a bit to indicate to dos dispatcher to turn
 34133                                  ;			     a20 off before iret. See M016.
 34134                                  ;
 34135                                  
 34136                                  ;	BREAK	<memory allocation utility routines>
 34137                                  
 34138                                  
 34139                                  ; 15/04/2018 - Retro DOS v2.0
 34140                                  ;----------------------------------------------------------------------------
 34141                                  ; xenix memory calls for MSDOS
 34142                                  ;
 34143                                  ; CAUTION: The following routines rely on the fact that arena_signature and
 34144                                  ; arena_owner_system are all equal to zero and are contained in DI.
 34145                                  ;
 34146                                  ;INCLUDE DOSSEG.ASM
 34147                                  
 34148                                  ;CODE	SEGMENT BYTE PUBLIC  'CODE'
 34149                                  ;       ASSUME  SS:DOSGROUP,CS:DOSGROUP
 34150                                  
 34151                                  ;.xlist
 34152                                  ;.xcref
 34153                                  ;INCLUDE DOSSYM.ASM
 34154                                  ;INCLUDE DEVSYM.ASM
 34155                                  ;.cref
 34156                                  ;.list
 34157                                  
 34158                                  ;TITLE ALLOC.ASM - memory arena manager
 34159                                  ;NAME Alloc
 34160                                  
 34161                                  ;SUBTTL memory allocation utility routines
 34162                                  ;PAGE
 34163                                  ;
 34164                                  ; arena data
 34165                                  ;
 34166                                  ;       i_need  arena_head,WORD         ; seg address of start of arena
 34167                                  ;       i_need  CurrentPDB,WORD         ; current process data block addr
 34168                                  ;       i_need  FirstArena,WORD         ; first free block found
 34169                                  ;       i_need  BestArena,WORD          ; best free block found
 34170                                  ;       i_need  LastArena,WORD          ; last free block found
 34171                                  ;       i_need  AllocMethod,BYTE        ; how to alloc first(best)last
 34172                                  
 34173                                  ;**	Arena_Free_Process
 34174                                  ;----------------------------------------------------------------------------
 34175                                  ;	Free all arena blocks allocated to a prOcess
 34176                                  ;
 34177                                  ;	ENTRY	(bx) = PID of process
 34178                                  ;	EXIT	none
 34179                                  ;	USES	????? BUGBUG
 34180                                  ;----------------------------------------------------------------------------
 34181                                  
 34182                                  	; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS5.0 MSDOS.SYS)
 34183                                  	; DOSCODE:A1C2h (MSDOS 5.0, MSDOS.SYS)
 34184                                  
 34185                                  arena_free_process:
 34186                                  	; 14/05/2019 - Retro DOS v4.0
 34187                                  	; 04/08/2018 - Retro DOS v3.0
 34188 0000628A 36A1[2400]                      MOV	AX,[SS:arena_head]
 34189                                  arena_free_process_start:
 34190 0000628E BF0000                  	MOV     DI,ARENA.SIGNATURE ; 0
 34191                                  	;MOV	AX,[SS:arena_head] ; 15/04/2018  
 34192 00006291 E83000                          CALL	check_signature         ; ES <- AX, check for valid block
 34193                                  
 34194                                  arena_free_process_loop:
 34195                                          ;retc
 34196 00006294 723D                            JC	SHORT AFP_RETN	; Retro DOS v2.0 - 05/03/2018
 34197 00006296 06                      	PUSH    ES
 34198 00006297 1F                              POP     DS
 34199                                  	;cmp	[1],bx 
 34200 00006298 391E0100                        CMP     [ARENA.OWNER],BX	; is block owned by pid?
 34201 0000629C 7504                            JNZ     SHORT arena_free_next	; no, skip to next
 34202                                  	;mov	[1],di
 34203 0000629E 893E0100                        MOV     [ARENA.OWNER],DI	; yes... free him
 34204                                  
 34205                                  arena_free_next:
 34206                                  	;cmp	byte [di],5Ah ;'Z'
 34207 000062A2 803D5A                          CMP     BYTE [DI],arena_signature_end
 34208                                                                          ; end of road, Jack?
 34209                                          ;retz				; never come back no more
 34210                                  	;JZ	SHORT AFP_RETN  ; MSDOS 3.3 (& MSDOS 2.11)
 34211                                  	; 14/05/2019
 34212                                  	; MSDOS 6.0
 34213 000062A5 7405                    	jz	short arena_chk_umbs
 34214                                          
 34215 000062A7 E81300                  	CALL    arena_next              ; next item in ES/AX carry set if trash
 34216 000062AA EBE8                            JMP     SHORT arena_free_process_loop
 34217                                  
 34218                                  	; MSDOS 6.0
 34219                                  arena_chk_umbs:				; M010 - Start
 34220                                  	; 20/05/2019
 34221 000062AC 36A1[8C00]              	mov	ax,[ss:UMB_HEAD]	; ax = umb_head
 34222 000062B0 83F8FF                  	cmp	ax,0FFFFh		; Q: is umb_head initialized
 34223 000062B3 741E                    	je	short ret_label		; N: we're done
 34224                                  	
 34225 000062B5 8CDF                    	mov	di,ds			; di = last arena
 34226 000062B7 39C7                    	cmp	di,ax			; Q: is last arena above umb_head
 34227 000062B9 7318                    	jae	short ret_label		; Y: we've scanned umbs also. done.
 34228 000062BB EBD1                    	jmp	short arena_free_process_start
 34229                                  					; M010 - End
 34230                                  ;AFP_RETN:
 34231                                  ;	RETN
 34232                                  
 34233                                  ;	BREAK	<Arena Helper Routines>
 34234                                  
 34235                                  ;**	Arena_Next - Find Next item in Arena
 34236                                  ;----------------------------------------------------------------------------
 34237                                  ;	ENTRY	DS - pointer to block head
 34238                                  ;		(di) = 0
 34239                                  ;	EXIT	AX,ES - pointers to next head
 34240                                  ;		'C' set iff arena damaged
 34241                                  ;----------------------------------------------------------------------------
 34242                                  
 34243                                  arena_next:
 34244 000062BD 8CD8                            MOV     AX,DS                   ; AX <- current block
 34245 000062BF 03060300                        ADD     AX,[ARENA.SIZE]		; AX <- AX + current block length
 34246 000062C3 40                              INC     AX                      ; remember that header!
 34247                                  
 34248                                  ;       fall into check_signature and return
 34249                                  ;
 34250                                  ;       CALL    check_signature         ; ES <- AX, carry set if error
 34251                                  ;       RETN
 34252                                  
 34253                                  ;**	Check_Signature - Check Memory Block Signature
 34254                                  ;----------------------------------------------------------------------------
 34255                                  ;	ENTRY	(AX) = address of block header
 34256                                  ;		(di) = 0
 34257                                  ;	EXIT	 ES = AX
 34258                                  ;		'C' clear if signature good
 34259                                  ;		'C' set if signature bad
 34260                                  ;	USES	ES, Flags
 34261                                  ;----------------------------------------------------------------------------
 34262                                  
 34263                                  check_signature:        
 34264                                  
 34265 000062C4 8EC0                    	MOV     ES,AX                   ; ES <- AX
 34266                                  	;cmp	byte [es:di],4Dh ; 'M'
 34267 000062C6 26803D4D                        CMP     BYTE [ES:DI],arena_signature_normal
 34268                                                                          ; IF next signature = not_end THEN
 34269 000062CA 7407                            JZ      SHORT check_signature_ok ;   GOTO ok
 34270                                  	;cmp 	byte [es:di],5Ah ; 'Z'
 34271 000062CC 26803D5A                        CMP     BYTE [ES:DI],arena_signature_end
 34272                                                                          ; IF next signature = end then
 34273 000062D0 7401                            JZ      SHORT check_signature_ok ;   GOTO ok
 34274 000062D2 F9                              STC                             ; set error
 34275                                  ret_label: ; MSDOS 6.0
 34276                                  AFP_RETN:
 34277                                   	; Retro DOS v2.0 - 05/03/2018
 34278                                  check_signature_ok:
 34279                                  COALESCE_RETN:
 34280 000062D3 C3                      	RETN
 34281                                  
 34282                                  ;**	Coalesce - Combine free blocks ahead with current block
 34283                                  ;----------------------------------------------------------------------------
 34284                                  ;	Coalesce adds the block following the argument to the argument block,
 34285                                  ;	iff it's free.  Coalesce is usually used to join free blocks, but
 34286                                  ;	some callers (such as $setblock) use it to join a free block to it's
 34287                                  ;	preceeding allocated block.
 34288                                  ;
 34289                                  ;	ENTRY	(ds) = pointer to the head of a free block
 34290                                  ;		(di) = 0
 34291                                  ;	EXIT	'C' clear if OK
 34292                                  ;		  (ds) unchanged, this block updated
 34293                                  ;		  (ax) = address of next block, IFF not at end
 34294                                  ;		'C' set if arena trashed
 34295                                  ;	USES	(cx)
 34296                                  ;----------------------------------------------------------------------------
 34297                                          
 34298                                  Coalesce:
 34299                                  	;cmp	byte [di],5Ah ; 'Z'
 34300 000062D4 803D5A                  	CMP     BYTE [DI],arena_signature_end
 34301                                                                          ; IF current signature = END THEN
 34302                                          ;retz				;   GOTO ok
 34303 000062D7 74FA                            jz	short COALESCE_RETN
 34304 000062D9 E8E1FF                  	CALL    arena_next              ; ES, AX <- next block, Carry set if error
 34305                                          ;retc				; IF no error THEN GOTO check
 34306 000062DC 72F5                    	jc	short COALESCE_RETN
 34307                                  
 34308                                  coalesce_check:
 34309                                  	;cmp	[es:1],di
 34310 000062DE 26393E0100                      CMP     [ES:ARENA.OWNER],DI
 34311                                          ;retnz				; IF next block isnt free THEN return
 34312 000062E3 75EE                            JNZ	SHORT COALESCE_RETN
 34313                                  	;mov	cx,[ES:3]
 34314 000062E5 268B0E0300              	MOV     CX,[ES:ARENA.SIZE]	; CX <- next block size
 34315 000062EA 41                              INC     CX                      ; CX <- CX + 1 (for header size)
 34316                                          ;ADD	[3],CX
 34317 000062EB 010E0300                	ADD     [ARENA.SIZE],CX		; current size <- current size + CX
 34318 000062EF 268A0D                          MOV     CL,[ES:DI]              ; move up signature
 34319 000062F2 880D                            MOV     [DI],CL
 34320 000062F4 EBDE                            JMP     SHORT Coalesce		; try again
 34321                                  
 34322                                  ; 04/08/2018 - Retro DOS v3.0
 34323                                  ; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 641Fh
 34324                                  
 34325                                  ;	BREAK  <$Alloc - allocate space in memory>
 34326                                  
 34327                                  ; MSDOS 6.0
 34328                                  ;----------------------------------------------------------------------------
 34329                                  ;**	$Alloc - Allocate Memory Space
 34330                                  ;
 34331                                  ;	$Alloc services the INT21 that allocates memory space to a program.
 34332                                  ;	Alloc returns a pointer to a free block of memory that
 34333                                  ;	has the requested size in paragraphs.
 34334                                  ;
 34335                                  ;	If the allocation strategy is HIGH_FIRST or HIGH_ONLY memory is 
 34336                                  ;	scanned from umb_head if not from arena_head. If the strategy is
 34337                                  ; 	HIGH_FIRST the scan is continued from arena_head if a block of 
 34338                                  ;	appropriate size is not found in the UMBs. If the strategy is 
 34339                                  ;	HIGH_FIRST+HIGH_ONLY only the UMBs are scanned for memory.
 34340                                  ;
 34341                                  ;	In either case if bit 0 of UmbFlag is not initialized then the scan
 34342                                  ;	starts from arena_head.
 34343                                  ;
 34344                                  ;	Assembler usage:
 34345                                  ;           MOV     BX,size
 34346                                  ;           MOV     AH,Alloc
 34347                                  ;           INT     21h
 34348                                  ;
 34349                                  ;	BUGBUG - a lot can be done to improve performance. We can set marks
 34350                                  ;	so that we start searching the arena at it's first non-trivial free
 34351                                  ;	block, we can peephole the code, etc. (We can move some subr calls
 34352                                  ;	inline, etc.) I assume that this is called rarely and that the arena
 34353                                  ;	doesn't have too many memory objects in it beyond the first free one.
 34354                                  ;	verify that this is true; if so, this can stay as is
 34355                                  ;
 34356                                  ;	ENTRY	(bx) = requested size, in bytes
 34357                                  ;		(DS) = (ES) = DOSGROUP
 34358                                  ;	EXIT	'C' clear if memory allocated
 34359                                  ;		  (ax:0) = address of requested memory
 34360                                  ;		'C' set if request failed
 34361                                  ;		  (AX) = error_not_enough_memory
 34362                                  ;		    (bx) = max size we could have allocated
 34363                                  ;		  (ax) = error_arena_trashed
 34364                                  ;	USES	All
 34365                                  ;----------------------------------------------------------------------------
 34366                                  
 34367                                  ; MSDOS 2.11 (& MSDOS 3.3)
 34368                                  ;----------------------------------------------------------------------------
 34369                                  ;SUBTTL $Alloc - allocate space in memory
 34370                                  ;
 34371                                  ;   Assembler usage:
 34372                                  ;           MOV     BX,size
 34373                                  ;           MOV     AH,Alloc
 34374                                  ;           INT     21h
 34375                                  ;         AX:0 is pointer to allocated memory
 34376                                  ;         BX is max size if not enough memory
 34377                                  ;
 34378                                  ;   Description:
 34379                                  ;           Alloc returns  a  pointer  to  a  free  block of
 34380                                  ;       memory that has the requested  size  in  paragraphs.
 34381                                  ;
 34382                                  ;   Error return:
 34383                                  ;           AX = error_not_enough_memory
 34384                                  ;              = error_arena_trashed
 34385                                  ;----------------------------------------------------------------------------
 34386                                  
 34387                                  ; DOSCODE:A28Eh (MSDOS 6.21, MSDOS.SYS)
 34388                                  
 34389                                  ; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS5.0 MSDOS.SYS)
 34390                                  ; DOSCODE:A22Eh (MSDOS 5.0, MSDOS.SYS)
 34391                                  
 34392                                  _$ALLOC:
 34393                                  	; 25/05/2019 (Procedure has been checked and confirmed)
 34394                                  	; 14/05/2019 - Retro DOS v4.0
 34395                                  	; 04/08/2018 - Retro DOS v3.0
 34396                                  	;EnterCrit critMem
 34397 000062F6 E85EB0                  	call	ECritMEM ; MSDOS 3.3 & MSDOS 6.0
 34398                                  
 34399                                  ; 17/12/2022
 34400                                  ; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 34401                                  ;%if 0
 34402                                  	; 14/05/2019
 34403 000062F9 16                      	push	ss
 34404 000062FA 1F                      	pop	ds
 34405                                  
 34406                                  	; MSDOS 6.0
 34407                                  	;mov	ax,[ss:arena_head]
 34408                                  	;mov	[ss:START_ARENA],ax	; assume LOW_FIRST
 34409                                  
 34410 000062FB A1[2400]                	mov	ax,[arena_head]
 34411 000062FE A3[8E00]                	mov	[START_ARENA],ax			
 34412                                  	
 34413                                  	;test	byte [ss:AllocMethod],HIGH_FIRST+HIGH_ONLY
 34414 00006301 F606[0203]C0            	test	byte [AllocMethod],HIGH_FIRST+HIGH_ONLY
 34415                                  					; Q: should we start scanning from 
 34416                                  					;    UMB's
 34417 00006306 740D                    	jz	short norm_alloc	; N: scan from arena_head
 34418                                  		
 34419                                  	;;cmp	word [ss:UMB_HEAD],-1	; Q: Has umb_head been initialized
 34420                                  	;cmp	word [UMB_HEAD],-1
 34421                                  	;je	short norm_alloc	; N: scan from arena_head
 34422                                  
 34423                                  	;test	byte [ss:UMBFLAG],LINKSTATE ; Q: are umb's linked
 34424 00006308 F606[8900]01            	test	byte [UMBFLAG],LINKSTATE ; 1
 34425 0000630D 7406                    	jz	short norm_alloc	; N: scan from arena_head
 34426                                  	
 34427                                  	;mov	ax,[ss:UMB_HEAD]
 34428                                  	;mov	[ss:START_ARENA],ax	; start_arena = umb_head
 34429 0000630F A1[8C00]                	mov	ax,[UMB_HEAD]
 34430 00006312 A3[8E00]                	mov	[START_ARENA],ax
 34431                                  					; M000 - end
 34432                                  norm_alloc:
 34433 00006315 31C0                            XOR     AX,AX
 34434 00006317 89C7                            MOV     DI,AX
 34435                                  	; 15/03/2018
 34436                                          ;MOV	[SS:FirstArena],AX	; init the options
 34437                                          ;MOV	[SS:BestArena],AX
 34438                                          ;MOV	[SS:LastArena],AX
 34439                                  	; 14/05/2019
 34440 00006319 A3[4003]                	MOV	[FirstArena],AX		; init the options
 34441 0000631C A3[4203]                        MOV	[BestArena],AX
 34442 0000631F A3[4403]                        MOV	[LastArena],AX
 34443 00006322 50                              PUSH    AX                      ; alloc_max <- 0
 34444                                  	; 04/08/2018
 34445                                  start_scan:
 34446                                  	;MOV	AX,[SS:arena_head]	; AX <- beginning of arena
 34447                                  	;MOV	AX,[arena_head]
 34448                                  
 34449                                  	; 14/05/2019	
 34450                                  	; MSDOS 6.0
 34451                                  	;mov	ax,[SS:START_ARENA]	; M000: AX <- beginning of arena
 34452 00006323 A1[8E00]                	mov	ax,[START_ARENA]
 34453                                  
 34454                                  	; 27/09/2023 (BugFix) (*) 
 34455                                  	; ( jump from 'alloc_chk' (ds<>ss, ax = [SS:START_ARENA]))
 34456                                  start_scan_x:
 34457                                  
 34458 00006326 E89BFF                  	CALL    check_signature         ; ES <- AX, carry set if error
 34459 00006329 7236                            JC      SHORT alloc_err		; IF error THEN GOTO err
 34460                                  
 34461                                  ;%endif
 34462                                  
 34463                                  ; 17/12/2022
 34464                                  %if 0
 34465                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 34466                                  
 34467                                  	; MSDOS 6.0
 34468                                  	mov	ax,[ss:arena_head]
 34469                                  	mov	[ss:START_ARENA],ax	; assume LOW_FIRST
 34470                                  
 34471                                  	test	byte [ss:AllocMethod],HIGH_FIRST+HIGH_ONLY
 34472                                  					; Q: should we start scanning from 
 34473                                  					;    UMB's
 34474                                  	jz	short norm_alloc	; N: scan from arena_head
 34475                                  		
 34476                                  	;cmp	word [ss:UMB_HEAD],-1	; Q: Has umb_head been initialized
 34477                                  	;je	short norm_alloc	; N: scan from arena_head
 34478                                  
 34479                                  	test	byte [ss:UMBFLAG],LINKSTATE ; Q: are umb's linked
 34480                                  	jz	short norm_alloc	; N: scan from arena_head
 34481                                  	
 34482                                  	mov	ax,[ss:UMB_HEAD]
 34483                                  	mov	[ss:START_ARENA],ax	; start_arena = umb_head
 34484                                  					; M000 - end
 34485                                  norm_alloc:
 34486                                          XOR     AX,AX
 34487                                          MOV     DI,AX
 34488                                  	; 15/03/2018
 34489                                  	MOV	[SS:FirstArena],AX	; init the options
 34490                                  	MOV	[SS:BestArena],AX
 34491                                  	MOV	[SS:LastArena],AX
 34492                                          PUSH    AX                      ; alloc_max <- 0
 34493                                  	; 04/08/2018
 34494                                  start_scan:
 34495                                  	;MOV	AX,[SS:arena_head]	; AX <- beginning of arena
 34496                                  	; 14/05/2019	
 34497                                  	; MSDOS 6.0
 34498                                  	mov	ax,[SS:START_ARENA]	; M000: AX <- beginning of arena
 34499                                  	CALL    check_signature         ; ES <- AX, carry set if error
 34500                                          JC      SHORT alloc_err		; IF error THEN GOTO err
 34501                                  %endif
 34502                                  
 34503                                  alloc_scan:
 34504 0000632B 06                              PUSH    ES
 34505 0000632C 1F                              POP     DS                      ; DS <- ES
 34506 0000632D 393E0100                        CMP     [ARENA.OWNER],DI ; 0
 34507 00006331 7469                            JZ      SHORT alloc_free	; IF current block is free THEN examine
 34508                                  
 34509                                  alloc_next:
 34510                                  	; MSDOS 6.0			; M000 - start 
 34511 00006333 36F606[8900]01          	test	byte [ss:UMBFLAG],LINKSTATE ; Q: are umb's linked
 34512 00006339 741C                    	jz	short norm_strat	; N: see if we reached last arena
 34513                                  	
 34514 0000633B 36F606[0203]80          	test	byte [ss:AllocMethod],HIGH_FIRST
 34515                                  					; Q: is alloc strategy high_first
 34516 00006341 7414                    	jz	short norm_strat	; N: see if we reached last arena
 34517 00006343 36A1[8E00]              	mov	ax,[ss:START_ARENA]
 34518 00006347 363B06[2400]            	cmp	ax,[ss:arena_head]	; Q: did we start scan from 
 34519                                  					;    arena_head
 34520 0000634C 7509                    	jne	short norm_strat	; N: see if we reached last arena
 34521 0000634E 8CD8                    	mov	ax,ds			; ax = current block
 34522 00006350 363B06[8C00]            	cmp	ax,[ss:UMB_HEAD]	; Q: check against umb_head 
 34523 00006355 EB03                    	jmp	short alloc_chk_end
 34524                                  
 34525                                  norm_strat:
 34526                                  	;cmp	byte [di],5Ah ; 'Z'
 34527 00006357 803D5A                          CMP     BYTE [DI],arena_signature_end
 34528                                                                          ; IF current block is last THEN
 34529                                  alloc_chk_end:
 34530 0000635A 740E                            JZ      SHORT alloc_end		;   GOTO end
 34531 0000635C E85EFF                          CALL    arena_next              ; AX, ES <- next block, Carry set if error
 34532 0000635F 73CA                            JNC     SHORT alloc_scan	; IF no error THEN GOTO scan
 34533                                  
 34534                                  alloc_err:
 34535 00006361 58                              POP     AX
 34536                                  
 34537                                  alloc_trashed:
 34538                                  	;LeaveCrit critMem
 34539 00006362 E80DB0                  	call    LCritMEM ; MSDOS 3.3 & MSDOS 6.0	
 34540                                          ;error	error_arena_trashed
 34541                                  	;mov	al,7
 34542 00006365 B007                    	MOV	AL,error_arena_trashed
 34543                                  alloc_errj:
 34544 00006367 E9E9A2                  	JMP	SYS_RET_ERR
 34545                                  
 34546                                  alloc_end:
 34547                                  	; 18/05/2019
 34548 0000636A 36833E[4003]00                  CMP	WORD [SS:FirstArena],0
 34549 00006370 7403                    	jz	short alloc_chk 
 34550 00006372 E98400                  	jmp	alloc_do_split
 34551                                  
 34552                                  alloc_chk:
 34553                                  	; MSDOS 6.0
 34554 00006375 36A1[2400]              	mov	ax,[ss:arena_head]
 34555 00006379 363B06[8E00]            	cmp	ax,[ss:START_ARENA]	; Q: started scanning from arena_head
 34556 0000637E 740E                    	je	short alloc_fail	; Y: not enough memory
 34557                                  					; N:
 34558                                  					; Q: is the alloc strat HIGH_ONLY
 34559 00006380 36F606[0203]40          	test 	byte [ss:AllocMethod],HIGH_ONLY
 34560 00006386 7506                    	jnz	short alloc_fail	; Y: return size of largest UMB
 34561                                  	
 34562 00006388 36A3[8E00]              	mov	[ss:START_ARENA],ax	; N: start scanning from arena_head
 34563                                  	; 27/09/2023 (*)
 34564 0000638C EB98                    	jmp	short start_scan_x ; (*) ; (BugFix)
 34565                                  	;jmp	short start_scan
 34566                                  					; M000 - end
 34567                                  
 34568                                  alloc_fail:
 34569                                          ;invoke Get_User_Stack
 34570 0000638E E8FFA0                          CALL	Get_User_Stack
 34571 00006391 5B                      	POP     BX
 34572                                          ;MOV	[SI].user_BX,BX
 34573                                  	;MOV	[SI+2],BX
 34574 00006392 895C02                  	mov	[SI+user_env.user_BX],bx
 34575                                  	;LeaveCrit critMem
 34576 00006395 E8DAAF                  	call    LCritMEM ; MSDOS 3.3 & MSDOS 6.0
 34577                                  	;error	error_not_enough_memory
 34578                                  	;mov	al,8
 34579 00006398 B008                    	MOV	AL,error_not_enough_memory
 34580                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 34581 0000639A EBCB                    	jmp	short alloc_errj
 34582                                  	;JMP	SYS_RET_ERR
 34583                                  
 34584                                  alloc_free:
 34585 0000639C E835FF                          CALL    Coalesce		; add following free block to current
 34586 0000639F 72C0                            JC	SHORT alloc_err		; IF error THEN GOTO err
 34587 000063A1 8B0E0300                        MOV     CX,[ARENA.SIZE]
 34588 000063A5 5A                              POP     DX                      ; check for max found size
 34589 000063A6 39D1                            CMP     CX,DX
 34590 000063A8 7602                            JNA     SHORT alloc_test
 34591 000063AA 89CA                            MOV     DX,CX
 34592                                  
 34593                                  alloc_test:
 34594 000063AC 52                              PUSH    DX
 34595 000063AD 39CB                            CMP     BX,CX                   ; IF BX > size of current block THEN
 34596 000063AF 7782                    	JA      SHORT alloc_next	;   GOTO next
 34597                                  
 34598                                  	; 15/03/2018
 34599 000063B1 36833E[4003]00                  CMP     WORD [SS:FirstArena],0
 34600 000063B7 7505                    	JNZ	SHORT alloc_best
 34601 000063B9 368C1E[4003]                    MOV     [SS:FirstArena],DS	; save first one found	
 34602                                  alloc_best:
 34603 000063BE 36833E[4203]00                  CMP     WORD [SS:BestArena],0
 34604 000063C4 740E                            JZ      SHORT alloc_make_best	; initial best
 34605 000063C6 06                              PUSH	ES
 34606 000063C7 368E06[4203]                    MOV     ES,[SS:BestArena]
 34607 000063CC 26390E0300                      CMP     [ES:ARENA.SIZE],CX	; is size of best larger than found?
 34608 000063D1 07                              POP	ES
 34609 000063D2 7605                            JBE     SHORT alloc_last
 34610                                  alloc_make_best:
 34611 000063D4 368C1E[4203]                    MOV     [SS:BestArena],DS	; assign best
 34612                                  alloc_last:
 34613 000063D9 368C1E[4403]                    MOV     [SS:LastArena],DS 	; assign last
 34614 000063DE E952FF                          JMP     alloc_next
 34615                                  ;
 34616                                  ; split the block high
 34617                                  ;
 34618                                  alloc_do_split_high:
 34619 000063E1 368E1E[4403]                    MOV     DS,[SS:LastArena]
 34620 000063E6 8B0E0300                        MOV     CX,[ARENA.SIZE]
 34621 000063EA 29D9                            SUB     CX,BX
 34622 000063EC 8CDA                            MOV     DX,DS
 34623 000063EE 7449                            JE      SHORT alloc_set_owner	; sizes are equal, no split
 34624 000063F0 01CA                            ADD     DX,CX                   ; point to next block
 34625 000063F2 8EC2                            MOV     ES,DX                   ; no decrement!
 34626 000063F4 49                              DEC     CX
 34627 000063F5 87D9                            XCHG    BX,CX                   ; bx has size of lower block
 34628 000063F7 EB2B                            JMP     SHORT alloc_set_sizes	; cx has upper (requested) size
 34629                                  ;
 34630                                  ; we have scanned memory and have found all appropriate blocks
 34631                                  ; check for the type of allocation desired; first and best are identical
 34632                                  ; last must be split high
 34633                                  ;
 34634                                  alloc_do_split:
 34635                                  
 34636                                  ; 17/12/2022
 34637                                  ; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 34638                                  ;%if 0
 34639                                  	; 14/05/2019
 34640                                  	; MSDOS 6.0			; M000 - start
 34641                                  	;xor	cx,cx
 34642 000063F9 368A0E[0203]            	mov	cl,[ss:AllocMethod]
 34643                                  	;and	cx,STRAT_MASK ; 0FF3Fh	; mask off bit 7
 34644 000063FE 80E13F                  	and	cl,3Fh
 34645                                  	;cmp	cx,BEST_FIT ; 1		; Q; is the alloc strategy best_fit
 34646 00006401 80F901                  	cmp	cl,BEST_FIT
 34647 00006404 77DB                    	ja	short alloc_do_split_high
 34648                                  ;%endif
 34649                                  
 34650                                  	; 17/12/2022
 34651                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 34652                                  	; MSDOS 6.0 & MSDOS 5.0
 34653                                  	;xor	cx,cx
 34654                                  	;mov	cl,[ss:AllocMethod]
 34655                                  	;and	cx,STRAT_MASK ; 0FF3Fh	; mask off bit 7
 34656                                  	;cmp	cx,BEST_FIT ; 1		; Q; is the alloc strategy best_fit
 34657                                  	;ja	short alloc_do_split_high
 34658                                  
 34659                                  	; 15/03/2018
 34660                                          ;;CMP	BYTE [SS:AllocMethod], 1
 34661                                  	; 04/08/2018
 34662                                  	;CMP	BYTE [SS:AllocMethod],BEST_FIT
 34663                                          ;JA	SHORT alloc_do_split_high
 34664                                          
 34665 00006406 368E1E[4003]            	MOV     DS,[SS:FirstArena]        
 34666 0000640B 7205                    	JB      SHORT alloc_get_size
 34667 0000640D 368E1E[4203]            	MOV     DS,[SS:BestArena]
 34668                                  
 34669                                  alloc_get_size:
 34670 00006412 8B0E0300                        MOV     CX,[ARENA.SIZE]
 34671 00006416 29D9                            SUB     CX,BX                   ; get room left over
 34672 00006418 8CD8                            MOV     AX,DS
 34673 0000641A 89C2                            MOV     DX,AX                   ; save for owner setting
 34674 0000641C 741B                            JE      SHORT alloc_set_owner	; IF BX = size THEN (don't split)
 34675 0000641E 01D8                            ADD     AX,BX
 34676 00006420 40                              INC     AX                      ; remember the header
 34677 00006421 8EC0                            MOV     ES,AX                   ; ES <- DS + BX (new header location)
 34678 00006423 49                              DEC     CX                      ; CX <- size of split block
 34679                                  alloc_set_sizes:
 34680 00006424 891E0300                        MOV     [ARENA.SIZE],BX		; current size <- BX
 34681 00006428 26890E0300                      MOV     [ES:ARENA.SIZE],CX      ; split size <- CX
 34682                                  	;mov	bl,4Dh ; 'M'
 34683 0000642D B34D                            MOV     BL,arena_signature_normal
 34684 0000642F 861D                            XCHG    BL,[DI]			; current signature <- 4D
 34685 00006431 26881D                          MOV     [ES:DI],BL		; new block sig <- old block sig
 34686 00006434 26893E0100                      MOV     [ES:ARENA.OWNER],DI
 34687                                  
 34688                                  alloc_set_owner:
 34689 00006439 8EDA                            MOV     DS,DX
 34690 0000643B 36A1[3003]                      MOV     AX,[SS:CurrentPDB] ; 15/03/2018
 34691 0000643F A30100                          MOV     [ARENA.OWNER],AX
 34692 00006442 8CD8                            MOV     AX,DS
 34693 00006444 40                              INC     AX
 34694 00006445 5B                              POP     BX
 34695                                  	;LeaveCrit critMem
 34696 00006446 E829AF                  	call    LCritMEM ; MSDOS 3.3 & MSDOS 6.0
 34697                                  	
 34698                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 34699                                  alloc_ok:
 34700                                          ;transfer SYS_RET_OK
 34701 00006449 E9FEA1                  	JMP	SYS_RET_OK
 34702                                  
 34703                                  ;	BREAK $SETBLOCK - change size of an allocated block (if possible)
 34704                                  
 34705                                  ; MSDOS 6.0
 34706                                  ;----------------------------------------------------------------------------
 34707                                  ;**	$SETBLOCK - Change size of an Alocated Block
 34708                                  ;
 34709                                  ;	Setblock changes the size of an allocated block. First, we coalesce
 34710                                  ;	any following free space onto this block; then we try to trim the
 34711                                  ;	block down to the size requested.
 34712                                  ;
 34713                                  ;	Note that if the guy wants to grow the block but that growth fails,
 34714                                  ;	we still go ahead and coalesce any trailing free blocks onto it.
 34715                                  ;	Thus the maximum-size-possible value that we return has already
 34716                                  ;	been allocated! This is a bug, dare we fix it? BUGBUG
 34717                                  ;
 34718                                  ;	NOTE - $SETBLOCK is in bed with $ALLOC and jumps into $ALLOC to
 34719                                  ;		finish it's work.  FOr this reason we build the allocsf
 34720                                  ;		structure on the frame, to make us compatible with $ALLOCs
 34721                                  ;		code.
 34722                                  ;
 34723                                  ;	ENTRY	(es) = segment of old block
 34724                                  ;		(bx) = newsize
 34725                                  ;		(ah) = SETBLOCK
 34726                                  ;
 34727                                  ;	EXIT	'C' clear if OK
 34728                                  ;		'C' set if error
 34729                                  ;		  (ax) = error_invalid_block
 34730                                  ;		       = error_arena_trashed
 34731                                  ;		       = error_not_enough_memory
 34732                                  ;		       = error_invalid_function
 34733                                  ;		  (bx) = maximum size possible, iff (ax) = error_not_enough_memory
 34734                                  ;	USES	???? BUGBUG
 34735                                  ;----------------------------------------------------------------------------
 34736                                  
 34737                                  ; MSDOS 2.11 (& MSDOS 3.3)
 34738                                  ;----------------------------------------------------------------------------
 34739                                  ;SUBTTL $SETBLOCK - change size of an allocated block (if possible)
 34740                                  ;
 34741                                  ;   Assembler usage:
 34742                                  ;           MOV     ES,block
 34743                                  ;           MOV     BX,newsize
 34744                                  ;           MOV     AH,setblock
 34745                                  ;           INT     21h
 34746                                  ;         if setblock fails for growing, BX will have the maximum
 34747                                  ;         size possible
 34748                                  ;   Error return:
 34749                                  ;           AX = error_invalid_block
 34750                                  ;              = error_arena_trashed
 34751                                  ;              = error_not_enough_memory
 34752                                  ;              = error_invalid_function
 34753                                  ;----------------------------------------------------------------------------
 34754                                  
 34755                                  _$SETBLOCK:        
 34756                                  	; 04/08/2018 - Retro DOS v3.0
 34757                                  	;EnterCrit   critMem
 34758 0000644C E808AF                  	call	ECritMEM ; MSDOS 3.3 & MSDOS 6.0
 34759                                  
 34760 0000644F BF0000                  	MOV     DI,ARENA.SIGNATURE
 34761 00006452 8CC0                            MOV     AX,ES
 34762 00006454 48                              DEC     AX
 34763 00006455 E86CFE                          CALL    check_signature
 34764 00006458 7303                            JNC     SHORT setblock_grab
 34765                                  
 34766                                  setblock_bad:
 34767 0000645A E905FF                          JMP     alloc_trashed
 34768                                  
 34769                                  setblock_grab:
 34770 0000645D 8ED8                            MOV     DS,AX
 34771 0000645F E872FE                          CALL    Coalesce
 34772 00006462 72F6                            JC      SHORT setblock_bad
 34773 00006464 8B0E0300                        MOV     CX,[ARENA.SIZE]
 34774 00006468 51                              PUSH    CX
 34775 00006469 39CB                            CMP     BX,CX
 34776 0000646B 76A5                            JBE     SHORT alloc_get_size
 34777 0000646D E91EFF                          JMP     alloc_fail
 34778                                  
 34779                                  ;	BREAK $DEALLOC - free previously allocated piece of memory
 34780                                  
 34781                                  ; MSDOS 6.0
 34782                                  ;----------------------------------------------------------------------------
 34783                                  ;**	$DEALLOC - Free Heap Memory
 34784                                  ;
 34785                                  ;	ENTRY	(es) = address of item
 34786                                  ;
 34787                                  ;	EXIT	'C' clear of OK
 34788                                  ;		'C' set if error
 34789                                  ;		  (AX) = error_invalid_block
 34790                                  ;	USES	???? BUGBUG
 34791                                  
 34792                                  ; MSDOS 2.11 (& MSDOS 3.3)
 34793                                  ;----------------------------------------------------------------------------
 34794                                  ;SUBTTL $DEALLOC - free previously allocated piece of memory
 34795                                  ;
 34796                                  ;   Assembler usage:
 34797                                  ;           MOV     ES,block
 34798                                  ;           MOV     AH,dealloc
 34799                                  ;           INT     21h
 34800                                  ;
 34801                                  ;   Error return:
 34802                                  ;           AX = error_invalid_block
 34803                                  ;              = error_arena_trashed
 34804                                  ;---------------------------------------------------------------------------- 
 34805                                  
 34806                                  	; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 34807                                  _$DEALLOC:
 34808                                  	; 14/05/2019 - Retro DOS v4.0    
 34809                                  	; 04/08/2018 - Retro DOS v3.0
 34810                                  	;EnterCrit   critMem
 34811 00006470 E8E4AE                  	call	ECritMEM ; MSDOS 3.3 & MSDOS 6.0
 34812                                  
 34813                                  	; MSDOS 6.0			; M016, M068 - Start
 34814 00006473 36F606[8600]04          	test	byte [ss:DOS_FLAG],EXECA20OFF
 34815                                  					; Q: was the previous call an int 21
 34816                                  					;    exec call
 34817 00006479 740D                    	jz	short deallocate	; N: continue
 34818 0000647B 36803E[8500]00          	cmp	byte [ss:A20OFF_COUNT], 0 ; Q: is count 0
 34819 00006481 7505                    	jne	short deallocate	; N: continue
 34820                                  	;mov	byte [ss:A20OFF_COUNT], 1 ; Y: set count to 1
 34821                                  	; 25/09/2023
 34822 00006483 36FE06[8500]            	inc	byte [ss:A20OFF_COUNT]
 34823                                  deallocate:				; M016, M068 - End
 34824 00006488 BF0000                  	MOV     DI,ARENA.SIGNATURE ; = 0
 34825 0000648B 8CC0                            MOV     AX,ES
 34826 0000648D 48                              DEC     AX
 34827 0000648E E833FE                          CALL    check_signature
 34828 00006491 720A                            JC      SHORT dealloc_err
 34829 00006493 26893E0100                      MOV     [ES:ARENA.OWNER],DI
 34830                                  	;LeaveCrit critMem
 34831 00006498 E8D7AE                  	call    LCritMEM ; MSDOS 3.3 & MSDOS 6.0
 34832                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 34833                                          ;transfer SYS_RET_OK
 34834                                  dealloc_ok:
 34835 0000649B EBAC                    	jmp	short alloc_ok
 34836                                  	;JMP	SYS_RET_OK
 34837                                  
 34838                                  dealloc_err:
 34839                                  	;LeaveCrit critMem
 34840 0000649D E8D2AE                  	call    LCritMEM ; MSDOS 3.3 & MSDOS 6.0
 34841                                          ;error	error_invalid_block
 34842                                  	;mov	al,9
 34843 000064A0 B009                    	MOV	AL,error_invalid_block
 34844                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 34845                                  dealloc_errj:
 34846                                  AllocOperErrj:	; 17/12/2022
 34847 000064A2 E9AEA1                  	JMP	SYS_RET_ERR
 34848                                  
 34849                                  ;	BREAK $AllocOper - get/set allocation mechanism
 34850                                  
 34851                                  ; MSDOS 6.0
 34852                                  ;----------------------------------------------------------------------------
 34853                                  ;**	$AllocOper - Get/Set Allocation Mechanism
 34854                                  ;
 34855                                  ;	Assembler usage:
 34856                                  ;           MOV     AH,AllocOper
 34857                                  ;           MOV     BX,method
 34858                                  ;           MOV     AL,func
 34859                                  ;           INT     21h
 34860                                  ;
 34861                                  ;	ENTRY	
 34862                                  ;		(al) = 0
 34863                                  ;		  Get allocation Strategy in (ax)
 34864                                  ;
 34865                                  ;		(al) = 1, (bx) = method = zw0000xy
 34866                                  ;		  Set allocation strategy.
 34867                                  ;		   w  = 1  => HIGH_ONLY
 34868                                  ;		   z  = 1  => HIGH_FIRST
 34869                                  ;		   xy = 00 => FIRST_FIT
 34870                                  ;		      = 01 => BEST_FIT
 34871                                  ;		      = 10 => LAST_FIT
 34872                                  ;
 34873                                  ;		(al) = 2
 34874                                  ;		  Get UMB link state in (al)
 34875                                  ;
 34876                                  ;		(al) = 3
 34877                                  ;		  Set UMB link state
 34878                                  ;		   (bx) = 0 => Unlink UMBs
 34879                                  ;		   (bx) = 1 => Link UMBs
 34880                                  ;
 34881                                  ;
 34882                                  ;	EXIT	'C' clear if OK
 34883                                  ;
 34884                                  ;		 if (al) = 0
 34885                                  ;		  (ax) = existing method
 34886                                  ;		 if (al) = 1
 34887                                  ;		  Sets allocation strategy
 34888                                  ;		 if (al) = 2
 34889                                  ;		  (al) = 0 => UMBs not linked
 34890                                  ;		  (al) = 1 => UMBs linked in
 34891                                  ;		 if (al) = 3
 34892                                  ;		  Links/Unlinks the UMBs into DOS chain
 34893                                  ;
 34894                                  ;		'C' set if error
 34895                                  ;		  AX = error_invalid_function
 34896                                  ;
 34897                                  ;	Rev. M000 - added support for HIGH_FIRST in (al) = 1. 7/9/90
 34898                                  ; 	Rev. M003 - added functions (al) = 2 and (al) = 3. 7/18/90
 34899                                  ;	Rev. M009 - (al) = 3 will return 'invalid function' in ax if
 34900                                  ;		    umbhead has'nt been initialized by sysinit and 'trashed
 34901                                  ;		    arena' if an arena sig is damaged.
 34902                                  ;----------------------------------------------------------------------------
 34903                                  
 34904                                  ; MSDOS 2.11 (& MSDOS 3.3)
 34905                                  ;----------------------------------------------------------------------------
 34906                                  ;SUBTTL $AllocOper - get/set allocation mechanism
 34907                                  ;
 34908                                  ;   Assembler usage:
 34909                                  ;           MOV     AH,AllocOper
 34910                                  ;           MOV     BX,method
 34911                                  ;           MOV     AL,func
 34912                                  ;           INT     21h
 34913                                  ;
 34914                                  ;   Error return:
 34915                                  ;           AX = error_invalid_function
 34916                                  ;----------------------------------------------------------------------------
 34917                                  
 34918                                  	; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 34919                                  _$ALLOCOPER:
 34920                                  	; 14/05/2019 - Retro DOS v4.0
 34921                                  	; MSDOS 6.0
 34922 000064A5 08C0                    	or	al,al ; 0
 34923 000064A7 741E                    	jz	short AllocGetStrat
 34924                                  	; 17/12/2022
 34925                                  	;cmp	al,1
 34926                                  	;jz	short AllocSetStrat
 34927                                  
 34928                                  	; 01/12/2022
 34929                                  	;cmp	al, 2
 34930                                  	;jb	short AllocSetStrat
 34931                                  	;ja	short AllocSetLink
 34932                                  	;;jmp	short AllocGetLink
 34933                                  ;AllocGetLink:
 34934                                  	; MSDOS 6.0
 34935                                  	;mov	al,[ss:UMBFLAG]		; return link state in al
 34936                                  	;and 	al,LINKSTATE		
 34937                                  	;;transfer SYS_RET_OK
 34938                                  	;jmp	SYS_RET_OK
 34939                                  
 34940 000064A9 3C02                    	cmp	al,2
 34941                                  	; 17/12/2022
 34942 000064AB 7223                    	jb	short AllocSetStrat ; al = 1
 34943 000064AD 7432                    	je	short AllocGetLink
 34944                                  
 34945                                  	;cmp	al,2
 34946                                  	;jz	short AllocGetLink
 34947 000064AF 3C03                    	cmp	al,3
 34948 000064B1 7436                    	jz	short AllocSetLink
 34949                                  
 34950                                  	; 15/04/2018
 34951                                  	;CMP	AL,1
 34952                                          ;JB	SHORT AllocOperGet
 34953                                          ;JZ	SHORT AllocOperSet
 34954                                  
 34955                                  AllocOperError:
 34956                                  	; 04/08/2018 - Retro DOS v3.0
 34957                                  	; MSDOS 3.3 (& MSDOS 6.0)	; Extended Error Locus	
 34958                                  	;mov	byte [ss:EXTERR_LOCUS],5
 34959 000064B3 36C606[2303]05                  MOV     byte [SS:EXTERR_LOCUS],errLOC_Mem
 34960                                  	;error	error_invalid_function
 34961                                  	;mov	al,1
 34962 000064B9 B001                    	MOV	AL,error_invalid_function
 34963                                  	; 17/12/2022
 34964                                  ;AllocOperErrj:
 34965                                  	;JMP	SYS_RET_ERR
 34966                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 34967                                  	;jmp	short dealloc_errj
 34968                                  	; 17/12/2022
 34969 000064BB EBE5                    	jmp	short AllocOperErrj
 34970                                  
 34971                                  AllocArenaError:
 34972                                  	; MSDOS 6.0
 34973 000064BD 36C606[2303]05          	MOV     byte [SS:EXTERR_LOCUS],errLOC_Mem
 34974                                  					; M009: Extended Error Locus
 34975                                  	;error	error_arena_trashed	; M009:
 34976                                  	;mov	al,7
 34977 000064C3 B007                    	MOV	AL,error_arena_trashed
 34978                                  	;JMP	SYS_RET_ERR
 34979 000064C5 EBDB                    	jmp	short AllocOperErrj ; 17/12/2022
 34980                                  
 34981                                  AllocGetStrat: 
 34982                                  	; MSDOS 6.0
 34983                                  AllocOperGet:
 34984 000064C7 36A0[0203]                      MOV     AL,[SS:AllocMethod]
 34985 000064CB 30E4                            XOR     AH,AH
 34986                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 34987                                  	;transfer SYS_RET_OK
 34988                                  AllocOperOk:
 34989                                  	; 17/12/2022
 34990                                  	;jmp	short dealloc_ok
 34991 000064CD E97AA1                  	JMP	SYS_RET_OK
 34992                                  
 34993                                  AllocSetStrat: 
 34994                                  	; 14/05/2019
 34995                                  	; MSDOS 6.0
 34996 000064D0 53                      	push	bx			; M000 - start
 34997                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 34998                                  	;and	bx,STRAT_MASK ; 0FF3Fh	; M064: mask off bit 6 & 7
 34999                                  	; 17/12/2022
 35000 000064D1 80E33F                  	and	bl,3Fh
 35001 000064D4 83FB02                  	cmp	bx,2			; BX must be 0-2
 35002                                  	;cmp	bl,2
 35003 000064D7 5B                      	pop	bx			; M000 - end
 35004 000064D8 77D9                    	ja	short AllocOperError
 35005                                  
 35006                                  AllocOperSet:
 35007 000064DA 36881E[0203]                    MOV     [SS:AllocMethod],BL
 35008                                    	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35009                                  	;transfer SYS_RET_OK
 35010                                  AllocOperOkj:
 35011 000064DF EBEC                    	jmp	short AllocOperOk
 35012                                  	;JMP	SYS_RET_OK
 35013                                  
 35014                                  AllocGetLink:
 35015                                  	; MSDOS 6.0
 35016 000064E1 36A0[8900]              	mov	al,[ss:UMBFLAG]		; return link state in al
 35017                                  	;and	al,1
 35018 000064E5 2401                    	and 	al,LINKSTATE		
 35019                                   	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35020                                  	;transfer SYS_RET_OK
 35021                                  AllocOperOkj2:
 35022                                  	; 17/12/2022
 35023 000064E7 EBE4                    	jmp	short AllocOperOk
 35024                                  	;jmp	short AllocOperOkj
 35025                                  	;;JMP	SYS_RET_OK
 35026                                  
 35027                                  AllocSetLink:
 35028                                  	; MSDOS 6.0			; M009 - start
 35029 000064E9 368B0E[8C00]            	mov	cx,[ss:UMB_HEAD]	; cx = umb_head
 35030 000064EE 83F9FF                  	cmp	cx,0FFFFh		; Q: has umb_head been initialized
 35031 000064F1 74C0                    	je	short AllocOperError	; N: error
 35032                                  					; Y: continue
 35033                                  					; M009 - end
 35034 000064F3 83FB01                  	cmp	bx,1			
 35035 000064F6 7204                    	jb	short UnlinkUmbs
 35036 000064F8 741C                    	jz	short LinkUmbs
 35037                                  	
 35038 000064FA EBB7                    	jmp	short AllocOperError
 35039                                  	
 35040                                  UnlinkUmbs:
 35041                                  	;test	byte [ss:UMBFLAG],1
 35042 000064FC 36F606[8900]01          	test	byte [ss:UMBFLAG],LINKSTATE ; Q: umbs unlinked?
 35043 00006502 7410                    	jz	short unlinked		; Y: return 
 35044                                  	
 35045 00006504 E82900                  	call	GetLastArena		; get arena before umb_head in DS
 35046 00006507 72B4                    	jc	short AllocArenaError	; M009: arena trashed
 35047                                  	
 35048                                  					; make it last
 35049 00006509 C60600005A              	mov	byte [0],arena_signature_end
 35050                                  	
 35051                                  	;and	byte [ss:UMBFLAG],0FEh
 35052 0000650E 368026[8900]FE          	and	byte [ss:UMBFLAG],~LINKSTATE ; indicate unlink'd state in umbflag
 35053                                  	
 35054                                  unlinked:
 35055                                   	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35056                                  	;transfer SYS_RET_OK
 35057                                  	; 17/12/2022
 35058 00006514 EBB7                    	jmp	short AllocOperOk
 35059                                  	;jmp	short AllocOperOkj2
 35060                                  	;;JMP	SYS_RET_OK
 35061                                  
 35062                                  LinkUmbs:
 35063 00006516 36F606[8900]01          	test	byte [ss:UMBFLAG],LINKSTATE ; Q: umbs linked?
 35064 0000651C 7510                    	jnz	short linked		; Y: return
 35065                                  	
 35066 0000651E E80F00                  	call	GetLastArena		; get arena before umb_head
 35067 00006521 729A                    	jc	short AllocArenaError	; M009: arena trashed
 35068                                  	
 35069                                  					; make it normal. M061: ds points to
 35070                                  					; arena before umb_head
 35071 00006523 C60600004D              	mov	byte [0],arena_signature_normal
 35072                                  	
 35073 00006528 36800E[8900]01          	or	byte [ss:UMBFLAG],LINKSTATE ; indicate link'd state in umbflag
 35074                                  linked:
 35075                                   	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35076                                  	;transfer SYS_RET_OK
 35077                                  	; 17/12/2022
 35078 0000652E EB9D                    	jmp	short AllocOperOk
 35079                                  	;jmp	short unlinked
 35080                                  	;;JMP	SYS_RET_OK
 35081                                  
 35082                                  ; MSDOS 6.0
 35083                                  ;--------------------------------------------------------------------------
 35084                                  ; Procedure Name : GetLastArena		-  M003
 35085                                  ;
 35086                                  ; Inputs	 : cx = umb_head
 35087                                  ;
 35088                                  ;
 35089                                  ; Outputs	 : If UMBs are linked
 35090                                  ;			ES = umb_head
 35091                                  ;			DS = arena before umb_head
 35092                                  ;		   else
 35093                                  ;			DS = last arena
 35094                                  ;			ES = next arena. will be umb_head if NC.
 35095                                  ;
 35096                                  ;		   CY if error
 35097                                  ;
 35098                                  ; Uses		 : DS, ES, DI, BX
 35099                                  ;--------------------------------------------------------------------------
 35100                                  
 35101                                  ; 14/05/2019 - Retro DOS v4.0
 35102                                  ; DOSCODE:A4D6h (MSDOS 6.21, MSDOS.SYS)
 35103                                  
 35104                                  ; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 35105                                  ; DOSCODE:A476h (MSDOS 5.0, MSDOS.SYS)
 35106                                  	
 35107                                  GetLastArena:
 35108 00006530 50                      	push	ax			; save ax
 35109                                  
 35110 00006531 36A1[2400]              	mov	ax,[ss:arena_head]
 35111 00006535 8EC0                    	mov	es,ax			; es = arena_head
 35112 00006537 31FF                    	xor	di,di
 35113                                  
 35114 00006539 26803D5A                	cmp     byte [es:di],arena_signature_end
 35115                                  					; Q: is this the last arena
 35116 0000653D 7419                    	je	short GLA_done		; Y: return last arena in ES		
 35117                                  					
 35118                                  GLA_next:
 35119 0000653F 8ED8                    	mov	ds,ax
 35120 00006541 E879FD                  	call	arena_next		; ax, es -> next arena
 35121                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35122                                  	;jc	short GLA_err
 35123                                  	; 17/12/2022
 35124 00006544 7228                    	jc	short GLA_err2
 35125                                  
 35126 00006546 36F606[8900]01          	test	byte [ss:UMBFLAG],LINKSTATE ; Q: are UMBs linked
 35127 0000654C 7506                    	jnz	short GLA_chkumb	; Y: terminating condition is 
 35128                                  					;    umb_head
 35129                                  					; N: terminating condition is 05Ah
 35130                                  
 35131 0000654E 26803D5A                	cmp     byte [es:di],arena_signature_end
 35132                                  					; Q: is this the last arena
 35133 00006552 EB02                    	jmp	short GLA_@f
 35134                                  GLA_chkumb:
 35135 00006554 39C8                    	cmp	ax,cx			; Q: is this umb_head
 35136                                  GLA_@f:
 35137 00006556 75E7                    	jne	short GLA_next		; N: get next arena
 35138                                  
 35139                                  GLA_done:
 35140                                  					; M061 - Start
 35141 00006558 36F606[8900]01          	test	byte [ss:UMBFLAG],LINKSTATE ; Q: are UMBs linked
 35142 0000655E 750B                    	jnz	short GLA_ret		; Y: we're done
 35143                                  					; N: let us confirm that the next 
 35144                                  					;    arena is umb_head
 35145 00006560 8ED8                    	mov	ds,ax
 35146 00006562 E858FD                  	call	arena_next		; ax, es -> next arena
 35147                                  	;jc	short GLA_err
 35148 00006565 7207                    	jc	short GLA_err2
 35149 00006567 39C8                    	cmp	ax,cx			; Q: is this umb_head
 35150 00006569 7502                    	jne	short GLA_err		; N: error
 35151                                  					; M061 - End
 35152                                  GLA_ret:
 35153                                  	; 17/12/2022				
 35154                                  	;clc
 35155                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35156                                  	;clc
 35157 0000656B 58                      	pop	ax			; M061
 35158 0000656C C3                      	retn				; M061
 35159                                  
 35160                                  GLA_err:
 35161 0000656D F9                      	stc				; M061
 35162                                  GLA_err2:
 35163 0000656E 58                      	pop	ax
 35164 0000656F C3                      	retn
 35165                                  
 35166                                  ;============================================================================
 35167                                  ; SRVCALL.ASM, MSDOS 6.0, 1991
 35168                                  ;============================================================================
 35169                                  ; 04/08/2018 - Retro DOS v3.0
 35170                                  
 35171                                  ;	TITLE SRVCALL - Server DOS call
 35172                                  ;	NAME  SRVCALL
 35173                                  
 35174                                  ;**	SRVCALL.ASM - Server DOS call functions
 35175                                  ;
 35176                                  ;
 35177                                  ;	$ServerCall
 35178                                  ;
 35179                                  ;	Modification history:
 35180                                  ;
 35181                                  ;	    Created: ARR 08 August 1983
 35182                                  
 35183                                  ;AsmVars <Installed>
 35184                                  
 35185                                  ;include dpl.asm
 35186                                  
 35187                                  ;Installed = TRUE
 35188                                  
 35189                                  ; 29/04/2019 - Retro DOS v4.0 (MSDOS 6.0, MSDOS 6.21)
 35190                                  ; ---------------------------------------------------------------------------
 35191                                  ; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 35192                                  
 35193                                  ;BREAK <ServerCall -- Server DOS call>
 35194                                  
 35195                                  ; DOSCODE:A517h (MSDOS 6.21, MSDOS.SYS)
 35196                                  ; DOSCODE:A4B7h (MSDOS 5.0, MSDOS.SYS)
 35197                                  
 35198                                  ;hkn; TABLE	SEGMENT
 35199                                  ;Public SRVC001S,SRVC001E
 35200                                  ;SRVC001S label byte
 35201                                  
 35202                                  SRVC001S:
 35203                                  
 35204 00006570 [7465]                  SERVERTAB:	dw	SERVER_DISP
 35205 00006572 [C665]                  SERVERLEAVE:	dw	SERVERRETURN
 35206 00006574 0B                      SERVER_DISP:	db	(SERVER_DISP_END-SERVER_DISP-1)/2 ; = 11
 35207 00006575 [2E66]                  		dw	SRV_CALL	; 0
 35208 00006577 [C765]                  		dw	COMMIT_ALL	; 1
 35209 00006579 [FD65]                  		dw	CLOSE_NAME	; 2
 35210 0000657B [0866]                  		dw	CLOSE_UID	; 3
 35211 0000657D [0F66]                  		dw	CLOSE_UID_PID	; 4
 35212 0000657F [1666]                  		dw	GET_LIST	; 5
 35213 00006581 [6F66]                  		dw	GET_DOS_DATA	; 6
 35214 00006583 [9366]                  		dw	SPOOL_OPER	; 7
 35215 00006585 [9366]                  		dw	SPOOL_OPER	; 8
 35216 00006587 [9366]                  		dw	SPOOL_OPER	; 9
 35217 00006589 [9F66]                  		dw	_$SetExtendedError  ; 10
 35218                                  
 35219                                  SERVER_DISP_END:  ;  LABEL BYTE
 35220                                  
 35221                                  ;SRVC001E label byte
 35222                                  
 35223                                  SRVC001E:
 35224                                  
 35225                                  ;hkn; TABLE	ENDS
 35226                                  
 35227                                  ;----------------------------------------------------------------------------
 35228                                  ;
 35229                                  ; Procedure Name : $ServerCall
 35230                                  ;
 35231                                  ; Inputs:
 35232                                  ;	DS:DX -> DPL  (except calls 7,8,9)
 35233                                  ; Function:
 35234                                  ;	AL=0	Server DOS call
 35235                                  ;	AL=1	Commit All files
 35236                                  ;	AL=2	Close file by name (SHARING LOADED ONLY) DS:DX in DPL -> name
 35237                                  ;	AL=3	Close all files for DPL_UID
 35238                                  ;	AL=4	Close all files for DPL_UID/PID_PID
 35239                                  ;	AL=5	Get open file list entry
 35240                                  ;		    IN: BX File Index
 35241                                  ;			CX User Index
 35242                                  ;		    OUT:ES:DI -> Name
 35243                                  ;			BX = UID
 35244                                  ;		    CX = # locked blocks held by this UID
 35245                                  ;	AL=6	Get DOS data area
 35246                                  ;		    OUT: DS:SI -> Start
 35247                                  ;			CX size in bytes of swap if indos
 35248                                  ;			DX size in bytes of swap always
 35249                                  ;	AL=7	Get truncate flag
 35250                                  ;	AL=8	Set truncate flag
 35251                                  ;	AL=9	Close all spool files
 35252                                  ;	AL=10	SetExtendedError
 35253                                  ;
 35254                                  ;----------------------------------------------------------------------------
 35255                                  
 35256                                  _$ServerCall:
 35257                                  	; 13/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 35258                                  	; DOSCODE:A4D2h (MSDOS 5.0 MSDOS.SYS)		
 35259                                  	; 10/06/2019
 35260                                  	; 29/04/2019 - Retro DOS v4.0
 35261                                  	; DOSCODE:A532h (MSDOS 6.21 MSDOS.SYS)
 35262                                  
 35263                                  	; 05/08/2018 - Retro DOS v3.0
 35264                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 657Bh
 35265 0000658B 3C07                    	CMP	AL,7
 35266 0000658D 7204                    	JB	short SET_STUFF
 35267 0000658F 3C09                    	CMP	AL,9
 35268 00006591 761A                    	JBE	short NO_SET_ID		; No DPL on calls 7,8,9
 35269                                  SET_STUFF:
 35270 00006593 89D6                    	MOV	SI,DX			; Point to DPL with DS:SI
 35271                                  	;mov	bx,[si+12h]
 35272 00006595 8B5C12                  	MOV	BX,[SI+DPL.UID]
 35273                                  
 35274                                  	; MSDOS 6.0
 35275                                  ;SR;
 35276                                  ; WIN386 updates the USER_ID itself. If WIN386 is present we skip the updating
 35277                                  ; of USER_ID
 35278                                  
 35279 00006598 36F606[2F10]01          	test	byte [SS:IsWin386],1
 35280 0000659E 7505                    	jnz	short skip_win386
 35281                                  
 35282                                  ;hkn; SS override for user_id and proc_id
 35283                                  	; 15/08/2018
 35284 000065A0 36891E[3E03]            	MOV	[SS:USER_ID],BX		; Set UID
 35285                                  
 35286                                  skip_win386:
 35287 000065A5 8B5C14                  	MOV	BX,[SI+DPL.PID]
 35288 000065A8 36891E[3C03]            	MOV	[SS:PROC_ID],BX		; Set process ID
 35289                                  NO_SET_ID:
 35290                                  	; 10/06/2019 - Retro DOS v4.0
 35291 000065AD 2EFF36[7265]            	PUSH	word [cs:SERVERLEAVE]	; push return address
 35292 000065B2 2EFF36[7065]            	PUSH	word [cS:SERVERTAB]	; push table address
 35293 000065B7 50                      	PUSH	AX
 35294 000065B8 E8ADAC                  	call	TableDispatch
 35295                                  
 35296                                  ;hkn; SS override
 35297                                  	;mov 	byte [SS:EXETERR_LOCUS],1
 35298 000065BB 36C606[2303]01          	MOV	byte [SS:EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus
 35299                                  	;error	error_invalid_function
 35300                                  	;mov	al,1
 35301 000065C1 B001                    	MOV	AL,error_invalid_function
 35302                                  servercall_error:
 35303 000065C3 E98DA0                  	JMP	SYS_RET_ERR
 35304                                  
 35305                                  SERVERRETURN:
 35306 000065C6 C3                      	retn
 35307                                  
 35308                                  ; Commit - iterate through the open file list and make sure that the
 35309                                  ; directory entries are correctly updated.
 35310                                  
 35311                                  	; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 35312                                  COMMIT_ALL:
 35313 000065C7 31DB                    	XOR	BX,BX			;   for (i=0; ThisSFT=getSFT(i); i++)
 35314 000065C9 16                      	push	ss
 35315 000065CA 1F                      	pop	ds
 35316 000065CB E889AD                  	call	ECritSFT		; Gonna scan SFT cache, lock it down
 35317                                  CommitLoop:
 35318 000065CE 53                      	push	bx
 35319 000065CF E82401                  	call	SFFromSFN
 35320 000065D2 7222                    	JC	short CommitDone
 35321 000065D4 26833D00                	cmp	word [es:di],0
 35322                                  	;CMP	word [ES:DI+SF_ENTRY.sf_Ref_Count],0
 35323                                  					; if (ThisSFT->refcount != 0)
 35324 000065D8 7418                    	JZ	short CommitNext
 35325                                  	;cmp	word [es:di],0FFFFh ; -1
 35326 000065DA 26833DFF                	cmp	word [ES:DI],sf_busy
 35327                                  	;CMP	word [ES:DI+SF_ENTRY.sf_Ref_Count],sf_busy  
 35328                                  					; BUSY SFTs have god knows what
 35329 000065DE 7412                    	JZ	short CommitNext	;   in them.
 35330                                  	; 17/12/2022
 35331 000065E0 26F6450680              	test	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_isnet>>8) ; 80h
 35332                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet ; 8000h
 35333 000065E5 750B                    	JNZ	short CommitNext	;  Skip Network SFTs so the SERVER
 35334                                  					;	doesn't deadlock
 35335 000065E7 893E[9E05]              	MOV	[THISSFT],DI
 35336 000065EB 8C06[A005]              	MOV	[THISSFT+2],ES
 35337 000065EF E8F6CA                  	call	DOS_COMMIT		;	DOSCommit ();
 35338                                  CommitNext:
 35339 000065F2 5B                      	pop	bx
 35340 000065F3 43                      	INC	BX
 35341 000065F4 EBD8                    	JMP	short CommitLoop
 35342                                  CommitDone:
 35343 000065F6 E879AD                  	call	LCritSFT
 35344 000065F9 5B                      	pop	bx
 35345                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35346                                  Commit_Ok:
 35347 000065FA E94DA0                  	jmp	SYS_RET_OK
 35348                                  	
 35349                                  
 35350                                  CLOSE_NAME:
 35351                                  
 35352                                  ;if installed
 35353                                  
 35354                                  ;hkn; SS override
 35355                                  	;call	far [ss:MFTcloN]
 35356 000065FD 36FF1E[A400]            	Call	far [SS:JShare+(5*4)] ; 5 = MFTcloN
 35357                                  ;else
 35358                                  ;	Call	MFTcloN
 35359                                  ;endif
 35360                                  
 35361                                  CheckReturns:
 35362 00006602 7202                    	JC	short func_err
 35363                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35364                                  	;transfer SYS_RET_OK
 35365                                  Commit_Okj:
 35366 00006604 EBF4                    	jmp	short Commit_Ok
 35367                                  	;jmp	SYS_RET_OK
 35368                                  
 35369                                  func_err:
 35370                                  	;transfer SYS_RET_ERR
 35371                                  	;jmp	SYS_RET_ERR
 35372 00006606 EBBB                    	jmp	short servercall_error
 35373                                  
 35374                                  CLOSE_UID:
 35375                                  
 35376                                  ;if installed
 35377                                  ;hkn; SS override
 35378                                  	;call	far [ss:MFTclU]
 35379 00006608 36FF1E[9C00]            	Call	far [SS:JShare+(3*4)] ; 3 = MTFTclu
 35380                                  ;else
 35381                                  ;	Call	MFTclU
 35382                                  ;endif
 35383 0000660D EBF3                    	JMP	short CheckReturns
 35384                                  
 35385                                  CLOSE_UID_PID:
 35386                                  
 35387                                  ;if installed
 35388                                  ;hkn; SS override
 35389                                  	;call	far [ss:MFTCloseP]
 35390 0000660F 36FF1E[A000]            	Call	far [SS:JShare+(4*4)] ; 4 = MFTCloseP 
 35391                                  ;else
 35392                                  ;	Call	MFTCloseP
 35393                                  ;endif
 35394 00006614 EBEC                    	JMP	short CheckReturns
 35395                                  
 35396                                  GET_LIST:
 35397                                  
 35398                                  ;if installed
 35399                                  ;hkn; SS override
 35400                                  	;call	far [ss:MFT_get]
 35401 00006616 36FF1E[B400]            	Call	far [SS:JShare+(9*4)] ; 9 = MFT_get
 35402                                  ;else
 35403                                  ;	Call	MFT_get
 35404                                  ;endif
 35405 0000661B 72E9                    	JC	short func_err
 35406 0000661D E8709E                  	call	Get_User_Stack
 35407                                  	;mov	[si+2],bx
 35408 00006620 895C02                  	MOV	[SI+user_env.user_BX],BX
 35409                                  	;mov	[si+10],di
 35410 00006623 897C0A                  	MOV	[SI+user_env.user_DI],DI
 35411                                  	;mov	[si+16],es
 35412 00006626 8C4410                  	MOV	[SI+user_env.user_ES],ES
 35413                                  SetCXOK:
 35414                                  	;mov	[si+4],cx
 35415 00006629 894C04                  	MOV	[SI+user_env.user_CX],CX
 35416                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35417                                  	;transfer SYS_RET_OK
 35418                                  Commit_Okj2:
 35419                                  	; 17/12/2022
 35420 0000662C EBCC                    	jmp	short Commit_Ok
 35421                                  	;jmp	short Commit_Okj
 35422                                  	;;jmp	SYS_RET_OK
 35423                                  
 35424                                  SRV_CALL:
 35425 0000662E 58                      	POP	AX			; get rid of call to $srvcall
 35426 0000662F 1E                      	push	ds
 35427 00006630 56                      	push	si
 35428 00006631 E85C9E                  	call	Get_User_Stack
 35429 00006634 5F                      	pop	di
 35430 00006635 07                      	pop	es
 35431                                  
 35432                                  ; DS:SI point to stack
 35433                                  ; ES:DI point to DPL
 35434                                  
 35435 00006636 E80EAC                  	call	XCHGP
 35436                                  
 35437                                  ; DS:SI point to DPL
 35438                                  ; ES:DI point to stack
 35439                                  ;
 35440                                  ; We now copy the registers from DPL to save stack
 35441                                  
 35442 00006639 56                      	push	si
 35443 0000663A B90600                  	MOV	CX,6
 35444 0000663D F3A5                    	REP	MOVSW			; Put in AX,BX,CX,DX,SI,DI
 35445 0000663F 47                      	INC	DI
 35446 00006640 47                      	INC	DI			; Skip user_BP
 35447 00006641 A5                      	MOVSW				; DS
 35448 00006642 A5                      	MOVSW				; ES
 35449 00006643 5E                      	pop	si			; DS:SI -> DPL
 35450 00006644 8B04                    	mov	ax,[SI]
 35451                                  	;MOV	AX,[SI+DPL.AX]
 35452                                  	;mov	bx,[si+2]
 35453 00006646 8B5C02                  	MOV	BX,[SI+DPL.BX]
 35454                                  	;mov	cx,[si+4]
 35455 00006649 8B4C04                  	MOV	CX,[SI+DPL.CX]
 35456                                  	;mov	dx,[si+6]
 35457 0000664C 8B5406                  	MOV	DX,[SI+DPL.DX]
 35458                                  	;mov	di,[si+10]
 35459 0000664F 8B7C0A                  	MOV	DI,[SI+DPL.DI]
 35460                                  	;mov	es,[si+14]
 35461 00006652 8E440E                  	MOV	ES,[SI+DPL.ES]
 35462                                  	;push	word [si+8]
 35463 00006655 FF7408                  	PUSH	word [SI+DPL.SI]
 35464                                  	;mov	ds,[si+12]
 35465 00006658 8E5C0C                  	MOV	DS,[SI+DPL.DS]
 35466 0000665B 5E                      	POP	SI
 35467                                  
 35468                                  ;hkn; SS override for next 3
 35469 0000665C 368C1E[EC05]            	MOV	[SS:SAVEDS],DS
 35470 00006661 36891E[EA05]            	MOV	[SS:SAVEBX],BX
 35471 00006666 36C606[7205]FF          	MOV	byte [SS:FSHARING],-1	; set no redirect flag
 35472 0000666C E91E9D                  	jmp	REDISP
 35473                                  
 35474                                  GET_DOS_DATA:
 35475 0000666F 16                      	push	ss
 35476 00006670 07                      	pop	es
 35477 00006671 BF[2003]                	MOV     DI,SWAP_START
 35478 00006674 B9[AC0A]                	MOV     CX,SWAP_END
 35479 00006677 BA[3A03]                	MOV     DX,SWAP_ALWAYS
 35480 0000667A 29F9                    	SUB     CX,DI
 35481 0000667C 29FA                    	SUB     DX,DI
 35482 0000667E D1E9                    	SHR     CX,1                    ; div by 2, remainder in carry
 35483 00006680 83D100                  	ADC     CX,0                    ; div by 2 + round up
 35484 00006683 D1E1                    	SHL     CX,1                    ; round up to 2 boundary.
 35485 00006685 E8089E                  	call	Get_User_Stack
 35486                                  	;mov	[si+14],es
 35487 00006688 8C440E                  	MOV     [SI+user_env.user_DS],ES
 35488                                  	;mov	[si+8],di
 35489 0000668B 897C08                  	MOV     [SI+user_env.user_SI],DI
 35490                                  	;mov	[si+6],dx
 35491 0000668E 895406                  	MOV     [SI+user_env.user_DX],DX
 35492 00006691 EB96                    	JMP	short SetCXOK
 35493                                  
 35494                                  SPOOL_OPER:
 35495                                  	;CallInstall NETSpoolOper,MultNET,37,AX,BX
 35496                                  
 35497 00006693 50                      	push    ax
 35498 00006694 B82511                  	mov     ax,1125h
 35499 00006697 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - REDIRECTED PRINTER MODE
 35500                                  			; STACK: WORD subfunction
 35501                                  			; Return: CF set on error, AX = error code
 35502                                  			; STACK unchanged
 35503 00006699 5B                      	pop	bx
 35504                                  	; 17/12/2022
 35505                                  	;JC	short func_err2
 35506 0000669A 7390                    	jnc	short Commit_Okj2
 35507                                  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35508                                  	;;jmp	SYS_RET_OK
 35509                                  	;jmp	short Commit_Okj2
 35510                                  	
 35511                                  func_err2:
 35512 0000669C E9B49F                  	jmp	SYS_RET_ERR
 35513                                  
 35514                                  ;Break	<$SetExtendedError - set extended error for later retrieval>
 35515                                  ;--------------------------------------------------------------------------
 35516                                  ;
 35517                                  ; Procedure Name : $SetExtendedError
 35518                                  ;
 35519                                  ; $SetExtendedError takes extended error information and loads it up for the
 35520                                  ; next extended error call. This is used by interrupt-level proccessors to
 35521                                  ; mask their actions.
 35522                                  ;
 35523                                  ;   Inputs: DS:SI points to DPL which contains all registers
 35524                                  ;   Outputs: none
 35525                                  ;
 35526                                  ;---------------------------------------------------------------------------
 35527                                  
 35528                                  _$SetExtendedError:
 35529                                  
 35530                                  ;hkn; SS override for all variables used
 35531                                  
 35532 0000669F 8B04                    	mov	ax,[si]
 35533                                  	;MOV	AX,[SI+DPL.AX]
 35534 000066A1 36A3[2403]              	MOV	[SS:EXTERR],AX
 35535                                  	;mov	ax,[si+10]
 35536 000066A5 8B440A                  	MOV	AX,[SI+DPL.DI]
 35537 000066A8 36A3[2803]              	MOV	[SS:EXTERRPT],AX
 35538                                  	;mov	ax,[si+14]
 35539 000066AC 8B440E                  	MOV	AX,[SI+DPL.ES]
 35540 000066AF 36A3[2A03]              	MOV	[SS:EXTERRPT+2],AX
 35541                                  	;mov	ax,[si+2]
 35542 000066B3 8B4402                  	MOV	AX,[SI+DPL.BX]
 35543 000066B6 36A3[2603]              	MOV	[SS:EXTERR_ACTION],AX
 35544                                  	;mov	ax,[si+4]
 35545 000066BA 8B4404                  	MOV	AX,[SI+DPL.CX]
 35546 000066BD 368826[2303]            	MOV	[SS:EXTERR_LOCUS],AH
 35547 000066C2 C3                      	retn
 35548                                  
 35549                                  ;============================================================================
 35550                                  ; UTIL.ASM, MSDOS 6.0, 1991
 35551                                  ;============================================================================
 35552                                  ; 05/08/2018 - Retro DOS v3.0
 35553                                  ; 05/05/2019 - Retro DOS v4.0
 35554                                  
 35555                                  ;**	Handle related utilities for MSDOS 2.X.
 35556                                  ;----------------------------------------------------------------------------
 35557                                  ;	pJFNFromHandle	written
 35558                                  ;	SFFromHandle	written
 35559                                  ;	SFFromSFN	written
 35560                                  ;	JFNFree 	written
 35561                                  ;	SFNFree 	written
 35562                                  ;
 35563                                  ;	Modification history:
 35564                                  ;
 35565                                  ;	    Created: MZ 1 April 1983
 35566                                  ;----------------------------------------------------------------------------
 35567                                  
 35568                                  ;	BREAK	<pJFNFromHandle - return pointer to JFN table entry>
 35569                                  
 35570                                  ;**	pJFNFromHandle - Translate Handle to Pointer to JFN
 35571                                  ;----------------------------------------------------------------------------
 35572                                  ;	pJFNFromHandle takes a file handle and turns that into a pointer to
 35573                                  ;	the JFN entry (i.e., to a byte holding the internal file handle #)
 35574                                  ;
 35575                                  ;	NOTE:
 35576                                  ;	  This routine is called from $CREATE_PROCESS_DATA_BLOCK which is called
 35577                                  ;	  at DOSINIT time with SS NOT DOSGROUP
 35578                                  ;
 35579                                  ;	ENTRY	(bx) = handle
 35580                                  ;	EXIT	'C' clear if ok
 35581                                  ;		  (es:di) = address of JFN value
 35582                                  ;		'C' set if error
 35583                                  ;		  (ax) = error code
 35584                                  ;	USES	AX, DI, ES, Flags
 35585                                  ;----------------------------------------------------------------------------
 35586                                  
 35587                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 35588                                  
 35589                                  pJFNFromHandle:
 35590                                  	; 05/05/2019 - Retro DOS v4.0
 35591                                  	;getdseg <es>			; es -> dosdata
 35592 000066C3 2E8E06[0700]            	mov	es,[cs:DosDSeg]
 35593                                  	
 35594                                  	;MOV	ES,[cs:CurrentPDB]	; get user process data block
 35595 000066C8 268E06[3003]            	mov	es,[es:CurrentPDB]
 35596                                  
 35597                                  	;cmp	bx,[ES:32h]
 35598 000066CD 263B1E3200              	CMP	BX,[ES:PDB.JFN_Length]	; is handle greater than allocated
 35599 000066D2 7204                    	JB	short pjfn10		; no, get offset
 35600                                  ReturnCarry_inv_hndl: ; 05/08/2018 - Retro DOS v3.0
 35601                                  	;mov	al,6
 35602 000066D4 B006                    	MOV     AL,error_invalid_handle ; appropriate error
 35603                                  ReturnCarry:
 35604 000066D6 F9                      	STC                             ; signal error
 35605 000066D7 C3                      	retn				; go back
 35606                                  pjfn10: 
 35607                                  	;les	di,[es:34h]
 35608 000066D8 26C43E3400              	LES	DI,[ES:PDB.JFN_Pointer]	; get pointer to beginning of table
 35609 000066DD 01DF                    	ADD	DI,BX			; add in offset, clear 'C'
 35610                                  	;clc
 35611                                  pJFNFromHandle_error:
 35612 000066DF C3                      	retn
 35613                                  
 35614                                  ;BREAK <SFFromHandle - return pointer (or error) to SF entry from handle>
 35615                                  ;----------------------------------------------------------------------------
 35616                                  ;
 35617                                  ; Procedure Name : SFFromHandle
 35618                                  ;
 35619                                  ; SFFromHandle - Given a handle, get JFN and then index into SF table
 35620                                  ;
 35621                                  ;   Input:      BX has handle
 35622                                  ;   Output:     Carry Set
 35623                                  ;                   AX has error code
 35624                                  ;               Carry Reset
 35625                                  ;                   ES:DI has pointer to SF entry
 35626                                  ;   Registers modified: If error, AX,ES, else ES:DI
 35627                                  ; NOTE:
 35628                                  ;   This routine is called from $CREATE_PROCESS_DATA_BLOCK which is called
 35629                                  ;       at DOSINIT time with SS NOT DOSGROUP
 35630                                  ;
 35631                                  ;----------------------------------------------------------------------------
 35632                                  
 35633                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 35634                                  
 35635                                  SFFromHandle:
 35636 000066E0 E8E0FF                  	CALL	pJFNFromHandle		; get jfn pointer
 35637                                  	;retc				; return if error
 35638 000066E3 72FA                    	jc	short pJFNFromHandle_error
 35639 000066E5 26803DFF                	CMP     BYTE [ES:DI],-1		; unused handle
 35640                                  	;JNZ	short GetSF		; nope, suck out SF
 35641                                  	;;mov	al,6
 35642                                  	;MOV	AL,error_invalid_handle ; appropriate error
 35643                                  	;jmp	short ReturnCarry	; signal it
 35644                                  	; 17/12/2022
 35645                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35646 000066E9 74E9                    	jz	short ReturnCarry_inv_hndl ; Retro DOS v3.0 modification
 35647                                  	;JNZ	short GetSF		; nope, suck out SF
 35648                                  	;;mov	al,6
 35649                                  	;MOV	AL,error_invalid_handle ; appropriate error
 35650                                  	;jmp	short ReturnCarry	; signal it
 35651                                  GetSF:
 35652 000066EB 53                      	push	bx			; save handle
 35653 000066EC 268A1D                  	MOV     BL,[ES:DI]		; get SFN
 35654 000066EF 30FF                    	XOR     BH,BH                   ; ignore upper half
 35655 000066F1 E80200                  	CALL    SFFromSFN               ; get real sf spot
 35656 000066F4 5B                      	pop	bx			; restore
 35657 000066F5 C3                      	retn                        	; say goodbye
 35658                                  
 35659                                  ;BREAK <SFFromSFN - index into SF table for SFN>
 35660                                  
 35661                                  ;**	SFFromSFN - Get an SF Table entry from an SFN
 35662                                  ;----------------------------------------------------------------------------
 35663                                  ;	SFFromSfn uses an SFN to index an entry into the SF table. This
 35664                                  ;	is more than just a simple index instruction because the SF table
 35665                                  ;	can be made up of multiple pieces chained together. We follow the
 35666                                  ;	chain to the right piece and then do the index operation.
 35667                                  ;
 35668                                  ;   NOTE:
 35669                                  ;	This routine is called from SFFromHandle which is called
 35670                                  ;       at DOSINIT time with SS NOT DOSGROUP
 35671                                  ;
 35672                                  ;	ENTRY	BX has SF index
 35673                                  ;	EXIT	'C' clear if OK
 35674                                  ;		  ES:DI points to SF entry
 35675                                  ;		'C' set if index too large
 35676                                  ;	USES	BX, DI, ES
 35677                                  ;----------------------------------------------------------------------------
 35678                                  
 35679                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 35680                                  
 35681                                  SFFromSFN:
 35682                                  	; 05/05/2019 - Retro DOS v4.0
 35683                                  	;getdseg <es>			; es -> dosdata
 35684 000066F6 2E8E06[0700]            	mov	es,[cs:DosDSeg]
 35685                                  
 35686                                  	;LES	DI,[CS:SFT_ADDR]	; (es:di) = start of SFT table
 35687 000066FB 26C43E[2A00]            	les	di,[es:SFT_ADDR]
 35688                                  sfsfn5:	
 35689                                  	;cmp	bx,[es:di+4]
 35690 00006700 263B5D04                	CMP	BX,[ES:DI+SFT.SFCount]	; is handle in this table?
 35691 00006704 720E                    	JB	short sfsfn7		; yes, go grab it
 35692                                  	;sub	bx,[es:di+4]
 35693 00006706 262B5D04                	SUB     BX,[ES:DI+SFT.SFCount]
 35694 0000670A 26C43D                  	les	di,[es:di] ; 14/08/2018
 35695                                  	;LES	DI,[ES:DI+SFT.SFLink]	; get next table segment
 35696 0000670D 83FFFF                  	CMP     DI,-1                   ; end of tables?
 35697 00006710 75EE                    	JNZ	short sfsfn5		; no, try again
 35698 00006712 F9                      	STC
 35699 00006713 C3                      	retn				; return with error, not found
 35700                                  sfsfn7:
 35701 00006714 50                      	push	ax
 35702                                  	;mov	ax,53 ; MSDOS 3.3
 35703                                  	;mov	ax,59 ; MSDOS 6.0
 35704                                  	;MOV	AX,SF_ENTRY.size	; put it in a nice place
 35705                                  	
 35706                                  	; 17/12/2022
 35707 00006715 B03B                    	mov	al,SF_ENTRY.size ; 28/05/2019
 35708                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35709                                  	;mov	ax,SF_ENTRY.size ; 59
 35710                                  	
 35711 00006717 F6E3                    	MUL	BL			; (ax) = offset into this SF block
 35712 00006719 01C7                    	ADD	DI,AX			; add base of SF block
 35713 0000671B 58                      	pop	ax
 35714                                  	;add	di,6
 35715 0000671C 83C706                  	ADD	DI,SFT.SFTable		; offset into structure, 'C' cleared
 35716 0000671F C3                      	retn				; return with 'C' clear
 35717                                  
 35718                                  ;	BREAK <JFNFree - return a jfn pointer if one is free>
 35719                                  
 35720                                  ;**	JFNFree - Find a Free JFN Slot
 35721                                  ;----------------------------------------------------------------------------
 35722                                  ;	JFNFree scansthrough the JFN table and returnsa pointer to a free slot
 35723                                  ;
 35724                                  ;	ENTRY	(ss) = DOSDATA
 35725                                  ;	EXIT	'C' clear if OK
 35726                                  ;		  (bx) = new handle
 35727                                  ;		  (es:di) = pointer to JFN slot
 35728                                  ;		'C' set if error
 35729                                  ;		  (al) = error code
 35730                                  ;	USES	bx, di, es, flags
 35731                                  ;----------------------------------------------------------------------------
 35732                                  
 35733                                  JFNFree:
 35734 00006720 31DB                    	XOR	BX,BX			; (bx) = initial JFN to try
 35735                                  jfnf1:	
 35736 00006722 E89EFF                  	CALL	pJFNFromHandle		; get the appropriate handle
 35737 00006725 7209                    	JC	short jfnf5		; no more handles
 35738 00006727 26803DFF                	CMP     BYTE [ES:DI],-1		; free?
 35739 0000672B 7405                    	je	short jfnfx		; yes, carry is clear
 35740 0000672D 43                      	INC     BX                      ; no, next handle
 35741 0000672E EBF2                    	JMP	short jfnf1		; and try again
 35742                                  
 35743                                  	; Error. 'C' set
 35744                                  jfnf5:	
 35745                                  	;mov	al,4
 35746 00006730 B004                    	MOV	AL,error_too_many_open_files
 35747                                  jfnfx:	
 35748 00006732 C3                      	retn				; bye
 35749                                  
 35750                                  ;	BREAK <SFNFree - Allocate a free SFN>
 35751                                  
 35752                                  ;**	SFNFree - Allocate a Free SFN/SFT
 35753                                  ;----------------------------------------------------------------------------
 35754                                  ;	SFNFree scans through the sf table looking for a free entry
 35755                                  ;	If it finds one it partially allocates it by setting SFT_REF_COUNT = -1
 35756                                  ;
 35757                                  ;	The problem is that we want to mark the SFT busy so that other threads
 35758                                  ;	can't allocate the SFT before we're finished marking it up.  However,
 35759                                  ;	we can't just mark it busy because we may get blown out of our open
 35760                                  ;	by INT24 and leave the thing orphaned.	To solve this we mark it
 35761                                  ;	"allocation in progress" by setting SFT_REF_COUNT = -1.  If we see
 35762                                  ;	an SFT with this value we look to see if it belongs to this user
 35763                                  ;	and process.  If it does belong to us then it must be an orphan
 35764                                  ;	and we reclaim it.
 35765                                  ;
 35766                                  ;	BUGBUG - improve the performance. I guess it's smaller to call SFFromSFN
 35767                                  ;		over and over, but we could at least set a high water mark...
 35768                                  ;		cause an N^2 loop calling slow SFFromSFN is real slow, too slow
 35769                                  ;		even though this is not a frequently called routine - jgl
 35770                                  ;
 35771                                  ;	ENTRY	(ss) = DOSDATA
 35772                                  ;	EXIT	'C' clear if no error
 35773                                  ;		  (bx) = SFN
 35774                                  ;		  (es:di) = pointer to SFT
 35775                                  ;		  es:[di].SFT_REF_COUNT = -1
 35776                                  ;		'C' set if error
 35777                                  ;		  (al) = error code
 35778                                  ;	USES	bx, di, es, Flags
 35779                                  ;----------------------------------------------------------------------------
 35780                                  
 35781                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 35782                                  	; DOSCODE:A682h (MSDOS 5.0 MSDOS.SYS)
 35783                                  
 35784                                  SFNFree:
 35785                                  	; 12/08/2018
 35786                                  	; 05/08/2018 - Retro DOS v3.0
 35787                                  	;
 35788                                  	; MSDOS 6.0
 35789 00006733 50                      	push	ax
 35790 00006734 31DB                    	xor	bx,bx			; (bx) = SFN to consider
 35791                                  sfnf5:	
 35792 00006736 53                      	push	bx
 35793 00006737 E8BCFF                  	call	SFFromSFN		; get the potential handle
 35794 0000673A 5B                      	pop	bx
 35795 0000673B 723A                    	jc	short sfnf95		; no more free SFNs
 35796 0000673D 26833D00                	cmp	word [ES:DI],0
 35797                                  	;cmp	word [ES:DI+SF_ENTRY.sf_Ref_Count],0 ; free?
 35798 00006741 741D                    	je	short sfnf20			; yep, got one
 35799                                  	
 35800                                  	;cmp	word [es:di],0FFFFh ; -1
 35801 00006743 26833DFF                	cmp	word [ES:DI],sf_busy
 35802                                  	;cmp	word [ES:DI+SF_ENTRY.sf_ref_count],sf_busy
 35803 00006747 7403                    	je	short sfnf10		; special busy mark
 35804                                  sfnf7:	
 35805 00006749 43                      	inc	bx			; try the next one
 35806 0000674A EBEA                    	jmp	short sfnf5
 35807                                  
 35808                                  ;	The SFT has the special "busy" mark; if it belongs to us then
 35809                                  ;	it was abandoned during a earlier call and we can use it.
 35810                                  ;
 35811                                  ;	(bx)	= SFN
 35812                                  ;	(es:di) = pointer to SFT
 35813                                  ;	(TOS)	= caller's (ax)
 35814                                  
 35815                                  sfnf10:	
 35816 0000674C 36A1[3E03]              	mov	ax,[SS:USER_ID]
 35817                                  	;cmp	[es:di+2Fh],ax
 35818 00006750 2639452F                	cmp	[ES:DI+SF_ENTRY.sf_UID],ax
 35819 00006754 75F3                    	jnz	short sfnf7		; not ours
 35820 00006756 36A1[3C03]              	mov	ax,[SS:PROC_ID]
 35821                                  	;cmp	[es:di+31h],ax
 35822 0000675A 26394531                	cmp	[ES:DI+SF_ENTRY.sf_PID],ax
 35823 0000675E 75E9                    	jnz	short sfnf7		; can't use this one, try the next
 35824                                  
 35825                                  ;	We have an SFT to allocate
 35826                                  ;
 35827                                  ;	(bx)	= SFN
 35828                                  ;	(es:di) = pointer to SFT
 35829                                  ;	(TOS)	= caller's (ax)
 35830                                  
 35831                                  sfnf20:
 35832                                  	; cf = 0 ;; Retro DOS v3.0
 35833                                  
 35834                                  	;mov	word [es:di],0FFFFh
 35835 00006760 26C705FFFF              	mov	word [ES:DI],sf_busy
 35836                                  					; make sure that this is allocated
 35837                                  	;mov	word [ES:DI+SF_ENTRY.sf_ref_count],sf_busy
 35838                                  
 35839 00006765 36A1[3E03]              	mov	ax,[SS:USER_ID]
 35840                                  	;mov	[es:di+2Fh],ax
 35841 00006769 2689452F                	mov	[ES:DI+SF_ENTRY.sf_UID],ax
 35842 0000676D 36A1[3C03]              	mov	ax,[SS:PROC_ID]
 35843                                  	;mov	[es:di+31h],ax
 35844 00006771 26894531                	mov	[ES:DI+SF_ENTRY.sf_PID],ax
 35845                                  sfnf21: ;; Retro DOS v3.0
 35846                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35847                                  	;pop	ax
 35848                                  	;;clc
 35849                                  	;retn				; return with no error
 35850                                  	; 17/12/2022
 35851 00006775 58                      	pop	ax
 35852                                  	;clc
 35853 00006776 C3                      	retn
 35854                                  
 35855                                  ;**	Error - no more free SFNs
 35856                                  ;
 35857                                  ;	'C' set
 35858                                  ;	(TOS) = saved ax
 35859                                  
 35860                                  sfnf95: 
 35861 00006777 58                      	pop	ax
 35862                                  	;mov	al,4
 35863 00006778 B004                    	mov	al,error_too_many_open_files
 35864 0000677A C3                      	retn				; return with 'C' and error
 35865                                  
 35866                                  ;============================================================================
 35867                                  ; HANDLE.ASM, MSDOS 6.0, 1991
 35868                                  ;============================================================================
 35869                                  ; 13/07/2018 - Retro DOS v3.0
 35870                                  ; 20/05/2019 - Retro DOS v4.0
 35871                                  
 35872                                  ; DOSCODE:A72Bh (MSDOS 6.21, MSDOS.SYS)
 35873                                  
 35874                                  ;	BREAK <$Close - return a handle to the system>
 35875                                  ;----------------------------------------------------------------------------
 35876                                  ;
 35877                                  ;**	$Close - Close a file Handle
 35878                                  ;
 35879                                  ;	BUGBUG - close gets called a LOT with invalid handles - sizzle that
 35880                                  ;		path
 35881                                  ;
 35882                                  ;	Assembler usage:
 35883                                  ;	    MOV     BX, handle
 35884                                  ;	    MOV     AH, Close
 35885                                  ;	    INT     int_command
 35886                                  ;
 35887                                  ;	ENTRY	(bx) = handle
 35888                                  ;	EXIT	<normal INT21 return convention>
 35889                                  ;	USES	all
 35890                                  ;
 35891                                  ;----------------------------------------------------------------------------
 35892                                  
 35893                                  ; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 35894                                  ; DOSCODE:A6CBh (MSDOS 5.0 MSDOS.SYS)
 35895                                  
 35896                                  _$CLOSE:
 35897                                  ;	Grab the SFT pointer from the JFN.
 35898                                  
 35899 0000677B E85A02                  	call	CheckOwner		; get system file entry
 35900 0000677E 722B                    	jc	short CloseError	; error return
 35901 00006780 16                      	push	ss
 35902 00006781 1F                      	pop	ds			; For DOS_CLOSE
 35903 00006782 893E[9E05]              	MOV	[THISSFT],DI		; save offset of pointer
 35904 00006786 8C06[A005]              	MOV	[THISSFT+2],ES		; save segment value
 35905                                  
 35906                                  ; DS:SI point to JFN table entry.
 35907                                  ; ES:DI point to SFT
 35908                                  ;
 35909                                  ; We now examine the user's JFN entry; If the file was a 70-mode file (network
 35910                                  ; FCB, we examine the ref count on the SFT;  if it was 1, we free the JFN.
 35911                                  ; If the file was not a net FCB, we free the JFN too.
 35912                                  
 35913                                  	;CMP	word [ES:DI+SF_ENTRY.sf_ref_count],1
 35914 0000678A 26833D01                	cmp	word [ES:DI],1		; will the SFT become free?
 35915 0000678E 740A                    	jz	short FreeJFN 		; yes, free JFN anyway.
 35916                                  	;mov	al,[ES:DI+2]
 35917 00006790 268A4502                	MOV	AL,[ES:DI+SF_ENTRY.sf_mode]
 35918                                  	;and	al,0F0h
 35919 00006794 24F0                    	AND	AL,SHARING_MASK
 35920                                  	;cmp	al,70h
 35921 00006796 3C70                    	CMP	AL,SHARING_NET_FCB
 35922 00006798 7407                    	JZ	short PostFree		; 70-mode and big ref count => free it
 35923                                  
 35924                                  ; The JFN must be freed.  Get the pointer to it and replace the contents with
 35925                                  ; -1.
 35926                                  
 35927                                  FreeJFN:
 35928 0000679A E826FF                  	call	pJFNFromHandle		;   d = pJFN (handle);
 35929 0000679D 26C605FF                	MOV	BYTE [ES:DI],0FFh	; release the JFN
 35930                                  PostFree:
 35931                                  
 35932                                  ; ThisSFT is correctly set, we have DS = DOSDATA. Looks OK for a DOS_CLOSE!
 35933                                  
 35934 000067A1 E8F6C7                  	call	DOS_CLOSE
 35935                                  
 35936                                  ; DOS_Close may return an error. If we see such an error, we report it but
 35937                                  ; the JFN stays closed because DOS_Close always frees the SFT!
 35938                                  
 35939 000067A4 7205                    	JC	short CloseError
 35940                                  	;mov	ah,3Eh
 35941 000067A6 B43E                    	MOV	AH,CLOSE		; MZ Bogus multiplan fix
 35942                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35943                                  CloseOk:
 35944 000067A8 E99F9E                  	jmp	SYS_RET_OK
 35945                                  CloseError:
 35946 000067AB E9A59E                  	jmp	SYS_RET_ERR
 35947                                  
 35948                                  ;	BREAK <$Commit - commit the file>
 35949                                  ;----------------------------------------------------------------------------
 35950                                  ;
 35951                                  ;**	$Commit - Commit a File
 35952                                  ;
 35953                                  ;	$Commit "commits" a file to disk - all of it's buffers are
 35954                                  ;	flushed out.  BUGBUG - I'm pretty sure that $Commit doesn't update
 35955                                  ;	the directory entry, etc., so this commit is pretty useless. check
 35956                                  ;	and fix this!! jgl
 35957                                  ;
 35958                                  ;	Assembler usage:
 35959                                  ;	    MOV     BX, handle
 35960                                  ;	    MOV     AH, Commit
 35961                                  ;	    INT     int_command
 35962                                  ;
 35963                                  ;	ENTRY	(bx) = handle
 35964                                  ;	EXIT	none
 35965                                  ;	USES	all
 35966                                  ;;----------------------------------------------------------------------------
 35967                                  
 35968                                  _$COMMIT:
 35969                                  ;	Grab the SFT pointer from the JFN.
 35970                                  
 35971 000067AE E82702                  	call	CheckOwner		; get system file entry
 35972 000067B1 7213                    	JC	short CommitError	; error return
 35973 000067B3 16                      	push	ss
 35974 000067B4 1F                      	pop	ds			; For DOS_COMMIT
 35975 000067B5 893E[9E05]              	MOV	[THISSFT],DI		; save offset of pointer
 35976 000067B9 8C06[A005]              	MOV	[THISSFT+2],ES		; save segment value
 35977                                  
 35978                                  ;	ThisSFT is correctly set, we have DS = DOSDATA. Looks OK for a DOS_COMMIT
 35979                                  ;
 35980                                  ;	ES:DI point to SFT
 35981                                  
 35982 000067BD E828C9                  	call	DOS_COMMIT
 35983 000067C0 7204                    	JC	short CommitError
 35984                                  	; 07/12/2022
 35985                                  	;jc	short CloseError
 35986                                  	;mov	ah,68h
 35987 000067C2 B468                    	MOV	AH,COMMIT
 35988                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35989                                  	;jmp	SYS_RET_OK
 35990                                  CommitOk:
 35991 000067C4 EBE2                    	jmp	short CloseOk	
 35992                                  
 35993                                  CommitError:
 35994                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 35995                                  	;jmp	SYS_RET_ERR
 35996 000067C6 EBE3                    	jmp	short CloseError
 35997                                  
 35998                                  ;	BREAK <$ExtHandle - extend handle count>
 35999                                  
 36000                                  ;**	$ExtHandle - Extend Handle Count
 36001                                  ;----------------------------------------------------------------------------
 36002                                  ;	Assembler usage:
 36003                                  ;	    MOV     BX, Number of Opens Allowed (MAX=65534;66535 is
 36004                                  ;	    MOV     AX, 6700H			 reserved to mark SFT
 36005                                  ;	    INT     int_command 		 busy )
 36006                                  ;
 36007                                  ;	ENTRY	(bx) = new number of handles
 36008                                  ;	EXIT	'C' clear if OK
 36009                                  ;		'C' set iff err
 36010                                  ;		  (ax) = error code
 36011                                  ;			 AX = error_not_enough_memory
 36012                                  ;			      error_too_many_open_files
 36013                                  ;	USES	all
 36014                                  ;----------------------------------------------------------------------------
 36015                                  
 36016                                  _$ExtHandle:
 36017 000067C8 31ED                    	XOR	BP,BP			; 0: enlarge   1: shrink  2:psp
 36018                                  	;cmp	bx,20
 36019 000067CA 83FB14                  	CMP	BX,FILPERPROC
 36020 000067CD 7303                    	JAE	short exth2		; Don't set less than FilPerProc no
 36021 000067CF BB1400                  	MOV	BX,FILPERPROC
 36022                                  exth2:	
 36023 000067D2 368E06[3003]            	MOV	ES,[ss:CurrentPDB]	; get user process data block;smr;SS Override
 36024                                  	;mov	cx,[ES:32h]
 36025 000067D7 268B0E3200              	MOV	CX,[ES:PDB.JFN_Length]	; get number of handle allowed
 36026 000067DC 39CB                    	CMP	BX,CX			; the requested == current
 36027 000067DE 7455                    	JE	short ok_done 		; yes and exit
 36028 000067E0 7722                    	JA	short larger		; go allocate new table
 36029                                  
 36030                                  ;	We're going to shrink the # of handles available
 36031                                  
 36032 000067E2 BD0100                  	MOV	BP,1			; shrink
 36033                                  	;mov	ds,[ES:36h]
 36034 000067E5 268E1E3600              	MOV	DS,[ES:PDB.JFN_Pointer+2] ;
 36035 000067EA 89DE                    	MOV	SI,BX			;
 36036 000067EC 29D9                    	SUB	CX,BX			; get difference
 36037                                  
 36038                                  ;	BUGBUG - code a SCASB here, should be a bit smaller
 36039                                  chck_handles:
 36040 000067EE 803CFF                  	CMP	BYTE [SI],-1		; scan through handles to ensure close
 36041 000067F1 753D                    	JNZ	short too_many_files	; status
 36042 000067F3 46                      	INC	SI
 36043 000067F4 E2F8                    	LOOP	chck_handles
 36044 000067F6 83FB14                  	CMP	BX,FILPERPROC		; = 20
 36045 000067F9 7709                    	JA	short larger		; no
 36046                                  
 36047 000067FB BD0200                  	MOV	BP,2			; psp
 36048                                  	;mov	di,24
 36049 000067FE BF1800                  	MOV	DI,PDB.JFN_TABLE	; es:di -> jfn table in psp
 36050 00006801 53                      	PUSH	BX
 36051 00006802 EB1D                    	JMP	short movhandl
 36052                                  
 36053                                  larger:
 36054 00006804 83FBFF                  	CMP	BX,-1			; 65535 is not allowed
 36055 00006807 747F                    	JZ	short invalid_func	; 10/08/2018
 36056 00006809 F8                      	CLC
 36057 0000680A 53                      	PUSH	BX			; save requested number
 36058 0000680B 83C30F                  	ADD	BX,0FH			; adjust to paragraph boundary
 36059 0000680E B104                    	MOV	CL,4
 36060                                  	;ror	bx,cl			; MSDOS 3.3
 36061 00006810 D3DB                    	RCR	BX,CL			; DOS 4.00 fix		;AC000;
 36062 00006812 81E3FF1F                	AND	BX,1FFFH		; clear most 3 bits
 36063                                  
 36064 00006816 55                      	PUSH	BP
 36065 00006817 E8DCFA                  	call	_$ALLOC			; allocate memory
 36066 0000681A 5D                      	POP	BP
 36067 0000681B 7266                    	JC	short no_memory		; not enough meory
 36068                                  
 36069 0000681D 8EC0                    	MOV	ES,AX			; es:di points to new table memory
 36070 0000681F 31FF                    	XOR	DI,DI
 36071                                  movhandl:
 36072 00006821 368E1E[3003]            	MOV	DS,[ss:CurrentPDB] 	; get user PDB address	;smr;SS Override
 36073                                  
 36074 00006826 F7C50300                	test	BP,3			; enlarge ?
 36075 0000682A 740C                    	JZ	short enlarge 		; yes
 36076 0000682C 59                      	POP	CX			; cx = the amount you shrink
 36077 0000682D 51                      	PUSH	CX
 36078 0000682E EB0C                    	JMP	short copy_hand
 36079                                  
 36080                                  ;	Done.  'C' clear
 36081                                  
 36082                                  ; 17/12/2022
 36083                                  ;ok_done:
 36084                                  ;	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36085                                  ;	;jmp	short CommitOk
 36086                                  ;	; 17/12/2022
 36087                                  ;	jmp	SYS_RET_OK
 36088                                  
 36089                                  too_many_files:
 36090                                  	;mov	al,4
 36091 00006830 B004                    	MOV	AL,error_too_many_open_files
 36092                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36093                                  	;jmp	SYS_RET_ERR
 36094                                  CommitErrorj:
 36095                                  	;jmp	short CommitError
 36096                                  	; 17/12/2022
 36097 00006832 E91E9E                  	jmp	SYS_RET_ERR
 36098                                  
 36099                                  ; 17/12/2022 
 36100                                  ok_done:
 36101                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36102                                  	;jmp	short CommitOk
 36103                                  	; 17/12/2022
 36104 00006835 E9129E                  	jmp	SYS_RET_OK
 36105                                  
 36106                                  enlarge:
 36107                                  	;mov	cx,[32h]
 36108 00006838 8B0E3200                	MOV	CX,[PDB.JFN_Length]	; get number of old handles
 36109                                  copy_hand:
 36110 0000683C 89CA                    	MOV	DX,CX
 36111                                  	;lds	si,[34h]
 36112 0000683E C5363400                	LDS	SI,[PDB.JFN_Pointer]	; get old table pointer
 36113 00006842 F3A4                    	REP	MOVSB			; copy infomation to new table
 36114 00006844 59                      	POP	CX			; get new number of handles
 36115 00006845 51                      	PUSH	CX			; save it again
 36116 00006846 29D1                    	SUB	CX,DX			; get the difference
 36117 00006848 B0FF                    	MOV	AL,-1			; set availability to handles
 36118 0000684A F3AA                    	REP	STOSB
 36119 0000684C 368E1E[3003]            	MOV	DS,[ss:CurrentPDB] 	; get user process data block;smr;SS Override
 36120                                  	;cmp	word [34h],0
 36121 00006851 833E340000              	CMP	WORD [PDB.JFN_Pointer],0 ; check if original table pointer
 36122 00006856 750D                    	JNZ	short update_info	; yes, go update PDB entries
 36123 00006858 55                      	PUSH	BP
 36124 00006859 1E                      	PUSH	DS			; save old table segment
 36125 0000685A 06                      	PUSH	ES			; save new table segment
 36126 0000685B 8E063600                	MOV	ES,[PDB.JFN_Pointer+2]	; get old table segment
 36127 0000685F E80EFC                  	call	_$DEALLOC		; deallocate old table meomory
 36128 00006862 07                      	POP	ES			; restore new table segment
 36129 00006863 1F                      	POP	DS			; restore old table segment
 36130 00006864 5D                      	POP	BP
 36131                                  
 36132                                  update_info:
 36133 00006865 F7C50200                	test	BP,2			; psp?
 36134 00006869 7408                    	JZ	short non_psp 		; no
 36135                                  	;mov	word [34h],18h ; 24
 36136 0000686B C70634001800            	MOV	WORD [PDB.JFN_Pointer],PDB.JFN_TABLE ; restore
 36137 00006871 EB06                    	JMP	short final
 36138                                  non_psp:
 36139                                  	;mov	word [34h],0
 36140 00006873 C70634000000            	MOV	WORD [PDB.JFN_Pointer],0 ; new table pointer offset always 0
 36141                                  final:
 36142                                  	;mov	[36h],es	
 36143 00006879 8C063600                	MOV	[PDB.JFN_Pointer+2],ES	; update table pointer segment
 36144                                  	;pop	word [32h]
 36145 0000687D 8F063200                	POP	word [PDB.JFN_Length]	; restore new number of handles
 36146                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36147                                  	;jmp	SYS_RET_OK
 36148                                  ok_done_j:
 36149 00006881 EBB2                    	jmp	short ok_done
 36150                                  
 36151                                  no_memory:
 36152 00006883 5B                      	POP	BX			; clean stack
 36153                                  	;mov	al,8
 36154 00006884 B008                    	MOV	AL,error_not_enough_memory
 36155                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36156                                  	;jmp	SYS_RET_ERR
 36157                                  CommitErrorj2:
 36158 00006886 EBAA                    	jmp	short CommitErrorj
 36159                                  
 36160                                  invalid_func:
 36161                                  	;mov	al,1
 36162 00006888 B001                    	MOV	AL,error_invalid_function
 36163                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36164                                  	;jmp	SYS_RET_ERR
 36165                                  CommitErrorj3:
 36166                                  	;jmp	short CommitErrorj2
 36167                                  	; 17/12/2022
 36168 0000688A EBA6                    	jmp	short CommitErrorj
 36169                                  
 36170                                  ; 20/05/2019 - Retro DOS v4.0
 36171                                  ; DOSCODE:A83Ah (MSDOS 6.21, MSDOS.SYS)
 36172                                  
 36173                                  ; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 36174                                  ; DOSCODE:A7DAh (MSDOS 5.0 MSDOS.SYS)
 36175                                  
 36176                                  ;	BREAK <$READ - Read from a file handle>
 36177                                  ;----------------------------------------------------------------------------
 36178                                  ;
 36179                                  ;**	$Read - Read from a File Handle
 36180                                  ;
 36181                                  ;   Assembler usage:
 36182                                  ;
 36183                                  ;	LDS	DX, buf
 36184                                  ;	MOV	CX, count
 36185                                  ;	MOV	BX, handle
 36186                                  ;	MOV	AH, Read
 36187                                  ;	INT	int_command
 36188                                  ;	  AX has number of bytes read
 36189                                  ;
 36190                                  ;	ENTRY	(bx) = file handle
 36191                                  ;		(cx) = byte count
 36192                                  ;		(ds:dx) = buffer address
 36193                                  ;	EXIT	Through system call return so that to user:
 36194                                  ;		  'C' clear if OK
 36195                                  ;		    (ax) = bytes read
 36196                                  ;		  'C' set if error
 36197                                  ;		    (ax) = error code
 36198                                  ;
 36199                                  ;----------------------------------------------------------------------------
 36200                                  
 36201                                  _$READ:
 36202 0000688C BE[4133]                	MOV	SI,DOS_READ
 36203                                  ReadDo:
 36204 0000688F E831FE                  	call	pJFNFromHandle
 36205 00006892 7208                    	JC	short ReadError
 36206                                  
 36207 00006894 268A05                  	MOV	AL,[ES:DI]
 36208 00006897 E83E01                  	call	CheckOwner		; get the handle
 36209 0000689A 7303                    	JNC	short ReadSetup		; no errors do the operation
 36210                                  
 36211                                  ;	Have an error. 'C' set
 36212                                  
 36213                                  ReadError:
 36214                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36215                                  	;;jmp	SYS_RET_ERR		; go to error traps
 36216                                  	;jmp	short CommitErrorj3
 36217                                  	; 17/12/2022
 36218 0000689C E9B49D                  	jmp	SYS_RET_ERR
 36219                                  
 36220                                  ReadSetup:
 36221 0000689F 36893E[9E05]            	MOV	[ss:THISSFT],DI		; save offset of pointer;smr;SS Override
 36222 000068A4 368C06[A005]            	MOV	[ss:THISSFT+2],ES	; save segment value	;smr;SS Override
 36223                                  	; 20/05/2019 - Retro DOS v4.0
 36224                                  	; MSDOS 6.0 
 36225                                  ;; Extended Open
 36226                                  	;test	byte [es:di+3],20h
 36227 000068A9 26F6450320              	test	byte [ES:DI+SF_ENTRY.sf_mode+1],(INT_24_ERROR>>8)
 36228                                  						 ;AN000;;EO. need i24
 36229 000068AE 7406                    	JZ	short needi24 		     	 ;AN000;;EO. yes
 36230 000068B0 36800E[F605]02          	OR	byte [ss:EXTOPEN_ON],EXT_OPEN_I24_OFF ; 2
 36231                                  					;AN000;;EO. set it off;smr;SS Override
 36232                                  needi24:				;AN000;
 36233                                  ;; Extended Open
 36234 000068B6 36FF36[2C03]            	push	word [SS:DMAADD]
 36235 000068BB 36FF36[2E03]            	push	word [SS:DMAADD+2]	;smr;SS Override
 36236                                  
 36237                                  ;;;;;	BAD SPOT FOR 286!!! SEGMENT ARITHMETIC!!!
 36238                                  
 36239                                  	; 26/07/2019
 36240                                  
 36241                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36242                                  	;
 36243                                  	; (It is not necessary to call 'Align_Buffer' proc here/below because
 36244                                  	; there is not another caller; it is better to put the code in this proc
 36245                                   	; here instead of calling it as a subroutine; but I have modified code
 36246                                  	; here for MSDOS 5.0 MSDOS.SYS address compatibility)
 36247                                  
 36248                                  	; MSDOS 6.0
 36249 000068C0 E81300                  	CALL	Align_Buffer		;AN000;MS. align user's buffer
 36250                                  	
 36251                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36252                                  	; MSDOS 3.3
 36253                                  	;MOV	BX,DX			; copy offset
 36254                                  	;push	cx			; don't stomp on count
 36255                                  	;MOV	CL,4			; bits to shift bytes->para
 36256                                  	;SHR	BX,CL			; get number of paragraphs
 36257                                  	;pop	cx			; get count back
 36258                                  	;MOV	AX,DS			; get original segment
 36259                                  	;ADD	AX,BX			; get new segment
 36260                                  	;MOV	DS,AX			; in seg register
 36261                                  	;AND	DX,0Fh			; normalize offset
 36262                                  	;MOV	[ss:DMAADD],DX		; use user DX as offset	;smr;SS Override
 36263                                  	;MOV	[ss:DMAADD+2],DS 	; use user DS as segment for DMA
 36264                                  						;smr;SS Override
 36265                                  ;;;;;	END BAD SPOT FOR 286!!! SEGMENT ARITHMETIC!!!
 36266                                  	
 36267 000068C3 16                      	push	ss			; go for DOS addressability
 36268 000068C4 1F                      	pop	ds
 36269                                  
 36270 000068C5 FFD6                    	CALL	SI ; DOS_READ		; indirect call to operation
 36271                                  
 36272 000068C7 8F06[2E03]              	pop	word [DMAADD+2]
 36273 000068CB 8F06[2C03]              	pop	word [DMAADD]
 36274                                  	;JNC	short READ_OK		;AN002;
 36275                                  	;JMP	short ReadError		;AN002; if error, say bye bye
 36276                                  	; 17/12/2022
 36277 000068CF 72CB                    	jc	short ReadError
 36278                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36279                                  	;jnc	short READ_OK		;AN002;
 36280                                  	;jmp	short ReadError
 36281                                  
 36282                                  READ_OK:
 36283 000068D1 89C8                    	MOV	AX,CX			; get correct return in correct reg
 36284                                  Read_Okj:
 36285                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36286                                  	;;jmp	SYS_RET_OK		; successful return
 36287                                  	;jmp	short ok_done_j
 36288                                  	; 17/12/2022
 36289 000068D3 E9749D                  	jmp	SYS_RET_OK
 36290                                  
 36291                                  ; 13/07/2018 - Retro DOS v3.0
 36292                                  
 36293                                  ;----------------------------------------------------------------------------
 36294                                  
 36295                                  ;   Input: DS:DX points to user's buffer addr
 36296                                  ;   Function: rearrange segment and offset for READ/WRITE buffer
 36297                                  ;   Output: [DMAADD] set
 36298                                  
 36299                                  ; 20/05/2019 - Retro DOS v4.0
 36300                                  ; 26/07/2019
 36301                                  ;	; MSDOS 6.0
 36302                                  ;Align_Buffer:
 36303                                  ;	MOV	BX,DX			; copy offset
 36304                                  ;	push	cx			; don't stomp on count
 36305                                  ;	MOV	CL,4			; bits to shift bytes->para
 36306                                  ;	SHR	BX,CL			; get number of paragraphs
 36307                                  ;	pop	cx			; get count back
 36308                                  ;	MOV	AX,DS			; get original segment
 36309                                  ;	ADD	AX,BX			; get new segment
 36310                                  ;	MOV	DS,AX			; in seg register
 36311                                  ;	AND	DX,0Fh			; normalize offset
 36312                                  ;	MOV	[ss:DMAADD],DX		; use user DX as offset	;smr;SS Override
 36313                                  ;	MOV	[ss:DMAADD+2],DS 	; use user DS as segment for DMA
 36314                                  ;						;smr;SS Override
 36315                                  ;	retn
 36316                                  
 36317                                  ; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36318                                  Align_Buffer:
 36319 000068D6 89D3                    	MOV	BX,DX			; copy offset
 36320 000068D8 51                      	push	cx			; don't stomp on count
 36321 000068D9 B104                    	MOV	CL,4			; bits to shift bytes->para
 36322 000068DB D3EB                    	SHR	BX,CL			; get number of paragraphs
 36323 000068DD 59                      	pop	cx			; get count back
 36324 000068DE 8CD8                    	MOV	AX,DS			; get original segment
 36325 000068E0 01D8                    	ADD	AX,BX			; get new segment
 36326 000068E2 8ED8                    	MOV	DS,AX			; in seg register
 36327 000068E4 83E20F                  	AND	DX,0Fh			; normalize offset
 36328 000068E7 368916[2C03]            	MOV	[ss:DMAADD],DX		; use user DX as offset	;smr;SS Override
 36329 000068EC 368C1E[2E03]            	MOV	[ss:DMAADD+2],DS 	; use user DS as segment for DMA
 36330                                  						;smr;SS Override
 36331 000068F1 C3                      	retn
 36332                                  
 36333                                  ; 20/05/2019 - Retro DOS v4.0
 36334                                  ; DOSCODE:A8A0h (MSDOS 6.21, MSDOS.SYS)
 36335                                  
 36336                                  ; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 36337                                  ; DOSCODE:A840h (MSDOS 5.0 MSDOS.SYS)
 36338                                  
 36339                                  ;BREAK <$WRITE - write to a file handle>
 36340                                  ;----------------------------------------------------------------------------
 36341                                  ;
 36342                                  ;   Assembler usage:
 36343                                  ;	    LDS     DX, buf
 36344                                  ;	    MOV     CX, count
 36345                                  ;	    MOV     BX, handle
 36346                                  ;	    MOV     AH, Write
 36347                                  ;	    INT     int_command
 36348                                  ;	  AX has number of bytes written
 36349                                  ;   Errors:
 36350                                  ;	    AX = write_invalid_handle
 36351                                  ;	       = write_access_denied
 36352                                  ;
 36353                                  ;   Returns in register AX
 36354                                  ;
 36355                                  ;----------------------------------------------------------------------------
 36356                                  
 36357                                  _$WRITE:
 36358 000068F2 BE[6A35]                	MOV	SI,DOS_WRITE
 36359 000068F5 EB98                    	JMP	short ReadDo
 36360                                  
 36361                                  ;BREAK <$LSEEK - move r/w pointer>
 36362                                  ;----------------------------------------------------------------------------
 36363                                  ;
 36364                                  ;   Assembler usage:
 36365                                  ;	    MOV     DX, offsetlow
 36366                                  ;	    MOV     CX, offsethigh
 36367                                  ;	    MOV     BX, handle
 36368                                  ;	    MOV     AL, method
 36369                                  ;	    MOV     AH, LSeek
 36370                                  ;	    INT     int_command
 36371                                  ;	  DX:AX has the new location of the pointer
 36372                                  ;   Error returns:
 36373                                  ;	    AX = error_invalid_handle
 36374                                  ;	       = error_invalid_function
 36375                                  ;   Returns in registers DX:AX
 36376                                  ;
 36377                                  ;----------------------------------------------------------------------------
 36378                                  
 36379                                  ; 21/05/2019 - Retro DOS v4.0
 36380                                  ; DOSCODE:A8A5h (MSDOS 6.21, MSDOS.SYS)
 36381                                  
 36382                                  ; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 36383                                  ; DOSCODE:A845h (MSDOS 5.0 MSDOS.SYS)
 36384                                  
 36385                                  _$LSEEK:
 36386 000068F7 E8DE00                  	call	CheckOwner		; get system file entry
 36387                                  
 36388                                  	; 17/12/2022
 36389                                  ;LSeekError:
 36390                                  	;JNC	short CHKOWN_OK		;AN002;
 36391                                  	;JMP	short ReadError		;AN002; error return
 36392                                  	; 17/12/2022
 36393                                  	; 02/06/2019
 36394 000068FA 72A0                    	jc	short ReadError
 36395                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36396                                  	;JNC	short CHKOWN_OK		;AN002;
 36397                                  	;JMP	short ReadError		;AN002; error return
 36398                                  
 36399                                  CHKOWN_OK:
 36400                                  					;AN002;
 36401 000068FC 3C02                    	CMP	AL,2			; is the seek value correct?
 36402 000068FE 760A                    	JBE	short LSeekDisp		; yes, go dispatch
 36403                                  	;mov	byte [ss:EXTERR_LOCUS],1 
 36404 00006900 36C606[2303]01          	MOV	byte [ss:EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus
 36405                                  					;smr;SS Override
 36406                                  	;mov	al,1
 36407 00006906 B001                    	mov	al,error_invalid_function ; invalid method
 36408                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36409                                  LSeekError2:
 36410 00006908 EB92                    	jmp	short ReadError
 36411                                  
 36412                                  LSeekDisp:
 36413 0000690A 3C01                    	CMP	AL,1			; best way to dispatch; check middle
 36414 0000690C 720A                    	JB	short LSeekStore	; just store CX:DX
 36415 0000690E 771B                    	JA	short LSeekEOF		; seek from end of file
 36416                                  	;add	dx,[es:di+21]
 36417 00006910 26035515                	ADD	DX,[ES:DI+SF_ENTRY.sf_position]
 36418                                  	;adc	cx,[es:di+23]
 36419 00006914 26134D17                	ADC	CX,[ES:DI+SF_ENTRY.sf_position+2]
 36420                                  LSeekStore:
 36421 00006918 89C8                    	MOV	AX,CX			; AX:DX
 36422 0000691A 92                      	XCHG	AX,DX			; DX:AX is the correct value
 36423                                  LSeekSetpos:
 36424                                  	;mov	[es:di+21],ax
 36425 0000691B 26894515                	MOV	[ES:DI+SF_ENTRY.sf_position],AX
 36426                                  	;mov	[es:di+23],dx
 36427 0000691F 26895517                	MOV	[ES:DI+SF_ENTRY.sf_position+2],DX
 36428 00006923 E86A9B                  	call	Get_User_Stack
 36429                                  	;mov	[si+6],dx
 36430 00006926 895406                  	MOV	[SI+user_env.user_DX],DX ; return DX:AX
 36431                                  	;jmp	SYS_RET_OK		; successful return
 36432                                  	; 25/06/2019
 36433                                  	;jmp	SYS_RET_OK_clc
 36434                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36435                                  	;jmp	SYS_RET_OK_clc
 36436                                  LSeekOk:
 36437 00006929 EBA8                    	jmp     short Read_Okj
 36438                                  
 36439                                  LSeekEOF:
 36440                                  	;;test	word [es:di+5],8000h
 36441                                  	;test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 36442                                  	; 21/05/2019 - Retro DOS v4.0
 36443 0000692B 26F6450680              	test	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
 36444 00006930 750A                    	JNZ	short Check_LSeek_Mode	; Is Net
 36445                                  LOCAL_LSeek:
 36446                                  	;add	dx,[es:di+17]
 36447 00006932 26035511                	ADD	DX,[ES:DI+SF_ENTRY.sf_size]
 36448                                  	;adc	cx,[es:di+19]
 36449 00006936 26134D13                	ADC	CX,[ES:DI+SF_ENTRY.sf_size+2]
 36450 0000693A EBDC                    	JMP	short LSeekStore	; go and set the position
 36451                                  
 36452                                  Check_LSeek_Mode:
 36453                                  	;;test	word [es:di+2],8000h
 36454                                  	;test	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB
 36455                                  	; 21/05/2019
 36456 0000693C 26F6450380              	test	byte [ES:DI+SF_ENTRY.sf_mode+1],(sf_isFCB>>8)
 36457 00006941 75EF                    	JNZ	short LOCAL_LSeek	; FCB treated like local file
 36458                                  	;mov	ax,[es:di+2]
 36459 00006943 268B4502                	MOV	AX,[ES:DI+SF_ENTRY.sf_mode]
 36460                                  	;and	ax, 0F0h
 36461 00006947 25F000                  	AND	AX,SHARING_MASK
 36462                                  	;cmp	ax,40h
 36463 0000694A 83F840                  	CMP	AX,SHARING_DENY_NONE
 36464 0000694D 7405                    	JZ	short NET_LSEEK		; LSEEK exported in this mode
 36465                                  	;cmp	ax,30h
 36466 0000694F 83F830                  	CMP	AX,SHARING_DENY_READ
 36467 00006952 75DE                    	JNZ	short LOCAL_LSeek	; Treated like local Lseek
 36468                                  NET_LSEEK:
 36469                                  ;	JMP	short LOCAL_LSeek
 36470                                  ; REMOVE ABOVE INSTRUCTION TO ENABLE DCR 142
 36471                                  	;CallInstall Net_Lseek,MultNET,33
 36472                                  	;JNC	short LSeekSetPos
 36473                                  
 36474 00006954 B82111                  	mov     ax,1121h
 36475 00006957 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - SEEK FROM END OF REMOTE FILE
 36476                                  			; CX:DX = offset (in bytes) from end
 36477                                  			; ES:DI -> SFT, SFT DPB field -> DPB of drive with file
 36478                                  			; SS = DOS CS
 36479                                  			; Return: CF set on error
 36480                                  			; CF clear if successful, DX:AX = new file position
 36481 00006959 73C0                    	jnb     short LSeekSetpos
 36482                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36483                                  	;jmp	SYS_RET_ERR
 36484                                  ;LSeekError3:
 36485                                  	; 17/12/2022
 36486                                  LSeekError:
 36487                                  	;jmp	short LSeekError2
 36488                                  DupErr:	; 17/12/2022
 36489 0000695B E9F59C                  	jmp	SYS_RET_ERR
 36490                                  
 36491                                  ;BREAK <FileTimes - modify write times on a handle>
 36492                                  ;----------------------------------------------------------------------------
 36493                                  ;
 36494                                  ;   Assembler usage:
 36495                                  ;	    MOV AH, FileTimes (57H)
 36496                                  ;	    MOV AL, func
 36497                                  ;	    MOV BX, handle
 36498                                  ;	; if AL = 1 then then next two are mandatory
 36499                                  ;	    MOV CX, time
 36500                                  ;	    MOV DX, date
 36501                                  ;	    INT 21h
 36502                                  ;	; if AL = 0 then CX/DX has the last write time/date
 36503                                  ;	; for the handle.
 36504                                  ;
 36505                                  ;	AL=02		 get extended attributes
 36506                                  ;	   BX=handle
 36507                                  ;	   CX=size of buffer (0, return max size )
 36508                                  ;	   DS:SI query list (si=-1, selects all EA)
 36509                                  ;	   ES:DI buffer to hold EA list
 36510                                  ;
 36511                                  ;	AL=03		 get EA name list
 36512                                  ;	   BX=handle
 36513                                  ;	   CX=size of buffer (0, return max size )
 36514                                  ;	   ES:DI buffer to hold name list
 36515                                  ;
 36516                                  ;	AL=04		 set extended attributes
 36517                                  ;	   BX=handle
 36518                                  ;	   ES:DI buffer of EA list
 36519                                  ;
 36520                                  ;
 36521                                  ;   Error returns:
 36522                                  ;	    AX = error_invalid_function
 36523                                  ;	       = error_invalid_handle
 36524                                  ;
 36525                                  ;----------------------------------------------------------------------------
 36526                                  
 36527                                  ; 21/05/2019 - Retro DOS v4.0
 36528                                  ; DOSCODE:A90Dh (MSDOS 6.21, MSDOS.SYS)
 36529                                  
 36530                                  ; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 36531                                  ; DOSCODE:A8ADh (MSDOS 5.0 MSDOS.SYS)
 36532                                  
 36533                                  _$FILE_TIMES:
 36534                                  	; 13/07/2018 - Retro DOS v3.0
 36535                                  
 36536                                  	; MSDOS 3.3
 36537                                  	;cmp	al,2			; correct subfunction ?
 36538                                  	;jb	short ft1
 36539                                  
 36540                                  	;;mov	byte [ss:EXTERR_LOCUS], 1
 36541                                  	;mov	byte [ss:EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus
 36542                                  						;SS Overr
 36543                                  	;;mov	al,1
 36544                                  	;mov	al,error_invalid_function ; give bad return
 36545                                  	;jmp	SYS_RET_ERR
 36546                                  
 36547                                  	; MSDOS 6.0
 36548 0000695E 3C02                    	cmp	al,2			; correct subfunction ?
 36549 00006960 7340                    	jae	short inval_func
 36550                                  ;ft1:
 36551 00006962 E87300                  	call	CheckOwner		; get sft
 36552                                  	; 17/12/2022
 36553 00006965 72F4                    	jc	short LSeekError	; bad handle
 36554                                  
 36555 00006967 08C0                    	or	al,al			; get time/date ?
 36556 00006969 7515                    	jnz	short ft_set_time
 36557                                  
 36558                                  ;------ here we get the time & date from the sft for the user
 36559                                  
 36560 0000696B FA                      	cli				; is this cli/sti reqd ? BUGBUG
 36561                                  	;mov	cx,[es:di+13]
 36562 0000696C 268B4D0D                	mov	cx,[es:di+SF_ENTRY.sf_time] ; get the time
 36563                                  	;mov	dx,[es:di+15]
 36564 00006970 268B550F                	mov	dx,[es:di+SF_ENTRY.sf_date] ;  & date
 36565 00006974 FB                      	sti
 36566 00006975 E8189B                  	call	Get_User_Stack
 36567                                  	;mov	[si+4],cx
 36568 00006978 894C04                  	mov	[si+user_env.user_CX],cx
 36569                                  	;mov	[si+6],dx
 36570 0000697B 895406                  	mov	[si+user_env.user_DX],dx
 36571 0000697E EB1F                    	jmp	short ok_ret
 36572                                  
 36573                                  ;------ here we set the time in sft
 36574                                  
 36575                                  ft_set_time:
 36576 00006980 E8D4A9                  	call    ECritSFT
 36577                                  	;mov	[es:di+13],cx
 36578 00006983 26894D0D                	mov	[es:di+SF_ENTRY.sf_time],cx ; drop in new time
 36579                                  	;mov	[es:di+15],dx
 36580 00006987 2689550F                	mov	[es:di+SF_ENTRY.sf_date],dx ;  and date	
 36581                                  
 36582 0000698B 31C0                    	xor	ax, ax
 36583 0000698D 36FF1E[C800]            	call	far [ss:JShare+(14*4)] ; 14 = ShSU	; SS Override
 36584                                  
 36585                                  ;------ set the flags in SFT entry
 36586                                  	;and	word [es:di+5],0FFBFh
 36587                                  	; 18/12/2022
 36588                                  	;and	byte [es:di+5],0BFh
 36589 00006992 26806505BF              	and	byte [es:di+SF_ENTRY.sf_flags],~devid_file_clean
 36590                                  	;and	word [es:di+SF_ENTRY.sf_flags],~devid_file_clean 
 36591                                  							; mark file as dirty
 36592                                  	;or	word [es:di+5],4000h
 36593                                  	; 17/12/2022
 36594                                  	;or	byte [es:di+6],40h
 36595 00006997 26804D0640              	or	byte [es:di+SF_ENTRY.sf_flags+1],(sf_close_nodate>>8)
 36596                                  	;or	word [es:di+SF_ENTRY.sf_flags],sf_close_nodate
 36597                                  							; ask close not to
 36598                                  							;   bother about date
 36599                                  							;   and time
 36600 0000699C E8D3A9                  	call	LCritSFT
 36601                                  ok_ret:
 36602                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36603                                  	; 17/12/2022
 36604 0000699F E9A89C                  	jmp	SYS_RET_OK
 36605                                  	;jmp	short LSeekOk
 36606                                  
 36607                                  inval_func:
 36608                                  	;mov	byte [ss:EXTERR_LOCUS],1
 36609 000069A2 36C606[2303]01          	mov	byte [ss:EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus
 36610                                  						;SS Overr
 36611                                  	;mov	al,1
 36612 000069A8 B001                    	mov	al,error_invalid_function ; give bad return
 36613                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36614                                  ft_error:
 36615                                  	;;jmp	SYS_RET_ERR
 36616                                  	;jmp	short LSeekError3
 36617                                  	; 17/12/2022
 36618 000069AA EBAF                    	jmp	short LSeekError
 36619                                  
 36620                                  ; 21/05/2019 - Retro DOS v4.0
 36621                                  ; DOSCODE:A95Bh (MSDOS 6.21, MSDOS.SYS)
 36622                                  
 36623                                  ; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 36624                                  ; DOSCODE:A8FBh (MSDOS 5.0 MSDOS.SYS)
 36625                                  
 36626                                  ;BREAK <$DUP - duplicate a jfn>
 36627                                  ;----------------------------------------------------------------------------
 36628                                  ;
 36629                                  ;   Assembler usage:
 36630                                  ;	    MOV     BX, fh
 36631                                  ;	    MOV     AH, Dup
 36632                                  ;	    INT     int_command
 36633                                  ;	  AX has the returned handle
 36634                                  ;   Errors:
 36635                                  ;	    AX = dup_invalid_handle
 36636                                  ;	       = dup_too_many_open_files
 36637                                  ;
 36638                                  ;----------------------------------------------------------------------------
 36639                                  
 36640                                  _$DUP:
 36641 000069AC 89D8                    	MOV	AX,BX			; save away old handle in AX
 36642 000069AE E86FFD                  	call	JFNFree 		; free handle? into ES:DI, new in BX
 36643                                  DupErrorCheck:
 36644 000069B1 72A8                    	JC	short DupErr		; nope, bye
 36645 000069B3 06                      	push	es
 36646 000069B4 57                      	push	di			; save away SFT
 36647 000069B5 5E                      	pop	si			; into convenient place DS:SI
 36648 000069B6 1F                      	pop	ds
 36649 000069B7 93                      	XCHG	AX,BX			; get back old handle
 36650 000069B8 E81D00                  	call	CheckOwner		; get sft in ES:DI
 36651 000069BB 729E                    	JC	short DupErr		; errors go home
 36652 000069BD E8EBC0                  	call	DOS_Dup_Direct
 36653 000069C0 E800FD                  	call	pJFNFromHandle		; get pointer
 36654 000069C3 268A1D                  	MOV	BL,[ES:DI]		; get SFT number
 36655 000069C6 881C                    	MOV	[SI],BL			; stuff in new SFT
 36656                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36657                                  	;jmp	SYS_RET_OK		; and go home
 36658 000069C8 EBD5                    	jmp	short ok_ret
 36659                                  
 36660                                  	; 17/12/2022
 36661                                  ;DupErr:
 36662                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36663                                  	;;jmp	SYS_RET_ERR
 36664                                  	;jmp	short ft_error
 36665                                  
 36666                                  ;BREAK <$DUP2 - force a dup on a particular jfn>
 36667                                  ;----------------------------------------------------------------------------
 36668                                  ;
 36669                                  ;   Assembler usage:
 36670                                  ;	    MOV     BX, fh
 36671                                  ;	    MOV     CX, newfh
 36672                                  ;	    MOV     AH, Dup2
 36673                                  ;	    INT     int_command
 36674                                  ;   Error returns:
 36675                                  ;	    AX = error_invalid_handle
 36676                                  ;
 36677                                  ;----------------------------------------------------------------------------
 36678                                  
 36679                                  _$DUP2:
 36680 000069CA 53                      	push	bx
 36681 000069CB 51                      	push	cx			; save source
 36682 000069CC 89CB                    	MOV	BX,CX			; get one to close
 36683 000069CE E8AAFD                  	call	_$CLOSE			; close destination handle
 36684 000069D1 5B                      	pop	bx
 36685 000069D2 58                      	pop	ax			; old in AX, new in BX
 36686 000069D3 E8EDFC                  	call	pJFNFromHandle		; get pointer
 36687 000069D6 EBD9                    	JMP	short DupErrorCheck	; check error and do dup
 36688                                  
 36689                                  ;Break	<CheckOwner - verify ownership of handles from server>
 36690                                  ;----------------------------------------------------------------------------
 36691                                  ;   CheckOwner - Due to the ability of the server to close file handles for a
 36692                                  ;   process without the process knowing it (delete/rename of open files, for
 36693                                  ;   example), it is possible for the redirector to issue a call to a handle
 36694                                  ;   that it soes not rightfully own. We check here to make sure that the
 36695                                  ;   issuing process is the owner of the SFT. At the same time, we do a
 36696                                  ;   SFFromHandle to really make sure that the SFT is good.
 36697                                  ;
 36698                                  ;	ENTRY	BX has the handle
 36699                                  ;		User_ID is the current user
 36700                                  ;	EXIT	Carry Clear => ES:DI points to SFT
 36701                                  ;		Carry Set => AX has error code
 36702                                  ;	USES	none
 36703                                  ;----------------------------------------------------------------------------
 36704                                  
 36705                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 36706                                  	; 21/05/2019 - Retro DOS v4.0
 36707                                  CheckOwner:
 36708                                  	; 13/07/2018 - Retro DOS v3.0
 36709                                  
 36710 000069D8 E805FD                  	call	SFFromHandle
 36711 000069DB 721B                    	jc	short co_ret_label	; retc
 36712                                  
 36713 000069DD 50                      	push	ax
 36714                                  
 36715                                  	; MSDOS 6.0
 36716                                  
 36717                                  ;SR; WIN386 patch - Do not check for USER_ID for using handles since these 
 36718                                  ;SR; are shared across multiple VMs in win386.
 36719                                  
 36720 000069DE 36F606[2F10]01          	test	byte [ss:IsWin386],1 ; 02/06/2019
 36721 000069E4 7404                    	jz	short no_win386		;win386 is not present
 36722 000069E6 31C0                    	xor	ax,ax			;set the zero flag
 36723 000069E8 EB08                    	jmp	short _skip_win386	
 36724                                  
 36725                                  no_win386:
 36726 000069EA 36A1[3E03]              	mov	ax,[SS:USER_ID]		;smr;SS Override
 36727                                  	;cmp	ax,[es:di+47]
 36728 000069EE 263B452F                	cmp	ax,[es:di+SF_ENTRY.sf_UID]
 36729                                  
 36730                                  _skip_win386:
 36731 000069F2 58                      	pop	ax
 36732                                  	
 36733                                  	; 17/12/2022
 36734 000069F3 7403                    	jz	short co_ret_label
 36735                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36736                                  	;jnz	short CheckOwner_err
 36737                                  	;retn
 36738                                  	
 36739                                  CheckOwner_err:
 36740                                  	;mov	al,6
 36741 000069F5 B006                    	mov	al,error_invalid_handle
 36742 000069F7 F9                      	stc
 36743                                  
 36744                                  co_ret_label:
 36745 000069F8 C3                      	retn
 36746                                  
 36747                                  ;============================================================================
 36748                                  ; MACRO.ASM, MSDOS 6.0, 1991
 36749                                  ;============================================================================
 36750                                  ; Retro	DOS v3.0 - 11/07/2018
 36751                                  ; 21/05/2019 - Retro DOS v4.0
 36752                                  
 36753                                  ;	TITLE	MACRO - Pathname and macro related internal routines
 36754                                  ;	NAME	MACRO
 36755                                  
 36756                                  ;	Microsoft Confidential
 36757                                  ;	Copyright (C) Microsoft Corporation 1991
 36758                                  ;	All Rights Reserved.
 36759                                  
 36760                                  ;**	MACRO.ASM
 36761                                  ;
 36762                                  ;	$AssignOper
 36763                                  ;	FIND_DPB
 36764                                  ;	InitCDS
 36765                                  ;	$UserOper
 36766                                  ;	GetVisDrv
 36767                                  ;	GetThisDrv
 36768                                  ;	GetCDSFromDrv
 36769                                  ;
 36770                                  ;   Revision history:
 36771                                  ;
 36772                                  ;	Created: MZ 4 April 1983
 36773                                  ;		 MZ 18 April 1983   Make TransFCB handle extended FCBs
 36774                                  ;		 AR 2 June 1983     Define/Delete macro for NET redir.
 36775                                  ;		 MZ 3 Nov 83	    Fix InitCDS to reset length to 2
 36776                                  ;		 MZ 4 Nov 83	    Fix NetAssign to use STRLEN only
 36777                                  ;		 MZ 18 Nov 83	    Rewrite string processing for subtree
 36778                                  ;				    aliasing.
 36779                                  ;
 36780                                  ;   MSDOS performs several types of name translation. First, we maintain for
 36781                                  ;   each valid drive letter the text of the current directory on that drive.
 36782                                  ;   For invalid drive letters, there is no current directory so we pretend to
 36783                                  ;   be at the root. A current directory is either the raw local directory
 36784                                  ;   (consisting of drive:\path) or a local network directory (consisting of
 36785                                  ;   \\machine\path. There is a limit on the point to which a .. is allowed.
 36786                                  ;
 36787                                  ;   Given a path, MSDOS will transform this into a real from-the-root path
 36788                                  ;   without . or .. entries. Any component that is > 8.3 is truncated to
 36789                                  ;   this and all * are expanded into ?'s.
 36790                                  ;
 36791                                  ;   The second part of name translation involves subtree aliasing. A list of
 36792                                  ;   subtree pairs is maintained by the external utility SUBST. The results of
 36793                                  ;   the previous 'canonicalization' are then examined to see if any of the
 36794                                  ;   subtree pairs is a prefix of the user path. If so, then this prefix is
 36795                                  ;   replaced with the other subtree in the pair.
 36796                                  ;
 36797                                  ;   A third part involves mapping this "real" path into a "physical" path.  A
 36798                                  ;   list of drive/subtree pairs are maintained by the external utility JOIN.
 36799                                  ;   The output of the previous translation is examined to see if any of the
 36800                                  ;   subtrees in this list are a prefix of the string. If so, then the prefix
 36801                                  ;   is replaced by the appropriate drive letter. In this manner, we can
 36802                                  ;   'mount' one device under another.
 36803                                  ;
 36804                                  ;   The final form of name translation involves the mapping of a user's
 36805                                  ;   logical drive number into the internal physical drive. This is
 36806                                  ;   accomplished by converting the drive number into letter:CON, performing
 36807                                  ;   the above translation and then converting the character back into a drive
 36808                                  ;   number.
 36809                                  ;
 36810                                  ;   There are two main entry points: TransPath and TransFCB. TransPath will
 36811                                  ;   take a path and form the real text of the pathname with all . and ..
 36812                                  ;   removed. TransFCB will translate an FCB into a path and then invoke
 36813                                  ;   TransPath.
 36814                                  ;
 36815                                  ;	A000	version 4.00  Jan. 1988
 36816                                  
 36817                                  ;Installed = TRUE
 36818                                  
 36819                                  ;	I_need	ThisCDS,DWORD		; pointer to CDS used
 36820                                  ;	I_need	CDSAddr,DWORD		; pointer to CDS table
 36821                                  ;	I_need	CDSCount,BYTE		; number of CDS entries
 36822                                  ;	I_need	CurDrv,BYTE		; current macro assignment (old
 36823                                  ;					; current drive)
 36824                                  ;	I_need	NUMIO,BYTE		; Number of physical drives
 36825                                  ;	I_need	fSharing,BYTE		; TRUE => no redirection allowed
 36826                                  ;	I_need	DummyCDS,80h		; buffer for dummy cds
 36827                                  ;	I_need	DIFFNAM,BYTE		; flag for MyName being set
 36828                                  ;	I_need	MYNAME,16		; machine name
 36829                                  ;	I_need	MYNUM,WORD		; machine number
 36830                                  ;	I_need	DPBHEAD,DWORD		; beginning of DPB chain
 36831                                  ;	I_need	EXTERR_LOCUS,BYTE	; Extended Error Locus
 36832                                  ;	I_need	DrvErr,BYTE		; drive error
 36833                                  
 36834                                  ;BREAK <$AssignOper -- Set up a Macro>
 36835                                  ;----------------------------------------------------------------------------
 36836                                  ; Inputs:
 36837                                  ;	AL = 00 get assign mode 		    (ReturnMode)
 36838                                  ;	AL = 01 set assign mode 		    (SetMode)
 36839                                  ;	AL = 02 get attach list entry		    (GetAsgList)
 36840                                  ;	AL = 03 Define Macro (attch start)
 36841                                  ;	    BL = Macro type
 36842                                  ;	       = 0 alias
 36843                                  ;	       = 1 file/device
 36844                                  ;	       = 2 drive
 36845                                  ;	       = 3 Char device -> network
 36846                                  ;	       = 4 File device -> network
 36847                                  ;	    DS:SI -> ASCIZ source name
 36848                                  ;	    ES:DI -> ASCIZ destination name
 36849                                  ;	AL = 04 Cancel Macro
 36850                                  ;	    DS:SI -> ASCIZ source name
 36851                                  ;	AL = 05 Modified get attach list entry
 36852                                  ;	AL = 06 Get ifsfunc item
 36853                                  ;	AL = 07 set in_use of a drive's CDS
 36854                                  ;	     DL = drive number, 0=default  0=A,,
 36855                                  ;	AL = 08 reset in_use of a drive's CDS
 36856                                  ;	     DL = drive number, 0=A, 1=B,,,
 36857                                  ; Function:
 36858                                  ;	Do macro stuff
 36859                                  ; Returns:
 36860                                  ;	Std Xenix style error return
 36861                                  ;----------------------------------------------------------------------------
 36862                                  
 36863                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 36864                                  	; 21/05/2019 - Retro DOS v4.0
 36865                                  _$AssignOper:
 36866                                  	; MSDOS 6.0
 36867 000069F9 3C07                    	CMP	AL,7			      ; set in_use ?		;AN000;
 36868 000069FB 7525                    	JNZ	short chk08		      ; no			;AN000;
 36869                                  srinuse:								;AN000;
 36870 000069FD 50                      	PUSH	AX			      ; save al 		;AN000;
 36871 000069FE 88D0                    	MOV	AL,DL			      ; AL= drive id		;AN000;
 36872 00006A00 E85601                  	CALL	GetCDSFromDrv		      ; ds:si -> cds		;AN000;
 36873 00006A03 58                      	POP	AX			      ; 			;AN000;
 36874 00006A04 7216                    	JC	short baddrv		      ; bad drive		;AN000;
 36875                                  	;cmp	word [si+45h],0
 36876 00006A06 837C4500                	CMP	WORD [SI+curdir.devptr],0     ; dpb ptr =0 ?		;AN000;
 36877 00006A0A 7410                    	JZ	short baddrv		      ;     no			;AN000;
 36878 00006A0C 3C07                    	CMP	AL,7			      ; set ?			;AN000;
 36879 00006A0E 7506                    	JNZ	short resetdrv		      ; no			;AN000;
 36880                                  	;or	word [si+43h],4000h
 36881                                  	; 17/12/2022
 36882                                  	;or	byte [si+44h],40h
 36883 00006A10 804C4440                	or	byte [SI+curdir.flags+1],(curdir_inuse>>8)
 36884                                  	;OR	word [SI+curdir.flags],curdir_inuse ; set in_use	;AN000;
 36885 00006A14 EB19                    	JMP	SHORT okdone		      ; 			;AN000;
 36886                                  resetdrv:
 36887                                  	;and	word [si+43h],0BFFFh									;AN000;
 36888                                  	; 18/12/2022
 36889 00006A16 806444BF                	and	byte [SI+curdir.flags+1],0BFh ; (~curdir_inuse)>>8
 36890                                  	;AND	word [SI+curdir.flags],~curdir_inuse ; reset in_use	;AN000;
 36891 00006A1A EB13                    	JMP	SHORT okdone		      ; 			;AN000;
 36892                                  
 36893                                  	; 17/12/2022
 36894                                  baddrv: 								;AN000;
 36895 00006A1C B80F00                  	MOV	AX,error_invalid_drive	      ; error			;AN000;
 36896                                  
 36897                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36898                                  	;JMP	SHORT ASS_ERR		      ; 			;AN000;
 36899                                  	; 17/12/2022
 36900                                  	; 21/05/2019
 36901                                  ASS_ERR:
 36902 00006A1F E9319C                  	jmp	SYS_RET_ERR
 36903                                  
 36904                                  chk08:									;AN000;
 36905 00006A22 3C08                    	CMP	AL,8			      ; reset inuse ?		;AN000;
 36906 00006A24 74D7                    	JZ	short srinuse 		      ; yes			;AN000;
 36907                                  
 36908                                    ;IF	NOT INSTALLED
 36909                                  	;transfer NET_ASSOPER
 36910                                    ;ELSE
 36911                                  	; MSDOS 3.3 (& MSDOS 6.0)
 36912 00006A26 50                      	PUSH	AX
 36913                                  	;mov	ax,111Eh
 36914                                  	;MOV	AX,(MultNET SHL 8) OR 30
 36915 00006A27 B81E11                  	mov	ax,(MultNET*256)+30
 36916 00006A2A CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - DO REDIRECTION
 36917                                  			; SS = DOS CS
 36918                                  			; STACK: WORD function to execute
 36919                                  			; Return: CF set on error, AX = error code
 36920                                  			; STACK unchanged
 36921 00006A2C 5B                      	POP	BX			; Don't zap error code in AX
 36922 00006A2D 72F0                    	JC	short ASS_ERR
 36923                                  okdone:
 36924 00006A2F E9189C                  	jmp	SYS_RET_OK
 36925                                  
 36926                                  	; 17/12/2022
 36927                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 36928                                  ;ASS_ERR:
 36929                                  	;jmp	SYS_RET_ERR
 36930                                  
 36931                                    ;ENDIF
 36932                                  
 36933                                  ;Break <FIND_DPB - Find a DPB from a drive number>
 36934                                  ;----------------------------------------------------------------------------
 36935                                  ;**	FIND_DPB - Find a DPB from a Drive #
 36936                                  ;
 36937                                  ;	ENTRY	AL has drive number A = 0
 36938                                  ;	EXIT	'C' set
 36939                                  ;		    No DPB for this drive number
 36940                                  ;		'C' clear
 36941                                  ;		    DS:SI points to DPB for drive
 36942                                  ;	USES	SI, DS, Flags
 36943                                  ;----------------------------------------------------------------------------
 36944                                  
 36945                                  	; 21/05/2019 - Retro DOS v4.0
 36946                                  FIND_DPB:
 36947 00006A32 36C536[2600]            	LDS	SI,[SS:DPBHEAD]		;smr;SS Override
 36948                                  fdpb5:	
 36949 00006A37 83FEFF                  	CMP	SI,-1
 36950 00006A3A 7409                    	JZ	short fdpb10
 36951 00006A3C 3A04                    	cmp	al,[si]
 36952                                  	;CMP	AL,[SI+DPB.DRIVE]
 36953 00006A3E 7406                    	jz	short ret_label15	; Carry clear (retz)
 36954                                  	;;lds	si,[si+18h] ; MSDOS 3.3
 36955                                  	;lds	si,[si+19h] ; MSDOS 6.0
 36956 00006A40 C57419                  	LDS	SI,[SI+DPB.NEXT_DPB]
 36957 00006A43 EBF2                    	JMP	short fdpb5
 36958                                  fdpb10:	
 36959 00006A45 F9                      	STC
 36960                                  ret_label15:
 36961 00006A46 C3                      	retn
 36962                                  
 36963                                  ;	Break <InitCDS - set up an empty CDS>
 36964                                  ;----------------------------------------------------------------------------
 36965                                  ;**	InitCDS - Setup an Empty CDS
 36966                                  ;
 36967                                  ;	ENTRY	ThisCDS points to CDS
 36968                                  ;		AL has uppercase drive letter
 36969                                  ;	EXIT	ThisCDS is now empty
 36970                                  ;		(ES:DI) = CDS
 36971                                  ;		'C' set if no DPB associated with drive
 36972                                  ;	USES	AH,ES,DI, Flags
 36973                                  ;----------------------------------------------------------------------------
 36974                                  
 36975                                  ; 21/05/2019 - Retro DOS v4.0
 36976                                  ; DOSCODE:A9FDh (MSDOS 6.21, MSDOS.SYS)
 36977                                  
 36978                                  ; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 36979                                  ; DOSCODE:A99Dh (MSDOS 5.0, MSDOS.SYS)
 36980                                  
 36981                                  InitCDS:
 36982                                  	; 19/08/2018
 36983                                  	; 05/08/2018 - Retro DOS v3.0
 36984                                  	; MSDOS 6.0
 36985 00006A47 50                      	push	ax			; save (AL) for caller
 36986 00006A48 36C43E[A205]            	LES	DI,[SS:THISCDS]		; (es:di) = CDS address
 36987                                  	;mov	word [es:di+67],0
 36988 00006A4D 26C745430000            	MOV	word [ES:DI+curdir.flags],0 ; "free" CDS
 36989 00006A53 2C40                    	SUB	AL,"A"-1                ; A = 1
 36990 00006A55 363806[4600]            	CMP	[SS:NUMIO],AL		;smr;SS Override
 36991 00006A5A 7236                    	JC	short icdsx		; Drive does not map a physical drive
 36992 00006A5C 48                      	dec	ax			; (AL) = 0 if A, 1 if B, etc.
 36993 00006A5D 50                      	PUSH	AX			; save drive number for later
 36994 00006A5E 0441                    	add	al,"A"
 36995 00006A60 B43A                    	MOV	AH,':'
 36996 00006A62 268905                  	mov	[ES:DI],ax
 36997                                  	;MOV	[ES:DI+curdir.text],AX 	; set "x:"
 36998                                  	;mov	ax,"\"
 36999                                  	;mov	[es:di+2],ax
 37000                                  	;MOV	word [ES:DI+curdir.text+2],"\"	; NUL terminate
 37001 00006A65 26C745025C00            	mov	word [ES:DI+curdir.text+2],005Ch ; 19/08/2018
 37002                                  	;or	word [es:di+67],4000h
 37003                                  	;or	byte [es:di+68],40h
 37004 00006A6B 26804D4440              	OR	byte [ES:DI+curdir.flags+1],(curdir_inuse>>8)
 37005 00006A70 29C0                    	sub	ax,ax
 37006                                  	;MOV	[es:di+73],ax ; 0
 37007 00006A72 26894549                	MOV	[ES:DI+curdir.ID],ax
 37008                                  	;mov	[es:di+75],ax ; 0
 37009 00006A76 2689454B                	MOV	[ES:DI+curdir.ID+2],ax
 37010 00006A7A B002                    	mov	al,2
 37011                                  	;mov	[es:di+79],aX ; 2
 37012 00006A7C 2689454F                	MOV	[ES:DI+curdir.end],ax
 37013 00006A80 58                      	POP	AX			; (al) = drive number
 37014 00006A81 1E                      	push	ds
 37015 00006A82 56                      	push	si
 37016 00006A83 E8ACFF                  	call	FIND_DPB
 37017 00006A86 7208                    	JC	short icds5		; OOOOPPPPPSSSS!!!!
 37018                                  	;mov	[es:di+69],si
 37019 00006A88 26897545                	MOV	[ES:DI+curdir.devptr],SI
 37020                                  	;mov	[es:di+71],ds
 37021 00006A8C 268C5D47                	MOV	[ES:DI+curdir.devptr+2],DS
 37022                                  icds5:	
 37023 00006A90 5E                      	pop	si
 37024 00006A91 1F                      	pop	ds
 37025                                  icdsx:	
 37026 00006A92 58                      	pop	ax
 37027                                  RET45:
 37028 00006A93 C3                      	retn
 37029                                  
 37030                                  ;Break <$UserOper - get/set current user ID (for net)>
 37031                                  ;----------------------------------------------------------------------------
 37032                                  ;   $UserOper - retrieve or initiate a user id string.	MSDOS will only
 37033                                  ;	maintain this string and do no verifications.
 37034                                  ;
 37035                                  ;   Inputs:	AL has function type (0-get 1-set 2-printer-set 3-printer-get
 37036                                  ;				      4-printer-set-flags,5-printer-get-flags)
 37037                                  ;		DS:DX is user string pointer (calls 1,2)
 37038                                  ;		ES:DI is user buffer (call 3)
 37039                                  ;		BX is assign index (calls 2,3,4,5)
 37040                                  ;		CX is user number (call 1)
 37041                                  ;		DX is flag word (call 4)
 37042                                  ;   Outputs:	If AL = 0 then the current user string is written to DS:DX
 37043                                  ;			and user CX is set to the user number
 37044                                  ;		If AL = 3 then CX bytes have been put at input ES:DI
 37045                                  ;		If AL = 5 then DX is flag word
 37046                                  ;----------------------------------------------------------------------------
 37047                                  
 37048                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 37049                                  	; 21/05/2019 - Retro DOS v4.0
 37050                                  _$UserOper:
 37051                                  	; 05/08/2018 - Retro DOS v3.0
 37052                                  	; MSDOS 6.0 (& MSDOS 3.3)
 37053 00006A94 50                      	PUSH	AX
 37054 00006A95 2C01                    	SUB	AL,1			; quick dispatch on 0,1
 37055 00006A97 58                      	POP	AX
 37056 00006A98 7211                    	JB	short UserGet 		; return to user the string
 37057 00006A9A 742E                    	JZ	short UserSet 		; set the current user
 37058 00006A9C 3C05                    	CMP	AL,5			; test for 2,3,4 or 5
 37059 00006A9E 763D                    	JBE	short UserPrint		; yep
 37060                                  	;mov	byte [ss:EXTERR_LOCUS],1
 37061 00006AA0 36C606[2303]01          	MOV	byte [SS:EXTERR_LOCUS],errLOC_Unk ;smr;SS Override 
 37062                                  					; Extended Error Locus
 37063                                  	;error	error_invalid_function	; not 0,1,2,3
 37064                                  	;mov	al,1
 37065 00006AA6 B001                    	MOV	AL,error_invalid_function
 37066                                  useroper_error:
 37067                                  	; 17/12/2022
 37068                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 37069 00006AA8 E9A89B                  	JMP	SYS_RET_ERR
 37070                                  	;jmp	short ASS_ERR
 37071                                  
 37072                                  UserGet:
 37073                                  ; Transfer MYNAME to DS:DX
 37074                                  ; Set Return CX to MYNUM
 37075 00006AAB 1E                      	PUSH	DS			; switch registers
 37076 00006AAC 07                      	POP	ES
 37077 00006AAD 89D7                    	MOV	DI,DX			; destination
 37078 00006AAF 368B0E[0E00]            	MOV	CX,[SS:MYNUM]		; Get number	;smr;SS Override
 37079 00006AB4 E8D999                  	call	Get_User_Stack
 37080                                  	;mov	[si+4],cx
 37081 00006AB7 894C04                  	MOV	[SI+user_env.user_CX],CX ; Set number return
 37082 00006ABA 16                      	push	ss			; point to DOSDATA
 37083 00006ABB 1F                      	pop	ds
 37084 00006ABC BE[0503]                	MOV	SI,MYNAME		; point source to user string
 37085                                  UserMove:
 37086 00006ABF B90F00                  	MOV	CX,15
 37087 00006AC2 F3A4                    	REP	MOVSB			; blam.
 37088 00006AC4 31C0                    	XOR	AX,AX			; 16th byte is 0
 37089 00006AC6 AA                      	STOSB
 37090                                  UserBye:
 37091 00006AC7 E9809B                  	jmp	SYS_RET_OK		; no errors here
 37092                                  
 37093                                  UserSet:
 37094                                  ; Transfer DS:DX to MYNAME
 37095                                  ; CX to MYNUM
 37096 00006ACA 36890E[0E00]            	MOV	[SS:MYNUM],CX				;smr;SS Override
 37097 00006ACF 89D6                    	MOV	SI,DX			; user space has source
 37098 00006AD1 16                      	push	ss
 37099 00006AD2 07                      	pop	es
 37100 00006AD3 BF[0503]                	MOV	DI,MYNAME		; point dest to user string
 37101 00006AD6 36FE06[0403]            	INC	byte [SS:DIFFNAM]	; signal change ;smr;SS Override
 37102 00006ADB EBE2                    	JMP	short UserMove
 37103                                  
 37104                                  UserPrint:
 37105                                  
 37106                                    ;IF NOT Installed
 37107                                    ;	transfer PRINTER_GETSET_STRING
 37108                                    ;ELSE
 37109 00006ADD 50                      	PUSH	AX
 37110                                  	;mov	ax,111Fh
 37111                                  	;MOV	AX,(MultNET SHL 8) OR 31
 37112 00006ADE B81F11                  	mov	ax,(MultNET<<8)|31
 37113 00006AE1 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - PRINTER SETUP
 37114                                  			; STACK: WORD function
 37115                                  			; Return: CF set on error, AX = error code
 37116                                  			; STACK unchanged
 37117 00006AE3 5A                      	POP	DX			; Clean stack
 37118                                  	;JNC	short OKPA
 37119 00006AE4 73E1                    	jnc	short UserBye ; 21/05/2019
 37120                                  	; 17/12/2022
 37121 00006AE6 EBC0                    	jmp	short useroper_error
 37122                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 37123                                  	;jnb     short OKPA
 37124                                  	;jmp     short useroper_error
 37125                                  
 37126                                  	; 17/12/2022
 37127                                  ;OKPA:
 37128                                  ;	jmp	short UserBye
 37129                                  
 37130                                    ;ENDIF
 37131                                  
 37132                                  
 37133                                  ;Break	<GetVisDrv - return visible drive>
 37134                                  ;----------------------------------------------------------------------------
 37135                                  ;   GetVisDrv - correctly map non-spliced inuse drives
 37136                                  ;
 37137                                  ;   Inputs:	AL has drive identifier (0=default)
 37138                                  ;   Outputs:	Carry Set - invalid drive/macro
 37139                                  ;		Carry Clear - AL has physical drive (0=A)
 37140                                  ;		    ThisCDS points to CDS
 37141                                  ;   Registers modified: AL
 37142                                  ;----------------------------------------------------------------------------
 37143                                  
 37144                                  	; 21/05/2019 - Retro DOS v4.0
 37145                                  	; DOSCODE:AA9Fh (MSDOS 6.21, MSDOS.SYS)
 37146                                  
 37147                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 37148                                  	; DOSCODE:AA3Fh (MSDOS 5.0, MSDOS.SYS)	
 37149                                  GetVisDrv:
 37150                                  	; 05/08/2018 - Retro DOS v3.0
 37151                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 6839h
 37152 00006AE8 E81900                  	CALL	GETTHISDRV		; get inuse drive
 37153 00006AEB 72A6                    	jc	short RET45
 37154 00006AED 1E                      	push	ds
 37155 00006AEE 56                      	push	si
 37156 00006AEF 36C536[A205]            	LDS	SI,[SS:THISCDS]		;smr;SS Override
 37157                                  	;test	word [si+67],2000h
 37158                                  	; 17/12/2022
 37159                                  	;test	byte [si+68],20h
 37160 00006AF4 F6444420                	test	byte [SI+curdir.flags+1],(curdir_splice>>8)
 37161                                  	;TEST	word [SI+curdir.flags],curdir_splice
 37162 00006AF8 5E                      	pop	si
 37163 00006AF9 1F                      	pop	ds
 37164 00006AFA 7497                    	jz	short RET45		; if not spliced, return OK
 37165                                  	; MSDOS 6.0
 37166                                  	;mov	byte [ss:DrvErr],0Fh
 37167 00006AFC 36C606[1006]0F          	MOV	byte [SS:DrvErr],error_invalid_drive ;IFS. ;AN000;smr;SS Override
 37168 00006B02 F9                      	STC				; signal error
 37169 00006B03 C3                      	retn
 37170                                  
 37171                                  ;Break <Getthisdrv - map a drive designator (0=def, 1=A...)>
 37172                                  ;----------------------------------------------------------------------------
 37173                                  ;   GetThisDrv - look through a set of macros and return the current drive and
 37174                                  ;	macro pointer
 37175                                  ;
 37176                                  ;   Inputs:	AL has drive identifier (1=A, 0=default)
 37177                                  ;   Outputs:
 37178                                  ;		Carry Set - invalid drive/macro
 37179                                  ;		Carry Clear - AL has physical drive (0=A)
 37180                                  ;		   ThisCDS points to macro
 37181                                  ;   Registers modified: AL
 37182                                  ;----------------------------------------------------------------------------
 37183                                  
 37184                                  	; 21/05/2019 - Retro DOS v4.0
 37185                                  	; DOSCODE:AABCh (MSDOS 6.21, MSDOS.SYS)
 37186                                  
 37187                                  	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 37188                                  	; DOSCODE:AA5Ch (MSDOS 5.0, MSDOS.SYS)	
 37189                                  GETTHISDRV:
 37190                                  	; 05/08/2018
 37191                                  	; 12/07/2018 - Retro DOS v3.0
 37192                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 6850h
 37193                                  	; MSDOS 3.3 (& MSDOS 6.0)
 37194 00006B04 08C0                    	OR	AL,AL			; are we using default drive?
 37195 00006B06 7505                    	JNZ	SHORT GTD10		; no, go get the CDS pointers
 37196 00006B08 36A0[3603]              	MOV	AL,[SS:CURDRV]		; get the current drive
 37197                                  	;INC	ax			; Counteract next instruction
 37198                                  	; 04/09/2018
 37199                                  	;inc	al
 37200                                  	; 07/12/2022
 37201 00006B0C 40                      	inc	ax
 37202                                  GTD10:	
 37203                                  	;DEC	AX
 37204                                  	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 37205 00006B0D 48                      	dec	ax			; 0 = A
 37206                                  	;dec	al
 37207 00006B0E 1E                      	PUSH	DS			; save world
 37208 00006B0F 56                      	PUSH	SI
 37209                                  	;mov	byte [ss:EXTERR_LOCUS],2
 37210 00006B10 36C606[2303]02          	MOV	BYTE [SS:EXTERR_LOCUS],errLOC_Disk		;smr;SS Override
 37211 00006B16 36F606[7205]FF          	TEST	BYTE [SS:FSHARING],-1	; Logical or Physical?	;smr;SS Override
 37212 00006B1C 7420                    	JZ	SHORT GTD20		; Logical
 37213 00006B1E 50                      	PUSH	AX
 37214 00006B1F 06                      	PUSH	ES
 37215 00006B20 57                      	PUSH	DI
 37216 00006B21 36C706[A205][F304]      	MOV	WORD [SS:THISCDS],DUMMYCDS ;smr;SS Override
 37217                                  	;mov	[SS:THISCDS+2],CS ; MSDOS 3.3
 37218 00006B28 368C16[A405]            	MOV	[SS:THISCDS+2],SS ; MSDOS 6.0 ;ThisCDS = &DummyCDS;smr;
 37219 00006B2D 0441                    	ADD	AL,'A'
 37220 00006B2F E815FF                  	CALL	InitCDS			; InitCDS(c);
 37221                                  	;test	word [es:di+67],4000h
 37222                                  	; 17/12/2022
 37223                                  	;test	byte [es:di+68],40h
 37224 00006B32 26F6454440              	test	byte [ES:DI+curdir.flags+1],(curdir_inuse>>8)
 37225                                  	;TEST	WORD [ES:DI+curdir.flags],curdir_inuse	; Clears carry
 37226 00006B37 5F                      	POP	DI
 37227 00006B38 07                      	POP	ES
 37228 00006B39 58                      	POP	AX
 37229 00006B3A 740D                    	JZ	SHORT GTD30		; Not a physical drive.
 37230 00006B3C EB18                    	JMP	SHORT GTDX		; carry clear
 37231                                  GTD20:
 37232 00006B3E E81800                  	CALL	GetCDSFromDrv
 37233 00006B41 7206                    	JC	SHORT GTD30	; Unassigned CDS -> return error already set
 37234                                  	;test	word [si+43h],4000h
 37235                                  	; 17/12/2022
 37236                                  	;test	byte [si+44h],40h
 37237 00006B43 F6444440                	test	byte [SI+curdir.flags+1],(curdir_inuse>>8)
 37238                                  	;TEST	WORD [SI+curdir.flags],curdir_inuse ; Clears Carry
 37239 00006B47 750D                    	JNZ	SHORT GTDX		; carry clear
 37240                                  GTD30:	
 37241                                  	; 21/05/2019
 37242                                  	; MSDOS 6.0
 37243 00006B49 B00F                    	MOV	AL,error_invalid_drive	; invalid FAT drive
 37244 00006B4B 36A2[1006]              	MOV	BYTE [ss:DrvErr],AL	; save this for IOCTL
 37245                                  	; MSDOS 3.3 (.& MSDOS 6.0)
 37246 00006B4F 36C606[2303]01          	MOV	BYTE [ss:EXTERR_LOCUS],errLOC_Unk
 37247 00006B55 F9                      	STC
 37248                                  GTDX:	
 37249 00006B56 5E                      	POP	SI			; restore world
 37250 00006B57 1F                      	POP	DS
 37251 00006B58 C3                      	RETN
 37252                                   
 37253                                  
 37254                                  ;Break <GetCDSFromDrv - convert a drive number to a CDS pointer>
 37255                                  ;----------------------------------------------------------------------------
 37256                                  ;   GetCDSFromDrv - given a physical drive number, convert it to a CDS
 37257                                  ;	pointer, returning an error if the drive number is greater than the
 37258                                  ;	number of CDS's
 37259                                  ;
 37260                                  ;   Inputs:	AL is physical unit # A=0...
 37261                                  ;   Outputs:	Carry Set if Bad Drive
 37262                                  ;		Carry Clear
 37263                                  ;		    DS:SI -> CDS
 37264                                  ;		    [THISCDS] = DS:SI
 37265                                  ;   Registers modified: DS,SI
 37266                                  ;----------------------------------------------------------------------------
 37267                                  
 37268                                  	; 21/05/2019 - Retro DOS v4.0
 37269                                  GetCDSFromDrv:
 37270 00006B59 363A06[4700]            	CMP	AL,[SS:CDSCOUNT]	; is this a valid designator;smr;SS Override
 37271                                  	;JB	SHORT GetCDS	; cf=1	; yes, go get the macro
 37272                                  	;STC				; signal error
 37273                                  	;RETN				; bye
 37274                                  	; 23/09/2023
 37275 00006B5E F5                      	cmc	; cf=1 <-> cf=0
 37276 00006B5F 7217                    	jc	short GetCDS_retn
 37277                                  GetCDS:
 37278                                  	; 23/09/2023
 37279                                  	;PUSH	BX
 37280 00006B61 50                      	PUSH	AX
 37281 00006B62 36C536[3C00]            	LDS	SI,[SS:CDSADDR]		; get pointer to table	;smr;SS Override
 37282                                  	;mov	bl,81 ; MSDOS 3.3
 37283                                  	;mov	bl,88 ; MSDOS 6.0 
 37284                                  	; 23/09/2023
 37285                                  	;MOV	BL,curdir.size		; size in convenient spot
 37286                                  	;MUL	BL			; get net offset
 37287 00006B67 B458                    	mov	ah,curdir.size
 37288 00006B69 F6E4                    	mul	ah
 37289 00006B6B 01C6                    	ADD	SI,AX ; *		; convert to true pointer
 37290 00006B6D 368936[A205]            	MOV	[SS:THISCDS],SI		; store convenient offset;smr;SS Override
 37291 00006B72 368C1E[A405]            	MOV	[SS:THISCDS+2],DS	; store convenient segment;smr;SS Override
 37292 00006B77 58                      	POP	AX
 37293                                  	; 23/09/2023
 37294                                  	;POP	BX
 37295                                  	; (cf must be 0 here) ; *
 37296                                  	;CLC				; no error
 37297                                  GetCDS_retn:
 37298 00006B78 C3                      	RETN				; bye!
 37299                                  
 37300                                  ;============================================================================
 37301                                  ; MACRO2.ASM, MSDOS 6.0, 1991
 37302                                  ;============================================================================
 37303                                  ; Retro	DOS v3.0 - 12/07/2018
 37304                                  ; 22/05/2019 - Retro DOS v4.0
 37305                                  
 37306                                  ;BREAK <TransFCB - convert an FCB into a path, doing substitution>
 37307                                  ;----------------------------------------------------------------------------
 37308                                  ;   TransFCB - Copy an FCB from DS:DX into a reserved area doing all of the
 37309                                  ;       gritty substitution.
 37310                                  ;
 37311                                  ;   Inputs:     DS:DX - pointer to FCB
 37312                                  ;               ES:DI - point to destination
 37313                                  ;   Outputs:    Carry Set - invalid path in final map
 37314                                  ;               Carry Clear - FCB has been mapped into ES:DI
 37315                                  ;                   Sattrib is set from possibly extended FCB
 37316                                  ;                   ExtFCB set if extended FCB found
 37317                                  ;   Registers modified: most
 37318                                  ;----------------------------------------------------------------------------
 37319                                  
 37320                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 37321                                  TransFCB:
 37322                                  	; 22/05/2019 - Retro DOS v4.0
 37323                                  	; 12/07/2018 - Retro DOS v3.0
 37324                                  	;LocalVar FCBTmp,16
 37325                                  	;ENTER
 37326 00006B79 55                      	push	bp
 37327 00006B7A 89E5                    	mov	bp,sp
 37328                                  	;sub	sp,15	; MSDOS 3.3
 37329 00006B7C 83EC10                  	sub	sp,16	; MSDOS 6.0
 37330 00006B7F 16                      	push	ss
 37331 00006B80 07                      	pop	es
 37332 00006B81 06                      	push	es
 37333 00006B82 57                      	push	di
 37334                                  	;lea	di,[bp-15] ; MSDOS 3.3
 37335                                  	;LEA	DI,FCBTmp 
 37336 00006B83 8D7EF0                  	lea	di,[bp-16]		; point to FCB temp area
 37337 00006B86 36C606[6C05]00          	mov	byte [SS:EXTFCB],0	; no extended FCB found ;smr;SS Override
 37338 00006B8C 36C606[6D05]00          	mov	byte [SS:SATTRIB],0	; default search attributes;smr;SS Override
 37339 00006B92 E82FB1                  	call	GetExtended             ; get FCB, extended or not
 37340                                  	; 06/12/2022
 37341 00006B95 740D                    	jz	short GetDrive		; not an extended FCB, get drive
 37342 00006B97 8A44FF                  	mov	AL,[SI-1]               ; get attributes
 37343 00006B9A 36A2[6D05]              	mov	[SS:SATTRIB],AL		; store search attributes;smr;SS Override
 37344 00006B9E 36C606[6C05]FF          	mov	byte [SS:EXTFCB],-1	; signal extended FCB  ;smr;SS Override
 37345                                  GetDrive:
 37346 00006BA4 AC                      	lodsb				; get drive byte
 37347 00006BA5 E85CFF                  	call	GETTHISDRV
 37348 00006BA8 722A                    	jc	short BadPack
 37349 00006BAA E87303                  	call	TextFromDrive           ; convert 0-based drive to text
 37350                                  
 37351                                  ; Scan the source to see if there are any illegal chars
 37352                                  
 37353                                  	;mov	bx,CharType		; load lookup table
 37354 00006BAD B90B00                  	mov	cx,11
 37355 00006BB0 56                      	push	si			; back over name, ext
 37356                                  FCBScan:
 37357 00006BB1 AC                      	lodsb				; get a byte
 37358                                  	
 37359                                  	; 09/08/2018
 37360                                  	;;xlat	byte [es:bx]
 37361                                  	;es	xlat
 37362                                  
 37363                                  	; 22/05/2019 - Retro DOS v4.0	
 37364 00006BB2 E82FE5                  	call	GetCharType		; get flags
 37365                                  
 37366                                  	;test	al,8	
 37367 00006BB5 A808                    	test	al,FFCB
 37368 00006BB7 741B                    	jz	short BadPack
 37369                                  NextCh: 
 37370 00006BB9 E2F6                    	loop	FCBScan
 37371 00006BBB 5E                      	pop	si
 37372 00006BBC 89FB                    	mov	bx,di
 37373 00006BBE E85CB5                  	call	PackName                ; crunch the path
 37374 00006BC1 5F                      	pop	di			; get original destination
 37375 00006BC2 07                      	pop	es
 37376 00006BC3 16                      	push	ss			; get DS addressability
 37377 00006BC4 1F                      	pop	ds
 37378                                  	;lea	si,[bp-15] ; MSDOS 3.3
 37379                                  	;LEA	SI,FCBTmp		; point at new pathname
 37380 00006BC5 8D76F0                  	lea	si,[bp-16]
 37381 00006BC8 803F00                  	cmp	byte [bx],0
 37382 00006BCB 7407                    	jz	short BadPack
 37383 00006BCD 55                      	push	bp
 37384 00006BCE E80E00                  	call	TransPathSet            ; convert the path
 37385 00006BD1 5D                      	pop	bp
 37386 00006BD2 7303                    	jnc	short FCBRet		; bye with transPath error code
 37387                                  BadPack:
 37388 00006BD4 F9                      	STC
 37389                                  	;mov	al,3
 37390 00006BD5 B003                    	MOV     AL,error_path_not_found
 37391                                  FCBRet: 
 37392                                  	;LEAVE
 37393 00006BD7 89EC                    	mov	sp,bp
 37394 00006BD9 5D                      	pop	bp
 37395                                  TransPath_retn:
 37396 00006BDA C3                      	retn
 37397                                  
 37398                                  ; 12/07/2018 - Retro DOS v3.0
 37399                                  
 37400                                  ;BREAK <TransPath - copy a path, do string sub and put in current dir>
 37401                                  ;----------------------------------------------------------------------------
 37402                                  ;
 37403                                  ;   TransPath - copy a path from DS:SI to ES:DI, performing component string
 37404                                  ;       substitution, insertion of current directory and fixing . and ..
 37405                                  ;       entries. Perform splicing. Allow input string to match splice
 37406                                  ;       exactly.
 37407                                  ;
 37408                                  ;   TransPathSet - Same as above except No splicing is performed if input path
 37409                                  ;       matches splice.
 37410                                  ;
 37411                                  ;   TransPathNoSet - No splicing/local using is performed at all.
 37412                                  ;
 37413                                  ;   The following anomalous behaviour is required:
 37414                                  ;
 37415                                  ;       Drive letters on devices are ignored. (set up DummyCDS)
 37416                                  ;       Paths on devices are ignored. (truncate to 0-length)
 37417                                  ;       Raw net I/O sets ThisCDS => NULL.
 37418                                  ;       fSharing => dummyCDS and no subst/splice. Only canonicalize.
 37419                                  ;
 37420                                  ;   Other behaviour:
 37421                                  ;
 37422                                  ;       ThisCDS set up.
 37423                                  ;       FatRead done on local CDS.
 37424                                  ;       ValidateCDS done on local CDS.
 37425                                  ;
 37426                                  ;   Brief flowchart:
 37427                                  ;
 37428                                  ;       if fSharing then
 37429                                  ;           set up DummyCDS (ThisCDS)
 37430                                  ;           canonicalize (sets cMeta)
 37431                                  ;           splice
 37432                                  ;           fatRead
 37433                                  ;           return
 37434                                  ;       if \\ or d:\\ lead then
 37435                                  ;           set up null CDS (ThisCDS)
 37436                                  ;           canonicalize (sets cMeta)
 37437                                  ;           return
 37438                                  ;       if device then
 37439                                  ;           set up dummyCDS (ThisCDS)
 37440                                  ;           canonicalize (sets cMeta)
 37441                                  ;           return
 37442                                  ;       if file then
 37443                                  ;           getCDS (sets (ThisCDS) from name)
 37444                                  ;           validateCDS (may reset current dir)
 37445                                  ;           Copy current dir
 37446                                  ;           canonicalize (set cMeta)
 37447                                  ;           splice
 37448                                  ;           generate correct CDS (ThisCDS)
 37449                                  ;           if local then
 37450                                  ;               fatread
 37451                                  ;           return
 37452                                  ;
 37453                                  ;   Inputs:     DS:SI - point to ASCIZ string path
 37454                                  ;               DI - point to buffer in DOSDATA
 37455                                  ;   Outputs:    Carry Set - invalid path specification: too many .., bad
 37456                                  ;                   syntax, etc. or user FAILed to I 24.
 37457                                  ;               WFP_Start - points to beginning of buffer
 37458                                  ;               Curr_Dir_End - points to end of current dir in path
 37459                                  ;               DS - DOSDATA
 37460                                  ;   Registers modified: most
 37461                                  ;
 37462                                  ;----------------------------------------------------------------------------
 37463                                  
 37464                                  ; 22/05/2019
 37465                                  ; 13/05/2019 - Retro DOS v4.0
 37466                                  ; DOSCODE:AB99h (MSDOS 6.21, MSDOS.SYS)
 37467                                  
 37468                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 37469                                  ; DOSCODE:AB39h (MSDOS 5.0, MSDOS.SYS)
 37470                                  
 37471                                  TransPath:
 37472 00006BDB 30C0                    	XOR     AL,AL
 37473 00006BDD EB02                    	JMP     SHORT SetSplice
 37474                                  TransPathSet:
 37475 00006BDF B0FF                    	MOV     AL,-1
 37476                                  SetSplice:
 37477 00006BE1 36A2[4C03]              	MOV	[SS:NoSetDir],AL	;   NoSetDir = !fExact; ;smr;SS Override
 37478 00006BE5 B0FF                    	MOV     AL,-1
 37479                                  TransPathNoSet:
 37480 00006BE7 36A2[7105]              	MOV	[SS:FSPLICE],AL		;   fSplice = TRUE;     ;smr;SS Override
 37481 00006BEB 36C606[7A05]FF          	MOV	byte [ss:CMETA],-1      			;smr;SS Override
 37482 00006BF1 36893E[B205]            	MOV     [SS:WFP_START],DI 				;smr;SS Override
 37483 00006BF6 36C706[B605]FFFF        	MOV	word [SS:CURR_DIR_END],-1 ; crack from start	;smr;SS Override
 37484 00006BFD 16                      	push	ss
 37485 00006BFE 07                      	pop	es
 37486                                  	;lea	bp,[di+134]
 37487 00006BFF 8DAD8600                	LEA     BP,[DI+TEMPLEN]         ; end of buffer
 37488                                  ;
 37489                                  ; if this is through the server dos call, fsharing is set. We set up a
 37490                                  ; dummy cds and let the operation go.
 37491                                  ;
 37492 00006C03 36F606[7205]FF          	TEST	byte [SS:FSHARING],-1	; if no sharing		;smr;SS Override
 37493 00006C09 7435                    	JZ	short CheckUNC		; skip to UNC check
 37494                                  ;
 37495                                  ; ES:DI point to buffer
 37496                                  ;
 37497 00006C0B E8FC02                  	CALL	DriveFromText           ; get drive and advance DS:SI
 37498 00006C0E E8F3FE                  	call	GETTHISDRV              ; Set ThisCDS and convert to 0-based
 37499 00006C11 722A                    	jc	short NoPath
 37500 00006C13 E80A03                  	CALL	TextFromDrive		; drop in new
 37501 00006C16 8D5D01                  	LEA	BX,[DI+1]               ; backup limit
 37502 00006C19 E83401                  	CALL	Canonicalize            ; copy and canonicalize
 37503 00006C1C 72BC                    	jc	short TransPath_retn	; errors
 37504                                  ;
 37505                                  ; Perform splices for net guys.
 37506                                  ;
 37507 00006C1E 16                      	push	ss
 37508 00006C1F 1F                      	pop	ds
 37509 00006C20 8B36[B205]              	MOV     SI,[WFP_START] 		; point to name
 37510 00006C24 F606[7105]FF            	TEST	byte [FSPLICE],-1
 37511 00006C29 7403                    	JZ	short NoServerSplice
 37512 00006C2B E83102                  	CALL    Splice
 37513                                  NoServerSplice:
 37514 00006C2E 16                      	push	ss
 37515 00006C2F 1F                      	pop	ds                      ; for FATREAD
 37516 00006C30 C43E[A205]              	LES     DI,[THISCDS]		; for fatread
 37517 00006C34 E820A7                  	call	ECritDisk
 37518 00006C37 E801EB                  	call	FATREAD_CDS
 37519 00006C3A E835A7                  	call	LCritDisk
 37520                                  NoPath:
 37521                                  	;mov	al,3
 37522 00006C3D B003                    	MOV     AL,error_path_not_found ; Set up for possible bad path error
 37523 00006C3F C3                      	retn				; any errors are in Carry flag
 37524                                  
 37525                                  ; Let the network decide if the name is for a spooled device. It will map
 37526                                  ; the name if so.
 37527                                  
 37528                                  CheckUNC:
 37529 00006C40 36C706[A205]FFFF        	MOV     WORD [SS:THISCDS],-1	; NULL thisCDS		;smr;SS Override
 37530                                  	;CallInstall NetSpoolCheck,MultNET,35
 37531 00006C47 B82311                  	mov	ax,1123h
 37532 00006C4A CD2F                    	int	2Fh	; Multiplex - NETWORK REDIRECTOR - QUALIFY REMOTE FILENAME
 37533                                  			; DS:SI -> ASCIZ filename to canonicalize
 37534                                  			; ES:DI -> 128-byte buffer for qualified name
 37535                                  			; Return: CF set if not resolved
 37536 00006C4C 7329                    	JNC	short UNCDone
 37537                                  
 37538                                  ; At this point the name is either a UNC-style name (prefixed with two leading
 37539                                  ; \\s) or is a local file/device. Remember that if a net-spooled device was
 37540                                  ; input, then the name has been changed to the remote spooler by the above net
 37541                                  ; call. Also, there may be a drive in front of the \\.
 37542                                  
 37543                                  NO_CHECK:
 37544 00006C4E E8B902                  	CALL    DriveFromText		; eat drive letter
 37545 00006C51 50                      	PUSH    AX                      ; save it
 37546 00006C52 8B04                    	MOV     AX,[SI]			; get first two bytes of path
 37547 00006C54 E8AAE4                  	call    PATHCHRCMP              ; convert to normal form
 37548 00006C57 86E0                    	XCHG    AH,AL                   ; swap for second byte
 37549 00006C59 E8A5E4                  	call    PATHCHRCMP              ; convert to normal form
 37550 00006C5C 751F                    	JNZ	short CheckDevice	; not a path char
 37551 00006C5E 38C4                    	CMP     AH,AL                   ; are they same?
 37552 00006C60 751B                    	JNZ	short CheckDevice	; nope
 37553                                  
 37554                                  ; We have a UNC request. We must copy the string up to the beginning of the
 37555                                  ; local machine root path
 37556                                  
 37557 00006C62 58                      	POP     AX
 37558 00006C63 A5                      	MOVSW                           ; get the lead \\.
 37559                                  UNCCpy:
 37560 00006C64 AC                      	LODSB                           ; get a byte
 37561 00006C65 E844E4                   	call	UCase                   ;AN000;; convert the char
 37562 00006C68 08C0                    	OR      AL,AL
 37563 00006C6A 740E                    	JZ	short UNCTerm		; end of string. All done.
 37564 00006C6C E892E4                  	call    PATHCHRCMP              ; is it a path char?
 37565 00006C6F 89FB                    	MOV     BX,DI                   ; backup position
 37566 00006C71 AA                      	STOSB
 37567 00006C72 75F0                    	JNZ	short UNCCpy		; no, go copy
 37568 00006C74 E8D900                  	CALL    Canonicalize            ; wham (and set cMeta)
 37569                                  UNCDone:
 37570 00006C77 16                      	push	ss
 37571 00006C78 1F                      	pop	ds
 37572 00006C79 C3                       	retn				; return error code
 37573                                  UNCTerm:
 37574 00006C7A AA                      	STOSB                           ;AN000;
 37575 00006C7B EBFA                    	JMP	short UNCDone		;AN000;
 37576                                  
 37577                                  CheckDevice:
 37578                                  
 37579                                  ; Check DS:SI for device. First eat any path stuff
 37580                                  
 37581 00006C7D 58                      	POP     AX                      ; retrieve drive info
 37582 00006C7E 803C00                  	CMP     BYTE [SI],0		; check for null file
 37583 00006C81 7504                    	JNZ	short CheckPath
 37584                                  	;mov	al,2 
 37585 00006C83 B002                    	MOV     AL,error_file_not_found ; bad file error
 37586 00006C85 F9                      	STC                             ; signal error on null input
 37587 00006C86 C3                      	RETN				; bye!
 37588                                  CheckPath:
 37589 00006C87 50                      	push	ax
 37590 00006C88 55                      	push	bp			; save drive number
 37591                                  
 37592                                  
 37593                                  ; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 37594                                  %if 0
 37595                                  	; MSDOS 6.0
 37596                                  ;;;BUGBUG BUG 10-26-1992 scottq
 37597                                  ;;;This is a hack for the CDROM extensions (2.1) who scan looking
 37598                                  ;;;for the following POP BP == 5Dh (restore <bp,ax>).
 37599                                  ;;;The problem is that a direct call to CheckThisDevice can (and did)
 37600                                  ;;;end up having a 5D in the opcode's displacement field. The
 37601                                  ;;;scanning code would choke on this thinking it was a POP BP instruction.
 37602                                  ;;;
 37603                                  ;;;What we do here is do a call to a function that is less than 5Dh
 37604                                  ;;;bytes away (and assert its not exactly 5D away) that jmps (transfers)
 37605                                  ;;;to the correct function. This cannot accidently insert a 5Dh.
 37606                                  ;;;
 37607                                  ;;;More info:
 37608                                  ;;;  This particular scan is begun at the UNCdone label for 32 bytes
 37609                                  ;;;looking for pop BP, so you cannot put a 5D between here and there.
 37610                                  ;;;
 37611                                  	call	no5Dshere
 37612                                  start5Dhack:
 37613                                  ;following is replaced with 5Dhack code--Invoke CheckThisDevice         
 37614                                  backfrom5Dhack:
 37615                                  
 37616                                  %endif
 37617                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 37618                                  	; Note: 'call no5Dshere' is not required for MSDOS 5.0 MSDOS.SYS
 37619 00006C89 E8F7D6                  	call    CheckThisDevice	; E8h,6Fh,0D6h
 37620                                  
 37621 00006C8C 5D                      	pop	bp
 37622 00006C8D 58                      	pop	ax			; get drive letter back
 37623 00006C8E 731C                    	JNC	short DoFile		; yes we have a file.
 37624                                  
 37625                                  ; We have a device. AX has drive letter. At this point we may fake a CDS ala
 37626                                  ; sharing DOS call. We know by getting here that we are NOT in a sharing DOS
 37627                                  ; call.
 37628                                  
 37629 00006C90 36C606[7205]FF          	MOV	byte [SS:FSHARING],-1	; simulate sharing dos call;smr;SS Override
 37630 00006C96 E86BFE                  	call	GETTHISDRV              ; set ThisCDS and init DUMMYCDS
 37631 00006C99 36C606[7205]00          	MOV     byte [SS:FSHARING],0	;                       ;smr;SS Override
 37632                                  
 37633                                  ; Now that we have noted that we have a device, we put it into a form that
 37634                                  ; getpath can understand. Normally getpath requires d:\ to begin the input
 37635                                  ; string. We relax this to state that if the d:\ is present then the path
 37636                                  ; may be a file. If D:/ (note the forward slash) is present then we have
 37637                                  ; a device.
 37638                                  
 37639 00006C9F E87E02                  	CALL    TextFromDrive
 37640 00006CA2 B02F                    	MOV     AL,'/'                  ; path sep.
 37641 00006CA4 AA                      	STOSB
 37642 00006CA5 E873A5                  	call	StrCpy			; move remainder of string
 37643                                  
 37644 00006CA8 F8                      	CLC                             ; everything OK.
 37645 00006CA9 16                      	push	ss
 37646 00006CAA 1F                      	pop	ds                      ; remainder of OK stuff
 37647                                  DoFile_retn:
 37648 00006CAB C3                      	retn
 37649                                  
 37650                                  ; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 37651                                  %if 0
 37652                                  
 37653                                  no5Dshere:
 37654                                  	; 10/08/2018
 37655                                  	jmp	CheckThisDevice		; snoop for device
 37656                                  %endif
 37657                                  
 37658                                  ;.erre (no5Dshere - start5Dhack - 5D)
 37659                                  
 37660                                  ; We have a file. Get the raw CDS.
 37661                                  
 37662                                  DoFile:
 37663                                  	; MSDOS 3.3 (& MSDOS 6.0)
 37664                                  
 37665 00006CAC E839FE                  	call	GetVisDrv               ; get proper CDS
 37666                                  	;mov	al,3 
 37667 00006CAF B003                    	MOV     AL,error_path_not_found ; Set up for possible bad file error
 37668 00006CB1 72F8                    	jc	short DoFile_retn  ; CARRY set -> bogus drive/spliced
 37669                                  
 37670                                  ; ThisCDS has correct CDS. DS:SI advanced to point to beginning of path/file.
 37671                                  ; Make sure that CDS has valid directory; ValidateCDS requires a temp buffer
 37672                                  ; Use the one that we are going to use (ES:DI).
 37673                                  
 37674                                  	;SAVE    <DS,SI,ES,DI>		; save all string pointers.
 37675 00006CB3 1E                      	push	ds
 37676 00006CB4 56                      	push	si
 37677 00006CB5 06                      	push	es
 37678 00006CB6 57                      	push	di
 37679 00006CB7 E80DD6                  	call	ValidateCDS             ; poke CDS and make everything OK
 37680                                  	;RESTORE <DI,ES,SI,DS>		; get back pointers
 37681 00006CBA 5F                      	pop	di
 37682 00006CBB 07                      	pop	es
 37683 00006CBC 5E                      	pop	si
 37684 00006CBD 1F                      	pop	ds
 37685                                  	;mov	al,3
 37686 00006CBE B003                    	MOV     AL,error_path_not_found ; Set up for possible bad path error
 37687                                  	;retc				; someone failed an operation
 37688 00006CC0 72E9                    	jc	short DoFile_retn
 37689                                  
 37690                                  ; ThisCDS points to correct CDS. It contains the correct text of the
 37691                                  ; current directory. Copy it in.
 37692                                  
 37693 00006CC2 1E                      	push	ds
 37694 00006CC3 56                      	push	si
 37695 00006CC4 36C536[A205]            	LDS     SI,[SS:THISCDS]		; point to CDS	;smr;SS Override
 37696 00006CC9 89FB                    	MOV     BX,DI                   ; point to destination
 37697                                  	;add	bx,[si+79] ; MSDOS 6.0
 37698 00006CCB 035C4F                  	ADD     BX,[SI+curdir.end]	; point to backup limit
 37699                                  	;lea	bp,[di+134]
 37700 00006CCE 8DAD8600                	LEA     BP,[DI+TEMPLEN]         ; regenerate end of buffer
 37701                                  					;AN000;
 37702 00006CD2 E855A5                  	call	FStrCpy                 ; copy string. ES:DI point to end
 37703 00006CD5 4F                      	DEC     DI                      ; point to NUL byte
 37704                                  
 37705                                  ; Make sure that there is a path char at end.
 37706                                  
 37707 00006CD6 B05C                    	MOV     AL,'\'
 37708 00006CD8 263845FF                	CMP     [ES:DI-1],AL
 37709 00006CDC 7401                    	JZ	short GetOrig
 37710 00006CDE AA                      	STOSB
 37711                                  
 37712                                  ; Now get original string.
 37713                                  
 37714                                  GetOrig:
 37715 00006CDF 4F                      	DEC     DI                      ; point to path char
 37716 00006CE0 5E                      	pop	si
 37717 00006CE1 1F                      	pop	ds
 37718                                  
 37719                                  ; BX points to the end of the root part of the CDS (at where a path char
 37720                                  ; should be). Now, we decide whether we use this root or extend it with the
 37721                                  ; current directory. See if the input string begins with a leading 
 37723 00006CE2 E8D000                  	CALL    PathSep                 ; is DS:SI a path sep?
 37724 00006CE5 7511                    	JNZ	short PathAssure	; no, DI is correct. Assure a path char
 37725 00006CE7 08C0                    	OR      AL,AL                   ; end of string?
 37726 00006CE9 7410                    	JZ	short DoCanon		; yes, skip.
 37727                                  ;
 37728                                  ; The string does begin with a \. Reset the beginning of the canonicalization
 37729                                  ; to this root. Make sure that there is a path char there and advance the
 37730                                  ; source string over all leading \'s.
 37731                                  ;
 37732 00006CEB 89DF                    	MOV     DI,BX                   ; back up to root point.
 37733                                  SkipPath:
 37734 00006CED AC                      	LODSB
 37735 00006CEE E810E4                  	call    PATHCHRCMP
 37736 00006CF1 74FA                    	JZ	short SkipPath
 37737 00006CF3 4E                      	DEC     SI
 37738 00006CF4 08C0                    	OR      AL,AL
 37739 00006CF6 7403                    	JZ	short DoCanon
 37740                                  
 37741                                  ; DS:SI start at some file name. ES:DI points at some path char. Drop one in
 37742                                  ; for yucks.
 37743                                  
 37744                                  PathAssure:
 37745 00006CF8 B05C                    	MOV     AL,'\'	; 5Ch
 37746 00006CFA AA                      	STOSB
 37747                                  
 37748                                  ; ES:DI point to the correct spot for canonicalization to begin.
 37749                                  ; BP is the max extent to advance DI
 37750                                  ; BX is the backup limit for ..
 37751                                  
 37752                                  DoCanon:
 37753 00006CFB E85200                  	CALL    Canonicalize            ; wham.
 37754                                  	;retc				; badly formatted path.
 37755 00006CFE 72AB                    	jc	short DoFile_retn
 37756                                  
 37757                                  ; The string has been moved to ES:DI. Reset world to DOS context, pointers
 37758                                  ; to wfp_start and do string substitution. BP is still the max position in
 37759                                  ; buffer.
 37760                                  
 37761 00006D00 16                      	push	ss
 37762 00006D01 1F                      	pop	ds
 37763 00006D02 8B3E[B205]              	MOV     DI,[WFP_START]		; DS:SI point to string
 37764 00006D06 C536[A205]              	LDS     SI,[THISCDS]		; point to CDS
 37765 00006D0A E81B02                  	CALL    PathPref                ; is there a prefix?
 37766 00006D0D 7514                    	JNZ	short DoSplice		; no, do splice
 37767                                  
 37768                                  ; We have a match. Check to see if we ended in a path char.
 37769                                  
 37770 00006D0F 8A44FF                  	MOV     AL,[SI-1]		; last char to match
 37771 00006D12 E8ECE3                  	call    PATHCHRCMP              ; did we end on a path char? (root)
 37772 00006D15 740C                    	JZ	short DoSplice		; yes, no current dir here.
 37773                                  Pathline:                               ; 2/13/KK
 37774 00006D17 26803D00                	CMP     BYTE [ES:DI],0		; end at NUL?
 37775 00006D1B 7406                    	JZ	short DoSplice
 37776 00006D1D 47                      	INC     DI                      ; point to after current path char
 37777 00006D1E 36893E[B605]            	MOV     [SS:CURR_DIR_END],DI	; point to correct spot ;smr;SS Override
 37778                                  
 37779                                  ; Splice the result.
 37780                                  
 37781                                  DoSplice:
 37782 00006D23 16                      	push	ss
 37783 00006D24 1F                      	pop	ds			; back to DOSDATA
 37784 00006D25 8B36[B205]              	MOV     SI,[WFP_START]		; point to beginning of string
 37785 00006D29 31C9                    	XOR     CX,CX
 37786 00006D2B F606[7105]FF            	TEST	byte [FSPLICE],-1
 37787 00006D30 7403                    	JZ	short SkipSplice
 37788 00006D32 E82A01                  	CALL    Splice                  ; replaces in place.
 37789                                  SkipSplice:
 37790                                  
 37791                                  ; The final thing is to assure ourselves that a FATREAD is done on the local
 37792                                  ; device.
 37793                                  
 37794 00006D35 16                      	push	ss
 37795 00006D36 1F                      	pop	ds
 37796 00006D37 C43E[A205]              	LES     DI,[THISCDS]		; point to correct drive
 37797                                  	;test	word [es:di+67],8000h
 37798                                  	; 17/12/2022
 37799                                  	;test	byte [es:di+68],80h
 37800 00006D3B 26F6454480              	test	byte [ES:DI+curdir.flags+1],curdir_isnet>>8 ; 04/12/2022
 37801                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet ; 8000h
 37802 00006D40 750D                    	JNZ	short Done		; net, no fatread necessary (retnz)
 37803 00006D42 E30B                    	JCXZ    Done
 37804 00006D44 E810A6                  	call	ECritDisk
 37805 00006D47 E8F1E9                  	call	FATREAD_CDS
 37806 00006D4A E825A6                  	call	LCritDisk
 37807                                  	;mov	al, 3
 37808 00006D4D B003                    	MOV     AL,error_path_not_found ; Set up for possible bad path error
 37809                                  Done:   
 37810 00006D4F C3                      	retn                         ; any errors in carry flag.
 37811                                  
 37812                                  ; 13/07/2018
 37813                                  
 37814                                  ;BREAK <Canonicalize - copy a path and remove . and .. entries>
 37815                                  ;----------------------------------------------------------------------------
 37816                                  ;   Canonicalize - copy path removing . and .. entries.
 37817                                  ;
 37818                                  ;   Inputs:     DS:SI - point to ASCIZ string path
 37819                                  ;               ES:DI - point to buffer
 37820                                  ;               BX - backup limit (offset from ES) points to slash
 37821                                  ;               BP - end of buffer
 37822                                  ;   Outputs:    Carry Set - invalid path specification: too many .., bad
 37823                                  ;                   syntax, etc.
 37824                                  ;               Carry Clear -
 37825                                  ;                   DS:DI - advanced to end of string
 37826                                  ;                   ES:DI - advanced to end of canonicalized form after nul
 37827                                  ;   Registers modified: AX CX DX (in addition to those above)
 37828                                  ;----------------------------------------------------------------------------
 37829                                  
 37830                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 37831                                  
 37832                                  Canonicalize:
 37833                                  
 37834                                  ; We copy all leading path separators.
 37835                                  
 37836 00006D50 AC                      	LODSB                           ;   while (PathChr (*s))
 37837 00006D51 E8ADE3                  	call    PATHCHRCMP
 37838 00006D54 7507                    	JNZ	short CanonDec
 37839 00006D56 39EF                    	CMP     DI,BP                   ;       if (d > dlim)
 37840 00006D58 7319                    	JAE	short CanonBad		;           goto error;
 37841 00006D5A AA                      	STOSB
 37842 00006D5B EBF3                    	JMP	short Canonicalize	;           *d++ = *s++;
 37843                                  CanonDec:
 37844 00006D5D 4E                      	DEC     SI
 37845                                  
 37846                                  ; Main canonicalization loop. We come here with DS:SI pointing to a textual
 37847                                  ; component (no leading path separators) and ES:DI being the destination
 37848                                  ; buffer.
 37849                                  
 37850                                  CanonLoop:
 37851                                  
 37852                                  ; If we are at the end of the source string, then we need to check to see that
 37853                                  ; a potential drive specifier is correctly terminated with a path sep char.
 37854                                  ; Otherwise, do nothing
 37855                                  
 37856 00006D5E 31C0                    	XOR     AX,AX
 37857 00006D60 3804                    	CMP     [SI],AL                 ;       if (*s == 0) {
 37858 00006D62 751A                    	JNZ	short DoComponent
 37859 00006D64 26807DFF3A              	CMP     BYTE [ES:DI-1],':'	;           if (d[-1] == ':')
 37860 00006D69 7505                    	JNZ	short DoTerminate
 37861 00006D6B B05C                    	MOV     AL,'\'                  ;               *d++ = '\';
 37862 00006D6D AA                      	STOSB
 37863 00006D6E 88E0                    	MOV     AL,AH
 37864                                  DoTerminate:
 37865 00006D70 AA                      	STOSB                           ;           *d++ = 0;
 37866 00006D71 F8                      	CLC                             ;           return (0);
 37867 00006D72 C3                      	retn
 37868                                  
 37869                                  CanonBad:
 37870 00006D73 E8CB01                  	CALL	ScanPathChar            ; check for path chars in rest of string
 37871                                  	;mov	al,3
 37872 00006D76 B003                    	MOV     AL,error_path_not_found ; Set up for bad path error
 37873 00006D78 7402                    	JZ	short PathEnc		; path character encountered in string
 37874                                  	;mov	al,2
 37875 00006D7A B002                    	MOV     AL,error_file_not_found ; Set bad file error
 37876                                  PathEnc:
 37877 00006D7C F9                      	STC
 37878                                  CanonBad_retn:
 37879 00006D7D C3                      	retn
 37880                                  
 37881                                  ; We have a textual component that we must copy. We uppercase it and truncate
 37882                                  ; it to 8.3
 37883                                  
 37884                                  DoComponent:                            ;           }
 37885 00006D7E E85000                  	CALL    CopyComponent		;       if (!CopyComponent (s, d))
 37886 00006D81 72FA                    	jc	short CanonBad_retn	;           return (-1);
 37887                                  
 37888                                  ; We special case the . and .. cases.  These will be backed up.
 37889                                  
 37890                                  	;CMP	WORD PTR ES:[DI],'.' + (0 SHL 8)
 37891 00006D83 26833D2E                	CMP	WORD [ES:DI],002Eh
 37892 00006D87 7408                    	JZ	short Skip1
 37893                                  	;CMP	WORD PTR ES:[DI],'..'
 37894 00006D89 26813D2E2E              	CMP     WORD [ES:DI],2E2Eh
 37895 00006D8E 750A                    	JNZ	short CanonNormal
 37896 00006D90 4F                      	DEC     DI                      ;           d--;
 37897                                  Skip1:  
 37898 00006D91 E82A00                  	CALL    SkipBack                ;           SkipBack ();
 37899                                  	;mov	al,3
 37900 00006D94 B003                    	MOV     AL,error_path_not_found ; Set up for possible bad path error
 37901 00006D96 72E5                    	jc	short CanonBad_retn
 37902 00006D98 EB02                    	JMP     short CanonPath         ;           }
 37903                                  
 37904                                  ; We have a normal path. Advance destination pointer over it.
 37905                                  
 37906                                  CanonNormal:                            ;       else
 37907 00006D9A 01CF                    	ADD     DI,CX                   ;           d += ct;
 37908                                  
 37909                                  ; We have successfully copied a component. We are now pointing at a path
 37910                                  ; sep char or are pointing at a nul or are pointing at something else.
 37911                                  ; If we point at something else, then we have an error.
 37912                                  
 37913                                  CanonPath:
 37914 00006D9C E81600                  	CALL    PathSep
 37915 00006D9F 75D2                    	JNZ	short CanonBad		; something else...
 37916                                  
 37917                                  ; Copy the first path char we see.
 37918                                  
 37919 00006DA1 AC                      	LODSB                           ; get the char
 37920 00006DA2 E85CE3                  	call    PATHCHRCMP              ; is it path char?
 37921 00006DA5 75B6                    	JNZ	short CanonDec		; no, go test for nul
 37922 00006DA7 39EF                    	CMP     DI,BP                   ; beyond buffer end?
 37923 00006DA9 73C8                    	JAE	short CanonBad		; yep, error.
 37924 00006DAB AA                      	STOSB                           ; copy the one byte
 37925                                  
 37926                                  ; Skip all remaining path chars
 37927                                  
 37928                                  CanonPathLoop:
 37929 00006DAC AC                      	LODSB                           ; get next byte
 37930 00006DAD E851E3                  	call    PATHCHRCMP              ; path char again?
 37931 00006DB0 74FA                    	JZ	short CanonPathLoop	; yep, grab another
 37932 00006DB2 4E                      	DEC     SI                      ; back up
 37933 00006DB3 EBA9                    	JMP	short  CanonLoop	; go copy component
 37934                                  
 37935                                  ;BREAK <PathSep - determine if char is a path separator>
 37936                                  ;----------------------------------------------------------------------------
 37937                                  ;   PathSep - look at DS:SI and see if char is / \ or NUL
 37938                                  ;   Inputs:     DS:SI - point to a char
 37939                                  ;   Outputs:    AL has char from DS:SI (/ => \)
 37940                                  ;               Zero set if AL is / \ or NUL
 37941                                  ;               Zero reset otherwise
 37942                                  ;   Registers modified: AL
 37943                                  ;----------------------------------------------------------------------------
 37944                                  
 37945                                  PathSep:
 37946 00006DB5 8A04                    	MOV     AL,[SI]                 ; get the character
 37947                                  PathSepGotCh:				; already have character
 37948 00006DB7 08C0                    	OR      AL,AL                   ; test for zero
 37949 00006DB9 74C2                    	jz	short CanonBad_retn	; return if equal to zero (NUL)
 37950                                  	;call	PATHCHRCMP              ; check for path character
 37951                                  	;retn				; and return HIS determination
 37952                                  	; 18/12/2022
 37953 00006DBB E943E3                  	jmp	PATHCHRCMP
 37954                                  
 37955                                  
 37956                                  ;BREAK <SkipBack - move backwards to a path separator>
 37957                                  ;----------------------------------------------------------------------------
 37958                                  ;   SkipBack - look at ES:DI and backup until it points to a / ;   Inputs:     ES:DI - point to a char
 37960                                  ;               BX has current directory back up limit (point to a / \)
 37961                                  ;   Outputs:    ES:DI backed up to point to a path char
 37962                                  ;               AL has char from output ES:DI (path sep if carry clear)
 37963                                  ;               Carry set if illegal backup
 37964                                  ;               Carry Clear if ok
 37965                                  ;   Registers modified: DI,AL
 37966                                  ;----------------------------------------------------------------------------
 37967                                  
 37968                                  SkipBack:
 37969 00006DBE 39DF                    	CMP     DI,BX                   ;   while (TRUE) {
 37970 00006DC0 720B                    	JB	short SkipBad		;       if (d < dlim)
 37971 00006DC2 4F                      	DEC     DI                      ;           goto err;
 37972 00006DC3 268A05                  	MOV     AL,[ES:DI]		;       if (pathchr (*--d))
 37973 00006DC6 E838E3                  	call    PATHCHRCMP              ;           break;
 37974 00006DC9 75F3                    	JNZ	short SkipBack		;       }
 37975 00006DCB F8                      	CLC                             ;   return (0);
 37976 00006DCC C3                      	retn				;
 37977                                  SkipBad:                                ;err:
 37978                                  	;mov	al,3
 37979 00006DCD B003                    	MOV     AL,error_path_not_found ; bad path error
 37980 00006DCF F9                      	STC                             ;   return (-1);
 37981 00006DD0 C3                      	retn				;
 37982                                  
 37983                                  ;Break <CopyComponent - copy out a file path component>
 37984                                  ;----------------------------------------------------------------------------
 37985                                  ;   CopyComponent - copy a file component from a path string (DS:SI) into ES:DI
 37986                                  ;
 37987                                  ;   Inputs:     DS:SI - source path
 37988                                  ;               ES:DI - destination
 37989                                  ;               ES:BP - end of buffer
 37990                                  ;   Outputs:    Carry Set - too long
 37991                                  ;               Carry Clear - DS:SI moved past component
 37992                                  ;                   CX has length of destination
 37993                                  ;   Registers modified: AX,CX,DX
 37994                                  ;----------------------------------------------------------------------------
 37995                                  
 37996                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 37997                                  
 37998                                  CopyComponent:
 37999                                  
 38000                                  %define CopyBP	 [BP]		; word
 38001                                  %define CopyD	 [BP+2]		; dword
 38002                                  %define CopyDoff [BP+2]		; word
 38003                                  %define CopyS	 [BP+6]		; dword
 38004                                  %define CopySoff [BP+6]		; word
 38005                                  %define CopyTemp [BP+10]	; byte
 38006                                  
 38007 00006DD1 83EC0E                  	SUB     SP,14                   ; room for temp buffer
 38008 00006DD4 1E                      	push	ds
 38009 00006DD5 56                      	push	si
 38010 00006DD6 06                      	push	es
 38011 00006DD7 57                      	push	di
 38012 00006DD8 55                      	push	bp
 38013 00006DD9 89E5                    	MOV     BP,SP
 38014 00006DDB B42E                    	MOV     AH,'.'
 38015 00006DDD AC                      	LODSB
 38016 00006DDE AA                      	STOSB
 38017 00006DDF 38E0                    	CMP     AL,AH                   ;   if ((*d++=*s++) == '.') {
 38018 00006DE1 7518                    	JNZ	short NormalComp
 38019 00006DE3 E8CFFF                  	CALL    PathSep                 ;       if (!pathsep(*s))
 38020 00006DE6 740B                    	JZ	short NulTerm
 38021                                  TryTwoDot:
 38022 00006DE8 AC                      	LODSB                           ;           if ((*d++=*s++) != '.'
 38023 00006DE9 AA                      	STOSB
 38024 00006DEA 38E0                    	CMP     AL,AH
 38025 00006DEC 7557                    	JNZ	short CopyBad
 38026 00006DEE E8C4FF                  	CALL    PathSep
 38027 00006DF1 7552                    	JNZ	short CopyBad		;               || !pathsep (*s))
 38028                                  NulTerm:                                ;               return -1;
 38029 00006DF3 30C0                    	XOR     AL,AL                   ;       *d++ = 0;
 38030 00006DF5 AA                      	STOSB
 38031 00006DF6 897606                  	MOV     CopySoff,SI
 38032 00006DF9 EB47                    	JMP     SHORT _GoodRet		;       }
 38033                                  NormalComp:                             ;   else {
 38034 00006DFB 8B7606                  	MOV     SI,CopySoff ; [bp+6]
 38035 00006DFE E83EE2                  	call	NameTrans               ;       s = NameTrans (s, Name1);
 38036 00006E01 3B7606                  	CMP     SI,CopySoff             ;       if (s == CopySOff)
 38037 00006E04 743F                    	JZ	short CopyBad		;           return (-1);
 38038 00006E06 36F606[7205]FF          	TEST	byte [SS:FSHARING],-1	;       if (!fSharing) {;smr;SS Override
 38039 00006E0C 7510                    	JNZ	short DoPack
 38040 00006E0E 80E201                  	AND     DL,1                    ;           cMeta += fMeta;
 38041 00006E11 360016[7A05]            	ADD	[ss:CMETA],DL		;           if (cMeta > 0);smr;SS Override
 38042 00006E16 7F2D                    	JG	short CopyBad		;               return (-1);
 38043 00006E18 7504                    	JNZ	short DoPack		;           else
 38044 00006E1A 08D2                    	OR      DL,DL                   ;           if (cMeta == 0 && fMeta == 0)
 38045 00006E1C 742F                    	JZ	short CopyBadPath	;               return (-1);
 38046                                  DoPack:                                 ;           }
 38047 00006E1E 897606                  	MOV     CopySoff,SI ; [bp+6]
 38048 00006E21 16                      	push	ss
 38049 00006E22 1F                      	pop	ds
 38050 00006E23 BE[4B05]                	MOV     SI,NAME1
 38051 00006E26 8D7E0A                  	LEA     DI,CopyTemp ; [bp+10]
 38052 00006E29 57                      	push	di
 38053 00006E2A E8F0B2                  	call	PackName                ;       PackName (Name1, temp);
 38054 00006E2D 5F                      	pop	di
 38055 00006E2E E802A4                  	call	StrLen                  ;       if (strlen(temp)+d > bp)
 38056 00006E31 49                      	DEC     CX
 38057 00006E32 034E02                  	ADD     CX,CopyDoff ; [bp+2]
 38058                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 38059                                  	;cmp	cx,[bp+0]
 38060                                  	; 15/12/2022
 38061                                  	;cmp	cx,[bp]
 38062 00006E35 3B4E00                  	CMP	CX,CopyBP   ; [bp+0]
 38063 00006E38 730B                    	JAE	short CopyBad		;           return (-1);
 38064 00006E3A 89FE                    	MOV     SI,DI                   ;       strcpy (d, temp);
 38065 00006E3C C47E02                  	LES     DI,CopyD    ; [bp+2]	
 38066 00006E3F E8E8A3                  	call	FStrCpy
 38067                                  _GoodRet:				;       }
 38068 00006E42 F8                      	CLC
 38069 00006E43 EB0B                    	JMP     SHORT CopyEnd           ;   return 0;
 38070                                  CopyBad:
 38071 00006E45 F9                      	STC
 38072 00006E46 E8F800                  	CALL    ScanPathChar            ; check for path chars in rest of string
 38073                                  	;mov	al,2
 38074 00006E49 B002                    	MOV     AL,error_file_not_found ; Set up for bad file error
 38075 00006E4B 7503                    	JNZ	short CopyEnd
 38076                                  CopyBadPath:
 38077 00006E4D F9                      	STC
 38078                                  	;mov	al,3
 38079 00006E4E B003                    	MOV     AL,error_path_not_found ; Set bad path error
 38080                                  CopyEnd:
 38081 00006E50 5D                      	pop	bp
 38082 00006E51 5F                      	pop	di
 38083 00006E52 07                      	pop	es
 38084 00006E53 5E                      	pop	si
 38085 00006E54 1F                      	pop	ds
 38086 00006E55 9F                      	LAHF
 38087 00006E56 83C40E                  	ADD     SP,14                   ; reclaim temp buffer
 38088 00006E59 E8D7A3                  	call	StrLen
 38089 00006E5C 49                      	DEC     CX
 38090 00006E5D 9E                      	SAHF
 38091 00006E5E C3                      	retn
 38092                                  
 38093                                  ; 14/05/2019 - Retro DOS v4.0
 38094                                  ; DOSCODE:AE22h (MSDOS 6.21, MSDOS.SYS)
 38095                                  
 38096                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 38097                                  ; DOSCODE:ADBFh (MSDOS 5.0, MSDOS.SYS)
 38098                                  
 38099                                  ;Break <Splice - pseudo mount by string substitution>
 38100                                  ;----------------------------------------------------------------------------
 38101                                  ;   Splice - take a string and substitute a prefix if one exists. Change
 38102                                  ;       ThisCDS to point to physical drive CDS.
 38103                                  ;   Inputs:     DS:SI point to string
 38104                                  ;               NoSetDir = TRUE => exact matches with splice fail
 38105                                  ;   Outputs:    DS:SI points to thisCDS
 38106                                  ;               ES:DI points to DPB
 38107                                  ;               String at DS:SI may be reduced in length by removing prefix
 38108                                  ;               and substituting drive letter.
 38109                                  ;               CX = 0 If no splice done
 38110                                  ;               CX <> 0 otherwise
 38111                                  ;               ThisCDS points to proper CDS if spliced, otherwise it is
 38112                                  ;                   left alone
 38113                                  ;               ThisDPB points to proper DPB
 38114                                  ;   Registers modified: DS:SI, ES:DI, BX,AX,CX
 38115                                  ;----------------------------------------------------------------------------
 38116                                  
 38117                                  Splice:
 38118 00006E5F 36F606[5A00]FF          	TEST	byte [SS:SPLICES],-1	;smr;SS Override
 38119 00006E65 7469                    	JZ	short AllDone
 38120 00006E67 36FF36[A205]            	push	word [SS:THISCDS]
 38121 00006E6C 36FF36[A405]            	push	word [SS:THISCDS+2]	; TmpCDS = ThisCDS;smr;SS Override
 38122 00006E71 1E                      	push	ds
 38123 00006E72 56                      	push	si
 38124 00006E73 5F                      	pop	di
 38125 00006E74 07                      	pop	es
 38126 00006E75 31C0                    	XOR     AX,AX                   ;   for (i=1; s = GetCDSFromDrv (i); i++)
 38127                                  SpliceScan:
 38128 00006E77 E8DFFC                  	call	GetCDSFromDrv
 38129 00006E7A 724A                    	JC	short SpliceDone
 38130 00006E7C FEC0                    	INC     AL
 38131                                  	; 17/12/2022
 38132                                  	;test	byte [si+68],20h
 38133 00006E7E F6444420                	test	byte [si+curdir.flags+1],curdir_splice>>8 ; 04/12/2022
 38134                                  	;;test	word [si+67],2000h
 38135                                  	;TEST	word [SI+curdir.flags],curdir_splice
 38136 00006E82 74F3                    	JZ	short SpliceScan 	;       if ( Spliced (i) ) {
 38137 00006E84 57                      	push	di
 38138 00006E85 E8A000                  	CALL    PathPref                ;           if (!PathPref (s, d))
 38139 00006E88 7403                    	JZ	short SpliceFound	;
 38140                                  SpliceSkip:
 38141 00006E8A 5F                      	pop	di
 38142 00006E8B EBEA                    	JMP	short SpliceScan	;               continue;
 38143                                  SpliceFound:
 38144 00006E8D 26803D00                	CMP     BYTE [ES:DI],0		;           if (*s || NoSetDir) {
 38145 00006E91 7508                    	JNZ	short SpliceDo
 38146 00006E93 36F606[4C03]FF          	TEST	byte [ss:NoSetDir],-1			;smr;SS Override
 38147 00006E99 75EF                    	JNZ	short SpliceSkip
 38148                                  SpliceDo:
 38149 00006E9B 89FE                    	MOV     SI,DI                   ;               p = src + strlen (p);
 38150 00006E9D 06                      	push	es
 38151 00006E9E 1F                      	pop	ds
 38152 00006E9F 5F                      	pop	di
 38153 00006EA0 E87F00                  	CALL	TextFromDrive1          ;               src = TextFromDrive1(src,i);
 38154 00006EA3 36A1[B605]              	MOV     AX,[SS:CURR_DIR_END]			;smr;SS Override
 38155 00006EA7 09C0                    	OR      AX,AX
 38156 00006EA9 7808                    	JS	short NoPoke
 38157 00006EAB 01F8                    	ADD     AX,DI                   ;               curdirend += src-p;
 38158 00006EAD 29F0                    	SUB     AX,SI
 38159 00006EAF 36A3[B605]              	MOV     [SS:CURR_DIR_END],AX			;smr;SS Override
 38160                                  NoPoke:
 38161 00006EB3 803C00                  	CMP     BYTE [SI],0		;               if (*p)
 38162 00006EB6 7503                    	JNZ	short SpliceCopy	;                   *src++ = '\\';
 38163 00006EB8 B05C                    	MOV     AL,"\"
 38164 00006EBA AA                      	STOSB
 38165                                  SpliceCopy:                             ;               strcpy (src, p);
 38166 00006EBB E86CA3                  	call	FStrCpy
 38167 00006EBE 83C404                  	ADD     SP,4                    ; throw away saved stuff
 38168 00006EC1 80C901                  	OR      CL,1                    ; signal splice done.
 38169 00006EC4 EB0C                    	JMP     SHORT DoSet             ;               return;
 38170                                  SpliceDone:                             ;               }
 38171 00006EC6 368F06[A405]            	pop	word [SS:THISCDS+2]     ;   ThisCDS = TmpCDS;
 38172 00006ECB 368F06[A205]            	pop	word [SS:THISCDS]			;smr;SS Override
 38173                                  AllDone:
 38174 00006ED0 31C9                    	XOR     CX,CX
 38175                                  DoSet:
 38176 00006ED2 36C536[A205]            	LDS     SI,[SS:THISCDS]		;   ThisDPB = ThisCDS->devptr;;smr;SS Override
 38177                                  	;les	di,[si+69]
 38178 00006ED7 C47C45                  	LES     DI,[SI+curdir.devptr]	
 38179 00006EDA 36893E[8A05]            	MOV	[SS:THISDPB],DI				;smr;SS Override
 38180 00006EDF 368C06[8C05]            	MOV	[SS:THISDPB+2],ES			;smr;SS Override
 38181                                  Splice_retn:
 38182 00006EE4 C3                      	retn
 38183                                  
 38184                                  ; 15/05/2019 - Retro DOS v4.0
 38185                                  ; DOSCODE:AEA9h (MSDOS 6.21, MSDOS.SYS)
 38186                                  
 38187                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 38188                                  ; DOSCODE:AE46h (MSDOS 5.0, MSDOS.SYS)
 38189                                  
 38190                                  ;Break <$NameTrans - partially process a name>
 38191                                  ;----------------------------------------------------------------------------
 38192                                  ;   $NameTrans - allow users to see what names get mapped to. This call
 38193                                  ;   performs only string substitution and canonicalization, not splicing.  Due
 38194                                  ;   to Transpath playing games with devices, we need to insure that the output
 38195                                  ;   has drive letter and : in it.
 38196                                  ;
 38197                                  ;   Inputs:     DS:SI - source string for translation
 38198                                  ;               ES:DI - pointer to buffer
 38199                                  ;   Outputs:
 38200                                  ;       Carry Clear
 38201                                  ;               Buffer at ES:DI is filled in with data
 38202                                  ;               ES:DI point byte after nul byte at end of dest string in buffer
 38203                                  ;       Carry Set
 38204                                  ;               AX = error_path_not_found
 38205                                  ;   Registers modified: all
 38206                                  ;----------------------------------------------------------------------------
 38207                                  
 38208                                  _$NameTrans:
 38209 00006EE5 1E                      	push	ds
 38210 00006EE6 56                      	push	si
 38211 00006EE7 06                      	push	es
 38212 00006EE8 57                      	push	di
 38213 00006EE9 51                      	push	cx ; MSDOS 6.0
 38214                                  	
 38215                                  	; MSDOS 6.0	
 38216                                  ; M027 - Start
 38217                                  ;
 38218                                  ; Sattrib must be set up with default values here. Otherwise, the value from
 38219                                  ; a previous DOS call is used for attrib and DevName thinks it is not a 
 38220                                  ; device if the old call set the volume attribute bit. Note that devname in
 38221                                  ; dir2.asm gets ultimately called by Transpath. See also M026. Also save
 38222                                  ; and restore CX.
 38223                                  
 38224                                  	;mov	ch,16h
 38225 00006EEA B516                    	mov     ch,attr_hidden+attr_system+attr_directory
 38226 00006EEC E8B902                  	call	SetAttrib
 38227                                  
 38228                                  ; M027 - End
 38229                                  
 38230                                  	; MSDOS 3.3 (& MSDOS 6.0)
 38231 00006EEF BF[BE03]                	MOV     DI,OPENBUF
 38232 00006EF2 E8E6FC                  	CALL    TransPath               ; to translation (everything)
 38233 00006EF5 59                      	pop	cx ; MSDOS 6.0
 38234 00006EF6 5F                      	pop     di
 38235 00006EF7 07                      	pop	es
 38236 00006EF8 5E                      	pop     si
 38237 00006EF9 1F                      	pop     ds
 38238 00006EFA 7303                    	JNC	short TransOK
 38239 00006EFC E95497                  	jmp	SYS_RET_ERR
 38240                                  TransOK:
 38241 00006EFF BE[BE03]                	MOV     SI,OPENBUF
 38242 00006F02 16                      	push	ss
 38243 00006F03 1F                      	pop	ds
 38244                                  ;GotText:
 38245 00006F04 E823A3                  	call	FStrCpy
 38246 00006F07 E94097                  	jmp	SYS_RET_OK
 38247                                  
 38248                                  ;Break   <DriveFromText - return drive number from a text string>
 38249                                  ;----------------------------------------------------------------------------
 38250                                  ;   DriveFromText - examine DS:SI and remove a drive letter, advancing the
 38251                                  ;   pointer.
 38252                                  ;
 38253                                  ;   Inputs:     DS:SI point to a text string
 38254                                  ;   Outputs:    AL has drive number
 38255                                  ;               DS:SI advanced
 38256                                  ;   Registers modified: AX,SI.
 38257                                  ;----------------------------------------------------------------------------
 38258                                  
 38259                                  DriveFromText:
 38260 00006F0A 30C0                    	XOR     AL,AL                   ;       drive = 0;
 38261                                  	;CMP	BYTE [SI],0		;       if (*s &&
 38262                                  	; 23/09/2023
 38263 00006F0C 3804                    	cmp	[si],al ; 0
 38264 00006F0E 74D4                    	jz	short Splice_retn
 38265 00006F10 807C013A                	CMP     BYTE [SI+1],':'		;           s[1] == ':') {
 38266 00006F14 75CE                    	jnz	short Splice_retn
 38267 00006F16 AD                      	LODSW                           ;           drive = (*s | 020) - 'a'+1;
 38268 00006F17 0C20                    	OR      AL,20h
 38269                                  	;sub	al,60h
 38270 00006F19 2C60                    	SUB     AL,'a'-1                ;           s += 2;
 38271 00006F1B 75C7                    	jnz	short Splice_retn
 38272 00006F1D B0FF                    	MOV	AL,-1                   ; nuke AL...
 38273                                  	; 23/09/2023
 38274                                  	;dec	al ; -1
 38275 00006F1F C3                      	retn				;           }
 38276                                  
 38277                                  ;Break   <TextFromDrive - convert a drive number to a text string>
 38278                                  ;----------------------------------------------------------------------------
 38279                                  ;   TextFromDrive - turn AL into a drive letter: and put it at es:di with
 38280                                  ;   trailing :. TextFromDrive1 takes a 1-based number.
 38281                                  ;
 38282                                  ;   Inputs:     AL has 0-based drive number
 38283                                  ;   Outputs:    ES:DI advanced
 38284                                  ;   Registers modified: AX
 38285                                  ;----------------------------------------------------------------------------
 38286                                  
 38287                                  TextFromDrive:
 38288 00006F20 FEC0                    	INC     AL
 38289                                  TextFromDrive1:
 38290                                  	;add	al,40h
 38291 00006F22 0440                    	ADD     AL,'A'-1                ;   *d++ = drive-1+'A';
 38292 00006F24 B43A                    	MOV     AH,":"	; 3Ah           ;   strcat (d, ":");
 38293 00006F26 AB                      	STOSW
 38294                                  PathPref_retn:
 38295 00006F27 C3                      	retn
 38296                                  
 38297                                  ;Break   <PathPref - see if one path is a prefix of another>
 38298                                  ;----------------------------------------------------------------------------
 38299                                  ;   PathPref - compare DS:SI with ES:DI to see if one is the prefix of the
 38300                                  ;   other.  Remember that only at a pathchar break are we allowed to have a
 38301                                  ;   prefix: A:\ and A:\FOO
 38302                                  ;
 38303                                  ;   Inputs:     DS:SI potential prefix
 38304                                  ;               ES:DI string
 38305                                  ;   Outputs:    Zero set => prefix found
 38306                                  ;                   DI/SI advanced past matching part
 38307                                  ;               Zero reset => no prefix, DS/SI garbage
 38308                                  ;   Registers modified: CX
 38309                                  ;----------------------------------------------------------------------------
 38310                                  
 38311                                  PathPref:
 38312 00006F28 E816A3                  	call	DStrLen                 ; get length
 38313 00006F2B 49                      	DEC     CX                      ; do not include nul byte
 38314 00006F2C F3A6                    	REPZ    CMPSB                   ; compare
 38315 00006F2E 75F7                    	jnz	short PathPref_retn	; if NZ then return NZ
 38316 00006F30 50                      	push	ax			; save char register
 38317 00006F31 8A44FF                  	MOV     AL,[SI-1]               ; get last byte to match
 38318 00006F34 E8CAE1                  	call    PATHCHRCMP              ; is it a path char (Root!)
 38319 00006F37 7406                    	JZ	short Prefix		; yes, match root (I hope)
 38320                                  NotSep:                                 ; 2/13/KK
 38321 00006F39 268A05                  	MOV     AL,[ES:DI]		; get next char to match
 38322 00006F3C E878FE                  	CALL    PathSepGotCh            ; was it a pathchar?
 38323                                  Prefix:
 38324 00006F3F 58                      	pop	ax			; get back original
 38325 00006F40 C3                      	retn
 38326                                  
 38327                                  ;Break   <ScanPathChar - see if there is a path character in a string>
 38328                                  ;----------------------------------------------------------------------------
 38329                                  ;     ScanPathChar - search through the string (pointed to by DS:SI) for
 38330                                  ;     a path separator.
 38331                                  ;
 38332                                  ;     Input:    DS:SI target string (null terminated)
 38333                                  ;     Output:   Zero set => path separator encountered in string
 38334                                  ;               Zero clear => null encountered
 38335                                  ;     Registers modified: SI
 38336                                  ;----------------------------------------------------------------------------
 38337                                  
 38338                                  ScanPathChar:
 38339 00006F41 AC                      	LODSB                           ; fetch a character
 38340 00006F42 E872FE                  	call    PathSepGotCh
 38341 00006F45 75FA                    	JNZ	short ScanPathChar	; not \, / or NUL => go back for more
 38342                                  	;call	PATHCHRCMP              ; path separator?
 38343                                  	;retn
 38344                                  	; 18/12/2022
 38345 00006F47 E9B7E1                  	jmp	PATHCHRCMP
 38346                                  
 38347                                  ;============================================================================
 38348                                  ; FILE.ASM, MSDOS 6.0, 1991
 38349                                  ;============================================================================
 38350                                  ; 14/07/2018 - Retro DOS v3.0
 38351                                  
 38352                                  ; 13/05/2019 - Retro DOS v4.0
 38353                                  ; DOSCODE:AF10h (MSDOS 6.21, MSDOS.SYS)
 38354                                  
 38355                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 38356                                  ; DOSCODE:AEADh (MSDOS 5.0, MSDOS.SYS)
 38357                                  
 38358                                  ; MSDOS 2.11
 38359                                  ;BREAK <$Open - open a file handle>
 38360                                  ;----------------------------------------------------------------------------
 38361                                  ;   Assembler usage:
 38362                                  ;           LDS     DX, Name
 38363                                  ;           MOV     AH, Open
 38364                                  ;           MOV     AL, access
 38365                                  ;           INT     int_command
 38366                                  ;
 38367                                  ;       ACCESS          Function
 38368                                  ;       ------          --------
 38369                                  ;       open_for_read   file is opened for reading
 38370                                  ;       open_for_write  file is opened for writing
 38371                                  ;       open_for_both   file is opened for both reading and writing.
 38372                                  ;
 38373                                  ;   Error returns:
 38374                                  ;           AX = error_invalid_access
 38375                                  ;              = error_file_not_found
 38376                                  ;              = error_access_denied
 38377                                  ;              = error_too_many_open_files
 38378                                  ;----------------------------------------------------------------------------
 38379                                  
 38380                                  ; MSDOS 6.0
 38381                                  ;	BREAK <$Open - open a file from a path string>
 38382                                  ;----------------------------------------------------------------------------
 38383                                  ;
 38384                                  ;**	$OPen - Open a File
 38385                                  ;
 38386                                  ;	given a path name in DS:DX and an open mode in AL, $Open opens the
 38387                                  ;	file and and returns a handle
 38388                                  ;
 38389                                  ;	ENTRY	(DS:DX) = pointer to asciz name
 38390                                  ;		(AL) = open mode
 38391                                  ;	EXIT	'C' clear if OK
 38392                                  ;		  (ax) = file handle
 38393                                  ;		'C' set if error
 38394                                  ;		  (ax) = error code
 38395                                  ;	USES	all
 38396                                  ;
 38397                                  ;----------------------------------------------------------------------------
 38398                                  
 38399                                  ; 13/05/2019 - Retro DOS v4.0
 38400                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 38401                                  
 38402                                  _$OPEN:       
 38403 00006F4A 30E4                    	xor	ah,ah  ; MSDOS 6.0	
 38404                                  _$Open2:
 38405                                  	;mov	ch,16h
 38406 00006F4C B516                    	mov	ch,attr_hidden+attr_system+attr_directory
 38407 00006F4E E85702                  	call	SetAttrib
 38408 00006F51 B9[E12B]                	mov	cx,DOS_OPEN
 38409                                  
 38410                                  	;xor	ah,ah  ; MSDOS 3.3
 38411                                  
 38412 00006F54 50                      	push	ax
 38413                                  
 38414                                  ;*	General file open/create code. The $CREATE call and the various
 38415                                  ;	$OPEN calls all come here.
 38416                                  ;
 38417                                  ;	We'll share a lot of the standard stuff of allocating SFTs, cracking
 38418                                  ;	path names, etc., and then dispatch to our individual handlers.
 38419                                  ;	WARNING - this info and list is just a guess, not definitive - jgl
 38420                                  ;
 38421                                  ;	(TOS) = create mode
 38422                                  ;	(CX) = address of routine to call to do actual function
 38423                                  ;	(DS:DX) = ASCIZ name
 38424                                  ;	SAttrib = Attribute mask
 38425                                  
 38426                                  ;	Get a free SFT and mark it "being allocated"
 38427                                  
 38428                                  AccessFile:
 38429 00006F55 E8FFA3                  	call	ECritSFT
 38430 00006F58 E8D8F7                  	call	SFNFree			; get a free sfn
 38431 00006F5B E814A4                  	call	LCritSFT
 38432 00006F5E 7214                    	jc	short OpenFailJ		; oops, no free sft's
 38433 00006F60 36891E[AA05]            	MOV	[SS:SFN],BX		; save the SFN for later;smr;SS Override
 38434 00006F65 36893E[9E05]            	MOV	[SS:THISSFT],DI		; save the SF offset	;smr;SS Override
 38435 00006F6A 368C06[A005]            	MOV	[SS:THISSFT+2],ES	; save the SF segment	;smr;SS Override
 38436                                  
 38437                                  ;	Find a free area in the user's JFN table.
 38438                                  
 38439 00006F6F E8AEF7                  	call	JFNFree			; get a free jfn
 38440 00006F72 7303                    	jnc	short SaveJFN
 38441                                  OpenFailJ:
 38442 00006F74 E99300                  	JMP	OpenFail		; there were free JFNs... try SFN
 38443                                  
 38444                                  SaveJFN:
 38445 00006F77 36893E[AE05]            	mov	[ss:PJFN],DI		; save the jfn offset	;smr;SS Override
 38446 00006F7C 368C06[B005]            	MOV	[ss:PJFN+2],ES		; save the jfn segment	;smr;SS Override
 38447 00006F81 36891E[AC05]            	MOV	[ss:JFN],BX		; save the jfn itself	;smr;SS Override
 38448                                  
 38449                                  ;	We have been given an JFN. We lock it down to prevent other tasks from
 38450                                  ;	reusing the same JFN.
 38451                                  
 38452 00006F86 368B1E[AA05]            	MOV	BX,[ss:SFN]					;smr;SS Override
 38453 00006F8B 26881D                  	MOV	[ES:DI],BL		; assign the JFN
 38454 00006F8E 89D6                    	MOV	SI,DX			; get name in appropriate place
 38455 00006F90 BF[BE03]                	MOV	DI,OPENBUF		; appropriate buffer
 38456 00006F93 51                      	push	cx			; save routine to call
 38457 00006F94 E844FC                  	call	TransPath		; convert the path
 38458 00006F97 5B                      	pop	bx			; (bx) = routine to call
 38459                                  
 38460 00006F98 36C536[9E05]            	LDS	SI,[SS:THISSFT]					;smr;SS Override
 38461 00006F9D 720A                    	JC	short OpenCleanJ	; no error, go and open file
 38462 00006F9F 36803E[7A05]FF          	CMP	byte [ss:CMETA],-1				;smr;SS Override
 38463 00006FA5 7404                    	JZ	short SetSearch
 38464                                  	;mov	al,2
 38465 00006FA7 B002                    	MOV	AL,error_file_not_found ; no meta chars allowed
 38466                                  OpenCleanJ:
 38467 00006FA9 EB50                    	JMP	short OpenClean
 38468                                  
 38469                                  SetSearch:
 38470 00006FAB 58                      	pop	ax			; Mode (Open), Attributes (Create)
 38471                                  
 38472                                  ;	We need to get the new inheritance bits.
 38473                                  
 38474 00006FAC 31C9                    	xor	cx,cx
 38475                                  	; MSDOS 6.0
 38476                                  	;mov	[si+2],cx ; 0
 38477 00006FAE 894C02                  	MOV	[SI+SF_ENTRY.sf_mode],cx ; initialize mode field to 0
 38478                                  	;mov    [si+51],cx ; 0
 38479 00006FB1 894C33                  	MOV	[SI+SF_ENTRY.sf_MFT],cx	 ; clean out sharing info
 38480                                  	;
 38481 00006FB4 81FB[E12B]              	CMP	BX,DOS_OPEN
 38482 00006FB8 7509                    	JNZ	short _DoOper
 38483                                  	;test   al,80h
 38484 00006FBA A880                    	test	AL,SHARING_NO_INHERIT	; look for no inher
 38485 00006FBC 7405                    	JZ	short _DoOper ; 10/08/2018
 38486 00006FBE 247F                    	AND	AL,7Fh			; mask off inherit bit
 38487                                  	;mov	cx,1000h
 38488 00006FC0 B90010                  	MOV	CX,sf_no_inherit
 38489                                  _DoOper:
 38490                                  	;; MSDOS 3.3
 38491                                  	;;mov	word [si+2], 0
 38492                                  	;;mov	word [si+33h], 0
 38493                                  	;MOV	word [SI+SF_ENTRY.sf_mode],0
 38494                                  	;MOV	word [SI+SF_ENTRY.sf_MFT],0
 38495                                  
 38496                                  	; MSDOS 6.0
 38497                                  ;**	Check if this is an extended open. If so you must set the
 38498                                  ;	modes in sf_mode. Call Set_EXT_mode to do all this. See
 38499                                  ;	Set_EXT_mode in creat.asm
 38500                                  
 38501                                  	; MSDOS 6.0
 38502                                  	;SAVE	<di, es>                ;M022 conditional removed here
 38503 00006FC3 57                      	push	di
 38504 00006FC4 06                      	push	es
 38505 00006FC5 1E                      	push	ds
 38506 00006FC6 07                      	pop	es
 38507 00006FC7 56                      	push	si
 38508 00006FC8 5F                      	pop	di			; (es:di) = SFT address
 38509 00006FC9 E801BC                  	call	Set_EXT_mode
 38510                                  	;RESTORE <es, di>
 38511 00006FCC 07                      	pop	es
 38512 00006FCD 5F                      	pop	di
 38513                                  
 38514                                  	;Context DS
 38515 00006FCE 16                      	push	ss
 38516 00006FCF 1F                      	pop	ds	
 38517                                  
 38518 00006FD0 51                      	push	cx
 38519 00006FD1 FFD3                    	CALL	BX			; blam!
 38520 00006FD3 59                      	pop	cx
 38521 00006FD4 C536[9E05]              	LDS	SI,[THISSFT]
 38522 00006FD8 721A                    	JC	short OpenE2		;AN000;FT. chek extended open hooks first
 38523                                  	;jc	short OpenE ; MSDOS 3.3
 38524                                  
 38525                                  ;	The SFT was successfully opened. Remove busy mark.
 38526                                  
 38527                                  OpenOK:
 38528                                  	;MOV	word [SI+SF_ENTRY.sf_ref_count],1
 38529 00006FDA C7040100                	mov	word [SI],1
 38530                                  	;or	[SI+5],cx
 38531 00006FDE 094C05                  	OR	[SI+SF_ENTRY.sf_flags],CX ; set no inherit bit if necessary
 38532                                  
 38533                                  ; If the open mode is 70, we scan the system for other SFT's with the same
 38534                                  ; contents. If we find one, then we can 'collapse' thissft onto the already
 38535                                  ; opened one. Otherwise we use this new one. We compare uid/pid/mode/mft
 38536                                  ;
 38537                                  ; Since this is only relevant on sharer systems, we stick this code into the
 38538                                  ; sharer.
 38539                                  
 38540 00006FE1 36A1[AC05]              	MOV	AX,[ss:JFN]				;smr;SS Override
 38541 00006FE5 36FF1E[C000]            	Call	far [ss:JShare+(12*4)]	; 12 = ShCol	;smr;SS Override
 38542                                  
 38543 00006FEA 36C706[AA05]FFFF        	MOV	word [ss:SFN],-1	; clear out sfn pointer	;smr;SS Override
 38544                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 38545                                  OpenOkj:
 38546 00006FF1 E95696                  	jmp	SYS_RET_OK		; bye with no errors
 38547                                  
 38548                                  	; MSDOS 6.0
 38549                                  ;Extended Open hooks check
 38550                                  OpenE2:					;AN000;;EO.
 38551 00006FF4 83F857                  	CMP	AX,error_invalid_parameter ;AN000;;EO. IFS extended open ?
 38552 00006FF7 7503                    	JNZ	short OpenE		;AN000;;EO. no.
 38553 00006FF9 EB11                    	JMP	short OpenCritLeave	;AN000;;EO. keep handle
 38554                                  
 38555                                  ;	Extended Open hooks check
 38556                                  ;
 38557                                  ;	AL has error code.  Stack has argument to dos_open/dos_create.
 38558                                  
 38559                                  OpenClean:
 38560 00006FFB 5B                      	pop	bx			; clean off stack
 38561                                  OpenE:
 38562                                  	;MOV	word [SI+SF_ENTRY.sf_ref_count],0 ; release SFT
 38563 00006FFC C7040000                	mov	word [SI],0
 38564 00007000 36C536[AE05]            	LDS	SI,[ss:PJFN]		;smr;SS Override
 38565 00007005 C604FF                  	MOV	BYTE [SI],0FFh		; free the SFN...
 38566 00007008 EB02                    	JMP	SHORT OpenCritLeave
 38567                                  
 38568                                  OpenFail:
 38569 0000700A FB                      	STI
 38570 0000700B 59                      	pop	cx			; Clean stack
 38571                                  OpenCritLeave:
 38572 0000700C 36C706[AA05]FFFF        	MOV	word [SS:SFN],-1	; remove mark.
 38573                                  
 38574                                  	; MSDOS 6.0
 38575                                  ; File Tagging DOS 4.00
 38576 00007013 36833E[2403]25          	CMP	word [SS:EXTERR],error_Code_Page_Mismatched
 38577                                  					;AN000;;FT. code page mismatch
 38578 00007019 7503                    	JNZ	short NORERR	  	;AN000;;FT. no
 38579 0000701B E93D96                  	jmp	From_GetSet		;AN000;;FT. yes
 38580                                  NORERR: 				;AN000;
 38581                                  ; File Tagging DOS 4.00
 38582                                  
 38583 0000701E E93296                  	jmp	SYS_RET_ERR		; no free, return error
 38584                                  
 38585                                  ; MSDOS 2.11
 38586                                  ;BREAK <$CREAT - creat a new file and open him for input>
 38587                                  ;----------------------------------------------------------------------------
 38588                                  ;   Assembler usage:
 38589                                  ;           LDS     DX, name
 38590                                  ;           MOV     AH, Creat
 38591                                  ;           MOV     CX, access
 38592                                  ;           INT     21h
 38593                                  ;       ; AX now has the handle
 38594                                  ;
 38595                                  ;   Error returns:
 38596                                  ;           AX = error_access_denied
 38597                                  ;              = error_path_not_found
 38598                                  ;              = error_too_many_open_files
 38599                                  ;----------------------------------------------------------------------------
 38600                                  
 38601                                  ; MSDOS 6.0
 38602                                  ;	BREAK <$Creat - create a brand-new file>
 38603                                  ;----------------------------------------------------------------------------
 38604                                  ;
 38605                                  ;**	$Creat - Create a File
 38606                                  ;
 38607                                  ;	$Creat creates the directory entry specified in DS:DX and gives it the
 38608                                  ;	initial attributes contained in CX
 38609                                  ;
 38610                                  ;	ENTRY	(DS:DX) = ASCIZ path name
 38611                                  ;		(CX) = initial attributes
 38612                                  ;	EXIT	'C' set if error
 38613                                  ;		  (ax) = error code
 38614                                  ;		'C' clear if OK
 38615                                  ;		  (ax) = file handle
 38616                                  ;	USES	all
 38617                                  ;
 38618                                  ;----------------------------------------------------------------------------
 38619                                  
 38620                                  _$CREAT:
 38621 00007021 51                      	push	cx			; Save attributes on stack
 38622 00007022 B9[B72A]                	mov	CX,DOS_CREATE		; routine to call
 38623                                  AccessSet:
 38624                                  	;mov	byte [ss:SATTRIB],6
 38625 00007025 36C606[6D05]06          	mov	byte [ss:SATTRIB],attr_hidden+attr_system ;smr;SS Override
 38626                                  	; 10/08/2018
 38627 0000702B E927FF                  	JMP	AccessFile		; use good ol' open
 38628                                  
 38629                                  ; MSDOS 6.0 (MSDOS 3.3)
 38630                                  ;	BREAK <$CHMOD - change file attributes>
 38631                                  ;----------------------------------------------------------------------------
 38632                                  ;
 38633                                  ;**	$CHMOD - Change File Attributes
 38634                                  ;
 38635                                  ;   Assembler usage:
 38636                                  ;	    LDS     DX, name
 38637                                  ;	    MOV     CX, attributes
 38638                                  ;	    MOV     AL,func (0=get, 1=set)
 38639                                  ;	    INT     21h
 38640                                  ;   Error returns:
 38641                                  ;	    AX = error_path_not_found
 38642                                  ;	    AX = error_access_denied
 38643                                  ;
 38644                                  ;----------------------------------------------------------------------------
 38645                                  
 38646                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 38647                                  _$CHMOD:
 38648                                  	; 05/08/2018 - Retro DOS v3.0
 38649                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 6FCCh ,
 38650 0000702E BF[BE03]                	MOV	DI,OPENBUF		; appropriate buffer
 38651 00007031 50                      	push	ax
 38652 00007032 51                      	push	cx			; save function and attributes
 38653 00007033 89D6                    	MOV	SI,DX			; get things in appropriate places
 38654 00007035 E8A7FB                  	call	TransPathSet		; get correct path
 38655 00007038 59                      	pop	cx
 38656 00007039 58                      	pop	ax			; and get function and attrs back
 38657 0000703A 7257                    	JC	short ChModErr		; errors get mapped to path not found
 38658 0000703C 16                      	push	ss			; set up for later possible calls
 38659 0000703D 1F                      	pop	ds
 38660 0000703E 803E[7A05]FF            	CMP	byte [CMETA],-1
 38661 00007043 754E                    	JNZ	short ChModErr
 38662                                  	;mov	byte [SATTRIB],16h
 38663 00007045 C606[6D05]16            	MOV	byte [SATTRIB],attr_hidden+attr_system+attr_directory
 38664 0000704A 2C01                    	SUB	AL,1			; fast way to discriminate
 38665 0000704C 720B                    	JB	short ChModGet		; 0 -> go get value
 38666 0000704E 7417                    	JZ	short ChModSet		; 1 -> go set value
 38667                                  	;mov	byte [EXTERR_LOCUS],1
 38668 00007050 C606[2303]01            	MOV	byte [EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus
 38669                                  	;mov	al,1
 38670 00007055 B001                    	mov	al,error_invalid_function ; bad value
 38671                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 38672                                  chmod_errj:	
 38673                                  	;;jmp	SYS_RET_ERR
 38674                                  	;jmp	short ChModE	
 38675 00007057 EBC5                    	jmp	short NORERR	; 06/12/2022
 38676                                  ChModGet:
 38677 00007059 E845B9                  	call	GET_FILE_INFO		; suck out the ol' info
 38678 0000705C 7237                    	JC	short ChModE		; error codes are already set for ret
 38679 0000705E E82F94                  	call	Get_User_Stack		; point to user saved vaiables
 38680                                  	;mov	[SI+4],ax
 38681 00007061 894404                  	MOV	[SI+user_env.user_CX],AX ; return the attributes
 38682                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility
 38683                                  OpenOkj2:
 38684                                  	; 17/12/2022
 38685                                  	;;jmp	SYS_RET_OK		; say sayonara
 38686                                  	;jmp	short OpenOkj
 38687                                  	; 25/06/2019
 38688 00007064 E9E695                  	jmp	SYS_RET_OK_clc
 38689                                  
 38690                                  ChModSet:
 38691 00007067 89C8                    	MOV	AX,CX			; get attrs in position
 38692 00007069 E893B9                  	call	SET_FILE_ATTRIBUTE	; go set
 38693 0000706C 7227                    	JC	short ChModE		; errors are set
 38694                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility
 38695                                  	;jmp	SYS_RET_OK
 38696                                  OpenOkj3:
 38697                                  	;jmp	short OpenOkj2
 38698                                  	; 17/12/2022
 38699 0000706E E9D995                  	jmp	SYS_RET_OK
 38700                                  
 38701                                  ; 17/12/2022
 38702                                  %if 0
 38703                                  ChModErr:
 38704                                  NotFound:	; 17/12/2022
 38705                                  	;mov	al,3
 38706                                  	mov	al,error_path_not_found
 38707                                  ChModE:
 38708                                  UnlinkE:	; 17/12/2022
 38709                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 38710                                  	;;jmp	SYS_RET_ERR
 38711                                  	;jmp	short chmod_errj
 38712                                  	; 17/12/2022
 38713                                  	jmp	short NORERR
 38714                                  %endif
 38715                                  
 38716                                  ; 22/05/2019 - Retro DOS v4.0
 38717                                  ; DOSCODE:B039h (MSDOS 6.21, MSDOS.SYS)
 38718                                  
 38719                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 38720                                  ; DOSCODE:AFD6h (MSDOS 5.0, MSDOS.SYS)
 38721                                  
 38722                                  ;	BREAK <$UNLINK - delete a file entry>
 38723                                  ;----------------------------------------------------------------------------
 38724                                  ;
 38725                                  ;**	$UNLINK - Delete a File
 38726                                  ;
 38727                                  ;
 38728                                  ;	Assembler usage:
 38729                                  ;	    LDS     DX, name
 38730                                  ;	    IF VIA SERVER DOS CALL
 38731                                  ;	     MOV     CX,SEARCH_ATTRIB
 38732                                  ;	    MOV     AH, Unlink
 38733                                  ;	    INT     21h
 38734                                  ;
 38735                                  ;	ENTRY	(ds:dx) = path name
 38736                                  ;		(cx) = search_attribute, if via server_dos
 38737                                  ;	EXIT	'C' clear if no error
 38738                                  ;		'C' set if error
 38739                                  ;		  (ax) = error code
 38740                                  ;			= error_file_not_found
 38741                                  ;			= error_access_denied
 38742                                  ;
 38743                                  ;----------------------------------------------------------------------------
 38744                                  
 38745                                  _$UNLINK:
 38746 00007071 51                      	push	cx			; Save possible CX input parm
 38747 00007072 89D6                    	MOV	SI,DX			; Point at input string
 38748 00007074 BF[BE03]                	MOV	DI,OPENBUF		; temp spot for path
 38749 00007077 E865FB                  	call	TransPathSet		; go get normalized path
 38750 0000707A 59                      	pop	cx
 38751 0000707B 7216                    	JC	short ChModErr		; badly formed path
 38752 0000707D 36803E[7A05]FF          	CMP	byte [ss:CMETA],-1	; meta chars?	;smr;SS Override
 38753 00007083 750E                    	JNZ	short NotFound
 38754 00007085 16                      	push	ss
 38755 00007086 1F                      	pop	ds
 38756                                  	;mov	ch,6
 38757 00007087 B506                    	mov	ch,attr_hidden+attr_system ; unlink appropriate files
 38758 00007089 E81C01                  	call	SetAttrib
 38759 0000708C E802B5                  	call	DOS_DELETE		; remove that file
 38760                                  	;JC	short UnlinkE 		; error is there
 38761                                  	; 17/12/2022
 38762 0000708F 728D                    	jc	short NORERR
 38763                                  
 38764                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 38765                                  UnlinkOk:
 38766                                  	;jmp	SYS_RET_OK		; okey doksy
 38767 00007091 EBDB                    	jmp	short OpenOkj3
 38768                                  
 38769                                  	; 17/12/2022
 38770                                  ChModErr:	; 17/12/2022
 38771                                  NotFound:
 38772                                  	;mov	al,3
 38773 00007093 B003                    	MOV	AL,error_path_not_found
 38774                                  ChModE:		; 17/12/2022
 38775                                  UnlinkE:
 38776                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 38777                                  	;;jmp	SYS_RET_ERR		; bye
 38778                                  	;jmp	short ChModE
 38779                                  	; 17/12/2022
 38780 00007095 EB87                    	jmp	short NORERR
 38781                                  
 38782                                  ;BREAK <$RENAME - move directory entries around>
 38783                                  ;----------------------------------------------------------------------------
 38784                                  ;
 38785                                  ;   Assembler usage:
 38786                                  ;	    LDS     DX, source
 38787                                  ;	    LES     DI, dest
 38788                                  ;	    IF VIA SERVER DOS CALL
 38789                                  ;	      MOV   CX,SEARCH_ATTRIB
 38790                                  ;	    MOV     AH, Rename
 38791                                  ;	    INT     21h
 38792                                  ;
 38793                                  ;   Error returns:
 38794                                  ;	    AX = error_file_not_found
 38795                                  ;	       = error_not_same_device
 38796                                  ;	       = error_access_denied
 38797                                  ;
 38798                                  ;----------------------------------------------------------------------------
 38799                                  
 38800                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 38801                                  _$RENAME:
 38802                                  	; MSDOS 3.3 (& MSDOS 6.0)
 38803 00007097 51                      	push	cx
 38804 00007098 1E                      	push	ds
 38805 00007099 52                      	push	dx			; save source and possible CX arg
 38806 0000709A 06                      	PUSH	ES
 38807 0000709B 1F                      	POP	DS			; move dest to source
 38808 0000709C 89FE                    	MOV	SI,DI			; save for offsets
 38809 0000709E BF[3E04]                	MOV	DI,RENBUF
 38810 000070A1 E83BFB                  	call	TransPathSet		; munge the paths
 38811 000070A4 36FF36[B205]            	PUSH	word [ss:WFP_START]	; get pointer	;smr;SS Override
 38812 000070A9 368F06[B405]            	POP	word [ss:REN_WFP]	; stash it	;smr;SS Override
 38813 000070AE 5E                      	pop	si
 38814 000070AF 1F                      	pop	ds
 38815 000070B0 59                      	pop	cx			; get back source and possible CX arg
 38816                                  epjc2:	
 38817 000070B1 72E0                    	JC	short ChModErr		; get old error
 38818 000070B3 36803E[7A05]FF          	CMP	byte [ss:CMETA],-1			;smr;SS Override
 38819 000070B9 75D8                    	JNZ	short NotFound
 38820 000070BB 51                      	push	cx			; Save possible CX arg
 38821 000070BC BF[BE03]                	MOV	DI,OPENBUF		; appropriate buffer
 38822 000070BF E81DFB                  	call	TransPathSet		; wham
 38823 000070C2 59                      	pop	cx
 38824 000070C3 72EC                    	JC	short epjc2
 38825 000070C5 16                      	push	ss
 38826 000070C6 1F                      	pop	ds
 38827 000070C7 803E[7A05]FF            	CMP	byte [CMETA],-1
 38828 000070CC 72C5                    	JB	short NotFound
 38829                                  
 38830                                  	; MSDOS 6.0
 38831 000070CE FF36[A205]              	PUSH	WORD [THISCDS]		   ;AN000;;MS.save thiscds
 38832 000070D2 FF36[A405]              	PUSH	WORD [THISCDS+2]	   ;AN000;;MS.
 38833 000070D6 BF[BE03]                	MOV	DI,OPENBUF		   ;AN000;;MS.
 38834 000070D9 16                      	PUSH	SS			   ;AN000;;MS.
 38835 000070DA 07                      	POP	ES			   ;AN000;;MS.es:di-> source
 38836 000070DB 30C0                    	XOR	AL,AL			   ;AN000;;MS.scan all CDS
 38837                                  rnloop: 				   ;AN000;
 38838 000070DD E879FA                  	call	GetCDSFromDrv		   ;AN000;;MS.
 38839 000070E0 7210                    	JC	short dorn		   ;AN000;;MS.	end of CDS
 38840 000070E2 E814A1                  	call	StrCmp			   ;AN000;;MS.	current dir ?
 38841 000070E5 7404                    	JZ	short rnerr		   ;AN000;;MS.	yes
 38842 000070E7 FEC0                    	INC	AL			   ;AN000;;MS.	next
 38843 000070E9 EBF2                    	JMP	short rnloop		   ;AN000;;MS.
 38844                                  rnerr:					   ;AN000;
 38845 000070EB 83C404                  	ADD	SP,4			   ;AN000;;MS. pop thiscds
 38846                                  	;error	error_current_directory    ;AN000;;MS.
 38847 000070EE B010                    	mov	al,error_current_directory 
 38848                                  	;jmp	SYS_RET_ERR
 38849                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 38850 000070F0 EBA3                    	jmp	short UnlinkE
 38851                                  dorn:					   ;AN000;
 38852 000070F2 368F06[A405]            	POP	WORD [SS:THISCDS+2]	   ;AN000;;MS.;PBUGBUG;SS REQD??
 38853 000070F7 368F06[A205]            	POP	WORD [SS:THISCDS]	   ;AN000;;MS.;PBUGBUG;SS REQD??
 38854                                  
 38855 000070FC 16                      	push	ss
 38856 000070FD 1F                      	pop	ds
 38857                                  
 38858                                  	; MSDOS 3.3 (& MSDOS 6.0)
 38859                                  	;mov	ch,16h
 38860 000070FE B516                    	mov	ch,attr_directory+attr_hidden+attr_system
 38861                                  					; rename appropriate files
 38862 00007100 E8A500                  	call	SetAttrib
 38863 00007103 E869B6                  	call	DOS_RENAME		; do the deed
 38864 00007106 728D                    	JC	short UnlinkE 		; errors
 38865                                  
 38866                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 38867                                  	;jmp	SYS_RET_OK
 38868 00007108 EB87                    	jmp	short UnlinkOk
 38869                                  
 38870                                  
 38871                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 38872                                  
 38873                                  ; 14/07/2018 - Retro DOS v3.0
 38874                                  ; MSDOS 3.3 (& MSDOS 6.0)
 38875                                  
 38876                                  ;Break <$CreateNewFile - Create a new directory entry>
 38877                                  ;----------------------------------------------------------------------------
 38878                                  ;   CreateNew - Create a new directory entry.  Return a file handle if there
 38879                                  ;	was no previous directory entry, and fail if a directory entry with
 38880                                  ;	the same name existed previously.
 38881                                  ;
 38882                                  ;   Inputs:	DS:DX point to an ASCIZ file name
 38883                                  ;		CX contains default file attributes
 38884                                  ;   Outputs:	Carry Clear:
 38885                                  ;		    AX has file handle opened for read/write
 38886                                  ;		Carry Set:
 38887                                  ;		    AX has error code
 38888                                  ;   Registers modified: All
 38889                                  ;----------------------------------------------------------------------------
 38890                                  
 38891                                  _$CreateNewFile:
 38892 0000710A 51                      	push	cx			; Save attributes on stack
 38893 0000710B B9[842B]                	MOV	CX,DOS_Create_New	; routine to call
 38894 0000710E E914FF                  	JMP	AccessSet		; use good ol' open
 38895                                  
 38896                                  ;**	BinToAscii - convert a number to a string.
 38897                                  ;----------------------------------------------------------------------------
 38898                                  ;	BinToAscii converts a 16 bit number into a 4 ascii characters.
 38899                                  ;	This routine is used to generate temp file names so we don't spend
 38900                                  ;	the time and code needed for a true hex number, we just use
 38901                                  ;	A thorugh O.
 38902                                  ;
 38903                                  ;	ENTRY	(ax) = value
 38904                                  ;		(es:di) = destination
 38905                                  ;	EXIT	(es:di) updated by 4
 38906                                  ;	USES	cx, di, flags
 38907                                  ;----------------------------------------------------------------------------
 38908                                  
 38909                                  ; MSDOS 3.3
 38910                                  ;BinToAscii:
 38911                                  ;	mov     cx,4
 38912                                  ;bta5:
 38913                                  ;	push    cx
 38914                                  ;	mov     cl,4
 38915                                  ;	rol     ax,cl
 38916                                  ;	push    ax
 38917                                  ;	and     al,0Fh
 38918                                  ;	add     al,'0'
 38919                                  ;	cmp     al,'9'
 38920                                  ;	jbe     short bta6
 38921                                  ;	add     al,7
 38922                                  ;bta6: 
 38923                                  ;	stosb
 38924                                  ;	pop     ax
 38925                                  ;	pop     cx
 38926                                  ;	loop    bta5
 38927                                  ;	retn
 38928                                  
 38929                                  ; MSDOS 6.0
 38930                                  BinToAscii:
 38931 00007111 B90404                  	mov	cx,404h			; (ch) = digit counter, (cl) = shift cnt
 38932                                  bta5:	
 38933 00007114 D3C0                    	ROL	AX,CL			; move leftmost nibble into rightmost
 38934 00007116 50                      	push	ax			; preserve remainder of digits
 38935 00007117 240F                    	AND	AL,0Fh			; grab low nibble
 38936 00007119 0441                    	ADD	AL,'A'			; turn into ascii
 38937 0000711B AA                      	STOSB				; drop in the character
 38938 0000711C 58                      	pop	ax			; (ax) = shifted number
 38939 0000711D FECD                    	dec	ch
 38940 0000711F 75F3                    	jnz	short bta5		; process 4 digits
 38941 00007121 C3                      	retn
 38942                                  
 38943                                  ;Break	<$CreateTempFile - create a unique name>
 38944                                  ;----------------------------------------------------------------------------
 38945                                  ;   $CreateTemp - given a directory, create a unique name in that directory.
 38946                                  ;	Method used is to get the current time, convert to a name and attempt
 38947                                  ;	a create new. Repeat until create new succeeds.
 38948                                  ;
 38949                                  ;   Inputs:	DS:DX point to a null terminated directory name.
 38950                                  ;		CX  contains default attributes
 38951                                  ;   Outputs:	Unique name is appended to DS:DX directory.
 38952                                  ;		AX has handle
 38953                                  ;   Registers modified: all
 38954                                  ;----------------------------------------------------------------------------
 38955                                  
 38956                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 38957                                  
 38958                                  _$CreateTempFile:
 38959                                  	;Enter
 38960 00007122 55                      	push	bp
 38961 00007123 89E5                    	mov	bp,sp
 38962                                  
 38963                                  	;LocalVar  EndPtr,DWORD
 38964                                  	;LocalVar  FilPtr,DWORD
 38965                                  	;LocalVar  Attr,WORD
 38966                                  
 38967 00007125 83EC0A                  	sub	sp,10
 38968                                  
 38969                                  	;test	cx,0FFD8h
 38970 00007128 F7C1D8FF                	test	CX,~attr_changeable
 38971 0000712C 7405                    	JZ	short OKatts		; Ok if no non-changeable bits set
 38972                                  
 38973                                  ; We need this "hook" here to detect these cases (like user sets one both of
 38974                                  ; vol_id and dir bits) because of the structure of the or $CreateNewFile loop
 38975                                  ; below. The code loops on error_access_denied, but if one of the non
 38976                                  ; changeable attributes is specified, the loop COULD be infinite or WILL be
 38977                                  ; infinite because CreateNewFile will fail with access_denied always. Thus we
 38978                                  ; need to detect these cases before getting to the loop.
 38979                                  
 38980                                  	;mov	ax, 5
 38981 0000712E B80500                  	MOV	AX,error_access_denied
 38982 00007131 EB69                    	JMP	SHORT SETTMPERR
 38983                                  
 38984                                  OKatts:
 38985                                  	;MOV	attr,CX 		; save attribute
 38986 00007133 894EF6                  	mov     [bp-10],cx
 38987                                  	;MOV	FilPtrL,DX		; pointer to file
 38988 00007136 8956F8                  	mov	[bp-8],dx
 38989                                  	;MOV	FilPtrH,DS
 38990 00007139 8C5EFA                  	mov	[bp-6],ds
 38991                                  	;MOV	EndPtrH,DS		; seg pointer to end of dir
 38992 0000713C 8C5EFE                  	mov	[bp-2],ds
 38993 0000713F 1E                      	PUSH	DS
 38994 00007140 07                      	POP	ES			; destination for nul search
 38995 00007141 89D7                    	MOV	DI,DX
 38996 00007143 89F9                    	MOV	CX,DI
 38997 00007145 F7D9                    	NEG	CX			; number of bytes remaining in segment
 38998                                  	; MSDOS 6.0
 38999 00007147 09C9                    	OR	CX,CX			;AN000;MS. cx=0 ? ds:dx on segment boundary
 39000 00007149 7501                    	JNZ	short okok		;AN000;MS. no
 39001                                  	;MOV	CX,-1			;AN000;MS.
 39002                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39003                                  	; 17/12/2022
 39004 0000714B 49                      	dec	cx  ; mov cx,-1
 39005                                  	;mov	cx,-1 ; 0FFFh
 39006                                  okok:					;AN000;
 39007 0000714C 31C0                    	XOR	AX,AX			;AN000;
 39008 0000714E F2AE                    	REPNZ	SCASB			;AN000;
 39009                                  					;AN000;
 39010 00007150 4F                      	DEC	DI			; point back to the null
 39011 00007151 268A45FF                	MOV	AL,[ES:DI-1]		; Get char before the NUL
 39012 00007155 E8A9DF                  	call	PATHCHRCMP		; Is it a path separator?
 39013 00007158 7403                    	JZ	short SETENDPTR		; Yes
 39014                                  STOREPTH:
 39015 0000715A B05C                    	MOV	AL,'\'
 39016 0000715C AA                      	STOSB				; Add a path separator (and INC DI)
 39017                                  SETENDPTR:
 39018                                  	;MOV	EndPtrL,DI		; pointer to the tail
 39019 0000715D 8856FC                  	mov	[bp-4],dl
 39020                                  CreateLoop:
 39021 00007160 16                      	push	ss			; let ReadTime see variables
 39022 00007161 1F                      	pop	ds
 39023 00007162 55                      	push	bp
 39024 00007163 E8D499                  	call	READTIME		; go get time
 39025 00007166 5D                      	pop	bp
 39026                                  ;
 39027                                  ; Time is in CX:DX. Go drop it into the string.
 39028                                  ;
 39029                                  	;les	di,EndPtr		; point to the string
 39030 00007167 C47EFC                  	les	di,[BP-4]
 39031 0000716A 89C8                    	mov	ax,cx
 39032 0000716C E8A2FF                  	call	BinToAscii		; store upper word
 39033 0000716F 89D0                    	mov	ax,dx
 39034 00007171 E89DFF                  	call	BinToAscii		; store lower word
 39035 00007174 30C0                    	xor	al,al
 39036 00007176 AA                      	STOSB				; nul terminate
 39037                                  	;LDS	DX,FilPtr		; get name
 39038 00007177 C556F8                  	lds	dx,[bp-8]
 39039                                  	;MOV	CX,Attr 		; get attr
 39040 0000717A 8B4EF6                  	mov	cx,[bp-10]
 39041 0000717D 55                      	push	bp
 39042 0000717E E889FF                  	CALL	_$CreateNewFile		; try to create a new file
 39043 00007181 5D                      	pop	bp
 39044 00007182 7319                    	JNC	short CreateDone	; failed, go try again
 39045                                  
 39046                                  ; The operation failed and the error has been mapped in AX. Grab the extended
 39047                                  ; error and figure out what to do.
 39048                                  
 39049                                  	;; MSDOS 3.3			; M049 - start
 39050                                  ;;	mov	ax,[ss:EXTERR]				;smr;SS Override
 39051                                  ;;	cmp	al,error_file_exists
 39052                                  ;;	jz	short CreateLoop	; file existed => try with new name
 39053                                  ;;	cmp	al,error_access_denied
 39054                                  ;;	jz	short CreateLoop	; access denied (attr mismatch)
 39055                                  
 39056                                  	; MSDOS 6.0
 39057                                  	;cmp	al,50h
 39058 00007184 3C50                    	CMP	AL,error_file_exists	; Q: did file already exist
 39059 00007186 74D8                    	JZ	short CreateLoop	; Y: try again
 39060                                  	;cmp	al,5
 39061 00007188 3C05                    	CMP	AL,error_access_denied	; Q: was it access denied
 39062 0000718A 7510                    	JNZ	short SETTMPERR		; N: Error out
 39063                                  					; Y: Check to see if we got this due
 39064                                  					;    to the network drive. Note that
 39065                                  					;    the redir will set the exterr
 39066                                  					;    to error_cannot_make if this is 
 39067                                  					;    so. 
 39068 0000718C 36803E[2403]41          	CMP	byte [SS:EXTERR],error_net_access_denied ; M069
 39069                                  					; See if it's REALLY an att mismatch
 39070 00007192 7408                    	je	short SETTMPERR		; no, network error, stop
 39071                                  ;M070
 39072                                  ; If the user failed on an I24, we do not want to try again
 39073                                  ;
 39074 00007194 36803E[2403]53          	cmp	byte [SS:EXTERR],error_FAIL_I24 ;User failed on I24? ;M070
 39075                                  	;je	short SETTMPERR		;yes, do not try again ;M070
 39076                                  
 39077                                  	;jmp	short CreateLoop	;attr mismatch, try again ;M070
 39078                                  	; 17/12/2022
 39079 0000719A 75C4                    	jne	short CreateLoop ; 10/06/2019 
 39080                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39081                                  	;jz	short SETTMPERR
 39082                                  	;jmp	short CreateLoop
 39083                                  
 39084                                  ;;	MOV	AL,error_access_denied	; Return this "extended" error
 39085                                  					; M049 - end
 39086                                  SETTMPERR:
 39087 0000719C F9                      	STC
 39088                                  CreateDone:
 39089                                  	;Leave
 39090 0000719D 89EC                    	mov	sp,bp
 39091 0000719F 5D                      	pop	bp
 39092 000071A0 7203                    	JC	short CreateFail
 39093 000071A2 E9A594                  	jmp	SYS_RET_OK		; success!
 39094                                  CreateFail:
 39095 000071A5 E9AB94                  	jmp	SYS_RET_ERR
 39096                                  
 39097                                  ;   SetAttrib will set the search attribute (SAttrib) either to the normal
 39098                                  ;   (CH) or to the value in CL if the current system call is through
 39099                                  ;   serverdoscall.
 39100                                  ;
 39101                                  ;   Inputs:	fSharing == FALSE => set sattrib to CH
 39102                                  ;		fSharing == TRUE => set sattrib to CL
 39103                                  ;   Outputs:	none
 39104                                  ;   Registers changed:	CX
 39105                                  
 39106                                  SetAttrib:
 39107 000071A8 36F606[7205]FF          	test	byte [SS:FSHARING],-1		;smr;SS Override
 39108 000071AE 7502                    	jnz	short Set
 39109 000071B0 88E9                    	mov	cl,ch
 39110                                  Set:
 39111 000071B2 36880E[6D05]            	mov	byte [ss:SATTRIB],cl		;smr;SS Override
 39112 000071B7 C3                      	retn
 39113                                  
 39114                                  ; 14/07/2018 - Retro DOS v3.0
 39115                                  ; MSDOS 6.0
 39116                                  
 39117                                  ; 29/04/2019 - Retro DOS v4.0
 39118                                  
 39119                                  ;Break	<Extended_Open- Extended open the file>
 39120                                  ;----------------------------------------------------------------------------
 39121                                  ; Input: AL= 0 reserved  AH=6CH
 39122                                  ;	 BX= mode
 39123                                  ;	 CL= create attribute  CH=search attribute (from server)
 39124                                  ;	 DX= flag
 39125                                  ;	 DS:SI = file name
 39126                                  ;	 ES:DI = parm list
 39127                                  ;			   DD  SET EA list (-1) null
 39128                                  ;			   DW  n  parameters
 39129                                  ;			   DB  type (TTTTTTLL)
 39130                                  ;			   DW  IOMODE
 39131                                  ; Function: Extended Open
 39132                                  ; Output: carry clear
 39133                                  ;		     AX= handle
 39134                                  ;		     CX=1 file opened
 39135                                  ;			2 file created/opened
 39136                                  ;			3 file replaced/opened
 39137                                  ;	  carry set: AX has error code
 39138                                  ;----------------------------------------------------------------------------
 39139                                  
 39140                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 39141                                  _$Extended_Open:			  ;AN000;
 39142                                  	;ASSUME	CS:DOSCODE,SS:DOSDATA	  ;AN000;
 39143 000071B8 368916[F405]            	MOV	[SS:EXTOPEN_FLAG],DX	  ;AN000;EO. save ext. open flag;smr;SS Override
 39144 000071BD 36C706[F705]0000        	MOV	word [SS:EXTOPEN_IO_MODE],0 ;AN000;EO. initialize IO mode;smr;SS Override
 39145                                  	; 17/12/2022
 39146 000071C4 F6C6FE                  	test	dh,0FEh ; 04/12/2022 
 39147                                  	;;test	dx,0FE00h
 39148                                  	;TEST	DX,RESERVED_BITS_MASK	  ;AN000;EO. reserved bits 0  ?
 39149 000071C7 7545                    	JNZ	short ext_inval2	  ;AN000;EO. no
 39150 000071C9 88D4                    	MOV	AH,DL			  ;AN000;EO. make sure flag is right
 39151 000071CB 80FA00                  	CMP	DL,0			  ;AN000;EO. all fail ?
 39152 000071CE 743E                    	JZ	short ext_inval2	  ;AN000;EO. yes, error
 39153                                  	;and	dl,0Fh
 39154 000071D0 80E20F                  	AND	DL,EXISTS_MASK		  ;AN000;EO. get exists action byte
 39155 000071D3 80FA02                  	CMP	DL,2			  ;AN000;EO, > 02
 39156 000071D6 7736                    	JA	short ext_inval2	  ;AN000;EO. yes ,error
 39157                                  	;and	ah,0F0h
 39158 000071D8 80E4F0                  	AND	AH,NOT_EXISTS_MASK	  ;AN000;EO. get no exists action byte
 39159 000071DB 80FC10                  	CMP	AH,10H			  ;AN000;EO. > 10
 39160 000071DE 772E                    	JA	short ext_inval2	  ;AN000;EO. yes error
 39161                                  
 39162 000071E0 368C06[FB05]            	MOV	[SS:SAVE_ES],ES		  ;AN000;EO. save API parms;smr;SS Override
 39163 000071E5 36893E[F905]            	MOV	[SS:SAVE_DI],DI		  ;AN000;EO.;smr;SS Override
 39164 000071EA 36FF36[F405]            	PUSH	word [SS:EXTOPEN_FLAG]	  ;AN000;EO.;smr;SS Override
 39165 000071EF 368F06[FD05]            	POP	word [SS:SAVE_DX]	  ;AN000;EO.;smr;SS Override
 39166 000071F4 36890E[FF05]            	MOV	[SS:SAVE_CX],CX		  ;AN000;EO.;smr;SS Override
 39167 000071F9 36891E[0106]            	MOV	[SS:SAVE_BX],BX		  ;AN000;EO.;smr;SS Override
 39168 000071FE 368C1E[0506]            	MOV	[SS:SAVE_DS],DS		  ;AN000;EO.;smr;SS Override
 39169 00007203 368936[0306]            	MOV	[SS:SAVE_SI],SI		  ;AN000;EO.;smr;SS Override
 39170 00007208 89F2                    	MOV	DX,SI			  ;AN000;EO. ds:dx points to file name
 39171 0000720A 89D8                    	MOV	AX,BX			  ;AN000;EO. ax= mode
 39172 0000720C EB0A                    	JMP	SHORT goopen2		  ;AN000;;EO. do normal
 39173                                  ext_inval2:				  ;AN000;;EO.
 39174                                  	;mov	al,1
 39175 0000720E B001                    	mov	al,error_invalid_function ;AN000;EO.. invalid function
 39176                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39177                                  eo_err:
 39178                                  	;jmp	SYS_RET_ERR
 39179 00007210 EB93                    	jmp	short CreateFail
 39180                                  
 39181                                  ext_inval_parm:				  ;AN000;EO..
 39182 00007212 59                      	POP	CX			  ;AN000;EO..  pop up satck
 39183 00007213 5E                      	POP	SI			  ;AN000;EO..
 39184                                  	;error	error_invalid_data	  ;AN000;EO..  invalid parms
 39185                                  	;mov	al,13
 39186 00007214 B00D                    	mov	al,error_invalid_data
 39187                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39188                                  	;;jmp	SYS_RET_ERR
 39189                                  	;jmp	short eo_err
 39190                                  	; 17/12/2022
 39191 00007216 EB8D                    	jmp	short CreateFail
 39192                                  
 39193                                  	; 17/12/2022	
 39194                                  ;error_return:				  ;AN000;EO.
 39195                                  ;	retn				  ;AN000;EO.. return with error
 39196                                  
 39197                                  goopen2:				  ;AN000;
 39198                                  	; 17/12/2022
 39199                                  	;test	bh,20h				 
 39200 00007218 F6C720                  	test	bh,INT_24_ERROR>>8 ; 04/12/2022
 39201                                  	;;test	bx,2000h
 39202                                  	;TEST	BX,INT_24_ERROR		  ;AN000;EO.. disable INT 24 error ?
 39203 0000721B 7406                    	JZ	short goopen		  ;AN000;EO.. no
 39204                                  	;or	byte [SS:EXTOPEN_ON],2
 39205 0000721D 36800E[F605]02          	OR	byte [SS:EXTOPEN_ON],EXT_OPEN_I24_OFF ;AN000;EO.. set bit to disable;smr;SS Override
 39206                                  goopen:					  ;AN000;
 39207                                  	;or	byte [SS:EXTOPEN_ON],1 
 39208 00007223 36800E[F605]01          	OR	byte [SS:EXTOPEN_ON],EXT_OPEN_ON  ;AN000;EO.. set Extended Open active;smr;SS Override
 39209                                  	;AND	word [SS:EXTOPEN_FLAG],0FFh  ;AN000;EO.create new ?;smr;SS Override
 39210                                  	; 18/12/2022
 39211 00007229 36C606[F505]00          	mov	byte [SS:EXTOPEN_FLAG+1],0 ; AND word [SS:EXTOPEN_FLAG],0FFh
 39212                                  	;cmp	word [SS:EXTOPEN_FLAG],10h
 39213 0000722F 36833E[F405]10          	CMP	word [SS:EXTOPEN_FLAG],EXT_EXISTS_FAIL+EXT_NEXISTS_CREATE ;AN000;FT.;smr;SS Override
 39214 00007235 7516                    	JNZ	short chknext 		  ;AN000;;EO. no
 39215 00007237 E8D0FE                  	call	_$CreateNewFile		  ;AN000;;EO. yes
 39216 0000723A 723F                    	JC	short error_return	  ;AN000;;EO. error
 39217                                  
 39218 0000723C 36803E[F605]00          	CMP	byte [SS:EXTOPEN_ON],0	  ;AN000;;EO. IFS does it;smr;SS Override
 39219 00007242 7438                    	JZ	short ok_return2	  ;AN000;;EO. yes
 39220                                  	;mov	word [SS:EXTOPEN_FLAG],2
 39221 00007244 36C706[F405]0200        	MOV	word [SS:EXTOPEN_FLAG],ACTION_CREATED_OPENED ;AN000;EO. creted/opened;smr;SS Override
 39222 0000724B EB7F                    	JMP	setXAttr		  ;AN000;;EO. set XAs
 39223                                  
 39224                                  	; 17/12/2022
 39225                                  ;ok_return2:
 39226                                  ;	jmp	SYS_RET_OK		  ;AN000;;EO.
 39227                                  
 39228                                  chknext:
 39229                                  	; 17/12/2022
 39230 0000724D 36F606[F405]01          	test	byte [SS:EXTOPEN_FLAG],EXT_EXISTS_OPEN ; 1
 39231                                  	;;test	word [SS:EXTOPEN_FLAG],1
 39232                                  	;TEST	word [SS:EXTOPEN_FLAG],EXT_EXISTS_OPEN ;AN000;;EO. exists open;smr;SS Override
 39233 00007253 752A                    	JNZ	short exist_open	  ;AN000;;EO. yes
 39234 00007255 E8C9FD                  	call	_$CREAT			  ;AN000;;EO. must be replace open
 39235 00007258 7221                    	JC	short error_return	  ;AN000;;EO. return with error
 39236 0000725A 36803E[F605]00          	CMP	byte [SS:EXTOPEN_ON],0	  ;AN000;;EO. IFS does it;smr;SS Override
 39237 00007260 741A                    	JZ	short ok_return2	  ;AN000;;EO. yes
 39238 00007262 36C706[F405]0200        	MOV	word [SS:EXTOPEN_FLAG],ACTION_CREATED_OPENED ;AN000;EO. prsume create/open;smr;SS Override
 39239 00007269 36F606[F605]04          	TEST	byte [SS:EXTOPEN_ON],EXT_FILE_NOT_EXISTS ;AN000;;EO. file not exists ?;smr;SS Override
 39240 0000726F 755B                    	JNZ	short setXAttr		  ;AN000;;EO. no
 39241 00007271 36C706[F405]0300        	MOV	word [SS:EXTOPEN_FLAG],ACTION_REPLACED_OPENED ;AN000;;EO. replaced/opened;smr;SS Override
 39242 00007278 EB52                    	JMP	SHORT setXAttr		  ;AN000;;EO. set XAs
 39243                                  error_return2:
 39244 0000727A F9                      	STC 				  ; Set Carry again to flag error ;AN001;
 39245                                  error_return:	 ;17/12/2022
 39246 0000727B C3                      	retn				  ;AN000;;EO. return with error
 39247                                  
 39248                                  	; 17/12/2022
 39249                                  ok_return:
 39250                                  ok_return2:
 39251 0000727C E9CB93                  	jmp	SYS_RET_OK
 39252                                  
 39253                                  exist_open:				  ;AN000;
 39254 0000727F 36F606[7205]FF          	test	byte [SS:FSHARING],-1	  ;AN000;;EO. server doscall?;smr;SS Override
 39255 00007285 7402                    	jz	short noserver		  ;AN000;;EO. no
 39256 00007287 88E9                    	MOV	CL,CH			  ;AN000;;EO. cl=search attribute
 39257                                  noserver:
 39258 00007289 E8C0FC                  	call	_$Open2			  ;AN000;;EO. do open
 39259 0000728C 732F                    	JNC	short ext_ok		  ;AN000;;EO.
 39260 0000728E 36803E[F605]00          	CMP	byte [SS:EXTOPEN_ON],0	  ;AN000;;EO. error and IFS call;smr;SS Override
 39261 00007294 74E4                    	JZ	short error_return2	  ;AN000;;EO. return with error
 39262                                  local_extopen:
 39263                                  	;cmp	ax,2
 39264 00007296 83F802                  	CMP	AX,error_file_not_found   ;AN000;;EO. file not found error
 39265 00007299 75DF                    	JNZ	short error_return2	  ;AN000;;EO. no,
 39266                                  	;;test	word [SS:EXTOPEN_FLAG],10h
 39267                                  	; 17/12/2022
 39268 0000729B 36F606[F405]10          	test	byte [SS:EXTOPEN_FLAG],EXT_NEXISTS_CREATE ; 10h
 39269                                  	;TEST	word [SS:EXTOPEN_FLAG],EXT_NEXISTS_CREATE ;AN000;;EO. want to fail;smr;SS Override
 39270                                  	;JNZ	short do_creat		  ;AN000;;EO. yes
 39271                                  	;JMP	short extexit 		  ;AN000;;EO. yes
 39272                                  	; 17/12/2022
 39273 000072A1 745D                    	jz	short extexit ; 10/06/2019
 39274                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39275                                  	;jnz	short do_creat
 39276                                  	;jmp	short extexit
 39277                                  do_creat:
 39278 000072A3 368B0E[FF05]            	MOV	CX,[SS:SAVE_CX]		  ;AN000;;EO. get ds:dx for file name;smr;SS Override
 39279 000072A8 36C536[0306]            	LDS	SI,[SS:SAVE_SI]		  ;AN000;;EO. cx = attribute;smr;SS Override
 39280 000072AD 89F2                    	MOV	DX,SI			  ;AN000;;EO.
 39281 000072AF E86FFD                  	call	_$CREAT			  ;AN000;;EO. do create
 39282 000072B2 724C                    	JC	short extexit 		  ;AN000;;EO. error
 39283                                  	;mov	word [SS:EXTOPEN_FLAG],2
 39284 000072B4 36C706[F405]0200        	MOV	word [SS:EXTOPEN_FLAG],ACTION_CREATED_OPENED
 39285                                  					  ;AN000;;EO. is created/opened;smr;SS Override
 39286 000072BB EB0F                    	JMP	SHORT setXAttr		  ;AN000;;EO. set XAs
 39287                                  
 39288                                  ext_ok:
 39289 000072BD 36803E[F605]00          	CMP	byte [SS:EXTOPEN_ON],0	  ;AN000;;EO. IFS call ?;smr;SS Override
 39290 000072C3 74B7                    	JZ	short ok_return		  ;AN000;;EO. yes
 39291                                  	;mov	word [SS:EXTOPEN_FLAG],1
 39292 000072C5 36C706[F405]0100        	MOV	word [SS:EXTOPEN_FLAG],ACTION_OPENED ;AN000;;EO. opened;smr;SS Override
 39293                                  setXAttr:
 39294                                  	; 29/04/2019
 39295 000072CC 50                      	push	ax
 39296 000072CD E8C091                  	call	Get_User_Stack		  ;AN000;;EO.
 39297 000072D0 36A1[F405]              	MOV	AX,[SS:EXTOPEN_FLAG]	  ;AN000;;EO.;smr;SS Override
 39298                                  	;mov	[si+4],ax
 39299 000072D4 894404                  	MOV	[SI+user_env.user_CX],AX  ;AN000;;EO. set action code for cx
 39300 000072D7 58                      	pop	ax			  ;AN000;;EO.
 39301 000072D8 8904                    	mov	[si],ax
 39302                                  	;MOV	[SI+user_env.user_AX],AX  ;AN000;;EO. set handle for ax
 39303                                  	; 17/12/2022
 39304 000072DA EBA0                    	jmp	short ok_return
 39305                                  ;ok_return:				  ;AN000;
 39306                                  	;jmp	SYS_RET_OK		  ;AN000;;EO.
 39307                                  
 39308                                  extexit2:				  ;AN000; ERROR RECOVERY
 39309 000072DC 5B                      	POP	BX			  ;AN000;EO. close the handle
 39310 000072DD 50                      	PUSH	AX			  ;AN000;EO. save error code from set XA
 39311                                  	;cmp	word [SS:EXTOPEN_FLAG],2
 39312 000072DE 36833E[F405]02          	CMP	word [SS:EXTOPEN_FLAG],ACTION_CREATED_OPENED
 39313                                  					  ;AN000;EO. from create;smr;SS Override
 39314 000072E4 750C                    	JNZ	short justopen		  ;AN000;EO.
 39315 000072E6 36C536[0306]            	LDS	SI,[SS:SAVE_SI]		  ;AN000;EO. cx = attribute;smr;SS Override
 39316 000072EB C514                    	LDS	DX,[SI]			  ;AN000;EO.
 39317 000072ED E881FD                  	call	_$UNLINK 		  ;AN000;EO. delete the file
 39318 000072F0 EB03                    	JMP	SHORT reserror		  ;AN000;EO.
 39319                                  
 39320                                  justopen:				  ;AN000;
 39321 000072F2 E886F4                  	call	_$CLOSE			  ;AN000;EO. pretend never happend
 39322                                  reserror:				  ;AN000;
 39323 000072F5 58                      	POP	AX			  ;AN000;EO. restore error code from set XA
 39324 000072F6 EB08                    	JMP	SHORT extexit		  ;AN000;EO.
 39325                                  
 39326                                  ext_file_unfound:			  ;AN000;
 39327                                  	;mov	ax,2
 39328 000072F8 B80200                  	MOV	AX,error_file_not_found   ;AN000;EO.
 39329 000072FB EB03                    	JMP	SHORT extexit		  ;AN000;EO.
 39330                                  ext_inval:				  ;AN000;
 39331                                  	;mov	ax,1
 39332 000072FD B80100                  	MOV	AX,error_invalid_function ;AN000;EO.
 39333                                  lockoperr:	; 17/12/2022
 39334                                  extexit:
 39335 00007300 E95093                  	jmp	SYS_RET_ERR		  ;AN000;EO.
 39336                                  
 39337                                  ;============================================================================
 39338                                  ; LOCK.ASM, MSDOS 6.0, 1991
 39339                                  ;============================================================================
 39340                                  ; 14/07/2018 - Retro DOS v3.0
 39341                                  ; 22/05/2019 - Retro DOS v4.0
 39342                                  
 39343                                  ;BREAK <$LockOper - Lock Calls>
 39344                                  ;----------------------------------------------------------------------------
 39345                                  ;
 39346                                  ;   Assembler usage:
 39347                                  ;	    MOV     BX, Handle	       (DOS 3.3)
 39348                                  ;	    MOV     CX, OffsetHigh
 39349                                  ;	    MOV     DX, OffsetLow
 39350                                  ;	    MOV     SI, LengthHigh
 39351                                  ;	    MOV     DI, LengthLow
 39352                                  ;	    MOV     AH, LockOper
 39353                                  ;	    MOV     AL, Request
 39354                                  ;	    INT     21h
 39355                                  ;
 39356                                  ;   Error returns:
 39357                                  ;	    AX = error_invalid_handle
 39358                                  ;	       = error_invalid_function
 39359                                  ;	       = error_lock_violation
 39360                                  ;
 39361                                  ;   Assembler usage:
 39362                                  ;	    MOV     AX, 5C??	       (DOS 4.00)
 39363                                  ;
 39364                                  ;				    0? lock all
 39365                                  ;				    8? lock write
 39366                                  ;				    ?2 lock multiple
 39367                                  ;				    ?3 unlock multiple
 39368                                  ;				    ?4 lock/read
 39369                                  ;				    ?5 write/unlock
 39370                                  ;				    ?6 add (lseek EOF/lock/write/unlock)
 39371                                  ;	    MOV     BX, Handle
 39372                                  ;	    MOV     CX, count or size
 39373                                  ;	    LDS     DX, buffer
 39374                                  ;	    INT     21h
 39375                                  ;
 39376                                  ;   Error returns:
 39377                                  ;	    AX = error_invalid_handle
 39378                                  ;	       = error_invalid_function
 39379                                  ;	       = error_lock_violation
 39380                                  ;
 39381                                  ;----------------------------------------------------------------------------
 39382                                  
 39383                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 39384                                  _$LockOper:
 39385 00007303 3C01                    	CMP	AL,1
 39386 00007305 770B                    	JA	short lock_bad_func
 39387                                  
 39388 00007307 57                      	PUSH	DI			       ; Save LengthLow
 39389 00007308 E8D5F3                  	call	SFFromHandle		       ; ES:DI -> SFT
 39390 0000730B 731D                    	JNC	short lock_do 		       ; have valid handle
 39391 0000730D 5F                      	POP	DI			       ; Clean stack
 39392                                  	;mov	al,6
 39393 0000730E B006                    	mov	al,error_invalid_handle
 39394                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39395                                  ;lockoperr:
 39396                                  	;jmp	SYS_RET_ERR
 39397                                  	; 17/12/2022
 39398 00007310 EBEE                    	jmp	short lockoperr ; jmp SYS_RET_ERR
 39399                                  
 39400                                  lock_bad_func:
 39401                                  	;mov	byte [ss:EXTERR_LOCUS],1
 39402 00007312 36C606[2303]01          	MOV	byte [SS:EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus;smr;SS Override
 39403                                  	;mov	al,1
 39404 00007318 B001                    	mov	al,error_invalid_function
 39405                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39406                                  lockoperrj:
 39407                                  	;jmp	SYS_RET_ERR
 39408 0000731A EBE4                    	jmp	short lockoperr
 39409                                  
 39410                                  	; 22/05/2019 - Retro DOS v4.0
 39411                                  
 39412                                  	; MSDOS 6.0 
 39413                                  ; Align_buffer call has been deleted, since it corrupts the DTA (6/5/88) P5013
 39414                                  ; Dead code deleted, MD, 23 Mar 90
 39415                                  
 39416                                  ;lock_do:
 39417                                  ;	; MSDOS 3.3
 39418                                  ;	or	al,al
 39419                                  ;	pop	ax
 39420                                  ;	jz	short DOS_Lock
 39421                                  ;DOS_Unlock:
 39422                                  ;	;test	word [es:di+5],8000h
 39423                                  ;	test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 39424                                  ;	JZ	short LOCAL_UNLOCK
 39425                                  ;	push    ax
 39426                                  ;	mov     ax,110Bh
 39427                                  ;	int     2Fh	; Multiplex - NETWORK REDIRECTOR - UNLOCK REGION OF FILE
 39428                                  ;			; BX = file handle, CX:DX = starting offset, SI = high word of size
 39429                                  ;			; STACK: WORD low word of size, ES:DI -> SFT for file
 39430                                  ;			; SFT DPB field -> DPB of drive containing file
 39431                                  ;			; Return: CF set error
 39432                                  ;	pop     bx
 39433                                  ;	jmp     short ValChk
 39434                                  ;
 39435                                  ;LOCAL_UNLOCK:
 39436                                  ;	Call	far [ss:JShare+(7*4)]	; 7 = clr_block ;smr;SS Override
 39437                                  ;ValChk:
 39438                                  ;	JNC	short Lock_OK
 39439                                  ;lockerror:
 39440                                  ;	jmp	SYS_RET_ERR
 39441                                  ;Lock_OK:
 39442                                  ;	;MOV	AX,[SS:Temp_VAR] ;AN000;;MS. AX= number of bytes ;smr;SS Override
 39443                                  ;	jmp	SYS_RET_OK
 39444                                  ;DOS_Lock:
 39445                                  ;	;test	word [es:di+5],8000h
 39446                                  ;	test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 39447                                  ;	JZ	short LOCAL_LOCK
 39448                                  ;	;CallInstall NET_XLock,MultNET,10
 39449                                  ;	mov     ax, 110Ah
 39450                                  ;	int     2Fh	; Multiplex - NETWORK REDIRECTOR - LOCK REGION OF FILE
 39451                                  ;			; BX = file handle, CX:DX = starting offset, SI = high word of size
 39452                                  ;			; STACK: WORD low word of size, ES:DI -> SFT
 39453                                  ;			; SFT DPB field -> DPB of drive containing file, SS = DOS CS
 39454                                  ;			; Return: CF set error
 39455                                  ;	JMP	short ValChk
 39456                                  ;
 39457                                  ;LOCAL_LOCK:
 39458                                  ;	Call	far [ss:JShare+(6*4)]	; 6 = Set_Block ;smr;SS Override
 39459                                  ;	JMP	short ValChk
 39460                                  
 39461                                  ; 17/12/2022
 39462                                  LOCAL_UNLOCK:
 39463                                  	; MSDOS 3.3
 39464                                  	;Call	far [ss:JShare+(7*4)]	; 7 = clr_block ;smr;SS Override
 39465                                  	; MSDOS 6.0
 39466 0000731C FF1E[AC00]              	Call	far [JShare+(7*4)]	; 7 = clr_block ;smr;SS Override
 39467                                  ValChk:
 39468 00007320 7302                    	JNC	short Lock_OK
 39469                                  lockerror:
 39470                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39471                                  	;;jmp	SYS_RET_ERR
 39472                                  	;jmp	short lockoperrj
 39473                                  	; 17/12/2022
 39474 00007322 EBDC                    	jmp	short lockoperr	; jmp SYS_RET_ERR
 39475                                  Lock_OK:
 39476                                  	;MOV	AX,[SS:TEMP_VAR] ;AN000;;MS. AX= number of bytes ;smr;SS Override
 39477                                  	; 10/06/2019
 39478 00007324 A1[0C06]                	mov	ax,[TEMP_VAR]
 39479 00007327 E92093                  	jmp	SYS_RET_OK
 39480                                  
 39481                                  	; 22/05/2019
 39482                                  lock_do:
 39483                                  	; MSDOS 6.0
 39484 0000732A 89C3                    	MOV	BX,AX				; save AX
 39485 0000732C BD[A903]                	MOV	BP,Lock_Buffer			; get DOS LOCK buffer
 39486                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39487                                  	;;mov	[bp+0],dx
 39488                                  	;MOV	[BP+LockBuf.Lock_position],DX	; set low offset
 39489                                  	; 15/12/2022
 39490 0000732F 895600                  	mov	[bp],dx
 39491                                  	;mov	[bp+2],cx
 39492 00007332 894E02                  	MOV	[BP+LockBuf.Lock_position+2],CX; set high offset
 39493 00007335 59                      	POP	CX				; get low length
 39494                                  	;mov	[bp+4],cx
 39495 00007336 894E04                  	MOV	[BP+LockBuf.Lock_length],CX	; set low length
 39496                                  	;mov	[bp+6],si
 39497 00007339 897606                  	MOV	[BP+LockBuf.Lock_length+2],SI	; set high length
 39498 0000733C B90100                  	MOV	CX,1				; one range
 39499                                  
 39500                                  ;	PUSH	CS				;
 39501                                  ;	POP	DS				; DS:DX points to
 39502                                  
 39503 0000733F 16                      	push	ss
 39504 00007340 1F                      	pop	ds
 39505                                  
 39506 00007341 89EA                    	MOV	DX,BP				; Lock_Buffer
 39507                                  	;test	al,1
 39508 00007343 A801                    	TEST	AL,UNLOCK_ALL			; function 1
 39509                                  	;JNZ	short DOS_Unlock		; yes
 39510                                  	;JMP	short DOS_Lock			; function 0
 39511                                  	; 17/12/2022
 39512                                  	; 10/06/2019
 39513 00007345 740E                    	jz	short DOS_Lock
 39514                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39515                                  	;JNZ	short DOS_Unlock
 39516                                  	;JMP	short DOS_Lock
 39517                                  
 39518                                  DOS_Unlock:
 39519                                  	;;test	word [es:di+5],8000h
 39520                                  	;test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 39521 00007347 26F6450680              	test	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
 39522 0000734C 74CE                    	JZ	short LOCAL_UNLOCK
 39523                                  
 39524                                  lock_unlock: ; 22/05/2019
 39525                                  	
 39526                                  	;CallInstall Net_Xlock,MultNET,10
 39527                                  	
 39528                                  	; MSDOS 3.3
 39529                                  	;mov     ax,110Bh
 39530                                  	;int     2Fh	; Multiplex - NETWORK REDIRECTOR - UNLOCK REGION OF FILE
 39531                                  			; BX = file handle, CX:DX = starting offset, SI = high word of size
 39532                                  			; STACK: WORD low word of size, ES:DI -> SFT for file
 39533                                  			; SFT DPB field -> DPB of drive containing file
 39534                                  			; Return: CF set error
 39535                                  	; MSDOS 6.0
 39536 0000734E B80A11                  	mov     ax,110Ah
 39537 00007351 CD2F                    	int     2Fh 	; Multiplex - NETWORK REDIRECTOR - LOCK REGION OF FILE
 39538                                  			; BX = file handle, CX:DX = starting offset, SI = high word of size
 39539                                  			; STACK: WORD low word of size, ES:DI -> SFT
 39540                                  			; SFT DPB field -> DPB of drive containing file, SS = DOS CS
 39541                                  			; Return: CF set error
 39542                                  
 39543 00007353 EBCB                    	JMP	SHORT ValChk
 39544                                  
 39545                                  ; 17/12/2022
 39546                                  %if 0
 39547                                  LOCAL_UNLOCK:
 39548                                  	; MSDOS 3.3
 39549                                  	;Call	far [ss:JShare+(7*4)]	; 7 = clr_block ;smr;SS Override
 39550                                  	; MSDOS 6.0
 39551                                  	Call	far [JShare+(7*4)]	; 7 = clr_block ;smr;SS Override
 39552                                  ValChk:
 39553                                  	JNC	short Lock_OK
 39554                                  lockerror:
 39555                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39556                                  	;jmp	SYS_RET_ERR
 39557                                  	jmp	short lockoperrj
 39558                                  Lock_OK:
 39559                                  	;MOV	AX,[SS:TEMP_VAR] ;AN000;;MS. AX= number of bytes ;smr;SS Override
 39560                                  	; 10/06/2019
 39561                                  	mov	ax,[TEMP_VAR]
 39562                                  	jmp	SYS_RET_OK
 39563                                  %endif
 39564                                  
 39565                                  DOS_Lock:
 39566                                  	;;test	word [es:di+5],8000h
 39567                                  	;test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 39568 00007355 26F6450680              	test	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
 39569 0000735A 7407                    	JZ	short LOCAL_LOCK
 39570                                  
 39571                                  	;CallInstall NET_XLock,MultNET,10
 39572                                  
 39573 0000735C B80A11                  	mov     ax,110Ah
 39574 0000735F CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - LOCK REGION OF FILE
 39575                                  			; BX = file handle, CX:DX = starting offset, SI = high word of size
 39576                                  			; STACK: WORD low word of size, ES:DI -> SFT
 39577                                  			; SFT DPB field -> DPB of drive containing file, SS = DOS CS
 39578                                  			; Return: CF set error
 39579                                  
 39580 00007361 EBBD                    	JMP	short ValChk
 39581                                  
 39582                                  LOCAL_LOCK:
 39583                                  	; MSDOS 3.3
 39584                                  	;Call	far [ss:JShare+(6*4)]	; 6 = Set_Block ;smr;SS Override
 39585                                  	; MSDOS 6.0
 39586 00007363 FF1E[A800]              	Call	far [JShare+(6*4)]	; 6 = Set_Block ;smr;SS Override
 39587                                  
 39588 00007367 EBB7                    	JMP	short ValChk
 39589                                  
 39590                                  ; 14/07/2018 - Retro DOS v3.0
 39591                                  ; LOCK_CHECK
 39592                                  ;MSDOS 6.0 (& MSDOS 3.3)
 39593                                  
 39594                                  ;----------------------------------------------------------------------------
 39595                                  ; Inputs:
 39596                                  ;	Outputs of SETUP
 39597                                  ;	[USER_ID] Set
 39598                                  ;	[PROC_ID] Set
 39599                                  ; Function:
 39600                                  ;	Check for lock violations on local I/O
 39601                                  ;	Retries are attempted with sleeps in between
 39602                                  ; Outputs:
 39603                                  ;    Carry clear
 39604                                  ;	Operation is OK
 39605                                  ;    Carry set
 39606                                  ;	A lock violation detected
 39607                                  ; Outputs of SETUP preserved
 39608                                  ;----------------------------------------------------------------------------
 39609                                  
 39610                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 39611                                  	; 22/05/2019 - Retro DOS v4.0
 39612                                  LOCK_CHECK:
 39613 00007369 8B1E[1A00]              	MOV	BX,[RetryCount]	; Number retries
 39614                                  LockRetry:
 39615 0000736D 53                      	push	bx		; save regs
 39616 0000736E 50                      	push	ax ; MSDOS 6.0
 39617                                  
 39618                                  	;MSDOS 3.3
 39619                                  	;Call	far [ss:JShare+(8*4)]	; 8 = chk_block
 39620                                  	;MSDOS 6.0
 39621 0000736F FF1E[B000]              	Call	far [JShare+(8*4)]	; 8 = chk_block
 39622                                  
 39623 00007373 58                      	pop	ax ; MSDOS 6.0
 39624 00007374 5B                      	pop	bx		; restrore regs
 39625 00007375 7307                    	jnc	short lc_ret_label ; There are no locks (retnc)
 39626                                  LockN:
 39627 00007377 E8D49E                  	call	Idle		; wait a while
 39628 0000737A 4B                      	DEC	BX		; remember a retry
 39629 0000737B 75F0                    	JNZ	short LockRetry	; more retries left...
 39630 0000737D F9                      	STC
 39631                                  lc_ret_label:
 39632 0000737E C3                      	retn
 39633                                  
 39634                                  ; 14/07/2018 - Retro DOS v3.0
 39635                                  ; LOCK_VIOLATION
 39636                                  ;MSDOS 6.0 (& MSDOS 3.3)
 39637                                  
 39638                                  ;----------------------------------------------------------------------------
 39639                                  ; Inputs:
 39640                                  ;	[THISDPB] set
 39641                                  ;	[READOP] indicates whether error on read or write
 39642                                  ; Function:
 39643                                  ;	Handle Lock violation on compatibility (FCB) mode SFTs
 39644                                  ; Outputs:
 39645                                  ;	Carry set if user says FAIL, causes error_lock_violation
 39646                                  ;	Carry clear if user wants a retry
 39647                                  ;
 39648                                  ; DS, ES, DI, CX preserved, others destroyed
 39649                                  ;----------------------------------------------------------------------------
 39650                                  
 39651                                  LOCK_VIOLATION:
 39652 0000737F 1E                      	PUSH	DS
 39653 00007380 06                      	PUSH	ES
 39654 00007381 57                      	PUSH	DI
 39655 00007382 51                      	PUSH	CX
 39656                                  	;mov	ax,21h
 39657 00007383 B82100                  	MOV	AX,error_lock_violation
 39658                                  	;mov	byte [ALLOWED],18h
 39659 00007386 C606[4B03]18            	MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
 39660 0000738B C42E[8A05]              	LES	BP,[THISDPB]
 39661 0000738F BF0100                  	MOV	DI,1		; Fake some registers
 39662 00007392 89F9                    	MOV	CX,DI
 39663                                  	;mov	dx,[es:bp+11]
 39664 00007394 268B560B                	MOV	DX,[ES:BP+DPB.FIRST_SECTOR]
 39665 00007398 E8CFDF                  	call	HARDERR
 39666 0000739B 59                      	POP	CX
 39667 0000739C 5F                      	POP	DI
 39668 0000739D 07                      	POP	ES
 39669 0000739E 1F                      	POP	DS
 39670 0000739F 3C01                    	CMP	AL,1
 39671 000073A1 74DB                    	jz	short lc_ret_label ; 1 = retry, carry clear
 39672 000073A3 F9                      	STC
 39673 000073A4 C3                      	retn
 39674                                  
 39675                                  ; 14/07/2018 - Retro DOS v3.0
 39676                                  
 39677                                  ;----------------------------------------------------------------------------
 39678                                  
 39679                                  ;	do a retz to return error
 39680                                  
 39681                                  	; 22/05/2019 - Retro DOS v4.0
 39682                                  CheckShare:
 39683                                  	; MSDOS 3.3
 39684                                  	;cmp	byte [cs:fShare],0
 39685                                  	;retn
 39686                                  
 39687                                  	; MSDOS 6.0
 39688 000073A5 1E                      	push	ds			;smr;
 39689                                  	;getdseg <ds>			; ds -> dosdata
 39690 000073A6 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 39691 000073AB 803E[0303]00            	cmp	byte [fShare],0
 39692 000073B0 1F                      	pop	ds			;smr;
 39693 000073B1 C3                      	retn
 39694                                  	
 39695                                  ;============================================================================
 39696                                  ; SHARE.ASM, MSDOS 6.0, 1991
 39697                                  ;============================================================================
 39698                                  ; 14/07/2018 - Retro DOS v3.0
 39699                                  ; 22/05/2019 - Retro DOS v4.0
 39700                                  
 39701                                  ; SHARE_CHECK
 39702                                  ;----------------------------------------------------------------------------
 39703                                  ; Inputs:
 39704                                  ;       [THISSFT] Points to filled in local file/device SFT for new
 39705                                  ;               instance of file sf_mode ALWAYS has mode (even on FCB SFTs)
 39706                                  ;       [WFP_START] has full path of name
 39707                                  ;       [USER_ID] Set
 39708                                  ;       [PROC_ID] Set
 39709                                  ; Function:
 39710                                  ;       Check for sharing violations on local file/device access
 39711                                  ; Outputs:
 39712                                  ;    Carry clear
 39713                                  ;       Sharing approved
 39714                                  ;    Carry set
 39715                                  ;       A sharing violation detected
 39716                                  ;           AX is error code
 39717                                  ; USES    ALL but DS
 39718                                  ;----------------------------------------------------------------------------
 39719                                  
 39720                                  	; 22/05/2019 - Retro DOS v4.0
 39721                                  SHARE_CHECK:
 39722                                  	; 26/07/2019
 39723 000073B2 FF1E[9400]              	call	far [JShare+(1*4)] 	; 1 = MFT_Enter
 39724                                  shchk_retn:
 39725 000073B6 C3                      	retn
 39726                                  
 39727                                  ; SHARE_VIOLATION
 39728                                  ;----------------------------------------------------------------------------
 39729                                  ; Inputs:
 39730                                  ;       [THISDPB] Set
 39731                                  ;       AX has error code
 39732                                  ; Function:
 39733                                  ;       Handle Sharing errors
 39734                                  ; Outputs:
 39735                                  ;       Carry set if user says FAIL, causes error_sharing_violation
 39736                                  ;       Carry clear if user wants a retry
 39737                                  ;
 39738                                  ; DS, ES, DI preserved, others destroyed
 39739                                  ;----------------------------------------------------------------------------
 39740                                  
 39741                                  SHARE_VIOLATION:
 39742 000073B7 1E                      	PUSH    DS
 39743 000073B8 06                      	PUSH	ES
 39744 000073B9 57                      	PUSH    DI
 39745 000073BA C606[7505]00            	MOV     byte [READOP],0		; All share errors are reading
 39746                                  	;mov	byte [ALLOWED],18h
 39747 000073BF C606[4B03]18            	MOV     byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
 39748 000073C4 C42E[8A05]              	LES     BP,[THISDPB]
 39749 000073C8 BF0100                  	MOV     DI,1			; Fake some registers
 39750 000073CB 89F9                    	MOV     CX,DI
 39751                                  	;mov	dx,[es:bp+17]
 39752 000073CD 268B5611                	MOV     DX,[ES:BP+DPB.DIR_SECTOR]
 39753 000073D1 E896DF                  	call	HARDERR
 39754 000073D4 5F                      	POP     DI
 39755 000073D5 07                      	POP	ES
 39756 000073D6 1F                      	POP     DS
 39757 000073D7 3C01                    	CMP     AL,1
 39758 000073D9 74DB                    	jz	short shchk_retn	; 1 = retry, carry clear
 39759 000073DB F9                      	STC
 39760 000073DC C3                      	retn
 39761                                  
 39762                                  ;----------------------------------------------------------------------------
 39763                                  ;   ShareEnd - terminate sharing info on a particular SFT/UID/PID. This does
 39764                                  ;       NOT perform a close, it merely asserts that the sharing information
 39765                                  ;       for the SFT/UID/PID may be safely released.
 39766                                  ;
 39767                                  ;   Inputs:     ES:DI points to an SFT
 39768                                  ;   Outputs:    None
 39769                                  ;   Registers modified: all except DS,ES,DI
 39770                                  ;----------------------------------------------------------------------------
 39771                                  
 39772                                  ShareEnd:
 39773                                  	; 26/07/2019
 39774 000073DD FF1E[9800]              	call	far [JShare+(2*4)]	; 2 = MFTClose
 39775 000073E1 C3                      	retn
 39776                                  
 39777                                  ;Break <ShareEnter - attempt to enter a node into the sharing set>
 39778                                  ;----------------------------------------------------------------------------
 39779                                  ;   ShareEnter - perform a retried entry of a nodde into the sharing set. If
 39780                                  ;   the max number of retries is exceeded, we notify the user via int 24.
 39781                                  ;
 39782                                  ;   Inputs:     ThisSFT points to the SFT
 39783                                  ;               WFP_Start points to the WFP
 39784                                  ;   Outputs:    Carry clear => successful entry
 39785                                  ;               Carry set => failed system call
 39786                                  ;   Registers modified: all
 39787                                  ;----------------------------------------------------------------------------
 39788                                  
 39789                                  ShareEnter:
 39790 000073E2 51                      	push	cx
 39791                                  retry:
 39792 000073E3 8B0E[1A00]              	mov     cx,[RetryCount]
 39793                                  attempt:
 39794 000073E7 C43E[9E05]              	les     di,[THISSFT]		; grab sft
 39795 000073EB 31C0                    	XOR     AX,AX
 39796                                   	;mov	[es:di+51],axfff
 39797 000073ED 26894533                	MOV     [ES:DI+SF_ENTRY.sf_MFT],AX ; indicate free SFT
 39798 000073F1 51                      	push	cx
 39799 000073F2 E8BDFF                  	call    SHARE_CHECK             ; attempt to enter into the sharing set
 39800 000073F5 59                      	pop	cx
 39801 000073F6 730A                    	jnc	short done		; success, let the user see this
 39802 000073F8 E8539E                  	call	Idle                    ; wait a while
 39803 000073FB E2EA                    	loop    attempt                 ; go back for another attempt
 39804 000073FD E8B7FF                  	call    SHARE_VIOLATION         ; signal the problem to the user
 39805 00007400 73E1                    	jnc	short retry		; user said to retry, go do it
 39806                                  done:
 39807 00007402 59                      	pop	cx
 39808 00007403 C3                      	retn
 39809                                  
 39810                                  ;============================================================================
 39811                                  ; EXEPATCH.ASM (MSDOS 6.0, 1991)
 39812                                  ;============================================================================
 39813                                  ; 29/04/2019 - Retro DOS 4.0
 39814                                  
 39815                                  ;** EXEPATCH.ASM 
 39816                                  ;----------------------------------------------------------------------------
 39817                                  ;	Contains the foll:
 39818                                  ;
 39819                                  ;		- code to find and overlay buggy unpack code
 39820                                  ;		- new code to be overlayed on buggy unpack code 
 39821                                  ;		- old code sequence to identify buggy unpack code
 39822                                  ;
 39823                                  ;	Revision history:
 39824                                  ;
 39825                                  ;		Created: 5/14/90
 39826                                  ;----------------------------------------------------------------------------
 39827                                  
 39828                                  ;----------------------------------------------------------------------------
 39829                                  ;
 39830                                  ; M020 : Fix for rational bug - for details see routine header
 39831                                  ; M028 : 4b04 implementation
 39832                                  ; M030 : Fixing bug in EXEPACKPATCH (EXEC_CS is an un-relocated value)
 39833                                  ; M032 : set turnoff bit only if DOS in HMA.
 39834                                  ; M033 : if IP < 2 then not exepacked.
 39835                                  ; M046 : support for a 4th version of exepacked files.
 39836                                  ; M068 : support for copy protected apps.
 39837                                  ; M071 : use A20OFF_COUNT of 10.
 39838                                  ;
 39839                                  ;----------------------------------------------------------------------------
 39840                                  
 39841                                  PATCH1_COM_OFFSET	EQU	06CH
 39842                                  PATCH1_OFFSET		EQU	028H
 39843                                  PATCH1_CHKSUM		EQU	0EF4EH
 39844                                  CHKSUM1_LEN		EQU	11CH/2 ; 142
 39845                                  
 39846                                  PATCH2_COM_OFFSET	EQU	076H
 39847                                  PATCH2_OFFSET		EQU	032H
 39848                                  
 39849                                  	; The strings that start at offset 076h have two possible 
 39850                                  	; check sums that are defined as PATCH2_CHKSUM PATCH2A_CHKSUM
 39851                                  
 39852                                  PATCH2_CHKSUM		EQU	78B2H
 39853                                  CHKSUM2_LEN		EQU	119H/2
 39854                                  PATCH2A_CHKSUM		EQU	1C47H		; M046
 39855                                  CHKSUM2A_LEN		EQU	103H/2		; M046
 39856                                  
 39857                                  PATCH3_COM_OFFSET	EQU	074H
 39858                                  PATCH3_OFFSET		EQU	032H
 39859                                  PATCH3_CHKSUM		EQU	4EDEH
 39860                                  CHKSUM3_LEN		EQU	117H/2
 39861                                  
 39862                                  ;**	Data structure passed for ExecReady call
 39863                                  ;
 39864                                  ;struc ERStruc
 39865                                  ; .ER_Reserved:	resw	1	; reserved, should be zero
 39866                                  ; .ER_Flags:	resw	1
 39867                                  ; .ER_ProgName:	resd	1	; ptr to ASCIIZ str of prog name
 39868                                  ; .ER_PSP:	resw	1	; PSP of the program
 39869                                  ; .ER_StartAddr: resd	1	; Start CS:IP of the program
 39870                                  ; .ER_ProgSize:	resd	1	; Program size including PSP
 39871                                  ; .size:
 39872                                  ;endstruc
 39873                                  
 39874                                  ;DOSCODE SEGMENT
 39875                                  
 39876                                  	; 22/05/2019 - Retro DOS v4.0
 39877                                  	; DOSCODE:B3DDh (MSDOS 6.21, MSDOS.SYS)
 39878                                  
 39879                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 39880                                  	; DOSCODE:B37Ah (MSDOS 5.0, MSDOS.SYS)
 39881                                  
 39882                                  ; M028 - BEGIN
 39883                                  
 39884                                  ;--------------------------------------------------------------------------
 39885                                  ;
 39886                                  ;	Procedure Name		: ExecReady
 39887                                  ;
 39888                                  ;	Input			: DS:DX -> ERStruc (see exe.inc)
 39889                                  ;
 39890                                  ;--------------------------------------------------------------------------
 39891                                  
 39892                                  ExecReady:
 39893 00007404 89D6                    	mov	si,dx			; move the pointer into a friendly one
 39894                                  	;;test	word [si+2],1
 39895                                  	; 17/12/2022
 39896 00007406 F6440201                	test	byte [si+ERStruc.ER_Flags],ER_EXE ; 1
 39897                                  	;test	word [si+ERStruc.ER_Flags],ER_EXE ; COM or EXE ?
 39898 0000740A 7413                    	jz	short er_setver		; only setver for .COM files
 39899                                  
 39900                                  	;mov	ax,[si+8]
 39901 0000740C 8B4408                  	mov	ax,[si+ERStruc.ER_PSP]
 39902 0000740F 83C010                  	add	ax,10h
 39903 00007412 8EC0                    	mov	es,ax
 39904                                  
 39905                                  	;mov	cx,[si+10]
 39906 00007414 8B4C0A                  	mov	cx,[si+ERStruc.ER_StartAddr]   ; M030
 39907                                  	;mov	cx,[si+12]
 39908 00007417 8B440C                  	mov	ax,[si+ERStruc.ER_StartAddr+2] ; M030
 39909                                  
 39910                                  	;call	[ss:FixExePatch]
 39911 0000741A 36FF16[F311]            	call	word [ss:FixExePatch] ; 28/12/2022
 39912                                  	
 39913                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 39914                                  	;call	[ss:Rational386PatchPtr]
 39915                                  
 39916                                  er_setver:
 39917                                  	;;test	word [si+2],2		; Q: is this an overlay
 39918                                  	; 17/12/2022
 39919 0000741F F6440202                	test	byte [si+ERStruc.ER_Flags],ER_OVERLAY ; 2
 39920                                  	;test	word [si+ERStruc.ER_Flags],ER_OVERLAY
 39921 00007423 7518                    	jnz	short er_chkdoshi	; Y: set A20OFF_COUNT if DOS high
 39922                                  					; N: set up lie version first
 39923 00007425 1E                      	push	ds
 39924 00007426 56                      	push	si
 39925                                  	;lds	si,[si+4]
 39926 00007427 C57404                  	lds	si,[si+ERStruc.ER_ProgName]
 39927 0000742A E876ED                  	call	Scan_Execname1
 39928 0000742D E887ED                  	call	Scan_Special_Entries
 39929 00007430 5E                      	pop	si
 39930 00007431 1F                      	pop	ds
 39931                                  	;mov	es,[si+8]
 39932 00007432 8E4408                  	mov	es,[si+ERStruc.ER_PSP]
 39933 00007435 36A1[BC0E]              	mov	ax,[ss:SPECIAL_VERSION]
 39934 00007439 26A34000                	mov	[es:PDB.Version],ax
 39935                                  
 39936                                  er_chkdoshi:
 39937 0000743D 36803E[F211]00          	cmp	byte [ss:DosHasHMA],0	; M032: Q: is dos in HMA (M021)
 39938 00007443 741F                    	je	short er_done		; M032: N: done
 39939                                  
 39940                                  					; M068 - Start
 39941                                  	;mov	ax,[si+8]
 39942 00007445 8B4408                  	mov	ax,[si+ERStruc.ER_PSP]	; ax = PSP
 39943                                  
 39944                                  	;or	byte [ss:DOS_FLAG],4
 39945 00007448 36800E[8600]04          	or	byte [ss:DOS_FLAG],EXECA20OFF ; Set bit to signal int 21
 39946                                  					; ah = 25 & ah= 49. See dossym.inc 
 39947                                  					; under TAG M003 & M009 for 
 39948                                  					; explanation
 39949                                  	;;test	word [si+2],1
 39950                                  	; 17/12/2022
 39951 0000744E F6440201                	test	byte [si+ERStruc.ER_Flags],ER_EXE ; 1
 39952                                  	;test	word [si+ERStruc.ER_Flags],ER_EXE ; Q: COM file
 39953 00007452 7507                    	jnz	short er_setA20		; N: inc a20off_count, set 
 39954                                  					;    a20off_psp and ret
 39955 00007454 1E                         	push	ds
 39956 00007455 8ED8                    	mov	ds,ax			; DS = load segment of com file.
 39957 00007457 E88E02                  	call	IsCopyProt		; check if copy protected
 39958 0000745A 1F                      	pop	ds
 39959                                  
 39960                                  er_setA20:
 39961                                  	; We need to inc the A20OFF_COUNT here. Note that if the count
 39962                                  	; is non-zero at this point it indicates that the A20 is to be 
 39963                                  	; turned off for that many int 21 calls made by the app. In 
 39964                                  	; addition the A20 has to be turned off when we exit from this 
 39965                                  	; call. Hence the inc.
 39966                                  
 39967 0000745B 36FE06[8500]            	inc	byte [ss:A20OFF_COUNT]		
 39968 00007460 36A3[6300]              	mov	[ss:A20OFF_PSP],ax	; set the PSP for which A20 is to be
 39969                                  					; turned OFF.
 39970                                  er_done:				; M068 - End
 39971 00007464 31C0                    	xor	ax,ax
 39972 00007466 C3                      	retn
 39973                                  
 39974                                  ; M028 - END
 39975                                  
 39976                                  
 39977                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 39978                                  %if 0
 39979                                  
 39980                                  ;----------------------------------------------------------------------------
 39981                                  ;
 39982                                  ; procedure : Rational386Patch
 39983                                  ;
 39984                                  ; Older versions of the Rational DOS Extender have several bugs which trash
 39985                                  ; 386 registers (usually just the high word of 32 bit registers) during
 39986                                  ; interrupt processing. Lotus 123 3.1+ is a popular application that uses a
 39987                                  ; version of the Rational extender with the 32 bit register trashing bugs.
 39988                                  ;
 39989                                  ; This routine applies patches to the Rational DOS Extender to work around
 39990                                  ; most of the register trashing bugs.
 39991                                  ;
 39992                                  ; Note that there are additional register trashing bugs not fixed by these
 39993                                  ; patches. In particular, the high word of ESP and the FS and GS registers
 39994                                  ; may be modified on interrupts.
 39995                                  ;
 39996                                  ; There are two different Rational DOS Extender patchs in this module.
 39997                                  ; Rational386Patch is to correct 386 register trashing bugs on 386 or later
 39998                                  ; processors. This patch code is executed when MS-DOS is running on a 386
 39999                                  ; or later processor, regardless of whether MS-DOS is running in the HMA
 40000                                  ; or not.
 40001                                  ;
 40002                                  ; The other Rational patch routine (RationalPatch, below) fixes a register
 40003                                  ; trashing problem on 286 processors, and is only executed if MS-DOS is
 40004                                  ; running in the HMA.
 40005                                  ;
 40006                                  ; This patch detection and replacement is based on an example supplied by
 40007                                  ; Ben Williams at Rational.
 40008                                  ;
 40009                                  ;----------------------------------------------------------------------------
 40010                                  
 40011                                  ; 22/05/2019 - Retro DOS v4.0
 40012                                  ; DOSCODE:B448h (MSDOS 6.21, MSDOS.SYS)
 40013                                  
 40014                                  ;----------------------------------------------------------------------------
 40015                                  ;
 40016                                  ; INPUT : ES = segment where program got loaded
 40017                                  ;
 40018                                  ;----------------------------------------------------------------------------
 40019                                  
 40020                                  rpFind1:
 40021                                  	db	0FAh, 0E4h, 21h, 60h, 33h, 0C0h, 0E6h, 43h, 8Bh, 16h
 40022                                  
 40023                                  rpFind1Len equ	$ - rpFind1
 40024                                  
 40025                                  ;	cli
 40026                                  ;	in	al, 21h
 40027                                  ;	pusha
 40028                                  ;	xor	ax, ax
 40029                                  ;	out	43h, al
 40030                                  ;	mov	dx, ...
 40031                                  
 40032                                  rpFind1a:
 40033                                  	db	0B0h, 0Eh, 0E6h, 37h, 33h, 0C0h, 0E6h, 0F2h
 40034                                  
 40035                                  rpFind1aLen equ	$ - rpFind1a
 40036                                  
 40037                                  ;	mov	al, 0Eh
 40038                                  ;	out	37h, al
 40039                                  ;	xor	ax, ax
 40040                                  ;	out	0F2h, al
 40041                                  
 40042                                  ; bug # 1 -- loss of high EAX on 386+ if not VCPI or DPMI
 40043                                  
 40044                                  rpFind2:
 40045                                  	db	0Fh, 20h, 0C0h
 40046                                  
 40047                                  rpFind2Len equ	$ - rpFind2
 40048                                  
 40049                                  ;	mov	eax, cr0	;may be preceeded by PUSH CX (51h)
 40050                                  
 40051                                  rpFind3:
 40052                                  	db	0Fh, 22h, 0C0h, 0EAh
 40053                                  
 40054                                  rpFind3Len equ	$ - rpFind3
 40055                                  
 40056                                  ;	mov	cr0, eax	;may be preceeded by POP CX (59h)
 40057                                  ;	jmp	far ptr xxx	;change far ptr to go to replace3
 40058                                  ;	mov	ss, bx		;8E D3 ... and come back at or after this
 40059                                  
 40060                                  ; note, there is no rpRepl1 string
 40061                                  
 40062                                  rpRepl2:
 40063                                   	db	66h, 50h, 51h, 0Fh, 20h, 0C0h
 40064                                  
 40065                                  rpRepl2Len equ	$ - rpRepl2
 40066                                  
 40067                                  ;	push	eax
 40068                                  ;	push	cx
 40069                                  ;	mov	eax, cr0
 40070                                  
 40071                                  rpRepl3:
 40072                                  	db	8Eh, 0D3h, 59h, 66h, 58h
 40073                                  
 40074                                  rpRepl3Len equ	$ - rpRepl3
 40075                                  
 40076                                  ;	mov	ss, bx
 40077                                  ;	pop	cx
 40078                                  ;	pop	eax
 40079                                  
 40080                                  ; bug # 2 -- loss of high EAX and ESI on 386+ only if VCPI
 40081                                  
 40082                                  rpFind4:
 40083                                  	db	93h, 58h, 8Bh, 0CCh
 40084                                  
 40085                                  rpFind4Len equ	$ - rpFind4
 40086                                  
 40087                                  ;	xchg	bx, ax
 40088                                  ;	pop	ax
 40089                                  ;	mov	cx, sp
 40090                                  
 40091                                  rpFind5:
 40092                                  	db	0B8h, 0Ch, 0DEh, 0CDh, 67h, 8Bh, 0E1h, 0FFh, 0E3h
 40093                                  
 40094                                  rpFind5Len equ	$ - rpFind5
 40095                                  
 40096                                  ;	mov	ax, DE0Ch
 40097                                  ;	int	67h
 40098                                  ;	mov	sp, cx
 40099                                  ;	jmp	bx
 40100                                  
 40101                                  rpRepl4:
 40102                                  	db	93h, 58h, 8Bh, 0CCh
 40103                                  	db	02Eh, 066h, 0A3h
 40104                                  
 40105                                  rpRepl4o1Len equ $ - rpRepl4
 40106                                  
 40107                                  	db	00h, 00h
 40108                                  	db	02Eh, 066h, 89h, 36h
 40109                                  
 40110                                  rpRepl4o2Len equ $ - rpRepl4
 40111                                  
 40112                                  	db	00h, 00h
 40113                                  
 40114                                  rpRepl4Len equ	$ - rpRepl4
 40115                                  
 40116                                  ;	xchg	bx, ax
 40117                                  ;	pop	ax
 40118                                  ;	mov	cx, sp
 40119                                  ;	mov	dword ptr cs:[xxxx], eax
 40120                                  ;	mov	dword ptr cs:[xxxx], esi
 40121                                  
 40122                                  rpRepl5:
 40123                                  	db	8Bh, 0E1h
 40124                                  	db	2Eh, 66h, 0A1h
 40125                                  
 40126                                  rpRepl5o1Len equ $ - rpRepl5
 40127                                  
 40128                                  	db	00h, 00h
 40129                                  	db	2Eh, 66h, 8Bh, 36h
 40130                                  
 40131                                  rpRepl5o2Len equ $ - rpRepl5
 40132                                  
 40133                                  	db	00h, 00h
 40134                                  	db	0FFh, 0E3h
 40135                                  
 40136                                  rpRepl5Len equ	$ - rpRepl5
 40137                                  
 40138                                  ;	mov	sp, cx
 40139                                  ;	mov	eax, dword ptr cs:[xxxx]
 40140                                  ;	mov	esi, dword ptr cs:[xxxx]
 40141                                  ;	jmp	bx
 40142                                  
 40143                                  ; bug # 3 -- loss of high EAX, EBX, ECX, EDX on 386+ only if VCPI
 40144                                  
 40145                                  rpFind6:
 40146                                  	db	0FAh, 52h, 51h
 40147                                  
 40148                                  rpFind6Len equ	$ - rpFind6
 40149                                  
 40150                                  ;	cli
 40151                                  ;	push	dx
 40152                                  ;	push	cx
 40153                                  
 40154                                  rpFind7a:
 40155                                  	db	0B8h, 0Ch, 0DEh, 66h, 26h, 0FFh, 1Eh
 40156                                  
 40157                                  rpFind7aLen equ	$ - rpFind7a
 40158                                  
 40159                                  ;	mov	ax, 0DE0Ch
 40160                                  ;	call	fword ptr es:[xxxx]
 40161                                  
 40162                                  rpFind7b:
 40163                                  	db	59h, 5Ah, 5Bh
 40164                                  
 40165                                  rpFind7bLen equ	$ - rpFind7b
 40166                                  
 40167                                  ;	pop	cx
 40168                                  ;	pop	dx
 40169                                  ;	pop	bx
 40170                                  
 40171                                  rpRepl6 :
 40172                                  	db	0FAh, 66h, 50h, 66h, 53h, 66h, 51h, 66h, 52h
 40173                                  
 40174                                  rpRepl6Len equ	$ - rpRepl6
 40175                                  
 40176                                  ;	cli
 40177                                  ;	push	eax
 40178                                  ;	push	ebx
 40179                                  ;	push	ecx
 40180                                  ;	push	edx
 40181                                  
 40182                                  rpRepl7:
 40183                                  	db	66h, 5Ah, 66h, 59h, 66h, 5Bh, 66h, 58h, 5Bh
 40184                                  
 40185                                  rpRepl7Len equ	$ - rpRepl7
 40186                                  
 40187                                  ;	pop	edx
 40188                                  ;	pop	ecx
 40189                                  ;	pop	ebx
 40190                                  ;	pop	eax
 40191                                  ;	pop	bx
 40192                                  
 40193                                  ; bug # 4 -- loss of high EAX and EBX on 386+ only if VCPI
 40194                                  
 40195                                  rpFind8:
 40196                                   	db	60h, 06h, 1Eh, 0B8h, 00h, 00h, 8Eh, 0D8h
 40197                                  
 40198                                  rpFind8Len equ	$ - rpFind8
 40199                                  
 40200                                  ;	pusha
 40201                                  ;	push	es
 40202                                  ;	push	ds
 40203                                  ;	mov	ax, dgroup	;jump back to here from replace8
 40204                                  ;	mov	ds, ax
 40205                                  
 40206                                  rpFind9 :
 40207                                  	db	1Fh, 07h, 61h
 40208                                  
 40209                                  rpFind9Len equ	$ - rpFind9
 40210                                  
 40211                                  ;	pop	ds
 40212                                  ;	pop	es
 40213                                  ;	popa
 40214                                  
 40215                                  rpRepl8:
 40216                                   	db	66h, 60h, 06h, 1Eh
 40217                                  
 40218                                  rpRepl8Len equ	$ - rpRepl8
 40219                                  
 40220                                  ;	pushad
 40221                                  ;	push	es
 40222                                  ;	push	ds
 40223                                  
 40224                                  rpRepl9:
 40225                                  	db	1Fh, 07h, 66h, 61h, 0C3h
 40226                                  
 40227                                  rpRepl9Len equ	$ - rpRepl9
 40228                                  
 40229                                  ;	pop	ds
 40230                                  ;	pop	es
 40231                                  ;	popad
 40232                                  ;	retn			;no need to jmp back to main-line
 40233                                  
 40234                                  ;----------------------------------------------------------------------------
 40235                                  
 40236                                  struc SearchPair
 40237                                   .sp_off1: resw 1	; offset of 1st search string
 40238                                   .sp_len1: resw 1	; length of 1st search string
 40239                                   .sp_off2: resw 1	; 2nd string
 40240                                   .sp_len2: resw 1	; 2nd string
 40241                                   .sp_diff: resw 1	; max difference between offsets
 40242                                   .size:
 40243                                  endstruc
 40244                                  
 40245                                  ;rpBug1Strs SearchPair	<offset rpFind2, rpFind2Len, offset rpFind3, rpFind3Len, 20h>
 40246                                  
 40247                                  rpBug1Strs:
 40248                                  	dw	rpFind2
 40249                                  	dw	rpFind2Len ; 3
 40250                                  	dw	rpFind3
 40251                                  	dw	rpFind3Len ; 4
 40252                                  	dw	20h
 40253                                  
 40254                                  ;rpBug2Strs SearchPair	<offset rpFind4, rpFind4Len, offset rpFind5, rpFind5Len, 80h>
 40255                                  
 40256                                  rpBug2Strs:
 40257                                  	dw	rpFind4
 40258                                  	dw	rpFind4Len ; 4
 40259                                  	dw	rpFind5
 40260                                  	dw	rpFind5Len ; 9
 40261                                  	dw	80h
 40262                                  
 40263                                  ;rpBug3Strs SearchPair	<offset rpFind6, rpFind6Len, offset rpFind7a, rpFind7aLen, 80h>
 40264                                  
 40265                                  rpBug3Strs:
 40266                                  	dw	rpFind6
 40267                                  	dw	rpFind6Len ; 3
 40268                                  	dw	rpFind7a
 40269                                  	dw	rpFind7aLen ; 7
 40270                                  	dw	80h
 40271                                  
 40272                                  ;rpBug4Strs SearchPair	<offset rpFind8, 4, offset rpFind9, rpFind9Len, 80h>
 40273                                  
 40274                                  rpBug4Strs:
 40275                                  	dw	rpFind8
 40276                                  	dw	4
 40277                                  	dw	rpFind9
 40278                                  	dw	rpFind9Len ; 3
 40279                                  	dw	80h
 40280                                  
 40281                                  ;----------------------------------------------------------------------------
 40282                                  
 40283                                  struc StackVars
 40284                                   .sv_wVersion:	resw 1		; Rational extender version #
 40285                                   .sv_cbCodeSeg: resw 1		; code seg size to scan
 40286                                   .sv_pPatch:	resw 1		; offset of next avail patch byte
 40287                                   .size:
 40288                                  endstruc
 40289                                  
 40290                                  ;----------------------------------------------------------------------------
 40291                                  
 40292                                  ; 22/05/2019 - Retro DOS v4.0
 40293                                  
 40294                                  Rational386Patch:
 40295                                  	; Do a few quick checks to see if this looks like a Rational
 40296                                  	; Extended application. Hopefully this will quickly weed out
 40297                                  	; most non Rational apps.
 40298                                  
 40299                                  	cmp	word [es:0],395		; version number goes here - versions
 40300                                  	jae	short rp3QuickOut	;   3.95+ don't need patching
 40301                                  
 40302                                  	cmp	word [es:0Ch],20h	; always has this value here
 40303                                  	jne	short rp3QuickOut
 40304                                  
 40305                                  	push	ax
 40306                                  
 40307                                  	mov	ax,18h 			; extender has 18h at
 40308                                  	cmp	[es:24],ax		;   offsets 24, 28, & 36
 40309                                  	jne	short rp3QO_ax
 40310                                  	cmp	[es:28],ax
 40311                                  	jne	short rp3QO_ax
 40312                                  	cmp	[es:36],ax
 40313                                  	je	short rp3Maybe
 40314                                  rp3QO_ax:
 40315                                  	pop	ax
 40316                                  rp3QuickOut:
 40317                                  	retn
 40318                                  
 40319                                  ; It might be the rational extender, do more extensive checking
 40320                                  
 40321                                  rp3Maybe:
 40322                                  	cld
 40323                                  	push	bx			; note ax pushed above
 40324                                  	push	cx
 40325                                  	push	dx
 40326                                  	push	si
 40327                                  	push	di
 40328                                  	push	es
 40329                                  	push	ds			; we use all of them
 40330                                  	push	bp
 40331                                  	sub	sp,StackVars.size  ; 6	; make space for stack variables
 40332                                  	mov	bp,sp
 40333                                  
 40334                                  	push	cs
 40335                                  	pop	ds
 40336                                  
 40337                                  	mov	ax,[es:0]		; save version #
 40338                                  	;mov	[bp+StackVars.sv_wVersion],ax
 40339                                  	mov	[bp],ax	
 40340                                  					; check that binary version # matches
 40341                                  	call	VerifyVersion		;   ascii string
 40342                                  	jne	short rp3Exit_j
 40343                                  
 40344                                  ; Looks like this is it, find where to put the patch code.  The
 40345                                  ; patch will be located on top of Rational code specific to 80286
 40346                                  ; processors, so these patchs MUST NOT be applied if running on
 40347                                  ; an 80286 system.
 40348                                  
 40349                                  	; Rational says the code to patch will never be beyond offset 46xxh
 40350                                  
 40351                                  	mov	cx,4500h		; force search len to 4700h (searches
 40352                                  	;mov	[bp+2],cx
 40353                                  	mov	[bp+StackVars.sv_cbCodeSeg],cx	; start at offset 200h)
 40354                                  
 40355                                  	mov	es,[es:20h]		; es=code segment
 40356                                  
 40357                                  	mov	si,rpFind1		; string to find
 40358                                  	mov	dx,rpFind1Len ; 10	; length to match
 40359                                  	call	ScanCodeSeq		; look for code seq
 40360                                  	jz	short rpGotPatch
 40361                                  
 40362                                  ; According to Rational, some very old versions of the extender may not
 40363                                  ; have the find1 code sequence. If the find1 code wasn't found above,
 40364                                  ; try an alternative patch area which is on top of NEC 98xx switching code.
 40365                                  
 40366                                  	mov	si,rpFind1a
 40367                                  	mov	dx,rpFind1aLen  ;8
 40368                                  	call	ScanCodeSeq
 40369                                  	jz	short rpGotPatch
 40370                                  
 40371                                  rp3Exit_j:
 40372                                  	jmp	rp3Exit
 40373                                  
 40374                                  ; Found the location to write patch code! DI = offset in code seg.
 40375                                  
 40376                                  rpGotPatch:
 40377                                  	;mov	[bp+4],di
 40378                                  	mov	[bp-StackVars.sv_pPatch],di	; save patch pointer
 40379                                  
 40380                                  ;----------------------------------------------------------------------------
 40381                                  ; Bug # 1 -- loss of high EAX on 386+ if not VCPI or DPMI
 40382                                  
 40383                                  	;cmp	word [bp+0],381
 40384                                  	;cmp	word [bp+StackVars.sv_wVersion],381 ; only need bug 1 if version
 40385                                  	cmp	word [bp],381
 40386                                  	jae	short rpBug2			;   < 3.81
 40387                                  
 40388                                  	mov	bx,rpBug1Strs			; locate find2 & find3 code
 40389                                  	call	FindBadCode
 40390                                  	jc	short rpBug2
 40391                                  
 40392                                  ; si = rpFind2 offset, di = rpFind3 offset
 40393                                  
 40394                                  	push	di
 40395                                  	mov	di,si				; rpFind2 offset
 40396                                  	mov	dx,rpFind2Len ; 3
 40397                                  
 40398                                  	cmp	byte [es:di-1],51h	 	; find2 preceeded by push cx?
 40399                                  	jne	short rp_no_cx
 40400                                  
 40401                                  	dec	di				;   yes, gobble up push cx too
 40402                                  	inc	dx
 40403                                  rp_no_cx:
 40404                                  	mov	si,rpRepl2			; patch out find2 sequence
 40405                                  	mov	cx,rpRepl2Len  ; 6
 40406                                  	call	GenPatch
 40407                                  
 40408                                  	pop	di				; rpFind3 offset
 40409                                  	cmp	byte [es:di-1],59h 		; find3 preceeded by pop cx?
 40410                                  	jne	short rp_no_cx2
 40411                                  
 40412                                  	mov	byte [es:di-1],90h		;   yes, no-op it
 40413                                  rp_no_cx2:
 40414                                  	;mov	ax,[bp+4]
 40415                                  	mov	ax,[bp+StackVars.sv_pPatch]	; change offset of far jmp
 40416                                  	;mov	[es:di+4],ax
 40417                                  	mov	[es:di+rpFind3Len],ax		;   to go to patch code
 40418                                  
 40419                                  	push	di				; save find3 offset
 40420                                  	mov	si,rpRepl3			; copy repl3 to patch area
 40421                                  	mov	cx,rpRepl3Len ; 5
 40422                                  	call	CopyPatch
 40423                                  
 40424                                  	pop	bx				; find3 offset
 40425                                  	add	bx,rpFind3Len+4	 ; 8		; skip over find3 and far jmp
 40426                                  	call	GenJump 			; jmp back from patch area
 40427                                  	;mov	[bp+4],di
 40428                                  	mov	[bp+StackVars.sv_pPatch], di	;   to main-line, update patch
 40429                                  						;   area pointer
 40430                                  
 40431                                  ;----------------------------------------------------------------------------
 40432                                  ; Bug # 2 -- loss of high regs on 386+ under VCPI only
 40433                                  
 40434                                  rpBug2:
 40435                                  	mov	bx,rpBug2Strs			; locate find4 & find5 code
 40436                                  	call	FindBadCode
 40437                                  	jc	short rpBug3
 40438                                  
 40439                                  ; si = rpFind4 offset, di = rpFind5 offset
 40440                                  
 40441                                  	;push	word [bp+4]
 40442                                  	push	word [bp+StackVars.sv_pPatch]	; save current patch pointer
 40443                                  						;   (where repl4 goes)
 40444                                  	push	di				; save find5 offset
 40445                                  
 40446                                  	mov	di,si
 40447                                  	mov	dx,rpFind4Len ; 4
 40448                                  	mov	si,rpRepl4
 40449                                  	mov	cx,rpRepl4Len ; 15
 40450                                  	call	GenPatch			; patch out find4 code
 40451                                  
 40452                                  	pop	di				; find5 offset
 40453                                  	add	di,5				; keep 5 bytes of find5 code
 40454                                  	;mov	bx,[bp+4]
 40455                                  	mov	bx,[bp+StackVars.sv_pPatch]	; jump to patch area
 40456                                  	push	bx				; save repl5 location
 40457                                  	call	GenJump
 40458                                  
 40459                                  	mov	si,rpRepl5			; copy repl5 code to patch
 40460                                  	mov	cx,rpRepl5Len  ; 15		;   area -- it has a jmp bx
 40461                                  	call	CopyPatch			;   so no need to jmp back to
 40462                                  						;   main-line code
 40463                                  
 40464                                  ; patches have been made, now update the patch code to store/load dwords just
 40465                                  ; after the code in the patch area
 40466                                  
 40467                                  	pop	di				; repl5 location
 40468                                  	pop	si				; repl4 location
 40469                                  
 40470                                  	;mov	ax,[bp+4]
 40471                                  	mov	ax,[bp+StackVars.sv_pPatch]	; (where dwords go)
 40472                                  
 40473                                  	;mov	[es:si+7],ax
 40474                                  	mov	[es:si+rpRepl4o1Len],ax		; offset for EAX
 40475                                  	;mov	[es:di+5],ax
 40476                                  	mov	[es:di+rpRepl5o1Len],ax
 40477                                  	add	ax,4
 40478                                  	;mov	[es:si+0Dh],ax
 40479                                  	mov	[es:si+rpRepl4o2Len],ax		; offset for ESI
 40480                                  	;mov	[es:di+0Bh],ax
 40481                                  	mov	[es:di+rpRepl5o2Len],ax
 40482                                  
 40483                                  	;add	word [bp+4],8
 40484                                  	add	word [bp+StackVars.sv_pPatch],8	; reserve space for 2 dwords in
 40485                                  						; patch area
 40486                                  
 40487                                  ;----------------------------------------------------------------------------
 40488                                  ; Bug # 3 -- loss of high regs on 386+ under VCPI only
 40489                                  
 40490                                  rpBug3:
 40491                                  	mov	bx,rpBug3Strs			; locate find6 & find7a code
 40492                                  	call	FindBadCode
 40493                                  	jc	short rpBug4
 40494                                  
 40495                                  	;add	di,9
 40496                                  	add	di,rpFind7aLen + 2		; skip over offset in find7a
 40497                                  	push	si				;   code and locate find7b
 40498                                  	mov	si,rpFind7b			;   sequence
 40499                                  	mov	dx,rpFind7bLen ; 3
 40500                                  	call	ScanCodeSeq_di
 40501                                  	pop	si
 40502                                  	jnz	short rpBug4
 40503                                  
 40504                                  	push	di				; save find7b code offset
 40505                                  
 40506                                  	mov	di,si
 40507                                  	mov	dx,rpFind6Len ; 3
 40508                                  	mov	si,rpRepl6
 40509                                  	mov	cx,rpRepl6Len ; 9
 40510                                  	call	GenPatch			; patch out find6 code
 40511                                  
 40512                                  	pop	di
 40513                                  	mov	dx,rpFind7bLen ; 3
 40514                                  	mov	si,rpRepl7
 40515                                  	mov	cx,rpRepl7Len ; 9
 40516                                  	call	GenPatch			; patch out find7b code
 40517                                  
 40518                                  ;----------------------------------------------------------------------------
 40519                                  ; Bug # 4 -- loss of high regs on 386+ under VCPI only
 40520                                  
 40521                                  rpBug4:
 40522                                  	;cmp	word [bp+0],360
 40523                                  	;cmp	word [bp+StackVars.sv_wVersion],360 ; only applies if 
 40524                                  	cmp	word [bp],360
 40525                                  	jbe	short rp3Exit 			; version > 3.60 and < 3.95
 40526                                  
 40527                                  	mov	bx,rpBug4Strs			; locate find8 & find9 code
 40528                                  	call	FindBadCode
 40529                                  	jc	short rp3Exit
 40530                                  
 40531                                  	push	di				; save find9 code offset
 40532                                  
 40533                                  	mov	di,si
 40534                                  	mov	dx,3
 40535                                  	mov	si,rpRepl8
 40536                                  	mov	cx,rpRepl8Len ; 4
 40537                                  	call	GenPatch			; patch out find8 code
 40538                                  
 40539                                  	pop	di				; find9 offset
 40540                                  	;mov	bx,[bp+4]
 40541                                  	mov	bx,[bp+StackVars.sv_pPatch]	; patch find9 to jmp to
 40542                                  	call	GenJump 			;   patch area
 40543                                  
 40544                                  	mov	si,rpRepl9			; copy replacement code to
 40545                                  	mov	cx,rpRepl9Len ; 5		;   patch area--it does a RET
 40546                                  	call	CopyPatch			;   so no jmp back to main-line
 40547                                  
 40548                                  rp3Exit:
 40549                                  	add	sp,StackVars.size
 40550                                  	pop	bp
 40551                                  	pop	ds
 40552                                  	pop	es
 40553                                  	pop	di
 40554                                  	pop	si
 40555                                  	pop	dx
 40556                                  	pop	cx
 40557                                  	pop	bx
 40558                                  	pop	ax
 40559                                  	retn
 40560                                  
 40561                                  ;----------------------------------------------------------------------------
 40562                                  ;
 40563                                  ; FindBadCode
 40564                                  ;
 40565                                  ; Searches Rational code segment looking for a pair of find strings (all
 40566                                  ; patches have at least two find strings).
 40567                                  ;
 40568                                  ; Entry:
 40569                                  ;	ES    = code segment to search
 40570                                  ;	DS:BX = search pair structure for this search
 40571                                  ;	[bp].sv_cbCodeSeg = length of code seg to search
 40572                                  ;
 40573                                  ; Exit:
 40574                                  ;	CY flag clear if both strings found, and
 40575                                  ;	SI    = offset in ES of 1st string
 40576                                  ;	DI    = offset in ES of 2nd string
 40577                                  ;	CY set if either string not found, or strings too far apart
 40578                                  ;
 40579                                  ; Used:
 40580                                  ;	CX
 40581                                  ;
 40582                                  ;----------------------------------------------------------------------------
 40583                                  
 40584                                  ;struc SearchPair
 40585                                  ; .sp_off1: resw 1	; offset of 1st search string
 40586                                  ; .sp_len1: resw 1	; length of 1st search string
 40587                                  ; .sp_off2: resw 1	; 2nd string
 40588                                  ; .sp_len2: resw 1	; 2nd string
 40589                                  ; .sp_diff: resw 1	; max difference between offsets
 40590                                  ; .size:
 40591                                  ;endstruc
 40592                                  
 40593                                  FindBadCode:
 40594                                  	;mov	cx,[bp+2]
 40595                                  	mov	cx,[bp+StackVars.sv_cbCodeSeg]	; search length
 40596                                  
 40597                                  	mov	si,[bx]	; mov si,[bx+0]
 40598                                  	;mov	si,[bx+Searchpair.sp_off1] ; ds:si -> search string
 40599                                  	
 40600                                  	;mov	dx,[bx+2]
 40601                                  	mov	dx,[bx+SearchPair.sp_len1] ; dx = search len
 40602                                  	call	ScanCodeSeq
 40603                                  	jnz	short fbc_error		; done if 1st not found
 40604                                  
 40605                                  	push	di			; save 1st string offset
 40606                                  
 40607                                  	;mov	si,[bx+4]
 40608                                  	mov	si,[bx+SearchPair.sp_off2]
 40609                                  	;mov	dx,[bx+6]
 40610                                  	mov	dx,[bx+SearchPair.sp_len2]
 40611                                  	call	ScanCodeSeq_di		; don't change flags after this!
 40612                                  
 40613                                  	pop	si			; restore 1st string offset
 40614                                  	jnz	short fbc_error
 40615                                  
 40616                                  	mov	ax,di			; sanity check that
 40617                                  	sub	ax,si			;   si < di && di - si <= allowed diff
 40618                                  	jc	short fbc_error
 40619                                  	;cmp	ax,[bx+8]
 40620                                  	cmp	ax,[bx+SearchPair.sp_diff]
 40621                                  	ja	short fbc_error
 40622                                  
 40623                                  	clc
 40624                                  	retn
 40625                                  
 40626                                  fbc_error:
 40627                                  	stc
 40628                                  	retn
 40629                                  
 40630                                  ;----------------------------------------------------------------------------
 40631                                  ;
 40632                                  ; GenPatch
 40633                                  ;
 40634                                  ; Generate a patch sequence. 1) insert a jump at the buggy code location
 40635                                  ; (jumps to the patch code area), 2) copy the selected patch code to the
 40636                                  ; patch area, 3) insert a jump from the patch area back to the main-line
 40637                                  ; code.
 40638                                  ;
 40639                                  ; Entry:
 40640                                  ;	ES:DI = start of buggy code to be patched
 40641                                  ;	DX    = length of buggy code to be patched
 40642                                  ;	DS:SI = replacement patch code
 40643                                  ;	CX    = length of replacement patch code
 40644                                  ;	[bp].sv_pPatch = offset in ES of where to copy patch code
 40645                                  ;
 40646                                  ; Exit:
 40647                                  ;	DI, [bp].sv_pPatch = byte after generated patch code
 40648                                  ;
 40649                                  ; Used:
 40650                                  ;	AX, BX, SI, Flags
 40651                                  ;
 40652                                  ;----------------------------------------------------------------------------
 40653                                  
 40654                                  GenPatch:
 40655                                  	push	di			;save offset of buggy code
 40656                                  
 40657                                  	;mov	bx,[bp+4]
 40658                                  	mov	bx,[bp+StackVars.sv_pPatch]
 40659                                  					;jump from buggy code to patch area
 40660                                  	call	GenJump
 40661                                  
 40662                                  	call	CopyPatch		;copy replacement code to patch area
 40663                                  
 40664                                  	pop	bx			;offset of buggy code + buggy code
 40665                                  	add	bx,dx			;  length = return from patch offset
 40666                                  
 40667                                  	call	GenJump 		;jump from patch area back to main-
 40668                                  	;mov	[bp+4],di
 40669                                  	mov	[bp+StackVars.sv_pPatch],di
 40670                                  					;  line code, update patch pointer
 40671                                  	retn
 40672                                  
 40673                                  ;----------------------------------------------------------------------------
 40674                                  ;
 40675                                  ; CopyPatch
 40676                                  ;
 40677                                  ; Copies patch code to patch location.
 40678                                  ;
 40679                                  ; Entry:
 40680                                  ;	DS:SI = patch code to be copied
 40681                                  ;	ES    = segment of code to patch
 40682                                  ;	CX    = length of code to copy
 40683                                  ;	[bp].sv_pPatch = offset in ES of where to copy patch code
 40684                                  ;
 40685                                  ; Exit:
 40686                                  ;	DI, [bp].sv_pPatch = byte after copied patch code
 40687                                  ;
 40688                                  ; Used:
 40689                                  ;	SI, Flags
 40690                                  ;
 40691                                  ;----------------------------------------------------------------------------
 40692                                  
 40693                                  CopyPatch:
 40694                                  	push	cx
 40695                                  	;mov	di,[bp+4]
 40696                                  	mov	di,[bp+StackVars.sv_pPatch] ;patch pointer is the dest offset
 40697                                  	cld
 40698                                  	rep movsb
 40699                                  	pop	cx
 40700                                  	;mov	[bp+4],di
 40701                                  	mov	[bp+StackVars.sv_pPatch],di ;update net pointer location
 40702                                  	retn
 40703                                  
 40704                                  ;----------------------------------------------------------------------------
 40705                                  ;
 40706                                  ; GenJump
 40707                                  ;
 40708                                  ; Generates a rel16 JMP instruction at location 'from' to location 'to'.
 40709                                  ;
 40710                                  ; Entry:
 40711                                  ;	ES:DI = from location (where to put jmp instruction)
 40712                                  ;	BX    = to location (where to jump to)
 40713                                  ;
 40714                                  ; Exit:
 40715                                  ;	DI = byte after generated jump
 40716                                  ;
 40717                                  ; Used:
 40718                                  ;	AX
 40719                                  ;
 40720                                  ;----------------------------------------------------------------------------
 40721                                  
 40722                                  GenJump:
 40723                                  	mov	al,0E9h		; jmp rel16 opcode
 40724                                  	stosb
 40725                                  
 40726                                  	mov	ax,bx		; calc offset to 'to' location
 40727                                  	sub	ax,di
 40728                                  	sub	ax,2
 40729                                  
 40730                                  	stosw			; output offset
 40731                                  
 40732                                  	retn
 40733                                  
 40734                                  ;----------------------------------------------------------------------------
 40735                                  ;
 40736                                  ; ScanCodeSeq
 40737                                  ;
 40738                                  ; Looks for a pattern pointed to by DS:SI & len DX in ES:200 to ES:200+CX-1
 40739                                  ;
 40740                                  ; returns in ES:DI the start of the pattern if Zero flag is set
 40741                                  ;
 40742                                  ;----------------------------------------------------------------------------
 40743                                  
 40744                                  ScanCodeSeq:
 40745                                  	mov	di,200h
 40746                                  ScanCodeSeq_di:
 40747                                  	push	cx
 40748                                  	sub	cx,dx
 40749                                  	inc	cx
 40750                                  scsagain:
 40751                                  	push	si
 40752                                  	push	di
 40753                                  	push	cx
 40754                                  	mov	cx,dx
 40755                                  	rep	cmpsb
 40756                                  	pop	cx
 40757                                  	pop	di
 40758                                  	pop	si
 40759                                  	je	short scsfound
 40760                                  	inc	di
 40761                                  	loop	scsagain
 40762                                  scsfound:
 40763                                  	pop	cx
 40764                                  vvexit:		; 18/12/2022
 40765                                  	retn
 40766                                  	
 40767                                  ;----------------------------------------------------------------------------
 40768                                  ;
 40769                                  ; VerifyVersion
 40770                                  ;
 40771                                  ; Checks whether the binary version from ES:0 matches the ASCII version
 40772                                  ; from ES:2A.
 40773                                  ;
 40774                                  ;       Entry: AX = binary version number 
 40775                                  ;       Exit : Z flag set if version numbers match
 40776                                  ;
 40777                                  ;----------------------------------------------------------------------------
 40778                                  
 40779                                  VerifyVersion:
 40780                                  	mov	si,[es:2Ah]		; offset of version number
 40781                                  					;  in ascii
 40782                                  	mov	bl,10
 40783                                  	add	si,3			; point to last digit
 40784                                  
 40785                                  	call	VVDigit
 40786                                  	jne	short vvexit
 40787                                  	call	VVDigit
 40788                                  	jne	short vvexit
 40789                                  	cmp	byte [es:si],'.'
 40790                                  	jne	short vvexit
 40791                                  	dec	si
 40792                                  	;call	VVDigit
 40793                                  	; 18/12/2022
 40794                                  	;jmp	short VVDigit
 40795                                  ;vvexit:
 40796                                  	;retn
 40797                                  VVDigit:
 40798                                  	div	bl
 40799                                  	add	ah,'0'
 40800                                  	dec	si
 40801                                  	cmp	[es:si+1],ah
 40802                                  	mov	ah,0			; do not xor or sub we need Z
 40803                                  	retn
 40804                                  
 40805                                  %endif
 40806                                  
 40807                                  ;-----------------------------------------------------------------------
 40808                                  
 40809                                  ; 23/05/2019 - Retro DOS v4.0
 40810                                  ; DOSCODE:B702h (MSDOS 6.21, MSDOS.SYS)
 40811                                  
 40812                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 40813                                  ; DOSCODE:B3E0h (MSDOS 5.0, MSDOS.SYS)
 40814                                  
 40815                                  exepatch_start:	 ; label byte
 40816                                  
 40817                                  	; The following is the code that'll be layed over the buggy unpack
 40818                                  	; code.
 40819                                  str1:
 40820 00007467 06                      	db  06h	  		;push	es		 
 40821 00007468 8CD8                    	db  8Ch,0D8h		;mov	ax,ds 
 40822                                  
 40823                                  first_stop equ	$-str1
 40824                                  			
 40825 0000746A 2BC2                    	db  2Bh, 0C2h		;sub	ax, dx			
 40826                                  
 40827                                  first:  ; label	byte
 40828                                  
 40829 0000746C 8ED8                    	db  8Eh,0D8h		;mov	ds,ax			
 40830 0000746E 8EC0                    	db  8Eh,0C0h		;mov	es,ax			
 40831 00007470 BF0F00                  	db  0BFh,0Fh,00h	;mov	di,000FH
 40832 00007473 57                      	db  57h	    		;push	di
 40833 00007474 B91000                  	db  0B9h,10h,00h	;mov	cx,0010H
 40834 00007477 B0FF                    	db  0B0h,0FFh 		;mov	al,0FFH 		
 40835 00007479 F3AE                    	db  0F3h,0AEh 		;repz	scasb			
 40836 0000747B 47                      	db  47h	    		;inc	di			
 40837 0000747C 8BF7                    	db  8Bh,0F7h  		;mov	si,di			
 40838 0000747E 5F                      	db  5Fh	    		;pop	di
 40839 0000747F 58                      	db  58h	    		;pop	ax
 40840                                  
 40841                                  second_stop equ	$-first
 40842                                  
 40843 00007480 2BC2                    	db  2Bh,0C2h  		;sub	ax, dx			
 40844                                  
 40845                                  second: ; label	byte
 40846                                  
 40847 00007482 8EC0                    	db  8Eh,0C0h  		;mov	es,ax			
 40848                                  		    		;NextRec:				
 40849 00007484 B90402                  	db  0B9h,04h,02h	;mov	cx, 0204h
 40850                                  		    		;norm_agn:				
 40851 00007487 8BC6                    	db  8Bh,0C6h		;mov	ax,si			
 40852 00007489 F7D0                    	db  0F7h,0D0h		;not	ax		
 40853 0000748B D3E8                    	db  0D3h,0E8h		;shr	ax,cl		
 40854 0000748D 7413                    	db  74h,13h		;jz	short SI_ok			
 40855 0000748F 8CDA                    	db  8Ch,0DAh		;mov	dx,ds			
 40856 00007491 83CEF0                  	db  83h,0CEh,0F0h	;or	si,0FFF0H
 40857 00007494 2BD0                    	db  2Bh,0D0h		;sub	dx,ax			
 40858 00007496 7308                    	db  73h,08h		;jnc	short SItoDS			
 40859 00007498 F7DA                    	db  0F7h,0DAh		;neg	dx			
 40860 0000749A D3E2                    	db  0D3h,0E2h		;shl	dx,cl			
 40861 0000749C 2BF2                    	db  2Bh,0F2h		;sub	si,dx			
 40862 0000749E 33D2                    	db  33h,0D2h		;xor	dx,dx			
 40863                                  				;SItoDS: 				
 40864 000074A0 8EDA                    	db  8Eh,0DAh		;mov	ds,dx		
 40865                                  				;SI_ok:					
 40866 000074A2 87F7                    	db  87h,0F7h		;xchg	si,di			
 40867 000074A4 1E                      	db  1Eh			;push	ds			
 40868 000074A5 06                      	db  06h			;push	es			
 40869 000074A6 1F                      	db  1Fh			;pop	ds			
 40870 000074A7 07                      	db  07h			;pop	es			
 40871 000074A8 FECD                    	db  0FEh,0CDh		;dec	ch			
 40872 000074AA 75DB                    	db  75h,0DBh		;jnz	short norm_agn		
 40873 000074AC AC                      	db  0ACh		;lodsb			
 40874 000074AD 92                      	db  92h			;xchg	dx,ax
 40875 000074AE 4E                      	db  4Eh			;dec	si
 40876 000074AF AD                      	db  0ADh		;lodsw			
 40877 000074B0 8BC8                    	db  8Bh,0C8h		;mov	cx,ax		
 40878 000074B2 46                      	db  46h			;inc	si		
 40879 000074B3 8AC2                    	db  8Ah,0C2h		;mov	al,dl		
 40880 000074B5 24FE                    	db  24h,0FEh		;and	al,0FEH		
 40881 000074B7 3CB0                    	db  3Ch,0B0h		;cmp	al,RPTREC
 40882 000074B9 7505                    	db  75h,05h		;jne	short TryEnum
 40883 000074BB AC                      	db  0ACh		;lodsb				
 40884 000074BC F3AA                    	db  0F3h,0AAh		;rep stosb			
 40885                                  
 40886                                  ;	db  0EBh,07h,90h	;jmp	short TryNext
 40887 000074BE EB06                    	db  0EBh,06h		;jmp	short TryNext
 40888                                  
 40889                                  				;TryEnum:
 40890 000074C0 3CB2                    	db  3Ch,0B2h		;cmp	al,ENMREC
 40891 000074C2 756C                    	db  75h,6Ch		;jne	short CorruptExe		
 40892 000074C4 F3A4                    	db  0F3h,0A4h		;rep movsb			
 40893                                  				;TryNext:
 40894                                  
 40895 000074C6 92                      	db  92h			;xchg	dx,ax
 40896                                  ;	db  8Ah,0C2h		;mov	al,dl			
 40897                                  
 40898 000074C7 A801                    	db  0A8h,01h		;test	al,1			
 40899 000074C9 74B9                    	db  74h,0B9h		;jz	short NextRec			
 40900 000074CB 9090                    	db  90h,90h		;nop,nop
 40901                                  	
 40902                                  last_stop equ $-second
 40903                                  size_str1 equ $-str1
 40904                                  
 40905                                  	; The following is the code that we need to look for in the exe
 40906                                  	; file.
 40907                                  
 40908                                  scan_patch1: ; label byte
 40909                                  
 40910 000074CD 8CC3                    	db  8Ch,0C3h		;mov	bx,es			
 40911 000074CF 8CD8                    	db  8Ch,0D8h		;mov	ax,ds
 40912 000074D1 2BC2                    	db  2Bh,0C2h		;sub	ax,dx
 40913 000074D3 8ED8                    	db  8Eh,0D8h		;mov	ds,ax			
 40914 000074D5 8EC0                    	db  8Eh,0C0h		;mov	es,ax			
 40915 000074D7 BF0F00                  	db  0BFh,0Fh,00h	;mov	di,000FH
 40916 000074DA B91000                  	db  0B9h,10h,00h	;mov	cx,0010H
 40917 000074DD B0FF                    	db  0B0h,0FFh		;mov	al,0FFH
 40918 000074DF F3AE                    	db  0F3h,0AEh		;repz	scasb			
 40919 000074E1 47                      	db  47h			;inc	di			
 40920 000074E2 8BF7                    	db  8Bh,0F7h		;mov	si,di
 40921 000074E4 8BC3                    	db  8Bh,0C3h		;mov	ax,bx			
 40922 000074E6 2BC2                    	db  2Bh,0C2h		;sub	ax, dx
 40923 000074E8 8EC0                    	db  8Eh,0C0h		;mov	es,ax
 40924 000074EA BF0F00                  	db  0BFh,0Fh,00h	;mov	di,000FH
 40925                                  				;NextRec:
 40926 000074ED B104                    	db  0B1h,04h		;mov	cl,4
 40927 000074EF 8BC6                    	db  8Bh,0C6h		;mov	ax,si
 40928 000074F1 F7D0                    	db  0F7h,0D0h		;not	ax		
 40929 000074F3 D3E8                    	db  0D3h,0E8h		;shr	ax,cl		
 40930 000074F5 7409                    	db  74h,09h		;jz	short SI_ok
 40931 000074F7 8CDA                    	db  8Ch,0DAh		;mov	dx,ds
 40932 000074F9 2BD0                    	db  2Bh,0D0h		;sub	dx,ax
 40933 000074FB 8EDA                    	db  8Eh,0DAh		;mov	ds,dx		
 40934 000074FD 83CEF0                  	db  83h,0CEh,0F0h	;or	si,0FFF0H	       
 40935                                  	       			;SI_ok:
 40936 00007500 8BC7                    	db  8Bh,0C7h		;mov	ax,di		
 40937 00007502 F7D0                    	db  0F7h,0D0h		;not	ax
 40938 00007504 D3E8                    	db  0D3h,0E8h		;shr	ax,cl
 40939 00007506 7409                    	db  74h,09h		;jz	short DI_ok
 40940 00007508 8CC2                    	db  8Ch,0C2h		;mov	dx,es
 40941 0000750A 2BD0                    	db  2Bh,0D0h		;sub	dx,ax
 40942 0000750C 8EC2                    	db  8Eh,0C2h		;mov	es,dx
 40943 0000750E 83CFF0                  	db  83h,0CFh,0F0h	;or	di,0FFF0H
 40944                                  				;DI_ok:
 40945                                  
 40946                                  size_scan_patch1 equ $-scan_patch1
 40947                                  
 40948                                  scan_patch2: ; label byte
 40949                                  			
 40950 00007511 8CC3                    	db  8Ch,0C3h		;mov	bx,es			
 40951 00007513 8CD8                    	db  8Ch,0D8h		;mov	ax,ds
 40952 00007515 48                      	db  48h			;dec	ax
 40953 00007516 8ED8                    	db  8Eh,0D8h		;mov	ds,ax			
 40954 00007518 8EC0                    	db  8Eh,0C0h		;mov	es,ax			
 40955 0000751A BF0F00                  	db  0BFh,0Fh,00h	;mov	di,000FH
 40956 0000751D B91000                  	db  0B9h,10h,00h	;mov	cx,0010H
 40957 00007520 B0FF                    	db  0B0h,0FFh		;mov	al,0FFH
 40958 00007522 F3AE                    	db  0F3h,0AEh		;repz	scasb			
 40959 00007524 47                      	db  47h			;inc	di			
 40960 00007525 8BF7                    	db  8Bh,0F7h		;mov	si,di
 40961 00007527 8BC3                    	db  8Bh,0C3h		;mov	ax,bx			
 40962 00007529 48                      	db  48h			;dec	ax
 40963 0000752A 8EC0                    	db  8Eh,0C0h		;mov	es,ax
 40964 0000752C BF0F00                  	db  0BFh,0Fh,00h	;mov	di,000FH		
 40965                                  				;NextRec:
 40966 0000752F B104                    	db  0B1h,04h		;mov	cl,4
 40967 00007531 8BC6                    	db  8Bh,0C6h		;mov	ax,si
 40968 00007533 F7D0                    	db  0F7h,0D0h		;not	ax		
 40969 00007535 D3E8                    	db  0D3h,0E8h		;shr	ax,cl		
 40970 00007537 740A                    	db  74h,0Ah		;jz	short SI_ok
 40971 00007539 8CDA                    	db  8Ch,0DAh		;mov	dx,ds
 40972 0000753B 2BD0                    	db  2Bh,0D0h		;sub	dx,ax
 40973 0000753D 8EDA                    	db  8Eh,0DAh		;mov	ds,dx		
 40974 0000753F 81CEF0FF                	db  81h,0CEh,0F0h,0FFh
 40975                                  				;or	si,0FFF0H
 40976                                  				;SI_ok:
 40977 00007543 8BC7                    	db  8Bh,0C7h		;mov	ax,di		
 40978 00007545 F7D0                    	db  0F7h,0D0h		;not	ax
 40979 00007547 D3E8                    	db  0D3h,0E8h		;shr	ax,cl
 40980 00007549 740A                    	db  74h,0Ah		;jz	short DI_ok
 40981 0000754B 8CC2                    	db  8Ch,0C2h		;mov	dx,es
 40982 0000754D 2BD0                    	db  2Bh,0D0h		;sub	dx,ax
 40983 0000754F 8EC2                    	db  8Eh,0C2h		;mov	es,dx
 40984 00007551 81CFF0FF                	db  81h,0CFh,0F0h,0FFh
 40985                                  				;or	di,0FFF0H
 40986                                  				;DI_ok:
 40987                                  
 40988                                  size_scan_patch2 equ $-scan_patch2
 40989                                  
 40990                                  scan_patch3: ; label byte
 40991                                  
 40992 00007555 8CC3                    	db  8Ch,0C3h		;mov	bx,es			
 40993 00007557 8CD8                    	db  8Ch,0D8h		;mov	ax,ds
 40994 00007559 48                      	db  48h			;dec	ax
 40995 0000755A 8ED8                    	db  8Eh,0D8h		;mov	ds,ax			
 40996 0000755C 8EC0                    	db  8Eh,0C0h		;mov	es,ax			
 40997 0000755E BF0F00                  	db  0BFh,0Fh,00h	;mov	di,000FH
 40998 00007561 B91000                  	db  0B9h,10h,00h	;mov	cx,0010H
 40999 00007564 B0FF                    	db  0B0h,0FFh		;mov	al,0FFH
 41000 00007566 F3AE                    	db  0F3h,0AEh		;repz	scasb			
 41001 00007568 47                      	db  47h			;inc	di			
 41002 00007569 8BF7                    	db  8Bh,0F7h		;mov	si,di
 41003 0000756B 8BC3                    	db  8Bh,0C3h		;mov	ax,bx			
 41004 0000756D 48                      	db  48h			;dec	ax
 41005 0000756E 8EC0                    	db  8Eh,0C0h		;mov	es,ax
 41006 00007570 BF0F00                  	db  0BFh,0Fh,00h	;mov	di,000FH		
 41007                                  				;NextRec:
 41008 00007573 B104                    	db  0B1h,04h		;mov	cl,4
 41009 00007575 8BC6                    	db  8Bh,0C6h		;mov	ax,si
 41010 00007577 F7D0                    	db  0F7h,0D0h		;not	ax		
 41011 00007579 D3E8                    	db  0D3h,0E8h		;shr	ax,cl		
 41012 0000757B 7409                    	db  74h,09h		;jz	short SI_ok
 41013 0000757D 8CDA                    	db  8Ch,0DAh		;mov	dx,ds
 41014 0000757F 2BD0                    	db  2Bh,0D0h		;sub	dx,ax
 41015 00007581 8EDA                    	db  8Eh,0DAh		;mov	ds,dx	
 41016 00007583 83CEF0                  	db  83h,0CEh,0F0h	;or	si,0FFF0H	
 41017                                  				;SI_ok:
 41018 00007586 8BC7                    	db  8Bh,0C7h		;mov	ax,di		
 41019 00007588 F7D0                    	db  0F7h,0D0h		;not	ax
 41020 0000758A D3E8                    	db  0D3h,0E8h		;shr	ax,cl
 41021 0000758C 7409                    	db  74h,09h		;jz	short DI_ok
 41022 0000758E 8CC2                    	db  8Ch,0C2h		;mov	dx,es
 41023 00007590 2BD0                    	db  2Bh,0D0h		;sub	dx,ax
 41024 00007592 8EC2                    	db  8Eh,0C2h		;mov	es,dx
 41025 00007594 83CFF0                  	db  83h,0CFh,0F0h	;or	di,0FFF0H
 41026                                  				;DI_ok:
 41027                                  
 41028                                  size_scan_patch3 equ $-scan_patch3
 41029                                  
 41030                                  scan_com: ; label byte
 41031                                  
 41032 00007597 AC                      	db  0ACh		;lodsb			
 41033 00007598 8AD0                    	db  8Ah,0D0h		;mov	dl,al		
 41034 0000759A 4E                      	db  4Eh			;dec	si
 41035 0000759B AD                      	db  0ADh		;lodsw			
 41036 0000759C 8BC8                    	db  8Bh,0C8h		;mov	cx,ax		
 41037 0000759E 46                      	db  46h			;inc	si		
 41038 0000759F 8AC2                    	db  8Ah,0C2h		;mov	al,dl		
 41039 000075A1 24FE                    	db  24h,0FEh		;and	al,0FEH		
 41040 000075A3 3CB0                    	db  3Ch,0B0h		;cmp	al,RPTREC
 41041 000075A5 7506                    	db  75h,06h		;jne	short TryEnum
 41042 000075A7 AC                      	db  0ACh		;lodsb				
 41043 000075A8 F3AA                    	db  0F3h,0AAh		;rep stosb			
 41044 000075AA EB0790                  	db  0EBh,07h,90h	;jmp	short TryNext
 41045                                  				;TryEnum:
 41046 000075AD 3CB2                    	db  3Ch,0B2h		;cmp	al,ENMREC
 41047 000075AF 756B                    	db  75h,6Bh		;jne	short CorruptExe		
 41048 000075B1 F3A4                    	db  0F3h,0A4h		;rep movsb			
 41049                                  				;TryNext:
 41050 000075B3 8AC2                    	db  8Ah,0C2h		;mov	al,dl			
 41051 000075B5 A801                    	db  0A8h,01h		;test	al,1			
 41052                                  ;	db  74h,0BAh		;jz	short NextRec			
 41053                                  
 41054                                  size_scan_com	equ	$-scan_com
 41055                                  
 41056                                  ;-----------------------------------------------------------------------
 41057                                  
 41058                                  ; 23/05/2019 - Retro DOS v4.0
 41059                                  ; DOSCODE:B852h (MSDOS 6.21, MSDOS.SYS)
 41060                                  
 41061                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41062                                  ; DOSCODE:B530h (MSDOS 5.0, MSDOS.SYS)
 41063                                  
 41064                                  ExePatch:
 41065                                  	; 28/12/2022 - Retro DOS v4.1
 41066                                  	;call	ExePackPatch
 41067                                  	;;call	word [ss:RationalPatchPtr]
 41068                                  	;retn
 41069                                  	; 28/12/2022
 41070                                  	;jmp	short ExePackPatch
 41071                                  
 41072                                  ;-----------------------------------------------------------------------
 41073                                  ;
 41074                                  ; Procedure Name 	: ExePackPatch
 41075                                  ;
 41076                                  ; Inputs	 	: DS 			-> DOSDATA
 41077                                  ;			  ES:0 			-> read in image
 41078                                  ;			  ax:cx = start cs:ip of program
 41079                                  ; Output		:		
 41080                                  ;
 41081                                  ;	1. If ES <= 0fffh
 41082                                  ;	   2. if exepack signature ('RB') found
 41083                                  ;	      3. if common code to patch compares (for 3 diff. versions)
 41084                                  ;	       	 4. if rest of the code & checksum compares
 41085                                  ;	  	    5. overlay buggy code with code in 
 41086                                  ;		       doscode:str1.
 41087                                  ;		 6. endif
 41088                                  ;	      7. endif
 41089                                  ;	   8. endif
 41090                                  ;	9. endif
 41091                                  ;
 41092                                  ;
 41093                                  ; Uses			: NONE
 41094                                  ;
 41095                                  ;-----------------------------------------------------------------------
 41096                                  		
 41097                                  	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41098                                  	; 23/05/2019 - Retro DOS v4.0	
 41099                                  ExePackPatch:
 41100 000075B7 53                      	push	bx
 41101 000075B8 8CC3                    	mov	bx,es			; bx has load segment
 41102 000075BA 81FBFF0F                	cmp	bx,0FFFh		; Q: is the load segment > 64K
 41103 000075BE 7602                    	jbe	short ep_cont		; N: 
 41104 000075C0 5B                      	pop	bx			; Y: no need to patch
 41105 000075C1 C3                      	retn
 41106                                  ep_cont:
 41107 000075C2 1E                      	push	ds
 41108 000075C3 06                      	push	es
 41109 000075C4 50                      	push	ax
 41110 000075C5 51                      	push	cx
 41111 000075C6 56                      	push	si
 41112 000075C7 57                      	push	di
 41113                                  	
 41114                                  		; M033 - start
 41115                                  		; exepacked programs have an IP of 12h (>=2)
 41116                                  
 41117 000075C8 83E902                  	sub	cx,2			; Q: is IP >=2 
 41118 000075CB 7303                    	jnb	short epp_1		; N: exit
 41119 000075CD E9C500                  	jmp	ep_notpacked
 41120                                  					; ax:cx now points to location of
 41121                                  					; 'RB' if this is an exepacked file.
 41122                                  		; M033 - end
 41123                                  epp_1:
 41124 000075D0 89CF                    	mov	di,cx
 41125 000075D2 8EC0                    	mov	es,ax
 41126 000075D4 36893E[8700]            	mov	[ss:UNPACK_OFFSET],di	; save pointer to 'RB' in 
 41127                                  					; unpack_offset
 41128                                  
 41129 000075D9 26813D5242              	cmp	word [es:di],'RB' ; 4252h
 41130                                  	;ljne	ep_notpacked
 41131 000075DE 7403                    	je	short epp_2
 41132 000075E0 E9B200                  	jmp	ep_notpacked
 41133                                  epp_2:
 41134 000075E3 0E                      	push	cs
 41135 000075E4 1F                      	pop	ds			; set ds to cs
 41136                                  
 41137                                  	;add	di,6Ch
 41138 000075E5 83C76C                  	add	di,PATCH1_COM_OFFSET	; es:di -> points to place in packed 
 41139                                  					;          file where we hope to find
 41140                                  					;	   scan string. 
 41141                                  
 41142 000075E8 E8B200                  	call	chk_common_str		; check for match
 41143                                  
 41144 000075EB 7524                    	jnz	short ep_chkpatch2	; Q: does the patch match
 41145                                  					; N: check at patch2_offset
 41146                                  					; Y: check for rest of patch string
 41147 000075ED BE[CD74]                	mov	si,scan_patch1
 41148                                  					; ds:si -> scan string 
 41149 000075F0 368B3E[8700]            	mov	di,[ss:UNPACK_OFFSET]	; restore di to point to 'RB'
 41150                                  
 41151                                  	;add	di,28h
 41152                                  	; 07/12/2022
 41153 000075F5 83C728                  	add	di,PATCH1_OFFSET	; es:di -> points to place in packed 
 41154                                  					;          file where we hope to find
 41155                                  					;	   scan string. 
 41156                                  	;mov	cx,68
 41157 000075F8 B94400                  	mov	cx,size_scan_patch1
 41158                                  	;mov	bx,142
 41159 000075FB BB8E00                  	mov	bx,CHKSUM1_LEN
 41160                                  	;mov	ax,0EF4Eh
 41161 000075FE B84EEF                  	mov	ax,PATCH1_CHKSUM
 41162 00007601 E8AD00                  	call	chk_patchsum		; check if patch and chk sum compare
 41163 00007604 7208                    	jc	short ep_done1		; Q: did we pass the test
 41164                                  					; N: exit
 41165                                  					; Y: overlay code with new 
 41166 00007606 BE[6774]                	mov	si,str1
 41167                                  	;mov	cx,102
 41168 00007609 B96600                  	mov	cx,size_str1
 41169                                  	
 41170 0000760C F3A4                    	rep	movsb
 41171                                  ep_done1:
 41172 0000760E E98400                  	jmp	ep_done
 41173                                  
 41174                                  ep_chkpatch2:
 41175                                  	;mov	di,76h
 41176 00007611 BF7600                  	mov	di,PATCH2_COM_OFFSET	; es:di -> possible location of patch
 41177                                  					; in another version of unpack
 41178 00007614 E88600                  	call	chk_common_str		; check for match
 41179                                  
 41180 00007617 7544                    	jnz	short ep_chkpatch3	; Q: does the patch match
 41181                                  					; N: check for patch3_offset
 41182                                  					; Y: check for rest of patch string
 41183                                  
 41184 00007619 BE[1175]                	mov	si,scan_patch2
 41185                                  					; ds:si -> scan string 
 41186                                  	;mov	di,32h
 41187 0000761C BF3200                  	mov	di,PATCH2_OFFSET	; es:di -> points to place in packed 
 41188                                  					;          file where we hope to find
 41189                                  	;mov	cx,68			;	   scan string. 
 41190 0000761F B94400                  	mov	cx,size_scan_patch2
 41191                                  	;mov	bx,140
 41192 00007622 BB8C00                  	mov	bx,CHKSUM2_LEN
 41193                                  	;mov	ax,78B2h
 41194 00007625 B8B278                  	mov	ax,PATCH2_CHKSUM
 41195 00007628 E88600                  	call	chk_patchsum		; check if patch and chk sum compare
 41196                                  
 41197                                  					; M046 - Start
 41198                                  					; Q: did we pass the test
 41199 0000762B 7311                    	jnc	short ep_patchcode2		; Y: overlay code with new 
 41200                                  					; N: try with a different chksum
 41201                                  
 41202 0000762D BE[1175]                	mov	si,scan_patch2
 41203                                  					; ds:si -> scan string 
 41204                                  	;mov	cx,68
 41205 00007630 B94400                  	mov	cx,size_scan_patch2
 41206                                  	;mov	bx,129
 41207 00007633 BB8100                  	mov	bx,CHKSUM2A_LEN
 41208                                  	;mov	ax,1C47h
 41209 00007636 B8471C                  	mov	ax,PATCH2A_CHKSUM
 41210 00007639 E87500                  	call	chk_patchsum		; check if patch and chk sum compare
 41211                                  					; Q: did we pass the test
 41212 0000763C 7257                    	jc	short ep_notpacked		; N: try with a different chksum
 41213                                  					; Y: overlay code with new 
 41214                                  						
 41215                                  ep_patchcode2:			       	; M046 - End
 41216 0000763E BE[6774]                	mov	si,str1
 41217                                  	;mov	cx,3
 41218 00007641 B90300                  	mov	cx,first_stop
 41219 00007644 F3A4                    	rep	movsb
 41220 00007646 B89048                  	mov	ax,4890h		; ax = opcodes for dec ax, nop
 41221 00007649 AB                      	stosw
 41222 0000764A 83C602                  	add	si,2
 41223                                  	;mov	cx,20
 41224 0000764D B91400                  	mov	cx,second_stop
 41225 00007650 F3A4                    	rep	movsb
 41226 00007652 AB                      	stosw				; put in dec ax and nop
 41227 00007653 83C602                  	add	si,2
 41228                                  	;mov	cx,75
 41229 00007656 B94B00                  	mov	cx,last_stop
 41230 00007659 F3A4                    	rep	movsb
 41231 0000765B EB38                    	jmp	short ep_done
 41232                                  
 41233                                  ep_chkpatch3:
 41234                                  	;mov	di,74h
 41235 0000765D BF7400                  	mov	di,PATCH3_COM_OFFSET	; es:di -> possible location of patch
 41236                                  					; in another version of unpack
 41237 00007660 E83A00                  	call	chk_common_str		; check for match
 41238                                  
 41239 00007663 7530                    	jnz	short ep_notpacked	; Q: does the patch match
 41240                                  					; N: exit
 41241                                  					; Y: check for rest of patch string
 41242 00007665 BE[5575]                	mov	si,scan_patch3
 41243                                  					; ds:si -> scan string 
 41244                                  	;mov	di,32h
 41245 00007668 BF3200                  	mov	di,PATCH3_OFFSET	; es:di -> points to place in packed 
 41246                                  					;          file where we hope to find
 41247                                  					;	   scan string. 
 41248                                  	;mov	cx,66
 41249 0000766B B94200                  	mov	cx,size_scan_patch3
 41250                                  	;mov	bx,139
 41251 0000766E BB8B00                  	mov	bx,CHKSUM3_LEN
 41252                                  	;mov	ax,4EDEh
 41253 00007671 B8DE4E                  	mov	ax,PATCH3_CHKSUM
 41254 00007674 E83A00                  	call	chk_patchsum		; check if patch and chk sum compare
 41255 00007677 721C                    	jc	short ep_notpacked	; Q: did we pass the test
 41256                                  					; N: exit
 41257                                  					; Y: overlay code with new 
 41258 00007679 BE[6774]                	mov	si,str1
 41259                                  	;mv	cx,3
 41260 0000767C B90300                  	mov	cx,first_stop
 41261 0000767F F3A4                    	rep	movsb
 41262 00007681 B048                    	mov	al,48h			; al = opcode for dec ax
 41263 00007683 AA                      	stosb
 41264 00007684 83C602                  	add	si,2
 41265                                  	;mov	cx,20
 41266 00007687 B91400                  	mov	cx,second_stop
 41267 0000768A F3A4                    	rep	movsb
 41268 0000768C AA                      	stosb				; put in dec ax
 41269 0000768D 83C602                  	add	si,2
 41270                                  	;mov	cx,75
 41271 00007690 B94B00                  	mov	cx,last_stop
 41272 00007693 F3A4                    	rep	movsb
 41273                                  
 41274                                  ep_notpacked:
 41275                                  	;stc
 41276                                  ep_done:
 41277 00007695 5F                      	pop	di
 41278 00007696 5E                      	pop	si
 41279 00007697 59                      	pop	cx
 41280 00007698 58                      	pop	ax
 41281 00007699 07                      	pop	es
 41282 0000769A 1F                      	pop	ds
 41283 0000769B 5B                      	pop	bx
 41284 0000769C C3                      	retn
 41285                                  
 41286                                  ;-------------------------------------------------------------------------
 41287                                  ;
 41288                                  ; 	Procedure Name	: chk_common_str
 41289                                  ;
 41290                                  ;	Input		: DS = DOSCODE
 41291                                  ;			; ES:DI points to string in packed file
 41292                                  ;
 41293                                  ;	Output		; Z if match else NZ
 41294                                  ;
 41295                                  ;-------------------------------------------------------------------------
 41296                                  
 41297                                  	; 23/05/2019 - Retro DOS v4.0
 41298                                  chk_common_str:
 41299 0000769D BE[9775]                	mov	si,scan_com
 41300                                  					; ds:si -> scan string 
 41301                                  	;mov	cx,32
 41302 000076A0 B92000                  	mov	cx,size_scan_com
 41303                                  
 41304 000076A3 F3A6                    	repe	cmpsb	       
 41305                                  
 41306                                  					; M046 - start
 41307                                  	; a fourth possible version of these exepacked programs have a 
 41308                                  	; 056h instead of 06Bh. See scan_com above
 41309                                  	;
 41310                                  	; 	db  75h, 6Bh		;jne CorruptExe		
 41311                                  	;
 41312                                  	; If the mismatch at this point is due to a 56h instead of 6Bh 
 41313                                  	; we shall try to match the rest of the string
 41314                                  	;
 41315                                  
 41316 000076A5 7409                    	jz	short ccs_done
 41317 000076A7 26807DFF56              	cmp	byte [es:di-1],56h
 41318 000076AC 7502                    	jnz	short ccs_done
 41319                                  
 41320 000076AE F3A6                    	repe	cmpsb	    
 41321                                  ccs_done:				; M046 - end
 41322 000076B0 C3                      	retn
 41323                                  
 41324                                  ;-------------------------------------------------------------------------
 41325                                  ;
 41326                                  ;	Procedure Name	: chk_patchsum
 41327                                  ;
 41328                                  ;	Input		: DS:SI -> string we're looking for
 41329                                  ;			: ES:DI -> offset in packed file
 41330                                  ;			: CX 	= scan length
 41331                                  ;			: BX	= length of check sum
 41332                                  ;			: AX 	= value of check sum
 41333                                  ;
 41334                                  ;	Output		: if patch & check sum compare
 41335                                  ;				NC
 41336                                  ;			  else
 41337                                  ;				CY
 41338                                  ;
 41339                                  ;	Uses		: AX, BX, CX, SI
 41340                                  ;
 41341                                  ;-------------------------------------------------------------------------
 41342                                  
 41343                                  	; 23/05/2019 - Retro DOS v4.0
 41344                                  chk_patchsum:
 41345 000076B1 57                      	push	di
 41346                                  
 41347 000076B2 F3A6                    	repe	cmpsb			   
 41348                                  
 41349 000076B4 7518                    	jnz	short cp_fail		; Q: does the patch match
 41350                                  					; N: exit
 41351                                  					; Y:	
 41352                                  
 41353                                  		; we do a check sum starting from the location of the 
 41354                                  		; exepack signature 'RB' up to 11c/2 bytes, the end of the
 41355                                  		; unpacking code.
 41356                                  
 41357 000076B6 368B3E[8700]            	mov	di,[ss:UNPACK_OFFSET]	; di -> start of unpack code
 41358 000076BB 89D9                    	mov	cx,bx			; cx = length of check sum
 41359                                  
 41360 000076BD 89C3                    	mov	bx,ax			; save check sum passed to us in bx
 41361 000076BF 31C0                    	xor	ax,ax
 41362                                  ep_chksum:
 41363 000076C1 260305                  	add	ax,[es:di]
 41364 000076C4 83C702                  	add	di,2
 41365 000076C7 E2F8                    	loop	ep_chksum
 41366                                  
 41367 000076C9 5F                      	pop	di			; restore di
 41368                                  
 41369 000076CA 39D8                    	cmp	ax,bx		 	; Q: does the check sum match
 41370                                  	;jne	short cp_fail		; N: exit
 41371                                  					; Y: 
 41372                                  	; 25/09/2023
 41373                                  	;clc	
 41374                                  	;retn
 41375 000076CC 74E2                    	je	short ccs_done ; cf=0
 41376                                  	
 41377                                  cp_fail:
 41378 000076CE F9                      	stc
 41379 000076CF C3                      	retn
 41380                                  
 41381                                  ; 28/12/2022 - Retro DOS v4.1
 41382                                  %if 0
 41383                                  ;--------------------------------------------------------------------------- 
 41384                                  
 41385                                  
 41386                                  ; M020 : BEGIN
 41387                                  ;
 41388                                  ;---------------------------------------------------------------------------
 41389                                  ;
 41390                                  ; procedure : RationalPatch
 41391                                  ;
 41392                                  ; A routine (in Ration DOS extender) which is invoked at hardware interrupts
 41393                                  ; clobbers CX register on 286 machines. (123 release 3 uses Rational DOS
 41394                                  ; extender). This routine identifies Buggy Rational EXEs and fixes the bug.
 41395                                  ;
 41396                                  ; THE BUG is in the following code sequence:
 41397                                  ;
 41398                                  ;8b 0e 10 00	mov	cx, ds:[10h]		; delay count
 41399                                  ;90		even				; word align
 41400                                  ;e2 fe		loop	$			; wait		CLOBBERS CX
 41401                                  ;e8 xx xx	call	set_A20			; enable A20
 41402                                  ;
 41403                                  ; This patch routine replaces the mov & the loop with a far call into a
 41404                                  ; routine in DOS data segment which is in low memory (because A20 line
 41405                                  ; is off). The routine (RatBugCode) in DOS data saves & restores CX around
 41406                                  ; a mov & loop.
 41407                                  ;
 41408                                  ; Identification of Buggy Rational EXE
 41409                                  ; ====================================
 41410                                  ;
 41411                                  ; (ALL OFFSETS ARE IN THE PROGRAM SECTION - EXCLUDING THE EXE HEADER)
 41412                                  ;
 41413                                  ; OFFSET				Contains
 41414                                  ; ------				--------
 41415                                  ; 0000h			100 times Version number in binary
 41416                                  ;			bug exists in version 3.48 thru 3.83 (both inclusive)
 41417                                  ;
 41418                                  ; 000ah			the WORDS : 0000h, 0020h, 0000h, 0040h, 0001h
 41419                                  ;
 41420                                  ; 002ah			offset where version number is stored in ASCII
 41421                                  ;				e.g. '3.48A'
 41422                                  ;
 41423                                  ; 0030h			offset of copyright string. Copyright strings either
 41424                                  ;			start with "DOS/16M Copyright...." or
 41425                                  ;			"Copyright.....". The string contains
 41426                                  ;			"Rational Systems, Inc."
 41427                                  ;
 41428                                  ; 0020h			word : Paragraph offset of the buggy code segment
 41429                                  ;				from the program image
 41430                                  ; 0016h			word : size of buggy code segment
 41431                                  ;
 41432                                  ;	Buggy code is definite to start after offset 200h in its segment
 41433                                  ;
 41434                                  ;----------------------------------------------------------------------------
 41435                                  
 41436                                  ; 23/05/2019 - Retro DOS v4.0
 41437                                  ; DOSCODE:B976h (MSDOS 6.21, MSDOS.SYS)
 41438                                  
 41439                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41440                                  ; DOSCODE:B654h (MSDOS 5.0, MSDOS.SYS)
 41441                                  
 41442                                  RScanPattern1:
 41443                                  	db	0, 0, 20h, 0, 0, 0, 40h, 0, 1, 0
 41444                                  
 41445                                  RLen1 equ $ - RScanPattern1
 41446                                  
 41447                                  RScanPattern2:
 41448                                  	db	8Bh, 0Eh, 10h, 00h, 90h, 0E2h, 0FEh, 0E8h
 41449                                  
 41450                                  RLen2 equ $ - RScanPattern2
 41451                                  
 41452                                  RScanPattern3:
 41453                                  	db	8Bh, 0Eh, 10h, 00h, 0E2h, 0FEh, 0E8h
 41454                                  
 41455                                  RLen3 equ $ - RScanPattern2
 41456                                  
 41457                                  ; DOSCODE:B98Fh (MSDOS 6.21, MSDOS.SYS)
 41458                                  ; DOSCODE:B66Dh (MSDOS 5.0, MSDOS.SYS)
 41459                                  
 41460                                  ;----------------------------------------------------------------------------
 41461                                  ;
 41462                                  ; INPUT : ES = segment where program got loaded
 41463                                  ;
 41464                                  ;----------------------------------------------------------------------------
 41465                                  
 41466                                  RationalPatch:
 41467                                  	cld
 41468                                  	push	ax
 41469                                  	push	bx
 41470                                  	push	cx
 41471                                  	push	dx
 41472                                  	push	si
 41473                                  	push	di
 41474                                  	push	es
 41475                                  	push	ds			; we use all of them
 41476                                  	mov	di,0Ah			; look for pat1 at offset 0Ah
 41477                                  	push	cs
 41478                                  	pop	ds
 41479                                  	
 41480                                  	mov	si,RScanPattern1
 41481                                  	;mov	cx,10
 41482                                  	mov	cx,RLen1
 41483                                  	rep	cmpsb			; do we have the pattern ?
 41484                                  	jne	short rpexit
 41485                                  	mov	ax,[es:0]
 41486                                  	cmp	ax,348			; is it a buggy version ?
 41487                                  	jb	short rpexit
 41488                                  	cmp	ax,383			; is it a buggy version
 41489                                  	ja	short rpexit
 41490                                  
 41491                                  	call	VerifyVersion
 41492                                  	jne	short rpexit
 41493                                  
 41494                                  	mov	cx,[es:16h]		; Length of buggy code seg
 41495                                  	sub	cx,200h			; Length we search (we start
 41496                                  					;  at offset 200h)
 41497                                  	mov	es,[es:20h]		; es=buggy code segment
 41498                                  	mov	si,RScanPattern2
 41499                                  	;mov	dx,8	
 41500                                  	mov	dx,RLen2
 41501                                  	call	ScanCodeSeq		; look for code seq with nop
 41502                                  	jz	short rpfound
 41503                                  
 41504                                  	mov	si,RScanPattern3
 41505                                  	;mov	dx,15
 41506                                  	mov	dx,RLen3
 41507                                  	call	ScanCodeSeq		; look for code seq w/o nop
 41508                                  	jnz	short rpexit
 41509                                  
 41510                                  rpfound:
 41511                                  	
 41512                                  ;	we set up a far call into DOS data
 41513                                  ;	dx has the length of the code seq we were searching for
 41514                                  
 41515                                  	mov	al,9Ah			; far call opcode
 41516                                  	stosb
 41517                                  	mov	ax,RatBugCode
 41518                                  	stosw
 41519                                  	mov	ax,ss
 41520                                  	stosw
 41521                                  	mov	cx,dx
 41522                                  	sub	cx,6			; filler (with NOPs)
 41523                                  	mov	al,90h
 41524                                  	rep	stosb
 41525                                  rpexit:
 41526                                  	pop	ds
 41527                                  	pop	es
 41528                                  	pop	di
 41529                                  	pop	si
 41530                                  	pop	dx
 41531                                  	pop	cx
 41532                                  	pop	bx
 41533                                  	pop	ax
 41534                                  	retn
 41535                                  
 41536                                  ; M020 END
 41537                                  
 41538                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41539                                  ; (MSDOS 5.0 MSDOS.SYS compatibility)
 41540                                  
 41541                                  ; DOSCODE:B6D8h (MSDOS 5.0, MSDOS.SYS)
 41542                                  
 41543                                  ;----------------------------------------------------------------------------
 41544                                  ;
 41545                                  ; ScanCodeSeq
 41546                                  ;
 41547                                  ; Looks for a pattern pointed to by DS:SI & len DX in ES:200 to ES:200+CX-1
 41548                                  ;
 41549                                  ; returns in ES:DI the start of the pattern if Zero flag is set
 41550                                  ;
 41551                                  ;----------------------------------------------------------------------------
 41552                                  
 41553                                  ScanCodeSeq:
 41554                                  	; 17/12/2022
 41555                                  	mov	di,200h
 41556                                  ;ScanCodeSeq_di:
 41557                                  	push	cx
 41558                                  	sub	cx,dx
 41559                                  	inc	cx
 41560                                  	; 17/12/2022
 41561                                  	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 41562                                  	;mov	di,200h
 41563                                  scsagain:
 41564                                  	push	si
 41565                                  	push	di
 41566                                  	push	cx
 41567                                  	mov	cx,dx
 41568                                  	rep	cmpsb
 41569                                  	pop	cx
 41570                                  	pop	di
 41571                                  	pop	si
 41572                                  	je	short scsfound
 41573                                  	inc	di
 41574                                  	loop	scsagain
 41575                                  scsfound:
 41576                                  	pop	cx
 41577                                  vvexit:		; 18/12/2022
 41578                                  	retn
 41579                                  
 41580                                  
 41581                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41582                                  ; (MSDOS 5.0 MSDOS.SYS compatibility)
 41583                                  
 41584                                  ; DOSCODE:B6F0h (MSDOS 5.0, MSDOS.SYS)
 41585                                  
 41586                                  ;----------------------------------------------------------------------------
 41587                                  ;
 41588                                  ; VerifyVersion
 41589                                  ;
 41590                                  ; Checks whether the binary version from ES:0 matches the ASCII version
 41591                                  ; from ES:2A.
 41592                                  ;
 41593                                  ;       Entry: AX = binary version number 
 41594                                  ;       Exit : Z flag set if version numbers match
 41595                                  ;
 41596                                  ;----------------------------------------------------------------------------
 41597                                  
 41598                                  VerifyVersion:
 41599                                  	mov	si,[es:2Ah]		; offset of version number
 41600                                  					;  in ascii
 41601                                  	mov	bl,10
 41602                                  	add	si,3			; point to last digit
 41603                                  
 41604                                  	call	VVDigit
 41605                                  	jne	short vvexit
 41606                                  	call	VVDigit
 41607                                  	jne	short vvexit
 41608                                  	cmp	byte [es:si],'.' ; 2Eh
 41609                                  	jne	short vvexit
 41610                                  	dec	si
 41611                                  	;call	VVDigit
 41612                                  	; 18/12/2022
 41613                                  	;jmp	short VVDigit
 41614                                  ;vvexit:
 41615                                  	;retn
 41616                                  VVDigit:
 41617                                  	div	bl
 41618                                  	add	ah,'0' ; 30h
 41619                                  	dec	si
 41620                                  	cmp	[es:si+1],ah
 41621                                  	mov	ah,0			; do not xor or sub we need Z
 41622                                  	retn
 41623                                  
 41624                                  ;--------------------------------------------------------------------------- 
 41625                                  %endif	; 28/12/2022
 41626                                  
 41627                                  ;---------------------------------------------------------------------------
 41628                                  ;
 41629                                  ;	M068
 41630                                  ;
 41631                                  ; 	Procedure Name	: IsCopyProt
 41632                                  ;
 41633                                  ;	Inputs		: DS:100 -> start of com file just read in
 41634                                  ;
 41635                                  ;	Outputs		: sets the A20OFF_COUNT variable to 10 if 
 41636                                  ;			  the program loaded in DS:100 uses a MICROSOFT
 41637                                  ;			  copy protect scheme that relies on the A20 line
 41638                                  ;			  being turned off for it's scheme to work.
 41639                                  ;
 41640                                  ;			  Note: The int 21 function dispatcher will turn 
 41641                                  ;				a20 off, if the A20OFF_COUNT is non-zero 
 41642                                  ;				and dec the A20OFF_COUNT before	iretting 
 41643                                  ;				to the user. 
 41644                                  ;
 41645                                  ;	Uses		: ES, DI, SI, CX
 41646                                  ;
 41647                                  ;---------------------------------------------------------------------------
 41648                                  
 41649                                  ; 23/05/2019 - Retro DOS v4.0
 41650                                  
 41651                                  CPStartOffset	EQU	0175h
 41652                                  CPID1Offset	EQU	011Bh
 41653                                  CPID2Offset	EQU	0173h
 41654                                  CPID3Offset	EQU	0146h
 41655                                  CPID4Offset	EQU	0124h
 41656                                  ID1		EQU	05343h
 41657                                  ID2		EQU	05044h
 41658                                  ID3		EQU	0F413h
 41659                                  ID4		EQU	08000h
 41660                                  
 41661                                  ; DOSCODE:B9FAh (MSDOS 6.21, MSDOS.SYS)
 41662                                  
 41663                                  ; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41664                                  ; DOSCODE:B71Ch (MSDOS 5.0, MSDOS.SYS)
 41665                                  
 41666                                  CPScanPattern:
 41667 000076D0 89264801                	db	89h,26h,48h,01h		 ; mov [148],sp
 41668 000076D4 8C0E4C01                	db	8Ch,0Eh,4Ch,01h		 ; mov [14C],cs
 41669 000076D8 C7064A010001            	db	0C7h,06h,4Ah,01h,00h,01h ; mov [14A],100h 
 41670 000076DE 8C0E1301                	db 	8Ch,0Eh,13h,01h		 ; mov [113],cs
 41671 000076E2 B82001                  	db	0B8h,20h,01h		 ; mov ax,120h
 41672 000076E5 BE0001                  	db	0BEh,00h,01h		 ; mov si,100h
 41673                                  
 41674                                  CPSPlen	EQU $ - CPScanPattern
 41675                                  
 41676                                  ; DOSCODE:BA12h (MSDOS 6.21, MSDOS.SYS)
 41677                                  ; DOSCODE:B734h (MSDOS 5.0, MSDOS.SYS)
 41678                                  
 41679                                  IsCopyProt:
 41680 000076E8 813E1B014353            	cmp	word [CPID1Offset],ID1
 41681 000076EE 752D                    	jne	short CP_done
 41682                                  
 41683 000076F0 813E73014450            	cmp	word [CPID2Offset],ID2
 41684 000076F6 7525                    	jne	short CP_done
 41685                                  
 41686 000076F8 813E460113F4            	cmp	word [CPID3Offset],ID3
 41687 000076FE 751D                    	jne	short CP_done
 41688                                  
 41689 00007700 813E24010080            	cmp	word [CPID4Offset],ID4
 41690 00007706 7515                    	jne	short CP_done
 41691                                  
 41692 00007708 0E                      	push	cs
 41693 00007709 07                      	pop	es
 41694 0000770A BF[D076]                	mov	di,CPScanPattern	; es:di -> Pattern to find
 41695                                  
 41696 0000770D BE7501                  	mov	si,CPStartOffset	; ds:si -> possible location 
 41697                                  					; of pattern
 41698                                  
 41699 00007710 B91800                  	mov	cx,CPSPlen ; 24		; cx = length of pattern
 41700 00007713 F3A6                    	repe	cmpsb
 41701 00007715 7506                    	jnz	short CP_done
 41702                                  
 41703 00007717 36C606[8500]0A          	mov	byte [ss:A20OFF_COUNT],0Ah ; M071
 41704                                  CP_done:
 41705 0000771D C3                      	retn
 41706                                  	
 41707                                  ;DOSCODE ENDS
 41708                                  
 41709                                  	;END
 41710                                  
 41711                                  ;----------------------------------------------------------------------------
 41712                                  
 41713                                  ;align 2 ; 05/09/2018 (Error!)
 41714                                  
 41715                                  ; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41716                                  ;align 16 ; 08/09/2018 (OK.)
 41717                                  align 2
 41718                                  
 41719                                  ; 06/08/2018 - Retro DOS v3.0
 41720                                  ;============================================================================
 41721                                  ; MSINIT.ASM
 41722                                  ;============================================================================
 41723                                  ; 22/04/2019 - Retro DOS v4.0 (MSINIT.ASM, MSDOS 6.0, 1991)
 41724                                  ;
 41725                                  ; MAIN ENTRY FOR DOS INITIALIZATION
 41726                                  ;
 41727                                  	; 15/07/2018 - Retro DOS v3.0
 41728                                  	; (MSDOS 3.3, IBMDOS.COM, 1987)
 41729                                  
 41730                                  ; temp iret instruction
 41731                                  
 41732                                  
 41733                                  ; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41734                                  ; DOSCODE:B76Ah (MSDOS 5.0, MSDOS.SYS)
 41735                                  
 41736                                  initiret: ; MSDOS 6.0
 41737                                  SYSBUF:
 41738                                  ;IRETT: ; 06/05/2019
 41739 0000771E CF                      	iret
 41740                                  
 41741                                  ; 22/04/2019 - Retro DOS v4.0
 41742                                  
 41743                                  ; pointer to the BIOS data segment that will be available just to the
 41744                                  ; initialization code
 41745                                  
 41746 0000771F 7000                    InitBioDataSeg:	dw 70h ; KERNEL_SEGMENT = 0070h
 41747                                  
 41748                                  ; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41749                                  ; DOSCODE:B76Dh (MSDOS 5.0, MSDOS.SYS)
 41750                                  
 41751                                  ; Convert AX from a number of bytes to a number of paragraphs (round up).
 41752                                  
 41753                                  ParaRound:
 41754 00007721 83C00F                  	add	ax, 15
 41755 00007724 D1D8                    	rcr	ax, 1
 41756 00007726 D1E8                    	shr	ax, 1
 41757 00007728 D1E8                    	shr	ax, 1
 41758 0000772A D1E8                    	shr	ax, 1
 41759 0000772C C3                      	retn
 41760                                  
 41761                                  ; MAIN ENTRY FOR DOS INITIALIZATION
 41762                                  
 41763                                  	; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41764                                  	; DOSCODE:B779h (MSDOS 5.0, MSDOS.SYS)
 41765                                  	
 41766                                  	; 30/05/2019
 41767                                  	; 22/04/2019 - Retro DOS v4.0
 41768                                  	; 07/07/2018 - Retro DOS v3.0
 41769                                  	; Retro DOS v2.0 - 03/03/2018
 41770                                  	; 03/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41771                                  	; MSDOS 5.0 - MSDOS.SYS, offset 79A9h
 41772                                  DOSINIT:
 41773                                  	; MSDOS 6.21 - MSDOS.SYS, offset 7C77h
 41774                                  	;
 41775                                  	; Far call from SYSINIT
 41776                                  	; DX = Memory size in paragraphs
 41777                                  	; DS:SI = [DEVICE_LIST] (SYSINIT.S) 
 41778                                  	;	  (Retro DOS v2.0, 16/03/2018)
 41779                                  	;
 41780                                  	; ES:DI = ptr to BIOS communication block (sysinit3.s)
 41781                                  	;	  (Retro DOS v4.0, 20/04/2019)
 41782                                  
 41783 0000772D FA                              CLI
 41784 0000772E FC                              CLD
 41785                                  
 41786                                  	; 03/11/2022
 41787                                  	;push	dx ; 30/05/2019		; save parameters from BIOS
 41788                                  	
 41789                                  	; 17/12/2022
 41790                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 41791                                  	;push	dx ; =*=		; save parameters from BIOS
 41792                                  	
 41793 0000772F 56                      	push	si
 41794 00007730 1E                      	push	ds
 41795 00007731 57                      	push	di			;save di (ptr to BiosComBlock)
 41796                                  
 41797 00007732 8CC3                    	mov	bx,es			;bx:di = ptr to BiosComBlock
 41798                                  
 41799                                  ; First, move the DOS data segment to its final location in low memory
 41800                                  
 41801                                  	;;mov	ax,0BF69h ; MSDOS 6.21 MSDOS.SYS, file offset 7C7Fh
 41802                                  	;mov	ax,0BC77h ; MSDOS 5.0 MSDOS.SYS, file offset 79B1h	
 41803 00007734 B8[AE7B]                	mov	ax,MEMSTRT		; get offset of end of init code
 41804                                  
 41805                                  	;add	ax,15	; 0Fh		; round to nearest paragraph
 41806                                  	;and	ax,~15	; 0FFF0h	; boundary
 41807                                  
 41808                                  	;mov	si,ax			; si = offset of DOSDATA in current 
 41809                                  					; code segment
 41810                                  
 41811                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 41812 00007737 83C00F                  	add	ax,15			; round to nearest paragraph
 41813 0000773A 83E0F0                  	and	ax,~15			; boundary
 41814                                  
 41815 0000773D 89C6                    	mov	si,ax			; si = offset of DOSDATA in current 
 41816                                  					; code segment
 41817                                  	; 05/12/2022
 41818                                  	; 30/04/2019 - Retro DOS v4.0
 41819                                  	;xor	si,si
 41820                                  	
 41821 0000773F 8CC8                    	mov	ax,cs
 41822 00007741 8ED8                    	mov	ds,ax			; ds = current code segment
 41823                                  					; DS:SI now points to dosdata
 41824                                  
 41825                                  	;mov	es,[cs:0BA49h] ; MSDOS 6.21 IO.SYS, offset 7C8Eh 
 41826                                  	;mov	es,[cs:InitBioDataSeg]	; First access to DosDataSg in
 41827                                  					;  BData segment. Cannot use
 41828                                  					;  getdseg macro here!!!
 41829                                  	; 17/12/2022
 41830 00007743 8E06[1F77]              	mov	es,[InitBioDataSeg]
 41831                                  	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 41832                                  	;mov	es,[cs:InitBioDataSeg]  ; ds = cs !
 41833                                  
 41834                                  	;mov	es,[es:3]
 41835 00007747 268E060300              	mov	es,[es:DosDataSg]	; Get free location in low memory
 41836                                  
 41837 0000774C 31FF                    	xor	di,di			; ES:DI now points to RAM data
 41838                                  
 41839                                  	;mov	cx,4970  ; Offset 0BA78h in MSDOS 6.21 MSDOS.SYS)
 41840                                  	;mov	cx,4976  ; 25/05/2019
 41841                                  	; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 41842                                  	;mov	cx,4962
 41843                                  	;mov	cx,MSDAT001E		; get end of dosdata = size of dosdata
 41844 0000774E B9A512                  	mov	cx,DOSDATASIZE ; = 4962 for MSDOS 5.0 MSDOS.SYS
 41845 00007751 F3A4                    	rep	movsb			; move data to final location
 41846                                  	
 41847 00007753 5F                      	pop	di			; restore ptr to BiosComBlock
 41848 00007754 1F                      	pop	ds			; restore parms from BIOS
 41849 00007755 5E                      	pop	si
 41850                                  	; 17/12/2022
 41851                                  	;pop	dx ; 30/05/2019	
 41852                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 41853                                  	;pop	dx ; =*=		
 41854                                  
 41855 00007756 06                      	push	es
 41856 00007757 1E                      	push	ds
 41857 00007758 07                      	pop	es			; es:si -> device chain
 41858 00007759 1F                      	pop	ds			; ds points to dosdata
 41859                                  
 41860                                  ;SR;
 41861                                  ;We get a ptr to the BIOS exchange data block. This has been setup right 
 41862                                  ;now so that the EXEC call knows when SysInit is present to do the special
 41863                                  ;lie table handling for device drivers. This can be expanded later on to
 41864                                  ;establish a communication block from the BIOS to the DOS.
 41865                                  
 41866                                  	;mov	[1040h],di	; Offset 0BA87h in MSDOS 6.21 MSDOS.SYS)
 41867                                  	;mov	[1042h],bx
 41868 0000775A 893E[3F10]              	mov	[BiosDataPtr],di
 41869 0000775E 891E[4110]              	mov	[BiosDataPtr+2],bx	; save ptr to BiosComBlock
 41870                                  
 41871 00007762 2E8C1E[0700]            	mov	[cs:DosDSeg],ds		; set pointer to dosdata in code seg
 41872                                  
 41873                                  	; Set the segment of Lowint23/24/28Addr in msctrlc.asm to dosdata
 41874                                  
 41875 00007767 2E8C1E[1051]            	mov	[cs:LowInt23Addr+2],ds	; set pointers in code seg
 41876 0000776C 2E8C1E[1451]            	mov	[cs:LowInt24Addr+2],ds
 41877 00007771 2E8C1E[1851]            	mov	[cs:LowInt28Addr+2],ds
 41878                                  
 41879                                  	;mov	[346h],dx	; MSDOS 6.21 DOSDATA addresses
 41880                                  	;mov	[584h],sp
 41881                                  	;mov	[586h],ss
 41882 00007776 8916[4603]                  	mov	[ENDMEM],dx	; =*=
 41883 0000777A 8926[8405]              	mov	[USER_SP],sp
 41884 0000777E 8C16[8605]              	mov	[USER_SS],ss
 41885                                  
 41886 00007782 8CD8                    	mov	ax,ds		; set up ss:sp to dosdata:dskstack
 41887 00007784 8ED0                    	mov	ss,ax
 41888                                  
 41889                                  	;mov	sp,920h		; MSDOS 6.21 DOSDATA address
 41890                                  	;mov	sp,offset dosdata:dskstack
 41891 00007786 BC[2009]                	mov	sp,DSKSTACK
 41892                                  
 41893                                  ;M023
 41894                                  ; Init patch ptrs to default values
 41895                                  
 41896                                  	;mov	word [1212h],RetExePatch
 41897                                  	;mov	word [1214h],RetExePatch
 41898                                  	;mov	word [61h],RetExePatch
 41899 00007789 C706[F311][8962]        	mov	word [FixExePatch],RetExePatch	; M023
 41900                                  	; 28/12/2022 - Retro DOS v4.1
 41901                                  	;mov	word [RationalPatchPtr],RetExePatch ; M023
 41902 0000778F C706[6100][8962]        	mov	word [ChkCopyProt],RetExePatch	; M068
 41903                                  
 41904                                  ; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 41905                                  %if 0	; 19/09/2023
 41906                                  
 41907                                  ; Setup to call 386 Rational DOS Extender patch routine if running on
 41908                                  ; a 386 or later. Unlike other patches, this is not dependent on MS-DOS
 41909                                  ; running in the HMA.
 41910                                  
 41911                                  	call	WhatCPUType	; get cpu type (0 < 286,1==286,2 >= 386)
 41912                                  	cmp	al,2		;   386 or later?
 41913                                  	mov	ax,Rational386Patch
 41914                                  	jae	short di_set_patch
 41915                                  	mov	ax,RetExePatch	; < 386, don't need this patch
 41916                                  di_set_patch:
 41917                                  	mov	[Rational386PatchPtr],ax ; patch routine or RET instr.
 41918                                  
 41919                                  %endif
 41920                                  	; Set up the variable temp_dosloc to point to the dos code segment
 41921                                  
 41922 00007795 8CC8                    	mov	ax,cs		; ax = current segment of DOS code
 41923                                  
 41924                                  	; ax now holds segment of DOS code
 41925 00007797 A3[AA0A]                	mov	[TEMP_DOSLOC],ax   ; store temp location of DOS
 41926                                  
 41927 0000779A 8C06[4A00]              	mov	word [NULDEV+2],es ; nuldev -> points to device chain
 41928 0000779E 8936[4800]              	mov	word [NULDEV],si
 41929                                  ;SR;
 41930                                  ; There are some locations in the Win386 instance data structures
 41931                                  ; which need to be set up with the DOS data segment. First, initialize
 41932                                  ; the segment part of the instance table pointer in the SIS.
 41933                                  
 41934                                  	;mov	[0FF2h],ds ; [Win386_Info+14+2]	
 41935 000077A2 8C1E[F10F]              	mov	[Win386_Info+Win386_SIS.Instance_Data_Ptr+2],ds
 41936                                  
 41937                                  ; Now initialize the segment part of the pointer to the data in each
 41938                                  ; instance table entry.
 41939                                  
 41940 000077A6 56                      	push	si		; preserve pointer to device chain
 41941                                  	; 18/12/2022
 41942                                  	; cx = 0
 41943 000077A7 B107                    	mov	cl,7
 41944                                  	;mov	cx,7		; There are 7 entries in the instance table
 41945                                  				; M019
 41946                                  	;mov	si,0FF6h ; offset (dosdata:Instance_Table+2)
 41947 000077A9 BE[F50F]                	mov	si,Instance_Table+2 ; point si to segment field
 41948                                  Instance_init_loop:
 41949 000077AC 8C1C                    	mov	[si],ds		; set offset in instance entry
 41950                                  	;add	si,6
 41951 000077AE 83C606                  	add	si,size_of_Win386_IIS ; move on to next entry
 41952 000077B1 E2F9                    	loop	Instance_init_loop
 41953                                  
 41954                                  ;Initialize the WIN386 2.xx instance table with the DOS data segment value
 41955                                  
 41956                                  	; 18/12/2022
 41957 000077B3 B105                    	mov	cl,5
 41958                                  	;mov	cx,5		; There are five entries in the instance table
 41959                                  
 41960                                  	;mov	si,(offset dosdata:OldInstanceJunk) + 6
 41961                                  	;mov	si,11EDh	; point si to segment field
 41962 000077B5 BE[CE11]                	mov	si,OldInstanceJunk+6
 41963                                  OldInstance_init_loop:
 41964 000077B8 8C1C                    	mov	[si],ds		; set offset in instance entry
 41965 000077BA 83C606                  	add	si,6		; move on to next entry
 41966 000077BD E2F9                    	loop	OldInstance_init_loop
 41967 000077BF 5E                      	pop	si		; restore pointer to device chain
 41968                                  
 41969                                  ; End of WIN386 2.xx compatibility bullshit
 41970                                  
 41971                                  ; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 41972                                  %if 0	
 41973                                     	; 30/04/2019
 41974                                  	;push	es
 41975                                  	;pop	ds
 41976                                  			; ds:si points to console device
 41977                                  
 41978                                  	; 24/04/2019 - Retro DOS v4.0
 41979                                  
 41980                                  	; 15/07/2018
 41981                                  	; MSDOS 3.3 (IBMDOS.COM, 1987)
 41982                                  	; (Set INT 2Ah handler address to an 'IRET')
 41983                                  
 41984                                  	; need crit vector inited to use deviocall
 41985                                  	;push	ds			; preserve segment of device chain
 41986                                  	push	es ; 30/04/2019
 41987                                  
 41988                                  %endif
 41989                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 41990 000077C0 06                      	push	es
 41991                                  	; 17/12/2022
 41992                                  	;pop	ds
 41993                                  	;push	ds
 41994                                  
 41995 000077C1 31C0                    	xor	ax,ax
 41996 000077C3 8ED8                    	mov	ds,ax			; point DS to int vector table
 41997 000077C5 B8[1E77]                	mov	ax,initiret
 41998                                  	;mov	[0A8h],ax  ; [2Ah*4]
 41999 000077C8 A3A800                  	mov	[addr_int_ibm],ax
 42000 000077CB 8CC8                    	mov	ax,cs
 42001                                  	;mov	[0AAh],ax  ; [(2Ah*4)+2] 		
 42002 000077CD A3AA00                  	mov	[addr_int_ibm+2],ax
 42003 000077D0 1F                      	pop	ds			; restore segment of device chain
 42004                                  
 42005 000077D1 E81C02                  	call	CHARINIT  		; initialize console driver
 42006 000077D4 56                      	push	si			; save pointer to header
 42007                                  
 42008 000077D5 16                      	push	ss			; move pointer to dos data...
 42009 000077D6 07                      	pop	es			; ...into ES
 42010                                  
 42011                                  	;initialize sft for file 0 (CON)
 42012                                  
 42013                                          ; 07/07/2018 - Retro DOS v3.0
 42014                                  	; 24/04/2019 - Retro DOS v4.0
 42015                                  	;mov	di,SFTABL+6 
 42016 000077D7 BF[D200]                	MOV     DI,SFTABL+SFT.SFTable	; Point to sft 0
 42017 000077DA B80300                          MOV     AX,3
 42018 000077DD AB                              STOSW           	; Refcount
 42019 000077DE FEC8                            DEC     AL
 42020 000077E0 AB                              STOSW           	; Access rd/wr, compatibility
 42021 000077E1 30C0                            XOR     AL,AL
 42022 000077E3 AA                              STOSB           	; attribute
 42023                                  	;mov	al,0C3h
 42024 000077E4 B0C3                    	mov	al,devid_device_EOF|devid_device|ISCIN|ISCOUT
 42025 000077E6 AB                      	STOSW			; flags
 42026 000077E7 89F0                            mov	ax,si
 42027 000077E9 AB                              stosw			; device pointer in devptr	
 42028 000077EA 8CD8                            mov	ax,ds
 42029 000077EC AB                      	stosw
 42030 000077ED 31C0                    	xor	ax,ax	; 0
 42031 000077EF AB                      	stosw			; firclus
 42032 000077F0 AB                      	stosw			; time
 42033 000077F1 AB                      	stosw			; date
 42034 000077F2 48                      	dec	ax	; -1
 42035 000077F3 AB                      	stosw			; size
 42036 000077F4 AB                      	stosw
 42037 000077F5 40                      	inc	ax	; 0
 42038 000077F6 AB                      	stosw			; position
 42039 000077F7 AB                      	stosw
 42040                                  	;add	di,7
 42041 000077F8 83C707                  	add	di,SF_ENTRY.sf_name-SF_ENTRY.sf_cluspos
 42042                                  				; point at name
 42043                                  	;add	si,10
 42044 000077FB 83C60A                  	add	si,SYSDEV.NAME	; sdevname
 42045                                  				; point to name
 42046 000077FE B90400                  	mov	cx,4
 42047 00007801 F3A5                    	rep	movsw		; name
 42048 00007803 B103                    	mov	cl,3
 42049 00007805 B020                    	mov	al," "
 42050 00007807 F3AA                    	rep	stosb		; extension
 42051                                  
 42052 00007809 5E                      	pop	si		; get back pointer to header
 42053                                  
 42054                                  				; mark device as CON I/O
 42055                                  	; 15/07/2018
 42056                                          ;OR	BYTE [SI+4],ISCIN|ISCOUT ; or byte [si+4],3
 42057 0000780A 804C0403                	OR	BYTE [SI+SYSDEV.ATT],ISCIN|ISCOUT
 42058                                  	; 12/03/2018
 42059                                  	;mov	[ss:32h],si
 42060 0000780E 368936[3200]            	MOV     [SS:BCON],SI
 42061                                  	;mov	[ss:34h],ds
 42062 00007813 368C1E[3400]                    MOV     [SS:BCON+2],DS
 42063                                  
 42064                                  	; initialize each device until the clock device is found
 42065                                  
 42066                                  CHAR_INIT_LOOP:
 42067 00007818 C534                            LDS     SI,[SI]			; AUX device
 42068 0000781A E8D301                  	call	CHARINIT 
 42069                                         	;15/07/2018
 42070                                  	;test	byte [SI+4],8
 42071 0000781D F6440408                	TEST    BYTE [SI+SYSDEV.ATT],ISCLOCK
 42072 00007821 74F5                            JZ      SHORT CHAR_INIT_LOOP
 42073                                  	; 12/03/2018
 42074                                  	;mov	[ss:2Eh],si
 42075 00007823 368936[2E00]                    MOV     [SS:BCLOCK],SI
 42076                                  	;mov	[ss:30h],ds
 42077 00007828 368C1E[3000]                    MOV     [SS:BCLOCK+2],DS
 42078                                          ;MOV	BP,MEMSTRT ; Retro DOS 3.0 ; ES:BP points to DPB
 42079                                  
 42080                                  	;mov	bp,4970			; bp = pointer to free mem
 42081                                  	;mov	bp,4976  ; 25/05/2019 - Retro DOS v4.0
 42082                                  	; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0, MSDOS.SYS)
 42083                                  	;mov	bp,4962 ; (MSDOS 5.0 MSDOS.SYS)
 42084 0000782D BDA512                  	mov	bp,MSDAT001E		; es:bp points to dpb area
 42085                                  
 42086 00007830 36892E[2600]            	mov	[ss:DPBHEAD],bp		; set offset of pointer to DPB's
 42087 00007835 368C06[2800]            	mov	[ss:DPBHEAD+2],es	; set segment of pointer to DPB's
 42088                                  PERDRV:
 42089                                  	;lds	si,[SI+SYSDEV.NEXT] ; 15/07/2018
 42090 0000783A C534                            LDS	SI,[SI]			; Next device
 42091 0000783C 83FEFF                          CMP	SI,-1	; 0FFFFh
 42092 0000783F 7479                    	JZ	SHORT CONTINIT
 42093                                  
 42094 00007841 E8AC01                          call	CHARINIT
 42095                                  
 42096                                  	; Retro DOS v2.0 - 16/03/2018 (NOTE for 'CHARINIT' return):
 42097                                  	; [CALLUNIT] = Number of drives for (Disk) Block Dev Driver ([DRVMAX])
 42098                                  	;           (..When the command is 'DSK$INIT', as in 'CHARINIT')
 42099                                  	; [CALLBPB] = [DEVCALL.COUNT] = Address of the BPB (DEVCALL offset 18) 
 42100                                  	; (REF: MSDOS 3.3 MSBIO2.ASM, MSDATA.INC, MSDISK.ASM, MSBIO1.ASM)
 42101                                  	; (.. !DSK$IN' in MSBIO1.ASM)
 42102                                  	; DEVCALL.MEDIA = CALLUNIT (DEVCALL offset 13)
 42103                                  
 42104                                          ; 15/07/2018
 42105                                  	;test	word [SI+4],8000h		; DEVTYP
 42106                                          ; 17/12/2022
 42107                                  	;test	byte [SI+5],80h
 42108 00007844 F6440580                	test	byte [SI+SYSDEV.ATT+1],(DEVTYP>>8) ; 80h
 42109                                  	;TEST	word [SI+SYSDEV.ATT],DEVTYP ; 8000h
 42110 00007848 75F0                    	JNZ     SHORT PERDRV			; Skip any other character devs
 42111                                  
 42112 0000784A 368A0E[6703]                    MOV	CL,[SS:CALLUNIT] ; 12/03/2018
 42113 0000784F 30ED                    	XOR     CH,CH
 42114                                          ; 07/07/2018
 42115                                  	;MOV	[SI+10],CL		; Number of units in name field
 42116 00007851 884C0A                  	mov	[si+SYSDEV.NAME],cl	; sdevname        
 42117 00007854 368A16[4600]            	MOV     DL,[SS:NUMIO]	; 15/03/2018
 42118 00007859 30F6                    	XOR     DH,DH
 42119 0000785B 36000E[4600]            	ADD	[SS:NUMIO],CL	; 12/03/2018
 42120 00007860 1E                      	PUSH    DS
 42121 00007861 56                              PUSH    SI
 42122 00007862 36C51E[6C03]            	LDS	BX,[SS:CALLBPB]	; 12/03/2018
 42123                                  
 42124                                  PERUNIT:
 42125 00007867 8B37                            MOV     SI,[BX]                 ; DS:SI Points to BPB
 42126 00007869 43                              INC     BX
 42127 0000786A 43                              INC     BX                      ; On to next BPB
 42128                                  	; 15/12/2022
 42129                                  	; 07/07/2018
 42130                                          ;mov	[ES:BP+DPB.DRIVE],DL
 42131 0000786B 26885600                	MOV     [ES:BP],DL
 42132                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42133                                  	;;mov	[ES:BP+0],DL
 42134                                  	;mov	[ES:BP+DPB.DRIVE],DL
 42135                                  
 42136                                  	;MOV	[ES:BP+1],DH
 42137 0000786F 26887601                	MOV	[ES:BP+DPB.UNIT],DH
 42138 00007873 53                              PUSH    BX
 42139 00007874 51                              PUSH    CX
 42140 00007875 52                              PUSH    DX
 42141                                  
 42142                                          ;invoke	$SETDPB
 42143 00007876 E8A097                          CALL	_$SETDPB		; build DPB!
 42144                                  
 42145                                  	; 07/07/2018
 42146                                  	;MOV	AX,[ES:BP+2]
 42147 00007879 268B4602                	mov	ax,[ES:BP+DPB.SECTOR_SIZE]
 42148                                          ; 12/03/2018
 42149 0000787D 363B06[3600]            	CMP	AX,[SS:MAXSEC]		; Q:is this the largest sector so far
 42150 00007882 7604                    	JBE     SHORT NOTMAX		; N:
 42151 00007884 36A3[3600]              	MOV	[SS:MAXSEC],AX		; Y: save it in maxsec
 42152                                  NOTMAX:					
 42153                                  	; set the next dpb field in the currently built bpb
 42154                                  	; and mark as never accessed
 42155                                          
 42156                                  	; 24/04/2019
 42157 00007888 89E8                    	mov	ax,bp			; get pointer to DPB
 42158                                  	;add	ax,33
 42159 0000788A 83C021                  	add	ax,DPBSIZ		; advance pointer to next DPB
 42160                                  					; set seg & offset of next DPB
 42161                                  	;mov	[es:bp+25],ax
 42162 0000788D 26894619                	mov	[es:bp+DPB.NEXT_DPB],ax
 42163                                  	;mov	[es:bp+27],es
 42164 00007891 268C461B                	mov	[es:bp+DPB.NEXT_DPB+2],es
 42165                                  					; mark as never accessed
 42166                                  	;mov	byte [es:bp+24],0FFh
 42167 00007895 26C64618FF              	mov	byte [es:bp+DPB.FIRST_ACCESS],-1
 42168                                  
 42169 0000789A 5A                      	POP     DX
 42170 0000789B 59                              POP     CX
 42171 0000789C 5B                              POP     BX
 42172 0000789D 8CD8                            MOV     AX,DS                   ; save segment of bpb array
 42173 0000789F 5E                              POP     SI
 42174 000078A0 1F                              POP     DS
 42175                                  					; ds:si -> device header
 42176                                  					; store it in the corresponding dpb
 42177                                  	; 07/07/2018
 42178                                          ;MOV	[ES:BP+19],SI ; 24/04/2019
 42179 000078A1 26897613                	mov	[ES:BP+DPB.DRIVER_ADDR],si
 42180                                          ;MOV	[ES:BP+21],DS ; 24/04/2019
 42181 000078A5 268C5E15                	mov	[ES:BP+DPB.DRIVER_ADDR+2],ds
 42182                                  
 42183 000078A9 1E                              PUSH    DS			; save pointer to device header
 42184 000078AA 56                              PUSH    SI
 42185 000078AB FEC6                            INC     DH			; inc unit #
 42186 000078AD FEC2                            INC     DL			; inc drive #
 42187 000078AF 8ED8                            MOV     DS,AX			; restore segment of BPB array
 42188                                          ;add	bp,33 ; 24/04/2019
 42189 000078B1 83C521                  	ADD     BP,DPBSIZ		; advance pointer to next dpb
 42190 000078B4 E2B1                    	LOOP    PERUNIT			; process all units in each driver
 42191                                          
 42192 000078B6 5E                      	POP     SI			; restore pointer to device header
 42193 000078B7 1F                              POP     DS
 42194 000078B8 EB80                    	JMP	PERDRV			; process all drivers in chain
 42195                                  
 42196                                  CONTINIT:
 42197                                  	; 24/04/2019
 42198                                  	;sub	bp,33			; set link in last DPB to -1
 42199 000078BA 83ED21                  	sub	bp,DPBSIZ		; back up to last dpb
 42200                                  					; set last link offset & segment
 42201                                  	;mov	word [bp+25],0FFFFh
 42202 000078BD C74619FFFF              	mov	word [bp+DPB.NEXT_DPB],-1
 42203                                  	;mov	word [bp+27],0FFFFh
 42204 000078C2 C7461BFFFF              	mov	word [bp+DPB.NEXT_DPB+2],-1
 42205                                  	;add	bp,33
 42206 000078C7 83C521                  	add	BP,DPBSIZ		; advance to free memory again
 42207                                  					; the DPB chain is done.  
 42208 000078CA 16                      	push	ss
 42209 000078CB 1F                      	pop	ds
 42210                                  
 42211 000078CC 89E8                    	mov	ax,bp
 42212 000078CE E850FE                  	call	ParaRound		; round up to segment
 42213                                  
 42214 000078D1 8CDA                    	mov	dx,ds			; dx = dosdata segment
 42215 000078D3 01C2                    	add	dx,ax			; dx = ds+ax first free segment
 42216                                  
 42217 000078D5 BB0F00                  	mov	bx,0Fh
 42218                                  	
 42219                                  	; 24/05/2019
 42220                                  	;mov	cx,[ENDMEM]
 42221                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42222                                  	; 17/12/2022
 42223                                  	;mov	cx,[ENDMEM] 
 42224                                  					; set seg inpacketto dosdata					
 42225 000078D8 8C1E[A203]              	mov	[DSKCHRET+3],ds ; mov [DOSSEG_INIT],ds 
 42226                                  
 42227                                  ; Patch in the segments of the interrupt vectors with current code segment.
 42228                                  ; Also patch in the segment of the pointers in the dosdata area.
 42229                                  ;
 42230                                  ; Note: Formerly, temp_dosloc was initialized to -1 until after these
 42231                                  ; calls were done. The procedure patch_misc_segments is called multiple
 42232                                  ; times, and relies on temp_dosloc being initialized to -1 as a flag
 42233                                  ; for the first invocation. Thus, we must set it to -1 for this call.
 42234                                  
 42235 000078DC 52                      	push	dx			; preserve first free segment
 42236                                  
 42237 000078DD A1[AA0A]                	mov	ax,[TEMP_DOSLOC]	; ax = segment to patch in 
 42238 000078E0 8EC0                    	mov	es,ax			; es = segment of DOS
 42239 000078E2 C706[AA0A]FFFF          	mov	word [TEMP_DOSLOC],-1	; -1 means first call to patch_misc_segments
 42240                                  
 42241 000078E8 E8AF01                  	call	patch_vec_segments	; uses AX as doscode segment
 42242 000078EB E8E401                  	call	patch_misc_segments	; patch in segments for sharer and 
 42243                                  					; other tables with seg in ES.
 42244                                  	; 17/12/2022
 42245                                  	; cx = 0
 42246 000078EE 8C06[AA0A]              	mov	[TEMP_DOSLOC],es	; put back segment of dos code
 42247                                  
 42248 000078F2 5A                      	pop	dx			; restore first free segment
 42249                                  
 42250                                  ; We shall now proceed to set the offsets of the interrupt vectors handled
 42251                                  ; by DOS to their appropriate values in DOSCODE. In case the DOS loads in
 42252                                  ; HIMEM the offsets also will be patched to their appropriate values in the
 42253                                  ; low_mem_stub by seg_reinit.
 42254                                  
 42255                                  	;xor	ax,ax ; 0
 42256                                  	;mov	ds,ax
 42257                                  	;mov	es,ax
 42258                                  	; 17/12/2022
 42259                                  	; cx = 0
 42260                                  	;xor	cx,cx ; 0
 42261 000078F3 8ED9                    	mov	ds,cx
 42262 000078F5 8EC1                    	mov	es,cx
 42263                                  
 42264                                  	; set the segment of int 24 vector that was 
 42265                                  	; left out by patch_vec_segments above.
 42266                                  
 42267                                  	; 17/12/2022
 42268                                  ; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42269                                  ;%if 0
 42270                                  	; 24/05/2019
 42271                                  	;;mov	di,90h
 42272                                  	;;mov	di,4*int_fatal_abort
 42273                                  	;mov	di,addr_int_fatal_abort
 42274 000078F7 BF9200                  	mov	di,addr_int_fatal_abort+2 ; 24/05/2019
 42275                                  
 42276 000078FA 36A1[AA0A]              	mov	ax,[ss:TEMP_DOSLOC]
 42277                                  	;mov	[di+2],ax  ; int 24h segment
 42278 000078FE 8905                    	mov	[di],ax ; 24/05/2019
 42279                                  
 42280                                  	;;mov	di,82h
 42281                                  	;mov	di,INTBASE+2
 42282                                  
 42283                                  ;%endif
 42284                                  	; 17/12/2022
 42285                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42286                                  	;;mov	di,90h
 42287                                  	;;mov	di,4*int_fatal_abort
 42288                                  	;mov	di,addr_int_fatal_abort
 42289                                  	;mov	ax,[ss:TEMP_DOSLOC]
 42290                                  	;mov	[di+2],ax  ; int 24h segment
 42291                                  	;;mov	di,82h
 42292                                  	;mov	di,INTBASE+2
 42293                                  
 42294                                  	; set default divide trap offset
 42295                                  
 42296                                  	;mov	word ptr ds:[0],offset doscode:divov
 42297 00007900 C7060000[EB52]          	mov	word [0],DIVOV	
 42298                                  
 42299                                  	; set vectors 20-28 and 2a-3f to point to iret.
 42300                                  
 42301                                  	;mov	di,80h
 42302 00007906 BF8000                  	mov	di,INTBASE
 42303                                  	;mov	ax,offset doscode:irett
 42304 00007909 B8[E702]                	mov	ax,IRETT
 42305                                  
 42306                                  	; 17/12/2022
 42307                                  	; cx = 0
 42308 0000790C B109                    	mov	cl,9
 42309                                  	;mov	cx,9			; set 9 offsets (skip 2 between each)
 42310                                  					;   sets offsets for ints 20h-28h
 42311                                  iset1:
 42312 0000790E AB                      	stosw
 42313                                  	;add	di,2
 42314                                  	; 20/09/2023
 42315 0000790F 47                      	inc	di
 42316 00007910 47                      	inc	di
 42317 00007911 E2FB                    	loop	iset1
 42318                                  
 42319 00007913 83C704                  	add	di,4			; skip vector 29h
 42320                                  
 42321                                  ;	mov	cx,6			; set 6 offsets (skip 2 between each)
 42322                                  ;					;   sets offsets for ints 2ah-2fh
 42323                                  ;iset2:
 42324                                  ;	stosw
 42325                                  ;	add	di,2
 42326                                  ;	loop	iset2
 42327                                  
 42328                                  ; 30h & 31H is the CPM call entry point whose segment address is set up by
 42329                                  ; patch_vec_segments above. So skip it.
 42330                                  
 42331                                  ;	add	di,8			; skip vector 30h & 31h 
 42332                                  
 42333                                  	;;;
 42334                                  	; 06/05/2019 - Retro DOS v4.0
 42335                                  	;mov	cx,5			; set offsets for int 2Ah-2Eh
 42336                                  	; 17/12/2022
 42337 00007916 B105                    	mov	cl,5 ; 28/06/2019
 42338                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42339                                  	;mov	cx,6
 42340                                  iset2:
 42341 00007918 AB                      	stosw
 42342                                  	;add	di,2
 42343                                  	; 20/09/2023
 42344 00007919 47                      	inc	di
 42345 0000791A 47                      	inc	di
 42346 0000791B E2FB                    	loop	iset2
 42347                                  
 42348                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42349                                  	; 17/12/2022
 42350 0000791D 83C70C                  	add	di,12			; skip vectors 2Fh, 30h & 31h
 42351                                  	;add	di,8
 42352                                  	;;;
 42353                                  
 42354                                  	; 17/12/2022
 42355 00007920 B10E                    	mov	cl,14
 42356                                  	;mov	cx,14			; set 14 offsets (skip 2 between each)
 42357                                  					;   sets offsets for ints 32h-3fh
 42358                                  iset3:
 42359 00007922 AB                      	stosw
 42360                                  	;add	di,2
 42361                                  	; 20/09/2023
 42362 00007923 47                      	inc	di
 42363 00007924 47                      	inc	di
 42364 00007925 E2FB                    	loop	iset3
 42365                                  
 42366                                  ;if installed
 42367                                  	; set the offset of int2f handler
 42368                                  	;mov	word [0BCh],INT2F
 42369 00007927 C706BC00[1607]          	mov	word [02Fh*4],INT2F
 42370                                  	; set segment to doscode as we have to do int 2f to check for XMS
 42371 0000792D 36A1[AA0A]              	mov	ax,[ss:TEMP_DOSLOC]	; get segment of doscode
 42372                                  	;mov	[0BEh],ax
 42373 00007931 A3BE00                  	mov	[(02Fh*4)+2],ax
 42374                                  ;endif
 42375                                  	; set up entry point call at vectors 30-31h. Note the segment of the 
 42376                                  	; long jump will be patched in by seg_reinit
 42377                                  
 42378                                  	;mov	byte [C0h],0EAh
 42379 00007934 C606C000EA              	mov	byte [ENTRYPOINT],mi_long_jmp
 42380                                  	;mov	byte [C1h],CALL_ENTRY
 42381 00007939 C706C100[E802]          	mov	word [ENTRYPOINT+1],CALL_ENTRY
 42382                                  
 42383 0000793F C7068000[E102]          	mov	word [addr_int_abort],QUIT	; INT 20h
 42384 00007945 C7068400[0D03]          	mov	word [addr_int_command],COMMAND ; INT 21h
 42385 0000794B C70688000001            	mov	word [addr_int_terminate],100h	; INT 22h
 42386 00007951 89168A00                	mov	word [addr_int_terminate+2],dx	
 42387 00007955 C7069400[4005]          	mov	word [addr_int_disk_read],ABSDRD   ; INT 25h
 42388 0000795B C7069800[C705]          	mov	word [addr_int_disk_write],ABSDWRT ; INT 26h 
 42389 00007961 C7069C00[2C62]          	mov	word [addr_int_keep_process],STAY_RESIDENT ; INT 27h
 42390                                  
 42391 00007967 16                      	push	ss
 42392 00007968 1F                      	pop	ds
 42393                                  	
 42394                                  	; 24/05/2019
 42395                                  	;push	ss
 42396                                  	;pop	es
 42397                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42398                                  	; 17/12/2022
 42399                                  	;push	ss
 42400                                  	;pop	es
 42401                                  
 42402 00007969 52                      	push	dx			; remember address of arena
 42403                                  
 42404 0000796A 42                      	inc	dx			; leave room for arena header
 42405                                  	;mov	[330h],dx
 42406 0000796B 8916[3003]              	mov     [CurrentPDB],dx		; set current pdb
 42407                                  
 42408 0000796F 31FF                    	xor	di,di			; point es:di at end of memory
 42409 00007971 8EC2                    	mov	es,dx			; ...where psp will be
 42410 00007973 31C0                    	xor	ax,ax
 42411                                  	;mov	cx,80h			; psp is 128 words
 42412                                  	; 17/12/2022
 42413 00007975 B180                    	mov	cl,128 ; 28/06/2019
 42414                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42415                                  	;mov	cx,128
 42416                                  
 42417 00007977 F3AB                    	rep	stosw			; zero out psp area
 42418 00007979 A1[4603]                        mov     ax,[ENDMEM]
 42419                                  	
 42420                                  	; 17/12/2022
 42421                                  	; cx = 0
 42422 0000797C E8E797                  	call	SETMEM         	 	; build psp at dx; ax is memory size
 42423                                  
 42424                                  	; ds, es now point to PSP
 42425                                  
 42426 0000797F 16                      	push	ss
 42427 00007980 1F                      	pop	ds
 42428                                  
 42429                                  	;mov	di,24
 42430 00007981 BF1800                  	mov	di,PDB.JFN_TABLE	; es:di -> pdb_jfn_table in psp
 42431 00007984 31C0                    	xor	ax,ax
 42432 00007986 AB                      	stosw
 42433 00007987 AA                      	stosb				; 0,1 and 2 are con device
 42434 00007988 B0FF                    	mov	al,0FFh
 42435                                  	;mov	cx,FILPERPROC-3 ; 17
 42436                                  	; 17/12/2022
 42437                                  	; cx = 4
 42438 0000798A B111                    	mov	cl,FILPERPROC-3 ; 17
 42439 0000798C F3AA                    	rep	stosb			; rest are unused
 42440                                  
 42441 0000798E 16                      	push	ss
 42442 0000798F 07                      	pop	es
 42443                                  					; must be set to print messages
 42444 00007990 8C1E[2C00]              	mov	[SFT_ADDR+2],ds     
 42445                                  
 42446                                  ; after this point the char device functions for con will work for
 42447                                  ; printing messages
 42448                                  
 42449                                  	; 24/04/2019 - Retro DOS v4.0
 42450                                  
 42451                                  ; 12/05/2019
 42452                                  ;
 42453                                  ;write_version_msg:
 42454                                  ;
 42455                                  ;	;if	(not ibm)
 42456                                  ;	;mov	si,offset doscode:header
 42457                                  ;	mov	si,HEADER
 42458                                  ;outmes:
 42459                                  ;	;lods	cs:byte ptr [si]
 42460                                  ;	cs
 42461                                  ;	lodsb
 42462                                  ;	cmp	al,"$"
 42463                                  ;	je	short outdone
 42464                                  ;	call	OUTT
 42465                                  ;	jmp	short outmes
 42466                                  ;outdone:
 42467                                  ;	push	ss			; out stomps on segments
 42468                                  ;	pop	ds
 42469                                  ;	push	ss
 42470                                  ;	pop	es
 42471                                  ;	;endif
 42472                                  
 42473                                  	; at this point es is dosdata
 42474                                  
 42475                                  	; Fill in the segment addresses of sysinitvar and country_cdpg 
 42476                                  	; in sysinittable (ms_data.asm)
 42477                                  
 42478                                  	;mov	si,0D28h
 42479 00007994 BE[280D]                	mov	si,SysInitTable
 42480                                  
 42481                                  	; 17/12/2022
 42482                                  	; ds = es = ss
 42483                                  
 42484                                  	; 17/12/2022
 42485                                  ; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42486                                  ;%if 0
 42487                                  	;;mov	[es:si+6],es
 42488                                  	;mov	[es:si+SYSI_EXT.Country_Tab+2],es
 42489                                  	;;mov	[es:si+2],es
 42490                                  	;mov	[es:si+SYSI_EXT.SysInitVars+2],es
 42491                                  	
 42492 00007997 8C4406                  	mov	[si+SYSI_EXT.Country_Tab+2],es
 42493 0000799A 8C4402                  	mov	[si+SYSI_EXT.SysInitVars+2],es
 42494                                  
 42495                                  	; buffhead -> dosdata:hashinitvar 
 42496                                  
 42497                                  	;mov	[es:BUFFHEAD+2],es	; BUGBUG - unused, remove this
 42498 0000799D 8C06[3A00]              	mov	[BUFFHEAD+2],es
 42499                                  	;mov	si,offset dosdata:hashinitvar ; and all other references
 42500                                  	;mov	si,6Dh
 42501 000079A1 BE[6D00]                	mov	si,HASHINITVAR
 42502                                  	;mov	[es:BUFFHEAD],si
 42503 000079A4 8936[3800]              	mov	[BUFFHEAD],si
 42504                                  
 42505 000079A8 5A                              pop     dx                      ; restore address of arena
 42506                                  
 42507                                  	;mov	[032Ch+2],dx
 42508 000079A9 8916[2E03]                      mov     [DMAADD+2],dx
 42509                                  
 42510                                  	;mov	[es:arena_head],dx
 42511 000079AD 8916[2400]              	mov	[arena_head],dx
 42512                                  
 42513                                  ;%endif
 42514                                  
 42515                                  ; 17/12/2022
 42516                                  %if 0
 42517                                  	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 42518                                  	;;;
 42519                                  	;mov	[es:si+6],es
 42520                                  	mov	[es:si+SYSI_EXT.Country_Tab+2],es
 42521                                  	;mov	[es:si+2],es
 42522                                  	mov	[es:si+SYSI_EXT.SysInitVars+2],es
 42523                                  
 42524                                  	; buffhead -> dosdata:hashinitvar 
 42525                                  
 42526                                  	mov	[es:BUFFHEAD+2],es	; BUGBUG - unused, remove this
 42527                                  	;mov	si,offset dosdata:hashinitvar ; and all other references
 42528                                  	;mov	si,6Dh
 42529                                  	mov	si,HASHINITVAR
 42530                                  	mov	[es:BUFFHEAD],si
 42531                                  
 42532                                          pop     dx                      ; restore address of arena
 42533                                  
 42534                                  	;mov	[032Ch+2],dx
 42535                                          mov     [DMAADD+2],dx
 42536                                  
 42537                                  	mov	[es:arena_head],dx
 42538                                  	;;;
 42539                                  %endif
 42540                                  
 42541 000079B1 8EDA                            mov     ds,dx
 42542                                  
 42543                                  	;mov	byte [0],'Z'
 42544 000079B3 C60600005A              	mov     byte [ARENA.SIGNATURE],arena_signature_end
 42545                                          ;mov	word [1],0
 42546 000079B8 C70601000000            	mov     word [ARENA.OWNER],arena_owner_system
 42547                                  
 42548 000079BE 36A1[4603]                      mov     ax,[ss:ENDMEM]
 42549 000079C2 29D0                    	sub	ax,dx
 42550 000079C4 48                              dec     ax
 42551 000079C5 A30300                          mov     [ARENA.SIZE],ax
 42552                                  
 42553                                  	; point to sft 0
 42554                                  
 42555                                  	;mov	di,offset dosdata:sftabl + sftable
 42556                                  	;mov	di,SFTABL+6
 42557 000079C8 BF[D200]                	mov	di,SFTABL+SFT.SFTable
 42558 000079CB B80300                          mov     ax,3
 42559 000079CE AB                              stosw           		; adjust refcount
 42560                                  
 42561                                  	; es:di is shared data area i.e., es:di -> dosdata:sysinttable
 42562                                  
 42563                                          ;mov	di,offset dosdata:sysinittable
 42564                                  	;mov	di,0D28h
 42565 000079CF BF[280D]                	mov	di,SysInitTable	
 42566                                  
 42567 000079D2 42                      	inc	dx			; advance dx from arena to psp
 42568 000079D3 8EDA                    	mov	ds,dx			; point ds to psp
 42569                                  
 42570                                  					; pass the address os seg_reinit 
 42571                                  					; in dx
 42572 000079D5 BA[437A]                	mov	dx,seg_reinit
 42573 000079D8 B9[6774]                	mov	cx,exepatch_start
 42574 000079DB 81E9[0000]              	sub	cx,_$STARTCODE		; cx = (doscode - exepatch) - dosinit
 42575                                  
 42576 000079DF B8[1E77]                	mov	ax,SYSBUF
 42577 000079E2 2D[0000]                	sub	ax,_$STARTCODE		; ax = size of doscode - dosinit
 42578                                  	
 42579 000079E5 368B26[8405]                    mov     sp,[ss:USER_SP]		; use ss override for next 2
 42580 000079EA 368E16[8605]                    mov     ss,[ss:USER_SS]
 42581                                  
 42582 000079EF CB                              retf
 42583                                  
 42584                                  ;
 42585                                  ; END OF DOSINIT
 42586                                  ;
 42587                                  ;--------------------------------------------------------------------------
 42588                                  
 42589                                  CHARINIT:
 42590                                  	; 24/04/2019 - Retro DOS v4.0
 42591                                  	; 07/07/2018 - Retro DOS v3.0
 42592                                  	;mov	byte [ss:035Ah],26 ; 1Ah
 42593 000079F0 36C606[5A03]1A                  MOV	BYTE [SS:DEVCALL_REQLEN],DINITHL
 42594                                  	;mov	byte [ss:035Bh],0
 42595 000079F6 36C606[5B03]00                  MOV	BYTE [SS:DEVCALL_REQUNIT],0
 42596                                  	;mov	byte [ss:035Ch],0
 42597 000079FC 36C606[5C03]00                  MOV	BYTE [SS:DEVCALL_REQFUNC],DEVINIT
 42598                                  	;mov	word [ss:035BD],0
 42599 00007A02 36C706[5D03]0000                MOV	WORD [SS:DEVCALL_REQSTAT],0
 42600 00007A09 06                              PUSH	ES
 42601 00007A0A 53                              PUSH	BX
 42602 00007A0B 50                              PUSH	AX
 42603 00007A0C BB[5A03]                        MOV	BX,DEVCALL
 42604                                          ;PUSH	CS
 42605 00007A0F 16                      	PUSH	SS ; 30/04/2019
 42606 00007A10 07                              POP	ES
 42607 00007A11 E8C3CC                          CALL	DEVIOCALL2	
 42608 00007A14 58                      	POP	AX
 42609 00007A15 5B                              POP	BX
 42610 00007A16 07                              POP	ES
 42611 00007A17 C3                              RETN
 42612                                  
 42613                                  ; 25/04/2019 - Retro DOS v4.0
 42614                                  
 42615                                  ;-----------------------------------------------------------------------------
 42616                                  ;
 42617                                  ;	check_XMM: routine to check presence of XMM driver
 42618                                  ;
 42619                                  ;	Exit:   Sets up the XMM entry point in XMMcontrol in DOSDATA
 42620                                  ;
 42621                                  ;	USED:	none
 42622                                  ;
 42623                                  ;-----------------------------------------------------------------------------
 42624                                  
 42625                                  check_XMM: ; proc near
 42626                                  ;
 42627                                  ; determine whether or not an XMM driver is installed
 42628                                  ;
 42629 00007A18 50                      	push	ax
 42630                                  	;mov	ax,(XMM_MULTIPLEX<<8)+XMM_INSTALL_CHECK
 42631 00007A19 B80043                  	mov	ax,4300h
 42632 00007A1C CD2F                    	int	2Fh
 42633                                  		; - Multiplex - XMS - INSTALLATION CHECK
 42634                                  		; Return: AL = 80h XMS driver installed
 42635                                  		; AL <> 80h no driver
 42636 00007A1E 3C80                    	cmp	al,80h			; Q: installed
 42637 00007A20 751D                    	jne	short cXMM_no_driver	; N: set error, quit
 42638                                  ;
 42639                                  ; get the XMM control functions entry point, save it, we
 42640                                  ; need to call it later.
 42641                                  ;
 42642 00007A22 53                      	push	bx
 42643 00007A23 52                      	push	dx
 42644 00007A24 1E                      	push	ds
 42645 00007A25 06                      	push	es
 42646                                  	;mov	ax,(XMM_MULTIPLEX<<8)+XMM_FUNCTION_ADDR
 42647 00007A26 B81043                  	mov	ax,4310h
 42648 00007A29 CD2F                    	int	2Fh
 42649                                  		; - Multiplex - XMS - GET DRIVER ADDRESS
 42650                                  		; Return: ES:BX -> driver entry point
 42651                                  
 42652 00007A2B 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 42653                                  
 42654 00007A30 891E[4911]              	mov	[XMMcontrol],bx
 42655 00007A34 8C06[4B11]              	mov	[XMMcontrol+2],es
 42656                                  cXMMexit:
 42657 00007A38 F8                      	clc
 42658 00007A39 07                      	pop	es
 42659 00007A3A 1F                      	pop	ds
 42660 00007A3B 5A                      	pop	dx
 42661 00007A3C 5B                      	pop	bx
 42662 00007A3D 58                      	pop	ax
 42663 00007A3E C3                      	retn				; done
 42664                                  ;
 42665                                  ; set carry if XMM driver not present
 42666                                  ;
 42667                                  cXMM_no_driver:
 42668 00007A3F F9                      	stc
 42669 00007A40 58                      	pop	ax
 42670 00007A41 C3                      	retn
 42671                                  
 42672                                  ;-----------------------------------------------------------------------------
 42673                                  ;
 42674                                  ; Procedure Name : seg_reinit
 42675                                  ;
 42676                                  ; Inputs	 : ES has final dos code location
 42677                                  ;		   AX = 0 / 1
 42678                                  ;
 42679                                  ; Outputs	 : Patch in the sharer and other tables with seg in ES
 42680                                  ;		   if AX =0
 42681                                  ;		      if first entry
 42682                                  ;			 patch segment & offset of vectors with stub
 42683                                  ;			 and stub with segment in ES
 42684                                  ;		      else
 42685                                  ;			 patch stub with segment in ES
 42686                                  ;
 42687                                  ;		   else if AX = 1
 42688                                  ;			patch segment of vectors with segment in ES	
 42689                                  ;
 42690                                  ; NOTE		 : This routine can be called at most twice!
 42691                                  ;
 42692                                  ; Regs Mod.	 : es, ax, di, cx, bx
 42693                                  ;-----------------------------------------------------------------------------
 42694                                  
 42695 00007A42 00                      num_entry: db	0		; keeps track of the # of times this routine
 42696                                  				; has been called. (0 or 1)
 42697                                  
 42698                                  	; 04/11/2022 - Retro DOS v4.0 (ref: MSDOS 5.0)
 42699                                  	; MSDOS 5.0 MSDOS.SYS - DOSCODE:0BAB7h
 42700                                  	; 25/05/2019 - Retro DOS v4.0 (ref: MSDOS 6.21)
 42701                                  	; MSDOS 6.21 MSDOS.SYS - DOSCODE:0BDA5h
 42702                                  
 42703                                  seg_reinit:	; proc	far
 42704 00007A43 1E                      	push	ds
 42705                                  
 42706 00007A44 2E8E1E[0700]            	mov	ds,[cs:DosDSeg]
 42707                                  
 42708 00007A49 E88600                  	call	patch_misc_segments	; patch in segments for sharer and 
 42709                                  					; other tables with seg in ES.
 42710                                  	; 17/12/2022
 42711                                  	; cx = 0
 42712 00007A4C 39C8                    	cmp	ax,cx ; 0
 42713                                  	;cmp	ax,0
 42714 00007A4E 753D                    	jne	short patch_vec_seg	; patch vectors with segment in es
 42715                                  
 42716                                  	; 17/12/2022
 42717 00007A50 2E380E[427A]            	cmp	[cs:num_entry],cl ; 0
 42718                                  	;cmp	byte [cs:num_entry],0	; Q: is it the first call to this 
 42719 00007A55 7508                    	jne	short second_entry	; N: just patch the stub with 
 42720                                  					;    segment in ES
 42721                                  					; Y: patch the vectors with stub 
 42722 00007A57 8CD8                    	mov	ax,ds
 42723 00007A59 E83E00                  	call	patch_vec_segments	; patch the segment of vectors
 42724 00007A5C E8BD00                  	call	patch_offset		; patch the offsets of vectors 
 42725                                  					; with those in the stub.
 42726                                  	; 17/12/2022
 42727                                  	; cx = 0
 42728                                  second_entry:
 42729 00007A5F 8CC0                    	mov	ax,es			; patch the stub with segment in es
 42730                                  
 42731                                  	;mov	di,OFFSET DOSDATA:DOSINTTABLE
 42732                                  	;mov	di,1062h	; (same table addr for MSDOS 5.0 and MSDOS 6.21)
 42733 00007A61 BF[4810]                	mov	di,DOSINTTABLE
 42734                                  	; 17/12/2022
 42735                                  	; cx = 0
 42736                                  	;mov	cx,9
 42737 00007A64 B109                    	mov	cl,9
 42738 00007A66 1E                      	push	ds			
 42739 00007A67 07                      	pop	es			; es:di -> DOSINTTABLE
 42740                                  
 42741                                  dosinttabloop:
 42742                                  	;add	di,2
 42743                                  	; 19/06/2023
 42744 00007A68 47                      	inc	di
 42745 00007A69 47                      	inc	di
 42746 00007A6A AB                      	stosw
 42747 00007A6B E2FB                    	loop	dosinttabloop	
 42748                                  
 42749                                  ; For ROMDOS, this routine will only be called when the DOS wants to
 42750                                  ; use the HMA, so we don't want to check CS
 42751                                  
 42752                                  ;ifndef ROMDOS
 42753 00007A6D 3D00F0                  	cmp	ax,0F000h		; Q: is the DOS running in the HMA
 42754 00007A70 7220                    	jb	short sr_done		; N: done
 42755                                  ;endif
 42756 00007A72 E8A3FF                  	call	check_XMM		; Y: set up the XMS entry point
 42757 00007A75 721B                    	jc	short sr_done		; failed to set up XMS do not do
 42758                                  					; A20 toggling in the stub.
 42759                                  	; 17/12/2022
 42760                                  	; cx = 0
 42761 00007A77 E81D01                  	call	patch_in_nops		; enable the stub to check A20 state
 42762                                  ; M021-
 42763                                  	;mov	byte [1211h],1
 42764 00007A7A C606[F211]01            	mov	byte [DosHasHMA],1	; set flag telling DOS control of HMA 
 42765                                  				
 42766                                  					; set pointer to the routine that 
 42767                                  					; patches buggy exepacked code.
 42768                                  	;mov	[FixExePatch],offset DOSCODE:ExePatch
 42769 00007A7F C706[F311][B775]        	mov	word [FixExePatch],ExePatch
 42770                                  					; M068: set pointer to the routine 
 42771                                  					; M068: that detects copy protected
 42772                                  					; M068: apps
 42773                                  	;mov	[ChkCopyProt],offset DOSCODE:IsCopyProt
 42774 00007A85 C706[6100][E876]        	mov	word [ChkCopyProt],IsCopyProt
 42775                                  
 42776                                  	; 19/09/2023
 42777 00007A8B EB05                    	jmp	short sr_done
 42778                                  
 42779                                  ; 28/12/2022 - Retro DOS v4.1
 42780                                  %if 0
 42781                                  ;----------------------------------------------------------------------------
 42782                                  
 42783                                  	; MSDOS 6.21 MSDOS.SYS - DOSCODE:0BDF1h
 42784                                  
 42785                                  ;	; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 42786                                  ;
 42787                                  ;; M020 - begin
 42788                                  ;
 42789                                  ;	call	WhatCPUType
 42790                                  ;	cmp	al,1
 42791                                  ;	jne	short sr_done 		; we need Rational Patch only
 42792                                  ;					;  on 286 systems
 42793                                  ;	;mov	[RationalPatchPtr],offset DOSCODE:RationalPatch
 42794                                  ;	mov	word [RationalPatchPtr],RationalPatch
 42795                                  ;
 42796                                  ;; M020 - end
 42797                                  ;
 42798                                  ;	jmp	short sr_done
 42799                                  ;
 42800                                  ;patch_vec_seg:				; patch vectors with segment in es
 42801                                  ;	mov	ax,es
 42802                                  ;	call	patch_vec_segments	; patch in DOSCODE for the segments
 42803                                  ;					; NOTE we don't have to patch the 
 42804                                  ;					; offsets as they have been already
 42805                                  ;					; set to the doscode offsets at
 42806                                  ;					; DOSINIT.
 42807                                  ;sr_done:
 42808                                  ;	mov	byte [cs:num_entry],1
 42809                                  ;	pop	ds
 42810                                  ;	retf	; ! far return !
 42811                                  
 42812                                  ;----------------------------------------------------------------------------
 42813                                  ;
 42814                                  ; Procedure Name : WhatCPUType
 42815                                  ;
 42816                                  ; Inputs	 : none
 42817                                  ;
 42818                                  ; Outputs	 : AL = 0 if CPU <  286
 42819                                  ;		      = 1 if CPU == 286
 42820                                  ;		      = 2 if CPU >= 386
 42821                                  ;
 42822                                  ; Regs. Mod.	 : AX
 42823                                  ;
 42824                                  ;----------------------------------------------------------------------------
 42825                                  
 42826                                  WhatCPUType:
 42827                                  	; 25/04/2019 - Retro DOS v4.0
 42828                                  	;get_cpu_type	; done with a MACRO which can't be generated > once
 42829                                  
 42830                                  	;CPUTYPE.INC (MSDOS 6.0, 1991)
 42831                                  
 42832                                  ; Note: this must be a macro, and not a subroutine in the BIOS since
 42833                                  ; 	it is called from both CODE and SYSINITSEG.
 42834                                  ;
 42835                                  ;------GET_CPU_TYPE-----------------------------------May, 88 by M.Williamson
 42836                                  ;  Returns: AX = 0 if 8086 or 8088
 42837                                  ;              = 1 if 80286
 42838                                  ;              = 2 if 80386
 42839                                  
 42840                                  	; 04/11/2022
 42841                                  	; MSDOS 5.0 MSDOS.SYS - DOSCODE:0BB03h
 42842                                  
 42843                                  Get_CPU_Type:	;macro
 42844                                  	pushf
 42845                                  	push	bx			; preserve bx
 42846                                  	xor	bx,bx			; init bx to zero
 42847                                  
 42848                                  	xor	ax,ax			; 0000 into AX
 42849                                  	push	ax			; put it on the stack...
 42850                                  	popf				; ...then shove it into the flags
 42851                                  	pushf				; get it back out of the flags...
 42852                                  	pop	ax			; ...and into ax
 42853                                  	and	ax,0F000h		; mask off high four bits
 42854                                  	cmp	ax,0F000h		; was it all 1's?
 42855                                  	je	short cpu_8086		; aye; it's an 8086 or 8088
 42856                                  
 42857                                  	mov	ax,0F000h		; now try to set the high four bits..
 42858                                  	push	ax
 42859                                  	popf
 42860                                  	pushf
 42861                                  	pop	ax			; ...and see what happens
 42862                                  	and	ax,0F000h		; any high bits set ?
 42863                                  	jz	short cpu_286		; nay; it's an 80286
 42864                                  
 42865                                  cpu_386:				; bx starts as zero
 42866                                  	inc	bx			; inc twice if 386
 42867                                  cpu_286:				; just inc once if 286
 42868                                  	inc	bx
 42869                                  cpu_8086:				; don't inc at all if 086
 42870                                  	mov	ax,bx			; put CPU type value in ax
 42871                                  	pop	bx			; restore original bx
 42872                                  	popf
 42873                                  	
 42874                                  	;endm
 42875                                  
 42876                                  	; 04/11/2022 (MSDOS 5.0 MSDOS.SYS)
 42877                                  	retn	; 19/09/2023
 42878                                  
 42879                                  ; 19/09/2023
 42880                                  ;	; 04/11/2022
 42881                                  ;	; MSDOS 5.0 MSDOS.SYS - DOSCODE:0BB27h
 42882                                  ;	cmp	al,1
 42883                                  ;	jne	short sr_done 		; we need Rational Patch only
 42884                                  ;					;  on 286 systems
 42885                                  ;	mov	word [RationalPatchPtr],RationalPatch
 42886                                  
 42887                                  ;----------------------------------------------------------------------------
 42888                                  %endif	; 28/12/2022
 42889                                  
 42890                                  	; 19/09/2023
 42891                                  	;jmp	short sr_done
 42892                                  
 42893                                  patch_vec_seg:				; patch vectors with segment in es
 42894 00007A8D 8CC0                    	mov	ax,es
 42895 00007A8F E80800                  	call	patch_vec_segments	; patch in DOSCODE for the segments
 42896                                  					; NOTE we don't have to patch the 
 42897                                  					; offsets as they have been already
 42898                                  					; set to the doscode offsets at
 42899                                  					; DOSINIT.
 42900                                  sr_done:
 42901 00007A92 2EC606[427A]01          	mov	byte [cs:num_entry],1
 42902 00007A98 1F                      	pop	ds
 42903 00007A99 CB                      	retf	; ! far return !
 42904                                  
 42905                                  ;----------------------------------------------------------------------------
 42906                                  ;
 42907                                  ; Procedure Name : patch_vec_segments
 42908                                  ;
 42909                                  ; Inputs	 : ax -> has segment address to patch in
 42910                                  ;		   ds -> DOSDATA
 42911                                  ;
 42912                                  ; Outputs	 : Patches in AX as the segment for the following vectors:
 42913                                  ;			
 42914                                  ;			0,20-28,3a-3f
 42915                                  ;
 42916                                  ; Regs. Mod.	 : DI,CX,DX,AX
 42917                                  ;
 42918                                  ;----------------------------------------------------------------------------
 42919                                  
 42920                                  patch_vec_segments:
 42921                                  
 42922 00007A9A 06                      	push	es
 42923                                  
 42924 00007A9B 31C9                    	xor	cx,cx ; 0
 42925 00007A9D 8EC1                    	mov	es,cx
 42926                                  
 42927                                  	;mov	di,82h
 42928 00007A9F BF8200                  	mov	di,INTBASE+2		; di -> segment of int 20 vector
 42929                                  
 42930 00007AA2 26A30200                	mov	[es:2],ax		; segment of default divide trap handler
 42931                                  
 42932                                  					; set vectors 20 & 21
 42933                                  	; 04/11/2022
 42934                                  	;mov	cx,2
 42935                                  	; 17/12/2022
 42936                                  	;mov	cl,2
 42937                                  ps_set1:
 42938 00007AA6 AB                      	stosw	; int 20h segment
 42939                                  	;add	di,2
 42940                                  	; 17/12/2022
 42941 00007AA7 47                      	inc	di
 42942 00007AA8 47                      	inc	di
 42943                                  	;loop	ps_set1
 42944                                  
 42945                                  	; 17/12/2022
 42946 00007AA9 AB                      	stosw	; int 21h segment
 42947                                  	;inc	di
 42948                                  	;inc	di
 42949                                  
 42950                                  	;add	di,4			; skip int 22h vector
 42951 00007AAA 83C706                  	add	di,6 ; *
 42952                                  
 42953 00007AAD AB                      	stosw				; set int 23h
 42954 00007AAE 83C706                  	add	di,6			; skip int 24h
 42955                                  
 42956                                  					; set vectors 25-28 and 2a-3f 
 42957                                  	; 04/11/2022
 42958                                  	;mov	cx,4			; set 4 segments
 42959                                  	; 17/12/2022
 42960 00007AB1 B104                    	mov	cl,4
 42961                                  ps_set2:
 42962 00007AB3 AB                      	stosw				
 42963                                  	;add	di,2
 42964                                  	; 17/12/2022
 42965 00007AB4 47                      	inc	di
 42966 00007AB5 47                      	inc	di
 42967 00007AB6 E2FB                    	loop	ps_set2
 42968                                  
 42969 00007AB8 83C704                  	add	di,4			; skip int 29h vector (fast con) as it may
 42970                                  					;   already be set.
 42971                                  	; 04/11/2022
 42972                                  	;mov	cx,6			; set 6 segs (skip 2 between each)
 42973                                  	; 17/12/2022
 42974 00007ABB B106                    	mov	cl,6			;  set segs for ints 2ah-2fh
 42975                                  ps_set3:
 42976 00007ABD AB                      	stosw
 42977                                  	;add	di,2
 42978                                  	; 17/12/2022
 42979 00007ABE 47                      	inc	di
 42980 00007ABF 47                      	inc	di
 42981 00007AC0 E2FB                    	loop	ps_set3
 42982                                  
 42983                                  ; 30h & 31H is the CPM call entry point whose segment address is set up by
 42984                                  ; below. So skip it.
 42985                                  
 42986 00007AC2 83C708                  	add	di,8			; skip vector 30h & 31h 
 42987                                  	
 42988                                  	; 04/11/2022
 42989                                  	;mov	cx,14			; set 14 segs (skip 2 between each)
 42990                                  	; 17/12/2022
 42991 00007AC5 B10E                    	mov	cl,14			;   sets segs for ints 32h-3fh
 42992                                  ps_set4:
 42993 00007AC7 AB                      	stosw
 42994                                  	;add	di,2
 42995                                  	; 17/12/2022
 42996 00007AC8 47                      	inc	di
 42997 00007AC9 47                      	inc	di
 42998 00007ACA E2FB                    	loop	ps_set4
 42999                                  
 43000                                  ; set offset of int2f
 43001                                  
 43002                                  ;if installed
 43003                                  ;	mov	word ptr es:[02fh * 4],offset doscode:int2f
 43004                                  ;endif
 43005                                  	;mov	[es:0C3h],ax
 43006 00007ACC 26A3C300                	mov	[es:ENTRYPOINT+3],ax
 43007                                  	; 17/12/2022
 43008                                  	; cx = 0
 43009 00007AD0 07                      	pop	es
 43010 00007AD1 C3                      	retn
 43011                                  
 43012                                  ;---------------------------------------------------------------------------
 43013                                  ;
 43014                                  ; Procedure Name : patch_misc_segments
 43015                                  ;
 43016                                  ; Inputs	 : es = segment to patch in
 43017                                  ;		   ds = dosdata
 43018                                  ;
 43019                                  ; outputs	 : patches in the sharer and other tables in the dos
 43020                                  ;		   with right dos code segment in es
 43021                                  ;
 43022                                  ; Regs Mod	 : DI,SI,CX
 43023                                  ;
 43024                                  ;---------------------------------------------------------------------------
 43025                                  
 43026                                  patch_misc_segments:
 43027                                  
 43028 00007AD2 53                      	push	bx
 43029 00007AD3 06                      	push	es
 43030 00007AD4 50                      	push	ax
 43031                                  
 43032 00007AD5 8CC0                    	mov	ax,es			; ax - > DOS segment
 43033                                  	
 43034 00007AD7 1E                      	push	ds
 43035 00007AD8 07                      	pop	es			; es -> DOSDATA
 43036                                  	
 43037                                  ; initialize the jump table for the sharer...
 43038                                  
 43039                                  	;mov	di,offset dosdata:jshare
 43040                                  	;mov	di,90h
 43041 00007AD9 BF[9000]                	mov	di,JShare
 43042                                  	;mov	bx,[0AAAh]
 43043 00007ADC 8B1E[AA0A]              	mov	bx,[TEMP_DOSLOC]	; bx = location to which the share
 43044                                  					; table was patched during the first
 43045                                  					; call to this routine
 43046 00007AE0 B90F00                  	mov	cx,15
 43047                                  jumptabloop:
 43048                                  	;add	di,2			; skip offset
 43049                                  	; 17/12/2022
 43050 00007AE3 47                      	inc	di
 43051 00007AE4 47                      	inc	di
 43052 00007AE5 83FBFF                  	cmp	bx,-1 ; 0FFFFh		; Q: is this called for the 1st time
 43053 00007AE8 7405                    	je	short share_patch	; Y: patch in sharer table
 43054                                  					; N: 
 43055 00007AEA 263B1D                  	cmp	bx,[es:di]		; Q: has share been installed
 43056 00007AED 7501                    	jne	short no_share_patch	; Y: don't patch in sharer table
 43057                                  share_patch:
 43058 00007AEF AB                      	stosw				; drop in segment
 43059                                  no_share_patch:
 43060 00007AF0 E2F1                    	loop	jumptabloop
 43061                                  					; BUGBUG patching the country info 
 43062                                  					; with dosdata can be done inline
 43063                                  					; in dosinit.
 43064                                  					; for dos 3.3 country info
 43065                                  					; table address
 43066                                  
 43067                                  	;mov	si,offset dosdata:country_cdpg
 43068                                  	;mov	si,122Ah   
 43069 00007AF2 BE[0012]                	mov	si,COUNTRY_CDPG
 43070                                  					; initialize double word
 43071                                  					; pointers with dosdata in ds
 43072                                  	;mov	[si+4Fh],ds
 43073                                  	;mov	[si+54h],ds
 43074                                  	;mov	[si+59h],ds
 43075                                  	;mov	[si+5Eh],ds
 43076                                  	;mov	[si+80h],ds
 43077                                  	;mov	[si+63h],ds
 43078 00007AF5 8C5C4F                  	mov	[si+DOS_CCDPG.ccUcase_ptr+2],ds    
 43079 00007AF8 8C5C54                  	mov	[si+DOS_CCDPG.ccFileUcase_ptr+2],ds 
 43080 00007AFB 8C5C59                  	mov	[si+DOS_CCDPG.ccFileChar_ptr+2],ds
 43081 00007AFE 8C5C5E                  	mov	[si+DOS_CCDPG.ccCollate_ptr+2],ds
 43082 00007B01 8C9C8000                	mov	[si+DOS_CCDPG.ccMono_ptr+2],ds
 43083 00007B05 8C5C63                  	mov	[si+DOS_CCDPG.ccDBCS_ptr+2],ds	
 43084                                  
 43085                                  					; fastopen routines are in doscode
 43086                                  					; so patch with doscode seg in ax
 43087                                  
 43088                                  	;mov	si,offset dosdata:fastopentable
 43089                                  	;mov	si,0D30h
 43090 00007B08 BE[300D]                	mov	si,FastOpenTable
 43091                                  
 43092                                  	; 17/12/2022
 43093                                  	; bx = [TEMP_DOSLOC]
 43094 00007B0B 83FBFF                  	cmp	bx,-1
 43095                                  	;cmp	word [TEMP_DOSLOC],-1	; Q: first time 
 43096 00007B0E 7405                    	je	short fast_patch	; Y: patch segment
 43097                                  	;mov	cx,[TEMP_DOSLOC]
 43098                                  					; Q: has fastopen patched in it's
 43099                                  					;    segment
 43100                                  	; 17/12/2022
 43101 00007B10 3B5C04                  	cmp	bx,[si+fastopen_entry.name_caching+2]
 43102                                  	;;cmp	cx,[si+4]
 43103                                  	;cmp	cx,[si+fastopen_entry.name_caching+2]
 43104 00007B13 7503                    	jne	short no_fast_patch	; Y: don't patch in doscode seg
 43105                                  
 43106                                  fast_patch:
 43107                                  	;mov	[si+4],ax
 43108 00007B15 894404                  	mov	[si+fastopen_entry.name_caching+2],ax
 43109                                  no_fast_patch:
 43110                                  	; 17/12/2022
 43111                                  	; cx = 0
 43112 00007B18 58                      	pop	ax
 43113 00007B19 07                      	pop	es
 43114 00007B1A 5B                      	pop	bx
 43115                                  
 43116 00007B1B C3                      	retn
 43117                                  
 43118                                  ;--------------------------------------------------------------------------
 43119                                  ;
 43120                                  ; Procedure Name : patch_offset
 43121                                  ; 
 43122                                  ; Inputs	 : NONE
 43123                                  ;
 43124                                  ; Outputs	 : Patches in the offsets in the low_mem_stub for vectors
 43125                                  ;		   0,20-28,3a-3f, and 30,31
 43126                                  ;
 43127                                  ;
 43128                                  ; Regs. Mod	 : AX,DI,CX
 43129                                  ;--------------------------------------------------------------------------
 43130                                  
 43131                                  patch_offset:
 43132 00007B1C 06                      	push	es		; preserve es
 43133                                  
 43134 00007B1D 31C0                    	xor	ax,ax
 43135 00007B1F 8EC0                    	mov	es,ax
 43136                                  				; set default divide trap address
 43137                                  	;mov	word ptr es:[0],offset dosdata:ldivov	
 43138                                  	;mov	word [es:0],108Ah
 43139 00007B21 26C7060000[7010]        	mov	word [es:0],ldivov
 43140                                  
 43141                                  	;mov	di,80h
 43142 00007B28 BF8000                  	mov	di,INTBASE	; di-> offset of int 20 handler
 43143                                  	;mov	ax,offset dosdata:lirett
 43144                                  	;mov	ax,10DAh
 43145 00007B2B B8[C010]                	mov	ax,lirett
 43146                                  				; set vectors 20 & 21 to point to iret.
 43147                                  	; 17/12/2022
 43148                                  	; cx = 0
 43149                                  
 43150                                  	;mov	cx,2		; set 2 offsets (skip 2 between each)
 43151                                  po_iset1:
 43152 00007B2E AB                      	stosw	; int 20h offset
 43153                                  	;add	di,2 ; *
 43154                                  	;loop	po_iset1
 43155                                  	; 17/12/2022
 43156 00007B2F 47                      	inc	di
 43157 00007B30 47                      	inc	di
 43158 00007B31 AB                      	stosw	; int 21h offset
 43159                                  
 43160                                  	;add	di,4		; skip vector 22h
 43161                                  	; 17/12/2022
 43162 00007B32 83C706                  	add	di,6 ; *	
 43163                                  
 43164 00007B35 AB                      	stosw			; set offset of 23h
 43165                                  	;add	di,6		; skip 24h
 43166                                  	; 19/09/2023
 43167 00007B36 83C712                  	add	di,18		; skip 23h segment and int 24-25-26-27h
 43168                                  
 43169                                  				; set vectors 25-28 and 2a-3f to iret.
 43170                                  	; 04/11/2022
 43171                                  	;mov	cx,4		; set 4 offsets (skip 2 between each)
 43172                                  	; 19/09/2023
 43173                                  	; 17/12/2022
 43174                                  	;mov	cl,4		;   sets offsets for ints 25h-28h
 43175                                  po_iset2:
 43176 00007B39 AB                      	stosw		; set offset for int 28h ; 19/09/2023
 43177                                  	;add	di,2
 43178                                  	; 19/09/2023
 43179                                  	; 17/12/2022
 43180                                  	;inc	di
 43181                                  	;inc	di
 43182                                  	; 19/09/2023
 43183                                  	;loop	po_iset2
 43184                                  
 43185                                  	;add	di,4		; skip vector 29h
 43186                                  	; 19/09/2023
 43187 00007B3A 83C706                  	add	di,6	; skip int 28h segment and int 29h ; 19/09/2023
 43188                                  
 43189                                  	; 04/11/2022
 43190                                  	;mov	cx,6		; set 6 offsets (skip 2 between each)
 43191                                  	; 17/12/2022
 43192                                  	;mov	cl,6		;   sets offsets for ints 2ah-2fh
 43193 00007B3D B105                    	mov	cl,5		; sets offsets for ints 2Ah-2Eh
 43194                                  po_iset3:
 43195 00007B3F AB                      	stosw
 43196                                  	;add	di,2
 43197                                  	; 17/12/2022
 43198 00007B40 47                      	inc	di
 43199 00007B41 47                      	inc	di
 43200 00007B42 E2FB                    	loop	po_iset3
 43201                                  
 43202                                  ; 30h & 31H is the CPM call entry point whose offset address is set up by
 43203                                  ; below. So skip it.
 43204                                  
 43205                                  	;add	di,8		; skip vector 30h & 31h 
 43206                                  	; 17/12/2022
 43207 00007B44 83C70C                  	add	di,12		; skip vector 2Fh, 30h & 31h
 43208                                  
 43209                                  	; 04/11/2022
 43210                                  	;mov	cx,14		; set 14 offsets (skip 2 between each)
 43211                                  				;   sets offsets for ints 32h-3fh
 43212                                  	; 17/12/2022
 43213 00007B47 B10E                    	mov	cl,14 ; 26/06/2019
 43214                                  po_iset4:
 43215 00007B49 AB                      	stosw
 43216                                  	;add	di,2
 43217                                  	; 17/12/2022
 43218 00007B4A 47                      	inc	di
 43219 00007B4B 47                      	inc	di
 43220 00007B4C E2FB                    	loop	po_iset4
 43221                                  
 43222                                  ;if installed
 43223                                  	;mov	word ptr es:[02fh * 4],offset dosdata:lint2f
 43224                                  	;mov	word [es:0BCh],10C6h ; (MSDOS 5.0 & 6.21)
 43225 00007B4E 26C706BC00[AC10]        	mov	word [es:(2Fh*4)],lint2f
 43226                                  ;endif
 43227                                  
 43228                                  ; set up entry point call at vectors 30-31h
 43229                                  	;mov	byte [es:0C0h],0EAh
 43230 00007B55 26C606C000EA            	mov	byte [es:ENTRYPOINT],mi_long_jmp
 43231                                  	;mov	word [es:0C1h],10D0h
 43232                                  
 43233 00007B5B 26C706C100[B610]        	mov	word [es:ENTRYPOINT+1],lcall_entry
 43234                                  
 43235                                  							; 19/09/2023
 43236                                  	;mov	word [es:80h],1094h
 43237 00007B62 26C7068000[7A10]        	mov	word [es:addr_int_abort],lquit		; int 20h
 43238                                  	;mov	word [es:84h],109Eh
 43239 00007B69 26C7068400[8410]        	mov	word [es:addr_int_command],lcommand	; int 21h
 43240                                  	;mov	word [es:94h],10A8h
 43241 00007B70 26C7069400[8E10]        	mov	word [es:addr_int_disk_read],labsdrd	; int 25h  
 43242                                  	;mov	word [es:98h],10B2h
 43243 00007B77 26C7069800[9810]        	mov	word [es:addr_int_disk_write],labsdwrt	; int 26h
 43244                                  	;mov	word [es:9Ch],10BCh
 43245 00007B7E 26C7069C00[A210]        	mov	word [es:addr_int_keep_process],lstay_resident	; int 27h
 43246                                  
 43247                                  	; 17/12/2022
 43248                                  	; CX = 0
 43249 00007B85 07                      	pop	es		; restore es
 43250 00007B86 C3                      	retn
 43251                                  
 43252                                  ;--------------------------------------------------------------------------
 43253                                  ;
 43254                                  ; 	Procedure Name	:	patch_in_nops
 43255                                  ;
 43256                                  ; 	Entry		: 	ES -> DOSDATA
 43257                                  ;
 43258                                  ;	Regs Mod	: 	cx, di
 43259                                  ;
 43260                                  ;	Description:
 43261                                  ;		This routine patches in 2 nops at the offsets specified in 
 43262                                  ;	patch_table. This basically enables the low mem stub to start 
 43263                                  ;	making XMS calls.
 43264                                  ;
 43265                                  ;--------------------------------------------------------------------------
 43266                                  
 43267                                  	; 04/11/2022
 43268                                  	; (MSDOS 5.0 MSDOS.SYS)
 43269                                  	; DOSCODE:0BC50h
 43270                                  
 43271                                  patch_table:	; label	byte
 43272                                  	;dw	offset dosdata:i0patch
 43273                                  	;dw	offset dosdata:i20patch
 43274                                  	;dw	offset dosdata:i21patch
 43275                                  	;dw	offset dosdata:i25patch
 43276                                  	;dw	offset dosdata:i26patch
 43277                                  	;dw	offset dosdata:i27patch
 43278                                  	;dw	offset dosdata:i2fpatch
 43279                                  	;dw	offset dosdata:cpmpatch
 43280 00007B87 [7010]                  	dw	i0patch
 43281 00007B89 [7A10]                  	dw	i20patch
 43282 00007B8B [8410]                  	dw	i21patch
 43283 00007B8D [8E10]                  	dw	i25patch
 43284 00007B8F [9810]                  	dw	i26patch
 43285 00007B91 [A210]                  	dw	i27patch
 43286 00007B93 [AC10]                  	dw	i2fpatch
 43287 00007B95 [B610]                  	dw	cpmpatch
 43288                                  
 43289                                  patch_table_size equ ($-patch_table)/2
 43290                                  
 43291                                  patch_in_nops:
 43292 00007B97 50                      	push	ax
 43293 00007B98 56                      	push	si
 43294 00007B99 BE[877B]                	mov	si,patch_table
 43295 00007B9C B89090                  	mov	ax,9090h ; nop, nop
 43296                                  	; 17/12/2022
 43297                                  	; cx = 0
 43298                                  	;mov	cx,8
 43299                                  	;mov	cx,patch_table_size ; 8
 43300 00007B9F B108                    	mov	cl,patch_table_size ; 8
 43301                                  pin_loop:
 43302 00007BA1 2E8B3C                  	mov	di,[cs:si]
 43303 00007BA4 AB                      	stosw
 43304                                  	;add	si,2
 43305                                  	; 17/12/2022
 43306 00007BA5 46                      	inc	si
 43307 00007BA6 46                      	inc	si
 43308 00007BA7 E2F8                    	loop	pin_loop
 43309 00007BA9 5E                      	pop	si
 43310 00007BAA 58                      	pop	ax
 43311 00007BAB C3                      	retn
 43312                                  
 43313                                  ; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
 43314                                  ; ---------------------------------------------------------------------------
 43315                                  ; MSDOS 5.0 - MSDOS.SYS offset BC77h, file offset 7EA7h
 43316                                  ; ---------------------------------------------------------------------------
 43317                                  
 43318                                  	; 05/12/2022 - temporary ; (paragraph alinment)
 43319                                  DOSCODE_END:
 43320                                  	;times	9 db 0	; db 9 dup(0)
 43321                                  	; 18/12/2022
 43322 00007BAC 0000                    	dw	0  ;	times 2 db 0
 43323                                  
 43324                                  ;align 16
 43325                                  	; DOSCODE:BC80h	(MSDOS 5.0 MSDOS.SYS file offset 7EB0h)
 43326                                  	; MSDOS.SYS file offset: 32432 (start of DOSDATA)
 43327                                  
 43328                                  ; ---------------------------------------------------------------------------
 43329                                  
 43330                                  
 43331                                  ;memstrt label word
 43332                                  ; ---------------------------------------------------------------------------
 43333                                  ; MSDOS 6.21 - MSDOS.SYS offset BF69h, file offset 8189h
 43334                                  ; ---------------------------------------------------------------------------
 43335                                  
 43336                                  MEMSTRT: ; 25/04/2019 - Retro DOS v4.0
 43337                                  
 43338                                  ; if not ROMDOS, then we close the dos code segment, otherwise we close
 43339                                  ; the dos initialization segment
 43340                                  
 43341                                  ;ifndef ROMDOS
 43342                                  
 43343                                  ;doscode ends
 43344                                  
 43345                                  ;else
 43346                                  
 43347                                  ;;dosinitseg ends
 43348                                  
 43349                                  ;endif ; ROMDOS
 43350                                  
 43351                                  ;============================================================================
 43352                                  
 43353                                  ; DPUBLIC <ParaRound, cXMM_no_driver, cXMMexit, char_init_loop, charinit>
 43354                                  ; DPUBLIC <check_XMM, continit, dosinttabloop, endlist>
 43355                                  ; DPUBLIC <initiret, iset1, iset2, jumptabloop, nxtentry>
 43356                                  ; DPUBLIC <notmax,  patch_offset, perdrv>
 43357                                  ; DPUBLIC <perunit, po_iset1, po_iset2, po_iset3>
 43358                                  ; DPUBLIC <ps_set1, ps_set2, ps_set3, seg_reinit>
 43359                                  ; DPUBLIC <sr_done, version_fake_table, xxx>
 43360                                  
 43361                                  ;; burasý doscode sonu
 43362                                  
 43363                                  ;============================================================================
 43364                                  ; DOSDATA
 43365                                  ;============================================================================
 43366                                  ; 29/04/2019 - Retro DOS 4.0
 43367                                  
 43368                                  ;[BITS 16]
 43369                                  
 43370                                  ;[ORG 0]
 43371                                  
 43372                                  ; 25/04/2019 - Retro DOS v4.0
 43373                                  
 43374                                  ;============================================================================
 43375                                  ; DOSDATA - MSDOS 6.21 - MSDOS.SYS Offset 0BF70h, file offset 8190h
 43376                                  ;============================================================================
 43377                                  
 43378                                  ;align 16
 43379                                  	; DOSDATA (MSDOS.SYS kernel DATA) segment starts here...
 43380                                  	; (4970 bytes for MSDOS 6.21)
 43381                                  	; (4976 bytes for Retro DOS v4.0, 25/05/2019 modification.)
 43382                                  
 43383                                  ;============================================================================
 43384                                  ; MSCONST.ASM (MSDOS 6.0, 1991)
 43385                                  ;============================================================================
 43386                                  ; 03/11/2022 - Retro DOS 4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 43387                                  ; 25/04/2019 - Retro DOS 4.0 (MSDOS 6.21)
 43388                                  ; 16/07/2018 - Retro DOS 3.0	
 43389                                  
 43390                                  ;Break <Initialized data and data used at DOS initialization>
 43391                                  ;----------------------------------------------------------------------------
 43392                                  
 43393                                  ; We need to identify the parts of the data area that are relevant to tasks
 43394                                  ; and those that are relevant to the system as a whole. Under 3.0, the system
 43395                                  ; data will be gathered with the system code. The process data under 2.x will
 43396                                  ; be available for swapping and under 3.0 it will be allocated per-process.
 43397                                  ;
 43398                                  ; The data that is system data will be identified by [SYSTEM] in the comments
 43399                                  ; describing that data item.
 43400                                  
 43401                                  ;DOSDATA SEGMENT
 43402                                  
 43403                                  ; 04/11/2022
 43404                                  ;[ORG 0]
 43405                                  
 43406                                  ; ----------------------------------------------------------------------------
 43407                                  ; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 43408                                  ; ----------------------------------------------------------------------------
 43409                                  ; DOSDATA segment start offset from beginning of MSDOS.SYS file: 32432 (7EB0h)
 43410                                  ; (3DD0h+7EB0h = 0BC80h) - for MSDOS 5.0 kernel file -
 43411                                  ; ----------------------------------------------------------------------------
 43412                                  
 43413                                  ; 04/11/2022
 43414                                  
 43415                                  ;DOSDATA:0000h
 43416                                  
 43417 00007BAE 90<rep 2h>              align 16
 43418                                  
 43419                                  ; ----------------------------------------------------------------------------
 43420                                  ; 06/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 43421                                  ; ----------------------------------------------------------------------------
 43422                                  
 43423                                  segment .data  vstart=0 ; 06/12/2022
 43424                                  								
 43425                                  ; ============================================================================
 43426                                  
 43427                                  ; 06/12/2022
 43428                                  ;DOSDATASTART equ $
 43429                                  DOSDATASTART:
 43430                                  
 43431                                  
 43432                                  ;hkn; add 4 bytes to get correct offsets since jmp has been removed in START
 43433                                  
 43434                                  	;; 03/11/2022
 43435                                  	;jmp	DOSINIT		; MSDOS 5.0 - MSDOS.SYS (DOSDATA:0000h)
 43436                                  
 43437                                  	; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 43438                                  	;db	4 dup (?)	
 43439 00000000 00<rep 4h>              	times	4 db 0
 43440                                  
 43441                                  	; 29/04/2019 - Retro DOS v4.0 modification
 43442                                  	;dw 	_$STARTCODE ; DOSCODE offset and/or size of DOSDATA
 43443                                  	;dw	0
 43444                                  
 43445                                  	;EVEN
 43446                                  
 43447                                  ;align 2
 43448                                  
 43449                                  ; WANGO!!! The following word is used by SHARE and REDIR to determin data
 43450                                  ; area compatability. This location must be incremented EACH TIME the data
 43451                                  ; area here gets mucked with.
 43452                                  ;
 43453                                  ; Also, do NOT change this position relative to DOSDATA:0.
 43454                                  
 43455                                  MSCT001S:	; LABEL BYTE
 43456                                  	
 43457                                  DataVersion:	
 43458 00000004 0100                    	dw	1	;AC000; [SYSTEM] version number for DOS DATA
 43459                                  
 43460                                  ;hkn; add 8 bytes to get correct offsets since BugTyp, BugLev and "BUG " has 
 43461                                  ;hkn; been removed to DOSCODE above
 43462                                  
 43463                                  ;M044
 43464                                  ; First part of save area for saving last para of Window memory
 43465                                  
 43466                                  WinoldPatch1:	; db 8 dup (?)	;M044
 43467 00000006 00<rep 8h>              	times	8 db 0
 43468                                  
 43469                                  	; MSDOS 6.21 DOSDATA:000Eh
 43470                                  MYNUM:			; Offset 000Eh
 43471 0000000E 0000                    	dw	0	; [SYSTEM] A number that goes with MYNAME
 43472                                  FCBLRU: 		; [SYSTEM] LRU count for FCB cache
 43473 00000010 0000                    	dw	0
 43474                                  OpenLRU:
 43475 00000012 0000                    	dw	0	; [SYSTEM] LRU count for FCB cache opens
 43476                                  OEM_HANDLER: 		
 43477 00000014 FFFFFFFF                	dd	-1	; [SYSTEM] Pointer to OEM handler code	
 43478                                  
 43479                                  ;	BUGBUG - who uses LeaveAddr?  What if we want to rework the
 43480                                  ;;			way that we leave DOS???? - jgl
 43481                                  
 43482                                  LeaveAddr:
 43483 00000018 [1204]                  	dw	LeaveDOS  ; <<OFFSET DOSCODE:LeaveDOS>> ; [SYSTEM]
 43484                                  RetryCount:		
 43485 0000001A 0300                    	dw	3	; [SYSTEM] Share retries
 43486                                  RetryLoop:
 43487 0000001C 0100                    	dw	1	; [SYSTEM] Share retries
 43488                                  LastBuffer:
 43489 0000001E FFFFFFFF                	dd	-1	; [SYSTEM] Buffer queue recency pointer
 43490                                  CONTPOS:
 43491 00000022 0000                    	dw	0	; [SYSTEM] location in buffer of next read
 43492                                  arena_head:
 43493 00000024 0000                    	dw	0	; [SYSTEM] Segment # of first arena in memory
 43494                                  
 43495                                  ;; 16/07/2018
 43496                                  ;;***************************************************************************
 43497                                  ;; NOTE: INT 21H AH=52H !  (http://stanislavs.org/helppc/int_21-52.html)
 43498                                  ;;***************************************************************************
 43499                                  ;; INT 21,52 - Get Pointer to DOS "INVARS" (Undocumented)
 43500                                  ;;
 43501                                  ;;	AH = 52h
 43502                                  ;;
 43503                                  ;;	on return:
 43504                                  ;;	ES:BX = pointer to DOS "invars", a table of pointers used by DOS.
 43505                                  ;;		Known "invars" fields follow (varies with DOS version):
 43506                                  ;;
 43507                                  ;;	Offset Size		 Description
 43508                                  ;;
 43509                                  ;;	 -12   word   sharing retry count (DOS 3.1-3.3)
 43510                                  ;;	 -10   word   sharing retry delay  (DOS 3.1-3.3)
 43511                                  ;;	  -8   dword  pointer to current disk buffer (DOS 3.x)
 43512                                  ;;	  -4   word   pointer in DOS code segment of unread CON input;
 43513                                  ;;		      0 indicates no unread input (DOS 3.x)
 43514                                  ;;	  -2   word   segment of first Memory Control Block (MCB)
 43515                                  ;;	  00   dword  pointer to first DRIVE PARAMETER TABLE (A:) in chain
 43516                                  ;;	  04   dword  pointer to DOS System File Table (SFT)
 43517                                  ;;	  08   dword  pointer to $CLOCK device driver
 43518                                  ;;	  0C   dword  pointer to CON device driver
 43519                                  ;;	  10   byte   number of logical drives in system
 43520                                  ;;	  11   word   maximum bytes/block of any block device
 43521                                  ;;	  13   dword  pointer to DOS cache buffer header
 43522                                  ;;	  17 18bytes  NUL device header, first 4 bytes of device header
 43523                                  ;;		      point to the next device in device chain
 43524                                  ;;
 43525                                  ;;***************************************************************************
 43526                                  
 43527                                  ; The following block of data is used by SYSINIT. 
 43528                                  ; Do not change the order or size of this block
 43529                                  
 43530                                  ;SYSINITVAR:
 43531                                  ;----------------------------------------------------------------------------
 43532                                  SYSINITVARS:
 43533                                  DPBHEAD:
 43534 00000026 00000000                	dd	0	; [SYSTEM] Pointer to head of DPB-FAT list
 43535                                  SFT_ADDR:
 43536 0000002A [CC000000]              	dd	SFTABL	; [SYSTEM] Pointer to first SFT table
 43537                                  BCLOCK:
 43538 0000002E 00000000                	dd	0	; [SYSTEM] The CLOCK device
 43539                                  BCON:
 43540 00000032 00000000                	dd	0	; [SYSTEM] Console device entry points
 43541                                  MAXSEC:
 43542 00000036 8000                    	dw	128	; [SYSTEM] Maximum allowed sector size
 43543                                  BUFFHEAD:
 43544 00000038 00000000                	dd	0	; [SYSTEM] Pointer to head of buffer queue
 43545                                  CDSADDR:
 43546 0000003C 00000000                	dd	0	; [SYSTEM] Pointer to curdir structure table
 43547                                  SFTFCB:
 43548 00000040 00000000                	dd	0	; [SYSTEM] pointer to FCB cache table
 43549                                  KEEPCOUNT:
 43550 00000044 0000                    	dw	0	; [SYSTEM] count of FCB opens to keep
 43551                                  NUMIO:
 43552 00000046 00                      	db	0	; [SYSTEM] Number of disk tables
 43553                                  CDSCOUNT:
 43554 00000047 00                      	db	0	; [SYSTEM] Number of CDS structures in above
 43555                                  
 43556                                  ; A fake header for the NUL device
 43557                                  NULDEV:
 43558 00000048 00000000                	dd	0	; [SYSTEM] Link to rest of device list
 43559                                  	;dw	8004h
 43560 0000004C 0480                    	dw	DEVTYP|ISNULL ; [SYSTEM] Null device attributes
 43561 0000004E [C60D]                  	dw	SNULDEV	; [SYSTEM] Strategy entry point
 43562 00000050 [CB0D]                  	dw	INULDEV	; [SYSTEM] Interrupt entry point
 43563 00000052 4E554C2020202020        	db	"NUL     " ; [SYSTEM] Name of null device
 43564                                  SPLICES:
 43565 0000005A 00                      	db	0	; [SYSTEM] TRUE => splices being done
 43566                                  
 43567                                  Special_Entries:
 43568 0000005B 0000                    	dw	0	; [SYSTEM] address of special entries ;AN000;
 43569                                  UU_IFS_DOS_CALL:
 43570 0000005D 00000000                	dd	0	; [SYSTEM] entry for IFS DOS service ;AN000;
 43571                                  ; 
 43572                                  ; UU_IFS_HEADER:
 43573                                  ; 	dd	0	; [SYSTEM] IFS header chain ;AN000;
 43574                                  
 43575                                  ChkCopyProt:
 43576 00000061 0000                    	dw	0	; M068
 43577                                  A20OFF_PSP:
 43578 00000063 0000                    	dw	0	; M068
 43579                                  BUFFERS_PARM1:
 43580 00000065 0000                    	dw	0	; [SYSTEM] value of BUFFERS= ,m	;AN000;
 43581                                  BUFFERS_PARM2:
 43582 00000067 0000                    	dw	0	; [SYSTEM] value of BUFFERS= ,n ;AN000;
 43583                                  BOOTDRIVE:
 43584 00000069 00                      	db	0	; [SYSTEM] the boot drive ;AN000;
 43585                                  DDMOVE:
 43586 0000006A 00                      	db	0 	; [SYSTEM] 1 if we need DWORD move ;AN000;
 43587                                  EXT_MEM_SIZE:
 43588 0000006B 0000                    	dw	0	; [SYSTEM] extended memory size	;AN000;
 43589                                  
 43590                                  HASHINITVAR: ; LABEL   WORD	; AN000;
 43591                                  ;
 43592                                  ; Replaced by next two declarations
 43593                                  ;
 43594                                  ;UU_BUF_HASH_PTR:
 43595                                  ;	dd	0	; [SYSTEM] buffer Hash table addr
 43596                                  ;UU_BUF_HASH_COUNT:
 43597                                  ;	dw	1	; [SYSTEM] number of Hash entries
 43598                                  
 43599                                  BufferQueue:
 43600 0000006D 00000000                	dd	0	; [SYSTEM] Head of the buffer Queue
 43601                                  DirtyBufferCount:
 43602 00000071 0000                    	dw	0	; [SYSTEM] Count of Dirty buffers in the Que
 43603                                  			; BUGBUG ---- change to byte
 43604                                  SC_CACHE_PTR:
 43605 00000073 00000000                	dd	0	; [SYSTEM] secondary cache pointer
 43606                                  SC_CACHE_COUNT:
 43607 00000077 0000                    	dw	0 	; [SYSTEM] secondary cache count
 43608                                  BuffInHMA:
 43609 00000079 00                      	db	0	; Flag to indicate that buffs are in HMA
 43610                                  LoMemBuff:
 43611 0000007A 00000000                	dd	0	; Ptr to intermediate buffer
 43612                                  			;  in Low mem when buffs are in HMA
 43613                                  ;
 43614                                  ; All variables which have UU_ as prefix can be reused for other
 43615                                  ; purposes and can be renamed. All these variables were used for
 43616                                  ; EMS support of Buffer Manager. Now they are useless for Buffer
 43617                                  ; manager ---- MOHANS
 43618                                  ;
 43619                                  	;I_am	UU_BUF_EMS_FIRST_PAGE,3,<0,0,0>  
 43620                                  UU_BUF_EMS_FIRST_PAGE:	
 43621 0000007E 000000                  	db	0,0,0	; holds the first page above 640K
 43622                                  
 43623                                  	;;I_am	UU_BUF_EMS_NPA640,WORD,<0> ; holds the number of pages 
 43624                                  ;UU_BUF_EMS_NPA640:			   ; above 640K	
 43625                                  ;	dw	0			
 43626                                  
 43627                                  CL0FATENTRY:
 43628 00000081 FFFF                    	dw	-1	; M014:	Holds the data that
 43629                                  			; is used in pack/unpack rts.
 43630                                  			; in fat.asm if cluster 0 is specified.
 43631                                  			; SR;
 43632                                  IoStatFail:
 43633 00000083 00                      	db	0	; IoStatFail has been added to 
 43634                                  			; record a fail on an I24 
 43635                                  			; issued from IOFUNC on a status call. 
 43636                                  
 43637                                  ;***	I_am	UU_BUF_EMS_MODE,BYTE,<-1>	; EMS mode 	;AN000;
 43638                                  ;***	I_am	UU_BUF_EMS_HANDLE,BYTE		; buffer EMS handle ;AN000;
 43639                                  ;***	I_am	UU_BUF_EMS_PAGE_FRAME,WORD ,<-1>; EMS page frame # ;AN000;
 43640                                  ;***	I_am	UU_BUF_EMS_SEG_CNT,WORD,<1>	; EMS seg count	;AN000;
 43641                                  ;***	I_am	UU_BUF_EMS_PFRAME,WORD		; EMS page frame seg address ;AN000;
 43642                                  ;***	I_am	UU_BUF_EMS_RESERV,WORD,<0> 	; reserved	;AN000;
 43643                                  ;
 43644                                  ;***	I_am	UU_BUF_EMS_MAP_BUFF,1,<0>	; this is not used to save the 
 43645                                  						; state of the 	buffers page.
 43646                                  						; This one byte is retained to 
 43647                                  						; keep the size of this data 
 43648                                  						; block the same.;
 43649                                  ALLOCMSAVE:
 43650 00000084 00                      	db	0	; M063: temp var. used to 
 43651                                  			; M063: save alloc method in
 43652                                  			; M063: msproc.asm
 43653                                  A20OFF_COUNT:
 43654 00000085 00                      	db	0	; M068: indiactes the # of 
 43655                                  			; M068: int 21 calls for 
 43656                                  			; M068: which A20 is off
 43657                                  DOS_FLAG:
 43658 00000086 00                      	db	0	; see DOSSYM.INC for Bit 
 43659                                  			; definitions
 43660                                  UNPACK_OFFSET:
 43661 00000087 0000                    	dw	0	; saves pointer to the start
 43662                                  			; of unpack code in exepatch.
 43663                                  			; asm.
 43664                                  UMBFLAG:
 43665 00000089 00                      	db	0 	; M003: bit 0 indicates the 
 43666                                  			; M003: link state of the UMBs
 43667                                  			; M003: whether linked or not 
 43668                                  			; M003: to the DOS arena chain
 43669                                  SAVE_AX:
 43670 0000008A 0000                    	dw	0	; M000: temp varibale to store ax
 43671                                  			; M000: in msproc.asm
 43672                                  UMB_HEAD:
 43673 0000008C FFFF                    	dw	-1	; M000: this is initialized to  
 43674                                  			; M000: the first umb arena by 
 43675                                  			; M000: BIOS sysinit.
 43676                                  START_ARENA:
 43677 0000008E 0100                    	dw	1	; M000: this is the first arena 
 43678                                  			; M000: from which DOS will 
 43679                                  			; M000: start its scan for alloc.
 43680                                  
 43681                                  ; End of SYSINITVar block
 43682                                  ;----------------------------------------------------------------------------
 43683                                  
 43684                                  ; 25/04/2019 - Retro DOS v4.0
 43685                                  
 43686                                  ; 16/07/2018
 43687                                  ; MSDOS 3.3 (& MDOS 6.0)
 43688                                  
 43689                                  ;
 43690                                  ; Sharer jump table
 43691                                  ;
 43692                                  
 43693                                  ;PUBLIC	JShare
 43694                                  	;EVEN
 43695                                  
 43696                                  ;JShare	LABEL	DWORD
 43697                                  ;	DW	OFFSET DOSCODE:BadCall, 0
 43698                                  ;	DW	OFFSET DOSCODE:OKCall,  0  ;	1   MFT_enter
 43699                                  ;	DW	OFFSET DOSCODE:OKCall,  0  ;	2   MFTClose
 43700                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	3   MFTclU
 43701                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	4   MFTCloseP
 43702                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	5   MFTCloN
 43703                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	6   set_block
 43704                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	7   clr_block
 43705                                  ;	DW	OFFSET DOSCODE:OKCall,  0  ;	8   chk_block
 43706                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	9   MFT_get
 43707                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	10  ShSave
 43708                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	11  ShChk
 43709                                  ;	DW	OFFSET DOSCODE:OKCall , 0  ;	12  ShCol
 43710                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	13  ShCloseFile
 43711                                  ;	DW	OFFSET DOSCODE:BadCall, 0  ;	14  ShSU
 43712                                  
 43713                                  align 2
 43714                                  
 43715                                  JShare:
 43716 00000090 [1007]0000              		DW	BadCall,0
 43717 00000094 [1407]0000              MFT_enter:	DW	OKCall, 0  ; 1   MFT_enter
 43718 00000098 [1407]0000              MFTClose:	DW	OKCall, 0  ; 2   MFTClose
 43719 0000009C [1007]0000              MFTclU:		DW	BadCall,0  ; 3   MFTclU
 43720 000000A0 [1007]0000              MFTCloseP:	DW	BadCall,0  ; 4   MFTCloseP
 43721 000000A4 [1007]0000              MFTCloN:	DW	BadCall,0  ; 5   MFTCloN
 43722 000000A8 [1007]0000              set_block:	DW	BadCall,0  ; 6   set_block
 43723 000000AC [1007]0000              clr_block:	DW	BadCall,0  ; 7   clr_block
 43724 000000B0 [1407]0000              chk_block:	DW	OKCall, 0  ; 8   chk_block
 43725 000000B4 [1007]0000              MFT_get:	DW	BadCall,0  ; 9   MFT_get
 43726 000000B8 [1007]0000              ShSave:		DW	BadCall,0  ; 10  ShSave
 43727 000000BC [1007]0000              ShChk:		DW	BadCall,0  ; 11  ShChk
 43728 000000C0 [1407]0000              ShCol:		DW	OKCall, 0  ; 12  ShCol
 43729 000000C4 [1007]0000              ShCloseFile:	DW	BadCall,0  ; 13  ShCloseFile
 43730 000000C8 [1007]0000              ShSU:		DW	BadCall,0  ; 14  ShSU
 43731                                  
 43732                                  
 43733                                  ;============================================================================
 43734                                  ; CONST2.ASM (MSDOS 6.0, 1991)
 43735                                  ;============================================================================
 43736                                  ; 25/04/2019 - Retro DOS 4.0 
 43737                                  ; 16/07/2018 - Retro DOS 3.0	
 43738                                  
 43739                                  ;Break <Initialized data and data used at DOS initialization>
 43740                                  ;----------------------------------------------------------------------------
 43741                                  
 43742                                  ; We need to identify the parts of the data area that are relevant to tasks
 43743                                  ; and those that are relevant to the system as a whole.  Under 3.0, the system
 43744                                  ; data will be gathered with the system code.  The process data under 2.x will
 43745                                  ; be available for swapping and under 3.0 it will be allocated per-process.
 43746                                  ;
 43747                                  ; The data that is system data will be identified by [SYSTEM] in the comments
 43748                                  ; describing that data item.
 43749                                  
 43750                                  ;DOSDATA SEGMENT WORD PUBLIC 'DATA'
 43751                                  
 43752                                  ;
 43753                                  ; Table of routines for assignable devices
 43754                                  ;
 43755                                  ; MSDOS allows assignment if the following standard devices:
 43756                                  ;   stdin  (usually CON input)
 43757                                  ;   stdout (usually CON output)
 43758                                  ;   auxin  (usually AUX input)
 43759                                  ;   auxout (usually AUX output)
 43760                                  ;   stdlpt (usually PRN output)
 43761                                  ;
 43762                                  ; SPECIAL NOTE:
 43763                                  ;   Status of a file is a strange idea. We choose to handle it in this manner:
 43764                                  ;   If we're not at end-of-file, then we always say that we have a character.
 43765                                  ;   Otherwise, we return ^Z as the character and set the ZERO flag. In this
 43766                                  ;   manner we can support program written under the old DOS (they use ^Z as EOF
 43767                                  ;   on devices) and programs written under the new DOS (they use the ZERO flag
 43768                                  ;   as EOF).
 43769                                  
 43770                                  ; Default SFTs for boot up
 43771                                  
 43772                                  		;PUBLIC	SFTABL
 43773                                  
 43774                                  SFTABL:	   ; LABEL   DWORD		; [SYSTEM] file table
 43775 000000CC FFFF                    		DW -1			; [SYSTEM] link to next table
 43776 000000CE FFFF                    		DW -1			; [SYSTEM] link seg to next table
 43777 000000D0 0500                    		DW sf_default_number	; [SYSTEM] Number of entries in table
 43778                                  		;times 295 db 0 ; MSDOS 6.0
 43779 000000D2 00<rep 127h>            		times (sf_default_number*sf_entry_size) db 0
 43780                                  
 43781                                  ; the next two variables relate to the position of the logical stdout/stdin
 43782                                  ; cursor. They are only meaningful when stdin/stdout are assigned to the
 43783                                  ; console.
 43784                                  		; DOSDATA:01F9h (MSDOS 6.21)
 43785 000001F9 00                      CARPOS:		db 0			; [SYSTEM] cursor position in stdin
 43786 000001FA 00                      STARTPOS:	db 0			; [SYSTEM] position of cursor at beginning
 43787                                  					;	   of buffered input call
 43788 000001FB 00<rep 80h>             INBUF:		times 128 db 0		; [SYSTEM] general device input buffer
 43789 0000027B 00<rep 83h>             CONBUF:		times 131 db 0		; [SYSTEM] The rest of INBUF and console buffer
 43790                                  		; DOSDATA:02FEh (MSDOS 6.21)
 43791 000002FE 00                      PFLAG:		db 0			; [SYSTEM] printer echoing flag
 43792 000002FF 00                      VERFLG:		db 0			; [SYSTEM] Initialize with verify off
 43793 00000300 03                      CHARCO:		db 00000011b		; [SYSTEM] Allows statchks every 4 chars...
 43794                                  switch_character:
 43795 00000301 2F                      chSwitch:	db '/'			; UNUSED - obsolete datum, can be reused
 43796 00000302 00                      AllocMethod:	db 0			; [SYSTEM] how to alloc first(best)last
 43797 00000303 00                      fShare:		db 0			; [SYSTEM] TRUE => sharing installed
 43798 00000304 01                      DIFFNAM:	db 1			; [SYSTEM] Indicates when MYNAME has changed
 43799 00000305 20<rep 10h>             MYNAME:		times 16 db 20h		; [SYSTEM] My network name
 43800                                  
 43801                                  ; The following table is a list of addresses that the sharer patches to be
 43802                                  ; PUSH AX to enable the critical sections
 43803                                  
 43804                                  		; DOSDATA:0315h (MSDOS 6.21)
 43805                                  
 43806                                  ;PUBLIC	CritPatch
 43807                                  
 43808                                  CritPatch:	; LABEL WORD
 43809                                  
 43810                                  ;IRP sect,<critDisk,critDevice>
 43811                                  
 43812                                  ;IF (NOT REDIRECTOR) AND (NOT SHAREF)
 43813                                  ;
 43814                                  ;SR; Change code patch address to a variable in data segment
 43815                                  ;
 43816                                  ;       dw OFFSET DOSDATA: redir_patch
 43817                                  ;       dw OFFSET DOSDATA: redir_patch
 43818                                  ;
 43819                                  ;;hkn	Short_Addr  E&sect
 43820                                  ;;hkn	Short_Addr  L&sect
 43821                                  ;
 43822                                  ;ELSE
 43823                                  ;	DW	0
 43824                                  ;	DW	0
 43825                                  ;ENDIF
 43826                                  ;ENDM
 43827                                  ;	DW	0
 43828                                  
 43829                                  	; 25/07/2019 - Retro DOS v4.0 (MSDOS 6.21)
 43830                                   
 43831 00000315 [0C0D]                  	dw 	redir_patch
 43832 00000317 [0C0D]                  	dw 	redir_patch			
 43833 00000319 [0C0D]                  	dw	redir_patch
 43834 0000031B [0C0D]                  	dw 	redir_patch
 43835                                  
 43836 0000031D 0000                    	dw	0
 43837                                  
 43838                                  ; WARNING!!! PRINT and PSPRINT *REQUIRE* ErrorMode to precede INDOS.
 43839                                  ; Also, IBM server 1.0 requires this also.
 43840                                  
 43841                                  	;EVEN			; Force swap area to start on word boundry
 43842 0000031F 90                      align 2
 43843                                  	;PUBLIC	SWAP_START
 43844                                  SWAP_START:	; LABEL BYTE
 43845 00000320 00                      ERRORMODE:	db 0		; Flag for INT 24 processing
 43846 00000321 00                      INDOS:		db 0		; DOS status for interrupt processing
 43847 00000322 FF                      WPERR:		db -1		; Write protect error flag
 43848 00000323 00                      EXTERR_LOCUS:	db 0		; Extended Error Locus
 43849 00000324 0000                    EXTERR:		dw 0		; Extended Error code
 43850                                  
 43851                                  ;WARNING Following two bytes Accessed as word in $GetExtendedError
 43852 00000326 00                      EXTERR_ACTION:	db 0		; Extended Error Action
 43853 00000327 00                      EXTERR_CLASS:	db 0		; Extended Error Class
 43854                                  ; end warning
 43855                                   
 43856 00000328 00000000                EXTERRPT:	dd 0		; Extended Error pointer
 43857                                  
 43858 0000032C 80000000                DMAADD:		dd 80h		; User's disk transfer address (disp/seg)
 43859 00000330 0000                    CurrentPDB:	dw 0		; Current process identifier
 43860 00000332 0000                    ConC_Spsave:	dw 0		; saved SP before ^C
 43861 00000334 0000                    exit_code:	dw 0		; exit code of last proc.
 43862 00000336 00                      CURDRV:		db 0		; Default drive (init A)
 43863 00000337 00                      CNTCFLAG:	db 0		; ^C check in dispatch disabled
 43864                                  ;				; F.C. 2/17/86
 43865 00000338 00                      CPSWFLAG:	db 0		; Code Page Switching Flag  DOS 4.00
 43866 00000339 00                      CPSWSAVE:	db 0		; copy of above in case of ABORT
 43867                                  ;align 2
 43868                                  SWAP_ALWAYS:	; 05/08/2018
 43869 0000033A 0000                    USER_IN_AX:	dw 0		; User INPUT AX value (used for
 43870                                  				;   extended error type stuff.
 43871                                  				;   NOTE: does not have Correct value on
 43872                                  				;   1-12, OEM, Get/Set CurrentPDB,
 43873                                  				;   GetExtendedError system calls)
 43874 0000033C 0000                    PROC_ID:	dw 0		; PID for sharing (0 = local)
 43875 0000033E 0000                    USER_ID:	dw 0		; Machine for sharing (0 = local)
 43876 00000340 0000                    FirstArena:	dw 0		; first free block found
 43877 00000342 0000                    BestArena:	dw 0		; best free block found
 43878 00000344 0000                    LastArena:	dw 0		; last free block found
 43879 00000346 0000                    ENDMEM:		dw 0		; End of memory used in DOSINIT
 43880 00000348 0000                    LASTENT:	dw 0		; Last entry for directory search
 43881 0000034A 00                      FAILERR:	db 0		; NZ if user did FAIL on I 24
 43882 0000034B 00                      ALLOWED:	db 0		; Allowed I 24 answers (see allowed_)
 43883 0000034C 00                      NoSetDir:	db 0		; true -> do not set directory
 43884 0000034D 00                      DidCTRLC:	db 0		; true -> we did a ^C exit
 43885 0000034E 00                      SpaceFlag:	db 0		; true -> embedded spaces are allowed in FC
 43886                                  
 43887                                  ; Warning!  The following items are accessed as a WORD in TIME.ASM
 43888                                  	;EVEN
 43889 0000034F 90                      align 2
 43890                                  		; DOSDATA:0350h (MSDOS 6.21)
 43891 00000350 00                      DAY:		db 0		; Day of month
 43892 00000351 00                      MONTH:		db 0		; Month of year
 43893 00000352 0000                    YEAR:		dw 0		; Year (with century)
 43894 00000354 FFFF                    DAYCNT:		dw -1		; Day count from beginning of year
 43895 00000356 00                      WEEKDAY:	db 0		; Day of week
 43896                                  ; end warning
 43897                                  
 43898 00000357 00                      CONSWAP:	db 0		; TRUE => console was swapped during device read
 43899 00000358 01                      IDLEINT:	db 1		; TRUE => idle int is allowed
 43900 00000359 00                      fAborting:	db 0		; TRUE => abort in progress
 43901                                  
 43902                                  ; Combination of all device call parameters
 43903                                  	;PUBLIC	DEVCALL 	;
 43904                                  ;DEVCALL SRHEAD	<>		; basic header for disk packet
 43905                                  DEVCALL: ; 08/08/2018
 43906 0000035A 00                      DEVCALL_REQLEN:  db 0 		;Length in bytes of request block
 43907 0000035B 00                      DEVCALL_REQUNIT: db 0		;Device unit number
 43908 0000035C 00                      DEVCALL_REQFUNC: db 0		;Type of request
 43909 0000035D 0000                    DEVCALL_REQSTAT: dw 0		;Status Word
 43910 0000035F 00<rep 8h>                       times 8 db 0		;Reserved for queue links
 43911                                  
 43912                                  	;PUBLIC	CALLUNIT
 43913                                  CALLUNIT: ; LABEL   BYTE	; unit number for disk
 43914                                  CALLFLSH: ; LABEL   WORD	;
 43915 00000367 00                      CALLMED:	db 0		; media byte
 43916                                  CALLBR:	  ; LABEL   DWORD	;
 43917                                  	;PUBLIC	CALLXAD 	;
 43918                                  CALLXAD:  ; LABEL   DWORD	;
 43919 00000368 00                      CALLRBYT:	db 0		;
 43920                                  	;PUBLIC	CALLVIDM	;
 43921                                  CALLVIDM: ; LABEL   DWORD	;
 43922 00000369 00<rep 3h>              	times 3 db 0	;
 43923                                  	;PUBLIC CallBPB		;
 43924                                  CALLBPB:  ; LABEL   DWORD	;
 43925                                  CALLSCNT:			;
 43926 0000036C 0000                    		dw 0		;
 43927                                  	;PUBLIC	CALLSSEC	;
 43928                                  CALLSSEC: ; LABEL   WORD	;
 43929 0000036E 0000                    		dw 0		;
 43930 00000370 00000000                CALLVIDRW:	dd 0		;
 43931                                  ;MSDOS 6.0
 43932 00000374 00000000                CALLNEWSC:	dd 0		; starting sector for >32mb
 43933 00000378 00000000                CALLDEVAD:	dd 0		; stash for device entry point
 43934                                  
 43935                                  ; Same as above for I/O calls	;
 43936                                  				;
 43937                                  	;PUBLIC	IOCall		;
 43938                                  ;IOCALL	SRHEAD	<>		;
 43939                                  IOCALL:	; 07/08/2018
 43940 0000037C 00                      IOCALL_REQLEN:	db 0		;Length in bytes of request block	
 43941 0000037D 00                      IOCALL_REQUNIT:	db 0		;Device unit number
 43942 0000037E 00                      IOCALL_REQFUNC: db 0		;Type of request
 43943 0000037F 0000                    IOCALL_REQSTAT: dw 0		;Status Word
 43944 00000381 00<rep 8h>              	times 8	db 0		;Reserved for queue links
 43945                                  IOFLSH:	  ; LABEL   WORD	;
 43946                                          ;PUBLIC  IORCHR		;
 43947                                  IORCHR:	  ; LABEL   BYTE	;
 43948 00000389 00                      IOMED:		db 0		;
 43949 0000038A 00000000                IOXAD:		dd 0		;
 43950 0000038E 0000                    IOSCNT:		dw 0		;	
 43951 00000390 0000                    IOSSEC:		dw 0		;
 43952                                  
 43953                                  ; Call struct for DSKSTATCHK	;
 43954 00000392 0E                      DSKSTCALL:	db DRDNDHL 	; = 14
 43955 00000393 00                      		db 0
 43956 00000394 05                      DSKSTCOM:	db DEVRDND	; = 5
 43957 00000395 0000                    DSKSTST:	dw 0		;
 43958 00000397 00<rep 8h>              	times 8	db 0		;
 43959 0000039F 00                      DSKCHRET:	db 0		;
 43960                                  
 43961                                  ;hkn; short_addr has been changed to provide offset in DOSCODE.
 43962                                  ;hkn; deviobuf is in DATA seg (DOSDATA)
 43963                                  ;hkn   short_addr  DEVIOBUF	;
 43964                                  	
 43965 000003A0 [BC03]                  DEVIOBUF_PTR	dw DEVIOBUF
 43966 000003A2 0000                    DOSSEG_INIT	dw 0		; DOS segment set at Init
 43967 000003A4 0100                    DSKSTCNT:	dw 1		;
 43968 000003A6 0000                    		dw 0		;
 43969                                  
 43970 000003A8 00                      CreatePDB:	db 0		; flag for creating a process
 43971                                  
 43972                                  ;MSDOS 6.0
 43973                                  Lock_Buffer:	; LABEL  DWORD	;MS. DOS Lock Buffer for Ext Lock
 43974 000003A9 00000000                		dd 0		;MS. position
 43975 000003AD 00000000                		dd 0		;MS. length
 43976                                  
 43977                                  ;hkn; the foll. was moved from dosmes.asm.
 43978                                  
 43979                                  	;EVEN
 43980 000003B1 90                      align 2				; needed to maintain offsets
 43981                                  
 43982                                  		; DOSDATA:03B2h (MSDOS 6.21)
 43983                                  USERNUM:
 43984 000003B2 0000                     		dw 0		; 24 bit user number
 43985 000003B4 00                      		db 0
 43986                                  ;IF IBM
 43987                                  ;IF IBMCOPYRIGHT
 43988                                  ;OEMNUM:	DB 0		; 8 bit OEM number
 43989                                  ;ELSE
 43990                                  ;OEMNUM:	DB 0FFh		; 8 bit OEM number
 43991                                  ;ENDIF
 43992                                  ;ELSE
 43993 000003B5 FF                      OEMNUM:		DB 0FFh
 43994                                  ;ENDIF
 43995                                  
 43996                                  ;============================================================================
 43997                                  ; MS_DATA.ASM (MSDOS 6.0, 1991)
 43998                                  ;============================================================================
 43999                                  ; 25/04/2019 - Retro DOS 4.0
 44000                                  
 44001                                  ; Retro DOS v4.0 NOTE: (by Erdogan Tan, 25/04/2019)
 44002                                  ; ----------------------------------------------------------
 44003                                  ; This data section which was named as uninitialized data
 44004                                  ; (as overlayed by initialization code) but follows 
 44005                                  ; initialized data section from DOSDATA:03B6h address
 44006                                  ; (in otherwords, the method is different than MSDOS 3.3,
 44007                                  ; and there is not overlaying..)
 44008                                  ; **********************************************************
 44009                                  ; Reference: MSDOS 6.21 kernel DOSDATA section (4970 bytes)
 44010                                  ; follows DOSCODE section in the kernel file (MSDOS.SYS) 
 44011                                  ; (it is located at offset 0BF70h, file offset 0BF70h-3DE0h) 
 44012                                  ; but starts from offset 0 (ORG 0) and ends at offset 1370h.
 44013                                  ; TIMEBUF is at offset 03B6h.
 44014                                  ; **********************************************************	
 44015                                  
 44016                                  ;Break <Uninitialized data overlayed by initialization code>
 44017                                  ;----------------------------------------------------------------------------
 44018                                  ;DOSDATA    SEGMENT WORD PUBLIC 'DATA'
 44019                                  ; Init code overlaps with data area below
 44020                                  
 44021                                  ; 	ORG     0
 44022                                  
 44023                                  MSDAT001S:	; label byte
 44024                                  
 44025                                  ; DOSDATA:03B6h	; MSDOS 6.21 (MSDOS.SYS, file offset 0BF70h-3DE0h+3B6h)
 44026                                  TIMEBUF: ;	times 6 db 0
 44027 000003B6 0000<rep 3h>            	times 3 dw	0		; Time read from clock device
 44028 000003BC 0000                    DEVIOBUF:	dw	0		; Buffer for I/O under file assignment
 44029                                  
 44030                                  ; The following areas are used as temp buffer in EXEC system call
 44031                                  
 44032                                  ; DOSDATA:03BEh
 44033                                  OPENBUF: ;times 64  dw	0
 44034 000003BE 00<rep 80h>             	times	128 db	0		; buffer for name operations
 44035                                  RENBUF:	
 44036 0000043E 00<rep 80h>             	times	128 db	0		; buffer for rename destination
 44037                                  
 44038                                  ; Buffer for search calls
 44039                                  SEARCHBUF:	
 44040 000004BE 00<rep 35h>             	times	53  db	0		; internal search buffer
 44041                                  DUMMYCDS:  ;times 88 db 0
 44042 000004F3 00<rep 58h>             	times	curdirLen db 0
 44043                                  
 44044                                  ; End of contiguous buffer
 44045                                   
 44046                                  ; Temporary directory entry for use by many routines. Device directory
 44047                                  ; entries (bogus) are built here.
 44048                                  
 44049                                  ; DOSDATA:054Bh
 44050                                  
 44051                                  DEVFCB:	; LABEL   BYTE			; Uses NAME1, NAME2, combined
 44052                                  
 44053                                  ; WARNING..  do not alter position of NAME1 relative to DEVFCB
 44054                                  ; without first examining BUILD_DEVICE_ENT. Look carefully at DOS_RENAME
 44055                                  ; as well as it is the only guy who uses NAME2 and DESTSTART.
 44056                                  
 44057                                  NAME1:	
 44058 0000054B 00<rep Ch>                      times 	12 db	0		; File name buffer
 44059                                  NAME2:
 44060 00000557 00<rep Dh>              	times	13 db	0 		;
 44061                                  DESTSTART:
 44062 00000564 0000                    	dw	0			;
 44063                                          ;DB      ((SIZE DIR_ENTRY) - ($ - DEVFCB)) DUP (?)
 44064                                  	;times	5  db	0
 44065 00000566 00<rep 5h>              	times	((dir_entry.size)-($-DEVFCB)) db 0
 44066                                  
 44067                                  ; End Temporary directory entry.
 44068                                  
 44069 0000056B 00                      ATTRIB:	db	0		; storage for file attributes
 44070                                  EXTFCB:	
 44071 0000056C 00                      	db	0		; TRUE => extended FCB in use
 44072                                  SATTRIB:
 44073 0000056D 00                      	db	0		; Storage for search attributes
 44074                                  OPEN_ACCESS:
 44075 0000056E 00                      	db	0		; access of open system call
 44076                                  FOUNDDEL:
 44077 0000056F 00                      	db	0		; true => file was deleted
 44078                                  FOUND_DEV:
 44079 00000570 00                      	db	0		; true => search found a device
 44080                                  FSPLICE:
 44081 00000571 00                      	db	0		; true => do a splice in transpath
 44082                                  FSHARING:
 44083 00000572 00                      	db	0		; TRUE => no redirection
 44084                                  SECCLUSPOS:
 44085 00000573 00                      	db	0		; Position of first sector within cluster
 44086 00000574 00                      TRANS:	db	0		;
 44087 00000575 00                      READOP:	db	0		;
 44088                                  THISDRV:
 44089 00000576 00                      	db	0		;
 44090                                  CLUSFAC:
 44091 00000577 00                      	db	0		;
 44092                                  CLUSSPLIT:
 44093 00000578 00                      	db	0		;
 44094                                  INSMODE:
 44095 00000579 00                      	db	0		; true => insert mode in buffered read
 44096 0000057A 00                      CMETA:	db	0		; count of meta'ed components found
 44097 0000057B 00                      VOLID:	db	0		;
 44098                                  EXIT_TYPE:
 44099 0000057C 00                      	db	0		; type of exit...
 44100                                   
 44101                                  	;EVEN
 44102                                  
 44103 0000057D 90                      align 2
 44104                                  
 44105                                  ; DOSDATA:057Eh
 44106                                  
 44107                                  ; WARNING - the following two items are accessed as a word
 44108                                  
 44109                                  CREATING:
 44110 0000057E 00                      	db	0		; true => creating a file
 44111 0000057F 00                      DELALL:	db	0		; = 0 iff BUGBUG
 44112                                  				; = DIRFREE iff BUGBUG
 44113                                  EXITHOLD:
 44114 00000580 00000000                	dd	0		; Temp location for proc terminate
 44115                                  USER_SP:
 44116 00000584 0000                    	dw	0		; User SP for system call
 44117                                  USER_SS:
 44118 00000586 0000                    	dw	0		; User SS for system call
 44119                                  CONTSTK:
 44120 00000588 0000                    	dw	0		;
 44121                                  THISDPB:
 44122 0000058A 00000000                	dd	0		;
 44123                                  CLUSSAVE:
 44124 0000058E 0000                    	dw	0		;
 44125                                  CLUSSEC:
 44126 00000590 00000000                	dd	0		;>32mb			AC0000
 44127                                  PREREAD:
 44128 00000594 0000                    	dw	0		; 0 means preread; 1 means optional
 44129 00000596 0000                    FATBYT:	dw	0		; Used by ALLOCATE
 44130                                  FATBYTE:
 44131 00000598 0000                    	dw	0		; Used by $SLEAZEFUNC
 44132                                  ; DOSDATA:059Ah
 44133 0000059A 00000000                DEVPT:	dd	0		;
 44134                                  THISSFT:
 44135 0000059E 00000000                	dd	0		; Address of user SFT
 44136                                  THISCDS:
 44137 000005A2 00000000                	dd	0		; Address of current CDS
 44138                                  THISFCB:
 44139 000005A6 00000000                	dd	0		; Address of user FCB
 44140 000005AA FFFF                    SFN:	dw	-1		; SystemFileNumber found for accessfile
 44141 000005AC 0000                    JFN:	dw	0		; JobFileNumber found for accessfile
 44142 000005AE 00000000                PJFN:	dd	0		; PointerJobFileNumber found for accessfile
 44143                                  WFP_START:
 44144 000005B2 0000                    	dw	0		;
 44145                                  REN_WFP:
 44146 000005B4 0000                    	dw	0		;
 44147                                  CURR_DIR_END:
 44148 000005B6 0000                    	dw	0		;
 44149                                  NEXTADD:
 44150 000005B8 0000                    	dw	0		;
 44151                                  LASTPOS:
 44152 000005BA 0000                    	dw	0		;
 44153                                  CLUSNUM:
 44154 000005BC 0000                    	dw	0		;
 44155 000005BE 00000000                DIRSEC:	dd	0		;>32mb			AC0000
 44156                                  DIRSTART:
 44157 000005C2 0000                    	dw	0		;
 44158 000005C4 00000000                SECPOS:	dd	0		;>32mb Position of first sector accessed
 44159 000005C8 00000000                VALSEC:	dd	0		;>32mb Number of valid (previously written)
 44160                                                                  ; sectors
 44161                                  BYTSECPOS:
 44162 000005CC 0000                    	dw	0		; Position of first byte within sector
 44163                                  BYTPOS: ;times	4 db 0		; Byte position in file of access
 44164 000005CE 0000<rep 2h>                    times	2 dw 0
 44165                                  BYTCNT1:
 44166 000005D2 0000                    	dw	0		; No. of bytes in first sector
 44167                                  BYTCNT2:
 44168 000005D4 0000                    	dw	0		; No. of bytes in last sector
 44169 000005D6 0000                    SECCNT:	dw	0		; No. of whole sectors
 44170                                  ; DOSDATA:05D8h
 44171                                  ENTFREE:
 44172 000005D8 0000                    	dw	0		;
 44173                                  ENTLAST:
 44174 000005DA 0000                    	dw	0		;
 44175                                  NXTCLUSNUM:
 44176 000005DC 0000                    	dw	0		;
 44177                                  GROWCNT:
 44178 000005DE 00000000                	dd	0		;
 44179 000005E2 00000000                CURBUF:	dd	0		;
 44180 000005E6 00000000                CONSFT:	dd	0		; SFT of console swapped guy.
 44181 000005EA 0000                    SAVEBX:	dw	0		;
 44182 000005EC 0000                    SAVEDS:	dw	0		;
 44183                                  RESTORE_TMP:
 44184 000005EE 0000                    	dw	0		; return address for restore world
 44185 000005F0 0000                    NSS:	dw	0
 44186 000005F2 0000                    NSP:	dw	0
 44187                                  ; DOSDATA:05F4h
 44188                                  EXTOPEN_FLAG:
 44189 000005F4 0000                    	dw	0		;FT. extended open input flag	;AN000;
 44190                                  EXTOPEN_ON:
 44191 000005F6 00                      	db	0		;FT. extended open conditional flag ;AN000;
 44192                                  EXTOPEN_IO_MODE:
 44193 000005F7 0000                    	dw	0		;FT. extended open io mode	;AN000;
 44194                                  SAVE_DI:
 44195 000005F9 0000                    	dw	0		;FT. extended open saved DI	;AN000;
 44196                                  SAVE_ES:
 44197 000005FB 0000                    	dw	0		;FT. extended open saved ES	;AN000;
 44198                                  SAVE_DX:
 44199 000005FD 0000                    	dw	0		;FT. extended open saved DX	;AN000;
 44200                                  SAVE_CX:
 44201 000005FF 0000                    	dw	0		;FT. extended open saved CX	;AN000;
 44202                                  SAVE_BX:
 44203 00000601 0000                    	dw	0		;FT. extended open saved BX	;AN000;
 44204                                  SAVE_SI:
 44205 00000603 0000                    	dw	0		;FT. extended open saved SI	;AN000;
 44206                                  SAVE_DS:
 44207 00000605 0000                    	dw	0		;FT. extended open saved DS	;AN000;
 44208                                  
 44209                                  ; DOSDATA:0607h
 44210                                  
 44211                                  ; HIGH_SECTOR is a hack to allow passing 32-bit sector numbers where
 44212                                  ; we used to just pass 16 bits in a register. Now High_SECTOR holds
 44213                                  ; the high 16, the low 16 are still in the register.
 44214                                  
 44215                                  HIGH_SECTOR:	
 44216 00000607 0000                    	dw	0		;>32mb higher sector #		;AN000;
 44217                                  	; 25/09/2023
 44218                                  OffsetMagicPatch:
 44219                                  	;dw	MagicPatch	;scottq 8/6/92
 44220                                  	; 06/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 44221 00000609 0000                    	dw	0
 44222                                  				;see dos\mpatch.asm
 44223                                  DISK_FULL:
 44224 0000060B 00                      	db	0		;>32mb indicating disk full when 1 ;AN000;
 44225                                  TEMP_VAR:
 44226 0000060C 0000                    	dw	0		; temporary variable for everyone ;AN000;
 44227                                  TEMP_VAR2:
 44228 0000060E 0000                    	dw	0		; temporary variable 2 for everyone ;AN000;
 44229 00000610 00                      DrvErr:	db	0		; used to save drive error	;AN000;
 44230                                  DOS34_FLAG:
 44231 00000611 0000                    	dw	0		; common flag for DOS 3.4	;AN000;
 44232                                  NO_FILTER_PATH:
 44233 00000613 00000000                	dd	0		; pointer to original path	;AN000;
 44234                                  NO_FILTER_DPATH:
 44235 00000617 00000000                	dd	0		; pointer to original path of destination ;AN000;
 44236                                  ; M008
 44237                                  AbsRdWr_SS:
 44238 0000061B 0000                    	dw	0		; INT 25/26 user stack segment
 44239                                  AbsRdWr_SP:
 44240 0000061D 0000                    	dw	0		; INT 25/26 user stack offset
 44241                                  
 44242                                  	; I_am   UU_Callback_flag,BYTE,<0>  ; Unused
 44243                                  ; M008
 44244                                   
 44245                                   
 44246                                  ; make those pushes fast!!!
 44247                                  
 44248                                  ;EVEN
 44249                                  
 44250 0000061F 90                      align 2
 44251                                  
 44252                                  StackSize   equ 180h  ; 384	; gross but effective
 44253                                  
 44254                                  ;StackSize  equ 300h  ;	768	; This is a "trial" change IBM hasn't
 44255                                  ;				; made up their minds about
 44256                                   
 44257                                  ; WARNING!!!! DskStack may grow into AUXSTACK due to interrupt service.
 44258                                  ; This is NO problem as long as AUXSTACK comes immediately before DSKSTACK
 44259                                  
 44260                                  RENAMEDMA:	; LABEL   BYTE	; See DOS_RENAME
 44261                                   
 44262 00000620 00<rep 180h>                    times	StackSize db	0	;
 44263                                  AUXSTACK:			; LABEL   BYTE
 44264                                   
 44265 000007A0 00<rep 180h>                    times	StackSize db 	0	;
 44266                                  DSKSTACK:			; LABEL   BYTE
 44267                                   
 44268 00000920 00<rep 180h>                    times	StackSize db	0	;
 44269                                  IOSTACK:			; LABEL   BYTE
 44270                                  
 44271                                  ; DOSDATA:0AA0h 
 44272                                   
 44273                                  ; patch space for Boca folks.
 44274                                  ; Say What????!!! This does NOT go into the swappable area!
 44275                                  ; NOTE: We include the decl of ibmpatch in ms-dos even though it is not needed.
 44276                                  ;       This allows the REDIRector to work on either IBM or MS-DOS.
 44277                                   
 44278                                  IBMPATCH: ; label byte
 44279                                  PRINTER_FLAG:
 44280 00000AA0 00                      	db	0		; [SYSTEM] status of PRINT utility
 44281                                  VOLCHNG_FLAG:
 44282 00000AA1 00                      	db	0		; [SYSTEM] true if volume label created
 44283                                  VIRTUAL_OPEN:
 44284 00000AA2 00                      	db	0		; [SYSTEM] non-zero if we opened a virtual file
 44285                                   
 44286                                  ; Following 4 variables moved to MSDATA.asm from MSTABLE.asm (P4986)
 44287                                  
 44288                                  FSeek_drive:
 44289 00000AA3 00                      	db	0		;AN000; fastseek drive #
 44290                                  FSeek_firclus:
 44291 00000AA4 0000                    	dw	0		;AN000; fastseek first cluster #
 44292                                  FSeek_logclus:
 44293 00000AA6 0000                    	dw	0		;AN000; fastseek logical cluster #
 44294                                  FSeek_logsave:
 44295 00000AA8 0000                    	dw	0		;AN000; fastseek returned log clus #
 44296                                  
 44297                                  ; DOSDATA:0AAAh
 44298                                  
 44299                                  TEMP_DOSLOC:
 44300 00000AAA FFFF                    	dw	-1		;stores the temporary location of dos
 44301                                  				;at SYSINIT time.
 44302                                  SWAP_END:  ; LABEL   BYTE
 44303                                   
 44304                                  ; THE FOLLOWING BYTE MUST BE HERE, IMMEDIATELY FOLLOWING SWAP_END. IT CANNOT
 44305                                  ; BE USED. If the size of the swap data area is ODD, it will be rounded up
 44306                                  ; to include this byte.
 44307                                   
 44308 00000AAC 00                      	db	0
 44309                                  
 44310                                  ; DOSDATA:0AADh
 44311                                   
 44312                                  ;hkn;	DB	(512+80+32-(SWAP_END-ibmpatch)) DUP (?)
 44313                                  
 44314                                  ;DOSDATA    ENDS
 44315                                  
 44316                                  ;============================================================================
 44317                                  ; DOSTAB.ASM (MSDOS 6.0, 1991)
 44318                                  ;============================================================================
 44319                                  ; 27/04/2019 - Retro DOS 4.0
 44320                                  ; 16/07/2018 - Retro DOS 3.0
 44321                                  
 44322                                  ;DOSDATA Segment
 44323                                  
 44324                                  ; DOSDATA:0AADh (MSDOS 6.21, MSDOS.SYS)
 44325                                  
 44326                                  ;
 44327                                  ; upper case table
 44328                                  ; ---------------------------------------------------------------------------
 44329                                  UCASE_TAB:	; label   byte
 44330 00000AAD 8000                    	dw	128
 44331 00000AAF 809A45418E418F80        	db	128,154,069,065,142,065,143,128 
 44332 00000AB7 4545454949498E8F        	db	069,069,069,073,073,073,142,143
 44333 00000ABF 9092924F994F5555        	db	144,146,146,079,153,079,085,085
 44334 00000AC7 59999A9B9C9D9E9F        	db	089,153,154,155,156,157,158,159
 44335 00000ACF 41494F55A5A5A6A7        	db	065,073,079,085,165,165,166,167
 44336 00000AD7 A8A9AAABACADAEAF        	db	168,169,170,171,172,173,174,175
 44337 00000ADF B0B1B2B3B4B5B6B7        	db	176,177,178,179,180,181,182,183
 44338 00000AE7 B8B9BABBBCBDBEBF        	db	184,185,186,187,188,189,190,191
 44339 00000AEF C0C1C2C3C4C5C6C7        	db	192,193,194,195,196,197,198,199
 44340 00000AF7 C8C9CACBCCCDCECF        	db	200,201,202,203,204,205,206,207
 44341 00000AFF D0D1D2D3D4D5D6D7        	db	208,209,210,211,212,213,214,215
 44342 00000B07 D8D9DADBDCDDDEDF        	db	216,217,218,219,220,221,222,223
 44343 00000B0F E0E1E2E3E4E5E6E7        	db	224,225,226,227,228,229,230,231
 44344 00000B17 E8E9EAEBECEDEEEF        	db	232,233,234,235,236,237,238,239
 44345 00000B1F F0F1F2F3F4F5F6F7        	db	240,241,242,243,244,245,246,247
 44346 00000B27 F8F9FAFBFCFDFEFF        	db	248,249,250,251,252,253,254,255
 44347                                  ;
 44348                                  ; file upper case table
 44349                                  ; ---------------------------------------------------------------------------
 44350                                  FILE_UCASE_TAB:	; label  byte
 44351 00000B2F 8000                    	dw	128
 44352 00000B31 809A45418E418F80        	db	128,154,069,065,142,065,143,128
 44353 00000B39 4545454949498E8F        	db	069,069,069,073,073,073,142,143
 44354 00000B41 9092924F994F5555        	db	144,146,146,079,153,079,085,085
 44355 00000B49 59999A9B9C9D9E9F        	db	089,153,154,155,156,157,158,159
 44356 00000B51 41494F55A5A5A6A7        	db	065,073,079,085,165,165,166,167
 44357 00000B59 A8A9AAABACADAEAF        	db	168,169,170,171,172,173,174,175
 44358 00000B61 B0B1B2B3B4B5B6B7        	db	176,177,178,179,180,181,182,183
 44359 00000B69 B8B9BABBBCBDBEBF        	db	184,185,186,187,188,189,190,191
 44360 00000B71 C0C1C2C3C4C5C6C7        	db	192,193,194,195,196,197,198,199
 44361 00000B79 C8C9CACBCCCDCECF        	db	200,201,202,203,204,205,206,207
 44362 00000B81 D0D1D2D3D4D5D6D7        	db	208,209,210,211,212,213,214,215
 44363 00000B89 D8D9DADBDCDDDEDF        	db	216,217,218,219,220,221,222,223
 44364 00000B91 E0E1E2E3E4E5E6E7        	db	224,225,226,227,228,229,230,231
 44365 00000B99 E8E9EAEBECEDEEEF        	db	232,233,234,235,236,237,238,239
 44366 00000BA1 F0F1F2F3F4F5F6F7        	db	240,241,242,243,244,245,246,247
 44367 00000BA9 F8F9FAFBFCFDFEFF        	db	248,249,250,251,252,253,254,255
 44368                                  ;
 44369                                  ; file char list
 44370                                  ; ---------------------------------------------------------------------------
 44371                                  FILE_CHAR_TAB:	; label  byte
 44372 00000BB1 1600                    	dw	22				; length
 44373 00000BB3 0100FF                  	db	1,0,255 			; include all
 44374 00000BB6 000020                  	db	0,0,20h 			; exclude 0 - 20h
 44375 00000BB9 020E2E222F5C5B5D3A-     	db	2,14,'."/\[]:|<>+=;,'           ; exclude 14 special
 44375 00000BC2 7C3C3E2B3D3B2C     
 44376                                  	;db	24 dup (?)			; reserved
 44377 00000BC9 00<rep 18h>             	times	24 db 0
 44378                                  
 44379                                  ;
 44380                                  ; collate table
 44381                                  ; ---------------------------------------------------------------------------
 44382                                  COLLATE_TAB:	; label   byte
 44383 00000BE1 0001                    	dw	256
 44384 00000BE3 0001020304050607        	db	0,1,2,3,4,5,6,7
 44385 00000BEB 08090A0B0C0D0E0F        	db	8,9,10,11,12,13,14,15
 44386 00000BF3 1011121314151617        	db	16,17,18,19,20,21,22,23
 44387 00000BFB 18191A1B1C1D1E1F        	db	24,25,26,27,28,29,30,31
 44388 00000C03 2021222324252627        	db	" ","!",'"',"#","$","%","&","'"
 44389 00000C0B 28292A2B2C2D2E2F        	db	"(",")","*","+",",","-",".","/"
 44390 00000C13 3031323334353637        	db	"0","1","2","3","4","5","6","7"
 44391 00000C1B 38393A3B3C3D3E3F        	db	"8","9",":",";","<","=",">","?"
 44392 00000C23 4041424344454647        	db	"@","A","B","C","D","E","F","G"
 44393 00000C2B 48494A4B4C4D4E4F        	db	"H","I","J","K","L","M","N","O"
 44394 00000C33 5051525354555657        	db	"P","Q","R","S","T","U","V","W"
 44395 00000C3B 58595A5B5C5D5E5F        	db	"X","Y","Z","[","\","]","^","_"
 44396 00000C43 6041424344454647        	db	"`","A","B","C","D","E","F","G"
 44397 00000C4B 48494A4B4C4D4E4F        	db	"H","I","J","K","L","M","N","O"
 44398 00000C53 5051525354555657        	db	"P","Q","R","S","T","U","V","W"
 44399 00000C5B 58595A7B7C7D7E7F        	db	"X","Y","Z","{","|","}","~",127
 44400 00000C63 4355454141414143        	db	"C","U","E","A","A","A","A","C"
 44401 00000C6B 4545454949494141        	db	"E","E","E","I","I","I","A","A"
 44402 00000C73 4541414F4F4F5555        	db	"E","A","A","O","O","O","U","U"
 44403 00000C7B 594F552424242424        	db	"Y","O","U","$","$","$","$","$"
 44404 00000C83 41494F554E4EA6A7        	db	"A","I","O","U","N","N",166,167
 44405 00000C8B 3FA9AAABAC212222        	db	"?",169,170,171,172,"!",'"','"'
 44406 00000C93 B0B1B2B3B4B5B6B7        	db	176,177,178,179,180,181,182,183
 44407 00000C9B B8B9BABBBCBDBEBF        	db	184,185,186,187,188,189,190,191
 44408 00000CA3 C0C1C2C3C4C5C6C7        	db	192,193,194,195,196,197,198,199
 44409 00000CAB C8C9CACBCCCDCECF        	db	200,201,202,203,204,205,206,207
 44410 00000CB3 D0D1D2D3D4D5D6D7        	db	208,209,210,211,212,213,214,215
 44411 00000CBB D8D9DADBDCDDDEDF        	db	216,217,218,219,220,221,222,223
 44412 00000CC3 E053                    	db	224,"S"
 44413 00000CC5 E2E3E4E5E6E7            	db	226,227,228,229,230,231
 44414 00000CCB E8E9EAEBECEDEEEF        	db	232,233,234,235,236,237,238,239
 44415 00000CD3 F0F1F2F3F4F5F6F7        	db	240,241,242,243,244,245,246,247
 44416 00000CDB F8F9FAFBFCFDFEFF        	db	248,249,250,251,252,253,254,255
 44417                                  
 44418                                  ; ------------------------------------------------<MSKK01>----------------------
 44419                                  
 44420                                  ; DOSDATA:0CE3h
 44421                                  
 44422                                  ; 29/04/2019
 44423                                  
 44424                                  ; dbcs is not supported in DOS 3.3
 44425                                  ;		   DBCS_TAB	    CC_DBCS <>
 44426                                  ;
 44427                                  ; DBCS for DOS 4.00			   2/12/KK
 44428                                  
 44429                                  DBCS_TAB:	; label byte		;AN000;  2/12/KK
 44430                                  ; ------------------------------------------------<MSKK01>----------------------
 44431                                  ;ifdef	DBCS
 44432                                  ; ifdef	  JAPAN
 44433                                  ;		dw	6		; <MSKK01>
 44434                                  ;		db	081h,09fh	; <MSKK01>
 44435                                  ;		db	0e0h,0fch	; <MSKK01>
 44436                                  ;		db	0,0		; <MSKK01>
 44437                                  ;
 44438                                  ;		db	0,0,0,0,0,0,0,0,0,0	; <MSKK01>
 44439                                  ; endif
 44440                                  ; ifdef	  TAIWAN
 44441                                  ;		dw	4		; <TAIWAN>
 44442                                  ;		db	081h,0FEh	; <TAIWAN>
 44443                                  ;		db	0,0		; <TAIWAN>
 44444                                  ;
 44445                                  ;		db	0,0,0,0,0,0,0,0,0,0,0,0
 44446                                  ; endif
 44447                                  ; ifdef   KOREA                         ; Keyl
 44448                                  ;               dw      4               ; <KOREA>
 44449                                  ;               db      0A1h,0FEh       ; <KOREA>
 44450                                  ;               db      0,0             ; <KOREA>
 44451                                  ;
 44452                                  ;		db	0,0,0,0,0,0,0,0,0,0,0,0
 44453                                  ;  endif
 44454                                  ;else
 44455 00000CE3 0000                    		dw	0		;AN000;  2/12/KK      max number
 44456                                  		;db	16 dup(0)	;AN000;  2/12/KK
 44457 00000CE5 00<rep 10h>             		times	16 db 0
 44458                                  
 44459                                  ;		dw	6		;  2/12/KK
 44460                                  ;		db	081h,09Fh	;  2/12/KK
 44461                                  ;		db	0E0h,0FCh	;  2/12/KK
 44462                                  ;		db	0,0		;  2/12/KK
 44463                                  ;
 44464                                  ;endif
 44465                                  ; ------------------------------------------------<MSKK01>----------------------
 44466                                  
 44467                                  ; DOSDATA:0CF5h
 44468                                  
 44469                                  ; ---------------------------------------------------------------------------
 44470                                  ;
 44471                                  ;CASE MAPPER ROUTINE FOR 80H-FFH character range, DOS 3.3
 44472                                  ;     ENTRY: AL = Character to map
 44473                                  ;     EXIT:  AL = The converted character
 44474                                  ; Alters no registers except AL and flags.
 44475                                  ; The routine should do nothing to chars below 80H.
 44476                                  ; ---------------------------------------------------------------------------
 44477                                  ; Example:
 44478                                  
 44479                                  MAP_CASE:
 44480                                  ;Procedure MAP_CASE,FAR
 44481                                  
 44482 00000CF5 3C80                    	CMP	AL,80h
 44483 00000CF7 7301                    	JAE	short Map1	;Map no chars below 80H ever
 44484 00000CF9 CB                      	RETF
 44485                                  Map1:
 44486 00000CFA 2C80                    	SUB	AL,80h		;Turn into index value
 44487 00000CFC 1E                      	PUSH	DS
 44488 00000CFD 53                      	PUSH	BX
 44489 00000CFE BB[AF0A]                	MOV	BX,UCASE_TAB+2
 44490                                  FINISH:
 44491 00000D01 0E                      	PUSH	CS		;Move to DS
 44492 00000D02 1F                      	POP	DS
 44493 00000D03 D7                      	XLAT			;Get upper case character
 44494 00000D04 5B                      	POP	BX
 44495 00000D05 1F                      	POP	DS
 44496                                  L_RET:	
 44497 00000D06 CB                      	RETF
 44498                                  
 44499                                  ;EndProc MAP_CASE
 44500                                  
 44501                                  ; ---------------------------------------------------------------------------
 44502                                  
 44503                                  ; The variables for ECS version are moved here for the same data alignments
 44504                                  ; as IBM-DOS and MS-DOS.
 44505                                  
 44506                                  InterChar:
 44507 00000D07 00                      	db	0	; Interim character flag ( 1= interim)  ;AN000;
 44508                                  ;------- NOTE: NEXT TWO BYTES SOMETIMES USED AS A WORD !! -------------------
 44509                                  DUMMY:	; LABEL   WORD
 44510                                  InterCon:  
 44511 00000D08 00                      	db	0	; Console in Interim mode ( 1= interim) ;AN000;
 44512                                  SaveCurFlg:
 44513 00000D09 00                      	db	0	; Print, do not advance cursor flag     ;AN000;
 44514                                  
 44515                                  ; ---------------------------------------------------------------------------
 44516                                  
 44517 00000D0A 0000                    TEMPSEG:  dw	0	;hkn; used to store ds.
 44518                                  redir_patch:
 44519 00000D0C 00                      	  db	0
 44520                                  
 44521                                  ; DOSDATA:0D0Dh
 44522                                  
 44523                                  Mark1:	; label byte
 44524                                  
 44525                                  ;IF2
 44526                                  ;	IF ((OFFSET MARK1) GT (OFFSET MSVERSION) )
 44527                                  ;		%OUT !DATA CORRUPTION!MARK1 OFFSET TOO BIG. RE-ORGANIZE DATA.
 44528                                  ;	ENDIF
 44529                                  ;ENDIF
 44530                                  
 44531 00000D0D 00<rep 5h>              	  times 5 db 0
 44532                                  
 44533                                  ;############################################################################
 44534                                  ;
 44535                                  ; ** HACK FOR DOS 4.0 REDIR **
 44536                                  ; 
 44537                                  ; The redir requires the following:
 44538                                  ;
 44539                                  ;	MSVERS	offset D12H
 44540                                  ;	YRTAB	offset D14H
 44541                                  ; 	MONTAB	offset D1CH
 44542                                  ;
 44543                                  ; WARNING! WARNING!
 44544                                  ; 
 44545                                  ; MARK1 SHOULD NOT BE >= 0D12H. IF SOME VARIABLE IS TO BE ADDED ABOVE DO SO
 44546                                  ; WITHOUT VIOLATING THIS AND UPDATE THE FOLL. LINE
 44547                                  ;
 44548                                  ; CURRENTLY MARK1 = 0D0DH
 44549                                  ;
 44550                                  ;############################################################################
 44551                                  
 44552                                  	;ORG	0D12h
 44553                                  
 44554                                  ; DOSDATA:0D12h (MSDOS 6.21, MSDOS.SYS)
 44555                                  
 44556                                  	;db	6
 44557                                  	;db	20
 44558                                  
 44559                                  	; Offset 0C78h in IBMDOS.COM (MSDOS 3.3, 1987)
 44560                                  MSVERSION:				; MS-DOS version in hex for $GET_VERSION
 44561 00000D12 06                      MSMAJORV: DB	MAJOR_VERSION	; DOS_MAJOR_VERSION
 44562 00000D13 16                      MSMINORV: DB	MINOR_VERSION	; DOS_MINOR_VERSION  
 44563                                  
 44564                                  ; YRTAB & MONTAB moved from TABLE segment in ms_table.asm
 44565                                  ;
 44566                                  ;	I_am    YRTAB,8,<200,166,200,165,200,165,200,165>   
 44567                                  ;	I_am    MONTAB,12,<31,28,31,30,31,30,31,31,30,31,30,31> 
 44568                                  
 44569                                  ; Days in year
 44570                                  
 44571                                  YRTAB:   
 44572 00000D14 C8A6                    	DB	200,166			; Leap year
 44573 00000D16 C8A5                    	DB	200,165
 44574 00000D18 C8A5                    	DB	200,165
 44575 00000D1A C8A5                    	DB	200,165
 44576                                  
 44577                                  ; Days of each month
 44578                                  
 44579                                  MONTAB:        
 44580 00000D1C 1F                      	DB      31                      ; January
 44581                                  february:
 44582 00000D1D 1C                      	DB	28 			; February--reset each 
 44583                                  					; time year changes
 44584 00000D1E 1F                              DB      31                      ; March
 44585 00000D1F 1E                              DB      30                      ; April
 44586 00000D20 1F                              DB      31                      ; May
 44587 00000D21 1E                              DB      30                      ; June
 44588 00000D22 1F                              DB      31                      ; July
 44589 00000D23 1F                              DB      31                      ; August
 44590 00000D24 1E                              DB      30                      ; September
 44591 00000D25 1F                              DB      31                      ; October
 44592 00000D26 1E                              DB      30                      ; November
 44593 00000D27 1F                              DB      31                      ; December
 44594                                  
 44595                                  ;----------------THE FOLL. BLOCK MOVED FROM TABLE SEG IN MS_TABLE.ASM-------
 44596                                  
 44597                                  ; SYS init extended table,   DOS 3.3   F.C. 5/29/86
 44598                                  
 44599                                  SysInitTable:
 44600                                  	;dw	SYSINITVAR
 44601 00000D28 [2600]                  	dw	SYSINITVARS	; pointer to sysinit var
 44602 00000D2A 0000                            dw      0		; segment
 44603 00000D2C [0012]                          dw	COUNTRY_CDPG	; pointer to country tabl
 44604 00000D2E 0000                            dw      0		; segment of pointer
 44605                                  
 44606                                  ; DOS 3.3 F.C. 6/12/86
 44607                                  ; FASTOPEN communications area DOS 3.3   F.C. 5/29/86
 44608                                  
 44609                                  FastTable:				; a better name
 44610                                  FastOpenTable:
 44611 00000D30 0200                    	dw      2                       ; number of entries
 44612 00000D32 [EE12]                  	dw      FastRet			; pointer to ret instr.
 44613 00000D34 0000                    	dw      0                       ; and will be modified by
 44614 00000D36 [EE12]                  	dw      FastRet			; FASTxxx when loaded in
 44615 00000D38 0000                    	dw      0                       
 44616                                  
 44617                                  ; DOS 3.3 F.C. 6/12/86
 44618                                  
 44619                                  FastFlg:				; flags
 44620                                  FastOpenFlg:
 44621 00000D3A 00                      	db	0			; don't change the foll: order  
 44622                                  
 44623                                  ; FastOpen_Ext_Info is used as a temporary storage for saving dirpos,dirsec
 44624                                  ; and clusnum which are filled by DOS 3.nc when calling FastOpen Insert
 44625                                  ; or filled by FastOPen when calling FastOpen Lookup
 44626                                  
 44627                                  FastOpen_Ext_Info: ; label  byte	;dirpos
 44628                                  	;db	SIZE FASTOPEN_EXTENDED_INFO dup(0)
 44629                                  	;times	11 db 0
 44630 00000D3B 00<rep Bh>              	times	FEI.size db 0
 44631                                  
 44632                                  ; Dir_Info_Buff is a dir entry buffer which is filled by FastOPen
 44633                                  ; when calling FastOpen Lookup
 44634                                  
 44635                                  Dir_Info_Buff:	; label  byte
 44636                                  	;db   	SIZE dir_entry dup (0)
 44637                                  	;times	32 db 0
 44638 00000D46 00<rep 20h>             	times	dir_entry.size db 0
 44639                                  
 44640                                  Next_Element_Start:
 44641 00000D66 0000                    	dw	0			; save next element start offset
 44642                                  Del_ExtCluster:
 44643 00000D68 0000                    	dw	0			; for dos_delete                       
 44644                                  
 44645                                  ; The following is a stack and its pointer for interrupt 2F which is used
 44646                                  ; by NLSFUNC. There is no significant use of this stack, we are just trying
 44647                                  ; not to destroy the INT 21 stack saved for the user.
 44648                                  
 44649                                  USER_SP_2F:	; LABEL  WORD
 44650 00000D6A [6C0D]                  	dw    	FAKE_STACK_2F
 44651                                  
 44652                                  Packet_Temp:	; label  word		; temporary packet used by readtime
 44653                                  DOS_TEMP:	; label  word		; temporary word
 44654                                  FAKE_STACK_2F:  
 44655                                  	; dw  14 dup (0)		; 12 register temporary storage
 44656 00000D6C 0000<rep Eh>            	times 14 dw 0
 44657                                  
 44658                                  Hash_Temp: 	;label  word		; temporary word             
 44659                                  	;dw   4 dup (0)			; temporary hash table during config.sys
 44660 00000D88 0000<rep 4h>            	times 4 dw 0
 44661                                              	
 44662                                  SCAN_FLAG:	
 44663 00000D90 00                      	db     0			; flag to indicate key ALT_Q
 44664                                  DATE_FLAG:
 44665 00000D91 0000                    	dw     0                	; flag to update the date
 44666                                  
 44667                                  FETCHI_TAG:	; label  word		; OBSOLETE - no longer used
 44668 00000D93 0000                    	dw     0			; formerly part of IBM's piracy protection
 44669                                  
 44670                                  MSG_EXTERROR:	; label  DWORD   ; for system message addr                                                       
 44671 00000D95 00000000                	dd     0               		; for extended error                   
 44672 00000D99 00000000                	dd     0			; for parser                           
 44673 00000D9D 00000000                	dd     0			; for critical errror                  
 44674 00000DA1 00000000                	dd     0			; for IFS                              
 44675 00000DA5 00000000                	dd     0			; for code reduction                   
 44676                                  
 44677                                  SEQ_SECTOR:	; label  DWORD 		; last sector read                                                     
 44678 00000DA9 FFFFFFFF                	dd     -1                                                        
 44679                                  SC_SECTOR_SIZE:
 44680 00000DAD 0000                    	dw	0			; sector size for SC                 
 44681                                  SC_DRIVE:
 44682 00000DAF 00                      	db	0			; drive # for secondary cache        
 44683                                  CurSC_DRIVE:
 44684 00000DB0 FF                      	db	-1			; current SC drive                   
 44685                                  CurSC_SECTOR:
 44686 00000DB1 00000000                	dd	0			; current SC starting sector         
 44687                                  SC_STATUS:
 44688 00000DB5 0000                    	dw	0			; SC status word                     
 44689                                  SC_FLAG:
 44690 00000DB7 00                      	db	0			; SC flag                            
 44691                                  AbsDskErr:
 44692 00000DB8 0000                    	dw	0			; Storage for Abs dsk read/write err
 44693                                                                                            
 44694                                  NO_NAME_ID:	; label byte                                                           
 44695 00000DBA 4E4F204E414D452020-     	db	'NO NAME    '		; null media id                      
 44695 00000DC3 2020               
 44696                                  
 44697                                  ;hkn; moved from TABLE segment in kstrin.asm
 44698                                  
 44699                                  KISTR001S:	; label	byte		; 2/17/KK
 44700 00000DC5 00                      LOOKSIZ: DB	0			; 0 if byte, NZ if word	2/17/KK
 44701                                  KISTR001E:	; label	byte		; 2/17/KK
 44702                                  
 44703                                  ; the nul device driver used to be part of the code. However, since the 
 44704                                  ; header is in the data, and the entry points are only given as an offset,
 44705                                  ; the strategy and interrupt entry points must also be in the data now.
 44706                                  
 44707                                  ; DOSDATA:0DC6h
 44708                                  
 44709                                  SNULDEV:
 44710                                  ;procedure snuldev,far
 44711                                  	;or	word [es:bx+3],100h
 44712                                  	; 17/12/2022
 44713                                  	;or	byte [es:bx+4],01h
 44714 00000DC6 26804F0401              	or	byte [es:bx+SRHEAD.REQSTAT+1],(STDON>>8)
 44715                                  INULDEV:
 44716 00000DCB CB                      	retf				; must not be a return!
 44717                                  ;endproc snuldev
 44718                                  
 44719                                  ;M044
 44720                                  ; Second part of save area for saving last para of Windows memory
 44721                                  
 44722                                  WinoldPatch2:
 44723                                  	;db	8 dup (?)	; M044
 44724 00000DCC 00<rep 8h>              	times	8 db 0	
 44725                                  UmbSave2:
 44726                                  	;db	5 dup (?)	; M062
 44727 00000DD4 00<rep 5h>              	times	5 db 0
 44728                                  UmbSaveFlag:
 44729 00000DD9 00                      	db	0		; M062
 44730                                  
 44731                                  ; DOSDATA:0DDBh
 44732                                  
 44733                                  Mark2:	; label byte
 44734                                  
 44735                                  ;IF2
 44736                                  ;	IF ((OFFSET MARK2) GT (OFFSET ERR_TABLE_21) )
 44737                                  ;		%OUT !DATA CORRUPTION!MARK2 OFFSET TOO BIG. RE-ORGANIZE DATA.
 44738                                  ;	ENDIF
 44739                                  ;ENDIF
 44740                                  
 44741                                  ;############################################################################
 44742                                  ;
 44743                                  ; ** HACK FOR DOS 4.0 REDIR **
 44744                                  ; 
 44745                                  ; The redir requires the following:
 44746                                  ;
 44747                                  ;	ERR_TABLE_21	offset DDBH
 44748                                  ;	ERR_TABLE_24	offset E5BH
 44749                                  ; 	ErrMap24	offset EABH
 44750                                  ;
 44751                                  ; WARNING! WARNING!
 44752                                  ;
 44753                                  ; MARK2 SHOULD NOT BE >= 0DDBH. IF SOME VARIABLE IS TO BE ADDED ABOVE DO SO
 44754                                  ; WITHOUT VIOLATING THIS AND UPDATE THE FOLL. LINE
 44755                                  ;
 44756                                  ; CURRENTLY MARK2 = 0DD0H
 44757                                  ;
 44758                                  ;############################################################################
 44759                                  
 44760                                  	;ORG	0DDBh
 44761                                  
 44762                                  ; DOSDATA:0DDBh (MSDOS 6.21, MSDOS.SYS)
 44763                                  
 44764                                  ; ---------------------------------------------------------------------------
 44765                                  ;
 44766                                  ; The following table defines CLASS ACTION and LOCUS info for the INT 21H
 44767                                  ; errors. Each entry is 4 bytes long:
 44768                                  ;
 44769                                  ;       Err#,Class,Action,Locus
 44770                                  ;
 44771                                  ; A value of 0FFh indicates a call specific value (ie. should already
 44772                                  ; be set). AN ERROR CODE NOT IN THE TABLE FALLS THROUGH TO THE CATCH ALL AT
 44773                                  ; THE END, IT IS ASSUMES THAT CLASS, ACTION, LOCUS IS ALREADY SET.
 44774                                  ;
 44775                                  ; ---------------------------------------------------------------------------
 44776                                  
 44777                                  ;ErrTab  Macro   err,class,action,locus
 44778                                  ;ifidn <locus>,<0FFh>
 44779                                  ;    DB  error_&err,errCLASS_&class,errACT_&action,0FFh
 44780                                  ;ELSE
 44781                                  ;    DB  error_&err,errCLASS_&class,errACT_&action,errLOC_&locus
 44782                                  ;ENDIF
 44783                                  ;ENDM
 44784                                  
 44785                                  ERR_TABLE_21: ; LABEL   BYTE
 44786 00000DDA 010704FF                    DB  error_invalid_function,       errCLASS_Apperr,    errACT_Abort,    0FFh
 44787 00000DDE 02080302                    DB  error_file_not_found,         errCLASS_NotFnd,    errACT_User,     errLOC_Disk
 44788 00000DE2 03080302                    DB  error_path_not_found,         errCLASS_NotFnd,    errACT_User,     errLOC_Disk
 44789 00000DE6 04010401                    DB  error_too_many_open_files,    errCLASS_OutRes,    errACT_Abort,    errLOC_Unk
 44790 00000DEA 050303FF                    DB  error_access_denied,          errCLASS_Auth,      errACT_User,     0FFh
 44791 00000DEE 06070401                    DB  error_invalid_handle,         errCLASS_Apperr,    errACT_Abort,    errLOC_Unk
 44792 00000DF2 07070505                    DB  error_arena_trashed,          errCLASS_Apperr,    errACT_Panic,    errLOC_Mem
 44793 00000DF6 08010405                    DB  error_not_enough_memory,      errCLASS_OutRes,    errACT_Abort,    errLOC_Mem
 44794 00000DFA 09070405                    DB  error_invalid_block,          errCLASS_Apperr,    errACT_Abort,    errLOC_Mem
 44795 00000DFE 0A070405                    DB  error_bad_environment,        errCLASS_Apperr,    errACT_Abort,    errLOC_Mem
 44796 00000E02 0B090301                    DB  error_bad_format,             errCLASS_BadFmt,    errACT_User,     errLOC_Unk
 44797 00000E06 0C070401                    DB  error_invalid_access,         errCLASS_Apperr,    errACT_Abort,    errLOC_Unk
 44798 00000E0A 0D090401                    DB  error_invalid_data,           errCLASS_BadFmt,    errACT_Abort,    errLOC_Unk
 44799 00000E0E 0F080302                    DB  error_invalid_drive,          errCLASS_NotFnd,    errACT_User,     errLOC_Disk
 44800 00000E12 10030302                    DB  error_current_directory,      errCLASS_Auth,      errACT_User,     errLOC_Disk
 44801 00000E16 110D0302                    DB  error_not_same_device,        errCLASS_Unk,       errACT_User,     errLOC_Disk
 44802 00000E1A 12080302                    DB  error_no_more_files,          errCLASS_NotFnd,    errACT_User,     errLOC_Disk
 44803 00000E1E 500C0302                    DB  error_file_exists,            errCLASS_Already,   errACT_User,     errLOC_Disk
 44804 00000E22 200A0202                    DB  error_sharing_violation,      errCLASS_Locked,    errACT_DlyRet,   errLOC_Disk
 44805 00000E26 210A0202                    DB  error_lock_violation,         errCLASS_Locked,    errACT_DlyRet,   errLOC_Disk
 44806 00000E2A 540104FF                    DB  error_out_of_structures,      errCLASS_OutRes,    errACT_Abort,    0FFh
 44807 00000E2E 56030301                    DB  error_invalid_password,       errCLASS_Auth,      errACT_User,     errLOC_Unk
 44808 00000E32 52010402                    DB  error_cannot_make,            errCLASS_OutRes,    errACT_Abort,    errLOC_Disk
 44809 00000E36 32090303                    DB  error_not_supported,          errCLASS_BadFmt,    errACT_User,     errLOC_Net
 44810 00000E3A 550C0303                    DB  error_already_assigned,       errCLASS_Already,   errACT_User,     errLOC_Net
 44811 00000E3E 57090301                    DB  error_invalid_parameter,      errCLASS_BadFmt,    errACT_User,     errLOC_Unk
 44812 00000E42 530D0401                    DB  error_FAIL_I24,               errCLASS_Unk,       errACT_Abort,    errLOC_Unk
 44813 00000E46 24010405                    DB  error_sharing_buffer_exceeded,errCLASS_OutRes,    errACT_Abort,    errLOC_Mem
 44814                                      ; MSDOS 6.0
 44815 00000E4A 26010401                    DB  error_handle_EOF,             errCLASS_OutRes,    errACT_Abort,    errLOC_Unk ;AN000;
 44816 00000E4E 27010401                    DB  error_handle_Disk_Full,       errCLASS_OutRes,    errACT_Abort,    errLOC_Unk ;AN000;
 44817 00000E52 5A0D0402                    DB  error_sys_comp_not_loaded,    errCLASS_Unk,       errACT_Abort,    errLOC_Disk ;AN001;
 44818 00000E56 FFFFFFFF                    DB  0FFh,                         0FFH,       	  0FFH,       	   0FFh
 44819                                  
 44820                                  ; MSDOS 3.3 (IBMDOS.COM, 1987) - Offset 0D2Ah
 44821                                  ;ERR_TABLE_21:	db 1,7,4,0FFh
 44822                                  ;		db 2,8,3,2
 44823                                  ;		db 3,8,3,2
 44824                                  ;		db 4,1,4,1
 44825                                  ;		db 5,3,3,0FFh
 44826                                  ;		db 6,7,4,1
 44827                                  ;		db 7,7,5,5
 44828                                  ;		db 8,1,4,5
 44829                                  ;		db 9,7,4,5
 44830                                  ;		db 0Ah,7,4,5
 44831                                  ;		db 0Bh,9,3,1
 44832                                  ;		db 0Ch,7,4,1
 44833                                  ;		db 0Dh,9,4,1
 44834                                  ;		db 0Fh,8,3,2
 44835                                  ;		db 10h,3,3,2
 44836                                  ;		db 11h,0Dh,3,2
 44837                                  ;		db 12h,8,3,2
 44838                                  ;		db 50h,0Ch,3,2
 44839                                  ;		db 20h,0Ah,2,2
 44840                                  ;		db 21h,0Ah,2,2
 44841                                  ;		db 54h,1,4,0FFh
 44842                                  ;		db 56h,3,3,1
 44843                                  ;		db 52h,1,4,2
 44844                                  ;		db 32h,9,3,3
 44845                                  ;		db 55h,0Ch,3,3
 44846                                  ;		db 57h,9,3,1
 44847                                  ;		db 53h,0Dh,4,1
 44848                                  ;		db 24h,1,4,5
 44849                                  ; MSDOS 6.0 (MSDOS 6.21)
 44850                                  ;		db 26h,1,4,1
 44851                                  ;		db 27h,1,4,1
 44852                                  ;		db 5Ah,0Dh,4,2
 44853                                  ; MSDOS 6.0 & MSDOS 3.3
 44854                                  ;		db 0FFh,0FFh,0FFh,0FFh
 44855                                  
 44856                                  ; DOSDATA:0E5Bh (MSDOS 6.21, MSDOS.SYS)
 44857                                  
 44858                                  ; ---------------------------------------------------------------------------
 44859                                  ;
 44860                                  ; The following table defines CLASS ACTION and LOCUS info for the INT 24H
 44861                                  ; errors. Each entry is 4 bytes long:
 44862                                  ;
 44863                                  ;       Err#,Class,Action,Locus
 44864                                  ;
 44865                                  ; A Locus value of 0FFh indicates a call specific value (ie. should already
 44866                                  ; be set). AN ERROR CODE NOT IN THE TABLE FALLS THROUGH TO THE CATCH ALL AT
 44867                                  ; THE END.
 44868                                  ;
 44869                                  ; ---------------------------------------------------------------------------
 44870                                  
 44871                                  ERR_TABLE_24: ; LABEL   BYTE
 44872 00000E5A 130B0702                    DB  error_write_protect,          errCLASS_Media,     errACT_IntRet,   errLOC_Disk
 44873 00000E5E 14040501                    DB  error_bad_unit,               errCLASS_Intrn,     errACT_Panic,    errLOC_Unk
 44874 00000E62 150507FF                    DB  error_not_ready,              errCLASS_HrdFail,   errACT_IntRet,   0FFh
 44875 00000E66 16040501                    DB  error_bad_command,            errCLASS_Intrn,     errACT_Panic,    errLOC_Unk
 44876 00000E6A 170B0402                    DB  error_CRC,                    errCLASS_Media,     errACT_Abort,    errLOC_Disk
 44877 00000E6E 18040501                    DB  error_bad_length,             errCLASS_Intrn,     errACT_Panic,    errLOC_Unk
 44878 00000E72 19050102                    DB  error_seek,                   errCLASS_HrdFail,   errACT_Retry,    errLOC_Disk
 44879 00000E76 1A0B0702                    DB  error_not_DOS_disk,           errCLASS_Media,     errACT_IntRet,   errLOC_Disk
 44880 00000E7A 1B0B0402                    DB  error_sector_not_found,       errCLASS_Media,     errACT_Abort,    errLOC_Disk
 44881 00000E7E 1C020704                    DB  error_out_of_paper,           errCLASS_TempSit,   errACT_IntRet,   errLOC_SerDev
 44882 00000E82 1D0504FF                    DB  error_write_fault,            errCLASS_HrdFail,   errACT_Abort,    0FFh
 44883 00000E86 1E0504FF                    DB  error_read_fault,             errCLASS_HrdFail,   errACT_Abort,    0FFh
 44884 00000E8A 1F0D04FF                    DB  error_gen_failure,            errCLASS_Unk,       errACT_Abort,    0FFh
 44885 00000E8E 200A0202                    DB  error_sharing_violation,      errCLASS_Locked,    errACT_DlyRet,   errLOC_Disk
 44886 00000E92 210A0202                    DB  error_lock_violation,         errCLASS_Locked,    errACT_DlyRet,   errLOC_Disk
 44887 00000E96 220B0702                    DB  error_wrong_disk,             errCLASS_Media,     errACT_IntRet,   errLOC_Disk
 44888 00000E9A 32090303                    DB  error_not_supported,          errCLASS_BadFmt,    errACT_User,     errLOC_Net
 44889 00000E9E 23070401                    DB  error_FCB_unavailable,        errCLASS_Apperr,    errACT_Abort,    errLOC_Unk
 44890 00000EA2 24010405                    DB  error_sharing_buffer_exceeded,errCLASS_OutRes,    errACT_Abort,    errLOC_Mem
 44891 00000EA6 FF0D05FF                    DB	0FFh,                         errCLASS_Unk,       errACT_Panic,    0FFh
 44892                                  
 44893                                  ; MSDOS 3.3 (IBMDOS.COM, 1987) - Offset 0D9Eh
 44894                                  ;ERR_TABLE_24:	db 13h,0Bh,7,2
 44895                                  ;		db 14h,4,5,1
 44896                                  ;		db 15h,5,7,0FFh
 44897                                  ;		db 16h,4,5,1
 44898                                  ;		db 17h,0Bh,4,2
 44899                                  ;		db 18h,4,5,1
 44900                                  ;		db 19h,5,1,2
 44901                                  ;		db 1Ah,0Bh,7,2
 44902                                  ;		db 1Bh,0Bh,4,2
 44903                                  ;		db 1Ch,2,7,4
 44904                                  ;		db 1Dh,5,4,0FFh
 44905                                  ;		db 1Eh,5,4,0FFh
 44906                                  ;		db 1Fh,0Dh,4,0FFh
 44907                                  ;		db 20h,0Ah,2,2
 44908                                  ;		db 21h,0Ah,2,2
 44909                                  ;		db 22h,0Bh,7,2
 44910                                  ;		db 32h,9,3,3
 44911                                  ;		db 23h,7,4,1
 44912                                  ;		db 24h,1,4,5
 44913                                  ;		db 0FFh,0Dh,5,0FFh
 44914                                  
 44915                                  ; DOSDATA:0EABh (MSDOS 6.21, MSDOS.SYS)
 44916                                  
 44917                                  ; ---------------------------------------------------------------------------
 44918                                  ;
 44919                                  ; We need to map old int 24 errors and device driver errors into the new set
 44920                                  ; of errors. The following table is indexed by the new errors
 44921                                  ;
 44922                                  ; ---------------------------------------------------------------------------
 44923                                  
 44924                                  ;Public  ErrMap24
 44925                                  ErrMap24: ; Label   BYTE
 44926 00000EAA 13                          DB  error_write_protect	; 0
 44927 00000EAB 14                          DB  error_bad_unit		; 1
 44928 00000EAC 15                          DB  error_not_ready		; 2
 44929 00000EAD 16                          DB  error_bad_command	; 3
 44930 00000EAE 17                          DB  error_CRC		; 4
 44931 00000EAF 18                          DB  error_bad_length	; 5
 44932 00000EB0 19                          DB  error_seek		; 6
 44933 00000EB1 1A                          DB  error_not_DOS_disk	; 7
 44934 00000EB2 1B                          DB  error_sector_not_found	; 8
 44935 00000EB3 1C                          DB  error_out_of_paper	; 9
 44936 00000EB4 1D                          DB  error_write_fault	; A
 44937 00000EB5 1E                          DB  error_read_fault	; B
 44938 00000EB6 1F                          DB  error_gen_failure	; C
 44939 00000EB7 1F                          DB  error_gen_failure	; D  RESERVED
 44940 00000EB8 1F                          DB  error_gen_failure	; E  RESERVED
 44941 00000EB9 22                          DB  error_wrong_disk	; F
 44942                                  
 44943                                  ;ErrMap24: db 13h, 14h, 15h, 16h, 17h, 18h, 19h, 1Ah
 44944                                  ;	   db 1Bh, 1Ch, 1Dh, 1Eh, 1Fh, 1Fh, 1Fh, 22h
 44945                                  	
 44946                                  ErrMap24End: ; LABEL   BYTE
 44947                                  
 44948                                  ; DOSDATA:0E5Bh (MSDOS 6.21, MSDOS.SYS)
 44949                                  
 44950                                  ; ---------------------------------------------------------------------------
 44951                                  
 44952                                  ; 27/04/2019 - Retro DOS v4.0
 44953                                  
 44954                                  FIRST_BUFF_ADDR:
 44955 00000EBA 0000                    	dw	0			; first buffer address               
 44956                                  SPECIAL_VERSION:
 44957 00000EBC 0000                    	dw	0			;AN006; used by INT 2F 47H
 44958                                  FAKE_COUNT:
 44959 00000EBE 00<rep FFh>             	times 255 db 0			;AN008; fake version count
 44960                                  OLD_FIRSTCLUS:
 44961 00000FBD 0000                    	dw	0			;AN011; save old first cluster for fastopen
 44962                                  
 44963                                  ; ---------------------------------------------------------------------------
 44964                                  
 44965                                  ;smr; moved from TABLE segment in exec.asm
 44966                                  
 44967 00000FBF 0000                    exec_init_SP: dw 0
 44968 00000FC1 0000                    exec_init_SS: dw 0
 44969 00000FC3 0000                    exec_init_IP: dw 0
 44970 00000FC5 0000                    exec_init_CS: dw 0
 44971                                  
 44972                                  exec_signature:
 44973 00000FC7 0000                    	dw	0	; must contain 4D5A  (yay zibo!)
 44974                                  exec_len_mod_512:
 44975 00000FC9 0000                    	dw	0	; low 9 bits of length
 44976                                  exec_pages:
 44977 00000FCB 0000                    	dw	0	; number of 512b pages in file
 44978                                  exec_rle_count:
 44979 00000FCD 0000                    	dw	0	; count of reloc entries
 44980                                  exec_par_dir:
 44981 00000FCF 0000                    	dw	0	; number of paragraphs before image
 44982                                  exec_min_BSS:
 44983 00000FD1 0000                    	dw	0	; minimum number of para of BSS
 44984                                  exec_max_BSS:
 44985 00000FD3 0000                    	dw	0	; max number of para of BSS
 44986                                  exec_SS:
 44987 00000FD5 0000                    	dw	0	; stack of image
 44988                                  exec_SP:
 44989 00000FD7 0000                    	dw	0	; SP of image
 44990                                  exec_chksum:
 44991 00000FD9 0000                    	dw	0	; checksum  of file (ignored)
 44992                                  exec_IP:
 44993 00000FDB 0000                    	dw	0	; IP of entry
 44994                                  exec_CS:
 44995 00000FDD 0000                    	dw	0	; CS of entry
 44996                                  exec_rle_table:
 44997 00000FDF 0000                    	dw	0	; byte offset of reloc table
 44998                                  
 44999                                  exec_header_len	equ $-exec_signature			;PBUGBUG
 45000                                  
 45001                                  ;smr; eom
 45002                                  
 45003                                  ; ---------------------------------------------------------------------------
 45004                                  
 45005                                  ;SR;
 45006                                  ; WIN386 instance table for DOS
 45007                                  
 45008                                  Win386_Info:
 45009 00000FE1 0300                    	db	3, 0
 45010 00000FE3 000000000000000000-     	dd	0, 0, 0
 45010 00000FEC 000000             
 45011 00000FEF [F30F]0000              	dw	Instance_Table, 0
 45012                                  
 45013                                  Instance_Table:
 45014 00000FF3 [2200]00000200          	dw	CONTPOS, 0, 2
 45015 00000FF9 [3200]00000400          	dw	BCON, 0, 4
 45016 00000FFF [F901]00000601          	dw	CARPOS, 0, 106h
 45017 00001005 [0003]00000100          	dw	CHARCO, 0, 1
 45018 0000100B [BF0F]00002200          	dw	exec_init_SP, 0, 34	; M074
 45019 00001011 [8900]00000100          	dw	UMBFLAG,0,1		; M019
 45020 00001017 [8C00]00000200          	dw	UMB_HEAD,0,2		; M019
 45021 0000101D 00000000                	dw	0, 0
 45022                                  
 45023                                  ; M001; SR;
 45024                                  ; M001; On DOSMGR call ( cx == 0 ), we need to return a table of offsets of 
 45025                                  ; M001; some DOS variables. Note that the only really important variable in 
 45026                                  ; M001; this is User_Id. The other variables are needed only to patch stuff 
 45027                                  ; M001; which does not need to be done in DOS 5.0. 
 45028                                  
 45029                                  ; 29/12/2022
 45030                                  ; (MSDOS 6.21 MSDOS.SYS DOSDATA:1022h)
 45031                                  
 45032                                  Win386_DOSVars:
 45033 00001021 05                      	db	5	;Major version 5 ; M001
 45034 00001022 00                      	db	0	;Minor version 0 ; M001
 45035 00001023 [EC05]                  	dw	SAVEDS	; M001
 45036 00001025 [EA05]                  	dw	SAVEBX	; M001
 45037 00001027 [2103]                  	dw	INDOS	; M001
 45038 00001029 [3E03]                  	dw	USER_ID	; M001
 45039 0000102B [1503]                  	dw	CritPatch ; M001
 45040 0000102D [8C00]                  	dw	UMB_HEAD ; M012
 45041                                  
 45042                                  ;SR;
 45043                                  ; Flag to indicate whether WIN386 is running or not
 45044                                  
 45045 0000102F 00                      IsWin386: db	0
 45046                                  
 45047                                  ;M018
 45048                                  ; This variable contains the path to the VxD device needed for Win386
 45049                                  
 45050 00001030 633A5C77696E613230-     VxDpath:  db	'c:\wina20.386',0	;M018
 45050 00001039 2E33383600         
 45051                                  
 45052                                  ;End WIN386 support
 45053                                  
 45054                                  ; ---------------------------------------------------------------------------
 45055                                  
 45056                                  ;SR;
 45057                                  ; These variables have been added for the special lie support for device
 45058                                  ;drivers.
 45059                                  ;
 45060                                  
 45061                                  DriverLoad:	
 45062 0000103E 01                      	db	1	;initialized to do special handling
 45063                                  BiosDataPtr:
 45064 0000103F 00000000                	dd	0
 45065                                  
 45066                                  ; 29/12/2022 - Retro DOS v4.1
 45067                                  %if 0
 45068                                  
 45069                                  ; 27/04/2019 - Retro DOS v4.0
 45070                                  ; 04/11/2022
 45071                                  ; DOSDATA:1044h (MSDOS 6.21 & MSDOS 5.0, MSDOS.SYS)
 45072                                  
 45073                                  ;------------------------------------------------------------------------
 45074                                  ; Patch for Sidekick
 45075                                  ;
 45076                                  ; A documented method for finding the offset of the Errormode flag in the 
 45077                                  ; dos swappable data area if for the app to scan in the dos segment (data) 
 45078                                  ; for the following sequence of instructions.
 45079                                  ;
 45080                                  ; Ref: Part C, Article 11, pg 356 of MSDOS Encyclopedia
 45081                                  ;
 45082                                  ; The Offset of Errormode flag is 0320h
 45083                                  ;
 45084                                  ;------------------------------------------------------------------------
 45085                                  
 45086                                  	db	036h, 0F6h, 06h, 020h, 03h, 0FFh ; test ss:[errormode], -1
 45087                                  	db	075h, 0Ch			 ; jnz  NearLabel
 45088                                  	db	036h, 0FFh, 036h, 058h, 03h	 ; push ss:[NearWord]
 45089                                  	db	0CDh, 028h			 ; int  28h
 45090                                  
 45091                                  ;--------------------------------------------------------------------------
 45092                                  ; Patch for PortOfEntry - M036
 45093                                  ;
 45094                                  ; PortOfEntry by Sector Technology uses an un documented way of determining
 45095                                  ; the offset of Errormode flag. The following patch is to support them in 
 45096                                  ; DOS 5.0. The corresponding code is actually in msdisp.asm
 45097                                  ;
 45098                                  ;---------------------------------------------------------------------------
 45099                                  
 45100                                  	db 	080h, 03Eh, 020h, 03h, 00h 	 ; cmp 	[errormode], 0
 45101                                  	db	075h, 037h			 ; jnz	NearLabel
 45102                                  	db 	0BCh, 0A0h, 0Ah		  	 ; mov	sp, dosdata:iostack
 45103                                  
 45104                                  %endif ; 29/12/2022
 45105                                  
 45106                                  ; DOSDATA:105Dh (MSDOS 6.21, MSDOS.SYS)
 45107                                  
 45108                                  ;--------------------------------------------------------------------------
 45109                                  
 45110                                  ;*** New FCB Implementation
 45111                                  ; This variable is used as a cache in the new FCB implementation to remember
 45112                                  ;the address of a local SFT that can be recycled for a regenerate operation
 45113                                  
 45114 00001043 00000000                LocalSFT: dd	0		; 0 to indicate invalid pointer
 45115                                  
 45116                                  ;DOSDATA ENDS
 45117                                  
 45118                                  ;============================================================================
 45119                                  ; LMSTUB.ASM (MSDOS 6.0, 1991)
 45120                                  ;============================================================================
 45121                                  ; 27/04/2019 - Retro DOS 4.0
 45122                                  
 45123                                  ;DOSDATA  SEGMENT WORD PUBLIC 'DATA'
 45124                                  
 45125                                  ;---------------------------------------------------------------------------
 45126                                  ;	Low Memory Stub for DOS when DOS runs in HMA
 45127                                  ;----------------------------------------------------------------------------
 45128                                  	
 45129                                  	;db	90h
 45130                                  
 45131                                  	;EVEN
 45132 00001047 90                      align 2
 45133                                  
 45134                                  ; DOSDATA:1062h (MSDOS 6.21, MSDOS.SYS)
 45135                                  
 45136                                  DOSINTTABLE:	; LABEL	DWORD
 45137                                  
 45138                                  	;DW	OFFSET DOSCODE:DIVOV 		, 0
 45139                                  	;DW	OFFSET DOSCODE:QUIT 		, 0
 45140                                  	;DW	OFFSET DOSCODE:COMMAND		, 0
 45141                                  	;DW	OFFSET DOSCODE:ABSDRD		, 0
 45142                                  	;DW	OFFSET DOSCODE:ABSDWRT		, 0
 45143                                  	;DW	OFFSET DOSCODE:Stay_resident	, 0
 45144                                  	;DW	OFFSET DOSCODE:INT2F		, 0
 45145                                  	;DW	OFFSET DOSCODE:CALL_ENTRY	, 0
 45146                                  	;DW	OFFSET DOSCODE:IRETT		, 0
 45147                                  	
 45148 00001048 [EB52]0000              	dw	DIVOV 		, 0  ; DOSINTTABLE+0
 45149 0000104C [E102]0000              	dw	QUIT 		, 0  ; DOSINTTABLE+4	
 45150 00001050 [0D03]0000              	dw	COMMAND		, 0  ; DOSINTTABLE+8
 45151 00001054 [4005]0000              	dw	ABSDRD		, 0  ; DOSINTTABLE+12
 45152 00001058 [C705]0000              	dw	ABSDWRT		, 0  ; DOSINTTABLE+16
 45153 0000105C [2C62]0000              	dw	STAY_RESIDENT	, 0  ; DOSINTTABLE+20
 45154 00001060 [1607]0000              	dw	INT2F		, 0  ; DOSINTTABLE+24
 45155 00001064 [E802]0000              	dw	CALL_ENTRY	, 0  ; DOSINTTABLE+28
 45156 00001068 [E702]0000              	dw	IRETT		, 0  ; DOSINTTABLE+32
 45157                                  
 45158 0000106C 0000                    SS_Save: dw	0		; save user's stack segment
 45159 0000106E 0000                    SP_Save: dw	0		; save user's stack offset
 45160                                  
 45161                                  ;-------------------------------------------------------------------------
 45162                                  ;
 45163                                  ; LOW MEM STUB:
 45164                                  ;
 45165                                  ; The low mem stub contains the entry points into DOS for all interrupts 
 45166                                  ; handled by DOS. This stub is installed if the user specifies that the 
 45167                                  ; DOS load in HIMEM. Each entry point does this.
 45168                                  ;
 45169                                  ; 	1. if jmp to 8 has been patched out
 45170                                  ;	   2. if A20 OFF
 45171                                  ;	      3. Enable A20
 45172                                  ;	   4. else 
 45173                                  ;	      5. just go to dos entry
 45174                                  ;	   6. endif
 45175                                  ;	7. else
 45176                                  ;	   8. just go to dos entry
 45177                                  ;	9. endif
 45178                                  ;
 45179                                  ;--------------------------------------------------------------------------
 45180                                  
 45181                                  ; 27/04/2019 - Retro DOS v4.0
 45182                                  
 45183                                  ; DOSDATA:108Ah (MSDOS 6.21, MSDOS.SYS)
 45184                                  
 45185                                  ;--------------------------------------------------------------------------
 45186                                  ;
 45187                                  ; DIVIDE BY 0 handler
 45188                                  ;
 45189                                  ;--------------------------------------------------------------------------
 45190                                  
 45191                                  ldivov:
 45192                                  	; The following jump, skipping the XMS calls will be patched to 
 45193                                  	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is 
 45194                                  	; needed because the stub is installed even before the XMS driver
 45195                                  	; is loaded if the user specifies dos=high in the config.sys
 45196                                  i0patch:
 45197 00001070 EB03                    	jmp	short divov_cont	
 45198                                  
 45199 00001072 E8D800                  	call	EnsureA20ON		; we must turn on A20 if OFF	
 45200                                  divov_cont:
 45201 00001075 2EFF2E[4810]            	jmp	far [cs:DOSINTTABLE]	; jmp to DOS
 45202                                  
 45203                                  ;------------------------------------------------------------------------
 45204                                  ;
 45205                                  ; INT 20 Handler
 45206                                  ;
 45207                                  ; Here we do not have to set up the stack to return here as the abort call
 45208                                  ; will return to the address after the int 21 ah=4b call. This would be the
 45209                                  ; common exit point if A20 had been OFF (for TOGGLE DOS) and the A20 line
 45210                                  ; will be restored then.
 45211                                  ;
 45212                                  ;-------------------------------------------------------------------------
 45213                                  
 45214                                  lquit:
 45215                                  	; The following jump, skipping the XMS calls will be patched to 
 45216                                  	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is 
 45217                                  	; needed because the stub is installed even before the XMS driver
 45218                                  	; is loaded if the user specifies dos=high in the config.sys
 45219                                  i20patch:
 45220 0000107A EB03                    	jmp	short quit_cont	
 45221                                  
 45222 0000107C E8CE00                  	call	EnsureA20ON		; we must turn on A20 if OFF	
 45223                                  quit_cont:
 45224 0000107F 2EFF2E[4C10]            	jmp	far [cs:DOSINTTABLE+4]	; jump to DOS
 45225                                  
 45226                                  ;--------------------------------------------------------------------------
 45227                                  ;
 45228                                  ; INT 21 Handler
 45229                                  ;
 45230                                  ;--------------------------------------------------------------------------
 45231                                  
 45232                                  lcommand:
 45233                                  	; The following jump, skipping the XMS calls will be patched to 
 45234                                  	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is 
 45235                                  	; needed because the stub is installed even before the XMS driver
 45236                                  	; is loaded if the user specifies dos=high in the config.sys
 45237                                  i21patch:
 45238 00001084 EB03                    	jmp	short command_cont	
 45239                                  
 45240 00001086 E8C400                  	call	EnsureA20ON		; we must turn on A20 if OFF	
 45241                                  command_cont:
 45242 00001089 2EFF2E[5010]            	jmp	far [cs:DOSINTTABLE+8]	; jmp to DOS
 45243                                  
 45244                                  ;------------------------------------------------------------------------
 45245                                  ;
 45246                                  ; INT 25 
 45247                                  ;
 45248                                  ;----------------------------------------------------------------------------
 45249                                  
 45250                                  labsdrd:
 45251                                  	; The following jump, skipping the XMS calls will be patched to 
 45252                                  	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is 
 45253                                  	; needed because the stub is installed even before the XMS driver
 45254                                  	; is loaded if the user specifies dos=high in the config.sys
 45255                                  i25patch:
 45256 0000108E EB03                    	jmp	short absdrd_cont	
 45257                                  
 45258 00001090 E8BA00                  	call	EnsureA20ON		; we must turn on A20 if OFF	
 45259                                  absdrd_cont:
 45260 00001093 2EFF2E[5410]            	jmp	far [cs:DOSINTTABLE+12]	; jmp to DOS
 45261                                  
 45262                                  ;-------------------------------------------------------------------------
 45263                                  ;
 45264                                  ; INT 26
 45265                                  ;
 45266                                  ;-----------------------------------------------------------------------
 45267                                  
 45268                                  labsdwrt:
 45269                                  	; The following jump, skipping the XMS calls will be patched to 
 45270                                  	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is 
 45271                                  	; needed because the stub is installed even before the XMS driver
 45272                                  	; is loaded if the user specifies dos=high in the config.sys
 45273                                  i26patch:
 45274 00001098 EB03                    	jmp	short absdwrt_cont	
 45275                                  
 45276 0000109A E8B000                  	call	EnsureA20ON		; we must turn on A20 if OFF	
 45277                                  absdwrt_cont:
 45278 0000109D 2EFF2E[5810]            	jmp	far [cs:DOSINTTABLE+16]	; jmp to DOS
 45279                                  
 45280                                  ;------------------------------------------------------------------------
 45281                                  ;
 45282                                  ; INT 27
 45283                                  ;
 45284                                  ;-----------------------------------------------------------------------
 45285                                  
 45286                                  lstay_resident:
 45287                                  	; The following jump, skipping the XMS calls will be patched to 
 45288                                  	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is 
 45289                                  	; needed because the stub is installed even before the XMS driver
 45290                                  	; is loaded if the user specifies dos=high in the config.sys
 45291                                  i27patch:
 45292 000010A2 EB03                    	jmp	short sr_cont	
 45293                                  
 45294 000010A4 E8A600                  	call	EnsureA20ON		; we must turn on A20 if OFF	
 45295                                  sr_cont:
 45296 000010A7 2EFF2E[5C10]            	jmp	far [cs:DOSINTTABLE+20]	; jmp to DOS
 45297                                  
 45298                                  ;-----------------------------------------------------------------------------
 45299                                  ;
 45300                                  ; INT 2f
 45301                                  ;
 45302                                  ;-------------------------------------------------------------------------
 45303                                  
 45304                                  lint2f:
 45305                                  	; The following jump, skipping the XMS calls will be patched to 
 45306                                  	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is 
 45307                                  	; needed because the stub is installed even before the XMS driver
 45308                                  	; is loaded if the user specifies dos=high in the config.sys
 45309                                  i2fpatch:
 45310 000010AC EB03                    	jmp	short int2f_cont	
 45311                                  
 45312 000010AE E89C00                  	call	EnsureA20ON		; we must turn on A20 if OFF	
 45313                                  int2f_cont:
 45314 000010B1 2EFF2E[6010]            	jmp	far [cs:DOSINTTABLE+24]	; jmp to DOS
 45315                                  
 45316                                  ;-----------------------------------------------------------------------------
 45317                                  ;
 45318                                  ; CPM entry
 45319                                  ;
 45320                                  ;------------------------------------------------------------------------
 45321                                  
 45322                                  lcall_entry:
 45323                                  	; The following jump, skipping the XMS calls will be patched to 
 45324                                  	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is 
 45325                                  	; needed because the stub is installed even before the XMS driver
 45326                                  	; is loaded if the user specifies dos=high in the config.sys
 45327                                  cpmpatch:
 45328 000010B6 EB03                    	jmp	short callentry_cont	
 45329                                  
 45330 000010B8 E89200                  	call	EnsureA20ON		; we must turn on A20 if OFF	
 45331                                  callentry_cont:
 45332 000010BB 2EFF2E[6410]            	jmp	far [cs:DOSINTTABLE+28]	; jmp to DOS
 45333                                  
 45334                                  ;--------------------------------------------------------------------------
 45335                                  
 45336                                  lirett:
 45337 000010C0 CF                      	iret
 45338                                  
 45339                                  ;---------------------------------------------------------------------------
 45340                                  ;
 45341                                  ; LowIntXX:
 45342                                  ;
 45343                                  ; Interrupts from DOS that pass control to a user program must be done from
 45344                                  ; low memory, as the user program may change the state of the A20 line or
 45345                                  ; they may require that the A20 line be OFF. The following piece of code is
 45346                                  ; far call'd from the following places in DOS:
 45347                                  ;
 45348                                  ;	1. msctrlc.asm where dos issues an int 23h (ctrlc)
 45349                                  ;	2. msctrlc.asm where dos issues an int 24h (critical error)
 45350                                  ;	3. msctrlc.asm where dos issues an int 28h (idle int)
 45351                                  ;
 45352                                  ; The int 23 and int 24 handlers may decide to do a far return instead of an
 45353                                  ; IRET ane leave the flags on the stack. Therefore we save the return address
 45354                                  ; before doing the ints and then do a far junp back into DOS.
 45355                                  ;
 45356                                  ;---------------------------------------------------------------------------
 45357                                  
 45358 000010C1 00000000                DosRetAddr23:	dd	0
 45359 000010C5 00000000                DosRetAddr24:	dd	0
 45360 000010C9 00000000                DosRetAddr28:	dd	0
 45361                                  
 45362                                  	; Execute int 23h from low memory
 45363                                  LowInt23:
 45364                                  					; save the return address that is on
 45365                                  					; the stack
 45366 000010CD 2E8F06[C110]            	pop	word [cs:DosRetAddr23]
 45367 000010D2 2E8F06[C310]            	pop	word [cs:DosRetAddr23+2]
 45368                                  
 45369 000010D7 CD23                    	int	23h			; ctrl C
 45370                                  					; turn on A20 it has been turned OFF
 45371                                  					; by int 28/23/24 handler.
 45372                                  
 45373 000010D9 E87100                  	call	EnsureA20ON		; M011: we must turn on A20 if OFF 
 45374                                  
 45375 000010DC 2EFF2E[C110]            	jmp	far [cs:DosRetAddr23]	; jump back to DOS
 45376                                  
 45377                                  
 45378                                  	; Execute int 24h from low memory
 45379                                  LowInt24:
 45380                                  					; save the return address that is on
 45381                                  					; the stack
 45382 000010E1 2E8F06[C510]            	pop	word [cs:DosRetAddr24]
 45383 000010E6 2E8F06[C710]            	pop	word [cs:DosRetAddr24+2]
 45384                                  
 45385 000010EB CD24                    	int	24h			; crit error
 45386                                  					; turn on A20 it has been turned OFF
 45387                                  					; by int 28/23/24 handler.
 45388                                  
 45389 000010ED E85D00                  	call	EnsureA20ON		; M011: we must turn on A20 if OFF	
 45390                                  
 45391 000010F0 2EFF2E[C510]            	jmp	far [cs:DosRetAddr24]	; jump back to DOS
 45392                                  
 45393                                  
 45394                                   
 45395                                  	; Execute int 28h from low memory
 45396                                  LowInt28:
 45397 000010F5 CD28                    	int	28h			; idle int
 45398                                  					; turn on A20 it has been turned OFF
 45399                                  					; by int 28/23/24 handler.
 45400                                  
 45401 000010F7 E85300                  	call	EnsureA20ON		; M011: we must turn on A20 if OFF	
 45402                                  
 45403 000010FA CB                      	retf
 45404                                  
 45405                                  ; DOSDATA:1115h (MSDOS 6.21, MSDOS.SYS)
 45406                                  
 45407                                  ;-------------------------------------------------------------------------
 45408                                  ;
 45409                                  ; int 21 ah=4b (exec) call will jump to the following label before xferring
 45410                                  ; control to the exec'd program. We turn off A20 inorder to allow programs
 45411                                  ; that have been packed by the faulty exepack utility to unpack correctly.
 45412                                  ; This is so because exepac'd programs rely on address wrap.
 45413                                  ;
 45414                                  ;------------------------------------------------------------------------- 
 45415                                  
 45416                                  disa20_xfer:
 45417 000010FB E83F00                  	call	XMMDisableA20		; disable A20
 45418                                  
 45419                                  	; Look at msproc.asm at label exec_go for understanding the following:
 45420                                  
 45421                                  	; DS:SI points to entry point
 45422                                  	; AX:DI points to initial stack
 45423                                  	; DX has PDB pointer
 45424                                  	; BX has initial AX value
 45425                                  
 45426 000010FE FA                      	cli
 45427 000010FF 2EC606[2103]00          	mov	byte [cs:INDOS],0	; SS Override
 45428                                  
 45429 00001105 8ED0                    	mov	SS,AX			; set up user's stack
 45430 00001107 89FC                    	mov	SP,DI			; and SP
 45431 00001109 FB                      	sti
 45432                                  
 45433 0000110A 1E                      	push	DS			; fake long call to entry
 45434 0000110B 56                      	push	SI
 45435 0000110C 8EC2                    	mov	ES,DX			; set up proper seg registers
 45436 0000110E 8EDA                    	mov	DS,DX
 45437 00001110 89D8                    	mov	AX,BX			; set up proper AX
 45438 00001112 CB                      	retf
 45439                                  
 45440                                  ;-------------------------------------------------------------------------
 45441                                  ;
 45442                                  ; M003:
 45443                                  ;
 45444                                  ; If an int 21 ah=25 call is made immediately after an exec call, DOS will
 45445                                  ; come here, turn A20 OFF restore user stack and registers before returning 
 45446                                  ; to user. This is done in dos\msdisp.asm. This has been done to support 
 45447                                  ; programs compiled with MS PASCAL 3.2. See under TAG M003 in DOSSYM.INC for 
 45448                                  ; more info.	
 45449                                  ;
 45450                                  ; Also at this point DS is DOSDATA. So we can assume DS DOSDATA. Note that 
 45451                                  ; SS is also DOS stack. It is important that we do the XMS call on DOS's 
 45452                                  ; stack to avoid additional stack overhead for the user.
 45453                                  ;
 45454                                  ; -------------------------------------------------------------------------
 45455                                  
 45456                                  disa20_iret:
 45457 00001113 E82700                  	call	XMMDisableA20
 45458 00001116 FE0E[2103]              	dec	byte [INDOS]
 45459 0000111A 8E16[8605]              	mov	SS,[USER_SS]		; restore user stack
 45460 0000111E 8B26[8405]              	mov	SP,[USER_SP]
 45461 00001122 89E5                    	mov	BP,SP
 45462                                  	;mov	[BP+user_env.user_AX],AL
 45463 00001124 884600                  	mov	[bp],al
 45464 00001127 A1[F205]                	mov	AX,[NSP]
 45465 0000112A A3[8405]                	mov	[USER_SP],AX
 45466 0000112D A1[F005]                	mov	AX,[NSS]
 45467 00001130 A3[8605]                	mov	[USER_SS],AX
 45468                                  
 45469 00001133 58                      	pop	AX			; restore user regs
 45470 00001134 5B                      	pop	BX
 45471 00001135 59                      	pop	CX
 45472 00001136 5A                      	pop	DX
 45473 00001137 5E                      	pop	SI
 45474 00001138 5F                      	pop	DI
 45475 00001139 5D                      	pop	BP
 45476 0000113A 1F                      	pop	DS
 45477 0000113B 07                      	pop	ES
 45478 0000113C CF                      	iret
 45479                                  
 45480                                  ;**************************************************************************
 45481                                  ;***	XMMDisableA20 - switch 20th address line			      
 45482                                  ;									      
 45483                                  ;	This routine is used to disable the 20th address line in 	      
 45484                                  ;	the system using XMM calls.					      
 45485                                  ;									      
 45486                                  ;	ENTRY	none		;ds = _DATA				      
 45487                                  ;	EXIT	A20 line disabled					      
 45488                                  ;	USES	NOTHING					      
 45489                                  ;									      
 45490                                  ;**************************************************************************
 45491                                  
 45492                                  XMMDisableA20:
 45493 0000113D 53                      	push	bx
 45494 0000113E 50                      	push	ax
 45495                                  	;mov	ah,XMM_LOCAL_DISABLE_A20
 45496 0000113F B406                    	mov	ah,6
 45497 00001141 2EFF1E[4911]            	call	far [cs:XMMcontrol]
 45498 00001146 58                      	pop	ax
 45499 00001147 5B                      	pop	bx
 45500 00001148 C3                      	retn
 45501                                  
 45502                                  ; The entry point in the BIOS XMS driver is defined here.
 45503                                  
 45504                                  XMMcontrol:
 45505 00001149 00000000                	dd	0
 45506                                  
 45507                                  ;--------------------------------------------------------------------------
 45508                                  ;
 45509                                  ;***	EnsureA20ON - Ensures that A20 is ON
 45510                                  ;									      
 45511                                  ;	This routine is used to query the A20 state in		 	      
 45512                                  ;	the system using XMM calls.					      
 45513                                  ;									      
 45514                                  ;	ENTRY: none		
 45515                                  ;
 45516                                  ;	EXIT : A20 will be ON
 45517                                  ;		
 45518                                  ; 	USES : NONE								      
 45519                                  ;									      
 45520                                  ;--------------------------------------------------------------------------
 45521                                  
 45522                                  ; 19/09/2023
 45523                                  ;LowMemory:	; label dword		; Set equal to 0000:0080
 45524                                  ;	dw	00080h
 45525                                  ;	dw	00000h
 45526                                  ;
 45527                                  ;HighMemory:	; label dword
 45528                                  ;	dw	00090h			; Set equal to FFFF:0090
 45529                                  ;	dw	0FFFFh
 45530                                  
 45531                                  EnsureA20ON:
 45532 0000114D 9C                      	pushf
 45533 0000114E 1E                      	push    ds
 45534 0000114F 06                      	push	es
 45535 00001150 51                      	push	cx
 45536 00001151 56                      	push	si
 45537 00001152 57                      	push	di
 45538                                  
 45539                                  	; 19/09/2023
 45540                                  	;lds	si,[cs:LowMemory]	; Compare the 4 words at 0000:0080
 45541                                  	;les	di,[cs:HighMemory]	; with the 4 at FFFF:0090
 45542                                  
 45543 00001153 31FF                    	xor	di,di
 45544 00001155 8EC7                    	mov	es,di
 45545 00001157 4F                      	dec	di
 45546 00001158 BE9000                  	mov	si,90h	; 0FFFFh:0090h	; HighMemory
 45547 0000115B 8EDF                    	mov	ds,di
 45548 0000115D BF8000                  	mov	di,80h ; 0000h:0080h	; LowMemory
 45549                                  	
 45550 00001160 B90400                  	mov	cx,4
 45551 00001163 FC                      	cld
 45552 00001164 F3A7                    	repe    cmpsw
 45553                                  
 45554 00001166 7407                    	jz	short EA20_OFF
 45555                                  EA20_RET:
 45556 00001168 5F                      	pop	di
 45557 00001169 5E                      	pop	si
 45558 0000116A 59                      	pop	cx
 45559 0000116B 07                      	pop	es
 45560 0000116C 1F                      	pop	ds
 45561 0000116D 9D                      	popf
 45562 0000116E C3                      	retn
 45563                                  
 45564                                  EA20_OFF:
 45565                                  	; We are going to do the XMS call on the DOS's AuxStack.
 45566                                  	; NOTE: ints are disabled at this point.
 45567                                  
 45568 0000116F 53                      	push	bx
 45569 00001170 50                      	push	ax
 45570                                  
 45571 00001171 8CD0                    	mov	ax,ss			; save user's stack pointer
 45572 00001173 2EA3[6C10]              	mov	[cs:SS_Save],ax
 45573 00001177 2E8926[6E10]            	mov	[cs:SP_Save],sp
 45574 0000117C 8CC8                    	mov	ax,cs
 45575 0000117E 8ED0                    	mov	ss,ax
 45576 00001180 BC[A007]                	mov	sp,AUXSTACK
 45577                                  					; ss:sp -> DOSDATA:AuxStack
 45578                                  	;mov	ah,XMM_LOCAL_ENABLE_A20
 45579 00001183 B405                    	mov	ah,5
 45580 00001185 2EFF1E[4911]            	call	far [cs:XMMcontrol]
 45581 0000118A 09C0                    	or	ax,ax
 45582 0000118C 740F                    	jz	short XMMerror		; AX = 0 fatal error
 45583                                  
 45584 0000118E 2EA1[6C10]              	mov	ax,[cs:SS_Save]		; restore user stack
 45585 00001192 8ED0                    	mov	ss,ax
 45586 00001194 2E8B26[6E10]            	mov	sp,[cs:SP_Save]
 45587                                  
 45588 00001199 58                      	pop	ax
 45589 0000119A 5B                      	pop	bx
 45590                                  
 45591 0000119B EBCB                    	jmp	short EA20_RET
 45592                                  
 45593                                  XMMerror:				; M006 - Start
 45594 0000119D B40F                    	mov	ah,0Fh			; get video mode
 45595 0000119F CD10                    	int	10h
 45596 000011A1 3C07                    	cmp	al,7			; Q: are we an MDA
 45597 000011A3 7406                    	je	short XMMcont			; Y: do not change mode
 45598 000011A5 30E4                    	xor	ah,ah ; 0			; set video mode
 45599 000011A7 B002                    	mov	al,02h			; 80 X 25 text
 45600 000011A9 CD10                    	int	10h
 45601                                  XMMcont:
 45602 000011AB B405                    	mov	ah,05h			; set display page
 45603 000011AD 30C0                    	xor	al,al			; page 0
 45604 000011AF CD10                    	int	10h
 45605                                  	
 45606 000011B1 BE[8E12]                	mov	si,XMMERRMSG
 45607 000011B4 0E                      	push	cs
 45608 000011B5 1F                      	pop	ds
 45609 000011B6 FC                      	cld				; clear direction flag
 45610                                  XMMprnt:
 45611 000011B7 AC                      	lodsb
 45612 000011B8 3C24                    	cmp	al,'$'			; indicates end of XMMERRMSG
 45613 000011BA 7409                    	jz	short XMMStall		; function 0Eh	
 45614 000011BC B40E                    	mov	ah,0Eh
 45615 000011BE BB0700                  	mov	bx,7
 45616 000011C1 CD10                    	int	10h
 45617 000011C3 EBF2                    	jmp	short XMMprnt
 45618                                  
 45619                                  XMMStall:
 45620 000011C5 FB                      	sti				; allow the user to warm boot
 45621 000011C6 EBFD                    	jmp	short XMMStall		; M006 - End
 45622                                  
 45623                                  ;---------------------------------------------------------------------------
 45624                                  
 45625                                  ; 27/04/2019 - Retro DOS v4.0
 45626                                  
 45627                                  ; retrodos4.s ; offset 0Ch in BIOS segment (0070h)
 45628                                  ALTAH	equ 0Ch
 45629                                  
 45630                                  ;This has been put in for WIN386 2.XX support. The format of the instance 
 45631                                  ;table was different for this. Segments will be patched in at init time.
 45632                                  
 45633                                  OldInstanceJunk:
 45634 000011C8 7000                    	dw	70h	;segment of BIOS
 45635 000011CA 0000                    	dw	0	;indicate stacks in SYSINIT area
 45636 000011CC 0600                    	dw	6	;5 instance items
 45637                                  
 45638                                  	;dw	0,offset dosdata:contpos, 2
 45639                                  	;dw	0,offset dosdata:bcon, 4
 45640                                  	;dw	0,offset dosdata:carpos,106h
 45641                                  	;dw	0,offset dosdata:charco, 1
 45642                                  	;dw	0,offset dosdata:exec_init_sp, 34               ;M032
 45643                                  	;dw	070h,offset BData:altah, 1	 ; altah byte in bios
 45644                                  
 45645 000011CE 0000[2200]0200          	dw	0,CONTPOS,2
 45646 000011D4 0000[3200]0400          	dw	0,BCON,4
 45647 000011DA 0000[F901]0601          	dw	0,CARPOS,106h
 45648 000011E0 0000[0003]0100          	dw	0,CHARCO,1
 45649 000011E6 0000[BF0F]2200          	dw	0,exec_init_SP,34
 45650 000011EC 70000C000100            	dw	70h,ALTAH,1	; altah byte in bios
 45651                                  
 45652                                  ;---------------------------------------------------------------------------
 45653                                  
 45654                                  ; M021-
 45655                                  ;
 45656                                  ; DosHasHMA - This flag is set by seg_reinit when the DOS actually
 45657                                  ; 	takes control of the HMA. When running, this word is a reliable
 45658                                  ;	indicator that the DOS is actually using HMA. You can't just use
 45659                                  ;	CS, because ROMDOS uses HMA with CS < F000.
 45660                                  
 45661                                  DosHasHMA:
 45662 000011F2 00                      	db	0
 45663                                  FixExePatch:
 45664 000011F3 0000                    	dw	0		; M012
 45665                                  
 45666                                  ; 28/12/2022 - Retro DOS v4.1
 45667                                  ;RationalPatchPtr:
 45668                                  ;	dw	0		; M012
 45669                                  
 45670                                  ; End M021
 45671                                  
 45672                                  ;---------------------------------------------------------------------------
 45673                                  
 45674                                  ; 28/12/2022 - Retro DOS v4.1
 45675                                  %if 0
 45676                                  
 45677                                  ; M020 Begin
 45678                                  
 45679                                  RatBugCode:	; proc	far
 45680                                  	push	cx
 45681                                  	mov	cx,[10h]
 45682                                  rbc_loop:
 45683                                  	;loop	$
 45684                                  	loop	rbc_loop
 45685                                  	pop	cx
 45686                                  	retf
 45687                                  		
 45688                                  ; M020 End
 45689                                  
 45690                                  %endif
 45691                                  
 45692                                  ;---------------------------------------------------------------------------
 45693                                  	
 45694                                  UmbSave1:
 45695                                  	;db	11 dup (?)	; M023
 45696 000011F5 00<rep Bh>              	times	11 db 0	
 45697                                  
 45698                                  ; DOSDATA:122Ah
 45699                                  
 45700                                  Mark3:	; label byte
 45701                                  
 45702                                  ;IF2
 45703                                  ;	IF ((OFFSET MARK3) GT (OFFSET COUNTRY_CDPG) )
 45704                                  ;		%OUT !DATA CORRUPTION!MARK3 OFFSET TOO BIG. RE-ORGANIZE DATA.
 45705                                  ;	ENDIF
 45706                                  ;ENDIF
 45707                                  
 45708                                  ;############################################################################
 45709                                  ;
 45710                                  ; ** HACK FOR DOS 4.0 REDIR **
 45711                                  ;
 45712                                  ; The dos 4.X redir requires that country_cdpg is at offset 0122ah. Any new
 45713                                  ; data variable that is to be added to DOSDATA must go in between Mark3
 45714                                  ; COUNTRY_CDPG if it can. 
 45715                                  ;
 45716                                  ; MARK3 SHOULD NOT BE > 122AH 
 45717                                  ;
 45718                                  ; As of 9/6/90, this area is FULL!
 45719                                  ;
 45720                                  ;############################################################################
 45721                                   
 45722                                  	;ORG	0122Ah
 45723                                  
 45724                                  ; DOSDATA:122Ah (MSDOS 6.21, MSDOS.SYS)
 45725                                  
 45726                                  ; The following table is used for DOS 3.3
 45727                                  ;DOS country and code page information is defined here for DOS 3.3.
 45728                                  ;The initial value for ccDosCountry is 1 (USA).
 45729                                  ;The initial value for ccDosCodepage is 850.
 45730                                  
 45731                                  ; country and code page information
 45732                                  ; ---------------------------------------------------------------------------
 45733                                  COUNTRY_CDPG:	; label  byte
 45734 00001200 0000000000000000        	db   0,0,0,0,0,0,0,0		; reserved words
 45735 00001208 5C434F554E5452592E-     	db   '\COUNTRY.SYS',0		; path name of country.sys
 45735 00001211 53595300           
 45736                                  	;db   51 dup (?)
 45737 00001215 00<rep 33h>             	times 51 db 0
 45738                                  ; ------------------------------------------------<MSKK01>-------------------
 45739                                  ;ifdef	DBCS
 45740                                  ;  ifdef JAPAN
 45741                                  ;	dw   932			; system code page id (JAPAN)
 45742                                  ;  endif
 45743                                  ;  ifdef TAIWAN
 45744                                  ;	dw   938			; system code page id (TAIWAN)
 45745                                  ;  endif
 45746                                  ;  ifdef KOREA
 45747                                  ;	dw   934			; system code page id (KOREA IBM)
 45748                                  ;  endif
 45749                                  ;else
 45750 00001248 B501                    	dw   437			; system code page id
 45751                                  ;endif
 45752                                  ; ------------------------------------------------<MSKK01>-------------------
 45753 0000124A 0600                    	dw   6				; number of entries
 45754 0000124C 02                      	db   SetUcase  ; 2		; Ucase type
 45755 0000124D [AD0A]                  	dw   UCASE_TAB			;pointer to upper case table
 45756 0000124F 0000                    	dw   0				; segment of poiter
 45757 00001251 04                      	db   SetUcaseFile  ; 4		; Ucase file char type
 45758 00001252 [2F0B]                  	dw   FILE_UCASE_TAB 		;pointer to file upper case table
 45759 00001254 0000                    	dw   0				; segment of poiter
 45760 00001256 05                      	db   SetFileList ; 5		; valid file chars type
 45761 00001257 [B10B]                  	dw   FILE_CHAR_TAB 		;pointer to valid file char tab
 45762 00001259 0000                    	dw   0				; segment of poiter
 45763 0000125B 06                      	db   SetCollate	; 6		; collate type
 45764 0000125C [E10B]                  	dw   COLLATE_TAB		;pointer to collate table
 45765 0000125E 0000                    	dw   0				; segment of poiter
 45766 00001260 07                      	db   SetDBCS	; 7		;AN000; DBCS Ev			2/12/KK
 45767 00001261 [E30C]                  	dw   DBCS_TAB			;AN000;pointer to DBCS Ev table	2/12/KK
 45768 00001263 0000                    	dw   0				;AN000; segment of pointer	2/12/KK
 45769 00001265 01                      	db   SetCountryInfo  ; 1	; country info type
 45770 00001266 2600                    	dw   NEW_COUNTRY_SIZE		; extended country info size
 45771                                  ; ------------------------------------------------<MSKK01>-------------------
 45772                                  ;ifdef	DBCS
 45773                                  ;	...... 
 45774                                  ;else
 45775 00001268 0100                    	dw   1				; USA country id
 45776 0000126A B501                    	dw   437			; USA system code page id
 45777 0000126C 0000                    	dw   0 				; date format
 45778 0000126E 2400000000              	db   '$',0,0,0,0		; currency symbol
 45779 00001273 2C00                    	db   ',',0			; thousand separator
 45780 00001275 2E00                    	db   '.',0			; decimal separator
 45781 00001277 2D00                    	db   '-',0			; date separator
 45782 00001279 3A00                    	db   ':',0			; time separator
 45783 0000127B 00                      	db   0				; currency format flag
 45784 0000127C 02                      	db   2				; # of digits in currency
 45785 0000127D 00                      	db   0 				; time format
 45786 0000127E [F50C]                  	dw   MAP_CASE			; mono case routine entry point
 45787 00001280 0000                    	dw   0				; segment of entry point
 45788 00001282 2C00                    	db   ',',0			; data list separator
 45789 00001284 000000000000000000-     	dw   0,0,0,0,0			; reserved
 45789 0000128D 00                 
 45790                                  ;endif
 45791                                  ; ------------------------------------------------<MSKK01>-------------------
 45792                                  
 45793                                  ; 27/04/2019 - Retro DOS v4.0
 45794                                  
 45795                                  ;include msdos.cl2			; XMMERRMSG
 45796                                  
 45797                                  ; DOSDATA:122Ah (MSDOS 6.21, MSDOS.SYS)
 45798                                  
 45799                                  XMMERRMSG:
 45800 0000128E 0D0A                    	db	0Dh,0Ah
 45801 00001290 413230204861726477-     	db	'A20 Hardware Error',0Dh,0Ah,'$'
 45801 00001299 617265204572726F72-
 45801 000012A2 0D0A24             
 45802                                  
 45803                                  ; DOSDATA ends
 45804                                  
 45805                                  ; 05/11/2022
 45806                                  ;----------------------------------------------------------------------------
 45807                                  ; End of MSDOS 5.0 MSDOS.SYS /// Retro DOS v4.0 (2022) - 05/11/2022
 45808                                  ;----------------------------------------------------------------------------
 45809                                  
 45810                                  ; 28/12/2022 - Retro DOS v4.1
 45811                                  ; (windows 3.1 and Rational Extender patches are removed/disabled)
 45812                                  ; (Windows 3.1 does not use the patches below if DOS version is MSDOS 5.0)
 45813                                  ;----------------------------------------------------------------------------
 45814                                  %if 0
 45815                                  
 45816                                  ;----------------------------------------------------------------------------
 45817                                  ; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 45818                                  
 45819                                  ;============================================================================
 45820                                  ; WPATCH.INC (MSDOS 6.0, 1991)  ;;; Windows 3.1 patches ;;;
 45821                                  ;============================================================================
 45822                                  ; 27/04/2019 - Retro DOS 4.0
 45823                                  
 45824                                  ;DOSDATA Segment
 45825                                  
 45826                                  ; DOSDATA:12CFh (MSDOS 6.21, MSDOS.SYS)
 45827                                  
 45828                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 45829                                  ; DOSDATA:12CFh (MSDOS 5.0, MSDOS.SYS)
 45830                                  
 45831                                  ; first and second DOS patches
 45832                                  ;	Non-console device read/write (system calls 3Fh and 40h)
 45833                                  ;
 45834                                  ; Code in disk.asm, 2 locations, one for read, one for write
 45835                                  ;	DVRDLP:
 45836                                  ;	DVWRTLP:
 45837                                  ;
 45838                                  ;
 45839                                  ; 036h	lds	si,SS:[????]				  ; ThisSFT
 45840                                  ;	lds	si,si+7 				  ; sf_devptr
 45841                                  ; 0E8h	call	????		<- "simulate" int28 event ; DSKSTATCHK
 45842                                  
 45843                                  DOSP1_ID:	db	036h,0C5h,036h
 45844                                  DOSP1_THISSFT:	db	036h,005h,0C5h,074h,007h,0E8h
 45845                                  DOSP1_ID_LEN	equ	$-DOSP1_ID
 45846                                  
 45847                                  		db	90h, 90h
 45848                                  
 45849                                  DOSP12_ID:	db	036h,0C5h,036h
 45850                                  DOSP12_THISSFT:	db	036h,005h,0C5h,074h,007h,0E8h
 45851                                  DOSP12_ID_LEN	equ	$-DOSP1_ID
 45852                                  
 45853                                  ; DOSDATA:12E3h
 45854                                  
 45855                                  ; Third/Fourth DOS patch - System call 3Fh (Read) from console
 45856                                  ;
 45857                                  ; Code in disk.asm, 1 location
 45858                                  ;	GETBUF:
 45859                                  ;
 45860                                  ; 051h	push	cx	<- begin special int28 mode
 45861                                  ;	push	es
 45862                                  ;	push	di
 45863                                  ;	mov	dx,???? ; offset dosgroup:CONBUF
 45864                                  ;	call	????	; $STD_CON_STRING_INPUT
 45865                                  ;	pop	di
 45866                                  ;	pop	es
 45867                                  ; 059h	pop	cx	<- end special int28 mode
 45868                                  
 45869                                  DOSP3_ID:	db	051h,006h,057h,0BAh
 45870                                  DOSP3_CONBUF:	db	029h,002h,0E8h
 45871                                  DOSP3_ID_LEN	equ	$-DOSP3_ID
 45872                                  		db	09Ah,0E3h,05Fh,007h	; ???? , pop di, pop es
 45873                                  DOSP4_ID:	db	059h			; pop cx
 45874                                  DOSP4_ID_OFF	equ	(DOSP4_ID - DOSP3_ID)
 45875                                  	
 45876                                  ; DOSDATA:12EFh
 45877                                  
 45878                                  ; Fifth DOS patch - System call 40h (Write) to console
 45879                                  ;
 45880                                  ; Code in disk.asm, 1 location
 45881                                  ;
 45882                                  ;		push	cx
 45883                                  ;      WRCONLP: lodsb
 45884                                  ;		cmp	al,1Ah
 45885                                  ;		jz	????
 45886                                  ;		call	????	<- "simulate" int28 event
 45887                                  ;		loop	WRCONLP
 45888                                  ;      CONEOF:	pop	ax
 45889                                  
 45890                                  DOSP5_ID:	db	051h			; push cx
 45891                                  		db	0ACh,03Ch,01Ah,074h,005h
 45892                                  		db	0E8h			; call
 45893                                  DOSP5_ID_LEN	equ	$-DOSP5_ID
 45894                                  
 45895                                  ; DOSDATA:12F6h
 45896                                  
 45897                                  ; Seventh DOS patch - System call entry, patch USER_ID with VMid for share
 45898                                  ;
 45899                                  ; Code in disp.asm, 1 location
 45900                                  ;
 45901                                  ;
 45902                                  ;	mov [SaveDS],ds
 45903                                  ;	mov [SaveBX],bx
 45904                                  ;	mov bx,cs
 45905                                  ;	mov ds,bx
 45906                                  ;	inc [indos]
 45907                                  ;	xor ax,ax
 45908                                  ;	mov [USER_ID],AX	<- Patch to set USER_ID to VMID
 45909                                  
 45910                                  DOSP7_ID:	db	02Eh,08Ch,01Eh
 45911                                  DOSP7_SAVEDS:	db	07Eh,05h		; mov [SaveDS],ds
 45912                                  		db	02Eh,089h,01Eh
 45913                                  DOSP7_SAVEBX:	db	07Ch,05h		; mov [SaveBX],bx
 45914                                  		db	08Ch,0CBh		; mov bx,cs
 45915                                  		db	08Eh,0DBh		; mov ds,bx
 45916                                  		db	0FEh,006h
 45917                                  DOSP7_INDOS:	db	0CFh,002h		; inc [indos]
 45918                                  		db	033h,0C0h		; xor ax,ax
 45919                                  DOSP7_ID_LEN	equ	$-DOSP7_ID
 45920                                  
 45921                                  ; DOSDATA:130Ah
 45922                                  
 45923                                  ; Eighth DOS patch - OWNER check in handle calls. For share, need to NOP test
 45924                                  ;
 45925                                  ; Code in handle.asm, 1 location in routine CheckOwner
 45926                                  ;
 45927                                  ;
 45928                                  ;
 45929                                  ;	push	ax
 45930                                  ;	mov	ax,ss:[USER_ID]     <- patch to XOR AX,AX to set zero
 45931                                  ;	cmp	ax,es:[di.sf_UID]   <- NOP
 45932                                  ;	pop	ax
 45933                                  ;	jz	????
 45934                                  
 45935                                  DOSP8_ID:	db	050h			; push ax
 45936                                  		db	036h,0A1h
 45937                                  DOSP8_USER_ID:	db	0EAh,002h		; mov  ax,ss:[USER_ID]
 45938                                  		db	026h,03Bh,045h		; cmp  ax,es:[di+2F]
 45939                                  DOSP8_ID_LEN	equ	$-DOSP8_ID
 45940                                  		db	02Fh,058h		; pop  ax
 45941                                  
 45942                                  ; DOSDATA:1314h
 45943                                  
 45944                                  ; 10th, 11th, 12th DOS patch - System call 3Fh (Read) in raw mode
 45945                                  ;
 45946                                  ;   Take RAW read to STDIN SFT and turn it into a polling loop doing
 45947                                  ;   a yeild when a character is not ready to be read.
 45948                                  ;
 45949                                  ; Code in disk.asm, 3 locations
 45950                                  ;
 45951                                  ;   DVRDRAW:
 45952                                  ;	    PUSH    ES
 45953                                  ;	    POP     DS
 45954                                  ;   ReadRawRetry:				<- Patch 10
 45955                                  ;	    MOV     BX,DI
 45956                                  ;	    XOR     AX,AX			<- Reenter #2
 45957                                  ;	    MOV     DX,AX
 45958                                  ;	    call    SETREAD
 45959                                  ;	    PUSH    DS				<- Reenter #1
 45960                                  ;	    LDS     SI,[THISSFT]
 45961                                  ;	    call    DEVIOCALL
 45962                                  ;	    MOV     DX,DI
 45963                                  ;	    MOV     AH,86H
 45964                                  ;	    MOV     DI,[DEVCALL.REQSTAT]
 45965                                  ;	    TEST    DI,STERR
 45966                                  ;	    JZ	    CRDROK
 45967                                  ;	    call    CHARHARD
 45968                                  ;	    MOV     DI,DX
 45969                                  ;	    OR	    AL,AL
 45970                                  ;	    JZ	    CRDROK
 45971                                  ;	    CMP     AL,3
 45972                                  ;	    JZ	    CRDFERR
 45973                                  ;	    POP     DS
 45974                                  ;	    JMP     ReadRawRetry
 45975                                  ;
 45976                                  ;   CRDFERR:
 45977                                  ;	    POP     DI				<- Patch 11
 45978                                  ;   DEVIOFERR:
 45979                                  ;	    LES     DI,[THISSFT]
 45980                                  ;	    jmp     SET_ACC_ERR_DS
 45981                                  ;
 45982                                  ;   CRDROK:
 45983                                  ;	    POP     DI				<- Patch 12
 45984                                  ;	    MOV     DI,DX
 45985                                  ;	    ADD     DI,[CALLSCNT]
 45986                                  ;	    JMP     SHORT ENDRDDEVJ3
 45987                                  
 45988                                  DOSP10_ID:		db	006H,01FH
 45989                                  DOSP10_LOC_OFFSET	equ	$-DOSP10_ID
 45990                                  DOSP10_LOC:		db	08BH,0DFH
 45991                                  DOSP10_REENT2_OFFSET	equ	$-DOSP10_LOC
 45992                                  			db	033H,0C0H,08BH,0D0H,0E8H
 45993                                  DOSP10_ID_LEN		equ	$-DOSP10_ID
 45994                                  			db	0DFH,00EH
 45995                                  DOSP10_REENT1_OFFSET	equ	$-DOSP10_LOC
 45996                                  			db	01EH,036H,0C5H,036H,036H,005H,0E8H,0AFH,00EH
 45997                                  			db	08BH,0D7H,0B4H,086H,036H,08BH,03EH
 45998                                  DOSP10_PACKVAL_OFFSET	equ	$-DOSP10_ID
 45999                                  			db	009H,003H
 46000                                  			db	0F7H,0C7H,000H,080H,074H,019H,0E8H,047H,017H
 46001                                  			db	08BH,0FAH,00AH,0C0H,074H,010H,03CH,003H,074H,003H
 46002                                  			db	01FH,0EBH,0CFH
 46003                                  DOSP11_LOC_OFFSET	equ	$-DOSP10_ID
 46004                                  			db	05FH
 46005                                  DOSP11_REENT_OFFSET	equ	$-DOSP10_LOC
 46006                                  			db	036H,0C4H,03EH,036H,005H,0E9H,0A1H,004H
 46007                                  
 46008                                  DOSP12_LOC_OFFSET	equ	$-DOSP10_ID
 46009                                  			db	05FH,08BH,0FAH
 46010                                  ; DOSDATA:1353h
 46011                                  
 46012                                  ; 13th DOS patch - Actually a SYSINIT patch. Patches the stack fault code
 46013                                  ;		which prints the fatal stack fault error on DOS >= 3.20.
 46014                                  ;
 46015                                  ;	    Sets focus to current VM so user can see fatal message.
 46016                                  ;
 46017                                  ;
 46018                                  ;	l0: lodsb		<- Setfocus here
 46019                                  ;	    cmp al, '$'
 46020                                  ;	    je l1
 46021                                  ;	    mov bl, 7
 46022                                  ;	    mov ah, 0Eh
 46023                                  ;	    int 10h
 46024                                  ;	    jmp l0
 46025                                  ;	l1: jmp $
 46026                                  
 46027                                  DOSP13_ID:	db	0ACh			; l0: lodsb
 46028                                  		db	03Ch,024h		;     cmp al, '$'
 46029                                  		db	074h,008h		;     je l1
 46030                                  		db	0B3h,007h		;     mov bl, 7
 46031                                  		db	0B4h,00Eh		;     mov ah, 0Eh
 46032                                  		db	0CDh,010h		;     int 10h
 46033                                  		db	0EBh,0F3h		;     jmp l0
 46034                                  		db	0EBh,0FEh		; l1: jmp $
 46035                                  DOSP13_ID_LEN	equ	$-DOSP13_ID
 46036                                  
 46037                                  ; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 46038                                  ; DOSDATA:1362h (MSDOS 5.0 MSDOS.SYS)
 46039                                  
 46040                                  ; 06/12/2022
 46041                                  ;DOSDATASIZE	equ  $ - DOSDATASTART ; 4962 bytes (1362h)
 46042                                  
 46043                                  ; DOSDATA ends
 46044                                  
 46045                                  ;============================================================================
 46046                                  ; MPATCH.ASM (MSDOS 6.0, 1993)
 46047                                  ;============================================================================
 46048                                  ; 27/04/2019 - Retro DOS 4.0
 46049                                  
 46050                                  ;mpatch.asm -- holds data patch location for callouts 
 46051                                  ; -- allocate cluster in rom.asm
 46052                                  ;
 46053                                  ; This area is pointed to by OffsetMagicPatch[609h] in fixed DOS data.
 46054                                  ; Currently, this location is used only by magicdrv.sys's patch to
 46055                                  ; cluster allocation, however it can be expanded to be used by other
 46056                                  ; patches. This is important since we have an easy-access pointer to
 46057                                  ; this location in OffsetMagicPatch. Magicdrv.sys is guaranteed to
 46058                                  ; only patch out a far call/retf, so any space after that could be
 46059                                  ; used as a patch by using OffsetMagicPatch+6. See rom.asm on how
 46060                                  ; to call out here.
 46061                                  ;
 46062                                  ; Currently, we allocate only the minimum space required for the 6
 46063                                  ; byte magicdrv patch, so if you change the dos data, you may want
 46064                                  ; to reserve space here if your new data will be position dependent
 46065                                  ; and would prohibit growing of this table.
 46066                                  ;       
 46067                                  ;history	-	created 8-7-92 by scottq
 46068                                  ;		-	added Rational386PatchPtr 2-1-93 by jimmat
 46069                                  ;
 46070                                  ;Exported Functions
 46071                                  ;==================
 46072                                  ;MagicPatch     -       callout patched by magidrv.sys for cluster allocations
 46073                                  
 46074                                  ; DosData Segment
 46075                                  
 46076                                  ; DOSDATA:1362h (MSDOS 6.21, MSDOS.SYS)
 46077                                  
 46078                                  ; ---------------------------------------------------------------------------
 46079                                  
 46080                                  ; Rational386PatchPtr points to either a RET instruction (80286 or less) or
 46081                                  ; a routine to fix buggy versions of the Rational DOS Extender (80386 or
 46082                                  ; greater). Added to this file because it needed to be somewhere and is
 46083                                  ; 'patch' related.
 46084                                  
 46085                                  Rational386PatchPtr:
 46086                                  	dw	0	; points to patch routine or RET instr.
 46087                                  ; ---------------------------------------------------------------------------
 46088                                  
 46089                                  MagicPatch:
 46090                                  ;MagicPatch proc far
 46091                                          retf            ;default is to just return to allocate
 46092                                          nop             ;however, this code will be patched
 46093                                          nop             ;by magicdrv.sys to
 46094                                          nop             ; call far ?:?     
 46095                                          nop             ; retf or perhaps just jmp far
 46096                                          nop             ;retf/nop take one byte, so we need six instructions
 46097                                                          ;for 6 byte patch
 46098                                  ;MagicPatch endp
 46099                                  
 46100                                  ; ---------------------------------------------------------------------------
 46101                                  
 46102                                  ;DosData Ends
 46103                                  
 46104                                  ; DOSDATA:136Ah
 46105                                  
 46106                                  ;----------------------------------------------------------------------------
 46107                                  
 46108                                  ;DOSDATALAST SEGMENT
 46109                                  
 46110                                  ; 29/04/2019 - Retro DOS v4.0
 46111                                  
 46112                                  ;----------------------------------------------------------------------------
 46113                                  ; 25/05/2019 - Retro DOS v4.0 Modification (paragraph alignment)
 46114                                  
 46115                                  ;db 0,1,12,64,19,0 ; ! Magic numbers !
 46116                                  
 46117                                  ;align 16
 46118                                  
 46119                                  ; !!! DOSDATA:1370h ; Retro DOS v4.0 only!
 46120                                  
 46121                                  ;----------------------------------------------------------------------------
 46122                                  
 46123                                  %endif	; 05/11/2022
 46124                                  
 46125                                  ; 05/12/2022
 46126                                  ;MSDAT001E:	; label byte
 46127                                  
 46128                                  ; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
 46129                                  DOSDATAEND equ $
 46130                                  DOSDATASIZE equ DOSDATAEND - DOSDATASTART ; = 4962 for MSDOS 5.0 MSDOS.SYS
 46131                                  MSDAT001E equ DOSDATAEND - DOSDATASTART
 46132                                  
 46133                                  ;DOSDATALAST ENDS
 46134                                  
 46135                                  ; Retro DOS v4.0 by Erdogan Tan (Redevelopment of MSDOS 5.0 KERNEL via NASM)
 46136                                  ; DECEMBER 2022, ISTANBUL - TURKIYE.
 46137                                  ;============================================================================
 46138                                  ;	END
 46139                                  ;============================================================================
 46140                                  ; Retro DOS v4.0 by Erdogan Tan (Redevelopment of MSDOS 6.21 KERNEL via NASM)
 46141                                  ; -----------------------------
 46142                                  ; MAY 2019, ISTANBUL - TURKIYE.
