     1                                  ; ****************************************************************************
     2                                  ; RD4LOAD.S (Retro DOS v4 KERNEL LOADER) -IO.SYS- by ERDOGAN TAN - 22/12/2022
     3                                  ; ----------------------------------------------------------------------------
     4                                  ; Last Update: 07/10/2023 (Modified IO.SYS loader) ((Previous: 15/09/2023))
     5                                  ; ----------------------------------------------------------------------------
     6                                  ; Beginning: 22/12/2022 (Retro DOS 4.0 Kernel Loader, Fake IO.SYS)
     7                                  ; ----------------------------------------------------------------------------
     8                                  ; Assembler: NASM version 2.15
     9                                  ; ----------------------------------------------------------------------------
    10                                  ;	   ((nasm rd4load.s -l rd4load.txt -o IO.SYS -Z error.txt)) 
    11                                  ; ----------------------------------------------------------------------------
    12                                  ; Derived from disassembled MSLOAD code of MSDOS 5.0 IO.SYS by Erdogan Tan 
    13                                  ; (Disassembly: 18/09/2022, NASM source: 21/10/2022, Last update: 22/12/2022) 
    14                                  ; ----------------------------------------------------------------------------
    15                                  
    16                                  ; +-------------------------------------------------------------------------+
    17                                  ; |   This file	has been generated by The Interactive Disassembler (IDA)    |
    18                                  ; |	      Copyright	(c) 2013 Hex-Rays, <support@hex-rays.com>	    |
    19                                  ; |			 Licensed to: Freeware version			    |
    20                                  ; +-------------------------------------------------------------------------+
    21                                  ;
    22                                  ; Input	MD5   :	B2FA03653E5C5D545327EE28B8A24356
    23                                  ; Input	CRC32 :	20FC79BF
    24                                  
    25                                  ; ---------------------------------------------------------------------------
    26                                  ; File Name   :	C:\Users\Erdoðan\Desktop\IO.SYS
    27                                  ; Format      :	Binary file
    28                                  ; Base Address:	0000h Range: 0000h - 8296h Loaded length: 00008296h
    29                                  
    30                                  ;		.386
    31                                  ;		.model flat
    32                                  
    33                                  ; ===========================================================================
    34                                  
    35                                  ; 09/12/2022
    36                                  ; Comments are from MSDOS 6.0 MSLOAD.ASM (1991) & HEX-RAYS IDA disasm output
    37                                  
    38                                  ; ===========================================================================
    39                                  ;	NOTE: The boot loader should be verifying that the first
    40                                  ;	  block of io.sys is, in fact, at cluster 2. This would be saving
    41                                  ;	  a whole lot of time during system debugging.
    42                                  ;
    43                                  ;============================================================================
    44                                  ;
    45                                  ;     for dos 4.00, msload program has been changed to allow:
    46                                  ;	  1. 32 bit calculation,
    47                                  ;	  2. reading a fat sector when needed, instead of reading the whole
    48                                  ;	     fat sectors at once. this will make the boot time faster,
    49                                  ;	     and eliminate the memory size limitation problem,
    50                                  ;	  3. solving the limitation of the file size (29 kb) of io.sys,
    51                                  ;	  4. adding the boot error message. show the same boot error message
    52                                  ;	     and do the same behavior when the read operation of io.sys
    53                                  ;	     fails as the msboot program, since msload program is the
    54                                  ;	     extention of msboot program.
    55                                  ;
    56                                  ; ===========================================================================
    57                                  
    58                                  ;----------------------------------------------------------------------------
    59                                  		[ORG 0]			; segment 0x0070h
    60                                  ;----------------------------------------------------------------------------
    61                                  
    62                                  START$:
    63 00000000 EB30                    		jmp	short SaveInputValues ; 14/09/2023
    64                                  		;nop	; 14/09/2023
    65                                  
    66                                  ; 14/09/2023
    67                                  ; 24/12/2022
    68                                  ; 23/12/2022
    69                                  ; 20/12/2022
    70                                  ; 09/12/2022
    71                                  ; ---------------------------------------------------------------------------
    72 00000002 0500                    SysVersion:	dw 5			; expected_version
    73                                  		; 06/10/2023
    74                                  ;ClusterSize:	dw 0
    75 00000004 0000                    StartSecL:	dw 0
    76 00000006 0000                    StartSecH:	dw 0
    77                                  ; 15/09/2023
    78                                  ;TempH:		dw 0			; for 32 bit calculation
    79                                  ;TempCluster:	dw 0
    80                                  ;ReservSectors:	dw 0
    81 00000008 FFFF                    LastFatSector:	dw 0FFFFh		; fat sec # start from 1st FAT entry
    82 0000000A 0000                    SectorCount:	dw 0
    83 0000000C 0000                    CurrentCluster:	dw 0	; *!*
    84 0000000E 0000                    BytesPerSec:	dw 0
    85 00000010 0000                    SecPerCluster:	dw 0
    86                                  ;RootDirEntries: dw 0
    87 00000012 0000                    SecPerFat:	dw 0
    88 00000014 0000                    SecPerTrack:	dw 0
    89 00000016 0000                    NumHeads:	dw 0
    90                                  ; 14/09/2023
    91 00000018 0000                    HiddenSectorsL: dw 0
    92 0000001A 0000                    HiddenSectorsH: dw 0
    93 0000001C 0000                    TotalSectorsL:	dw 0			; max. number of sectors
    94 0000001E 0000                    TotalSectorsH:	dw 0
    95 00000020 0000                    FirstSectorL:	dw 0
    96 00000022 0000                    FirstSectorH:	dw 0
    97 00000024 00                      BootDrive:	db 0
    98 00000025 00                      Fatsize:	db 0
    99 00000026 00                      MediaByte:	db 0
   100 00000027 00                      EndOfFile:	db 0
   101 00000028 00000000                OrgDasdPtr:	dd 0
   102 0000002C 0000                    FatStartSecL:	dw 0
   103 0000002E 0000                    FatStartSecH:	dw 0
   104 00000030 0000                    FatSegment:	dw 0
   105                                  
   106                                  ; ---------------------------------------------------------------------------
   107                                  
   108                                  ; SaveInputValues
   109                                  ; ---------------------------------------------------------------------------
   110                                  ; INPUT:     none
   111                                  ;
   112                                  ;   dl = int 13 drive number we booted from
   113                                  ;   ch = media byte
   114                                  ;   bx = first data sector (low) on disk (0-based)
   115                                  ;   ds:si = original rom bios diskette parameter table.
   116                                  ;
   117                                  ; if an extended boot record, then ax will be the first data sector
   118                                  ; high word. save ax and set FirstSectorH according to ax if it is an
   119                                  ; extended boot record.
   120                                  ;
   121                                  ;   ax = first data sector (high) on disk ;
   122                                  ; OUTPUT:
   123                                  ;
   124                                  ;   bx = first data sector on disk
   125                                  ;
   126                                  ;   MediaByte = input ch
   127                                  ;   BootDrive = input dl
   128                                  ;   FirstSectorL = input bx
   129                                  ;   FirstSectorH = input AX, if an extended boot record.;j.k.
   130                                  ;   TotalSectorsL = maximum sector number in this media ;j.k.
   131                                  ;   TotalSectorsH = high word of the above
   132                                  ;   HiddenSectorsL = hidden secotrs
   133                                  ;   HiddenSectorsH
   134                                  ;   ReservSectors = reserved sectors
   135                                  ;   SecPerTrack = sectors/track
   136                                  ;   NumHeads = heads/cylinder
   137                                  ;
   138                                  ;   ds = 0
   139                                  ;   AX,DX,SI destroyed
   140                                  ;
   141                                  ; calls:     none
   142                                  ; ---------------------------------------------------------------------------
   143                                  ;FUNCTION:
   144                                  ; save input information and bpb informations from the boot record.
   145                                  ; ---------------------------------------------------------------------------
   146                                  
   147                                  Sec9 equ 522h
   148                                  ; 20/12/2022	
   149                                  DskAddr	equ 1Eh*4 ; 78h
   150                                  ; 22/12/2022
   151                                  ;StackPtr equ MyStacks+(NumHeads-MyStacks)
   152                                  
   153                                  ; 24/12/2022
   154                                  ; 22/12/2022
   155                                  KernelFirstClustr equ 53Ah	; The 1st cluster address of 'MSDOS.SYS' file
   156                                  				; in the root directory entry.
   157                                  
   158                                  ; ---------------------------------------------------------------------------
   159                                  
   160                                  		; 23/12/2022
   161                                  		; (registers from MSDOS 5.0 boot sector)
   162                                  		; ss = 0
   163                                  		; sp = 7C00h
   164                                  		; ds = 0
   165                                  		; es = 0
   166                                  		; ax:bx = absolute disk address for cluster 2 (data start)
   167                                  		; dl = [BootDrv] = [7C24h]
   168                                  		; ch = [MediaByte] = [7C15h]
   169                                  		; ds:si = rom bios disk(ette) params table address (INT 1Eh)
   170                                  		; 0:500h = root dir buffer (1st sector of the root dir)
   171                                  
   172                                  		; 14/09/2023
   173                                  SaveInputValues:
   174                                  		; 24/12/2022
   175 00000032 1E                      		push	ds
   176 00000033 0E                      		push	cs
   177 00000034 1F                      		pop	ds 
   178                                  		;mov	[cs:FirstSectorL], bx ; first data sector (low word)
   179                                  		;mov	[cs:MediaByte], ch
   180                                  		;mov	[cs:BootDrive], dl
   181                                  		;mov	[cs:OrgDasdPtr], si
   182                                  		;push	ds
   183                                  		;pop	word [cs:OrgDasdPtr+2]
   184 00000035 891E[2000]              		mov	[FirstSectorL], bx
   185 00000039 891E[0400]              		mov	[StartSecL], bx ; **!**
   186 0000003D 882E[2600]              		mov	[MediaByte], ch
   187 00000041 8816[2400]              		mov	[BootDrive], dl
   188 00000045 8936[2800]              		mov	[OrgDasdPtr], si
   189 00000049 8F06[2A00]              		pop	word [OrgDasdPtr+2]
   190                                  	
   191 0000004D 31C9                    		xor	cx, cx		; segment 0 (obviously)
   192 0000004F 8ED9                    		mov	ds, cx		; ZERO
   193                                  		; 23/12/2022
   194                                  		; es = 0 (just before jumping to start of IO.SYS) 
   195                                  		;push	es ; !
   196                                  		;mov	es, cx
   197                                  		; es = 0
   198                                  		;mov	si, [DskAddr]	; 0000h:0078h (Int 1Eh)
   199                                  		;mov	ds, [DskAddr+2]	; DS:SI -> current table
   200                                  		; 20/12/2022
   201 00000051 BE2205                  		mov	si, Sec9
   202 00000054 89F7                    		mov	di, si
   203 00000056 87367800                		xchg	si, [DskAddr]
   204 0000005A 870E7A00                		xchg	cx, [DskAddr+2]
   205 0000005E 8ED9                    		mov	ds, cx
   206                                  		;mov	di, Sec9	; 522h  ; ES:DI -> new table
   207 00000060 B90B00                  		mov	cx, 11			; taken from ibmboot.asm
   208 00000063 FC                      		cld
   209 00000064 F3A4                    		rep movsb		; copy table
   210                                  		;push	es
   211                                  		;pop	ds		; ds = 0
   212                                  		; 20/12/2022
   213 00000066 8ED9                    		mov	ds, cx ; 0
   214                                  		;mov	word [DskAddr], Sec9 ; 522h
   215                                  		;mov	[DskAddr+2], ds	; point disk parm vector to new table
   216                                  		; 23/12/2022
   217                                  		;pop	es ; !
   218                                  		; es = 0
   219                                  		; ds = 0
   220                                  		; ss = 0
   221                                  ; 24/12/2022
   222                                  %if 0
   223                                  		mov	cx, [7C0Bh] 	; BootSector.ext_boot_bpb.BPB_bytespersector
   224                                  		mov	[cs:BytesPerSec], cx
   225                                  		mov	cl, [7C0Dh]	; BootSector.ext_boot_bpb.BPB_sectorspercluster
   226                                  		mov	[cs:SecPerCluster], cl
   227                                  		mov	cx, [7C18h]	; BootSector.ext_boot_bpb.BPB_sectorspertrack	
   228                                  		mov	[cs:SecPerTrack], cx
   229                                  		mov	cx, [7C1Ah]	; BootSector.ext_boot_bpb.BPB_heads
   230                                  		mov	[cs:NumHeads], cx
   231                                  		mov	cx, [7C16h]	; BootSector.ext_boot_bpb.BPB_sectorsperfat
   232                                  		mov	[cs:SecPerFat], cx
   233                                  		mov	cx, [7C0Eh]	; BootSector.ext_boot_bpb.BPB_reservedsectors	
   234                                  		mov	[cs:ReservSectors], cx
   235                                  		mov	cx, [7C1Ch]	; BootSector.ext_boot_bpb.BPB_hiddensectors
   236                                  		mov	[cs:HiddenSectorsL], cx
   237                                  		mov	cx, [7C13h]	; BootSector.ext_boot_bpb.BPB_totalsectors
   238                                  		mov	[cs:TotalSectorsL], cx
   239                                  
   240                                  		; First of all, check if it the boot record is an extended one.
   241                                  		; This is just a safe guard in case some user just "copy" the
   242                                  		; 4.00 iosys.com to a media with a conventional boot record.
   243                                  
   244                                  		; 22/12/2022
   245                                  		cmp	byte [7C26h], 29h ; ext_boot_signature
   246                                  		jne	short relocate
   247                                  		mov	[cs:FirstSectorH], ax ; first data sector (high word)
   248                                  		mov	ax, [7C1Eh]
   249                                  		mov	[cs:HiddenSectorsH], ax
   250                                  		; 10/12/2022
   251                                  		or	cx, cx
   252                                  		;cmp	cx, 0		; cx set already before (=totalsectors)
   253                                  		; 22/12/2022
   254                                  		jnz	short relocate
   255                                  		mov	ax, [7C20h]	; BootSector.ext_boot_bpb.BPB_bigtotalsectors
   256                                  		mov	[cs:TotalSectorsL], ax
   257                                  		mov	ax, [7C22h]	; BootSector.ext_boot_bpb.BPB_bigtotalsectors+2
   258                                  		mov	[cs:TotalSectorsH], ax
   259                                  %endif
   260                                  		; 14/09/2023
   261 00000068 89C5                    		mov	bp, ax  ; first data sector (high word)
   262                                  		
   263 0000006A 0E                      		push	cs
   264 0000006B 07                      		pop	es
   265                                  
   266                                  		; get the 1st cluster of MSDOS.SYS 
   267 0000006C A13A05                  		mov	ax, [KernelFirstClustr] ; [053Ah]
   268 0000006F BF[0C00]                		mov	di, CurrentCluster  
   269 00000072 AB                      		stosw	 ; *!* ; Initialize CurrentCluster to this cluster
   270                                  		; di = offset BytesPerSec 
   271                                  		
   272 00000073 BE0B7C                  		mov	si, 07C0Bh	; boot sector's bpb, BytesPerSector
   273                                  		;mov	di, BytesPerSec
   274 00000076 A5                      		movsw	; BytesPerSec
   275 00000077 A4                      		movsb	; SecPerCluster
   276 00000078 47                      		inc	di ; skip high byte of SecPerCluster word (it is 0)
   277 00000079 AD                      		lodsw	; ReservSectors
   278 0000007A 50                      		push	ax ; * ; ReservSectors
   279 0000007B AC                      		lodsb	; skip NumFats
   280                                  		;movsw	; RootDirEntries ; !
   281 0000007C AD                      		lodsw	; skip RootDirEntries ; !
   282 0000007D AD                      		lodsw	; TotalSectorsL
   283                                  		; 14/09/2023
   284 0000007E 50                      		push	ax ; ** ; TotalSectorsL
   285 0000007F AC                      		lodsb	; skip MediaByte
   286 00000080 A5                      		movsw	; SecPerFat
   287 00000081 A5                      		movsw 	; SecPerTrack
   288 00000082 A5                      		movsw	; NumHeads
   289 00000083 A5                      		movsw	; HiddenSectorsL
   290 00000084 AD                      		lodsw	; HiddenSectorsH
   291 00000085 89C2                    		mov	dx, ax ; HiddenSectorsH in dx
   292 00000087 AD                      		lodsw	
   293 00000088 89C1                    		mov	cx, ax ; BigTotalSecs lw in cx
   294 0000008A AD                      		lodsw
   295 0000008B 89C3                    		mov	bx, ax ; BigTotalSecs hw in bx
   296 0000008D AD                      		lodsw	; skip BootDrv and CurrentHead
   297                                   
   298                                  		; 14/09/2023
   299 0000008E AC                      		lodsb	; ext_boot_signature
   300                                  
   301 0000008F 0E                      		push	cs
   302 00000090 1F                      		pop	ds
   303                                  
   304 00000091 3C29                    		cmp	al, 29h  ; is it ext_boot_signature ?
   305 00000093 58                      		pop	ax ; ** ; TotalSectorsL (16 bit total sectors)
   306 00000094 7407                    		je	short ext_boot_sec_1 ; yes, use high words
   307                                  
   308                                  		; (old boot sector ?)
   309                                  		; (zero high words, do not use them)
   310 00000096 47                      		inc	di ; skip HiddenSectorsH (it is already zero)	
   311 00000097 47                      		inc	di
   312 00000098 AB                      		stosw	; TotalSectorsL
   313                                  			; (TotalSectorsH = 0)
   314 00000099 31D2                    		xor	dx, dx ; 0 ; HiddenSectorsH
   315 0000009B EB15                    		jmp	short set_fat_start
   316                                  ext_boot_sec_1:
   317                                  		; 14/09/2023
   318 0000009D 92                      		xchg	ax, dx
   319 0000009E AB                      		stosw	; HiddenSectorsH
   320 0000009F 92                      		xchg	dx, ax
   321                                  			; dx = HiddenSectorsH, ax = TotalSectorsL
   322                                  		; 24/12/2022
   323 000000A0 09C0                    		or	ax, ax  ; TotalSectorsL (16 bit total sectors)
   324 000000A2 7505                    		jnz	short ext_boot_sec_2 ; (*)
   325                                  
   326                                  		; 14/09/2023
   327                                  		; (32 bit total sectors)
   328 000000A4 89C8                    		mov	ax, cx ; BigTotalSecs lw 
   329 000000A6 AB                      		stosw	; TotalSectorsL	
   330 000000A7 89D8                    		mov	ax, bx ; BigTotalSecs hw
   331                                  ext_boot_sec_2:
   332 000000A9 AB                      		stosw	; TotalSectorsH or TotalSectorsL (*)
   333                                  		; bp = 1st data sector hw
   334 000000AA 892E[2200]              		mov	[FirstSectorH], bp
   335 000000AE 892E[0600]              		mov	[StartSecH], bp ; **!**	
   336                                  
   337                                  set_fat_start:
   338                                  		; 14/09/2023
   339 000000B2 31FF                    		xor	di, di
   340 000000B4 58                      		pop	ax ; * ReservSectors 
   341 000000B5 0306[1800]              		add	ax, [HiddenSectorsL]
   342                                  		; dx = [HiddenSectorsH]
   343                                  		;adc	dx, 0
   344 000000B9 11FA                    		adc	dx, di ; 0
   345                                  
   346                                  		;mov	di, FatStartSecL
   347                                  		;stosw
   348                                  		;mov	ax, dx
   349                                  		;stosw		
   350                                  
   351 000000BB A3[2C00]                		mov	[FatStartSecL], ax
   352 000000BE 8916[2E00]              		mov	[FatStartSecH], dx
   353                                  		
   354                                  ; --------------------------------------------------------------------------- 
   355                                  
   356                                  relocate:
   357                                  		; 23/12/2022
   358                                  		; (set fat buffer segment at the end of loader)
   359                                  
   360                                  		FATBUFSEGM equ 70h+(((EndOfLoader-START$)+15)>>4)
   361                                  						 ; paragraph alignment
   362                                  		
   363                                  		; 24/12/2022
   364                                  		;mov	word [cs:FatSegment], FATBUFSEGM
   365                                  		FATSEGMENT equ FATBUFSEGM
   366                                  
   367                                  		; 24/12/2022
   368                                  		; ds = cs
   369                                  
   370                                  ; ---------------------------------------------------------------------------
   371                                  SetupStack:	
   372                                  		; 22/12/2022
   373                                  		;cli
   374                                  		;xor	ax, ax
   375                                  		;mov	ss, ax
   376                                  		;mov	sp, 700h
   377                                  		;sti
   378                                  
   379                                  ; ---------------------------------------------------------------------------
   380                                  ; 23/12/2022
   381                                  ; Write loading message
   382                                  		
   383                                  		; 24/12/2022	
   384                                  		;push	cs
   385                                  		;pop	ds
   386 000000C2 BE[1003]                		mov	si, loading_msg
   387 000000C5 E85001                  		call	WriteTTY
   388                                  
   389                                  ; FindClusterSize
   390                                  ; ---------------------------------------------------------------------------
   391                                  ;
   392                                  ; INPUT:     bpb information in loaded boot record at 0:7c00h
   393                                  ;
   394                                  ; OUTPUT:
   395                                  ;
   396                                  ;	ds = 0
   397                                  ;	ax = bytes/cluster
   398                                  ;	bx = sectors/cluster
   399                                  ;	si destroyed
   400                                  ; calls:     none
   401                                  ;----------------------------------------------------------------------------
   402                                  ;
   403                                  ; get bytes/sector from bpb
   404                                  ;
   405                                  ; get sectors/cluster from bpb
   406                                  ;
   407                                  ; bytes/cluster = bytes/sector * sector/cluster
   408                                  ; ---------------------------------------------------------------------------
   409                                  
   410                                  FindClusterSize:
   411                                  
   412                                  ;for the time being just ASSUME the boot record is valid and the bpb is there.
   413                                  
   414                                  ; 06/10/2023
   415                                  %if 0
   416                                  		; 24/12/2022
   417                                  		; ds = cs
   418                                  		;xor	ax, ax
   419                                  		;mov	ds, ax
   420                                  		;mov	ax, [7C0Bh]	; get bpb bytes/sector
   421                                  		; 24/12/2022
   422                                  		mov	ax, [BytesPerSec]
   423                                  		;xor	bx, bx
   424                                  		;mov	bl, [7C0Dh]	; get sectors/cluster
   425                                  		;mul	bx
   426                                  		mul	word [SecPerCluster]
   427                                  		;mov	[cs:ClusterSize], ax
   428                                  		; 24/12/2022
   429                                  		mov	[ClusterSize], ax
   430                                  %endif
   431                                  
   432                                  ; CalcFatSize
   433                                  ; ---------------------------------------------------------------------------
   434                                  ;
   435                                  ; NOTES:
   436                                  ;
   437                                  ;   Determine if fat is 12 or 16 bit fat. 12 bit fat if floppy, read mbr
   438                                  ;   to find out what system id byte is.
   439                                  ;
   440                                  ; INPUT:
   441                                  ;
   442                                  ; OUTPUT:
   443                                  ;
   444                                  ;   CS:FatSize = FAT_12_BIT or FAT_16_BIT
   445                                  ;   all other registers destroyed
   446                                  ;
   447                                  ; ---------------------------------------------------------------------------
   448                                  
   449                                  CalcFatSize:
   450                                  		; 24/12/2022
   451                                  		; ds = cs
   452 000000C8 C606[2500]01            		mov	byte [Fatsize], 1
   453                                  		;mov	byte [cs:Fatsize], 1 ; FAT_12_BIT (assume)
   454                                  		;mov	dx, [cs:TotalSectorsH]
   455                                  		;mov	ax, [cs:TotalSectorsL] ; DX:AX = total disk sectors
   456 000000CD 8B16[1E00]              		mov	dx, [TotalSectorsH]
   457 000000D1 A1[1C00]                		mov	ax, [TotalSectorsL] ; DX:AX = total disk sectors
   458                                  		;;;		
   459                                  ; 24/12/2202
   460                                  %if 0
   461                                  		sub	ax, [ReservSectors]
   462                                  		;sub	ax, [cs:ReservSectors]
   463                                  		sbb	dx, 0		; DX:AX	= Total	avail sectors
   464                                  		;mov	bx, [cs:SecPerFat]
   465                                  		mov	bx, [SecPerFat]
   466                                  		shl	bx, 1		; (Assume 2 FATs)
   467                                  		sub	ax, bx
   468                                  		sbb	dx, 0
   469                                  		;mov	bx, [7C11h]	; Root directory entry count
   470                                  		mov	bx, [RootDirEntries]
   471                                  		mov	cl, 4
   472                                  		shr	bx, cl		; BX = Total directory sectors
   473                                  		sub	ax, bx
   474                                  		sbb	dx, 0		; DX:AX	= Sectors in data area
   475                                  %endif
   476                                  		; 14/09/2023 (BugFix)
   477 000000D4 8B1E[2000]              		mov	bx, [FirstSectorL]
   478 000000D8 8B0E[2200]              		mov	cx, [FirstSectorH]
   479                                  		; ! here, cx:bx includes hidden sectors (partition start address) !
   480 000000DC 2B1E[1800]              		sub	bx, [HiddenSectorsL]
   481 000000E0 1B0E[1A00]              		sbb	cx, [HiddenSectorsH] ; cx:bx = start of data from boot sector
   482                                  
   483                                  		; 24/12/2022
   484                                  		;sub	ax, [FirstSectorL] ; total sectors - start of data
   485                                  		;sbb	dx, [FirstSectorH]
   486                                  		; 14/09/2023
   487 000000E4 29D8                    		sub	ax, bx
   488 000000E6 19CA                    		sbb	dx, cx
   489                                  				; DX:AX	= Sectors in data area
   490                                  		;;;
   491                                  		;xor	cx, cx
   492                                  		;mov	cl, [7C0Dh]	; Sectors per cluster
   493 000000E8 8B0E[1000]              		mov	cx, [SecPerCluster] ; *#*
   494 000000EC 50                      		push	ax
   495 000000ED 89D0                    		mov	ax, dx
   496 000000EF 31D2                    		xor	dx, dx
   497 000000F1 F7F1                    		div	cx  ; *#*
   498                                  		; 24/12/2022
   499                                  		;;mov	[cs:TempH], ax	; AX = Total number of clusters
   500                                  		;mov	[TempH], ax
   501 000000F3 58                      		pop	ax
   502 000000F4 F7F1                    		div	cx  ; *#*
   503 000000F6 3DF60F                  		cmp	ax, 4086	; 4096-10
   504 000000F9 7205                    		jb	short ReadInFirstCluster ; 12 bit FAT
   505                                  		;mov	byte [cs:Fatsize], 4 ; FAT_16_BIT
   506 000000FB C606[2500]04            		mov	byte [Fatsize], 4 ; FAT_16_BIT
   507                                  
   508                                  ; 22/12/2022
   509                                  ;----------------------------------------------------------------------------
   510                                  ; HERE IS DIFFERENT THAN IO.SYS LOADER (MSLOAD)
   511                                  ; FOLLOWING CODE HAS BEEN MODIFIED FOR LOADING RETRO DOS KERNEL (MSDOS.SYS)
   512                                  ;----------------------------------------------------------------------------
   513                                  
   514                                  ; 22/12/2022
   515                                  
   516                                  KernelInitSegment equ 1000h	; Address where the kernel will be loaded
   517                                  
   518                                  ; ---------------------------------------------------------------------------
   519                                  
   520                                  		; 06/10/2023
   521                                  		; 23/12/2022
   522                                  		; 22/12/2022
   523                                  ReadInFirstCluster:
   524                                  		; 24/12/2022
   525                                  		;;mov	ax, [53Ah]
   526                                  		;mov	ax, [ss:KernelFirstClustr] ; [ss:053Ah] 
   527                                  		;; 23/12/2022
   528                                  		;;mov	[cs:CurrentCluster], ax ; Initialize to this cluster
   529                                  		; 24/12/2022
   530                                  		; ds = cs
   531                                  		;mov	[CurrentCluster], ax
   532                                  
   533                                  		; 24/12/2022
   534                                  		; [currentCluster] = the 1st cluster of MSDOS.SYS ; *!*
   535 00000100 A1[0C00]                		mov	ax, [CurrentCluster]
   536                                  					; MSDOS.SYS First Cluster
   537 00000103 48                      		dec	ax		; Root dir buffer at 500h (segment=0)
   538                                  					; MSDOS.SYS first cluster ptr at 53Ah
   539 00000104 48                      		dec	ax		; AX = word [53Ah] - 2
   540                                  
   541                                  ; 24/12/2022
   542                                  %if 0
   543                                  		mov	cx, [cs:FirstSectorL] ;	Put starting sector of disk data
   544                                  		mov	[cs:StartSecL], cx    ; area in StartSecH:StartSecL
   545                                  		mov	cx, [cs:FirstSectorH]
   546                                  		mov	[cs:StartSecH], cx
   547                                  		xor	cx, cx
   548                                  		mov	cl, [cs:SecPerCluster]
   549                                  		mul	cx		; DX:AX = logical start sector
   550                                  		add	[cs:StartSecL], ax
   551                                  		adc	[cs:StartSecH], dx
   552                                  					; abs start sector for next read of
   553                                  					; the rest of the last loader cluster
   554                                  %endif
   555                                  		; 24/12/2022
   556                                  		; ds = cs
   557                                  		;mov	cx, [FirstSectorL] ; Put starting sector of disk data
   558                                  		;mov	[StartSecL], cx	   ; area in StartSecH:StartSecL
   559                                  		;mov	cx, [FirstSectorH]
   560                                  		;mov	[StartSecH], cx
   561                                  		; [StartSecL] = [FirstSectorL] ; **!**
   562                                  		; [StartSecH] = [FirstSectorH] ; **!**
   563                                  
   564                                  		; ax = cluster index (cluster number - 2)
   565                                  
   566                                  		;;xor	cx, cx
   567                                  		;;mov	cl, [SecPerCluster]
   568                                  		;mov	cx, [SecPerCluster] ; ch = 0
   569                                  		; cx = [SecPerCluster]  ; *#* ; 24/12/2022
   570 00000105 F7E1                    		mul	cx		; DX:AX = logical start sector
   571                                  		; 24/12/2022
   572 00000107 0106[0400]              		add	[StartSecL], ax
   573 0000010B 1116[0600]              		adc	[StartSecH], dx
   574                                  					; abs start sector for next read of
   575                                  					; the rest of the last loader cluster
   576                                  		; 22/12/2022
   577 0000010F BF0010                  		mov	di, KernelInitSegment
   578                                  		;mov	di, 1000h	; MSDOS.SYS initial (loading) segment
   579 00000112 8EC7                    		mov	es, di
   580 00000114 31FF                    		xor	di, di		; 1000h:0000h
   581                                  		; 24/12/2022
   582                                  		; cx = [SecPerCluster]
   583                                  		;mov	ax, [SecPerCluster]
   584                                  		;;sub	ax, ax
   585                                  		;;mov	al, [SecPerCluster]
   586                                  		
   587                                  		; 06/10/2023
   588                                  		;mov	ax, cx
   589                                  		;			; Read in the entire last cluster
   590                                  		;mov	[SectorCount], ax ; ah = 0
   591 00000116 890E[0A00]              		mov	[SectorCount], cx ; cx = [SecPerCluster], ch = 0
   592                                  
   593 0000011A E84A00                  		call	ReadSectors
   594                                  
   595                                  		; 22/12/2022
   596                                  		;mov	[cs:NextBioLocation], di
   597                                  
   598                                  ; GetContigClusters
   599                                  ; ---------------------------------------------------------------------------
   600                                  ;
   601                                  ; NOTES: go find clusters as long as they are contiguous
   602                                  ;
   603                                  ;
   604                                  ; INPUT:
   605                                  ;   CS:NextBioLocation
   606                                  ;   CS:
   607                                  ;
   608                                  ; OUTPUT:
   609                                  ;
   610                                  ; calls: GetNextFatEntry
   611                                  ; ---------------------------------------------------------------------------
   612                                  ;
   613                                  ;Set CS:SectorCount to sectors per cluster
   614                                  ;
   615                                  ;Call GetNextFatEntry to get next cluster in file
   616                                  ;
   617                                  ;Call check_for_eof
   618                                  ;
   619                                  ;if (nc returned)
   620                                  ;
   621                                  ;   {call GetNextFatEntry
   622                                  ;
   623                                  ;    if (new cluster is contig to old cluster)
   624                                  ;	{add sectors per cluster to CS:SectorCount
   625                                  ;
   626                                  ;	 call check_for_eof
   627                                  ;
   628                                  ;	 if (nc returned)
   629                                  ;
   630                                  ; ---------------------------------------------------------------------------
   631                                  
   632                                  ; 09/12/2022
   633                                  ; END_OF_FILE equ 0FFh
   634                                  ; DosLoadSeg equ 70h
   635                                  
   636                                  		; 24/12/2022
   637                                  GetContigClusters:
   638                                  
   639                                  ; 24/12/2022
   640                                  %if 0			
   641                                  		xor	ah, ah
   642                                  		mov	al, [cs:SecPerCluster]	; Assume we will get one cluster
   643                                  		mov	[cs:SectorCount], ax	; Sector count = sectors in 1 cluster
   644                                  		push	word [cs:SectorCount]
   645                                  		call	GetNextFatEntry		; Returns next cluster to read in AX	
   646                                  		pop	word [cs:SectorCount]
   647                                  		mov	[cs:CurrentCluster], ax ; Update the last one found
   648                                  		cmp	byte [cs:EndOfFile], 0FFh ; END_OF_FILE
   649                                  		je	short GoToBioInit ; 23/12/2022
   650                                  		; 22/12/2022
   651                                  		;xor	dx, dx ; * (not required)
   652                                  		; 10/12/2022
   653                                  		;sub	ax, 2			; Zero base the cluster
   654                                  		dec	ax
   655                                  		dec	ax
   656                                  		xor	ch, ch
   657                                  		mov	cl, [cs:SecPerCluster]
   658                                  		mul	cx ; *			; How many sectors (before next cluster) 
   659                                  		add	ax, [cs:FirstSectorL]	; See where the data sector starts
   660                                  		adc	dx, [cs:FirstSectorH]
   661                                  		mov	[cs:StartSecL], ax	; Save it (used by ReadSectors)
   662                                  		mov	[cs:StartSecH], dx
   663                                  		; 22/12/2022
   664                                  		;mov	di, [cs:NextBioLocation] ; Get where to put code
   665                                  		;push	word [cs:SectorCount]	; Save how many sectors
   666                                  		call	ReadSectors
   667                                  		;pop	ax			; Get back total sectors read in
   668                                  		;mul	word [cs:BytesPerSec]	; Get number of bytes we loaded
   669                                  		;add	[cs:NextBioLocation], ax ; Point to where to load next	
   670                                  		jmp	short GetContigClusters
   671                                  
   672                                  %endif
   673                                  		; 24/12/2022
   674                                  		; ds = cs
   675                                  
   676 0000011D A1[1000]                		mov	ax, [SecPerCluster]	; Assume we will get one cluster
   677 00000120 A3[0A00]                		mov	[SectorCount], ax	; Sector count = sectors in 1 cluster
   678                                  		;push	word [SectorCount]
   679 00000123 50                      		push	ax
   680 00000124 E8FE00                  		call	GetNextFatEntry		; Returns next cluster to read in AX	
   681 00000127 8F06[0A00]              		pop	word [SectorCount]
   682 0000012B A3[0C00]                		mov	[CurrentCluster], ax	; Update the last one found
   683                                  
   684 0000012E 803E[2700]FF            		cmp	byte [EndOfFile], 0FFh	; END_OF_FILE
   685 00000133 741A                    		je	short GoToBioInit ; 23/12/2022
   686                                  		; 22/12/2022
   687                                  		;xor	dx, dx ; * (not required)
   688                                  		; 10/12/2022
   689                                  		;sub	ax, 2			; Zero base the cluster
   690 00000135 48                      		dec	ax
   691 00000136 48                      		dec	ax
   692                                  		; 24/12/2022
   693                                  		; ax = cluster index
   694                                  		;mov	cx, [SecPerCluster]
   695                                  		;mul	cx ; *			; How many sectors (before next cluster) 
   696 00000137 F726[1000]              		mul	word [SecPerCluster]
   697 0000013B 0306[2000]              		add	ax, [FirstSectorL]	; See where the data sector starts
   698 0000013F 1316[2200]              		adc	dx, [FirstSectorH]
   699 00000143 A3[0400]                		mov	[StartSecL], ax		; Save it (used by ReadSectors)
   700 00000146 8916[0600]              		mov	[StartSecH], dx
   701                                  			
   702 0000014A E81A00                  		call	ReadSectors
   703                                  				; ES:DI = (the next) buffer address for next read
   704                                  		
   705 0000014D EBCE                    		jmp	short GetContigClusters
   706                                  
   707                                  ; ---------------------------------------------------------------------------
   708                                  
   709                                  ; GoToBioInit
   710                                  ; ---------------------------------------------------------------------------
   711                                  ;
   712                                  ; NOTES:
   713                                  ;
   714                                  ;  Set up required registers for iosys, then jump to it (70:0)
   715                                  ;
   716                                  ; INPUT:     none
   717                                  ;
   718                                  ;   CS:MediaByte = media byte
   719                                  ;   CS:BootDrive = int 13 drive number we booted from
   720                                  ;   CS:FirstSectorL = first data sector on disk (low) (0-based)
   721                                  ;   CS:FirstSectorH = first data sector on disk (high)
   722                                  ;
   723                                  ; OUTPUT:
   724                                  ;
   725                                  ;   required by msinit
   726                                  ;   DL = int 13 drive number we booted from
   727                                  ;   CH = media byte
   728                                  ;   BX = first data sector on disk (0-based)
   729                                  ;   AX = first data sector on disk (high)
   730                                  ;   DI = sectors/fat for the boot media.
   731                                  ;
   732                                  ; calls:     none
   733                                  ; ---------------------------------------------------------------------------
   734                                  ;
   735                                  ; set up registers for msinit then do far jmp
   736                                  ;
   737                                  ; ---------------------------------------------------------------------------
   738                                  
   739                                  GoToBioInit:
   740                                  		; 22/12/2022
   741                                  		; Set registers just as Retro DOS v2/v3 boot sector sets them
   742                                  		
   743                                  		; these are not necessary
   744                                  		;xor	ax, ax
   745                                  		;mov	ds, ax
   746                                  		;mov	bp, 7C00h
   747                                  		;cli
   748                                  		;mov	ss, ax
   749                                  		;mov	sp, bp
   750                                  		;sti
   751                                  	
   752                                  		; 23/12/2022
   753                                  		;push	cs
   754                                  		;pop	ds
   755                                  		;mov	si, crlf
   756                                  		; 24/12/2022
   757                                  		; ds = cs
   758 0000014F BE[3003]                		mov	si, ok_msg
   759 00000152 E8C300                  		call	WriteTTY
   760                                  		
   761 00000155 8A36[2600]              		mov	dh, [MediaByte] ; Restore regs required for msint
   762 00000159 8A16[2400]              		mov	dl, [BootDrive] ; Physical drv number we booted from.
   763 0000015D A1[1C00]                		mov	ax, [TotalSectorsL]
   764                                  
   765                                  		; 15/09/2023
   766                                  		; (This is not necessary but BP value will be 7C00h
   767                                  		; when the RetroDOS boot sector code starts the kernel.
   768                                  		; Retro DOS 4 Kernel source code contains a comment that
   769                                  		; 'bp = 7C00h' at the init stage.)
   770                                  		; ((The recent RetroDOS v4 kernel code doesn't use BP 
   771                                  		; by assuming it has 7C00h. However, I want to leave BP 
   772                                  		; as equal to SP here.))
   773                                   
   774 00000160 89E5                    		mov	bp, sp ; 7C00h ; 15/09/2023
   775                                  
   776                                  		; 22/12/2022
   777                                  		; (far jump to Retro DOS kernel start address)
   778 00000162 EA00000010              		jmp	1000h:0	; Far jump to MSDOS.SYS address	(KERNEL)
   779                                  
   780                                  ; =============== S U B	R O U T	I N E =======================================
   781                                  
   782                                  ; ReadSectors
   783                                  ; ---------------------------------------------------------------------------
   784                                  ; notES:
   785                                  ;
   786                                  ;  read in the CS:SectorCount number of sectors at ES:di
   787                                  ;
   788                                  ;
   789                                  ; INPUT:
   790                                  ;
   791                                  ;   DI = OFFSET of start of read
   792                                  ;   ES = segment of read
   793                                  ;   CS:SectorCount = number of sectors to read
   794                                  ;   CS:StartSecL = starting sector (low)
   795                                  ;   CS:StartSecH = starting sector (high)
   796                                  ;   following is bpb info that must be setup prior to call
   797                                  ;   CS:NumHeads
   798                                  ;   CS:number_of_sectors
   799                                  ;   CS:BootDrive
   800                                  ;   CS:SecPerTrack
   801                                  ;
   802                                  ; OUTPUT:
   803                                  ;
   804                                  ;   AX,BX,CX,DX,SI,DI destroyed
   805                                  ; ---------------------------------------------------------------------------
   806                                  ; divide start sector by sectors per track
   807                                  ; the remainder is the actual sector number, 0 based
   808                                  ;
   809                                  ; increment actual sector number to get 1 based
   810                                  ;
   811                                  ; the quotient is the number of tracks - divide by heads to get the cyl
   812                                  ;
   813                                  ; the remainder is actual head, the quotient is cylinder
   814                                  ;
   815                                  ; figure the number of sectors in that track, set al to this
   816                                  ;
   817                                  ; do the read
   818                                  ;
   819                                  ; if error, do reset, then redo the int 13h
   820                                  ;
   821                                  ; if successful read, subtract # sectors read from SectorCount, add to logical
   822                                  ; sector, add #sectors read * BytesPerSec to bx;
   823                                  ;
   824                                  ; if SectorCount <> 0 do next read
   825                                  ; ---------------------------------------------------------------------------
   826                                  
   827                                  		; 15/09/2023
   828                                  		; 24/12/2022
   829                                  		; 22/12/2022
   830                                  ReadSectors:
   831 00000167 B90500                  		mov	cx, 5			; 5 retries
   832                                  
   833                                  		; Convert a logical sector into track/sector/head. AX has the
   834                                  		; logical sector number
   835                                  TryRead:
   836                                  		; 24/12/2022
   837                                  		; ds = cs
   838 0000016A 51                      		push	cx
   839                                  		;mov	ax, [cs:StartSecL]	; Get starting sector
   840                                  		;mov	dx, [cs:StartSecH]
   841                                  		; 15/09/2023
   842                                  		;mov	ax, [StartSecL]	; *	; Get starting sector	
   843                                  		;mov	dx, [StartSecH]
   844                                  		;push	ax ; *
   845                                  		;mov	ax, dx
   846 0000016B A1[0600]                		mov	ax, [StartSecH]
   847 0000016E 31D2                    		xor	dx, dx
   848                                  		;;div	word [cs:SecPerTrack]
   849                                  		;div	word [SecPerTrack]	
   850                                  		; 24/12/2022
   851 00000170 8B1E[1400]              		mov	bx, [SecPerTrack]
   852 00000174 F7F3                    		div	bx
   853                                  
   854                                  		;mov	[TempH], ax
   855                                  		;;mov	[cs:TempH], ax
   856                                  		; 15/09/2023
   857 00000176 89C5                    		mov	bp, ax ; [TempH]
   858                                  		;pop	ax ; *
   859 00000178 A1[0400]                		mov	ax, [StartSecL] ; *
   860 0000017B F7F3                    		div	bx
   861                                  		;div	word [SecPerTrack]
   862                                  		;;div	word [cs:SecPerTrack]	; [TempH]:ax = track,
   863                                  						; dx = sector number
   864                                  
   865                                  		;mov	bx, [cs:SecPerTrack]	; Get number of sectors we can
   866                                  						; read in this track
   867 0000017D 29D3                    		sub	bx, dx
   868                                  		;mov	si, bx
   869 0000017F 8B36[0A00]              		mov	si, [SectorCount]
   870                                  
   871 00000183 39DE                    		cmp	si, bx
   872 00000185 7602                    		jna	short GotLength
   873                                  		;cmp	[SectorCount], si
   874                                  		;;cmp	[cs:SectorCount], si	; Is possible sectors in track more
   875                                  		;jnb	short GotLength		; than what we need to read?
   876 00000187 89DE                    		mov	si, bx
   877                                  		;mov	si, [SectorCount]
   878                                  		;;mov	si, [cs:SectorCount]	; Yes, only read what we need to
   879                                  GotLength:
   880                                  		; 23/12/2022
   881                                  		; dma boundary check for >64KB reads
   882                                  		; 24/12/2022
   883                                  		; Also, Segment Override risk !
   884 00000189 09FF                    		or	di, di
   885 0000018B 7418                    		jz	short dma_boundary_ok ; no problem for the 1st read
   886                                  		; 24/12/2022
   887                                  		;cmp	byte [BootDrive], 80h
   888                                  		;;cmp	byte [cs:BootDrive], 80h
   889                                  		;jnb	short dma_boundary_ok ; no problem for hard disks
   890                                  dma_boundary_chk:
   891                                  		; 24/12/2022
   892 0000018D 83FE01                  		cmp	si, 1
   893 00000190 7613                    		jna	short dma_boundary_ok 
   894                                  				; 1 sector read will not cause a boundary error			
   895 00000192 52                      		push	dx
   896 00000193 50                      		push	ax
   897                                  
   898 00000194 89F0                    		mov	ax, si ; sector count
   899 00000196 29D2                    		sub	dx, dx
   900                                  		; 24/12/2022
   901 00000198 F726[0E00]              		mul	word [BytesPerSec]
   902                                  		;mul	word [cs:BytesPerSec]
   903                                  		; 23/12/2022
   904                                  		; If di > 0 -> es = 1000h (or 2000h)
   905                                  		;mov	bx, es
   906                                  		;mov	cl, 4
   907                                  		;shl	bx, cl ; convert paragraphs to bytes
   908                                  		;; bx = segment start position (for 64K memory sections)
   909                                  		;add	bx, ax ; byte count to read
   910                                  		; 06/10/2023
   911                                  		;mov	bx, ax ; byte count to read
   912 0000019C 01F8                    		add	ax, di
   913                                  
   914 0000019E 58                      		pop	ax
   915 0000019F 5A                      		pop	dx
   916                                  		; 06/10/2023
   917                                  		;add	bx, di ; add current buffer offset to byte count
   918 000001A0 7303                    		jnc	short dma_boundary_ok
   919                                  		; Sector count must be decreased to prevent
   920                                  		; DMA boundary error or segment override risk!
   921 000001A2 4E                      		dec	si
   922 000001A3 EBE8                    		jmp	short dma_boundary_chk
   923                                  dma_boundary_ok:
   924                                  		;inc	dl			; Sector numbers are 1-based
   925                                  		; 18/12/2022
   926 000001A5 42                      		inc	dx
   927 000001A6 88D3                    		mov	bl, dl			; Start sector in BL
   928                                  		
   929                                  		; 15/09/2023
   930                                  		; 24/12/2022
   931                                  		;mov	dx, [TempH]		; DX:AX = Track
   932                                  		;;mov	dx, [cs:TempH]		; DX:AX = Track
   933                                  		
   934 000001A8 50                      		push	ax
   935                                  		;mov	ax, dx
   936                                  		; 15/09/2023
   937 000001A9 89E8                    		mov	ax, bp ; [TempH]
   938 000001AB 31D2                    		xor	dx, dx
   939                                  		; 24/12/2022
   940 000001AD F736[1600]              		div	word [NumHeads]
   941                                  		;div	word [cs:NumHeads]	; Start cyl in AX, head in dl
   942                                  		;mov	[TempH], ax
   943                                  		;;mov	[cs:TempH], ax
   944 000001B1 58                      		pop	ax
   945 000001B2 F736[1600]              		div	word [NumHeads]
   946                                  		;div	word [cs:NumHeads]	; [TempH]:AX = Cylinder, DX = Head
   947                                  
   948                                  			; At this moment, we assume that TempH = 0,
   949                                  			; ax <= 1024, dx <= 255
   950                                  
   951 000001B6 88D6                    		mov	dh, dl
   952                                  		
   953 000001B8 B106                    		mov	cl, 6
   954 000001BA D2E4                    		shl	ah, cl			; Shift cyl high bits up
   955 000001BC 08DC                    		or	ah, bl			; Mix in with sector bits
   956 000001BE 88C5                    		mov	ch, al			; Setup cyl low
   957 000001C0 88E1                    		mov	cl, ah			; Setup cyl/high - sector
   958 000001C2 89FB                    		mov	bx, di			; Get back OFFSET
   959                                  		; 24/12/2022
   960 000001C4 8A16[2400]              		mov	dl, [BootDrive]		; Get drive
   961                                  		;mov	dl, [cs:BootDrive]	; Get drive
   962 000001C8 89F0                    		mov	ax, si			; Get number of sectors to read (al)
   963 000001CA B402                    		mov	ah, 2			; Read sectors
   964                                  		; 23/12/2022
   965                                  		;push	ax
   966                                  		;push	di
   967                                  
   968                                  			; Issue one read request. ES:BX have the transfer address,
   969                                  			; AL is the number of sectors.	
   970                                  
   971 000001CC CD13                    		int	13h		; DISK - READ SECTORS INTO MEMORY
   972                                  					; AL = number of sectors to read, CH = track, CL = sector
   973                                  					; DH = head, DL	= drive, ES:BX -> buffer to fill
   974                                  					; Return: CF set on error, AH =	status,	AL = number of sectors read
   975                                  		; 23/12/2022
   976                                  		;pop	di
   977                                  		;pop	ax
   978                                  
   979                                  		; 23/12/2022
   980 000001CE B400                    		mov	ah, 0
   981                                  		
   982 000001D0 59                      		pop	cx		; Get retry count back
   983 000001D1 7307                    		jnc	short ReadOk	; 23/12/2022
   984                                  		
   985                                  		; 23/12/2022
   986                                  		;mov	bx, di		; Get offset
   987                                  		; ah = 0
   988                                  		;xor	ah, ah
   989                                  		; 23/12/2022
   990                                  		;push	cx
   991                                  		; 24/12/2022
   992                                  		;mov	dl, [BootDrive]
   993                                  		;;mov	dl, [cs:BootDrive]
   994                                  		; 23/12/2022
   995                                  		;push	di
   996 000001D3 CD13                    		int	13h	; DISK - RESET DISK SYSTEM
   997                                  				; DL = drive (if bit 7 is set both hard	disks and floppy disks reset)
   998                                  		; 23/12/2022
   999                                  		;pop	di
  1000                                  		;pop	cx
  1001 000001D5 49                      		dec	cx
  1002 000001D6 7426                    		jz	short ReadError
  1003 000001D8 EB90                    		jmp	TryRead
  1004                                  ; ---------------------------------------------------------------------------
  1005                                  		; 07/10/2023
  1006                                  ;ReadError:				
  1007                                  		;jmp	ErrorOut
  1008                                  ; ---------------------------------------------------------------------------
  1009                                  
  1010                                  ReadOk:
  1011                                  		; 23/12/2022
  1012                                  		; ah = 0
  1013                                  		; 22/12/2022
  1014                                  		;xor	ah, ah		; Mask out read command, just get # read
  1015                                  		; ch = 0
  1016 000001DA 88C1                    		mov	cl, al
  1017                                  		; 22/12/2022
  1018                                  		; cx = ax = read (sector) count	
  1019                                  		;mov	bx, [cs:BytesPerSec]	; Bytes per sector
  1020                                  		;mul	bx			; Get total bytes read	
  1021                                  		; 24/12/2022
  1022                                  		; ds = cs
  1023 000001DC F726[0E00]              		mul	word [BytesPerSec]
  1024                                  		;mul	word [cs:BytesPerSec]
  1025 000001E0 01C7                    		add	di, ax			; Add it to OFFSET
  1026 000001E2 7307                    		jnc	short read_next_sector
  1027 000001E4 8CC3                    		mov	bx, es
  1028                                  		;add	bx, 1000h
  1029 000001E6 80C710                  		add	bh, 10h
  1030 000001E9 8EC3                    		mov	es, bx
  1031                                  read_next_sector:
  1032                                  		; 24/12/2022
  1033                                  		; ds = cs
  1034                                  		; 22/12/2022
  1035 000001EB 290E[0A00]              		sub	[SectorCount], cx
  1036                                  		;sub	[cs:SectorCount], cx
  1037                                  		;;sub	[cs:SectorCount], ax	; Bump number down
  1038 000001EF 740C                    		jz	short EndRead
  1039 000001F1 010E[0400]              		add	[StartSecL], cx
  1040                                  		;add	[cs:StartSecL], cx
  1041                                  		;;add	[cs:StartSecL], ax	; Where to start next time
  1042 000001F5 8316[0600]00            		adc	word [StartSecH], 0
  1043                                  		;adc	word [cs:StartSecH], 0
  1044 000001FA E96AFF                  		jmp	ReadSectors
  1045                                  ; ---------------------------------------------------------------------------
  1046                                  		; 07/10/2023
  1047                                  		; 24/12/2022
  1048                                  EndRead:
  1049 000001FD C3                      EndWrite:	retn
  1050                                  ; ---------------------------------------------------------------------------
  1051                                  
  1052                                  ReadError:
  1053                                  		; 07/10/2023
  1054                                  ErrorOut:	
  1055                                  		; 24/12/2022
  1056                                  		; ds = cs		
  1057                                  		;push	cs
  1058                                  		;pop	ds
  1059 000001FE BE[C702]                		mov	si, NonSystemDiskMsg ; "\r\nNon-System disk or disk error\r\nRe"...
  1060 00000201 E81400                  		call	WriteTTY
  1061                                  
  1062                                  		; Wait for a keypress on the keyboard.
  1063                                  		; Use the bios keyboard interrupt.
  1064                                  
  1065 00000204 30E4                    		xor	ah, ah
  1066 00000206 CD16                    		int	16h		; KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY
  1067                                  					; Return: AH = scan code, AL = character
  1068                                  
  1069                                  		; We have to restore the address of the original rom disk
  1070                                  		; parameter table to the location at [0:DskAddr]. The address
  1071                                  		; of this original table has been saved previously in
  1072                                  		; 0:OrgDasdPtr and 0:OrgDasdPtr+2. After this table address
  1073                                  		; has been restored we can reboot by invoking the bootstrap
  1074                                  		; loader bios interrupt.
  1075                                  
  1076                                  		; 23/12/2022
  1077                                  		;xor	bx, bx
  1078                                  		;mov	ds, bx
  1079                                  		;les	bx, [OrgDasdPtr] ; Wrong DS segment !
  1080                                  					 ; (Erdogan Tan, 23/12/2022)
  1081 00000208 C41E[2800]              		les	bx, [OrgDasdPtr] ; Correct DS segment = CS
  1082                                  		
  1083                                  		; 23/12/2022
  1084 0000020C 16                      		push	ss ; 0
  1085 0000020D 1F                      		pop	ds
  1086                                  		; ds = 0		
  1087                                  
  1088 0000020E BE7800                  		mov	si, DskAddr	; (Int 1Eh)
  1089 00000211 891C                    		mov	[si], bx	; restore offset		
  1090 00000213 8C4402                  		mov	[si+2], es	; restore segment
  1091                                  
  1092 00000216 CD19                    		int	19h		; reboot
  1093                                  
  1094                                  ; =============== S U B	R O U T	I N E =======================================
  1095                                  
  1096                                  ; WriteTTY
  1097                                  ; ---------------------------------------------------------------------------
  1098                                  ; in) DS:si -> asciiz string.
  1099                                  ;
  1100                                  ; WriteTTY the character in al to the screen.
  1101                                  ; use video service 'write teletype to active page' (ROM_TTY)
  1102                                  ; use normal character attribute
  1103                                  ; ---------------------------------------------------------------------------
  1104                                  
  1105                                  WriteTTY:				
  1106 00000218 AC                      		lodsb
  1107 00000219 08C0                    		or	al, al
  1108 0000021B 74E0                    		jz	short EndWrite
  1109                                  		;mov	AH, ROM_TTY	; 09/12/2022
  1110 0000021D B40E                    		mov	ah, 0Eh
  1111 0000021F B307                    		mov	bl, 7		; "normal" attribute
  1112 00000221 CD10                    		int	10h		; - VIDEO - WRITE CHARACTER AND	ADVANCE	CURSOR (TTY WRITE)
  1113                                  					; AL = character, BH = display page (alpha modes)
  1114                                  					; BL = foreground color	(graphics modes)
  1115 00000223 EBF3                    		jmp	short WriteTTY
  1116                                  ; ---------------------------------------------------------------------------
  1117                                  
  1118                                  ; 10/12/2022	
  1119                                  ;EndWrite:				
  1120                                  ;		retn
  1121                                  
  1122                                  ; =============== S U B	R O U T	I N E =======================================
  1123                                  
  1124                                  ; GetNextFatEntry
  1125                                  ; ---------------------------------------------------------------------------
  1126                                  ;
  1127                                  ; NOTES:
  1128                                  ;
  1129                                  ;   given the last cluster found, this will return the next cluster of
  1130                                  ;   iosys. if the last cluster is (f)ff8 - (f)fff, then the final cluster
  1131                                  ;   of iosys has been loaded, and control is passed to goto_iosys
  1132                                  ;   msload can handle maximum fat area size of 128 kb.
  1133                                  ;
  1134                                  ; INPUT:
  1135                                  ;
  1136                                  ;    CS:CurrentCluster
  1137                                  ;    CS:FatSize
  1138                                  ;
  1139                                  ; OUTPUT:
  1140                                  ;
  1141                                  ;   CS:CurrentCluster (updated)
  1142                                  ;
  1143                                  ; calls:  GetFatSector
  1144                                  ; ---------------------------------------------------------------------------
  1145                                  ; get CurrentCluster
  1146                                  ;
  1147                                  ; if (16 bit fat)
  1148                                  ;    {if (CurrentCluster = fff8 - ffff)
  1149                                  ;	 {jmp goto_iosys}
  1150                                  ;     else
  1151                                  ;	{get OFFSET by multiply cluster by 2}
  1152                                  ;
  1153                                  ; else
  1154                                  ;    {if (CurrentCluster = ff8 - fff)
  1155                                  ;	 {jmp goto_iosys}
  1156                                  ;     else
  1157                                  ;	{get OFFSET by	- multiply cluster by 3
  1158                                  ;
  1159                                  ;	 rotate right to divide by 2
  1160                                  ;
  1161                                  ;	 if (cy set - means odd number)
  1162                                  ;	    {shr 4 times to keep high twelve bits}
  1163                                  ;
  1164                                  ;	 else
  1165                                  ;	    {and with 0fffh to keep low 12 bits}
  1166                                  ;	}
  1167                                  ;    }
  1168                                  ;
  1169                                  ; ---------------------------------------------------------------------------
  1170                                  
  1171                                  ; 09/12/2022
  1172                                  ; FAT_12_BIT equ 1
  1173                                  ; NOT_END_OF_FILE equ 0  ; ~END_OF_FILE ; END_OF_FILE equ 0FFh
  1174                                  
  1175                                  GetNextFatEntry:			
  1176 00000225 06                      		push	es
  1177                                  		; 24/12/2022
  1178 00000226 B8D000                  		mov	ax, FATSEGMENT	; FATBUFSEGM
  1179                                  		;mov	ax, [cs:FatSegment]
  1180 00000229 8EC0                    		mov	es, ax		; ES-> FAT area segment
  1181                                  		; 09/12/2022
  1182                                  		;;mov	byte [cs:EndOfFile], END_OF_FILE
  1183                                  		;mov	byte [cs:EndOfFile], 0FFh ; Assume last cluster
  1184                                  		;mov	ax, [cs:CurrentCluster] ; Get last cluster
  1185                                  		; 24/12/2022
  1186                                  		; ds = cs
  1187 0000022B C606[2700]FF            		mov	byte [EndOfFile], 0FFh ; Assume last cluster
  1188 00000230 A1[0C00]                		mov	ax, [CurrentCluster] ; Get last cluster
  1189                                  		; 06/10/2023
  1190 00000233 29D2                    		sub	dx, dx
  1191                                  		; dx = 0
  1192 00000235 803E[2500]01            		cmp	byte [Fatsize], 1
  1193                                  		;;cmp	byte [cs:FatSize], FAT_12_BIT
  1194                                  		;cmp	byte [cs:Fatsize], 1
  1195 0000023A 7539                    		jne	short Got16Bit	; 23/12/2022
  1196 0000023C 89C6                    		mov	si, ax
  1197 0000023E D1E8                    		shr	ax, 1
  1198 00000240 01C6                    		add	si, ax		; SI = AX * 1.5 = AX + AX/2
  1199                                  		; 06/10/2023
  1200 00000242 56                      		push	si ; (**)
  1201                                  		; 23/12/2022
  1202                                  		;push	dx
  1203                                  		;xor	dx, dx
  1204                                  		; 06/10/2023
  1205                                  		;sub	dx, dx ; 23/12/2022
  1206 00000243 E84700                  		call	GetFatSector
  1207                                  		; 06/10/2023
  1208 00000246 5E                      		pop	si ; (**)
  1209                                  		; 23/12/2022
  1210                                  		;pop	dx
  1211 00000247 7512                    		jnz	short ClusterOk
  1212 00000249 268A07                  		mov	al, [es:bx]
  1213                                  		; 22/12/2022
  1214                                  		;mov	[cs:TempCluster], al
  1215                                  		; 06/10/2023
  1216 0000024C 50                      		push	ax ; (*)
  1217 0000024D 46                      		inc	si
  1218                                  		; 23/12/2022
  1219                                  		;push	dx
  1220 0000024E 31D2                    		xor	dx, dx
  1221 00000250 E83A00                  		call	GetFatSector	; Read next fat sector
  1222                                  		; 23/12/2022
  1223                                  		;pop	dx
  1224                                  		; 22/12/2022
  1225                                  		;mov	al, [es:0]
  1226                                  		;mov	[cs:TempCluster+1], al
  1227                                  		;mov	ax, [cs:TempCluster]
  1228                                  		; 06/10/2023
  1229                                  		; 22/12/2022
  1230 00000253 58                      		pop	ax ; (*) 
  1231 00000254 268A260000              		mov	ah, [es:0]
  1232 00000259 EB03                    		jmp	short EvenOdd
  1233                                  ; ---------------------------------------------------------------------------
  1234                                  
  1235                                  ClusterOk:				
  1236 0000025B 268B07                  		mov	ax, [es:bx]
  1237                                  EvenOdd:	
  1238                                  		; 24/12/2022
  1239                                  		; ds = cs
  1240 0000025E F606[0C00]01            		test	byte [CurrentCluster], 1
  1241                                  		; 10/12/2022		
  1242                                  		;test	byte [cs:CurrentCluster], 1 ; 09/12/2022
  1243                                  		;;test	word [cs:CurrentCluster], 1 ; Was last cluster odd?
  1244 00000263 7505                    		jnz	short OddResult		; If not zero it was odd
  1245 00000265 25FF0F                  		and	ax, 0FFFh		; Keep low 12 bits
  1246 00000268 EB04                    		jmp	short TestEOF
  1247                                  ; ---------------------------------------------------------------------------
  1248                                  
  1249                                  OddResult:				
  1250 0000026A B104                    		mov	cl, 4			; Keep high 12 bits for odd
  1251 0000026C D3E8                    		shr	ax, cl
  1252                                  TestEOF:				
  1253 0000026E 3DF80F                  		cmp	ax, 0FF8h		; Is it last cluster?
  1254 00000271 7318                    		jnb	short GotClusterDone	; Yep, all done here
  1255 00000273 EB11                    		jmp	short NotLastCluster
  1256                                  ; ---------------------------------------------------------------------------
  1257                                  
  1258                                  Got16Bit:
  1259                                  		; 23/12/2022				
  1260                                  		;push	dx
  1261                                  		;xor	dx, dx
  1262                                  		; 06/10/2023
  1263                                  		; ax = cluster number (index)
  1264                                  		; dx = 0
  1265                                  		;sub	dx, dx ; 23/12/2022
  1266 00000275 D1E0                    		shl	ax, 1			; Multiply cluster by 2
  1267                                  		;adc	dx, 0
  1268                                  		; 07/10/2023
  1269 00000277 11D2                    		adc	dx, dx ; dx = 0
  1270 00000279 89C6                    		mov	si, ax			; Get the final buffer OFFSET
  1271 0000027B E80F00                  		call	GetFatSector
  1272                                  		; 23/12/2022
  1273                                  		;pop	dx
  1274 0000027E 268B07                  		mov	ax, [es:bx]
  1275 00000281 83F8F8                  		cmp	ax, 0FFF8h
  1276 00000284 7305                    		jnb	short GotClusterDone
  1277                                  NotLastCluster:	
  1278                                  		; 24/12/2022
  1279                                  		; ds = cs			
  1280                                  		;;mov	byte [cs:EndOfFile], NOT_END_OF_FILE ; ~END_OF_FILE
  1281                                  		;mov	byte [cs:EndOfFile], 0	; Assume not last cluster
  1282 00000286 C606[2700]00            		mov	byte [EndOfFile], 0	; Assume not last cluster
  1283                                  GotClusterDone:				
  1284 0000028B 07                      		pop	es
  1285                                  		; 07/10/2023
  1286                                  		; 24/12/2022
  1287                                  ;EndRead:
  1288 0000028C C3                      		retn
  1289                                  
  1290                                  ; =============== S U B	R O U T	I N E =======================================
  1291                                  
  1292                                  ; GetFatSector
  1293                                  ; ---------------------------------------------------------------------------
  1294                                  ;function: find and read the corresponding fat sector into ES:0
  1295                                  ;
  1296                                  ;in). SI = offset value (starting from fat entry 0) of fat entry to find.
  1297                                  ;     ES = fat sector segment
  1298                                  ;     CS:BytesPerSec
  1299                                  ;
  1300                                  ;out). corresponding fat sector read in.
  1301                                  ;      BX = offset value of the corresponding fat entry in the fat sector.
  1302                                  ;      CX destroyed.
  1303                                  ;      zero flag set if the fat entry is splitted, i.e. when 12 bit fat entry
  1304                                  ;      starts at the last byte of the fat sector. in this case, the caller
  1305                                  ;      should save this byte, and read the next fat sector to get the rest
  1306                                  ;      of the fat entry value. (this will only happen with the 12 bit fat).
  1307                                  ;
  1308                                  ; ---------------------------------------------------------------------------
  1309                                  
  1310                                  		; 24/12/2022
  1311                                  		; 22/12/2022
  1312                                  GetFatSector:	
  1313                                  		; 06/10/2023			
  1314                                  		;push	ax
  1315                                  		;push	si
  1316 0000028D 57                      		push	di
  1317 0000028E 89F0                    		mov	ax, si		; dx:si = cluster offset in the FAT
  1318                                  		; 24/12/2022
  1319                                  		; ds = cs
  1320                                  		;mov	cx, [cs:BytesPerSec]
  1321                                  		;div	cx			; AX = Sector number, DX = Offset
  1322 00000290 F736[0E00]              		div	word [BytesPerSec]
  1323 00000294 3B06[0800]              		cmp	ax, [LastFatSector]
  1324                                  		;cmp	ax, [cs:LastFatSector]	; The same fat sector?
  1325 00000298 7421                    		je	short SplitChk		; Don't need to read it again.
  1326 0000029A A3[0800]                		mov	[LastFatSector], ax
  1327                                  		;mov	[cs:LastFatSector], ax
  1328 0000029D 52                      		push	dx
  1329                                  		; 24/12/2022
  1330 0000029E 31D2                    		xor	dx, dx
  1331                                  		;add	ax, [cs:HiddenSectorsL]
  1332                                  		;adc	dx, [cs:HiddenSectorsH]
  1333                                  		;add	ax, [cs:ReservSectors]
  1334                                  		;adc	dx, 0
  1335                                  		; 24/12/2022
  1336                                  		; ds = cs
  1337 000002A0 0306[2C00]              		add	ax, [FatStartSecL]
  1338 000002A4 1316[2E00]              		adc	dx, [FatStartSecH]
  1339 000002A8 A3[0400]                		mov	[StartSecL], ax
  1340 000002AB 8916[0600]              		mov	[StartSecH], dx		; Set up for ReadSectors
  1341                                  		;mov	[cs:StartSecL], ax
  1342                                  		;mov	[cs:StartSecH], dx	; Set up for ReadSectors
  1343                                  		
  1344 000002AF C706[0A00]0100          		mov	word [SectorCount], 1	; 1 sector
  1345                                  		;mov	word [cs:SectorCount], 1 ; 1 sector
  1346 000002B5 31FF                    		xor	di, di ; 0
  1347                                  		; es:di = FATSEGMENT:0000h
  1348 000002B7 E8ADFE                  		call	ReadSectors
  1349 000002BA 5A                      		pop	dx
  1350                                  		; 24/12/2022
  1351                                  		;mov	cx, [cs:BytesPerSec]
  1352                                  SplitChk:
  1353                                  		; 24/12/2022
  1354 000002BB 8B0E[0E00]              		mov	cx, [BytesPerSec]				
  1355 000002BF 49                      		dec	cx			; CX = SECTOR SIZE - 1
  1356 000002C0 39CA                    		cmp	dx, cx			; If last byte of sector, splitted entry.
  1357 000002C2 89D3                    		mov	bx, dx			; set bx to dx
  1358 000002C4 5F                      		pop	di
  1359                                  		; 06/10/2023
  1360                                  		;pop	si
  1361                                  		;pop	ax
  1362                                  		; 07/10/2023
  1363                                  ;EndWrite:		; 10/12/2022
  1364 000002C5 C3                      		retn
  1365                                  
  1366                                  ; ---------------------------------------------------------------------------
  1367                                  
  1368                                  ; 09/12/2022
  1369                                  ;include msbio.cl1
  1370                                  
  1371                                  		; 22/12/2022
  1372                                  		; 20/12/2022
  1373                                  		; 18/12/2022
  1374 000002C6 00                      		db 0	; (word alignment)
  1375                                  NonSystemDiskMsg:
  1376 000002C7 0D0A                    		db 0Dh,0Ah
  1377 000002C9 4E6F6E2D5379737465-     		db 'Non-System disk or disk error',0Dh,0Ah
  1377 000002D2 6D206469736B206F72-
  1377 000002DB 206469736B20657272-
  1377 000002E4 6F720D0A           
  1378 000002E8 5265706C6163652061-     		db 'Replace and press any key when ready',0Dh,0Ah,0
  1378 000002F1 6E6420707265737320-
  1378 000002FA 616E79206B65792077-
  1378 00000303 68656E207265616479-
  1378 0000030C 0D0A00             
  1379                                  ;EndOfLoader:
  1380                                  		; 07/10/2023
  1381                                  		; 22/12/2022
  1382                                  		;dw 01A1h	; 10/12/2022
  1383                                  
  1384                                  ; ---------------------------------------------------------------------------
  1385                                  
  1386                                  ; 23/12/2022
  1387 0000030F 00                      		db 0
  1388 00000310 0D0A                    loading_msg:	db 0Dh, 0Ah
  1389 00000312 4C6F6164696E67204B-     		db 'Loading Kernel MSDOS.SYS ... '
  1389 0000031B 65726E656C204D5344-
  1389 00000324 4F532E535953202E2E-
  1389 0000032D 2E20               
  1390                                  ; 24/12/2022
  1391 0000032F 00                      		db 0
  1392 00000330 4F4B2E20                ok_msg:		db 'OK. '
  1393 00000334 00                      		db 0	; 07/10/2023
  1394                                  crlf:
  1395 00000335 0D0A00                  		db 0Dh, 0Ah, 0
  1396                                  
  1397                                  ; ---------------------------------------------------------------------------
  1398                                  		
  1399                                  
  1400                                  ; 22/12/2022
  1401                                  ; (set file size to 1536 bytes)
  1402                                  
  1403                                  SignatureSize equ EndOfLoader - signature
  1404                                  
  1405                                  FillingSpace equ ($-START$)+SignatureSize
  1406                                  
  1407                                  ;	times	1536-FillingSpace db 0FFh ; db 90h
  1408                                  ; 07/10/2023
  1409 00000338 FF<rep 280h>            	times	1534-FillingSpace db 0FFh ; db 90h
  1410                                  
  1411 000005B8 00                      signature:	db 0
  1412 000005B9 0D0A                    		db 0Dh, 0Ah
  1413 000005BB 526574726F20444F53-     		db 'Retro DOS v4 Kernel Loader (Fake IO.SYS) '
  1413 000005C4 207634204B65726E65-
  1413 000005CD 6C204C6F6164657220-
  1413 000005D6 2846616B6520494F2E-
  1413 000005DF 5359532920         
  1414 000005E4 0D0A                    		db 0Dh,0Ah
  1415                                  		;db 'by Erdogan Tan [2022]'
  1416 000005E6 6279204572646F6761-     		db 'by Erdogan Tan [2023]' ; 06/10/2023
  1416 000005EF 6E2054616E205B3230-
  1416 000005F8 32335D             
  1417 000005FB 0D0A00                  		db  0Dh, 0Ah, 0
  1418                                  		; 07/10/2023
  1419 000005FE A101                    EndOfLoader:	dw 01A1h
