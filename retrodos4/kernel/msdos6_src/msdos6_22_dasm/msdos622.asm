;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2013 Hex-Rays, <support@hex-rays.com>	    |
; |			 Licensed to: Freeware version			    |
; +-------------------------------------------------------------------------+
;
; MSDOS 6.22 (original) Kernel
; NASM conversion: Erdogan Tan - 26/09/2023 (Last Update: 27/09/2023)
;
; (nasm msdos622.asm -l msdos622.lst -o MSDOS.SYS -Z error.txt)

; ---------------------------------------------------------------------------
; File Name   :	C:\retrodos4\MSDOS622.SYS
; Format      :	Binary file
; Base Address:	0000h Range: 0000h - 94FAh Loaded length: 94FAh
; ===========================================================================

; ----------------------------------------------------------------------------
segment DOSCODE vstart=3DE0h
; ----------------------------------------------------------------------------

		[org 3DE0h]
$STARTCODE:
		jmp	DOSINIT
; ---------------------------------------------------------------------------
		dw $STARTCODE
BioDataSeg:	dw 70h
DosDSeg:	dw 0			; ...
MSMAJOR:	db 6
MSMINOR:	db 22
I21_MAP_E_TAB:	db 38h,	2, 1, 2		; ...
		db 39h,	2 dup(3), 2, 5
		db 3Ah,	4, 10h,	3, 2, 5
		db 3Bh,	2 dup(2), 3
		db 3Ch,	4, 3, 2, 4, 5
		db 3Dh,	6, 3, 2, 0Ch, 4, 1Ah, 5
		db 3Eh,	1, 6
		db 3Fh,	2, 6, 5
		db 40h,	2, 6, 5
		db 41h,	2 dup(3), 2, 5
		db 42h,	2, 6, 1
		db 43h,	4, 3, 2, 1, 5
		db 44h,	5, 0Fh,	0Dh, 1,	6, 5
		db 45h,	2, 6, 4
		db 46h,	2, 6, 4
		db 47h,	2, 1Ah,	0Fh
		db 48h,	2, 7, 8
		db 49h,	2, 7, 9
		db 4Ah,	3, 7, 9, 8
		db 4Bh,	8, 3, 1, 2, 4, 0Bh, 0Ah, 8, 5
		db 4Eh,	2 dup(3), 2, 12h
		db 4Fh,	1, 12h
		db 56h,	5, 11h,	3, 2, 10h, 5
		db 57h,	4, 6, 8, 0Dh, 1
		db 58h,	2 dup(1)
		db 5Ah,	4, 3, 2, 4, 5
		db 5Bh,	5, 50h,	3, 2, 4, 5
		db 5Ch,	4, 6, 1, 24h, 21h
		db 65h,	2, 1, 2
		db 66h,	2, 1, 2
		db 68h,	1, 6
		db 67h,	3, 4, 8, 1
		db 6Ch,	0Ah, 3,	2, 0Ch,	4, 50h,	8, 1Ah,	0Dh, 1,	5
		db 69h,	4, 0Fh,	0Dh, 1,	5
		db 0FFh
DISPATCH:	dw $ABORT	; ...
		dw $STD_CON_INPUT
		dw $STD_CON_OUTPUT
		dw $STD_AUX_INPUT
		dw $STD_AUX_OUTPUT
		dw $STD_PRINTER_OUTPUT
		dw $RAW_CON_IO
		dw $RAW_CON_INPUT
		dw $STD_CON_INPUT_NO_ECHO
		dw $STD_CON_STRING_OUTPUT
		dw $STD_CON_STRING_INPUT
		dw $STD_CON_INPUT_STATUS
		dw $STD_CON_INPUT_FLUSH
		dw $DISK_RESET
		dw $SET_DEFAULT_DRIVE
		dw $FCB_OPEN
		dw $FCB_CLOSE
		dw $DIR_SEARCH_FIRST
		dw $DIR_SEARCH_NEXT
		dw $FCB_DELETE
		dw $FCB_SEQ_READ
		dw $FCB_SEQ_WRITE
		dw $FCB_CREATE
		dw $FCB_RENAME
		dw NO_OP
		dw $GET_DEFAULT_DRIVE
		dw $SET_DMA
		dw $SLEAZEFUNC
		dw $SLEAZEFUNCDL
		dw NO_OP
		dw NO_OP
		dw $GET_DEFAULT_DPB
		dw NO_OP
		dw $FCB_RANDOM_READ
		dw $FCB_RANDOM_WRITE
		dw $GET_FCB_FILE_LENGTH
		dw $GET_FCB_POSITION
		dw $SET_INTERRUPT_VECTOR
		dw $CREATE_PROCESS_DATA_BLOCK
		dw $FCB_RANDOM_READ_BLOCK
		dw $FCB_RANDOM_WRITE_BLOCK
		dw $PARSE_FILE_DESCRIPTOR
		dw $GET_DATE
		dw $SET_DATE
		dw $GET_TIME
		dw $SET_TIME
		dw $SET_VERIFY_ON_WRITE
		dw $GET_DMA
		dw $GET_VERSION
		dw $KEEP_PROCESS
		dw $GET_DPB
		dw $SET_CTRL_C_TRAPPING
		dw $GET_INDOS_FLAG
		dw $GET_INTERRUPT_VECTOR
		dw $GET_DRIVE_FREESPACE
		dw $CHAR_OPER
		dw $INTERNATIONAL
		dw $MKDIR
		dw $RMDIR
		dw $CHDIR
		dw $CREAT
		dw $OPEN
		dw $CLOSE
		dw $READ
		dw $WRITE
		dw $UNLINK
		dw $LSEEK
		dw $CHMOD
		dw $IOCTL
		dw $DUP
		dw $DUP2
		dw $CURRENT_DIR
		dw $ALLOC
		dw $DEALLOC
		dw $SETBLOCK
		dw $EXEC
		dw $EXIT
		dw $WAIT
		dw $FIND_FIRST
		dw $FIND_NEXT
		dw $SET_CURRENT_PDB
		dw $GET_CURRENT_PDB
		dw $GET_IN_VARS
		dw $SETDPB
		dw $GET_VERIFY_ON_WRITE
		dw $DUP_PDB
		dw $RENAME
		dw $FILE_TIMES
		dw $ALLOCOPER
		dw $GetExtendedError
		dw $CreateTempFile
		dw $CreateNewFile
		dw $LockOper
		dw $ServerCall
		dw $UserOper
		dw $AssignOper
		dw $NameTrans
		dw NO_OP
		dw $GET_CURRENT_PDB
		dw $ECS_Call
		dw $SET_PRINTER_FLAG
		dw $GetExtCntry
		dw $GetSetCdPg
		dw $ExtHandle
		dw $COMMIT
		dw $GSetMediaID
		dw $COMMIT
		dw NO_OP
		dw $Extended_Open
FOO:		dw Leave2F	; ...
DTab:		dw DOSTable	; ...
DOSTable:	db 48			; ...
		dw DOSInstall
		dw DOS_CLOSE
		dw RECSET
		dw DOSGetGroup
		dw PATHCHRCMP
		dw OUTT
		dw NET_I24_ENTRY
		dw PLACEBUF
		dw FREE_SFT
		dw BUFWRITE
		dw SHARE_VIOLATION
		dw SHARE_ERROR
		dw SET_SFT_MODE
		dw DATE16
		dw Idle
		dw SCANPLACE
		dw Idle
		dw StrCpy
		dw StrLen
		dw UCase
		dw POINTCOMP
		dw CHECKFLUSH
		dw SFFromSFN
		dw GetCDSFromDrv
		dw Get_User_Stack
		dw GETTHISDRV
		dw DriveFromText
		dw SETYEAR
		dw DSUM
		dw DSLIDE
		dw StrCmp
		dw InitCDS
		dw pJFNFromHandle
		dw $NameTrans
		dw CAL_LK
		dw DEVNAME
		dw Idle
		dw DStrLen
		dw NLS_OPEN
		dw $CLOSE
		dw NLS_LSEEK
		dw $READ
		dw FastInit
		dw NLS_IOCTL
		dw GetDevList
		dw NLS_GETEXT
		dw MSG_RETRIEVAL
		dw NO_OP
ms_copyright:	db 'MS DOS Version 6 (C)Copyright 1981-1994 Microsoft Corp Licensed M'
		db 'aterial - Property of Microsoft All rights reserved '
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR STATCHK

$SET_CTRL_C_TRAPPING:			; ...
		cmp	al, 6
		jbe	short scct_1
		mov	al, 0FFh
		iret
; ---------------------------------------------------------------------------

scct_1:					; ...
		push	ds
		mov	ds, [cs:DosDSeg]
		push	ax
		push	si
		mov	si, CNTCFLAG
		xor	ah, ah
		or	ax, ax
		jnz	short scct_2
		mov	dl, [si]
		jmp	short scct_9s
; ---------------------------------------------------------------------------

scct_2:					; ...
		dec	ax
		jnz	short scct_3
		and	dl, 1
		mov	[si], dl
		jmp	short scct_9s
; ---------------------------------------------------------------------------

scct_3:					; ...
		dec	ax
		jnz	short scct_4
		and	dl, 1
		xchg	dl, [si]
		jmp	short scct_9s
; ---------------------------------------------------------------------------

scct_4:					; ...
		cmp	ax, 3
		jnz	short scct_5
		mov	dl, [BOOTDRIVE]
		jmp	short scct_9s
; ---------------------------------------------------------------------------

scct_5:					; ...
		cmp	ax, 4
		jnz	short scct_9s
		mov	bx, 1606h
		mov	dl, 0
		xor	dh, dh
		cmp	byte [DosHasHMA], 0
		jz	short scct_9s
		or	dh, 10h

scct_9s:				; ...
		pop	si
		pop	ax
		pop	ds
		iret
; ---------------------------------------------------------------------------

SetCtrlShortEntry:			; ...
		jmp	short $SET_CTRL_C_TRAPPING
; ---------------------------------------------------------------------------

$SET_CURRENT_PDB:			; ...
		push	ds
		mov	ds, [cs:DosDSeg]
		mov	[CurrentPDB], bx
		pop	ds
		iret
; ---------------------------------------------------------------------------

$GET_CURRENT_PDB:			; ...
		push	ds
		mov	ds, [cs:DosDSeg]
		mov	bx, [CurrentPDB]
		pop	ds
		iret
; ---------------------------------------------------------------------------

$SET_PRINTER_FLAG:			; ...
		push	ds
		mov	ds, [cs:DosDSeg]
		mov	[PRINTER_FLAG], al
		pop	ds
		iret
; END OF FUNCTION CHUNK	FOR STATCHK
; ---------------------------------------------------------------------------

quit:					; ...
		xor	ah, ah
		jmp	short SAVREGS
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR STATCHK

BADCALL:				; ...
		xor	al, al

irett:					; ...
		iret
; END OF FUNCTION CHUNK	FOR STATCHK
; ---------------------------------------------------------------------------

call_entry:				; ...
		push	ds
		mov	ds, [cs:DosDSeg]
		pop	word [SAVEDS]
		pop	ax
		pop	ax
		pop	word [USER_SP]
		pushf
		cli
		push	ax
		push	word [USER_SP]
		push	word [SAVEDS]
		pop	ds
		cmp	cl, 36
		ja	short BADCALL
		mov	ah, cl
		jmp	short SAVREGS
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR STATCHK

command:				; ...
		cli
		cmp	ah, 6Ch
		ja	short BADCALL

SAVREGS:				; ...
		cmp	ah, 33h
		jb	short SaveAllRegs
		jz	short SetCtrlShortEntry
		cmp	ah, 64h
		ja	short SaveAllRegs
		jz	short $SET_PRINTER_FLAG
		cmp	ah, 51h
		jz	short $GET_CURRENT_PDB
		cmp	ah, 62h
		jz	short $GET_CURRENT_PDB
		cmp	ah, 50h
		jz	short $SET_CURRENT_PDB

SaveAllRegs:				; ...
		push	es
		push	ds
		push	bp
		push	di
		push	si
		push	dx
		push	cx
		push	bx
		push	ax
		mov	ax, ds
		mov	ds, [cs:DosDSeg]
		mov	[SAVEDS], ax
		mov	[SAVEBX], bx
		mov	ax, [USER_SP]
		mov	[NSP], ax
		mov	ax, [USER_SS]
		mov	[NSS], ax
		xor	ax, ax
		mov	byte [FSHARING], al
		test	byte [IsWin386], 1
		jnz	short set_indos_flag
		mov	[USER_ID], ax

set_indos_flag:				; ...
		inc	byte [INDOS]
		mov	[USER_SP], sp
		mov	[USER_SS], ss
		mov	ax, [CurrentPDB]
		mov	[PROC_ID], ax
		mov	ds, ax
		pop	ax
		push	ax
		mov	[2Eh], sp
		mov	word [30h], ss
		mov	ss, [cs:DosDSeg]

REDISP:					; ...
		mov	sp, AUXSTACK
		sti
		mov	bx, ss
		mov	ds, bx
		xchg	ax, bx
		xor	ax, ax
		mov	byte [ss:EXTOPEN_ON], al
		and	word [ss:DOS34_FLAG], 800h
		mov	byte [ss:CONSWAP], al
		mov	byte [ss:NoSetDir], al
		mov	byte [ss:FAILERR], al
		inc	ax
		mov	byte [ss:IDLEINT], al
		xchg	ax, bx
		mov	bl, ah
		shl	bx, 1
		cld
		or	ah, ah
		jz	short DSKROUT
		cmp	ah, 59h
		jz	short DISPCALL
		cmp	ah, 0Ch
		ja	short DSKROUT

IOROUT:
		cmp	byte [ss:ERRORMODE], 0
		jnz	short DISPCALL
		mov	sp, PRINTER_FLAG
		jmp	short DISPCALL
; ---------------------------------------------------------------------------

DSKROUT:				; ...
		mov	[ss:USER_IN_AX], ax
		mov	byte [ss:EXTERR_LOCUS], 1
		mov	byte [ss:ERRORMODE], 0
		mov	byte [ss:WPERR], 0FFh
		push	ax
		mov	ah, 82h
		int	2Ah		; Microsoft Networks - END DOS CRITICAL	SECTIONS 0 THROUGH 7
		pop	ax
		mov	byte [ss:IDLEINT], 0
		mov	sp, DSKSTACK
		test	byte [ss:CNTCFLAG], 0FFh
		jz	short DISPCALL
		push	ax
		call	DSKSTATCHK
		pop	ax

DISPCALL:				; ...
		mov	bx, [cs:DISPATCH+bx]
		xchg	bx, [ss:SAVEBX]
		mov	ds, [ss:SAVEDS]
		call	[ss:SAVEBX]
		and	byte [ss:DOS_FLAG], 0FBh

LeaveDOS:				; ...
		cli
		mov	ds, [cs:DosDSeg]
		cmp	byte [A20OFF_COUNT], 0
		jnz	short disa20

LeaveA20On:				; ...
		dec	byte [INDOS]
		mov	ss, [USER_SS]
		mov	sp, [USER_SP]
		mov	bp, sp
		mov	[bp+0],	al
		mov	ax, [NSP]
		mov	[USER_SP], ax
		mov	ax, [NSS]
		mov	[USER_SS], ax
		pop	ax
		pop	bx
		pop	cx
		pop	dx
		pop	si
		pop	di
		pop	bp
		pop	ds
		pop	es
		iret
; ---------------------------------------------------------------------------

disa20:					; ...
		mov	bx, [A20OFF_PSP]
		cmp	bx, [CurrentPDB]
		jnz	short LeaveA20On
		dec	byte [A20OFF_COUNT]
		push	ds
		mov	bx, disa20_iret
		push	bx
		retf
; END OF FUNCTION CHUNK	FOR STATCHK

; =============== S U B	R O U T	I N E =======================================


restore_world:		; ...
		mov	es, [cs:DosDSeg]
		pop	word [es:RESTORE_TMP]
		pop	ax
		pop	bx
		pop	cx
		pop	dx
		pop	si
		pop	di
		pop	bp
		pop	ds
		jmp	word [es:RESTORE_TMP]


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

save_world:		; ...
		mov	es, [cs:DosDSeg]
		pop	word [es:RESTORE_TMP]
		push	ds
		push	bp
		push	di
		push	si
		push	dx
		push	cx
		push	bx
		push	ax
		push	word [es:RESTORE_TMP]
		push	bp
		mov	bp, sp
		mov	es, word [bp+20]
		pop	bp
		retn


; =============== S U B	R O U T	I N E =======================================


Get_User_Stack:	; ...
		mov	ds, [cs:DosDSeg]
		lds	si, [USER_SP]
		retn


; ---------------------------------------------------------------------------
ERRIN:		db 2			; ...
		db 6
		db 12
		db 4
		db 8
		db 0
ERROUT:		db 80h
		db 40h
		db 2
		db 10h
		db 4
		db 3

; =============== S U B	R O U T	I N E =======================================


AbsSetup:
		inc	byte [ss:INDOS]
		sti
		cld
		push	ds
		push	ss
		pop	ds
		call	GETBP
		jb	short errdriv
		mov	word [es:bp+1Fh], 0FFFFh

errdriv:				; ...
		pop	ds
		jnb	short AbsSetup2

AbsSetup_retn:				; ...
		retn
; ---------------------------------------------------------------------------

AbsSetup2:				; ...
		mov	word [ss:HIGH_SECTOR], 0
		call	RW32_CONVERT
		jb	short AbsSetup_retn
		call	SET_RQ_SC_PARMS
		push	ds
		push	si
		push	ax
		push	ss
		pop	ds
		mov	si, OPENBUF
		mov	[si], al
		add	byte [si], 'A'
		mov	word [si+1], ':'
		mov	ax, 300h
		clc
		int	2Ah		; Microsoft Networks - CHECK DIRECT I/O
					; DS:SI	-> ASCIZ disk device name (may be full path or only drive
					; specifier--must include the colon)
					; Return: CF clear if absolute disk access allowed
		pop	ax
		pop	si
		pop	ds
		jnb	short AbsSetup_retn
		mov	word [ss:EXTERR], 32h
		retn

; ---------------------------------------------------------------------------

ABSDRD:					; ...
		cli
		push	ax
		mov	ax, ds
		mov	ds, [cs:DosDSeg]
		mov	[TEMPSEG], ax
		pop	ax
		push	es
		mov	[AbsRdWr_SS], ss
		mov	[AbsRdWr_SP], sp
		mov	ss, [cs:DosDSeg]
		mov	sp, DSKSTACK
		mov	ds, [TEMPSEG]
		push	es
		call	save_world
		push	es
		call	AbsSetup
		jb	short ILEAVE
		call	ECritDisk
		mov	byte [ss:CurSC_DRIVE], 0FFh
		call	LCritDisk
		call	DSKREAD
		jnz	short ERR_LEAVE
		mov	cx, di
		mov	[ss:TEMP_VAR2], ds
		mov	[ss:TEMP_VAR], bx
		call	DskRdBufScan
		jmp	short ILEAVE
; ---------------------------------------------------------------------------

TLEAVE:					; ...
		jz	short ILEAVE

ERR_LEAVE:				; ...
		push	es
		push	cs
		pop	es
		xor	ah, ah
		mov	cx, 6
		mov	di, ERRIN
		repne scasb
		jnz	short LEAVECODE
		mov	ah, [es:di+5]

LEAVECODE:				; ...
		pop	es
		mov	[ss:AbsDskErr], ax
		stc

ILEAVE:					; ...
		pop	es
		call	restore_world
		pop	es
		cli
		mov	ax, [ss:AbsDskErr]
		dec	byte [ss:INDOS]
		push	ss
		pop	es
		mov	ss, [es:AbsRdWr_SS]
		mov	sp, [es:AbsRdWr_SP]
		pop	es
		sti
		retf
; ---------------------------------------------------------------------------

ABSDWRT:				; ...
		cli
		push	ax
		mov	ax, ds
		mov	ds, [cs:DosDSeg]
		mov	[TEMPSEG], ax
		pop	ax
		push	es
		mov	[AbsRdWr_SS], ss
		mov	[AbsRdWr_SP], sp
		mov	ss, [cs:DosDSeg]
		mov	sp, DSKSTACK
		mov	ds, [TEMPSEG]
		push	es
		call	save_world
		push	es
		call	AbsSetup
		jb	short ILEAVE
		call	ECritDisk
		mov	byte [ss:CurSC_DRIVE], 0FFh
		call	Fastxxx_Purge
		call	LCritDisk
		push	ds
		call	DskWrtBufPurge
		pop	ds
		call	DSKWRITE
		jmp	short TLEAVE

; =============== S U B	R O U T	I N E =======================================


GETBP:
		push	ax
		add	al, 1
		jb	short SKIPGET
		call	GETTHISDRV
		jnb	short SKIPGET
		xor	ah, ah
		cmp	ax, 1Ah
		jz	short SKIPGET
		stc
		mov	word [EXTERR], ax
		mov	word [AbsDskErr], 201h

SKIPGET:				; ...
		pop	ax
		jnb	short GETBP_@f
		retn
; ---------------------------------------------------------------------------

GETBP_@f:				; ...
		les	bp, [THISCDS]
		test	word [es:bp+43h], 8000h
		jz	short GETBP_CDS
		mov	word [EXTERR], 32h ; '2'
		stc
		retn
; ---------------------------------------------------------------------------

GETBP_CDS:				; ...
		les	bp, [es:bp+45h]


; =============== S U B	R O U T	I N E =======================================


GOTDPB:
		mov	word [THISDPB], bp
		mov	word [THISDPB+2], es
		retn

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR $IOCTL

SYS_RET_OK:				; ...
		call	Get_User_Stack
		and	word [si+16h], 0FFFEh
		jmp	short DO_RET
; ---------------------------------------------------------------------------

SYS_RET_ERR:				; ...
		xor	ah, ah
		call	ETAB_LK
		call	ErrorMap

From_GetSet:				; ...
		call	Get_User_Stack
		or	word [si+16h], 1
		stc

DO_RET:					; ...
		mov	[si], ax
		retn
; END OF FUNCTION CHUNK	FOR $IOCTL
; ---------------------------------------------------------------------------

NO_OP:					; ...
		xor	al, al
		retn

; =============== S U B	R O U T	I N E =======================================


FCB_RET_ERR:
		xor	ah, ah
		mov	word [ss:EXTERR], ax
		call	ErrorMap
		mov	al, 0FFh
		retn

; =============== S U B	R O U T	I N E =======================================


ErrorMap:
		push	si
		mov	si, ERR_TABLE_21
		cmp	byte [ss:FAILERR], 0
		jz	short EXTENDED_NORMAL
		mov	word [ss:EXTERR], 53h

EXTENDED_NORMAL:			; ...
		call	CAL_LK
		pop	si
		retn

; =============== S U B	R O U T	I N E =======================================


CAL_LK:
		push	ds
		push	ax
		push	bx
		mov	ds, [cs:DosDSeg]
		mov	bx, [EXTERR]

TABLK1:					; ...
		lodsb
		cmp	al, 0FFh
		jz	short GOT_VALS
		cmp	al, bl
		jz	short GOT_VALS
		add	si, 3
		jmp	short TABLK1
; ---------------------------------------------------------------------------

GOT_VALS:				; ...
		lodsw
		cmp	ah, 0FFh
		jz	short NO_SET_ACT
		mov	byte [EXTERR_ACT_CLASS], ah

NO_SET_ACT:				; ...
		cmp	al, 0FFh
		jz	short NO_SET_CLS
		mov	byte [EXTERR_ACT_CLASS+1], al

NO_SET_CLS:				; ...
		lodsb
		cmp	al, 0FFh
		jz	short NO_SET_LOC
		mov	byte [EXTERR_LOCUS], al

NO_SET_LOC:				; ...
		pop	bx
		pop	ax
		pop	ds
		retn

; =============== S U B	R O U T	I N E =======================================


ETAB_LK:
		push	ds
		push	si
		push	cx
		push	bx
		push	ss
		pop	ds
		mov	word [EXTERR], ax
		mov	si, I21_MAP_E_TAB
		mov	bh, al
		mov	bl, byte [USER_IN_AX+1]

TABLK2:					; ...
		;lods	word [cs:si]
		cs	lodsw
		cmp	al, 0FFh
		jz	short NOT_IN_TABLE
		cmp	al, bl
		jz	short GOT_CALL
		xchg	ah, al
		xor	ah, ah
		add	si, ax
		jmp	short TABLK2
; ---------------------------------------------------------------------------

NOT_IN_TABLE:				; ...
		mov	al, bh
		jmp	short NO_MAP
; ---------------------------------------------------------------------------

GOT_CALL:				; ...
		mov	cl, ah
		xor	ch, ch

CHECK_CODE:				; ...
		;lods	byte [cs:si]
		cs	lodsb	
		cmp	al, bh
		jz	short NO_MAP
		loop	CHECK_CODE

NO_MAP:					; ...
		xor	ah, ah
		pop	bx
		pop	cx
		pop	si
		pop	ds
		retn

; =============== S U B	R O U T	I N E =======================================


SetBad:
		mov	ax, 1
		push	ds
		mov	ds, [cs:DosDSeg]
		mov	byte [EXTERR_LOCUS], 1
		pop	ds
		stc
		retn

; =============== S U B	R O U T	I N E =======================================


BadCall:
		call	SetBad
		retf

; =============== S U B	R O U T	I N E =======================================


OKCall:
		clc
		retf

; ---------------------------------------------------------------------------

INT2F:					; ...
		sti
		cmp	ah, 11h		; MultNET
		jnz	short INT2FSHR

TestInstall:				; ...
		or	al, al
		jz	short Leave2F

BadFunc:				; ...
		call	SetBad

Leave2F:				; ...
		retf	2
; ---------------------------------------------------------------------------

INT2FSHR:				; ...
		cmp	ah, 10h		; MultSHARE
		jz	short TestInstall
		cmp	ah, 14h		; NLSFUNC
		jz	short TestInstall
		cmp	ah, 12h		; MultDOS
		jnz	short check_win
		jmp	DispatchDOS
; ---------------------------------------------------------------------------

check_win:				; ...
		cmp	ah, 16h
		jz	short Win386_Msg
		cmp	ah, 46h	; 'F'
		jnz	short next_i2f
		jmp	Winold_swap
; ---------------------------------------------------------------------------

next_i2f:				; ...
		jmp	70h:05h
; ---------------------------------------------------------------------------

Win386_Msg:				; ...
		push	ds
		mov	ds, [cs:DosDSeg]
		cmp	al, 3
		jnz	short Win386_Msg_exit
		jmp	OldWin386Init
; ---------------------------------------------------------------------------

Win386_Msg_exit:			; ...
		cmp	al, 6
		jnz	short Win386_Msg_devcall
		jmp	Win386_Leaving
; ---------------------------------------------------------------------------

Win386_Msg_devcall:			; ...
		cmp	al, 7
		jnz	short Win386_Msg_init
		jmp	Win386_Query
; ---------------------------------------------------------------------------

Win386_Msg_init:			; ...
		cmp	al, 5
		jz	short Win386_Starting
		jmp	win_nexti2f
; ---------------------------------------------------------------------------

Win386_Starting:			; ...
		test	dx, 1
		jz	short Win386_vchk
		jmp	win_nexti2f
; ---------------------------------------------------------------------------

Win386_vchk:				; ...
		mov	word [Win386_Info_6], 0
		mov	word [Win386_Info_6+2], 0
		cmp	di, 30Ah
		jb	short Win386_vxd
		jmp	noVxD31
; ---------------------------------------------------------------------------

Win386_vxd:				; ...
		push	ax
		push	bx
		push	cx
		push	dx
		push	si
		push	di
		mov	bx, [8Ch]	; UMB_HEAD
		cmp	bx, 0FFFFh
		jz	short Vxd31
		mov	byte [UmbSaveFlag], 1
		push	ds
		push	es
		mov	ax, ds
		mov	es, ax
		mov	ds, bx
		xor	si, si
		cld
		mov	di, UmbSave1
		mov	cx, 11
		rep movsb
		mov	di, UmbSave2
		mov	cx, 5
		rep movsb
		pop	es
		pop	ds

Vxd31:					; ...
		test	byte [DOS_FLAG], 2
		jz	short Dont_Supress
		pop	di
		pop	si
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		jmp	short noVxD31
; ---------------------------------------------------------------------------

Dont_Supress:				; ...
		mov	al, [BOOTDRIVE]
		add	al, 40h		; 'A'-1
		mov	[VxDpath], al
		mov	ah, 6Ch
		mov	al, 0
		mov	bx, 2080h
		mov	cx, 7
		mov	dx, 1
		mov	si, VxDpath ; "c:\\wina20.386"
		mov	di, 0FFFFh
		int	21h		; DOS -	4.0 - EXTENDED OPEN/CREATE
					; BL = open mode as in AL for normal open (INT 21h/AH=3Dh)
					; BH = flags, CX = create attribute, DL	= action if file exists/does not exists
					; DH = 00h (reserved), [SI ->	ASCIZ file name
		pop	di
		pop	si
		pop	dx
		pop	cx
		jnb	short VxDthere
		push	dx
		push	ds
		push	si
		mov	si, NoVxDErrMsg ; "You must have	the file WINA20.386 in th"...
		push	cs
		pop	ds
		mov	cx, 99
		mov	ah, 2
		cld

vxdlp:					; ...
		lodsb
		xchg	dl, al
		int	21h		; DOS -
		loop	vxdlp
		pop	si
		pop	ds
		pop	dx
		pop	bx
		pop	ax
		inc	cx
		jmp	win_nexti2f
; ---------------------------------------------------------------------------

VxDthere:				; ...
		mov	bx, ax
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		mov	bx, Win386_Info
		mov	word [bx+6], VxDpath ; "c:\\wina20.386"
		mov	word [bx+8], ds
		pop	bx
		pop	ax

noVxD31:				; ...
		or	byte [IsWin386], 1
		or	byte [redir_patch], 1
		push	dx
		mov	dx, bx
		mov	bx, Win386_Info
		mov	[bx+2],	dx
		mov	word [bx+4], es
		pop	dx
		push	ds
		pop	es
		jmp	win_nexti2f
; ---------------------------------------------------------------------------

Win386_Leaving:				; ...
		test	dx, 1
		jz	short Win386_Leaving_c
		jmp	win_nexti2f
; ---------------------------------------------------------------------------

Win386_Leaving_c:			; ...
		cmp	byte [UmbSaveFlag], 1
		jnz	short noumb
		mov	byte [UmbSaveFlag], 0
		push	ax
		push	es
		push	cx
		push	si
		push	di
		mov	ax, [8Ch]	; UMB_HEAD
		mov	es, ax
		xor	di, di
		cld
		mov	si, UmbSave1
		mov	cx, 11
		rep movsb
		mov	si, UmbSave2
		mov	cx, 5
		rep movsb
		pop	di
		pop	si
		pop	cx
		pop	es
		pop	ax

noumb:					; ...
		and	byte [IsWin386], 0
		and	byte [redir_patch], 0
		jmp	short win_nexti2f
; ---------------------------------------------------------------------------

Win386_Query:				; ...
		cmp	bx, 15h
		jnz	short win_nexti2f
		or	cx, cx
		jnz	short dosmgr_func
		inc	cx
		mov	bx, Win386_DOSVars
		push	ds
		pop	es
		jmp	short PopIret
; ---------------------------------------------------------------------------

OldWin386Init:				; ...
		pop	ax
		mov	si, OldInstanceJunk
		mov	ax, 5248h
		jmp	next_i2f
; ---------------------------------------------------------------------------

dosmgr_func:				; ...
		dec	cx
		jz	short win386_patch
		dec	cx
		jz	short PopIret
		dec	cx
		jz	short win386_size
		dec	cx
		jz	short win386_inst
		dec	cx
		jnz	short PopIret
		mov	ax, es
		dec	ax
		push	es
		mov	es, ax
		cmp	byte [es:di], 'D'
		jnz	short cantsize
		inc	ax
		cmp	[es:di+1], ax
		jnz	short cantsize
		mov	ax, [es:di+3]
		pop	es
		mov	bx, 16
		mul	bx
		mov	cx, ax
		mov	bx, dx
		jmp	short win386_done
; ---------------------------------------------------------------------------

cantsize:				; ...
		pop	es
		xor	ax, ax
		xor	dx, dx
		jmp	short PopIret
; ---------------------------------------------------------------------------

win386_patch:				; ...
		mov	bx, dx
		jmp	short win386_done
; ---------------------------------------------------------------------------

win386_size:				; ...
		test	dx, 1
		jz	short PopIret
		mov	cx, 88
		jmp	short win386_done
; ---------------------------------------------------------------------------

win386_inst:				; ...
		xor	dx, dx
		jmp	short PopIret
; ---------------------------------------------------------------------------

win386_done:				; ...
		mov	ax, 0B97Ch	; WIN_OP_DONE
		mov	dx, 0A2ABh	; DOSMGR_OP_DONE

PopIret:				; ...
		pop	ds
		iret
; ---------------------------------------------------------------------------

win_nexti2f:				; ...
		pop	ds
		jmp	next_i2f

; =============== S U B	R O U T	I N E =======================================


getwinlast:
		mov	si, [CurrentPDB]
		dec	si
		mov	es, si
		add	si, [es:3]
		retn

; ---------------------------------------------------------------------------

Winold_swap:				; ...
		push	ds
		push	es
		push	si
		push	di
		push	cx
		mov	ds, [cs:DosDSeg]
		cmp	al, 1
		jnz	short swapin
		call	getwinlast
		push	ds
		pop	es
		mov	ds, si
		xor	si, si
		mov	di, WinoldPatch1
		mov	cx, 8
		cld
		push	cx
		rep movsb
		pop	cx
		mov	di, WinoldPatch2
		rep movsb
		jmp	short winold_done
; ---------------------------------------------------------------------------

swapin:					; ...
		cmp	al, 2
		jnz	short winold_done
		call	getwinlast
		mov	es, si
		xor	di, di
		mov	si, WinoldPatch1
		mov	cx, 8
		cld
		push	cx
		rep movsb
		pop	cx
		mov	si, WinoldPatch2
		rep movsb

winold_done:				; ...
		pop	cx
		pop	di
		pop	si
		pop	es
		pop	ds
		jmp	next_i2f
; ---------------------------------------------------------------------------

DispatchDOS:				; ...
		push	word [cs:FOO]
		push	word [cs:DTab]
		push	ax
		push	bp
		mov	bp, sp
		mov	ax, [bp+0Eh]
		pop	bp
		call	TableDispatch
		jmp	BadFunc
; ---------------------------------------------------------------------------

DOSGetGroup:				; ...
		mov	ds, [cs:DosDSeg]
		retn
; ---------------------------------------------------------------------------

DOSInstall:				; ...
		mov	al, 0FFh
		retn

; =============== S U B	R O U T	I N E =======================================


RW32_CONVERT:
		cmp	cx, 0FFFFh
		jz	short new32format
		push	ax
		push	dx
		mov	ax, [es:bp+0Dh]
		mov	dl, [es:bp+4]
		cmp	dl, 0FEh ; 'þ'
		jz	short letold
		inc	dl
		xor	dh, dh
		mul	dx
		or	dx, dx

letold:					; ...
		pop	dx
		pop	ax
		jz	short old_style
		push	ds
		mov	ds, [cs:DosDSeg]
		mov	word [AbsDskErr], 207h
		pop	ds
		stc
		retn
; ---------------------------------------------------------------------------

new32format:				; ...
		mov	dx, [bx+2]
		push	ds
		mov	ds, [cs:DosDSeg]
		mov	word [HIGH_SECTOR],	dx
		pop	ds
		mov	dx, [bx]
		mov	cx, [bx+4]
		lds	bx, [bx+6]

old_style:				; ...
		clc
		retn

; =============== S U B	R O U T	I N E =======================================


Fastxxx_Purge:
		push	ax
		push	si
		push	dx
		push	ds
		mov	ds, [cs:DosDSeg]
		test	byte [FastOpenFlg], 80h
		pop	ds
		jz	short nofast
		mov	ah, 1
		mov	al, 5
		mov	dl, [es:bp+0]
		call	Fast_Dispatch

nofast:					; ...
		pop	dx
		pop	si
		pop	ax
		retn

; ---------------------------------------------------------------------------
DIVMES:		db 0Dh,0Ah		; ...
		db 'Divide overflow',0Dh,0Ah
DivMesLen:	dw 19			; ...
NoVxDErrMsg:	db 'You must have the file WINA20.386 in the root of your boot drive',0Dh ; ...
		db 0Ah
		db 'to run Windows in Enhanced Mode',0Dh,0Ah
NLS_YES:	db 'Y'                  ; ...
NLS_NO:		db 'N'                  ; ...
NLS_yes2:	db 'y'                  ; ...
NLS_no2:	db 'n'                  ; ...
CANCHAR:	db 1Bh			; ...
ESCCHAR:	db 0			; ...
ESCTAB:		db 64, 77, 59, 83, 60, 62, 2 dup(61), 63, 75, 2	dup(82)	; ...
		db 2 dup(65)
ESCFUNC:	dw GETCH		; ...
		dw TWOESC
		dw EXITINS_ENTERINS
		dw EXITINS_ENTERINS
		dw BACKSP
		dw REEDIT
		dw KILNEW
		dw COPYLIN
		dw SKIPSTR
		dw COPYSTR
		dw SKIPONE
		dw COPYONE
		dw COPYONE
		dw CTRLZ
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR $STD_CON_STRING_INPUT

OEMFunctionKey:				; ...
		call	$STD_CON_INPUT_NO_ECHO
		mov	cl, 14
		push	di
		mov	di, ESCTAB
		push	es
		push	cs
		pop	es
		repne scasb
		pop	es
		pop	di
		shl	cx, 1
		mov	bp, cx
		jmp	word [cs:ESCFUNC+bp]
; END OF FUNCTION CHUNK	FOR $STD_CON_STRING_INPUT
; ---------------------------------------------------------------------------

$GET_DATE:				; ...
		push	ss
		pop	ds
		call	READTIME
		mov	ax, [YEAR]
		mov	bx, word [DAY]
		call	Get_User_Stack
		mov	[si+6],	bx
		add	ax, 1980
		mov	[si+4],	ax
		mov	al, [ss:WEEKDAY]

_RET24:					; ...
		retn
; ---------------------------------------------------------------------------

$SET_DATE:				; ...
		mov	al, -1
		sub	cx, 1980
		jb	short _RET24
		cmp	cx, 119
		ja	short RET24
		or	dh, dh
		jz	short _RET24
		or	dl, dl
		jz	short _RET24
		cmp	dh, 12
		ja	short RET24
		push	ss
		pop	ds
		call	DODATE

RET24:					; ...
		retn
; ---------------------------------------------------------------------------

$GET_TIME:				; ...
		push	ss
		pop	ds
		call	READTIME
		call	Get_User_Stack
		mov	[si+6],	dx
		mov	[si+4],	cx
		xor	al, al

RET26:					; ...
		retn
; ---------------------------------------------------------------------------

$SET_TIME:				; ...
		mov	al, -1
		cmp	ch, 24
		jnb	short RET26
		cmp	cl, 60
		jnb	short RET26
		cmp	dh, 60
		jnb	short RET26
		cmp	dl, 100
		jnb	short RET26
		push	cx
		push	dx
		push	ss
		pop	ds
		mov	bx, TIMEBUF
		mov	cx, 6
		xor	dx, dx
		mov	ax, dx
		push	bx
		call	SETREAD
		push	ds
		lds	si, [BCLOCK]
		call	DEVIOCALL2
		pop	ds
		pop	bx
		call	SETWRITE
		pop	word [TIMEBUF+4]
		pop	word [TIMEBUF+2]
		lds	si, [BCLOCK]
		call	DEVIOCALL2
		xor	al, al
		retn

; =============== S U B	R O U T	I N E =======================================


DATE16	:
		mov	ds, [cs:DosDSeg]
		push	cx
		push	es
		call	READTIME
		pop	es
		shl	cl, 1
		shl	cl, 1
		shl	cx, 1
		shl	cx, 1
		shl	cx, 1
		shr	dh, 1
		or	cl, dh
		mov	dx, cx
		mov	ax, word [MONTH]
		mov	cl, 4
		shl	al, cl
		shl	ax, 1
		pop	cx
		or	al, [DAY]

RET21:					; ...
		retn

; =============== S U B	R O U T	I N E =======================================


READTIME:
		mov	word [DATE_FLAG], 0
		push	si
		push	bx
		mov	bx, TIMEBUF
		mov	cx, 6
		xor	dx, dx
		mov	ax, dx
		call	SETREAD
		push	ds
		lds	si, [BCLOCK]
		call	DEVIOCALL2
		pop	ds
		pop	bx
		pop	si
		mov	ax, [TIMEBUF]
		mov	cx, [TIMEBUF+2]
		mov	dx, [TIMEBUF+4]
		cmp	ax, [DAYCNT]
		jz	short RET21
		cmp	ax, 43830	; FOURYEARS*30
		jnb	short RET22
		mov	[DAYCNT], ax
		push	si
		push	cx
		push	dx
		xor	dx, dx
		mov	cx, 1461	; FOURYEARS
		div	cx
		shl	ax, 1
		shl	ax, 1
		shl	ax, 1
		mov	cx, ax
		mov	si, YRTAB
		call	DSLIDE
		shr	cx, 1
		jnb	short SK
		add	dx, 200

SK:					; ...
		call	SETYEAR
		mov	cl, 1
		mov	si, MONTAB
		call	DSLIDE
		mov	[MONTH], cl
		inc	dx
		mov	[DAY], dl
		call	WKDAY
		pop	dx
		pop	cx
		pop	si

RET22:					; ...
		retn

; =============== S U B	R O U T	I N E =======================================


DSLIDE	:
		mov	ah, 0

DSLIDE1:				; ...
		lodsb
		cmp	dx, ax
		jb	short RET22
		sub	dx, ax
		inc	cx
		jmp	short DSLIDE1


; =============== S U B	R O U T	I N E =======================================


SETYEAR	:
		mov	ds, [cs:DosDSeg]
		mov	byte [YEAR], cl

CHKYR:					; ...
		test	cl, 3
		mov	al, 28
		jnz	short SAVFEB
		inc	al

SAVFEB:					; ...
		mov	[february], al

RET23:					; ...
		retn

; =============== S U B	R O U T	I N E =======================================


DODATE	:
		call	CHKYR
		mov	al, dh
		mov	bx, YRTAB+7 ; MONTAB-1
		xlat
		cmp	al, dl
		mov	al, -1
		jb	short RET23
		call	SETYEAR
		mov	word [DAY], dx
		shr	cx, 1
		shr	cx, 1
		mov	ax, 1461
		mov	bx, dx
		mul	cx
		mov	cl, byte [YEAR]
		and	cl, 3
		mov	si, YRTAB
		mov	dx, ax
		shl	cx, 1
		call	DSUM
		mov	cl, bh
		mov	si, MONTAB
		dec	cx
		call	DSUM
		mov	cl, bl
		dec	cx
		add	dx, cx
		xchg	ax, dx
		mov	[DAYCNT], ax
		push	si
		push	bx
		push	ax
		mov	bx, TIMEBUF
		mov	cx, 6
		xor	dx, dx
		mov	ax, dx
		push	bx
		call	SETREAD
		push	ds
		lds	si, [BCLOCK]
		call	DEVIOCALL2
		pop	ds
		pop	bx
		call	SETWRITE
		pop	word [TIMEBUF]
		push	ds
		lds	si, [BCLOCK]
		call	DEVIOCALL2
		pop	ds
		pop	bx
		pop	si

WKDAY:					; ...
		mov	ax, [DAYCNT]
		xor	dx, dx
		mov	cx, 7
		inc	ax
		inc	ax
		div	cx
		mov	[WEEKDAY], dl
		xor	al, al
		retn

; =============== S U B	R O U T	I N E =======================================


DSUM	:
		mov	ah, 0
		jcxz	DSUM9

DSUM1:					; ...
		lodsb
		add	dx, ax
		loop	DSUM1

DSUM9:					; ...
		retn

; ---------------------------------------------------------------------------

$GET_VERSION:				; ...
		push	ss
		pop	ds
		mov	bx, word [USERNUM_hb]
		mov	cx, [USERNUM]
		cmp	al, 1
		jnz	short norm_vers
		xor	bh, bh

norm_vers:				; ...
		push	ds
		mov	ds, [CurrentPDB]
		mov	ax, [40h]	; PDB.Version
		pop	ds
		call	Get_User_Stack
		mov	[si], ax
		mov	[si+2],	bx
		mov	[si+4],	cx
		retn
; ---------------------------------------------------------------------------

$GET_VERIFY_ON_WRITE:			; ...
		mov	al, [ss:VERFLG]
		retn
; ---------------------------------------------------------------------------

$SET_VERIFY_ON_WRITE:			; ...
		and	al, 1
		mov	[ss:VERFLG], al

; =============== S U B	R O U T	I N E =======================================


RET27:
		retn

; ---------------------------------------------------------------------------

$INTERNATIONAL:				; ...
		cmp	al, 0FFh
		jz	short BX_HAS_CODE
		mov	bl, al
		xor	bh, bh

BX_HAS_CODE:				; ...
		push	ds
		pop	es
		push	dx
		pop	di
		push	ss
		pop	ds
		cmp	di, 0FFFFh
		jz	short international_set
		or	bx, bx
		jnz	short international_find
		mov	si, COUNTRY_CDPG
		jmp	short international_copy
; ---------------------------------------------------------------------------

international_find:			; ...
		mov	bp, 0
		call	international_get
		jb	short errtn
		cmp	bx, 0
		jnz	short international_copy
		mov	bx, dx
		jmp	short international_ok3

; =============== S U B	R O U T	I N E =======================================


international_get:
		mov	si, COUNTRY_CDPG
		cmp	bx, [ss:si+68h]
		jz	short RET27
		mov	dx, bx
		xor	bx, bx
		mov	ax, 1400h
		int	2Fh		; - Multiplex -	NLSFUNC.COM - INSTALLATION CHECK
					; Return: AL = 00h not installed, OK to	install
					; 01h not installed, not OK
					; FFh installed
		cmp	al, 0FFh
		jnz	short interr
		or	bp, bp
		jnz	short stcdpg
		mov	ax, 1404h
		int	2Fh		; - Multiplex -	NLSFUNC.COM - GET COUNTRY INFO
					; BX = code page, DX = country code, [SI -> internal code page structure
					; ES:DI	-> user	buffer
					; Return: AL = status
		jmp	short chkok
; ---------------------------------------------------------------------------

stcdpg:					; ...
		mov	ax, 1403h
		int	2Fh		; - Multiplex -	NLSFUNC.COM - SET COUNTRY INFO
					; DS:SI	-> internal code page structure
					; BX = code page, DX = country code
					; Return: AL = status

chkok:					; ...
		or	al, al
		jz	short RET27

setcarry:				; ...
		stc
		retn
; ---------------------------------------------------------------------------

interr:					; ...
		mov	al, 0FFh
		jmp	short setcarry

; ---------------------------------------------------------------------------

international_copy:			; ...
		mov	bx, [ss:si+68h]
		mov	si, COUNTRY_CDPG_108
		mov	cx, 24
		push	ds
		push	ss
		pop	ds
		rep movsb
		pop	ds

international_ok3:			; ...
		call	Get_User_Stack
		mov	[si+2],	bx

international_ok:			; ...
		mov	ax, bx

SYS_RET_OK_jmp:				; ...
		jmp	SYS_RET_OK
; ---------------------------------------------------------------------------

international_set:			; ...
		mov	bp, 1
		call	international_get
		jnb	short international_ok

errtn:					; ...
		cmp	al, 0FFh
		jz	short errtn2

errtn1:					; ...
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

errtn2:					; ...
		mov	al, 1
		jmp	short errtn1
; ---------------------------------------------------------------------------

$GetExtCntry:				; ...
		cmp	al, 20h	; ' '
		jb	short notcap
		test	al, 80h
		jnz	short fileupper
		mov	bx, UCASE_TAB_2
		jmp	short capit
; ---------------------------------------------------------------------------

fileupper:				; ...
		mov	bx, FILE_UCASE_TAB_2

capit:					; ...
		cmp	al, 20h	; ' '
		jnz	short chkyes
		mov	al, dl
		call	GETLET3
		call	Get_User_Stack
		mov	[si+6],	al
		jmp	short nono
; ---------------------------------------------------------------------------

chkyes:					; ...
		cmp	al, 23h
		jnz	short capstring
		xor	ax, ax
		cmp	dl, [cs:NLS_YES]
		jz	short yesyes
		cmp	dl, [cs:NLS_yes2]
		jz	short yesyes
		cmp	dl, [cs:NLS_NO]
		jz	short nono
		cmp	dl, [cs:NLS_no2]
		jz	short nono
		inc	ax

yesyes:					; ...
		inc	ax

nono:					; ...
		jmp	short SYS_RET_OK_jmp
; ---------------------------------------------------------------------------

capstring:				; ...
		mov	si, dx
		cmp	al, 21h
		jnz	short capascii
		or	cx, cx
		jz	short nono

concap:					; ...
		lodsb
		call	GETLET3
		mov	[si-1],	al
		loop	concap
		jmp	short nono
; ---------------------------------------------------------------------------

capascii:				; ...
		cmp	al, 22h
		jnz	short capinval

concap2:				; ...
		lodsb
		or	al, al
		jz	short nono
		call	GETLET3
		mov	[si-1],	al
		jmp	short concap2
; ---------------------------------------------------------------------------

notcap:					; ...
		cmp	cx, 5
		jb	short sizeerror
		push	ss
		pop	ds
		mov	si, COUNTRY_CDPG
		cmp	dx, 0FFFFh
		jnz	short GETCDPG
		mov	dx, [si+68h]

GETCDPG:				; ...
		cmp	bx, 0FFFFh
		jnz	short CHKAGAIN
		mov	bx, [si+6Ah]

CHKAGAIN:				; ...
		cmp	dx, [si+68h]
		jnz	short CHKNLS
		cmp	bx, [si+6Ah]
		jnz	short CHKNLS
		mov	bx, [si+48h]
		push	cx
		mov	cx, [si+4Ah]
		mov	si, COUNTRY_CDPG_76

NXTENTRY:				; ...
		cmp	al, [si]
		jz	short FOUNDIT
		add	si, 5
		loop	NXTENTRY
		pop	cx

capinval:				; ...
		mov	al, 1

SYS_RET_ERR_jmp:			; ...
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

FOUNDIT:				; ...
		movsb
		pop	cx
		cmp	al, 1
		jz	short setsize
		mov	cx, 4
		mov	ax, 5

OK_RETN:				; ...
		rep movsb
		mov	cx, ax
		mov	ax, bx

GETDONE:				; ...
		call	Get_User_Stack
		mov	[si+4],	cx

jmp_to_nono:				; ...
		jmp	short nono
; ---------------------------------------------------------------------------

setsize:				; ...
		sub	cx, 3
		cmp	[si], cx
		jnb	short setsize2
		mov	cx, [si]

setsize2:				; ...
		mov	[es:di], cx
		add	di, 2
		add	si, 2
		mov	ax, cx
		add	ax, 3
		jmp	short OK_RETN
; ---------------------------------------------------------------------------

CHKNLS:					; ...
		xor	ah, ah
		push	ax
		pop	bp
		mov	ax, 1400h
		int	2Fh		; - Multiplex -	NLSFUNC.COM - INSTALLATION CHECK
					; Return: AL = 00h not installed, OK to	install
					; 01h not installed, not OK
					; FFh installed
		cmp	al, 0FFh
		jz	short NLSNXT

sizeerror:				; ...
		mov	al, 1

sizeerror_jmp:				; ...
		jmp	short SYS_RET_ERR_jmp
; ---------------------------------------------------------------------------

NLSNXT:					; ...
		mov	ax, 1402h
		int	2Fh		; - Multiplex -	NLSFUNC.COM - GET COUNTRY INFO
					; BP = subfunction, BX = code page
					; DX = country code, [SI -> internal code page structure
					; ES:DI	-> user	buffer,	CX = size of user buffer
					; Return: AL = status
					; 00h successful
					; else DOS error code
		cmp	al, 0
		jnz	short NLSERROR
		mov	ax, [si+48h]
		jmp	short GETDONE
; ---------------------------------------------------------------------------

NLSERROR:				; ...
		jmp	short sizeerror_jmp
; ---------------------------------------------------------------------------

$GetSetCdPg:				; ...
		push	ss
		pop	ds
		mov	si, COUNTRY_CDPG
		cmp	al, 1
		jnz	short setglpg
		mov	bx, [si+6Ah]
		mov	dx, [si+48h]
		call	Get_User_Stack
		mov	[si+2],	bx
		mov	[si+6],	dx

OK_RETURN:				; ...
		jmp	short jmp_to_nono
; ---------------------------------------------------------------------------

setglpg:				; ...
		cmp	al, 2
		jnz	short nomem
		mov	dx, [si+68h]
		mov	ax, 1400h
		int	2Fh		; - Multiplex -	NLSFUNC.COM - INSTALLATION CHECK
					; Return: AL = 00h not installed, OK to	install
					; 01h not installed, not OK
					; FFh installed
		cmp	al, 0FFh
		jnz	short nomem
		mov	ax, 1401h
		int	2Fh		; - Multiplex -	NLSFUNC.COM - CHANGE CODE PAGE
					; DS:SI	-> internal code page structure
					; BX = new code	page, DX = country code???
					; Return: AL = status
					; 00h successful
					; else DOS error code
		or	al, al
		jz	short OK_RETURN
		cmp	al, 65
		jnz	short seterr
		mov	ax, 65
		mov	word [EXTERR], ax
		mov	byte [EXTERR_ACT_CLASS], 6
		mov	byte [EXTERR_ACT_CLASS+1], 5
		mov	byte [EXTERR_LOCUS], 4
		jmp	From_GetSet
; ---------------------------------------------------------------------------

seterr:					; ...
		jmp	short NLSERROR
; ---------------------------------------------------------------------------

nomem:					; ...
		mov	al, 1
		jmp	short seterr
; ---------------------------------------------------------------------------

$GET_DRIVE_FREESPACE:			; ...
		push	ss
		pop	ds
		mov	al, dl
		call	GETTHISDRV

SET_AX_RET:				; ...
		jb	short BADFDRV
		call	DISK_INFO
		xchg	dx, bx
		jb	short SET_AX_RET
		xor	ah, ah

DoSt:					; ...
		call	Get_User_Stack
		mov	[si+6],	dx
		mov	[si+4],	cx
		mov	[si+2],	bx
		mov	[si], ax
		retn
; ---------------------------------------------------------------------------

BADFDRV:				; ...
		call	FCB_RET_ERR
		mov	ax, -1
		jmp	short DoSt
; ---------------------------------------------------------------------------

$GET_DMA:				; ...
		mov	bx, word [ss:DMAADD]
		mov	cx, word [ss:DMAADD+2]
		call	Get_User_Stack
		mov	[si+2],	bx
		mov	[si+10h], cx
		retn
; ---------------------------------------------------------------------------

$SET_DMA:				; ...
		mov	word [ss:DMAADD], dx
		mov	word [ss:DMAADD+2], ds
		retn
; ---------------------------------------------------------------------------

$GET_DEFAULT_DRIVE:			; ...
		mov	al, [ss:CURDRV]
		retn
; ---------------------------------------------------------------------------

$SET_DEFAULT_DRIVE:			; ...
		mov	al, dl
		inc	al
		call	GetVisDrv
		jb	short SETRET
		mov	[ss:CURDRV], al

SETRET:					; ...
		mov	al, [ss:CDSCOUNT]
		retn

; =============== S U B	R O U T	I N E =======================================


$GET_INTERRUPT_VECTOR:
		call	RECSET
		les	bx, [es:bx]
		call	Get_User_Stack
		mov	[si+2],	bx
		mov	word [si+10h], es
		retn

; ---------------------------------------------------------------------------

$SET_INTERRUPT_VECTOR:			; ...
		call	RECSET
		cli
		mov	[es:bx], dx
		mov	word [es:bx+2], ds
		sti
		test	byte [ss:DOS_FLAG], 4
		jnz	short siv_1
		retn
; ---------------------------------------------------------------------------

siv_1:					; ...
		cmp	byte [ss:A20OFF_COUNT], 0
		jnz	short siv_2
		mov	byte [ss:A20OFF_COUNT], 1

siv_2:					; ...
		retn

; =============== S U B	R O U T	I N E =======================================


RECSET:
		xor	bx, bx
		mov	es, bx
		mov	bl, al
		shl	bx, 1
		shl	bx, 1
		retn

; ---------------------------------------------------------------------------

$CHAR_OPER:				; ...
		or	al, al
		mov	dl, '/'
		jz	short chop_1
		cmp	al, 2
		mov	dl, 0FFh
		jz	short chop_1
		retn
; ---------------------------------------------------------------------------

chop_1:					; ...
		call	Get_User_Stack
		mov	[si+6],	dx
		retn
; ---------------------------------------------------------------------------

$GetExtendedError:			; ...
		push	ss
		pop	ds
		mov	ax, [EXTERR]
		les	di, [EXTERRPT]
		mov	bx, [EXTERR_ACT_CLASS]
		mov	ch, [EXTERR_LOCUS]
		call	Get_User_Stack
		mov	[si+0Ah], di
		mov	word [si+10h], es
		mov	[si+2],	bx
		mov	[si+4],	cx

jmp_SYS_RET_OK:				; ...
		jmp	SYS_RET_OK
; ---------------------------------------------------------------------------
		push	si
		mov	si, COUNTRY_CDPG
		mov	ax, [ss:si+6Ah]
		pop	si
		retn
; ---------------------------------------------------------------------------

$ECS_Call:				; ...
		or	al, al
		jnz	short _okok
		call	Get_User_Stack
		mov	word [si+8],	DBCS_TAB_2
		push	es
		mov	es, [cs:DosDSeg]
		mov	word [si+14], es
		pop	es

_okok:					; ...
		jmp	short jmp_SYS_RET_OK
; ---------------------------------------------------------------------------

$PARSE_FILE_DESCRIPTOR:			; ...
		call	MAKEFCB
		push	si
		call	Get_User_Stack
		pop	word [si+8]
		retn
; ---------------------------------------------------------------------------

$SLEAZEFUNC:				; ...
		mov	dl, 0

$SLEAZEFUNCDL:				; ...
		push	ss
		pop	ds
		mov	al, dl
		call	GETTHISDRV

SET_AL_RET:				; ...
		jb	short BADSLDRIVE
		call	DISK_INFO
		jb	short SET_AL_RET
		mov	byte [FATBYTE], ah
		mov	di, FATBYTE
		xor	ah, ah
		call	Get_User_Stack
		mov	[si+4],	cx
		mov	[si+6],	bx
		mov	[si+2],	di
		mov	word [si+0Eh], ss
		retn
; ---------------------------------------------------------------------------

BADSLDRIVE:				; ...
		jmp	FCB_RET_ERR
; ---------------------------------------------------------------------------

$GET_INDOS_FLAG:			; ...
		call	Get_User_Stack
		mov	word [si+2],	INDOS
		mov	word [si+10h], ss
		retn
; ---------------------------------------------------------------------------

$GET_IN_VARS:				; ...
		call	Get_User_Stack
		mov	word [si+2],	DPBHEAD	; SYSINITVARS
		mov	word [si+10h], ss
		retn
; ---------------------------------------------------------------------------

$GET_DEFAULT_DPB:			; ...
		mov	dl, 0

$GET_DPB:				; ...
		push	ss
		pop	ds
		mov	al, dl
		call	GETTHISDRV
		jb	short ISNODRV
		les	di, [THISCDS]
		test	byte [es:di+44h], 80h
		jnz	short ISNODRV
		call	ECritDisk
		call	FATREAD_CDS
		call	LCritDisk
		jb	short ISNODRV
		call	Get_User_Stack
		mov	[si+2],	bp
		mov	word [si+0Eh], es
		xor	al, al
		retn
; ---------------------------------------------------------------------------

ISNODRV:				; ...
		mov	al, 0FFh
		retn
; ---------------------------------------------------------------------------

$DISK_RESET:				; ...
		mov	al, 0FFh
		push	ss
		pop	ds
		call	ECritDisk
		or	word [DOS34_FLAG], 4
		call	FLUSHBUF
		and	word [DOS34_FLAG], 0FFFBh
		mov	word [SC_STATUS], 0
		mov	bx, 0FFFFh
		mov	word [LastBuffer+2], bx
		mov	word [LastBuffer], bx
		call	LCritDisk
		mov	ax, 0FFFFh
		push	ax
		mov	ax, 1120h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - FLUSH ALL DISK BUFFERS
					; DS = DOS CS
					; Return: CF clear (successful)
		pop	ax
		retn
; ---------------------------------------------------------------------------
word3		dw 3			; ...

; =============== S U B	R O U T	I N E =======================================


$SETDPB	:
		mov	di, bp
		add	di, 2
		lodsw
		stosw
		cmp	byte [si+3], 0
		jnz	short yesfat
		mov	byte [es:di+4], 0
		jmp	short setend
; ---------------------------------------------------------------------------

yesfat:					; ...
		mov	dx, ax
		lodsb
		dec	al
		stosb
		inc	al
		xor	ah, ah

LOG2LOOP:				; ...
		test	al, 1
		jnz	short SAVLOG
		inc	ah
		shr	al, 1
		jmp	short LOG2LOOP
; ---------------------------------------------------------------------------

SAVLOG:					; ...
		mov	al, ah
		stosb
		mov	bl, al
		movsw
		lodsb
		stosb
		mov	bh, al
		lodsw
		stosw
		mov	cl, 5
		shr	dx, cl
		dec	ax
		add	ax, dx
		mov	cx, dx
		xor	dx, dx
		div	cx
		mov	cx, ax
		inc	di
		inc	di
		movsw
		lodsb
		mov	[es:bp+17h], al
		lodsw
		stosw
		mov	dl, bh
		xor	dh, dh
		mul	dx
		add	ax, [es:bp+6]
		stosw
		add	ax, cx
		mov	[es:bp+0Bh], ax
		mov	cl, bl
		cmp	word [es:bp+0Dh], 0
		jnz	short normal_dpb
		xor	ch, ch
		mov	bx, [si+8]
		mov	dx, [si+0Ah]
		sub	bx, ax
		sbb	dx, 0
		or	cx, cx
		jz	short norot

rott:					; ...
		clc
		rcr	dx, 1
		rcr	bx, 1
		loop	rott

norot:					; ...
		mov	ax, bx
		jmp	short setend
; ---------------------------------------------------------------------------

normal_dpb:				; ...
		sub	ax, [es:bp+0Dh]
		neg	ax
		shr	ax, cl

setend:					; ...
		inc	ax
		mov	bx, ax
		mov	ax, [es:bp+0Fh]
		mul	word [es:bp+2]
		cmp	bx, 0FF6h
		jb	short setend_fat12
		shr	dx, 1
		jnz	short setend_faterr
		rcr	ax, 1
		cmp	ax, 0FF7h
		jb	short setend_faterr
		jmp	short setend_fat16
; ---------------------------------------------------------------------------

setend_fat12:				; ...
		add	ax, ax
		adc	dx, dx
		cmp	dx, 3
		jnb	short setend_faterr
		div	word [cs:word3]

setend_fat16:				; ...
		dec	ax
		cmp	ax, bx
		jbe	short setend_fat

setend_faterr:				; ...
		mov	ax, bx

setend_fat:				; ...
		mov	[es:bp+0Dh], ax
		mov	word [es:bp+1Dh], 0
		mov	word [es:bp+1Fh], 0FFFFh
		retn

; =============== S U B	R O U T	I N E =======================================


$DUP_PDB:
		mov	ds, [cs:DosDSeg]
		mov	byte [CreatePDB], 0FFh
		mov	ds, [CurrentPDB]
		push	si
		jmp	short CreateCopy

; =============== S U B	R O U T	I N E =======================================


$CREATE_PROCESS_DATA_BLOCK:
		call	Get_User_Stack
		mov	ds, word [si+14h]
		push	word [2]	; PDB.BLOCK_LEN

CreateCopy:				; ...
		mov	es, dx
		xor	si, si
		mov	di, si
		mov	cx, 128
		rep movsw
		mov	cx, 20
		mov	di, 18h		; PDB.JFN_TABLE
		push	ds
		lds	si, [34h]	; PDB.JFN_Pointer
		rep movsb
		pop	ds
		mov	ds, [cs:DosDSeg]
		cmp	byte [CreatePDB], 0
		jz	short Create_PDB_cont
		mov	ds, [cs:DosDSeg]
		xor	bx, bx
		mov	cx, 20

Create_dup_jfn:				; ...
		push	es
		call	SFFromHandle
		mov	al, 0FFh
		jb	short CreateStash
		test	byte [es:di+6], 10h
		jnz	short CreateStash
		mov	ah, [es:di+2]
		and	ah, 0F0h
		cmp	ah, 70h
		jz	short CreateStash
		mov	word [THISSFT], di
		mov	word [THISSFT+2], es
		call	DOS_DUP
		call	pJFNFromHandle
		mov	al, [es:di]

CreateStash:				; ...
		pop	es
		mov	[es:bx+18h], al
		inc	bx
		loop	Create_dup_jfn
		mov	bx, [CurrentPDB]
		mov	[es:16h], bx	; PDB.PARENT_PID
		mov	[CurrentPDB], es
		mov	ds, bx

Create_PDB_cont:			; ...
		push	ds
		mov	ds, [cs:DosDSeg]
		mov	byte [CreatePDB], 0
		pop	ds
		pop	ax

SETMEM:					; ...
		xor	cx, cx
		mov	ds, cx
		mov	es, dx
		mov	si, 88h
		mov	di, 10
		mov	cx, 6
		rep movsw
		mov	[es:2], ax
		sub	ax, dx
		cmp	ax, 0FFFh
		jbe	short HAVDIF
		mov	ax, 0FFFh

HAVDIF:					; ...
		sub	ax, 10h
		mov	bx, 0Ch
		sub	bx, ax
		mov	cl, 4
		shl	ax, cl
		mov	ds, dx
		mov	[6], ax
		mov	[8], bx
		cmp	ax, 0FEF0h
		jz	short addr_ok
		mov	word [6], 0C0h
		mov	word [8], 0

addr_ok:				; ...
		mov	word [0], 20CDh
		mov	byte [5], 9Ah
		mov	word [50h], 21CDh
		mov	byte [52h], 0CBh
		mov	word [34h], 18h
		mov	word [36h], ds
		mov	word [32h], 20
		mov	word [38h], 0FFFFh
		mov	word [3Ah], 0FFFFh
		mov	word [es:40h], 1606h ; 6.22
		retn

; ---------------------------------------------------------------------------

$GSetMediaID:				; ...
		mov	cx, 866h
		cmp	al, 0
		jz	short doioctl
		cmp	al, 1
		jnz	short errorfunc
		mov	cx, 846h

doioctl:				; ...
		mov	al, 0Dh
		call	$IOCTL
		retn
; ---------------------------------------------------------------------------

errorfunc:				; ...
		mov	al, 1
		jmp	SYS_RET_ERR

; =============== S U B	R O U T	I N E =======================================


StrCmp:
		push	si
		push	di
		push	ax

Cmplp:					; ...
		lodsb
		call	UCase
		call	PATHCHRCMP
		mov	ah, al
		mov	al, [es:di]
		inc	di
		call	UCase
		call	PATHCHRCMP
		cmp	ah, al
		jnz	short PopRet
		or	al, al
		jnz	short Cmplp

PopRet:					; ...
		pop	ax
		pop	di
		pop	si
		retn

; =============== S U B	R O U T	I N E =======================================


StrCpy:
		push	ax

CPYLoop:				; ...
		lodsb
		call	UCase
		call	PATHCHRCMP
		stosb
		or	al, al
		jnz	short CPYLoop
		pop	ax
		retn

; =============== S U B	R O U T	I N E =======================================


FStrCpy:
		push	ax

FCPYLoop:				; ...
		lodsb
		stosb
		or	al, al
		jnz	short FCPYLoop
		pop	ax
		retn

; =============== S U B	R O U T	I N E =======================================


StrLen:
		push	di
		push	ax
		mov	cx, 0FFFFh	; 65535
		xor	al, al
		repne scasb
		not	cx
		pop	ax
		pop	di
		retn

; =============== S U B	R O U T	I N E =======================================


DStrLen:
		call	XCHGP
		call	StrLen
		call	XCHGP
		retn

; =============== S U B	R O U T	I N E =======================================


XCHGP:
		push	ds
		push	es
		pop	ds
		pop	es
		xchg	si, di

xchgp_retn:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================


Idle:
		cmp	byte [ss:FSHARING], 0
		jnz	short xchgp_retn
		push	cx
		mov	cx, [ss:RetryLoop]
		jcxz	Idle3

Idle1:					; ...
		push	cx
		xor	cx, cx

Idle2:					; ...
		loop	Idle2
		pop	cx
		loop	Idle1

Idle3:					; ...
		pop	cx
		retn

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

TableDispatch:

;TFrame.Index	= byte ptr  4
;TFrame.Tab	= word ptr  6

TFrame.Index	equ 4
TFrame.Tab	equ 6

		push	bp
		mov	bp, sp
		push	bx
		mov	bx, [bp+TFrame.Tab]
		mov	bl, [cs:bx]
		cmp	[bp+TFrame.Index], bl
		jnb	short TableError
		mov	bl, [bp+TFrame.Index]
		xor	bh, bh
		shl	bx, 1
		inc	bx
		add	bx, [bp+TFrame.Tab]
		mov	bx, [cs:bx]
		mov	[bp+TFrame.Tab], bx
		pop	bx
		pop	bp
		add	sp, 4
		retn
; ---------------------------------------------------------------------------

TableError:				; ...
		pop	bx
		pop	bp
		retn	6

; =============== S U B	R O U T	I N E =======================================


TestNet	:
		mov	es, [cs:DosDSeg]
		les	di, [es:THISCDS]
		cmp	di, 0FFFFh
		jz	short CMCRet
		test	byte [es:di+44h], 80h
		jnz	short CMCRet
		retn
; ---------------------------------------------------------------------------

CMCRet:					; ...
		cmc
		retn

; =============== S U B	R O U T	I N E =======================================


IsSFTNet:
		test	byte [es:di+6], 80h
		retn

; ---------------------------------------------------------------------------

FastInit:				; ...
		push	es
		mov	es, [cs:DosDSeg]
		mov	di, FastTable_2
		dec	bx
		mov	dx, bx
		shl	bx, 1
		shl	bx, 1
		add	di, bx
		mov	ax, [es:di+2]
		mov	cx, cs
		cmp	ax, cx
		jz	short ok_install
		or	ax, ax
		jz	short ok_install
		stc
		jmp	short FSret
; ---------------------------------------------------------------------------

ok_install:				; ...
		cmp	si, 0FFFFh
		jz	short FSret
		mov	cx, ds
		mov	[es:di+2], cx
		mov	[es:di], si
		mov	di, FastOpenFlg
		add	di, dx
		or	byte [es:di], 80h

FSret:					; ...
		pop	es
		retn
; ---------------------------------------------------------------------------

FastRet:				; ...
		stc
		sbb	ax, ax
		retf
; ---------------------------------------------------------------------------

NLS_OPEN:				; ...
		mov	al, cl
		call	$OPEN
		retn
; ---------------------------------------------------------------------------

NLS_LSEEK:				; ...
		push	word [ss:USER_SP]
		push	word [ss:USER_SS]
		call	Fake_User_Stack
		mov	ax, bp
		call	$LSEEK
		pop	word [ss:USER_SS]
		pop	word [ss:USER_SP]
		retn

; =============== S U B	R O U T	I N E =======================================


Fake_User_Stack:
		mov	ax, [ss:USER_SP_2F]
		mov	[ss:USER_SP], ax
		mov	ax, ss
		mov	[ss:USER_SS], ax
		retn

; ---------------------------------------------------------------------------

GetDevList:				; ...
		mov	si, SysInitTable
		mov	ds, [cs:DosDSeg]
		lds	si, [si]
		mov	ax, [si+22h]
		mov	bx, [si+24h]
		retn
; ---------------------------------------------------------------------------

NLS_IOCTL:				; ...
		push	word [ss:USER_SP]
		push	word [ss:USER_SS]
		call	Fake_User_Stack
		mov	ax, bp
		call	$IOCTL
		pop	word [ss:USER_SS]
		pop	word [ss:USER_SP]
		retn
; ---------------------------------------------------------------------------

NLS_GETEXT:				; ...
		mov	ax, [ss:EXTERR]
		retn
; ---------------------------------------------------------------------------

MSG_RETRIEVAL:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================


ECritDisk:

; FUNCTION CHUNK AT 5146 SIZE 0000000E BYTES
; FUNCTION CHUNK AT 5155 SIZE 00000005 BYTES

		pushf
		cmp	byte [ss:redir_patch], 0
		jz	short ECritDisk_2
		jmp	short ECritDisk_1

; =============== S U B	R O U T	I N E =======================================


ECritDisk_iret:
		iret

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR ECritDisk

ECritDisk_1:				; ...
		push	cs
		call	ECritDisk_iret
		push	ax
		mov	ax, 8001h
		int	2Ah		; Microsoft Networks - BEGIN DOS CRITICAL SECTION
					; AL = critical	section	number (00h-0Fh)
		pop	ax
		retn
; ---------------------------------------------------------------------------

ECritDisk_2:				; ...
		jmp	short ECritDisk_3
; END OF FUNCTION CHUNK	FOR ECritDisk

; =============== S U B	R O U T	I N E =======================================


ECritDisk_iret2:
		iret

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR ECritDisk

ECritDisk_3:				; ...
		push	cs
		call	ECritDisk_iret2
		retn
; END OF FUNCTION CHUNK	FOR ECritDisk

; =============== S U B	R O U T	I N E =======================================


LCritDisk:

; FUNCTION CHUNK AT 5166 SIZE 0000000E BYTES
; FUNCTION CHUNK AT 5175 SIZE 00000005 BYTES

		pushf
		cmp	byte [ss:redir_patch], 0
		jz	short LCritDisk_2
		jmp	short LCritDisk_1

; =============== S U B	R O U T	I N E =======================================


LCritDisk_iret:
		iret

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR LCritDisk

LCritDisk_1:				; ...
		push	cs
		call	LCritDisk_iret
		push	ax
		mov	ax, 8101h
		int	2Ah		; Microsoft Networks - END DOS CRITICAL	SECTION
					; AL = critical	section	number (00h-0Fh)
		pop	ax
		retn
; ---------------------------------------------------------------------------

LCritDisk_2:				; ...
		jmp	short LCritDisk_3
; END OF FUNCTION CHUNK	FOR LCritDisk

; =============== S U B	R O U T	I N E =======================================


LCritDisk_iret2:
		iret

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR LCritDisk

LCritDisk_3:				; ...
		push	cs
		call	LCritDisk_iret2
		retn
; END OF FUNCTION CHUNK	FOR LCritDisk

; =============== S U B	R O U T	I N E =======================================


ECritDevice:

; FUNCTION CHUNK AT 5186 SIZE 0000000E BYTES
; FUNCTION CHUNK AT 5195 SIZE 00000005 BYTES

		pushf
		cmp	byte [ss:redir_patch], 0
		jz	short ECritDevice_2
		jmp	short ECritDevice_1

; =============== S U B	R O U T	I N E =======================================


ECritDevice_iret:
		iret

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR ECritDevice

ECritDevice_1:				; ...
		push	cs
		call	ECritDevice_iret
		push	ax
		mov	ax, 8002h
		int	2Ah		; Microsoft Networks - BEGIN DOS CRITICAL SECTION
					; AL = critical	section	number (00h-0Fh)
		pop	ax
		retn
; ---------------------------------------------------------------------------

ECritDevice_2:				; ...
		jmp	short ECritDevice_3
; END OF FUNCTION CHUNK	FOR ECritDevice

; =============== S U B	R O U T	I N E =======================================


ECritDevice_iret2:
		iret

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR ECritDevice

ECritDevice_3:				; ...
		push	cs
		call	ECritDevice_iret2
		retn
; END OF FUNCTION CHUNK	FOR ECritDevice

; =============== S U B	R O U T	I N E =======================================

LCritDevice:

; FUNCTION CHUNK AT 51A6 SIZE 0000000E BYTES
; FUNCTION CHUNK AT 51B5 SIZE 00000005 BYTES

		pushf
		cmp	byte [ss:redir_patch], 0
		jz	short LCritDevice_2
		jmp	short LCritDevice_1

; =============== S U B	R O U T	I N E =======================================


LCritDevice_iret:
		iret

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR LCritDevice

LCritDevice_1:				; ...
		push	cs
		call	LCritDevice_iret
		push	ax
		mov	ax, 8102h
		int	2Ah		; Microsoft Networks - END DOS CRITICAL	SECTION
					; AL = critical	section	number (00h-0Fh)
		pop	ax
		retn
; ---------------------------------------------------------------------------

LCritDevice_2:				; ...
		jmp	short LCritDevice_3
; END OF FUNCTION CHUNK	FOR LCritDevice

; =============== S U B	R O U T	I N E =======================================


LCritDevice_iret2:
		iret

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR LCritDevice

LCritDevice_3:				; ...
		push	cs
		call	LCritDevice_iret2
		retn
; END OF FUNCTION CHUNK	FOR LCritDevice

; =============== S U B	R O U T	I N E =======================================


$STD_CON_INPUT_NO_ECHO:
		push	ds
		push	si

INTEST:					; ...
		call	STATCHK
		jnz	short GET
		cmp	byte [ss:PRINTER_FLAG], 0
		jnz	short no_sys_wait
		mov	ah, 5
		call	IOFUNC

no_sys_wait:				; ...
		mov	ah, 84h
		int	2Ah		; Microsoft Networks - KEYBOARD	BUSY LOOP
		cmp	byte [ss:DATE_FLAG], 0FFh
		jnz	short NoUpdate
		push	ax
		push	bx
		push	cx
		push	dx
		push	ds
		push	ss
		pop	ds
		mov	ax, 0
		call	Save_Restore_Packet
		call	READTIME
		mov	ax, 1
		call	Save_Restore_Packet
		pop	ds
		pop	dx
		pop	cx
		pop	bx
		pop	ax

NoUpdate:				; ...
		inc	word [ss:DATE_FLAG]
		jmp	short INTEST
; ---------------------------------------------------------------------------

GET:					; ...
		xor	ah, ah
		call	IOFUNC
		pop	si
		pop	ds
		mov	byte [ss:SCAN_FLAG], 0
		cmp	al, 0
		jnz	short noscan
		mov	byte [ss:SCAN_FLAG], 1

noscan:					; ...
		retn

; ---------------------------------------------------------------------------

$STD_CON_STRING_OUTPUT:			; ...
		mov	si, dx

STRING_OUT1:				; ...
		lodsb
		cmp	al, '$'
		jz	short noscan
		call	OUTT
		jmp	short STRING_OUT1

; =============== S U B	R O U T	I N E =======================================


$STD_CON_STRING_INPUT:

; FUNCTION CHUNK AT 4820 SIZE 00000019 BYTES
; FUNCTION CHUNK AT 52C5 SIZE 00000005 BYTES
; FUNCTION CHUNK AT 52F3 SIZE 00000019 BYTES
; FUNCTION CHUNK AT 537D SIZE 00000044 BYTES
; FUNCTION CHUNK AT 53F1 SIZE 00000021 BYTES

		mov	ax, ss
		mov	es, ax
		mov	si, dx
		xor	ch, ch
		lodsw
		or	al, al
		jz	short noscan
		mov	bl, ah
		mov	bh, ch
		cmp	al, bl
		jbe	short NOEDIT
		cmp	byte [bx+si], 0Dh
		jz	short EDITON

NOEDIT:					; ...
		mov	bl, ch

EDITON:					; ...
		mov	dl, al
		dec	dx

NEWLIN:					; ...
		mov	al, [ss:CARPOS]
		mov	[ss:STARTPOS], al
		push	si
		mov	di, INBUF
		mov	byte [ss:INSMODE], ch
		mov	bh, ch
		mov	dh, ch
		call	$STD_CON_INPUT_NO_ECHO
		cmp	al, 0Ah
		jnz	short GOTCH

GETCH:					; ...
		call	$STD_CON_INPUT_NO_ECHO

GOTCH:					; ...
		cmp	al, 6
		jz	short GETCH
		cmp	al, [cs:ESCCHAR]
		jz	short ESCAPE
		cmp	al, 7Fh
		jz	short BACKSPJ
		cmp	al, 8
		jz	short BACKSPJ
		cmp	al, 17h
		nop
		nop
		cmp	al, 15h
		nop
		nop
		cmp	al, 0Dh
		jz	short ENDLIN
		cmp	al, 0Ah
		jz	short PHYCRLF
		cmp	al, [cs:CANCHAR]
		jz	short KILNEW

SAVCH:					; ...
		cmp	dh, dl
		jnb	short BUFFUL
		stosb
		inc	dh
		call	BUFOUT
		cmp	byte [ss:INSMODE], 0
		jnz	short GETCH
		cmp	bh, bl
		jnb	short GETCH
		inc	si
		inc	bh
		jmp	short GETCH
; ---------------------------------------------------------------------------

BACKSPJ:				; ...
		jmp	short BACKSP
; ---------------------------------------------------------------------------

BUFFUL:					; ...
		mov	al, 7
		call	OUTT
		jmp	short GETCH
; ---------------------------------------------------------------------------

ESCAPE:					; ...
		jmp	OEMFunctionKey
; ---------------------------------------------------------------------------

ENDLIN:					; ...
		stosb
		call	OUTT
		pop	di
		mov	[di-1],	dh
		inc	dh

; =============== S U B	R O U T	I N E =======================================


COPYNEW:
		push	ds
		push	es
		pop	ds
		pop	es
		mov	si, INBUF
		mov	cl, dh
		rep movsb

OLDBAK_RETN:				; ...
		retn

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR $STD_CON_STRING_INPUT

PHYCRLF:				; ...
		call	CRLF
		jmp	short GETCH
; END OF FUNCTION CHUNK	FOR $STD_CON_STRING_INPUT
; ---------------------------------------------------------------------------

LineDel:				; ...
		or	dh, dh
		jz	short GETCH
		call	BackSpace
		jmp	short LineDel
; ---------------------------------------------------------------------------

WordDel:				; ...
		call	BackSpace
		or	dh, dh
		jz	short getchj
		mov	al, [es:di-1]
		cmp	al, '0'
		jb	short getchj
		cmp	al, '9'
		jbe	short WordDel
		or	al, 20h
		cmp	al, 'a'
		jb	short getchj
		cmp	al, 'z'
		jbe	short WordDel

getchj:					; ...
		jmp	GETCH
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR $STD_CON_STRING_INPUT

KILNEW:					; ...
		mov	al, '\'
		call	OUTT
		pop	si

PUTNEW:					; ...
		call	CRLF
		mov	al, [ss:STARTPOS]
		call	TAB
		jmp	NEWLIN
; ---------------------------------------------------------------------------

BACKSP:					; ...
		call	BackSpace
		jmp	GETCH
; END OF FUNCTION CHUNK	FOR $STD_CON_STRING_INPUT

; =============== S U B	R O U T	I N E =======================================


BackSpace:
		or	dh, dh
		jz	short OLDBAK
		call	BACKUP
		mov	al, [es:di]
		cmp	al, 20h	; ' '
		jnb	short OLDBAK
		cmp	al, 9
		jz	short BAKTAB
		cmp	al, 15h
		jz	short OLDBAK
		cmp	al, 14h
		jz	short OLDBAK
		call	BACKMES

OLDBAK:					; ...
		cmp	byte [ss:INSMODE], 0
		jnz	short OLDBAK_RETN
		or	bh, bh
		jz	short OLDBAK_RETN
		dec	bh
		dec	si
		retn
; ---------------------------------------------------------------------------

BAKTAB:					; ...
		push	di
		dec	di
		std
		mov	cl, dh
		mov	al, 20h	; ' '
		push	bx
		mov	bl, 7
		jcxz	FIGTAB

FNDPOS:					; ...
		scasb
		jbe	short CHKCNT
		cmp	byte [es:di+1], 9
		jz	short HAVTAB
		dec	bl

CHKCNT:					; ...
		loop	FNDPOS

FIGTAB:					; ...
		sub	bl, [ss:STARTPOS]

HAVTAB:					; ...
		sub	bl, dh
		add	cl, bl
		and	cl, 7
		cld
		pop	bx
		pop	di
		jz	short OLDBAK

TABBAK:					; ...
		call	BACKMES
		loop	TABBAK
		jmp	short OLDBAK

; =============== S U B	R O U T	I N E =======================================


BACKUP:
		dec	dh
		dec	di

; =============== S U B	R O U T	I N E =======================================


BACKMES:
		mov	al, 8
		call	OUTT
		mov	al, 20h	; ' '
		call	OUTT
		mov	al, 8
		jmp	OUTT

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR $STD_CON_STRING_INPUT

TWOESC:					; ...
		mov	al, [cs:ESCCHAR]
		jmp	SAVCH
; ---------------------------------------------------------------------------

COPYLIN:				; ...
		mov	cl, bl
		sub	cl, bh
		jmp	short COPYEACH
; ---------------------------------------------------------------------------

COPYSTR:				; ...
		call	FINDOLD
		jmp	short COPYEACH
; ---------------------------------------------------------------------------

COPYONE:				; ...
		mov	cl, 1

COPYEACH:				; ...
		mov	byte [ss:INSMODE], 0
		cmp	dh, dl
		jz	short GETCH2
		cmp	bh, bl
		jz	short GETCH2
		lodsb
		stosb
		call	BUFOUT
		inc	bh
		inc	dh
		loop	COPYEACH

GETCH2:					; ...
		jmp	GETCH
; ---------------------------------------------------------------------------

SKIPONE:				; ...
		cmp	bh, bl
		jz	short GETCH2
		inc	bh
		inc	si
		jmp	GETCH
; ---------------------------------------------------------------------------

SKIPSTR:				; ...
		call	FINDOLD
		add	si, cx
		add	bh, cl
		jmp	GETCH
; END OF FUNCTION CHUNK	FOR $STD_CON_STRING_INPUT

; =============== S U B	R O U T	I N E =======================================


FINDOLD:
		call	$STD_CON_INPUT_NO_ECHO
		cmp	al, [cs:ESCCHAR]
		jnz	short FINDSETUP
		call	$STD_CON_INPUT_NO_ECHO
		jmp	short NOTFND
; ---------------------------------------------------------------------------

FINDSETUP:				; ...
		mov	cl, bl
		sub	cl, bh
		jz	short NOTFND
		dec	cx
		jz	short NOTFND
		push	es
		push	ds
		pop	es
		push	di
		mov	di, si
		inc	di
		repne scasb
		pop	di
		pop	es
		jnz	short NOTFND
		not	cl
		add	cl, bl
		sub	cl, bh

FINDOLD_RETN:				; ...
		retn
; ---------------------------------------------------------------------------

NOTFND:					; ...
		pop	bp
		jmp	GETCH

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR $STD_CON_STRING_INPUT

REEDIT:					; ...
		mov	al, '@'
		call	OUTT
		pop	di
		push	di
		push	es
		push	ds
		call	COPYNEW
		pop	ds
		pop	es
		pop	si
		mov	bl, dh
		jmp	PUTNEW
; ---------------------------------------------------------------------------

EXITINS_ENTERINS:			; ...
		not	byte [ss:INSMODE]
		jmp	GETCH
; ---------------------------------------------------------------------------

CTRLZ:					; ...
		mov	al, 1Ah
		jmp	SAVCH
; END OF FUNCTION CHUNK	FOR $STD_CON_STRING_INPUT

; =============== S U B	R O U T	I N E =======================================


CRLF:
		mov	al, 0Dh
		call	OUTT
		mov	al, 0Ah
		jmp	OUTT

; ---------------------------------------------------------------------------

$RAW_CON_IO:				; ...
		mov	al, dl
		cmp	al, 0FFh
		jz	short rcio1
		jmp	short RAWOUT
; ---------------------------------------------------------------------------
		nop

rcio1:					; ...
		les	di, [ss:USER_SP]
		xor	bx, bx
		call	GET_IO_SFT
		jb	short FINDOLD_RETN
		mov	ah, 1
		call	IOFUNC
		jnz	short RESFLG
		call	SPOOLINT
		or	byte [es:di+16h], 40h
		xor	al, al

RET17:					; ...
		retn
; ---------------------------------------------------------------------------

RESFLG:					; ...
		and	byte [es:di+16h], 0BFh

rci0:					; ...
		call	SPOOLINT

$RAW_CON_INPUT:				; ...
		push	bx
		xor	bx, bx
		call	GET_IO_SFT
		pop	bx
		jb	short RET17
		mov	ah, 1
		call	IOFUNC
		jnz	short rci5
		mov	ah, 84h
		int	2Ah		; Microsoft Networks - KEYBOARD	BUSY LOOP
		jmp	short rci0
; ---------------------------------------------------------------------------

rci5:					; ...
		xor	ah, ah
		call	IOFUNC
		retn

; =============== S U B	R O U T	I N E =======================================


RAWOUT:
		push	bx
		mov	bx, 1
		call	GET_IO_SFT
		jb	short RAWRET1
		mov	bx, [si+5]
		and	bx, 8080h
		cmp	bx, 80h	; ''
		jnz	short RAWNORM
		push	ds
		lds	bx, [si+7]
		test	byte [bx+4], 10h
		pop	ds
		jz	short RAWNORM
		int	29h		; DOS 2+ internal - FAST PUTCHAR
					; AL = character to display

RAWRET:					; ...
		clc

RAWRET1:				; ...
		pop	bx

RAWRET2:				; ...
		retn
; ---------------------------------------------------------------------------

RAWNORM:				; ...
		call	RAWOUT3
		jmp	short RAWRET

; =============== S U B	R O U T	I N E =======================================


RAWOUT2:
		call	GET_IO_SFT
		jb	short RAWRET2

; =============== S U B	R O U T	I N E =======================================


RAWOUT3:
		push	ax
		jmp	short RAWOSTRT
; ---------------------------------------------------------------------------

ROLP:					; ...
		call	SPOOLINT
		or	word [ss:DOS34_FLAG], 200h
		call	DSKSTATCHK

RAWOSTRT:				; ...
		mov	ah, 3
		call	IOFUNC
		jz	short ROLP
		inc	ax
		pop	ax
		jz	short nosend
		mov	ah, 2
		call	IOFUNC

nosend:					; ...
		clc
		retn

; =============== S U B	R O U T	I N E =======================================


Save_Restore_Packet:
		push	ds
		push	es
		push	si
		push	di
		cmp	ax, 0
		jz	short save_packet

restore_packet:
		mov	si, FAKE_STACK_2F
		mov	di, DEVCALL
		jmp	short set_seg
; ---------------------------------------------------------------------------

save_packet:				; ...
		mov	di, FAKE_STACK_2F
		mov	si, DEVCALL

set_seg:				; ...
		mov	ax, ss
		mov	ds, ax
		mov	es, ax
		mov	cx, 11
		rep movsw
		pop	di
		pop	si
		pop	es
		pop	ds
		retn

; ---------------------------------------------------------------------------

$STD_CON_INPUT:				; ...
		call	$STD_CON_INPUT_NO_ECHO
		push	ax
		call	OUTT
		pop	ax

; =============== S U B	R O U T	I N E =======================================


CON_INPUT_RETN:
		retn

; ---------------------------------------------------------------------------

$STD_CON_OUTPUT:			; ...
		mov	al, dl

; =============== S U B	R O U T	I N E =======================================


OUTT:

; FUNCTION CHUNK AT 556F SIZE 00000008 BYTES
; FUNCTION CHUNK AT 557A SIZE 00000008 BYTES
; FUNCTION CHUNK AT 55CF SIZE 00000007 BYTES

		cmp	al, 20h
		jb	short CTRLOUT
		cmp	al, 7Fh
		jz	short OUTCH
		inc	byte [ss:CARPOS]

OUTCH:					; ...
		push	ds
		push	si
		inc	byte [ss:CHARCO]
		and	byte [ss:CHARCO], 3Fh
		jnz	short OUTSKIP
		push	ax
		call	STATCHK
		pop	ax

OUTSKIP:				; ...
		call	RAWOUT
		pop	si
		pop	ds
		test	byte [ss:PFLAG], 0FFh
		jz	short CON_INPUT_RETN
		push	bx
		push	ds
		push	si
		mov	bx, 1
		call	GET_IO_SFT
		jb	short TRIPOPJ
		mov	bx, [si+5]
		test	bh, 80h
		jnz	short TRIPOPJ
		test	bl, 80h
		jz	short TRIPOPJ
		mov	bx, 4
		call	GET_IO_SFT
		jb	short TRIPOPJ
		test	byte [si+6], 8
		jz	short LISSTRT2J
		mov	byte [ss:PFLAG], 0

TRIPOPJ:				; ...
		jmp	TRIPOP
; ---------------------------------------------------------------------------

LISSTRT2J:				; ...
		jmp	LISSTRT2
; ---------------------------------------------------------------------------

CTRLOUT:				; ...
		cmp	al, 0Dh
		jz	short ZERPOS
		cmp	al, 8
		jz	short BACKPOS
		cmp	al, 9
		jnz	short OUTCH
		mov	al, [ss:CARPOS]
		or	al, 0F8h
		neg	al

; =============== S U B	R O U T	I N E =======================================


TAB:
		push	cx
		mov	cl, al
		mov	ch, 0
		jcxz	POPTAB

TABLP:					; ...
		mov	al, ' '
		call	OUTT
		loop	TABLP

POPTAB:					; ...
		pop	cx
		retn

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR OUTT

ZERPOS:					; ...
		mov	byte [ss:CARPOS], 0
		jmp	short OUTCH
; END OF FUNCTION CHUNK	FOR OUTT
; ---------------------------------------------------------------------------

j_OUTT:					; ...
		jmp	OUTT
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR OUTT

BACKPOS:				; ...
		dec	byte [ss:CARPOS]
		jmp	OUTCH
; END OF FUNCTION CHUNK	FOR OUTT

; =============== S U B	R O U T	I N E =======================================


BUFOUT:
		cmp	al, ' '
		jnb	short j_OUTT
		cmp	al, 9
		jz	short j_OUTT
		cmp	al, 15h
		jz	short CTRLU
		cmp	al, 14h
		jz	short CTRLU

NOT_CTRLU:
		push	ax
		mov	al, '^'
		call	OUTT
		pop	ax
		or	al, 40h

CTRLU:					; ...
		call	OUTT

BUFOUT_RETN:				; ...
		retn

; ---------------------------------------------------------------------------

$STD_AUX_INPUT:				; ...
		call	STATCHK
		mov	bx, 3
		call	GET_IO_SFT
		jb	short BUFOUT_RETN
		jmp	short TAISTRT
; ---------------------------------------------------------------------------

AUXILP:					; ...
		call	SPOOLINT

TAISTRT:				; ...
		mov	ah, 1
		call	IOFUNC
		jz	short AUXILP
		xor	ah, ah
		call	IOFUNC
		retn
; ---------------------------------------------------------------------------

$STD_AUX_OUTPUT:			; ...
		push	bx
		mov	bx, 3
		jmp	short SENDOUT
; ---------------------------------------------------------------------------

$STD_PRINTER_OUTPUT:			; ...
		push	bx
		mov	bx, 4

SENDOUT:				; ...
		mov	al, dl
		push	ax
		call	STATCHK
		pop	ax
		push	ds
		push	si
; START	OF FUNCTION CHUNK FOR OUTT

LISSTRT2:				; ...
		call	RAWOUT2

TRIPOP:					; ...
		pop	si
		pop	ds
		pop	bx

SCIS_RETN:				; ...
		retn
; END OF FUNCTION CHUNK	FOR OUTT
; ---------------------------------------------------------------------------

$STD_CON_INPUT_STATUS:			; ...
		call	STATCHK
		mov	al, 0
		jz	short SCIS_RETN
		or	al, 0FFh
		retn
; ---------------------------------------------------------------------------

$STD_CON_INPUT_FLUSH:			; ...
		push	ax
		push	dx
		xor	bx, bx
		call	GET_IO_SFT
		jb	short BADJFNCON
		mov	ah, 4
		call	IOFUNC

BADJFNCON:				; ...
		pop	dx
		pop	ax
		mov	ah, al
		cmp	al, 1
		jz	short REDISPJ
		cmp	al, 6
		jz	short REDISPJ
		cmp	al, 7
		jz	short REDISPJ
		cmp	al, 8
		jz	short REDISPJ
		cmp	al, 0Ah
		jz	short REDISPJ
		mov	al, 0
		retn
; ---------------------------------------------------------------------------

REDISPJ:				; ...
		cli
		jmp	REDISP
; ---------------------------------------------------------------------------

$GET_FCB_POSITION:			; ...
		call	GetExtended
		call	GetExtent
		mov	[si+21h], ax
		mov	[si+23h], dl
		cmp	word [si+0Eh], 64
		jnb	short GetFCBBye
		mov	[si+24h], dh

GetFCBBye:				; ...
		jmp	NO_OP
; ---------------------------------------------------------------------------

$FCB_DELETE:				; ...
		mov	di, OPENBUF
		call	TransFCB
		jb	short BadPath
		push	ss
		pop	ds
		call	DOS_DELETE
		jb	short BadPath

GoodPath:				; ...
		jmp	short GetFCBBye
; ---------------------------------------------------------------------------

BadPath:				; ...
		jmp	FCB_RET_ERR
; ---------------------------------------------------------------------------

$GET_FCB_FILE_LENGTH:			; ...
		call	GetExtended
		mov	di, OPENBUF
		push	ds
		push	si
		call	TransFCB
		pop	si
		pop	ds
		jb	short BadPath
		push	ds
		push	si
		push	ss
		pop	ds
		call	GET_FILE_INFO
		pop	si
		pop	ds
		jb	short BadPath
		mov	dx, bx
		mov	ax, di
		mov	bx, [si+0Eh]
		or	bx, bx
		jnz	short GetSize
		mov	bx, 128

GetSize:				; ...
		mov	di, ax
		mov	ax, dx
		xor	dx, dx
		div	bx
		push	ax
		mov	ax, di
		div	bx
		mov	cx, dx
		pop	dx
		jcxz	LengthStore
		add	ax, 1
		adc	dx, 0

LengthStore:				; ...
		mov	[si+21h], ax
		mov	[si+23h], dl
		or	dh, dh
		jz	short GoodPath
		mov	[si+24h], dh

GoodRet:				; ...
		jmp	short GoodPath
; ---------------------------------------------------------------------------

$FCB_CLOSE:				; ...
		xor	al, al
		call	GetExtended
		jz	short NoAttr
		mov	al, [si-1]

NoAttr:					; ...
		mov	byte [ss:ATTRIB], al
		call	SFTFromFCB
		jb	short GoodRet
		mov	al, [es:di+4]
		xor	ah, ah
		push	ax
		call	CheckShare
		jnz	short NoStash
		mov	al, [ss:ATTRIB]
		mov	[es:di+4], al

NoStash:				; ...
		mov	ax, [si+14h]
		mov	[es:di+0Fh], ax
		mov	ax, [si+16h]
		mov	[es:di+0Dh], ax
		mov	ax, [si+10h]
		mov	[es:di+11h], ax
		mov	ax, [si+12h]
		mov	[es:di+13h], ax
		or	word [es:di+5], 4000h
		push	ss
		pop	ds
		call	DOS_CLOSE
		les	di, [THISSFT]
		pop	cx
		mov	[es:di+4], cl
		pushf
		cmp	word [es:di], 0
		jnz	short CloseOK
		push	ax
		mov	al, 'M'
		call	BlastSFT
		pop	ax

CloseOK:				; ...
		popf
		jnb	short GoodRet
		cmp	al, 6
		jz	short GoodRet
		mov	al, 2

jmp_to_FCB_RET_ERR:			; ...
		jmp	FCB_RET_ERR
; ---------------------------------------------------------------------------

$FCB_RENAME:				; ...
		call	GetExtended
		push	dx
		mov	al, [si]
		add	si, 10h
		mov	di, RENBUF
		push	word [si]
		push	ds
		push	si
		mov	[si], al
		mov	dx, si
		call	TransFCB
		pop	si
		pop	ds
		pop	word [si]
		pop	dx
		jb	short fren90
		mov	si, [ss:WFP_START]
		mov	[ss:REN_WFP], si
		mov	di, OPENBUF
		call	TransFCB
		jb	short fren90
		call	DOS_RENAME
		jb	short fren90
		jmp	NO_OP
; ---------------------------------------------------------------------------

fren90:					; ...
		jmp	short jmp_to_FCB_RET_ERR

; =============== S U B	R O U T	I N E =======================================


SaveFCBInfo:
		les	di, [ss:THISSFT]
		call	IsSFTNet
		jz	short SaveLocal
		mov	ax, [es:di+0Bh]
		mov	[si+1Ch], ax
		mov	bl, 80h	; ''
		jmp	short SaveSFN
; ---------------------------------------------------------------------------

SaveLocal:				; ...
		call	CheckShare
		jz	short SaveNoShare
		jmp	short SaveShare
; ---------------------------------------------------------------------------

SaveNoShare:				; ...
		test	byte [es:di+5], 80h
		jnz	short SaveNoShareDev
		mov	ax, [es:di+1Bh]
		mov	[si+1Dh], ax
		mov	ax, [es:di+1Dh]
		mov	bl, [es:di+4]
		mov	bh, bl
		ror	bl, 1
		shl	bh, 1
		or	bl, bh
		and	bl, 0C0h
		or	al, bl
		mov	[si+18h], al
		mov	al, [es:di+1Fh]
		mov	[si+1Fh], al
		mov	ax, [es:di+0Bh]
		mov	[si+1Bh], ax
		mov	bl, 0

SetFCBBits:				; ...
		mov	ax, [es:di+5]
		and	al, 0C0h
		or	al, [es:di+2]
		mov	[si+1Ah], al
		or	bl, bl
		jz	short SaveNoSFN
		jmp	short SaveSFN
; ---------------------------------------------------------------------------

SaveNoShareDev:				; ...
		mov	ax, [es:di+7]
		mov	[si+1Ah], ax
		mov	ax, [es:di+9]
		mov	[si+1Ch], ax
		mov	bl, 40h	; '@'
		jmp	short SetFCBBits
; ---------------------------------------------------------------------------

SaveShare:				; ...
		call	far [ss:ShSave]

SaveSFN:				; ...
		lea	ax, [di-6]
		sub	ax, word [ss:SFTFCB]
		push	bx
		mov	bl, 59
		div	bl
		mov	[si+18h], al
		pop	bx

SaveNoSFN:				; ...
		mov	ax, [es:di+5]
		and	al, 3Fh
		or	al, bl
		mov	[si+19h], al
		mov	ax, [ss:FCBLRU]
		inc	ax
		mov	[es:di+15h], ax
		jnz	short SimpleStuff
		mov	bx, 15h
		call	ResetLRU

SimpleStuff:				; ...
		mov	[ss:FCBLRU], ax
		retn

; =============== S U B	R O U T	I N E =======================================


ResetLRU:
		mov	ax, 8000h
		push	es
		push	di
		les	di, [ss:SFTFCB]
		mov	cx, [es:di+4]
		lea	di, [di+6]

ovScan:					; ...
		sub	[es:bx+di], ax
		ja	short ovLoop
		mov	[es:bx+di], ax

ovLoop:					; ...
		add	di, 59
		loop	ovScan
		pop	di
		pop	es
		mov	[es:bx+di], ax
		retn

; =============== S U B	R O U T	I N E =======================================


LRUFCB:
		push	es
		call	save_world
		mov	ds, [cs:DosDSeg]
		or	al, al
		jnz	short lru1
		mov	di, word [LocalSFT]
		or	di, word [LocalSFT+2]
		jz	short lru1
		les	di, [LocalSFT]

gotlocalSFT:				; ...
		mov	word [THISSFT], di
		mov	word [THISSFT+2], es
		clc
		jmp	LRUDone
; ---------------------------------------------------------------------------

lru1:					; ...
		les	di, [SFTFCB]
		mov	cx, [es:di+4]
		lea	di, [di+6]
		mov	bx, 0FFFFh
		mov	si, bx
		mov	dx, bx
		mov	bp, bx

findSFT:				; ...
		or	word [es:di], 0
		jz	short gotSFT
		cmp	word [es:di], 0FFFFh
		jz	short gotSFT
		test	word [es:di+5], 8000h
		jnz	short lru5
		call	CheckShare
		jnz	short lru5

hackpoint:				; ...
		mov	word [LocalSFT], di
		mov	word [LocalSFT+2], es
		or	al, al
		jz	short gotlocalSFT
		cmp	[es:di+15h], bx
		jnb	short lru4
		mov	bx, [es:di+15h]
		mov	si, di

lru4:					; ...
		add	di, 59
		loop	findSFT
		mov	di, si
		cmp	si, 0FFFFh
		jnz	short gotSFT
		mov	di, bp
		cmp	bp, 0FFFFh
		jnz	short gotnetSFT
		jmp	short errorbadSFT
; ---------------------------------------------------------------------------

lru5:					; ...
		cmp	[es:di+15h], dx
		jnb	short lru4
		mov	dx, [es:di+15h]
		mov	bp, di
		jmp	short lru4
; ---------------------------------------------------------------------------

gotSFT:					; ...
		or	al, al
		jz	short hackpoint

notlocaluse:
		mov	ax, es
		cmp	word [LocalSFT], di
		jnz	short notinvalid
		cmp	word [LocalSFT+2], ax
		jz	short zerolocalSFT

notinvalid:				; ...
		jmp	gotlocalSFT
; ---------------------------------------------------------------------------

zerolocalSFT:				; ...
		xor	ax, ax
		mov	word [LocalSFT], ax
		mov	word [LocalSFT+2], ax
		jmp	gotlocalSFT
; ---------------------------------------------------------------------------

gotnetSFT:				; ...
		or	al, al
		jnz	short closenet
		mov	word [LocalSFT], di
		mov	word [LocalSFT+2], es

closenet:				; ...
		mov	word [THISSFT], di
		mov	word [THISSFT+2], es

LRUClose:				; ...
		cmp	word [es:di], 0
		jz	short LRUDone
		call	DOS_CLOSE
		jnb	short LRUClose
		cmp	al, 6
		jz	short LRUClose

errorbadSFT:				; ...
		stc
		jmp	short LRUDead
; ---------------------------------------------------------------------------

LRUDone:				; ...
		xor	al, al
		call	BlastSFT

LRUDead:				; ...
		call	restore_world
		pop	es
		mov	es, [cs:DosDSeg]
		les	di, [es:THISSFT]
		jb	short LruFCB_err
		retn
; ---------------------------------------------------------------------------

LruFCB_err:				; ...
		mov	al, 23h	; '#'
		retn

; =============== S U B	R O U T	I N E =======================================


RegenCopyName:
		lodsb
		call	UCase
		stosb
		loop	RegenCopyName
		retn

; =============== S U B	R O U T	I N E =======================================


FCBRegen:
		mov	al, [si+19h]
		test	al, 80h
		jz	short RegenNoSharing
		call	CheckShare
		jnz	short RegenFail
		mov	ax, 1100h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - INSTALLATION	CHECK
					; Return: AL = 00h  not	installed, OK to install
					; 01h  not installed, not OK to	install
					; FFh  installed
		or	al, al
		jz	short RegenDead

RegenFail:				; ...
		mov	ax, [ss:USER_IN_AX]
		cmp	ah, 10h
		jz	short RegenDead
		call	FCBHardErr

RegenDead:				; ...
		stc

FCBRegen_retn:				; ...
		retn
; ---------------------------------------------------------------------------

RegenNoSharing:				; ...
		call	CheckShare
		jnz	short RegenFail
		push	ax
		mov	al, 0
		call	LRUFCB
		pop	ax
		jb	short FCBRegen_retn
		mov	word [es:di+2], 8002h
		and	al, 3Fh
		cbw
		or	ax, 4000h
		mov	cl, [si+1Ah]
		mov	ch, cl
		and	ch, 0C0h
		or	al, ch
		and	cl, 0Fh
		mov	[es:di+2], cl
		mov	[es:di+5], ax
		mov	ax, [ss:PROC_ID]
		mov	[es:di+31h], ax
		push	ds
		push	si
		push	es
		push	di
		push	ss
		pop	es
		mov	di, NAME1
		mov	cx, 8
		inc	si
		call	RegenCopyName
		push	ss
		pop	ds
		mov	byte [ATTRIB], 16h
		call	DEVNAME
		pop	di
		pop	es
		pop	si
		pop	ds
		jb	short RegenFileNoSharing
		mov	[es:di+5], bh
		mov	byte [es:di+4], 0
		lds	si, [ss:DEVPT]
		mov	[es:di+7], si
		mov	word [es:di+9], ds
		retn
; ---------------------------------------------------------------------------

RegenDeadJ:				; ...
		jmp	short RegenDead
; ---------------------------------------------------------------------------

RegenFileNoSharing:			; ...
		mov	ax, [es:di+5]
		and	ax, 3Fh
		push	ds
		push	si
		call	FIND_DPB
		mov	[es:di+7], si
		mov	word [es:di+9], ds
		pop	si
		pop	ds
		jb	short RegenDeadJ
		mov	ax, [si+1Dh]
		mov	[es:di+1Bh], ax
		mov	al, [si+18h]
		and	al, 0C0h
		mov	ah, al
		rol	ah, 1
		shr	al, 1
		or	al, ah
		and	al, 3Fh
		mov	[es:di+4], al
		mov	al, [si+18h]
		and	al, 3Fh
		sub	ah, ah
		mov	[es:di+1Dh], ax
		mov	ax, [si+1Bh]
		mov	[es:di+0Bh], ax
		mov	[es:di+35h], ax
		mov	al, [si+1Fh]
		mov	[es:di+1Fh], al
		inc	word [es:di]
		lea	si, [si+1]
		lea	di, [di+20h]
		mov	cx, 11
		call	RegenCopyName
		clc
		retn

; =============== S U B	R O U T	I N E =======================================


BlastSFT:
		push	di
		mov	cx, 59
		rep stosb
		pop	di
		sub	ax, ax
		mov	[es:di], ax
		mov	[es:di+15h], ax
		dec	ax
		mov	[es:di+17h], ax
		retn

; =============== S U B	R O U T	I N E =======================================


CheckFCB:
		test	byte [si+19h], 0C0h
		jz	short BadSFT
		les	di, [ss:SFTFCB]
		cmp	[es:di+4], al
		jb	short BadSFT
		mov	bl, 59
		mul	bl
		lea	di, [di+6]
		add	di, ax
		mov	ax, [ss:PROC_ID]
		cmp	[es:di+31h], ax
		jnz	short BadSFT
		cmp	word [es:di], 0
		jz	short BadSFT
		mov	al, [si+19h]
		test	al, 80h
		jz	short CheckNoShare
		push	ax
		and	al, 0C0h
		cmp	al, 0C0h ; 'À'
		pop	ax
		jnz	short CheckNet
		call	far [ss:ShChk]
		jb	short BadSFT
		jmp	short CheckD
; ---------------------------------------------------------------------------

CheckFirClus:
		cmp	bx, [es:di+0Bh]
		jnz	short BadSFT

CheckD:					; ...
		and	al, 3Fh
		mov	ah, [es:di+5]
		and	ah, 3Fh
		cmp	ah, al
		jnz	short BadSFT

BlastSFT_retn:				; ...
		retn
; ---------------------------------------------------------------------------

BadSFT:					; ...
		stc
		retn
; ---------------------------------------------------------------------------

CheckNet:				; ...
		mov	ax, [si+1Ch]
		cmp	ax, [es:di+0Bh]
		jnz	short BadSFT
		retn

; ---------------------------------------------------------------------------

CheckNoShare:				; ...
		test	al, 40h
		jnz	short $+2
		mov	bx, [si+1Ah]
		cmp	bx, [es:di+7]
		jnz	short BadSFT
		mov	bx, [si+1Ch]
		cmp	bx, [es:di+9]
		jnz	short BadSFT
		jmp	short CheckD

; =============== S U B	R O U T	I N E =======================================


SFTFromFCB:
		push	ax
		push	bx
		mov	al, [si+18h]
		call	CheckFCB
		pop	bx
		pop	ax
		mov	word [ss:THISSFT], di
		mov	word [ss:THISSFT+2], es
		jnb	short Set_SFT
		push	es
		call	save_world
		call	FCBRegen
		call	restore_world
		pop	es
		mov	ax, [ss:EXTERR]
		jb	short BlastSFT_retn

Set_SFT:				; ...
		les	di, [ss:THISSFT]
		push	word [ss:PROC_ID]
		pop	word [es:di+31h]
		retn

; =============== S U B	R O U T	I N E =======================================


FCBHardErr:
		mov	es, [cs:DosDSeg]
		mov	ax, 23h	; '#'
		mov	byte [es:ALLOWED], 8
		les	bp, [es:THISDPB]
		mov	di, 1
		mov	cx, di
		mov	dx, [es:bp+0Bh]
		call	HARDERR
		stc
		retn

; =============== S U B	R O U T	I N E =======================================


GetRR:
		mov	ax, [si+21h]
		mov	dx, [si+23h]
		cmp	bx, 64
		jb	short GetRRBye
		xor	dh, dh

GetRRBye:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================


GetExtent:
		mov	al, [si+20h]
		mov	dx, [si+0Ch]
		shl	al, 1
		shr	dx, 1
		rcr	al, 1
		mov	ah, dl
		mov	dl, dh
		xor	dh, dh
		retn

; =============== S U B	R O U T	I N E =======================================


SetExtent:
		push	ax
		push	dx
		mov	cx, ax
		and	al, 7Fh
		mov	[si+20h], al
		and	cl, 80h
		shl	cx, 1
		rcl	dx, 1
		mov	al, ch
		mov	ah, dl
		mov	[si+0Ch], ax
		pop	dx
		pop	ax
		retn

; =============== S U B	R O U T	I N E =======================================


GetExtended:
		mov	si, dx
		cmp	byte [si], 0FFh
		jnz	short GetBye
		add	si, 7

GetBye:					; ...
		cmp	si, dx

getextd_retn:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================


GetRecSize:
		mov	bx, [si+0Eh]
		or	bx, bx
		jnz	short getextd_retn
		mov	bx, 128
		mov	[si+0Eh], bx
		retn

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

FCBIO:

;FCBOp		= byte ptr -14h
;cRecRes	= word ptr -13h
;cResult	= word ptr -11h
;cByte		= word ptr -0Fh
;bPosL		= word ptr -0Dh
;bPosH		= word ptr -0Bh
;RecSize	= word ptr -9
;RecPosL	= word ptr -7
;RecPosH	= word ptr -5
;cRec		= word ptr -3
;FCBErr		= byte ptr -1

FCBErr	equ -1	
cRec	equ -3
RecPosH equ -5
RecPosL	equ -7
RecSize	equ -9
bPosH	equ -11
bPosL	equ -13
cByte	equ -15	
cResult equ -17	
cRecRes	equ -19
FCBOp	equ -20

		push	bp
		mov	bp, sp
		sub	sp, 20
		mov	[bp+FCBOp], al
		mov	byte [bp+FCBErr], 0
		call	GetExtended
		test	byte [bp+FCBOp], 8
		jnz	short GetPos
		mov	cx, 1

GetPos:					; ...
		mov	[bp+cRec], cx
		call	GetExtent
		call	GetRecSize
		mov	[bp+RecSize], bx
		test	byte [bp+FCBOp], 2
		jz	short GetRec
		call	GetRR

GetRec:					; ...
		mov	[bp+RecPosL], ax
		mov	[bp+RecPosH], dx
		call	SetExtent
		mov	ax, [bp+RecPosH]
		mul	bx
		mov	di, ax
		mov	ax, [bp+RecPosL]
		mul	bx
		add	dx, di
		mov	[bp+bPosL], ax
		mov	[bp+bPosH], dx
		mov	ax, [bp+cRec]
		mul	bx
		mov	[bp+cByte], ax
		add	ax, word [ss:DMAADD]
		adc	dx, 0
		jz	short DoOper
		mov	byte [bp+FCBErr], 2
		mov	ax, word [ss:DMAADD]
		neg	ax
		jnz	short DoDiv
		dec	ax

DoDiv:					; ...
		xor	dx, dx
		div	bx
		mov	[bp+cRec], ax
		mul	bx
		mov	[bp+cByte], ax

DoOper:					; ...
		xor	bx, bx
		mov	[bp+cResult], bx
		cmp	[bp+cByte], bx
		jnz	short DoGetExt
		test	byte [bp+FCBErr], 2
		jz	short DoGetExt
		jmp	short SkipOp
; ---------------------------------------------------------------------------

DoGetExt:				; ...
		call	SFTFromFCB
		jnb	short ContinueOp

FCBDeath:				; ...
		call	FCB_RET_ERR
		mov	word [bp+cRecRes], 0
		mov	byte [bp+FCBErr], 1
		jmp	FCBSave
; ---------------------------------------------------------------------------

ContinueOp:				; ...
		mov	ax, [si+10h]
		mov	[es:di+11h], ax
		mov	ax, [si+12h]
		mov	[es:di+13h], ax
		mov	ax, [bp+bPosL]
		mov	dx, [bp+bPosH]
		mov	[es:di+15h], ax
		xchg	dx, [es:di+17h]
		push	dx
		mov	cx, [bp+cByte]
		mov	di, DOS_READ
		test	byte [bp+FCBOp], 4
		jnz	short DoContext
		mov	di, DOS_WRITE

DoContext:				; ...
		push	bp
		push	ds
		push	si
		push	ss
		pop	ds
		call	di ; DOS_READ
		pop	si
		pop	ds
		pop	bp
		jb	short FCBDeath
		cmp	byte [ss:DISK_FULL], 0
		jz	short NODSKFULL
		mov	byte [ss:DISK_FULL], 0
		mov	byte [bp+FCBErr], 1

NODSKFULL:				; ...
		mov	[bp+cResult], cx
		call	SaveFCBInfo
		pop	word [es:di+17h]
		mov	ax, [es:di+11h]
		mov	[si+10h], ax
		mov	ax, [es:di+13h]
		mov	[si+12h], ax

SkipOp:					; ...
		mov	ax, [bp+cResult]
		xor	dx, dx
		div	word [bp+RecSize]
		mov	[bp+cRecRes], ax
		add	[bp+RecPosL], ax
		adc	word [bp+RecPosH], 0
		cmp	ax, [bp+cRec]
		jz	short TryBlank
		test	byte [bp+FCBOp], 4
		jnz	short SetEOF
		test	byte [es:di+5], 80h
		jnz	short TryBlank

SetEOF:					; ...
		mov	byte [bp+FCBErr], 1

TryBlank:				; ...
		or	dx, dx
		jz	short SetExt
		add	word [bp+RecPosL], 1
		adc	word [bp+RecPosH], 0
		test	byte [bp+FCBOp], 4
		jz	short SetExt
		inc	word [bp+cRecRes]
		mov	byte [bp+FCBErr], 3
		mov	cx, [bp+RecSize]
		sub	cx, dx
		xor	al, al
		les	di, [ss:DMAADD]
		add	di, [bp+cResult]
		rep stosb

SetExt:					; ...
		mov	dx, [bp+RecPosH]
		mov	ax, [bp+RecPosL]
		test	byte [bp+FCBOp], 2
		jz	short DoSetExt
		test	byte [bp+FCBOp], 8
		jz	short TrySetRR

DoSetExt:				; ...
		call	SetExtent

TrySetRR:				; ...
		test	byte [bp+FCBOp], 8
		jz	short TryReturn
		mov	[si+21h], ax
		mov	[si+23h], dl
		cmp	word [si+0Eh], 64
		jnb	short TryReturn
		mov	[si+24h], dh

TryReturn:				; ...
		test	byte [bp+FCBOp], 4
		jnz	short FCBSave
		push	ds
		call	DATE16
		pop	ds
		mov	[si+14h], ax
		mov	[si+16h], dx

FCBSave:				; ...
		test	byte [bp+FCBOp], 8
		jz	short DoReturn
		mov	cx, [bp+cRecRes]
		call	Get_User_Stack
		mov	[si+4],	cx

DoReturn:				; ...
		mov	al, [bp+FCBErr]
		mov	sp, bp
		pop	bp
		retn

; =============== S U B	R O U T	I N E =======================================


$FCB_OPEN:
		mov	ax, 2
		mov	cx, DOS_OPEN

DoAccess:				; ...
		push	ds
		push	dx
		push	cx
		push	ax
		mov	di, OPENBUF
		call	TransFCB
		pop	ax
		pop	cx
		pop	dx
		pop	ds
		jnb	short FindFCB

FCBOpenErr:				; ...
		jmp	FCB_RET_ERR
; ---------------------------------------------------------------------------

FindFCB:				; ...
		call	GetExtended
		push	ax
		mov	al, 1
		call	LRUFCB
		pop	ax
		jb	short HardMessage
		mov	word [es:di+2], 8000h
		push	ds
		push	si
		push	bx
		mov	si, cx
		push	ss
		pop	ds
		call	si
		pop	bx
		pop	si
		pop	ds
		les	di, [ss:THISSFT]
		jnb	short FCBOK
		push	ax
		mov	al, 'R'
		call	BlastSFT
		pop	ax
		cmp	ax, 4
		jz	short HardMessage
		cmp	ax, 24h	; '$'
		jnz	short DeadFCB

HardMessage:				; ...
		push	ax
		call	FCBHardErr
		pop	ax

DeadFCB:				; ...
		jmp	short FCBOpenErr
; ---------------------------------------------------------------------------

FCBOK:					; ...
		call	IsSFTNet
		jnz	short FCBOK2
		call	CheckShare
		jnz	short FCBOK2
		mov	word [ss:LocalSFT], di
		mov	word [ss:LocalSFT+2], es

FCBOK2:					; ...
		inc	word [es:di]
		call	SaveFCBInfo
		test	byte [es:di+5], 80h
		jnz	short FCBNoDrive
		mov	al, [si]
		call	GETTHISDRV
		inc	al
		mov	[si], al

FCBNoDrive:				; ...
		mov	word [si+0Eh], 80h
		mov	ax, [es:di+0Dh]
		mov	[si+16h], ax
		mov	ax, [es:di+0Fh]
		mov	[si+14h], ax
		mov	ax, [es:di+11h]
		mov	[si+10h], ax
		mov	ax, [es:di+13h]
		mov	[si+12h], ax
		xor	ax, ax
		mov	[si+0Ch], ax
		les	di, [ss:SFTFCB]
		mov	ah, [es:di+4]

OpenScan:				; ...
		cmp	al, [si+18h]
		jz	short SkipCheck
		push	ax
		call	CheckFCB
		pop	ax
		jnb	short OpenFound

SkipCheck:				; ...
		inc	al
		cmp	al, ah
		jnz	short OpenScan

OpenDone:				; ...
		xor	al, al
		retn
; ---------------------------------------------------------------------------

OpenFound:				; ...
		mov	[si+18h], al
		inc	word [es:di]
		mov	ax, [ss:FCBLRU]
		mov	[es:di+15h], ax
		push	ss
		pop	ds
		les	di, [THISSFT]
		dec	word [es:di]
		call	ShareEnd
		mov	al, 'C'
		call	BlastSFT
		jmp	short OpenDone

; ---------------------------------------------------------------------------

$FCB_CREATE:				; ...
		mov	cx, DOS_CREATE
		xor	ax, ax
		call	GetExtended
		jz	short DoAccessJ
		mov	al, [si-1]

DoAccessJ:				; ...
		jmp	DoAccess
; ---------------------------------------------------------------------------

$FCB_RANDOM_WRITE_BLOCK:		; ...
		mov	al, 0Ah
		jmp	FCBIO
; ---------------------------------------------------------------------------

$FCB_RANDOM_READ_BLOCK:			; ...
		mov	al, 0Eh
		jmp	FCBIO
; ---------------------------------------------------------------------------

$FCB_SEQ_READ:				; ...
		mov	al, 4
		jmp	FCBIO
; ---------------------------------------------------------------------------

$FCB_SEQ_WRITE:				; ...
		mov	al, 0
		jmp	FCBIO
; ---------------------------------------------------------------------------

$FCB_RANDOM_READ:			; ...
		mov	al, 6
		jmp	FCBIO
; ---------------------------------------------------------------------------

$FCB_RANDOM_WRITE:			; ...
		mov	al, 2
		jmp	FCBIO
; ---------------------------------------------------------------------------

$DIR_SEARCH_FIRST:			; ...
		mov	word [ss:THISFCB], dx
		mov	word [ss:THISFCB+2], ds
		mov	si, dx
		cmp	byte [si], 0FFh
		jnz	short NORMFCB4
		add	si, 7

NORMFCB4:				; ...
		push	word [si]
		push	ss
		pop	es
		mov	di, OPENBUF
		call	TransFCB
		jnb	short SearchIt
		pop	bx

dsf_err:				; ...
		jmp	FCB_RET_ERR
; ---------------------------------------------------------------------------

SearchIt:				; ...
		push	ss
		pop	ds
		push	word [DMAADD]
		push	word [DMAADD+2]
		mov	word [DMAADD], SEARCHBUF
		mov	word [DMAADD+2], ds
		call	GET_FAST_SEARCH
		pop	word [DMAADD+2]
		pop	word [DMAADD]
		jnb	short SearchSet
		pop	bx
		jmp	short dsf_err
; ---------------------------------------------------------------------------

SearchSet:				; ...
		mov	si, SEARCHBUF
		les	di, [THISFCB]
		test	byte [EXTFCB], 0FFh
		jz	short NORMFCB1
		add	di, 7

NORMFCB1:				; ...
		pop	bx
		or	bl, bl
		jnz	short SearchDrv
		mov	bl, [CURDRV]
		inc	bl

SearchDrv:				; ...
		lodsb
		xchg	al, bl
		inc	di
		mov	cx, 10
		rep movsw
		xchg	al, bl
		stosb
		les	di, [DMAADD]
		test	byte [EXTFCB], 0FFh
		jz	short NORMFCB2
		mov	al, 0FFh
		stosb
		inc	al
		mov	cx, 5
		rep stosb
		mov	al, [SATTRIB]
		stosb

NORMFCB2:				; ...
		mov	al, bl
		stosb
		mov	cx, 16
		rep movsw
		jmp	NO_OP
; ---------------------------------------------------------------------------

$DIR_SEARCH_NEXT:			; ...
		mov	word [ss:THISFCB], dx
		mov	word [ss:THISFCB+2], ds
		mov	byte [ss:SATTRIB], 0
		mov	byte [ss:EXTFCB], 0
		push	ss
		pop	es
		mov	di, SEARCHBUF
		mov	si, dx
		cmp	byte [si], 0FFh
		jnz	short NORMFCB6
		add	si, 6
		lodsb
		mov	byte [ss:SATTRIB], al
		dec	byte [ss:EXTFCB]

NORMFCB6:				; ...
		lodsb
		push	ax
		mov	al, [si+20]
		stosb
		mov	cx, 10
		rep movsw
		push	ss
		pop	ds
		push	word [DMAADD]
		push	word [DMAADD+2]
		mov	word [DMAADD], SEARCHBUF
		mov	word [DMAADD+2], ds
		call	DOS_SEARCH_NEXT
		pop	word [DMAADD+2]
		pop	word [DMAADD]
		jb	short SearchNoMore
		jmp	SearchSet
; ---------------------------------------------------------------------------

SearchNoMore:				; ...
		les	di, [THISFCB]
		test	byte [EXTFCB], 0FFh
		jz	short NORMFCB8
		add	di, 7

NORMFCB8:				; ...
		pop	bx
		mov	[es:di], bl
		jmp	FCB_RET_ERR
; ---------------------------------------------------------------------------

$FIND_FIRST:				; ...
		mov	si, dx
		mov	byte [ss:SATTRIB], cl
		mov	di, OPENBUF
		call	TransPathSet
		jnb	short Find_it
		mov	al, 3

FindError:				; ...
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

Find_it:				; ...
		push	ss
		pop	ds
		push	word [DMAADD]
		push	word [DMAADD+2]
		mov	word [DMAADD], SEARCHBUF
		mov	word [DMAADD+2], ds
		call	GET_FAST_SEARCH
		pop	word [DMAADD+2]
		pop	word [DMAADD]
		jnb	short FindSet

FindItError:				; ...
		jmp	short FindError
; ---------------------------------------------------------------------------

FindSet:				; ...
		mov	si, SEARCHBUF
		les	di, [DMAADD]
		mov	cx, 21
		rep movsb
		push	si
		mov	al, [si+0Bh]
		stosb
		add	si, 16h
		movsw
		movsw
		inc	si
		inc	si
		movsw
		movsw
		pop	si
		call	PackName
		jmp	SYS_RET_OK
; ---------------------------------------------------------------------------

$FIND_NEXT:				; ...
		push	ss
		pop	es
		mov	di, SEARCHBUF
		lds	si, [ss:DMAADD]
		mov	cx, 21
		rep movsb
		push	ss
		pop	ds
		push	word [DMAADD]
		push	word [DMAADD+2]
		mov	word [DMAADD], SEARCHBUF
		mov	word [DMAADD+2], ds
		call	DOS_SEARCH_NEXT
		pop	word [DMAADD+2]
		pop	word [DMAADD]
		jnb	short FindSet
		jmp	short FindItError

; =============== S U B	R O U T	I N E =======================================


PackName:
		mov	cx, 8
		rep movsb

main_kill_tail:				; ...
		cmp	byte [es:di-1], ' '
		jnz	short find_check_dot
		dec	di
		inc	cx
		cmp	cx, 8
		jb	short main_kill_tail

find_check_dot:				; ...
		cmp	word [si], '  '
		jnz	short got_ext
		cmp	byte [si+2], ' '
		jz	short find_done

got_ext:				; ...
		mov	al, '.'
		stosb
		mov	cx, 3
		rep movsb

ext_kill_tail:				; ...
		cmp	byte [es:di-1], ' '
		jnz	short find_done
		dec	di
		jmp	short ext_kill_tail
; ---------------------------------------------------------------------------

find_done:				; ...
		xor	ax, ax
		stosb
		retn

; =============== S U B	R O U T	I N E =======================================


GET_FAST_SEARCH:
		or	word [ss:DOS34_FLAG], 400h
		call	DOS_SEARCH_FIRST
		retn

; ---------------------------------------------------------------------------

$CURRENT_DIR:				; ...
		call	ECritDisk
		mov	al, dl
		call	GetVisDrv
		jnb	short CurrentValidate

CurdirErr:				; ...
		call	LCritDisk
		push	ds
		mov	ds, [cs:DosDSeg]
		mov	al, [DrvErr]
		pop	ds

curdir_errj:				; ...
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

CurrentValidate:			; ...
		push	ds
		push	si
		mov	ds, [cs:DosDSeg]
		lds	si, [THISCDS]
		test	word [si+43h], 8000h
		jnz	short $+2
		push	ds
		mov	ds, [cs:DosDSeg]
		mov	byte [NoSetDir], 0
		pop	ds
		mov	di, OPENBUF
		call	ValidateCDS
		push	es
		push	di
		pop	si
		pop	ds
		pop	di
		pop	es
		jb	short CurdirErr
		add	si, 0
		add	si, [si+4Fh]
		cmp	byte [si], '\'
		jnz	short CurrentCopy
		inc	si

CurrentCopy:				; ...
		push	ax
		lodsb
		or	al, al
		jz	short FOK
		cmp	al, 5
		jz	short FCHANGE
		jmp	short FFF
; ---------------------------------------------------------------------------

FCPYNEXT:				; ...
		lodsb

FFF:					; ...
		cmp	al, '\'
		jnz	short FOK
		stosb
		lodsb
		cmp	al, 5
		jnz	short FOK

FCHANGE:				; ...
		mov	al, 0E5h ; 'å'

FOK:					; ...
		stosb
		or	al, al
		jnz	short FCPYNEXT
		pop	ax
		xor	al, al
		call	LCritDisk
		jmp	SYS_RET_OK
; ---------------------------------------------------------------------------

$RMDIR:					; ...
		push	dx
		push	ds
		mov	si, dx
		mov	di, OPENBUF
		push	di
		call	TransPathNoSet
		pop	di
		jnb	short rmlset
		pop	ds
		pop	dx
		mov	al, 3

rmdir_errj:				; ...
		jmp	short curdir_errj
; ---------------------------------------------------------------------------

rmlset:					; ...
		cmp	byte [ss:CMETA], 0FFh
		jnz	short rmerr
		push	ss
		pop	es
		xor	al, al

rmloop:					; ...
		call	GetCDSFromDrv
		jb	short rmcont
		call	StrCmp
		jz	short rmerr
		inc	al
		jmp	short rmloop
; ---------------------------------------------------------------------------

rmerr:					; ...
		pop	ds
		pop	dx
		mov	al, 10h

rmerrj:					; ...
		jmp	short rmdir_errj
; ---------------------------------------------------------------------------

rmcont:					; ...
		pop	ds
		pop	dx
		mov	si, DOS_RMDIR
		;; 27/09/2023 (*)
		;jmp	DoDirCall	; jmp short DoDirCall ; db 0EBh,7Fh
		;			; (!NASM converts it to short jump!)
		; 27/09/2023 (*)
		;db	0E9h,7Fh,0	; near call
		;			; (as in the original MSDOS.SYS)
		db	0E9h
		dw	(DoDirCall-nextinstr)
nextinstr:		

; ---------------------------------------------------------------------------

$CHDIR:					; (Here must be DOSCODE:6065h) (*)
		mov	di, OPENBUF
		mov	si, dx
		call	TransPath
		jnb	short ChDirCrack

ChDirErrP:				; ...
		mov	al, 3

ChDirErr:				; ...
		jmp	short rmerrj
; ---------------------------------------------------------------------------

ChDirCrack:				; ...
		cmp	byte [CMETA], 0FFh
		jnz	short ChDirErrP
		les	di, [THISCDS]
		cmp	di, 0FFFFh
		jz	short ChDirErrP
		call	DOS_CHDIR
		jb	short ChDirErr
		les	di, [THISCDS]
		test	word [es:di+43h], 2000h
		jz	short GotCDS
		push	es
		push	di
		push	cx
		call	Get_User_Stack
		mov	di, [si+6]
		mov	ds, word [si+0Eh]
		mov	si, OPENBUF
		xchg	si, di
		xor	al, al
		push	di
		call	TransPathNoSet
		pop	si
		les	di, [THISCDS]
		mov	word [es:di+49h], 0FFFFh
		pop	cx
		pop	di
		pop	es

GotCDS:					; ...
		call	Check_PathLen
		ja	short ChDirErrP
		test	word [es:di+43h], 8000h
		jnz	short SkipRecency
		test	word [es:di+43h], 2000h
		jz	short setdirclus
		mov	cx, 0FFFFh

setdirclus:				; ...
		mov	[es:di+49h], cx
		les	di, [THISCDS]

SkipRecency:				; ...
		call	FStrCpy
		xor	al, al

mkdir_ok:				; ...
		jmp	SYS_RET_OK
; ---------------------------------------------------------------------------

$MKDIR:					; ...
		mov	si, DOS_MKDIR

DoDirCall:				; ...
		mov	di, OPENBUF
		push	si
		mov	si, dx
		call	TransPath
		pop	si
		jnb	short MkDirCrack

MkErrP:					; ...
		mov	al, 3

MkErr:					; ...
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

MkDirCrack:				; ...
		cmp	byte [ss:CMETA], 0FFh
		jnz	short MkErrP
		push	si
		call	Check_PathLen
		pop	si
		jbe	short pathok
		mov	al, 5
		jmp	short MkErr
; ---------------------------------------------------------------------------

pathok:					; ...
		call	si
		jb	short MkErr
		jmp	short mkdir_ok

; =============== S U B	R O U T	I N E =======================================


Check_PathLen:
		mov	si, [ss:WFP_START]

; =============== S U B	R O U T	I N E =======================================


check_PathLen2:
		push	ss
		pop	ds
		push	cx
		call	DStrLen
		cmp	cx, 67
		pop	cx
		retn

; ---------------------------------------------------------------------------
IOCTLJMPTABLE:	dw ioctl_getset_data ; ...
		dw ioctl_getset_data
		dw ioctl_control_string
		dw ioctl_control_string
		dw ioctl_get_dev
		dw ioctl_get_dev
		dw ioctl_status
		dw ioctl_status
		dw ioctl_rem_media
		dw ioctl_drive_attr
		dw ioctl_handle_redir
		dw Set_Retry_Parameters
		dw GENERICIOCTLHANDLE
		dw GENERICIOCTL
		dw ioctl_drive_owner
		dw ioctl_drive_owner
		dw GENERICIOCTLHANDLE ; query_handle_support
		dw GENERICIOCTL	; query_device_support

; =============== S U B	R O U T	I N E =======================================


$IOCTL:

; FUNCTION CHUNK AT 43F1 SIZE 0000001C BYTES
; FUNCTION CHUNK AT 63B3 SIZE 0000004A BYTES

		mov	si, ds
		push	ss
		pop	ds
		cmp	al, 11h
		ja	short ioctl_bad_funj2
		push	ax
		mov	di, ax
		and	di, 0FFh
		shl	di, 1
		pop	ax
		jmp	[cs:IOCTLJMPTABLE+di]
; ---------------------------------------------------------------------------

ioctl_bad_funj2:			; ...
		jmp	ioctl_bad_fun
; ---------------------------------------------------------------------------

ioctl_getset_data:			; ...
		call	SFFromHandle
		jnb	short ioctl_check_permissions

ioctl_bad_handle:			; ...
		mov	al, 6

ioctl_error:				; ...
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

ioctl_check_permissions:		; ...
		cmp	al, 0
		mov	al, [es:di+5]
		jz	short ioctl_read
		or	dh, dh
		jz	short ioctl_check_device
		mov	al, 0Dh
		jmp	short ioctl_error
; ---------------------------------------------------------------------------

ioctl_check_device:			; ...
		test	al, 80h
		jz	short ioctl_bad_funj2
		or	dl, 80h
		mov	byte [EXTERR_LOCUS], 4
		mov	[es:di+5], dl

ioctl_ok:				; ...
		jmp	SYS_RET_OK
; ---------------------------------------------------------------------------

ioctl_read:				; ...
		mov	byte [EXTERR_LOCUS], 2
		xor	ah, ah
		test	al, 80h
		jz	short ioctl_no_high
		mov	byte [EXTERR_LOCUS], 4
		les	di, [es:di+7]
		mov	ah, [es:di+5]

ioctl_no_high:				; ...
		mov	dx, ax
		call	Get_User_Stack
		mov	[si+6],	dx

jmp_to_ioctl_ok:			; ...
		jmp	short ioctl_ok
; ---------------------------------------------------------------------------

ioctl_control_string:			; ...
		call	SFFromHandle
		jb	short ioctl_bad_handle
		test	byte [es:di+5], 80h
		jz	short ioctl_bad_funj2
		mov	byte [EXTERR_LOCUS], 4
		les	di, [es:di+7]
		xor	bl, bl
		jmp	ioctl_do_string
; ---------------------------------------------------------------------------

ioctl_status:				; ...
		mov	ah, 1
		sub	al, 6
		jz	short ioctl_get_status
		mov	ah, 3

ioctl_get_status:			; ...
		push	ax
		call	GET_IO_SFT
		pop	ax
		jnb	short DO_IOFUNC
		jmp	short ioctl_bad_handle
; ---------------------------------------------------------------------------

DO_IOFUNC:				; ...
		call	IOFUNC
		mov	ah, al
		mov	al, 0FFh
		jnz	short ioctl_status_ret
		inc	al

ioctl_status_ret:			; ...
		jmp	short jmp_to_ioctl_ok
; ---------------------------------------------------------------------------

Set_Retry_Parameters:			; ...
		mov	[RetryLoop], cx
		or	dx, dx
		jz	short ioctl_bad_fun
		mov	[RetryCount], dx
		jmp	short ioctl_status_ret
; ---------------------------------------------------------------------------

GENERICIOCTLHANDLE:			; ...
		call	SFFromHandle
		jb	short ioctl_bad_handlej
		test	byte [es:di+6], 80h
		jnz	short ioctl_bad_fun
		mov	byte [EXTERR_LOCUS], 4
		les	di, [es:di+7]
		jmp	short Do_GenIOCTL
; ---------------------------------------------------------------------------

GENERICIOCTL:				; ...
		mov	byte [EXTERR_LOCUS], 2
		cmp	ch, 8
		jnz	short ioctl_bad_fun
		call	Check_If_Net
		jnz	short ioctl_bad_fun

Do_GenIOCTL:				; ...
		test	byte [es:di+4], 40h
		jz	short ioctl_bad_fun
		mov	byte [IOCALL_REQFUNC], 13h
		cmp	al, 10h
		jl	short SetIOCtlBlock
		test	byte [es:di+4], 80h
		jz	short ioctl_bad_fun
		mov	byte [IOCALL_REQFUNC], 19h

SetIOCtlBlock:				; ...
		push	es
		push	di
		mov	byte [IOCALL], 23
		mov	[IOCALL_REQUNIT], bl
		mov	byte [IOMED], ch
		mov	byte [IOXAD], cl
		mov	word [IOXAD+1], si
		mov	word [IOXAD+3], di
		mov	[IOSCNT+1], dx
		mov	[IOSSEC+1], si
		mov	bx, IOCALL
		push	ss
		pop	es
		pop	si
		pop	ds
		jmp	ioctl_do_IO
; ---------------------------------------------------------------------------

ioctl_bad_fun:				; ...
		mov	al, 1
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

ioctl_bad_handlej:			; ...
		jmp	ioctl_bad_handle
; ---------------------------------------------------------------------------

ioctl_rem_media:			; ...
		call	Check_If_Net
		jnz	short ioctl_bad_fun
		test	byte [es:di+5], 8
		jz	short ioctl_bad_fun
		mov	byte [ss:IOCALL_REQFUNC], 15
		mov	al, 13
		mov	ah, bl
		mov	word [ss:IOCALL], ax
		xor	ax, ax
		mov	[ss:IOCALL_REQSTAT], ax
		push	es
		pop	ds
		mov	si, di
		push	ss
		pop	es
		mov	bx, IOCALL
		push	ds
		push	si
		call	DEVIOCALL2
		pop	si
		pop	ds
		mov	ax, [ss:IOCALL_REQSTAT]
		and	ax, 200h
		mov	cl, 9
		shr	ax, cl

ioctlt_rmed_ok:				; ...
		jmp	SYS_RET_OK
; ---------------------------------------------------------------------------

ioctl_drive_attr:			; ...
		mov	al, bl
		call	GETTHISDRV
		jb	short ioctl_drv_err
		call	Get_Driver_BL
		jb	short ioctl_drv_err
		mov	dx, [es:di+4]
		mov	bl, al
		les	di, [ss:THISCDS]
		test	byte [es:di+44h], 80h
		jz	short IOCTLShare
		mov	dx, 1000h

IOCTLShare:				; ...
		push	ss
		pop	ds
		mov	si, OPENBUF
		add	bl, 'A'
		mov	[si], bl
		mov	word [si+1], ':'
		mov	ax, 300h
		clc
		int	2Ah		; Microsoft Networks - CHECK DIRECT I/O
					; DS:SI	-> ASCIZ disk device name (may be full path or only drive
					; specifier--must include the colon)
					; Return: CF clear if absolute disk access allowed
		jnb	short IOCTLLocal
		or	dx, 200h

IOCTLLocal:				; ...
		test	byte [es:di+44h], 10h
		jz	short ioctl_set_DX
		or	dx, 8000h

ioctl_set_DX:				; ...
		call	Get_User_Stack
		mov	[si+6],	dx

ioctl_dattr_ok:				; ...
		jmp	short ioctlt_rmed_ok
; ---------------------------------------------------------------------------

ioctl_drv_err:				; ...
		mov	al, 0Fh

ioctl_dattr_errj:			; ...
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

ioctl_handle_redir:			; ...
		call	SFFromHandle
		jnb	short ioctl_got_sft
		jmp	ioctl_bad_handle
; ---------------------------------------------------------------------------

ioctl_got_sft:				; ...
		mov	dx, [es:di+5]
		jmp	short ioctl_set_DX
; ---------------------------------------------------------------------------

ioctl_bad_funj:				; ...
		jmp	ioctl_bad_fun
; ---------------------------------------------------------------------------

ioctl_get_dev:				; ...
		call	Check_If_Net
		jnz	short ioctl_bad_funj

ioctl_do_string:			; ...
		test	byte [es:di+5], 40h
		jz	short ioctl_bad_funj
		mov	byte [IOCALL_REQFUNC], 3
		test	al, 1
		jz	short ioctl_control_call
		mov	byte [IOCALL_REQFUNC], 12

ioctl_control_call:			; ...
		mov	al, 22
		mov	ah, bl
		mov	word [IOCALL], ax
		xor	ax, ax
		mov	[IOCALL_REQSTAT], ax
		mov	byte [IOMED], al
		mov	word [IOSCNT], cx
		mov	word [IOXAD], dx
		mov	word [IOXAD+2], si
		push	es
		pop	ds
		mov	si, di
		push	ss
		pop	es
		mov	bx, IOCALL

ioctl_do_IO:				; ...
		call	DEVIOCALL2
		test	byte [ss:IOCALL_REQSTAT+1], 80h
		jnz	short ioctl_string_err
		mov	ax, [ss:IOSCNT]
		jmp	short ioctl_dattr_ok
; ---------------------------------------------------------------------------

ioctl_string_err:			; ...
		mov	di, [ss:IOCALL_REQSTAT]
		and	di, 0FFh
		mov	ax, di
		call	SET_I24_EXTENDED_ERROR
		mov	ax, [ss:EXTERR]
		jmp	short ioctl_dattr_errj

; =============== S U B	R O U T	I N E =======================================


Get_Driver_BL:
		push	ax
		mov	al, bl
		call	GETTHISDRV
		jb	short ioctl_bad_drv
		xor	bl, bl
		mov	byte [EXTERR_LOCUS], 3
		les	di, [THISCDS]
		test	byte [es:di+44h], 80h
		les	di, [es:di+45h]
		jnz	short got_dev_ptr
		mov	byte [EXTERR_LOCUS], 2
		mov	bl, [es:di+1]
		les	di, [es:di+13h]

got_dev_ptr:				; ...
		clc

ioctl_bad_drv:				; ...
		pop	ax
		retn


; =============== S U B	R O U T	I N E =======================================


Check_If_Net:
		call	Get_Driver_BL
		jb	short ioctl_drv_err_pop
		push	es
		push	di
		les	di, [THISCDS]
		test	byte [es:di+44h], 80h
		pop	di
		pop	es
		retn
; ---------------------------------------------------------------------------

ioctl_drv_err_pop:			; ...
		pop	ax
		jmp	ioctl_drv_err

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR $IOCTL

ioctl_bad_funj3:			; ...
		jmp	ioctl_bad_fun
; ---------------------------------------------------------------------------

ioctl_string_errj:			; ...
		jmp	short ioctl_string_err
; ---------------------------------------------------------------------------

ioctl_drive_owner:			; ...
		call	Check_If_Net
		jnz	short ioctl_bad_funj3
		test	byte [es:di+4], 40h
		jz	short ioctl_bad_funj3
		mov	byte [IOCALL_REQFUNC], 23
		cmp	al, 0Eh
		jz	short GetOwner
		mov	byte [IOCALL_REQFUNC], 24

GetOwner:				; ...
		mov	al, 13
		mov	ah, bl
		mov	word [IOCALL], ax
		xor	ax, ax
		mov	[IOCALL_REQSTAT], ax
		push	es
		pop	ds
		mov	si, di
		push	ss
		pop	es
		mov	bx, IOCALL
		push	ds
		push	si
		call	DEVIOCALL2
		pop	si
		pop	ds
		test	byte [ss:IOCALL_REQSTAT+1], 80h
		jnz	short ioctl_string_errj
		mov	al, [ss:IOCALL_REQUNIT]
		jmp	SYS_RET_OK
; END OF FUNCTION CHUNK	FOR $IOCTL

; =============== S U B	R O U T	I N E =======================================


DOS_DELETE:
		call	TestNet
		jnb	short LOCAL_DELETE
		mov	ax, 1113h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - DELETE REMOTE FILE
					; SS = DS = DOS	CS, SDA	first filename pointer -> fully-qualified filename in DOS CS
					; SDA CDS pointer -> current directory structure for drive with	file
					; Return: CF set on error
		retn
; ---------------------------------------------------------------------------

LOCAL_DELETE:				; ...
		mov	byte [FOUNDDEL], 0
		call	ECritDisk
		mov	word [CREATING], 0E500h
		mov	si, [WFP_START]

SKPNUL:					; ...
		lodsb
		or	al, al
		jnz	short SKPNUL
		sub	si, 4
		cmp	word [si], '*.'	; '.*' 
		jnz	short TEST_QUEST
		cmp	byte [si+2], '*'
		jz	short CHECK_ATTS

TEST_QUEST:				; ...
		sub	si, 9
		xchg	di, si
		push	ss
		pop	es
		mov	ax, '??'
		mov	cx, 4
		repe scasw
		jnz	short NOT_ALL
		xchg	di, si
		lodsw
		cmp	ax, '?.'
		jnz	short NOT_ALL
		lodsw
		cmp	ax, '??'
		jnz	short NOT_ALL

CHECK_ATTS:				; ...
		mov	al, [SATTRIB]
		and	al, 1Fh
		cmp	al, 1Fh
		jnz	short NOT_ALL
		mov	byte [DELALL], 0

NOT_ALL:				; ...
		mov	byte [NoSetDir], 1
		call	GetPathNoSet
		jnb	short Del_found
		jnz	short _bad_path
		or	cl, cl
		jz	short _bad_path

No_file:				; ...
		mov	ax, 2

ErrorReturn:				; ...
		stc
		call	LCritDisk
		retn
; ---------------------------------------------------------------------------

_bad_path:				; ...
		mov	ax, 3
		jmp	short ErrorReturn
; ---------------------------------------------------------------------------

Del_found:				; ...
		jnz	short NOT_DIR
		cmp	byte [DELALL], 0
		jz	short NOT_DIR

Del_access_err:				; ...
		mov	ax, 5
		jmp	short ErrorReturn
; ---------------------------------------------------------------------------

NOT_DIR:				; ...
		or	ah, ah
		js	short Del_access_err

DELFILE:				; ...
		or	byte [FOUNDDEL], 1
		push	ds
		mov	ah, [DELALL]
		lds	di, [CURBUF]
		test	byte [ss:ATTRIB], 1
		jnz	short DoDelete
		test	byte [bx+0Bh], 1
		jz	short DoDelete
		pop	ds
		jmp	short DELNXT
; ---------------------------------------------------------------------------

DoDelete:				; ...
		call	REN_DEL_Check
		jnb	short DEL_SHARE_OK
		pop	ds
		jmp	short DELNXT
; ---------------------------------------------------------------------------

DEL_SHARE_OK:				; ...
		test	byte [di+5], 40h
		jnz	short yesdirty
		call	INC_DIRTY_COUNT
		or	byte [di+5], 40h

yesdirty:				; ...
		mov	[bx], ah
		mov	bx, [si]
		pop	ds
		or	byte [FOUNDDEL], 10h
		cmp	bx, 2
		jb	short DELNXT
		cmp	bx, [es:bp+0Dh]
		ja	short DELNXT
		call	RELEASE
		jb	short No_fileJ
		call	FastOpen_Delete

DELNXT:					; ...
		les	bp, [THISDPB]
		call	GETENTRY
		jb	short No_fileJ
		call	NEXTENT
		jnb	short DELFILE
		les	bp, [THISDPB]
		mov	al, [es:bp+0]
		call	FLUSHBUF
		jb	short No_fileJ
		test	byte [FOUNDDEL], 10h
		jz	short DelError
		test	byte [ATTRIB], 8
		jz	short No_Set_Flag
		push	ax
		push	es
		push	di
		les	di, [THISCDS]
		mov	ah, [es:di]
		sub	ah, 'A'
		mov	byte [VOLCHNG_FLAG], ah
		xor	bh, bh
		call	Set_Media_ID
		call	FATREAD_CDS
		pop	di
		pop	es
		pop	ax

No_Set_Flag:				; ...
		call	LCritDisk
		retn
; ---------------------------------------------------------------------------

DelError:				; ...
		test	byte [FOUNDDEL], 1
		jnz	short Del_access_errJ

No_fileJ:				; ...
		jmp	No_file
; ---------------------------------------------------------------------------

Del_access_errJ:			; ...
		jmp	Del_access_err

; =============== S U B	R O U T	I N E =======================================


REN_DEL_Check:
		push	ds
		push	di
		push	ax
		push	bx
		push	si
		push	ss
		pop	es
		mov	di, [ss:WFP_START]
		mov	si, bx
		mov	ds, word [ss:CURBUF+2]
		mov	bx, di
		add	bx, 2
		call	StrLen
		dec	cx
		add	di, cx
		call	SkipBack
		inc	di
		mov	[ss:SAVE_BX], di
		call	PackName
		pop	si
		pop	bx
		push	bx
		push	si
		push	ss
		pop	ds
		call	far [ShCloseFile]
		mov	word [THISSFT+2], ds
		mov	word [THISSFT], RENAMEDMA+145h ; AUXSTACK-SF_ENTRY.size
					; RENAMEDMA+(384-59)
		xor	ah, ah
		call	DOOPEN
		les	di, [THISSFT]
		mov	word [es:di+2], 10h
		mov	word [es:di], 1
		call	ShareEnter
		jb	short CheckDone
		les	di, [THISSFT]
		mov	word [es:di], 0
		call	ShareEnd
		clc

CheckDone:				; ...
		les	bp, [THISDPB]
		pop	si
		pop	bx
		pop	ax
		pop	di
		pop	ds
		retn

; =============== S U B	R O U T	I N E =======================================


FastOpen_Delete:
		pushf
		push	si
		push	bx
		push	ax
		mov	si, [ss:WFP_START]
		mov	al, 3

fastinvoke:				; ...
		mov	bx, FastTable_2
		call	far [bx]
		pop	ax
		pop	bx
		pop	si
		popf
		retn

; =============== S U B	R O U T	I N E =======================================


FastOpen_Rename:
		pushf
		push	si
		push	di
		push	bx
		push	ax
		mov	si, [ss:REN_WFP]
		mov	di, NAME1
		mov	al, 6
		mov	bx, FastTable_2
		call	far [bx]
		pop	ax
		pop	bx
		pop	di
		pop	si
		popf
		retn

; =============== S U B	R O U T	I N E =======================================


FastOpen_Update:
		pushf
		push	si
		push	bx
		push	ax
		mov	al, 4
		jmp	short fastinvoke

; =============== S U B	R O U T	I N E =======================================


Fast_Dispatch:
		mov	si, FastTable_2
		call	far [ss:si]
		retn

; =============== S U B	R O U T	I N E =======================================


DOS_RENAME:
		call	TestNet
		jnb	short LOCAL_RENAME
		mov	ax, 1111h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - RENAME REMOTE FILE
					; SS = DS = DOS	CS, SDA	first filename pointer = offset	of fully-qualified old name
					; SDA CDS pointer -> current directory
					; Return: CF set on error
		retn
; ---------------------------------------------------------------------------

LOCAL_RENAME:				; ...
		mov	byte [EXTERR_LOCUS], 2
		mov	si, [WFP_START]
		mov	di, [REN_WFP]
		mov	al, [si]
		mov	ah, [di]
		or	ax, 2020h
		cmp	al, ah
		jz	short SAMEDRV
		mov	ax, 11h
		stc
		retn
; ---------------------------------------------------------------------------

SAMEDRV:				; ...
		push	word [DMAADD+2]
		push	word [DMAADD]
		mov	word [DMAADD+2], ds
		mov	word [DMAADD], RENAMEDMA
		mov	byte [FOUND_DEV], 0
		call	ECritDisk
		call	DOS_SEARCH_FIRST
		jnb	short Check_Dev
		cmp	ax, 12h
		jnz	short GOTERR
		mov	ax, 2

GOTERR:					; ...
		stc

RENAME_POP:				; ...
		pop	word [DMAADD]
		pop	word [DMAADD+2]
		call	LCritDisk
		retn
; ---------------------------------------------------------------------------

Check_Dev:				; ...
		mov	ax, 5
		push	ds
		lds	si, [DMAADD]
		add	si, 21
		test	byte [si+11], 10h
		jz	short notdir
		mov	si, [REN_WFP]
		call	check_PathLen2

notdir:					; ...
		pop	ds
		ja	short GOTERR
		cmp	byte [FOUND_DEV], 0
		jnz	short GOTERR
		mov	si, bx
		add	si, 26
		call	REN_DEL_Check
		jnb	short REN_OK1
		mov	ax, 20h
		jmp	short RENAME_POP
; ---------------------------------------------------------------------------

REN_OK1:				; ...
		push	si
		lds	si, [DMAADD]
		add	si, 21
		test	byte [si+11], 10h
		jz	short NOT_DIR1
		pop	si
		jmp	short SWAP_SOURCE
; ---------------------------------------------------------------------------

NOT_DIR1:				; ...
		pop	si
		call	FastOpen_Delete

SWAP_SOURCE:				; ...
		mov	ax, [WFP_START]
		mov	si, [REN_WFP]
		mov	[WFP_START], si
		mov	[REN_WFP], ax
		mov	word [CURR_DIR_END], 0FFFFh
		mov	word [CREATING], 0E5FFh
		call	GetPathNoSet
		jb	short NODEST
		or	ah, ah
		jns	short SAVEDEST

BAD_ACC:				; ...
		mov	ax, 5
		stc

RENAME_CLEAN:				; ...
		pushf
		push	ax
		mov	al, [THISDRV]
		call	FLUSHBUF
		pop	ax
		cmp	byte [FAILERR], 0
		jnz	short BAD_ERR
		popf
		jmp	RENAME_POP
; ---------------------------------------------------------------------------

BAD_ERR:				; ...
		pop	ax
		mov	ax, 3
		jmp	GOTERR
; ---------------------------------------------------------------------------

NODEST:					; ...
		jnz	short BAD_PATH
		cmp	byte [FAILERR], 0
		jnz	short BAD_PATH
		or	cl, cl
		jnz	short SAVEDEST

BAD_PATH:				; ...
		mov	ax, 3
		stc
		jmp	RENAME_POP
; ---------------------------------------------------------------------------

SAVEDEST:				; ...
		push	ss
		pop	es
		mov	di, NAME2
		mov	si, NAME1
		mov	cx, 11
		rep movsb
		mov	ax, [DIRSTART]
		mov	[DESTSTART], ax

BUILDDEST:				; ...
		push	ss
		pop	es
		mov	bx, RENAMEDMA+15h
		mov	di, NAME1
		mov	si, NAME2
		mov	cx, 11
		call	NEW_RENAME
		mov	byte [ATTRIB], 16h
		mov	byte [CREATING], 0FFh
		call	DEVNAME
		jnb	short BAD_ACC
		mov	bx, [DESTSTART]
		les	bp, [THISDPB]
		call	SETDIRSRCH
		jb	short BAD_ACC
		call	SEARCH
		jnb	short BAD_ACC
		cmp	byte [FAILERR], 0
		jnz	short BAD_ACCJ
		mov	ax, [DESTSTART]
		cmp	ax, word [RENAMEDMA+0Fh]
		jz	short SIMPLE_RENAME
		mov	al, [RENAMEDMA+20h]
		test	al, 10h
		jnz	short BAD_ACCJ
		mov	byte [ATTRIB], al
		mov	word [THISSFT+2], ds
		mov	si, RENAMEDMA+145h
		mov	word [THISSFT], si
		mov	word [si+2], 2
		xor	cx, cx
		call	RENAME_MAKE
		jnb	short GOT_DEST

BAD_ACCJ:				; ...
		jmp	BAD_ACC
; ---------------------------------------------------------------------------

GOT_DEST:				; ...
		push	bx
		les	di, [THISSFT]
		call	ShareEnd
		pop	bx
		les	di, [CURBUF]
		test	byte [es:di+5], 40h
		jnz	short yesdirty1
		call	INC_DIRTY_COUNT
		or	byte [es:di+5], 40h

yesdirty1:				; ...
		mov	di, bx
		add	di, 11
		mov	si, RENAMEDMA+20h
		mov	cx, 21
		rep movsb
		call	GET_SOURCE
		jb	short RENAME_OVER
		mov	di, bx
		mov	es, word [CURBUF+2]
		mov	al, 0E5h
		stosb
		jmp	short DIRTY_IT
; ---------------------------------------------------------------------------

SIMPLE_RENAME:				; ...
		call	GET_SOURCE
		jb	short RENAME_OVER
		mov	di, bx
		mov	es, word [CURBUF+2]
		mov	si, NAME1
		mov	cx, 11
		rep movsb

DIRTY_IT:				; ...
		mov	di, word [CURBUF]
		test	byte [es:di+5], 40h
		jnz	short yesdirty2
		call	INC_DIRTY_COUNT
		or	byte [es:di+5], 40h

yesdirty2:				; ...
		push	si
		lds	si, [DMAADD]
		add	si, 21
		test	byte [si+11], 10h
		jz	short NOT_DIR2
		call	FastOpen_Rename
		pop	si
		jmp	short NOT_DIRTY1
; ---------------------------------------------------------------------------

NOT_DIR2:				; ...
		pop	si

NOT_DIRTY1:				; ...
		mov	si, RENAMEDMA+1
		call	ECritDisk
		mov	byte [CREATING], 0
		call	RENAME_NEXT
		jb	short RENAME_OVER
		lea	si, [bx+26]
		call	REN_DEL_Check
		jnb	short REN_OK2
		mov	ax, 20h
		jmp	RENAME_CLEAN
; ---------------------------------------------------------------------------

REN_OK2:				; ...
		mov	al, [RENAMEDMA+20h]
		test	al, 10h
		jz	short Ren_Directory
		call	FastOpen_Delete
		jmp	BUILDDEST
; ---------------------------------------------------------------------------

Ren_Directory:				; ...
		call	FastOpen_Rename
		jmp	BUILDDEST
; ---------------------------------------------------------------------------

RENAME_OVER:				; ...
		clc
		jmp	RENAME_CLEAN

; =============== S U B	R O U T	I N E =======================================


GET_SOURCE:
		mov	bx, word [RENAMEDMA+0Fh]
		les	bp, [THISDPB]
		call	SETDIRSRCH
		jb	short gs_ret_label
		call	STARTSRCH
		mov	ax, word [RENAMEDMA+0Dh]
		call	GETENT

gs_ret_label:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================


NEW_RENAME:
		lodsb
		cmp	al, '?'
		jnz	short NOCHG
		mov	al, [bx]

NOCHG:					; ...
		stosb
		inc	bx
		loop	NEW_RENAME
		retn

; =============== S U B	R O U T	I N E =======================================


GET_FILE_INFO:
		call	TestNet
		jnb	short LOCAL_INFO
		mov	ax, 110Fh
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - GET REMOTE FILE'S ATTRIBUTES
					; SS = DOS CS, SDA first filename pointer -> fully-qualified name of file
					; SDA CDS pointer -> current directory
					; Return: CF set on error, AX =	file attributes
		retn
; ---------------------------------------------------------------------------

LOCAL_INFO:				; ...
		call	ECritDisk
		mov	byte [NoSetDir], 1
		call	Get_FAST_PATH
		jnb	short info_check_dev

NO_PATH:				; ...
		jnz	short bad_path1
		or	cl, cl
		jz	short bad_path1

info_no_file:				; ...
		mov	ax, 2

BadRet:					; ...
		stc

JustRet:				; ...
		call	LCritDisk
		retn
; ---------------------------------------------------------------------------

bad_path1:				; ...
		mov	ax, 3
		jmp	short BadRet
; ---------------------------------------------------------------------------

info_check_dev:				; ...
		or	ah, ah
		js	short info_no_file
		cmp	word [CURBUF], 0FFFFh
		jnz	short not_root
		xor	ah, ah
		mov	al, 10h
		clc
		jmp	short JustRet
; ---------------------------------------------------------------------------

not_root:				; ...
		push	ds
		mov	ds, word [CURBUF+2]
		mov	si, bx
		xor	bx, bx
		mov	di, bx
		mov	cx, [si+16h]
		mov	dx, [si+18h]
		xor	ah, ah
		mov	al, [si+0Bh]
		test	al, 10h
		jnz	short NO_SIZE
		mov	di, [si+1Ch]
		mov	bx, [si+1Eh]

NO_SIZE:				; ...
		pop	ds
		clc
		jmp	short JustRet

; =============== S U B	R O U T	I N E =======================================


SET_FILE_ATTRIBUTE:
		test	ax, 0FFD8h
		jz	short set_look

_BAD_ACC:				; ...
		mov	byte [EXTERR_LOCUS], 1
		mov	byte [EXTERR_ACT_CLASS+1], 7
		mov	byte [EXTERR_ACT_CLASS], 4
		mov	ax, 5
		stc
		retn
; ---------------------------------------------------------------------------

set_look:				; ...
		call	TestNet
		jnb	short LOCAL_SET
		push	ax
		mov	ax, 110Eh
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - SET REMOTE FILE'S ATTRIBUTES
					; SS = DOS CS, SDA first filename pointer -> fully-qualified name of file
					; SDA CDS pointer -> current directory
					; STACK: WORD new file attributes
					; Return: CF set on error
		pop	bx
		retn
; ---------------------------------------------------------------------------

LOCAL_SET:				; ...
		call	ECritDisk
		push	ax
		mov	byte [NoSetDir], 1
		call	GETPATH
		jnb	short set_check_device
		pop	bx
		jmp	short NO_PATH
; ---------------------------------------------------------------------------

set_check_device:			; ...
		or	ah, ah
		jns	short set_check_share
		pop	ax
		call	LCritDisk
		jmp	short _BAD_ACC
; ---------------------------------------------------------------------------

set_check_share:			; ...
		pop	ax
		cmp	word [CURBUF], 0FFFFh
		jz	short cannot_set_root
		call	REN_DEL_Check
		jnb	short set_do
		mov	ax, 32
		jmp	short OK_BYE
; ---------------------------------------------------------------------------

cannot_set_root:			; ...
		mov	ax, 5
		stc
		jmp	short OK_BYE
; ---------------------------------------------------------------------------

set_do:					; ...
		les	di, [CURBUF]
		and	byte [es:bx+0Bh], 0D8h
		or	[es:bx+0Bh], al
		test	byte [es:di+5], 40h
		jnz	short yesdirty3
		call	INC_DIRTY_COUNT
		or	byte [es:di+5], 40h

yesdirty3:				; ...
		mov	al, [THISDRV]
		push	dx
		push	di
		mov	ah, 0
		mov	dl, al
		mov	di, bx
		call	FastOpen_Update
		pop	di
		pop	dx
		call	FLUSHBUF
		jnb	short OK_BYE
		mov	ax, 2

OK_BYE:					; ...
		call	LCritDisk
		retn

; =============== S U B	R O U T	I N E =======================================


Get_FAST_PATH:
		or	byte [ss:FastOpenFlg], 1
		call	GETPATH
		pushf
		and	byte [ss:FastOpenFlg], 80h
		popf
		retn

; =============== S U B	R O U T	I N E =======================================


DOS_DUP	:
		mov	es, [cs:DosDSeg]
		les	di, [es:THISSFT]

DOS_Dup_Direct:				; ...
		call	IsSFTNet
		jnz	short DO_INC
		call	DEV_OPEN_SFT

DO_INC:					; ...
		inc	word [es:di]
		retn

; ---------------------------------------------------------------------------

DOS_CREATE:				; ...
		xor	ah, ah

Create_inter:				; ...
		test	al, 80h
		jnz	short AttErr
		test	al, 8
		jz	short NoReset
		or	word [DOS34_FLAG], 80h
		mov	al, 8

NoReset:				; ...
		or	al, 20h
		test	al, 50h
		jz	short ATT_OK

AttErr:					; ...
		mov	ax, 5
		mov	byte [EXTERR_LOCUS], 1
		jmp	short SET_MKND_ERR
; ---------------------------------------------------------------------------

ATT_OK:					; ...
		les	di, [THISSFT]
		push	es
		les	si, [THISCDS]
		cmp	si, 0FFFFh
		jnz	short TEST_RE_NET
		pop	es
		test	byte [EXTOPEN_ON], 1
		jz	short NOEXTOP

IFS_extopen:				; ...
		push	ax
		mov	ax, 112Eh
		int	2Fh		; Multiplex - DOS 4 IFSFUNC.EXE	- ???
					; SS = DS = DOS	CS, STACK: WORD	???   low byte = ???
					; Return: CF set on error
					; CF clear if successful
		pop	bx
		mov	byte [EXTOPEN_ON], 0
		retn
; ---------------------------------------------------------------------------

NOEXTOP:				; ...
		push	ax
		mov	ax, 1118h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - CREATE/TRUNCATE FILE
					; ES:DI	-> uninitialized SFT, SS = DOS CS
					; SDA first filename pointer ->	fully-qualified	name of	file
					; STACK: WORD file creation mode???
		pop	bx
		retn
; ---------------------------------------------------------------------------

TEST_RE_NET:				; ...
		test	word [es:si+43h], 8000h
		pop	es
		jz	short LOCAL_CREATE
		call	Set_EXT_mode
		jb	short dochk
		or	word [es:di+2], 2

dochk:					; ...
		test	byte [EXTOPEN_ON], 1
		jnz	short IFS_extopen
		push	ax
		mov	ax, 1117h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - CREATE/TRUNCATE REMOTE FILE
					; ES:DI	-> uninitialized SFT, SS = DOS CS
					; SDA first filename pointer ->	fully-qualified	name of	file to	open
					; SDA CDS pointer -> current directory
					; Return: CF set on error
		pop	bx
		retn
; ---------------------------------------------------------------------------

LOCAL_CREATE:				; ...
		call	Set_EXT_mode
		jb	short setdone
		or	word [es:di+2], 2

setdone:				; ...
		call	ECritDisk
		call	MakeNode
		jnb	short Create_ok
		mov	byte [VOLCHNG_FLAG], 0FFh
		call	LCritDisk

SET_MKND_ERR:				; ...
		mov	bx, CRTERRTAB
		;xlat	byte [cs:bx]
		cs	xlat
		stc
		retn
; ---------------------------------------------------------------------------
CRTERRTAB	db 0, 5, 52h, 50h, 3, 5, 20h, 2	; ...
; ---------------------------------------------------------------------------

Create_ok:				; ...
		call	FastOpen_Delete
		mov	al, [SATTRIB]
		test	al, 8
		jz	short NoVolLabel
		les	di, [THISCDS]
		mov	ah, [es:di]
		sub	ah, 'A'
		mov	byte [VOLCHNG_FLAG], ah
		mov	bh, 1
		call	Set_Media_ID
		call	ECritDisk
		call	FATREAD_CDS
		call	LCritDisk

NoVolLabel:				; ...
		mov	ax, 2
		les	di, [THISSFT]
		call	far [ShSU]
		call	LCritDisk
		jmp	SET_SFT_MODE
; ---------------------------------------------------------------------------

DOS_Create_New:				; ...
		mov	ah, 1
		jmp	Create_inter

; =============== S U B	R O U T	I N E =======================================


Set_Media_ID:
		push	ax
		push	es
		push	di
		inc	ah
		mov	bl, ah
		mov	al, 0Dh
		mov	cx, 866h
		mov	dx, FAKE_STACK_2F
		push	bx
		push	dx
		xor	bh, bh
		call	$IOCTL
		pop	dx
		pop	bx
		jb	short geterr
		or	bh, bh
		jz	short NoName
		mov	si, NAME1
		jmp	short doset
; ---------------------------------------------------------------------------

NoName:					; ...
		mov	si, NO_NAME_ID ;	"NO NAME    "

doset:					; ...
		mov	di, dx
		add	di, 6
		push	ss
		pop	ds
		push	ss
		pop	es
		mov	cx, 11
		rep movsb
		mov	cx, 846h
		mov	al, 0Dh
		xor	bh, bh
		call	$IOCTL

geterr:					; ...
		push	ss
		pop	ds
		pop	di
		pop	es
		pop	ax
		retn

; =============== S U B	R O U T	I N E =======================================


Set_EXT_mode:
		test	byte [ss:EXTOPEN_ON], 1
		jz	short NOTEX
		push	ax
		mov	ax, [ss:SAVE_BX]
		or	[es:di+2], ax
		pop	ax
		stc

NOTEX:					; ...
		retn

; =============== S U B	R O U T	I N E =======================================


DOS_OPEN:
		mov	byte [NoSetDir], 0
		call	Check_Access_AX
		jb	short do_ret_label
		les	di, [THISSFT]
		xor	ah, ah
		mov	[es:di+2], al
		push	es
		les	si, [THISCDS]
		cmp	si, 0FFFFh
		jnz	short TEST_RE_NET1
		pop	es
		test	byte [EXTOPEN_ON], 1
		jz	short _NOEXTOP

_IFS_extopen:				; ...
		mov	al, byte [SAVE_BX]
		push	ax
		mov	ax, 112Eh
		int	2Fh		; Multiplex - DOS 4 IFSFUNC.EXE	- ???
					; SS = DS = DOS	CS, STACK: WORD	???   low byte = ???
					; Return: CF set on error
					; CF clear if successful
		pop	bx
		mov	byte [EXTOPEN_ON], 0

do_ret_label:				; ...
		retn
; ---------------------------------------------------------------------------

_NOEXTOP:				; ...
		test	byte [DOS_FLAG], 1
		jz	short not_exec_open
		test	byte [DOS34_FLAG+1], 8
		jz	short not_exec_open
		mov	al, 23h

not_exec_open:				; ...
		push	ax
		mov	ax, 1116h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - OPEN	EXISTING REMOTE	FILE
					; ES:DI	-> uninitialized SFT, SS = DOS CS
					; SDA first filename pointer ->	fully-qualified	name of	file to	open
					; STACK: WORD file open	mode
					; Return: CF set on error
		pop	bx
		retn
; ---------------------------------------------------------------------------

TEST_RE_NET1:				; ...
		test	word [es:si+43h], 8000h
		pop	es
		jz	short LOCAL_OPEN
		test	byte [EXTOPEN_ON], 1
		jnz	short _IFS_extopen
		jmp	short _NOEXTOP
; ---------------------------------------------------------------------------

LOCAL_OPEN:				; ...
		call	ECritDisk
		or	byte [FastOpenFlg],	5
		call	GETPATH
		jnb	short Open_found
		jnz	short bad_path2
		or	cl, cl
		jz	short bad_path2

OpenFNF:
		mov	ax, 2

OpenBadRet:				; ...
		and	byte [ss:FastOpenFlg],	80h
		stc
		call	LCritDisk
		jmp	Clear_FastOpen
; ---------------------------------------------------------------------------

bad_path2:				; ...
		mov	ax, 3
		jmp	short OpenBadRet
; ---------------------------------------------------------------------------

Open_Bad_Access:			; ...
		mov	ax, 5
		jmp	short OpenBadRet
; ---------------------------------------------------------------------------

Open_found:				; ...
		jz	short Open_Bad_Access
		or	ah, ah
		js	short open_ok
		mov	es, word [CURBUF+2]
		mov	al, [es:bx+0Bh]
		test	al, 8
		jnz	short Open_Bad_Access
		test	al, 1
		jz	short open_ok
		push	ds
		push	si
		lds	si, [THISSFT]
		mov	cx, [si+2]
		test	cx, 8000h
		jnz	short ResetAccess
		mov	dl, cl
		and	dl, 0F0h
		cmp	dl, 70h	; 'p'
		jnz	short NormalOpen

ResetAccess:				; ...
		and	cx, 0FFF0h
		mov	[si+2],	cx
		jmp	short FillSFT
; ---------------------------------------------------------------------------

NormalOpen:				; ...
		and	cl, 0Fh
		cmp	cl, 0
		jz	short FillSFT
		pop	si
		pop	ds
		jmp	short Open_Bad_Access
; ---------------------------------------------------------------------------

FillSFT:				; ...
		pop	si
		pop	ds

open_ok:				; ...
		call	DOOPEN
		and	byte [ss:FastOpenFlg], 80h
		call	DO_SHARE_CHECK
		jnb	short SHARE_OK
		call	LCritDisk
		jmp	short Clear_FastOpen
; ---------------------------------------------------------------------------

SHARE_OK:				; ...
		mov	ax, 3
		les	di, [THISSFT]
		call	far [ShSU]
		call	LCritDisk

SET_SFT_MODE:				; ...
		les	di, [THISSFT]
		call	DEV_OPEN_SFT
		test	word [es:di+2], 8000h
		jz	short Clear_FastOpen
		mov	ax, [CurrentPDB]
		mov	[es:di+31h], ax

Clear_FastOpen:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================


SHARE_ERROR:
		test	word [es:di+2], 8000h
		jnz	short _HARD_ERR
		mov	cl, [es:di+2]
		and	cl, 0F0h
		cmp	cl, 0
		jnz	short _NO_HARD_ERR

_HARD_ERR:				; ...
		call	SHARE_VIOLATION
		jnb	short Clear_FastOpen

_NO_HARD_ERR:				; ...
		mov	ax, 20h	; ' '
		stc
		retn

; =============== S U B	R O U T	I N E =======================================


DO_SHARE_CHECK:
		call	ECritDisk

OPN_RETRY:				; ...
		mov	cx, [RetryCount]

OpenShareRetry:				; ...
		push	cx
		call	SHARE_CHECK
		pop	cx
		jnb	short Share_Ok2
		call	Idle
		loop	OpenShareRetry
		les	di, [THISSFT]
		call	SHARE_ERROR
		jnb	short OPN_RETRY

Share_Ok2:				; ...
		call	LCritDisk
		retn

; =============== S U B	R O U T	I N E =======================================


Check_Access_AX:
		mov	[OPEN_ACCESS],	al
		push	bx
		mov	bl, al
		and	bl, 0F0h
		cmp	byte [FSHARING], 0FFh
		jnz	short CheckShareMode
		cmp	bl, 70h
		jz	short CheckAccessMode

CheckShareMode:				; ...
		cmp	bl, 40h
		ja	short Make_Bad_Access

CheckAccessMode:			; ...
		mov	bl, al
		and	bl, 0Fh
		cmp	bl, 2
		ja	short Make_Bad_Access
		pop	bx
		clc
		retn
; ---------------------------------------------------------------------------

Make_Bad_Access:			; ...
		mov	ax, 0Ch
		pop	bx
		stc
		retn

; =============== S U B	R O U T	I N E =======================================


DISK_INFO:
		call	TestNet
		jnb	short LOCAL_DSK_INFO
		mov	ax, 110Ch
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - GET DISK SPACE
					; ES:DI	-> current directory
					; Return: AL = sectors per cluster, BX = total clusters
					; CX = bytes per sector, DX = number of	available clusters
		retn
; ---------------------------------------------------------------------------

LOCAL_DSK_INFO:				; ...
		mov	byte [EXTERR_LOCUS], 2
		call	ECritDisk
		call	FATREAD_CDS
		jb	short CRIT_LEAVE
		mov	bx, 2
		call	UNPACK
		jb	short CRIT_LEAVE
		lds	si, [CURBUF]
		mov	ah, [si+20]
		push	ss
		pop	ds
		mov	cx, [es:bp+0Dh]
		mov	dx, [es:bp+1Fh]
		cmp	dx, 0FFFFh
		jz	short DoScan
		cmp	dx, cx
		jb	short GotVal

DoScan:					; ...
		xor	dx, dx
		dec	cx

SCANFREE:				; ...
		call	UNPACK
		jb	short CRIT_LEAVE
		jnz	short NOTFREECLUS
		inc	dx

NOTFREECLUS:				; ...
		inc	bx
		loop	SCANFREE
		dec	bx

ReturnVals:				; ...
		dec	bx
		mov	al, [es:bp+4]
		inc	al
		mov	cx, [es:bp+2]
		mov	[es:bp+1Fh], dx
		clc

CRIT_LEAVE:				; ...
		call	LCritDisk
		retn
; ---------------------------------------------------------------------------

GotVal:					; ...
		mov	bx, cx
		jmp	short ReturnVals

; =============== S U B	R O U T	I N E =======================================


DOS_SEARCH_FIRST:

; FUNCTION CHUNK AT 6C8B SIZE 0000009C BYTES

		les	di, [THISCDS]
		cmp	di, 0FFFFh
		jnz	short TEST_RE_NET2
		mov	ax, 1119h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - ???
		retn
; ---------------------------------------------------------------------------

TEST_RE_NET2:				; ...
		test	word [es:di+43h], 8000h
		jz	short LOCAL_SEARCH_FIRST
		mov	ax, 111Bh
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - FINDFIRST
					; SS = DS = DOS	CS, [DTA] = uninitialized 21-byte findfirst search data
					; SDA first filename pointer ->	fully-qualified	search template
					; SDA CDS pointer -> current directory
					; Return: CF set on error
		retn
; ---------------------------------------------------------------------------

LOCAL_SEARCH_FIRST:			; ...
		call	ECritDisk
		test	word [DOS34_FLAG], 400h
		jz	short NOFN
		or	byte [FastOpenFlg],	1

NOFN:					; ...
		mov	byte [NoSetDir], 1
		call	CHECK_QUESTION
		jnb	short norm_GETPATH
		and	byte [FastOpenFlg],	80h

norm_GETPATH:				; ...
		call	GETPATH
		jnb	short find_check_dev
		jnz	short bad_path3
		or	cl, cl
		jz	short bad_path3

; START	OF FUNCTION CHUNK FOR DOS_SEARCH_NEXT

find_no_more:				; ...
		mov	ax, 12h

BadBye:					; ...
		and	byte [ss:FastOpenFlg],	80h
		stc
		call	LCritDisk
		retn
; END OF FUNCTION CHUNK	FOR DOS_SEARCH_NEXT
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR DOS_SEARCH_FIRST

bad_path3:				; ...
		mov	ax, 3
		jmp	short BadBye
; ---------------------------------------------------------------------------

find_check_dev:				; ...
		or	ah, ah
		jns	short found_entry
		mov	word [LASTENT], 0FFFFh
		inc	byte [FOUND_DEV]

found_entry:				; ...
		les	di, [DMAADD]
		mov	si, [WFP_START]
		lodsb
		sub	al, 40h	; '@'
		stosb

found_it:				; ...
		les	di, [DMAADD]
		inc	di
		push	ds
		test	byte [FastOpenFlg],	10h
		jz	short notfast
		mov	si, bx
		mov	ds, word [CURBUF+2]
		jmp	short movmov
; ---------------------------------------------------------------------------

notfast:				; ...
		mov	si, NAME1

movmov:					; ...
		movsb
		cmp	byte [es:di-1], 5
		jnz	short NOTKANJB
		mov	byte [es:di-1], 0E5h ; 'å'

NOTKANJB:				; ...
		mov	cx, 10
		rep movsb
		pop	ds
		mov	al, [ATTRIB]
		stosb
		push	ax
		mov	ax, [LASTENT]
		stosw
		mov	ax, [DIRSTART]
		stosw
		add	di, 4
		pop	ax
		or	ah, ah
		js	short DOSREL
		cmp	word [CURBUF], 0FFFFh
		jnz	short OKSTORE
		test	byte [FastOpenFlg], 10h
		jnz	short OKSTORE
		mov	word [es:di-8], 0FFFFh
		jmp	find_no_more
; ---------------------------------------------------------------------------

OKSTORE:				; ...
		mov	ds, word [CURBUF+2]

DOSREL:					; ...
		mov	si, bx
		mov	cx, 32
		mov	ax, di
		rep movsb
		mov	di, ax
		cmp	byte [es:di], 5
		jnz	short NO05
		mov	byte [es:di], 0E5h

NO05:					; ...
		and	byte [ss:FastOpenFlg], 80h
		push	ss
		pop	ds
		clc
		call	LCritDisk
		retn
; END OF FUNCTION CHUNK	FOR DOS_SEARCH_FIRST

; =============== S U B	R O U T	I N E =======================================


DOS_SEARCH_NEXT:

; FUNCTION CHUNK AT 6C7D SIZE 0000000E BYTES

		les	di, [DMAADD]
		mov	al, [es:di]
		test	al, 80h
		jz	short LOCAL_SEARCH_NEXT
		mov	ax, 111Ch
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - FINDNEXT
					; SS = DS = DOS	CS, [DTA] = 21-byte findfirst search data
					; Return: CF set on error, AX =	DOS error code
					; CF clear if successful
		retn
; ---------------------------------------------------------------------------

LOCAL_SEARCH_NEXT:			; ...
		mov	byte [EXTERR_LOCUS], 2
		call	ECritDisk
		mov	word [THISCDS], DUMMYCDS
		mov	word [THISCDS+2], ds
		add	al, 40h	; '@'
		call	InitCDS
		jb	short No_files
		les	di, [THISCDS]
		les	bp, [es:di+45h]
		call	GOTDPB
		mov	al, [es:bp+0]
		mov	[THISDRV], al
		mov	word [CREATING], 0E500h
		mov	byte [NoSetDir], 1
		lds	si, [DMAADD]
		lodsb

RENAME_NEXT:				; ...
		push	ss
		pop	es
		mov	di, NAME1
		mov	cx, 11
		rep movsb
		lodsb
		mov	byte [ss:ATTRIB], al
		lodsw
		or	ax, ax
		jns	short cont_load

No_files:				; ...
		jmp	find_no_more
; ---------------------------------------------------------------------------

cont_load:				; ...
		push	ax
		lodsw
		mov	bx, ax
		push	ss
		pop	ds
		les	bp, [THISDPB]
		call	SETDIRSRCH
		jnb	short SEARCH_GOON
		pop	ax
		jmp	short No_files
; ---------------------------------------------------------------------------

SEARCH_GOON:				; ...
		call	STARTSRCH
		pop	ax
		call	GETENT
		jb	short No_files
		call	NEXTENT
		jb	short No_files
		xor	ah, ah
		jmp	found_it

; =============== S U B	R O U T	I N E =======================================


CHECK_QUESTION:
		push	ss
		pop	ds
		mov	si, [ss:WFP_START]

getnext:				; ...
		lodsb
		or	al, al
		jz	short NO_Question
		cmp	al, '?'
		jnz	short getnext
		stc

NO_Question:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================


DOS_ABORT:
		mov	es, [ss:CurrentPDB]
		mov	cx, [es:32h]	; [ES:PDB.JFN_Length]

reset_free_jfn:				; ...
		mov	bx, cx
		push	cx
		dec	bx
		call	$CLOSE
		pop	cx
		loop	reset_free_jfn
		push	ss
		pop	ds
		mov	ax, 111Dh
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - CLOSE ALL REMOTE FILES FOR PROCESS
					; DS???, SS = DOS CS
		call	far [MFTCloseP]
		les	di, [ss:SFTFCB]
		mov	cx, [es:di+4]
		jcxz	FCBScanDone
		lea	di, [di+6]
		mov	ax, [ss:PROC_ID]

FCBTest:				; ...
		cmp	[es:di+31h], ax
		jnz	short FCBNext
		mov	word [es:di], 0

FCBNext:				; ...
		add	di, 59
		loop	FCBTest

FCBScanDone:				; ...
		xor	bx, bx

Scan:					; ...
		push	bx
		call	SFFromSFN
		pop	bx
		jnb	short Scan1
		retn
; ---------------------------------------------------------------------------

Scan1:					; ...
		cmp	word [es:di], 0FFFFh
		jnz	short scan_next
		mov	ax, [ss:PROC_ID]
		cmp	[es:di+31h], ax
		jnz	short scan_next
		mov	ax, [ss:USER_ID]
		cmp	[es:di+2Fh], ax
		jnz	short scan_next
		mov	word [es:di], 0

scan_next:				; ...
		inc	bx
		jmp	short Scan

; =============== S U B	R O U T	I N E =======================================


DOS_CLOSE:
		les	di, [THISSFT]
		mov	bx, [es:di+5]
		test	bx, 8000h
		jz	short LocalClose
		mov	ax, 1106h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - CLOSE REMOTE	FILE
					; ES:DI	-> SFT
					; SFT DPB field	-> DPB of drive	containing file
					; Return: CF set on error, AX =	DOS error code
					; CF clear if successful
		retn
; ---------------------------------------------------------------------------

LocalClose:				; ...
		call	ECritDisk
		call	SetSFTTimes
		call	FREE_SFT
		push	ss
		pop	ds
		push	ax
		push	bx
		call	ShareEnd
		pop	bx
		pop	ax

CloseEntry:				; ...
		push	ax
		test	bx, 0C0h
		jz	short rdir
		jmp	FREE_SFT_OK
; ---------------------------------------------------------------------------

rdir:					; ...
		call	DirFromSFT
		mov	al, 5
		jnb	short clook
		jmp	CloseFinish
; ---------------------------------------------------------------------------

clook:					; ...
		push	di
		push	si
		lea	si, [si+20h]
		call	XCHGP
		call	MetaCompare
		call	XCHGP
		pop	si
		pop	di
		jz	short CLOSE_GO
		mov	di, si
		push	ds
		pop	es
		push	ss
		pop	ds
		stc
		mov	al, 2
		jmp	CloseFinish
; ---------------------------------------------------------------------------

CLOSE_GO:				; ...
		test	word [si+2], 8000h
		jz	short nofcb
		mov	ch, [es:di+0Bh]
		mov	al, [si+4]
		mov	byte [ss:ATTRIB], al
		jmp	short setattr
; ---------------------------------------------------------------------------

nofcb:					; ...
		mov	al, [si+4]
		mov	[es:di+0Bh], al

setattr:				; ...
		or	byte [es:di+0Bh], 20h
		mov	ax, [es:di+1Ah]
		mov	[ss:OLD_FIRSTCLUS], ax
		mov	ax, [si+0Bh]
		mov	[es:di+1Ah], ax
		mov	ax, [si+11h]
		mov	[es:di+1Ch], ax
		mov	ax, [si+13h]
		mov	[es:di+1Eh], ax
		mov	ax, [si+0Fh]
		mov	[es:di+18h], ax
		mov	ax, [si+0Dh]
		mov	[es:di+16h], ax
		test	byte [es:bx+5], 40h
		jnz	short yesdirty4
		call	INC_DIRTY_COUNT
		or	byte [es:bx+5], 40h

yesdirty4:				; ...
		push	ds
		push	si
		mov	cx, [si+0Bh]
		mov	al, [ss:THISDRV]
		push	dx
		mov	ah, 0
		mov	dl, al
		or	cx, cx
		jnz	short do_update2
		mov	ah, 3
		mov	di, [si+1Bh]
		mov	cx, [si+1Dh]
		mov	dh, [si+1Fh]
		jmp	short do_update
; ---------------------------------------------------------------------------

do_update2:				; ...
		cmp	cx, [ss:OLD_FIRSTCLUS]
		jz	short do_update
		mov	ah, 2
		mov	cx, [ss:OLD_FIRSTCLUS]

do_update:				; ...
		push	ss
		pop	ds
		call	FastOpen_Update
		pop	dx
		call	FLUSHBUF
		pop	di
		pop	es
		mov	al, 5
		jb	short CloseFinish

FREE_SFT_OK:				; ...
		clc

CloseFinish:				; ...
		pushf
		call	DEV_CLOSE_SFT
		popf
		pop	cx
		pushf
		dec	cx
		jnz	short NoFree
		mov	[es:di], cx

NoFree:					; ...
		call	LCritDisk
		popf
		retn

; =============== S U B	R O U T	I N E =======================================


FREE_SFT:
		pushf
		mov	ax, [es:di]
		dec	ax
		jnz	short SetCount
		dec	ax

SetCount:				; ...
		xchg	ax, [es:di]
		popf
		retn

; =============== S U B	R O U T	I N E =======================================


DirFromSFT:
		mov	byte [EXTERR_LOCUS], 2
		push	es
		push	di
		mov	dx, [es:di+1Dh]
		mov	word [HIGH_SECTOR], dx
		mov	dx, [es:di+1Bh]
		push	word [HIGH_SECTOR]
		push	dx
		call	FATREAD_SFT
		pop	dx
		pop	word [HIGH_SECTOR]
		jb	short PopDone
		xor	al, al
		mov	byte [ALLOWED], 18h
		call	GETBUFFR
		jb	short PopDone
		pop	si
		pop	ds
		les	di, [ss:CURBUF]
		or	byte [es:di+5], 4
		mov	bx, di
		lea	di, [di+14h]
		mov	al, 20h	; ' '
		mul	byte [si+1Fh]
		add	di, ax
		retn
; ---------------------------------------------------------------------------

PopDone:				; ...
		pop	di
		pop	es

PopDone_retn:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================


DOS_COMMIT:
		les	di, [THISSFT]
		mov	bx, [es:di+5]
		test	bx, 0C0h
		jnz	short PopDone_retn
		test	bx, 8000h
		jz	short LOCAL_COMMIT
		mov	ax, 1107h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - COMMIT REMOTE FILE
					; ES:DI	-> SFT
					; SFT DPB field	-> DPB of drive	containing file
					; Return: CF set on error, AX =	DOS error code
					; CF clear if successful
		retn
; ---------------------------------------------------------------------------

LOCAL_COMMIT:				; ...
		call	ECritDisk
		call	ECritDisk
		call	SetSFTTimes
		mov	ax, 0FFFFh
		call	CloseEntry
		pushf
		call	DEV_OPEN_SFT
		popf
		call	LCritDisk

localcommit_retn:			; ...
		retn

; =============== S U B	R O U T	I N E =======================================


SetSFTTimes:
		test	bx, 0C0h
		jnz	short localcommit_retn
		test	bx, 4000h
		jnz	short localcommit_retn
		push	ax
		push	bx
		call	DATE16
		mov	[es:di+0Fh], ax
		mov	[es:di+0Dh], dx
		xor	ax, ax
		call	far [ShSU]
		pop	bx
		pop	ax
		retn

; ---------------------------------------------------------------------------

DOS_MKDIR:				; ...
		call	TestNet
		jnb	short LOCAL_MKDIR
		mov	ax, 1103h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - MAKE	REMOTE DIRECTORY
					; SS = DOS CS
					; SDA first filename pointer ->	fully-qualified	directory name
					; SDA CDS pointer -> current directory
					; Return: CF set on error, AX =	DOS error code
					; CF clear if successful
		retn
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR DOS_RMDIR

NODEACCERRJ:				; ...
		mov	ax, 5

_BadRet:				; ...
		stc
		call	LCritDisk
		retn
; END OF FUNCTION CHUNK	FOR DOS_RMDIR
; ---------------------------------------------------------------------------

PATHNFJ:				; ...
		call	LCritDisk
		jmp	SET_MKND_ERR
; ---------------------------------------------------------------------------

LOCAL_MKDIR:				; ...
		call	ECritDisk
		mov	word [THISSFT+2], ss
		mov	word [THISSFT], RENBUF
		mov	word [RENBUF+33h], 0 ; [RENBUF+SF_ENTRY.sf_MFT]
		mov	al, 10h
		call	MakeNode
		jb	short PATHNFJ
		cmp	ax, 3
		jz	short NODEACCERRJ
		les	bp, [THISDPB]
		lds	di, [CURBUF]
		sub	si, di
		push	si
		push	word [di+8]
		push	word [di+6]
		push	ss
		pop	ds
		push	word [DIRSTART]
		xor	ax, ax
		mov	word [DIRSTART], ax
		call	NEWDIR
		jb	short NODEEXISTSPOPDEL
		call	GETENT
		jb	short NODEEXISTSPOPDEL
		les	di, [CURBUF]
		test	byte [es:di+5], 40h
		jnz	short yesdirty5
		call	INC_DIRTY_COUNT
		or	byte [es:di+5], 40h

yesdirty5:				; ...
		add	di, 20
		mov	ax, 202Eh
		mov	dx, [DIRSTART]
		call	SETDOTENT
		mov	ax, 2E2Eh
		pop	dx
		call	SETDOTENT
		les	bp, [THISDPB]
		mov	byte [ALLOWED], 18h
		pop	dx
		pop	word [HIGH_SECTOR]
		xor	al, al
		call	GETBUFFR
		jb	short NODEEXISTSP
		mov	dx, [DIRSTART]
		lds	di, [CURBUF]
		or	byte [di+5], 4
		pop	si
		add	si, di
		mov	[si], dx
		xor	dx, dx
		mov	[si+2],	dx
		mov	[si+4],	dx

; =============== S U B	R O U T	I N E =======================================


DIRUP	:
		test	byte [di+5], 40h
		jnz	short yesdirty6
		call	INC_DIRTY_COUNT
		or	byte [di+5], 40h

yesdirty6:				; ...
		push	ss
		pop	ds
		mov	al, [es:bp+0]
		call	FLUSHBUF
		mov	ax, 5
		call	LCritDisk
		retn

; ---------------------------------------------------------------------------

NODEEXISTSPOPDEL:			; ...
		pop	dx
		pop	dx
		pop	word [HIGH_SECTOR]
		les	bp, [THISDPB]
		mov	byte [ALLOWED], 18h
		xor	al, al
		call	GETBUFFR
		jb	short NODEEXISTSP
		lds	di, [CURBUF]
		or	byte [di+5], 4
		pop	si
		add	si, di
		sub	si, 1Ah
		mov	byte [si], 0E5h
		call	DIRUP

NODEEXISTS:				; ...
		jmp	NODEACCERRJ
; ---------------------------------------------------------------------------

NODEEXISTSP:				; ...
		pop	si
		jmp	short NODEEXISTS

; =============== S U B	R O U T	I N E =======================================


DOS_CHDIR:
		call	TestNet
		jnb	short LOCAL_CHDIR
		mov	ax, 1105h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - CHDIR
					; SS = DOS CS
					; SDA first filename pointer ->	fully-qualified	directory name
					; SDA CDS pointer -> current directory
					; Return: CF set on error, AX =	DOS error code
					; CF clear if successful
		retn
; ---------------------------------------------------------------------------

LOCAL_CHDIR:				; ...
		call	ECritDisk
		test	word [es:di+43h], 2000h
		jz	short nojoin
		mov	word [es:di+49h], 0FFFFh

nojoin:					; ...
		mov	byte [NoSetDir], 0
		mov	byte [SATTRIB], 16h
		or	byte [FastOpenFlg],	1
		call	GETPATH
		pushf
		and	byte [FastOpenFlg],	80h
		popf
		mov	ax, 3
		jb	short ChDirDone
		jnz	short NOTDIRPATH
		mov	cx, [DIRSTART]
		clc

ChDirDone:				; ...
		call	LCritDisk
		retn

; =============== S U B	R O U T	I N E =======================================


DOS_RMDIR:

; FUNCTION CHUNK AT 6FE5 SIZE 00000008 BYTES

		call	TestNet
		jnb	short LOCAL_RMDIR
		mov	ax, 1101h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - REMOVE REMOTE DIRECTORY
					; SS = DOS CS
					; SDA first filename pointer ->	fully-qualified	directory name
					; SDA CDS pointer -> current directory
					; Return: CF set on error, AX =	DOS error code
					; CF clear if successful
		retn
; ---------------------------------------------------------------------------

LOCAL_RMDIR:				; ...
		call	ECritDisk
		mov	byte [NoSetDir], 0
		mov	byte [SATTRIB], 16h
		call	GETPATH
		jb	short NOPATH
		jnz	short NOTDIRPATH
		mov	di, [DIRSTART]
		or	di, di
		jnz	short rmdir_get_buf
		jmp	short NOTDIRPATH
; ---------------------------------------------------------------------------

NOPATH:					; ...
		mov	ax, 3
		jmp	_BadRet
; ---------------------------------------------------------------------------

NOTDIRPATHPOP:				; ...
		pop	ax
		pop	ax

NOTDIRPATHPOP2:				; ...
		pop	ax

NOTDIRPATH:				; ...
		jmp	NODEACCERRJ
; ---------------------------------------------------------------------------

rmdir_get_buf:				; ...
		lds	di, [CURBUF]
		sub	bx, di
		push	bx
		push	word [di+8]
		push	word [di+6]
		push	ss
		pop	ds
		push	ss
		pop	es
		mov	di, NAME1
		mov	al, '?'
		mov	cx, 11
		rep stosb
		xor	al, al
		stosb
		call	STARTSRCH
		call	GETENTRY
		jb	short NOTDIRPATHPOP
		mov	ds, word [CURBUF+2]
		mov	si, bx
		lodsw
		cmp	ax, 202Eh
		jnz	short NOTDIRPATHPOP
		add	si, 30
		lodsw
		cmp	ax, 2E2Eh
		jnz	short NOTDIRPATHPOP
		push	ss
		pop	ds
		mov	word [LASTENT], 2
		call	GETENTRY
		jb	short NOTDIRPATHPOP
		mov	byte [ATTRIB], 16h
		call	SRCH
		jnb	short NOTDIRPATHPOP
		cmp	byte [FAILERR], 0
		jnz	short NOTDIRPATHPOP
		les	bp, [THISDPB]
		mov	bx, [DIRSTART]
		call	RELEASE
		jb	short NOTDIRPATHPOP
		pop	dx
		pop	word [HIGH_SECTOR]
		mov	byte [ALLOWED], 18h
		xor	al, al
		call	GETBUFFR
		jb	short NOTDIRPATHPOP2
		lds	di, [CURBUF]
		or	byte [di+5], 4
		pop	bx
		add	bx, di
		mov	byte [bx], 0E5h
		push	ds
		push	ss
		pop	ds
		call	FastOpen_Delete
		pop	ds
		jmp	DIRUP

; =============== S U B	R O U T	I N E =======================================


SWAPBACK:
		mov	byte [CONSWAP], 0
		retn

; =============== S U B	R O U T	I N E =======================================


SWAPCON	:
		mov	byte [CONSWAP], 1
		push	ax
		mov	ax, word [THISSFT]
		mov	word [CONSFT], ax
		mov	ax, word [THISSFT+2]
		mov	word [CONSFT+2], ax
		pop	ax
		retn

; =============== S U B	R O U T	I N E =======================================


DOS_READ:
		les	di, [THISSFT]
		mov	al, [es:di+2]
		and	al, 0Fh
		cmp	al, 1
		jnz	short READ_NO_MODE
		jmp	SET_ACC_ERR
; ---------------------------------------------------------------------------

READ_NO_MODE:				; ...
		call	SETUP
		jcxz	NoIORet
		call	IsSFTNet
		jz	short LOCAL_READ
		mov	ax, 1108h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - READ	FROM REMOTE FILE
					; ES:DI	-> SFT
					; SFT DPB field	-> DPB of drive	containing file
					; CX = number of bytes,	SS = DOS CS, SDA DTA field -> user buffer
					; Return: CF set on error, CX =	bytes read
		retn
; ---------------------------------------------------------------------------

NoIORet:				; ...
		clc
		retn
; ---------------------------------------------------------------------------

LOCAL_READ:				; ...
		test	byte [es:di+5], 80h
		jnz	short READDEV
		mov	byte [EXTERR_LOCUS], 2
		call	ECritDisk
		call	DISKREAD

critexit:
		call	LCritDisk
		retn
; ---------------------------------------------------------------------------

READDEV:				; ...
		mov	byte [EXTERR_LOCUS], 4
		mov	bl, [es:di+5]
		les	di, [DMAADD]
		test	bl, 40h
		jz	short ENDRDDEVJ3
		test	bl, 4
		jz	short TESTRAW
		xor	al, al

ENDRDDEVJ3:				; ...
		jmp	ENDRDDEVJ2
; ---------------------------------------------------------------------------

TESTRAW:				; ...
		test	bl, 20h
		jnz	short DVRDRAW
		test	bl, 1
		jz	short NOTRDCON
		jmp	READCON
; ---------------------------------------------------------------------------

DVRDRAW:				; ...
		push	es
		pop	ds
		test	byte [ss:IsWin386], 1
		jz	short ReadRawRetry
		test	bl, 1
		jz	short ReadRawRetry
		jmp	do_polling
; ---------------------------------------------------------------------------

ReadRawRetry:				; ...
		mov	bx, di
		xor	ax, ax
		mov	dx, ax
		call	SETREAD
		push	ds
		lds	si, [ss:THISSFT]
		call	DEVIOCALL
		mov	dx, di
		mov	ah, 86h
		mov	di, [ss:DEVCALL_REQSTAT]
		or	di, di
		jns	short CRDROK
		call	CHARHARD
		mov	di, dx
		add	di, word [ss:CALLBPB]
		sub	cx, word [ss:CALLBPB]
		or	al, al
		jz	short CRDROK
		cmp	al, 3
		jz	short CRDFERR
		pop	ds
		jmp	short ReadRawRetry
; ---------------------------------------------------------------------------

CRDFERR:				; ...
		pop	di

DEVIOFERR:				; ...
		les	di, [ss:THISSFT]
		jmp	SET_ACC_ERR_DS
; ---------------------------------------------------------------------------

CRDROK:					; ...
		pop	di
		mov	di, dx
		add	di, word [ss:CALLBPB]
		jmp	short ENDRDDEVJ3
; ---------------------------------------------------------------------------

NOTRDCON:				; ...
		mov	ax, es
		mov	ds, ax
		mov	bx, di
		xor	dx, dx
		mov	ax, dx
		push	cx
		mov	cx, 1
		call	SETREAD
		pop	cx
		lds	si, [ss:THISSFT]
		lds	si, [si+7]

DVRDLP:					; ...
		call	DSKSTATCHK
		call	DEVIOCALL2
		push	di
		mov	ah, 86h
		mov	di, [ss:DEVCALL_REQSTAT]
		or	di, di
		jns	short CRDOK
		call	CHARHARD
		pop	di
		mov	word [ss:CALLBPB], 1
		cmp	al, 1
		jz	short DVRDLP
		cmp	al, 3
		jz	short DEVIOFERR
		xor	al, al
		jmp	short DVRDIGN
; ---------------------------------------------------------------------------

CRDOK:					; ...
		pop	di
		cmp	word [ss:CALLBPB], 1 ; [SS:CALLSCNT]
		jnz	short ENDRDDEVJ2
		push	ds
		mov	ds, word [ss:CALLBR+2] ; [SS:CALLXAD+2]
		mov	al, [di]
		pop	ds

DVRDIGN:				; ...
		inc	word [ss:CALLBR] ; [SS:CALLXAD]
		mov	word [ss:DEVCALL_REQSTAT], 0
		inc	di
		cmp	al, 1Ah
		jz	short ENDRDDEVJ2
		cmp	al, 0Dh
		loopne	DVRDLP
		inc	ax

ENDRDDEVJ2:				; ...
		jmp	ENDRDDEV
; ---------------------------------------------------------------------------

do_polling:				; ...
		mov	bx, di
		xor	ax, ax
		mov	dx, ax
		call	SETREAD

do_io:					; ...
		mov	byte [es:bx+2], 5
		push	ds
		lds	si, [ss:THISSFT]
		call	DEVIOCALL
		pop	ds
		test	word [es:bx+3], 8000h
		jz	short check_busy
		push	ds
		mov	dx, di
		call	CHARHARD
		mov	di, dx
		or	al, al
		jz	short pop_done_read
		cmp	al, 3
		jz	short devrderr
		pop	ds
		jmp	short do_io
; ---------------------------------------------------------------------------

check_busy:				; ...
		test	word [es:bx+3], 200h
		jnz	short no_char
		mov	byte [es:bx+2], 4
		mov	word [es:bx+12h], 1
		push	ds
		lds	si, [ss:THISSFT]
		call	DEVIOCALL
		mov	dx, di
		mov	ah, 86h
		mov	di, [es:bx+3]
		test	di, 8000h
		jz	short next_char
		call	CHARHARD
		mov	di, dx
		or	al, al
		jz	short pop_done_read
		cmp	al, 3
		jz	short devrderr
		pop	ds
		jmp	short do_io
; ---------------------------------------------------------------------------

next_char:				; ...
		pop	ds
		mov	di, dx
		dec	cx
		jcxz	done_read
		inc	word [es:bx+14]
		jmp	short do_io
; ---------------------------------------------------------------------------

devrderr:				; ...
		pop	di
		les	di, [ss:THISSFT]
		jmp	SET_ACC_ERR_DS
; ---------------------------------------------------------------------------

no_char:				; ...
		push	ax
		mov	ah, 84h
		int	2Ah		; Microsoft Networks - KEYBOARD	BUSY LOOP
		pop	ax
		jmp	do_io
; ---------------------------------------------------------------------------

pop_done_read:				; ...
		pop	ds

done_read:				; ...
		add	di, word [ss:CALLBPB]
		jmp	ENDRDDEVJ3
; ---------------------------------------------------------------------------

TRANBUF:				; ...
		lodsb
		stosb
		cmp	al, 0Dh
		jnz	short NORMCH
		mov	byte [si], 0Ah

NORMCH:					; ...
		cmp	al, 0Ah
		loopne	TRANBUF
		jnz	short ENDRDCON
		xor	si, si
		call	OUTT
		or	al, 1

ENDRDCON:				; ...
		push	ss
		pop	ds
		call	SWAPBACK
		mov	[CONTPOS], si

ENDRDDEV:				; ...
		push	ss
		pop	ds
		mov	[NEXTADD], di
		jnz	short SETSFTC
		les	di, [THISSFT]
		and	byte [es:di+5], 0BFh

SETSFTC:				; ...
		call	SETSFT
		retn
; ---------------------------------------------------------------------------

READCON:				; ...
		call	SWAPCON
		mov	si, [CONTPOS]
		or	si, si
		jnz	short TRANBUF
		cmp	byte [CONBUF], 128
		jz	short GETBUF
		mov	word [CONBUF], 0FF80h

GETBUF:					; ...
		push	cx
		push	es
		push	di
		mov	dx, CONBUF
		call	$STD_CON_STRING_INPUT
		pop	di
		pop	es
		pop	cx
		mov	si, CONBUF+2
		cmp	byte [si], 1Ah
		jnz	short TRANBUF
		mov	al, 1Ah
		stosb
		dec	di
		mov	al, 0Ah
		call	OUTT
		xor	si, si
		jmp	short ENDRDCON

; =============== S U B	R O U T	I N E =======================================


DOS_WRITE:
		les	di, [THISSFT]
		mov	al, [es:di+2]
		and	al, 0Fh
		cmp	al, 0
		jnz	short Check_FCB_RO

BadMode:				; ...
		jmp	SET_ACC_ERR
; ---------------------------------------------------------------------------

Check_FCB_RO:				; ...
		test	byte [es:di+3], 80h
		jz	short WRITE_NO_MODE
		test	byte [es:di+4], 1
		jnz	short BadMode

WRITE_NO_MODE:				; ...
		call	SETUP
		call	IsSFTNet
		jz	short LOCAL_WRITE
		mov	ax, 1109h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - WRITE TO REMOTE FILE
					; ES:DI	-> SFT
					; SFT DPB field	-> DPB of drive	containing file
					; CX = number of bytes,	SS = DOS CS, SDA DTA field -> user buffer
					; Return: CF set on error, CX =	bytes written
		retn
; ---------------------------------------------------------------------------

LOCAL_WRITE:				; ...
		test	byte [es:di+5], 80h
		jnz	short WRTDEV
		mov	byte [EXTERR_LOCUS], 2
		call	ECritDisk
		call	DISKWRITE
		jb	short nocommit
		les	di, [THISSFT]
		test	byte [es:di+3], 40h
		jz	short nocommit
		push	cx
		call	DOS_COMMIT
		pop	cx

nocommit:				; ...
		call	LCritDisk
		retn
; ---------------------------------------------------------------------------

DVWRTRAW:				; ...
		xor	ax, ax
		call	SETWRITE
		push	ds
		lds	si, [ss:THISSFT]
		call	DEVIOCALL
		mov	dx, di
		mov	ah, 87h
		mov	di, [ss:DEVCALL_REQSTAT]
		or	di, di
		jns	short CWRTROK
		call	CHARHARD
		sub	cx, word [ss:CALLBPB]	; [ss:CALLSCNT]
		mov	bx, dx
		add	bx, word [ss:CALLBPB]
		mov	di, bx
		or	al, al
		jz	short CWRTROK
		cmp	al, 3
		jz	short CWRFERR
		pop	ds
		jmp	short DVWRTRAW
; ---------------------------------------------------------------------------

CWRFERR:				; ...
		pop	ax
		jmp	CRDFERR
; ---------------------------------------------------------------------------

CWRTROK:				; ...
		pop	ax
		pop	ds
		mov	ax, word [CALLBPB]

ENDWRDEV:				; ...
		les	di, [THISSFT]
		mov	cx, ax
		call	ADDREC
		retn
; ---------------------------------------------------------------------------

WRTNUL:					; ...
		mov	dx, cx

WRTCOOKJ:				; ...
		jmp	WRTCOOKDONE
; ---------------------------------------------------------------------------

WRTDEV:					; ...
		mov	byte [EXTERR_LOCUS], 4
		or	byte [es:di+5], 40h
		mov	bl, [es:di+5]
		xor	ax, ax
		jcxz	ENDWRDEV
		push	ds
		mov	al, bl
		lds	bx, [DMAADD]
		mov	di, bx
		xor	dx, dx
		test	al, 20h
		jz	short TEST_DEV_CON
		jmp	short DVWRTRAW
; ---------------------------------------------------------------------------

TEST_DEV_CON:				; ...
		test	al, 2
		jnz	short WRITECON
		test	al, 4
		jnz	short WRTNUL
		mov	ax, dx
		cmp	byte [bx], 1Ah
		jz	short WRTCOOKJ
		push	cx
		mov	cx, 1
		call	SETWRITE
		pop	cx
		lds	si, [ss:THISSFT]
		lds	si, [si+7]

DVWRTLP:				; ...
		call	DSKSTATCHK
		call	DEVIOCALL2
		push	di
		mov	ah, 87h
		mov	di, [ss:35Dh]
		or	di, di
		jns	short CWROK
		call	CHARHARD
		pop	di
		mov	word [ss:CALLBPB], 1
		cmp	al, 1
		jz	short DVWRTLP
		or	al, al
		jz	short DVWRTIGN
		jmp	CRDFERR
; ---------------------------------------------------------------------------

CWROK:					; ...
		pop	di
		cmp	word [ss:CALLBPB], 0
		jz	short WRTCOOKDONE

DVWRTIGN:				; ...
		inc	dx
		inc	word [ss:CALLBR]
		inc	di
		push	ds
		mov	ds, word [ss:CALLBR+2]
		cmp	byte [di], 1Ah
		pop	ds
		jz	short WRTCOOKDONE
		mov	word [ss:DEVCALL_REQSTAT], 0
		loop	DVWRTLP

WRTCOOKDONE:				; ...
		mov	ax, dx
		pop	ds
		jmp	ENDWRDEV
; ---------------------------------------------------------------------------

WRITECON:				; ...
		push	ds
		push	ss
		pop	ds
		call	SWAPCON
		pop	ds
		mov	si, bx
		push	cx

WRCONLP:				; ...
		lodsb
		cmp	al, 1Ah
		jz	short CONEOF
		call	OUTT
		loop	WRCONLP

CONEOF:					; ...
		pop	ax
		sub	ax, cx
		pop	ds
		call	SWAPBACK
		jmp	ENDWRDEV

; =============== S U B	R O U T	I N E =======================================


GET_IO_SFT:
		cmp	byte [ss:CONSWAP], 0
		jnz	short GetRedir

GetNormal:				; ...
		push	ss
		pop	ds
		push	es
		push	di
		call	SFFromHandle
		jb	short RET44P
		mov	si, es
		mov	ds, si
		mov	si, di

RET44P:					; ...
		pop	di
		pop	es
		retn
; ---------------------------------------------------------------------------

GetRedir:				; ...
		cmp	bx, 1
		ja	short GetNormal
		lds	si, [ss:CONSFT]
		clc

get_io_sft_retn:			; ...
		retn

; =============== S U B	R O U T	I N E =======================================


DIRREAD:
		xor	dx, dx
		cmp	word [DIRSTART], 0
		jnz	short SubDir
		xchg	ax, dx
		jmp	short DoRead
; ---------------------------------------------------------------------------

SubDir:					; ...
		mov	dl, al
		and	dl, [es:bp+4]
		mov	cl, [es:bp+5]
		shr	ax, cl

DoRead:					; ...
		mov	[SECCLUSPOS], dl
		mov	cx, ax
		mov	ah, dl
		mov	dx, [DIRSEC+2]
		mov	word [HIGH_SECTOR], dx
		mov	dx, [DIRSEC]
		add	dl, ah
		adc	dh, 0
		adc	word [HIGH_SECTOR], 0
		mov	bx, [CLUSNUM]
		mov	[NXTCLUSNUM], bx
		jcxz	FIRSTCLUSTER

SKPCLLP:				; ...
		call	UNPACK
		jb	short get_io_sft_retn
		xchg	bx, di
		call	IsEOF
		jnb	short HAVESKIPPED
		loop	SKPCLLP

HAVESKIPPED:				; ...
		mov	[NXTCLUSNUM], bx
		mov	dx, di
		mov	bl, ah
		call	FIGREC

FIRSTCLUSTER:				; ...
		mov	byte [ALLOWED], 18h
		xor	al, al
		call	GETBUFFR
		jb	short get_io_sft_retn

SET_BUF_AS_DIR:				; ...
		push	ds
		push	si
		lds	si, [CURBUF]
		or	byte [si+5], 4
		pop	si
		pop	ds

dirread_retn:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================


FATSECRD:

; FUNCTION CHUNK AT 7660 SIZE 00000002 BYTES

		mov	byte [ss:ALLOWED], 18h
		mov	di, cx
		mov	cl, [es:bp+8]
		mov	ax, [es:bp+0Fh]
		xor	ch, ch
		push	dx

NXTFAT:					; ...
		mov	word [ss:HIGH_SECTOR], 0
		push	cx
		push	ax
		mov	cx, di
		call	DSKREAD
		pop	ax
		pop	cx
		jz	short RET41P
		add	dx, ax
		loop	NXTFAT
		pop	dx
		mov	cx, di

; =============== S U B	R O U T	I N E =======================================


DREAD:
		call	DSKREAD
		jz	short dirread_retn
		mov	byte [ss:READOP], 0
		call	HARDERRRW
		cmp	al, 1
		jz	short DREAD
		cmp	al, 3
		clc
		jnz	short NO_CAR
		stc

NO_CAR:					; ...
		retn

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR FATSECRD

RET41P:					; ...
		pop	dx
		retn
; END OF FUNCTION CHUNK	FOR FATSECRD

; =============== S U B	R O U T	I N E =======================================


CHECK_WRITE_LOCK:
		test	byte [es:di+4], 8
		jz	short write_cont
		call	SET_ACC_ERR_DS
		retn
; ---------------------------------------------------------------------------

write_cont:				; ...
		push	cx
		or	cx, cx
		jnz	short Not_Truncate
		dec	cx

Not_Truncate:				; ...
		mov	al, 80h	
		call	LOCK_CHECK
		pop	cx
		jnb	short WRITE_OK
		call	WRITE_LOCK_VIOLATION
		jnb	short write_cont

WRITE_OK:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================


CHECK_READ_LOCK:
		test	byte [es:di+4], 8
		jz	short do_retry
		call	SET_ACC_ERR
		retn
; ---------------------------------------------------------------------------

do_retry:				; ...
		xor	al, al
		call	LOCK_CHECK
		jnb	short READLOCK_OK
		call	READ_LOCK_VIOLATION
		jnb	short do_retry

READLOCK_OK:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================


DSKREAD	:
		push	cx
		mov	ah, [es:bp+17h]
		mov	al, [es:bp+1]
		push	bx
		push	es
		call	SETREAD
		jmp	short DODSKOP

; =============== S U B	R O U T	I N E =======================================


DWRITE	:
		call	DSKWRITE
		jz	short dw_ret_label
		mov	byte [ss:READOP], 1
		call	HARDERRRW
		cmp	al, 1
		jz	short DWRITE
		cmp	al, 3
		clc
		jnz	short dw_ret_label
		stc

dw_ret_label:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================


DSKWRITE:
		push	cx
		mov	ah, [es:bp+17h]
		mov	al, [es:bp+1]
		push	bx
		push	es
		call	SETWRITE

DODSKOP:				; ...
		mov	cx, ds
		pop	ds
		push	ds
		lds	si, [ds:bp+13h]	; 27/09/2023
		call	DEVIOCALL2
		mov	ds, cx
		pop	es
		pop	bx
		mov	cx, word [ss:CALLBPB]
		pop	di
		sub	cx, di
		neg	cx
		mov	ax, [ss:DEVCALL_REQSTAT]
		test	ax, 8000h
		retn

; =============== S U B	R O U T	I N E =======================================


HARDERRRW:
		cmp	al, 0Fh
		jnz	short DO_ERR
		push	ax
		mov	ax, word [ss:CALLVIDRW]
		mov	word [ss:EXTERRPT], ax
		mov	ax, word [ss:CALLVIDRW+2]
		mov	word [ss:EXTERRPT+2], ax
		pop	ax

DO_ERR:					; ...
		call	HARDERR
		retn

; =============== S U B	R O U T	I N E =======================================


SETUP:
		lds	si, [es:di+7]
		mov	word [ss:THISDPB+2], ds
		push	ss
		pop	ds
		mov	word [THISDPB], si
		mov	bx, word [DMAADD]
		mov	[NEXTADD], bx
		mov	byte [TRANS], 0
		mov	ax, [es:di+15h]
		mov	dx, [es:di+17h]
		mov	[BYTPOS+2], dx
		mov	[BYTPOS], ax
		test	word [es:di+5], 8080h
		jnz	short NOSETSTUFF
		push	es
		les	bp, [THISDPB]
		mov	bl, [es:bp+0]
		mov	[THISDRV], bl
		mov	bx, [es:bp+2]
		push	cx
		call	DIV32
		mov	word [BYTSECPOS], dx
		mov	[SECPOS], ax
		mov	word [SECPOS+2], cx
		mov	dx, cx
		mov	bx, ax
		and	bl, [es:bp+4]
		mov	[SECCLUSPOS], bl
		call	SHR32
		pop	cx
		jnz	short EOFERR
		cmp	ax, [es:bp+0Dh]
		ja	short EOFERR
		mov	[CLUSNUM], ax
		pop	es

NOSETSTUFF:				; ...
		mov	ax, cx
		add	ax, word [DMAADD]
		jnb	short setup_OK
		mov	ax, word [DMAADD]
		neg	ax
		jnz	short NoDec
		dec	ax

NoDec:					; ...
		mov	cx, ax
		jcxz	NOROOM

setup_OK:				; ...
		retn
; ---------------------------------------------------------------------------

EOFERR:					; ...
		pop	es
		xor	cx, cx

NOROOM:					; ...
		pop	bx
		clc
		retn

; =============== S U B	R O U T	I N E =======================================


BREAKDOWN:
		mov	ax, [BYTSECPOS]
		mov	bx, cx
		or	ax, ax
		jz	short SAVFIR
		sub	ax, [es:bp+2]
		neg	ax
		sub	bx, ax
		jnb	short SAVFIR
		add	ax, bx
		xor	bx, bx

SAVFIR:					; ...
		mov	word [BYTCNT1], ax
		mov	ax, bx
		xor	dx, dx
		div	word [es:bp+2]
		mov	word [SECCNT], ax
		mov	[BYTCNT2], dx

_RET45:					; ...
		retn

; =============== S U B	R O U T	I N E =======================================


READ_LOCK_VIOLATION:
		mov	byte [READOP], 0

ERR_ON_CHECK:				; ...
		test	byte [es:di+3], 80h
		jnz	short HARD_ERR
		push	cx
		mov	cl, [es:di+2]
		and	cl, 0F0h
		cmp	cl, 0
		pop	cx
		jnz	short NO_HARD_ERR

HARD_ERR:				; ...
		call	LOCK_VIOLATION
		jnb	short _RET45

NO_HARD_ERR:				; ...
		xor	cx, cx
		mov	ax, 21h
		stc
		retn


; =============== S U B	R O U T	I N E =======================================


WRITE_LOCK_VIOLATION:
		mov	byte [READOP], 1
		jmp	short ERR_ON_CHECK


; =============== S U B	R O U T	I N E =======================================


DISKREAD:

; FUNCTION CHUNK AT 782C SIZE 00000002 BYTES
; FUNCTION CHUNK AT 7837 SIZE 0000008B BYTES
; FUNCTION CHUNK AT 7A4E SIZE 0000000B BYTES

		mov	ax, [es:di+11h]
		mov	bx, [es:di+13h]
		sub	ax, [BYTPOS]
		sbb	bx, [BYTPOS+2]
		jb	short RDERR
		jnz	short ENUF
		or	ax, ax
		jz	short RDERR
		cmp	ax, cx
		jnb	short ENUF
		mov	cx, ax

ENUF:					; ...
		call	CHECK_READ_LOCK
		jnb	short _READ_OK
		retn
; ---------------------------------------------------------------------------

_READ_OK:				; ...
		les	bp, [THISDPB]
		call	BREAKDOWN
		mov	cx, [CLUSNUM]
		call	FNDCLUS
		jb	short SET_ACC_ERR_DS
		or	cx, cx
		jz	short SKIPERR

RDERR:					; ...
		mov	ah, 0Eh
		jmp	WRTERR22

; =============== S U B	R O U T	I N E =======================================

; Attributes: thunk

SETSFTJ2:
		jmp	SETSFT

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR DISKREAD

CANOT_READ:				; ...
		pop	cx
		pop	bx
; END OF FUNCTION CHUNK	FOR DISKREAD

; =============== S U B	R O U T	I N E =======================================


SET_ACC_ERR_DS:
		push	ss
		pop	ds

; =============== S U B	R O U T	I N E =======================================


SET_ACC_ERR:
		xor	cx, cx
		mov	ax, 5
		stc
		retn

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR DISKREAD

SKIPERR:				; ...
		mov	word [LASTPOS], dx
		mov	[CLUSNUM], bx
		cmp	word [BYTCNT1], 0
		jz	short RDMID
		call	BUFRD
		jb	short SET_ACC_ERR_DS

RDMID:					; ...
		cmp	word [SECCNT], 0
		jz	short RDLAST
		call	NEXTSEC
		jb	short SETSFTJ2
		mov	byte [TRANS], 1
		mov	dl, [SECCLUSPOS]
		mov	cx, [SECCNT]
		mov	bx, [CLUSNUM]

RDLP:					; ...
		call	OPTIMIZE
		jb	short SET_ACC_ERR_DS
		push	di
		push	ax
		push	bx
		mov	byte [ALLOWED], 38h
		mov	ds, word [DMAADD+2]
		push	dx
		push	cx
		call	SET_RQ_SC_PARMS
		call	DREAD
		pop	cx
		pop	dx
		pop	word [ss:TEMP_VAR]
		jb	short CANOT_READ
		mov	[ss:TEMP_VAR2], ds
		call	DskRdBufScan
		push	ss
		pop	ds
		pop	cx
		pop	bx
		jcxz	RDLAST
		call	IsEOF
		jnb	short SETSFT
		mov	dl, 0
		inc	word [LASTPOS]
		jmp	short RDLP
; ---------------------------------------------------------------------------

RDLAST:					; ...
		mov	ax, [BYTCNT2]
		or	ax, ax
		jz	short SETSFT
		mov	word [BYTCNT1], ax
		call	NEXTSEC
		jb	short SETSFT
		mov	word [BYTSECPOS], 0
		call	BUFRD
		jnb	short SETSFT
		jmp	SET_ACC_ERR_DS
; END OF FUNCTION CHUNK	FOR DISKREAD

; =============== S U B	R O U T	I N E =======================================


SETSFT:
		les	di, [THISSFT]

SETCLUS:				; ...
		mov	cx, [NEXTADD]
		sub	cx, word [DMAADD]
		test	byte [es:di+5], 80h
		jnz	short ADDREC
		mov	ax, [CLUSNUM]
		mov	[es:di+35h], ax
		mov	ax, [LASTPOS]
		mov	[es:di+19h], ax

; =============== S U B	R O U T	I N E =======================================


ADDREC:
		jcxz	RET28
		add	[es:di+15h], cx
		adc	word [es:di+17h], 0

RET28:					; ...
		clc
		retn

; =============== S U B	R O U T	I N E =======================================


DskRdBufScan:
		cmp	word [ss:DirtyBufferCount], 0
		jz	short bufx
		mov	bx, [ss:HIGH_SECTOR]
		mov	si, bx
		add	cx, dx
		adc	si, 0
		call	GETCURHEAD
		mov	ax, [di+2]
		mov	[ss:FIRST_BUFF_ADDR], ax
		mov	al, [es:bp+0]

bufq:					; ...
		cmp	al, [di+4]
		jnz	short bufq1
		cmp	bx, [di+8]
		jnz	short bufq01
		cmp	dx, [di+6]

bufq01:					; ...
		ja	short bufq1
		cmp	si, [di+8]
		jnz	short bufq02
		cmp	cx, [di+6]

bufq02:					; ...
		ja	short bufq2

bufq1:					; ...
		cmp	di, [ss:FIRST_BUFF_ADDR]
		mov	di, [di]
		jnz	short bufq

bufx:					; ...
		retn
; ---------------------------------------------------------------------------

bufq2:					; ...
		push	ax
		test	byte [di+5], 40h
		jz	short bufq3
		push	cx
		push	dx
		push	si
		push	di
		push	es
		mov	ax, dx
		sub	ax, [di+6]
		neg	ax
		lea	si, [di+20]
		mov	cx, [es:bp+2]
		mul	cx
		mov	di, [ss:TEMP_VAR]
		add	di, ax
		mov	es, [ss:TEMP_VAR2]
		shr	cx, 1
		rep movsw
		adc	cx, 0
		rep movsb
		pop	es
		pop	di
		pop	si
		pop	dx
		pop	cx

bufq3:					; ...
		mov	ax, di
		call	SCANPLACE
		cmp	ax, [ss:FIRST_BUFF_ADDR]
		pop	ax
		jnz	short bufq
		jmp	short bufx

; =============== S U B	R O U T	I N E =======================================


DISKWRITE:

; FUNCTION CHUNK AT 7A59 SIZE 000001B5 BYTES

		call	CHECK_WRITE_LOCK
		jnb	short _WRITE_OK
		retn
; ---------------------------------------------------------------------------

WRTEOFJ:				; ...
		jmp	WRTEOF
; ---------------------------------------------------------------------------

_WRITE_OK:				; ...
		and	word [es:di+5], 0BFBFh
		mov	ax, [es:di+11h]
		mov	[TEMP_VAR], ax
		mov	ax, [es:di+13h]
		mov	[TEMP_VAR2], ax
		les	bp, [THISDPB]
		call	BREAKDOWN
		mov	ax, [BYTPOS]
		mov	dx, [BYTPOS+2]
		jcxz	WRTEOFJ
		add	ax, cx
		adc	dx, 0
		mov	bx, [es:bp+2]
		call	DIV32
		mov	si, ax
		mov	word [HIGH_SECTOR], cx
		or	dx, dx
		push	dx
		mov	dx, cx
		jnz	short CALCLUS
		sub	ax, 1
		sbb	dx, 0

CALCLUS:				; ...
		call	SHR32
		pop	dx
		push	ax
		push	dx
		mov	dx, [TEMP_VAR2]
		mov	ax, [TEMP_VAR]
		call	DIV32
		mov	[TEMP_VAR2], cx
		mov	[VALSEC+2], cx
		mov	cx, ax
		mov	bx, si
		or	dx, dx
		jz	short NORND
		add	ax, 1
		adc	word [VALSEC+2], 0

NORND:					; ...
		mov	[VALSEC], ax
		xor	ax, ax
		mov	[GROWCNT], ax
		mov	[GROWCNT+2], ax
		pop	ax
		mov	di, [HIGH_SECTOR]
		cmp	di, [TEMP_VAR2]
		jb	short NOGROW
		jz	short lowsec
		sub	bx, cx
		sbb	di, [TEMP_VAR2]
		jmp	short yesgrow
; ---------------------------------------------------------------------------

lowsec:					; ...
		mov	di, 0
		sub	bx, cx
		jb	short NOGROW
		jz	short TESTTAIL

yesgrow:				; ...
		mov	cx, dx
		xchg	ax, bx
		mul	word [es:bp+2]
		mov	word [HIGH_SECTOR], dx
		mov	[TEMP_VAR2], ax
		mov	ax, di
		mul	word [es:bp+2]
		add	ax, [HIGH_SECTOR]
		mov	dx, ax
		mov	ax, [TEMP_VAR2]
		sub	ax, cx
		sbb	dx, 0
		add	ax, bx
		adc	dx, 0
		jmp	short SETGRW
; ---------------------------------------------------------------------------

HAVSTART:				; ...
		mov	cx, ax
		call	SKPCLP
		jcxz	DOWRTJ
		call	ALLOCATE
		jnb	short DOWRTJ

WRTERR:					; ...
		mov	ah, 0Fh

; START	OF FUNCTION CHUNK FOR DISKREAD

WRTERR22:				; ...
		mov	al, [THISDRV]
		xor	cx, cx
		les	di, [THISSFT]
		clc
		retn
; END OF FUNCTION CHUNK	FOR DISKREAD
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR DISKWRITE

DOWRTJ:					; ...
		jmp	short DOWRT
; ---------------------------------------------------------------------------

ACC_ERRWJ:				; ...
		jmp	SET_ACC_ERRW
; ---------------------------------------------------------------------------

TESTTAIL:				; ...
		sub	ax, dx
		jbe	short NOGROW
		xor	dx, dx

SETGRW:					; ...
		mov	[GROWCNT], ax
		mov	[GROWCNT+2], dx

NOGROW:					; ...
		pop	ax
		mov	cx, [CLUSNUM]
		call	FNDCLUS
		jb	short ACC_ERRWJ
		mov	[CLUSNUM], bx
		mov	word [LASTPOS], dx
		sub	ax, dx
		jz	short DOWRT
		jcxz	HAVSTART
		push	cx
		mov	cx, ax
		call	ALLOCATE
		pop	cx
		jb	short WRTERR
		mov	dx, [LASTPOS]
		inc	dx
		dec	cx
		jz	short NOSKIP
		call	SKPCLP
		jb	short ACC_ERRWJ

NOSKIP:					; ...
		mov	[CLUSNUM], bx
		mov	word [LASTPOS], dx

DOWRT:					; ...
		cmp	word [BYTCNT1], 0
		jz	short WRTMID
		mov	bx, [CLUSNUM]
		call	BUFWRT
		jb	short ACC_ERRWJ

WRTMID:					; ...
		mov	ax, [SECCNT]
		or	ax, ax
		jz	short WRTLAST
		add	[SECPOS], ax
		adc	word [SECPOS+2], 0
		call	NEXTSEC
		jb	short SET_ACC_ERRW
		mov	byte [TRANS], 1
		mov	dl, [SECCLUSPOS]
		mov	bx, [CLUSNUM]
		mov	cx, [SECCNT]

WRTLP:					; ...
		call	OPTIMIZE
		jb	short SET_ACC_ERRW
		push	di
		push	ax
		call	DskWrtBufPurge
		mov	ds, word [ss:DMAADD+2]
		mov	byte [ss:ALLOWED], 38h

DWRITE_LUP:				; ...
		call	DSKWRITE
		jz	short DWRITE_OKAY
		cmp	al, 27h
		jz	short DWRITE_DISK_FULL
		mov	byte [ss:READOP], 1
		call	HARDERRRW
		cmp	al, 1
		jz	short DWRITE_LUP
		cmp	al, 3
		clc
		jnz	short DWRITE_OKAY
		stc

DWRITE_OKAY:				; ...
		pop	cx
		pop	bx
		push	ss
		pop	ds
		jb	short SET_ACC_ERRW
		jcxz	WRTLAST
		mov	dl, 0
		inc	word [LASTPOS]
		jmp	short WRTLP
; ---------------------------------------------------------------------------

DWRITE_DISK_FULL:			; ...
		push	ss
		pop	ds
		pop	cx
		pop	bx
		mov	byte [DISK_FULL], 1
		stc
		jmp	WRTERR
; ---------------------------------------------------------------------------

SET_ACC_ERRW:				; ...
		jmp	SET_ACC_ERR_DS
; ---------------------------------------------------------------------------

WRTLAST:				; ...
		mov	ax, [BYTCNT2]
		or	ax, ax
		jz	short FINWRT
		mov	word [BYTCNT1], ax
		call	NEXTSEC
		jb	short SET_ACC_ERRW
		mov	word [BYTSECPOS], 0
		call	BUFWRT
		jb	short SET_ACC_ERRW

FINWRT:					; ...
		les	di, [THISSFT]
		mov	ax, [GROWCNT]
		mov	cx, [GROWCNT+2]
		or	ax, ax
		jnz	short UPDATE_size
		jcxz	SAMSIZ

UPDATE_size:				; ...
		add	[es:di+11h], ax
		adc	[es:di+13h], cx
		mov	ax, 1
		call	far [ShSU]

SAMSIZ:					; ...
		jmp	SETCLUS
; ---------------------------------------------------------------------------

WRTEOF:					; ...
		mov	cx, ax
		or	cx, dx
		jz	short KILLFIL
		sub	ax, 1
		sbb	dx, 0
		push	bx
		mov	bx, [es:bp+2]
		call	DIV32
		pop	bx
		mov	dx, cx
		mov	word [HIGH_SECTOR],	cx
		call	SHR32
		mov	cx, ax
		call	FNDCLUS

SET_ACC_ERRWJ2:				; ...
		jb	short SET_ACC_ERRW
		jcxz	RELFILE
		call	ALLOCATE
		jb	short WRTERRJ

UPDATE:					; ...
		les	di, [THISSFT]
		mov	ax, [BYTPOS]
		mov	[es:di+11h], ax
		mov	ax, [BYTPOS+2]
		mov	[es:di+13h], ax
		mov	ax, 2
		call	far [ShSU]
		xor	cx, cx
		jmp	ADDREC
; ---------------------------------------------------------------------------

WRTERRJ:				; ...
		jmp	WRTERR
; ---------------------------------------------------------------------------

RELFILE:				; ...
		push	es
		les	di, [THISSFT]
		cmp	dx, [es:di+19h]
		jnb	short SKIPRESET
		mov	word [es:di+19h], 0
		mov	dx, [es:di+0Bh]
		mov	[es:di+35h], dx

SKIPRESET:				; ...
		pop	es
		mov	dx, 0FFFFh
		call	RELBLKS

SET_ACC_ERRWJ:				; ...
		jb	short SET_ACC_ERRWJ2
		jmp	short UPDATE
; ---------------------------------------------------------------------------

KILLFIL:				; ...
		xor	bx, bx
		push	es
		les	di, [THISSFT]
		mov	[es:di+19h], bx
		mov	[es:di+35h], bx
		xchg	bx, [es:di+0Bh]
		pop	es
		or	bx, bx
		jz	short UPDATEJ
		push	es
		push	bp
		push	ax
		push	cx
		push	dx
		les	bp, [THISDPB]
		mov	dl, [es:bp+0]
		mov	cx, bx
		mov	ah, 2
		call	FastOpen_Update
		pop	dx
		pop	cx
		pop	ax
		pop	bp
		pop	es
		call	RELEASE
		jb	short SET_ACC_ERRWJ

UPDATEJ:				; ...
		jmp	short UPDATE
; END OF FUNCTION CHUNK	FOR DISKWRITE

; =============== S U B	R O U T	I N E =======================================


DskWrtBufPurge:
		push	bx
		push	cx
		mov	bx, [ss:HIGH_SECTOR]
		mov	si, bx
		add	cx, dx
		adc	si, 0
		mov	al, [es:bp+0]
		cmp	word [ss:SC_CACHE_COUNT], 0
		jz	short nosc
		cmp	al, [ss:CurSC_DRIVE]
		jnz	short nosc
		push	ax
		mov	ax, [ss:CurSC_SECTOR]
		mov	di, [ss:CurSC_SECTOR+2]
		cmp	si, di
		jnz	short sc01
		cmp	cx, ax

sc01:					; ...
		jbe	short sc5
		add	ax, [ss:SC_CACHE_COUNT]
		adc	di, 0
		cmp	bx, di
		jnz	short sc02
		cmp	dx, ax

sc02:					; ...
		jnb	short sc5
		mov	word [ss:SC_STATUS], 0

sc5:					; ...
		pop	ax

nosc:					; ...
		call	GETCURHEAD

_bufq:					; ...
		cmp	al, [di+4]
		jnz	short bufq5
		cmp	bx, [di+8]
		jnz	short bufq04
		cmp	dx, [di+6]

bufq04:					; ...
		ja	short bufq5
		cmp	si, [di+8]
		jnz	short bufq05
		cmp	cx, [di+6]

bufq05:					; ...
		jbe	short bufq5
		test	byte [di+5], 40h
		jz	short bufq4
		call	DEC_DIRTY_COUNT

bufq4:					; ...
		mov	word [di+4], 20FFh
		call	SCANPLACE
		jmp	short bufq6
; ---------------------------------------------------------------------------

bufq5:					; ...
		mov	di, [di]

bufq6:					; ...
		cmp	di, [ss:FIRST_BUFF_ADDR]
		jnz	short _bufq
		pop	cx
		pop	bx
		retn

; =============== S U B	R O U T	I N E =======================================


DIV32:
		cmp	bx, 512
		jnz	short div5
		mov	cx, dx
		mov	dx, ax
		and	dx, 511
		mov	al, ah
		mov	ah, cl
		mov	cl, ch
		xor	ch, ch
		shr	cx, 1
		rcr	ax, 1
		retn
; ---------------------------------------------------------------------------

div5:					; ...
		mov	cx, ax
		mov	ax, dx
		xor	dx, dx
		div	bx
		xchg	ax, cx
		div	bx
		retn

; =============== S U B	R O U T	I N E =======================================


SHR32:
		mov	cl, [es:bp+5]
		xor	ch, ch
		jcxz	norota

rotashft2:				; ...
		shr	dx, 1
		rcr	ax, 1
		loop	rotashft2

norota:					; ...
		retn

; =============== S U B	R O U T	I N E =======================================


SEARCH:
		call	STARTSRCH
		mov	al, [ATTRIB]
		and	al, 9Eh
		cmp	al, 8
		jnz	short NOTVOLSRCH
		call	SETROOTSRCH

NOTVOLSRCH:				; ...
		call	GETENTRY
		jnb	short SRCH
		jmp	SETESRET
; ---------------------------------------------------------------------------

SRCH:					; ...
		push	ds
		mov	ds, word [CURBUF+2]
		mov	ah, [bx]
		or	ah, ah
		jz	short FREE
		cmp	ah, [ss:DELALL]
		jz	short FREE
		test	byte [bx+0Bh], 8
		jz	short CHKFNAM
		inc	byte [ss:VOLID]

CHKFNAM:				; ...
		mov	si, ss
		mov	es, si
		mov	si, bx
		mov	di, NAME1
		cmp	byte [ss:NAME1], 0E5h
		jnz	short NO_E5
		mov	byte [ss:NAME1], 5

NO_E5:					; ...
		call	MetaCompare
		jz	short FOUND
		pop	ds

NEXTENT:				; ...
		les	bp, [THISDPB]
		call	NEXTENTRY
		jnb	short SRCH
		jmp	short SETESRET
; ---------------------------------------------------------------------------

FREE:					; ...
		pop	ds
		mov	cx, [LASTENT]
		cmp	cx, [ENTFREE]
		jnb	short TSTALL
		mov	[ENTFREE], cx

TSTALL:					; ...
		cmp	ah, [DELALL]

NEXTENTJ:				; ...
		jz	short NEXTENT
		mov	[ENTLAST], cx
		stc
		jmp	short SETESRET
; ---------------------------------------------------------------------------

FOUND:					; ...
		mov	ch, [si]
		pop	ds
		mov	ah, [ATTRIB]
		and	ah, 9Eh
		lea	si, [si+0Fh]
		test	ch, 8
		jz	short check_one_volume_id
		test	ah, 8
		jz	short NEXTENTJ
		xor	ah, ah
		jmp	short RETFF
; ---------------------------------------------------------------------------

check_one_volume_id:			; ...
		cmp	ah, 8
		jz	short NEXTENTJ
		call	MatchAttributes
		jz	short RETFF
		test	byte [CREATING], 0FFh
		jz	short NEXTENTJ

RETFF:					; ...
		les	bp, [THISDPB]
		mov	ah, [es:bp+0]

SETESRET:				; ...
		push	ss
		pop	es
		retn

; =============== S U B	R O U T	I N E =======================================


MetaCompare:
		mov	cx, 11

WILDCRD:				; ...
		repe cmpsb
		jz	short MetaRet
		cmp	byte [es:di-1], '?'
		jz	short WILDCRD

MetaRet:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================


NEXTENTRY:
		mov	ax, [LASTENT]
		cmp	ax, [ENTLAST]
		jz	short NONE
		inc	ax
		lea	bx, [bx+32]
		cmp	bx, dx
		jnz	short HAVIT
		mov	bl, [SECCLUSPOS]
		inc	bl
		cmp	bl, [CLUSFAC]
		jb	short SAMECLUS
		mov	bx, [NXTCLUSNUM]
		call	IsEOF
		jnb	short NONE
		cmp	bx, 2
		jb	short NONE
		jmp	short GETENT
; ---------------------------------------------------------------------------

NONE:					; ...
		stc
		retn
; ---------------------------------------------------------------------------

HAVIT:					; ...
		mov	word [LASTENT], ax
		clc

nextentry_retn:				; ...
		retn
; ---------------------------------------------------------------------------

SAMECLUS:				; ...
		mov	[SECCLUSPOS], bl
		mov	word [LASTENT], ax
		push	ds
		lds	di, [CURBUF]
		mov	dx, [di+8]
		mov	word [ss:HIGH_SECTOR], dx
		mov	dx, [di+6]
		add	dx, 1
		adc	word [ss:HIGH_SECTOR], 0
		pop	ds
		call	FIRSTCLUSTER
		xor	bx, bx
		jmp	short SETENTRY

; =============== S U B	R O U T	I N E =======================================


GETENTRY:
		mov	ax, [LASTENT]

GETENT:					; ...
		mov	word [LASTENT], ax
		mov	cl, 5
		rol	ax, cl
		mov	dx, ax
		and	ax, 0FFE0h
		and	dx, 1Fh
		mov	bx, [es:bp+2]
		and	bl, 0E0h	; 255-31
		div	bx
		mov	bx, dx
		push	bx
		call	DIRREAD
		pop	bx
		jb	short nextentry_retn

SETENTRY:				; ...
		mov	dx, word [CURBUF]
		add	dx, 20
		add	bx, dx
		add	dx, [es:bp+2]
		clc
		retn

; =============== S U B	R O U T	I N E =======================================


SETDIRSRCH:
		or	bx, bx
		jz	short SETROOTSRCH
		mov	word [DIRSTART], bx
		mov	al, [es:bp+4]
		inc	al
		mov	[CLUSFAC], al
		push	si
		test	byte [FastOpenFlg], 2
		jnz	short UNP_OK
		call	UNPACK
		jnb	short UNP_OK
		pop	si
		retn
; ---------------------------------------------------------------------------

UNP_OK:					; ...
		mov	[CLUSNUM], di
		mov	dx, bx
		xor	bl, bl
		mov	[SECCLUSPOS], bl
		call	FIGREC
		pop	si
		push	dx
		mov	dx, [HIGH_SECTOR]
		mov	word [DIRSEC+2], dx
		pop	dx
		mov	[DIRSEC], dx
		clc
		retn

; =============== S U B	R O U T	I N E =======================================


SETROOTSRCH:
		xor	ax, ax
		mov	word [DIRSTART], ax
		mov	[SECCLUSPOS], al
		dec	ax
		mov	[CLUSNUM], ax
		mov	ax, [es:bp+0Bh]
		mov	dx, [es:bp+11h]
		sub	ax, dx
		mov	[CLUSFAC], al
		mov	[DIRSEC], dx
		mov	word [DIRSEC+2], 0
		clc
		retn

; =============== S U B	R O U T	I N E =======================================


GETPATH	:

; FUNCTION CHUNK AT 7F82 SIZE 000001A5 BYTES

		mov	word [CREATING], 0E500h

GetPathNoSet:				; ...
		mov	byte [EXTERR_LOCUS], 2
		mov	word [CURBUF], 0FFFFh
		mov	di, [WFP_START]
		cmp	word [di+1], ':\' ; '\:'
		jz	short CrackIt
		add	di, 3
		mov	si, di
		call	CHKDEV
		jb	short InternalError

Build_devJ:				; ...
		mov	al, [SATTRIB]
		mov	byte [ATTRIB], al
		mov	byte [EXTERR_LOCUS], 1
		push	ss
		pop	es
		mov	si, NAME1
		mov	di, [WFP_START]
		mov	dx, di
		mov	cx, 8

MoveLoop:				; ...
		lodsb
		stosb
		cmp	al, 20h	; ' '
		jz	short NoSave
		mov	dx, di

NoSave:					; ...
		loop	MoveLoop
		mov	di, dx
		mov	byte [di], 0
		call	Build_device_ent
		inc	al
		retn
; ---------------------------------------------------------------------------

InternalError:				; ...
		jmp	short InternalError
; ---------------------------------------------------------------------------

CrackIt:				; ...
		mov	si, [CURR_DIR_END]
		cmp	si, 0FFFFh
		jnz	short LOOK_SING
		lea	si, [di+3]

LOOK_SING:				; ...
		mov	byte [ATTRIB], 16h
		les	di, [THISCDS]
		mov	ax, 0FFFFh
		mov	bx, [es:di+73]
		mov	si, [CURR_DIR_END]
		cmp	si, ax
		jz	short NO_CURR_D
		cmp	bx, ax
		jz	short NO_CURR_D
		test	byte [FastOpenFlg],	1
		jz	short GOT_SEARCH_CLUSTER
		push	es
		push	di
		push	cx
		push	word [si-1]
		push	si
		push	bx
		mov	byte [si-1], 0
		mov	si, [WFP_START]
		mov	bx, FastOpenTable
		mov	di, Dir_Info_Buff
		mov	cx, FastOpen_Ext_Info
		mov	al, 1
		push	ds
		pop	es
		call	far [bx+2]
		jb	short GO_Chk_end1
		cmp	byte [si], 0
		jz	short GO_Chk_end
		stc
		jmp	short GO_Chk_end
; ---------------------------------------------------------------------------

GO_Chk_end1:				; ...
		clc

GO_Chk_end:				; ...
		pop	bx
		pop	si
		pop	word [si-1]
		pop	cx
		pop	di
		pop	es
		jnb	short GOT_SEARCH_CLUSTER

NO_CURR_D:				; ...
		mov	si, [WFP_START]
		lea	si, [si+3]
		les	bp, [THISDPB]
		jmp	short ROOTPATH
; ---------------------------------------------------------------------------

GOT_SEARCH_CLUSTER:			; ...
		les	bp, [THISDPB]
		call	SETDIRSRCH
		jb	short SETFERR
		jmp	short FINDPATH
; ---------------------------------------------------------------------------

SETFERR:				; ...
		xor	cl, cl
		stc
		retn

; =============== S U B	R O U T	I N E =======================================


CHKDEV	:
		mov	si, di
		mov	di, ss
		mov	es, di
		mov	di, NAME1
		mov	cx, 9

TESTLOOP:				; ...
		call	GETLET
		cmp	al, 2Eh	; '.'
		jz	short TESTDEVICE
		call	PATHCHRCMP
		jz	short NOTDEV
		or	al, al
		jz	short TESTDEVICE
		stosb
		loop	TESTLOOP

NOTDEV:					; ...
		stc
		retn
; ---------------------------------------------------------------------------

TESTDEVICE:				; ...
		add	cx, 2
		mov	al, 20h	; ' '
		rep stosb
		mov	ax, ss
		mov	ds, ax
		call	DEVNAME
		retn

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR GETPATH

ROOTPATH:				; ...
		call	SETROOTSRCH
		cmp	byte [si], 0
		jnz	short FINDPATH
		mov	al, [SATTRIB]
		mov	byte [ATTRIB], al
		xor	ah, ah
		retn
; ---------------------------------------------------------------------------

FINDPATH:				; ...
		push	es
		push	si
		mov	di, si
		mov	cx, [DIRSTART]
		cmp	word [CURR_DIR_END], 0FFFFh
		jz	short NOIDS
		cmp	di, [CURR_DIR_END]
		jnz	short NOIDS
		les	di, [THISCDS]
		mov	[es:di+73], cx

NOIDS:					; ...
		mov	ax, ss
		mov	es, ax
		mov	di, NAME1
		mov	ax, 2020h
		stosb
		stosw
		stosw
		stosw
		stosw
		stosw
		mov	di, NAME1
		xor	ah, ah

GetNam:					; ...
		inc	cl
		lodsb
		cmp	al, '.'
		jz	short _SetExt
		or	al, al
		jz	short _GetDone
		cmp	al, '\'
		jz	short _GetDone
		cmp	al, '?'
		jnz	short StoNam
		or	ah, 1

StoNam:					; ...
		stosb
		jmp	short GetNam
; ---------------------------------------------------------------------------

_SetExt:				; ...
		mov	di, NAME1+8

GetExt:					; ...
		lodsb
		or	al, al
		jz	short _GetDone
		cmp	al, '\'
		jz	short _GetDone
		cmp	al, '?'
		jnz	short StoExt
		or	ah, 1

StoExt:					; ...
		stosb
		jmp	short GetExt
; ---------------------------------------------------------------------------

_GetDone:				; ...
		dec	si
		mov	cl, ah
		or	cl, 80h
		pop	di
		pop	es
		cmp	si, di
		jnz	short check_device
		jmp	_BADPATH
; ---------------------------------------------------------------------------

check_device:				; ...
		push	si
		mov	al, [si]
		or	al, al
		jnz	short NOT_LAST
		mov	bh, [SATTRIB]
		mov	byte [ATTRIB], bh

NOT_LAST:				; ...
		push	es
		push	ss
		pop	es
		call	DEVNAME
		pop	es
		jb	short FindFile
		or	al, al
		jz	short GO_BDEV
		jmp	FILEINPATH
; ---------------------------------------------------------------------------

GO_BDEV:				; ...
		pop	si
		jmp	Build_devJ
; ---------------------------------------------------------------------------

FindFile:				; ...
		cmp	byte [NAME1], 0E5h
		jnz	short NOE5
		mov	byte [NAME1], 5

NOE5:					; ...
		push	di
		push	es
		push	cx
		call	LookupPath
		jnb	short DIR_FOUND
		call	SEARCH

DIR_FOUND:				; ...
		pop	cx
		pop	es
		pop	di
		jnb	short LOAD_BUF
		jmp	BADPATHPOP
; ---------------------------------------------------------------------------

LOAD_BUF:				; ...
		lds	di, [CURBUF]
		test	byte [bx+0Bh], 10h
		jnz	short GO_NEXT
		jmp	FILEINPATH
; ---------------------------------------------------------------------------

GO_NEXT:				; ...
		cmp	byte [ss:NoSetDir], 0
		jz	short SetDir
		mov	dx, di
		mov	cx, ds
		push	ss
		pop	ds
		pop	di
		test	byte [FastOpenFlg],	1
		jz	short _nofast
		test	byte [FastOpenFlg],	2
		jz	short _nofast
		mov	di, [Next_Element_Start]

_nofast:				; ...
		cmp	byte [di], 0
		jnz	short NEXT_ONE
		jmp	_SETRET
; ---------------------------------------------------------------------------

NEXT_ONE:				; ...
		push	di
		mov	di, dx
		mov	ds, cx

SetDir:					; ...
		mov	dx, [si]
		push	ds
		push	ss
		pop	ds
		test	byte [FastOpenFlg],	2
		jz	short DO_NORMAL
		mov	bx, dx
		mov	di, [CLUSNUM]
		push	ax
		call	SETDIRSRCH
		pop	ax
		add	sp, 2
		jmp	short FAST_OPEN_SKIP
; ---------------------------------------------------------------------------

DO_NORMAL:				; ...
		pop	ds
		sub	bx, di
		sub	si, di
		push	bx
		push	ax
		push	si
		push	cx
		push	word [di+6]
		push	word [di+8]
		mov	bx, dx
		push	ss
		pop	ds
		call	SETDIRSRCH
		pop	word [HIGH_SECTOR]
		pop	dx
		jb	short SKIP_GETB
		mov	byte [ALLOWED], 18h
		xor	al, al
		call	GETBUFFR

SKIP_GETB:				; ...
		pop	cx
		pop	si
		pop	ax
		pop	bx
		jnb	short SET_THE_BUF
		pop	di
		mov	si, di
		jmp	short _BADPATH
; ---------------------------------------------------------------------------

SET_THE_BUF:				; ...
		call	SET_BUF_AS_DIR
		mov	di, word [CURBUF]
		add	si, di
		add	bx, di

FAST_OPEN_SKIP:				; ...
		pop	di
		call	InsertPath
		mov	al, [di]
		or	al, al
		jz	short _SETRET
		inc	di
		mov	si, di
		call	PATHCHRCMP
		jnz	short find_bad_name
		jmp	FINDPATH
; ---------------------------------------------------------------------------

find_bad_name:				; ...
		dec	si

_BADPATH:				; ...
		xor	cl, cl
		jmp	short BADPRET
; ---------------------------------------------------------------------------

FILEINPATH:				; ...
		pop	di
		push	ss
		pop	ds
		test	byte [FastOpenFlg],	1
		jz	short NO_FAST
		test	byte [FastOpenFlg],	2
		jz	short NO_FAST
		mov	di, [Next_Element_Start]

NO_FAST:				; ...
		mov	al, [di]
		or	al, al
		jz	short INCRET
		mov	si, di
		jmp	short BADPRET
; ---------------------------------------------------------------------------

INCRET:					; ...
		call	InsertPath
		inc	al

_SETRET:				; ...
		retn
; ---------------------------------------------------------------------------

BADPATHPOP:				; ...
		pop	si
		mov	al, [si]
		mov	si, di
		or	al, al

BADPRET:				; ...
		mov	al, [SATTRIB]
		mov	byte [ATTRIB], al
		stc
		retn
; END OF FUNCTION CHUNK	FOR GETPATH

; =============== S U B	R O U T	I N E =======================================


STARTSRCH:
		les	bp, [THISDPB]
		xor	ax, ax
		mov	word [LASTENT], ax
		mov	byte [VOLID], al
		dec	ax
		mov	[ENTFREE], ax
		mov	[ENTLAST], ax
		retn

; =============== S U B	R O U T	I N E =======================================


MatchAttributes:
		push	ax
		mov	al, [ss:ATTRIB]
		not	al
		and	al, ch
		and	al, 16h
		pop	ax
		retn

; =============== S U B	R O U T	I N E =======================================


DEVNAME	:
		push	si
		push	di
		push	cx
		push	ax
		push	word [NAME1]
		cmp	byte [NAME1], 5
		jnz	short NOKTR
		mov	byte [NAME1], 0E5h

NOKTR:					; ...
		test	byte [ATTRIB], 8
		jnz	short RET31
		mov	si, NULDEV

LOOKIO:					; ...
		test	word [si+4], 8000h
		jz	short SKIPDEV
		mov	ax, si
		add	si, 10
		mov	di, NAME1
		mov	cx, 4
		repe cmpsw
		mov	si, ax
		jz	short IOCHK

SKIPDEV:				; ...
		lds	si, [si]
		cmp	si, 0FFFFh
		jnz	short LOOKIO

RET31:					; ...
		stc

RETNV:					; ...
		mov	cx, ss
		mov	ds, cx
		pop	word [NAME1]
		pop	ax
		pop	cx
		pop	di
		pop	si
		retn
; ---------------------------------------------------------------------------

IOCHK:					; ...
		mov	word [ss:DEVPT+2], ds
		mov	bh, [si+4]
		or	bh, 0C0h
		and	bh, 0DFh
		mov	word [ss:DEVPT], si
		jmp	short RETNV

; =============== S U B	R O U T	I N E =======================================


Build_device_ent:
		mov	ax, 2020h
		mov	di, NAME1+8 ; DEVFCB+8
		stosw
		stosb
		mov	al, 40h
		stosb
		xor	ax, ax
		mov	cx, 10
		rep stosw
		call	DATE16
		mov	di, NAME2+0Ah
		xchg	ax, dx
		stosw
		xchg	ax, dx
		stosw
		mov	si, di
		mov	ax, word [DEVPT]
		stosw
		mov	ax, word [DEVPT+2]
		stosw
		mov	ah, bh
		mov	bx, NAME1
		xor	al, al
		retn

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

ValidateCDS:

;SaveCDS	= dword	ptr -6
;Temp		= word ptr -2

SaveCDS	equ -6
Temp	equ -2
		push	bp
		mov	bp, sp
		sub	sp, 6
		mov	[bp+Temp], di
		lds	si, [ss:THISCDS]
		mov	word [bp+SaveCDS], si
		mov	word [bp+SaveCDS+2], ds
		call	ECritDisk
		test	word [si+43h], 8000h
		jz	short _DoSplice
		jmp	FatFail
; ---------------------------------------------------------------------------

_DoSplice:				; ...
		xor	dl, dl
		xchg	dl, [ss:NoSetDir]
		push	ss
		pop	es
		call	FStrCpy
		mov	si, [bp+Temp]
		push	ss
		pop	ds
		call	Splice
		push	ss
		pop	ds
		mov	byte [NoSetDir], dl
		les	di, [THISCDS]
		push	bp
		call	FATREAD_CDS
		pop	bp
		jb	short FatFail
		lds	si, [THISCDS]
		cmp	word [si+49h], 0FFFFh
		jnz	short RestoreCDS
		push	ss
		pop	es
		push	word [ss:WFP_START]
		cmp	si, word [bp+SaveCDS]
		jnz	short DoChdir
		mov	di, [bp+Temp]
		mov	[ss:WFP_START], di
		call	FStrCpy

DoChdir:				; ...
		push	ss
		pop	ds
		push	word [SATTRIB]
		push	bp
		call	DOS_CHDIR
		pop	bp
		pop	bx
		pop	word [WFP_START]
		mov	byte [SATTRIB], bl
		lds	si, [bp+SaveCDS]
		jnb	short SetCluster
		mov	word [ss:THISCDS], si
		mov	word [ss:THISCDS+2], ds
		xor	cx, cx
		mov	[si+3],	cl

SetCluster:				; ...
		mov	word [si+49h], 0FFFFh
		lds	si, [ss:THISCDS]
		test	word [si+43h], 2000h
		jz	short _setdirclus
		mov	cx, 0FFFFh

_setdirclus:				; ...
		mov	[si+49h], cx

RestoreCDS:				; ...
		les	di, [bp+SaveCDS]
		mov	word [ss:THISCDS], di
		mov	word [ss:THISCDS+2], es
		clc

FatFail:				; ...
		call	LCritDisk
		les	di, [bp+SaveCDS]
		mov	sp, bp
		pop	bp
		retn

; =============== S U B	R O U T	I N E =======================================


CheckThisDevice:
		push	di
		push	si
		mov	di, si
		mov	al, [si]
		call	PATHCHRCMP
		jnz	short ParseDev
		inc	si
		lodsw
		or	ax, 2020h
		cmp	ax, 'de'        ; 'ed'
		jnz	short NotDevice
		lodsb
		or	al, 20h
		cmp	al, 'v'
		jnz	short NotDevice
		lodsb
		call	PATHCHRCMP
		jnz	short NotDevice

ParseDev:				; ...
		push	ds
		push	si
		call	NAMETRANS
		cmp	byte [si], 0
		stc
		jnz	short SkipSearch
		push	ss
		pop	ds
		mov	al, [SATTRIB]
		mov	byte [ATTRIB], al
		call	DEVNAME

SkipSearch:				; ...
		pop	si
		pop	ds

CheckReturn:				; ...
		pop	di
		jnb	short Check_Done
		mov	si, di

Check_Done:				; ...
		pop	di
		cmc
		retn
; ---------------------------------------------------------------------------

NotDevice:				; ...
		stc
		jmp	short CheckReturn

; =============== S U B	R O U T	I N E =======================================


LookupPath:
		test	byte [ss:FastOpenFlg], 1
		jnz	short FASTINST

NOLOOK:					; ...
		jmp	NOLOOKUP
; ---------------------------------------------------------------------------

FASTINST:				; ...
		test	byte [ss:FastOpenFlg], 8
		jnz	short NOLOOK
		mov	bx, FastOpenTable
		mov	si, [ss:WFP_START]
		mov	di, Dir_Info_Buff
		mov	cx, FastOpen_Ext_Info
		mov	al, 1
		push	ds
		pop	es
		call	far [bx+2]
		jb	short NOTFOUND
		lea	bx, [si-2]
		cmp	bx, [ss:WFP_START]
		jz	short NOTFOUND
		cmp	byte [si], 0
		jnz	short parfnd
		push	cx
		mov	cl, [ss:ATTRIB]
		mov	ch, [ss:SATTRIB]
		mov	byte [ss:ATTRIB], ch
		mov	ch, [es:di+0Bh]
		call	MatchAttributes
		pop	cx
		jnz	short NOLOOKUP

parfnd:					; ...
		mov	[ss:Next_Element_Start], si
		mov	bx, cx
		mov	ax, [bx+7]
		mov	word [ss:LASTENT], ax
		mov	ax, [bx+9]
		mov	word [ss:DIRSTART], ax
		mov	ax, [bx+5]
		mov	[ss:CLUSNUM], ax
		push	es
		les	bx, [ss:THISDPB]
		mov	ah, [es:bx]
		pop	es
		mov	word [ss:CURBUF], 0
		mov	word [ss:CURBUF+2], es
		mov	bx, di
		lea	si, [di+1Ah]
		or	byte [ss:FastOpenFlg], 12h
		retn
; ---------------------------------------------------------------------------

NOTFOUND:				; ...
		cmp	ax, 0FFFFh
		jnz	short Partial_Success
		mov	byte [ss:FastOpenFlg], 0

Partial_Success:			; ...
		and	byte [ss:FastOpenFlg], 0FBh

NOLOOKUP:				; ...
		stc
		retn

; =============== S U B	R O U T	I N E =======================================


InsertPath:
		pushf
		test	byte [ss:FastOpenFlg], 1
		jz	short GET_NEXT_ELEMENT
		test	byte [ss:FastOpenFlg], 2
		jz	short INSERT_DIR_INFO
		and	byte [ss:FastOpenFlg], 0FDh
		mov	di, [ss:Next_Element_Start]
		jmp	short GET_NEXT2
; ---------------------------------------------------------------------------

INSERT_DIR_INFO:
		push	ds
		push	es
		push	bx
		push	si
		push	di
		push	cx
		push	ax
		lds	di, [ss:CURBUF]
		mov	si, FastOpen_Ext_Info
		mov	ax, [di+6]
		mov	[ss:si+1], ax
		mov	ax, [di+8]
		push	ss
		pop	ds
		mov	[si+3],	ax
		mov	ax, [CLUSNUM]
		mov	[si+5],	ax
		mov	ax, [LASTENT]
		mov	[si+7],	ax
		mov	ax, [DIRSTART]
		mov	[si+9],	ax
		mov	ax, bx
		add	di, 20
		sub	ax, di
		mov	cl, 32
		div	cl
		mov	[si], al
		push	ds
		pop	es
		mov	ds, word [CURBUF+2]
		mov	di, bx
		cmp	word [di+1Ah], 0
		jz	short SKIP_INSERT
		push	si
		pop	bx
		mov	al, 2
		mov	si, FastOpenTable
		call	far [es:si+2]
		clc

SKIP_INSERT:
		pop	ax
		pop	cx
		pop	di
		pop	si
		pop	bx
		pop	es
		pop	ds

GET_NEXT2:
		or	byte [ss:FastOpenFlg], 8

GET_NEXT_ELEMENT:
		popf
		retn

; ---------------------------------------------------------------------------
LenTab:		db 22, 14, 22, 13, 15, 14 ; ...
CmdTab:		db 86h,	4		; ...
		db 86h,	5
		db 87h,	8
		db 87h,	0Ah
		db 86h,	7
		db 86h,	5

; =============== S U B	R O U T	I N E =======================================


IOFUNC:
		mov	word [ss:IOXAD+2], ss
		mov	word [ss:IOXAD], DEVIOBUF
		mov	word [ss:IOSCNT], 1
		mov	[ss:DEVIOBUF], ax
		test	byte [si+6], 80h
		jz	short IOTO22
		jmp	IOTOFILE
; ---------------------------------------------------------------------------

IOTO22:					; ...
		test	byte [si+5], 80h
		jnz	short IOTO33
		jmp	IOTOFILE
; ---------------------------------------------------------------------------

IOTO33:					; ...
		push	es
		call	save_world
		mov	dx, ds
		mov	bx, ss
		mov	ds, bx
		mov	es, bx
		xor	bx, bx
		cmp	ah, 5
		jnz	short _no_sys_wait
		or	bx, 400h

_no_sys_wait:				; ...
		mov	[IOCALL_REQSTAT], bx
		xor	bx, bx
		mov	byte [IOMED], bl
		mov	bl, ah
		mov	ah, [cs:LenTab+bx]
		shl	bx, 1
		mov	cx, word [cs:CmdTab+bx]
		mov	bx, IOCALL
		mov	byte [IOCALL], ah
		mov	byte [IOCALL_REQFUNC], ch
		mov	ds, dx
		call	DEVIOCALL
		mov	di, [ss:IOCALL_REQSTAT]
		and	di, di
		js	short DevErr

OKDevIO:				; ...
		mov	ax, ss
		mov	ds, ax
		cmp	ch, 5
		jnz	short DNODRD
		mov	al, [IOMED]
		mov	byte [DEVIOBUF], al

DNODRD:					; ...
		mov	ah, byte [IOCALL_REQSTAT+1]
		not	ah
		and	ah, 2

QuickReturn:
		call	restore_world
		pop	es
		pushf
		mov	al, [ss:IoStatFail]
		cbw
		cmp	ax, 0FFFFh
		jnz	short not_fail_ret
		inc	byte [ss:IoStatFail]
		popf
		retn
; ---------------------------------------------------------------------------

not_fail_ret:				; ...
		mov	ax, [ss:DEVIOBUF]
		popf
		retn
; ---------------------------------------------------------------------------

DevErr:					; ...
		mov	ah, cl
		call	CHARHARD
		cmp	al, 1
		jnz	short NO_RETRY
		call	restore_world
		pop	es
		jmp	IOFUNC
; ---------------------------------------------------------------------------

NO_RETRY:				; ...
		and	byte [ss:IOCALL_REQSTAT+1], 0FDh
		cmp	al, 3
		jnz	short not_fail
		dec	byte [ss:IoStatFail]

not_fail:				; ...
		jmp	short OKDevIO
; ---------------------------------------------------------------------------

IOTOFILE:				; ...
		or	ah, ah
		jz	short IOIN
		dec	ah
		jz	short IOIST
		dec	ah
		jz	short IOUT
		retn
; ---------------------------------------------------------------------------

IOIST:					; ...
		push	word [si+15h]
		push	word [si+17h]
		call	IOIN
		pop	word [si+17h]
		pop	word [si+15h]
		retn
; ---------------------------------------------------------------------------

IOUT:					; ...
		call	SETXADDR
		call	DOS_WRITE
		call	RESTXADDR

IOUT_retn:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================


IOIN:
		call	SETXADDR
		or	word [ss:DOS34_FLAG], 40h
		call	DOS_READ
		and	word [ss:DOS34_FLAG], 0FFBFh
		or	cx, cx
		call	RESTXADDR
		mov	al, byte [ss:DEVIOBUF]
		jnz	short IOUT_retn
		mov	al, 1Ah
		retn

; =============== S U B	R O U T	I N E =======================================


SETXADDR:
		pop	word [ss:CALLBPB]
		push	es
		call	save_world
		push	word [ss:DMAADD]
		push	word [ss:DMAADD+2]
		mov	word [ss:THISSFT+2], ds
		push	ss
		pop	ds
		mov	word [THISSFT], si
		mov	cx, word [IOXAD+2]
		mov	word [DMAADD+2], cx
		mov	cx, word [IOXAD]
		mov	word [DMAADD], cx
		mov	cx, [IOSCNT]
		jmp	short RESTRET

; =============== S U B	R O U T	I N E =======================================


RESTXADDR:
		pop	word [CALLBPB]
		pop	word [DMAADD+2]
		pop	word [DMAADD]
		call	restore_world
		pop	es

RESTRET:				; ...
		jmp	word [ss:CALLBPB]

; =============== S U B	R O U T	I N E =======================================


DEV_OPEN_SFT:
		push	es
		call	save_world
		mov	al, 0Dh
		jmp	short DO_OPCLS

; =============== S U B	R O U T	I N E =======================================


DEV_CLOSE_SFT:
		push	es
		call	save_world
		mov	al, 0Eh

DO_OPCLS:				; ...
		test	byte [es:di+6], 80h
		jnz	short OPCLS_DONE
		xor	ah, ah
		test	byte [es:di+5], 80h
		les	di, [es:di+7]
		jnz	short GOT_DEV_ADDR
		cmp	byte [ss:fShare], 1
		jbe	short OPCLS_DONE
		mov	ah, [es:di+1]
		mov	cl, [es:di]
		les	di, [es:di+13h]

GOT_DEV_ADDR:				; ...
		test	byte [es:di+5], 8
		jz	short OPCLS_DONE
		push	es
		pop	ds
		mov	si, di

OPCLS_RETRY:				; ...
		push	ss
		pop	es
		mov	di, DEVCALL
		mov	bx, di
		push	ax
		mov	al, 13
		stosb
		pop	ax
		xchg	ah, al
		stosb
		xchg	ah, al
		stosb
		mov	word [es:di], 0
		push	ax
		call	DEVIOCALL2
		mov	di, [es:bx+3]
		and	di, di
		jns	short OPCLS_DONEP
		test	byte [si+5], 80h
		jz	short BLKDEV
		mov	ah, 86h
		jmp	short HRDERR
; ---------------------------------------------------------------------------

BLKDEV:					; ...
		mov	al, cl
		mov	ah, 6

HRDERR:					; ...
		call	CHARHARD
		cmp	al, 1
		jnz	short OPCLS_DONEP
		pop	ax
		jmp	short OPCLS_RETRY
; ---------------------------------------------------------------------------

OPCLS_DONEP:				; ...
		pop	ax

OPCLS_DONE:				; ...
		call	restore_world
		pop	es
		retn

; =============== S U B	R O U T	I N E =======================================


DEVIOCALL:
		lds	si, [si+7]

; =============== S U B	R O U T	I N E =======================================


DEVIOCALL2:
		call	ECritDevice
		test	byte [si+5], 80h
		jnz	short chardev2
		cmp	byte [es:bx+2], 4
		jz	short chkext
		cmp	byte [es:bx+2], 8
		jz	short chkext
		cmp	byte [es:bx+2], 9
		jnz	short chardev2

chkext:					; ...
		call	RW_SC
		jb	short dev_exit
		test	byte [si+4], 2
		jz	short chksector
		add	byte [es:bx], 8
		mov	ax, word [ss:CALLBPB+2]
		mov	word [ss:CALLBPB+2], 0FFFFh
		mov	word [ss:CALLNEWSC], ax
		mov	ax, [ss:HIGH_SECTOR]
		mov	word [ss:CALLNEWSC+2], ax
		jmp	short chardev2
; ---------------------------------------------------------------------------

chksector:				; ...
		cmp	word [ss:HIGH_SECTOR], 0
		jz	short chardev2
		mov	word [es:bx+3], 8107h
		jmp	short dev_exit
; ---------------------------------------------------------------------------

chardev2:				; ...
		mov	ax, [si+6]
		mov	word [ss:CALLDEVAD], ax
		mov	word [ss:CALLDEVAD+2], ds
		call	far [ss:CALLDEVAD]
		mov	ax, [si+8]
		mov	word [ss:CALLDEVAD], ax
		call	far [ss:CALLDEVAD]
		call	VIRREAD
		jb	short chardev2

dev_exit:				; ...
		call	LCritDevice
		retn

; =============== S U B	R O U T	I N E =======================================


SETREAD	:
		push	di
		push	cx
		push	ax
		mov	cl, 4

SETCALLHEAD:				; ...
		mov	al, 16h
		push	ss
		pop	es
		mov	di, DEVCALL
		stosb
		pop	ax
		stosb
		push	ax
		mov	al, cl
		stosb
		xor	ax, ax
		stosw
		add	di, 8
		pop	ax
		xchg	ah, al
		stosb
		xchg	al, ah
		push	ax
		mov	ax, bx
		stosw
		mov	ax, ds
		stosw
		pop	cx
		pop	ax
		stosw
		xchg	ax, dx
		stosw
		xchg	ax, cx
		xchg	dx, cx
		pop	di
		mov	bx, DEVCALL
		retn

; =============== S U B	R O U T	I N E =======================================


SETWRITE:
		push	di
		push	cx
		push	ax
		mov	cl, 8
		add	cl, [ss:VERFLG]
		jmp	short SETCALLHEAD

; =============== S U B	R O U T	I N E =======================================


RW_SC	:
		cmp	word [ss:SC_CACHE_COUNT], 0
		jz	short scexit4
		cmp	word [ss:CALLBPB], 1
		jnz	short scexit4
		push	cx
		push	dx
		push	ds
		push	si
		push	es
		push	di
		mov	dx, word [ss:CALLBPB+2]
		cmp	byte [ss:DEVCALL_REQFUNC], 4
		jz	short doread
		call	INVALIDATE_SC
		jmp	scexit2
; ---------------------------------------------------------------------------

scexit4:				; ...
		clc
		retn
; ---------------------------------------------------------------------------

doread:					; ...
		call	SC2BUF
		jb	short readSC
		mov	word [ss:DEVCALL_REQSTAT], 100h
		stc
		jmp	short saveseq
; ---------------------------------------------------------------------------

readSC:					; ...
		mov	ax, [ss:HIGH_SECTOR]
		mov	cx, word [ss:CALLBPB+2]
		sub	cx, [ss:SEQ_SECTOR]
		sbb	ax, [ss:SEQ_SECTOR+2]
		cmp	ax, 0
		jnz	short saveseq2

chklow:
		cmp	cx, 1
		ja	short saveseq2
		mov	word [ss:SC_STATUS], 0FFFFh
		mov	ax, [ss:SC_CACHE_COUNT]
		mov	word [ss:CALLBPB], ax	; [ss:CALLSCNT]

readsr:
		mov	ax, word [ss:CALLBR+2]
		mov	[ss:TEMP_VAR2], ax
		mov	ax, word [ss:CALLBR]
		mov	[ss:TEMP_VAR], ax
		mov	ax, word [ss:SC_CACHE_PTR]
		mov	word [ss:CALLBR], ax
		mov	ax, word [ss:SC_CACHE_PTR+2]
		mov	word [ss:CALLBR+2], ax
		mov	byte [ss:SC_FLAG], 1
		mov	al, [ss:SC_DRIVE]
		mov	byte [ss:CurSC_DRIVE], al
		mov	ax, word [ss:CALLBPB+2]
		mov	[ss:CurSC_SECTOR], ax
		mov	ax, [ss:HIGH_SECTOR]
		mov	[ss:CurSC_SECTOR+2], ax

saveseq2:				; ...
		clc

saveseq:				; ...
		mov	ax, [ss:HIGH_SECTOR]
		mov	[ss:SEQ_SECTOR+2], ax
		mov	ax, word [ss:CALLBPB+2]
		mov	[ss:SEQ_SECTOR], ax
		jmp	short scexit
; ---------------------------------------------------------------------------

scexit2:				; ...
		clc

scexit:					; ...
		pop	di
		pop	es
		pop	si
		pop	ds
		pop	dx
		pop	cx
		retn

; =============== S U B	R O U T	I N E =======================================


IN_SC:
		mov	al, [ss:SC_DRIVE]
		cmp	al, [ss:CurSC_DRIVE]
		jnz	short outrange2
		mov	ax, [ss:HIGH_SECTOR]
		mov	cx, dx
		sub	cx, [ss:CurSC_SECTOR]
		sbb	ax, [ss:CurSC_SECTOR+2]
		cmp	ax, 0
		jnz	short outrange2
		cmp	cx, [ss:SC_CACHE_COUNT]
		jnb	short outrange2
		clc
		jmp	short inexit
; ---------------------------------------------------------------------------

outrange2:				; ...
		stc

inexit:					; ...
		retn

; =============== S U B	R O U T	I N E =======================================


INVALIDATE_SC:
		call	IN_SC
		jb	short outrange
		mov	ax, 1
		shl	ax, cl
		not	ax
		and	word [ss:SC_STATUS], ax

outrange:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================


VIRREAD	:
		cmp	byte [ss:SC_FLAG], 0
		jz	short sc2end
		mov	ax, [ss:TEMP_VAR2]
		mov	word [ss:CALLBR+2], ax
		mov	ax, [ss:TEMP_VAR]
		mov	word [ss:CALLBR], ax
		mov	byte [ss:SC_FLAG], 0
		mov	word [ss:CALLBPB], 1 ; [ss:CALLSCNT]
		test	byte [ss:DEVCALL_REQSTAT+1], 80h
		jnz	short scerror
		push	ds
		push	si
		push	es
		push	di
		push	dx
		push	cx
		xor	cx, cx
		call	SC2BUF2
		pop	cx
		pop	dx
		pop	di
		pop	es
		pop	si
		pop	ds
		jmp	short sc2end
; ---------------------------------------------------------------------------

scerror:				; ...
		mov	word [ss:CALLBPB], 1
		mov	word [ss:SC_STATUS], 0
		mov	byte [ss:CurSC_DRIVE], 0FFh
		stc
		retn
; ---------------------------------------------------------------------------

sc2end:					; ...
		clc
		retn

; =============== S U B	R O U T	I N E =======================================


SC2BUF:
		call	IN_SC
		jb	short noSC
		mov	ax, 1
		shl	ax, cl
		test	word [ss:SC_STATUS], ax
		jz	short noSC

SC2BUF2:				; ...
		mov	ax, cx
		mul	word [ss:SC_SECTOR_SIZE]
		add	ax, word [ss:SC_CACHE_PTR]
		adc	dx, word [ss:SC_CACHE_PTR+2]
		mov	ds, dx
		mov	si, ax
		mov	es, word [ss:CALLBR+2]
		mov	di, word [ss:CALLBR]
		mov	cx, [ss:SC_SECTOR_SIZE]
		shr	cx, 1

MOVWORDS:
		cmp	byte [ss:DDMOVE], 0
		jz	short nodd
		shr	cx, 1
; ---------------------------------------------------------------------------
		db 66h			; 80386, 32 bit	op prefix
; ---------------------------------------------------------------------------

nodd:					; ...
		rep movsw
		clc
		retn
; ---------------------------------------------------------------------------

noSC:					; ...
		stc
		retn

; =============== S U B	R O U T	I N E =======================================


BUILDDIR:
		mov	ax, [ENTFREE]
		cmp	ax, 0FFFFh
		jz	short CHECK_IF_ROOT
		clc
		retn
; ---------------------------------------------------------------------------

CHECK_IF_ROOT:				; ...
		cmp	word [DIRSTART], 0
		jnz	short NEWDIR
		stc

builddir_retn:				; ...
		retn
; ---------------------------------------------------------------------------

NEWDIR:					; ...
		mov	bx, [DIRSTART]
		or	bx, bx
		jz	short NULLDIR
		call	GETEOF
		jb	short builddir_retn

NULLDIR:				; ...
		mov	cx, 1
		call	ALLOCATE
		jb	short builddir_retn
		mov	dx, [DIRSTART]
		or	dx, dx
		jnz	short ADDINGDIR
		call	SETDIRSRCH
		jb	short builddir_retn
		mov	word [LASTENT], 0FFFFh
		jmp	short GOTDIRREC
; ---------------------------------------------------------------------------

ADDINGDIR:				; ...
		push	bx
		mov	bx, [CLUSNUM]
		call	IsEOF
		pop	bx
		jb	short NOTFIRSTGROW
		mov	[CLUSNUM], bx
		push	cx
		push	ax
		push	bp
		mov	ah, 1
		mov	dl, [es:bp+0]
		mov	cx, [DIRSTART]
		mov	bp, bx
		call	FastOpen_Update
		pop	bp
		pop	ax
		pop	cx

NOTFIRSTGROW:				; ...
		mov	dx, bx
		xor	bl, bl
		call	FIGREC

GOTDIRREC:				; ...
		mov	cl, [es:bp+4]
		inc	cl
		xor	ch, ch

ZERODIR:				; ...
		push	cx
		mov	byte [ALLOWED], 18h
		mov	al, 0FFh
		call	GETBUFFR
		jnb	short GET_SSIZE
		pop	cx
		retn
; ---------------------------------------------------------------------------

GET_SSIZE:				; ...
		mov	cx, [es:bp+2]
		push	es
		les	di, [CURBUF]
		or	byte [es:di+5], 4
		push	di
		add	di, 20
		xor	ax, ax
		shr	cx, 1
		rep stosw
		jnb	short EVENZ
		stosb

EVENZ:					; ...
		pop	di
		test	byte [es:di+5], 40h
		jnz	short yesdirty7
		call	INC_DIRTY_COUNT
		or	byte [es:di+5], 40h

yesdirty7:				; ...
		pop	es
		pop	cx
		add	dx, 1
		adc	word [HIGH_SECTOR],	0
		loop	ZERODIR
		mov	ax, [LASTENT]
		inc	ax
		clc
		retn

; =============== S U B	R O U T	I N E =======================================


SETDOTENT:
		stosw
		mov	cx, 4
		mov	ax, 2020h
		rep stosw
		stosb
		mov	al, 10h
		stosb
		add	di, 10
		mov	si, word [THISSFT]
		mov	ax, [si+0Dh]
		stosw
		mov	ax, [si+0Fh]
		stosw
		mov	ax, dx
		stosw
		xor	ax, ax
		stosw
		stosw
		retn

; =============== S U B	R O U T	I N E =======================================


MakeNode:
		mov	word [CREATING], 0E5FFh
		push	ax
		mov	byte [NoSetDir], 0
		mov	byte [SATTRIB], al
		call	GetPathNoSet
		mov	dl, cl
		mov	cx, ax
		pop	ax
		jnb	short make_exists
		jnz	short make_err_4
		cmp	dl, 80h
		jz	short RENAME_MAKE

make_err_4:				; ...
		mov	al, 4

make_err_ret:				; ...
		xor	ah, ah
		stc
		retn
; ---------------------------------------------------------------------------

RENAME_MAKE:				; ...
		test	byte [EXTOPEN_ON], 1
		jz	short make_type2
		or	byte [EXTOPEN_ON], 4
		test	byte [EXTOPEN_FLAG], 0F0h
		jnz	short make_type2
		stc
		mov	ax, 7

make_retn:				; ...
		retn
; ---------------------------------------------------------------------------

make_type2:				; ...
		les	di, [THISSFT]
		xor	ax, ax
		stc
		jmp	short make_new
; ---------------------------------------------------------------------------

make_exists:				; ...
		jz	short make_exists_dir
		mov	al, 3
		test	byte [ATTRIB], 18h
		jnz	short make_err_ret_5
		or	ch, ch
		js	short make_share
		or	ah, ah
		jnz	short make_err_ret
		push	cx
		mov	es, word [CURBUF+2]
		mov	ch, [es:bx+0Bh]
		test	ch, 1
		jnz	short make_err_ret_5P
		call	MatchAttributes
		pop	cx
		jnz	short make_err_ret_5
		xor	al, al

make_share:				; ...
		xor	ah, ah
		push	ax
		push	cx
		mov	ah, ch
		call	DOOPEN
		les	di, [THISSFT]
		push	si
		push	bx
		call	ShareEnter
		jnb	short MakeEndShare
		pop	bx
		pop	si
		pop	cx
		pop	ax

Make_Share_ret:				; ...
		mov	al, 6
		jmp	short make_err_ret
; ---------------------------------------------------------------------------

make_err_ret_5P:			; ...
		pop	cx

make_err_ret_5:				; ...
		mov	al, 5
		jmp	short make_err_ret
; ---------------------------------------------------------------------------

make_exists_dir:			; ...
		mov	al, 1
		jmp	short make_err_ret
; ---------------------------------------------------------------------------

make_save:				; ...
		push	ax
		mov	ax, cx
		call	NEWENTRY
		pop	ax
		jnb	short make_retn
		mov	al, 2

make_save_retn:				; ...
		retn
; ---------------------------------------------------------------------------

make_new:				; ...
		call	make_save
		jb	short make_save_retn
		test	byte [ATTRIB], 10h
		jnz	short make_save_retn
		push	ax
		push	bx
		push	si
		call	ShareEnter
		pop	si
		pop	bx
		pop	ax
		jnb	short make_save_retn
		push	ax
		les	di, [CURBUF]
		mov	byte [es:bx], 0E5h
		test	byte [es:di+5], 40h
		jnz	short yesdirty8
		call	INC_DIRTY_COUNT
		or	byte [es:di+5], 40h

yesdirty8:				; ...
		les	bp, [THISDPB]
		mov	al, [es:bp+0]
		call	FLUSHBUF
		pop	ax
		jmp	short Make_Share_ret
; ---------------------------------------------------------------------------

MakeEndShare:				; ...
		les	di, [THISSFT]
		xor	ax, ax
		call	ECritDisk
		xchg	ax, [es:di]
		push	ax
		push	di
		push	es
		pushf
		call	ShareEnd
		popf
		pop	es
		pop	di
		pop	word [es:di]
		call	LCritDisk
		pop	bx
		pop	si
		pop	cx
		pop	ax
		call	make_save
		jb	short make_save_retn
		push	ax
		push	bx
		push	si
		pushf
		call	ShareEnter
		popf
		pop	si
		pop	bx
		pop	ax

makeendshare_retn:			; ...
		retn

; =============== S U B	R O U T	I N E =======================================


NEWENTRY:
		les	bp, [THISDPB]
		jnb	short EXISTENT
		cmp	byte [FAILERR], 0
		stc
		jnz	short makeendshare_retn
		call	BUILDDIR
		jb	short makeendshare_retn
		call	GETENT
		jb	short makeendshare_retn
		jmp	short FREESPOT
; ---------------------------------------------------------------------------

ERRRET3:				; ...
		stc

newentry_retn:				; ...
		retn
; ---------------------------------------------------------------------------

EXISTENT:				; ...
		or	ah, ah
		jns	short NOT_DEV1
		jmp	DOOPEN
; ---------------------------------------------------------------------------

NOT_DEV1:				; ...
		call	FREEENT
		jb	short newentry_retn

FREESPOT:				; ...
		test	byte [ATTRIB], 8
		jz	short NOTVOLID
		cmp	byte [VOLID], 0
		jnz	short ERRRET3

NOTVOLID:				; ...
		mov	es, word [CURBUF+2]
		mov	di, bx
		mov	si, NAME1
		mov	cx, 5
		rep movsw
		movsb
		mov	al, [ATTRIB]
		stosb
		mov	cl, 5
		xor	ax, ax
		rep stosw
		call	DATE16
		xchg	ax, dx
		stosw
		xchg	ax, dx
		stosw
		xor	ax, ax
		push	di
		stosw
		stosw
		stosw
		mov	si, word [CURBUF]
		test	byte [es:si+5], 40h
		jnz	short yesdirty9
		call	INC_DIRTY_COUNT
		or	byte [es:si+5], 40h

yesdirty9:				; ...
		les	bp, [THISDPB]
		mov	al, [es:bp+0]
		push	ax
		push	bx
		push	es
		push	di
		les	di, [THISSFT]
		test	byte [es:di+5], 80h
		jnz	short GotADevice
		push	ds
		push	bx
		lds	bx, [THISDPB]
		mov	[es:di+7], bx
		mov	bx, ds
		mov	[es:di+9], bx
		pop	bx
		pop	ds
		call	DEV_OPEN_SFT
		mov	byte [VIRTUAL_OPEN], 1

GotADevice:				; ...
		pop	di
		pop	es
		call	FLUSHBUF
		call	CHECK_VIRT_OPEN
		pop	bx
		pop	ax
		pop	si
		mov	ah, al
		jnb	short DOOPEN
		retn

; =============== S U B	R O U T	I N E =======================================


DOOPEN:
		mov	dh, ah
		les	di, [THISSFT]
		add	di, 4
		xor	al, al
		or	dh, dh
		js	short DEV_SFT1
		mov	ds, word [CURBUF+2]
		mov	al, [bx+0Bh]

DEV_SFT1:				; ...
		stosb
		xor	ax, ax
		mov	al, dh
		or	al, 40h
		stosw
		push	ds
		lds	ax, [bx+1Ah]
		or	dh, dh
		js	short DEV_SFT2
		lds	ax, [ss:THISDPB]

DEV_SFT2:				; ...
		stosw
		mov	ax, ds
		pop	ds
		stosw
		push	si
		movsw
		sub	si, 6
		movsw
		movsw
		lodsw
		lodsw
		mov	cx, ax
		lodsw
		or	dh, dh
		jns	short FILE_SFT1
		xor	ax, ax
		mov	cx, ax

FILE_SFT1:				; ...
		xchg	ax, cx
		stosw
		xchg	ax, cx
		stosw
		xor	ax, ax
		stosw
		stosw
		or	dh, dh
		js	short DEV_SFT3
		stosw
		mov	ax, [bx+1Ah]
		push	di
		sub	di, 1Bh		; SF_ENTRY.sf_dirsec
		mov	[es:di+35h], ax
		pop	di
		push	ds
		push	ss
		pop	ds
		test	byte [FastOpenFlg],	4
		jz	short Not_FastOpen
		mov	si, FastOpen_Ext_Info
		mov	ax, [si+1]
		stosw
		mov	ax, [si+3]
		stosw
		mov	al, [si]
		stosb
		pop	ds
		jmp	short Next_Name
; ---------------------------------------------------------------------------

Not_FastOpen:				; ...
		pop	ds
		mov	si, word [ss:CURBUF]
		mov	ax, [si+6]
		stosw
		mov	ax, [si+8]
		stosw
		mov	ax, bx
		add	si, 20
		sub	ax, si
		mov	cl, 32
		div	cl
		stosb

Next_Name:				; ...
		jmp	short FILE_SFT2
; ---------------------------------------------------------------------------

DEV_SFT3:				; ...
		add	di, 7

FILE_SFT2:				; ...
		mov	si, bx
		mov	cx, 11
		rep movsb
		pop	si
		push	ss
		pop	ds
		clc
		retn

; =============== S U B	R O U T	I N E =======================================


FREEENT:
		push	ds
		lds	di, [CURBUF]
		mov	cx, [si]
		mov	dx, [di+8]
		mov	word [ss:HIGH_SECTOR], dx
		mov	dx, [di+6]
		pop	ds
		cmp	cx, 2
		jb	short RET1
		cmp	cx, [es:bp+0Dh]
		ja	short RET1
		sub	bx, di
		push	bx
		push	word [HIGH_SECTOR]
		push	dx
		mov	bx, cx
		call	RELEASE
		pop	dx
		pop	word [HIGH_SECTOR]
		jnb	short GET_BUF_BACK
		pop	bx

freeent_retn:				; ...
		retn
; ---------------------------------------------------------------------------

GET_BUF_BACK:				; ...
		mov	byte [ALLOWED], 18h
		xor	al, al
		call	GETBUFFR
		pop	bx
		jb	short freeent_retn
		call	SET_BUF_AS_DIR
		add	bx, word [CURBUF]
		mov	si, bx
		add	si, 1Ah

RET1:					; ...
		clc
		retn

; =============== S U B	R O U T	I N E =======================================


CHECK_VIRT_OPEN:
		push	ax
		lahf
		cmp	byte [VIRTUAL_OPEN], 0
		jz	short ALL_CLOSED
		mov	byte [VIRTUAL_OPEN], 0
		push	es
		push	di
		les	di, [THISSFT]
		call	DEV_CLOSE_SFT
		pop	di
		pop	es

ALL_CLOSED:				; ...
		sahf
		pop	ax
		retn

; =============== S U B	R O U T	I N E =======================================


FNDCLUS:
		push	es
		les	di, [THISSFT]
		mov	bx, [es:di+35h]
		mov	dx, [es:di+19h]
		or	bx, bx
		jz	short NOCLUS
		sub	cx, dx
		jnb	short FINDIT
		add	cx, dx
		xor	dx, dx
		mov	bx, [es:di+0Bh]

FINDIT:					; ...
		pop	es
		jcxz	RET9

SKPCLP:					; ...
		call	UNPACK
		jb	short fndclus_retn
		xchg	bx, di
		call	IsEOF
		xchg	bx, di
		jnb	short RET9
		xchg	bx, di
		inc	dx
		loop	SKPCLP

RET9:					; ...
		clc
		retn
; ---------------------------------------------------------------------------

NOCLUS:					; ...
		pop	es
		inc	cx
		dec	dx
		clc

fndclus_retn:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================


BUFSEC:
		mov	dx, [CLUSNUM]
		mov	bl, [SECCLUSPOS]
		mov	byte [ALLOWED], 38h
		call	FIGREC
		call	GETBUFFR
		jb	short fndclus_retn
		mov	byte [TRANS], 1
		mov	si, [NEXTADD]
		mov	di, si
		mov	cx, [BYTCNT1]
		add	di, cx
		mov	[NEXTADD], di
		les	di, [CURBUF]
		or	byte [es:di+5], 8
		lea	di, [di+20]
		add	di, [BYTSECPOS]
		clc
		retn

; =============== S U B	R O U T	I N E =======================================


BUFRD:
		push	es
		xor	ax, ax
		call	BUFSEC
		jnb	short BUF_OK

BUF_IO_FAIL:				; ...
		pop	es
		jmp	short RBUFPLACED
; ---------------------------------------------------------------------------

BUF_OK:					; ...
		mov	bx, es
		mov	es, word [DMAADD+2]
		mov	ds, bx
		xchg	di, si
		shr	cx, 1
		rep movsw
		adc	cx, 0
		rep movsb
		pop	es
		lds	di, [ss:CURBUF]
		lea	bx, [di+20]
		sub	si, bx
		call	PLACEBUF
		cmp	si, [es:bp+2]
		jb	short RBUFPLACEDC
		mov	word [ss:BufferQueue], di

RBUFPLACEDC:				; ...
		clc

RBUFPLACED:				; ...
		push	ss
		pop	ds
		retn

; =============== S U B	R O U T	I N E =======================================


BUFWRT:
		mov	ax, [SECPOS]
		add	ax, 1
		mov	[SECPOS], ax
		adc	word [SECPOS+2], 0
		mov	ax, [SECPOS+2]
		cmp	ax, [VALSEC+2]
		mov	al, 1
		ja	short NOREAD
		jb	short _doread
		mov	ax, [SECPOS]
		cmp	ax, [VALSEC]
		mov	al, 1
		ja	short NOREAD

_doread:				; ...
		xor	al, al

NOREAD:					; ...
		push	es
		call	BUFSEC
		jb	short BUF_IO_FAIL
		mov	ds, word [DMAADD+2]
		shr	cx, 1
		rep movsw
		adc	cx, 0
		rep movsb
		pop	es
		lds	bx, [ss:CURBUF]
		test	byte [bx+5], 40h
		jnz	short yesdirty10
		call	INC_DIRTY_COUNT
		or	byte [bx+5], 40h

yesdirty10:				; ...
		lea	si, [bx+20]
		sub	di, si
		cmp	di, [es:bp+2]
		jb	short WBUFPLACED
		mov	word [ss:BufferQueue], bx

WBUFPLACED:				; ...
		clc
		push	ss
		pop	ds
		retn

; =============== S U B	R O U T	I N E =======================================


NEXTSEC:
		test	byte [TRANS], 0FFh
		jz	short CLRET
		mov	al, [SECCLUSPOS]
		inc	al
		cmp	al, [es:bp+4]
		jbe	short SAVPOS
		mov	bx, [CLUSNUM]
		call	IsEOF
		jnb	short NONEXT
		call	UNPACK
		jb	short NONEXT
		mov	[CLUSNUM], di
		inc	word [LASTPOS]
		mov	al, 0

SAVPOS:					; ...
		mov	[SECCLUSPOS], al

CLRET:					; ...
		clc
		retn
; ---------------------------------------------------------------------------

NONEXT:					; ...
		stc
		retn

; =============== S U B	R O U T	I N E =======================================


OPTIMIZE:
		push	dx
		push	bx
		mov	al, [es:bp+4]
		inc	al
		mov	ah, al
		sub	al, dl
		mov	dx, cx
		mov	cx, 0

OPTCLUS:				; ...
		call	UNPACK
		jb	short OP_ERR
		add	cl, al
		adc	ch, 0
		cmp	cx, dx
		jnb	short BLKDON
		mov	al, ah
		inc	bx
		cmp	di, bx
		jz	short OPTCLUS
		dec	bx

FINCLUS:				; ...
		mov	[CLUSNUM], bx
		sub	dx, cx
		push	dx
		mov	ax, cx
		mul	word [es:bp+2]
		mov	si, [NEXTADD]
		add	ax, si
		mov	[NEXTADD], ax
		pop	ax
		pop	dx
		sub	bx, dx
		add	word [LASTPOS], bx
		pop	bx
		call	FIGREC
		mov	bx, si
		clc
		retn
; ---------------------------------------------------------------------------

OP_ERR:					; ...
		add	sp, 4
		stc
		retn
; ---------------------------------------------------------------------------

BLKDON:					; ...
		sub	cx, dx
		sub	ah, cl
		dec	ah
		mov	[SECCLUSPOS], ah
		mov	cx, dx
		jmp	short FINCLUS

; =============== S U B	R O U T	I N E =======================================


FIGREC:
		push	cx
		mov	cl, [es:bp+5]
		dec	dx
		dec	dx
		mov	word [ss:HIGH_SECTOR], 0
		or	cl, cl
		jz	short noshift
		xor	ch, ch

rotleft:				; ...
		clc
		rcl	dx, 1
		rcl	word [ss:HIGH_SECTOR], 1
		loop	rotleft

noshift:				; ...
		or	dl, bl
		add	dx, [es:bp+0Bh]
		adc	word [ss:HIGH_SECTOR], 0
		pop	cx

figrec_retn:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================

callmagic:
		push	ds
		push	word [ss:OffsetMagicPatch]
		retf

; =============== S U B	R O U T	I N E =======================================


ALLOCATE:
		clc
		push	cs
		call	callmagic
		jnb	short Regular_Allocate_Path
		jmp	Disk_Full_Return
; ---------------------------------------------------------------------------

Regular_Allocate_Path:			; ...
		push	bx
		xor	bx, bx
		call	UNPACK
		mov	[FATBYT], di
		pop	bx
		jb	short figrec_retn
		push	cx
		push	bx
		mov	dx, bx
		mov	bx, [es:bp+1Dh]
		cmp	bx, 2
		ja	short FINDFRE

ads1:					; ...
		mov	word [es:bp+1Dh], 2
		mov	bx, 1

FINDFRE:				; ...
		inc	bx
		cmp	bx, [es:bp+0Dh]
		ja	short ads7
		call	UNPACK
		jb	short ads4
		jnz	short FINDFRE
		mov	[es:bp+1Dh], bx
		xchg	ax, dx
		mov	dx, 1
		call	PACK
		jb	short ads4
		cmp	word [es:bp+1Fh], 0FFFFh
		jz	short NO_ALLOC
		dec	word [es:bp+1Fh]

NO_ALLOC:				; ...
		xchg	ax, dx
		xchg	bx, dx
		mov	ax, dx
		call	PACK
		jb	short ads4
		xchg	ax, bx
		mov	dx, bx
		loop	FINDFRE
		mov	dx, 0FFFFh
		call	PACK

ads4:					; ...
		pop	bx
		pop	cx
		jb	short figrec_retn
		call	UNPACK
		jb	short figrec_retn
		call	RESTFATBYT
		jb	short figrec_retn
		xchg	bx, di
		or	di, di
		jz	short dofastk
		retn
; ---------------------------------------------------------------------------

dofastk:				; ...
		push	dx
		mov	dl, [es:bp+0]
		push	es
		les	di, [THISSFT]
		mov	[es:di+0Bh], bx
		mov	[es:di+35h], bx
		pop	es
		pop	dx
		retn
; ---------------------------------------------------------------------------

ads7:					; ...
		cmp	word [es:bp+1Dh], 2
		jnz	short ads1
		pop	bx
		mov	dx, 0FFFFh
		call	RELBLKS
		pop	ax
		sub	ax, cx
		call	RESTFATBYT

Disk_Full_Return:			; ...
		mov	byte [DISK_FULL], 1
		stc
		retn

; =============== S U B	R O U T	I N E =======================================


RESTFATBYT:
		push	bx
		push	dx
		push	di
		xor	bx, bx
		mov	dx, [FATBYT]
		call	PACK
		pop	di
		pop	dx
		pop	bx
		retn

; =============== S U B	R O U T	I N E =======================================


RELEASE	:
		xor	dx, dx

RELBLKS:				; ...
		call	UNPACK
		jb	short RELEASE_flush
		jz	short RELEASE_flush
		mov	ax, di
		push	dx
		call	PACK
		pop	dx
		jb	short RELEASE_flush
		or	dx, dx
		jnz	short NO_DEALLOC
		cmp	word [es:bp+1Fh], -1
		jz	short NO_DEALLOC
		inc	word [es:bp+1Fh]

NO_DEALLOC:				; ...
		mov	bx, ax
		dec	ax
		jz	short RELEASE_flush
		call	IsEOF
		jb	short RELEASE

RELEASE_flush:				; ...
		mov	al, [es:bp+0]
		push	si
		push	cx
		push	es
		push	bp
		call	FLUSHBUF
		pop	bp
		pop	es
		pop	cx
		pop	si

RET12:					; ...
		retn

; =============== S U B	R O U T	I N E =======================================


GETEOF:
		call	UNPACK
		jb	short RET12
		push	bx
		mov	bx, di
		call	IsEOF
		pop	bx
		jnb	short RET12
		mov	bx, di
		jmp	short GETEOF

; =============== S U B	R O U T	I N E =======================================


MAKEFCB	:
		mov	byte [ss:SpaceFlag], 0
		xor	dl, dl
		test	al, 2
		jnz	short DEFDRV
		mov	byte [es:di], 0

DEFDRV:					; ...
		inc	di
		mov	cx, 8
		test	al, 4
		xchg	ax, bx
		mov	al, ' '
		jz	short FILLB
		add	di, cx
		xor	cx, cx

FILLB:					; ...
		rep stosb
		mov	cl, 3
		test	bl, 8
		jz	short FILLB2
		add	di, cx
		xor	cx, cx

FILLB2:					; ...
		rep stosb
		xchg	ax, cx
		stosw
		stosw
		sub	di, 16
		test	bl, 1
		jz	short SKPSPC
		call	SCANB
		call	DELIM
		jnz	short NOSCAN
		inc	si

SKPSPC:					; ...
		call	SCANB

NOSCAN:					; ...
		call	GETLET
		jbe	short NODRV
		cmp	byte [si], ':'
		jnz	short NODRV
		inc	si
		sub	al, '@'
		jbe	short BADDRV
		push	ax
		call	GetVisDrv
		pop	ax
		jnb	short HAVDRV
		cmp	byte [ss:DrvErr], 1Ah
		jz	short HAVDRV

BADDRV:					; ...
		mov	dl, -1

HAVDRV:					; ...
		stosb
		inc	si
		dec	di

NODRV:					; ...
		dec	si
		inc	di

NORMSCAN:				; ...
		mov	cx, 8
		call	GETWORD
		cmp	byte [si], '.'
		jnz	short NODOT
		inc	si
		test	byte [ss:DOS34_FLAG+1], 1
		jz	short VOLOK
		movsb
		mov	cx, 2
		jmp	short contvol
; ---------------------------------------------------------------------------

VOLOK:					; ...
		mov	cx, 3

contvol:				; ...
		call	MUSTGETWORD

NODOT:					; ...
		mov	al, dl
		and	word [ss:DOS34_FLAG], 0FEFFh
		retn

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR GETWORD

NONAM:					; ...
		add	di, cx
		dec	si
		retn
; END OF FUNCTION CHUNK	FOR GETWORD

; =============== S U B	R O U T	I N E =======================================


GETWORD	:

; FUNCTION CHUNK AT 8F67 SIZE 00000004 BYTES

		call	GETLET
		jbe	short NONAM
		dec	si

MUSTGETWORD:				; ...
		call	GETLET
		jnz	short MustCheckCX
		test	byte [ss:SpaceFlag], 0FFh
		jz	short FILLNAM
		cmp	al, ' '
		jnz	short FILLNAM

MustCheckCX:				; ...
		jcxz	MUSTGETWORD
		dec	cx
		cmp	al, '*'
		jnz	short NOSTAR
		mov	al, '?'
		rep stosb

NOSTAR:					; ...
		stosb
		cmp	al, '?'
		jnz	short MUSTGETWORD
		or	dl, 1
		jmp	short MUSTGETWORD
; ---------------------------------------------------------------------------

FILLNAM:				; ...
		mov	al, ' '
		rep stosb
		dec	si
		retn

; =============== S U B	R O U T	I N E =======================================


SCANB	:
		lodsb
		call	SPCHK
		jz	short SCANB
		dec	si

scanb_retn:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================


NAMETRANS:
		mov	byte [ss:SpaceFlag], 1
		push	ss
		pop	es
		mov	di, NAME1
		push	di
		mov	ax, '  '
		mov	cx, 5
		stosb
		rep stosw
		xor	al, al
		mov	dl, al
		stosb
		pop	di
		call	NORMSCAN
		cmp	byte [ss:NAME1], 0E5h
		jnz	short scanb_retn
		mov	byte [ss:NAME1], 5
		retn

; ---------------------------------------------------------------------------
CharType:	db  66h, 66h, 66h, 66h,	06h, 66h, 66h, 66h; 0 ;	...
		db  66h, 66h, 66h, 66h,	66h, 66h, 66h, 66h; 8
		db 0F8h,0F6h,0FFh,0FFh,0FFh, 4Fh,0F4h, 6Eh; 16
		db 0FFh,0FFh,0FFh,0FFh,0FFh, 44h, 44h,0F4h; 24
		db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh; 32
		db 0FFh,0FFh,0FFh,0FFh,0FFh, 6Fh, 66h,0FFh; 40
		db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh; 48
		db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0F4h; 56

; =============== S U B	R O U T	I N E =======================================


GETLET:
		lodsb

; =============== S U B	R O U T	I N E =======================================


UCase:
		push	bx
		mov	bx, FILE_UCASE_TAB_2

gl_0:					; ...
		cmp	al, 'a'
		jb	short gl_2
		cmp	al, 'z'
		ja	short gl_1
		sub	al, 20h

gl_1:					; ...
		cmp	al, 80h
		jb	short gl_2
		sub	al, 80h
		push	ds
		mov	ds, [cs:DosDSeg]
		xlat
		pop	ds

gl_2:					; ...
		push	ax
		call	GetCharType
		test	al, 1
		pop	ax
		pop	bx
		retn

; =============== S U B	R O U T	I N E =======================================


GETLET3:
		push	bx
		jmp	short gl_0

; =============== S U B	R O U T	I N E =======================================


DELIM:
		push	ax
		call	GetCharType
		test	al, 2
		pop	ax
		retn

; =============== S U B	R O U T	I N E =======================================


SPCHK:
		push	ax
		call	GetCharType
		test	al, 4
		pop	ax
		retn

; =============== S U B	R O U T	I N E =======================================


GetCharType:
		cmp	al, 7Eh
		jnb	short gct_90
		push	bx
		mov	bx, CharType
		shr	al, 1
		;xlat	byte [cs:bx]
		cs	xlat
		pop	bx
		jnb	short gct_80
		shr	al, 1
		shr	al, 1
		shr	al, 1
		shr	al, 1

gct_80:					; ...
		and	al, 0Fh
		retn
; ---------------------------------------------------------------------------

gct_90:					; ...
		mov	al, 0Fh
		retn

; =============== S U B	R O U T	I N E =======================================


PATHCHRCMP:
		cmp	al, '/'
		jbe	short PathRet
		cmp	al, '\'
		retn
; ---------------------------------------------------------------------------

GotFor:					; ...
		mov	al, '\'
		retn
; ---------------------------------------------------------------------------

PathRet:				; ...
		jz	short GotFor
		retn

; ---------------------------------------------------------------------------
LowInt23Addr:	dd LowInt23		; ...
LowInt24Addr:	dd LowInt24		; ...
LowInt28Addr:	dd LowInt28		; ...

; =============== S U B	R O U T	I N E =======================================


DSKSTATCHK:
		cmp	byte [ss:INDOS], 1
		jz	short dskstatchk1
		retn
; ---------------------------------------------------------------------------

dskstatchk1:				; ...
		push	cx
		push	es
		push	bx
		push	ds
		push	si
		mov	bx, ss
		mov	es, bx
		mov	ds, bx
		mov	byte [ss:DSKSTCOM], 5
		mov	byte [ss:DSKSTCALL], 0Eh
		mov	word [ss:DSKSTST], 0
		mov	bx, DSKSTCALL
		lds	si, [ss:BCON]
		call	DEVIOCALL2
		test	byte [ss:DSKSTST+1], 2
		jz	short _GotCh
		xor	al, al

RET36:					; ...
		pop	si
		pop	ds
		pop	bx
		pop	es
		pop	cx
		retn
; ---------------------------------------------------------------------------

_GotCh:					; ...
		mov	al, [ss:DSKCHRET]
		cmp	al, 3
		jnz	short RET36
		mov	byte [ss:DSKSTCOM], 4
		mov	byte [ss:DSKSTCALL], 16h
		mov	[ss:DSKCHRET], cl
		mov	word [ss:DSKSTST], 0
		mov	word [ss:DSKSTCNT], 1
		call	DEVIOCALL2
		pop	si
		pop	ds
		pop	bx
		pop	es
		pop	cx
		jmp	CNTCHAND

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR STATCHK

NOSTOP:					; ...
		cmp	al, 10h		; "P"-"@"
		jnz	short check_next
		cmp	byte [ss:SCAN_FLAG], 0
		jz	short INCHKJ
		retn
; ---------------------------------------------------------------------------

check_next:				; ...
		cmp	al, 3		; "C"-"@"
		jz	short INCHKJ

check_end:				; ...
		retn
; ---------------------------------------------------------------------------

INCHKJ:					; ...
		jmp	INCHK
; END OF FUNCTION CHUNK	FOR STATCHK

; =============== S U B	R O U T	I N E =======================================


SPOOLINT:
		pushf
		cmp	byte [ss:IDLEINT], 0
		jz	short POPFRET
		cmp	byte [ss:ERRORMODE], 0
		jnz	short POPFRET
		push	word [ss:IDLEINT]
		cmp	byte [ss:DosHasHMA], 0
		jnz	short do_low_int28
		int	28h		; DOS 2+ internal - KEYBOARD BUSY LOOP
		jmp	short spool_ret_addr
; ---------------------------------------------------------------------------

do_low_int28:				; ...
		call	far [cs:LowInt28Addr]

spool_ret_addr:				; ...
		pop	word [ss:IDLEINT]

POPFRET:				; ...
		popf

_RET18:					; ...
		retn

; =============== S U B	R O U T	I N E =======================================


STATCHK:

; FUNCTION CHUNK AT 4052 SIZE 0000007A BYTES
; FUNCTION CHUNK AT 40D0 SIZE 00000003 BYTES
; FUNCTION CHUNK AT 40F8 SIZE 00000154 BYTES
; FUNCTION CHUNK AT 90F4 SIZE 00000015 BYTES

		call	DSKSTATCHK
		push	bx
		xor	bx, bx
		call	GET_IO_SFT
		pop	bx
		jb	short _RET18
		mov	ah, 1
		call	IOFUNC
		jz	short SPOOLINT
		cmp	al, 13h		; 'S'-'@'
		jnz	short NOSTOP
		cmp	byte [ss:SCAN_FLAG], 0
		jnz	short check_end
		xor	ah, ah
		call	IOFUNC
		jmp	short PAUSOSTRT
; ---------------------------------------------------------------------------

PRINTONOFF:				; ...
		not	byte [ss:PFLAG]
		push	bx
		mov	bx, 4
		call	GET_IO_SFT
		pop	bx
		jb	short _RET18
		push	es
		push	di
		push	ds
		pop	es
		mov	di, si
		test	byte [es:di+6], 8
		jz	short NORM_PR
		push	ax
		mov	ax, 1126h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - ???
					; Return: CF set on error, AX =	error code
					; STACK	unchanged
		pop	ax
		jnb	short NORM_PR
		mov	byte [ss:PFLAG], 0
		push	ax
		mov	ax, 1124h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - ???
					; ES:DI	-> SFT,	SS = DOS CS
		pop	ax
		jmp	short RETP6
; ---------------------------------------------------------------------------

NORM_PR:				; ...
		cmp	byte [ss:PFLAG], 0
		jnz	short PRNOPN
		call	DEV_CLOSE_SFT
		jmp	short RETP6
; ---------------------------------------------------------------------------

PRNOPN:					; ...
		call	DEV_OPEN_SFT

RETP6:					; ...
		pop	di
		pop	es

STATCHK_RETN:				; ...
		retn
; ---------------------------------------------------------------------------

PAUSOLP:				; ...
		call	SPOOLINT

PAUSOSTRT:				; ...
		mov	ah, 1
		call	IOFUNC
		jz	short PAUSOLP

INCHK:					; ...
		push	bx
		xor	bx, bx
		call	GET_IO_SFT
		pop	bx
		jb	short STATCHK_RETN
		xor	ah, ah
		call	IOFUNC
		cmp	al, 10h		; "P"-"@"
		jz	short PRINTONOFF
		cmp	al, 3		; "C"-"@"
		jnz	short STATCHK_RETN

CNTCHAND:				; ...
		test	byte [ss:DOS34_FLAG+1], 2
		jnz	short around_deadlock
		mov	al, 3
		call	BUFOUT
		call	CRLF

around_deadlock:			; ...
		push	ss
		pop	ds
		cmp	byte [CONSWAP], 0
		jz	short NOSWAP
		call	SWAPBACK

NOSWAP:					; ...
		cli
		mov	ss, [USER_SS]
		mov	sp, [USER_SP]
		call	restore_world
		pop	es
		push	ds
		mov	ds, [cs:DosDSeg]
		mov	byte [INDOS], 0
		mov	byte [ERRORMODE], 0
		mov	[ConC_Spsave], sp
		add	word [ConC_Spsave], 2
		cmp	byte [DosHasHMA], 0
		pop	ds
		jnz	short do_low_int23
		clc
		int	23h		; DOS -	CONTROL	"C" EXIT ADDRESS
					; Return: return via RETF 2 with CF set
					; DOS will abort program with errorlevel 0
					; else
					; interrupted DOS call continues
		jmp	short ctrlc_ret_addr
; ---------------------------------------------------------------------------

do_low_int23:				; ...
		clc
		call	far [cs:LowInt23Addr]

ctrlc_ret_addr:				; ...
		cli
		push	ax
		mov	ax, ds
		mov	ds, [cs:DosDSeg]
		mov	[TEMPSEG], ax
		pop	ax
		mov	[USER_IN_AX], ax
		pushf
		pop	ax
		cmp	sp, [ConC_Spsave]
		jnz	short ctrlc_try_new

ctrlc_repeat:				; ...
		mov	ax, [USER_IN_AX]
		mov	ds, [TEMPSEG]

COMMANDJ:				; ...
		jmp	command
; ---------------------------------------------------------------------------

ctrlc_try_new:				; ...
		add	sp, 2
		test	al, 1
		jz	short ctrlc_repeat
		mov	ds, [TEMPSEG]

ctrlc_abort:				; ...
		mov	ax, 4C00h
		push	ds
		mov	ds, [cs:DosDSeg]
		mov	byte [DidCTRLC], 0FFh
		pop	ds
		jmp	short COMMANDJ

; ---------------------------------------------------------------------------

DIVOV:					; ...
		mov	si, DIVMES	; "\r\nDivide overflow\r\n"
		mov	bx, [cs:DivMesLen]
		mov	ss, [cs:DosDSeg]
		mov	sp, AUXSTACK
		call	_OUTMES
		jmp	short ctrlc_abort

; =============== S U B	R O U T	I N E =======================================


_OUTMES	:
		push	ss
		pop	es
		push	ss
		pop	ds
		mov	byte [DSKSTCOM], 8
		mov	byte [DSKSTCALL], 16h
		mov	word [DSKSTST], 0
		mov	[DSKSTCNT], bx
		mov	bx, DSKSTCALL
		mov	[DEVIOBUF_PTR], si ; [DSKCHRET+1]
		mov	[DOSSEG_INIT],	cs ; [DSKCHRET+3]
		lds	si, [BCON]
		call	DEVIOCALL2
		mov	word [es:DEVIOBUF_PTR], DEVIOBUF
		mov	word [es:DSKSTCNT], 1
		retn

; =============== S U B	R O U T	I N E =======================================


CHARHARD:
		cmp	byte [ss:ERRORMODE], 0
		jnz	short chard1
		or	ah, 10h
		test	byte [ss:PFLAG], 0FFh
		jnz	short ctrlp

chard1:					; ...
		or	ah, 38h

ctrlp:					; ...
		mov	byte [ss:ALLOWED], ah
		mov	word [ss:EXITHOLD+2], es
		mov	word [ss:EXITHOLD], bp
		push	si
		and	di, 0FFh
		mov	bp, ds
		call	FATALC
		pop	si
		retn

; =============== S U B	R O U T	I N E =======================================


HARDERR	:
		xchg	ax, di
		and	di, 0FFh
		cmp	di, 0
		jnz	short NOSETWRPERR
		push	ax
		mov	al, [es:bp+0]
		mov	byte [ss:WPERR], al
		pop	ax

NOSETWRPERR:				; ...
		sub	ax, cx
		add	dx, ax
		push	dx
		mul	word [es:bp+2]
		pop	dx
		add	bx, ax
		xor	ah, ah
		cmp	dx, [es:bp+6]
		jb	short ERRINT
		inc	ah
		cmp	dx, [es:bp+11h]
		jnb	short TESTDIR
		mov	word [es:bp+1Fh], 0FFFFh
		jmp	short ERRINT
; ---------------------------------------------------------------------------

TESTDIR:				; ...
		inc	ah
		cmp	dx, [es:bp+0Bh]
		jb	short ERRINT
		inc	ah

ERRINT:					; ...
		shl	ah, 1
		or	ah, [ss:READOP]
		or	ah, [ss:ALLOWED]

FATAL:					; ...
		mov	al, [es:bp+0]

FATAL1:					; ...
		mov	word [ss:EXITHOLD+2], es
		mov	word [ss:EXITHOLD], bp
		les	si, [es:bp+13h]
		mov	bp, es

; =============== S U B	R O U T	I N E =======================================


FATALC:

; FUNCTION CHUNK AT A1EA SIZE 0000000D BYTES
; FUNCTION CHUNK AT A1FF SIZE 00000022 BYTES

		call	SET_I24_EXTENDED_ERROR
		cmp	di, 0Ch
		jbe	short NET_I24_ENTRY
		mov	di, 0Ch

NET_I24_ENTRY:				; ...
		cmp	byte [ss:ERRORMODE], 0
		jz	short NoSetFail
		mov	al, 3
		jmp	short FailRet
; ---------------------------------------------------------------------------

NoSetFail:				; ...
		mov	[ss:CONTSTK], sp
		push	ss
		pop	es
		cmp	word [ss:SFN], 0FFFFh
		jz	short _NoFree
		push	ds
		push	si
		lds	si, [ss:PJFN]
		mov	byte [si], 0FFh
		pop	si
		pop	ds

_NoFree:				; ...
		cli
		inc	byte [ss:ERRORMODE]
		dec	byte [ss:INDOS]
		test	byte [ss:EXTOPEN_ON], 2
		jz	short i24yes
		mov	al, 3
		jmp	short passi24
; ---------------------------------------------------------------------------

i24yes:					; ...
		mov	ss, [ss:USER_SS]
		mov	sp, [es:USER_SP]
		cmp	byte [es:DosHasHMA], 0
		jnz	short do_low_int24
		int	24h		; DOS -	FATAL ERROR HANDLER ADDRESS
					; Automatically	called upon detection of unrecoverable I/O error.
		jmp	short criterr_ret_addr
; ---------------------------------------------------------------------------

do_low_int24:				; ...
		call	far [cs:LowInt24Addr]

criterr_ret_addr:			; ...
		mov	[es:USER_SP], sp
		mov	[es:USER_SS], ss
		mov	bp, es
		mov	ss, bp

passi24:				; ...
		mov	sp, [ss:CONTSTK]
		inc	byte [ss:INDOS]
		mov	byte [ss:ERRORMODE], 0
		sti

FailRet:				; ...
		les	bp, [ss:EXITHOLD]
		cmp	al, 1
		jb	short CheckIgnore
		jz	short CheckRetry
		cmp	al, 3
		jnz	short DoAbort
		test	byte [ss:ALLOWED], 8
		jz	short DoAbort

DoFail:					; ...
		mov	al, 3
		test	byte [ss:EXTOPEN_ON], 2
		jnz	short CleanUp
		inc	byte [ss:FAILERR]

CleanUp:				; ...
		mov	byte [ss:WPERR], 0FFh
		cmp	word [ss:SFN], 0FFFFh
		jnz	short CleanUp2
		retn
; ---------------------------------------------------------------------------

CleanUp2:				; ...
		push	ds
		push	si
		push	ax
		mov	ax, [ss:SFN]
		lds	si, [ss:PJFN]
		mov	[si], al
		pop	ax
		pop	si
		pop	ds
		retn
; ---------------------------------------------------------------------------

CheckIgnore:				; ...
		test	byte [ss:ALLOWED], 20h
		jz	short DoFail
		jmp	short CleanUp
; ---------------------------------------------------------------------------

CheckRetry:				; ...
		test	byte [ss:ALLOWED], 10h
		jz	short DoFail
		jmp	short CleanUp
; ---------------------------------------------------------------------------

DoAbort:				; ...
		push	ss
		pop	ds
		cmp	byte [CONSWAP], 0
		jz	short NOSWAP2
		call	SWAPBACK

NOSWAP2:				; ...
		cmp	byte [fAborting], 0
		jnz	short DoFail
		mov	byte [EXIT_TYPE], 2
		xor	al, al
		jmp	exit_inner
; ---------------------------------------------------------------------------

reset_environment:			; ...
		push	ds
		mov	ah, 82h
		int	2Ah		; Microsoft Networks - END DOS CRITICAL	SECTIONS 0 THROUGH 7
		mov	byte [ss:fAborting], 0FFh ; -1
		mov	ax, 1122h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - PROCESS TERMINATION HOOK
					; SS = DOS CS
		mov	al, 22h
		call	$GET_INTERRUPT_VECTOR
		pop	cx
		push	es
		push	bx
		mov	bx, [ss:CurrentPDB]
		mov	ds, bx
		mov	ax, [16h]	; [PDB.PARENT_PID]
		cmp	ax, bx
		jz	short reset_return
		cmp	bx, cx
		jnz	short reset_return
		push	ax
		cmp	byte [ss:EXIT_TYPE], 3
		jz	short reset_to_parent
		call	arena_free_process
		call	DOS_ABORT

reset_to_parent:			; ...
		pop	word [ss:CurrentPDB]

reset_return:				; ...
		push	ss
		pop	ds
		mov	al, 0FFh
		call	ECritDisk
		call	FLUSHBUF
		call	LCritDisk
		call	CHECK_VIRT_OPEN
		cli

		mov	byte [INDOS], 0
		mov	byte [WPERR], 0FFh
		mov	byte [fAborting], 0
		pop	word [EXITHOLD]
		pop	word [EXITHOLD+2]
		mov	ds, [CurrentPDB]
		mov	ss, word [30h]
		mov	sp, [2Eh]	; [PDB.USER_STACK]
		call	restore_world
		pop	es
		push	ax
		mov	ax, ds
		mov	ds, [cs:DosDSeg]
		mov	[TEMPSEG], ax
		pop	ax
		mov	[USER_SP], ax
		pop	ax
		pop	ax
		pop	ax
		lahf
		xchg	ah, al
		and	al, 2
		mov	ah, 0F2h
		push	ax
		push	word [EXITHOLD+2]
		push	word [EXITHOLD]
		mov	ax, [USER_SP]
		mov	ds, [TEMPSEG]
		iret

; =============== S U B	R O U T	I N E =======================================


SET_I24_EXTENDED_ERROR:
		push	ax
		mov	ax, FIRST_BUFF_ADDR ; ErrMap24End
		sub	ax, ErrMap24
		push	ds
		mov	ds, [cs:DosDSeg]
		cmp	di, ax
		mov	ax, di
		jnb	short NoTrans
		mov	al, [ErrMap24+di]
		xor	ah, ah

NoTrans:				; ...
		mov	word [EXTERR], ax
		pop	ds
		pop	ax
		push	si
		mov	si, ERR_TABLE_24
		call	CAL_LK
		pop	si
		retn

; =============== S U B	R O U T	I N E =======================================


IsEOF:
		cmp	word [es:bp+0Dh], 0FF6h
		jnb	short EOF16
		cmp	bx, 0FF0h
		jz	short IsEOF_other
		cmp	bx, 0FF8h

IsEOF_other:				; ...
		retn
; ---------------------------------------------------------------------------

EOF16:					; ...
		cmp	bx, 0FFF8h
		retn

; =============== S U B	R O U T	I N E =======================================


UNPACK:
		or	bx, bx
		jnz	short up_cont
		mov	di, [CL0FATENTRY]
		or	di, di
		retn
; ---------------------------------------------------------------------------

up_cont:				; ...
		cmp	bx, [es:bp+0Dh]
		ja	short HURTFAT
		call	MAPCLUSTER
		jb	short _DoContext
		mov	di, [di]
		jnz	short High12
		mov	si, [es:bp+0Dh]
		cmp	si, 0FF6h
		jb	short Unpack12
		or	di, di
		jmp	short _DoContext
; ---------------------------------------------------------------------------

High12:					; ...
		shr	di, 1
		shr	di, 1
		shr	di, 1
		shr	di, 1

Unpack12:				; ...
		and	di, 0FFFh

_DoContext:				; ...
		push	ss
		pop	ds
		retn
; ---------------------------------------------------------------------------

HURTFAT:				; ...
		mov	word [es:bp+1Fh], 0FFFFh
		push	ax
		mov	ah, 88h
		mov	byte [ss:ALLOWED], 8
		mov	di, 0FFFh
		call	FATAL
		cmp	al, 3
		clc
		jnz	short OKU_RET
		stc

OKU_RET:				; ...
		pop	ax

hurtfat_retn:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================


PACK:
		or	bx, bx
		jnz	short p_cont
		mov	[CL0FATENTRY], dx
		retn
; ---------------------------------------------------------------------------

p_cont:					; ...
		call	MAPCLUSTER
		jb	short _DoContext
		mov	si, [di]
		jz	short ALIGNED
		push	cx
		mov	cl, 4
		shl	dx, cl
		pop	cx
		and	si, 0Fh
		jmp	short PACKIN
; ---------------------------------------------------------------------------

ALIGNED:				; ...
		cmp	word [es:bp+0Dh], 0FF6h
		jnb	short Pack16
		and	si, 0F000h
		and	dx, 0FFFh
		jmp	short PACKIN
; ---------------------------------------------------------------------------

Pack16:					; ...
		xor	si, si

PACKIN:					; ...
		or	si, dx
		mov	[di], si
		lds	si, [ss:CURBUF]
		test	byte [si+5], 40h
		jnz	short yesdirty11
		call	INC_DIRTY_COUNT
		or	byte [si+5], 40h

yesdirty11:				; ...
		cmp	byte [ss:CLUSSPLIT], 0
		push	ss
		pop	ds
		jz	short hurtfat_retn
		push	ax
		push	bx
		push	cx
		mov	ax, [CLUSSAVE]
		mov	ds, word [CURBUF+2]
		add	si, 20
		mov	[si], ah
		push	ss
		pop	ds
		push	ax
		mov	dx, [CLUSSEC+2]
		mov	word [HIGH_SECTOR], dx
		mov	dx, [CLUSSEC]
		mov	si, 1
		xor	al, al
		call	GETBUFFRB
		pop	ax
		jb	short POPP_RET
		lds	di, [CURBUF]
		test	byte [di+5], 40h
		jnz	short yesdirty12
		call	INC_DIRTY_COUNT
		or	byte [di+5], 40h

yesdirty12:				; ...
		add	di, 20
		dec	di
		add	di, [es:bp+2]
		mov	[di], al
		clc

POPP_RET:				; ...
		push	ss
		pop	ds
		pop	cx
		pop	bx
		pop	ax
		retn

; =============== S U B	R O U T	I N E =======================================


MAPCLUSTER:
		mov	byte [CLUSSPLIT], 0
		push	ax
		push	bx
		push	cx
		push	dx
		mov	ax, bx
		cmp	word [es:bp+0Dh], 0FF6h
		jnb	short Map16
		shr	ax, 1

Map16:					; ...
		xor	di, di
		add	ax, bx
		adc	di, di
		mov	cx, [es:bp+2]
		cmp	cx, 512
		jnz	short _DoDiv
		mov	dx, ax
		and	dx, 1FFh
		mov	al, ah
		shr	di, 1
		rcr	al, 1
		xor	ah, ah
		jmp	short DivDone
; ---------------------------------------------------------------------------

_DoDiv:					; ...
		mov	dx, di
		div	cx

DivDone:				; ...
		add	ax, [es:bp+6]
		dec	cx
		push	ax
		push	dx
		push	cx
		mov	dx, ax
		mov	word [HIGH_SECTOR], 0
		xor	al, al
		mov	si, 1
		call	GETBUFFRB
		pop	cx
		pop	ax
		pop	dx
		jb	short MAP_POP
		lds	si, [CURBUF]
		lea	di, [si+20]
		add	di, ax
		cmp	ax, cx
		jnz	short MAPRET
		mov	al, [di]
		push	ss
		pop	ds
		inc	byte [CLUSSPLIT]
		mov	byte [CLUSSAVE], al
		mov	[CLUSSEC], dx
		mov	word [CLUSSEC+2], 0
		inc	dx
		mov	word [HIGH_SECTOR], 0
		xor	al, al
		mov	si, 1
		call	GETBUFFRB
		jb	short MAP_POP
		lds	si, [CURBUF]
		lea	di, [si+20]
		mov	al, [di]
		push	ss
		pop	ds
		mov	byte [CLUSSAVE+1], al
		mov	di, CLUSSAVE

MAPRET:					; ...
		pop	dx
		pop	cx
		pop	bx
		xor	ax, ax
		cmp	word [es:bp+0Dh], 0FF6h
		jnb	short MapSet
		mov	ax, bx

MapSet:					; ...
		test	al, 1
		pop	ax
		retn
; ---------------------------------------------------------------------------

MAP_POP:				; ...
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		retn

; =============== S U B	R O U T	I N E =======================================


FATREAD_SFT:
		les	bp, [es:di+7]
		mov	al, [es:bp+0]
		mov	[THISDRV], al
		call	GOTDPB
		call	FAT_GOT_DPB

fatread_sft_retn:			; ...
		retn

; =============== S U B	R O U T	I N E =======================================


FATREAD_CDS:
		push	es
		push	di
		les	bp, [es:di+45h]
		mov	al, [es:bp+0]
		mov	[THISDRV], al
		call	GOTDPB
		call	FAT_GOT_DPB
		pop	di
		pop	es
		jb	short fatread_sft_retn
		jnz	short NO_CHANGE
		xor	ax, ax
		dec	ax
		push	ds
		mov	cl, [CDSCOUNT]
		xor	ch, ch
		lds	si, [es:di+45h]
		les	di, [ss:CDSADDR]

frcd20:					; ...
		test	byte [es:di+44h], 80h
		jnz	short frcd25
		cmp	si, [es:di+45h]
		jnz	short frcd25
		mov	bx, ds
		cmp	bx, [es:di+47h]
		jnz	short frcd25
		test	[es:di+49h], ax
		jz	short frcd25
		mov	[es:di+49h], ax

frcd25:					; ...
		add	di, 88
		loop	frcd20
		pop	ds

NO_CHANGE:				; ...
		les	bp, [THISDPB]
		clc
		retn

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR FAT_GOT_DPB

FATERR:					; ...
		mov	word [es:bp+1Fh], 0FFFFh ; -1
		and	di, 0FFh
		mov	byte [ALLOWED], 18h
		mov	ah, 1Ah
		mov	al, [THISDRV]
		call	FATAL1
		les	bp, [THISDPB]
		cmp	al, 3
		jnz	short FAT_GOT_DPB
		stc
		retn
; END OF FUNCTION CHUNK	FOR FAT_GOT_DPB

; =============== S U B	R O U T	I N E =======================================


FAT_GOT_DPB:

; FUNCTION CHUNK AT 971C SIZE 00000021 BYTES

		push	ss
		pop	ds
		mov	al, 0Fh
		mov	ah, [es:bp+1]
		mov	word [DEVCALL], ax
		mov	byte [DEVCALL_REQFUNC], 1
		mov	word [DEVCALL_REQSTAT], 0
		mov	al, [es:bp+17h]	; [ES:BP+DPB.MEDIA]
		mov	[CALLUNIT], al	; [CALLMED]
		push	es
		push	ds
		mov	bx, DEVCALL
		lds	si, [es:bp+13h]	; [ES:BP+DPB.DRIVER_ADDR]
		pop	es
		call	DEVIOCALL2
		push	ss
		pop	ds
		pop	es
		mov	di, [DEVCALL_REQSTAT]
		or	di, di
		js	short FATERR
		xor	ah, ah
		xchg	ah, [es:bp+18h]	; [ES:BP+DPB.FIRST_ACCESS]
		mov	al, [THISDRV]
		cmp	byte [VOLCHNG_FLAG], al
		jnz	short CHECK_BYT
		mov	byte [VOLCHNG_FLAG], 0FFh ;	-1
		jmp	GOGETBPB
; ---------------------------------------------------------------------------

CHECK_BYT:				; ...
		or	ah, byte [CALLBR] ; [CALLRBYT]
		jns	short CHECK_ZR
		jmp	short NEWDSK
; ---------------------------------------------------------------------------

CHECK_ZR:				; ...
		jz	short CHKBUFFDIRT
		clc
		retn
; ---------------------------------------------------------------------------

DISK_CHNG_ERR:				; ...
		push	es
		push	bp
		les	bp, [es:bp+13h]
		test	byte [es:bp+5], 8
		pop	bp
		pop	es
		jz	short FAIL_OPJ2
		push	ds
		push	di
		push	ss
		pop	ds
		mov	byte [ALLOWED], 18h	; Allowed_FAIL+Allowed_RETRY
		push	es
		les	di, [CALLBR+1]	; [CALLVIDM]
		mov	word [EXTERRPT+2], es
		pop	es
		mov	word [EXTERRPT], di
		mov	ax, 0Fh
		mov	byte [READOP], 1
		call	HARDERR
		pop	di
		pop	ds
		cmp	al, 3

FAIL_OPJ2:				; ...
		jz	short FAIL_OP
		jmp	FAT_GOT_DPB
; ---------------------------------------------------------------------------

CHKBUFFDIRT:				; ...
		cmp	word [ss:DirtyBufferCount], 0
		jz	short NEWDSK
		call	GETCURHEAD

nbuffer:				; ...
		cmp	[di+4],	al	; [di+BUFFINFO.buf_ID]
		jnz	short lfnxt
		test	byte [di+5], 40h ; [di+BUFFINFO.buf_flags]
		jz	short lfnxt
		push	ss
		pop	ds
		clc
		retn
; ---------------------------------------------------------------------------

FAIL_OP:				; ...
		push	ss
		pop	ds
		stc
		retn
; ---------------------------------------------------------------------------

lfnxt:					; ...
		mov	di, [di]
		cmp	[ss:FIRST_BUFF_ADDR], di
		jnz	short nbuffer

NEWDSK:					; ...
		mov	word [es:bp+1Fh], 0FFFFh ; -1
		call	GETCURHEAD

nxbuffer:				; ...
		cmp	[di+4],	al
		jnz	short lfnxt2
		test	byte [di+5], 40h ; buf_dirty
		jnz	short DISK_CHNG_ERR
		mov	word [di+4], 20FFh
		call	SCANPLACE
		jmp	short skpbuff
; ---------------------------------------------------------------------------

lfnxt2:					; ...
		mov	di, [di]

skpbuff:				; ...
		cmp	di, [ss:FIRST_BUFF_ADDR]
		jnz	short nxbuffer
		cmp	word [ss:SC_CACHE_COUNT], 0
		jz	short GOGETBPB
		cmp	al, [ss:CurSC_DRIVE]
		jnz	short GOGETBPB
		mov	byte [ss:CurSC_DRIVE], 0FFh ; -1

GOGETBPB:				; ...
		lds	di, [es:bp+13h]
		test	byte [di+5], 20h
		jnz	short GETFREEBUF
		push	ss
		pop	ds
		mov	bx, 2
		call	UNPACK

FAIL_OPJ:				; ...
		jb	short FAIL_OP
		lds	di, [CURBUF]
		jmp	short GOTGETBUF
; ---------------------------------------------------------------------------

GETFREEBUF:				; ...
		push	es
		push	bp
		xor	dx, dx
		mov	word [ss:HIGH_SECTOR],	dx
		call	GETCURHEAD
		call	BUFWRITE
		pop	bp
		pop	es
		jb	short FAIL_OPJ

GOTGETBUF:				; ...
		add	di, 20		; BUFINSIZ
		mov	word [ss:CALLBR+2], ds ; [SS:CALLXAD+2]
		push	ss
		pop	ds
		mov	word [CALLBR], di ; [CALLXAD]
		mov	al, 16h
		mov	ah, [es:bp+1]	; ES:BP+DPB.UNIT]
		mov	word [DEVCALL], ax ; [DEVCALL_REQLEN]
		mov	byte [DEVCALL_REQFUNC], 2
		mov	word [DEVCALL_REQSTAT], 0
		mov	al, [es:bp+17h]	; [ES:BP+DPB.MEDIA]
		mov	[CALLUNIT], al	; [CALLMED]
		push	es
		push	ds
		push	word [es:bp+15h]
		push	word [es:bp+13h] ; [ES:BP+DPB.DRIVER_ADDR]
		mov	bx, DEVCALL
		pop	si
		pop	ds
		pop	es
		call	DEVIOCALL2
		pop	es
		push	ss
		pop	ds
		mov	di, [DEVCALL_REQSTAT]
		or	di, di
		js	short FATERRJ
		mov	al, [es:bp+17h]
		lds	si, [CALLBPB]
		mov	word [es:bp+1Dh], 0	; [ES:BP+DPB.NEXT_FREE]
		call	$SETDPB
		lds	di, [ss:CALLBR]	; [SS:CALLXAD]
		mov	al, [es:bp+8]	; [ES:BP+DPB.FAT_COUNT]
		mov	[di-0Ah], al	; [DI+BUFFINFO.buf_wrtcnt-BUFINSIZ]
		mov	ax, [es:bp+0Fh]	; [ES:BP+DPB.FAT_SIZE]
		mov	[di-9],	ax	; [DI+BUFFINFO.buf_wrtcntinc-BUFINSIZ]
		push	ss
		pop	ds
		xor	al, al
		retn
; ---------------------------------------------------------------------------

FATERRJ:				; ...
		jmp	FATERR

; =============== S U B	R O U T	I N E =======================================


GETCURHEAD:
		lds	di, [ss:BufferQueue]
		mov	word [ss:LastBuffer], 0FFFFh ; -1
		mov	[ss:FIRST_BUFF_ADDR], di
		retn

; =============== S U B	R O U T	I N E =======================================


SCANPLACE:
		push	word [di]
		call	PLACEBUF
		pop	di
		retn

; =============== S U B	R O U T	I N E =======================================


PLACEBUF:
		push	ax
		push	bx
		push	si
		mov	ax, [di]
		mov	bx, word [ss:BufferQueue]
		cmp	ax, bx
		jz	short nret
		cmp	di, bx
		jnz	short not_first
		mov	word [ss:BufferQueue], ax
		jmp	short nret
; ---------------------------------------------------------------------------

not_first:				; ...
		mov	si, [di+2]
		mov	[si], ax
		xchg	ax, si
		mov	[si+2],	ax
		mov	si, [bx+2]
		mov	[si], di
		mov	[bx+2],	di
		mov	[di+2],	si
		mov	[di], bx

nret:					; ...
		pop	si
		pop	bx
		pop	ax
		cmp	byte [di+4], 0FFh
		jnz	short pbx
		mov	word [ss:BufferQueue], di

pbx:					; ...
		retn

; ---------------------------------------------------------------------------

POINTCOMP:				; ...
		cmp	si, di
		jnz	short _ret_label
		push	cx
		push	dx
		mov	cx, ds
		mov	dx, es
		cmp	cx, dx
		pop	dx
		pop	cx

_ret_label:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================


GETBUFFR:
		xor	si, si

; =============== S U B	R O U T	I N E =======================================


GETBUFFRB:
		mov	[PREREAD], ax
		mov	al, [es:bp+0]	; [ES:BP+DPB.DRIVE]
		lds	di, [LastBuffer]
		mov	cx, [ss:HIGH_SECTOR]
		cmp	di, 0FFFFh	; -1
		jz	short getb5
		cmp	dx, [di+6]	; [DI+BUFFINFO.buf_sector]
		jnz	short getb5
		cmp	cx, [di+8]	; [DI+BUFFINFO.buf_sector+2]
		jnz	short getb5
		cmp	al, [di+4]	; [DI+BUFFINFO.buf_ID]
		jnz	short getb5
		jmp	getb35
; ---------------------------------------------------------------------------

getb5:					; ...
		call	GETCURHEAD

getb10:					; ...
		cmp	dx, [di+6]
		jnz	short getb12
		cmp	cx, [di+8]
		jnz	short getb12
		cmp	al, [di+4]
		jnz	short getb12
		jmp	getb25
; ---------------------------------------------------------------------------

getb12:					; ...
		mov	di, [di]
		cmp	di, [ss:FIRST_BUFF_ADDR]
		jnz	short getb10
		push	cx
		push	si
		push	dx
		push	bp
		push	es
		call	BUFWRITE
		pop	es
		pop	bp
		pop	dx
		pop	si
		pop	word [ss:HIGH_SECTOR]
		jnb	short getb13
		jmp	getbx
; ---------------------------------------------------------------------------

getb13:					; ...
		call	SET_RQ_SC_PARMS
		xor	ah, ah
		cmp	byte [ss:PREREAD], ah
		jnz	short getb20
		lea	bx, [di+20]	; [DI+BUFINSIZ]
		mov	cx, 1
		push	si
		push	di
		push	dx
		push	es
		cmp	byte [ss:BuffInHMA], 0
		jz	short getb14
		push	ds
		push	bx
		lds	bx, [ss:LoMemBuff]

getb14:					; ...
		or	si, si
		jz	short getb15
		call	FATSECRD
		mov	ah, 2
		jmp	short getb17
; ---------------------------------------------------------------------------

getb15:					; ...
		call	DREAD
		mov	ah, 0

getb17:					; ...
		pushf
		cmp	byte [ss:BuffInHMA], 0
		jz	short not_in_hma
		mov	cx, [es:bp+2]
		shr	cx, 1
		popf
		mov	si, bx
		pop	di
		pop	es
		cld
		pushf
		rep movsw
		push	es
		pop	ds

not_in_hma:				; ...
		popf
		pop	es
		pop	dx
		pop	di
		pop	si
		jb	short getbx

getb20:					; ...
		mov	cx, [ss:HIGH_SECTOR]
		mov	[di+8],	cx	; [DI+BUFFINFO.buf_sector+2]
		mov	[di+6],	dx	; [DI+BUFFINFO.buf_sector]
		mov	[di+0Dh], bp	; [DI+BUFFINFO.buf_DPB]
		mov	word [di+0Fh], es ;	[DI+BUFFINFO.buf_DPB+2]
		mov	al, [es:bp+0]	; [ES:BP+DPB.DRIVE]
		mov	[di+4],	ax	; [DI+BUFFINFO.buf_ID]

getb25:					; ...
		mov	byte [di+0Ah], 1 ; [DI+BUFFINFO.buf_wrtcnt]
		xor	ax, ax
		or	si, si
		jz	short getb30
		mov	al, [es:bp+8]	; [ES:BP+DPB.FAT_COUNT]
		mov	[di+0Ah], al	; [DI+BUFFINFO.buf_wrtcnt]
		mov	ax, [es:bp+0Fh]	; [ES:BP+DPB.FAT_SIZE]

getb30:					; ...
		mov	[di+0Bh], ax	; [DI+BUFFINFO.buf_wrtcntinc]
		call	PLACEBUF

getb35:					; ...
		mov	word [ss:CURBUF+2], ds
		mov	word [ss:LastBuffer+2], ds
		mov	word [ss:CURBUF], di
		mov	word [ss:LastBuffer], di
		clc

getbx:					; ...
		push	ss
		pop	ds

getbuffrb_retn:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================


FLUSHBUF:
		call	GETCURHEAD
		test	byte [ss:DOS34_FLAG], 4
		jnz	short scan_buf_queue
		cmp	word [ss:DirtyBufferCount], 0
		jz	short end_scan

scan_buf_queue:				; ...
		call	CHECKFLUSH
		mov	ah, [di+4]
		cmp	byte [ss:WPERR], ah
		jz	short free_the_buf
		test	byte [ss:DOS34_FLAG], 4
		jz	short dont_free_the_buf

free_the_buf:				; ...
		mov	word [di+4], 0FFh ; [DI+BUFFINFO.buf_ID]

dont_free_the_buf:			; ...
		mov	di, [di]	; [DI+BUFFINFO.buf_link]
		cmp	di, [ss:FIRST_BUFF_ADDR]
		jnz	short scan_buf_queue

end_scan:				; ...
		push	ss
		pop	ds
		cmp	byte [FAILERR], 0
		jnz	short bad_flush
		retn
; ---------------------------------------------------------------------------

bad_flush:				; ...
		stc
		retn

; =============== S U B	R O U T	I N E =======================================


CHECKFLUSH:
		mov	ah, 0FFh
		cmp	[di+4],	ah
		jz	short getbuffrb_retn
		cmp	ah, al
		jz	short DOBUFFER
		cmp	al, [di+4]
		clc
		jnz	short getbuffrb_retn

DOBUFFER:				; ...
		test	byte [di+5], 40h ; buf_dirty
		jz	short getbuffrb_retn
		push	ax
		push	word [di+4]
		call	BUFWRITE
		pop	ax
		jb	short LEAVE_BUF
		and	ah, 0BFh	; not 40h
		mov	[di+4],	ax

LEAVE_BUF:				; ...
		pop	ax

checkflush_retn:			; ...
		retn

; =============== S U B	R O U T	I N E =======================================


BUFWRITE:
		mov	ax, 0FFh
		xchg	ax, [di+4]	; [DI+BUFFINFO.buf_ID]
		cmp	al, 0FFh
		jz	short checkflush_retn
		test	ah, 40h
		jz	short checkflush_retn
		call	DEC_DIRTY_COUNT
		cmp	al, [ss:WPERR]
		jz	short checkflush_retn
		mov	[ss:SC_DRIVE], al
		les	bp, [di+0Dh]	; [DI+BUFFINFO.buf_DPB]
		lea	bx, [di+14h]	; [DI+BUFINSIZ]
		mov	dx, [di+6]	; [DI+BUFFINFO.buf_sector]
		mov	cx, [di+8]
		mov	word [ss:HIGH_SECTOR], cx
		mov	cl, [di+0Ah]	; [DI+BUFFINFO.buf_wrtcnt]
		xor	ch, ch
		mov	byte [ss:ALLOWED], 18h ; Allowed_RETRY+Allowed_FAIL
		test	ah, 8
		jz	short NO_IGNORE
		or	byte [ss:ALLOWED], 20h ; Allowed_IGNORE

NO_IGNORE:				; ...
		mov	ax, [di+11]	; [DI+BUFFINFO.buf_wrtcntinc]
		push	di
		xor	di, di
		push	ds
		push	bx

WRTAGAIN:				; ...
		push	di
		push	cx
		push	ax
		mov	cx, 1
		push	bx
		push	dx
		push	ds
		cmp	byte [ss:BuffInHMA], 0
		jz	short NBUFFINHMA
		push	cx
		push	es
		mov	si, bx
		mov	cx, [es:bp+2]	; [es:bp+DPB.SECTOR_SIZE]
		shr	cx, 1
		les	di, [ss:LoMemBuff]
		mov	bx, di
		cld
		rep movsw
		push	es
		pop	ds
		pop	es
		pop	cx

NBUFFINHMA:				; ...
		call	DWRITE
		pop	ds
		pop	dx
		pop	bx
		pop	ax
		pop	cx
		pop	di
		jb	short NOSET
		inc	di

NOSET:					; ...
		add	dx, ax
		loop	WRTAGAIN
		pop	bx
		pop	ds
		or	di, di
		jnz	short BWROK
		stc

BWROK:					; ...
		pop	di
		retn

; =============== S U B	R O U T	I N E =======================================


SET_RQ_SC_PARMS:
		push	ax
		mov	ax, [es:bp+2]
		mov	word [ss:SC_SECTOR_SIZE], ax
		mov	al, [es:bp+0]
		mov	[ss:SC_DRIVE], al
		pop	ax
		retn

; =============== S U B	R O U T	I N E =======================================


INC_DIRTY_COUNT:
		inc	word [ss:DirtyBufferCount]
		retn

; =============== S U B	R O U T	I N E =======================================


DEC_DIRTY_COUNT:
		cmp	word [ss:DirtyBufferCount], 0
		jz	short ddcx
		dec	word [ss:DirtyBufferCount]

ddcx:					; ...
		retn

; ---------------------------------------------------------------------------

$WAIT:					; ...
		xor	ax, ax
		xchg	ax, [ss:exit_code]
		jmp	SYS_RET_OK

; =============== S U B	R O U T	I N E =======================================


$EXEC:
		mov	byte [ss:A20OFF_COUNT], 0
		cmp	al, 5
		jnz	short Exec_@f
		pop	cx
		mov	cx, LeaveDOS
		push	cx

Exec_@f:				; ...
		push	bp
		mov	bp, sp
		sub	sp, 29		; sub sp, 30  ;	Retro DOS v4
		cmp	al, 5
		jbe	short Exec_Check_2

Exec_Bad_Fun:				; ...
		mov	byte [ss:EXTERR_LOCUS], 1
		mov	al, 1

Exec_Ret_Err:				; ...
		mov	sp, bp
		pop	bp
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

ExecReadyJ:				; ...
		call	ExecReady
		jmp	norm_ovl
; ---------------------------------------------------------------------------

Exec_Check_2:				; ...
		cmp	al, 2
		jz	short Exec_Bad_Fun
		cmp	al, 4
		jz	short Exec_Bad_Fun
		cmp	al, 5
		jz	short ExecReadyJ
		mov	[bp-4],	bx
		mov	word [bp-2], es
		mov	[bp-5],	al
		mov	byte [bp-6], 0
		mov	[bp-26], dx
		mov	word [bp-24], ds
		mov	si, dx
		call	DStrLen
		mov	[bp-22], cx
		mov	al, [ss:AllocMethod]
		mov	[ss:ALLOCMSAVE], al
		xor	al, al
		push	bp
		or	byte [ss:DOS_FLAG], 1
		call	$OPEN
		pushf
		and	byte [ss:DOS_FLAG], 0FEh ; not 1
		popf
		pop	bp
		jb	short Exec_Ret_Err
		mov	[bp-8],	ax
		mov	bx, ax
		xor	al, al
		call	$IOCTL
		jb	short Exec_BombJ
		test	dl, 80h
		jz	short Exec_Check_Environ
		mov	al, 2

Exec_BombJ:				; ...
		jmp	Exec_Bomb
; ---------------------------------------------------------------------------

BadEnv:					; ...
		mov	al, 0Ah
		jmp	Exec_Bomb
; ---------------------------------------------------------------------------

Exec_Check_Environ:			; ...
		mov	word [bp-18], 0
		mov	word [bp-14], 0
		test	byte [bp-5], 2
		jnz	short Exec_Read_Header
		lds	si, [bp-4]
		mov	ax, [si]
		or	ax, ax
		jnz	short Exec_Scan_Env
		mov	ds, [ss:CurrentPDB]
		mov	ax, [2Ch]
		or	ax, ax
		jz	short Exec_Read_Header

Exec_Scan_Env:				; ...
		mov	es, ax
		xor	di, di
		mov	cx, 8000h
		xor	al, al

Exec_Get_Environ_Len:			; ...
		repne scasb
		jnz	short BadEnv
		dec	cx
		js	short BadEnv
		scasb
		jnz	short Exec_Get_Environ_Len
		push	di
		lea	bx, [di+11h]
		add	bx, [bp-22]
		mov	cl, 4
		shr	bx, cl
		push	es
		call	$ALLOC
		pop	ds
		pop	cx
		jnb	short Exec_Save_Environ
		jmp	short Exec_No_Mem
; ---------------------------------------------------------------------------

Exec_Save_Environ:			; ...
		mov	es, ax
		mov	[bp-14], ax
		xor	si, si
		mov	di, si
		rep movsb
		mov	ax, 1
		stosw
		lds	si, [bp-26]
		mov	cx, [bp-22]
		rep movsb

Exec_Read_Header:			; ...
		push	ss
		pop	ds
		mov	cx, 26
		mov	dx, exec_signature
		push	es
		push	ds
		call	ExecRead
		pop	ds
		pop	es
		jb	short Exec_Bad_File
		or	ax, ax
		jz	short Exec_Bad_File
		cmp	ax, 26
		jnz	short Exec_Com_Filej
		test	word [exec_max_BSS], 0FFFFh
		jnz	short Exec_Check_Sig
		mov	byte [bp-6], 0FFh

Exec_Check_Sig:				; ...
		mov	ax, [exec_signature]
		cmp	ax, 'ZM'
		jz	short Exec_Save_Start
		cmp	ax, 'MZ'
		jz	short Exec_Save_Start

Exec_Com_Filej:				; ...
		jmp	Exec_Com_File
; ---------------------------------------------------------------------------

Exec_Save_Start:			; ...
		mov	ax, [exec_pages]
		mov	cl, 5
		shl	ax, cl
		sub	ax, [exec_par_dir]
		mov	[bp-12], ax
		test	byte [bp-5], 2
		jz	short Exec_Allocate
		les	di, [bp-4]
		mov	ax, [es:di]
		mov	[bp-20], ax
		mov	ax, [es:di+2]
		mov	[bp-10], ax
		jmp	Exec_Find_Res
; ---------------------------------------------------------------------------

Exec_No_Mem:				; ...
		mov	al, 8
		jmp	short Exec_Bomb
; ---------------------------------------------------------------------------

Exec_Bad_File:				; ...
		mov	al, 0Bh

Exec_Bomb:				; ...
		mov	bx, [bp-8]
		call	Exec_Dealloc
		call	LCritDisk
		push	ax
		push	bp
		call	$CLOSE
		pop	bp
		pop	ax
		jmp	Exec_Ret_Err
; ---------------------------------------------------------------------------

Exec_Chk_Mem:				; ...
		mov	al, [ss:AllocMethod]
		mov	bl, [ss:ALLOCMSAVE]
		mov	byte [ss:AllocMethod], bl
		test	bl, 40h
		jnz	short Exec_No_Mem
		test	al, 40h
		jz	short Exec_No_Mem
		mov	ax, [ss:SAVE_AX]
		jmp	short Exec_Norm_Alloc
; ---------------------------------------------------------------------------

Exec_Allocate:				; ...
		mov	byte [bp-29], 0
		cmp	word [exec_SS], 0
		jnz	short ea1
		cmp	word [exec_SP], 0
		jnz	short ea1
		inc	byte [bp-29]
		cmp	ax, 0FF0h	; 1000h-10h
		jnb	short ea1
		add	ax, 10h

ea1:					; ...
		test	byte [AllocMethod], 80h ; HIGH_FIRST
		jz	short Exec_Norm_Alloc
		or	byte [AllocMethod], 40h ; HIGH_ONLY

Exec_Norm_Alloc:			; ...
		mov	[SAVE_AX], ax
		mov	bx, 0FFFFh
		push	ds
		call	$ALLOC
		pop	ds
		mov	ax, [SAVE_AX]
		add	ax, 10h
		cmp	bx, 11h
		jb	short Exec_Chk_Mem
		cmp	ax, bx
		ja	short Exec_Chk_Mem
		test	byte [bp-6], 0FFh
		jnz	short Exec_BX_Max
		add	ax, [exec_min_BSS]
		jb	short Exec_Chk_Mem
		cmp	ax, bx
		ja	short Exec_Chk_Mem
		sub	ax, [exec_min_BSS]
		add	ax, [exec_max_BSS]
		jb	short Exec_BX_Max
		cmp	ax, bx
		jbe	short Exec_Got_Block

Exec_BX_Max:				; ...
		mov	ax, bx

Exec_Got_Block:				; ...
		push	ds
		mov	bx, ax
		mov	[bp-16], bx
		call	$ALLOC
		pop	ds
		jnb	short eat0
		jmp	Exec_Chk_Mem
; ---------------------------------------------------------------------------

eat0:					; ...
		mov	cl, [ALLOCMSAVE]
		mov	byte [AllocMethod], cl
		cmp	byte [bp-29], 0
		jz	short ea2
		cmp	bx, 1000h
		jnb	short ea2
		mov	cl, 4
		shl	bx, cl
		sub	bx, 100h
		mov	[exec_SP], bx

ea2:					; ...
		mov	[bp-18], ax
		add	ax, 10h
		test	byte [bp-6], 0FFh
		jz	short Exec_Use_AX
		add	ax, [bp-16]
		sub	ax, [bp-12]
		sub	ax, 10h

Exec_Use_AX:				; ...
		mov	[bp-10], ax
		mov	[bp-20], ax

Exec_Find_Res:				; ...
		mov	dx, [bp-20]
		mov	[bp-28], dx
		mov	dx, [exec_par_dir]
		push	dx
		mov	cl, 4
		shl	dx, cl
		pop	ax
		mov	cl, 12
		shr	ax, cl
		mov	cx, ax
		mov	bx, [bp-8]
		push	ds
		xor	al, al
		call	$LSEEK
		pop	ds
		jnb	short Exec_Big_Read
		jmp	Exec_Bomb
; ---------------------------------------------------------------------------

Exec_Big_Read:				; ...
		mov	bx, [bp-12]
		cmp	bx, 1000h
		jb	short Exec_Read_OK
		mov	bx, 0FE0h

Exec_Read_OK:				; ...
		sub	[bp-12], bx
		push	bx
		mov	cl, 4
		shl	bx, cl
		mov	cx, bx
		push	ds
		mov	ds, word [bp-20]
		xor	dx, dx
		push	cx
		call	ExecRead
		pop	cx
		pop	ds
		jb	short Exec_Bad_FileJ
		cmp	cx, ax
		pop	bx
		jz	short ExecCheckEnd
		sub	cx, ax
		cmp	cx, 512
		jnb	short Exec_Bad_FileJ

ExecCheckEnd:				; ...
		add	[bp-20], bx
		test	word [bp-12], 0FFFFh
		jnz	short Exec_Big_Read
		mov	cx, [bp-10]
		mov	ax, [exec_SS]
		add	ax, cx
		mov	[exec_init_SS], ax
		mov	ax, [exec_SP]
		mov	[exec_init_SP], ax
		les	ax, [exec_IP]
		mov	[exec_init_IP], ax
		mov	ax, es
		add	ax, cx
		mov	[exec_init_CS], ax
		xor	cx, cx
		mov	dx, [exec_rle_table]
		mov	bx, [bp-8]
		push	ds
		xor	ax, ax
		call	$LSEEK
		pop	ds
		jnb	short exec_get_entries

Exec_Bad_FileJ:				; ...
		jmp	Exec_Bad_File
; ---------------------------------------------------------------------------

exec_get_entries:			; ...
		mov	dx, [exec_rle_count]

exec_read_reloc:			; ...
		push	dx
		mov	dx, OPENBUF ; Exec_Internal_Buffer
		mov	cx, 396		; (Exec_Internal_Buffer_Size)/4)*4
		push	ds
		call	ExecRead
		pop	es
		pop	dx
		jb	short Exec_Bad_FileJ
		mov	cx, 99		; (Exec_Internal_Buffer_Size)/4
		mov	di, OPENBUF ; Exec_Internal_Buffer
		mov	si, [bp-10]

exec_reloc_one:				; ...
		or	dx, dx
		jz	short Exec_Set_PDBJ

exec_get_addr:
		lds	bx, [es:di]
		mov	ax, ds
		add	ax, [bp-28]
		mov	ds, ax
		add	[bx], si
		add	di, 4
		dec	dx
		loop	exec_reloc_one
		push	es
		pop	ds
		jmp	short exec_read_reloc
; ---------------------------------------------------------------------------

Exec_Set_PDBJ:				; ...
		push	es
		push	ax
		push	cx
		mov	es, word [bp-28]
		mov	ax, [ss:exec_init_CS]
		mov	cx, [ss:exec_init_IP]
		call	[ss:FixExePatch]
		call	[ss:Rational386PatchPtr]
		pop	cx
		pop	ax
		pop	es
		jmp	Exec_Set_PDB
; ---------------------------------------------------------------------------

Exec_No_Memj:				; ...
		jmp	Exec_No_Mem
; ---------------------------------------------------------------------------

Exec_Com_File:				; ...
		test	byte [bp-5], 2
		jz	short Exec_Alloc_Com_File
		lds	si, [bp-4]
		lodsw
		mov	[bp-20], ax
		mov	ax, 0FFFFh
		jmp	short Exec_Read_Block
; ---------------------------------------------------------------------------

Exec_Chk_Com_Mem:			; ...
		mov	al, [ss:AllocMethod]
		mov	bl, [ss:ALLOCMSAVE]
		mov	byte [ss:AllocMethod], bl
		test	bl, 40h
		jnz	short Exec_No_Memj
		test	al, 40h
		jz	short Exec_No_Memj
		mov	ax, [bp-18]
		xor	bx, bx
		call	ChangeOwner
		jmp	short Exec_Norm_Com_Alloc
; ---------------------------------------------------------------------------

Exec_Alloc_Com_File:			; ...
		test	byte [ss:AllocMethod], 80h
		jz	short Exec_Norm_Com_Alloc
		or	byte [ss:AllocMethod], 40h

Exec_Norm_Com_Alloc:			; ...
		mov	bx, 0FFFFh
		call	$ALLOC
		or	bx, bx
		jz	short Exec_Chk_Com_Mem
		mov	[bp-16], bx
		push	bx
		call	$ALLOC
		pop	bx
		mov	[bp-18], ax
		add	ax, 10h
		mov	[bp-20], ax
		xor	ax, ax
		cmp	bx, 1000h
		jnb	short Exec_Read_Com
		mov	ax, bx
		mov	cl, 4
		shl	ax, cl
		cmp	ax, 200h
		jbe	short Exec_Chk_Com_Mem
		sub	ax, 100h

Exec_Read_Com:				; ...
		sub	ax, 100h

Exec_Read_Block:			; ...
		push	ax
		mov	bx, [bp-8]
		xor	cx, cx
		mov	dx, cx
		xor	ax, ax
		call	$LSEEK
		pop	cx
		mov	ds, word [bp-20]
		xor	dx, dx
		push	cx
		call	ExecRead
		pop	si
		jnb	short OkRead
		jmp	Exec_Bad_File
; ---------------------------------------------------------------------------

OkRead:					; ...
		cmp	ax, si
		jnz	short OkRead2
		jmp	Exec_Chk_Com_Mem
; ---------------------------------------------------------------------------

OkRead2:				; ...
		mov	bl, [ss:ALLOCMSAVE]
		mov	byte [ss:AllocMethod], bl
		test	byte [bp-5], 2
		jnz	short Exec_Set_PDB
		mov	ax, [bp-20]
		sub	ax, 10h
		mov	[ss:exec_init_CS], ax
		mov	word [ss:exec_init_IP], 100h
		add	si, 0FEh
		cmp	si, 0FFFEh
		jz	short Exec_St_Ok
		add	si, 100h

Exec_St_Ok:				; ...
		mov	[ss:exec_init_SP], si
		mov	[ss:exec_init_SS], ax
		mov	ds, ax
		mov	word [si], 0
		call	word [ss:ChkCopyProt]

Exec_Set_PDB:				; ...
		mov	bx, [bp-8]
		call	Exec_Dealloc
		push	bp
		call	$CLOSE
		pop	bp
		call	Exec_Alloc
		test	byte [bp-5], 2 ; exec_func_overlay
		jz	short Exec_Build_Header
		call	Scan_Execname
		call	Scan_Special_Entries
		cmp	byte [ss:DriverLoad], 0
		jz	short norm_ovl
		push	si
		push	es
		les	si, [ss:BiosDataPtr]
		cmp	byte [es:si], 0
		jz	short sysinit_done
		mov	es, [ss:CurrentPDB]
		push	word [ss:SPECIAL_VERSION]
		pop	word [es:40h]
		jmp	short setver_done
; ---------------------------------------------------------------------------

sysinit_done:				; ...
		mov	byte [ss:DriverLoad], 0

setver_done:				; ...
		pop	es
		pop	si

norm_ovl:				; ...
		mov	sp, bp
		pop	bp
		jmp	SYS_RET_OK
; ---------------------------------------------------------------------------

Exec_Build_Header:			; ...
		mov	dx, [bp-18]
		mov	si, 1
		mov	ax, [bp-14]
		or	ax, ax
		jz	short No_Owner
		dec	ax
		mov	ds, ax
		mov	[si], dx

No_Owner:				; ...
		mov	ax, [bp-18]
		dec	ax
		mov	ds, ax
		mov	[si], dx
		push	ds
		pop	es
		mov	di, 8
		call	Scan_Execname
		push	cx
		push	si

MoveName:				; ...
		lodsb
		cmp	al, '.'
		jz	short mem_done
		stosb
		cmp	di, 16		; ARENAHEADERSIZE
		jnb	short mem_done
		loop	MoveName

mem_done:				; ...
		xor	al, al
		cmp	di, 16
		jnb	short Fill8
		stosb

Fill8:					; ...
		pop	si
		pop	cx
		call	Scan_Special_Entries
		push	dx
		mov	si, [bp-16]
		add	si, dx
		call	$DUP_PDB
		pop	dx
		push	word [bp-14]
		pop	word [es:2Ch]	; [ES:PDB.ENVIRON]
		push	word [ss:SPECIAL_VERSION]
		pop	word [es:40h]	; [ES:PDB.Version]
		lds	si, [bp-4]
		push	ds
		push	si
		lds	si, [si+6]
		mov	cx, 12
		push	cx
		mov	di, 5Ch
		mov	bl, [si]
		rep movsb
		xor	ax, ax
		stosw
		stosw
		pop	cx
		pop	si
		pop	ds
		push	ds
		push	si
		lds	si, [si+0Ah]
		mov	bh, [si]
		rep movsb
		stosw
		stosw
		pop	si
		pop	ds
		lds	si, [si+2]
		or	cl, 80h
		mov	di, cx
		rep movsb
		dec	cl
		mov	al, bh
		xor	bh, bh
		call	GetVisDrv
		jnb	short Exec_BL
		mov	bh, cl

Exec_BL:				; ...
		mov	al, bl
		xor	bl, bl
		call	GetVisDrv
		jnb	short Exec_Set_Return
		mov	bl, cl

Exec_Set_Return:			; ...
		call	Get_User_Stack
		push	word [si+14h]
		push	word [si+12h]
		push	word [si+14h]
		push	word [si+12h]
		pop	word [es:0Ah]	; [ES:PDB.EXIT]
		pop	word [es:0Ch]
		xor	ax, ax
		mov	ds, ax
		pop	word [88h]	; [addr_int_terminate] ; 22h*4
		pop	word [8Ah]
		mov	word [ss:DMAADD], 80h
		mov	ds, [ss:CurrentPDB]
		mov	word [ss:DMAADD+2], ds
		test	byte [bp-5], 1
		jz	short exec_go
		lds	si, [ss:exec_init_SP]
		les	di, [bp-4]
		mov	word [es:di+10h], ds
		dec	si
		dec	si
		mov	[si], bx
		mov	[es:di+0Eh], si
		lds	ax, [ss:exec_init_IP]
		mov	word [es:di+14h], ds
		mov	[es:di+12h], ax
		mov	sp, bp
		pop	bp
		jmp	SYS_RET_OK
; ---------------------------------------------------------------------------

exec_go:				; ...
		lds	si, [ss:exec_init_IP]
		les	di, [ss:exec_init_SP]
		mov	ax, es
		cmp	byte [ss:DosHasHMA], 0
		jz	short Xfer_To_User
		push	ds
		mov	ds, [cs:DosDSeg]
		or	byte [DOS_FLAG], 4	; EXECA20OFF
		mov	[A20OFF_PSP], dx
		mov	ax, ds
		pop	ds
		push	ax
		mov	ax, disa20_xfer
		push	ax
		mov	ax, es
		retf
; ---------------------------------------------------------------------------

Xfer_To_User:				; ...
		cli
		mov	byte [ss:INDOS], 0
		mov	ss, ax
		mov	sp, di
		sti
		push	ds
		push	si
		mov	es, dx
		mov	ds, dx
		mov	ax, bx
		retf

; =============== S U B	R O U T	I N E =======================================


ExecRead:
		call	Exec_Dealloc
		mov	bx, [bp-8]
		push	bp
		call	$READ
		pop	bp
		call	Exec_Alloc
		retn

; =============== S U B	R O U T	I N E =======================================


Exec_Dealloc:
		push	bx
		sub	bx, bx
		call	ECritDisk
		call	ChangeOwners
		pop	bx
		retn

; =============== S U B	R O U T	I N E =======================================


Exec_Alloc:
		push	bx
		mov	bx, [ss:CurrentPDB]
		call	ChangeOwners
		call	LCritDisk
		pop	bx
		retn

; =============== S U B	R O U T	I N E =======================================


ChangeOwners:
		pushf
		push	ax
		mov	ax, [bp-14]
		call	ChangeOwner
		mov	ax, [bp-18]
		call	ChangeOwner
		pop	ax
		popf

chgown_retn:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================


ChangeOwner:
		or	ax, ax
		jz	short chgown_retn
		dec	ax
		push	ds
		mov	ds, ax
		mov	[1], bx	; [ARENA.OWNER]
		pop	ds
		retn

; =============== S U B	R O U T	I N E =======================================


Scan_Execname:
		lds	si, [bp-26]

Scan_Execname1:				; ...
		mov	cx, si

Scan0:					; ...
		lodsb
		cmp	al, ':'
		jz	short Scan_Execname1
		cmp	al, '\'
		jz	short Scan_Execname1
		cmp	al, 0
		jnz	short Scan0
		sub	si, cx
		xchg	si, cx
		retn

; =============== S U B	R O U T	I N E =======================================


Scan_Special_Entries:
		dec	cx
		mov	word [ss:SPECIAL_VERSION], 1606h
		les	di, [ss:UU_IFS_DOS_CALL]
		mov	ax, es
		or	ax, di
		jz	short End_List

GetEntries:				; ...
		mov	al, [es:di]
		or	al, al
		jz	short End_List
		mov	[ss:TEMP_VAR2], di
		cmp	al, cl
		jnz	short SkipOne
		inc	di
		push	cx
		push	si
		push	ax

sse_next_char:				; ...
		lodsb
		call	UCase
		scasb
		jnz	short Not_Matched
		loop	sse_next_char
		pop	ax
		mov	ax, [es:di]
		mov	[ss:SPECIAL_VERSION], ax
		pop	si
		pop	cx
		jmp	short End_List
; ---------------------------------------------------------------------------

Not_Matched:				; ...
		pop	ax
		pop	si
		pop	cx

SkipOne:				; ...
		mov	di, [ss:TEMP_VAR2]
		xor	ah, ah
		add	di, ax
		add	di, 3
		jmp	short GetEntries
; ---------------------------------------------------------------------------

End_List:				; ...
		retn

; ---------------------------------------------------------------------------

$KEEP_PROCESS:				; ...
		push	ax
		mov	byte [ss:EXIT_TYPE], 3
		mov	es, [ss:CurrentPDB]
		cmp	dx, 6
		jnb	short Keep_Shrink
		mov	dx, 6

Keep_Shrink:				; ...
		mov	bx, dx
		push	bx
		push	es
		call	$SETBLOCK
		pop	ds
		pop	bx
		jb	short Keep_Done
		mov	ax, ds
		add	ax, bx
		mov	[2], ax	; [PDB.BLOCK_LEN]

Keep_Done:				; ...
		pop	ax
		jmp	short exit_inner
; ---------------------------------------------------------------------------

stay_resident:				; ...
		mov	ax, 3100h
		add	dx, 15
		rcr	dx, 1
		mov	cl, 3
		shr	dx, cl
		jmp	command
; ---------------------------------------------------------------------------

$EXIT:					; ...
		xor	ah, ah
		xchg	ah, [ss:DidCTRLC]
		or	ah, ah
		mov	byte [ss:EXIT_TYPE], 0	; EXIT_TERMINATE
		jz	short exit_inner
		mov	byte [ss:EXIT_TYPE], 1	; EXIT_CTRL_C
; START	OF FUNCTION CHUNK FOR FATALC

exit_inner:				; ...
		call	Get_User_Stack
		push	word [ss:CurrentPDB]
		pop	word [si+14h]
		jmp	short abort_inner
; END OF FUNCTION CHUNK	FOR FATALC
; ---------------------------------------------------------------------------

$ABORT:					; ...
		xor	al, al
		mov	byte [ss:EXIT_TYPE], 0	; EXIT_ABORT
; START	OF FUNCTION CHUNK FOR FATALC

abort_inner:				; ...
		mov	ah, [ss:EXIT_TYPE]
		mov	[ss:exit_code], ax
		call	Get_User_Stack
		mov	ds, word [si+14h]
		xor	ax, ax
		mov	es, ax
		mov	si, 10
		mov	di, 88h
		movsw
		movsw
		movsw
		movsw
		movsw
		movsw
		jmp	reset_environment
; END OF FUNCTION CHUNK	FOR FATALC
; ---------------------------------------------------------------------------

RetExePatch:
		retn

; =============== S U B	R O U T	I N E =======================================


arena_free_process:
		mov	ax, [ss:arena_head]

arena_free_process_start:
		mov	di, 0
		call	check_signature

arena_free_process_loop:
		jb	short check_signature_ok
		push	es
		pop	ds
		cmp	[1], bx	; [ARENA.OWNER]
		jnz	short arena_free_next
		mov	[1], di

arena_free_next:
		cmp	byte [di], 5Ah ; 'Z'
		jz	short arena_chk_umbs
		call	arena_next
		jmp	short arena_free_process_loop
; ---------------------------------------------------------------------------

arena_chk_umbs:
		mov	ax, [ss:UMB_HEAD]
		cmp	ax, 0FFFFh
		jz	short check_signature_ok
		mov	di, ds
		cmp	di, ax
		jnb	short check_signature_ok
		jmp	short arena_free_process_start

; =============== S U B	R O U T	I N E =======================================


arena_next:
		mov	ax, ds
		add	ax, [3]	; [ARENA.SIZE]
		inc	ax

; =============== S U B	R O U T	I N E =======================================


check_signature:
		mov	es, ax
		cmp	byte [es:di], 4Dh ;	'M'
		jz	short check_signature_ok
		cmp	byte [es:di], 5Ah ;	'Z'
		jz	short check_signature_ok
		stc

check_signature_ok:			; ...
		retn

; =============== S U B	R O U T	I N E =======================================


Coalesce:
		cmp	byte [di], 5Ah ; 'Z'
		jz	short check_signature_ok
		call	arena_next
		jb	short check_signature_ok
		cmp	[es:1], di
		jnz	short check_signature_ok
		mov	cx, [es:3]
		inc	cx
		add	[3], cx
		mov	cl, [es:di]
		mov	[di], cl
		jmp	short Coalesce

; =============== S U B	R O U T	I N E =======================================


$ALLOC:
		call	ECritDisk	; ECritMEM
		mov	ax, [ss:arena_head]
		mov	[ss:START_ARENA], ax
		test	byte [ss:AllocMethod], 0C0h ; HIGH_FIRST+HIGH_ONLY
		jz	short norm_alloc
		test	byte [ss:UMBFLAG], 1
		jz	short norm_alloc
		mov	ax, [ss:UMB_HEAD]
		mov	[ss:START_ARENA], ax

norm_alloc:				; ...
		xor	ax, ax
		mov	di, ax
		mov	word [ss:FirstArena], ax
		mov	word [ss:BestArena], ax
		mov	[ss:LastArena], ax
		push	ax

start_scan:				; ...
		mov	ax, [ss:START_ARENA]
		call	check_signature
		jb	short alloc_err

alloc_scan:				; ...
		push	es
		pop	ds
		cmp	[1], di
		jz	short alloc_free

alloc_next:				; ...
		test	byte [ss:UMBFLAG], 1
		jz	short norm_strat
		test	byte [ss:AllocMethod], 80h
		jz	short norm_strat
		mov	ax, [ss:START_ARENA]
		cmp	ax, [ss:arena_head]
		jnz	short norm_strat
		mov	ax, ds
		cmp	ax, [ss:UMB_HEAD]
		jmp	short alloc_chk_end
; ---------------------------------------------------------------------------

norm_strat:				; ...
		cmp	byte [di], 5Ah ; 'Z'

alloc_chk_end:				; ...
		jz	short alloc_end
		call	arena_next
		jnb	short alloc_scan

alloc_err:				; ...
		pop	ax

alloc_trashed:				; ...
		call	LCritDisk	; LCritMEM
		mov	al, 7

alloc_errj:				; ...
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

alloc_end:				; ...
		cmp	word [ss:FirstArena], 0
		jz	short alloc_chk
		jmp	alloc_do_split
; ---------------------------------------------------------------------------

alloc_chk:				; ...
		mov	ax, [ss:arena_head]
		cmp	ax, [ss:START_ARENA]
		jz	short alloc_fail
		test	byte [ss:AllocMethod], 40h
		jnz	short alloc_fail
		mov	[ss:START_ARENA], ax
		jmp	short start_scan
; ---------------------------------------------------------------------------

alloc_fail:				; ...
		call	Get_User_Stack
		pop	bx
		mov	[si+2],	bx
		call	LCritDisk	; LCritMEM
		mov	al, 8
		jmp	short alloc_errj
; ---------------------------------------------------------------------------

alloc_free:				; ...
		call	Coalesce
		jb	short alloc_err
		mov	cx, [3]
		pop	dx
		cmp	cx, dx
		jbe	short alloc_test
		mov	dx, cx

alloc_test:				; ...
		push	dx
		cmp	bx, cx
		ja	short alloc_next
		cmp	word [ss:FirstArena], 0
		jnz	short alloc_best
		mov	word [ss:FirstArena], ds

alloc_best:				; ...
		cmp	word [ss:BestArena], 0
		jz	short alloc_make_best
		push	es
		mov	es, [ss:BestArena]
		cmp	[es:3], cx
		pop	es
		jbe	short alloc_last

alloc_make_best:			; ...
		mov	word [ss:BestArena], ds

alloc_last:				; ...
		mov	[ss:LastArena], ds
		jmp	alloc_next
; ---------------------------------------------------------------------------

alloc_do_split_high:			; ...
		mov	ds, [ss:LastArena]
		mov	cx, [3]
		sub	cx, bx
		mov	dx, ds
		jz	short alloc_set_owner
		add	dx, cx
		mov	es, dx
		dec	cx
		xchg	bx, cx
		jmp	short alloc_set_sizes
; ---------------------------------------------------------------------------

alloc_do_split:				; ...
		xor	cx, cx
		mov	cl, [ss:AllocMethod]
		and	cx, 0FF3Fh
		cmp	cx, 1
		ja	short alloc_do_split_high
		mov	ds, [ss:FirstArena]
		jb	short alloc_get_size
		mov	ds, [ss:BestArena]

alloc_get_size:				; ...
		mov	cx, [3]
		sub	cx, bx
		mov	ax, ds
		mov	dx, ax
		jz	short alloc_set_owner
		add	ax, bx
		inc	ax
		mov	es, ax
		dec	cx

alloc_set_sizes:			; ...
		mov	[3], bx
		mov	[es:3], cx
		mov	bl, 4Dh	; 'M'
		xchg	bl, [di]
		mov	[es:di], bl
		mov	[es:1], di

alloc_set_owner:			; ...
		mov	ds, dx
		mov	ax, [ss:CurrentPDB]
		mov	[1], ax
		mov	ax, ds
		inc	ax
		pop	bx
		call	LCritDisk	; LCritMEM

alloc_ok:				; ...
		jmp	SYS_RET_OK

; =============== S U B	R O U T	I N E =======================================


$SETBLOCK:
		call	ECritDisk	; ECritMEM
		mov	di, 0
		mov	ax, es
		dec	ax
		call	check_signature
		jnb	short setblock_grab

setblock_bad:				; ...
		jmp	alloc_trashed
; ---------------------------------------------------------------------------

setblock_grab:				; ...
		mov	ds, ax
		call	Coalesce
		jb	short setblock_bad
		mov	cx, [3]
		push	cx
		cmp	bx, cx
		jbe	short alloc_get_size
		jmp	alloc_fail

; =============== S U B	R O U T	I N E =======================================


$DEALLOC:
		call	ECritDisk	; ECritMEM
		test	byte [ss:DOS_FLAG], 4 ; EXECA20OFF
		jz	short deallocate
		cmp	byte [ss:A20OFF_COUNT], 0
		jnz	short deallocate
		mov	byte [ss:A20OFF_COUNT], 1

deallocate:				; ...
		mov	di, 0
		mov	ax, es
		dec	ax
		call	check_signature
		jb	short dealloc_err
		mov	[es:1], di
		call	LCritDisk	; LCritMEM

dealloc_ok:				; ...
		jmp	short alloc_ok
; ---------------------------------------------------------------------------

dealloc_err:				; ...
		call	LCritDisk	; LCritMEM
		mov	al, 9

dealloc_errj:				; ...
		jmp	SYS_RET_ERR

; ---------------------------------------------------------------------------

$ALLOCOPER:				; ...
		or	al, al
		jz	short AllocGetStrat
		cmp	al, 1
		jz	short AllocSetStrat
		cmp	al, 2
		jz	short AllocGetLink
		cmp	al, 3
		jz	short AllocSetLink

AllocOperError:				; ...
		mov	byte [ss:EXTERR_LOCUS], 5
		mov	al, 1

AllocOperErrj:				; ...
		jmp	short dealloc_errj
; ---------------------------------------------------------------------------

AllocArenaError:			; ...
		mov	byte [ss:EXTERR_LOCUS], 5
		mov	al, 7
		jmp	short AllocOperErrj
; ---------------------------------------------------------------------------

AllocGetStrat:				; ...
		mov	al, [ss:AllocMethod]
		xor	ah, ah

AllocOperOK:				; ...
		jmp	short dealloc_ok
; ---------------------------------------------------------------------------

AllocSetStrat:				; ...
		push	bx
		and	bx, 0FF3Fh
		cmp	bx, 2
		pop	bx
		ja	short AllocOperError

AllocOperSet:
		mov	byte [ss:AllocMethod], bl

AllocOperSetOK:				; ...
		jmp	short AllocOperOK
; ---------------------------------------------------------------------------

AllocGetLink:				; ...
		mov	al, [ss:UMBFLAG]
		and	al, 1

AllocGetLinkOK:				; ...
		jmp	short AllocOperSetOK
; ---------------------------------------------------------------------------

AllocSetLink:				; ...
		mov	cx, [ss:UMB_HEAD]
		cmp	cx, 0FFFFh
		jz	short AllocOperError
		cmp	bx, 1
		jb	short UnlinkUmbs
		jz	short LinkUmbs
		jmp	short AllocOperError
; ---------------------------------------------------------------------------

UnlinkUmbs:				; ...
		test	byte [ss:UMBFLAG], 1
		jz	short unlinked
		call	GetLastArena
		jb	short AllocArenaError
		mov	byte [0], 5Ah ; 'Z'
		and	byte [ss:UMBFLAG], 0FEh

unlinked:				; ...
		jmp	short AllocGetLinkOK
; ---------------------------------------------------------------------------

LinkUmbs:				; ...
		test	byte [ss:UMBFLAG], 1
		jnz	short linked
		call	GetLastArena
		jb	short AllocArenaError
		mov	byte [0], 4Dh ; 'M'
		or	byte [ss:UMBFLAG], 1

linked:					; ...
		jmp	short unlinked

; =============== S U B	R O U T	I N E =======================================


GetLastArena:
		push	ax
		mov	ax, [ss:arena_head]
		mov	es, ax
		xor	di, di
		cmp	byte [es:di], 5Ah ;	'Z'
		jz	short GLA_done

GLA_next:				; ...
		mov	ds, ax
		call	arena_next
		jb	short GLA_err
		test	byte [ss:UMBFLAG], 1
		jnz	short GLA_chkumb
		cmp	byte [es:di], 5Ah ;	'Z'
		jmp	short GLA_@f
; ---------------------------------------------------------------------------

GLA_chkumb:				; ...
		cmp	ax, cx

GLA_@f:					; ...
		jnz	short GLA_next

GLA_done:				; ...
		test	byte [ss:UMBFLAG], 1
		jnz	short GLA_ret
		mov	ds, ax
		call	arena_next
		jb	short GLA_err
		cmp	ax, cx
		jnz	short GLA_err

GLA_ret:				; ...
		clc
		pop	ax
		retn
; ---------------------------------------------------------------------------

GLA_err:				; ...
		stc
		pop	ax
		retn

; ---------------------------------------------------------------------------
SERVERTAB:	dw SERVER_DISP	; ...
SERVERLEAVE:	dw SERVERRETURN	; ...
SERVER_DISP:	db 11			; ...
		dw SRV_CALL
		dw COMMIT_ALL
		dw CLOSE_NAME
		dw CLOSE_UID
		dw CLOSE_UID_PID
		dw GET_LIST
		dw GET_DOS_DATA
		dw SPOOL_OPER
		dw SPOOL_OPER
		dw SPOOL_OPER
		dw _$SetExtendedError
; ---------------------------------------------------------------------------

$ServerCall:				; ...
		cmp	al, 7
		jb	short SET_STUFF
		cmp	al, 9
		jbe	short NO_SET_ID

SET_STUFF:				; ...
		mov	si, dx
		mov	bx, [si+12h]
		test	byte [ss:IsWin386], 1
		jnz	short skip_win386
		mov	[ss:USER_ID], bx

skip_win386:				; ...
		mov	bx, [si+14h]
		mov	[ss:PROC_ID], bx

NO_SET_ID:				; ...
		push	word [cs:SERVERLEAVE]
		push	word [cs:SERVERTAB]
		push	ax
		call	TableDispatch
		mov	byte [ss:EXTERR_LOCUS], 1
		mov	al, 1

servercall_error:			; ...
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

SERVERRETURN:				; ...
		retn
; ---------------------------------------------------------------------------

COMMIT_ALL:				; ...
		xor	bx, bx
		push	ss
		pop	ds
		call	ECritDisk

CommitLoop:				; ...
		push	bx
		call	SFFromSFN
		jb	short CommitDone
		cmp	word [es:di], 0
		jz	short CommitNext
		cmp	word [es:di], 0FFFFh
		jz	short CommitNext
		test	word [es:di+5], 8000h
		jnz	short CommitNext
		mov	word [THISSFT], di
		mov	word [THISSFT+2], es
		call	DOS_COMMIT

CommitNext:				; ...
		pop	bx
		inc	bx
		jmp	short CommitLoop
; ---------------------------------------------------------------------------

CommitDone:				; ...
		call	LCritDisk	; LCritSFT
		pop	bx

jmp_to_SYS_RET_OK:			; ...
		jmp	SYS_RET_OK
; ---------------------------------------------------------------------------

CLOSE_NAME:				; ...
		call	far [ss:MFTCloN]

CheckReturns:				; ...
		jb	short func_err

jmp_to_jmp_to_SYS_RET_OK:		; ...
		jmp	short jmp_to_SYS_RET_OK
; ---------------------------------------------------------------------------

func_err:				; ...
		jmp	short servercall_error
; ---------------------------------------------------------------------------

CLOSE_UID:				; ...
		call	far [ss:MFTclU]
		jmp	short CheckReturns
; ---------------------------------------------------------------------------

CLOSE_UID_PID:				; ...
		call	far [ss:MFTCloseP]
		jmp	short CheckReturns
; ---------------------------------------------------------------------------

GET_LIST:				; ...
		call	far [ss:MFT_get]
		jb	short func_err
		call	Get_User_Stack
		mov	[si+2],	bx
		mov	[si+0Ah], di
		mov	word [si+10h], es

SetCXOK:				; ...
		mov	[si+4],	cx

third_jmp_short_SYS_RET_OK:		; ...
		jmp	short jmp_to_jmp_to_SYS_RET_OK
; ---------------------------------------------------------------------------

SRV_CALL:				; ...
		pop	ax
		push	ds
		push	si
		call	Get_User_Stack
		pop	di
		pop	es
		call	XCHGP
		push	si
		mov	cx, 6
		rep movsw
		inc	di
		inc	di
		movsw
		movsw
		pop	si
		mov	ax, [si]
		mov	bx, [si+2]
		mov	cx, [si+4]
		mov	dx, [si+6]
		mov	di, [si+0Ah]
		mov	es, word [si+0Eh]
		push	word [si+8]
		mov	ds, word [si+0Ch]
		pop	si
		mov	[ss:SAVEDS], ds
		mov	[ss:SAVEBX], bx
		mov	byte [ss:FSHARING], 0FFh
		jmp	REDISP
; ---------------------------------------------------------------------------

GET_DOS_DATA:				; ...
		push	ss
		pop	es
		mov	di, ERRORMODE ; SWAP_START
		mov	cx, SWAP_END
		mov	dx, USER_IN_AX ;	SWAP_ALWAYS
		sub	cx, di
		sub	dx, di
		shr	cx, 1
		adc	cx, 0
		shl	cx, 1
		call	Get_User_Stack
		mov	word [si+0Eh], es
		mov	[si+8],	di
		mov	[si+6],	dx
		jmp	short SetCXOK
; ---------------------------------------------------------------------------

SPOOL_OPER:				; ...
		push	ax
		mov	ax, 1125h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - REDIRECTED PRINTER MODE
					; STACK: WORD subfunction
					; Return: CF set on error, AX =	error code
					; STACK	unchanged
		pop	bx
		jb	short func_err2
		jmp	short third_jmp_short_SYS_RET_OK
; ---------------------------------------------------------------------------

func_err2:				; ...
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

_$SetExtendedError:			; ...
		mov	ax, [si]
		mov	word [ss:EXTERR], ax
		mov	ax, [si+0Ah]
		mov	word [ss:EXTERRPT], ax
		mov	ax, [si+0Eh]
		mov	word [ss:EXTERRPT+2], ax
		mov	ax, [si+2]
		mov	[ss:EXTERR_ACT_CLASS], ax
		mov	ax, [si+4]
		mov	byte [ss:EXTERR_LOCUS], ah
		retn

; =============== S U B	R O U T	I N E =======================================


pJFNFromHandle:
		mov	es, [cs:DosDSeg]
		mov	es, [es:CurrentPDB]
		cmp	bx, [es:32h]	; [ES:PDB.JFN_Length]
		jb	short pjfn10
		mov	al, 6

ReturnCarry:				; ...
		stc
		retn
; ---------------------------------------------------------------------------

pjfn10:					; ...
		les	di, [es:34h]	; [ES:PDB.JFN_Pointer]
		add	di, bx

pJFNFromHandle_error:			; ...
		retn

; =============== S U B	R O U T	I N E =======================================


SFFromHandle:
		call	pJFNFromHandle
		jb	short pJFNFromHandle_error
		cmp	byte [es:di], 0FFh
		jnz	short GetSF
		mov	al, 6
		jmp	short ReturnCarry
; ---------------------------------------------------------------------------

GetSF:					; ...
		push	bx
		mov	bl, [es:di]
		xor	bh, bh
		call	SFFromSFN
		pop	bx
		retn

; =============== S U B	R O U T	I N E =======================================


SFFromSFN:
		mov	es, [cs:DosDSeg]
		les	di, [es:SFT_ADDR]

sfsfn5:					; ...
		cmp	bx, [es:di+4]
		jb	short sfsfn7
		sub	bx, [es:di+4]
		les	di, [es:di]
		cmp	di, 0FFFFh
		jnz	short sfsfn5
		stc
		retn
; ---------------------------------------------------------------------------

sfsfn7:					; ...
		push	ax
		mov	ax, 59		; SF_ENTRY.size
		mul	bl
		add	di, ax
		pop	ax
		add	di, 6
		retn			; SFT.SFTable

; =============== S U B	R O U T	I N E =======================================


JFNFree	:
		xor	bx, bx

jfnf1:					; ...
		call	pJFNFromHandle
		jb	short jfnf5
		cmp	byte [es:di], 0FFh
		jz	short jfnfx
		inc	bx
		jmp	short jfnf1
; ---------------------------------------------------------------------------

jfnf5:					; ...
		mov	al, 4

jfnfx:					; ...
		retn

; =============== S U B	R O U T	I N E =======================================


SFNFree	:
		push	ax
		xor	bx, bx

sfnf5:					; ...
		push	bx
		call	SFFromSFN
		pop	bx
		jb	short sfnf95
		cmp	word [es:di], 0
		jz	short sfnf20
		cmp	word [es:di], 0FFFFh
		jz	short sfnf10

sfnf7:					; ...
		inc	bx
		jmp	short sfnf5
; ---------------------------------------------------------------------------

sfnf10:					; ...
		mov	ax, [ss:USER_ID]
		cmp	[es:di+2Fh], ax
		jnz	short sfnf7
		mov	ax, [ss:PROC_ID]
		cmp	[es:di+31h], ax
		jnz	short sfnf7

sfnf20:					; ...
		mov	word [es:di], 0FFFFh
		mov	ax, [ss:USER_ID]
		mov	[es:di+2Fh], ax
		mov	ax, [ss:PROC_ID]
		mov	[es:di+31h], ax
		pop	ax
		clc
		retn
; ---------------------------------------------------------------------------

sfnf95:					; ...
		pop	ax
		mov	al, 4
		retn

; =============== S U B	R O U T	I N E =======================================


$CLOSE:
		call	CheckOwner
		jb	short CloseError
		push	ss
		pop	ds
		mov	word [THISSFT], di
		mov	word [THISSFT+2], es
		cmp	word [es:di], 1
		jz	short FreeJFN
		mov	al, [es:di+2]
		and	al, 0F0h
		cmp	al, 70h
		jz	short PostFree

FreeJFN:				; ...
		call	pJFNFromHandle
		mov	byte [es:di], 0FFh

PostFree:				; ...
		call	DOS_CLOSE
		jb	short CloseError
		mov	ah, 3Eh

Close_OK:				; ...
		jmp	SYS_RET_OK
; ---------------------------------------------------------------------------

CloseError:				; ...
		jmp	SYS_RET_ERR

; ---------------------------------------------------------------------------

$COMMIT:				; ...
		call	CheckOwner
		jb	short CommitError
		push	ss
		pop	ds
		mov	word [THISSFT], di
		mov	word [THISSFT+2], es
		call	DOS_COMMIT
		jb	short CommitError
		mov	ah, 68h
; START	OF FUNCTION CHUNK FOR $READ

CommitOk:				; ...
		jmp	short Close_OK
; ---------------------------------------------------------------------------

CommitError:				; ...
		jmp	short CloseError
; END OF FUNCTION CHUNK	FOR $READ
; ---------------------------------------------------------------------------

$ExtHandle:				; ...
		xor	bp, bp
		cmp	bx, 20
		jnb	short exth2
		mov	bx, 20		; FILPERPROC

exth2:					; ...
		mov	es, [ss:CurrentPDB]
		mov	cx, [es:32h]	; [ES:PDB.JFN_Length]
		cmp	bx, cx
		jz	short ok_done
		ja	short larger
		mov	bp, 1
		mov	ds, word [es:36h] ; [ES:PDB.JFN_Pointer+2]
		mov	si, bx
		sub	cx, bx

chck_handles:				; ...
		cmp	byte [si], 0FFh
		jnz	short too_many_files
		inc	si
		loop	chck_handles
		cmp	bx, 20
		ja	short larger
		mov	bp, 2
		mov	di, 24		; PDB.JFN_TABLE
		push	bx
		jmp	short movhandl
; ---------------------------------------------------------------------------

larger:					; ...
		cmp	bx, 0FFFFh
		jz	short invalid_func
		clc
		push	bx
		add	bx, 0Fh
		mov	cl, 4
		rcr	bx, cl
		and	bx, 1FFFh
		push	bp
		call	$ALLOC
		pop	bp
		jb	short no_memory
		mov	es, ax
		xor	di, di

movhandl:				; ...
		mov	ds, [ss:CurrentPDB]
		test	bp, 3
		jz	short enlarge
		pop	cx
		push	cx
		jmp	short copy_hand
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR $READ

ok_done:				; ...
		jmp	short CommitOk
; END OF FUNCTION CHUNK	FOR $READ
; ---------------------------------------------------------------------------

too_many_files:				; ...
		mov	al, 4
; START	OF FUNCTION CHUNK FOR $READ

CommitErrorj:				; ...
		jmp	short CommitError
; END OF FUNCTION CHUNK	FOR $READ
; ---------------------------------------------------------------------------

enlarge:				; ...
		mov	cx, [32h]	; [PDB.JFN_Length]

copy_hand:				; ...
		mov	dx, cx
		lds	si, [34h]
		rep movsb
		pop	cx
		push	cx
		sub	cx, dx
		mov	al, 0FFh
		rep stosb
		mov	ds, [ss:CurrentPDB]
		cmp	word [34h], 0 ; [PDB.JFN_Pointer]
		jnz	short update_info
		push	bp
		push	ds
		push	es
		mov	es, word [36h]	; [PDB.JFN_Pointer+2]
		call	$DEALLOC
		pop	es
		pop	ds
		pop	bp

update_info:				; ...
		test	bp, 2
		jz	short non_psp
		mov	word [34h], 18h ; 24
		jmp	short final
; ---------------------------------------------------------------------------

non_psp:				; ...
		mov	word [34h], 0

final:					; ...
		mov	word [36h], es
		pop	word [32h]
; START	OF FUNCTION CHUNK FOR $READ

ExtHandle_OK:				; ...
		jmp	short ok_done
; END OF FUNCTION CHUNK	FOR $READ
; ---------------------------------------------------------------------------

no_memory:				; ...
		pop	bx
		mov	al, 8
; START	OF FUNCTION CHUNK FOR $READ

CommitErrorj2:				; ...
		jmp	short CommitErrorj
; END OF FUNCTION CHUNK	FOR $READ
; ---------------------------------------------------------------------------

invalid_func:				; ...
		mov	al, 1
; START	OF FUNCTION CHUNK FOR $READ

CommitErrorj3:				; ...
		jmp	short CommitErrorj2
; END OF FUNCTION CHUNK	FOR $READ

; =============== S U B	R O U T	I N E =======================================


$READ	:

; FUNCTION CHUNK AT A774 SIZE 00000004 BYTES
; FUNCTION CHUNK AT A7E0 SIZE 00000002 BYTES
; FUNCTION CHUNK AT A7E4 SIZE 00000002 BYTES
; FUNCTION CHUNK AT A82F SIZE 00000002 BYTES
; FUNCTION CHUNK AT A834 SIZE 00000002 BYTES
; FUNCTION CHUNK AT A838 SIZE 00000002 BYTES

		mov	si, DOS_READ

ReadDo:					; ...
		call	pJFNFromHandle
		jb	short ReadError
		mov	al, [es:di]
		call	CheckOwner
		jnb	short ReadSetup

ReadError:				; ...
		jmp	short CommitErrorj3
; ---------------------------------------------------------------------------

ReadSetup:				; ...
		mov	word [ss:THISSFT], di
		mov	word [ss:THISSFT+2], es
		test	byte [es:di+3], 20h
		jz	short needi24
		or	byte [ss:EXTOPEN_ON], 2

needi24:				; ...
		push	word [ss:DMAADD]
		push	word [ss:DMAADD+2]
		call	Align_Buffer
		push	ss
		pop	ds
		call	si ; DOS_READ
		pop	word [DMAADD+2]
		pop	word [DMAADD]
		jnb	short READ_OK
		jmp	short ReadError
; ---------------------------------------------------------------------------

READ_OK:				; ...
		mov	ax, cx

Read_OK_j:				; ...
		jmp	short ExtHandle_OK

; =============== S U B	R O U T	I N E =======================================


Align_Buffer:
		mov	bx, dx
		push	cx
		mov	cl, 4
		shr	bx, cl
		pop	cx
		mov	ax, ds
		add	ax, bx
		mov	ds, ax
		and	dx, 0Fh
		mov	word [ss:DMAADD], dx
		mov	word [ss:DMAADD+2], ds
		retn

; ---------------------------------------------------------------------------

$WRITE:					; ...
		mov	si, DOS_WRITE
		jmp	short ReadDo

; =============== S U B	R O U T	I N E =======================================


$LSEEK:
		call	CheckOwner

LSeekError:				; ...
		jnb	short CHKOWN_OK
		jmp	short ReadError
; ---------------------------------------------------------------------------

CHKOWN_OK:				; ...
		cmp	al, 2
		jbe	short LSeekDisp
		mov	byte [ss:EXTERR_LOCUS], 1
		mov	al, 1

jmp_to_ReadError:			; ...
		jmp	short ReadError
; ---------------------------------------------------------------------------

LSeekDisp:				; ...
		cmp	al, 1
		jb	short LSeekStore
		ja	short LSeekEOF
		add	dx, [es:di+15h]
		adc	cx, [es:di+17h]

LSeekStore:				; ...
		mov	ax, cx
		xchg	ax, dx

LSeekSetpos:				; ...
		mov	[es:di+15h], ax
		mov	[es:di+17h], dx
		call	Get_User_Stack
		mov	[si+6],	dx

jmp_to_Read_OK_j:			; ...
		jmp	short Read_OK_j
; ---------------------------------------------------------------------------

LSeekEOF:				; ...
		test	byte [es:di+6], 80h
		jnz	short Check_LSeek_Mode

LOCAL_LSeek:				; ...
		add	dx, [es:di+11h]
		adc	cx, [es:di+13h]
		jmp	short LSeekStore
; ---------------------------------------------------------------------------

Check_LSeek_Mode:			; ...
		test	byte [es:di+3], 80h
		jnz	short LOCAL_LSeek
		mov	ax, [es:di+2]
		and	ax, 0F0h
		cmp	ax, 40h
		jz	short NET_LSEEK
		cmp	ax, 30h
		jnz	short LOCAL_LSeek

NET_LSEEK:				; ...
		mov	ax, 1121h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - SEEK	FROM END OF REMOTE FILE
					; CX:DX	= offset (in bytes) from end
					; ES:DI	-> SFT,	SFT DPB	field -> DPB of	drive with file
					; SS = DOS CS
					; Return: CF set on error
					; CF clear if successful, DX:AX	= new file position
		jnb	short LSeekSetpos

jmp_to_jmp_ReadError:			; ...
		jmp	short jmp_to_ReadError

; ---------------------------------------------------------------------------

$FILE_TIMES:				; ...
		cmp	al, 2
		jnb	short inval_func
		call	CheckOwner
		jb	short LSeekError
		or	al, al
		jnz	short ft_set_time
		cli
		mov	cx, [es:di+0Dh]
		mov	dx, [es:di+0Fh]
		sti
		call	Get_User_Stack
		mov	[si+4],	cx
		mov	[si+6],	dx
		jmp	short ok_ret
; ---------------------------------------------------------------------------

ft_set_time:				; ...
		call	ECritDisk	; ECritSFT
		mov	[es:di+0Dh], cx
		mov	[es:di+0Fh], dx
		xor	ax, ax
		call	far [ss:ShSU]
		and	word [es:di+5], 0FFBFh
		or	word [es:di+5], 4000h
		call	LCritDisk	; LCritSFT

ok_ret:					; ...
		jmp	short jmp_to_Read_OK_j
; ---------------------------------------------------------------------------

inval_func:				; ...
		mov	byte [ss:EXTERR_LOCUS], 1
		mov	al, 1

jmp3_to_ReadError:			; ...
		jmp	short jmp_to_jmp_ReadError
; ---------------------------------------------------------------------------

$DUP:					; ...
		mov	ax, bx
		call	JFNFree

DupErrorCheck:				; ...
		jb	short DupErr
		push	es
		push	di
		pop	si
		pop	ds
		xchg	ax, bx
		call	CheckOwner
		jb	short DupErr
		call	DOS_Dup_Direct
		call	pJFNFromHandle
		mov	bl, [es:di]
		mov	[si], bl
		jmp	short ok_ret
; ---------------------------------------------------------------------------

DupErr:					; ...
		jmp	short jmp3_to_ReadError
; ---------------------------------------------------------------------------

$DUP2:					; ...
		push	bx
		push	cx
		mov	bx, cx
		call	$CLOSE
		pop	bx
		pop	ax
		call	pJFNFromHandle
		jmp	short DupErrorCheck

; =============== S U B	R O U T	I N E =======================================


CheckOwner:
		call	SFFromHandle
		jb	short co_ret_label
		push	ax
		test	byte [ss:IsWin386], 1
		jz	short no_win386
		xor	ax, ax
		jmp	short _skip_win386
; ---------------------------------------------------------------------------

no_win386:				; ...
		mov	ax, [ss:USER_ID]
		cmp	ax, [es:di+47]	; [es:di+SF_ENTRY.sf_UID]

_skip_win386:				; ...
		pop	ax
		jnz	short CheckOwner_err
		retn
; ---------------------------------------------------------------------------

CheckOwner_err:				; ...
		mov	al, 6
		stc

co_ret_label:				; ...
		retn

; ---------------------------------------------------------------------------

$AssignOper:				; ...
		cmp	al, 7
		jnz	short chk08

srinuse:				; ...
		push	ax
		mov	al, dl
		call	GetCDSFromDrv
		pop	ax
		jb	short baddrv
		cmp	word [si+45h], 0
		jz	short baddrv
		cmp	al, 7
		jnz	short resetdrv
		or	word [si+43h], 4000h
		jmp	short okdone
; ---------------------------------------------------------------------------

resetdrv:				; ...
		and	word [si+43h], 0BFFFh
		jmp	short okdone
; ---------------------------------------------------------------------------

baddrv:					; ...
		mov	ax, 0Fh
		jmp	short ASS_ERR
; ---------------------------------------------------------------------------

chk08:					; ...
		cmp	al, 8
		jz	short srinuse
		push	ax
		mov	ax, 111Eh
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - DO REDIRECTION
					; SS = DOS CS
					; STACK: WORD function to execute
					; Return: CF set on error, AX =	error code
					; STACK	unchanged
		pop	bx
		jb	short ASS_ERR

okdone:					; ...
		jmp	SYS_RET_OK
; ---------------------------------------------------------------------------

ASS_ERR:				; ...
		jmp	SYS_RET_ERR

; =============== S U B	R O U T	I N E =======================================


FIND_DPB:
		lds	si, [ss:DPBHEAD]

fdpb5:					; ...
		cmp	si, 0FFFFh
		jz	short fdpb10
		cmp	al, [si]	; [SI+DPB.DRIVE]
		jz	short ret_label15
		lds	si, [si+19h]	; [SI+DPB.NEXT_DPB]
		jmp	short fdpb5
; ---------------------------------------------------------------------------

fdpb10:					; ...
		stc

ret_label15:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================


InitCDS	:
		push	ax
		les	di, [ss:THISCDS]
		mov	word [es:di+43h], 0
		sub	al, 40h	; '@'
		cmp	[ss:NUMIO], al
		jb	short icdsx
		dec	ax
		push	ax
		add	al, 'A'
		mov	ah, ':'
		mov	[es:di], ax
		mov	word [es:di+2], '\'
		or	byte [es:di+44h], 40h
		sub	ax, ax
		mov	[es:di+49h], ax
		mov	[es:di+4Bh], ax
		mov	al, 2
		mov	[es:di+4Fh], ax
		pop	ax
		push	ds
		push	si
		call	FIND_DPB
		jb	short icds5
		mov	[es:di+45h], si
		mov	word [es:di+47h], ds

icds5:					; ...
		pop	si
		pop	ds

icdsx:					; ...
		pop	ax

RET45:					; ...
		retn

; ---------------------------------------------------------------------------

$UserOper:				; ...
		push	ax
		sub	al, 1
		pop	ax
		jb	short UserGet
		jz	short UserSet
		cmp	al, 5
		jbe	short UserPrint
		mov	byte [ss:EXTERR_LOCUS], 1
		mov	al, 1

useroper_error:				; ...
		jmp	short ASS_ERR
; ---------------------------------------------------------------------------

UserGet:				; ...
		push	ds
		pop	es
		mov	di, dx
		mov	cx, [ss:MYNUM]
		call	Get_User_Stack
		mov	[si+4],	cx
		push	ss
		pop	ds
		mov	si, MYNAME

UserMove:				; ...
		mov	cx, 15
		rep movsb
		xor	ax, ax
		stosb

UserBye:				; ...
		jmp	SYS_RET_OK
; ---------------------------------------------------------------------------

UserSet:				; ...
		mov	[ss:MYNUM], cx
		mov	si, dx
		push	ss
		pop	es
		mov	di, MYNAME
		inc	byte [ss:DIFFNAM]
		jmp	short UserMove
; ---------------------------------------------------------------------------

UserPrint:				; ...
		push	ax
		mov	ax, 111Fh
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - PRINTER SETUP
					; STACK: WORD function
					; Return: CF set on error, AX =	error code
					; STACK	unchanged
		pop	dx
		jnb	short OKPA
		jmp	short useroper_error
; ---------------------------------------------------------------------------

OKPA:					; ...
		jmp	short UserBye

; =============== S U B	R O U T	I N E =======================================


GetVisDrv:
		call	GETTHISDRV
		jb	short RET45
		push	ds
		push	si
		lds	si, [ss:THISCDS]
		test	word [si+43h], 2000h
		pop	si
		pop	ds
		jz	short RET45
		mov	byte [ss:DrvErr], 0Fh
		stc
		retn

; =============== S U B	R O U T	I N E =======================================


GETTHISDRV:
		or	al, al
		jnz	short GTD10
		mov	al, [ss:CURDRV]
		inc	ax

GTD10:					; ...
		dec	ax
		push	ds
		push	si
		mov	byte [ss:EXTERR_LOCUS], 2
		test	byte [ss:FSHARING], 0FFh
		jz	short GTD20
		push	ax
		push	es
		push	di
		mov	word [ss:THISCDS], DUMMYCDS
		mov	word [ss:THISCDS+2], ss
		add	al, 'A'
		call	InitCDS
		test	word [es:di+43h], 4000h
		pop	di
		pop	es
		pop	ax
		jz	short GTD30
		jmp	short GTDX
; ---------------------------------------------------------------------------

GTD20:					; ...
		call	GetCDSFromDrv
		jb	short GTD30
		test	word [si+43h], 4000h
		jnz	short GTDX

GTD30:					; ...
		mov	al, 0Fh
		mov	byte [ss:DrvErr], al
		mov	byte [ss:EXTERR_LOCUS], 1
		stc

GTDX:					; ...
		pop	si
		pop	ds
		retn

; =============== S U B	R O U T	I N E =======================================


GetCDSFromDrv:
		cmp	al, [ss:CDSCOUNT]
		jb	short GetCDS
		stc
		retn
; ---------------------------------------------------------------------------

GetCDS:					; ...
		push	bx
		push	ax
		lds	si, [ss:CDSADDR]
		mov	bl, 88		; curdir.size
		mul	bl
		add	si, ax
		mov	word [ss:THISCDS], si
		mov	word [ss:THISCDS+2], ds
		pop	ax
		pop	bx
		clc
		retn

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

TransFCB:
		push	bp
		mov	bp, sp
		sub	sp, 16
		push	ss
		pop	es
		push	es
		push	di
		lea	di, [bp-16]	; FCBTmp
		mov	byte [ss:EXTFCB], 0
		mov	byte [ss:SATTRIB], 0
		call	GetExtended
		jz	short GetDrive
		mov	al, [si-1]
		mov	byte [ss:SATTRIB], al
		mov	byte [ss:EXTFCB], 0FFh

GetDrive:				; ...
		lodsb
		call	GETTHISDRV
		jb	short BadPack
		call	TextFromDrive
		mov	cx, 11
		push	si

FCBScan:				; ...
		lodsb
		call	GetCharType
		test	al, 8
		jz	short BadPack
		loop	FCBScan
		pop	si
		mov	bx, di
		call	PackName
		pop	di
		pop	es
		push	ss
		pop	ds
		lea	si, [bp-16]	;  FCBTmp
		cmp	byte [bx], 0
		jz	short BadPack
		push	bp
		call	TransPathSet
		pop	bp
		jnb	short FCBRet

BadPack:				; ...
		stc
		mov	al, 3

FCBRet:					; ...
		mov	sp, bp
		pop	bp

TransPath_retn:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================


TransPath:
		xor	al, al
		jmp	short SetSplice

; =============== S U B	R O U T	I N E =======================================


TransPathSet:

; FUNCTION CHUNK AT AC6D SIZE 000000A5 BYTES

		mov	al, 0FFh

SetSplice:				; ...
		mov	byte [ss:NoSetDir], al
		mov	al, 0FFh

TransPathNoSet:				; ...
		mov	[ss:FSPLICE], al
		mov	byte [ss:CMETA], 0FFh
		mov	[ss:WFP_START], di
		mov	word [ss:CURR_DIR_END], 0FFFFh
		push	ss
		pop	es
		lea	bp, [di+134]	; lea bp,[di+TEMPLEN]
		test	byte [ss:FSHARING], 0FFh
		jz	short CheckUNC
		call	DriveFromText
		call	GETTHISDRV
		jb	short NoPath
		call	TextFromDrive
		lea	bx, [di+1]
		call	Canonicalize
		jb	short TransPath_retn
		push	ss
		pop	ds
		mov	si, [WFP_START]
		test	byte [FSPLICE], 0FFh
		jz	short NoServerSplice
		call	Splice

NoServerSplice:				; ...
		push	ss
		pop	ds
		les	di, [THISCDS]
		call	ECritDisk
		call	FATREAD_CDS
		call	LCritDisk

NoPath:					; ...
		mov	al, 3
		retn
; ---------------------------------------------------------------------------

CheckUNC:				; ...
		mov	word [ss:THISCDS], 0FFFFh
		mov	ax, 1123h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - QUALIFY REMOTE FILENAME
					; DS:SI	-> ASCIZ filename to canonicalize
					; ES:DI	-> 128-byte buffer for qualified name
					; Return: CF set if not	resolved
		jnb	short UNCDone
		call	DriveFromText
		push	ax
		mov	ax, [si]
		call	PATHCHRCMP
		xchg	ah, al
		call	PATHCHRCMP
		jnz	short CheckDevice
		cmp	ah, al
		jnz	short CheckDevice
		pop	ax
		movsw

UNCCpy:					; ...
		lodsb
		call	UCase
		or	al, al
		jz	short UNCTerm
		call	PATHCHRCMP
		mov	bx, di
		stosb
		jnz	short UNCCpy
		call	Canonicalize

UNCDone:				; ...
		push	ss
		pop	ds
		retn
; ---------------------------------------------------------------------------

UNCTerm:				; ...
		stosb
		jmp	short UNCDone
; ---------------------------------------------------------------------------

CheckDevice:				; ...
		pop	ax
		cmp	byte [si], 0
		jnz	short CheckPath
		mov	al, 2
		stc
		retn
; ---------------------------------------------------------------------------

CheckPath:				; ...
		push	ax
		push	bp
		call	no5Dshere	; call CheckThisDevice
		pop	bp
		pop	ax
		jnb	short DoFile
		mov	byte [ss:FSHARING], 0FFh
		call	GETTHISDRV
		mov	byte [ss:FSHARING], 0
		call	TextFromDrive
		mov	al, '/'
		stosb
		call	StrCpy
		clc
		push	ss
		pop	ds

DoFile_retn:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================

; Attributes: thunk

no5Dshere:
		jmp	CheckThisDevice

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR TransPathSet

DoFile:					; ...
		call	GetVisDrv
		mov	al, 3
		jb	short DoFile_retn
		push	ds
		push	si
		push	es
		push	di
		call	ValidateCDS
		pop	di
		pop	es
		pop	si
		pop	ds
		mov	al, 3
		jb	short DoFile_retn
		push	ds
		push	si
		lds	si, [ss:THISCDS]
		mov	bx, di
		add	bx, [si+79]
		lea	bp, [di+134]
		call	FStrCpy
		dec	di
		mov	al, '\'
		cmp	[es:di-1], al
		jz	short GetOrig
		stosb

GetOrig:				; ...
		dec	di
		pop	si
		pop	ds
		call	PathSep
		jnz	short PathAssure
		or	al, al
		jz	short DoCanon
		mov	di, bx

SkipPath:				; ...
		lodsb
		call	PATHCHRCMP
		jz	short SkipPath
		dec	si
		or	al, al
		jz	short DoCanon

PathAssure:				; ...
		mov	al, '\'
		stosb

DoCanon:				; ...
		call	Canonicalize
		jb	short DoFile_retn
		push	ss
		pop	ds
		mov	di, [WFP_START]
		lds	si, [THISCDS]
		call	PathPref
		jnz	short DoSplice
		mov	al, [si-1]
		call	PATHCHRCMP
		jz	short DoSplice

Pathline:
		cmp	byte [es:di], 0
		jz	short DoSplice
		inc	di
		mov	[ss:CURR_DIR_END], di

DoSplice:				; ...
		push	ss
		pop	ds
		mov	si, [WFP_START]
		xor	cx, cx
		test	byte [FSPLICE], 0FFh
		jz	short SkipSplice
		call	Splice

SkipSplice:				; ...
		push	ss
		pop	ds
		les	di, [THISCDS]
		test	word [es:di+67], 8000h
		jnz	short Done
		jcxz	Done
		call	ECritDisk
		call	FATREAD_CDS
		call	LCritDisk
		mov	al, 3

Done:					; ...
		retn
; END OF FUNCTION CHUNK	FOR TransPathSet

; =============== S U B	R O U T	I N E =======================================


Canonicalize:
		lodsb
		call	PATHCHRCMP
		jnz	short CanonDec
		cmp	di, bp
		jnb	short CanonBad
		stosb
		jmp	short Canonicalize
; ---------------------------------------------------------------------------

CanonDec:				; ...
		dec	si

CanonLoop:				; ...
		xor	ax, ax
		cmp	[si], al
		jnz	short DoComponent
		cmp	byte [es:di-1], ':'
		jnz	short DoTerminate
		mov	al, '\'
		stosb
		mov	al, ah

DoTerminate:				; ...
		stosb
		clc
		retn
; ---------------------------------------------------------------------------

CanonBad:				; ...
		call	ScanPathChar
		mov	al, 3
		jz	short PathEnc
		mov	al, 2

PathEnc:				; ...
		stc

CanonBad_retn:				; ...
		retn
; ---------------------------------------------------------------------------

DoComponent:				; ...
		call	CopyComponent
		jb	short CanonBad_retn
		cmp	word [es:di], '.' ; 2Eh
		jz	short Skip1
		cmp	word [es:di], '..' ; 2E2Eh
		jnz	short CanonNormal
		dec	di

Skip1:					; ...
		call	SkipBack
		mov	al, 3
		jb	short CanonBad_retn
		jmp	short CanonPath
; ---------------------------------------------------------------------------

CanonNormal:				; ...
		add	di, cx

CanonPath:				; ...
		call	PathSep
		jnz	short CanonBad
		lodsb
		call	PATHCHRCMP
		jnz	short CanonDec
		cmp	di, bp
		jnb	short CanonBad
		stosb

CanonPathLoop:				; ...
		lodsb
		call	PATHCHRCMP
		jz	short CanonPathLoop
		dec	si
		jmp	short CanonLoop

; =============== S U B	R O U T	I N E =======================================


PathSep	:
		mov	al, [si]

PathSepGotCh:				; ...
		or	al, al
		jz	short CanonBad_retn
		call	PATHCHRCMP
		retn

; =============== S U B	R O U T	I N E =======================================


SkipBack:
		cmp	di, bx
		jb	short SkipBad
		dec	di
		mov	al, [es:di]
		call	PATHCHRCMP
		jnz	short SkipBack
		clc
		retn
; ---------------------------------------------------------------------------

SkipBad:				; ...
		mov	al, 3
		stc
		retn

; =============== S U B	R O U T	I N E =======================================


CopyComponent:
		sub	sp, 14
		push	ds
		push	si
		push	es
		push	di
		push	bp
		mov	bp, sp
		mov	ah, '.'
		lodsb
		stosb
		cmp	al, ah
		jnz	short NormalComp
		call	PathSep
		jz	short NulTerm

TryTwoDot:
		lodsb
		stosb
		cmp	al, ah
		jnz	short CopyBad
		call	PathSep
		jnz	short CopyBad

NulTerm:				; ...
		xor	al, al
		stosb
		mov	[bp+6],	si
		jmp	short _GoodRet
; ---------------------------------------------------------------------------

NormalComp:				; ...
		mov	si, [bp+6]
		call	NAMETRANS
		cmp	si, [bp+6]
		jz	short CopyBad
		test	byte [ss:FSHARING], 0FFh
		jnz	short DoPack
		and	dl, 1
		add	byte [ss:CMETA], dl
		jg	short CopyBad
		jnz	short DoPack
		or	dl, dl
		jz	short CopyBadPath

DoPack:					; ...
		mov	[bp+6],	si
		push	ss
		pop	ds
		mov	si, NAME1
		lea	di, [bp+0Ah]
		push	di
		call	PackName
		pop	di
		call	StrLen
		dec	cx
		add	cx, [bp+2]
		cmp	cx, [bp+0]
		jnb	short CopyBad
		mov	si, di
		les	di, [bp+2]
		call	FStrCpy

_GoodRet:				; ...
		clc
		jmp	short CopyEnd
; ---------------------------------------------------------------------------

CopyBad:				; ...
		stc
		call	ScanPathChar
		mov	al, 2
		jnz	short CopyEnd

CopyBadPath:				; ...
		stc
		mov	al, 3

CopyEnd:				; ...
		pop	bp
		pop	di
		pop	es
		pop	si
		pop	ds
		lahf
		add	sp, 14
		call	StrLen
		dec	cx
		sahf
		retn

; =============== S U B	R O U T	I N E =======================================


Splice	:
		test	byte [ss:SPLICES], 0FFh
		jz	short AllDone
		push	word [ss:THISCDS]
		push	word [ss:THISCDS+2]
		push	ds
		push	si
		pop	di
		pop	es
		xor	ax, ax

SpliceScan:				; ...
		call	GetCDSFromDrv
		jb	short SpliceDone
		inc	al
		test	word [si+43h], 2000h
		jz	short SpliceScan
		push	di
		call	PathPref
		jz	short SpliceFound

SpliceSkip:				; ...
		pop	di
		jmp	short SpliceScan
; ---------------------------------------------------------------------------

SpliceFound:				; ...
		cmp	byte [es:di], 0
		jnz	short SpliceDo
		test	byte [ss:NoSetDir], 0FFh
		jnz	short SpliceSkip

SpliceDo:				; ...
		mov	si, di
		push	es
		pop	ds
		pop	di
		call	TextFromDrive1
		mov	ax, [ss:CURR_DIR_END]
		or	ax, ax
		js	short NoPoke
		add	ax, di
		sub	ax, si
		mov	[ss:CURR_DIR_END], ax

NoPoke:					; ...
		cmp	byte [si], 0
		jnz	short SpliceCopy
		mov	al, '\'
		stosb

SpliceCopy:				; ...
		call	FStrCpy
		add	sp, 4
		or	cl, 1
		jmp	short DoSet
; ---------------------------------------------------------------------------

SpliceDone:				; ...
		pop	word [ss:THISCDS+2]
		pop	word [ss:THISCDS]

AllDone:				; ...
		xor	cx, cx

DoSet:					; ...
		lds	si, [ss:THISCDS]
		les	di, [si+45h]
		mov	word [ss:THISDPB], di
		mov	word [ss:THISDPB+2], es

Splice_retn:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================


$NameTrans:
		push	ds
		push	si
		push	es
		push	di
		push	cx
		mov	ch, 16h		; attr_hidden+attr_system+attr_directory
		call	SetAttrib
		mov	di, OPENBUF
		call	TransPath
		pop	cx
		pop	di
		pop	es
		pop	si
		pop	ds
		jnb	short TransOK
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

TransOK:				; ...
		mov	si, OPENBUF
		push	ss
		pop	ds
		call	FStrCpy
		jmp	SYS_RET_OK

; =============== S U B	R O U T	I N E =======================================


DriveFromText:
		xor	al, al
		cmp	byte [si], 0
		jz	short Splice_retn
		cmp	byte [si+1], ':'
		jnz	short Splice_retn
		lodsw
		or	al, 20h
		sub	al, 60h
		jnz	short Splice_retn
		mov	al, 0FFh
		retn

; =============== S U B	R O U T	I N E =======================================


TextFromDrive:
		inc	al

TextFromDrive1:				; ...
		add	al, 40h	; '@'   ; 'A'-1
		mov	ah, ':'
		stosw

PathPref_retn:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================


PathPref:
		call	DStrLen
		dec	cx
		repe cmpsb
		jnz	short PathPref_retn
		push	ax
		mov	al, [si-1]
		call	PATHCHRCMP
		jz	short Prefix
		mov	al, [es:di]
		call	PathSepGotCh

Prefix:					; ...
		pop	ax
		retn

; =============== S U B	R O U T	I N E =======================================


ScanPathChar:
		lodsb
		call	PathSepGotCh
		jnz	short ScanPathChar
		call	PATHCHRCMP
		retn

; =============== S U B	R O U T	I N E =======================================


$OPEN:
		xor	ah, ah

$Open2:					; ...
		mov	ch, 16h		; attr_hidden+attr_system+attr_directory
		call	SetAttrib
		mov	cx, DOS_OPEN
		push	ax

AccessFile:				; ...
		call	ECritDisk	; ECritSFT
		call	SFNFree
		call	LCritDisk	; LCritSFT
		jb	short OpenFailJ
		mov	[ss:SFN], bx
		mov	word [ss:THISSFT], di
		mov	word [ss:THISSFT+2], es
		call	JFNFree
		jnb	short SaveJFN

OpenFailJ:				; ...
		jmp	OpenFail
; ---------------------------------------------------------------------------

SaveJFN:				; ...
		mov	word [ss:PJFN], di
		mov	word [ss:PJFN+2], es
		mov	[ss:JFN], bx
		mov	bx, [ss:SFN]
		mov	[es:di], bl
		mov	si, dx
		mov	di, OPENBUF
		push	cx
		call	TransPath
		pop	bx
		lds	si, [ss:THISSFT]
		jb	short OpenCleanJ
		cmp	byte [ss:CMETA], 0FFh
		jz	short SetSearch
		mov	al, 2

OpenCleanJ:				; ...
		jmp	short OpenClean
; ---------------------------------------------------------------------------

SetSearch:				; ...
		pop	ax
		xor	cx, cx
		mov	[si+2],	cx
		mov	[si+51], cx
		cmp	bx, DOS_OPEN
		jnz	short _DoOper
		test	al, 80h
		jz	short _DoOper
		and	al, 7Fh
		mov	cx, 1000h

_DoOper:				; ...
		push	di
		push	es
		push	ds
		pop	es
		push	si
		pop	di
		call	Set_EXT_mode
		pop	es
		pop	di
		push	ss
		pop	ds
		push	cx
		call	bx
		pop	cx
		lds	si, [THISSFT]
		jb	short OpenE2

OpenOK:
		mov	word [si], 1
		or	[si+5],	cx
		mov	ax, [ss:JFN]
		call	far [ss:ShCol]
		mov	word [ss:SFN], 0FFFFh

OpenOKJ:				; ...
		jmp	SYS_RET_OK
; ---------------------------------------------------------------------------

OpenE2:					; ...
		cmp	ax, 57h
		jnz	short OpenE
		jmp	short OpenCritLeave
; ---------------------------------------------------------------------------

OpenClean:				; ...
		pop	bx

OpenE:					; ...
		mov	word [si], 0
		lds	si, [ss:PJFN]
		mov	byte [si], 0FFh
		jmp	short OpenCritLeave
; ---------------------------------------------------------------------------

OpenFail:				; ...
		sti
		pop	cx

OpenCritLeave:				; ...
		mov	word [ss:SFN], 0FFFFh
		cmp	word [ss:EXTERR], 25h
		jnz	short NORERR
		jmp	From_GetSet
; ---------------------------------------------------------------------------

NORERR:					; ...
		jmp	SYS_RET_ERR

; =============== S U B	R O U T	I N E =======================================


$CREAT:
		push	cx
		mov	cx, DOS_CREATE

; START	OF FUNCTION CHUNK FOR $CreateNewFile

AccessSet:				; ...
		mov	byte [ss:SATTRIB], 6	; attr_hidden+attr_system
		jmp	AccessFile
; END OF FUNCTION CHUNK	FOR $CreateNewFile
; ---------------------------------------------------------------------------

$CHMOD:					; ...
		mov	di, OPENBUF
		push	ax
		push	cx
		mov	si, dx
		call	TransPathSet
		pop	cx
		pop	ax
		jb	short ChModErr
		push	ss
		pop	ds
		cmp	byte [CMETA], 0FFh
		jnz	short ChModErr
		mov	byte [SATTRIB], 16h
		sub	al, 1
		jb	short ChModGet
		jz	short ChModSet
		mov	byte [EXTERR_LOCUS], 1
		mov	al, 1
; START	OF FUNCTION CHUNK FOR $UNLINK

ChModErrj:				; ...
		jmp	short NORERR
; END OF FUNCTION CHUNK	FOR $UNLINK
; ---------------------------------------------------------------------------

ChModGet:				; ...
		call	GET_FILE_INFO
		jb	short ChModE
		call	Get_User_Stack
		mov	[si+4],	ax
; START	OF FUNCTION CHUNK FOR $UNLINK

OpenOkj2:				; ...
		jmp	short OpenOKJ
; END OF FUNCTION CHUNK	FOR $UNLINK
; ---------------------------------------------------------------------------

ChModSet:				; ...
		mov	ax, cx
		call	SET_FILE_ATTRIBUTE
		jb	short ChModE
; START	OF FUNCTION CHUNK FOR $UNLINK

OpenOkj3:				; ...
		jmp	short OpenOkj2
; ---------------------------------------------------------------------------

ChModErr:				; ...
		mov	al, 3

ChModE:					; ...
		jmp	short ChModErrj
; END OF FUNCTION CHUNK	FOR $UNLINK

; =============== S U B	R O U T	I N E =======================================


$UNLINK:

; FUNCTION CHUNK AT B01D SIZE 00000002 BYTES
; FUNCTION CHUNK AT B02A SIZE 00000002 BYTES
; FUNCTION CHUNK AT B033 SIZE 00000006 BYTES

		push	cx
		mov	si, dx
		mov	di, OPENBUF
		call	TransPathSet
		pop	cx
		jb	short ChModErr
		cmp	byte [ss:CMETA], 0FFh ; -1
		jnz	short NotFound
		push	ss
		pop	ds
		mov	ch, 6
		call	SetAttrib
		call	DOS_DELETE
		jb	short UnlinkE

UnLinkOK:				; ...
		jmp	short OpenOkj3
; ---------------------------------------------------------------------------

NotFound:				; ...
		mov	al, 3

UnlinkE:				; ...
		jmp	short ChModE

; ---------------------------------------------------------------------------

$RENAME:				; ...
		push	cx
		push	ds
		push	dx
		push	es
		pop	ds
		mov	si, di
		mov	di, RENBUF
		call	TransPathSet
		push	word [ss:WFP_START]
		pop	word [ss:REN_WFP]
		pop	si
		pop	ds
		pop	cx

epjc2:					; ...
		jb	short ChModErr
		cmp	byte [ss:CMETA], 0FFh
		jnz	short NotFound
		push	cx
		mov	di, OPENBUF
		call	TransPathSet
		pop	cx
		jb	short epjc2
		push	ss
		pop	ds
		cmp	byte [CMETA], 0FFh
		jb	short NotFound
		push	word [THISCDS]
		push	word [THISCDS+2]
		mov	di, OPENBUF
		push	ss
		pop	es
		xor	al, al

rnloop:					; ...
		call	GetCDSFromDrv
		jb	short dorn
		call	StrCmp
		jz	short rnerr
		inc	al
		jmp	short rnloop
; ---------------------------------------------------------------------------

rnerr:					; ...
		add	sp, 4
		mov	al, 10h
		jmp	short UnlinkE
; ---------------------------------------------------------------------------

dorn:					; ...
		pop	word [ss:THISCDS+2]
		pop	word [ss:THISCDS]
		push	ss
		pop	ds
		mov	ch, 16h		; attr_directory+attr_hidden+attr_system
		call	SetAttrib
		call	DOS_RENAME
		jb	short UnlinkE
		jmp	short UnLinkOK

; =============== S U B	R O U T	I N E =======================================


$CreateNewFile:

; FUNCTION CHUNK AT AFEB SIZE 00000009 BYTES

		push	cx
		mov	cx, DOS_Create_New
		jmp	AccessSet

; =============== S U B	R O U T	I N E =======================================


BinToAscii:
		mov	cx, 404h

bta5:					; ...
		rol	ax, cl
		push	ax
		and	al, 0Fh
		add	al, 'A'
		stosb
		pop	ax
		dec	ch
		jnz	short bta5
		retn

; ---------------------------------------------------------------------------

$CreateTempFile:			; ...
		push	bp
		mov	bp, sp
		sub	sp, 10
		test	cx, 0FFD8h	; ~attr_changeable
		jz	short OKatts
		mov	ax, 5
		jmp	short SETTMPERR
; ---------------------------------------------------------------------------

OKatts:					; ...
		mov	[bp-10], cx
		mov	[bp-8],	dx
		mov	word [bp-6], ds
		mov	word [bp-2], ds
		push	ds
		pop	es
		mov	di, dx
		mov	cx, di
		neg	cx
		or	cx, cx
		jnz	short okok
		mov	cx, 0FFFFh

okok:					; ...
		xor	ax, ax
		repne scasb
		dec	di
		mov	al, [es:di-1]
		call	PATHCHRCMP
		jz	short SETENDPTR
		mov	al, '\'
		stosb

SETENDPTR:				; ...
		mov	[bp-4],	di

CreateLoop:				; ...
		push	ss
		pop	ds
		push	bp
		call	READTIME
		pop	bp
		les	di, [bp-4]
		mov	ax, cx
		call	BinToAscii
		mov	ax, dx
		call	BinToAscii
		xor	al, al
		stosb
		lds	dx, [bp-8]
		mov	cx, [bp-10]
		push	bp
		call	$CreateNewFile
		pop	bp
		jnb	short CreateDone
		cmp	al, 50h
		jz	short CreateLoop
		cmp	al, 5
		jnz	short SETTMPERR
		cmp	word [ss:EXTERR], 41h
		jz	short SETTMPERR
		cmp	word [ss:EXTERR], 53h
		jz	short SETTMPERR
		jmp	short CreateLoop
; ---------------------------------------------------------------------------

SETTMPERR:				; ...
		stc

CreateDone:				; ...
		mov	sp, bp
		pop	bp
		jb	short CreateFail
		jmp	SYS_RET_OK
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR $Extended_Open

CreateFail:				; ...
		jmp	SYS_RET_ERR
; END OF FUNCTION CHUNK	FOR $Extended_Open

; =============== S U B	R O U T	I N E =======================================


SetAttrib:
		test	byte [ss:FSHARING], 0FFh
		jnz	short Set
		mov	cl, ch

Set:					; ...
		mov	byte [ss:SATTRIB], cl
		retn

; =============== S U B	R O U T	I N E =======================================


$Extended_Open:

; FUNCTION CHUNK AT B171 SIZE 00000003 BYTES

		mov	[ss:EXTOPEN_FLAG], dx
		mov	word [ss:EXTOPEN_IO_MODE], 0
		test	dx, 0FE00h	; RESERVED_BITS_MASK
		jnz	short ext_inval2
		mov	ah, dl
		cmp	dl, 0
		jz	short ext_inval2
		and	dl, 0Fh
		cmp	dl, 2
		ja	short ext_inval2
		and	ah, 0F0h
		cmp	ah, 10h
		ja	short ext_inval2
		mov	[ss:SAVE_ES], es
		mov	[ss:SAVE_DI], di
		push	word [ss:EXTOPEN_FLAG]
		pop	word [ss:SAVE_DX]
		mov	[ss:SAVE_CX], cx
		mov	[ss:SAVE_BX], bx
		mov	[ss:SAVE_DS], ds
		mov	[ss:SAVE_SI], si
		mov	dx, si
		mov	ax, bx
		jmp	short goopen2
; ---------------------------------------------------------------------------

ext_inval2:				; ...
		mov	al, 1

jmp_to_CreateFail:			; ...
		jmp	short CreateFail
; ---------------------------------------------------------------------------

ext_inval_parm:
		pop	cx
		pop	si
		mov	al, 13
		jmp	short jmp_to_CreateFail
; ---------------------------------------------------------------------------

error_return:				; ...
		retn
; ---------------------------------------------------------------------------

goopen2:				; ...
		test	bx, 2000h
		jz	short goopen
		or	byte [ss:EXTOPEN_ON], 2

goopen:					; ...
		or	byte [ss:EXTOPEN_ON], 1
		and	word [ss:EXTOPEN_FLAG], 0FFh
		cmp	word [ss:EXTOPEN_FLAG], 10h
		jnz	short chknext
		call	$CreateNewFile
		jb	short error_return
		cmp	byte [ss:EXTOPEN_ON], 0
		jz	short ok_return2
		mov	word [ss:EXTOPEN_FLAG], 2
		jmp	setXAttr
; ---------------------------------------------------------------------------

ok_return2:				; ...
		jmp	SYS_RET_OK
; ---------------------------------------------------------------------------

chknext:				; ...
		test	word [ss:EXTOPEN_FLAG], 1
		jnz	short exist_open
		call	$CREAT
		jb	short error_return
		cmp	byte [ss:EXTOPEN_ON], 0
		jz	short ok_return2
		mov	word [ss:EXTOPEN_FLAG], 2
		test	byte [ss:EXTOPEN_ON], 4
		jnz	short setXAttr
		mov	word [ss:EXTOPEN_FLAG], 3
		jmp	short setXAttr
; ---------------------------------------------------------------------------

error_return2:				; ...
		stc
		retn
; ---------------------------------------------------------------------------

exist_open:				; ...
		test	byte [ss:FSHARING], 0FFh
		jz	short noserver
		mov	cl, ch

noserver:				; ...
		call	$Open2
		jnb	short ext_ok
		cmp	byte [ss:EXTOPEN_ON], 0
		jz	short error_return2
		cmp	ax, 2
		jnz	short error_return2
		test	word [ss:EXTOPEN_FLAG], 10h
		jnz	short do_creat
		jmp	short extexit
; ---------------------------------------------------------------------------

do_creat:				; ...
		mov	cx, [ss:SAVE_CX]
		lds	si, [ss:SAVE_SI]
		mov	dx, si
		call	$CREAT
		jb	short extexit
		mov	word [ss:EXTOPEN_FLAG], 2
		jmp	short setXAttr
; ---------------------------------------------------------------------------

ext_ok:					; ...
		cmp	byte [ss:EXTOPEN_ON], 0
		jz	short ok_return
		mov	word [ss:EXTOPEN_FLAG], 1

setXAttr:				; ...
		push	ax
		call	Get_User_Stack
		mov	ax, [ss:EXTOPEN_FLAG]
		mov	[si+4],	ax
		pop	ax
		mov	[si], ax

ok_return:				; ...
		jmp	SYS_RET_OK
; ---------------------------------------------------------------------------

extexit2:
		pop	bx
		push	ax
		cmp	word [ss:EXTOPEN_FLAG], 2
		jnz	short justopen
		lds	si, [ss:SAVE_SI]
		lds	dx, [si]
		call	$UNLINK
		jmp	short reserror
; ---------------------------------------------------------------------------

justopen:				; ...
		call	$CLOSE

reserror:				; ...
		pop	ax
		jmp	short extexit
; ---------------------------------------------------------------------------
		mov	ax, 2
		jmp	short extexit
; ---------------------------------------------------------------------------
		mov	ax, 1

extexit:				; ...
		jmp	SYS_RET_ERR

; ---------------------------------------------------------------------------

$LockOper:				; ...
		cmp	al, 1
		ja	short lock_bad_func
		push	di
		call	SFFromHandle
		jnb	short lock_do
		pop	di
		mov	al, 6

LockOperErrj:				; ...
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

lock_bad_func:				; ...
		mov	byte [ss:EXTERR_LOCUS], 1
		mov	al, 1

LockOperErr:				; ...
		jmp	short LockOperErrj
; ---------------------------------------------------------------------------

lock_do:				; ...
		mov	bx, ax
		mov	bp, Lock_Buffer
		mov	[bp+0],	dx
		mov	[bp+2],	cx
		pop	cx
		mov	[bp+4],	cx
		mov	[bp+6],	si
		mov	cx, 1
		push	ss
		pop	ds
		mov	dx, bp
		test	al, 1
		jnz	short DOS_Unlock
		jmp	short DOS_Lock
; ---------------------------------------------------------------------------

DOS_Unlock:				; ...
		test	byte [es:di+6], 80h
		jz	short LOCAL_UNLOCK
		mov	ax, 110Ah
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - LOCK	REGION OF FILE
					; BX = file handle, CX:DX = starting offset, SI	= high word of size
					; STACK: WORD low word of size,	[es:DI -> SFT
					; SFT DPB field	-> DPB of drive	containing file, SS = DOS CS
					; Return: CF set error
		jmp	short ValChk
; ---------------------------------------------------------------------------

LOCAL_UNLOCK:				; ...
		call	far [clr_block]

ValChk:					; ...
		jnb	short Lock_OK
		jmp	short LockOperErr
; ---------------------------------------------------------------------------

Lock_OK:				; ...
		mov	ax, [TEMP_VAR]
		jmp	SYS_RET_OK
; ---------------------------------------------------------------------------

DOS_Lock:				; ...
		test	byte [es:di+6], 80h
		jz	short LOCAL_LOCK
		mov	ax, 110Ah
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - LOCK	REGION OF FILE
					; BX = file handle, CX:DX = starting offset, SI	= high word of size
					; STACK: WORD low word of size,	[es:DI -> SFT
					; SFT DPB field	-> DPB of drive	containing file, SS = DOS CS
					; Return: CF set error
		jmp	short ValChk
; ---------------------------------------------------------------------------

LOCAL_LOCK:				; ...
		call	far [set_block]
		jmp	short ValChk

; =============== S U B	R O U T	I N E =======================================


LOCK_CHECK:
		mov	bx, [RetryCount]

LockRetry:				; ...
		push	bx
		push	ax
		call	far [chk_block]
		pop	ax
		pop	bx
		jnb	short lc_ret_label
		call	Idle
		dec	bx
		jnz	short LockRetry
		stc

lc_ret_label:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================


LOCK_VIOLATION:
		push	ds
		push	es
		push	di
		push	cx
		mov	ax, 21h		; error_lock_violation
		mov	byte [ALLOWED], 18h	; Allowed_FAIL+Allowed_RETRY
		les	bp, [THISDPB]
		mov	di, 1
		mov	cx, di
		mov	dx, [es:bp+0Bh]	; [ES:BP+DPB.FIRST_SECTOR]
		call	HARDERR
		pop	cx
		pop	di
		pop	es
		pop	ds
		cmp	al, 1
		jz	short lc_ret_label
		stc
		retn

; =============== S U B	R O U T	I N E =======================================


CheckShare:
		push	ds
		mov	ds, [cs:DosDSeg]
		cmp	byte [fShare], 0
		pop	ds
		retn

; =============== S U B	R O U T	I N E =======================================


SHARE_CHECK:
		call	far [MFT_enter]

shchk_retn:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================


SHARE_VIOLATION:
		push	ds
		push	es
		push	di
		mov	byte [READOP], 0
		mov	byte [ALLOWED], 18h	; Allowed_FAIL+Allowed_RETRY
		les	bp, [THISDPB]
		mov	di, 1
		mov	cx, di
		mov	dx, [es:bp+17]	; [ES:BP+DPB.DIR_SECTOR]
		call	HARDERR
		pop	di
		pop	es
		pop	ds
		cmp	al, 1
		jz	short shchk_retn
		stc
		retn

; =============== S U B	R O U T	I N E =======================================


ShareEnd:
		call	far [MFTClose]
		retn

; =============== S U B	R O U T	I N E =======================================


ShareEnter:
		push	cx

retry:					; ...
		mov	cx, [RetryCount]

attempt:				; ...
		les	di, [THISSFT]
		xor	ax, ax
		mov	[es:di+51], ax	; [ES:DI+SF_ENTRY.sf_MFT]
		push	cx
		call	SHARE_CHECK
		pop	cx
		jnb	short done
		call	Idle
		loop	attempt
		call	SHARE_VIOLATION
		jnb	short retry

done:					; ...
		pop	cx
		retn

; =============== S U B	R O U T	I N E =======================================


ExecReady:
		mov	si, dx
		test	word [si+2], 1
		jz	short er_setver
		mov	ax, [si+8]
		add	ax, 10h
		mov	es, ax
		mov	cx, [si+0Ah]
		mov	ax, [si+0Ch]
		call	word [ss:FixExePatch]
		call	word [ss:Rational386PatchPtr]

er_setver:				; ...
		test	word [si+2], 2
		jnz	short er_chkdoshi
		push	ds
		push	si
		lds	si, [si+4]
		call	Scan_Execname1
		call	Scan_Special_Entries
		pop	si
		pop	ds
		mov	es, word [si+8]
		mov	ax, [ss:SPECIAL_VERSION]
		mov	[es:40h], ax	; [es:PDB.Version]

er_chkdoshi:				; ...
		cmp	byte [ss:DosHasHMA], 0
		jz	short er_done
		mov	ax, [si+8]
		or	byte [ss:DOS_FLAG], 4
		test	word [si+2], 1
		jnz	short er_seta20
		push	ds
		mov	ds, ax
		call	IsCopyProt
		pop	ds

er_seta20:				; ...
		inc	byte [ss:A20OFF_COUNT]
		mov	[ss:A20OFF_PSP], ax

er_done:				; ...
		xor	ax, ax
		retn

; ---------------------------------------------------------------------------
rpFind1:	db 0FAh, 0E4h, 21h, 60h, 33h, 0C0h, 0E6h, 43h, 8Bh, 16h	; ...
rpFind1a:	db 0B0h, 0Eh, 0E6h, 37h, 33h, 0C0h, 0E6h, 0F2h ; ...
rpFind2:	db 0Fh,	20h, 0C0h	; ...
rpFind3:	db 0Fh,	22h, 0C0h, 0EAh	; ...
rpRepl2:	db 66h,	50h, 51h, 0Fh, 20h, 0C0h ; ...
rpRepl3:	db 8Eh,	0D3h, 59h, 66h,	58h ; ...
rpFind4:	db 93h,	58h, 8Bh, 0CCh	; ...
rpFind5:	db 0B8h, 0Ch, 0DEh, 0CDh, 67h, 8Bh, 0E1h, 0FFh,	0E3h ; ...
rpRepl4:	db 93h,	58h, 8Bh, 0CCh	; ...
		db 2Eh,	66h, 0A3h
		db 2 dup(0)
		db 2Eh,	66h, 89h, 36h
		db 2 dup(0)
rpRepl5:	db 8Bh,	0E1h		; ...
		db 2Eh,	66h, 0A1h
		db 2 dup(0)
		db 2Eh,	66h, 8Bh, 36h
		db 2 dup(0)
		db 0FFh, 0E3h
rpFind6:	db 0FAh, 52h, 51h	; ...
rpFind7a:	db 0B8h, 0Ch, 0DEh, 66h, 26h, 0FFh, 1Eh	; ...
rpFind7b:	db 59h,	5Ah, 5Bh	; ...
rpRepl6:	db 0FAh, 66h, 50h, 66h,	53h, 66h, 51h, 66h, 52h	; ...
rpRepl7:	db 66h,	5Ah, 66h, 59h, 66h, 5Bh, 66h, 58h, 5Bh ; ...
rpFind8:	db 60h,	6, 1Eh,	0B8h, 2	dup(0),	8Eh, 0D8h ; ...
rpFind9:	db 1Fh,	7, 61h		; ...
rpRepl8:	db 66h,	60h, 6,	1Eh	; ...
rpRepl9:	db 1Fh,	7, 66h,	61h, 0C3h ; ...
rpBug1Strs:	dw rpFind2	; ...
		dw 3
		dw rpFind3
		dw 4
		dw 20h
rpBug2Strs:	dw rpFind4	; ...
		dw 4
		dw rpFind5
		dw 9
		dw 80h
rpBug3Strs:	dw rpFind6	; ...
		dw 3
		dw rpFind7a
		dw 7
		dw 80h
rpBug4Strs:	dw rpFind8	; ...
		dw 4
		dw rpFind9
		dw 3
		dw 80h
; ---------------------------------------------------------------------------

Rational386Patch:			; ...
		cmp	word [es:0], 395
		jnb	short rp3QuickOut
		cmp	word [es:0Ch], 20h ; ' '
		jnz	short rp3QuickOut
		push	ax
		mov	ax, 18h
		cmp	[es:18h], ax
		jnz	short rp3QO_ax
		cmp	[es:1Ch], ax
		jnz	short rp3QO_ax
		cmp	[es:24h], ax
		jz	short rp3Maybe

rp3QO_ax:				; ...
		pop	ax

rp3QuickOut:				; ...
		retn
; ---------------------------------------------------------------------------

rp3Maybe:				; ...
		cld
		push	bx
		push	cx
		push	dx
		push	si
		push	di
		push	es
		push	ds
		push	bp
		sub	sp, 6
		mov	bp, sp
		push	cs
		pop	ds
		mov	ax, [es:0]
		mov	[bp+0],	ax
		call	VerifyVersion
		jnz	short rp3Exit_j
		mov	cx, 4500h
		mov	[bp+2],	cx
		mov	es, word [es:20h]
		mov	si, rpFind1
		mov	dx, 10
		call	ScanCodeSeq
		jz	short rpGotPatch
		mov	si, rpFind1a
		mov	dx, 8
		call	ScanCodeSeq
		jz	short rpGotPatch

rp3Exit_j:				; ...
		jmp	rp3Exit
; ---------------------------------------------------------------------------

rpGotPatch:				; ...
		mov	[bp+4],	di
		cmp	word [bp+0], 381
		jnb	short rpBug2
		mov	bx, rpBug1Strs
		call	FindBadCode
		jb	short rpBug2
		push	di
		mov	di, si
		mov	dx, 3
		cmp	byte [es:di-1], 51h	; 'Q'
		jnz	short rp_no_cx
		dec	di
		inc	dx

rp_no_cx:				; ...
		mov	si, rpRepl2
		mov	cx, 6
		call	GenPatch
		pop	di
		cmp	byte [es:di-1], 59h	; 'Y'
		jnz	short rp_no_cx2
		mov	byte [es:di-1], 90h	; ''

rp_no_cx2:				; ...
		mov	ax, [bp+4]
		mov	[es:di+4], ax
		push	di
		mov	si, rpRepl3
		mov	cx, 5
		call	CopyPatch
		pop	bx
		add	bx, 8
		call	GenJump
		mov	[bp+4],	di

rpBug2:					; ...
		mov	bx, rpBug2Strs
		call	FindBadCode
		jb	short rpBug3
		push	word [bp+4]
		push	di
		mov	di, si
		mov	dx, 4
		mov	si, rpRepl4
		mov	cx, 15
		call	GenPatch
		pop	di
		add	di, 5
		mov	bx, [bp+4]
		push	bx
		call	GenJump
		mov	si, rpRepl5
		mov	cx, 15
		call	CopyPatch
		pop	di
		pop	si
		mov	ax, [bp+4]
		mov	[es:si+7], ax
		mov	[es:di+5], ax
		add	ax, 4
		mov	[es:si+0Dh], ax
		mov	[es:di+0Bh], ax
		add	word [bp+4], 8

rpBug3:					; ...
		mov	bx, rpBug3Strs
		call	FindBadCode
		jb	short rpBug4
		add	di, 9
		push	si
		mov	si, rpFind7b
		mov	dx, 3
		call	ScanCodeSeq_di
		pop	si
		jnz	short rpBug4
		push	di
		mov	di, si
		mov	dx, 3
		mov	si, rpRepl6
		mov	cx, 9
		call	GenPatch
		pop	di
		mov	dx, 3
		mov	si, rpRepl7
		mov	cx, 9
		call	GenPatch

rpBug4:					; ...
		cmp	word [bp+0], 360
		jbe	short rp3Exit
		mov	bx, rpBug4Strs
		call	FindBadCode
		jb	short rp3Exit
		push	di
		mov	di, si
		mov	dx, 3
		mov	si, rpRepl8
		mov	cx, 4
		call	GenPatch
		pop	di
		mov	bx, [bp+4]
		call	GenJump
		mov	si, rpRepl9
		mov	cx, 5
		call	CopyPatch

rp3Exit:				; ...
		add	sp, 6
		pop	bp
		pop	ds
		pop	es
		pop	di
		pop	si
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		retn

; =============== S U B	R O U T	I N E =======================================


FindBadCode:
		mov	cx, [bp+2]
		mov	si, [bx]
		mov	dx, [bx+2]
		call	ScanCodeSeq
		jnz	short fbc_error
		push	di
		mov	si, [bx+4]
		mov	dx, [bx+6]
		call	ScanCodeSeq_di
		pop	si
		jnz	short fbc_error
		mov	ax, di
		sub	ax, si
		jb	short fbc_error
		cmp	ax, [bx+8]
		ja	short fbc_error
		clc
		retn
; ---------------------------------------------------------------------------

fbc_error:				; ...
		stc
		retn

; =============== S U B	R O U T	I N E =======================================


GenPatch:
		push	di
		mov	bx, [bp+4]
		call	GenJump
		call	CopyPatch
		pop	bx
		add	bx, dx
		call	GenJump
		mov	[bp+4],	di
		retn

; =============== S U B	R O U T	I N E =======================================


CopyPatch:
		push	cx
		mov	di, [bp+4]
		cld
		rep movsb
		pop	cx
		mov	[bp+4],	di
		retn

; =============== S U B	R O U T	I N E =======================================


GenJump	:
		mov	al, 0E9h
		stosb
		mov	ax, bx
		sub	ax, di
		sub	ax, 2
		stosw
		retn

; =============== S U B	R O U T	I N E =======================================


ScanCodeSeq:
		mov	di, 200h

; =============== S U B	R O U T	I N E =======================================


ScanCodeSeq_di:
		push	cx
		sub	cx, dx
		inc	cx

scsagain:				; ...
		push	si
		push	di
		push	cx
		mov	cx, dx
		repe cmpsb
		pop	cx
		pop	di
		pop	si
		jz	short scsfound
		inc	di
		loop	scsagain

scsfound:				; ...
		pop	cx
		retn

; =============== S U B	R O U T	I N E =======================================


VerifyVersion:
		mov	si, [es:2Ah]
		mov	bl, 10
		add	si, 3
		call	VVDigit
		jnz	short vvexit
		call	VVDigit
		jnz	short vvexit
		cmp	byte [es:si], '.'
		jnz	short vvexit
		dec	si
		call	VVDigit

vvexit:					; ...
		retn

; =============== S U B	R O U T	I N E =======================================


VVDigit	:
		div	bl
		add	ah, '0'
		dec	si
		cmp	[es:si+1], ah
		mov	ah, 0
		retn

; ---------------------------------------------------------------------------

exepatch_start:
;str1:
		db  06h	  		;push	es		 
		db  8Ch,0D8h		;mov	ax,ds 

;first_stop equ	$-str1
			
		db  2Bh, 0C2h		;sub	ax, dx			
first:
		db  8Eh,0D8h		;mov	ds,ax			
		db  8Eh,0C0h		;mov	es,ax			
		db  0BFh,0Fh,00h	;mov	di,000FH
		db  57h	    		;push	di
		db  0B9h,10h,00h	;mov	cx,0010H
		db  0B0h,0FFh 		;mov	al,0FFH 		
		db  0F3h,0AEh 		;repz	scasb			
		db  47h	    		;inc	di			
		db  8Bh,0F7h  		;mov	si,di			
		db  5Fh	    		;pop	di
		db  58h	    		;pop	ax

;second_stop equ $-first

		db  2Bh,0C2h  		;sub	ax, dx			
second:
		db  8Eh,0C0h  		;mov	es,ax			
		    		;NextRec:				
		db  0B9h,04h,02h	;mov	cx, 0204h
		    		;norm_agn:				
		db  8Bh,0C6h		;mov	ax,si			
		db  0F7h,0D0h		;not	ax		
		db  0D3h,0E8h		;shr	ax,cl		
		db  74h,13h		;jz	short SI_ok			
		db  8Ch,0DAh		;mov	dx,ds			
		db  83h,0CEh,0F0h	;or	si,0FFF0H
		db  2Bh,0D0h		;sub	dx,ax			
		db  73h,08h		;jnc	short SItoDS			
		db  0F7h,0DAh		;neg	dx			
		db  0D3h,0E2h		;shl	dx,cl			
		db  2Bh,0F2h		;sub	si,dx			
		db  33h,0D2h		;xor	dx,dx			
				;SItoDS: 				
		db  8Eh,0DAh		;mov	ds,dx		
				;SI_ok:					
		db  87h,0F7h		;xchg	si,di			
		db  1Eh			;push	ds			
		db  06h			;push	es			
		db  1Fh			;pop	ds			
		db  07h			;pop	es			
		db  0FEh,0CDh		;dec	ch			
		db  75h,0DBh		;jnz	short norm_agn		
		db  0ACh		;lodsb			
		db  92h			;xchg	dx,ax
		db  4Eh			;dec	si
		db  0ADh		;lodsw			
		db  8Bh,0C8h		;mov	cx,ax		
		db  46h			;inc	si		
		db  8Ah,0C2h		;mov	al,dl		
		db  24h,0FEh		;and	al,0FEH		
		db  3Ch,0B0h		;cmp	al,RPTREC
		db  75h,05h		;jne	short TryEnum
		db  0ACh		;lodsb				
		db  0F3h,0AAh		;rep stosb			
		;db 0EBh,07h,90h	;jmp	short TryNext
		db  0EBh,06h		;jmp	short TryNext
				;TryEnum:
		db  3Ch,0B2h		;cmp	al,ENMREC
		db  75h,6Ch		;jne	short CorruptExe		
		db  0F3h,0A4h		;rep movsb			
				;TryNext:
		db  92h			;xchg	dx,ax
		;db 8Ah,0C2h		;mov	al,dl			

		db  0A8h,01h		;test	al,1			
		db  74h,0B9h		;jz	short NextRec			
		db  90h,90h		;nop,nop
	
;last_stop equ $-second
;size_str1 equ $-str1

scan_patch1:
		db  8Ch,0C3h		;mov	bx,es			
		db  8Ch,0D8h		;mov	ax,ds
		db  2Bh,0C2h		;sub	ax,dx
		db  8Eh,0D8h		;mov	ds,ax			
		db  8Eh,0C0h		;mov	es,ax			
		db  0BFh,0Fh,00h	;mov	di,000FH
		db  0B9h,10h,00h	;mov	cx,0010H
		db  0B0h,0FFh		;mov	al,0FFH
		db  0F3h,0AEh		;repz	scasb			
		db  47h			;inc	di			
		db  8Bh,0F7h		;mov	si,di
		db  8Bh,0C3h		;mov	ax,bx			
		db  2Bh,0C2h		;sub	ax, dx
		db  8Eh,0C0h		;mov	es,ax
		db  0BFh,0Fh,00h	;mov	di,000FH
				;NextRec:
		db  0B1h,04h		;mov	cl,4
		db  8Bh,0C6h		;mov	ax,si
		db  0F7h,0D0h		;not	ax		
		db  0D3h,0E8h		;shr	ax,cl		
		db  74h,09h		;jz	short SI_ok
		db  8Ch,0DAh		;mov	dx,ds
		db  2Bh,0D0h		;sub	dx,ax
		db  8Eh,0DAh		;mov	ds,dx		
		db  83h,0CEh,0F0h	;or	si,0FFF0H	       
	       			;SI_ok:
		db  8Bh,0C7h		;mov	ax,di		
		db  0F7h,0D0h		;not	ax
		db  0D3h,0E8h		;shr	ax,cl
		db  74h,09h		;jz	short DI_ok
		db  8Ch,0C2h		;mov	dx,es
		db  2Bh,0D0h		;sub	dx,ax
		db  8Eh,0C2h		;mov	es,dx
		db  83h,0CFh,0F0h	;or	di,0FFF0H
				;DI_ok:

;size_scan_patch1 equ $-scan_patch1

scan_patch2:
		db  8Ch,0C3h		;mov	bx,es			
		db  8Ch,0D8h		;mov	ax,ds
		db  48h			;dec	ax
		db  8Eh,0D8h		;mov	ds,ax			
		db  8Eh,0C0h		;mov	es,ax			
		db  0BFh,0Fh,00h	;mov	di,000FH
		db  0B9h,10h,00h	;mov	cx,0010H
		db  0B0h,0FFh		;mov	al,0FFH
		db  0F3h,0AEh		;repz	scasb			
		db  47h			;inc	di			
		db  8Bh,0F7h		;mov	si,di
		db  8Bh,0C3h		;mov	ax,bx			
		db  48h			;dec	ax
		db  8Eh,0C0h		;mov	es,ax
		db  0BFh,0Fh,00h	;mov	di,000FH		
				;NextRec:
		db  0B1h,04h		;mov	cl,4
		db  8Bh,0C6h		;mov	ax,si
		db  0F7h,0D0h		;not	ax		
		db  0D3h,0E8h		;shr	ax,cl		
		db  74h,0Ah		;jz	short SI_ok
		db  8Ch,0DAh		;mov	dx,ds
		db  2Bh,0D0h		;sub	dx,ax
		db  8Eh,0DAh		;mov	ds,dx		
		db  81h,0CEh,0F0h,0FFh	;or	si,0FFF0H
				;SI_ok:
		db  8Bh,0C7h		;mov	ax,di		
		db  0F7h,0D0h		;not	ax
		db  0D3h,0E8h		;shr	ax,cl
		db  74h,0Ah		;jz	short DI_ok
		db  8Ch,0C2h		;mov	dx,es
		db  2Bh,0D0h		;sub	dx,ax
		db  8Eh,0C2h		;mov	es,dx
		db  81h,0CFh,0F0h,0FFh	;or	di,0FFF0H
				;DI_ok:

;size_scan_patch2 equ $-scan_patch2

scan_patch3:
		db  8Ch,0C3h		;mov	bx,es			
		db  8Ch,0D8h		;mov	ax,ds
		db  48h			;dec	ax
		db  8Eh,0D8h		;mov	ds,ax			
		db  8Eh,0C0h		;mov	es,ax			
		db  0BFh,0Fh,00h	;mov	di,000FH
		db  0B9h,10h,00h	;mov	cx,0010H
		db  0B0h,0FFh		;mov	al,0FFH
		db  0F3h,0AEh		;repz	scasb			
		db  47h			;inc	di			
		db  8Bh,0F7h		;mov	si,di
		db  8Bh,0C3h		;mov	ax,bx			
		db  48h			;dec	ax
		db  8Eh,0C0h		;mov	es,ax
		db  0BFh,0Fh,00h	;mov	di,000FH		
				;NextRec:
		db  0B1h,04h		;mov	cl,4
		db  8Bh,0C6h		;mov	ax,si
		db  0F7h,0D0h		;not	ax		
		db  0D3h,0E8h		;shr	ax,cl		
		db  74h,09h		;jz	short SI_ok
		db  8Ch,0DAh		;mov	dx,ds
		db  2Bh,0D0h		;sub	dx,ax
		db  8Eh,0DAh		;mov	ds,dx	
		db  83h,0CEh,0F0h	;or	si,0FFF0H	
				;SI_ok:
		db  8Bh,0C7h		;mov	ax,di		
		db  0F7h,0D0h		;not	ax
		db  0D3h,0E8h		;shr	ax,cl
		db  74h,09h		;jz	short DI_ok
		db  8Ch,0C2h		;mov	dx,es
		db  2Bh,0D0h		;sub	dx,ax
		db  8Eh,0C2h		;mov	es,dx
		db  83h,0CFh,0F0h	;or	di,0FFF0H
				;DI_ok:

;size_scan_patch3 equ $-scan_patch3

scan_com:
		db  0ACh		;lodsb			
		db  8Ah,0D0h		;mov	dl,al		
		db  4Eh			;dec	si
		db  0ADh		;lodsw			
		db  8Bh,0C8h		;mov	cx,ax		
		db  46h			;inc	si		
		db  8Ah,0C2h		;mov	al,dl		
		db  24h,0FEh		;and	al,0FEH		
		db  3Ch,0B0h		;cmp	al,RPTREC
		db  75h,06h		;jne	short TryEnum
		db  0ACh		;lodsb				
		db  0F3h,0AAh		;rep stosb			
		db  0EBh,07h,90h	;jmp	short TryNext
				;TryEnum:
		db  3Ch,0B2h		;cmp	al,ENMREC
		db  75h,6Bh		;jne	short CorruptExe		
		db  0F3h,0A4h		;rep movsb			
				;TryNext:
		db  8Ah,0C2h		;mov	al,dl			
		db  0A8h,01h		;test	al,1			
		;db 74h,0BAh		;jz	short NextRec
	
; ---------------------------------------------------------------------------

ExePatch:
		call	ExePackPatch
		call	word [ss:RationalPatchPtr]
		retn

; =============== S U B	R O U T	I N E =======================================


ExePackPatch:
		push	bx
		mov	bx, es
		cmp	bx, 0FFFh
		jbe	short ep_cont
		pop	bx
		retn
; ---------------------------------------------------------------------------

ep_cont:				; ...
		push	ds
		push	es
		push	ax
		push	cx
		push	si
		push	di
		sub	cx, 2
		jnb	short epp_1
		jmp	ep_notpacked
; ---------------------------------------------------------------------------

epp_1:					; ...
		mov	di, cx
		mov	es, ax

		mov	[ss:UNPACK_OFFSET], di
		cmp	word [es:di], 'RB'  ;'BR'
		jz	short epp_2
		jmp	ep_notpacked
; ---------------------------------------------------------------------------

epp_2:					; ...
		push	cs
		pop	ds
		add	di, 6Ch
		call	chk_common_str
		jnz	short ep_chkpatch2
		mov	si, scan_patch1
		mov	di, [ss:UNPACK_OFFSET]
		add	di, 28h
		mov	cx, 68
		mov	bx, 142
		mov	ax, 0EF4Eh
		call	chk_patchsum
		jb	short ep_done1
		mov	si, exepatch_start
		mov	cx, 102
		rep movsb

ep_done1:				; ...
		jmp	ep_notpacked
; ---------------------------------------------------------------------------

ep_chkpatch2:				; ...
		mov	di, 76h
		call	chk_common_str
		jnz	short ep_chkpatch3
		mov	si, scan_patch2
		mov	di, 32h
		mov	cx, 68
		mov	bx, 140
		mov	ax, 78B2h
		call	chk_patchsum
		jnb	short ep_patchcode2
		mov	si, scan_patch2
		mov	cx, 68
		mov	bx, 129
		mov	ax, 1C47h
		call	chk_patchsum
		jb	short ep_notpacked

ep_patchcode2:				; ...
		mov	si, exepatch_start
		mov	cx, 3
		rep movsb
		mov	ax, 4890h
		stosw
		add	si, 2
		mov	cx, 20
		rep movsb
		stosw
		add	si, 2
		mov	cx, 75
		rep movsb
		jmp	short ep_notpacked
; ---------------------------------------------------------------------------

ep_chkpatch3:				; ...
		mov	di, 74h
		call	chk_common_str
		jnz	short ep_notpacked
		mov	si, scan_patch3
		mov	di, 32h
		mov	cx, 66
		mov	bx, 139
		mov	ax, 4EDEh
		call	chk_patchsum
		jb	short ep_notpacked
		mov	si, exepatch_start
		mov	cx, 3
		rep movsb
		mov	al, 48h	; 'H'
		stosb
		add	si, 2
		mov	cx, 20
		rep movsb
		stosb
		add	si, 2
		mov	cx, 75
		rep movsb

ep_notpacked:				; ...
		pop	di
		pop	si
		pop	cx
		pop	ax
		pop	es
		pop	ds
		pop	bx
		retn

; =============== S U B	R O U T	I N E =======================================


chk_common_str:
		mov	si, scan_com
		mov	cx, 32
		repe cmpsb
		jz	short ccs_done
		cmp	byte [es:di-1], 56h
		jnz	short ccs_done
		repe cmpsb

ccs_done:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================


chk_patchsum:
		push	di
		repe cmpsb
		jnz	short cp_fail
		mov	di, [ss:87h]
		mov	cx, bx
		mov	bx, ax
		xor	ax, ax

ep_chksum:				; ...
		add	ax, [es:di]
		add	di, 2
		loop	ep_chksum
		pop	di
		cmp	ax, bx
		jnz	short cp_fail
		clc
		retn
; ---------------------------------------------------------------------------

cp_fail:				; ...
		stc
		retn

; ---------------------------------------------------------------------------
RScanPattern1:	db 2 dup(0), 20h, 3 dup(0), 40h, 0, 1, 0 ; ...
RScanPattern2:	db 8Bh,	0Eh, 10h, 0, 90h, 0E2h,	0FEh, 0E8h ; ...
RScanPattern3:	db 8Bh,	0Eh, 10h, 0, 0E2h, 0FEh, 0E8h ;	...
; ---------------------------------------------------------------------------

RationalPatch:				; ...
		cld
		push	ax
		push	bx
		push	cx
		push	dx
		push	si
		push	di
		push	es
		push	ds
		mov	di, 0Ah
		push	cs
		pop	ds
		mov	si, RScanPattern1
		mov	cx, 10
		repe cmpsb
		jnz	short rpexit
		mov	ax, [es:0]
		cmp	ax, 348
		jb	short rpexit
		cmp	ax, 383
		ja	short rpexit
		call	VerifyVersion
		jnz	short rpexit
		mov	cx, [es:16h]
		sub	cx, 200h
		mov	es, word [es:20h]
		mov	si, RScanPattern2
		mov	dx, 8
		call	ScanCodeSeq
		jz	short rpfound
		mov	si, RScanPattern3
		mov	dx, 15
		call	ScanCodeSeq
		jnz	short rpexit

rpfound:				; ...
		mov	al, 9Ah
		stosb
		mov	ax, RatBugCode
		stosw
		mov	ax, ss
		stosw
		mov	cx, dx
		sub	cx, 6
		mov	al, 90h
		rep stosb

rpexit:					; ...
		pop	ds
		pop	es
		pop	di
		pop	si
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		retn
; ---------------------------------------------------------------------------
CPScanPattern	db  89h, 26h, 48h, 01h	; 0 ; ...
		db  8Ch, 0Eh, 4Ch, 01h	; 4
		db 0C7h, 06h, 4Ah, 01h	; 8
		db  00h, 01h, 8Ch, 0Eh	; 12
		db  13h, 01h,0B8h, 20h	; 16
		db  01h,0BEh, 00h, 01h	; 20

; =============== S U B	R O U T	I N E =======================================


IsCopyProt:
		cmp	word [11Bh], 5343h
		jnz	short CP_done
		cmp	word [173h], 5044h
		jnz	short CP_done
		cmp	word [146h], 0F413h
		jnz	short CP_done
		cmp	word [124h], 8000h
		jnz	short CP_done
		push	cs
		pop	es
		mov	di, CPScanPattern
		mov	si, 175h
		mov	cx, 24
		repe cmpsb
		jnz	short CP_done
		mov	byte [ss:A20OFF_COUNT], 0Ah

CP_done:				; ...
		retn

; ---------------------------------------------------------------------------

initiret:				; ...
		iret
; ---------------------------------------------------------------------------
InitBioDataSeg:	dw 70h			; ...

; =============== S U B	R O U T	I N E =======================================


ParaRound:
		add	ax, 15
		rcr	ax, 1
		shr	ax, 1
		shr	ax, 1
		shr	ax, 1
		retn

; ---------------------------------------------------------------------------

DOSINIT:				; ...
		cli
		cld
		push	dx
		push	si
		push	ds
		push	di
		mov	bx, es
		mov	ax, MEMSTRT
		add	ax, 0Fh
		and	ax, 0FFF0h
		mov	si, ax
		mov	ax, cs
		mov	ds, ax
		mov	es, [cs:InitBioDataSeg]
		mov	es, word [es:3] ; DosDataSg equ 3
		xor	di, di
		mov	cx, 4970	; DOSDATASIZE (MSDAT001E)
		rep movsb
		pop	di
		pop	ds
		pop	si
		pop	dx
		push	es
		push	ds
		pop	es
		pop	ds
		mov	word [BiosDataPtr], di
		mov	word [BiosDataPtr+2], bx
		mov	[cs:DosDSeg], ds
		mov	word [cs:LowInt23Addr+2], ds
		mov	word [cs:LowInt24Addr+2], ds
		mov	word [cs:LowInt28Addr+2], ds
		mov	[ENDMEM], dx
		mov	[USER_SP], sp
		mov	[USER_SS], ss
		mov	ax, ds
		mov	ss, ax
		mov	sp, DSKSTACK
		mov	word [FixExePatch], RetExePatch
		mov	word [RationalPatchPtr], RetExePatch
		mov	word [ChkCopyProt], RetExePatch
		call	WhatCPUType
		cmp	al, 2
		mov	ax, Rational386Patch
		jnb	short di_set_patch
		mov	ax, RetExePatch

di_set_patch:				; ...
		mov	[Rational386PatchPtr], ax
		mov	ax, cs
		mov	[TEMP_DOSLOC], ax
		mov	word [NULDEV+2], es
		mov	word [NULDEV], si
		mov	[SIS_Instance_Data_Ptr_2], ds
		push	si
		mov	cx, 7
		mov	si, Instance_Table_2

Instance_init_loop:			; ...
		mov	word [si], ds
		add	si, 6
		loop	Instance_init_loop
		mov	cx, 5
		mov	si, OldInstanceJunk_6

OldInstance_init_loop:			; ...
		mov	word [si], ds
		add	si, 6
		loop	OldInstance_init_loop
		pop	si
		push	es
		pop	ds
		push	ds
		xor	ax, ax
		mov	ds, ax
		mov	ax, initiret
		mov	[0A8h], ax	; [2Ah*4]
		mov	ax, cs
		mov	[0AAh], ax
		pop	ds
		call	CHARINIT
		push	si
		push	ss
		pop	es
		mov	di, SFT0_SFTable	; SFTABL+SFT.SFTable
		mov	ax, 3
		stosw
		dec	al
		stosw
		xor	al, al
		stosb
		mov	al, 0C3h
		stosw
		mov	ax, si
		stosw
		mov	ax, ds
		stosw
		xor	ax, ax
		stosw
		stosw
		stosw
		dec	ax
		stosw
		stosw
		inc	ax
		stosw
		stosw
		add	di, 7
		add	si, 10
		mov	cx, 4
		rep movsw
		mov	cl, 3
		mov	al, ' '
		rep stosb
		pop	si
		or	byte [si+4], 3
		mov	word [ss:BCON], si
		mov	word [ss:BCON+2], ds

char_init_loop:				; ...
		lds	si, [si]
		call	CHARINIT
		test	byte [si+4], 8
		jz	short char_init_loop
		mov	word [ss:BCLOCK], si
		mov	word [ss:BCLOCK+2], ds
		mov	bp, 4970	; MSDAT001E
		mov	word [ss:DPBHEAD], bp
		mov	word [ss:DPBHEAD+2], es

PERDRV:					; ...
		lds	si, [si]
		cmp	si, -1
		jz	short CONTINIT
		call	CHARINIT
		test	word [si+4], 8000h
		jnz	short PERDRV
		mov	cl, [ss:CALLUNIT]
		xor	ch, ch
		mov	[si+10], cl
		mov	dl, [ss:NUMIO]
		xor	dh, dh
		add	[ss:NUMIO], cl
		push	ds
		push	si
		lds	bx, [ss:CALLBPB]

PERUNIT:				; ...
		mov	si, [bx]
		inc	bx
		inc	bx
		mov	[es:bp+0], dl
		mov	[es:bp+1], dh
		push	bx
		push	cx
		push	dx
		call	$SETDPB
		mov	ax, [es:bp+2]
		cmp	ax, [ss:MAXSEC]
		jbe	short NOTMAX
		mov	[ss:MAXSEC], ax

NOTMAX:					; ...
		mov	ax, bp
		add	ax, 33		; DPBSIZ
		mov	[es:bp+19h], ax
		mov	word [es:bp+1Bh], es
		mov	byte [es:bp+18h], 0FFh
		pop	dx
		pop	cx
		pop	bx
		mov	ax, ds
		pop	si
		pop	ds
		mov	[es:bp+13h], si
		mov	word [es:bp+15h], ds
		push	ds
		push	si
		inc	dh
		inc	dl
		mov	ds, ax
		add	bp, 33		; DPBSIZ
		loop	PERUNIT
		pop	si
		pop	ds
		jmp	PERDRV
; ---------------------------------------------------------------------------

CONTINIT:				; ...
		sub	bp, 33
		mov	word [bp+19h], 0FFFFh
		mov	word [bp+1Bh], 0FFFFh
		add	bp, 33
		push	ss
		pop	ds
		mov	ax, bp
		call	ParaRound
		mov	dx, ds
		add	dx, ax
		mov	bx, 0Fh
		mov	cx, [ENDMEM]
		mov	[DOSSEG_INIT], ds
		push	dx
		mov	ax, [TEMP_DOSLOC]
		mov	es, ax
		mov	word [TEMP_DOSLOC], 0FFFFh
		call	patch_vec_segments
		call	patch_misc_segments
		mov	[TEMP_DOSLOC], es
		pop	dx
		xor	ax, ax
		mov	ds, ax
		mov	es, ax
		mov	di, 90h
		mov	ax, [ss:TEMP_DOSLOC]
		mov	[di+2],	ax
		mov	di, 82h
		mov	word [0], DIVOV
		mov	di, 80h		; INTBASE
		mov	ax, irett
		mov	cx, 9

iset1:					; ...
		stosw
		add	di, 2
		loop	iset1
		add	di, 4
		mov	cx, 6

iset2:					; ...
		stosw
		add	di, 2
		loop	iset2
		add	di, 8
		mov	cx, 14

iset3:					; ...
		stosw
		add	di, 2
		loop	iset3
		mov	word [0BCh], INT2F
		mov	ax, [ss:TEMP_DOSLOC]
		mov	[0BEh], ax
		mov	byte [0C0h], 0EAh
		mov	word [0C1h], call_entry
		mov	word [80h], quit
		mov	word [84h], command
		mov	word [88h], 100h
		mov	[8Ah], dx
		mov	word [94h], ABSDRD
		mov	word [98h], ABSDWRT
		mov	word [9Ch], stay_resident
		push	ss
		pop	ds
		push	ss
		pop	es
		push	dx
		inc	dx
		mov	[CurrentPDB], dx
		xor	di, di
		mov	es, dx
		xor	ax, ax
		mov	cx, 128
		rep stosw
		mov	ax, [ENDMEM]
		call	SETMEM
		push	ss
		pop	ds
		mov	di, 24
		xor	ax, ax
		stosw
		stosb
		mov	al, 0FFh
		mov	cx, 17
		rep stosb
		push	ss
		pop	es
		mov	word [SFT_ADDR+2], ds
		mov	si, SysInitTable
		mov	word [es:si+6], es
		mov	word [es:si+2], es
		mov	word [es:BUFFHEAD+2], es
		mov	si, BufferQueue ; HASHINITVAR
		mov	word [es:BUFFHEAD], si
		pop	dx
		mov	word [DMAADD+2], dx
		mov	[es:arena_head], dx
		mov	ds, dx
		mov	byte [0], 'Z'
		mov	word [1], 0
		mov	ax, [ss:ENDMEM]
		sub	ax, dx
		dec	ax
		mov	[3], ax
		mov	di, SFT0_SFTable
		mov	ax, 3
		stosw
		mov	di, SysInitTable
		inc	dx
		mov	ds, dx
		mov	dx, _seg_reinit
		mov	cx, exepatch_start
		sub	cx, $STARTCODE
		mov	ax, initiret
		sub	ax, $STARTCODE
		mov	sp, [ss:USER_SP]
		mov	ss, [ss:USER_SS]
		retf

; =============== S U B	R O U T	I N E =======================================


CHARINIT:
		mov	byte [ss:DEVCALL], 26
		mov	byte [ss:DEVCALL_REQUNIT], 0
		mov	byte [ss:DEVCALL_REQFUNC], 0
		mov	word [ss:DEVCALL_REQSTAT], 0
		push	es
		push	bx
		push	ax
		mov	bx, DEVCALL
		push	ss
		pop	es
		call	DEVIOCALL2
		pop	ax
		pop	bx
		pop	es
		retn

; =============== S U B	R O U T	I N E =======================================


check_XMM:
		push	ax
		mov	ax, 4300h
		int	2Fh		; - Multiplex -	XMS - INSTALLATION CHECK
					; Return: AL = 80h XMS driver installed
					; AL <>	80h no driver
		cmp	al, 80h
		jnz	short cXMM_no_driver
		push	bx
		push	dx
		push	ds
		push	es
		mov	ax, 4310h
		int	2Fh		; - Multiplex -	XMS - GET DRIVER ADDRESS
					; Return: ES:BX	-> driver entry	point
		mov	ds, [cs:DosDSeg]
		mov	word [XMMcontrol], bx
		mov	word [XMMcontrol+2], es
		clc
		pop	es
		pop	ds
		pop	dx
		pop	bx
		pop	ax
		retn
; ---------------------------------------------------------------------------

cXMM_no_driver:				; ...
		stc
		pop	ax
		retn

; ---------------------------------------------------------------------------
num_entry:	db 0			; ...
; ---------------------------------------------------------------------------

_seg_reinit:				; ...
		push	ds
		mov	ds, [cs:DosDSeg]
		call	patch_misc_segments
		cmp	ax, 0
		jnz	short patch_vec_seg
		cmp	byte [cs:num_entry], 0
		jnz	short second_entry
		mov	ax, ds
		call	patch_vec_segments
		call	patch_offset

second_entry:				; ...
		mov	ax, es
		mov	di, DOSINTTABLE
		mov	cx, 9
		push	ds
		pop	es

dosinttabloop:				; ...
		add	di, 2
		stosw
		loop	dosinttabloop
		cmp	ax, 0F000h
		jb	short sr_done
		call	check_XMM
		jb	short sr_done
		call	patch_in_nops
		mov	byte [DosHasHMA], 1
		mov	word [FixExePatch], ExePatch
		mov	word [ChkCopyProt], IsCopyProt
		call	WhatCPUType
		cmp	al, 1
		jnz	short sr_done
		mov	word [RationalPatchPtr], RationalPatch
		jmp	short sr_done
; ---------------------------------------------------------------------------

patch_vec_seg:				; ...
		mov	ax, es
		call	patch_vec_segments

sr_done:				; ...
		mov	byte [cs:num_entry], 1
		pop	ds
		retf

; =============== S U B	R O U T	I N E =======================================


WhatCPUType:
		pushf
		push	bx
		xor	bx, bx
		xor	ax, ax
		push	ax
		popf
		pushf
		pop	ax
		and	ax, 0F000h
		cmp	ax, 0F000h
		jz	short cpu_8086
		mov	ax, 0F000h
		push	ax
		popf
		pushf
		pop	ax
		and	ax, 0F000h
		jz	short cpu_286

cpu_386:
		inc	bx

cpu_286:				; ...
		inc	bx

cpu_8086:				; ...
		mov	ax, bx
		pop	bx
		popf
		retn

; =============== S U B	R O U T	I N E =======================================


patch_vec_segments:
		push	es
		xor	cx, cx
		mov	es, cx
		mov	di, 82h		; INTBASE+2
		mov	[es:2], ax
		mov	cx, 2

ps_set1:				; ...
		stosw
		add	di, 2
		loop	ps_set1
		add	di, 4
		stosw
		add	di, 6
		mov	cx, 4

ps_set2:				; ...
		stosw
		add	di, 2
		loop	ps_set2
		add	di, 4
		mov	cx, 6

ps_set3:				; ...
		stosw
		add	di, 2
		loop	ps_set3
		add	di, 8
		mov	cx, 14

ps_set4:				; ...
		stosw
		add	di, 2
		loop	ps_set4
		mov	[es:0C3h], ax
		pop	es
		retn

; =============== S U B	R O U T	I N E =======================================


patch_misc_segments:
		push	bx
		push	es
		push	ax
		mov	ax, es
		push	ds
		pop	es
		mov	di, JShare
		mov	bx, [TEMP_DOSLOC]
		mov	cx, 15

jumptabloop:				; ...
		add	di, 2
		cmp	bx, 0FFFFh
		jz	short share_patch
		cmp	bx, [es:di]
		jnz	short no_share_patch

share_patch:				; ...
		stosw

no_share_patch:				; ...
		loop	jumptabloop
		mov	si, COUNTRY_CDPG
		mov	word [si+4Fh], ds
		mov	word [si+54h], ds
		mov	word [si+59h], ds
		mov	word [si+5Eh], ds
		mov	word [si+80h], ds
		mov	word [si+63h], ds
		mov	si, FastOpenTable
		cmp	word [TEMP_DOSLOC], 0FFFFh
		jz	short fast_patch
		mov	cx, [TEMP_DOSLOC]
		cmp	cx, [si+4]
		jnz	short no_fast_patch

fast_patch:				; ...
		mov	[si+4],	ax

no_fast_patch:				; ...
		pop	ax
		pop	es
		pop	bx
		retn

; =============== S U B	R O U T	I N E =======================================


patch_offset:
		push	es
		xor	ax, ax
		mov	es, ax
		mov	word [es:0], ldivov
		mov	di, 80h
		mov	ax, lirett
		mov	cx, 2

po_iset1:				; ...
		stosw
		add	di, 2
		loop	po_iset1
		add	di, 4
		stosw
		add	di, 6
		mov	cx, 4

po_iset2:				; ...
		stosw
		add	di, 2
		loop	po_iset2
		add	di, 4
		mov	cx, 6

po_iset3:				; ...
		stosw
		add	di, 2
		loop	po_iset3
		add	di, 8
		mov	cx, 14

po_iset4:				; ...
		stosw
		add	di, 2
		loop	po_iset4
		mov	word [es:0BCh], lint2f
		mov	byte [es:0C0h], 0EAh
		mov	word [es:0C1h], lcall_entry
		mov	word [es:80h], lquit
		mov	word [es:84h], lcommand
		mov	word [es:94h], labsdrd
		mov	word [es:98h], labsdwrt
		mov	word [es:9Ch], lstay_resident
		pop	es
		retn

; ---------------------------------------------------------------------------
patch_table:	dw ldivov
		dw lquit
		dw lcommand
		dw labsdrd
		dw labsdwrt
		dw lstay_resident
		dw lint2f
		dw lcall_entry

; =============== S U B	R O U T	I N E =======================================


patch_in_nops:
		push	ax
		push	si
		mov	si, patch_table
		mov	ax, 9090h
		mov	cx, 8

pin_loop:				; ...
		mov	di, [cs:si]
		stosw
		add	si, 2
		loop	pin_loop
		pop	si
		pop	ax
		retn

; ---------------------------------------------------------------------------
MEMSTRT		db 7 dup(0)		; (MSDOS.SYS - DOSCODE:BF69h)


; ===========================================================================

; ----------------------------------------------------------------------------
segment DOSDATA vstart=0
; ----------------------------------------------------------------------------

byte_BF70	db 4 dup(0)		; ...
DataVersion	dw 1			; ...
WinoldPatch1	db 8 dup(0)		; ...
MYNUM		dw 0			; ...
FCBLRU		dw 0			; ...
OpenLRU		dw 0
OEM_HANDLER	dd 0FFFFFFFFh		; ...
LeaveAddr	dw LeaveDOS		; ...
RetryCount	dw 3			; ...
RetryLoop	dw 1			; ...
LastBuffer	dd 0FFFFFFFFh		; ...
CONTPOS		dw 0			; ...
arena_head	dw 0			; ...
DPBHEAD		dd 0			; ...
SFT_ADDR	dd SFTABL		; ...
BCLOCK		dd 0			; ...
BCON		dd 0			; ...
MAXSEC		dw 128			; ...
BUFFHEAD	dd 0			; ...
CDSADDR		dd 0			; ...
SFTFCB		dd 0			; ...
KEEPCOUNT	dw 0
NUMIO		db 0			; ...
CDSCOUNT	db 0			; ...
NULDEV		dd 0			; ...
		dw 8004h		; DEVTYP|ISNULL
		dw SNULDEV
off_BFC0	dw INULDEV		; ...
aNul		db 'NUL     '           ; ...
SPLICES		db 0			; ...
Special_Entries	dw 0
UU_IFS_DOS_CALL	dd 0			; ...
ChkCopyProt	dw 0			; ...
A20OFF_PSP	dw 0			; ...
BUFFERS_PARM1	dw 0
BUFFERS_PARM2	dw 0
BOOTDRIVE	db 0			; ...
DDMOVE		db 0			; ...
EXT_MEM_SIZE	dw 0
BufferQueue	dd 0			; ...
DirtyBufferCount dw 0			; ...
SC_CACHE_PTR	dd 0			; ...
SC_CACHE_COUNT	dw 0			; ...
BuffInHMA	db 0			; ...
LoMemBuff	dd 0			; ...
UU_BUF_EMS_FIRST_PAGE db 3 dup(0)	; ...
CL0FATENTRY	dw 0FFFFh		; ...
IoStatFail	db 0			; ...
ALLOCMSAVE	db 0			; ...
A20OFF_COUNT	db 0			; ...
DOS_FLAG	db 0			; ...
UNPACK_OFFSET	dw 0			; ...
UMBFLAG		db 0			; ...
SAVE_AX		dw 0			; ...
UMB_HEAD	dw 0FFFFh		; ...
START_ARENA	dw 1			; ...
JShare		dd BadCall		; ...
MFT_enter	dd OKCall		; ...
MFTClose	dd OKCall		; ...
MFTclU		dd BadCall		; ...
MFTCloseP	dd BadCall		; ...
MFTCloN		dd BadCall		; ...
set_block	dd BadCall		; ...
clr_block	dd BadCall		; ...
chk_block	dd OKCall		; ...
MFT_get		dd BadCall		; ...
ShSave		dd BadCall		; ...
ShChk		dd BadCall		; ...
ShCol		dd OKCall		; ...
ShCloseFile	dd BadCall		; ...
ShSU		dd BadCall		; ...
SFTABL		dd 0FFFFFFFFh		; ...
		dw 5
SFT0_SFTable	db 295 dup(0)		; ...
CARPOS		db 0			; ...
STARTPOS	db 0			; ...
INBUF		db 128 dup(0)		; ...
CONBUF		db 131 dup(0)		; ...
PFLAG		db 0			; ...
VERFLG		db 0			; ...
CHARCO		db 3			; ...
chSwitch	db '/'
AllocMethod	db 0			; ...
fShare		db 0			; ...
DIFFNAM		db 1			; ...
MYNAME		db 16 dup(32)		; ...
CritPatch	dw redir_patch		; ...
		dw redir_patch
		dw redir_patch
		dw redir_patch
		dw 0
		db 90h
ERRORMODE	db 0			; ...
INDOS		db 0			; ...
WPERR		db 0FFh			; ...
EXTERR_LOCUS	db 0			; ...
EXTERR		dw 0			; ...
EXTERR_ACT_CLASS dw 0			; ...
EXTERRPT	dd 0			; ...
DMAADD		dd 80h			; ...
CurrentPDB	dw 0			; ...
ConC_Spsave	dw 0			; ...
exit_code	dw 0			; ...
CURDRV		db 0			; ...
CNTCFLAG	db 0			; ...
CPSWFLAG	db 0
CPSWSAVE	db 0
USER_IN_AX	dw 0			; ...
PROC_ID		dw 0			; ...
USER_ID		dw 0			; ...
FirstArena	dw 0			; ...
BestArena	dw 0			; ...
LastArena	dw 0			; ...
ENDMEM		dw 0			; ...
LASTENT		dw 0			; ...
FAILERR		db 0			; ...
ALLOWED		db 0			; ...
NoSetDir	db 0			; ...
DidCTRLC	db 0			; ...
SpaceFlag	db 0			; ...
		db 90h
DAY		db 0			; ...
MONTH		db 0			; ...
YEAR		dw 0			; ...
DAYCNT		dw 0FFFFh		; ...
WEEKDAY		db 0			; ...
CONSWAP		db 0			; ...
IDLEINT		db 1			; ...
fAborting	db 0			; ...
DEVCALL		db 0			; ...
DEVCALL_REQUNIT	db 0			; ...
DEVCALL_REQFUNC	db 0			; ...
DEVCALL_REQSTAT	dw 0			; ...
		db 8 dup(0)
CALLUNIT	db 0			; ...
CALLBR		dd 0			; ...
CALLBPB		dd 0			; ...
CALLVIDRW	dd 0			; ...
CALLNEWSC	dd 0			; ...
CALLDEVAD	dd 0			; ...
IOCALL		db 0			; ...
IOCALL_REQUNIT	db 0			; ...
IOCALL_REQFUNC	db 0			; ...
IOCALL_REQSTAT	dw 0			; ...
		db 8 dup(0)
IOMED		db 0			; ...
IOXAD		dd 0			; ...
IOSCNT		dw 0			; ...
IOSSEC		dw 0			; ...
DSKSTCALL	db 14			; ...
		db 0
DSKSTCOM	db 5			; ...
DSKSTST		dw 0			; ...
		db 8 dup(0)
DSKCHRET	db 0			; ...
DEVIOBUF_PTR	dw DEVIOBUF		; ...
DOSSEG_INIT	dw 0			; ...
DSKSTCNT	dw 1			; ...
		dw 0
CreatePDB	db 0			; ...
Lock_Buffer	dd 0			; ...
		dd 0
		db 90h
USERNUM		dw 0			; ...
USERNUM_hb	db 0			; ...
OEMNUM		db 0FFh
TIMEBUF		dw 3 dup(0)		; ...
DEVIOBUF	dw 0			; ...
OPENBUF		db 128 dup(0)		; ...
RENBUF		db 128 dup(0)		; ...
SEARCHBUF	db 53 dup(0)		; ...
DUMMYCDS	db 88 dup(0)		; ...
NAME1		db 12 dup(0)		; ...
NAME2		db 13 dup(0)		; ...
DESTSTART	dw 0			; ...
		db 5 dup(0)
ATTRIB		db 0			; ...
EXTFCB		db 0			; ...
SATTRIB		db 0			; ...
OPEN_ACCESS	db 0			; ...
FOUNDDEL	db 0			; ...
FOUND_DEV	db 0			; ...
FSPLICE		db 0			; ...
FSHARING	db 0			; ...
SECCLUSPOS	db 0			; ...
TRANS		db 0			; ...
READOP		db 0			; ...
THISDRV		db 0			; ...
CLUSFAC		db 0			; ...
CLUSSPLIT	db 0			; ...
INSMODE		db 0			; ...
CMETA		db 0			; ...
VOLID		db 0			; ...
EXIT_TYPE	db 0			; ...
		db 90h
CREATING	db 0			; ...
DELALL		db 0			; ...
EXITHOLD	dd 0			; ...
USER_SP		dw 0			; ...
USER_SS		dw 0			; ...
CONTSTK		dw 0			; ...
THISDPB		dd 0			; ...
CLUSSAVE	dw 0			; ...
CLUSSEC		dw 2 dup(0)		; ...
PREREAD		dw 0			; ...
FATBYT		dw 0			; ...
FATBYTE		dw 0			; ...
DEVPT		dd 0			; ...
THISSFT		dd 0			; ...
THISCDS		dd 0			; ...
THISFCB		dd 0			; ...
SFN		dw 0FFFFh		; ...
JFN		dw 0			; ...
PJFN		dd 0			; ...
WFP_START	dw 0			; ...
REN_WFP		dw 0			; ...
CURR_DIR_END	dw 0			; ...
NEXTADD		dw 0			; ...
LASTPOS		dw 0			; ...
CLUSNUM		dw 0			; ...
DIRSEC		dw 2 dup(0)		; ...
DIRSTART	dw 0			; ...
SECPOS		dw 2 dup(0)		; ...
VALSEC		dw 2 dup(0)		; ...
BYTSECPOS	dw 0			; ...
BYTPOS		dw 2 dup(0)		; ...
BYTCNT1		dw 0			; ...
BYTCNT2		dw 0			; ...
SECCNT		dw 0			; ...
ENTFREE		dw 0			; ...
ENTLAST		dw 0			; ...
NXTCLUSNUM	dw 0			; ...
GROWCNT		dw 2 dup(0)		; ...
CURBUF		dd 0			; ...
CONSFT		dd 0			; ...
SAVEBX		dw 0			; ...
SAVEDS		dw 0			; ...
RESTORE_TMP	dw 0			; ...
NSS		dw 0			; ...
NSP		dw 0			; ...
EXTOPEN_FLAG	dw 0			; ...
EXTOPEN_ON	db 0			; ...
EXTOPEN_IO_MODE	dw 0			; ...
SAVE_DI		dw 0			; ...
SAVE_ES		dw 0			; ...
SAVE_DX		dw 0			; ...
SAVE_CX		dw 0			; ...
SAVE_BX		dw 0			; ...
SAVE_SI		dw 0			; ...
SAVE_DS		dw 0			; ...
HIGH_SECTOR	dw 0			; ...
OffsetMagicPatch dw MagicPatch		; ...
DISK_FULL	db 0			; ...
TEMP_VAR	dw 0			; ...
TEMP_VAR2	dw 0			; ...
DrvErr		db 0			; ...
DOS34_FLAG	dw 0			; ...
NO_FILTER_PATH	dd 0
NO_FILTER_DPATH	dd 0
AbsRdWr_SS	dw 0			; ...
AbsRdWr_SP	dw 0			; ...
		db 0
RENAMEDMA	db 180h	dup(0)		; ...
AUXSTACK	db 384 dup(0)		; ...
DSKSTACK	db 384 dup(0)		; ...
PRINTER_FLAG	db 0			; ...
VOLCHNG_FLAG	db 0			; ...
VIRTUAL_OPEN	db 0			; ...
FSeek_drive	db 0
FSeek_firclus	dw 0
FSeek_logclus	dw 0
FSeek_logsave	dw 0
TEMP_DOSLOC	dw 0FFFFh		; ...
SWAP_END	db 0			; ...
UCASE_TAB	dw 128			; ...
UCASE_TAB_2	db 128,	154, 69, 65, 142, 65, 143, 128,	3 dup(69), 3 dup(73) ; ...
		db 142,	143, 144, 2 dup(146), 79, 153, 79, 2 dup(85), 89
		db 153,	154, 155, 156, 157, 158, 159, 65, 73, 79, 85, 2	dup(165)
		db 166,	167, 168, 169, 170, 171, 172, 173, 174,	175, 176
		db 177,	178, 179, 180, 181, 182, 183, 184, 185,	186, 187
		db 188,	189, 190, 191, 192, 193, 194, 195, 196,	197, 198
		db 199,	200, 201, 202, 203, 204, 205, 206, 207,	208, 209
		db 210,	211, 212, 213, 214, 215, 216, 217, 218,	219, 220
		db 221,	222, 223, 224, 225, 226, 227, 228, 229,	230, 231
		db 232,	233, 234, 235, 236, 237, 238, 239, 240,	241, 242
		db 243,	244, 245, 246, 247, 248, 249, 250, 251,	252, 253
		db 254,	255
FILE_UCASE_TAB	dw 128			; ...
FILE_UCASE_TAB_2 db 128, 154, 69, 65, 142, 65, 143, 128, 3 dup(69), 3 dup(73) ;	...
		db 142,	143, 144, 2 dup(146), 79, 153, 79, 2 dup(85), 89
		db 153,	154, 155, 156, 157, 158, 159, 65, 73, 79, 85, 2	dup(165)
		db 166,	167, 168, 169, 170, 171, 172, 173, 174,	175, 176
		db 177,	178, 179, 180, 181, 182, 183, 184, 185,	186, 187
		db 188,	189, 190, 191, 192, 193, 194, 195, 196,	197, 198
		db 199,	200, 201, 202, 203, 204, 205, 206, 207,	208, 209
		db 210,	211, 212, 213, 214, 215, 216, 217, 218,	219, 220
		db 221,	222, 223, 224, 225, 226, 227, 228, 229,	230, 231
		db 232,	233, 234, 235, 236, 237, 238, 239, 240,	241, 242
		db 243,	244, 245, 246, 247, 248, 249, 250, 251,	252, 253
		db 254,	255
FILE_CHAR_TAB	dw 22			; ...
		db 1, 0, 255, 2	dup(0),	32, 2, 14
		db '."/\[]:|<>+=;,'
		db 24 dup(0)
COLLATE_TAB	dw 256			; ...
		db 0, 1, 2, 3, 4, 5, 6,	7, 8, 9, 10, 11, 12, 13, 14, 15
		db 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28
		db 29, 30, 31
		db ' !"#$%&',27h,'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]'
		db '^_`ABCDEFGHIJKLMNOPQRSTUVWXYZ{|}~'
		db 127
		db 'CUEAAAACEEEIIIAAEAAOOOUUYOU$$$$$AIOUNN'
		db 166,	167
		db '?'
		db 169,	170, 171, 172
		db '!', 2 dup('"')
		db 176,	177, 178, 179, 180, 181, 182, 183, 184,	185, 186
		db 187,	188, 189, 190, 191, 192, 193, 194, 195,	196, 197
		db 198,	199, 200, 201, 202, 203, 204, 205, 206,	207, 208
		db 209,	210, 211, 212, 213, 214, 215, 216, 217,	218, 219
		db 220,	221, 222, 223, 224
		db 'S'
		db 226,	227, 228, 229, 230, 231, 232, 233, 234,	235, 236
		db 237,	238, 239, 240, 241, 242, 243, 244, 245,	246, 247
		db 248,	249, 250, 251, 252, 253, 254, 255
DBCS_TAB	dw 0			; ...
DBCS_TAB_2	db 16 dup(0)		; ...
; ---------------------------------------------------------------------------

MAP_CASE:				; ...
		cmp	al, 80h
		jnb	short Map1
		retf
; ---------------------------------------------------------------------------

Map1:					; ...
		sub	al, 80h
		push	ds
		push	bx
		mov	bx, UCASE_TAB_2
		push	cs
		pop	ds
		xlat
		pop	bx
		pop	ds
		retf
; ---------------------------------------------------------------------------
InterChar	db 0
InterCon	db 0
SaveCurFlg	db 0
TEMPSEG		dw 0			; ...
redir_patch	db 0			; ...
Mark1		db 5 dup(0)
MSVERSION	db 6
		db 22
YRTAB		db 200,	166, 200, 165, 200, 165, 200, 165 ; ...
MONTAB		db 31			; ...
february	db 28			; ...
		db 31, 30, 31, 30, 2 dup(31), 30, 31, 30, 31
SysInitTable	dd DPBHEAD	; ...
		dd COUNTRY_CDPG
FastOpenTable	dw 2			; ...
FastTable_2	dw FastRet	; ...
		dw 0
		dw FastRet
		dw 0
FastOpenFlg	db 0			; ...
FastOpen_Ext_Info db 11	dup(0)		; ...
Dir_Info_Buff	db 32 dup(0)		; ...
Next_Element_Start dw 0			; ...
Del_ExtCluster	dw 0
USER_SP_2F	dw FAKE_STACK_2F	; ...
FAKE_STACK_2F	dw 14 dup(0)		; ...
Hash_Temp	dw 4 dup(0)
SCAN_FLAG	db 0			; ...
DATE_FLAG	dw 0			; ...
FETCHI_TAG	dw 0
MSG_EXTERROR	dd 0
		dd 0
		dd 0
		dd 0
		dd 0
SEQ_SECTOR	dw 2 dup(0FFFFh)	; ...
SC_SECTOR_SIZE	dw 0			; ...
SC_DRIVE	db 0			; ...
CurSC_DRIVE	db 0FFh			; ...
CurSC_SECTOR	dw 2 dup(0)		; ...
SC_STATUS	dw 0			; ...
SC_FLAG		db 0			; ...
AbsDskErr	dw 0			; ...
NO_NAME_ID	db 'NO NAME    '        ; ...
LOOKSIZ		db 0
; ---------------------------------------------------------------------------

SNULDEV:
		or	word [es:bx+3], 100h

INULDEV:
		retf
; ---------------------------------------------------------------------------
WinoldPatch2	db 8 dup(0)		; ...
UmbSave2	db 5 dup(0)		; ...
UmbSaveFlag	db 0			; ...
ERR_TABLE_21	db 1, 7, 4, 0FFh, 2, 8,	3, 2, 3, 8, 3, 2, 4, 1,	4, 1, 5	; ...
		db 2 dup(3), 0FFh, 6, 7, 4, 1, 2 dup(7), 2 dup(5), 8, 1
		db 4, 5, 9, 7, 4, 5, 0Ah, 7, 4,	5, 0Bh,	9, 3, 1, 0Ch, 7
		db 4, 1, 0Dh, 9, 4, 1, 0Fh, 8, 3, 2, 10h, 2 dup(3), 2
		db 11h,	0Dh, 3,	2, 12h,	8, 3, 2, 50h, 0Ch, 3, 2, 20h, 0Ah
		db 2 dup(2), 21h, 0Ah, 2 dup(2), 54h, 1, 4, 0FFh, 56h
		db 2 dup(3), 1,	52h, 1,	4, 2, 32h, 9, 2	dup(3),	55h, 0Ch
		db 2 dup(3), 57h, 9, 3,	1, 53h,	0Dh, 4,	1, 24h,	1, 4, 5
		db 26h,	1, 4, 1, 27h, 1, 4, 1, 5Ah, 0Dh, 4, 2, 4 dup(0FFh)
ERR_TABLE_24	db 13h,	0Bh, 7,	2, 14h,	4, 5, 1, 15h, 5, 7, 0FFh, 16h ;	...
		db 4, 5, 1, 17h, 0Bh, 4, 2, 18h, 4, 5, 1, 19h, 5, 1, 2
		db 1Ah,	0Bh, 7,	2, 1Bh,	0Bh, 4,	2, 1Ch,	2, 7, 4, 1Dh, 5
		db 4, 0FFh, 1Eh, 5, 4, 0FFh, 1Fh, 0Dh, 4, 0FFh,	20h, 0Ah
		db 2 dup(2), 21h, 0Ah, 2 dup(2), 22h, 0Bh, 7, 2, 32h, 9
		db 2 dup(3), 23h, 7, 4,	1, 24h,	1, 4, 5, 0FFh, 0Dh, 5
		db 0FFh
ErrMap24	db 13h,	14h, 15h, 16h, 17h, 18h, 19h, 1Ah, 1Bh,	1Ch, 1Dh ; ...
		db 1Eh,	3 dup(1Fh), 22h
FIRST_BUFF_ADDR	dw 0			; ...
SPECIAL_VERSION	dw 0			; ...
FAKE_COUNT	db 255 dup(0)
OLD_FIRSTCLUS	dw 0			; ...
exec_init_SP	dw 0			; ...
exec_init_SS	dw 0			; ...
exec_init_IP	dw 0			; ...
exec_init_CS	dw 0			; ...
exec_signature	dw 0			; ...
exec_len_mod_512 dw 0
exec_pages	dw 0			; ...
exec_rle_count	dw 0			; ...
exec_par_dir	dw 0			; ...
exec_min_BSS	dw 0			; ...
exec_max_BSS	dw 0			; ...
exec_SS		dw 0			; ...
exec_SP		dw 0			; ...
exec_chksum	dw 0
exec_IP		dw 0			; ...
exec_CS		dw 0
exec_rle_table	dw 0			; ...
Win386_Info	db 3			; ...
		db 0
		dd 0
Win386_Info_6	dd 0			; ...
		dd 0
SIS_Instance_Data_Ptr dw Instance_Table
SIS_Instance_Data_Ptr_2	dw 0		; ...
Instance_Table	dw CONTPOS		; ...
Instance_Table_2 dw 0			; ...
		dw 2
		dw BCON
		dw 0
		dw 4
		dw CARPOS
		dw 0
		dw 106h
		dw CHARCO
		dw 0
		dw 1
		dw exec_init_SP
		dw 0
		dw 34
		dw UMBFLAG
		dw 0
		dw 1
		dw UMB_HEAD
		dw 0
		dw 2
		dw 0
		dw 0
Win386_DOSVars	db 5			; ...
		db 0
		dw SAVEDS
		dw SAVEBX
		dw INDOS
		dw USER_ID
		dw CritPatch
		dw UMB_HEAD
IsWin386	db 0			; ...
VxDpath		db 'c:\wina20.386',0    ; ...
DriverLoad	db 1			; ...
BiosDataPtr	dd 0			; ...
		db 36h,	0F6h, 6, 20h, 3, 0FFh
		db 75h,	0Ch
		db 36h,	0FFh, 36h, 58h,	3
		db 0CDh, 28h
		db 80h,	3Eh, 20h, 3, 0
		db 75h,	37h
		db 0BCh, 0A0h, 0Ah
LocalSFT	dd 0			; ...
		db 90h
DOSINTTABLE	dd DIVOV		; ...
DOSINTTABLE_4	dd quit			; ...
DOSINTTABLE_8	dd command		; ...
DOSINTTABLE_12	dd ABSDRD		; ...
DOSINTTABLE_16	dd ABSDWRT		; ...
DOSINTTABLE_20	dd stay_resident	; ...
DOSINTTABLE_24	dd INT2F		; ...
DOSINTTABLE_28	dd call_entry		; ...
DOSINTTABLE_32	dd irett
SS_Save		dw 0			; ...
SP_Save		dw 0			; ...
; ---------------------------------------------------------------------------

ldivov:
		jmp	short divov_cont
; ---------------------------------------------------------------------------
		call	EnsureA20ON

divov_cont:
		jmp	far [cs:DOSINTTABLE]
; ---------------------------------------------------------------------------

lquit:
		jmp	short quit_cont
; ---------------------------------------------------------------------------
		call	EnsureA20ON

quit_cont:
		jmp	far [cs:DOSINTTABLE_4]
; ---------------------------------------------------------------------------

lcommand:
		jmp	short command_cont
; ---------------------------------------------------------------------------
		call	EnsureA20ON

command_cont:
		jmp	far [cs:DOSINTTABLE_8]
; ---------------------------------------------------------------------------

labsdrd:
		jmp	short absdrd_cont
; ---------------------------------------------------------------------------
		call	EnsureA20ON

absdrd_cont:
		jmp	far [cs:DOSINTTABLE_12]
; ---------------------------------------------------------------------------

labsdwrt:
		jmp	short absdwrt_cont
; ---------------------------------------------------------------------------
		call	EnsureA20ON

absdwrt_cont:
		jmp	far [cs:DOSINTTABLE_16]
; ---------------------------------------------------------------------------

lstay_resident:
		jmp	short sr_cont
; ---------------------------------------------------------------------------
		call	EnsureA20ON

sr_cont:
		jmp	far [cs:DOSINTTABLE_20]
; ---------------------------------------------------------------------------

lint2f:
		jmp	short int2f_cont
; ---------------------------------------------------------------------------
		call	EnsureA20ON

int2f_cont:
		jmp	far [cs:DOSINTTABLE_24]
; ---------------------------------------------------------------------------

lcall_entry:
		jmp	short callentry_cont
; ---------------------------------------------------------------------------
		call	EnsureA20ON

callentry_cont:
		jmp	far [cs:DOSINTTABLE_28]
; ---------------------------------------------------------------------------

lirett:
		iret
; ---------------------------------------------------------------------------
DosRetAddr23	dd 0			; ...
DosRetAddr24	dd 0			; ...
DosRetAddr28	dd 0
; ---------------------------------------------------------------------------

LowInt23:				; ...
		pop	word [cs:DosRetAddr23]
		pop	word [cs:DosRetAddr23+2]
		int	23h		; DOS -	CONTROL	"C" EXIT ADDRESS
					; Return: return via RETF 2 with CF set
					; DOS will abort program with errorlevel 0
					; else
					; interrupted DOS call continues
		call	EnsureA20ON
		jmp	far [cs:DosRetAddr23]
; ---------------------------------------------------------------------------

LowInt24:				; ...
		pop	word [cs:DosRetAddr24]
		pop	word [cs:DosRetAddr24+2]
		int	24h		; DOS -	FATAL ERROR HANDLER ADDRESS
					; Automatically	called upon detection of unrecoverable I/O error.
		call	EnsureA20ON
		jmp	far [cs:DosRetAddr24]
; ---------------------------------------------------------------------------

LowInt28:				; ...
		int	28h		; DOS 2+ internal - KEYBOARD BUSY LOOP
		call	EnsureA20ON
		retf
; ---------------------------------------------------------------------------

disa20_xfer:				; ...
		call	XMMDisableA20
		cli
		mov	byte [cs:INDOS], 0
		mov	ss, ax
		mov	sp, di
		sti
		push	ds
		push	si
		mov	es, dx
		mov	ds, dx
		mov	ax, bx
		retf
; ---------------------------------------------------------------------------

disa20_iret:				; ...
		call	XMMDisableA20
		dec	byte [INDOS]
		mov	ss, [USER_SS]
		mov	sp, [USER_SP]
		mov	bp, sp
		mov	[bp+0],	al
		mov	ax, [NSP]
		mov	[USER_SP], ax
		mov	ax, [NSS]
		mov	[USER_SS], ax
		pop	ax
		pop	bx
		pop	cx
		pop	dx
		pop	si
		pop	di
		pop	bp
		pop	ds
		pop	es
		iret

; =============== S U B	R O U T	I N E =======================================


XMMDisableA20:
		push	bx
		push	ax
		mov	ah, 6
		call	far [cs:XMMcontrol]
		pop	ax
		pop	bx
		retn

; ---------------------------------------------------------------------------
XMMcontrol:	dd 0			; ...
LowMemory:	dd 80h			; ...
HighMemory:	dd 0FFFF0090h		; ...

; =============== S U B	R O U T	I N E =======================================


EnsureA20ON:
		pushf
		push	ds
		push	es
		push	cx
		push	si
		push	di
		lds	si, [cs:LowMemory]
		les	di, [cs:HighMemory]
		mov	cx, 4
		cld
		repe cmpsw
		jz	short EA20_OFF

EA20_RET:				; ...
		pop	di
		pop	si
		pop	cx
		pop	es
		pop	ds
		popf
		retn
; ---------------------------------------------------------------------------

EA20_OFF:				; ...
		push	bx
		push	ax
		mov	ax, ss
		mov	[cs:SS_Save], ax
		mov	[cs:SP_Save], sp
		mov	ax, cs
		mov	ss, ax
		mov	sp, AUXSTACK
		mov	ah, 5
		call	far [cs:XMMcontrol]
		or	ax, ax
		jz	short XMMerror
		mov	ax, [cs:SS_Save]
		mov	ss, ax
		mov	sp, [cs:SP_Save]
		pop	ax
		pop	bx
		jmp	short EA20_RET
; ---------------------------------------------------------------------------

XMMerror:				; ...
		mov	ah, 0Fh
		int	10h		; - VIDEO - GET	CURRENT	VIDEO MODE
					; Return: AH = number of columns on screen
					; AL = current video mode
					; BH = current active display page
		cmp	al, 7
		jz	short XMMcont
		xor	ah, ah
		mov	al, 2
		int	10h		; - VIDEO - SET	VIDEO MODE
					; AL = mode

XMMcont:				; ...
		mov	ah, 5
		xor	al, al
		int	10h		; - VIDEO - SELECT DISPLAY PAGE
					; AL = display page, 0-7  for modes 0 &	1, 0-3	for modes 2 & 3
		mov	si, XMMERRMSG ; "\r\nA20	Hardware Error\r\n$"
		push	cs
		pop	ds
		cld

XMMprnt:				; ...
		lodsb
		cmp	al, '$'
		jz	short XMMStall
		mov	ah, 0Eh
		mov	bx, 7
		int	10h		; - VIDEO - WRITE CHARACTER AND	ADVANCE	CURSOR (TTY WRITE)
					; AL = character, BH = display page (alpha modes)
					; BL = foreground color	(graphics modes)
		jmp	short XMMprnt
; ---------------------------------------------------------------------------

XMMStall:				; ...
		sti
		jmp	short XMMStall

; ---------------------------------------------------------------------------
OldInstanceJunk: dw 70h			; ...
		dw 0
		dw 6
OldInstanceJunk_6: dw 0			; ...
		dw CONTPOS
		dw 2
		dw 0
		dw BCON
		dw 4
		dw 0
		dw CARPOS
		dw 106h
		dw 0
		dw CHARCO
		dw 1
		dw 0
		dw exec_init_SP
		dw 34
		dw 70h
		dw 0Ch
		dw 1
DosHasHMA:	db 0			; ...
FixExePatch:	dw 0			; ...
RationalPatchPtr: dw 0			; ...
; ---------------------------------------------------------------------------

RatBugCode:				; ...
		push	cx
		; 27/09/2023
		mov	cx, [10h]	; db 0B9h, dw 10h
rbc_loop:				; ...
		loop	rbc_loop
		pop	cx
		retf
; ---------------------------------------------------------------------------
UmbSave1:	db 11 dup(0)		; ...
COUNTRY_CDPG:	db 8 dup(0)		; ...
		db '\COUNTRY.SYS',0
		db 51 dup(0)
		dw 437
		dw 6
COUNTRY_CDPG_76: db 2			; ...
		dw UCASE_TAB
		dw 0
		db 4
		dw FILE_UCASE_TAB
		dw 0
		db 5
		dw FILE_CHAR_TAB
		dw 0
		db 6
		dw COLLATE_TAB
		dw 0
		db 7
		dw DBCS_TAB
		dw 0
		db 1
		dw 38
		dw 1
		dw 437
COUNTRY_CDPG_108: dw 0			; ...
		db '$',0,0,0,0
		db ',',0
		db '.',0
		db '-',0
		db ':',0
		db 0
		db 2
		db 0
		dw MAP_CASE
		dw 0
		db ',',0
		dw 5 dup(0)
XMMERRMSG:	db 0Dh,0Ah		; ...
		db 'A20 Hardware Error',0Dh,0Ah,'$'
DOSP1_ID:	db 36h,	0C5h, 36h
DOSP1_THISSFT:	db 36h,	5, 0C5h, 74h, 7, 0E8h
		db 2 dup(90h)
DOSP12_ID:	db 36h,	0C5h, 36h
DOSP12_THISSFT:	db 36h,	5, 0C5h, 74h, 7, 0E8h
DOSP3_ID:	db 51h,	6, 57h,	0BAh
DOSP3_CONBUF:	db 29h,	2, 0E8h
		db 9Ah,	0E3h, 5Fh, 7
DOSP4_ID:	db 59h
DOSP5_ID:	db 51h
		db 0ACh, 3Ch, 1Ah, 74h,	5
		db 0E8h
DOSP7_ID:	db 2Eh,	8Ch, 1Eh
DOSP7_SAVEDS:	db 7Eh,	5
		db 2Eh,	89h, 1Eh
DOSP7_SAVEBX:	db 7Ch,	5
		db 8Ch,	0CBh
		db 8Eh,	0DBh
		db 0FEh, 6
DOSP7_INDOS:	db 0CFh, 2
		db 33h,	0C0h
DOSP8_ID:	db 50h
		db 36h,	0A1h
DOSP8_USER_ID:	db 0EAh, 2
		db 26h,	3Bh, 45h
		db 2Fh,	58h
DOSP10_ID:	db 6, 1Fh
DOSP10_LOC:	db 8Bh,	0DFh
		db 33h,	0C0h, 8Bh, 0D0h, 0E8h
		db 0DFh, 0Eh
		db 1Eh,	36h, 0C5h, 2 dup(36h), 5, 0E8h,	0AFh, 0Eh
		db 8Bh,	0D7h, 0B4h, 86h, 36h, 8Bh, 3Eh
		db 9, 3
		db 0F7h, 0C7h, 0, 80h, 74h, 19h, 0E8h, 47h, 17h
		db 8Bh,	0FAh, 0Ah, 0C0h, 74h, 10h, 3Ch,	3, 74h,	3
		db 1Fh,	0EBh, 0CFh
		db 5Fh
		db 36h,	0C4h, 3Eh, 36h,	5, 0E9h, 0A1h, 4
		db 5Fh,	8Bh, 0FAh
DOSP13_ID:	db 0ACh
		db 3Ch,	24h
		db 74h,	8
		db 0B3h, 7
		db 0B4h, 0Eh
		db 0CDh, 10h
		db 0EBh, 0F3h
		db 0EBh, 0FEh
Rational386PatchPtr: dw 0		; ...
; ---------------------------------------------------------------------------

MagicPatch:				; ...
		retf
; ---------------------------------------------------------------------------
		nop
		nop
		nop
		nop
		nop
; END
