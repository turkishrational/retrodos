seg000:0000 ;
seg000:0000 ; +-------------------------------------------------------------------------+
seg000:0000 ; |	  This file has	been generated by The Interactive Disassembler (IDA)	|
seg000:0000 ; |		  Copyright (c)	2013 Hex-Rays, <support@hex-rays.com>		|
seg000:0000 ; |			     Licensed to: Freeware version			|
seg000:0000 ; +-------------------------------------------------------------------------+
seg000:0000 ;
seg000:0000 ; Input MD5	  : 668F4B20F6E29BE5E81D1D351DA48C22
seg000:0000 ; Input CRC32 : 5A0CE9FB
seg000:0000
seg000:0000 ; File Name	  : C:\Users\Erdoðan\Desktop\SYSINIT.BIN
seg000:0000 ; Format	  : Binary file
seg000:0000 ; Base Address: 0000h Range: 0000h - 3D20h Loaded length: 00003D20h
seg000:0000
seg000:0000		    .386
seg000:0000		    .model flat
seg000:0000
seg000:0000 ; ===========================================================================
seg000:0000
seg000:0000 ; Segment type: Pure code
seg000:0000 seg000	    segment byte public	'CODE' use16
seg000:0000		    assume cs:seg000
seg000:0000		    assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing
seg000:0000 SYSINIT$	    dw 0		    ; DATA XREF: AllocMemForDOS+47r
seg000:0000					    ; AllocMemForDOS+54w ...
seg000:0002 stackcount	    dw 0		    ; DATA XREF: stackinit+Dw
seg000:0002					    ; stackinit+35r ...
seg000:0004 stackat	    dw 0		    ; DATA XREF: stackinit+3Ew
seg000:0004					    ; stackinit+47r
seg000:0006 stacksize	    dw 0		    ; DATA XREF: stackinit+14w
seg000:0006					    ; stackinit+4Cr ...
seg000:0008 stacks	    dd 0		    ; DATA XREF: seg000:firstentryo
seg000:0008					    ; seg000:0624w ...
seg000:000C firstentry	    dw offset stacks	    ; DATA XREF: do_int_stacks:foundbad02r
seg000:000C					    ; longpath:inuser ...
seg000:000E lastentry	    dw 48h		    ; DATA XREF: longpathr
seg000:000E					    ; seg000:0639w ...
seg000:000E					    ; stacks+(defaultcount*entrysize)-entrysize
seg000:0010 nextentry	    dw 48h		    ; DATA XREF: do_int_stacks+8r
seg000:0010					    ; do_int_stacks+17w ...
seg000:0010					    ; stacks+(defaultcount*entrysize)-entrysize
seg000:0012 old02	    dd 0		    ; DATA XREF: seg000:002Dr
seg000:0012					    ; stackinit+ACo
seg000:0016 ; ---------------------------------------------------------------------------
seg000:0016
seg000:0016 int02:				    ; DATA XREF: stackinit+AFo
seg000:0016		    push    ax
seg000:0017		    push    es
seg000:0018		    mov	    ax,	0F000h
seg000:001B		    mov	    es,	ax
seg000:001D		    assume es:nothing
seg000:001D
seg000:001D loc_1D:				    ; DATA XREF: AllocMemForDOS+22w
seg000:001D		    cmp	    byte ptr es:0FFFEh,	0F9h ; 'ù'
seg000:0023		    pop	    es
seg000:0024		    assume es:nothing
seg000:0024
seg000:0024 loc_24:				    ; DATA XREF: UnlinkUMB+Fr
seg000:0024		    jnz	    short normal02
seg000:0026		    in	    al,	62h	    ; PC/XT PPI	port C.	Bits:
seg000:0026					    ; 0-3: values of DIP switches
seg000:0026					    ; 5: 1=Timer 2 channel out
seg000:0026					    ; 6: 1=I/O channel check
seg000:0026					    ; 7: 1=RAM parity check error occurred.
seg000:0028
seg000:0028 loc_28:				    ; DATA XREF: AllocMemForDOS+29w
seg000:0028		    test    al,	80h
seg000:002A		    jz	    short normal02
seg000:002C		    pop	    ax
seg000:002D		    jmp	    cs:old02
seg000:0032 ; ---------------------------------------------------------------------------
seg000:0032
seg000:0032 normal02:				    ; CODE XREF: seg000:loc_24j
seg000:0032					    ; seg000:002Aj
seg000:0032		    pop	    ax
seg000:0033		    call    near ptr do_int_stacks
seg000:0036		    adc	    al,	[bx+si]
seg000:0036 ; ---------------------------------------------------------------------------
seg000:0038 old08	    dd 0		    ; DATA XREF: stackinit+BBo
seg000:003C ; ---------------------------------------------------------------------------
seg000:003C
seg000:003C int08:				    ; DATA XREF: stackinit+BEo
seg000:003C		    call    near ptr do_int_stacks
seg000:003F		    cmp	    [bx+si], al	    ; DATA XREF: longpath+69r
seg000:003F ; ---------------------------------------------------------------------------
seg000:0041 old09	    dd 0		    ; DATA XREF: seg000:off_4Co
seg000:0041					    ; stackinit+CAo ...
seg000:0045 ; ---------------------------------------------------------------------------
seg000:0045
seg000:0045 int09:				    ; DATA XREF: stackinit+CDo
seg000:0045		    jmp	    short keyboard_lbl
seg000:0047 ; ---------------------------------------------------------------------------
seg000:0047		    nop
seg000:0047 ; ---------------------------------------------------------------------------
seg000:0048 byte_48	    db 0		    ; DATA XREF: LinkFirstUMB+5r
seg000:0049 ; ---------------------------------------------------------------------------
seg000:0049
seg000:0049 keyboard_lbl:			    ; CODE XREF: seg000:int09j
seg000:0049		    call    near ptr do_int_stacks
seg000:0049 ; ---------------------------------------------------------------------------
seg000:004C off_4C	    dw offset old09	    ; DATA XREF: seg000:04BDr
seg000:004E old70	    dd 0		    ; DATA XREF: IsVDiskInstalled+4r
seg000:004E					    ; stackinit+D9o
seg000:0052 ; ---------------------------------------------------------------------------
seg000:0052
seg000:0052 int70:				    ; DATA XREF: stackinit+DCo
seg000:0052					    ; seg000:0488r ...
seg000:0052		    call    near ptr do_int_stacks
seg000:0055		    dec	    si
seg000:0055 ; ---------------------------------------------------------------------------
seg000:0056		    db	  0
seg000:0057 ; ---------------------------------------------------------------------------
seg000:0057
seg000:0057 int0A:				    ; DATA XREF: stackinit+119o
seg000:0057		    jmp	    short entry_int0A_stk
seg000:0057 ; ---------------------------------------------------------------------------
seg000:0059 old0A	    dd 0		    ; DATA XREF: stackinit+116o
seg000:005D		    dw 424Bh
seg000:005F firstflag0A	    db 0
seg000:0060 ; ---------------------------------------------------------------------------
seg000:0060
seg000:0060 loc_60:				    ; DATA XREF: seg000:sysinit_basew
seg000:0060					    ; seg000:1168r
seg000:0060		    jmp	    short intret_0A
seg000:0060 ; ---------------------------------------------------------------------------
seg000:0062 byte_62	    db 7 dup(0)		    ; DATA XREF: seg000:1161w
seg000:0062					    ; seg000:116Dr ...
seg000:0069 ; ---------------------------------------------------------------------------
seg000:0069
seg000:0069 entry_int0A_stk:			    ; CODE XREF: seg000:int0Aj
seg000:0069		    call    near ptr do_int_stacks
seg000:006C		    pop	    cx
seg000:006C ; ---------------------------------------------------------------------------
seg000:006D		    db	  0
seg000:006E ; ---------------------------------------------------------------------------
seg000:006E
seg000:006E intret_0A:				    ; CODE XREF: seg000:loc_60j
seg000:006E		    iret
seg000:006F ; ---------------------------------------------------------------------------
seg000:006F
seg000:006F int0B:
seg000:006F		    jmp	    short entry_int0B_stk
seg000:006F ; ---------------------------------------------------------------------------
seg000:0071 old0B	    dd 0		    ; DATA XREF: seg000:off_84o
seg000:0075		    dw 424Bh
seg000:0077 firstflag0B	    db 0
seg000:0078 ; ---------------------------------------------------------------------------
seg000:0078		    jmp	    short intret_0B
seg000:0078 ; ---------------------------------------------------------------------------
seg000:007A		    db 7 dup(0)
seg000:0081 ; ---------------------------------------------------------------------------
seg000:0081
seg000:0081 entry_int0B_stk:			    ; CODE XREF: seg000:int0Bj
seg000:0081		    call    near ptr do_int_stacks
seg000:0081 ; ---------------------------------------------------------------------------
seg000:0084 off_84	    dw offset old0B	    ; DATA XREF: seg000:05F8r
seg000:0084					    ; seg000:05FCr ...
seg000:0086 ; ---------------------------------------------------------------------------
seg000:0086
seg000:0086 intret_0B:				    ; CODE XREF: seg000:0078j
seg000:0086					    ; DATA XREF: multi_pass+7D9w
seg000:0086		    iret
seg000:0087 ; ---------------------------------------------------------------------------
seg000:0087
seg000:0087 int0C:				    ; DATA XREF: stackinit+199o
seg000:0087		    jmp	    short entry_int0C_stk
seg000:0087 ; ---------------------------------------------------------------------------
seg000:0089 old0C	    dd 0		    ; DATA XREF: stackinit+196o
seg000:0089					    ; umb_insert+6r ...
seg000:008D		    dw 424Bh
seg000:008F firstflag0C	    db 0
seg000:0090 ; ---------------------------------------------------------------------------
seg000:0090		    jmp	    short intret_0C
seg000:0090 ; ---------------------------------------------------------------------------
seg000:0092		    db 7 dup(0)
seg000:0099 ; ---------------------------------------------------------------------------
seg000:0099
seg000:0099 entry_int0C_stk:			    ; CODE XREF: seg000:int0Cj
seg000:0099		    call    near ptr do_int_stacks
seg000:009C		    mov	    [bx+si], ax
seg000:009E
seg000:009E intret_0C:				    ; CODE XREF: seg000:0090j
seg000:009E		    iret
seg000:009F ; ---------------------------------------------------------------------------
seg000:009F
seg000:009F int0D:				    ; DATA XREF: stackinit+1D9o
seg000:009F		    jmp	    short entry_int0D_stk
seg000:009F ; ---------------------------------------------------------------------------
seg000:00A1 old0D	    dd 0		    ; DATA XREF: seg000:00B4o
seg000:00A1					    ; stackinit+1D6o
seg000:00A5		    dw 424Bh
seg000:00A7 firstflag0D	    db 0
seg000:00A8 ; ---------------------------------------------------------------------------
seg000:00A8		    jmp	    short intret_0D
seg000:00A8 ; ---------------------------------------------------------------------------
seg000:00AA		    db 7 dup(0)
seg000:00B1 ; ---------------------------------------------------------------------------
seg000:00B1
seg000:00B1 entry_int0D_stk:			    ; CODE XREF: seg000:int0Dj
seg000:00B1		    call    near ptr do_int_stacks
seg000:00B1 ; ---------------------------------------------------------------------------
seg000:00B4		    dw offset old0D
seg000:00B6 ; ---------------------------------------------------------------------------
seg000:00B6
seg000:00B6 intret_0D:				    ; CODE XREF: seg000:00A8j
seg000:00B6		    iret
seg000:00B7 ; ---------------------------------------------------------------------------
seg000:00B7
seg000:00B7 int0E:				    ; DATA XREF: stackinit+219o
seg000:00B7		    jmp	    short entry_int0E_stk
seg000:00B7 ; ---------------------------------------------------------------------------
seg000:00B9 old0E	    dd 0		    ; DATA XREF: seg000:00CCo
seg000:00B9					    ; stackinit+216o ...
seg000:00BD word_BD	    dw 424Bh		    ; DATA XREF: seg000:04E7r
seg000:00BF firstflag0E	    db 0
seg000:00C0 ; ---------------------------------------------------------------------------
seg000:00C0		    jmp	    short intret_0E
seg000:00C0 ; ---------------------------------------------------------------------------
seg000:00C2		    db 7 dup(0)
seg000:00C9 ; ---------------------------------------------------------------------------
seg000:00C9
seg000:00C9 entry_int0E_stk:			    ; CODE XREF: seg000:int0Ej
seg000:00C9		    call    near ptr do_int_stacks
seg000:00C9 ; ---------------------------------------------------------------------------
seg000:00CC		    dw offset old0E
seg000:00CE ; ---------------------------------------------------------------------------
seg000:00CE
seg000:00CE intret_0E:				    ; CODE XREF: seg000:00C0j
seg000:00CE		    iret
seg000:00CF ; ---------------------------------------------------------------------------
seg000:00CF
seg000:00CF int72:				    ; DATA XREF: stackinit+259o
seg000:00CF		    jmp	    short entry_int72_stk
seg000:00CF ; ---------------------------------------------------------------------------
seg000:00D1 old72	    dd 0		    ; DATA XREF: stackinit+256o
seg000:00D5		    dw 424Bh
seg000:00D7 firstflag72	    db 0
seg000:00D8 ; ---------------------------------------------------------------------------
seg000:00D8		    jmp	    short intret_72
seg000:00D8 ; ---------------------------------------------------------------------------
seg000:00DA		    db 7 dup(0)
seg000:00E1 ; ---------------------------------------------------------------------------
seg000:00E1
seg000:00E1 entry_int72_stk:			    ; CODE XREF: seg000:int72j
seg000:00E1		    call    near ptr do_int_stacks
seg000:00E4		    rol	    word ptr [bx+si], 1
seg000:00E6
seg000:00E6 intret_72:				    ; CODE XREF: seg000:00D8j
seg000:00E6		    iret
seg000:00E7 ; ---------------------------------------------------------------------------
seg000:00E7
seg000:00E7 int73:				    ; DATA XREF: stackinit+299o
seg000:00E7		    jmp	    short entry_int73_stk
seg000:00E7 ; ---------------------------------------------------------------------------
seg000:00E9 old73	    dd 0		    ; DATA XREF: seg000:00FCo
seg000:00E9					    ; stackinit+296o
seg000:00ED		    dw 424Bh
seg000:00EF firstflag73	    db 0
seg000:00F0 ; ---------------------------------------------------------------------------
seg000:00F0		    jmp	    short intret_73
seg000:00F0 ; ---------------------------------------------------------------------------
seg000:00F2		    db 7 dup(0)
seg000:00F9 ; ---------------------------------------------------------------------------
seg000:00F9
seg000:00F9 entry_int73_stk:			    ; CODE XREF: seg000:int73j
seg000:00F9		    call    near ptr do_int_stacks
seg000:00F9 ; ---------------------------------------------------------------------------
seg000:00FC		    dw offset old73
seg000:00FE ; ---------------------------------------------------------------------------
seg000:00FE
seg000:00FE intret_73:				    ; CODE XREF: seg000:00F0j
seg000:00FE		    iret
seg000:00FF ; ---------------------------------------------------------------------------
seg000:00FF
seg000:00FF int74:				    ; DATA XREF: stackinit+2D9o
seg000:00FF		    jmp	    short entry_int74_stk
seg000:00FF ; ---------------------------------------------------------------------------
seg000:0101 old74	    dd 0		    ; DATA XREF: stackinit+2D6o
seg000:0105		    dw 424Bh
seg000:0107 firstflag74	    db 0
seg000:0108 ; ---------------------------------------------------------------------------
seg000:0108		    jmp	    short intret_74
seg000:0108 ; ---------------------------------------------------------------------------
seg000:010A		    db 7 dup(0)
seg000:0111 ; ---------------------------------------------------------------------------
seg000:0111
seg000:0111 entry_int74_stk:			    ; CODE XREF: seg000:int74j
seg000:0111		    call    near ptr do_int_stacks
seg000:0114		    add	    [bx+di], ax
seg000:0116
seg000:0116 intret_74:				    ; CODE XREF: seg000:0108j
seg000:0116		    iret
seg000:0117 ; ---------------------------------------------------------------------------
seg000:0117
seg000:0117 int76:				    ; DATA XREF: stackinit+319o
seg000:0117		    jmp	    short entry_int76_stk
seg000:0117 ; ---------------------------------------------------------------------------
seg000:0119 old76	    dd 0		    ; DATA XREF: stackinit+316o
seg000:011D		    dw 424Bh
seg000:011F firstflag76	    db 0
seg000:0120 ; ---------------------------------------------------------------------------
seg000:0120		    jmp	    short intret_76
seg000:0120 ; ---------------------------------------------------------------------------
seg000:0122		    db 7 dup(0)
seg000:0129 ; ---------------------------------------------------------------------------
seg000:0129
seg000:0129 entry_int76_stk:			    ; CODE XREF: seg000:int76j
seg000:0129		    call    near ptr do_int_stacks
seg000:012C		    sbb	    [bx+di], ax
seg000:012E
seg000:012E intret_76:				    ; CODE XREF: seg000:0120j
seg000:012E		    iret
seg000:012F ; ---------------------------------------------------------------------------
seg000:012F
seg000:012F int77:
seg000:012F		    jmp	    short entry_int77_stk
seg000:012F ; ---------------------------------------------------------------------------
seg000:0131 old77	    dd 0
seg000:0135		    dw 424Bh
seg000:0137 firstflag77	    db 0
seg000:0138 ; ---------------------------------------------------------------------------
seg000:0138		    jmp	    short intret_77
seg000:0138 ; ---------------------------------------------------------------------------
seg000:013A		    db 7 dup(0)
seg000:0141 ; ---------------------------------------------------------------------------
seg000:0141
seg000:0141 entry_int77_stk:			    ; CODE XREF: seg000:int77j
seg000:0141		    call    near ptr do_int_stacks
seg000:0144		    xor	    [bx+di], ax
seg000:0146
seg000:0146 intret_77:				    ; CODE XREF: seg000:0138j
seg000:0146		    iret
seg000:0147
seg000:0147 ; =============== S	U B R O	U T I N	E =======================================
seg000:0147
seg000:0147
seg000:0147 do_int_stacks   proc far		    ; CODE XREF: seg000:0033p
seg000:0147					    ; seg000:int08p ...
seg000:0147		    push    ax
seg000:0148		    push    bp
seg000:0149		    push    es
seg000:014A		    mov	    es,	word ptr cs:stacks+2
seg000:014F		    mov	    bp,	cs:nextentry
seg000:0154		    mov	    al,	1
seg000:0156		    xchg    al,	es:[bp+0]
seg000:015A		    cmp	    al,	0
seg000:015C		    jnz	    short notfree02
seg000:015E		    sub	    cs:nextentry, 8
seg000:0164
seg000:0164 found02:				    ; CODE XREF: do_int_stacks+71j
seg000:0164		    mov	    es:[bp+2], sp
seg000:0168		    mov	    word ptr es:[bp+4],	ss
seg000:016C		    mov	    ax,	bp
seg000:016E		    mov	    bp,	es:[bp+6]
seg000:0172		    cmp	    es:[bp+0], ax
seg000:0176		    jnz	    short foundbad02
seg000:0178		    push    bp
seg000:0179		    mov	    bp,	sp
seg000:017B		    mov	    ax,	[bp+8]
seg000:017E		    pop	    bp
seg000:017F		    push    es
seg000:0180		    pop	    ss
seg000:0181		    mov	    sp,	bp
seg000:0183		    mov	    bp,	ax
seg000:0185		    mov	    bp,	cs:[bp+0]
seg000:0189		    pushf
seg000:018A		    call    dword ptr cs:[bp+0]
seg000:018E		    mov	    bp,	sp
seg000:0190		    mov	    bp,	es:[bp+0]
seg000:0194		    mov	    ss,	word ptr es:[bp+4]
seg000:0198		    mov	    sp,	es:[bp+2]
seg000:019C		    mov	    byte ptr es:[bp+0],	0
seg000:01A1		    mov	    cs:nextentry, bp
seg000:01A6		    pop	    es
seg000:01A7		    pop	    bp
seg000:01A8		    pop	    ax
seg000:01A9		    add	    sp,	2
seg000:01AC		    iret
seg000:01AD ; ---------------------------------------------------------------------------
seg000:01AD
seg000:01AD notfree02:				    ; CODE XREF: do_int_stacks+15j
seg000:01AD		    cmp	    al,	1
seg000:01AF		    jz	    short findnext02
seg000:01B1		    xchg    al,	es:[bp+0]
seg000:01B5
seg000:01B5 findnext02:				    ; CODE XREF: do_int_stacks+68j
seg000:01B5					    ; do_int_stacks+78j ...
seg000:01B5		    call    longpath
seg000:01B8		    jmp	    short found02
seg000:01BA ; ---------------------------------------------------------------------------
seg000:01BA
seg000:01BA foundbad02:				    ; CODE XREF: do_int_stacks+2Fj
seg000:01BA		    cmp	    bp,	cs:firstentry
seg000:01BF		    jb	    short findnext02
seg000:01C1		    mov	    bp,	ax
seg000:01C3		    mov	    byte ptr es:[bp+0],	3
seg000:01C8		    jmp	    short findnext02
seg000:01C8 do_int_stacks   endp
seg000:01C8
seg000:01CA
seg000:01CA ; =============== S	U B R O	U T I N	E =======================================
seg000:01CA
seg000:01CA
seg000:01CA longpath	    proc near		    ; CODE XREF: do_int_stacks:findnext02p
seg000:01CA		    mov	    bp,	cs:lastentry
seg000:01CF
seg000:01CF lploopp:				    ; CODE XREF: longpath+28j
seg000:01CF		    cmp	    byte ptr es:[bp+0],	0
seg000:01D4		    jnz	    short inuse
seg000:01D6		    mov	    al,	1
seg000:01D8		    xchg    al,	es:[bp+0]
seg000:01DC		    cmp	    al,	0
seg000:01DE		    jz	    short found
seg000:01E0		    cmp	    al,	1
seg000:01E2		    jz	    short inuse
seg000:01E4		    mov	    es:[bp+0], al
seg000:01E8
seg000:01E8 inuse:				    ; CODE XREF: longpath+Aj
seg000:01E8					    ; longpath+18j
seg000:01E8		    cmp	    bp,	cs:firstentry
seg000:01ED		    jz	    short fatal
seg000:01EF		    sub	    bp,	8
seg000:01F2		    jmp	    short lploopp
seg000:01F4 ; ---------------------------------------------------------------------------
seg000:01F4
seg000:01F4 found:				    ; CODE XREF: longpath+14j
seg000:01F4		    retn
seg000:01F5 ; ---------------------------------------------------------------------------
seg000:01F5
seg000:01F5 fatal:				    ; CODE XREF: longpath+23j
seg000:01F5		    push    ds
seg000:01F6		    mov	    ax,	0F000h
seg000:01F9		    mov	    ds,	ax
seg000:01FB		    assume ds:nothing
seg000:01FB		    cmp	    byte ptr ds:0FFFEh,	0F9h
seg000:0200
seg000:0200 loc_200:
seg000:0200		    pop	    ds
seg000:0201		    assume ds:nothing
seg000:0201		    jnz	    short skip_nmis
seg000:0203		    mov	    al,	7
seg000:0205		    out	    72h, al	    ; CMOS Memory/RTC Index Register (Extended RAM)
seg000:0207
seg000:0207 skip_nmis:				    ; CODE XREF: longpath+37j
seg000:0207		    cli
seg000:0208		    mov	    al,	0FFh
seg000:020A		    out	    21h, al	    ; Interrupt	controller, 8259A.
seg000:020C		    out	    0A1h, al	    ; Interrupt	Controller #2, 8259A
seg000:020E		    mov	    si,	cs
seg000:0210		    mov	    ds,	si
seg000:0212		    mov	    si,	offset fatal_msg ; "\r\n\a\r\nInternal stack overflow\r\nSy"...
seg000:0215		    push    ax
seg000:0216		    push    ds
seg000:0217		    mov	    ax,	70h
seg000:021A		    mov	    ds,	ax
seg000:021C		    assume ds:nothing
seg000:021C		    test    byte ptr ds:8D0h, 1
seg000:0221		    pop	    ds
seg000:0222		    assume ds:nothing
seg000:0222		    pop	    ax
seg000:0223		    jz	    short fatal_loop
seg000:0225		    call    far	ptr 70h:8D1h
seg000:022A
seg000:022A fatal_loop:				    ; CODE XREF: longpath+59j
seg000:022A					    ; longpath+6Bj
seg000:022A		    lodsb
seg000:022B		    cmp	    al,	'$'
seg000:022D		    jz	    short fatal_done
seg000:022F		    mov	    bl,	7
seg000:0231		    mov	    ah,	0Eh
seg000:0233		    int	    10h		    ; -	VIDEO -	WRITE CHARACTER	AND ADVANCE CURSOR (TTY	WRITE)
seg000:0233					    ; AL = character, BH = display page	(alpha modes)
seg000:0233					    ; BL = foreground color (graphics modes)
seg000:0235		    jmp	    short fatal_loop
seg000:0237 ; ---------------------------------------------------------------------------
seg000:0237
seg000:0237 fatal_done:				    ; CODE XREF: longpath+63j
seg000:0237					    ; longpath:fatal_donej
seg000:0237		    jmp	    short fatal_done
seg000:0237 longpath	    endp
seg000:0237
seg000:0237 ; ---------------------------------------------------------------------------
seg000:0239 fatal_msg	    db 0Dh,0Ah		    ; DATA XREF: longpath+48o
seg000:0239		    db 7,0Dh,0Ah
seg000:0239		    db 'Internal stack overflow',0Dh,0Ah
seg000:0239		    db 'System halted',0Dh,0Ah,'$'
seg000:0267 ; ---------------------------------------------------------------------------
seg000:0267
seg000:0267 SYSINIT:				    ; DATA XREF: endfile+275o
seg000:0267		    jmp	    GOINIT
seg000:0267 ; ---------------------------------------------------------------------------
seg000:026A runhigh	    db 0		    ; DATA XREF: seg000:0749r
seg000:026A					    ; seg000:dolastr ...
seg000:026B DOSINFO	    dd 0		    ; DATA XREF: seg000:05C5w
seg000:026B					    ; seg000:NoRPLArenar ...
seg000:026F dosinit	    dw 0		    ; DATA XREF: seg000:0563w
seg000:026F					    ; seg000:05AAr ...
seg000:026F					    ; dos_temp_location
seg000:0271 CURRENT_DOS_LOCATION dw 0		    ; DATA XREF: seg000:0551r
seg000:0271					    ; seg000:055Bw ...
seg000:0273 DEVICE_LIST	    dd 0		    ; DATA XREF: seg000:0597r
seg000:0277 sysi_country    dd 0		    ; DATA XREF: seg000:05D5w
seg000:0277					    ; multi_pass:tryq_set_for_dosr ...
seg000:027B dos_segreinit   dd 0		    ; DATA XREF: seg000:05BDw
seg000:027B					    ; seg000:0758r ...
seg000:027F lo_doscod_size  dw 0		    ; DATA XREF: seg000:05B8w
seg000:027F					    ; seg000:0965r ...
seg000:0281 hi_doscod_size  dw 0		    ; DATA XREF: seg000:05B4w
seg000:0281					    ; MovDOSHi+Dr
seg000:0283 def_php	    dw 0		    ; DATA XREF: seg000:05AFw
seg000:0283					    ; seg000:06F9r
seg000:0285 _seg_reinit_ptr dw 32h		    ; DATA XREF: seg000:058Dr
seg000:0285					    ; MovBIOS+1Br
seg000:0287 temp_bcode_seg  dw 2C7h		    ; DATA XREF: seg000:0576w
seg000:0287					    ; MovBIOSr
seg000:0289 fake_floppy_drv db 0		    ; DATA XREF: seg000:04CBw
seg000:0289					    ; TempCDS+50r
seg000:028A stack_count	    dw 9		    ; DATA XREF: endfile:doinstallstackr
seg000:028A					    ; endfile+2AFr ...
seg000:028C stack_size	    dw 128		    ; DATA XREF: endfile+2AAr
seg000:028C					    ; stackinit+11r ...
seg000:028E stack_addr	    dd 0		    ; DATA XREF: endfile+246r
seg000:028E					    ; endfile+295w ...
seg000:0292 MEMORY_SIZE	    dw 1		    ; DATA XREF: seg000:04D6r
seg000:0292					    ; seg000:059Cr ...
seg000:0294 RPLMemTop	    dw 0		    ; DATA XREF: seg000:050Aw
seg000:0294					    ; seg000:05EBr ...
seg000:0296 DEFAULT_DRIVE   db 0		    ; DATA XREF: seg000:EXEC0_5C_FCBo
seg000:0296					    ; seg000:0667r ...
seg000:0297 buffers	    dw 0FFFFh		    ; DATA XREF: endfile+F2r
seg000:0297					    ; endfile+102w ...
seg000:0299 h_buffers	    dw 0		    ; DATA XREF: endfile:dodefaultbuffw
seg000:0299					    ; endfile+19Fr ...
seg000:029B singlebuffersize dw	0		    ; DATA XREF: seg000:0663w
seg000:029B					    ; seg000:06AAr ...
seg000:029D FILES	    db 8		    ; DATA XREF: endfile+21r
seg000:029D					    ; seg000:loc_F9Br ...
seg000:029E FCBS	    db 4		    ; DATA XREF: endfile+85r
seg000:029E					    ; multi_pass+737w
seg000:029F KEEP	    db 0		    ; DATA XREF: endfile+A0r
seg000:029F					    ; multi_pass+73Bw
seg000:02A0 NUM_CDS	    db 5		    ; DATA XREF: endfile+201r
seg000:02A0					    ; endfile+208r ...
seg000:02A1 top_of_cdss	    dw 0		    ; DATA XREF: seg000:06BAw
seg000:02A1					    ; TempCDS+17r ...
seg000:02A3 ALLOCLIM	    dw 0		    ; DATA XREF: TempCDS+1Dw
seg000:02A3					    ; endfile+18w ...
seg000:02A5 DirStrng	    db 'A', ':', '\', 0     ; DATA XREF: TempCDS:foosetr
seg000:02A5					    ; TempCDS+3Ew ...
seg000:02A9 command_line    db 2, 0		    ; DATA XREF: seg000:EXEC0_COM_LINEo
seg000:02A9					    ; seg000:081Ew ...
seg000:02AB		    db 'P'
seg000:02AC		    db 0
seg000:02AD		    db 124 dup(0)
seg000:0329 ZERO	    db 0		    ; DATA XREF: seg000:EXEC0_6C_FCBo
seg000:032A sepchr	    db 0		    ; DATA XREF: check_switch+3Fw
seg000:032A					    ; check_switch+48w	...
seg000:032B linecount	    dw 0		    ; DATA XREF: multi_pass+1Cw
seg000:032B					    ; multi_pass+2Dw ...
seg000:032D showcount	    db '     ',0Dh,0Ah,'$'  ; DATA XREF: showlinenum+7o
seg000:0335 buffer_linenum  dw 0		    ; DATA XREF: multi_pass+107w
seg000:0337 sys_model_byte  db 0FFh		    ; DATA XREF: seg000:0495w
seg000:0337					    ; seg000:04ABw ...
seg000:0338 sys_scnd_model_byte	db 0		    ; DATA XREF: seg000:049Dw
seg000:0338					    ; endfile+24Dr
seg000:0339 buf_prev_off    dw 0		    ; DATA XREF: set_buffer_infor
seg000:0339					    ; set_buffer_info+9w
seg000:033B COMEXE	    dw 0		    ; DATA XREF: seg000:0880o
seg000:033D EXEC0_COM_LINE  dw offset command_line
seg000:033F		    dw 46Dh		    ; SYSINIT segment
seg000:0341 EXEC0_5C_FCB    dw offset DEFAULT_DRIVE
seg000:0343		    dw 46Dh
seg000:0345 EXEC0_6C_FCB    dw offset ZERO	    ; default fcb at 6Ch
seg000:0347		    dw 46Dh
seg000:0349 multi_pass_id   db 0		    ; DATA XREF: seg000:0774w
seg000:0349					    ; seg000:0782w ...
seg000:034A install_flag    dw 0		    ; DATA XREF: seg000:0798r
seg000:034A					    ; seg000:07CEr ...
seg000:034C config_size	    dw 0		    ; DATA XREF: sum_up+Br
seg000:034C					    ; doconf+38w
seg000:034E sysinit_base_ptr dd	0		    ; DATA XREF: seg000:1044w
seg000:034E					    ; do_install_exec+60r ...
seg000:0352 sysinit_ptr	    dd 0		    ; DATA XREF: seg000:105Dw
seg000:0352					    ; seg000:sysinit_base_endr	...
seg000:0356 checksum	    dw 0		    ; DATA XREF: do_install_exec+53w
seg000:0356					    ; seg000:1179r
seg000:0358 ldexec_fcb	    db 14h dup(20h)	    ; DATA XREF: seg000:iexec_ldexec_5c_fcbo
seg000:0358					    ; seg000:iexec_ldexec_6c_fcbo
seg000:036C ldexec_line	    db 0		    ; DATA XREF: seg000:iexec_ldexec_lineo
seg000:036C					    ; do_install_exec:done_installparmw
seg000:036D ldexec_start    db 20h		    ; DATA XREF: do_install_exec+Aw
seg000:036D					    ; do_install_exec+31w
seg000:036E ldexec_parm	    db 80 dup(0)	    ; DATA XREF: do_install_exec+10o
seg000:03BE instexe	    dw 0		    ; DATA XREF: do_install_exec+40w
seg000:03BE					    ; do_install_exec+5Bo
seg000:03C0 iexec_ldexec_line dw offset	ldexec_line
seg000:03C2 iexec_ldexec_line_seg dw 46Dh	    ; DATA XREF: do_install_exec+44w
seg000:03C4 iexec_ldexec_5c_fcb	dw offset ldexec_fcb
seg000:03C6 iexec_ldexec_5c_fcb_seg dw 46Dh	    ; DATA XREF: do_install_exec+48w
seg000:03C8 iexec_ldexec_6c_fcb	dw offset ldexec_fcb
seg000:03CA iexec_ldexec_6c_fcb_seg dw 46Dh	    ; DATA XREF: do_install_exec+4Cw
seg000:03CC com_level	    db 0		    ; DATA XREF: organize+10w
seg000:03CC					    ; organize+29w ...
seg000:03CD cmmt	    db 0		    ; DATA XREF: organize+10Ew
seg000:03CD					    ; organize+12Bw ...
seg000:03CE cmmt1	    db 0		    ; DATA XREF: organize+10Aw
seg000:03CE					    ; skip_comment+15r
seg000:03CF cmmt2	    db 0		    ; DATA XREF: organize+127w
seg000:03CF					    ; skip_comment+28r
seg000:03D0 cmd_indicator   db 0		    ; DATA XREF: organize+79w
seg000:03D0					    ; organize:org3r ...
seg000:03D1 donotshownum    db 0		    ; DATA XREF: seg000:ConfigDonew
seg000:03D1					    ; badfil+22r
seg000:03D2 count	    dw 0		    ; DATA XREF: doconf+27w
seg000:03D2					    ; doconf+35r ...
seg000:03D4 org_count	    dw 0		    ; DATA XREF: multi_pass+Er
seg000:03D4					    ; get2+Ew
seg000:03D6 chrptr	    dw 0		    ; DATA XREF: multi_pass+18w
seg000:03D6					    ; multi_pass:multi_pass_adjustw ...
seg000:03D8 cntryfilehandle dw 0		    ; DATA XREF: multi_pass+501w
seg000:03D8					    ; multi_pass:coffj4r
seg000:03DA old_area	    dw 0		    ; DATA XREF: seg000:07D9r
seg000:03DA					    ; seg000:1076w
seg000:03DC impossible_owner_size dw 0		    ; DATA XREF: seg000:07DEr
seg000:03DC					    ; seg000:102Fw
seg000:03DE memlo	    dw 0		    ; DATA XREF: endfile+32r
seg000:03DE					    ; endfile+4Br ...
seg000:03E0 memhi	    dw 0		    ; DATA XREF: AllocFreeMem+Fw
seg000:03E0					    ; endfile+37r ...
seg000:03E2 ldoff	    dw 0
seg000:03E4 area	    dw 0		    ; DATA XREF: seg000:07C5r
seg000:03E4					    ; AllocFreeMem+Bw ...
seg000:03E6 packet	    db 24		    ; DATA XREF: calldev+15o
seg000:03E7		    db 0
seg000:03E8		    db 0
seg000:03E9		    dw 0
seg000:03EB		    db 8 dup(0)
seg000:03F3 unitcount	    db 0		    ; DATA XREF: multi_pass:isblockr
seg000:03F4 break_addr	    db 4 dup(0)		    ; DATA XREF: multi_pass+2B6w
seg000:03F4					    ; multi_pass+2D6r ...
seg000:03F8 bpb_addr	    db 4 dup(0)		    ; DATA XREF: multi_pass+22Ew
seg000:03F8					    ; multi_pass+3A6r ...
seg000:03FC devdrivenum	    db 0		    ; DATA XREF: seg000:06A1w
seg000:03FC					    ; multi_pass+3A1w
seg000:03FD configmsgflag   dw 0		    ; DATA XREF: multi_pass+311r
seg000:03FD					    ; multi_pass+31Cw
seg000:03FF toomanydrivesflag db 0		    ; DATA XREF: seg000:0729r
seg000:0400 BCodeSeg	    dw 2C7h		    ; DATA XREF: MovBIOS+17w
seg000:0402 BiosComBlock    dd 7008FDh		    ; DATA XREF: seg000:0592r
seg000:0406 tempstack	    db 128 dup(0)	    ; DATA XREF: SetInt12Mem+6r
seg000:0406					    ; SetInt12Mem+13w ...
seg000:0486 ; ---------------------------------------------------------------------------
seg000:0486
seg000:0486 GOINIT:				    ; CODE XREF: seg000:SYSINITj
seg000:0486		    mov	    ah,	0C0h
seg000:0488		    int	    15h		    ; SYSTEM - GET CONFIGURATION (XT after 1/10/86,AT mdl 3x9,CONV,XT286,PS)
seg000:048A		    jb	    short no_rom_config
seg000:048C		    cmp	    ah,	0
seg000:048F		    jnz	    short no_rom_config
seg000:0491		    mov	    al,	es:[bx+2]
seg000:0495		    mov	    cs:sys_model_byte, al
seg000:0499		    mov	    al,	es:[bx+3]
seg000:049D		    mov	    cs:sys_scnd_model_byte, al
seg000:04A1		    jmp	    short move_myself
seg000:04A3 ; ---------------------------------------------------------------------------
seg000:04A3
seg000:04A3 no_rom_config:			    ; CODE XREF: seg000:048Aj
seg000:04A3					    ; seg000:048Fj
seg000:04A3		    mov	    ax,	0F000h
seg000:04A6		    mov	    ds,	ax
seg000:04A8		    assume ds:nothing
seg000:04A8		    mov	    al,	ds:0FFFEh
seg000:04AB		    mov	    cs:sys_model_byte, al
seg000:04AF		    int	    11h		    ; check_for_fake_floppy
seg000:04AF					    ;
seg000:04AF					    ; EQUIPMENT	DETERMINATION
seg000:04AF					    ; Return: AX = equipment flag bits
seg000:04B1		    test    ax,	1
seg000:04B4		    jnz	    short move_myself
seg000:04B6		    push    es
seg000:04B7		    xor	    cl,	cl
seg000:04B9		    mov	    ah,	8
seg000:04BB		    mov	    dl,	0
seg000:04BD		    int	    13h		    ; DISK - DISK - GET	CURRENT	DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)
seg000:04BD					    ; DL = drive number
seg000:04BD					    ; Return: CF set on	error, AH = status code, BL = drive type
seg000:04BD					    ; DL = number of consecutive drives
seg000:04BD					    ; DH = maximum value for head number, ES:DI	-> drive parameter
seg000:04BF		    pop	    es
seg000:04C0		    jb	    short move_myself
seg000:04C2		    cmp	    cl,	0
seg000:04C5		    jz	    short move_myself
seg000:04C7		    or	    dl,	dl
seg000:04C9		    jnz	    short move_myself
seg000:04CB		    mov	    cs:fake_floppy_drv,	1
seg000:04D1
seg000:04D1 move_myself:			    ; CODE XREF: seg000:04A1j
seg000:04D1					    ; seg000:04B4j ...
seg000:04D1		    cld
seg000:04D2		    xor	    si,	si
seg000:04D4		    mov	    di,	si
seg000:04D6		    mov	    cx,	cs:MEMORY_SIZE
seg000:04DB		    push    cs
seg000:04DC		    pop	    ds
seg000:04DD		    assume ds:nothing
seg000:04DD		    dec	    cx
seg000:04DE		    xor	    bx,	bx
seg000:04E0		    mov	    es,	bx
seg000:04E2
seg000:04E2 loc_4E2:				    ; [es:(2Fh*4)] ; INT 2Fh address (0:0BCh)
seg000:04E2		    mov	    bx,	word ptr es:old0E+3
seg000:04E7		    mov	    es,	es:word_BD+1 ; [es:((2Fh*4)+2)]	; INT 2Fh segment (0:0BEh)
seg000:04EC		    assume es:nothing
seg000:04EC		    cmp	    word ptr es:[bx+3],	'PR' ; check for 'RPL'
seg000:04F2		    jnz	    short NoRPL
seg000:04F4		    cmp	    byte ptr es:[bx+5],	'L'
seg000:04F9		    jnz	    short NoRPL
seg000:04FB		    mov	    dx,	cx
seg000:04FD		    push    dx
seg000:04FE		    mov	    ax,	4A06h
seg000:0501		    int	    2Fh
seg000:0503		    pop	    ax
seg000:0504		    mov	    cx,	dx
seg000:0506		    cmp	    dx,	ax
seg000:0508		    jz	    short NoRPL
seg000:050A		    mov	    cs:RPLMemTop, dx
seg000:050F		    dec	    cx
seg000:0510
seg000:0510 NoRPL:				    ; CODE XREF: seg000:04F2j
seg000:0510					    ; seg000:04F9j ...
seg000:0510		    mov	    ax,	3D20h	    ; SI_end (SYSINIT code size)
seg000:0513		    call    _off_to_para
seg000:0516		    sub	    cx,	ax
seg000:0518		    sub	    cx,	0A00h	    ; (SYSINITSEG-DOSBIOCODESEG)*10h
seg000:051C		    mov	    ax,	1A60h
seg000:051F		    call    _off_to_para
seg000:0522		    sub	    cx,	ax
seg000:0524		    mov	    es,	cx
seg000:0526		    assume es:nothing
seg000:0526		    mov	    cx,	3D20h	    ; sysinit code size
seg000:0529		    shr	    cx,	1
seg000:052B		    rep	movsw
seg000:052D		    push    es
seg000:052E		    mov	    ax,	offset SYSIN
seg000:0531		    push    ax
seg000:0532		    retf
seg000:0533 ; ---------------------------------------------------------------------------
seg000:0533
seg000:0533 SYSIN:				    ; DATA XREF: seg000:052Eo
seg000:0533		    mov	    ax,	70h
seg000:0536		    mov	    ds,	ax
seg000:0538		    assume ds:nothing
seg000:0538		    mov	    word ptr ds:8FBh, cs ; [MoveDOSIntoHMA+2]
seg000:053C		    mov	    byte ptr ds:8FDh, 1	; [SysinitPresent]
seg000:0541		    mov	    ax,	3D20h	    ; SI_end
seg000:0544		    call    _off_to_para
seg000:0547		    mov	    cx,	cs
seg000:0549		    add	    ax,	cx
seg000:054B		    mov	    es,	ax
seg000:054D		    xor	    si,	si
seg000:054F		    mov	    di,	si
seg000:0551		    mov	    ds,	cs:CURRENT_DOS_LOCATION
seg000:0556		    assume ds:nothing
seg000:0556		    mov	    cx,	5000h
seg000:0559		    rep	movsw
seg000:055B		    mov	    cs:CURRENT_DOS_LOCATION, es
seg000:0560		    mov	    ax,	ds:stackcount+1	; mov ax, [3]
seg000:0563		    mov	    cs:dosinit,	ax
seg000:0567		    call    _off_to_para
seg000:056A		    sub	    cs:CURRENT_DOS_LOCATION, ax
seg000:056F		    mov	    ax,	es
seg000:0571		    add	    ax,	0A00h
seg000:0574		    mov	    es,	ax
seg000:0576		    assume es:nothing
seg000:0576		    xchg    ax,	cs:temp_bcode_seg
seg000:057B		    mov	    ds,	ax
seg000:057D		    mov	    si,	30h ; '0'
seg000:0580		    mov	    di,	si
seg000:0582		    mov	    cx,	1A60h
seg000:0585		    sub	    cx,	si
seg000:0587		    shr	    cx,	1
seg000:0589		    rep	movsw
seg000:058B		    mov	    ax,	es
seg000:058D		    call    dword ptr cs:_seg_reinit_ptr
seg000:0592		    les	    di,	cs:BiosComBlock
seg000:0597		    assume es:nothing
seg000:0597		    lds	    si,	cs:DEVICE_LIST
seg000:059C		    mov	    dx,	cs:MEMORY_SIZE
seg000:05A1		    cli
seg000:05A2		    mov	    ax,	cs
seg000:05A4		    mov	    ss,	ax
seg000:05A6
seg000:05A6 locstack:				    ; DATA XREF: seg000:locstacko
seg000:05A6		    mov	    sp,	offset locstack
seg000:05A9		    sti
seg000:05AA		    call    dword ptr cs:dosinit
seg000:05AF		    mov	    cs:def_php,	ds
seg000:05B4		    mov	    cs:hi_doscod_size, ax
seg000:05B8		    mov	    cs:lo_doscod_size, cx
seg000:05BD		    mov	    word ptr cs:dos_segreinit, dx
seg000:05C2		    mov	    ax,	es:[di]
seg000:05C5		    mov	    word ptr cs:DOSINFO, ax
seg000:05C9		    mov	    ax,	es:[di+2]
seg000:05CD		    mov	    word ptr cs:DOSINFO+2, ax
seg000:05D1		    mov	    ax,	es:[di+4]
seg000:05D5		    mov	    word ptr cs:sysi_country, ax
seg000:05D9		    mov	    ax,	es:[di+6]
seg000:05DD		    mov	    word ptr cs:sysi_country+2,	ax
seg000:05E1		    mov	    es,	cs:CURRENT_DOS_LOCATION
seg000:05E6		    mov	    word ptr cs:dos_segreinit+2, es
seg000:05EB		    cmp	    cs:RPLMemTop, 0
seg000:05F1		    jz	    short NoRPLArena
seg000:05F3		    mov	    bx,	0FFFFh
seg000:05F6		    mov	    ah,	48h
seg000:05F8		    int	    21h		    ; DOS - 2+ - ALLOCATE MEMORY
seg000:05F8					    ; BX = number of 16-byte paragraphs	desired
seg000:05FA		    mov	    ah,	48h
seg000:05FC		    int	    21h		    ; DOS - 2+ - ALLOCATE MEMORY
seg000:05FC					    ; BX = number of 16-byte paragraphs	desired
seg000:05FE		    mov	    es,	ax
seg000:0600		    push    es
seg000:0601		    sub	    ax,	cs:RPLMemTop
seg000:0606		    neg	    ax
seg000:0608		    dec	    ax
seg000:0609		    mov	    bx,	ax
seg000:060B		    mov	    ah,	4Ah
seg000:060D		    int	    21h		    ; DOS - 2+ - ADJUST	MEMORY BLOCK SIZE (SETBLOCK)
seg000:060D					    ; ES = segment address of block to change
seg000:060D					    ; BX = new size in paragraphs
seg000:060F		    mov	    bx,	0FFFFh
seg000:0612		    mov	    ah,	48h
seg000:0614		    int	    21h		    ; DOS - 2+ - ALLOCATE MEMORY
seg000:0614					    ; BX = number of 16-byte paragraphs	desired
seg000:0616		    mov	    ah,	48h
seg000:0618		    int	    21h		    ; DOS - 2+ - ALLOCATE MEMORY
seg000:0618					    ; BX = number of 16-byte paragraphs	desired
seg000:061A		    dec	    ax
seg000:061B		    mov	    es,	ax
seg000:061D		    mov	    es:SYSINIT$+1, 8
seg000:0624		    mov	    word ptr es:stacks,	'PR'
seg000:062B		    mov	    word ptr es:stacks+2, 'L'
seg000:0632		    mov	    es:firstentry, 0
seg000:0639		    mov	    es:lastentry, 0
seg000:0640		    pop	    es
seg000:0641		    mov	    ah,	49h
seg000:0643		    int	    21h		    ; DOS - 2+ - FREE MEMORY
seg000:0643					    ; ES = segment address of area to be freed
seg000:0645
seg000:0645 NoRPLArena:				    ; CODE XREF: seg000:05F1j
seg000:0645		    les	    di,	cs:DOSINFO
seg000:064A		    clc
seg000:064B		    mov	    ah,	88h
seg000:064D		    int	    15h		    ; Get Extended Memory Size
seg000:064D					    ; Return: CF clear on success
seg000:064D					    ; AX = size	of memory above	1M in K
seg000:064F		    jb	    short no_ext_memory
seg000:0651		    mov	    es:[di+45h], ax
seg000:0655		    or	    ax,	ax
seg000:0657		    jz	    short no_ext_memory
seg000:0659		    call    ClrVDISKHeader
seg000:065C
seg000:065C no_ext_memory:			    ; CODE XREF: seg000:064Fj
seg000:065C					    ; seg000:0657j
seg000:065C		    mov	    ax,	es:[di+10h]
seg000:0660		    add	    ax,	20	    ; bufinsiz
seg000:0663		    mov	    cs:singlebuffersize, ax
seg000:0667		    mov	    al,	cs:DEFAULT_DRIVE
seg000:066B		    mov	    es:[di+43h], al
seg000:066F
seg000:066F get_cpu_type:
seg000:066F		    pushf
seg000:0670		    push    bx
seg000:0671		    xor	    bx,	bx
seg000:0673		    xor	    ax,	ax
seg000:0675		    push    ax
seg000:0676		    popf
seg000:0677		    pushf
seg000:0678		    pop	    ax
seg000:0679		    and	    ax,	0F000h
seg000:067C		    cmp	    ax,	0F000h
seg000:067F		    jz	    short cpu_8086
seg000:0681		    mov	    ax,	0F000h
seg000:0684		    push    ax
seg000:0685		    popf
seg000:0686		    pushf
seg000:0687		    pop	    ax
seg000:0688		    and	    ax,	0F000h
seg000:068B		    jz	    short cpu_286
seg000:068D
seg000:068D cpu_386:
seg000:068D		    inc	    bx
seg000:068E
seg000:068E cpu_286:				    ; CODE XREF: seg000:068Bj
seg000:068E		    inc	    bx
seg000:068F
seg000:068F cpu_8086:				    ; CODE XREF: seg000:067Fj
seg000:068F		    mov	    ax,	bx
seg000:0691		    pop	    bx
seg000:0692		    popf
seg000:0693		    cmp	    ax,	2
seg000:0696		    jnz	    short not_386_system
seg000:0698		    mov	    byte ptr es:[di+44h], 1
seg000:069D
seg000:069D not_386_system:			    ; CODE XREF: seg000:0696j
seg000:069D		    mov	    al,	es:[di+20h]
seg000:06A1		    mov	    cs:devdrivenum, al
seg000:06A5		    mov	    ax,	cs
seg000:06A7		    sub	    ax,	11h
seg000:06AA		    mov	    cx,	cs:singlebuffersize
seg000:06AF		    shr	    cx,	1
seg000:06B1		    shr	    cx,	1
seg000:06B3		    shr	    cx,	1
seg000:06B5		    shr	    cx,	1
seg000:06B7		    inc	    cx
seg000:06B8		    sub	    ax,	cx
seg000:06BA		    mov	    cs:top_of_cdss, ax
seg000:06BE		    push    es
seg000:06BF		    push    di
seg000:06C0		    les	    di,	es:[di+12h]
seg000:06C4		    mov	    word ptr es:[di+4],	0
seg000:06CA		    mov	    word ptr es:[di], 0
seg000:06CF		    mov	    es:[di+2], ax
seg000:06D3		    mov	    es,	ax
seg000:06D5		    xor	    ax,	ax
seg000:06D7		    mov	    di,	ax
seg000:06D9		    mov	    es:[di], ax
seg000:06DC		    mov	    es:[di+2], ax
seg000:06E0		    mov	    word ptr es:[di+4],	0FFh
seg000:06E6		    mov	    word ptr es:[di+6],	0
seg000:06EC		    mov	    word ptr es:[di+8],	0
seg000:06F2		    pop	    di
seg000:06F3		    pop	    es
seg000:06F4		    push    cs
seg000:06F5		    pop	    ds
seg000:06F6		    call    TempCDS
seg000:06F9		    mov	    ds,	cs:def_php
seg000:06FE		    call    far	ptr 70h:89Bh
seg000:0703		    sti
seg000:0704		    cld
seg000:0705		    mov	    bx,	cs
seg000:0707		    sub	    bx,	10h
seg000:070A		    mov	    es,	bx
seg000:070C		    assume es:nothing
seg000:070C		    xor	    si,	si	    ; DATA XREF: SaveFreeHMAPtr:loc_BE5w
seg000:070E
seg000:070E loc_70E:				    ; DATA XREF: AllocHMA+10w
seg000:070E					    ; AllocHMA+1Dr ...
seg000:070E		    mov	    di,	si
seg000:0710
seg000:0710 loc_710:				    ; DATA XREF: AllocHMA+14w
seg000:0710		    mov	    cx,	128
seg000:0713		    rep	movsw
seg000:0715		    mov	    word ptr es:36h, es
seg000:071A		    mov	    ah,	50h
seg000:071C		    int	    21h		    ; DOS - 2+ internal	- SET PSP SEGMENT
seg000:071C					    ; BX = segment address of new PSP
seg000:071E		    push    ds
seg000:071F		    push    cs
seg000:0720		    pop	    ds
seg000:0721		    mov	    dx,	offset int24
seg000:0724		    mov	    ax,	2524h
seg000:0727		    int	    21h		    ; DOS - SET	INTERRUPT VECTOR
seg000:0727					    ; AL = interrupt number
seg000:0727					    ; DS:DX = new vector to be used for	specified interrupt
seg000:0729		    cmp	    ds:toomanydrivesflag, 0
seg000:072E		    jz	    short no_err
seg000:0730		    mov	    dx,	offset TooManyDrivesMsg	; "WARNING! Logical drives past	Z: exist a"...
seg000:0733		    call    print
seg000:0736
seg000:0736 no_err:				    ; CODE XREF: seg000:072Ej
seg000:0736		    pop	    ds
seg000:0737		    mov	    dl,	cs:DEFAULT_DRIVE
seg000:073C		    or	    dl,	dl
seg000:073E		    jz	    short nodrvset
seg000:0740		    dec	    dl
seg000:0742		    mov	    ah,	0Eh
seg000:0744		    int	    21h		    ; DOS - SELECT DISK
seg000:0744					    ; DL = new default drive number (0 = A, 1 =	B, etc.)
seg000:0744					    ; Return: AL = number of logical drives
seg000:0746
seg000:0746 nodrvset:				    ; CODE XREF: seg000:073Ej
seg000:0746		    call    doconf
seg000:0749		    cmp	    cs:runhigh,	0
seg000:074F		    jz	    short dont_install_stub
seg000:0751		    mov	    es,	cs:CURRENT_DOS_LOCATION
seg000:0756		    assume es:nothing
seg000:0756		    xor	    ax,	ax
seg000:0758		    call    cs:dos_segreinit
seg000:075D		    jmp	    short do_multi_pass
seg000:075F ; ---------------------------------------------------------------------------
seg000:075F
seg000:075F dont_install_stub:			    ; CODE XREF: seg000:074Fj
seg000:075F		    xor	    bx,	bx
seg000:0761		    call    MovDOSLo
seg000:0764 ; ---------------------------------------------------------------------------
seg000:0764		    mov	    ax,	(offset	SYSINIT$+1)
seg000:0767		    mov	    es,	cs:CURRENT_DOS_LOCATION
seg000:076C		    call    cs:dos_segreinit
seg000:0771
seg000:0771 do_multi_pass:			    ; CODE XREF: seg000:075Dj
seg000:0771		    call    AllocFreeMem
seg000:0774		    inc	    cs:multi_pass_id
seg000:0779		    call    multi_pass
seg000:077C		    call    ShrinkUMB
seg000:077F		    call    UnlinkUMB
seg000:0782		    inc	    cs:multi_pass_id
seg000:0787		    call    multi_pass
seg000:078A		    call    endfile
seg000:078D		    mov	    ax,	70h
seg000:0790		    mov	    es,	ax
seg000:0792		    assume es:nothing
seg000:0792		    mov	    byte ptr es:8FDh, 0	; [es:SysinitPresent]
seg000:0798		    test    cs:install_flag, 1
seg000:079F		    jz	    short dolast
seg000:07A1		    inc	    cs:multi_pass_id
seg000:07A6		    call    multi_pass
seg000:07A9
seg000:07A9 dolast:				    ; CODE XREF: seg000:079Fj
seg000:07A9		    cmp	    cs:runhigh,	0FFh
seg000:07AF		    jnz	    short _@@
seg000:07B1		    call    LoadDOSHiOrLo
seg000:07B4
seg000:07B4 _@@:				    ; CODE XREF: seg000:07AFj
seg000:07B4		    cmp	    cs:runhigh,	0
seg000:07BA		    jz	    short ConfigDone ; _@@@
seg000:07BC		    call    CPMHack
seg000:07BF
seg000:07BF ConfigDone:				    ; CODE XREF: seg000:07BAj
seg000:07BF		    mov	    cs:donotshownum, 1
seg000:07C5		    mov	    es,	cs:area
seg000:07CA		    assume es:nothing
seg000:07CA		    mov	    ah,	49h
seg000:07CC		    int	    21h		    ; DOS - 2+ - FREE MEMORY
seg000:07CC					    ; ES = segment address of area to be freed
seg000:07CE		    test    cs:install_flag, 2
seg000:07D5		    jz	    short skip_free_sysinitbase
seg000:07D7		    push    es
seg000:07D8		    push    bx
seg000:07D9		    mov	    es,	cs:old_area
seg000:07DE		    mov	    bx,	cs:impossible_owner_size
seg000:07E3		    mov	    ah,	4Ah
seg000:07E5		    int	    21h		    ; DOS - 2+ - ADJUST	MEMORY BLOCK SIZE (SETBLOCK)
seg000:07E5					    ; ES = segment address of block to change
seg000:07E5					    ; BX = new size in paragraphs
seg000:07E7		    mov	    ax,	es
seg000:07E9		    dec	    ax
seg000:07EA		    mov	    es,	ax
seg000:07EC		    mov	    es:SYSINIT$+1, 8
seg000:07F3		    mov	    word ptr es:stacks,	'DS'
seg000:07FA		    pop	    bx
seg000:07FB		    pop	    es
seg000:07FC
seg000:07FC skip_free_sysinitbase:		    ; CODE XREF: seg000:07D5j
seg000:07FC		    cmp	    cs:runhigh,	0
seg000:0802		    jz	    short _@@@@
seg000:0804		    call    InstVDiskHeader
seg000:0807
seg000:0807 _@@@@:				    ; CODE XREF: seg000:0802j
seg000:0807		    push    cs
seg000:0808		    pop	    ds
seg000:0809		    mov	    si,	(offset	command_line+1)
seg000:080C		    push    ds
seg000:080D		    pop	    es
seg000:080E		    mov	    di,	si
seg000:0810		    mov	    cl,	0FFh
seg000:0812
seg000:0812 _@_loop:				    ; CODE XREF: seg000:0818j
seg000:0812		    inc	    cl
seg000:0814		    lodsb
seg000:0815		    stosb
seg000:0816		    or	    al,	al
seg000:0818		    jnz	    short _@_loop
seg000:081A		    dec	    di
seg000:081B		    mov	    al,	0Dh
seg000:081D		    stosb
seg000:081E		    mov	    ds:command_line, cl
seg000:0822
seg000:0822 retry:				    ; "\\COMMAND.COM"
seg000:0822		    mov	    dx,	offset commnd
seg000:0825		    push    dx
seg000:0826		    mov	    bx,	0FFFFh
seg000:0829		    mov	    ah,	48h
seg000:082B		    int	    21h		    ; DOS - 2+ - ALLOCATE MEMORY
seg000:082B					    ; BX = number of 16-byte paragraphs	desired
seg000:082D		    mov	    ah,	48h
seg000:082F		    int	    21h		    ; DOS - 2+ - ALLOCATE MEMORY
seg000:082F					    ; BX = number of 16-byte paragraphs	desired
seg000:0831		    jb	    short memerrjx
seg000:0833		    mov	    es,	ax
seg000:0835		    assume es:nothing
seg000:0835		    mov	    ah,	49h
seg000:0837		    int	    21h		    ; DOS - 2+ - FREE MEMORY
seg000:0837					    ; ES = segment address of area to be freed
seg000:0839		    mov	    bp,	bx
seg000:083B		    mov	    bx,	ds:MEMORY_SIZE
seg000:083F		    mov	    ax,	cs
seg000:0841		    sub	    bx,	ax
seg000:0843		    add	    bx,	11h
seg000:0846		    sub	    bp,	bx
seg000:0848		    jb	    short memerrjx
seg000:084A		    mov	    ax,	3D00h
seg000:084D		    stc
seg000:084E		    int	    21h		    ; DOS - 2+ - OPEN DISK FILE	WITH HANDLE
seg000:084E					    ; DS:DX -> ASCIZ filename
seg000:084E					    ; AL = access mode
seg000:084E					    ; 0	- read
seg000:0850		    jb	    short comerr
seg000:0852		    mov	    bx,	ax
seg000:0854		    xor	    cx,	cx
seg000:0856		    xor	    dx,	dx
seg000:0858		    mov	    ax,	4202h
seg000:085B		    stc
seg000:085C		    int	    21h		    ; DOS - 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
seg000:085C					    ; AL = method: offset from end of file
seg000:085E		    jb	    short comerr
seg000:0860		    add	    ax,	15
seg000:0863		    adc	    dx,	0
seg000:0866		    call    _off_to_para
seg000:0869		    mov	    cl,	12
seg000:086B		    shl	    dx,	cl
seg000:086D		    or	    ax,	dx
seg000:086F		    add	    ax,	10h
seg000:0872		    cmp	    ax,	bp
seg000:0874		    jb	    short okld
seg000:0876
seg000:0876 memerrjx:				    ; CODE XREF: seg000:0831j
seg000:0876					    ; seg000:0848j
seg000:0876		    jmp	    memerr
seg000:0879 ; ---------------------------------------------------------------------------
seg000:0879
seg000:0879 okld:				    ; CODE XREF: seg000:0874j
seg000:0879		    mov	    ah,	3Eh
seg000:087B		    int	    21h		    ; DOS - 2+ - CLOSE A FILE WITH HANDLE
seg000:087B					    ; BX = file	handle
seg000:087D		    pop	    dx
seg000:087E		    push    cs
seg000:087F		    pop	    es
seg000:0880		    assume es:nothing
seg000:0880		    mov	    bx,	offset COMEXE
seg000:0883		    mov	    word ptr [bx+4], cs
seg000:0886		    mov	    word ptr [bx+8], cs
seg000:0889		    mov	    word ptr [bx+12], cs
seg000:088C		    xor	    ax,	ax
seg000:088E		    mov	    ah,	4Bh
seg000:0890		    stc
seg000:0891		    int	    21h		    ; DOS - 2+ - LOAD OR EXECUTE (EXEC)
seg000:0891					    ; DS:DX -> ASCIZ filename
seg000:0891					    ; ES:BX -> parameter block
seg000:0891					    ; AL = subfunc: load & execute program
seg000:0893
seg000:0893 comerr:				    ; CODE XREF: seg000:0850j
seg000:0893					    ; seg000:085Ej
seg000:0893		    mov	    dx,	offset badcom ;	"Command Interpreter"
seg000:0896		    call    badfil
seg000:0899 ; START OF FUNCTION	CHUNK FOR multi_pass
seg000:0899
seg000:0899 stall:				    ; CODE XREF: multi_pass:stallj
seg000:0899					    ; multi_pass+12EBj
seg000:0899		    jmp	    short stall
seg000:0899 ; END OF FUNCTION CHUNK FOR	multi_pass
seg000:089B
seg000:089B ; =============== S	U B R O	U T I N	E =======================================
seg000:089B
seg000:089B
seg000:089B AllocFreeMem    proc near		    ; CODE XREF: seg000:do_multi_passp
seg000:089B		    mov	    bx,	0FFFFh
seg000:089E		    mov	    ah,	48h
seg000:08A0		    int	    21h		    ; DOS - 2+ - ALLOCATE MEMORY
seg000:08A0					    ; BX = number of 16-byte paragraphs	desired
seg000:08A2		    mov	    ah,	48h
seg000:08A4		    int	    21h		    ; DOS - 2+ - ALLOCATE MEMORY
seg000:08A4					    ; BX = number of 16-byte paragraphs	desired
seg000:08A6		    mov	    cs:area, ax
seg000:08AA		    mov	    cs:memhi, ax
seg000:08AE		    retn
seg000:08AE AllocFreeMem    endp
seg000:08AE
seg000:08AE ; ---------------------------------------------------------------------------
seg000:08AF DOSLOMSG	    db 'HMA not available : Loading DOS low',0Dh,0Ah,'$'
seg000:08AF					    ; DATA XREF: LoadDOSHiOrLo+Ao
seg000:08D5 FEmsg	    db 'Fatal Error:Cannot allocate Memory for DOS',0Dh,0Ah,'$'
seg000:08D5					    ; DATA XREF: AllocMemForDOS+70o
seg000:0902
seg000:0902 ; =============== S	U B R O	U T I N	E =======================================
seg000:0902
seg000:0902
seg000:0902 LoadDOSHiOrLo   proc near		    ; CODE XREF: seg000:07B1p
seg000:0902		    call    TryToMovDOSHi
seg000:0905		    jb	    short LdngLo
seg000:0907		    retn
seg000:0908 ; ---------------------------------------------------------------------------
seg000:0908
seg000:0908 LdngLo:				    ; CODE XREF: LoadDOSHiOrLo+3j
seg000:0908		    push    cs
seg000:0909		    pop	    ds
seg000:090A		    mov	    ah,	9
seg000:090C		    mov	    dx,	offset DOSLOMSG	; "HMA not available : Loading DOS low\r\n"...
seg000:090F		    int	    21h		    ; DOS - PRINT STRING
seg000:090F					    ; DS:DX -> string terminated by "$"
seg000:0911		    mov	    bx,	1
seg000:0914		    call    MovDOSLo
seg000:0917 ; ---------------------------------------------------------------------------
seg000:0917		    mov	    es,	cs:CURRENT_DOS_LOCATION
seg000:091C		    xor	    ax,	ax
seg000:091E		    call    cs:dos_segreinit
seg000:0923		    mov	    cs:runhigh,	0
seg000:0929		    retn
seg000:0929 LoadDOSHiOrLo   endp
seg000:0929
seg000:092A
seg000:092A ; =============== S	U B R O	U T I N	E =======================================
seg000:092A
seg000:092A
seg000:092A TryToMovDOSHi   proc near		    ; CODE XREF: LoadDOSHiOrLop
seg000:092A					    ; seg000:0A94p ...
seg000:092A		    call    MovDOSHi
seg000:092D		    jb	    short ttldhx
seg000:092F		    mov	    es,	cs:CURRENT_DOS_LOCATION
seg000:0934		    xor	    ax,	ax
seg000:0936		    call    cs:dos_segreinit
seg000:093B		    mov	    cs:runhigh,	1
seg000:0941		    clc
seg000:0942
seg000:0942 ttldhx:				    ; CODE XREF: TryToMovDOSHi+3j
seg000:0942		    retn
seg000:0942 TryToMovDOSHi   endp
seg000:0942
seg000:0943
seg000:0943 ; =============== S	U B R O	U T I N	E =======================================
seg000:0943
seg000:0943
seg000:0943 MovDOSHi	    proc near		    ; CODE XREF: TryToMovDOSHip
seg000:0943		    call    AllocHMA
seg000:0946		    jb	    short mdhx
seg000:0948		    mov	    ax,	0FFFFh
seg000:094B		    mov	    es,	ax
seg000:094D		    assume es:nothing
seg000:094D		    call    MovBIOS
seg000:0950		    mov	    cx,	cs:hi_doscod_size
seg000:0955		    call    MovDOS
seg000:0958		    call    SaveFreeHMAPtr
seg000:095B		    clc
seg000:095C
seg000:095C mdhx:				    ; CODE XREF: MovDOSHi+3j
seg000:095C		    retn
seg000:095C MovDOSHi	    endp
seg000:095C
seg000:095D
seg000:095D ; =============== S	U B R O	U T I N	E =======================================
seg000:095D
seg000:095D ; Attributes: noreturn
seg000:095D
seg000:095D MovDOSLo	    proc near		    ; CODE XREF: seg000:0761p
seg000:095D					    ; LoadDOSHiOrLo+12p
seg000:095D		    call    AllocMemForDOS
seg000:095D MovDOSLo	    endp
seg000:095D
seg000:0960 ; ---------------------------------------------------------------------------
seg000:0960		    mov	    es,	ax
seg000:0962		    assume es:nothing
seg000:0962		    call    MovBIOS
seg000:0965		    mov	    cx,	cs:lo_doscod_size
seg000:096A		    call    MovDOS
seg000:096D		    retn
seg000:096E
seg000:096E ; =============== S	U B R O	U T I N	E =======================================
seg000:096E
seg000:096E
seg000:096E MovBIOS	    proc near		    ; CODE XREF: MovDOSHi+Ap
seg000:096E					    ; seg000:0962p
seg000:096E		    mov	    ds,	cs:temp_bcode_seg
seg000:0973		    mov	    si,	30h
seg000:0976		    mov	    di,	si
seg000:0978		    mov	    cx,	1A60h
seg000:097B		    sub	    cx,	si
seg000:097D		    shr	    cx,	1
seg000:097F		    rep	movsw
seg000:0981		    push    es
seg000:0982		    push    di
seg000:0983		    mov	    ax,	es
seg000:0985		    mov	    cs:BCodeSeg, ax
seg000:0989		    call    dword ptr cs:_seg_reinit_ptr
seg000:098E		    pop	    di
seg000:098F		    pop	    es
seg000:0990		    retn
seg000:0990 MovBIOS	    endp
seg000:0990
seg000:0991
seg000:0991 ; =============== S	U B R O	U T I N	E =======================================
seg000:0991
seg000:0991
seg000:0991 MovDOS	    proc near		    ; CODE XREF: MovDOSHi+12p
seg000:0991					    ; seg000:096Ap
seg000:0991		    push    es
seg000:0992		    push    di
seg000:0993		    lds	    si,	dword ptr cs:dosinit
seg000:0998		    rep	movsb
seg000:099A		    pop	    bx
seg000:099B		    mov	    ax,	cs:dosinit
seg000:099F		    sub	    ax,	bx
seg000:09A1		    call    _off_to_para
seg000:09A4		    pop	    bx
seg000:09A5		    sub	    bx,	ax
seg000:09A7		    mov	    cs:CURRENT_DOS_LOCATION, bx
seg000:09AC		    retn
seg000:09AC MovDOS	    endp
seg000:09AC
seg000:09AD
seg000:09AD ; =============== S	U B R O	U T I N	E =======================================
seg000:09AD
seg000:09AD ; Attributes: noreturn
seg000:09AD
seg000:09AD AllocMemForDOS  proc near		    ; CODE XREF: MovDOSLop
seg000:09AD		    mov	    ax,	1A60h
seg000:09B0		    sub	    ax,	30h
seg000:09B3		    add	    ax,	cs:lo_doscod_size
seg000:09B8		    add	    ax,	15
seg000:09BB		    call    _off_to_para
seg000:09BE		    or	    bx,	bx
seg000:09C0		    mov	    bx,	ax
seg000:09C2		    jz	    short update_arena
seg000:09C4		    mov	    ah,	48h
seg000:09C6		    int	    21h		    ; DOS - 2+ - ALLOCATE MEMORY
seg000:09C6					    ; BX = number of 16-byte paragraphs	desired
seg000:09C8		    jb	    short FatalErr
seg000:09CA		    sub	    ax,	3
seg000:09CD		    mov	    es,	ax
seg000:09CF		    mov	    word ptr es:loc_1D+4, 8 ; [es:20h+ARENA.OWNER]
seg000:09D6		    mov	    word ptr es:loc_28,	'CS' ; [es:20h+ARENA.NAME]
seg000:09DD		    retn
seg000:09DE ; ---------------------------------------------------------------------------
seg000:09DE
seg000:09DE update_arena:			    ; CODE XREF: AllocMemForDOS+15j
seg000:09DE		    push    ds
seg000:09DF		    push    di
seg000:09E0		    push    cx
seg000:09E1		    push    dx
seg000:09E2		    lds	    di,	cs:DOSINFO
seg000:09E7		    dec	    di
seg000:09E8		    dec	    di
seg000:09E9		    mov	    es,	word ptr [di]
seg000:09EB		    mov	    cx,	es:stackcount+1
seg000:09F0		    cmp	    cx,	bx
seg000:09F2		    jb	    short FatalErr
seg000:09F4		    mov	    dl,	byte ptr es:SYSINIT$
seg000:09F9		    mov	    ax,	es
seg000:09FB		    add	    ax,	bx
seg000:09FD		    mov	    [di], ax
seg000:09FF		    mov	    ds,	ax
seg000:0A01		    mov	    byte ptr ds:SYSINIT$, dl
seg000:0A05		    mov	    ds:SYSINIT$+1, 0
seg000:0A0B		    sub	    cx,	bx
seg000:0A0D		    mov	    ds:stackcount+1, cx
seg000:0A11		    mov	    ax,	es
seg000:0A13		    sub	    ax,	3
seg000:0A16		    pop	    dx
seg000:0A17		    pop	    cx
seg000:0A18		    pop	    di
seg000:0A19		    pop	    ds
seg000:0A1A		    retn
seg000:0A1B ; ---------------------------------------------------------------------------
seg000:0A1B
seg000:0A1B FatalErr:				    ; CODE XREF: AllocMemForDOS+1Bj
seg000:0A1B					    ; AllocMemForDOS+45j
seg000:0A1B		    push    cs
seg000:0A1C		    pop	    ds
seg000:0A1D		    mov	    dx,	offset FEmsg ; "Fatal Error:Cannot allocate Memory for "...
seg000:0A20		    mov	    ah,	9
seg000:0A22		    int	    21h		    ; DOS - PRINT STRING
seg000:0A22					    ; DS:DX -> string terminated by "$"
seg000:0A24		    cli
seg000:0A25		    hlt
seg000:0A25 AllocMemForDOS  endp ; sp-analysis failed
seg000:0A25
seg000:0A26
seg000:0A26 ; =============== S	U B R O	U T I N	E =======================================
seg000:0A26
seg000:0A26
seg000:0A26 AllocHMA	    proc near		    ; CODE XREF: MovDOSHip
seg000:0A26		    push    ds
seg000:0A27		    mov	    ax,	70h
seg000:0A2A		    mov	    ds,	ax
seg000:0A2C		    assume ds:nothing
seg000:0A2C		    call    IsXMSLoaded
seg000:0A2F		    jnz	    short grabhma_error
seg000:0A31		    mov	    ax,	4310h
seg000:0A34		    int	    2Fh		    ; -	Multiplex - XMS	- GET DRIVER ADDRESS
seg000:0A34					    ; Return: ES:BX -> driver entry point
seg000:0A36		    mov	    ds:0Eh, bx
seg000:0A3A		    mov	    word ptr ds:10h, es
seg000:0A3E		    mov	    ah,	1
seg000:0A40		    mov	    dx,	0FFFFh
seg000:0A43		    call    dword ptr ds:0Eh
seg000:0A47		    dec	    ax
seg000:0A48		    jz	    short allocHMA_1
seg000:0A4A		    mov	    ah,	88h
seg000:0A4C		    int	    15h		    ; Get Extended Memory Size
seg000:0A4C					    ; Return: CF clear on success
seg000:0A4C					    ; AX = size	of memory above	1M in K
seg000:0A4E		    cmp	    ax,	64
seg000:0A51		    jb	    short grabhma_error
seg000:0A53
seg000:0A53 allocHMA_1:				    ; CODE XREF: AllocHMA+22j
seg000:0A53		    mov	    ah,	5
seg000:0A55		    call    dword ptr ds:0Eh
seg000:0A59		    dec	    ax
seg000:0A5A		    jnz	    short grabhma_error
seg000:0A5C		    call    IsVDiskInstalled
seg000:0A5F		    jz	    short grabhma_error
seg000:0A61		    mov	    ax,	0FFFFh
seg000:0A64		    mov	    es,	ax
seg000:0A66		    assume es:nothing
seg000:0A66		    mov	    word ptr es:10h, 1234h
seg000:0A6D		    cmp	    word ptr es:10h, 1234h
seg000:0A74		    jnz	    short grabhma_error
seg000:0A76		    clc
seg000:0A77		    pop	    ds
seg000:0A78		    assume ds:nothing
seg000:0A78		    retn
seg000:0A79 ; ---------------------------------------------------------------------------
seg000:0A79
seg000:0A79 grabhma_error:			    ; CODE XREF: AllocHMA+9j
seg000:0A79					    ; AllocHMA+2Bj ...
seg000:0A79		    stc
seg000:0A7A		    pop	    ds
seg000:0A7B		    retn
seg000:0A7B AllocHMA	    endp
seg000:0A7B
seg000:0A7C
seg000:0A7C ; =============== S	U B R O	U T I N	E =======================================
seg000:0A7C
seg000:0A7C
seg000:0A7C IsXMSLoaded	    proc near		    ; CODE XREF: AllocHMA+6p
seg000:0A7C					    ; InitAllocUMBp
seg000:0A7C		    mov	    ax,	4300h
seg000:0A7F		    int	    2Fh		    ; -	Multiplex - XMS	- INSTALLATION CHECK
seg000:0A7F					    ; Return: AL = 80h XMS driver installed
seg000:0A7F					    ; AL <> 80h	no driver
seg000:0A81		    cmp	    al,	80h
seg000:0A83		    retn
seg000:0A83 IsXMSLoaded	    endp
seg000:0A83
seg000:0A84 ; ---------------------------------------------------------------------------
seg000:0A84
seg000:0A84 FTryToMovDOSHi:
seg000:0A84		    push    ax
seg000:0A85		    push    bx
seg000:0A86		    push    cx
seg000:0A87		    push    dx
seg000:0A88		    push    si
seg000:0A89		    push    di
seg000:0A8A		    push    ds
seg000:0A8B		    push    es
seg000:0A8C		    cmp	    cs:runhigh,	0FFh
seg000:0A92		    jnz	    short _ftymdh_1
seg000:0A94		    call    TryToMovDOSHi
seg000:0A97
seg000:0A97 _ftymdh_1:				    ; CODE XREF: seg000:0A92j
seg000:0A97		    pop	    es
seg000:0A98		    assume es:nothing
seg000:0A98		    pop	    ds
seg000:0A99		    pop	    di
seg000:0A9A		    pop	    si
seg000:0A9B		    pop	    dx
seg000:0A9C		    pop	    cx
seg000:0A9D		    pop	    bx
seg000:0A9E		    pop	    ax
seg000:0A9F		    retf
seg000:0A9F ; ---------------------------------------------------------------------------
seg000:0AA0 StartVDHead	    dd 0		    ; DATA XREF: InstVDiskHeader+3Ao
seg000:0AA4		    dw 8000h
seg000:0AA6		    dw 0
seg000:0AA8		    dw 0
seg000:0AAA		    db 1
seg000:0AAB		    db 7 dup(0)
seg000:0AB2 VDiskSig1	    db 'VDISK'              ; DATA XREF: IsVDiskInstalled+10o
seg000:0AB7 aV3_3	    db '  V3.3'
seg000:0ABD		    db 15 dup(0)
seg000:0ACC		    dw 0
seg000:0ACE		    db 11h
seg000:0ACF VDInt19	    db 0EAh
seg000:0AD0 OldVDInt19	    dw 2 dup(0)		    ; DATA XREF: InstVDiskHeader+7w
seg000:0AD0					    ; InstVDiskHeader+Ew
seg000:0AD4 VDiskHMAHead    db 3 dup(0)		    ; DATA XREF: InstVDiskHeader+52o
seg000:0AD7 VDiskSig2	    db 'VDISK'              ; DATA XREF: IsVDiskInstalled+1Fo
seg000:0ADC		    db '3.3'
seg000:0ADF		    dw 128
seg000:0AE1		    db 1
seg000:0AE2		    dw 1
seg000:0AE4		    db 1
seg000:0AE5		    dw 64
seg000:0AE7		    dw 512
seg000:0AE9		    db 0FEh
seg000:0AEA		    dw 6
seg000:0AEC		    dw 8
seg000:0AEE		    dw 1
seg000:0AF0		    dw 0
seg000:0AF2		    dw 440h
seg000:0AF4
seg000:0AF4 ; =============== S	U B R O	U T I N	E =======================================
seg000:0AF4
seg000:0AF4
seg000:0AF4 InstVDiskHeader proc near		    ; CODE XREF: seg000:0804p
seg000:0AF4		    xor	    ax,	ax
seg000:0AF6		    mov	    ds,	ax
seg000:0AF8		    mov	    ax,	word ptr ds:byte_62+2 ;	[19h*4]
seg000:0AFB		    mov	    cs:OldVDInt19, ax
seg000:0AFF		    mov	    ax,	word ptr ds:byte_62+4 ;	[19h*4+2]
seg000:0B02		    mov	    cs:OldVDInt19+2, ax
seg000:0B06		    mov	    ah,	48h
seg000:0B08		    mov	    bx,	4	    ; (EndVDHead-StartVDHead+15)>>4
seg000:0B0B		    int	    21h		    ; DOS - 2+ - ALLOCATE MEMORY
seg000:0B0B					    ; BX = number of 16-byte paragraphs	desired
seg000:0B0D		    dec	    ax
seg000:0B0E		    mov	    es,	ax
seg000:0B10		    mov	    es:SYSINIT$+1, 8
seg000:0B17		    mov	    word ptr es:stacks,	'CS'
seg000:0B1E		    inc	    ax
seg000:0B1F		    mov	    es,	ax
seg000:0B21		    cli
seg000:0B22		    mov	    word ptr ds:byte_62+2, 47 ;	[19h*4],(VDInt19-StartVDHead)
seg000:0B28		    mov	    word ptr ds:byte_62+4, ax ;	[19h*4+2]
seg000:0B2B		    mov	    cx,	52
seg000:0B2E		    mov	    si,	offset StartVDHead
seg000:0B31		    xor	    di,	di
seg000:0B33		    push    cs
seg000:0B34		    pop	    ds
seg000:0B35		    cld
seg000:0B36		    rep	movsb
seg000:0B38		    sti
seg000:0B39		    push    di
seg000:0B3A		    push    es
seg000:0B3B		    mov	    ax,	0FFFFh
seg000:0B3E		    mov	    es,	ax
seg000:0B40		    assume es:nothing
seg000:0B40		    mov	    di,	10h
seg000:0B43		    mov	    cx,	32
seg000:0B46		    mov	    si,	offset VDiskHMAHead
seg000:0B49		    rep	movsb
seg000:0B4B		    pop	    di
seg000:0B4C		    pop	    es
seg000:0B4D		    assume es:nothing
seg000:0B4D		    retn
seg000:0B4D InstVDiskHeader endp
seg000:0B4D
seg000:0B4D ; ---------------------------------------------------------------------------
seg000:0B4E dummy	    db 8 dup(0)		    ; DATA XREF: ClrVDISKHeader+21o
seg000:0B56 gdt		    db 8 dup(0)
seg000:0B5E src_desc	    dw 0FFFFh
seg000:0B60 src_desc_lo_word dw	0		    ; DATA XREF: ClrVDISKHeader+13w
seg000:0B62 src_desc_hi_byte db	0		    ; DATA XREF: ClrVDISKHeader+17w
seg000:0B63		    db 93h
seg000:0B64		    dw 0
seg000:0B66 tgt_desc	    dw 0FFFFh
seg000:0B68		    dw 0
seg000:0B6A		    db 10h
seg000:0B6B		    db 93h
seg000:0B6C		    dw 0
seg000:0B6E rombios_code    db 8 dup(0)
seg000:0B76 temp_stack	    db 8 dup(0)
seg000:0B7E ClrdVDISKHead   db 32 dup(0)	    ; DATA XREF: ClrVDISKHeader+Do
seg000:0B9E
seg000:0B9E ; =============== S	U B R O	U T I N	E =======================================
seg000:0B9E
seg000:0B9E
seg000:0B9E ClrVDISKHeader  proc near		    ; CODE XREF: seg000:0659p
seg000:0B9E		    push    es
seg000:0B9F		    mov	    ax,	cs
seg000:0BA1		    mov	    dx,	ax
seg000:0BA3		    mov	    cl,	12
seg000:0BA5		    shr	    dx,	cl
seg000:0BA7		    mov	    cl,	4
seg000:0BA9		    shl	    ax,	cl
seg000:0BAB		    add	    ax,	offset ClrdVDISKHead
seg000:0BAE		    adc	    dl,	0
seg000:0BB1		    mov	    cs:src_desc_lo_word, ax ; [cs:src_desc+desc.lo_word]
seg000:0BB5		    mov	    cs:src_desc_hi_byte, dl ; [cs:src_desc+desc.hi_byte]
seg000:0BBA		    mov	    cx,	16
seg000:0BBD		    push    cs
seg000:0BBE		    pop	    es
seg000:0BBF		    mov	    si,	offset dummy ; bmove
seg000:0BC2		    mov	    ah,	87h
seg000:0BC4		    int	    15h		    ; EXTENDED MEMORY -	BLOCK MOVE (AT,XT286,PS)
seg000:0BC4					    ; CX = number of words to move, ES:SI -> global descriptor table
seg000:0BC4					    ; Return: CF set on	error, AH = status
seg000:0BC6		    pop	    es
seg000:0BC7		    retn
seg000:0BC7 ClrVDISKHeader  endp
seg000:0BC7
seg000:0BC8
seg000:0BC8 ; =============== S	U B R O	U T I N	E =======================================
seg000:0BC8
seg000:0BC8
seg000:0BC8 SaveFreeHMAPtr  proc near		    ; CODE XREF: MovDOSHi+15p
seg000:0BC8		    mov	    bx,	es
seg000:0BCA		    mov	    ax,	0FFFFh
seg000:0BCD		    sub	    ax,	bx
seg000:0BCF		    add	    di,	15
seg000:0BD2		    and	    di,	0FFF0h
seg000:0BD5		    mov	    cl,	4
seg000:0BD7		    shl	    ax,	cl
seg000:0BD9		    sub	    di,	ax
seg000:0BDB		    push    ds
seg000:0BDC		    mov	    ax,	70h
seg000:0BDF		    mov	    ds,	ax
seg000:0BE1		    assume ds:nothing
seg000:0BE1		    mov	    ds:8F7h, di	    ; [FreeHMAPtr]
seg000:0BE5
seg000:0BE5 loc_BE5:				    ; DATA XREF: multi_pass+7BAw
seg000:0BE5					    ; multi_pass+7BFw
seg000:0BE5		    mov	    byte ptr ds:0Dh, 0FFh
seg000:0BEA		    pop	    ds
seg000:0BEB		    assume ds:nothing
seg000:0BEB		    retn
seg000:0BEB SaveFreeHMAPtr  endp
seg000:0BEB
seg000:0BEC
seg000:0BEC ; =============== S	U B R O	U T I N	E =======================================
seg000:0BEC
seg000:0BEC
seg000:0BEC IsVDiskInstalled proc near		    ; CODE XREF: AllocHMA+36p
seg000:0BEC		    xor	    ax,	ax
seg000:0BEE		    mov	    ds,	ax
seg000:0BF0		    mov	    ds,	word ptr ds:old70 ; DATA XREF: multi_pass+7C8w
seg000:0BF4		    mov	    si,	18	    ; [19*4+2]
seg000:0BF7		    mov	    cx,	5	    ; VLEN1
seg000:0BFA		    push    cs
seg000:0BFB		    pop	    es
seg000:0BFC		    mov	    di,	offset VDiskSig1 ; "VDISK"
seg000:0BFF		    repe cmpsb
seg000:0C01		    jz	    short ivdins_retn
seg000:0C03		    mov	    ax,	0FFFFh
seg000:0C06		    mov	    ds,	ax
seg000:0C08		    assume ds:nothing
seg000:0C08		    mov	    si,	13h
seg000:0C0B		    mov	    di,	offset VDiskSig2 ; "VDISK"
seg000:0C0E		    mov	    cx,	5	    ; VLEN2
seg000:0C11		    repe cmpsb
seg000:0C13
seg000:0C13 ivdins_retn:			    ; CODE XREF: IsVDiskInstalled+15j
seg000:0C13		    retn
seg000:0C13 IsVDiskInstalled endp
seg000:0C13
seg000:0C14
seg000:0C14 ; =============== S	U B R O	U T I N	E =======================================
seg000:0C14
seg000:0C14
seg000:0C14 CPMHack	    proc near		    ; CODE XREF: seg000:07BCp
seg000:0C14		    push    ds
seg000:0C15		    mov	    cx,	0FFFFh
seg000:0C18		    mov	    es,	cx
seg000:0C1A		    assume es:nothing
seg000:0C1A		    xor	    cx,	cx
seg000:0C1C		    mov	    ds,	cx
seg000:0C1E		    assume ds:nothing
seg000:0C1E		    mov	    si,	0C0h
seg000:0C21		    mov	    di,	0D0h
seg000:0C24		    mov	    cx,	5
seg000:0C27		    cld
seg000:0C28		    rep	movsb
seg000:0C2A		    pop	    ds
seg000:0C2B		    retn
seg000:0C2B CPMHack	    endp
seg000:0C2B
seg000:0C2C
seg000:0C2C ; =============== S	U B R O	U T I N	E =======================================
seg000:0C2C
seg000:0C2C
seg000:0C2C _off_to_para    proc near		    ; CODE XREF: seg000:0513p
seg000:0C2C					    ; seg000:051Fp ...
seg000:0C2C		    shr	    ax,	1
seg000:0C2E		    shr	    ax,	1	    ; DATA XREF: endfile+6r
seg000:0C2E					    ; endfile+Dw ...
seg000:0C30		    shr	    ax,	1	    ; DATA XREF: setparms+31w
seg000:0C32		    shr	    ax,	1
seg000:0C34		    retn
seg000:0C34 _off_to_para    endp
seg000:0C34
seg000:0C35
seg000:0C35 ; =============== S	U B R O	U T I N	E =======================================
seg000:0C35
seg000:0C35
seg000:0C35 TempCDS	    proc near		    ; CODE XREF: seg000:06F6p
seg000:0C35					    ; doconf+47p ...
seg000:0C35		    les	    di,	ds:DOSINFO
seg000:0C39		    assume es:nothing
seg000:0C39		    mov	    cl,	es:[di+20h]
seg000:0C3D		    xor	    ch,	ch
seg000:0C3F		    mov	    es:[di+21h], cl
seg000:0C43		    mov	    al,	cl
seg000:0C45		    mov	    ah,	88
seg000:0C47		    mul	    ah
seg000:0C49		    call    ParaRound
seg000:0C4C		    mov	    si,	ds:top_of_cdss
seg000:0C50		    sub	    si,	ax
seg000:0C52		    mov	    ds:ALLOCLIM, si
seg000:0C56		    mov	    es:[di+18h], si
seg000:0C5A		    mov	    ax,	si
seg000:0C5C		    mov	    word ptr es:[di+16h], 0
seg000:0C62		    lds	    si,	es:[di]
seg000:0C65		    mov	    es,	ax
seg000:0C67		    xor	    di,	di
seg000:0C69
seg000:0C69 fooset:				    ; CODE XREF: TempCDS+8Fj
seg000:0C69					    ; endfile+241p
seg000:0C69		    mov	    ax,	word ptr cs:DirStrng
seg000:0C6D		    stosw
seg000:0C6E		    mov	    ax,	word ptr cs:DirStrng+2
seg000:0C72		    stosw
seg000:0C73		    inc	    cs:DirStrng
seg000:0C78		    xor	    ax,	ax
seg000:0C7A		    push    cx
seg000:0C7B		    mov	    cx,	63
seg000:0C7E		    rep	stosb
seg000:0C80		    cmp	    si,	0FFFFh
seg000:0C83		    jz	    short fooset_zero
seg000:0C85		    cmp	    cs:fake_floppy_drv,	1
seg000:0C8B		    jnz	    short normcds
seg000:0C8D		    cmp	    byte ptr [si], 1 ; if dpb_drive = 0	(a) or 1 (b)
seg000:0C90		    ja	    short normcds
seg000:0C92		    mov	    cl,	3
seg000:0C94		    rep	stosw
seg000:0C96		    pop	    cx
seg000:0C97		    jmp	    short get_next_dpb
seg000:0C99 ; ---------------------------------------------------------------------------
seg000:0C99
seg000:0C99 fooset_zero:			    ; CODE XREF: TempCDS+4Ej
seg000:0C99		    mov	    cl,	3
seg000:0C9B		    rep	stosw
seg000:0C9D		    pop	    cx
seg000:0C9E		    jmp	    short fincds
seg000:0CA0 ; ---------------------------------------------------------------------------
seg000:0CA0
seg000:0CA0 normcds:				    ; CODE XREF: TempCDS+56j
seg000:0CA0					    ; TempCDS+5Bj
seg000:0CA0		    pop	    cx
seg000:0CA1		    cmp	    byte ptr [si+8], 0
seg000:0CA5		    jz	    short setnormcds
seg000:0CA7		    mov	    ax,	4000h
seg000:0CAA
seg000:0CAA setnormcds:				    ; CODE XREF: TempCDS+70j
seg000:0CAA		    stosw
seg000:0CAB		    mov	    ax,	si
seg000:0CAD		    stosw
seg000:0CAE		    mov	    ax,	ds
seg000:0CB0		    stosw
seg000:0CB1
seg000:0CB1 get_next_dpb:			    ; CODE XREF: TempCDS+62j
seg000:0CB1		    lds	    si,	[si+19h]
seg000:0CB4
seg000:0CB4 fincds:				    ; CODE XREF: TempCDS+69j
seg000:0CB4		    mov	    ax,	0FFFFh
seg000:0CB7		    stosw
seg000:0CB8		    stosw
seg000:0CB9		    stosw
seg000:0CBA		    mov	    ax,	2
seg000:0CBD		    stosw
seg000:0CBE		    mov	    al,	0
seg000:0CC0		    stosb
seg000:0CC1		    stosw
seg000:0CC2		    stosw
seg000:0CC3		    stosw
seg000:0CC4		    loop    fooset
seg000:0CC6		    mov	    cs:DirStrng, 'A'
seg000:0CCC		    retn
seg000:0CCC TempCDS	    endp
seg000:0CCC
seg000:0CCD
seg000:0CCD ; =============== S	U B R O	U T I N	E =======================================
seg000:0CCD
seg000:0CCD
seg000:0CCD endfile	    proc near		    ; CODE XREF: seg000:078Ap
seg000:0CCD		    push    ds
seg000:0CCE		    mov	    ax,	70h
seg000:0CD1		    mov	    ds,	ax
seg000:0CD3		    assume ds:nothing
seg000:0CD3		    cmp	    word ptr ds:52Fh, 0	; [multrk_flag]
seg000:0CD8		    jnz	    short multrk_flag_done
seg000:0CDA		    or	    word ptr ds:52Fh, 80h
seg000:0CE0
seg000:0CE0 multrk_flag_done:			    ; CODE XREF: endfile+Bj
seg000:0CE0		    pop	    ds
seg000:0CE1		    assume ds:nothing
seg000:0CE1		    mov	    ax,	cs:top_of_cdss
seg000:0CE5		    mov	    cs:ALLOCLIM, ax
seg000:0CE9		    push    cs
seg000:0CEA		    pop	    ds
seg000:0CEB		    call    round
seg000:0CEE		    mov	    al,	cs:FILES
seg000:0CF2		    sub	    al,	5
seg000:0CF4		    jbe	    short dofcbs
seg000:0CF6		    push    ax
seg000:0CF7		    mov	    al,	'F'
seg000:0CF9		    call    setdevmark
seg000:0CFC		    pop	    ax
seg000:0CFD		    xor	    ah,	ah
seg000:0CFF		    mov	    bx,	cs:memlo
seg000:0D04		    mov	    dx,	cs:memhi
seg000:0D09		    lds	    di,	cs:DOSINFO
seg000:0D0E		    lds	    di,	[di+4]	    ; SYSI.SFT
seg000:0D11		    mov	    [di], bx	    ; [di+SF.SFLink]
seg000:0D13		    mov	    [di+2], dx	    ; [di+SF.SFLink+2]
seg000:0D16		    push    cs
seg000:0D17		    pop	    ds
seg000:0D18		    les	    di,	dword ptr cs:memlo
seg000:0D1D		    mov	    word ptr es:[di], 0FFFFh
seg000:0D22		    mov	    es:[di+4], ax   ; [es:di+SF.SFCount]
seg000:0D26		    mov	    bl,	59	    ; SF_ENTRY.size
seg000:0D28		    mul	    bl
seg000:0D2A		    mov	    cx,	ax
seg000:0D2C		    add	    cs:memlo, ax
seg000:0D31		    mov	    ax,	6
seg000:0D34		    add	    cs:memlo, ax
seg000:0D39		    or	    cs:setdevmarkflag, 2
seg000:0D3F		    call    round	    ; DATA XREF: stackinit+37Aw
seg000:0D42		    add	    di,	ax
seg000:0D44		    xor	    ax,	ax
seg000:0D46		    rep	stosb
seg000:0D48
seg000:0D48 dofcbs:				    ; CODE XREF: endfile+27j
seg000:0D48		    push    cs
seg000:0D49		    pop	    ds
seg000:0D4A		    call    round
seg000:0D4D		    mov	    al,	'X'
seg000:0D4F		    call    setdevmark
seg000:0D52		    mov	    al,	cs:FCBS
seg000:0D56		    xor	    ah,	ah
seg000:0D58		    mov	    bx,	cs:memlo
seg000:0D5D		    mov	    dx,	cs:memhi
seg000:0D62		    lds	    di,	cs:DOSINFO
seg000:0D67		    mov	    [di+1Ah], bx    ; [di+SYSI_FCB]
seg000:0D6A		    mov	    [di+1Ch], dx    ; [di+SYSI_FCB+2]
seg000:0D6D		    mov	    bl,	cs:KEEP
seg000:0D72		    xor	    bh,	bh
seg000:0D74		    mov	    [di+1Eh], bx    ; [di+SYSI_KEEP]
seg000:0D77		    push    cs
seg000:0D78		    pop	    ds
seg000:0D79		    les	    di,	dword ptr ds:memlo
seg000:0D7D		    mov	    word ptr es:[di], 0FFFFh
seg000:0D82		    mov	    es:[di+4], ax   ; [es:di+SF.SFCount]
seg000:0D86		    mov	    bl,	59	    ; SF_ENTRY.size
seg000:0D88		    mov	    cx,	ax
seg000:0D8A		    mul	    bl
seg000:0D8C		    add	    ds:memlo, ax
seg000:0D90		    mov	    ax,	6
seg000:0D93		    add	    ds:memlo, ax
seg000:0D97		    or	    ds:setdevmarkflag, 2
seg000:0D9C		    call    round
seg000:0D9F		    add	    di,	ax
seg000:0DA1		    mov	    al,	'A'
seg000:0DA3
seg000:0DA3 fillloop:				    ; CODE XREF: endfile+F0j
seg000:0DA3		    push    cx
seg000:0DA4		    mov	    cx,	59	    ; SF_ENTRY.size
seg000:0DA7		    cld
seg000:0DA8		    rep	stosb
seg000:0DAA		    mov	    word ptr es:[di-3Bh], 0
seg000:0DB0		    mov	    word ptr es:[di-26h], 0
seg000:0DB6		    mov	    word ptr es:[di-24h], 0
seg000:0DBC		    pop	    cx
seg000:0DBD		    loop    fillloop
seg000:0DBF		    cmp	    ds:buffers,	0FFFFh
seg000:0DC4		    jz	    short dodefaultbuff
seg000:0DC6		    jmp	    dobuff
seg000:0DC9 ; ---------------------------------------------------------------------------
seg000:0DC9
seg000:0DC9 dodefaultbuff:			    ; CODE XREF: endfile+F7j
seg000:0DC9		    mov	    ds:h_buffers, 0
seg000:0DCF		    mov	    ds:buffers,	2
seg000:0DD5		    push    ax
seg000:0DD6		    push    ds
seg000:0DD7		    les	    bp,	cs:DOSINFO
seg000:0DDC		    les	    bp,	es:[bp+0]
seg000:0DE0		    push    cs
seg000:0DE1		    pop	    ds
seg000:0DE2
seg000:0DE2 nextdpb:				    ; CODE XREF: endfile+165j
seg000:0DE2		    mov	    bl,	es:[bp+0]
seg000:0DE6		    inc	    bl
seg000:0DE8		    mov	    ax,	4408h
seg000:0DEB		    int	    21h		    ; DOS - 2+ - IOCTL -
seg000:0DED		    or	    ax,	ax
seg000:0DEF		    jnz	    short nosetbuf
seg000:0DF1		    xor	    bx,	bx
seg000:0DF3		    mov	    bl,	es:[bp+0]
seg000:0DF7		    inc	    bl
seg000:0DF9		    mov	    dx,	offset devp_specialfunc	; deviceparameters
seg000:0DFC		    mov	    ax,	440Dh	    ; (IOCTL<<8)|GENERIC_IOCTL
seg000:0DFF		    mov	    cx,	860h
seg000:0E02		    int	    21h		    ; DOS - 2+ - IOCTL -
seg000:0E04		    jb	    short nosetbuf
seg000:0E06		    mov	    bx,	word ptr ds:devparms_9+6 ; deviceparameters+15
seg000:0E06					    ; (totalsectors, 16bit)
seg000:0E0A		    mov	    ax,	ds:devparms_7 ;	deviceparameters+7
seg000:0E0A					    ; (bytespersector)
seg000:0E0D		    xor	    dx,	dx
seg000:0E0F		    mov	    cx,	512
seg000:0E12		    div	    cx
seg000:0E14		    mul	    bx
seg000:0E16		    or	    dx,	dx
seg000:0E18		    jnz	    short setbuf
seg000:0E1A		    cmp	    ax,	720
seg000:0E1D		    jbe	    short nosetbuf
seg000:0E1F
seg000:0E1F setbuf:				    ; CODE XREF: endfile+14Bj
seg000:0E1F		    mov	    ds:buffers,	3
seg000:0E25		    jmp	    short chk_memsize_for_buffers
seg000:0E27 ; ---------------------------------------------------------------------------
seg000:0E27
seg000:0E27 nosetbuf:				    ; CODE XREF: endfile+122j
seg000:0E27					    ; endfile+137j ...
seg000:0E27		    cmp	    word ptr es:[bp+19h], 0FFFFh ; [es:bp+DPB.NEXT_DPB]
seg000:0E2C		    jz	    short chk_memsize_for_buffers
seg000:0E2E		    les	    bp,	es:[bp+19h] ; [es:bp+DPB.NEXT_DPB]
seg000:0E32		    jmp	    short nextdpb
seg000:0E34 ; ---------------------------------------------------------------------------
seg000:0E34
seg000:0E34 chk_memsize_for_buffers:		    ; CODE XREF: endfile+158j
seg000:0E34					    ; endfile+15Fj
seg000:0E34		    cmp	    ds:MEMORY_SIZE, 2000h
seg000:0E3A		    jbe	    short bufset
seg000:0E3C		    mov	    ds:buffers,	5
seg000:0E42		    cmp	    ds:MEMORY_SIZE, 4000h
seg000:0E48		    jbe	    short bufset
seg000:0E4A		    mov	    ds:buffers,	10
seg000:0E50		    cmp	    ds:MEMORY_SIZE, 8000h
seg000:0E56		    jbe	    short bufset
seg000:0E58		    mov	    ds:buffers,	15
seg000:0E5E
seg000:0E5E bufset:				    ; CODE XREF: endfile+16Dj
seg000:0E5E					    ; endfile+17Bj ...
seg000:0E5E		    pop	    ds
seg000:0E5F		    pop	    ax
seg000:0E60
seg000:0E60 dobuff:				    ; CODE XREF: endfile+F9j
seg000:0E60		    lds	    bx,	cs:DOSINFO
seg000:0E65		    mov	    ax,	cs:buffers
seg000:0E69		    mov	    [bx+3Fh], ax
seg000:0E6C		    mov	    ax,	cs:h_buffers
seg000:0E70		    mov	    [bx+41h], ax
seg000:0E73		    lds	    bx,	[bx+12h]
seg000:0E76		    call    round
seg000:0E79		    mov	    al,	'B'
seg000:0E7B		    call    setdevmark
seg000:0E7E		    push    ds
seg000:0E7F		    push    bx
seg000:0E80		    call    set_buffer
seg000:0E83		    pop	    bx
seg000:0E84		    pop	    ds
seg000:0E85		    cmp	    cs:h_buffers, 0
seg000:0E8B		    jz	    short xif16
seg000:0E8D		    call    round
seg000:0E90		    mov	    cx,	cs:memlo
seg000:0E95		    mov	    [bx+6], cx
seg000:0E98		    mov	    cx,	cs:memhi
seg000:0E9D		    mov	    [bx+8], cx
seg000:0EA0		    mov	    cx,	cs:h_buffers
seg000:0EA5		    mov	    [bx+10], cx
seg000:0EA8		    mov	    ax,	512
seg000:0EAB		    mul	    cx
seg000:0EAD		    mov	    cs:memlo, ax
seg000:0EB1		    or	    cs:setdevmarkflag, 2
seg000:0EB7		    call    round
seg000:0EBA
seg000:0EBA xif16:				    ; CODE XREF: endfile+1BEj
seg000:0EBA		    call    round
seg000:0EBD		    push    ax
seg000:0EBE		    mov	    ax,	'L'
seg000:0EC1		    call    setdevmark
seg000:0EC4		    pop	    ax
seg000:0EC5		    les	    di,	cs:DOSINFO
seg000:0ECA		    mov	    cl,	es:[di+20h] ; [es:di+SYSI_NUMIO]
seg000:0ECE		    cmp	    cl,	cs:NUM_CDS
seg000:0ED3		    jnb	    short gotncds
seg000:0ED5		    mov	    cl,	cs:NUM_CDS
seg000:0EDA
seg000:0EDA gotncds:				    ; CODE XREF: endfile+206j
seg000:0EDA		    xor	    ch,	ch
seg000:0EDC		    mov	    es:[di+21h], cl ; [es:di+SYSI_NCDS]
seg000:0EE0		    mov	    ax,	cs:memhi
seg000:0EE4		    mov	    es:[di+18h], ax ; [es:di+SYSI_CDS+2]
seg000:0EE8		    mov	    ax,	cs:memlo
seg000:0EEC		    mov	    es:[di+16h], ax ; [es:di+SYSI_CDS]
seg000:0EF0		    mov	    al,	cl
seg000:0EF2		    mov	    ah,	88	    ; curdirlen	; curdir_list.size
seg000:0EF4		    mul	    ah
seg000:0EF6		    call    ParaRound
seg000:0EF9		    add	    cs:memhi, ax
seg000:0EFE		    or	    cs:setdevmarkflag, 2
seg000:0F04		    call    round
seg000:0F07		    lds	    si,	es:[di]
seg000:0F0A		    les	    di,	es:[di+16h] ; [es:di+SYSI_CDS]
seg000:0F0E		    call    fooset
seg000:0F11		    push    cs
seg000:0F12		    pop	    ds
seg000:0F13		    cmp	    word ptr ds:stack_addr, 0FFFFh
seg000:0F18		    jz	    short doinstallstack
seg000:0F1A		    cmp	    ds:sys_scnd_model_byte, 0
seg000:0F1F		    jnz	    short doinstallstack
seg000:0F21		    cmp	    ds:sys_model_byte, 0FEh
seg000:0F26		    jnb	    short skipstack
seg000:0F28
seg000:0F28 doinstallstack:			    ; CODE XREF: endfile+24Bj
seg000:0F28					    ; endfile+252j
seg000:0F28		    mov	    ax,	ds:stack_count
seg000:0F2B		    or	    ax,	ax
seg000:0F2D		    jz	    short skipstack
seg000:0F2F		    call    round
seg000:0F32		    mov	    al,	'S'
seg000:0F34		    call    setdevmark
seg000:0F37		    mov	    ax,	ds:memhi
seg000:0F3A		    mov	    es,	ax
seg000:0F3C		    push    cs
seg000:0F3D		    pop	    ds
seg000:0F3E		    xor	    si,	si
seg000:0F40		    xor	    di,	di
seg000:0F42		    mov	    cx,	offset SYSINIT ; endstackcode
seg000:0F45		    mov	    ds:memlo, cx
seg000:0F49		    call    round
seg000:0F4C		    rep	movsb
seg000:0F4E		    push    ds
seg000:0F4F		    mov	    ax,	70h
seg000:0F52		    mov	    ds,	ax
seg000:0F54		    assume ds:nothing
seg000:0F54		    mov	    word ptr ds:8C0h, offset nextentry ; [NextStack]
seg000:0F5A		    mov	    word ptr ds:8C2h, es ; [NextStack+2]
seg000:0F5E		    mov	    ax,	cs:memlo
seg000:0F62		    mov	    word ptr cs:stack_addr, ax
seg000:0F66		    mov	    ds:8C6h, ax	    ; [IT_StackLoc]
seg000:0F69		    mov	    ax,	cs:memhi
seg000:0F6D		    mov	    word ptr cs:stack_addr+2, ax
seg000:0F71		    mov	    ds:8C8h, ax	    ; [IT_StackLoc+2]
seg000:0F74		    mov	    ax,	8
seg000:0F77		    add	    ax,	cs:stack_size
seg000:0F7C		    mul	    cs:stack_count
seg000:0F81		    mov	    ds:8CAh, ax	    ; [IT_StackSize]
seg000:0F84		    pop	    ds
seg000:0F85		    assume ds:nothing
seg000:0F85		    call    ParaRound
seg000:0F88		    add	    cs:memhi, ax
seg000:0F8D		    or	    cs:setdevmarkflag, 2
seg000:0F93		    call    round
seg000:0F96		    call    stackinit
seg000:0F99
seg000:0F99 skipstack:				    ; CODE XREF: endfile+259j
seg000:0F99					    ; endfile+260j
seg000:0F99		    push    cs
seg000:0F9A		    pop	    ds
seg000:0F9A endfile	    endp ; sp-analysis failed
seg000:0F9A
seg000:0F9B
seg000:0F9B loc_F9B:				    ; CODE XREF: seg000:06FEP
seg000:0F9B		    mov	    al,	ds:FILES
seg000:0F9E		    xor	    ah,	ah
seg000:0FA0		    mov	    cx,	ax
seg000:0FA2		    xor	    bx,	bx
seg000:0FA4		    mov	    ah,	3Eh
seg000:0FA6		    int	    21h		    ; DOS - 2+ - CLOSE A FILE WITH HANDLE
seg000:0FA6					    ; BX = file	handle
seg000:0FA8		    mov	    bx,	2
seg000:0FAB
seg000:0FAB rcclloop:				    ; CODE XREF: seg000:0FB0j
seg000:0FAB		    mov	    ah,	3Eh
seg000:0FAD		    int	    21h		    ; DOS - 2+ - CLOSE A FILE WITH HANDLE
seg000:0FAD					    ; BX = file	handle
seg000:0FAF		    inc	    bx
seg000:0FB0		    loop    rcclloop
seg000:0FB2		    mov	    dx,	offset condev ;	"CON"
seg000:0FB5		    mov	    al,	2
seg000:0FB7		    mov	    ah,	3Dh
seg000:0FB9		    stc
seg000:0FBA		    int	    21h		    ; DOS - 2+ - OPEN DISK FILE	WITH HANDLE
seg000:0FBA					    ; DS:DX -> ASCIZ filename
seg000:0FBA					    ; AL = access mode
seg000:0FBA					    ; 2	- read & write
seg000:0FBC		    jnb	    short goaux
seg000:0FBE		    call    badfil	    ; DATA XREF: endfile+287w
seg000:0FC1		    jmp	    short goaux2    ; DATA XREF: endfile+28Dw
seg000:0FC3 ; ---------------------------------------------------------------------------
seg000:0FC3
seg000:0FC3 goaux:				    ; CODE XREF: seg000:0FBCj
seg000:0FC3		    push    ax
seg000:0FC4		    mov	    bx,	1	    ; DATA XREF: endfile+299w
seg000:0FC7		    mov	    ah,	3Eh	    ; DATA XREF: endfile+2A4w
seg000:0FC9		    int	    21h		    ; DATA XREF: endfile+2B4w
seg000:0FC9					    ; DOS - 2+ - CLOSE A FILE WITH HANDLE
seg000:0FC9					    ; BX = file	handle
seg000:0FCB		    pop	    ax
seg000:0FCC		    mov	    bx,	ax
seg000:0FCE		    mov	    ah,	45h
seg000:0FD0
seg000:0FD0 loc_FD0:				    ; CODE XREF: longpath+5BP
seg000:0FD0					    ; DATA XREF: longpath+52r
seg000:0FD0		    int	    21h		    ; DOS -
seg000:0FD2		    mov	    ah,	45h
seg000:0FD4		    int	    21h		    ; DOS - 2+ - CREATE	DUPLICATE HANDLE (DUP)
seg000:0FD4					    ; BX = file	handle to duplicate
seg000:0FD6
seg000:0FD6 goaux2:				    ; CODE XREF: seg000:0FC1j
seg000:0FD6		    mov	    dx,	offset auxdev ;	"AUX"
seg000:0FD9		    mov	    al,	2
seg000:0FDB		    call    open_dev
seg000:0FDE		    mov	    dx,	offset prndev ;	"PRN"
seg000:0FE1		    mov	    al,	1
seg000:0FE3		    call    open_dev
seg000:0FE6		    push    ax
seg000:0FE7		    push    bx
seg000:0FE8		    push    dx
seg000:0FE9		    push    es
seg000:0FEA		    mov	    al,	0FFh
seg000:0FEC		    mov	    dx,	2F2h
seg000:0FEF		    out	    dx,	al
seg000:0FF0		    inc	    dx
seg000:0FF1		    out	    dx,	al
seg000:0FF2		    inc	    dx
seg000:0FF3		    out	    dx,	al
seg000:0FF4		    inc	    dx
seg000:0FF5		    out	    dx,	al
seg000:0FF6		    inc	    dx
seg000:0FF7
seg000:0FF7 loc_FF7:				    ; DATA XREF: SaveFreeHMAPtr+19w
seg000:0FF7		    out	    dx,	al
seg000:0FF8		    inc	    dx
seg000:0FF9		    out	    dx,	al
seg000:0FFA		    mov	    ax,	0F000h	    ; DATA XREF: seg000:0538w
seg000:0FFD
seg000:0FFD loc_FFD:				    ; DATA XREF: seg000:053Cw
seg000:0FFD					    ; seg000:0792w
seg000:0FFD		    mov	    es,	ax
seg000:0FFF		    assume es:nothing
seg000:0FFF		    cmp	    byte ptr es:0FFFEh,	0FCh
seg000:1005		    jz	    short startrearm
seg000:1007		    mov	    ah,	0C0h
seg000:1009		    int	    15h		    ; SYSTEM - GET CONFIGURATION (XT after 1/10/86,AT mdl 3x9,CONV,XT286,PS)
seg000:100B		    jb	    short finishrearm
seg000:100D		    test    byte ptr es:[bx+5],	40h
seg000:1012		    jz	    short finishrearm
seg000:1014
seg000:1014 startrearm:				    ; CODE XREF: seg000:1005j
seg000:1014		    mov	    al,	0FFh
seg000:1016		    mov	    dx,	6F2h
seg000:1019		    out	    dx,	al
seg000:101A		    inc	    dx
seg000:101B		    out	    dx,	al
seg000:101C		    inc	    dx
seg000:101D		    out	    dx,	al
seg000:101E		    inc	    dx
seg000:101F		    inc	    dx
seg000:1020		    out	    dx,	al
seg000:1021		    inc	    dx
seg000:1022		    out	    dx,	al
seg000:1023
seg000:1023 finishrearm:			    ; CODE XREF: seg000:100Bj
seg000:1023					    ; seg000:1012j
seg000:1023		    pop	    es
seg000:1024		    assume es:nothing
seg000:1024		    pop	    dx
seg000:1025		    pop	    bx
seg000:1026		    pop	    ax
seg000:1027		    push    ax
seg000:1028		    mov	    ax,	ds:memhi
seg000:102B		    sub	    ax,	ds:area
seg000:102F		    mov	    ds:impossible_owner_size, ax
seg000:1032		    mov	    al,	'T'
seg000:1034		    call    setdevmark
seg000:1037		    pop	    ax
seg000:1038		    mov	    di,	ds:memhi
seg000:103C		    mov	    es,	di
seg000:103E		    mov	    word ptr ds:sysinit_base_ptr+2, di
seg000:1042		    xor	    di,	di
seg000:1044		    mov	    word ptr ds:sysinit_base_ptr, di
seg000:1048		    mov	    si,	offset sysinit_base
seg000:104B		    mov	    cx,	128
seg000:104E		    add	    ds:memlo, cx
seg000:1052		    or	    cs:setdevmarkflag, 2
seg000:1058		    call    round
seg000:105B		    rep	movsb
seg000:105D		    mov	    word ptr ds:sysinit_ptr, offset sysinitptr
seg000:1063		    mov	    word ptr ds:sysinit_ptr+2, cs
seg000:1067		    or	    ds:install_flag, 2
seg000:106C		    call    round
seg000:106F		    mov	    bx,	ds:memhi
seg000:1073		    mov	    ax,	ds:area
seg000:1076		    mov	    ds:old_area, ax
seg000:1079		    mov	    es,	ax
seg000:107B		    sub	    bx,	ax
seg000:107D		    mov	    ah,	4Ah
seg000:107F		    int	    21h		    ; DOS - 2+ - ADJUST	MEMORY BLOCK SIZE (SETBLOCK)
seg000:107F					    ; ES = segment address of block to change
seg000:107F					    ; BX = new size in paragraphs
seg000:1081		    push    es
seg000:1082		    mov	    ax,	es
seg000:1084		    dec	    ax
seg000:1085		    mov	    es,	ax
seg000:1087		    mov	    es:SYSINIT$+1, 8
seg000:108E		    mov	    word ptr es:stacks,	'DS'
seg000:1095		    pop	    es
seg000:1096		    mov	    bx,	0FFFFh
seg000:1099		    mov	    ah,	48h
seg000:109B		    int	    21h		    ; DOS - 2+ - ALLOCATE MEMORY
seg000:109B					    ; BX = number of 16-byte paragraphs	desired
seg000:109D		    mov	    ah,	48h
seg000:109F		    int	    21h		    ; DOS - 2+ - ALLOCATE MEMORY
seg000:109F					    ; BX = number of 16-byte paragraphs	desired
seg000:10A1		    mov	    ds:memhi, ax
seg000:10A4		    mov	    ds:memlo, 0
seg000:10AA		    mov	    es,	ax
seg000:10AC		    assume es:nothing
seg000:10AC		    mov	    bx,	ds:top_of_cdss
seg000:10B0		    sub	    bx,	ax
seg000:10B2		    dec	    bx
seg000:10B3		    dec	    bx
seg000:10B4		    mov	    ah,	4Ah
seg000:10B6		    int	    21h		    ; DOS - 2+ - ADJUST	MEMORY BLOCK SIZE (SETBLOCK)
seg000:10B6					    ; ES = segment address of block to change
seg000:10B6					    ; BX = new size in paragraphs
seg000:10B8		    mov	    bx,	0FFFFh
seg000:10BB		    mov	    ah,	48h
seg000:10BD		    int	    21h		    ; DOS - 2+ - ALLOCATE MEMORY
seg000:10BD					    ; BX = number of 16-byte paragraphs	desired
seg000:10BF		    mov	    ah,	48h
seg000:10C1		    int	    21h		    ; DOS - 2+ - ALLOCATE MEMORY
seg000:10C1					    ; BX = number of 16-byte paragraphs	desired
seg000:10C3		    mov	    ds:area, ax
seg000:10C6		    mov	    es,	ds:memhi
seg000:10CA		    assume es:nothing
seg000:10CA		    mov	    ah,	49h
seg000:10CC		    int	    21h		    ; DOS - 2+ - FREE MEMORY
seg000:10CC					    ; ES = segment address of area to be freed
seg000:10CE		    retn
seg000:10CF
seg000:10CF ; =============== S	U B R O	U T I N	E =======================================
seg000:10CF
seg000:10CF
seg000:10CF do_install_exec proc near		    ; CODE XREF: multi_pass+8Cp
seg000:10CF		    push    si
seg000:10D0		    push    es
seg000:10D1		    push    ds
seg000:10D2		    pop	    es
seg000:10D3		    pop	    ds
seg000:10D4		    mov	    dx,	si
seg000:10D6		    xor	    cx,	cx
seg000:10D8		    cld
seg000:10D9		    mov	    cs:ldexec_start, ' ' ; 20h
seg000:10DF		    mov	    di,	offset ldexec_parm
seg000:10E2
seg000:10E2 installfilename:			    ; CODE XREF: do_install_exec+18j
seg000:10E2		    lodsb
seg000:10E3		    cmp	    al,	0
seg000:10E5		    jz	    short got_installparm
seg000:10E7		    jmp	    short installfilename
seg000:10E9 ; ---------------------------------------------------------------------------
seg000:10E9
seg000:10E9 got_installparm:			    ; CODE XREF: do_install_exec+16j
seg000:10E9					    ; do_install_exec+25j
seg000:10E9		    lodsb
seg000:10EA		    mov	    es:[di], al
seg000:10ED		    cmp	    al,	0Ah	    ; LF
seg000:10EF		    jz	    short done_installparm
seg000:10F1		    inc	    cl
seg000:10F3		    inc	    di
seg000:10F4		    jmp	    short got_installparm
seg000:10F6 ; ---------------------------------------------------------------------------
seg000:10F6
seg000:10F6 done_installparm:			    ; CODE XREF: do_install_exec+20j
seg000:10F6		    mov	    cs:ldexec_line, cl
seg000:10FB		    cmp	    cl,	0
seg000:10FE		    jnz	    short install_seg_set
seg000:1100		    mov	    cs:ldexec_start, 0Dh ; CR
seg000:1106
seg000:1106 install_seg_set:			    ; CODE XREF: do_install_exec+2Fj
seg000:1106		    mov	    cs:SYSINIT$, 0  ; mov word [cs:0],0
seg000:110D		    mov	    ax,	cs
seg000:110F		    mov	    cs:instexe,	ax  ; iexec.environ
seg000:1113		    mov	    cs:iexec_ldexec_line_seg, ax ; iexec.ldexec_line+2
seg000:1117		    mov	    cs:iexec_ldexec_5c_fcb_seg,	ax ; iexec.ldexec_5c_fcb+2
seg000:111B		    mov	    cs:iexec_ldexec_6c_fcb_seg,	ax ; iexec.ldexec_6c_fcb+2
seg000:111F		    call    sum_up
seg000:1122		    mov	    es:checksum, ax
seg000:1126		    xor	    ax,	ax
seg000:1128		    mov	    ah,	4Bh
seg000:112A		    mov	    bx,	offset instexe
seg000:112D		    push    es
seg000:112E		    push    ds
seg000:112F		    jmp	    cs:sysinit_base_ptr
seg000:112F do_install_exec endp
seg000:112F
seg000:1134 ; ---------------------------------------------------------------------------
seg000:1134
seg000:1134 sysinitptr:				    ; DATA XREF: seg000:105Do
seg000:1134		    pop	    si
seg000:1135		    push    es
seg000:1136		    push    ds
seg000:1137		    pop	    es
seg000:1138		    pop	    ds
seg000:1139		    jnb	    short install_exit_ret
seg000:113B		    push    si
seg000:113C		    call    badload
seg000:113F		    pop	    si
seg000:1140		    jmp	    short sysinitptr_retn
seg000:1142 ; ---------------------------------------------------------------------------
seg000:1142
seg000:1142 install_exit_ret:			    ; CODE XREF: seg000:1139j
seg000:1142		    mov	    ah,	4Dh
seg000:1144		    int	    21h		    ; DOS - 2+ - GET EXIT CODE OF SUBPROGRAM (WAIT)
seg000:1146		    cmp	    ah,	3
seg000:1149		    jz	    short sysinitptr_retn
seg000:114B		    call    error_line
seg000:114E		    stc
seg000:114F
seg000:114F sysinitptr_retn:			    ; CODE XREF: seg000:1140j
seg000:114F					    ; seg000:1149j
seg000:114F		    retn
seg000:1150
seg000:1150 ; =============== S	U B R O	U T I N	E =======================================
seg000:1150
seg000:1150
seg000:1150 ParaRound	    proc near		    ; CODE XREF: TempCDS+14p
seg000:1150					    ; endfile+229p ...
seg000:1150		    add	    ax,	15
seg000:1153		    rcr	    ax,	1
seg000:1155		    shr	    ax,	1
seg000:1157		    shr	    ax,	1
seg000:1159		    shr	    ax,	1
seg000:115B		    retn
seg000:115B ParaRound	    endp
seg000:115B
seg000:115C ; ---------------------------------------------------------------------------
seg000:115C
seg000:115C sysinit_base:			    ; DATA XREF: seg000:1048o
seg000:115C		    mov	    word ptr cs:loc_60+1, ss ; sysinit_base_ss = 61
seg000:1161		    mov	    word ptr cs:byte_62+1, sp ;	sysinit_base_sp	= 63
seg000:1166		    int	    21h		    ; DOS - PROGRAM TERMINATION
seg000:1168		    mov	    ss,	word ptr cs:loc_60+1
seg000:116D		    mov	    sp,	word ptr cs:byte_62+1
seg000:1172		    pop	    ds
seg000:1173		    pop	    es
seg000:1174		    jb	    short sysinit_base_end
seg000:1176		    call    sum_up
seg000:1179		    cmp	    es:checksum, ax
seg000:117E		    jz	    short sysinit_base_end
seg000:1180		    mov	    ah,	9
seg000:1182		    push    cs
seg000:1183		    pop	    ds
seg000:1184		    mov	    dx,	65h	    ; mem_alloc_err_msgx-sysinit_base
seg000:1187		    int	    21h		    ; DOS - PRINT STRING
seg000:1187					    ; DS:DX -> string terminated by "$"
seg000:1189
seg000:1189 _stall:				    ; CODE XREF: seg000:_stallj
seg000:1189		    jmp	    short _stall
seg000:118B ; ---------------------------------------------------------------------------
seg000:118B
seg000:118B sysinit_base_end:			    ; CODE XREF: seg000:1174j
seg000:118B					    ; seg000:117Ej
seg000:118B		    jmp	    es:sysinit_ptr
seg000:1190
seg000:1190 ; =============== S	U B R O	U T I N	E =======================================
seg000:1190
seg000:1190
seg000:1190 sum_up	    proc near		    ; CODE XREF: do_install_exec+50p
seg000:1190					    ; seg000:1176p
seg000:1190		    push    ds
seg000:1191		    mov	    ax,	es:top_of_cdss
seg000:1195		    mov	    ds,	ax
seg000:1197		    xor	    si,	si
seg000:1199		    xor	    ax,	ax
seg000:119B		    mov	    cx,	es:config_size
seg000:11A0		    shr	    cx,	1
seg000:11A2		    jz	    short sum_sys_code
seg000:11A4
seg000:11A4 sum1:				    ; CODE XREF: sum_up+18j
seg000:11A4		    add	    ax,	[si]
seg000:11A6		    inc	    si
seg000:11A7		    inc	    si
seg000:11A8		    loop    sum1
seg000:11AA
seg000:11AA sum_sys_code:			    ; CODE XREF: sum_up+12j
seg000:11AA		    mov	    si,	5A6h	    ; locstack
seg000:11AA					    ; starting after the stack
seg000:11AD		    mov	    cx,	3D20h	    ; SI_end
seg000:11AD					    ; is the label at the end of sysinit
seg000:11B0		    sub	    cx,	si
seg000:11B2		    shr	    cx,	1
seg000:11B4
seg000:11B4 sum2:				    ; CODE XREF: sum_up+29j
seg000:11B4		    add	    ax,	es:[si]
seg000:11B7		    inc	    si
seg000:11B8		    inc	    si
seg000:11B9		    loop    sum2
seg000:11BB		    pop	    ds
seg000:11BC		    retn
seg000:11BC sum_up	    endp
seg000:11BC
seg000:11BC ; ---------------------------------------------------------------------------
seg000:11BD _sysinit_base_ss dw	0		    ; sysinit_base_ss equ $-sysinit_base
seg000:11BF _sysinit_base_sp dw	0		    ; sysinit_base_sp equ $-sysinit_base
seg000:11C1 mem_alloc_err_msgx db 0Dh,0Ah
seg000:11C1		    db 'Memory allocation error $'
seg000:11DC
seg000:11DC ; =============== S	U B R O	U T I N	E =======================================
seg000:11DC
seg000:11DC
seg000:11DC set_buffer	    proc near		    ; CODE XREF: endfile+1B3p
seg000:11DC		    xor	    dl,	dl
seg000:11DE		    call    GetBufferAddr
seg000:11E1		    jz	    short set_buff_1
seg000:11E3		    mov	    dl,	1
seg000:11E5
seg000:11E5 set_buff_1:				    ; CODE XREF: set_buffer+5j
seg000:11E5		    mov	    [bx], di	    ; [bx+BUFFINF.Buff_Queue]
seg000:11E7		    mov	    word ptr [bx+2], es	; [bx+BUFFINF.Buff_Queue+2]
seg000:11EA		    mov	    word ptr [bx+4], 0 ; [bx+BUFFINF.Dirty_Buff_Count]
seg000:11EF		    mov	    ax,	di
seg000:11F1		    mov	    cx,	cs:buffers
seg000:11F6		    push    di
seg000:11F7
seg000:11F7 nxt_buff:				    ; CODE XREF: set_buffer+20j
seg000:11F7		    call    set_buffer_info
seg000:11FA		    mov	    di,	ax
seg000:11FC		    loop    nxt_buff
seg000:11FE		    sub	    di,	cs:singlebuffersize
seg000:1203		    pop	    cx
seg000:1204		    mov	    es:[di], cx	    ; [es:di+buffinfo.buf_next]
seg000:1207		    xchg    cx,	di
seg000:1209		    mov	    es:[di+2], cx   ; [es:di+buffinfo.buf_prev]
seg000:120D		    or	    dl,	dl
seg000:120F		    jz	    short set_buff_2
seg000:1211		    mov	    byte ptr [bx+12], 1
seg000:1215		    mov	    ax,	cs:memhi
seg000:1219		    mov	    word ptr [bx+13], 0
seg000:121E		    mov	    [bx+15], ax
seg000:1221		    mov	    ax,	cs:singlebuffersize
seg000:1225		    sub	    ax,	20
seg000:1228
seg000:1228 set_buff_2:				    ; CODE XREF: set_buffer+33j
seg000:1228		    add	    cs:memlo, ax
seg000:122D		    or	    cs:setdevmarkflag, 2
seg000:1233		    call    round
seg000:1236		    retn
seg000:1236 set_buffer	    endp
seg000:1236
seg000:1237
seg000:1237 ; =============== S	U B R O	U T I N	E =======================================
seg000:1237
seg000:1237
seg000:1237 GetBufferAddr   proc near		    ; CODE XREF: set_buffer+2p
seg000:1237		    push    bx
seg000:1238		    push    dx
seg000:1239		    mov	    ax,	cs:singlebuffersize
seg000:123D		    mul	    cs:buffers
seg000:1242		    add	    ax,	0Fh
seg000:1245		    and	    ax,	0FFF0h
seg000:1248		    mov	    bx,	ax
seg000:124A		    mov	    ax,	4A02h
seg000:124D		    int	    2Fh
seg000:124F		    cmp	    di,	0FFFFh
seg000:1252		    jnz	    short got_hma
seg000:1254		    mov	    di,	0
seg000:1257		    mov	    es,	cs:memhi
seg000:125C
seg000:125C got_hma:				    ; CODE XREF: GetBufferAddr+1Bj
seg000:125C		    pop	    dx
seg000:125D		    pop	    bx
seg000:125E		    retn
seg000:125E GetBufferAddr   endp
seg000:125E
seg000:125F
seg000:125F ; =============== S	U B R O	U T I N	E =======================================
seg000:125F
seg000:125F
seg000:125F set_buffer_info proc near		    ; CODE XREF: set_buffer:nxt_buffp
seg000:125F		    push    cs:buf_prev_off
seg000:1264		    pop	    word ptr es:[di+2] ; [es:di+buffinfo.buf_prev]
seg000:1268		    mov	    cs:buf_prev_off, ax
seg000:126C		    add	    ax,	cs:singlebuffersize
seg000:1271		    mov	    es:[di], ax	    ; [es:di+buffinfo.buf_next]
seg000:1274		    mov	    word ptr es:[di+4],	0FFh ; [es:di+buffinfo.buf_ID]
seg000:127A		    mov	    word ptr es:[di+6],	0 ; [es:di+buffinfo.buf_sector]
seg000:1280		    mov	    word ptr es:[di+8],	0 ; [es:di+buffinfo.buf_sector+2]
seg000:1286		    retn
seg000:1286 set_buffer_info endp
seg000:1286
seg000:1287
seg000:1287 ; =============== S	U B R O	U T I N	E =======================================
seg000:1287
seg000:1287
seg000:1287 stackinit	    proc near		    ; CODE XREF: endfile+2C9p
seg000:1287		    push    ax
seg000:1288		    push    ds
seg000:1289		    push    es
seg000:128A		    push    bx
seg000:128B		    push    cx
seg000:128C		    push    dx
seg000:128D		    push    di
seg000:128E		    push    si
seg000:128F		    push    bp
seg000:1290		    mov	    ax,	cs:stack_count
seg000:1294		    mov	    es:stackcount, ax
seg000:1298		    mov	    ax,	ds:stack_size
seg000:129B		    mov	    es:stacksize, ax
seg000:129F		    mov	    ax,	word ptr cs:stack_addr
seg000:12A3		    mov	    word ptr es:stacks,	ax
seg000:12A7		    mov	    ax,	word ptr cs:stack_addr+2
seg000:12AB		    mov	    word ptr es:stacks+2, ax
seg000:12AF		    mov	    bp,	word ptr es:stacks
seg000:12B4		    mov	    es:firstentry, bp
seg000:12B9		    mov	    ax,	8
seg000:12BC		    mov	    cx,	es:stackcount
seg000:12C1		    mul	    cx
seg000:12C3		    add	    ax,	bp
seg000:12C5		    mov	    es:stackat,	ax
seg000:12C9		    mov	    bx,	ax
seg000:12CB		    sub	    bx,	2
seg000:12CE		    mov	    di,	es:stackat
seg000:12D3		    mov	    ax,	es:stacksize
seg000:12D7		    mul	    cx
seg000:12D9		    mov	    cx,	ax
seg000:12DB		    xor	    ax,	ax
seg000:12DD		    push    es
seg000:12DE		    pop	    ds
seg000:12DF		    mov	    es,	word ptr ds:stacks+2
seg000:12E3		    cld
seg000:12E4		    rep	stosb
seg000:12E6		    mov	    cx,	ds:stackcount
seg000:12EA
seg000:12EA buildloop:				    ; CODE XREF: stackinit+82j
seg000:12EA		    mov	    byte ptr es:[bp+0],	0
seg000:12EF		    mov	    es:[bp+1], al
seg000:12F3		    mov	    es:[bp+2], ax
seg000:12F7		    mov	    es:[bp+4], ax
seg000:12FB		    add	    bx,	ds:stacksize
seg000:12FF		    mov	    es:[bp+6], bx
seg000:1303		    mov	    es:[bx], bp
seg000:1306		    add	    bp,	8
seg000:1309		    loop    buildloop
seg000:130B		    sub	    bp,	8
seg000:130E		    mov	    ds:lastentry, bp
seg000:1312		    mov	    ds:nextentry, bp
seg000:1316		    push    ds
seg000:1317		    mov	    ax,	0F000h
seg000:131A		    mov	    ds,	ax
seg000:131C		    assume ds:nothing
seg000:131C		    cmp	    byte ptr ds:0FFFEh,	0F9h
seg000:1321		    pop	    ds
seg000:1322		    assume ds:nothing
seg000:1322		    jnz	    short skip_disablenmis
seg000:1324		    mov	    al,	7
seg000:1326		    out	    72h, al	    ; CMOS Memory/RTC Index Register (Extended RAM)
seg000:1328
seg000:1328 skip_disablenmis:			    ; CODE XREF: stackinit+9Bj
seg000:1328		    xor	    ax,	ax
seg000:132A		    mov	    es,	ax
seg000:132C		    cli
seg000:132D
seg000:132D stkinit_02:				    ; 02h*4
seg000:132D		    mov	    si,	8
seg000:1330		    mov	    di,	642h	    ; INT19OLD02
seg000:1333		    mov	    bx,	offset old02
seg000:1336		    mov	    dx,	offset int02
seg000:1339		    call    new_init_loop
seg000:133C
seg000:133C stkinit_08:				    ; 08h*4
seg000:133C		    mov	    si,	32
seg000:133F		    mov	    di,	647h	    ; INT19OLD08
seg000:1342		    mov	    bx,	offset old08
seg000:1345		    mov	    dx,	offset int08
seg000:1348		    call    new_init_loop
seg000:134B
seg000:134B stkinit_09:				    ; 09h*4
seg000:134B		    mov	    si,	36
seg000:134E		    mov	    di,	64Ch	    ; INT19OLD09
seg000:1351		    mov	    bx,	offset old09
seg000:1354		    mov	    dx,	offset int09
seg000:1357		    call    new_init_loop
seg000:135A
seg000:135A stkinit_70:				    ; 70h*4
seg000:135A		    mov	    si,	448
seg000:135D		    mov	    di,	66Ah	    ; INT19OLD70
seg000:1360		    mov	    bx,	offset old70
seg000:1363		    mov	    dx,	offset int70
seg000:1366		    call    new_init_loop
seg000:1369
seg000:1369 stkinit_0A:				    ; 0Ah*4
seg000:1369		    mov	    si,	40
seg000:136C		    push    ds
seg000:136D		    lds	    bx,	es:[si]
seg000:1370		    push    ds
seg000:1371		    pop	    dx
seg000:1372		    cmp	    dx,	0
seg000:1375		    jz	    short int_0A_first
seg000:1377		    cmp	    byte ptr [bx], 0CFh
seg000:137A		    jz	    short int_0A_first
seg000:137C		    cmp	    word ptr [bx+6], 424Bh
seg000:1381		    jz	    short int_0A_not_first
seg000:1383		    cmp	    dx,	0F000h
seg000:1387		    jnz	    short int_0A_not_first
seg000:1389		    push    es
seg000:138A		    push    dx
seg000:138B		    mov	    dx,	0F000h
seg000:138E		    mov	    es,	dx
seg000:1390		    assume es:nothing
seg000:1390		    cmp	    bx,	es:0FF01h
seg000:1395		    pop	    dx
seg000:1396		    pop	    es
seg000:1397		    assume es:nothing
seg000:1397		    jz	    short int_0A_first
seg000:1399
seg000:1399 int_0A_not_first:			    ; CODE XREF: stackinit+FAj
seg000:1399					    ; stackinit+100j
seg000:1399		    pop	    ds
seg000:139A		    mov	    di,	651h	    ; INT19OLD0A
seg000:139D		    mov	    bx,	offset old0A
seg000:13A0		    mov	    dx,	offset int0A
seg000:13A3		    call    new_init_loop
seg000:13A6		    jmp	    short int_0A_end
seg000:13A8 ; ---------------------------------------------------------------------------
seg000:13A8
seg000:13A8 int_0A_first:			    ; CODE XREF: stackinit+EEj
seg000:13A8					    ; stackinit+F3j ...
seg000:13A8		    pop	    ds
seg000:13A9
seg000:13A9 int_0A_end:				    ; CODE XREF: stackinit+11Fj
seg000:13A9		    mov	    si,	44	    ; 0Bh*4
seg000:13AC		    push    ds
seg000:13AD		    lds	    bx,	es:[si]
seg000:13B0		    push    ds
seg000:13B1		    pop	    dx
seg000:13B2		    cmp	    dx,	0
seg000:13B5		    jz	    short int_0B_first
seg000:13B7		    cmp	    byte ptr [bx], 0CFh
seg000:13BA		    jz	    short int_0B_first
seg000:13BC		    cmp	    word ptr [bx+6], 424Bh
seg000:13C1		    jz	    short int_0B_not_first
seg000:13C3		    cmp	    dx,	0F000h
seg000:13C7		    jnz	    short int_0B_not_first
seg000:13C9		    push    es
seg000:13CA		    push    dx
seg000:13CB		    mov	    dx,	0F000h
seg000:13CE		    mov	    es,	dx
seg000:13D0		    assume es:nothing
seg000:13D0		    cmp	    bx,	es:0FF01h
seg000:13D5		    pop	    dx
seg000:13D6		    pop	    es
seg000:13D7		    assume es:nothing
seg000:13D7		    jz	    short int_0B_first
seg000:13D9
seg000:13D9 int_0B_not_first:			    ; CODE XREF: stackinit+13Aj
seg000:13D9					    ; stackinit+140j
seg000:13D9		    pop	    ds
seg000:13DA		    mov	    di,	656h	    ; INT19OLD0B
seg000:13DD		    mov	    bx,	71h ; 'q'
seg000:13E0		    mov	    dx,	6Fh ; 'o'
seg000:13E3		    call    new_init_loop
seg000:13E6		    jmp	    short int_0B_end
seg000:13E8 ; ---------------------------------------------------------------------------
seg000:13E8
seg000:13E8 int_0B_first:			    ; CODE XREF: stackinit+12Ej
seg000:13E8					    ; stackinit+133j ...
seg000:13E8		    pop	    ds
seg000:13E9
seg000:13E9 int_0B_end:				    ; CODE XREF: stackinit+15Fj
seg000:13E9		    mov	    si,	48	    ; 0Ch*4
seg000:13EC		    push    ds
seg000:13ED		    lds	    bx,	es:[si]
seg000:13F0		    push    ds
seg000:13F1		    pop	    dx
seg000:13F2		    cmp	    dx,	0
seg000:13F5		    jz	    short int_0C_first
seg000:13F7		    cmp	    byte ptr [bx], 0CFh
seg000:13FA		    jz	    short int_0C_first
seg000:13FC		    cmp	    word ptr [bx+6], 424Bh
seg000:1401		    jz	    short int_0C_not_first
seg000:1403		    cmp	    dx,	0F000h
seg000:1407		    jnz	    short int_0C_not_first
seg000:1409		    push    es
seg000:140A		    push    dx
seg000:140B		    mov	    dx,	0F000h
seg000:140E		    mov	    es,	dx
seg000:1410		    assume es:nothing
seg000:1410		    cmp	    bx,	es:0FF01h
seg000:1415		    pop	    dx
seg000:1416		    pop	    es
seg000:1417		    assume es:nothing
seg000:1417		    jz	    short int_0C_first
seg000:1419
seg000:1419 int_0C_not_first:			    ; CODE XREF: stackinit+17Aj
seg000:1419					    ; stackinit+180j
seg000:1419		    pop	    ds
seg000:141A		    mov	    di,	65Bh	    ; INT19OLD0C
seg000:141D		    mov	    bx,	offset old0C
seg000:1420		    mov	    dx,	offset int0C
seg000:1423		    call    new_init_loop
seg000:1426		    jmp	    short int_0C_end
seg000:1428 ; ---------------------------------------------------------------------------
seg000:1428
seg000:1428 int_0C_first:			    ; CODE XREF: stackinit+16Ej
seg000:1428					    ; stackinit+173j ...
seg000:1428		    pop	    ds
seg000:1429
seg000:1429 int_0C_end:				    ; CODE XREF: stackinit+19Fj
seg000:1429		    mov	    si,	52	    ; 0Dh*4
seg000:142C		    push    ds
seg000:142D		    lds	    bx,	es:[si]
seg000:1430		    push    ds
seg000:1431		    pop	    dx
seg000:1432		    cmp	    dx,	0
seg000:1435		    jz	    short int_0D_first
seg000:1437		    cmp	    byte ptr [bx], 0CFh	; 'Ï'
seg000:143A		    jz	    short int_0D_first
seg000:143C		    cmp	    word ptr [bx+6], 424Bh
seg000:1441		    jz	    short int_0D_not_first
seg000:1443		    cmp	    dx,	0F000h
seg000:1447		    jnz	    short int_0D_not_first
seg000:1449		    push    es
seg000:144A		    push    dx
seg000:144B		    mov	    dx,	0F000h
seg000:144E		    mov	    es,	dx
seg000:1450		    assume es:nothing
seg000:1450		    cmp	    bx,	es:0FF01h
seg000:1455		    pop	    dx
seg000:1456		    pop	    es
seg000:1457		    assume es:nothing
seg000:1457		    jz	    short int_0D_first
seg000:1459
seg000:1459 int_0D_not_first:			    ; CODE XREF: stackinit+1BAj
seg000:1459					    ; stackinit+1C0j
seg000:1459		    pop	    ds
seg000:145A		    mov	    di,	660h	    ; INT19OLD0D
seg000:145D		    mov	    bx,	offset old0D
seg000:1460		    mov	    dx,	offset int0D
seg000:1463		    call    new_init_loop
seg000:1466		    jmp	    short int_0D_end
seg000:1468 ; ---------------------------------------------------------------------------
seg000:1468
seg000:1468 int_0D_first:			    ; CODE XREF: stackinit+1AEj
seg000:1468					    ; stackinit+1B3j ...
seg000:1468		    pop	    ds
seg000:1469
seg000:1469 int_0D_end:				    ; CODE XREF: stackinit+1DFj
seg000:1469		    mov	    si,	56	    ; 0Eh*4
seg000:146C		    push    ds
seg000:146D		    lds	    bx,	es:[si]
seg000:1470		    push    ds
seg000:1471		    pop	    dx
seg000:1472		    cmp	    dx,	0
seg000:1475		    jz	    short int_0E_first
seg000:1477		    cmp	    byte ptr [bx], 0CFh
seg000:147A		    jz	    short int_0E_first
seg000:147C		    cmp	    word ptr [bx+6], 424Bh
seg000:1481		    jz	    short int_0E_not_first
seg000:1483		    cmp	    dx,	0F000h
seg000:1487		    jnz	    short int_0E_not_first
seg000:1489		    push    es
seg000:148A		    push    dx
seg000:148B		    mov	    dx,	0F000h
seg000:148E		    mov	    es,	dx
seg000:1490		    assume es:nothing
seg000:1490		    cmp	    bx,	es:0FF01h
seg000:1495		    pop	    dx
seg000:1496		    pop	    es
seg000:1497		    assume es:nothing
seg000:1497		    jz	    short int_0E_first
seg000:1499
seg000:1499 int_0E_not_first:			    ; CODE XREF: stackinit+1FAj
seg000:1499					    ; stackinit+200j
seg000:1499		    pop	    ds
seg000:149A		    mov	    di,	665h	    ; INT19OLD0E
seg000:149D		    mov	    bx,	offset old0E
seg000:14A0		    mov	    dx,	offset int0E
seg000:14A3		    call    new_init_loop
seg000:14A6		    jmp	    short int_0E_end
seg000:14A8 ; ---------------------------------------------------------------------------
seg000:14A8
seg000:14A8 int_0E_first:			    ; CODE XREF: stackinit+1EEj
seg000:14A8					    ; stackinit+1F3j ...
seg000:14A8		    pop	    ds
seg000:14A9
seg000:14A9 int_0E_end:				    ; CODE XREF: stackinit+21Fj
seg000:14A9		    mov	    si,	456	    ; 72h*4
seg000:14AC		    push    ds
seg000:14AD		    lds	    bx,	es:[si]
seg000:14B0		    push    ds
seg000:14B1		    pop	    dx
seg000:14B2		    cmp	    dx,	0
seg000:14B5		    jz	    short int_72_first
seg000:14B7		    cmp	    byte ptr [bx], 0CFh
seg000:14BA		    jz	    short int_72_first
seg000:14BC		    cmp	    word ptr [bx+6], 424Bh
seg000:14C1		    jz	    short int_72_not_first
seg000:14C3		    cmp	    dx,	0F000h
seg000:14C7		    jnz	    short int_72_not_first
seg000:14C9		    push    es
seg000:14CA		    push    dx
seg000:14CB		    mov	    dx,	0F000h
seg000:14CE		    mov	    es,	dx
seg000:14D0		    assume es:nothing
seg000:14D0		    cmp	    bx,	es:0FF01h
seg000:14D5		    pop	    dx
seg000:14D6		    pop	    es
seg000:14D7		    assume es:nothing
seg000:14D7		    jz	    short int_72_first
seg000:14D9
seg000:14D9 int_72_not_first:			    ; CODE XREF: stackinit+23Aj
seg000:14D9					    ; stackinit+240j
seg000:14D9		    pop	    ds
seg000:14DA		    mov	    di,	66Fh	    ; INT19OLD72
seg000:14DD		    mov	    bx,	offset old72
seg000:14E0		    mov	    dx,	offset int72
seg000:14E3		    call    new_init_loop
seg000:14E6		    jmp	    short int_72_end
seg000:14E8 ; ---------------------------------------------------------------------------
seg000:14E8
seg000:14E8 int_72_first:			    ; CODE XREF: stackinit+22Ej
seg000:14E8					    ; stackinit+233j ...
seg000:14E8		    pop	    ds
seg000:14E9
seg000:14E9 int_72_end:				    ; CODE XREF: stackinit+25Fj
seg000:14E9		    mov	    si,	460	    ; 73h*4
seg000:14EC		    push    ds
seg000:14ED		    lds	    bx,	es:[si]
seg000:14F0		    push    ds
seg000:14F1		    pop	    dx
seg000:14F2		    cmp	    dx,	0
seg000:14F5		    jz	    short int_73_first
seg000:14F7		    cmp	    byte ptr [bx], 0CFh
seg000:14FA		    jz	    short int_73_first
seg000:14FC		    cmp	    word ptr [bx+6], 424Bh
seg000:1501		    jz	    short int_73_not_first
seg000:1503		    cmp	    dx,	0F000h
seg000:1507		    jnz	    short int_73_not_first
seg000:1509		    push    es
seg000:150A		    push    dx
seg000:150B		    mov	    dx,	0F000h
seg000:150E		    mov	    es,	dx
seg000:1510		    assume es:nothing
seg000:1510		    cmp	    bx,	es:0FF01h
seg000:1515		    pop	    dx
seg000:1516		    pop	    es
seg000:1517		    assume es:nothing
seg000:1517		    jz	    short int_73_first
seg000:1519
seg000:1519 int_73_not_first:			    ; CODE XREF: stackinit+27Aj
seg000:1519					    ; stackinit+280j
seg000:1519		    pop	    ds
seg000:151A		    mov	    di,	674h	    ; INT19OLD73
seg000:151D		    mov	    bx,	offset old73
seg000:1520		    mov	    dx,	offset int73
seg000:1523		    call    new_init_loop
seg000:1526		    jmp	    short int_73_end
seg000:1528 ; ---------------------------------------------------------------------------
seg000:1528
seg000:1528 int_73_first:			    ; CODE XREF: stackinit+26Ej
seg000:1528					    ; stackinit+273j ...
seg000:1528		    pop	    ds
seg000:1529
seg000:1529 int_73_end:				    ; CODE XREF: stackinit+29Fj
seg000:1529		    mov	    si,	464	    ; 74h*4
seg000:152C		    push    ds
seg000:152D		    lds	    bx,	es:[si]
seg000:1530		    push    ds
seg000:1531		    pop	    dx
seg000:1532		    cmp	    dx,	0
seg000:1535		    jz	    short int_74_first
seg000:1537		    cmp	    byte ptr [bx], 0CFh
seg000:153A		    jz	    short int_74_first
seg000:153C		    cmp	    word ptr [bx+6], 424Bh
seg000:1541		    jz	    short int_74_not_first
seg000:1543		    cmp	    dx,	0F000h
seg000:1547		    jnz	    short int_74_not_first
seg000:1549		    push    es
seg000:154A		    push    dx
seg000:154B		    mov	    dx,	0F000h
seg000:154E		    mov	    es,	dx
seg000:1550		    assume es:nothing
seg000:1550		    cmp	    bx,	es:0FF01h
seg000:1555		    pop	    dx
seg000:1556		    pop	    es
seg000:1557		    assume es:nothing
seg000:1557		    jz	    short int_74_first
seg000:1559
seg000:1559 int_74_not_first:			    ; CODE XREF: stackinit+2BAj
seg000:1559					    ; stackinit+2C0j
seg000:1559		    pop	    ds
seg000:155A		    mov	    di,	679h	    ; INT19OLD74
seg000:155D		    mov	    bx,	offset old74
seg000:1560		    mov	    dx,	offset int74
seg000:1563		    call    new_init_loop
seg000:1566		    jmp	    short int_74_end
seg000:1568 ; ---------------------------------------------------------------------------
seg000:1568
seg000:1568 int_74_first:			    ; CODE XREF: stackinit+2AEj
seg000:1568					    ; stackinit+2B3j ...
seg000:1568		    pop	    ds
seg000:1569
seg000:1569 int_74_end:				    ; CODE XREF: stackinit+2DFj
seg000:1569		    mov	    si,	472	    ; 76h*4
seg000:156C		    push    ds
seg000:156D		    lds	    bx,	es:[si]
seg000:1570		    push    ds
seg000:1571		    pop	    dx
seg000:1572		    cmp	    dx,	0
seg000:1575		    jz	    short int_76_first
seg000:1577		    cmp	    byte ptr [bx], 0CFh
seg000:157A		    jz	    short int_76_first
seg000:157C		    cmp	    word ptr [bx+6], 424Bh
seg000:1581		    jz	    short int_76_not_first
seg000:1583		    cmp	    dx,	0F000h
seg000:1587		    jnz	    short int_76_not_first
seg000:1589		    push    es
seg000:158A		    push    dx
seg000:158B		    mov	    dx,	0F000h
seg000:158E		    mov	    es,	dx
seg000:1590		    assume es:nothing
seg000:1590		    cmp	    bx,	es:0FF01h
seg000:1595		    pop	    dx
seg000:1596		    pop	    es
seg000:1597		    assume es:nothing
seg000:1597		    jz	    short int_76_first
seg000:1599
seg000:1599 int_76_not_first:			    ; CODE XREF: stackinit+2FAj
seg000:1599					    ; stackinit+300j
seg000:1599		    pop	    ds
seg000:159A		    mov	    di,	67Eh	    ; INT19OLD76
seg000:159D		    mov	    bx,	offset old76
seg000:15A0		    mov	    dx,	offset int76
seg000:15A3		    call    new_init_loop
seg000:15A6		    jmp	    short int_76_end
seg000:15A8 ; ---------------------------------------------------------------------------
seg000:15A8
seg000:15A8 int_76_first:			    ; CODE XREF: stackinit+2EEj
seg000:15A8					    ; stackinit+2F3j ...
seg000:15A8		    pop	    ds
seg000:15A9
seg000:15A9 int_76_end:				    ; CODE XREF: stackinit+31Fj
seg000:15A9		    mov	    si,	476	    ; 77h*4
seg000:15AC		    push    ds
seg000:15AD		    lds	    bx,	es:[si]
seg000:15B0		    push    ds
seg000:15B1		    pop	    dx
seg000:15B2		    cmp	    dx,	0
seg000:15B5		    jz	    short int_77_first
seg000:15B7		    cmp	    byte ptr [bx], 0CFh
seg000:15BA		    jz	    short int_77_first
seg000:15BC		    cmp	    word ptr [bx+6], 424Bh
seg000:15C1		    jz	    short int_77_not_first
seg000:15C3		    cmp	    dx,	0F000h
seg000:15C7		    jnz	    short int_77_not_first
seg000:15C9		    push    es
seg000:15CA		    push    dx
seg000:15CB		    mov	    dx,	0F000h
seg000:15CE		    mov	    es,	dx
seg000:15D0		    assume es:nothing
seg000:15D0		    cmp	    bx,	es:0FF01h
seg000:15D5		    pop	    dx
seg000:15D6		    pop	    es
seg000:15D7		    assume es:nothing
seg000:15D7		    jz	    short int_77_first
seg000:15D9
seg000:15D9 int_77_not_first:			    ; CODE XREF: stackinit+33Aj
seg000:15D9					    ; stackinit+340j
seg000:15D9		    pop	    ds
seg000:15DA		    mov	    di,	683h
seg000:15DD		    mov	    bx,	131h
seg000:15E0		    mov	    dx,	12Fh
seg000:15E3		    call    new_init_loop
seg000:15E6		    jmp	    short int_77_end
seg000:15E8 ; ---------------------------------------------------------------------------
seg000:15E8
seg000:15E8 int_77_first:			    ; CODE XREF: stackinit+32Ej
seg000:15E8					    ; stackinit+333j ...
seg000:15E8		    pop	    ds
seg000:15E9
seg000:15E9 int_77_end:				    ; CODE XREF: stackinit+35Fj
seg000:15E9		    push    ds
seg000:15EA		    mov	    ax,	0F000h
seg000:15ED		    mov	    ds,	ax
seg000:15EF		    assume ds:nothing
seg000:15EF		    cmp	    byte ptr ds:0FFFEh,	0F9h
seg000:15F4		    pop	    ds
seg000:15F5		    assume ds:nothing
seg000:15F5		    jnz	    short skip_enablenmis
seg000:15F7		    mov	    al,	27h
seg000:15F9		    out	    72h, al	    ; CMOS Memory/RTC Index Register (Extended RAM)
seg000:15FB
seg000:15FB skip_enablenmis:			    ; CODE XREF: stackinit+36Ej
seg000:15FB		    sti
seg000:15FC		    mov	    ax,	70h
seg000:15FF		    mov	    ds,	ax
seg000:1601		    assume ds:nothing
seg000:1601		    mov	    byte ptr ds:640h, 1
seg000:1606		    pop	    bp
seg000:1607		    pop	    si
seg000:1608		    pop	    di
seg000:1609		    pop	    dx
seg000:160A		    pop	    cx
seg000:160B		    pop	    bx
seg000:160C		    pop	    es
seg000:160D		    pop	    ds
seg000:160E		    assume ds:nothing
seg000:160E		    pop	    ax
seg000:160F		    retn
seg000:160F stackinit	    endp
seg000:160F
seg000:1610
seg000:1610 ; =============== S	U B R O	U T I N	E =======================================
seg000:1610
seg000:1610
seg000:1610 new_init_loop   proc near		    ; CODE XREF: stackinit+B2p
seg000:1610					    ; stackinit+C1p ...
seg000:1610		    mov	    ax,	es:[si]
seg000:1613		    mov	    [bx], ax
seg000:1615		    mov	    ax,	es:[si+2]
seg000:1619		    mov	    [bx+2], ax
seg000:161C		    push    ds
seg000:161D		    mov	    ax,	70h
seg000:1620		    mov	    ds,	ax
seg000:1622		    assume ds:nothing
seg000:1622		    mov	    ax,	es:[si]
seg000:1625		    mov	    [di], ax
seg000:1627		    mov	    ax,	es:[si+2]
seg000:162B		    mov	    [di+2], ax
seg000:162E		    pop	    ds
seg000:162F		    assume ds:nothing
seg000:162F		    mov	    es:[si], dx
seg000:1632		    mov	    word ptr es:[si+2],	ds
seg000:1636		    retn
seg000:1636 new_init_loop   endp
seg000:1636
seg000:1637
seg000:1637 ; =============== S	U B R O	U T I N	E =======================================
seg000:1637
seg000:1637
seg000:1637 setdevmark	    proc near		    ; CODE XREF: endfile+2Cp
seg000:1637					    ; endfile+82p ...
seg000:1637		    push    es
seg000:1638		    push    cx
seg000:1639		    mov	    cx,	cs:memhi
seg000:163E		    mov	    cs:devmark_addr, cx
seg000:1643		    mov	    es,	cx
seg000:1645		    mov	    byte ptr es:SYSINIT$, al ; [es:0]
seg000:1649		    inc	    cx
seg000:164A		    mov	    es:SYSINIT$+1, cx ;	[es:1]
seg000:164F		    pop	    cx
seg000:1650		    pop	    es
seg000:1651		    inc	    cs:memhi
seg000:1656		    retn
seg000:1656 setdevmark	    endp
seg000:1656
seg000:1656 ; ---------------------------------------------------------------------------
seg000:1657		    db 0
seg000:1658 multdeviceflag  db 0		    ; DATA XREF: multi_pass+31w
seg000:1658					    ; multi_pass+2AEr ...
seg000:1659 devmark_addr    dw 0		    ; DATA XREF: setdevmark+7w
seg000:1659					    ; round+29r
seg000:165B setdevmarkflag  db 0		    ; DATA XREF: endfile+6Cw
seg000:165B					    ; endfile+CAw ...
seg000:165C driver_units    db 0
seg000:165D badparm_ptr	    dd 0		    ; DATA XREF: multi_pass+1C5w
seg000:165D					    ; sysinit_parse+Bw	...
seg000:165D					    ; SYSPARSE - Local Data
seg000:1661 _$P_ORDINAL	    dw 0		    ; DATA XREF: SysParse+8w
seg000:1661					    ; SysParse+DCr ...
seg000:1663 _$P_RC	    dw 0		    ; DATA XREF: SysParse+Dw
seg000:1663					    ; SysParse:_$P_Too_Many_Errorw ...
seg000:1665 _$P_SI_Save	    dw 0		    ; DATA XREF: SysParse:_$P_Pack_Endw
seg000:1665					    ; SysParse+16Ar ...
seg000:1667 _$P_DX	    dw 0		    ; DATA XREF: SysParse+1Bw
seg000:1667					    ; SysParse+16Fr ...
seg000:1669 _$P_Terminator  db 0		    ; DATA XREF: SysParse+174r
seg000:1669					    ; _$P_File_Format:_$P_FileF00w ...
seg000:166A _$P_DBCSEV_OFF  dw 0		    ; DATA XREF: _$P_Chk_DBCS+28w
seg000:166A					    ; _$P_Chk_DBCS:_$P_DBCS00r
seg000:166C _$P_DBCSEV_SEG  dw 0		    ; DATA XREF: _$P_Chk_DBCS+3r
seg000:166C					    ; _$P_Chk_DBCS+2Dw	...
seg000:166E _$P_Flags	    dw 0		    ; DATA XREF: SysParsew
seg000:166E					    ; SysParse+62r ...
seg000:1670 _$P_SaveSI_Cmpx dw 0		    ; DATA XREF: SysParse:_$P_Startw
seg000:1670					    ; _$P_Chk_SW_Control+18w ...
seg000:1672 _$P_KEYorSW_Ptr dw 0		    ; DATA XREF: _$P_Chk_SW_Control+12r
seg000:1672					    ; _$P_Chk_SW_Control+1Er ...
seg000:1674 _$P_Save_EOB    dw 0		    ; DATA XREF: SysParse+B6w
seg000:1676 _$P_Found_SYNONYM dw 0		    ; DATA XREF: SysParse+14w
seg000:1676					    ; _$P_Search_KEYorSW:_$P_KEYorSW_Foundw ...
seg000:1678 _$P_STRING_BUF  db 128 dup(0)	    ; DATA XREF: SysParse+5Eo
seg000:1678					    ; SysParse+BEo ...
seg000:16F8 _$P_Char_CAP_Ptr db	0FFh		    ; DATA XREF: _$P_Do_CAPS_Char+13o
seg000:16F9		    dw 0
seg000:16FB		    dw 0
seg000:16FD _$P_FileSp_Char db '[', ']', '|', '<', '>', '+', '=', ';', '"'
seg000:16FD					    ; DATA XREF: SysParse+22w
seg000:16FD					    ; _$P_FileSp_Chk+2o ...
seg000:1706 _$P_err_flag    db 0		    ; DATA XREF: _$P_Check_Match_Flagsw
seg000:1706					    ; _$P_Check_Match_Flags:_$P_Match_Exitr ...
seg000:1707
seg000:1707 ; =============== S	U B R O	U T I N	E =======================================
seg000:1707
seg000:1707
seg000:1707 SysParse	    proc near		    ; CODE XREF: sysinit_parse+13p
seg000:1707		    mov	    cs:_$P_Flags, 0
seg000:170E		    cld
seg000:170F		    mov	    cs:_$P_ORDINAL, cx
seg000:1714		    mov	    cs:_$P_RC, 0
seg000:171B		    mov	    cs:_$P_Found_SYNONYM, 0
seg000:1722		    mov	    cs:_$P_DX, 0
seg000:1729		    mov	    word ptr cs:_$P_FileSp_Char, ']['
seg000:1730		    mov	    word ptr cs:_$P_FileSp_Char+2, '<|'
seg000:1737		    mov	    word ptr cs:_$P_FileSp_Char+4, '+>'
seg000:173E		    mov	    word ptr cs:_$P_FileSp_Char+6, ';='
seg000:1745		    call    _$P_Skip_Delim
seg000:1748		    jnb	    short _$P_Start
seg000:174A		    mov	    ax,	0FFFFh
seg000:174D		    push    bx
seg000:174E		    mov	    bx,	es:[di]
seg000:1751		    cmp	    cl,	es:[bx]
seg000:1754		    jnb	    short _$P_Fin
seg000:1756		    mov	    ax,	2
seg000:1759
seg000:1759 _$P_Fin:				    ; CODE XREF: SysParse+4Dj
seg000:1759		    pop	    bx
seg000:175A		    jmp	    _$P_Single_Exit
seg000:175D ; ---------------------------------------------------------------------------
seg000:175D
seg000:175D _$P_Start:				    ; CODE XREF: SysParse+41j
seg000:175D		    mov	    cs:_$P_SaveSI_Cmpx,	si
seg000:1762		    push    bx
seg000:1763		    push    di
seg000:1764		    push    bp
seg000:1765		    lea	    bx,	_$P_STRING_BUF
seg000:1769		    test    byte ptr cs:_$P_Flags+1, 20h
seg000:176F		    jnz	    short _$P_Pack_End
seg000:1771
seg000:1771 _$P_Pack_Loop:			    ; CODE XREF: SysParse+A3j
seg000:1771					    ; SysParse+AAj
seg000:1771		    lodsb
seg000:1772		    call    _$P_Chk_Switch
seg000:1775		    jb	    short _$P_Pack_End_BY_EOL
seg000:1777		    call    _$P_Chk_EOL
seg000:177A		    jz	    short _$P_Pack_End_BY_EOL
seg000:177C		    call    _$P_Chk_Delim
seg000:177F		    jnz	    short _$P_PL01
seg000:1781		    test    byte ptr cs:_$P_Flags+1, 20h
seg000:1787		    jnz	    short _$P_Pack_End_backup_si
seg000:1789		    call    _$P_Skip_Delim
seg000:178C		    jmp	    short _$P_Pack_End
seg000:178E ; ---------------------------------------------------------------------------
seg000:178E
seg000:178E _$P_Pack_End_backup_si:		    ; CODE XREF: SysParse+80j
seg000:178E		    test    byte ptr cs:_$P_Flags+1, 41h
seg000:1794		    jz	    short _$P_Pack_End
seg000:1796		    dec	    si
seg000:1797		    jmp	    short _$P_Pack_End
seg000:1799 ; ---------------------------------------------------------------------------
seg000:1799
seg000:1799 _$P_PL01:				    ; CODE XREF: SysParse+78j
seg000:1799		    mov	    cs:[bx], al
seg000:179C		    cmp	    al,	3Dh ; '='   ; _$P_Keyword
seg000:179E		    jnz	    short _$P_PL00
seg000:17A0		    or	    byte ptr cs:_$P_Flags+1, 1
seg000:17A6
seg000:17A6 _$P_PL00:				    ; CODE XREF: SysParse+97j
seg000:17A6		    inc	    bx
seg000:17A7		    call    _$P_Chk_DBCS
seg000:17AA		    jnb	    short _$P_Pack_Loop
seg000:17AC		    lodsb
seg000:17AD		    mov	    cs:[bx], al
seg000:17B0		    inc	    bx
seg000:17B1		    jmp	    short _$P_Pack_Loop
seg000:17B3 ; ---------------------------------------------------------------------------
seg000:17B3
seg000:17B3 _$P_Pack_End_BY_EOL:		    ; CODE XREF: SysParse+6Ej
seg000:17B3					    ; SysParse+73j
seg000:17B3		    dec	    si
seg000:17B4
seg000:17B4 _$P_Pack_End:			    ; CODE XREF: SysParse+68j
seg000:17B4					    ; SysParse+85j ...
seg000:17B4		    mov	    cs:_$P_SI_Save, si
seg000:17B9		    mov	    byte ptr cs:[bx], 0
seg000:17BD		    mov	    cs:_$P_Save_EOB, bx
seg000:17C2		    mov	    bx,	es:[di]
seg000:17C5		    lea	    si,	_$P_STRING_BUF
seg000:17C9		    cmp	    byte ptr cs:[si], 2Fh ; '/' ; _$P_Switch
seg000:17CD		    jz	    short _$P_SW_Manager
seg000:17CF		    cmp	    byte ptr cs:[si], 22h ; '"' ; _$P_DQuote
seg000:17D3		    jz	    short _$P_Positional_Manager
seg000:17D5		    test    byte ptr cs:_$P_Flags+1, 1
seg000:17DB		    jnz	    short _$P_Key_Manager
seg000:17DD
seg000:17DD _$P_Positional_Manager:		    ; CODE XREF: SysParse+CCj
seg000:17DD		    mov	    al,	es:[bx+1]   ; [es:bx+_$P_PARMSX_Blk.MaxP]
seg000:17E1		    xor	    ah,	ah
seg000:17E3		    cmp	    cs:_$P_ORDINAL, ax
seg000:17E8		    jnb	    short _$P_Too_Many_Error
seg000:17EA		    mov	    ax,	cs:_$P_ORDINAL
seg000:17EE		    shl	    ax,	1
seg000:17F0		    inc	    bx
seg000:17F1		    inc	    bx
seg000:17F2		    add	    bx,	ax
seg000:17F4		    mov	    bx,	es:[bx]
seg000:17F7		    call    _$P_Chk_Pos_Control
seg000:17FA		    jmp	    short _$P_Return_to_Caller
seg000:17FC ; ---------------------------------------------------------------------------
seg000:17FC
seg000:17FC _$P_Too_Many_Error:			    ; CODE XREF: SysParse+E1j
seg000:17FC		    mov	    cs:_$P_RC, 1
seg000:1803		    jmp	    short _$P_Return_to_Caller
seg000:1805 ; ---------------------------------------------------------------------------
seg000:1805
seg000:1805 _$P_SW_Manager:			    ; CODE XREF: SysParse+C6j
seg000:1805		    mov	    al,	es:[bx+1]   ; [es:bx+_$P_PARMSX_Blk.MaxP]
seg000:1809		    xor	    ah,	ah
seg000:180B		    inc	    ax
seg000:180C		    shl	    ax,	1
seg000:180E		    add	    bx,	ax
seg000:1810		    mov	    cl,	es:[bx]
seg000:1813		    xor	    ch,	ch
seg000:1815		    or	    cx,	cx
seg000:1817		    jz	    short _$P_SW_Not_Found
seg000:1819		    inc	    bx
seg000:181A
seg000:181A _$P_SW_Mgr_Loop:			    ; CODE XREF: SysParse+11Fj
seg000:181A		    push    bx
seg000:181B		    mov	    bx,	es:[bx]
seg000:181E		    call    _$P_Chk_SW_Control
seg000:1821		    pop	    bx
seg000:1822		    jnb	    short _$P_Return_to_Caller
seg000:1824		    inc	    bx
seg000:1825		    inc	    bx
seg000:1826		    loop    _$P_SW_Mgr_Loop
seg000:1828
seg000:1828 _$P_SW_Not_Found:			    ; CODE XREF: SysParse+110j
seg000:1828		    mov	    cs:_$P_RC, 3
seg000:182F		    jmp	    short _$P_Return_to_Caller
seg000:1831 ; ---------------------------------------------------------------------------
seg000:1831
seg000:1831 _$P_Key_Manager:			    ; CODE XREF: SysParse+D4j
seg000:1831		    mov	    al,	es:[bx+1]
seg000:1835		    xor	    ah,	ah
seg000:1837		    inc	    ax
seg000:1838		    shl	    ax,	1
seg000:183A		    add	    bx,	ax
seg000:183C		    mov	    al,	es:[bx]
seg000:183F		    xor	    ah,	ah
seg000:1841		    shl	    ax,	1
seg000:1843		    inc	    ax
seg000:1844		    add	    bx,	ax
seg000:1846		    mov	    cl,	es:[bx]
seg000:1849		    xor	    ch,	ch
seg000:184B		    or	    cx,	cx
seg000:184D		    jz	    short _$P_Key_Not_Found
seg000:184F		    inc	    bx
seg000:1850
seg000:1850 _$P_Key_Mgr_Loop:			    ; CODE XREF: SysParse+155j
seg000:1850		    push    bx
seg000:1851		    mov	    bx,	es:[bx]
seg000:1854		    call    _$P_Chk_Key_Control
seg000:1857		    pop	    bx
seg000:1858		    jnb	    short _$P_Return_to_Caller
seg000:185A		    inc	    bx
seg000:185B		    inc	    bx
seg000:185C		    loop    _$P_Key_Mgr_Loop
seg000:185E
seg000:185E _$P_Key_Not_Found:			    ; CODE XREF: SysParse+146j
seg000:185E		    mov	    cs:_$P_RC, 4
seg000:1865
seg000:1865 _$P_Return_to_Caller:		    ; CODE XREF: SysParse+F3j
seg000:1865					    ; SysParse+FCj ...
seg000:1865		    pop	    bp
seg000:1866		    pop	    di
seg000:1867		    pop	    bx
seg000:1868		    mov	    cx,	cs:_$P_ORDINAL
seg000:186D		    mov	    ax,	cs:_$P_RC
seg000:1871		    mov	    si,	cs:_$P_SI_Save
seg000:1876		    mov	    dx,	cs:_$P_DX
seg000:187B		    mov	    bl,	cs:_$P_Terminator
seg000:1880
seg000:1880 _$P_Single_Exit:			    ; CODE XREF: SysParse+53j
seg000:1880		    clc
seg000:1881		    retn
seg000:1881 SysParse	    endp
seg000:1881
seg000:1882
seg000:1882 ; =============== S	U B R O	U T I N	E =======================================
seg000:1882
seg000:1882
seg000:1882 _$P_Chk_Pos_Control	proc near	    ; CODE XREF: SysParse+F0p
seg000:1882		    push    ax
seg000:1883		    mov	    ax,	es:[bx]
seg000:1886		    test    ax,	2
seg000:1889		    jnz	    short _$P_CPC00
seg000:188B		    inc	    cs:_$P_ORDINAL
seg000:1890
seg000:1890 _$P_CPC00:				    ; CODE XREF: _$P_Chk_Pos_Control+7j
seg000:1890		    cmp	    byte ptr cs:[si], 0
seg000:1894		    jnz	    short _$P_CPC01
seg000:1896		    test    ax,	1
seg000:1899		    jnz	    short _$P_CPC02
seg000:189B		    mov	    cs:_$P_RC, 2
seg000:18A2		    jmp	    short _$P_CPC_Exit
seg000:18A4 ; ---------------------------------------------------------------------------
seg000:18A4
seg000:18A4 _$P_CPC02:				    ; CODE XREF: _$P_Chk_Pos_Control+17j
seg000:18A4		    push    ax
seg000:18A5		    mov	    al,	3
seg000:18A7		    mov	    ah,	0FFh
seg000:18A9		    call    _$P_Fill_Result
seg000:18AC		    pop	    ax
seg000:18AD		    jmp	    short _$P_CPC_Exit
seg000:18AF ; ---------------------------------------------------------------------------
seg000:18AF
seg000:18AF _$P_CPC01:				    ; CODE XREF: _$P_Chk_Pos_Control+12j
seg000:18AF		    call    _$P_Check_Match_Flags
seg000:18B2
seg000:18B2 _$P_CPC_Exit:			    ; CODE XREF: _$P_Chk_Pos_Control+20j
seg000:18B2					    ; _$P_Chk_Pos_Control+2Bj
seg000:18B2		    pop	    ax
seg000:18B3		    retn
seg000:18B3 _$P_Chk_Pos_Control	endp
seg000:18B3
seg000:18B4
seg000:18B4 ; =============== S	U B R O	U T I N	E =======================================
seg000:18B4
seg000:18B4
seg000:18B4 _$P_Chk_Key_Control	proc near	    ; CODE XREF: SysParse+14Dp
seg000:18B4		    stc
seg000:18B5		    retn
seg000:18B5 _$P_Chk_Key_Control	endp
seg000:18B5
seg000:18B6
seg000:18B6 ; =============== S	U B R O	U T I N	E =======================================
seg000:18B6
seg000:18B6
seg000:18B6 _$P_Search_KEYorSW proc near	    ; CODE XREF: _$P_Chk_SW_Control+6p
seg000:18B6		    push    bp
seg000:18B7		    push    cx
seg000:18B8		    mov	    cl,	es:[bx+8]   ; [es:bx+_$P_Control_Blk.nid]
seg000:18BC		    xor	    ch,	ch
seg000:18BE		    or	    cx,	cx
seg000:18C0		    jz	    short _$P_KEYorSW_Not_Found
seg000:18C2		    lea	    bp,	[bx+9]	    ; [es:bx+_$P_Control_Blk.KEYorSW]
seg000:18C5
seg000:18C5 _$P_KEYorSW_Loop:			    ; CODE XREF: _$P_Search_KEYorSW+17j
seg000:18C5		    call    _$P_String_Comp
seg000:18C8		    jnb	    short _$P_KEYorSW_Found
seg000:18CA		    call    _$P_MoveBP_NUL
seg000:18CD		    loop    _$P_KEYorSW_Loop
seg000:18CF
seg000:18CF _$P_KEYorSW_Not_Found:		    ; CODE XREF: _$P_Search_KEYorSW+Aj
seg000:18CF		    stc
seg000:18D0		    jmp	    short _$P_KEYorSW_Exit
seg000:18D2 ; ---------------------------------------------------------------------------
seg000:18D2
seg000:18D2 _$P_KEYorSW_Found:			    ; CODE XREF: _$P_Search_KEYorSW+12j
seg000:18D2		    mov	    cs:_$P_Found_SYNONYM, bp
seg000:18D7		    clc
seg000:18D8
seg000:18D8 _$P_KEYorSW_Exit:			    ; CODE XREF: _$P_Search_KEYorSW+1Aj
seg000:18D8		    pop	    cx
seg000:18D9		    pop	    bp
seg000:18DA		    retn
seg000:18DA _$P_Search_KEYorSW endp
seg000:18DA
seg000:18DB
seg000:18DB ; =============== S	U B R O	U T I N	E =======================================
seg000:18DB
seg000:18DB
seg000:18DB _$P_MoveBP_NUL  proc near		    ; CODE XREF: _$P_Search_KEYorSW+14p
seg000:18DB					    ; _$P_MoveBP_NUL+8j
seg000:18DB		    cmp	    byte ptr es:[bp+0],	0
seg000:18E0		    jz	    short _$P_MBP_Exit
seg000:18E2		    inc	    bp
seg000:18E3		    jmp	    short _$P_MoveBP_NUL ; _$P_MBP_Loop
seg000:18E5 ; ---------------------------------------------------------------------------
seg000:18E5
seg000:18E5 _$P_MBP_Exit:			    ; CODE XREF: _$P_MoveBP_NUL+5j
seg000:18E5		    inc	    bp
seg000:18E6		    retn
seg000:18E6 _$P_MoveBP_NUL  endp
seg000:18E6
seg000:18E7
seg000:18E7 ; =============== S	U B R O	U T I N	E =======================================
seg000:18E7
seg000:18E7
seg000:18E7 _$P_Chk_SW_Control proc near	    ; CODE XREF: SysParse+117p
seg000:18E7		    or	    byte ptr cs:_$P_Flags+1, 10h
seg000:18ED		    call    _$P_Search_KEYorSW
seg000:18F0		    jb	    short _$P_Chk_SW_Err0
seg000:18F2		    and	    byte ptr cs:_$P_Flags+1, 0EFh
seg000:18F8		    push    ax
seg000:18F9		    mov	    ax,	cs:_$P_KEYorSW_Ptr
seg000:18FD		    sub	    ax,	si
seg000:18FF		    add	    cs:_$P_SaveSI_Cmpx,	ax
seg000:1904		    pop	    ax
seg000:1905		    mov	    si,	cs:_$P_KEYorSW_Ptr
seg000:190A		    cmp	    byte ptr cs:[si], 0
seg000:190E		    jnz	    short _$P_CSW00
seg000:1910		    cmp	    byte ptr cs:[si-1],	3Ah ; ':'
seg000:1915		    jnz	    short _$P_Chk_if_data_required
seg000:1917		    mov	    cs:_$P_RC, 9
seg000:191E		    jmp	    short _$P_Chk_SW_Exit
seg000:1920 ; ---------------------------------------------------------------------------
seg000:1920
seg000:1920 _$P_Chk_if_data_required:		    ; CODE XREF: _$P_Chk_SW_Control+2Ej
seg000:1920		    cmp	    word ptr es:[bx], 0
seg000:1924		    jz	    short _$P_Chk_SW_Exit
seg000:1926		    test    word ptr es:[bx], 1
seg000:192B		    jnz	    short _$P_Chk_SW_Exit
seg000:192D		    mov	    cs:_$P_RC, 2
seg000:1934		    jmp	    short _$P_Chk_SW_Exit
seg000:1936 ; ---------------------------------------------------------------------------
seg000:1936
seg000:1936 _$P_CSW00:				    ; CODE XREF: _$P_Chk_SW_Control+27j
seg000:1936		    call    _$P_Check_Match_Flags
seg000:1939		    clc
seg000:193A		    jmp	    short _$P_Chk_SW_Single_Exit
seg000:193C ; ---------------------------------------------------------------------------
seg000:193C
seg000:193C _$P_Chk_SW_Err0:			    ; CODE XREF: _$P_Chk_SW_Control+9j
seg000:193C		    stc
seg000:193D		    jmp	    short _$P_Chk_SW_Single_Exit
seg000:193F ; ---------------------------------------------------------------------------
seg000:193F
seg000:193F _$P_Chk_SW_Exit:			    ; CODE XREF: _$P_Chk_SW_Control+37j
seg000:193F					    ; _$P_Chk_SW_Control+3Dj ...
seg000:193F		    push    ax
seg000:1940		    mov	    al,	3
seg000:1942		    mov	    ah,	0FFh
seg000:1944		    call    _$P_Fill_Result
seg000:1947		    pop	    ax
seg000:1948		    clc
seg000:1949
seg000:1949 _$P_Chk_SW_Single_Exit:		    ; CODE XREF: _$P_Chk_SW_Control+53j
seg000:1949					    ; _$P_Chk_SW_Control+56j
seg000:1949		    retn
seg000:1949 _$P_Chk_SW_Control endp
seg000:1949
seg000:194A
seg000:194A ; =============== S	U B R O	U T I N	E =======================================
seg000:194A
seg000:194A
seg000:194A _$P_Fill_Result proc near		    ; CODE XREF: _$P_Chk_Pos_Control+27p
seg000:194A					    ; _$P_Chk_SW_Control+5Dp ...
seg000:194A		    push    di
seg000:194B		    mov	    di,	es:[bx+4]   ; [es:bx+_$P_Control_Blk.Result_Buf]
seg000:194F		    mov	    cs:_$P_DX, di
seg000:1954		    mov	    es:[di], al	    ; es:di+_$P_Result_Blk.Type]
seg000:1957		    mov	    es:[di+1], ah   ; [es:di+_$P_Result_Blk.Item_Tag]
seg000:195B		    push    ax
seg000:195C		    mov	    ax,	cs:_$P_Found_SYNONYM
seg000:1960		    mov	    es:[di+2], ax   ; [es:di+_$P_Result_Blk.SYNONYM_Ptr]
seg000:1964		    pop	    ax
seg000:1965
seg000:1965 _$P_RLT04:				    ; _$P_Number
seg000:1965		    cmp	    al,	1
seg000:1967		    jnz	    short _$P_RLT00
seg000:1969
seg000:1969 _$P_RLT02:				    ; CODE XREF: _$P_Fill_Result+35j
seg000:1969					    ; _$P_Fill_Result+39j
seg000:1969		    mov	    es:[di+4], dx   ; [es:di+_$P_Result_Blk.Picked_Val]
seg000:196D		    mov	    es:[di+6], cx   ; [es:di+_$P_Result_Blk.Picked_Val+2]
seg000:1971		    jmp	    short _$P_RLT_Exit
seg000:1973 ; ---------------------------------------------------------------------------
seg000:1973
seg000:1973 _$P_RLT00:				    ; CODE XREF: _$P_Fill_Result+1Dj
seg000:1973		    cmp	    al,	2	    ; _$P_List_Idx
seg000:1975		    jnz	    short _$P_RLT01
seg000:1977		    mov	    es:[di+4], dx
seg000:197B		    jmp	    short _$P_RLT_Exit
seg000:197D ; ---------------------------------------------------------------------------
seg000:197D
seg000:197D _$P_RLT01:				    ; CODE XREF: _$P_Fill_Result+2Bj
seg000:197D		    cmp	    al,	7	    ; _$P_Date_F
seg000:197F		    jz	    short _$P_RLT02
seg000:1981		    cmp	    al,	8	    ; _$P_Time_F
seg000:1983		    jz	    short _$P_RLT02
seg000:1985		    cmp	    al,	6	    ; _$P_Drive
seg000:1987		    jnz	    short _$P_RLT03
seg000:1989		    mov	    es:[di+4], dl   ; [es:di+_$P_Result_Blk.Picked_Val]
seg000:198D		    jmp	    short _$P_RLT_Exit
seg000:198F ; ---------------------------------------------------------------------------
seg000:198F
seg000:198F _$P_RLT03:				    ; CODE XREF: _$P_Fill_Result+3Dj
seg000:198F		    cmp	    al,	4	    ; _$P_Complex
seg000:1991		    jnz	    short _$P_RLT05
seg000:1993		    mov	    ax,	cs:_$P_SaveSI_Cmpx
seg000:1997		    inc	    ax
seg000:1998		    mov	    es:[di+4], ax
seg000:199C		    mov	    word ptr es:[di+6],	ds
seg000:19A0		    jmp	    short _$P_RLT_Exit
seg000:19A2 ; ---------------------------------------------------------------------------
seg000:19A2
seg000:19A2 _$P_RLT05:				    ; CODE XREF: _$P_Fill_Result+47j
seg000:19A2		    mov	    es:[di+4], si   ; [es:di+_$P_Result_Blk.Picked_Val]
seg000:19A6		    mov	    word ptr es:[di+6],	cs ; [es:di+_$P_Result_Blk.Picked_Val+2]
seg000:19AA		    push    ax
seg000:19AB		    test    byte ptr es:[bx+2],	1 ; [es:bx+_$P_Control_Blk.Function_Flag]
seg000:19B0		    jz	    short _$P_RLT_CAP00
seg000:19B2		    mov	    al,	4	    ; _$P_DOSTBL_File
seg000:19B4		    jmp	    short _$P_RLT_CAP02
seg000:19B6 ; ---------------------------------------------------------------------------
seg000:19B6
seg000:19B6 _$P_RLT_CAP00:			    ; CODE XREF: _$P_Fill_Result+66j
seg000:19B6		    test    byte ptr es:[bx+2],	2 ; [es:bx+_$P_Control_Blk.Function_Flag]
seg000:19BB		    jz	    short $P_RLT_CAP01
seg000:19BD		    mov	    al,	2	    ; _$P_DOSTBL_Char
seg000:19BF
seg000:19BF _$P_RLT_CAP02:			    ; CODE XREF: _$P_Fill_Result+6Aj
seg000:19BF		    call    _$P_Do_CAPS_String
seg000:19C2
seg000:19C2 $P_RLT_CAP01:			    ; CODE XREF: _$P_Fill_Result+71j
seg000:19C2		    pop	    ax
seg000:19C3		    test    byte ptr es:[bx+2],	10h ; [es:bx+_$P_Control_Blk.Function_Flag]
seg000:19C8		    jz	    short _$P_RLT_Exit
seg000:19CA		    call    _$P_Remove_Colon
seg000:19CD
seg000:19CD _$P_RLT_Exit:			    ; CODE XREF: _$P_Fill_Result+27j
seg000:19CD					    ; _$P_Fill_Result+31j ...
seg000:19CD		    pop	    di
seg000:19CE		    retn
seg000:19CE _$P_Fill_Result endp
seg000:19CE
seg000:19CF
seg000:19CF ; =============== S	U B R O	U T I N	E =======================================
seg000:19CF
seg000:19CF
seg000:19CF _$P_Check_Match_Flags proc near	    ; CODE XREF: _$P_Chk_Pos_Control:_$P_CPC01p
seg000:19CF					    ; _$P_Chk_SW_Control:_$P_CSW00p
seg000:19CF		    mov	    cs:_$P_err_flag, 0 ; _$P_NULL
seg000:19D5		    push    ax
seg000:19D6		    mov	    ax,	es:[bx]	    ; [es:bx+_$P_Control_Blk.Match_Flag]
seg000:19D9		    or	    ax,	ax
seg000:19DB		    jnz	    short _$P_Mat
seg000:19DD		    push    ax
seg000:19DE		    push    bx
seg000:19DF		    push    dx
seg000:19E0		    push    di
seg000:19E1		    mov	    cs:_$P_RC, 9    ; _$P_Syntax
seg000:19E8		    mov	    ah,	0FFh	    ; _$P_No_Tag
seg000:19EA		    mov	    al,	3	    ; _$P_String
seg000:19EC		    call    _$P_Fill_Result
seg000:19EF		    pop	    di
seg000:19F0		    pop	    dx
seg000:19F1		    pop	    bx
seg000:19F2		    pop	    ax
seg000:19F3		    jmp	    short _$P_Bridge
seg000:19F5 ; ---------------------------------------------------------------------------
seg000:19F5
seg000:19F5 _$P_Mat:				    ; CODE XREF: _$P_Check_Match_Flags+Cj
seg000:19F5		    jmp	    short _$P_Match03
seg000:19F7 ; ---------------------------------------------------------------------------
seg000:19F7
seg000:19F7 _$P_Bridge:				    ; CODE XREF: _$P_Check_Match_Flags+24j
seg000:19F7		    jmp	    short _$P_Match_Exit
seg000:19F7 ; ---------------------------------------------------------------------------
seg000:19F9		    db	90h ; 
seg000:19FA ; ---------------------------------------------------------------------------
seg000:19FA
seg000:19FA _$P_Match03:			    ; CODE XREF: _$P_Check_Match_Flags:_$P_Matj
seg000:19FA		    test    ax,	8000h	    ; _$P_Num_Val
seg000:19FD		    jz	    short _$P_Match04
seg000:19FF		    mov	    cs:_$P_RC, 0    ; _$P_No_Error
seg000:1A06		    call    _$P_Value
seg000:1A09		    cmp	    cs:_$P_RC, 9    ; _$P_Syntax
seg000:1A0F		    jnz	    short _$P_Match_Exit
seg000:1A11
seg000:1A11 _$P_Match04:			    ; CODE XREF: _$P_Check_Match_Flags+2Ej
seg000:1A11		    test    ax,	4000h	    ; _$P_SNum_Val
seg000:1A14		    jz	    short _$P_Match05
seg000:1A16		    mov	    cs:_$P_RC, 0
seg000:1A1D		    call    _$P_SValue
seg000:1A20		    cmp	    cs:_$P_RC, 9
seg000:1A26		    jnz	    short _$P_Match_Exit
seg000:1A28
seg000:1A28 _$P_Match05:			    ; CODE XREF: _$P_Check_Match_Flags+45j
seg000:1A28		    test    ax,	100h	    ; _$P_Drv_Only
seg000:1A2B		    jz	    short _$P_Match06
seg000:1A2D		    mov	    cs:_$P_RC, 0
seg000:1A34		    call    _$P_File_Format
seg000:1A37		    call    _$P_Drive_Format
seg000:1A3A		    cmp	    cs:_$P_RC, 9
seg000:1A40		    jnz	    short _$P_Match_Exit
seg000:1A42
seg000:1A42 _$P_Match06:			    ; CODE XREF: _$P_Check_Match_Flags+5Cj
seg000:1A42		    test    ax,	200h	    ; _$P_File_Spc
seg000:1A45		    jz	    short _$P_Match07
seg000:1A47		    mov	    cs:_$P_RC, 0
seg000:1A4E		    call    _$P_File_Format
seg000:1A51		    cmp	    cs:_$P_RC, 9
seg000:1A57		    jnz	    short _$P_Match_Exit
seg000:1A59
seg000:1A59 _$P_Match07:			    ; CODE XREF: _$P_Check_Match_Flags+76j
seg000:1A59		    test    ax,	2000h	    ; _$P_Simple_S
seg000:1A5C		    jz	    short _$P_Match_Exit
seg000:1A5E		    mov	    cs:_$P_RC, 0
seg000:1A65		    call    _$P_Simple_String
seg000:1A68
seg000:1A68 _$P_Match_Exit:			    ; CODE XREF: _$P_Check_Match_Flags:_$P_Bridgej
seg000:1A68					    ; _$P_Check_Match_Flags+40j ...
seg000:1A68		    cmp	    cs:_$P_err_flag, 1 ; _$P_error_filespec
seg000:1A6E		    jnz	    short _$P_Match2_Exit
seg000:1A70		    cmp	    cs:_$P_RC, 0
seg000:1A76		    jnz	    short _$P_Match2_Exit
seg000:1A78		    mov	    cs:_$P_RC, 9
seg000:1A7F
seg000:1A7F _$P_Match2_Exit:			    ; CODE XREF: _$P_Check_Match_Flags+9Fj
seg000:1A7F					    ; _$P_Check_Match_Flags+A7j
seg000:1A7F		    pop	    ax
seg000:1A80		    retn
seg000:1A80 _$P_Check_Match_Flags endp
seg000:1A80
seg000:1A81
seg000:1A81 ; =============== S	U B R O	U T I N	E =======================================
seg000:1A81
seg000:1A81
seg000:1A81 _$P_Remove_Colon proc near		    ; CODE XREF: _$P_Fill_Result+80p
seg000:1A81		    push    ax
seg000:1A82		    push    si
seg000:1A83
seg000:1A83 _$P_RCOL_Loop:			    ; CODE XREF: _$P_Remove_Colon+21j
seg000:1A83		    mov	    al,	cs:[si]
seg000:1A86		    or	    al,	al
seg000:1A88		    jz	    short _$P_RCOL_Exit
seg000:1A8A		    cmp	    al,	3Ah ; ':'   ; _$P_Colon
seg000:1A8C		    jnz	    short _$P_RCOL00
seg000:1A8E		    cmp	    byte ptr cs:[si+1],	0 ; _$P_NULL
seg000:1A93		    jnz	    short _$P_RCOL00
seg000:1A95		    mov	    byte ptr cs:[si], 0
seg000:1A99		    jmp	    short _$P_RCOL_Exit
seg000:1A9B ; ---------------------------------------------------------------------------
seg000:1A9B
seg000:1A9B _$P_RCOL00:				    ; CODE XREF: _$P_Remove_Colon+Bj
seg000:1A9B					    ; _$P_Remove_Colon+12j
seg000:1A9B		    call    _$P_Chk_DBCS
seg000:1A9E		    jnb	    short _$P_RCOL01
seg000:1AA0		    inc	    si
seg000:1AA1
seg000:1AA1 _$P_RCOL01:				    ; CODE XREF: _$P_Remove_Colon+1Dj
seg000:1AA1		    inc	    si
seg000:1AA2		    jmp	    short _$P_RCOL_Loop
seg000:1AA4 ; ---------------------------------------------------------------------------
seg000:1AA4
seg000:1AA4 _$P_RCOL_Exit:			    ; CODE XREF: _$P_Remove_Colon+7j
seg000:1AA4					    ; _$P_Remove_Colon+18j
seg000:1AA4		    pop	    si
seg000:1AA5		    pop	    ax
seg000:1AA6		    retn
seg000:1AA6 _$P_Remove_Colon endp
seg000:1AA6
seg000:1AA7
seg000:1AA7 ; =============== S	U B R O	U T I N	E =======================================
seg000:1AA7
seg000:1AA7
seg000:1AA7 _$P_Do_CAPS_String proc near	    ; CODE XREF: _$P_Fill_Result:_$P_RLT_CAP02p
seg000:1AA7		    push    si
seg000:1AA8		    push    dx
seg000:1AA9		    mov	    dl,	al
seg000:1AAB
seg000:1AAB _$P_DCS_Loop:			    ; CODE XREF: _$P_Do_CAPS_String+1Aj
seg000:1AAB		    mov	    al,	cs:[si]
seg000:1AAE		    call    _$P_Chk_DBCS
seg000:1AB1		    jb	    short _$P_DCS00
seg000:1AB3		    or	    al,	al
seg000:1AB5		    jz	    short _$P_DCS_Exit
seg000:1AB7		    call    _$P_Do_CAPS_Char
seg000:1ABA		    mov	    cs:[si], al
seg000:1ABD		    jmp	    short _$P_DCS01
seg000:1ABF ; ---------------------------------------------------------------------------
seg000:1ABF
seg000:1ABF _$P_DCS00:				    ; CODE XREF: _$P_Do_CAPS_String+Aj
seg000:1ABF		    inc	    si
seg000:1AC0
seg000:1AC0 _$P_DCS01:				    ; CODE XREF: _$P_Do_CAPS_String+16j
seg000:1AC0		    inc	    si
seg000:1AC1		    jmp	    short _$P_DCS_Loop
seg000:1AC3 ; ---------------------------------------------------------------------------
seg000:1AC3
seg000:1AC3 _$P_DCS_Exit:			    ; CODE XREF: _$P_Do_CAPS_String+Ej
seg000:1AC3		    pop	    dx
seg000:1AC4		    pop	    si
seg000:1AC5		    retn
seg000:1AC5 _$P_Do_CAPS_String endp
seg000:1AC5
seg000:1AC6
seg000:1AC6 ; =============== S	U B R O	U T I N	E =======================================
seg000:1AC6
seg000:1AC6
seg000:1AC6 _$P_Do_CAPS_Char proc near		    ; CODE XREF: _$P_Do_CAPS_String+10p
seg000:1AC6					    ; _$P_String_Comp+Ep
seg000:1AC6		    cmp	    al,	80h	    ; _$P_ASCII80
seg000:1AC8		    jnb	    short _$P_DCC_Go
seg000:1ACA		    cmp	    al,	'a'
seg000:1ACC		    jb	    short _$P_CAPS_Ret
seg000:1ACE		    cmp	    al,	'z'
seg000:1AD0		    ja	    short _$P_CAPS_Ret
seg000:1AD2		    and	    al,	0DFh	    ; _$P_Make_Upper
seg000:1AD4		    jmp	    short _$P_CAPS_Ret
seg000:1AD6 ; ---------------------------------------------------------------------------
seg000:1AD6
seg000:1AD6 _$P_DCC_Go:				    ; CODE XREF: _$P_Do_CAPS_Char+2j
seg000:1AD6		    push    bx
seg000:1AD7		    push    es
seg000:1AD8		    push    di
seg000:1AD9		    lea	    di,	_$P_Char_CAP_Ptr
seg000:1ADD		    cmp	    cs:[di], dl
seg000:1AE0		    jz	    short _$P_DCC01
seg000:1AE2		    push    ax
seg000:1AE3		    push    cx
seg000:1AE4		    push    dx
seg000:1AE5		    push    cs
seg000:1AE6		    pop	    es
seg000:1AE7		    mov	    ah,	65h	    ; _$P_DOS_Get_TBL
seg000:1AE9		    mov	    al,	dl
seg000:1AEB		    mov	    bx,	0FFFFh	    ; _$P_DOSTBL_Def
seg000:1AEE		    mov	    cx,	5	    ; _$P_DOSTBL_BL
seg000:1AF1		    mov	    dx,	0FFFFh
seg000:1AF4		    int	    21h		    ; DOS - 4.x	internal - COUNTRY-DEPENDENT FILENAME CAPITALIZATION
seg000:1AF4					    ; AL = function -
seg000:1AF6		    pop	    dx
seg000:1AF7		    pop	    cx
seg000:1AF8		    pop	    ax
seg000:1AF9
seg000:1AF9 _$P_DCC01:				    ; CODE XREF: _$P_Do_CAPS_Char+1Aj
seg000:1AF9		    mov	    bx,	cs:[di+1]   ; [cs:di+_$P_DOS_TBL.Off]
seg000:1AFD		    mov	    es,	word ptr cs:[di+3] ; [cs:di+_$P_DOS_TBL.Seg]
seg000:1B01		    inc	    bx
seg000:1B02		    inc	    bx
seg000:1B03		    sub	    al,	80h	    ; _$P_ASCII80
seg000:1B05		    xlat    byte ptr es:[bx]
seg000:1B07		    pop	    di
seg000:1B08		    pop	    es
seg000:1B09		    pop	    bx
seg000:1B0A
seg000:1B0A _$P_CAPS_Ret:			    ; CODE XREF: _$P_Do_CAPS_Char+6j
seg000:1B0A					    ; _$P_Do_CAPS_Char+Aj ...
seg000:1B0A		    retn
seg000:1B0A _$P_Do_CAPS_Char endp
seg000:1B0A
seg000:1B0B
seg000:1B0B ; =============== S	U B R O	U T I N	E =======================================
seg000:1B0B
seg000:1B0B
seg000:1B0B _$P_SValue	    proc near		    ; CODE XREF: _$P_Check_Match_Flags+4Ep
seg000:1B0B		    push    ax
seg000:1B0C		    or	    byte ptr cs:_$P_Flags+1, 80h ; _$P_Signed
seg000:1B12		    and	    byte ptr cs:_$P_Flags+1, 0FDh ; 0FFh-_$P_Neg
seg000:1B18		    mov	    al,	cs:[si]
seg000:1B1B		    cmp	    al,	'+'         ; _$P_Plus
seg000:1B1D		    jz	    short _$P_SVal00
seg000:1B1F		    cmp	    al,	'-'         ; _$P_Minus
seg000:1B21		    jnz	    short _$P_Sval01
seg000:1B23		    or	    byte ptr cs:_$P_Flags+1, 2 ; [cs:_$P_Flags2],
seg000:1B23					    ; _$P_Neg
seg000:1B29
seg000:1B29 _$P_SVal00:				    ; CODE XREF: _$P_SValue+12j
seg000:1B29		    inc	    si
seg000:1B2A
seg000:1B2A _$P_Sval01:				    ; CODE XREF: _$P_SValue+16j
seg000:1B2A		    call    _$P_Value
seg000:1B2D		    pop	    ax
seg000:1B2E		    retn
seg000:1B2E _$P_SValue	    endp
seg000:1B2E
seg000:1B2F
seg000:1B2F ; =============== S	U B R O	U T I N	E =======================================
seg000:1B2F
seg000:1B2F
seg000:1B2F _$P_Value	    proc near		    ; CODE XREF: _$P_Check_Match_Flags+37p
seg000:1B2F					    ; _$P_SValue:_$P_Sval01p
seg000:1B2F		    push    ax
seg000:1B30		    push    cx
seg000:1B31		    push    dx
seg000:1B32		    push    si
seg000:1B33		    xor	    cx,	cx	    ;  cx = higher 16 bits
seg000:1B35		    xor	    dx,	dx	    ; dx = lower 16 bits
seg000:1B37		    push    bx
seg000:1B38
seg000:1B38 _$P_Value_Loop:			    ; CODE XREF: _$P_Value+4Cj
seg000:1B38		    mov	    al,	cs:[si]	    ; get (numeric) character
seg000:1B3B		    or	    al,	al	    ; end of line ?
seg000:1B3D		    jz	    short _$P_Value00
seg000:1B3F		    call    _$P_0099	    ; make asc(0..9) to	bin(0..9)
seg000:1B42		    jb	    short _$P_Value_Err0
seg000:1B44		    xor	    ah,	ah
seg000:1B46		    mov	    bp,	ax	    ; save binary number
seg000:1B48		    shl	    dx,	1	    ; 2*x
seg000:1B4A		    rcl	    cx,	1
seg000:1B4C		    call    _$P_Check_OVF   ; Overflow occurred	?
seg000:1B4F		    jb	    short _$P_Value_Err0 ; then	error, exit
seg000:1B51		    mov	    bx,	dx
seg000:1B53		    mov	    ax,	cx
seg000:1B55		    shl	    dx,	1	    ; 4*x
seg000:1B57		    rcl	    cx,	1
seg000:1B59		    call    _$P_Check_OVF
seg000:1B5C		    jb	    short _$P_Value_Err0
seg000:1B5E		    shl	    dx,	1	    ; 8*x
seg000:1B60		    rcl	    cx,	1
seg000:1B62		    call    _$P_Check_OVF
seg000:1B65		    jb	    short _$P_Value_Err0
seg000:1B67		    add	    dx,	bx	    ; 10*x
seg000:1B69		    adc	    cx,	ax
seg000:1B6B		    call    _$P_Check_OVF
seg000:1B6E		    jb	    short _$P_Value_Err0
seg000:1B70		    add	    dx,	bp	    ; Add the current one degree decimal
seg000:1B72		    adc	    cx,	0
seg000:1B75		    call    _$P_Check_OVF
seg000:1B78		    jb	    short _$P_Value_Err0
seg000:1B7A		    inc	    si
seg000:1B7B		    jmp	    short _$P_Value_Loop
seg000:1B7D ; ---------------------------------------------------------------------------
seg000:1B7D
seg000:1B7D _$P_Value_Err0:			    ; CODE XREF: _$P_Value+13j
seg000:1B7D					    ; _$P_Value+20j ...
seg000:1B7D		    pop	    bx
seg000:1B7E		    jmp	    _$P_Value_Err
seg000:1B81 ; ---------------------------------------------------------------------------
seg000:1B81
seg000:1B81 _$P_Value00:			    ; CODE XREF: _$P_Value+Ej
seg000:1B81		    pop	    bx
seg000:1B82		    test    byte ptr cs:_$P_Flags+1, 2 ; _$P_Neg
seg000:1B88		    jz	    short _$P_Value01 ;	was it negative	?
seg000:1B8A		    not	    cx		    ; Make 2's complement
seg000:1B8C		    not	    dx
seg000:1B8E		    add	    dx,	1
seg000:1B91		    adc	    cx,	0
seg000:1B94
seg000:1B94 _$P_Value01:			    ; CODE XREF: _$P_Value+59j
seg000:1B94		    mov	    si,	es:[bx+6]   ; [es:bx+_$P_Control_Blk.Value_List]
seg000:1B98		    mov	    al,	es:[si]
seg000:1B9B		    cmp	    al,	0	    ; _$P_nval_None
seg000:1B9D		    jnz	    short _$P_Value02
seg000:1B9F		    mov	    al,	1	    ; _$P_Number
seg000:1BA1		    mov	    ah,	0FFh	    ; _$P_No_Tag
seg000:1BA3		    jmp	    short _$P_Value_Exit
seg000:1BA5 ; ---------------------------------------------------------------------------
seg000:1BA5		    nop
seg000:1BA6
seg000:1BA6 _$P_Value02:			    ; CODE XREF: _$P_Value+6Ej
seg000:1BA6		    inc	    si
seg000:1BA7		    mov	    al,	es:[si]
seg000:1BAA		    cmp	    al,	0	    ; _$P_No_nrng
seg000:1BAC		    jz	    short _$P_Value_Err
seg000:1BAE		    inc	    si
seg000:1BAF
seg000:1BAF _$P_Val02_Loop:			    ; CODE XREF: _$P_Value+C9j
seg000:1BAF		    test    byte ptr cs:_$P_Flags+1, 80h ; _$P_Signed
seg000:1BB5		    jnz	    short _$P_Val02_Sign
seg000:1BB7		    cmp	    cx,	es:[si+3]   ; [es:si+_$P_Val_List.Val_XH]
seg000:1BBB		    jb	    short _$P_Val02_Next
seg000:1BBD		    ja	    short _$P_Val_In
seg000:1BBF		    cmp	    dx,	es:[si+1]   ; [es:si+_$P_Val_List.Val_XL]
seg000:1BC3		    jb	    short _$P_Val02_Next
seg000:1BC5
seg000:1BC5 _$P_Val_In:				    ; CODE XREF: _$P_Value+8Ej
seg000:1BC5		    cmp	    cx,	es:[si+7]   ; [es:si+_$P_Val_List.Val_YH]
seg000:1BC9		    ja	    short _$P_Val02_Next
seg000:1BCB		    jb	    short _$P_Val_Found
seg000:1BCD		    cmp	    dx,	es:[si+5]   ; [es:si+_$P_Val_List.Val_YL]
seg000:1BD1		    ja	    short _$P_Val02_Next
seg000:1BD3		    jmp	    short _$P_Val_Found
seg000:1BD5 ; ---------------------------------------------------------------------------
seg000:1BD5
seg000:1BD5 _$P_Val02_Sign:			    ; CODE XREF: _$P_Value+86j
seg000:1BD5		    cmp	    cx,	es:[si+3]   ; [es:si+_$P_Val_List.Val_XH]
seg000:1BD9		    jl	    short _$P_Val02_Next
seg000:1BDB		    jg	    short _$P_SVal_In
seg000:1BDD		    cmp	    dx,	es:[si+1]   ; [es:si+_$P_Val_List.Val_XL]
seg000:1BE1		    jl	    short _$P_Val02_Next
seg000:1BE3
seg000:1BE3 _$P_SVal_In:			    ; CODE XREF: _$P_Value+ACj
seg000:1BE3		    cmp	    cx,	es:[si+7]   ; [es:si+_$P_Val_List.Val_YH]
seg000:1BE7		    jg	    short _$P_Val02_Next
seg000:1BE9		    jl	    short _$P_Val_Found
seg000:1BEB		    cmp	    dx,	es:[si+5]   ; [es:si+_$P_Val_List.Val_YL]
seg000:1BEF		    jg	    short _$P_Val02_Next
seg000:1BF1		    jmp	    short _$P_Val_Found
seg000:1BF3 ; ---------------------------------------------------------------------------
seg000:1BF3
seg000:1BF3 _$P_Val02_Next:			    ; CODE XREF: _$P_Value+8Cj
seg000:1BF3					    ; _$P_Value+94j ...
seg000:1BF3		    add	    si,	9	    ; _$P_Len_Range
seg000:1BF6		    dec	    al
seg000:1BF8		    jnz	    short _$P_Val02_Loop
seg000:1BFA		    mov	    cs:_$P_RC, 6    ; _$P_Out_Of_Range
seg000:1C01		    mov	    al,	1	    ; _$P_Number
seg000:1C03		    mov	    ah,	0FFh	    ; _$P_No_Tag
seg000:1C05		    jmp	    short _$P_Value_Exit
seg000:1C07 ; ---------------------------------------------------------------------------
seg000:1C07
seg000:1C07 _$P_Val_Found:			    ; CODE XREF: _$P_Value+9Cj
seg000:1C07					    ; _$P_Value+A4j ...
seg000:1C07		    mov	    al,	1	    ; _$P_Number
seg000:1C09		    mov	    ah,	es:[si]	    ; found ITEM_TAG set
seg000:1C0C		    jmp	    short _$P_Value_Exit
seg000:1C0E ; ---------------------------------------------------------------------------
seg000:1C0E
seg000:1C0E _$P_Value_Err:			    ; CODE XREF: _$P_Value+4Fj
seg000:1C0E					    ; _$P_Value+7Dj
seg000:1C0E		    mov	    cs:_$P_RC, 9    ; _$P_Syntax
seg000:1C15		    mov	    al,	3	    ; _$P_String
seg000:1C17		    mov	    ah,	0FFh	    ; _$P_No_Tag
seg000:1C19
seg000:1C19 _$P_Value_Exit:			    ; CODE XREF: _$P_Value+74j
seg000:1C19					    ; _$P_Value+D6j ...
seg000:1C19		    call    _$P_Fill_Result
seg000:1C1C		    pop	    si
seg000:1C1D		    pop	    dx
seg000:1C1E		    pop	    cx
seg000:1C1F		    pop	    ax
seg000:1C20		    retn
seg000:1C20 _$P_Value	    endp
seg000:1C20
seg000:1C21
seg000:1C21 ; =============== S	U B R O	U T I N	E =======================================
seg000:1C21
seg000:1C21
seg000:1C21 _$P_Check_OVF   proc near		    ; CODE XREF: _$P_Value+1Dp
seg000:1C21					    ; _$P_Value+2Ap ...
seg000:1C21		    pushf
seg000:1C22		    test    byte ptr cs:_$P_Flags+1, 2 ; [cs:_$P_Flags2],
seg000:1C22					    ; _$P_Neg
seg000:1C28		    jnz	    short _$P_COVF
seg000:1C2A		    popf
seg000:1C2B		    retn
seg000:1C2C ; ---------------------------------------------------------------------------
seg000:1C2C
seg000:1C2C _$P_COVF:				    ; CODE XREF: _$P_Check_OVF+7j
seg000:1C2C		    popf
seg000:1C2D		    jo	    short _$P_COVF00
seg000:1C2F		    clc
seg000:1C30		    retn
seg000:1C31 ; ---------------------------------------------------------------------------
seg000:1C31
seg000:1C31 _$P_COVF00:				    ; CODE XREF: _$P_Check_OVF+Cj
seg000:1C31		    stc
seg000:1C32		    retn
seg000:1C32 _$P_Check_OVF   endp
seg000:1C32
seg000:1C33
seg000:1C33 ; =============== S	U B R O	U T I N	E =======================================
seg000:1C33
seg000:1C33
seg000:1C33 _$P_0099	    proc near		    ; CODE XREF: _$P_Value+10p
seg000:1C33		    cmp	    al,	'0'
seg000:1C35		    jb	    short _$P_0099Err
seg000:1C37		    cmp	    al,	'9'
seg000:1C39		    ja	    short _$P_0099Err
seg000:1C3B		    sub	    al,	'0'
seg000:1C3D		    clc
seg000:1C3E		    retn
seg000:1C3F ; ---------------------------------------------------------------------------
seg000:1C3F
seg000:1C3F _$P_0099Err:			    ; CODE XREF: _$P_0099+2j
seg000:1C3F					    ; _$P_0099+6j
seg000:1C3F		    stc
seg000:1C40		    retn
seg000:1C40 _$P_0099	    endp
seg000:1C40
seg000:1C41
seg000:1C41 ; =============== S	U B R O	U T I N	E =======================================
seg000:1C41
seg000:1C41
seg000:1C41 _$P_Simple_String proc near		    ; CODE XREF: _$P_Check_Match_Flags+96p
seg000:1C41		    push    ax
seg000:1C42		    push    bx
seg000:1C43		    push    dx
seg000:1C44		    push    di
seg000:1C45		    mov	    di,	es:[bx+6]   ; [es:bx+_$P_Control_Blk.Value_List]
seg000:1C49		    mov	    al,	es:[di]	    ; get nval
seg000:1C4C		    or	    al,	al	    ; no value list ?
seg000:1C4E		    jnz	    short _$P_Sim00 ; then
seg000:1C50		    mov	    ah,	0FFh	    ; _$P_No_Tag
seg000:1C52		    jmp	    short _$P_Sim_Exit
seg000:1C54 ; ---------------------------------------------------------------------------
seg000:1C54
seg000:1C54 _$P_Sim00:				    ; CODE XREF: _$P_Simple_String+Dj
seg000:1C54		    cmp	    al,	3	    ; _$P_nval_String
seg000:1C56		    jnz	    short _$P_Sim01 ; syntax error
seg000:1C58		    inc	    di
seg000:1C59		    mov	    al,	es:[di]	    ; al = nrng
seg000:1C5C		    mov	    ah,	9	    ; _$P_Len_Range
seg000:1C5E		    mul	    ah
seg000:1C60		    inc	    ax		    ; ax = (nrng*9)+1
seg000:1C61		    add	    di,	ax
seg000:1C63		    mov	    al,	es:[di]	    ; get nnval
seg000:1C66		    mov	    ah,	5	    ; _$P_Len_Value
seg000:1C68		    mul	    ah
seg000:1C6A		    inc	    ax
seg000:1C6B		    add	    di,	ax	    ; di points	to nstrval
seg000:1C6D		    mov	    al,	es:[di]	    ; get nstrval c
seg000:1C70		    inc	    di
seg000:1C71		    inc	    di		    ; di points	to 1st string in list
seg000:1C72
seg000:1C72 _$P_Sim_Loop:			    ; CODE XREF: _$P_Simple_String+3Ej
seg000:1C72		    mov	    bp,	es:[di]	    ; get string pointer
seg000:1C75		    call    _$P_String_Comp
seg000:1C78		    jnb	    short _$P_Sim_Found
seg000:1C7A		    add	    di,	3	    ; _$P_Len_String
seg000:1C7D		    dec	    al
seg000:1C7F		    jnz	    short _$P_Sim_Loop
seg000:1C81		    mov	    cs:_$P_RC, 8    ; _$P_Not_In_Str
seg000:1C88		    mov	    ah,	0FFh	    ; No ITEM_TAG set
seg000:1C8A		    jmp	    short _$P_Sim_Exit
seg000:1C8C ; ---------------------------------------------------------------------------
seg000:1C8C
seg000:1C8C _$P_Sim_Found:			    ; CODE XREF: _$P_Simple_String+37j
seg000:1C8C		    mov	    ah,	es:[di-1]   ; set item_tag
seg000:1C90		    mov	    al,	2	    ; _$P_List_Idx
seg000:1C92		    mov	    dx,	es:[di]	    ; get address of STRING
seg000:1C95		    jmp	    short _$P_Sim_Exit0
seg000:1C97 ; ---------------------------------------------------------------------------
seg000:1C97
seg000:1C97 _$P_Sim01:				    ; CODE XREF: _$P_Simple_String+15j
seg000:1C97		    mov	    cs:_$P_RC, 9    ; _$P_Syntax
seg000:1C9E		    mov	    ah,	0FFh	    ; _$P_No_Tag
seg000:1CA0
seg000:1CA0 _$P_Sim_Exit:			    ; CODE XREF: _$P_Simple_String+11j
seg000:1CA0					    ; _$P_Simple_String+49j
seg000:1CA0		    mov	    al,	3	    ; _$P_String
seg000:1CA2
seg000:1CA2 _$P_Sim_Exit0:			    ; CODE XREF: _$P_Simple_String+54j
seg000:1CA2		    call    _$P_Fill_Result
seg000:1CA5		    pop	    di
seg000:1CA6		    pop	    dx
seg000:1CA7		    pop	    bx
seg000:1CA8		    pop	    ax
seg000:1CA9		    retn
seg000:1CA9 _$P_Simple_String endp
seg000:1CA9
seg000:1CAA
seg000:1CAA ; =============== S	U B R O	U T I N	E =======================================
seg000:1CAA
seg000:1CAA
seg000:1CAA _$P_String_Comp proc near		    ; CODE XREF: _$P_Search_KEYorSW:_$P_KEYorSW_Loopp
seg000:1CAA					    ; _$P_Simple_String+34p
seg000:1CAA
seg000:1CAA arg_1AC4	    = word ptr	1AC6h
seg000:1CAA
seg000:1CAA		    push    ax
seg000:1CAB		    push    bp
seg000:1CAC		    push    dx
seg000:1CAD		    push    si
seg000:1CAE		    mov	    dl,	2	    ; $P_DOSTBL_Char
seg000:1CAE					    ; (use character case map table)
seg000:1CB0
seg000:1CB0 _$P_SCOM_Loop:			    ; CODE XREF: _$P_String_Comp:_$P_SCOM01j
seg000:1CB0		    mov	    al,	cs:[si]	    ; get command character
seg000:1CB3		    call    _$P_Chk_DBCS
seg000:1CB6		    jb	    short _$P_SCOM00
seg000:1CB8		    call    _$P_Do_CAPS_Char
seg000:1CBB		    test    byte ptr cs:_$P_Flags+1, 8 ; _$P_Key_Cmp
seg000:1CBB					    ; (keyword search ?)
seg000:1CC1		    jz	    short _$P_SCOM04
seg000:1CC3		    cmp	    al,	'='         ; _$P_Keyword
seg000:1CC3					    ; ("=" is delimiter)
seg000:1CC5		    jnz	    short _$P_SCOM03
seg000:1CC7		    cmp	    byte ptr es:[bp+1],	0 ; _$P_NULL
seg000:1CCC		    jnz	    short _$P_SCOM_Differ
seg000:1CCE		    jmp	    short _$P_SCOM05 ; (keyword	found in synonym list)
seg000:1CD0 ; ---------------------------------------------------------------------------
seg000:1CD0
seg000:1CD0 _$P_SCOM04:				    ; CODE XREF: _$P_String_Comp+17j
seg000:1CD0		    test    byte ptr cs:_$P_Flags+1, 10h ; _$P_SW_Cmp
seg000:1CD0					    ; (switch search ?)
seg000:1CD6		    jz	    short _$P_SCOM03
seg000:1CD8		    cmp	    al,	':'         ; _$P_Colon
seg000:1CD8					    ; (/:" is delimiter, at end	of switch on command line)
seg000:1CDA		    jnz	    short _$P_SCOM03
seg000:1CDC		    cmp	    byte ptr es:[bp+0],	0 ; _$P_NULL
seg000:1CE1		    jnz	    short _$P_SCOM_Differ
seg000:1CE3
seg000:1CE3 _$P_SCOM05:				    ; CODE XREF: _$P_String_Comp+24j
seg000:1CE3		    inc	    si
seg000:1CE4		    jmp	    short _$P_SCOM_Same
seg000:1CE6 ; ---------------------------------------------------------------------------
seg000:1CE6
seg000:1CE6 _$P_SCOM03:				    ; CODE XREF: _$P_String_Comp+1Bj
seg000:1CE6					    ; _$P_String_Comp+2Cj ...
seg000:1CE6		    cmp	    al,	es:[bp+0]
seg000:1CEA		    jnz	    short _$P_SCOM_Differ0
seg000:1CEC		    or	    al,	al
seg000:1CEE		    jz	    short _$P_SCOM_Same
seg000:1CF0		    inc	    si
seg000:1CF1		    inc	    bp
seg000:1CF2		    jmp	    short _$P_SCOM01
seg000:1CF4 ; ---------------------------------------------------------------------------
seg000:1CF4
seg000:1CF4 _$P_SCOM00:				    ; CODE XREF: _$P_String_Comp+Cj
seg000:1CF4		    cmp	    al,	es:[bp+0]
seg000:1CF8		    jnz	    short _$P_SCOM_Differ
seg000:1CFA		    inc	    si
seg000:1CFB		    mov	    al,	cs:[si]
seg000:1CFE		    inc	    bp
seg000:1CFF		    cmp	    al,	es:[bp+0]
seg000:1D03		    jnz	    short _$P_SCOM_Differ
seg000:1D05		    inc	    si
seg000:1D06		    inc	    bp
seg000:1D07
seg000:1D07 _$P_SCOM01:				    ; CODE XREF: _$P_String_Comp+48j
seg000:1D07		    jmp	    short _$P_SCOM_Loop
seg000:1D09 ; ---------------------------------------------------------------------------
seg000:1D09
seg000:1D09 _$P_SCOM_Differ0:			    ; CODE XREF: _$P_String_Comp+40j
seg000:1D09		    test    byte ptr cs:_$P_Flags+1, 40h ; [cs:_$P_Flags2],
seg000:1D09					    ; _$P_SW
seg000:1D0F		    jz	    short _$P_not_applicable
seg000:1D11		    test    word ptr es:[bx+2],	20h ; [es:bx+_$P_Control_Blk.Function_Flag],
seg000:1D11					    ; _$P_colon_is_not_necessary
seg000:1D17		    jz	    short _$P_not_applicable
seg000:1D19		    cmp	    byte ptr es:[bp+0],	0 ; _$P_NULL
seg000:1D1E		    jz	    short _$P_SCOM_Same
seg000:1D20
seg000:1D20 _$P_not_applicable:			    ; CODE XREF: _$P_String_Comp+65j
seg000:1D20					    ; _$P_String_Comp+6Dj
seg000:1D20		    test    word ptr es:[bx], 10h ; _$P_Ig_Colon
seg000:1D25		    jz	    short _$P_SCOM_Differ
seg000:1D27		    cmp	    al,	':'         ; _$P_Colon
seg000:1D29		    jnz	    short _$P_SCOM02
seg000:1D2B		    cmp	    byte ptr es:[bp+0],	0 ; _$P_NULL
seg000:1D30		    jnz	    short _$P_SCOM_Differ
seg000:1D32		    jmp	    short _$P_SCOM_Same
seg000:1D34 ; ---------------------------------------------------------------------------
seg000:1D34
seg000:1D34 _$P_SCOM02:				    ; CODE XREF: _$P_String_Comp+7Fj
seg000:1D34		    cmp	    al,	0	    ; _$P_NULL
seg000:1D36		    jnz	    short _$P_SCOM_Differ
seg000:1D38		    cmp	    byte ptr es:[bp+0],	':' ; _$P_Colon
seg000:1D3D		    jz	    short _$P_SCOM_Same
seg000:1D3F
seg000:1D3F _$P_SCOM_Differ:			    ; CODE XREF: _$P_String_Comp+22j
seg000:1D3F					    ; _$P_String_Comp+37j ...
seg000:1D3F		    stc
seg000:1D40		    jmp	    short _$P_SCOM_Exit
seg000:1D42 ; ---------------------------------------------------------------------------
seg000:1D42
seg000:1D42 _$P_SCOM_Same:			    ; CODE XREF: _$P_String_Comp+3Aj
seg000:1D42					    ; _$P_String_Comp+44j ...
seg000:1D42		    mov	    cs:_$P_KEYorSW_Ptr,	si
seg000:1D47		    clc
seg000:1D48
seg000:1D48 _$P_SCOM_Exit:			    ; CODE XREF: _$P_String_Comp+96j
seg000:1D48		    pop	    si
seg000:1D49		    pop	    dx
seg000:1D4A		    pop	    bp
seg000:1D4B		    pop	    ax
seg000:1D4C		    retn
seg000:1D4C _$P_String_Comp endp
seg000:1D4C
seg000:1D4D
seg000:1D4D ; =============== S	U B R O	U T I N	E =======================================
seg000:1D4D
seg000:1D4D
seg000:1D4D _$P_File_Format proc near		    ; CODE XREF: _$P_Check_Match_Flags+65p
seg000:1D4D					    ; _$P_Check_Match_Flags+7Fp
seg000:1D4D		    push    ax
seg000:1D4E		    push    di
seg000:1D4F		    push    si
seg000:1D50		    mov	    di,	cs:_$P_SaveSI_Cmpx
seg000:1D55		    mov	    al,	cs:[si]
seg000:1D58		    or	    al,	al
seg000:1D5A		    jz	    short _$P_FileF_Err
seg000:1D5C		    call    _$P_FileSp_Chk
seg000:1D5F		    jnz	    short _$P_FileF03
seg000:1D61		    mov	    cs:_$P_err_flag, 1 ; _$P_error_filespec
seg000:1D67		    pop	    si
seg000:1D68		    mov	    byte ptr cs:[si], 0	; _$P_NULL
seg000:1D6C		    pop	    di
seg000:1D6D		    jmp	    short _$P_FileF02
seg000:1D6F ; ---------------------------------------------------------------------------
seg000:1D6F
seg000:1D6F _$P_FileF_Err:			    ; CODE XREF: _$P_File_Format+Dj
seg000:1D6F		    pop	    si
seg000:1D70		    mov	    byte ptr cs:[si], 0	; _$P_NULL
seg000:1D74		    pop	    di
seg000:1D75		    test    word ptr es:[bx], 1	; _$P_Optional
seg000:1D7A		    jnz	    short _$P_FileF02
seg000:1D7C		    mov	    cs:_$P_RC, 2    ; _$P_Op_Missing
seg000:1D83		    jmp	    short _$P_FileF02
seg000:1D85 ; ---------------------------------------------------------------------------
seg000:1D85
seg000:1D85 _$P_FileF03:			    ; CODE XREF: _$P_File_Format+12j
seg000:1D85		    pop	    ax
seg000:1D86		    push    si
seg000:1D87
seg000:1D87 _$P_FileF_Loop1:			    ; CODE XREF: _$P_File_Format+4Fj
seg000:1D87		    mov	    al,	cs:[si]	    ; load character (not special char)
seg000:1D8A		    or	    al,	al	    ; end of line ?
seg000:1D8C		    jz	    short _$P_FileF_RLT
seg000:1D8E		    call    _$P_FileSp_Chk
seg000:1D91		    jz	    short _$P_FileF00
seg000:1D93		    call    _$P_Chk_DBCS
seg000:1D96		    jnb	    short _$P_FileF01
seg000:1D98		    inc	    di
seg000:1D99		    inc	    si
seg000:1D9A
seg000:1D9A _$P_FileF01:			    ; CODE XREF: _$P_File_Format+49j
seg000:1D9A		    inc	    di
seg000:1D9B		    inc	    si
seg000:1D9C		    jmp	    short _$P_FileF_Loop1
seg000:1D9E ; ---------------------------------------------------------------------------
seg000:1D9E
seg000:1D9E _$P_FileF00:			    ; CODE XREF: _$P_File_Format+44j
seg000:1D9E		    mov	    cs:_$P_Terminator, al
seg000:1DA2		    mov	    byte ptr cs:[si], 0	; update end of	string
seg000:1DA6		    inc	    di
seg000:1DA7		    mov	    cs:_$P_SI_Save, di
seg000:1DAC
seg000:1DAC _$P_FileF_RLT:			    ; CODE XREF: _$P_File_Format+3Fj
seg000:1DAC		    pop	    si
seg000:1DAD		    pop	    di
seg000:1DAE
seg000:1DAE _$P_FileF02:			    ; CODE XREF: _$P_File_Format+20j
seg000:1DAE					    ; _$P_File_Format+2Dj ...
seg000:1DAE		    pop	    ax
seg000:1DAF		    test    ax,	200h	    ; _$P_File_Spc
seg000:1DB2		    jz	    short _$P_Drv_Only_Exit
seg000:1DB4		    push    ax
seg000:1DB5		    mov	    ah,	0FFh	    ; _$P_No_Tag
seg000:1DB7		    mov	    al,	5	    ; _$P_File_Spec
seg000:1DB9		    call    _$P_Fill_Result
seg000:1DBC		    pop	    ax
seg000:1DBD
seg000:1DBD _$P_Drv_Only_Exit:			    ; CODE XREF: _$P_File_Format+65j
seg000:1DBD		    retn
seg000:1DBD _$P_File_Format endp
seg000:1DBD
seg000:1DBE
seg000:1DBE ; =============== S	U B R O	U T I N	E =======================================
seg000:1DBE
seg000:1DBE
seg000:1DBE _$P_FileSp_Chk  proc near		    ; CODE XREF: _$P_File_Format+Fp
seg000:1DBE					    ; _$P_File_Format+41p
seg000:1DBE		    push    bx
seg000:1DBF		    push    cx
seg000:1DC0		    lea	    bx,	_$P_FileSp_Char
seg000:1DC4		    mov	    cx,	9	    ; _$P_FileSp_Len
seg000:1DC7
seg000:1DC7 _$P_FileSp_Loop:			    ; CODE XREF: _$P_FileSp_Chk+Fj
seg000:1DC7		    cmp	    al,	cs:[bx]
seg000:1DCA		    jz	    short _$P_FileSp_Exit
seg000:1DCC		    inc	    bx
seg000:1DCD		    loop    _$P_FileSp_Loop
seg000:1DCF		    inc	    cx
seg000:1DD0
seg000:1DD0 _$P_FileSp_Exit:			    ; CODE XREF: _$P_FileSp_Chk+Cj
seg000:1DD0		    pop	    cx
seg000:1DD1		    pop	    bx
seg000:1DD2		    retn
seg000:1DD2 _$P_FileSp_Chk  endp
seg000:1DD2
seg000:1DD3
seg000:1DD3 ; =============== S	U B R O	U T I N	E =======================================
seg000:1DD3
seg000:1DD3
seg000:1DD3 _$P_Drive_Format proc near		    ; CODE XREF: _$P_Check_Match_Flags+68p
seg000:1DD3		    push    ax
seg000:1DD4		    push    dx
seg000:1DD5		    mov	    al,	cs:[si]
seg000:1DD8		    or	    al,	al
seg000:1DDA		    jz	    short _$P_Drv_Exit
seg000:1DDC		    call    _$P_Chk_DBCS
seg000:1DDF		    jb	    short _$P_Drv_Err
seg000:1DE1		    cmp	    word ptr cs:[si+1],	':' ; _$P_Colon
seg000:1DE6		    jz	    short _$P_DrvF00
seg000:1DE8		    test    word ptr es:[bx], 10h ; _$P_Ig_Colon
seg000:1DED		    jz	    short _$P_Drv_Err
seg000:1DEF		    cmp	    byte ptr cs:[si+1],	0 ; _$P_NULL
seg000:1DF4		    jnz	    short _$P_Drv_Err
seg000:1DF6
seg000:1DF6 _$P_DrvF00:				    ; CODE XREF: _$P_Drive_Format+13j
seg000:1DF6		    or	    al,	20h	    ; _$P_Make_Lower
seg000:1DF6					    ; (lower case)
seg000:1DF8		    cmp	    al,	'a'         ; drive letter must
seg000:1DF8					    ; in range of "a" -	"z"
seg000:1DFA		    jb	    short _$P_Drv_Err
seg000:1DFC		    cmp	    al,	'z'
seg000:1DFE		    ja	    short _$P_Drv_Err
seg000:1E00		    sub	    al,	60h	    ; "a"-1
seg000:1E02		    mov	    dl,	al
seg000:1E04		    mov	    ah,	0FFh
seg000:1E06		    mov	    al,	6
seg000:1E08		    call    _$P_Fill_Result
seg000:1E0B		    jmp	    short _$P_Drv_Exit
seg000:1E0D ; ---------------------------------------------------------------------------
seg000:1E0D
seg000:1E0D _$P_Drv_Err:			    ; CODE XREF: _$P_Drive_Format+Cj
seg000:1E0D					    ; _$P_Drive_Format+1Aj ...
seg000:1E0D		    mov	    cs:_$P_RC, 9    ; _$P_Syntax
seg000:1E14
seg000:1E14 _$P_Drv_Exit:			    ; CODE XREF: _$P_Drive_Format+7j
seg000:1E14					    ; _$P_Drive_Format+38j
seg000:1E14		    pop	    dx
seg000:1E15		    pop	    ax
seg000:1E16		    retn
seg000:1E16 _$P_Drive_Format endp
seg000:1E16
seg000:1E17
seg000:1E17 ; =============== S	U B R O	U T I N	E =======================================
seg000:1E17
seg000:1E17
seg000:1E17 _$P_Skip_Delim  proc near		    ; CODE XREF: SysParse+3Ep
seg000:1E17					    ; SysParse+82p ...
seg000:1E17		    lodsb
seg000:1E18		    call    _$P_Chk_EOL	    ; is it EOL	character ?
seg000:1E1B		    jz	    short _$P_Skip_Delim_CY
seg000:1E1D		    call    _$P_Chk_Delim   ; is it one	of delimiters ?
seg000:1E20		    jnz	    short _$P_Skip_Delim_NCY ; if no, exit w/ CY off
seg000:1E22		    test    byte ptr cs:_$P_Flags+1, 20h ; _$P_Extra
seg000:1E22					    ; extra delim or comma found ?
seg000:1E28		    jz	    short _$P_Skip_Delim ; if no, loop
seg000:1E2A		    test    byte ptr cs:_$P_Flags+1, 41h ; [cs:_$P_Flags2],
seg000:1E2A					    ; _$P_SW+_$P_equ
seg000:1E30		    jz	    short _$P_Exit_At_Extra ; no switch, no keyword
seg000:1E32		    dec	    si
seg000:1E33		    jmp	    short _$P_Exit_At_Extra
seg000:1E35 ; ---------------------------------------------------------------------------
seg000:1E35
seg000:1E35 _$P_Skip_Delim_CY:			    ; CODE XREF: _$P_Skip_Delim+4j
seg000:1E35		    stc			    ; indicate EOL
seg000:1E36		    jmp	    short _$P_Skip_Delim_Exit
seg000:1E38 ; ---------------------------------------------------------------------------
seg000:1E38
seg000:1E38 _$P_Skip_Delim_NCY:			    ; CODE XREF: _$P_Skip_Delim+9j
seg000:1E38		    clc			    ; indicate non delim
seg000:1E39
seg000:1E39 _$P_Skip_Delim_Exit:		    ; CODE XREF: _$P_Skip_Delim+1Fj
seg000:1E39		    dec	    si		    ; in this case, need
seg000:1E39					    ; backup index pointer
seg000:1E3A		    retn
seg000:1E3B ; ---------------------------------------------------------------------------
seg000:1E3B
seg000:1E3B _$P_Exit_At_Extra:			    ; CODE XREF: _$P_Skip_Delim+19j
seg000:1E3B					    ; _$P_Skip_Delim+1Cj
seg000:1E3B		    clc			    ; indicate extra delim
seg000:1E3C		    retn
seg000:1E3C _$P_Skip_Delim  endp
seg000:1E3C
seg000:1E3D
seg000:1E3D ; =============== S	U B R O	U T I N	E =======================================
seg000:1E3D
seg000:1E3D
seg000:1E3D _$P_Chk_EOL	    proc near		    ; CODE XREF: SysParse+70p
seg000:1E3D					    ; _$P_Skip_Delim+1p
seg000:1E3D		    push    bx
seg000:1E3E		    push    cx
seg000:1E3F		    cmp	    al,	0Dh	    ; _$P_CR
seg000:1E41		    jz	    short _$P_Chk_EOL_Exit
seg000:1E43		    cmp	    al,	0	    ; _$P_NUL
seg000:1E45		    jz	    short _$P_Chk_EOL_Exit
seg000:1E47		    cmp	    al,	0Ah	    ; _$P_LF
seg000:1E49		    jz	    short _$P_Chk_EOL_Exit
seg000:1E4B		    cmp	    byte ptr es:[di+2],	2 ; [es:di+_$P_PARMS_Blk.Num_Extra],
seg000:1E4B					    ; _$P_I_Have_EOL
seg000:1E50		    jb	    short _$P_Chk_EOL_Exit
seg000:1E52		    xor	    bx,	bx
seg000:1E54		    mov	    bl,	es:[di+3]   ; [es:di+_$P_PARMS_Blk.Len_Extra_Delim]
seg000:1E58		    add	    bx,	4	    ; _$P_Len_PARMS
seg000:1E5B		    cmp	    byte ptr es:[bx+di], 0 ; _$P_I_Use_Default
seg000:1E5B					    ; No extra EOL character ?
seg000:1E5F		    jz	    short _$P_Chk_EOL_NZ
seg000:1E61		    xor	    cx,	cx
seg000:1E63		    mov	    cl,	es:[bx+di]  ; Check extra EOL character
seg000:1E66
seg000:1E66 _$P_Chk_EOL_Loop:			    ; CODE XREF: _$P_Chk_EOL+2Fj
seg000:1E66		    inc	    bx
seg000:1E67		    cmp	    al,	es:[bx+di]
seg000:1E6A		    jz	    short _$P_Chk_EOL_Exit
seg000:1E6C		    loop    _$P_Chk_EOL_Loop
seg000:1E6E
seg000:1E6E _$P_Chk_EOL_NZ:			    ; CODE XREF: _$P_Chk_EOL+22j
seg000:1E6E		    cmp	    al,	0Dh	    ; _$P_CR
seg000:1E6E					    ; reset ZF
seg000:1E70
seg000:1E70 _$P_Chk_EOL_Exit:			    ; CODE XREF: _$P_Chk_EOL+4j
seg000:1E70					    ; _$P_Chk_EOL+8j ...
seg000:1E70		    pop	    cx
seg000:1E71		    pop	    bx
seg000:1E72		    retn
seg000:1E72 _$P_Chk_EOL	    endp
seg000:1E72
seg000:1E73
seg000:1E73 ; =============== S	U B R O	U T I N	E =======================================
seg000:1E73
seg000:1E73
seg000:1E73 _$P_Chk_Delim   proc near		    ; CODE XREF: SysParse+75p
seg000:1E73					    ; _$P_Skip_Delim+6p
seg000:1E73		    push    bx
seg000:1E74		    push    cx
seg000:1E75		    mov	    cs:_$P_Terminator, ' ' ; _$P_Space
seg000:1E7B		    and	    byte ptr cs:_$P_Flags+1, 0DFh ; 0FFh-_$P_Extra
seg000:1E81		    cmp	    al,	20h ; ' '   ; _$P_Space
seg000:1E83		    jz	    short _$P_Chk_Delim_Exit
seg000:1E85		    cmp	    al,	9	    ; _$P_TAB
seg000:1E87		    jz	    short _$P_Chk_Delim_Exit
seg000:1E89		    cmp	    al,	2Ch ; ','   ; _$P_Comma
seg000:1E8B		    jz	    short _$P_Chk_Delim_Exit0
seg000:1E8D
seg000:1E8D _$P_Chk_Delim00:			    ; _$P_DBSP1
seg000:1E8D		    cmp	    al,	20h ; ' '
seg000:1E8F		    jnz	    short _$P_Chk_Delim01
seg000:1E91		    cmp	    byte ptr [si], 20h ; ' ' ; _$P_DBSP2
seg000:1E94		    jnz	    short _$P_Chk_Delim01
seg000:1E96		    mov	    al,	20h ; ' '   ; _$P_Space
seg000:1E98		    inc	    si
seg000:1E99		    cmp	    al,	al
seg000:1E9B		    jmp	    short _$P_Chk_Delim_Exit
seg000:1E9D ; ---------------------------------------------------------------------------
seg000:1E9D
seg000:1E9D _$P_Chk_Delim01:			    ; CODE XREF: _$P_Chk_Delim+1Cj
seg000:1E9D					    ; _$P_Chk_Delim+21j
seg000:1E9D		    cmp	    byte ptr es:[di+2],	1 ; [es:di-_$P_PARMS_Blk.Num_Extra],
seg000:1E9D					    ; _$P_I_Have_Delim
seg000:1EA2		    jb	    short _$P_Chk_Delim_Exit
seg000:1EA4		    xor	    cx,	cx
seg000:1EA6		    mov	    cl,	es:[di+3]   ; ;	[es:di+_$P_PARMS_Blk.Len_Extra_Delim]
seg000:1EAA		    or	    cx,	cx
seg000:1EAC		    jz	    short _$P_Chk_Delim_NZ
seg000:1EAE		    mov	    bx,	3	    ; _$P_Len_PARMS-1
seg000:1EB1
seg000:1EB1 _$P_Chk_Delim_Loop:			    ; CODE XREF: _$P_Chk_Delim+44j
seg000:1EB1		    inc	    bx
seg000:1EB2		    cmp	    al,	es:[bx+di]
seg000:1EB5		    jz	    short _$P_Chk_Delim_Exit0
seg000:1EB7		    loop    _$P_Chk_Delim_Loop
seg000:1EB9
seg000:1EB9 _$P_Chk_Delim_NZ:			    ; CODE XREF: _$P_Chk_Delim+39j
seg000:1EB9		    cmp	    al,	20h ; ' '   ; _$P_Space
seg000:1EBB
seg000:1EBB _$P_Chk_Delim_Exit:			    ; CODE XREF: _$P_Chk_Delim+10j
seg000:1EBB					    ; _$P_Chk_Delim+14j ...
seg000:1EBB		    pop	    cx
seg000:1EBC		    pop	    bx
seg000:1EBD		    retn
seg000:1EBE ; ---------------------------------------------------------------------------
seg000:1EBE
seg000:1EBE _$P_Chk_Delim_Exit0:		    ; CODE XREF: _$P_Chk_Delim+18j
seg000:1EBE					    ; _$P_Chk_Delim+42j
seg000:1EBE		    mov	    cs:_$P_Terminator, al
seg000:1EC2		    test    byte ptr cs:_$P_Flags+1, 1 ; [cs:_$P_Flags2],
seg000:1EC2					    ; _$P_equ
seg000:1EC8		    jnz	    short _$P_No_Set_Extra
seg000:1ECA		    or	    byte ptr cs:_$P_Flags+1, 20h ; _$P_Extra
seg000:1ED0
seg000:1ED0 _$P_No_Set_Extra:			    ; CODE XREF: _$P_Chk_Delim+55j
seg000:1ED0		    cmp	    al,	al
seg000:1ED2		    jmp	    short _$P_Chk_Delim_Exit
seg000:1ED2 _$P_Chk_Delim   endp
seg000:1ED2
seg000:1ED4
seg000:1ED4 ; =============== S	U B R O	U T I N	E =======================================
seg000:1ED4
seg000:1ED4
seg000:1ED4 _$P_Chk_Switch  proc near		    ; CODE XREF: SysParse+6Bp
seg000:1ED4		    lea	    bp,	_$P_STRING_BUF
seg000:1ED8		    cmp	    bx,	bp
seg000:1EDA		    jz	    short _$P_STRUC_L2
seg000:1EDC		    cmp	    al,	'/'         ; _$P_Switch
seg000:1EDE		    jnz	    short _$P_STRUC_L5
seg000:1EE0		    stc
seg000:1EE1		    jmp	    short _$P_STRUC_L1
seg000:1EE3 ; ---------------------------------------------------------------------------
seg000:1EE3
seg000:1EE3 _$P_STRUC_L5:			    ; CODE XREF: _$P_Chk_Switch+Aj
seg000:1EE3		    clc
seg000:1EE4		    jmp	    short _$P_STRUC_L1
seg000:1EE6 ; ---------------------------------------------------------------------------
seg000:1EE6
seg000:1EE6 _$P_STRUC_L2:			    ; CODE XREF: _$P_Chk_Switch+6j
seg000:1EE6		    cmp	    al,	'/'         ; _$P_Switch
seg000:1EE8		    jnz	    short _$P_STRUC_L12
seg000:1EEA		    or	    byte ptr cs:_$P_Flags+1, 40h ; _$P_SW
seg000:1EF0
seg000:1EF0 _$P_STRUC_L12:			    ; CODE XREF: _$P_Chk_Switch+14j
seg000:1EF0		    clc
seg000:1EF1
seg000:1EF1 _$P_STRUC_L1:			    ; CODE XREF: _$P_Chk_Switch+Dj
seg000:1EF1					    ; _$P_Chk_Switch+10j
seg000:1EF1		    retn
seg000:1EF1 _$P_Chk_Switch  endp
seg000:1EF1
seg000:1EF2
seg000:1EF2 ; =============== S	U B R O	U T I N	E =======================================
seg000:1EF2
seg000:1EF2
seg000:1EF2 _$P_Chk_DBCS    proc near		    ; CODE XREF: SysParse+A0p
seg000:1EF2					    ; _$P_Remove_Colon:_$P_RCOL00p ...
seg000:1EF2		    push    ds
seg000:1EF3		    push    si
seg000:1EF4		    push    bx
seg000:1EF5		    cmp	    cs:_$P_DBCSEV_SEG, 0 ; ALREADY SET ?
seg000:1EFB		    jnz	    short _$P_DBCS00
seg000:1EFD		    push    ax
seg000:1EFE		    push    ds
seg000:1EFF		    push    cx
seg000:1F00		    push    dx
seg000:1F01		    push    di
seg000:1F02		    push    bp
seg000:1F03		    push    es
seg000:1F04		    xor	    si,	si
seg000:1F06		    mov	    ds,	si
seg000:1F08		    mov	    ax,	6300h	    ; _$P_DOS_GetEV
seg000:1F0B		    int	    21h		    ; DOS - 3.2+ only -	GET DOUBLE BYTE	CHARACTER SET LEAD TABLE
seg000:1F0D		    mov	    bx,	ds
seg000:1F0F		    or	    bx,	bx
seg000:1F11		    pop	    es
seg000:1F12		    pop	    bp
seg000:1F13		    pop	    di
seg000:1F14		    pop	    dx
seg000:1F15		    pop	    cx
seg000:1F16		    pop	    ds
seg000:1F17		    pop	    ax
seg000:1F18		    jz	    short _$P_NON_DBCS
seg000:1F1A		    mov	    cs:_$P_DBCSEV_OFF, si ; save EV offset
seg000:1F1F		    mov	    cs:_$P_DBCSEV_SEG, bx ; save EV segment
seg000:1F24
seg000:1F24 _$P_DBCS00:				    ; CODE XREF: _$P_Chk_DBCS+9j
seg000:1F24		    mov	    si,	cs:_$P_DBCSEV_OFF
seg000:1F29		    mov	    ds,	cs:_$P_DBCSEV_SEG
seg000:1F2E
seg000:1F2E _$P_DBCS_LOOP:			    ; CODE XREF: _$P_Chk_DBCS+4Fj
seg000:1F2E		    cmp	    word ptr [si], 0 ; zero vector ?
seg000:1F31		    jz	    short _$P_NON_DBCS ; then exit
seg000:1F33		    cmp	    al,	[si]
seg000:1F35		    jb	    short _$P_DBCS01
seg000:1F37		    cmp	    al,	[si+1]
seg000:1F3A		    ja	    short _$P_DBCS01
seg000:1F3C		    stc			    ; indicate DBCS and	exit
seg000:1F3D		    jmp	    short _$P_DBCS_EXIT
seg000:1F3F ; ---------------------------------------------------------------------------
seg000:1F3F
seg000:1F3F _$P_DBCS01:				    ; CODE XREF: _$P_Chk_DBCS+43j
seg000:1F3F					    ; _$P_Chk_DBCS+48j
seg000:1F3F		    inc	    si
seg000:1F40		    inc	    si
seg000:1F41		    jmp	    short _$P_DBCS_LOOP
seg000:1F43 ; ---------------------------------------------------------------------------
seg000:1F43
seg000:1F43 _$P_NON_DBCS:			    ; CODE XREF: _$P_Chk_DBCS+26j
seg000:1F43					    ; _$P_Chk_DBCS+3Fj
seg000:1F43		    clc			    ; indicate SBCS
seg000:1F44
seg000:1F44 _$P_DBCS_EXIT:			    ; CODE XREF: _$P_Chk_DBCS+4Bj
seg000:1F44		    pop	    bx
seg000:1F45		    pop	    si
seg000:1F46		    pop	    ds
seg000:1F47		    retn
seg000:1F47 _$P_Chk_DBCS    endp
seg000:1F47
seg000:1F47 ; ---------------------------------------------------------------------------
seg000:1F48 buf_parms	    dw offset buf_parmsx    ; DATA XREF: multi_pass+B4o
seg000:1F48					    ; buffer = [n | n,m] {/e}
seg000:1F4A		    db 1		    ; an extra delimiter list
seg000:1F4B		    db 1		    ; length is	1
seg000:1F4C		    db ';'                  ; delimiter
seg000:1F4D buf_parmsx	    dw 201h		    ; DATA XREF: seg000:buf_parmso
seg000:1F4D					    ; min 1, max 2 positionals
seg000:1F4F		    dw offset buf_pos1
seg000:1F51		    dw offset buf_pos2
seg000:1F53		    db 1		    ; one switch
seg000:1F54		    dw offset sw_x_ctrl
seg000:1F56		    db 0		    ; no keywords
seg000:1F57 buf_pos1	    dw 8000h		    ; DATA XREF: seg000:1F4Fo
seg000:1F57					    ; numeric value??
seg000:1F59		    dw 0		    ; function
seg000:1F5B		    dw offset result_val    ; result value buffer
seg000:1F5D		    dw offset buf_range_1   ; value list
seg000:1F5F		    db 0		    ; no switches/keywords
seg000:1F60 buf_range_1	    db 1		    ; DATA XREF: seg000:1F5Do
seg000:1F60					    ; range definition
seg000:1F61		    db 1		    ; 1	definition of range
seg000:1F62		    db 1		    ; item tag for this	range
seg000:1F63		    dd 1		    ; numeric min
seg000:1F67		    dd 99		    ; numeric max
seg000:1F6B buf_pos2	    dw 8001h		    ; DATA XREF: seg000:1F51o
seg000:1F6B					    ; optional num.
seg000:1F6D		    dw 0
seg000:1F6F		    dw offset result_val
seg000:1F71		    dw offset buf_range_2
seg000:1F73		    db 0
seg000:1F74 buf_range_2	    db 1		    ; DATA XREF: seg000:1F71o
seg000:1F75		    db 1
seg000:1F76		    db 1
seg000:1F77		    dd 0
seg000:1F7B		    dd 8
seg000:1F7F sw_x_ctrl	    dw 0		    ; DATA XREF: seg000:1F54o
seg000:1F7F					    ; ;	followed by one	switch
seg000:1F81		    dw 0
seg000:1F83		    dw offset result_val
seg000:1F85		    dw offset noval
seg000:1F87		    db 1
seg000:1F88 switch_x	    db '/X',0               ; DATA XREF: multi_pass+CAo
seg000:1F8B p_buffers	    dw 0		    ; DATA XREF: multi_pass+DCw
seg000:1F8B					    ; multi_pass:en7r ...
seg000:1F8D p_h_buffers	    dw 0		    ; DATA XREF: multi_pass:if13w
seg000:1F8D					    ; multi_pass+F0w ...
seg000:1F8F p_buffer_slash_x db	0		    ; DATA XREF: multi_pass+AFw
seg000:1F90 noval	    db 0		    ; DATA XREF: seg000:1F85o
seg000:1F90					    ; seg000:1FF1o ...
seg000:1F91 result_val	    db 0		    ; DATA XREF: seg000:1F5Bo
seg000:1F91					    ; seg000:1F6Fo ...
seg000:1F91					    ; type returned
seg000:1F92 result_val_itag db 0		    ; DATA XREF: multi_pass+128r
seg000:1F92					    ; multi_pass+165r ...
seg000:1F92					    ; item tag returned
seg000:1F93 result_val_swoff dw	0		    ; DATA XREF: multi_pass+CAr
seg000:1F93					    ; multi_pass+779r ...
seg000:1F93					    ; es:offset	of the switch defined
seg000:1F95 rv_dword	    dd 0		    ; DATA XREF: multi_pass:if11r
seg000:1F95					    ; multi_pass+4ABr ...
seg000:1F99 brk_parms	    dw offset brk_parmsx    ; DATA XREF: multi_pass+112o
seg000:1F99					    ; break = [	on | off ]
seg000:1F9B		    db 1		    ; an extra delimiter list
seg000:1F9C		    db 1		    ; length is	1
seg000:1F9D		    db ';'                  ; delimiter
seg000:1F9E brk_parmsx	    dw 101h		    ; DATA XREF: seg000:brk_parmso
seg000:1F9E					    ; min,max =	1 positional
seg000:1FA0		    dw offset brk_pos
seg000:1FA2		    db 0		    ; no switches
seg000:1FA3		    db 0		    ; no keywords
seg000:1FA4 brk_pos	    dw 2000h		    ; DATA XREF: seg000:1FA0o
seg000:1FA6		    dw 0
seg000:1FA8		    dw offset result_val
seg000:1FAA		    dw offset on_off_string
seg000:1FAC		    db 0
seg000:1FAD on_off_string   db 3		    ; DATA XREF: seg000:1FAAo
seg000:1FAD					    ; seg000:20AEo
seg000:1FAD					    ; signals that there is a string choice
seg000:1FAE		    db 0		    ; no range definition
seg000:1FAF		    db 0		    ; no numeric values	choice
seg000:1FB0		    db 2		    ; 2	strings	for choice
seg000:1FB1		    db 1		    ; the 1st string tag
seg000:1FB2		    dw offset on_string	    ; "ON"
seg000:1FB4		    db 2		    ; the 2nd string tag
seg000:1FB5		    dw offset _off_string   ; "OFF"
seg000:1FB7 on_string	    db 'ON',0               ; DATA XREF: seg000:1FB2o
seg000:1FBA _off_string	    db 'OFF',0              ; DATA XREF: seg000:1FB5o
seg000:1FBE p_ctrl_break    db 0		    ; DATA XREF: multi_pass+12Fw
seg000:1FBE					    ; multi_pass:if26w	...
seg000:1FBF cntry_parms	    dw offset cntry_parmsx  ; DATA XREF: multi_pass+486o
seg000:1FBF					    ; country =	n {m {path}}
seg000:1FBF					    ; or country = n,,path
seg000:1FC1		    db 1
seg000:1FC2		    db 1
seg000:1FC3		    db ';'
seg000:1FC4 cntry_parmsx    dw 301h		    ; DATA XREF: seg000:cntry_parmso
seg000:1FC4					    ; min 1, max 3 pos.
seg000:1FC6		    dw offset cntry_pos1
seg000:1FC8		    dw offset cntry_pos2
seg000:1FCA		    dw offset cntry_pos3
seg000:1FCC		    db 0		    ; no switches
seg000:1FCD		    db 0		    ; no keywords
seg000:1FCE cntry_pos1	    dw 8000h		    ; DATA XREF: seg000:1FC6o
seg000:1FD0		    dw 0
seg000:1FD2		    dw offset result_val
seg000:1FD4		    dw offset cc_range
seg000:1FD6		    db 0
seg000:1FD7 cc_range	    db 1		    ; DATA XREF: seg000:1FD4o
seg000:1FD7					    ; seg000:1FE8o
seg000:1FD8		    db 1
seg000:1FD9		    db 1
seg000:1FDA		    dd 1
seg000:1FDE		    dd 999
seg000:1FE2 cntry_pos2	    dw 8001h		    ; DATA XREF: seg000:1FC8o
seg000:1FE4		    dw 0
seg000:1FE6		    dw offset result_val
seg000:1FE8		    dw offset cc_range
seg000:1FEA		    db 0
seg000:1FEB cntry_pos3	    dw 201h		    ; DATA XREF: seg000:1FCAo
seg000:1FED		    dw 0
seg000:1FEF		    dw offset result_val
seg000:1FF1		    dw offset noval
seg000:1FF3		    db 0
seg000:1FF4 p_cntry_code    dw 0		    ; DATA XREF: multi_pass+495w
seg000:1FF4					    ; multi_pass+4B4w ...
seg000:1FF6 p_code_page	    dw 0		    ; DATA XREF: multi_pass+47Fw
seg000:1FF6					    ; multi_pass:if57w	...
seg000:1FF8 files_parms	    dw offset files_parmsx  ; DATA XREF: multi_pass+5A1o
seg000:1FF8					    ; files = n
seg000:1FFA		    db 1
seg000:1FFB		    db 1
seg000:1FFC		    db ';'
seg000:1FFD files_parmsx    dw 101h		    ; DATA XREF: seg000:files_parmso
seg000:1FFD					    ; min,max 1	positional
seg000:1FFF		    dw offset files_pos
seg000:2001		    db 0		    ; no switches
seg000:2002		    db 0		    ; no keywords
seg000:2003 files_pos	    dw 8000h		    ; DATA XREF: seg000:1FFFo
seg000:2005		    dw 0
seg000:2007		    dw offset result_val
seg000:2009		    dw offset files_range
seg000:200B		    db 0
seg000:200C files_range	    db 1		    ; DATA XREF: seg000:2009o
seg000:200D		    db 1
seg000:200E		    db 1
seg000:200F		    dd 8
seg000:2013		    dd 255
seg000:2017 p_files	    db 0		    ; DATA XREF: multi_pass+5BBw
seg000:2017					    ; multi_pass:en67r
seg000:2018 fcbs_parms	    dw offset fcbs_parmsx   ; DATA XREF: multi_pass+708o
seg000:2018					    ; fcbs = n,m
seg000:201A		    db 1
seg000:201B		    db 1
seg000:201C		    db ';'
seg000:201D fcbs_parmsx	    dw 201h		    ; DATA XREF: seg000:fcbs_parmso
seg000:201D					    ; min,max =	2 positional
seg000:201F		    dw offset fcbs_pos_1
seg000:2021		    dw offset fcbs_pos_2
seg000:2023		    db 0		    ; no switches
seg000:2024		    db 0		    ; no keywords
seg000:2025 fcbs_pos_1	    dw 8000h		    ; DATA XREF: seg000:201Fo
seg000:2027		    dw 0
seg000:2029		    dw offset result_val
seg000:202B		    dw offset fcbs_range
seg000:202D		    db 0
seg000:202E fcbs_range	    db 1		    ; DATA XREF: seg000:202Bo
seg000:202F		    db 1
seg000:2030		    db 1
seg000:2031		    dd 1
seg000:2035		    dd 255
seg000:2039 fcbs_pos_2	    dw 8000h		    ; DATA XREF: seg000:2021o
seg000:203B		    dw 0
seg000:203D		    dw offset result_val
seg000:203F		    dw offset fcbs_keep_range
seg000:2041		    db 0
seg000:2042 fcbs_keep_range db 1		    ; DATA XREF: seg000:203Fo
seg000:2043		    db 1
seg000:2044		    db 1
seg000:2045		    dd 0
seg000:2049		    dd 255
seg000:204D p_fcbs	    db 0		    ; DATA XREF: multi_pass+727w
seg000:204D					    ; multi_pass:en98r
seg000:204E p_keep	    db 0		    ; DATA XREF: multi_pass:if102w
seg000:204F ldrv_parms	    dw offset ldrv_parmsx   ; DATA XREF: multi_pass+5D1o
seg000:204F					    ; lastdrive	= x
seg000:2051		    db 1
seg000:2052		    db 1
seg000:2053		    db ';'
seg000:2054 ldrv_parmsx	    dw 101h		    ; DATA XREF: seg000:ldrv_parmso
seg000:2054					    ;  min,max = 1 positional
seg000:2056		    dw offset ldrv_pos
seg000:2058		    db 0		    ; no switches
seg000:2059		    db 0		    ; no keywords
seg000:205A ldrv_pos	    dw 110h		    ; DATA XREF: seg000:2056o
seg000:205C		    dw 10h
seg000:205E		    dw offset result_val
seg000:2060		    dw offset noval
seg000:2062		    db 0
seg000:2063 p_ldrv	    db 0		    ; DATA XREF: multi_pass+5EBw
seg000:2063					    ; multi_pass:en73r
seg000:2064 stks_parms	    dw offset stks_parmsx   ; DATA XREF: multi_pass:do_tryko
seg000:2064					    ; stacks = n,m
seg000:2066		    db 1
seg000:2067		    db 1
seg000:2068		    db ';'
seg000:2069 stks_parmsx	    dw 202h		    ; DATA XREF: seg000:stks_parmso
seg000:206B		    dw offset stks_pos_1
seg000:206D		    dw offset stks_pos_2
seg000:206F		    db 0		    ; no switches
seg000:2070		    db 0		    ; no keywords
seg000:2071 stks_pos_1	    dw 8000h		    ; DATA XREF: seg000:206Bo
seg000:2073		    dw 0
seg000:2075		    dw offset result_val
seg000:2077		    dw offset stks_range
seg000:2079		    db 0
seg000:207A stks_range	    db 1		    ; DATA XREF: seg000:2077o
seg000:207B		    db 1
seg000:207C		    db 1
seg000:207D		    dd 0
seg000:2081		    dd 64
seg000:2085 stks_pos_2	    dw 8000h		    ; DATA XREF: seg000:206Do
seg000:2087		    dw 0
seg000:2089		    dw offset result_val
seg000:208B		    dw offset stk_size_range
seg000:208D		    db 0
seg000:208E stk_size_range  db 1		    ; DATA XREF: seg000:208Bo
seg000:208F		    db 1
seg000:2090		    db 1
seg000:2091		    dd 0
seg000:2095		    dd 512
seg000:2099 p_stack_count   dw 0		    ; DATA XREF: multi_pass+642w
seg000:2099					    ; multi_pass:en79r	...
seg000:209B p_stack_size    dw 0		    ; DATA XREF: multi_pass:if83w
seg000:209B					    ; multi_pass+65Er ...
seg000:209D mtrk_parms	    dw offset mtrk_parmsx   ; DATA XREF: multi_pass+14Fo
seg000:209D					    ; multitrack = [ on	| off ]
seg000:209F		    db 1
seg000:20A0		    db 1
seg000:20A1		    db ';'
seg000:20A2 mtrk_parmsx	    dw 101h		    ; DATA XREF: seg000:mtrk_parmso
seg000:20A2					    ; min,max =	1 positional
seg000:20A4		    dw offset mtrk_pos
seg000:20A6		    db 0		    ; no switches
seg000:20A7		    db 0		    ; no keywords
seg000:20A8 mtrk_pos	    dw 2000h		    ; DATA XREF: seg000:20A4o
seg000:20AA		    dw 0
seg000:20AC		    dw offset result_val
seg000:20AE		    dw offset on_off_string
seg000:20B0		    db 0
seg000:20B1 p_mtrk	    db 0		    ; DATA XREF: multi_pass+16Cw
seg000:20B1					    ; multi_pass:if35w	...
seg000:20B2 swit_parms	    dw offset swit_parmsx   ; DATA XREF: multi_pass:do_try1o
seg000:20B2					    ; switches=/k
seg000:20B4		    db 1
seg000:20B5		    db 1
seg000:20B6		    db ';'
seg000:20B7 swit_parmsx	    dw 0		    ; DATA XREF: seg000:swit_parmso
seg000:20B7					    ; no positionals
seg000:20B9		    db 3		    ; #	of switches
seg000:20BA		    dw offset swit_k_ctrl   ; /k control
seg000:20BC		    dw offset swit_t_ctrl   ; /t control
seg000:20BE		    dw offset swit_w_ctrl   ; /w control
seg000:20C0		    db 0		    ; no keywords
seg000:20C1 swit_k_ctrl	    dw 0		    ; DATA XREF: seg000:20BAo
seg000:20C3		    dw 0
seg000:20C5		    dw offset result_val
seg000:20C7		    dw offset noval
seg000:20C9		    db 1
seg000:20CA swit_k	    db '/K',0               ; DATA XREF: multi_pass+779o
seg000:20CD swit_t_ctrl	    dw 0		    ; DATA XREF: seg000:20BCo
seg000:20CF		    dw 0
seg000:20D1		    dw offset result_val
seg000:20D3		    dw offset noval
seg000:20D5		    db 1
seg000:20D6 swit_t	    db '/T',0               ; DATA XREF: multi_pass:if115o
seg000:20D9 swit_w_ctrl	    dw 0		    ; DATA XREF: seg000:20BEo
seg000:20DB		    dw 0
seg000:20DD		    dw offset result_val
seg000:20DF		    dw offset noval
seg000:20E1		    db 1
seg000:20E2 swit_w	    db '/W',0               ; DATA XREF: multi_pass:if116o
seg000:20E5 p_swit_k	    db 0		    ; DATA XREF: multi_pass+782w
seg000:20E5					    ; multi_pass:en110r
seg000:20E6 p_swit_t	    db 0		    ; DATA XREF: multi_pass+793w
seg000:20E6					    ; multi_pass:if117r
seg000:20E7 p_swit_w	    db 0		    ; DATA XREF: multi_pass+7A4w
seg000:20E7					    ; multi_pass+7CBr
seg000:20E8 dos_parms	    dw offset dos_parmsx    ; DATA XREF: multi_pass:it_is_ho
seg000:20EA		    db 1
seg000:20EB		    db 1
seg000:20EC		    db ';'
seg000:20ED dos_parmsx	    db 1		    ; DATA XREF: seg000:dos_parmso
seg000:20ED					    ; min parameters
seg000:20EE		    db 2		    ; max parameters
seg000:20EF		    dw offset dos_pos
seg000:20F1		    dw offset dos_pos
seg000:20F3		    db 0		    ; no switches
seg000:20F4		    db 0		    ; no keywords
seg000:20F5 dos_pos	    dw 2000h		    ; DATA XREF: seg000:20EFo
seg000:20F5					    ; seg000:20F1o
seg000:20F7		    dw 0
seg000:20F9		    dw offset result_val
seg000:20FB		    dw offset dos_strings
seg000:20FD		    db 0
seg000:20FE		    dw 2000h
seg000:2100		    dw 0
seg000:2102		    dw offset result_val
seg000:2104		    dw offset dos_strings
seg000:2106		    db 0
seg000:2107 dos_strings	    db 3		    ; DATA XREF: seg000:20FBo
seg000:2107					    ; seg000:2104o
seg000:2107					    ; signals that there is a string choice
seg000:2108		    db 0		    ; no range definition
seg000:2109		    db 0		    ; no numeric values	choice
seg000:210A		    db 4		    ; 4	strings	for choice
seg000:210B		    db 1		    ; the 1st string tag
seg000:210C		    dw offset hi_string	    ; "HIGH"
seg000:210E		    db 2		    ; the 2nd string tag
seg000:210F		    dw offset lo_string	    ; "LOW"
seg000:2111		    db 3
seg000:2112		    dw offset umb_string    ; "UMB"
seg000:2114		    db 4
seg000:2115		    dw offset noumb_string  ; "NOUMB"
seg000:2117 hi_string	    db 'HIGH',0             ; DATA XREF: seg000:210Co
seg000:211C lo_string	    db 'LOW',0              ; DATA XREF: seg000:210Fo
seg000:2120 umb_string	    db 'UMB',0              ; DATA XREF: seg000:2112o
seg000:2124 noumb_string    db 'NOUMB',0            ; DATA XREF: seg000:2115o
seg000:212A p_dos_hi	    db 0		    ; local variable
seg000:212A					    ; ;	BUGBUG : I dont	know whether PARSER uses
seg000:212A					    ; this variable or not
seg000:212B DevSize	    dw 0		    ; DATA XREF: multi_pass+251r
seg000:212B					    ; SpaceInUMB+15r ...
seg000:212D DevLoadAddr	    dw 0		    ; DATA XREF: multi_pass+24Dr
seg000:212D					    ; InitDevLoad+37w ...
seg000:212F DevLoadEnd	    dw 0		    ; DATA XREF: multi_pass+258r
seg000:212F					    ; multi_pass+2BDr ...
seg000:2131 DevEntry	    dd 0		    ; DATA XREF: multi_pass+289r
seg000:2131					    ; multi_pass:breakokr ...
seg000:2135 DevBrkAddr	    dd 0		    ; DATA XREF: multi_pass+2DAw
seg000:2135					    ; multi_pass:foundpbr ...
seg000:2139 DevUMB	    db 0		    ; DATA XREF: multi_pass+1FFr
seg000:2139					    ; multi_pass+2E6r ...
seg000:213A DevUMBAddr	    dw 0		    ; DATA XREF: InitDevLoad+19r
seg000:213A					    ; SpaceInUMB+4r ...
seg000:213C DevUMBSize	    dw 0		    ; DATA XREF: InitDevLoad+1Er
seg000:213C					    ; SpaceInUMBr ...
seg000:213E DevUMBFree	    dw 0		    ; DATA XREF: InitDevLoad:InitForHir
seg000:213E					    ; SpaceInUMB+9r ...
seg000:2140 DevXMSAddr	    dd 0		    ; DATA XREF: InitAllocUMB+13w
seg000:2140					    ; umb_allocate+6r ...
seg000:2144 DevExecAddr	    dw 0		    ; DATA XREF: ExecDev+5w
seg000:2144					    ; ExecDev+13o
seg000:2146 DevExecReloc    dw 0		    ; DATA XREF: ExecDev+Aw
seg000:2148 DeviceHi	    db 0		    ; DATA XREF: multi_pass:NrmTstw
seg000:2148					    ; multi_pass+207w ...
seg000:2149 DevSizeOption   dw 0		    ; DATA XREF: multi_pass+21Dw
seg000:2149					    ; SizeDevice+37r ...
seg000:214B Int12Lied	    db 0		    ; DATA XREF: SetInt12Mem+16w
seg000:214B					    ; TrueInt12Memr ...
seg000:214C OldInt12Mem	    dw 0		    ; DATA XREF: SetInt12Mem+Aw
seg000:214C					    ; TrueInt12Mem+14r
seg000:214E ThreeComName    db 'PROTMAN$'           ; DATA XREF: IsIt3Com+Do
seg000:2156 FirstUMBLinked  db 0		    ; DATA XREF: InitAllocUMB+1Dr
seg000:2156					    ; InitAllocUMB+2Aw	...
seg000:2157 DevDOSData	    dw 0		    ; DATA XREF: InitAllocUMB+9w
seg000:2157					    ; umb_insert+1r ...
seg000:2159 DevCmdLine	    dw 0, 0		    ; DATA XREF: multi_pass+238w
seg000:2159					    ; ParseSize+7w ...
seg000:215D DevSavedDelim   db 0		    ; DATA XREF: multi_pass:tryu_4w
seg000:215D					    ; multi_pass+224w ...
seg000:215E
seg000:215E ; =============== S	U B R O	U T I N	E =======================================
seg000:215E
seg000:215E
seg000:215E doconf	    proc near		    ; CODE XREF: seg000:nodrvsetp
seg000:215E		    push    cs
seg000:215F		    pop	    ds
seg000:2160		    mov	    ax,	3700h
seg000:2163		    int	    21h		    ; DOS - 2+ internal	- GET SWITCHAR/AVAILDEV
seg000:2163					    ; Return: AL = FFh unsupported subfunction
seg000:2163					    ; DL = current switch character
seg000:2165		    mov	    ds:command_line+1, dl ; set	in default command line
seg000:2169		    mov	    dx,	offset config ;	"\\CONFIG.SYS"
seg000:216C		    mov	    ax,	3D00h
seg000:216F		    stc			    ; in case of int 24
seg000:2170		    int	    21h		    ; DOS - 2+ - OPEN DISK FILE	WITH HANDLE
seg000:2170					    ; DS:DX -> ASCIZ filename
seg000:2170					    ; AL = access mode
seg000:2170					    ; 0	- read
seg000:2172		    jnb	    short noprob
seg000:2174		    mov	    ds:multi_pass_id, 11
seg000:2179		    retn
seg000:217A ; ---------------------------------------------------------------------------
seg000:217A
seg000:217A noprob:				    ; CODE XREF: doconf+14j
seg000:217A		    mov	    bx,	ax	    ; get file size (note < 64k!!)
seg000:217A					    ; File handle
seg000:217C		    xor	    cx,	cx
seg000:217E		    xor	    dx,	dx
seg000:2180		    mov	    ax,	4202h
seg000:2183		    int	    21h		    ; DOS - 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
seg000:2183					    ; AL = method: offset from end of file
seg000:2185		    mov	    ds:count, ax
seg000:2188		    xor	    dx,	dx	    ; reset pointer to beginning of file
seg000:218A		    mov	    ax,	4200h
seg000:218D		    int	    21h		    ; DOS - 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
seg000:218D					    ; AL = method: offset from beginning of file
seg000:218F		    mov	    dx,	ds:top_of_cdss ; use current alloclim value
seg000:2193		    mov	    ax,	ds:count
seg000:2196		    mov	    ds:config_size, ax
seg000:2199		    call    ParaRound
seg000:219C		    sub	    dx,	ax
seg000:219E		    sub	    dx,	11h
seg000:21A1		    mov	    ds:top_of_cdss, dx
seg000:21A5		    call    TempCDS
seg000:21A8		    mov	    dx,	cs:top_of_cdss
seg000:21AD		    mov	    ds,	dx
seg000:21AF		    mov	    es,	dx
seg000:21B1		    xor	    dx,	dx
seg000:21B3		    mov	    cx,	cs:count
seg000:21B8		    mov	    ah,	3Fh
seg000:21BA		    stc
seg000:21BB		    int	    21h		    ; DOS - 2+ - READ FROM FILE	WITH HANDLE
seg000:21BB					    ; BX = file	handle,	CX = number of bytes to	read
seg000:21BB					    ; DS:DX -> buffer
seg000:21BD		    pushf		    ; find the eof mark	in the file.
seg000:21BD					    ; if present,then trim length.
seg000:21BE		    push    ax
seg000:21BF		    push    di
seg000:21C0		    push    cx
seg000:21C1		    mov	    al,	1Ah	    ; eof mark
seg000:21C3		    mov	    di,	dx	    ; point to buffer
seg000:21C5		    jcxz    short puteol    ; no chars
seg000:21C7		    repne scasb		    ; find end
seg000:21C9		    jnz	    short puteol    ; none found and count exhausted
seg000:21CB		    dec	    di		    ; backup past 1Ah
seg000:21CC
seg000:21CC puteol:				    ; CODE XREF: doconf+67j
seg000:21CC					    ; doconf+6Bj
seg000:21CC		    mov	    al,	0Dh	    ; cr
seg000:21CE		    stosb
seg000:21CF		    mov	    al,	0Ah	    ; lf
seg000:21D1		    stosb
seg000:21D2		    sub	    di,	dx	    ; difference moved
seg000:21D4		    mov	    cs:count, di    ; new count
seg000:21D9		    pop	    cx
seg000:21DA		    pop	    di
seg000:21DB		    pop	    ax
seg000:21DC		    push    cs
seg000:21DD		    pop	    ds
seg000:21DE		    push    ax
seg000:21DF		    mov	    ah,	3Eh
seg000:21E1		    int	    21h		    ; DOS - 2+ - CLOSE A FILE WITH HANDLE
seg000:21E1					    ; BX = file	handle
seg000:21E3		    pop	    ax
seg000:21E4		    popf
seg000:21E5		    jb	    short conferr   ; we've got a problem
seg000:21E7		    cmp	    cx,	ax
seg000:21E9		    jz	    short getcom    ; couldn't read the file
seg000:21EB
seg000:21EB conferr:				    ; CODE XREF: doconf+87j
seg000:21EB		    mov	    dx,	offset config ;	want to	print config error
seg000:21EE		    call    badfil
seg000:21F1
seg000:21F1 endconv:				    ; CODE XREF: multi_pass+7j
seg000:21F1					    ; multi_pass:conflpj ...
seg000:21F1		    retn
seg000:21F1 doconf	    endp
seg000:21F1
seg000:21F2
seg000:21F2 ; =============== S	U B R O	U T I N	E =======================================
seg000:21F2
seg000:21F2
seg000:21F2 multi_pass	    proc near		    ; CODE XREF: seg000:0779p
seg000:21F2					    ; seg000:0787p ...
seg000:21F2
seg000:21F2 ; FUNCTION CHUNK AT	seg000:0899 SIZE 00000002 BYTES
seg000:21F2 ; FUNCTION CHUNK AT	seg000:278E SIZE 0000025B BYTES
seg000:21F2 ; FUNCTION CHUNK AT	seg000:2A1C SIZE 0000000C BYTES
seg000:21F2 ; FUNCTION CHUNK AT	seg000:34D5 SIZE 0000000B BYTES
seg000:21F2
seg000:21F2		    push    cs
seg000:21F3		    pop	    ds
seg000:21F4		    cmp	    ds:multi_pass_id, 10
seg000:21F9		    jnb	    short endconv
seg000:21FB		    push    ds:top_of_cdss
seg000:21FF		    pop	    es
seg000:2200		    mov	    si,	ds:org_count
seg000:2204		    mov	    ds:count, si
seg000:2208		    xor	    si,	si
seg000:220A		    mov	    ds:chrptr, si
seg000:220E		    mov	    ds:linecount, si
seg000:2212		    call    getchr
seg000:2215		    jmp	    short conflp
seg000:2217 ; ---------------------------------------------------------------------------
seg000:2217
seg000:2217 getcom:				    ; CODE XREF: doconf+8Bj
seg000:2217		    call    organize
seg000:221A		    call    getchr
seg000:221D
seg000:221D conflp:				    ; CODE XREF: multi_pass+23j
seg000:221D					    ; multi_pass+55j ...
seg000:221D		    jb	    short endconv
seg000:221F		    inc	    ds:linecount
seg000:2223		    mov	    ds:multdeviceflag, 0
seg000:2228		    mov	    ds:setdevmarkflag, 0
seg000:222D		    cmp	    al,	0Ah	    ; lf
seg000:222F		    jz	    short blank_line ; ignore this line
seg000:2231		    mov	    ah,	al
seg000:2233		    call    getchr
seg000:2236		    jnb	    short tryi
seg000:2238		    cmp	    ds:multi_pass_id, 2
seg000:223D		    jnb	    short endconv
seg000:223F		    jmp	    badop
seg000:2242 ; ---------------------------------------------------------------------------
seg000:2242
seg000:2242 coff:				    ; CODE XREF: multi_pass:multi_pass_coff2j
seg000:2242					    ; multi_pass+8Fj ...
seg000:2242		    push    cs
seg000:2243		    pop	    ds
seg000:2244		    call    newline
seg000:2247		    jmp	    short conflp
seg000:2249 ; ---------------------------------------------------------------------------
seg000:2249
seg000:2249 blank_line:				    ; CODE XREF: multi_pass+3Dj
seg000:2249		    call    getchr
seg000:224C		    jmp	    short conflp
seg000:224E ; ---------------------------------------------------------------------------
seg000:224E		    push    cs
seg000:224F		    pop	    ds
seg000:2250
seg000:2250 tryi:				    ; CODE XREF: multi_pass+44j
seg000:2250		    cmp	    ds:multi_pass_id, 0	; install command
seg000:2250					    ; the initial pass for DOS=HI
seg000:2255		    jnz	    short not_init_pass
seg000:2257		    jmp	    multi_try_doshi
seg000:225A ; ---------------------------------------------------------------------------
seg000:225A
seg000:225A not_init_pass:			    ; CODE XREF: multi_pass+63j
seg000:225A		    cmp	    ds:multi_pass_id, 2	; the second pass was for ifs=
seg000:225F		    jz	    short multi_pass_coff ; now	it is NOPs
seg000:2261		    cmp	    ds:multi_pass_id, 3	; the third pass for install= ?
seg000:2266		    jz	    short multi_try_i
seg000:2268		    cmp	    ah,	'H'         ; CONFIG_DOS
seg000:226B		    jz	    short multi_pass_coff
seg000:226D		    cmp	    ah,	'I'         ; CONFIG_INSTALL
seg000:2270		    jnz	    short tryb
seg000:2272		    or	    ds:install_flag, 1 ; have_install_cmd
seg000:2277
seg000:2277 multi_pass_coff2:
seg000:2277		    jmp	    short coff
seg000:2279 ; ---------------------------------------------------------------------------
seg000:2279
seg000:2279 multi_try_i:			    ; CODE XREF: multi_pass+74j
seg000:2279		    cmp	    ah,	'I'         ; CONFIG_INSTALL
seg000:227C		    jnz	    short multi_pass_filter
seg000:227E		    call    do_install_exec
seg000:2281		    jmp	    short coff
seg000:2283 ; ---------------------------------------------------------------------------
seg000:2283
seg000:2283 multi_pass_filter:			    ; CODE XREF: multi_pass+8Aj
seg000:2283					    ; multi_pass+19Fj
seg000:2283		    cmp	    ah,	'Y'         ; CONFIG_COMMENT
seg000:2286		    jz	    short multi_pass_adjust
seg000:2288		    cmp	    ah,	'Z'         ; CONFIG_UNKNOWN
seg000:228B		    jz	    short multi_pass_adjust
seg000:228D		    cmp	    ah,	'0'         ; CONFIG_REM
seg000:2290		    jnz	    short multi_pass_coff ; ignore the rest of the commands
seg000:2292
seg000:2292 multi_pass_adjust:			    ; CODE XREF: multi_pass+94j
seg000:2292					    ; multi_pass+99j
seg000:2292		    dec	    ds:chrptr
seg000:2296		    inc	    ds:count
seg000:229A
seg000:229A multi_pass_coff:			    ; CODE XREF: multi_pass+6Dj
seg000:229A					    ; multi_pass+79j ...
seg000:229A		    jmp	    short coff	    ; to handle	next install= commands.
seg000:229C ; ---------------------------------------------------------------------------
seg000:229C
seg000:229C tryb:				    ; CODE XREF: multi_pass+7Ej
seg000:229C		    cmp	    ah,	'B'         ; buffer command
seg000:229C					    ; CONFIG_BUFFERS
seg000:229F		    jnz	    short tryc
seg000:22A1		    mov	    ds:p_buffer_slash_x, 0
seg000:22A6		    mov	    di,	offset buf_parms
seg000:22A9		    xor	    cx,	cx
seg000:22AB		    mov	    dx,	cx
seg000:22AD
seg000:22AD do7:				    ; CODE XREF: multi_pass:en11j
seg000:22AD		    call    sysinit_parse
seg000:22B0		    jnb	    short if7
seg000:22B2		    call    badparm_p
seg000:22B5		    jmp	    short sr7
seg000:22B7 ; ---------------------------------------------------------------------------
seg000:22B7
seg000:22B7 if7:				    ; CODE XREF: multi_pass+BEj
seg000:22B7		    cmp	    ax,	0FFFFh	    ; _$P_RC_EOL
seg000:22B7					    ; end of line?
seg000:22BA		    jz	    short en7
seg000:22BC		    cmp	    ds:result_val_swoff, offset	switch_x ; "/X"
seg000:22C2		    jnz	    short if11
seg000:22C4		    jmp	    short en11
seg000:22C6 ; ---------------------------------------------------------------------------
seg000:22C6
seg000:22C6 if11:				    ; CODE XREF: multi_pass+D0j
seg000:22C6		    mov	    ax,	word ptr ds:rv_dword
seg000:22C9		    cmp	    cx,	1
seg000:22CC		    jnz	    short if13
seg000:22CE		    mov	    ds:p_buffers, ax
seg000:22D1		    jmp	    short en11
seg000:22D3 ; ---------------------------------------------------------------------------
seg000:22D3
seg000:22D3 if13:				    ; CODE XREF: multi_pass+DAj
seg000:22D3		    mov	    ds:p_h_buffers, ax
seg000:22D6
seg000:22D6 en11:				    ; CODE XREF: multi_pass+D2j
seg000:22D6					    ; multi_pass+DFj
seg000:22D6		    jmp	    short do7
seg000:22D8 ; ---------------------------------------------------------------------------
seg000:22D8
seg000:22D8 en7:				    ; CODE XREF: multi_pass+C8j
seg000:22D8		    cmp	    ds:p_buffers, 99
seg000:22DD		    jbe	    short if18
seg000:22DF		    call    badparm_p
seg000:22E2		    mov	    ds:p_h_buffers, 0
seg000:22E8		    jmp	    short sr7
seg000:22EA ; ---------------------------------------------------------------------------
seg000:22EA
seg000:22EA if18:				    ; CODE XREF: multi_pass+EBj
seg000:22EA		    mov	    ax,	ds:p_buffers ; we don't have any problem.
seg000:22ED		    mov	    ds:buffers,	ax  ; now,let's set it really.
seg000:22F0		    mov	    ax,	ds:p_h_buffers
seg000:22F3		    mov	    ds:h_buffers, ax
seg000:22F6		    mov	    ax,	ds:linecount
seg000:22F9		    mov	    ds:buffer_linenum, ax ; save the line number for the future	use
seg000:22FC
seg000:22FC sr7:				    ; CODE XREF: multi_pass+C3j
seg000:22FC					    ; multi_pass+F6j
seg000:22FC		    jmp	    coff
seg000:22FF ; ---------------------------------------------------------------------------
seg000:22FF
seg000:22FF tryc:				    ; CODE XREF: multi_pass+ADj
seg000:22FF		    cmp	    ah,	'C'         ; break command
seg000:22FF					    ; CONFIG_BREAK
seg000:2302		    jnz	    short trym
seg000:2304		    mov	    di,	offset brk_parms
seg000:2307		    xor	    cx,	cx
seg000:2309		    mov	    dx,	cx
seg000:230B
seg000:230B do22:				    ; CODE XREF: multi_pass:en26j
seg000:230B		    call    sysinit_parse
seg000:230E		    jnb	    short if22
seg000:2310		    call    badparm_p
seg000:2313		    jmp	    short sr22
seg000:2315 ; ---------------------------------------------------------------------------
seg000:2315
seg000:2315 if22:				    ; CODE XREF: multi_pass+11Cj
seg000:2315		    cmp	    ax,	0FFFFh	    ; _$P_RC_EOL
seg000:2318		    jz	    short en22
seg000:231A		    cmp	    ds:result_val_itag,	1
seg000:231F		    jnz	    short if26
seg000:2321		    mov	    ds:p_ctrl_break, 1 ; turn it on
seg000:2326		    jmp	    short en26
seg000:2328 ; ---------------------------------------------------------------------------
seg000:2328
seg000:2328 if26:				    ; CODE XREF: multi_pass+12Dj
seg000:2328		    mov	    ds:p_ctrl_break, 0 ; turn it off
seg000:232D
seg000:232D en26:				    ; CODE XREF: multi_pass+134j
seg000:232D		    jmp	    short do22
seg000:232F ; ---------------------------------------------------------------------------
seg000:232F
seg000:232F en22:				    ; CODE XREF: multi_pass+126j
seg000:232F		    mov	    ah,	33h	    ; SET_CTRL_C_TRAPPING
seg000:2331		    mov	    al,	1
seg000:2333		    mov	    dl,	ds:p_ctrl_break
seg000:2337		    int	    21h		    ; DOS - EXTENDED CONTROL-BREAK CHECKING
seg000:2337					    ; AL = 00h get state / 01h set state / 02h set AND get
seg000:2337					    ; DL = 00h for OFF or 01h for ON
seg000:2339
seg000:2339 sr22:				    ; CODE XREF: multi_pass+121j
seg000:2339		    jmp	    coff
seg000:233C ; ---------------------------------------------------------------------------
seg000:233C
seg000:233C trym:				    ; CODE XREF: multi_pass+110j
seg000:233C		    cmp	    ah,	'M'         ; multitrack command
seg000:233C					    ; CONFIG_MULTITRACK
seg000:233F		    jnz	    short tryu
seg000:2341		    mov	    di,	offset mtrk_parms
seg000:2344		    xor	    cx,	cx
seg000:2346		    mov	    dx,	cx
seg000:2348
seg000:2348 do31:				    ; CODE XREF: multi_pass:en35j
seg000:2348		    call    sysinit_parse
seg000:234B		    jnb	    short if31
seg000:234D		    call    badparm_p
seg000:2350		    jmp	    short sr31
seg000:2352 ; ---------------------------------------------------------------------------
seg000:2352
seg000:2352 if31:				    ; CODE XREF: multi_pass+159j
seg000:2352		    cmp	    ax,	0FFFFh	    ; _$P_RC_EOL
seg000:2352					    ; end of line?
seg000:2355		    jz	    short en31
seg000:2357		    cmp	    ds:result_val_itag,	1
seg000:235C		    jnz	    short if35
seg000:235E		    mov	    ds:p_mtrk, 1    ; turn it on temporarily
seg000:2363		    jmp	    short en35
seg000:2365 ; ---------------------------------------------------------------------------
seg000:2365
seg000:2365 if35:				    ; CODE XREF: multi_pass+16Aj
seg000:2365		    mov	    ds:p_mtrk, 0    ; turn it off temporarily
seg000:236A
seg000:236A en35:				    ; CODE XREF: multi_pass+171j
seg000:236A		    jmp	    short do31
seg000:236C ; ---------------------------------------------------------------------------
seg000:236C
seg000:236C en31:				    ; CODE XREF: multi_pass+163j
seg000:236C		    push    ds
seg000:236D		    mov	    ax,	70h	    ; DOSBIODATASEG (DOS BIOS Data Segment)
seg000:2370		    mov	    ds,	ax
seg000:2372		    assume ds:nothing
seg000:2372		    cmp	    cs:p_mtrk, 0
seg000:2378		    jnz	    short if39
seg000:237A		    mov	    word ptr ds:52Fh, 1	; [multrk_flag],
seg000:237A					    ; multrk_off2
seg000:2380		    jmp	    short en39
seg000:2382 ; ---------------------------------------------------------------------------
seg000:2382
seg000:2382 if39:				    ; CODE XREF: multi_pass+186j
seg000:2382		    mov	    word ptr ds:52Fh, 80h ; [multrk_flag],
seg000:2382					    ; multrk_on
seg000:2388
seg000:2388 en39:				    ; CODE XREF: multi_pass+18Ej
seg000:2388		    pop	    ds
seg000:2389		    assume ds:nothing
seg000:2389
seg000:2389 sr31:				    ; CODE XREF: multi_pass+15Ej
seg000:2389		    jmp	    coff
seg000:238C ; ---------------------------------------------------------------------------
seg000:238C
seg000:238C multi_try_doshi:			    ; CODE XREF: multi_pass+65j
seg000:238C		    cmp	    ah,	'H'         ; DOS=HIGH/LOW command
seg000:238C					    ; CONFIG_DOS
seg000:238F		    jz	    short it_is_h
seg000:2391		    jmp	    multi_pass_filter
seg000:2394 ; ---------------------------------------------------------------------------
seg000:2394
seg000:2394 it_is_h:				    ; CODE XREF: multi_pass+19Dj
seg000:2394		    mov	    di,	offset dos_parms
seg000:2397		    xor	    cx,	cx
seg000:2399		    mov	    dx,	cx
seg000:239B
seg000:239B h_do_parse:				    ; CODE XREF: multi_pass+1BBj
seg000:239B		    call    sysinit_parse
seg000:239E		    jnb	    short h_parse_ok
seg000:23A0		    call    badparm_p
seg000:23A3		    jmp	    short h_end
seg000:23A5 ; ---------------------------------------------------------------------------
seg000:23A5
seg000:23A5 h_parse_ok:				    ; CODE XREF: multi_pass+1ACj
seg000:23A5		    cmp	    ax,	0FFFFh	    ; _$P_RC_EOL
seg000:23A5					    ; end of line?
seg000:23A8		    jz	    short h_end
seg000:23AA		    call    ProcDOS
seg000:23AD		    jmp	    short h_do_parse
seg000:23AF ; ---------------------------------------------------------------------------
seg000:23AF
seg000:23AF h_end:				    ; CODE XREF: multi_pass+1B1j
seg000:23AF					    ; multi_pass+1B6j
seg000:23AF		    jmp	    coff
seg000:23B2 ; ---------------------------------------------------------------------------
seg000:23B2
seg000:23B2 tryu:				    ; CODE XREF: multi_pass+14Dj
seg000:23B2		    cmp	    ah,	'U'         ; devicehigh command
seg000:23B2					    ; CONFIG_DEVICEHIGH
seg000:23B5		    jnz	    short tryd
seg000:23B7		    mov	    word ptr cs:badparm_ptr, si
seg000:23BC		    mov	    word ptr cs:badparm_ptr+2, es
seg000:23C1		    call    ParseSize
seg000:23C4		    jnb	    short tryu_0
seg000:23C6		    call    badparm_p
seg000:23C9		    jmp	    coff
seg000:23CC ; ---------------------------------------------------------------------------
seg000:23CC
seg000:23CC tryu_0:				    ; CODE XREF: multi_pass+1D2j
seg000:23CC		    push    si
seg000:23CD		    push    es
seg000:23CE
seg000:23CE tryu_3:				    ; CODE XREF: multi_pass+1EDj
seg000:23CE		    mov	    al,	es:[si]
seg000:23D1		    cmp	    al,	0Dh	    ; cr
seg000:23D3		    jz	    short tryu_4
seg000:23D5		    cmp	    al,	0Ah	    ; lf
seg000:23D7		    jz	    short tryu_4
seg000:23D9		    call    delim
seg000:23DC		    jz	    short tryu_4
seg000:23DE		    inc	    si
seg000:23DF		    jmp	    short tryu_3
seg000:23E1 ; ---------------------------------------------------------------------------
seg000:23E1
seg000:23E1 tryu_4:				    ; CODE XREF: multi_pass+1E1j
seg000:23E1					    ; multi_pass+1E5j ...
seg000:23E1		    mov	    cs:DevSavedDelim, al
seg000:23E5		    mov	    byte ptr es:[si], 0
seg000:23E9		    pop	    es
seg000:23EA		    pop	    si
seg000:23EB
seg000:23EB NrmTst:
seg000:23EB		    mov	    cs:DeviceHi, 0
seg000:23F1		    cmp	    cs:DevUMB, 0
seg000:23F7		    jz	    short LoadDevice
seg000:23F9		    mov	    cs:DeviceHi, 1
seg000:23FF		    jmp	    short LoadDevice
seg000:2401 ; ---------------------------------------------------------------------------
seg000:2401
seg000:2401 tryd:				    ; CODE XREF: multi_pass+1C3j
seg000:2401		    cmp	    ah,	'D'         ; device command
seg000:2401					    ; CONFIG_DEVICE
seg000:2404		    jz	    short gotd
seg000:2406		    jmp	    tryq
seg000:2409 ; ---------------------------------------------------------------------------
seg000:2409
seg000:2409 gotd:				    ; CODE XREF: multi_pass+212j
seg000:2409		    mov	    cs:DeviceHi, 0
seg000:240F		    mov	    cs:DevSizeOption, 0
seg000:2416		    mov	    cs:DevSavedDelim, 20h ; ' '
seg000:241C
seg000:241C LoadDevice:				    ; CODE XREF: multi_pass+205j
seg000:241C					    ; multi_pass+20Dj
seg000:241C		    mov	    bx,	cs
seg000:241E		    mov	    ds,	bx
seg000:2420		    mov	    word ptr cs:bpb_addr, si
seg000:2425		    mov	    word ptr cs:bpb_addr+2, es
seg000:242A		    mov	    cs:DevCmdLine, si
seg000:242F		    mov	    cs:DevCmdLine+2, es
seg000:2434		    call    round
seg000:2437		    call    SizeDevice
seg000:243A		    jb	    short BadFile
seg000:243C
seg000:243C DevConvLoad:
seg000:243C		    call    InitDevLoad
seg000:243F		    mov	    ax,	cs:DevLoadAddr
seg000:2443		    add	    ax,	cs:DevSize
seg000:2448		    jb	    short NoMem
seg000:244A		    cmp	    cs:DevLoadEnd, ax
seg000:244F		    jnb	    short LoadDev
seg000:2451
seg000:2451 NoMem:				    ; CODE XREF: multi_pass+256j
seg000:2451		    jmp	    memerr
seg000:2454 ; ---------------------------------------------------------------------------
seg000:2454
seg000:2454 BadFile:				    ; CODE XREF: multi_pass+248j
seg000:2454					    ; multi_pass+27Cj ...
seg000:2454		    cmp	    byte ptr es:[si], 0Dh ; cr
seg000:2458		    jnz	    short tryd_2
seg000:245A		    jmp	    badop
seg000:245D ; ---------------------------------------------------------------------------
seg000:245D
seg000:245D tryd_2:				    ; CODE XREF: multi_pass+266j
seg000:245D		    call    badload
seg000:2460		    jmp	    coff
seg000:2463 ; ---------------------------------------------------------------------------
seg000:2463
seg000:2463 LoadDev:				    ; CODE XREF: multi_pass+25Dj
seg000:2463		    push    es
seg000:2464		    pop	    ds
seg000:2465		    mov	    dx,	si	    ; ds:dx points to file name
seg000:2467		    call    ExecDev	    ; load device driver using exec call
seg000:246A		    push    ds
seg000:246B		    pop	    es		    ; es:si back to config.sys
seg000:246C		    push    cs
seg000:246D		    pop	    ds		    ; ds back to sysinit
seg000:246E		    jb	    short BadFile
seg000:2470
seg000:2470 goodld:				    ; CODE XREF: multi_pass+454j
seg000:2470		    push    es
seg000:2471		    push    si
seg000:2472		    call    RemoveNull
seg000:2475		    push    es
seg000:2476		    push    si
seg000:2477		    push    cs
seg000:2478		    pop	    es
seg000:2479		    push    ds
seg000:247A		    push    si
seg000:247B		    lds	    si,	cs:DevEntry ; peeks the	header attribute
seg000:2480		    test    word ptr [si+4], 8000h
seg000:2485		    jnz	    short got_device_com_cont
seg000:2487		    lds	    si,	cs:DOSINFO  ; ds:si -> sys_var
seg000:248C		    cmp	    byte ptr [si+32], 26 ; [si+SYSI_NUMIO]
seg000:248C					    ; no more than 26 drive number
seg000:2490		    jb	    short got_device_com_cont
seg000:2492		    pop	    si
seg000:2493		    pop	    ds
seg000:2494		    pop	    si
seg000:2495		    pop	    es
seg000:2496		    jmp	    short badnumblock
seg000:2498 ; ---------------------------------------------------------------------------
seg000:2498
seg000:2498 got_device_com_cont:		    ; CODE XREF: multi_pass+293j
seg000:2498					    ; multi_pass+29Ej
seg000:2498		    pop	    si
seg000:2499		    pop	    ds
seg000:249A		    call    LieInt12Mem
seg000:249D		    call    UpdatePDB	    ; update the PSP:2 value
seg000:24A0		    cmp	    cs:multdeviceflag, 0
seg000:24A6		    jnz	    short skip_pass_limit
seg000:24A8		    mov	    word ptr cs:break_addr, 0
seg000:24AF		    mov	    bx,	cs:DevLoadEnd
seg000:24B4		    mov	    word ptr cs:break_addr+2, bx
seg000:24B9
seg000:24B9 skip_pass_limit:			    ; CODE XREF: multi_pass+2B4j
seg000:24B9		    mov	    bx,	6	    ; SYSDEV.STRAT
seg000:24BC		    call    calldev
seg000:24BF		    mov	    bx,	8	    ; SYSDEV.INT
seg000:24C2		    call    calldev
seg000:24C5		    call    TrueInt12Mem
seg000:24C8		    mov	    ax,	word ptr cs:break_addr
seg000:24CC		    mov	    word ptr cs:DevBrkAddr, ax
seg000:24D0		    mov	    ax,	word ptr cs:break_addr+2
seg000:24D4		    mov	    word ptr cs:DevBrkAddr+2, ax
seg000:24D8		    cmp	    cs:DevUMB, 0
seg000:24DE		    jz	    short tryd_3
seg000:24E0		    call    AllocUMB
seg000:24E3
seg000:24E3 tryd_3:				    ; CODE XREF: multi_pass+2ECj
seg000:24E3		    cmp	    cs:runhigh,	0FFh
seg000:24E9		    jnz	    short tryd_4
seg000:24EB		    call    TryToMovDOSHi   ; move DOS into HMA	if reqd
seg000:24EE
seg000:24EE tryd_4:				    ; CODE XREF: multi_pass+2F7j
seg000:24EE		    pop	    si
seg000:24EF		    pop	    ds
seg000:24F0		    mov	    byte ptr [si], 0
seg000:24F3		    push    cs
seg000:24F4		    pop	    ds
seg000:24F5		    jmp	    short was_device_com
seg000:24F7 ; ---------------------------------------------------------------------------
seg000:24F7
seg000:24F7 badnumblock:			    ; CODE XREF: multi_pass+2A4j
seg000:24F7					    ; multi_pass+38Fj
seg000:24F7		    push    cs
seg000:24F8		    pop	    ds
seg000:24F9		    mov	    dx,	offset badblock	; "\r\nToo many	block devices\r\n$"
seg000:24FC		    call    print
seg000:24FF
seg000:24FF erase_dev_do:			    ; CODE XREF: multi_pass:jc_eddj
seg000:24FF					    ; multi_pass+378j
seg000:24FF		    pop	    si		    ; modified to show message "error in config.sys..."
seg000:2500		    pop	    es
seg000:2501		    push    cs
seg000:2502		    pop	    ds
seg000:2503		    cmp	    cs:configmsgflag, 0
seg000:2509		    jz	    short no_error_line_msg
seg000:250B		    call    error_line
seg000:250E		    mov	    cs:configmsgflag, 0
seg000:2515
seg000:2515 no_error_line_msg:			    ; CODE XREF: multi_pass+317j
seg000:2515		    jmp	    coff
seg000:2518 ; ---------------------------------------------------------------------------
seg000:2518
seg000:2518 was_device_com:			    ; CODE XREF: multi_pass+303j
seg000:2518		    mov	    ax,	word ptr cs:DevBrkAddr+2
seg000:251C		    cmp	    ax,	cs:DevLoadEnd
seg000:2521		    jbe	    short breakok
seg000:2523		    pop	    si
seg000:2524		    pop	    es
seg000:2525		    jmp	    BadFile
seg000:2528 ; ---------------------------------------------------------------------------
seg000:2528
seg000:2528 breakok:				    ; CODE XREF: multi_pass+32Fj
seg000:2528		    lds	    dx,	cs:DevEntry
seg000:252D		    mov	    si,	dx
seg000:252F		    les	    di,	cs:DOSINFO
seg000:2534		    mov	    ax,	[si+4]	    ; [si+SYSDEV.ATT]
seg000:2537		    test    ax,	8000h	    ; DEVTYP
seg000:2537					    ; test if block dev
seg000:253A		    jz	    short isblock
seg000:253C		    or	    cs:setdevmarkflag, 2 ; for_devmark
seg000:2542		    call    DevSetBreak
seg000:2545
seg000:2545 jc_edd:				    ; CODE XREF: multi_pass+39Bj
seg000:2545		    jb	    short erase_dev_do
seg000:2547		    test    ax,	1	    ; ISCIN
seg000:2547					    ; is it a console in?
seg000:254A		    jz	    short tryclk
seg000:254C		    mov	    es:[di+12],	dx  ; [es:di+SYSI_CON]
seg000:2550		    mov	    word ptr es:[di+14], ds ; [es:di+SYSI_CON+2]
seg000:2554
seg000:2554 tryclk:				    ; CODE XREF: multi_pass+358j
seg000:2554		    test    ax,	8	    ; ISCLOCK
seg000:2554					    ; is it a clock device?
seg000:2557		    jz	    short golink
seg000:2559		    mov	    es:[di+8], dx   ; [es:di+SYSI_CLOCK]
seg000:255D		    mov	    word ptr es:[di+10], ds ; [es:di+SYSI_CLOCK+2]
seg000:2561
seg000:2561 golink:				    ; CODE XREF: multi_pass+365j
seg000:2561		    jmp	    linkit
seg000:2564 ; ---------------------------------------------------------------------------
seg000:2564
seg000:2564 isblock:				    ; CODE XREF: multi_pass+348j
seg000:2564		    mov	    al,	cs:unitcount
seg000:2568		    or	    al,	al
seg000:256A		    jz	    short erase_dev_do
seg000:256C		    mov	    [si+10], al	    ; [si+SYSDEV.NAME]
seg000:256C					    ; number of	units in name field
seg000:256F		    cbw
seg000:2570		    mov	    cx,	ax
seg000:2572		    mov	    dh,	ah
seg000:2574		    mov	    dl,	es:[di+32]  ; [es:di+SYSI_NUMIO]
seg000:2574					    ; get number of devices
seg000:2578		    mov	    ah,	dl
seg000:257A		    add	    ah,	al
seg000:257C		    cmp	    ah,	26	    ; check for	too many devices
seg000:257F		    jbe	    short ok_block
seg000:2581		    jmp	    badnumblock
seg000:2584 ; ---------------------------------------------------------------------------
seg000:2584
seg000:2584 ok_block:				    ; CODE XREF: multi_pass+38Dj
seg000:2584		    or	    cs:setdevmarkflag, 2 ; for_devmark
seg000:258A		    call    DevSetBreak
seg000:258D		    jb	    short jc_edd
seg000:258F		    add	    es:[di+32],	al  ; [es:di+SYSI_NUMIO]
seg000:258F					    ; update the amount
seg000:2593		    add	    cs:devdrivenum, al ; remember amount for next device
seg000:2598		    lds	    bx,	dword ptr cs:bpb_addr ;	point to bpb array
seg000:259D
seg000:259D perunit:				    ; CODE XREF: multi_pass+41Bj
seg000:259D		    les	    bp,	cs:DOSINFO
seg000:25A2		    les	    bp,	es:[bp+0]   ; [es:bp+SYSI_DPB]
seg000:25A6
seg000:25A6 scandpb:				    ; CODE XREF: multi_pass+3BFj
seg000:25A6		    cmp	    word ptr es:[bp+25], 0FFFFh	; [es:bp+DPB.NEXT_DPB]
seg000:25AB		    jz	    short foundpb
seg000:25AD		    les	    bp,	es:[bp+25]  ; [es:bp+DPB.NEXT_DPB]
seg000:25B1		    jmp	    short scandpb
seg000:25B3 ; ---------------------------------------------------------------------------
seg000:25B3
seg000:25B3 foundpb:				    ; CODE XREF: multi_pass+3B9j
seg000:25B3		    mov	    ax,	word ptr cs:DevBrkAddr
seg000:25B7		    mov	    es:[bp+25],	ax  ; [es:bp+DPB.NEXT_DPB]
seg000:25BB		    mov	    ax,	word ptr cs:DevBrkAddr+2
seg000:25BF		    mov	    es:[bp+27],	ax  ; [es:bp+DPB.NEXT_DPB+2]
seg000:25C3		    les	    bp,	cs:DevBrkAddr
seg000:25C8		    add	    word ptr cs:DevBrkAddr, 33 ; DPBSIZ
seg000:25CE		    call    RoundBreakAddr
seg000:25D1		    mov	    word ptr es:[bp+25], 0FFFFh
seg000:25D7		    mov	    byte ptr es:[bp+24], 0FFh ;	[es:bp+DPB.FIRST_ACCESS]
seg000:25DC		    mov	    si,	[bx]	    ; ds:si points to bpb
seg000:25DE		    inc	    bx
seg000:25DF		    inc	    bx
seg000:25E0		    mov	    es:[bp+0], dx
seg000:25E4		    mov	    ah,	53h	    ; SETDPB
seg000:25E6		    int	    21h		    ; DOS - 2+ internal	- TRANSLATE BIOS PARAMETER BLOCK
seg000:25E6					    ; DS:SI -> BPB (BIOS Parameter Block)
seg000:25E6					    ; ES:BP -> buffer for DOS Drive Parameter Block
seg000:25E8		    mov	    ax,	es:[bp+2]   ; [es:bp+DPB.SECTOR_SIZE]
seg000:25EC		    push    es
seg000:25ED		    les	    di,	cs:DOSINFO
seg000:25F2		    cmp	    ax,	es:[di+10h] ; [es:di+SYSI_MAXSEC]
seg000:25F6		    pop	    es
seg000:25F7		    ja	    short bad_bpb_size_sector
seg000:25F9
seg000:25F9 iblk_1:
seg000:25F9		    push    ds
seg000:25FA		    push    dx
seg000:25FB		    lds	    dx,	cs:DevEntry
seg000:2600		    mov	    es:[bp+13h], dx ; [es:bp+DPB.DRIVER_ADDR]
seg000:2604		    mov	    word ptr es:[bp+15h], ds ; [es:bp+DPB.DRIVER_ADDR+2]
seg000:2608		    pop	    dx
seg000:2609		    pop	    ds
seg000:260A		    inc	    dx
seg000:260B		    inc	    dh
seg000:260D		    loop    perunit
seg000:260F		    push    cs
seg000:2610		    pop	    ds
seg000:2611		    call    TempCDS	    ; set cds for new drives
seg000:2614
seg000:2614 linkit:				    ; CODE XREF: multi_pass:golinkj
seg000:2614		    les	    di,	cs:DOSINFO  ; es:di = dos (SYSVARS) table
seg000:2619		    mov	    cx,	es:[di+22h] ; [es:di+SYSI_DEV]
seg000:261D		    mov	    dx,	es:[di+24h] ; [es:di+SYSI_DEV+2]
seg000:261D					    ; dx:cx = head of list
seg000:2621		    lds	    si,	cs:DevEntry ; ds:si = device location
seg000:2626		    mov	    es:[di+22h], si ; set head of list in dos
seg000:262A		    mov	    word ptr es:[di+24h], ds
seg000:262E		    mov	    ax,	[si]	    ; get pointer to next device
seg000:2630		    mov	    word ptr cs:DevEntry, ax ; and save	it
seg000:2634		    mov	    [si], cx	    ; link in the driver
seg000:2636		    mov	    [si+2], dx
seg000:2639
seg000:2639 enddev:
seg000:2639		    pop	    si
seg000:263A		    pop	    es
seg000:263B		    inc	    ax		    ; ax = ffff	(no more devs if yes)?
seg000:263C		    jz	    short coffj3
seg000:263E		    inc	    cs:multdeviceflag ;	possibly multiple device driver
seg000:2643		    call    DevBreak
seg000:2646		    jmp	    goodld
seg000:2649 ; ---------------------------------------------------------------------------
seg000:2649
seg000:2649 coffj3:				    ; CODE XREF: multi_pass+44Aj
seg000:2649		    mov	    cs:multdeviceflag, 0 ; reset the flag
seg000:264F		    call    DevBreak
seg000:2652		    jmp	    coff
seg000:2655 ; ---------------------------------------------------------------------------
seg000:2655
seg000:2655 bad_bpb_size_sector:		    ; CODE XREF: multi_pass+405j
seg000:2655		    pop	    si
seg000:2656		    pop	    es
seg000:2657		    mov	    dx,	offset badsiz_pre ; "\r\nSector	size too large in file $"
seg000:265A		    mov	    bx,	offset crlfm ; "\r\n$"
seg000:265D		    call    prnerr
seg000:2660		    jmp	    coff
seg000:2663 ; ---------------------------------------------------------------------------
seg000:2663
seg000:2663 tryq:				    ; CODE XREF: multi_pass+214j
seg000:2663		    cmp	    ah,	'Q'         ; country command
seg000:2663					    ; CONFIG_COUNTRY
seg000:2666		    jz	    short tryq_cont
seg000:2668		    jmp	    tryf
seg000:266B ; ---------------------------------------------------------------------------
seg000:266B
seg000:266B tryq_cont:				    ; CODE XREF: multi_pass+474j
seg000:266B		    mov	    byte ptr cs:cntry_drv, 0 ; reset the drive,path to default value
seg000:2671		    mov	    cs:p_code_page, 0
seg000:2678		    mov	    di,	offset cntry_parms
seg000:267B		    xor	    cx,	cx
seg000:267D		    mov	    dx,	cx
seg000:267F
seg000:267F do52:				    ; CODE XREF: multi_pass:en56j
seg000:267F		    call    sysinit_parse
seg000:2682		    jnb	    short if52
seg000:2684		    call    cntry_error
seg000:2687		    mov	    cs:p_cntry_code, 0FFFFh ; show message and end the search loop
seg000:2687					    ; signals that parse error
seg000:268E		    jmp	    short sr52	    ; then end the search loop
seg000:2690 ; ---------------------------------------------------------------------------
seg000:2690
seg000:2690 if52:				    ; CODE XREF: multi_pass+490j
seg000:2690		    cmp	    ax,	0FFFFh	    ; _$P_RC_EOL
seg000:2690					    ; end of line?
seg000:2693		    jz	    short sr52
seg000:2695		    cmp	    cs:result_val, 1 ; [cs:result_val+_$P_Result_Blk.Type],
seg000:2695					    ; _$P_number ; numeric?
seg000:269B		    jnz	    short if56
seg000:269D		    mov	    ax,	word ptr cs:rv_dword ; [cs:result_val+_$P_Result_Blk.Picked_Val]
seg000:26A1		    cmp	    cx,	1
seg000:26A4		    jnz	    short if57
seg000:26A6		    mov	    cs:p_cntry_code, ax
seg000:26AA		    jmp	    short en57
seg000:26AC ; ---------------------------------------------------------------------------
seg000:26AC
seg000:26AC if57:				    ; CODE XREF: multi_pass+4B2j
seg000:26AC		    mov	    cs:p_code_page, ax
seg000:26B0
seg000:26B0 en57:				    ; CODE XREF: multi_pass+4B8j
seg000:26B0		    jmp	    short en56
seg000:26B2 ; ---------------------------------------------------------------------------
seg000:26B2
seg000:26B2 if56:				    ; CODE XREF: multi_pass+4A9j
seg000:26B2		    push    ds
seg000:26B3		    push    es
seg000:26B4		    push    si
seg000:26B5		    push    di
seg000:26B6		    push    cs
seg000:26B7		    pop	    es
seg000:26B8		    lds	    si,	cs:rv_dword
seg000:26BD		    mov	    di,	offset cntry_drv ; "A:"
seg000:26C0		    call    move_asciiz
seg000:26C3		    pop	    di
seg000:26C4		    pop	    si
seg000:26C5		    pop	    es
seg000:26C6		    pop	    ds
seg000:26C7
seg000:26C7 en56:				    ; CODE XREF: multi_pass:en57j
seg000:26C7		    jmp	    short do52
seg000:26C9 ; ---------------------------------------------------------------------------
seg000:26C9
seg000:26C9 sr52:				    ; CODE XREF: multi_pass+49Cj
seg000:26C9					    ; multi_pass+4A1j
seg000:26C9		    cmp	    cs:p_cntry_code, 0FFFFh ; had a parse error?
seg000:26CF		    jnz	    short tryq_open
seg000:26D1		    jmp	    coff
seg000:26D4 ; ---------------------------------------------------------------------------
seg000:26D4
seg000:26D4 tryqbad:				    ; CODE XREF: multi_pass+548j
seg000:26D4		    stc
seg000:26D5		    mov	    dx,	offset badcountry ; "\r\nInvalid country code or code page\r"...
seg000:26D8		    jmp	    tryqchkerr
seg000:26DB ; ---------------------------------------------------------------------------
seg000:26DB
seg000:26DB tryq_open:				    ; CODE XREF: multi_pass+4DDj
seg000:26DB		    cmp	    byte ptr cs:cntry_drv, 0 ; "A:"
seg000:26E1		    jz	    short tryq_def
seg000:26E3		    mov	    dx,	offset cntry_drv ; "A:"
seg000:26E6		    jmp	    short tryq_openit
seg000:26E8 ; ---------------------------------------------------------------------------
seg000:26E8
seg000:26E8 tryq_def:				    ; CODE XREF: multi_pass+4EFj
seg000:26E8		    mov	    dx,	offset cntry_root
seg000:26EB
seg000:26EB tryq_openit:			    ; CODE XREF: multi_pass+4F4j
seg000:26EB		    mov	    ax,	3D00h
seg000:26EE		    stc
seg000:26EF		    int	    21h		    ; DOS - 2+ - OPEN DISK FILE	WITH HANDLE
seg000:26EF					    ; DS:DX -> ASCIZ filename
seg000:26EF					    ; AL = access mode
seg000:26EF					    ; 0	- read
seg000:26F1		    jb	    short tryqfilebad
seg000:26F3		    mov	    cs:cntryfilehandle,	ax ; save file handle
seg000:26F7		    mov	    bx,	ax
seg000:26F9		    mov	    ax,	cs:p_cntry_code
seg000:26FD		    mov	    dx,	cs:p_code_page ; now,ax=country	id,bx=filehandle
seg000:2702		    mov	    cx,	cs:memhi
seg000:2707		    add	    cx,	384	    ; need 6k buffer to	handle country.sys
seg000:270B		    cmp	    cx,	cs:ALLOCLIM
seg000:2710		    ja	    short tryqmemory ; cannot allocate the buffer for country.sys
seg000:2712		    mov	    si,	offset cntry_drv ; ds:si -> cntry_drv
seg000:2715		    cmp	    byte ptr [si], 0 ; default path?
seg000:2718		    jnz	    short tryq_set_for_dos
seg000:271A		    inc	    si
seg000:271B		    inc	    si
seg000:271C
seg000:271C tryq_set_for_dos:			    ; CODE XREF: multi_pass+526j
seg000:271C		    les	    di,	cs:sysi_country
seg000:2721		    push    di
seg000:2722		    add	    di,	8	    ; country_cdpg_info.ccPath_CountrySys
seg000:2725		    call    move_asciiz	    ; set the path to country.sys in dos
seg000:2728		    pop	    di		    ; es:di -> country info tab	again.
seg000:2729		    mov	    cx,	cs:memhi
seg000:272E		    mov	    ds,	cx
seg000:2730		    xor	    si,	si	    ; ds:si -> 2k buffer to be used
seg000:2732		    call    setdoscountryinfo ;	now do the job!!!
seg000:2735		    jnb	    short tryqchkerr
seg000:2737		    cmp	    cx,	0FFFFh
seg000:273A		    jz	    short tryqbad
seg000:273C
seg000:273C tryqfilebad:			    ; CODE XREF: multi_pass+4FFj
seg000:273C		    push    cs
seg000:273D		    pop	    es
seg000:273E		    cmp	    byte ptr cs:cntry_drv, 0 ; is the default file used?
seg000:2744		    jz	    short tryqdefbad
seg000:2746		    mov	    si,	offset cntry_drv ; "A:"
seg000:2749		    jmp	    short tryqbadload
seg000:274B ; ---------------------------------------------------------------------------
seg000:274B
seg000:274B tryqdefbad:				    ; CODE XREF: multi_pass+552j
seg000:274B		    mov	    si,	offset cntry_root ; es:si -> \country.sys in sysinit_seg
seg000:274E
seg000:274E tryqbadload:			    ; CODE XREF: multi_pass+557j
seg000:274E		    call    badload
seg000:2751		    mov	    cx,	cs:top_of_cdss
seg000:2756		    mov	    es,	cx
seg000:2758		    jmp	    short coffj4
seg000:275A ; ---------------------------------------------------------------------------
seg000:275A
seg000:275A tryqmemory:				    ; CODE XREF: multi_pass+51Ej
seg000:275A		    mov	    dx,	offset insufmemory ; "\r\nInsufficient memory for COUNTRY.SYS"...
seg000:275D
seg000:275D tryqchkerr:				    ; CODE XREF: multi_pass+4E6j
seg000:275D					    ; multi_pass+543j
seg000:275D		    mov	    cx,	cs:top_of_cdss
seg000:2762		    mov	    es,	cx
seg000:2764		    push    cs
seg000:2765		    pop	    ds
seg000:2766		    jnb	    short coffj4
seg000:2768		    call    print
seg000:276B		    call    error_line
seg000:276E
seg000:276E coffj4:				    ; CODE XREF: multi_pass+566j
seg000:276E					    ; multi_pass+574j
seg000:276E		    mov	    bx,	cs:cntryfilehandle
seg000:2773		    mov	    ah,	3Eh
seg000:2775		    int	    21h		    ; DOS - 2+ - CLOSE A FILE WITH HANDLE
seg000:2775					    ; BX = file	handle
seg000:2777		    jmp	    coff	    ; close a file.
seg000:2777 multi_pass	    endp		    ; don't care even if it fails.
seg000:2777
seg000:277A
seg000:277A ; =============== S	U B R O	U T I N	E =======================================
seg000:277A
seg000:277A
seg000:277A cntry_error	    proc near		    ; CODE XREF: multi_pass+492p
seg000:277A		    cmp	    ax,	6	    ; _$P_Out_Of_Range
seg000:277D		    jnz	    short if64
seg000:277F		    mov	    dx,	offset badcountry ; "\r\nInvalid country code or code page\r"...
seg000:2782		    jmp	    short en64
seg000:2784 ; ---------------------------------------------------------------------------
seg000:2784
seg000:2784 if64:				    ; CODE XREF: cntry_error+3j
seg000:2784		    mov	    dx,	offset badcountrycom ; "\r\nError in COUNTRY command\r\n$"
seg000:2787
seg000:2787 en64:				    ; CODE XREF: cntry_error+8j
seg000:2787		    call    print
seg000:278A		    call    error_line
seg000:278D		    retn
seg000:278D cntry_error	    endp
seg000:278D
seg000:278E ; ---------------------------------------------------------------------------
seg000:278E ; START OF FUNCTION	CHUNK FOR multi_pass
seg000:278E
seg000:278E tryf:				    ; CODE XREF: multi_pass+476j
seg000:278E		    cmp	    ah,	'F'         ; files command
seg000:278E					    ; CONFIG_FILES
seg000:2791		    jnz	    short tryl
seg000:2793		    mov	    di,	offset files_parms
seg000:2796		    xor	    cx,	cx
seg000:2798		    mov	    dx,	cx
seg000:279A
seg000:279A do67:				    ; CODE XREF: multi_pass+5BFj
seg000:279A		    call    sysinit_parse
seg000:279D		    jnb	    short if67
seg000:279F		    call    badparm_p
seg000:27A2		    jmp	    short sr67
seg000:27A4 ; ---------------------------------------------------------------------------
seg000:27A4
seg000:27A4 if67:				    ; CODE XREF: multi_pass+5ABj
seg000:27A4		    cmp	    ax,	0FFFFh	    ; _$P_RC_EOL
seg000:27A4					    ; end of line?
seg000:27A7		    jz	    short en67	    ; then end the $endloop
seg000:27A9		    mov	    al,	byte ptr cs:rv_dword ; [cs:result_val+_$P_Result_Blk.Picked_Val]
seg000:27AD		    mov	    cs:p_files,	al  ; save it temporarily
seg000:27B1		    jmp	    short do67
seg000:27B3 ; ---------------------------------------------------------------------------
seg000:27B3
seg000:27B3 en67:				    ; CODE XREF: multi_pass+5B5j
seg000:27B3		    mov	    al,	cs:p_files
seg000:27B7		    mov	    cs:FILES, al    ; no error.	really set the value now.
seg000:27BB
seg000:27BB sr67:				    ; CODE XREF: multi_pass+5B0j
seg000:27BB		    jmp	    coff
seg000:27BE ; ---------------------------------------------------------------------------
seg000:27BE
seg000:27BE tryl:				    ; CODE XREF: multi_pass+59Fj
seg000:27BE		    cmp	    ah,	'L'         ; lastdrive command
seg000:27BE					    ; CONFIG_LASTDRIVE
seg000:27C1		    jnz	    short tryp
seg000:27C3		    mov	    di,	offset ldrv_parms
seg000:27C6		    xor	    cx,	cx
seg000:27C8		    mov	    dx,	cx
seg000:27CA
seg000:27CA do73:				    ; CODE XREF: multi_pass+5EFj
seg000:27CA		    call    sysinit_parse
seg000:27CD		    jnb	    short if73
seg000:27CF		    call    badparm_p
seg000:27D2		    jmp	    short sr73
seg000:27D4 ; ---------------------------------------------------------------------------
seg000:27D4
seg000:27D4 if73:				    ; CODE XREF: multi_pass+5DBj
seg000:27D4		    cmp	    ax,	0FFFFh	    ; _$P_RC_EOL
seg000:27D7		    jz	    short en73
seg000:27D9		    mov	    al,	byte ptr cs:rv_dword ; [cs:rv_byte]
seg000:27D9					    ; pick up drive number
seg000:27DD		    mov	    cs:p_ldrv, al   ; save it temporarily
seg000:27E1		    jmp	    short do73
seg000:27E3 ; ---------------------------------------------------------------------------
seg000:27E3
seg000:27E3 en73:				    ; CODE XREF: multi_pass+5E5j
seg000:27E3		    mov	    al,	cs:p_ldrv
seg000:27E7		    mov	    cs:NUM_CDS,	al  ; no error.	really set the value now.
seg000:27EB
seg000:27EB sr73:				    ; CODE XREF: multi_pass+5E0j
seg000:27EB		    jmp	    coff
seg000:27EE ; ---------------------------------------------------------------------------
seg000:27EE
seg000:27EE tryp:				    ; CODE XREF: multi_pass+5CFj
seg000:27EE		    cmp	    ah,	'P'         ; setting drive parameters
seg000:27EE					    ; CONFIG_DRIVPARM
seg000:27F1		    jnz	    short tryk
seg000:27F3		    call    parseline
seg000:27F6		    jb	    short trypbad
seg000:27F8		    call    setparms
seg000:27FB		    call    diddleback
seg000:27FE		    jb	    short trypbad
seg000:2800		    jmp	    coff
seg000:2803 ; ---------------------------------------------------------------------------
seg000:2803
seg000:2803 trypbad:				    ; CODE XREF: multi_pass+604j
seg000:2803					    ; multi_pass+60Cj
seg000:2803		    jmp	    badop
seg000:2806 ; ---------------------------------------------------------------------------
seg000:2806
seg000:2806 tryk:				    ; CODE XREF: multi_pass+5FFj
seg000:2806		    cmp	    ah,	'K'         ; setting internal stack parameters
seg000:2806					    ; CONFIG_STACKS
seg000:2809		    jz	    short do_tryk
seg000:280B		    jmp	    trys
seg000:280E ; ---------------------------------------------------------------------------
seg000:280E
seg000:280E do_tryk:				    ; CODE XREF: multi_pass+617j
seg000:280E		    mov	    di,	offset stks_parms
seg000:2811		    xor	    cx,	cx
seg000:2813		    mov	    dx,	cx
seg000:2815
seg000:2815 do79:				    ; CODE XREF: multi_pass:en83j
seg000:2815		    call    sysinit_parse
seg000:2818		    jnb	    short if79
seg000:281A		    mov	    dx,	offset badstack	; "\r\nInvalid STACK parameters\r\n$"
seg000:281D		    call    print
seg000:2820		    call    error_line
seg000:2823		    jmp	    sr79
seg000:2826 ; ---------------------------------------------------------------------------
seg000:2826
seg000:2826 if79:				    ; CODE XREF: multi_pass+626j
seg000:2826		    cmp	    ax,	0FFFFh	    ; _$P_RC_EOL
seg000:2829		    jz	    short en79
seg000:282B		    mov	    ax,	word ptr cs:rv_dword ; [cs:result_val+_$P_Result_Blk.Picked_Val]
seg000:282F		    cmp	    cx,	1
seg000:2832		    jnz	    short if83
seg000:2834		    mov	    cs:p_stack_count, ax
seg000:2838		    jmp	    short en83
seg000:283A ; ---------------------------------------------------------------------------
seg000:283A
seg000:283A if83:				    ; CODE XREF: multi_pass+640j
seg000:283A		    mov	    cs:p_stack_size, ax
seg000:283E
seg000:283E en83:				    ; CODE XREF: multi_pass+646j
seg000:283E		    jmp	    short do79
seg000:2840 ; ---------------------------------------------------------------------------
seg000:2840
seg000:2840 en79:				    ; CODE XREF: multi_pass+637j
seg000:2840		    cmp	    cs:p_stack_count, 0
seg000:2846		    jz	    short if87
seg000:2848		    cmp	    cs:p_stack_count, 8	; mincount
seg000:284E		    jb	    short ll88
seg000:2850		    cmp	    cs:p_stack_size, 32	; minsize
seg000:2856		    jnb	    short if88
seg000:2858
seg000:2858 ll88:				    ; CODE XREF: multi_pass+65Cj
seg000:2858		    mov	    cs:p_stack_count, 0FFFFh ; invalid
seg000:285F
seg000:285F if88:				    ; CODE XREF: multi_pass+664j
seg000:285F		    jmp	    short en87
seg000:2861 ; ---------------------------------------------------------------------------
seg000:2861
seg000:2861 if87:				    ; CODE XREF: multi_pass+654j
seg000:2861		    cmp	    cs:p_stack_size, 0
seg000:2867		    jz	    short en87
seg000:2869		    mov	    cs:p_stack_count, 0FFFFh ; invalid
seg000:2870
seg000:2870 en87:				    ; CODE XREF: multi_pass:if88j
seg000:2870					    ; multi_pass+675j
seg000:2870		    cmp	    cs:p_stack_count, 0FFFFh ; invalid?
seg000:2876		    jnz	    short if94
seg000:2878		    mov	    cs:stack_count, 9 ;	defaultcount
seg000:2878					    ; reset to default value.
seg000:287F		    mov	    cs:stack_size, 128 ; defaultsize
seg000:2886		    mov	    word ptr cs:stack_addr, 0
seg000:288D		    mov	    dx,	offset badstack	; "\r\nInvalid STACK parameters\r\n$"
seg000:2890		    call    print
seg000:2893		    call    error_line
seg000:2896		    jmp	    short sr79
seg000:2898 ; ---------------------------------------------------------------------------
seg000:2898
seg000:2898 if94:				    ; CODE XREF: multi_pass+684j
seg000:2898		    mov	    ax,	cs:p_stack_count
seg000:289C		    mov	    cs:stack_count, ax
seg000:28A0		    mov	    ax,	cs:p_stack_size
seg000:28A4		    mov	    cs:stack_size, ax
seg000:28A8		    mov	    word ptr cs:stack_addr, 0FFFFh ; -1
seg000:28A8					    ; stacks= been accepted.
seg000:28AF
seg000:28AF sr79:				    ; CODE XREF: multi_pass+631j
seg000:28AF					    ; multi_pass+6A4j
seg000:28AF		    jmp	    coff
seg000:28B2 ; ---------------------------------------------------------------------------
seg000:28B2
seg000:28B2 trys:				    ; CODE XREF: multi_pass+619j
seg000:28B2		    cmp	    ah,	'S'         ; shell command
seg000:28B2					    ; CONFIG_SHELL
seg000:28B5		    jnz	    short tryx
seg000:28B7		    mov	    cs:command_line+1, 0 ; zap length,first byte of command-line
seg000:28BD		    mov	    di,	(offset	commnd+1) ; we already have the	first char
seg000:28C0		    mov	    [di-1], al	    ; of the new shell in AL, save it now
seg000:28C3
seg000:28C3 storeshell:				    ; CODE XREF: multi_pass+6DFj
seg000:28C3		    call    getchr
seg000:28C6		    or	    al,	al	    ; this is the normal case: "organize"
seg000:28C8		    jz	    short getshparms ; put a ZERO right	after the filename
seg000:28CA		    cmp	    al,	20h ; ' '   ; this may happen if there are no args
seg000:28CC		    jb	    short endofshell ; I suppose...
seg000:28CE		    mov	    [di], al
seg000:28D0		    inc	    di
seg000:28D1		    jmp	    short storeshell
seg000:28D3 ; ---------------------------------------------------------------------------
seg000:28D3
seg000:28D3 endofshell:				    ; CODE XREF: multi_pass+6DAj
seg000:28D3					    ; multi_pass+6FCj
seg000:28D3		    mov	    byte ptr [di], 0 ;	zero-terminate the filename (or
seg000:28D3					    ; the command-line as the case may be)
seg000:28D6		    call    getchr
seg000:28D9		    cmp	    al,	0Ah	    ; lf
seg000:28DB		    jnz	    short endofline
seg000:28DD		    call    getchr
seg000:28E0
seg000:28E0 endofline:				    ; CODE XREF: multi_pass+6E9j
seg000:28E0		    jmp	    conflp
seg000:28E3 ; ---------------------------------------------------------------------------
seg000:28E3
seg000:28E3 getshparms:				    ; CODE XREF: multi_pass+6D6j
seg000:28E3		    mov	    byte ptr [di], 0 ; zero-terminate the filename
seg000:28E6		    mov	    di,	(offset	command_line+1)	; prepare to process the command-line
seg000:28E9
seg000:28E9 parmloop:				    ; CODE XREF: multi_pass+701j
seg000:28E9		    call    getchr
seg000:28EC		    cmp	    al,	20h ; ' '
seg000:28EE		    jb	    short endofshell
seg000:28F0		    mov	    [di], al
seg000:28F2		    inc	    di
seg000:28F3		    jmp	    short parmloop
seg000:28F5 ; ---------------------------------------------------------------------------
seg000:28F5
seg000:28F5 tryx:				    ; CODE XREF: multi_pass+6C3j
seg000:28F5		    cmp	    ah,	'X'         ; fcbs command
seg000:28F5					    ; CONFIG_FCBS
seg000:28F8		    jnz	    short tryy
seg000:28FA		    mov	    di,	offset fcbs_parms
seg000:28FD		    xor	    cx,	cx
seg000:28FF		    mov	    dx,	cx
seg000:2901
seg000:2901 do98:				    ; CODE XREF: multi_pass:en102j
seg000:2901		    call    sysinit_parse
seg000:2904		    jnb	    short if98
seg000:2906		    call    badparm_p
seg000:2909		    jmp	    short sr98
seg000:290B ; ---------------------------------------------------------------------------
seg000:290B
seg000:290B if98:				    ; CODE XREF: multi_pass+712j
seg000:290B		    cmp	    ax,	0FFFFh	    ; _$P_RC_EOL
seg000:290E		    jz	    short en98
seg000:2910		    mov	    al,	byte ptr cs:rv_dword ; [cs:result_val+_$P_Result_Blk.Picked_Val]
seg000:2914		    cmp	    cx,	1	    ; the first	positional?
seg000:2917		    jnz	    short if102
seg000:2919		    mov	    cs:p_fcbs, al
seg000:291D		    jmp	    short en102
seg000:291F ; ---------------------------------------------------------------------------
seg000:291F
seg000:291F if102:				    ; CODE XREF: multi_pass+725j
seg000:291F		    mov	    cs:p_keep, al
seg000:2923
seg000:2923 en102:				    ; CODE XREF: multi_pass+72Bj
seg000:2923		    jmp	    short do98
seg000:2925 ; ---------------------------------------------------------------------------
seg000:2925
seg000:2925 en98:				    ; CODE XREF: multi_pass+71Cj
seg000:2925		    mov	    al,	cs:p_fcbs
seg000:2929		    mov	    cs:FCBS, al
seg000:292D		    mov	    cs:KEEP, 0
seg000:2933
seg000:2933 sr98:				    ; CODE XREF: multi_pass+717j
seg000:2933		    jmp	    coff
seg000:2936 ; ---------------------------------------------------------------------------
seg000:2936
seg000:2936 tryy:				    ; CODE XREF: multi_pass+706j
seg000:2936		    cmp	    ah,	'Y'         ; comment command
seg000:2936					    ; CONFIG_COMMENT
seg000:2939		    jnz	    short try0
seg000:293B
seg000:293B donothing:				    ; CODE XREF: multi_pass+759j
seg000:293B					    ; multi_pass:tryz_donothingj
seg000:293B		    dec	    cs:chrptr
seg000:2940		    inc	    cs:count
seg000:2945		    jmp	    coff
seg000:2948 ; ---------------------------------------------------------------------------
seg000:2948
seg000:2948 try0:				    ; CODE XREF: multi_pass+747j
seg000:2948		    cmp	    ah,	'0'         ; rem command
seg000:2948					    ; CONFIG_REM
seg000:294B		    jz	    short donothing
seg000:294D
seg000:294D try1:				    ; switches command
seg000:294D		    cmp	    ah,	'1'         ; CONFIG_SWITCHES
seg000:2950		    jz	    short do_try1
seg000:2952
seg000:2952 skip_it5:
seg000:2952		    jmp	    tryz
seg000:2955 ; ---------------------------------------------------------------------------
seg000:2955
seg000:2955 do_try1:				    ; CODE XREF: multi_pass+75Ej
seg000:2955		    mov	    di,	offset swit_parms
seg000:2958		    xor	    cx,	cx
seg000:295A		    mov	    dx,	cx
seg000:295C
seg000:295C do110:				    ; CODE XREF: multi_pass+788j
seg000:295C					    ; multi_pass+799j ...
seg000:295C		    call    sysinit_parse
seg000:295F		    jnb	    short if110
seg000:2961		    call    badparm_p
seg000:2964		    jmp	    short sr110
seg000:2966 ; ---------------------------------------------------------------------------
seg000:2966
seg000:2966 if110:				    ; CODE XREF: multi_pass+76Dj
seg000:2966		    cmp	    ax,	0FFFFh	    ; _$P_RC_EOL
seg000:2969		    jz	    short en110	    ; jmp to $endloop for semantic check
seg000:296B		    cmp	    cs:result_val_swoff, offset	swit_k ; [cs:result_val+_$P_Result_Blk.SYNONYM_Ptr]
seg000:2972		    jnz	    short if115
seg000:2974		    mov	    cs:p_swit_k, 1
seg000:297A		    jmp	    short do110
seg000:297C ; ---------------------------------------------------------------------------
seg000:297C
seg000:297C if115:				    ; CODE XREF: multi_pass+780j
seg000:297C		    cmp	    cs:result_val_swoff, offset	swit_t ; [cs:result_val+_$P_Result_Blk.SYNONYM_Ptr]
seg000:2983		    jnz	    short if116
seg000:2985		    mov	    cs:p_swit_t, 1
seg000:298B		    jmp	    short do110
seg000:298D ; ---------------------------------------------------------------------------
seg000:298D
seg000:298D if116:				    ; CODE XREF: multi_pass+791j
seg000:298D		    cmp	    cs:result_val_swoff, offset	swit_w ; [cs:result_val+_$P_Result_Blk.SYNONYM_Ptr]
seg000:2994		    jnz	    short do110
seg000:2996		    mov	    cs:p_swit_w, 1
seg000:299C		    jmp	    short do110
seg000:299E ; ---------------------------------------------------------------------------
seg000:299E
seg000:299E en110:				    ; CODE XREF: multi_pass+777j
seg000:299E		    cmp	    cs:p_swit_k, 1  ;  if /k entered
seg000:29A4		    push    ds
seg000:29A5		    mov	    ax,	70h	    ; DOSBIODATASEG
seg000:29A8		    mov	    ds,	ax
seg000:29AA		    assume ds:nothing
seg000:29AA		    jnz	    short if117
seg000:29AC		    mov	    byte ptr ds:4E5h, 0	; [keyrd_func]
seg000:29AC					    ; use the conventional keyboard functions
seg000:29B1		    mov	    byte ptr ds:4E6h, 1	; [keysts_func]
seg000:29B6
seg000:29B6 if117:				    ; CODE XREF: multi_pass+7B8j
seg000:29B6		    mov	    al,	cs:p_swit_t
seg000:29BA		    mov	    ds:4F2h, al	    ; [t_switch]
seg000:29BD		    cmp	    cs:p_swit_w, 0
seg000:29C3		    jz	    short skip_dos_flag
seg000:29C5		    push    es
seg000:29C6		    push    bx
seg000:29C7		    mov	    ah,	52h	    ; GET_IN_VARS
seg000:29C9		    int	    21h		    ; DOS - 2+ internal	- GET LIST OF LISTS
seg000:29C9					    ; Return: ES:BX -> DOS list	of lists
seg000:29CB		    or	    byte ptr es:intret_0B, 2 ; [es:86h]
seg000:29CB					    ; [es:DOS_FLAG_OFFSET],SUPPRESS_WINA20
seg000:29D1		    pop	    bx
seg000:29D2		    pop	    es
seg000:29D3
seg000:29D3 skip_dos_flag:			    ; CODE XREF: multi_pass+7D1j
seg000:29D3		    pop	    ds
seg000:29D4		    assume ds:nothing
seg000:29D4
seg000:29D4 sr110:				    ; CODE XREF: multi_pass+772j
seg000:29D4		    jmp	    coff
seg000:29D7 ; ---------------------------------------------------------------------------
seg000:29D7
seg000:29D7 tryz:				    ; CODE XREF: multi_pass:skip_it5j
seg000:29D7		    cmp	    ah,	0FFh	    ; bogus command
seg000:29D7					    ; null command?
seg000:29D7					    ; (BUGBUG -	who sets FFh anyway?)
seg000:29DA		    jz	    short tryz_donothing
seg000:29DC		    dec	    ds:chrptr
seg000:29E0		    inc	    ds:count
seg000:29E4		    jmp	    short badop
seg000:29E6 ; ---------------------------------------------------------------------------
seg000:29E6
seg000:29E6 tryz_donothing:			    ; CODE XREF: multi_pass+7E8j
seg000:29E6		    jmp	    donothing
seg000:29E6 ; END OF FUNCTION CHUNK FOR	multi_pass
seg000:29E9
seg000:29E9 ; =============== S	U B R O	U T I N	E =======================================
seg000:29E9
seg000:29E9
seg000:29E9 sysinit_parse   proc near		    ; CODE XREF: multi_pass:do7p
seg000:29E9					    ; multi_pass:do22p	...
seg000:29E9		    push    es
seg000:29EA		    push    ds
seg000:29EB		    push    es
seg000:29EC		    pop	    ds
seg000:29ED		    push    cs
seg000:29EE		    pop	    es
seg000:29EF		    mov	    word ptr cs:badparm_ptr+2, ds
seg000:29F4		    mov	    word ptr cs:badparm_ptr, si
seg000:29F9		    mov	    dx,	0
seg000:29FC		    call    SysParse
seg000:29FF		    cmp	    ax,	0	    ; _$P_No_Error
seg000:2A02		    jz	    short ll4
seg000:2A04		    cmp	    ax,	0FFFFh	    ; _$P_RC_EOL
seg000:2A07		    jnz	    short if4
seg000:2A09
seg000:2A09 ll4:				    ; CODE XREF: sysinit_parse+19j
seg000:2A09		    clc
seg000:2A0A		    jmp	    short en4
seg000:2A0C ; ---------------------------------------------------------------------------
seg000:2A0C
seg000:2A0C if4:				    ; CODE XREF: sysinit_parse+1Ej
seg000:2A0C		    stc
seg000:2A0D
seg000:2A0D en4:				    ; CODE XREF: sysinit_parse+21j
seg000:2A0D		    pop	    ds
seg000:2A0E		    pop	    es
seg000:2A0F		    retn
seg000:2A0F sysinit_parse   endp
seg000:2A0F
seg000:2A10 ; ---------------------------------------------------------------------------
seg000:2A10
seg000:2A10 badop_p:
seg000:2A10		    push    cs
seg000:2A11		    pop	    ds
seg000:2A12		    mov	    dx,	offset badopm ;	"\r\nUnrecognized command in CONFIG.SYS"
seg000:2A15		    call    print
seg000:2A18		    call    error_line
seg000:2A1B		    retn
seg000:2A1C ; ---------------------------------------------------------------------------
seg000:2A1C ; START OF FUNCTION	CHUNK FOR multi_pass
seg000:2A1C
seg000:2A1C badop:				    ; CODE XREF: multi_pass+4Dj
seg000:2A1C					    ; multi_pass+268j ...
seg000:2A1C		    mov	    dx,	offset badopm ;	"\r\nUnrecognized command in CONFIG.SYS"
seg000:2A1F		    call    print
seg000:2A22		    call    error_line
seg000:2A25		    jmp	    coff
seg000:2A25 ; END OF FUNCTION CHUNK FOR	multi_pass
seg000:2A28
seg000:2A28 ; =============== S	U B R O	U T I N	E =======================================
seg000:2A28
seg000:2A28
seg000:2A28 badparm_p	    proc near		    ; CODE XREF: multi_pass+C0p
seg000:2A28					    ; multi_pass+EDp ...
seg000:2A28		    push    ds
seg000:2A29		    push    dx
seg000:2A2A		    push    si
seg000:2A2B		    push    cs
seg000:2A2C		    pop	    ds
seg000:2A2D		    mov	    dx,	offset badparm ; "\r\nBad command or parameters	- $"
seg000:2A30		    call    print
seg000:2A33		    lds	    si,	ds:badparm_ptr
seg000:2A37
seg000:2A37 do1:				    ; CODE XREF: badparm_p+1Bj
seg000:2A37		    mov	    dl,	[si]
seg000:2A39		    cmp	    dl,	0Dh	    ; cr
seg000:2A3C		    jz	    short en1
seg000:2A3E		    mov	    ah,	2	    ; STD_CON_OUTPUT
seg000:2A40		    int	    21h		    ; DOS - DISPLAY OUTPUT
seg000:2A40					    ; DL = character to	send to	standard output
seg000:2A42		    inc	    si
seg000:2A43		    jmp	    short do1
seg000:2A45 ; ---------------------------------------------------------------------------
seg000:2A45
seg000:2A45 en1:				    ; CODE XREF: badparm_p+14j
seg000:2A45		    push    cs
seg000:2A46		    pop	    ds
seg000:2A47		    mov	    dx,	offset crlfm ; "\r\n$"
seg000:2A4A		    call    print
seg000:2A4D		    call    error_line
seg000:2A50		    pop	    si
seg000:2A51		    pop	    dx
seg000:2A52		    pop	    ds
seg000:2A53		    retn
seg000:2A53 badparm_p	    endp
seg000:2A53
seg000:2A54
seg000:2A54 ; =============== S	U B R O	U T I N	E =======================================
seg000:2A54
seg000:2A54
seg000:2A54 getchr	    proc near		    ; CODE XREF: multi_pass+20p
seg000:2A54					    ; multi_pass+28p ...
seg000:2A54		    push    cx
seg000:2A55		    mov	    cx,	ds:count
seg000:2A59		    jcxz    short nochar
seg000:2A5B		    mov	    si,	ds:chrptr
seg000:2A5F		    mov	    al,	es:[si]
seg000:2A62		    dec	    ds:count
seg000:2A66		    inc	    ds:chrptr
seg000:2A6A		    clc
seg000:2A6B
seg000:2A6B get_ret:				    ; CODE XREF: getchr+1Aj
seg000:2A6B		    pop	    cx
seg000:2A6C		    retn
seg000:2A6D ; ---------------------------------------------------------------------------
seg000:2A6D
seg000:2A6D nochar:				    ; CODE XREF: getchr+5j
seg000:2A6D		    stc
seg000:2A6E		    jmp	    short get_ret
seg000:2A6E getchr	    endp
seg000:2A6E
seg000:2A70 ; ---------------------------------------------------------------------------
seg000:2A70
seg000:2A70 incorrect_order:			    ; "\r\nIncorrect order in CONFIG.SYS line "...
seg000:2A70		    mov	    dx,	offset badorder
seg000:2A73		    call    print
seg000:2A76		    call    showlinenum
seg000:2A79		    retn
seg000:2A7A
seg000:2A7A ; =============== S	U B R O	U T I N	E =======================================
seg000:2A7A
seg000:2A7A
seg000:2A7A error_line	    proc near		    ; CODE XREF: seg000:114Bp
seg000:2A7A					    ; multi_pass+319p ...
seg000:2A7A		    push    cs
seg000:2A7B		    pop	    ds
seg000:2A7C		    mov	    dx,	offset errorcmd	; "Error in CONFIG.SYS line $"
seg000:2A7F		    call    print
seg000:2A82		    call    showlinenum
seg000:2A85		    retn
seg000:2A85 error_line	    endp
seg000:2A85
seg000:2A86
seg000:2A86 ; =============== S	U B R O	U T I N	E =======================================
seg000:2A86
seg000:2A86
seg000:2A86 showlinenum	    proc near		    ; CODE XREF: seg000:2A76p
seg000:2A86					    ; error_line+8p
seg000:2A86		    push    es
seg000:2A87		    push    ds
seg000:2A88		    push    di
seg000:2A89		    push    cs
seg000:2A8A		    pop	    es
seg000:2A8B		    push    cs
seg000:2A8C		    pop	    ds
seg000:2A8D		    mov	    di,	(offset	showcount+4) ; di -> the least significant decimal field.
seg000:2A90		    mov	    cx,	10	    ;  decimal divide factor
seg000:2A93		    mov	    ax,	cs:linecount
seg000:2A97
seg000:2A97 sln_loop:				    ; CODE XREF: showlinenum+20j
seg000:2A97		    cmp	    ax,	10
seg000:2A9A		    jb	    short sln_last
seg000:2A9C		    xor	    dx,	dx
seg000:2A9E		    div	    cx
seg000:2AA0		    or	    dl,	'0'         ; add "0" (= 30h) to make it an ascii.
seg000:2AA3		    mov	    [di], dl
seg000:2AA5		    dec	    di
seg000:2AA6		    jmp	    short sln_loop
seg000:2AA8 ; ---------------------------------------------------------------------------
seg000:2AA8
seg000:2AA8 sln_last:				    ; CODE XREF: showlinenum+14j
seg000:2AA8		    or	    al,	'0'
seg000:2AAA		    mov	    [di], al
seg000:2AAC		    mov	    dx,	di
seg000:2AAE		    call    print	    ; show it.
seg000:2AB1		    pop	    di
seg000:2AB2		    pop	    ds
seg000:2AB3		    pop	    es
seg000:2AB4		    retn
seg000:2AB4 showlinenum	    endp
seg000:2AB4
seg000:2AB5
seg000:2AB5 ; =============== S	U B R O	U T I N	E =======================================
seg000:2AB5
seg000:2AB5
seg000:2AB5 ProcDOS	    proc near		    ; CODE XREF: multi_pass+1B8p
seg000:2AB5		    xor	    ah,	ah
seg000:2AB7		    mov	    al,	cs:result_val_itag ; [cs:result_val+_$P_Result_Blk.Item_Tag]
seg000:2ABB		    dec	    ax
seg000:2ABC		    jz	    short pd_hi
seg000:2ABE		    dec	    ax
seg000:2ABF		    jz	    short pd_lo
seg000:2AC1		    dec	    ax
seg000:2AC2		    jz	    short pd_umb
seg000:2AC4		    mov	    cs:DevUMB, 0
seg000:2ACA		    retn
seg000:2ACB ; ---------------------------------------------------------------------------
seg000:2ACB
seg000:2ACB pd_umb:				    ; CODE XREF: ProcDOS+Dj
seg000:2ACB		    mov	    cs:DevUMB, 0FFh
seg000:2AD1		    retn
seg000:2AD2 ; ---------------------------------------------------------------------------
seg000:2AD2
seg000:2AD2 pd_lo:				    ; CODE XREF: ProcDOS+Aj
seg000:2AD2		    mov	    cs:runhigh,	0
seg000:2AD8		    retn
seg000:2AD9 ; ---------------------------------------------------------------------------
seg000:2AD9
seg000:2AD9 pd_hi:				    ; CODE XREF: ProcDOS+7j
seg000:2AD9		    mov	    cs:runhigh,	0FFh
seg000:2ADF		    retn
seg000:2ADF ProcDOS	    endp
seg000:2ADF
seg000:2AE0
seg000:2AE0 ; =============== S	U B R O	U T I N	E =======================================
seg000:2AE0
seg000:2AE0
seg000:2AE0 LieInt12Mem	    proc near		    ; CODE XREF: multi_pass+2A8p
seg000:2AE0		    mov	    ax,	cs:ALLOCLIM ; lie INT 12 as alloclim
seg000:2AE4		    call    IsIt3Com	    ; Is it 3Com driver?
seg000:2AE7		    jz	    short lim_set   ; yes, lie to him differently
seg000:2AE9		    cmp	    cs:DeviceHi, 0  ;  Is the DD being loaded in UMB
seg000:2AEF		    jz	    short limx	    ; no, don't lie
seg000:2AF1		    mov	    ax,	cs:DevLoadEnd ;	lie INT	12 as end of UMB
seg000:2AF5
seg000:2AF5 lim_set:				    ; CODE XREF: LieInt12Mem+7j
seg000:2AF5		    call    SetInt12Mem
seg000:2AF8
seg000:2AF8 limx:				    ; CODE XREF: LieInt12Mem+Fj
seg000:2AF8		    retn
seg000:2AF8 LieInt12Mem	    endp
seg000:2AF8
seg000:2AF9
seg000:2AF9 ; =============== S	U B R O	U T I N	E =======================================
seg000:2AF9
seg000:2AF9
seg000:2AF9 SetInt12Mem	    proc near		    ; CODE XREF: LieInt12Mem:lim_setp
seg000:2AF9		    push    ds
seg000:2AFA		    mov	    bx,	40h
seg000:2AFD		    mov	    ds,	bx	    ; ROM BIOS Data Segment
seg000:2AFF		    assume ds:nothing
seg000:2AFF		    mov	    bx,	ds:13h	    ; INT 12 memory variable
seg000:2B03		    mov	    cs:OldInt12Mem, bx
seg000:2B08		    mov	    cl,	6
seg000:2B0A		    shr	    ax,	cl	    ; convert paras into Ks
seg000:2B0C		    mov	    ds:13h, ax	    ; Lie
seg000:2B0F		    mov	    cs:Int12Lied, 0FFh ; mark that we are lying
seg000:2B15		    pop	    ds
seg000:2B16		    assume ds:nothing
seg000:2B16		    retn
seg000:2B16 SetInt12Mem	    endp
seg000:2B16
seg000:2B17
seg000:2B17 ; =============== S	U B R O	U T I N	E =======================================
seg000:2B17
seg000:2B17
seg000:2B17 TrueInt12Mem    proc near		    ; CODE XREF: multi_pass+2D3p
seg000:2B17		    cmp	    cs:Int12Lied, 0 ; were we lying so far?
seg000:2B1D		    mov	    cs:Int12Lied, 0 ; reset it anyway
seg000:2B23		    jz	    short timx	    ; no, we weren't
seg000:2B25		    push    ds
seg000:2B26		    mov	    ax,	40h
seg000:2B29		    mov	    ds,	ax
seg000:2B2B		    assume ds:nothing
seg000:2B2B		    mov	    ax,	cs:OldInt12Mem
seg000:2B2F		    mov	    ds:13h, ax
seg000:2B32		    pop	    ds
seg000:2B33		    assume ds:nothing
seg000:2B33
seg000:2B33 timx:				    ; CODE XREF: TrueInt12Mem+Cj
seg000:2B33		    retn
seg000:2B33 TrueInt12Mem    endp
seg000:2B33
seg000:2B34
seg000:2B34 ; =============== S	U B R O	U T I N	E =======================================
seg000:2B34
seg000:2B34
seg000:2B34 IsIt3Com	    proc near		    ; CODE XREF: LieInt12Mem+4p
seg000:2B34		    push    ds
seg000:2B35		    push    es
seg000:2B36		    push    si
seg000:2B37		    lds	    si,	cs:DevEntry ; ptr to device header
seg000:2B3C		    add	    si,	10	    ; SYSDEV.NAME
seg000:2B3F		    push    cs
seg000:2B40		    pop	    es
seg000:2B41		    mov	    di,	offset ThreeComName ; "PROTMAN$"
seg000:2B44		    mov	    cx,	8	    ; name length
seg000:2B47		    repe cmpsb
seg000:2B49		    pop	    si
seg000:2B4A		    pop	    es
seg000:2B4B		    pop	    ds
seg000:2B4C		    retn
seg000:2B4C IsIt3Com	    endp
seg000:2B4C
seg000:2B4D
seg000:2B4D ; =============== S	U B R O	U T I N	E =======================================
seg000:2B4D
seg000:2B4D
seg000:2B4D UpdatePDB	    proc near		    ; CODE XREF: multi_pass+2ABp
seg000:2B4D		    push    ds
seg000:2B4E		    mov	    ah,	62h
seg000:2B50		    int	    21h		    ; DOS - 3+ - GET PSP ADDRESS
seg000:2B52		    mov	    ds,	bx
seg000:2B54		    mov	    bx,	cs:ALLOCLIM
seg000:2B59		    mov	    ds:stackcount, bx ;	[PDB.BLOCK_LEN]
seg000:2B5D		    pop	    ds
seg000:2B5E		    retn
seg000:2B5E UpdatePDB	    endp
seg000:2B5E
seg000:2B5F
seg000:2B5F ; =============== S	U B R O	U T I N	E =======================================
seg000:2B5F
seg000:2B5F
seg000:2B5F InitDevLoad	    proc near		    ; CODE XREF: multi_pass:DevConvLoadp
seg000:2B5F		    cmp	    cs:DeviceHi, 0  ; Are we loading in	UMB ?
seg000:2B65		    jz	    short InitForLo ; no, init for lo mem
seg000:2B67
seg000:2B67 InitForConv:			    ; Do we have space left in the
seg000:2B67		    call    SpaceInUMB	    ; current UMB ?
seg000:2B6A		    jnb	    short InitForHi ; yes, we have
seg000:2B6C		    call    ShrinkUMB	    ; shrink the current UMB in	use
seg000:2B6F		    call    GetUMBForDev    ; else try to allocate new UMB
seg000:2B72		    jb	    short InitForLo ; we didn't succeed, so load
seg000:2B72					    ; in low memory
seg000:2B74
seg000:2B74 InitForHi:				    ; CODE XREF: InitDevLoad+Bj
seg000:2B74		    mov	    ax,	cs:DevUMBFree ;	get Para addr of free mem
seg000:2B78		    mov	    dx,	cs:DevUMBAddr ;	UMB start addr
seg000:2B7D		    add	    dx,	cs:DevUMBSize ;	DX = UMB End addr
seg000:2B82		    jmp	    short idl1
seg000:2B84 ; ---------------------------------------------------------------------------
seg000:2B84
seg000:2B84 InitForLo:				    ; CODE XREF: InitDevLoad+6j
seg000:2B84					    ; InitDevLoad+13j
seg000:2B84		    mov	    cs:DeviceHi, 0  ; in case we failed	to load
seg000:2B84					    ; into UMB indicate	that
seg000:2B84					    ; we are loading low
seg000:2B8A		    mov	    ax,	cs:memhi    ; AX = start of Low	memory
seg000:2B8E		    mov	    dx,	cs:ALLOCLIM ; DX = End of Low memory
seg000:2B93
seg000:2B93 idl1:				    ; CODE XREF: InitDevLoad+23j
seg000:2B93		    call    DevSetMark	    ; setup a sub-arena	for DD
seg000:2B96		    mov	    cs:DevLoadAddr, ax ; init the Device load address
seg000:2B9A		    mov	    cs:DevLoadEnd, dx ;	init the limit of the block
seg000:2B9F		    mov	    word ptr cs:DevEntry, 0 ; init Entry point to DD
seg000:2BA6		    mov	    word ptr cs:DevEntry+2, ax
seg000:2BAA		    retn
seg000:2BAA InitDevLoad	    endp
seg000:2BAA
seg000:2BAB
seg000:2BAB ; =============== S	U B R O	U T I N	E =======================================
seg000:2BAB
seg000:2BAB
seg000:2BAB SpaceInUMB	    proc near		    ; CODE XREF: InitDevLoad:InitForConvp
seg000:2BAB		    mov	    ax,	cs:DevUMBSize
seg000:2BAF		    add	    ax,	cs:DevUMBAddr ;	End of UMB
seg000:2BB4		    sub	    ax,	cs:DevUMBFree ;	- Free = Remaining space
seg000:2BB9		    or	    ax,	ax	    ; Nospace ?
seg000:2BBB		    jnz	    short spcinumb1
seg000:2BBD		    stc
seg000:2BBE		    retn
seg000:2BBF ; ---------------------------------------------------------------------------
seg000:2BBF
seg000:2BBF spcinumb1:				    ; CODE XREF: SpaceInUMB+10j
seg000:2BBF		    dec	    ax		    ; space for	sub-arena
seg000:2BC0		    cmp	    ax,	cs:DevSize  ; do we have space ?
seg000:2BC5		    retn
seg000:2BC5 SpaceInUMB	    endp
seg000:2BC5
seg000:2BC6
seg000:2BC6 ; =============== S	U B R O	U T I N	E =======================================
seg000:2BC6
seg000:2BC6
seg000:2BC6 GetUMBForDev    proc near		    ; CODE XREF: InitDevLoad+10p
seg000:2BC6		    mov	    bx,	0FFFFh
seg000:2BC9		    mov	    ax,	4800h
seg000:2BCC		    int	    21h		    ; DOS - 2+ - ALLOCATE MEMORY
seg000:2BCC					    ; BX = number of 16-byte paragraphs	desired
seg000:2BCE		    or	    bx,	bx
seg000:2BD0		    jz	    short gufd_err
seg000:2BD2		    dec	    bx
seg000:2BD3		    cmp	    cs:DevSize,	bx
seg000:2BD8		    ja	    short gufd_err
seg000:2BDA		    inc	    bx
seg000:2BDB		    mov	    ax,	4800h
seg000:2BDE		    int	    21h		    ; DOS - 2+ - ALLOCATE MEMORY
seg000:2BDE					    ; BX = number of 16-byte paragraphs	desired
seg000:2BE0		    jb	    short gufd_err
seg000:2BE2		    push    ds
seg000:2BE3		    dec	    ax
seg000:2BE4		    mov	    ds,	ax
seg000:2BE6		    assume ds:nothing
seg000:2BE6		    mov	    word ptr ds:1, 8 ; [ARENA.OWNER]
seg000:2BEC		    mov	    word ptr ds:8, 4453h ; 'SD'
seg000:2BEC					    ; [ARENA.NAME]
seg000:2BF2		    inc	    ax
seg000:2BF3		    pop	    ds
seg000:2BF4		    assume ds:nothing
seg000:2BF4		    mov	    cs:DevUMBSize, bx
seg000:2BF9		    mov	    cs:DevUMBAddr, ax
seg000:2BFD		    mov	    cs:DevUMBFree, ax
seg000:2C01		    clc
seg000:2C02		    retn
seg000:2C03 ; ---------------------------------------------------------------------------
seg000:2C03
seg000:2C03 gufd_err:				    ; CODE XREF: GetUMBForDev+Aj
seg000:2C03					    ; GetUMBForDev+12j	...
seg000:2C03		    xor	    ax,	ax
seg000:2C05		    mov	    cs:DevUMBSize, ax
seg000:2C09		    mov	    cs:DevUMBAddr, ax
seg000:2C0D		    mov	    cs:DevUMBFree, ax
seg000:2C11		    stc
seg000:2C12		    retn
seg000:2C12 GetUMBForDev    endp
seg000:2C12
seg000:2C13
seg000:2C13 ; =============== S	U B R O	U T I N	E =======================================
seg000:2C13
seg000:2C13
seg000:2C13 DevSetMark	    proc near		    ; CODE XREF: InitDevLoad:idl1p
seg000:2C13		    push    es
seg000:2C14		    push    di
seg000:2C15		    push    ds
seg000:2C16		    push    si
seg000:2C17		    mov	    es,	ax
seg000:2C19		    mov	    byte ptr es:SYSINIT$, 'D' ; [es:devmark.id],
seg000:2C19					    ; devmark_device
seg000:2C1F		    inc	    ax
seg000:2C20		    mov	    es:SYSINIT$+1, ax ;	[es:devmark.seg]
seg000:2C24		    push    ax
seg000:2C25		    lds	    si,	dword ptr cs:bpb_addr ;	command	line is	still there
seg000:2C2A		    mov	    di,	si
seg000:2C2C		    cld
seg000:2C2D
seg000:2C2D dsm_again:				    ; CODE XREF: DevSetMark+21j
seg000:2C2D					    ; DevSetMark+29j ...
seg000:2C2D		    lodsb
seg000:2C2E		    cmp	    al,	':'
seg000:2C30		    jnz	    short isit_slash
seg000:2C32		    mov	    di,	si
seg000:2C34		    jmp	    short dsm_again
seg000:2C36 ; ---------------------------------------------------------------------------
seg000:2C36
seg000:2C36 isit_slash:				    ; CODE XREF: DevSetMark+1Dj
seg000:2C36		    cmp	    al,	'\'
seg000:2C38		    jnz	    short isit_null
seg000:2C3A		    mov	    di,	si
seg000:2C3C		    jmp	    short dsm_again
seg000:2C3E ; ---------------------------------------------------------------------------
seg000:2C3E
seg000:2C3E isit_null:				    ; CODE XREF: DevSetMark+25j
seg000:2C3E		    or	    al,	al
seg000:2C40		    jnz	    short dsm_again
seg000:2C42		    mov	    si,	di
seg000:2C44		    mov	    di,	8	    ; devmark.filename
seg000:2C47		    mov	    cx,	8	    ; maximum 8	characters
seg000:2C4A
seg000:2C4A dsm_next_char:			    ; CODE XREF: DevSetMark+41j
seg000:2C4A		    lodsb
seg000:2C4B		    or	    al,	al
seg000:2C4D		    jz	    short blankout
seg000:2C4F		    cmp	    al,	'.'
seg000:2C51		    jz	    short blankout
seg000:2C53		    stosb
seg000:2C54		    loop    dsm_next_char
seg000:2C56
seg000:2C56 blankout:				    ; CODE XREF: DevSetMark+3Aj
seg000:2C56					    ; DevSetMark+3Ej
seg000:2C56		    jcxz    short dsm_exit
seg000:2C58		    mov	    al,	20h ; ' '
seg000:2C5A		    rep	stosb		    ; blank out	the rest
seg000:2C5C
seg000:2C5C dsm_exit:				    ; CODE XREF: DevSetMark:blankoutj
seg000:2C5C		    pop	    ax
seg000:2C5D		    pop	    si
seg000:2C5E		    pop	    ds
seg000:2C5F		    pop	    di
seg000:2C60		    pop	    es
seg000:2C61		    retn
seg000:2C61 DevSetMark	    endp
seg000:2C61
seg000:2C62
seg000:2C62 ; =============== S	U B R O	U T I N	E =======================================
seg000:2C62
seg000:2C62
seg000:2C62 SizeDevice	    proc near		    ; CODE XREF: multi_pass+245p
seg000:2C62		    push    es
seg000:2C63		    pop	    ds
seg000:2C64		    mov	    dx,	si
seg000:2C66		    mov	    ax,	3D00h
seg000:2C69		    int	    21h		    ; DOS - 2+ - OPEN DISK FILE	WITH HANDLE
seg000:2C69					    ; DS:DX -> ASCIZ filename
seg000:2C69					    ; AL = access mode
seg000:2C69					    ; 0	- read
seg000:2C6B		    jb	    short sd_err
seg000:2C6D		    mov	    bx,	ax
seg000:2C6F		    mov	    ax,	4202h	    ; seek
seg000:2C72		    xor	    cx,	cx
seg000:2C74		    mov	    dx,	cx	    ; to end of	file
seg000:2C76		    int	    21h		    ; DOS - 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
seg000:2C76					    ; AL = method: offset from end of file
seg000:2C78		    jb	    short sd_close  ; did seek fail (impossible)
seg000:2C7A		    add	    ax,	15	    ; para convert
seg000:2C7D		    adc	    dx,	0
seg000:2C80		    test    dx,	0FFF0h	    ; size > 0ffff paras ?
seg000:2C84		    jz	    short szdev1    ; no
seg000:2C86		    mov	    cs:DevSize,	0FFFFh ; invalid device	size
seg000:2C8D		    jmp	    short sd_close  ; assuming that we fail later
seg000:2C8F ; ---------------------------------------------------------------------------
seg000:2C8F
seg000:2C8F szdev1:				    ; CODE XREF: SizeDevice+22j
seg000:2C8F		    mov	    cl,	4	    ; convert it to paras
seg000:2C91		    shr	    ax,	cl
seg000:2C93		    mov	    cl,	12
seg000:2C95		    shl	    dx,	cl
seg000:2C97		    or	    ax,	dx
seg000:2C99		    cmp	    ax,	cs:DevSizeOption
seg000:2C9E		    ja	    short szdev2
seg000:2CA0		    mov	    ax,	cs:DevSizeOption
seg000:2CA4
seg000:2CA4 szdev2:				    ; CODE XREF: SizeDevice+3Cj
seg000:2CA4		    mov	    cs:DevSize,	ax  ; save file	size
seg000:2CA8		    clc
seg000:2CA9
seg000:2CA9 sd_close:				    ; CODE XREF: SizeDevice+16j
seg000:2CA9					    ; SizeDevice+2Bj
seg000:2CA9		    pushf
seg000:2CAA		    mov	    ax,	3E00h
seg000:2CAD		    int	    21h		    ; DOS - 2+ - CLOSE A FILE WITH HANDLE
seg000:2CAD					    ; BX = file	handle
seg000:2CAF		    popf
seg000:2CB0
seg000:2CB0 sd_err:				    ; CODE XREF: SizeDevice+9j
seg000:2CB0		    retn
seg000:2CB0 SizeDevice	    endp
seg000:2CB0
seg000:2CB1
seg000:2CB1 ; =============== S	U B R O	U T I N	E =======================================
seg000:2CB1
seg000:2CB1
seg000:2CB1 ExecDev	    proc near		    ; CODE XREF: multi_pass+275p
seg000:2CB1		    mov	    bx,	cs:DevLoadAddr
seg000:2CB6		    mov	    cs:DevExecAddr, bx
seg000:2CBB		    mov	    cs:DevExecReloc, bx
seg000:2CC0		    mov	    bx,	cs
seg000:2CC2		    mov	    es,	bx
seg000:2CC4		    mov	    bx,	offset DevExecAddr
seg000:2CC7		    mov	    al,	3
seg000:2CC9		    mov	    ah,	4Bh
seg000:2CCB		    int	    21h		    ; DOS - 2+ - LOAD OR EXECUTE (EXEC)
seg000:2CCB					    ; DS:DX -> ASCIZ filename
seg000:2CCB					    ; ES:BX -> parameter block
seg000:2CCB					    ; AL = subfunc: called by MSC spawn(P_NOWAIT,...) when running DOS 4.x.
seg000:2CCD		    retn
seg000:2CCD ExecDev	    endp
seg000:2CCD
seg000:2CCE
seg000:2CCE ; =============== S	U B R O	U T I N	E =======================================
seg000:2CCE
seg000:2CCE
seg000:2CCE RemoveNull	    proc near		    ; CODE XREF: multi_pass+280p
seg000:2CCE					    ; RemoveNull+8j
seg000:2CCE		    mov	    bl,	es:[si]
seg000:2CD1		    or	    bl,	bl	    ; null ?
seg000:2CD3		    jz	    short rn_gotnull
seg000:2CD5		    inc	    si
seg000:2CD6		    jmp	    short RemoveNull
seg000:2CD8 ; ---------------------------------------------------------------------------
seg000:2CD8
seg000:2CD8 rn_gotnull:				    ; CODE XREF: RemoveNull+5j
seg000:2CD8		    mov	    bl,	cs:DevSavedDelim
seg000:2CDD		    mov	    es:[si], bl	    ; replace null with	blank
seg000:2CE0		    retn
seg000:2CE0 RemoveNull	    endp
seg000:2CE0
seg000:2CE1
seg000:2CE1 ; =============== S	U B R O	U T I N	E =======================================
seg000:2CE1
seg000:2CE1
seg000:2CE1 RoundBreakAddr  proc near		    ; CODE XREF: multi_pass+3DCp
seg000:2CE1					    ; DevSetBreak:set_break_continuep
seg000:2CE1		    mov	    ax,	word ptr cs:DevBrkAddr
seg000:2CE5		    call    ParaRound
seg000:2CE8		    add	    word ptr cs:DevBrkAddr+2, ax
seg000:2CED		    mov	    word ptr cs:DevBrkAddr, 0
seg000:2CF4		    mov	    ax,	cs:DevLoadEnd
seg000:2CF8		    cmp	    word ptr cs:DevBrkAddr+2, ax
seg000:2CFD		    jbe	    short rba_ok
seg000:2CFF		    jmp	    memerr
seg000:2D02 ; ---------------------------------------------------------------------------
seg000:2D02
seg000:2D02 rba_ok:				    ; CODE XREF: RoundBreakAddr+1Cj
seg000:2D02		    retn
seg000:2D02 RoundBreakAddr  endp
seg000:2D02
seg000:2D03
seg000:2D03 ; =============== S	U B R O	U T I N	E =======================================
seg000:2D03
seg000:2D03
seg000:2D03 DevSetBreak	    proc near		    ; CODE XREF: multi_pass+350p
seg000:2D03					    ; multi_pass+398p
seg000:2D03		    push    ax
seg000:2D04		    mov	    ax,	word ptr cs:DevBrkAddr+2 ; remove the init code
seg000:2D08		    cmp	    cs:multdeviceflag, 0
seg000:2D0E		    jnz	    short set_break_continue ; do not check it.
seg000:2D10		    cmp	    ax,	cs:DevLoadAddr
seg000:2D15		    jnz	    short set_break_continue ; if not same, then o.k.
seg000:2D17		    cmp	    word ptr cs:DevBrkAddr, 0
seg000:2D1D		    jz	    short break_failed ; [DevBrkAddr+2]=[memhi]	& [DevBrkAddr]=0
seg000:2D1F
seg000:2D1F set_break_continue:			    ; CODE XREF: DevSetBreak+Bj
seg000:2D1F					    ; DevSetBreak+12j
seg000:2D1F		    call    RoundBreakAddr
seg000:2D22		    pop	    ax
seg000:2D23		    clc
seg000:2D24		    retn
seg000:2D25 ; ---------------------------------------------------------------------------
seg000:2D25
seg000:2D25 break_failed:			    ; CODE XREF: DevSetBreak+1Aj
seg000:2D25		    pop	    ax
seg000:2D26		    stc
seg000:2D27		    retn
seg000:2D27 DevSetBreak	    endp
seg000:2D27
seg000:2D28
seg000:2D28 ; =============== S	U B R O	U T I N	E =======================================
seg000:2D28
seg000:2D28
seg000:2D28 DevBreak	    proc near		    ; CODE XREF: multi_pass+451p
seg000:2D28					    ; multi_pass+45Dp
seg000:2D28		    push    ds
seg000:2D29		    mov	    ax,	cs:DevLoadAddr
seg000:2D2D		    mov	    bx,	word ptr cs:DevBrkAddr+2
seg000:2D32		    dec	    ax		    ; seg of sub-arena
seg000:2D33		    mov	    ds,	ax
seg000:2D35		    inc	    ax		    ; Back to Device segment
seg000:2D36		    sub	    ax,	bx
seg000:2D38		    neg	    ax		    ; size of device in	paras
seg000:2D3A		    mov	    ds:stackcount+1, ax	; [devmark.size]
seg000:2D3D		    cmp	    cs:DeviceHi, 0
seg000:2D43		    jz	    short db_lo
seg000:2D45		    mov	    cs:DevUMBFree, bx ;	update Free ptr	in UMB
seg000:2D4A		    jmp	    short db_exit
seg000:2D4C ; ---------------------------------------------------------------------------
seg000:2D4C
seg000:2D4C db_lo:				    ; CODE XREF: DevBreak+1Bj
seg000:2D4C		    mov	    cs:memhi, bx
seg000:2D51		    mov	    cs:memlo, 0
seg000:2D58
seg000:2D58 db_exit:				    ; CODE XREF: DevBreak+22j
seg000:2D58		    pop	    ds
seg000:2D59		    retn
seg000:2D59 DevBreak	    endp
seg000:2D59
seg000:2D5A
seg000:2D5A ; =============== S	U B R O	U T I N	E =======================================
seg000:2D5A
seg000:2D5A
seg000:2D5A ParseSize	    proc near		    ; CODE XREF: multi_pass+1CFp
seg000:2D5A		    mov	    cs:DevSizeOption, 0	; init the value
seg000:2D61		    mov	    cs:DevCmdLine, si
seg000:2D66		    mov	    cs:DevCmdLine+2, es
seg000:2D6B		    call    SkipDelim
seg000:2D6E		    cmp	    word ptr es:[si], 4953h ; 'SI'
seg000:2D73		    jnz	    short ps_no_size
seg000:2D75		    cmp	    word ptr es:[si+2],	455Ah ;	'ZE'
seg000:2D7B		    jnz	    short ps_no_size
seg000:2D7D		    mov	    al,	es:[si+4]
seg000:2D81		    call    delim
seg000:2D84		    jnz	    short ps_no_size
seg000:2D86		    add	    si,	5
seg000:2D89		    call    GetHexNum
seg000:2D8C		    jb	    short ps_err
seg000:2D8E		    mov	    cs:DevSizeOption, ax
seg000:2D92		    call    SkipDelim
seg000:2D95
seg000:2D95 ps_no_size:				    ; CODE XREF: ParseSize+19j
seg000:2D95					    ; ParseSize+21j ...
seg000:2D95		    clc
seg000:2D96		    retn
seg000:2D97 ; ---------------------------------------------------------------------------
seg000:2D97
seg000:2D97 ps_err:				    ; CODE XREF: ParseSize+32j
seg000:2D97		    stc
seg000:2D98		    retn
seg000:2D98 ParseSize	    endp
seg000:2D98
seg000:2D99
seg000:2D99 ; =============== S	U B R O	U T I N	E =======================================
seg000:2D99
seg000:2D99
seg000:2D99 SkipDelim	    proc near		    ; CODE XREF: ParseSize+11p
seg000:2D99					    ; ParseSize+38p ...
seg000:2D99		    mov	    al,	es:[si]
seg000:2D9C		    call    delim
seg000:2D9F		    jnz	    short sd_ret
seg000:2DA1		    inc	    si
seg000:2DA2		    jmp	    short SkipDelim
seg000:2DA4 ; ---------------------------------------------------------------------------
seg000:2DA4
seg000:2DA4 sd_ret:				    ; CODE XREF: SkipDelim+6j
seg000:2DA4		    retn
seg000:2DA4 SkipDelim	    endp
seg000:2DA4
seg000:2DA5
seg000:2DA5 ; =============== S	U B R O	U T I N	E =======================================
seg000:2DA5
seg000:2DA5
seg000:2DA5 GetHexNum	    proc near		    ; CODE XREF: ParseSize+2Fp
seg000:2DA5		    xor	    ax,	ax
seg000:2DA7		    xor	    dx,	dx
seg000:2DA9
seg000:2DA9 ghn_next:				    ; CODE XREF: GetHexNum+2Bj
seg000:2DA9		    mov	    bl,	es:[si]
seg000:2DAC		    cmp	    bl,	0Dh
seg000:2DAF		    jz	    short ghn_err
seg000:2DB1		    cmp	    bl,	0Ah
seg000:2DB4		    jz	    short ghn_err
seg000:2DB6		    push    ax
seg000:2DB7		    mov	    al,	bl
seg000:2DB9		    call    delim
seg000:2DBC		    pop	    ax
seg000:2DBD		    jz	    short ghn_into_paras
seg000:2DBF		    call    GetNibble
seg000:2DC2		    jb	    short ghn_err
seg000:2DC4		    mov	    cx,	4
seg000:2DC7
seg000:2DC7 ghn_shift1:				    ; CODE XREF: GetHexNum+26j
seg000:2DC7		    shl	    ax,	1
seg000:2DC9		    rcl	    dx,	1
seg000:2DCB		    loop    ghn_shift1
seg000:2DCD		    or	    al,	bl
seg000:2DCF		    inc	    si
seg000:2DD0		    jmp	    short ghn_next
seg000:2DD2 ; ---------------------------------------------------------------------------
seg000:2DD2
seg000:2DD2 ghn_into_paras:			    ; CODE XREF: GetHexNum+18j
seg000:2DD2		    add	    ax,	15
seg000:2DD5		    adc	    dx,	0
seg000:2DD8		    test    dx,	0FFF0h
seg000:2DDC		    jnz	    short ghn_err
seg000:2DDE		    mov	    cx,	4
seg000:2DE1
seg000:2DE1 ghn_shift2:				    ; CODE XREF: GetHexNum+41j
seg000:2DE1		    clc
seg000:2DE2		    rcr	    dx,	1
seg000:2DE4		    rcr	    ax,	1
seg000:2DE6		    loop    ghn_shift2
seg000:2DE8		    clc
seg000:2DE9		    retn
seg000:2DEA ; ---------------------------------------------------------------------------
seg000:2DEA
seg000:2DEA ghn_err:				    ; CODE XREF: GetHexNum+Aj
seg000:2DEA					    ; GetHexNum+Fj ...
seg000:2DEA		    stc
seg000:2DEB		    retn
seg000:2DEB GetHexNum	    endp
seg000:2DEB
seg000:2DEC
seg000:2DEC ; =============== S	U B R O	U T I N	E =======================================
seg000:2DEC
seg000:2DEC
seg000:2DEC GetNibble	    proc near		    ; CODE XREF: GetHexNum+1Ap
seg000:2DEC		    cmp	    bl,	'0'
seg000:2DEF		    jb	    short gnib_err
seg000:2DF1		    cmp	    bl,	'9'
seg000:2DF4		    ja	    short is_it_hex
seg000:2DF6		    sub	    bl,	'0'         ; clc
seg000:2DF9		    retn
seg000:2DFA ; ---------------------------------------------------------------------------
seg000:2DFA
seg000:2DFA is_it_hex:				    ; CODE XREF: GetNibble+8j
seg000:2DFA		    cmp	    bl,	'A'         ; 41h
seg000:2DFD		    jb	    short gnib_err
seg000:2DFF		    cmp	    bl,	'F'         ; 46h
seg000:2E02		    ja	    short gnib_err
seg000:2E04		    sub	    bl,	37h	    ; 'A'-10 ; clc
seg000:2E07		    retn
seg000:2E08 ; ---------------------------------------------------------------------------
seg000:2E08
seg000:2E08 gnib_err:				    ; CODE XREF: GetNibble+3j
seg000:2E08					    ; GetNibble+11j ...
seg000:2E08		    stc
seg000:2E09		    retn
seg000:2E09 GetNibble	    endp
seg000:2E09
seg000:2E0A
seg000:2E0A ; =============== S	U B R O	U T I N	E =======================================
seg000:2E0A
seg000:2E0A
seg000:2E0A AllocUMB	    proc near		    ; CODE XREF: multi_pass+2EEp
seg000:2E0A		    call    InitAllocUMB    ; link in the first	UMB
seg000:2E0D		    jb	    short au_exit   ; quit on error
seg000:2E0F
seg000:2E0F au_next:				    ; CODE XREF: AllocUMB+Dj
seg000:2E0F		    call    umb_allocate    ; allocate
seg000:2E12		    jb	    short au_coalesce
seg000:2E14		    call    umb_insert	    ; &	insert till no UMBs
seg000:2E17		    jmp	    short au_next
seg000:2E19 ; ---------------------------------------------------------------------------
seg000:2E19
seg000:2E19 au_coalesce:			    ; CODE XREF: AllocUMB+8j
seg000:2E19		    call    umb_coalesce    ; coalesce all UMBs
seg000:2E1C
seg000:2E1C au_exit:				    ; CODE XREF: AllocUMB+3j
seg000:2E1C		    retn
seg000:2E1C AllocUMB	    endp
seg000:2E1C
seg000:2E1D
seg000:2E1D ; =============== S	U B R O	U T I N	E =======================================
seg000:2E1D
seg000:2E1D
seg000:2E1D InitAllocUMB    proc near		    ; CODE XREF: AllocUMBp
seg000:2E1D		    call    IsXMSLoaded
seg000:2E20		    jnz	    short iau_err   ; quit on no XMS driver
seg000:2E22		    mov	    ah,	52h	    ; get DOS DATA seg
seg000:2E24		    int	    21h		    ; DOS - 2+ internal	- GET LIST OF LISTS
seg000:2E24					    ; Return: ES:BX -> DOS list	of lists
seg000:2E26		    mov	    cs:DevDOSData, es ;	& save it for later
seg000:2E2B		    mov	    ax,	4310h
seg000:2E2E		    int	    2Fh		    ; -	Multiplex - XMS	- GET DRIVER ADDRESS
seg000:2E2E					    ; Return: ES:BX -> driver entry point
seg000:2E30		    mov	    word ptr cs:DevXMSAddr, bx
seg000:2E35		    mov	    word ptr cs:DevXMSAddr+2, es
seg000:2E3A		    cmp	    cs:FirstUMBLinked, 0 ; have	we already linked a UMB?
seg000:2E40		    jnz	    short ia_1	    ; quit if we already did it
seg000:2E42		    call    LinkFirstUMB    ; else link	the first UMB
seg000:2E45		    jb	    short iau_err
seg000:2E47		    mov	    cs:FirstUMBLinked, 0FFh ; mark that	1st UMB	linked
seg000:2E4D
seg000:2E4D ia_1:				    ; CODE XREF: InitAllocUMB+23j
seg000:2E4D		    clc
seg000:2E4E		    retn
seg000:2E4F ; ---------------------------------------------------------------------------
seg000:2E4F
seg000:2E4F iau_err:				    ; CODE XREF: InitAllocUMB+3j
seg000:2E4F					    ; InitAllocUMB+28j
seg000:2E4F		    stc
seg000:2E50		    retn
seg000:2E50 InitAllocUMB    endp
seg000:2E50
seg000:2E51
seg000:2E51 ; =============== S	U B R O	U T I N	E =======================================
seg000:2E51
seg000:2E51
seg000:2E51 umb_allocate    proc near		    ; CODE XREF: AllocUMB:au_nextp
seg000:2E51					    ; LinkFirstUMBp
seg000:2E51		    push    ax
seg000:2E52		    mov	    ah,	10h	    ; XMM_REQUEST_UMB ;	16
seg000:2E54		    mov	    dx,	0FFFFh	    ; try to allocate largest possible
seg000:2E57		    call    cs:DevXMSAddr   ; dx now contains the size of
seg000:2E57					    ; the largest UMB
seg000:2E5C		    or	    dx,	dx
seg000:2E5E		    jz	    short ua_err
seg000:2E60		    mov	    ah,	10h	    ; XMM_REQUEST_UMB ;	16
seg000:2E62		    call    cs:DevXMSAddr
seg000:2E67		    cmp	    ax,	1	    ; Q: was the reqst successful
seg000:2E6A		    jnz	    short ua_err    ; N: error
seg000:2E6C		    clc
seg000:2E6D
seg000:2E6D ua_done:				    ; CODE XREF: umb_allocate+1Fj
seg000:2E6D		    pop	    ax
seg000:2E6E		    retn
seg000:2E6F ; ---------------------------------------------------------------------------
seg000:2E6F
seg000:2E6F ua_err:				    ; CODE XREF: umb_allocate+Dj
seg000:2E6F					    ; umb_allocate+19j
seg000:2E6F		    stc
seg000:2E70		    jmp	    short ua_done
seg000:2E70 umb_allocate    endp
seg000:2E70
seg000:2E72
seg000:2E72 ; =============== S	U B R O	U T I N	E =======================================
seg000:2E72
seg000:2E72
seg000:2E72 umb_insert	    proc near		    ; CODE XREF: AllocUMB+Ap
seg000:2E72		    push    ds
seg000:2E73		    mov	    ds,	cs:DevDOSData
seg000:2E78		    mov	    ds,	word ptr ds:old0C+3 ; [8Ch]
seg000:2E78					    ; [UMB_ARENA]
seg000:2E7C		    assume ds:nothing
seg000:2E7C		    mov	    ax,	ds
seg000:2E7E		    mov	    es,	ax
seg000:2E80		    assume es:nothing
seg000:2E80
seg000:2E80 ui_next:				    ; CODE XREF: umb_insert+1Fj
seg000:2E80		    cmp	    ax,	bx	    ; Q: is current block above
seg000:2E80					    ; new block
seg000:2E82		    ja	    short ui_insert ; Y: insert	it
seg000:2E82					    ;
seg000:2E82					    ; Q: is current block the last
seg000:2E84		    cmp	    byte ptr es:0, 'Z' ; [es:ARENA.SIGNATURE],
seg000:2E84					    ; arena_signature_end ; 'Z'
seg000:2E8A		    jz	    short ui_append ; Y: append	new block to chain
seg000:2E8C		    mov	    ds,	ax	    ; N: get next block
seg000:2E8E		    call    get_next
seg000:2E91		    jmp	    short ui_next
seg000:2E93 ; ---------------------------------------------------------------------------
seg000:2E93
seg000:2E93 ui_insert:				    ; CODE XREF: umb_insert+10j
seg000:2E93		    mov	    cx,	ds	    ; ds = previous arena
seg000:2E95		    inc	    cx		    ; top of previous block
seg000:2E96		    sub	    cx,	bx
seg000:2E98		    neg	    cx		    ; cx = size	of used	block
seg000:2E9A		    mov	    byte ptr ds:0, 'M' ; [ARENA.SIGNATURE],
seg000:2E9A					    ; arena_signature_normal ; 'M'
seg000:2E9F		    mov	    word ptr ds:1, 8 ; [ARENA.OWNER]
seg000:2E9F					    ; mark as system owned
seg000:2EA5		    mov	    ds:3, cx	    ; [ARENA.SIZE]
seg000:2EA9		    mov	    word ptr ds:8, 4353h ; [ARENA.NAME],
seg000:2EA9					    ; 'SC'
seg000:2EAF		    mov	    es,	bx
seg000:2EB1		    assume es:nothing
seg000:2EB1		    mov	    byte ptr es:SYSINIT$, 'M' ; [es:ARENA.SIGNATURE],
seg000:2EB1					    ; arena_signature_normal
seg000:2EB7		    mov	    es:SYSINIT$+1, 0 ; [es:ARENA.OWNER],
seg000:2EB7					    ; arena_owner_system
seg000:2EB7					    ; mark as free
seg000:2EBE		    sub	    dx,	2	    ; make room	for arena at
seg000:2EBE					    ; start & end of new block
seg000:2EC1		    mov	    es:stackcount+1, dx	; [es:ARENA.SIZE]
seg000:2EC6		    add	    bx,	dx
seg000:2EC8		    inc	    bx
seg000:2EC9		    mov	    es,	bx	    ; es=arena at top of new block
seg000:2ECB		    inc	    bx		    ; ax contains arena	just above this	block
seg000:2ECC		    sub	    ax,	bx	    ; ax = size	of used	block
seg000:2ECE		    mov	    byte ptr es:SYSINIT$, 4Dh ;	'M' ; [es:ARENA.SIGNATURE],
seg000:2ECE					    ; arena_signature_normal
seg000:2ED4		    mov	    es:SYSINIT$+1, 8 ; [es:ARENA.OWNER]
seg000:2ED4					    ; mark as system owned
seg000:2EDB		    mov	    es:stackcount+1, ax	; [es:ARENA.SIZE]
seg000:2EDF		    mov	    word ptr es:stacks,	4353h ;	'SC'
seg000:2EDF					    ; [es:ARENA.NAME]
seg000:2EE6		    jmp	    short ui_done
seg000:2EE8 ; ---------------------------------------------------------------------------
seg000:2EE8
seg000:2EE8 ui_append:				    ; CODE XREF: umb_insert+18j
seg000:2EE8		    add	    ax,	es:stackcount+1	; [es:ARENA.SIZE]
seg000:2EE8					    ; ax=top of	last block-1 para
seg000:2EED		    sub	    es:stackcount+1, 1 ; reflect the space we are
seg000:2EED					    ; going to rsrv on top of this block
seg000:2EED					    ; for the next arena.
seg000:2EF3		    mov	    byte ptr es:SYSINIT$, 'M' ; [es:ARENA.SIGNATURE],
seg000:2EF3					    ; arena_signature_normal
seg000:2EF9		    mov	    cx,	ax	    ; cx=top of	prev block-1
seg000:2EFB		    inc	    ax
seg000:2EFC		    sub	    ax,	bx	    ; ax=top of	prev block -
seg000:2EFC					    ;	 seg. address of new block
seg000:2EFE		    neg	    ax
seg000:2F00		    mov	    es,	cx	    ; ds = arena of unused block
seg000:2F02		    mov	    byte ptr es:SYSINIT$, 'M'
seg000:2F08		    mov	    es:SYSINIT$+1, 8
seg000:2F0F		    mov	    es:stackcount+1, ax
seg000:2F13		    mov	    word ptr es:stacks,	4353h ;	'SC'
seg000:2F1A		    mov	    es,	bx
seg000:2F1C		    mov	    byte ptr es:SYSINIT$, 5Ah ;	'Z' ; [es:ARENA.SIGNATURE],
seg000:2F1C					    ; arena_signature_end
seg000:2F22		    mov	    es:SYSINIT$+1, 0 ; arena_owner_system
seg000:2F22					    ;  mark as free
seg000:2F29		    dec	    dx		    ; make room	for arena
seg000:2F2A		    mov	    es:stackcount+1, dx	; [es:ARENA.SIZE]
seg000:2F2F
seg000:2F2F ui_done:				    ; CODE XREF: umb_insert+74j
seg000:2F2F		    pop	    ds
seg000:2F30		    assume ds:nothing
seg000:2F30		    retn
seg000:2F30 umb_insert	    endp
seg000:2F30
seg000:2F31
seg000:2F31 ; =============== S	U B R O	U T I N	E =======================================
seg000:2F31
seg000:2F31
seg000:2F31 umb_coalesce    proc near		    ; CODE XREF: AllocUMB:au_coalescep
seg000:2F31		    xor	    di,	di
seg000:2F33		    mov	    es,	cs:DevDOSData
seg000:2F38		    mov	    es,	word ptr es:old0C+3 ; [es:UMB_ARENA]
seg000:2F38					    ; es = UMB_HEAD
seg000:2F3D		    assume es:nothing
seg000:2F3D
seg000:2F3D uc_nextfree:			    ; CODE XREF: umb_coalesce+1Cj
seg000:2F3D					    ; umb_coalesce+28j
seg000:2F3D		    mov	    ax,	es
seg000:2F3F		    mov	    ds,	ax
seg000:2F41		    assume ds:nothing
seg000:2F41		    cmp	    es:1, di	    ; [es:ARENA.OWNER]
seg000:2F41					    ; Q: is current arena free
seg000:2F46		    jz	    short uc_again  ; Y: try to	coalesce with next block
seg000:2F46					    ; N: get next arena
seg000:2F48		    call    get_next	    ; es, ax = next arena
seg000:2F4B		    jb	    short uc_done
seg000:2F4D		    jmp	    short uc_nextfree
seg000:2F4F ; ---------------------------------------------------------------------------
seg000:2F4F
seg000:2F4F uc_again:				    ; CODE XREF: umb_coalesce+15j
seg000:2F4F					    ; umb_coalesce+39j
seg000:2F4F		    call    get_next	    ; ES, AX <-	next block
seg000:2F52		    jb	    short uc_done
seg000:2F54		    cmp	    es:1, di	    ; [es:ARENA.OWNER]
seg000:2F54					    ; Q: is arena free
seg000:2F59		    jnz	    short uc_nextfree
seg000:2F5B		    mov	    cx,	es:3	    ; [es:ARENA.SIZE]
seg000:2F5B					    ; cx <- next block size
seg000:2F60		    inc	    cx		    ; cx <- cx + 1 (for	header size)
seg000:2F61		    add	    ds:3, cx	    ; [ARENA.SIZE]
seg000:2F61					    ; current size <- current size + cx
seg000:2F65		    mov	    cl,	es:[di]	    ; move up signature
seg000:2F68		    mov	    [di], cl
seg000:2F6A		    jmp	    short uc_again  ; try again
seg000:2F6C ; ---------------------------------------------------------------------------
seg000:2F6C
seg000:2F6C uc_done:				    ; CODE XREF: umb_coalesce+1Aj
seg000:2F6C					    ; umb_coalesce+21j
seg000:2F6C		    retn
seg000:2F6C umb_coalesce    endp
seg000:2F6C
seg000:2F6D
seg000:2F6D ; =============== S	U B R O	U T I N	E =======================================
seg000:2F6D
seg000:2F6D
seg000:2F6D get_next	    proc near		    ; CODE XREF: umb_insert+1Cp
seg000:2F6D					    ; umb_coalesce+17p	...
seg000:2F6D		    cmp	    byte ptr ds:0, 5Ah ; 'Z' ; arena_signature_end
seg000:2F72		    jz	    short gn_err
seg000:2F74		    mov	    ax,	ds	    ; ax=current block
seg000:2F76		    add	    ax,	ds:3	    ; [ARENA.SIZE]
seg000:2F76					    ; ax=ax + current block length
seg000:2F7A		    inc	    ax
seg000:2F7B		    mov	    es,	ax
seg000:2F7D		    assume es:nothing
seg000:2F7D		    clc
seg000:2F7E		    retn
seg000:2F7F ; ---------------------------------------------------------------------------
seg000:2F7F
seg000:2F7F gn_err:				    ; CODE XREF: get_next+5j
seg000:2F7F		    stc
seg000:2F80		    retn
seg000:2F80 get_next	    endp
seg000:2F80
seg000:2F81
seg000:2F81 ; =============== S	U B R O	U T I N	E =======================================
seg000:2F81
seg000:2F81
seg000:2F81 LinkFirstUMB    proc near		    ; CODE XREF: InitAllocUMB+25p
seg000:2F81		    call    umb_allocate
seg000:2F84		    jb	    short lfu_err
seg000:2F86		    int	    12h		    ; MEMORY SIZE -
seg000:2F86					    ; Return: AX = number of contiguous	1K blocks of memory
seg000:2F88		    mov	    cl,	6
seg000:2F8A		    shl	    ax,	cl	    ; ax = size	in paragraphs
seg000:2F8C		    mov	    cx,	ax	    ; bx = segment of allocated	UMB
seg000:2F8C					    ; dx = size	of UMB
seg000:2F8E		    sub	    ax,	bx
seg000:2F90		    neg	    ax
seg000:2F92		    sub	    cx,	1	    ; cx = first umb_arena
seg000:2F95		    mov	    es,	cx	    ; es = first umb_arena
seg000:2F97		    mov	    byte ptr es:SYSINIT$, 4Dh ;	'M' ; [es:ARENA.SIGNATURE],
seg000:2F97					    ; arena_signature_normal
seg000:2F9D		    mov	    es:SYSINIT$+1, 8
seg000:2FA4		    mov	    es:stackcount+1, ax	; [es:ARENA.SIZE]
seg000:2FA8		    mov	    word ptr es:stacks,	4353h ;	'SC'
seg000:2FA8					    ; [es:ARENA.NAME]
seg000:2FAF		    mov	    es,	bx	    ; es has first free	umb seg
seg000:2FB1		    mov	    byte ptr es:SYSINIT$, 5Ah ;	'Z' ; [es:ARENA.SIGNATURE],
seg000:2FB1					    ; arena_signature_end
seg000:2FB7		    mov	    es:SYSINIT$+1, 0 ; [es:ARENA.OWNER],
seg000:2FB7					    ; arena_owner_system ; 0
seg000:2FB7					    ; mark as free
seg000:2FBE		    dec	    dx		    ; make room	for arena
seg000:2FBF		    mov	    es:stackcount+1, dx	; [es:ARENA.SIZE]
seg000:2FC4		    mov	    es,	cs:DevDOSData
seg000:2FC9		    mov	    di,	8Ch	    ; UMB_ARENA
seg000:2FCC		    mov	    es:[di], cx	    ; initialize umb_head in DOS data segment
seg000:2FCC					    ; with the arena just below	Top of Mem
seg000:2FCF		    mov	    di,	24h	    ; DOS_ARENA
seg000:2FD2		    mov	    es,	word ptr es:[di] ; es =	start arena
seg000:2FD5		    xor	    di,	di
seg000:2FD7
seg000:2FD7 scan_next:				    ; CODE XREF: LinkFirstUMB+66j
seg000:2FD7		    cmp	    byte ptr es:[di], 'Z' ; arena_signature_end
seg000:2FDB		    jz	    short got_last
seg000:2FDD		    mov	    ax,	es
seg000:2FDF		    add	    ax,	es:stackcount+1	; [es:ARENA.SIZE]
seg000:2FE4		    inc	    ax
seg000:2FE5		    mov	    es,	ax
seg000:2FE7		    jmp	    short scan_next
seg000:2FE9 ; ---------------------------------------------------------------------------
seg000:2FE9
seg000:2FE9 got_last:				    ; CODE XREF: LinkFirstUMB+5Aj
seg000:2FE9		    sub	    es:stackcount+1, 1 ; [es:3]
seg000:2FE9					    ; [es:ARENA.SIZE]
seg000:2FEF		    mov	    byte ptr es:SYSINIT$, 'M' ; [es:ARENA.SIGNATURE],
seg000:2FEF					    ; arena_signature_normal
seg000:2FF5		    clc
seg000:2FF6		    retn
seg000:2FF7 ; ---------------------------------------------------------------------------
seg000:2FF7
seg000:2FF7 lfu_err:				    ; CODE XREF: LinkFirstUMB+3j
seg000:2FF7		    stc
seg000:2FF8		    retn
seg000:2FF8 LinkFirstUMB    endp
seg000:2FF8
seg000:2FF9
seg000:2FF9 ; =============== S	U B R O	U T I N	E =======================================
seg000:2FF9
seg000:2FF9
seg000:2FF9 ShrinkUMB	    proc near		    ; CODE XREF: seg000:077Cp
seg000:2FF9					    ; InitDevLoad+Dp
seg000:2FF9		    cmp	    cs:DevUMBAddr, 0
seg000:2FFF		    jz	    short su_exit
seg000:3001		    push    es
seg000:3002		    push    bx
seg000:3003		    mov	    bx,	cs:DevUMBFree
seg000:3008		    sub	    bx,	cs:DevUMBAddr
seg000:300D		    mov	    es,	cs:DevUMBAddr
seg000:3012		    mov	    ax,	4A00h
seg000:3015		    int	    21h		    ; DOS - 2+ - ADJUST	MEMORY BLOCK SIZE (SETBLOCK)
seg000:3015					    ; ES = segment address of block to change
seg000:3015					    ; BX = new size in paragraphs
seg000:3017		    mov	    ax,	es
seg000:3019		    dec	    ax
seg000:301A		    mov	    es,	ax
seg000:301C		    mov	    es:SYSINIT$+1, 8 ; [es:1]
seg000:301C					    ; [es:ARENA.OWNER]
seg000:3023		    pop	    bx
seg000:3024		    pop	    es
seg000:3025
seg000:3025 su_exit:				    ; CODE XREF: ShrinkUMB+6j
seg000:3025		    retn
seg000:3025 ShrinkUMB	    endp
seg000:3025
seg000:3026
seg000:3026 ; =============== S	U B R O	U T I N	E =======================================
seg000:3026
seg000:3026
seg000:3026 UnlinkUMB	    proc near		    ; CODE XREF: seg000:077Fp
seg000:3026		    push    ds
seg000:3027		    push    es
seg000:3028		    cmp	    cs:FirstUMBLinked, 0
seg000:302E		    jz	    short ulu_x	    ; nothing to unlink
seg000:3030		    mov	    es,	cs:DevDOSData ;	get DOS	data seg
seg000:3035		    mov	    ds,	word ptr es:loc_24 ; [es:24h]
seg000:3035					    ; [es:DOS_ARENA]
seg000:303A		    assume ds:nothing
seg000:303A		    mov	    di,	word ptr es:old0C+3 ; [es:8Ch]
seg000:303A					    ; [es:UMB_ARENA]
seg000:303F
seg000:303F ulu_next:				    ; CODE XREF: UnlinkUMB+24j
seg000:303F		    call    get_next
seg000:3042		    jb	    short ulu_x
seg000:3044		    cmp	    di,	ax
seg000:3046		    jz	    short ulu_found
seg000:3048		    mov	    ds,	ax
seg000:304A		    assume ds:nothing
seg000:304A		    jmp	    short ulu_next
seg000:304C ; ---------------------------------------------------------------------------
seg000:304C
seg000:304C ulu_found:				    ; CODE XREF: UnlinkUMB+20j
seg000:304C		    mov	    byte ptr ds:SYSINIT$, 'Z' ; [ARENA.SIGNATURE],
seg000:304C					    ; arena_signature_end
seg000:3051
seg000:3051 ulu_x:				    ; CODE XREF: UnlinkUMB+8j
seg000:3051					    ; UnlinkUMB+1Cj
seg000:3051		    pop	    es
seg000:3052		    pop	    ds
seg000:3053		    retn
seg000:3053 UnlinkUMB	    endp
seg000:3053
seg000:3053 ; ---------------------------------------------------------------------------
seg000:3054 insert_blank    db 0		    ; DATA XREF: organize+18Bw
seg000:3054					    ; organize:org_dhlfr ...
seg000:3055
seg000:3055 ; =============== S	U B R O	U T I N	E =======================================
seg000:3055
seg000:3055
seg000:3055 setparms	    proc near		    ; CODE XREF: multi_pass+606p
seg000:3055		    push    ds
seg000:3056		    push    ax
seg000:3057		    push    bx
seg000:3058		    push    cx
seg000:3059		    push    dx
seg000:305A		    push    cs
seg000:305B		    pop	    ds
seg000:305C		    xor	    bx,	bx
seg000:305E		    mov	    bl,	ds:drive
seg000:3062		    inc	    bl		    ; get it correct for ioctl call
seg000:3062					    ; (1=a,2=b...)
seg000:3064		    mov	    dx,	offset devp_specialfunc	; deviceparameters
seg000:3067		    mov	    ah,	44h	    ; IOCTL
seg000:3069		    mov	    al,	0Dh	    ; GENERIC_IOCTL
seg000:306B		    mov	    ch,	8	    ; RAWIO
seg000:306D		    mov	    cl,	40h	    ; SET_DEVICE_PARAMETERS
seg000:306F		    int	    21h		    ; DOS - 2+ - IOCTL -
seg000:3071		    test    ds:switches, 4  ; flagec35
seg000:3077		    jz	    short eot_ok
seg000:3079		    mov	    cl,	ds:drive    ; which drive was this for?
seg000:307D		    mov	    ax,	70h
seg000:3080		    mov	    ds,	ax	    ; DOSBIODATASEG
seg000:3082		    assume ds:nothing
seg000:3082		    mov	    al,	1	    ; assume drive 0
seg000:3084		    shl	    al,	cl	    ; set proper bit depending on drive
seg000:3086		    or	    ds:531h, al	    ; [ec35_flag]
seg000:3086					    ; set the bit in the permanent flags
seg000:308A
seg000:308A eot_ok:				    ; CODE XREF: setparms+22j
seg000:308A		    pop	    dx
seg000:308B		    pop	    cx
seg000:308C		    pop	    bx
seg000:308D		    pop	    ax
seg000:308E		    pop	    ds
seg000:308F		    assume ds:nothing
seg000:308F		    retn
seg000:308F setparms	    endp
seg000:308F
seg000:3090
seg000:3090 ; =============== S	U B R O	U T I N	E =======================================
seg000:3090
seg000:3090
seg000:3090 diddleback	    proc near		    ; CODE XREF: multi_pass+609p
seg000:3090		    push    ds
seg000:3091		    push    cs
seg000:3092		    pop	    ds
seg000:3093		    mov	    ds:devp_cylinders, 80 ; [deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS]
seg000:3099		    mov	    ds:devp_devtype, 2 ; [deviceparameters+A_DEVICEPARAMETERS.DP_DEVICETYPE],
seg000:3099					    ; DEV_3INCH720KB
seg000:309E		    mov	    ds:devp_devattr, 0 ; [deviceparameters+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES]
seg000:30A4		    mov	    ds:switches, 0  ; zero all switches
seg000:30AA		    pop	    ds
seg000:30AB		    retn
seg000:30AB diddleback	    endp
seg000:30AB
seg000:30AC
seg000:30AC ; =============== S	U B R O	U T I N	E =======================================
seg000:30AC
seg000:30AC
seg000:30AC parseline	    proc near		    ; CODE XREF: multi_pass+601p
seg000:30AC		    push    ds
seg000:30AD		    push    cs
seg000:30AE		    pop	    ds
seg000:30AF
seg000:30AF nextswtch:				    ; CODE XREF: parseline+24j
seg000:30AF		    cmp	    al,	0Dh	    ; carriage return?
seg000:30B1		    jz	    short done_line
seg000:30B3		    cmp	    al,	0Ah	    ; linefeed?
seg000:30B5		    jz	    short put_back  ; put it back and done
seg000:30B7		    cmp	    al,	' '         ; space?
seg000:30B9		    jbe	    short getnext   ; skip over	space
seg000:30BB		    cmp	    al,	'/'
seg000:30BD		    jz	    short getparm
seg000:30BF		    stc			    ; mark error invalid-character-in-input
seg000:30C0		    jmp	    short exitpl
seg000:30C2 ; ---------------------------------------------------------------------------
seg000:30C2
seg000:30C2 getparm:				    ; CODE XREF: parseline+11j
seg000:30C2		    call    check_switch
seg000:30C5		    mov	    ds:switches, bx ; save switches read so far
seg000:30C9		    jb	    short swterr
seg000:30CB
seg000:30CB getnext:				    ; CODE XREF: parseline+Dj
seg000:30CB		    call    getchr
seg000:30CE		    jb	    short done_line
seg000:30D0		    jmp	    short nextswtch
seg000:30D2 ; ---------------------------------------------------------------------------
seg000:30D2
seg000:30D2 swterr:				    ; CODE XREF: parseline+1Dj
seg000:30D2		    jmp	    short exitpl
seg000:30D4 ; ---------------------------------------------------------------------------
seg000:30D4
seg000:30D4 done_line:				    ; CODE XREF: parseline+5j
seg000:30D4					    ; parseline+22j ...
seg000:30D4		    test    ds:switches, 8  ; flagdrive
seg000:30D4					    ; see if drive specified
seg000:30DA		    jnz	    short okay
seg000:30DC		    stc
seg000:30DD		    jmp	    short exitpl
seg000:30DF ; ---------------------------------------------------------------------------
seg000:30DF
seg000:30DF okay:				    ; CODE XREF: parseline+2Ej
seg000:30DF		    mov	    ax,	ds:switches
seg000:30E2		    and	    ax,	3	    ; get flag bits for	changeline and non-rem
seg000:30E5		    mov	    ds:devp_devattr, ax	; [deviceparameters+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES]
seg000:30E8		    mov	    word ptr ds:devparms_20+12h, 0
seg000:30EE		    clc
seg000:30EF		    call    setdeviceparameters
seg000:30F2
seg000:30F2 exitpl:				    ; CODE XREF: parseline+14j
seg000:30F2					    ; parseline:swterrj ...
seg000:30F2		    pop	    ds
seg000:30F3		    retn
seg000:30F4 ; ---------------------------------------------------------------------------
seg000:30F4
seg000:30F4 put_back:				    ; CODE XREF: parseline+9j
seg000:30F4		    inc	    ds:count	    ; one more char to scan
seg000:30F8		    dec	    ds:chrptr	    ; back up over linefeed
seg000:30FC		    jmp	    short done_line
seg000:30FC parseline	    endp
seg000:30FC
seg000:30FE
seg000:30FE ; =============== S	U B R O	U T I N	E =======================================
seg000:30FE
seg000:30FE
seg000:30FE check_switch    proc near		    ; CODE XREF: parseline:getparmp
seg000:30FE		    call    getchr
seg000:3101		    jb	    short err_check
seg000:3103		    and	    al,	0DFh	    ; convert it to upper case
seg000:3105		    cmp	    al,	'A'
seg000:3107		    jb	    short err_check
seg000:3109		    cmp	    al,	'Z'
seg000:310B		    ja	    short err_check
seg000:310D		    push    es
seg000:310E		    push    cs
seg000:310F		    pop	    es
seg000:3110		    mov	    cl,	byte ptr ds:switchlist ; get number of valid switches
seg000:3114		    mov	    ch,	0
seg000:3116		    mov	    di,	(offset	switchlist+1) ;	point to string	of valid switches
seg000:3119		    repne scasb
seg000:311B		    pop	    es
seg000:311C		    jnz	    short err_check
seg000:311E		    mov	    ax,	1
seg000:3121		    shl	    ax,	cl	    ; set bit to indicate switch
seg000:3123		    mov	    bx,	ds:switches ; get switches so far
seg000:3127		    or	    bx,	ax	    ; save this	with other switches
seg000:3129		    mov	    cx,	ax
seg000:312B		    test    ax,	0F8h	    ; switchnum
seg000:312B					    ; test against switches that require number	to follow
seg000:312E		    jz	    short done_swtch
seg000:3130		    call    getchr
seg000:3133		    jb	    short err_swtch
seg000:3135		    cmp	    al,	':'
seg000:3137		    jnz	    short err_swtch
seg000:3139		    call    getchr
seg000:313C		    push    bx
seg000:313D		    mov	    cs:sepchr, 20h ; ' ' ; allow space separators
seg000:3143		    call    getnum
seg000:3146		    mov	    cs:sepchr, 0
seg000:314C		    pop	    bx
seg000:314D		    call    process_num
seg000:3150
seg000:3150 done_swtch:				    ; CODE XREF: check_switch+30j
seg000:3150		    clc
seg000:3151		    retn
seg000:3152 ; ---------------------------------------------------------------------------
seg000:3152
seg000:3152 err_swtch:				    ; CODE XREF: check_switch+35j
seg000:3152					    ; check_switch+39j
seg000:3152		    xor	    bx,	cx	    ; remove this switch from the records
seg000:3154
seg000:3154 err_check:				    ; CODE XREF: check_switch+3j
seg000:3154					    ; check_switch+9j ...
seg000:3154		    stc
seg000:3155		    retn
seg000:3155 check_switch    endp
seg000:3155
seg000:3156
seg000:3156 ; =============== S	U B R O	U T I N	E =======================================
seg000:3156
seg000:3156
seg000:3156 process_num	    proc near		    ; CODE XREF: check_switch+4Fp
seg000:3156		    test    ds:switches, cx ; if this switch has been done before,
seg000:3156					    ; ignore this one.
seg000:315A		    jnz	    short done_ret
seg000:315C		    test    cx,	8	    ; flagdrive
seg000:3160		    jz	    short try_f
seg000:3162		    mov	    ds:drive, al
seg000:3165		    jmp	    short done_ret
seg000:3167 ; ---------------------------------------------------------------------------
seg000:3167
seg000:3167 try_f:				    ; CODE XREF: process_num+Aj
seg000:3167		    test    cx,	80h	    ; flagff
seg000:316B		    jz	    short try_t	    ; flagff
seg000:316D		    mov	    ds:devp_devtype, al	; [deviceparameters+1]
seg000:316D					    ; [deviceparameters+A_DEVICEPARAMETERS.DP_DEVICETYPE]
seg000:3170		    jmp	    short done_ret
seg000:3172 ; ---------------------------------------------------------------------------
seg000:3172
seg000:3172 try_t:				    ; CODE XREF: process_num+15j
seg000:3172		    or	    ax,	ax
seg000:3174		    jz	    short done_ret  ; if number	entered	was 0, assume default value
seg000:3176		    test    cx,	10h	    ; flagcyln
seg000:317A		    jz	    short try_s
seg000:317C		    mov	    ds:devp_cylinders, ax ; deviceparameters+4]	[deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS]
seg000:317F		    jmp	    short done_ret
seg000:3181 ; ---------------------------------------------------------------------------
seg000:3181
seg000:3181 try_s:				    ; CODE XREF: process_num+24j
seg000:3181		    test    cx,	20h	    ; flagseclim
seg000:3185		    jz	    short try_h
seg000:3187		    mov	    ds:slim, ax
seg000:318A		    jmp	    short done_ret
seg000:318C ; ---------------------------------------------------------------------------
seg000:318C
seg000:318C try_h:				    ; CODE XREF: process_num+2Fj
seg000:318C		    mov	    ds:hlim, ax
seg000:318F
seg000:318F done_ret:				    ; CODE XREF: process_num+4j
seg000:318F					    ; process_num+Fj ...
seg000:318F		    clc
seg000:3190		    retn
seg000:3190 process_num	    endp
seg000:3190
seg000:3191
seg000:3191 ; =============== S	U B R O	U T I N	E =======================================
seg000:3191
seg000:3191
seg000:3191 setdeviceparameters	proc near	    ; CODE XREF: parseline+43p
seg000:3191		    push    es
seg000:3192		    push    cs
seg000:3193		    pop	    es
seg000:3194		    xor	    bx,	bx
seg000:3196		    mov	    bl,	ds:devp_devtype	; [deviceparameters+A_DEVICEPARAMETERS.DP_DEVICETYPE]
seg000:319A		    cmp	    bl,	0	    ; DEV_5INCH
seg000:319D		    jnz	    short got_80
seg000:319F		    mov	    ds:devp_cylinders, 40 ; [deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS]
seg000:31A5
seg000:31A5 got_80:				    ; CODE XREF: setdeviceparameters+Cj
seg000:31A5		    shl	    bx,	1	    ; get index	into bpb table
seg000:31A7		    mov	    si,	ds:bpbtable[bx]	; [bpbtable+bx]
seg000:31A7					    ; get address of bpb
seg000:31AB		    mov	    di,	offset devparms_7 ; [deviceparameters+7]
seg000:31AB					    ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB]
seg000:31AB					    ; es:di -> bpb
seg000:31AE		    mov	    cx,	31	    ; A_BPB.size
seg000:31B1		    cld
seg000:31B2		    rep	movsb
seg000:31B4		    pop	    es
seg000:31B5		    test    ds:switches, 20h ; flagseclim
seg000:31BB		    jz	    short see_heads
seg000:31BD		    mov	    ax,	ds:slim
seg000:31C0		    mov	    word ptr ds:devparms_20, ax	; [deviceparameters+20]
seg000:31C0					    ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_SECTORSPERTRACK]
seg000:31C3
seg000:31C3 see_heads:				    ; CODE XREF: setdeviceparameters+2Aj
seg000:31C3		    test    ds:switches, 40h ; flagheads
seg000:31C9		    jz	    short heads_not_altered
seg000:31CB		    mov	    ax,	ds:hlim
seg000:31CE		    mov	    word ptr ds:devparms_20+2, ax ; [deviceparameters+22]
seg000:31CE					    ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_HEADS]
seg000:31D1
seg000:31D1 heads_not_altered:			    ; CODE XREF: setdeviceparameters+38j
seg000:31D1		    mov	    ds:devparms_9, 2 ; [deviceparameters+9]
seg000:31D1					    ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_SECTORSPERCLUSTER]
seg000:31D6		    mov	    bl,	0F0h	    ; get default mediabyte
seg000:31D8		    mov	    bh,	ds:devparms_17 ; [deviceparameters+17]
seg000:31D8					    ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_MEDIADESCRIPTOR]
seg000:31DC		    cmp	    word ptr ds:devparms_20+2, 2 ; [deviceparameters+22]
seg000:31E1		    ja	    short got_correct_mediad
seg000:31E3		    jnz	    short only_one_head
seg000:31E5		    mov	    bl,	bh	    ; get mediadescriptor from bpb
seg000:31E7		    cmp	    word ptr ds:devparms_20, 18	; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_SECTORSPERTRACK]
seg000:31EC		    jnz	    short not_144m
seg000:31EE		    cmp	    ds:devp_cylinders, 80
seg000:31F3		    jnz	    short not_144m
seg000:31F5		    jmp	    short got_one_secperclus_drive
seg000:31F7 ; ---------------------------------------------------------------------------
seg000:31F7
seg000:31F7 not_144m:				    ; CODE XREF: setdeviceparameters+5Bj
seg000:31F7					    ; setdeviceparameters+62j
seg000:31F7		    cmp	    ds:devp_cylinders, 40 ; [deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS]
seg000:31FC		    jnz	    short got_correct_mediad
seg000:31FE		    cmp	    word ptr ds:devparms_20, 8 ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_SECTORSPERTRACK]
seg000:3203		    jnz	    short got_correct_mediad
seg000:3205		    mov	    bl,	0FCh
seg000:3207		    jmp	    short got_correct_mediad
seg000:3209 ; ---------------------------------------------------------------------------
seg000:3209
seg000:3209 only_one_head:			    ; CODE XREF: setdeviceparameters+52j
seg000:3209		    cmp	    ds:devp_devtype, 0 ; [deviceparameters+A_DEVICEPARAMETERS.DP_DEVICETYPE],
seg000:3209					    ; DEV_5INCH	; 0
seg000:320E		    jnz	    short got_one_secperclus_drive
seg000:3210		    mov	    bl,	0FCh	    ; single sided 9 sector media id
seg000:3212		    cmp	    word ptr ds:devparms_20, 8
seg000:3217		    jnz	    short got_one_secperclus_drive
seg000:3219		    mov	    bl,	0FEh	    ; 160K mediaid
seg000:321B
seg000:321B got_one_secperclus_drive:		    ; CODE XREF: setdeviceparameters+64j
seg000:321B					    ; setdeviceparameters+7Dj ...
seg000:321B		    mov	    ds:devparms_9, 1 ; [deviceparameters+9]
seg000:321B					    ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_SECTORSPERCLUSTER]
seg000:3220
seg000:3220 got_correct_mediad:			    ; CODE XREF: setdeviceparameters+50j
seg000:3220					    ; setdeviceparameters+6Bj ...
seg000:3220		    mov	    ds:devparms_17, bl ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_MEDIADESCRIPTOR]
seg000:3224		    mov	    ax,	ds:devp_cylinders ; [deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS]
seg000:3227		    mul	    word ptr ds:devparms_20+2 ;	[deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_HEADS]
seg000:322B		    mul	    word ptr ds:devparms_20 ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_SECTORSPERTRACK]
seg000:322F		    mov	    word ptr ds:devparms_9+6, ax ; [deviceparameters+15]
seg000:322F					    ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_TOTALSECTORS]
seg000:3232		    clc
seg000:3233		    retn
seg000:3233 setdeviceparameters	endp
seg000:3233
seg000:3234
seg000:3234 ; =============== S	U B R O	U T I N	E =======================================
seg000:3234
seg000:3234
seg000:3234 organize	    proc near		    ; CODE XREF: multi_pass:getcomp
seg000:3234		    mov	    cx,	cs:count
seg000:3239		    jcxz    short nochar1
seg000:323B		    call    mapcase
seg000:323E		    xor	    si,	si
seg000:3240		    mov	    di,	si
seg000:3242		    xor	    ax,	ax
seg000:3244		    mov	    cs:com_level, 0
seg000:324A
seg000:324A org1:				    ; CODE XREF: organize+24j
seg000:324A					    ; organize+2Fj ...
seg000:324A		    call    skip_comment
seg000:324D		    jz	    short end_commd_line ; found a comment string and skipped
seg000:324F		    call    get2	    ; not a comment string. then get a char.
seg000:3252		    cmp	    al,	0Ah	    ; lf
seg000:3254		    jz	    short end_commd_line ; starts with a blank line.
seg000:3256		    cmp	    al,	20h ; ' '
seg000:3258		    jbe	    short org1	    ; skip leading control characters
seg000:325A		    jmp	    short findit
seg000:325C ; ---------------------------------------------------------------------------
seg000:325C
seg000:325C end_commd_line:			    ; CODE XREF: organize+19j
seg000:325C					    ; organize+20j ...
seg000:325C		    stosb		    ; store line feed char in buffer for the linecount.
seg000:325D		    mov	    cs:com_level, 0 ; reset the	command	level.
seg000:3263		    jmp	    short org1
seg000:3265 ; ---------------------------------------------------------------------------
seg000:3265
seg000:3265 nochar1:				    ; CODE XREF: organize+5j
seg000:3265		    stc
seg000:3266		    retn
seg000:3267 ; ---------------------------------------------------------------------------
seg000:3267
seg000:3267 findit:				    ; CODE XREF: organize+26j
seg000:3267		    push    cx
seg000:3268		    push    si
seg000:3269		    push    di
seg000:326A		    mov	    bp,	si
seg000:326C		    dec	    bp
seg000:326D		    mov	    si,	offset comtab ;	prepare	to search command table
seg000:3270		    mov	    ch,	0
seg000:3272
seg000:3272 findcom:				    ; CODE XREF: organize+4Cj
seg000:3272					    ; organize+62j
seg000:3272		    mov	    di,	bp
seg000:3274		    mov	    cl,	[si]
seg000:3276		    inc	    si
seg000:3277		    jcxz    short nocom
seg000:3279		    repe cmpsb
seg000:327B		    lahf
seg000:327C		    add	    si,	cx	    ; bump to next position without affecting flags
seg000:327E		    sahf
seg000:327F		    lodsb		    ; get indicator letter
seg000:3280		    jnz	    short findcom
seg000:3282		    cmp	    byte ptr es:[di], 0Dh ; the	next char might	be cr,lf
seg000:3286		    jz	    short gotcom0   ; such as in "rem",cr,lf case.
seg000:3288		    cmp	    byte ptr es:[di], 0Ah
seg000:328C		    jz	    short gotcom0
seg000:328E		    push    ax
seg000:328F		    mov	    al,	es:[di]	    ; now the next char. should	be a delim.
seg000:3292		    call    delim
seg000:3295		    pop	    ax
seg000:3296		    jnz	    short findcom
seg000:3298
seg000:3298 gotcom0:				    ; CODE XREF: organize+52j
seg000:3298					    ; organize+58j
seg000:3298		    pop	    di
seg000:3299		    pop	    si
seg000:329A		    pop	    cx
seg000:329B		    jmp	    short gotcom
seg000:329D ; ---------------------------------------------------------------------------
seg000:329D
seg000:329D nocom:				    ; CODE XREF: organize+43j
seg000:329D		    pop	    di
seg000:329E		    pop	    si
seg000:329F		    pop	    cx
seg000:32A0		    mov	    al,	5Ah ; 'Z'   ; CONFIG_UNKNOWN
seg000:32A2		    stosb		    ; save indicator char.
seg000:32A3
seg000:32A3 _skipline:				    ; CODE XREF: organize+74j
seg000:32A3		    call    get2
seg000:32A6		    cmp	    al,	0Ah	    ; lf ; skip	this bad command line
seg000:32A8		    jnz	    short _skipline
seg000:32AA		    jmp	    short end_commd_line ; handle next command line
seg000:32AC ; ---------------------------------------------------------------------------
seg000:32AC
seg000:32AC gotcom:				    ; CODE XREF: organize+67j
seg000:32AC		    stosb
seg000:32AD		    mov	    cs:cmd_indicator, al
seg000:32B1
seg000:32B1 org2:				    ; CODE XREF: organize+8Bj
seg000:32B1		    call    get2	    ; skip the command name until delimiter
seg000:32B4		    cmp	    al,	0Ah	    ; lf
seg000:32B6		    jz	    short org21
seg000:32B8		    cmp	    al,	0Dh	    ; cr
seg000:32BA		    jz	    short org21
seg000:32BC		    call    delim
seg000:32BF		    jnz	    short org2
seg000:32C1		    jmp	    short org3
seg000:32C3 ; ---------------------------------------------------------------------------
seg000:32C3
seg000:32C3 org21:				    ; CODE XREF: organize+82j
seg000:32C3					    ; organize+86j
seg000:32C3		    dec	    si		    ; if cr or lf then undo si,	cx register
seg000:32C4		    inc	    cx		    ; and continue
seg000:32C5
seg000:32C5 org3:				    ; CODE XREF: organize+8Dj
seg000:32C5		    cmp	    cs:cmd_indicator, 59h ; 'Y' ; CONFIG_COMMENT
seg000:32CB		    jz	    short get_cmt_token
seg000:32CD		    cmp	    cs:cmd_indicator, 49h ; 'I' ; CONFIG_INSTALL
seg000:32D3		    jz	    short org_file
seg000:32D5		    cmp	    cs:cmd_indicator, 44h ; 'D' ; CONFIG_DEVICE
seg000:32DB		    jz	    short org_file
seg000:32DD		    cmp	    cs:cmd_indicator, 53h ; 'S' ; CONFIG_SHELL
seg000:32E3		    jz	    short org_file
seg000:32E5		    cmp	    cs:cmd_indicator, 31h ; '1' ; CONFIG_SWITCHES
seg000:32EB		    jz	    short org_switch
seg000:32ED
seg000:32ED org31:
seg000:32ED		    jmp	    org4
seg000:32F0 ; ---------------------------------------------------------------------------
seg000:32F0
seg000:32F0 org_switch:				    ; CODE XREF: organize+B7j
seg000:32F0					    ; organize+C7j
seg000:32F0		    call    skip_comment
seg000:32F3		    jz	    short end_commd_line_brdg
seg000:32F5		    call    get2
seg000:32F8		    call    org_delim
seg000:32FB		    jz	    short org_switch
seg000:32FD		    stosb
seg000:32FE		    jmp	    org5
seg000:3301 ; ---------------------------------------------------------------------------
seg000:3301
seg000:3301 org_file:				    ; CODE XREF: organize+9Fj
seg000:3301					    ; organize+A7j ...
seg000:3301		    call    skip_comment    ; get the filename and put 0 at end
seg000:3304		    jz	    short org_put_zero
seg000:3306		    call    get2	    ; not a comment
seg000:3309		    call    delim
seg000:330C		    jz	    short org_file  ; skip the possible	delimiters
seg000:330E		    stosb		    ; copy the first non delim char found in buffer
seg000:330F
seg000:330F org_copy_file:			    ; CODE XREF: organize+EFj
seg000:330F		    call    skip_comment    ; comment char in the filename?
seg000:3312		    jz	    short org_put_zero ; then stop copying filename at that point
seg000:3314		    call    get2
seg000:3317		    cmp	    al,	'/'         ; a switch char? (device=filename/xxx)
seg000:3319		    jz	    short end_file_slash ; this	will be	the special case.
seg000:331B		    stosb		    ; save the char. in	buffer
seg000:331C		    call    delim
seg000:331F		    jz	    short end_copy_file
seg000:3321		    cmp	    al,	' '         ; 20h ; SPACE
seg000:3323		    ja	    short org_copy_file	; keep copying
seg000:3325		    jmp	    short end_copy_file	; otherwise, assume end	of the filename.
seg000:3327 ; ---------------------------------------------------------------------------
seg000:3327
seg000:3327 get_cmt_token:			    ; CODE XREF: organize+97j
seg000:3327					    ; organize+F8j ...
seg000:3327		    call    get2	    ; get the token. just max. 2 char.
seg000:332A		    cmp	    al,	20h ; ' '   ; skip white spaces or "=" char.
seg000:332C		    jz	    short get_cmt_token	; (we are allowing the other special
seg000:332C					    ; characters can used for comment id. char.)
seg000:332E		    cmp	    al,	9	    ; TAB
seg000:3330		    jz	    short get_cmt_token
seg000:3332		    cmp	    al,	3Dh ; '='   ;  = is special in this case.
seg000:3334		    jz	    short get_cmt_token
seg000:3336		    cmp	    al,	0Dh	    ; CR
seg000:3338		    jz	    short get_cmt_end ;	cannot accept the carriage return
seg000:333A		    cmp	    al,	0Ah	    ; LF
seg000:333C		    jz	    short get_cmt_end
seg000:333E		    mov	    cs:cmmt1, al    ; store it
seg000:3342		    mov	    cs:cmmt, 1	    ; 1	char. so far.
seg000:3348		    call    get2
seg000:334B		    cmp	    al,	20h ; ' '
seg000:334D		    jz	    short get_cmt_end
seg000:334F		    cmp	    al,	9
seg000:3351		    jz	    short get_cmt_end
seg000:3353		    cmp	    al,	0Dh
seg000:3355		    jz	    short get_cmt_end
seg000:3357		    cmp	    al,	0Ah
seg000:3359		    jz	    short end_commd_line_brdg
seg000:335B		    mov	    cs:cmmt2, al
seg000:335F		    inc	    cs:cmmt
seg000:3364
seg000:3364 get_cmt_end:			    ; CODE XREF: organize+104j
seg000:3364					    ; organize+108j ...
seg000:3364		    call    get2
seg000:3367		    cmp	    al,	0Ah	    ; lf
seg000:3369		    jnz	    short get_cmt_end ;	skip it.
seg000:336B
seg000:336B end_commd_line_brdg:		    ; CODE XREF: organize+BFj
seg000:336B					    ; organize+125j ...
seg000:336B		    jmp	    end_commd_line  ; else jmp to end_commd_line
seg000:336E ; ---------------------------------------------------------------------------
seg000:336E
seg000:336E org_put_zero:			    ; CODE XREF: organize+D0j
seg000:336E					    ; organize+DEj
seg000:336E		    mov	    byte ptr es:[di], 0	; make the filename in front of
seg000:336E					    ; the comment string to be an asciiz.
seg000:3372		    inc	    di
seg000:3373		    jmp	    end_commd_line  ; (maybe null if device=/*)
seg000:3376 ; ---------------------------------------------------------------------------
seg000:3376
seg000:3376 end_file_slash:			    ; CODE XREF: organize+E5j
seg000:3376		    mov	    byte ptr es:[di], 0	; al = "/" option char.
seg000:337A		    inc	    di		    ; make a filename an asciiz
seg000:337A					    ; and store	"/" after that.
seg000:337B		    stosb
seg000:337C		    jmp	    short org5	    ; continue with the	rest of	the line
seg000:337E ; ---------------------------------------------------------------------------
seg000:337E
seg000:337E end_copy_file:			    ; CODE XREF: organize+EBj
seg000:337E					    ; organize+F1j
seg000:337E		    mov	    byte ptr es:[di-1],	0 ; make it an asciiz and handle the next char.
seg000:3383		    cmp	    al,	0Ah	    ; lf
seg000:3385		    jz	    short end_commd_line_brdg
seg000:3387		    jmp	    short org5
seg000:3389 ; ---------------------------------------------------------------------------
seg000:3389
seg000:3389 org4:				    ; CODE XREF: organize:org31j
seg000:3389					    ; organize+160j
seg000:3389		    call    skip_comment
seg000:338C		    jz	    short end_commd_line_brdg
seg000:338E		    call    get2
seg000:3391		    call    org_delim	    ; skip delimiters except '/'
seg000:3394		    jz	    short org4
seg000:3396		    jmp	    short org51
seg000:3398 ; ---------------------------------------------------------------------------
seg000:3398
seg000:3398 org5:				    ; CODE XREF: organize+CAj
seg000:3398					    ; organize+148j ...
seg000:3398		    call    skip_comment    ; rest of the line
seg000:3398					    ; comment?
seg000:339B		    jz	    short end_commd_line_brdg
seg000:339D		    call    get2	    ; not a comment.
seg000:33A0
seg000:33A0 org51:				    ; CODE XREF: organize+162j
seg000:33A0		    stosb		    ; copy the character
seg000:33A1		    cmp	    al,	22h ; '"'   ; a quote ?
seg000:33A3		    jz	    short at_quote
seg000:33A5		    cmp	    al,	20h ; ' '
seg000:33A7		    ja	    short org5
seg000:33A9		    cmp	    cs:cmd_indicator, 55h ; 'U' ; CONFIG_DEVICEHIGH
seg000:33AF		    jnz	    short not_dh
seg000:33B1		    cmp	    al,	0Ah	    ; lf
seg000:33B3		    jz	    short org_dhlf  ; stuff a blank before the lf
seg000:33B5		    cmp	    al,	0Dh	    ; cr
seg000:33B7		    jnz	    short org5
seg000:33B9		    mov	    byte ptr es:[di-1],	20h ; ' ' ; overwrite cr with blank
seg000:33BE		    stosb		    ; put cr after blank
seg000:33BF		    inc	    cs:insert_blank ; indicate that blank has been inserted
seg000:33C4		    jmp	    short org5
seg000:33C6 ; ---------------------------------------------------------------------------
seg000:33C6
seg000:33C6 not_dh:				    ; CODE XREF: organize+17Bj
seg000:33C6		    cmp	    al,	0Ah	    ; line feed	?
seg000:33C8		    jz	    short org1_brdg ; handles the next command line.
seg000:33CA		    jmp	    short org5	    ; handles next char	in this	line.
seg000:33CC ; ---------------------------------------------------------------------------
seg000:33CC
seg000:33CC org_dhlf:				    ; CODE XREF: organize+17Fj
seg000:33CC		    cmp	    cs:insert_blank, 1 ; Q:has a blank already been inserted
seg000:33D2		    jz	    short org1_brdg ; Y:
seg000:33D4		    mov	    byte ptr es:[di-1],	20h ; ' ' ; overwrite lf with blank
seg000:33D9		    stosb		    ; put lf after blank
seg000:33DA
seg000:33DA org1_brdg:				    ; CODE XREF: organize+194j
seg000:33DA					    ; organize+19Ej
seg000:33DA		    mov	    cs:insert_blank, 0 ; clear blank indicator for devicehigh
seg000:33E0		    jmp	    org1
seg000:33E3 ; ---------------------------------------------------------------------------
seg000:33E3
seg000:33E3 at_quote:				    ; CODE XREF: organize+16Fj
seg000:33E3		    cmp	    cs:com_level, 0
seg000:33E9		    jz	    short up_level
seg000:33EB		    mov	    cs:com_level, 0 ; reset it.
seg000:33F1		    jmp	    short org5
seg000:33F3 ; ---------------------------------------------------------------------------
seg000:33F3
seg000:33F3 up_level:				    ; CODE XREF: organize+1B5j
seg000:33F3		    inc	    cs:com_level    ; set it.
seg000:33F8		    jmp	    short org5
seg000:33F8 organize	    endp
seg000:33F8
seg000:33FA
seg000:33FA ; =============== S	U B R O	U T I N	E =======================================
seg000:33FA
seg000:33FA
seg000:33FA get2	    proc near		    ; CODE XREF: organize+1Bp
seg000:33FA					    ; organize:_skiplinep ...
seg000:33FA		    jcxz    short noget
seg000:33FC		    mov	    al,	es:[si]
seg000:33FF		    inc	    si
seg000:3400		    dec	    cx
seg000:3401		    retn
seg000:3402 ; ---------------------------------------------------------------------------
seg000:3402
seg000:3402 noget:				    ; CODE XREF: get2j
seg000:3402					    ; skip_commentj ...
seg000:3402		    pop	    cx
seg000:3403		    mov	    cs:count, di
seg000:3408		    mov	    cs:org_count, di
seg000:340D		    xor	    si,	si
seg000:340F		    mov	    cs:chrptr, si
seg000:3414		    retn
seg000:3414 get2	    endp ; sp-analysis failed
seg000:3414
seg000:3415
seg000:3415 ; =============== S	U B R O	U T I N	E =======================================
seg000:3415
seg000:3415
seg000:3415 skip_comment    proc near		    ; CODE XREF: organize:org1p
seg000:3415					    ; organize:org_switchp ...
seg000:3415		    jcxz    short noget	    ; get out of the organize routine.
seg000:3417		    cmp	    cs:com_level, 0 ; only check it if parameter level is 0.
seg000:3417					    ; (not inside quotations)
seg000:341D		    jnz	    short no_commt
seg000:341F		    cmp	    cs:cmmt, 1
seg000:3425		    jb	    short no_commt
seg000:3427		    mov	    al,	es:[si]
seg000:342A		    cmp	    cs:cmmt1, al
seg000:342F		    jnz	    short no_commt
seg000:3431		    cmp	    cs:cmmt, 2
seg000:3437		    jnz	    short skip_cmmt
seg000:3439		    mov	    al,	es:[si+1]
seg000:343D		    cmp	    cs:cmmt2, al
seg000:3442		    jnz	    short no_commt
seg000:3444
seg000:3444 skip_cmmt:				    ; CODE XREF: skip_comment+22j
seg000:3444					    ; skip_comment+38j
seg000:3444		    jcxz    short noget	    ; get out of organize routine.
seg000:3446		    mov	    al,	es:[si]
seg000:3449		    inc	    si
seg000:344A		    dec	    cx
seg000:344B		    cmp	    al,	0Ah	    ; line feed?
seg000:344D		    jnz	    short skip_cmmt
seg000:344F
seg000:344F no_commt:				    ; CODE XREF: skip_comment+8j
seg000:344F					    ; skip_comment+10j	...
seg000:344F		    retn
seg000:344F skip_comment    endp
seg000:344F
seg000:3450
seg000:3450 ; =============== S	U B R O	U T I N	E =======================================
seg000:3450
seg000:3450
seg000:3450 delim	    proc near		    ; CODE XREF: multi_pass+1E7p
seg000:3450					    ; ParseSize+27p ...
seg000:3450		    cmp	    al,	'/'         ; ibm will assume "/" as an delimeter.
seg000:3452		    jz	    short delim_ret
seg000:3454		    cmp	    al,	0	    ; special case for sysinit!!!
seg000:3456		    jz	    short delim_ret
seg000:3458
seg000:3458 org_delim:				    ; CODE XREF: organize+C4p
seg000:3458					    ; organize+15Dp
seg000:3458		    cmp	    al,	' '         ; used by organize routine except for getting
seg000:3458					    ; the file name
seg000:345A		    jz	    short delim_ret
seg000:345C		    cmp	    al,	9	    ; TAB
seg000:345E		    jz	    short delim_ret
seg000:3460		    cmp	    al,	'='
seg000:3462		    jz	    short delim_ret
seg000:3464		    cmp	    al,	','
seg000:3466		    jz	    short delim_ret
seg000:3468		    cmp	    al,	';'
seg000:346A
seg000:346A delim_ret:				    ; CODE XREF: delim+2j
seg000:346A					    ; delim+6j	...
seg000:346A		    retn
seg000:346A delim	    endp
seg000:346A
seg000:346B
seg000:346B ; =============== S	U B R O	U T I N	E =======================================
seg000:346B
seg000:346B
seg000:346B newline	    proc near		    ; CODE XREF: multi_pass+52p
seg000:346B					    ; newline+7j
seg000:346B		    call    getchr	    ; skip non-control characters
seg000:346E		    jb	    short nl_ret
seg000:3470		    cmp	    al,	0Ah	    ; look for line feed
seg000:3472		    jnz	    short newline
seg000:3474		    call    getchr
seg000:3477
seg000:3477 nl_ret:				    ; CODE XREF: newline+3j
seg000:3477		    retn
seg000:3477 newline	    endp
seg000:3477
seg000:3478
seg000:3478 ; =============== S	U B R O	U T I N	E =======================================
seg000:3478
seg000:3478
seg000:3478 mapcase	    proc near		    ; CODE XREF: organize+7p
seg000:3478		    push    cx
seg000:3479		    push    si
seg000:347A		    push    ds
seg000:347B		    push    es
seg000:347C		    pop	    ds
seg000:347D		    xor	    si,	si
seg000:347F
seg000:347F convloop:				    ; CODE XREF: mapcase:noconvj
seg000:347F		    lodsb
seg000:3480		    cmp	    al,	'a'
seg000:3482		    jb	    short noconv
seg000:3484		    cmp	    al,	'z'
seg000:3486		    ja	    short noconv
seg000:3488		    sub	    al,	20h
seg000:348A		    mov	    [si-1], al
seg000:348D
seg000:348D noconv:				    ; CODE XREF: mapcase+Aj
seg000:348D					    ; mapcase+Ej
seg000:348D		    loop    convloop
seg000:348F		    pop	    ds
seg000:3490		    pop	    si
seg000:3491		    pop	    cx
seg000:3492		    retn
seg000:3492 mapcase	    endp
seg000:3492
seg000:3493
seg000:3493 ; =============== S	U B R O	U T I N	E =======================================
seg000:3493
seg000:3493
seg000:3493 round	    proc near		    ; CODE XREF: endfile+1Ep
seg000:3493					    ; endfile+72p ...
seg000:3493		    push    ax
seg000:3494		    mov	    ax,	cs:memlo
seg000:3498		    call    ParaRound	    ; para round up
seg000:349B		    add	    cs:memhi, ax
seg000:34A0		    mov	    cs:memlo, 0
seg000:34A7		    mov	    ax,	cs:memhi    ; ax = new memhi
seg000:34AB		    cmp	    ax,	cs:ALLOCLIM ; if new memhi >= alloclim,	error
seg000:34B0		    jnb	    short memerr
seg000:34B2		    test    cs:setdevmarkflag, 2 ; for_devmark
seg000:34B8		    jz	    short skip_set_devmarksize
seg000:34BA		    push    es
seg000:34BB		    push    si
seg000:34BC		    mov	    si,	cs:devmark_addr
seg000:34C1		    mov	    es,	si
seg000:34C3		    sub	    ax,	si
seg000:34C5		    dec	    ax
seg000:34C6		    mov	    es:stackcount+1, ax	; [es:3]
seg000:34C6					    ; paragraph
seg000:34CA		    and	    cs:setdevmarkflag, 0FDh ; not_for_devmark
seg000:34D0		    pop	    si
seg000:34D1		    pop	    es
seg000:34D2
seg000:34D2 skip_set_devmarksize:		    ; CODE XREF: round+25j
seg000:34D2		    pop	    ax
seg000:34D3		    clc
seg000:34D4		    retn
seg000:34D4 round	    endp
seg000:34D4
seg000:34D5 ; ---------------------------------------------------------------------------
seg000:34D5 ; START OF FUNCTION	CHUNK FOR multi_pass
seg000:34D5
seg000:34D5 memerr:				    ; CODE XREF: seg000:memerrjxj
seg000:34D5					    ; multi_pass:NoMemj ...
seg000:34D5		    mov	    dx,	offset badmem ;	"\r\nConfiguration too large for memory\"...
seg000:34D8		    push    cs
seg000:34D9		    pop	    ds
seg000:34DA		    call    print
seg000:34DD		    jmp	    stall
seg000:34DD ; END OF FUNCTION CHUNK FOR	multi_pass
seg000:34E0
seg000:34E0 ; =============== S	U B R O	U T I N	E =======================================
seg000:34E0
seg000:34E0
seg000:34E0 calldev	    proc near		    ; CODE XREF: multi_pass+2CAp
seg000:34E0					    ; multi_pass+2D0p
seg000:34E0		    mov	    ds,	word ptr cs:DevEntry+2
seg000:34E5		    add	    bx,	word ptr cs:DevEntry ; do a little relocation
seg000:34EA		    mov	    ax,	[bx]
seg000:34EC		    push    word ptr cs:DevEntry
seg000:34F1		    mov	    word ptr cs:DevEntry, ax
seg000:34F5		    mov	    bx,	offset packet
seg000:34F8		    call    cs:DevEntry	    ; call far [cs:DevEntry]
seg000:34FD		    pop	    word ptr cs:DevEntry
seg000:3502		    retn
seg000:3502 calldev	    endp
seg000:3502
seg000:3503
seg000:3503 ; =============== S	U B R O	U T I N	E =======================================
seg000:3503
seg000:3503
seg000:3503 todigit	    proc near		    ; CODE XREF: getnum:b2p
seg000:3503		    sub	    al,	'0'
seg000:3505		    jb	    short notdig
seg000:3507		    cmp	    al,	9
seg000:3509		    ja	    short notdig
seg000:350B		    clc
seg000:350C		    retn
seg000:350D ; ---------------------------------------------------------------------------
seg000:350D
seg000:350D notdig:				    ; CODE XREF: todigit+2j
seg000:350D					    ; todigit+6j
seg000:350D		    stc
seg000:350E		    retn
seg000:350E todigit	    endp
seg000:350E
seg000:350F
seg000:350F ; =============== S	U B R O	U T I N	E =======================================
seg000:350F
seg000:350F
seg000:350F getnum	    proc near		    ; CODE XREF: check_switch+45p
seg000:350F		    push    bx
seg000:3510		    xor	    bx,	bx	    ; running count is zero
seg000:3512
seg000:3512 b2:					    ; CODE XREF: getnum+40j
seg000:3512		    call    todigit	    ; do we have a digit ?
seg000:3515		    jb	    short badnum    ; no, bomb
seg000:3517		    xchg    ax,	bx	    ; put total	in ax
seg000:3518		    push    bx		    ; save digit (0 to 9)
seg000:3519		    mov	    bx,	10	    ; base of arithmetic
seg000:351C		    mul	    bx		    ; shift by one decimal digit
seg000:351E		    pop	    bx		    ; get back digit (0	to 9)
seg000:351F		    add	    al,	bl	    ; get total
seg000:3521		    adc	    ah,	0	    ; make that	16 bits
seg000:3524		    jb	    short badnum    ; too big a	number
seg000:3526		    xchg    ax,	bx	    ; stash total
seg000:3527		    call    getchr	    ; get next digit
seg000:352A		    jb	    short b1	    ; no more characters
seg000:352C		    cmp	    al,	20h ; ' '   ; space?
seg000:352E		    jz	    short b15	    ; then end of digits
seg000:3530		    cmp	    al,	2Ch ; ','   ; ',' is a seperator!!!
seg000:3532		    jz	    short b15	    ; then end of digits.
seg000:3534		    cmp	    al,	9	    ; TAB
seg000:3536		    jz	    short b15
seg000:3538		    cmp	    al,	cs:sepchr   ; allow 0 or special separators
seg000:353D		    jz	    short b15
seg000:353F		    cmp	    al,	2Fh ; '/'   ; see if another switch follows
seg000:3541		    nop			    ; cas - remnant of old bad code
seg000:3542		    nop
seg000:3543		    jz	    short b15
seg000:3545		    cmp	    al,	0Ah	    ; line-feed?
seg000:3547		    jz	    short b15
seg000:3549		    cmp	    al,	0Dh	    ; carriage return?
seg000:354B		    jz	    short b15
seg000:354D		    or	    al,	al	    ; end of line separator?
seg000:354F		    jnz	    short b2	    ; no, try as a valid char...
seg000:3551
seg000:3551 b15:				    ; CODE XREF: getnum+1Fj
seg000:3551					    ; getnum+23j ...
seg000:3551		    inc	    cs:count	    ; one more character to s...
seg000:3556		    dec	    cs:chrptr	    ; back up over separator
seg000:355B
seg000:355B b1:					    ; CODE XREF: getnum+1Bj
seg000:355B		    mov	    ax,	bx	    ; get proper count
seg000:355D		    or	    ax,	ax	    ; clears carry, sets zero accordingly
seg000:355F		    pop	    bx
seg000:3560		    retn
seg000:3561 ; ---------------------------------------------------------------------------
seg000:3561
seg000:3561 badnum:				    ; CODE XREF: getnum+6j
seg000:3561					    ; getnum+15j
seg000:3561		    mov	    cs:sepchr, 0
seg000:3567		    xor	    ax,	ax	    ; set zero flag, and ax = 0
seg000:3569		    pop	    bx
seg000:356A		    stc			    ; and carry	set
seg000:356B		    retn
seg000:356B getnum	    endp
seg000:356B
seg000:356C
seg000:356C ; =============== S	U B R O	U T I N	E =======================================
seg000:356C
seg000:356C
seg000:356C setdoscountryinfo proc near		    ; CODE XREF: multi_pass+540p
seg000:356C		    push    di
seg000:356D		    push    ax
seg000:356E		    push    dx
seg000:356F		    xor	    cx,	cx
seg000:3571		    xor	    dx,	dx
seg000:3573		    mov	    ax,	512	    ; read 512 bytes
seg000:3576		    call    readincontrolbuffer	; read the file	header
seg000:3579		    jb	    short setdosdata_fail
seg000:357B		    push    es
seg000:357C		    push    si
seg000:357D		    push    cs
seg000:357E		    pop	    es
seg000:357F		    mov	    di,	offset country_file_signature ;	db 0FFh,'COUNTRY'
seg000:3582		    mov	    cx,	8
seg000:3585		    repe cmpsb
seg000:3587		    pop	    si
seg000:3588		    pop	    es
seg000:3589		    jnz	    short setdosdata_fail ; signature mismatch
seg000:358B		    add	    si,	18	    ; si -> county info	type
seg000:358E		    cmp	    byte ptr [si], 1 ; only accept type	1
seg000:358E					    ; (currently only 1	header type)
seg000:3591		    jnz	    short setdosdata_fail ; cannot proceed. error return
seg000:3593		    inc	    si		    ; si -> file offset
seg000:3594		    mov	    dx,	[si]	    ; get the info file	offset.
seg000:3596		    mov	    cx,	[si+2]
seg000:3599		    mov	    ax,	6144	    ; read 6144	bytes.
seg000:359C		    call    readincontrolbuffer	; read info
seg000:359F		    jb	    short setdosdata_fail
seg000:35A1		    mov	    cx,	[si]	    ; get the #	of country,
seg000:35A1					    ; codepage combination entries
seg000:35A3		    cmp	    cx,	438	    ; cannot handle more than 438 entries.
seg000:35A7		    ja	    short setdosdata_fail
seg000:35A9		    inc	    si
seg000:35AA		    inc	    si		    ; si -> entry information packet
seg000:35AB		    pop	    dx		    ; restore code page	id
seg000:35AC		    pop	    ax		    ; restore country id
seg000:35AD		    pop	    di
seg000:35AE
seg000:35AE setdoscntry_find:			    ; CODE XREF: setdoscountryinfo+55j
seg000:35AE		    cmp	    ax,	[si+2]	    ; search for desired country_id,codepage_id.
seg000:35AE					    ; compare country_id
seg000:35B1		    jnz	    short setdoscntry_next
seg000:35B3		    cmp	    dx,	0	    ; no user specified	code page ?
seg000:35B6		    jz	    short setdoscntry_any_codepage ; then no need to match code	page id.
seg000:35B8		    cmp	    dx,	[si+4]	    ; compare code page	id
seg000:35BB		    jz	    short setdoscntry_got_it
seg000:35BD
seg000:35BD setdoscntry_next:			    ; CODE XREF: setdoscountryinfo+45j
seg000:35BD		    add	    si,	[si]	    ; next entry
seg000:35BF		    inc	    si
seg000:35C0		    inc	    si		    ; take a word for size of entry itself
seg000:35C1		    loop    setdoscntry_find
seg000:35C3		    mov	    cx,	0FFFFh	    ; signals that bad country id entered.
seg000:35C6
seg000:35C6 setdoscntry_fail:			    ; CODE XREF: setdoscountryinfo+5Fj
seg000:35C6					    ; setdoscountryinfo+75j
seg000:35C6		    stc
seg000:35C7		    retn
seg000:35C8 ; ---------------------------------------------------------------------------
seg000:35C8
seg000:35C8 setdosdata_fail:			    ; CODE XREF: setdoscountryinfo+Dj
seg000:35C8					    ; setdoscountryinfo+1Dj ...
seg000:35C8		    pop	    si
seg000:35C9		    pop	    cx
seg000:35CA		    pop	    di
seg000:35CB		    jmp	    short setdoscntry_fail
seg000:35CD ; ---------------------------------------------------------------------------
seg000:35CD
seg000:35CD setdoscntry_any_codepage:		    ; CODE XREF: setdoscountryinfo+4Aj
seg000:35CD		    mov	    dx,	[si+4]	    ; use the code_page_id of the country_id found.
seg000:35D0
seg000:35D0 setdoscntry_got_it:			    ; CODE XREF: setdoscountryinfo+4Fj
seg000:35D0		    mov	    cs:cntrycodepage_id, dx ; found the	matching entry
seg000:35D0					    ; save code	page id	for this country.
seg000:35D5		    mov	    dx,	[si+10]	    ; get the file offset of country data
seg000:35D8		    mov	    cx,	[si+12]
seg000:35DB		    mov	    ax,	512	    ; read 512 bytes
seg000:35DE		    call    readincontrolbuffer
seg000:35E1		    jb	    short setdoscntry_fail
seg000:35E3		    mov	    cx,	[si]	    ; get the number of	entries	to handle.
seg000:35E5		    inc	    si
seg000:35E6		    inc	    si		    ; si -> first entry
seg000:35E7
seg000:35E7 setdoscntry_data:			    ; CODE XREF: setdoscountryinfo+110j
seg000:35E7		    push    di		    ; es:di -> dos_country_cdpg_info
seg000:35E8		    push    cx		    ; save # of	entry left
seg000:35E9		    push    si		    ; si -> current entry in control buffer
seg000:35EA		    mov	    al,	[si+2]	    ; get data entry id
seg000:35ED		    call    getcountrydestination ; get	the address of destination in es:di
seg000:35F0		    jb	    short setdoscntry_data_next	; no matching data entry id in dos
seg000:35F2		    mov	    dx,	[si+4]	    ; get offset of data
seg000:35F5		    mov	    cx,	[si+6]
seg000:35F8		    mov	    ax,	4200h
seg000:35FB		    stc
seg000:35FC		    int	    21h		    ; DOS - 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
seg000:35FC					    ; AL = method: offset from beginning of file
seg000:35FE		    jb	    short setdosdata_fail
seg000:3600		    mov	    dx,	512
seg000:3603		    mov	    cx,	20
seg000:3606		    mov	    ah,	3Fh	    ; read the country.sys data
seg000:3608		    stc
seg000:3609		    int	    21h		    ; DOS - 2+ - READ FROM FILE	WITH HANDLE
seg000:3609					    ; BX = file	handle,	CX = number of bytes to	read
seg000:3609					    ; DS:DX -> buffer
seg000:360B		    jb	    short setdosdata_fail ; read failure
seg000:360D		    cmp	    ax,	cx
seg000:360F		    jnz	    short setdosdata_fail
seg000:3611		    mov	    dx,	[si+4]	    ; get offset of data again.
seg000:3614		    mov	    cx,	[si+6]
seg000:3617		    mov	    ax,	4200h	    ; move pointer back	again
seg000:361A		    stc
seg000:361B		    int	    21h		    ; DOS - 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
seg000:361B					    ; AL = method: offset from beginning of file
seg000:361D		    jb	    short setdosdata_fail
seg000:361F		    push    si
seg000:3620		    mov	    si,	520	    ; (512+8)
seg000:3620					    ; get length of the	data from the file
seg000:3623		    mov	    cx,	[si]
seg000:3625		    pop	    si
seg000:3626		    mov	    dx,	512
seg000:3629		    add	    cx,	10
seg000:362C		    mov	    ah,	3Fh
seg000:362E		    stc
seg000:362F		    int	    21h		    ; DOS - 2+ - READ FROM FILE	WITH HANDLE
seg000:362F					    ; BX = file	handle,	CX = number of bytes to	read
seg000:362F					    ; DS:DX -> buffer
seg000:3631		    jb	    short setdosdata_fail
seg000:3633		    cmp	    ax,	cx
seg000:3635		    jnz	    short setdosdata_fail
seg000:3637		    mov	    al,	[si+2]	    ; save data	id for future use.
seg000:363A		    mov	    si,	520	    ; (512+8)
seg000:363A					    ; si-> data	buffer + id tag	field
seg000:363D		    mov	    cx,	[si]	    ; get the length of	the file
seg000:363D					    ; take care	of a word for lenght of	tab itself.
seg000:363F		    inc	    cx
seg000:3640		    inc	    cx
seg000:3641		    cmp	    cx,	1528	    ; fit into the buffer?
seg000:3645		    ja	    short setdosdata_fail
seg000:3647		    call    setdbcs_before_copy
seg000:364A		    cmp	    al,	1	    ; SetCountryInfo ; 1
seg000:364A					    ; is the data for setcountryinfo table?
seg000:364C		    jnz	    short setdoscntry_mov ; no,	don't worry
seg000:364E		    push    word ptr es:[di+24]	; [es:di+country_cdpg_info.ccMono_Ptr-country_cdpg_info.ccCountryInfoLen]
seg000:3652		    push    word ptr es:[di+26]	; [es:di+country_cdpg_info.ccMono_Ptr-country_cdpg_info.ccCountryInfoLen+2]
seg000:3656		    push    di
seg000:3657		    push    ax
seg000:3658		    mov	    ax,	cs:cntrycodepage_id ; do not use the code page info in country_info
seg000:365C		    mov	    [si+4], ax	    ; use the saved one	for this !!!!
seg000:365F		    pop	    ax
seg000:3660
seg000:3660 setdoscntry_mov:			    ; CODE XREF: setdoscountryinfo+E0j
seg000:3660		    rep	movsb		    ; copy the table into dos
seg000:3662		    cmp	    al,	1	    ; SetCountryInfo
seg000:3662					    ; was the ccmono_ptr saved?
seg000:3664		    jnz	    short setdoscntry_data_next
seg000:3666		    pop	    di
seg000:3667		    pop	    word ptr es:[di+26]	; [es:di+country_cdpg_info.ccMono_Ptr-country_cdpg_info.ccCountryInfoLen+2]
seg000:366B		    pop	    word ptr es:[di+24]	; [es:di+country_cdpg_info.ccMono_Ptr-country_cdpg_info.ccCountryInfoLen]
seg000:366F
seg000:366F setdoscntry_data_next:		    ; CODE XREF: setdoscountryinfo+84j
seg000:366F					    ; setdoscountryinfo+F8j
seg000:366F		    pop	    si		    ; restore control buffer pointer
seg000:3670		    pop	    cx		    ; restore #	of entries left
seg000:3671		    pop	    di		    ; restore pointer to dso_country_cdpg
seg000:3672		    add	    si,	[si]	    ; try to get the next entry
seg000:3674		    inc	    si
seg000:3675		    inc	    si		    ; take a word of entry length itself
seg000:3676		    dec	    cx
seg000:3677		    cmp	    cx,	0
seg000:367A		    jz	    short setdoscntry_ok
seg000:367C		    jmp	    setdoscntry_data
seg000:367F ; ---------------------------------------------------------------------------
seg000:367F
seg000:367F setdoscntry_ok:			    ; CODE XREF: setdoscountryinfo+10Ej
seg000:367F		    retn
seg000:367F setdoscountryinfo endp ; sp-analysis failed
seg000:367F
seg000:3680
seg000:3680 ; =============== S	U B R O	U T I N	E =======================================
seg000:3680
seg000:3680
seg000:3680 setdbcs_before_copy	proc near	    ; CODE XREF: setdoscountryinfo+DBp
seg000:3680		    cmp	    al,	7	    ; SetDBCS ;	7
seg000:3680					    ; dbcs vector set?
seg000:3682		    jnz	    short sdbcsbc
seg000:3684		    cmp	    word ptr es:[di], 0	; zero byte data block?
seg000:3688		    jz	    short sdbcsbc
seg000:368A		    push    di
seg000:368B		    push    ax
seg000:368C		    push    cx
seg000:368D		    mov	    cx,	es:[di]	    ; load block length
seg000:3690		    add	    di,	2	    ; points actual data
seg000:3693		    xor	    al,	al	    ; fill bytes
seg000:3695		    rep	stosb		    ; clear data block
seg000:3697		    pop	    cx
seg000:3698		    pop	    ax
seg000:3699		    pop	    di
seg000:369A
seg000:369A sdbcsbc:				    ; CODE XREF: setdbcs_before_copy+2j
seg000:369A					    ; setdbcs_before_copy+8j
seg000:369A		    retn
seg000:369A setdbcs_before_copy	endp
seg000:369A
seg000:369B
seg000:369B ; =============== S	U B R O	U T I N	E =======================================
seg000:369B
seg000:369B
seg000:369B getcountrydestination proc near	    ; CODE XREF: setdoscountryinfo+81p
seg000:369B		    push    cx
seg000:369C		    add	    di,	74	    ; country_cdpg_info.ccNumber_of_entries
seg000:369C					    ; skip the reserved	area, syscodepage etc.
seg000:369F		    mov	    cx,	es:[di]	    ; get the number of	entries
seg000:36A2		    inc	    di
seg000:36A3		    inc	    di		    ; si -> the	first start entry id
seg000:36A4
seg000:36A4 getcntrydest:			    ; CODE XREF: getcountrydestination:getcntrydest_loopj
seg000:36A4		    cmp	    es:[di], al
seg000:36A7		    jz	    short getcntrydest_ok
seg000:36A9		    cmp	    byte ptr es:[di], 1	; was it setcountryinfo	entry?
seg000:36AD		    jz	    short getcntrydest_1
seg000:36AF		    add	    di,	5	    ; next data	id
seg000:36B2		    jmp	    short getcntrydest_loop
seg000:36B4 ; ---------------------------------------------------------------------------
seg000:36B4
seg000:36B4 getcntrydest_1:			    ; CODE XREF: getcountrydestination+12j
seg000:36B4		    add	    di,	41	    ; NEW_COUNTRY_SIZE+3
seg000:36B4					    ; next data	id
seg000:36B7
seg000:36B7 getcntrydest_loop:			    ; CODE XREF: getcountrydestination+17j
seg000:36B7		    loop    getcntrydest
seg000:36B9		    stc
seg000:36BA		    jmp	    short getcntrydest_exit
seg000:36BC ; ---------------------------------------------------------------------------
seg000:36BC
seg000:36BC getcntrydest_ok:			    ; CODE XREF: getcountrydestination+Cj
seg000:36BC		    cmp	    al,	1	    ; select country info?
seg000:36BE		    jnz	    short getcntrydest_ok1
seg000:36C0		    inc	    di		    ; now di ->	cccountryinfolen
seg000:36C1		    jmp	    short getcntrydest_exit
seg000:36C3 ; ---------------------------------------------------------------------------
seg000:36C3
seg000:36C3 getcntrydest_ok1:			    ; CODE XREF: getcountrydestination+23j
seg000:36C3		    les	    di,	es:[di+1]   ; get the destination in es:di
seg000:36C7
seg000:36C7 getcntrydest_exit:			    ; CODE XREF: getcountrydestination+1Fj
seg000:36C7					    ; getcountrydestination+26j
seg000:36C7		    pop	    cx
seg000:36C8		    retn
seg000:36C8 getcountrydestination endp
seg000:36C8
seg000:36C9
seg000:36C9 ; =============== S	U B R O	U T I N	E =======================================
seg000:36C9
seg000:36C9
seg000:36C9 readincontrolbuffer	proc near	    ; CODE XREF: setdoscountryinfo+Ap
seg000:36C9					    ; setdoscountryinfo+30p ...
seg000:36C9		    push    ax		    ; move file	pointer	to cx:dx
seg000:36C9					    ; #	of bytes to read
seg000:36CA		    mov	    ax,	4200h
seg000:36CD		    stc
seg000:36CE		    int	    21h		    ; DOS - 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
seg000:36CE					    ; AL = method: offset from beginning of file
seg000:36D0		    pop	    cx		    ; #	of bytes to read
seg000:36D0					    ; should be	less than 1024 bytes
seg000:36D1		    jb	    short ricb_exit
seg000:36D3		    xor	    dx,	dx	    ; ds:dx -> control buffer
seg000:36D5		    xor	    si,	si
seg000:36D7		    mov	    ah,	3Fh
seg000:36D9		    stc
seg000:36DA		    int	    21h		    ; DOS - 2+ - READ FROM FILE	WITH HANDLE
seg000:36DA					    ; BX = file	handle,	CX = number of bytes to	read
seg000:36DA					    ; DS:DX -> buffer
seg000:36DC
seg000:36DC ricb_exit:				    ; CODE XREF: readincontrolbuffer+8j
seg000:36DC		    retn
seg000:36DC readincontrolbuffer	endp
seg000:36DC
seg000:36DD
seg000:36DD ; =============== S	U B R O	U T I N	E =======================================
seg000:36DD
seg000:36DD
seg000:36DD set_country_path proc near
seg000:36DD		    push    si
seg000:36DE		    push    ds
seg000:36DF		    push    es
seg000:36E0		    pop	    ds
seg000:36E1		    pop	    es
seg000:36E2		    call    chk_drive_letter ; current ds:[si] is a drive letter?
seg000:36E5		    jb	    short scp_default_drv ; no,	use current default drive.
seg000:36E7		    mov	    al,	[si]
seg000:36E9		    inc	    si
seg000:36EA		    inc	    si		    ; si -> next char after ":"
seg000:36EB		    jmp	    short scp_setdrv
seg000:36ED ; ---------------------------------------------------------------------------
seg000:36ED
seg000:36ED scp_default_drv:			    ; CODE XREF: set_country_path+8j
seg000:36ED		    mov	    ah,	19h
seg000:36EF		    int	    21h		    ; DOS - GET	DEFAULT	DISK NUMBER
seg000:36F1		    add	    al,	'A'         ; convert it to a character.
seg000:36F3
seg000:36F3 scp_setdrv:				    ; CODE XREF: set_country_path+Ej
seg000:36F3		    mov	    byte ptr cs:cntry_drv, al ;	set the	drive letter.
seg000:36F7		    mov	    di,	offset cntry_path ; "COUNTRY.SYS"
seg000:36FA		    mov	    al,	[si]
seg000:36FC		    cmp	    al,	'\'
seg000:36FE		    jz	    short scp_root_dir
seg000:3700		    cmp	    al,	'/'         ; let's accept "/" as an directory delim
seg000:3702		    jz	    short scp_root_dir
seg000:3704		    jmp	    short scp_path
seg000:3706 ; ---------------------------------------------------------------------------
seg000:3706
seg000:3706 scp_root_dir:			    ; CODE XREF: set_country_path+21j
seg000:3706					    ; set_country_path+25j
seg000:3706		    dec	    di		    ; di -> cntry_root
seg000:3707
seg000:3707 scp_path:				    ; CODE XREF: set_country_path+27j
seg000:3707		    call    move_asciiz	    ; copy it
seg000:370A		    mov	    di,	offset cntry_drv ; "A:"
seg000:370D		    push    ds
seg000:370E		    push    es
seg000:370F		    pop	    ds
seg000:3710		    pop	    es
seg000:3711		    pop	    si
seg000:3712		    retn
seg000:3712 set_country_path endp
seg000:3712
seg000:3713
seg000:3713 ; =============== S	U B R O	U T I N	E =======================================
seg000:3713
seg000:3713
seg000:3713 chk_drive_letter proc near		    ; CODE XREF: set_country_path+5p
seg000:3713		    push    ax
seg000:3714		    cmp	    byte ptr [si], 'A'
seg000:3717		    jb	    short cdletter_no
seg000:3719		    cmp	    byte ptr [si], 'Z'
seg000:371C		    ja	    short cdletter_no
seg000:371E		    cmp	    byte ptr [si+1], ':'
seg000:3722		    jnz	    short cdletter_no
seg000:3724		    jmp	    short cdletter_exit
seg000:3726 ; ---------------------------------------------------------------------------
seg000:3726
seg000:3726 cdletter_no:			    ; CODE XREF: chk_drive_letter+4j
seg000:3726					    ; chk_drive_letter+9j ...
seg000:3726		    stc
seg000:3727
seg000:3727 cdletter_exit:			    ; CODE XREF: chk_drive_letter+11j
seg000:3727		    pop	    ax
seg000:3728		    retn
seg000:3728 chk_drive_letter endp
seg000:3728
seg000:3729
seg000:3729 ; =============== S	U B R O	U T I N	E =======================================
seg000:3729
seg000:3729
seg000:3729 move_asciiz	    proc near		    ; CODE XREF: multi_pass+4CEp
seg000:3729					    ; multi_pass+533p ...
seg000:3729		    movsb
seg000:372A		    cmp	    byte ptr [si-1], 0 ; was it	0?
seg000:372E		    jnz	    short move_asciiz
seg000:3730		    retn
seg000:3730 move_asciiz	    endp
seg000:3730
seg000:3731
seg000:3731 ; =============== S	U B R O	U T I N	E =======================================
seg000:3731
seg000:3731
seg000:3731 badfil	    proc near		    ; CODE XREF: seg000:0896p
seg000:3731					    ; seg000:0FBEp ...
seg000:3731		    push    cs
seg000:3732		    pop	    es
seg000:3733		    mov	    si,	dx
seg000:3735
seg000:3735 badload:				    ; CODE XREF: seg000:113Cp
seg000:3735					    ; multi_pass:tryd_2p ...
seg000:3735		    mov	    dx,	offset badld_pre ; "\r\nBad or missing $"
seg000:3738		    mov	    bx,	offset crlfm ; "\r\n$"
seg000:373B
seg000:373B prnerr:				    ; CODE XREF: multi_pass+46Bp
seg000:373B		    push    cs
seg000:373C		    pop	    ds
seg000:373D		    call    print
seg000:3740
seg000:3740 prn1:				    ; CODE XREF: badfil+1Bj
seg000:3740		    mov	    dl,	es:[si]
seg000:3743		    or	    dl,	dl
seg000:3745		    jz	    short prn2
seg000:3747		    mov	    ah,	2	    ; STD_CON_OUTPUT
seg000:3749		    int	    21h		    ; DOS - DISPLAY OUTPUT
seg000:3749					    ; DL = character to	send to	standard output
seg000:374B		    inc	    si
seg000:374C		    jmp	    short prn1
seg000:374E ; ---------------------------------------------------------------------------
seg000:374E
seg000:374E prn2:				    ; CODE XREF: badfil+14j
seg000:374E		    mov	    dx,	bx
seg000:3750		    call    print
seg000:3753		    cmp	    cs:donotshownum, 1 ; suppress line number when handling command.com
seg000:3759		    jz	    short prnexit
seg000:375B		    call    error_line
seg000:375E
seg000:375E prnexit:				    ; CODE XREF: badfil+28j
seg000:375E		    retn
seg000:375E badfil	    endp
seg000:375E
seg000:375F
seg000:375F ; =============== S	U B R O	U T I N	E =======================================
seg000:375F
seg000:375F
seg000:375F print	    proc near		    ; CODE XREF: seg000:0733p
seg000:375F					    ; multi_pass+30Ap ...
seg000:375F		    mov	    ah,	9
seg000:3761		    int	    21h		    ; DOS - PRINT STRING
seg000:3761					    ; DS:DX -> string terminated by "$"
seg000:3763		    retn
seg000:3763 print	    endp
seg000:3763
seg000:3764
seg000:3764 ; =============== S	U B R O	U T I N	E =======================================
seg000:3764
seg000:3764
seg000:3764 open_dev	    proc near		    ; CODE XREF: seg000:0FDBp
seg000:3764					    ; seg000:0FE3p
seg000:3764		    call    open_file
seg000:3767		    jnb	    short open_dev3
seg000:3769
seg000:3769 open_dev1:				    ; CODE XREF: open_dev+1Dj
seg000:3769		    mov	    dx,	offset nuldev ;	"NUL"
seg000:376C		    call    open_file
seg000:376F
seg000:376F of_retn:				    ; CODE XREF: open_dev+17j
seg000:376F		    retn
seg000:3770 ; ---------------------------------------------------------------------------
seg000:3770
seg000:3770 open_dev3:				    ; CODE XREF: open_dev+3j
seg000:3770		    mov	    bx,	ax
seg000:3772		    xor	    ax,	ax
seg000:3774		    mov	    ah,	44h	    ; IOCTL
seg000:3776		    int	    21h		    ; DOS - 2+ - IOCTL - GET DEVICE INFORMATION
seg000:3776					    ; BX = file	or device handle
seg000:3778		    test    dl,	10000000b   ; 80h
seg000:377B		    jnz	    short of_retn
seg000:377D		    mov	    ah,	3Eh
seg000:377F		    int	    21h		    ; DOS - 2+ - CLOSE A FILE WITH HANDLE
seg000:377F					    ; BX = file	handle
seg000:3781		    jmp	    short open_dev1
seg000:3781 open_dev	    endp
seg000:3781
seg000:3783
seg000:3783 ; =============== S	U B R O	U T I N	E =======================================
seg000:3783
seg000:3783
seg000:3783 open_file	    proc near		    ; CODE XREF: open_devp
seg000:3783					    ; open_dev+8p
seg000:3783		    mov	    ah,	3Dh
seg000:3785		    stc
seg000:3786		    int	    21h		    ; DOS - 2+ - OPEN DISK FILE	WITH HANDLE
seg000:3786					    ; DS:DX -> ASCIZ filename
seg000:3786					    ; AL = access mode
seg000:3786					    ; 0	- read
seg000:3788		    retn
seg000:3788 open_file	    endp
seg000:3788
seg000:3789 ; ---------------------------------------------------------------------------
seg000:3789
seg000:3789 int24:				    ; DATA XREF: seg000:0721o
seg000:3789		    mov	    al,	3
seg000:378B		    iret
seg000:378B ; ---------------------------------------------------------------------------
seg000:378C MsDosVersion5Copyr db 'MS DOS Version 5.00 (C)Copyright 1981-1991 Microsoft Corp License'
seg000:378C		    db 'd Material - Property of Microsoft All rights reserved '
seg000:3804 nuldev	    db 'NUL',0              ; DATA XREF: open_dev:open_dev1o
seg000:3808 condev	    db 'CON',0              ; DATA XREF: seg000:0FB2o
seg000:380C auxdev	    db 'AUX',0              ; DATA XREF: seg000:goaux2o
seg000:3810 prndev	    db 'PRN',0              ; DATA XREF: seg000:0FDEo
seg000:3814 config	    db '\CONFIG.SYS',0      ; DATA XREF: doconf+Bo
seg000:3814					    ; doconf:conferro
seg000:3820 cntry_drv	    db 'A:'                 ; DATA XREF: multi_pass:tryq_contw
seg000:3820					    ; multi_pass+4CBo ...
seg000:3822 cntry_root	    db '\'                  ; DATA XREF: multi_pass:tryq_defo
seg000:3822					    ; multi_pass:tryqdefbado
seg000:3823 cntry_path	    db 'COUNTRY.SYS',0      ; DATA XREF: set_country_path+1Ao
seg000:382F		    db 52 dup(0)
seg000:3863 country_file_signature db 0FFh	    ; DATA XREF: setdoscountryinfo+13o
seg000:3864		    db 'COUNTRY'
seg000:386B cntrycodepage_id dw	0		    ; DATA XREF: setdoscountryinfo:setdoscntry_got_itw
seg000:386B					    ; setdoscountryinfo+ECr
seg000:386D commnd	    db '\COMMAND.COM',0     ; DATA XREF: seg000:retryo
seg000:386D					    ; multi_pass+6CBo
seg000:387A		    db 51 dup(0)
seg000:38AD pathstring	    db 64 dup(0)
seg000:38ED comtab	    db 7		    ; DATA XREF: organize+39o
seg000:38EE aBuffers	    db 'BUFFERS'
seg000:38F5		    db 'B'
seg000:38F6		    db 5
seg000:38F7 aBreak	    db 'BREAK'
seg000:38FC		    db 'C'
seg000:38FD		    db 6
seg000:38FE aDevice	    db 'DEVICE'
seg000:3904		    db 'D'
seg000:3905		    db 10
seg000:3906 aDevicehigh	    db 'DEVICEHIGH'
seg000:3910		    db 'U'
seg000:3911		    db 5
seg000:3912 aFiles	    db 'FILES'
seg000:3917		    db 'F'
seg000:3918		    db 4
seg000:3919 aFcbs	    db 'FCBS'
seg000:391D		    db 'X'
seg000:391E		    db 9
seg000:391F aLastdrive	    db 'LASTDRIVE'
seg000:3928		    db 'L'
seg000:3929		    db 10
seg000:392A aMultitrack	    db 'MULTITRACK'
seg000:3934		    db 'M'
seg000:3935		    db 8
seg000:3936 aDrivparm	    db 'DRIVPARM'
seg000:393E		    db 'P'
seg000:393F		    db 6
seg000:3940 aStacks	    db 'STACKS'
seg000:3946		    db 'K'
seg000:3947		    db 7
seg000:3948 aCountry	    db 'COUNTRY'
seg000:394F		    db 'Q'
seg000:3950		    db 5
seg000:3951 aShell	    db 'SHELL'
seg000:3956		    db 'S'
seg000:3957		    db 7
seg000:3958 aInstall	    db 'INSTALL'
seg000:395F		    db 'I'
seg000:3960		    db 7
seg000:3961 aComment	    db 'COMMENT'
seg000:3968		    db 'Y'
seg000:3969		    db 3
seg000:396A aRem	    db 'REM'
seg000:396D		    db '0'
seg000:396E		    db 8
seg000:396F aSwitches	    db 'SWITCHES'
seg000:3977		    db '1'
seg000:3978		    db 3
seg000:3979 aDos	    db 'DOS'
seg000:397C		    db 'H'
seg000:397D		    db 0
seg000:397E devp_specialfunc db	0		    ; DATA XREF: endfile+12Co
seg000:397E					    ; setparms+Fo
seg000:397F devp_devtype    db 2		    ; DATA XREF: diddleback+9w
seg000:397F					    ; process_num+17w ...
seg000:3980 devp_devattr    dw 0		    ; DATA XREF: diddleback+Ew
seg000:3980					    ; parseline+39w
seg000:3982 devp_cylinders  dw 80		    ; DATA XREF: diddleback+3w
seg000:3982					    ; process_num+26w ...
seg000:3984 devparms_6	    db 0
seg000:3985 devparms_7	    dw 0		    ; DATA XREF: endfile+13Dr
seg000:3985					    ; setdeviceparameters+1Ao
seg000:3987 devparms_9	    db 8 dup(0)		    ; DATA XREF: setdeviceparameters:heads_not_alteredw
seg000:3987					    ; setdeviceparameters:got_one_secperclus_drivew ...
seg000:398F devparms_17	    db 3 dup(0)		    ; DATA XREF: setdeviceparameters+47r
seg000:398F					    ; setdeviceparameters:got_correct_mediadw
seg000:3992 devparms_20	    db 272 dup(0)	    ; DATA XREF: setdeviceparameters+2Fw
seg000:3992					    ; setdeviceparameters+56r ...
seg000:3AA2 hlim	    dw 2		    ; DATA XREF: process_num:try_hw
seg000:3AA2					    ; setdeviceparameters+3Ar
seg000:3AA4 slim	    dw 9		    ; DATA XREF: process_num+31w
seg000:3AA4					    ; setdeviceparameters+2Cr
seg000:3AA6 drive	    db 0		    ; DATA XREF: setparms+9r
seg000:3AA6					    ; setparms+24r ...
seg000:3AA7 switches	    dw 0		    ; DATA XREF: setparms+1Cr
seg000:3AA7					    ; diddleback+14w ...
seg000:3AA9 bpb48t	    dw 512		    ; DATA XREF: seg000:bpbtableo
seg000:3AAB		    db 2
seg000:3AAC		    dw 1
seg000:3AAE		    db 2
seg000:3AAF		    dw 112
seg000:3AB1		    dw 720
seg000:3AB3		    db 0FDh
seg000:3AB4		    dw 2
seg000:3AB6		    dw 9
seg000:3AB8		    dw 2
seg000:3ABA		    dd 0
seg000:3ABE		    dd 0
seg000:3AC2 bpb96t	    dw 512		    ; DATA XREF: seg000:3B28o
seg000:3AC4		    db 1
seg000:3AC5		    dw 1
seg000:3AC7		    db 2
seg000:3AC8		    dw 224
seg000:3ACA		    dw 2400
seg000:3ACC		    db 0F9h
seg000:3ACD		    dw 7
seg000:3ACF		    dw 15
seg000:3AD1		    dw 2
seg000:3AD3		    dd 0
seg000:3AD7		    dd 0
seg000:3ADB bpb35	    dw 512		    ; DATA XREF: seg000:3B2Ao
seg000:3ADB					    ; seg000:3B2Co ...
seg000:3ADD		    db 2
seg000:3ADE		    dw 1
seg000:3AE0		    db 2
seg000:3AE1		    dw 112
seg000:3AE3		    dw 1440
seg000:3AE5		    db 0F9h
seg000:3AE6		    dw 3
seg000:3AE8		    dw 9
seg000:3AEA		    dw 2
seg000:3AEC		    dd 0
seg000:3AF0		    dd 0
seg000:3AF4 bpb35h	    dw 512		    ; DATA XREF: seg000:3B34o
seg000:3AF6		    db 1
seg000:3AF7		    dw 1
seg000:3AF9		    db 2
seg000:3AFA		    dw 224
seg000:3AFC		    dw 2880
seg000:3AFE		    db 0F0h
seg000:3AFF		    dw 9
seg000:3B01		    dw 18
seg000:3B03		    dw 2
seg000:3B05		    dd 0
seg000:3B09		    dd 0
seg000:3B0D bpb288	    dw 200h		    ; DATA XREF: seg000:3B38o
seg000:3B0F		    db 2
seg000:3B10		    dw 1
seg000:3B12		    db 2
seg000:3B13		    dw 240
seg000:3B15		    dw 5760
seg000:3B17		    db 0F0h
seg000:3B18		    dw 9
seg000:3B1A		    dw 36
seg000:3B1C		    dw 2
seg000:3B1E		    dd 0
seg000:3B22		    dd 0
seg000:3B26 bpbtable	    dw offset bpb48t	    ; DATA XREF: setdeviceparameters+16r
seg000:3B28		    dw offset bpb96t
seg000:3B2A		    dw offset bpb35
seg000:3B2C		    dw offset bpb35
seg000:3B2E		    dw offset bpb35
seg000:3B30		    dw offset bpb35
seg000:3B32		    dw offset bpb35
seg000:3B34		    dw offset bpb35h
seg000:3B36		    dw offset bpb35
seg000:3B38		    dw offset bpb288
seg000:3B3A switchlist	    db 8,'FHSTDICN',0       ; DATA XREF: check_switch+12r
seg000:3B3A					    ; check_switch+18o
seg000:3B44 badopm	    db 0Dh,0Ah		    ; DATA XREF: seg000:2A12o
seg000:3B44					    ; multi_pass:badopo
seg000:3B44		    db 'Unrecognized command in CONFIG.SYS'
seg000:3B68 crlfm	    db 0Dh,0Ah,'$'          ; DATA XREF: multi_pass+468o
seg000:3B68					    ; badparm_p+1Fo ...
seg000:3B6B badparm	    db 0Dh,0Ah		    ; DATA XREF: badparm_p+5o
seg000:3B6B		    db 'Bad command or parameters - $'
seg000:3B8A badsiz_pre	    db 0Dh,0Ah		    ; DATA XREF: multi_pass+465o
seg000:3B8A		    db 'Sector size too large in file $'
seg000:3BAB badld_pre	    db 0Dh,0Ah		    ; DATA XREF: badfil:badloado
seg000:3BAB		    db 'Bad or missing $'
seg000:3BBD badcom	    db 'Command Interpreter',0 ; DATA XREF: seg000:comerro
seg000:3BD1 badcountry	    db 0Dh,0Ah		    ; DATA XREF: multi_pass+4E3o
seg000:3BD1					    ; cntry_error+5o
seg000:3BD1		    db 'Invalid country code or code page',0Dh,0Ah,'$'
seg000:3BF7 badcountrycom   db 0Dh,0Ah		    ; DATA XREF: cntry_error:if64o
seg000:3BF7		    db 'Error in COUNTRY command',0Dh,0Ah,'$'
seg000:3C14 insufmemory	    db 0Dh,0Ah		    ; DATA XREF: multi_pass:tryqmemoryo
seg000:3C14		    db 'Insufficient memory for COUNTRY.SYS file',0Dh,0Ah,'$'
seg000:3C41 badmem	    db 0Dh,0Ah		    ; DATA XREF: multi_pass:memerro
seg000:3C41		    db 'Configuration too large for memory',0Dh,0Ah,'$'
seg000:3C68 badblock	    db 0Dh,0Ah		    ; DATA XREF: multi_pass+307o
seg000:3C68		    db 'Too many block devices',0Dh,0Ah,'$'
seg000:3C83 badstack	    db 0Dh,0Ah		    ; DATA XREF: multi_pass+628o
seg000:3C83					    ; multi_pass+69Bo
seg000:3C83		    db 'Invalid STACK parameters',0Dh,0Ah,'$'
seg000:3CA0 badorder	    db 0Dh,0Ah		    ; DATA XREF: seg000:incorrect_ordero
seg000:3CA0		    db 'Incorrect order in CONFIG.SYS line $'
seg000:3CC6 errorcmd	    db 'Error in CONFIG.SYS line $' ; DATA XREF: error_line+2o
seg000:3CE0 TooManyDrivesMsg db	'WARNING! Logical drives past Z: exist and will be ignored',0Dh,0Ah,'$'
seg000:3CE0					    ; DATA XREF: seg000:0730o
seg000:3D1C		    db 4 dup(0)
seg000:3D1C seg000	    ends
seg000:3D1C
seg000:3D1C
seg000:3D1C		    end
