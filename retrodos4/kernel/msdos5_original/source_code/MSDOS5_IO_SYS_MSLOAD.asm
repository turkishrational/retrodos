

;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2013 Hex-Rays, <support@hex-rays.com>	    |
; |			 Licensed to: Freeware version			    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	B2FA03653E5C5D545327EE28B8A24356
; Input	CRC32 :	20FC79BF

; ---------------------------------------------------------------------------
; File Name   :	C:\Users\Erdoðan\Desktop\IO.SYS
; Format      :	Binary file
; Base Address:	0000h Range: 0000h - 8296h Loaded length: 00008296h

		.386
		.model flat

; ===========================================================================

; Segment type:	Pure code
MSLOAD		segment	byte public 'CODE' use16
		assume cs:MSLOAD
		assume es:MSLOAD, ss:MSLOAD, ds:MSLOAD,	fs:MSLOAD, gs:MSLOAD

START$:
		jmp	SaveInputValuess
; ---------------------------------------------------------------------------
SysVersion	dw 5
MyStacks	db 115 dup(0)		; msload.asm
DskAddr		db 141 dup(0)		; DATA XREF: MSLOAD:0159r MSLOAD:016Cw ...
NumHeads	dw 0			; DATA XREF: MSLOAD:0196w MSLOAD:023Co ...
ClusterSize	db 2 dup(0)		; DATA XREF: MSLOAD:024Ew MSLOAD:02F8r ...
StartSecL	dw 0			; DATA XREF: MSLOAD:02BFw MSLOAD:02D3w ...
StartSecH	dw 0			; DATA XREF: MSLOAD:02C9w MSLOAD:02D8w ...
TempH		dw 0			; DATA XREF: MSLOAD:028Fw
					; ReadSectors+17w ...
TempCluster	db 2 dup(0)		; DATA XREF: GetNextFatEntry+2Bw
					; GetNextFatEntry+3Fr ...
LastFatSector	db 2 dup(0FFh)		; DATA XREF: GetFatSector+Cr
					; GetFatSector+13w
SectorCount	dw 0			; DATA XREF: MSLOAD:030Aw MSLOAD:033Fw ...
SecPerFat	dw 0			; DATA XREF: MSLOAD:019Fw MSLOAD:0269r
HiddenSectorsL	dw 0			; DATA XREF: MSLOAD:01B1w
					; GetFatSector+1Ar
HiddenSectorsH	dw 0			; DATA XREF: MSLOAD:01CDw
					; GetFatSector+1Fr
BytesPerSec	dw 0			; DATA XREF: MSLOAD:017Bw MSLOAD:0213r ...
ReservSectors	db 2 dup(0)		; DATA XREF: MSLOAD:01A8w MSLOAD:0261r ...
CurrentCluster	db 2 dup(0)		; DATA XREF: MSLOAD:02A6w MSLOAD:0314w ...
NextBioLocation	db 2 dup(0)		; DATA XREF: MSLOAD:0333w MSLOAD:037Dr ...
FirstSectorL	dw 0			; DATA XREF: MSLOAD:SaveInputValuessw
					; MSLOAD:02BAr	...
FirstSectorH	dw 0			; DATA XREF: MSLOAD:01C6w MSLOAD:02C4r ...
TotalSectorsL	dw 0			; DATA XREF: MSLOAD:01BAw MSLOAD:01D9w ...
TotalSectorsH	dw 0			; DATA XREF: MSLOAD:01E0w MSLOAD:0258r
SecPerTrack	db 2 dup(0)		; DATA XREF: MSLOAD:018Dw
					; ReadSectors+12r ...
BootDrive	db 0			; DATA XREF: MSLOAD:0142w MSLOAD:03A1r ...
Fatsize		db 0			; DATA XREF: MSLOAD:0252w MSLOAD:029Bw ...
MediaByte	db 0			; DATA XREF: MSLOAD:013Dw
					; MSLOAD:GoToBioInitr
EndOfFile	db 0			; DATA XREF: MSLOAD:0354r
					; GetNextFatEntry+7w ...
OrgDasdPtr	db 4 dup(0)		; DATA XREF: MSLOAD:0147w
					; ReadSectors+18Er ...
FatSegment	db 2 dup(0)		; DATA XREF: MSLOAD:021Dw
					; GetNextFatEntry+1r
SecPerCluster	db 0			; DATA XREF: MSLOAD:0184w MSLOAD:02ADr ...
; ---------------------------------------------------------------------------

SaveInputValuess:			; CODE XREF: MSLOAD:START$j
		mov	cs:FirstSectorL, bx
		mov	cs:MediaByte, ch
		mov	cs:BootDrive, dl
		mov	word ptr cs:OrgDasdPtr,	si
		push	ds
		pop	word ptr cs:OrgDasdPtr+2
		xor	cx, cx
		mov	ds, cx		; ZERO
		assume es:nothing, ss:nothing, fs:nothing, gs:nothing
		push	es
		mov	es, cx
		assume es:MSLOAD, ss:MSLOAD, fs:MSLOAD,	gs:MSLOAD
		mov	si, word ptr DskAddr ; 0000h:0078h (Int	1Eh)
		mov	ds, word ptr DskAddr+2
		assume ds:nothing
		mov	di, 522h	; Sec9
		mov	cx, 11
		cld
		rep movsb
		push	es
		pop	ds
		assume ds:MSLOAD
		mov	word ptr DskAddr, 522h ; Sec9
		mov	word ptr DskAddr+2, ds
		pop	es
		assume es:nothing
		mov	cx, ds:7C0Bh
		mov	cs:BytesPerSec,	cx
		mov	cl, ds:7C0Dh
		mov	cs:SecPerCluster, cl
		mov	cx, ds:7C18h
		mov	word ptr cs:SecPerTrack, cx
		mov	cx, ds:7C1Ah
		mov	cs:NumHeads, cx
		mov	cx, ds:7C16h
		mov	cs:SecPerFat, cx
		mov	cx, ds:7C0Eh
		mov	word ptr cs:ReservSectors, cx
		mov	cx, ds:7C1Ch
		mov	cs:HiddenSectorsL, cx
		mov	cx, ds:7C13h
		mov	cs:TotalSectorsL, cx
		cmp	byte ptr ds:7C26h, 29h ; ext_boot_signature
		jnz	short relocate
		mov	cs:FirstSectorH, ax ; ax = first data sector (high) on disk
		mov	ax, ds:7C1Eh
		mov	cs:HiddenSectorsH, ax
		cmp	cx, 0
		jnz	short relocate
		mov	ax, ds:7C20h
		mov	cs:TotalSectorsL, ax
		mov	ax, ds:7C22h
		mov	cs:TotalSectorsH, ax

relocate:				; CODE XREF: MSLOAD:01C4j MSLOAD:01D4j
		cld
		xor	si, si
		mov	di, si
		int	12h		; MEMORY SIZE -
					; Return: AX = number of contiguous 1K blocks of memory
		mov	cl, 6
		shl	ax, cl
		xor	bx, bx
		mov	ds, bx		; ZERO
		mov	bx, word ptr DskAddr+44h ; 2Fh*4 (Int 2Fh)
		mov	ds, word ptr DskAddr+46h ; 2Fh*4+2
		cmp	word ptr [bx+3], 'PR'
		jnz	short SkipRPL
		cmp	byte ptr [bx+5], 'L'
		jnz	short SkipRPL
		mov	dx, ax
		mov	ax, 4A06h	; (multMULT shl	8) + multMULTRPLTOM
		int	2Fh
		mov	ax, dx

SkipRPL:				; CODE XREF: MSLOAD:0200j MSLOAD:0206j
		mov	cl, 4
		mov	dx, cs:BytesPerSec
		shr	dx, cl
		inc	dx
		sub	ax, dx
		mov	word ptr cs:FatSegment,	ax
		mov	dx, offset EndOfLoader ; EndOfLoader
		shr	dx, cl
		inc	dx
		sub	ax, dx
		mov	es, ax
		push	cs
		pop	ds
		mov	cx, offset EndOfLoader ; EndOfLoader
		rep movsb
		push	es
		mov	ax, offset SetupStack
		push	ax
		retf
; ---------------------------------------------------------------------------

SetupStack:				; DATA XREF: MSLOAD:0233o
		mov	ax, cs		; Start	of relocated code
		mov	ss, ax
		mov	sp, offset NumHeads ; StackPtr offset
		xor	ax, ax
		mov	ds, ax
		mov	ax, ds:7C0Bh	; get bpb bytes/sector
		xor	bx, bx
		mov	bl, ds:7C0Dh	; ;get sectors/cluster
		mul	bx
		mov	word ptr cs:ClusterSize, ax
		mov	cs:Fatsize, 1	; FAT_12_BIT (assume)
		mov	dx, cs:TotalSectorsH
		mov	ax, cs:TotalSectorsL ; DX:AX = total disk sectors
		sub	ax, word ptr cs:ReservSectors
		sbb	dx, 0		; DX:AX	= Total	avail sectors
		mov	bx, cs:SecPerFat
		shl	bx, 1		; (Assume 2 FATs)
		sub	ax, bx
		sbb	dx, 0
		mov	bx, ds:7C11h	; Root directory entry count
		mov	cl, 4
		shr	bx, cl		; BX = Total directory sectors
		sub	ax, bx
		sbb	dx, 0		; DX:AX	= Sectors in data area
		xor	cx, cx
		mov	cl, ds:7C0Dh	; Sectors per cluster
		push	ax
		mov	ax, dx
		xor	dx, dx
		div	cx
		mov	cs:TempH, ax	; AX = Total number of clusters
		pop	ax
		div	cx
		cmp	ax, 4086	; 4096-10
		jb	short ReadInFirstClusters ; 12 bit FAT
		mov	cs:Fatsize, 4	; FAT_16_BIT

ReadInFirstClusters:			; CODE XREF: MSLOAD:0299j
		mov	ax, word ptr loc_517+3 ; IO.SYS	First Cluster
		dec	ax		; Root dir buffer at 500h (segment=0)
					; IO.SYS first cluster ptr at 51Ah
		dec	ax		; AX = word [51Ah] - 2
		mov	word ptr cs:CurrentCluster, ax
		mov	ax, 3		; Load the 3rd and other IO.SYS	sectors
		div	cs:SecPerCluster
		cmp	ah, 0
		jz	short SetNextClusterNum	; next cluster
		xor	ah, ah
		push	ax
		mov	cx, cs:FirstSectorL
		mov	cs:StartSecL, cx
		mov	cx, cs:FirstSectorH
		mov	cs:StartSecH, cx
		mul	cs:SecPerCluster
		add	cs:StartSecL, ax
		adc	cs:StartSecH, 0
		mov	ax, word ptr loc_517+3 ; AX = [51Ah] = IO.SYS 1st clust
		dec	ax
		dec	ax
		xor	bx, bx
		mov	bl, cs:SecPerCluster
		mul	bx
		add	cs:StartSecL, ax
		adc	cs:StartSecH, dx
		pop	ax
		push	ax
		mul	word ptr cs:ClusterSize
		mov	di, 700h	; IO.SYS offset	(segment = 0)
		add	di, ax
		xor	ax, ax
		mov	es, ax
		assume es:MSLOAD
		mov	al, cs:SecPerCluster ; Read in the entire last cluster
		mov	cs:SectorCount,	ax
		call	ReadSectors
		pop	ax		; AX = total clust read	by boot	loader
		inc	ax		; AX = total clust read	in now

SetNextClusterNum:			; CODE XREF: MSLOAD:02B5j
		inc	ax		; AX = total clusters read in based 2
		add	word ptr cs:CurrentCluster, ax
		dec	ax		; CurrentCluster = Last	cluster	read
					; AX = number of clusters loaded

SaveLoadedBios:
		push	ds
		mul	word ptr cs:ClusterSize
		sub	ax, offset EndOfLoader ; (OFFSET EndOfLoader)-(OFFSET Start)
		mov	cx, ax
		mov	ax, 70h		; Segment at 70h
		mov	ds, ax
		assume ds:nothing
		mov	es, ax
		assume es:nothing
		mov	si, offset EndOfLoader ; EndOfLoader
		xor	di, di
		rep movsb
		mov	word ptr cs:NextBioLocation, di
		pop	ds		; Save where location for next read
		assume ds:nothing

GetContigClusters:			; CODE XREF: MSLOAD:039Aj
		xor	ah, ah
		mov	al, cs:SecPerCluster
		mov	cs:SectorCount,	ax
		push	cs:SectorCount
		call	GetNextFatEntry
		pop	cs:SectorCount
		mov	word ptr cs:CurrentCluster, ax
		cmp	cs:EndOfFile, 0FFh ; END_OF_FILE
		jz	short GoToBioInit
		xor	dx, dx
		sub	ax, 2
		xor	ch, ch
		mov	cl, cs:SecPerCluster
		mul	cx
		add	ax, cs:FirstSectorL
		adc	dx, cs:FirstSectorH
		mov	cs:StartSecL, ax
		mov	cs:StartSecH, dx
		mov	di, word ptr cs:NextBioLocation
		push	cs:SectorCount
		mov	ax, 70h
		mov	es, ax
		call	ReadSectors
		pop	ax
		mul	cs:BytesPerSec
		add	word ptr cs:NextBioLocation, ax
		jmp	short GetContigClusters
; ---------------------------------------------------------------------------

GoToBioInit:				; CODE XREF: MSLOAD:035Aj
		mov	ch, cs:MediaByte
		mov	dl, cs:BootDrive
		mov	bx, cs:FirstSectorL
		mov	ax, cs:FirstSectorH
		jmp	far ptr	70h:0	; Far jump to IoSysAddr	(DOSBIOS)

; =============== S U B	R O U T	I N E =======================================


ReadSectors	proc near		; CODE XREF: MSLOAD:030Ep MSLOAD:038Cp ...

; FUNCTION CHUNK AT 0532 SIZE 0000001E BYTES

		mov	cx, 5

TryRead:				; CODE XREF: ReadSectors+85j
		push	cx
		mov	ax, cs:StartSecL
		mov	dx, cs:StartSecH
		push	ax
		mov	ax, dx
		xor	dx, dx
		div	word ptr cs:SecPerTrack
		mov	cs:TempH, ax
		pop	ax
		div	word ptr cs:SecPerTrack
		mov	bx, word ptr cs:SecPerTrack
		sub	bx, dx
		mov	si, bx
		cmp	cs:SectorCount,	si
		jnb	short GotLength
		mov	si, cs:SectorCount

GotLength:				; CODE XREF: ReadSectors+2Fj
		inc	dl
		mov	bl, dl
		mov	dx, cs:TempH
		push	ax
		mov	ax, dx
		xor	dx, dx
		div	cs:NumHeads
		mov	cs:TempH, ax
		pop	ax
		div	cs:NumHeads
		mov	dh, dl
		mov	cl, 6
		shl	ah, cl
		or	ah, bl
		mov	ch, al
		mov	cl, ah
		mov	bx, di
		mov	dl, cs:BootDrive
		mov	ax, si
		mov	ah, 2
		push	ax
		push	di
		int	13h		; DISK - READ SECTORS INTO MEMORY
					; AL = number of sectors to read, CH = track, CL = sector
					; DH = head, DL	= drive, ES:BX -> buffer to fill
					; Return: CF set on error, AH =	status,	AL = number of sectors read
		pop	di
		pop	ax
		pop	cx
		jnb	short ReadOk
		mov	bx, di
		xor	ah, ah
		push	cx
		mov	dl, cs:BootDrive
		push	di
		int	13h		; DISK - RESET DISK SYSTEM
					; DL = drive (if bit 7 is set both hard	disks and floppy disks reset)
		pop	di
		pop	cx
		dec	cx
		jz	short ReadError
		jmp	TryRead
; ---------------------------------------------------------------------------

ReadError:				; CODE XREF: ReadSectors+83j
		jmp	ErrorOut
; ---------------------------------------------------------------------------

ReadOk:					; CODE XREF: ReadSectors+71j
		xor	ah, ah
		sub	cs:SectorCount,	ax
		jz	short EndRead
		add	cs:StartSecL, ax
		adc	cs:StartSecH, 0
		xor	bx, bx
		mov	bl, al
		mov	ax, cs:BytesPerSec
		mul	bx
ReadSectors	endp

		add	di, ax
		jmp	ReadSectors
; ---------------------------------------------------------------------------

EndRead:				; CODE XREF: ReadSectors+92j
		retn

; =============== S U B	R O U T	I N E =======================================


GetNextFatEntry	proc near		; CODE XREF: MSLOAD:0348p
		push	es
		mov	ax, word ptr cs:FatSegment
		mov	es, ax
		assume es:nothing
		mov	cs:EndOfFile, 0FFh
		mov	ax, word ptr cs:CurrentCluster
		cmp	cs:Fatsize, 1
		jnz	short Got16Bit
		mov	si, ax
		shr	ax, 1
		add	si, ax
		push	dx
		xor	dx, dx
		call	GetFatSector
		pop	dx
		jnz	short ClusterOk
		mov	al, es:[bx]
		mov	cs:TempCluster,	al
		inc	si
		push	dx
		xor	dx, dx
		call	GetFatSector
		pop	dx
		mov	al, es:0
		mov	cs:TempCluster+1, al
		mov	ax, word ptr cs:TempCluster
		jmp	short EvenOdd
; ---------------------------------------------------------------------------

ClusterOk:				; CODE XREF: GetNextFatEntry+26j
		mov	ax, es:[bx]

EvenOdd:				; CODE XREF: GetNextFatEntry+43j
		test	word ptr cs:CurrentCluster, 1
		jnz	short OddResult
		and	ax, 0FFFh
		jmp	short TestEOF
; ---------------------------------------------------------------------------

OddResult:				; CODE XREF: GetNextFatEntry+4Fj
		mov	cl, 4
		shr	ax, cl

TestEOF:				; CODE XREF: GetNextFatEntry+54j
		cmp	ax, 0FF8h
		jnb	short GotClusterDone
		jmp	short NotLastCluster
; ---------------------------------------------------------------------------

Got16Bit:				; CODE XREF: GetNextFatEntry+17j
		push	dx
		xor	dx, dx
		shl	ax, 1
		adc	dx, 0
		mov	si, ax
		call	GetFatSector
		pop	dx
		mov	ax, es:[bx]
		cmp	ax, 0FFF8h
		jnb	short GotClusterDone

NotLastCluster:				; CODE XREF: GetNextFatEntry+5Fj
		mov	cs:EndOfFile, 0

GotClusterDone:				; CODE XREF: GetNextFatEntry+5Dj
					; GetNextFatEntry+75j
		pop	es
		retn
GetNextFatEntry	endp


; =============== S U B	R O U T	I N E =======================================


GetFatSector	proc near		; CODE XREF: GetNextFatEntry+22p
					; GetNextFatEntry+33p ...
		push	ax
		push	si
		push	di
		mov	ax, si
		mov	cx, cs:BytesPerSec
		div	cx
		cmp	ax, word ptr cs:LastFatSector
		jz	short SplitChk
		mov	word ptr cs:LastFatSector, ax
		push	dx
		xor	dx, dx
		add	ax, cs:HiddenSectorsL
		adc	dx, cs:HiddenSectorsH
		add	ax, word ptr cs:ReservSectors
		adc	dx, 0
		mov	cs:StartSecL, ax
		mov	cs:StartSecH, dx

loc_517:				; DATA XREF: MSLOAD:ReadInFirstClustersr
					; MSLOAD:02DEr
		mov	cs:SectorCount,	1
		xor	di, di
		call	ReadSectors
		pop	dx
		mov	cx, cs:BytesPerSec

SplitChk:				; CODE XREF: GetFatSector+11j
		dec	cx
		cmp	dx, cx
		mov	bx, dx
		pop	di
		pop	si
		pop	ax

ec35_flag:
		retn
GetFatSector	endp

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR ReadSectors

ErrorOut:				; CODE XREF: ReadSectors:ReadErrorj
		push	cs
		pop	ds
		assume ds:MSLOAD
		mov	si, offset NonSystemDiskMsg ; "\r\nNon-System disk or disk error\r\nRe"...
		call	WriteTTY
		xor	ah, ah
		int	16h		; KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY
					; Return: AH = scan code, AL = character
		xor	bx, bx
		mov	ds, bx
		les	bx, dword ptr OrgDasdPtr
		mov	si, offset DskAddr ;  (Int 1Eh)
		mov	[si], bx
		mov	word ptr [si+2], es
		int	19h		; DISK BOOT
; END OF FUNCTION CHUNK	FOR ReadSectors	; causes reboot	of disk	system

; =============== S U B	R O U T	I N E =======================================


WriteTTY	proc near		; CODE XREF: ReadSectors+183p
					; WriteTTY+Bj
		lodsb
		or	al, al
		jz	short EndWrite
		mov	ah, 0Eh
		mov	bl, 7
		int	10h		; - VIDEO - WRITE CHARACTER AND	ADVANCE	CURSOR (TTY WRITE)
					; AL = character, BH = display page (alpha modes)
					; BL = foreground color	(graphics modes)
		jmp	short WriteTTY
; ---------------------------------------------------------------------------

EndWrite:				; CODE XREF: WriteTTY+3j
		retn
WriteTTY	endp

; ---------------------------------------------------------------------------
NonSystemDiskMsg db 0Dh,0Ah		; DATA XREF: ReadSectors+180o
		db 'Non-System disk or disk error',0Dh,0Ah
		db 'Replace and press any key when ready',0Dh,0Ah,0
EndOfLoader	db ?
MSLOAD		ends


		end
