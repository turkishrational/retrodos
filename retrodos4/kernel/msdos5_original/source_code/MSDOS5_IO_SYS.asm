; ---------------------------------------------------------------------------

bpbx		struc ;	(sizeof=0x19)	; ...
bytespersec	dw ?			; base 10
secperclust	db ?			; base 10
rsvdsecs	dw ?			; base 10
numfats		db ?			; base 10
rootdirents	dw ?			; base 10
totalsize16	dw ?			; base 10
mediaid		db ?
fatsecs		dw ?			; base 10
secpertrack	dw ?			; base 10
heads		dw ?			; base 10
hiddensecs_lw	dw ?			; base 10
hiddensecs_hw	dw ?			; base 10
totalsecs_lw	dw ?			; base 10
totalsecs_hw	dw ?			; base 10
bpbx		ends


;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2013 Hex-Rays, <support@hex-rays.com>	    |
; |			 Licensed to: Freeware version			    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	B2FA03653E5C5D545327EE28B8A24356
; Input	CRC32 :	20FC79BF

; ---------------------------------------------------------------------------

		.386
		.model flat

; ===========================================================================

; Segment type:	Pure code
DOSBIOS		segment	byte public 'CODE' use16
		assume cs:DOSBIOS
		assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing

BData_start:				; ...
		jmp	init		; MSBIO1.ASM, MSSBDATA.INC
; ---------------------------------------------------------------------------
DosDataSg	dw 0			; ...
bios_i2f	db 0EAh			; far jump to int_2f (segment may not be at 70h)
off_706		dw offset int_2f
word_708	dw 70h			; KERNEL_SEGMENT
romstartaddr	dw 0
altah		db 0			; ...
inHMA		db 0			; ...
xms		dd 0			; ...
ptrsav		dd 0			; ...
auxbuf		db 4 dup(0)		; ...
zeroseg		dw 0			; ...
i13_ds		dw 0			; ...
prevoper	dw 0			; ...
number_of_sec	db 0			; ...
auxnum		dw 0			; ...
res_dev_list	dw offset auxdev2	; ...
					; ConHeader:
		dw 70h			; Device Header	for the	CON Device Driver
word_727	dw 8013h
		dw offset strategy
		dw offset con_entry
aCon		db 'CON     '           ; ...
auxdev2		dw offset prndev2	; ...
		dw 70h
		dw 8000h
		dw offset strategy
		dw offset aux0_entry
aAux		db 'AUX     '
prndev2		dw offset timdev	; ...
		dw 70h
word_74B	dw 0A0C0h
		dw offset strategy
		dw offset prn0_entry
aPrn		db 'PRN     '
timdev		dw offset dskdev	; ...
		dw 70h
		dw 8008h
		dw offset strategy
		dw offset tim_entry
aClock		db 'CLOCK$  '
dskdev		dw offset com1dev	; ...
		dw 70h
		dw 8C2h
		dw offset strategy
		dw offset dsk_entry
drvmax		db 4			; ...
step_drv	db 0FEh			; ...
fhave96		db 0			; ...
single		db 0			; ...
fhavek09	db 0			; ...
fsetowner	db 0			; ...
com1dev		dw offset lpt1dev	; ...
		dw 70h
		dw 8000h
		dw offset strategy
		dw offset aux0_entry
aCom1		db 'COM1    '
lpt1dev		dw offset lpt2dev	; ...
word_78F	dw 70h
		dw 0A0C0h
		dw offset strategy
		dw offset prn1_entry
aLpt1		db 'LPT1    '
lpt2dev		dw offset lpt3dev	; ...
		dw 70h
word_7A3	dw 0A0C0h
		dw offset strategy
		dw offset prn2_entry
aLpt2		db 'LPT2    ',0,0,0
Orig13		dd 0			; ...
lpt3dev		dw offset com2dev	; ...
		dw 70h
		dw 0A0C0h
		dw offset strategy
		dw offset prn3_entry
asc_7C2		db 'LPT3    '
com2dev		dw offset com3dev	; ...
		dw 70h
		dw 8000h
		dw offset strategy
		dw offset aux1_entry
		db 'COM2    '
com3dev		dw offset com4dev	; ...
		dw 70h
		dw 8000h
		dw offset strategy
		dw offset aux2_entry
		db 'COM3    '
com4dev		dw 0FFFFh		; ...
		dw 70h
		dw 8000h
		dw offset strategy
		dw offset aux3_entry
		db 'COM4    '
RomVectors	db 10h			; ...
Old10		dd 0
		db 13h
Old13		dd 0			; ...
		db 15h
Old15		dd 0			; ...
		db 19h
Old19		dd 0
		db 1Bh
Old1B		dd 0
start_bds	dd 70034Eh		; ...
					; Start	of linked list of BDS's
accesscount	db 0			; ...
tim_drv		db 0FFh			; ...
medbyt		db 0			; ...
rflag		db 2			; ...
					; 2 for	read, 3	for write
verify		db 0			; 1 if verify after write
seccnt		dw 0			; ...
		db 0			; -- pad where hardnum was
dsktnum		db 1			; ...
motorstartup	db 0			; ...
settlecurrent	db 0			; ...
					; value	from table
settleslow	db 0			; ...
					; slow settle value
nextspeed	db 0			; value	of speed to be used
save_head_sttl	db 0			; ...
					; used by read_sector routine
save_eot	db 0			; ...
					; saved	eot from the default DPT
eot		db 9			; ...
dpt		dd 0			; ...
cursec		db 0			; ...
					; current sector
curhd		db 0			; ...
					; current head
curtrk		dw 0			; ...
					; current track
spsav		dw 0			; ...
					; save the stack pointer
formt_eot	db 8			; ...
					; eot used for format
hdnum		db 0			; ...
					; head number
trknum		dw 0			; ...
					; track	being manipulated
gap_patch	db 50h			; ...
					; format gap patched into dpt
errin		db 0CCh			; ...
					; write	fault error
		db 80h			; no response
		db 40h			; seek failure
		db 10h			; bad crc
		db 8			; dma overrun
		db 6			; media	change
		db 4			; sector not found
		db 3			; write	attempt	to write-protect disk
lsterr		db 0			; ...
					; all other errors
errout		db 10			; write	fault error
		db 2			; no response
		db 6			; seek failure
		db 4			; bad crc
		db 4			; dma overrun
		db 15			; invalid media	change
		db 8			; sector not found
		db 0			; write	attempt	to write-protect disk
		db 12			; general error
disksector	db 512 dup(0)		; ...
					; read in boot sector here
bds1		dw offset bds2
		dw 70h			; dword	link to	next structure
		db 0			; int 13h drive	number
		db 0			; logical drive	letter
fdrive1		dw 512			; ...
					; physical sector size in bytes
		db 0FFh			; sectors/allocation unit
		dw 1			; reserved sectors for dos
		db 2			; no of	file allocation	tables
		dw 64			; number of root directory entries
		dw 360			; number sectors (at 512 bytes each)
		db 0			; media	descriptor, initially 0
		dw 2			; number of fat	sectors
		dw 9			; sector limit (sectors	per track)
		dw 1			; head limit (number of	heads -	1)
		dw 0			; hidden sector	count (low word)
		dw 0			; hidden sector	(high)
		dw 0			; number sectors (low)
		dw 0			; number sectors (high)
		db 0			; true => large	fats
		dw 0			; open ref. count
		db 3			; form factor
		dw 20h			; various flags
		dw 40			; number of cylinders
recommended_bps	dw 512			; recommended bps for this drive
		db 1
		dw 1
		db 2
		dw 224			; number of root directory entries
		dw 360
		db 0F0h	; ð		; media	descriptor, initially 0F0h
		dw 2
		dw 9
		dw 2
		dw 0
		dw 0
		dw 0
		dw 0
		db 6 dup(0)
		db 0FFh			; last track accessed on this drive
word_A95	dw 0FFFFh		; keep these two contiguous (?)
		dw 0FFFFh
		db 'NO NAME    ',0      ; volume id for this disk
		dd 0			; current volume serial	from boot record
		db 'FAT12   ',0         ; current file system id from boot record
bds2		dw offset bds3		; ...
		dw 70h
		db 0
		db 0
fdrive2		dw 512			; ...
byte_ABA	db 0FFh, 1, 0, 2, 40h, 0, 68h, 1, 0, 2,	0, 9, 0, 1, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 3, 20h, 0, 28h, 0
		db 0, 2, 1, 1, 0, 2, 0E0h, 0, 68h, 1, 0F0h, 2, 0, 9, 0
		db 2, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0FFh
		db 0FFh, 0FFh, 0FFh, 0FFh, 4Eh,	4Fh, 20h, 4Eh, 41h, 4Dh
		db 45h,	20h, 20h, 20h, 20h, 0, 0, 0, 0,	0, 46h,	41h, 54h
		db 31h,	32h, 20h, 20h, 20h, 0
bds3		dw offset bds4		; ...
		dw 70h
		db 0
		db 0
fdrive3		dw 512			; ...
		db 0FFh, 1, 0, 2, 40h, 0, 68h, 1, 0, 2,	0, 9, 0, 1, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 3, 20h, 0, 28h, 0
		db 0, 2, 1, 1, 0, 2, 0E0h, 0, 68h, 1, 0F0h, 2, 0, 9, 0
		db 2, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0FFh
		db 0FFh, 0FFh, 0FFh, 0FFh, 4Eh,	4Fh, 20h, 4Eh, 41h, 4Dh
		db 45h,	20h, 20h, 20h, 20h, 0, 0, 0, 0,	0, 46h,	41h, 54h
		db 31h,	32h, 20h, 20h, 20h, 0
bds4		dw 0FFFFh		; ...
		dw 70h
		db 0
		db 0
fdrive4		dw 512			; ...
byte_B82	db 0FFh, 1, 0, 2, 40h, 0, 68h, 1, 0, 2,	0, 9, 0, 1, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 3, 20h, 0, 28h, 0
		db 0, 2, 1, 1, 0, 2, 0E0h, 0, 68h, 1, 0F0h, 2, 0, 9, 0
		db 2, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0FFh
		db 0FFh, 0FFh, 0FFh, 0FFh, 4Eh,	4Fh, 20h, 4Eh, 41h, 4Dh
		db 45h,	20h, 20h, 20h, 20h, 0, 0, 0, 0,	0, 46h,	41h, 54h
		db 31h,	32h, 20h, 20h, 20h, 0
sm92		db 3			; ...
		db 9
		db 70h
		dw 1440			; 2*9*80
		db 2
		db 2
keyrd_func	db 0			; ...
keysts_func	db 1			; ...
printdev	db 0			; ...
					; printer device index
wait_count	dw 4 dup(50h)		; ...
					; retry	counts for printers
daycnt		dw 0			; ...
t_switch	db 0			; ...
					; flag for updating daycnt
havecmosclock	db 0			; ...
base_century	db 19			; ...
base_year	db 80			; ...
month_tab	db 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ; ...
bintobcd	dd bin_to_bcd		; ...
					; points to bin_to_bcd proc in msinit
daycnttoday	dd daycnt_to_day	; ...
					; points to daycnt_to_day in msinit
set_id_flag	db 0			; ...
					; flag for getbp routine
fat_12_id	db 'FAT12   ',0         ; ...
fat_16_id	db 'FAT16   ',0         ; ...
vol_no_name	db 'NO NAME    ',0      ; ...
temp_h		dw 0			; ...
					; temporary for	32 bit calculation
start_sec_h	dw 0			; ...
					; starting sector number high word
saved_word	dw 0			; ...
					; tempory saving place for a word
multrk_flag	dw 0			; ...
ec35flag	db 0			; ...
					; flags	for 3.5	inch disk drives
vretry_cnt	dw 0			; ...
soft_ecc_cnt	dw 0			; ...
multitrk_format_flag db	0		; ...
					; multi	track format request flag
xfer_seg	dw 0			; ...
					; temp for transfer segment
sectorspertrack	dw 36			; ...
tracktable	db 0, 0, 1, 2		; ...
		db 0, 0, 2, 2
		db 0, 0, 3, 2
		db 0, 0, 4, 2
		db 0, 0, 5, 2
		db 0, 0, 6, 2
		db 0, 0, 7, 2
		db 0, 0, 8, 2
		db 0, 0, 9, 2
		db 0, 0, 10, 2
		db 0, 0, 11, 2
		db 0, 0, 12, 2
		db 0, 0, 13, 2
		db 0, 0, 14, 2
		db 0, 0, 15, 2
		db 0, 0, 16, 2
		db 0, 0, 17, 2
		db 0, 0, 18, 2
		db 0, 0, 19, 2
		db 0, 0, 20, 2
		db 0, 0, 21, 2
		db 0, 0, 22, 2
		db 0, 0, 23, 2
		db 0, 0, 24, 2
		db 0, 0, 25, 2
		db 0, 0, 26, 2
		db 0, 0, 27, 2
		db 0, 0, 28, 2
		db 0, 0, 29, 2
		db 0, 0, 30, 2
		db 0, 0, 31, 2
		db 0, 0, 32, 2
		db 0, 0, 33, 2
		db 0, 0, 34, 2
		db 0, 0, 35, 2
		db 0, 0, 36, 2
		db 108 dup(0)		; 4*max_sectors_curr_sup - ($ -	tracktable) dup	(0)
					; times	((4*63)	- 144) db 0
mediatype	db 0			; ...
media_set_for_format db	0		; ...
had_format_error db 0			; ...
tempdpt		dd 0FFFFFFFFh		; ...
					; temp disk base table
model_byte	db 0FFh			; ...
					; model	byte set at init time
secondary_model_byte db	0		; ...
int19sem	db 0			; ...
					; i19_lst
i19_lst		db 2			; ...
					; Int19old&aa
int19old02	dd 0FFFFFFFFh
		db 8
int19old08	dd 0FFFFFFFFh		; original hardware int. vectors for int 19h
		db 9
int19old09	dd 0FFFFFFFFh
		db 0Ah
int19old0A	dd 0FFFFFFFFh
		db 0Bh
int19old0B	dd 0FFFFFFFFh
		db 0Ch
int19old0C	dd 0FFFFFFFFh
		db 0Dh
int19old0D	dd 0FFFFFFFFh
		db 0Eh
int19old0E	dd 0FFFFFFFFh
		db 70h
int19old70	dd 0FFFFFFFFh
		db 72h
int19old72	dd 0FFFFFFFFh
		db 73h
int19old73	dd 0FFFFFFFFh
		db 74h
int19old74	dd 0FFFFFFFFh
		db 76h
int19old76	dd 0FFFFFFFFh
		db 77h
int19old77	dd 0FFFFFFFFh
dskdrvs		dw offset fdrive1	; ...
		dw offset fdrive2
		dw offset fdrive3
		dw offset fdrive4
		dw 22 dup(0)		; up to	26 drives for mini disks
int6c_ret_addr	dd 0			; ...
bin_date_time	db 0, 0, 0, 0		; ...
					; century, year, month,	day
month_table	dw 0			; ...
					; january
		dw 31			; february
		dw 59
		dw 90
		dw 120
		dw 151
		dw 181
		dw 212
		dw 243
		dw 273
		dw 304
		dw 334			; december
daycnt2		dw 0			; ...
feb29		db 0			; february 29 in a leap	year flag
cdev		dw 43h,	2C7h		; ...
					; chardev_entry
					; at 2C7h:43h =	70h:25B3h
ttticks		dw 396h, 2C7h		; ...
					; time_to_ticks
					; at 2C7h:396h = 70h:2906h
bcode_i2f	dw 1302h, 2C7h		; ...
					; i2f_handler
					; at 2C7h:1302h	= 70h:3872h
i13x		dw 154Bh, 2C7h		; ...
					; i13z
					; at 2C7h:154Bh	= 70h:3ABBh
; ---------------------------------------------------------------------------

cbreak:					; ...
		mov	cs:altah, 3	; break	key handling
					; indicate break key set

intret:					; ...
		iret

; =============== S U B	R O U T	I N E =======================================


strategy	proc far		; ...
		mov	word ptr cs:ptrsav, bx ; store es:bx (device driver request packet)
					; away at [ptrsav] for next driver function call
		mov	word ptr cs:ptrsav+2, es
		retf
strategy	endp

; ---------------------------------------------------------------------------

con_entry:				; ...
		call	cdev_entry
; ---------------------------------------------------------------------------
		dw 0E4h			; con_table
					; 2C7h:0E4h = 70h:2654h
; ---------------------------------------------------------------------------

prn0_entry:				; ...
		call	cdev_entry
; ---------------------------------------------------------------------------
		dw 0FBh			; prn_table
					; 2C7h:0FBh = 70h:266Bh
		db 0, 0
; ---------------------------------------------------------------------------

prn1_entry:				; ...
		call	cdev_entry
; ---------------------------------------------------------------------------
		dw 0FBh			; prn_table
					; 2C7h:0FBh = 70h:266Bh
		db 0, 1
; ---------------------------------------------------------------------------

prn2_entry:				; ...
		call	cdev_entry
; ---------------------------------------------------------------------------
		dw 0FBh			; prn_table
					; 2C7h:0FBh = 70h:266Bh
		db 1, 2
; ---------------------------------------------------------------------------

prn3_entry:				; ...
		call	cdev_entry
; ---------------------------------------------------------------------------
		dw 0FBh			; prn_table
					; 2C7h:0FBh = 70h:266Bh
		db 2, 3
; ---------------------------------------------------------------------------

aux0_entry:				; ...
		call	cdev_entry
; ---------------------------------------------------------------------------
		dw 130h			; aux_table
					; 2C7h:130h = 70h:26A0h
		db 0
; ---------------------------------------------------------------------------

aux1_entry:				; ...
		call	cdev_entry
; ---------------------------------------------------------------------------
		dw 130h			; aux_table
					; 2C7h:130h = 70h:26A0h
		db 1
; ---------------------------------------------------------------------------

aux2_entry:				; ...
		call	cdev_entry
; ---------------------------------------------------------------------------
		dw 130h			; aux_table
					; 2C7h:130h = 70h:26A0h
		db 2
; ---------------------------------------------------------------------------

aux3_entry:				; ...
		call	cdev_entry
; ---------------------------------------------------------------------------
		dw 130h			; aux_table
					; 2C7h:130h = 70h:26A0h
		db 3
; ---------------------------------------------------------------------------

tim_entry:				; ...
		call	cdev_entry
; ---------------------------------------------------------------------------
		dw 147h			; tim_table
					; 2C7h:147h = 70h:26B7h
; ---------------------------------------------------------------------------

dsk_entry:				; ...
		call	cdev_entry
; ---------------------------------------------------------------------------
		dw 4A2h			; dsktbl
					; 2C7h:4A2h = 70h:2A12h

; =============== S U B	R O U T	I N E =======================================


cdev_entry	proc near		; ...
		cmp	cs:inHMA, 0
		jz	short ce_enter_codeseg
		push	ax
		mov	ax, cs:DosDataSg
		cmp	word ptr cs:ptrsav+2, ax
		pop	ax
		jnz	short not_from_dos

ce_enter_codeseg:			; ...
		jmp	dword ptr cs:cdev ; jmp	far [cs:cdev]
; ---------------------------------------------------------------------------

not_from_dos:				; ...
		call	EnsureA20On
		jmp	short ce_enter_codeseg
cdev_entry	endp

; ---------------------------------------------------------------------------

outchr:					; ...
		push	ax		; int 29h handler
		push	si
		push	di
		push	bp
		push	bx
		mov	ah, 0Eh
		mov	bx, 7
		int	10h		; - VIDEO - WRITE CHARACTER AND	ADVANCE	CURSOR (TTY WRITE)
					; AL = character, BH = display page (alpha modes)
					; BL = foreground color	(graphics modes)
		pop	bx
		pop	bp
		pop	di
		pop	si
		pop	ax
		iret
; ---------------------------------------------------------------------------

block13:				; ...
		cmp	cs:inHMA, 0
		jz	short skipa20
		call	IsA20Off	; A20 Off?
		jnz	short skipa20
		call	EnableA20	; assure a20 enabled

skipa20:				; ...
		mov	cs:i13_ds, ds	; save caller's ds for call-through
		pushf			; fake interrupt
		call	dword ptr cs:i13x ; call far [cs:i13x]
					; call through Bios_Code entry table
		mov	ds, cs:i13_ds
		retf	2

; =============== S U B	R O U T	I N E =======================================


call_orig13	proc far		; ...
		mov	ds, ds:i13_ds	;  get caller's ds register
		pushf
		call	cs:Orig13	; call far [cs:orig13]
		mov	cs:i13_ds, ds
		push	cs
		pop	ds		; restore ds ->	Bios_Data before return
		assume ds:DOSBIOS
		pushf
		cmp	cs:inHMA, 0
		jz	short corig13_popf_retf
		call	IsA20Off
		jnz	short corig13_popf_retf
		call	EnableA20

corig13_popf_retf:			; ...
		popf
		retf
call_orig13	endp

; ---------------------------------------------------------------------------
HiMem		dd 0FFFF0090h		; ...
LoMem		dd 80h			; ...

; =============== S U B	R O U T	I N E =======================================


EnsureA20On	proc near		; ...
		call	IsA20Off
		jz	short EnableA20
		retn
EnsureA20On	endp


; =============== S U B	R O U T	I N E =======================================


EnableA20	proc near		; ...
		push	ax
		push	bx
		mov	ah, 5
		call	cs:xms
		pop	bx
		pop	ax
		retn
EnableA20	endp


; =============== S U B	R O U T	I N E =======================================


IsA20Off	proc near		; ...
		push	ds
		push	es
		push	cx
		push	si
		push	di
		lds	si, cs:HiMem
		assume ds:nothing
		les	di, cs:LoMem
		mov	cx, 8
		repe cmpsw
		pop	di
		pop	si
		pop	cx
		pop	es
		pop	ds
		retn
IsA20Off	endp

; ---------------------------------------------------------------------------

DisableA20:
		push	ax
		push	bx
		mov	ah, 6		; localdisable A20
		call	cs:xms
		pop	bx
		pop	ax
		retn
; ---------------------------------------------------------------------------

int19:					; ...
		push	cs		; bootstrap interrupt -- we must restore a bunch of the
					; interrupt vectors before resuming the	original int19 code
		pop	ds
		assume ds:DOSBIOS
		mov	es, zeroseg
		assume es:nothing
		mov	cx, 5		; NUMROMVECTORS
		mov	si, offset RomVectors

next_int:				; ...
		lodsb			; get int number
		cbw			; assume < 128
		shl	ax, 1
		shl	ax, 1		; int *	4
		mov	di, ax
		lodsw
		stosw
		lodsw
		stosw			; install the saved vector
		loop	next_int
		cmp	int19sem, 0
		jz	short doint19
		mov	si, offset i19_lst ; stacks code has changed these hardware interrupt vectors
					; stkinit in sysinit1 will initialize int19oldxx values
		mov	cx, 14		; num_i19

i19_restore_loop:			; ...
		lodsb			; get interrupt	number
		cbw			; assume < 128
		mov	di, ax
		lodsw			; get original vector offset
		mov	bx, ax		; save it
		lodsw
		cmp	bx, 0FFFFh	; check	for 0ffffh (unlikely segment)
		jz	short i19_restor_1 ; opt no need to check selector too
		cmp	ax, 0FFFFh	; opt 0ffffh is	unlikely offset
		jz	short i19_restor_1
		add	di, di
		add	di, di
		xchg	ax, bx
		stosw
		xchg	ax, bx
		stosw			; put the vector back

i19_restor_1:				; ...
		loop	i19_restore_loop

doint19:				; ...
		cmp	inHMA, 0	; ; Is dos running from	HMA
		jz	short SkipVDisk
		call	EraseVDiskHead	; Then erase our VDISK header at 1MB boundary
					; Some m/c's (AST 386 & HP QS/16 do not clear
					; the memory above 1MB during a	warm boot.

SkipVDisk:				; ...
		int	19h		; DISK BOOT
					; causes reboot	of disk	system

; =============== S U B	R O U T	I N E =======================================


Int15		proc near		; ...
		cmp	ax, 4F53h	; del keystroke	?
		jz	short int15_1
		jmp	cs:Old15
; ---------------------------------------------------------------------------

int15_1:				; ...
		push	ds
		push	ax
		mov	ax, 40h		; ROMDATASEG
		mov	ds, ax
		assume ds:nothing
		mov	al, ds:17h	; [KBFLAG]
		and	al, 0Ch		; (CTRLSTATE | ALTSTATE)
		cmp	al, 0Ch		; (CTRLSTATE | ALTSTATE)
		jnz	short int15_2
		push	cs
		pop	ds
		assume ds:DOSBIOS
		cmp	inHMA, 0	; is DOS running from HMA
		jz	short int15_2
		call	EraseVDiskHead

int15_2:				; ...
		pop	ax
		pop	ds
		assume ds:nothing
		stc
		jmp	cs:Old15
Int15		endp


; =============== S U B	R O U T	I N E =======================================


EraseVDiskHead	proc near		; ...
		push	ax		; Erases the VDisk Header present
					; in the 1MB boundary
		push	cx
		push	di
		push	es
		call	EnsureA20On
		mov	ax, 0FFFFh	; HMA seg
		mov	es, ax
		assume es:nothing
		mov	di, 10h		; point	to VDISK header
		mov	cx, 10h		; size of vdisk	header
		xor	ax, ax
		rep stosw		; clear	it
		pop	es
		assume es:nothing
		pop	di
		pop	cx
		pop	ax
		retn
EraseVDiskHead	endp

; ---------------------------------------------------------------------------

int_2f:					; ...
		jmp	dword ptr cs:bcode_i2f
; ---------------------------------------------------------------------------

i2f_dskentry:				; ...
		jmp	dsk_entry
; ---------------------------------------------------------------------------

re_init_:				; called back by sysinit after
		retf			; a bunch of stuff is done.
					; presently does nothing
; ---------------------------------------------------------------------------
Win386_SI	db 3, 0			; ...
					; SI_Version
					; Startup Info for Win386
SI_Next		dd 0			; ...
					; pointer to next info structure
		dd 0			; a field we don't need
		dd 0			; another field	we don't need
SI_Instance	dw offset Instance_Table
		dw 70h
Instance_Table	dw 0, 50h		; ...
					; print	screen status...
		dw 2			;  ...2	bytes
		dw 0Eh,	50h		; ROM Basic data...
		dw 14h			; ...14H bytes
		dw offset altah		; a con	device buffer...
		dw 70h			; Bios_Data segment
		dw 1			; ... 1	byte
NextStack	dw 0, 0			; pointer to next stack	to be used...
		dw 2			; ...2 bytes
IT_StackLoc	dd 0			; location of hardware stacks
IT_StackSize	dw 0			; size of hardware stacks
		dd 0			; terminate the	instance table
					; SR;
IsWin386	db 0			; ...
					; Flag to indicate whether
					; Win386 is running or not
; ---------------------------------------------------------------------------

V86_Crit_SetFocus:			; ...
		push	di		; This routine was originally in BIOS_CODE but this causes a lot of problems
					; when we call it including checking of	A20. The code being only about
					; 30 bytes, we might as	well put it in BIOS_DATA
		push	es
		push	bx
		push	ax
		xor	di, di
		mov	es, di
		assume es:nothing
		mov	bx, 15h		; Device ID of DOSMGR device
		mov	ax, 1684h	; Get API entry	point
		int	2Fh		; - Multiplex -	MS WINDOWS - GET DEVICE	API ENTRY POINT
					; BX = virtual device (VxD) ID,	ES:DI =	0000h:0000h
					; Return: ES:DI	-> VxD API entry point,	or 0:0 if the VxD does not support an API
		mov	ax, es
		or	ax, di
		jz	short Skip	; Here,	es:di is address of API	routine.
					; Set up stack frame to	simulate a call.
		push	cs
		mov	ax, offset Skip
		push	ax
		push	es
		push	di		; API far call address
		mov	ax, 1		; SetFocus function number
		retf			; do the call
; ---------------------------------------------------------------------------

Skip:					; ...
		pop	ax
		pop	bx
		pop	es
		assume es:nothing
		pop	di
		retf
; ---------------------------------------------------------------------------
FreeHMAPtr	dw 0FFFFh		; ...
MoveDOSIntoHMA	dd 46D0A84h		; ...
					; FTryToMovDOSHi
					; (procedure in	SYSINIT	segment)
SysinitPresent	db 0			; ...
endfloppy	db 0, 0			; ...
					; Bios_Data ends
					; Possibly disposable BIOS data
					; This data follows the	regular	BIOS data,
					; and is part of the same group.
nul_vid		db 'NO NAME    ',0      ; ...
					; null volume id
tmp_vid		db 'NO NAME    ',0      ; ...
					; vid scratch buffer
harddrv		db 80h			; ...
					; end96tpi
					; memory allocation for	bdss
bdss		dw 0FFFFh		; ...
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
		db 32h,	20h, 20h, 20h, 0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
		db 32h,	20h, 20h, 20h, 0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
		db 32h,	20h, 20h, 20h, 0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
		db 32h,	20h, 20h, 20h, 0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
		db 32h,	20h, 20h, 20h, 0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
		db 32h,	20h, 20h, 20h, 0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
		db 32h,	20h, 20h, 20h, 0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
		db 32h,	20h, 20h, 20h, 0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
		db 32h,	20h, 20h, 20h, 0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
		db 32h,	20h, 20h, 20h, 0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
		db 32h,	20h, 20h, 20h, 0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
		db 32h,	20h, 20h, 20h, 0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
		db 32h,	20h, 20h, 20h, 0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
		db 32h,	20h, 20h, 20h, 0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
		db 32h,	20h, 20h, 20h, 0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
		db 32h,	20h, 20h, 20h, 0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
		db 32h,	20h, 20h, 20h, 0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
		db 32h,	20h, 20h, 20h, 0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
		db 32h,	20h, 20h, 20h, 0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
		db 32h,	20h, 20h, 20h, 0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
		db 32h,	20h, 20h, 20h, 0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
		db 32h,	20h, 20h, 20h, 0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
		db 32h,	20h, 20h, 20h, 0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
		db 32h,	20h, 20h, 20h, 0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
		db 32h,	20h, 20h, 20h, 0
		db 0
; ---------------------------------------------------------------------------

ibm_disk_io:				; ...
		cmp	dl, 80h		; main routine,	fixes at rom bug
		jb	short atd1
		cmp	ah, 2
		jz	short atd2
		cmp	ah, 0Ah
		jz	short atd2

atd1:					; ...
		jmp	cs:Old13	; jmp far [cs:Old13]
					; use rom int 13h handler
; ---------------------------------------------------------------------------

atd2:					; ...
		push	bx
		push	cx
		push	dx
		push	di
		push	ds
		push	es
		push	ax
		mov	ax, 40h		; bioseg
					; establish bios segment addressing
		mov	ds, ax
		assume ds:nothing
		mov	byte ptr ds:74h, 0 ; [disk_status1]
		and	dl, 7Fh
		cmp	dl, ds:drvmax	; [hf_num]
		jb	short atd3
		mov	byte ptr ds:74h, 1 ; bad_disk
		jmp	short atd4
; ---------------------------------------------------------------------------

atd3:					; ...
		push	bx
		mov	ax, es
		shr	bx, 4
		add	ax, bx
		mov	es, ax
		pop	bx
		and	bx, 0Fh
		push	cs
		call	check_dma
; ---------------------------------------------------------------------------
		jb	short atd4
		pop	ax
		push	ax
		call	setcmd
; ---------------------------------------------------------------------------
		mov	dx, 3F6h
		out	dx, al		; AT only. Fixed disk register
		call	docmd
; ---------------------------------------------------------------------------

atd4:					; ...
		pop	ax
		mov	ah, ds:74h	; [disk_status1]
		or	ah, ah
		jz	short atd5
		stc

atd5:					; ...
		pop	es
		pop	ds
		assume ds:nothing
		pop	di
		pop	dx
		pop	cx
		pop	bx
		retf	2		; far return, dropping flags

; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn

setcmd		proc near		; ...
		mov	ds:43h,	al	; [cmd_block+sec_cnt]
		mov	byte ptr ds:48h, 20h ; [cmd_block+cmd_reg]
		cmp	ah, 2
		jz	short setc1	; cmd_reg = 20h	if function 02h	(read)
		mov	byte ptr ds:48h, 22h ; [cmd_block+cmd_reg]
					; cmd_reg = 22h	if function 0Ah	(read long)

setc1:					; ...
		mov	al, cl
		and	al, 3Fh		; mask sector number
		mov	ds:44h,	al	; [cmd_block+sec_num]
		mov	ds:45h,	ch	; [cmd_block+cyl_low]
		mov	al, cl
		shr	al, 6		; get two high bits of cylinder	number
		mov	ds:46h,	al	; [cmd_block+cyl_high]
		mov	ax, dx
		shl	al, 4		; drive	number
		and	ah, 0Fh
		or	al, ah		; head number
		or	al, 0A0h	; set ecc and 512 bytes	per sector
		mov	ds:47h,	al	; [cmd_block+drv_head]
		push	es
		push	bx
		push	cs
		call	get_vec
; ---------------------------------------------------------------------------
		mov	ax, es:[bx+5]	; [es:bx+fdp_precomp]
		shr	ax, 2
		mov	ds:42h,	al	; [cmd_block+pre_comp]
		mov	al, es:[bx+8]	; [es:bx+fdp_control]
		pop	bx
		pop	es
		mov	ah, ds:76h	; [control_byte]
		and	ah, 0C0h
		or	ah, al
		mov	ds:76h,	ah
		retn
setcmd		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn

docmd		proc near		; ...
		mov	di, bx
		push	cs
		call	command
; ---------------------------------------------------------------------------
		jnz	short doc3

doc1:					; ...
		push	cs
		call	waitt		; wait for controller to complete read
; ---------------------------------------------------------------------------
		jnz	short doc3
		mov	cx, 256
		mov	dx, 1F0h	; hf_port
		cld
		cli

rsct_loop:				; ...
		insw
		loop	rsct_loop
		sti
		test	byte ptr ds:48h, 2 ; [cmd_block+cmd_reg]
					; (ds =	40h)
		jz	short doc2
		push	cs
		call	wait_drq
; ---------------------------------------------------------------------------
		jb	short doc3
		mov	cx, 4
		mov	dx, 1F0h
		cli
		rep insb
		sti

doc2:					; ...
		push	cs
		call	check_status
; ---------------------------------------------------------------------------
		jnz	short doc3
		dec	byte ptr ds:43h	; [cmd_block+sec_cnt]
		jnz	short doc1

doc3:					; ...
		retn
docmd		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn

get_vec		proc near		; ...
		push	0FF65h		; romfret ; far	return in rom
		jmp	far ptr	0F000h:2F8Eh ; jmp romsegment:romget_vec
get_vec		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn

command		proc near		; ...
		push	0FF65h		; romfret ; far	return in rom
		jmp	far ptr	0F000h:2E1Eh ; jmp romsegment:romcommand
command		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn

waitt		proc near		; ...
		push	0FF65h		; romfret ; far	return in rom
		jmp	far ptr	0F000h:2E7Fh ; jmp romsegment:romwait
waitt		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn

wait_drq	proc near		; ...
		push	0FF65h		; romfret ; far	return in rom
		jmp	far ptr	0F000h:2EE2h ; romsegment:romwait_drq
wait_drq	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn

check_status	proc near		; ...
		push	0FF65h		; romfret ; far	return in rom
		jmp	far ptr	0F000h:2EF8h ; jmp romsegment:romcheck_status
check_status	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn

check_dma	proc near		; ...
		push	0FF65h		; romfret ; far	return in rom
		jmp	far ptr	0F000h:2F69h ; jmp romsegment:romcheck_dma
check_dma	endp

; ---------------------------------------------------------------------------

endatrom:				; ...
		cmp	ah, 15h		; compaq_disk_io proc far
					;
					; the following	label defines the end of the at	rom patch.
					; this is used at configuration	time.
					;
					; warning!!!
					; this code will be dynamically	relocated by msinit
		ja	short mebbe_hookit ; only deal with functions >	15h

no_hookit:				; ...
		jmp	cs:Old13
; ---------------------------------------------------------------------------

mebbe_hookit:				; ...
		cmp	dl, 80h
		jb	short no_hookit
		push	ds
		push	ax
		mov	ax, 40h
		mov	ds, ax
		assume ds:nothing
		pop	ax
		pushf
		call	cs:Old13
		pop	ds
		assume ds:nothing
		retf	2
; ---------------------------------------------------------------------------
end_compaq_i13hook db 0			; ...

; =============== S U B	R O U T	I N E =======================================


daycnt_to_day	proc far		; ...
		push	cs:daycnt
		cmp	cs:daycnt, 7305	; (365*20+(20/4))
					; # days from 1-1-1980 to 1-1-2000
		jnb	short century20
		mov	cs:base_century, 19
		mov	cs:base_year, 80
		jmp	short years
; ---------------------------------------------------------------------------

century20:				; ...
		mov	cs:base_century, 20
		mov	cs:base_year, 0
		sub	cs:daycnt, 7305	; (365*20+(20/4))
					; adjust daycnt

years:					; ...
		xor	dx, dx
		mov	ax, cs:daycnt
		mov	bx, 1461	; (366+365*3)
					; # of days in a Leap year block
		div	bx		; AX = # of leap block,	DX = daycnt
		mov	cs:daycnt, dx	; save daycnt left
		mov	bl, 4
		mul	bl		; AX = # of years. Less	than 100
		add	cs:base_year, al ; So, ah = 0. Adjust year
		inc	cs:daycnt	; set daycnt to	1 base
		cmp	cs:daycnt, 366	; daycnt=remainder of leap year	bk
		jbe	short leapyear	; within 366+355+355+355 days.
		inc	cs:base_year	; if daycnt <= 366, then leap year
		sub	cs:daycnt, 366	; else daycnt--, base_year++ ;
		mov	cx, 3		; And next three years are normal

regularyear:				; ...
		cmp	cs:daycnt, 365	; for(i=1; i>3 or daycnt <=365;	i++)
		jbe	short yeardone	; {if (daycnt >	365)
		inc	cs:base_year	;   { daycnt -=	365
		sub	cs:daycnt, 365	;   }
		loop	regularyear	; }
					;
					; should never fall through loop

leapyear:				; ...
		mov	cs:month_tab+1,	29 ; leap year.
					; change month table.

yeardone:				; ...
		xor	bx, bx
		xor	dx, dx
		mov	ax, cs:daycnt
		mov	si, offset month_tab
		mov	cx, 12

months:					; ...
		inc	bl
		mov	dl, [si]	; mov dl, [cs:si]
		cmp	ax, dx		; cmp daycnt for each month till fit
					; dh=0
		jbe	short month_done
		inc	si		; next month
		sub	ax, dx		; adjust daycnt
		loop	months		;
					; should never fall through loop

month_done:				; ...
		mov	cs:month_tab+1,	28 ; restore month table value
		mov	dl, bl
		mov	dh, cs:base_year
		mov	cl, cs:base_century ; al=day,dl=month,dh=year,cl=cntry
		call	cs:bintobcd	; convert "day"	to bcd
					; dl = bcd day,	al = month
		xchg	dl, al
		call	cs:bintobcd	; call far [cs:bintobcd]
					; dh = bcd month, al = year
		xchg	dh, al
		call	cs:bintobcd	;
					; cl = bcd year, al = century
		xchg	cl, al

loc_1BF2:				; ...
		call	cs:bintobcd	; ch = bcd century
		mov	ch, al
		pop	cs:daycnt	; restore original value
		retf
daycnt_to_day	endp


; =============== S U B	R O U T	I N E =======================================


bin_to_bcd	proc far		; ...
		push	cx		; real time clock support
		aam			; al=high digit	bcd, ah=low digit bc
		mov	cl, 4
		shl	ah, cl		; mov the high digit to	high nibble
		or	al, ah
		pop	cx
		retf
bin_to_bcd	endp

; ---------------------------------------------------------------------------

int6c:					; ...
		push	cs		; warning!!!
					; this code will be dynamically	relocated by msinit.
		pop	ds
		assume ds:DOSBIOS
		pop	word ptr int6c_ret_addr	; pop off return address
		pop	word ptr int6c_ret_addr+2
		popf
		call	read_real_date	; get the date from the	clock
		cli
		mov	daycnt,	si	; update dos copy of date
		sti
		call	read_real_time	; get the time from the	rtc
		cli
		mov	ah, 1
		int	1Ah		; CLOCK	- SET TIME OF DAY
					; CX:DX	= clock	count
					; Return: time of day set
		sti
		jmp	int6c_ret_addr

; =============== S U B	R O U T	I N E =======================================


read_real_date	proc near		; ...
		push	ax
		push	cx
		push	dx
		xor	ah, ah		; throw	away clock roll	over
		int	1Ah		; CLOCK	- GET TIME OF DAY
					; Return: CX:DX	= clock	count
					; AL = 00h if clock was	read or	written	(via AH=0,1) since the previous
					; midnight
					; Otherwise, AL	> 0
		pop	dx
		pop	cx
		pop	ax
		push	ax
		push	bx
		push	cx
		push	dx
		mov	cs:daycnt2, 1	; REAL TIME CLOCK ERROR	FLAG (+1 DAY)
		mov	ah, 4
		int	1Ah		; CLOCK	- READ DATE FROM REAL TIME CLOCK (AT,XT286,CONV,PS)
					; Return: DL = day in BCD
					; DH = month in	BCD
					; CL = year in BCD
					; CH = century (19h or 20h)
		jnb	short read_ok
		jmp	r_d_ret
; ---------------------------------------------------------------------------

read_ok:				; ...
		mov	bin_date_time, ch
		mov	bin_date_time+1, cl
		mov	bin_date_time+2, dh
		mov	bin_date_time+3, dl
		mov	cs:daycnt2, 2	; READ OF R-T CLOCK SUCCESSFUL
		call	bcd_verify	; verify bcd values in range
		jb	short r_d_ret	;  some	value out of range
		mov	cs:daycnt2, 3
		call	date_verify
		jb	short r_d_ret
		mov	cs:daycnt2, 0
		call	in_bin
		mov	al, bin_date_time+1
		cbw
		cmp	bin_date_time, 20 ; 20th century?
		jnz	short century_19 ; no
		add	ax, 100		; add in a century

century_19:				; ...
		sub	ax, 80		; subtract off 1-1-80
		mov	cl, 4		; leap year every 4
		div	cl		; al= #	leap year blocks, ah= remainder
		mov	bl, ah		; save odd years
		cbw			; zero ah
		mov	cx, 1461	; 366+(3*365)
					; # of days in leap year blocks
		mul	cx
		mov	cs:daycnt2, ax	; SAVE COUNT OF	DAYS
		mov	al, bl		; get odd years	count
		cbw
		or	ax, ax
		jz	short leap_year
		mov	cx, 365		; days in year
		mul	cx
		add	cs:daycnt2, ax	; ADD ON DAYS IN ODD YEARS
		jmp	short leap_adjustment ;	account	for leap year
					; possibly account for a leap day
; ---------------------------------------------------------------------------

leap_year:				; ...
		cmp	bin_date_time+2, 2 ; is	month february?
		jbe	short no_leap_adjustment ; jan or feb. no leap day yet.

leap_adjustment:			; ...
		inc	cs:daycnt2	; account for leap day

no_leap_adjustment:			; ...
		mov	cl, bin_date_time+3 ; get days of month
		xor	ch, ch
		dec	cx		; because of offset from day 1,	not day	0
		add	cs:daycnt2, cx	; GET DAYS IN MONTHS PRECEEDING
		mov	cl, bin_date_time+2 ; get month
		xor	ch, ch
		dec	cx		; january starts at offset 0
		shl	cx, 1		; word offset
		mov	si, offset month_table
		add	si, cx
		mov	ax, [si]	; mov ax, [cs:si]
					; get #	days in	previous months
		add	cs:daycnt2, ax

r_d_ret:				; ...
		mov	si, cs:daycnt2
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		retn
read_real_date	endp

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR read_real_time

r_t_retj:				; ...
		xor	cx, cx
		xor	dx, dx
		jmp	short r_t_ret
; END OF FUNCTION CHUNK	FOR read_real_time

; =============== S U B	R O U T	I N E =======================================


read_real_time	proc near		; ...

; FUNCTION CHUNK AT 15E6 SIZE 00000006 BYTES

		mov	ah, 2
		int	1Ah		; CLOCK	- READ REAL TIME CLOCK (AT,XT286,CONV,PS)
					; Return: CH = hours in	BCD
					; CL = minutes in BCD
					; DH = seconds in BCD
		jb	short r_t_retj
		mov	bin_date_time, ch ; hours
		mov	bin_date_time+1, cl ; minutes
		mov	bin_date_time+2, dh ; seconds
		mov	bin_date_time+3, 0 ; unused for	time
		call	bcd_verify
		jb	short r_t_retj
		call	time_verify
		jb	short r_t_retj
		call	in_bin		; from bcd to bin
		mov	ch, bin_date_time
		mov	cl, bin_date_time+1
		mov	dh, bin_date_time+2
		mov	dl, bin_date_time+3
		call	dword ptr ttticks ; call far [ttticks]
					; note:	indirect far call
					;
					; cx:dx	= number of ticks
					; (at 18.2 ticks per sec.)

r_t_ret:				; ...
		retn
read_real_time	endp


; =============== S U B	R O U T	I N E =======================================


in_bin		proc near		; ...
		mov	al, bin_date_time ; century or hours
		call	bcd_to_bin
		mov	bin_date_time, al
		mov	al, bin_date_time+1 ; years or minutes
		call	bcd_to_bin
		mov	bin_date_time+1, al
		mov	al, bin_date_time+2 ; months or	seconds
		call	bcd_to_bin
		mov	bin_date_time+2, al
		mov	al, bin_date_time+3 ; days (not	used for time)
		call	bcd_to_bin
		mov	bin_date_time+3, al
		retn
in_bin		endp


; =============== S U B	R O U T	I N E =======================================


bcd_to_bin	proc near		; ...
		mov	ah, al
		and	al, 0Fh
		mov	cl, 4
		shr	ah, cl
		aad
		retn
bcd_to_bin	endp


; =============== S U B	R O U T	I N E =======================================


date_verify	proc near		; ...
		cmp	bin_date_time, 20h ; century check
		ja	short date_error
		jz	short century_20 ; jmp in 21th century
		cmp	bin_date_time, 19h ; century check
		jb	short date_error
		cmp	bin_date_time+1, 80h ; year check
		jb	short date_error

century_20:				; ...
		cmp	bin_date_time+1, 99h ; year check
		ja	short date_error
		cmp	bin_date_time+2, 12h ; month check
		ja	short date_error
		cmp	bin_date_time+2, 0
		jbe	short date_error
		cmp	bin_date_time+3, 31h ; day check
		ja	short date_error
		cmp	bin_date_time+3, 0 ; day check
		jbe	short date_error
		clc
		retn
; ---------------------------------------------------------------------------

date_error:				; ...
		stc
		retn
date_verify	endp


; =============== S U B	R O U T	I N E =======================================


time_verify	proc near		; ...
		cmp	bin_date_time, 24h ; hour check
		ja	short time_error
		cmp	bin_date_time+1, 59h ; minute check
		ja	short time_error
		cmp	bin_date_time+2, 59h ; second check
		ja	short time_error
		clc
		retn
; ---------------------------------------------------------------------------

time_error:				; ...
		stc
		retn
time_verify	endp


; =============== S U B	R O U T	I N E =======================================


bcd_verify	proc near		; ...
		mov	cx, 4		; 4 bytes to check
		mov	bx, offset bin_date_time

bv_loop:				; ...
		mov	al, [bx]	; get a	bcd number (0..99)
		mov	ah, al
		and	ax, 0F00Fh	; 10's place in high ah, 1's in al
					; is 1's place in range?
		cmp	al, 10
		ja	short bv_error	; jmp out of range
		shr	ah, 1
		shr	ah, 1
		shr	ah, 1
		shr	ah, 1
		and	ah, 0Fh		; get rid of any erroneous bits
		cmp	ah, 10		; is 10's place in range
		ja	short bv_error	; jmp out of range
		inc	bx		; next byte
		dec	cx
		jnz	short bv_loop
		clc			; set success flag
		retn
; ---------------------------------------------------------------------------

bv_error:				; ...
		stc			; set error flag
		retn
bcd_verify	endp

; ---------------------------------------------------------------------------
endk09		db 90h
drvfat		dw 0			; ...
					; drive	and fat	id of dos
bios_l		dw 0			; ...
					; first	sector of data (low word)
bios_h		dw 0			; ...
					; first	sector of data (high word)
doscnt		dw 0			; ...
					; how many sectors to read
fbigfat		db 0			; ...
					; flags	for drive
fatloc		dw 0			; ...
					; seg addr of fat sector
init_bootseg	dw 0			; ...
					; seg addr of buffer for reading boot record
rom_drv_num	db 80h			; ...
					; rom drive number
md_sectorsize	dw 200h			; ...
					; used by get_fat_sector proc.
temp_cluster	dw 0			; ...
					; used by get_fat_sector proc.
last_fat_sec_num dw 0FFFFh		; ...
					; used by get_fat_sector proc.
num_heads	db 2			; ...
					; number of heads returned by rom
sec_trk		db 9			; ...
					; sec/trk returned by rom
num_cyln	db 40			; ...
					; number of cylinders returned by rom
fakefloppydrv	db 0			; ...
					; if 1,	then no	diskette drives	in the system.
disktable	dw 512,	256, 64, 0	; warning !!! old values
		dw 2048, 513, 112, 0
		dw 8192, 1026, 256, 0
		dw 32680, 2051,	512, 0	; warning !!! old values
		dw 65535, 4100,	1024, 0	; default disktable under
					; the assumption of total fat size <= 128 kb,
					; and the maximum size of fat entry = 16 bit.
disktable2	dw 0, 32680, 2051, 512,	0 ; ...
					; for compatibility.
		dw 4, 0, 402h, 200h, 40h ; covers upto 134 mb media.
					; fbig = 40h
		dw 8, 0, 803h, 200h, 40h ; upto	268 mb
		dw 10h,	0, 1004h, 200h,	40h ; upto 536 mb
		dw 20h,	0, 2005h, 200h,	40h ; upto 1072	mb
		dw 40h,	0, 4006h, 200h,	40h ; upto 2144	mb
		dw 80h,	0, 8007h, 200h,	40h ; upto 4288	mb...
					;
					; variables for	mini disk initialization
rom_minidisk_num db 0			; ...
					; temp variable	for phys unit
hnum		db 0			; ...
					; real number of hardfiles
last_dskdrv_table dw offset dskdrvs	; ...
					; index	into dskdrv table
end_of_bdss	dw offset bdss		; ...
					; offset value of the ending address
mini_hdlim	dw 0			; ...
mini_seclim	dw 0			; ...
bios_date	db '01/10/84',0         ; ...
					; used for checking at rom bios	date.
		db  90h	; 		;
					; the following	are the	recommended bpbs
					; for the media	that we	know of	so far.
bpb48t		bpbx <512, 2, 1, 2, 112, 720, 0FDh, 2, 9, 2, 0,	0, 0, 0> ; ...
					;
					; physical sector size in bytes
					; sectors/allocation unit
					; reserved sectors for dos
					; number of allocation tables
					; number of directory entries
					; number of sectors (at	512 bytes each)
					; media	descriptor
					; number of fat	sectors
					; sectors per track
					; heads
					; hidden sector	count (low word)
					; hidden sector	(high)
					; number of sectors (low)
					; number of sectors (high)
		db 90h
bpb96t		bpbx <512, 1, 1, 2, 224, 2400, 0F9h, 7,	15, 2, 0, 0, 0,	0> ; ...
		db 90h
bpb35		bpbx <512, 2, 1, 2, 112, 1440, 0F9h, 3,	9, 2, 0, 0, 0, 0> ; ...
		db 90h
bpb288		bpbx <512, 2, 1, 2, 240, 5760, 0F0h, 9,	36, 2, 0, 0, 0,	0> ; ...
		db 90h			;
					; align	2
bpbtable	dw offset bpb48t	; ...
					; 48tpi	drives
		dw offset bpb96t	; 96tpi	drives
		dw offset bpb35		; 3.5" drives
		dw offset bpb35		; unused 8" diskette
		dw offset bpb35		; unused 8" diskette
		dw offset bpb35		; used for hard	disk
off_1EE4	dw offset bpb35		; ...
					; used for tape	drive
		dw offset bpb35		; FFOTHER
		dw offset bpb35		; ERIMO
		dw offset bpb288	; 2.88MB drive
addr_of_bcretf	dw 0C8h			; ...
					; dw bc_retf
					; 2C7h:0C8h = 70h:2638h
; ---------------------------------------------------------------------------

call_bios_code:				; ...
		push	cs:addr_of_bcretf ; set	up near	return to far return
		push	cs:cdev+2	; push Bios_Code segment
		push	bp		; save offset of utility function
		retf
; ---------------------------------------------------------------------------
flp_drvs	db 0			; ...
; ---------------------------------------------------------------------------

init:					; ...
		cli			; MSINIT.ASM
					; --------------------------------------------------
					; entry	from boot sector. the register contents	are:
					;
					;  dl =	int 13 drive number we booted from
					;  ch =	media byte
					;  bx =	first data sector on disk.
					;  ax =	first data sector (high)
					;  di =	sectors/fat for	the boot media.
		push	ax
		xor	ax, ax
		mov	ds, ax
		assume ds:nothing
		pop	ax
		mov	cs:bios_h, ax	; (start of) dos bios (IO.SYS) data sector
		mov	cs:bios_l, bx
		push	cs		; Save a peck of interrupt vectors...
		pop	es
		assume es:DOSBIOS
		push	cx
		push	di
		mov	cx, 5		; NUMROMVECTORS
					; no. of rom vectors to	be saved
		mov	si, offset RomVectors ;	point to list of int vectors

next_int_:				; ...
		lods	byte ptr cs:[si] ; cs lodsb
		cbw			; ax = interrupt number
		shl	ax, 1
		shl	ax, 1		; int no * 4
		mov	di, ax		; interrupt vector address
		xchg	si, di		; rombios interrupt vector address in si
					; saving address in di
		lodsw			; movsw
		stosw
		lodsw			; movsw
		stosw			; save the vector
		xchg	si, di
		loop	next_int_
		pop	di
		pop	cx
		mov	ax, word ptr cs:Old13 ;	save old13 in orig13 also
		mov	word ptr cs:Orig13, ax
		mov	ax, word ptr cs:Old13+2
		mov	word ptr cs:Orig13+2, ax
		mov	word ptr ds:4Ch, offset	block13	; 13h*4
					; set up int 13	for new	action
		mov	word ptr ds:4Eh, cs ; 13h*4+2
		mov	word ptr ds:54h, offset	Int15 ;	15h*4
					; set up int 15	for new	action
		mov	word ptr ds:56h, cs ; 15h*4+2
		mov	word ptr ds:64h, offset	int19 ;	19h*4
					; set up int 19	for new	action
		mov	word ptr ds:66h, cs ; 19h*4+2
					; ;
		sti
		int	11h		; EQUIPMENT DETERMINATION
					; Return: AX = equipment flag bits
		test	ax, 1		; floppy drives	present	?
		jnz	short normalfloppydrv ;	yes.
		push	ax
		push	bx
		push	cx
		push	dx
		push	di
		push	es
		mov	ah, 8
		mov	dl, 0
		int	13h		; DISK - DISK -	GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)
					; DL = drive number
					; Return: CF set on error, AH =	status code, BL	= drive	type
					; DL = number of consecutive drives
					; DH = maximum value for head number, ES:DI -> drive parameter
		jb	short _gdskp_error
		mov	cs:flp_drvs, dl

_gdskp_error:				; ...
		pop	es
		assume es:nothing
		pop	di
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		jb	short normalfloppydrv
		cmp	cs:flp_drvs, 0	; number of drvs == 0?
		jz	short _set_fake_flpdrv
		mov	al, cs:flp_drvs
		dec	al		; make it zero based
		jmp	short got_num_flp_drvs
; ---------------------------------------------------------------------------

_set_fake_flpdrv:			; ...
		mov	cs:fakefloppydrv, 1 ; we don't have any floppy drives.
		mov	ax, 1
		jmp	short settwodrive ; well then set it for two drives!
; ---------------------------------------------------------------------------

normalfloppydrv:			; ...
		rol	al, 1		; there	exist floppy drives.
					; put bits 6 & 7 into bits 0 & 1
		rol	al, 1

got_num_flp_drvs:			; ...
		and	ax, 3		; only look at bits 0 &	1
		jnz	short notsingle	; zero means single drive system
		inc	ax		; pretend it's a two drive system

settwodrive:				; ...
		inc	cs:single	; set this to two fakedrives
					; remember this

notsingle:				; ...
		inc	ax		; ax has number	of drives, 2-4
					; is also 0 indexed boot drive if we
					; booted off hard file
		mov	cl, al		; ch is	fat id,	cl # floppies
		test	dl, 80h		; boot from floppy ?
		jnz	short gothrd	; no.
		xor	ax, ax		; indicate boot	from drive a

gothrd:					; ...
		xor	dx, dx		; ax = 0-based drive we	booted from
					; bios_l, bios_h set.
					; cl = number of floppies including fake one
					; ch = media byte
		cli
		mov	ss, dx		;  set stack segment and stack pointer
		assume ss:nothing
		mov	sp, 700h
		sti
		push	cx		; save number of floppies and media byte
		mov	ah, ch		; FAT ID to AH
		push	ax		; save boot drive number and media byte
		mov	ah, 0C0h
		int	15h		; SYSTEM - GET CONFIGURATION (XT after 1/10/86,AT mdl 3x9,CONV,XT286,PS)
		jb	short no_rom_system_conf ; just	use Model_Byte
		cmp	ah, 0
		jnz	short no_rom_system_conf
		mov	al, es:[bx+2]	; [es:bx+ROMBIOS_DESC.bios_sd_modelbyte]
		mov	cs:model_byte, al ; get/save model byte
		mov	al, es:[bx+3]	; [es:bx+ROMBIOS_DESC.bios_sd_scnd_modelbyte]
		mov	cs:secondary_model_byte, al ; get/save secondary model byte
		jmp	short turn_timer_on
; ---------------------------------------------------------------------------

no_rom_system_conf:			; ...
		mov	si, 0FFFFh
		mov	es, si
		assume es:nothing
		mov	al, es:0Eh	; get model byte (from 0FFFFh:0Eh)
		mov	cs:model_byte, al ; save model byte

turn_timer_on:				; ...
		mov	al, 20h	; ' '   ; turn on the timer
		out	20h, al		; Interrupt controller,	8259A.
					; AKPORT
		cmp	cs:model_byte, 0 ; next	to last	byte in	rom bios
		jnz	short not_olivetti_m24 ; skip for all other machines
					; (except olivetti m24)
		in	al, 66h		; is 8530 installed?
		test	al, 20h
		jz	short not_olivetti_m24 ; we're done if not
		mov	al, 0Fh		; double check
		out	50h, al
		in	al, 50h
		test	al, 1		; this test was	copied from olivetti
		jz	short skip_aux_port_init ; take	this branch if 8530 installed

not_olivetti_m24:			; ...
		mov	al, 3		; init com4
		call	aux_init
		mov	al, 2		; init com3
		call	aux_init
		mov	al, 1		; init com2
		call	aux_init
		xor	al, al		; init com1
		call	aux_init

skip_aux_port_init:			; ...
		mov	al, 2		; init lpt3
		call	print_init
		mov	al, 1		; init lpt2
		call	print_init
		xor	al, al		; init lpt1
		call	print_init
		xor	dx, dx
		mov	ds, dx		; to initialize	print screen vector
		mov	es, dx
		assume es:nothing
		xor	ax, ax
		mov	di, 534h	; INITSPOT (0000h:0534h)
					; IBM wants 4 zeros here
		stosw
		stosw
		mov	ax, cs		; fetch	segment
		mov	word ptr ds:6Ch, offset	cbreak ; [BRKADR]
					; break	entry point
		mov	ds:6Eh,	ax	; vector for break
		mov	word ptr ds:0A4h, offset outchr	; [CHROUT*4]
		mov	ds:0A6h, ax	; [CHROUT*4+2]
		mov	di, 4
		mov	bx, offset intret ; intret (cs:intret)
					; will initialize rest of interrupts
		xchg	ax, bx
		stosw			; location 4
		xchg	ax, bx		; cs:
		stosw			; int 1	; location 6
		add	di, 4
		xchg	ax, bx
		stosw			; location 12
		xchg	ax, bx		; cs:
		stosw			; int 3	; location 14
		xchg	ax, bx
		stosw			; location 16
		xchg	ax, bx		; cs:
		stosw			; int 4	; location 18
		mov	ds:500h, dx	; set print screen & break = 0
		mov	ds:504h, dx	; [LSTDRV]
					; clean	out last drive spec
		mov	al, ds:52Ch	; [SEC9+DISK_PARMS.DISK_MOTOR_STRT]
					; [522h+0Ch]
		mov	cs:motorstartup, al
		cmp	cs:model_byte, 0FDh ; is this an old rom?
		jb	short no_diddle	; no
		mov	word ptr ds:52Bh, 20Fh ; [SEC9+DISK_PARMS.DISK_HEAD_STTL], 0200h+NORMSETTLE
					; set head settle and motor start on pc-1 pc-2 pc-xt hal0
		mov	byte ptr ds:522h, 0DFh ; [SEC9+DISK_PARMS.DISK_SPECIFY_1]
					;  set 1st specify byte	on pc-1	pc-2 pc-xt hal0

no_diddle:				; ...
		int	12h		; MEMORY SIZE -
					; Return: AX = number of contiguous 1K blocks of memory
		mov	cl, 6
		shl	ax, cl		; convert memory size to 16-byte blocks	(segment no.)
		pop	cx
		mov	cs:drvfat, cx
		push	ax		; save real top	of memory
		push	ds
		push	bx
		xor	bx, bx

loc_208E:				; ...
		mov	ds, bx		; Check	if an RPL program is present at	TOM
					; and do not tromp over	it
		mov	bx, ds:0BCh	; [2Fh*4]
		mov	ds, word ptr ds:0BEh ; [2Fh*4+2]
		assume ds:nothing
		cmp	word ptr [bx+3], 'PR' ; 'RPL'
		jnz	short SkipRPL
		cmp	byte ptr [bx+5], 'L'
		jnz	short SkipRPL
		mov	dx, ax		; get TOM into DX
		mov	ax, 4A06h	; (multMULT shl	8) + multMULTRPLTOM
		int	2Fh		; Get new TOM from any RPL
		mov	ax, dx

SkipRPL:				; ...
		pop	bx
		pop	ds
		sub	ax, 64
		mov	cs:fatloc, ax
		sub	ax, 64
		mov	cs:init_bootseg, ax
		pop	ax
		mov	dx, 46Dh	; SYSINIT segment
		mov	ds, dx
		assume ds:nothing
		mov	word ptr ds:273h, offset res_dev_list ;
					; [SYSINIT+DEVICE_LIST]
		mov	word ptr ds:275h, cs ; [SYSINIT+DEVICE_LIST+2]
		mov	ds:292h, ax	; [SYSINIT+MEMORY_SIZE]
		inc	cl
		mov	ds:296h, cl	; [SYSINIT+DEFAULT_DRIVE]
		mov	word ptr ds:271h, 83Fh ; [SYSINIT+CURRENT_DOS_LOCATION]
					; dos_load_seg
		mov	ax, 46Dh	; SYSINIT segment
		mov	es, ax
		assume es:nothing
		xor	ax, ax		; Some old ibm hardware	generates spurious int 0F's
					; due to bogus printer cards.
					; we initialize	this value to point to an iret
					; only if
					;
					; 1) the original segment points to storage
					;    inside valid ram.
					;
					; 2) the original segment is 0F000:xxxx
		mov	ds, ax
		assume ds:nothing
		mov	ax, ds:3Eh	; [0Fh*4+2]
		cmp	ax, es:292h	; [ES:SYSINIT+MEMORY_SIZE]  ; (condition 1)
		jbe	short resetintf
		cmp	ax, 0F000h	; (condition 2)
		jnz	short keepintf

resetintf:				; ...
		mov	word ptr ds:3Ch, offset	intret ; [0Fh*4]
		mov	word ptr ds:3Eh, cs ; [0Fh*4+2]

keepintf:				; ...
		xor	cx, cx
		mov	ds, cx
		mov	cl, ds:496h	; get keyboard flag
		test	cl, 10h		; extended keyboard ?
		jz	short org_key	; no
		mov	cs:keyrd_func, 10h ; extended keyboard
		mov	cs:keysts_func,	11h ; change for extended keyboard functions

org_key:				; ...
		push	cs		; original keyboard
		pop	ds
		assume ds:DOSBIOS
		push	cs
		pop	es
		assume es:DOSBIOS
		call	cmos_clock_read	; If cmos clock	exists,
					; then set the system time according to	that.
					; also,	reset the cmos clock rate.
		mov	word ptr BData_start, offset harddrv ;
					; set up pointer to hdrive
		pop	ax		; number of floppies and FAT ID
		xor	ah, ah		; chuck	fat id byte
		mov	drvmax,	al	; remember which drive is hard disk
		mov	dsktnum, al	; and set initial number of drives
		shl	ax, 1
		add	last_dskdrv_table, ax
		mov	dl, 80h
		mov	ah, 8
		int	13h		; DISK - DISK -	GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)
					; DL = drive number
					; Return: CF set on error, AH =	status code, BL	= drive	type
					; DL = number of consecutive drives
					; DH = maximum value for head number, ES:DI -> drive parameter
		jb	short enddrv
		mov	hnum, dl

enddrv:					; ...
		xor	dl, dl
		push	cs
		pop	ds
		mov	eot, 9
		mov	di, offset start_bds ;
					; if we	are faking floppy drives we need
					; to set aside two bdss	for the	two fake floppy	drives
		cmp	fakefloppydrv, 1
		jnz	short loop_drive
		mov	di, [di]	; [di+BDS.link]
					; di <-	first bds link
		mov	di, [di]	; [di+BDS.link]
					; di <-	second bds link
		mov	word ptr [di], 0FFFFh ;	set end	of link
		jmp	dohard		; allocate/initialise bds for harddrives
; ---------------------------------------------------------------------------

loop_drive:				; ...
		cmp	dl, drvmax
		jb	short got_more
		jmp	done_drives
; ---------------------------------------------------------------------------

got_more:				; ...
		xor	cx, cx		; zero all flags
		mov	di, [di]	; [di+BDS.link]
					; get next bds
		mov	dh, 0		; ff48tpi
					; set form factor to 48	tpi
		mov	num_cyln, 40	; 40 tracks per	side
		push	ds
		push	di
		push	dx
		push	cx
		push	es
		mov	ah, 8
		int	13h		; DISK - DISK -	GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)
					; DL = drive number
					; Return: CF set on error, AH =	status code, BL	= drive	type
					; DL = number of consecutive drives
					; DH = maximum value for head number, ES:DI -> drive parameter
		jb	short noparmsfromrom
		cmp	ch, 0		; if ch=0, then	cl,dh=0	too.
		jnz	short pfr_ok
		mov	ch, 39		; rom gave wrong info.
		mov	cl, 9		; let's default to 360k.
		mov	dh, 1

pfr_ok:					; ...
		inc	dh		; make number of heads 1-based
		inc	ch		; make number of cylinders 1-based
		mov	num_heads, dh	; save parms returned by rom
		and	cl, 3Fh
		mov	sec_trk, cl
		mov	num_cyln, ch	; assume less than 256 cylinders!!
		cmp	cl, eot		; may set carry
		jbe	short eot_ok
		mov	eot, cl

eot_ok:					; ...
		pop	es
		assume es:nothing
		pop	cx
		pop	dx
		pop	di
		pop	ds		;
					; Check	for presence of	changeline
		assume ds:nothing
		mov	ah, 15h
		int	13h		; DISK - DISK -	GET TYPE (AT,XT2,XT286,CONV,PS)
					; DL = drive ID
					; Return: CF set on error, AH =	disk type (3 = hard drive)
					; CX:DX	= number of sectors on the media
		jb	short changeline_done
		cmp	ah, 2		; check	for presence of	changeline
		jnz	short changeline_done
		or	cl, 2		; fchangeline
					; signal type
		mov	ds:fhave96, 1	; remember that	we have	96tpi disks

changeline_done:			; ...
		cmp	ds:num_cyln, 40
		jnz	short try_80
		cmp	ds:sec_trk, 9
		jbe	short nextdrive

gotother:				; ...
		mov	dh, 7		; ffOther
					; we have a "strange" medium
		jmp	short nextdrive
; ---------------------------------------------------------------------------

try_80:					; ...
		cmp	ds:num_cyln, 80
		jnz	short gotother
		mov	dh, 9		; ff288
					; assume 2.88 MB drive
		cmp	ds:sec_trk, 36	; is it	?
		jz	short nextdrive	; yeah,	go update
		cmp	ds:sec_trk, 15
		jz	short got96
		cmp	ds:sec_trk, 9
		jnz	short gotother
		mov	dh, 2		; ffSmall
		jmp	short nextdrive
; ---------------------------------------------------------------------------

got96:					; ...
		mov	dh, 1		; ff96tpi
		jmp	short nextdrive
; ---------------------------------------------------------------------------

noparmsfromrom:				; ...
		pop	es		; we have an old rom, so we either have	a 48tpi	or 96tpi drive
					; if the drive has changeline, we assume it is a 96tpi
		pop	cx
		pop	dx
		pop	di
		pop	ds
		mov	ah, 15h
		int	13h		; DISK - DISK -	GET TYPE (AT,XT2,XT286,CONV,PS)
					; DL = drive ID
					; Return: CF set on error, AH =	disk type (3 = hard drive)
					; CX:DX	= number of sectors on the media
		jb	short nextdrive
		cmp	ah, 2		; is there changeline?
		jnz	short nextdrive
		or	cl, 2
		mov	ds:fhave96, 1	; fchangeline
		mov	ds:num_cyln, 80
		mov	dh, 1
		mov	al, 15
		cmp	al, ds:eot
		jbe	short nextdrive
		mov	ds:eot,	al

nextdrive:				; ...
		or	cl, 20h		; fi_own_physical
					; set this true	for all	drives
		mov	bh, dl		;
					; we need to do	special	things if
					; we have a single drive system
					; and are setting up a logical drive
		cmp	ds:single, 2
		jnz	short not_special
		dec	bh		; int13	drive number same for logical drive
		xor	cl, 20h		; reset	ownership flag for logical drive

not_special:				; ...
		xor	ax, ax		; fill BDS for drive
		mov	al, ds:num_heads
		mov	[di+36h], ax	; [di+BDS.rheads]
		mov	al, ds:sec_trk
		mov	[di+34h], ax	; [di+BDS.rsecpertrack]
		mov	[di+23h], cx	; [di+BDS.flags]
		mov	[di+22h], dh	; [di+BDS.formfactor]
		mov	[di+5],	dl	; [di+BDS.drivelet]
		mov	[di+4],	bh	; [di+BDS.drivenum]
		mov	bl, ds:num_cyln
		mov	[di+25h], bl	; [di+BDS.cylinders]
		cmp	ds:single, 1	; Special case for single drive	system
		jnz	short no_single
		mov	ds:single, 2	; Don't forget we have
					; single drive system
		or	cx, 10h		; fi_am_mult
					; set that this	is one of several drives
		or	[di+23h], cx	; [di+BDS.flags]
					; save flags
		mov	di, [di]	; [di+BDS.link]
					; move to next BDS in list
		inc	dl		; add a	number
		jmp	short nextdrive	; Use same info	for BDS	as previous
; ---------------------------------------------------------------------------

no_single:				; ...
		inc	dl
		jmp	loop_drive
; ---------------------------------------------------------------------------

done_drives:				; ...
		mov	word ptr [di], -1 ; set	link to	null
					;
					; set up all the hard drives in	the system

dohard:					; ...
		mov	dh, ds:hnum
		or	dh, dh		; done if no hardfiles
		jz	short static_configure
		mov	dl, 80h

dohard1:				; ...
		push	dx
		mov	di, ds:end_of_bdss
		mov	bl, ds:drvmax
		mov	bh, 0		; first	primary	partition (or active)
		call	sethard
		jb	short hardfile_err
		call	dmax_check	; error	if already 26 drives
		jnb	short hardfile_err
		call	xinstall_bds	; insert new bds into linked list

hardfile_err:				; ...
		pop	dx
		inc	dl		; next hard drive
		dec	dh
		jnz	short dohard1	;
					; end of physical drive	initialization
					; ;
		call	domini		; for setting up mini disks,
					; if found
		mov	dh, ds:hnum	; we already know this is >0
		mov	dl, 80h

dohardx1:				; ...
		mov	bh, 1		; do all subsequent primary partitions

dohardx2:				; ...
		push	dx
		push	bx
		mov	di, ds:end_of_bdss
		mov	bl, ds:drvmax
		call	sethard
		jb	short dohardx4	; move to next hardfile	if error
		call	dmax_check	; make sure <=26 drives
		jnb	short dohardx4	; skip if error
		call	xinstall_bds	; insert new bds into linked list
		pop	bx		; get partition	number
		pop	dx		; restore physical drive counts
		inc	bh
		jmp	short dohardx2	; keep looping until we	fail
; ---------------------------------------------------------------------------

dohardx4:				; ...
		pop	bx		; unjunk partition number from stack
		pop	dx		; restore physical drive counts
		inc	dl		; next hard drive
		dec	dh
		jnz	short dohardx1
		cmp	ds:dsktnum, 2	; >2 diskette drives
		jbe	short static_configure ;  no - no need for remapping
		call	remap		; remap	bds chain to adjust driver letters
					;
					; End of drive initialization.

static_configure:			; ...
		mov	di, ds:end_of_bdss
		cmp	di, offset bdss	; did we allocate any hard drive bdss?
		jnz	short dynamic_configure	; that's the end, then
		mov	di, offset harddrv ; end96tpi
					; keep everything up to	end96tpi
		cmp	ds:fhave96, 0
		jnz	short dynamic_configure
		mov	di, offset endfloppy

dynamic_configure:			; ...
		push	cs
		pop	es
		assume es:DOSBIOS
		cld
		cmp	ds:model_byte, 0FCh ; AT ?
		jnz	short checkcmosclock
		cmp	ds:hnum, 0	; No hard file?
		jz	short checkcmosclock
		xchg	ax, di		; save allocation pointer in ax
		mov	si, 0F000h
		mov	es, si		; ES ->	ROM BIOS segment
		assume es:nothing
		mov	si, offset bios_date ; "01/10/84"
		mov	di, 0FFF5h	; ROM BIOS string is at	F000:FFF5
		mov	cx, 9		; bdate_l
					; Only patch ROM for bios 01/10/84
		repe cmpsb		; check	for date + zero	on end
		xchg	ax, di		; restore allocation pointer
		jnz	short checkcmosclock
		mov	cx, offset endatrom
		mov	si, offset ibm_disk_io
		jmp	short install_int13_patch
; ---------------------------------------------------------------------------

checkcmosclock:				; ...
		mov	ax, 0F000h	; checkcompaqbug
		mov	es, ax		; point	to ROM BIOS
		cmp	word ptr es:0FFEAh, 'OC' ; look for COMPAQ
		jnz	short not_compaq_patch
		cmp	word ptr es:0FFECh, 'PM'
		jnz	short not_compaq_patch
		cmp	word ptr es:0FFEEh, 'QA'
		jnz	short not_compaq_patch
		mov	ax, es:0FFFBh	; get year
		xchg	ah, al
		cmp	ax, '86'        ; 3836h
					; is it	86?
		ja	short not_compaq_patch
		jb	short do_compaq_patch
		mov	ax, es:0FFF5h	; get month
		xchg	ah, al
		cmp	ax, '08'        ; 3038h
					; is it	08?
		ja	short not_compaq_patch
		jb	short do_compaq_patch
		mov	ax, es:0FFF8h	; get day
		xchg	ah, al
		cmp	ax, '04'        ; 3034h
					; is it	04?
		jnb	short not_compaq_patch

do_compaq_patch:			; ...
		mov	cx, offset end_compaq_i13hook
		mov	si, offset endatrom

install_int13_patch:			; ...
		push	cs
		pop	es
		assume es:DOSBIOS
		mov	word ptr ds:Orig13, di ; set new rom bios int 13 vector
		mov	word ptr ds:Orig13+2, cs
		sub	cx, si		; size of rom fix module
		rep movsb		; relocate it

not_compaq_patch:			; ...
		push	cs
		pop	es
		cmp	ds:havecmosclock, 1 ; cmos clock exists?
		jnz	short checkk09	; no
		mov	word ptr ds:daycnttoday, di ;
					; set the address for mschar
		mov	cx, 209		; enddaycnttoday - daycnt_to_day
		mov	si, offset daycnt_to_day
		rep movsb
		mov	word ptr ds:bintobcd, di ;
					; set the address for msclock
					; let original segment stay
		mov	cx, 11
		mov	si, offset bin_to_bcd
		rep movsb

checkk09:				; ...
		push	di
		mov	ax, 4101h	; wait for bh=es:[di]
		mov	bl, 1		; wait for 1 clock tick
		mov	bh, es:[di]
		stc			; Assume we will fail
		int	15h		; SYSTEM - WAIT	ON EXTERNAL EVENT (CONVERTIBLE)
					; AL = condition type, BH = condition compare or mask value
					; BL = timeout value times 55 milliseconds, 00h	means no timeout
					; DX = I/O port	address	if AL bit 4 set
		pop	di
		jb	short configdone
		mov	ds:fhavek09, 1	; remember we have a k09 type
		push	ds
		xor	ax, ax
		mov	ds, ax
		assume ds:nothing
		mov	ds:1B0h, di	; [6Ch*4]
					; new int 6ch handler
		mov	word ptr ds:1B2h, cs ; [6Ch*4+2]
		pop	ds
		assume ds:nothing
		mov	si, offset int6c
		mov	cx, 459		; endk09 - int6c
					; size of k09 routine
		rep movsb		;
					; set up config	stuff for sysinit

configdone:				; ...
		push	cs		; di is	final ending address of	msbio.
		pop	ds
		assume ds:DOSBIOS
		add	di, 15		; round	(up) to	paragraph
		shr	di, 1
		shr	di, 1
		shr	di, 1
		shr	di, 1
		add	di, 70h		; KERNEL_SEGMENT (in fact: IO.SYS loading segment)
		mov	DosDataSg, di	; where	the dos	data segment will be
		mov	ax, drvfat	; get drive and	fat id
		mov	bp, 4D7h	; set_drive (in	dosbios	code segment)
					; at 2C7h:4D7h = 70h:2A47h
		push	cs		; simulate far call
		call	call_bios_code	; get bds for drive
		mov	bp, 606h	; GetBp	(2C7h:606h = 70h:2B76h)
		push	cs
		call	call_bios_code
		push	es		; copy bds to ds:di
		pop	ds		;
					; the following	read of	es:0000	was spurious anyway. Should look into it.
					;
					; hmmmmmm. j.k.	took out a call	to getfat right	here a while
					; back.	Apparently it was what actually	setup es: for the following   ;	cas----
		xor	di, di
		mov	al, es:[di]	; get fat id byte
		mov	byte ptr es:drvfat+1, al ; ; save fat byte
		mov	ax, es:drvfat	;
					; cas -- why do	a SECOND setdrive here???
		push	es
		push	ds		; copy bds to es:di
		pop	es
		push	cs		; copy Bios_Data to ds
		pop	ds
		mov	bp, 4D7h	; SetDrive (2C7h:47Dh =	70h:2A47h)
		push	cs
		call	call_bios_code
		push	es
		pop	ds
		pop	es
		assume es:nothing
		mov	bx, [di+6]	; [di+BDS.BDS_BPB.BPB_BYTESPERSECTOR]
		mov	cs:md_sectorsize, bx ;	used by	get_fat_sector proc.
		mov	bl, [di+1Fh]	; [di+BDS.fatsiz]
					; get size of fat on media
		mov	es:16DEh, bl	; es:fbigfat
		mov	cl, [di+8]
		mov	ax, [di+17h]	; [di+BDS.BDS_BPB.BPB_HIDDENSECTORS]
		sub	es:16D8h, ax	; es:bios_l
		mov	ax, [di+19h]	; subtract hidden sectors since	we
					; need a logical sector	number that will
					; be used by getclus(diskrd procedure)
		sbb	es:16DAh, ax	; es:bios_h
					; subtract upper 16 bits of sector num
		xor	ch, ch		; cx = sectors/cluster
					;
					; the boot program has left the	directory at 0:500h
		push	ds
		xor	di, di
		mov	ds, di
		assume ds:nothing
		mov	bx, ds:53Ah	; clus=*53Ah
					; (First cluster field of 2nd dir entry
					; of root directory in the buffer at 500h)
		pop	ds
		assume ds:nothing

loadit:					; ...
		mov	ax, 46Dh
		mov	es, ax		; SYSINIT segment
		assume es:nothing
		mov	es, word ptr es:271h ; current_dos_location
		assume es:nothing
		call	getclus		; read cluster at ES:DI	(DI is updated)
; ---------------------------------------------------------------------------
		test	cs:fbigfat, 40h	; fbig
		jnz	short eofbig
		cmp	bx, 0FF7h
		jmp	short iseofx
; ---------------------------------------------------------------------------

eofbig:					; ...
		cmp	bx, 0FFF7h

iseofx:					; ...
		jb	short loadit	; keep loading until cluster = eof
		call	setdrvparms
		jmp	far ptr	46Dh:267h ; jmp	far SYSINITSEG:SYSINITSTART

; =============== S U B	R O U T	I N E =======================================


remap		proc near		; ...
		mov	di, word ptr cs:start_bds ; this function  will	be called only if
					; more than 2 diskettes	are found in the system
					;
					; get first bds

drive_loop:				; ...
		cmp	byte ptr [di+4], 80h ; [di+BDS.drivenum]
					; first	hard disk??
		jz	short fdrv_found ; yes,	continue
		mov	di, [di]	; [di+BDS.link]
					; get next bds,	assume segment
		cmp	di, -1		; last bds?
		jnz	short drive_loop ; loop	if not
		jmp	short rmap_exit	; yes, no hard drive on	system
; ---------------------------------------------------------------------------

fdrv_found:				; ...
		mov	al, 2		; start	with logical drv num=2

fdrv_loop:				; ...
		mov	[di+5],	al	; [di+BDS.drivelet]
					; found	??
		mov	di, [di]	; [di+BDS.link]
					; ds:di--> next	bds
		inc	al		; set num for next drive
		cmp	di, 0FFFFh	; last hard drive ??
		jnz	short fdrv_loop	; no - assign more disk	drives
		mov	di, word ptr cs:start_bds ; [start_bds]
					; get first bds
		mov	di, [di]	; [di+BDS.link]
					; ds:di-->bds2
		mov	ah, cs:dsktnum	; get number of	floppies to remap
		sub	ah, 2		; adjust for a:	& b:

remap_loop1:				; ...
		mov	di, [di]	; [di+BDS.drivelet]
					; set new num to next floppy
		mov	[di+5],	al
		inc	al		; new number for next floppy
		dec	ah		; count	down extra floppies
		jnz	short remap_loop1
		mov	al, byte ptr cs:drvfat ; now we've got to adjust the boot drive
					; if we	reassigned it
		cmp	al, 2		; is it	a: or b: ?
		jb	short rmap_exit
		sub	al, cs:dsktnum	; is it	one of the other floppies?
		jb	short remap_boot_flop ;	brif so
		add	al, 2		; bootdrv -= (dsktnum-2)
		jmp	short remap_change_boot_drv
; ---------------------------------------------------------------------------

remap_boot_flop:			; ...
		add	al, cs:drvmax	; bootdrv += (drvmax-dsktnum)

remap_change_boot_drv:			; ...
		mov	byte ptr cs:drvfat, al ; alter msdos.sys load drive
		inc	al
		push	ds
		mov	di, 46Dh	; SYSINIT segment
		mov	ds, di
		assume ds:nothing
		mov	ds:296h, al	; [SYSINIT+DEFAULT_DRIVE]
					; pass it to sysinit as	well
		pop	ds
		assume ds:nothing

rmap_exit:				; ...
		retn
remap		endp


; =============== S U B	R O U T	I N E =======================================


getboot		proc near		; ...
		mov	ax, cs:init_bootseg
		mov	es, ax
		mov	bx, 200h	; bootbias
					; load BX, ES:BX is where sector goes
		mov	ax, 201h
		xor	dh, dh
		mov	cx, 1
		int	13h		; DISK - READ SECTORS INTO MEMORY
					; AL = number of sectors to read, CH = track, CL = sector
					; DH = head, DL	= drive, ES:BX -> buffer to fill
					; Return: CF set on error, AH =	status,	AL = number of sectors read
		jb	short erret
		cmp	word ptr es:3FEh, 0AA55h ; [es:bootbias+1FEh]
					; Dave Litton magic word?
		jz	short norm_ret

erret:					; ...
		stc

norm_ret:				; ...
		retn
getboot		endp


; =============== S U B	R O U T	I N E =======================================


sethard		proc near		; ...
		push	di		; generate bpb for a variable sized hard file.
					; ibm has a partitioned	hard file
					; we must read physical	sector 0 to
					; determine where our own logical sectors start.
					; we also read in our boot sector to determine
					; version number
					;
					; inputs:
					; dl is	rom drive number (80...)
					; bh is	partition number (0....)
					; ds:di	points to bds
					;
					; outputs:
					; carry	clear -> bpb is	filled in
					; carry	set   -> bpb is	left uninitialized due to error
		push	bx
		push	ds
		push	es
		mov	[di+5],	bl	; [di+BDS.drivelet]
		mov	[di+4],	dl	; [di+BDS.drivenum]
		or	byte ptr [di+23h], 1 ; [di+BDS.flags]
					; fnon_removable
		mov	byte ptr [di+22h], 5 ; [di+BDS.formfactor]
					; ffHardFile
		mov	ds:fbigfat, 0	; assume 12 bit	FAT
		mov	dh, bh		; partition number
		push	dx
		mov	ah, 8
		int	13h		; DISK - DISK -	GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)
					; DL = drive number
					; Return: CF set on error, AH =	status code, BL	= drive	type
					; DL = number of consecutive drives
					; DH = maximum value for head number, ES:DI -> drive parameter
		inc	dh
		mov	[di+15h], dh	; [di+BDS.heads] ; get number of heads
		pop	dx
		jb	short setret	; error	if no hard disk
		and	cl, 3Fh
		mov	[di+13h], cl	; [di+BDS.secpertrack]
		push	dx		; save partition number
		call	getboot
		pop	dx		; restore partition number
		jb	short setret
		mov	bx, 3C2h	; 1C2h+bootbias

act_part:				; ...
		test	byte ptr es:[bx-4], 80h	; The first 'active' partition is 00,
					; the second is	01....
					; then the remainder of	the 'primary'
					; but non-active partitions
					;
					; is the partition active?
		jz	short no_act	; no
		cmp	byte ptr es:[bx], 1 ; reject if	partitiontype != 1, 4 or 6
		jz	short got_good_act
		cmp	byte ptr es:[bx], 4
		jz	short got_good_act
		cmp	byte ptr es:[bx], 6
		jnz	short no_act

got_good_act:				; ...
		or	dh, dh		; is this our target partition #?
		jz	short set2	; WE GOT THE ONE WANTED!!
		dec	dh		; count	down

no_act:					; ...
		add	bx, 16
		cmp	bx, 402h	; 202h+bootbias
					; last entry done?
		jnz	short act_part	; no,process next entry
					;
					; Now scan the non-active partitions
		mov	bx, 3C2h	; 1C2h+bootbias
					; restore original value of bx

get_primary:				; ...
		test	byte ptr es:[bx-4], 80h
		jnz	short not_prim	; we've already scanned
					; the ACTIVE ones
		cmp	byte ptr es:[bx], 1 ; see if partitiontype == 1, 4 or 6
		jz	short got_prim
		cmp	byte ptr es:[bx], 4
		jz	short got_prim
		cmp	byte ptr es:[bx], 6
		jnz	short not_prim

got_prim:				; ...
		or	dh, dh		; is this our target partition?
		jz	short set2
		dec	dh

not_prim:				; ...
		add	bx, 16
		cmp	bx, 402h	; 202h+bootbias
		jnz	short get_primary ; loop till we've gone through table

setret:					; ...
		stc			; error	return
		jmp	ret_hard_err
; ---------------------------------------------------------------------------

set2:					; ...
		mov	cs:rom_drv_num,	dl
		mov	ax, es:[bx+4]	; hidden sectors (start	sector)
		mov	dx, es:[bx+6]
		sub	ax, 1		; decrement the	sector count by	1
					; to make it zero based
		sbb	dx, 0
		add	ax, es:[bx+8]	; sectors in partition
		adc	dx, es:[bx+10]
		jnb	short okdrive
		or	ds:fbigfat, 80h	; ftoobig

okdrive:				; ...
		mov	ax, es:[bx+4]
		mov	[di+17h], ax	; [di+BDS.hiddensecs]
					; BPB_HIDDENSECTORS = p->partitionbegin
		mov	ax, es:[bx+6]
		mov	[di+19h], ax	; [di+BDS.hiddensecs+2]
		mov	dx, es:[bx+10]	; # of sectors (high)
		mov	ax, es:[bx+8]	; # of sectors (low)
		mov	[di+1Dh], dx	; [di+BDS.totalsecs32+2]
		mov	[di+1Bh], ax	; [di+BDS.totalsecs32]
					; bpb->maxsec =	p->partitionlength
		cmp	dx, 0
		ja	short okdrive_1
		cmp	ax, 64		; if (p->partitionlength < 64)
		jb	short setret	; return -1;

okdrive_1:				; ...
		mov	dx, [di+19h]	; [di+BDS.hiddensecs+2]
		mov	ax, [di+17h]	; [di+BDS.hiddensecs]
		xor	bx, bx		; boot sector number - for mini	disk
					; usually equal	to the # of sec/trk.
		mov	bl, [di+13h]	; [di+BDS.secpertrack]
		push	ax
		mov	ax, dx
		xor	dx, dx
		div	bx		; (sectors)dx:ax / (BDS.secpertrack)bx =
					; (track)temp_h:ax + (sector)dx
		mov	cs:temp_h, ax
		pop	ax
		div	bx
		mov	cl, dl
		inc	cl
		xor	bx, bx
		mov	bl, [di+15h]	; [di+BDS.heads]
		push	ax
		xor	dx, dx
		mov	ax, cs:temp_h
		div	bx
		mov	cs:temp_h, ax
		pop	ax
		div	bx		;  dl is head, ax is cylinder
		cmp	cs:temp_h, 0
		ja	short setret_brdg ; exceeds the	limit of int 13h
		cmp	ax, 1024
		ja	short setret_brdg ; exceeds the	limit of int 13h
		cmp	word ptr [di+47h], 1 ; [di+BDS.bdsm_ismini]
					; check	for mini disk
		jnz	short oknotmini	; not mini disk.
		add	ax, [di+49h]	; [di+BDS.bdsm_hidden_trks]
					; set the physical track number

oknotmini:				; ...
		ror	ah, 1		; move high two	bits of	cyl to high
		ror	ah, 1		; two bits of upper byte
		and	ah, 0C0h	; turn off remainder of	bits
		or	cl, ah		; move two bits	to correct spot
		mov	ch, al		; ch is	cylinder (low 8	bits)
					; cl is	sector + 2 high	bits of	cylinder
		mov	dh, dl		; dh is	head
		mov	dl, cs:rom_drv_num ; dl	is drive number
		push	cs
		pop	es
		assume es:DOSBIOS
		mov	bx, offset disksector ;	for convenience,
					; we are going to read the logical boot	sector
					; into cs:disksector area.
		mov	ax, 201h
		int	13h		; DISK - READ SECTORS INTO MEMORY
					; AL = number of sectors to read, CH = track, CL = sector
					; DH = head, DL	= drive, ES:BX -> buffer to fill
					; Return: CF set on error, AH =	status,	AL = number of sectors read
		mov	bx, offset disksector
		push	bx
		push	ax
		cmp	byte ptr cs:[bx], 0E9h ; is it a near jump?
		jz	short check_1_ok ; yes
		cmp	byte ptr cs:[bx], 0EBh ; is it a short jump?
		jnz	short invalid_boot_record ; no
		cmp	byte ptr cs:[bx+2], 90h	; yes, is the next one a nop?
		jnz	short invalid_boot_record

check_1_ok:				; ...
		mov	bx, 159h	; disksector+EXT_BOOT.BPB
					; point	to the bpb in the boot record
		mov	al, cs:[bx+10]	; [bx+EBPB.MEDIADESCRIPTOR]
					; get the mediadescriptor byte
		and	al, 0F0h	; mask off low nibble
		cmp	al, 0F0h	; is high nibble = 0Fh?
		jnz	short invalid_boot_record ; no,	invalid	boot record
		cmp	word ptr cs:[bx], 512 ;	[bx+EBPB.BYTESPERSECTOR]
		jnz	short invalid_boot_record ; invalidate non 512 byte sectors

check2_ok:				; yes, mediadescriptor ok.
		mov	al, cs:[bx+2]	; now make sure	that
					; the sectorspercluster	is
					; a power of 2
					;
					; [bx+EBPB.SECTORSPERCLUSTER]
					; get the sectorspercluster
		or	al, al		; is it	zero?
		jz	short invalid_boot_record ; yes, invalid boot record

ck_power_of_two:			; ...
		shr	al, 1		; shift	until first bit	emerges
		jnb	short ck_power_of_two
		jz	short valid_boot_record

invalid_boot_record:			; ...
		pop	ax
		pop	bx
		jmp	unknown		; jump to invalid boot record
					;  unformatted or illegal media.
; ---------------------------------------------------------------------------

valid_boot_record:			; ...
		pop	ax		; Signature found. Now check version.
		pop	bx
		cmp	word ptr cs:[bx+8], 2E32h ; '2.'
		jnz	short try5
		cmp	byte ptr cs:[bx+0Ah], 30h ; '0'
		jnz	short try5
		jmp	short copybpb
; ---------------------------------------------------------------------------

setret_brdg:				; ...
		jmp	setret
; ---------------------------------------------------------------------------

unknown3_0_j:				; ...
		jmp	unknown3_0	; legally formatted media,
					; although, content might be bad.
; ---------------------------------------------------------------------------

try5:					; ...
		call	cover_fdisk_bug	;
					; see if it is an os2 signature
		cmp	word ptr cs:[bx+8], 2E30h ; '0.'
		jnz	short no_os2
		mov	al, cs:[bx+7]
		sub	al, 31h		; '1'
		and	al, 0FEh
		jz	short copybpb	; accept either	'1' or '2'
		jmp	unknown
; ---------------------------------------------------------------------------

no_os2:					; ...
		cmp	word ptr cs:[bx+8], 2E33h ; '3.'
		jb	short unknown3_0_j ; must be 2.1 boot record.
					; do not trust it, but still legal.
		jnz	short copybpb	; honor	os2 boot record
					; or dos 4.0 version
		cmp	byte ptr cs:[bx+0Ah], 31h ; '1'
		jb	short unknown3_0_j ;
					; if version >=	3.1, then o.k.

copybpb:				; ...
		cmp	cs:disksector+26h, 29h ; [disksector+EXT_BOOT.SIG]
					; EXT_BOOT_SIGNATURE
		jnz	short copybpb_fat ; conventional fat system
		cmp	cs:disksector+10h, 0 ;
					; [disksector+EXT_BOOT.BPB+EBPB.NUMBEROFFATS]
		jnz	short copybpb_fat ; a fat system.
					;
					; non fat based	media.
		push	di
		push	ds
		push	ds
		pop	es
		assume es:nothing
		push	cs
		pop	ds
		assume ds:DOSBIOS
		mov	si, 159h	; disksector+EXT_BOOT.BPB
		add	di, 6		; add di,BDS.BPB
		cmp	word ptr cs:[si+8], 0 ;	[cs:si+EBPB.TOTALSECTORS]
		jnz	short already_nonz ;
					;  how about big_total?
		cmp	word ptr cs:[si+15h], 0	; [cs:si+EBPB.BIGTOTALSECTORS]
		jnz	short already_nonz
		cmp	word ptr cs:[si+17h], 0	; [cs:si+EBPB.BIGTOTALSECTORS+2]
		jnz	short already_nonz ;
					; now let's copy the values from the partition table
					; (now in the BDS) into	the BPB	in the boot sector buffer,
					; before they get copied back
		mov	ax, [di+8]	; [di+BDS.totalsecs16]
		mov	cs:[si+8], ax	; [cs:si+EBPB.TOTALSECTORS]
		mov	ax, [di+15h]	; [di+BDS.totalsecs32]
		mov	cs:[si+15h], ax	; [cs:si+EBPB.BIGTOTALSECTORS]
		mov	ax, [di+17h]	; [di+BDS.totalsecs32+2]
		mov	cs:[si+17h], ax	; [cs:si+EBPB.BIGTOTALSECTORS+2]

already_nonz:				; ...
		mov	cx, 25
		rep movsb
		pop	ds
		assume ds:nothing
		pop	di
		push	es
		push	ds
		pop	es
		push	cs
		pop	ds
		assume ds:DOSBIOS
		mov	bp, 751h	; mov_media_ids
					; at 2C7h:751h = 70h:2CC1h
					; set volume id, systemid, serial.
		push	cs		; simulate far call
		call	call_bios_code
		push	es
		pop	ds
		assume ds:nothing
		pop	es
		jmp	goodret
; ---------------------------------------------------------------------------

copybpb_fat:				; ...
		mov	si, 159h	; disksector+EXT_BOOT.BPB
					; cs:si	-> bpb in boot
		xor	dx, dx
		mov	ax, cs:[si+8]	; [cs:si+EBPB.TOTALSECTORS]
					; get totsec from boot sec
		or	ax, ax
		jnz	short copy_totsec ; if non zero, use that
		mov	ax, cs:[si+15h]	; [cs:si+EBPB.BIGTOTALSECTORS]
					; get the big version
					; (32 bit total	sectors)
		mov	dx, cs:[si+17h]	; [cs:si+EBPB.BIGTOTALSECTORS+2]
		mov	cx, dx
		or	cx, ax		; see if it is a big zero
		jz	short totsec_already_set ; screw it. it	was bogus.

copy_totsec:				; ...
		mov	[di+1Bh], ax	; [di+BDS.totalsecs32]
					; make DPB match boot sec
		mov	[di+1Dh], dx	; [di+BDS.totalsecs32+2]

totsec_already_set:			; ...
		mov	ax, [di+1Bh]	; [di+BDS.totalsecs32]
		mov	dx, [di+1Dh]	; [di+BDS.totalsecs32+2]

fat_big_small:				; [cs:si+EBPB.RESERVEDSECTORS]
		mov	bx, cs:[si+3]	; get #reserved_sectors	from BPB
		mov	[di+9],	bx	; [di+BDS.resectors]
					; update BDS field
		sub	ax, bx
		sbb	dx, 0		; update the count
		mov	bx, cs:[si+0Bh]	; [cs:si+EBPB.SECTORSPERFAT]
					; bx = sectors/fat
		mov	[di+11h], bx	; [di+BDS.fatsecs]
					; set in bds bpb
		shl	bx, 1		; always 2 fats
		sub	ax, bx		; sub #	fat sectors
		sbb	dx, 0
		mov	bx, cs:[si+6]	; [cs:si+EBPB.ROOTENTRIES]
					; # root entries
		mov	[di+0Ch], bx	; [di+BDS.direntries]
					; set in bds bpb
		mov	cl, 4
		shr	bx, cl		; div by 16 ents/sector
		sub	ax, bx		; sub #	dir sectors
		sbb	dx, 0		;
					; dx:ax	now contains the
					; # of data sectors
		xor	cx, cx
		mov	cl, cs:[si+2]	; [cs:si+EBPB.SECTORSPERCLUSTER]
					; sectors per cluster
		mov	[di+8],	cl	; [di+BDS.secperclus]
					; set in bios bpb
		push	ax
		mov	ax, dx
		xor	dx, dx
		div	cx		; cx = sectors per cluster
		mov	cs:temp_h, ax	; [temp_h]:ax now contains the
					; # clusters.
		pop	ax
		div	cx
		cmp	cs:temp_h, 0
		ja	short toobig_ret ; too big cluster number
		cmp	ax, 0FF6h	; 4096-10
					; is this 16-bit fat?
		jb	short copymediaid ; no,	small fat
		or	ds:fbigfat, 40h	; fbig
					; 16 bit fat

copymediaid:				; ...
		push	es
		push	ds
		pop	es
		push	cs
		pop	ds
		assume ds:DOSBIOS
		mov	bp, 751h	; mov_media_ids
					; at 2C7h:751h = 70h:2CC1h
					; copy filesys_id, volume label
		push	cs		; simulate far call
		call	call_bios_code
		push	es
		pop	ds
		assume ds:nothing
		pop	es
		jmp	massage_bpb	; now final check for bpb info
					; and return.
; ---------------------------------------------------------------------------

toobig_ret:				; ...
		or	cs:fbigfat, 80h
		jmp	goodret		; still	drive letter is	assigned
					; but useless. to big for
					; current pc dos fat file system
; ---------------------------------------------------------------------------

unknown:				; ...
		or	word ptr [di+23h], 200h	; [di+BDS.flags]
					; unformatted_media
					; Set unformatted media	flag.
					; ;
					; the boot signature may not be	recognizable,
					; but we should	try and	read it	anyway.

unknown3_0:				; ...
		mov	dx, [di+1Dh]	; skip setting unformatted_media bit
					; [di+BDS.totalsecs32+2]
		mov	ax, [di+1Bh]	; [di+BDS.totalsecs32]
		mov	si, offset disktable2

scan:					; ...
		cmp	dx, cs:[si]
		jb	short gotparm
		ja	short scan_next
		cmp	ax, cs:[si+2]
		jbe	short gotparm

scan_next:				; ...
		add	si, 10		; 5*2
		jmp	short scan	; covers upto 512 mb media
; ---------------------------------------------------------------------------

gotparm:				; ...
		mov	cl, [si+8]	; fat size for fbigfat flag
		or	ds:fbigfat, cl
		mov	cx, cs:[si+4]	; ch = number of sectors per cluster
					; cl = log base	2 of ch
		mov	dx, cs:[si+6]
		mov	[di+0Ch], dx	; [di+BDS.direntries]
					; save number of (root)	dir entries
		mov	dx, [di+1Dh]	; [di+BDS.totalsecs32+2]
		mov	ax, [di+1Bh]	; [di+BDS.totalsecs32]
		mov	[di+8],	ch	; [di+BDS.secperclus]
					; save sectors per cluster
		test	ds:fbigfat, 40h	; fbig
					; if (fbigfat)
		jnz	short dobig	; goto dobig; (16 bit fat)
		xor	bx, bx		; (12 bit fat)
		mov	bl, ch
		dec	bx
		add	bx, ax		; dx=0
		shr	bx, cl		; bx = 1+(bpb->maxsec+BDS.secperclus-1)/
		inc	bx		; BDS.secperclus
		and	bl, 0FEh	;  bx &= ~1; (=number of clusters)
		mov	si, bx
		shr	bx, 1
		add	bx, si
		add	bx, 511		; bx +=	511 + bx/2
		shr	bh, 1		; bh >>= 1; (=bx/512)
		mov	[di+11h], bh	; [di+BDS.fatsecs]
					; save number of fat sectors
		jmp	short massage_bpb
; ---------------------------------------------------------------------------

dobig:					; ...
		mov	cl, 4		; 16 (2^4) directory entries
					; per sector
		push	dx		; save total sectors (high)
		mov	dx, [di+0Ch]	; [di+BDS.direntries]
		shr	dx, cl		; root dir sectors = BDS.direntries / 16;
		sub	ax, dx
		pop	dx
		sbb	dx, 0		; dx:ax	= total	sectors	- root dir sectors
		sub	ax, 1
		sbb	dx, 0		; dx:ax	= t - r	- d
					; total	secs - reserved	secs - root dir	secs
		mov	bl, 2		; ;
					; ; 29/12/2018 - Erdogan Tan (Retro DOS	v4.0)
					; ; 27/09/2022
					; (Microsoft FAT32 File	System Specification,
					; December 2000, Page 21)
					; TmpVal1 = DskSize - (BPB_ResvdSecCnt+RootrDirSectors)
					; TmpVal2 = (256*BPB_SecPerClus)+BPB_NumFATs
					; FATsz	= (TmpVal1+(TmpVal2-1))/TmpVal2
					; (If FATType == FAT16,	BPB_FATSz16 = LOWORD(FATSz))
					; ;
		mov	bh, [di+8]	; [di+BDS.secperclus]
					; bx = 256 * BDS.secperclus + 2
		add	ax, bx		; ax = t-r-d+256*spc+2
		adc	dx, 0
		sub	ax, 1		; ax = t-r-d+256*spc+1
		sbb	dx, 0
		div	bx		; BDS.fatsecs =
					; ceil((total-dir-res)/(256*BDS.secperclus+2))
		mov	[di+11h], ax	; [di+BDS.fatsecs]
					; number of fat	sectors
		mov	bl, ds:fbigfat
		mov	[di+1Fh], bl	; [di+BDS.fatsiz] ; fat	size flag
		push	ds
		push	ds
		pop	es
		push	cs
		pop	ds
		assume ds:DOSBIOS
		mov	bp, 5D9h	; clear_ids
					; at 2C7h:5D9h = 70h:2B49h
		push	cs
		call	call_bios_code
		pop	ds
		assume ds:nothing

massage_bpb:				; ...
		mov	dx, [di+1Dh]	; [di+BDS.totalsecs32+2]
		mov	ax, [di+1Bh]	; [di+BDS.totalsecs32]
		cmp	dx, 0		; double word total sectors?
		ja	short goodret	;  don't have to change it.
		cmp	word ptr [di+19h], 0 ; [di+BDS.hiddensecs+2]
		ja	short goodret	; don't have to change it.
		add	ax, [di+17h]	; [di+BDS.hiddensecs]
		jb	short goodret
		mov	ax, [di+1Bh]	; [di+BDS.totalsecs32]
		mov	[di+0Eh], ax	; [di+BDS.totalsecs16]
		mov	word ptr [di+1Bh], 0 ; [di+BDS.totalsecs32]

goodret:				; ...
		mov	bl, ds:fbigfat
		mov	[di+1Fh], bl	; [di+BDS.fatsiz]
					; set size of fat on media
		clc

ret_hard_err:				; ...
		pop	es
		pop	ds
		pop	bx
		pop	di
		retn
sethard		endp


; =============== S U B	R O U T	I N E =======================================


cover_fdisk_bug	proc near		; ...
		push	ax		; If BPB_TOTALSECTORS +	hidden sector =	10000h
					; then subtract	1 from BPB_TOTALSECTORS.
		push	dx
		push	si
		cmp	cs:disksector+26h, 29h ; [disksector+EXT_BOOT.SIG]
					; EXT_BOOT_SIGNATURE
		jz	short cfb_retit	; if extended bpb, then	>= pc dos 4.00
		cmp	word ptr cs:[bx+7], 3031h ; '10' ; os2 1.0 = ibm 10.0
		jnz	short cfb_chk_BPB_TOTALSECTORS
		cmp	byte ptr cs:[bx+10], '0'
		jnz	short cfb_retit

cfb_chk_BPB_TOTALSECTORS:		; ...
		mov	si, 159h	; disksector+EXT_BOOT.BPB
		cmp	word ptr cs:[si+8], 0 ;	[cs:si+EBPB.TOTALSECTORS]
					; just to make sure.
		jz	short cfb_retit
		mov	ax, cs:[si+8]	; [cs:si+EBPB.TOTALSECTORS]
		add	ax, cs:[si+11h]	; [cs:si+EBPB.HIDDENSECTORS]
		jnb	short cfb_retit
		jnz	short cfb_retit	; if carry set and ax=0
		dec	word ptr cs:[si+8] ; 0 -> 0FFFFh
					; then decrease	BPB_TOTALSECTORS by 1
		sub	word ptr [di+1Bh], 1 ; [di+BDS.totalsecs32]
		sbb	word ptr [di+1Dh], 0 ; [di+BDS.totalsecs32+2]

cfb_retit:				; ...
		pop	si
		pop	dx
		pop	ax
		retn
cover_fdisk_bug	endp

; ---------------------------------------------------------------------------
word2		dw 2			; ...
word3		dw 3			; ...
word512		dw 512			; ...

; =============== S U B	R O U T	I N E =======================================


setdrvparms	proc near		; ...
		xor	bx, bx
		les	di, ds:start_bds ; get first bds in list

_next_bds:				; ...
		push	es
		push	di
		mov	bl, es:[di+22h]	; [es:di+BDS.formfactor]
		cmp	bl, 5		; ffHardFile
		jnz	short nothardff
		xor	dx, dx
		mov	ax, es:[di+0Eh]	; [es:di+BDS.totalsecs16]
		or	ax, ax
		jnz	short get_ccyl
		mov	dx, es:[di+1Dh]	; [es:di+BDS.totalsecs32+2]
		mov	ax, es:[di+1Bh]	; [es:di+BDS.totalsecs32]

get_ccyl:				; ...
		push	dx
		push	ax
		mov	ax, es:[di+15h]	; [es:di+BDS.heads]
		mul	word ptr es:[di+13h] ; [es:di+BDS.secpertrack]
					; assume sectors per cyl. < 64k.
		mov	cx, ax		; cx has # sectors per cylinder
		pop	ax
		pop	dx		; dx:ax	= total	sectors
		push	ax
		mov	ax, dx
		xor	dx, dx
		div	cx
		mov	cs:temp_h, ax	; ax be	0 here.
		pop	ax
		div	cx		; div #sec by sec/cyl to get # cyl.
		or	dx, dx
		jz	short no_cyl_rnd
		inc	ax		; round	up

no_cyl_rnd:				; ...
		mov	es:[di+25h], ax	; [es:di+BDS.cylinders]
		push	es
		pop	ds
		lea	si, [di+6]	; [di+BDS.bytespersec]
					; ds:si	-> bpb for hard	file
		jmp	short set_recbpb
; ---------------------------------------------------------------------------

nothardff:				; ...
		push	cs
		pop	ds
		assume ds:DOSBIOS
		cmp	cs:fakefloppydrv, 1 ; if fake floppy drive variable is set
					; then we don't have to handle this bds
		jz	short go_to_next_bds
		cmp	bl, 7		; ffother
					; special case "other" type of medium
		jnz	short not_process_other
		xor	dx, dx
		mov	ax, [di+25h]	; [di+BDS.cylinders]
		mul	word ptr [di+36h] ; [di+BDS.rheads]
		mul	word ptr [di+34h] ; [di+BDS.rsecpertrack]
		mov	[di+2Fh], ax	; [di+BDS.rtotalsecs16]
		dec	ax
		mov	dl, 1

_again:					; ...
		cmp	ax, 0FF6h	; 4096-10
		jb	short _@@
		shr	ax, 1
		shl	dl, 1
		jmp	short _again
; ---------------------------------------------------------------------------

_@@:					; ...
		cmp	dl, 1		; is it	a small	disk ?
		jz	short __@@	; yes, 224 root	entries	is enuf
		mov	word ptr [di+2Dh], 240 ; [di+BDS.rdirentries]

__@@:					; ...
		mov	[di+29h], dl	; [di+BDS.rsecperclus]
					;
					; logic	to get the sectors/fat area.
					; fat entry is assumed to be 1.5 bytes
		mul	cs:word3	; * 3
		div	cs:word2	; / 2
		xor	dx, dx
		div	cs:word512	; / 512
		inc	ax		; + 1
		mov	[di+32h], ax	; [di+BDS.rfatsecs]
		jmp	short go_to_next_bds
; ---------------------------------------------------------------------------

not_process_other:			; ...
		shl	bx, 1		; bx is	word index into	table of bpbs
		mov	si, offset bpbtable
		mov	si, [bx+si]	; get address of bpb

set_recbpb:				; ...
		lea	di, [di+27h]	; [di+BDS.R_BPB]
					; es:di	-> recbpb
		mov	cx, 25
		rep movsb

go_to_next_bds:				; ...
		pop	di
		pop	es
		les	di, es:[di]	; [es:di+BDS.link]
		cmp	di, 0FFFFh	; -1
		jz	short got_end_of_bds_chain
		jmp	_next_bds
; ---------------------------------------------------------------------------

got_end_of_bds_chain:			; ...
		retn
setdrvparms	endp


; =============== S U B	R O U T	I N E =======================================


print_init	proc near		; ...
		cbw
		mov	dx, ax
		mov	ah, 1
		int	17h		; PRINTER - INITIALIZE
					; DX = printer port (0-3)
					; Return: AH = status
		retn
print_init	endp


; =============== S U B	R O U T	I N E =======================================


aux_init	proc near		; ...
		cbw
		mov	dx, ax
		mov	al, 0A3h	; RSINIT ; 0A3h
					; 2400,n,1,8 (msequ.inc)
		mov	ah, 0
		int	14h		; SERIAL I/O - INITIALIZE USART
					; AL = initializing parameters,	DX = port number (0-3)
					; Return: AH = RS-232 status code bits,	AL = modem status bits
		retn
aux_init	endp


; =============== S U B	R O U T	I N E =======================================


domini		proc near		; ...
		mov	dh, hnum	; mini disk initialization routine.
					; called right after dohard
		cmp	dh, 0
		jz	short dominiret	; no hard file?	then exit.
		mov	dl, 80h		; start	with hardfile 80h

domini_loop:				; ...
		push	dx
		mov	rom_minidisk_num, dl
		mov	ah, 8
		int	13h		; DISK - DISK -	GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)
					; DL = drive number
					; Return: CF set on error, AH =	status code, BL	= drive	type
					; DL = number of consecutive drives
					; DH = maximum value for head number, ES:DI -> drive parameter
		inc	dh
		xor	ax, ax
		mov	al, dh
		mov	mini_hdlim, ax	; # of heads
		and	cl, 3Fh
		mov	al, cl
		mov	mini_seclim, ax	; # of sectors/track
		push	es
		mov	dl, rom_minidisk_num
		call	getboot		; read master boot record into
					; initbootsegment:bootbias
		jb	short domininext
		call	find_mini_partition

domininext:				; ...
		pop	es
		pop	dx
		inc	dl
		dec	dh
		jnz	short domini_loop

dominiret:				; ...
		retn
domini		endp


; =============== S U B	R O U T	I N E =======================================


find_mini_partition proc near		; ...
		add	bx, 1C2h	; tries	to find	every extended partition on a disk
					; bx ->	file system id

fmpnext:				; ...
		cmp	byte ptr es:[bx], 5 ; 5	= extended partition id.
		jz	short fmpgot
		add	bx, 16
		cmp	bx, 402h	; 202h+bootbias
		jnz	short fmpnext
		jmp	short fmpnextfound ; extended partition	not found
; ---------------------------------------------------------------------------

fmpgot:					; ...
		call	dmax_check	; check	for drvmax already 26
		jnb	short fmpnextfound ; done if too many
		mov	di, end_of_bdss	; get next free	bds
		mov	word ptr [di+47h], 1 ; [di+BDS.bdsm_ismini]
		or	word ptr [di+23h], 1 ; [di+BDS.flags]
					; fNon_Removable
		mov	byte ptr [di+22h], 5 ; [di+BDS.formfactor]
					; ffHardFile
		mov	fbigfat, 0	; assume 12 bit	fat.
		mov	ax, mini_hdlim
		mov	[di+15h], ax	; [di+BDS.heads]
		mov	ax, mini_seclim
		mov	[di+13h], ax	; [di+BDS.secpertrack]
		mov	al, rom_minidisk_num
		mov	[di+4],	al	; [di+BDS.drivenum]
					; set physical number
		mov	al, drvmax
		mov	[di+5],	al	; [di+BDS.drivelet]
					; set logical number
		cmp	word ptr es:[bx+10], 0
		ja	short fmpgot_cont
		cmp	word ptr es:[bx+8], 64 ; with current bpb,
					; only lower word is meaningful.
		jb	short fmpnextfound

fmpgot_cont:				; ...
		sub	bx, 4		; let bx point to the start of the entry
		mov	dh, es:[bx+2]	; cylinder
		and	dh, 0C0h	; get higher bits of cyl
		rol	dh, 1
		rol	dh, 1
		mov	dl, es:[bx+3]	; cyl byte
		mov	[di+49h], dx	; [di+BDS.bdsm_hidden_trks]
					; set hidden trks
		mov	cx, es:[bx+2]	; cylinder,cylinder/sector
		mov	dh, es:[bx+1]	; head
		mov	dl, rom_minidisk_num
		mov	bx, 200h	; bootbias
		mov	ax, 201h
		int	13h		; DISK - READ SECTORS INTO MEMORY
					; AL = number of sectors to read, CH = track, CL = sector
					; DH = head, DL	= drive, ES:BX -> buffer to fill
					; Return: CF set on error, AH =	status,	AL = number of sectors read
		jb	short fmpnextfound
		mov	bx, 3C2h	; 1C2h+bootbias
		push	es
		call	setmini		; install a mini disk.
					; bx value saved.
		pop	es
		jb	short fmpnextchain
		call	xinstall_bds

fmpnextchain:				; ...
		jmp	fmpnext		; let's find out
					; if we	have any chained partition
; ---------------------------------------------------------------------------

fmpnextfound:				; ...
		retn
find_mini_partition endp


; =============== S U B	R O U T	I N E =======================================


setmini		proc near		; ...
		push	di		; 'setmini' is called
					; from 'find_mini_partition' procedure
		push	bx
		push	ds
		push	es

setmini_1:				; ...
		cmp	byte ptr es:[bx], 1 ; FAT12 partition
		jz	short setmini_2
		cmp	byte ptr es:[bx], 4 ; FAT16 partition
		jz	short setmini_2
		cmp	byte ptr es:[bx], 6 ; FAT16 BIG	partition
		jz	short setmini_2
		add	bx, 16
		cmp	bx, 402h	; 202h+bootbias
		jnz	short setmini_1
		stc
		pop	es
		pop	ds
		assume ds:nothing
		pop	bx
		pop	di
		retn
; ---------------------------------------------------------------------------

setmini_2:				; ...
		jmp	set2
setmini		endp


; =============== S U B	R O U T	I N E =======================================


dmax_check	proc near		; ...
		cmp	ds:drvmax, 26	; checks for drvmax < 26
		jb	short dmax_ok	; return with carry if okay
		push	es
		mov	ax, 46Dh	; SYSINIT_SEG (SYSINIT segment)
		mov	es, ax
		assume es:nothing
		mov	byte ptr es:3FFh, 1 ; [es:toomanydrivesflag]
					; set message flag
					; [SYSINIT+toomanydrivesflag]
		pop	es
		assume es:nothing

dmax_ok:				; ...
		retn
dmax_check	endp


; =============== S U B	R O U T	I N E =======================================


xinstall_bds	proc near		; ...
		push	si		; link next bds	(at ds:di) into	the chain
		push	bx
		mov	si, word ptr ds:start_bds ; get	first bds

xinstall_bds_1:				; ...
		cmp	word ptr [si], 0FFFFh ;	is this	the last one?
		jz	short xinstall_bds_2 ;	skip ahead if so
		mov	si, [si]	; [si+BDS.link]
					; chain	through	list
		jmp	short xinstall_bds_1
; ---------------------------------------------------------------------------

xinstall_bds_2:				; ...
		mov	[si], di	; [si+BDS.link]
		mov	word ptr [si+2], ds ; [si+BDS.link+2]
		mov	word ptr [di], 0FFFFh ;	mov word [di+BDS.link],	-1
					; make sure it is a null ptr.
		mov	word ptr [di+2], ds ; [di+BDS.link+2]
					; might	as well	plug segment
		lea	bx, [di+6]	; [di+BDS.BPB]
		mov	si, ds:last_dskdrv_table
		mov	[si], bx
		add	ds:last_dskdrv_table, 2
		inc	ds:drvmax
		add	ds:end_of_bdss,	100 ; BDS.size = 100
		pop	bx
		pop	si
		retn
xinstall_bds	endp


; =============== S U B	R O U T	I N E =======================================


cmos_clock_read	proc near		; ...
		push	ax
		push	cx
		push	dx
		push	bp
		xor	bp, bp

loop_clock:				; ...
		xor	cx, cx
		xor	dx, dx
		mov	ah, 2
		int	1Ah		; CLOCK	- READ REAL TIME CLOCK (AT,XT286,CONV,PS)
					; Return: CH = hours in	BCD
					; CL = minutes in BCD
					; DH = seconds in BCD
		cmp	cx, 0
		jnz	short clock_present
		cmp	dx, 0
		jnz	short clock_present
		cmp	bp, 1		; read again after a slight delay, in case clock
		jz	short no_readdate ; was	at zero	setting.
		inc	bp		; only perform delay once.
		mov	cx, 4000h	; 16384

delay:					; ...
		loop	delay
		jmp	short loop_clock
; ---------------------------------------------------------------------------

clock_present:				; ...
		mov	cs:havecmosclock, 1 ; set the flag for cmos clock
		call	cmosck		; reset	cmos clock rate	that may be
					; possibly destroyed by	cp dos and
					; post routine did not restore that.
		push	si
		call	read_real_date	; read real-time clock for date
		cli
		mov	ds:daycnt, si	; set system date
		sti
		pop	si

no_readdate:				; ...
		pop	bp
		pop	dx
		pop	cx
		pop	ax
		retn
cmos_clock_read	endp

; ---------------------------------------------------------------------------

cmosck:					; ...
		push	ax
		cmp	cs:model_byte, 0FCh
		jnz	short cmosck9	; Exit if not an AT model
		cmp	cs:secondary_model_byte, 6 ; Is	it 06 for the industral	AT ?
		jz	short cmosck4	; Go reset CMOS	periodic rate if 06
		cmp	cs:secondary_model_byte, 4 ; Is	it 00, 01, 02, or 03 ?
		jnb	short cmosck9

cmosck4:				; ...
		mov	al, 8Ah		; cmos_reg_a|nmi
					; NMI disabled on return
		mov	ah, 26h		; 00100110b
					; Set divider &	rate selection
		call	cmos_write
		mov	al, 8Bh		; cmos_reg_b|nmi
					; NMI disabled on return
		call	cmos_read
		and	al, 7		; 00000111b
					; clear	SET,PIE,AIE,UIE,SQWE
		mov	ah, al
		mov	al, 0Bh		; cmos_reg_b
					; NMI enabled on return
		call	cmos_write

cmosck9:				; ...
		pop	ax
		retn

; =============== S U B	R O U T	I N E =======================================


cmos_read	proc near		; ...
		pushf
		cli
		push	bx
		push	ax		; AL = cmos table address to be	read
		or	al, 80h
		out	70h, al		; CMOS Memory/RTC Index	Register:
					; RTC Seconds
		nop			; (undocumented	delay needed)
		in	al, 71h		; CMOS Memory/RTC Data Register
		mov	bx, ax
		pop	ax
		and	al, 80h
		or	al, 0Fh
		out	70h, al		; CMOS Memory/RTC Index	Register:
					; RTC Seconds
		nop
		in	al, 71h		; CMOS Memory/RTC Data Register
		mov	ax, bx
		pop	bx
		push	cs		; *place code segment in stack and
		call	cmos_popf	; *handle popf for b- level 80286
		retn
cmos_read	endp

; ---------------------------------------------------------------------------

cmos_popf:				; ...
		iret			; popf for level b- parts
					; return far and restore flags

; =============== S U B	R O U T	I N E =======================================


cmos_write	proc near		; ...
		pushf
		push	ax
		cli
		push	ax		; save user nmi	state
		or	al, 80h		; disable nmi for us
		out	70h, al		; CMOS Memory/RTC Index	Register:
					; RTC Seconds
		nop
		mov	al, ah
		out	71h, al		; CMOS Memory/RTC Data Register
		pop	ax		; get user nmi
		and	al, 80h
		or	al, 0Fh
		out	70h, al		; CMOS Memory/RTC Index	Register:
					; RTC Seconds
		nop
		in	al, 71h		; CMOS Memory/RTC Data Register
		pop	ax
		push	cs		; *place code segment in stack and
		call	cmos_popf	; *handle popf for b- level 80286
		retn
cmos_write	endp

; ---------------------------------------------------------------------------

getclus:				; ...
		push	cx		; read in a cluster at a specified address
					; cx = sectors per cluster
					; bx = cluster to read
					; es:di	= load location
		push	di
		mov	cs:doscnt, cx
		mov	ax, bx
		dec	ax
		dec	ax
		mul	cx		; convert to logical sector
					; dx:ax	= matching logical sector number starting
					;	  from the data	sector
		add	ax, cs:bios_l
		adc	dx, cs:bios_h	;
					; dx:ax	= first	logical	sector to read

unpack:					; ...
		push	ds
		push	ax
		push	bx
		mov	si, cs:fatloc
		mov	ds, si
		mov	si, bx		; next cluster
		test	cs:fbigfat, 40h	; fbig
					; 16 bit fat?
		jnz	short unpack16	; yes
		shr	si, 1		; 12 bit fat. si=si/2
					; si = clus + clus/2
		add	si, bx		;
					; (si =	byte offset of the cluster in the FAT)
		push	dx
		xor	dx, dx
		call	get_fat_sector
		pop	dx
		mov	ax, [bx]	; save it into ax
					; if not a splitted fat, check even-odd.
		jnz	short even_odd
		mov	al, [bx]	; splitted fat
		mov	byte ptr cs:temp_cluster, al
		inc	si		; (next	byte)
		push	dx
		xor	dx, dx
		call	get_fat_sector
		pop	dx
		mov	al, ds:0
		mov	byte ptr cs:temp_cluster+1, al
		mov	ax, cs:temp_cluster

even_odd:				; ...
		pop	bx		; restore old fat entry	value
		push	bx		; save it right	away.
		shr	bx, 1		; was it even or odd?
		jnb	short havclus	; it was even.
		shr	ax, 1		; odd. massage fat value and keep
					; the highest 12 bits.
		shr	ax, 1
		shr	ax, 1
		shr	ax, 1

havclus:				; ...
		mov	bx, ax		; now bx = new fat entry.
		and	bx, 0FFFh	; keep low 12 bits.
		jmp	short unpackx
; ---------------------------------------------------------------------------

unpack16:				; ...
		push	dx
		xor	dx, dx
		shl	si, 1		; extend to 32 bit offset
		adc	dx, 0
		call	get_fat_sector
		pop	dx
		mov	bx, [bx]	;
					; bx = new fat entry.
; START	OF FUNCTION CHUNK FOR getclus

unpackx:				; ...
		pop	si		; restore old bx value into si
		pop	ax		; restore logical sector (low)
		pop	ds
		sub	si, bx
		cmp	si, -1		; one apart?
		jnz	short getcl2
		add	cs:doscnt, cx
		jmp	short unpack
; ---------------------------------------------------------------------------

getcl2:					; ...
		push	bx
		push	dx		; sector to read (high)
		push	ax		; sector to read (low)
		mov	ax, cs:drvfat	; get drive and	fat spec
		mov	cx, cs:doscnt
		pop	dx		; sector to read for diskrd (low)
		pop	cs:start_sec_h	; sector to read for diskrd (high)
		push	ds
		push	cs
		pop	ds
		assume ds:DOSBIOS
		push	cs		; simulate far call
		mov	bp, 8E5h	; offset diskrd
					; 2C7h:8E5h = 70h:2E55h
		call	call_bios_code
		pop	ds
		assume ds:nothing
		pop	bx
		pop	di
		mov	ax, cs:doscnt	; get number of	sectors	read
		xchg	ah, al		; multiply by 256
		shl	ax, 1		; times	2 equal	512
		add	di, ax		; update load location
		pop	cx		; restore sectors/cluster
		retn
; END OF FUNCTION CHUNK	FOR getclus

; =============== S U B	R O U T	I N E =======================================


get_fat_sector	proc near		; ...
		push	ax		; find and read	the corresponding fat sector into ds:0
		push	cx
		push	di
		push	si
		push	es
		push	ds
		mov	ax, si
		mov	cx, cs:md_sectorsize ; 512
		div	cx		; ax=sector number, dx = offset
		nop			;
					; Get rid of the assumption that
					; there	is only	one reserved sector
		push	es
		push	ds
		push	di
		push	ax
		push	cs
		pop	ds
		assume ds:DOSBIOS
		mov	ax, cs:drvfat	; get drive # and FAT id
		mov	bp, 4D7h	; setdrive
					; at 2C7h:4D7h = 70h:2A47h
		push	cs		; simulate far call
		call	call_bios_code	; get bds for drive
		pop	ax		; (sector number -without reserved and hidden sectors-)
		add	ax, es:[di+9]	; [es:di+BDS.resectors]
					; add #reserved_sectors
		pop	di
		pop	ds
		assume ds:nothing
		pop	es
		cmp	ax, cs:last_fat_sec_num
		jz	short gfs_split_chk ; don't need to read it again.
		mov	cs:last_fat_sec_num, ax	; sector number	(in the	partition, without hidden sectors)
		push	dx
		mov	cs:start_sec_h,	0 ; prepare to read the	fat sector
					; start_sec_h is always	0 for fat sector.
		mov	dx, ax
		mov	cx, 1		; 1 sector read
		mov	ax, cs:drvfat
		push	ds
		pop	es
		xor	di, di		; es:di	-> fatloc segment:0
		push	ds
		push	cs
		pop	ds
		assume ds:DOSBIOS
		push	cs		; simulate far call
		mov	bp, 8E5h	; offset diskrd
					; 2C7h:8E5h = 70h:2E55h
		call	call_bios_code
		pop	ds
		assume ds:nothing
		pop	dx
		mov	cx, cs:md_sectorsize ; 512

gfs_split_chk:				; ...
		dec	cx		; 511
		cmp	dx, cx		; if offset points to the
					; last byte of this sector,
					; then splitted	entry.
		mov	bx, dx		; set bx to dx
		pop	ds
		pop	es
		pop	si
		pop	di
		pop	cx
		pop	ax
		retn
get_fat_sector	endp

; ---------------------------------------------------------------------------
		db 4 dup(0)
DOSBIOSEG_27Ch	db 30h dup(0)		; SEGMENT 2C7h (2C70h-700h=2570h)
BiosDataWord	dw 70h
; ---------------------------------------------------------------------------

_seg_reinit:				; [cs:BiosDataWord]
		mov	es, word ptr cs:aCon+3 ; at 2C7h:30h or	70h:25A0h
		assume es:nothing
		mov	di, (offset cdev+2)
		mov	cx, 4		; (end_BC_entries - cdev)/4

_seg_reinit_1:				; ...
		stosw			; modify Bios_Code entry points
		inc	di
		inc	di
		loop	_seg_reinit_1
		retf
; ---------------------------------------------------------------------------

chardev_entry:				; 0070h:25B3h =	02C7h:0043h
		push	si
		push	ax
		push	cx
		push	dx
		push	di
		push	bp
		push	ds
		push	es
		push	bx
		mov	bp, sp
		mov	si, [bp+18]	; get return address (dispatch table)
		mov	ds, word ptr cs:aCon+3 ; [cs:Bios_Data_Word]
		assume ds:nothing
		mov	ax, [si+2]	; get the device number	if present
		mov	byte ptr ds:auxnum, al
		mov	ds:printdev, ah
		mov	si, [si]	; point	to the device dispatch table
		les	bx, ds:ptrsav	; get pointer to i/o packet
		assume es:nothing
		mov	al, es:[bx+1]	; [es:bx+unit]	; al = unit code
		mov	ah, es:[bx+13]	; [es:bx+media]	; ah = media descrip
		mov	cx, es:[bx+18]	; [es:bx+count]	; cx = count
		mov	dx, es:[bx+20]	; [es:bx+start]	; dx = start sector
		cmp	si, 4A2h	; dsktbl
					; at 2C7h:4A2h = 70h:2A12h
		jnz	short no_sector32_mapping
		mov	ds:start_sec_h,	0 ; initialize to 0
		cmp	dx, 0FFFFh
		jnz	short no_sector32_mapping
		mov	dx, es:[bx+28]	; [es:bx+start_h]
					; 32 bits dsk req
		mov	ds:start_sec_h,	dx ; start_sec_h = packet.start_h
		mov	dx, es:[bx+26]	; [es:bx+start_l]
					; dx = packet.start_l

no_sector32_mapping:			; ...
		xchg	ax, di
		mov	al, es:[bx+2]	; [es:bx+cmd]
		cmp	al, cs:[si]
		jnb	short command_error
		cbw			; note that al <= 15 means ok
		shl	ax, 1
		add	si, ax
		xchg	ax, di
		les	di, es:[bx+14]	; [es:bx+trans]
		cld
		call	word ptr cs:[si+1]
		jb	short already_got_ah_status
		mov	ah, 1

already_got_ah_status:			; ...
		mov	ds, word ptr cs:aCon+3 ; [cs:Bios_Data_Word]
					; cas note: shouldn't be needed!
		lds	bx, ds:ptrsav
		assume ds:nothing
		mov	[bx+3],	ax	; [bx+status]
					; mark operation complete
		pop	bx
		pop	es
		pop	ds
		pop	bp
		pop	di
		pop	dx
		pop	cx
		pop	ax
		pop	si
		add	sp, 2		; get rid of fake return address

bc_retf:
		retf
; ---------------------------------------------------------------------------

command_error:				; ...
		call	bc_cmderr
		jmp	short already_got_ah_status
; ---------------------------------------------------------------------------
		db 7 dup(0)
; ---------------------------------------------------------------------------

bc_cmderr:				; ...
		mov	al, 3		; 2C7h:D5h = 70h:2645h
					; unknown command error

; =============== S U B	R O U T	I N E =======================================


bc_err_cnt	proc near		; ...
		les	bx, ds:ptrsav
		sub	es:[bx+18], cx	; [es:bx+count]
		mov	ah, 81h
		stc
		retn
bc_err_cnt	endp

; ---------------------------------------------------------------------------
		db 0
con_table	db 11			; 2C7h:0E4h = 70h:2654h
					; (((offset con_table_end) - (offset con_table)	- 1)/2)
		dw 1FBh			; bc_exvec at 2C7h:1FBh	= 70h:276Bh
					; 00 init
		dw 1FBh			; 01
		dw 1FBh			; 02
		dw 0D5h			; bc_exvec at 2C7h:D5h = 70h:2645h
					; 03
		dw 15Ch			; con_read at 2C7h:15Ch	= 70h:26CCh
					; 04
		dw 19Fh			; con_rdnd at 2C7h:19Fh	= 70h:270Fh
					; 05
		dw 1FBh			; 06
		dw 209h			; con_flush at 2C7h:209h = 70h:2779h
					; 07
		dw 1FDh			; con_writ at 2C7h:1FDh	= 70h:276Dh
					; 08
		dw 1FDh			; 09
		dw 1FBh			; 0A
prn_table	db 26			; 2C7h:0FBh = 70h:266Bh
					; ((prn_table_end - prn_table) - 1)/2 ;	26
		dw 1FBh			; bc_exvec
		dw 1FBh			; 01
		dw 1FBh			; 02
		dw 0D5h			; bc_cmderr
		dw 21Ah			; prn_input
					; 04 indicate zero chars read
		dw 1C8h			; z_bus_exit
					; 05 read non-destructive
		dw 1FBh			; 06
		dw 1FBh			; 07
		dw 21Fh			; prn_writ
		dw 21Fh			; 09
		dw 251h			; prn_stat
		dw 1FBh			; 0B
		dw 1FBh			; 0C
		dw 1FBh			; 0D
		dw 1FBh			; 0E
		dw 1FBh			; 0F
		dw 28Bh			; prn_tilbusy
		dw 1FBh			; 11
		dw 1FBh			; 12
		dw 2BAh			; prn_genioctl
		dw 1FBh			; 14
		dw 1FBh			; 15
		dw 1FBh			; 16
		dw 1FBh			; 17
		dw 1FBh			; 18
		dw 2F0h			; prn_ioctl_query
aux_table	db 11			; 2C7h:130h = 70h:26A0h
					; ((aux_table_end - aux_table) - 1)/2 ;	11
		dw 1FBh			; 00 - init
		dw 1FBh			; 01
		dw 1FBh			; 02
		dw 0D5h			; 03
		dw 30Dh			; aux_read ; 04	- read
		dw 335h			; aux_rdnd - 05	- read non-destructive
		dw 1FBh			; 06
		dw 36Ch			; aux_flsh
		dw 374h			; aux_writ
		dw 374h			; 09
		dw 355h			; aux_wrst
tim_table	db 10			; 2C7h:147h = 70h:26B7h
					; ((tim_table_end - tim_table) - 1)/2 ;	10
		dw 1FBh			; 00
		dw 1FBh			; 01
		dw 1FBh			; 02
		dw 0D5h			; 03
		dw 435h			; tim_read
		dw 1C8h			; z_bus_exit
		dw 1FBh			; 06
		dw 1FBh			; 07
		dw 3DBh			; tim_writ
		dw 3DBh			; 09
; ---------------------------------------------------------------------------

con_read:				; 2C7h:15Ch = 70h:26CCh
		jcxz	short con_exit	; read cx bytes	from keyboard into buffer

con_loop:				; ...
		call	chrin		; get char in al
		stosb			; store	char at	es:di
		loop	con_loop

con_exit:				; ...
		clc
		retn

; =============== S U B	R O U T	I N E =======================================


chrin		proc near		; ...
		mov	ah, ds:keyrd_func ; set	by msinit. 0 or	10h
		xor	al, al
		xchg	al, ds:altah	; get character	& zero altah
		or	al, al
		jnz	short keyret
		int	16h		; KEYBOARD -
		or	ax, ax
		jz	short chrin
		cmp	ax, 7200h	; check	for ctrl-prtsc
		jnz	short alt_ext_chk
		mov	al, 10h
		jmp	short keyret
; ---------------------------------------------------------------------------

alt_ext_chk:				; ...
		cmp	ds:keyrd_func, 0
		jz	short not_ext
		cmp	al, 0E0h
		jnz	short not_ext
		or	ah, ah
		jz	short keyret
		xor	al, al
		jmp	short alt_save
; ---------------------------------------------------------------------------

not_ext:				; ...
		or	al, al		; special case?
		jnz	short keyret

alt_save:				; ...
		mov	ds:altah, ah	; store	special	key

keyret:					; ...
		retn
chrin		endp

; ---------------------------------------------------------------------------

con_rdnd:				; ...
		mov	al, ds:altah
		or	al, al
		jnz	short rdexit
		mov	ah, ds:keysts_func
		int	16h		; KEYBOARD -
		jnz	short gotchr
		cmp	ds:fhavek09, 0
		jz	short z_bus_exit
		les	bx, ds:ptrsav
		test	word ptr es:[bx+3], 400h ; [es:bx+status]
		jz	short z_bus_exit
		mov	ax, 4100h
		xor	bl, bl
		int	15h		; SYSTEM - WAIT	ON EXTERNAL EVENT (CONVERTIBLE)
					; AL = condition type, BH = condition compare or mask value
					; BL = timeout value times 55 milliseconds, 00h	means no timeout
					; DX = I/O port	address	if AL bit 4 set

z_bus_exit:				; ...
		stc			; 2C7h:1C8h = 70h:2738h
		mov	ah, 3		; indicate busy	status
		retn
; ---------------------------------------------------------------------------

gotchr:					; ...
		or	ax, ax
		jnz	short notbrk	; check	for null after break
		mov	ah, ds:keyrd_func ; issue keyboard read	function
		int	16h		; KEYBOARD -
		jmp	short con_rdnd	; get a	real status
; ---------------------------------------------------------------------------

notbrk:					; ...
		cmp	ax, 7200h	; check	for ctrl-prtsc
		jnz	short rd_ext_chk
		mov	al, 10h		; ('P' & 1Fh) ; return control p
		jmp	short rdexit
; ---------------------------------------------------------------------------

rd_ext_chk:				; ...
		cmp	ds:keyrd_func, 0 ; extended keyboard function?
		jz	short rdexit
		cmp	al, 0E0h	; extended key value or	greek alpha?
		jnz	short rdexit
		cmp	ah, 0		; scan code exist?
		jz	short rdexit	; yes. greek alpha char.
		mov	al, 0		; no. extended key stroke.
					; change it for	compatibility

rdexit:					; ...
		les	bx, ds:ptrsav
		mov	es:[bx+13], al	; [es:bx+media]
					; return keyboard character here

bc_exvec:				; ...
		clc			; bc_exvec at 2C7h:1FBh	= 70h:276Bh
					; indicate normal termination
		retn
; ---------------------------------------------------------------------------

con_writ:
		jcxz	short bc_exvec

con_lp:					; ...
		mov	al, es:[di]
		inc	di
		int	29h		; DOS 2+ internal - FAST PUTCHAR
					; AL = character to display
		loop	con_lp
; START	OF FUNCTION CHUNK FOR con_flush

cc_ret:					; ...
		clc
		retn
; END OF FUNCTION CHUNK	FOR con_flush

; =============== S U B	R O U T	I N E =======================================


con_flush	proc near		; ...

; FUNCTION CHUNK AT 2777 SIZE 00000002 BYTES

		mov	ds:altah, 0	; clear	out holding buffer
					; while	(charavail()) charread();

flloop:					; ...
		mov	ah, 1
		int	16h		; KEYBOARD - CHECK BUFFER, DO NOT CLEAR
					; Return: ZF clear if character	in buffer
					; AH = scan code, AL = character
					; ZF set if no character in buffer
		jz	short cc_ret
		xor	ah, ah
		int	16h		; KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY
					; Return: AH = scan code, AL = character
		jmp	short flloop
con_flush	endp

; ---------------------------------------------------------------------------

prn_input:				; 2C7h:21Ah = 70h:278Ah
		call	bc_err_cnt	; reset	count to zero
					; (sub reqpkt.count,cx)
		clc			; but return with carry	reset for no error
		retn
; ---------------------------------------------------------------------------

prn_writ:				; 2C7h:21Fh = 70h:278Fh
		jcxz	short prn_done	; no chars to output

prn_loop:				; ...
		mov	bx, 2		; retry	count

prn_out:				; ...
		call	prnstat		; get status
		jnz	short TestPrnError
		mov	al, es:[di]	; get character	to print
		xor	ah, ah
		call	prnop		; print	to printer
		jz	short prn_con	; no error - continue
		cmp	ah, 0FFh	; MODE_CTRLBRK
		jnz	short _prnwf
		mov	al, 0Ch		; error_I24_gen_failure
		mov	ds:altah, 0
		jmp	short pmessg
; ---------------------------------------------------------------------------

_prnwf:					; ...
		test	ah, 1		; timeoutstatus
		jz	short prn_con

TestPrnError:				; ...
		dec	bx		; retry	until count is exhausted.
		jnz	short prn_out

pmessg:					; ...
		jmp	bc_err_cnt
; ---------------------------------------------------------------------------

prn_con:				; ...
		inc	di		; point	to next	char and continue
		loop	prn_loop

prn_done:				; ...
		clc
		retn
; ---------------------------------------------------------------------------

prn_stat:				; 2C7h:251h = 70h:27C1h
		call	prnstat		; device in dx
		jnz	short pmessg
		test	ah, 80h		; notbusystatus
		jnz	short prn_done
		jmp	z_bus_exit
; ---------------------------------------------------------------------------

prnstat:				; ...
		mov	ah, 2		; set command for get status

; =============== S U B	R O U T	I N E =======================================


prnop		proc near		; ...
		mov	dx, ds:auxnum	; get printer number
		int	17h		; PRINTER - GET	STATUS
					; DX = printer port (0-3)
					; Return: AH = status
		push	ax
		and	ah, 30h
		cmp	ah, 30h		; noprinter
		pop	ax
		jnz	short NextTest
		and	ah, 0DFh	; ~nopaperstatus
		or	ah, 8		; ioerrstatus

NextTest:				; ...
		test	ah, 28h		; (ioerrstatus+nopaperstatus)
					; i/o error?
		jz	short checknotready ; no, try not ready
		mov	al, 9		; error_I24_out_of_paper
					; first, assume	out of paper
		test	ah, 20h		; out of paper set?
		jnz	short ret1	; yes, error is	set
		inc	al		; return al=10 (i/o error)

ret1:					; ...
		retn
; ---------------------------------------------------------------------------

checknotready:				; ...
		mov	al, 2		; assume not-ready
		test	ah, 1
		retn
prnop		endp

; ---------------------------------------------------------------------------

prn_tilbusy:				; 2C7h:28Bh = 70h:27FBh
		mov	si, di		; everything is	set for	lodsb

prn_tilbloop:				; ...
		push	cx
		push	bx
		xor	bh, bh
		mov	bl, ds:printdev
		shl	bx, 1
		mov	cx, ds:wait_count[bx] ;	wait count times to come ready
		pop	bx

prn_getstat:				; ...
		call	prnstat		; get status
		jnz	short prn_bperr	; error
		test	ah, 80h		; ready	yet?
		loope	prn_getstat	; no, go for more
		pop	cx		; get original count
		jz	short prn_berr	; still	not ready => done
		lods	byte ptr es:[si] ; es
					; lodsb
		xor	ah, ah
		call	prnop
		jnz	short prn_berr	; error
		loop	prn_tilbloop
		clc
		retn
; ---------------------------------------------------------------------------

prn_bperr:				; ...
		pop	cx		; restore transfer count from stack

prn_berr:				; ...
		jmp	bc_err_cnt
; ---------------------------------------------------------------------------

prn_genioctl:				; 2C7h:2BAh = 70h:282Ah
		les	di, ds:ptrsav
		cmp	byte ptr es:[di+13], 5 ; [es:di+IOCTL_REQ.MAJORFUNCTION]
					; ioc_pc
		jz	short prnfunc_ok

prnfuncerr:				; ...
		jmp	bc_cmderr
; ---------------------------------------------------------------------------

prnfunc_ok:				; ...
		mov	al, es:[di+14]	; [es:di+IOCTL_REQ.MINORFUNCTION]
		les	di, es:[di+19]	; [es:di+IOCTL_REQ.GENERICIOCTL_PACKET]
		xor	bh, bh
		mov	bl, ds:printdev	; get index into retry counts
		shl	bx, 1
		mov	cx, ds:wait_count[bx] ;	pull out retry count for device
		cmp	al, 65h		; get_retry_count
		jz	short prngetcount
		cmp	al, 45h		; set_retry_count
		jnz	short prnfuncerr
		mov	cx, es:[di]

prngetcount:				; ...
		mov	ds:wait_count[bx], cx
		mov	es:[di], cx	; [es:di+A_RETRYCOUNT.RC_COUNT]
					; return current retry count
		clc
		retn
; ---------------------------------------------------------------------------

prn_ioctl_query:			; 2C7h:2F0h = 70h:2860h
		les	di, ds:ptrsav
		cmp	byte ptr es:[di+13], 5 ; [es:di+IOCTL_REQ.MAJORFUNCTION]
					; ioc_pc
		jnz	short prn_query_err
		mov	al, es:[di+14]	; [es:di+IOCTL_REQ.MINORFUNCTION]
		cmp	al, 65h		; GET_RETRY_COUNT
		jz	short IOCtlSupported
		cmp	al, 45h		; SET_RETRY_COUNT
		jnz	short prn_query_err

IOCtlSupported:				; ...
		clc
		retn
; ---------------------------------------------------------------------------

prn_query_err:				; ...
		stc
		jmp	bc_cmderr
; ---------------------------------------------------------------------------

aux_read:				; 2C7h:30Dh = 70h:287Dh
		jcxz	short exvec2
		call	getbx		; put address of auxbuf	in bx
		xor	al, al
		xchg	al, [bx]
		or	al, al
		jnz	short aux2

aux1:					; ...
		call	auxin		; get character	from port
					; won't return if error

aux2:					; ...
		stosb
		loop	aux1		; if more characters, go around	again

exvec2:					; ...
		clc			; all done, successful exit
		retn
; ---------------------------------------------------------------------------

auxin:					; ...
		mov	ah, 2		; auxfunc_receive
		call	auxop
		test	ah, 0Eh		; flag_frame|flag_parity|flag_overrun
		jnz	short arbad	; skip if any error bits set
		retn
; ---------------------------------------------------------------------------

arbad:					; ...
		pop	ax		; remove return	address	(near call)
		xor	al, al
		or	al, 0B0h	; flag_rec_sig|	flag_dsr|flag_cts
		jmp	bc_err_cnt
; ---------------------------------------------------------------------------

aux_rdnd:				; 2C7h:335h = 70h:28A5h
		call	getbx
		mov	al, [bx]	; have bx point	to auxbuf
		or	al, al		; if al	is non-zero (char in buffer)
		jnz	short auxdrx	; then return character
		call	auxstat		; if not, get status of	aux device
		test	ah, 1		; flag_data_ready - test data ready
		jz	short auxbus	; then device is busy (not ready)
		test	al, 20h		; flag_dsr - test data set ready
		jz	short auxbus	; then device is busy (not ready)
		call	auxin		; else aux is ready, get character
		mov	[bx], al

auxdrx:					; ...
		jmp	rdexit		; return busy status
; ---------------------------------------------------------------------------

auxbus:					; ...
		jmp	z_bus_exit
; ---------------------------------------------------------------------------

aux_wrst:				; 2C7h:355h = 70h:28C5h
		call	auxstat		; get status of	aux in ax
		test	al, 20h		; test data set	ready
		jz	short auxbus	; then device is busy (not ready)
		test	ah, 20h		; flag_tranhol_emp - test transmit hold	reg empty
		jz	short auxbus	; then device is busy (not ready)
		clc
		retn
; ---------------------------------------------------------------------------

auxstat:				; ...
		mov	ah, 3		; auxfunc_status

; =============== S U B	R O U T	I N E =======================================


auxop		proc near		; ...
		mov	dx, ds:auxnum	; ah=function code
					; 0=init, 1=send, 2=receive, 3=status
					; get port number
		int	14h		; SERIAL I/O - GET USART STATUS
					; DX = port number (0-3)
					; Return: AX = port status code
		retn
auxop		endp

; ---------------------------------------------------------------------------

aux_flsh:				; 2C7h:36Ch = 70h:28DCh
		call	getbx		; flush	aux input buffer
		mov	byte ptr [bx], 0 ; get bx to point to auxbuf
					; zero out buffer
		clc			; all done, successful return
		retn
; ---------------------------------------------------------------------------

aux_writ:				; 2C7h:374h = 70h:28E4h
		jcxz	short exvec2	; write	to aux device (if cx > 0)

aux_loop:				; ...
		mov	al, es:[di]	; get character	to be written
					; move di pointer to next character
		inc	di
		mov	ah, 1		; auxfunc_send - indicates a write
		call	auxop		; send character over aux port
		test	ah, 80h		; check	for error
		jz	short awok	; then no error
		mov	al, 10		; else indicate	write fault
		jmp	bc_err_cnt	; call error routines
; ---------------------------------------------------------------------------

awok:					; ...
		loop	aux_loop	; if cx	is non-zero,
					; still	more character to print
		clc			; all done, successful return
		retn

; =============== S U B	R O U T	I N E =======================================


getbx		proc near		; ...
		mov	bx, ds:auxnum	; return bx -> single byte input buffer
					; for selected aux port	([auxnum])
		add	bx, offset auxbuf
		retn
getbx		endp

; ---------------------------------------------------------------------------

time_to_ticks:				; 0070h:2906h =	02C7h:0396h
		mov	al, 60		; convert time to ticks
		mul	ch		; hours	to minutes
		mov	ch, 0
		add	ax, cx		; total	minutes
		mov	cx, 6000	; 60*100
		mov	bx, dx		; get out of the way of	the multiply
		mul	cx		; convert to 1/100 sec
		mov	cx, ax
		mov	al, 100
		mul	bh		; convert seconds to 1/100 sec
		add	cx, ax		; combine seconds with hours and min
		adc	dx, 0		; ripple carry
		mov	bh, 0
		add	cx, bx		; combine 1/100	sec
		adc	dx, 0		; dx:cx	is time	in 1/100 sec
		xchg	ax, dx
		xchg	ax, cx		; now time is in cx:ax
		mov	bx, 59659
		mul	bx		; multiply low half
		xchg	dx, cx
		xchg	ax, dx		; cx->ax, ax->dx, dx->cx
		mul	bx		; multiply high	half
		add	ax, cx		; combine overlapping products
		adc	dx, 0
		xchg	ax, dx		; ax:dx=time*59659
		mov	bx, 5
		div	bl		; divide high half by 5
		mov	cl, al
		mov	ch, 0
		mov	al, ah		; remainder of divide-by-5
		cbw
		xchg	ax, dx		; use it to extend low half
		div	bx		; divide low half by 5
		mov	dx, ax		; cx:dx	is now number of ticks in time
		retf			; far return
; ---------------------------------------------------------------------------

tim_writ:				; 2C7h:3DBh = 70h:294Bh
		mov	ax, es:[di]
		push	ax		; daycnt. we need to set this at the very
					; end to avoid tick windows.
		cmp	ds:havecmosclock, 0
		jz	short no_cmos_1
		mov	al, es:[di+3]	; near indirect	calls
					; get binary hours
					; convert to bcd
		call	ds:bintobcd	; call far [bintobcd]
		mov	ch, al		; ch = bcd hours
		mov	al, es:[di+2]	; get binary minutes
		call	ds:bintobcd	; convert to bcd
		mov	cl, al		; cl = bcd minutes
		mov	al, es:[di+5]	; get binary seconds
		call	ds:bintobcd
		mov	dh, al		; dh = bcd seconds
		mov	dl, 0		; dl = 0 (st) or 1 (dst)
		cli
		mov	ah, 3
		int	1Ah		; CLOCK	- SET REAL TIME	CLOCK (AT,XT286,CONV,PS)
					; CH = hours in	BCD, CL	= minutes in BCD
					;  DH =	seconds	in BCD,DL = 01h	if daylight savings, 00h if standard time
					; Return: CMOS clock set
		sti

no_cmos_1:				; ...
		mov	cx, es:[di+2]
		mov	dx, es:[di+4]
		call	dword ptr ds:ttticks ; call far	[ttticks]
					; convert time to ticks
					; cx:dx	now has	time in	ticks
		cli			; turn off timer
		mov	ah, 1
		int	1Ah		; CLOCK	- SET TIME OF DAY
					; CX:DX	= clock	count
					; Return: time of day set
		pop	ds:daycnt
		sti
		cmp	ds:havecmosclock, 0
		jz	short no_cmos_2
		call	ds:daycnttoday	; call far [daycnttoday]
					; convert to bcd format
		cli
		mov	ah, 5
		int	1Ah		; CLOCK	- SET DATE IN REAL TIME	CLOCK (AT,XT286,CONV,PS)
					; DL = day in BCD, DH =	month in BCD, CL = year	in BCD
					; CH = century (19h or 20h)
					; Return: CMOS clock set
		sti

no_cmos_2:				; ...
		clc
		retn
; ---------------------------------------------------------------------------

tim_read:				; 2C7h:435h = 70h:29A5h
		call	GetTickCnt
		mov	si, ds:daycnt
		mov	ax, cx
		mov	bx, dx		; start	with ticks in cx:dx
					; multiply by 5
		shl	dx, 1
		rcl	cx, 1		; times	2
		shl	dx, 1
		rcl	cx, 1		; times	4
		add	dx, bx
		adc	ax, cx		; times	5
		xchg	ax, dx		; now have ticks * 5 in	dx:ax
					; we now need to multiply by 65,536
					; and divide by	59659 d.
		mov	cx, 59659	; get divisor
		div	cx		; dx now has remainder
					; ax has high word of final quotient
		mov	bx, ax		; put high word	in safe	place
		xor	ax, ax		; this is the multiply by 65536
		div	cx		; bx:ax	now has	time in	100th of seconds
		mov	dx, bx		; rounding based on the	remainder may be added here
					; the result in	bx:ax is time in 1/100 second.
		mov	cx, 200		; division by 200 is necessary to ensure
					; no overflow--max result
					; is number of seconds in a day/2 = 43200.
		div	cx
		cmp	dl, 100		; remainder over 100?
		jb	short noadj
		sub	dl, 100		; keep 1/100's less than 100

noadj:					; ...
		cmc			; if we	subtracted 100,	carry is now set
		mov	bl, dl		; save 1/100's
		rcl	ax, 1		; to compensate	for dividing by	200 instead of 100,
					; we now multiply by two, shifting a one in
					; if the remainder had exceeded	100.
		mov	dl, 0
		rcl	dx, 1
		mov	cx, 60		; divide out seconds
		div	cx
		mov	bh, dl		; save the seconds
		div	cl		; break	into hours and minutes
		xchg	al, ah		; time is now in ax:bx
					; (hours, minutes, seconds, 1/100 sec)
		push	ax
		mov	ax, si		; daycnt
		stosw
		pop	ax
		stosw
		mov	ax, bx
		stosw
		clc
		retn

; =============== S U B	R O U T	I N E =======================================


GetTickCnt	proc near		; ...
		xor	ah, ah
		int	1Ah		; CLOCK	- GET TIME OF DAY
					; Return: CX:DX	= clock	count
					; AL = 00h if clock was	read or	written	(via AH=0,1) since the previous
					; midnight
					; Otherwise, AL	> 0
		cmp	ds:t_switch, 0	; use old method ? (>0 is yes)
		jnz	short inc_case	; old method assumes  that Int 1Ah returns rollover flag
		xor	ah, ah		; new method assumes that Int 1Ah returns roll over count
					; and not flag
		add	ds:daycnt, ax
		retn
; ---------------------------------------------------------------------------

inc_case:				; ...
		or	al, al
		jz	short no_rollover
		inc	ds:daycnt

no_rollover:				; ...
		retn
GetTickCnt	endp

; ---------------------------------------------------------------------------
		db 0
dsktbl		db 26			; 2C7h:4A2h = 70h:2A12h
					; ((dtbl_siz-1)/2) ; this is the size of the table ; 26
		dw 1742h		; dsk_init
		dw 4EBh			; media_chk
		dw 592h			; get_bpb
		dw 0D5h			; bc_cmderr
		dw 857h			; dsk_read
		dw 83Dh			; x_bus_exit
		dw 558h			; ret_carry_clear
		dw 558h			; ret_carry_clear
		dw 849h			; dsk_writ
		dw 841h			; dsk_writv
		dw 558h			; ret_carry_clear
		dw 558h			; ret_carry_clear
		dw 0D5h			; bc_cmderr
		dw 80Ah			; dsk_open
		dw 81Ah			; dsk_close
		dw 831h			; dsk_rem
		dw 558h			; ret_carry_clear
		dw 558h			; ret_carry_clear
		dw 558h			; ret_carry_clear
		dw 0C6Bh		; do_generic_ioctl
		dw 558h			; ret_carry_clear
		dw 558h			; ret_carry_clear
		dw 558h			; ret_carry_clear
		dw 1124h		; ioctl_getown
		dw 1142h		; ioctl_setown
		dw 129Ah		; ioctl_support_query

; =============== S U B	R O U T	I N E =======================================


SetDrive	proc near		; ...
		les	di, ds:start_bds

X_Scan_Loop:				; ...
		cmp	es:[di+5], al	; [es:di+BDS.link] ; Go	to next	bds
		jz	short X_SetDrv
		les	di, es:[di]
		cmp	di, 0FFFFh
		jnz	short X_Scan_Loop
		stc

X_SetDrv:				; ...
		retn
SetDrive	endp

; ---------------------------------------------------------------------------

media_chk:				; 2C7h:4EBh = 70h:2A5Bh
		call	SetDrive
		mov	si, 1
		test	byte ptr es:[di+24h], 1	; [es:di+BDS.flags+1]
					; fchanged_by_format
		jz	short WeAreNotFakingIt
		and	word ptr es:[di+23h], 0FEFFh ; [es:di+BDS.flags]
					; ~fchanged_by_format ;	reset flag
		mov	ds:tim_drv, 0FFh ; Ensure that we ask the rom if media has changed
		test	byte ptr es:[di+23h], 1	; [es:di+BDS.flags]
					; fnon_removable
		jz	short wehaveafloppy
		mov	si, 0FFFFh	; Indicate media changed
		jmp	short Media_Done ; Media_Done
; ---------------------------------------------------------------------------

WeAreNotFakingIt:			; ...
		test	byte ptr es:[di+23h], 1
		jnz	short Media_Done

wehaveafloppy:				; ...
		xor	si, si
		cmp	ds:fhave96, 0	; Do we	have changeline	support?
		jz	short mChk_NoChangeLine	; Brif not
		call	mediacheck	;  Call	into removable routine
		jb	short err_exitj
		call	haschange
		jnz	short Media_Done

mChk_NoChangeLine:			; ...
		mov	si, 1		; Presume no change
		mov	al, ds:tim_drv	; Last drive accessed
		cmp	al, es:[di+4]	; [es:di+BDS.drivenum]
					; Is drive of last access the same?
		jnz	short Media_Unk	; No, then "i don't know"
		call	Check_Time_Of_Access
		jmp	short Media_Done
; ---------------------------------------------------------------------------

Media_Unk:				; ...
		dec	si		; ; Return "I don't know"

Media_Done:				; ...
		push	es
		les	bx, ds:ptrsav
		mov	es:[bx+0Eh], si	; [es:bx+trans]
		pop	es
		or	si, si
		jns	short ret_carry_clear ;	volidok
		cmp	ds:fhave96, 0
		jz	short mChk1_NoChangeLine ; Brif	no changeline support
		call	media_set_vid

mChk1_NoChangeLine:			; ...
		mov	ds:tim_drv, 0FFh ; Make	sure we	ask rom	for media check

ret_carry_clear:			; ...
		clc			; volidok
		retn
; ---------------------------------------------------------------------------

err_exitj:				; ...
		call	maperror	; guaranteed to	set carry

ret81:					; ...
		mov	ah, 81h		; return error status
		retn			; return with carry set

; =============== S U B	R O U T	I N E =======================================


Check_Time_Of_Access proc near		; ...
		mov	si, 1
		call	GetTickCnt	; cx:dx	is the elapsed time
		mov	ax, es:[di+47h]	; [es:di+BDS.tim_lo]
					; get stored time
		sub	dx, ax
		mov	ax, es:[di+49h]	; [es:di+BDS.tim_hi]
		sbb	cx, ax
		jnz	short timecheck_unk ; cx<>0 => >1 hour time must pass
		or	dx, dx
		jnz	short timepassed ; yes,	examine	max value
		inc	ds:accesscount
		cmp	ds:accesscount,	5 ; if count is	less than threshold, ok
		jb	short timecheck_ret
		dec	ds:accesscount	; don't let the count wrap
		jmp	short timecheck_unk ; "i don't know" if media changed
; ---------------------------------------------------------------------------

timepassed:				; ...
		cmp	dx, 36		; 18*2 ; 18.2 tics per second.
					; min elapsed time? (2 seconds)
		jbe	short timecheck_ret ; yes, presume no change

timecheck_unk:				; ...
		dec	si		; presume i don't know

timecheck_ret:				; ...
		retn
Check_Time_Of_Access endp

; ---------------------------------------------------------------------------
		jmp	short err_exitj
; ---------------------------------------------------------------------------

get_bpb:				; 2C7h:592h = 70h:2B02h
		mov	ah, es:[di]	; get fat id byte read by dos
		call	SetDrive	; get the correct bds for the drive
		test	byte ptr es:[di+23h], 1	; [es:di+BDS.flags]
					; fnon_removable
		jnz	short already_gotbpb ; no need to build	for fixed disks
		call	clear_ids
		mov	ds:set_id_flag,	1 ; indicate to	set system id in bds
		call	GetBp		; build	a bpb if necessary
		jb	short ret81
		cmp	ds:set_id_flag,	2 ; already, volume_label set from boot
		mov	ds:set_id_flag,	0 ; record to bds table?
		jz	short already_gotbpb ; do not set it again from	root dir
					; otherwise, conventional boot record
		cmp	ds:fhave96, 0	; do we	have changeline	support?
		jz	short already_gotbpb ; brif not
		call	set_volume_id

already_gotbpb:				; ...
		add	di, 6		; BDS.BPB
					; return the bpb from the current bds

SetPtrSav:				; ...
		mov	cx, es		; return point for dsk_init
					; save es
		les	bx, ds:ptrsav
		mov	es:[bx+0Dh], ah	; [es:bx+media]
		mov	es:[bx+12h], di	; [es:bx+count]
		mov	es:[bx+14h], cx	; [es:bx+count+2]
		clc
		retn

; =============== S U B	R O U T	I N E =======================================


clear_ids	proc near		; ...
		push	di
		xor	cx, cx
		mov	es:[di+57h], cx	; [es:di+BDS.vol_serial]
		mov	es:[di+59h], cx	; [es:di+BDS.vol_serial+2]
		mov	cx, 11		; size_of_EXT_BOOT_VOL_LABEL
		mov	si, offset vol_no_name ; "NO NAME    "
		add	di, 75		; BDS.volid
		rep movsb
		test	byte ptr es:[di+1Fh], 40h
		mov	si, offset fat_16_id ; "FAT16	"
		jnz	short ci_bigfat
		mov	si, offset fat_12_id ; "FAT12	"

ci_bigfat:				; ...
		mov	cx, 8		; size_of_EXT_SYSTEM_ID
		add	di, 5		; (BDS.filesys_id-BDS.volid)-size_of_EXT_BOOT_VOL_LABEL
					; filesys_id field
		rep movsb
		pop	di
		retn
clear_ids	endp


; =============== S U B	R O U T	I N E =======================================


GetBp		proc near		; ...
		test	byte ptr es:[di+23h], 5	; return bpb from the drive specified by the bds
					; [es:di+BDS.flags]
					; return_fake_bpb|fnon_removable
		jz	short getbp1	; getbp1
		jmp	getret_exit
; ---------------------------------------------------------------------------

getbp1:					; ...
		push	cx
		push	dx
		push	bx
		call	readbootsec
		jb	short getbp_err_ret_brdg
		or	bx, bx		; bx is	0 if boot sector is valid.
		jnz	short dofatbpb
		call	movbpb		; move bpb into	registers
		jmp	short Has1
; ---------------------------------------------------------------------------

getbp_err_ret_brdg:			; ...
		jmp	getbp_err_ret
; ---------------------------------------------------------------------------

dofatbpb:				; ...
		call	readfat		; puts media descriptor	byte in	ah
		jb	short getbp_err_ret_brdg
		cmp	ds:fhave96, 0	;  changeline support available?
		jz	short bpb_nochangeline ; brif not
		call	hidensity	; may not return! May add sp, 2	and
					; jump to has1!!!!!! or	has720K

bpb_nochangeline:			; ...
		cmp	byte ptr es:[di+22h], 2	; [es:di+BDS.formfactor]
					; ffSmall
		jnz	short is_floppy
		cmp	ah, 0F9h	; is it	a valid	fat id byte for	3.5" ?
		jnz	short got_unknown_medium

Has720K:				; ...
		mov	bx, offset sm92
		mov	al, [bx+0]	; [bx+bpbtype.spf]
		mov	cx, [bx+3]	; [bx+bpbtype.csec]
		mov	dx, [bx+5]	; [bx+bpbtype.spau]
		mov	bx, [bx+1]	; [bx+bpbtype.spt]
		jmp	short Has1
; ---------------------------------------------------------------------------

is_floppy:				; ...
		cmp	ah, 0F8h	; must be a 5.25" floppy if we come here
					; valid	media??	(0F8h-0FFh)
		jb	short got_unknown_medium
		mov	al, 1		; set number of	fat sectors
		mov	bx, 16392	; 64*256+8
					; set dir entries and sector max
		mov	cx, 320		; 40*8
					; set size of drive
		mov	dx, 257		; 01*256+1
					; set head limit and sec/all unit
		test	ah, 2		; test for 8 or	9 sector
		jnz	short has8	; nz = has 8 sectors
		inc	al		; inc number of	fat sectors
		inc	bl		; inc sector max
		add	cx, 40		; increase size	(to 360)

has8:					; ...
		test	ah, 1		; test for 1 or	2 heads
		jz	short Has1	; jz = 1 head
		add	cx, cx		; double size of disk
		mov	bh, 112		; increase number of directory entries
		inc	dh		; inc sec/all unit
		inc	dl		; inc head limit

Has1:					; ...
		mov	es:[di+8], dh	; [es:di+BDS.secperclus]
		mov	es:[di+0Ch], bh	; [es:di+BDS.direntries]
		mov	es:[di+0Eh], cx	; [es:di+BDS.totalsecs16]
		mov	es:[di+10h], ah	; [es:di+BDS.media]
		mov	es:[di+11h], al	; [es:di+BDS.fatsecs]
		mov	es:[di+13h], bl	; [es:di+BDS.secpertrack]
		mov	es:[di+15h], dl	; [es:di+BDS.heads]
		mov	word ptr es:[di+19h], 0	; [es:di+BDS.hiddensecs+2]
		mov	word ptr es:[di+17h], 0	; [es:di+BDS.hiddensecs]
		mov	word ptr es:[di+1Dh], 0	; [es:di+BDS.totalsecs32+2]

getret:					; ...
		pop	bx
		pop	dx
		pop	cx

getret_exit:				; ...
		retn
; ---------------------------------------------------------------------------

getbp_err_ret:				; ...
		mov	ds:set_id_flag,	0 ; before doing anything else,	set set_id_flag	to 0.
		call	maperror
		jmp	short getret
; ---------------------------------------------------------------------------

got_unknown_medium:			; ...
		mov	ds:set_id_flag,	0 ; we have a 3.5" diskette for	which we cannot	build a	bpb.
					; we do	not assume any type of bpb for this medium.
		mov	al, 7
		stc
		jmp	short getret
GetBp		endp


; =============== S U B	R O U T	I N E =======================================


readbootsec	proc near		; ...
		mov	dh, 0		; read in the boot sector. set carry if	error in reading sector.
					; bx is	set to 1 if the	boot sector is invalid,	otherwise it is	0.
		mov	cx, 1		; head 0
					; cylinder 0, sector 1
		call	read_sector
		jb	short err_ret
		xor	bx, bx		; assume valid boot sector
		cmp	ds:disksector, 69h ; is	it a direct jump?
		jz	short check_bpb_mediabyte ; don't need to find a nop
		cmp	ds:disksector, 0E9h ; dos 2.0 jump?
		jz	short check_bpb_mediabyte ; no need for	nop
		cmp	ds:disksector, 0EBh ; how about	a short	jump?
		jnz	short invalidbootsec
		cmp	ds:disksector+2, 90h ; is next one a nop?
		jnz	short invalidbootsec

check_bpb_mediabyte:			; ...
		mov	al, ds:disksector+15h ;
					; [disksector+EXT_BOOT.BPB+EBPB.MEDIADESCRIPTOR]
		and	al, 0F0h
		cmp	al, 0F0h	; allow	for strange media
		jnz	short invalidbootsec

checksinglesided:
		mov	al, ds:disksector+15h
		cmp	al, 0F0h
		jz	short gooddsk
		test	al, 1
		jnz	short gooddsk
		cmp	word ptr ds:disksector+8, 2E33h	; "3."
		jnz	short mustbeearlier
		cmp	ds:disksector+0Ah, 32h ; "2"
		jnb	short gooddsk

mustbeearlier:				; ...
		mov	ds:disksector+0Dh, 1 ;
					; [disksector+EXT_BOOT.BPB+EBPB.SECTORSPERCLUSTER]
		jmp	short gooddsk
; ---------------------------------------------------------------------------

invalidbootsec:				; ...
		inc	bx

gooddsk:				; ...
		clc
		retn
; ---------------------------------------------------------------------------

err_ret:				; ...
		retn
readbootsec	endp


; =============== S U B	R O U T	I N E =======================================


movbpb		proc near		; ...
		mov	dh, ds:disksector+0Dh ;
					; disksector+EXT_BOOT.BPB+EBPB.SECTORSPERCLUSTER]
					; sectors per unit
		mov	bh, ds:disksector+11h ;
					; [disksector+EXT_BOOT.BPB+EBPB.ROOTENTRIES]
					; number of directory entries
		mov	cx, word ptr ds:disksector+13h ;
					; [disksector+EXT_BOOT.BPB+EBPB.TOTALSECTORS]
					; size of drive
		mov	ah, ds:disksector+15h ;
					; [disksector+EXT_BOOT.BPB+EBPB.MEDIADESCRIPTOR]
					; media	descriptor
		mov	al, ds:disksector+16h ;
					; [disksector+EXT_BOOT.BPB+EBPB.SECTORSPERFAT]
					; number of fat	sectors
		mov	bl, ds:disksector+18h ;
					; [disksector+EXT_BOOT.BPB+EBPB.SECTORSPERTRACK]
					; sectors per track
		mov	dl, ds:disksector+1Ah ;
					; [disksector+EXT_BOOT.BPB+EBPB.HEADS]
					; number of heads
		cmp	ds:set_id_flag,	1 ; called by get_bpb?
		jnz	short movbpb_ret
		call	mov_media_ids
		jb	short movbpb_conv ; conventional boot record?
		mov	ds:set_id_flag,	2 ; signals that volume	id is set

movbpb_conv:				; ...
		cmp	ds:fhave96, 1
		jnz	short movbpb_ret
		call	resetchanged	; reset	flags in bds to	not fchanged.

movbpb_ret:				; ...
		clc
		retn
movbpb		endp


; =============== S U B	R O U T	I N E =======================================


mov_media_ids	proc near		; ...
		cmp	ds:disksector+26h, 29h ; [disksector+EXT_BOOT.SIG]
					; EXT_BOOT_SIGNATURE
		jnz	short mmi_not_ext
		push	cx
		mov	cx, word ptr ds:disksector+27h ;
					; [disksector+EXT_BOOT.SERIAL]
		mov	es:[di+57h], cx	; [es:di+BDS.vol_serial]
		mov	cx, word ptr ds:disksector+29h ;
					; [disksector+EXT_BOOT.SERIAL+2]
		mov	es:[di+59h], cx	; [es:di+BDS.vol_serial+2]
		push	di
		push	si
		mov	cx, 11		; size_of_EXT_BOOT_VOL_LABEL
		mov	si, (offset disksector+2Bh) ;
					; disksector+EXT_BOOT.VOL_LABEL
		add	di, 75		; BDS.volid
		rep movsb
		mov	cx, 8		; size_of_EXT_SYSTEM_ID
		mov	si, (offset disksector+36h) ; disksector+EXT_BOOT.SYSTEM_ID
		add	di, 5		; (BDS.filesys_id-BDS.volid)-size_of_EXT_BOOT_VOL_LABEL
		rep movsb
		pop	si
		pop	di
		pop	cx
		clc			; this clc is not required (16/06/2019 - Erdogan Tan)
					; (20/09/2022)
		retn
; ---------------------------------------------------------------------------

mmi_not_ext:				; ...
		stc
		retn
mov_media_ids	endp


; =============== S U B	R O U T	I N E =======================================


readfat		proc near		; ...
		mov	dh, 0
		mov	cx, 2		; head 0
					; cylinder 0, sector 2
		call	read_sector
		jb	short bad_fat_ret
		mov	ah, [bx]	; media	byte

bad_fat_ret:				; ...
		retn
readfat		endp


; =============== S U B	R O U T	I N E =======================================


read_sector	proc near		; ...
		push	bp
		mov	bp, 3		; make 3 attempts
		mov	dl, es:[di+4]	; [es:di+BDS.drivenum]
		mov	bx, offset disksector ;
					; get es:bx to point to	buffer

rd_ret:					; ...
		push	es
		push	ds
		pop	es
		mov	ax, 201h
		int	13h		; DISK - READ SECTORS INTO MEMORY
					; AL = number of sectors to read, CH = track, CL = sector
					; DH = head, DL	= drive, ES:BX -> buffer to fill
					; Return: CF set on error, AH =	status,	AL = number of sectors read
		pop	es
		jnb	short okret2

rd_rty:					; ...
		call	again		; reset	disk, decrement	bp, preserve ax
		jz	short err_rd_ret
		test	byte ptr es:[di+23h], 1	; [es:di+BDS.flags]
					; fnon_removable
		jnz	short rd_ret
		cmp	ds:media_set_for_format, 0
		jnz	short rd_skip1_dpt
		push	ax
		push	ds		; for retry, set the head settle time to 0Fh
		lds	si, ds:dpt
		mov	al, [si+9]	; [si+DISK_PARMS.DISK_HEAD_STTL]
		mov	byte ptr [si+9], 15 ; [si+DISK_PARMS.DISK_HEAD_STTL]
					; NORMSETTLE
		pop	ds
		mov	ds:save_head_sttl, al
		pop	ax

rd_skip1_dpt:				; ...
		push	es
		push	ds
		pop	es
		mov	ax, 201h
		int	13h		; DISK - READ SECTORS INTO MEMORY
					; AL = number of sectors to read, CH = track, CL = sector
					; DH = head, DL	= drive, ES:BX -> buffer to fill
					; Return: CF set on error, AH =	status,	AL = number of sectors read
		pop	es
		pushf
		cmp	ds:media_set_for_format, 0
		jnz	short rd_skip2_dpt
		push	ax
		mov	al, ds:save_head_sttl
		push	ds
		lds	si, ds:dpt
		mov	[si+9],	al	; [si+DISK_PARMS.DISK_HEAD_STTL]
		pop	ds
		pop	ax

rd_skip2_dpt:				; ...
		popf
		jnb	short okret2
		jmp	short rd_rty
; ---------------------------------------------------------------------------

err_rd_ret:				; ...
		mov	dl, 0FFh	; make sure we ask rom if media	has changed
					; return error
		stc

okret2:					; ...
		mov	ds:step_drv, dl	; set up for head settle logic in disk
		mov	ds:tim_drv, dl	; save drive last accessed
		mov	es:[di+46h], ch	; [es:di+BDS.track]
					; save last track accessed on this drive
					; preserve flags in case error occurred
		pushf
		call	set_tim
		popf			; restore flags
		pop	bp
		retn
read_sector	endp

; ---------------------------------------------------------------------------

dsk_open:				; 2C7h:80Ah = 70h:2D7Ah
		cmp	ds:fhave96, 0
		jz	short dsk_open_exit ; done if no changeline support
		call	SetDrive	; get bds for drive
		inc	word ptr es:[di+20h] ; [es:di+BDS.opcnt]

dsk_open_exit:				; ...
		clc			; CF is	already	ZERO here (18/09/2022, MSDOS 5.0 IO.SYS)
					; (19/07/2019 -	Erdogan	Tan - MSDOS 6.0	IO.SYS - retrodos4.s)
		retn
; ---------------------------------------------------------------------------

dsk_close:				; 2C7h:81Ah = 70h:2D8Ah
		cmp	ds:fhave96, 0
		jz	short exitjx	; done if no changeline	support
		call	SetDrive	; get bds for drive
		cmp	word ptr es:[di+20h], 0	; [es:di+BDS.opcnt]
		jz	short exitjx	; watch	out for	wrap
		dec	word ptr es:[di+20h]

exitjx:					; ...
		clc			; CF is	already	ZERO here (18/09/2022, MSDOS 5.0 IO.SYS)
					; (19/07/2019 -	Erdogan	Tan - MSDOS 6.0	IO.SYS - retrodos4.s)
		retn
; ---------------------------------------------------------------------------

dsk_rem:				; 2C7h:831h = 70h:2DA1h
		call	SetDrive	; al is	unit #
		test	byte ptr es:[di+23h], 1
		jnz	short x_bus_exit ; non_rem
		clc
		retn
; ---------------------------------------------------------------------------

x_bus_exit:				; ...
		mov	ah, 3		; 2C7h:83Dh = 0070h:2DADh
					; return busy status
		stc

dsk_ret:				; ...
		retn
; ---------------------------------------------------------------------------

dsk_writv:				; 2C7h:841h = 70h:2DB1h
		mov	word ptr ds:rflag, 103h	; write	and verify
		jmp	short dsk_cl
; ---------------------------------------------------------------------------

dsk_writ:				; 2C7h:849h = 70h:2DB9h
		mov	word ptr ds:rflag, 3 ; romwrite

dsk_cl:					; ...
		call	diskio		; romwrite
; ---------------------------------------------------------------------------

dsk_io:					; ...
		jnb	short dsk_ret
		jmp	bc_err_cnt
; ---------------------------------------------------------------------------

dsk_read:				; ; 2C7h:857h =	70h:2DC7h
		call	diskrd
		jmp	short dsk_io

; =============== S U B	R O U T	I N E =======================================


checksingle	proc near		; ...
		push	ax
		push	bx
		mov	bx, es:[di+23h]	; [es:di+BDS.flags]
		test	bl, 21h		; fnon_removable|fi_own_physical
		jnz	short singleret
		test	bl, 10h		; fi_am_mult
					; is there a drive sharing this	physical drive?
		jz	short singleret
		mov	al, es:[di+4]	; [es:di+BDS.drivenum]
					; get physical drive number
		push	es		; preserve pointer to current bds
		push	di
		les	di, ds:start_bds ; get first bds

scan_list:				; ...
		cmp	es:[di+4], al
		jnz	short scan_skip	; Not our drive. Try next bds.
		mov	bl, 20h	; ' '   ; fi_own_physical ; test ownership flag
		test	es:[di+23h], bl
		jz	short scan_skip	; he doesn't own it either. continue
		xor	es:[di+23h], bl	; reset	ownership flag
		pop	di		; restore pointer to current bds
		pop	es
		or	es:[di+23h], bl	; ; set	ownership flag
		cmp	ds:fsetowner, 1
		jnz	short not_fsetowner
		cmp	byte ptr es:[di+4], 0 ;	are we handling	drive number 0 ?
		jnz	short singleret
		mov	al, es:[di+5]	; [es:di+BDS.drivelet]
					; get the DOS drive letter
		push	es
		mov	es, ds:zeroseg
		assume es:nothing
		mov	es:504h, al	; [es:LSTDRV]
					; set up sdsb
		pop	es		; restore bds pointer
		assume es:nothing
		jmp	short singleret
; ---------------------------------------------------------------------------

not_fsetowner:				; ...
		cmp	ds:single, 2	; if (single_drive_system)
		jnz	short ignore_sdsb
		push	ax
		mov	al, es:[di+5]	; if (curr_drv == req_drv)
		mov	ah, al
		push	es
		mov	es, ds:zeroseg
		assume es:nothing
		xchg	al, es:504h	; [es:LSTDRV] ;	then swap(curr_drv,req_drv)
		pop	es
		assume es:nothing
		cmp	ah, al		; else
		pop	ax		; swap(curr_drv,req_drv)
		jz	short singleret	; issue	swap_dsk_msg

ignore_sdsb:				; ...
		call	swpdsk
		jmp	short singleret
; ---------------------------------------------------------------------------

scan_skip:				; ...
		les	di, es:[di]	; [es:di+BDS.link]
					; go to	next bds
		cmp	di, 0FFFFh	; end of list?
		jnz	short scan_list	; ontinue until	hit end	of list
		stc
		pop	di		; restore current bds
		pop	es

singleret:				; ...
		pop	bx
		pop	ax
		retn
checksingle	endp

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR diskio

baddrive:				; ...
		mov	al, 8		; sector not found
		jmp	short baddrive_ret
; ---------------------------------------------------------------------------

unformatteddrive:			; ...
		mov	al, 7		; unknown media

baddrive_ret:				; ...
		stc
; END OF FUNCTION CHUNK	FOR diskio

; =============== S U B	R O U T	I N E =======================================


ioret		proc near		; ...
		retn
ioret		endp

; ---------------------------------------------------------------------------

diskrd:					; ...
		mov	ds:rflag, 2	; romread

; =============== S U B	R O U T	I N E =======================================


diskio		proc near		; ...

; FUNCTION CHUNK AT 2E4D SIZE 00000007 BYTES

		mov	bx, di		; es:bx	= transfer address
		mov	ds:xfer_seg, es	; save transfer	segment
		call	SetDrive
		mov	al, es:[di+10h]	; [es:di+BDS.media]
		mov	ds:medbyt, al
		jcxz	short ioret
		test	byte ptr es:[di+24h], 2	; [es:di+BDS.flags+1]
					; unformatted_media
		jnz	short unformatteddrive
		mov	ds:seccnt, cx	; save sector count
		mov	ds:spsav, sp	; save sp
		mov	ax, dx
		xor	si, si
		add	dx, cx
		adc	si, 0
		cmp	word ptr es:[di+0Eh], 0	; [es:di+BDS.totalsecs16]
					; > 32 bit sector ?
		jz	short sanity32
		cmp	si, 0
		jnz	short baddrive
		cmp	dx, es:[di+0Eh]	; [es:di+BDS.totalsecs16]
		ja	short baddrive
		jmp	short sanityok
; ---------------------------------------------------------------------------

sanity32:				; ...
		add	si, ds:start_sec_h
		cmp	si, es:[di+1Dh]	; [es:di+BDS.totalsecs32+2]
		jb	short sanityok
		ja	short baddrive
		cmp	dx, es:[di+1Bh]	; [es:di+BDS.totalsecs32]
		ja	short baddrive

sanityok:				; ...
		mov	dx, ds:start_sec_h
		add	ax, es:[di+17h]	; [es:di+BDS.hiddensecs]
		adc	dx, es:[di+19h]	; [es:di+BDS.hiddensecs+2]
		mov	ds:saved_word, ax ; save the sector number (low)
		push	es
		mov	es, ds:zeroseg
		assume es:nothing
		les	si, es:78h	; [es:DSKADR]
					; current disk parm table
		assume es:nothing
		mov	word ptr ds:dpt, si
		mov	word ptr ds:dpt+2, es
		pop	es
		test	byte ptr es:[di+23h], 1	; [es:di+BDS.flags]
					; fnon_removable
		jnz	short skip_setup
		call	checksingle
		cmp	ds:fhave96, 0	; do we	have changeline	support?
		jz	short diskio_nochangeline ; brif not
		call	checklatchio	; will do a sneaky pop stack return
					; if a disk error occurs

diskio_nochangeline:			; ...
		call	iosetup		; set up tables	and variables for i/o

skip_setup:				; ...
		mov	ax, dx
		xor	dx, dx
		div	word ptr es:[di+13h] ; [es:di+BDS.secpertrack]
					; divide by sec	per track
		mov	ds:temp_h, ax
		mov	ax, ds:saved_word
		div	word ptr es:[di+13h] ; [es:di+BDS.secpertrack]
					; now, [temp_h]:ax = track #, dx = sector
		inc	dl		; sector number	is 1 based.
		mov	ds:cursec, dl	; save current sector
		mov	cx, es:[di+15h]	; es:di+BDS.heads]
					; get number of	heads
		push	ax
		xor	dx, dx
		mov	ax, ds:temp_h	; divide tracks	by heads per cylinder
		div	cx
		mov	ds:temp_h, ax
		pop	ax
		div	cx		; now, [temp_h]:ax = cylinder #, dx = head
		cmp	ds:temp_h, 0
		ja	short baddrive_brdg
		cmp	ax, 1024	; 2^10 currently maxium	for track #.
		ja	short baddrive_brdg
		mov	ds:curhd, dl	; save current head
		mov	ds:curtrk, ax	; save current track
		mov	ax, ds:seccnt
		call	block		; (cas - call/ret)
		call	done
		retn
; ---------------------------------------------------------------------------

baddrive_brdg:				; ...
		jmp	baddrive
diskio		endp ; sp-analysis failed


; =============== S U B	R O U T	I N E =======================================


iosetup		proc near		; ...
		mov	al, es:[di+4]	; [es:di+BDS.drivenum]
		mov	ds:tim_drv, al
		cmp	ds:media_set_for_format, 0
		jnz	short skip_dpt_setting
		mov	al, ds:eot	; fetch	up eot before changing ds
		push	ds
		lds	si, ds:dpt	; get pointer to disk base table
		mov	[si+4],	al
		mov	al, [si+10]	; [si+DISK_PARMS.DISK_MOTOR_STRT]
		mov	ah, [si+4]	; [si+DISK_PARMS.DISK_EOT]
		pop	ds
		mov	ds:motorstartup, al
		mov	ds:save_eot, ah
		push	ds
		lds	si, ds:dpt
		cmp	byte ptr es:[di+22h], 2	; [es:di+BDS.formfactor]
					; ffSmall
		jnz	short motor_start_ok
		mov	al, 4
		xchg	al, [si+10]	; [si+DISK_PARMS.DISK_MOTOR_STRT]

motor_start_ok:				; ...
		xor	al, al
		inc	al		; ibm wants fast settle	to be 1
		xchg	al, [si+9]	; [si+DISK_PARMS.DISK_HEAD_STTL]
					; get settle and set up	for fast
		pop	ds
		mov	ds:settlecurrent, al
		mov	al, 15		; NORMSETTLE
					; someone has diddled the settle
		mov	ds:settleslow, al

skip_dpt_setting:			; ...
		retn
iosetup		endp


; =============== S U B	R O U T	I N E =======================================


done		proc near		; ...
		test	byte ptr es:[di+23h], 1	; [es:di+BDS.flags]
					; fnon_removable
		jnz	short ddbx	; do not set for non-removable media
		call	set_tim

diddleback:				; ...
		pushf
		cmp	ds:media_set_for_format, 0
		jnz	short nodiddleback
		push	ax
		push	es
		les	si, ds:dpt
		mov	al, ds:save_eot
		mov	es:[si+4], al	; [es:si+DISK_PARMS.DISK_EOT]
		mov	al, ds:settlecurrent
		mov	ah, ds:motorstartup
		mov	es:[si+9], al	; [es:si+DISK_PARMS.DISK_HEAD_STTL]
		mov	byte ptr es:[si+3], 2 ;	[es:si+DISK_PARMS.DISK_SECTOR_SIZ]
		mov	es:[si+0Ah], ah	; [es:si+DISK_PARMS.DISK_MOTOR_STRT]
		pop	es
		pop	ax

nodiddleback:				; ...
		popf

ddbx:					; ...
		retn
done		endp


; =============== S U B	R O U T	I N E =======================================


block		proc near		; ...
		or	ax, ax
		jz	short ddbx
		test	byte ptr es:[di+23h], 1	; [es:di+BDS.flags]
					; fnon_removable
		jz	short block_floppy ;
					; check	to see if multi	track operation	is allowed. if not
					; we have to go	to the block_floppy below to break up the operation.
		test	byte ptr ds:multrk_flag, 80h ; multrk_on
		jz	short block_floppy
		call	Disk
		xor	ax, ax
		retn
; ---------------------------------------------------------------------------

block_floppy:				; ...
		mov	cl, es:[di+19]	; read at most 1 track worth.
					; perform minimization at sector / track
					; [es:di+BDS.secpertrack]
		inc	cl
		sub	cl, ds:cursec
		xor	ch, ch
		cmp	ax, cx
		jnb	short gotmin
		mov	cx, ax

gotmin:					; ...
		push	ax
		push	cx
		mov	ax, cx
		call	Disk
		pop	cx
		pop	ax
		sub	ax, cx		; reduce sectors-remaining by last i/o
		shl	cl, 1
		add	bh, cl		; adjust transfer address
		jmp	short block
block		endp

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR Disk

dskerr_brdg:				; ...
		jmp	dskerr
; END OF FUNCTION CHUNK	FOR Disk

; =============== S U B	R O U T	I N E =======================================


Disk		proc near		; ...

; FUNCTION CHUNK AT 2FE8 SIZE 00000003 BYTES

		mov	bp, 5		; MAXERR
					; set up retry count
		test	byte ptr es:[di+23h], 1	;
					; [es:di+BDS.flags], fnon_removable
		jz	short GetRdWrInd
		cmp	ah, 4		; romverify ; Is this a	track verify?
		jz	short GetRdWrInd
		mov	bp, 2		; This is verify so only 1 retry

GetRdWrInd:				; ...
		mov	ds:vretry_cnt, bp ;
					; verify op. retry cnt for write-verify
		mov	ds:soft_ecc_cnt, bp ; soft ecc error retry count.
		mov	ah, ds:rflag	; get read/write indicator

retry:					; ...
		push	ax
		mov	dx, ds:curtrk
		test	byte ptr es:[di+23h], 1
		jz	short disk_not_mini
		cmp	word ptr es:[di+47h], 1	; [es:di+BDS.bdsm_ismini]
					; is this a mini disk? ((logical dos partition))
		jnz	short disk_not_mini ; no. continue to next.
		add	dx, es:[di+49h]	; [es:di+BDS.bdsm_hidden_trks]
					; add hidden trks.

disk_not_mini:				; ...
		ror	dh, 1
		ror	dh, 1
		or	dh, ds:cursec
		mov	cx, dx
		xchg	ch, cl		;  cl =	sector,	ch = cylinder
		mov	dh, ds:curhd	; load current head number and
		mov	dl, es:[di+4]	; physical drive number
					; [es:di+BDS.drivenum]
		cmp	byte ptr es:[di+22h], 5	; [es:di+BDS.formfactor], ffHardFile
		jz	short do_fast	; hard files use fast speed
		cmp	ds:step_drv, 0FFh ; -1
		jz	short do_writej
		cmp	ah, 2		; romread
		jz	short do_fast
		cmp	ah, 4		; romverify
		jz	short do_fast

do_writej:				; ...
		jmp	short do_write	; reads	always fast
; ---------------------------------------------------------------------------

do_fast:				; ...
		call	fastspeed	; change settle	mode

testerr:				; ...
		jb	short dskerr_brdg
		mov	ds:step_drv, dl
		mov	es:[di+46h], ch	; [es:di+BDS.track]
		cmp	word ptr ds:rflag, 103h	; check	for write and verify
		jz	short doverify

noverify:				; ...
		pop	ax
		test	byte ptr es:[di+23h], 1	; [es:di+BDS.flags]
					; fnon_removable
		jz	short its_removable
		test	byte ptr ds:multrk_flag, 80h ; multrk_on
		jnz	short disk_ret

its_removable:				; ...
		and	cl, 3Fh		; eliminate cylinder bits from sector
		xor	ah, ah
		sub	ds:seccnt, ax	; reduce count of sectors to go	next sector
		add	cl, al
		mov	ds:cursec, cl
		cmp	cl, es:[di+13h]	; [es:di+BDS.secpertrack]
					; see if sector/track limit reached
		jbe	short disk_ret
		mov	ds:cursec, 1	; start	with first sector of next track
		mov	dh, ds:curhd
		inc	dh
		cmp	dh, es:[di+15h]	; [es:di+BDS.heads]
		jb	short noxor
		xor	dh, dh
		inc	ds:curtrk

noxor:					; ...
		mov	ds:curhd, dh

disk_ret:				; ...
		clc
		retn
; ---------------------------------------------------------------------------

do_write:				; ...
		cmp	dl, ds:step_drv
		jnz	short do_norm	; we have changed drives
		cmp	ch, es:[di+46h]	; [es:di+BDS.track]
		jz	short do_fast	; we are still on the same track

do_norm:				; ...
		call	normspeed
		jmp	short testerr
; ---------------------------------------------------------------------------

doverify:				; ...
		pop	ax
		push	ax
		mov	ah, 4
		call	fastspeed
		jnb	short noverify
		cmp	ah, 11h		; soft ecc error ?
		jnz	short not_softecc_err
		dec	ds:soft_ecc_cnt
		jz	short noverify	; no more retry
		call	ResetDisk	; reset	disk
		jmp	short dskerr1	; retry
; ---------------------------------------------------------------------------

not_softecc_err:			; ...
		call	ResetDisk
		dec	ds:vretry_cnt
		jmp	short dskerr0
; ---------------------------------------------------------------------------

dskerr:					; ...
		cmp	ds:fhave96, 0	; do we	have changeline	support?
		jz	short dskerr_nochangeline ; brif not
		call	checkio

dskerr_nochangeline:			; ...
		cmp	ds:multitrk_format_flag, 1 ; multi trk format request?
		jnz	short dochkagain ; no more retry.
		mov	bp, 1
		mov	ds:multitrk_format_flag, 0 ; clear the flag.

dochkagain:				; ...
		call	again

dskerr0:				; ...
		jz	short harderr
		test	byte ptr es:[di+23h], 1	; [es:di+BDS.flags]
					; fnon_removable
		jnz	short skip_timeout_chk
		cmp	ah, 80h		; timeout?
		jz	short harderr

skip_timeout_chk:			; ...
		cmp	ah, 0CCh	; write	fault error?
		jz	short write_fault_err ;	then, don't retry.
		mov	ds:soft_ecc_cnt, 5 ; MAXERR
					; set soft_ecc_cnt back	to maxerr

dskerr1:				; ...
		pop	ax		; restore sector count
		jmp	retry
; ---------------------------------------------------------------------------

write_fault_err:			; ...
		mov	bp, 1		; just retry only once
					; for write fault error.
		jmp	short dskerr1
; ---------------------------------------------------------------------------

harderr:				; ...
		call	maperror

harderr2:				; ...
		mov	ds:tim_drv, 0FFh ; force a media check through rom
		mov	cx, ds:seccnt	; get count of sectors to go
		mov	sp, ds:spsav	; recover entry	stack pointer
		jmp	diddleback	; restore the disk parameters
Disk		endp


; =============== S U B	R O U T	I N E =======================================


normspeed	proc near		; ...
		cmp	ds:media_set_for_format, 0
		jnz	short fastspeed
		push	es
		push	ax
		mov	al, ds:settleslow
		les	si, ds:dpt	; current disk parm table
		mov	es:[si+9], al	; [es:si+DISK_PARMS.DISK_HEAD_STTL]
		pop	ax
		pop	es
		call	fastspeed
		push	es
		les	si, ds:dpt
		mov	byte ptr es:[si+9], 1 ;	[es:si+DISK_PARMS.DISK_HEAD_STTL]
					; 1 is fast settle value
		pop	es
		retn
normspeed	endp


; =============== S U B	R O U T	I N E =======================================


fastspeed	proc near		; ...
		test	byte ptr es:[di+1Fh], 80h ; if the drive has been marked as too	big
					; (i.e.	starting sector	of the partition is > 16 bits),
					; then always return drive not ready.
					;
					; [es:di+BDS.fatsiz]
					; ftoobig
		jnz	short notready
		push	es
		mov	es, ds:xfer_seg
		int	13h		; DISK -
		mov	ds:xfer_seg, es
		pop	es
		retn
; ---------------------------------------------------------------------------

notready:				; ...
		stc
		mov	ah, 80h
		retn
fastspeed	endp


; =============== S U B	R O U T	I N E =======================================


maperror	proc near		; ...
		push	cx
		push	es
		push	ds		; set es=Bios_Data
		pop	es
		mov	al, ah		; put error code in al
		mov	ds:lsterr, al	; terminate list with error code
		mov	cx, 9		; numerr (= errout-errin)
					; number of possible error conditions
		mov	di, offset errin ; point to error conditions
		repne scasb
		mov	al, [di+8]	; [di+numerr-1]
					; get translation
		pop	es
		pop	cx
		stc			; flag error condition
		retn
maperror	endp


; =============== S U B	R O U T	I N E =======================================


set_tim		proc near		; ...
		push	ax		; set the time of last access for this drive.
					; this is done only for	removable media.
					; es:di	-> bds
		call	GetTickCnt	; Does INT 1A ah=0 & updates daycnt
					;
					; we have the new time.
					; if we	see that the time has passed,
					; then we reset	the threshold counter
		cmp	dx, es:[di+47h]	; [es:di+BDS.tim_lo]
		jnz	short setaccess
		cmp	cx, es:[di+49h]	; [es:di+BDS.tim_hi]
		jz	short done_set

setaccess:				; ...
		mov	ds:accesscount,	0
		mov	es:[di+47h], dx	; [es:di+BDS.tim_lo]
		mov	es:[di+49h], cx	; [es:di+BDS.tim_hi]

done_set:				; ...
		clc
		pop	ax
		retn
set_tim		endp


; =============== S U B	R O U T	I N E =======================================


again		proc near		; ...
		call	ResetDisk
		cmp	ah, 6
		jz	short dont_dec_retry_count ; If	it is a	media change error
					; do not decrement retry count.
		dec	bp		; decrement retry count
		retn
; ---------------------------------------------------------------------------

dont_dec_retry_count:			; ...
		or	ah, ah
		retn
again		endp

; ---------------------------------------------------------------------------
		db    0
IoReadJumpTable	db 8
		dw 0CA7h		; GetDeviceParameters
		dw 0EE8h		; ReadTrack
		dw 0E86h		; VerifyTrack
		dw 0CA3h		; Cmd_Error_Proc
		dw 0CA3h		; Cmd_Error_Proc
		dw 0CA3h		; Cmd_Error_Proc
		dw 119Ah		; GetMediaId
		dw 1269h		; GetAccessFlag
		dw 12C1h		; SenseMediaType
IoWriteJumpTable db 7
		dw 0CF3h		; SetDeviceParameters
		dw 0EEFh		; WriteTrack
		dw 0DC1h		; FormatTrack
		dw 0CA3h		; Cmd_Error_Proc
		dw 0CA3h		; Cmd_Error_Proc
		dw 0CA3h		; Cmd_Error_Proc
		dw 11D2h		; SetMediaId
		dw 1280h		; SetAccessFlag
IOC_DC_Table	db 60h			; GET_DEVICE_PARAMETERS
		db 40h			; SET_DEVICE_PARAMETERS
		db 61h			; READ_TRACK
		db 41h			; WRITE_TRACK
		db 62h			; VERIFY_TRACK
		db 42h			; FORMAT_TRACK
		db 66h			; GET_MEDIA_ID
		db 46h			; SET_MEDIA_ID
		db 67h			; GET_ACCESS_FLAG
		db 47h			; SET_ACCESS_FLAG
		db 68h			; SENSE_MEDIA_TYPE
; ---------------------------------------------------------------------------

do_generic_ioctl:			; 2C7h:0C6Bh = 70h:31DBh
		call	SetDrive	; ES:DI	Points to bds for drive
		push	es
		les	bx, ds:ptrsav	; ES:BX	Points to request header
		cmp	byte ptr es:[bx+0Dh], 8	; [es:bx+IOCTL_REQ.MAJORFUNCTION]
					; RAWIO
		mov	al, es:[bx+0Eh]	; [es:bx+IOCTL_REQ.MINORFUNCTION]
		pop	es
		jnz	short IoctlFuncErr
		mov	si, 0C3Ch	; IoReadJumpTable
					; at 2C7h:0C3Ch	= 70h:31ACh
		test	al, 20h		; GEN_IOCTL_FN_TST ; test of req. function
		jnz	short NotGenericWrite
		mov	si, 0C4Fh	; IoWriteJumpTable
					; at 2C7h:0C4Fh	= 70h:31BFh

NotGenericWrite:			; ...
		and	al, 0DFh	; ~GEN_IOCTL_FN_TST ; get rid of read/write bit
		sub	al, 40h		; offset for base function
		cmp	al, cs:[si]
		ja	short IoctlFuncErr
		cbw
		shl	ax, 1
		inc	si
		add	si, ax
		call	word ptr cs:[si]
		mov	ds, word ptr cs:aCon+3 ; [cs:Bios_Data_Word]
					; 2C7h:30h = 70h:25A0h
		assume ds:nothing
		mov	ah, 81h		; Return this status in	case of	carry
		retn			; Pass carry flag through to exit code
; ---------------------------------------------------------------------------

Cmd_Error_Proc:				; 2C7h:0CA3h = 70h:3213h
		pop	dx

IoctlFuncErr:				; ...
		jmp	bc_cmderr
; ---------------------------------------------------------------------------

GetDeviceParameters:			; DS:BX	points to request header
		lds	bx, ds:ptrsav
		assume ds:nothing
		lds	bx, [bx+19]	; [bx+IOCTL_REQ.GENERICIOCTL_PACKET]
					; (DS:BX) = return buffer
		mov	al, es:[di+34]	; [es:di+BDS.formfactor]
		mov	[bx+1],	al	; [bx+A_DEVICEPARAMETERS.DP_DEVICETYPE]
		mov	ax, es:[di+35]	; [es:di+BDS.flags]
		and	ax, 3		; fnon_removable+fchangeline
					; Mask off other bits
		mov	[bx+2],	ax	; [bx+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES]
		mov	ax, es:[di+37]	; [es:di+BDS.cylinders]
		mov	[bx+4],	ax	; [bx+A_DEVICEPARAMETERS.DP_CYLINDERS]
		xor	al, al		; Set media type to default
		mov	[bx+6],	al	; [bx+A_DEVICEPARAMETERS.DP_MEDIATYPE]
		lea	si, [di+39]	; [di+BDS.rbytespersec]	= [di+BDS.R_BPB]
					; copy recommended bpb
		test	byte ptr [bx], 1 ; [bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS]
					; BUILD_DEVICE_BPB
		jz	short UseBpbPresent
		push	ds		; Save request packet segment
		mov	ds, word ptr cs:aCon+3 ; [cs:Bios_Data_Word]
					; 2C7h:30h = 70h:25A0h
					; Point	back to	Bios_Data
		assume ds:nothing
		call	checksingle
		call	GetBp		; Build	the bpb	from scratch
		pop	ds		; Restore request packet segment
		assume ds:nothing
		jb	short GetParmRet
		lea	si, [di+6]	; [di+BDS.bytespersec] = [di+BSD.DP_BPB]
					; Use this subfield of bds instead

UseBpbPresent:				; ...
		lea	di, [bx+7]	; [bx+A_DEVICEPARAMETERS.DP_BPB]
					; This is where	the result goes
		mov	cx, 25		; A_BPB.size - 6
					; For now use 'small' bpb
		push	ds		; reverse segments for copy
		push	es
		pop	ds
		pop	es
		rep movsb
		clc

GetParmRet:				; ...
		retn
; ---------------------------------------------------------------------------

SetDeviceParameters:			; 2C7h:0CF3h = 70h:3263h
		lds	bx, ds:ptrsav	; DS:BX	points to request header
		lds	bx, [bx+19]	; [bx+IOCTL_REQ.GENERICIOCTL_PACKET]
		or	word ptr es:[di+23h], 140h ; [es:di+BDS.flags]
					; fchanged_by_format|fchanged
		test	byte ptr [bx], 2 ; [bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS]
					; ONLY_SET_TRACKLAYOUT
		jnz	short setTrackTable
		mov	al, [bx+1]	; [bx+A_DEVICEPARAMETERS.DP_DEVICETYPE]
		mov	es:[di+34], al	; [es:di+BDS.formfactor]
		mov	ax, [bx+4]	; [bx+A_DEVICEPARAMETERS.DP_CYLINDERS]
		mov	es:[di+37], ax	; [es:di+BDS.cylinders]
		mov	ax, [bx+2]	; [bx+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES]
		push	ds
		mov	ds, word ptr cs:aCon+3 ; [cs:Bios_Data_Word]
					; 2C7h:30h = 70h:25A0h
		assume ds:nothing
		cmp	ds:fhave96, 0
		pop	ds
		assume ds:nothing
		jnz	short HaveChange ; we have changeline support
		and	ax, 0FFFDh	; ~fchangeline

HaveChange:				; ...
		and	ax, 3		; fnon_removable|fchangeline
		mov	cx, es:[di+35]	; [es:di+BDS.flags]
		and	cx, 0FDF4h	; ~(fnon_removable|fchangeline|good_tracklayout|unformatted_media)
		or	ax, cx
		mov	es:[di+35], ax	; [es:di+BDS.flags]
		mov	al, [bx+6]	; [bx+A_DEVICEPARAMETERS.DP_MEDIATYPE]
					; Set media type
		push	ds
		mov	ds, word ptr cs:aCon+3 ; [cs:Bios_Data_Word]
		assume ds:nothing
		mov	ds:mediatype, al
		pop	ds
		assume ds:nothing
		or	word ptr es:[di+35], 80h ; [es:di+BDS.flags]
					; set_dasd_true
		push	di		; Save bds pointer
		test	byte ptr [bx], 1 ; [bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS]
					; INSTALL_FAKE_BPB
		jnz	short InstallFakeBpb
		test	word ptr es:[di+35], 4 ; [es:di+BDS.flags]
					; return_fake_bpb
		jz	short InstallRecommendedBpb
		and	word ptr es:[di+35], 0FFFBh ; [es:di+BDS.flags]
					; ~return_fake_bpb

InstallRecommendedBpb:			; ...
		mov	cx, 31		; A_BPB.size
		lea	di, [di+27h]	; [di+BDS.R_BPB] = [di+BDS.rbytespersec]
		jmp	short CopyTheBpb
; ---------------------------------------------------------------------------

InstallFakeBpb:				; ...
		or	word ptr es:[di+35], 4 ; byte [es:di+BDS.flags]
					; return_fake_bpb
		mov	cx, 25		; A_BPB.size - 6
					; move 'smaller' bpb
		lea	di, [di+6]	; [es:di+BDS.BPB] = [es:di+BDS.bytespersec]

CopyTheBpb:				; ...
		lea	si, [bx+7]	; [bx+A_DEVICEPARAMETERS.DP_BPB]
		rep movsb
		push	ds		; Save packet segment
		mov	ds, word ptr cs:aCon+3 ; [cs:Bios_Data_Word]
					; Setup	for ds -> Bios_Data
		assume ds:nothing
		call	RestoreOldDpt	; Restore the old Dpt from TempDpt
		pop	ds		; Restore packet segment
		assume ds:nothing
		pop	di		; Restore bds pointer

setTrackTable:				; ...
		mov	cx, [bx+38]
		push	ds
		mov	ds, word ptr cs:aCon+3 ; [cs:Bios_Data_Word]
		assume ds:nothing
		mov	ds:sectorspertrack, cx
		pop	ds
		assume ds:nothing
		and	word ptr es:[di+35], 0FFF7h ; [es:di+BDS.flags]
					; ~good_tracklayout
		test	byte ptr [bx], 4 ; [bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS]
					; TRACKLAYOUT_IS_GOOD
		jz	short UglyTrackLayOut
		or	word ptr es:[di+35], 8 ; [es:di+BDS.flags]
					; good_tracklayout

UglyTrackLayOut:			; ...
		cmp	cx, 63		; MAX_SECTORS_IN_TRACK
		ja	short TooManyPerTrack
		jcxz	short SectorInfoSaved
		mov	di, offset tracktable
		lea	si, [bx+40]	; [bx+A_DEVICEPARAMETERS.DP_SECTORTABLE]
		mov	es, word ptr cs:aCon+3 ; [cs:Bios_Data_Word]
					; Trash	our bds	pointer
		assume es:nothing

StoreSectorInfo:			; ...
		inc	di
		inc	di		; Skip over cylinder and head
		lodsw			; Get sector id
		stosb			; Copy it
		lodsw			; Get sector size
		call	SectSizeToSectIndex
		stosb			; Store	sector SIZE index
		loop	StoreSectorInfo

SectorInfoSaved:			; ...
		clc
		retn
; ---------------------------------------------------------------------------

TooManyPerTrack:			; ...
		mov	al, 0Ch
		stc
		retn
; ---------------------------------------------------------------------------

FormatTrack:
		lds	bx, ds:ptrsav
		lds	bx, [bx+19]	; [bx+IOCTL_REQ.GENERICIOCTL_PACKET
		test	byte ptr [bx], 1 ; [bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS]
					; STATUS_FOR_FORMAT
		jz	short DoFormatTrack
		push	ds
		mov	ds, word ptr cs:aCon+3 ; [cs:Bios_Data_Word]
		assume ds:nothing
		call	SetMediaForFormat ; Also moves current Dpt to TempDpt
		pop	ds
		assume ds:nothing
		mov	[bx], al	; [bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS]
		clc
		retn
; ---------------------------------------------------------------------------

DoFormatTrack:				; ...
		cmp	byte ptr es:[di+34], 5 ; [es:di+BDS.formfactor]
					; DEV_HARDDISK
		jnz	short DoFormatDiskette
		mov	ds, word ptr cs:aCon+3 ; [cs:Bios_Data_Word]
					; Point	to Bios_Data (at 2C7h:30h or 70h:25A0h)
		assume ds:nothing
		jmp	VerifyTrack
; ---------------------------------------------------------------------------

DoFormatDiskette:			; ...
		mov	cx, [bx+1]
		mov	dx, [bx+3]
		test	byte ptr [bx], 2
		mov	ds, word ptr cs:aCon+3 ; [cs:Bios_Data_Word]
					; Setup	ds-> Bios_Data for verify
		jz	short DoFormatDiskette_1
		jmp	VerifyTrack_Err
; ---------------------------------------------------------------------------

DoFormatDiskette_1:			; ...
		call	SetMediaForFormat ; Also moves current Dpt to TempDpt
		cmp	al, 1		;  ROM support for sec/trk,# trks comb?
		jz	short NeedToSetDasd ; Old rom
		cmp	al, 3		; Time out error?
		jnz	short NoSetDasd	; No,fine. (at this point, don't care
					; about	the illegal combination)
		jmp	short FormatFailed
; ---------------------------------------------------------------------------

NeedToSetDasd:				; ...
		push	dx
		call	SetDasd		; INT 13h, AH=17h
		pop	dx

NoSetDasd:				; ...
		call	checksingle	; Do any needed	diskette swapping
		mov	ax, dx		; Get track from packet
		mov	ds:trknum, ax
		mov	ds:hdnum, cl	; Store	head from packet
		mov	ah, cl
		mov	bx, offset tracktable
		mov	cx, ds:sectorspertrack

StoreCylinderHead:			; ...
		mov	[bx], ax	; Store	into TrackTable
		add	bx, 4		; Skip to next sector field
		loop	StoreCylinderHead
		mov	cx, 5		; MAXERR - Set up retry	count

FormatRetry:				; ...
		push	cx
		mov	bx, offset tracktable
		mov	al, byte ptr ds:sectorspertrack
		mov	ah, 5		; romformat
		mov	ds:xfer_seg, ds
		call	ToRom
		pop	cx
		jb	short FormatError
		push	cx		; Now verify the sectors just formatted.
					; NOTE:	because	of bug in some BIOSes we have to
					;	set ES:BX to 00:00
		push	bx
		xor	bx, bx
		mov	ds:xfer_seg, bx
		mov	al, byte ptr ds:sectorspertrack
		mov	ah, 4		; romverify
		mov	cl, 1
		call	ToRom
		pop	bx
		pop	cx
		jnb	short FormatOk

FormatError:				; ...
		call	ResetDisk
		mov	ds:had_format_error, 1
		push	ax
		push	cx
		push	dx
		call	SetMediaForFormat
		cmp	al, 1
		jnz	short WhileErr
		call	SetDasd

WhileErr:				; ...
		pop	dx
		pop	cx
		pop	ax
		loop	FormatRetry

FormatFailed:				; ...
		mov	ds:had_format_error, 1 ; Set the format	error flag
		cmp	ah, 6		; DSK_CHANGELINE_ERR - convert change line
		jnz	short DoMapIt	; Error	to time	out error
		mov	ah, 80h		; DSK_TIMEOUT_ERR

DoMapIt:				; ...
		jmp	maperror
; ---------------------------------------------------------------------------

FormatOk:				; ...
		mov	ds:had_format_error, 0 ; reset the format error	flag
		retn
; ---------------------------------------------------------------------------

VerifyTrack:				; ...
		push	ds
		lds	bx, ds:ptrsav
		assume ds:nothing
		lds	bx, [bx+19]	; [bx+IOCTL_REQ.GENERICIOCTL_PACKET]
		mov	cx, [bx+3]	; [bx+A_VERIFYPACKET.VP_CYLINDER]
		mov	ax, [bx+1]	; [bx+A_VERIFYPACKET.VP_HEAD]
		mov	dx, [bx+5]	; [bx+A_FORMATPACKET.FP_TRACKCOUNT]
		mov	bl, [bx]	; [bx+A_FORMATPACKET.FP_SPECIALFUNCTIONS]
					; Get option flag word
		pop	ds
		mov	ds:rflag, 4	; romverify
		mov	ds:curtrk, cx
		mov	ds:curhd, al	; ASSUME heads < 256
		mov	cx, ds:sectorspertrack
		test	bl, 2		; DO_FAST_FORMAT
		jz	short NormVerifyTrack
		mov	ax, dx
		or	ah, ah
		jnz	short VerifyTrack_Err
		mul	cl
		or	ah, ah
		jnz	short VerifyTrack_Err
		mov	cx, ax
		test	word ptr es:[di+35], 1 ; [es:di+BDS.flags]
					; fnon_removable
		jz	short NormVerifyTrack
		test	ds:multrk_flag,	80h ; MULTI_TRK_ON
		jz	short NormVerifyTrack
		mov	ds:multitrk_format_flag, 1

NormVerifyTrack:			; ...
		xor	ax, ax		;  1st sector
		xor	bx, bx
		mov	ds:xfer_seg, bx	; Use 0:0 as the transfer address for verify
		call	TrackIo
		mov	ds:multitrk_format_flag, 0
		retn
; ---------------------------------------------------------------------------

VerifyTrack_Err:			; ...
		mov	ah, 1
		jmp	maperror
; ---------------------------------------------------------------------------

ReadTrack:				; romread
		mov	ds:rflag, 2
		jmp	short ReadWriteTrack
; ---------------------------------------------------------------------------

WriteTrack:				; romwrite
		mov	ds:rflag, 3

ReadWriteTrack:				; ...
		push	es
		les	bx, ds:ptrsav	; ES:BX	-> to request header
		assume es:nothing
		les	bx, es:[bx+19]	; [es:bx+IOCTL_REQ.GENERICIOCTL_PACKET]
		mov	ax, es:[bx+3]	; [es:bx+A_TRACKREADWRITEPACKET.TRWP_CYLINDER]
		mov	ds:curtrk, ax
		mov	ax, es:[bx+1]	; [es:bx+A_TRACKREADWRITEPACKET.TRWP_HEAD]
		mov	ds:curhd, al	; Assume heads < 256!!!
		mov	ax, es:[bx+5]	; [es:bx+A_TRACKREADWRITEPACKET.TRWP_FIRSTSECTOR]
		mov	cx, es:[bx+7]	; [es:bx+A_TRACKREADWRITEPACKET.TRWP_SECTORSTOREADWRITE]
		les	bx, es:[bx+9]	; [es:bx+A_TRACKREADWRITEPACKET.TRWP_TRANSFERADDRESS]
					; Get transfer address
		mov	ds:xfer_seg, es	; Pass transfer	segment
		pop	es

; =============== S U B	R O U T	I N E =======================================


TrackIo		proc near		; ...
		mov	ds:spsav, sp	; performs track read/write/verify
					; Procedure `disk' will pop stack to
					; SpSav	and return if error
		call	checksingle
		cmp	ds:media_set_for_format, 1 ; See if we have already set	disk
		jz	short Dptalreadyset ; base table
		push	ax		; set up tables	and variables for i/o
		push	cx
		call	iosetup
		pop	cx
		pop	ax

Dptalreadyset:				; ...
		mov	si, offset tracktable
		shl	ax, 1
		shl	ax, 1
		add	si, ax		; CX to	be the number of times we have to loop
					; DX to	be the number of sectors we read on each iteration
		mov	dx, 1
		test	word ptr es:[di+35], 8 ; [es:di+BDS.flags]
					; good_tracklayout
		jz	short ionextsector
		xchg	dx, cx

ionextsector:				; ...
		push	cx
		push	dx
		inc	si
		inc	si		; Skip over the	cylinder and head in
					; the track table
		lodsb			; Get sector ID	from track table
		mov	ds:cursec, al	; assumptions for a fixed disk multi-track disk	i/o
					; 1). In the input CX (# of sectors to go) to TrackIo,
					;     only CL is valid.
					; 2). Sector size should be set	to 512 bytes.
					; 3). Good track layout
		test	word ptr es:[di+35], 1 ; [es:di+BDS.flags]
					; fnon_removable ; Fixed disk?
		jz	short IoRemovable ; No
		test	ds:multrk_flag,	80h ; MULTI_TRK_ON - Allow multi-track operation?
		jz	short IoRemovable ; No,don't do that.
		mov	ds:seccnt, dx
		mov	ax, dx
		call	Disk
		pop	dx
		pop	cx
		clc
		retn
; ---------------------------------------------------------------------------

IoRemovable:				; ...
		lodsb			; Get sector size index	from track
					; table	and save it
		push	ax
		push	si
		push	ds		; Save Bios_Data
		push	ax
		mov	ah, ds:eot	; Preserve whatever might be in	ah
					; Fetch	EOT while ds-> Bios_Data
		lds	si, ds:dpt
		mov	[si+3],	al	; [si+DISK_PARMS.DISK_SECTOR_SIZ]
		mov	[si+4],	ah	; [si+DISK_PARMS.DISK_EOT]
		pop	ax
		pop	ds
		mov	al, dl
		mov	ds:seccnt, ax
		call	Disk
		pop	si		; Advance buffer pointer by adding
					; sector size
		pop	ax
		call	SectorSizeIndexToSectorSize
		add	bx, ax
		pop	dx
		pop	cx
		loop	ionextsector
		cmp	ds:media_set_for_format, 1
		jz	short NoNeedDone
		call	done		; set time of last access, and reset
					; entries in Dpt.

NoNeedDone:				; ...
		clc
		retn
TrackIo		endp


; =============== S U B	R O U T	I N E =======================================


SectSizeToSectIndex proc near		; ...
		cmp	ah, 2		; (0=>128,1=>256,2=>512,3=>1024)
					; examine upper	byte only
		ja	short OneK
		mov	al, ah		; value	in AH is the index!
		retn
; ---------------------------------------------------------------------------

OneK:					; ...
		mov	al, 3
		retn
SectSizeToSectIndex endp


; =============== S U B	R O U T	I N E =======================================


SectorSizeIndexToSectorSize proc near	; ...
		mov	cl, al
		mov	ax, 128
		shl	ax, cl
		retn
SectorSizeIndexToSectorSize endp


; =============== S U B	R O U T	I N E =======================================


SetDasd		proc near		; ...
		cmp	ds:had_format_error, 1 ;
					; See if we've previously set dasd type
		jz	short DoSetDasd
		test	word ptr es:[di+23h], 80h ; [es:di+BDS.flags]
					; set_dasd_true
		jz	short DasdHasBeenSet
		and	word ptr es:[di+23h], 0FF7Fh ; [es:di+BDS.flags]
					; ~set_dasd_true

DoSetDasd:				; ...
		mov	ds:had_format_error, 0
		mov	ds:gap_patch, 50h ; Format gap for 48tpi disks
		mov	al, 4
		cmp	byte ptr es:[di+22h], 2	; [es:di+BDS.formfactor]
					; DEV_3INCH720KB
		jz	short DoSet
		cmp	byte ptr es:[di+22h], 1	; [es:di+BDS.formfactor]
					; DEV_5INCH96TPI
		jz	short GotBig
		mov	al, 1
		jmp	short DoSet
; ---------------------------------------------------------------------------

GotBig:					; ...
		mov	al, 2		; 160/320k in a	1.2 meg	drive
		cmp	ds:mediatype, 0
		jnz	short DoSet
		mov	al, 3		; 1.2meg in a 1.2meg drive
		mov	ds:gap_patch, 54h

DoSet:					; ...
		push	ds
		push	si
		mov	ds, ds:zeroseg	; Point	to interrupt vectors
		assume ds:nothing
		lds	si, ds:78h	; [DSKADR]  (Int 1Eh)
		assume ds:nothing
		mov	byte ptr [si+9], 0Fh ;
					; [si+DISK_PARMS.DISK_HEAD_STTL]
		pop	si
		pop	ds
		mov	ah, 17h
		mov	dl, es:[di+4]
		int	13h		; DISK - DISK -	SET TYPE (AT,XT2,XT286,CONV,PS
					; AL = disk type AL = 03h - high-capacity disk in high-capacity	drive

DasdHasBeenSet:				; ...
		mov	ah, es:[di+13h]	; [es:di+BDS.secpertrack]
		mov	ds:formt_eot, ah
		retn
SetDasd		endp


; =============== S U B	R O U T	I N E =======================================


SetMediaForFormat proc near		; ...
		push	cx
		push	dx
		cmp	ds:had_format_error, 1
		jz	short SkipSaveDskAdr
		xor	al, al		; If already done return 0
		cmp	ds:media_set_for_format, 1
		jnz	short DoSetMediaForFormat
		jmp	SetMediaRet	; Media	already	set
; ---------------------------------------------------------------------------

DoSetMediaForFormat:			; ...
		push	es
		push	si
		mov	es, ds:zeroseg
		assume es:nothing
		les	si, es:78h	; [es:DSKADR]
					; Get pointer to disk base table
		assume es:nothing
		mov	word ptr ds:dpt, si
		mov	word ptr ds:dpt+2, es ;	Save pointer to	table
		mov	byte ptr es:[si+9], 0Fh	; [es:si+DISK_PARMS.DISK_HEAD_STTL]
		pop	si
		pop	es

SkipSaveDskAdr:				; ...
		mov	cx, es:[di+25h]	; [es:di+BDS.cylinders]
		dec	cx
		and	ch, 3
		ror	ch, 1
		ror	ch, 1
		xchg	ch, cl
		or	cl, es:[di+13h]	; [es:di+BDS.secpertrack]
		mov	dl, es:[di+4]	; [es:di+BDS.drivenum]
		push	es
		push	ds
		push	si
		push	di
		mov	ah, 18h
		int	13h		; DISK - SET MEDIA TYPE	FOR FORMAT (AT model 3x9,XT2,XT286,PS)
					; DL = drive number, CH	= lower	8 bits of number of tracks, CL = sectors per track
		jb	short FormaStatErr
		cmp	ds:had_format_error, 1
		jz	short skip_disk_base_setting
		push	es		; Save segment returned	by the rom
		mov	es, ds:zeroseg	; Point	to interrupt vector segment
		assume es:nothing
		les	si, es:78h	; [es:DSKADR] (Int 1Eh)
					; Get current disk base	table
		assume es:nothing
		mov	word ptr ds:tempdpt, si
		mov	word ptr ds:tempdpt+2, es ; Save it
		mov	es, ds:zeroseg
		assume es:nothing
		mov	es:78h,	di
		pop	word ptr es:7Ah	; replace with one returned by rom
		mov	ds:media_set_for_format, 1

skip_disk_base_setting:			; ...
		xor	al, al		; Legal	combination + rom support code
		mov	ds:had_format_error, al	; Reset	the flag
		jmp	short PopStatRet
; ---------------------------------------------------------------------------

FormaStatErr:				; ...
		cmp	ah, 0Ch		; DSK_ILLEGAL_COMBINATION
					; Illegal combination =	0Ch
		jz	short FormatStatIllegalComb
		cmp	ah, 80h		; DSK_TIMEOUT_ERR
		jz	short FormatStatTimeOut
		mov	al, 1		; Function not supported.
		jmp	short PopStatRet
; ---------------------------------------------------------------------------

FormatStatIllegalComb:			; ...
		mov	al, 2		; Function supported, but
					; Illegal sect/trk,trk combination.
		jmp	short PopStatRet
; ---------------------------------------------------------------------------

FormatStatTimeOut:			; ...
		mov	al, 3		; Function supported, but
					; Media	not present.

PopStatRet:				; ...
		pop	di
		pop	si
		pop	ds
		pop	es
		assume es:nothing

SetMediaRet:				; ...
		pop	dx
		pop	cx
		retn
SetMediaForFormat endp


; =============== S U B	R O U T	I N E =======================================


ResetDisk	proc near		; ...
		push	ax
		cmp	ds:media_set_for_format, 1 ; Reset while formatting?
		jnz	short ResetDisk_cont ; Then verify operation in	"fmt & vrfy"
		mov	ds:had_format_error, 1 ; Might have failed.

ResetDisk_cont:				; ...
		xor	ah, ah		; So signals that we had a format error
		int	13h		; DISK - RESET DISK SYSTEM
					; DL = drive (if bit 7 is set both hard	disks and floppy disks reset)
		mov	ds:step_drv, 0FFh ; Zap	up the speed
		pop	ax
		retn
ResetDisk	endp


; =============== S U B	R O U T	I N E =======================================


ToRom		proc near		; ...
		push	bx
		push	si		; Compaq bug fix
		test	ds:media_set_for_format, 1
		jnz	short GotValidDpt
		push	ax
		push	es		; Save bds segment
		cmp	byte ptr es:[di+22h], 2	; [es:di+BDS.formfactor]
					; ffSmall ; is it a 3.5" drive?
		pushf			; (Save	the cmp	result)
		mov	es, ds:zeroseg
		assume es:nothing
		les	si, es:78h	; Get pointer to disk base table
		assume es:nothing
		mov	word ptr ds:dpt, si
		mov	word ptr ds:dpt+2, es ;	 Save pointer to table
		mov	al, ds:formt_eot
		mov	es:[si+4], al	; [es:si+DISK_PARMS.DISK_EOT]
		mov	al, ds:gap_patch
		mov	es:[si+7], al	; [es:si+DISK_PARMS.DISK_FORMT_GAP]
					; Important for	format
		mov	byte ptr es:[si+9], 0Fh	; [es:si+DISK_PARMS.DISK_HEAD_STTL]
					; Assume we are	doing a	seek operation
					; Setup	motor start correctly for 3.5" drives
		popf			; Get result of	earlier	cmp
		jnz	short MotorStrtOK
		mov	byte ptr es:[si+0Ah], 4	; [es:si+DISK_PARMS.DISK_MOTOR_STRT]

MotorStrtOK:				; ...
		pop	es		; Restore bds segment
		pop	ax

GotValidDpt:				; ...
		mov	dx, ds:trknum	; Set track number
		mov	ch, dl		; Set low 8 bits in ch
		mov	dl, es:[di+4]	; Set drive number
		mov	dh, ds:hdnum	; Set head number
		push	es		; Save bds segment
		mov	es, ds:xfer_seg
		int	13h		; DISK -
		pop	es		; Restore bds segment
		pop	si
		pop	bx
		retn
ToRom		endp

; ---------------------------------------------------------------------------

ioctl_getown:
		call	SetDrive
		mov	al, es:[di+4]	; [es:di+BDS.drivenum]
					; Get physical drive number
		les	di, ds:start_bds ; Get start of	bds chain

ownloop:				; ...
		cmp	es:[di+4], al	; [es:di+BDS.drivenum]
		jnz	short getnextBDS
		test	word ptr es:[di+23h], 20h ; [es:di+BDS.flags]
					; fi_own_physical
		jnz	short exitown

getnextBDS:				; ...
		les	di, es:[di]	; [es:di+BDS.link]
		jmp	short ownloop
; ---------------------------------------------------------------------------

ioctl_setown:
		call	SetDrive
		mov	ds:fsetowner, 1	; set flag for CheckSingle to look at.
		call	checksingle
		mov	ds:fsetowner, 0	; set ownership	of drive reset flag

exitown:				; ...
		xor	cl, cl
		test	word ptr es:[di+23h], 10h ; [es:di+BDS.flags]
					; fi_am_mult
		jz	short exitnomult
		mov	cl, es:[di+5]	; [es:di+BDS.drivelet]
					; Get logical drive number
					; Get it 1-based
		inc	cl

exitnomult:				; ...
		lds	bx, ds:ptrsav
		mov	[bx+1],	cl	; [bx+unit]
					; Exit normal termination
		clc
		retn

; =============== S U B	R O U T	I N E =======================================


RestoreOldDpt	proc near		; ...
		push	ax
		xor	al, al
		mov	ds:had_format_error, al	; Reset	flag and get current flag setting
		xchg	al, ds:media_set_for_format
		or	al, al
		jz	short DontRestore
		push	si
		push	ds
		push	es
		lds	si, ds:tempdpt
		mov	es, word ptr cs:aCon+3 ; [cs:Bios_Data_Word]
		assume es:nothing
		mov	es, es:zeroseg
		assume es:nothing
		mov	es:78h,	si	; [es:DSKADR]
		mov	word ptr es:7Ah, ds ; [es:DSKADR+2]
		pop	es
		assume es:nothing
		pop	ds
		pop	si

DontRestore:				; ...
		pop	ax
		clc			;  Clear carry
		retn
RestoreOldDpt	endp

; ---------------------------------------------------------------------------

GetMediaId:
		call	ChangeLineChk
		mov	al, es:[di+5]	; [es:di+BDS.drivelet] ; Logical drive number
		mov	ds:rflag, 2	; Read operation
		call	BootIo		; Read boot sector into	DiskSector
; ---------------------------------------------------------------------------
		jb	short IOCtl_If1
		cmp	ds:disksector+15h, 0F0h	; [disksector+EXT_BOOT.BPB+EBPB.MEDIADESCRIPTOR]
		jb	short IOCtl_If2	; brif not valid (0F0h - 0FFh)
		cmp	ds:disksector+26h, 29h ; [disksector+EXT_BOOT.SIG]
					; EXT_BOOT_SIGNATURE
		jnz	short IOCtl_If2	; not extended boot record
		les	di, ds:ptrsav	; es:di	points to request header
		les	di, es:[bx+19]	; [es:bx+IOCTL_REQ.GENERICIOCTL_PACKET]
		mov	si, (offset disksector+27h) ; disksector+EXT_BOOT.SERIAL
		add	di, 2		; A_MEDIA_ID_INFO.MI_SERIAL
		mov	cx, 23		; size_of_EXT_BOOT_SERIA
					; L+size_of_EXT_BOOT_VOL_LABEL
					; +size_of_EXT_SYSTEM_ID
		rep movsb		; Move from Bios_Data into request packet
		clc
		retn
; ---------------------------------------------------------------------------

IOCtl_If2:				; ...
		mov	al, 7		; error_unknown_media
		stc

IOCtl_If1:				; ...
		retn
; ---------------------------------------------------------------------------

SetMediaId:
		call	ChangeLineChk
		mov	al, es:[di+5]	; [es:di+BDS.drivelet]
					; Logical drive	number
		mov	dl, al
		mov	ds:rflag, 2	; romread
		push	dx
		call	BootIo		; Read boot sec	to Bios_Data:DiskSector
; ---------------------------------------------------------------------------
		pop	dx
		jb	short IOCtl_If6
		cmp	ds:disksector+15h, 0F0h	;  Valid? (0F0h-0FFh?)
					; [disksector+EXT_BOOT.BPB+EBPB.MEDIADESCRIPTOR]
		jb	short IOCtl_If7	; Brif not
		cmp	ds:disksector+26h, 29h ; [disksector+EXT_BOOT.SIG]
					; EXT_BOOT_SIGNATURE
		jnz	short IOCtl_If7	; not extended boot record
		push	es		; Save BDS pointer
		push	di
		push	ds		; Point	ES To boot record
		pop	es
		mov	di, (offset disksector+27h) ; disksector+EXT_BOOT.SERIAL
		lds	si, ds:ptrsav	; ds:si	points to request header.
		lds	si, [si+19]	; [si+IOCTL_REQ.GENERICIOCTL_PACKET]
		add	si, 2		; A_MEDIA_ID_INFO.MI_SERIAL
		mov	cx, 23		; size_of_EXT_BOOT_SERIAL
					; +size_of_EXT_BOOT_VOL_LABEL
					; +size_of_EXT_SYSTEM_ID
		rep movsb
		push	es		; point	ds back	to Bios_Data
		pop	ds
		pop	di		; restore bds pointer
		pop	es
		call	mov_media_ids	; update the bds media id info.
		mov	al, dl
		mov	ds:rflag, 3	; romwrite
		call	BootIo		; write	it back.
; ---------------------------------------------------------------------------
		mov	ds:tim_drv, 0FFh ; make	sure chk_media check the driver
					; return with error code from BootIo
		retn
; ---------------------------------------------------------------------------

IOCtl_If7:				; ...
		mov	al, 7		; error_unknown_media
		stc

IOCtl_If6:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn

BootIo		proc near		; ...
		push	es		; Call DiskIO to read/write the	boot sec.
		push	di
		push	bx
		push	ds
		pop	es
		mov	di, offset disksector ;	es:di -> transfer address
		xor	dx, dx		; First	sector (h) -> 0
		mov	ds:start_sec_h,	dx ; Start sector (h) -> 0
		mov	cx, 1
		call	diskio
		pop	bx
		pop	di
		pop	es
		retn
BootIo		endp


; =============== S U B	R O U T	I N E =======================================


ChangeLineChk	proc near		; ...
		mov	dl, es:[di+4]	; [es:di+BDS.drivenum]
		or	dl, dl		; Fixed	disk?
		js	short ChangeLnChkRet ; Yes, skip it.
		test	word ptr es:[di+23h], 4	; [es:di+BDS.flags]
					; return_fake_bpb
		jnz	short ChangeLnChkRet
		cmp	ds:fhave96, 1	; This rom support change line?
		jnz	short ChangeLnChkRet
		call	haschange	; This drive support change line?
		jz	short ChangeLnChkRet ; Do nothing
		mov	ah, 16h
		int	13h		; DISK - FLOPPY	DISK - CHANGE OF DISK STATUS (AT,XT2,XT286,CONV,PS)
					; DL = drive to	check
					; Return: AH = disk change status
		jnb	short ChangeLnChkRet
		push	bx
		mov	bx, 40h		; fchanged
					; Update flag in BDS for this
					; physical drive
		call	set_changed_dl
		pop	bx

ChangeLnChkRet:				; ...
		retn
ChangeLineChk	endp

; ---------------------------------------------------------------------------

GetAccessFlag:				; DS:BX	points to request header
		lds	bx, ds:ptrsav
		lds	bx, [bx+19]	; [bx+IOCTL_REQ.GENERICIOCTL_PACKET]
		mov	al, 0		; Assume result	is unformatted
		test	word ptr es:[di+35], 200h ; [es:di+BDS.flags]
					; unformatted_media
		jnz	short GafDone	; Done if unformatted
		inc	al		; Return true for formatted

GafDone:				; ...
		mov	[bx+1],	al	; [bx+A_DISKACCESS_CONTROL.DAC_ACCESS_FLAG]
		retn
; ---------------------------------------------------------------------------

SetAccessFlag:				; ES:BX	points to request header
		lds	bx, ds:ptrsav
		lds	bx, [bx+19]	; [bx+IOCTL_REQ.GENERICIOCTL_PACKET]
		and	word ptr es:[di+35], 0FDFFh ; es:di+BDS.flags]
					; ~unformatted_media
		cmp	byte ptr [bx+1], 0 ; [bx+A_DISKACCESS_CONTROL.DAC_ACCESS_FLAG]
		jnz	short saf_Done
		or	word ptr es:[di+35], 200h ; [es:di+BDS.flags]
					; unformatted_media

saf_Done:				; ...
		retn
; ---------------------------------------------------------------------------

ioctl_support_query:
		push	es
		les	bx, ds:ptrsav
		mov	ax, es:[bx+13]	; [es:bx+IOCTL_REQ.MAJORFUNCTION]
					; AL ==	Major, AH == Minor
		cmp	al, 8		; IOC_DC
					; See if major code is 8
		jnz	short nosupport
		push	cs
		pop	es
		assume es:DOSBIOS
		mov	cx, 11		; IOC_DC_TABLE_LEN
		mov	di, 0C60h	; IOC_DC_Table
					; at 2C7h:0C60h	= 70h:31D0h
		xchg	al, ah		; Put minor code in AL
		repne scasb		; Scan for minor code in AL
		jnz	short nosupport	; it was not found
		mov	ax, 100h
		jmp	short $+2	; ioctlsupexit
					; Signal ioctl is supported
; ---------------------------------------------------------------------------

ioctlsupexit:				; ...
		pop	es
		assume es:nothing
		clc
		retn
; ---------------------------------------------------------------------------

nosupport:				; ...
		pop	es
		jmp	bc_cmderr
; ---------------------------------------------------------------------------

SenseMediaType:				; DS:BX	points to request header.
		lds	bx, ds:ptrsav
		lds	bx, [bx+19]	; bx+IOCTL_REQ.GENERICIOCTL_PACKET]
		mov	word ptr [bx], 0 ; Initialize the 2 packet bytes
		mov	dl, es:[di+4]	; [es:di+BDS.drivenum]
					; Get int 13h drive number from	BDS
		xor	dh, dh		; DX = physical	drive number
		mov	ah, 20h		; Get Media Type function
					; If no	carry media type in AL
		int	13h		; DISK - QCACHE	- DISMOUNT
		jb	short MediaSenseEr ; error code	in AH
		inc	byte ptr [bx]	; Signal media type is default (bit 1)

DetermineMediaType:			; ...
		dec	al
		cmp	al, 2		;  Chk for 720K	ie: (3-1) = 2
		jz	short GotMediaType
		add	al, 4
		cmp	al, 7		;  Chk for 1.44M  ie: (4-1+4) =	7
		jz	short GotMediaType
		cmp	al, 9		; Chk for 2.88M	 ie: (6-1+4) =	9
		jnz	short UnknownMediaType ; Just didn't recognize media type

GotMediaType:				; ...
		mov	[bx+1],	al	; Save the return value
		clc			; Signal success
		retn
; ---------------------------------------------------------------------------

MediaSenseEr:				; ...
		cmp	ah, 32h		; See if not default media error
		jz	short DetermineMediaType ; Not really an error
		mov	al, 2		; Now assume drive not ready
		cmp	ah, 31h		; See if media was present
		jz	short SenseErrExit ; Return drive not ready

UnknownMediaType:			; ...
		mov	al, 7		; Just don't know the media type

SenseErrExit:				; ...
		mov	ah, 81h		; Signal error return
		stc
		retn
; ---------------------------------------------------------------------------
		db    0
; ---------------------------------------------------------------------------

i2f_handler:				; here is 02C7h:1302h =	0070h:3872h
		cmp	ah, 13h
		jz	short int2f_replace_int13
		cmp	ah, 8
		jz	short mine
		cmp	ah, 16h		; MultWin386
		jz	short win386call
		cmp	ah, 4Ah		; multMULT
		jnz	short i2f_handler_iret
		jmp	handle_multmult
; ---------------------------------------------------------------------------

i2f_handler_iret:			; ...
		iret
; ---------------------------------------------------------------------------

int2f_replace_int13:			; ...
		push	ax
		mov	ax, ds
		mov	ds, word ptr cs:aCon+3 ; [cs:BiosDataWord]
					; = [02C7h:0030h] = [0070h:25A0h]
		assume ds:nothing
		push	word ptr ds:Orig13
		push	word ptr ds:Orig13+2
		push	word ptr ds:Old13
		push	word ptr ds:Old13+2
		mov	word ptr ds:Orig13, dx
		mov	word ptr ds:Orig13+2, ax
		mov	word ptr ds:Old13, bx
		mov	word ptr ds:Old13+2, es
		pop	es
		pop	bx
		pop	ds
		assume ds:nothing
		pop	dx
		pop	ax

i2f_iret:				; ...
		iret
; ---------------------------------------------------------------------------

mine:					; ...
		cmp	al, 0F8h
		jnb	short i2f_iret
		or	al, al
		jnz	short disp_func
		mov	al, 0FFh
		jmp	short i2f_iret
; ---------------------------------------------------------------------------

disp_func:				; ...
		cmp	al, 1
		jz	short do_subfun_01
		cmp	al, 3
		jz	short do_get_bds_vector
		push	ds
		mov	ds, word ptr cs:aCon+3 ; [cs:Bios_Data_Word]
					; = [0070h:25A0h] = [02C7h:0030h]
		assume ds:nothing
		mov	word ptr ds:ptrsav, bx
		mov	word ptr ds:ptrsav+2, es
		pop	ds
		assume ds:nothing
		jmp	far ptr	i2f_dskentry
; ---------------------------------------------------------------------------

do_subfun_01:				; ...
		push	es
		push	ds
		push	ds
		pop	es
		mov	ds, word ptr cs:aCon+3 ; [cs:Bios_Data_Word]
					; point	ds: -> Bios_Data
		assume ds:nothing
		call	install_bds
		pop	ds
		assume ds:nothing
		pop	es
		jmp	short i2f_iret
; ---------------------------------------------------------------------------

do_get_bds_vector:			; ...
		mov	ds, word ptr cs:aCon+3 ; [cs:Bios_Data_Word]
		assume ds:nothing
		lds	di, ds:start_bds
		assume ds:nothing

ii2f_iret:				; ...
		jmp	short i2f_iret
; ---------------------------------------------------------------------------

win386call:				; ...
		push	ds
		mov	ds, word ptr cs:aCon+3 ; [cs:Bios_Data_Word]
					; at 2C7h:30h =	70h:25A0h
		assume ds:nothing
		cmp	al, 5		; Win386_Init
					; is it	win386 initializing?
		jz	short Win386Init
		cmp	al, 6		; Win386_Exit
					; is it	win386 exiting?
		jnz	short win_iret	; if not, continue int2f chain
		test	dx, 1		; is it	win386 or win286 dos extender?
		jnz	short win_iret	; if not win386, then continue
		and	ds:IsWin386, 0	; indicate that	win386 is not present
		jmp	short win_iret
; ---------------------------------------------------------------------------

Win386Init:				; ...
		test	dx, 1		; is it	win386 or win286 dos extender?
		jnz	short win_iret	; if not win386, then continue
		or	ds:IsWin386, 1	; Indicate WIN386 present
		mov	word ptr ds:SI_Next, bx	; Hook our structure into chain
		mov	word ptr ds:SI_Next+2, es
		mov	bx, offset Win386_SI ; point ES:BX to Win386_SI
		push	ds
		pop	es
		assume es:nothing

win_iret:				; ...
		pop	ds
		assume ds:nothing
		jmp	short i2f_iret	; return back up the chain
; ---------------------------------------------------------------------------

handle_multmult:			; ...
		cmp	al, 1
		jnz	short try_2
		push	ds
		call	HMAPtr
		mov	bx, 0FFFFh
		mov	es, bx
		assume es:nothing
		mov	bx, di
		not	bx
		or	bx, bx
		jz	short try_1
		inc	bx

try_1:					; ...
		pop	ds
		jmp	short ii2f_iret
; ---------------------------------------------------------------------------

try_2:					; ...
		cmp	al, 2		; multMULTALLOCHMA
		jnz	short try_3
		push	ds
		mov	di, 0FFFFh
		mov	es, di
		call	HMAPtr
		cmp	di, 0FFFFh
		jz	short InsuffHMA
		neg	di
		cmp	bx, di
		jbe	short try_4
		mov	di, 0FFFFh
		jmp	short InsuffHMA
; ---------------------------------------------------------------------------

try_4:					; ...
		mov	di, ds:FreeHMAPtr
		add	bx, 15
		and	bx, 0FFF0h
		add	ds:FreeHMAPtr, bx
		jnz	short InsuffHMA
		mov	ds:FreeHMAPtr, 0FFFFh

InsuffHMA:				; ...
		pop	ds
		jmp	ii2f_iret
; ---------------------------------------------------------------------------

try_3:					; ...
		jmp	ii2f_iret

; =============== S U B	R O U T	I N E =======================================


HMAPtr		proc near		; ...
		mov	ds, word ptr cs:aCon+3 ; [cs:Bios_Data_Word]
		assume ds:nothing
		mov	di, ds:FreeHMAPtr
		cmp	di, 0FFFFh
		jnz	short HMAPtr_retn
		cmp	ds:SysinitPresent, 0
		jz	short HMAPtr_retn
		call	ds:MoveDOSIntoHMA ; call far [MoveDOSIntoHMA]
		mov	di, ds:FreeHMAPtr

HMAPtr_retn:				; ...
		retn
HMAPtr		endp


; =============== S U B	R O U T	I N E =======================================


move_sector	proc near		; ...
		cld
		push	cx
		mov	cx, 256
		cmp	si, 0FE00h
		ja	short movsec_bytes
		cmp	di, 0FE00h
		ja	short movsec_bytes
		rep movsw
		pop	cx
		retn
; ---------------------------------------------------------------------------

movsec_bytes:				; ...
		shl	cx, 1
		rep movsb
		pop	cx
		retn
move_sector	endp


; =============== S U B	R O U T	I N E =======================================


check_wrap	proc near		; ...
		push	ax
		push	bx
		push	es
		push	di
		call	find_bds
		jb	short no_wrap
		test	word ptr es:[di+23h], 1	; word [es:di+BDS.flags],fnon_removable
		jz	short no_wrap
		mov	bx, es:[di+13h]	; [es:di+BDS.secpertrack]
		mov	ax, cx
		and	ax, 3Fh		; extract sector number
		cmp	ax, bx		; are we going to wrap?
		jbe	short no_wrap
		div	bl		; ah=new sector	#, al=#	of head	wraps
		or	ah, ah		; if the new sector # is 0,
					; it is	the last sector	on that	track.
		jnz	short not_on_bound
		mov	ah, bl		; set sector=BDS_BPB.BPB_SECTORSPERTRACK
					; if on	boundary
		dec	al		; also decrement # of head wraps

not_on_bound:				; ...
		and	cl, 0C0h	; zero out sector #
		or	cl, ah		; or in	new sector #
		xor	ah, ah		; ax = # of head wraps
		inc	ax
		add	al, dh		; add in starting head #
		adc	ah, 0		; catch	any carry
		cmp	ax, es:[di+15h]	; [es:di+BDS.heads]
					; are we going to wrap around a	head?
		jbe	short no_wrap_head ; do	not lose new head number!!
		push	dx
		xor	dx, dx
		mov	bx, es:[di+15h]	; [es:di+BDS.heads]
		div	bx		; dx=new head #, ax=# of cylinder wraps
		or	dx, dx		; if new head #	is 0,
					; it is	the last head.
		jnz	short no_head_bound
		mov	dx, bx		; on boundary. set to BDS_BPB.BPB_HEADS
		or	ax, ax
		jz	short no_head_bound
		dec	ax		; reduce number	of cylinder wraps

no_head_bound:				; ...
		mov	bh, dl		; bh has new head number
		pop	dx
		dec	bh		; get it 0-based
		mov	dh, bh		; set up new head number in dh
		mov	bh, cl
		and	bh, 3Fh		; preserve sector number
		mov	bl, 6
		xchg	cl, bl
		shr	bl, cl		; get ms cylinder bits to ls end
		add	ch, al		; add in cylinder wrap
		adc	bl, ah		; add in high byte
		shl	bl, cl		; move up to ms	end
		xchg	bl, cl		; restore cylinder bits	into cl
		or	cl, bh		; or in	sector number

no_wrap:				; ...
		clc
		pop	di
		pop	es
		assume es:nothing
		pop	bx
		pop	ax
		retn
; ---------------------------------------------------------------------------

no_wrap_head:				; ...
		mov	dh, al		; do not lose new head number
		dec	dh		; get it 0-based
		jmp	short no_wrap
check_wrap	endp


; =============== S U B	R O U T	I N E =======================================


find_bds	proc near		; ...
		les	di, ds:start_bds

fbds_1:					; ...
		cmp	es:[di+4], dl	; [es:di+BDS.drivenum]
		jz	short fdbs_2
		les	di, es:[di]	; [es:di+BDS.link]
		cmp	di, 0FFFFh
		jnz	short fbds_1
		stc

fdbs_2:					; ...
		retn
find_bds	endp


; =============== S U B	R O U T	I N E =======================================


doint		proc near		; ...
		mov	dl, [bp+8]	; [bp+INT13FRAME.olddx]
					; get physical drive number
		xor	ah, ah
		or	al, al
		jz	short dointdone	; if zero sectors, return ax=0
		mov	ah, [bp+3]	; [bp+INT13FRAME.oldax+1]
					; get request code
		push	word ptr [bp+10h] ; [bp+INT13FRAME.oldf]
		popf
		call	call_orig13	; call far 70h:797h
					; call far KERNEL_SEGMENT:call_orig13
		pushf
		pop	word ptr [bp+10h] ; [bp+INT13FRAME.oldf]

dointdone:				; ...
		retn
doint		endp

; ---------------------------------------------------------------------------
dtype_array	dd 400090h		; 40:90	is drive type array
; ---------------------------------------------------------------------------

format_special_stuff:			; ...
		cmp	ds:fhave96, 0
		jz	short format_special_stuff_done
		push	bx
		mov	bx, 140h	; fchanged_by_format+fchanged
		call	set_changed_dl
		pop	bx
		jmp	short format_special_stuff_done
; ---------------------------------------------------------------------------

ec35_special_stuff:			; ...
		test	dl, dl
		js	short ec35_special_stuff_done ;	if hard	drive, we're done
		push	ax
		push	cx
		mov	cl, dl		; turn drive number into bit map
		mov	al, 1		; assume drive 0
		shl	al, cl		; shift	over correct number of times
		test	ds:ec35flag, al
		pop	cx
		pop	ax
		jz	short ec35_special_stuff_done ;
					; done if this floppy is not an	ec35
		push	bx		; free up a far	pointer	(es:bx)
		push	es
		les	bx, dword ptr cs:loc_1BF2+3 ; [cs:dtype_array]
					; 0070h:3A65h =	2C7h:14F5h
		add	bl, dl
		adc	bh, 0
		mov	byte ptr es:[bx], 93h ;	establish drive	type as:
					; (360k	disk in	360k drive,
					; no double-stepping, 250 kbs transfer rate)
		pop	es
		pop	bx
		jmp	short ec35_special_stuff_done
; ---------------------------------------------------------------------------

ps2_special_stuff:			; ...
		cmp	ds:prevoper, 8	; (ps2_30)
					; read driver parm ?
		jz	short ps2_30_problem
		cmp	ds:prevoper, 15h ; apparently function 15h fails, too
		jnz	short ps2_special_stuff_done

ps2_30_problem:				; ...
		push	ax
		mov	ah, 1
		call	call_orig13	; call far 70:797h
					; call far KERNEL_SEGMENT:call_orig13
		pop	ax
		jmp	short ps2_special_stuff_done
; ---------------------------------------------------------------------------

i13z:					; 0070h:3ABBh =	02C7h:154Bh
		push	ds
		mov	ds, word ptr cs:aCon+3 ; [cs:BiosdataWord]
					; = [02C7h:0030h] = [0070h:25A0h]
		mov	ds:prevoper, ax
		cmp	ah, 5		; romformat
		jz	short format_special_stuff

format_special_stuff_done:		; ...
		cmp	ds:ec35flag, 0
		jnz	short ec35_special_stuff

ec35_special_stuff_done:		; ...
		call	call_orig13
		pushf
		cmp	ds:model_byte, 0FAh ; 'ú'
		jz	short ps2_special_stuff

ps2_special_stuff_done:			; ...
		popf
		jb	short goterr13	; error	on original orig13 call-thru?

ret_from_i13:				; ...
		pop	ds
		assume ds:nothing
		retf	2		; restore ds & iret w/flags
; ---------------------------------------------------------------------------

i13ret_ck_chglinerr:			; ...
		jnb	short ret_from_i13 ; done if not an error termination

i13_ret_error:				; ...
		cmp	ah, 6		; did i	see a change event?
		jnz	short int13b	; skip if wrong	error
		or	dl, dl		; is this for the hard disk?
		js	short int13b	; yes, ignore
		cmp	ds:fhave96, 0
		jz	short int13b	; just in case ROM returned this
					; error	even though it told us it
					; never	would
		push	bx
		mov	bx, 40h		; fchanged
		call	set_changed_dl
		pop	bx

int13b:					; ...
		stc
		jmp	short ret_from_i13
; ---------------------------------------------------------------------------

goterr13:				; ...
		cmp	ah, 9		; dma error?
		jz	short gotdmaerr

goterr13_xxxx:				; ...
		cmp	ah, 11h		; ecc error?
		jnz	short i13_ret_error ; other error. just	return back.
		cmp	ds:media_set_for_format, 1 ; formatting?
		jz	short i13_ret_error
		cmp	byte ptr ds:prevoper+1,	2 ; ecc-corrected error
					; (2 = romread)
					; ECC correction only applies to reads
		jnz	short i13_ret_error
		xor	ah, ah
		call	call_orig13	; call far KERNEL_SEGMENT:call_orig13
					; call far 70:797h
		mov	ax, ds:prevoper
		xor	ah, ah		; return code =	no error
		cmp	al, 1		; if request for one sector, assume ok
		jz	short ret_from_i13 ; return with carry clear
		push	bx
		push	cx
		push	dx
		mov	ds:number_of_sec, al

loop_ecc:				; ...
		mov	ax, 201h	; read one sector
		call	check_wrap	; get correct parameters for int 13
		call	call_orig13	; call far KERNEL_SEGMENT:call_orig13
		jnb	short ok11_op
		cmp	ah, 9		; DMA error during ECC read?
		jz	short handle_dma_during_ecc
		cmp	ah, 11h		; only allow ecc errors
		jnz	short ok11_exit_err
		mov	ah, 0		; ecc error. reset the system again.
		xor	ax, ax		; clear	the error code so that if this
					; was the last sector, no error	code
					; will be returned for the corrected
					; read.	(clear carry too.)

ok11_op:				; ...
		dec	ds:number_of_sec
		jz	short ok11_exit	; all done?
		inc	cl		; advance sector number
					; add 200h to address
		inc	bh
		inc	bh
		jmp	short loop_ecc
; ---------------------------------------------------------------------------

ok11_exit_err:				; ...
		stc

ok11_exit:				; ...
		pop	dx
		pop	cx
		pop	bx
		jmp	short i13ret_ck_chglinerr
; ---------------------------------------------------------------------------

handle_dma_during_ecc:			; ...
		push	es
		push	bx
		mov	bx, offset disksector
		push	ds
		pop	es
		mov	ax, 201h
		call	call_orig13	; call far KERNEL_SEGMENT:call_orig13
		pop	bx
		pop	es
		jnb	short handle_dma_during_ecc_noerr
		cmp	ah, 11h
		jnz	short ok11_exit_err ; if anything but ecc error, bomb out

handle_dma_during_ecc_noerr:		; ...
		push	si		; kosher
		push	di
		mov	di, bx
		mov	si, offset disksector
		call	move_sector
		pop	di
		pop	si
		jmp	short ok11_op
; ---------------------------------------------------------------------------

gotdmaerr:				; ...
		mov	ax, ds:prevoper	; dma violation
		sti
		cmp	ah, 2		; romread
		jb	short i13_done_dmaerr
		cmp	ah, 4		; romverify
		jz	short intverify
		cmp	ah, 5		; romformat
		jz	short intformat
		ja	short i13_done_dmaerr
		push	dx
		push	cx
		push	bx
		push	ax
		push	bp
		mov	bp, sp
		mov	dx, es		; check	for 64k	boundary error
		shl	dx, 1
		shl	dx, 1
		shl	dx, 1
		shl	dx, 1		; segment converted to absolute	address
		add	dx, bx		; combine with offset
		add	dx, 511		; simulate a transfer
					; if carry is set,
					; then we are within 512 bytes of
					; the end of the segment
		jnb	short no_skip_first
		jmp	bufferx		; restore dh=head & do buffer
; ---------------------------------------------------------------------------

no_skip_first:				; ...
		shr	dh, 1		; dh = number of sectors before	address
		mov	ah, 128		; ah = max number of sectors in	segment
		sub	ah, dh
		cmp	ah, al		; can we fit it	in?
		jb	short doblock	; no, perform blocking.
		mov	dh, [bp+9]	; [bp+INT13FRAME.olddx+1]
					; set up head number
		call	doint
		jmp	bad13		; and return from this place
; ---------------------------------------------------------------------------

i13_done_dmaerr:			; ...
		mov	ah, 9		; pass dma error thru to caller
		stc
		jmp	ret_from_i13	; return with error,
					; we know it's not a changeline error
; ---------------------------------------------------------------------------

intverify:				; ...
		push	es		; save caller's dma address
		push	bx
		push	ds		; es:bx	-> Bios_Data:disksector
		pop	es

dosimple:				; ...
		mov	bx, offset disksector
		call	call_orig13	; call far KERNEL_SEGMENT:call_orig13
		pop	bx
		pop	es
		jmp	i13ret_ck_chglinerr
; ---------------------------------------------------------------------------

intformat:				; ...
		push	es
		push	bx
		push	si
		push	di
		push	ds
		push	es
		push	ds
		pop	es
		pop	ds
		mov	si, bx
		mov	di, offset disksector
		call	move_sector	; user's data into Bios_Data:disksector
		pop	ds
		pop	di
		pop	si		; do the i/o from
		jmp	short dosimple	; Bios_Data:disksector
; ---------------------------------------------------------------------------

doblock:				; ...
		mov	dx, [bp+8]	; we can't fit the request into the entire block.
					; perform the operation	on the first block
					; [bp+INT13FRAME.olddx]
					; get head #, drive #
		push	cx
		push	es
		push	di		; ah - # of sectors before dma boundary
					; al - requested # of sectors for i/o.
		call	find_bds
		mov	cx, es:[di+13h]	; [es:di+BDS.secpertrack]
		test	word ptr es:[di+23h], 1	; [es:di+BDS.flags],fnon_removable
		pop	di
		pop	es
		mov	al, ah		; set al=ah for	floppies
		jz	short doblockflop ; they are track by track operation
		mov	ah, 63		; ah = 63-secpt	(# safe	sectors??)
		sub	ah, cl		; al - # of sectors before dma boundary

doblockflop:				; ...
		pop	cx

doblockcontinue:			; ...
		cmp	ah, al		; if safe_# >= #_of_sectors_to_go_before dma,
		jnb	short doblocklast ; then #_of_sectors_to_go as it is for doint.
		push	ax
		mov	al, ah		; otherwise, set al to ah to operate.
		jmp	short doblockdoint
; ---------------------------------------------------------------------------

doblocklast:				; ...
		mov	ah, al
		push	ax

doblockdoint:				; ...
		call	doint		; let ah = al =	# of sectors for this shot
		jb	short bad13	; something happened, bye!
		pop	ax
		sub	[bp+2],	ah	; sub [bp+INT13FRAME.oldax], ah
					; decrement by the successful operation
		add	cl, ah		; advance sector #. safety gauranteed.
		add	bh, ah		; advance dma addres
		add	bh, ah		; twice	for 512	byte sectors
		cmp	ah, al		; check	the previous value
		jz	short buffer	; if #_of_sectors_to_go	< safe_#,
					; then we are done already.
		sub	al, ah		; otherwise,
					; #_sector_to_go = #_of_sector_to_go - safe_#
		call	check_wrap	; get new cx, dh for the next operation.
		jmp	short doblockcontinue ;	handles	next sectors left.
; ---------------------------------------------------------------------------

bufferx:				; ...
		mov	dh, [bp+9]	; [bp+INT13FRAME.olddx+1]
					; set up head number

buffer:					; ...
		push	bx
		mov	ah, [bp+3]	; [bp+INT13FRAME.oldax+1]
		cmp	ah, 3		; romwrite
		jnz	short doread	;
					; copy the offending sector into local buffer
		push	es
		push	ds
		push	si
		push	di
		push	ds
		push	es
		pop	ds
		pop	es
		mov	di, offset disksector
		push	di
		mov	si, bx
		call	move_sector	; move sector into local buffer
		pop	bx		; new transfer address
					; (es:bx = Bios_Data:diskbuffer)
		pop	di
		pop	si
		pop	ds
		mov	al, 1		; [bp+INT13FRAME.olddx]
					; get drive number
		mov	dl, [bp+8]
		call	check_wrap	; sets up registers if wrap-around
					;
					; ah is	function
					; al is	1 for single sector transfer
					; es:bx	is local transfer addres
					; cx is	track/sector number
					; dx is	head/drive number
					; si,di	unchanged
		call	doint
		pop	es
		jb	short bad13
		jmp	short dotail
; ---------------------------------------------------------------------------

doread:					; ...
		push	es
		push	bx
		push	ds
		pop	es
		mov	bx, offset disksector
		mov	al, 1
		mov	dl, [bp+8]	; [bp+INT13FRAME.olddx]
					; get drive number
		call	check_wrap	;
					; ah = function
					; al = 1 for single sector
					; es:bx	points to local	buffer
					; cx, dx are track/sector, head/drive
		call	doint
		pop	bx
		pop	es
		jb	short bad13
		push	si
		push	di
		mov	di, bx
		mov	si, offset disksector
		call	move_sector
		pop	di
		pop	si

dotail:					; ...
		pop	bx		; retrieve new dma area
		add	bh, 2		; advance over sector
		inc	cx
		mov	al, [bp+2]	; [bp+INT13FRAME.oldax]
		clc
		dec	al
		jz	short bad13
		mov	dl, [bp+8]	; [bp+INT13FRAME.olddx]
		call	check_wrap
		call	doint

bad13:					; ...
		mov	sp, bp
		pop	bp
		pop	bx
		pop	bx
		pop	cx
		pop	dx
		jb	short xgoterr13_xxxx ; go handle ECC errors
		jmp	ret_from_i13	; non-error exit
; ---------------------------------------------------------------------------

xgoterr13_xxxx:				; ...
		jmp	goterr13_xxxx
; ---------------------------------------------------------------------------
		db    0
; ---------------------------------------------------------------------------

dsk_init:				; 2C7h:1742h = 70h:3CB2h
		mov	ah, ds:drvmax
		mov	di, offset dskdrvs
		push	ds		; pass result in es:di
		pop	es
		jmp	SetPtrSav

; =============== S U B	R O U T	I N E =======================================


install_bds	proc near		; ...
		push	ds		; install_bds installs a bds at	location es:di
					; into the current linked list of bds
					; maintained by	this device driver. it places
					; the bds at the end of	the list.
					; Trashes (at least) ax, bx, di, si
		mov	si, offset start_bds

loop_next_bds:				; ...
		lds	si, [si]	; [si+BDS.link]
					; fetch	next bds
		mov	al, es:[di+4]	; [es:di+BDS.drivenum]
		cmp	[si+4],	al	; does this one	share a	physical
					; drive	with new one?
		jnz	short next_bds
		mov	bl, 10h		; fi_am_mult
		or	es:[di+23h], bl	; [es:di+BDS.flags]
					; set both of them to i_am_mult	if so
		or	[si+23h], bl	; [si+BDS.flags]
		and	byte ptr es:[di+23h], 0DFh ; [es:di+BDS.flags],~fi_own_physical
					; we don't own it
		mov	bl, [si+23h]	; [si+BDS.flags]
					; determine if changeline available
		and	bl, 2		; fchangeline
		or	es:[di+23h], bl	; [es:di+BDS.flags]

next_bds:				; ...
		cmp	word ptr [si], 0FFFFh ;	[si+BDS.link],-1
					; are we at end	of list?
		jnz	short loop_next_bds
		mov	word ptr [si+2], es ; [si+BDS.link+2],es
					; install bds
		mov	[si], di
		mov	word ptr es:[di], 0FFFFh ; [es:di+BDS.link],-1
					; set next pointer to null
		pop	ds
		retn
install_bds	endp

; ---------------------------------------------------------------------------

swpdsk:					; ...
		test	ds:IsWin386, 1	; Is win386 present?
		jz	short no_win386	; no, skip SetFocus
		call	far ptr	V86_Crit_SetFocus ; call far 70h:8D1h
					; call far KERNEL_SEGMENT:V86_Crit_SetFocus

no_win386:				; ...
		push	cx
		push	dx
		mov	dl, es:[di+5]	; [es:di+BDS.drivelet]
					; get the drive	letter
		mov	dh, dl
		xor	dh, 1
		sub	cx, cx		; nobody has handled swap disk
		mov	ax, 4A00h	; multMULT<<8)|multMULTSWPDSK
					; broad	cast code for swap disk
					; Broadcast it
		int	2Fh
		inc	cx
		jz	short swpdsk9	; somebody has handled it
		add	dl, 'A'
		mov	byte ptr cs:off_1EE4, dl ; [cs:drvlet]
					; 0070h:3D54h =	2C7h:17E4h
		mov	si, 17C8h	; sngmsg
					; 0070h:3D38h =	2C7h:17C8h
		push	bx
		lods	byte ptr cs:[si]

wrmsg_loop:				; ...
		int	29h		; DOS 2+ internal - FAST PUTCHAR
					; AL = character to display
		lods	byte ptr cs:[si] ; cs lodsb
					; get the next character of the	message
		or	al, al
		jnz	short wrmsg_loop
		call	con_flush
		xor	ah, ah
		int	16h		; KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY
					; Return: AH = scan code, AL = character
		pop	bx

swpdsk9:				; ...
		pop	dx
		pop	cx
		retn
; ---------------------------------------------------------------------------
sngmsg		db 0Dh,0Ah
		db 'Insert diskette for drive '
drvlet		db 'A: and press any key when ready',0Dh,0Ah
		db 0Ah,0

; =============== S U B	R O U T	I N E =======================================


chkopcnt	proc near		; ...
		cmp	word ptr es:[di+20h], 0	; [es:di+BDS.opcnt]
		retn
chkopcnt	endp


; =============== S U B	R O U T	I N E =======================================


mediacheck	proc near		; ...
		call	checksingle	; make sure correct disk is in place
		xor	si, si
		call	haschange
		jz	short mediaret
		call	checkromchange
		jnz	short mediadovolid
		push	ax
		push	dx
		mov	dl, es:[di+4]	; [es:di+BDS.drivenum]
					; set logical drive number
		mov	ah, 16h
		int	13h		; DISK - FLOPPY	DISK - CHANGE OF DISK STATUS (AT,XT2,XT286,CONV,PS)
					; DL = drive to	check
					; Return: AH = disk change status
		pop	dx
		pop	ax
		jb	short mediadovolid
		mov	si, 1		; signal no change
		mov	bl, ds:tim_drv	; get last drive accessed
		cmp	es:[di+4], bl	; [es:di+BDS.drivenum]
					; (If the last drive accessed is not current drive
					; media	change status may be incorrect.	So,
					; "I don't now" will be returned even if it is indicated
					; as media is not changed.)
		jz	short mediaret	; (same	drive,
					; media	changeline indication is reliable)
		push	ax
		push	cx
		push	dx
		call	Check_Time_Of_Access
		pop	dx
		pop	cx
		pop	ax
		or	si, si
		jz	short mediadovolid ; check_time	says ">= 2 secs	passed"
					; (volume id will be checked)
		xor	si, si		; return "i don't know"

mediaret:				; ...
		retn
; ---------------------------------------------------------------------------

mediadovolid:				; ...
		call	GetBp		; build	a new bpb in current bds
		jb	short mediaret
		call	check_vid
		jnb	short mediaret
mediacheck	endp

		jmp	maperror	; fix up al for	return to dos
; ---------------------------------------------------------------------------

checklatchio:				; ...
		call	chkopcnt	; if returning fake bpb
					; then assume the disk has not changed
		jz	short checkret
		call	checkromchange	; check	for past rom indications.
					; if no	rom change indicated, then return ok.
		jz	short checkret
		call	GetBp		; build	bpb in current bds
		jb	short ret_no_error_map ; getbp has already called maperror
		call	check_vid
		jb	short checklatchret ; disk error trying	to read	in.
		or	si, si		; is changed for sure?
		jns	short checkret
		call	returnvid

checklatchret:				; ...
		call	maperror	; fix up al for	return to dos

ret_no_error_map:			; ...
		stc
		pop	si		; pop off return address

checkret:				; ...
		retn
; ---------------------------------------------------------------------------

checkfatvid:				; ...
		call	fat_check	; check	the fat	and the	vid
		or	si, si
		js	short changed_drv ;
					; the fat was the same.
					; fall into check_vid and check	volume id.

; =============== S U B	R O U T	I N E =======================================


check_vid	proc near		; ...
		cmp	ds:disksector+26h, 29h ; [disksector+EXT_BOOT.SIG]
					; EXT_BOOT_SIGNATURE
		jz	short do_ext_check_id
		call	haschange
		jz	short checkret
		xor	si, si
		cmp	ds:disksector+10h, 0 ; [disksector+EXT_BOOT.BPB+EBPB.NUMBEROFFATS]
		jz	short checkfatret ; don't read vol id
					; if not fat system
		call	read_volume_id
		jb	short checkfatret
		call	check_volume_id
		mov	si, 0FFFFh	; -1
					; definitely changed
		jnz	short changed_drv
		inc	si		; not changed

vid_no_changed:				; ...
		call	resetchanged
		clc

checkfatret:				; ...
		retn
; ---------------------------------------------------------------------------

changed_drv:				; ...
		clc			; cas -- return	no error
		mov	ds:tim_drv, 0FFh ; ensure that we ask rom for media
		retn			; check	next time round
; ---------------------------------------------------------------------------

do_ext_check_id:			; ...
		push	ax
		mov	ax, word ptr ds:disksector+27h ; [DiskSector+EXT_BOOT.SERIAL]
		cmp	ax, es:[di+57h]	; [di+BDS.vol_serial]
		jnz	short ext_changed
		mov	ax, word ptr ds:disksector+29h ; [DiskSector+EXT_BOOT.SERIAL+2]
		cmp	ax, es:[di+59h]	; [di+BDS.vol_serial+2]
		jnz	short ext_changed
		xor	si, si		; 0
					; don't know
		pop	ax
		jmp	short vid_no_changed ; reset the flag
; ---------------------------------------------------------------------------

ext_changed:				; ...
		pop	ax
		mov	si, 0FFFFh	; -1
					; disk changed!
		clc
		jmp	short changed_drv
check_vid	endp

; ---------------------------------------------------------------------------

checkio:				; ...
		cmp	ah, 6
		jnz	short checkfatret
		call	chkopcnt
		jz	short checkfatret
		call	GetBp
		jb	short no_error_map
		call	checkfatvid
		jb	short checkioret ; disk	error trying to	read in.
		or	si, si		; is changed for sure?
		js	short checkioerr ; yes changed
		inc	bp		; allow	a retry
		retn
; ---------------------------------------------------------------------------

checkioerr:				; ...
		call	returnvid

checkioret:				; ...
		stc			; make sure carry gets passed through
		jmp	harderr
; ---------------------------------------------------------------------------

no_error_map:				; ...
		jmp	harderr2

; =============== S U B	R O U T	I N E =======================================


returnvid	proc near		; ...
		mov	si, 22		; extra
					; offset into pointer to return	value
		call	vid_into_packet
		mov	ah, 6
		stc
		retn
returnvid	endp

; ---------------------------------------------------------------------------

media_set_vid:				; ...
		mov	si, 15		; trans+1
					; return the value here	in packet

; =============== S U B	R O U T	I N E =======================================


vid_into_packet	proc near		; ...
		push	ds		; return pointer to vid	in bds at es:di	in packet[si]
		lds	bx, ds:ptrsav
		add	di, 75		; BDS.volid
		mov	[bx+si], di
		sub	di, 75		; BDS.volid
		mov	word ptr [bx+si+2], es
		pop	ds
		retn
vid_into_packet	endp

; ---------------------------------------------------------------------------

hidensity:				; ...
		test	word ptr es:[di+23h], 2	; [es:di+BDS.flags]
					; fchangeline
		jz	short dofloppy
		cmp	byte ptr es:[di+22h], 2	; [es:di+BDS.formfactor]
					; ffSmall
		jz	short dofloppy
		cmp	ah, 0F9h	; 96 tpi drive ?
		jnz	short dofloppy
		cmp	byte ptr es:[di+22h], 7	; [es:di+BDS.formfactor]
					; ffOther
		jz	short Is720K
		cmp	byte ptr es:[di+22h], 9	; [es:di+BDS.formfactor]
					; ff288
		jz	short Is720K
		mov	al, 7		; seven	sectors	/ fat
		mov	bx, 57359	; 224*256+0Fh
		mov	cx, 2400	; 80*15*2
		mov	dx, 258		; 1*256+2
		add	sp, 2
		jmp	Has1
; ---------------------------------------------------------------------------

Is720K:					; ...
		add	sp, 2
		jmp	Has720K
; ---------------------------------------------------------------------------

dofloppy:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================


set_changed_dl	proc near		; ...
		push	es
		push	di
		les	di, ds:start_bds

scan_bds:				; ...
		cmp	es:[di+4], dl	; [es:di+BDS.drivenum]
		jnz	short get_next_bds
		or	es:[di+23h], bx	; [es:di+BDS.flags]
					; signal change	on other drive

get_next_bds:				; ...
		les	di, es:[di]	; [es:di+BDS.link]
					; go to	next bds
		cmp	di, 0FFFFh
		jnz	short scan_bds	; loop unless we hit end of chain
		pop	di
		pop	es
		retn
set_changed_dl	endp


; =============== S U B	R O U T	I N E =======================================


checkromchange	proc near		; ...
		test	word ptr es:[di+23h], 40h ; [es:di+BDS.flags]
					; fchanged
		retn
checkromchange	endp


; =============== S U B	R O U T	I N E =======================================


resetchanged	proc near		; ...
		and	word ptr es:[di+23h], 0FFBFh ; [es:di+BDS.flags]
					; ~fchanged
		retn
resetchanged	endp


; =============== S U B	R O U T	I N E =======================================


haschange	proc near		; ...
		test	word ptr es:[di+23h], 2	; [es:di+BDS.flags]
					; fchangeline
		retn
haschange	endp

; ---------------------------------------------------------------------------

set_volume_id:				; ...
		push	dx
		push	ax
		call	haschange	; does drive have changeline support?
		jz	short setvret	; no, get out
		call	read_volume_id
		jb	short seterr
		call	transfer_volume_id ; copy the volume id	to special drive
		call	resetchanged	; restore value	of change line

setvret:				; ...
		clc
		pop	ax
		pop	dx
		retn
; ---------------------------------------------------------------------------

seterr:					; ...
		pop	dx
		pop	dx
		retn
; ---------------------------------------------------------------------------
root_sec	dw 0			; root sector #

; =============== S U B	R O U T	I N E =======================================


read_volume_id	proc near		; ...
		push	dx
		push	cx
		push	bx
		push	ax
		push	es
		push	di
		push	ds
		pop	es
		mov	di, offset tmp_vid ; "NO NAME	 "
		mov	si, offset nul_vid ; "NO NAME	 "
		mov	cx, 12		; initialize tmp_vid to	null vi_id
		rep movsb
		pop	di
		pop	es
		mov	al, es:[di+11]	; [es:di+BDS.fats]
					; # of fats
		mov	cx, es:[di+17]	; [es:di+BDS.fatsecs]
					; sectors / fat
		mul	cl		; size taken by	fats
		add	ax, es:[di+9]	; [es:di+BDS.resectors]
					; add on reserved sectors
					;
					; ax is	now sector # (0	based)
		mov	word ptr cs:loc_208E+1,	ax ; [cs:root_sec]
					; 0070h:3EFFh =	2C7h:198Fh
		mov	ax, es:[di+12]	; [es:di+BDS.direntries]
					; # root dir entries
		mov	cl, 4		; 16 entries/sector
		shr	ax, cl		; divide by 16
		mov	cx, ax		; cx is	# of sectors to	scan

next_sec:				; ...
		push	cx
		mov	ax, word ptr cs:loc_208E+1 ; [cs:root_sec]
					; get sector #
		mov	cx, es:[di+19]	; [es:di+BDS.secpertrack]
					; sectors / track
		xor	dx, dx
		div	cx
		inc	dx		; dx= sectors into track
					; ax= track count from 0
		mov	cl, dl		; sector to read
		xor	dx, dx
		div	word ptr es:[di+21] ; [es:di+BDS.heads]
					; # heads on this disc
		mov	dh, dl		; head number
		mov	ch, al		; track	#
		call	read_sector	; get first sector of the root directory,
					; ds:bx	-> directory sector
		jb	short readviderr
		mov	cx, 16		; # of dir entries in a	block of root
		mov	al, 8		; volume label bit

fvid_loop:				; ...
		cmp	byte ptr [bx], 0 ; end of dir?
		jz	short no_vid	; yes, no vol id
		cmp	byte ptr [bx], 0E5h ; empty entry?
		jz	short ent_loop	; yes, skip
		test	[bx+11], al	; is volume label bit set in fcb?
		jnz	short found_vid	; jmp yes

ent_loop:				; ...
		add	bx, 32		; add length of	directory entry
		loop	fvid_loop
		pop	cx
		inc	word ptr cs:loc_208E+1 ; inc word [root_sec]
					; next sector
		loop	next_sec

notfound:				; ...
		xor	si, si
		jmp	short fvid_ret
; ---------------------------------------------------------------------------

found_vid:				; ...
		pop	cx
		mov	si, bx		; point	to volume_id
		push	es
		push	di
		push	ds
		pop	es
		mov	di, offset tmp_vid ; "NO NAME	 "
		mov	cx, 11		; VOLID_SIZ-1
					; length of string minus nul
		rep movsb		; mov volume label to tmp_vid
		xor	al, al		; null terminate
		stosb
		xor	si, si
		pop	di
		pop	es

fvid_ret:				; ...
		pop	ax
		clc

rvidret:				; ...
		pop	bx
		pop	cx
		pop	dx
		retn
; ---------------------------------------------------------------------------

no_vid:					; ...
		pop	cx
		jmp	short notfound
; ---------------------------------------------------------------------------

readviderr:				; ...
		pop	si
		pop	si
		jmp	short rvidret
read_volume_id	endp


; =============== S U B	R O U T	I N E =======================================


transfer_volume_id proc	near		; ...
		push	di		; copy the volume id from tmp to special drive
		push	si
		push	cx
		mov	si, offset tmp_vid ; "NO NAME	 "
		add	di, 75		; BDS.volid
		mov	cx, 12		; VOLID_SIZ
		cld
		rep movsb
		pop	cx
		pop	si
		pop	di
		retn
transfer_volume_id endp


; =============== S U B	R O U T	I N E =======================================


check_volume_id	proc near		; ...
		push	di
		push	cx
		mov	si, offset tmp_vid ; "NO NAME	 "
		add	di, 75		; BDS.volid
		mov	cx, 12		; VOLID_SIZ
		cld
		repe cmpsb		; are the 2 volume_ids the same?
		pop	cx
		pop	di
		retn
check_volume_id	endp


; =============== S U B	R O U T	I N E =======================================


fat_check	proc near		; ...
		push	ax
		xor	si, si		; say fat id's are same.
		mov	al, ds:medbyt
		cmp	al, es:[di+10h]	; [es:di+BDS.media]
					; compare it with the bds medbyte
		jz	short okret1	; carry	clear
		dec	si

okret1:					; ...
		pop	ax
		retn
fat_check	endp

; ---------------------------------------------------------------------------
		db 4 dup(0)		; times	4 db 0
DOSBIOS		ends


		end
