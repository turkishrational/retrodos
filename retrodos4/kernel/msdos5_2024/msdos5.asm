; MSDOS.SYS
; Original MSDOS 5.0 Kernel (Source Code in NASM syntax)
;
; - Assembler: NASM 2.15 - 
; ((nasm msdos5.asm -l msdos5.lst -o MSDOS5.BIN -Z error.txt))
;				  -o MSDOS.SYS
;	
; (Disassembled and re-written by Erdogan Tan for finding the reason of
;  the AutoCAD R12 running problem of Retro DOS v4.0-v4.1-v4.2-v5.0 Kernels)
; 
; Erdogan Tan - 09/07/2024 - Istanbul
;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2013 Hex-Rays, <support@hex-rays.com>	    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	926BAF897B78FE053F29FC8FF8CFD7C5
; Input	CRC32 :	64D3C385

; ---------------------------------------------------------------------------
; File Name   :	C:\Users\Erdoðan\Desktop\MSDOS5.SYS
; Format      :	Binary file
; Base Address:	0000h Range: 0000h - 9212h Loaded length: 9212h

; ----------------------------------------------------------------------------
; 06/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; ----------------------------------------------------------------------------

segment .code vstart=3DD0h ; 06/12/2022
								
; ============================================================================

	; 05/12/2022 - RetroDOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	PARASTART equ 3DD0h ; BIOSDATASTART+BIOSDATASIZE
			    ; +BIOSCODESIZE+DOSDATASIZE (rounded up)

	;[ORG PARASTART]	

_$STARTCODE:				; ...
		jmp	DOSINIT
; ---------------------------------------------------------------------------
		dw _$STARTCODE		; PARASTART
BioDataSeg	dw 70h
DosDSeg		dw 0			; ...
MSMAJOR		db 5			; MAJOR_VERSION
MSMINOR		db 0			; MINOR_VERSION
I21_MAP_E_TAB	db 38h,	2, 1, 2		; ...
		db 39h,	3, 3, 2, 5
		db 3Ah,	4, 10h,	3, 2, 5
		db 3Bh,	2, 2, 3
		db 3Ch,	4, 3, 2, 4, 5
		db 3Dh,	6, 3, 2, 0Ch, 4, 1Ah, 5
		db 3Eh,	1, 6
		db 3Fh,	2, 6, 5
		db 40h,	2, 6, 5
		db 41h,	3, 3, 2, 5
		db 42h,	2, 6, 1
		db 43h,	4, 3, 2, 1, 5
		db 44h,	5, 0Fh,	0Dh, 1,	6, 5
		db 45h,	2, 6, 4
		db 46h,	2, 6, 4
		db 47h,	2, 1Ah,	0Fh
		db 48h,	2, 7, 8
		db 49h,	2, 7, 9
		db 4Ah,	3, 7, 9, 8
		db 4Bh,	8, 3, 1, 2, 4, 0Bh, 0Ah, 8, 5
		db 4Eh,	3, 3, 2, 12h
		db 4Fh,	1, 12h
		db 56h,	5, 11h,	3, 2, 10h, 5
		db 57h,	4, 6, 8, 0Dh, 1
		db 58h,	1, 1
		db 5Ah,	4, 3, 2, 4, 5
		db 5Bh,	5, 50h,	3, 2, 4, 5
		db 5Ch,	4, 6, 1, 24h, 21h
		db 65h,	2, 1, 2
		db 66h,	2, 1, 2
		db 68h,	1, 6
		db 67h,	3, 4, 8, 1
		db 6Ch,	0Ah, 3,	2, 0Ch,	4, 50h,	8, 1Ah,	0Dh, 1,	5
		db 69h,	4, 0Fh,	0Dh, 1,	5, 0FFh
DISPATCH	dw _$ABORT	; ...
		dw _$STD_CON_INPUT
		dw _$STD_CON_OUTPUT
		dw _$STD_AUX_INPUT
		dw _$STD_AUX_OUTPUT
		dw _$STD_PRINTER_OUTPUT
		dw _$RAW_CON_IO
		dw _$RAW_CON_INPUT
		dw _$STD_CON_INPUT_NO_ECHO
		dw _$STD_CON_STRING_OUTPUT
		dw _$STD_CON_STRING_INPUT
		dw _$STD_CON_INPUT_STATUS
		dw _$STD_CON_INPUT_FLUSH
		dw _$DISK_RESET
		dw _$SET_DEFAULT_DRIVE
		dw _$FCB_OPEN
		dw _$FCB_CLOSE
		dw _$DIR_SEARCH_FIRST
		dw _$DIR_SEARCH_NEXT
		dw _$FCB_DELETE
		dw _$FCB_SEQ_READ
		dw _$FCB_SEQ_WRITE
		dw _$FCB_CREATE
		dw _$FCB_RENAME
		dw NO_OP
		dw _$GET_DEFAULT_DRIVE
		dw _$SET_DMA
		dw _$SLEAZEFUNC
		dw _$SLEAZEFUNCDL
		dw NO_OP
		dw NO_OP
		dw _$GET_DEFAULT_DPB
		dw NO_OP
		dw _$FCB_RANDOM_READ
		dw _$FCB_RANDOM_WRITE
		dw _$GET_FCB_FILE_LENGTH
		dw _$GET_FCB_POSITION
		dw _$SET_INTERRUPT_VECTOR
		dw _$CREATE_PROCESS_DATA_BLOCK
		dw _$FCB_RANDOM_READ_BLOCK
		dw _$FCB_RANDOM_WRITE_BLOCK
		dw _$PARSE_FILE_DESCRIPTOR
		dw _$GET_DATE
		dw _$SET_DATE
		dw _$GET_TIME
		dw _$SET_TIME
		dw _$SET_VERIFY_ON_WRITE
		dw _$GET_DMA
		dw _$GET_VERSION
		dw _$KEEP_PROCESS
		dw _$GET_DPB
		dw _$SET_CTRL_C_TRAPPING
		dw _$GET_INDOS_FLAG
		dw _$GET_INTERRUPT_VECTOR
		dw _$GET_DRIVE_FREESPACE
		dw _$CHAR_OPER
		dw _$INTERNATIONAL
		dw _$MKDIR
		dw _$RMDIR
		dw _$CHDIR
		dw _$CREAT
		dw _$OPEN
		dw _$CLOSE
		dw _$READ
		dw _$WRITE
		dw _$UNLINK
		dw _$LSEEK
		dw _$CHMOD
		dw _$IOCTL
		dw _$DUP
		dw _$DUP2
		dw _$CURRENT_DIR
		dw _$ALLOC
		dw _$DEALLOC
		dw _$SETBLOCK
		dw _$EXEC
		dw _$EXIT
		dw _$WAIT
		dw _$FIND_FIRST
		dw _$FIND_NEXT
		dw _$SET_CURRENT_PDB
		dw _$GET_CURRENT_PDB
		dw _$GET_IN_VARS
		dw _$SETDPB
		dw _$GET_VERIFY_ON_WRITE
		dw _$DUP_PDB
		dw _$RENAME
		dw _$FILE_TIMES
		dw _$ALLOCOPER
		dw _$GetExtendedError
		dw _$CreateTempFile
		dw _$CreateNewFile
		dw _$LockOper
		dw _$ServerCall
		dw _$UserOper
		dw _$AssignOper
		dw _$NameTrans
		dw NO_OP
		dw _$GET_CURRENT_PDB
		dw _$ECS_Call
		dw _$SET_PRINTER_FLAG
		dw _$GetExtCntry
		dw _$GetSetCdPg
		dw _$ExtHandle
		dw _$COMMIT
		dw _$GSetMediaID
		dw _$COMMIT
		dw NO_OP
		dw _$Extended_Open
FOO		dw Leave2F	; ...
Dtab		dw DOSTable	; ...
DOSTable	db 48			; ...
		dw DOSInstall
		dw DOS_CLOSE
		dw RECSET
		dw DOSGetGroup
		dw PATHCHRCMP
		dw OUTT
		dw NET_I24_ENTRY
		dw PLACEBUF
		dw FREE_SFT
		dw BUFWRITE
		dw SHARE_VIOLATION
		dw SHARE_ERROR
		dw SET_SFT_MODE
		dw DATE16
		dw Idle
		dw SCANPLACE
		dw Idle
		dw StrCpy
		dw StrLen
		dw UCase
		dw POINTCOMP
		dw CHECKFLUSH
		dw SFFromSFN
		dw GetCDSFromDrv
		dw Get_User_Stack
		dw GETTHISDRV
		dw DriveFromText
		dw SETYEAR
		dw DSUM
		dw DSLIDE
		dw StrCmp
		dw InitCDS
		dw pJFNFromHandle
		dw _$NameTrans
		dw CAL_LK
		dw DEVNAME
		dw Idle
		dw DStrLen
		dw NLS_OPEN
		dw _$CLOSE
		dw NLS_LSEEK
		dw _$READ
		dw FastInit
		dw NLS_IOCTL
		dw GetDevList
		dw NLS_GETEXT
		dw MSG_RETRIEVAL
		dw NO_OP
ms_copyright	db 'MS DOS Version 5.00 (C)Copyright 1981-1991 Microsoft Corp License'
		db 'd Material - Property of Microsoft All rights reserved '
; ---------------------------------------------------------------------------

_$SET_CTRL_C_TRAPPING:			; ...
		cmp	al, 6
		jbe	short scct_1
		mov	al, 0FFh
		iret
; ---------------------------------------------------------------------------

scct_1:					; ...
		push	ds
		mov	ds, [cs:DosDSeg]
		push	ax
		push	si
		mov	si, CNTCFLAG
		xor	ah, ah
		or	ax, ax
		jnz	short scct_2
		mov	dl, [si]
		jmp	short scct_6	; scct_9s
; ---------------------------------------------------------------------------

scct_2:					; ...
		dec	ax
		jnz	short scct_3
		and	dl, 1
		mov	[si], dl
		jmp	short scct_6	; scct_9s
; ---------------------------------------------------------------------------

scct_3:					; ...
		dec	ax
		jnz	short scct_4
		and	dl, 1
		xchg	dl, [si]
		jmp	short scct_6	; scct_9s
; ---------------------------------------------------------------------------

scct_4:					; ...
		cmp	ax, 3
		jnz	short scct_5
		mov	dl, [BOOTDRIVE]
		jmp	short scct_6	; scct_9s
; ---------------------------------------------------------------------------

scct_5:					; ...
		cmp	ax, 4
		jnz	short scct_6	; scct_9s
		mov	bx, 5		; (MINOR_VERSION<<8)+MAJOR_VERSION
		mov	dl, 0		; DOSREVNM
		xor	dh, dh
		cmp	byte [DosHasHMA],	0
		jz	short scct_6
		or	dh, 10h		; DOSINHMA

scct_6:					; ...
		pop	si		; scct_9s
		pop	ax
		pop	ds
		iret
; ---------------------------------------------------------------------------

SetCtrlShortEntry:			; ...
		jmp	short _$SET_CTRL_C_TRAPPING
; ---------------------------------------------------------------------------

_$SET_CURRENT_PDB:			; ...
		push	ds
		mov	ds, [cs:DosDSeg]
		mov	[CurrentPDB], bx
		pop	ds
		iret
; ---------------------------------------------------------------------------

_$GET_CURRENT_PDB:			; ...
		push	ds
		mov	ds, [cs:DosDSeg]
		mov	bx, [CurrentPDB]
		pop	ds
		iret
; ---------------------------------------------------------------------------

_$SET_PRINTER_FLAG:			; ...
		push	ds
		mov	ds, [cs:DosDSeg]
		mov	[PRINTER_FLAG], al
		pop	ds
		iret
; ---------------------------------------------------------------------------

QUIT:					; ...
		xor	ah, ah
		jmp	short SAVREGS
; ---------------------------------------------------------------------------

BADCALL:				; ...
		xor	al, al

IRETT:					; ...
		iret
; ---------------------------------------------------------------------------

CALL_ENTRY:				; ...
		push	ds
		mov	ds, [cs:DosDSeg]
		pop	word [SAVEDS]
		pop	ax
		pop	ax
		pop	word [USER_SP]
		pushf
		cli
		push	ax
		push	word [USER_SP]
		push	word [SAVEDS]
		pop	ds
		cmp	cl, 36		; MAXCALL
		ja	short BADCALL
		mov	ah, cl
		jmp	short SAVREGS
; ---------------------------------------------------------------------------

COMMAND:				; ...
		cli
		cmp	ah, 6Ch
		ja	short BADCALL

SAVREGS:				; ...
		cmp	ah, 33h
		jb	short loc_410E
		jz	short SetCtrlShortEntry
		cmp	ah, 64h
		ja	short loc_410E
		jz	short _$SET_PRINTER_FLAG
		cmp	ah, 51h
		jz	short _$GET_CURRENT_PDB
		cmp	ah, 62h
		jz	short _$GET_CURRENT_PDB
		cmp	ah, 50h
		jz	short _$SET_CURRENT_PDB

loc_410E:				; ...
		push	es
		push	ds
		push	bp
		push	di
		push	si
		push	dx
		push	cx
		push	bx
		push	ax
		mov	ax, ds
		mov	ds, [cs:DosDSeg]
		mov	[SAVEDS], ax
		mov	[SAVEBX], bx
		mov	ax, [USER_SP]
		mov	[NSP], ax
		mov	ax, [USER_SS]
		mov	[NSS], ax
		xor	ax, ax
		mov	[FSHARING], al
		test	byte [IsWin386], 1
		jnz	short loc_4140
		mov	[USER_ID], ax

loc_4140:				; ...
		inc	byte [INDOS]
		mov	[USER_SP], sp
		mov	[USER_SS], ss
		mov	ax, [CurrentPDB]
		mov	[PROC_ID], ax
		mov	ds, ax
		pop	ax
		push	ax
		mov	[2Eh], sp	; [PDB.USER_STACK]
		mov	word [30h], ss	; [PDB.USER_STACK+2]
		mov	ss, [cs:DosDSeg]

REDISP:					; ...
		mov	sp, AUXSTACK
		sti
		mov	bx, ss
		mov	ds, bx
		xchg	ax, bx
		xor	ax, ax
		mov	[ss:EXTOPEN_ON], al
		and	word [ss:DOS34_FLAG], 800h
		mov	[ss:CONSWAP], al
		mov	[ss:NoSetDir], al
		mov	byte [ss:FAILERR], al
		inc	ax
		mov	[ss:IDLEINT], al ; 1
		xchg	ax, bx
		mov	bl, ah
		shl	bx, 1
		cld
		or	ah, ah
		jz	short DSKROUT
		cmp	ah, 59h		; GETEXTENDEDERROR
		jz	short DISPCALL
		cmp	ah, 12		; STD_CON_INPUT_FLUSH
		ja	short DSKROUT

IOROUT:
		cmp	byte [ss:ERRORMODE], 0
		jnz	short DISPCALL
		mov	sp, PRINTER_FLAG	; IOSTACK
		jmp	short DISPCALL
; ---------------------------------------------------------------------------

DSKROUT:				; ...
		mov	[ss:USER_IN_AX], ax
		mov	byte [ss:EXTERR_LOCUS], 1
		mov	byte [ss:ERRORMODE], 0
		mov	byte [ss:WPERR], 0FFh
		push	ax
		mov	ah, 82h
		int	2Ah		; Microsoft Networks - END DOS CRITICAL	SECTIONS 0 THROUGH 7
		pop	ax
		mov	byte [ss:IDLEINT], 0
		mov	sp, DSKSTACK
		test	byte [ss:CNTCFLAG], 0FFh ; -1
		jz	short DISPCALL
		push	ax
		call	DSKSTATCHK
		pop	ax

DISPCALL:				; ...
		mov	bx, [cs:DISPATCH+bx] ; [CS:BX+DISPATCH]
		xchg	bx, [ss:SAVEBX]
		mov	ds, [ss:SAVEDS]
		;call	[ss:SAVEBX]
		call	word [SS:SAVEBX] ; near call
		and	byte [ss:DOS_FLAG], 0FBh

LeaveDOS:				; ...
		cli
		mov	ds, [cs:DosDSeg]
		cmp	byte [A20OFF_COUNT], 0
		jnz	short disa20

LeaveA20On:				; ...
		dec	byte [INDOS]
		mov	ss, [USER_SS]
		mov	sp, [USER_SP]
		mov	bp, sp
		mov	[bp+0],	al
		mov	ax, [NSP]
		mov	[USER_SP], ax
		mov	ax, [NSS]
		mov	[USER_SS], ax
		pop	ax
		pop	bx
		pop	cx
		pop	dx
		pop	si
		pop	di
		pop	bp
		pop	ds
		pop	es
		iret
; ---------------------------------------------------------------------------

disa20:					; ...
		mov	bx, [A20OFF_PSP]
		cmp	bx, [CurrentPDB]
		jnz	short LeaveA20On
		dec	byte [A20OFF_COUNT]
		push	ds
		mov	bx, disa20_iret
		push	bx
		retf
; ---------------------------------------------------------------------------

restore_world:				; ...
		mov	es, [cs:DosDSeg]
		pop	word [es:RESTORE_TMP]
		pop	ax
		pop	bx
		pop	cx
		pop	dx
		pop	si
		pop	di
		pop	bp
		pop	ds
		jmp	[es:RESTORE_TMP]
; ---------------------------------------------------------------------------

save_world:				; ...
		mov	es, [cs:DosDSeg]
		pop	word [es:RESTORE_TMP]
		push	ds
		push	bp
		push	di
		push	si
		push	dx
		push	cx
		push	bx
		push	ax
		push	word [es:RESTORE_TMP]
		push	bp
		mov	bp, sp
		mov	es, word [bp+20]
		pop	bp
		retn

; =============== S U B	R O U T	I N E =======================================

		Get_User_Stack:	; ...
		mov	ds, [cs:DosDSeg]
		lds	si, [USER_SP]
		retn

; ---------------------------------------------------------------------------
ERRIN		db 2			; ...
		db 6
		db 12
		db 4
		db 8
		db 0
ERROUT		db 80h
		db 40h
		db 2
		db 10h
		db 4
		db 3

; =============== S U B	R O U T	I N E =======================================


 AbsSetup:		; ...
		inc	byte [ss:INDOS]
		sti
		cld
		push	ds
		push	ss
		pop	ds
		call	GETBP
		jb	short errdriv
		mov	word [es:bp+1Fh], -1 ; [ES:BP+DPB.FREE_CNT]

errdriv:				; ...
		pop	ds
		jnb	short AbsSetup2

AbsSetup_retn:				; ...
		retn
; ---------------------------------------------------------------------------

AbsSetup2:				; ...
		mov	word [ss:HIGH_SECTOR], 0
		call	RW32_CONVERT
		jb	short AbsSetup_retn
		call	SET_RQ_SC_PARMS
		push	ds
		push	si
		push	ax
		push	ss
		pop	ds
		mov	si, OPENBUF
		mov	[si], al
		add	byte [si], 'A' ; 41h
		mov	word [si+1], ':' ; 3Ah
		mov	ax, 300h
		clc
		int	2Ah		; Microsoft Networks - CHECK DIRECT I/O
					; DS:SI	-> ASCIZ disk device name (may be full path or only drive
					; specifier--must include the colon)
					; Return: CF clear if absolute disk access allowed
		pop	ax
		pop	si
		pop	ds
		jnb	short AbsSetup_retn
		mov	word [ss:EXTERR], 32h
		retn
; ---------------------------------------------------------------------------

ABSDRD:					; ...
		cli
		push	ax
		mov	ax, ds
		mov	ds, [cs:DosDSeg]
		mov	[TEMPSEG], ax
		pop	ax
		push	es
		mov	[AbsRdWr_SS], ss
		mov	[AbsRdWr_SP], sp
		mov	ss, [cs:DosDSeg]
		mov	sp, DSKSTACK
		mov	ds, [TEMPSEG]
		push	es
		call	save_world
		push	es
		call	AbsSetup
		jb	short ILEAVE
		call	ECritDisk
		mov	byte [ss:CurSC_DRIVE], 0FFh ; -1
		call	LCritDisk
		call	DSKREAD
		jnz	short ERR_LEAVE
		mov	cx, di
		mov	[ss:TEMP_VAR2],	ds
		mov	[ss:TEMP_VAR], bx
		call	DskRdBufScan
		jmp	short ILEAVE
; ---------------------------------------------------------------------------

TLEAVE:					; ...
		jz	short ILEAVE

ERR_LEAVE:				; ...
		push	es
		push	cs
		pop	es
		xor	ah, ah
		mov	cx, 6		; NUMERR
		mov	di, ERRIN
		repne scasb
		jnz	short LEAVECODE
		mov	ah, [es:di+5]

LEAVECODE:				; ...
		pop	es
		mov	[ss:AbsDskErr],	ax
		stc

ILEAVE:					; ...
		pop	es
		call	restore_world
		pop	es
		cli
		mov	ax, [ss:AbsDskErr]
		dec	byte [ss:INDOS]
		push	ss
		pop	es
		mov	ss, [es:AbsRdWr_SS]
		mov	sp, [es:AbsRdWr_SP]
		pop	es
		sti
		retf
; ---------------------------------------------------------------------------

ABSDWRT:				; ...
		cli
		push	ax
		mov	ax, ds
		mov	ds, [cs:DosDSeg]
		mov	[TEMPSEG], ax
		pop	ax
		push	es
		mov	[AbsRdWr_SS], ss
		mov	[AbsRdWr_SP], sp
		mov	ss, [cs:DosDSeg]
		mov	sp, DSKSTACK
		mov	ds, [TEMPSEG]
		push	es
		call	save_world
		push	es
		call	AbsSetup
		jb	short ILEAVE
		call	ECritDisk
		mov	byte [ss:CurSC_DRIVE], 0FFh ; -1
		call	Fastxxx_Purge
		call	LCritDisk
		push	ds
		call	DskWrtBufPurge
		pop	ds
		call	DSKWRITE
		jmp	short TLEAVE

; =============== S U B	R O U T	I N E =======================================

GETBP:		; ...
		push	ax
		add	al, 1
		jb	short SKIPGET
		call	GETTHISDRV
		jnb	short SKIPGET
		xor	ah, ah
		cmp	ax, 1Ah		; error_not_DOS_disk
		jz	short SKIPGET
		stc
		mov	[EXTERR], ax
		mov	word [AbsDskErr], 201h

SKIPGET:				; ...
		pop	ax
		jnb	short getbp_t
		retn
; ---------------------------------------------------------------------------

getbp_t:				; ...
		les	bp, [THISCDS]
		test	word [es:bp+43h], 8000h ; [ES:BP+curdir.flags],
					; curdir_isnet
		jz	short GETBP_CDS
		mov	word [EXTERR], 32h ; '2' ; error_not_supported
		stc

GETBP_RETN:
		retn
; ---------------------------------------------------------------------------

GETBP_CDS:				; ...
		les	bp, [es:bp+45h]	; [ES:BP+curdir.devptr]

GOTDPB:					; ...
		mov	word [THISDPB], bp
		mov	word [THISDPB+2], es
		retn
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR _$CLOSE

SYS_RETURN:				; ...
		call	Get_User_Stack	; SYS_RETURN_OK
		and	word [si+16h], 0FFFEh ; [SI+user_env.user_F],
					; ~f_Carry
		jmp	short DO_RET
; ---------------------------------------------------------------------------

SYS_RET_ERR:				; ...
		xor	ah, ah
		call	ETAB_LK
		call	ErrorMap

From_GetSet:				; ...
		call	Get_User_Stack
		or	word [si+16h], 1 ; [SI+user_env.user_F],
					; f_Carry
		stc

DO_RET:					; ...
		mov	[si], ax
		retn
; END OF FUNCTION CHUNK	FOR _$CLOSE
; ---------------------------------------------------------------------------

NO_OP:					; ...
		xor	al, al
		retn

; =============== S U B	R O U T	I N E =======================================

FCB_RET_ER:
		xor	ah, ah
		mov	word [ss:EXTERR], ax
		call	ErrorMap
		mov	al, 0FFh	; -1
		retn

; =============== S U B	R O U T	I N E =======================================

ErrorMap:
		push	si
		mov	si, ERR_TABLE_21
		cmp	byte [ss:FAILERR], 0
		jz	short EXTENDED_NORMAL
		mov	word [ss:EXTERR], 53h ; error_FAIL_I24

EXTENDED_NORMAL:			; ...
		call	CAL_LK
		pop	si
		retn

; =============== S U B	R O U T	I N E =======================================


 CAL_LK:		; ...
		push	ds
		push	ax
		push	bx
		mov	ds, [cs:DosDSeg]
		mov	bx, [EXTERR]

TABLK1:					; ...
		lodsb
		cmp	al, 0FFh
		jz	short GOT_VALS
		cmp	al, bl
		jz	short GOT_VALS
		add	si, 3
		jmp	short TABLK1
; ---------------------------------------------------------------------------

GOT_VALS:				; ...
		lodsw
		cmp	ah, 0FFh
		jz	short NO_SET_ACT
		mov	[EXTERR_ACTION], ah

NO_SET_ACT:				; ...
		cmp	al, 0FFh
		jz	short NO_SET_CLS
		mov	[EXTERR_CLASS], al

NO_SET_CLS:				; ...
		lodsb
		cmp	al, 0FFh
		jz	short NO_SET_LOC
		mov	[EXTERR_LOCUS], al

NO_SET_LOC:				; ...
		pop	bx
		pop	ax
		pop	ds
		retn

; =============== S U B	R O U T	I N E =======================================

ETAB_LK:
		push	ds
		push	si
		push	cx
		push	bx
		push	ss
		pop	ds
		mov	[EXTERR], ax
		mov	si, I21_MAP_E_TAB
		mov	bh, al
		mov	bl, byte [USER_IN_AX+1]

TABLK2:					; ...
		;lods	word [cs:si] ; cs lodsw
		cs
		lodsw
		cmp	al, 0FFh
		jz	short NOT_IN_TABLE
		cmp	al, bl
		jz	short GOT_CALL
		xchg	ah, al
		xor	ah, ah
		add	si, ax
		jmp	short TABLK2
; ---------------------------------------------------------------------------

NOT_IN_TABLE:				; ...
		mov	al, bh
		jmp	short NO_MAP
; ---------------------------------------------------------------------------

GOT_CALL:				; ...
		mov	cl, ah
		xor	ch, ch

CHECK_CODE:				; ...
		;lods	byte [cs:si] ; cs lodsb
		cs
		lodsb
		cmp	al, bh
		jz	short NO_MAP
		loop	CHECK_CODE

NO_MAP:					; ...
		xor	ah, ah
		pop	bx
		pop	cx
		pop	si
		pop	ds
		retn

; =============== S U B	R O U T	I N E =======================================

SetBad:		; ...
		mov	ax, 1		; error_invalid_function
		push	ds
		mov	ds, [cs:DosDSeg]
		mov	byte [EXTERR_LOCUS], 1 ; errLOC_Unk
		pop	ds
		stc
		retn

; =============== S U B	R O U T	I N E =======================================

BadCall:
		call	SetBad
		retf

; ---------------------------------------------------------------------------

OKCall:
		clc
		retf

; ---------------------------------------------------------------------------

INT2F:					; ...
		sti
		cmp	ah, 11h		; MultNET
		jnz	short INT2FSHR

TestInstall:				; ...
		or	al, al
		jz	short Leave2F

BadFunc:				; ...
		call	SetBad

Leave2F:				; ...
		retf	2
; ---------------------------------------------------------------------------

INT2FSHR:				; ...
		cmp	ah, 10h		; MultSHARE
		jz	short TestInstall
		cmp	ah, 14h		; NLSFUNC
		jz	short TestInstall
		cmp	ah, 12h		; MultDOS
		jnz	short check_win
		jmp	DispatchDOS
; ---------------------------------------------------------------------------

check_win:				; ...
		cmp	ah, 16h		; MultWin386
		jz	short Win386_Msg
		cmp	ah, 46h		; WINOLDAP
		jnz	short next_i2f
		jmp	winold_swap
; ---------------------------------------------------------------------------

next_i2f:				; ...
		;jmp	far ptr	70h:5
		jmp	0070h:0005h
; ---------------------------------------------------------------------------

Win386_Msg:				; ...
		push	ds
		mov	ds, [cs:DosDSeg]
		cmp	al, 3
		jnz	short Win386_Msg_exit
		jmp	OldWin386Init
; ---------------------------------------------------------------------------

Win386_Msg_exit:			; ...
		cmp	al, 6
		jnz	short Win386_Msg_devcall
		jmp	Win386_Leaving
; ---------------------------------------------------------------------------

Win386_Msg_devcall:			; ...
		cmp	al, 7
		jnz	short Win386_Msg_init
		jmp	Win386_Query
; ---------------------------------------------------------------------------

Win386_Msg_init:			; ...
		cmp	al, 5
		jz	short Win386_Starting
		jmp	win_nexti2f
; ---------------------------------------------------------------------------

Win386_Starting:			; ...
		test	dx, 1
		jz	short Win386_vchk
		jmp	win_nexti2f
; ---------------------------------------------------------------------------

Win386_vchk:				; ...
		mov	word [Win386_Info+6], 0 ; [Win386_Info+Win386_SIS.Virt_Dev_File_Ptr]
		mov	word [Win386_Info+8], 0 ; [Win386_Info+Win386_SIS.Virt_Dev_File_Ptr+2]
		cmp	di, 30Ah	; version 3.10
		jb	short Win386_vxd
		jmp	noVxD31
; ---------------------------------------------------------------------------

Win386_vxd:				; ...
		push	ax
		push	bx
		push	cx
		push	dx
		push	si
		push	di
		mov	bx, [UMB_HEAD]
		cmp	bx, 0FFFFh
		jz	short Vxd31
		mov	byte [UmbSaveFlag], 1
		push	ds
		push	es
		mov	ax, ds
		mov	es, ax
		mov	ds, bx
		xor	si, si
		cld
		mov	di, UmbSave1
		mov	cx, 11
		rep movsb
		mov	di, UmbSave2
		mov	cx, 5
		rep movsb
		pop	es
		pop	ds

Vxd31:					; ...
		test	byte [DOS_FLAG], 2
		jz	short Dont_Supress
		pop	di
		pop	si
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		jmp	short noVxD31
; ---------------------------------------------------------------------------

Dont_Supress:				; ...
		mov	al, [BOOTDRIVE]
		add	al, 40h	; '@'   ; 'A' - 1
		mov	byte [VxDpath], al ; "c:\\wina20.386"
		mov	ah, 6Ch		; ExtOpen
		mov	al, 0
		mov	bx, 2080h
		mov	cx, 7
		mov	dx, 1
		mov	si, VxDpath ; "c:\\wina20.386"
		mov	di, 0FFFFh
		int	21h		; DOS -	4.0 - EXTENDED OPEN/CREATE
					; BL = open mode as in AL for normal open (INT 21h/AH=3Dh)
					; BH = flags, CX = create attribute, DL	= action if file exists/does not exists
					; DH = 00h (reserved), DS:SI ->	ASCIZ file name
		pop	di
		pop	si
		pop	dx
		pop	cx
		jnb	short VxDthere
		push	dx
		push	ds
		push	si
		mov	si, NoVxDErrMsg ; "You must have	the file WINA20.386 in th"...
		push	cs
		pop	ds
		mov	cx, 99
		mov	ah, 2
		cld

vxdlp:					; ...
		lodsb
		xchg	dl, al
		int	21h		; DOS -	DISPLAY	OUTPUT
					; DL = character to send to standard output
		loop	vxdlp
		pop	si
		pop	ds
		pop	dx
		pop	bx
		pop	ax
		inc	cx
		jmp	win_nexti2f
; ---------------------------------------------------------------------------

VxDthere:				; ...
		mov	bx, ax
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		mov	bx, Win386_Info
		mov	word [bx+6], VxDpath ; [Win386_Info+Win386_SIS.Virt_Dev_File_Ptr],
					; VxDpath
		mov	word [bx+8], ds ; [Win386_Info+Win386_SIS.Virt_Dev_File_Ptr+2]
		pop	bx
		pop	ax

noVxD31:				; ...
		or	byte [IsWin386], 1
		or	byte [redir_patch], 1
		push	dx
		mov	dx, bx
		mov	bx, Win386_Info
		mov	[bx+2],	dx
		mov	word [bx+4], es
		pop	dx
		push	ds
		pop	es
		jmp	win_nexti2f
; ---------------------------------------------------------------------------

Win386_Leaving:				; ...
		test	dx, 1
		jz	short Win386_Leaving_c
		jmp	win_nexti2f
; ---------------------------------------------------------------------------

Win386_Leaving_c:			; ...
		cmp	byte [UmbSaveFlag], 1
		jnz	short noumb
		mov	byte [UmbSaveFlag], 0
		push	ax
		push	es
		push	cx
		push	si
		push	di
		mov	ax, [UMB_HEAD]
		mov	es, ax
		xor	di, di
		cld
		mov	si, UmbSave1
		mov	cx, 11
		rep movsb
		mov	si, UmbSave2
		mov	cx, 5
		rep movsb
		pop	di
		pop	si
		pop	cx
		pop	es
		pop	ax

noumb:					; ...
		and	byte [IsWin386], 0
		and	byte [redir_patch], 0
		jmp	short win_nexti2f
; ---------------------------------------------------------------------------

Win386_Query:				; ...
		cmp	bx, 15h		; Win386_DOSMGR
		jnz	short win_nexti2f
		or	cx, cx
		jnz	short dosmgr_func
		inc	cx
		mov	bx, Win386_DOSVars
		push	ds
		pop	es
		jmp	short PopIret
; ---------------------------------------------------------------------------

OldWin386Init:				; ...
		pop	ax
		mov	si, OldInstanceJunk
		mov	ax, 5248h	; 'HR'
		jmp	next_i2f
; ---------------------------------------------------------------------------

dosmgr_func:				; ...
		dec	cx
		jz	short win386_patch
		dec	cx
		jz	short PopIret
		dec	cx
		jz	short win386_size
		dec	cx
		jz	short win386_inst
		dec	cx
		jnz	short PopIret
		mov	ax, es
		dec	ax
		push	es
		mov	es, ax
		cmp	byte [es:di], 'D'
		jnz	short cantsize
		inc	ax
		cmp	[es:di+1], ax
		jnz	short cantsize
		mov	ax, [es:di+3]
		pop	es
		mov	bx, 16
		mul	bx
		mov	cx, ax
		mov	bx, dx
		jmp	short win386_done
; ---------------------------------------------------------------------------

cantsize:				; ...
		pop	es
		xor	ax, ax
		xor	dx, dx
		jmp	short PopIret
; ---------------------------------------------------------------------------

win386_patch:				; ...
		mov	bx, dx
		jmp	short win386_done
; ---------------------------------------------------------------------------

win386_size:				; ...
		test	dx, 1
		jz	short PopIret
		mov	cx, 88		; curdirLen
		jmp	short win386_done
; ---------------------------------------------------------------------------

win386_inst:				; ...
		xor	dx, dx
		jmp	short PopIret
; ---------------------------------------------------------------------------

win386_done:				; ...
		mov	ax, 0B97Ch	; WIN_OP_DONE
		mov	dx, 0A2ABh	; DOSMGR_OP_DONE

PopIret:				; ...
		pop	ds
		iret
; ---------------------------------------------------------------------------

win_nexti2f:				; ...
		pop	ds
		jmp	next_i2f
; ---------------------------------------------------------------------------

getwinlast:				; ...
		mov	si, [CurrentPDB]
		dec	si
		mov	es, si
		add	si, [es:3]
		retn
; ---------------------------------------------------------------------------

winold_swap:				; ...
		push	ds
		push	es
		push	si
		push	di
		push	cx
		mov	ds, [cs:DosDSeg]
		cmp	al, 1
		jnz	short swapin
		call	getwinlast
		push	ds
		pop	es
		mov	ds, si
		xor	si, si
		mov	di, WinoldPatch1
		mov	cx, 8
		cld
		push	cx
		rep movsb
		pop	cx
		mov	di, WinoldPatch2
		rep movsb
		jmp	short winold_done
; ---------------------------------------------------------------------------

swapin:					; ...
		cmp	al, 2
		jnz	short winold_done
		call	getwinlast
		mov	es, si
		xor	di, di
		mov	si, 6
		mov	cx, 8
		cld
		push	cx
		rep movsb
		pop	cx
		mov	si, WinoldPatch2
		rep movsb

winold_done:				; ...
		pop	cx
		pop	di
		pop	si
		pop	es
		pop	ds
		jmp	next_i2f
; ---------------------------------------------------------------------------

DispatchDOS:				; ...
		push	word [cs:FOO]
		push	word [cs:Dtab]
		push	ax
		push	bp
		mov	bp, sp
		mov	ax, [bp+0Eh]
		pop	bp
		call	TableDispatch
		jmp	BadFunc
; ---------------------------------------------------------------------------

DOSGetGroup:				; ...
		mov	ds, [cs:DosDSeg]
		retn
; ---------------------------------------------------------------------------

DOSInstall:				; ...
		mov	al, 0FFh
		retn

; =============== S U B	R O U T	I N E =======================================


 RW32_CONVERT:	; ...
		cmp	cx, 0FFFFh
		jz	short new32format
		push	ax
		push	dx
		mov	ax, [es:bp+0Dh]	; [ES:BP+DPB.MAX_CLUSTER]
		mov	dl, [es:bp+4]	; [ES:BP+DPB.CLUSTER_MASK]
		cmp	dl, 0FEh	; Sectors/cluster - 1
		jz	short letold
		inc	dl
		xor	dh, dh
		mul	dx
		or	dx, dx

letold:					; ...
		pop	dx
		pop	ax
		jz	short old_style
		push	ds
		mov	ds, [cs:DosDSeg]
		mov	word [AbsDskErr], 207h
		pop	ds
		stc
		retn
; ---------------------------------------------------------------------------

new32format:				; ...
		mov	dx, [bx+2]	; [BX+ABS_32RW.SECTOR_RBA+2]
		push	ds
		mov	ds, [cs:DosDSeg]
		mov	word [HIGH_SECTOR], dx
		pop	ds
		mov	dx, [bx]	; [BX+ABS_32RW.SECTOR_RBA]
		mov	cx, [bx+4]	; [BX+ABS_32RW.ABS_RW_COUNT]
		lds	bx, [bx+6]	; [BX+ABS_32RW.BUFFER_ADDR]

old_style:				; ...
		clc
		retn

; =============== S U B	R O U T	I N E =======================================

Fastxxx_Purge:
		push	ax
		push	si
		push	dx
		push	ds
		mov	ds, [cs:DosDSeg]
		test	byte [FastOpenFlg], 80h ; Fast_yes
		pop	ds
		jz	short nofast
		mov	ah, 1		; FastOpen_ID
		mov	al, 5		; FONC_purge
		mov	dl, [es:bp+0]
		call	Fast_Dispatch

nofast:					; ...
		pop	dx
		pop	si
		pop	ax
		retn

; ---------------------------------------------------------------------------
DIVMES		db 0Dh,0Ah		; ...
		db 'Divide overflow',0Dh,0Ah
DivMesLen	dw 19			; ...
NoVxDErrMsg	db 'You must have the file WINA20.386 in the root of your boot drive',0Dh ; ...
		db 0Ah
		db 'to run Windows in Enhanced Mode',0Dh,0Ah
NLS_YES		db 'Y'                  ; ...
NLS_NO		db 'N'                  ; ...
NLS_yes2	db 'y'                  ; ...
NLS_no2		db 'n'                  ; ...
CANCHAR		db 1Bh			; ...
ESCCHAR		db 0			; ...
ESCTAB		db 64			; ...
		db 77
		db 59
		db 83
		db 60
		db 62
		db 61
		db 61
		db 63
		db 75
		db 82
		db 82
		db 65
		db 65
ESCFUNC		dw GETCH		; ...
		dw TWOESC
		dw EXITINS
		dw EXITINS	; ENTERINS
		dw BACKSP
		dw REEDIT
		dw KILNEW
		dw COPYLIN
		dw SKIPSTR
		dw COPYSTR
		dw SKIPONE
		dw COPYONE
		dw COPYONE
		dw CTRLZ
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR _$STD_CON_STRING_INPUT

OEMFunctionKey:				; ...
		call	_$STD_CON_INPUT_NO_ECHO
		mov	cl, 14		; ESCTABLEN
		push	di
		mov	di, ESCTAB
		push	es
		push	cs
		pop	es
		repne scasb
		pop	es
		pop	di
		shl	cx, 1
		mov	bp, cx
		jmp	[cs:ESCFUNC+bp]	; [CS:BP+ESCFUNC]
; END OF FUNCTION CHUNK	FOR _$STD_CON_STRING_INPUT
; ---------------------------------------------------------------------------

_$GET_DATE:				; ...
		push	ss
		pop	ds
		call	READTIME
		mov	ax, [YEAR]
		mov	bx, word [DAY]
		call	Get_User_Stack
		mov	[si+6],	bx	; [SI+user_env.user_DX]
		add	ax, 1980
		mov	[si+4],	ax	; [SI+user_env.user_CX]
		mov	al, [ss:WEEKDAY]

RET20:					; ...
		retn
; ---------------------------------------------------------------------------

_$SET_DATE:				; ...
		mov	al, -1		; 0FFh
		sub	cx, 1980
		jb	short RET20
		cmp	cx, 119
		ja	short RET24
		or	dh, dh
		jz	short RET20
		or	dl, dl
		jz	short RET20
		cmp	dh, 0Ch
		ja	short RET24
		push	ss
		pop	ds
		call	DODATE

RET24:					; ...
		retn
; ---------------------------------------------------------------------------

_$GET_TIME:				; ...
		push	ss
		pop	ds
		call	READTIME
		call	Get_User_Stack
		mov	[si+6],	dx	; [SI+user_env.user_DX]
		mov	[si+4],	cx	; [SI+user_env.user_CX]
		xor	al, al

RET26:					; ...
		retn
; ---------------------------------------------------------------------------

_$SET_TIME:				; ...
		mov	al, -1
		cmp	ch, 24
		jnb	short RET26
		cmp	cl, 60
		jnb	short RET26
		cmp	dh, 60
		jnb	short RET26
		cmp	dl, 100
		jnb	short RET26
		push	cx
		push	dx
		push	ss
		pop	ds
		mov	bx, TIMEBUF
		mov	cx, 6
		xor	dx, dx
		mov	ax, dx
		push	bx
		call	SETREAD
		push	ds
		lds	si, [BCLOCK]
		call	DEVIOCALL2
		pop	ds
		pop	bx
		call	SETWRITE
		pop	word [TIMEBUF+4]
		pop	word [TIMEBUF+2]
		lds	si, [BCLOCK]
		call	DEVIOCALL2
		xor	al, al
		retn

; =============== S U B	R O U T	I N E =======================================


 DATE16:		; ...
		mov	ds, [cs:DosDSeg]
		push	cx
		push	es
		call	READTIME
		pop	es
		shl	cl, 1
		shl	cl, 1
		shl	cx, 1
		shl	cx, 1
		shl	cx, 1
		shr	dh, 1
		or	cl, dh
		mov	dx, cx
		mov	ax, word [MONTH]
		mov	cl, 4
		shl	al, cl
		shl	ax, 1
		pop	cx
		or	al, [DAY]

RET21:					; ...
		retn

; =============== S U B	R O U T	I N E =======================================

READTIME:		; ...
		mov	word [DATE_FLAG], 0
		push	si
		push	bx
		mov	bx, TIMEBUF
		mov	cx, 6
		xor	dx, dx
		mov	ax, dx
		call	SETREAD
		push	ds
		lds	si, [BCLOCK]
		call	DEVIOCALL2
		pop	ds
		pop	bx
		pop	si
		mov	ax, [TIMEBUF]
		mov	cx, [TIMEBUF+2]
		mov	dx, [TIMEBUF+4]
		cmp	ax, [DAYCNT]
		jz	short RET21
		cmp	ax, 43830	; FOURYEARS*30
		jnb	short RET22
		mov	[DAYCNT], ax
		push	si
		push	cx
		push	dx
		xor	dx, dx
		mov	cx, 1461	; FOURYEARS
		div	cx
		shl	ax, 1
		shl	ax, 1
		shl	ax, 1
		mov	cx, ax
		mov	si, YRTAB
		call	DSLIDE
		shr	cx, 1
		jnb	short SK
		add	dx, 200

SK:					; ...
		call	SETYEAR
		mov	cl, 1
		mov	si, MONTAB
		call	DSLIDE
		mov	[MONTH], cl
		inc	dx
		mov	[DAY], dl
		call	WKDAY
		pop	dx
		pop	cx
		pop	si

RET22:					; ...
		retn

; =============== S U B	R O U T	I N E =======================================

DSLIDE:		; ...
		mov	ah, 0

DSLIDE1:				; ...
		lodsb
		cmp	dx, ax
		jb	short RET22
		sub	dx, ax
		inc	cx
		jmp	short DSLIDE1

; =============== S U B	R O U T	I N E =======================================

SETYEAR:
		mov	ds, [cs:DosDSeg]
		mov	byte [YEAR], cl

CHKYR:					; ...
		test	cl, 3
		mov	al, 28
		jnz	short SAVFEB
		inc	al

SAVFEB:					; ...
		mov	[february], al ; [MONTAB+1]

RET23:					; ...
		retn

; =============== S U B	R O U T	I N E =======================================

DODATE:		; ...
		call	CHKYR
		mov	al, dh
		mov	bx, YRTAB+7	; offset MONTAB-1
		xlat
		cmp	al, dl
		mov	al, -1
		jb	short RET23
		call	SETYEAR
		mov	word [DAY], dx
		shr	cx, 1
		shr	cx, 1
		mov	ax, 1461	; FOURYEARS
		mov	bx, dx
		mul	cx
		mov	cl, byte [YEAR]
		and	cl, 3
		mov	si, YRTAB
		mov	dx, ax
		shl	cx, 1
		call	DSUM
		mov	cl, bh
		mov	si, MONTAB
		dec	cx
		call	DSUM
		mov	cl, bl
		dec	cx
		add	dx, cx
		xchg	ax, dx
		mov	[DAYCNT], ax
		push	si
		push	bx
		push	ax
		mov	bx, TIMEBUF
		mov	cx, 6
		xor	dx, dx
		mov	ax, dx
		push	bx
		call	SETREAD
		push	ds
		lds	si, [BCLOCK]
		call	DEVIOCALL2
		pop	ds
		pop	bx
		call	SETWRITE
		pop	word [TIMEBUF]
		push	ds
		lds	si, [BCLOCK]
		call	DEVIOCALL2
		pop	ds
		pop	bx
		pop	si

WKDAY:					; ...
		mov	ax, [DAYCNT]
		xor	dx, dx
		mov	cx, 7
		inc	ax
		inc	ax
		div	cx
		mov	[WEEKDAY], dl
		xor	al, al
		retn

; =============== S U B	R O U T	I N E =======================================

DSUM:		; ...
		mov	ah, 0
		jcxz	DUSUM9

DSUM1:					; ...
		lodsb
		add	dx, ax
		loop	DSUM1

DUSUM9:					; ...
		retn
; ---------------------------------------------------------------------------

_$GET_VERSION:				; ...
		push	ss
		pop	ds
		mov	bx, word [USERNUM+2]
		mov	cx, word [USERNUM]
		cmp	al, 1
		jnz	short Norm_Vers
		xor	bh, bh

Norm_Vers:				; ...
		push	ds
		mov	ds, [CurrentPDB]
		mov	ax, [40h]	; [PDB.Version]
		pop	ds
		call	Get_User_Stack
		mov	[si], ax	; [SI+user_env.user_AX]
		mov	[si+2],	bx	; [SI+user_env.user_BX]
		mov	[si+4],	cx	; [SI+user_env.user_CX]
		retn
; ---------------------------------------------------------------------------

_$GET_VERIFY_ON_WRITE:			; ...
		mov	al, [ss:VERFLG]
		retn
; ---------------------------------------------------------------------------

_$SET_VERIFY_ON_WRITE:			; ...
		and	al, 1
		mov	[ss:VERFLG], al

RET27:					; ...
		retn
; ---------------------------------------------------------------------------

_$INTERNATIONAL:			; ...
		cmp	al, 0FFh
		jz	short BX_HAS_CODE
		mov	bl, al
		xor	bh, bh

BX_HAS_CODE:				; ...
		push	ds
		pop	es
		push	dx
		pop	di
		push	ss
		pop	ds
		cmp	di, 0FFFFh	; -1
		jz	short international_set
		or	bx, bx
		jnz	short international_find
		mov	si, COUNTRY_CDPG
		jmp	short international_copy
; ---------------------------------------------------------------------------

international_find:			; ...
		mov	bp, 0
		call	international_get
		jb	short errtn
		cmp	bx, 0
		jnz	short international_copy
		mov	bx, dx
		jmp	short international_ok3

; =============== S U B	R O U T	I N E =======================================


 international_get:	; ...
		mov	si, COUNTRY_CDPG
		cmp	bx, [ss:si+68h]	; [SI+DOS_CCDPG.ccDosCountry]
		jz	short RET27
		mov	dx, bx
		xor	bx, bx
		mov	ax, 1400h
		int	2Fh		; - Multiplex -	NLSFUNC.COM - INSTALLATION CHECK
					; Return: AL = 00h not installed, OK to	install
					; 01h not installed, not OK
					; FFh installed
		cmp	al, 0FFh
		jnz	short interr
		or	bp, bp
		jnz	short stcdpg
		mov	ax, 1404h
		int	2Fh		; - Multiplex -	NLSFUNC.COM - GET COUNTRY INFO
					; BX = code page, DX = country code, DS:SI -> internal code page structure
					; ES:DI	-> user	buffer
					; Return: AL = status
		jmp	short chkok
; ---------------------------------------------------------------------------

stcdpg:					; ...
		mov	ax, 1403h
		int	2Fh		; - Multiplex -	NLSFUNC.COM - SET COUNTRY INFO
					; DS:SI	-> internal code page structure
					; BX = code page, DX = country code
					; Return: AL = status

chkok:					; ...
		or	al, al
		jz	short RET27

setcarry:				; ...
		stc
		retn
; ---------------------------------------------------------------------------

interr:					; ...
		mov	al, 0FFh
		jmp	short setcarry

; ---------------------------------------------------------------------------

international_copy:			; ...
		mov	bx, [ss:si+68h]	; [ss:SI+DOS_CCDPG.ccDosCountry]
		mov	si, COUNTRY_CDPG_108 ; COUNTRY_CDPG + 108
		mov	cx, 24		; OLD_COUNTRY_SIZE
		push	ds
		push	ss
		pop	ds
		rep movsb
		pop	ds

international_ok3:			; ...
		call	Get_User_Stack
		mov	[si+2],	bx	; [SI+user_env.user_BX]

international_ok:			; ...
		mov	ax, bx

SYS_RET_OK_jmp:				; ...
		jmp	SYS_RETURN	; SYS_RET_OK
; ---------------------------------------------------------------------------

international_set:			; ...
		mov	bp, 1
		call	international_get
		jnb	short international_ok

errtn:					; ...
		cmp	al, 0FFh
		jz	short errtn2

errtn1:					; ...
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

errtn2:					; ...
		mov	al, 1		; error_invalid_function
		jmp	short errtn1
; ---------------------------------------------------------------------------

_$GetExtCntry:				; ...
		cmp	al, 20h		; CAP_ONE_CHAR
		jb	short notcap
		test	al, 80h		; UPPER_TABLE
		jnz	short fileupper
		mov	bx, UCASE_TAB_2 ; UCASE_TAB+2
		jmp	short capit
; ---------------------------------------------------------------------------

fileupper:				; ...
		mov	bx, FILE_UCASE_TAB_2 ; FILE_UCASE_TAB+2

capit:					; ...
		cmp	al, 20h		; CAP_ONE_CHAR
		jnz	short chkyes
		mov	al, dl
		call	GETLET3
		call	Get_User_Stack
		mov	[si+6],	al	; [SI+user_env.user_DX]
		jmp	short nono
; ---------------------------------------------------------------------------

chkyes:					; ...
		cmp	al, 23h		; CHECK_YES_NO
		jnz	short capstring
		xor	ax, ax
		cmp	dl, [cs:NLS_YES] ; 'Y'
		jz	short yesyes
		cmp	dl, [cs:NLS_yes2] ; 'y'
		jz	short yesyes
		cmp	dl, [cs:NLS_NO]	; 'n'
		jz	short nono
		cmp	dl, [cs:NLS_no2]
		jz	short nono
		inc	ax

yesyes:					; ...
		inc	ax

nono:					; ...
		jmp	short SYS_RET_OK_jmp
; ---------------------------------------------------------------------------

capstring:				; ...
		mov	si, dx
		cmp	al, 21h		; CAP_STRING
		jnz	short capascii
		or	cx, cx
		jz	short nono

concap:					; ...
		lodsb
		call	GETLET3
		mov	[si-1],	al
		loop	concap
		jmp	short nono
; ---------------------------------------------------------------------------

capascii:				; ...
		cmp	al, 22h		; CAP_ASCIIZ
		jnz	short capinval

concap2:				; ...
		lodsb
		or	al, al
		jz	short nono
		call	GETLET3
		mov	[si-1],	al
		jmp	short concap2
; ---------------------------------------------------------------------------

notcap:					; ...
		cmp	cx, 5
		jb	short sizeerror
		push	ss
		pop	ds
		mov	si, COUNTRY_CDPG
		cmp	dx, 0FFFFh	; -1
		jnz	short GETCDPG
		mov	dx, [si+68h]	; [SI+DOS_CCDPG.ccDosCountry]

GETCDPG:				; ...
		cmp	bx, 0FFFFh	; -1
		jnz	short CHKAGAIN
		mov	bx, [si+6Ah]	; [SI+DOS_CCDPG.ccDosCodePage]

CHKAGAIN:				; ...
		cmp	dx, [si+68h]	; [SI+DOS_CCDPG.ccDosCountry]
		jnz	short CHKNLS
		cmp	bx, [si+6Ah]	; [SI+DOS_CCDPG.ccDosCodePage]
		jnz	short CHKNLS
		mov	bx, [si+48h]	; [SI+DOS_CCDPG.ccSysCodePage]
		push	cx
		mov	cx, [si+4Ah]	; [SI+DOS_CCDPG.ccNumber_of_entries]
		mov	si, COUNTRY_CDPG_76 ; COUNTRY_CDPG+76
					; COUNTRY_CDPG+DOS_CCDPG.ccSetUcase

NXTENTRY:				; ...
		cmp	al, [si]
		jz	short FOUNDIT
		add	si, 5
		loop	NXTENTRY
		pop	cx

capinval:				; ...
		mov	al, 1

SYS_RET_ERR_jmp:			; ...
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

FOUNDIT:				; ...
		movsb
		pop	cx
		cmp	al, 1		; SetCountryInfo
		jz	short setsize
		mov	cx, 4
		mov	ax, 5

OK_RETN:				; ...
		rep movsb
		mov	cx, ax
		mov	ax, bx

GETDONE:				; ...
		call	Get_User_Stack
		mov	[si+4],	cx	; [SI+user_env.user_CX]

nono_jmp:				; ...
		jmp	short nono
; ---------------------------------------------------------------------------

setsize:				; ...
		sub	cx, 3
		cmp	[si], cx
		jnb	short setsize2
		mov	cx, [si]

setsize2:				; ...
		mov	[es:di], cx
		add	di, 2
		add	si, 2
		mov	ax, cx
		add	ax, 3
		jmp	short OK_RETN
; ---------------------------------------------------------------------------

CHKNLS:					; ...
		xor	ah, ah
		push	ax
		pop	bp
		mov	ax, 1400h
		int	2Fh		; - Multiplex -	NLSFUNC.COM - INSTALLATION CHECK
					; Return: AL = 00h not installed, OK to	install
					; 01h not installed, not OK
					; FFh installed
		cmp	al, 0FFh
		jz	short NLSNXT

sizeerror:				; ...
		mov	al, 1		; error_invalid_function

sys_ret_err_jmp2:			; ...
		jmp	short SYS_RET_ERR_jmp
; ---------------------------------------------------------------------------

NLSNXT:					; ...
		mov	ax, 1402h
		int	2Fh		; - Multiplex -	NLSFUNC.COM - GET COUNTRY INFO
					; BP = subfunction, BX = code page
					; DX = country code, DS:SI -> internal code page structure
					; ES:DI	-> user	buffer,	CX = size of user buffer
					; Return: AL = status
					; 00h successful
					; else DOS error code
		cmp	al, 0
		jnz	short NLSERROR
		mov	ax, [si+48h]	; [SI+DOS_CCDPG.ccSysCodePage]
		jmp	short GETDONE
; ---------------------------------------------------------------------------

NLSERROR:				; ...
		jmp	short sys_ret_err_jmp2
; ---------------------------------------------------------------------------

_$GetSetCdPg:				; ...
		push	ss
		pop	ds
		mov	si, COUNTRY_CDPG
		cmp	al, 1
		jnz	short setglpg
		mov	bx, [si+6Ah]	; [SI+DOS_CCDPG.ccDosCodePage]
		mov	dx, [si+48h]	; [SI+DOS_CCDPG.ccSysCodePage]
		call	Get_User_Stack
		mov	[si+2],	bx
		mov	[si+6],	dx

OK_RETURN:				; ...
		jmp	short nono_jmp
; ---------------------------------------------------------------------------

setglpg:				; ...
		cmp	al, 2
		jnz	short nomem
		mov	dx, [si+68h]	; [SI+DOS_CCDPG.ccDosCountry]
		mov	ax, 1400h
		int	2Fh		; - Multiplex -	NLSFUNC.COM - INSTALLATION CHECK
					; Return: AL = 00h not installed, OK to	install
					; 01h not installed, not OK
					; FFh installed
		cmp	al, 0FFh
		jnz	short nomem
		mov	ax, 1401h
		int	2Fh		; - Multiplex -	NLSFUNC.COM - CHANGE CODE PAGE
					; DS:SI	-> internal code page structure
					; BX = new code	page, DX = country code???
					; Return: AL = status
					; 00h successful
					; else DOS error code
		or	al, al
		jz	short OK_RETURN
		cmp	al, 65
		jnz	short seterr
		mov	ax, 65
		mov	[EXTERR], ax
		mov	byte [EXTERR_ACTION], 6 ; errACT_Ignore
		mov	byte [EXTERR_CLASS], 5 ; errCLASS_HrdFail
		mov	byte [EXTERR_LOCUS], 4 ; errLOC_SerDev
		jmp	From_GetSet
; ---------------------------------------------------------------------------

seterr:					; ...
		jmp	short NLSERROR
; ---------------------------------------------------------------------------

nomem:					; ...
		mov	al, 1		; error_invalid_function
		jmp	short seterr
; ---------------------------------------------------------------------------

_$GET_DRIVE_FREESPACE:			; ...
		push	ss
		pop	ds
		mov	al, dl
		call	GETTHISDRV

SET_AX_RET:				; ...
		jb	short BADFDRV
		call	DISK_INFO
		xchg	dx, bx
		jb	short SET_AX_RET
		xor	ah, ah

DoSt:					; ...
		call	Get_User_Stack
		mov	[si+6],	dx	; [SI+user_env.user_DX]
		mov	[si+4],	cx	; [SI+user_env.user_CX]
		mov	[si+2],	bx	; [SI+user_env.user_BX]
		mov	[si], ax	; [SI+user_env.user_AX]
		retn
; ---------------------------------------------------------------------------

BADFDRV:				; ...
		call	FCB_RET_ER
		mov	ax, 0FFFFh	; -1
		jmp	short DoSt
; ---------------------------------------------------------------------------

_$GET_DMA:				; ...
		mov	bx, word [ss:DMAADD]
		mov	cx, word [ss:DMAADD+2]
		call	Get_User_Stack
		mov	[si+2],	bx	; [SI+user_env.user_BX]
		mov	[si+10h], cx	; [SI+user_env.user_ES]
		retn
; ---------------------------------------------------------------------------

_$SET_DMA:				; ...
		mov	word [ss:DMAADD], dx
		mov	word [ss:DMAADD+2],	ds
		retn
; ---------------------------------------------------------------------------

_$GET_DEFAULT_DRIVE:			; ...
		mov	al, [ss:CURDRV]
		retn
; ---------------------------------------------------------------------------

_$SET_DEFAULT_DRIVE:			; ...
		mov	al, dl
		inc	al
		call	GetVisDrv
		jb	short SETRET
		mov	[ss:CURDRV], al

SETRET:					; ...
		mov	al, [ss:CDSCOUNT]
		retn

; =============== S U B	R O U T	I N E =======================================


 _$GET_INTERRUPT_VECTOR: ; ...
		call	RECSET
		les	bx, [es:bx]
		call	Get_User_Stack
		mov	[si+2],	bx	; [SI+user_env.user_BX]
		mov	word [si+10h], es ;	[SI+user_env.user_ES]
		retn

; ---------------------------------------------------------------------------

_$SET_INTERRUPT_VECTOR:			; ...
		call	RECSET
		cli
		mov	[es:bx], dx
		mov	word [es:bx+2], ds
		sti
		test	byte [ss:DOS_FLAG], 4 ; EXECA20OFF
		jnz	short siv_1
		retn
; ---------------------------------------------------------------------------

siv_1:					; ...
		cmp	byte [ss:A20OFF_COUNT], 0
		jnz	short siv_2
		mov	byte [ss:A20OFF_COUNT], 1

siv_2:					; ...
		retn

; =============== S U B	R O U T	I N E =======================================


 RECSET:		; ...
		xor	bx, bx
		mov	es, bx
		mov	bl, al
		shl	bx, 1
		shl	bx, 1
		retn

; ---------------------------------------------------------------------------

_$CHAR_OPER:				; ...
		or	al, al
		mov	dl, '/'
		jz	short chop_1
		cmp	al, 2
		mov	dl, 0FFh	; -1
		jz	short chop_1
		retn
; ---------------------------------------------------------------------------

chop_1:					; ...
		call	Get_User_Stack
		mov	[si+6],	dx	; [SI+user_env.user_DX]
		retn
; ---------------------------------------------------------------------------

_$GetExtendedError:			; ...
		push	ss
		pop	ds
		mov	ax, [EXTERR]
		les	di, [EXTERRPT]
		mov	bx, word [EXTERR_ACTION]	; BL = Action
					; BH = Class
		mov	ch, [EXTERR_LOCUS]
		call	Get_User_Stack
		mov	[si+0Ah], di	; [SI+user_env.user_DI]
		mov	word [si+10h], es ;	[SI+user_env.user_ES]
		mov	[si+2],	bx	; [SI+user_env.user_BX]
		mov	[si+4],	cx	; [SI+user_env.user_CX]

jmp_SYS_RET_OK:				; ...
		jmp	SYS_RETURN
; ---------------------------------------------------------------------------
		push	si
		mov	si, COUNTRY_CDPG
		mov	ax, [ss:si+6Ah]	; [SI+DOS_CCDPG.ccDosCodePage]
		pop	si
		retn
; ---------------------------------------------------------------------------

_$ECS_Call:				; ...
		or	al, al
		jnz	short _okok
		call	Get_User_Stack
		mov	word [si+8], DBCS_TAB+2 ;
					; [si+user_env.user_SI]
		push	es
		mov	es, [cs:DosDSeg]
		mov	word [si+0Eh], es ;	[SI+user_env.user_DS]
		pop	es

_okok:					; ...
		jmp	short jmp_SYS_RET_OK
; ---------------------------------------------------------------------------

_$PARSE_FILE_DESCRIPTOR:		; ...
		call	MAKEFCB
		push	si
		call	Get_User_Stack
		pop	word [si+8]	; [SI+user_env.user_SI]
		retn
; ---------------------------------------------------------------------------

_$SLEAZEFUNC:				; ...
		mov	dl, 0

_$SLEAZEFUNCDL:				; ...
		push	ss
		pop	ds
		mov	al, dl
		call	GETTHISDRV

SET_AL_RET:				; ...
		jb	short BADSLDRIVE
		call	DISK_INFO
		jb	short SET_AL_RET
		mov	[FATBYTE], ah
		mov	di, FATBYTE
		xor	ah, ah
		call	Get_User_Stack
		mov	[si+4],	cx	; [SI+user_env.user_CX]
		mov	[si+6],	bx	; [SI+user_env.user_DCX]
		mov	[si+2],	di	; [SI+user_env.user_BX]
		mov	word [si+0Eh], ss ;	[SI+user_env.user_DS]
		retn
; ---------------------------------------------------------------------------

BADSLDRIVE:				; ...
		jmp	FCB_RET_ER
; ---------------------------------------------------------------------------

_$GET_INDOS_FLAG:			; ...
		call	Get_User_Stack
		mov	word [si+2], INDOS ; word [SI+user_env.user_BX]
		mov	word [si+10h], ss  ; [SI+user_env.user_ES]
		retn
; ---------------------------------------------------------------------------

_$GET_IN_VARS:				; ...
		call	Get_User_Stack
		mov	word [si+2], SYSINITVARS ;
					; [SI+user_env.user_BX]
		mov	word [si+10h], ss ; [SI+user_env.user_ES]
		retn
; ---------------------------------------------------------------------------

_$GET_DEFAULT_DPB:			; ...
		mov	dl, 0

_$GET_DPB:				; ...
		push	ss
		pop	ds
		mov	al, dl
		call	GETTHISDRV
		jb	short ISNODRV
		les	di, [THISCDS]
		test	byte [es:di+44h], 80h ; [ES:DI+curdir.flags+1],
					; (curdir_isnet>>8)
		jnz	short ISNODRV
		call	ECritDisk
		call	FATREAD_CDS
		call	LCritDisk
		jb	short ISNODRV
		call	Get_User_Stack
		mov	[si+2],	bp	; [SI+user_env.user_BX]
		mov	word [si+0Eh], es ;	[SI+user_env.user_DS]
		xor	al, al
		retn
; ---------------------------------------------------------------------------

ISNODRV:				; ...
		mov	al, 0FFh	; -1
		retn
; ---------------------------------------------------------------------------

_$DISK_RESET:				; ...
		mov	al, -1		; 0FFh
		push	ss
		pop	ds
		call	ECritDisk
		or	word [DOS34_FLAG], 4 ; FROM_DISK_RESET
		call	FLUSHBUF
		and	word [DOS34_FLAG], 0FFFBh ; NO_FROM_DISK_RESET
		mov	word [SC_STATUS], 0
		mov	bx, -1
		mov	word [LastBuffer+2], bx
		mov	word [LastBuffer], bx
		call	LCritDisk
		mov	ax, -1		; 0FFFFh
		push	ax
		mov	ax, 1120h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - FLUSH ALL DISK BUFFERS
					; DS = DOS CS
					; Return: CF clear (successful)
		pop	ax
		retn
; ---------------------------------------------------------------------------
_word_3		dw 3			; ...
; ---------------------------------------------------------------------------

_$SETDPB:				; ...
		mov	di, bp
		add	di, 2
		lodsw
		stosw
		cmp	byte [si+3], 0 ; [SI+A_BPB.BPB_NUMBEROFFATS-2]
		jnz	short yesfat
		mov	byte [es:di+4], 0 ;	[ES:DI+DPB.FAT_COUNT-4]
		jmp	short setend
; ---------------------------------------------------------------------------

yesfat:					; ...
		mov	dx, ax
		lodsb
		dec	al
		stosb
		inc	al
		xor	ah, ah

LOG2LOOP:				; ...
		test	al, 1
		jnz	short SAVLOG
		inc	ah
		shr	al, 1
		jmp	short LOG2LOOP
; ---------------------------------------------------------------------------

SAVLOG:					; ...
		mov	al, ah
		stosb
		mov	bl, al
		movsw
		lodsb
		stosb
		mov	bh, al
		lodsw
		stosw
		mov	cl, 5
		shr	dx, cl
		dec	ax
		add	ax, dx
		mov	cx, dx
		xor	dx, dx
		div	cx
		mov	cx, ax
		inc	di
		inc	di
		movsw
		lodsb
		mov	[es:bp+17h], al	; [ES:BP+DPB.MEDIA]
		lodsw
		stosw
		mov	dl, bh
		xor	dh, dh
		mul	dx
		add	ax, [es:bp+6]	; [ES:BP+DPB.FIRST_FAT]
		stosw
		add	ax, cx
		mov	[es:bp+0Bh], ax	; [ES:BP+DPB.FIRST_SECTOR]
		mov	cl, bl
		cmp	word [es:bp+0Dh], 0
		jnz	short normal_dpb
		xor	ch, ch
		mov	bx, [si+8]	; [SI+A_BPB.BPB_BIGTOTALSECTORS-A_BPB.BPB_SECTORSPERTRACK]
		mov	dx, [si+0Ah]	; [SI+A_BPB.BPB_BIGTOTALSECTORS-A_BPB.BPB_SECTORSPERTRACK+2]
		sub	bx, ax
		sbb	dx, 0
		or	cx, cx
		jz	short norot

rott:					; ...
		clc
		rcr	dx, 1
		rcr	bx, 1
		loop	rott

norot:					; ...
		mov	ax, bx
		jmp	short setend
; ---------------------------------------------------------------------------

normal_dpb:				; ...
		sub	ax, [es:bp+0Dh]
		neg	ax
		shr	ax, cl

setend:					; ...
		inc	ax
		mov	bx, ax
		mov	ax, [es:bp+0Fh]	; [ES:BP+DPB.FAT_SIZE]
		mul	word [es:bp+2] ; [ES:BP+DPB.SECTOR_SIZE]
		cmp	bx, 0FF6h	; 4096-10
		jb	short setend_fat12
		shr	dx, 1
		rcr	ax, 1
		cmp	ax, 0FF7h	; 4096-10+1
		jb	short setend_faterr
		jmp	short setend_fat16
; ---------------------------------------------------------------------------

setend_fat12:				; ...
		add	ax, ax
		adc	dx, dx
		div	word [cs:_word_3]

setend_fat16:				; ...
		dec	ax
		cmp	ax, bx
		jbe	short setend_fat

setend_faterr:				; ...
		mov	ax, bx

setend_fat:				; ...
		mov	[es:bp+0Dh], ax	; [ES:BP+DPB.MAX_CLUSTER]
		mov	word [es:bp+1Dh], 0 ; [ES:BP+DPB.NEXT_FREE]
		mov	word [es:bp+1Fh], -1 ; [ES:BP+DPB.FREE_CNT]
		retn

; =============== S U B	R O U T	I N E =======================================

_$DUP_PDB:	
		mov	ds, [cs:DosDSeg]
		mov	byte [CreatePDB], 0FFh
		mov	ds, [CurrentPDB]
		push	si
		jmp	short CreateCopy
; ---------------------------------------------------------------------------

_$CREATE_PROCESS_DATA_BLOCK:		; ...
		call	Get_User_Stack
		mov	ds, word [si+14h] ; [SI+user_env.user_CS]
		push	word [2]	; [PDB.BLOCK_LEN]

CreateCopy:				; ...
		mov	es, dx
		xor	si, si
		mov	di, si
		mov	cx, 128
		rep movsw
		mov	cx, 20		; FILPERPROC
		mov	di, 18h		; PDB.JFN_TABLE
		push	ds
		lds	si, [34h]	; [PDB.JFN_Pointer]
		rep movsb
		pop	ds
		mov	ds, [cs:DosDSeg]
		cmp	byte [CreatePDB], 0
		jz	short Create_PDB_cont
		mov	ds, [cs:DosDSeg]
		xor	bx, bx
		mov	cx, 20

Create_dup_jfn:				; ...
		push	es
		call	SFFromHandle
		mov	al, -1		; 0FFh
		jb	short CreateStash
		test	byte [es:di+6], 10h ; [ES:DI+SF_ENTRY.sf_flags+1],
					; (sf_no_inherit>>8)
		jnz	short CreateStash
		mov	ah, [es:di+2]	; [ES:DI+SF_ENTRY.sf_mode]
		and	ah, 0F0h	; SHARING_MASK
		cmp	ah, 70h		; SHARING_NET_FCB
		jz	short CreateStash
		mov	word [THISSFT], di
		mov	word [THISSFT+2], es
		call	DOS_DUP
		call	pJFNFromHandle
		mov	al, [es:di]

CreateStash:				; ...
		pop	es
		mov	[es:bx+18h], al	; [ES:BX+PDB.JFN_TABLE]
		inc	bx
		loop	Create_dup_jfn
		mov	bx, [CurrentPDB]
		mov	[es:16h], bx	; [ES:PDB.PARENT_PID]
		mov	[CurrentPDB], es
		mov	ds, bx

Create_PDB_cont:			; ...
		push	ds
		mov	ds, [cs:DosDSeg]
		mov	byte [CreatePDB], 0
		pop	ds
		pop	ax

SETMEM:					; ...
		xor	cx, cx
		mov	ds, cx
		mov	es, dx
		mov	si, 88h		; addr_int_terminate
		mov	di, 0Ah		; SAVEXIT
		mov	cx, 6
		rep movsw
		mov	[es:2],	ax
		sub	ax, dx
		cmp	ax, 0FFFh	; MAXDIF
		jbe	short HAVDIF
		mov	ax, 0FFFh

HAVDIF:					; ...
		sub	ax, 10h
		mov	bx, 0Ch		; ENTRYPOINTSEG
		sub	bx, ax
		mov	cl, 4
		shl	ax, cl
		mov	ds, dx
		mov	[6],	ax	; [PDB.CPM_CALL+1]
		mov	[8],	bx	; [PDB.CPM_CALL+3]
		cmp	ax, 0FEF0h	; WRAPOFFSET
		jz	short addr_ok
		mov	word [6], 0C0h
		mov	word [8], 0

addr_ok:				; ...
		mov	word [0], 20CDh ; [PDB.EXIT_CALL],
					; (int_abort*256) + mi_INT
		mov	byte [5], 9Ah ; [PDB.CPM_CALL],mi_Long_CALL
		mov	word [50h], 21CDh ; [PDB.CALL_SYSTEM],
					; (int_command*256) + mi_INT
		mov	byte [52h], 0CBh	; [PDB.CALL_SYSTEM+2],mi_Long_RET
		mov	word [34h], 18h ; [PDB.JFN_Pointer],PDB.JFN_TABLE
		mov	word [36h], ds ;	[PDB.JFN_Pointer+2]
		mov	word [32h], 20 ;	[PDB.JFN_Length],FILPERPROC
		mov	word [38h], 0FFFFh ; [PDB.Next_PDB],-1
		mov	word [3Ah], 0FFFFh ; [PDB.Next_PDB+2],-1
		mov	word [es:40h], 5 ; [ES:PDB.Version],
					; (MINOR_VERSION*256)+MAJOR_VERSION
		retn

; ---------------------------------------------------------------------------

_$GSetMediaID:				; ...
		mov	cx, 866h	; RAWIO	- GET_MEDIA_ID
		cmp	al, 0		; get ?
		jz	short doioctl	; yes
		cmp	al, 1		; set ?
		jnz	short errorfunc	; no, error
		mov	cx, 846h	; RAWIO	- SET_MEDIA_ID

doioctl:				; ...
		mov	al, 0Dh		; generic IOCTL
		call	_$IOCTL
		retn
; ---------------------------------------------------------------------------

errorfunc:				; ...
		mov	al, 1		; error_invalid_function
		jmp	SYS_RET_ERR

; =============== S U B	R O U T	I N E =======================================


 StrCmp:		; ...
		push	si
		push	di
		push	ax

Cmplp:					; ...
		lodsb
		call	UCase
		call	PATHCHRCMP
		mov	ah, al
		mov	al, [es:di]
		inc	di
		call	UCase
		call	PATHCHRCMP
		cmp	ah, al
		jnz	short PopRet
		or	al, al
		jnz	short Cmplp

PopRet:					; ...
		pop	ax
		pop	di
		pop	si
		retn

; =============== S U B	R O U T	I N E =======================================


 StrCpy:		; ...
		push	ax

CPYLoop:				; ...
		lodsb
		call	UCase
		call	PATHCHRCMP
		stosb
		or	al, al
		jnz	short CPYLoop
		pop	ax
		retn

; =============== S U B	R O U T	I N E =======================================

FStrCpy:
		push	ax

FCPYLoop:				; ...
		lodsb
		stosb
		or	al, al
		jnz	short FCPYLoop
		pop	ax
		retn

; =============== S U B	R O U T	I N E =======================================

StrLen:		; ...
		push	di
		push	ax
		mov	cx, 65535
		xor	al, al
		repne scasb
		not	cx
		pop	ax
		pop	di
		retn

; =============== S U B	R O U T	I N E =======================================

DStrLen:
		call	XCHGP
		call	StrLen
		call	XCHGP
		retn

; =============== S U B	R O U T	I N E =======================================

XCHGP:		; ...
		push	ds
		push	es
		pop	ds
		pop	es
		xchg	si, di

xchgp_retn:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================

Idle:		; ...
		cmp	byte [ss:FSHARING], 0
		jnz	short xchgp_retn
		push	cx
		mov	cx, [ss:RetryLoop]
		jcxz	Idle3

Idle1:					; ...
		push	cx
		xor	cx, cx

Idle2:					; ...
		loop	Idle2
		pop	cx
		loop	Idle1

Idle3:					; ...
		pop	cx
		retn

; ---------------------------------------------------------------------------

TableDispatch:				; ...
		push	bp
		mov	bp, sp
		push	bx
		mov	bx, [bp+6]	; [BP+TFrame.Tab]
		mov	bl, [cs:bx]
		cmp	[bp+4],	bl	; [BP+TFrame.Index]
		jnb	short TableError
		mov	bl, [bp+4]	; [BP+TFrame.Index]
		xor	bh, bh
		shl	bx, 1
		inc	bx
		add	bx, [bp+6]	; [BP+TFrame.Tab]
		mov	bx, [cs:bx]
		mov	[bp+6],	bx	; [BP+TFrame.Tab]
		pop	bx
		pop	bp
		add	sp, 4
		retn
; ---------------------------------------------------------------------------

TableError:				; ...
		pop	bx
		pop	bp
		retn	6

; =============== S U B	R O U T	I N E =======================================

TestNet:
		mov	es, [cs:DosDSeg]
		les	di, [es:THISCDS]
		cmp	di, -1
		jz	short CMCRet
		test	byte [es:di+44h], 80h ; [ES:DI+curdir.flags+1],
					; (curdir_isnet>>8)
		jnz	short CMCRet
		retn
; ---------------------------------------------------------------------------

CMCRet:					; ...
		cmc
		retn

; =============== S U B	R O U T	I N E =======================================

IsSFTNet:		; ...
		test	byte [es:di+6], 80h	; [ES:DI+SF_ENTRY.sf_flags+1],
					; (sf_isnet>>8)
		retn

; ---------------------------------------------------------------------------

FastInit:				; ...
		push	es
		mov	es, [cs:DosDSeg]
		mov	di, FastOpenTable_2 ; FastTable+2
		dec	bx
		mov	dx, bx
		shl	bx, 1
		shl	bx, 1
		add	di, bx
		mov	ax, [es:di+2]
		mov	cx, cs
		cmp	ax, cx
		jz	short ok_install
		or	ax, ax
		jz	short ok_install
		stc
		jmp	short FSret
; ---------------------------------------------------------------------------

ok_install:				; ...
		cmp	si, -1
		jz	short FSret
		mov	cx, ds
		mov	[es:di+2], cx
		mov	[es:di], si
		mov	di, FastOpenFlg ; FastFlg
		add	di, dx
		or	byte [es:di], 80h ; Fast_yes

FSret:					; ...
		pop	es
		retn
; ---------------------------------------------------------------------------

FastRet:				; ...
		stc
		sbb	ax, ax
		retf
; ---------------------------------------------------------------------------

NLS_OPEN:				; ...
		mov	al, cl
		call	_$OPEN
		retn
; ---------------------------------------------------------------------------

NLS_LSEEK:				; ...
		push	word [ss:USER_SP]
		push	word [ss:USER_SS]
		call	Fake_User_Stack
		mov	ax, bp
		call	_$LSEEK
		pop	word [ss:USER_SS]
		pop	word [ss:USER_SP]
		retn

; =============== S U B	R O U T	I N E =======================================

Fake_User_Stack:
		mov	ax, [ss:USER_SP_2F]
		mov	[ss:USER_SP], ax
		mov	ax, ss
		mov	[ss:USER_SS], ax
		retn

; ---------------------------------------------------------------------------

GetDevList:				; ...
		mov	si, SysInitTable
		mov	ds, [cs:DosDSeg]
		lds	si, [si]
		mov	ax, [si+22h]	; [SI+SYSI.DEV]
		mov	bx, [si+24h]	; [SI+SYSI.DEV+2]
		retn
; ---------------------------------------------------------------------------

NLS_IOCTL:				; ...
		push	word [ss:USER_SP]
		push	word [ss:USER_SS]
		call	Fake_User_Stack
		mov	ax, bp
		call	_$IOCTL
		pop	word [ss:USER_SS]
		pop	word [ss:USER_SP]
		retn
; ---------------------------------------------------------------------------

NLS_GETEXT:				; ...
		mov	ax, [ss:EXTERR]
		retn
; ---------------------------------------------------------------------------

MSG_RETRIEVAL:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================

ECritDisk:		; ...
		pushf			; ECritMEM
					; ECritSFT
		cmp	byte [ss:redir_patch], 0
		jz	short ECritDisk_2
		jmp	short ECritDisk_1
; ---------------------------------------------------------------------------

ECritDisk_iret:				; ...
		iret
; ---------------------------------------------------------------------------

ECritDisk_1:				; ...
		push	cs
		call	ECritDisk_iret

ECritDisk_0:
		push	ax
		mov	ax, 8001h
		int	2Ah		; Microsoft Networks - BEGIN DOS CRITICAL SECTION
					; AL = critical	section	number (00h-0Fh)
		pop	ax
		retn
; ---------------------------------------------------------------------------

ECritDisk_2:				; ...
		jmp	short ECritDisk_3
; ---------------------------------------------------------------------------

ECritDisk_iret2:			; ...
		iret
; ---------------------------------------------------------------------------

ECritDisk_3:				; ...
		push	cs
		call	ECritDisk_iret2
		retn

; =============== S U B	R O U T	I N E =======================================

LCritDisk:		; ...
		pushf			; LCritMEM
					; LCritSFT
		cmp	byte [ss:redir_patch], 0
		jz	short LCritDisk_2
		jmp	short LCritDisk_1
; ---------------------------------------------------------------------------

LCritDisk_iret:				; ...
		iret
; ---------------------------------------------------------------------------

LCritDisk_1:				; ...
		push	cs
		call	LCritDisk_iret
		push	ax
		mov	ax, 8101h
		int	2Ah		; Microsoft Networks - END DOS CRITICAL	SECTION
					; AL = critical	section	number (00h-0Fh)
		pop	ax
		retn
; ---------------------------------------------------------------------------

LCritDisk_2:				; ...
		jmp	short LCritDisk_3
; ---------------------------------------------------------------------------

LCritDisk_iret2:			; ...
		iret
; ---------------------------------------------------------------------------

LCritDisk_3:				; ...
		push	cs
		call	LCritDisk_iret2
		retn

; =============== S U B	R O U T	I N E =======================================

ECritDevice:	; ...
		pushf
		cmp	byte [ss:redir_patch], 0
		jz	short ECritDevice_2
		jmp	short ECritDevice_1
; ---------------------------------------------------------------------------

ECritDevice_iret:			; ...
		iret
; ---------------------------------------------------------------------------

ECritDevice_1:				; ...
		push	cs
		call	ECritDevice_iret
		push	ax
		mov	ax, 8002h
		int	2Ah		; Microsoft Networks - BEGIN DOS CRITICAL SECTION
					; AL = critical	section	number (00h-0Fh)
		pop	ax
		retn
; ---------------------------------------------------------------------------

ECritDevice_2:				; ...
		jmp	short ECritDevice_3
; ---------------------------------------------------------------------------

ECritDevice_iret2:			; ...
		iret
; ---------------------------------------------------------------------------

ECritDevice_3:				; ...
		push	cs
		call	ECritDevice_iret2
		retn

; =============== S U B	R O U T	I N E =======================================


 LCritDevice:	; ...
		pushf			; LCritMEM
					; LCritSFT
		cmp	byte [ss:redir_patch], 0
		jz	short LCritDevice_2
		jmp	short LCritDevice_1
; ---------------------------------------------------------------------------

LCritDevice_iret:			; ...
		iret
; ---------------------------------------------------------------------------

LCritDevice_1:				; ...
		push	cs
		call	LCritDevice_iret
		push	ax
		mov	ax, 8102h
		int	2Ah		; Microsoft Networks - END DOS CRITICAL	SECTION
					; AL = critical	section	number (00h-0Fh)
		pop	ax
		retn
; ---------------------------------------------------------------------------

LCritDevice_2:				; ...
		jmp	short LCritDevice_3
; ---------------------------------------------------------------------------

LCritDevice_iret2:			; ...
		iret
; ---------------------------------------------------------------------------

LCritDevice_3:				; ...
		push	cs
		call	LCritDevice_iret2
		retn

; =============== S U B	R O U T	I N E =======================================

_$STD_CON_INPUT_NO_ECHO:
		push	ds
		push	si

INTEST:					; ...
		call	STATCHK
		jnz	short GET
		cmp	byte [ss:PRINTER_FLAG], 0
		jnz	short no_sys_wait
		mov	ah, 5
		call	IOFUNC

no_sys_wait:				; ...
		mov	ah, 84h
		int	2Ah		; Microsoft Networks - KEYBOARD	BUSY LOOP
		cmp	byte [ss:DATE_FLAG], 0FFh ; -1
		jnz	short NoUpdate
		push	ax
		push	bx
		push	cx
		push	dx
		push	ds
		push	ss
		pop	ds
		mov	ax, 0
		call	Save_Restore_Packet
		call	READTIME
		mov	ax, 1
		call	Save_Restore_Packet
		pop	ds
		pop	dx
		pop	cx
		pop	bx
		pop	ax

NoUpdate:				; ...
		inc	word [ss:DATE_FLAG]
		jmp	short INTEST
; ---------------------------------------------------------------------------

GET:					; ...
		xor	ah, ah
		call	IOFUNC
		pop	si
		pop	ds
		mov	byte [ss:SCAN_FLAG], 0
		cmp	al, 0
		jnz	short noscan
		mov	byte [ss:SCAN_FLAG], 1

noscan:					; ...
		retn

; ---------------------------------------------------------------------------

_$STD_CON_STRING_OUTPUT:		; ...
		mov	si, dx

STRING_OUT1:				; ...
		lodsb
		cmp	al, '$'
		jz	short noscan
		call	OUTT
		jmp	short STRING_OUT1

; =============== S U B	R O U T	I N E =======================================

_$STD_CON_STRING_INPUT:

; FUNCTION CHUNK AT 4813 SIZE 00000019 BYTES

		mov	ax, ss
		mov	es, ax
		mov	si, dx
		xor	ch, ch
		lodsw
		or	al, al
		jz	short noscan
		mov	bl, ah
		mov	bh, ch
		cmp	al, bl
		jbe	short NOEDIT
		cmp	byte [bx+si], 0Dh ;	c_CR
		jz	short EDITON

NOEDIT:					; ...
		mov	bl, ch

EDITON:					; ...
		mov	dl, al
		dec	dx

NEWLIN:					; ...
		mov	al, [ss:CARPOS]
		mov	[ss:STARTPOS], al
		push	si
		mov	di, INBUF
		mov	[ss:INSMODE], ch
		mov	bh, ch
		mov	dh, ch
		call	_$STD_CON_INPUT_NO_ECHO
		cmp	al, 0Ah		; c_LF
		jnz	short GOTCH

GETCH:					; ...
		call	_$STD_CON_INPUT_NO_ECHO

GOTCH:					; ...
		cmp	al, 6		; "F"-"@"
		jz	short GETCH
		cmp	al, [cs:ESCCHAR]
		jz	short ESCAPE
		cmp	al, 7Fh		; c_DEL
		jz	short BACKSPJ
		cmp	al, 8		; c_BS
		jz	short BACKSPJ
		cmp	al, 17h		; W"-"@"
		nop
		nop
		cmp	al, 15h		; "U"-"@"
		nop
		nop
		cmp	al, 0Dh		; c_CR
		jz	short ENDLIN
		cmp	al, 0Ah		; c_LF
		jz	short PHYCRLF
		cmp	al, [cs:CANCHAR] ; 1Bh
		jz	short KILNEW

SAVCH:					; ...
		cmp	dh, dl
		jnb	short BUFFUL
		stosb
		inc	dh
		call	BUFOUT
		cmp	byte [ss:INSMODE], 0
		jnz	short GETCH
		cmp	bh, bl
		jnb	short GETCH
		inc	si
		inc	bh
		jmp	short GETCH
; ---------------------------------------------------------------------------

BACKSPJ:				; ...
		jmp	short BACKSP
; ---------------------------------------------------------------------------

BUFFUL:					; ...
		mov	al, 7
		call	OUTT
		jmp	short GETCH
; ---------------------------------------------------------------------------

ESCAPE:					; ...
		jmp	OEMFunctionKey
; ---------------------------------------------------------------------------

ENDLIN:					; ...
		stosb
		call	OUTT
		pop	di
		mov	[di-1],	dh
		inc	dh

COPYNEW:				; ...
		push	ds
		push	es
		pop	ds
		pop	es
		mov	si, INBUF
		mov	cl, dh
		rep movsb

OLDBAK_RETN:				; ...
		retn
; ---------------------------------------------------------------------------

PHYCRLF:				; ...
		call	CRLF
		jmp	short GETCH
; ---------------------------------------------------------------------------

LineDel:				; ...
		or	dh, dh
		jz	short GETCH
		call	BackSpace
		jmp	short LineDel
; ---------------------------------------------------------------------------

WordDel:				; ...
		call	BackSpace	; WordLoop
		or	dh, dh
		jz	short GetChJ
		mov	al, [es:di-1]
		cmp	al, '0'
		jb	short GetChJ
		cmp	al, '9'
		jbe	short WordDel
		or	al, 20h
		cmp	al, 'a'
		jb	short GetChJ
		cmp	al, 'z'
		jbe	short WordDel

GetChJ:					; ...
		jmp	GETCH
; ---------------------------------------------------------------------------

KILNEW:					; ...
		mov	al, '\'
		call	OUTT
		pop	si

PUTNEW:					; ...
		call	CRLF
		mov	al, [ss:STARTPOS]
		call	TAB
		jmp	NEWLIN
; ---------------------------------------------------------------------------

BACKSP:					; ...
		call	BackSpace
		jmp	GETCH

; =============== S U B	R O U T	I N E =======================================

BackSpace:
		or	dh, dh
		jz	short OLDBAK
		call	BACKUP
		mov	al, [es:di]
		cmp	al, 20h	; ' '
		jnb	short OLDBAK
		cmp	al, 9		; c_HT
		jz	short BAKTAB
		cmp	al, 15h		; "U"-"@"
		jz	short OLDBAK
		cmp	al, 14h		; "T"-"@"
		jz	short OLDBAK
		call	BACKMES

OLDBAK:					; ...
		cmp	byte [ss:INSMODE], 0
		jnz	short OLDBAK_RETN
		or	bh, bh
		jz	short OLDBAK_RETN
		dec	bh
		dec	si
		retn
; ---------------------------------------------------------------------------

BAKTAB:					; ...
		push	di
		dec	di
		std
		mov	cl, dh
		mov	al, 20h	; ' '
		push	bx
		mov	bl, 7
		jcxz	FIGTAB

FNDPOS:					; ...
		scasb
		jbe	short CHKCNT
		cmp	byte [es:di+1], 9
		jz	short HAVTAB
		dec	bl

CHKCNT:					; ...
		loop	FNDPOS

FIGTAB:					; ...
		sub	bl, [ss:STARTPOS]

HAVTAB:					; ...
		sub	bl, dh
		add	cl, bl
		and	cl, 7
		cld
		pop	bx
		pop	di
		jz	short OLDBAK

TABBAK:					; ...
		call	BACKMES
		loop	TABBAK
		jmp	short OLDBAK

; ---------------------------------------------------------------------------

BACKUP:					; ...
		dec	dh
		dec	di

BACKMES:				; ...
		mov	al, 8		; c_BS
		call	OUTT
		mov	al, 20h	; ' '
		call	OUTT
		mov	al, 8
		jmp	OUTT
; ---------------------------------------------------------------------------

TWOESC:					; ...
		mov	al, [cs:ESCCHAR]
		jmp	SAVCH
; ---------------------------------------------------------------------------

COPYLIN:				; ...
		mov	cl, bl
		sub	cl, bh
		jmp	short COPYEACH
; ---------------------------------------------------------------------------

COPYSTR:				; ...
		call	FINDOLD
		jmp	short COPYEACH
; ---------------------------------------------------------------------------

COPYONE:				; ...
		mov	cl, 1

COPYEACH:				; ...
		mov	byte [ss:INSMODE], 0
		cmp	dh, dl
		jz	short GETCH2
		cmp	bh, bl
		jz	short GETCH2
		lodsb
		stosb
		call	BUFOUT
		inc	bh
		inc	dh
		loop	COPYEACH

GETCH2:					; ...
		jmp	GETCH
; ---------------------------------------------------------------------------

SKIPONE:				; ...
		cmp	bh, bl
		jz	short GETCH2
		inc	bh
		inc	si
		jmp	GETCH
; ---------------------------------------------------------------------------

SKIPSTR:				; ...
		call	FINDOLD
		add	si, cx
		add	bh, cl
		jmp	GETCH
; ---------------------------------------------------------------------------

FINDOLD:				; ...
		call	_$STD_CON_INPUT_NO_ECHO
		cmp	al, [cs:ESCCHAR]
		jnz	short FINDSETUP
		call	_$STD_CON_INPUT_NO_ECHO
		jmp	short NOTFND
; ---------------------------------------------------------------------------

FINDSETUP:				; ...
		mov	cl, bl
		sub	cl, bh
		jz	short NOTFND
		dec	cx
		jz	short NOTFND
		push	es
		push	ds
		pop	es
		push	di
		mov	di, si
		inc	di
		repne scasb
		pop	di
		pop	es
		jnz	short NOTFND
		not	cl
		add	cl, bl
		sub	cl, bh

; =============== S U B	R O U T	I N E =======================================

FINDOLD_RETN:
		retn

; ---------------------------------------------------------------------------

NOTFND:					; ...
		pop	bp
		jmp	GETCH
; ---------------------------------------------------------------------------

REEDIT:					; ...
		mov	al, '@'
		call	OUTT
		pop	di
		push	di
		push	es
		push	ds
		call	COPYNEW
		pop	ds
		pop	es
		pop	si
		mov	bl, dh
		jmp	PUTNEW
; ---------------------------------------------------------------------------

EXITINS:				; ...
		not	byte [ss:INSMODE] ; ENTERINS
		jmp	GETCH
; ---------------------------------------------------------------------------

CTRLZ:					; ...
		mov	al, 1Ah		; "Z"-"@"
		jmp	SAVCH

; =============== S U B	R O U T	I N E =======================================

CRLF:		; ...
		mov	al, 0Dh		; c_CR
		call	OUTT
		mov	al, 0Ah		; c_LF
		jmp	OUTT

; =============== S U B	R O U T	I N E =======================================

_$RAW_CON_IO:	; ...
		mov	al, dl
		cmp	al, 0FFh
		jz	short rci1
		jmp	short RAWOUT
; ---------------------------------------------------------------------------
		nop			; db 90h ; align 2

rci1:					; ...
		les	di, [ss:USER_SP]
		xor	bx, bx
		call	GET_IO_SFT
		jb	short FINDOLD_RETN
		mov	ah, 1
		call	IOFUNC
		jnz	short RESFLG
		call	SPOOLINT
		or	byte [es:di+16h], 40h ; [ES:DI+user_env.user_F]
		xor	al, al

RET17:					; ...
		retn
; ---------------------------------------------------------------------------

RESFLG:					; ...
		and	byte [es:di+16h], 0BFh

rci0:					; ...
		call	SPOOLINT

_$RAW_CON_INPUT:			; ...
		push	bx
		xor	bx, bx
		call	GET_IO_SFT
		pop	bx
		jb	short RET17
		mov	ah, 1
		call	IOFUNC
		jnz	short rci5
		mov	ah, 84h
		int	2Ah		; Microsoft Networks - KEYBOARD	BUSY LOOP
		jmp	short rci0
; ---------------------------------------------------------------------------

rci5:					; ...
		xor	ah, ah
		call	IOFUNC
		retn

; =============== S U B	R O U T	I N E =======================================

RAWOUT:
		push	bx
		mov	bx, 1
		call	GET_IO_SFT
		jb	short RAWRET1
		mov	bx, [si+5]	; [SI+SF_ENTRY.sf_flags]
		and	bx, 8080h	; sf_isnet+devid_device
		cmp	bx, 80h
		jnz	short RAWNORM
		push	ds
		lds	bx, [si+7]	; [SI+SF_ENTRY.sf_devptr]
		test	byte [bx+4], 10h ; [BX+SYSDEV.ATT],
					; ISSPEC
		pop	ds
		jz	short RAWNORM
		int	29h		; DOS 2+ internal - FAST PUTCHAR
					; AL = character to display

RAWRET:					; ...
		clc

RAWRET1:				; ...
		pop	bx

RAWRET2:				; ...
		retn
; ---------------------------------------------------------------------------

RAWNORM:				; ...
		call	RAWOUT3
		jmp	short RAWRET

; ---------------------------------------------------------------------------

RAWOUT2:				; ...
		call	GET_IO_SFT
		jb	short RAWRET2

; =============== S U B	R O U T	I N E =======================================

RAWOUT3:
		push	ax
		jmp	short RAWOSTRTRAWOSTRT
; ---------------------------------------------------------------------------

ROLP:					; ...
		call	SPOOLINT
		or	word [ss:DOS34_FLAG], 200h ; CTRL_BREAK_FLAG
		call	DSKSTATCHK

RAWOSTRTRAWOSTRT:			; ...
		mov	ah, 3
		call	IOFUNC
		jz	short ROLP
		inc	ax
		pop	ax
		jz	short nosend
		mov	ah, 2
		call	IOFUNC

nosend:					; ...
		clc
		retn

; =============== S U B	R O U T	I N E =======================================

Save_Restore_Packet:
		push	ds
		push	es
		push	si
		push	di
		cmp	ax, 0
		jz	short save_packet
		mov	si, FAKE_STACK_2F
		mov	di, DEVCALL
		jmp	short set_seg
; ---------------------------------------------------------------------------

save_packet:				; ...
		mov	di, FAKE_STACK_2F
		mov	si, DEVCALL

set_seg:				; ...
		mov	ax, ss
		mov	ds, ax
		mov	es, ax
		mov	cx, 11
		rep movsw
		pop	di
		pop	si
		pop	es
		pop	ds
		retn

; =============== S U B	R O U T	I N E =======================================

_$STD_CON_INPUT:
		call	_$STD_CON_INPUT_NO_ECHO
		push	ax
		call	OUTT
		pop	ax

CON_INPUT_RETN:				; ...
		retn

; ---------------------------------------------------------------------------

_$STD_CON_OUTPUT:			; ...
		mov	al, dl

OUTT:					; ...
		cmp	al, 20h	; ' '
		jb	short CTRLOUT
		cmp	al, 7Fh		; c_DEL	; 127
		jz	short OUTCH

OUTCHA:
		inc	byte [ss:CARPOS]

OUTCH:					; ...
		push	ds
		push	si
		inc	byte [ss:CHARCO]
		and	byte [ss:CHARCO], 3Fh ; 00111111b
		jnz	short OUTSKIP
		push	ax
		call	STATCHK
		pop	ax

OUTSKIP:				; ...
		call	RAWOUT
		pop	si
		pop	ds
		test	byte [ss:PFLAG], 0FFh ; -1
		jz	short CON_INPUT_RETN
		push	bx
		push	ds
		push	si
		mov	bx, 1
		call	GET_IO_SFT
		jb	short TRIPOPJ
		mov	bx, [si+5]	; [SI+SF_ENTRY.sf_flags]
		test	bh, 80h		; (sf_isnet>>8)
		jnz	short TRIPOPJ
		test	bl, 80h		; devid_device
		jz	short TRIPOPJ
		mov	bx, 4
		call	GET_IO_SFT
		jb	short TRIPOPJ
		test	byte [si+6], 8 ; [SI+SF_ENTRY.sf_flags+1],
					; (sf_net_spool>>8)
		jz	short LISSTRT2J
		mov	byte [ss:PFLAG], 0

TRIPOPJ:				; ...
		jmp	TRIPOP
; ---------------------------------------------------------------------------

LISSTRT2J:				; ...
		jmp	LISSTRT2
; ---------------------------------------------------------------------------

CTRLOUT:				; ...
		cmp	al, 0Dh		; c_CR
		jz	short ZERPOS
		cmp	al, 8		; c_BS
		jz	short BACKPOS
		cmp	al, 9		; c_HT
		jnz	short OUTCH
		mov	al, [ss:CARPOS]
		or	al, 0F8h
		neg	al

TAB:					; ...
		push	cx
		mov	cl, al
		mov	ch, 0
		jcxz	POPTAB

TABLP:					; ...
		mov	al, 20h	; ' '
		call	OUTT
		loop	TABLP

POPTAB:					; ...
		pop	cx
		retn
; ---------------------------------------------------------------------------

ZERPOS:					; ...
		mov	byte [ss:CARPOS], 0
		jmp	short OUTCH
; ---------------------------------------------------------------------------

OUTJ:					; ...
		jmp	OUTT
; ---------------------------------------------------------------------------

BACKPOS:				; ...
		dec	byte [ss:CARPOS]
		jmp	OUTCH

; =============== S U B	R O U T	I N E =======================================


 BUFOUT:		; ...
		cmp	al, 20h	; ' '
		jnb	short OUTJ
		cmp	al, 9
		jz	short OUTJ
		cmp	al, 15h		; "U"-"@"
		jz	short CTRLU
		cmp	al, 14h		; "T"-"@"
		jz	short CTRLU

NOT_CTRLU:
		push	ax
		mov	al, '^'
		call	OUTT
		pop	ax
		or	al, 40h

CTRLU:					; ...
		call	OUTT

BUFOUT_RETN:				; ...
		retn

; ---------------------------------------------------------------------------

_$STD_AUX_INPUT:			; ...
		call	STATCHK
		mov	bx, 3
		call	GET_IO_SFT
		jb	short BUFOUT_RETN
		jmp	short TAISTRT
; ---------------------------------------------------------------------------

AUXILP:					; ...
		call	SPOOLINT

TAISTRT:				; ...
		mov	ah, 1
		call	IOFUNC
		jz	short AUXILP
		xor	ah, ah
		call	IOFUNC
		retn
; ---------------------------------------------------------------------------

_$STD_AUX_OUTPUT:			; ...
		push	bx
		mov	bx, 3
		jmp	short SENDOUT
; ---------------------------------------------------------------------------

_$STD_PRINTER_OUTPUT:			; ...
		push	bx
		mov	bx, 4

SENDOUT:				; ...
		mov	al, dl
		push	ax
		call	STATCHK
		pop	ax
		push	ds
		push	si

LISSTRT2:				; ...
		call	RAWOUT2

TRIPOP:					; ...
		pop	si
		pop	ds
		pop	bx

SCIS_RETN:				; ...
		retn
; ---------------------------------------------------------------------------

_$STD_CON_INPUT_STATUS:			; ...
		call	STATCHK
		mov	al, 0
		jz	short SCIS_RETN
		or	al, 0FFh	; -1
		retn
; ---------------------------------------------------------------------------

_$STD_CON_INPUT_FLUSH:			; ...
		push	ax
		push	dx
		xor	bx, bx
		call	GET_IO_SFT
		jb	short BADJFNCON
		mov	ah, 4
		call	IOFUNC

BADJFNCON:				; ...
		pop	dx
		pop	ax
		mov	ah, al
		cmp	al, 1
		jz	short REDISPJ
		cmp	al, 6
		jz	short REDISPJ
		cmp	al, 7
		jz	short REDISPJ
		cmp	al, 8
		jz	short REDISPJ
		cmp	al, 10
		jz	short REDISPJ
		mov	al, 0
		retn
; ---------------------------------------------------------------------------

REDISPJ:				; ...
		cli
		jmp	REDISP
; ---------------------------------------------------------------------------

_$GET_FCB_POSITION:			; ...
		call	GetExtended
		call	GetExtent
		mov	[si+21h], ax	; [SI+SYS_FCB.RR]
		mov	[si+23h], dl	; [SI+SYS_FCB.RR+2]
		cmp	word [si+0Eh], 64 ;	[SI+SYS_FCB.RECSIZ]
		jnb	short GetFCBBye
		mov	[si+24h], dh	; [SI+SYS_FCB.RR+2+1]

GetFCBBye:				; ...
		jmp	NO_OP
; ---------------------------------------------------------------------------

_$FCB_DELETE:				; ...
		mov	di, OPENBUF
		call	TransFCB
		jb	short BadPath
		push	ss
		pop	ds
		call	DOS_DELETE
		jb	short BadPath

GoodPath:				; ...
		jmp	short GetFCBBye
; ---------------------------------------------------------------------------

BadPath:				; ...
		jmp	FCB_RET_ER
; ---------------------------------------------------------------------------

_$GET_FCB_FILE_LENGTH:			; ...
		call	GetExtended
		mov	di, OPENBUF
		push	ds
		push	si
		call	TransFCB
		pop	si
		pop	ds
		jb	short BadPath
		push	ds
		push	si
		push	ss
		pop	ds
		call	GET_FILE_INFO
		pop	si
		pop	ds
		jb	short BadPath
		mov	dx, bx
		mov	ax, di
		mov	bx, [si+0Eh]	; [SI+SYS_FCB.RECSIZ]
		or	bx, bx
		jnz	short GetSize
		mov	bx, 128

GetSize:				; ...
		mov	di, ax
		mov	ax, dx
		xor	dx, dx
		div	bx
		push	ax
		mov	ax, di
		div	bx
		mov	cx, dx
		pop	dx
		jcxz	LengthStore
		add	ax, 1
		adc	dx, 0

LengthStore:				; ...
		mov	[si+21h], ax	; [SI+SYS_FCB.RR]
		mov	[si+23h], dl	; [SI+SYS_FCB.RR+2]
		or	dh, dh
		jz	short GoodPath
		mov	[si+24h], dh	; [SI+SYS_FCB.RR+3]

GoodRet:				; ...
		jmp	short GoodPath
; ---------------------------------------------------------------------------

_$FCB_CLOSE:				; ...
		xor	al, al
		call	GetExtended
		jz	short NoAttr
		mov	al, [si-1]

NoAttr:					; ...
		mov	[ss:ATTRIB], al
		call	SFTFromFCB
		jb	short GoodRet
		mov	al, [es:di+4]	; [ES:DI+SF_ENTRY.sf_attr]
		xor	ah, ah
		push	ax
		call	CheckShare
		jnz	short NoStash
		mov	al, [ss:ATTRIB]
		mov	[es:di+4], al	; [ES:DI+SF_ENTRY.sf_attr]

NoStash:				; ...
		mov	ax, [si+14h]	; [SI+SYS_FCB.FDATE]
		mov	[es:di+0Fh], ax	; [ES:DI+SF_ENTRY.sf_date]
		mov	ax, [si+16h]	; [SI+SYS_FCB.FTIME]
		mov	[es:di+0Dh], ax	; [ES:DI+SF_ENTRY.sf_time]
		mov	ax, [si+10h]	; [SI+SYS_FCB.FILSIZ]
		mov	[es:di+11h], ax	; [ES:DI+SF_ENTRY.sf_size]
		mov	ax, [si+12h]	; [SI+SYS_FCB.FILSIZ+2]
		mov	[es:di+13h], ax	; [ES:DI+SF_ENTRY.sf_size+2]
		or	word [es:di+5], 4000h ; [ES:DI+SF_ENTRY.sf_flags],
					; sf_close_nodate
		push	ss
		pop	ds
		call	DOS_CLOSE
		les	di, [THISSFT]
		pop	cx
		mov	[es:di+4], cl	; [ES:DI+SF_ENTRY.sf_attr]
		pushf
		cmp	word [es:di], 0 ; [ES:DI+SF_ENTRY.sf_ref_count]
		jnz	short CloseOK
		push	ax
		mov	al, 'M'         ; 4Dh
		call	BlastSFT
		pop	ax

CloseOK:				; ...
		popf
		jnb	short GoodRet
		cmp	al, 6		; error_invalid_handle
		jz	short GoodRet
		mov	al, 2		; error_file_not_found

fcb_close_err:				; ...
		jmp	FCB_RET_ER
; ---------------------------------------------------------------------------

_$FCB_RENAME:				; ...
		call	GetExtended
		push	dx
		mov	al, [si]
		add	si, 10h
		mov	di, RENBUF
		push	word [si]
		push	ds
		push	si
		mov	[si], al
		mov	dx, si
		call	TransFCB
		pop	si
		pop	ds
		pop	word [si]
		pop	dx
		jb	short fren90
		mov	si, [ss:WFP_START]
		mov	[ss:REN_WFP], si
		mov	di, OPENBUF
		call	TransFCB
		jb	short fren90
		call	DOS_RENAME
		jb	short fren90
		jmp	NO_OP		; FCB_RET_OK
; ---------------------------------------------------------------------------

fren90:					; ...
		jmp	short fcb_close_err

; =============== S U B	R O U T	I N E =======================================

SaveFCBInfo:
		les	di, [ss:THISSFT]
		call	IsSFTNet
		jz	short SaveLocal
		mov	ax, [es:di+0Bh]	; [ES:DI+sf_serial_ID]
		mov	[si+1Ch], ax	; [SI+fcb_netID]
		mov	bl, 80h		; FCBNETWORK
		jmp	short SaveSFN
; ---------------------------------------------------------------------------

SaveLocal:				; ...
		call	CheckShare
		jz	short SaveNoShare
		jmp	short SaveShare
; ---------------------------------------------------------------------------

SaveNoShare:				; ...
		test	byte [es:di+5], 80h	; [ES:DI+SF_ENTRY.sf_flags],
					; devid_device
		jnz	short SaveNoShareDev
		mov	ax, [es:di+1Bh]	; [ES:DI+SF_ENTRY.sf_dirsec]
		mov	[si+1Dh], ax	; [SI+fcb_nsl_dirsec]
		mov	ax, [es:di+1Dh]	; [es:di+SF_ENTRY.sf_dirsec+2]
		mov	bl, [es:di+4]	; [es:di+SF_ENTRY.sf_attr]
		mov	bh, bl
		ror	bl, 1
		shl	bh, 1
		or	bl, bh
		and	bl, 0C0h
		or	al, bl
		mov	[si+18h], al	; [si+fcb_sfn]
		mov	al, [es:di+1Fh]	; [ES:DI+SF_ENTRY.sf_dirpos]
		mov	[si+1Fh], al	; [SI+fcb_nsl_dirpos]
		mov	ax, [es:di+0Bh]	; [ES:DI+SF_ENTRY.sf_firclus]
		mov	[si+1Bh], ax	; [SI+fcb_nsl_firclus]
		mov	bl, 0

SetFCBBits:				; ...
		mov	ax, [es:di+5]	; [ES:DI+SF_ENTRY.sf_flags]
		and	al, 0C0h
		or	al, [es:di+2]	; [ES:DI+SF_ENTRY.sf_mode]
		mov	[si+1Ah], al	; [SI+fcb_nsl_bits]
		or	bl, bl
		jz	short SaveNoSFN
		jmp	short SaveSFN
; ---------------------------------------------------------------------------

SaveNoShareDev:				; ...
		mov	ax, [es:di+7]	; [ES:DI+SF_ENTRY.sf_devptr]
		mov	[si+1Ah], ax	; [SI+fcb_nsld_drvptr]
		mov	ax, [es:di+9]	; [ES:DI+SF_ENTRY.sf_devptr+2]
		mov	[si+1Ch], ax	; [SI+fcb_nsld_drvptr+2]
		mov	bl, 40h		; FCBDEVICE
		jmp	short SetFCBBits
; ---------------------------------------------------------------------------

SaveShare:				; ...
		;call	dword [ss:ShSave] ; Call far [ss:JShare+(10*4)]
		call	far [ss:JShare+(10*4)]
SaveSFN:				; ...
		lea	ax, [di-6]	; [DI-SFT.SFTable]
		sub	ax, word [ss:SFTFCB]
		push	bx
		mov	bl, 59		; SF_ENTRY.size
		div	bl
		mov	[si+18h], al	; [SI+fcb_sfn]
		pop	bx

SaveNoSFN:				; ...
		mov	ax, [es:di+5]	; [ES:DI+SF_ENTRY.sf_flags]
		and	al, 3Fh
		or	al, bl
		mov	[si+19h], al	; [SI+fcb_l_drive]
		mov	ax, [ss:FCBLRU]
		inc	ax
		mov	[es:di+15h], ax	; [ES:DI+sf_LRU]
		jnz	short SimpleStuff
		mov	bx, 15h		; SF_ENTRY.sf_position
		call	ResetLRU

SimpleStuff:				; ...
		mov	[ss:FCBLRU], ax
		retn

; =============== S U B	R O U T	I N E =======================================

ResetLRU:		; ...
		mov	ax, 8000h
		push	es
		push	di
		les	di, [ss:SFTFCB]
		mov	cx, [es:di+4]	; [ES:DI+SFT.SFCount]
		lea	di, [di+6]	; [DI+SFT.SFTable]

ovScan:					; ...
		sub	[es:bx+di], ax
		ja	short ovLoop
		mov	[es:bx+di], ax

ovLoop:					; ...
		add	di, 59		; SF_ENTRY.size
		loop	ovScan
		pop	di
		pop	es
		mov	[es:bx+di], ax
		retn

; =============== S U B	R O U T	I N E =======================================

LRUFCB:		; ...
		push	es
		call	save_world
		mov	ds, [cs:DosDSeg]
		or	al, al
		jnz	short lru1
		mov	di, word [LocalSFT]
		or	di, word [LocalSFT+2]
		jz	short lru1
		les	di, [LocalSFT]

gotlocalSFT:				; ...
		mov	word [THISSFT], di
		mov	word [THISSFT+2], es
		clc
		jmp	LRUDone
; ---------------------------------------------------------------------------

lru1:					; ...
		les	di, [SFTFCB]
		mov	cx, [es:di+4]	; [es:di+SFT.SFCount]
		lea	di, [di+6]	; [di+SFT.SFTable]
		mov	bx, 0FFFFh	; -1
		mov	si, bx
		mov	dx, bx
		mov	bp, bx

findSFT:				; ...
		or	word [es:di], 0 ; [es:di+SF_ENTRY.sf_ref_count]
		jz	short gotSFT
		cmp	word [es:di], 0FFFFh ; [es:di+SF_ENTRY.sf_ref_count],
					; sf_busy
		jz	short gotSFT
		test	word [es:di+5], 8000h ; [ES:DI+SF_ENTRY.sf_flags],
					; sf_isnet
		jnz	short lru5
		call	CheckShare
		jnz	short lru5

hackpoint:				; ...
		mov	word [LocalSFT],	di
		mov	word [LocalSFT+2], es
		or	al, al
		jz	short gotlocalSFT
		cmp	[es:di+15h], bx	; [es:di+sf_LRU]
		jnb	short lru4
		mov	bx, [es:di+15h]	; [es:di+sf_LRU]
		mov	si, di

lru4:					; ...
		add	di, 59		; SF_ENTRY.size
		loop	findSFT
		mov	di, si
		cmp	si, -1
		jnz	short gotSFT
		mov	di, bp
		cmp	bp, -1
		jnz	short gotnetSFT

noSFT:
		jmp	short errorbadSFT
; ---------------------------------------------------------------------------

lru5:					; ...
		cmp	[es:di+15h], dx	; [es:di+sf_LRU]
		jnb	short lru4
		mov	dx, [es:di+15h]	; [es:di+sf_LRU]
		mov	bp, di
		jmp	short lru4
; ---------------------------------------------------------------------------

gotSFT:					; ...
		or	al, al
		jz	short hackpoint
		mov	ax, es
		cmp	word [LocalSFT],	di
		jnz	short notinvalid
		cmp	word [LocalSFT+2], ax
		jz	short zerolocalSFT

notinvalid:				; ...
		jmp	gotlocalSFT
; ---------------------------------------------------------------------------

zerolocalSFT:				; ...
		xor	ax, ax
		mov	word [LocalSFT],	ax
		mov	word [LocalSFT+2], ax
		jmp	gotlocalSFT
; ---------------------------------------------------------------------------

gotnetSFT:				; ...
		or	al, al
		jnz	short closenet
		mov	word [LocalSFT],	di
		mov	word [LocalSFT+2], es

closenet:				; ...
		mov	word [THISSFT], di
		mov	word [THISSFT+2], es

LRUClose:				; ...
		cmp	word [es:di], 0 ; [es:di+SF_ENTRY.sf_ref_count]
		jz	short LRUDone
		call	DOS_CLOSE
		jnb	short LRUClose
		cmp	al, 6
		jz	short LRUClose

errorbadSFT:				; ...
		stc
		jmp	short LRUDead
; ---------------------------------------------------------------------------

LRUDone:				; ...
		xor	al, al
		call	BlastSFT

LRUDead:				; ...
		call	restore_world
		pop	es
		mov	es, [cs:DosDSeg]
		les	di, [es:THISSFT]
		jb	short LruFCB_err
		retn
; ---------------------------------------------------------------------------

LruFCB_err:				; ...
		mov	al, 23h		; error_FCB_unavailable
		retn

; =============== S U B	R O U T	I N E =======================================

RegenCopyName:	; ...
		lodsb
		call	UCase

StuffChar2:
		stosb
		loop	RegenCopyName	; CopyName
		retn

; =============== S U B	R O U T	I N E =======================================

FCBRegen:		; ...
		mov	al, [si+19h]	; [SI+fcb_l_drive]
		test	al, 80h
		jz	short RegenNoSharing
		call	CheckShare
		jnz	short RegenFail
		mov	ax, 1100h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - INSTALLATION	CHECK
					; Return: AL = 00h  not	installed, OK to install
					; 01h  not installed, not OK to	install
					; FFh  installed
		or	al, al
		jz	short RegenDead

RegenFail:				; ...
		mov	ax, [ss:USER_IN_AX]
		cmp	ah, 10h
		jz	short RegenDead
		call	FCBHardErr

RegenDead:				; ...
		stc

FCBRegen_retn:				; ...
		retn
; ---------------------------------------------------------------------------

RegenNoSharing:				; ...
		call	CheckShare
		jnz	short RegenFail
		push	ax
		mov	al, 0
		call	LRUFCB
		pop	ax
		jb	short FCBRegen_retn
		mov	word [es:di+2], 8002h ; [ES:DI+SF_ENTRY.sf_mode],
					; sf_isFCB+open_for_both+SHARING_COMP
		and	al, 3Fh
		cbw
		or	ax, 4000h	; sf_close_nodate
		mov	cl, [si+1Ah]	; [SI+fcb_nsl_bits]
		mov	ch, cl
		and	ch, 0C0h
		or	al, ch
		and	cl, 0Fh		; access_mask
		mov	[es:di+2], cl	; ES:DI+SF_ENTRY.sf_mode]
		mov	[es:di+5], ax	; [ES:DI+SF_ENTRY.sf_flags]
		mov	ax, [ss:PROC_ID]
		mov	[es:di+31h], ax	; [ES:DI+SF_ENTRY.sf_PID]
		push	ds
		push	si
		push	es
		push	di
		push	ss
		pop	es
		mov	di, NAME1
		mov	cx, 8
		inc	si
		call	RegenCopyName
		push	ss
		pop	ds
		mov	byte [ATTRIB], 16h ; attr_hidden+attr_system+attr_directory
		call	DEVNAME
		pop	di
		pop	es
		pop	si
		pop	ds
		jb	short RegenFileNoSharing
		mov	[es:di+5], bh	; [ES:DI+SF_ENTRY.sf_flags]
		mov	byte [es:di+4], 0 ;	[ES:DI+SF_ENTRY.sf_attr]
		lds	si, [ss:DEVPT]
		mov	[es:di+7], si	; [ES:DI+SF_ENTRY.sf_devptr]
		mov	word [es:di+9], ds ; [ES:DI+SF_ENTRY.sf_devptr+2]
		retn
; ---------------------------------------------------------------------------

RegenDeadJ:				; ...
		jmp	short RegenDead
; ---------------------------------------------------------------------------

RegenFileNoSharing:			; ...
		mov	ax, [es:di+5]	; [ES:DI+SF_ENTRY.sf_flags]
		and	ax, 3Fh
		push	ds
		push	si
		call	FIND_DPB
		mov	[es:di+7], si	; [ES:DI+SF_ENTRY.sf_devptr]
		mov	word [es:di+9], ds ; [ES:DI+SF_ENTRY.sf_devptr+2]
		pop	si
		pop	ds
		jb	short RegenDeadJ
		mov	ax, [si+1Dh]	; [SI+fcb_nsl_dirsec]
		mov	[es:di+1Bh], ax	; [ES:DI+SF_ENTRY.sf_dirsec]
		mov	al, [si+18h]	; [si+fcb_sfn]
		and	al, 0C0h
		mov	ah, al
		rol	ah, 1
		shr	al, 1
		or	al, ah
		and	al, 3Fh
		mov	[es:di+4], al	; [es:di+SF_ENTRY.sf_attr]
		mov	al, [si+18h]	; [si+fcb_sfn]
		and	al, 3Fh
		sub	ah, ah
		mov	[es:di+1Dh], ax	; [es:di+SF_ENTRY.sf_dirsec+2]
		mov	ax, [si+1Bh]	; [SI+fcb_nsl_firclus]
		mov	[es:di+0Bh], ax	; [ES:DI+SF_ENTRY.sf_firclus]
		mov	[es:di+35h], ax	; [ES:DI+SF_ENTRY.sf_lstclus]
		mov	al, [si+1Fh]	; SI+fcb_nsl_dirpos]
		mov	[es:di+1Fh], al	; [ES:DI+SF_ENTRY.sf_dirpos]
		inc	word [es:di] ; [ES:DI+SF_ENTRY.sf_ref_count]
		lea	si, [si+1]	; [SI+SYS_FCB.name]
		lea	di, [di+20h]	; [DI+SF_ENTRY.sf_name]
		mov	cx, 11		; SYS_FCB.EXTENT-SYS_FCB.name ;	12-1
		call	RegenCopyName
		clc
		retn

; =============== S U B	R O U T	I N E =======================================

BlastSFT:		; ...
		push	di
		mov	cx, 59		; SF_ENTRY.size
		rep stosb
		pop	di
		sub	ax, ax
		mov	[es:di], ax	; [es:di+SFT_ENTRY.sf_ref_count]
		mov	[es:di+15h], ax	; [es:di+sf_LRU]
		dec	ax
		mov	[es:di+17h], ax	; [es:di+sf_OpenAge]
		retn

; =============== S U B	R O U T	I N E =======================================

CheckFCB:		; ...
		test	byte [si+19h], 0C0h	; [si+fcb_l_drive],
					; FCBNETWORK|FCBSHARE|FCBDEVICE
		jz	short BadSFT
		les	di, [ss:SFTFCB]
		cmp	[es:di+4], al	; [ES:DI+SFT.SFCount]
		jb	short BadSFT
		mov	bl, 59		; SF_ENTRY.size
		mul	bl
		lea	di, [di+6]	; [DI+SFT.SFTable]
		add	di, ax
		mov	ax, [ss:PROC_ID]
		cmp	[es:di+31h], ax	; [ES:DI+SF_ENTRY.sf_PID]
		jnz	short BadSFT
		cmp	word [es:di], 0 ; [ES:DI+SF_ENTRY.sf_ref_count]
		jz	short BadSFT
		mov	al, [si+19h]	; [SI+fcb_l_drive]
		test	al, 80h		; FCBSPECIAL
		jz	short CheckNoShare
		push	ax
		and	al, 0C0h	; FCBMASK
		cmp	al, 0C0h	; FCBSHARE
		pop	ax
		jnz	short CheckNet
		;call	dword [ss:ShChk] ; Call far [ss:JShare+(11*4)]
		call	far [ss:JShare+(11*4)]
		jb	short BadSFT
		jmp	short CheckD
; ---------------------------------------------------------------------------

CheckFirClus:				; [ES:DI+SF_ENTRY.sf_firclus]
		cmp	bx, [es:di+0Bh]
		jnz	short BadSFT

CheckD:					; ...
		and	al, 3Fh
		mov	ah, [es:di+5]
		and	ah, 3Fh
		cmp	ah, al
		jnz	short BadSFT

CheckD_retn:				; ...
		retn
; ---------------------------------------------------------------------------

BadSFT:					; ...
		stc
		retn
; ---------------------------------------------------------------------------

CheckNet:				; ...
		mov	ax, [si+1Ch]	; [SI+fcb_netID]
		cmp	ax, [es:di+0Bh]	; [ES:DI+sf_serial_ID]
		jnz	short BadSFT
		retn
; ---------------------------------------------------------------------------

CheckNoShare:				; ...
		test	al, 40h		; FCBDEVICE
		jnz	short $+2	; CheckNoShareDev

CheckNoShareDev:			; ...
		mov	bx, [si+1Ah]	; [SI+fcb_nsld_drvptr]
		cmp	bx, [es:di+7]	; [ES:DI+SF_ENTRY.sf_devptr]
		jnz	short BadSFT
		mov	bx, [si+1Ch]	; [SI+fcb_nsld_drvptr+2]
		cmp	bx, [es:di+9]	; [ES:DI+SF_ENTRY.sf_devptr+2]
		jnz	short BadSFT
		jmp	short CheckD

; =============== S U B	R O U T	I N E =======================================

SFTFromFCB:		; ...
		push	ax
		push	bx
		mov	al, [si+18h]	; [SI+fcb_sfn]
		call	CheckFCB
		pop	bx
		pop	ax
		mov	word [ss:THISSFT], di
		mov	word [ss:THISSFT+2], es
		jnb	short Set_SFT
		push	es
		call	save_world
		call	FCBRegen
		call	restore_world
		pop	es
		mov	ax, [ss:EXTERR]
		jb	short CheckD_retn

Set_SFT:				; ...
		les	di, [ss:THISSFT]
		push	word [ss:PROC_ID]
		pop	word [es:di+31h] ; [ES:DI+SF_ENTRY.sf_PID]
		retn

; =============== S U B	R O U T	I N E =======================================

FCBHardErr:		; ...
		mov	es, [cs:DosDSeg]
		mov	ax, 23h		; error_FCB_unavailable
		mov	byte [es:ALLOWED], 8 ; Allowed_FAIL
		les	bp, [es:THISDPB]
		mov	di, 1
		mov	cx, di
		mov	dx, [es:bp+0Bh]	; [ES:BP+DPB.FIRST_SECTOR]
		call	HARDERR
		stc
		retn

; =============== S U B	R O U T	I N E =======================================

GetRR:		; ...
		mov	ax, [si+21h]	; [SI+SYS_FCB.RR]
		mov	dx, [si+23h]	; [SI+SYS_FCB.RR+2]
		cmp	bx, 64
		jb	short GetRRBye
		xor	dh, dh

GetRRBye:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================

GetExtent:		; ...
		mov	al, [si+20h]	; [SI+SYS_FCB.NR]
		mov	dx, [si+0Ch]	; [SI+SYS_FCB.EXTENT]
		shl	al, 1
		shr	dx, 1
		rcr	al, 1
		mov	ah, dl
		mov	dl, dh
		xor	dh, dh
		retn

; =============== S U B	R O U T	I N E =======================================

SetExtent:		; ...
		push	ax
		push	dx
		mov	cx, ax
		and	al, 7Fh
		mov	[si+20h], al	; [SI+SYS_FCB.NR]
		and	cl, 80h
		shl	cx, 1
		rcl	dx, 1
		mov	al, ch
		mov	ah, dl
		mov	[si+0Ch], ax	; [SI+SYS_FCB.EXTENT]
		pop	dx
		pop	ax
		retn

; =============== S U B	R O U T	I N E =======================================

GetExtended:	; ...
		mov	si, dx
		cmp	byte [si], 0FFh ; -1
		jnz	short GetBye
		add	si, 7

GetBye:					; ...
		cmp	si, dx

getextd_retn:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================

GetRecSize:		; ...
		mov	bx, [si+0Eh]	; [SI+SYS_FCB.RECSIZ]
		or	bx, bx
		jnz	short getextd_retn
		mov	bx, 128
		mov	[si+0Eh], bx	; [SI+SYS_FCB.RECSIZ]
		retn

; ---------------------------------------------------------------------------

FCBIO:					; ...
		push	bp
		mov	bp, sp
		sub	sp, 14h
		mov	[bp-14h], al	; FCBOp
		mov	byte [bp-1], 0 ; FCBErr
		call	GetExtended
		test	byte [bp-14h], 8 ; FCBOp,BLOCK
		jnz	short GetPos
		mov	cx, 1

GetPos:					; ...
		mov	[bp-3],	cx	; cRec
		call	GetExtent
		call	GetRecSize
		mov	[bp-9],	bx	; RecSize
		test	byte [bp-14h], 2 ; FCBOp,RANDOM
		jz	short GetRec
		call	GetRR

GetRec:					; ...
		mov	[bp-7],	ax	; RecPosL
		mov	[bp-5],	dx	; RecPosH
		call	SetExtent
		mov	ax, [bp-5]	; RecPosH
		mul	bx
		mov	di, ax
		mov	ax, [bp-7]	; RecPosL
		mul	bx
		add	dx, di
		mov	[bp-0Dh], ax	; bPosL
		mov	[bp-0Bh], dx	; bPosH
		mov	ax, [bp-3]	; cRec
		mul	bx
		mov	[bp-0Fh], ax	; cByte
		add	ax, word [ss:DMAADD]
		adc	dx, 0
		jz	short DoOper
		mov	byte [bp-1], 2 ; FCBErr,FTRIM
		mov	ax, word [ss:DMAADD]
		neg	ax
		jnz	short DoDiv
		dec	ax

DoDiv:					; ...
		xor	dx, dx
		div	bx
		mov	[bp-3],	ax	; cRec
		mul	bx
		mov	[bp-0Fh], ax	; cByte

DoOper:					; ...
		xor	bx, bx
		mov	[bp-11h], bx	; cResult
		cmp	[bp-0Fh], bx	; cByte
		jnz	short DoGetExt
		test	byte [bp-1], 2 ; FCBErr,FTRIM
		jz	short DoGetExt
		jmp	short SkipOp
; ---------------------------------------------------------------------------

DoGetExt:				; ...
		call	SFTFromFCB
		jnb	short ContinueOp

FCBDeath:				; ...
		call	FCB_RET_ER
		mov	word [bp-13h], 0 ; cRecRes
		mov	byte [bp-1], 1 ; FCBErr,FEOF
		jmp	FCBSave
; ---------------------------------------------------------------------------

ContinueOp:				; ...
		mov	ax, [si+10h]	; [SI+SYS_FCB.FILSIZ]
		mov	[es:di+11h], ax	; [ES:DI+SF_ENTRY.sf_size]
		mov	ax, [si+12h]	; [SI+SYS_FCB.FILSIZ+2]
		mov	[es:di+13h], ax	; [ES:DI+SF_ENTRY.sf_size+2]
		mov	ax, [bp-0Dh]	; bPosL
		mov	dx, [bp-0Bh]	; bPosH
		mov	[es:di+15h], ax	; [ES:DI+SF_ENTRY.sf_position]
		xchg	dx, [es:di+17h]	; [ES:DI+SF_ENTRY.sf_position+2]
		push	dx
		mov	cx, [bp-0Fh]	; cByte
		mov	di, DOS_READ
		test	byte [bp-14h], 4 ; FCBOp,FCBREAD
		jnz	short DoContext
		mov	di, DOS_WRITE

DoContext:				; ...
		push	bp
		push	ds
		push	si
		push	ss
		pop	ds
		call	di ; DOS_READ	; or DOS_WRITE
		pop	si
		pop	ds
		pop	bp
		jb	short FCBDeath
		cmp	byte [ss:DISK_FULL], 0
		jz	short NODSKFULL
		mov	byte [ss:DISK_FULL], 0
		mov	byte [bp-1], 1 ; FCBErr,FEOF

NODSKFULL:				; ...
		mov	[bp-11h], cx	; cResult
		call	SaveFCBInfo
		pop	word [es:di+17h] ; [ES:DI+SF_ENTRY.sf_position+2]
		mov	ax, [es:di+11h]	; [ES:DI+SF_ENTRY.sf_size]
		mov	[si+10h], ax	; [SI+SYS_FCB.FILSIZ]
		mov	ax, [es:di+13h]	; [ES:DI+SF_ENTRY.sf_size+2]
		mov	[si+12h], ax	; [SI+SYS_FCB.FILSIZ+2]

SkipOp:					; ...
		mov	ax, [bp-11h]	; cResult
		xor	dx, dx
		div	word [bp-9]	; RecSize
		mov	[bp-13h], ax	; cRecRes
		add	[bp-7],	ax	; RecPosL
		adc	word [bp-5], 0 ; RecPosH
		cmp	ax, [bp-3]	; cRec
		jz	short TryBlank
		test	byte [bp-14h], 4 ; FCBOp,FCBREAD
		jnz	short SetEOF
		test	byte [es:di+5], 80h
		jnz	short TryBlank

SetEOF:					; ...
		mov	byte [bp-1], 1 ; FCBErr,FEOF

TryBlank:				; ...
		or	dx, dx
		jz	short SetExt
		add	word [bp-7], 1 ; RecPosL
		adc	word [bp-5], 0 ; RecPosH
		test	byte [bp-14h], 4 ; FCBOp,FCBREAD
		jz	short SetExt
		inc	word [bp-13h] ; cRecRes
		mov	byte [bp-1], 3 ; FCBErr,FTRIM+FEOF
		mov	cx, [bp-9]	; RecSize
		sub	cx, dx
		xor	al, al
		les	di, [ss:DMAADD]
		add	di, [bp-11h]	; cResult
		rep stosb

SetExt:					; ...
		mov	dx, [bp-5]	; RecPosH
		mov	ax, [bp-7]	; RecPosL
		test	byte [bp-14h], 2 ; FCBOp,RANDOM
		jz	short DoSetExt
		test	byte [bp-14h], 8 ; FCBOp,BLOCK
		jz	short TrySetRR

DoSetExt:				; ...
		call	SetExtent

TrySetRR:				; ...
		test	byte [bp-14h], 8 ; FCBOp,BLOCK
		jz	short TryReturn
		mov	[si+21h], ax	; [SI+SYS_FCB.RR]
		mov	[si+23h], dl	; [SI+SYS_FCB.RR+2]
		cmp	word [si+0Eh], 64 ;	[SI+SYS_FCB.RECSIZ]
		jnb	short TryReturn
		mov	[si+24h], dh	; [SI+SYS_FCB.RR+2+1]

TryReturn:				; ...
		test	byte [bp-14h], 4 ; FCBOp,FCBREAD
		jnz	short FCBSave
		push	ds
		call	DATE16
		pop	ds
		mov	[si+14h], ax	; [SI+SYS_FCB.FDATE]
		mov	[si+16h], dx	; [SI+SYS_FCB.FTIME]

FCBSave:				; ...
		test	byte [bp-14h], 8 ; FCBOp,BLOCK
		jz	short DoReturn
		mov	cx, [bp-13h]	; cRecRes
		call	Get_User_Stack
		mov	[si+4],	cx	; [SI+user_env.user_CX]

DoReturn:				; ...
		mov	al, [bp-1]	; FCBErr
		mov	sp, bp
		pop	bp
		retn

; =============== S U B	R O U T	I N E =======================================

_$FCB_OPEN:		; ...
		mov	ax, 2		; SHARING_COMPAT+open_for_both
		mov	cx, DOS_OPEN

DoAccess:				; ...
		push	ds
		push	dx
		push	cx
		push	ax
		mov	di, OPENBUF
		call	TransFCB
		pop	ax
		pop	cx
		pop	dx
		pop	ds
		jnb	short FindFCB

FCBOpenErr:				; ...
		jmp	FCB_RET_ER
; ---------------------------------------------------------------------------

FindFCB:				; ...
		call	GetExtended
		push	ax
		mov	al, 1
		call	LRUFCB
		pop	ax
		jb	short HardMessage
		mov	word [es:di+2], 8000h ; [es:di+SF_ENTRY.sf_mode],
					; sf_isFCB
		push	ds
		push	si
		push	bx
		mov	si, cx
		push	ss
		pop	ds
		call	si
		pop	bx
		pop	si
		pop	ds
		les	di, [ss:THISSFT]
		jnb	short FCBOK
		push	ax
		mov	al, 'R'         ; 52h
		call	BlastSFT
		pop	ax
		cmp	ax, 4		; error_too_many_open_files
		jz	short HardMessage
		cmp	ax, 24h		; error_sharing_buffer_exceeded
		jnz	short DeadFCB

HardMessage:				; ...
		push	ax
		call	FCBHardErr
		pop	ax

DeadFCB:				; ...
		jmp	short FCBOpenErr
; ---------------------------------------------------------------------------

FCBOK:					; ...
		call	IsSFTNet
		jnz	short FCBOK2
		call	CheckShare
		jnz	short FCBOK2
		mov	word [ss:LocalSFT],	di
		mov	word [ss:LocalSFT+2], es

FCBOK2:					; ...
		inc	word [es:di] ; [ES:DI+SF_ENTRY.sf_ref_count]
		call	SaveFCBInfo
		test	byte [es:di+5], 80h	; [ES:DI+SF_ENTRY.sf_flags],
					; devid_device
		jnz	short FCBNoDrive
		mov	al, [si]
		call	GETTHISDRV
		inc	al
		mov	[si], al

FCBNoDrive:				; ...
		mov	word [si+0Eh], 128 ; [SI+SYS_FCB.RECSIZ]
		mov	ax, [es:di+0Dh]	; [ES:DI+SF_ENTRY.sf_time]
		mov	[si+16h], ax	; [SI+SYS_FCB.FTIME]
		mov	ax, [es:di+0Fh]	; [ES:DI+SF_ENTRY.sf_date]
		mov	[si+14h], ax	; [SI+SYS_FCB.FDATE]
		mov	ax, [es:di+11h]	; [ES:DI+SF_ENTRY.sf_size]
		mov	[si+10h], ax	; [SI+SYS_FCB.FILSIZ]
		mov	ax, [es:di+13h]	; [ES:DI+SF_ENTRY.sf_size+2]
		mov	[si+12h], ax	; [SI+SYS_FCB.FILSIZ+2]
		xor	ax, ax
		mov	[si+0Ch], ax	; [SI+SYS_FCB.EXTENT]
		les	di, [ss:SFTFCB]
		mov	ah, [es:di+4]	; [ES:DI+SFT.SFCount]

OpenScan:				; ...
		cmp	al, [si+18h]	; [SI+fcb_sfn]
		jz	short SkipCheck
		push	ax
		call	CheckFCB
		pop	ax
		jnb	short OpenFound

SkipCheck:				; ...
		inc	al
		cmp	al, ah
		jnz	short OpenScan

OpenDone:				; ...
		xor	al, al
		retn
; ---------------------------------------------------------------------------

OpenFound:				; ...
		mov	[si+18h], al	; [SI+fcb_sfn]
		inc	word [es:di] ; [ES:DI+SF_ENTRY.sf_ref_count]
		mov	ax, [ss:FCBLRU]
		mov	[es:di+15h], ax	; [ES:DI+sf_LRU]
		push	ss
		pop	ds
		les	di, [THISSFT]
		dec	word [es:di] ; [ES:DI+SF_ENTRY.sf_ref_count]
		call	ShareEnd
		mov	al, 'C'         ; 43h
		call	BlastSFT
		jmp	short OpenDone

; ---------------------------------------------------------------------------

_$FCB_CREATE:				; ...
		mov	cx, DOS_CREATE
		xor	ax, ax
		call	GetExtended
		jz	short DoAccessJ
		mov	al, [si-1]

DoAccessJ:				; ...
		jmp	DoAccess
; ---------------------------------------------------------------------------

_$FCB_RANDOM_WRITE_BLOCK:		; ...
		mov	al, 0Ah		; RANDOM+BLOCK
		jmp	FCBIO
; ---------------------------------------------------------------------------

_$FCB_RANDOM_READ_BLOCK:		; ...
		mov	al, 0Eh		; RANDOM+FCBREAD+BLOCK
		jmp	FCBIO
; ---------------------------------------------------------------------------

_$FCB_SEQ_READ:				; ...
		mov	al, 4		; FCBREAD
		jmp	FCBIO
; ---------------------------------------------------------------------------

_$FCB_SEQ_WRITE:			; ...
		mov	al, 0
		jmp	FCBIO
; ---------------------------------------------------------------------------

_$FCB_RANDOM_READ:			; ...
		mov	al, 6		; RANDOM+FCBREAD
		jmp	FCBIO
; ---------------------------------------------------------------------------

_$FCB_RANDOM_WRITE:			; ...
		mov	al, 2		; RANDOM
		jmp	FCBIO
; ---------------------------------------------------------------------------

_$DIR_SEARCH_FIRST:			; ...
		mov	word [ss:THISFCB], dx
		mov	word [ss:THISFCB+2], ds
		mov	si, dx
		cmp	byte [si], 0FFh
		jnz	short NORMFCB4
		add	si, 7

NORMFCB4:				; ...
		push	word [si]
		push	ss
		pop	es
		mov	di, OPENBUF
		call	TransFCB
		jnb	short SearchIt
		pop	bx

dcf_errj:				; ...
		jmp	FCB_RET_ER
; ---------------------------------------------------------------------------

SearchIt:				; ...
		push	ss
		pop	ds
		push	word [DMAADD]
		push	word [DMAADD+2]
		mov	word [DMAADD], SEARCHBUF
		mov	word [DMAADD+2], ds
		call	GET_FAST_SEARCH
		pop	word [DMAADD+2]
		pop	word [DMAADD]
		jnb	short SearchSet
		pop	bx
		jmp	short dcf_errj
; ---------------------------------------------------------------------------

SearchSet:				; ...
		mov	si, SEARCHBUF
		les	di, [THISFCB]
		test	byte [EXTFCB], 0FFh
		jz	short NORMFCB1
		add	di, 7

NORMFCB1:				; ...
		pop	bx
		or	bl, bl
		jnz	short SearchDrv
		mov	bl, [CURDRV]
		inc	bl

SearchDrv:				; ...
		lodsb
		xchg	al, bl
		inc	di
		mov	cx, 10		; 20/2
		rep movsw
		xchg	al, bl
		stosb
		les	di, [DMAADD]
		test	byte [EXTFCB], 0FFh
		jz	short NORMFCB2
		mov	al, 0FFh
		stosb
		inc	al
		mov	cx, 5
		rep stosb
		mov	al, [SATTRIB]
		stosb

NORMFCB2:				; ...
		mov	al, bl
		stosb
		mov	cx, 16
		rep movsw
		jmp	NO_OP		; FCB_RET_OK
; ---------------------------------------------------------------------------

_$DIR_SEARCH_NEXT:			; ...
		mov	word [ss:THISFCB], dx
		mov	word [ss:THISFCB+2], ds
		mov	byte [ss:SATTRIB], 0
		mov	byte [ss:EXTFCB], 0
		push	ss
		pop	es
		mov	di, SEARCHBUF
		mov	si, dx
		cmp	byte [si], 0FFh
		jnz	short NORMFCB6
		add	si, 6
		lodsb
		mov	[ss:SATTRIB], al
		dec	byte [ss:EXTFCB]

NORMFCB6:				; ...
		lodsb
		push	ax
		mov	al, [si+20]
		stosb
		mov	cx, 10		; 20/2
		rep movsw
		push	ss
		pop	ds
		push	word [DMAADD]
		push	word [DMAADD+2]
		mov	word [DMAADD], SEARCHBUF
		mov	word [DMAADD+2],	ds
		call	DOS_SEARCH_NEXT
		pop	word [DMAADD+2]
		pop	word [DMAADD]
		jb	short SearchNoMore
		jmp	SearchSet
; ---------------------------------------------------------------------------

SearchNoMore:				; ...
		les	di, [THISFCB]
		test	byte [EXTFCB], 0FFh
		jz	short NORMFCB8
		add	di, 7

NORMFCB8:				; ...
		pop	bx
		mov	[es:di], bl
		jmp	FCB_RET_ER
; ---------------------------------------------------------------------------

_$FIND_FIRST:				; ...
		mov	si, dx
		mov	[ss:SATTRIB], cl
		mov	di, OPENBUF
		call	TransPathSet
		jnb	short Find_it

FindError:
		mov	al, 3

FF_errj:				; ...
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

Find_it:				; ...
		push	ss
		pop	ds
		push	word [DMAADD]
		push	word [DMAADD+2]
		mov	word [DMAADD], SEARCHBUF
		mov	word [DMAADD+2],	ds
		call	GET_FAST_SEARCH
		pop	word [DMAADD+2]
		pop	word [DMAADD]
		jnb	short FindSet

FFF_errj:				; ...
		jmp	short FF_errj
; ---------------------------------------------------------------------------

FindSet:				; ...
		mov	si, SEARCHBUF
		les	di, [DMAADD]
		mov	cx, 21
		rep movsb
		push	si
		mov	al, [si+0Bh]	; [SI+dir_entry.dir_attr]
		stosb
		add	si, 16h		; dir_entry.dir_time
		movsw
		movsw
		inc	si
		inc	si
		movsw
		movsw
		pop	si
		call	PackName
		jmp	SYS_RETURN	; SYS_RET_OK
; ---------------------------------------------------------------------------

_$FIND_NEXT:				; ...
		push	ss
		pop	es
		mov	di, SEARCHBUF
		lds	si, [ss:DMAADD]
		mov	cx, 21
		rep movsb
		push	ss
		pop	ds
		push	word [DMAADD]
		push	word [DMAADD+2]
		mov	word [DMAADD], SEARCHBUF
		mov	word [DMAADD+2],	ds
		call	DOS_SEARCH_NEXT
		pop	word [DMAADD+2]
		pop	word [DMAADD]
		jnb	short FindSet
		jmp	short FFF_errj

; =============== S U B	R O U T	I N E =======================================

PackName:		; ...
		mov	cx, 8
		rep movsb

main_kill_tail:				; ...
		cmp	byte [es:di-1], 20h	; ' '
		jnz	short find_check_dot
		dec	di
		inc	cx
		cmp	cx, 8
		jb	short main_kill_tail

find_check_dot:				; ...
		cmp	word [si], 2020h ; (" " << 8) | " "
		jnz	short got_ext
		cmp	byte [si+2], 20h ; ' '
		jz	short find_done

got_ext:				; ...
		mov	al, '.'         ; 2Eh
		stosb
		mov	cx, 3
		rep movsb

ext_kill_tail:				; ...
		cmp	byte [es:di-1], 20h	; ' '
		jnz	short find_done
		dec	di
		jmp	short ext_kill_tail
; ---------------------------------------------------------------------------

find_done:				; ...
		xor	ax, ax
		stosb
		retn

; =============== S U B	R O U T	I N E =======================================

GET_FAST_SEARCH:
		or	word [ss:DOS34_FLAG], 400h ; SEARCH_FASTOPEN
		call	DOS_SEARCH_FIRST
		retn

; ---------------------------------------------------------------------------

_$CURRENT_DIR:				; ...
		call	ECritDisk
		mov	al, dl
		call	GetVisDrv
		jnb	short CurrentValidate

CurdirErr:				; ...
		call	LCritDisk
		push	ds
		mov	ds, [cs:DosDSeg]
		mov	al, [DrvErr]
		pop	ds

curdir_errj:				; ...
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

CurrentValidate:			; ...
		push	ds
		push	si
		mov	ds, [cs:DosDSeg]
		lds	si, [THISCDS]
		test	word [si+43h], 8000h ; [SI+curdir.flags],
					; curdir_isnet
		jnz	short $+2

DoCheck:				; ...
		push	ds
		mov	ds, [cs:DosDSeg]
		mov	byte [NoSetDir], 0
		pop	ds
		mov	di, OPENBUF
		call	ValidateCDS
		push	es
		push	di
		pop	si
		pop	ds
		pop	di
		pop	es
		jb	short CurdirErr
		add	si, 0		; curdir.text
		add	si, [si+4Fh]	; [SI+curdir.end]
		cmp	byte [si], '\' ; 5Ch
		jnz	short CurrentCopy
		inc	si

CurrentCopy:				; ...
		push	ax
		lodsb
		or	al, al
		jz	short FOK
		cmp	al, 5
		jz	short FCHANGE
		jmp	short FFF
; ---------------------------------------------------------------------------

FCPYNEXT:				; ...
		lodsb

FFF:					; ...
		cmp	al, '\'
		jnz	short FOK
		stosb
		lodsb
		cmp	al, 5
		jnz	short FOK

FCHANGE:				; ...
		mov	al, 0E5h

FOK:					; ...
		stosb
		or	al, al
		jnz	short FCPYNEXT
		pop	ax
		xor	al, al
		call	LCritDisk
		jmp	SYS_RETURN
; ---------------------------------------------------------------------------

_$RMDIR:				; ...
		push	dx
		push	ds
		mov	si, dx
		mov	di, OPENBUF
		push	di
		call	TransPathNoSet
		pop	di
		jnb	short rmlset
		pop	ds
		pop	dx
		mov	al, 3

rmdir_errj:				; ...
		jmp	short curdir_errj
; ---------------------------------------------------------------------------

rmlset:					; ...
		cmp	byte [ss:CMETA], 0FFh ; -1
		jnz	short rmerr
		push	ss
		pop	es
		xor	al, al

rmloop:					; ...
		call	GetCDSFromDrv
		jb	short rmcont
		call	StrCmp
		jz	short rmerr
		inc	al
		jmp	short rmloop
; ---------------------------------------------------------------------------

rmerr:					; ...
		pop	ds
		pop	dx
		mov	al, 10h		; error_current_directory

chdir_errj:				; ...
		jmp	short rmdir_errj
; ---------------------------------------------------------------------------

rmcont:					; ...
		pop	ds
		pop	dx
		mov	si, DOS_RMDIR
		;jmp	DoDirCall	; // NASM converts this to short jump 
		;nop
		;jmp	short DoDirCall
		db 0E9h			; // for locating _$CHDIR at 6051h 
		dw DoDirCall-($+2)
; ---------------------------------------------------------------------------

_$CHDIR:				; ...
		mov	di, OPENBUF
		mov	si, dx
		call	TransPath
		jnb	short ChDirCrack

ChDirErrP:				; ...
		mov	al, 3		; error_path_not_found

ChDirErr:				; ...
		jmp	short chdir_errj
; ---------------------------------------------------------------------------

ChDirCrack:				; ...
		cmp	byte [CMETA], 0FFh ; -1
		jnz	short ChDirErrP
		les	di, [THISCDS]
		cmp	di, 0FFFFh	; -1
		jz	short ChDirErrP
		call	DOS_CHDIR
		jb	short ChDirErr
		les	di, [THISCDS]
		test	word [es:di+43h], 2000h ; [ES:DI+curdir.flags],
					; curdir_splice
		jz	short GotCDS
		push	es
		push	di
		push	cx
		call	Get_User_Stack
		mov	di, [si+6]	; [SI+user_env.user_DX]
		mov	ds, word [si+0Eh] ;	[SI+user_env.user_DS]
		mov	si, OPENBUF
		xchg	si, di
		xor	al, al
		push	di
		call	TransPathNoSet
		pop	si
		les	di, [THISCDS]
		mov	word [es:di+49h], 0FFFFh ; [ES:DI+curdir.ID]
		pop	cx
		pop	di
		pop	es

GotCDS:					; ...
		call	Check_PathLen
		ja	short ChDirErrP
		test	word [es:di+43h], 8000h ; [ES:DI+curdir.flags],
					; curdir_isnet
		jnz	short SkipRecency
		test	word [es:di+43h], 2000h ; [ES:DI+curdir.flags],
					; curdir_splice
		jz	short setdirclus
		mov	cx, 0FFFFh	; -1

setdirclus:				; ...
		mov	[es:di+49h], cx	; [ES:DI+curdir.ID]
		les	di, [THISCDS]

SkipRecency:				; ...
		call	FStrCpy
		xor	al, al

mkdir_ok:				; ...
		jmp	SYS_RETURN
; ---------------------------------------------------------------------------

_$MKDIR:				; ...
		mov	si, DOS_MKDIR

DoDirCall:				; ...
		mov	di, OPENBUF
		push	si
		mov	si, dx
		call	TransPath
		pop	si
		jnb	short MkDirCrack

MkErrP:					; ...
		mov	al, 3		; error_path_not_found

MkErr:					; ...
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

MkDirCrack:				; ...
		cmp	byte [ss:CMETA], 0FFh ; -1
		jnz	short MkErrP
		push	si
		call	Check_PathLen
		pop	si
		jbe	short pathok
		mov	al, 5		; error_access_denied
		jmp	short MkErr
; ---------------------------------------------------------------------------

pathok:					; ...
		call	si
		jb	short MkErr
		jmp	short mkdir_ok

; =============== S U B	R O U T	I N E =======================================

Check_PathLen:	; ...
		mov	si, [ss:WFP_START]

Check_PathLen2:				; ...
		push	ss
		pop	ds
		push	cx
		call	DStrLen
		cmp	cx, 67		; DIRSTRLEN
		pop	cx
		retn

; ---------------------------------------------------------------------------
IOCTLJMPTABLE	dw ioctl_getset_data ; ...
		dw ioctl_getset_data
		dw ioctl_control_string
		dw ioctl_control_string
		dw ioctl_get_dev
		dw ioctl_get_dev
		dw ioctl_status
		dw ioctl_status
		dw ioctl_rem_media
		dw ioctl_drive_attr
		dw ioctl_handle_redir
		dw Set_Retry_Parameters
		dw GENERICIOCTLHANDLE
		dw GENERICIOCTL
		dw ioctl_drive_owner
		dw ioctl_drive_owner
		dw GENERICIOCTLHANDLE
		dw GENERICIOCTL

; =============== S U B	R O U T	I N E =======================================

_$IOCTL:

; FUNCTION CHUNK AT 628F SIZE 00000003 BYTES
; FUNCTION CHUNK AT 62DF SIZE 00000002 BYTES
; FUNCTION CHUNK AT 62E3 SIZE 00000003 BYTES
; FUNCTION CHUNK AT 62F4 SIZE 00000003 BYTES
; FUNCTION CHUNK AT 62FC SIZE 0000005E BYTES

		mov	si, ds
		push	ss
		pop	ds
		cmp	al, 11h
		ja	short ioctl_bad_funj2
		push	ax
		mov	di, ax
		and	di, 0FFh
		shl	di, 1
		pop	ax
		jmp	[cs:IOCTLJMPTABLE+di]
; ---------------------------------------------------------------------------

ioctl_bad_funj2:			; ...
		jmp	ioctl_bad_fun
; ---------------------------------------------------------------------------

ioctl_getset_data:			; ...
		call	SFFromHandle
		jnb	short ioctl_check_permissions

ioctl_bad_handle:			; ...
		mov	al, 6		; error_invalid_handle

ioctl_error:				; ...
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

ioctl_check_permissions:		; ...
		cmp	al, 0
		mov	al, [es:di+5]	; [ES:DI+SF_ENTRY.sf_flags]
		jz	short ioctl_read
		or	dh, dh
		jz	short ioctl_check_device
		mov	al, 0Dh		; error_invalid_data
		jmp	short ioctl_error
; ---------------------------------------------------------------------------

ioctl_check_device:			; ...
		test	al, 80h		; devid_device
		jz	short ioctl_bad_funj2
		or	dl, 80h		; devid_device
		mov	byte [EXTERR_LOCUS], 4 ; errLOC_SerDev
		mov	[es:di+5], dl	; [ES:DI+SF_ENTRY.sf_flags]

ioctl_ok:				; ...
		jmp	SYS_RETURN	; SYS_RET_OK
; ---------------------------------------------------------------------------

ioctl_read:				; ...
		mov	byte [EXTERR_LOCUS], 2
		xor	ah, ah
		test	al, 80h		; devid_device
		jz	short ioctl_no_high
		mov	byte [EXTERR_LOCUS], 4 ; errLOC_SerDev
		les	di, [es:di+7]	; [ES:DI+SF_ENTRY.sf_devptr]
		mov	ah, [es:di+5]	; [ES:DI+SYSDEV.ATT+1]

ioctl_no_high:				; ...
		mov	dx, ax
		call	Get_User_Stack
		mov	[si+6],	dx	; [SI+user_env.user_DX]

ioctl_ok_j:				; ...
		jmp	short ioctl_ok
; ---------------------------------------------------------------------------

ioctl_control_string:			; ...
		call	SFFromHandle
		jb	short ioctl_bad_handle
		test	byte [es:di+5], 80h	; [ES:DI+SF_ENTRY.sf_flags],
					; devid_device
		jz	short ioctl_bad_funj2
		mov	byte [EXTERR_LOCUS], 4 ; [EXTERR_LOCUS],errLOC_SerDev
		les	di, [es:di+7]	; [ES:DI+SF_ENTRY.sf_devptr]
		xor	bl, bl
		jmp	ioctl_do_string
; ---------------------------------------------------------------------------

ioctl_status:				; ...
		mov	ah, 1
		sub	al, 6
		jz	short ioctl_get_status
		mov	ah, 3

ioctl_get_status:			; ...
		push	ax
		call	GET_IO_SFT
		pop	ax
		jnb	short DO_IOFUNC
		jmp	short ioctl_bad_handle
; ---------------------------------------------------------------------------

DO_IOFUNC:				; ...
		call	IOFUNC
		mov	ah, al
		mov	al, 0FFh
		jnz	short ioctl_status_ret
		inc	al

ioctl_status_ret:			; ...
		jmp	short ioctl_ok_j
; ---------------------------------------------------------------------------

Set_Retry_Parameters:			; ...
		mov	[RetryLoop],	cx
		or	dx, dx
		jz	short ioctl_bad_fun
		mov	[RetryCount], dx
		jmp	short ioctl_status_ret
; ---------------------------------------------------------------------------

GENERICIOCTLHANDLE:			; ...
		call	SFFromHandle
		jb	short ioctl_bad_handlej
		test	byte [es:di+6], 80h	; [ES:DI+SF_ENTRY.sf_flags+1],
					; (sf_isnet>>8)
		jnz	short ioctl_bad_fun
		mov	byte [EXTERR_LOCUS], 4 ; errLOC_SerDev
		les	di, [es:di+7]	; [es:di+SF_ENTRY.sf_devptr]
		jmp	short Do_GenIOCTL
; ---------------------------------------------------------------------------

GENERICIOCTL:				; ...
		mov	byte [EXTERR_LOCUS], 2 ; errLOC_Disk
		cmp	ch, 8		; IOC_DC
		jnz	short ioctl_bad_fun
		call	Check_If_Net
		jnz	short ioctl_bad_fun

Do_GenIOCTL:				; ...
		test	byte [es:di+4], 40h ; [ES:DI+SYSDEV.ATT],
					; DEV320
		jz	short ioctl_bad_fun
		mov	byte [IOCALL_REQFUNC], 13h ; GENIOCTL
		cmp	al, 10h		; IOCTL_QUERY_HANDLE
		jl	short SetIOCtlBlock
		test	byte [es:di+4], 80h ; [ES:DI+SYSDEV.ATT],IOQUERY
		jz	short ioctl_bad_fun
		mov	byte [IOCALL_REQFUNC], 19h ; IOCTL_QUERY

SetIOCtlBlock:				; ...
		push	es
		push	di
		mov	byte [IOCALL_REQLEN], 17h ; IOCTL_REQ.size
		mov	[IOCALL_REQUNIT], bl
		mov	[IOCTL_REQ_MAJORFUNCTION], ch ; [IOCALL+IOCTL_REQ.MAJORFUNCTION]
		mov	[IOCTL_REQ_MINORFUNCTION], cl ; [IOCALL+IOCTL_REQ.MINORFUNCTION]
		mov	word [IOCTL_REQ_REG_SI], si ; [IOCALL+IOCTL_REQ.REG_SI]
		mov	word [IOCTL_REQ_REG_DI], di ; [IOCALL+IOCTL_REQ.REG_DI]
		mov	[IOCTL_REQ_GENERICIOCTL_PACKET], dx ; [IOCALL+IOCTL_REQ.GENERICIOCTL_PACKET]
		mov	word [IOCTL_REQ_GENERICIOCTL_PACKET_2], si ; [IOCALL+IOCTL_REQ.GENERICIOCTL_PACKET+2]
		mov	bx, IOCALL_REQLEN ; IOCALL
		push	ss
		pop	es
		pop	si
		pop	ds
		jmp	ioctl_do_IO
; ---------------------------------------------------------------------------

ioctl_bad_fun:				; ...
		mov	al, 1		; error_invalid_function
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

ioctl_bad_handlej:			; ...
		jmp	ioctl_bad_handle

; ---------------------------------------------------------------------------

ioctl_rem_media:			; ...
		call	Check_If_Net
		jnz	short ioctl_bad_fun
		test	byte [es:di+5], 8 ;	[es:di+SYSDEV.ATT+1],
					; (DEVOPCL>>8)
		jz	short ioctl_bad_fun
		mov	byte [ss:IOCALL_REQFUNC], 0Fh ; DEVRMD ; 15
		mov	al, 0Dh		; REMHL	; 13
		mov	ah, bl
		mov	word [ss:IOCALL_REQLEN], ax
		xor	ax, ax
		mov	word [ss:IOCALL_REQSTAT], ax
		push	es
		pop	ds
		mov	si, di
		push	ss
		pop	es
		mov	bx, IOCALL_REQLEN ; IOCALL
		push	ds
		push	si
		call	DEVIOCALL2
		pop	si
		pop	ds
		mov	ax, word [ss:IOCALL_REQSTAT]
		and	ax, 200h	; STBUI
		mov	cl, 9
		shr	ax, cl
; START	OF FUNCTION CHUNK FOR _$IOCTL

ioctl_da_ok_j:				; ...
		jmp	SYS_RETURN	; SYS_RET_OK
; END OF FUNCTION CHUNK	FOR _$IOCTL
; ---------------------------------------------------------------------------

ioctl_drive_attr:			; ...
		mov	al, bl
		call	GETTHISDRV
		jb	short ioctl_drv_err
		call	Get_Driver_BL
		jb	short ioctl_drv_err
		mov	dx, [es:di+4]	; [es:di+SYSDEV.ATT]
		mov	bl, al
		les	di, [ss:THISCDS]
		test	byte [es:di+44h], 80h ; [ES:DI+curdir.flags+1],
					; (curdir_isnet>>8)
		jz	short IOCTLShare
		mov	dx, 1000h

IOCTLShare:				; ...
		push	ss
		pop	ds
		mov	si, OPENBUF
		add	bl, 'A'         ; 41h
		mov	[si], bl
		mov	word [si+1], 3Ah ; ':'
		mov	ax, 300h
		clc
		int	2Ah		; Microsoft Networks - CHECK DIRECT I/O
					; DS:SI	-> ASCIZ disk device name (may be full path or only drive
					; specifier--must include the colon)
					; Return: CF clear if absolute disk access allowed
		jnb	short IOCTLLocal
		or	dx, 200h

IOCTLLocal:				; ...
		test	byte [es:di+44h], 10h ; [ES:DI+curdir.flags+1],
					; (curdir_local>>8)
		jz	short ioctl_set_DX
		or	dx, 8000h

ioctl_set_DX:				; ...
		call	Get_User_Stack
		mov	[si+6],	dx	; [SI+user_env.user_DX]
; START	OF FUNCTION CHUNK FOR _$IOCTL

ioctl_gd_ok_j:				; ...
		jmp	short ioctl_da_ok_j
; END OF FUNCTION CHUNK	FOR _$IOCTL
; ---------------------------------------------------------------------------

ioctl_drv_err:				; ...
		mov	al, 0Fh		; error_invalid_drive
; START	OF FUNCTION CHUNK FOR _$IOCTL

ioctl_gd_err_j:				; ...
		jmp	SYS_RET_ERR
; END OF FUNCTION CHUNK	FOR _$IOCTL
; ---------------------------------------------------------------------------

ioctl_handle_redir:			; ...
		call	SFFromHandle
		jnb	short ioctl_got_sft
		jmp	ioctl_bad_handle
; ---------------------------------------------------------------------------

ioctl_got_sft:				; ...
		mov	dx, [es:di+5]	; [ES:DI+SF_ENTRY.sf_flags]
		jmp	short ioctl_set_DX
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR _$IOCTL

ioctl_bad_funj:				; ...
		jmp	ioctl_bad_fun
; END OF FUNCTION CHUNK	FOR _$IOCTL
; ---------------------------------------------------------------------------

ioctl_get_dev:				; ...
		call	Check_If_Net
		jnz	short ioctl_bad_funj
; START	OF FUNCTION CHUNK FOR _$IOCTL

ioctl_do_string:			; ...
		test	byte [es:di+5], 40h ; [ES:DI+SYSDEV.ATT+1],
					; (DEVIOCTL>>8)
		jz	short ioctl_bad_funj
		mov	byte [IOCALL_REQFUNC], 3 ; DEVRDIOCTL
		test	al, 1
		jz	short ioctl_control_call
		mov	byte [IOCALL_REQFUNC], 12 ; [IOCALL_REQFUNC],
					; DEVWRIOCTL

ioctl_control_call:			; ...
		mov	al, 22		; DRDWRHL
		mov	ah, bl
		mov	word [IOCALL_REQLEN], ax
		xor	ax, ax
		mov	word [IOCALL_REQSTAT], ax
		mov	[IOCTL_REQ_MAJORFUNCTION], al ; [IOMED]
		mov	word [IOCTL_IOSCNT], cx ; [IOSCNT]
		mov	word [IOCTL_REQ_MINORFUNCTION], dx ; [IOXAD]
		mov	word [IOCTL_IOXAD_2], si	; [IOXAD+2]
		push	es
		pop	ds
		mov	si, di
		push	ss
		pop	es
		mov	bx, IOCALL_REQLEN ; IOCALL

ioctl_do_IO:				; ...
		call	DEVIOCALL2
		test	byte [ss:IOCALL_REQSTAT+1], 80h ; [SS:IOCALL_REQSTAT+1],
					; (STERR>>8)
		jnz	short ioctl_string_err
		mov	ax, word [ss:IOCTL_IOSCNT] ; [SS:IOSCNT]
		jmp	short ioctl_gd_ok_j
; ---------------------------------------------------------------------------

ioctl_string_err:			; ...
		mov	di, word [ss:IOCALL_REQSTAT]

device_err:				;
		and	di, 0FFh	; STECODE
		mov	ax, di
		call	SET_I24_EXTENDED_ERROR
		mov	ax, [ss:EXTERR]
		jmp	short ioctl_gd_err_j
; END OF FUNCTION CHUNK	FOR _$IOCTL

; =============== S U B	R O U T	I N E =======================================

Get_Driver_BL:	; ...
		push	ax
		mov	al, bl
		call	GETTHISDRV
		jb	short ioctl_bad_drv
		xor	bl, bl
		mov	byte [EXTERR_LOCUS], 3 ; errLOC_Net
		les	di, [THISCDS]
		test	byte [es:di+44h], 80h ; [ES:DI+curdir.flags+1],
					; (curdir_isnet>>8)
		les	di, [es:di+45h]	; [ES:DI+curdir.devptr]
		jnz	short got_dev_ptr
		mov	byte [EXTERR_LOCUS], 2 ; errLOC_Disk
		mov	bl, [es:di+1]	; [ES:DI+DPB.UNIT]
		les	di, [es:di+13h]	; [ES:DI+DPB.DRIVER_ADDR]

got_dev_ptr:				; ...
		clc

ioctl_bad_drv:				; ...
		pop	ax
		retn

; ---------------------------------------------------------------------------

Check_If_Net:				; ...
		call	Get_Driver_BL
		jb	short ioctl_drv_err_pop
		push	es
		push	di
		les	di, [THISCDS]
		test	byte [es:di+44h], 80h ; [ES:DI+curdir.flags+1],
					; (curdir_isnet>>8)
		pop	di
		pop	es
		retn
; ---------------------------------------------------------------------------

ioctl_drv_err_pop:			; ...
		pop	ax
		jmp	ioctl_drv_err
; ---------------------------------------------------------------------------

ioctl_bad_funj3:			; ...
		jmp	ioctl_bad_fun
; ---------------------------------------------------------------------------

ioctl_string_errj:			; ...
		jmp	short ioctl_string_err
; ---------------------------------------------------------------------------

ioctl_drive_owner:			; ...
		call	Check_If_Net
		jnz	short ioctl_bad_funj3
		test	byte [es:di+4], 40h ; [ES:DI+SYSDEV.ATT],
					; DEV320
		jz	short ioctl_bad_funj3
		mov	byte [IOCALL_REQFUNC], 23 ; DEVGETOWN
		cmp	al, 0Eh
		jz	short GetOwner

SetOwner:				; DEVSETOWN
		mov	byte [IOCALL_REQFUNC], 24

GetOwner:				; ...
		mov	al, 13		; OWNHL
		mov	ah, bl
		mov	word [IOCALL_REQLEN], ax
		xor	ax, ax
		mov	word [IOCALL_REQSTAT], ax
		push	es
		pop	ds
		mov	si, di
		push	ss
		pop	es
		mov	bx, IOCALL_REQLEN ; IOCALL
		push	ds
		push	si
		call	DEVIOCALL2
		pop	si
		pop	ds
		test	byte [ss:IOCALL_REQSTAT+1], 80h ; (STERR>>8)
		jnz	short ioctl_string_errj
		mov	al, [ss:IOCALL_REQUNIT]
		jmp	SYS_RETURN	; SYS_RET_OK

; =============== S U B	R O U T	I N E =======================================

DOS_DELETE:		; ...
		call	TestNet
		jnb	short LOCAL_DELETE
		mov	ax, 1113h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - DELETE REMOTE FILE
					; SS = DS = DOS	CS, SDA	first filename pointer -> fully-qualified filename in DOS CS
					; SDA CDS pointer -> current directory structure for drive with	file
					; Return: CF set on error
		retn
; ---------------------------------------------------------------------------

LOCAL_DELETE:				; ...
		mov	byte [FOUNDDEL], 0
		call	ECritDisk
		mov	word [CREATING], 0E500h ; DIRFREE*256+0
		mov	si, [WFP_START]

SKPNUL:					; ...
		lodsb
		or	al, al
		jnz	short SKPNUL
		sub	si, 4
		cmp	word [si], 2E2Ah ; "*."
		jnz	short TEST_QUEST
		cmp	byte [si+2], '*'
		jz	short CHECK_ATTS

TEST_QUEST:				; ...
		sub	si, 9
		xchg	di, si
		push	ss
		pop	es
		mov	ax, '??'        ; 3F3Fh
		mov	cx, 4
		repe scasw
		jnz	short NOT_ALL
		xchg	di, si
		lodsw
		cmp	ax, 3F2Eh	; ".?"
		jnz	short NOT_ALL
		lodsw
		cmp	ax, '??'
		jnz	short NOT_ALL

CHECK_ATTS:				; ...
		mov	al, [SATTRIB]
		and	al, 1Fh		; attr_hidden+attr_system+attr_directory
					; +attr_volume_id+attr_read_only
		cmp	al, 1Fh
		jnz	short NOT_ALL
		mov	byte [DELALL], 0

NOT_ALL:				; ...
		mov	byte [NoSetDir], 1
		call	GetPathNoSet
		jnb	short Del_found
		jnz	short _bad_path
		or	cl, cl
		jz	short _bad_path

No_file:				; ...
		mov	ax, 2		; error_file_not_found

ErrorReturn:				; ...
		stc
		call	LCritDisk
		retn
; ---------------------------------------------------------------------------

_bad_path:				; ...
		mov	ax, 3		; error_path_not_found
		jmp	short ErrorReturn
; ---------------------------------------------------------------------------

Del_found:				; ...
		jnz	short NOT_DIR
		cmp	byte [DELALL], 0
		jz	short NOT_DIR

Del_access_err:				; ...
		mov	ax, 5		; error_access_denied
		jmp	short ErrorReturn
; ---------------------------------------------------------------------------

NOT_DIR:				; ...
		or	ah, ah
		js	short Del_access_err

DELFILE:				; ...
		or	byte [FOUNDDEL], 1 ; FILEFOUND
		push	ds
		mov	ah, [DELALL]
		lds	di, [CURBUF]
		test	byte [ss:ATTRIB], 1 ; attr_read_only
		jnz	short DoDelete
		test	byte [bx+0Bh], 1 ; [BX+dir_entry.dir_attr],
					; attr_read_only
		jz	short DoDelete
		pop	ds
		jmp	short DELNXT
; ---------------------------------------------------------------------------

DoDelete:				; ...
		call	REN_DEL_Check
		jnb	short DEL_SHARE_OK
		pop	ds
		jmp	short DELNXT
; ---------------------------------------------------------------------------

DEL_SHARE_OK:				; ...
		test	byte [di+5], 40h ; [DI+BUFFINFO.buf_flags],buf_dirty
		jnz	short yesdirty
		call	INC_DIRTY_COUNT
		or	byte [di+5], 40h

yesdirty:				; ...
		mov	[bx], ah	; [BX+dir_entry.dir_name]
		mov	bx, [si]
		pop	ds
		or	byte [FOUNDDEL], 10h ; FILEDELETED
		cmp	bx, 2
		jb	short DELNXT
		cmp	bx, [es:bp+0Dh]	; [ES:BP+DPB.MAX_CLUSTER]
		ja	short DELNXT
		call	RELEASE
		jb	short No_fileJ
		call	FastOpen_Delete

DELNXT:					; ...
		les	bp, [THISDPB]
		call	GETENTRY
		jb	short No_fileJ
		call	NEXTENT
		jnb	short DELFILE
		les	bp, [THISDPB]
		mov	al, [es:bp+0]
		call	FLUSHBUF
		jb	short No_fileJ
		test	byte [FOUNDDEL], 10h ; FILEDELETED
		jz	short DelError
		test	byte [ATTRIB], 8 ; attr_volume_id
		jz	short No_Set_Flag
		push	ax
		push	es
		push	di
		les	di, [THISCDS]
		mov	ah, [es:di]
		sub	ah, 'A'
		mov	[VOLCHNG_FLAG], ah
		xor	bh, bh
		call	Set_Media_ID
		call	FATREAD_CDS
		pop	di
		pop	es
		pop	ax

No_Set_Flag:				; ...
		call	LCritDisk
		retn
; ---------------------------------------------------------------------------

DelError:				; ...
		test	byte [FOUNDDEL], 1 ; FILEFOUND
		jnz	short Del_access_errJ

No_fileJ:				; ...
		jmp	No_file
; ---------------------------------------------------------------------------

Del_access_errJ:			; ...
		jmp	Del_access_err

; =============== S U B	R O U T	I N E =======================================

REN_DEL_Check:	; ...
		push	ds
		push	di
		push	ax
		push	bx
		push	si
		push	ss
		pop	es
		mov	di, [ss:WFP_START]
		mov	si, bx
		mov	ds, word [ss:CURBUF+2]
		mov	bx, di
		add	bx, 2
		call	StrLen
		dec	cx
		add	di, cx
		call	SkipBack
		inc	di
		mov	[ss:SAVE_BX], di
		call	PackName
		pop	si
		pop	bx
		push	bx
		push	si
		push	ss
		pop	ds
		;call	dword [ShCloseFile] ; Call far [JShare+(13*4)]
		call	far [JShare+(13*4)]
		mov	word [THISSFT+2], ds
		mov	word [THISSFT], 765h ; AUXSTACK-SF_ENTRY.size
		xor	ah, ah
		call	DOOPEN
		les	di, [THISSFT]
		mov	word [es:di+2], 10h	; [ES:DI+SF_ENTRY.sf_mode],
					; SHARING_DENY_BOTH
		mov	word [es:di], 1 ; [ES:DI+SF_ENTRY.sf_ref_count]
		call	ShareEnter
		jb	short CheckDone
		les	di, [THISSFT]
		mov	word [es:di], 0
		call	ShareEnd
		clc

CheckDone:				; ...
		les	bp, [THISDPB]
		pop	si
		pop	bx
		pop	ax
		pop	di
		pop	ds
		retn

; ---------------------------------------------------------------------------

FastOpen_Delete:			; ...
		pushf
		push	si
		push	bx
		push	ax
		mov	si, [ss:WFP_START]
		mov	al, 3		; FONC_delete
; START	OF FUNCTION CHUNK FOR FastOpen_Update

fastinvoke:				; ...
		mov	bx, FastOpenTable_2 ; FastTable+2
		;call	dword [bx]	; CALL far [BX]
		call	far [bx]
		pop	ax
		pop	bx
		pop	si
		popf
		retn
; END OF FUNCTION CHUNK	FOR FastOpen_Update

; =============== S U B	R O U T	I N E =======================================

FastOpen_Rename:
		pushf
		push	si
		push	di
		push	bx
		push	ax
		mov	si, [ss:REN_WFP]
		mov	di, NAME1
		mov	al, 6		; FONC_Rename
		mov	bx, FastOpenTable_2
		;call	dword [bx]	; CALL far [BX]
		call	far [bx]
		pop	ax
		pop	bx
		pop	di
		pop	si
		popf
		retn

; =============== S U B	R O U T	I N E =======================================

FastOpen_Update:

; FUNCTION CHUNK AT 6596 SIZE 0000000A BYTES

		pushf
		push	si
		push	bx
		push	ax
		mov	al, 4		; FONC_update
		jmp	short fastinvoke

; =============== S U B	R O U T	I N E =======================================

Fast_Dispatch:	; ...
		mov	si, FastOpenTable_2 ; FastTable+2
		;call	dword [ss:si] ; CALL far [SS:SI]
		call	far [ss:si]
		retn

; =============== S U B	R O U T	I N E =======================================

DOS_RENAME:		; ...
		call	TestNet
		jnb	short LOCAL_RENAME
		mov	ax, 1111h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - RENAME REMOTE FILE
					; SS = DS = DOS	CS, SDA	first filename pointer = offset	of fully-qualified old name
					; SDA CDS pointer -> current directory
					; Return: CF set on error
		retn
; ---------------------------------------------------------------------------

LOCAL_RENAME:				; ...
		mov	byte [EXTERR_LOCUS], 2 ; errLOC_Disk
		mov	si, [WFP_START]
		mov	di, [REN_WFP]
		mov	al, [si]
		mov	ah, [di]
		or	ax, 2020h	; Lower	case
		cmp	al, ah
		jz	short SAMEDRV
		mov	ax, 11h		; error_not_same_device
		stc
		retn
; ---------------------------------------------------------------------------

SAMEDRV:				; ...
		push	word [DMAADD+2]
		push	word [DMAADD]
		mov	word [DMAADD+2], ds
		mov	word [DMAADD], RENAMEDMA
		mov	byte [FOUND_DEV], 0
		call	ECritDisk
		call	DOS_SEARCH_FIRST
		jnb	short Check_Dev
		cmp	ax, 12h		; error_no_more_files
		jnz	short GOTERR
		mov	ax, 2		; error_file_not_found

GOTERR:					; ...
		stc

RENAME_POP:				; ...
		pop	word [DMAADD]
		pop	word [DMAADD+2]
		call	LCritDisk
		retn
; ---------------------------------------------------------------------------

Check_Dev:				; ...
		mov	ax, 5		; error_access_denied
		push	ds
		lds	si, [DMAADD]
		add	si, 21		; find_buf.attr
		test	byte [si+11], 10h ; [SI+dir_entry.dir_attr],
					; attr_directory
		jz	short notdir
		mov	si, [REN_WFP]
		call	Check_PathLen2

notdir:					; ...
		pop	ds
		ja	short GOTERR
		cmp	byte [FOUND_DEV], 0
		jnz	short GOTERR
		mov	si, bx
		add	si, 26		; dir_entry.dir_first
		call	REN_DEL_Check
		jnb	short REN_OK1
		mov	ax, 20h		; error_sharing_violation
		jmp	short RENAME_POP
; ---------------------------------------------------------------------------

REN_OK1:				; ...
		push	si
		lds	si, [DMAADD]
		add	si, 21
		test	byte [si+11], 10h ;	[SI+dir_entry.dir_attr],
					; attr_directory
		jz	short NOT_DIR1
		pop	si
		jmp	short SWAP_SOURCE
; ---------------------------------------------------------------------------

NOT_DIR1:				; ...
		pop	si
		call	FastOpen_Delete

SWAP_SOURCE:				; ...
		mov	ax, [WFP_START]
		mov	si, [REN_WFP]
		mov	[WFP_START], si
		mov	[REN_WFP], ax
		mov	word [CURR_DIR_END], 0FFFFh ; -1
		mov	word [CREATING], 0E5FFh ; DIRFREE*256+0FFh
		call	GetPathNoSet
		jb	short NODEST
		or	ah, ah
		jns	short SAVEDEST

BAD_ACC:				; ...
		mov	ax, 5		; error_access_denied
		stc

RENAME_CLEAN:				; ...
		pushf
		push	ax
		mov	al, [THISDRV]
		call	FLUSHBUF
		pop	ax
		cmp	byte [FAILERR], 0
		jnz	short BAD_ERR
		popf
		jmp	RENAME_POP
; ---------------------------------------------------------------------------

BAD_ERR:				; ...
		pop	ax

_BAD_PATH:				; error_path_not_found
		mov	ax, 3
		jmp	GOTERR
; ---------------------------------------------------------------------------

NODEST:					; ...
		jnz	short BAD_PATH
		cmp	byte [FAILERR], 0
		jnz	short BAD_PATH
		or	cl, cl
		jnz	short SAVEDEST

BAD_PATH:				; ...
		mov	ax, 3		; error_path_not_found
		stc
		jmp	RENAME_POP
; ---------------------------------------------------------------------------

SAVEDEST:				; ...
		push	ss
		pop	es
		mov	di, NAME2
		mov	si, NAME1
		mov	cx, 11
		rep movsb
		mov	ax, [DIRSTART]
		mov	[DESTSTART],	ax

BUILDDEST:				; ...
		push	ss
		pop	es
		mov	bx, RENAMEDMA+15h ; RENAMEDMA+21
		mov	di, NAME1
		mov	si, NAME2
		mov	cx, 11
		call	NEW_RENAME
		mov	byte [ATTRIB], 16h ; attr_all
		mov	byte [CREATING], 0FFh
		call	DEVNAME
		jnb	short BAD_ACC
		mov	bx, [DESTSTART]
		les	bp, [THISDPB]
		call	SETDIRSRCH
		jb	short BAD_ACC
		call	FINDENTRY
		jnb	short BAD_ACC
		cmp	byte [FAILERR], 0
		jnz	short BAD_ACCJ
		mov	ax, [DESTSTART]
		cmp	ax, word [RENAMEDMA+0Fh]	; [RENAMEDMA+15]
		jz	short SIMPLE_RENAME
		mov	al, [RENAMEDMA+20h] ; [RENAMEDMA+32]
					; [RENAMEDMA+21+dir_entry.dir_attr]
		test	al, 10h		; attr_directory
		jnz	short BAD_ACCJ
		mov	byte [ATTRIB], al
		mov	word [THISSFT+2], ds
		mov	si, RENAMEDMA+145h ; RENAMEDMA+325
					; AUXSTACK-SF_ENTRY.size
		mov	word [THISSFT], si
		mov	word [si+2], 2 ; [SI+SF_ENTRY.sf_mode],
					; SHARING_COMPAT+open_for_both
		xor	cx, cx
		call	RENAME_MAKE
		jnb	short GOT_DEST

BAD_ACCJ:				; ...
		jmp	BAD_ACC
; ---------------------------------------------------------------------------

GOT_DEST:				; ...
		push	bx
		les	di, [THISSFT]
		call	ShareEnd
		pop	bx
		les	di, [CURBUF]
		test	byte [es:di+5], 40h ; [ES:DI+BUFFINFO.buf_flags],
					; buf_dirty
		jnz	short yesdirty1
		call	INC_DIRTY_COUNT
		or	byte [es:di+5], 40h ; [ES:DI+BUFFINFO.buf_flags],
					; buf_dirty

yesdirty1:				; ...
		mov	di, bx
		add	di, 11		; dir_entry.dir_attr
		mov	si, RENAMEDMA+20h
		mov	cx, 21		; dir_entry.size-dir_entry.dir_attr
		rep movsb
		call	GET_SOURCE
		jb	short RENAME_OVER
		mov	di, bx
		mov	es, word [CURBUF+2]
		mov	al, 0E5h	; DIRFREE
		stosb
		jmp	short DIRTY_IT
; ---------------------------------------------------------------------------

SIMPLE_RENAME:				; ...
		call	GET_SOURCE
		jb	short RENAME_OVER
		mov	di, bx
		mov	es, word [CURBUF+2]
		mov	si, NAME1
		mov	cx, 11
		rep movsb

DIRTY_IT:				; ...
		mov	di, word [CURBUF]
		test	byte [es:di+5], 40h ; [ES:DI+BUFFINFO.buf_flags],
					; buf_dirty
		jnz	short yesdirty2
		call	INC_DIRTY_COUNT
		or	byte [es:di+5], 40h ; [ES:DI+BUFFINFO.buf_flags],
					; buf_dirty

yesdirty2:				; ...
		push	si
		lds	si, [DMAADD]
		add	si, 21		; find_buf.attr
		test	byte [si+11], 10h ; [SI+dir_entry.dir_attr],
					; attr_directory
		jz	short NOT_DIR2
		call	FastOpen_Rename
		pop	si
		jmp	short NOT_DIRTY1
; ---------------------------------------------------------------------------

NOT_DIR2:				; ...
		pop	si

NOT_DIRTY1:				; ...
		mov	si, RENAMEDMA+1
		call	ECritDisk
		mov	byte [CREATING], 0
		call	RENAME_NEXT
		jb	short RENAME_OVER
		lea	si, [bx+26]	; [BX+dir_entry.dir_first]
		call	REN_DEL_Check
		jnb	short REN_OK2
		mov	ax, 20h		; error_sharing_violation
		jmp	RENAME_CLEAN
; ---------------------------------------------------------------------------

REN_OK2:				; ...
		mov	al, [RENAMEDMA+20h] ; [RENAMEDMA+21+dir_entry.dir_attr]
		test	al, 10h		; attr_directory
		jz	short Ren_Directory
		call	FastOpen_Delete
		jmp	BUILDDEST
; ---------------------------------------------------------------------------

Ren_Directory:				; ...
		call	FastOpen_Rename
		jmp	BUILDDEST
; ---------------------------------------------------------------------------

RENAME_OVER:				; ...
		clc
		jmp	RENAME_CLEAN

; =============== S U B	R O U T	I N E =======================================

GET_SOURCE:		; ...
		mov	bx, word [RENAMEDMA+0Fh]
		les	bp, [THISDPB]
		call	SETDIRSRCH
		jb	short gs_ret_label
		call	STARTSRCH
		mov	ax, word [RENAMEDMA+0Dh]
		call	GETENT

gs_ret_label:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================

NEW_RENAME:		; ...
		lodsb
		cmp	al, '?'         ; 3Fh
		jnz	short NOCHG
		mov	al, [bx]

NOCHG:					; ...
		stosb
		inc	bx
		loop	NEW_RENAME
		retn

; =============== S U B	R O U T	I N E =======================================

GET_FILE_INFO:	; ...
		call	TestNet
		jnb	short LOCAL_INFO
		mov	ax, 110Fh	; (MultNET SHL 8) OR 15
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - GET REMOTE FILE'S ATTRIBUTES
					; SS = DOS CS, SDA first filename pointer -> fully-qualified name of file
					; SDA CDS pointer -> current directory
					; Return: CF set on error, AX =	file attributes
		retn
; ---------------------------------------------------------------------------

LOCAL_INFO:				; ...
		call	ECritDisk
		mov	byte [NoSetDir], 1
		call	GET_FAST_PATH
		jnb	short info_check_dev

NO_PATH:				; ...
		jnz	short bad_path1
		or	cl, cl
		jz	short bad_path1

info_no_file:				; ...
		mov	ax, 2		; error_file_not_found

BadRet:					; ...
		stc

JustRet:				; ...
		call	LCritDisk
		retn
; ---------------------------------------------------------------------------

bad_path1:				; ...
		mov	ax, 3		; error_path_not_found
		jmp	short BadRet
; ---------------------------------------------------------------------------

info_check_dev:				; ...
		or	ah, ah
		js	short info_no_file
		cmp	word [CURBUF], 0FFFFh ; -1
		jnz	short not_root
		xor	ah, ah
		mov	al, 10h		; attr_directory
		clc
		jmp	short JustRet
; ---------------------------------------------------------------------------

not_root:				; ...
		push	ds
		mov	ds, word [CURBUF+2]
		mov	si, bx
		xor	bx, bx
		mov	di, bx
		mov	cx, [si+16h]	; [SI+dir_entry.dir_time]
		mov	dx, [si+18h]	; [SI+dir_entry.dir_date]
		xor	ah, ah
		mov	al, [si+0Bh]	; [SI+dir_entry.dir_attr]
		test	al, 10h		; attr_directory
		jnz	short NO_SIZE
		mov	di, [si+1Ch]	; [SI+dir_entry.dir_size_l]
		mov	bx, [si+1Eh]	; [SI+dir_entry.dir_size_h]

NO_SIZE:				; ...
		pop	ds
		clc
		jmp	short JustRet

; =============== S U B	R O U T	I N E =======================================

SET_FILE_ATTRIBUTE:	; ...
		test	ax, 0FFD8h	; ~attr_changeable
		jz	short set_look

_BAD_ACC:				; ...
		mov	byte [EXTERR_LOCUS], 1 ; errLOC_Unk
		mov	byte [EXTERR_CLASS], 7 ; errCLASS_Apperr
		mov	byte [EXTERR_ACTION], 4 ; errACT_Abort
		mov	ax, 5		; error_access_denied
		stc
		retn
; ---------------------------------------------------------------------------

set_look:				; ...
		call	TestNet
		jnb	short LOCAL_SET
		push	ax
		mov	ax, 110Eh	; (MultNET SHL 8) OR 14
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - SET REMOTE FILE'S ATTRIBUTES
					; SS = DOS CS, SDA first filename pointer -> fully-qualified name of file
					; SDA CDS pointer -> current directory
					; STACK: WORD new file attributes
					; Return: CF set on error
		pop	bx
		retn
; ---------------------------------------------------------------------------

LOCAL_SET:				; ...
		call	ECritDisk
		push	ax
		mov	byte [NoSetDir], 1
		call	GETPATH
		jnb	short set_check_device
		pop	bx
		jmp	short NO_PATH
; ---------------------------------------------------------------------------

set_check_device:			; ...
		or	ah, ah
		jns	short set_check_share
		pop	ax
		call	LCritDisk
		jmp	short _BAD_ACC
; ---------------------------------------------------------------------------

set_check_share:			; ...
		pop	ax
		cmp	word [CURBUF], -1 ; 0FFFFh
		jz	short cannot_set_root
		call	REN_DEL_Check
		jnb	short set_do
		mov	ax, 20h		; error_sharing_violation
		jmp	short OK_BYE
; ---------------------------------------------------------------------------

cannot_set_root:			; ...
		mov	ax, 5		; error_access_denied
		stc
		jmp	short OK_BYE
; ---------------------------------------------------------------------------

set_do:					; ...
		les	di, [CURBUF]
		and	byte [es:bx+0Bh], 0D8h ; [ES:BX+dir_entry.dir_attr],~attr_changeable
		or	[es:bx+0Bh], al	; [ES:BX+dir_entry.dir_attr]
		test	byte [es:di+5], 40h ; [ES:DI+BUFFINFO.buf_flags],buf_dirty
		jnz	short yesdirty3
		call	INC_DIRTY_COUNT
		or	byte [es:di+5], 40h ; [ES:DI+BUFFINFO.buf_flags],buf_dirty

yesdirty3:				; ...
		mov	al, [THISDRV]
		push	dx
		push	di
		mov	ah, 0
		mov	dl, al
		mov	di, bx
		call	FastOpen_Update
		pop	di
		pop	dx
		call	FLUSHBUF
		jnb	short OK_BYE
		mov	ax, 2		; error_file_not_found

OK_BYE:					; ...
		call	LCritDisk
		retn

; =============== S U B	R O U T	I N E =======================================

GET_FAST_PATH:
		or	byte [ss:FastOpenFlg], 1 ; FastOpen_Set
		call	GETPATH
		pushf
		and	byte [ss:FastOpenFlg], 80h ; Fast_yes
		popf
		retn

; =============== S U B	R O U T	I N E =======================================

DOS_DUP:
		mov	es, [cs:DosDSeg]
		les	di, [es:THISSFT]

DOS_Dup_Direct:				; ...
		call	IsSFTNet
		jnz	short DO_INC
		call	DEV_OPEN_SFT

DO_INC:					; ...
		inc	word [es:di]	; [ES:DI+SF_ENTRY.sf_ref_count]
		retn

; ---------------------------------------------------------------------------

DOS_CREATE:				; ...
		xor	ah, ah

Create_inter:				; ...
		test	al, 80h		; ~(attr_all+attr_ignore+attr_volume_id)
		jnz	short AttErr
		test	al, 8		; attr_volume_id
		jz	short NoReset
		or	word [DOS34_FLAG], 80h ; DBCS_VOLID
		mov	al, 8		; attr_volume_id

NoReset:				; ...
		or	al, 20h		; attr_archive
		test	al, 50h		; attr_directory+attr_device
		jz	short ATT_OK

AttErr:					; ...
		mov	ax, 5		; Attribute problem
		mov	byte [EXTERR_LOCUS], 1 ; errLOC_Unk
		jmp	short SET_MKND_ERR
; ---------------------------------------------------------------------------

ATT_OK:					; ...
		les	di, [THISSFT]
		push	es
		les	si, [THISCDS]
		cmp	si, -1		; 0FFFFh
		jnz	short TEST_RE_NET
		pop	es
		test	byte [EXTOPEN_ON], 1 ; EXT_OPEN_ON
		jz	short NOEXTOP

IFS_extopen:				; ...
		push	ax
		mov	ax, 112Eh	; (MultNET SHL 8) OR 46
		int	2Fh		; Multiplex - DOS 4 IFSFUNC.EXE	- ???
					; SS = DS = DOS	CS, STACK: WORD	???   low byte = ???
					; Return: CF set on error
					; CF clear if successful
		pop	bx
		mov	byte [EXTOPEN_ON], 0
		retn
; ---------------------------------------------------------------------------

NOEXTOP:				; ...
		push	ax
		mov	ax, 1118h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - CREATE/TRUNCATE FILE
					; ES:DI	-> uninitialized SFT, SS = DOS CS
					; SDA first filename pointer ->	fully-qualified	name of	file
					; STACK: WORD file creation mode???
		pop	bx
		retn
; ---------------------------------------------------------------------------

TEST_RE_NET:				; ...
		test	word [es:si+43h], 8000h ; [ES:SI+curdir.flags],
					; curdir_isnet
		pop	es
		jz	short LOCAL_CREATE
		call	Set_EXT_mode
		jb	short dochk
		or	word [es:di+2], 2 ; [ES:DI+SF_ENTRY.sf_mode],
					; SHARING_COMPAT+open_for_both

dochk:					; ...
		test	byte [EXTOPEN_ON], 1
		jnz	short IFS_extopen
		push	ax
		mov	ax, 1117h	; (MultNET SHL 8) OR 23
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - CREATE/TRUNCATE REMOTE FILE
					; ES:DI	-> uninitialized SFT, SS = DOS CS
					; SDA first filename pointer ->	fully-qualified	name of	file to	open
					; SDA CDS pointer -> current directory
					; Return: CF set on error
		pop	bx
		retn
; ---------------------------------------------------------------------------

LOCAL_CREATE:				; ...
		call	Set_EXT_mode
		jb	short setdone
		or	word [es:di+2], 2 ; [ES:DI+SF_ENTRY.sf_mode],
					; SHARING_COMPAT+open_for_both

setdone:				; ...
		call	ECritDisk
		call	MakeNode
		jnb	short Create_ok
		mov	byte [VOLCHNG_FLAG], 0FFh ; -1
		call	LCritDisk

SET_MKND_ERR:				; ...
		mov	bx, CRTERRTAB
		;xlat	byte [cs:bx] ; CS XLAT
		cs
		xlat
		stc
		retn
; ---------------------------------------------------------------------------
CRTERRTAB	db 0			; ...
		db 5			; error_access_denied
		db 52h			; error_cannot_make
		db 50h			; error_file_exists
		db 3			; error_path_not_found
		db 5			; error_access_denied
		db 20h			; error_sharing_violation
		db 2			; error_file_not_found
; ---------------------------------------------------------------------------

Create_ok:				; ...
		call	FastOpen_Delete
		mov	al, [SATTRIB]
		test	al, 8		; attr_volume_id
		jz	short NoVolLabel
		les	di, [THISCDS]
		mov	ah, [es:di]	; [ES:DI+curdir.text]
		sub	ah, 'A'         ; 41h
		mov	[VOLCHNG_FLAG], ah
		mov	bh, 1
		call	Set_Media_ID
		call	ECritDisk
		call	FATREAD_CDS
		call	LCritDisk

NoVolLabel:				; ...
		mov	ax, 2
		les	di, [THISSFT]
		;call	dword [ShSU]	; call far [JShare+(14*4)]
		call	far [JShare+(14*4)]
		call	LCritDisk
		jmp	SET_SFT_MODE
; ---------------------------------------------------------------------------

DOS_Create_New:				; ...
		mov	ah, 1
		jmp	Create_inter

; =============== S U B	R O U T	I N E =======================================

Set_Media_ID:	; ...
		push	ax
		push	es
		push	di
		inc	ah
		mov	bl, ah
		mov	al, 0Dh		; generic IOCTL
		mov	cx, 866h	; get media id
		mov	dx, FAKE_STACK_2F ; Packet_Temp
		push	bx
		push	dx
		xor	bh, bh
		call	_$IOCTL
		pop	dx
		pop	bx
		jb	short geterr
		or	bh, bh
		jz	short NoName	; delete volume	id
		mov	si, NAME1 ; set volume id
		jmp	short doset
; ---------------------------------------------------------------------------

NoName:					; ...
		mov	si, NO_NAME_ID ;	"NO NAME    "

doset:					; ...
		mov	di, dx
		add	di, 6		; MEDIA_ID_INFO.MEDIA_Label
		push	ss
		pop	ds
		push	ss
		pop	es
		mov	cx, 11
		rep movsb
		mov	cx, 846h	; set volume id
		mov	al, 0Dh
		xor	bh, bh
		call	_$IOCTL

geterr:					; ...
		push	ss
		pop	ds
		pop	di
		pop	es
		pop	ax
		retn

; =============== S U B	R O U T	I N E =======================================

Set_EXT_mode:	; ...
		test	byte [ss:EXTOPEN_ON], 1 ; [ss:EXTOPEN_ON],EXT_OPEN_ON
		jz	short NOTEX
		push	ax
		mov	ax, [ss:SAVE_BX]
		or	[es:di+2], ax	; [ES:DI+SF_ENTRY.sf_mode]
		pop	ax
		stc

NOTEX:					; ...
		retn

; ---------------------------------------------------------------------------

DOS_OPEN:				; ...
		mov	byte [NoSetDir], 0
		call	Check_Access_AX
		jb	short do_ret_label
		les	di, [THISSFT]
		xor	ah, ah
		mov	[es:di+2], al	; [ES:DI+SF_ENTRY.sf_mode]
		push	es
		les	si, [THISCDS]
		cmp	si, -1
		jnz	short TEST_RE_NET1
		pop	es
		test	byte [EXTOPEN_ON], 1 ; EXT_OPEN_ON
		jz	short _NOEXTOP

_IFS_extopen:				; ...
		mov	al, byte [SAVE_BX]
		push	ax
		mov	ax, 112Eh	; (MultNET*256)+46
		int	2Fh		; Multiplex - DOS 4 IFSFUNC.EXE	- ???
					; SS = DS = DOS	CS, STACK: WORD	???   low byte = ???
					; Return: CF set on error
					; CF clear if successful
		pop	bx
		mov	byte [EXTOPEN_ON], 0

do_ret_label:				; ...
		retn
; ---------------------------------------------------------------------------

_NOEXTOP:				; ...
		test	byte [DOS_FLAG], 1 ; EXECOPEN
		jz	short not_exec_open
		test	byte [DOS34_FLAG+1], 8 ; (EXEC_AWARE_REDIR>>8)
		jz	short not_exec_open
		mov	al, 23h		; SHARING_DENY_WRITE+EXEC_OPEN

not_exec_open:				; ...
		push	ax
		mov	ax, 1116h	; (MultNET SHL 8) OR 22
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - OPEN	EXISTING REMOTE	FILE
					; ES:DI	-> uninitialized SFT, SS = DOS CS
					; SDA first filename pointer ->	fully-qualified	name of	file to	open
					; STACK: WORD file open	mode
					; Return: CF set on error
		pop	bx
		retn
; ---------------------------------------------------------------------------

TEST_RE_NET1:				; ...
		test	word [es:si+43h], 8000h ; [ES:SI+curdir.flags],
					; curdir_isnet
		pop	es
		jz	short LOCAL_OPEN
		test	byte [EXTOPEN_ON], 1
		jnz	short _IFS_extopen
		jmp	short _NOEXTOP
; ---------------------------------------------------------------------------

LOCAL_OPEN:				; ...
		call	ECritDisk
		or	byte [FastOpenFlg], 5 ; FastOpen_Set+Special_Fill_Set
		call	GETPATH
		jnb	short Open_found
		jnz	short bad_path2
		or	cl, cl
		jz	short bad_path2
		mov	ax, 2		; error_file_not_found

OpenBadRet:				; ...
		and	byte [ss:FastOpenFlg], 80h ; Fast_yes
		stc
		call	LCritDisk
		jmp	Clear_FastOpen
; ---------------------------------------------------------------------------

bad_path2:				; ...
		mov	ax, 3		; error_path_not_found
		jmp	short OpenBadRet
; ---------------------------------------------------------------------------

Open_Bad_Access:			; ...
		mov	ax, 5		; error_access_denied
		jmp	short OpenBadRet
; ---------------------------------------------------------------------------

Open_found:				; ...
		jz	short Open_Bad_Access
		or	ah, ah
		js	short open_ok
		mov	es, word [CURBUF+2]
		mov	al, [es:bx+0Bh]	; [ES:BX+dir_entry.dir_attr]
		test	al, 8		; attr_volume_id
		jnz	short Open_Bad_Access
		test	al, 1		; attr_read_only
		jz	short open_ok
		push	ds
		push	si
		lds	si, [THISSFT]
		mov	cx, [si+2]	; [SI+SF_ENTRY.sf_mode]
		test	cx, 8000h	; sf_isFCB
		jnz	short ResetAccess
		mov	dl, cl
		and	dl, 0F0h	; SHARING_MASK
		cmp	dl, 70h		; SHARING_NET_FCB
		jnz	short NormalOpen

ResetAccess:				; ...
		and	cx, 0FFF0h	; ~access_mask
		mov	[si+2],	cx	; [SI+SF_ENTRY.sf_mode]
		jmp	short FillSFT
; ---------------------------------------------------------------------------

NormalOpen:				; ...
		and	cl, 0Fh		; access_mask
		cmp	cl, 0		; open_for_read
		jz	short FillSFT
		pop	si
		pop	ds
		jmp	short Open_Bad_Access
; ---------------------------------------------------------------------------

FillSFT:				; ...
		pop	si
		pop	ds

open_ok:				; ...
		call	DOOPEN
		and	byte [ss:FastOpenFlg], 80h ; Fast_yes
		call	DO_SHARE_CHECK
		jnb	short SHARE_OK
		call	LCritDisk
		jmp	short Clear_FastOpen
; ---------------------------------------------------------------------------

SHARE_OK:				; ...
		mov	ax, 3
		les	di, [THISSFT]
		;call	dword [ShSU] ; call far [JShare+(14*4)]
		call	far [JShare+(14*4)]
		call	LCritDisk

SET_SFT_MODE:				; ...
		les	di, [THISSFT]
		call	DEV_OPEN_SFT
		test	word [es:di+2], 8000h ; ES:DI+SF_ENTRY.sf_mode],
					; sf_isFCB
		jz	short Clear_FastOpen
		mov	ax, [CurrentPDB]
		mov	[es:di+31h], ax	; [ES:DI+SF_ENTRY.sf_PID]

Clear_FastOpen:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================

SHARE_ERROR:	; ...
		test	word [es:di+2], 8000h ; [ES:DI+SF_ENTRY.sf_mode],
					; sf_isFCB
		jnz	short _HARD_ERR
		mov	cl, [es:di+2]	; [ES:DI+SF_ENTRY.sf_mode]
		and	cl, 0F0h	; SHARING_MASK
		cmp	cl, 0		; SHARING_COMPAT
		jnz	short _NO_HARD_ERR

_HARD_ERR:				; ...
		call	SHARE_VIOLATION
		jnb	short Clear_FastOpen

_NO_HARD_ERR:				; ...
		mov	ax, 20h		; error_sharing_violation
		stc
		retn

; =============== S U B	R O U T	I N E =======================================

DO_SHARE_CHECK:	; ...
		call	ECritDisk

OPN_RETRY:				; ...
		mov	cx, [RetryCount]

OpenShareRetry:				; ...
		push	cx
		call	SHARE_CHECK
		pop	cx
		jnb	short Share_Ok2
		call	Idle
		loop	OpenShareRetry
		les	di, [THISSFT]
		call	SHARE_ERROR
		jnb	short OPN_RETRY

Share_Ok2:				; ...
		call	LCritDisk
		retn

; =============== S U B	R O U T	I N E =======================================

Check_Access_AX:
		mov	[OPEN_ACCESS], al
		push	bx
		mov	bl, al
		and	bl, 0F0h	; SHARING_MASK
		cmp	byte [FSHARING], -1
		jnz	short CheckShareMode
		cmp	bl, 70h		; SHARING_NET_FCB
		jz	short CheckAccessMode

CheckShareMode:				; ...
		cmp	bl, 40h
		ja	short Make_Bad_Access

CheckAccessMode:			; ...
		mov	bl, al
		and	bl, 0Fh		; access_mask
		cmp	bl, 2
		ja	short Make_Bad_Access
		pop	bx
		clc
		retn
; ---------------------------------------------------------------------------

Make_Bad_Access:			; ...
		mov	ax, 0Ch		; error_invalid_access
		pop	bx
		stc
		retn

; =============== S U B	R O U T	I N E =======================================

DISK_INFO:		; ...
		call	TestNet
		jnb	short LOCAL_DSK_INFO
		mov	ax, 110Ch
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - GET DISK SPACE
					; ES:DI	-> current directory
					; Return: AL = sectors per cluster, BX = total clusters
					; CX = bytes per sector, DX = number of	available clusters
		retn
; ---------------------------------------------------------------------------

LOCAL_DSK_INFO:				; ...
		mov	byte [EXTERR_LOCUS], 2 ; errLOC_Disk
		call	ECritDisk
		call	FATREAD_CDS
		jb	short CRIT_LEAVE
		mov	bx, 2
		call	UNPACK
		jb	short CRIT_LEAVE
		lds	si, [CURBUF]
		mov	ah, [si+14h]	; [SI+BUFINSIZ]
		push	ss
		pop	ds
		mov	cx, [es:bp+0Dh]	; [ES:BP+DPB.MAX_CLUSTER]
		mov	dx, [es:bp+1Fh]	; [ES:BP+DPB.FREE_CNT]
		cmp	dx, -1		; 0FFFFh
		jz	short DoScan
		cmp	dx, cx
		jb	short GotVal

DoScan:					; ...
		xor	dx, dx
		dec	cx

SCANFREE:				; ...
		call	UNPACK
		jb	short CRIT_LEAVE
		jnz	short NOTFREECLUS
		inc	dx

NOTFREECLUS:				; ...
		inc	bx
		loop	SCANFREE
		dec	bx

ReturnVals:				; ...
		dec	bx
		mov	al, [es:bp+4]	; [ES:BP+DPB.CLUSTER_MASK]
		inc	al
		mov	cx, [es:bp+2]	; [ES:BP+DPB.SECTOR_SIZE]
		mov	[es:bp+1Fh], dx	; [ES:BP+DPB.FREE_CNT]
		clc

CRIT_LEAVE:				; ...
		call	LCritDisk
		retn
; ---------------------------------------------------------------------------

GotVal:					; ...
		mov	bx, cx
		jmp	short ReturnVals

; =============== S U B	R O U T	I N E =======================================

DOS_SEARCH_FIRST:	; ...
		les	di, [THISCDS]
		cmp	di, 0FFFFh	; -1
		jnz	short TEST_RE_NET2
		mov	ax, 1119h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - ???
		retn
; ---------------------------------------------------------------------------

TEST_RE_NET2:				; ...
		test	word [es:di+43h], 8000h ; [ES:DI+curdir.flags],
					; curdir_isnet
		jz	short LOCAL_SEARCH_FIRST
		mov	ax, 111Bh	; (MultNET<<8)|27
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - FINDFIRST
					; SS = DS = DOS	CS, [DTA] = uninitialized 21-byte findfirst search data
					; SDA first filename pointer ->	fully-qualified	search template
					; SDA CDS pointer -> current directory
					; Return: CF set on error
		retn
; ---------------------------------------------------------------------------

LOCAL_SEARCH_FIRST:			; ...
		call	ECritDisk
		test	word [DOS34_FLAG], 400h ; SEARCH_FASTOPEN
		jz	short NOFN
		or	byte [FastOpenFlg], 1 ; FastOpen_Set

NOFN:					; ...
		mov	byte [NoSetDir], 1
		call	CHECK_QUESTION
		jnb	short norm_GETPATH
		and	byte [FastOpenFlg], 80h ; Fast_yes

norm_GETPATH:				; ...
		call	GETPATH
		jnb	short find_check_dev
		jnz	short bad_path3
		or	cl, cl
		jz	short bad_path3

find_no_more:				; ...
		mov	ax, 12h		; error_no_more_files

BadBye:					; ...
		and	byte [ss:FastOpenFlg], 80h ; Fast_yes
		stc
		call	LCritDisk
		retn
; ---------------------------------------------------------------------------

bad_path3:				; ...
		mov	ax, 3
		jmp	short BadBye
; ---------------------------------------------------------------------------

find_check_dev:				; ...
		or	ah, ah
		jns	short found_entry
		mov	word [LASTENT], 0FFFFh ; -1
		inc	byte [FOUND_DEV]

found_entry:				; ...
		les	di, [DMAADD]
		mov	si, [WFP_START]
		lodsb
		sub	al, 40h		; 'A'-1
		stosb

found_it:				; ...
		les	di, [DMAADD]
		inc	di
		push	ds
		test	byte [FastOpenFlg], 10h ; Set_For_Search
		jz	short notfast
		mov	si, bx
		mov	ds, word [CURBUF+2]
		jmp	short movmov
; ---------------------------------------------------------------------------

notfast:				; ...
		mov	si, NAME1

movmov:					; ...
		movsb
		cmp	byte [es:di-1], 5
		jnz	short NOTKANJB
		mov	byte [es:di-1], 0E5h

NOTKANJB:				; ...
		mov	cx, 10
		rep movsb
		pop	ds
		mov	al, [ATTRIB]
		stosb
		push	ax
		mov	ax, [LASTENT]
		stosw
		mov	ax, [DIRSTART]
		stosw
		add	di, 4
		pop	ax
		or	ah, ah
		js	short DOSREL
		cmp	word [CURBUF], -1 ; 0FFFFh
		jnz	short OKSTORE
		test	byte [FastOpenFlg], 10h ; Set_For_Search
		jnz	short OKSTORE
		mov	word [es:di-8], 0FFFFh ; -1
		jmp	find_no_more
; ---------------------------------------------------------------------------

OKSTORE:				; ...
		mov	ds, word [CURBUF+2]

DOSREL:					; ...
		mov	si, bx
		mov	cx, 32		; dir_entry.size
		mov	ax, di
		rep movsb
		mov	di, ax
		cmp	byte [es:di], 5
		jnz	short NO05
		mov	byte [es:di], 0E5h

NO05:					; ...
		and	byte [ss:FastOpenFlg], 80h ; Fast_yes
		push	ss
		pop	ds
		clc
		call	LCritDisk
		retn

; =============== S U B	R O U T	I N E =======================================

DOS_SEARCH_NEXT:
		les	di, [DMAADD]
		mov	al, [es:di]
		test	al, 80h
		jz	short LOCAL_SEARCH_NEXT
		mov	ax, 111Ch
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - FINDNEXT
					; SS = DS = DOS	CS, [DTA] = 21-byte findfirst search data
					; Return: CF set on error, AX =	DOS error code
					; CF clear if successful
		retn
; ---------------------------------------------------------------------------

LOCAL_SEARCH_NEXT:			; ...
		mov	byte [EXTERR_LOCUS], 2 ; errLOC_Disk
		call	ECritDisk
		mov	word [THISCDS], DUMMYCDS
		mov	word [THISCDS+2], ds
		add	al, 40h		; 'A'-1
		call	InitCDS
		jb	short No_files
		les	di, [THISCDS]
		les	bp, [es:di+45h]	; [ES:DI+curdir.devptr]
		call	GOTDPB
		mov	al, [es:bp+0]	; [ES:BP+DPB.DRIVE]
		mov	[THISDRV], al
		mov	word [CREATING], 0E500h ; (DIRFREE*256)+0
		mov	byte [NoSetDir], 1
		lds	si, [DMAADD]
		lodsb

RENAME_NEXT:				; ...
		push	ss
		pop	es
		mov	di, NAME1
		mov	cx, 11
		rep movsb
		lodsb
		mov	[ss:ATTRIB], al
		lodsw
		or	ax, ax
		jns	short cont_load

No_files:				; ...
		jmp	find_no_more
; ---------------------------------------------------------------------------

cont_load:				; ...
		push	ax
		lodsw
		mov	bx, ax
		push	ss
		pop	ds
		les	bp, [THISDPB]
		call	SETDIRSRCH
		jnb	short SEARCH_GOON
		pop	ax
		jmp	short No_files
; ---------------------------------------------------------------------------

SEARCH_GOON:				; ...
		call	STARTSRCH
		pop	ax
		call	GETENT
		jb	short No_files
		call	NEXTENT
		jb	short No_files
		xor	ah, ah
		jmp	found_it

; =============== S U B	R O U T	I N E =======================================

CHECK_QUESTION:	; ...
		push	ss
		pop	ds
		mov	si, [ss:WFP_START]

getnext:				; ...
		lodsb
		or	al, al
		jz	short NO_Question
		cmp	al, '?'
		jnz	short getnext
		stc

NO_Question:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================

DOS_ABORT:		; ...
		mov	es, [ss:CurrentPDB]
		mov	cx, [es:32h]	; [ES:PDB.JFN_Length]

reset_free_jfn:				; ...
		mov	bx, cx
		push	cx
		dec	bx
		call	_$CLOSE
		pop	cx
		loop	reset_free_jfn
		push	ss
		pop	ds
		mov	ax, 111Dh	; Net_Abort, MultNET, 29
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - CLOSE ALL REMOTE FILES FOR PROCESS
					; DS???, SS = DOS CS
		;call	dword [MFTCloseP] ; call far [JShare+(4*4)]
		call	far [JShare+(4*4)]
		les	di, [ss:SFTFCB]
		mov	cx, [es:di+4]	; [es:di+SFT.SFCount]
		jcxz	FCBScanDone
		lea	di, [di+6]	; [DI+SFT.SFTable]
		mov	ax, [ss:PROC_ID]

FCBTest:				; ...
		cmp	[es:di+31h], ax	; [es:di+SF_ENTRY.sf_PID]
		jnz	short FCBNext
		mov	word [es:di], 0 ; [es:di+SF_ENTRY.sf_ref_count]

FCBNext:				; ...
		add	di, 3Bh	; ';'
		loop	FCBTest

FCBScanDone:				; ...
		xor	bx, bx

Scan:					; ...
		push	bx
		call	SFFromSFN
		pop	bx
		jnb	short Scan1
		retn
; ---------------------------------------------------------------------------

Scan1:					; ...
		cmp	word [es:di], 0FFFFh ; [es:di+SF_ENTRY.sf_ref_count],
					; sf_busy
		jnz	short scan_next
		mov	ax, [ss:PROC_ID]
		cmp	[es:di+31h], ax	; [es:di+SF_ENTRY.sf_PID]
		jnz	short scan_next
		mov	ax, [ss:USER_ID]
		cmp	[es:di+2Fh], ax	; [es:di+SF_ENTRY.sf_UID]
		jnz	short scan_next
		mov	word [es:di], 0 ; [es:di+SF_ENTRY.sf_ref_count]

scan_next:				; ...
		inc	bx
		jmp	short Scan

; =============== S U B	R O U T	I N E =======================================

DOS_CLOSE:		; ...
		les	di, [THISSFT]
		mov	bx, [es:di+5]	; [ES:DI+SF_ENTRY.sf_flags]
		test	bx, 8000h	; sf_isnet
		jz	short LocalClose
		mov	ax, 1106h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - CLOSE REMOTE	FILE
					; ES:DI	-> SFT
					; SFT DPB field	-> DPB of drive	containing file
					; Return: CF set on error, AX =	DOS error code
					; CF clear if successful
		retn
; ---------------------------------------------------------------------------

LocalClose:				; ...
		call	ECritDisk
		call	SetSFTTimes
		call	FREE_SFT
		push	ss
		pop	ds
		push	ax
		push	bx
		call	ShareEnd
		pop	bx
		pop	ax

CloseEntry:				; ...
		push	ax
		test	bx, 0C0h	; devid_file_clean+devid_device
		jz	short rdir
		jmp	FREE_SFT_OK
; ---------------------------------------------------------------------------

rdir:					; ...
		call	DirFromSFT
		mov	al, 5		; error_access_denied
		jnb	short clook
		jmp	CloseFinish
; ---------------------------------------------------------------------------

clook:					; ...
		push	di
		push	si
		lea	si, [si+20h]	; [SI+SF_ENTRY.sf_name]
		call	XCHGP
		call	MetaCompare
		call	XCHGP
		pop	si
		pop	di
		jz	short CLOSE_GO
		mov	di, si
		push	ds
		pop	es
		push	ss
		pop	ds
		stc
		mov	al, 2
		jmp	CloseFinish
; ---------------------------------------------------------------------------

CLOSE_GO:				; ...
		test	word [si+2], 8000h ; [SI+SF_ENTRY.sf_mode],
					; sf_isFCB
		jz	short nofcb
		mov	ch, [es:di+0Bh]	; [ES:DI+dir_entry.dir_attr]
		mov	al, [si+4]	; [SI+SF_ENTRY.sf_attr]
		mov	[ss:ATTRIB], al
		jmp	short setattr
; ---------------------------------------------------------------------------

nofcb:					; ...
		mov	al, [si+4]	; [SI+SF_ENTRY.sf_attr]
		mov	[es:di+0Bh], al	; [ES:DI+dir_entry.dir_attr]

setattr:				; ...
		or	byte [es:di+0Bh], 20h ; [ES:DI+dir_entry.dir_attr],
					; attr_archive
		mov	ax, [es:di+1Ah]	; [ES:DI+dir_entry.dir_first]
		mov	[ss:OLD_FIRSTCLUS], ax
		mov	ax, [si+0Bh]	; [SI+SF_ENTRY.sf_firclus]
		mov	[es:di+1Ah], ax	; [ES:DI+dir_entry.dir_first]
		mov	ax, [si+11h]	; [SI+SF_ENTRY.sf_size]
		mov	[es:di+1Ch], ax	; [ES:DI+dir_entry.dir_size_l]
		mov	ax, [si+13h]	; [SI+SF_ENTRY.sf_size+2]
		mov	[es:di+1Eh], ax	; [ES:DI+dir_entry.dir_size_h]
		mov	ax, [si+0Fh]	; [SI+SF_ENTRY.sf_date]
		mov	[es:di+18h], ax	; [ES:DI+dir_entry.dir_date]
		mov	ax, [si+0Dh]	; [SI+SF_ENTRY.sf_time]
		mov	[es:di+16h], ax	; [ES:DI+dir_entry.dir_time]
		test	byte [es:bx+5], 40h	; [ES:BX+BUFFINFO.buf_flags],
					; buf_dirty
		jnz	short yesdirty4
		call	INC_DIRTY_COUNT
		or	byte [es:bx+5], 40h	; [ES:BX+BUFFINFO.buf_flags],
					; buf_dirty

yesdirty4:				; ...
		push	ds
		push	si
		mov	cx, [si+0Bh]	; [SF_ENTRY.sf_firclus]
		mov	al, [ss:THISDRV]
		push	dx
		mov	ah, 0
		mov	dl, al
		or	cx, cx
		jnz	short do_update2
		mov	ah, 3
		mov	di, [si+1Bh]	; [SI+SF_ENTRY.sf_dirsec]
		mov	cx, [si+1Dh]	; [SI+SF_ENTRY.sf_dirsec+2]
		mov	dh, [si+1Fh]	; [SI+SF_ENTRY.sf_dirpos]
		jmp	short do_update
; ---------------------------------------------------------------------------

do_update2:				; ...
		cmp	cx, [ss:OLD_FIRSTCLUS]
		jz	short do_update
		mov	ah, 2
		mov	cx, [ss:OLD_FIRSTCLUS]

do_update:				; ...
		push	ss
		pop	ds
		call	FastOpen_Update
		pop	dx
		call	FLUSHBUF
		pop	di
		pop	es
		mov	al, 5		; error_access_denied
		jb	short CloseFinish

FREE_SFT_OK:				; ...
		clc

CloseFinish:				; ...
		pushf
		call	DEV_CLOSE_SFT
		popf
		pop	cx
		pushf
		dec	cx
		jnz	short NoFree
		mov	[es:di], cx	; [ES:DI+SF_ENTRY.sf_ref_Count]

NoFree:					; ...
		call	LCritDisk
		popf
		retn

; =============== S U B	R O U T	I N E =======================================

FREE_SFT:		; ...
		pushf
		mov	ax, [es:di]	; [ES:DI+SF_ENTRY.sf_ref_count]
		dec	ax
		jnz	short SetCount
		dec	ax

SetCount:				; ...
		xchg	ax, [es:di]	; [ES:DI+SF_ENTRY.sf_ref_count]
		popf
		retn

; =============== S U B	R O U T	I N E =======================================

DirFromSFT:		; ...
		mov	byte [EXTERR_LOCUS], 2 ; errLOC_Disk
		push	es
		push	di
		mov	dx, [es:di+1Dh]	; [ES:DI+SF_ENTRY.sf_dirsec+2]
		mov	word [HIGH_SECTOR], dx
		mov	dx, [es:di+1Bh]	; [ES:DI+SF_ENTRY.sf_dirsec]
		push	word [HIGH_SECTOR]
		push	dx
		call	FATREAD_SFT
		pop	dx
		pop	word [HIGH_SECTOR]
		jb	short PopDone
		xor	al, al
		mov	byte [ALLOWED], 18h ; Allowed_FAIL+Allowed_RETRY
		call	GETBUFFR
		jb	short PopDone
		pop	si
		pop	ds
		les	di, [ss:CURBUF]
		or	byte [es:di+5], 4
		mov	bx, di
		lea	di, [di+14h]
		mov	al, 20h	; ' '
		mul	byte [si+1Fh]
		add	di, ax
		retn
; ---------------------------------------------------------------------------

PopDone:				; ...
		pop	di
		pop	es

PopDone_retn:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================

DOS_COMMIT:		; ...
		les	di, [THISSFT]
		mov	bx, [es:di+5]	; [ES:DI+SF_ENTRY.sf_flags]
		test	bx, 0C0h	; devid_file_clean+devid_device
		jnz	short PopDone_retn
		test	bx, 8000h	; sf_isnet
		jz	short LOCAL_COMMIT
		mov	ax, 1107h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - COMMIT REMOTE FILE
					; ES:DI	-> SFT
					; SFT DPB field	-> DPB of drive	containing file
					; Return: CF set on error, AX =	DOS error code
					; CF clear if successful
		retn
; ---------------------------------------------------------------------------

LOCAL_COMMIT:				; ...
		call	ECritDisk
		call	ECritDisk
		call	SetSFTTimes
		mov	ax, -1
		call	CloseEntry
		pushf
		call	DEV_OPEN_SFT
		popf
		call	LCritDisk

localcommit_retn:			; ...
		retn

; =============== S U B	R O U T	I N E =======================================

SetSFTTimes:	; ...
		test	bx, 0C0h	; devid_file_clean+devid_device
		jnz	short localcommit_retn
		test	bx, 4000h	; sf_close_nodate
		jnz	short localcommit_retn
		push	ax
		push	bx
		call	DATE16
		mov	[es:di+0Fh], ax	; [ES:DI+SF_ENTRY.sf_date]
		mov	[es:di+0Dh], dx	; [ES:DI+SF_ENTRY.sf_time]
		xor	ax, ax
		;call	dword [ShSU] ; call far [JShare+(14*4)]
		call	far [JShare+(14*4)]
		pop	bx
		pop	ax
		retn

; ---------------------------------------------------------------------------

DOS_MKDIR:				; ...
		call	TestNet
		jnb	short LOCAL_MKDIR
		mov	ax, 1103h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - MAKE	REMOTE DIRECTORY
					; SS = DOS CS
					; SDA first filename pointer ->	fully-qualified	directory name
					; SDA CDS pointer -> current directory
					; Return: CF set on error, AX =	DOS error code
					; CF clear if successful
		retn
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR DOS_CHDIR

NODEACCERRJ:				; ...
		mov	ax, 5		; error_access_denied

_BadRet:				; ...
		stc
		call	LCritDisk
		retn
; END OF FUNCTION CHUNK	FOR DOS_CHDIR
; ---------------------------------------------------------------------------

PATHNFJ:				; ...
		call	LCritDisk
		jmp	SET_MKND_ERR
; ---------------------------------------------------------------------------

LOCAL_MKDIR:				; ...
		call	ECritDisk
		mov	word [THISSFT+2], ss
		mov	word [THISSFT], RENBUF
		mov	word [RENBUF+33h], 0 ; [RENBUF+SF_ENTRY.sf_MFT]
		mov	al, 10h		; attr_directory
		call	MakeNode
		jb	short PATHNFJ
		cmp	ax, 3
		jz	short NODEACCERRJ
		les	bp, [THISDPB]
		lds	di, [CURBUF]
		sub	si, di
		push	si
		push	word [di+8]	; [DI+BUFFINFO.buf_sector+2]
		push	word [di+6]	; [DI+BUFFINFO.buf_sector]
		push	ss
		pop	ds
		push	word [DIRSTART]
		xor	ax, ax
		mov	[DIRSTART], ax
		call	NEWDIR
		jb	short NODEEXISTSPOPDEL
		call	GETENT
		jb	short NODEEXISTSPOPDEL
		les	di, [CURBUF]
		test	byte [es:di+5], 40h ; [ES:DI+BUFFINFO.buf_flags],
					; buf_dirty
		jnz	short yesdirty5
		call	INC_DIRTY_COUNT
		or	byte [es:di+5], 40h ; [ES:DI+BUFFINFO.buf_flags],buf_dirty

yesdirty5:				; ...
		add	di, 20		; BUFINSIZ
		mov	ax, 202Eh	; ". "
		mov	dx, [DIRSTART]
		call	SETDOTENT
		mov	ax, 2E2Eh	; ".."
		pop	dx
		call	SETDOTENT
		les	bp, [THISDPB]
		mov	byte [ALLOWED], 18h ; Allowed_FAIL+Allowed_RETRY
		pop	dx
		pop	word [HIGH_SECTOR]
		xor	al, al
		call	GETBUFFR
		jb	short NODEEXISTSP
		mov	dx, [DIRSTART]
		lds	di, [CURBUF]
		or	byte [di+5], 4
		pop	si
		add	si, di
		mov	[si], dx
		xor	dx, dx
		mov	[si+2],	dx
		mov	[si+4],	dx

; =============== S U B	R O U T	I N E =======================================

DIRUP:		; ...
		test	byte [di+5], 40h ; [DI+BUFFINFO.buf_flags],buf_dirty
		jnz	short yesdirty6
		call	INC_DIRTY_COUNT
		or	byte [di+5], 40h ; [DI+BUFFINFO.buf_flags],buf_dirty

yesdirty6:				; ...
		push	ss
		pop	ds
		mov	al, [es:bp+0]
		call	FLUSHBUF
		mov	ax, 5
		call	LCritDisk
		retn

; ---------------------------------------------------------------------------

NODEEXISTSPOPDEL:			; ...
		pop	dx
		pop	dx
		pop	word [HIGH_SECTOR]
		les	bp, [THISDPB]
		mov	byte [ALLOWED], 18h ; Allowed_FAIL+Allowed_RETRY
		xor	al, al
		call	GETBUFFR
		jb	short NODEEXISTSP
		lds	di, [5E2h]
		or	byte [di+5], 4
		pop	si
		add	si, di
		sub	si, 1Ah
		mov	byte [si], 0E5h
		call	DIRUP

NODEEXISTS:				; ...
		jmp	NODEACCERRJ
; ---------------------------------------------------------------------------

NODEEXISTSP:				; ...
		pop	si
		jmp	short NODEEXISTS

; =============== S U B	R O U T	I N E =======================================

DOS_CHDIR:		; ...

arg_7E		equ 80h

; FUNCTION CHUNK AT 6FD1 SIZE 00000008 BYTES
; FUNCTION CHUNK AT 713D SIZE 00000003 BYTES

		call	TestNet
		jnb	short LOCAL_CHDIR
		mov	ax, 1105h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - CHDIR
					; SS = DOS CS
					; SDA first filename pointer ->	fully-qualified	directory name
					; SDA CDS pointer -> current directory
					; Return: CF set on error, AX =	DOS error code
					; CF clear if successful
		retn
; ---------------------------------------------------------------------------

LOCAL_CHDIR:				; ...
		call	ECritDisk
		test	word [es:di+43h], 2000h ; [ES:DI+curdir.flags],curdir_splice
		jz	short nojoin
		mov	word [es:di+49h], 0FFFFh ; [ES:DI+curdir.ID]

nojoin:					; ...
		mov	byte [NoSetDir], 0
		mov	byte [SATTRIB], 16h ; attr_directory+attr_system+attr_hidden
		or	byte [FastOpenFlg], 1 ; FastOpen_Set
		call	GETPATH
		pushf
		and	byte [FastOpenFlg], 80h ; Fast_yes
		popf
		mov	ax, 3		; error_path_not_found
		jb	short ChDirDone
		jnz	short NOTDIRPATH
		mov	cx, [DIRSTART]
		clc

ChDirDone:				; ...
		call	LCritDisk
		retn

; ---------------------------------------------------------------------------

DOS_RMDIR:				; ...
		call	TestNet
		jnb	short LOCAL_RMDIR
		mov	ax, 1101h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - REMOVE REMOTE DIRECTORY
					; SS = DOS CS
					; SDA first filename pointer ->	fully-qualified	directory name
					; SDA CDS pointer -> current directory
					; Return: CF set on error, AX =	DOS error code
					; CF clear if successful
		retn
; ---------------------------------------------------------------------------

LOCAL_RMDIR:				; ...
		call	ECritDisk
		mov	byte [NoSetDir], 0
		mov	byte [SATTRIB], 16h ; attr_directory+attr_system+attr_hidden
		call	GETPATH
		jb	short NOPATH
		jnz	short NOTDIRPATH
		mov	di, [DIRSTART]
		or	di, di
		jnz	short rmdir_get_buf
		jmp	short NOTDIRPATH
; ---------------------------------------------------------------------------

NOPATH:					; ...
		mov	ax, 3		; error_path_not_found
		jmp	_BadRet
; ---------------------------------------------------------------------------

NOTDIRPATHPOP:				; ...
		pop	ax
		pop	ax

NOTDIRPATHPOP2:				; ...
		pop	ax
; START	OF FUNCTION CHUNK FOR DOS_CHDIR

NOTDIRPATH:				; ...
		jmp	NODEACCERRJ
; END OF FUNCTION CHUNK	FOR DOS_CHDIR
; ---------------------------------------------------------------------------

rmdir_get_buf:				; ...
		lds	di, [CURBUF]
		sub	bx, di
		push	bx
		push	word [di+8]	; [DI+BUFFINFO.buf_sector+2]
		push	word [di+6]	; [DI+BUFFINFO.buf_sector]
		push	ss
		pop	ds
		push	ss
		pop	es
		mov	di, NAME1
		mov	al, '?'
		mov	cx, 11
		rep stosb
		xor	al, al
		stosb
		call	STARTSRCH
		call	GETENTRY
		jb	short NOTDIRPATHPOP
		mov	ds, word [CURBUF+2]
		mov	si, bx
		lodsw
		cmp	ax, 202Eh	; (' ' SHL 8) OR '.'
		jnz	short NOTDIRPATHPOP
		add	si, 30		; dir_entry.size-2
		lodsw
		cmp	ax, 2E2Eh	; ('.' SHL 8) OR '.'
		jnz	short NOTDIRPATHPOP
		push	ss
		pop	ds
		mov	word [LASTENT], 2
		call	GETENTRY
		jb	short NOTDIRPATHPOP
		mov	byte [ATTRIB], 16h ; attr_directory+attr_hidden+attr_system
		call	SRCH
		jnb	short NOTDIRPATHPOP
		cmp	byte [FAILERR], 0
		jnz	short NOTDIRPATHPOP
		les	bp, [THISDPB]
		mov	bx, [DIRSTART]
		call	RELEASE
		jb	short NOTDIRPATHPOP
		pop	dx
		pop	word [HIGH_SECTOR]
		mov	byte [ALLOWED], 18h ; Allowed_FAIL+Allowed_RETRY
		xor	al, al
		call	GETBUFFR
		jb	short NOTDIRPATHPOP2
		lds	di, [5E2h]
		or	byte [di+5], 4
		pop	bx
		add	bx, di
		mov	byte [bx], 0E5h
		push	ds
		push	ss
		pop	ds
		call	FastOpen_Delete
		pop	ds
		jmp	DIRUP

; =============== S U B	R O U T	I N E =======================================

SWAPBACK:
		mov	byte [CONSWAP], 0
		retn

; =============== S U B	R O U T	I N E =======================================

SWAPCON:
		mov	byte [CONSWAP], 1
		push	ax
		mov	ax, word [THISSFT]
		mov	word [CONSFT], ax
		mov	ax, word [THISSFT+2]
		mov	word [CONSFT+2],	ax
		pop	ax
		retn

; =============== S U B	R O U T	I N E =======================================

DOS_READ:		; ...
		les	di, [THISSFT]
		mov	al, [es:di+2]	; [ES:DI+SF_ENTRY.sf_mode]
		and	al, 0Fh		; access_mask
		cmp	al, 1
		jnz	short READ_NO_MODE
		jmp	SET_ACC_ERR
; ---------------------------------------------------------------------------

READ_NO_MODE:				; ...
		call	SETUP
		jcxz	NoIORet
		call	IsSFTNet
		jz	short LOCAL_READ
		mov	ax, 1108h	; (MultNET<<8)|8
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - READ	FROM REMOTE FILE
					; ES:DI	-> SFT
					; SFT DPB field	-> DPB of drive	containing file
					; CX = number of bytes,	SS = DOS CS, SDA DTA field -> user buffer
					; Return: CF set on error, CX =	bytes read
		retn
; ---------------------------------------------------------------------------

NoIORet:				; ...
		clc
		retn
; ---------------------------------------------------------------------------

LOCAL_READ:				; ...
		test	byte [es:di+5], 80h	; [ES:DI+SF_ENTRY.sf_flags],devid_device
		jnz	short READDEV
		mov	byte [EXTERR_LOCUS], 2 ; errLOC_Disk
		call	ECritDisk
		call	DISKREAD
		call	LCritDisk
		retn
; ---------------------------------------------------------------------------

READDEV:				; ...
		mov	byte [EXTERR_LOCUS], 4 ; errLOC_SerDev
		mov	bl, [es:di+5]	; [ES:DI+SF_ENTRY.sf_flags]
		les	di, [DMAADD]
		test	bl, 40h		; devid_device_EOF
		jz	short ENDRDDEVJ3
		test	bl, 4		; devid_device_null
		jz	short TESTRAW
		xor	al, al

ENDRDDEVJ3:				; ...
		jmp	ENDRDDEVJ2
; ---------------------------------------------------------------------------

TESTRAW:				; ...
		test	bl, 20h		; devid_device_raw
		jnz	short DVRDRAW
		test	bl, 1
		jz	short NOTRDCON
		jmp	READCON
; ---------------------------------------------------------------------------

DVRDRAW:				; ...
		push	es
		pop	ds
		test	byte [ss:IsWin386], 1
		jz	short ReadRawRetry
		test	bl, 1		; devid_device_con_in
		jz	short ReadRawRetry
		jmp	do_polling
; ---------------------------------------------------------------------------

ReadRawRetry:				; ...
		mov	bx, di
		xor	ax, ax
		mov	dx, ax
		call	SETREAD
		push	ds
		lds	si, [ss:THISSFT]
		call	DEVIOCALL
		mov	dx, di
		mov	ah, 86h
		mov	di, [ss:DEVCALL_REQSTAT]
		or	di, di
		jns	short CRDROK
		call	CHARHARD
		mov	di, dx
		add	di, [ss:CALLSCNT]
		sub	cx, [ss:CALLSCNT]
		or	al, al
		jz	short CRDROK
		cmp	al, 3
		jz	short CRDFERR
		pop	ds
		jmp	short ReadRawRetry
; ---------------------------------------------------------------------------

CRDFERR:				; ...
		pop	di

DEVIOFERR:				; ...
		les	di, [ss:THISSFT]
		jmp	SET_ACC_ERR_DS
; ---------------------------------------------------------------------------

CRDROK:					; ...
		pop	di
		mov	di, dx
		add	di, [ss:CALLSCNT]
		jmp	short ENDRDDEVJ3
; ---------------------------------------------------------------------------

NOTRDCON:				; ...
		mov	ax, es
		mov	ds, ax
		mov	bx, di
		xor	dx, dx
		mov	ax, dx
		push	cx
		mov	cx, 1
		call	SETREAD
		pop	cx
		lds	si, [ss:THISSFT]
		lds	si, [si+7]	; [SI+SF_ENTRY.sf_devptr]

DVRDLP:					; ...
		call	DSKSTATCHK
		call	DEVIOCALL2
		push	di
		mov	ah, 86h
		mov	di, [ss:DEVCALL_REQSTAT]
		or	di, di
		jns	short CRDOK
		call	CHARHARD
		pop	di
		mov	word [ss:CALLSCNT], 1
		cmp	al, 1
		jz	short DVRDLP
		cmp	al, 3
		jz	short DEVIOFERR
		xor	al, al
		jmp	short DVRDIGN
; ---------------------------------------------------------------------------

CRDOK:					; ...
		pop	di
		cmp	word [ss:CALLSCNT], 1
		jnz	short ENDRDDEVJ2
		push	ds
		mov	ds, word [ss:CALLXADD+2]
		mov	al, [di]
		pop	ds

DVRDIGN:				; ...
		inc	word [ss:CALLXADD]
		mov	word [ss:DEVCALL_REQSTAT], 0
		inc	di
		cmp	al, 1Ah		; ^Z?
		jz	short ENDRDDEVJ2
		cmp	al, 0Dh		; c_CR
		loopne	DVRDLP
		inc	ax

ENDRDDEVJ2:				; ...
		jmp	ENDRDDEV
; ---------------------------------------------------------------------------

do_polling:				; ...
		mov	bx, di
		xor	ax, ax
		mov	dx, ax
		call	SETREAD

do_io:					; ...
		mov	byte [es:bx+2], 5 ;	DEVRDND
		push	ds
		lds	si, [ss:THISSFT]
		call	DEVIOCALL
		pop	ds
		test	word [es:bx+3], 8000h ; [es:bx+SRHEAD.REQSTAT],STERR
		jz	short check_busy
		push	ds
		mov	dx, di
		call	CHARHARD
		mov	di, dx
		or	al, al
		jz	short pop_done_read
		cmp	al, 3
		jz	short devrderr
		pop	ds
		jmp	short do_io
; ---------------------------------------------------------------------------

check_busy:				; ...
		test	word [es:bx+3], 200h ; [es:bx+SRHEAD.REQSTAT]
		jnz	short no_char
		mov	byte [es:bx+2], 4 ;	DEVRD
		mov	word [es:bx+12h], 1
		push	ds
		lds	si, [ss:THISSFT]
		call	DEVIOCALL
		mov	dx, di
		mov	ah, 86h
		mov	di, [es:bx+3]
		test	di, 8000h	; STERR
		jz	short next_char
		call	CHARHARD
		mov	di, dx
		or	al, al
		jz	short pop_done_read
		cmp	al, 3
		jz	short devrderr
		pop	ds
		jmp	short do_io
; ---------------------------------------------------------------------------

next_char:				; ...
		pop	ds
		mov	di, dx
		dec	cx
		jcxz	done_read
		inc	word [es:bx+14]
		jmp	short do_io
; ---------------------------------------------------------------------------

devrderr:				; ...
		pop	di
		les	di, [ss:THISSFT]
		jmp	SET_ACC_ERR_DS
; ---------------------------------------------------------------------------

no_char:				; ...
		push	ax
		mov	ah, 84h
		int	2Ah		; Microsoft Networks - KEYBOARD	BUSY LOOP
		pop	ax
		jmp	do_io
; ---------------------------------------------------------------------------

pop_done_read:				; ...
		pop	ds

done_read:				; ...
		add	di, [ss:CALLSCNT]
		jmp	ENDRDDEVJ3
; ---------------------------------------------------------------------------

TRANBUF:				; ...
		lodsb
		stosb
		cmp	al, 0Dh		; c_CR
		jnz	short NORMCH
		mov	byte [si], 0Ah ; c_LF

NORMCH:					; ...
		cmp	al, 0Ah		; c_LF
		loopne	TRANBUF
		jnz	short ENDRDCON
		xor	si, si
		call	OUTT
		or	al, 1

ENDRDCON:				; ...
		push	ss
		pop	ds
		call	SWAPBACK
		mov	[CONTPOS], si

ENDRDDEV:				; ...
		push	ss
		pop	ds
		mov	[NEXTADD], di
		jnz	short SETSFTC
		les	di, [THISSFT]
		and	byte [es:di+5], 0BFh ; [ES:DI+SF_ENTRY.sf_flags],
					; ~devid_device_EOF

SETSFTC:				; ...
		call	SETSFT
		retn
; ---------------------------------------------------------------------------

READCON:				; ...
		call	SWAPCON
		mov	si, [CONTPOS]
		or	si, si
		jnz	short TRANBUF
		cmp	byte [CONBUF], 128 ; 80h
		jz	short GETBUF
		mov	word [CONBUF], 0FF80h

GETBUF:					; ...
		push	cx
		push	es
		push	di
		mov	dx, CONBUF
		call	_$STD_CON_STRING_INPUT
		pop	di
		pop	es
		pop	cx
		mov	si, CONBUF+2
		cmp	byte [si], 1Ah
		jnz	short TRANBUF
		mov	al, 1Ah
		stosb
		dec	di
		mov	al, 0Ah		; c_LF
		call	OUTT
		xor	si, si
		jmp	short ENDRDCON

; =============== S U B	R O U T	I N E =======================================

DOS_WRITE:		; ...
		les	di, [THISSFT]
		mov	al, [es:di+2]	; [ES:DI+SF_ENTRY.sf_mode]
		and	al, 0Fh		; access_mask
		cmp	al, 0		; open_for_read
		jnz	short Check_FCB_RO

BadMode:				; ...
		jmp	SET_ACC_ERR
; ---------------------------------------------------------------------------

Check_FCB_RO:				; ...
		test	byte [es:di+3], 80h	; [ES:DI+SF_ENTRY.sf_mode+1],(sf_isFCB>>8)
		jz	short WRITE_NO_MODE
		test	byte [es:di+4], 1 ;	[ES:DI+SF_ENTRY.sf_attr],attr_read_only
		jnz	short BadMode

WRITE_NO_MODE:				; ...
		call	SETUP
		call	IsSFTNet
		jz	short LOCAL_WRITE
		mov	ax, 1109h	; (MultNET<<8)|9
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - WRITE TO REMOTE FILE
					; ES:DI	-> SFT
					; SFT DPB field	-> DPB of drive	containing file
					; CX = number of bytes,	SS = DOS CS, SDA DTA field -> user buffer
					; Return: CF set on error, CX =	bytes written
		retn
; ---------------------------------------------------------------------------

LOCAL_WRITE:				; ...
		test	byte [es:di+5], 80h	; [ES:DI+SF_ENTRY.sf_flags],
					; devid_device
		jnz	short WRTDEV
		mov	byte [EXTERR_LOCUS], 2
		call	ECritDisk
		call	DISKWRITE
		jb	short nocommit
		les	di, [THISSFT]
		test	byte [es:di+3], 40h	; [ES:DI+SF_ENTRY.sf_mode],
					; auto_commit_write
		jz	short nocommit
		push	cx
		call	DOS_COMMIT
		pop	cx

nocommit:				; ...
		call	LCritDisk
		retn
; ---------------------------------------------------------------------------

DVWRTRAW:				; ...
		xor	ax, ax
		call	SETWRITE
		push	ds
		lds	si, [ss:THISSFT]
		call	DEVIOCALL
		mov	dx, di
		mov	ah, 87h
		mov	di, [ss:DEVCALL_REQSTAT]
		or	di, di
		jns	short CWRTROK
		call	CHARHARD
		sub	cx, [ss:CALLSCNT]
		mov	bx, dx
		add	bx, [ss:CALLSCNT]
		mov	di, bx
		or	al, al
		jz	short CWRTROK
		cmp	al, 3
		jz	short CWRFERR
		pop	ds
		jmp	short DVWRTRAW
; ---------------------------------------------------------------------------

CWRFERR:				; ...
		pop	ax
		jmp	CRDFERR
; ---------------------------------------------------------------------------

CWRTROK:				; ...
		pop	ax
		pop	ds
		mov	ax, [CALLSCNT]

ENDWRDEV:				; ...
		les	di, [THISSFT]
		mov	cx, ax
		call	ADDREC
		retn
; ---------------------------------------------------------------------------

WRTNUL:					; ...
		mov	dx, cx

WRTCOOKJ:				; ...
		jmp	WRTCOOKDONE
; ---------------------------------------------------------------------------

WRTDEV:					; ...
		mov	byte [EXTERR_LOCUS], 4 ; errLOC_SerDev
		or	byte [es:di+5], 40h ; [ES:DI+SF_ENTRY.sf_flags],
					; devid_device_EOF
		mov	bl, [es:di+5]	; [ES:DI+SF_ENTRY.sf_flags]
		xor	ax, ax
		jcxz	ENDWRDEV
		push	ds
		mov	al, bl
		lds	bx, [DMAADD]
		mov	di, bx
		xor	dx, dx
		test	al, 20h		; devid_device_raw
		jz	short TEST_DEV_CON
		jmp	short DVWRTRAW
; ---------------------------------------------------------------------------

TEST_DEV_CON:				; ...
		test	al, 2		; devid_device_con_out
		jnz	short WRITECON
		test	al, 4		; devid_device_null
		jnz	short WRTNUL
		mov	ax, dx
		cmp	byte [bx], 1Ah ; ^Z?
		jz	short WRTCOOKJ
		push	cx
		mov	cx, 1
		call	SETWRITE
		pop	cx
		lds	si, [ss:THISSFT]
		lds	si, [si+7]	; [SI+SF_ENTRY.sf_devptr]

DVWRTLP:				; ...
		call	DSKSTATCHK
		call	DEVIOCALL2
		push	di
		mov	ah, 87h
		mov	di, [ss:DEVCALL_REQSTAT]
		or	di, di
		jns	short CWROK
		call	CHARHARD
		pop	di
		mov	word [ss:CALLSCNT], 1
		cmp	al, 1
		jz	short DVWRTLP
		or	al, al
		jz	short DVWRTIGN
		jmp	CRDFERR
; ---------------------------------------------------------------------------

CWROK:					; ...
		pop	di
		cmp	word [ss:CALLSCNT], 0
		jz	short WRTCOOKDONE

DVWRTIGN:				; ...
		inc	dx
		inc	word [ss:CALLXADD]
		inc	di
		push	ds
		mov	ds, word [ss:CALLXADD+2]
		cmp	byte [di], 1Ah ; ^Z?
		pop	ds
		jz	short WRTCOOKDONE
		mov	word [ss:DEVCALL_REQSTAT], 0
		loop	DVWRTLP

WRTCOOKDONE:				; ...
		mov	ax, dx
		pop	ds
		jmp	ENDWRDEV
; ---------------------------------------------------------------------------

WRITECON:				; ...
		push	ds
		push	ss
		pop	ds
		call	SWAPCON
		pop	ds
		mov	si, bx
		push	cx

WRCONLP:				; ...
		lodsb
		cmp	al, 1Ah		; ^Z?
		jz	short CONEOF
		call	OUTT
		loop	WRCONLP

CONEOF:					; ...
		pop	ax
		sub	ax, cx
		pop	ds
		call	SWAPBACK
		jmp	ENDWRDEV

; =============== S U B	R O U T	I N E =======================================

GET_IO_SFT:
		cmp	byte [ss:CONSWAP], 0
		jnz	short GetRedir

GetNormal:				; ...
		push	ss
		pop	ds
		push	es
		push	di
		call	SFFromHandle
		jb	short RET44P
		mov	si, es
		mov	ds, si
		mov	si, di

RET44P:					; ...
		pop	di
		pop	es
		retn
; ---------------------------------------------------------------------------

GetRedir:				; ...
		cmp	bx, 1
		ja	short GetNormal
		lds	si, [ss:CONSFT]
		clc

get_io_sft_retn:			; ...
		retn

; =============== S U B	R O U T	I N E =======================================

DIRREAD:
		xor	dx, dx
		cmp	word [DIRSTART], 0
		jnz	short SubDir
		xchg	ax, dx
		jmp	short DoRead
; ---------------------------------------------------------------------------

SubDir:					; ...
		mov	dl, al
		and	dl, [es:bp+4]	; [ES:BP+DPB.CLUSTER_MASK]
		mov	cl, [es:bp+5]	; [ES:BP+DPB.CLUSTER_SHIFT]
		shr	ax, cl

DoRead:					; ...
		mov	[SECCLUSPOS], dl
		mov	cx, ax
		mov	ah, dl
		mov	dx, word [DIRSEC+2]
		mov	word [HIGH_SECTOR], dx
		mov	dx, word [DIRSEC]
		add	dl, ah
		adc	dh, 0
		adc	word [HIGH_SECTOR], 0
		mov	bx, [CLUSNUM]
		mov	[NXTCLUSNUM], bx
		jcxz	FIRSTCLUSTER

SKPCLLP:				; ...
		call	UNPACK
		jb	short get_io_sft_retn
		xchg	bx, di
		call	IsEOF
		jnb	short HAVESKIPPED
		loop	SKPCLLP

HAVESKIPPED:				; ...
		mov	[NXTCLUSNUM], bx
		mov	dx, di
		mov	bl, ah
		call	FIGREC

FIRSTCLUSTER:				; ...
		mov	byte [ALLOWED], 18h ; Allowed_RETRY+Allowed_FAIL
		xor	al, al
		call	GETBUFFR
		jb	short get_io_sft_retn

SET_BUF_AS_DIR:				; ...
		push	ds
		push	si
		lds	si, [CURBUF]
		or	byte [si+5], 4 ; [SI+BUFFINFO.buf_flags],buf_isDIR
		pop	si
		pop	ds

dirread_retn:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================

FATSECRD:		; ...
		mov	byte [ss:ALLOWED], 18h ; Allowed_RETRY+Allowed_FAIL
		mov	di, cx
		mov	cl, [es:bp+8]	; [ES:BP+DPB.FAT_COUNT]
		mov	ax, [es:bp+0Fh]	; [ES:BP+DPB.FAT_SIZE]
		xor	ch, ch
		push	dx

NXTFAT:					; ...
		mov	word [ss:HIGH_SECTOR], 0
		push	cx
		push	ax
		mov	cx, di
		call	DSKREAD
		pop	ax
		pop	cx
		jz	short RET41P
		add	dx, ax
		loop	NXTFAT
		pop	dx
		mov	cx, di

DREAD:					; ...
		call	DSKREAD
		jz	short dirread_retn
		mov	byte [ss:READOP], 0
		call	HARDERRRW
		cmp	al, 1
		jz	short DREAD
		cmp	al, 3
		clc
		jnz	short NO_CAR
		stc

NO_CAR:					; ...
		retn
; ---------------------------------------------------------------------------

RET41P:					; ...
		pop	dx
		retn

; =============== S U B	R O U T	I N E =======================================

CHECK_WRITE_LOCK:	; ...
		test	byte [es:di+4], 8 ;	[ES:DI+SF_ENTRY.sf_attr],
					; attr_volume_id
		jz	short write_cont
		call	SET_ACC_ERR_DS
		retn
; ---------------------------------------------------------------------------

write_cont:				; ...
		push	cx
		or	cx, cx
		jnz	short Not_Truncate
		dec	cx

Not_Truncate:				; ...
		mov	al, 80h
		call	LOCK_CHECK
		pop	cx
		jnb	short WRITE_OK
		call	WRITE_LOCK_VIOLATION
		jnb	short write_cont

WRITE_OK:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================

CHECK_READ_LOCK:
		test	byte [es:di+4], 8 ;	[ES:DI+SF_ENTRY.sf_attr],
					; attr_volume_id
		jz	short do_retry
		call	SET_ACC_ERR
		retn
; ---------------------------------------------------------------------------

do_retry:				; ...
		xor	al, al
		call	LOCK_CHECK
		jnb	short READLOCK_OK
		call	READ_LOCK_VIOLATION
		jnb	short do_retry

READLOCK_OK:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================

DSKREAD:
		push	cx
		mov	ah, [es:bp+17h]	; [ES:BP+DPB.MEDIA]
		mov	al, [es:bp+1]	; [ES:BP+DPB.UNIT]
		push	bx
		push	es
		call	SETREAD
		jmp	short DODSKOP

; =============== S U B	R O U T	I N E =======================================

DWRITE:		; ...
		call	DSKWRITE
		jz	short dw_ret_label
		mov	byte [ss:READOP], 1
		call	HARDERRRW
		cmp	al, 1
		jz	short DWRITE
		cmp	al, 3
		clc
		jnz	short dw_ret_label ; NO_CAR2
		stc

dw_ret_label:				; ...
		retn			; NO_CAR2

; =============== S U B	R O U T	I N E =======================================

DSKWRITE:		; ...
		push	cx
		mov	ah, [es:bp+17h]	; [ES:BP+DPB.MEDIA]
		mov	al, [es:bp+1]	; [ES:BP+DPB.UNIT]
		push	bx
		push	es
		call	SETWRITE

DODSKOP:				; ...
		mov	cx, ds
		pop	ds
		push	ds
		lds	si, [ds:bp+13h]	; LDS SI,[BP+DPB.DRIVER_ADDR]
		call	DEVIOCALL2
		mov	ds, cx
		pop	es
		pop	bx
		mov	cx, [ss:CALLSCNT]
		pop	di
		sub	cx, di
		neg	cx
		mov	ax, [ss:DEVCALL_REQSTAT]
		test	ax, 8000h	; STERR
		retn

; =============== S U B	R O U T	I N E =======================================

HARDERRRW:		; ...
		cmp	al, 0Fh		; error_I24_wrong_disk
		jnz	short DO_ERR
		push	ax
		mov	ax, word [ss:CALLVIDRW]
		mov	word [ss:EXTERRPT],	ax
		mov	ax, word [ss:CALLVIDRW+2]
		mov	word [ss:EXTERRPT+2], ax
		pop	ax

DO_ERR:					; ...
		call	HARDERR
		retn

; ---------------------------------------------------------------------------

SETUP:					; ...
		lds	si, [es:di+7]	; [ES:DI+SF_ENTRY.sf_devptr]
		mov	word [ss:THISDPB+2], ds
		push	ss
		pop	ds
		mov	word [THISDPB], si
		mov	bx, word [DMAADD]
		mov	[NEXTADD], bx
		mov	byte [TRANS], 0
		mov	ax, [es:di+15h]	; [ES:DI+SF_ENTRY.sf_position]
		mov	dx, [es:di+17h]	; [ES:DI+SF_ENTRY.sf_position+2]
		mov	word [BYTPOS+2], dx
		mov	word [BYTPOS], ax
		test	word [es:di+5], 8080h ; [ES:DI+SF_ENTRY.sf_flags],
					; sf_isnet+devid_device
		jnz	short NOSETSTUFF
		push	es
		les	bp, [THISDPB]
		mov	bl, [es:bp+0]	; [ES:BP+DPB.drive]
		mov	[THISDRV], bl
		mov	bx, [es:bp+2]	; [ES:BP+DPB.SECTOR_SIZE]
		push	cx
		call	DIV32
		mov	[BYTSECPOS],	dx
		mov	word [SECPOS], ax
		mov	word [SECPOS+2],	cx
		mov	dx, cx
		mov	bx, ax
		and	bl, [es:bp+4]	; [ES:BP+DPB.CLUSTER_MASK]
		mov	[SECCLUSPOS], bl
		call	SHR32
		pop	cx
		jnz	short EOFERR
		cmp	ax, [es:bp+0Dh]	; [ES:BP+DPB.MAX_CLUSTER]
		ja	short EOFERR
		mov	[CLUSNUM], ax
		pop	es

NOSETSTUFF:				; ...
		mov	ax, cx
		add	ax, word [DMAADD]
		jnb	short setup_OK
		mov	ax, word [DMAADD]
		neg	ax
		jnz	short NoDec
		dec	ax

NoDec:					; ...
		mov	cx, ax
		jcxz	NOROOM

setup_OK:				; ...
		retn
; ---------------------------------------------------------------------------

EOFERR:					; ...
		pop	es
		xor	cx, cx

NOROOM:					; ...
		pop	bx
		clc
		retn

; =============== S U B	R O U T	I N E =======================================

BREAKDOWN:		; ...
		mov	ax, [BYTSECPOS]
		mov	bx, cx
		or	ax, ax
		jz	short SAVFIR
		sub	ax, [es:bp+2]	; [ES:BP+DPB.SECTOR_SIZE]
		neg	ax
		sub	bx, ax
		jnb	short SAVFIR
		add	ax, bx
		xor	bx, bx

SAVFIR:					; ...
		mov	[BYTCNT1], ax
		mov	ax, bx
		xor	dx, dx
		div	word [es:bp+2] ; [ES:BP+DPB.SECTOR_SIZE]
		mov	[SECCNT], ax
		mov	[BYTCNT2], dx

_RET45:					; ...
		retn

; =============== S U B	R O U T	I N E =======================================

READ_LOCK_VIOLATION: ; ...
		mov	byte [READOP], 0

ERR_ON_CHECK:				; ...
		test	byte [es:di+3], 80h	; [ES:DI+SF_ENTRY.sf_mode+1],
					; (sf_isFCB>>8)
		jnz	short HARD_ERR
		push	cx
		mov	cl, [es:di+2]	; [ES:DI+SF_ENTRY.sf_mode]
		and	cl, 0F0h	; SHARING_MASK
		cmp	cl, 0		; SHARING_COMPAT
		pop	cx
		jnz	short NO_HARD_ERR

HARD_ERR:				; ...
		call	LOCK_VIOLATION
		jnb	short _RET45

NO_HARD_ERR:				; ...
		xor	cx, cx
		mov	ax, 21h		; error_lock_violation
		stc
		retn

; =============== S U B	R O U T	I N E =======================================

WRITE_LOCK_VIOLATION: ; ...
		mov	byte [READOP], 1
		jmp	short ERR_ON_CHECK

; ---------------------------------------------------------------------------

DISKREAD:				; ...
		mov	ax, [es:di+11h]	; [ES:DI+SF_ENTRY.sf_size]
		mov	bx, [es:di+13h]	; [ES:DI+SF_ENTRY.sf_size+2]
		sub	ax, word [BYTPOS]
		sbb	bx, word [BYTPOS+2]
		jb	short RDERR
		jnz	short ENUF
		or	ax, ax
		jz	short RDERR
		cmp	ax, cx
		jnb	short ENUF
		mov	cx, ax

ENUF:					; ...
		call	CHECK_READ_LOCK
		jnb	short _READ_OK
		retn
; ---------------------------------------------------------------------------

_READ_OK:				; ...
		les	bp, [THISDPB]
		call	BREAKDOWN
		mov	cx, [CLUSNUM]
		call	FNDCLUS
		jb	short SET_ACC_ERR_DS
		or	cx, cx
		jz	short SKIPERR

RDERR:					; ...
		mov	ah, 0Eh
		jmp	WRTERR22
; ---------------------------------------------------------------------------

SETSFTJ2:				; ...
		jmp	SETSFT
; ---------------------------------------------------------------------------

CANOT_READ:				; ...
		pop	cx
		pop	bx

SET_ACC_ERR_DS:				; ...
		push	ss
		pop	ds

SET_ACC_ERR:				; ...
		xor	cx, cx
		mov	ax, 5		; error_access_denied
		stc
		retn
; ---------------------------------------------------------------------------

SKIPERR:				; ...
		mov	[LASTPOS], dx
		mov	[CLUSNUM], bx
		cmp	word [BYTCNT1], 0
		jz	short RDMID
		call	BUFRD
; ---------------------------------------------------------------------------
		jb	short SET_ACC_ERR_DS

RDMID:					; ...
		cmp	word [SECCNT], 0
		jz	short RDLAST
		call	NEXTSEC
		jb	short SETSFTJ2
		mov	byte [TRANS], 1
		mov	dl, [SECCLUSPOS]
		mov	cx, [SECCNT]
		mov	bx, [CLUSNUM]

RDLP:					; ...
		call	OPTIMIZE
		jb	short SET_ACC_ERR_DS
		push	di
		push	ax
		push	bx
		mov	byte [ALLOWED], 38h ; Allowed_RETRY+Allowed_FAIL+Allowed_IGNORE
		mov	ds, word [DMAADD+2]
		push	dx
		push	cx
		call	SET_RQ_SC_PARMS
		call	DREAD
		pop	cx
		pop	dx
		pop	word [ss:TEMP_VAR]
		jb	short CANOT_READ
		mov	[ss:TEMP_VAR2],	ds
		call	DskRdBufScan
		push	ss
		pop	ds
		pop	cx
		pop	bx
		jcxz	RDLAST
		call	IsEOF
		jnb	short SETSFT
		mov	dl, 0
		inc	word [LASTPOS]
		jmp	short RDLP
; ---------------------------------------------------------------------------

RDLAST:					; ...
		mov	ax, [BYTCNT2]
		or	ax, ax
		jz	short SETSFT
		mov	[BYTCNT1], ax
		call	NEXTSEC
		jb	short SETSFT
		mov	word [BYTSECPOS], 0
		call	BUFRD
		jnb	short SETSFT
		jmp	SET_ACC_ERR_DS

; =============== S U B	R O U T	I N E =======================================

SETSFT:		; ...
		les	di, [THISSFT]

SETCLUS:				; ...
		mov	cx, [NEXTADD]
		sub	cx, word [DMAADD]
		test	byte [es:di+5], 80h	; [ES:DI+SF_ENTRY.sf_flags],
					; devid_device
		jnz	short ADDREC
		mov	ax, [CLUSNUM]
		mov	[es:di+35h], ax	; [ES:DI+SF_ENTRY.sf_lstclus]
		mov	ax, [LASTPOS]
		mov	[es:di+19h], ax	; [ES:DI+SF_ENTRY.sf_cluspos]

ADDREC:					; ...
		jcxz	RET28
		add	[es:di+15h], cx	; [ES:DI+SF_ENTRY.sf_position]
		adc	word [es:di+17h], 0	; [ES:DI+SF_ENTRY.sf_position+2]

RET28:					; ...
		clc
		retn

; =============== S U B	R O U T	I N E =======================================

DskRdBufScan:	; ...
		cmp	word [ss:DirtyBufferCount], 0
		jz	short bufx
		mov	bx, [ss:HIGH_SECTOR]
		mov	si, bx
		add	cx, dx
		adc	si, 0
		call	GETCURHEAD
		mov	ax, [di+2]	; [di+BUFFINFO.buf_prev]
		mov	[ss:FIRST_BUFF_ADDR], ax
		mov	al, [es:bp+0]

bufq:					; ...
		cmp	al, [di+4]	; [di+BUFFINFO.buf_ID]
		jnz	short bufq1
		cmp	bx, [di+8]	; [di+BUFFINFO.buf_sector+2]
		jnz	short bufq01
		cmp	dx, [di+6]	; [di+BUFFINFO.buf_sector]

bufq01:					; ...
		ja	short bufq1
		cmp	si, [di+8]
		jnz	short bufq02
		cmp	cx, [di+6]

bufq02:					; ...
		ja	short bufq2

bufq1:					; ...
		cmp	di, [ss:FIRST_BUFF_ADDR]
		mov	di, [di]	; [di+BUFFINFO.buf_next]
		jnz	short bufq

bufx:					; ...
		retn
; ---------------------------------------------------------------------------

bufq2:					; ...
		push	ax
		test	byte [di+5], 40h ; [di+BUFFINFO.buf_flags],
					; buf_dirty
		jz	short bufq3
		push	cx
		push	dx
		push	si
		push	di
		push	es
		mov	ax, dx
		sub	ax, [di+6]	; [di+BUFFINFO.buf_sector]
		neg	ax
		lea	si, [di+20]	; [di+BUFINSIZ]
		mov	cx, [es:bp+2]	; [es:bp+DPB.SECTOR_SIZE]
		mul	cx
		mov	di, [ss:TEMP_VAR]
		add	di, ax
		mov	es, [ss:TEMP_VAR2]
		shr	cx, 1
		rep movsw
		adc	cx, 0
		rep movsb
		pop	es
		pop	di
		pop	si
		pop	dx
		pop	cx

bufq3:					; ...
		mov	ax, di
		call	SCANPLACE
		cmp	ax, [ss:FIRST_BUFF_ADDR]
		pop	ax
		jnz	short bufq
		jmp	short bufx

; =============== S U B	R O U T	I N E =======================================

DISKWRITE:		; ...
		call	CHECK_WRITE_LOCK
		jnb	short _WRITE_OK
		retn
; ---------------------------------------------------------------------------

WRTEOFJ:				; ...
		jmp	WRTEOF
; ---------------------------------------------------------------------------

_WRITE_OK:				; ...
		and	word [es:di+5], 0BFBFh ; [ES:DI+SF_ENTRY.sf_flags],
					; ~(sf_close_nodate|devid_file_clean)
		mov	ax, [es:di+11h]	; [ES:DI+SF_ENTRY.sf_size]
		mov	[TEMP_VAR], ax
		mov	ax, [es:di+13h]	; [ES:DI+SF_ENTRY.sf_size+2]
		mov	[TEMP_VAR2],	ax
		les	bp, [THISDPB]
		call	BREAKDOWN
		mov	ax, word [BYTPOS]
		mov	dx, word [BYTPOS+2]
		jcxz	WRTEOFJ
		add	ax, cx
		adc	dx, 0
		mov	bx, [es:bp+2]	; [ES:BP+DPB.SECTOR_SIZE]
		call	DIV32
		mov	si, ax
		mov	word [HIGH_SECTOR], cx
		or	dx, dx
		push	dx
		mov	dx, cx
		jnz	short CALCLUS
		sub	ax, 1
		sbb	dx, 0

CALCLUS:				; ...
		call	SHR32
		pop	dx
		push	ax
		push	dx
		mov	dx, [TEMP_VAR2]
		mov	ax, [TEMP_VAR]
		call	DIV32
		mov	[TEMP_VAR2],	cx
		mov	word [VALSEC+2],	cx
		mov	cx, ax
		mov	bx, si
		or	dx, dx
		jz	short NORND
		add	ax, 1
		adc	word [VALSEC+2],	0

NORND:					; ...
		mov	word [VALSEC], ax
		xor	ax, ax
		mov	word [GROWCNT], ax
		mov	word [GROWCNT+2], ax
		pop	ax
		mov	di, [HIGH_SECTOR]
		cmp	di, [TEMP_VAR2]
		jb	short NOGROW
		jz	short lowsec
		sub	bx, cx
		sbb	di, [TEMP_VAR2]
		jmp	short yesgrow
; ---------------------------------------------------------------------------

lowsec:					; ...
		mov	di, 0
		sub	bx, cx
		jb	short NOGROW
		jz	short TESTTAIL

yesgrow:				; ...
		mov	cx, dx
		xchg	ax, bx
		mul	word [es:bp+2] ; [ES:BP+DPB.SECTOR_SIZE]
		mov	word [HIGH_SECTOR], dx
		mov	[TEMP_VAR2],	ax
		mov	ax, di
		mul	word [es:bp+2] ; [ES:BP+DPB.SECTOR_SIZE]
		add	ax, [HIGH_SECTOR]
		mov	dx, ax
		mov	ax, [TEMP_VAR2]
		sub	ax, cx
		sbb	dx, 0
		add	ax, bx
		adc	dx, 0
		jmp	short SETGRW
; ---------------------------------------------------------------------------

HAVSTART:				; ...
		mov	cx, ax
		call	SKPCLP
		jcxz	DOWRTJ
		call	ALLOCATE
		jnb	short DOWRTJ

WRTERR:					; ...
		mov	ah, 0Fh

WRTERR22:				; ...
		mov	al, [THISDRV]
		xor	cx, cx
		les	di, [THISSFT]
		clc
		retn
; ---------------------------------------------------------------------------

DOWRTJ:					; ...
		jmp	short DOWRT
; ---------------------------------------------------------------------------

ACC_ERRWJ:				; ...
		jmp	SET_ACC_ERRW
; ---------------------------------------------------------------------------

TESTTAIL:				; ...
		sub	ax, dx
		jbe	short NOGROW
		xor	dx, dx

SETGRW:					; ...
		mov	word [GROWCNT], ax
		mov	word [GROWCNT+2], dx

NOGROW:					; ...
		pop	ax
		mov	cx, [CLUSNUM]
		call	FNDCLUS
		jb	short ACC_ERRWJ
		mov	[CLUSNUM], bx
		mov	[LASTPOS], dx
		sub	ax, dx
		jz	short DOWRT
		jcxz	HAVSTART
		push	cx
		mov	cx, ax
		call	ALLOCATE
		pop	cx
		jb	short WRTERR
		mov	dx, [LASTPOS]
		inc	dx
		dec	cx
		jz	short NOSKIP
		call	SKPCLP
		jb	short ACC_ERRWJ

NOSKIP:					; ...
		mov	[CLUSNUM], bx
		mov	[LASTPOS], dx

DOWRT:					; ...
		cmp	word [BYTCNT1], 0
		jz	short WRTMID
		mov	bx, [CLUSNUM]
		call	BUFWRT
		jb	short ACC_ERRWJ

WRTMID:					; ...
		mov	ax, [SECCNT]
		or	ax, ax
		jz	short WRTLAST
		add	word [SECPOS], ax
		adc	word [SECPOS+2], 0
		call	NEXTSEC
		jb	short SET_ACC_ERRW
		mov	byte [TRANS], 1
		mov	dl, [SECCLUSPOS]
		mov	bx, [CLUSNUM]
		mov	cx, [SECCNT]

WRTLP:					; ...
		call	OPTIMIZE
		jb	short SET_ACC_ERRW
		push	di
		push	ax
		call	DskWrtBufPurge
		mov	ds, word [ss:DMAADD+2]
		mov	byte [ss:ALLOWED], 38h ; Allowed_RETRY+Allowed_FAIL+Allowed_IGNORE
		call	DWRITE
		pop	cx
		pop	bx
		push	ss
		pop	ds
		jb	short SET_ACC_ERRW
		jcxz	WRTLAST
		mov	dl, 0
		inc	word [LASTPOS]
		jmp	short WRTLP
; ---------------------------------------------------------------------------

WRTLAST:				; ...
		mov	ax, [BYTCNT2]
		or	ax, ax
		jz	short FINWRT
		mov	[BYTCNT1], ax
		call	NEXTSEC
		jb	short SET_ACC_ERRW
		mov	word [BYTSECPOS], 0
		call	BUFWRT
		jb	short SET_ACC_ERRW

FINWRT:					; ...
		les	di, [THISSFT]
		mov	ax, word [GROWCNT]
		mov	cx, word [GROWCNT+2]
		or	ax, ax
		jnz	short UPDATE_size
		jcxz	SAMSIZ

UPDATE_size:				; ...
		add	[es:di+11h], ax	; [ES:DI+SF_ENTRY.sf_size]
		adc	[es:di+13h], cx	; [ES:DI+SF_ENTRY.sf_size+2]
		mov	ax, 1
		;call	dword [ShSU] ; call far [JShare+(14*4)] ; 14 = ShSU
		call	far [JShare+(14*4)] 
SAMSIZ:					; ...
		jmp	SETCLUS
; ---------------------------------------------------------------------------

SET_ACC_ERRW:				; ...
		jmp	SET_ACC_ERR_DS
; ---------------------------------------------------------------------------

WRTEOF:					; ...
		mov	cx, ax
		or	cx, dx
		jz	short KILLFIL
		sub	ax, 1
		sbb	dx, 0
		push	bx
		mov	bx, [es:bp+2]	; [ES:BP+DPB.SECTOR_SIZE]
		call	DIV32
		pop	bx
		mov	dx, cx
		mov	word [HIGH_SECTOR], cx
		call	SHR32
		mov	cx, ax
		call	FNDCLUS

SET_ACC_ERRWJ2:				; ...
		jb	short SET_ACC_ERRW
		jcxz	RELFILE
		call	ALLOCATE
		jb	short WRTERRJ

UPDATE:					; ...
		les	di, [THISSFT]
		mov	ax, word [BYTPOS]
		mov	[es:di+11h], ax	; [ES:DI+SF_ENTRY.sf_size]
		mov	ax, word [BYTPOS+2]
		mov	[es:di+13h], ax	; [ES:DI+SF_ENTRY.sf_size+2]
		mov	ax, 2
		;call	dword [ShSU] ; call far [JShare+(14*4)]
		call	far [JShare+(14*4)]
		xor	cx, cx
		jmp	ADDREC
; ---------------------------------------------------------------------------

WRTERRJ:				; ...
		jmp	WRTERR
; ---------------------------------------------------------------------------

RELFILE:				; ...
		push	es
		les	di, [THISSFT]
		cmp	dx, [es:di+19h]	; [ES:DI+SF_ENTRY.sf_cluspos]
		jnb	short SKIPRESET
		mov	word [es:di+19h], 0
		mov	dx, [es:di+0Bh]	; [ES:DI+SF_ENTRY.sf_firclus]
		mov	[es:di+35h], dx	; [ES:DI+SF_ENTRY.sf_lstclus]

SKIPRESET:				; ...
		pop	es
		mov	dx, 0FFFFh
		call	RELBLKS

SET_ACC_ERRWJJ:				; ...
		jb	short SET_ACC_ERRWJ2
		jmp	short UPDATE
; ---------------------------------------------------------------------------

KILLFIL:				; ...
		xor	bx, bx
		push	es
		les	di, [THISSFT]
		mov	[es:di+19h], bx	; [ES:DI+SF_ENTRY.sf_cluspos]
		mov	[es:di+35h], bx	; [ES:DI+SF_ENTRY.sf_lstclus]
		xchg	bx, [es:di+0Bh]	; [ES:DI+SF_ENTRY.sf_firclus]
		pop	es
		or	bx, bx
		jz	short UPDATEJ
		push	es
		push	bp
		push	ax
		push	cx
		push	dx
		les	bp, [THISDPB]
		mov	dl, [es:bp+0]
		mov	cx, bx
		mov	ah, 2
		call	FastOpen_Update
		pop	dx
		pop	cx
		pop	ax
		pop	bp
		pop	es
		call	RELEASE
		jb	short SET_ACC_ERRWJJ

UPDATEJ:				; ...
		jmp	short UPDATE

; =============== S U B	R O U T	I N E =======================================

DskWrtBufPurge:	; ...
		push	bx
		push	cx
		mov	bx, [ss:HIGH_SECTOR]
		mov	si, bx
		add	cx, dx
		adc	si, 0
		mov	al, [es:bp+0]
		cmp	word [ss:SC_CACHE_COUNT], 0
		jz	short nosc
		cmp	al, [ss:CurSC_DRIVE]
		jnz	short nosc
		push	ax
		mov	ax, word [ss:CurSC_SECTOR]
		mov	di, word [ss:CurSC_SECTOR+2]
		cmp	si, di
		jnz	short sc01
		cmp	cx, ax

sc01:					; ...
		jbe	short sc5
		add	ax, [ss:SC_CACHE_COUNT]
		adc	di, 0
		cmp	bx, di
		jnz	short sc02
		cmp	dx, ax

sc02:					; ...
		jnb	short sc5
		mov	word [ss:SC_STATUS], 0

sc5:					; ...
		pop	ax

nosc:					; ...
		call	GETCURHEAD

_bufq:					; ...
		cmp	al, [di+4]	; [di+BUFFINFO.buf_ID]
		jnz	short bufq5
		cmp	bx, [di+8]	; [di+BUFFINFO.buf_sector+2]
		jnz	short bufq04
		cmp	dx, [di+6]	; [di+BUFFINFO.buf_sector]

bufq04:					; ...
		ja	short bufq5
		cmp	si, [di+8]
		jnz	short bufq05
		cmp	cx, [di+6]

bufq05:					; ...
		jbe	short bufq5
		test	byte [di+5], 40h ; [di+BUFFINFO.buf_flags],
					; buf_dirty
		jz	short bufq4
		call	DEC_DIRTY_COUNT

bufq4:					; ...
		mov	word [di+4], 20FFh ; [di+BUFFINFO.buf_ID],
					; ((buf_visit<<8)|0FFh)
		call	SCANPLACE
		jmp	short bufq6
; ---------------------------------------------------------------------------

bufq5:					; ...
		mov	di, [di]	; [di+BUFFINFO.buf_next]

bufq6:					; ...
		cmp	di, [ss:FIRST_BUFF_ADDR]
		jnz	short _bufq
		pop	cx
		pop	bx
		retn

; =============== S U B	R O U T	I N E =======================================

DIV32:		; ...
		cmp	bx, 512
		jnz	short div5
		mov	cx, dx
		mov	dx, ax		; CX:AX	= Dividend
					; DX = Remainder
		and	dx, 1FFh	; 511
		mov	al, ah
		mov	ah, cl
		mov	cl, ch
		xor	ch, ch
		shr	cx, 1
		rcr	ax, 1
		retn
; ---------------------------------------------------------------------------

div5:					; ...
		mov	cx, ax
		mov	ax, dx
		xor	dx, dx
		div	bx		; 0:AX/BX
		xchg	ax, cx
		div	bx		; DX:AX/BX
		retn

; =============== S U B	R O U T	I N E =======================================

SHR32:		; ...
		mov	cl, [es:bp+5]	; [ES:BP+DPB.CLUSTER_SHIFT]
		xor	ch, ch
		jcxz	norota

rotashft2:				; ...
		shr	dx, 1
		rcr	ax, 1
		loop	rotashft2

norota:					; ...
		retn

; =============== S U B	R O U T	I N E =======================================

FINDENTRY:		; ...
		call	STARTSRCH
		mov	al, [ATTRIB]
		and	al, 9Eh		; ~attr_ignore
		cmp	al, 8		; attr_volume_id
		jnz	short NOTVOLSRCH
		call	SETROOTSRCH

NOTVOLSRCH:				; ...
		call	GETENTRY
		jnb	short SRCH
		jmp	SETESRET
; ---------------------------------------------------------------------------

SRCH:					; ...
		push	ds
		mov	ds, word [CURBUF+2]
		mov	ah, [bx]	; [BX+dir_entry.dir_name] ; mov	ah,[bx+0]
		or	ah, ah
		jz	short FREE
		cmp	ah, [ss:DELALL]
		jz	short FREE
		test	byte [bx+0Bh], 8 ; [BX+dir_entry.dir_attr],
					; attr_volume_id
		jz	short CHKFNAM
		inc	byte [ss:VOLID]

CHKFNAM:				; ...
		mov	si, ss
		mov	es, si
		mov	si, bx
		mov	di, NAME1
		cmp	byte [ss:NAME1], 0E5h
		jnz	short NO_E5
		mov	byte [ss:NAME1], 5

NO_E5:					; ...
		call	MetaCompare
		jz	short FOUND
		pop	ds

NEXTENT:				; ...
		les	bp, [THISDPB]
		call	NEXTENTRY
		jnb	short SRCH
		jmp	short SETESRET
; ---------------------------------------------------------------------------

FREE:					; ...
		pop	ds
		mov	cx, [LASTENT]
		cmp	cx, [ENTFREE]
		jnb	short TSTALL
		mov	[ENTFREE], cx

TSTALL:					; ...
		cmp	ah, [DELALL]

NEXTENTJ:				; ...
		jz	short NEXTENT
		mov	[ENTLAST], cx
		stc
		jmp	short SETESRET
; ---------------------------------------------------------------------------

FOUND:					; ...
		mov	ch, [si]
		pop	ds
		mov	ah, [ATTRIB]
		and	ah, 9Eh		; ~attr_ignore
		lea	si, [si+15]	; [SI+dir_entry.dir_first-dir_entry.dir_attr]
		test	ch, 8		; attr_volume_id
		jz	short check_one_volume_id
		test	ah, 8		; attr_volume_id
		jz	short NEXTENTJ
		xor	ah, ah
		jmp	short RETFF
; ---------------------------------------------------------------------------

check_one_volume_id:			; ...
		cmp	ah, 8
		jz	short NEXTENTJ
		call	MatchAttributes
		jz	short RETFF
		test	byte [CREATING], 0FFh ; -1
		jz	short NEXTENTJ

RETFF:					; ...
		les	bp, [THISDPB]
		mov	ah, [es:bp+0]	; [ES:BP+DPB.DRIVE]

SETESRET:				; ...
		push	ss
		pop	es
		retn

; =============== S U B	R O U T	I N E =======================================

MetaCompare:	; ...
		mov	cx, 11

WILDCRD:				; ...
		repe cmpsb
		jz	short MetaRet

CHECK_META:				; 3Fh
		cmp	byte [es:di-1], '?'
		jz	short WILDCRD

MetaRet:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================

NEXTENTRY:		; ...
		mov	ax, [LASTENT]
		cmp	ax, [ENTLAST]
		jz	short NONE
		inc	ax
		lea	bx, [bx+32]
		cmp	bx, dx
		jb	short HAVIT
		mov	bl, [SECCLUSPOS]
		inc	bl
		cmp	bl, [CLUSFAC]
		jb	short SAMECLUS
		mov	bx, [NXTCLUSNUM]
		call	IsEOF
		jnb	short NONE
		cmp	bx, 2
		jb	short NONE
		jmp	short GETENT
; ---------------------------------------------------------------------------

NONE:					; ...
		stc
		retn
; ---------------------------------------------------------------------------

HAVIT:					; ...
		mov	[LASTENT], ax
		clc

nextentry_retn:				; ...
		retn
; ---------------------------------------------------------------------------

SAMECLUS:				; ...
		mov	[SECCLUSPOS], bl
		mov	[LASTENT], ax
		push	ds
		lds	di, [CURBUF]
		mov	dx, [di+8]	; [DI+BUFFINFO.buf_sector+2]
		mov	word [ss:HIGH_SECTOR], dx
		mov	dx, [di+6]	; [DI+BUFFINFO.buf_sector]
		add	dx, 1
		adc	word [ss:HIGH_SECTOR], 0
		pop	ds
		call	FIRSTCLUSTER
		xor	bx, bx
		jmp	short SETENTRY

; =============== S U B	R O U T	I N E =======================================

GETENTRY:		; ...
		mov	ax, [LASTENT]

GETENT:					; ...
		mov	[LASTENT], ax
		mov	cl, 5
		rol	ax, cl		; * 32
		mov	dx, ax
		and	ax, 0FFE0h	; ~(32-1)
		and	dx, 1Fh		; 32-1
		mov	bx, [es:bp+2]	; [ES:BP+DPB.SECTOR_SIZE]
		and	bl, 0E0h	; 255-31
		div	bx
		mov	bx, dx
		push	bx
		call	DIRREAD
		pop	bx
		jb	short nextentry_retn

SETENTRY:				; ...
		mov	dx, word [CURBUF]
		add	dx, 20		; BUFINSIZ
		add	bx, dx
		add	dx, [es:bp+2]	; [ES:BP+DPB.SECTOR_SIZE]
		retn

; =============== S U B	R O U T	I N E =======================================

SETDIRSRCH:		; ...
		or	bx, bx
		jz	short SETROOTSRCH
		mov	[DIRSTART], bx
		mov	al, [es:bp+4]	; [ES:BP+DPB.CLUSTER_MASK]
		inc	al
		mov	[CLUSFAC], al
		push	si
		test	byte [FastOpenFlg], 2 ; Lookup_Success
		jnz	short UNP_OK
		call	UNPACK
		jnb	short UNP_OK
		pop	si
		retn
; ---------------------------------------------------------------------------

UNP_OK:					; ...
		mov	[CLUSNUM], di
		mov	dx, bx
		xor	bl, bl
		mov	[SECCLUSPOS], bl
		call	FIGREC
		pop	si
		push	dx
		mov	dx, [HIGH_SECTOR]
		mov	word [DIRSEC+2],	dx
		pop	dx
		mov	word [DIRSEC], dx
		clc
		retn

; =============== S U B	R O U T	I N E =======================================

SETROOTSRCH:	; ...
		xor	ax, ax
		mov	[DIRSTART], ax
		mov	[SECCLUSPOS], al
		dec	ax
		mov	[CLUSNUM], ax
		mov	ax, [es:bp+0Bh]	; [ES:BP+DPB.FIRST_SECTOR]
		mov	dx, [es:bp+11h]	; [ES:BP+DPB.DIR_SECTOR]
		sub	ax, dx
		mov	[CLUSFAC], al
		mov	word [DIRSEC], dx
		mov	word [DIRSEC+2],	0
		clc
		retn

; =============== S U B	R O U T	I N E =======================================

GETPATH:

; FUNCTION CHUNK AT 7F47 SIZE 000001A5 BYTES

		mov	word [CREATING], 0E500h ; DIRFREE*256+0

GetPathNoSet:				; ...
		mov	byte [EXTERR_LOCUS], 2 ; errLOC_Disk
		mov	word [CURBUF], -1 ; 0FFFFh
		mov	di, [WFP_START]
		cmp	word [di+1], 5C3Ah ; '\' << 8 + ':'
		jz	short CrackIt
		add	di, 3
		mov	si, di
		call	CHKDEV
		jb	short InternalError

Build_devJ:				; ...
		mov	al, [SATTRIB]
		mov	byte [ATTRIB], al
		mov	byte [EXTERR_LOCUS], 1 ; errLOC_Unk
		push	ss
		pop	es
		mov	si, NAME1
		mov	di, [WFP_START]
		mov	dx, di
		mov	cx, 8

MoveLoop:				; ...
		lodsb
		stosb
		cmp	al, 20h	; ' '
		jz	short NoSave
		mov	dx, di

NoSave:					; ...
		loop	MoveLoop
		mov	di, dx
		mov	byte [di], 0
		call	Build_device_ent
		inc	al
		retn
; ---------------------------------------------------------------------------

InternalError:				; ...
		jmp	short InternalError
; ---------------------------------------------------------------------------

CrackIt:				; ...
		mov	si, [CURR_DIR_END]
		cmp	si, -1		; 0FFFFh
		jnz	short LOOK_SING
		lea	si, [di+3]

LOOK_SING:				; ...
		mov	byte [ATTRIB], 16h ; attr_directory+attr_system+attr_hidden
		les	di, [THISCDS]
		mov	ax, 0FFFFh	; -1
		mov	bx, [es:di+49h]	; [ES:DI+curdir.ID]
		mov	si, [CURR_DIR_END]
		cmp	si, ax
		jz	short NO_CURR_D
		cmp	bx, ax
		jz	short NO_CURR_D
		test	byte [FastOpenFlg], 1 ; FastOpen_Set
		jz	short GOT_SEARCH_CLUSTER
		push	es
		push	di
		push	cx
		push	word [si-1]
		push	si
		push	bx
		mov	byte [si-1], 0
		mov	si, [WFP_START]
		mov	bx, FastOpenTable
		mov	di, Dir_Info_Buff
		mov	cx, FastOpen_Ext_Info
		mov	al, 1		; FONC_Look_up
		push	ds
		pop	es
		;call	dword [bx+2] ; CALL far [BX+fastopen_entry.name_caching]
		call	far [bx+2]
		jb	short GO_Chk_end1
		cmp	byte [si], 0
		jz	short GO_Chk_end
		stc
		jmp	short GO_Chk_end
; ---------------------------------------------------------------------------

GO_Chk_end1:				; ...
		clc

GO_Chk_end:				; ...
		pop	bx
		pop	si
		pop	word [si-1]
		pop	cx
		pop	di
		pop	es
		jnb	short GOT_SEARCH_CLUSTER

NO_CURR_D:				; ...
		mov	si, [WFP_START]
		lea	si, [si+3]
		les	bp, [THISDPB]
		jmp	short ROOTPATH
; ---------------------------------------------------------------------------

GOT_SEARCH_CLUSTER:			; ...
		les	bp, [THISDPB]
		call	SETDIRSRCH
		jb	short SETFERR
		jmp	short FINDPATH
; ---------------------------------------------------------------------------

SETFERR:				; ...
		xor	cl, cl
		stc
		retn

; =============== S U B	R O U T	I N E =======================================

CHKDEV:		; ...
		mov	si, di
		mov	di, ss
		mov	es, di
		mov	di, NAME1
		mov	cx, 9

TESTLOOP:				; ...
		call	GETLET
		cmp	al, 2Eh	; '.'
		jz	short TESTDEVICE
		call	PATHCHRCMP
		jz	short NOTDEV
		or	al, al
		jz	short TESTDEVICE
		stosb
		loop	TESTLOOP

NOTDEV:					; ...
		stc
		retn
; ---------------------------------------------------------------------------

TESTDEVICE:				; ...
		add	cx, 2
		mov	al, 20h	; ' '
		rep stosb
		mov	ax, ss
		mov	ds, ax
		call	DEVNAME
		retn

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR GETPATH

ROOTPATH:				; ...
		call	SETROOTSRCH
		cmp	byte [si], 0
		jnz	short FINDPATH
		mov	al, [SATTRIB]
		mov	byte [ATTRIB], al
		xor	ah, ah
		retn
; ---------------------------------------------------------------------------

FINDPATH:				; ...
		push	es
		push	si
		mov	di, si
		mov	cx, [DIRSTART]
		cmp	word [CURR_DIR_END], 0FFFFh ; -1
		jz	short NOIDS
		cmp	di, [CURR_DIR_END]
		jnz	short NOIDS
		les	di, [THISCDS]
		mov	[es:di+49h], cx	; [ES:DI+curdir.ID]

NOIDS:					; ...
		mov	ax, ss
		mov	es, ax
		mov	di, NAME1
		mov	ax, 2020h	; '  '
		stosb
		stosw
		stosw
		stosw
		stosw
		stosw
		mov	di, NAME1
		xor	ah, ah

GetNam:					; ...
		inc	cl
		lodsb
		cmp	al, 2Eh	; '.'
		jz	short _SetExt
		or	al, al
		jz	short _GetDone
		cmp	al, 5Ch	; '\'
		jz	short _GetDone
		cmp	al, 3Fh	; '?'
		jnz	short StoNam
		or	ah, 1

StoNam:					; ...
		stosb
		jmp	short GetNam
; ---------------------------------------------------------------------------

_SetExt:				; ...
		mov	di, NAME1+8

GetExt:					; ...
		lodsb
		or	al, al
		jz	short _GetDone
		cmp	al, 5Ch	; '\'
		jz	short _GetDone
		cmp	al, 3Fh	; '?'
		jnz	short StoExt
		or	ah, 1

StoExt:					; ...
		stosb
		jmp	short GetExt
; ---------------------------------------------------------------------------

_GetDone:				; ...
		dec	si
		mov	cl, ah
		or	cl, 80h
		pop	di
		pop	es
		cmp	si, di
		jnz	short check_device
		jmp	_BADPATH
; ---------------------------------------------------------------------------

check_device:				; ...
		push	si
		mov	al, [si]
		or	al, al
		jnz	short NOT_LAST
		mov	bh, [SATTRIB]
		mov	byte [ATTRIB], bh

NOT_LAST:				; ...
		push	es
		push	ss
		pop	es
		call	DEVNAME
		pop	es
		jb	short FindFile
		or	al, al
		jz	short GO_BDEV
		jmp	FILEINPATH
; ---------------------------------------------------------------------------

GO_BDEV:				; ...
		pop	si
		jmp	Build_devJ
; ---------------------------------------------------------------------------

FindFile:				; ...
		cmp	byte [NAME1], 0E5h
		jnz	short NOE5
		mov	byte [NAME1], 5

NOE5:					; ...
		push	di
		push	es
		push	cx
		call	LookupPath
		jnb	short DIR_FOUND
		call	FINDENTRY

DIR_FOUND:				; ...
		pop	cx
		pop	es
		pop	di
		jnb	short LOAD_BUF
		jmp	BADPATHPOP
; ---------------------------------------------------------------------------

LOAD_BUF:				; ...
		lds	di, [CURBUF]
		test	byte [bx+0Bh], 10h ; [BX+dir_entry.dir_attr],
					; attr_directory
		jnz	short GO_NEXT
		jmp	FILEINPATH
; ---------------------------------------------------------------------------

GO_NEXT:				; ...
		cmp	byte [ss:NoSetDir], 0
		jz	short SetDir
		mov	dx, di
		mov	cx, ds
		push	ss
		pop	ds
		pop	di
		test	byte [FastOpenFlg], 1 ; FastOpen_Set
		jz	short _nofast
		test	byte [FastOpenFlg], 2 ; Lookup_Success
		jz	short _nofast
		mov	di, [Next_Element_Start]

_nofast:				; ...
		cmp	byte [di], 0
		jnz	short NEXT_ONE
		jmp	_SETRET
; ---------------------------------------------------------------------------

NEXT_ONE:				; ...
		push	di
		mov	di, dx
		mov	ds, cx

SetDir:					; ...
		mov	dx, [si]
		push	ds
		push	ss
		pop	ds
		test	byte [FastOpenFlg], 2 ; Lookup_Success
		jz	short DO_NORMAL
		mov	bx, dx
		mov	di, [CLUSNUM]
		push	ax
		call	SETDIRSRCH
		pop	ax
		add	sp, 2
		jmp	short FAST_OPEN_SKIP
; ---------------------------------------------------------------------------

DO_NORMAL:				; ...
		pop	ds
		sub	bx, di
		sub	si, di
		push	bx
		push	ax
		push	si
		push	cx
		push	word [di+6]	; [DI+BUFFINFO.buf_sector]
		push	word [di+8]	; [DI+BUFFINFO.buf_sector+2]
		mov	bx, dx
		push	ss
		pop	ds
		call	SETDIRSRCH
		pop	word [HIGH_SECTOR]
		pop	dx
		jb	short SKIP_GETB
		mov	byte [ALLOWED], 18h ; Allowed_RETRY+Allowed_FAIL
		xor	al, al
		call	GETBUFFR

SKIP_GETB:				; ...
		pop	cx
		pop	si
		pop	ax
		pop	bx
		jnb	short SET_THE_BUF
		pop	di
		mov	si, di
		jmp	short _BADPATH
; ---------------------------------------------------------------------------

SET_THE_BUF:				; ...
		call	SET_BUF_AS_DIR
		mov	di, word [CURBUF]
		add	si, di
		add	bx, di

FAST_OPEN_SKIP:				; ...
		pop	di
		call	InsertPath
		mov	al, [di]
		or	al, al
		jz	short _SETRET
		inc	di
		mov	si, di
		call	PATHCHRCMP
		jnz	short find_bad_name
		jmp	FINDPATH
; ---------------------------------------------------------------------------

find_bad_name:				; ...
		dec	si

_BADPATH:				; ...
		xor	cl, cl
		jmp	short BADPRET
; ---------------------------------------------------------------------------

FILEINPATH:				; ...
		pop	di
		push	ss
		pop	ds
		test	byte [FastOpenFlg], 1 ; FastOpen_Set
		jz	short NO_FAST
		test	byte [FastOpenFlg], 2 ; Lookup_Success
		jz	short NO_FAST
		mov	di, [Next_Element_Start]

NO_FAST:				; ...
		mov	al, [di]
		or	al, al
		jz	short INCRET
		mov	si, di
		jmp	short BADPRET
; ---------------------------------------------------------------------------

INCRET:					; ...
		call	InsertPath
		inc	al

_SETRET:				; ...
		retn
; ---------------------------------------------------------------------------

BADPATHPOP:				; ...
		pop	si
		mov	al, [si]
		mov	si, di
		or	al, al

BADPRET:				; ...
		mov	al, [SATTRIB]
		mov	byte [ATTRIB], al
		stc
		retn
; END OF FUNCTION CHUNK	FOR GETPATH

; =============== S U B	R O U T	I N E =======================================

STARTSRCH:		; ...
		les	bp, [THISDPB]
		xor	ax, ax
		mov	[LASTENT], ax
		mov	[VOLID], al
		dec	ax
		mov	[ENTFREE], ax
		mov	[ENTLAST], ax
		retn

; =============== S U B	R O U T	I N E =======================================

MatchAttributes:
		push	ax
		mov	al, [ss:ATTRIB]
		not	al
		and	al, ch
		and	al, 16h		; attr_all
		pop	ax
		retn

; =============== S U B	R O U T	I N E =======================================

DEVNAME:
		push	si
		push	di
		push	cx
		push	ax
		push	word [NAME1]
		cmp	byte [NAME1], 5
		jnz	short NOKTR
		mov	byte [NAME1], 0E5h

NOKTR:					; ...
		test	byte [ATTRIB], 8 ; attr_volume_id
		jnz	short RET31
		mov	si, NULDEV

LOOKIO:					; ...
		test	word [si+4], 8000h ; [SI+SYSDEV.ATT],DEVTYP
		jz	short SKIPDEV
		mov	ax, si
		add	si, 10		; SYSDEV.NAME
		mov	di, NAME1
		mov	cx, 4
		repe cmpsw
		mov	si, ax
		jz	short IOCHK

SKIPDEV:				; ...
		lds	si, [si]
		cmp	si, 0FFFFh	; -1
		jnz	short LOOKIO

RET31:					; ...
		stc

RETNV:					; ...
		mov	cx, ss
		mov	ds, cx
		pop	word [NAME1]
		pop	ax
		pop	cx
		pop	di
		pop	si
		retn
; ---------------------------------------------------------------------------

IOCHK:					; ...
		mov	word [ss:DEVPT+2], ds
		mov	bh, [si+4]	; [SI+SYSDEV.ATT]
		or	bh, 0C0h
		and	bh, 0DFh	; ~20h
		mov	word [ss:DEVPT], si
		jmp	short RETNV

; =============== S U B	R O U T	I N E =======================================

Build_device_ent:	; ...
		mov	ax, 2020h	; '  '
		mov	di, NAME1+8	; DEVFCB+8
		stosw
		stosb
		mov	al, 40h		; attr_device
		stosb
		xor	ax, ax
		mov	cx, 10
		rep stosw
		call	DATE16
		mov	di, NAME2+0Ah	; DEVFCB+dir_entry.dir_time
		xchg	ax, dx
		stosw
		xchg	ax, dx
		stosw
		mov	si, di
		mov	ax, word [DEVPT]
		stosw
		mov	ax, word [DEVPT+2]
		stosw
		mov	ah, bh
		mov	bx, NAME1 ; DEVFCB
		xor	al, al
		retn

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

ValidateCDS:	; ...

SaveCDS		equ -6
Temp		equ -2

		push	bp
		mov	bp, sp
		sub	sp, 6
		mov	[bp+Temp], di	; [bp-2]
		lds	si, [ss:THISCDS]
		mov	word [bp+SaveCDS], si ; [bp-6]
		mov	word [bp+SaveCDS+2], ds ; [bp-4]
		call	ECritDisk
		test	word [si+67], 8000h	; [SI+curdir.flags],
					; curdir_isnet
		jz	short _DoSplice
		jmp	FatFail
; ---------------------------------------------------------------------------

_DoSplice:				; ...
		xor	dl, dl
		xchg	dl, [ss:NoSetDir]
		push	ss
		pop	es
		call	FStrCpy
		mov	si, [bp+Temp]	; [bp-2]
		push	ss
		pop	ds
		call	Splice
		push	ss
		pop	ds
		mov	[NoSetDir], dl
		les	di, [THISCDS]
		push	bp
		call	FATREAD_CDS
		pop	bp
		jb	short FatFail
		lds	si, [THISCDS]
		cmp	word [si+49h], 0FFFFh ; [SI+curdir.ID],-1
		jnz	short RestoreCDS
		push	ss
		pop	es
		push	word [ss:WFP_START]
		cmp	si, word [bp+SaveCDS] ; [bp-6] ; SaveCDSL
		jnz	short DoChdir
		mov	di, [bp+Temp]	; [bp-2]
		mov	[ss:WFP_START],	di
		call	FStrCpy

DoChdir:				; ...
		push	ss
		pop	ds
		push	word [SATTRIB]
		push	bp
		call	DOS_CHDIR
		pop	bp
		pop	bx
		pop	word [WFP_START]
		mov	[SATTRIB], bl
		lds	si, [bp+SaveCDS] ; [bp-6]
		jnb	short SetCluster
		mov	word [ss:THISCDS], si
		mov	word [ss:THISCDS+2], ds
		xor	cx, cx
		mov	[si+3],	cl

SetCluster:				; ...
		mov	word [si+49h], 0FFFFh ; [SI+curdir.ID],-1
		lds	si, [ss:THISCDS]
		test	word [si+43h], 2000h ; SI+curdir.flags],
					; curdir_splice
		jz	short _setdirclus
		mov	cx, -1		; 0FFFFh ; 65535

_setdirclus:				; ...
		mov	[si+49h], cx	; [SI+curdir.ID]

RestoreCDS:				; ...
		les	di, [bp+SaveCDS] ; [bp-6]
		mov	word [ss:THISCDS], di
		mov	word [ss:THISCDS+2], es
		clc

FatFail:				; ...
		call	LCritDisk
		les	di, [bp+SaveCDS] ; [bp-6]
		mov	sp, bp
		pop	bp
		retn

; =============== S U B	R O U T	I N E =======================================

CheckThisDevice:
		push	di
		push	si
		mov	di, si
		mov	al, [si]
		call	PATHCHRCMP
		jnz	short ParseDev
		inc	si
		lodsw
		or	ax, 2020h
		cmp	ax, 6564h	; 'dev'
		jnz	short NotDevice
		lodsb
		or	al, 20h
		cmp	al, 'v'
		jnz	short NotDevice
		lodsb
		call	PATHCHRCMP
		jnz	short NotDevice

ParseDev:				; ...
		push	ds
		push	si
		call	NameTrans
		cmp	byte [si], 0
		stc
		jnz	short SkipSearch
		push	ss
		pop	ds
		mov	al, [SATTRIB]
		mov	byte [ATTRIB], al
		call	DEVNAME

SkipSearch:				; ...
		pop	si
		pop	ds

CheckReturn:				; ...
		pop	di
		jnb	short Check_Done
		mov	si, di

Check_Done:				; ...
		pop	di
		cmc
		retn
; ---------------------------------------------------------------------------

NotDevice:				; ...
		stc
		jmp	short CheckReturn

; =============== S U B	R O U T	I N E =======================================

LookupPath:		; ...
		test	byte [ss:FastOpenFlg], 1 ; FastOpen_Set
		jnz	short FASTINST

NOLOOK:					; ...
		jmp	NOLOOKUP
; ---------------------------------------------------------------------------

FASTINST:				; ...
		test	byte [ss:FastOpenFlg], 8 ; No_Lookup
		jnz	short NOLOOK
		mov	bx, FastOpenTable
		mov	si, [ss:WFP_START]
		mov	di, Dir_Info_Buff
		mov	cx, FastOpen_Ext_Info
		mov	al, 1
		push	ds
		pop	es
		;call	dword [bx+2] ; CALL far [BX+fastopen_entry.name_caching]
		call	far [bx+2]
		jb	short NOTFOUND
		lea	bx, [si-2]
		cmp	bx, [ss:WFP_START]
		jz	short NOTFOUND
		cmp	byte [si], 0
		jnz	short parfnd
		push	cx
		mov	cl, [ss:ATTRIB]
		mov	ch, [ss:SATTRIB]
		mov	[ss:ATTRIB], ch
		mov	ch, [es:di+0Bh]	; [ES:DI+dir_entry.dir_attr]
		call	MatchAttributes
		pop	cx
		jnz	short NOLOOKUP

parfnd:					; ...
		mov	[ss:Next_Element_Start], si
		mov	bx, cx
		mov	ax, [bx+7]	; [BX+FEI.lastent]
		mov	[ss:LASTENT], ax
		mov	ax, [bx+9]	; [BX+FEI.dirstart]
		mov	[ss:DIRSTART], ax
		mov	ax, [bx+5]	; [BX+FEI.clusnum]
		mov	[ss:CLUSNUM], ax
		push	es
		les	bx, [ss:THISDPB]
		mov	ah, [es:bx]	; [ES:BX+DPB.DRIVE]
		pop	es
		mov	word [ss:CURBUF], 0
		mov	word [ss:CURBUF+2],	es
		mov	bx, di
		lea	si, [di+1Ah]	; [DI+dir_entry.dir_first]
		or	byte [ss:FastOpenFlg], 12h ; Lookup_Success+Set_For_Search
		retn
; ---------------------------------------------------------------------------

NOTFOUND:				; ...
		cmp	ax, 0FFFFh	; -1
		jnz	short Partial_Success
		mov	byte [ss:FastOpenFlg], 0

Partial_Success:			; ...
		and	byte [ss:FastOpenFlg], 0FBh ; Special_Fill_Reset

NOLOOKUP:				; ...
		stc
		retn

; =============== S U B	R O U T	I N E =======================================

InsertPath:		; ...
		pushf
		test	byte [ss:FastOpenFlg], 1 ; FastOpen_Set
		jz	short GET_NEXT_ELEMENT
		test	byte [ss:FastOpenFlg], 2 ; Lookup_Success
		jz	short INSERT_DIR_INFO
		and	byte [ss:FastOpenFlg], 0FDh ; Lookup_Reset
		mov	di, [ss:Next_Element_Start]
		jmp	short GET_NEXT2
; ---------------------------------------------------------------------------

INSERT_DIR_INFO:			; ...
		push	ds
		push	es
		push	bx
		push	si
		push	di
		push	cx
		push	ax
		lds	di, [ss:CURBUF]
		mov	si, FastOpen_Ext_Info
		mov	ax, [di+6]	; [DI+BUFFINFO.buf_sector]
		mov	[ss:si+1], ax	; [SS:SI+FEI.dirsec]
		mov	ax, [di+8]	; [DI+BUFFINFO.buf_sector+2]
		push	ss
		pop	ds
		mov	[si+3],	ax	; [SI+FEI.dirsec+2]
		mov	ax, [CLUSNUM]
		mov	[si+5],	ax	; [SI+FEI.clusnum]
		mov	ax, [LASTENT]
		mov	[si+7],	ax	; [SI+FEI.lastent]
		mov	ax, [DIRSTART]
		mov	[si+9],	ax	; [SI+FEI.dirstart]
		mov	ax, bx
		add	di, 20		; BUFINSIZ
		sub	ax, di
		mov	cl, 32		; dir_entry.size
		div	cl
		mov	[si], al	; [SI+FEI.dirpos]
		push	ds
		pop	es
		mov	ds, word [CURBUF+2]
		mov	di, bx
		cmp	word [di+26], 0 ; [DI+dir_entry.dir_first]
		jz	short SKIP_INSERT
		push	si
		pop	bx
		mov	al, 2		; FONC_insert
		mov	si, FastOpenTable
		;call	dword [es:si+2] ; CALL far [SI+fastopen_entry.name_caching]
		call	far [es:si+2]
		clc

SKIP_INSERT:				; ...
		pop	ax
		pop	cx
		pop	di
		pop	si
		pop	bx
		pop	es
		pop	ds

GET_NEXT2:				; ...
		or	byte [ss:FastOpenFlg], 8 ; No_Lookup

GET_NEXT_ELEMENT:			; ...
		popf
		retn

; ---------------------------------------------------------------------------
LenTab		db 22, 14, 22, 13, 15, 14 ; ...
					; DRDWRHL, DRDNDHL, DRDWRHL,
					; DSTATHL, DFLSHL, DRDNDHL
CmdTab		db 86h,	4		; ...
					; DEVRD	  ; 0 input
		db 86h,	5		; DEVRDND ; 1 input status
		db 87h,	8		; DEVWRT  ; 2 output
		db 87h,	0Ah		; DEVOST  ; 3 output status
		db 86h,	7		; DEVIFL  ; 4 input flush
		db 86h,	5		; 5 input status with system WAIT

; =============== S U B	R O U T	I N E =======================================

IOFUNC:		; ...
		mov	word [ss:IOCTL_IOXAD_2], ss	; [SS:IOXAD+2]
		mov	word [ss:IOCTL_REQ_MINORFUNCTION], DEVIOBUF ;
					; [SS:IOXAD],DEVIOBUF
		mov	word [ss:IOCTL_IOSCNT], 1 ;	[SS:IOSCNT]
		mov	[ss:DEVIOBUF], ax
		test	byte [si+6], 80h ; [SI+SF_ENTRY.sf_flags+1],
					; (sf_isnet>>8)
		jz	short IOTO22
		jmp	IOTOFILE
; ---------------------------------------------------------------------------

IOTO22:					; ...
		test	byte [si+5], 80h ; [SI+SF_ENTRY.sf_flags],
					; devid_device
		jnz	short IOTO33
		jmp	IOTOFILE
; ---------------------------------------------------------------------------

IOTO33:					; ...
		push	es
		call	save_world
		mov	dx, ds
		mov	bx, ss
		mov	ds, bx
		mov	es, bx
		xor	bx, bx
		cmp	ah, 5
		jnz	short _no_sys_wait
		or	bx, 400h

_no_sys_wait:				; ...
		mov	word [IOCALL_REQSTAT], bx
		xor	bx, bx
		mov	[IOCTL_REQ_MAJORFUNCTION], bl ; [IOMED]
		mov	bl, ah
		mov	ah, [cs:LenTab+bx] ; [cs:BX+LenTab]
		shl	bx, 1
		mov	cx, word [cs:CmdTab+bx] ; [cs:BX+CmdTab]
		mov	bx, IOCALL_REQLEN ; IOCALL ; DOSDATA:037Ch
		mov	[IOCALL_REQLEN], ah
		mov	[IOCALL_REQFUNC], ch
		mov	ds, dx
		call	DEVIOCALL
		mov	di, word [ss:IOCALL_REQSTAT]
		and	di, di
		js	short DevErr

OKDevIO:				; ...
		mov	ax, ss
		mov	ds, ax
		cmp	ch, 5		; DEVRDND
		jnz	short DNODRD
		mov	al, [IOCTL_REQ_MAJORFUNCTION] ; [IORCHR]
		mov	byte [DEVIOBUF],	al

DNODRD:					; ...
		mov	ah, [IOCALL_REQSTAT+1]
		not	ah
		and	ah, 2		; STBUI>>8
		call	restore_world
		pop	es
		pushf
		mov	al, [ss:IoStatFail]
		cbw
		cmp	ax, -1		; 0FFFFh
		jnz	short not_fail_ret
		inc	byte [ss:IoStatFail]
		popf
		retn
; ---------------------------------------------------------------------------

not_fail_ret:				; ...
		mov	ax, [ss:DEVIOBUF]
		popf
		retn
; ---------------------------------------------------------------------------

DevErr:					; ...
		mov	ah, cl
		call	CHARHARD
		cmp	al, 1
		jnz	short NO_RETRY
		call	restore_world
		pop	es
		jmp	IOFUNC
; ---------------------------------------------------------------------------

NO_RETRY:				; ...
		and	byte [ss:IOCALL_REQSTAT+1], 0FDh ; ~(STBUI>>8)
		cmp	al, 3
		jnz	short not_fail
		dec	byte [ss:IoStatFail]

not_fail:				; ...
		jmp	short OKDevIO
; ---------------------------------------------------------------------------

IOTOFILE:				; ...
		or	ah, ah
		jz	short IOIN
		dec	ah
		jz	short IOIST
		dec	ah
		jz	short IOUT
		retn
; ---------------------------------------------------------------------------

IOIST:					; ...
		push	word [si+15h] ; [SI+SF_ENTRY.sf_position]
		push	word [si+17h] ; [SI+SF_ENTRY.sf_position+2]
		call	IOIN
		pop	word [si+17h]
		pop	word [si+15h]
		retn
; ---------------------------------------------------------------------------

IOUT:					; ...
		call	SETXADDR
		call	DOS_WRITE
		call	RESTXADDR

IOUT_retn:				; ...
		retn
; ---------------------------------------------------------------------------

IOIN:					; ...
		call	SETXADDR
		or	word [ss:DOS34_FLAG], 40h ; Disable_EOF_I24
		call	DOS_READ
		and	word [ss:DOS34_FLAG], 0FFBFh ; NO_Disable_EOF_I24
		or	cx, cx
		call	RESTXADDR
		mov	al, byte [ss:DEVIOBUF]
		jnz	short IOUT_retn
		mov	al, 1Ah		; ^Z
		retn

; =============== S U B	R O U T	I N E =======================================

SETXADDR:		; ...

; FUNCTION CHUNK AT 8529 SIZE 00000005 BYTES

		pop	word [ss:CALLSCNT]
		push	es
		call	save_world
		push	word [ss:DMAADD]
		push	word [ss:DMAADD+2]
		mov	word [ss:THISSFT+2], ds
		push	ss
		pop	ds
		mov	word [THISSFT], si
		mov	cx, word [IOCTL_IOXAD_2]	; [IOXAD+2]
		mov	word [DMAADD+2],	cx
		mov	cx, word [IOCTL_REQ_MINORFUNCTION] ; [IOXAD]
		mov	word [DMAADD], cx
		mov	cx, word [IOCTL_IOSCNT] ; [IOCNT]
		jmp	short RESTRET

; ---------------------------------------------------------------------------

RESTXADDR:				; ...
		pop	word [CALLSCNT]
		pop	word [DMAADD+2]
		pop	word [DMAADD]
		call	restore_world
		pop	es
; START	OF FUNCTION CHUNK FOR SETXADDR

RESTRET:				; ...
		;jmp	[ss:CALLSCNT]	; JMP WORD [SS:CALLSCNT]
		jmp	word [ss:CALLSCNT]

; END OF FUNCTION CHUNK	FOR SETXADDR

; =============== S U B	R O U T	I N E =======================================

DEV_OPEN_SFT:	; ...
		push	es
		call	save_world
		mov	al, 0Dh		; DEVOPN
		jmp	short DO_OPCLS

; =============== S U B	R O U T	I N E =======================================

DEV_CLOSE_SFT:	; ...
		push	es
		call	save_world
		mov	al, 0Eh

DO_OPCLS:				; ...
		test	byte [es:di+6], 80h	; [es:di+SF_ENTRY.sf_flags+1],
					; (sf_isnet>>8)
		jnz	short OPCLS_DONE
		xor	ah, ah
		test	byte [es:di+5], 80h	; [ES:DI+SF_ENTRY.sf_flags],
					; devid_device
		les	di, [es:di+7]	; [ES:DI+SF_ENTRY.sf_devptr]
		jnz	short GOT_DEV_ADDR
		cmp	byte [ss:fShare], 1
		jbe	short OPCLS_DONE
		mov	ah, [es:di+1]	; [ES:DI+DPB.UNIT]
		mov	cl, [es:di]	; [ES:DI+DPB.DRIVE]
		les	di, [es:di+13h]	; [ES:DI+DPB.DRIVER_ADDR]

GOT_DEV_ADDR:				; ...
		test	byte [es:di+5], 8 ;	[ES:DI+SYSDEV.ATT+1],
					; (DEVOPCL>>8)
		jz	short OPCLS_DONE
		push	es
		pop	ds
		mov	si, di

OPCLS_RETRY:				; ...
		push	ss
		pop	es
		mov	di, DEVCALL
		mov	bx, di
		push	ax
		mov	al, 13		; DOPCLHL
		stosb
		pop	ax
		xchg	ah, al
		stosb
		xchg	ah, al
		stosb
		mov	word [es:di], 0
		push	ax
		call	DEVIOCALL2
		mov	di, [es:bx+3]	; [ES:BX+SRHEAD.REQSTAT]
		and	di, di
		jns	short OPCLS_DONEP
		test	byte [si+5], 80h ; [ES:DI+SYSDEV.ATT+1],
					; (DEVTYP>>8)
		jz	short BLKDEV
		mov	ah, 86h
		jmp	short HRDERR
; ---------------------------------------------------------------------------

BLKDEV:					; ...
		mov	al, cl
		mov	ah, 6

HRDERR:					; ...
		call	CHARHARD
		cmp	al, 1
		jnz	short OPCLS_DONEP
		pop	ax
		jmp	short OPCLS_RETRY
; ---------------------------------------------------------------------------

OPCLS_DONEP:				; ...
		pop	ax

OPCLS_DONE:				; ...
		call	restore_world
		pop	es
		retn

; =============== S U B	R O U T	I N E =======================================

DEVIOCALL:		; ...
		lds	si, [si+7]	; [SI+SF_ENTRY.sf_devptr]

DEVIOCALL2:				; ...
		call	ECritDevice
		test	byte [si+5], 80h ; [si+SYSDEV.ATT+1],(DEVTYP>>8)
		jnz	short chardev2
		cmp	byte [es:bx+2], 4 ; [ES:BX+SRHEAD.REQFUNC],DEVRD
		jz	short chkext
		cmp	byte [es:bx+2], 8 ; [ES:BX+SRHEAD.REQFUNC],DEVWRT
		jz	short chkext
		cmp	byte [es:bx+2], 9 ; [ES:BX+SRHEAD.REQFUNC],DEVWRTV
		jnz	short chardev2

chkext:					; ...
		call	RW_SC
		jb	short dev_exit
		test	byte [si+4], 2 ; [SI+SYSDEV.ATT],EXTDRVR
		jz	short chksector
		add	byte [es:bx], 8
		mov	ax, [ss:CALLSSEC]
		mov	word [ss:CALLSSEC], 0FFFFh ; -1
		mov	word [ss:CALLNEWSC], ax
		mov	ax, [ss:HIGH_SECTOR]
		mov	word [ss:CALLNEWSC+2], ax
		jmp	short chardev2
; ---------------------------------------------------------------------------

chksector:				; ...
		cmp	word [ss:HIGH_SECTOR], 0
		jz	short chardev2
		mov	word [es:bx+3], 8107h ; [ES:BX+SRHEAD.REQSTAT],
					; STERR+STDON+error_I24_not_DOS_disk
		jmp	short dev_exit
; ---------------------------------------------------------------------------

chardev2:				; ...
		mov	ax, [si+6]	; [SI+SYSDEV.STRAT]
		mov	word [ss:CALLDEVAD], ax
		mov	word [ss:CALLDEVAD+2], ds
		;call	[ss:CALLDEVAD]
		CALL	far [SS:CALLDEVAD]
		mov	ax, [si+8]	; [SI+SYSDEV.INT]
		mov	word [ss:CALLDEVAD], ax
		;call	[ss:CALLDEVAD]
		CALL	far [SS:CALLDEVAD]
		call	VIRREAD
		jb	short chardev2

dev_exit:				; ...
		call	LCritDevice
		retn

; =============== S U B	R O U T	I N E =======================================

SETREAD:
		push	di
		push	cx
		push	ax
		mov	cl, 4		; DEVRD

SETCALLHEAD:				; ...
		mov	al, 16h		; DRDWRHL
		push	ss
		pop	es
		mov	di, DEVCALL
		stosb
		pop	ax
		stosb
		push	ax
		mov	al, cl
		stosb
		xor	ax, ax
		stosw
		add	di, 8
		pop	ax
		xchg	ah, al
		stosb
		xchg	al, ah
		push	ax
		mov	ax, bx
		stosw
		mov	ax, ds
		stosw
		pop	cx
		pop	ax
		stosw
		xchg	ax, dx
		stosw
		xchg	ax, cx
		xchg	dx, cx
		pop	di
		mov	bx, DEVCALL
		retn

; =============== S U B	R O U T	I N E =======================================

SETWRITE:		; ...
		push	di
		push	cx
		push	ax
		mov	cl, 8		; DEVWRT
		add	cl, [ss:VERFLG]
		jmp	short SETCALLHEAD

; =============== S U B	R O U T	I N E =======================================

RW_SC:		; ...
		cmp	word [ss:SC_CACHE_COUNT], 0
		jz	short scexit4
		cmp	word [ss:CALLSCNT], 1
		jnz	short scexit4
		push	cx
		push	dx
		push	ds
		push	si
		push	es
		push	di
		mov	dx, [ss:CALLSSEC]
		cmp	byte [ss:DEVCALL_REQFUNC], 4 ; DEVRD
		jz	short doread
		call	INVALIDATE_SC
		jmp	scexit2
; ---------------------------------------------------------------------------

scexit4:				; ...
		clc
		retn
; ---------------------------------------------------------------------------

doread:					; ...
		call	SC2BUF
		jb	short readSC
		mov	word [ss:DEVCALL_REQSTAT], 100h ; STDON
		stc
		jmp	short saveseq
; ---------------------------------------------------------------------------

readSC:					; ...
		mov	ax, [ss:HIGH_SECTOR]
		mov	cx, [ss:CALLSSEC]
		sub	cx, word [ss:SEQ_SECTOR]
		sbb	ax, word [ss:SEQ_SECTOR+2]
		cmp	ax, 0
		jnz	short saveseq2
		cmp	cx, 1
		ja	short saveseq2
		mov	word [ss:SC_STATUS], 0FFFFh
		mov	ax, [ss:SC_CACHE_COUNT]
		mov	[ss:CALLSCNT], ax
		mov	ax, word [ss:CALLXADD+2]
		mov	[ss:TEMP_VAR2],	ax
		mov	ax, word [ss:CALLXADD]
		mov	[ss:TEMP_VAR], ax
		mov	ax, word [ss:SC_CACHE_PTR]
		mov	word [ss:CALLXADD], ax
		mov	ax, word [ss:SC_CACHE_PTR+2]
		mov	word [ss:CALLXADD+2], ax
		mov	byte [ss:SC_FLAG], 1
		mov	al, [ss:SC_DRIVE]
		mov	byte [ss:CurSC_DRIVE], al
		mov	ax, [ss:CALLSSEC]
		mov	word [ss:CurSC_SECTOR], ax
		mov	ax, [ss:HIGH_SECTOR]
		mov	word [ss:CurSC_SECTOR+2], ax

saveseq2:				; ...
		clc

saveseq:				; ...
		mov	ax, [ss:HIGH_SECTOR]
		mov	word [ss:SEQ_SECTOR+2], ax
		mov	ax, [ss:CALLSSEC]
		mov	word [ss:SEQ_SECTOR], ax
		jmp	short scexit
; ---------------------------------------------------------------------------

scexit2:				; ...
		clc

scexit:					; ...
		pop	di
		pop	es
		pop	si
		pop	ds
		pop	dx
		pop	cx
		retn

; =============== S U B	R O U T	I N E =======================================

IN_SC:		; ...
		mov	al, [ss:SC_DRIVE]
		cmp	al, [ss:CurSC_DRIVE]
		jnz	short outrange2
		mov	ax, [ss:HIGH_SECTOR]
		mov	cx, dx
		sub	cx, word [ss:CurSC_SECTOR]
		sbb	ax, word [ss:CurSC_SECTOR+2]
		cmp	ax, 0
		jnz	short outrange2
		cmp	cx, [ss:SC_CACHE_COUNT]
		jnb	short outrange2
		clc
		jmp	short inexit
; ---------------------------------------------------------------------------

outrange2:				; ...
		stc

inexit:					; ...
		retn

; =============== S U B	R O U T	I N E =======================================

INVALIDATE_SC:	; ...
		call	IN_SC
		jb	short outrange
		mov	ax, 1
		shl	ax, cl
		not	ax
		and	[ss:SC_STATUS],	ax

outrange:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================

VIRREAD:
		cmp	byte [ss:SC_FLAG], 0
		jz	short sc2end
		mov	ax, [ss:TEMP_VAR2]
		mov	word [ss:CALLXADD+2], ax
		mov	ax, [ss:TEMP_VAR]
		mov	word [ss:CALLXADD], ax
		mov	byte [ss:SC_FLAG], 0
		mov	word [ss:CALLSCNT], 1
		test	byte [ss:DEVCALL_REQSTAT+1], 80h ; (STERR>>8)
		jnz	short scerror
		push	ds
		push	si
		push	es
		push	di
		push	dx
		push	cx
		xor	cx, cx
		call	SC2BUF2
		pop	cx
		pop	dx
		pop	di
		pop	es
		pop	si
		pop	ds
		jmp	short sc2end
; ---------------------------------------------------------------------------

scerror:				; ...
		mov	word [ss:CALLSCNT], 1
		mov	word [ss:SC_STATUS], 0
		mov	byte [ss:CurSC_DRIVE], 0FFh ; -1
		stc
		retn
; ---------------------------------------------------------------------------

sc2end:					; ...
		clc
		retn

; ---------------------------------------------------------------------------

SC2BUF:					; ...
		call	IN_SC
		jb	short noSC
		mov	ax, 1
		shl	ax, cl
		test	[ss:SC_STATUS],	ax
		jz	short noSC

SC2BUF2:				; ...
		mov	ax, cx
		mul	word [ss:SC_SECTOR_SIZE]
		add	ax, word [ss:SC_CACHE_PTR]
		adc	dx, word [ss:SC_CACHE_PTR+2]
		mov	ds, dx
		mov	si, ax
		mov	es, word [ss:CALLXADD+2]
		mov	di, word [ss:CALLXADD]
		mov	cx, [ss:SC_SECTOR_SIZE]
		shr	cx, 1
		cmp	byte [ss:DDMOVE], 0
		jz	short nodd
		shr	cx, 1
; ---------------------------------------------------------------------------
		db 66h			; rep movsd (dword move	prefix)
; ---------------------------------------------------------------------------

nodd:					; ...
		rep movsw
		clc
		retn
; ---------------------------------------------------------------------------

noSC:					; ...
		stc
		retn

; =============== S U B	R O U T	I N E =======================================

BUILDDIR:		; ...
		mov	ax, [ENTFREE]
		cmp	ax, 0FFFFh	; -1
		jz	short CHECK_IF_ROOT
		clc
		retn
; ---------------------------------------------------------------------------

CHECK_IF_ROOT:				; ...
		cmp	word [DIRSTART], 0
		jnz	short NEWDIR
		stc

builddir_retn:				; ...
		retn
; ---------------------------------------------------------------------------

NEWDIR:					; ...
		mov	bx, [DIRSTART]
		or	bx, bx
		jz	short NULLDIR
		call	GETEOF
		jb	short builddir_retn

NULLDIR:				; ...
		mov	cx, 1
		call	ALLOCATE
		jb	short builddir_retn
		mov	dx, [DIRSTART]
		or	dx, dx
		jnz	short ADDINGDIR
		call	SETDIRSRCH
		jb	short builddir_retn
		mov	word [LASTENT], 0FFFFh ; -1
		jmp	short GOTDIRREC
; ---------------------------------------------------------------------------

ADDINGDIR:				; ...
		push	bx
		mov	bx, [CLUSNUM]
		call	IsEOF
		pop	bx
		jb	short NOTFIRSTGROW
		mov	[CLUSNUM], bx
		push	cx
		push	ax
		push	bp
		mov	ah, 1
		mov	dl, [es:bp+0]	; [ES:BP+DPB.DRIVE]
		mov	cx, [DIRSTART]
		mov	bp, bx
		call	FastOpen_Update
		pop	bp
		pop	ax
		pop	cx

NOTFIRSTGROW:				; ...
		mov	dx, bx
		xor	bl, bl
		call	FIGREC

GOTDIRREC:				; ...
		mov	cl, [es:bp+4]	; [ES:BP+DPB.CLUSTER_MASK]
		inc	cl
		xor	ch, ch

ZERODIR:				; ...
		push	cx
		mov	byte [ALLOWED], 18h ; Allowed_FAIL+Allowed_RETRY
		mov	al, 0FFh
		call	GETBUFFR
		jnb	short GET_SSIZE
		pop	cx
		retn
; ---------------------------------------------------------------------------

GET_SSIZE:				; ...
		mov	cx, [es:bp+2]	; [ES:BP+DPB.SECTOR_SIZE]
		push	es
		les	di, [CURBUF]
		or	byte [es:di+5], 4 ;	[ES:DI+BUFFINFO.buf_flags],
					; buf_isDIR
		push	di
		add	di, 20		; BUFINSIZ
		xor	ax, ax
		shr	cx, 1
		rep stosw
		jnb	short EVENZ
		stosb

EVENZ:					; ...
		pop	di
		test	byte [es:di+5], 40h	; [ES:DI+BUFFINFO.buf_flags],
					; buf_dirty
		jnz	short yesdirty7
		call	INC_DIRTY_COUNT
		or	byte [es:di+5], 40h

yesdirty7:				; ...
		pop	es
		pop	cx
		add	dx, 1
		adc	word [HIGH_SECTOR], 0
		loop	ZERODIR
		mov	ax, [LASTENT]
		inc	ax
		clc
		retn

; =============== S U B	R O U T	I N E =======================================

SETDOTENT:		; ...
		stosw
		mov	cx, 4
		mov	ax, 2020h	; '  '
		rep stosw
		stosb
		mov	al, 10h		; attr_directory
		stosb
		add	di, 10
		mov	si, word [THISSFT]
		mov	ax, [si+0Dh]	; [SI+SF_ENTRY.sf_time]
		stosw
		mov	ax, [si+0Fh]	; [SI+SF_ENTRY.sf_date]
		stosw
		mov	ax, dx
		stosw
		xor	ax, ax
		stosw
		stosw
		retn

; ---------------------------------------------------------------------------

MakeNode:				; ...
		mov	word [CREATING], 0E5FFh ; DIRFREE*256 + 0FFh
		push	ax
		mov	byte [NoSetDir], 0
		mov	[SATTRIB], al
		call	GetPathNoSet
		mov	dl, cl
		mov	cx, ax
		pop	ax
		jnb	short make_exists
		jnz	short make_err_4
		cmp	dl, 80h
		jz	short RENAME_MAKE ; make_type

make_err_4:				; ...
		mov	al, 4

make_err_ret:				; ...
		xor	ah, ah
		stc
		retn
; ---------------------------------------------------------------------------

RENAME_MAKE:				; ...
		test	byte [EXTOPEN_ON], 1 ; make_type
					; EXT_OPEN_ON
		jz	short make_type2
		or	byte [EXTOPEN_ON], 4 ; EXT_FILE_NOT_EXISTS
		test	byte [EXTOPEN_FLAG], 0F0h
		jnz	short make_type2
		stc
		mov	ax, 7

; =============== S U B	R O U T	I N E =======================================

make_retn:		; ...
		retn
; ---------------------------------------------------------------------------

make_type2:				; ...
		les	di, [THISSFT]
		xor	ax, ax
		stc
		jmp	short make_new
; ---------------------------------------------------------------------------

make_exists:				; ...
		jz	short make_exists_dir
		mov	al, 3
		test	byte [ATTRIB], 18h ; attr_volume_id+attr_directory
		jnz	short make_err_ret_5
		or	ch, ch
		js	short make_share
		or	ah, ah
		jnz	short make_err_ret
		push	cx
		mov	es, word [CURBUF+2]
		mov	ch, [es:bx+0Bh]	; [ES:BX+dir_entry.dir_attr]
		test	ch, 1
		jnz	short make_err_ret_5P
		call	MatchAttributes
		pop	cx
		jnz	short make_err_ret_5
		xor	al, al

make_share:				; ...
		xor	ah, ah
		push	ax
		push	cx
		mov	ah, ch
		call	DOOPEN
		les	di, [THISSFT]
		push	si
		push	bx
		call	ShareEnter
		jnb	short MakeEndShare
		pop	bx
		pop	si
		pop	cx
		pop	ax

Make_Share_ret:				; ...
		mov	al, 6
		jmp	short make_err_ret
; ---------------------------------------------------------------------------

make_err_ret_5P:			; ...
		pop	cx

make_err_ret_5:				; ...
		mov	al, 5
		jmp	short make_err_ret
; ---------------------------------------------------------------------------

make_exists_dir:			; ...
		mov	al, 1
		jmp	short make_err_ret

; =============== S U B	R O U T	I N E =======================================

make_save:		; ...
		push	ax
		mov	ax, cx
		call	NEWENTRY
		pop	ax
		jnb	short make_retn
		mov	al, 2

make_save_retn:				; ...
		retn

; ---------------------------------------------------------------------------

make_new:				; ...
		call	make_save
		jb	short make_save_retn
		test	byte [ATTRIB], 10h ; attr_directory
		jnz	short make_save_retn
		push	ax
		push	bx
		push	si
		call	ShareEnter
		pop	si
		pop	bx
		pop	ax
		jnb	short make_save_retn
		push	ax
		les	di, [CURBUF]
		mov	byte [es:bx], 0E5h ; DIRFREE
		test	byte [es:di+5], 40h	; [ES:DI+BUFFINFO.buf_flags],
					; buf_dirty
		jnz	short yesdirty8
		call	INC_DIRTY_COUNT
		or	byte [es:di+5], 40h

yesdirty8:				; ...
		les	bp, [THISDPB]
		mov	al, [es:bp+0]	; [ES:BP+DPB.DRIVE]
		call	FLUSHBUF
		pop	ax
		jmp	short Make_Share_ret
; ---------------------------------------------------------------------------

MakeEndShare:				; ...
		les	di, [THISSFT]
		xor	ax, ax
		call	ECritDisk	; call ECritSFT
		xchg	ax, [es:di]	; [ES:DI+SF_ENTRY.sf_ref_count]
		push	ax
		push	di
		push	es
		pushf
		call	ShareEnd
		popf
		pop	es
		pop	di
		pop	word [es:di] ; [ES:DI+SF_ENTRY.sf_ref_count]
		call	LCritDisk	; call LCritSFT
		pop	bx
		pop	si
		pop	cx
		pop	ax
		call	make_save
		jb	short make_save_retn
		push	ax
		push	bx
		push	si
		pushf
		call	ShareEnter
		popf
		pop	si
		pop	bx
		pop	ax

makeendshare_retn:			; ...
		retn

; =============== S U B	R O U T	I N E =======================================

NEWENTRY:		; ...
		les	bp, [THISDPB]
		jnb	short EXISTENT
		cmp	byte [FAILERR], 0
		stc
		jnz	short makeendshare_retn
		call	BUILDDIR
		jb	short makeendshare_retn
		call	GETENT
		jb	short makeendshare_retn
		jmp	short FREESPOT
; ---------------------------------------------------------------------------

ERRRET3:				; ...
		stc

newentry_retn:				; ...
		retn
; ---------------------------------------------------------------------------

EXISTENT:				; ...
		or	ah, ah
		jns	short NOT_DEV1
		jmp	DOOPEN
; ---------------------------------------------------------------------------

NOT_DEV1:				; ...
		call	FREEENT
		jb	short newentry_retn

FREESPOT:				; ...
		test	byte [ATTRIB], 8 ; attr_volume_id
		jz	short NOTVOLID
		cmp	byte [VOLID], 0
		jnz	short ERRRET3

NOTVOLID:				; ...
		mov	es, word [CURBUF+2]
		mov	di, bx
		mov	si, NAME1
		mov	cx, 5
		rep movsw
		movsb
		mov	al, [ATTRIB]
		stosb
		mov	cl, 5
		xor	ax, ax
		rep stosw
		call	DATE16
		xchg	ax, dx
		stosw
		xchg	ax, dx
		stosw
		xor	ax, ax
		push	di
		stosw
		stosw
		stosw
		mov	si, word [CURBUF]
		test	byte [es:si+5], 40h ; [ES:SI+BUFFINFO.buf_flags],
					; buf_dirty
		jnz	short yesdirty9
		call	INC_DIRTY_COUNT
		or	byte [es:si+5], 40h

yesdirty9:				; ...
		les	bp, [THISDPB]
		mov	al, [es:bp+0]	; [ES:BP+DPB.DRIVE]
		push	ax
		push	bx
		push	es
		push	di
		les	di, [THISSFT]
		test	byte [es:di+5], 80h ; [ES:DI+SF_ENTRY.sf_flags],
					; devid_device
		jnz	short GotADevice
		push	ds
		push	bx
		lds	bx, [THISDPB]
		mov	[es:di+7], bx	; [ES:DI+SF_ENTRY.sf_devptr]
		mov	bx, ds
		mov	[es:di+9], bx	; [ES:DI+SF_ENTRY.sf_devptr+2]
		pop	bx
		pop	ds
		call	DEV_OPEN_SFT
		mov	byte [VIRTUAL_OPEN], 1

GotADevice:				; ...
		pop	di
		pop	es
		call	FLUSHBUF
		call	CHECK_VIRT_OPEN
		pop	bx
		pop	ax
		pop	si
		mov	ah, al
		jnb	short DOOPEN
		retn

; =============== S U B	R O U T	I N E =======================================

DOOPEN:		; ...
		mov	dh, ah
		les	di, [THISSFT]
		add	di, 4		; SF_ENTRY.sf_attr
		xor	al, al
		or	dh, dh
		js	short DEV_SFT
		mov	ds, word [CURBUF+2]
		mov	al, [bx+0Bh]	; [BX+dir_entry.dir_attr]

DEV_SFT:				; ...
		stosb
		xor	ax, ax
		mov	al, dh
		or	al, 40h		; devid_file_clean
		stosw
		push	ds
		lds	ax, [bx+1Ah]	; [BX+dir_entry.dir_first]
		or	dh, dh
		js	short DEV_SFT2
		lds	ax, [ss:THISDPB]

DEV_SFT2:				; ...
		stosw
		mov	ax, ds
		pop	ds
		stosw
		push	si
		movsw
		sub	si, 6		; dir_entry.dir_size_l - dir_entry.dir_time
		movsw
		movsw
		lodsw
		lodsw
		mov	cx, ax
		lodsw
		or	dh, dh
		jns	short FILE_SFT1
		xor	ax, ax
		mov	cx, ax

FILE_SFT1:				; ...
		xchg	ax, cx
		stosw
		xchg	ax, cx
		stosw
		xor	ax, ax
		stosw
		stosw
		or	dh, dh
		js	short DEV_SFT3
		stosw
		mov	ax, [bx+1Ah]	; [BX+dir_entry.dir_first]
		push	di
		sub	di, 1Bh		; SF_ENTRY.sf_dirsec
		mov	[es:di+35h], ax	; [ES:DI+SF_ENTRY.sf_lstclus]
		pop	di
		push	ds
		push	ss
		pop	ds
		test	byte [FastOpenFlg], 4 ; Special_Fill_Set
		jz	short Not_FastOpen
		mov	si, FastOpen_Ext_Info
		mov	ax, [si+1]	; [SI+FEI.dirsec]
		stosw
		mov	ax, [si+3]	; [SI+FEI.dirsec+2]
		stosw
		mov	al, [si]	; [SI+FEI.dirpos]
		stosb
		pop	ds
		jmp	short Next_Name
; ---------------------------------------------------------------------------

Not_FastOpen:				; ...
		pop	ds
		mov	si, word [ss:CURBUF]
		mov	ax, [si+6]	; [SI+BUFFINFO.buf_sector]
		stosw
		mov	ax, [si+8]	; [SI+BUFFINFO.buf_sector+2]
		stosw
		mov	ax, bx
		add	si, 20		; BUFINSIZ
		sub	ax, si
		mov	cl, 32		; dir_entry.size
		div	cl
		stosb

Next_Name:				; ...
		jmp	short FILE_SFT2
; ---------------------------------------------------------------------------

DEV_SFT3:				; ...
		add	di, 7		; SF_ENTRY.sf_name-SF_ENTRY.sf_cluspos

FILE_SFT2:				; ...
		mov	si, bx
		mov	cx, 11
		rep movsb
		pop	si
		push	ss
		pop	ds
		clc
		retn

; =============== S U B	R O U T	I N E =======================================

FREEENT:
		push	ds
		lds	di, [CURBUF]
		mov	cx, [si]
		mov	dx, [di+8]	; [DI+BUFFINFO.buf_sector+2]
		mov	word [ss:HIGH_SECTOR], dx
		mov	dx, [di+6]	; [DI+BUFFINFO.buf_sector]
		pop	ds
		cmp	cx, 2
		jb	short RET1
		cmp	cx, [es:bp+0Dh]	; [ES:BP+DPB.MAX_CLUSTER]
		ja	short RET1
		sub	bx, di
		push	bx
		push	word [HIGH_SECTOR]
		push	dx
		mov	bx, cx
		call	RELEASE
		pop	dx
		pop	word [HIGH_SECTOR]
		jnb	short GET_BUF_BACK
		pop	bx

freeent_retn:				; ...
		retn
; ---------------------------------------------------------------------------

GET_BUF_BACK:				; ...
		mov	byte [ALLOWED], 18h ; Allowed_RETRY+Allowed_FAIL
		xor	al, al
		call	GETBUFFR
		pop	bx
		jb	short freeent_retn
		call	SET_BUF_AS_DIR
		add	bx, [5E2h]
		mov	si, bx
		add	si, 1Ah

RET1:					; ...
		clc
		retn

; =============== S U B	R O U T	I N E =======================================

CHECK_VIRT_OPEN:
		push	ax
		lahf
		cmp	byte [VIRTUAL_OPEN], 0
		jz	short ALL_CLOSED
		mov	byte [VIRTUAL_OPEN], 0
		push	es
		push	di
		les	di, [THISSFT]
		call	DEV_CLOSE_SFT
		pop	di
		pop	es

ALL_CLOSED:				; ...
		sahf
		pop	ax
		retn

; =============== S U B	R O U T	I N E =======================================

FNDCLUS:
		push	es
		les	di, [THISSFT]
		mov	bx, [es:di+35h]	; [ES:DI+SF_ENTRY.sf_lstclus]
		mov	dx, [es:di+19h]	; [ES:DI+SF_ENTRY.sf_cluspos]
		or	bx, bx
		jz	short NOCLUS
		sub	cx, dx
		jnb	short FINDIT
		add	cx, dx
		xor	dx, dx
		mov	bx, [es:di+0Bh]	; [ES:DI+SF_ENTRY.sf_firclus]

FINDIT:					; ...
		pop	es
		jcxz	RET9

SKPCLP:					; ...
		call	UNPACK
		jb	short fndclus_retn
		xchg	bx, di
		call	IsEOF
		xchg	bx, di
		jnb	short RET9
		xchg	bx, di
		inc	dx
		loop	SKPCLP

RET9:					; ...
		clc
		retn
; ---------------------------------------------------------------------------

NOCLUS:					; ...
		pop	es
		inc	cx
		dec	dx
		clc

fndclus_retn:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn

BUFSEC:		; ...
		mov	dx, [CLUSNUM]
		mov	bl, [SECCLUSPOS]
		mov	byte [ALLOWED], 38h ; Allowed_FAIL+Allowed_RETRY+Allowed_IGNORE
		call	FIGREC
		call	GETBUFFR
		jb	short fndclus_retn
		mov	byte [TRANS], 1
		mov	si, [NEXTADD]
		mov	di, si
		mov	cx, [BYTCNT1]
		add	di, cx
		mov	[NEXTADD], di
		les	di, [CURBUF]
		or	byte [es:di+5], 8 ; [ES:DI+BUFFINFO.buf_flags],
					; buf_isDATA
		lea	di, [di+20]	; LEA DI,[DI+BUFINSIZ]
		add	di, [BYTSECPOS]
		clc
		retn

; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn

BUFRD:		; ...
		push	es
		xor	ax, ax
		call	BUFSEC

; ---------------------------------------------------------------------------
		jnb	short BUF_OK
; START	OF FUNCTION CHUNK FOR BUFWRT

BUF_IO_FAIL:				; ...
		pop	es
		jmp	short RBUFPLACED
; END OF FUNCTION CHUNK	FOR BUFWRT
; ---------------------------------------------------------------------------

BUF_OK:					; ...
		mov	bx, es
		mov	es, word [DMAADD+2]
		mov	ds, bx
		xchg	di, si
		shr	cx, 1
		rep movsw
		adc	cx, 0
		rep movsb

EVENRD:
		pop	es
		lds	di, [ss:CURBUF]
		lea	bx, [di+20]	; LEA BX,[DI+BUFINSIZ]
		sub	si, bx
		call	PLACEBUF
		cmp	si, [es:bp+2]	; [ES:BP+DPB.SECTOR_SIZE]
		jb	short RBUFPLACEDC
		mov	word [ss:BufferQueue], di

RBUFPLACEDC:				; ...
		clc
; START	OF FUNCTION CHUNK FOR BUFWRT

RBUFPLACED:				; ...
		push	ss
		pop	ds
		retn
; END OF FUNCTION CHUNK	FOR BUFWRT

; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn

BUFWRT:		; ...

; FUNCTION CHUNK AT 8C35 SIZE 00000003 BYTES
; FUNCTION CHUNK AT 8C65 SIZE 00000003 BYTES

		mov	ax, word [SECPOS]
		add	ax, 1
		mov	word [SECPOS], ax
		adc	word [SECPOS+2],	0
		mov	ax, word [SECPOS+2]
		cmp	ax, word [VALSEC+2]
		mov	al, 1
		ja	short NOREAD
		jb	short _doread
		mov	ax, word [SECPOS]
		cmp	ax, word [VALSEC]
		mov	al, 1
		ja	short NOREAD

_doread:				; ...
		xor	al, al

NOREAD:					; ...
		push	es
		call	BUFSEC
; ---------------------------------------------------------------------------
		jb	short BUF_IO_FAIL
		mov	ds, word [DMAADD+2]
		shr	cx, 1
		rep movsw
		adc	cx, 0
		rep movsb

EVENWRT:
		pop	es
		lds	bx, [ss:CURBUF]
		test	byte [bx+5], 40h
		jnz	short yesdirty10
		call	INC_DIRTY_COUNT
		or	byte [bx+5], 40h ; [BX+BUFFINFO.buf_flags],
					; buf_dirty

yesdirty10:				; ...
		lea	si, [bx+20]	; LEA BX,[BX+BUFINSIZ]
		sub	di, si
		cmp	di, [es:bp+2]	; [ES:BP+DPB.SECTOR_SIZE]
		jb	short WBUFPLACED
		mov	word [ss:BufferQueue], bx

WBUFPLACED:				; ...
		clc
		push	ss
		pop	ds
		retn

; =============== S U B	R O U T	I N E =======================================

NEXTSEC:
		test	byte [TRANS], 0FFh ; -1
		jz	short CLRET
		mov	al, [SECCLUSPOS]
		inc	al
		cmp	al, [es:bp+4]	; [ES:BP+DPB.CLUSTER_MASK]
		jbe	short SAVPOS
		mov	bx, [CLUSNUM]
		call	IsEOF
		jnb	short NONEXT
		call	UNPACK
		jb	short NONEXT
		mov	[CLUSNUM], di
		inc	word [LASTPOS]
		mov	al, 0

SAVPOS:					; ...
		mov	[SECCLUSPOS], al

CLRET:					; ...
		clc
		retn
; ---------------------------------------------------------------------------

NONEXT:					; ...
		stc
		retn

; =============== S U B	R O U T	I N E =======================================

OPTIMIZE:		; ...
		push	dx
		push	bx
		mov	al, [es:bp+4]	; [ES:BP+DPB.CLUSTER_MASK]
		inc	al
		mov	ah, al
		sub	al, dl
		mov	dx, cx
		mov	cx, 0

do_norm3:				; ...
		call	UNPACK		; OPTCLUS
		jb	short OP_ERR
		add	cl, al
		adc	ch, 0
		cmp	cx, dx
		jnb	short BLKDON
		mov	al, ah
		inc	bx
		cmp	di, bx
		jz	short do_norm3	; OPTCLUS
		dec	bx

FINCLUS:				; ...
		mov	[CLUSNUM], bx
		sub	dx, cx
		push	dx
		mov	ax, cx
		mul	word [es:bp+2] ; [ES:BP+DPB.SECTOR_SIZE]
		mov	si, [NEXTADD]
		add	ax, si
		mov	[NEXTADD], ax
		pop	ax
		pop	dx
		sub	bx, dx
		add	[LASTPOS], bx
		pop	bx
		call	FIGREC
		mov	bx, si
		clc
		retn
; ---------------------------------------------------------------------------

OP_ERR:					; ...
		add	sp, 4
		stc
		retn
; ---------------------------------------------------------------------------

BLKDON:					; ...
		sub	cx, dx
		sub	ah, cl
		dec	ah
		mov	[SECCLUSPOS], ah
		mov	cx, dx
		jmp	short FINCLUS

; =============== S U B	R O U T	I N E =======================================

FIGREC:		; ...
		push	cx
		mov	cl, [es:bp+5]	; [ES:BP+DPB.CLUSTER_SHIFT]
		dec	dx
		dec	dx
		mov	word [ss:HIGH_SECTOR], 0
		or	cl, cl
		jz	short noshift
		xor	ch, ch

rotleft:				; ...
		clc
		rcl	dx, 1
		rcl	word [ss:HIGH_SECTOR], 1
		loop	rotleft

noshift:				; ...
		or	dl, bl
		add	dx, [es:bp+0Bh]	; [ES:BP+DPB.FIRST_SECTOR]
		adc	word [ss:HIGH_SECTOR], 0
		pop	cx

figrec_retn:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================

ALLOCATE:		; ...
		push	bx
		xor	bx, bx
		call	UNPACK
		mov	[FATBYT], di
		pop	bx
		jb	short figrec_retn
		push	cx
		push	bx
		mov	dx, bx
		mov	bx, [es:bp+1Dh]	; [ES:BP+DPB.NEXT_FREE]
		cmp	bx, 2
		ja	short FINDFRE

ads1:					; ...
		mov	word [es:bp+1Dh], 2	; [ES:BP+DPB.NEXT_FREE]
		mov	bx, 1

FINDFRE:				; ...
		inc	bx
		cmp	bx, [es:bp+0Dh]	; [ES:BP+DPB.MAX_CLUSTER]
		ja	short ads7
		call	UNPACK
		jb	short ads4
		jnz	short FINDFRE
		mov	[es:bp+1Dh], bx	; [ES:BP+DPB.NEXT_FREE]
		xchg	ax, dx
		mov	dx, 1
		call	PACK
		jb	short ads4
		cmp	word [es:bp+1Fh], 0FFFFh ; [ES:BP+DPB.FREE_CNT],-1
		jz	short NO_ALLOC
		dec	word [es:bp+1Fh] ; [ES:BP+DPB.FREE_CNT]

NO_ALLOC:				; ...
		xchg	ax, dx
		xchg	bx, dx
		mov	ax, dx
		call	PACK
		jb	short ads4
		xchg	ax, bx
		mov	dx, bx
		loop	FINDFRE
		mov	dx, 0FFFFh
		call	PACK

ads4:					; ...
		pop	bx
		pop	cx
		jb	short figrec_retn
		call	UNPACK
		jb	short figrec_retn
		call	RESTFATBYT
		jb	short figrec_retn
		xchg	bx, di
		or	di, di
		jnz	short figrec_retn
		push	dx
		mov	dl, [es:bp+0]	; [ES:BP+DPB.DRIVE]
		push	es
		les	di, [THISSFT]
		mov	[es:di+0Bh], bx	; [ES:DI+SF_ENTRY.sf_firclus]
		mov	[es:di+35h], bx	; [ES:DI+SF_ENTRY.sf_lstclus]
		pop	es
		pop	dx
		retn
; ---------------------------------------------------------------------------

ads7:					; ...
		cmp	word [es:bp+1Dh], 2	; [ES:BP+DPB.NEXT_FREE]
		jnz	short ads1
		pop	bx
		mov	dx, 0FFFFh
		call	RELBLKS
		pop	ax
		sub	ax, cx
		call	RESTFATBYT
		mov	byte [DISK_FULL], 1
		stc
		retn

; =============== S U B	R O U T	I N E =======================================

RESTFATBYT:		; ...
		push	bx
		push	dx
		push	di
		xor	bx, bx
		mov	dx, [FATBYT]
		call	PACK
		pop	di
		pop	dx
		pop	bx

RELEASE_flush:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================

RELEASE:
		xor	dx, dx

RELBLKS:				; ...
		call	UNPACK
		jb	short RELEASE_flush
		jz	short RELEASE_flush
		mov	ax, di
		push	dx
		call	PACK
		pop	dx
		jb	short RELEASE_flush
		or	dx, dx
		jnz	short NO_DEALLOC
		cmp	word [es:bp+1Fh], 0FFFFh
		jz	short NO_DEALLOC
		inc	word [es:bp+1Fh]

NO_DEALLOC:				; ...
		mov	bx, ax
		dec	ax
		jz	short RELEASE_flush
		call	IsEOF
		jb	short RELEASE

RET12:					; ...
		retn

; =============== S U B	R O U T	I N E =======================================

GETEOF:		; ...
		call	UNPACK
		jb	short RET12
		push	bx
		mov	bx, di
		call	IsEOF
		pop	bx
		jnb	short RET12
		mov	bx, di
		jmp	short GETEOF

; =============== S U B	R O U T	I N E =======================================

MAKEFCB:
		mov	byte [ss:SpaceFlag], 0
		xor	dl, dl
		test	al, 2		; DRVBIT
		jnz	short DEFDRV
		mov	byte [es:di], 0

DEFDRV:					; ...
		inc	di
		mov	cx, 8
		test	al, 4		; NAMBIT
		xchg	ax, bx
		mov	al, 20h	; ' '
		jz	short FILLB
		add	di, cx
		xor	cx, cx

FILLB:					; ...
		rep stosb
		mov	cl, 3
		test	bl, 8		; EXTBIT
		jz	short FILLB2
		add	di, cx
		xor	cx, cx

FILLB2:					; ...
		rep stosb
		xchg	ax, cx
		stosw
		stosw
		sub	di, 16
		test	bl, 1		; SCANSEPARATOR
		jz	short SKPSPC
		call	SCANB
		call	DELIM
		jnz	short NOSCAN
		inc	si

SKPSPC:					; ...
		call	SCANB

NOSCAN:					; ...
		call	GETLET
		jbe	short NODRV
		cmp	byte [si], ':'
		jnz	short NODRV
		inc	si
		sub	al, '@'
		jbe	short BADDRV
		push	ax
		call	GetVisDrv
		pop	ax
		jnb	short HAVDRV
		cmp	byte [ss:DrvErr], 1Ah ; error_not_DOS_disk
		jz	short HAVDRV

BADDRV:					; ...
		mov	dl, 0FFh	; -1

HAVDRV:					; ...
		stosb
		inc	si
		dec	di

NODRV:					; ...
		dec	si
		inc	di

NORMSCAN:				; ...
		mov	cx, 8
		call	GETWORD
		cmp	byte [si], '.'
		jnz	short NODOT
		inc	si
		test	byte [ss:DOS34_FLAG+1], 1 ;	(DBCS_VOLID2>>8)
		jz	short VOLOK
		movsb
		mov	cx, 2
		jmp	short contvol
; ---------------------------------------------------------------------------

VOLOK:					; ...
		mov	cx, 3

contvol:				; ...
		call	MUSTGETWORD

NODOT:					; ...
		mov	al, dl
		and	word [ss:DOS34_FLAG], 0FEFFh ; ~DBCS_VOLID2
		retn

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR GETWORD

NONAM:					; ...
		add	di, cx
		dec	si
		retn
; END OF FUNCTION CHUNK	FOR GETWORD

; =============== S U B	R O U T	I N E =======================================

GETWORD:

; FUNCTION CHUNK AT 8F0B SIZE 00000004 BYTES

		call	GETLET
		jbe	short NONAM
		dec	si

MUSTGETWORD:				; ...
		call	GETLET
		jnz	short MustCheckCX
		test	byte [ss:SpaceFlag], 0FFh
		jz	short FILLNAM
		cmp	al, 20h	; ' '
		jnz	short FILLNAM

MustCheckCX:				; ...
		jcxz	MUSTGETWORD
		dec	cx
		cmp	al, 2Ah	; '*'
		jnz	short NOSTAR
		mov	al, 3Fh	; '?'
		rep stosb

NOSTAR:					; ...
		stosb
		cmp	al, 3Fh	; '?'
		jnz	short MUSTGETWORD
		or	dl, 1
		jmp	short MUSTGETWORD
; ---------------------------------------------------------------------------

FILLNAM:				; ...
		mov	al, 20h	; ' '
		rep stosb
		dec	si
		retn

; =============== S U B	R O U T	I N E =======================================

SCANB:		; ...
		lodsb
		call	SPCHK
		jz	short SCANB
		dec	si

scanb_retn:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================

NameTrans:		; ...
		mov	byte [ss:SpaceFlag], 1
		push	ss
		pop	es
		mov	di, NAME1
		push	di
		mov	ax, 2020h	; '  '
		mov	cx, 5
		stosb
		rep stosw
		xor	al, al
		mov	dl, al
		stosb
		pop	di
		call	NORMSCAN
		cmp	byte [ss:NAME1], 0E5h
		jnz	short scanb_retn
		mov	byte [ss:NAME1], 5
		retn

; ---------------------------------------------------------------------------
CharType	db 66h,66h,66h,66h, 6,66h,66h,66h ; ...
		db 66h,66h,66h,66h,66h,66h,66h,66h
		db 0F8h,0F6h,0FFh,0FFh,0FFh,4Fh,0F4h,6Eh
		db 0FFh,0FFh,0FFh,0FFh,0FFh,44h,44h,0F4h
		db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
		db 0FFh,0FFh,0FFh,0FFh,0FFh,6Fh,66h,0FFh
		db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
		db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0F4h
; ---------------------------------------------------------------------------

GETLET:					; ...
		lodsb

; =============== S U B	R O U T	I N E =======================================

UCase:		; ...
		push	bx
		mov	bx, FILE_UCASE_TAB_2 ; FILE_UCASE_TAB+2

gl_0:					; ...
		cmp	al, 'a'         ; 61h
		jb	short gl_2
		cmp	al, 'z'         ; 7Ah
		ja	short gl_1
		sub	al, 20h

gl_1:					; ...
		cmp	al, 80h
		jb	short gl_2
		sub	al, 80h
		push	ds
		mov	ds, [cs:DosDSeg]
		xlat
		pop	ds

gl_2:					; ...
		push	ax
		call	GetCharType
		test	al, 1		; FCHK
		pop	ax
		pop	bx
		retn

; =============== S U B	R O U T	I N E =======================================

 GETLET3:
		push	bx
		jmp	short gl_0

; =============== S U B	R O U T	I N E =======================================

 DELIM:		; ...
		push	ax
		call	GetCharType
		test	al, 2		; FDELIM
		pop	ax
		retn

; =============== S U B	R O U T	I N E =======================================

 SPCHK:		; ...
		push	ax
		call	GetCharType
		test	al, 4		; FSPCHK
		pop	ax
		retn

; =============== S U B	R O U T	I N E =======================================

GetCharType:	; ...
		cmp	al, 7Eh	; '~'   ; CharType_last
		jnb	short gct_90
		push	bx
		mov	bx, CharType
		shr	al, 1
		;xlat	byte [cs:bx] ; cs xlat
		cs
		xlat
		pop	bx
		jnb	short gct_80
		shr	al, 1
		shr	al, 1
		shr	al, 1
		shr	al, 1

gct_80:					; ...
		and	al, 0Fh
		retn
; ---------------------------------------------------------------------------

gct_90:					; ...
		mov	al, 0Fh
		retn

; =============== S U B	R O U T	I N E =======================================

PATHCHRCMP:		; ...
		cmp	al, 2Fh	; '/'
		jbe	short PathRet
		cmp	al, 5Ch	; '\'
		retn
; ---------------------------------------------------------------------------

GotFor:					; ...
		mov	al, 5Ch	; '\'
		retn
; ---------------------------------------------------------------------------

PathRet:				; ...
		jz	short GotFor
		retn

; ---------------------------------------------------------------------------
LowInt23Addr	dw LowInt23	; ...
LowInt23Seg	dw 0			; ...
LowInt24Addr	dw LowInt24	; ...
LowInt24Seg	dw 0			; ...
LowInt28Addr	dw LowInt28	; ...
LowInt28Seg	dw 0			; ...

; =============== S U B	R O U T	I N E =======================================

DSKSTATCHK:		; ...
		cmp	byte [ss:INDOS], 1
		jz	short _RET37
		retn
; ---------------------------------------------------------------------------

_RET37:					; ...
		push	cx
		push	es
		push	bx
		push	ds
		push	si
		mov	bx, ss
		mov	es, bx
		mov	ds, bx
		mov	byte [ss:DSKSTCOM], 5 ; DEVRDND
		mov	byte [ss:DSKSTCALL], 14 ; DRDNDHL
		mov	word [ss:DSKSTST], 0
		mov	bx, DSKSTCALL
		lds	si, [ss:BCON]
		call	DEVIOCALL2
		test	byte [ss:DSKSTST+1], 2 ; (STBUI>>8)
		jz	short _GotCh
		xor	al, al

RET36:					; ...
		pop	si
		pop	ds
		pop	bx
		pop	es
		pop	cx
		retn
; ---------------------------------------------------------------------------

_GotCh:					; ...
		mov	al, [ss:DSKCHRET]
		cmp	al, 3		; "C"-"@"
		jnz	short RET36
		mov	byte [ss:DSKSTCOM], 4 ; DEVRD
		mov	byte [ss:DSKSTCALL], 22 ; DRDWRHL
		mov	[ss:DSKCHRET], cl
		mov	word [ss:DSKSTST], 0
		mov	word [ss:DSKSTCNT], 1
		call	DEVIOCALL2
		pop	si
		pop	ds
		pop	bx
		pop	es
		pop	cx
		jmp	CNTCHAND

; ---------------------------------------------------------------------------

NOSTOP:					; ...
		cmp	al, 10h		; "P"-"@"
		jnz	short check_next
		cmp	byte [ss:SCAN_FLAG], 0
		jz	short INCHKJ
		retn
; ---------------------------------------------------------------------------

check_next:				; ...
		cmp	al, 3		; "C"-"@"
		jz	short INCHKJ

check_end:				; ...
		retn
; ---------------------------------------------------------------------------

INCHKJ:					; ...
		jmp	INCHK

; =============== S U B	R O U T	I N E =======================================

SPOOLINT:
		pushf
		cmp	byte [ss:IDLEINT], 0
		jz	short POPFRET
		cmp	byte [ss:ERRORMODE], 0
		jnz	short POPFRET
		push	word [ss:IDLEINT]
		cmp	byte [ss:DosHasHMA], 0
		jnz	short do_low_int28
		int	28h		; DOS 2+ internal - KEYBOARD BUSY LOOP
		jmp	short spool_ret_addr
; ---------------------------------------------------------------------------

do_low_int28:				; ...
		;call	dword [cs:LowInt28Addr] ; call far [cs:LowInt28Addr]
		call	far [cs:LowInt28Addr]
spool_ret_addr:				; ...
		pop	word [ss:IDLEINT]

POPFRET:				; ...
		popf

_RET18:					; ...
		retn

; ---------------------------------------------------------------------------

STATCHK:				; ...
		call	DSKSTATCHK
		push	bx
		xor	bx, bx
		call	GET_IO_SFT
		pop	bx
		jb	short _RET18
		mov	ah, 1
		call	IOFUNC
		jz	short SPOOLINT
		cmp	al, 13h		; 'S'-'@'
		jnz	short NOSTOP
		cmp	byte [ss:SCAN_FLAG], 0
		jnz	short check_end
		xor	ah, ah
		call	IOFUNC
		jmp	short PAUSOSTRT
; ---------------------------------------------------------------------------

PRINT_ON_OFF:				; ...
		not	byte [ss:PFLAG]
		push	bx
		mov	bx, 4
		call	GET_IO_SFT
		pop	bx
		jb	short _RET18
		push	es
		push	di
		push	ds
		pop	es
		mov	di, si
		test	byte [es:di+6], 8 ;	[ES:DI+SF_ENTRY.sf_flags+1],
					; (sf_net_spool>>8)
		jz	short NORM_PR
		push	ax
		mov	ax, 1126h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - ???
					; Return: CF set on error, AX =	error code
					; STACK	unchanged
		pop	ax
		jnb	short NORM_PR
		mov	byte [ss:PFLAG], 0
		push	ax
		mov	ax, 1124h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - ???
					; ES:DI	-> SFT,	SS = DOS CS
		pop	ax
		jmp	short RETP6
; ---------------------------------------------------------------------------

NORM_PR:				; ...
		cmp	byte [ss:PFLAG], 0
		jnz	short PRNOPN
		call	DEV_CLOSE_SFT
		jmp	short RETP6
; ---------------------------------------------------------------------------

PRNOPN:					; ...
		call	DEV_OPEN_SFT

RETP6:					; ...
		pop	di
		pop	es

STATCHK_RETN:				; ...
		retn
; ---------------------------------------------------------------------------

PAUSOLP:				; ...
		call	SPOOLINT

PAUSOSTRT:				; ...
		mov	ah, 1
		call	IOFUNC
		jz	short PAUSOLP

INCHK:					; ...
		push	bx
		xor	bx, bx
		call	GET_IO_SFT
		pop	bx
		jb	short STATCHK_RETN
		xor	ah, ah
		call	IOFUNC
		cmp	al, 10h		; "P"-"@"
		jz	short PRINT_ON_OFF ; PRINTON
		cmp	al, 3		; "C"-"@"
		jnz	short STATCHK_RETN

CNTCHAND:				; ...
		test	byte [ss:DOS34_FLAG+1], 2 ; (CTRL_BREAK_FLAG>>8)
		jnz	short around_deadlock
		mov	al, 3
		call	BUFOUT
		call	CRLF

around_deadlock:			; ...
		push	ss
		pop	ds
		cmp	byte [CONSWAP], 0
		jz	short NOSWAP
		call	SWAPBACK

NOSWAP:					; ...
		cli
		mov	ss, [USER_SS]
		mov	sp, [USER_SP]
		call	restore_world
		pop	es
		push	ds
		mov	ds, [cs:DosDSeg]
		mov	byte [INDOS], 0
		mov	byte [ERRORMODE], 0
		mov	[ConC_Spsave], sp
		add	word [ConC_Spsave], 2
		cmp	byte [DosHasHMA], 0
		pop	ds
		jnz	short do_low_int23
		clc
		int	23h		; DOS -	CONTROL	"C" EXIT ADDRESS
					; Return: return via RETF 2 with CF set
					; DOS will abort program with errorlevel 0
					; else
					; interrupted DOS call continues
		jmp	short ctrlc_ret_addr
; ---------------------------------------------------------------------------

do_low_int23:				; ...
		clc
		;call	dword [cs:LowInt23Addr] ; call far [cs:LowInt23Addr]
		call	far [cs:LowInt23Addr]
ctrlc_ret_addr:				; ...
		cli
		push	ax
		mov	ax, ds
		mov	ds, [cs:DosDSeg]
		mov	[TEMPSEG], ax
		pop	ax
		mov	[USER_IN_AX], ax
		pushf
		pop	ax
		cmp	sp, [ConC_Spsave]
		jnz	short ctrlc_try_new

ctrlc_repeat:				; ...
		mov	ax, [USER_IN_AX]
		mov	ds, [TEMPSEG]

COMMANDJ:				; ...
		jmp	COMMAND
; ---------------------------------------------------------------------------

ctrlc_try_new:				; ...
		add	sp, 2
		test	al, 1		; f_Carry
		jz	short ctrlc_repeat
		mov	ds, [TEMPSEG]

ctrlc_abort:				; ...
		mov	ax, 4C00h	; (EXIT<<8)+0
		push	ds
		mov	ds, [cs:DosDSeg]
		mov	byte [DidCTRLC], 0FFh ; -1
		pop	ds
		jmp	short COMMANDJ
; ---------------------------------------------------------------------------

DIVOV:					; ...
		mov	si, DIVMES	; "\r\nDivide overflow\r\n"
		mov	bx, [cs:DivMesLen]
		mov	ss, [cs:DosDSeg]
		mov	sp, AUXSTACK
		call	_OUTMES		; RealDivOv
		jmp	short ctrlc_abort

; =============== S U B	R O U T	I N E =======================================

_OUTMES:
		push	ss
		pop	es
		push	ss
		pop	ds
		mov	byte [DSKSTCOM], 8 ; DEVWRT
		mov	byte [DSKSTCALL], 16h ; DRDWRHL
		mov	word [DSKSTST], 0
		mov	word [DSKSTCNT], bx
		mov	bx, DSKSTCALL
		mov	[DSKCHRET_1], si ; [DSKCHRET+1]
		mov	[DSKCHRET_3], cs ; [DSKCHRET+3]
		lds	si, [BCON]
		call	DEVIOCALL2
		mov	word [es:DSKCHRET_1], DEVIOBUF ; [ES:DSKCHRET+1]
		mov	word [es:DSKSTCNT], 1
		retn

; =============== S U B	R O U T	I N E =======================================

CHARHARD:		; ...
		cmp	byte [ss:ERRORMODE], 0
		jnz	short chard1
		or	ah, 10h
		test	byte [ss:PFLAG], 0FFh ; -1
		jnz	short ctrlp

chard1:					; ...
		or	ah, 38h		; Allowed_IGNORE+Allowed_RETRY+Allowed_FAIL

ctrlp:					; ...
		mov	[ss:ALLOWED], ah
		mov	word [ss:EXITHOLD+2], es
		mov	word [ss:EXITHOLD], bp
		push	si
		and	di, 0FFh	; STECODE
		mov	bp, ds
		call	FATALC
		pop	si
		retn

; ---------------------------------------------------------------------------

HARDERR:				; ...
		xchg	ax, di
		and	di, 0FFh	; STECODE
		cmp	di, 0		; error_I24_write_protect
		jnz	short NOSETWRPERR
		push	ax
		mov	al, [es:bp+0]
		mov	[ss:WPERR], al
		pop	ax

NOSETWRPERR:				; ...
		sub	ax, cx
		add	dx, ax
		push	dx
		mul	word [es:bp+2] ; [ES:BP+DPB.SECTOR_SIZE]
		pop	dx
		add	bx, ax
		xor	ah, ah
		cmp	dx, [es:bp+6]	; [ES:BP+DPB.FIRST_FAT]
		jb	short ERRINT
		inc	ah
		cmp	dx, [es:bp+11h]	; [ES:BP+DPB.DIR_SECTOR]
		jnb	short TESTDIR
		mov	word [es:bp+1Fh], 0FFFFh ; [ES:BP+DPB.FREE_CNT],-1
		jmp	short ERRINT
; ---------------------------------------------------------------------------

TESTDIR:				; ...
		inc	ah
		cmp	dx, [es:bp+0Bh]	; [ES:BP+DPB.FIRST_SECTOR]
		jb	short ERRINT
		inc	ah

ERRINT:					; ...
		shl	ah, 1
		or	ah, [ss:READOP]
		or	ah, [ss:ALLOWED]

FATAL:					; ...
		mov	al, [es:bp+0]

FATAL1:					; ...
		mov	word [ss:EXITHOLD+2], es
		mov	word [ss:EXITHOLD], bp
		les	si, [es:bp+13h]	; [ES:BP+DPB.DRIVER_ADDR]
		mov	bp, es

FATALC:					; ...
		call	SET_I24_EXTENDED_ERROR
		cmp	di, 0Ch		; error_I24_gen_failure
		jbe	short NET_I24_ENTRY
		mov	di, 0Ch

NET_I24_ENTRY:				; ...
		cmp	byte [ss:ERRORMODE], 0 ; GOT_RIGHT_CODE
		jz	short NoSetFail
		mov	al, 3
		jmp	short FailRet
; ---------------------------------------------------------------------------

NoSetFail:				; ...
		mov	[ss:CONTSTK], sp
		push	ss
		pop	es
		cmp	word [ss:SFN], 0FFFFh ; -1
		jz	short _NoFree
		push	ds
		push	si
		lds	si, [ss:PJFN]
		mov	byte [si], 0FFh
		pop	si
		pop	ds

_NoFree:				; ...
		cli
		inc	byte [ss:ERRORMODE]
		dec	byte [ss:INDOS]
		test	byte [ss:EXTOPEN_ON], 2 ; EXT_OPEN_I24_OFF
		jz	short i24yes
		mov	al, 3
		jmp	short passi24
; ---------------------------------------------------------------------------

i24yes:					; ...
		mov	ss, [ss:USER_SS]
		mov	sp, [es:USER_SP]
		cmp	byte [es:DosHasHMA], 0
		jnz	short do_low_int24
		int	24h		; DOS -	FATAL ERROR HANDLER ADDRESS
					; Automatically	called upon detection of unrecoverable I/O error.
		jmp	short criterr_ret_addr
; ---------------------------------------------------------------------------

do_low_int24:				; ...
		;call	dword [cs:LowInt24Addr] ; call far [cs:LowInt24Addr]
		call	far [cs:LowInt24Addr]
criterr_ret_addr:			; ...
		mov	[es:USER_SP], sp
		mov	[es:USER_SS], ss
		mov	bp, es
		mov	ss, bp

passi24:				; ...
		mov	sp, [ss:CONTSTK]
		inc	byte [ss:INDOS]
		mov	byte [ss:ERRORMODE], 0
		sti

FailRet:				; ...
		les	bp, [ss:EXITHOLD]
		cmp	al, 1
		jb	short CheckIgnore
		jz	short CheckRetry
		cmp	al, 3
		jnz	short DoAbort
		test	byte [ss:ALLOWED], 8
		jz	short DoAbort

DoFail:					; ...
		mov	al, 3
		test	byte [ss:EXTOPEN_ON], 2 ; EXT_OPEN_I24_OFF
		jnz	short CleanUp
		inc	byte [ss:FAILERR]

CleanUp:				; ...
		mov	byte [ss:WPERR], 0FFh ; -1
		cmp	word [ss:SFN], 0FFFFh ; -1
		jnz	short CleanUp2
		retn
; ---------------------------------------------------------------------------

CleanUp2:				; ...
		push	ds
		push	si
		push	ax
		mov	ax, [ss:SFN]
		lds	si, [ss:PJFN]
		mov	[si], al
		pop	ax
		pop	si
		pop	ds
		retn
; ---------------------------------------------------------------------------

CheckIgnore:				; ...
		test	byte [ss:ALLOWED], 20h ; Allowed_IGNORE
		jz	short DoFail
		jmp	short CleanUp
; ---------------------------------------------------------------------------

CheckRetry:				; ...
		test	byte [ss:ALLOWED], 10h ; Allowed_RETRY
		jz	short DoFail
		jmp	short CleanUp
; ---------------------------------------------------------------------------

DoAbort:				; ...
		push	ss
		pop	ds
		cmp	byte [CONSWAP], 0
		jz	short NOSWAP2
		call	SWAPBACK

NOSWAP2:				; ...
		cmp	byte [fAborting], 0
		jnz	short DoFail
		mov	byte [EXIT_TYPE], 2 ; EXIT_HARD_ERROR
		xor	al, al
		jmp	exit_inner
; ---------------------------------------------------------------------------

reset_environment:			; ...
		push	ds
		mov	ah, 82h
		int	2Ah		; Microsoft Networks - END DOS CRITICAL	SECTIONS 0 THROUGH 7
		mov	byte [ss:fAborting], 0FFh ; -1
		mov	ax, 1122h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - PROCESS TERMINATION HOOK
					; SS = DOS CS
		mov	al, 22h		; int_terminate
		call	_$GET_INTERRUPT_VECTOR
		pop	cx
		push	es
		push	bx
		mov	bx, [ss:CurrentPDB]
		mov	ds, bx
		mov	ax, [16h]	; [PDB.PARENT_PID]
		cmp	ax, bx
		jz	short reset_return
		cmp	bx, cx
		jnz	short reset_return
		push	ax
		cmp	byte [ss:EXIT_TYPE], 3 ; EXIT_KEEP_PROCESS
		jz	short reset_to_parent
		call	arena_free_process
		call	DOS_ABORT

reset_to_parent:			; ...
		pop	word [ss:CurrentPDB]

reset_return:				; ...
		push	ss
		pop	ds
		mov	al, 0FFh	; -1
		call	ECritDisk
		call	FLUSHBUF
		call	LCritDisk
		call	CHECK_VIRT_OPEN
		cli
		mov	byte [INDOS], 0
		mov	byte [WPERR], 0FFh
		mov	byte [fAborting], 0
		pop	word [EXITHOLD]
		pop	word [EXITHOLD+2]
		mov	ds, [CurrentPDB]
		mov	ss, word [BCLOCK+2]
		mov	sp, word [BCLOCK]
		call	restore_world
		pop	es
		push	ax
		mov	ax, ds
		mov	ds, [cs:DosDSeg]
		mov	[TEMPSEG], ax
		pop	ax
		mov	[USER_SP], ax
		pop	ax
		pop	ax
		pop	ax
		lahf
		xchg	ah, al
		and	al, 2
		mov	ah, 0F2h
		push	ax
		push	word [EXITHOLD+2]
		push	word [EXITHOLD]
		mov	ax, [USER_SP]
		mov	ds, [TEMPSEG]
		iret

; =============== S U B	R O U T	I N E =======================================

SET_I24_EXTENDED_ERROR: ; ...
		push	ax
		mov	ax, FIRST_BUFF_ADDR ; ErrMap24End
		sub	ax, ErrMap24
		push	ds
		mov	ds, [cs:DosDSeg]
		cmp	di, ax
		mov	ax, di
		jnb	short NoTrans
		mov	al, [ErrMap24+di] ; [ErrMap24+di]
		xor	ah, ah

NoTrans:				; ...
		mov	[EXTERR], ax
		pop	ds
		pop	ax
		push	si
		mov	si, ERR_TABLE_24
		call	CAL_LK
		pop	si
		retn

; =============== S U B	R O U T	I N E =======================================

IsEOF:		; ...
		cmp	word [es:bp+0Dh], 0FF6h ; [ES:BP+DPB.MAX_CLUSTER],
					; 4096-10
		jnb	short EOF16
		cmp	bx, 0FF0h
		jz	short IsEOF_other
		cmp	bx, 0FF8h

IsEOF_other:				; ...
		retn
; ---------------------------------------------------------------------------

EOF16:					; ...
		cmp	bx, 0FFF8h
		retn

; =============== S U B	R O U T	I N E =======================================

UNPACK:		; ...
		or	bx, bx
		jnz	short up_cont
		mov	di, [CL0FATENTRY]
		or	di, di
		retn
; ---------------------------------------------------------------------------

up_cont:				; ...
		cmp	bx, [es:bp+0Dh]	; [ES:BP+DPB.MAX_CLUSTER]
		ja	short HURTFAT
		call	MAPCLUSTER
		jb	short _DoContext
		mov	di, [di]
		jnz	short High12
		mov	si, [es:bp+0Dh]	; [ES:BP+DPB.MAX_CLUSTER]
		cmp	si, 0FF6h	; 4096-10
		jb	short Unpack12
		or	di, di
		jmp	short _DoContext
; ---------------------------------------------------------------------------

High12:					; ...
		shr	di, 1
		shr	di, 1
		shr	di, 1
		shr	di, 1

Unpack12:				; ...
		and	di, 0FFFh

_DoContext:				; ...
		push	ss
		pop	ds
		retn
; ---------------------------------------------------------------------------

HURTFAT:				; ...
		mov	word [es:bp+1Fh], 0FFFFh ; [ES:BP+DPB.FREE_CNT],-1
		push	ax
		mov	ah, 88h		; Allowed_FAIL+80h
		mov	byte [ss:ALLOWED], 8 ; Allowed_FAIL
		mov	di, 0FFFh
		call	FATAL
		cmp	al, 3
		clc
		jnz	short OKU_RET
		stc

OKU_RET:				; ...
		pop	ax

hurtfat_retn:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================

PACK:		; ...
		or	bx, bx
		jnz	short p_cont
		mov	[CL0FATENTRY], dx
		retn
; ---------------------------------------------------------------------------

p_cont:					; ...
		call	MAPCLUSTER
		jb	short _DoContext
		mov	si, [di]
		jz	short ALIGNED
		push	cx
		mov	cl, 4
		shl	dx, cl
		pop	cx
		and	si, 0Fh
		jmp	short PACKIN
; ---------------------------------------------------------------------------

ALIGNED:				; ...
		cmp	word [es:bp+0Dh], 0FF6h ; [ES:BP+DPB.MAX_CLUSTER],
					; 4096-10
		jnb	short Pack16
		and	si, 0F000h
		and	dx, 0FFFh
		jmp	short PACKIN
; ---------------------------------------------------------------------------

Pack16:					; ...
		xor	si, si

PACKIN:					; ...
		or	si, dx
		mov	[di], si
		lds	si, [ss:CURBUF]
		test	byte [si+5], 40h ; [SI+BUFFINFO.buf_flags],buf_dirty
		jnz	short yesdirty11
		call	INC_DIRTY_COUNT
		or	byte [si+5], 40h

yesdirty11:				; ...
		cmp	byte [ss:CLUSSPLIT], 0
		push	ss
		pop	ds
		jz	short hurtfat_retn
		push	ax
		push	bx
		push	cx
		mov	ax, [CLUSSAVE]
		mov	ds, word [CURBUF+2]
		add	si, 20		; BUFINSIZ
		mov	[si], ah
		push	ss
		pop	ds
		push	ax
		mov	dx, word [CLUSSEC+2]
		mov	word [HIGH_SECTOR], dx
		mov	dx, word [CLUSSEC]
		mov	si, 1
		xor	al, al
		call	GETBUFFRB
		pop	ax
		jb	short POPP_RET
		lds	di, [CURBUF]
		test	byte [di+5], 40h
		jnz	short yesdirty12
		call	INC_DIRTY_COUNT
		or	byte [di+5], 40h ; [DI+BUFFINFO.buf_flags],buf_dirty

yesdirty12:				; ...
		add	di, 20		; BUFINSIZ
		dec	di
		add	di, [es:bp+2]	; [ES:BP+DPB.SECTOR_SIZE]
		mov	[di], al
		clc

POPP_RET:				; ...
		push	ss
		pop	ds
		pop	cx
		pop	bx
		pop	ax
		retn

; =============== S U B	R O U T	I N E =======================================

MAPCLUSTER:		; ...
		mov	byte [CLUSSPLIT], 0
		push	ax
		push	bx
		push	cx
		push	dx
		mov	ax, bx
		cmp	word [es:bp+0Dh], 0FF6h ; [ES:BP+DPB.MAX_CLUSTER],
					; 4096-10
		jnb	short Map16
		shr	ax, 1

Map16:					; ...
		xor	di, di
		add	ax, bx
		adc	di, di
		mov	cx, [es:bp+2]	; [ES:BP+DPB.SECTOR_SIZE]
		cmp	cx, 512
		jnz	short _DoDiv
		mov	dx, ax
		and	dx, 1FFh
		mov	al, ah
		shr	di, 1
		rcr	al, 1
		xor	ah, ah
		jmp	short DivDone
; ---------------------------------------------------------------------------

_DoDiv:					; ...
		mov	dx, di
		div	cx

DivDone:				; ...
		add	ax, [es:bp+6]	; ES:BP+DPB.FIRST_FAT]
		dec	cx
		push	ax
		push	dx
		push	cx
		mov	dx, ax
		mov	word [HIGH_SECTOR], 0
		xor	al, al
		mov	si, 1
		call	GETBUFFRB
		pop	cx
		pop	ax
		pop	dx
		jb	short MAP_POP
		lds	si, [CURBUF]
		lea	di, [si+20]	; [SI+BUFINSIZ]
		add	di, ax
		cmp	ax, cx
		jnz	short MAPRET
		mov	al, [di]
		push	ss
		pop	ds
		inc	byte [CLUSSPLIT]
		mov	byte [CLUSSAVE], al
		mov	word [CLUSSEC], dx
		mov	word [CLUSSEC+2], 0
		inc	dx
		mov	word [HIGH_SECTOR], 0
		xor	al, al
		mov	si, 1
		call	GETBUFFRB
		jb	short MAP_POP
		lds	si, [CURBUF]
		lea	di, [si+20]	; [SI+BUFINSIZ]
		mov	al, [di]
		push	ss
		pop	ds
		mov	byte [CLUSSAVE+1], al
		mov	di, CLUSSAVE

MAPRET:					; ...
		pop	dx
		pop	cx
		pop	bx
		xor	ax, ax
		cmp	word [es:bp+0Dh], 0FF6h ; [ES:BP+DPB.MAX_CLUSTER],
					; 4096-10
		jnb	short MapSet
		mov	ax, bx

MapSet:					; ...
		test	al, 1
		pop	ax
		retn
; ---------------------------------------------------------------------------

MAP_POP:				; ...
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		retn

; =============== S U B	R O U T	I N E =======================================

FATREAD_SFT:	; ...
		les	bp, [es:di+7]	; [ES:DI+SF_ENTRY.sf_devptr]
		mov	al, [es:bp+0]
		mov	[THISDRV], al
		call	GOTDPB
		call	FAT_GOT_DPB

fatread_sft_retn:			; ...
		retn

; =============== S U B	R O U T	I N E =======================================

FATREAD_CDS:	; ...
		push	es
		push	di
		les	bp, [es:di+45h]	; [ES:DI+curdir.devptr]
		mov	al, [es:bp+0]
		mov	[THISDRV], al
		call	GOTDPB
		call	FAT_GOT_DPB
		pop	di
		pop	es
		jb	short fatread_sft_retn
		jnz	short NO_CHANGE
		xor	ax, ax
		dec	ax
		push	ds
		mov	cl, [CDSCOUNT]
		xor	ch, ch
		lds	si, [es:di+45h]	; [ES:DI+curdir.devptr]
		les	di, [ss:CDSADDR]

frcd20:					; ...
		test	byte [es:di+44h], 80h ; [ES:DI+curdir.flags+1],
					; (curdir_isnet>>8)
		jnz	short frcd25
		cmp	si, [es:di+45h]	; [ES:DI+curdir.devptr]
		jnz	short frcd25
		mov	bx, ds
		cmp	bx, [es:di+47h]	; [ES:DI+curdir.devptr+2]
		jnz	short frcd25
		test	[es:di+49h], ax	; [ES:DI+curdir.ID]
		jz	short frcd25
		mov	[es:di+49h], ax

frcd25:					; ...
		add	di, 88		; curdir.size
		loop	frcd20
		pop	ds

NO_CHANGE:				; ...
		les	bp, [THISDPB]
		clc
		retn

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR FAT_GOT_DPB

FAT_operation:				; ...
		mov	word [es:bp+1Fh], 0FFFFh ; [ES:BP+DPB.FREE_CNT],-1
		and	di, 0FFh	; STECODE
		mov	byte [ALLOWED], 18h ; Allowed_FAIL+Allowed_RETRY
		mov	ah, 1Ah		; 2+Allowed_FAIL+Allowed_RETRY
		mov	al, [THISDRV]
		call	FATAL1
		les	bp, [THISDPB]
		cmp	al, 3
		jnz	short FAT_GOT_DPB
		stc
		retn
; END OF FUNCTION CHUNK	FOR FAT_GOT_DPB

; =============== S U B	R O U T	I N E =======================================

FAT_GOT_DPB:	; ...

; FUNCTION CHUNK AT 96C0 SIZE 00000021 BYTES

		push	ss
		pop	ds
		mov	al, 0Fh		; DMEDHL
		mov	ah, [es:bp+1]	; [ES:BP+DPB.UNIT]
		mov	[DEVCALL], ax
		mov	byte [DEVCALL_REQFUNC], 1 ; DEVMDCH
		mov	word [DEVCALL_REQSTAT], 0
		mov	al, [es:bp+17h]	; [ES:BP+DPB.MEDIA]
		mov	[CALLMED], al
		push	es
		push	ds
		mov	bx, DEVCALL
		lds	si, [es:bp+13h]	; [ES:BP+DPB.DRIVER_ADDR]
		pop	es
		call	DEVIOCALL2
		push	ss
		pop	ds
		pop	es
		mov	di, [DEVCALL_REQSTAT]
		or	di, di
		js	short FAT_operation
		xor	ah, ah
		xchg	ah, [es:bp+18h]	; [ES:BP+DPB.FIRST_ACCESS]
		mov	al, [THISDRV]
		cmp	byte [VOLCHNG_FLAG], al
		jnz	short CHECK_BYT
		mov	byte [VOLCHNG_FLAG], 0FFh ; -1
		jmp	GOGETBPB
; ---------------------------------------------------------------------------

CHECK_BYT:				; ...
		or	ah, [CALLXADD]
		jns	short CHECK_ZR
		jmp	short NEWDSK
; ---------------------------------------------------------------------------

CHECK_ZR:				; ...
		jz	short CHKBUFFDIRT
		clc
		retn
; ---------------------------------------------------------------------------

DISK_CHNG_ERR:				; ...
		push	es
		push	bp
		les	bp, [es:bp+13h]	; [ES:BP+DPB.DRIVER_ADDR]
		test	byte [es:bp+5], 8 ; [es:bp+SYSDEV.ATT+1],
					; (DEVOPCL>>8)
		pop	bp
		pop	es
		jz	short FAIL_OPJ2
		push	ds
		push	di
		push	ss
		pop	ds
		mov	byte [ALLOWED], 18h
		push	es
		les	di, [CALLXADD+1] ; les di,[CALLVIDM]
		mov	word [EXTERRPT+2], es
		pop	es
		mov	word [EXTERRPT],	di
		mov	ax, 0Fh		; error_I24_wrong_disk
		mov	byte [READOP], 1
		call	HARDERR
		pop	di
		pop	ds
		cmp	al, 3

FAIL_OPJ2:				; ...
		jz	short FAIL_OP
		jmp	FAT_GOT_DPB
; ---------------------------------------------------------------------------

CHKBUFFDIRT:				; ...
		cmp	word [ss:DirtyBufferCount], 0
		jz	short NEWDSK
		call	GETCURHEAD

nbuffer:				; ...
		cmp	[di+4],	al	; [di+BUFFINFO.buf_ID]
		jnz	short lfnxt
		test	byte [di+5], 40h ; [di+BUFFINFO.buf_flags],
					; buf_dirty
		jz	short lfnxt
		push	ss
		pop	ds
		clc
		retn
; ---------------------------------------------------------------------------

FAIL_OP:				; ...
		push	ss
		pop	ds
		stc
		retn
; ---------------------------------------------------------------------------

lfnxt:					; ...
		mov	di, [di]	; [di+BUFFINFO.buf_next]
		cmp	[ss:FIRST_BUFF_ADDR], di
		jnz	short nbuffer

NEWDSK:					; ...
		mov	word [es:bp+1Fh], 0FFFFh ; [ES:BP+DPB.FREE_CNT],-1
		call	GETCURHEAD

nxbuffer:				; ...
		cmp	[di+4],	al	; [DI+BUFFINFO.buf_ID]
		jnz	short lfnxt2
		test	byte [di+5], 40h ; [DI+BUFFINFO.buf_flags],buf_dirty
		jnz	short DISK_CHNG_ERR
		mov	word [di+4], 20FFh ; [DI+BUFFINFO.buf_ID],
					; (buf_visit*256)+0FFh
		call	SCANPLACE
		jmp	short skpbuff
; ---------------------------------------------------------------------------

lfnxt2:					; ...
		mov	di, [di]	; [di+BUFFINFO.buf_next]

skpbuff:				; ...
		cmp	di, [ss:FIRST_BUFF_ADDR]
		jnz	short nxbuffer
		cmp	word [ss:SC_CACHE_COUNT], 0
		jz	short GOGETBPB
		cmp	al, [ss:CurSC_DRIVE]
		jnz	short GOGETBPB
		mov	byte [ss:CurSC_DRIVE], 0FFh ; -1

GOGETBPB:				; ...
		lds	di, [es:bp+13h]	; [ES:BP+DPB.DRIVER_ADDR]
		test	byte [di+5], 20h ; [DI+SYSDEV.ATT+1],
					; (ISFATBYDEV>>8)
		jnz	short GETFREEBUF
		push	ss
		pop	ds
		mov	bx, 2
		call	UNPACK

FAIL_OPJ:				; ...
		jb	short FAIL_OP
		lds	di, [CURBUF]
		jmp	short GOTGETBUF
; ---------------------------------------------------------------------------

GETFREEBUF:				; ...
		push	es
		push	bp
		xor	dx, dx
		mov	word [ss:HIGH_SECTOR], dx
		call	GETCURHEAD
		call	BUFWRITE
		pop	bp
		pop	es
		jb	short FAIL_OPJ

GOTGETBUF:				; ...
		add	di, 20		; BUFINSIZ
		mov	word [ss:CALLXADD+2], ds
		push	ss
		pop	ds
		mov	word [CALLXADD], di
		mov	al, 16h		; DBPBHL
		mov	ah, [es:bp+1]	; [ES:BP+DPB.UNIT]
		mov	[DEVCALL], ax ; [DEVCALL_REQLEN]
		mov	byte [DEVCALL_REQFUNC], 2 ; DEVBPB
		mov	word [DEVCALL_REQSTAT], 0
		mov	al, [es:bp+17h]	; [ES:BP+DPB.MEDIA]
		mov	[CALLMED], al
		push	es
		push	ds
		push	word [es:bp+15h] ; [ES:BP+DPB.DRIVER_ADDR+2]
		push	word [es:bp+13h] ; [ES:BP+DPB.DRIVER_ADDR]
		mov	bx, DEVCALL
		pop	si
		pop	ds
		pop	es
		call	DEVIOCALL2
		pop	es
		push	ss
		pop	ds
		mov	di, [DEVCALL_REQSTAT]
		or	di, di
		js	short FATERRJ
		mov	al, [es:bp+17h]	; [ES:BP+DPB.MEDIA]
		lds	si, [CALLSCNT] ; lds si,[CALLBPB]
		mov	word [es:bp+1Dh], 0	; [ES:BP+DPB.NEXT_FREE]
		call	_$SETDPB
		lds	di, [ss:CALLXADD]
		mov	al, [es:bp+8]	; [ES:BP+DPB.FAT_COUNT]
		mov	[di-0Ah], al	; [DI+BUFFINFO.buf_wrtcnt-BUFINSIZ]
		mov	ax, [es:bp+0Fh]	; [ES:BP+DPB.FAT_SIZE]
		mov	[di-9],	ax	; [DI+BUFFINFO.buf_wrtcntinc-BUFINSIZ]
		push	ss
		pop	ds
		xor	al, al
		retn
; ---------------------------------------------------------------------------

FATERRJ:				; ...
		jmp	FAT_operation

; =============== S U B	R O U T	I N E =======================================

GETCURHEAD:		; ...
		lds	di, [ss:BufferQueue]
		mov	word [ss:LastBuffer], 0FFFFh ; -1
		mov	[ss:FIRST_BUFF_ADDR], di
		retn

; =============== S U B	R O U T	I N E =======================================

SCANPLACE:		; ...
		push	word [di]	; [di+BUFFINFO.buf_next]
		call	PLACEBUF
		pop	di
		retn

; =============== S U B	R O U T	I N E =======================================

PLACEBUF:		; ...
		push	ax
		push	bx
		push	si
		mov	ax, [di]	; [di+BUFFINFO.buf_next]
		mov	bx, word [ss:BufferQueue]
		cmp	ax, bx
		jz	short nret
		cmp	di, bx
		jnz	short not_first
		mov	word [ss:BufferQueue], ax
		jmp	short nret
; ---------------------------------------------------------------------------

not_first:				; ...
		mov	si, [di+2]	; [DI+BUFFINFO.buf_prev]
		mov	[si], ax	; [SI+BUFFINFO.buf_next]
		xchg	ax, si
		mov	[si+2],	ax	; [SI+BUFFINFO.buf_prev]
		mov	si, [bx+2]	; [BX+BUFFINFO.buf_prev]
		mov	[si], di
		mov	[bx+2],	di
		mov	[di+2],	si
		mov	[di], bx	; [DI+BUFFINFO.buf_next]

nret:					; ...
		pop	si
		pop	bx
		pop	ax
		cmp	byte [di+4], 0FFh ;	[di+BUFFINFO.buf_ID],-1
		jnz	short pbx
		mov	word [ss:BufferQueue], di

pbx:					; ...
		retn

; ---------------------------------------------------------------------------

POINTCOMP:				; ...
		cmp	si, di
		jnz	short placehead_retn
		push	cx
		push	dx
		mov	cx, ds
		mov	dx, es
		cmp	cx, dx
		pop	dx
		pop	cx

placehead_retn:				; ...
		retn
; ---------------------------------------------------------------------------

GETBUFFR:				; ...
		xor	si, si

GETBUFFRB:				; ...
		mov	[PREREAD], ax
		mov	al, [es:bp+0]	; [ES:BP+DPB.DRIVE]
		lds	di, [LastBuffer]
		mov	cx, [ss:HIGH_SECTOR]
		cmp	di, 0FFFFh	; -1
		jz	short getb5
		cmp	dx, [di+6]	; [DI+BUFFINFO.buf_sector]
		jnz	short getb5
		cmp	cx, [di+8]	; [DI+BUFFINFO.buf_sector+2]
		jnz	short getb5
		cmp	al, [di+4]	; [DI+BUFFINFO.buf_ID]
		jnz	short getb5
		jmp	getb35
; ---------------------------------------------------------------------------

getb5:					; ...
		call	GETCURHEAD

getb10:					; ...
		cmp	dx, [di+6]	; [DI+BUFFINFO.buf_sector]
		jnz	short getb12
		cmp	cx, [di+8]	; [DI+BUFFINFO.buf_sector+2]
		jnz	short getb12
		cmp	al, [di+4]	; [DI+BUFFINFO.buf_ID]
		jnz	short getb12
		jmp	getb25
; ---------------------------------------------------------------------------

getb12:					; ...
		mov	di, [di]	; [DI+BUFFINFO.BUF_NEXT]
		cmp	di, [ss:FIRST_BUFF_ADDR]
		jnz	short getb10
		push	cx
		push	si
		push	dx
		push	bp
		push	es
		call	BUFWRITE
		pop	es
		pop	bp
		pop	dx
		pop	si
		pop	word [ss:HIGH_SECTOR]
		jnb	short getb13
		jmp	getbx
; ---------------------------------------------------------------------------

getb13:					; ...
		call	SET_RQ_SC_PARMS
		xor	ah, ah
		cmp	byte [ss:PREREAD], ah
		jnz	short getb20
		lea	bx, [di+20]	; [DI+BUFINSIZ]
		mov	cx, 1
		push	si
		push	di
		push	dx
		push	es
		cmp	byte [ss:BuffInHMA], 0
		jz	short getb14
		push	ds
		push	bx
		lds	bx, [ss:LoMemBuff]

getb14:					; ...
		or	si, si
		jz	short getb15
		call	FATSECRD
		mov	ah, 2		; buf_isFAT
		jmp	short getb17
; ---------------------------------------------------------------------------

getb15:					; ...
		call	DREAD
		mov	ah, 0

getb17:					; ...
		pushf
		cmp	byte [ss:BuffInHMA], 0
		jz	short not_in_hma
		popf
		mov	cx, [es:bp+2]	; [ES:BP+DPB.SECTOR_SIZE]
		shr	cx, 1
		mov	si, bx
		pop	di
		pop	es
		cld
		rep movsw
		push	es
		pop	ds
		jmp	short getb19
; ---------------------------------------------------------------------------

not_in_hma:				; ...
		popf

getb19:					; ...
		pop	es
		pop	dx
		pop	di
		pop	si
		jb	short getbx

getb20:					; ...
		mov	cx, [ss:HIGH_SECTOR]
		mov	[di+8],	cx	; [DI+BUFFINFO.buf_sector+2]
		mov	[di+6],	dx	; [DI+BUFFINFO.buf_sector]
		mov	[di+0Dh], bp	; [DI+BUFFINFO.buf_DPB]
		mov	word [di+0Fh], es ;	[DI+BUFFINFO.buf_DPB+2]
		mov	al, [es:bp+0]	; [ES:BP+DPB.DRIVE]
		mov	[di+4],	ax	; [DI+BUFFINFO.buf_ID]

getb25:					; ...
		mov	byte [di+0Ah], 1 ;	[DI+BUFFINFO.buf_wrtcnt]
		xor	ax, ax
		or	si, si
		jz	short getb30
		mov	al, [es:bp+8]	; [ES:BP+DPB.FAT_COUNT]
		mov	[di+0Ah], al	; [DI+BUFFINFO.buf_wrtcnt]
		mov	ax, [es:bp+0Fh]	; [ES:BP+DPB.FAT_SIZE]

getb30:					; ...
		mov	[di+0Bh], ax	; [DI+BUFFINFO.buf_wrtcntinc]
		call	PLACEBUF

getb35:					; ...
		mov	word [ss:CURBUF+2],	ds
		mov	word [ss:LastBuffer+2], ds
		mov	word [ss:CURBUF], di
		mov	word [ss:LastBuffer], di
		clc

getbx:					; ...
		push	ss
		pop	ds

getbuffrb_retn:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================

FLUSHBUF:		; ...
		call	GETCURHEAD
		test	byte [ss:DOS34_FLAG], 4 ; FROM_DISK_RESET
		jnz	short scan_buf_queue
		cmp	word [ss:DirtyBufferCount], 0
		jz	short end_scan

scan_buf_queue:				; ...
		call	CHECKFLUSH
		mov	ah, [di+4]	; [DI+BUFFINFO.buf_ID]
		cmp	[ss:WPERR], ah
		jz	short free_the_buf
		test	byte [ss:DOS34_FLAG], 4 ; FROM_DISK_RESET
		jz	short dont_free_the_buf

free_the_buf:				; ...
		mov	word [di+4], 0FFh ;	[DI+BUFFINFO.buf_ID],00FFh

dont_free_the_buf:			; ...
		mov	di, [di]	; [DI+BUFFINFO.buf_next]
		cmp	di, [ss:FIRST_BUFF_ADDR]
		jnz	short scan_buf_queue

end_scan:				; ...
		push	ss
		pop	ds
		cmp	byte [FAILERR], 0
		jnz	short bad_flush
		retn
; ---------------------------------------------------------------------------

bad_flush:				; ...
		stc
		retn

; =============== S U B	R O U T	I N E =======================================

CHECKFLUSH:		; ...
		mov	ah, 0FFh	; -1
		cmp	[di+4],	ah	; [DI+BUFFINFO.buf_ID]
		jz	short getbuffrb_retn ; flushbuf_retn
		cmp	ah, al
		jz	short DOBUFFER
		cmp	al, [di+4]
		clc
		jnz	short getbuffrb_retn ; flushbuf_retn

DOBUFFER:				; ...
		test	byte [di+5], 40h ; [DI+BUFFINFO.buf_flags],
					; buf_dirty
		jz	short getbuffrb_retn ; flushbuf_retn
		push	ax
		push	word [di+4]	; [DI+BUFFINFO.buf_ID]
		call	BUFWRITE
		pop	ax
		jb	short LEAVE_BUF
		and	ah, 0BFh	; ~buf_dirty
		mov	[di+4],	ax

LEAVE_BUF:				; ...
		pop	ax

checkflush_retn:			; ...
		retn

; =============== S U B	R O U T	I N E =======================================

BUFWRITE:		; ...
		mov	ax, 0FFh
		xchg	ax, [di+4]	; [DI+BUFFINFO.buf_ID]
		cmp	al, 0FFh
		jz	short checkflush_retn
		test	ah, 40h		; buf_dirty
		jz	short checkflush_retn
		call	DEC_DIRTY_COUNT
		cmp	al, [ss:WPERR]
		jz	short checkflush_retn
		mov	[ss:SC_DRIVE], al
		les	bp, [di+13]	; [DI+BUFFINFO.buf_DPB]
		lea	bx, [di+20]	; [DI+BUFINSIZ]
		mov	dx, [di+6]	; [DI+BUFFINFO.buf_sector]
		mov	cx, [di+8]	; [DI+BUFFINFO.buf_sector+2]
		mov	word [ss:HIGH_SECTOR], cx
		mov	cl, [di+10]	; [DI+BUFFINFO.buf_wrtcnt]
		xor	ch, ch
		mov	byte [ss:ALLOWED], 18h ; Allowed_RETRY+Allowed_FAIL
		test	ah, 8		; buf_isDATA
		jz	short NO_IGNORE
		or	byte [ss:ALLOWED], 20h ; Allowed_IGNORE

NO_IGNORE:				; ...
		mov	ax, [di+11]	; [DI+BUFFINFO.buf_wrtcntinc]
		push	di
		xor	di, di
		push	ds
		push	bx

WRTAGAIN:				; ...
		push	di
		push	cx
		push	ax
		mov	cx, 1
		push	bx
		push	dx
		push	ds
		cmp	byte [ss:BuffInHMA], 0
		jz	short NBUFFINHMA
		push	cx
		push	es
		mov	si, bx
		mov	cx, [es:bp+2]	; [es:bp+DPB.SECTOR_SIZE]
		shr	cx, 1
		les	di, [ss:LoMemBuff]
		mov	bx, di
		cld
		rep movsw
		push	es
		pop	ds
		pop	es
		pop	cx

NBUFFINHMA:				; ...
		call	DWRITE
		pop	ds
		pop	dx
		pop	bx
		pop	ax
		pop	cx
		pop	di
		jb	short NOSET
		inc	di

NOSET:					; ...
		add	dx, ax
		loop	WRTAGAIN
		pop	bx
		pop	ds
		or	di, di
		jnz	short BWROK
		stc

BWROK:					; ...
		pop	di
		retn

; =============== S U B	R O U T	I N E =======================================

SET_RQ_SC_PARMS:
		push	ax
		mov	ax, [es:bp+2]	; [ES:BP+DPB.SECTOR_SIZE]
		mov	[ss:SC_SECTOR_SIZE], ax
		mov	al, [es:bp+0]
		mov	[ss:SC_DRIVE], al
		pop	ax
		retn

; =============== S U B	R O U T	I N E =======================================

INC_DIRTY_COUNT:
		inc	word [ss:DirtyBufferCount]
		retn

; =============== S U B	R O U T	I N E =======================================

DEC_DIRTY_COUNT:
		cmp	word [ss:DirtyBufferCount], 0
		jz	short ddcx
		dec	word [ss:DirtyBufferCount]

ddcx:					; ...
		retn

; ---------------------------------------------------------------------------

_$WAIT:					; ...
		xor	ax, ax
		xchg	ax, [ss:exit_code]
		jmp	SYS_RETURN	; SYS_RET_OK
; ---------------------------------------------------------------------------

_$EXEC:					; ...
		mov	byte [ss:A20OFF_COUNT], 0
		cmp	al, 5
		jnz	short Exec_@f
		pop	cx
		mov	cx, LeaveDOS
		push	cx

Exec_@f:				; ...
		push	bp
		mov	bp, sp
		sub	sp, 29
		cmp	al, 5
		jbe	short Exec_Check_2

Exec_Bad_Fun:				; ...
		mov	byte [ss:EXTERR_LOCUS], 1 ; errLOC_Unk
		mov	al, 1		; error_invalid_function

Exec_Ret_Err:				; ...
		mov	sp, bp
		pop	bp
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

ExecReadyJ:				; ...
		call	ExecReady
		jmp	norm_ovl
; ---------------------------------------------------------------------------

Exec_Check_2:				; ...
		cmp	al, 2
		jz	short Exec_Bad_Fun
		cmp	al, 4
		jz	short Exec_Bad_Fun
		cmp	al, 5
		jz	short ExecReadyJ
		mov	[bp-4],	bx	; Exec_BlkL
		mov	word [bp-2], es
		mov	[bp-5],	al	; Exec_Func
		mov	byte [bp-6], 0 ; Exec_Load_High
		mov	[bp-26], dx	; ExecNameL
		mov	word [bp-24], ds ; ExecNameH
		mov	si, dx
		call	DStrLen
		mov	[bp-22], cx	; ExecNameLen
		mov	al, [ss:AllocMethod]
		mov	[ss:ALLOCMSAVE], al
		xor	al, al
		push	bp
		or	byte [ss:DOS_FLAG], 1 ; EXECOPEN
		call	_$OPEN
		pushf
		and	byte [ss:DOS_FLAG], 0FEh ; ~EXECOPEN
		popf
		pop	bp
		jb	short Exec_Ret_Err
		mov	[bp-8],	ax	; Exec_FH
		mov	bx, ax
		xor	al, al
		call	_$IOCTL
		jb	short Exec_BombJ
		test	dl, 80h		; devid_ISDEV
		jz	short Exec_Check_Environ
		mov	al, 2		; error_file_not_found

Exec_BombJ:				; ...
		jmp	Exec_Bomb
; ---------------------------------------------------------------------------

BadEnv:					; ...
		mov	al, 0Ah		; error_bad_environment
		jmp	Exec_Bomb
; ---------------------------------------------------------------------------

Exec_Check_Environ:			; ...
		mov	word [bp-18], 0 ; Exec_Load_Block
		mov	word [bp-14], 0 ; Exec_Environ
		test	byte [bp-5], 2 ; Exec_Func,exec_func_overlay
		jnz	short Exec_Read_Header
		lds	si, [bp-4]	; Exec_Blk
		mov	ax, [si]	; [SI+EXEC1.ENVIRON]
		or	ax, ax
		jnz	short Exec_Scan_Env
		mov	ds, [ss:CurrentPDB]
		mov	ax, [2Ch]	; [PDB.ENVIRON]
		or	ax, ax
		jz	short Exec_Read_Header

Exec_Scan_Env:				; ...
		mov	es, ax
		xor	di, di
		mov	cx, 8000h
		xor	al, al

Exec_Get_Environ_Len:			; ...
		repne scasb
		jnz	short BadEnv
		dec	cx
		js	short BadEnv
		scasb
		jnz	short Exec_Get_Environ_Len
		push	di
		lea	bx, [di+11h]	; [DI+0Fh+2]
		add	bx, [bp-22]	; ExecNameLen
		mov	cl, 4
		shr	bx, cl
		push	es
		call	_$ALLOC
		pop	ds
		pop	cx
		jnb	short Exec_Save_Environ
		jmp	short Exec_No_Mem
; ---------------------------------------------------------------------------

Exec_Save_Environ:			; ...
		mov	es, ax
		mov	[bp-14], ax	; Exec_Environ
		xor	si, si
		mov	di, si
		rep movsb
		mov	ax, 1
		stosw
		lds	si, [bp-26]	; ExecName
		mov	cx, [bp-22]	; ExecNameLen
		rep movsb

Exec_Read_Header:			; ...
		push	ss
		pop	ds
		mov	cx, 26		; exec_header_len
		mov	dx, exec_signature
		push	es
		push	ds
		call	ExecRead
		pop	ds
		pop	es
		jb	short Exec_Bad_File
		or	ax, ax
		jz	short Exec_Bad_File
		cmp	ax, 26		; exec_header_len
		jnz	short Exec_Com_Filej
		test	word [exec_max_BSS], 0FFFFh ; -1
		jnz	short Exec_Check_Sig
		mov	byte [bp-6], 0FFh ;	Exec_Load_High,-1

Exec_Check_Sig:				; ...
		mov	ax, [exec_signature]
		cmp	ax, 5A4Dh	; 'MZ'
		jz	short Exec_Save_Start
		cmp	ax, 4D5Ah	; 'ZM'
		jz	short Exec_Save_Start

Exec_Com_Filej:				; ...
		jmp	Exec_Com_File
; ---------------------------------------------------------------------------

Exec_Save_Start:			; ...
		mov	ax, [exec_pages]
		mov	cl, 5
		shl	ax, cl
		sub	ax, [exec_par_dir]
		mov	[bp-12], ax	; Exec_Res_Len_Para
		test	byte [bp-5], 2 ; Exec_Func,exec_func_overlay
		jz	short Exec_Allocate
		les	di, [bp-4]	; Exec_Blk
		mov	ax, [es:di]	; [ES:DI+EXEC3.load_addr]
		mov	[bp-20], ax	; Exec_DMA
		mov	ax, [es:di+2]	; [ES:DI+EXEC3.reloc_fac]
		mov	[bp-10], ax	; Exec_Rel_Fac
		jmp	Exec_Find_Res
; ---------------------------------------------------------------------------

Exec_No_Mem:				; ...
		mov	al, 8		; error_not_enough_memory
		jmp	short Exec_Bomb
; ---------------------------------------------------------------------------

Exec_Bad_File:				; ...
		mov	al, 0Bh		; error_bad_format

Exec_Bomb:				; ...
		mov	bx, [bp-8]	; Exec_FH
		call	Exec_Dealloc
		call	LCritDisk	; call LCritMEM
		push	ax
		push	bp
		call	_$CLOSE
		pop	bp
		pop	ax
		jmp	Exec_Ret_Err
; ---------------------------------------------------------------------------

Exec_Chk_Mem:				; ...
		mov	al, [ss:AllocMethod]
		mov	bl, [ss:ALLOCMSAVE]
		mov	[ss:AllocMethod], bl
		test	bl, 40h		; HIGH_ONLY
		jnz	short Exec_No_Mem
		test	al, 40h
		jz	short Exec_No_Mem
		mov	ax, [ss:SAVE_AX]
		jmp	short Exec_Norm_Alloc
; ---------------------------------------------------------------------------

Exec_Allocate:				; ...
		mov	byte [bp-29], 0 ; Exec_NoStack
		cmp	word [exec_SS], 0
		jnz	short ea1
		cmp	word [exec_SP], 0
		jnz	short ea1
		inc	byte [bp-29]
		cmp	ax, 0FF0h	; 1000h-10h
		jnb	short ea1
		add	ax, 10h

ea1:					; ...
		test	byte [AllocMethod], 80h ; HIGH_FIRST
		jz	short Exec_Norm_Alloc
		or	byte [AllocMethod], 40h ; HIGH_ONLY

Exec_Norm_Alloc:			; ...
		mov	[SAVE_AX], ax
		mov	bx, 0FFFFh
		push	ds
		call	_$ALLOC
		pop	ds
		mov	ax, [SAVE_AX]
		add	ax, 10h
		cmp	bx, 11h
		jb	short Exec_Chk_Mem
		cmp	ax, bx
		ja	short Exec_Chk_Mem
		test	byte [bp-6], 0FFh ;	Exec_Load_High,-1
		jnz	short Exec_BX_Max
		add	ax, [exec_min_BSS]
		jb	short Exec_Chk_Mem
		cmp	ax, bx
		ja	short Exec_Chk_Mem
		sub	ax, [exec_min_BSS]
		add	ax, [exec_max_BSS]
		jb	short Exec_BX_Max
		cmp	ax, bx
		jbe	short Exec_Got_Block

Exec_BX_Max:				; ...
		mov	ax, bx

Exec_Got_Block:				; ...
		push	ds
		mov	bx, ax
		mov	[bp-16], bx	; Exec_Size
		call	_$ALLOC
		pop	ds
		jnb	short ea0
		jmp	Exec_Chk_Mem
; ---------------------------------------------------------------------------

ea0:					; ...
		mov	cl, [ALLOCMSAVE]
		mov	[AllocMethod], cl
		cmp	byte [bp-29], 0 ; Exec_NoStack
		jz	short ea2
		cmp	bx, 1000h
		jnb	short ea2
		mov	cl, 4
		shl	bx, cl
		sub	bx, 100h
		mov	[exec_SP], bx

ea2:					; ...
		mov	[bp-18], ax	; Exec_Load_Block
		add	ax, 10h
		test	byte [bp-6], 0FFh ;	Exec_Load_High,-1
		jz	short Exec_Use_AX
		add	ax, [bp-16]	; Exec_Size
		sub	ax, [bp-12]	; Exec_Res_Len_Para
		sub	ax, 10h

Exec_Use_AX:				; ...
		mov	[bp-10], ax	; Exec_Rel_Fac
		mov	[bp-20], ax	; Exec_DMA

Exec_Find_Res:				; ...
		mov	dx, [bp-20]	; Exec_DMA
		mov	[bp-28], dx	; Exec_DMA_Save
		mov	dx, [exec_par_dir]
		push	dx
		mov	cl, 4
		shl	dx, cl
		pop	ax
		mov	cl, 12
		shr	ax, cl
		mov	cx, ax
		mov	bx, [bp-8]	; Exec_FH
		push	ds
		xor	al, al
		call	_$LSEEK
		pop	ds
		jnb	short Exec_Big_Read
		jmp	Exec_Bomb
; ---------------------------------------------------------------------------

Exec_Big_Read:				; ...
		mov	bx, [bp-12]	; Exec_Res_Len_Para
		cmp	bx, 1000h
		jb	short Exec_Read_OK
		mov	bx, 0FE0h

Exec_Read_OK:				; ...
		sub	[bp-12], bx	; Exec_Res_Len_Para
		push	bx
		mov	cl, 4
		shl	bx, cl
		mov	cx, bx
		push	ds
		mov	ds, word [bp-20] ; Exec_DMA
		xor	dx, dx
		push	cx
		call	ExecRead
		pop	cx
		pop	ds
		jb	short Exec_Bad_FileJ
		cmp	cx, ax
		pop	bx
		jz	short ExecCheckEnd
		sub	cx, ax
		cmp	cx, 512
		jnb	short Exec_Bad_FileJ

ExecCheckEnd:				; ...
		add	[bp-20], bx	; Exec_DMA
		test	word [bp-0Ch], 0FFFFh ; Exec_Res_Len_Para,-1
		jnz	short Exec_Big_Read
		mov	cx, [bp-10]	; Exec_Rel_Fac
		mov	ax, [exec_SS]
		add	ax, cx
		mov	[exec_init_SS], ax
		mov	ax, [exec_SP]
		mov	[exec_init_SP], ax
		les	ax, [exec_IP] ; les ax,[exec_IP]
		mov	[exec_init_IP], ax
		mov	ax, es
		add	ax, cx
		mov	[exec_init_CS], ax
		xor	cx, cx
		mov	dx, [exec_rle_table]
		mov	bx, [bp-8]	; Exec_FH
		push	ds
		xor	ax, ax
		call	_$LSEEK
		pop	ds
		jnb	short exec_get_entries

Exec_Bad_FileJ:				; ...
		jmp	Exec_Bad_File
; ---------------------------------------------------------------------------

exec_get_entries:			; ...
		mov	dx, [exec_rle_count]

exec_read_reloc:			; ...
		push	dx
		mov	dx, OPENBUF
		mov	cx, 396		; ((Exec_Internal_Buffer_Size)/4)*4
					; (397>>2)<<2
		push	ds
		call	ExecRead
		pop	es
		pop	dx
		jb	short Exec_Bad_FileJ
		mov	cx, 99		; (Exec_Internal_Buffer_Size)/4	; (397>>2)
		mov	di, OPENBUF ; Exec_Internal_Buffer
		mov	si, [bp-10]	; Exec_Rel_Fac

exec_reloc_one:				; ...
		or	dx, dx
		jz	short Exec_Set_PDBJ

exec_get_addr:
		lds	bx, [es:di]
		mov	ax, ds
		add	ax, [bp-28]	; Exec_DMA_Save
		mov	ds, ax
		add	[bx], si
		add	di, 4
		dec	dx
		loop	exec_reloc_one
		push	es
		pop	ds
		jmp	short exec_read_reloc
; ---------------------------------------------------------------------------

Exec_Set_PDBJ:				; ...
		push	es
		push	ax
		push	cx
		mov	es, word [bp-28] ; Exec_DMA_Save
		mov	ax, [ss:exec_init_CS]
		mov	cx, [ss:exec_init_IP]
		;call	[ss:FixExePatch] ; call	word [ss:FixExePatch]
		call	word [ss:FixExePatch]
		pop	cx
		pop	ax
		pop	es
		jmp	Exec_Set_PDB
; ---------------------------------------------------------------------------

Exec_No_Memj:				; ...
		jmp	Exec_No_Mem
; ---------------------------------------------------------------------------

Exec_Com_File:				; ...
		test	byte [bp-5], 2 ; Exec_Func,exec_func_overlay
		jz	short Exec_Alloc_Com_File
		lds	si, [bp-4]	; lds si,Exec_Blk
		lodsw
		mov	[bp-14h], ax	; mov Exec_DMA,ax
		mov	ax, 0FFFFh
		jmp	short Exec_Read_Block
; ---------------------------------------------------------------------------

Exec_Chk_Com_Mem:			; ...
		mov	al, [ss:AllocMethod]
		mov	bl, [ss:ALLOCMSAVE]
		mov	[ss:AllocMethod], bl
		test	bl, 40h		; HIGH_ONLY
		jnz	short Exec_No_Memj
		test	al, 40h
		jz	short Exec_No_Memj
		mov	ax, [bp-18]	; Exec_Load_Block
		xor	bx, bx
		call	ChangeOwner
		jmp	short Exec_Norm_Com_Alloc
; ---------------------------------------------------------------------------

Exec_Alloc_Com_File:			; ...
		test	byte [ss:AllocMethod], 80h ; HIGH_FIRST
		jz	short Exec_Norm_Com_Alloc
		or	byte [ss:AllocMethod], 40h ; HIGH_ONLY

Exec_Norm_Com_Alloc:			; ...
		mov	bx, 0FFFFh
		call	_$ALLOC
		or	bx, bx
		jz	short Exec_Chk_Com_Mem
		mov	[bp-16], bx	; Exec_Size
		push	bx
		call	_$ALLOC
		pop	bx
		mov	[bp-18], ax	; Exec_Load_Block
		add	ax, 10h
		mov	[bp-20], ax	; Exec_DMA
		xor	ax, ax
		cmp	bx, 1000h
		jnb	short Exec_Read_Com
		mov	ax, bx
		mov	cl, 4
		shl	ax, cl
		cmp	ax, 100h
		jbe	short Exec_Chk_Com_Mem
		sub	ax, 100h

Exec_Read_Com:				; ...
		sub	ax, 100h

Exec_Read_Block:			; ...
		push	ax
		mov	bx, [bp-8]	; Exec_FH
		xor	cx, cx
		mov	dx, cx
		xor	ax, ax
		call	_$LSEEK
		pop	cx
		mov	ds, word [bp-20] ; Exec_DMA
		xor	dx, dx
		push	cx
		call	ExecRead
		pop	si
		jnb	short OkRead
		jmp	Exec_Bad_File
; ---------------------------------------------------------------------------

OkRead:					; ...
		cmp	ax, si
		jnz	short OkRead2
		jmp	Exec_Chk_Com_Mem
; ---------------------------------------------------------------------------

OkRead2:				; ...
		mov	bl, [ss:ALLOCMSAVE]
		mov	[ss:AllocMethod], bl
		test	byte [bp-5], 2 ; Exec_Func,exec_func_overlay
		jnz	short Exec_Set_PDB
		mov	ax, [bp-20]	; Exec_DMA
		sub	ax, 10h
		mov	[ss:exec_init_CS], ax
		mov	word [ss:exec_init_IP], 100h
		add	si, 0FEh
		cmp	si, 0FFFEh
		jz	short Exec_St_Ok
		add	si, 100h

Exec_St_Ok:				; ...
		mov	[ss:exec_init_SP], si
		mov	[ss:exec_init_SS], ax
		mov	ds, ax
		mov	word [si], 0
		;call	[ss:ChkCopyProt] ; call	word [ss:ChkCopyProt]
		call	word [ss:ChkCopyProt]

Exec_Set_PDB:				; ...
		mov	bx, [bp-8]	; Exec_FH
		call	Exec_Dealloc
		push	bp
		call	_$CLOSE
		pop	bp
		call	Exec_Alloc
		test	byte [bp-5], 2 ; Exec_Func,exec_func_overlay
		jz	short Exec_Build_Header
		call	Scan_Execname
		call	Scan_Special_Entries
		cmp	byte [ss:DriverLoad], 0
		jz	short norm_ovl
		push	si
		push	es
		les	si, [ss:BiosDataPtr]
		cmp	byte [es:si], 0
		jz	short sysinit_done
		mov	es, [ss:CurrentPDB]
		push	word [ss:SPECIAL_VERSION] ; push word [ss:SPECIAL_VERSION]
		pop	word [es:SFTFCB] ; pop word [es:PDB.Version]
		jmp	short setver_done
; ---------------------------------------------------------------------------

sysinit_done:				; ...
		mov	byte [ss:DriverLoad], 0

setver_done:				; ...
		pop	es
		pop	si

norm_ovl:				; ...
		mov	sp, bp
		pop	bp
		jmp	SYS_RETURN	; SYS_RET_OK
; ---------------------------------------------------------------------------

Exec_Build_Header:			; ...
		mov	dx, [bp-18]	; Exec_Load_Block
		mov	si, 1		; ARENA.OWNER
		mov	ax, [bp-14]	; Exec_Environ
		or	ax, ax
		jz	short No_Owner
		dec	ax
		mov	ds, ax
		mov	[si], dx

No_Owner:				; ...
		mov	ax, [bp-18]	; Exec_Load_Block
		dec	ax
		mov	ds, ax
		mov	[si], dx
		push	ds
		pop	es
		mov	di, 8		; ARENA.NAME
		call	Scan_Execname
		push	cx
		push	si

MoveName:				; ...
		lodsb
		cmp	al, '.'         ; 2Eh
		jz	short Mem_Done
		stosb
		cmp	di, 16		; ARENAHEADERSIZE
		jnb	short Mem_Done
		loop	MoveName

Mem_Done:				; ...
		xor	al, al
		cmp	di, 16		; ARENAHEADERSIZE
		jnb	short Fill8
		stosb

Fill8:					; ...
		pop	si
		pop	cx
		call	Scan_Special_Entries
		push	dx
		mov	si, [bp-16]	; Exec_Size
		add	si, dx
		call	_$DUP_PDB
		pop	dx
		push	word [bp-14] ; Exec_Environ
		pop	word [es:2Ch] ; [ES:PDB.ENVIRON]
		push	word [ss:SPECIAL_VERSION]
		pop	word [es:SFTFCB] ; [ES:PDB.Version]
		lds	si, [bp-4]	; Exec_Blk
		push	ds
		push	si
		lds	si, [si+6]	; [SI+EXEC0.5C_FCB]
		mov	cx, 12
		push	cx
		mov	di, 5Ch
		mov	bl, [si]
		rep movsb
		xor	ax, ax
		stosw
		stosw
		pop	cx
		pop	si
		pop	ds
		push	ds
		push	si
		lds	si, [si+0Ah]	; [SI+EXEC0.6C_FCB]
		mov	bh, [si]
		rep movsb
		stosw
		stosw
		pop	si
		pop	ds
		lds	si, [si+2]	; [SI+EXEC0.COM_LINE]
		or	cl, 80h
		mov	di, cx
		rep movsb
		dec	cl
		mov	al, bh
		xor	bh, bh
		call	GetVisDrv
		jnb	short Exec_BL
		mov	bh, cl

Exec_BL:				; ...
		mov	al, bl
		xor	bl, bl
		call	GetVisDrv
		jnb	short Exec_Set_Return
		mov	bl, cl

Exec_Set_Return:			; ...
		call	Get_User_Stack
		push	word [si+14h] ; [SI+user_env.user_CS]
		push	word [si+12h] ; [SI+user_env.user_IP]
		push	word [si+14h] ; [SI+user_env.user_CS]
		push	word [si+12h] ; [SI+user_env.user_IP]
		pop	word [es:0Ah] ; [ES:PDB.EXIT]
		pop	word [es:0Ch] ; [ES:PDB.EXIT+2]
		xor	ax, ax
		mov	ds, ax
		pop	word [88h] ; [addr_int_terminate] ; 22h*4
		pop	word [8Ah] ; [addr_int_terminate+2] ; (22h*4)+2
		mov	word [ss:DMAADD], 80h
		mov	ds, [ss:CurrentPDB]
		mov	word [ss:DMAADD+2],	ds
		test	byte [bp-5], 1 ; Exec_Func,exec_func_no_execute
		jz	short exec_go
		lds	si, [ss:exec_init_SP]
		les	di, [bp-4]	; Exec_Blk
		mov	word [es:di+10h], ds ; [ES:DI+EXEC1.SS]
		dec	si
		dec	si
		mov	[si], bx
		mov	[es:di+0Eh], si	; [ES:DI+EXEC1.SP]
		lds	ax, [ss:exec_init_IP]
		mov	word [es:di+14h], ds ; [ES:DI+EXEC1.CS]
		mov	[es:di+12h], ax	; [ES:DI+EXEC1.IP]
		mov	sp, bp
		pop	bp
		jmp	SYS_RETURN	; SYS_RET_OK
; ---------------------------------------------------------------------------

exec_go:				; ...
		lds	si, [ss:exec_init_IP]
		les	di, [ss:exec_init_SP]
		mov	ax, es
		cmp	byte [ss:DosHasHMA], 0
		jz	short Xfer_To_User
		push	ds
		mov	ds, [cs:DosDSeg]
		or	byte [DOS_FLAG], 4 ; EXECA20OFF
		mov	[A20OFF_PSP], dx
		mov	ax, ds
		pop	ds
		push	ax
		mov	ax, disa20_xfer
		push	ax
		mov	ax, es
		retf
; ---------------------------------------------------------------------------

Xfer_To_User:				; ...
		cli
		mov	byte [ss:INDOS], 0
		mov	ss, ax
		mov	sp, di
		sti
		push	ds
		push	si
		mov	es, dx
		mov	ds, dx
		mov	ax, bx
		retf

; =============== S U B	R O U T	I N E =======================================

ExecRead:		; ...
		call	Exec_Dealloc
		mov	bx, [bp-8]	; Exec_FH
		push	bp
		call	_$READ
		pop	bp
		call	Exec_Alloc
		retn

; =============== S U B	R O U T	I N E =======================================

Exec_Dealloc:	; ...
		push	bx
		sub	bx, bx
		call	ECritDisk	; call ECritMEM
		call	ChangeOwners
		pop	bx
		retn

; =============== S U B	R O U T	I N E =======================================

Exec_Alloc:		; ...
		push	bx
		mov	bx, [ss:CurrentPDB]
		call	ChangeOwners
		call	LCritDisk	; call LCritMEM
		pop	bx
		retn

; =============== S U B	R O U T	I N E =======================================

ChangeOwners:	; ...
		pushf
		push	ax
		mov	ax, [bp-14]	; Exec_Environ
		call	ChangeOwner
		mov	ax, [bp-18]	; Exec_Load_Block
		call	ChangeOwner
		pop	ax
		popf

chgown_retn:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================

ChangeOwner:	; ...
		or	ax, ax
		jz	short chgown_retn
		dec	ax
		push	ds
		mov	ds, ax
		mov	[1],	bx	; [ARENA.OWNER]
		pop	ds
		retn

; =============== S U B	R O U T	I N E =======================================

Scan_Execname:	; ...
		lds	si, [bp-26]	; ExecName

Save_Begin:				; ...
		mov	cx, si

Scan0:					; ...
		lodsb
		cmp	al, ':'         ; 3Ah
		jz	short Save_Begin
		cmp	al, '\'         ; 5Ch
		jz	short Save_Begin
		cmp	al, 0
		jnz	short Scan0
		sub	si, cx
		xchg	si, cx
		retn

; =============== S U B	R O U T	I N E =======================================

Scan_Special_Entries: ; ...
		dec	cx
		mov	word [ss:SPECIAL_VERSION], 5
		les	di, [ss:UU_IFS_DOS_CALL]
		mov	ax, es
		or	ax, di
		jz	short End_List

GetEntries:				; ...
		mov	al, [es:di]
		or	al, al
		jz	short End_List
		mov	[ss:TEMP_VAR2],	di
		cmp	al, cl
		jnz	short SkipOne
		inc	di
		push	cx
		push	si
		push	ax

sse_next_char:				; ...
		lodsb
		call	UCase
		scasb
		jnz	short Not_Matched
		loop	sse_next_char
		pop	ax
		mov	ax, [es:di]
		mov	[ss:SPECIAL_VERSION], ax
		pop	si
		pop	cx
		jmp	short End_List
; ---------------------------------------------------------------------------

Not_Matched:				; ...
		pop	ax
		pop	si
		pop	cx

SkipOne:				; ...
		mov	di, [ss:TEMP_VAR2]
		xor	ah, ah
		add	di, ax
		add	di, 3
		jmp	short GetEntries
; ---------------------------------------------------------------------------

End_List:				; ...
		retn

; ---------------------------------------------------------------------------

_$KEEP_PROCESS:				; ...
		push	ax
		mov	byte [ss:EXIT_TYPE], 3 ; EXIT_KEEP_PROCESS
		mov	es, [ss:CurrentPDB]
		cmp	dx, 6
		jnb	short Keep_Shrink
		mov	dx, 6

Keep_Shrink:				; ...
		mov	bx, dx
		push	bx
		push	es
		call	_$SETBLOCK
		pop	ds
		pop	bx
		jb	short Keep_Done
		mov	ax, ds
		add	ax, bx
		mov	[2], ax	; [PDB.BLOCK_LEN]

Keep_Done:				; ...
		pop	ax
		jmp	short exit_inner
; ---------------------------------------------------------------------------

STAY_RESIDENT:				; ...
		mov	ax, 3100h	; (KEEP_PROCESS<<8)+0
		add	dx, 15
		rcr	dx, 1
		mov	cl, 3
		shr	dx, cl
		jmp	COMMAND
; ---------------------------------------------------------------------------

_$EXIT:					; ...
		xor	ah, ah
		xchg	ah, [ss:DidCTRLC]
		or	ah, ah
		mov	byte [ss:EXIT_TYPE], 0 ; EXIT_TERMINATE
		jz	short exit_inner
		mov	byte [ss:EXIT_TYPE], 1 ; EXIT_CTRL_C

exit_inner:				; ...
		call	Get_User_Stack
		push	word [ss:CurrentPDB]
		pop	word [si+14h] ; [SI+user_env.user_CS]
		jmp	short abort_inner
; ---------------------------------------------------------------------------

_$ABORT:				; ...
		xor	al, al
		mov	byte [ss:EXIT_TYPE], 0 ; EXIT_ABORT

abort_inner:				; ...
		mov	ah, [ss:EXIT_TYPE]
		mov	[ss:exit_code],	ax
		call	Get_User_Stack
		mov	ds, word [si+14h] ; [SI+user_env.user_CS]
		xor	ax, ax
		mov	es, ax
		mov	si, 10		; SAVEXIT
		mov	di, 88h		; addr_int_terminate
		movsw
		movsw
		movsw
		movsw
		movsw
		movsw
		jmp	reset_environment
; ---------------------------------------------------------------------------

RetExePatch:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================

arena_free_process:	; ...
		mov	ax, [ss:arena_head]

arena_free_process_start:		; ...
		mov	di, 0		; ARENA.SIGNATURE
		call	check_signature

arena_free_process_loop:		; ...
		jb	short AFP_RETN
		push	es
		pop	ds
		cmp	[1],	bx	; [ARENA.OWNER]
		jnz	short arena_free_next
		mov	[1],	di

arena_free_next:			; ...
		cmp	byte [di], 5Ah ; 'Z' ; arena_signature_end
		jz	short arena_chk_umbs
		call	arena_next
		jmp	short arena_free_process_loop
; ---------------------------------------------------------------------------

arena_chk_umbs:				; ...
		mov	ax, [ss:UMB_HEAD]
		cmp	ax, 0FFFFh
		jz	short AFP_RETN
		mov	di, ds
		cmp	di, ax
		jnb	short AFP_RETN
		jmp	short arena_free_process_start

; ---------------------------------------------------------------------------

arena_next:				; ...
		mov	ax, ds
		add	ax, [3]	; [ARENA.SIZE]
		inc	ax

; =============== S U B	R O U T	I N E =======================================

check_signature:
		mov	es, ax
		cmp	byte [es:di], 4Dh ;	'M' ; arena_signature_normal
		jz	short AFP_RETN
		cmp	byte [es:di], 5Ah ;	'Z' ; arena_signature_end
		jz	short AFP_RETN
		stc

AFP_RETN:				; ...
		retn			; COALESCE_RETN

; =============== S U B	R O U T	I N E =======================================

Coalesce:		; ...
		cmp	byte [di], 5Ah ; 'Z' ; arena_signature_end
		jz	short AFP_RETN	; COALESCE_RETN
		call	arena_next
		jb	short AFP_RETN	; COALESCE_RETN
		cmp	[es:1],	di	; [ES:ARENA.OWNER]
		jnz	short AFP_RETN	; COALESCE_RETN
		mov	cx, [es:3]	; [ES:ARENA.SIZE]
		inc	cx
		add	[3], cx		; [ARENA.SIZE]
		mov	cl, [es:di]
		mov	[di], cl
		jmp	short Coalesce

; ---------------------------------------------------------------------------

_$ALLOC:				; ...
		call	ECritDisk	; call ECritMEM
		mov	ax, [ss:arena_head]
		mov	[ss:START_ARENA], ax
		test	byte [ss:AllocMethod], 0C0h ; HIGH_FIRST+HIGH_ONLY
		jz	short norm_alloc
		test	byte [ss:UMBFLAG], 1 ; LINKSTATE
		jz	short norm_alloc
		mov	ax, [ss:UMB_HEAD]
		mov	[ss:START_ARENA], ax

norm_alloc:				; ...
		xor	ax, ax
		mov	di, ax
		mov	[ss:FirstArena], ax
		mov	[ss:BestArena],	ax
		mov	[ss:LastArena],	ax
		push	ax

start_scan:				; ...
		mov	ax, [ss:START_ARENA]
		call	check_signature
		jb	short alloc_err

alloc_scan:				; ...
		push	es
		pop	ds
		cmp	[1], di		; [ARENA.OWNER]
		jz	short alloc_free

alloc_next:				; ...
		test	byte [ss:UMBFLAG], 1 ; LINKSTATE
		jz	short norm_strat
		test	byte [ss:AllocMethod], 80h ; HIGH_FIRST
		jz	short norm_strat
		mov	ax, [ss:START_ARENA]
		cmp	ax, [ss:arena_head]
		jnz	short norm_strat
		mov	ax, ds
		cmp	ax, [ss:UMB_HEAD]
		jmp	short alloc_chk_end
; ---------------------------------------------------------------------------

norm_strat:				; ...
		cmp	byte [di], 5Ah ; 'Z' ; arena_signature_end

alloc_chk_end:				; ...
		jz	short alloc_end
		call	arena_next
		jnb	short alloc_scan

alloc_err:				; ...
		pop	ax
; START	OF FUNCTION CHUNK FOR _$SETBLOCK

alloc_trashed:				; ...
		call	LCritDisk	; call LCritMEM
		mov	al, 7		; error_arena_trashed

alloc_errj:				; ...
		jmp	SYS_RET_ERR
; END OF FUNCTION CHUNK	FOR _$SETBLOCK
; ---------------------------------------------------------------------------

alloc_end:				; ...
		cmp	word [ss:FirstArena], 0
		jz	short alloc_chk
		jmp	alloc_do_split
; ---------------------------------------------------------------------------

alloc_chk:				; ...
		mov	ax, [ss:arena_head]
		cmp	ax, [ss:START_ARENA]
		jz	short alloc_fail
		test	byte [ss:AllocMethod], 40h ; HIGH_ONLY
		jnz	short alloc_fail
		mov	[ss:START_ARENA], ax
		jmp	short start_scan
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR _$SETBLOCK

alloc_fail:				; ...
		call	Get_User_Stack
		pop	bx
		mov	[si+2],	bx	; [SI+user_env.user_BX]
		call	LCritDisk	; call LCritMEM
		mov	al, 8		; error_not_enough_memory
		jmp	short alloc_errj
; END OF FUNCTION CHUNK	FOR _$SETBLOCK
; ---------------------------------------------------------------------------

alloc_free:				; ...
		call	Coalesce
		jb	short alloc_err
		mov	cx, [3]	; [ARENA.SIZE]
		pop	dx
		cmp	cx, dx
		jbe	short alloc_test
		mov	dx, cx

alloc_test:				; ...
		push	dx
		cmp	bx, cx
		ja	short alloc_next
		cmp	word [ss:FirstArena], 0
		jnz	short alloc_best
		mov	[ss:FirstArena], ds

alloc_best:				; ...
		cmp	word [ss:BestArena], 0
		jz	short alloc_make_best
		push	es
		mov	es, [ss:BestArena]
		cmp	[es:3],	cx	; [ES:ARENA.SIZE]
		pop	es
		jbe	short alloc_last

alloc_make_best:			; ...
		mov	[ss:BestArena],	ds

alloc_last:				; ...
		mov	[ss:LastArena],	ds
		jmp	alloc_next
; ---------------------------------------------------------------------------

alloc_do_split_high:			; ...
		mov	ds, [ss:LastArena]
		mov	cx, [3]	; [ARENA.SIZE]
		sub	cx, bx
		mov	dx, ds
		jz	short alloc_set_owner
		add	dx, cx
		mov	es, dx
		dec	cx
		xchg	bx, cx
		jmp	short alloc_set_sizes
; ---------------------------------------------------------------------------

alloc_do_split:				; ...
		xor	cx, cx
		mov	cl, [ss:AllocMethod]
		and	cx, 0FF3Fh	; STRAT_MASK
		cmp	cx, 1		; BEST_FIT
		ja	short alloc_do_split_high
		mov	ds, [ss:FirstArena]
		jb	short alloc_get_size
		mov	ds, [ss:BestArena]
; START	OF FUNCTION CHUNK FOR _$SETBLOCK

alloc_get_size:				; ...
		mov	cx, [3]	; [ARENA.SIZE]
		sub	cx, bx
		mov	ax, ds
		mov	dx, ax
		jz	short alloc_set_owner
		add	ax, bx
		inc	ax
		mov	es, ax
		dec	cx

alloc_set_sizes:			; ...
		mov	[3],	bx	; [ARENA.SIZE]
		mov	[es:3],	cx	; [ES:ARENA.SIZE]
		mov	bl, 4Dh	; 'M'   ; arena_signature_normal
		xchg	bl, [di]
		mov	[es:di], bl
		mov	[es:1],	di	; [ES:ARENA.OWNER]

alloc_set_owner:			; ...
		mov	ds, dx
		mov	ax, [ss:CurrentPDB]
		mov	[1],	ax	; [ARENA.OWNER]
		mov	ax, ds
		inc	ax
		pop	bx
		call	LCritDisk	; call LCritMEM

alloc_ok:				; ...
		jmp	SYS_RETURN	; SYS_RET_OK
; END OF FUNCTION CHUNK	FOR _$SETBLOCK

; =============== S U B	R O U T	I N E =======================================

_$SETBLOCK:		; ...

; FUNCTION CHUNK AT A2A2 SIZE 00000008 BYTES
; FUNCTION CHUNK AT A2CE SIZE 0000000E BYTES
; FUNCTION CHUNK AT A355 SIZE 0000003A BYTES

		call	ECritDisk	; call ECritMEM
		mov	di, 0		; ARENA.SIGNATURE
		mov	ax, es
		dec	ax
		call	check_signature
		jnb	short setblock_grab

setblock_bad:				; ...
		jmp	alloc_trashed
; ---------------------------------------------------------------------------

setblock_grab:				; ...
		mov	ds, ax
		call	Coalesce
		jb	short setblock_bad
		mov	cx, [3]	; [ARENA.SIZE]
		push	cx
		cmp	bx, cx
		jbe	short alloc_get_size
		jmp	alloc_fail

; =============== S U B	R O U T	I N E =======================================

_$DEALLOC:		; ...
		call	ECritDisk	; call ECritMEM
		test	byte [ss:DOS_FLAG], 4 ; EXECA20OFF
		jz	short deallocate
		cmp	byte [ss:A20OFF_COUNT], 0
		jnz	short deallocate
		mov	byte [ss:A20OFF_COUNT], 1

deallocate:				; ...
		mov	di, 0		; ARENA.SIGNATURE
		mov	ax, es
		dec	ax
		call	check_signature
		jb	short dealloc_err
		mov	[es:1],	di	; [ES:ARENA.OWNER]
		call	LCritDisk	; call LCritMEM

dealloc_ok:				; ...
		jmp	short alloc_ok
; ---------------------------------------------------------------------------

dealloc_err:				; ...
		call	LCritDisk	; call LCritMEM
		mov	al, 9		; error_invalid_block

dealloc_errj:				; ...
		jmp	SYS_RET_ERR

; ---------------------------------------------------------------------------

_$ALLOCOPER:				; ...
		or	al, al
		jz	short AllocGetStrat
		cmp	al, 1
		jz	short AllocSetStrat
		cmp	al, 2
		jz	short AllocGetLink
		cmp	al, 3
		jz	short AllocSetLink

AllocOperError:				; ...
		mov	byte [ss:EXTERR_LOCUS], 5 ; errLOC_Mem
		mov	al, 1		; error_invalid_function

AllocOperErrj:				; ...
		jmp	short dealloc_errj
; ---------------------------------------------------------------------------

AllocArenaError:			; ...
		mov	byte [ss:EXTERR_LOCUS], 5 ; errLOC_Mem
		mov	al, 7		; error_arena_trashed
		jmp	short AllocOperErrj
; ---------------------------------------------------------------------------

AllocGetStrat:				; ...
		mov	al, [ss:AllocMethod]
		xor	ah, ah

AllocOperOk:				; ...
		jmp	short dealloc_ok
; ---------------------------------------------------------------------------

AllocSetStrat:				; ...
		push	bx
		and	bx, 0FF3Fh
		cmp	bx, 2
		pop	bx
		ja	short AllocOperError
		mov	[ss:AllocMethod], bl

AllocOperOkj:				; ...
		jmp	short AllocOperOk
; ---------------------------------------------------------------------------

AllocGetLink:				; ...
		mov	al, [ss:UMBFLAG]
		and	al, 1		; LINKSTATE

AllocOperOkj2:				; ...
		jmp	short AllocOperOkj
; ---------------------------------------------------------------------------

AllocSetLink:				; ...
		mov	cx, [ss:UMB_HEAD]
		cmp	cx, 0FFFFh
		jz	short AllocOperError
		cmp	bx, 1
		jb	short UnlinkUmbs
		jz	short LinkUmbs
		jmp	short AllocOperError
; ---------------------------------------------------------------------------

UnlinkUmbs:				; ...
		test	byte [ss:UMBFLAG], 1 ; LINKSTATE
		jz	short unlinked
		call	GetLastArena
		jb	short AllocArenaError
		mov	byte [0], 5Ah ; 'Z' ; arena_signature_end
		and	byte [ss:UMBFLAG], 0FEh ; ~LINKSTATE

unlinked:				; ...
		jmp	short AllocOperOkj2
; ---------------------------------------------------------------------------

LinkUmbs:				; ...
		test	byte [ss:UMBFLAG], 1 ; LINKSTATE
		jnz	short linked
		call	GetLastArena
		jb	short AllocArenaError
		mov	byte [0], 4Dh ; 'M' ; arena_signature_normal
		or	byte [ss:UMBFLAG], 1 ; LINKSTATE

linked:					; ...
		jmp	short unlinked

; =============== S U B	R O U T	I N E =======================================

GetLastArena:	; ...
		push	ax
		mov	ax, [ss:arena_head]
		mov	es, ax
		xor	di, di
		cmp	byte [es:di], 5Ah ; 'Z' ; arena_signature_end
		jz	short GLA_done

GLA_next:				; ...
		mov	ds, ax
		call	arena_next
		jb	short GLA_err
		test	byte [ss:UMBFLAG], 1 ; LINKSTATE
		jnz	short GLA_chkumb
		cmp	byte [es:di], 5Ah ; 'Z'
		jmp	short GLA_@f
; ---------------------------------------------------------------------------

GLA_chkumb:				; ...
		cmp	ax, cx

GLA_@f:					; ...
		jnz	short GLA_next

GLA_done:				; ...
		test	byte [ss:UMBFLAG], 1
		jnz	short GLA_ret
		mov	ds, ax
		call	arena_next
		jb	short GLA_err
		cmp	ax, cx
		jnz	short GLA_err

GLA_ret:				; ...
		clc
		pop	ax
		retn
; ---------------------------------------------------------------------------

GLA_err:				; ...
		stc
		pop	ax
		retn

; ---------------------------------------------------------------------------
SERVERTAB	dw SERVER_DISP	; ...
					; SRVC001S
SERVERLEAVE	dw SERVERRETURN	; ...
SERVER_DISP	db 11			; ...
					; (SERVER_DISP_END-SERVER_DISP-1)/2
					; ; = 11
		dw SRV_CALL	; 0
		dw COMMIT_ALL	; 1
		dw CLOSE_NAME	; 2
		dw CLOSE_UID	; 3
		dw CLOSE_UID_PID	; 4
		dw GET_LIST	; 5
		dw GET_DOS_DATA	; 6
		dw SPOOL_OPER	; 7
		dw SPOOL_OPER	; 8
		dw SPOOL_OPER	; 9
		dw _$SetExtendedError ; 10
; ---------------------------------------------------------------------------

_$ServerCall:				; ...
		cmp	al, 7
		jb	short SET_STUFF
		cmp	al, 9
		jbe	short NO_SET_ID

SET_STUFF:				; ...
		mov	si, dx
		mov	bx, [si+12h]	; [SI+DPL.UID]
		test	byte [ss:IsWin386], 1
		jnz	short skip_win386
		mov	[ss:USER_ID], bx

skip_win386:				; ...
		mov	bx, [si+14h]	; [SI+DPL.PID]
		mov	[ss:PROC_ID], bx

NO_SET_ID:				; ...
		push	word [cs:SERVERLEAVE]
		push	word [cs:SERVERTAB]
		push	ax
		call	TableDispatch
		mov	byte [ss:EXTERR_LOCUS], 1 ; errLOC_Unk
		mov	al, 1		; error_invalid_function

servercall_error:			; ...
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

SERVERRETURN:				; ...
		retn
; ---------------------------------------------------------------------------

COMMIT_ALL:				; ...
		xor	bx, bx
		push	ss
		pop	ds
		call	ECritDisk	; call ECritSFT

CommitLoop:				; ...
		push	bx
		call	SFFromSFN
		jb	short CommitDone
		cmp	word [es:di], 0 ; [ES:DI+SF_ENTRY.sf_Ref_Count]
		jz	short CommitNext
		cmp	word [es:di], 0FFFFh ; [ES:DI+SF_ENTRY.sf_Ref_Count],
					; sf_busy
		jz	short CommitNext
		test	word [es:di+5], 8000h ; [ES:DI+SF_ENTRY.sf_flags],
					; sf_isnet
		jnz	short CommitNext
		mov	word [THISSFT], di
		mov	word [THISSFT+2], es
		call	DOS_COMMIT

CommitNext:				; ...
		pop	bx
		inc	bx
		jmp	short CommitLoop
; ---------------------------------------------------------------------------

CommitDone:				; ...
		call	LCritDisk	; call LCritSFT
		pop	bx

Commit_Ok:				; ...
		jmp	SYS_RETURN	; SYS_RET_OK
; ---------------------------------------------------------------------------

CLOSE_NAME:				; ...
		;call	dword [ss:MFTcloN] ; Call far [SS:JShare+(5*4)] ; 5 = MFTcloN
		call	far [ss:JShare+(5*4)]
CheckReturns:				; ...
		jb	short func_err

Commit_Okj:				; ...
		jmp	short Commit_Ok
; ---------------------------------------------------------------------------

func_err:				; ...
		jmp	short servercall_error
; ---------------------------------------------------------------------------

CLOSE_UID:				; ...
		;call	[ss:MFTclU]	; Call far [SS:JShare+(3*4)] ; 3 = MTFTclu
		call	far [ss:JShare+(3*4)]
		jmp	short CheckReturns
; ---------------------------------------------------------------------------

CLOSE_UID_PID:				; ...
		;call	dword [ss:MFTCloseP]
		call	far [ss:JShare+(4*4)]
		jmp	short CheckReturns
; ---------------------------------------------------------------------------

GET_LIST:				; ...
		;call	[ss:MFT_get]	; Call far [SS:JShare+(9*4)] ; 9 = MFT_get
		call	far [SS:JShare+(9*4)]
		jb	short func_err
		call	Get_User_Stack
		mov	[si+2],	bx	; [SI+user_env.user_BX]
		mov	[si+10], di	; [SI+user_env.user_DI]
		mov	word [si+16], es ; [SI+user_env.user_ES]

SetCXOK:				; ...
		mov	[si+4],	cx	; [SI+user_env.user_CX]

Commit_Okj2:				; ...
		jmp	short Commit_Okj
; ---------------------------------------------------------------------------

SRV_CALL:				; ...
		pop	ax
		push	ds
		push	si
		call	Get_User_Stack
		pop	di
		pop	es
		call	XCHGP
		push	si
		mov	cx, 6
		rep movsw
		inc	di
		inc	di
		movsw
		movsw
		pop	si
		mov	ax, [si]	; [SI+DPL.AX]
		mov	bx, [si+2]	; [SI+DPL.BX]
		mov	cx, [si+4]	; [SI+DPL.CX]
		mov	dx, [si+6]	; [SI+DPL.DX]
		mov	di, [si+10]	; [SI+DPL.DI]
		mov	es, word [si+14] ; [SI+DPL.ES]
		push	word [si+8]	; [SI+DPL.SI]
		mov	ds, word [si+12] ; [SI+DPL.DS]
		pop	si
		mov	[ss:SAVEDS], ds
		mov	[ss:SAVEBX], bx
		mov	byte [ss:FSHARING], 0FFh ; -1
		jmp	REDISP
; ---------------------------------------------------------------------------

GET_DOS_DATA:				; ...
		push	ss
		pop	es
		mov	di, ERRORMODE ; SWAP_START
		mov	cx, SWAP_END
		mov	dx, USER_IN_AX ; SWAP_ALWAYS
		sub	cx, di
		sub	dx, di
		shr	cx, 1
		adc	cx, 0
		shl	cx, 1
		call	Get_User_Stack
		mov	word [si+14], es ; [SI+user_env.user_DS]
		mov	[si+8],	di	; [SI+user_env.user_SI]
		mov	[si+6],	dx	; [SI+user_env.user_DX]
		jmp	short SetCXOK
; ---------------------------------------------------------------------------

SPOOL_OPER:				; ...
		push	ax
		mov	ax, 1125h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - REDIRECTED PRINTER MODE
					; STACK: WORD subfunction
					; Return: CF set on error, AX =	error code
					; STACK	unchanged
		pop	bx
		jb	short func_err2
		jmp	short Commit_Okj2
; ---------------------------------------------------------------------------

func_err2:				; ...
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

_$SetExtendedError:			; ...
		mov	ax, [si]	; [SI+DPL.AX]
		mov	word [ss:EXTERR], ax
		mov	ax, [si+10]	; [SI+DPL.DI]
		mov	word [ss:EXTERRPT],	ax
		mov	ax, [si+14]	; [SI+DPL.ES]
		mov	word [ss:EXTERRPT+2], ax
		mov	ax, [si+2]	; [SI+DPL.BX]
		mov	word [ss:EXTERR_ACTION], ax
		mov	ax, [si+4]	; [SI+DPL.CX]
		mov	byte [ss:EXTERR_LOCUS], ah
		retn

; =============== S U B	R O U T	I N E =======================================

pJFNFromHandle:	; ...
		mov	es, [cs:DosDSeg]
		mov	es, [es:CurrentPDB]
		cmp	bx, [es:32h]	; [ES:PDB.JFN_Length]
		jb	short pjfn10
		mov	al, 6		; error_invalid_handle

ReturnCarry:				; ...
		stc
		retn
; ---------------------------------------------------------------------------

pjfn10:					; ...
		les	di, [es:34h]	; [ES:PDB.JFN_Pointer]
		add	di, bx

pJFNFromHandle_error:			; ...
		retn

; =============== S U B	R O U T	I N E =======================================

SFFromHandle:	; ...
		call	pJFNFromHandle
		jb	short pJFNFromHandle_error
		cmp	byte [es:di], 0FFh ; -1
		jnz	short GetSF
		mov	al, 6
		jmp	short ReturnCarry
; ---------------------------------------------------------------------------

GetSF:					; ...
		push	bx
		mov	bl, [es:di]
		xor	bh, bh
		call	SFFromSFN
		pop	bx
		retn

; =============== S U B	R O U T	I N E =======================================

SFFromSFN:		; ...
		mov	es, [cs:DosDSeg]
		les	di, [es:SFT_ADDR]

sfsfn5:					; ...
		cmp	bx, [es:di+4]	; [ES:DI+SFT.SFCount]
		jb	short sfsfn7
		sub	bx, [es:di+4]
		les	di, [es:di]	; [ES:DI+SFT.SFLink]
		cmp	di, 0FFFFh	; -1
		jnz	short sfsfn5
		stc
		retn
; ---------------------------------------------------------------------------

sfsfn7:					; ...
		push	ax
		mov	ax, 59		; SF_ENTRY.size
		mul	bl
		add	di, ax
		pop	ax
		add	di, 6		; SFT.SFTable
		retn

; =============== S U B	R O U T	I N E =======================================

JFNFree:
		xor	bx, bx

jfnf1:					; ...
		call	pJFNFromHandle
		jb	short jfnf5
		cmp	byte [es:di], 0FFh ; -1
		jz	short jfnfx
		inc	bx
		jmp	short jfnf1
; ---------------------------------------------------------------------------

jfnf5:					; ...
		mov	al, 4		; error_too_many_open_files

jfnfx:					; ...
		retn

; =============== S U B	R O U T	I N E =======================================

SFNFree:
		push	ax
		xor	bx, bx

sfnf5:					; ...
		push	bx
		call	SFFromSFN
		pop	bx
		jb	short sfnf95
		cmp	word [es:di], 0 ; [ES:DI+SF_ENTRY.sf_Ref_Count]
		jz	short sfnf20
		cmp	word [es:di], 0FFFFh ; [ES:DI+SF_ENTRY.sf_ref_count],
					; sf_busy
		jz	short sfnf10

sfnf7:					; ...
		inc	bx
		jmp	short sfnf5
; ---------------------------------------------------------------------------

sfnf10:					; ...
		mov	ax, [ss:USER_ID]
		cmp	[es:di+2Fh], ax	; [ES:DI+SF_ENTRY.sf_UID]
		jnz	short sfnf7
		mov	ax, [ss:PROC_ID]
		cmp	[es:di+31h], ax	; [ES:DI+SF_ENTRY.sf_PID]
		jnz	short sfnf7

sfnf20:					; ...
		mov	word [es:di], 0FFFFh ; sf_busy
		mov	ax, [ss:USER_ID]
		mov	[es:di+2Fh], ax	; [ES:DI+SF_ENTRY.sf_UID]
		mov	ax, [ss:PROC_ID]
		mov	[es:di+31h], ax	; [ES:DI+SF_ENTRY.sf_PID]
		pop	ax
		clc
		retn
; ---------------------------------------------------------------------------

sfnf95:					; ...
		pop	ax
		mov	al, 4		; error_too_many_open_files
		retn

; =============== S U B	R O U T	I N E =======================================

 _$CLOSE:

; FUNCTION CHUNK AT 43E4 SIZE 0000001C BYTES

		call	CheckOwner
		jb	short CloseError
		push	ss
		pop	ds
		mov	word [THISSFT], di
		mov	word [THISSFT+2], es
		cmp	word [es:di], 1 ; [ES:DI+SF_ENTRY.sf_ref_count]
		jz	short FreeJFN
		mov	al, [es:di+2]	; [ES:DI+SF_ENTRY.sf_mode]
		and	al, 0F0h	; SHARING_MASK
		cmp	al, 70h		; SHARING_NET_FCB
		jz	short PostFree

FreeJFN:				; ...
		call	pJFNFromHandle
		mov	byte [es:di], 0FFh

PostFree:				; ...
		call	DOS_CLOSE
		jb	short CloseError
		mov	ah, 3Eh		; CLOSE

CloseOk:				; ...
		jmp	SYS_RETURN	; SYS_RET_OK
; ---------------------------------------------------------------------------

CloseError:				; ...
		jmp	SYS_RET_ERR

; ---------------------------------------------------------------------------

_$COMMIT:				; ...
		call	CheckOwner
		jb	short CommitError
		push	ss
		pop	ds
		mov	word [THISSFT], di
		mov	word [THISSFT+2], es
		call	DOS_COMMIT
		jb	short CommitError
		mov	ah, 68h		; COMMIT
; START	OF FUNCTION CHUNK FOR _$READ

CommitOk:				; ...
		jmp	short CloseOk
; ---------------------------------------------------------------------------

CommitError:				; ...
		jmp	short CloseError
; END OF FUNCTION CHUNK	FOR _$READ
; ---------------------------------------------------------------------------

_$ExtHandle:				; ...
		xor	bp, bp
		cmp	bx, 20		; FILPERPROC
		jnb	short exth2
		mov	bx, 20

exth2:					; ...
		mov	es, [ss:CurrentPDB]
		mov	cx, [es:32h]	; [ES:PDB.JFN_Length]
		cmp	bx, cx
		jz	short ok_done
		ja	short larger
		mov	bp, 1
		mov	ds, word [es:36h] ;	[ES:PDB.JFN_Pointer+2]
		mov	si, bx
		sub	cx, bx

chck_handles:				; ...
		cmp	byte [si], 0FFh ; -1
		jnz	short too_many_files
		inc	si
		loop	chck_handles
		cmp	bx, 20		; FILPERPROC
		ja	short larger
		mov	bp, 2
		mov	di, 24		; PDB.JFN_TABLE
		push	bx
		jmp	short movhandl
; ---------------------------------------------------------------------------

larger:					; ...
		cmp	bx, 0FFFFh	; -1
		jz	short invalid_func
		clc
		push	bx
		add	bx, 0Fh
		mov	cl, 4
		rcr	bx, cl
		and	bx, 1FFFh
		push	bp
		call	_$ALLOC
		pop	bp
		jb	short no_memory
		mov	es, ax
		xor	di, di

movhandl:				; ...
		mov	ds, [ss:CurrentPDB]
		test	bp, 3
		jz	short enlarge
		pop	cx
		push	cx
		jmp	short copy_hand
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR _$READ

ok_done:				; ...
		jmp	short CommitOk
; END OF FUNCTION CHUNK	FOR _$READ
; ---------------------------------------------------------------------------

too_many_files:				; ...
		mov	al, 4		; error_too_many_open_files
; START	OF FUNCTION CHUNK FOR _$READ

CommitErrorj:				; ...
		jmp	short CommitError
; END OF FUNCTION CHUNK	FOR _$READ
; ---------------------------------------------------------------------------

enlarge:				; ...
		mov	cx, [32h]	; [PDB.JFN_Length]

copy_hand:				; ...
		mov	dx, cx
		lds	si, [34h]	; [PDB.JFN_Pointer]
		rep movsb
		pop	cx
		push	cx
		sub	cx, dx
		mov	al, 0FFh	; -1
		rep stosb
		mov	ds, [ss:CurrentPDB]
		cmp	word [34h], 0 ; [PDB.JFN_Pointer]
		jnz	short update_info
		push	bp
		push	ds
		push	es
		mov	es, word [36h] ;	[PDB.JFN_Pointer+2]
		call	_$DEALLOC
		pop	es
		pop	ds
		pop	bp

update_info:				; ...
		test	bp, 2
		jz	short non_psp
		mov	word [34h], 18h ; [PDB.JFN_Pointer],PDB.JFN_TABLE
		jmp	short final
; ---------------------------------------------------------------------------

non_psp:				; ...
		mov	word [34h], 0 ; [PDB.JFN_Pointer]

final:					; ...
		mov	word [36h], es ;	[PDB.JFN_Pointer+2]
		pop	word [32h] ; [PDB.JFN_Length]
; START	OF FUNCTION CHUNK FOR _$READ

ok_done_j:				; ...
		jmp	short ok_done
; END OF FUNCTION CHUNK	FOR _$READ
; ---------------------------------------------------------------------------

no_memory:				; ...
		pop	bx
		mov	al, 8		; error_not_enough_memory
; START	OF FUNCTION CHUNK FOR _$READ

CommitErrorj2:				; ...
		jmp	short CommitErrorj
; END OF FUNCTION CHUNK	FOR _$READ
; ---------------------------------------------------------------------------

invalid_func:				; ...
		mov	al, 1		; error_invalid_function
; START	OF FUNCTION CHUNK FOR _$READ

CommitErrorj3:				; ...
		jmp	short CommitErrorj2
; END OF FUNCTION CHUNK	FOR _$READ

; =============== S U B	R O U T	I N E =======================================

_$READ:		; ...

; FUNCTION CHUNK AT A714 SIZE 00000004 BYTES
; FUNCTION CHUNK AT A780 SIZE 00000002 BYTES
; FUNCTION CHUNK AT A784 SIZE 00000002 BYTES
; FUNCTION CHUNK AT A7CF SIZE 00000002 BYTES
; FUNCTION CHUNK AT A7D4 SIZE 00000002 BYTES
; FUNCTION CHUNK AT A7D8 SIZE 00000002 BYTES

		mov	si, DOS_READ

ReadDo:					; ...
		call	pJFNFromHandle
		jb	short ReadError
		mov	al, [es:di]
		call	CheckOwner
		jnb	short ReadSetup

ReadError:				; ...
		jmp	short CommitErrorj3
; ---------------------------------------------------------------------------

ReadSetup:				; ...
		mov	word [ss:THISSFT], di
		mov	word [ss:THISSFT+2], es
		test	byte [es:di+3], 20h	; [ES:DI+SF_ENTRY.sf_mode+1],
					; (INT_24_ERROR>>8)
		jz	short needi24
		or	byte [ss:EXTOPEN_ON], 2 ; EXT_OPEN_I24_OFF

needi24:				; ...
		push	word [ss:DMAADD]
		push	word [ss:DMAADD+2]
		call	Align_Buffer
		push	ss
		pop	ds
		call	si ; DOS_READ
		pop	word [DMAADD+2]
		pop	word [DMAADD]
		jnb	short READ_OK
		jmp	short ReadError
; ---------------------------------------------------------------------------

READ_OK:				; ...
		mov	ax, cx

Read_Okj:				; ...
		jmp	short ok_done_j

; =============== S U B	R O U T	I N E =======================================

Align_Buffer:	; ...
		mov	bx, dx
		push	cx
		mov	cl, 4
		shr	bx, cl
		pop	cx
		mov	ax, ds
		add	ax, bx
		mov	ds, ax
		and	dx, 0Fh
		mov	word [ss:DMAADD], dx
		mov	word [ss:DMAADD+2],	ds
		retn

; ---------------------------------------------------------------------------

_$WRITE:				; ...
		mov	si, DOS_WRITE
		jmp	short ReadDo

; =============== S U B	R O U T	I N E =======================================

_$LSEEK:
		call	CheckOwner

LSeekError:				; ...
		jnb	short CHKOWN_OK
		jmp	short ReadError
; ---------------------------------------------------------------------------

CHKOWN_OK:				; ...
		cmp	al, 2
		jbe	short LSeekDisp
		mov	byte [ss:EXTERR_LOCUS], 1 ; errLOC_Unk
		mov	al, 1		; error_invalid_function

LSeekError2:				; ...
		jmp	short ReadError
; ---------------------------------------------------------------------------

LSeekDisp:				; ...
		cmp	al, 1
		jb	short LSeekStore
		ja	short LSeekEOF
		add	dx, [es:di+21]	; [ES:DI+SF_ENTRY.sf_position]
		adc	cx, [es:di+23]	; [ES:DI+SF_ENTRY.sf_position+2]

LSeekStore:				; ...
		mov	ax, cx
		xchg	ax, dx

LSeekSetpos:				; ...
		mov	[es:di+21], ax
		mov	[es:di+23], dx
		call	Get_User_Stack
		mov	[si+6],	dx

LSeekOk:				; ...
		jmp	short Read_Okj
; ---------------------------------------------------------------------------

LSeekEOF:				; ...
		test	byte [es:di+6], 80h	; [ES:DI+SF_ENTRY.sf_flags+1],
					; (sf_isnet>>8)
		jnz	short Check_LSeek_Mode

LOCAL_LSeek:				; ...
		add	dx, [es:di+17]	; [ES:DI+SF_ENTRY.sf_size]
		adc	cx, [es:di+19]	; [ES:DI+SF_ENTRY.sf_size+2]
		jmp	short LSeekStore
; ---------------------------------------------------------------------------

Check_LSeek_Mode:			; ...
		test	byte [es:di+3], 80h	; [ES:DI+SF_ENTRY.sf_mode+1],
					; (sf_isFCB>>8)
		jnz	short LOCAL_LSeek
		mov	ax, [es:di+2]	; [ES:DI+SF_ENTRY.sf_mode]
		and	ax, 0F0h
		cmp	ax, 40h		; SHARING_MASK
		jz	short NET_LSEEK
		cmp	ax, 30h		; SHARING_DENY_READ
		jnz	short LOCAL_LSeek

NET_LSEEK:				; ...
		mov	ax, 1121h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - SEEK	FROM END OF REMOTE FILE
					; CX:DX	= offset (in bytes) from end
					; ES:DI	-> SFT,	SFT DPB	field -> DPB of	drive with file
					; SS = DOS CS
					; Return: CF set on error
					; CF clear if successful, DX:AX	= new file position
		jnb	short LSeekSetpos

LSeekError3:				; ...
		jmp	short LSeekError2

; ---------------------------------------------------------------------------

_$FILE_TIMES:				; ...
		cmp	al, 2
		jnb	short inval_func
		call	CheckOwner
		jb	short LSeekError
		or	al, al
		jnz	short ft_set_time
		cli
		mov	cx, [es:di+13]	; [es:di+SF_ENTRY.sf_time]
		mov	dx, [es:di+15]	; [es:di+SF_ENTRY.sf_date]
		sti
		call	Get_User_Stack
		mov	[si+4],	cx
		mov	[si+6],	dx
		jmp	short ok_ret
; ---------------------------------------------------------------------------

ft_set_time:				; ...
		call	ECritDisk	; call ECritSFT
		mov	[es:di+13], cx	; [es:di+SF_ENTRY.sf_time]
		mov	[es:di+15], dx	; [es:di+SF_ENTRY.sf_date]
		xor	ax, ax
		;call	dword [ss:ShSU] ; call far [ss:JShare+(14*4)] ; 14 = ShSU
		call	far [ss:JShare+(14*4)]
		and	word [es:di+5], 0FFBFh ; ~devid_file_clean
		or	word [es:di+5], 4000h ; sf_close_nodate
		call	LCritDisk	; call ECritSFT

ok_ret:					; ...
		jmp	short LSeekOk
; ---------------------------------------------------------------------------

inval_func:				; ...
		mov	byte [ss:EXTERR_LOCUS], 1 ; errLOC_Unk
		mov	al, 1		; error_invalid_function

ft_error:				; ...
		jmp	short LSeekError3
; ---------------------------------------------------------------------------

_$DUP:					; ...
		mov	ax, bx
		call	JFNFree

DupErrorCheck:				; ...
		jb	short DupErr
		push	es
		push	di
		pop	si
		pop	ds
		xchg	ax, bx
		call	CheckOwner
		jb	short DupErr
		call	DOS_Dup_Direct
		call	pJFNFromHandle
		mov	bl, [es:di]
		mov	[si], bl
		jmp	short ok_ret
; ---------------------------------------------------------------------------

DupErr:					; ...
		jmp	short ft_error
; ---------------------------------------------------------------------------

_$DUP2:					; ...
		push	bx
		push	cx
		mov	bx, cx
		call	_$CLOSE
		pop	bx
		pop	ax
		call	pJFNFromHandle
		jmp	short DupErrorCheck

; =============== S U B	R O U T	I N E =======================================

CheckOwner:		; ...
		call	SFFromHandle
		jb	short co_ret_label
		push	ax
		test	byte [ss:IsWin386], 1
		jz	short no_win386
		xor	ax, ax
		jmp	short _skip_win386
; ---------------------------------------------------------------------------

no_win386:				; ...
		mov	ax, [ss:USER_ID]
		cmp	ax, [es:di+2Fh]	; [es:di+SF_ENTRY.sf_UID]

_skip_win386:				; ...
		pop	ax
		jnz	short CheckOwner_err
		retn
; ---------------------------------------------------------------------------

CheckOwner_err:				; ...
		mov	al, 6
		stc

co_ret_label:				; ...
		retn

; ---------------------------------------------------------------------------

_$AssignOper:				; ...
		cmp	al, 7
		jnz	short chk08

srinuse:				; ...
		push	ax
		mov	al, dl
		call	GetCDSFromDrv
		pop	ax
		jb	short baddrv
		cmp	word [si+45h], 0 ; [SI+curdir.devptr]
		jz	short baddrv
		cmp	al, 7
		jnz	short resetdrv
		or	word [si+43h], 4000h ; [SI+curdir.flags],
					; curdir_inuse
		jmp	short okdone
; ---------------------------------------------------------------------------

resetdrv:				; ...
		and	word [si+43h], 0BFFFh ; ~curdir_inuse
		jmp	short okdone
; ---------------------------------------------------------------------------

baddrv:					; ...
		mov	ax, 0Fh		; error_invalid_drive
		jmp	short ASS_ERR
; ---------------------------------------------------------------------------

chk08:					; ...
		cmp	al, 8
		jz	short srinuse
		push	ax
		mov	ax, 111Eh	; (MultNET SHL 8) OR 30
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - DO REDIRECTION
					; SS = DOS CS
					; STACK: WORD function to execute
					; Return: CF set on error, AX =	error code
					; STACK	unchanged
		pop	bx
		jb	short ASS_ERR

okdone:					; ...
		jmp	SYS_RETURN	; SYS_RET_OK
; ---------------------------------------------------------------------------

ASS_ERR:				; ...
		jmp	SYS_RET_ERR

; =============== S U B	R O U T	I N E =======================================

FIND_DPB:		; ...
		lds	si, [ss:SYSINITVARS] ; [SS:DPBHEAD]

fdpb5:					; ...
		cmp	si, 0FFFFh	; -1
		jz	short fdpb10
		cmp	al, [si]	; [SI+DPB.DRIVE]
		jz	short ret_label15
		lds	si, [si+19h]	; [SI+DPB.NEXT_DPB]
		jmp	short fdpb5
; ---------------------------------------------------------------------------

fdpb10:					; ...
		stc

ret_label15:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================

InitCDS:
		push	ax
		les	di, [ss:THISCDS]
		mov	word [es:di+43h], 0 ; [ES:DI+curdir.flags]
		sub	al, 40h	; '@'   ; 'A'-1
		cmp	[ss:NUMIO], al
		jb	short icdsx
		dec	ax
		push	ax
		add	al, 41h	; 'A'
		mov	ah, 3Ah	; ':'
		mov	[es:di], ax	; [ES:DI+curdir.text]
		mov	word [es:di+2], 5Ch ; '\' ; [ES:DI+curdir.text+2]
		or	byte [es:di+44h], 40h ; [ES:DI+curdir.flags+1],
					; (curdir_inuse>>8)
		sub	ax, ax
		mov	[es:di+49h], ax	; [ES:DI+curdir.ID]
		mov	[es:di+4Bh], ax	; [ES:DI+curdir.ID+2]
		mov	al, 2
		mov	[es:di+4Fh], ax	; [ES:DI+curdir.end]
		pop	ax
		push	ds
		push	si
		call	FIND_DPB
		jb	short icds5
		mov	[es:di+45h], si	; [ES:DI+curdir.devptr]
		mov	word [es:di+47h], ds ; [ES:DI+curdir.devptr+2]

icds5:					; ...
		pop	si
		pop	ds

icdsx:					; ...
		pop	ax

RET45:					; ...
		retn

; ---------------------------------------------------------------------------

_$UserOper:				; ...
		push	ax
		sub	al, 1
		pop	ax
		jb	short UserGet
		jz	short UserSet
		cmp	al, 5
		jbe	short UserPrint
		mov	byte [ss:EXTERR_LOCUS], 1 ; errLOC_Unk
		mov	al, 1		; error_invalid_function

useroper_error:				; ...
		jmp	short ASS_ERR
; ---------------------------------------------------------------------------

UserGet:				; ...
		push	ds
		pop	es
		mov	di, dx
		mov	cx, [ss:MYNUM]
		call	Get_User_Stack
		mov	[si+4],	cx	; [SI+user_env.user_CX]
		push	ss
		pop	ds
		mov	si, MYNAME

UserMove:				; ...
		mov	cx, 15
		rep movsb
		xor	ax, ax
		stosb

UserBye:				; ...
		jmp	SYS_RETURN	; SYS_RET_OK
; ---------------------------------------------------------------------------

UserSet:				; ...
		mov	[ss:MYNUM], cx
		mov	si, dx
		push	ss
		pop	es
		mov	di, MYNAME
		inc	byte [ss:DIFFNAM]
		jmp	short UserMove
; ---------------------------------------------------------------------------

UserPrint:				; ...
		push	ax
		mov	ax, 111Fh	; (MultNET SHL 8) OR 31
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - PRINTER SETUP
					; STACK: WORD function
					; Return: CF set on error, AX =	error code
					; STACK	unchanged
		pop	dx
		jnb	short OKPA
		jmp	short useroper_error
; ---------------------------------------------------------------------------

OKPA:					; ...
		jmp	short UserBye

; =============== S U B	R O U T	I N E =======================================

GetVisDrv:		; ...
		call	GETTHISDRV
		jb	short RET45
		push	ds
		push	si
		lds	si, [ss:THISCDS]
		test	word [si+43h], 2000h ; [SI+curdir.flags],
					; curdir_splice
		pop	si
		pop	ds
		jz	short RET45
		mov	byte [ss:DrvErr], 0Fh ; error_invalid_drive
		stc
		retn

; =============== S U B	R O U T	I N E =======================================

GETTHISDRV:		; ...
		or	al, al
		jnz	short GTD10
		mov	al, [ss:CURDRV]
		inc	ax

GTD10:					; ...
		dec	ax
		push	ds
		push	si
		mov	byte [ss:EXTERR_LOCUS], 2 ; errLOC_Disk
		test	byte [ss:FSHARING], 0FFh ; -1
		jz	short GTD20
		push	ax
		push	es
		push	di
		mov	word [ss:THISCDS], DUMMYCDS
		mov	word [ss:THISCDS+2], ss
		add	al, 41h	; 'A'
		call	InitCDS
		test	word [es:di+43h], 4000h ; [ES:DI+curdir.flags],
					; curdir_inuse
		pop	di
		pop	es
		pop	ax
		jz	short GTD30
		jmp	short GTDX
; ---------------------------------------------------------------------------

GTD20:					; ...
		call	GetCDSFromDrv
		jb	short GTD30
		test	word [si+43h], 4000h ; [SI+curdir.flags],
					; curdir_inuse
		jnz	short GTDX

GTD30:					; ...
		mov	al, 0Fh		; error_invalid_drive
		mov	[ss:DrvErr], al
		mov	byte [ss:EXTERR_LOCUS], 1 ; errLOC_Unk
		stc

GTDX:					; ...
		pop	si
		pop	ds
		retn

; =============== S U B	R O U T	I N E =======================================

GetCDSFromDrv:	; ...
		cmp	al, [ss:CDSCOUNT]
		jb	short GetCDS
		stc
		retn
; ---------------------------------------------------------------------------

GetCDS:					; ...
		push	bx
		push	ax
		lds	si, [ss:CDSADDR]
		mov	bl, 88		; curdir.size
		mul	bl
		add	si, ax
		mov	word [ss:THISCDS], si
		mov	word [ss:THISCDS+2], ds
		pop	ax
		pop	bx
		clc
		retn

; ---------------------------------------------------------------------------

TransFCB:				; ...
		push	bp
		mov	bp, sp
		sub	sp, 16
		push	ss
		pop	es
		push	es
		push	di
		lea	di, [bp-16]	; FCBTmp
		mov	byte [ss:EXTFCB], 0
		mov	byte [ss:SATTRIB], 0
		call	GetExtended
		jz	short GetDrive
		mov	al, [si-1]
		mov	[ss:SATTRIB], al
		mov	byte [ss:EXTFCB], 0FFh ; -1

GetDrive:				; ...
		lodsb
		call	GETTHISDRV
		jb	short BadPack
		call	TextFromDrive
		mov	cx, 11
		push	si

FCBScan:				; ...
		lodsb
		call	GetCharType
		test	al, 8		; FFCB
		jz	short BadPack
		loop	FCBScan
		pop	si
		mov	bx, di
		call	PackName
		pop	di
		pop	es
		push	ss
		pop	ds
		lea	si, [bp-16]	; FCBTmp
		cmp	byte [bx], 0
		jz	short BadPack
		push	bp
		call	TransPathSet
		pop	bp
		jnb	short FCBRet

BadPack:				; ...
		stc
		mov	al, 3		; error_path_not_found

FCBRet:					; ...
		mov	sp, bp
		pop	bp

TransPath_retn:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================

TransPath:		; ...
		xor	al, al
		jmp	short SetSplice
; ---------------------------------------------------------------------------

TransPathSet:				; ...
		mov	al, 0FFh	; -1

SetSplice:				; ...
		mov	[ss:NoSetDir], al
		mov	al, 0FFh	; -1

TransPathNoSet:				; ...
		mov	[ss:FSPLICE], al
		mov	byte [ss:CMETA], 0FFh ; -1
		mov	[ss:WFP_START],	di
		mov	word [ss:CURR_DIR_END], 0FFFFh ; -1
		push	ss
		pop	es
		lea	bp, [di+134]	; [DI+TEMPLEN]
		test	byte [ss:FSHARING], 0FFh ; -1
		jz	short CheckUNC
		call	DriveFromText
		call	GETTHISDRV
		jb	short NoPath
		call	TextFromDrive
		lea	bx, [di+1]
		call	Canonicalize
		jb	short TransPath_retn
		push	ss
		pop	ds
		mov	si, [WFP_START]
		test	byte [FSPLICE], 0FFh ; -1
		jz	short NoServerSplice
		call	Splice

NoServerSplice:				; ...
		push	ss
		pop	ds
		les	di, [THISCDS]
		call	ECritDisk
		call	FATREAD_CDS
		call	LCritDisk

NoPath:					; ...
		mov	al, 3		; error_path_not_found
		retn
; ---------------------------------------------------------------------------

CheckUNC:				; ...
		mov	word [ss:THISCDS], 0FFFFh
		mov	ax, 1123h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - QUALIFY REMOTE FILENAME
					; DS:SI	-> ASCIZ filename to canonicalize
					; ES:DI	-> 128-byte buffer for qualified name
					; Return: CF set if not	resolved
		jnb	short UNCDone
		call	DriveFromText
		push	ax
		mov	ax, [si]
		call	PATHCHRCMP
		xchg	ah, al
		call	PATHCHRCMP
		jnz	short CheckDevice
		cmp	ah, al
		jnz	short CheckDevice
		pop	ax
		movsw

UNCCpy:					; ...
		lodsb
		call	UCase
		or	al, al
		jz	short UNCTerm
		call	PATHCHRCMP
		mov	bx, di
		stosb
		jnz	short UNCCpy
		call	Canonicalize

UNCDone:				; ...
		push	ss
		pop	ds
		retn
; ---------------------------------------------------------------------------

UNCTerm:				; ...
		stosb
		jmp	short UNCDone
; ---------------------------------------------------------------------------

CheckDevice:				; ...
		pop	ax
		cmp	byte [si], 0
		jnz	short CheckPath
		mov	al, 2		; error_file_not_found
		stc
		retn
; ---------------------------------------------------------------------------

CheckPath:				; ...
		push	ax
		push	bp
		call	CheckThisDevice
		pop	bp
		pop	ax
		jnb	short DoFile
		mov	byte [ss:FSHARING], 0FFh ; -1
		call	GETTHISDRV
		mov	byte [ss:FSHARING], 0
		call	TextFromDrive
		mov	al, '/'
		stosb
		call	StrCpy
		clc
		push	ss
		pop	ds

DoFile_retn:				; ...
		retn
; ---------------------------------------------------------------------------

DoFile:					; ...
		call	GetVisDrv
		mov	al, 3		; error_path_not_found
		jb	short DoFile_retn
		push	ds
		push	si
		push	es
		push	di
		call	ValidateCDS
		pop	di
		pop	es
		pop	si
		pop	ds
		mov	al, 3
		jb	short DoFile_retn
		push	ds
		push	si
		lds	si, [ss:THISCDS]
		mov	bx, di
		add	bx, [si+79]	; [SI+curdir.end]
		lea	bp, [di+134]	; [DI+TEMPLEN]
		call	FStrCpy
		dec	di
		mov	al, '\'
		cmp	[es:di-1], al
		jz	short GetOrig
		stosb

GetOrig:				; ...
		dec	di
		pop	si
		pop	ds
		call	PathSep
		jnz	short PathAssure
		or	al, al
		jz	short DoCanon
		mov	di, bx

SkipPath:				; ...
		lodsb
		call	PATHCHRCMP
		jz	short SkipPath
		dec	si
		or	al, al
		jz	short DoCanon

PathAssure:				; ...
		mov	al, 5Ch	; '\'
		stosb

DoCanon:				; ...
		call	Canonicalize
		jb	short DoFile_retn
		push	ss
		pop	ds
		mov	di, [WFP_START]
		lds	si, [THISCDS]
		call	PathPref
		jnz	short DoSplice
		mov	al, [si-1]
		call	PATHCHRCMP
		jz	short DoSplice
		cmp	byte [es:di], 0
		jz	short DoSplice
		inc	di
		mov	[ss:CURR_DIR_END], di

DoSplice:				; ...
		push	ss
		pop	ds
		mov	si, [WFP_START]
		xor	cx, cx
		test	byte [FSPLICE], 0FFh ; -1
		jz	short SkipSplice
		call	Splice

SkipSplice:				; ...
		push	ss
		pop	ds
		les	di, [THISCDS]
		test	word [es:di+67], 8000h ; [ES:DI+curdir.flags],
					; curdir_isnet
		jnz	short Done
		jcxz	Done
		call	ECritDisk
		call	FATREAD_CDS
		call	LCritDisk
		mov	al, 3		; error_path_not_found

Done:					; ...
		retn

; =============== S U B	R O U T	I N E =======================================

Canonicalize:	; ...
		lodsb
		call	PATHCHRCMP
		jnz	short CanonDec
		cmp	di, bp
		jnb	short CanonBad
		stosb
		jmp	short Canonicalize
; ---------------------------------------------------------------------------

CanonDec:				; ...
		dec	si

CanonLoop:				; ...
		xor	ax, ax
		cmp	[si], al
		jnz	short DoComponent
		cmp	byte [es:di-1], ':'
		jnz	short DoTerminate
		mov	al, '\'
		stosb
		mov	al, ah

DoTerminate:				; ...
		stosb
		clc
		retn
; ---------------------------------------------------------------------------

CanonBad:				; ...
		call	ScanPathChar
		mov	al, 3		; error_path_not_found
		jz	short PathEnc
		mov	al, 2		; error_file_not_found

PathEnc:				; ...
		stc

CanonBad_retn:				; ...
		retn
; ---------------------------------------------------------------------------

DoComponent:				; ...
		call	CopyComponent
		jb	short CanonBad_retn
		cmp	word [es:di], 2Eh ;	'.'
		jz	short Skip1
		cmp	word [es:di], 2E2Eh
		jnz	short CanonNormal
		dec	di

Skip1:					; ...
		call	SkipBack
		mov	al, 3		; error_path_not_found
		jb	short CanonBad_retn
		jmp	short CanonPath
; ---------------------------------------------------------------------------

CanonNormal:				; ...
		add	di, cx

CanonPath:				; ...
		call	PathSep
		jnz	short CanonBad
		lodsb
		call	PATHCHRCMP
		jnz	short CanonDec
		cmp	di, bp
		jnb	short CanonBad
		stosb

CanonPathLoop:				; ...
		lodsb
		call	PATHCHRCMP
		jz	short CanonPathLoop
		dec	si
		jmp	short CanonLoop

; =============== S U B	R O U T	I N E =======================================

PathSep:
		mov	al, [si]

PathSepGotCh:				; ...
		or	al, al
		jz	short CanonBad_retn
		call	PATHCHRCMP
		retn

; =============== S U B	R O U T	I N E =======================================

SkipBack:		; ...
		cmp	di, bx
		jb	short SkipBad
		dec	di
		mov	al, [es:di]
		call	PATHCHRCMP
		jnz	short SkipBack
		clc
		retn
; ---------------------------------------------------------------------------

SkipBad:				; ...
		mov	al, 3		; error_path_not_found
		stc
		retn

; =============== S U B	R O U T	I N E =======================================

CopyComponent:	; ...
		sub	sp, 14
		push	ds
		push	si
		push	es
		push	di
		push	bp
		mov	bp, sp
		mov	ah, '.'
		lodsb
		stosb
		cmp	al, ah
		jnz	short NormalComp
		call	PathSep
		jz	short NulTerm

TryTwoDot:
		lodsb
		stosb
		cmp	al, ah
		jnz	short CopyBad
		call	PathSep
		jnz	short CopyBad

NulTerm:				; ...
		xor	al, al
		stosb
		mov	[bp+6],	si	; CopySoff
		jmp	short _GoodRet
; ---------------------------------------------------------------------------

NormalComp:				; ...
		mov	si, [bp+6]	; CopySoff
		call	NameTrans
		cmp	si, [bp+6]
		jz	short CopyBad
		test	byte [ss:FSHARING], 0FFh ; -1
		jnz	short DoPack
		and	dl, 1
		add	[ss:CMETA], dl
		jg	short CopyBad
		jnz	short DoPack
		or	dl, dl
		jz	short CopyBadPath

DoPack:					; ...
		mov	[bp+6],	si
		push	ss
		pop	ds
		mov	si, NAME1
		lea	di, [bp+10]	; CopyTemp
		push	di
		call	PackName
		pop	di
		call	StrLen
		dec	cx
		add	cx, [bp+2]	; CopyDoff
		cmp	cx, [bp+0]	; CopyBP
		jnb	short CopyBad
		mov	si, di
		les	di, [bp+2]	; CopyD
		call	FStrCpy

_GoodRet:				; ...
		clc
		jmp	short CopyEnd
; ---------------------------------------------------------------------------

CopyBad:				; ...
		stc
		call	ScanPathChar
		mov	al, 2		; error_file_not_found
		jnz	short CopyEnd

CopyBadPath:				; ...
		stc
		mov	al, 3		; error_path_not_found

CopyEnd:				; ...
		pop	bp
		pop	di
		pop	es
		pop	si
		pop	ds
		lahf
		add	sp, 14
		call	StrLen
		dec	cx
		sahf
		retn

; =============== S U B	R O U T	I N E =======================================

Splice:		; ...
		test	byte [ss:SPLICES], 0FFh ; -1
		jz	short AllDone
		push	word [ss:THISCDS]
		push	word [ss:THISCDS+2]
		push	ds
		push	si
		pop	di
		pop	es
		xor	ax, ax

SpliceScan:				; ...
		call	GetCDSFromDrv
		jb	short SpliceDone
		inc	al
		test	word [si+67], 2000h	; [SI+curdir.flags],
					; curdir_splice
		jz	short SpliceScan
		push	di
		call	PathPref
		jz	short SpliceFound

SpliceSkip:				; ...
		pop	di
		jmp	short SpliceScan
; ---------------------------------------------------------------------------

SpliceFound:				; ...
		cmp	byte [es:di], 0
		jnz	short SpliceDo
		test	byte [ss:NoSetDir], 0FFh ; -1
		jnz	short SpliceSkip

SpliceDo:				; ...
		mov	si, di
		push	es
		pop	ds
		pop	di
		call	TextFromDrive1
		mov	ax, [ss:CURR_DIR_END]
		or	ax, ax
		js	short NoPoke
		add	ax, di
		sub	ax, si
		mov	[ss:CURR_DIR_END], ax

NoPoke:					; ...
		cmp	byte [si], 0
		jnz	short SpliceCopy
		mov	al, '\'
		stosb

SpliceCopy:				; ...
		call	FStrCpy
		add	sp, 4
		or	cl, 1
		jmp	short DoSet
; ---------------------------------------------------------------------------

SpliceDone:				; ...
		pop	word [ss:THISCDS+2]
		pop	word [ss:THISCDS]

AllDone:				; ...
		xor	cx, cx

DoSet:					; ...
		lds	si, [ss:THISCDS]
		les	di, [si+69]	; [SI+curdir.devptr]
		mov	word [ss:THISDPB], di
		mov	word [ss:THISDPB+2], es

Splice_retn:				; ...
		retn

; ---------------------------------------------------------------------------

_$NameTrans:				; ...
		push	ds
		push	si
		push	es
		push	di
		push	cx
		mov	ch, 16h		; attr_hidden+attr_system+attr_directory
		call	SetAttrib
		mov	di, OPENBUF
		call	TransPath
		pop	cx
		pop	di
		pop	es
		pop	si
		pop	ds
		jnb	short TransOK
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

TransOK:				; ...
		mov	si, OPENBUF
		push	ss
		pop	ds
		call	FStrCpy
		jmp	SYS_RETURN	; SYS_RET_OK

; =============== S U B	R O U T	I N E =======================================

DriveFromText:	; ...
		xor	al, al
		cmp	byte [si], 0
		jz	short Splice_retn
		cmp	byte [si+1], ':'
		jnz	short Splice_retn
		lodsw
		or	al, 20h
		sub	al, 60h		; 'a'-1
		jnz	short Splice_retn
		mov	al, 0FFh	; -1
		retn

; =============== S U B	R O U T	I N E =======================================

TextFromDrive:	; ...
		inc	al

TextFromDrive1:				; ...
		add	al, 40h		; 'A'-1
		mov	ah, ':'         ; 3Ah
		stosw

PathPref_retn:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================

PathPref:		; ...
		call	DStrLen
		dec	cx
		repe cmpsb
		jnz	short PathPref_retn
		push	ax
		mov	al, [si-1]
		call	PATHCHRCMP
		jz	short Prefix
		mov	al, [es:di]
		call	PathSepGotCh

Prefix:					; ...
		pop	ax
		retn

; =============== S U B	R O U T	I N E =======================================

ScanPathChar:	; ...
		lodsb
		call	PathSepGotCh
		jnz	short ScanPathChar
		call	PATHCHRCMP
		retn

; =============== S U B	R O U T	I N E =======================================

_$OPEN:		; ...
		xor	ah, ah

_$Open2:				; ...
		mov	ch, 16h		; attr_hidden+attr_system+attr_directory
		call	SetAttrib
		mov	cx, DOS_OPEN
		push	ax

AccessFile:				; ...
		call	ECritDisk	; call ECritSFT
		call	SFNFree
		call	LCritDisk	; call LCritSFT
		jb	short OpenFailJ
		mov	[ss:SFN], bx
		mov	word [ss:THISSFT], di
		mov	word [ss:THISSFT+2], es
		call	JFNFree
		jnb	short SaveJFN

OpenFailJ:				; ...
		jmp	OpenFail
; ---------------------------------------------------------------------------

SaveJFN:				; ...
		mov	word [ss:PJFN], di
		mov	word [ss:PJFN+2], es
		mov	[ss:JFN], bx
		mov	bx, [ss:SFN]
		mov	[es:di], bl
		mov	si, dx
		mov	di, OPENBUF
		push	cx
		call	TransPath
		pop	bx
		lds	si, [ss:THISSFT]
		jb	short OpenCleanJ
		cmp	byte [ss:CMETA], 0FFh ; -1
		jz	short SetSearch
		mov	al, 2

OpenCleanJ:				; ...
		jmp	short OpenClean
; ---------------------------------------------------------------------------

SetSearch:				; ...
		pop	ax
		xor	cx, cx
		mov	[si+2],	cx	; [SI+SF_ENTRY.sf_mode]
		mov	[si+33h], cx	; [SI+SF_ENTRY.sf_MFT]
		cmp	bx, DOS_OPEN
		jnz	short _DoOper
		test	al, 80h
		jz	short _DoOper
		and	al, 7Fh
		mov	cx, 1000h	; sf_no_inherit

_DoOper:				; ...
		push	di
		push	es
		push	ds
		pop	es
		push	si
		pop	di
		call	Set_EXT_mode
		pop	es
		pop	di
		push	ss
		pop	ds
		push	cx
		call	bx
		pop	cx
		lds	si, [THISSFT]
		jb	short OpenE2
		mov	word [si], 1
		or	[si+5],	cx	; [SI+SF_ENTRY.sf_flags]
		mov	ax, [ss:JFN]
		;call	[ss:ShCol]	; Call far [ss:JShare+(12*4)] ;	12 = ShCol
		call	far [ss:JShare+(12*4)]
		mov	word [ss:SFN], 0FFFFh ; -1

OpenOkj:				; ...
		jmp	SYS_RETURN	; SYS_RET_OK
; ---------------------------------------------------------------------------

OpenE2:					; ...
		cmp	ax, 57h		; error_invalid_parameter
		jnz	short OpenE
		jmp	short OpenCritLeave
; ---------------------------------------------------------------------------

OpenClean:				; ...
		pop	bx

OpenE:					; ...
		mov	word [si], 0
		lds	si, [ss:PJFN]
		mov	byte [si], 0FFh ; -1
		jmp	short OpenCritLeave
; ---------------------------------------------------------------------------

OpenFail:				; ...
		sti
		pop	cx

OpenCritLeave:				; ...
		mov	word [ss:SFN], 0FFFFh ; -1
		cmp	word [ss:EXTERR], 25h ; error_Code_Page_Mismatched
		jnz	short NORERR
		jmp	From_GetSet
; ---------------------------------------------------------------------------

NORERR:					; ...
		jmp	SYS_RET_ERR

; ---------------------------------------------------------------------------

_$CREAT:				; ...
		push	cx
		mov	cx, DOS_CREATE
; START	OF FUNCTION CHUNK FOR _$CreateNewFile

AccessSet:				; ...
		mov	byte [ss:SATTRIB], 6 ; attr_hidden+attr_system
		jmp	AccessFile
; END OF FUNCTION CHUNK	FOR _$CreateNewFile
; ---------------------------------------------------------------------------

_$CHMOD:				; ...
		mov	di, OPENBUF
		push	ax
		push	cx
		mov	si, dx
		call	TransPathSet
		pop	cx
		pop	ax
		jb	short ChModErr
		push	ss
		pop	ds
		cmp	byte [CMETA], 0FFh ; -1
		jnz	short ChModErr
		mov	byte [SATTRIB], 16h ; attr_hidden+attr_system+attr_directory
		sub	al, 1
		jb	short ChModGet
		jz	short ChModSet
		mov	byte [EXTERR_LOCUS], 1 ; errLOC_Unk
		mov	al, 1		; error_invalid_function
; START	OF FUNCTION CHUNK FOR _$UNLINK

chmod_errj:				; ...
		jmp	short NORERR
; END OF FUNCTION CHUNK	FOR _$UNLINK
; ---------------------------------------------------------------------------

ChModGet:				; ...
		call	GET_FILE_INFO
		jb	short ChModE
		call	Get_User_Stack
		mov	[si+4],	ax	; [SI+user_env.user_CX]
; START	OF FUNCTION CHUNK FOR _$UNLINK

OpenOkj2:				; ...
		jmp	short OpenOkj
; END OF FUNCTION CHUNK	FOR _$UNLINK
; ---------------------------------------------------------------------------

ChModSet:				; ...
		mov	ax, cx
		call	SET_FILE_ATTRIBUTE
		jb	short ChModE
; START	OF FUNCTION CHUNK FOR _$UNLINK

OpenOkj3:				; ...
		jmp	short OpenOkj2
; ---------------------------------------------------------------------------

ChModErr:				; ...
		mov	al, 3

ChModE:					; ...
		jmp	short chmod_errj
; END OF FUNCTION CHUNK	FOR _$UNLINK

; =============== S U B	R O U T	I N E =======================================

_$UNLINK:		; ...

; FUNCTION CHUNK AT AFBA SIZE 00000002 BYTES
; FUNCTION CHUNK AT AFC7 SIZE 00000002 BYTES
; FUNCTION CHUNK AT AFD0 SIZE 00000006 BYTES

		push	cx
		mov	si, dx
		mov	di, OPENBUF
		call	TransPathSet
		pop	cx
		jb	short ChModErr
		cmp	byte [ss:CMETA], 0FFh ; -1
		jnz	short NotFound
		push	ss
		pop	ds
		mov	ch, 6		; attr_hidden+attr_system
		call	SetAttrib
		call	DOS_DELETE
		jb	short UnlinkE

UnlinkOk:				; ...
		jmp	short OpenOkj3
; ---------------------------------------------------------------------------

NotFound:				; ...
		mov	al, 3

UnlinkE:				; ...
		jmp	short ChModE

; ---------------------------------------------------------------------------

_$RENAME:				; ...
		push	cx
		push	ds
		push	dx
		push	es
		pop	ds
		mov	si, di
		mov	di, RENBUF
		call	TransPathSet
		push	word [ss:WFP_START]
		pop	word [ss:REN_WFP]
		pop	si
		pop	ds
		pop	cx

epjc2:					; ...
		jb	short ChModErr
		cmp	byte [ss:CMETA], 0FFh ; -1
		jnz	short NotFound
		push	cx
		mov	di, OPENBUF
		call	TransPathSet
		pop	cx
		jb	short epjc2
		push	ss
		pop	ds
		cmp	byte [CMETA], 0FFh
		jb	short NotFound
		push	word [THISCDS]
		push	word [THISCDS+2]
		mov	di, OPENBUF
		push	ss
		pop	es
		xor	al, al

rnloop:					; ...
		call	GetCDSFromDrv
		jb	short dorn
		call	StrCmp
		jz	short rnerr
		inc	al
		jmp	short rnloop
; ---------------------------------------------------------------------------

rnerr:					; ...
		add	sp, 4
		mov	al, 10h		; error_current_directory
		jmp	short UnlinkE
; ---------------------------------------------------------------------------

dorn:					; ...
		pop	word [ss:THISCDS+2]
		pop	word [ss:THISCDS]
		push	ss
		pop	ds
		mov	ch, 16h		; attr_directory+attr_hidden+attr_system
		call	SetAttrib
		call	DOS_RENAME
		jb	short UnlinkE
		jmp	short UnlinkOk

; =============== S U B	R O U T	I N E =======================================

_$CreateNewFile:

; FUNCTION CHUNK AT AF88 SIZE 00000009 BYTES

		push	cx
		mov	cx, DOS_Create_New
		jmp	AccessSet

; =============== S U B	R O U T	I N E =======================================

BinToAscii:		; ...
		mov	cx, 404h

bta5:					; ...
		rol	ax, cl
		push	ax
		and	al, 0Fh
		add	al, 'A'
		stosb
		pop	ax
		dec	ch
		jnz	short bta5
		retn

; ---------------------------------------------------------------------------

_$CreateTempFile:			; ...
		push	bp
		mov	bp, sp
		sub	sp, 10
		test	cx, 0FFD8h	; ~attr_changeable
		jz	short OKatts
		mov	ax, 5		; error_access_denied
		jmp	short SETTMPERR
; ---------------------------------------------------------------------------

OKatts:					; ...
		mov	[bp-10], cx	; attr
		mov	[bp-8],	dx	; FilPtrL
		mov	word [bp-6], ds ; FilPtrH
		mov	word [bp-2], ds ; EndPtrH
		push	ds
		pop	es
		mov	di, dx
		mov	cx, di
		neg	cx
		or	cx, cx
		jnz	short okok
		mov	cx, 0FFFFh

okok:					; ...
		xor	ax, ax
		repne scasb
		dec	di
		mov	al, [es:di-1]
		call	PATHCHRCMP
		jz	short SETENDPTR

STOREPTH:
		mov	al, '\'
		stosb

SETENDPTR:				; ...
		mov	[bp-4],	di	; EndPtrL

CreateLoop:				; ...
		push	ss
		pop	ds
		push	bp
		call	READTIME
		pop	bp
		les	di, [bp-4]	; EndPtr
		mov	ax, cx
		call	BinToAscii
		mov	ax, dx
		call	BinToAscii
		xor	al, al
		stosb
		lds	dx, [bp-8]	; FilPtr
		mov	cx, [bp-10]	; Attr
		push	bp
		call	_$CreateNewFile
		pop	bp
		jnb	short CreateDone
		cmp	al, 50h		; error_file_exists
		jz	short CreateLoop
		cmp	al, 5		; error_access_denied
		jnz	short SETTMPERR
		cmp	word [ss:EXTERR], 41h ; error_net_access_denied
		jz	short SETTMPERR
		cmp	word [ss:EXTERR], 53h ; error_FAIL_I24
		jz	short SETTMPERR
		jmp	short CreateLoop
; ---------------------------------------------------------------------------

SETTMPERR:				; ...
		stc

CreateDone:				; ...
		mov	sp, bp
		pop	bp
		jb	short CreateFail
		jmp	SYS_RETURN	; SYS_RET_OK
; ---------------------------------------------------------------------------

CreateFail:				; ...
		jmp	SYS_RET_ERR

; =============== S U B	R O U T	I N E =======================================

SetAttrib:		; ...
		test	byte [ss:FSHARING], 0FFh ; -1
		jnz	short Set
		mov	cl, ch

Set:					; ...
		mov	[ss:SATTRIB], cl
		retn

; ---------------------------------------------------------------------------

_$Extended_Open:			; ...
		mov	[ss:EXTOPEN_FLAG], dx
		mov	word [ss:EXTOPEN_IO_MODE], 0
		test	dx, 0FE00h	; RESERVED_BITS_MASK
		jnz	short ext_inval2
		mov	ah, dl
		cmp	dl, 0
		jz	short ext_inval2
		and	dl, 0Fh
		cmp	dl, 2
		ja	short ext_inval2
		and	ah, 0F0h	; NOT_EXISTS_MASK
		cmp	ah, 10h
		ja	short ext_inval2
		mov	[ss:SAVE_ES], es
		mov	[ss:SAVE_DI], di
		push	word [ss:EXTOPEN_FLAG]
		pop	word [ss:SAVE_DX]
		mov	[ss:SAVE_CX], cx
		mov	[ss:SAVE_BX], bx
		mov	[ss:SAVE_DS], ds
		mov	[ss:SAVE_SI], si
		mov	dx, si
		mov	ax, bx
		jmp	short goopen2
; ---------------------------------------------------------------------------

ext_inval2:				; ...
		mov	al, 1		; error_invalid_function

eo_err:					; ...
		jmp	short CreateFail
; ---------------------------------------------------------------------------
		pop	cx
		pop	si
		mov	al, 13		; error_invalid_data
		jmp	short eo_err
; ---------------------------------------------------------------------------

error_return:				; ...
		retn
; ---------------------------------------------------------------------------

goopen2:				; ...
		test	bx, 2000h
		jz	short goopen
		or	byte [ss:EXTOPEN_ON], 2 ; EXT_OPEN_I24_OFF

goopen:					; ...
		or	byte [ss:EXTOPEN_ON], 1 ; EXT_OPEN_ON
		and	word [ss:EXTOPEN_FLAG], 0FFh
		cmp	word [ss:EXTOPEN_FLAG], 10h ; EXT_EXISTS_FAIL+EXT_NEXISTS_CREATE
		jnz	short chknext
		call	_$CreateNewFile
		jb	short error_return
		cmp	byte [ss:EXTOPEN_ON], 0
		jz	short ok_return2
		mov	word [ss:EXTOPEN_FLAG], 2 ; ACTION_CREATED_OPENED
		jmp	setXAttr
; ---------------------------------------------------------------------------

ok_return2:				; ...
		jmp	SYS_RETURN	; SYS_RET_OK
; ---------------------------------------------------------------------------

chknext:				; ...
		test	word [ss:EXTOPEN_FLAG], 1 ; EXT_EXISTS_OPEN
		jnz	short exist_open
		call	_$CREAT
		jb	short error_return
		cmp	byte [ss:EXTOPEN_ON], 0
		jz	short ok_return2
		mov	word [ss:EXTOPEN_FLAG], 2 ; ACTION_CREATED_OPENED
		test	byte [ss:EXTOPEN_ON], 4 ; EXT_FILE_NOT_EXISTS
		jnz	short setXAttr
		mov	word [ss:EXTOPEN_FLAG], 3 ; ACTION_REPLACED_OPENED
		jmp	short setXAttr
; ---------------------------------------------------------------------------

error_return2:				; ...
		stc
		retn
; ---------------------------------------------------------------------------

exist_open:				; ...
		test	byte [ss:FSHARING], 0FFh ; -1
		jz	short noserver
		mov	cl, ch

noserver:				; ...
		call	_$Open2
		jnb	short ext_ok
		cmp	byte [ss:EXTOPEN_ON], 0
		jz	short error_return2
		cmp	ax, 2		; error_file_not_found
		jnz	short error_return2
		test	word [ss:EXTOPEN_FLAG], 10h ; EXT_NEXISTS_CREATE
		jnz	short do_creat
		jmp	short extexit
; ---------------------------------------------------------------------------

do_creat:				; ...
		mov	cx, [ss:SAVE_CX]
		lds	si, [ss:SAVE_SI]
		mov	dx, si
		call	_$CREAT
		jb	short extexit
		mov	word [ss:EXTOPEN_FLAG], 2 ; ACTION_CREATED_OPENED
		jmp	short setXAttr
; ---------------------------------------------------------------------------

ext_ok:					; ...
		cmp	byte [ss:EXTOPEN_ON], 0
		jz	short ok_return
		mov	word [ss:EXTOPEN_FLAG], 1 ; ACTION_OPENED

setXAttr:				; ...
		push	ax
		call	Get_User_Stack
		mov	ax, [ss:EXTOPEN_FLAG]
		mov	[si+4],	ax	; [SI+user_env.user_CX]
		pop	ax
		mov	[si], ax	; [SI+user_env.user_AX]

ok_return:				; ...
		jmp	SYS_RETURN	; SYS_RET_OK
; ---------------------------------------------------------------------------
		pop	bx
		push	ax
		cmp	word [ss:EXTOPEN_FLAG], 2 ; ACTION_CREATED_OPENED
		jnz	short justopen
		lds	si, [ss:SAVE_SI]
		lds	dx, [si]
		call	_$UNLINK
		jmp	short reserror
; ---------------------------------------------------------------------------

justopen:				; ...
		call	_$CLOSE

reserror:				; ...
		pop	ax
		jmp	short extexit
; ---------------------------------------------------------------------------
		mov	ax, 2		; error_file_not_found
		jmp	short extexit
; ---------------------------------------------------------------------------
		mov	ax, 1		; error_invalid_function

extexit:				; ...
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

_$LockOper:				; ...
		cmp	al, 1
		ja	short lock_bad_func
		push	di
		call	SFFromHandle
		jnb	short lock_do
		pop	di
		mov	al, 6		; error_invalid_handle

lockoperr:				; ...
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

lock_bad_func:				; ...
		mov	byte [ss:EXTERR_LOCUS], 1 ; errLOC_Unk
		mov	al, 1		; error_invalid_function

lockoperrj:				; ...
		jmp	short lockoperr
; ---------------------------------------------------------------------------

lock_do:				; ...
		mov	bx, ax
		mov	bp, Lock_Buffer
		mov	[bp+0],	dx	; [BP+LockBuf.Lock_position]
		mov	[bp+2],	cx	; [BP+LockBuf.Lock_position+2]
		pop	cx
		mov	[bp+4],	cx	; [BP+LockBuf.Lock_length]
		mov	[bp+6],	si	; [BP+LockBuf.Lock_length+2]
		mov	cx, 1
		push	ss
		pop	ds
		mov	dx, bp
		test	al, 1		; UNLOCK_ALL
		jnz	short DOS_Unlock
		jmp	short DOS_Lock
; ---------------------------------------------------------------------------

DOS_Unlock:				; ...
		test	byte [es:di+6], 80h	; [ES:DI+SF_ENTRY.sf_flags+1],
					; (sf_isnet>>8)
		jz	short LOCAL_UNLOCK
		mov	ax, 110Ah
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - LOCK	REGION OF FILE
					; BX = file handle, CX:DX = starting offset, SI	= high word of size
					; STACK: WORD low word of size,	ES:DI -> SFT
					; SFT DPB field	-> DPB of drive	containing file, SS = DOS CS
					; Return: CF set error
		jmp	short ValChk
; ---------------------------------------------------------------------------

LOCAL_UNLOCK:				; ...
		;call	[clr_block]	; Call far [JShare+(7*4)] ; 7 =	clr_block
		call	far [JShare+(7*4)]
ValChk:					; ...
		jnb	short Lock_OK
		jmp	short lockoperrj
; ---------------------------------------------------------------------------

Lock_OK:				; ...
		mov	ax, [TEMP_VAR]
		jmp	SYS_RETURN	; SYS_RET_OK
; ---------------------------------------------------------------------------

DOS_Lock:				; ...
		test	byte [es:di+6], 80h
		jz	short LOCAL_LOCK
		mov	ax, 110Ah
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - LOCK	REGION OF FILE
					; BX = file handle, CX:DX = starting offset, SI	= high word of size
					; STACK: WORD low word of size,	ES:DI -> SFT
					; SFT DPB field	-> DPB of drive	containing file, SS = DOS CS
					; Return: CF set error
		jmp	short ValChk
; ---------------------------------------------------------------------------

LOCAL_LOCK:				; ...
		;call	[set_block]	; Call far [JShare+(6*4)] ; 6 =	Set_Block
		call	far [JShare+(6*4)]
		jmp	short ValChk

; =============== S U B	R O U T	I N E =======================================

LOCK_CHECK:		; ...
		mov	bx, [RetryCount]

LockRetry:				; ...
		push	bx
		push	ax
		;call	[chk_block]	; Call far [JShare+(8*4)] ; 8 =	chk_block
		call	far [JShare+(8*4)]
		pop	ax
		pop	bx
		jnb	short lc_ret_label
		call	Idle
		dec	bx
		jnz	short LockRetry
		stc

lc_ret_label:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================

LOCK_VIOLATION:	; ...
		push	ds
		push	es
		push	di
		push	cx
		mov	ax, 21h		; error_lock_violation
		mov	byte [ALLOWED], 18h ; Allowed_FAIL+Allowed_RETRY
		les	bp, [THISDPB]
		mov	di, 1
		mov	cx, di
		mov	dx, [es:bp+11]	; [ES:BP+DPB.FIRST_SECTOR]
		call	HARDERR
		pop	cx
		pop	di
		pop	es
		pop	ds
		cmp	al, 1
		jz	short lc_ret_label
		stc
		retn

; =============== S U B	R O U T	I N E =======================================

CheckShare:		; ...
		push	ds
		mov	ds, [cs:DosDSeg]
		cmp	byte [fShare], 0
		pop	ds
		retn

; =============== S U B	R O U T	I N E =======================================

SHARE_CHECK:	; ...
		;call	[MFT_enter]	; call far [JShare+(1*4)] ; 1 =	MFT_Enter
		call	far [JShare+(1*4)] 
shchk_retn:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================

SHARE_VIOLATION:
		push	ds
		push	es
		push	di
		mov	byte [READOP], 0
		mov	byte [ALLOWED], 18h ; Allowed_FAIL+Allowed_RETRY
		les	bp, [THISDPB]
		mov	di, 1
		mov	cx, di
		mov	dx, [es:bp+17]	; [ES:BP+DPB.DIR_SECTOR]
		call	HARDERR
		pop	di
		pop	es
		pop	ds
		cmp	al, 1
		jz	short shchk_retn
		stc
		retn

; =============== S U B	R O U T	I N E =======================================

ShareEnd:		; ...
		;call	[MFTClose]	; call far [JShare+(2*4)] ; 2 =	MFTClose
		call	far [JShare+(2*4)]
		retn

; =============== S U B	R O U T	I N E =======================================

ShareEnter:		; ...
		push	cx

retry:					; ...
		mov	cx, [RetryCount]

attempt:				; ...
		les	di, [THISSFT]
		xor	ax, ax
		mov	[es:di+51], ax	; [ES:DI+SF_ENTRY.sf_MFT]
		push	cx
		call	SHARE_CHECK
		pop	cx
		jnb	short done
		call	Idle
		loop	attempt
		call	SHARE_VIOLATION
		jnb	short retry

done:					; ...
		pop	cx
		retn

; =============== S U B	R O U T	I N E =======================================

ExecReady:
		mov	si, dx
		test	word [si+2], 1 ; [si+ERStruc.ER_Flags],ER_EXE
		jz	short er_setver
		mov	ax, [si+8]	; [si+ERStruc.ER_PSP]
		add	ax, 10h
		mov	es, ax
		mov	cx, [si+10]	; [si+ERStruc.ER_StartAddr]
		mov	ax, [si+12]	; [si+ERStruc.ER_StartAddr+2]
		;call	[ss:FixExePatch]	
		call	word [ss:FixExePatch]

er_setver:				; ...
		test	word [si+2], 2 ; [si+ERStruc.ER_Flags],ER_OVERLAY
		jnz	short er_chkdoshi
		push	ds
		push	si
		lds	si, [si+4]	; [si+ERStruc.ER_ProgName]
		call	Save_Begin	; call Scan_Execname1
		call	Scan_Special_Entries
		pop	si
		pop	ds
		mov	es, word [si+8] ; [si+ERStruc.ER_PSP]
		mov	ax, [ss:SPECIAL_VERSION]
		mov	word [es:SFTFCB], ax ; [es:PDB.Version]

er_chkdoshi:				; ...
		cmp	byte [ss:DosHasHMA], 0
		jz	short er_done
		mov	ax, [si+8]	; [si+ERStruc.ER_PSP]
		or	byte [ss:DOS_FLAG], 4
		test	word [si+2], 1 ; EXECA20OFF
		jnz	short er_setA20
		push	ds
		mov	ds, ax
		call	IsCopyProt
		pop	ds

er_setA20:				; ...
		inc	byte [ss:A20OFF_COUNT]
		mov	[ss:A20OFF_PSP], ax

er_done:				; ...
		xor	ax, ax
		retn

; ---------------------------------------------------------------------------
exepatch_start	db 6			; ...
		db 8Ch,0D8h
_first_stop	db 2Bh,0C2h
		db 8Eh,0D8h
		db 8Eh,0C0h
		db 0BFh,0Fh,0
		db 57h
		db 0B9h,10h,0
		db 0B0h,0FFh
		db 0F3h,0AEh
		db 47h
		db 8Bh,0F7h
		db 5Fh,58h
_second_stop	db 2Bh,0C2h
second		db 8Eh,0C0h
		db 0B9h,4,2
		db 8Bh,0C6h
		db 0F7h,0D0h
		db 0D3h,0E8h
		db 74h,13h
		db 8Ch,0DAh
		db 83h,0CEh,0F0h
		db 2Bh,0D0h
		db 73h,8
		db 0F7h,0DAh
		db 0D3h,0E2h
		db 2Bh,0F2h
		db 33h,0D2h
		db 8Eh,0DAh
		db 87h,0F7h
		db 1Eh
		db 6
		db 1Fh
		db 7
		db 0FEh,0CDh
		db 75h,0DBh
		db 0ACh
		db 92h
		db 4Eh
		db 0ADh
		db 8Bh,0C8h
		db 46h
		db 8Ah,0C2h
		db 24h,0FEh
		db 3Ch,0B0h
		db 75h,5
		db 0ACh
		db 0F3h,0AAh
		db 0EBh,6
		db 3Ch,0B2h
		db 75h,6Ch
		db 0F3h,0A4h
		db 92h
		db 0A8h,1
		db 74h,0B9h
		db 90h,90h
scan_patch1	db 8Ch,0C3h		; ...
		db 8Ch,0D8h
		db 2Bh,0C2h
		db 8Eh,0D8h
		db 8Eh,0C0h
		db 0BFh,0Fh,0
		db 0B9h,10h,0
		db 0B0h,0FFh
		db 0F3h,0AEh
		db 47h
		db 8Bh,0F7h
		db 8Bh,0C3h
		db 2Bh,0C2h
		db 8Eh,0C0h
		db 0BFh,0Fh,0
		db 0B1h,4
		db 8Bh,0C6h
		db 0F7h,0D0h
		db 0D3h,0E8h
		db 74h,9
		db 8Ch,0DAh
		db 2Bh,0D0h
		db 8Eh,0DAh
		db 83h,0CEh,0F0h
		db 8Bh,0C7h
		db 0F7h,0D0h
		db 0D3h,0E8h
		db 74h,9
		db 8Ch,0C2h
		db 2Bh,0D0h
		db 8Eh,0C2h
		db 83h,0CFh,0F0h
scan_patch2	db 8Ch,0C3h		; ...
		db 8Ch,0D8h
		db 48h
		db 8Eh,0D8h
		db 8Eh,0C0h
		db 0BFh,0Fh,0
		db 0B9h,10h,0
		db 0B0h,0FFh
		db 0F3h,0AEh
		db 47h
		db 8Bh,0F7h
		db 8Bh,0C3h
		db 48h
		db 8Eh,0C0h
		db 0BFh,0Fh,0
		db 0B1h,4
		db 8Bh,0C6h
		db 0F7h,0D0h
		db 0D3h,0E8h
		db 74h,0Ah
		db 8Ch,0DAh
		db 2Bh,0D0h
		db 8Eh,0DAh
		db 81h,0CEh,0F0h,0FFh
		db 8Bh,0C7h
		db 0F7h,0D0h
		db 0D3h,0E8h
		db 74h,0Ah
		db 8Ch,0C2h
		db 2Bh,0D0h
		db 8Eh,0C2h
		db 81h,0CFh,0F0h,0FFh
scan_patch3	db 8Ch,0C3h		; ...
		db 8Ch,0D8h
		db 48h
		db 8Eh,0D8h
		db 8Eh,0C0h
		db 0BFh,0Fh,0
		db 0B9h,10h,0
		db 0B0h,0FFh
		db 0F3h,0AEh
		db 47h
		db 8Bh,0F7h
		db 8Bh,0C3h
		db 48h
		db 8Eh,0C0h
		db 0BFh,0Fh,0
		db 0B1h,4
		db 8Bh,0C6h
		db 0F7h,0D0h
		db 0D3h,0E8h
		db 74h,9
		db 8Ch,0DAh
		db 2Bh,0D0h
		db 8Eh,0DAh
		db 83h,0CEh,0F0h
		db 8Bh,0C7h
		db 0F7h,0D0h
		db 0D3h,0E8h
		db 74h,9
		db 8Ch,0C2h
		db 2Bh,0D0h
		db 8Eh,0C2h
		db 83h,0CFh,0F0h
scan_com	db 0ACh			; ...
		db 8Ah,0D0h
		db 4Eh
		db 0ADh
		db 8Bh,0C8h
		db 46h
		db 8Ah,0C2h
		db 24h,0FEh
		db 3Ch,0B0h
		db 75h,6
		db 0ACh
		db 0F3h,0AAh
		db 0EBh,7,90h
		db 3Ch,0B2h
		db 75h,6Bh
		db 0F3h,0A4h
		db 8Ah,0C2h
		db 0A8h,1

; =============== S U B	R O U T	I N E =======================================

ExePatch:		; ...
		call	ExePackPatch
		;call	[ss:RationalPatchPtr]
		call	word [ss:RationalPatchPtr]
		retn

; =============== S U B	R O U T	I N E =======================================

ExePackPatch:	; ...
		push	bx
		mov	bx, es
		cmp	bx, 0FFFh
		jbe	short ep_cont
		pop	bx
		retn
; ---------------------------------------------------------------------------

ep_cont:				; ...
		push	ds
		push	es
		push	ax
		push	cx
		push	si
		push	di
		sub	cx, 2
		jnb	short epp_1
		jmp	ep_notpacked
; ---------------------------------------------------------------------------

epp_1:					; ...
		mov	di, cx
		mov	es, ax
		mov	[ss:UNPACK_OFFSET], di
		cmp	word [es:di], 4252h	; 'RB'
		jz	short epp_2
		jmp	ep_notpacked
; ---------------------------------------------------------------------------

epp_2:					; ...
		push	cs
		pop	ds
		add	di, 6Ch		; PATCH1_COM_OFFSET
		call	chk_common_str
		jnz	short ep_chkpatch2
		mov	si, scan_patch1
		mov	di, [ss:UNPACK_OFFSET]
		add	di, 28h		; PATCH1_OFFSET
		mov	cx, 68		; size_scan_patch1
					; = scan_patch2	- scan_patch1
		mov	bx, 142
		mov	ax, 0EF4Eh	; PATCH1_CHKSUM
		call	chk_patchsum
		jb	short ep_done1
		mov	si, exepatch_start ; str1
		mov	cx, 102
		rep movsb

ep_done1:				; ...
		jmp	ep_notpacked	; ep_done
; ---------------------------------------------------------------------------

ep_chkpatch2:				; ...
		mov	di, 76h		; PATCH2_COM_OFFSET
		call	chk_common_str
		jnz	short ep_chkpatch3
		mov	si, scan_patch2
		mov	di, 32h		; PATCH2_OFFSET
		mov	cx, 68		; size_scan_patch2
		mov	bx, 140		; CHKSUM2_LEN
		mov	ax, 78B2h	; PATCH2_CHKSUM
		call	chk_patchsum
		jnb	short ep_patchcode2
		mov	si, scan_patch2
		mov	cx, 68		; size_scan_patch2
					; = scan_patch3	- scan_patch2
		mov	bx, 129		; CHKSUM2A_LEN
		mov	ax, 1C47h	; PATCH2A_CHKSUM
		call	chk_patchsum
		jb	short ep_notpacked

ep_patchcode2:				; ...
		mov	si, exepatch_start ; str1
		mov	cx, 3		; first_stop =
					; _first_stop -	exepact_start (str1)
		rep movsb
		mov	ax, 4890h	; dec ax, nop
		stosw
		add	si, 2
		mov	cx, 20		; second_stop =
					; _secondstop -	_first_stop
		rep movsb
		stosw			; dec ax, nop
		add	si, 2
		mov	cx, 75		; last_stop =
					; scan_patch1 -	second
		rep movsb
		jmp	short ep_notpacked ; ep_done
; ---------------------------------------------------------------------------

ep_chkpatch3:				; ...
		mov	di, 74h		; PATCH3_COM_OFFSET
		call	chk_common_str
		jnz	short ep_notpacked
		mov	si, scan_patch3
		mov	di, 32h		; PATCH3_OFFSET
		mov	cx, 66		; size_scan_patch3
					; = scan_com - scan_patch3
		mov	bx, 139		; CHKSUM3_LEN
		mov	ax, 4EDEh	; PATCH3_CHKSUM
		call	chk_patchsum
		jb	short ep_notpacked
		mov	si, exepatch_start ; str1
		mov	cx, 3		; first_stop
		rep movsb
		mov	al, 48h		; dec ax
		stosb
		add	si, 2
		mov	cx, 20		; second_stop
		rep movsb
		stosb			; dec ax
		add	si, 2
		mov	cx, 75		; last_stop
		rep movsb

ep_notpacked:				; ...
		pop	di
		pop	si
		pop	cx
		pop	ax
		pop	es
		pop	ds
		pop	bx
		retn

; =============== S U B	R O U T	I N E =======================================

chk_common_str:	; ...
		mov	si, scan_com
		mov	cx, 32		; size_scan_com
					; = offset ExePatch - offset scan_com
		repe cmpsb
		jz	short ccs_done
		cmp	byte [es:di-1], 56h
		jnz	short ccs_done
		repe cmpsb

ccs_done:				; ...
		retn

; ---------------------------------------------------------------------------

chk_patchsum:				; ...
		push	di
		repe cmpsb
		jnz	short cp_fail
		mov	di, [ss:UNPACK_OFFSET]
		mov	cx, bx
		mov	bx, ax
		xor	ax, ax

ep_chksum:				; ...
		add	ax, [es:di]
		add	di, 2
		loop	ep_chksum
		pop	di
		cmp	ax, bx
		jnz	short cp_fail
		clc
		retn
; ---------------------------------------------------------------------------

cp_fail:				; ...
		stc
		retn
; ---------------------------------------------------------------------------
RScanPattern1	db 0, 0, 20h, 0, 0, 0, 40h, 0, 1, 0 ; ...
RScanPattern2	db 8Bh,	0Eh, 10h, 0, 90h, 0E2h,	0FEh, 0E8h ; ...
RScanPattern3	db 8Bh,	0Eh, 10h, 0, 0E2h, 0FEh, 0E8h ;	...

; =============== S U B	R O U T	I N E =======================================

RationalPatch:	; ...
		cld
		push	ax
		push	bx
		push	cx
		push	dx
		push	si
		push	di
		push	es
		push	ds
		mov	di, 0Ah
		push	cs
		pop	ds
		mov	si, RScanPattern1
		mov	cx, 10		; RLen1
		repe cmpsb
		jnz	short rpexit
		mov	ax, [es:0]
		cmp	ax, 348
		jb	short rpexit
		cmp	ax, 383
		ja	short rpexit
		call	VerifyVersion
		jnz	short rpexit
		mov	cx, [es:16h]
		sub	cx, 200h
		mov	es, word [es:20h]
		mov	si, RScanPattern2
		mov	dx, 8		; RLen2
		call	ScanCodeSeq
		jz	short rpfound
		mov	si, RScanPattern3
		mov	dx, 15		; RLen3
		call	ScanCodeSeq
		jnz	short rpexit

rpfound:				; ...
		mov	al, 9Ah		; far call opcode
		stosb
		mov	ax, RatBugCode
		stosw
		mov	ax, ss
		stosw
		mov	cx, dx
		sub	cx, 6
		mov	al, 90h		; NOPs
		rep stosb

rpexit:					; ...
		pop	ds
		pop	es
		pop	di
		pop	si
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		retn

; =============== S U B	R O U T	I N E =======================================

ScanCodeSeq:	; ...
		push	cx
		sub	cx, dx
		inc	cx
		mov	di, 200h

scsagain:				; ...
		push	si
		push	di
		push	cx
		mov	cx, dx
		repe cmpsb
		pop	cx
		pop	di
		pop	si
		jz	short scsfound
		inc	di
		loop	scsagain

scsfound:				; ...
		pop	cx
		retn

; =============== S U B	R O U T	I N E =======================================

VerifyVersion:	; ...
		mov	si, [es:2Ah]
		mov	bl, 10
		add	si, 3
		call	VVDigit
		jnz	short vvexit
		call	VVDigit
		jnz	short vvexit
		cmp	byte [es:si], '.' ; 2Eh
		jnz	short vvexit
		dec	si
		call	VVDigit

vvexit:					; ...
		retn

; =============== S U B	R O U T	I N E =======================================

VVDigit:
		div	bl
		add	ah, '0'         ; 30h
		dec	si
		cmp	[es:si+1], ah
		mov	ah, 0
		retn

; ---------------------------------------------------------------------------
CPScanPattern	db 89h,	26h, 48h, 1	; ...
					; mov [148],sp
		db 8Ch,	0Eh, 4Ch, 1	; mov [14C],cs
		db 0C7h, 6, 4Ah, 1, 0, 1 ; mov [14A],100h
		db 8Ch,	0Eh, 13h, 1	; mov [113],cs
		db 0B8h, 20h, 1		; mov ax,120h
		db 0BEh, 0, 1		; mov si,100h

; =============== S U B	R O U T	I N E =======================================

IsCopyProt:		; ...
		cmp	word [11Bh], 5343h ; [CPID1Offset], ID1
		jnz	short CP_done
		cmp	word [173h], 5044h ; [CPID2Offset], ID2
		jnz	short CP_done
		cmp	word [146h], 0F413h ; [CPID3Offset], ID3
		jnz	short CP_done
		cmp	word [124h], 8000h ; [CPID4Offset], ID4
		jnz	short CP_done
		push	cs
		pop	es
		mov	di, CPScanPattern
		mov	si, 175h	; CPStartOffset
		mov	cx, 24		; CPSPlen
		repe cmpsb
		jnz	short CP_done
		mov	byte [ss:A20OFF_COUNT], 0Ah

CP_done:				; ...
		retn

; ---------------------------------------------------------------------------

SYSBUF:					; ...
		iret			; initiret
; ---------------------------------------------------------------------------
InitBioDataSeg	dw 70h			; ...

; =============== S U B	R O U T	I N E =======================================

ParaRound:		; ...
		add	ax, 0Fh		; add ax, 15
		rcr	ax, 1
		shr	ax, 1
		shr	ax, 1
		shr	ax, 1
		retn

; ---------------------------------------------------------------------------

DOSINIT:				; ...
		cli
		cld
		push	dx
		push	si
		push	ds
		push	di
		mov	bx, es
		mov	ax, DOSCODE_END ; MEMSTRT
		add	ax, 15
		and	ax, 0FFF0h	; ~15
		mov	si, ax
		mov	ax, cs
		mov	ds, ax
		mov	es, [cs:InitBioDataSeg]
		mov	es, word [es:3]
		xor	di, di
		mov	cx, 4962	; MSDAT001E ; size of DOSDATA
		rep movsb
		pop	di
		pop	ds
		pop	si
		pop	dx
		push	es
		push	ds
		pop	es
		pop	ds
		mov	word [BiosDataPtr], di
		mov	word [BiosDataPtr+2], bx
		mov	[cs:DosDSeg], ds
		mov	[cs:LowInt23Seg], ds
		mov	[cs:LowInt24Seg], ds
		mov	[cs:LowInt28Seg], ds
		mov	[ENDMEM], dx
		mov	[USER_SP], sp
		mov	[USER_SS], ss
		mov	ax, ds
		mov	ss, ax
		mov	sp, DSKSTACK
		mov	word [FixExePatch], RetExePatch
		mov	word [RationalPatchPtr], RetExePatch
		mov	word [ChkCopyProt], RetExePatch
		mov	ax, cs
		mov	[TEMP_DOSLOC], ax
		mov	word [NULDEV+2], es
		mov	word [NULDEV], si
		mov	[Win386_Info_16], ds ; [Win386_Info+16]
					; [Win386_Info+Win386_SIS.Instance_Data_Ptr+2]
		push	si
		mov	cx, 7
		mov	si, Instance_Table_2 ; Instance_Table+2

Instance_init_loop:			; ...
		mov	word [si], ds
		add	si, 6		; size_of_Win386_IIS
		loop	Instance_init_loop
		mov	cx, 5
		mov	si, OldInstanceJunk_6 ; OldInstanceJunk+6

OldInstance_init_loop:			; ...
		mov	word [si], ds
		add	si, 6
		loop	OldInstance_init_loop
		pop	si
		push	es
		pop	ds
		push	ds
		xor	ax, ax
		mov	ds, ax
		mov	ax, SYSBUF ; initiret
		mov	[0A8h], ax	; [2Ah*4] ; [addr_int_ibm]
		mov	ax, cs
		mov	[0AAh], ax	; [(2Ah*4)+2] ;	[addr_int_ibm+2]
		pop	ds
		call	CHARINIT
		push	si
		push	ss
		pop	es
		mov	di, SFTABL_6 ; SFTABL+6
					; SFTABL+SFT.SFTable
		mov	ax, 3
		stosw
		dec	al
		stosw
		xor	al, al
		stosb
		mov	al, 0C3h	; devid_device_EOF|devid_device|ISCIN|ISCOUT
		stosw
		mov	ax, si
		stosw
		mov	ax, ds
		stosw
		xor	ax, ax		; 0
		stosw
		stosw
		stosw
		dec	ax		; -1
		stosw
		stosw
		inc	ax		; 0
		stosw
		stosw
		add	di, 7		; SF_ENTRY.sf_name-SF_ENTRY.sf_cluspos
		add	si, 10		; SYSDEV.NAME
		mov	cx, 4
		rep movsw
		mov	cl, 3
		mov	al, 20h	; ' '
		rep stosb
		pop	si
		or	byte [si+4], 3 ; [SI+SYSDEV.ATT],ISCIN|ISCOUT
		mov	word [ss:BCON], si
		mov	word [ss:BCON+2], ds

CHAR_INIT_LOOP:				; ...
		lds	si, [si]
		call	CHARINIT
		test	byte [si+4], 8 ; [SI+SYSDEV.ATT],ISCLOCK
		jz	short CHAR_INIT_LOOP
		mov	word [ss:BCLOCK], si
		mov	word [ss:BCLOCK+2],	ds
		mov	bp, 4962	; MSDAT001E
		mov	word [ss:SYSINITVARS], bp ;	[ss:DPBHEAD]
		mov	word [ss:SYSINITVARS+2], es	; [ss:DPBHEAD+2]

PERDRV:					; ...
		lds	si, [si]	; [SI+SYSDEV.NEXT]
		cmp	si, 0FFFFh	; -1
		jz	short CONTINIT
		call	CHARINIT
		test	word [si+4], 8000h ; [SI+SYSDEV.ATT],DEVTYP
		jnz	short PERDRV
		mov	cl, [ss:CALLMED] ; [SS:CALLUNIT]
		xor	ch, ch
		mov	[si+10], cl	; [si+SYSDEV.NAME]
		mov	dl, [ss:NUMIO]
		xor	dh, dh
		add	[ss:NUMIO], cl
		push	ds
		push	si
		lds	bx, [ss:CALLSCNT] ; [SS:CALLBPB]

PERUNIT:				; ...
		mov	si, [bx]
		inc	bx
		inc	bx
		mov	[es:bp+0], dl	; [ES:BP+DPB.DRIVE]
		mov	[es:bp+1], dh	; [ES:BP+DPB.UNIT]
		push	bx
		push	cx
		push	dx
		call	_$SETDPB
		mov	ax, [es:bp+2]	; [ES:BP+DPB.SECTOR_SIZE]
		cmp	ax, [ss:MAXSEC]
		jbe	short NOTMAX
		mov	[ss:MAXSEC], ax

NOTMAX:					; ...
		mov	ax, bp
		add	ax, 33		; DPBSIZ
		mov	[es:bp+25], ax	; [ES:BP+DPB.NEXT_DPB]
		mov	word [es:bp+27], es	; [ES:BP+DPB.NEXT_DPB+2]
		mov	byte [es:bp+24], 0FFh ; [ES:BP+DPB.FIRST_ACCESS],-1
		pop	dx
		pop	cx
		pop	bx
		mov	ax, ds
		pop	si
		pop	ds
		mov	[es:bp+19], si	; [ES:BP+DPB.DRIVER_ADDR]
		mov	word [es:bp+21], ds ; [ES:BP+DPB.DRIVER_ADDR+2]
		push	ds
		push	si
		inc	dh
		inc	dl
		mov	ds, ax
		add	bp, 33		; DPBSIZ
		loop	PERUNIT
		pop	si
		pop	ds
		jmp	PERDRV
; ---------------------------------------------------------------------------

CONTINIT:				; ...
		sub	bp, 33		; DPBSIZ
		mov	word [bp+25], 0FFFFh ; -1
		mov	word [bp+27], 0FFFFh ; -1
		add	bp, 33
		push	ss
		pop	ds
		mov	ax, bp
		call	ParaRound
		mov	dx, ds
		add	dx, ax
		mov	bx, 0Fh
		mov	cx, [ENDMEM]
		mov	[DSKCHRET_3], ds ; [DSKCHRET+3] ; [DOSSEG_INIT]
		push	dx
		mov	ax, [TEMP_DOSLOC]
		mov	es, ax
		mov	word [TEMP_DOSLOC], 0FFFFh ; -1
		call	patch_vec_segments
		call	patch_misc_segments
		mov	[TEMP_DOSLOC], es
		pop	dx
		xor	ax, ax
		mov	ds, ax
		mov	es, ax
		mov	di, 90h		; addr_int_fatal_abort
					; 4*int_fatal_abort
		mov	ax, [ss:TEMP_DOSLOC]
		mov	[di+2],	ax
		mov	di, 82h		; INTBASE+2
		mov	word [0], DIVOV
		mov	di, 80h		; INTBASE
		mov	ax, IRETT
		mov	cx, 9

iset1:					; ...
		stosw
		add	di, 2
		loop	iset1
		add	di, 4
		mov	cx, 6

iset2:					; ...
		stosw
		add	di, 2
		loop	iset2
		add	di, 8
		mov	cx, 14

iset3:					; ...
		stosw
		add	di, 2
		loop	iset3
		mov	word [0BCh], INT2F ; [02Fh*4],INT2F
		mov	ax, [ss:TEMP_DOSLOC]
		mov	[0BEh], ax	; [(02Fh*4)+2]
		mov	byte [0C0h], 0EAh ; [ENTRYPOINT],mi_long_jmp
		mov	word [0C1h], CALL_ENTRY ;	 [ENTRYPOINT+1]
		mov	word [80h], QUIT ; [addr_int_abort]
		mov	word [84h], COMMAND ; [addr_int_command]
		mov	word [88h], 100h	; [addr_int_terminate]
		mov	[8Ah], dx	; [addr_int_terminate+2]
		mov	word [94h], ABSDRD ; [addr_int_disk_read]
		mov	word [98h], ABSDWRT ; [addr_int_disk_write]
		mov	word [9Ch], STAY_RESIDENT	; [addr_int_keep_process]
		push	ss
		pop	ds
		push	ss
		pop	es
		push	dx
		inc	dx
		mov	[CurrentPDB], dx
		xor	di, di
		mov	es, dx
		xor	ax, ax
		mov	cx, 128
		rep stosw
		mov	ax, [ENDMEM]
		call	SETMEM
		push	ss
		pop	ds
		mov	di, 24		; PDB.JFN_TABLE
		xor	ax, ax
		stosw
		stosb
		mov	al, 0FFh
		mov	cx, 17		; FILPERPROC-3
		rep stosb
		push	ss
		pop	es
		mov	word [SFT_ADDR+2], ds
		mov	si, SysInitTable
		mov	word [es:si+6], es ; [es:si+SYSI_EXT.Country_Tab+2]
		mov	word [es:si+2], es ; [es:si+SYSI_EXT.SysInitVars+2]
		mov	word [es:BUFFHEAD+2], es
		mov	si, BufferQueue ; HASHINITVAR
		mov	word [es:BUFFHEAD],	si
		pop	dx
		mov	word [DMAADD+2],	dx
		mov	[es:arena_head], dx
		mov	ds, dx
		mov	byte [0], 5Ah ; 'Z' ; [ARENA.SIGNATURE],
					; arena_signature_end
		mov	word [1], 0 ; [ARENA.OWNER],
					; arena_owner_system
		mov	ax, [ss:ENDMEM]
		sub	ax, dx
		dec	ax
		mov	[3],	ax	; [ARENA.SIZE]
		mov	di, SFTABL_6 ; SFTABL+6
					; SFTABL+SFT.SFTable
		mov	ax, 3
		stosw
		mov	di, SysInitTable
		inc	dx
		mov	ds, dx
		mov	dx, _seg_reinit
		mov	cx, exepatch_start
		sub	cx, _$STARTCODE
		mov	ax, SYSBUF
		sub	ax, _$STARTCODE
		mov	sp, [ss:USER_SP]
		mov	ss, [ss:USER_SS]
		retf

; =============== S U B	R O U T	I N E =======================================

CHARINIT:		; ...
		mov	byte [ss:DEVCALL], 1Ah ; [SS:DEVCALL_REQLEN],DINITHL
		mov	byte [ss:DEVCALL+1], 0 ; [SS:DEVCALL_REQUNIT],0
		mov	byte [ss:DEVCALL_REQFUNC], 0 ; [SS:DEVCALL_REQFUNC],DEVINIT
		mov	word [ss:DEVCALL_REQSTAT], 0 ; [SS:DEVCALL_REQSTAT],0
		push	es
		push	bx
		push	ax
		mov	bx, DEVCALL
		push	ss
		pop	es
		call	DEVIOCALL2
		pop	ax
		pop	bx
		pop	es
		retn

; =============== S U B	R O U T	I N E =======================================

check_XMM:		; ...
		push	ax
		mov	ax, 4300h	; (XMM_MULTIPLEX<<8)+XMM_INSTALL_CHECK
		int	2Fh		; - Multiplex -	XMS - INSTALLATION CHECK
					; Return: AL = 80h XMS driver installed
					; AL <>	80h no driver
		cmp	al, 80h
		jnz	short cXMM_no_driver
		push	bx
		push	dx
		push	ds
		push	es
		mov	ax, 4310h	; (XMM_MULTIPLEX<<8)+XMM_FUNCTION_ADDR
		int	2Fh		; - Multiplex -	XMS - GET DRIVER ADDRESS
					; Return: ES:BX	-> driver entry	point
		mov	ds, [cs:DosDSeg]
		mov	word [XMMcontrol], bx
		mov	word [XMMcontrol+2], es

cXMMexit:
		clc
		pop	es
		pop	ds
		pop	dx
		pop	bx
		pop	ax
		retn
; ---------------------------------------------------------------------------

cXMM_no_driver:				; ...
		stc
		pop	ax
		retn

; ---------------------------------------------------------------------------
num_entry	db 0			; ...
; ---------------------------------------------------------------------------

_seg_reinit:				; ...
		push	ds
		mov	ds, [cs:DosDSeg]
		call	patch_misc_segments
		cmp	ax, 0
		jnz	short patch_vec_seg
		cmp	byte [cs:num_entry], 0
		jnz	short second_entry
		mov	ax, ds
		call	patch_vec_segments
		call	patch_offset

second_entry:				; ...
		mov	ax, es
		mov	di, DOSINTTABLE
		mov	cx, 9
		push	ds
		pop	es

dosinttabloop:				; ...
		add	di, 2
		stosw
		loop	dosinttabloop
		cmp	ax, 0F000h
		jb	short sr_done
		call	check_XMM
		jb	short sr_done
		call	patch_in_nops
		mov	byte [DosHasHMA], 1
		mov	word [FixExePatch], ExePatch
		mov	word [ChkCopyProt], IsCopyProt

Get_CPU_Type:				; WhatCPUType
		pushf
		push	bx
		xor	bx, bx
		xor	ax, ax
		push	ax
		popf
		pushf
		pop	ax
		and	ax, 0F000h
		cmp	ax, 0F000h
		jz	short cpu_8086
		mov	ax, 0F000h
		push	ax
		popf
		pushf
		pop	ax
		and	ax, 0F000h
		jz	short cpu_286
		inc	bx

cpu_286:				; ...
		inc	bx

cpu_8086:				; ...
		mov	ax, bx
		pop	bx
		popf
		cmp	al, 1
		jnz	short sr_done
		mov	word [RationalPatchPtr], RationalPatch
		jmp	short sr_done
; ---------------------------------------------------------------------------

patch_vec_seg:				; ...
		mov	ax, es
		call	patch_vec_segments

sr_done:				; ...
		mov	byte [cs:num_entry], 1
		pop	ds
		retf

; =============== S U B	R O U T	I N E =======================================

patch_vec_segments:	; ...
		push	es
		xor	cx, cx
		mov	es, cx
		mov	di, 82h		; INTBASE+2
					; di ->	segment	of int 20 vector
		mov	[es:2],	ax
		mov	cx, 2

ps_set1:				; ...
		stosw
		add	di, 2
		loop	ps_set1
		add	di, 4
		stosw
		add	di, 6
		mov	cx, 4

ps_set2:				; ...
		stosw
		add	di, 2
		loop	ps_set2
		add	di, 4
		mov	cx, 6

ps_set3:				; ...
		stosw
		add	di, 2
		loop	ps_set3
		add	di, 8
		mov	cx, 14

ps_set4:				; ...
		stosw
		add	di, 2
		loop	ps_set4
		mov	[es:0C3h], ax	; [es:ENTRYPOINT+3]
		pop	es
		retn

; =============== S U B	R O U T	I N E =======================================

patch_misc_segments: ; ...
		push	bx
		push	es
		push	ax
		mov	ax, es
		push	ds
		pop	es
		mov	di, JShare
		mov	bx, [TEMP_DOSLOC]
		mov	cx, 15

jumptabloop:				; ...
		add	di, 2
		cmp	bx, -1
		jz	short share_patch
		cmp	bx, [es:di]
		jnz	short no_share_patch

share_patch:				; ...
		stosw

no_share_patch:				; ...
		loop	jumptabloop
		mov	si, COUNTRY_CDPG
		mov	word [si+4Fh], ds ; [si+DOS_CCDPG.ccUcase_ptr+2]
		mov	word [si+54h], ds ; [si+DOS_CCDPG.ccFileUcase_ptr+2]
		mov	word [si+59h], ds ; [si+DOS_CCDPG.ccFileChar_ptr+2]
		mov	word [si+5Eh], ds ; [si+DOS_CCDPG.ccCollate_ptr+2]
		mov	word [si+80h], ds ; [si+DOS_CCDPG.ccMono_ptr+2]
		mov	word [si+63h], ds ; [si+DOS_CCDPG.ccDBCS_ptr+2]
		mov	si, FastOpenTable
		cmp	word [TEMP_DOSLOC], 0FFFFh ; -1
		jz	short fast_patch
		mov	cx, [TEMP_DOSLOC]
		cmp	cx, [si+4]	; [si+fastopen_entry.name_caching+2]
		jnz	short no_fast_patch

fast_patch:				; ...
		mov	[si+4],	ax

no_fast_patch:				; ...
		pop	ax
		pop	es
		pop	bx
		retn

; =============== S U B	R O U T	I N E =======================================

patch_offset:	; ...
		push	es
		xor	ax, ax
		mov	es, ax
		mov	word [es:0], ldivov
		mov	di, 80h		; INTBASE
					; di-> offset of int 20	handler
		mov	ax, lirett
		mov	cx, 2

po_iset1:				; ...
		stosw
		add	di, 2
		loop	po_iset1
		add	di, 4
		stosw
		add	di, 6
		mov	cx, 4

po_iset2:				; ...
		stosw
		add	di, 2
		loop	po_iset2
		add	di, 4
		mov	cx, 6

po_iset3:				; ...
		stosw
		add	di, 2
		loop	po_iset3
		add	di, 8
		mov	cx, 14

po_iset4:				; ...
		stosw
		add	di, 2
		loop	po_iset4
		mov	word [es:0BCh], lint2f
		mov	byte [es:0C0h], 0EAh ; [es:ENTRYPOINT],mi_long_jmp
		mov	word [es:0C1h], lcall_entry
		mov	word [es:80h], lquit	; [es:addr_int_abort]
		mov	word [es:84h], lcommand ; [es:addr_int_command]
		mov	word [es:94h], labsdrd ; [es:addr_int_disk_read]
		mov	word [es:98h], labsdwrt ; [es:addr_int_disk_write]
		mov	word [es:9Ch], lstay_resident ; [es:addr_int_keep_process]
		pop	es
		retn

; ---------------------------------------------------------------------------
patch_table	dw ldivov	; ...
					; i0patch
		dw lquit		; i20patch
		dw lcommand	; i21patch
		dw labsdrd	; i25patch
		dw labsdwrt	; i26patch
		dw lstay_resident ; i27patch
		dw lint2f	; i2fpatch
		dw lcall_entry	; cpmpatch
; ---------------------------------------------------------------------------

patch_in_nops:				; ...
		push	ax
		push	si
		mov	si, patch_table
		mov	ax, 9090h	; nop, nop
		mov	cx, 8		; patch_table_size

pin_loop:				; ...
		mov	di, [cs:si]
		stosw
		add	si, 2
		loop	pin_loop
		pop	si
		pop	ax
		retn
; ---------------------------------------------------------------------------
DOSCODE_END	db 9 dup(0)		; ...

; ===========================================================================
; ----------------------------------------------------------------------------
; 06/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; ----------------------------------------------------------------------------

segment .data  vstart=0 ; 06/12/2022
								
; ============================================================================

DOSDATASTART:
DATASTART	db 4 dup(0)
DataVersion	dw 1
WinoldPatch1	db 8 dup(0)		; ...
MYNUM		dw 0			; ...
FCBLRU		dw 0			; ...
OpenLRU		dw 0
OEM_HANDLER	dd 0FFFFFFFFh
LeaveAddr	dw LeaveDOS	; DOSCODE:LeaveDOS
RetryCount	dw 3			; ...
RetryLoop	dw 1			; ...
LastBuffer	dd 0FFFFFFFFh		; ...
CONTPOS		dw 0			; ...
arena_head	dw 0			; ...
SYSINITVARS	dd 0			; ...
					; DPBHEAD
SFT_ADDR	dd 0CCh			; ...
BCLOCK		dd 0			; ...
BCON		dd 0			; ...
MAXSEC		dw 128			; ...
BUFFHEAD	dd 0			; ...
CDSADDR		dd 0			; ...
SFTFCB		dd 0			; ...
KEEPCOUNT	dw 0
NUMIO		db 0			; ...
CDSCOUNT	db 0			; ...
NULDEV		dd 0			; ...
		dw 8004h		; DEVTYP|ISNULL
		dw SNULDEV
		dw INULDEV
		db 'NUL     '
SPLICES		db 0			; ...
Special_Entries	dw 0
UU_IFS_DOS_CALL	dd 0			; ...
ChkCopyProt	dw 0			; ...
A20OFF_PSP	dw 0			; ...
BUFFERS_PARM1	dw 0
BUFFERS_PARM2	dw 0
BOOTDRIVE	db 0			; ...
DDMOVE		db 0			; ...
EXT_MEM_SIZE	dw 0
BufferQueue	dd 0			; ...
DirtyBufferCount dw 0			; ...
SC_CACHE_PTR	dd 0			; ...
SC_CACHE_COUNT	dw 0			; ...
BuffInHMA	db 0			; ...
LoMemBuff	dd 0			; ...
UU_BUF_EMS_FIRST_PAGE db 3 dup(0)
CL0FATENTRY	dw -1			; ...
IoStatFail	db 0			; ...
ALLOCMSAVE	db 0			; ...
A20OFF_COUNT	db 0			; ...
DOS_FLAG	db 0			; ...
UNPACK_OFFSET	dw 0			; ...
UMBFLAG		db 0			; ...
SAVE_AX		dw 0			; ...
UMB_HEAD	dw -1			; ...
START_ARENA	dw 1			; ...
JShare		dw BadCall	; ...
		dw 0
MFT_enter	dw OKCall		; ...
		dw 0
MFTClose	dw OKCall		; ...
		dw 0
MFTclU		dw BadCall		; ...
		dw 0
MFTCloseP	dw BadCall	; ...
		dw 0
MFTcloN		dw BadCall	; ...
		dw 0
set_block	dw BadCall		; ...
		dw 0
clr_block	dw BadCall		; ...
		dw 0
chk_block	dw OKCall		; ...
		dw 0
MFT_get		dw BadCall		; ...
		dw 0
ShSave		dw BadCall	; ...
		dw 0
ShChk		dw BadCall	; ...
		dw 0
ShCol		dw OKCall		; ...
		dw 0
ShCloseFile	dw BadCall	; ...
		dw 0
ShSU		dw BadCall	; ...
		dw 0
SFTABL		dw -1
		dw -1
		dw 5
SFTABL_6	db 295 dup(0)		; SFTABL+6
CARPOS		db 0			; ...
STARTPOS	db 0			; ...
INBUF		db 128 dup(0)		; ...
CONBUF		db 131 dup(0)		; ...
PFLAG		db 0			; ...
VERFLG		db 0			; ...
CHARCO		db 11b			; ...
chSwitch	db '/'
AllocMethod	db 0			; ...
fShare		db 0			; ...
DIFFNAM		db 1			; ...
MYNAME		db 16 dup(20h)		; ...
CritPatch	dw redir_patch
		dw redir_patch
		dw redir_patch
		dw redir_patch
		dw 0
		db 90h			; align	2
ERRORMODE	db 0			; ...
					; SWAP_START
INDOS		db 0			; ...
WPERR		db -1			; ...
EXTERR_LOCUS	db 0			; ...
EXTERR		dw 0			; ...
EXTERR_ACTION	db 0			; ...
EXTERR_CLASS	db 0			; ...
EXTERRPT	dd 0			; ...
DMAADD		dd 80h			; ...
CurrentPDB	dw 0			; ...
ConC_Spsave	dw 0			; ...
exit_code	dw 0			; ...
CURDRV		db 0			; ...
CNTCFLAG	db 0			; ...
CPSWFLAG	db 0
CPSWSAVE	db 0
USER_IN_AX	dw 0			; ...
					; SWAP_ALWAYS
PROC_ID		dw 0			; ...
USER_ID		dw 0			; ...
FirstArena	dw 0			; ...
BestArena	dw 0			; ...
LastArena	dw 0			; ...
ENDMEM		dw 0			; ...
LASTENT		dw 0			; ...
FAILERR		db 0			; ...
ALLOWED		db 0			; ...
NoSetDir	db 0			; ...
DidCTRLC	db 0			; ...
SpaceFlag	db 0			; ...
		db 90h			; align	2
DAY		db 0			; ...
MONTH		db 0			; ...
YEAR		dw 0			; ...
DAYCNT		dw 0FFFFh		; ...
WEEKDAY		db 0			; ...
CONSWAP		db 0			; ...
IDLEINT		db 1			; ...
fAborting	db 0			; ...
DEVCALL		dw 0			; ...
DEVCALL_REQFUNC	db 0			; ...
DEVCALL_REQSTAT	dw 0			; ...
		db 8 dup(0)
CALLMED		db 0			; ...
CALLXADD	db 0,0,0,0		; ...
CALLSCNT	dw 0			; ...
CALLSSEC	dw 0			; ...
CALLVIDRW	dd 0			; ...
CALLNEWSC	dd 0			; ...
CALLDEVAD	dd 0			; ...
IOCALL_REQLEN	db 0			; ...
					; IOCALL
IOCALL_REQUNIT	db 0			; ...
IOCALL_REQFUNC	db 0			; ...
IOCALL_REQSTAT	db 2 dup(0)		; ...
		db 8 dup(0)
IOCTL_REQ_MAJORFUNCTION	db 0		; ...
IOCTL_REQ_MINORFUNCTION	db 0		; ...
IOCTL_REQ_REG_SI db 0			; ...
IOCTL_IOXAD_2	db 0			; ...
IOCTL_REQ_REG_DI db 0			; ...
IOCTL_IOSCNT	db 0			; ...
IOCTL_REQ_GENERICIOCTL_PACKET dw 0	; ...
IOCTL_REQ_GENERICIOCTL_PACKET_2	db 0	; ...
DSKSTCALL	db 14			; ...
					; DRDNDHL
		db 0
DSKSTCOM	db 5			; ...
					; DEVRDND
DSKSTST		dw 0			; ...
		db 8 dup(0)
DSKCHRET	db 0			; ...
DSKCHRET_1	dw DEVIOBUF		; DSKCHRET+1
DSKCHRET_3	dw 0			; DSKCHRET+3
DSKSTCNT	dw 1			; ...
		dw 0
CreatePDB	db 0			; ...
Lock_Buffer	db 8 dup(0)		; ...
		db 90h
USERNUM		dd 0FF000000h		; ...
TIMEBUF		dw 3 dup(0)		; ...
DEVIOBUF	dw 0			; ...
OPENBUF		db 128 dup(0)		; ...
RENBUF		db 128 dup(0)		; ...
SEARCHBUF	db 53 dup(0)		; ...
DUMMYCDS	db 88 dup(0)		; ...
NAME1		db 12 dup(0)		; ...
NAME2		db 13 dup(0)		; ...
DESTSTART	dw 0			; ...
		db 5 dup(0)
ATTRIB		db 0			; ...
EXTFCB		db 0			; ...
SATTRIB		db 0			; ...
OPEN_ACCESS	db 0			; ...
FOUNDDEL	db 0			; ...
FOUND_DEV	db 0			; ...
FSPLICE		db 0			; ...
FSHARING	db 0			; ...
SECCLUSPOS	db 0			; ...
TRANS		db 0			; ...
READOP		db 0			; ...
THISDRV		db 0			; ...
CLUSFAC		db 0			; ...
CLUSSPLIT	db 0			; ...
INSMODE		db 0			; ...
CMETA		db 0			; ...
VOLID		db 0			; ...
EXIT_TYPE	db 0			; ...
		db 90h
CREATING	db 0			; ...
DELALL		db 0			; ...
EXITHOLD	dd 0			; ...
USER_SP		dw 0			; ...
USER_SS		dw 0			; ...
CONTSTK		dw 0			; ...
THISDPB		dd 0			; ...
CLUSSAVE	dw 0			; ...
CLUSSEC		dd 0			; ...
PREREAD		dw 0			; ...
FATBYT		dw 0			; ...
FATBYTE		db 0			; ...
		db 0
DEVPT		dd 0			; ...
THISSFT		dd 0			; ...
THISCDS		dd 0			; ...
THISFCB		dd 0			; ...
SFN		dw 0FFFFh		; ...
JFN		dw 0			; ...
PJFN		dd 0			; ...
WFP_START	dw 0			; ...
REN_WFP		dw 0			; ...
CURR_DIR_END	dw 0			; ...
NEXTADD		dw 0			; ...
LASTPOS		dw 0			; ...
CLUSNUM		dw 0			; ...
DIRSEC		dd 0			; ...
DIRSTART	dw 0			; ...
SECPOS		dd 0			; ...
VALSEC		dd 0			; ...
BYTSECPOS	dw 0			; ...
BYTPOS		dd 0			; ...
BYTCNT1		dw 0			; ...
BYTCNT2		dw 0			; ...
SECCNT		dw 0			; ...
ENTFREE		dw 0			; ...
ENTLAST		dw 0			; ...
NXTCLUSNUM	dw 0			; ...
GROWCNT		dd 0			; ...
CURBUF		dd 0			; ...
CONSFT		dd 0			; ...
SAVEBX		dw 0			; ...
SAVEDS		dw 0			; ...
RESTORE_TMP	dw 0			; ...
NSS		dw 0			; ...
NSP		dw 0			; ...
EXTOPEN_FLAG	dw 0			; ...
EXTOPEN_ON	db 0			; ...
EXTOPEN_IO_MODE	dw 0			; ...
SAVE_DI		dw 0			; ...
SAVE_ES		dw 0			; ...
SAVE_DX		dw 0			; ...
SAVE_CX		dw 0			; ...
SAVE_BX		dw 0			; ...
SAVE_SI		dw 0			; ...
SAVE_DS		dw 0			; ...
HIGH_SECTOR	dw 0			; ...
		dw 0
DISK_FULL	db 0			; ...
TEMP_VAR	dw 0			; ...
TEMP_VAR2	dw 0			; ...
DrvErr		db 0			; ...
DOS34_FLAG	dw 0			; ...
		db 8 dup(0)
AbsRdWr_SS	dw 0			; ...
AbsRdWr_SP	dw 0			; ...
		db 0
RENAMEDMA	db 384 dup(0)		; ...
AUXSTACK	db 384 dup(0)		; ...
DSKSTACK	db 384 dup(0)		; ...
					; IOSTACK
PRINTER_FLAG	db 0			; ...
VOLCHNG_FLAG	db 0			; ...
VIRTUAL_OPEN	db 0			; ...
FSeek_drive	db 0
FSeek_firclus	dw 0
FSeek_logclus	dw 0
FSeek_logsave	dw 0
TEMP_DOSLOC	dw -1			; ...
SWAP_END	db 0			; ...
UCASE_TAB	dw 128			; ...
UCASE_TAB_2	db 128,154,069,065,142,065,143,128 ; ...
		db 069,069,069,073,073,073,142,143
		db 144,146,146,079,153,079,085,085
		db 089,153,154,155,156,157,158,159
		db 065,073,079,085,165,165,166,167
		db 168,169,170,171,172,173,174,175
		db 176,177,178,179,180,181,182,183
		db 184,185,186,187,188,189,190,191
		db 192,193,194,195,196,197,198,199
		db 200,201,202,203,204,205,206,207
		db 208,209,210,211,212,213,214,215
		db 216,217,218,219,220,221,222,223
		db 224,225,226,227,228,229,230,231
		db 232,233,234,235,236,237,238,239
		db 240,241,242,243,244,245,246,247
		db 248,249,250,251,252,253,254,255
FILE_UCASE_TAB	dw 128			; ...
FILE_UCASE_TAB_2 db 128,154,069,065,142,065,143,128 ; ...
		db 069,069,069,073,073,073,142,143
		db 144,146,146,079,153,079,085,085
		db 089,153,154,155,156,157,158,159
		db 065,073,079,085,165,165,166,167
		db 168,169,170,171,172,173,174,175
		db 176,177,178,179,180,181,182,183
		db 184,185,186,187,188,189,190,191
		db 192,193,194,195,196,197,198,199
		db 200,201,202,203,204,205,206,207
		db 208,209,210,211,212,213,214,215
		db 216,217,218,219,220,221,222,223
		db 224,225,226,227,228,229,230,231
		db 232,233,234,235,236,237,238,239
		db 240,241,242,243,244,245,246,247
		db 248,249,250,251,252,253,254,255
FILE_CHAR_TAB	dw 22			; ...
		db 1, 0, 255
		db 0, 0, 20h
		db 2, 14
		db '."/\[]:|<>+=;,'
		db 24 dup(0)
COLLATE_TAB	dw 256			; ...
		db 0, 1, 2, 3, 4, 5, 6,	7
		db 8, 9, 10, 11, 12, 13, 14, 15
		db 16, 17, 18, 19, 20, 21, 22, 23
		db 24, 25, 26, 27, 28, 29, 30, 31
		db ' ', '!', '"', '#', '$', '%', '&'
		db 27h
		db '(', ')', '*', '+', ',', '-', '.', '/'
		db '0', '1', '2', '3', '4', '5', '6', '7'
		db '8', '9', ':', ';', '<', '=', '>', '?'
		db '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G'
		db 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O'
		db 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W'
		db 'X', 'Y', 'Z', '[', '\', ']', '^', '_'
		db '`', 'A', 'B', 'C', 'D', 'E', 'F', 'G'
		db 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O'
		db 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W'
		db 'X', 'Y', 'Z', '{', '|', '}', '~', ''
		db 'C', 'U', 'E', 'A', 'A', 'A', 'A', 'C'
		db 'E', 'E', 'E', 'I', 'I', 'I', 'A', 'A'
		db 'E', 'A', 'A', 'O', 'O', 'O', 'U', 'U'
		db 'Y', 'O', 'U', '$', '$', '$', '$', '$'
		db 'A', 'I', 'O', 'U', 'N', 'N'
		db 166,	167
		db '?'
		db 169,	170, 171, 172
		db '!', '"', '"'
		db 176,	177, 178, 179, 180, 181, 182, 183
		db 184,	185, 186, 187, 188, 189, 190, 191
		db 192,	193, 194, 195, 196, 197, 198, 199
		db 200,	201, 202, 203, 204, 205, 206, 207
		db 208,	209, 210, 211, 212, 213, 214, 215
		db 216,	217, 218, 219, 220, 221, 222, 223
		db 224
		db 'S'
		db 226,	227, 228, 229, 230, 231, 232, 233
		db 234,	235, 236, 237, 238, 239, 240, 241
		db 242,	243, 244, 245, 246, 247, 248, 249
		db 250,	251, 252, 253, 254, 255
DBCS_TAB	dw 9 dup(0)		; ...
; ---------------------------------------------------------------------------

MAP_CASE:				; ...
		cmp	al, 80h
		jnb	short Map1
		retf
; ---------------------------------------------------------------------------

Map1:					; ...
		sub	al, 80h
		push	ds
		push	bx
		mov	bx, UCASE_TAB_2 ; UCASE_TAB+2
		push	cs
		pop	ds
		xlat
		pop	bx
		pop	ds
		retf
; ---------------------------------------------------------------------------
InterChar	db 0
InterCon	db 0
SaveCurFlg	db 0
TEMPSEG		dw 0			; ...
redir_patch	db 0			; ...
		db 5 dup(0)
		db 5
		db 0
YRTAB		db 200,	166		; ...
		db 200,	165
		db 200,	165
		db 200,	165
MONTAB		db 31			; ...
february	db 28			; ...
		db 31
		db 30
		db 31
		db 30
		db 31
		db 31
		db 30
		db 31
		db 30
		db 31
SysInitTable	dw SYSINITVARS	; ...
		dw 0
		dw COUNTRY_CDPG
		dw 0
FastOpenTable	dw 2			; ...
FastOpenTable_2	dw FastRet	; ...
		dw 0
		dw FastRet
		dw 0
FastOpenFlg	db 0			; ...
FastOpen_Ext_Info db 11	dup( 0)		; ...
Dir_Info_Buff	db 32 dup( 0)		; ...
Next_Element_Start dw 0			; ...
Del_ExtCluster	dw 0
USER_SP_2F	dw FAKE_STACK_2F	; ...
FAKE_STACK_2F	dw 14 dup(0)		; ...
					; DOS_TEMP
Hash_Temp	dw 4 dup(0)
SCAN_FLAG	db 0			; ...
DATE_FLAG	dw 0			; ...
FETCHI_TAG	dw 0			; OBSOLETE
MSG_EXTERROR	dd 0
		dd 0
		dd 0
		dd 0
		dd 0
SEQ_SECTOR	dd -1			; ...
SC_SECTOR_SIZE	dw 0			; ...
SC_DRIVE	db 0			; ...
CurSC_DRIVE	db -1			; ...
CurSC_SECTOR	dd 0			; ...
SC_STATUS	dw 0			; ...
SC_FLAG		db 0			; ...
AbsDskErr	dw 0			; ...
NO_NAME_ID	db 'NO NAME    '        ; ...
LOOKSIZ		db 0
; ---------------------------------------------------------------------------

SNULDEV:				; ...
		or	word [es:bx+3], 100h ; [es:bx+SRHEAD.REQSTAT],
					; STDON

INULDEV:				; ...
		retf
; ---------------------------------------------------------------------------
WinoldPatch2	db 8 dup(0)		; ...
UmbSave2	db 5 dup(0)		; ...
UmbSaveFlag	db 0			; ...
ERR_TABLE_21	db 1, 7, 4, 0FFh	; ...
		db 2, 8, 3, 2
		db 3, 8, 3, 2
		db 4, 1, 4, 1
		db 5, 3, 3, 0FFh
		db 6, 7, 4, 1
		db 7, 7, 5, 5
		db 8, 1, 4, 5
		db 9, 7, 4, 5
		db 0Ah,	7, 4, 5
		db 0Bh,	9, 3, 1
		db 0Ch,	7, 4, 1
		db 0Dh,	9, 4, 1
		db 0Fh,	8, 3, 2
		db 10h,	3, 3, 2
		db 11h,	0Dh, 3,	2
		db 12h,	8, 3, 2
		db 50h,	0Ch, 3,	2
		db 20h,	0Ah, 2,	2
		db 21h,	0Ah, 2,	2
		db 54h,	1, 4, 0FFh
		db 56h,	3, 3, 1
		db 52h,	1, 4, 2
		db 32h,	9, 3, 3
		db 55h,	0Ch, 3,	3
		db 57h,	9, 3, 1
		db 53h,	0Dh, 4,	1
		db 24h,	1, 4, 5
		db 26h,	1, 4, 1
		db 27h,	1, 4, 1
		db 5Ah,	0Dh, 4,	2
		db 0FFh, 0FFh, 0FFh, 0FFh
ERR_TABLE_24	db 13h,	0Bh, 7,	2	; ...
		db 14h,	4, 5, 1
		db 15h,	5, 7, 0FFh
		db 16h,	4, 5, 1
		db 17h,	0Bh, 4,	2
		db 18h,	4, 5, 1
		db 19h,	5, 1, 2
		db 1Ah,	0Bh, 7,	2
		db 1Bh,	0Bh, 4,	2
		db 1Ch,	2, 7, 4
		db 1Dh,	5, 4, 0FFh
		db 1Eh,	5, 4, 0FFh
		db 1Fh,	0Dh, 4,	0FFh
		db 20h,	0Ah, 2,	2
		db 21h,	0Ah, 2,	2
		db 22h,	0Bh, 7,	2
		db 32h,	9, 3, 3
		db 23h,	7, 4, 1
		db 24h,	1, 4, 5
		db 0FFh, 0Dh, 5, 0FFh
ErrMap24	db 13h,	14h, 15h, 16h, 17h, 18h, 19h, 1Ah ; ...
		db 1Bh,	1Ch, 1Dh, 1Eh, 1Fh, 1Fh, 1Fh, 22h
FIRST_BUFF_ADDR	dw 0			; ...
SPECIAL_VERSION	dw 0			; ...
FAKE_COUNT	db 255 dup(0)
OLD_FIRSTCLUS	dw 0			; ...
exec_init_SP	dw 0			; ...
exec_init_SS	dw 0			; ...
exec_init_IP	dw 0			; ...
exec_init_CS	dw 0			; ...
exec_signature	dw 0			; ...
exec_len_mod_512 dw 0
exec_pages	dw 0			; ...
exec_rle_count	dw 0			; ...
exec_par_dir	dw 0			; ...
exec_min_BSS	dw 0			; ...
exec_max_BSS	dw 0			; ...
exec_SS		dw 0			; ...
exec_SP		dw 0			; ...
exec_chksum	dw 0
exec_IP		dw 0			; ...
exec_CS		dw 0
exec_rle_table	dw 0			; ...
Win386_Info	db 3, 13 dup(0)		; ...
		dw Instance_Table
Win386_Info_16	dw 0			; ...
Instance_Table	dw CONTPOS	; ...
Instance_Table_2 dw 0			; ...
		dw 2
		dw BCON
		dw 0
		dw 4
		dw CARPOS
		dw 0
		dw 106h
		dw CHARCO
		dw 0
		dw 1
		dw exec_init_SP
		dw 0
		dw 22h
		dw UMBFLAG
		dw 0
		dw 1
		dw UMB_HEAD
		dw 0
		dw 2
		dw 0
		dw 0
Win386_DOSVars	db 5			; ...
					; Major	version	5
		db 0			; Minor	version	0
		dw SAVEDS
		dw SAVEBX
		dw INDOS
		dw USER_ID
		dw CritPatch
		dw UMB_HEAD
IsWin386	db 0			; ...
VxDpath		db 'c:\wina20.386',0    ; ...
DriverLoad	db 1			; ...
BiosDataPtr	dd 0			; ...
		db 36h,	0F6h, 6, 20h, 3, 0FFh ;	Patch for Sidekick
		db 75h,	0Ch
		db 36h,	0FFh, 36h, 58h,	3
		db 0CDh, 28h
		db 80h,	3Eh, 20h, 3, 0	; Patch	for PortOfEntry
		db 75h,	37h
		db 0BCh, 0A0h, 0Ah
LocalSFT	dd 0			; ...
		db 90h			; align	2
DOSINTTABLE	dw DIVOV		; ...
		dw 0
DOSINTTABLE_4	dw QUIT		; ...
		dw 0
DOSINTTABLE_8	dw COMMAND	; ...
		dw 0
DOSINTTABLE_12	dw ABSDRD	; ...
		dw 0
DOSINTTABLE_16	dw ABSDWRT	; ...
		dw 0
DOSINTTABLE_20	dw STAY_RESIDENT	; ...
		dw 0
DOSINTTABLE_24	dw INT2F		; ...
		dw 0
DOSINTTABLE_28	dw CALL_ENTRY	; ...
		dw 0
		dw IRETT
		dw 0
SS_Save		dw 0			; ...
SP_Save		dw 0			; ...
; ---------------------------------------------------------------------------

ldivov:					; ...
		jmp	short divov_cont ; i0patch
; ---------------------------------------------------------------------------
		call	EnsureA20ON

divov_cont:				; ...
		;jmp	dword [cs:DOSINTTABLE]
		jmp	far [cs:DOSINTTABLE]
; ---------------------------------------------------------------------------

lquit:					; ...
		jmp	short quit_cont	; i20patch
; ---------------------------------------------------------------------------
		call	EnsureA20ON

quit_cont:				; ...
		;jmp	dword [cs:DOSINTTABLE_4]
		jmp	far [cs:DOSINTTABLE+4]
; ---------------------------------------------------------------------------

lcommand:				; ...
		jmp	short command_cont ; i21patch
; ---------------------------------------------------------------------------
		call	EnsureA20ON

command_cont:				; ...
		;jmp	dword [cs:DOSINTTABLE_8]
		jmp	far [cs:DOSINTTABLE+8]
; ---------------------------------------------------------------------------

labsdrd:				; ...
		jmp	short absdrd_cont ; i25patch
; ---------------------------------------------------------------------------
		call	EnsureA20ON

absdrd_cont:				; ...
		;jmp	dword [cs:DOSINTTABLE_12]
		jmp	far [cs:DOSINTTABLE+12]
; ---------------------------------------------------------------------------

labsdwrt:				; ...
		jmp	short absdwrt_cont ; i26patch
; ---------------------------------------------------------------------------
		call	EnsureA20ON

absdwrt_cont:				; ...
		;jmp	dword [cs:DOSINTTABLE_16]
		jmp	far [cs:DOSINTTABLE+16]
; ---------------------------------------------------------------------------

lstay_resident:				; ...
		jmp	short sr_cont	; i27patch
; ---------------------------------------------------------------------------
		call	EnsureA20ON

sr_cont:				; ...
		;jmp	dword [cs:DOSINTTABLE_20]
		jmp	far [cs:DOSINTTABLE+20]
; ---------------------------------------------------------------------------

lint2f:					; ...
		jmp	short int2f_cont ; i2fpatch
; ---------------------------------------------------------------------------
		call	EnsureA20ON

int2f_cont:				; ...
		;jmp	dword [cs:DOSINTTABLE_24]
		jmp	far [cs:DOSINTTABLE+24]
; ---------------------------------------------------------------------------

lcall_entry:				; ...
		jmp	short callentry_cont ; cpmpatch
; ---------------------------------------------------------------------------
		call	EnsureA20ON

callentry_cont:				; ...
		;jmp	dword [cs:DOSINTTABLE_28]
		jmp	far [cs:DOSINTTABLE+28]
; ---------------------------------------------------------------------------

lirett:					; ...
		iret
; ---------------------------------------------------------------------------
DosRetAddr23	dd 0			; ...
DosRetAddr24	dd 0			; ...
DosRetAddr28	dd 0
; ---------------------------------------------------------------------------

LowInt23:				; ...
		pop	word [cs:DosRetAddr23]
		pop	word [cs:DosRetAddr23+2]
		int	23h		; DOS -	CONTROL	"C" EXIT ADDRESS
					; Return: return via RETF 2 with CF set
					; DOS will abort program with errorlevel 0
					; else
					; interrupted DOS call continues
		call	EnsureA20ON
		;jmp	[cs:DosRetAddr23]
		jmp	far [cs:DosRetAddr23]
; ---------------------------------------------------------------------------

LowInt24:				; ...
		pop	word [cs:DosRetAddr24]
		pop	word [cs:DosRetAddr24+2]
		int	24h		; DOS -	FATAL ERROR HANDLER ADDRESS
					; Automatically	called upon detection of unrecoverable I/O error.
		call	EnsureA20ON
		;jmp	[cs:DosRetAddr24]
		jmp	far [cs:DosRetAddr24]
; ---------------------------------------------------------------------------

LowInt28:				; ...
		int	28h		; DOS 2+ internal - KEYBOARD BUSY LOOP
		call	EnsureA20ON
		retf
; ---------------------------------------------------------------------------

disa20_xfer:				; ...
		call	XMMDisableA20
		cli
		mov	byte [cs:INDOS], 0
		mov	ss, ax
		mov	sp, di
		sti
		push	ds
		push	si
		mov	es, dx
		mov	ds, dx
		mov	ax, bx
		retf
; ---------------------------------------------------------------------------

disa20_iret:				; ...
		call	XMMDisableA20
		dec	byte [INDOS]
		mov	ss, word [USER_SS]
		mov	sp, [USER_SP]
		mov	bp, sp
		mov	[bp+0],	al
		mov	ax, [NSP]
		mov	[USER_SP], ax
		mov	ax, [NSS]
		mov	[USER_SS], ax
		pop	ax
		pop	bx
		pop	cx
		pop	dx
		pop	si
		pop	di
		pop	bp
		pop	ds
		pop	es
		iret

; =============== S U B	R O U T	I N E =======================================

XMMDisableA20:	; ...
		push	bx
		push	ax
		mov	ah, 6
		;call	[cs:XMMcontrol]
		call	far [cs:XMMcontrol]
		pop	ax
		pop	bx
		retn

; ---------------------------------------------------------------------------
XMMcontrol	dd 0			; ...
LowMemory	dd 80h			; ...
HighMemory	dd 0FFFF0090h		; ...

; =============== S U B	R O U T	I N E =======================================


 EnsureA20ON:	; ...
		pushf
		push	ds
		push	es
		push	cx
		push	si
		push	di
		lds	si, [cs:LowMemory]
		les	di, [cs:HighMemory]
		mov	cx, 4
		cld
		repe cmpsw
		jz	short EA20_OFF

EA20_RET:				; ...
		pop	di
		pop	si
		pop	cx
		pop	es
		pop	ds
		popf
		retn
; ---------------------------------------------------------------------------

EA20_OFF:				; ...
		push	bx
		push	ax
		mov	ax, ss
		mov	[cs:SS_Save], ax
		mov	[cs:SP_Save], sp
		mov	ax, cs
		mov	ss, ax
		mov	sp, AUXSTACK
		mov	ah, 5		; XMM_LOCAL_ENABLE_A20
		;call	[cs:XMMcontrol]
		call	far [cs:XMMcontrol]
		or	ax, ax
		jz	short XMMerror
		mov	ax, [cs:SS_Save]
		mov	ss, ax
		mov	sp, [cs:SP_Save]
		pop	ax
		pop	bx
		jmp	short EA20_RET
; ---------------------------------------------------------------------------

XMMerror:				; ...
		mov	ah, 0Fh
		int	10h		; - VIDEO - SELECT DISPLAY PAGE
					; AL = display page, 0-7  for modes 0 &	1, 0-3	for modes 2 & 3
		cmp	al, 7
		jz	short XMMcont
		xor	ah, ah
		mov	al, 2
		int	10h		; - VIDEO -

XMMcont:				; ...
		mov	ah, 5
		xor	al, al
		int	10h		; - VIDEO - WRITE CHARACTER AND	ADVANCE	CURSOR (TTY WRITE)
					; AL = character, BH = display page (alpha modes)
					; BL = foreground color	(graphics modes)
		mov	si, XMMERRMSG ; "\r\nA20 Hardware Error\r\n$"
		push	cs
		pop	ds
		cld

XMMprnt:				; ...
		lodsb
		cmp	al, '$'
		jz	short XMMStall
		mov	ah, 0Eh
		mov	bx, 7
		int	10h		; - VIDEO -
		jmp	short XMMprnt
; ---------------------------------------------------------------------------

XMMStall:				; ...
		sti
		jmp	short XMMStall

; ---------------------------------------------------------------------------
OldInstanceJunk	dw 70h			; ...
		dw 0
		dw 6
OldInstanceJunk_6 dw 0			; ...
		dw CONTPOS
		dw 2
		dw 0
		dw BCON
		dw 4
		dw 0
		dw CARPOS
		dw 106h
		dw 0
		dw CHARCO
		dw 1
		dw 0
		dw exec_init_SP
		dw 34
		dw 70h
		dw 0Ch			; DOSBIODATASEG:ALTAH
		dw 1
DosHasHMA	db 0			; ...
FixExePatch	dw 0			; ...
RationalPatchPtr dw 0			; ...
; ---------------------------------------------------------------------------

RatBugCode:				; ...
		push	cx
		mov	cx, [FCBLRU]	; [10h]

rbc_loop:				; ...
		loop	rbc_loop
		pop	cx
		retf
; ---------------------------------------------------------------------------
UmbSave1	db 11 dup(0)		; ...
COUNTRY_CDPG	db 0, 0, 0, 0, 0, 0, 0,	0 ; ...
		db '\COUNTRY.SYS',0
		db 51 dup(0)
		dw 437
		dw 6
COUNTRY_CDPG_76	db 2			; ...
		dw UCASE_TAB
		dw 0
		db 4
		dw FILE_UCASE_TAB
		dw 0
		db 5
		dw FILE_CHAR_TAB
		dw 0
		db 6
		dw COLLATE_TAB
		dw 0
		db 7
		dw DBCS_TAB
		dw 0
		db 1
		dw 38			; NEW_COUNTRY_SIZE
		dw 1
		dw 437
COUNTRY_CDPG_108 dw 0			; ...
		db '$',0,0,0,0
		db ',',0,'.',0,'-',0,':',0
		db 0
		db 2
		db 0
		dw MAP_CASE
		dw 0
		db ',',0
		dw 0, 0, 0, 0, 0
XMMERRMSG	db 0Dh,0Ah		; ...
		db 'A20 Hardware Error',0Dh,0Ah,'$'
DOSP1_ID	db 36h,	0C5h, 36h
DOSP1_THISSFT	db 36h,	5, 0C5h, 74h, 7, 0E8h
		db 90h
		db 90h
DOSP12_ID	db 36h,	0C5h, 36h
DOSP12_THISSFT	db 36h,	5, 0C5h, 74h, 7, 0E8h
DOSP3_ID	db 51h,	6, 57h,	0BAh
DOSP3_CONBUF	db 29h,	2, 0E8h
		db 9Ah,	0E3h, 5Fh, 7
		db 59h
DOSP5_ID	db 51h
		db 0ACh, 3Ch, 1Ah, 74h,	5
		db 0E8h
DOSP7_ID	db 2Eh,	8Ch, 1Eh
DOSP7_SAVEDS	db 7Eh,	5
		db 2Eh,	89h, 1Eh
DOSP7_SAVEBX	db 7Ch,	5
		db 8Ch,	0CBh
		db 8Eh,	0DBh
		db 0FEh, 6
DOSP7_INDOS	db 0CFh, 2
		db 33h,	0C0h
DOSP8_ID	db 50h
		db 36h,	0A1h
DOSP8_USER_ID	db 0EAh, 2
		db 26h,	3Bh, 45h
		db 2Fh,	58h
DOSP10_ID	db 6, 1Fh
DOSP10_LOC	db 8Bh,	0DFh
		db 33h,	0C0h, 8Bh, 0D0h, 0E8h
		db 0DFh, 0Eh
		db 1Eh,	36h, 0C5h, 36h,	36h, 5,	0E8h, 0AFh, 0Eh
		db 8Bh,	0D7h, 0B4h, 86h, 36h, 8Bh, 3Eh
		db 9, 3
		db 0F7h, 0C7h, 0, 80h, 74h, 19h, 0E8h, 47h, 17h
		db 8Bh,	0FAh, 0Ah, 0C0h, 74h, 10h, 3Ch,	3, 74h,	3
		db 1Fh,	0EBh, 0CFh
		db 5Fh
		db 36h,	0C4h, 3Eh, 36h,	5, 0E9h, 0A1h, 4
		db 5Fh,	8Bh, 0FAh
DOSP13_ID	db 0ACh
		db 3Ch,	24h
		db 74h,	8
		db 0B3h, 7
		db 0B4h, 0Eh
		db 0CDh, 10h
		db 0EBh, 0F3h
		db 0EBh, 0FEh

; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
DOSDATAEND equ $
DOSDATASIZE equ DOSDATAEND - DOSDATASTART ; = 4962 for MSDOS 5.0 MSDOS.SYS
MSDAT001E equ DOSDATAEND - DOSDATASTART

;DOSDATALAST ENDS

; Retro DOS v4.0 by Erdogan Tan (Redevelopment of MSDOS 5.0 KERNEL via NASM)
; DECEMBER 2022, ISTANBUL - TURKIYE.
;============================================================================
;	END
;============================================================================
; Retro DOS v4.0 by Erdogan Tan (Redevelopment of MSDOS 6.21 KERNEL via NASM)
; -----------------------------
; MAY 2019, ISTANBUL - TURKIYE.