     1                                  ; ****************************************************************************
     2                                  ; IOSYS5.S (MSDOS 5.0 IO.SYS) - RETRO DOS v4.0 by ERDOGAN TAN - 01/10/2022
     3                                  ; ----------------------------------------------------------------------------
     4                                  ; Last Update: 29/09/2023 (Modified IO.SYS)  ((Previous: 17/09/2023))
     5                                  ; ----------------------------------------------------------------------------
     6                                  ; Beginning: 26/12/2018 (Retro DOS 4.0)
     7                                  ; ----------------------------------------------------------------------------
     8                                  ; Assembler: NASM version 2.15
     9                                  ; ----------------------------------------------------------------------------
    10                                  ;	   ((nasm iosys5.s -l iosys5.lst -o IOSYS5.BIN -Z error.txt)) 	
    11                                  ; ----------------------------------------------------------------------------
    12                                  
    13                                  ; 09/12/2022 - Multisection binary file format (BIOSDATA & BIOSCODE sections)
    14                                  ; 01/10/2022 - Erdogan Tan (Istanbul)
    15                                  
    16                                  ;Note: This code is a part of Retro DOS 4.0 kernel source code
    17                                  ;     (as included binary, 'IOSYS5.BIN') 
    18                                  ;     Equivalent of MSDOS 5.0 IO.SYS, BIOSCODE and BIOSDATA and SYSINIT
    19                                  ;						        (except MSLOAD code)  
    20                                        
    21                                  ;------ Retro DOS v2 (v3) boot sector loads RETRODOS.SYS (MSDOS.SYS)
    22                                  ;	at 1000h:0000h and loader (initialization) part of RETRODOS kernel
    23                                  ;	moves IO.SYS (DOSBIOSCODE & DOSBIOSDATA, 'IOSYS5.BIN') to 70h:0000h.
    24                                  ;	Then SYSINIT code to the next segment (46Dh for original MSDOS 5.0)..
    25                                  ;	SYSINIT code relocates itself and DOSBIOSCODE and MSDOS.SYS
    26                                  ;	(MSDOS5.BIN) according to request/setting in 'config.sys' file.
    27                                  
    28                                  ; ----------------------------------------------------------------------------
    29                                  
    30                                  ;bpbx		struc ;	(sizeof=0x19)	
    31                                  ;
    32                                  ;bytespersec	dw ?			; base 10
    33                                  ;secperclust	db ?			; base 10
    34                                  ;rsvdsecs	dw ?			; base 10
    35                                  ;numfats	db ?			; base 10
    36                                  ;rootdirents	dw ?			; base 10
    37                                  ;totalsize16	dw ?			; base 10
    38                                  ;mediaid	db ?
    39                                  ;fatsecs	dw ?			; base 10
    40                                  ;secpertrack	dw ?			; base 10
    41                                  ;heads		dw ?			; base 10
    42                                  ;hiddensecs_lw	dw ?			; base 10
    43                                  ;hiddensecs_hw	dw ?			; base 10
    44                                  ;totalsecs_lw	dw ?			; base 10
    45                                  ;totalsecs_hw	dw ?			; base 10
    46                                  ;
    47                                  ;bpbx		ends
    48                                  
    49                                  ;-----------------------------------------------------------------------------
    50                                  ;
    51                                  ; +-------------------------------------------------------------------------+
    52                                  ; |   This file	has been generated by The Interactive Disassembler (IDA)    |
    53                                  ; |	      Copyright	(c) 2013 Hex-Rays, <support@hex-rays.com>	    |
    54                                  ; |			 Licensed to: Freeware version			    |
    55                                  ; +-------------------------------------------------------------------------+
    56                                  ;
    57                                  ; Input	MD5   :	B2FA03653E5C5D545327EE28B8A24356
    58                                  ; Input	CRC32 :	20FC79BF
    59                                  
    60                                  ;-----------------------------------------------------------------------------
    61                                  
    62                                  ;		.386
    63                                  ;		.model flat
    64                                  
    65                                  ; ============================================================================
    66                                  
    67                                  ; 24/12/2022
    68                                  ; 22/12/2022
    69                                  ; 20/12/2022
    70                                  ; 18/12/2022
    71                                  ; 10/12/2022
    72                                  ; 09/12/2022
    73                                  ; 19/10/2022, 21/10/2022
    74                                  ; 17/10/2022, 18/10/2022
    75                                  ; 15/10/2022, 16/10/2022
    76                                  ; 03/10/2022
    77                                  ; 02/10/2022
    78                                  ; 01/10/2022 - Erdogan Tan
    79                                  
    80                                  ; [[ Most of comments here are from the original MSDOS 6.0 source code ]]
    81                                  
    82                                  ;-----------------------------------------------------------------------------
    83                                  ; Start of (MSDOS 5.0) IO.SYS (IBMBIO.COM)
    84                                  ;-----------------------------------------------------------------------------
    85                                  
    86                                  		[ORG 0]			; segment 0x0070h
    87                                  
    88                                  ; ----------------------------------------------------------------------------
    89                                  ; %include msload5.s	; 09/12/2022
    90                                  ; ----------------------------------------------------------------------------
    91                                  
    92                                  ;=============================================================================
    93                                  ; (IO.SYS) LOADER SECTION 
    94                                  ;=============================================================================
    95                                  ; 09/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
    96                                  ;non-contiguous io.sys loader (msload) ((MSDOS 6.0 source: MSLOAD.ASM, 1991))
    97                                  
    98                                  section .MSLOAD ; vstart=0 
    99                                  
   100                                  ; ****************************************************************************
   101                                  ; MSLOADS5.S (MSDOS 5.0 IO.SYS) - RETRO DOS v4.0 by ERDOGAN TAN - 01/10/2022
   102                                  ; ----------------------------------------------------------------------------
   103                                  ; Last Update: 25/12/2022 (Modified IO.SYS loader)  ((Previous: 22/12/2022))
   104                                  ; ----------------------------------------------------------------------------
   105                                  ; Beginning: 21/10/2022 (Retro DOS 4.0)
   106                                  ; ----------------------------------------------------------------------------
   107                                  ; Assembler: NASM version 2.15 
   108                                  ; ----------------------------------------------------------------------------
   109                                  ;	   ((nasm msload5.s -l msload5.lst -o MSLOAD5.BIN -Z error.txt)) 
   110                                  ; ----------------------------------------------------------------------------
   111                                  ; Converted to NASM source code from disassembled MSDOS 5.0 (IO.SYS) MSLOAD
   112                                  ; code by Erdogan Tan (disassembly: 18/09/2022, Converted source: 21/10/2022) 
   113                                  ; ----------------------------------------------------------------------------
   114                                  
   115                                  ; +-------------------------------------------------------------------------+
   116                                  ; |   This file	has been generated by The Interactive Disassembler (IDA)    |
   117                                  ; |	      Copyright	(c) 2013 Hex-Rays, <support@hex-rays.com>	    |
   118                                  ; |			 Licensed to: Freeware version			    |
   119                                  ; +-------------------------------------------------------------------------+
   120                                  ;
   121                                  ; Input	MD5   :	B2FA03653E5C5D545327EE28B8A24356
   122                                  ; Input	CRC32 :	20FC79BF
   123                                  
   124                                  ; ---------------------------------------------------------------------------
   125                                  ; File Name   :	C:\Users\Erdoðan\Desktop\IO.SYS
   126                                  ; Format      :	Binary file
   127                                  ; Base Address:	0000h Range: 0000h - 8296h Loaded length: 00008296h
   128                                  
   129                                  ;		.386
   130                                  ;		.model flat
   131                                  
   132                                  ; ===========================================================================
   133                                  
   134                                  ; 09/12/2022
   135                                  ; Comments are from MSDOS 6.0 MSLOAD.ASM (1991) & HEX-RAYS IDA disasm output
   136                                  
   137                                  ; ===========================================================================
   138                                  ;	NOTE: The boot loader should be verifying that the first
   139                                  ;	  block of io.sys is, in fact, at cluster 2. This would be saving
   140                                  ;	  a whole lot of time during system debugging.
   141                                  ;
   142                                  ;============================================================================
   143                                  ;
   144                                  ;     for dos 4.00, msload program has been changed to allow:
   145                                  ;	  1. 32 bit calculation,
   146                                  ;	  2. reading a fat sector when needed, instead of reading the whole
   147                                  ;	     fat sectors at once. this will make the boot time faster,
   148                                  ;	     and eliminate the memory size limitation problem,
   149                                  ;	  3. solving the limitation of the file size (29 kb) of io.sys0,
   150                                  ;	  4. adding the boot error message. show the same boot error message
   151                                  ;	     and do the same behavior when the read operation of io.sys
   152                                  ;	     fails as the msboot program, since msload program is the
   153                                  ;	     extention of msboot program.
   154                                  ;
   155                                  ; ===========================================================================
   156                                  
   157                                  ;
   158                                  ;----------------------------------------------------------------------------
   159                                  ;
   160                                  ; M056 : Added RPL support, so that RPL's fake INT 13 code can be safe from
   161                                  ;		SYSINIT & transient portion of COMMAND.COM
   162                                  ;
   163                                  ;----------------------------------------------------------------------------
   164                                  		
   165                                  		[ORG 0]			; segment 0x0070h
   166                                  
   167                                  START$:
   168 00000000 EB32                    		jmp	short SaveInputValues ; 14/09/2023
   169                                  		;nop	; 14/09/2023
   170                                  
   171                                  %if 0
   172                                  ; 20/12/2022
   173                                  ; 09/12/2022
   174                                  ; ---------------------------------------------------------------------------
   175                                  SysVersion:	dw 5			; expected_version	
   176                                  ;MyStacks:	db 256 dup(0)		; local stack
   177                                  ; 22/12/2022
   178                                  ; 20/12/2022
   179                                  ;MyStacks:	dw 102 dup(0)		; local stack
   180                                  NumHeads:	dw 0			; ...
   181                                  ClusterSize:	db 2 dup(0)		; ...
   182                                  StartSecL:	dw 0			; ...
   183                                  StartSecH:	dw 0			; ...
   184                                  TempH:		dw 0			; for 32 bit calculation
   185                                  TempCluster:	db 2 dup(0)		; temporary place for cluster number
   186                                  LastFatSector:	db 2 dup(0FFh)		; fat sec # start from 1st FAT entry
   187                                  SectorCount:	dw 0			; ...
   188                                  SecPerFat:	dw 0			; ...
   189                                  HiddenSectorsL:	dw 0			; ...
   190                                  HiddenSectorsH:	dw 0			; ...
   191                                  BytesPerSec:	dw 0			; ...
   192                                  ReservSectors:	db 2 dup(0)		; ...
   193                                  CurrentCluster:	db 2 dup(0)		; ...
   194                                  NextBioLocation: db 2 dup(0)		; ...
   195                                  FirstSectorL:	dw 0			; ...
   196                                  FirstSectorH:	dw 0			; ...
   197                                  TotalSectorsL:	dw 0			; max. number of sectors
   198                                  TotalSectorsH:	dw 0			; ...
   199                                  SecPerTrack:	db 2 dup(0)		; ...
   200                                  BootDrive:	db 0			; ...
   201                                  Fatsize:	db 0			; ...
   202                                  MediaByte:	db 0			; ...
   203                                  EndOfFile:	db 0			; ...
   204                                  OrgDasdPtr:	db 4 dup(0)		; ...
   205                                  FatSegment:	db 2 dup(0)		; ...
   206                                  SecPerCluster:	db 0			; ...
   207                                  ; ---------------------------------------------------------------------------
   208                                  %endif
   209                                  
   210                                  ; 14/09/2023
   211                                  ; 24/12/2022
   212                                  ; 23/12/2022
   213                                  ; 20/12/2022
   214                                  ; 09/12/2022
   215                                  ; ---------------------------------------------------------------------------
   216 00000002 0500                    SysVersion:	dw 5			; expected_version	
   217 00000004 0000                    ClusterSize:	dw 0
   218 00000006 0000                    StartSecL:	dw 0
   219 00000008 0000                    StartSecH:	dw 0
   220                                  ; 15/09/2023
   221                                  ;TempH:		dw 0			; for 32 bit calculation
   222                                  ;TempCluster:	dw 0
   223                                  ;ReservSectors:	dw 0
   224 0000000A FFFF                    LastFatSector:	dw 0FFFFh		; fat sec # start from 1st FAT entry
   225 0000000C 0000                    SectorCount:	dw 0
   226 0000000E 0000                    CurrentCluster:	dw 0	; *!*
   227 00000010 0000                    BytesPerSec:	dw 0
   228 00000012 0000                    SecPerCluster:	dw 0
   229                                  ;RootDirEntries: dw 0
   230 00000014 0000                    SecPerFat:	dw 0
   231 00000016 0000                    SecPerTrack:	dw 0
   232 00000018 0000                    NumHeads:	dw 0
   233                                  ; 14/09/2023
   234 0000001A 0000                    HiddenSectorsL: dw 0
   235 0000001C 0000                    HiddenSectorsH: dw 0
   236 0000001E 0000                    TotalSectorsL:	dw 0			; max. number of sectors
   237 00000020 0000                    TotalSectorsH:	dw 0
   238 00000022 0000                    FirstSectorL:	dw 0
   239 00000024 0000                    FirstSectorH:	dw 0
   240 00000026 00                      BootDrive:	db 0
   241 00000027 00                      Fatsize:	db 0
   242 00000028 00                      MediaByte:	db 0
   243 00000029 00                      EndOfFile:	db 0
   244 0000002A 00000000                OrgDasdPtr:	dd 0
   245 0000002E 0000                    FatStartSecL:	dw 0
   246 00000030 0000                    FatStartSecH:	dw 0
   247 00000032 0000                    FatSegment:	dw 0
   248                                  
   249                                  ; SaveInputValues
   250                                  ; ---------------------------------------------------------------------------
   251                                  ; INPUT:     none
   252                                  ;
   253                                  ;   dl = int 13 drive number we booted from
   254                                  ;   ch = media byte
   255                                  ;   bx = first data sector (low) on disk (0-based)
   256                                  ;   ds:si = original rom bios diskette parameter table.
   257                                  ;
   258                                  ; if an extended boot record, then ax will be the first data sector
   259                                  ; high word. save ax and set FirstSectorH according to ax if it is an
   260                                  ; extended boot record.
   261                                  ;
   262                                  ;   ax = first data sector (high) on disk ;
   263                                  ; OUTPUT:
   264                                  ;
   265                                  ;   bx = first data sector on disk
   266                                  ;
   267                                  ;   MediaByte = input ch
   268                                  ;   BootDrive = input dl
   269                                  ;   FirstSectorL = input bx
   270                                  ;   FirstSectorH = input AX, if an extended boot record.;j.k.
   271                                  ;   TotalSectorsL = maximum sector number in this media ;j.k.
   272                                  ;   TotalSectorsH = high word of the above
   273                                  ;   HiddenSectorsL = hidden secotrs
   274                                  ;   HiddenSectorsH
   275                                  ;   ReservSectors = reserved sectors
   276                                  ;   SecPerTrack = sectors/track
   277                                  ;   NumHeads = heads/cylinder
   278                                  ;
   279                                  ;   ds = 0
   280                                  ;   AX,DX,SI destroyed
   281                                  ;
   282                                  ; calls:     none
   283                                  ; ---------------------------------------------------------------------------
   284                                  ;FUNCTION:
   285                                  ; save input information and bpb informations from the boot record.
   286                                  ; ---------------------------------------------------------------------------
   287                                  
   288                                  Sec9 equ 522h
   289                                  ; 20/12/2022	
   290                                  DskAddr	equ 1Eh*4 ; 78h
   291                                  ; 22/12/2022
   292                                  ;StackPtr equ MyStacks+(NumHeads-MyStacks)
   293                                  
   294                                  ; ---------------------------------------------------------------------------
   295                                  
   296                                  		; 24/12/2022
   297                                  		; (registers from MSDOS 5.0 boot sector)
   298                                  		; ss = 0
   299                                  		; sp = 7C00h
   300                                  		; ds = 0
   301                                  		; es = 0
   302                                  		; ax:bx = absolute disk address for cluster 2 (data start)
   303                                  		; dl = [BootDrv] = [7C24h]
   304                                  		; ch = [MediaByte] = [7C15h]
   305                                  		; ds:si = rom bios disk(ette) params table address (INT 1Eh)
   306                                  		; 0:500h = root dir buffer (1st sector of the root dir)
   307                                  
   308                                  		; 14/09/2023
   309                                  SaveInputValues:
   310                                  		; 24/12/2022
   311 00000034 1E                      		push	ds
   312 00000035 0E                      		push	cs
   313 00000036 1F                      		pop	ds 
   314                                  		;mov	[cs:FirstSectorL], bx ; first data sector (low word)
   315                                  		;mov	[cs:MediaByte], ch
   316                                  		;mov	[cs:BootDrive], dl
   317                                  		;mov	[cs:OrgDasdPtr], si
   318                                  		;push	ds
   319                                  		;pop	word [cs:OrgDasdPtr+2]
   320 00000037 891E[2200]              		mov	[FirstSectorL], bx
   321 0000003B 891E[0600]              		mov	[StartSecL], bx ; **!**
   322 0000003F 882E[2800]              		mov	[MediaByte], ch
   323 00000043 8816[2600]              		mov	[BootDrive], dl
   324 00000047 8936[2A00]              		mov	[OrgDasdPtr], si
   325 0000004B 8F06[2C00]              		pop	word [OrgDasdPtr+2]
   326                                  
   327 0000004F 31C9                    		xor	cx, cx		; segment 0 (obviously)
   328 00000051 8ED9                    		mov	ds, cx		; ZERO
   329                                  		; 23/12/2022
   330                                  		; es = 0 (just before jumping to start of IO.SYS) 
   331                                  		;push	es ; !
   332                                  		;mov	es, cx
   333                                  		; es = 0
   334                                  		;mov	si, [DskAddr]	; 0000h:0078h (Int 1Eh)
   335                                  		;mov	ds, [DskAddr+2]	; DS:SI -> current table
   336                                  		; 20/12/2022
   337 00000053 BE2205                  		mov	si, Sec9
   338 00000056 89F7                    		mov	di, si
   339 00000058 87367800                		xchg	si, [DskAddr]
   340 0000005C 870E7A00                		xchg	cx, [DskAddr+2]
   341 00000060 8ED9                    		mov	ds, cx
   342                                  		;mov	di, Sec9	; 522h  ; ES:DI -> new table
   343 00000062 B90B00                  		mov	cx, 11			; taken from ibmboot.asm
   344 00000065 FC                      		cld
   345 00000066 F3A4                    		rep movsb		; copy table
   346                                  		;push	es
   347                                  		;pop	ds		; ds = 0
   348                                  		; 20/12/2022
   349 00000068 8ED9                    		mov	ds, cx ; 0
   350                                  		;mov	word [DskAddr], Sec9 ; 522h
   351                                  		;mov	[DskAddr+2], ds	; point disk parm vector to new table
   352                                  		; 23/12/2022
   353                                  		;pop	es ; !
   354                                  		; es = 0
   355                                  		; ds = 0
   356                                  		; ss = 0
   357                                  ; 24/12/2022
   358                                  %if 0
   359                                  		mov	cx, [7C0Bh] 	; BootSector.ext_boot_bpb.BPB_bytespersector
   360                                  		mov	[cs:BytesPerSec], cx
   361                                  		mov	cl, [7C0Dh]	; BootSector.ext_boot_bpb.BPB_sectorspercluster
   362                                  		mov	[cs:SecPerCluster], cl
   363                                  		mov	cx, [7C18h]	; BootSector.ext_boot_bpb.BPB_sectorspertrack	
   364                                  		mov	[cs:SecPerTrack], cx
   365                                  		mov	cx, [7C1Ah]	; BootSector.ext_boot_bpb.BPB_heads
   366                                  		mov	[cs:NumHeads], cx
   367                                  		mov	cx, [7C16h]	; BootSector.ext_boot_bpb.BPB_sectorsperfat
   368                                  		mov	[cs:SecPerFat], cx
   369                                  		mov	cx, [7C0Eh]	; BootSector.ext_boot_bpb.BPB_reservedsectors	
   370                                  		mov	[cs:ReservSectors], cx
   371                                  		mov	cx, [7C1Ch]	; BootSector.ext_boot_bpb.BPB_hiddensectors
   372                                  		mov	[cs:HiddenSectorsL], cx
   373                                  		mov	cx, [7C13h]	; BootSector.ext_boot_bpb.BPB_totalsectors
   374                                  		mov	[cs:TotalSectorsL], cx
   375                                  
   376                                  		; First of all, check if it the boot record is an extended one.
   377                                  		; This is just a safe guard in case some user just "copy" the
   378                                  		; 4.00 iosys.com to a media with a conventional boot record.
   379                                  
   380                                  		; 22/12/2022
   381                                  		cmp	byte [7C26h], 29h ; ext_boot_signature
   382                                  		jne	short relocate
   383                                  		mov	[cs:FirstSectorH], ax ; first data sector (high word)
   384                                  		mov	ax, [7C1Eh]
   385                                  		mov	[cs:HiddenSectorsH], ax
   386                                  		; 10/12/2022
   387                                  		or	cx, cx
   388                                  		;cmp	cx, 0		; cx set already before (=totalsectors)
   389                                  		; 22/12/2022
   390                                  		jnz	short relocate
   391                                  		mov	ax, [7C20h]	; BootSector.ext_boot_bpb.BPB_bigtotalsectors
   392                                  		mov	[cs:TotalSectorsL], ax
   393                                  		mov	ax, [7C22h]	; BootSector.ext_boot_bpb.BPB_bigtotalsectors+2
   394                                  		mov	[cs:TotalSectorsH], ax
   395                                  %endif
   396                                  		; 14/09/2023
   397 0000006A 89C5                    		mov	bp, ax  ; first data sector (high word)
   398                                  		
   399 0000006C 0E                      		push	cs
   400 0000006D 07                      		pop	es
   401                                  
   402                                  		;mov	ax, [BioSStart]
   403 0000006E A11A05                  		mov	ax, [51Ah]	; IO.SYS First Cluster
   404 00000071 48                      		dec	ax		; Root dir buffer at 500h (segment=0)
   405                                  					; IO.SYS first cluster ptr at 51Ah
   406 00000072 48                      		dec	ax		; AX = word [51Ah] - 2
   407 00000073 BF[0E00]                		mov	di, CurrentCluster		
   408 00000076 AB                      		stosw			;  Initialize to this cluster
   409                                  
   410 00000077 BE0B7C                  		mov	si, 07C0Bh	; boot sector's bpb, BytesPerSector
   411                                  		;mov	di, BytesPerSec
   412 0000007A A5                      		movsw	; BytesPerSec
   413 0000007B A4                      		movsb	; SecPerCluster
   414 0000007C 47                      		inc	di ; skip high byte of SecPerCluster word (it is 0)
   415 0000007D AD                      		lodsw	; ReservSectors
   416 0000007E 50                      		push	ax ; * ; ReservSectors
   417 0000007F AC                      		lodsb	; skip NumFats
   418                                  		;movsw	; RootDirEntries ; !
   419 00000080 AD                      		lodsw	; skip RootDirEntries ; !
   420 00000081 AD                      		lodsw	; TotalSectorsL
   421                                  		; 14/09/2023
   422 00000082 50                      		push	ax ; ** ; TotalSectorsL
   423 00000083 AC                      		lodsb	; skip MediaByte
   424 00000084 A5                      		movsw	; SecPerFat
   425 00000085 A5                      		movsw 	; SecPerTrack
   426 00000086 A5                      		movsw	; NumHeads
   427 00000087 A5                      		movsw	; HiddenSectorsL
   428 00000088 AD                      		lodsw	; HiddenSectorsH
   429 00000089 89C2                    		mov	dx, ax ; HiddenSectorsH in dx
   430 0000008B AD                      		lodsw	
   431 0000008C 89C1                    		mov	cx, ax ; BigTotalSecs lw in cx
   432 0000008E AD                      		lodsw
   433 0000008F 89C3                    		mov	bx, ax ; BigTotalSecs hw in bx
   434 00000091 AD                      		lodsw	; skip BootDrv and CurrentHead
   435                                   
   436                                  		; 14/09/2023
   437 00000092 AC                      		lodsb	; ext_boot_signature
   438                                  
   439 00000093 0E                      		push	cs
   440 00000094 1F                      		pop	ds
   441                                  
   442 00000095 3C29                    		cmp	al, 29h  ; is it ext_boot_signature ?
   443 00000097 58                      		pop	ax ; ** ; TotalSectorsL (16 bit total sectors)
   444 00000098 7407                    		je	short ext_boot_sec_1 ; yes, use high words
   445                                  
   446                                  		; (old boot sector ?)
   447                                  		; (zero high words, do not use them)
   448 0000009A 47                      		inc	di ; skip HiddenSectorsH (it is already zero)	
   449 0000009B 47                      		inc	di
   450 0000009C AB                      		stosw	; TotalSectorsL
   451                                  			; (TotalSectorsH = 0)
   452 0000009D 31D2                    		xor	dx, dx ; 0 ; HiddenSectorsH
   453 0000009F EB15                    		jmp	short set_fat_start
   454                                  ext_boot_sec_1:
   455                                  		; 14/09/2023
   456 000000A1 92                      		xchg	ax, dx
   457 000000A2 AB                      		stosw	; HiddenSectorsH
   458 000000A3 92                      		xchg	dx, ax
   459                                  			; dx = HiddenSectorsH, ax = TotalSectorsL
   460                                  		; 24/12/2022
   461 000000A4 09C0                    		or	ax, ax  ; TotalSectorsL (16 bit total sectors)
   462 000000A6 7505                    		jnz	short ext_boot_sec_2 ; (*)
   463                                  
   464                                  		; 14/09/2023
   465                                  		; (32 bit total sectors)
   466 000000A8 89C8                    		mov	ax, cx ; BigTotalSecs lw 
   467 000000AA AB                      		stosw	; TotalSectorsL	
   468 000000AB 89D8                    		mov	ax, bx ; BigTotalSecs hw
   469                                  ext_boot_sec_2:
   470 000000AD AB                      		stosw	; TotalSectorsH or TotalSectorsL (*)
   471                                  		; bp = 1st data sector hw
   472 000000AE 892E[2400]              		mov	[FirstSectorH], bp
   473 000000B2 892E[0800]              		mov	[StartSecH], bp ; **!**	
   474                                  
   475                                  set_fat_start:
   476                                  		; 14/09/2023
   477 000000B6 31FF                    		xor	di, di
   478 000000B8 58                      		pop	ax ; * ReservSectors 
   479 000000B9 0306[1A00]              		add	ax, [HiddenSectorsL]
   480                                  		; dx = [HiddenSectorsH]
   481                                  		;adc	dx, 0
   482 000000BD 11FA                    		adc	dx, di ; 0
   483                                  
   484                                  		;mov	di, FatStartSecL
   485                                  		;stosw
   486                                  		;mov	ax, dx
   487                                  		;stosw		
   488                                  
   489 000000BF A3[2E00]                		mov	[FatStartSecL], ax
   490 000000C2 8916[3000]              		mov	[FatStartSecH], dx
   491                                  	
   492                                  ; Relocate
   493                                  ; -------------------------------------------------------------------------
   494                                  ;
   495                                  ; NOTES:
   496                                  ;
   497                                  ;   Relocates the loader code to top-of-memory.
   498                                  ;
   499                                  ; INPUT:     none
   500                                  ;
   501                                  ; OUTPUT:    code and data relocated.
   502                                  ;	     AX,CX,SI,DI destroyed
   503                                  ;
   504                                  ; calls:     none
   505                                  ; -------------------------------------------------------------------------
   506                                  ;
   507                                  ; Determine the number of paragraphs (16 byte blocks) of memory.
   508                                  ; this involves invoking the memory size determination interrupt,
   509                                  ; which returns the number of 1k blocks of memory, and then
   510                                  ; converting this to the number of paragraphs.
   511                                  ; Find out whether RPL code is present at top of memory and modify the
   512                                  ; available amount of memory in AX
   513                                  ; leave the number of paragraphs of memory in ax.
   514                                  ;
   515                                  ; -------------------------------------------------------------------------
   516                                  ; copy code from start to top of memory.
   517                                  ;
   518                                  ; the length to copy is EndOfLoader
   519                                  ;
   520                                  ; jump to relocated code
   521                                  ; -------------------------------------------------------------------------
   522                                  
   523                                  		; 14/09/2023
   524                                  relocate:
   525                                  		; 24/12/2022
   526                                  		;cld
   527                                  
   528 000000C6 31F6                    		xor	si, si
   529                                  		; 14/09/2023
   530                                  		;mov	di, si
   531                                  		; di = 0
   532                                  
   533 000000C8 CD12                    		int	12h		; MEMORY SIZE -
   534                                  					; Return: AX = number of contiguous 1K blocks of memory
   535 000000CA B106                    		mov	cl, 6
   536 000000CC D3E0                    		shl	ax, cl		; Memory size in paragraphs
   537                                  
   538                                  ;------ Check if an RPL program is present at TOM and do not tromp over it
   539                                  
   540                                  		; 10/12/2022
   541                                  		; ds = 0
   542                                  		; 24/12/2022
   543                                  		; ds = cs
   544                                  		;xor	bx, bx
   545                                  		;mov	ds, bx		; ZERO
   546                                  		; 14/09/2023
   547 000000CE 8EDE                    		mov	ds, si ; 0
   548                                  		
   549                                  		;mov	bx, [DskAddr+44h] ; 2Fh*4 (Int 2Fh)
   550                                  		;mov	ds, [DskAddr+46h] ; 2Fh*4+2
   551                                  		; 10/12/2022
   552 000000D0 8B1EBC00                		mov	bx, [2Fh*4]	; (Int 2Fh)
   553 000000D4 8E1EBE00                		mov	ds, [2Fh*4+2]		
   554                                  
   555                                  		;cmp	word ptr [bx+3], 'PR'
   556                                  		; 09/12/2022
   557 000000D8 817F035250              		cmp	word [bx+3], 'RP' ; 'RPL'
   558 000000DD 750F                    		jnz	short Skip_RPL
   559 000000DF 807F054C                		cmp	byte [bx+5], 'L'
   560 000000E3 7509                    		jnz	short Skip_RPL
   561 000000E5 89C2                    		mov	dx, ax		; get TOM into DX
   562 000000E7 B8064A                  		mov	ax, 4A06h	; (multMULT shl	8) + multMULTRPLTOM
   563 000000EA CD2F                    		int	2Fh		; Get new TOM from any RPL
   564 000000EC 89D0                    		mov	ax, dx
   565                                  Skip_RPL:
   566                                  		; 24/12/2022
   567 000000EE 0E                      		push	cs
   568 000000EF 1F                      		pop	ds	; 25/12/2022
   569                                  
   570 000000F0 B104                    		mov	cl, 4
   571 000000F2 8B16[1000]              		mov	dx, [BytesPerSec] ; 24/12/2022
   572                                  		;mov	dx, [cs:BytesPerSec]
   573 000000F6 D3EA                    		shr	dx, cl
   574 000000F8 42                      		inc	dx
   575 000000F9 29D0                    		sub	ax, dx
   576 000000FB A3[3200]                		mov	[FatSegment], ax ; 24/12/2022
   577                                  		;mov	[cs:FatSegment], ax ; This will be used for fat sector
   578                                  		; 22/12/2022
   579                                  		;mov	dx, EndOfLoader
   580 000000FE BA[9004]                		mov	dx, EndOfLoader+256
   581                                  				; loader size + temporary/local stack space (*)
   582 00000101 D3EA                    		shr	dx, cl
   583 00000103 42                      		inc	dx
   584 00000104 29D0                    		sub	ax, dx
   585 00000106 8EC0                    		mov	es, ax	; ES:DI -> place be relocated.
   586                                  		; 22/12/2022
   587 00000108 4A                      		dec	dx
   588 00000109 D3E2                    		shl	dx, cl	; convert paragraphs to bytes (*)	
   589                                  				; (stack pointer will be set to this offset)
   590                                  		; 24/12/2022
   591                                  		;push	cs
   592                                  		;pop	ds		; DS:SI -> source
   593                                  
   594 0000010B B9[9003]                		mov	cx, EndOfLoader
   595 0000010E F3A4                    		rep movsb
   596                                  
   597 00000110 06                      		push	es
   598 00000111 B8[1601]                		mov	ax, SetupStack
   599 00000114 50                      		push	ax		; Massage stack for destin of CS:IP
   600 00000115 CB                      		retf
   601                                  ; ---------------------------------------------------------------------------
   602                                  
   603                                  ; Start of relocated code
   604                                  ;----------------------------------------------------------------------------
   605                                  ;
   606                                  ; Move the stack to just under the boot record and relocation area (0:7c00h)
   607                                  ;
   608                                  
   609                                  SetupStack:	
   610                                  		; 22/12/202		; ...
   611                                  		;mov	ax, cs		; Start	of relocated code
   612                                  		;mov	ss, ax
   613                                  		;;mov	sp, NumHeads	; StackPtr offset
   614                                  		; 20/12/2022
   615                                  		;mov	sp, StackPtr	; StackPtr offset
   616                                  		
   617                                  ; 22/12/2022
   618                                  ; (set a temporary stack just above the relocated loader code)
   619                                  ; ((instead of using/reserving 256 bytes of stack space in 'IO.SYS' file))
   620                                  
   621                                  		; 22/12/2022
   622                                  		; cs = loader segment (relocated)
   623                                  		; dx = loader size + stack space (*) -paragraph aligned-
   624                                  
   625                                  		;cli
   626 00000116 8CC8                    		mov	ax, cs
   627 00000118 8ED8                    		mov	ds, ax	; 24/12/2022
   628 0000011A FA                      		cli 
   629 0000011B 8ED0                    		mov	ss, ax
   630 0000011D 89D4                    		mov	sp, dx	; (*)
   631 0000011F FB                      		sti
   632                                  
   633                                  ; FindClusterSize
   634                                  ; ---------------------------------------------------------------------------
   635                                  ;
   636                                  ; INPUT:     bpb information in loaded boot record at 0:7c00h
   637                                  ;
   638                                  ; OUTPUT:
   639                                  ;
   640                                  ;	ds = 0
   641                                  ;	ax = bytes/cluster
   642                                  ;	bx = sectors/cluster
   643                                  ;	si destroyed
   644                                  ; calls:     none
   645                                  ;----------------------------------------------------------------------------
   646                                  ;
   647                                  ; get bytes/sector from bpb
   648                                  ;
   649                                  ; get sectors/cluster from bpb
   650                                  ;
   651                                  ; bytes/cluster = bytes/sector * sector/cluster
   652                                  ; ---------------------------------------------------------------------------
   653                                  
   654                                  FindClusterSize:
   655                                  
   656                                  ;for the time being just ASSUME the boot record is valid and the bpb is there.
   657                                  
   658                                  		; 24/12/2022
   659                                  		; ds = cs
   660                                  		;xor	ax, ax
   661                                  		;mov	ds, ax
   662                                  		;mov	ax, [7C0Bh]	; get bpb bytes/sector
   663                                  		; 24/12/2022
   664 00000120 A1[1000]                		mov	ax, [BytesPerSec]
   665                                  		;xor	bx, bx
   666                                  		;mov	bl, [7C0Dh]	; get sectors/cluster
   667                                  		;mul	bx
   668 00000123 F726[1200]              		mul	word [SecPerCluster]
   669                                  		;mov	[cs:ClusterSize], ax
   670                                  		; 24/12/2022
   671 00000127 A3[0400]                		mov	[ClusterSize], ax
   672                                  
   673                                  ; CalcFatSize
   674                                  ; ---------------------------------------------------------------------------
   675                                  ;
   676                                  ; NOTES:
   677                                  ;
   678                                  ;   Determine if fat is 12 or 16 bit fat. 12 bit fat if floppy, read mbr
   679                                  ;   to find out what system id byte is.
   680                                  ;
   681                                  ; INPUT:
   682                                  ;
   683                                  ; OUTPUT:
   684                                  ;
   685                                  ;   CS:FatSize = FAT_12_BIT or FAT_16_BIT
   686                                  ;   all other registers destroyed
   687                                  ;
   688                                  ; ---------------------------------------------------------------------------
   689                                  
   690                                  CalcFatSize:
   691                                  		; 14/09/2023
   692                                  		; 24/12/2022
   693                                  		; ds = cs
   694 0000012A C606[2700]01            		mov	byte [Fatsize], 1
   695                                  		;mov	byte [cs:Fatsize], 1 ; FAT_12_BIT (assume)
   696                                  		;mov	dx, [cs:TotalSectorsH]
   697                                  		;mov	ax, [cs:TotalSectorsL] ; DX:AX = total disk sectors
   698 0000012F 8B16[2000]              		mov	dx, [TotalSectorsH]
   699 00000133 A1[1E00]                		mov	ax, [TotalSectorsL] ; DX:AX = total disk sectors
   700                                  ; 24/12/2202
   701                                  %if 0
   702                                  		sub	ax, [ReservSectors]
   703                                  		;sub	ax, [cs:ReservSectors]
   704                                  		sbb	dx, 0		; DX:AX	= Total	avail sectors
   705                                  		;mov	bx, [cs:SecPerFat]
   706                                  		mov	bx, [SecPerFat]
   707                                  		shl	bx, 1		; (Assume 2 FATs)
   708                                  		sub	ax, bx
   709                                  		sbb	dx, 0
   710                                  		;mov	bx, [7C11h]	; Root directory entry count
   711                                  		mov	bx, [RootDirEntries]
   712                                  		mov	cl, 4
   713                                  		shr	bx, cl		; BX = Total directory sectors
   714                                  		sub	ax, bx
   715                                  		sbb	dx, 0		; DX:AX	= Sectors in data area
   716                                  %endif
   717                                  		; 14/09/2023 (BugFix)
   718 00000136 8B1E[2200]              		mov	bx, [FirstSectorL]
   719 0000013A 8B0E[2400]              		mov	cx, [FirstSectorH]
   720                                  		; ! here, cx:bx includes hidden sectors (partition start address) !
   721 0000013E 2B1E[1A00]              		sub	bx, [HiddenSectorsL]
   722 00000142 1B0E[1C00]              		sbb	cx, [HiddenSectorsH] ; cx:bx = start of data from boot sector
   723                                  
   724                                  		; 24/12/2022
   725                                  		;sub	ax, [FirstSectorL] ; total sectors - start of data
   726                                  		;sbb	dx, [FirstSectorH]
   727                                  		; 14/09/2023
   728 00000146 29D8                    		sub	ax, bx
   729 00000148 19CA                    		sbb	dx, cx
   730                                  				; DX:AX	= Sectors in data area
   731                                  		;;;
   732                                  		;xor	cx, cx
   733                                  		;mov	cl, [7C0Dh]	; Sectors per cluster
   734 0000014A 8B0E[1200]              		mov	cx, [SecPerCluster] ; *#*
   735 0000014E 50                      		push	ax
   736 0000014F 89D0                    		mov	ax, dx
   737 00000151 31D2                    		xor	dx, dx
   738 00000153 F7F1                    		div	cx  ; *#*
   739                                  		; 24/12/2022
   740                                  		;;mov	[cs:TempH], ax	; AX = Total number of clusters
   741                                  		;mov	[TempH], ax
   742 00000155 58                      		pop	ax
   743 00000156 F7F1                    		div	cx  ; *#*
   744 00000158 3DF60F                  		cmp	ax, 4086	; 4096-10
   745 0000015B 7205                    		jb	short ReadInFirstClusters ; 12 bit FAT
   746                                  		;mov	byte [cs:Fatsize], 4 ; FAT_16_BIT
   747 0000015D C606[2700]04            		mov	byte [Fatsize], 4 ; FAT_16_BIT
   748                                  
   749                                  ; ReadInFirstClusters
   750                                  ; ---------------------------------------------------------------------------
   751                                  ;
   752                                  ; NOTES: read the start of the clusters that covers at least IbmLoadSize
   753                                  ;	 fully.  for example, if sector/cluster = 2, and IbmLoadSize=3
   754                                  ;	 then we are going to re-read the second cluster to fully cover
   755                                  ;	 msload program in the cluster boundary.
   756                                  ;
   757                                  ; INPUT:
   758                                  ;   IbmLoadSize - make sure this value is the same as the one in
   759                                  ;		  msboot program when you build the new version!!!!!
   760                                  ;
   761                                  ;   SecPerCluster
   762                                  ;   ClusterSize
   763                                  ;   FirstSectorL
   764                                  ;   FirstSectorH
   765                                  ;
   766                                  ; OUTPUT: msload program is fully covered in a cluster boundary.
   767                                  ;	  ax = # of clusters we read in so far.
   768                                  ;
   769                                  ; calls:     ReadSectors
   770                                  ; logic:
   771                                  ;	ax; dx = IbmLoadSize / # of sector in a cluster.
   772                                  ;	if dx = 0 then ok. (msload is in a cluster boundary.)
   773                                  ;      else		   (has to read (ax+1)th cluster to cover msload)
   774                                  ;	read (ax+1)th cluster into the address after the clusters we
   775                                  ;	read in so far.
   776                                  ; ---------------------------------------------------------------------------
   777                                  
   778                                  ; 09/12/2022
   779                                  ; BiosStart equ 51Ah ; AX = IO.SYS starting cluster
   780                                  ; IbmLoadSize equ 3  ; AX = Number sectors in MSLOAD
   781                                  ; BiosOffset equ 700h ; Address where loader was read in
   782                                  	
   783                                  ReadInFirstClusters:
   784                                  		; 24/12/2022
   785                                  		;;mov	ax, [BioSStart]
   786                                  		;mov	ax, [51Ah]	; IO.SYS First Cluster
   787                                  		;dec	ax		; Root dir buffer at 500h (segment=0)
   788                                  		;			; IO.SYS first cluster ptr at 51Ah
   789                                  		;dec	ax		; AX = word [51Ah] - 2
   790                                  		;;mov	[cs:CurrentCluster], ax ;  Initialize to this cluster
   791                                  		; 24/12/2022
   792                                  		; ds = cs
   793                                  		;mov	[CurrentCluster], ax
   794                                  		; 24/12/2022
   795                                  		; [CurrentCluster] = word [51Ah] - 2
   796                                  
   797                                  		;mov	ax, IbmLoadSize
   798 00000162 B80300                  		mov	ax, 3		; Load the 3rd and other IO.SYS	sectors
   799 00000165 F6F1                    		div	cl ; *#*
   800                                  		;div	byte [SecPerCluster]
   801                                  		;;div	byte [cs:SecPerCluster]
   802                                  					; AL = total cluster read in
   803                                  					; AH = remaining sectors in last cluster
   804                                  		; 10/12/2022
   805 00000167 20E4                    		and	ah, ah
   806                                  		;cmp	ah, 0
   807 00000169 7433                    		jz	short SetNextClusterNum	; next cluster
   808                                  
   809 0000016B 30E4                    		xor	ah, ah
   810 0000016D 50                      		push	ax		; AX = total clusters in the loader
   811                                  					; already read in
   812                                  ; 24/12/2022
   813                                  %if 0		
   814                                  		mov	cx, [cs:FirstSectorL] ;	Put starting sector of disk data
   815                                  		mov	[cs:StartSecL], cx    ; area in StartSecH:StartSecL
   816                                  		mov	cx, [cs:FirstSectorH]
   817                                  		mov	[cs:StartSecH], cx
   818                                  		mul	byte [cs:SecPerCluster]
   819                                  		add	[cs:StartSecL], ax ; Add number of sectors already loaded
   820                                  		adc	word [cs:StartSecH], 0 ; to start sector
   821                                  		;mov	ax, [BiosStart]
   822                                  		mov	ax, [51Ah] ; AX = [51Ah] = IO.SYS 1st clust
   823                                  		dec	ax
   824                                  		dec	ax
   825                                  		xor	bx, bx
   826                                  		mov	bl, [cs:SecPerCluster]
   827                                  		mul	bx		; DX:AX = logical start sector
   828                                  		add	[cs:StartSecL], ax
   829                                  		adc	[cs:StartSecH], dx
   830                                  					; abs start sector for next read of
   831                                  					; the rest of the last loader cluster
   832                                  		pop	ax
   833                                  		push	ax
   834                                  		mul	word [cs:ClusterSize]
   835                                  		;mov	di, BiosOffset
   836                                  		mov	di, 700h	; IO.SYS offset	(segment = 0)
   837                                  		add	di, ax
   838                                  		xor	ax, ax
   839                                  		mov	es, ax		; ES = segment 0
   840                                  		mov	al, [cs:SecPerCluster]
   841                                  					; Read in the entire last cluster
   842                                  		mov	[cs:SectorCount], ax
   843                                  		call	ReadSectors
   844                                  		pop	ax		; AX = total clust read	by boot	loader
   845                                  		inc	ax		; AX = total clust read	in now
   846                                  SetNextClusterNum:			; ...
   847                                  		inc	ax		; AX = total clusters read in based 2
   848                                  		add	[cs:CurrentCluster], ax
   849                                  		dec	ax		; CurrentCluster = Last	cluster	read
   850                                  					; AX = number of clusters loaded
   851                                  %endif
   852                                  		; 24/12/2022
   853                                  		; ds =cs
   854                                  		;mov	cx, [FirstSectorL] ; Put starting sector of disk data
   855                                  		;mov	[StartSecL], cx    ; area in StartSecH:StartSecL
   856                                  		;mov	cx, [cs:FirstSectorH]
   857                                  		;mov	[StartSecH], cx
   858                                  		; [StartSecL] = [FirstSectorL] ; **!**
   859                                  		; [StartSecH] = [FirstSectorH] ; **!**
   860                                  		
   861                                  		; 24/12/2022
   862                                  		; cx = [SecPerCluster]  ; *#*
   863                                  
   864                                  		;mul	byte [SecPerCluster]
   865 0000016E F6E1                    		mul	cl ; *#*
   866 00000170 0106[0600]              		add	[StartSecL], ax ; Add number of sectors already loaded
   867 00000174 8316[0800]00            		adc	word [StartSecH], 0 ; to start sector
   868                                  
   869                                  		;mov	ax, [51Ah] ; AX = [51Ah] = IO.SYS 1st clust
   870                                  		;dec	ax
   871                                  		;dec	ax
   872 00000179 A1[0E00]                		mov	ax, [CurrentCluster]
   873                                  		; ax = word [51Ah] - 2
   874                                  		
   875                                  		;;xor	bx, bx
   876                                  		;;mov	bl, [SecPerCluster]
   877                                  		;mov	bx, [SecPerCluster]
   878                                  		;mul	bx		; DX:AX = logical start sector
   879 0000017C F7E1                    		mul	cx  ; [SecPerCluster]  ; *#*
   880                                  
   881 0000017E 0106[0600]              		add	[StartSecL], ax
   882 00000182 1116[0800]              		adc	[StartSecH], dx
   883                                  					; abs start sector for next read of
   884                                  					; the rest of the last loader cluster
   885 00000186 58                      		pop	ax
   886 00000187 50                      		push	ax
   887 00000188 F726[0400]              		mul	word [ClusterSize]
   888                                  		;mov	di, BiosOffset
   889 0000018C BF0007                  		mov	di, 700h	; IO.SYS offset	(segment = 0)
   890 0000018F 01C7                    		add	di, ax
   891 00000191 31C0                    		xor	ax, ax
   892 00000193 8EC0                    		mov	es, ax		; ES = segment 0
   893                                  		; 24/12/2022
   894                                  		;mov	al, [SecPerCluster]
   895                                  		;			; Read in the entire last cluster
   896                                  		;mov	[SectorCount], ax
   897 00000195 890E[0C00]              		mov	[SectorCount], cx ; [SecPerCluster]  ; *#*
   898                                  		
   899 00000199 E86700                  		call	ReadSectors
   900 0000019C 58                      		pop	ax		; AX = total clust read	by boot	loader
   901 0000019D 40                      		inc	ax		; AX = total clust read	in now
   902                                  SetNextClusterNum:			; ...
   903 0000019E 40                      		inc	ax		; AX = total clusters read in based 2
   904 0000019F 0106[0E00]              		add	[CurrentCluster], ax
   905 000001A3 48                      		dec	ax		; CurrentCluster = Last	cluster	read
   906                                  					; AX = number of clusters loaded
   907                                  		
   908                                  ; SaveLoadedBios
   909                                  ; ---------------------------------------------------------------------------
   910                                  ;
   911                                  ; NOTES:
   912                                  ;
   913                                  ;   Determine how much of iosys was loaded in when the loader was loaded
   914                                  ;   by the boot record (only the portion that is guaranteed to be contiguous)
   915                                  ;
   916                                  ; INPUT:
   917                                  ;   AX:Total cluster already read in (loader & bios)
   918                                  ;   CS:CurrentCluster = number of clusters used for loader+2
   919                                  ;
   920                                  ; OUTPUT:
   921                                  ;	ES = 70h
   922                                  ;	DI = next offset to load iosys code
   923                                  ;	AX,BX,CX,DX,SI destroyed
   924                                  ;
   925                                  ;	CS:NextBioLocation = di on output
   926                                  ;	CS:last_cluster = last cluster loaded
   927                                  ;
   928                                  ; calls:     none
   929                                  ;
   930                                  ; ---------------------------------------------------------------------------
   931                                  ;
   932                                  ; Multiply cluster * cluster size in bytes to get total loaded for msload
   933                                  ;
   934                                  ; Subtract total_loaded - (EndOfLoader) to get loaded io.sys in last cluster
   935                                  ;
   936                                  ; Relocate this piece of iosys down to 70:0
   937                                  ;
   938                                  ; ---------------------------------------------------------------------------
   939                                  
   940                                  SaveLoadedBios:
   941 000001A4 1E                      		push	ds
   942                                  		; 24/12/2022
   943                                  		; ds = cs
   944                                  		; ax = number of loaded clusters
   945 000001A5 F726[0400]              		mul	word [ClusterSize]
   946                                  		;mul	word [cs:ClusterSize]
   947                                  					; Get total bytes loaded by
   948                                  					; this is always < 64k, so
   949                                  					; lower 16 bits ok
   950                                  
   951 000001A9 2D[9003]                		sub	ax, EndOfLoader ; (OFFSET EndOfLoader)-(OFFSET Start)
   952 000001AC 89C1                    		mov	cx, ax
   953 000001AE B87000                  		mov	ax, 70h		; Segment at 70h
   954 000001B1 8ED8                    		mov	ds, ax
   955 000001B3 8EC0                    		mov	es, ax
   956 000001B5 BE[9003]                		mov	si, EndOfLoader ; EndOfLoader
   957 000001B8 31FF                    		xor	di, di
   958 000001BA F3A4                    		rep movsb		; Relocate this code to 0070h:0000h
   959                                  		;mov	[NextBioLocation], di
   960                                  		;;mov	[cs:NextBioLocation], di
   961                                  
   962                                  		; es:di = (the next) buffer address for next read
   963                                  
   964 000001BC 1F                      		pop	ds		; Save where location for next read
   965                                  
   966                                  ; GetContigClusters
   967                                  ; ---------------------------------------------------------------------------
   968                                  ;
   969                                  ; NOTES: go find clusters as long as they are contiguous
   970                                  ;
   971                                  ;
   972                                  ; INPUT:
   973                                  ;   CS:NextBioLocation
   974                                  ;   CS:
   975                                  ;
   976                                  ; OUTPUT:
   977                                  ;
   978                                  ; calls: GetNextFatEntry
   979                                  ; ---------------------------------------------------------------------------
   980                                  ;
   981                                  ;Set CS:SectorCount to sectors per cluster
   982                                  ;
   983                                  ;Call GetNextFatEntry to get next cluster in file
   984                                  ;
   985                                  ;Call check_for_eof
   986                                  ;
   987                                  ;if (nc returned)
   988                                  ;
   989                                  ;   {call GetNextFatEntry
   990                                  ;
   991                                  ;    if (new cluster is contig to old cluster)
   992                                  ;	{add sectors per cluster to CS:SectorCount
   993                                  ;
   994                                  ;	 call check_for_eof
   995                                  ;
   996                                  ;	 if (nc returned)
   997                                  ;
   998                                  ; ---------------------------------------------------------------------------
   999                                  
  1000                                  ; 09/12/2022
  1001                                  ; END_OF_FILE equ 0FFh
  1002                                  ; DosLoadSeg equ 70h
  1003                                  
  1004                                  GetContigClusters:
  1005                                  
  1006                                  ; 24/12/2022
  1007                                  %if 0	
  1008                                  		xor	ah, ah
  1009                                  		mov	al, [cs:SecPerCluster]	; Assume we will get one cluster
  1010                                  		mov	[cs:SectorCount], ax	; Sector count = sectors in 1 cluster
  1011                                  		push	word [cs:SectorCount]
  1012                                  		call	GetNextFatEntry		; Returns next cluster to read in AX	
  1013                                  		pop	word [cs:SectorCount]
  1014                                  		mov	word [cs:CurrentCluster], ax ; Update the last one found
  1015                                  		cmp	byte [cs:EndOfFile], 0FFh ; END_OF_FILE
  1016                                  		jz	short GoToBioInit
  1017                                  		xor	dx, dx
  1018                                  		;sub	ax, 2			; Zero base the cluster
  1019                                  		; 10/12/2022
  1020                                  		dec	ax
  1021                                  		dec	ax
  1022                                  		xor	ch, ch
  1023                                  		mov	cl, [cs:SecPerCluster]
  1024                                  		mul	cx			; How many sectors (before next cluster) 
  1025                                  		add	ax, [cs:FirstSectorL]	; See where the data sector starts
  1026                                  		adc	dx, [cs:FirstSectorH]
  1027                                  		mov	[cs:StartSecL], ax	; Save it (used by ReadSectors)
  1028                                  		mov	[cs:StartSecH], dx
  1029                                  		mov	di, [cs:NextBioLocation] ; Get where to put code
  1030                                  		push	word [cs:SectorCount]	; Save how many sectors
  1031                                  		;mov	ax, DosLoadSeg
  1032                                  		mov	ax, 70h
  1033                                  		mov	es, ax
  1034                                  		call	ReadSectors
  1035                                  		pop	ax			; Get back total sectors read in
  1036                                  		mul	word [cs:BytesPerSec]	; Get number of bytes we loaded
  1037                                  		add	[cs:NextBioLocation], ax ; Point to where to load next	
  1038                                  		jmp	short GetContigClusters
  1039                                  
  1040                                  %endif
  1041                                  		; 24/12/2022
  1042                                  		; ds = cs
  1043                                  
  1044 000001BD A1[1200]                		mov	ax, [SecPerCluster]	; Assume we will get one cluster
  1045 000001C0 A3[0C00]                		mov	[SectorCount], ax	; Sector count = sectors in 1 cluster
  1046                                  		;push	word [SectorCount]
  1047 000001C3 50                      		push	ax
  1048 000001C4 E8AF00                  		call	GetNextFatEntry		; Returns next cluster to read in AX	
  1049 000001C7 8F06[0C00]              		pop	word [SectorCount]
  1050 000001CB A3[0E00]                		mov	[CurrentCluster], ax	; Update the last one found
  1051                                  
  1052 000001CE 803E[2900]FF            		cmp	byte [EndOfFile], 0FFh	; END_OF_FILE
  1053 000001D3 741A                    		je	short GoToBioInit ; 23/12/2022
  1054                                  		; 22/12/2022
  1055                                  		;xor	dx, dx ; * (not required)
  1056                                  		; 10/12/2022
  1057                                  		;sub	ax, 2			; Zero base the cluster
  1058 000001D5 48                      		dec	ax
  1059 000001D6 48                      		dec	ax
  1060                                  		; 24/12/2022
  1061                                  		; ax = cluster index
  1062                                  		;mov	cx, [SecPerCluster]
  1063                                  		;mul	cx ; *			; How many sectors (before next cluster) 
  1064 000001D7 F726[1200]              		mul	word [SecPerCluster]
  1065 000001DB 0306[2200]              		add	ax, [FirstSectorL]	; See where the data sector starts
  1066 000001DF 1316[2400]              		adc	dx, [FirstSectorH]
  1067 000001E3 A3[0600]                		mov	[StartSecL], ax		; Save it (used by ReadSectors)
  1068 000001E6 8916[0800]              		mov	[StartSecH], dx
  1069                                  
  1070                                  		; es:di = (current) buffer address for (current) read
  1071                                  	
  1072 000001EA E81600                  		call	ReadSectors
  1073                                  				; ES:DI = (the next) buffer address for next read
  1074                                  		
  1075 000001ED EBCE                    		jmp	short GetContigClusters
  1076                                  
  1077                                  ; ---------------------------------------------------------------------------
  1078                                  
  1079                                  ; GoToBiosInit
  1080                                  ; ---------------------------------------------------------------------------
  1081                                  ;
  1082                                  ; NOTES:
  1083                                  ;
  1084                                  ;  Set up required registers for iosys, then jump to it (70:0)
  1085                                  ;
  1086                                  ; INPUT:     none
  1087                                  ;
  1088                                  ;   CS:MediaByte = media byte
  1089                                  ;   CS:BootDrive = int 13 drive number we booted from
  1090                                  ;   CS:FirstSectorL = first data sector on disk (low) (0-based)
  1091                                  ;   CS:FirstSectorH = first data sector on disk (high)
  1092                                  ;
  1093                                  ; OUTPUT:
  1094                                  ;
  1095                                  ;   required by msinit
  1096                                  ;   DL = int 13 drive number we booted from
  1097                                  ;   CH = media byte
  1098                                  ;   BX = first data sector on disk (0-based)
  1099                                  ;   AX = first data sector on disk (high)
  1100                                  ;   DI = sectors/fat for the boot media.
  1101                                  ;
  1102                                  ; calls:     none
  1103                                  ; ---------------------------------------------------------------------------
  1104                                  ;
  1105                                  ; set up registers for msinit then do far jmp
  1106                                  ;
  1107                                  ; ---------------------------------------------------------------------------
  1108                                  
  1109                                  GoToBioInit:	
  1110                                  		; 24/12/2022
  1111                                  		; ds = cs	
  1112                                  		;mov	ch, [cs:MediaByte]
  1113                                  		;mov	dl, [cs:BootDrive]
  1114                                  		;mov	bx, [cs:FirstSectorL]
  1115                                  		;mov	ax, [cs:FirstSectorH]
  1116                                  
  1117 000001EF 8A2E[2800]              		mov	ch, [MediaByte] ; Restore regs required for msint
  1118 000001F3 8A16[2600]              		mov	dl, [BootDrive] ; Physical drv number we booted from.
  1119 000001F7 8B1E[2200]              		mov	bx, [FirstSectorL] ; AX:BX = first data sector of disk
  1120 000001FB A1[2400]                		mov	ax, [FirstSectorH]
  1121                                  
  1122                                  		; 15/09/2023 (retrodos 4.s, retrodos41.s, retrodos42.s)
  1123                                  		; (This is not necessary but BP value will be 7C00h
  1124                                  		; when the RetroDOS boot sector code starts the kernel.
  1125                                  		; Retro DOS 4 Kernel source code contains a comment that
  1126                                  		; 'bp = 7C00h' at the init stage. But RetroDOS kernel
  1127                                  		; doesn't use it later. However, i want to leave BP
  1128                                  		; as equal to SP here.) ---rd4load.s---
  1129                                  		;
  1130                                  		; 15/09/2023 (iosys5.s, iosys51.s, iosys6.s)
  1131                                  		; (The BP value here will not be used by IO.SYS later.
  1132                                  		;  It is not necessary to set.) 
  1133                                  		;
  1134                                  		;mov	bp, sp	; 7C00h ; 15/09/2023
  1135                                  
  1136 000001FE EA00007000              		jmp	70h:0	; Far jump to IoSysAddr	(DOSBIOS)
  1137                                  
  1138                                  ; =============== S U B	R O U T	I N E =======================================
  1139                                  
  1140                                  ; ReadSectors
  1141                                  ; ---------------------------------------------------------------------------
  1142                                  ; notES:
  1143                                  ;
  1144                                  ;  read in the CS:SectorCount number of sectors at ES:di
  1145                                  ;
  1146                                  ;
  1147                                  ; INPUT:
  1148                                  ;
  1149                                  ;   DI = OFFSET of start of read
  1150                                  ;   ES = segment of read
  1151                                  ;   CS:SectorCount = number of sectors to read
  1152                                  ;   CS:StartSecL = starting sector (low)
  1153                                  ;   CS:StartSecH = starting sector (high)
  1154                                  ;   following is bpb info that must be setup prior to call
  1155                                  ;   CS:NumHeads
  1156                                  ;   CS:number_of_sectors
  1157                                  ;   CS:BootDrive
  1158                                  ;   CS:SecPerTrack
  1159                                  ;
  1160                                  ; OUTPUT:
  1161                                  ;
  1162                                  ;   AX,BX,CX,DX,SI,DI destroyed
  1163                                  ; ---------------------------------------------------------------------------
  1164                                  ; divide start sector by sectors per track
  1165                                  ; the remainder is the actual sector number, 0 based
  1166                                  ;
  1167                                  ; increment actual sector number to get 1 based
  1168                                  ;
  1169                                  ; the quotient is the number of tracks - divide by heads to get the cyl
  1170                                  ;
  1171                                  ; the remainder is actual head, the quotient is cylinder
  1172                                  ;
  1173                                  ; figure the number of sectors in that track, set al to this
  1174                                  ;
  1175                                  ; do the read
  1176                                  ;
  1177                                  ; if error, do reset, then redo the int 13h
  1178                                  ;
  1179                                  ; if successful read, subtract # sectors read from SectorCount, add to logical
  1180                                  ; sector, add #sectors read * BytesPerSec to bx;
  1181                                  ;
  1182                                  ; if SectorCount <> 0 do next read
  1183                                  ; ---------------------------------------------------------------------------
  1184                                  
  1185                                  		; 15/09/2023
  1186                                  ReadSectors:
  1187                                  		; 24/12/2022
  1188                                  		; 22/12/2022
  1189                                  ReadSectors:
  1190 00000203 B90500                  		mov	cx, 5			; 5 retries
  1191                                  
  1192                                  		; Convert a logical sector into track/sector/head. AX has the
  1193                                  		; logical sector number
  1194                                  TryRead:
  1195                                  		; 24/12/2022
  1196                                  		; ds = cs
  1197 00000206 51                      		push	cx
  1198                                  		;mov	ax, [cs:StartSecL]	; Get starting sector
  1199                                  		;mov	dx, [cs:StartSecH]
  1200                                  		; 15/09/2023
  1201                                  		;mov	ax, [StartSecL]	; *	; Get starting sector
  1202                                  		;mov	dx, [StartSecH]
  1203                                  		;push	ax ; *
  1204                                  		;mov	ax, dx
  1205 00000207 A1[0800]                		mov	ax, [StartSecH]
  1206 0000020A 31D2                    		xor	dx, dx
  1207                                  		;;div	word [cs:SecPerTrack]
  1208                                  		;div	word [SecPerTrack]
  1209                                  		; 24/12/2022
  1210 0000020C 8B1E[1600]              		mov	bx, [SecPerTrack]
  1211 00000210 F7F3                    		div	bx
  1212                                  
  1213                                  		;mov	[TempH], ax
  1214                                  		;;mov	[cs:TempH], ax
  1215                                  		; 15/09/2023
  1216 00000212 89C5                    		mov	bp, ax ; [TempH]
  1217                                  		;pop	ax ; *
  1218 00000214 A1[0600]                		mov	ax, [StartSecL] ; *
  1219 00000217 F7F3                    		div	bx
  1220                                  		;div	word [SecPerTrack]
  1221                                  		;;div	word [cs:SecPerTrack]	; [TempH]:ax = track,
  1222                                  						; dx = sector number
  1223                                  
  1224                                  		;mov	bx, [cs:SecPerTrack]	; Get number of sectors we can
  1225                                  						; read in this track
  1226 00000219 29D3                    		sub	bx, dx
  1227                                  		;mov	si, bx
  1228 0000021B 8B36[0C00]              		mov	si, [SectorCount]
  1229                                  
  1230 0000021F 39DE                    		cmp	si, bx
  1231 00000221 7602                    		jna	short GotLength
  1232                                  		;cmp	[SectorCount], si
  1233                                  		;;cmp	[cs:SectorCount], si	; Is possible sectors in track more
  1234                                  		;jnb	short GotLength		; than what we need to read?
  1235 00000223 89DE                    		mov	si, bx
  1236                                  		;mov	si, [SectorCount]
  1237                                  		;;mov	si, [cs:SectorCount]	; Yes, only read what we need to
  1238                                  ;GotLength:
  1239                                  
  1240                                  		; 24/12/2022
  1241                                  		; IO.SYS < 40KB (segment override is not possible)
  1242                                  		; 700h+0F8FFh < 64KB address 
  1243                                  		;	(there is not an override risk up to 63743 bytes)
  1244                                  ; 24/12/2022
  1245                                  %if 0
  1246                                  		; 24/12/2022
  1247                                  		; dma boundary check for >64KB reads
  1248                                  		; Also, Segment Override risk !
  1249                                  		or	di, di
  1250                                  		jz	short dma_boundary_ok ; no problem for the 1st read
  1251                                  		;cmp	byte [BootDrive], 80h
  1252                                  		;;cmp	byte [cs:BootDrive], 80h
  1253                                  		;jnb	short dma_boundary_ok ; no problem for hard disks
  1254                                  dma_boundary_chk:
  1255                                  		cmp	si, 1
  1256                                  		jna	short dma_boundary_ok 
  1257                                  				; 1 sector read will not cause a boundary error			
  1258                                  		push	dx
  1259                                  		push	ax
  1260                                  		mov	ax, si
  1261                                  		sub	dx, dx
  1262                                  		mul	word [BytesPerSec]
  1263                                  		mov	bx, es
  1264                                  		mov	cl, 4
  1265                                  		shl	bx, cl	; convert paragraphs to bytes
  1266                                  		; bx = segment start position (for 64K memory sections)
  1267                                  		add	bx, ax	; byte count to read
  1268                                  		pop	ax
  1269                                  		pop	dx
  1270                                  		add	bx, di	; add current buffer offset to byte count
  1271                                  		jnc	short dma_boundary_ok
  1272                                  		
  1273                                  		; Sector count must be decreased to prevent
  1274                                  		; DMA boundary error or segment override risk!
  1275                                  		dec	si
  1276                                  		jmp	short dma_boundary_chk
  1277                                  dma_boundary_ok:
  1278                                  %endif
  1279                                  		; 24/12/2022
  1280                                  GotLength:
  1281                                  		;inc	dl			; Sector numbers are 1-based
  1282                                  		; 18/12/2022
  1283 00000225 42                      		inc	dx
  1284 00000226 88D3                    		mov	bl, dl			; Start sector in BL
  1285                                  		
  1286                                  		; 15/09/2023
  1287                                  		; 24/12/2022
  1288                                  		;mov	dx, [TempH]		; DX:AX = Track
  1289                                  		;;mov	dx, [cs:TempH]		; DX:AX = Track
  1290                                  		
  1291 00000228 50                      		push	ax
  1292                                  		;mov	ax, dx
  1293                                  		; 15/09/2023
  1294 00000229 89E8                    		mov	ax, bp ; [TempH]
  1295 0000022B 31D2                    		xor	dx, dx
  1296                                  		; 24/12/2022
  1297 0000022D F736[1800]              		div	word [NumHeads]
  1298                                  		;div	word [cs:NumHeads]	; Start cyl in AX, head in dl
  1299                                  		;mov	[TempH], ax
  1300                                  		;;mov	[cs:TempH], ax
  1301 00000231 58                      		pop	ax
  1302 00000232 F736[1800]              		div	word [NumHeads]
  1303                                  		;div	word [cs:NumHeads]	; [TempH]:AX = Cylinder, DX = Head
  1304                                  
  1305                                  			; At this moment, we assume that TempH = 0,
  1306                                  			; ax <= 1024, dx <= 255
  1307                                  
  1308 00000236 88D6                    		mov	dh, dl
  1309                                  		
  1310 00000238 B106                    		mov	cl, 6
  1311 0000023A D2E4                    		shl	ah, cl			; Shift cyl high bits up
  1312 0000023C 08DC                    		or	ah, bl			; Mix in with sector bits
  1313 0000023E 88C5                    		mov	ch, al			; Setup cyl low
  1314 00000240 88E1                    		mov	cl, ah			; Setup cyl/high - sector
  1315 00000242 89FB                    		mov	bx, di			; Get back OFFSET
  1316                                  		; 24/12/2022
  1317 00000244 8A16[2600]              		mov	dl, [BootDrive]		; Get drive
  1318                                  		;mov	dl, [cs:BootDrive]	; Get drive
  1319 00000248 89F0                    		mov	ax, si			; Get number of sectors to read (al)
  1320 0000024A B402                    		mov	ah, 2			; Read sectors
  1321                                  		; 23/12/2022
  1322                                  		;push	ax
  1323                                  		;push	di
  1324                                  
  1325                                  			; Issue one read request. ES:BX have the transfer address,
  1326                                  			; AL is the number of sectors.	
  1327                                  
  1328 0000024C CD13                    		int	13h		; DISK - READ SECTORS INTO MEMORY
  1329                                  					; AL = number of sectors to read, CH = track, CL = sector
  1330                                  					; DH = head, DL	= drive, ES:BX -> buffer to fill
  1331                                  					; Return: CF set on error, AH =	status,	AL = number of sectors read
  1332                                  		; 23/12/2022
  1333                                  		;pop	di
  1334                                  		;pop	ax
  1335                                  
  1336                                  		; 23/12/2022
  1337 0000024E B400                    		mov	ah, 0
  1338                                  		
  1339 00000250 59                      		pop	cx		; Get retry count back
  1340 00000251 730A                    		jnc	short ReadOk	; 23/12/2022
  1341                                  		
  1342                                  		; 23/12/2022
  1343                                  		;mov	bx, di		; Get offset
  1344                                  		; ah = 0
  1345                                  		;xor	ah, ah
  1346                                  		; 23/12/2022
  1347                                  		;push	cx
  1348                                  		; 24/12/2022
  1349                                  		;mov	dl, [BootDrive]
  1350                                  		;;mov	dl, [cs:BootDrive]
  1351                                  		; 23/12/2022
  1352                                  		;push	di
  1353 00000253 CD13                    		int	13h		; DISK - RESET DISK SYSTEM
  1354                                  					; DL = drive (if bit 7 is set both hard	disks and floppy disks reset)
  1355                                  		; 23/12/2022
  1356                                  		;pop	di
  1357                                  		;pop	cx
  1358 00000255 49                      		dec	cx
  1359 00000256 7402                    		jz	short ReadError
  1360 00000258 EBAC                    		jmp	TryRead
  1361                                  ; ---------------------------------------------------------------------------
  1362                                  
  1363                                  ReadError:				
  1364 0000025A E9BD00                  		jmp	ErrorOut
  1365                                  ; ---------------------------------------------------------------------------
  1366                                  
  1367                                  ReadOk:
  1368                                  		; 23/12/2022			
  1369                                  		; ah = 0
  1370                                  		; 22/12/2022
  1371                                  		;xor	ah, ah		; Mask out read command, just get # read
  1372                                  		; ch = 0
  1373 0000025D 88C1                    		mov	cl, al
  1374                                  
  1375                                  		; 22/12/2022
  1376                                  		; cx = ax = read (sector) count	
  1377                                  		;mov	bx, [cs:BytesPerSec]	; Bytes per sector
  1378                                  		;mul	bx			; Get total bytes read	
  1379                                  		; 24/12/2022
  1380                                  		; ds = cs
  1381 0000025F F726[1000]              		mul	word [BytesPerSec]
  1382                                  		;mul	word [cs:BytesPerSec]
  1383 00000263 01C7                    		add	di, ax			; Add it to OFFSET
  1384                                  
  1385                                  		; 24/12/2022
  1386                                  		; IO.SYS < 40KB (segment override is not possible)
  1387                                  		; 700h+0F8FFh < 64KB address 
  1388                                  		;	(there is not an override risk up to 63743 bytes)
  1389                                  		;add	di, ax
  1390                                  		;jnc	short read_next_sector
  1391                                  		;mov	bx, es
  1392                                  		;;add	bx, 1000h
  1393                                  		;add	bh, 10h
  1394                                  		;mov	es, bx
  1395                                  ;read_next_sector:
  1396                                  
  1397                                  		; 24/12/2022
  1398                                  		; ds = cs
  1399                                  		; 22/12/2022
  1400 00000265 290E[0C00]              		sub	[SectorCount], cx
  1401                                  		;sub	[cs:SectorCount], cx
  1402                                  		;;sub	[cs:SectorCount], ax	; Bump number down
  1403 00000269 7471                    		jz	short EndRead
  1404 0000026B 010E[0600]              		add	[StartSecL], cx
  1405                                  		;add	[cs:StartSecL], cx
  1406                                  		;;add	[cs:StartSecL], ax	; Where to start next time
  1407 0000026F 8316[0800]00            		adc	word [StartSecH], 0
  1408                                  		;adc	word [cs:StartSecH], 0
  1409 00000274 EB8D                    		jmp	ReadSectors
  1410                                  ; ---------------------------------------------------------------------------
  1411                                  		
  1412                                  		; 24/12/2022
  1413                                  ;EndRead:				
  1414                                  		;retn
  1415                                  
  1416                                  ; =============== S U B	R O U T	I N E =======================================
  1417                                  
  1418                                  ; GetNextFatEntry
  1419                                  ; ---------------------------------------------------------------------------
  1420                                  ;
  1421                                  ; NOTES:
  1422                                  ;
  1423                                  ;   given the last cluster found, this will return the next cluster of
  1424                                  ;   iosys. if the last cluster is (f)ff8 - (f)fff, then the final cluster
  1425                                  ;   of iosys has been loaded, and control is passed to goto_iosys
  1426                                  ;   msload can handle maximum fat area size of 128 kb.
  1427                                  ;
  1428                                  ; INPUT:
  1429                                  ;
  1430                                  ;    CS:CurrentCluster
  1431                                  ;    CS:FatSize
  1432                                  ;
  1433                                  ; OUTPUT:
  1434                                  ;
  1435                                  ;   CS:CurrentCluster (updated)
  1436                                  ;
  1437                                  ; calls:  GetFatSector
  1438                                  ; ---------------------------------------------------------------------------
  1439                                  ; get CurrentCluster
  1440                                  ;
  1441                                  ; if (16 bit fat)
  1442                                  ;    {if (CurrentCluster = fff8 - ffff)
  1443                                  ;	 {jmp goto_iosys}
  1444                                  ;     else
  1445                                  ;	{get OFFSET by multiply cluster by 2}
  1446                                  ;
  1447                                  ; else
  1448                                  ;    {if (CurrentCluster = ff8 - fff)
  1449                                  ;	 {jmp goto_iosys}
  1450                                  ;     else
  1451                                  ;	{get OFFSET by	- multiply cluster by 3
  1452                                  ;
  1453                                  ;	 rotate right to divide by 2
  1454                                  ;
  1455                                  ;	 if (cy set - means odd number)
  1456                                  ;	    {shr 4 times to keep high twelve bits}
  1457                                  ;
  1458                                  ;	 else
  1459                                  ;	    {and with 0fffh to keep low 12 bits}
  1460                                  ;	}
  1461                                  ;    }
  1462                                  ;
  1463                                  ; ---------------------------------------------------------------------------
  1464                                  
  1465                                  ; 09/12/2022
  1466                                  ; FAT_12_BIT equ 1
  1467                                  ; NOT_END_OF_FILE equ 0  ; ~END_OF_FILE ; END_OF_FILE equ 0FFh
  1468                                  
  1469                                  GetNextFatEntry:
  1470 00000276 06                      		push	es
  1471                                  		; 24/12/2022
  1472                                  		; ds = cs
  1473                                  		;mov	ax, [cs:FatSegment]
  1474 00000277 A1[3200]                		mov	ax, [FatSegment]
  1475 0000027A 8EC0                    		mov	es, ax		; ES-> FAT area segment
  1476                                  		; 09/12/2022
  1477                                  		;;mov	byte [cs:EndOfFile], END_OF_FILE
  1478                                  		;mov	byte [cs:EndOfFile], 0FFh ; Assume last cluster
  1479                                  		;mov	ax, [cs:CurrentCluster] ; Get last cluster
  1480                                  		; 24/12/2022
  1481                                  		; ds = cs
  1482 0000027C C606[2900]FF            		mov	byte [EndOfFile], 0FFh ; Assume last cluster
  1483 00000281 A1[0E00]                		mov	ax, [CurrentCluster] ; Get last cluster
  1484 00000284 803E[2700]01            		cmp	byte [Fatsize], 1
  1485                                  		;;cmp	byte [cs:FatSize], FAT_12_BIT
  1486                                  		;cmp	byte [cs:Fatsize], 1
  1487 00000289 7537                    		jne	short Got16Bit	; 23/12/2022
  1488 0000028B 89C6                    		mov	si, ax
  1489 0000028D D1E8                    		shr	ax, 1
  1490 0000028F 01C6                    		add	si, ax		; SI = AX * 1.5 = AX + AX/2
  1491                                  		; 23/12/2022
  1492                                  		;push	dx
  1493                                  		;xor	dx, dx
  1494 00000291 29D2                    		sub	dx, dx ; 23/12/2022
  1495 00000293 E84700                  		call	GetFatSector
  1496                                  		; 23/12/2022
  1497                                  		;pop	dx
  1498 00000296 7510                    		jnz	short ClusterOk
  1499 00000298 268A07                  		mov	al, [es:bx]
  1500                                  		; 22/12/2022
  1501                                  		;mov	[cs:TempCluster], al
  1502                                  		;push	ax ; (*)
  1503 0000029B 46                      		inc	si
  1504                                  		; 23/12/2022
  1505                                  		;push	dx
  1506 0000029C 31D2                    		xor	dx, dx
  1507 0000029E E83C00                  		call	GetFatSector	; Read next fat sector
  1508                                  		; 23/12/2022
  1509                                  		;pop	dx
  1510                                  		; 22/12/2022
  1511                                  		;mov	al, [es:0]
  1512                                  		;mov	[cs:TempCluster+1], al
  1513                                  		;mov	ax, [cs:TempCluster]
  1514                                  		; 22/12/2022
  1515                                  		;pop	ax ; (*) 
  1516 000002A1 268A260000              		mov	ah, [es:0]
  1517 000002A6 EB03                    		jmp	short EvenOdd
  1518                                  ; ---------------------------------------------------------------------------
  1519                                  
  1520                                  ClusterOk:				
  1521 000002A8 268B07                  		mov	ax, [es:bx]
  1522                                  EvenOdd:	
  1523                                  		; 24/12/2022
  1524                                  		; ds = cs
  1525 000002AB F606[0E00]01            		test	byte [CurrentCluster], 1
  1526                                  		; 10/12/2022		
  1527                                  		;test	byte [cs:CurrentCluster], 1 ; 09/12/2022
  1528                                  		;;test	word [cs:CurrentCluster], 1 ; Was last cluster odd?
  1529 000002B0 7505                    		jnz	short OddResult		; If not zero it was odd
  1530 000002B2 25FF0F                  		and	ax, 0FFFh		; Keep low 12 bits
  1531 000002B5 EB04                    		jmp	short TestEOF
  1532                                  ; ---------------------------------------------------------------------------
  1533                                  
  1534                                  OddResult:				
  1535 000002B7 B104                    		mov	cl, 4			; Keep high 12 bits for odd
  1536 000002B9 D3E8                    		shr	ax, cl
  1537                                  TestEOF:				
  1538 000002BB 3DF80F                  		cmp	ax, 0FF8h		; Is it last cluster?
  1539 000002BE 731B                    		jnb	short GotClusterDone	; Yep, all done here
  1540 000002C0 EB14                    		jmp	short NotLastCluster
  1541                                  ; ---------------------------------------------------------------------------
  1542                                  
  1543                                  Got16Bit:
  1544                                  		; 23/12/2022				
  1545                                  		;push	dx
  1546                                  		;xor	dx, dx
  1547 000002C2 29D2                    		sub	dx, dx ; 23/12/2022
  1548 000002C4 D1E0                    		shl	ax, 1			; Multiply cluster by 2
  1549 000002C6 83D200                  		adc	dx, 0
  1550 000002C9 89C6                    		mov	si, ax			; Get the final buffer OFFSET
  1551 000002CB E80F00                  		call	GetFatSector
  1552                                  		; 23/12/2022
  1553                                  		;pop	dx
  1554 000002CE 268B07                  		mov	ax, [es:bx]
  1555 000002D1 83F8F8                  		cmp	ax, 0FFF8h
  1556 000002D4 7305                    		jnb	short GotClusterDone
  1557                                  NotLastCluster:	
  1558                                  		; 24/12/2022
  1559                                  		; ds = cs			
  1560                                  		;;mov	byte [cs:EndOfFile], NOT_END_OF_FILE ; ~END_OF_FILE
  1561                                  		;mov	byte [cs:EndOfFile], 0	; Assume not last cluster
  1562 000002D6 C606[2900]00            		mov	byte [EndOfFile], 0	; Assume not last cluster
  1563                                  GotClusterDone:				
  1564 000002DB 07                      		pop	es
  1565                                  		; 24/12/2022
  1566                                  EndRead:
  1567 000002DC C3                      		retn
  1568                                  
  1569                                  ; =============== S U B	R O U T	I N E =======================================
  1570                                  
  1571                                  ; GetFatSector
  1572                                  ; ---------------------------------------------------------------------------
  1573                                  ;function: find and read the corresponding fat sector into ES:0
  1574                                  ;
  1575                                  ;in). SI = offset value (starting from fat entry 0) of fat entry to find.
  1576                                  ;     ES = fat sector segment
  1577                                  ;     CS:BytesPerSec
  1578                                  ;
  1579                                  ;out). corresponding fat sector read in.
  1580                                  ;      BX = offset value of the corresponding fat entry in the fat sector.
  1581                                  ;      CX destroyed.
  1582                                  ;      zero flag set if the fat entry is splitted, i.e. when 12 bit fat entry
  1583                                  ;      starts at the last byte of the fat sector. in this case, the caller
  1584                                  ;      should save this byte, and read the next fat sector to get the rest
  1585                                  ;      of the fat entry value. (this will only happen with the 12 bit fat).
  1586                                  ;
  1587                                  ; ---------------------------------------------------------------------------
  1588                                  
  1589                                  		; 24/12/2022
  1590                                  		; 22/12/2022
  1591                                  GetFatSector:
  1592 000002DD 50                      		push	ax
  1593 000002DE 56                      		push	si
  1594 000002DF 57                      		push	di
  1595 000002E0 89F0                    		mov	ax, si
  1596                                  		; 24/12/2022
  1597                                  		; ds = cs
  1598                                  		;mov	cx, [cs:BytesPerSec]
  1599                                  		;div	cx			; AX = Sector number, DX = Offset
  1600 000002E2 F736[1000]              		div	word [BytesPerSec]
  1601 000002E6 3B06[0A00]              		cmp	ax, [LastFatSector]
  1602                                  		;cmp	ax, [cs:LastFatSector]	; The same fat sector?
  1603 000002EA 7421                    		je	short SplitChk		; Don't need to read it again.
  1604 000002EC A3[0A00]                		mov	[LastFatSector], ax
  1605                                  		;mov	[cs:LastFatSector], ax
  1606 000002EF 52                      		push	dx
  1607                                  		; 24/12/2022
  1608 000002F0 31D2                    		xor	dx, dx
  1609                                  		;add	ax, [cs:HiddenSectorsL]
  1610                                  		;adc	dx, [cs:HiddenSectorsH]
  1611                                  		;add	ax, [cs:ReservSectors]
  1612                                  		;adc	dx, 0
  1613                                  		; 24/12/2022
  1614                                  		; ds = cs
  1615 000002F2 0306[2E00]              		add	ax, [FatStartSecL]
  1616 000002F6 1316[3000]              		adc	dx, [FatStartSecH]
  1617 000002FA A3[0600]                		mov	[StartSecL], ax
  1618 000002FD 8916[0800]              		mov	[StartSecH], dx		; Set up for ReadSectors
  1619                                  		;mov	[cs:StartSecL], ax
  1620                                  		;mov	[cs:StartSecH], dx	; Set up for ReadSectors
  1621                                  		
  1622 00000301 C706[0C00]0100          		mov	word [SectorCount], 1 ; 1 sector			
  1623                                  		;mov	word [cs:SectorCount], 1 ; 1 sector
  1624 00000307 31FF                    		xor	di, di ; 0
  1625                                  		; es:di = FATSEGMENT:0000h
  1626 00000309 E8F7FE                  		call	ReadSectors
  1627 0000030C 5A                      		pop	dx
  1628                                  		; 24/12/2022
  1629                                  		;mov	cx, [cs:BytesPerSec]
  1630                                  SplitChk:
  1631                                  		; 24/12/2022
  1632 0000030D 8B0E[1000]              		mov	cx, [BytesPerSec]				
  1633 00000311 49                      		dec	cx			; CX = SECTOR SIZE - 1
  1634 00000312 39CA                    		cmp	dx, cx			; If last byte of sector, splitted entry.
  1635 00000314 89D3                    		mov	bx, dx			; set bx to dx
  1636 00000316 5F                      		pop	di
  1637 00000317 5E                      		pop	si
  1638 00000318 58                      		pop	ax
  1639                                  EndWrite:		; 10/12/2022
  1640 00000319 C3                      		retn
  1641                                  
  1642                                  ; ---------------------------------------------------------------------------
  1643                                  
  1644                                  ErrorOut:
  1645                                  		; 24/12/2022
  1646                                  		; ds = cs
  1647                                  		;push	cs
  1648                                  		;pop	ds
  1649                                  		
  1650 0000031A BE[4103]                		mov	si, NonSystemDiskMsg ; "\r\nNon-System disk or disk error\r\nRe"...
  1651 0000031D E81400                  		call	WriteTTY
  1652                                  
  1653                                  		; Wait for a keypress on the keyboard.
  1654                                  		; Use the bios keyboard interrupt.
  1655                                  
  1656 00000320 30E4                    		xor	ah, ah
  1657 00000322 CD16                    		int	16h		; KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY
  1658                                  					; Return: AH = scan code, AL = character
  1659                                  
  1660                                  		; We have to restore the address of the original rom disk
  1661                                  		; parameter table to the location at [0:DskAddr]. The address
  1662                                  		; of this original table has been saved previously in
  1663                                  		; 0:OrgDasdPtr and 0:OrgDasdPtr+2. After this table address
  1664                                  		; has been restored we can reboot by invoking the bootstrap
  1665                                  		; loader bios interrupt.
  1666                                  
  1667                                  		; 23/12/2022
  1668                                  		;xor	bx, bx
  1669                                  		;mov	ds, bx
  1670                                  		;les	bx, [OrgDasdPtr] ; Wrong DS segment !
  1671                                  					 ; (Erdogan Tan, 23/12/2022)
  1672 00000324 C41E[2A00]              		les	bx, [OrgDasdPtr] ; Correct DS segment = CS
  1673                                  		
  1674                                  		; 23/12/2022
  1675 00000328 16                      		push	ss ; 0
  1676 00000329 1F                      		pop	ds
  1677                                  		; ds = 0		
  1678                                  
  1679 0000032A BE7800                  		mov	si, DskAddr	; (Int 1Eh)
  1680 0000032D 891C                    		mov	[si], bx	; restore offset		
  1681 0000032F 8C4402                  		mov	[si+2], es	; restore segment
  1682 00000332 CD19                    		int	19h		; reboot
  1683                                  
  1684                                  
  1685                                  ; =============== S U B	R O U T	I N E =======================================
  1686                                  
  1687                                  ; WriteTTY
  1688                                  ; ---------------------------------------------------------------------------
  1689                                  ; in) DS:si -> asciiz string.
  1690                                  ;
  1691                                  ; WriteTTY the character in al to the screen.
  1692                                  ; use video service 'write teletype to active page' (ROM_TTY)
  1693                                  ; use normal character attribute
  1694                                  ; ---------------------------------------------------------------------------
  1695                                  
  1696                                  WriteTTY:
  1697 00000334 AC                      		lodsb
  1698 00000335 08C0                    		or	al, al
  1699 00000337 74E0                    		jz	short EndWrite
  1700                                  		;mov	AH, ROM_TTY	; 09/12/2022
  1701 00000339 B40E                    		mov	ah, 0Eh
  1702 0000033B B307                    		mov	bl, 7		; "normal" attribute
  1703 0000033D CD10                    		int	10h		; - VIDEO - WRITE CHARACTER AND	ADVANCE	CURSOR (TTY WRITE)
  1704                                  					; AL = character, BH = display page (alpha modes)
  1705                                  					; BL = foreground color	(graphics modes)
  1706 0000033F EBF3                    		jmp	short WriteTTY
  1707                                  ; ---------------------------------------------------------------------------
  1708                                  
  1709                                  ; 10/12/2022	
  1710                                  ;EndWrite:
  1711                                  ;		retn
  1712                                  
  1713                                  ; ---------------------------------------------------------------------------
  1714                                  
  1715                                  ; 09/12/2022
  1716                                  ;include msbio.cl1
  1717                                  
  1718                                  		; 22/12/2022
  1719                                  		; 20/12/2022
  1720                                  		; 18/12/2022
  1721                                  		;db 0	; (word alignment)
  1722                                  NonSystemDiskMsg:
  1723 00000341 0D0A                    		db 0Dh,0Ah		; ...
  1724 00000343 4E6F6E2D5379737465-     		db 'Non-System disk or disk error',0Dh,0Ah
  1724 0000034C 6D206469736B206F72-
  1724 00000355 206469736B20657272-
  1724 0000035E 6F720D0A           
  1725 00000362 5265706C6163652061-     		db 'Replace and press any key when ready',0Dh,0Ah,0
  1725 0000036B 6E6420707265737320-
  1725 00000374 616E79206B65792077-
  1725 0000037D 68656E207265616479-
  1725 00000386 0D0A00             
  1726                                  ; 25/12/2022
  1727 00000389 90<rep 7h>              align 16
  1728                                  
  1729                                  EndOfLoader:
  1730                                  		;dw 01A1h	; 10/12/2022
  1731                                  
  1732                                  ; ---------------------------------------------------------------------------
  1733                                  
  1734                                  ;=============================================================================
  1735                                  ; DOS BIOS (IO.SYS) DATA SEGMENT 
  1736                                  ;=============================================================================
  1737                                  ; 09/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
  1738                                  
  1739                                  section .BIOSDATA vstart=0
  1740                                  
  1741                                  ;--- DOSBIOS data segment ----------------------------------------------------
  1742                                  ;-----------------------------------------------------------------------------
  1743                                  
  1744                                  ;Bios_Data segment
  1745                                  
  1746                                  BData_start:				
  1747 00000000 E96F17                  hdrv_pat:	jmp	init		; MSBIO1.ASM, MSSBDATA.INC
  1748                                  ; ----------------------------------------------------------------------------
  1749                                  
  1750 00000003 0000                    DosDataSg:	dw 0
  1751                                  
  1752                                  ; DOS's int 2f handler will exit via a jump through here.
  1753                                  ; This is how the BIOS hooks int2f
  1754                                  			
  1755 00000005 EA                      bios_i2f:	db 0EAh			; far jump to int_2f (segment may not be at 70h)
  1756 00000006 [9108]                  off_706:	dw int_2f
  1757 00000008 7000                    word_708:	dw 70h			; KERNEL_SEGMENT
  1758                                  
  1759 0000000A 0000                    romstartaddr:	dw 0			; The start address for the romfind routines
  1760                                  					; This is to maintain binary compatibility
  1761                                  					; with DISK based DOS 5.0
  1762                                  
  1763                                  ; This is a byte used for special key handling in the resident
  1764                                  ; console device driver. It must be here so that it can be included
  1765                                  ; in the WIN386 instance table (in INC\LMSTUB.ASM).
  1766                                  
  1767 0000000C 00                      altah:		db 0			; special key handling
  1768                                  			
  1769 0000000D 00                      inHMA:		db 0			; flag indicates we're running from HMA
  1770 0000000E 00000000                xms:		dd 0			; entry point to xms if above is true
  1771                                  
  1772                                  ; PTRSAV - pointer save
  1773                                  ;
  1774                                  ; This variable holds the pointer to the Request Header passed by a program
  1775                                  ; wishing to use a device driver. When the strategy routine is called it 
  1776                                  ; puts the address of the Request header in this variable and returns.
  1777                                  		
  1778 00000012 00000000                ptrsav:		dd 0			
  1779                                  auxbuf:		;db 4 dup(0)		; set of 1 byte buffers for com 1,2,3, and 4
  1780 00000016 00000000                		db 0, 0, 0, 0 ; 19/10/2022
  1781 0000001A 0000                    zeroseg:	dw 0			; easy way to load segment registers with zero			
  1782 0000001C 0000                    i13_ds:		dw 0			; ds register for int13 call through	
  1783 0000001E 0000                    prevoper:	dw 0			; holds int 13 request (i.e. register ax).			
  1784 00000020 00                      number_of_sec:	db 0			; holds number of secs. to read on an ecc error
  1785 00000021 0000                    auxnum:		dw 0			; which aux device was requested			
  1786                                  
  1787                                  ;-----------------------------------------------------------------------------
  1788                                  
  1789                                  res_dev_list:
  1790                                  
  1791                                  ; Device Header for the CON Device Driver
  1792                                  
  1793                                  CONHeader:				; HEADER FOR DEVICE "CON"
  1794 00000023 [3500]                  		dw auxdev2
  1795 00000025 7000                    		dw 70h	
  1796 00000027 1380                    word_727:	dw 8013h
  1797 00000029 [F506]                  		dw strategy
  1798 0000002B [0007]                  		dw con_entry
  1799 0000002D 434F4E2020202020        aCon:		db 'CON     '           
  1800 00000035 [4700]                  auxdev2:	dw prndev2		; HEADER FOR DEVICE "AUX"	
  1801 00000037 7000                    		dw 70h
  1802 00000039 0080                    		dw 8000h
  1803 0000003B [F506]                  		dw strategy
  1804 0000003D [2107]                  		dw aux0_entry
  1805 0000003F 4155582020202020        aAux:		db 'AUX     '
  1806 00000047 [5900]                  prndev2:	dw timdev		; HEADER FOR DEVICE "PRN"
  1807 00000049 7000                    		dw 70h
  1808 0000004B C0A0                    word_74B:	dw 0A0C0h
  1809 0000004D [F506]                  		dw strategy
  1810 0000004F [0507]                  		dw prn0_entry
  1811 00000051 50524E2020202020        aPrn:		db 'PRN     '		; HEADER FOR DEVICE "CLOCK$"
  1812 00000059 [6B00]                  timdev:		dw dskdev	
  1813 0000005B 7000                    		dw 70h
  1814 0000005D 0880                    		dw 8008h
  1815 0000005F [F506]                  		dw strategy
  1816 00000061 [3907]                  		dw tim_entry
  1817 00000063 434C4F434B242020        aClock:		db 'CLOCK$  '
  1818 0000006B [7B00]                  dskdev:		dw com1dev		; HEADER FOR DISK DEVICES
  1819 0000006D 7000                    		dw 70h
  1820 0000006F C208                    		dw 8C2h
  1821                                  		;dw offset strategy
  1822                                  		;dw offset dsk_entry
  1823                                  		; 19/10/2022
  1824 00000071 [F506]                  		dw strategy
  1825 00000073 [3E07]                  		dw dsk_entry
  1826                                  
  1827                                  ; maximum number of drives
  1828                                  
  1829 00000075 04                      drvmax:		db 4			
  1830 00000076 FE                      step_drv:	db 0FEh	 ; -2		; last drive accessed		
  1831 00000077 00                      fhave96:	db 0			; flag to indicate presence of
  1832                                  					; 96tpi support		
  1833 00000078 00                      single:		db 0			; used to detect single drive systems		
  1834 00000079 00                      fhavek09:	db 0			; indicates if this is a k09 or not
  1835                                  					; used by console driver.			
  1836 0000007A 00                      fsetowner:	db 0			; = 1 if we are setting the owner of a
  1837                                  					; drive. (examined by checksingle).
  1838                                  		
  1839 0000007B [8D00]                  com1dev:	dw lpt1dev		; Device Header for device "COM1"	
  1840 0000007D 7000                    		dw 70h
  1841 0000007F 0080                    		dw 8000h
  1842 00000081 [F506]                  		dw strategy
  1843 00000083 [2107]                  		dw aux0_entry
  1844 00000085 434F4D3120202020        aCom1:		db 'COM1    '
  1845 0000008D [9F00]                  lpt1dev:	dw lpt2dev		; Device Header for device LPT1	
  1846 0000008F 7000                    		dw 70h
  1847 00000091 C0A0                    		dw 0A0C0h
  1848 00000093 [F506]                  		dw strategy
  1849 00000095 [0C07]                  		dw prn1_entry
  1850 00000097 4C50543120202020        aLpt1:		db 'LPT1    '
  1851 0000009F [B800]                  lpt2dev:	dw lpt3dev		; Device Header for device LPT2	
  1852 000000A1 7000                    		dw 70h
  1853 000000A3 C0A0                    		dw 0A0C0h
  1854 000000A5 [F506]                  		dw strategy
  1855 000000A7 [1307]                  		dw prn2_entry
  1856 000000A9 4C5054322020202000-     aLpt2:		db 'LPT2    ',0,0,0
  1856 000000B2 0000               
  1857                                  
  1858                                  ;M058; Start of changes
  1859                                  ; Orig13 needs to be at offset 0B4h for the CMS floppy driver to work.
  1860                                  ;These guys patch Orig13 with their own int 13h hook and so this offset
  1861                                  ;cannot change for them to work. Even ProComm does this.
  1862                                  
  1863 000000B4 00000000                Orig13:		dd 0			; to make Orig13 offset 0B4h		
  1864                                  
  1865 000000B8 [CA00]                  lpt3dev:	dw com2dev		; Device Header for device LPT3	
  1866 000000BA 7000                    		dw 70h
  1867 000000BC C0A0                    		dw 0A0C0h
  1868 000000BE [F506]                  		dw strategy
  1869 000000C0 [1A07]                  		dw prn3_entry
  1870 000000C2 4C50543320202020        aLpt3:		db 'LPT3    '
  1871 000000CA [DC00]                  com2dev:	dw com3dev		; Device Header for device "COM2"
  1872 000000CC 7000                    		dw 70h
  1873 000000CE 0080                    		dw 8000h
  1874 000000D0 [F506]                  		dw strategy
  1875 000000D2 [2707]                  		dw aux1_entry
  1876                                  		; 19/10/2022
  1877 000000D4 434F4D3220202020        aCom2:		db 'COM2    '
  1878                                  com3dev:	;dw offset com4dev	; Device Header for device "COM3"
  1879 000000DC [EE00]                  		dw com4dev
  1880 000000DE 7000                    		dw 70h
  1881 000000E0 0080                    		dw 8000h
  1882                                  		;dw offset strategy
  1883                                  		;dw offset aux2_entry
  1884 000000E2 [F506]                  		dw strategy
  1885 000000E4 [2D07]                  		dw aux2_entry	
  1886 000000E6 434F4D3320202020        aCom3:		db 'COM3    '
  1887 000000EE FFFF                    com4dev:	dw 0FFFFh		; Device Header for device "COM4"	
  1888 000000F0 7000                    		dw 70h
  1889 000000F2 0080                    		dw 8000h
  1890 000000F4 [F506]                  		dw strategy
  1891 000000F6 [3307]                  		dw aux3_entry
  1892 000000F8 434F4D3420202020        		db 'COM4    '
  1893                                  
  1894                                  ;-----------------------------------------------------------------------------
  1895                                  
  1896 00000100 10                      RomVectors:	db 10h			
  1897 00000101 00000000                Old10:		dd 0
  1898 00000105 13                      		db 13h
  1899 00000106 00000000                Old13:		dd 0			
  1900 0000010A 15                      		db 15h
  1901 0000010B 00000000                Old15:		dd 0			
  1902 0000010F 19                      		db 19h
  1903 00000110 00000000                Old19:		dd 0
  1904 00000114 1B                      		db 1Bh
  1905 00000115 00000000                Old1B:		dd 0
  1906                                  
  1907                                  ;EndRomVectors	equ $
  1908                                  
  1909                                  ;NUMROMVECTORS	equ ((EndRomVectors - RomVectors)/5)
  1910                                  
  1911                                  ;-----------------------------------------------------------------------------
  1912                                  
  1913 00000119 [4E03]                  start_bds:	dw bds1			; Start	of linked list of BDS's
  1914 0000011B 7000                    		dw 70h			; KERNEL_SEGMENT
  1915                                  
  1916                                  ; (MSDOS 3.3) NOTE:
  1917                                  ; Some floppy drives do not have changeline support. The result is a
  1918                                  ; large amount of inefficiency in the code. A media-check always returns
  1919                                  ; "I don`t know". This cause DOS to reread the FAT on every access and
  1920                                  ; always discard any cached data.
  1921                                  ;    We get around this inefficiency by implementing a "Logical Door Latch".
  1922                                  ; The following three items are used to do this. The logical door latch is
  1923                                  ; based on the premise that it is not physically possible to change floppy
  1924                                  ; disks in a drive in under two seconds (most people take about 10). The
  1925                                  ; logical door latch is implemented by saving the time of the last successful
  1926                                  ; disk operation (in the value TIM_DRV). When a new request is made the
  1927                                  ; current time is compared to the saved time. If less than two seconds have
  1928                                  ; passed then the value "No Change" is returned. If more than two seconds
  1929                                  ; have passed the value "Don't Know" is returned.
  1930                                  ;    There is one complecation to this algorithm. Some programs change the
  1931                                  ; value of the timer. In this unfortunate case we have an invalid timer.
  1932                                  ; This possibility is detected by counting the number of disk operations
  1933                                  ; which occur without any time passing. If this count exceeds the value of
  1934                                  ; "AccessMax" we assume the counter is invalid and always return "Don't
  1935                                  ; Know". The variable "AccessCount" is used to keep track of the number
  1936                                  ; of disk operation which occur without the time changing.
  1937                                  
  1938 0000011D 00                      accesscount:	db 0			
  1939 0000011E FF                      tim_drv:	db 0FFh			
  1940 0000011F 00                      medbyt:		db 0
  1941                                  wrtverify:	; 15/10/2022			
  1942 00000120 02                      rflag:		db 2			; 2 for	read, 3	for write
  1943 00000121 00                      verify:		db 0			; 1 if verify after write
  1944 00000122 0000                    seccnt:		dw 0			
  1945 00000124 00                      		db 0			; -- pad where hardnum was
  1946 00000125 01                      dsktnum:	db 1			; number of diskette drives			
  1947                                  
  1948                                  ; (MSDOS 3.3) NOTE:
  1949                                  ; Some of the older versions of the IBM rom-bios always assumed a seek would
  1950                                  ; have to be made to read the diskette. Consequently a large head settle
  1951                                  ; time was always used in the I/O operations. To get around this problem
  1952                                  ; we need to continually adjust the head settle time. The following
  1953                                  ; algorithm is used:
  1954                                  ;
  1955                                  ;   Get the current head settle value.
  1956                                  ;   If it is 1, then
  1957                                  ;	set slow = 15
  1958                                  ;   else
  1959                                  ;	set slow = value
  1960                                  ;   ...
  1961                                  ;   if we are seeking and writing then
  1962                                  ;	use slow
  1963                                  ;   else
  1964                                  ;	use fast
  1965                                  ;   ...
  1966                                  ;   restore current head settle value
  1967                                  
  1968 00000126 00                      motorstartup:	db 0			; value from table
  1969 00000127 00                      settlecurrent:	db 0			; value	from table
  1970 00000128 00                      settleslow:	db 0			; slow settle value
  1971 00000129 00                      nextspeed:	db 0			; value	of speed to be used
  1972 0000012A 00                      save_head_sttl:	db 0			; used by read_sector routine
  1973 0000012B 00                      save_eot:	db 0			; saved	eot from the default DPT
  1974 0000012C 09                      eot:		db 9			
  1975 0000012D 00000000                dpt:		dd 0			; pointer to Disk Parameter Table			
  1976 00000131 00                      cursec:		db 0			; current sector
  1977 00000132 00                      curhd:		db 0			; current head
  1978 00000133 0000                    curtrk:		dw 0			; current track
  1979 00000135 0000                    spsav:		dw 0			; save the stack pointer
  1980 00000137 08                      formt_eot:	db 8			; eot used for format
  1981 00000138 00                      hdnum:		db 0			; head number
  1982 00000139 0000                    trknum:		dw 0			; track	being manipulated
  1983 0000013B 50                      gap_patch:	db 50h			; format gap patched into dpt
  1984                                  
  1985                                  ;-----------------------------------------------------------------------------
  1986                                  
  1987                                  ; disk errors returned from the IBM rom
  1988                                  
  1989 0000013C CC                      errin:		db 0CCh			; write	fault error
  1990 0000013D 80                      		db 80h			; no response
  1991 0000013E 40                      		db 40h			; seek failure
  1992 0000013F 10                      		db 10h			; bad crc
  1993 00000140 08                      		db 8			; dma overrun
  1994 00000141 06                      		db 6			; media	change
  1995 00000142 04                      		db 4			; sector not found
  1996 00000143 03                      		db 3			; write	attempt	to write-protect disk
  1997 00000144 00                      lsterr:		db 0			; all other errors
  1998                                  
  1999                                  ; returned error codes corresponding to above
  2000                                  
  2001 00000145 0A                      errout:		db 10			; write	fault error
  2002 00000146 02                      		db 2			; no response
  2003 00000147 06                      		db 6			; seek failure
  2004 00000148 04                      		db 4			; bad crc
  2005 00000149 04                      		db 4			; dma overrun
  2006 0000014A 0F                      		db 15			; invalid media	change
  2007 0000014B 08                      		db 8			; sector not found
  2008 0000014C 00                      		db 0			; write	attempt	to write-protect disk
  2009 0000014D 0C                      		db 12			; general error
  2010                                  
  2011                                  ;-----------------------------------------------------------------------------
  2012                                  
  2013                                  ; 30/12/2018 - Retro DOS v4.0
  2014                                  
  2015                                  ; read in boot sector here, read done in readboot.
  2016                                  ; also read sector for dma check for hard disk.
  2017                                  ;
  2018                                  ; This buffer is word aligned because certain AMI BIOSs have a bug
  2019                                  ; in them which causes the byte after the buffer to be trashed
  2020                                  ; on floppy reads to odd-byte boundaries. Although no general effort 
  2021                                  ; is made to enforce this in the bigger picture, this one small sacrifice
  2022                                  ; makes that system more-or-less work.
  2023                                  
  2024                                  disksector:	;db 512 dup(0)		; read in boot sector here
  2025                                  		; 19/10/2022
  2026 0000014E 00<rep 200h>            		times 512 db 0
  2027                                  
  2028                                  ;-----------------------------------------------------------------------------
  2029                                  
  2030                                  ; 30/12/2018 - Retro DOS v4.0
  2031                                  ;-----------------------------------------------------------------------------
  2032                                  ; 25/05/2018 (04/04/2018)
  2033                                  ;*****************************************************************************
  2034                                  ;	"bds" contains information for each drive in the system.
  2035                                  ;	various values are patched whenever actions are performed.
  2036                                  ;	sectors/alloc. unit in bpb initially set to -1 to signify that
  2037                                  ;	the bpb has not been filled. link also set to -1 to signify end
  2038                                  ;	of list. # of cylinders in maxparms initialized to -1 to indicate
  2039                                  ;	that the parameters have not been set.
  2040                                  
  2041                                  bds1:		;dw offset bds2
  2042 0000034E [B203]                  		dw bds2	; 19/10/2022
  2043 00000350 7000                    		dw 70h			; dword	link to	next structure
  2044 00000352 00                      		db 0			; int 13h drive	number
  2045 00000353 00                      		db 0			; logical drive	letter
  2046 00000354 0002                    fdrive1:	dw 512			
  2047                                  					; physical sector size in bytes
  2048 00000356 FF                      		db 0FFh			; sectors/allocation unit
  2049 00000357 0100                    		dw 1			; reserved sectors for dos
  2050 00000359 02                      		db 2			; no of	file allocation	tables
  2051 0000035A 4000                    		dw 64			; number of root directory entries
  2052 0000035C 6801                    		dw 360			; number sectors (at 512 bytes each)
  2053 0000035E 00                      		db 0			; media	descriptor, initially 0
  2054 0000035F 0200                    		dw 2			; number of fat	sectors
  2055 00000361 0900                    		dw 9			; sector limit (sectors	per track)
  2056 00000363 0100                    		dw 1			; head limit (number of	heads -	1)
  2057 00000365 0000                    		dw 0			; hidden sector	count (low word)
  2058 00000367 0000                    		dw 0			; hidden sector	(high)
  2059 00000369 0000                    		dw 0			; number sectors (low)
  2060 0000036B 0000                    		dw 0			; number sectors (high)
  2061 0000036D 00                      		db 0			; true => large	fats
  2062 0000036E 0000                    		dw 0			; open ref. count
  2063 00000370 03                      		db 3			; form factor
  2064 00000371 2000                    		dw 20h			; various flags
  2065 00000373 2800                    		dw 40			; number of cylinders
  2066 00000375 0002                    recommended_bps: dw 512			; recommended bps for this drive
  2067 00000377 01                      		db 1
  2068 00000378 0100                    		dw 1
  2069 0000037A 02                      		db 2
  2070 0000037B E000                    		dw 224			; number of root directory entries
  2071 0000037D 6801                    		dw 360
  2072 0000037F F0                      		db 0F0h			; media	descriptor, initially 0F0h
  2073 00000380 0200                    		dw 2
  2074 00000382 0900                    		dw 9
  2075 00000384 0200                    		dw 2
  2076 00000386 0000                    		dw 0
  2077 00000388 0000                    		dw 0
  2078 0000038A 0000                    		dw 0
  2079 0000038C 0000                    		dw 0
  2080                                  		;db 6 dup(0)
  2081 0000038E 00<rep 6h>              		times 6 db 0		; 19/10/2022
  2082 00000394 FF                      		db 0FFh			; last track accessed on this drive
  2083 00000395 FFFF                    word_A95:	dw 0FFFFh		; keep these two contiguous (?)
  2084 00000397 FFFF                    		dw 0FFFFh
  2085 00000399 4E4F204E414D452020-     		db 'NO NAME    ',0      ; volume id for this disk
  2085 000003A2 202000             
  2086 000003A5 00000000                		dd 0			; current volume serial	from boot record
  2087 000003A9 464154313220202000      		db 'FAT12   ',0         ; current file system id from boot record
  2088                                  ; ----
  2089                                  
  2090 000003B2 [1604]                  bds2:		dw bds3		
  2091 000003B4 7000                    		dw 70h
  2092 000003B6 00                      		db 0
  2093 000003B7 00                      		db 0
  2094 000003B8 0002                    fdrive2:	dw 512			
  2095 000003BA FF0100024000680100-     byte_ABA:	db 0FFh, 1, 0, 2, 40h, 0, 68h, 1, 0, 2,	0, 9, 0, 1, 0
  2095 000003C3 020009000100       
  2096 000003C9 000000000000000000-     		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 3, 20h, 0, 28h, 0
  2096 000003D2 00000320002800     
  2097 000003D9 000201010002E00068-     		db 0, 2, 1, 1, 0, 2, 0E0h, 0, 68h, 1, 0F0h, 2, 0, 9, 0
  2097 000003E2 01F002000900       
  2098 000003E8 020000000000000000-     		db 2, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0FFh
  2098 000003F1 00000000000000FF   
  2099 000003F9 FFFFFFFF4E4F204E41-     		db 0FFh, 0FFh, 0FFh, 0FFh, 4Eh,	4Fh, 20h, 4Eh, 41h, 4Dh
  2099 00000402 4D                 
  2100 00000403 452020202000000000-     		db 45h,	20h, 20h, 20h, 20h, 0, 0, 0, 0,	0, 46h,	41h, 54h
  2100 0000040C 00464154           
  2101 00000410 313220202000            		db 31h,	32h, 20h, 20h, 20h, 0
  2102                                  ; ----
  2103                                  
  2104 00000416 [7A04]                  bds3:		dw bds4		
  2105 00000418 7000                    		dw 70h
  2106 0000041A 00                      		db 0
  2107 0000041B 00                      		db 0
  2108 0000041C 0002                    fdrive3:	dw 512			
  2109 0000041E FF0100024000680100-     		db 0FFh, 1, 0, 2, 40h, 0, 68h, 1, 0, 2,	0, 9, 0, 1, 0
  2109 00000427 020009000100       
  2110 0000042D 000000000000000000-     		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 3, 20h, 0, 28h, 0
  2110 00000436 00000320002800     
  2111 0000043D 000201010002E00068-     		db 0, 2, 1, 1, 0, 2, 0E0h, 0, 68h, 1, 0F0h, 2, 0, 9, 0
  2111 00000446 01F002000900       
  2112 0000044C 020000000000000000-     		db 2, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0FFh
  2112 00000455 00000000000000FF   
  2113 0000045D FFFFFFFF4E4F204E41-     		db 0FFh, 0FFh, 0FFh, 0FFh, 4Eh,	4Fh, 20h, 4Eh, 41h, 4Dh
  2113 00000466 4D                 
  2114 00000467 452020202000000000-     		db 45h,	20h, 20h, 20h, 20h, 0, 0, 0, 0,	0, 46h,	41h, 54h
  2114 00000470 00464154           
  2115 00000474 313220202000            		db 31h,	32h, 20h, 20h, 20h, 0
  2116                                  ; ----
  2117                                  
  2118 0000047A FFFF                    bds4:		dw 0FFFFh		
  2119 0000047C 7000                    		dw 70h
  2120 0000047E 00                      		db 0
  2121 0000047F 00                      		db 0
  2122 00000480 0002                    fdrive4:	dw 512			
  2123 00000482 FF0100024000680100-     byte_B82:	db 0FFh, 1, 0, 2, 40h, 0, 68h, 1, 0, 2,	0, 9, 0, 1, 0
  2123 0000048B 020009000100       
  2124 00000491 000000000000000000-     		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 3, 20h, 0, 28h, 0
  2124 0000049A 00000320002800     
  2125 000004A1 000201010002E00068-     		db 0, 2, 1, 1, 0, 2, 0E0h, 0, 68h, 1, 0F0h, 2, 0, 9, 0
  2125 000004AA 01F002000900       
  2126 000004B0 020000000000000000-     		db 2, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0FFh
  2126 000004B9 00000000000000FF   
  2127 000004C1 FFFFFFFF4E4F204E41-     		db 0FFh, 0FFh, 0FFh, 0FFh, 4Eh,	4Fh, 20h, 4Eh, 41h, 4Dh
  2127 000004CA 4D                 
  2128 000004CB 452020202000000000-     		db 45h,	20h, 20h, 20h, 20h, 0, 0, 0, 0,	0, 46h,	41h, 54h
  2128 000004D4 00464154           
  2129 000004D8 313220202000            		db 31h,	32h, 20h, 20h, 20h, 0
  2130                                  
  2131                                  ;-----------------------------------------------------------------------------
  2132                                  
  2133 000004DE 03                      sm92:		db 3			; .spf			
  2134 000004DF 09                      		db 9			; .spt
  2135 000004E0 70                      		db 112	; 70h		; .cdire
  2136 000004E1 A005                    		dw 1440	; 2*9*80	; .csec
  2137 000004E3 02                      		db 2			; .spau
  2138 000004E4 02                      		db 2			; .chead
  2139                                  
  2140 000004E5 00                      keyrd_func:	db 0			
  2141 000004E6 01                      keysts_func:	db 1			
  2142 000004E7 00                      printdev:	db 0			; printer device index
  2143                                  
  2144                                  wait_count:	;dw 4 dup(50h)		; retry	counts for printers
  2145 000004E8 5000<rep 4h>            		times 4 dw 50h		; 19/10/2022
  2146                                  
  2147 000004F0 0000                    daycnt:		dw 0			
  2148 000004F2 00                      t_switch:	db 0			; flag for updating daycnt
  2149 000004F3 00                      havecmosclock:	db 0			
  2150 000004F4 13                      base_century:	db 19			
  2151 000004F5 50                      base_year:	db 80			
  2152 000004F6 1F1C1F1E1F1E1F1F1E-     month_tab:	db 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 
  2152 000004FF 1F1E1F             
  2153 00000502 [FD14]                  bintobcd:	dw bin_to_bcd		; points to bin_to_bcd proc in msinit
  2154 00000504 7000                    		dw 70h ; 17/10/2022	
  2155 00000506 [2C14]                  daycnttoday:	dw daycnt_to_day	; points to daycnt_to_day in msinit
  2156 00000508 7000                    		dw 70h ; 17/10/2022
  2157 0000050A 00                      set_id_flag:	db 0			; flag for getbp routine
  2158 0000050B 464154313220202000      fat_12_id:	db 'FAT12   ',0         
  2159 00000514 464154313620202000      fat_16_id:	db 'FAT16   ',0         
  2160 0000051D 4E4F204E414D452020-     vol_no_name:	db 'NO NAME    ',0      
  2160 00000526 202000             
  2161                                  
  2162 00000529 0000                    temp_h:		dw 0			; temporary for	32 bit calculation
  2163 0000052B 0000                    start_sec_h:	dw 0			; starting sector number high word
  2164 0000052D 0000                    saved_word:	dw 0			; tempory saving place for a word
  2165 0000052F 0000                    multrk_flag:	dw 0			
  2166 00000531 00                      ec35flag:	db 0			; flags	for 3.5	inch disk drives
  2167 00000532 0000                    vretry_cnt:	dw 0			
  2168 00000534 0000                    soft_ecc_cnt:	dw 0			
  2169 00000536 00                      multitrk_format_flag: db 0		; multi	track format request flag
  2170 00000537 0000                    xfer_seg:	dw 0			; temp for transfer segment
  2171                                  
  2172                                  ; variables for msdioctl.asm module
  2173                                  
  2174                                  ; tracktable contains a 4-tuples (c,h,r,n) for each sector in a track
  2175                                  ; c = cylinder number,h = head number,r = sector id,n = bytes per sector
  2176                                  ;	n	bytes per sector
  2177                                  ;      ---	----------------
  2178                                  ;	0	      128
  2179                                  ;	1	      256
  2180                                  ;	2	      512
  2181                                  ;	3	     1024
  2182                                  
  2183                                  ;max_sectors_curr_sup equ 63		; current maximum sec/trk that
  2184                                  ;					; we support (was 40 in dos 3.2)
  2185                                  
  2186 00000539 2400                    sectorspertrack: dw 36			
  2187 0000053B 00000102                tracktable:	db 0, 0, 1, 2		
  2188 0000053F 00000202                		db 0, 0, 2, 2
  2189 00000543 00000302                		db 0, 0, 3, 2
  2190 00000547 00000402                		db 0, 0, 4, 2
  2191 0000054B 00000502                		db 0, 0, 5, 2
  2192 0000054F 00000602                		db 0, 0, 6, 2
  2193 00000553 00000702                		db 0, 0, 7, 2
  2194 00000557 00000802                		db 0, 0, 8, 2
  2195 0000055B 00000902                		db 0, 0, 9, 2
  2196 0000055F 00000A02                		db 0, 0, 10, 2
  2197 00000563 00000B02                		db 0, 0, 11, 2
  2198 00000567 00000C02                		db 0, 0, 12, 2
  2199 0000056B 00000D02                		db 0, 0, 13, 2
  2200 0000056F 00000E02                		db 0, 0, 14, 2
  2201 00000573 00000F02                		db 0, 0, 15, 2
  2202 00000577 00001002                		db 0, 0, 16, 2
  2203 0000057B 00001102                		db 0, 0, 17, 2
  2204 0000057F 00001202                		db 0, 0, 18, 2
  2205 00000583 00001302                		db 0, 0, 19, 2
  2206 00000587 00001402                		db 0, 0, 20, 2
  2207 0000058B 00001502                		db 0, 0, 21, 2
  2208 0000058F 00001602                		db 0, 0, 22, 2
  2209 00000593 00001702                		db 0, 0, 23, 2
  2210 00000597 00001802                		db 0, 0, 24, 2
  2211 0000059B 00001902                		db 0, 0, 25, 2
  2212 0000059F 00001A02                		db 0, 0, 26, 2
  2213 000005A3 00001B02                		db 0, 0, 27, 2
  2214 000005A7 00001C02                		db 0, 0, 28, 2
  2215 000005AB 00001D02                		db 0, 0, 29, 2
  2216 000005AF 00001E02                		db 0, 0, 30, 2
  2217 000005B3 00001F02                		db 0, 0, 31, 2
  2218 000005B7 00002002                		db 0, 0, 32, 2
  2219 000005BB 00002102                		db 0, 0, 33, 2
  2220 000005BF 00002202                		db 0, 0, 34, 2
  2221 000005C3 00002302                		db 0, 0, 35, 2
  2222 000005C7 00002402                		db 0, 0, 36, 2
  2223 000005CB 00<rep 6Ch>             		times 108 db 0		; 19/10/2022
  2224                                  		;db 108 dup(0)		; 4*max_sectors_curr_sup - ($ -	tracktable) dup	(0)
  2225                                  					; times	((4*63)	- 144) db 0
  2226                                  
  2227                                  ;-----------------------------------------------------------------------------
  2228                                  
  2229                                  ; this is a real ugly place to put this
  2230                                  ; it should really go in the bds
  2231                                  
  2232 00000637 00                      mediatype:	db 0			
  2233 00000638 00                      media_set_for_format: db 0		; 1 if we have done an int 13 set media
  2234                                  					; type for format call
  2235 00000639 00                      had_format_error: db 0			; 1 if the previous format operation
  2236                                  					; failed.
  2237                                  
  2238                                  ; temp disk base table. it holds the the current dpt which is then replaced by
  2239                                  ; the one passed by "new roms" before we perform a format operation. the old
  2240                                  ; dpt is restored in restoreolddpt. the first entry (disk_specify_1) is -1 if
  2241                                  ; this table does not contain the previously saved dpt.
  2242                                  		
  2243 0000063A FFFFFFFF                tempdpt:	dd 0FFFFFFFFh ; -1	; temp disk base table
  2244 0000063E FF                      model_byte:	db 0FFh			; model	byte set at init time
  2245 0000063F 00                      secondary_model_byte: db 0
  2246                                  		
  2247 00000640 00                      int19sem:	db 0			; indicate that all int 19
  2248                                  					; initialization is complete
  2249                                  		
  2250                                  ;; we assume the following remain contiguous and their order doesn't change
  2251                                  ;i19_lst:
  2252                                  ;	irp	aa,<02,08,09,0a,0b,0c,0d,0e,70,72,73,74,76,77>
  2253                                  ;	public	int19old&aa
  2254                                  ;		db	aa&h	; store the number as a byte
  2255                                  ;int19old&aa	dd	-1	; original hardware int. vectors for int 19h.
  2256                                  ;	endm
  2257                                  
  2258                                  ; 21/10/2022
  2259                                  
  2260 00000641 02                      i19_lst:	db 2			
  2261                                  					; Int19old&aa
  2262 00000642 FFFFFFFF                int19old02:	dd 0FFFFFFFFh ; -1
  2263 00000646 08                      		db 8
  2264 00000647 FFFFFFFF                int19old08:	dd 0FFFFFFFFh		; original hardware int. vectors for int 19h
  2265 0000064B 09                      		db 9
  2266 0000064C FFFFFFFF                int19old09:	dd 0FFFFFFFFh
  2267 00000650 0A                      		db 0Ah
  2268 00000651 FFFFFFFF                int19old0A:	dd 0FFFFFFFFh
  2269 00000655 0B                      		db 0Bh
  2270 00000656 FFFFFFFF                int19old0B:	dd 0FFFFFFFFh
  2271 0000065A 0C                      		db 0Ch
  2272 0000065B FFFFFFFF                int19old0C:	dd 0FFFFFFFFh
  2273 0000065F 0D                      		db 0Dh
  2274 00000660 FFFFFFFF                int19old0D:	dd 0FFFFFFFFh
  2275 00000664 0E                      		db 0Eh
  2276 00000665 FFFFFFFF                int19old0E:	dd 0FFFFFFFFh
  2277 00000669 70                      		db 70h
  2278 0000066A FFFFFFFF                int19old70:	dd 0FFFFFFFFh
  2279 0000066E 72                      		db 72h
  2280 0000066F FFFFFFFF                int19old72:	dd 0FFFFFFFFh
  2281 00000673 73                      		db 73h
  2282 00000674 FFFFFFFF                int19old73:	dd 0FFFFFFFFh
  2283 00000678 74                      		db 74h
  2284 00000679 FFFFFFFF                int19old74:	dd 0FFFFFFFFh
  2285 0000067D 76                      		db 76h
  2286 0000067E FFFFFFFF                int19old76:	dd 0FFFFFFFFh
  2287 00000682 77                      		db 77h
  2288 00000683 FFFFFFFF                int19old77:	dd 0FFFFFFFFh
  2289                                  
  2290                                  ;num_i19	equ ($ - i19_lst)/5  ; 18/03/2019
  2291                                  
  2292                                  ;-----------------------------------------------------------------------------
  2293                                  
  2294 00000687 [5403]                  dskdrvs:	dw fdrive1	
  2295 00000689 [B803]                  		dw fdrive2
  2296 0000068B [1C04]                  		dw fdrive3
  2297 0000068D [8004]                  		dw fdrive4
  2298                                  
  2299                                  ;M011 -- made all hard drive stuff variable
  2300                                  		;dw 22 dup(0)		; up to	26 drives for mini disks
  2301 0000068F 0000<rep 16h>           		times 22 dw 0	; 19/10/2022
  2302                                  
  2303                                  ;-----------------------------------------------------------------------------
  2304                                  
  2305                                  ; 01/10/2022 - Retro DOS v4.0 (MSDOS v5.0 -actual-)
  2306                                  ; 30/12/2018 - Retro DOS v4.0 (MSDOS v6.21 -draft-)
  2307                                  ; 01/06/2018 - Retro DOS v3.0 (MSDOS v3.3)
  2308                                  
  2309                                  ;variables for dynamic relocatable modules
  2310                                  ;these should be stay resident.
  2311                                  
  2312 000006BB 00000000                int6c_ret_addr:	dd 0			; return address from int 6Ch
  2313                                  					; for p12 machine
  2314                                  
  2315                                  ; data structures for real-time date and time
  2316                                  			
  2317 000006BF 00000000                bin_date_time:	db 0, 0, 0, 0		; century, year, month,	day
  2318                                  
  2319 000006C3 0000                    month_table:	dw 0			; january
  2320 000006C5 1F00                    		dw 31			; february
  2321 000006C7 3B00                    		dw 59
  2322 000006C9 5A00                    		dw 90
  2323 000006CB 7800                    		dw 120
  2324 000006CD 9700                    		dw 151
  2325 000006CF B500                    		dw 181
  2326 000006D1 D400                    		dw 212
  2327 000006D3 F300                    		dw 243
  2328 000006D5 1101                    		dw 273
  2329 000006D7 3001                    		dw 304
  2330 000006D9 4E01                    		dw 334			; december
  2331                                  
  2332 000006DB 0000                    daycnt2:	dw 0			
  2333 000006DD 00                      feb29:		db 0			; february 29 in a leap	year flag
  2334                                  
  2335                                  ;-----------------------------------------------------------------------------
  2336                                  ;
  2337                                  ; 01/10/2022 - (New/Actual) Retro DOS v4.0 (will run as MSDOS 5.0)	
  2338                                  ; by Erdogan Tan (Istanbul) ! free source code !
  2339                                  ; 31/12/2018 - (old/draft) Retro DOS v4.0 (will/would run as MSDOS 6.21)
  2340                                  
  2341                                  ; ----------------------------------------------------------------------------
  2342                                  
  2343                                  ;************************************************************************
  2344                                  ;*									*
  2345                                  ;*	Entry points into Bios_Code routines. The segment values	*
  2346                                  ;*	  are plugged in by seg_reinit.					*
  2347                                  ;*									*
  2348                                  ;************************************************************************
  2349                                  
  2350                                  ; 01/10/2022 - Retro DOS v4.0 - IO.SYS (MSDOS v5.0)
  2351                                  ; BIOSCODE_SEGMENT equ 2C7h
  2352                                  ; BIOSDATA_SEGMENT equ 70h ; KERNEL_SEGMENT equ 70h
  2353                                  
  2354                                  ; 01/10/2022 - Erdogan Tan
  2355                                  ; (disassembled MSDOS 5.0 IO.SYS code here with fixed function/routine
  2356                                  ;  addresses, they will be changed to table labels later)
  2357                                  
  2358                                  ; 09/12/2022
  2359                                  %if 0
  2360                                  cdev:		dw 43h,	2C7h		; chardev_entry
  2361                                  					; at 2C7h:43h =	70h:25B3h
  2362                                  ttticks:	dw 396h, 2C7h		; time_to_ticks
  2363                                  					; at 2C7h:396h = 70h:2906h
  2364                                  bcode_i2f:	dw 1302h, 2C7h		; i2f_handler
  2365                                  					; at 2C7h:1302h	= 70h:3872h
  2366                                  i13x:		dw 154Bh, 2C7h		; i13z
  2367                                  					; at 2C7h:154Bh	= 70h:3ABBh
  2368                                  %endif
  2369                                  
  2370                                  ; 09/12/2022
  2371 000006DE [4300]B702              cdev:		dw chardev_entry, IOSYSCODESEG
  2372 000006E2 [8B03]B702              ttticks:	dw time_to_ticks, IOSYSCODESEG
  2373 000006E6 [B912]B702              bcode_i2f:	dw i2f_handler, IOSYSCODESEG
  2374 000006EA [F614]B702              i13x:		dw i13z, IOSYSCODESEG
  2375                                  
  2376                                  end_BC_entries:	; 15/10/2022
  2377                                  
  2378                                  ;************************************************************************
  2379                                  ;*									*
  2380                                  ;*	cbreak - break key handling - simply set altah=3 and iret	*
  2381                                  ;*									*
  2382                                  ;************************************************************************
  2383                                  
  2384                                  cbreak:					
  2385 000006EE 2EC606[0C00]03          		mov	byte [cs:altah], 3 ; break key handling
  2386                                  					; indicate break key set
  2387                                  intret:					
  2388 000006F4 CF                      		iret
  2389                                  
  2390                                  ; =============== S U B	R O U T	I N E ========================================
  2391                                  
  2392                                  
  2393                                  ;************************************************************************
  2394                                  ;*									*
  2395                                  ;*	strategy - store es:bx (device driver request packet)		*
  2396                                  ;*		     away at [ptrsav] for next driver function call	*
  2397                                  ;*									*
  2398                                  ;************************************************************************
  2399                                  
  2400                                  strategy:	; proc far		
  2401 000006F5 2E891E[1200]            		mov	[cs:ptrsav], bx ; store es:bx (device driver request packet)
  2402                                  					; away at [ptrsav] for next driver function call
  2403 000006FA 2E8C06[1400]            		mov	[cs:ptrsav+2], es
  2404 000006FF CB                      		retf
  2405                                  
  2406                                  ; ----------------------------------------------------------------------------
  2407                                  
  2408                                  ;************************************************************************
  2409                                  ;*									*
  2410                                  ;*	device driver entry points. these are the initial		*
  2411                                  ;*	  'interrupt' hooks out of the device driver chain.		*
  2412                                  ;*	  in the case of our resident drivers, they'll just		*
  2413                                  ;*	  stick a fake return address on the stack which		*
  2414                                  ;*	  points to dispatch tables and possibly some unit		*
  2415                                  ;*	  numbers, and then call through a common entry point		*
  2416                                  ;*	  which can take care of a20 switching				*
  2417                                  ;*									*
  2418                                  ;************************************************************************
  2419                                  
  2420                                  ; 01/10/2022 - Erdogan Tan
  2421                                  ; (disassembled MSDOS 5.0 IO.SYS code here with fixed table
  2422                                  ;  addresses, they will be changed to table labels later)
  2423                                  
  2424                                  ; 09/12/2022
  2425                                  
  2426                                  con_entry:				
  2427 00000700 E84000                  		call	cdev_entry
  2428                                  ; ----------------------------------------------------------------------------
  2429                                  		;dw 0E4h		; con_table
  2430 00000703 [E300]                  		dw con_table	
  2431                                  					; 2C7h:0E4h = 70h:2654h
  2432                                  ; ----------------------------------------------------------------------------
  2433                                  
  2434                                  prn0_entry:				
  2435 00000705 E83B00                  		call	cdev_entry
  2436                                  ; ----------------------------------------------------------------------------
  2437                                  		;dw 0FBh		; prn_table
  2438 00000708 [FA00]                  		dw prn_table
  2439                                  					; 2C7h:0FBh = 70h:266Bh
  2440 0000070A 0000                    		db 0, 0
  2441                                  ; ----------------------------------------------------------------------------
  2442                                  
  2443                                  prn1_entry:				
  2444 0000070C E83400                  		call	cdev_entry
  2445                                  ; ----------------------------------------------------------------------------
  2446                                  		;dw 0FBh		; prn_table
  2447 0000070F [FA00]                  		dw prn_table
  2448                                  					; 2C7h:0FBh = 70h:266Bh
  2449 00000711 0001                    		db 0, 1
  2450                                  ; ----------------------------------------------------------------------------
  2451                                  
  2452                                  prn2_entry:				
  2453 00000713 E82D00                  		call	cdev_entry
  2454                                  ; ----------------------------------------------------------------------------
  2455                                  		;dw 0FBh		; prn_table
  2456 00000716 [FA00]                  		dw prn_table
  2457                                  					; 2C7h:0FBh = 70h:266Bh
  2458 00000718 0102                    		db 1, 2
  2459                                  ; ----------------------------------------------------------------------------
  2460                                  
  2461                                  prn3_entry:				
  2462 0000071A E82600                  		call	cdev_entry
  2463                                  ; ----------------------------------------------------------------------------
  2464                                  		;dw 0FBh		; prn_table
  2465 0000071D [FA00]                  		dw prn_table
  2466                                  					; 2C7h:0FBh = 70h:266Bh
  2467 0000071F 0203                    		db 2, 3
  2468                                  ; ----------------------------------------------------------------------------
  2469                                  
  2470                                  aux0_entry:				
  2471 00000721 E81F00                  		call	cdev_entry
  2472                                  ; ----------------------------------------------------------------------------
  2473                                  		;dw 130h		; aux_table
  2474 00000724 [2F01]                  		dw aux_table
  2475                                  					; 2C7h:130h = 70h:26A0h
  2476 00000726 00                      		db 0
  2477                                  ; ----------------------------------------------------------------------------
  2478                                  
  2479                                  aux1_entry:				
  2480 00000727 E81900                  		call	cdev_entry
  2481                                  ; ----------------------------------------------------------------------------
  2482                                  		;dw 130h		; aux_table
  2483 0000072A [2F01]                  		dw aux_table
  2484                                  					; 2C7h:130h = 70h:26A0h
  2485 0000072C 01                      		db 1
  2486                                  ; ----------------------------------------------------------------------------
  2487                                  
  2488                                  aux2_entry:				
  2489 0000072D E81300                  		call	cdev_entry
  2490                                  ; ----------------------------------------------------------------------------
  2491                                  		;dw 130h		; aux_table
  2492 00000730 [2F01]                  		dw aux_table
  2493                                  					; 2C7h:130h = 70h:26A0h
  2494 00000732 02                      		db 2
  2495                                  ; ----------------------------------------------------------------------------
  2496                                  
  2497                                  aux3_entry:				
  2498 00000733 E80D00                  		call	cdev_entry
  2499                                  ; ----------------------------------------------------------------------------
  2500                                  		;dw 130h		; aux_table
  2501 00000736 [2F01]                  		dw aux_table
  2502                                  					; 2C7h:130h = 70h:26A0h
  2503 00000738 03                      		db 3
  2504                                  ; ----------------------------------------------------------------------------
  2505                                  
  2506                                  tim_entry:				
  2507 00000739 E80700                  		call	cdev_entry
  2508                                  ; ----------------------------------------------------------------------------
  2509                                  		;dw 147h		; tim_table
  2510 0000073C [4601]                  		dw tim_table
  2511                                  					; 2C7h:147h = 70h:26B7h
  2512                                  ; ----------------------------------------------------------------------------
  2513                                  
  2514                                  ; 15/10/2022
  2515                                  ;DSKTBL	equ dsktbl - DOSBIOSEG_2C7h	; dsktbl - 2C70h
  2516                                  ; 09/12/2022
  2517                                  DSKTBL equ dsktbl
  2518                                  
  2519                                  dsk_entry:				
  2520 0000073E E80200                  		call	cdev_entry
  2521                                  ; ----------------------------------------------------------------------------
  2522                                  		;dw 4A2h		; dsktbl
  2523 00000741 [9604]                  		dw DSKTBL		; 09/12/2022
  2524                                  					; 2C7h:4A2h = 70h:2A12h
  2525                                  
  2526                                  ; =============== S U B	R O U T	I N E ========================================
  2527                                  
  2528                                  ;************************************************************************
  2529                                  ;*									*
  2530                                  ;*	Ensure A20 is enabled before jumping into code in HMA.		*
  2531                                  ;*	This code assumes that if Segment of Device request packet is	*
  2532                                  ;*	DOS DATA segment then the Device request came from DOS & that	*
  2533                                  ;*	A20 is already on.						*
  2534                                  ;*									*
  2535                                  ;************************************************************************
  2536                                  
  2537                                  cdev_entry:	; proc near		
  2538 00000743 2E803E[0D00]00          		cmp	byte [cs:inHMA], 0
  2539 00000749 740D                    		jz	short ce_enter_codeseg
  2540                                  				; optimized for DOS in HMA
  2541 0000074B 50                      		push	ax
  2542 0000074C 2EA1[0300]              		mov	ax, [cs:DosDataSg]
  2543 00000750 2E3906[1400]            		cmp	[cs:ptrsav+2], ax
  2544 00000755 58                      		pop	ax
  2545 00000756 7505                    		jnz	short not_from_dos
  2546                                  				; jump is coded this way to fall thru
  2547                                  				; in 99.99% of the cases
  2548                                  ce_enter_codeseg:
  2549 00000758 2EFF2E[DE06]            		jmp	far [cs:cdev]			
  2550                                  		;jmp	dword ptr cs:cdev
  2551                                  ;-----------------------------------------------------------------------------
  2552                                  
  2553                                  not_from_dos:				
  2554 0000075D E86200                  		call	EnsureA20On
  2555 00000760 EBF6                    		jmp	short ce_enter_codeseg
  2556                                  
  2557                                  ;************************************************************************
  2558                                  ;*									*
  2559                                  ;*	outchr - this is our int 29h handler. it writes the		*
  2560                                  ;*	   character in al on the display using int 10h ttywrite	*
  2561                                  ;*									*
  2562                                  ;************************************************************************
  2563                                  
  2564                                  outchr:					
  2565 00000762 50                      		push	ax		; int 29h handler
  2566 00000763 56                      		push	si
  2567 00000764 57                      		push	di
  2568 00000765 55                      		push	bp
  2569 00000766 53                      		push	bx
  2570 00000767 B40E                    		mov	ah, 0Eh
  2571 00000769 BB0700                  		mov	bx, 7
  2572 0000076C CD10                    		int	10h		; - VIDEO - WRITE CHARACTER AND	ADVANCE	CURSOR (TTY WRITE)
  2573                                  					; AL = character, BH = display page (alpha modes)
  2574                                  					; BL = foreground color	(graphics modes)
  2575 0000076E 5B                      		pop	bx
  2576 0000076F 5D                      		pop	bp
  2577 00000770 5F                      		pop	di
  2578 00000771 5E                      		pop	si
  2579 00000772 58                      		pop	ax
  2580 00000773 CF                      		iret
  2581                                  ;-----------------------------------------------------------------------------
  2582                                  
  2583                                  ;************************************************************************
  2584                                  ;*									*
  2585                                  ;*	block13 - our int13 hooker					*
  2586                                  ;*									*
  2587                                  ;************************************************************************
  2588                                  
  2589                                  block13:				
  2590 00000774 2E803E[0D00]00          		cmp	byte [cs:inHMA], 0
  2591 0000077A 7408                    		jz	short skipa20
  2592 0000077C E85400                  		call	IsA20Off	; A20 Off?
  2593 0000077F 7503                    		jnz	short skipa20
  2594 00000781 E84300                  		call	EnableA20	; assure a20 enabled
  2595                                  
  2596                                  skipa20:				
  2597 00000784 2E8C1E[1C00]            		mov	[cs:i13_ds], ds	; save caller's ds for call-through
  2598 00000789 9C                      		pushf			; fake interrupt
  2599 0000078A 2EFF1E[EA06]            		call	far [cs:i13x]
  2600                                  		;call	dword ptr cs:i13x
  2601                                  					; call through Bios_Code entry table
  2602 0000078F 2E8E1E[1C00]            		mov	ds, [cs:i13_ds]
  2603 00000794 CA0200                  		retf	2
  2604                                  
  2605                                  ; =============== S U B	R O U T	I N E =======================================
  2606                                  
  2607                                  ; the int13 hook calls back here to call-through to the ROM
  2608                                  ; this is necessary because some people have extended their
  2609                                  ; ROM BIOSs to use ds as a parameter/result register and
  2610                                  ; our int13 hook relies heavily on ds to access Bios_Data
  2611                                  
  2612                                  call_orig13:	; proc far		
  2613 00000797 8E1E[1C00]              		mov	ds, [i13_ds]	; get caller's ds register
  2614 0000079B 9C                      		pushf			; simulate an int13
  2615 0000079C 2EFF1E[B400]            		call	far [cs:Orig13]
  2616                                  		;call	cs:Orig13
  2617 000007A1 2E8C1E[1C00]            		mov	[cs:i13_ds], ds
  2618 000007A6 0E                      		push	cs
  2619 000007A7 1F                      		pop	ds		; restore ds ->	Bios_Data before return
  2620                                  
  2621 000007A8 9C                      		pushf
  2622                                  		; 10/12/2022
  2623                                  		; ds = cs
  2624 000007A9 803E[0D00]00            		cmp	byte [inHMA], 0	; 16/10/2022
  2625                                  		;cmp	byte [cs:inHMA], 0
  2626 000007AE 7408                    		jz	short corig13_popf_retf
  2627 000007B0 E82000                  		call	IsA20Off
  2628 000007B3 7503                    		jnz	short corig13_popf_retf
  2629 000007B5 E80F00                  		call	EnableA20
  2630                                  corig13_popf_retf:			
  2631 000007B8 9D                      		popf
  2632 000007B9 CB                      		retf
  2633                                  
  2634                                  ;-----------------------------------------------------------------------------
  2635                                  
  2636                                  ; BIOSDATA:07BBh (MSDOS 6.21, IO.SYS)
  2637                                  ; BIOSDATA:07BBh (MSDOS 5.0, IO.SYS) ; 16/10/2022
  2638                                  
  2639 000007BA 9000FFFF                HiMem:		dd 0FFFF0090h		
  2640 000007BE 80000000                LoMem:		dd 80h
  2641                                  
  2642                                  ; ----------------------------------------------------------------------------			
  2643                                  
  2644                                  ; =============== S U B	R O U T	I N E ========================================
  2645                                  
  2646                                  
  2647                                  ;************************************************************************
  2648                                  ;*									*
  2649                                  ;*	EnsureA20On - ensure that a20 is enabled if we're running	*
  2650                                  ;*	  in the HMA before interrupt entry points into Bios_Code	*
  2651                                  ;*									*
  2652                                  ;************************************************************************
  2653                                  
  2654                                  EnsureA20On:	; proc near		
  2655 000007C2 E80E00                  		call	IsA20Off
  2656                                  		;jz	short EnableA20
  2657                                  		;retn
  2658                                  		; 18/12/2022
  2659 000007C5 750B                    		jnz	short A20On_retn	
  2660                                  
  2661                                  ; =============== S U B	R O U T	I N E ========================================
  2662                                  
  2663                                  
  2664                                  EnableA20:	; proc near		
  2665 000007C7 50                      		push	ax
  2666 000007C8 53                      		push	bx
  2667 000007C9 B405                    		mov	ah, 5	 ; local enable a20
  2668                                  		;call	cs:xms
  2669 000007CB 2EFF1E[0E00]            		call	far [cs:xms] ; 16/10/2022
  2670 000007D0 5B                      		pop	bx
  2671 000007D1 58                      		pop	ax
  2672                                  A20On_retn:	; 18/12/2022	
  2673 000007D2 C3                      		retn
  2674                                  
  2675                                  ; =============== S U B	R O U T	I N E ========================================
  2676                                  
  2677                                  
  2678                                  IsA20Off:	; proc near		
  2679 000007D3 1E                      		push	ds
  2680 000007D4 06                      		push	es
  2681 000007D5 51                      		push	cx
  2682 000007D6 56                      		push	si
  2683 000007D7 57                      		push	di
  2684 000007D8 2EC536[BA07]            		lds	si, [cs:HiMem]
  2685 000007DD 2EC43E[BE07]            		les	di, [cs:LoMem]
  2686 000007E2 B90800                  		mov	cx, 8
  2687 000007E5 F3A7                    		repe cmpsw
  2688 000007E7 5F                      		pop	di
  2689 000007E8 5E                      		pop	si
  2690 000007E9 59                      		pop	cx
  2691 000007EA 07                      		pop	es
  2692 000007EB 1F                      		pop	ds
  2693 000007EC C3                      		retn
  2694                                  
  2695                                  ; ----------------------------------------------------------------------------
  2696                                  
  2697                                  DisableA20:
  2698 000007ED 50                      		push	ax
  2699 000007EE 53                      		push	bx
  2700 000007EF B406                    		mov	ah, 6		; local disable A20
  2701 000007F1 2EFF1E[0E00]            		call	far [cs:xms]
  2702                                  		;call	cs:xms
  2703 000007F6 5B                      		pop	bx
  2704 000007F7 58                      		pop	ax
  2705 000007F8 C3                      		retn
  2706                                  
  2707                                  ; ----------------------------------------------------------------------------
  2708                                  
  2709                                  ;************************************************************************
  2710                                  ;*									*
  2711                                  ;*	int19 - bootstrap interrupt -- we must restore a bunch of the	*
  2712                                  ;*	  interrupt vectors before resuming the original int19 code	*
  2713                                  ;*									*
  2714                                  ;************************************************************************
  2715                                  
  2716                                  int19:					
  2717 000007F9 0E                      		push	cs
  2718 000007FA 1F                      		pop	ds
  2719 000007FB 8E06[1A00]              		mov	es, [zeroseg]	; 16/10/2022
  2720 000007FF B90500                  		mov	cx, 5		; NUMROMVECTORS
  2721                                  		;mov	si, offset RomVectors
  2722 00000802 BE[0001]                		mov	si, RomVectors	; 19/10/2022
  2723                                  next_int:				
  2724 00000805 AC                      		lodsb			; get int number
  2725 00000806 98                      		cbw			; assume < 128
  2726 00000807 D1E0                    		shl	ax, 1
  2727 00000809 D1E0                    		shl	ax, 1		; int *	4
  2728 0000080B 89C7                    		mov	di, ax
  2729 0000080D AD                      		lodsw
  2730 0000080E AB                      		stosw
  2731 0000080F AD                      		lodsw
  2732 00000810 AB                      		stosw			; install the saved vector
  2733 00000811 E2F2                    		loop	next_int
  2734 00000813 803E[4006]00            		cmp	byte [int19sem], 0 ; 19/10/2022
  2735 00000818 7422                    		jz	short doint19
  2736 0000081A BE[4106]                		mov	si, i19_lst	; stacks code has changed these hardware interrupt vectors
  2737                                  					; stkinit in sysinit1 will initialize int19oldxx values
  2738 0000081D B90E00                  		mov	cx, 14		; num_i19
  2739                                  
  2740                                  i19_restore_loop:			
  2741 00000820 AC                      		lodsb			; get interrupt	number
  2742 00000821 98                      		cbw			; assume < 128
  2743 00000822 89C7                    		mov	di, ax
  2744 00000824 AD                      		lodsw			; get original vector offset
  2745 00000825 89C3                    		mov	bx, ax		; save it
  2746 00000827 AD                      		lodsw
  2747 00000828 83FBFF                  		cmp	bx, 0FFFFh	; check	for 0ffffh (unlikely segment)
  2748 0000082B 740D                    		jz	short i19_restor_1 ; opt no need to check selector too
  2749 0000082D 83F8FF                  		cmp	ax, 0FFFFh	; opt 0ffffh is	unlikely offset
  2750 00000830 7408                    		jz	short i19_restor_1
  2751 00000832 01FF                    		add	di, di
  2752 00000834 01FF                    		add	di, di
  2753 00000836 93                      		xchg	ax, bx
  2754 00000837 AB                      		stosw
  2755 00000838 93                      		xchg	ax, bx
  2756 00000839 AB                      		stosw			; put the vector back
  2757                                  
  2758                                  i19_restor_1:				
  2759 0000083A E2E4                    		loop	i19_restore_loop
  2760                                  
  2761                                  doint19:				
  2762 0000083C 803E[0D00]00            		cmp	byte [inHMA], 0	; ; Is dos running from	HMA
  2763 00000841 7403                    		jz	short SkipVDisk
  2764 00000843 E83000                  		call	EraseVDiskHead	; Then erase our VDISK header at 1MB boundary
  2765                                  					; Some m/c's (AST 386 & HP QS/16 do not clear
  2766                                  					; the memory above 1MB during a	warm boot.
  2767                                  SkipVDisk:				
  2768 00000846 CD19                    		int	19h		; DISK BOOT
  2769                                  					; causes reboot	of disk	system
  2770                                  
  2771                                  ; =============== S U B	R O U T	I N E ========================================
  2772                                  
  2773                                  ;-----------------------------------------------------------------------------
  2774                                  ;
  2775                                  ; procedure : int15
  2776                                  ;
  2777                                  ;		Int15 handler for recognizing ctrl-alt-del seq
  2778                                  ;		If it recognizes ctrl-alt-del and if DOS was
  2779                                  ;		is running high, it Erases the VDISK header
  2780                                  ;		present at 1MB boundary
  2781                                  ;
  2782                                  ;-----------------------------------------------------------------------------
  2783                                  
  2784                                  ; 16/10/2022
  2785                                  ;DELKEY		equ	53h
  2786                                  ;ROMDATASEG	equ	40h
  2787                                  KBFLAG		equ	17h
  2788                                  ;CTRLSTATE	equ	04h
  2789                                  ;ALTSTATE	equ	08h
  2790                                  
  2791                                  Int15:		; proc near		
  2792                                  		;cmp	ax, 4F00h+DELKEY
  2793 00000848 3D534F                  		cmp	ax, 4F53h	; del keystroke ?
  2794 0000084B 7405                    		jz	short int15_1
  2795 0000084D 2EFF2E[0B01]            		jmp	far [cs:Old15]	; 16/10/2022
  2796                                  		;jmp	cs:Old15
  2797                                  ; ----------------------------------------------------------------------------
  2798                                  
  2799                                  int15_1:				
  2800 00000852 1E                      		push	ds
  2801 00000853 50                      		push	ax
  2802 00000854 B84000                  		mov	ax, 40h		; ROMDATASEG
  2803 00000857 8ED8                    		mov	ds, ax
  2804                                  		;mov	al, ds:17h	; [KBFLAG]
  2805                                  		; 16/10/2022
  2806 00000859 A01700                  		mov	al, [KBFLAG]
  2807 0000085C 240C                    		and	al, 0Ch		; (CTRLSTATE | ALTSTATE)
  2808 0000085E 3C0C                    		cmp	al, 0Ch		; (CTRLSTATE | ALTSTATE)
  2809 00000860 750C                    		jnz	short int15_2
  2810 00000862 0E                      		push	cs
  2811 00000863 1F                      		pop	ds
  2812 00000864 803E[0D00]00            		cmp	byte [inHMA], 0	; is DOS running from HMA
  2813 00000869 7403                    		jz	short int15_2
  2814 0000086B E80800                  		call	EraseVDiskHead
  2815                                  int15_2:				
  2816 0000086E 58                      		pop	ax
  2817 0000086F 1F                      		pop	ds
  2818 00000870 F9                      		stc
  2819 00000871 2EFF2E[0B01]            		jmp	far [cs:Old15]	; 16/10/2022
  2820                                  		;jmp	cs:Old15
  2821                                  
  2822                                  ; =============== S U B	R O U T	I N E ========================================
  2823                                  
  2824                                  ;-----------------------------------------------------------------------------
  2825                                  ;
  2826                                  ; procedure : EraseVDiskHead
  2827                                  ;
  2828                                  ;		Erases the VDisk Header present in the 1MB boundary
  2829                                  ;
  2830                                  ;-----------------------------------------------------------------------------
  2831                                  
  2832                                  EraseVDiskHead:	; proc near		
  2833 00000876 50                      		push	ax
  2834 00000877 51                      		push	cx
  2835 00000878 57                      		push	di
  2836 00000879 06                      		push	es
  2837 0000087A E845FF                  		call	EnsureA20On
  2838 0000087D B8FFFF                  		mov	ax, 0FFFFh	; HMA seg
  2839 00000880 8EC0                    		mov	es, ax
  2840 00000882 BF1000                  		mov	di, 10h		; point	to VDISK header
  2841 00000885 B91000                  		mov	cx, 10h		; size of vdisk	header
  2842 00000888 31C0                    		xor	ax, ax
  2843 0000088A F3AB                    		rep stosw		; clear	it
  2844 0000088C 07                      		pop	es
  2845 0000088D 5F                      		pop	di
  2846 0000088E 59                      		pop	cx
  2847 0000088F 58                      		pop	ax
  2848 00000890 C3                      		retn
  2849                                  
  2850                                  ; ----------------------------------------------------------------------------
  2851                                  
  2852                                  ;************************************************************************
  2853                                  ;*									*
  2854                                  ;*	the int2f handler chains up to Bios_Code through here.		*
  2855                                  ;*	  it returns through one of the three functions that follow.	*
  2856                                  ;*	  notice that we'll assume we're being entered from DOS, so	*
  2857                                  ;*	  that we're guaranteed to be A20 enabled if needed		*
  2858                                  ;*									*
  2859                                  ;************************************************************************
  2860                                  
  2861                                  int_2f:		
  2862 00000891 2EFF2E[E606]            		jmp	far [cs:bcode_i2f] ; 16/10/2022			
  2863                                  		;jmp	dword ptr cs:bcode_i2f ; far [cs:bcode_i2f]
  2864                                  
  2865                                  ; ----------------------------------------------------------------------------
  2866                                  
  2867                                  ; re-enter here to transition out of hma mode and jmp to dsk_entry
  2868                                  ; note:  is it really necessary to transiton out and then back in?
  2869                                  ;	 It's not as if this is a really speed critical function.
  2870                                  ;	 might as well do whatever's most compact.
  2871                                  
  2872                                  i2f_dskentry:				
  2873 00000896 E9A5FE                  		jmp	dsk_entry
  2874                                  
  2875                                  ; ----------------------------------------------------------------------------
  2876                                  
  2877                                  ;************************************************************************
  2878                                  ;*									*
  2879                                  ;*	re_init - called back by sysinit after a bunch of stuff		*
  2880                                  ;*		is done. presently does nothing. affects no		*
  2881                                  ;*		registers!						*
  2882                                  ;*									*
  2883                                  ;************************************************************************
  2884                                  
  2885                                  ; 09/12/2022
  2886                                  ; re_init_:
  2887                                  re_init:				; called back by sysinit after
  2888 00000899 CB                      		retf			; a bunch of stuff is done.
  2889                                  					; presently does nothing
  2890                                  
  2891                                  ; ----------------------------------------------------------------------------
  2892                                  
  2893                                  ;SR; WIN386 support
  2894                                  
  2895                                  ; WIN386 instance data structure
  2896                                  ;
  2897                                  ; Here is a Win386 startup info structure which we set up and to which
  2898                                  ; we return a pointer when Win386 initializes.
  2899                                  
  2900 0000089A 0300                    Win386_SI:	db 3, 0			; SI_Version
  2901                                  					; Startup Info for Win386
  2902 0000089C 00000000                SI_Next:	dd 0			; pointer to next info structure
  2903 000008A0 00000000                		dd 0			; a field we don't need
  2904 000008A4 00000000                		dd 0			; another field	we don't need
  2905 000008A8 [AC08]                  SI_Instance:	dw Instance_Table
  2906 000008AA 7000                    		dw 70h	; Bios_Data	; far pointer to instance table
  2907                                  
  2908                                  ; This table gives Win386 the instance data in the BIOS and ROM-BIOS data
  2909                                  ; areas. Note that the address and size of the hardware stacks must
  2910                                  ; be calculated and inserted at boot time.
  2911                                  
  2912 000008AC 00005000                Instance_Table:	dw 0, 50h		; print	screen status...
  2913 000008B0 0200                    		dw 2			; ... 2	bytes
  2914 000008B2 0E005000                		dw 0Eh,	50h		; ROM Basic data...
  2915 000008B6 1400                    		dw 14h			; ... 14H bytes
  2916 000008B8 [0C00]                  		dw altah		; a con	device buffer...
  2917 000008BA 7000                    		dw 70h			; Bios_Data segment
  2918 000008BC 0100                    		dw 1			; ... 1 byte
  2919                                  
  2920                                  NextStack:
  2921                                  
  2922                                  ; NOTE:  If stacks are disabled by STACKS=0,0, the following
  2923                                  ;	instance items WILL NOT be filled in by SYSINIT.
  2924                                  ;	That's just fine as long as these are the last items
  2925                                  ;	in the instance list since the first item is initialized
  2926                                  ;	to 0000 at load time.
  2927                                  
  2928 000008BE 00000000                		dw 0, 0			; pointer to next stack	to be used...
  2929 000008C2 0200                    		dw 2			; ... 2 bytes
  2930 000008C4 00000000                IT_StackLoc:	dd 0			; location of hardware stacks
  2931 000008C8 0000                    IT_StackSize:	dw 0			; size of hardware stacks
  2932 000008CA 00000000                		dd 0			; terminate the	instance table
  2933                                  
  2934                                  					;SR;
  2935 000008CE 00                      IsWin386:	db 0			; Flag to indicate whether
  2936                                  					; Win386 is running or not
  2937                                  ;-----------------------------------------------------------------------------
  2938                                  
  2939                                  ;This routine was originally in BIOS_CODE but this causes a lot of problems
  2940                                  ;when we call it including checking of A20. The code being only about 
  2941                                  ;30 bytes, we might as well put it in BIOS_DATA
  2942                                  
  2943                                  V86_Crit_SetFocus:			
  2944 000008CF 57                      		push	di
  2945 000008D0 06                      		push	es
  2946 000008D1 53                      		push	bx
  2947 000008D2 50                      		push	ax
  2948 000008D3 31FF                    		xor	di, di
  2949 000008D5 8EC7                    		mov	es, di
  2950 000008D7 BB1500                  		mov	bx, 15h		; Device ID of DOSMGR device
  2951 000008DA B88416                  		mov	ax, 1684h	; Get API entry	point
  2952 000008DD CD2F                    		int	2Fh		; - Multiplex -	MS WINDOWS - GET DEVICE	API ENTRY POINT
  2953                                  					; BX = virtual device (VxD) ID,	ES:DI =	0000h:0000h
  2954                                  					; Return: ES:DI	-> VxD API entry point,	or 0:0 if the VxD does not support an API
  2955 000008DF 8CC0                    		mov	ax, es
  2956 000008E1 09F8                    		or	ax, di
  2957 000008E3 740B                    		jz	short Skip	; Here,	es:di is address of API	routine.
  2958                                  					; Set up stack frame to	simulate a call.
  2959 000008E5 0E                      		push	cs
  2960                                  		;mov	ax, offset Skip
  2961 000008E6 B8[F008]                		mov	ax, Skip
  2962 000008E9 50                      		push	ax
  2963 000008EA 06                      		push	es
  2964 000008EB 57                      		push	di		; API far call address
  2965 000008EC B80100                  		mov	ax, 1		; SetFocus function number
  2966 000008EF CB                      		retf			; do the call
  2967                                  ;-----------------------------------------------------------------------------
  2968                                  
  2969                                  Skip:					
  2970 000008F0 58                      		pop	ax
  2971 000008F1 5B                      		pop	bx
  2972 000008F2 07                      		pop	es
  2973 000008F3 5F                      		pop	di
  2974 000008F4 CB                      		retf
  2975                                  
  2976                                  ;End WIN386 support
  2977                                  
  2978                                  ; ----------------------------------------------------------------------------
  2979                                  
  2980                                  ; 17/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
  2981                                  
  2982                                  ; 09/12/2022
  2983                                  ;SYSINITSEG	equ 46Dh  ; SYSINIT segment
  2984                                  ;DOSLOADSEG	equ 83Fh  ; MSDOS.SYS (kernel) loading segment		
  2985                                  ; (followings are in sysinit segment)
  2986                                  ;FTryToMovDOSHi	equ 0A84h ; (procedure in SYSINIT segment)
  2987                                  FTRYTOMOVDOSHI	equ FTryToMovDOSHi ; SYSINIT section
  2988                                  ;DEVICELIST	equ 273h
  2989                                  DEVICELIST	equ DEVICE_LIST	; SYSINIT section 	
  2990                                  ;MEMORYSIZE	equ 292h	
  2991                                  MEMORYSIZE	equ MEMORY_SIZE	; SYSINIT section
  2992                                  ;DEFAULTDRIVE	equ 296h
  2993                                  DEFAULTDRIVE	equ DEFAULT_DRIVE ; SYSINIT section
  2994                                  ;;currentdoslocation equ 271h
  2995                                  ;CURRENTDOSLOCATION equ 271h
  2996                                  CURRENTDOSLOCATION equ CURRENT_DOS_LOCATION  ; SYSINIT section
  2997                                  ;SYSINITSTART	equ 267h
  2998                                  SYSINITSTART	equ SYSINIT  ; SYSINIT section
  2999                                  ; 18/10/2022
  3000                                  ;toomanydrivesflag equ 3FFh 
  3001                                  TOOMANYDRIVESFLAG equ toomanydrivesflag ; SYSINIT section	
  3002                                  
  3003                                  ; ----------------------------------------------------------------------------
  3004                                  
  3005 000008F5 FFFF                    FreeHMAPtr:	dw 0FFFFh		
  3006                                  ;MoveDOSIntoHMA: dd 46D0A84h 		; FTryToMovDOSHi
  3007                                  					; (procedure in	SYSINIT	segment)
  3008                                  ; 17/10/2022
  3009 000008F7 [210A]                  MoveDOSIntoHMA:	dw FTRYTOMOVDOSHI	; 09/12/2022
  3010 000008F9 5704                    		dw SYSINITSEG	
  3011                                  
  3012                                  ;SR;
  3013                                  ; A communication block has been setup between the DOS and the BIOS. All
  3014                                  ;the data starting from SysinitPresent will be part of the data block. 
  3015                                  ;Right now, this is the only data being communicated. It can be expanded 
  3016                                  ;later to add more stuff
  3017                                  
  3018 000008FB 00                      SysinitPresent:	db 0			
  3019 000008FC 0000                    endfloppy:	db 0, 0
  3020                                  
  3021                                  ; ----------------------------------------------------------------------------			
  3022                                  
  3023                                  ; Bios_Data ends
  3024                                  	
  3025                                  ; Possibly disposable BIOS data
  3026                                  ; This data follows the	regular	BIOS data,
  3027                                  ; and is part of the same group.
  3028                                  
  3029 000008FE 4E4F204E414D452020-     nul_vid:	db 'NO NAME    ',0      
  3029 00000907 202000             
  3030                                  					; null volume id
  3031 0000090A 4E4F204E414D452020-     tmp_vid:	db 'NO NAME    ',0      
  3031 00000913 202000             
  3032                                  					; vid scratch buffer
  3033 00000916 80                      harddrv:	db 80h			
  3034                                  
  3035                                  end96tpi:
  3036                                  
  3037                                  ;;*********************************************************************
  3038                                  ;;memory allocation for bdss
  3039                                  ;;*********************************************************************
  3040                                  ;
  3041                                  ;;max_mini_dsk_num equ 23	; max # of mini disk ibmbio can support
  3042                                  ;
  3043                                  ;;bdss	BDS_STRUC (2+max_mini_dsk_num) dup (<>)	; currently max. 25
  3044                                  ;
  3045                                  ;bdss:	times BDS.size*(2+max_mini_dsk_num) db 0
  3046                                  
  3047 00000917 FFFF                    bdss:		dw 0FFFFh		
  3048 00000919 000050030002010100-     		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
  3048 00000922 0210000000F8       
  3049 00000928 010000000000000000-     		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
  3049 00000931 000000000000000003 
  3050 0000093A 200028000000000000-     		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
  3050 00000943 00000000000000     
  3051 0000094A 000000000000000000-     		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
  3051 00000953 000000000000000000 
  3052 0000095C 00FF010000004E4F20-     		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
  3052 00000965 4E414D45           
  3053 00000969 202020200000000000-     		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
  3053 00000972 46415431           
  3054 00000976 3220202000              		db 32h,	20h, 20h, 20h, 0
  3055 0000097B FFFF                    		dw 0FFFFh
  3056 0000097D 000050030002010100-     		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
  3056 00000986 0210000000F8       
  3057 0000098C 010000000000000000-     		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
  3057 00000995 000000000000000003 
  3058 0000099E 200028000000000000-     		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
  3058 000009A7 00000000000000     
  3059 000009AE 000000000000000000-     		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
  3059 000009B7 000000000000000000 
  3060 000009C0 00FF010000004E4F20-     		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
  3060 000009C9 4E414D45           
  3061 000009CD 202020200000000000-     		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
  3061 000009D6 46415431           
  3062 000009DA 3220202000              		db 32h,	20h, 20h, 20h, 0
  3063 000009DF FFFF                    		dw 0FFFFh
  3064 000009E1 000050030002010100-     		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
  3064 000009EA 0210000000F8       
  3065 000009F0 010000000000000000-     		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
  3065 000009F9 000000000000000003 
  3066 00000A02 200028000000000000-     		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
  3066 00000A0B 00000000000000     
  3067 00000A12 000000000000000000-     		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
  3067 00000A1B 000000000000000000 
  3068 00000A24 00FF010000004E4F20-     		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
  3068 00000A2D 4E414D45           
  3069 00000A31 202020200000000000-     		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
  3069 00000A3A 46415431           
  3070 00000A3E 3220202000              		db 32h,	20h, 20h, 20h, 0
  3071 00000A43 FFFF                    		dw 0FFFFh
  3072 00000A45 000050030002010100-     		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
  3072 00000A4E 0210000000F8       
  3073 00000A54 010000000000000000-     		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
  3073 00000A5D 000000000000000003 
  3074 00000A66 200028000000000000-     		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
  3074 00000A6F 00000000000000     
  3075 00000A76 000000000000000000-     		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
  3075 00000A7F 000000000000000000 
  3076 00000A88 00FF010000004E4F20-     		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
  3076 00000A91 4E414D45           
  3077 00000A95 202020200000000000-     		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
  3077 00000A9E 46415431           
  3078 00000AA2 3220202000              		db 32h,	20h, 20h, 20h, 0
  3079 00000AA7 FFFF                    		dw 0FFFFh
  3080 00000AA9 000050030002010100-     		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
  3080 00000AB2 0210000000F8       
  3081 00000AB8 010000000000000000-     		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
  3081 00000AC1 000000000000000003 
  3082 00000ACA 200028000000000000-     		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
  3082 00000AD3 00000000000000     
  3083 00000ADA 000000000000000000-     		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
  3083 00000AE3 000000000000000000 
  3084 00000AEC 00FF010000004E4F20-     		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
  3084 00000AF5 4E414D45           
  3085 00000AF9 202020200000000000-     		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
  3085 00000B02 46415431           
  3086 00000B06 3220202000              		db 32h,	20h, 20h, 20h, 0
  3087 00000B0B FFFF                    		dw 0FFFFh
  3088 00000B0D 000050030002010100-     		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
  3088 00000B16 0210000000F8       
  3089 00000B1C 010000000000000000-     		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
  3089 00000B25 000000000000000003 
  3090 00000B2E 200028000000000000-     		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
  3090 00000B37 00000000000000     
  3091 00000B3E 000000000000000000-     		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
  3091 00000B47 000000000000000000 
  3092 00000B50 00FF010000004E4F20-     		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
  3092 00000B59 4E414D45           
  3093 00000B5D 202020200000000000-     		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
  3093 00000B66 46415431           
  3094 00000B6A 3220202000              		db 32h,	20h, 20h, 20h, 0
  3095 00000B6F FFFF                    		dw 0FFFFh
  3096 00000B71 000050030002010100-     		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
  3096 00000B7A 0210000000F8       
  3097 00000B80 010000000000000000-     		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
  3097 00000B89 000000000000000003 
  3098 00000B92 200028000000000000-     		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
  3098 00000B9B 00000000000000     
  3099 00000BA2 000000000000000000-     		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
  3099 00000BAB 000000000000000000 
  3100 00000BB4 00FF010000004E4F20-     		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
  3100 00000BBD 4E414D45           
  3101 00000BC1 202020200000000000-     		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
  3101 00000BCA 46415431           
  3102 00000BCE 3220202000              		db 32h,	20h, 20h, 20h, 0
  3103 00000BD3 FFFF                    		dw 0FFFFh
  3104 00000BD5 000050030002010100-     		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
  3104 00000BDE 0210000000F8       
  3105 00000BE4 010000000000000000-     		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
  3105 00000BED 000000000000000003 
  3106 00000BF6 200028000000000000-     		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
  3106 00000BFF 00000000000000     
  3107 00000C06 000000000000000000-     		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
  3107 00000C0F 000000000000000000 
  3108 00000C18 00FF010000004E4F20-     		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
  3108 00000C21 4E414D45           
  3109 00000C25 202020200000000000-     		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
  3109 00000C2E 46415431           
  3110 00000C32 3220202000              		db 32h,	20h, 20h, 20h, 0
  3111 00000C37 FFFF                    		dw 0FFFFh
  3112 00000C39 000050030002010100-     		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
  3112 00000C42 0210000000F8       
  3113 00000C48 010000000000000000-     		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
  3113 00000C51 000000000000000003 
  3114 00000C5A 200028000000000000-     		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
  3114 00000C63 00000000000000     
  3115 00000C6A 000000000000000000-     		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
  3115 00000C73 000000000000000000 
  3116 00000C7C 00FF010000004E4F20-     		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
  3116 00000C85 4E414D45           
  3117 00000C89 202020200000000000-     		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
  3117 00000C92 46415431           
  3118 00000C96 3220202000              		db 32h,	20h, 20h, 20h, 0
  3119 00000C9B FFFF                    		dw 0FFFFh
  3120 00000C9D 000050030002010100-     		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
  3120 00000CA6 0210000000F8       
  3121 00000CAC 010000000000000000-     		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
  3121 00000CB5 000000000000000003 
  3122 00000CBE 200028000000000000-     		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
  3122 00000CC7 00000000000000     
  3123 00000CCE 000000000000000000-     		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
  3123 00000CD7 000000000000000000 
  3124 00000CE0 00FF010000004E4F20-     		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
  3124 00000CE9 4E414D45           
  3125 00000CED 202020200000000000-     		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
  3125 00000CF6 46415431           
  3126 00000CFA 3220202000              		db 32h,	20h, 20h, 20h, 0
  3127 00000CFF FFFF                    		dw 0FFFFh
  3128 00000D01 000050030002010100-     		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
  3128 00000D0A 0210000000F8       
  3129 00000D10 010000000000000000-     		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
  3129 00000D19 000000000000000003 
  3130 00000D22 200028000000000000-     		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
  3130 00000D2B 00000000000000     
  3131 00000D32 000000000000000000-     		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
  3131 00000D3B 000000000000000000 
  3132 00000D44 00FF010000004E4F20-     		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
  3132 00000D4D 4E414D45           
  3133 00000D51 202020200000000000-     		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
  3133 00000D5A 46415431           
  3134 00000D5E 3220202000              		db 32h,	20h, 20h, 20h, 0
  3135 00000D63 FFFF                    		dw 0FFFFh
  3136 00000D65 000050030002010100-     		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
  3136 00000D6E 0210000000F8       
  3137 00000D74 010000000000000000-     		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
  3137 00000D7D 000000000000000003 
  3138 00000D86 200028000000000000-     		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
  3138 00000D8F 00000000000000     
  3139 00000D96 000000000000000000-     		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
  3139 00000D9F 000000000000000000 
  3140 00000DA8 00FF010000004E4F20-     		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
  3140 00000DB1 4E414D45           
  3141 00000DB5 202020200000000000-     		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
  3141 00000DBE 46415431           
  3142 00000DC2 3220202000              		db 32h,	20h, 20h, 20h, 0
  3143 00000DC7 FFFF                    		dw 0FFFFh
  3144 00000DC9 000050030002010100-     		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
  3144 00000DD2 0210000000F8       
  3145 00000DD8 010000000000000000-     		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
  3145 00000DE1 000000000000000003 
  3146 00000DEA 200028000000000000-     		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
  3146 00000DF3 00000000000000     
  3147 00000DFA 000000000000000000-     		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
  3147 00000E03 000000000000000000 
  3148 00000E0C 00FF010000004E4F20-     		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
  3148 00000E15 4E414D45           
  3149 00000E19 202020200000000000-     		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
  3149 00000E22 46415431           
  3150 00000E26 3220202000              		db 32h,	20h, 20h, 20h, 0
  3151 00000E2B FFFF                    		dw 0FFFFh
  3152 00000E2D 000050030002010100-     		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
  3152 00000E36 0210000000F8       
  3153 00000E3C 010000000000000000-     		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
  3153 00000E45 000000000000000003 
  3154 00000E4E 200028000000000000-     		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
  3154 00000E57 00000000000000     
  3155 00000E5E 000000000000000000-     		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
  3155 00000E67 000000000000000000 
  3156 00000E70 00FF010000004E4F20-     		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
  3156 00000E79 4E414D45           
  3157 00000E7D 202020200000000000-     		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
  3157 00000E86 46415431           
  3158 00000E8A 3220202000              		db 32h,	20h, 20h, 20h, 0
  3159 00000E8F FFFF                    		dw 0FFFFh
  3160 00000E91 000050030002010100-     		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
  3160 00000E9A 0210000000F8       
  3161 00000EA0 010000000000000000-     		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
  3161 00000EA9 000000000000000003 
  3162 00000EB2 200028000000000000-     		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
  3162 00000EBB 00000000000000     
  3163 00000EC2 000000000000000000-     		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
  3163 00000ECB 000000000000000000 
  3164 00000ED4 00FF010000004E4F20-     		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
  3164 00000EDD 4E414D45           
  3165 00000EE1 202020200000000000-     		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
  3165 00000EEA 46415431           
  3166 00000EEE 3220202000              		db 32h,	20h, 20h, 20h, 0
  3167 00000EF3 FFFF                    		dw 0FFFFh
  3168 00000EF5 000050030002010100-     		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
  3168 00000EFE 0210000000F8       
  3169 00000F04 010000000000000000-     		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
  3169 00000F0D 000000000000000003 
  3170 00000F16 200028000000000000-     		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
  3170 00000F1F 00000000000000     
  3171 00000F26 000000000000000000-     		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
  3171 00000F2F 000000000000000000 
  3172 00000F38 00FF010000004E4F20-     		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
  3172 00000F41 4E414D45           
  3173 00000F45 202020200000000000-     		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
  3173 00000F4E 46415431           
  3174 00000F52 3220202000              		db 32h,	20h, 20h, 20h, 0
  3175 00000F57 FFFF                    		dw 0FFFFh
  3176 00000F59 000050030002010100-     		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
  3176 00000F62 0210000000F8       
  3177 00000F68 010000000000000000-     		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
  3177 00000F71 000000000000000003 
  3178 00000F7A 200028000000000000-     		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
  3178 00000F83 00000000000000     
  3179 00000F8A 000000000000000000-     		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
  3179 00000F93 000000000000000000 
  3180 00000F9C 00FF010000004E4F20-     		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
  3180 00000FA5 4E414D45           
  3181 00000FA9 202020200000000000-     		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
  3181 00000FB2 46415431           
  3182 00000FB6 3220202000              		db 32h,	20h, 20h, 20h, 0
  3183 00000FBB FFFF                    		dw 0FFFFh
  3184 00000FBD 000050030002010100-     		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
  3184 00000FC6 0210000000F8       
  3185 00000FCC 010000000000000000-     		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
  3185 00000FD5 000000000000000003 
  3186 00000FDE 200028000000000000-     		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
  3186 00000FE7 00000000000000     
  3187 00000FEE 000000000000000000-     		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
  3187 00000FF7 000000000000000000 
  3188 00001000 00FF010000004E4F20-     		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
  3188 00001009 4E414D45           
  3189 0000100D 202020200000000000-     		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
  3189 00001016 46415431           
  3190 0000101A 3220202000              		db 32h,	20h, 20h, 20h, 0
  3191 0000101F FFFF                    		dw 0FFFFh
  3192 00001021 000050030002010100-     		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
  3192 0000102A 0210000000F8       
  3193 00001030 010000000000000000-     		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
  3193 00001039 000000000000000003 
  3194 00001042 200028000000000000-     		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
  3194 0000104B 00000000000000     
  3195 00001052 000000000000000000-     		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
  3195 0000105B 000000000000000000 
  3196 00001064 00FF010000004E4F20-     		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
  3196 0000106D 4E414D45           
  3197 00001071 202020200000000000-     		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
  3197 0000107A 46415431           
  3198 0000107E 3220202000              		db 32h,	20h, 20h, 20h, 0
  3199 00001083 FFFF                    		dw 0FFFFh
  3200 00001085 000050030002010100-     		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
  3200 0000108E 0210000000F8       
  3201 00001094 010000000000000000-     		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
  3201 0000109D 000000000000000003 
  3202 000010A6 200028000000000000-     		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
  3202 000010AF 00000000000000     
  3203 000010B6 000000000000000000-     		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
  3203 000010BF 000000000000000000 
  3204 000010C8 00FF010000004E4F20-     		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
  3204 000010D1 4E414D45           
  3205 000010D5 202020200000000000-     		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
  3205 000010DE 46415431           
  3206 000010E2 3220202000              		db 32h,	20h, 20h, 20h, 0
  3207 000010E7 FFFF                    		dw 0FFFFh
  3208 000010E9 000050030002010100-     		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
  3208 000010F2 0210000000F8       
  3209 000010F8 010000000000000000-     		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
  3209 00001101 000000000000000003 
  3210 0000110A 200028000000000000-     		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
  3210 00001113 00000000000000     
  3211 0000111A 000000000000000000-     		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
  3211 00001123 000000000000000000 
  3212 0000112C 00FF010000004E4F20-     		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
  3212 00001135 4E414D45           
  3213 00001139 202020200000000000-     		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
  3213 00001142 46415431           
  3214 00001146 3220202000              		db 32h,	20h, 20h, 20h, 0
  3215 0000114B FFFF                    		dw 0FFFFh
  3216 0000114D 000050030002010100-     		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
  3216 00001156 0210000000F8       
  3217 0000115C 010000000000000000-     		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
  3217 00001165 000000000000000003 
  3218 0000116E 200028000000000000-     		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
  3218 00001177 00000000000000     
  3219 0000117E 000000000000000000-     		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
  3219 00001187 000000000000000000 
  3220 00001190 00FF010000004E4F20-     		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
  3220 00001199 4E414D45           
  3221 0000119D 202020200000000000-     		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
  3221 000011A6 46415431           
  3222 000011AA 3220202000              		db 32h,	20h, 20h, 20h, 0
  3223 000011AF FFFF                    		dw 0FFFFh
  3224 000011B1 000050030002010100-     		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
  3224 000011BA 0210000000F8       
  3225 000011C0 010000000000000000-     		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
  3225 000011C9 000000000000000003 
  3226 000011D2 200028000000000000-     		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
  3226 000011DB 00000000000000     
  3227 000011E2 000000000000000000-     		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
  3227 000011EB 000000000000000000 
  3228 000011F4 00FF010000004E4F20-     		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
  3228 000011FD 4E414D45           
  3229 00001201 202020200000000000-     		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
  3229 0000120A 46415431           
  3230 0000120E 3220202000              		db 32h,	20h, 20h, 20h, 0
  3231 00001213 FFFF                    		dw 0FFFFh
  3232 00001215 000050030002010100-     		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
  3232 0000121E 0210000000F8       
  3233 00001224 010000000000000000-     		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
  3233 0000122D 000000000000000003 
  3234 00001236 200028000000000000-     		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
  3234 0000123F 00000000000000     
  3235 00001246 000000000000000000-     		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
  3235 0000124F 000000000000000000 
  3236 00001258 00FF010000004E4F20-     		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
  3236 00001261 4E414D45           
  3237 00001265 202020200000000000-     		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
  3237 0000126E 46415431           
  3238 00001272 3220202000              		db 32h,	20h, 20h, 20h, 0
  3239 00001277 FFFF                    		dw 0FFFFh
  3240 00001279 000050030002010100-     		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
  3240 00001282 0210000000F8       
  3241 00001288 010000000000000000-     		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
  3241 00001291 000000000000000003 
  3242 0000129A 200028000000000000-     		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
  3242 000012A3 00000000000000     
  3243 000012AA 000000000000000000-     		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
  3243 000012B3 000000000000000000 
  3244 000012BC 00FF010000004E4F20-     		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
  3244 000012C5 4E414D45           
  3245 000012C9 202020200000000000-     		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
  3245 000012D2 46415431           
  3246 000012D6 3220202000              		db 32h,	20h, 20h, 20h, 0
  3247 000012DB 00                      		db 0
  3248                                  
  3249                                  ;---------------------------------------------------------------------------
  3250                                  ; Possibly disposable data, goes at end of data group
  3251                                  ;***************************************************************************
  3252                                  
  3253                                  ; Possibly disposable data, goes at end of data group
  3254                                  
  3255                                  ;***	ibm_disk_io - main routine, fixes at rom bug
  3256                                  ;
  3257                                  ;	entry:	(ah) = function, 02 or 0a for read.
  3258                                  ;		(dl) = drive number (80h or 81h).
  3259                                  ;		(dh) = head number.
  3260                                  ;		(ch) = cylinder number.
  3261                                  ;		(cl) = sector number (high 2 bits has cylinder number).
  3262                                  ;		(al) = number of sectors.
  3263                                  ;		(es:bx) = address of read buffer.
  3264                                  ;		for more on register contents see rom bios listing.
  3265                                  ;		stack set up for return by an iret.
  3266                                  ;
  3267                                  ;	exit:	(ah) = status of current operation.
  3268                                  ;		(cy) = 1 if failed, 0 if successful.
  3269                                  ;		for other register contents see rom bios listing.
  3270                                  ;
  3271                                  ;	uses:	
  3272                                  ;
  3273                                  ;
  3274                                  ;	warning: uses old13 vector for non-read calls.
  3275                                  ;		does direct calls to the at rom.
  3276                                  ;		does segment arithmatic.
  3277                                  ;
  3278                                  ;	effects: performs disk i/o operation.
  3279                                  
  3280                                  ; 16/10/2022
  3281                                  ; 28/05/2019
  3282                                  cmd_block equ 42h ; ROMBIOS DATA segment (40h) offset 42h ; 13/12/2022
  3283                                  
  3284                                  ;* offsets into cmd_block for registers
  3285                                  
  3286                                  pre_comp equ 0	;write pre-compensation
  3287                                  sec_cnt	 equ 1	;sector count
  3288                                  sec_num	 equ 2	;sector number
  3289                                  cyl_low	 equ 3	;cylinder number, low part
  3290                                  cyl_high equ 4	;cylinder number, high part
  3291                                  drv_head equ 5	;drive/head (bit 7 = ecc mode, bit 5 = 512 byte sectors, 
  3292                                  		;            bit 4 = drive number, bits 3-0 have head number)
  3293                                  cmd_reg  equ 6	;command register
  3294                                  
  3295                                  ; 01/10/2022
  3296                                  disk_status1	equ 74h
  3297                                  hf_num		equ 75h
  3298                                  control_byte	equ 76h
  3299                                  
  3300                                  ibm_disk_io:				
  3301 000012DC 80FA80                  		cmp	dl, 80h		; main routine,	fixes at rom bug
  3302 000012DF 720A                    		jb	short atd1	; pass through floppy disk calls. 
  3303 000012E1 80FC02                  		cmp	ah, 2
  3304 000012E4 740A                    		jz	short atd2	; intercept call 02 (read sectors).
  3305 000012E6 80FC0A                  		cmp	ah, 0Ah
  3306 000012E9 7405                    		jz	short atd2	; and call 0Ah (read long).
  3307                                  atd1:
  3308 000012EB 2EFF2E[0601]            		jmp	far [cs:Old13]					
  3309                                  		;jmp	cs:Old13	; use rom int 13h handler
  3310                                  ;-----------------------------------------------------------------------------
  3311                                  
  3312                                  atd2:					
  3313 000012F0 53                      		push	bx
  3314 000012F1 51                      		push	cx
  3315 000012F2 52                      		push	dx
  3316 000012F3 57                      		push	di
  3317 000012F4 1E                      		push	ds
  3318 000012F5 06                      		push	es
  3319 000012F6 50                      		push	ax
  3320 000012F7 B84000                  		mov	ax, 40h		; bioseg (rombios data segment)
  3321                                  					; establish bios segment addressing
  3322 000012FA 8ED8                    		mov	ds, ax
  3323                                  		; 16/10/2022
  3324 000012FC C606740000              		mov	byte [disk_status1], 0
  3325                                  		;mov	byte ptr ds:74h, 0 ; [disk_status1]
  3326                                  					; initially no error code.
  3327 00001301 80E27F                  		and	dl, 7Fh		; mask to hard disk number
  3328 00001304 3A167500                		cmp	dl, [hf_num]
  3329                                  		;cmp	dl, ds:75h	; [hf_num] ; 40h:75h
  3330 00001308 7207                    		jb	short atd3	; disk number in range
  3331                                  		;mov	byte ptr ds:74h, 1 ; bad_disk
  3332 0000130A C606740001              		mov	byte [disk_status1], 1
  3333 0000130F EB20                    		jmp	short atd4	; disk number out of range error,
  3334                                  					; return
  3335                                  ; ----------------------------------------------------------------------------
  3336                                  
  3337                                  atd3:					
  3338 00001311 53                      		push	bx
  3339 00001312 8CC0                    		mov	ax, es
  3340 00001314 C1EB04                  		shr	bx, 4		; make es:bx to seg:000x form.
  3341 00001317 01D8                    		add	ax, bx
  3342 00001319 8EC0                    		mov	es, ax
  3343 0000131B 5B                      		pop	bx
  3344 0000131C 83E30F                  		and	bx, 0Fh
  3345 0000131F 0E                      		push	cs
  3346 00001320 E8DF00                  		call	check_dma
  3347 00001323 720C                    		jb	short atd4	; abort if dma across segment boundary
  3348 00001325 58                      		pop	ax
  3349 00001326 50                      		push	ax
  3350 00001327 E81A00                  		call	setcmd		; set up command block for disk op
  3351 0000132A BAF603                  		mov	dx, 3F6h	; hf_reg_port 
  3352 0000132D EE                      		out	dx, al		; write out command modifier
  3353 0000132E E86B00                  		call	docmd		; carry out command
  3354                                  ; ----------------------------------------------------------------------------
  3355                                  
  3356                                  atd4:	
  3357                                  
  3358                                  ;  new code - let logical or clear carry and then set carry if ah!=0
  3359                                  ;	      and save a couple bytes while were at it.
  3360                                  				
  3361 00001331 58                      		pop	ax
  3362                                  		;mov	ah, ds:74h	; [disk_status1]
  3363 00001332 8A267400                		mov	ah, [disk_status1]
  3364 00001336 08E4                    		or	ah, ah
  3365 00001338 7401                    		jz	short atd5
  3366 0000133A F9                      		stc
  3367                                  atd5:					
  3368 0000133B 07                      		pop	es
  3369 0000133C 1F                      		pop	ds
  3370 0000133D 5F                      		pop	di
  3371 0000133E 5A                      		pop	dx
  3372 0000133F 59                      		pop	cx
  3373 00001340 5B                      		pop	bx
  3374 00001341 CA0200                  		retf	2		; far return, dropping flags
  3375                                  
  3376                                  ; =============== S U B	R O U T	I N E ========================================
  3377                                  
  3378                                  ;***	setcmd - set up cmd_block for the disk operation
  3379                                  ;
  3380                                  ;	entry:	(ds) = bios data segment.
  3381                                  ;		(es:bx) in seg:000x form.
  3382                                  ;		other registers as in int 13h call
  3383                                  ;	
  3384                                  ;	exit:	cmd_block set up for disk read call.
  3385                                  ;		control_byte set up for disk operation.
  3386                                  ;		(al) = control byte modifier
  3387                                  ;
  3388                                  ;	sets the fields of cmd_block using the register contents
  3389                                  ;	and the contents of the disk parameter block for the given drive.
  3390                                  ;
  3391                                  ;	warning: (ax) destroyed.
  3392                                  ;		does direct calls to the at rom.
  3393                                  
  3394                                  setcmd:		; proc near		
  3395                                  		;mov	ds:43h,	al	; [cmd_block+sec_cnt]
  3396                                  		; 16/10/2022
  3397 00001344 A24300                  		mov	[cmd_block+sec_cnt], al
  3398                                  		;mov	byte ptr ds:48h, 20h ; [cmd_block+cmd_reg]
  3399 00001347 C606480020              		mov	byte [cmd_block+cmd_reg], 20h ; assume function 02h (read)
  3400 0000134C 80FC02                  		cmp	ah, 2
  3401 0000134F 7405                    		jz	short setc1	; cmd_reg = 20h	if function 02h	(read)
  3402 00001351 C606480022              		mov	byte [cmd_block+cmd_reg], 22h
  3403                                  		;mov	byte ptr ds:48h, 22h ; [cmd_block+cmd_reg]
  3404                                  					; cmd_reg = 22h	if function 0Ah	(read long)
  3405                                  setc1:					
  3406 00001356 88C8                    		mov	al, cl
  3407 00001358 243F                    		and	al, 3Fh		; mask sector number
  3408                                  		;mov	ds:44h,	al	; [cmd_block+sec_num]
  3409                                  		;mov	ds:45h,	ch	; [cmd_block+cyl_low]
  3410 0000135A A24400                  		mov	[cmd_block+sec_num], al ; mov [44h],al
  3411 0000135D 882E4500                		mov	[cmd_block+cyl_low], ch ; mov [45h],ch
  3412 00001361 88C8                    		mov	al, cl
  3413 00001363 C0E806                  		shr	al, 6		; get two high bits of cylinder	number
  3414                                  		;mov	ds:46h,	al	; [cmd_block+cyl_high]
  3415 00001366 A24600                  		mov	[cmd_block+cyl_high], al ; mov [46h],al
  3416 00001369 89D0                    		mov	ax, dx
  3417 0000136B C0E004                  		shl	al, 4		; drive	number
  3418 0000136E 80E40F                  		and	ah, 0Fh
  3419 00001371 08E0                    		or	al, ah		; head number
  3420 00001373 0CA0                    		or	al, 0A0h	; set ecc and 512 bytes	per sector
  3421                                  		;mov	ds:47h,	al	; [cmd_block+drv_head]
  3422 00001375 A24700                  		mov	[cmd_block+drv_head], al  ; mov [47h],al 
  3423 00001378 06                      		push	es
  3424 00001379 53                      		push	bx
  3425 0000137A 0E                      		push	cs
  3426 0000137B E85C00                  		call	get_vec
  3427 0000137E 268B4705                		mov	ax, [es:bx+5]	; [es:bx+fdp_precomp]
  3428                                  			 		; write pre-comp from disk parameters
  3429 00001382 C1E802                  		shr	ax, 2
  3430                                  		;mov	ds:42h,	al	; [cmd_block+pre_comp]
  3431 00001385 A24200                  		mov	[cmd_block+pre_comp], al ; mov [42h],al
  3432                                  					; only use low part
  3433 00001388 268A4708                		mov	al, [es:bx+8]	; [es:bx+fdp_control]
  3434                                  					; control byte modifier
  3435 0000138C 5B                      		pop	bx
  3436 0000138D 07                      		pop	es
  3437                                  		;mov	ah, ds:76h	; [control_byte]
  3438 0000138E 8A267600                		mov	ah, [control_byte] ; mov ah,[76h]
  3439 00001392 80E4C0                  		and	ah, 0C0h	; keep disable retry bits	
  3440 00001395 08C4                    		or	ah, al
  3441                                  		;mov	ds:76h,	ah
  3442 00001397 88267600                		mov	[control_byte], ah ; mov [76h],al
  3443 0000139B C3                      		retn
  3444                                  
  3445                                  ; =============== S U B	R O U T	I N E ========================================
  3446                                  
  3447                                  ;***	docmd - carry out read operation to at hard disk
  3448                                  ;
  3449                                  ;	entry:	(es:bx) = address for read in data.
  3450                                  ;		cmd_block set up for disk read.
  3451                                  ;
  3452                                  ;	exit:	buffer at (es:bx) contains data read.
  3453                                  ;		disk_status1 set to error code (0 if success).
  3454                                  ;
  3455                                  ;	
  3456                                  ;
  3457                                  ;	warning: (ax), (bl), (cx), (dx), (di) destroyed.
  3458                                  ;		no check is made for dma boundary overrun.
  3459                                  ;
  3460                                  ;	effects: programs disk controller.
  3461                                  ;		performs disk input.
  3462                                  
  3463                                  docmd:		; proc near		
  3464 0000139C 89DF                    		mov	di, bx
  3465 0000139E 0E                      		push	cs
  3466 0000139F E84000                  		call	command
  3467 000013A2 7535                    		jnz	short doc3
  3468                                  doc1:					
  3469 000013A4 0E                      		push	cs
  3470 000013A5 E84200                  		call	waitt		; wait for controller to complete read
  3471 000013A8 752F                    		jnz	short doc3
  3472 000013AA B90001                  		mov	cx, 256		; 256 words per sector
  3473 000013AD BAF001                  		mov	dx, 1F0h	; hf_port
  3474 000013B0 FC                      		cld			; string op goes up
  3475 000013B1 FA                      		cli			; disable interrupts
  3476                                  					; (bug was forgetting this)
  3477                                  
  3478                                  ;	M062 -- some of these old machines have intermittent failures
  3479                                  ;		when the read is done at full speed. Instead of using
  3480                                  ;		a string rep instruction, we'll use a loop. There is
  3481                                  ;		a slight performance hit, but it only affects these
  3482                                  ;		very old machines with an exact date code match, and
  3483                                  ;		it makes said machines more reliable
  3484                                  ;
  3485                                  ;M062	repz	insw		;read in sector
  3486                                  
  3487                                  rsct_loop:				
  3488 000013B2 6D                      		insw
  3489 000013B3 E2FD                    		loop	rsct_loop
  3490 000013B5 FB                      		sti
  3491                                  		; 16/10/2022
  3492 000013B6 F606480002              		test	byte [cmd_block+cmd_reg], 02h
  3493                                  		;test	byte ptr ds:48h, 2 ; [cmd_block+cmd_reg]
  3494                                  					; (ds =	40h)
  3495 000013BB 7410                    		jz	short doc2	; no ecc bytes to read.
  3496 000013BD 0E                      		push	cs
  3497 000013BE E83100                  		call	wait_drq	; wait for controller to complete read
  3498 000013C1 7216                    		jb	short doc3
  3499 000013C3 B90400                  		mov	cx, 4		; 4 bytes of ecc
  3500 000013C6 BAF001                  		mov	dx, 1F0h	; hf_port
  3501 000013C9 FA                      		cli
  3502 000013CA F36C                    		rep insb		; read in ecc
  3503 000013CC FB                      		sti
  3504                                  doc2:					
  3505 000013CD 0E                      		push	cs
  3506 000013CE E82900                  		call	check_status
  3507 000013D1 7506                    		jnz	short doc3	; operation failed
  3508                                  		;dec	byte ptr ds:43h	; [cmd_block+sec_cnt]
  3509 000013D3 FE0E4300                		dec	byte [cmd_block+sec_cnt]
  3510 000013D7 75CB                    		jnz	short doc1	; loop while more sectors to read
  3511                                  doc3:					
  3512 000013D9 C3                      		retn
  3513                                  
  3514                                  ; =============== S U B	R O U T	I N E ========================================
  3515                                  
  3516                                  ;***	define where the rom routines are actually located
  3517                                  ;	   in the buggy old AT BIOS that we might need to
  3518                                  ;	   install a special level of int13 handler for
  3519                                  
  3520                                  ; 16/10/2022
  3521                                  
  3522                                  romsegment 	equ 0F000h  ; segment
  3523                                  romcommand 	equ 2E1Eh   ; offset in romsegment
  3524                                  romwait		equ 2E7Fh   ; offset in romsegment
  3525                                  romwait_drq 	equ 2EE2h   ; offset in romsegment
  3526                                  romcheck_status equ 2EF8h   ; offset in romsegment
  3527                                  romcheck_dma 	equ 2F69h   ; offset in romsegment	
  3528                                  romget_vec	equ 2F8Eh   ; offset in romsegment
  3529                                  romfret		equ 0FF65h  ; far return in rom	
  3530                                  
  3531                                  ;***	get_vec - get pointer to hard disk parameters.
  3532                                  ;
  3533                                  ;	entry:	(dl) = low bit has hard disk number (0 or 1).
  3534                                  ;
  3535                                  ;	exit:	(es:bx) = address of disk parameters table.
  3536                                  ;
  3537                                  ;	uses:	ax for segment computation.
  3538                                  ;
  3539                                  ;	loads es:bx from interrupt table in low memory, vector 46h (disk 0)
  3540                                  ;	or 70h (disk 1).
  3541                                  ;	
  3542                                  ;	warning: (ax) destroyed.
  3543                                  ;		this does a direct call to the at rom.
  3544                                  
  3545                                  get_vec:	; proc near		
  3546                                  		;push	0FF65h		; romfret ; far	return in rom
  3547                                  		;jmp	far ptr	0F000h:2F8Eh
  3548                                  		; 16/10/2022
  3549 000013DA 6865FF                  		push	romfret		; far return in rom
  3550 000013DD EA8E2F00F0              		jmp	romsegment:romget_vec
  3551                                  
  3552                                  ; =============== S U B	R O U T	I N E ========================================
  3553                                  
  3554                                  ;***	command - send contents of cmd_block to disk controller.
  3555                                  ;
  3556                                  ;	entry:	control_byte 
  3557                                  ;		cmd_block - set up with values for hard disk controller.
  3558                                  ;
  3559                                  ;	exit:	disk_status1 = error code.
  3560                                  ;		nz if error, zr for no error.
  3561                                  ;
  3562                                  ;
  3563                                  ;	warning: (ax), (cx), (dx) destroyed.
  3564                                  ;		does a direct call to the at rom.
  3565                                  ;
  3566                                  ;	effects: programs disk controller.
  3567                                  
  3568                                  command:	; proc near		
  3569                                  		;push	0FF65h		; romfret ; far	return in rom
  3570                                  		;jmp	far ptr	0F000h:2E1Eh
  3571                                  		; 16/10/2022
  3572 000013E2 6865FF                  		push	romfret		; far return in rom
  3573 000013E5 EA1E2E00F0              		jmp	romsegment:romcommand
  3574                                  
  3575                                  ; =============== S U B	R O U T	I N E ========================================
  3576                                  
  3577                                  ;***	waitt - wait for disk interrupt
  3578                                  ;
  3579                                  ;	entry:	nothing.
  3580                                  ;
  3581                                  ;	exit:	disk_status1 = error code.
  3582                                  ;		nz if error, zr if no error.
  3583                                  ;
  3584                                  ;
  3585                                  ;	warning: (ax), (bl), (cx) destroyed.
  3586                                  ;		does a direct call to the at rom.
  3587                                  ;		
  3588                                  ;	effects: calls int 15h, function 9000h.
  3589                                  
  3590                                  waitt:		; proc near		
  3591                                  		;push	0FF65h		; romfret ; far	return in rom
  3592                                  		;jmp	far ptr	0F000h:2E7Fh
  3593                                  		; 16/10/2022
  3594 000013EA 6865FF                  		push	romfret		; far return in rom
  3595 000013ED EA7F2E00F0              		jmp	romsegment:romwait
  3596                                  
  3597                                  ; =============== S U B	R O U T	I N E ========================================
  3598                                  
  3599                                  ;***	wait_drq - wait for data request.
  3600                                  ;
  3601                                  ;	entry:	nothing.
  3602                                  ;
  3603                                  ;	exit:	disk_status1 = error code.
  3604                                  ;		cy if error, nc if no error.
  3605                                  ;
  3606                                  ;	warning: (al), (cx), (dx) destroyed.
  3607                                  ;		does a direct call to the at rom.
  3608                                  
  3609                                  wait_drq:	; proc near		
  3610                                  		;push	0FF65h		; romfret ; far	return in rom
  3611                                  		;jmp	far ptr	0F000h:2EE2h
  3612                                  		; 16/10/2022
  3613 000013F2 6865FF                  		push	romfret		; far return in rom
  3614 000013F5 EAE22E00F0              		jmp	romsegment:romwait_drq
  3615                                  
  3616                                  ; =============== S U B	R O U T	I N E ========================================
  3617                                  
  3618                                  ;***	check_status - check hard disk status.
  3619                                  ;
  3620                                  ;	entry:	nothing.
  3621                                  ;
  3622                                  ;	exit:	disk_status1 = error code.
  3623                                  ;		nz if error, zr if no error.
  3624                                  ;
  3625                                  ;	warning: (ax), (cx), (dx) destroyed.
  3626                                  ;		does a direct call to the at rom.
  3627                                  
  3628                                  check_status:	; proc near		
  3629                                  		;push	0FF65h		; romfret ; far	return in rom
  3630                                  		;jmp	far ptr	0F000h:2EF8h
  3631                                  		; 16/10/2022
  3632 000013FA 6865FF                  		push	romfret		; far return in rom
  3633 000013FD EAF82E00F0              		jmp	romsegment:romcheck_status
  3634                                  
  3635                                  ; =============== S U B	R O U T	I N E ========================================
  3636                                  
  3637                                  ;***	check_dma - check for dma overrun 64k segment.
  3638                                  ;
  3639                                  ;	entry:	(es:bx) = addr. of memory buffer in seg:000x form.
  3640                                  ;		cmd_block set up for operation.
  3641                                  ;
  3642                                  ;	exit:	disk_status1 - error code.
  3643                                  ;		cy if error, nc if no error.
  3644                                  ;
  3645                                  ;	warning: does a direct call to the at rom.
  3646                                  
  3647                                  check_dma:	; proc near		
  3648                                  		;push	0FF65h		; romfret ; far	return in rom
  3649                                  		;jmp	far ptr	0F000h:2F69h
  3650                                  		; 16/10/2022
  3651 00001402 6865FF                  		push	romfret		; far return in rom
  3652 00001405 EA692F00F0              		jmp	romsegment:romcheck_dma
  3653                                  
  3654                                  ;-----------------------------------------------------------------------------
  3655                                  
  3656                                  endatrom:
  3657                                  
  3658                                  ; ----------------------------------------------------------------------------
  3659                                  
  3660                                  ;; M015 -- begin changes
  3661                                  ;;
  3662                                  ;; Certain old COMPAQ '286 machines have a bug in their ROM BIOS.
  3663                                  ;; When Int13 is done with AH > 15h and DL >= 80h, they trash
  3664                                  ;; the byte at DS:74h, assuming that DS points to ROM_DATA.
  3665                                  ;; If our init code detects this error, it will install this
  3666                                  ;; special Int13 hook through the same mechanism that was set
  3667                                  ;; up for the IBM patch above. This code is also dynamically
  3668                                  ;; relocated by MSINIT.
  3669                                  
  3670                                  compaq_disk_io:
  3671 0000140A 80FC15                  		cmp	ah, 15h		; compaq_disk_io proc far
  3672                                  					;
  3673                                  					; the following	label defines the end of the at	rom patch.
  3674                                  					; this is used at configuration	time.
  3675                                  					;
  3676                                  					; warning!!!
  3677                                  					; this code will be dynamically	relocated by msinit
  3678 0000140D 7705                    		ja	short mebbe_hookit ; only deal with functions > 15h
  3679                                  no_hookit:				
  3680                                  		;jmp	cs:Old13
  3681                                  		; 16/10/2022
  3682 0000140F 2EFF2E[0601]            		jmp	far [cs:Old13]
  3683                                  
  3684                                  ; ----------------------------------------------------------------------------
  3685                                  
  3686                                  mebbe_hookit:				
  3687 00001414 80FA80                  		cmp	dl, 80h
  3688 00001417 72F6                    		jb	short no_hookit
  3689 00001419 1E                      		push	ds
  3690 0000141A 50                      		push	ax
  3691 0000141B B84000                  		mov	ax, 40h
  3692 0000141E 8ED8                    		mov	ds, ax
  3693 00001420 58                      		pop	ax
  3694 00001421 9C                      		pushf
  3695                                  		;call	cs:Old13
  3696                                  		; 16/10/2022
  3697 00001422 2EFF1E[0601]            		call	far [cs:Old13]
  3698 00001427 1F                      		pop	ds
  3699 00001428 CA0200                  		retf	2
  3700                                  
  3701                                  ; ----------------------------------------------------------------------------
  3702                                  
  3703 0000142B 00                      end_compaq_i13hook: db 0			
  3704                                  
  3705                                  ; =============== S U B	R O U T	I N E ========================================
  3706                                  
  3707                                  ; CMOS Clock setting support routines used by MSCLOCK.		
  3708                                  ; Warning!!! This code will be dynamically relocated by MSINIT.
  3709                                  
  3710                                  daycnt_to_day:	; proc far
  3711                                  
  3712                                  ; entry: [daycnt] = number of days since 1-1-80
  3713                                  ;
  3714                                  ; return: ch - century in bcd
  3715                                  ;	  cl - year in bcd
  3716                                  ;	  dh - month in bcd
  3717                                  ;	  dl - day in bcd
  3718                                  
  3719                                  		; 16/10/2022		
  3720 0000142C 2EFF36[F004]            		push	word [cs:daycnt] ; save daycnt
  3721 00001431 2E813E[F004]891C        		cmp	word [cs:daycnt], 7305	; (365*20+(20/4))
  3722                                  					; # days from 1-1-1980 to 1-1-2000
  3723 00001438 730E                    		jnb	short century20
  3724 0000143A 2EC606[F404]13          		mov	byte [cs:base_century], 19
  3725 00001440 2EC606[F504]50          		mov	byte [cs:base_year], 80
  3726 00001446 EB13                    		jmp	short years
  3727                                  ; ----------------------------------------------------------------------------
  3728                                  		
  3729                                  century20:				
  3730 00001448 2EC606[F404]14          		mov	byte [cs:base_century], 20
  3731 0000144E 2EC606[F504]00          		mov	byte [cs:base_year], 0
  3732 00001454 2E812E[F004]891C        		sub	word [cs:daycnt], 7305	; (365*20+(20/4))
  3733                                  					; adjust daycnt
  3734                                  years:					
  3735 0000145B 31D2                    		xor	dx, dx
  3736 0000145D 2EA1[F004]              		mov	ax, [cs:daycnt]
  3737 00001461 BBB505                  		mov	bx, 1461	; (366+365*3)
  3738                                  					; # of days in a Leap year block
  3739 00001464 F7F3                    		div	bx		; AX = # of leap block,	DX = daycnt
  3740 00001466 2E8916[F004]            		mov	[cs:daycnt], dx	; save daycnt left
  3741 0000146B B304                    		mov	bl, 4
  3742 0000146D F6E3                    		mul	bl		; AX = # of years. Less	than 100
  3743 0000146F 2E0006[F504]            		add	[cs:base_year], al ; So, ah = 0. Adjust year
  3744 00001474 2EFF06[F004]            		inc	word [cs:daycnt]	; set daycnt to	1 base
  3745 00001479 2E813E[F004]6E01        		cmp	word [cs:daycnt], 366	; daycnt=remainder of leap year	bk
  3746 00001480 7626                    		jbe	short leapyear	; within 366+355+355+355 days.
  3747 00001482 2EFE06[F504]            		inc	byte [cs:base_year]	; if daycnt <= 366, then leap year
  3748 00001487 2E812E[F004]6E01        		sub	word [cs:daycnt], 366	; else daycnt--, base_year++ ;
  3749 0000148E B90300                  		mov	cx, 3		; And next three years are normal
  3750                                  regularyear:				
  3751 00001491 2E813E[F004]6D01        		cmp	word [cs:daycnt], 365	; for(i=1; i>3 or daycnt <=365;	i++)
  3752 00001498 7614                    		jbe	short yeardone	; {if (daycnt >	365)
  3753 0000149A 2EFE06[F504]            		inc	byte [cs:base_year]	;   { daycnt -=	365
  3754 0000149F 2E812E[F004]6D01        		sub	word [cs:daycnt], 365	;   }
  3755 000014A6 E2E9                    		loop	regularyear	; }
  3756                                  					;
  3757                                  					; should never fall through loop
  3758                                  leapyear:				
  3759 000014A8 2EC606[F704]1D          		mov	byte [cs:month_tab+1], 29 ; leap year.
  3760                                  					; change month table.
  3761                                  yeardone:				
  3762 000014AE 31DB                    		xor	bx, bx
  3763 000014B0 31D2                    		xor	dx, dx
  3764 000014B2 2EA1[F004]              		mov	ax, [cs:daycnt]
  3765                                  		;mov	si, offset month_tab
  3766 000014B6 BE[F604]                		mov	si, month_tab	; 19/10/2022
  3767 000014B9 B90C00                  		mov	cx, 12
  3768                                  months:					
  3769 000014BC FEC3                    		inc	bl
  3770                                  
  3771                                  		; !!! -- 16/10/2022 -- (if DS=CS, what for CS: prefixes are used !?)
  3772                                  		;mov	dl, [cs:si]
  3773                                  		; !!! -- 16/10/2022 -- (may be to keep code addrs as unchanged/fix!?)
  3774                                  		; ds = cs !? ((ofcourse ds must be same with cs here))
  3775                                  		;mov	dl, [si] ; 20/03/2019 (MSDOS 6.21 IO.SYS, BIOSDATA:14C0h)
  3776                                  		;mov	dl, [si] ; 16/10/2022 (MSDOS 5.0 IO.SYS, BIOSDATA:14C0h)
  3777                                  		
  3778 000014BE 8A14                    		mov	dl, [si] ; ?	; mov dl, [cs:si]
  3779 000014C0 39D0                    		cmp	ax, dx		; cmp daycnt for each month till fit
  3780                                  					; dh=0
  3781 000014C2 7605                    		jbe	short month_done
  3782 000014C4 46                      		inc	si		; next month
  3783 000014C5 29D0                    		sub	ax, dx		; adjust daycnt
  3784 000014C7 E2F3                    		loop	months		;
  3785                                  					; should never fall through loop
  3786                                  month_done:				
  3787 000014C9 2EC606[F704]1C          		mov	byte [cs:month_tab+1], 28
  3788                                  					; restore month table value
  3789 000014CF 88DA                    		mov	dl, bl
  3790 000014D1 2E8A36[F504]            		mov	dh, [cs:base_year]
  3791 000014D6 2E8A0E[F404]            		mov	cl, [cs:base_century] ; al=day,dl=month,dh=year,cl=cntry
  3792 000014DB 2EFF1E[0205]            		call	far [cs:bintobcd]
  3793                                  		;call	cs:bintobcd	; convert "day"	to bcd
  3794                                  					; dl = bcd day,	al = month
  3795 000014E0 86D0                    		xchg	dl, al
  3796 000014E2 2EFF1E[0205]            		call	far [cs:bintobcd]
  3797                                  		;call	cs:bintobcd	; dh = bcd month, al = year
  3798 000014E7 86F0                    		xchg	dh, al
  3799 000014E9 2EFF1E[0205]            		call	far [cs:bintobcd]
  3800                                  		;call	cs:bintobcd	; cl = bcd year, al = century
  3801 000014EE 86C8                    		xchg	cl, al
  3802 000014F0 2EFF1E[0205]            		call	far [cs:bintobcd]
  3803                                  		;call	cs:bintobcd	; ch = bcd century
  3804 000014F5 88C5                    		mov	ch, al
  3805 000014F7 2E8F06[F004]            		pop	word [cs:daycnt] ; restore original value
  3806 000014FC CB                      		retf
  3807                                  
  3808                                  enddaycnttoday:	
  3809                                  
  3810                                  ; =============== S U B	R O U T	I N E ========================================
  3811                                  
  3812                                  bin_to_bcd:	; proc far		; real time clock support
  3813                                  
  3814                                  ;convert a binary input in al (less than 63h or 99 decimal)
  3815                                  ;into a bcd value in al. ah destroyed.	
  3816                                  		
  3817 000014FD 51                      		push	cx		
  3818 000014FE D40A                    		aam			; al=high digit	bcd, ah=low digit bc
  3819 00001500 B104                    		mov	cl, 4
  3820 00001502 D2E4                    		shl	ah, cl		; mov the high digit to	high nibble
  3821 00001504 08E0                    		or	al, ah
  3822 00001506 59                      		pop	cx
  3823 00001507 CB                      		retf
  3824                                  
  3825                                  ; ----------------------------------------------------------------------------
  3826                                  
  3827                                  ; the k09 requires the routines for reading the clock because of the suspend/
  3828                                  ; resume facility. the system clock needs to be reset after resume.
  3829                                  
  3830                                  ; the following routine is executed at resume time when the system
  3831                                  ; powered on after suspension. it reads the real time clock and
  3832                                  ; resets the system time and date, and then irets.
  3833                                  
  3834                                  ; warning!!! this code will be dynamically relocated by msinit.
  3835                                  
  3836                                  int6c:					
  3837 00001508 0E                      		push	cs
  3838 00001509 1F                      		pop	ds
  3839 0000150A 8F06[BB06]              		pop	word [int6c_ret_addr]	; pop off return address
  3840 0000150E 8F06[BD06]              		pop	word [int6c_ret_addr+2]
  3841 00001512 9D                      		popf
  3842 00001513 E81300                  		call	read_real_date	; get the date from the clock
  3843 00001516 FA                      		cli
  3844 00001517 8936[F004]              		mov	[daycnt], si	; update dos copy of date
  3845 0000151B FB                      		sti
  3846 0000151C E8CB00                  		call	read_real_time	; get the time from the	rtc
  3847 0000151F FA                      		cli
  3848 00001520 B401                    		mov	ah, 1
  3849 00001522 CD1A                    		int	1Ah		; CLOCK	- SET TIME OF DAY
  3850                                  					; CX:DX	= clock	count
  3851                                  					; Return: time of day set
  3852 00001524 FB                      		sti
  3853                                  		;jmp	int6c_ret_addr	; long jump
  3854                                  		; 16/10/2022
  3855 00001525 FF2E[BB06]              		jmp	far [int6c_ret_addr] ; long jump
  3856                                  
  3857                                  ; =============== S U B	R O U T	I N E ========================================
  3858                                  
  3859                                  ;   read_real_date reads real-time clock for date and returns the number
  3860                                  ;   of days elapsed since 1-1-80 in si
  3861                                  
  3862                                  read_real_date:	; proc near		
  3863 00001529 50                      		push	ax
  3864 0000152A 51                      		push	cx
  3865 0000152B 52                      		push	dx
  3866 0000152C 30E4                    		xor	ah, ah		; throw	away clock roll	over
  3867 0000152E CD1A                    		int	1Ah		; CLOCK	- GET TIME OF DAY
  3868                                  					; Return: CX:DX	= clock	count
  3869                                  					; AL = 00h if clock was	read or	written	(via AH=0,1) since the previous
  3870                                  					; midnight
  3871                                  					; Otherwise, AL	> 0
  3872 00001530 5A                      		pop	dx
  3873 00001531 59                      		pop	cx
  3874 00001532 58                      		pop	ax
  3875 00001533 50                      		push	ax
  3876 00001534 53                      		push	bx
  3877 00001535 51                      		push	cx
  3878 00001536 52                      		push	dx
  3879 00001537 2EC706[DB06]0100        		mov	word [cs:daycnt2], 1
  3880                                  					; REAL TIME CLOCK ERROR	FLAG (+1 DAY)
  3881 0000153E B404                    		mov	ah, 4
  3882 00001540 CD1A                    		int	1Ah		; CLOCK	- READ DATE FROM REAL TIME CLOCK (AT,XT286,CONV,PS)
  3883                                  					; Return: DL = day in BCD
  3884                                  					; DH = month in	BCD
  3885                                  					; CL = year in BCD
  3886                                  					; CH = century (19h or 20h)
  3887 00001542 7303                    		jnb	short read_ok
  3888 00001544 E99300                  		jmp	r_d_ret
  3889                                  ;-----------------------------------------------------------------------------
  3890                                  
  3891                                  read_ok:				
  3892 00001547 882E[BF06]              		mov	[bin_date_time], ch
  3893 0000154B 880E[C006]              		mov	[bin_date_time+1], cl
  3894 0000154F 8836[C106]              		mov	[bin_date_time+2], dh
  3895 00001553 8816[C206]              		mov	[bin_date_time+3], dl
  3896 00001557 2EC706[DB06]0200        		mov	word [cs:daycnt2], 2 ; READ OF R-T CLOCK SUCCESSFUL
  3897 0000155E E84201                  		call	bcd_verify	; verify bcd values in range
  3898 00001561 7277                    		jb	short r_d_ret	;  some	value out of range
  3899 00001563 2EC706[DB06]0300        		mov	word [cs:daycnt2], 3
  3900 0000156A E8E600                  		call	date_verify
  3901 0000156D 726B                    		jb	short r_d_ret
  3902 0000156F 2EC706[DB06]0000        		mov	word [cs:daycnt2], 0
  3903 00001576 E8AA00                  		call	in_bin
  3904 00001579 A0[C006]                		mov	al, [bin_date_time+1]
  3905 0000157C 98                      		cbw
  3906 0000157D 803E[BF06]14            		cmp	byte [bin_date_time], 20 ; 20th century?
  3907 00001582 7503                    		jnz	short century_19 ; no
  3908 00001584 83C064                  		add	ax, 100		; add in a century
  3909                                  
  3910                                  century_19:				
  3911 00001587 83E850                  		sub	ax, 80		; subtract off 1-1-80
  3912 0000158A B104                    		mov	cl, 4		; leap year every 4
  3913 0000158C F6F1                    		div	cl		; al= #	leap year blocks, ah= remainder
  3914 0000158E 88E3                    		mov	bl, ah		; save odd years
  3915 00001590 98                      		cbw			; zero ah
  3916 00001591 B9B505                  		mov	cx, 1461	; 366+(3*365)
  3917                                  					; # of days in leap year blocks
  3918 00001594 F7E1                    		mul	cx
  3919 00001596 2EA3[DB06]              		mov	[cs:daycnt2], ax ; SAVE COUNT OF DAYS
  3920 0000159A 88D8                    		mov	al, bl		; get odd years	count
  3921 0000159C 98                      		cbw
  3922 0000159D 09C0                    		or	ax, ax
  3923 0000159F 740C                    		jz	short leap_year
  3924 000015A1 B96D01                  		mov	cx, 365		; days in year
  3925 000015A4 F7E1                    		mul	cx
  3926 000015A6 2E0106[DB06]            		add	[cs:daycnt2], ax ; ADD ON DAYS IN ODD YEARS
  3927 000015AB EB07                    		jmp	short leap_adjustment ;	account	for leap year
  3928                                  					; possibly account for a leap day
  3929                                  ;-----------------------------------------------------------------------------
  3930                                  
  3931                                  leap_year:				
  3932 000015AD 803E[C106]02            		cmp	byte [bin_date_time+2], 2 ; is	month february?
  3933 000015B2 7605                    		jbe	short no_leap_adjustment ; jan or feb. no leap day yet.
  3934                                  leap_adjustment:			
  3935 000015B4 2EFF06[DB06]            		inc	word [cs:daycnt2] ; account for leap day
  3936                                  no_leap_adjustment:			
  3937 000015B9 8A0E[C206]              		mov	cl, [bin_date_time+3] ; get days of month
  3938 000015BD 30ED                    		xor	ch, ch
  3939 000015BF 49                      		dec	cx		; because of offset from day 1,	not day	0
  3940 000015C0 2E010E[DB06]            		add	[cs:daycnt2], cx ; GET DAYS IN MONTHS PRECEEDING
  3941 000015C5 8A0E[C106]              		mov	cl, [bin_date_time+2] ; get month
  3942 000015C9 30ED                    		xor	ch, ch
  3943 000015CB 49                      		dec	cx		; january starts at offset 0
  3944 000015CC D1E1                    		shl	cx, 1		; word offset
  3945 000015CE BE[C306]                		mov	si, month_table
  3946 000015D1 01CE                    		add	si, cx
  3947                                  		; 16/10/2022
  3948                                  		; ds must be same with cs here, if so..
  3949                                  		; what for cs: prefixes are used !?)
  3950                                  		; mov	ax, [cs:si]
  3951                                  		; mov	ax, [si] ; 16/10/2022 (MSDOS 5.0 IO.SYS - BIOSDATA:15D5h)
  3952 000015D3 8B04                    		mov	ax, [si]	; mov ax, [cs:si]
  3953                                  					; get #	days in	previous months
  3954 000015D5 2E0106[DB06]            		add	[cs:daycnt2], ax
  3955                                  r_d_ret:				
  3956 000015DA 2E8B36[DB06]            		mov	si, [cs:daycnt2]
  3957 000015DF 5A                      		pop	dx
  3958 000015E0 59                      		pop	cx
  3959 000015E1 5B                      		pop	bx
  3960 000015E2 58                      		pop	ax
  3961 000015E3 C3                      		retn
  3962                                  
  3963                                  ;-----------------------------------------------------------------------------
  3964                                  
  3965                                  r_t_retj:				
  3966 000015E4 31C9                    		xor	cx, cx
  3967 000015E6 31D2                    		xor	dx, dx
  3968 000015E8 EB38                    		jmp	short r_t_ret
  3969                                  
  3970                                  ; =============== S U B	R O U T	I N E ========================================
  3971                                  
  3972                                  ; read_real_time reads the time from the rtc. on exit, it has the number of
  3973                                  ; ticks (at 18.2 ticks per sec.) in cx:dx.
  3974                                  
  3975                                  read_real_time:	; proc near		
  3976 000015EA B402                    		mov	ah, 2
  3977 000015EC CD1A                    		int	1Ah		; CLOCK	- READ REAL TIME CLOCK (AT,XT286,CONV,PS)
  3978                                  					; Return: CH = hours in	BCD
  3979                                  					; CL = minutes in BCD
  3980                                  					; DH = seconds in BCD
  3981 000015EE 72F4                    		jb	short r_t_retj
  3982 000015F0 882E[BF06]              		mov	[bin_date_time], ch ; hours
  3983 000015F4 880E[C006]              		mov	[bin_date_time+1], cl ; minutes
  3984 000015F8 8836[C106]              		mov	[bin_date_time+2], dh ; seconds
  3985 000015FC C606[C206]00            		mov	byte [bin_date_time+3], 0 ; unused for time
  3986 00001601 E89F00                  		call	bcd_verify
  3987 00001604 72DE                    		jb	short r_t_retj
  3988 00001606 E88500                  		call	time_verify
  3989 00001609 72D9                    		jb	short r_t_retj
  3990 0000160B E81500                  		call	in_bin		; from bcd to bin
  3991 0000160E 8A2E[BF06]              		mov	ch, [bin_date_time]
  3992 00001612 8A0E[C006]              		mov	cl, [bin_date_time+1]
  3993 00001616 8A36[C106]              		mov	dh, [bin_date_time+2]
  3994 0000161A 8A16[C206]              		mov	dl, [bin_date_time+3]
  3995                                  		; 16/10/2022
  3996                                  		; 17/09/2022
  3997                                  		; 31/05/2019
  3998 0000161E FF1E[E206]              		call	far [ttticks] 
  3999                                  		;call	dword ptr ttticks ; note: indirect far call
  4000                                  					; cx:dx	= number of ticks
  4001                                  					; (at 18.2 ticks per sec.)
  4002                                  r_t_ret:				
  4003 00001622 C3                      		retn
  4004                                  
  4005                                  ; =============== S U B	R O U T	I N E =======================================
  4006                                  
  4007                                  ;   in_bin converts bin_date_time values from bcd to bin
  4008                                  
  4009                                  in_bin:		; proc near		
  4010 00001623 A0[BF06]                		mov	al, [bin_date_time] ; century or hours
  4011 00001626 E81F00                  		call	bcd_to_bin
  4012 00001629 A2[BF06]                		mov	[bin_date_time], al
  4013 0000162C A0[C006]                		mov	al, [bin_date_time+1] ; years or minutes
  4014 0000162F E81600                  		call	bcd_to_bin
  4015 00001632 A2[C006]                		mov	[bin_date_time+1], al
  4016 00001635 A0[C106]                		mov	al, [bin_date_time+2] ; months or seconds
  4017 00001638 E80D00                  		call	bcd_to_bin
  4018 0000163B A2[C106]                		mov	[bin_date_time+2], al
  4019 0000163E A0[C206]                		mov	al, [bin_date_time+3] ; days (not used for time)
  4020 00001641 E80400                  		call	bcd_to_bin
  4021 00001644 A2[C206]                		mov	[bin_date_time+3], al
  4022 00001647 C3                      		retn
  4023                                  
  4024                                  ; =============== S U B	R O U T	I N E =======================================
  4025                                  
  4026                                  ;   bcd_to_bin converts two bcd nibbles in al (value <= 99.) to
  4027                                  ;   a binary representation in al
  4028                                  ;   ah is destroyed
  4029                                  
  4030                                  bcd_to_bin:	; proc near		
  4031 00001648 88C4                    		mov	ah, al
  4032 0000164A 240F                    		and	al, 0Fh
  4033 0000164C B104                    		mov	cl, 4
  4034 0000164E D2EC                    		shr	ah, cl
  4035 00001650 D50A                    		aad
  4036 00001652 C3                      		retn
  4037                                  
  4038                                  ; =============== S U B	R O U T	I N E ========================================
  4039                                  
  4040                                  ;   date_verify loosely checks bcd date values to be in range
  4041                                  ;   in bin_date_time
  4042                                  
  4043                                  date_verify:	; proc near		
  4044 00001653 803E[BF06]20            		cmp	byte [bin_date_time], 20h ; century check
  4045 00001658 7732                    		ja	short date_error
  4046 0000165A 740E                    		jz	short century_20 ; jmp in 21th century
  4047 0000165C 803E[BF06]19            		cmp	byte [bin_date_time], 19h ; century check
  4048                                  		;jb	short date_error
  4049                                  		; 12/12/2022
  4050 00001661 722A                    		jb	short date_err2
  4051 00001663 803E[C006]80            		cmp	byte [bin_date_time+1], 80h ; year check
  4052                                  		;jb	short date_error
  4053                                  		; 12/12/2022
  4054 00001668 7223                    		jb	short date_err2
  4055                                  century_20:				
  4056 0000166A 803E[C006]99            		cmp	byte [bin_date_time+1], 99h ; year check
  4057 0000166F 771B                    		ja	short date_error
  4058 00001671 803E[C106]12            		cmp	byte [bin_date_time+2], 12h ; month check
  4059 00001676 7714                    		ja	short date_error
  4060 00001678 803E[C106]00            		cmp	byte [bin_date_time+2], 0
  4061                                  		;jbe	short date_error
  4062 0000167D 760D                    		jna	short date_error
  4063 0000167F 803E[C206]31            		cmp	byte [bin_date_time+3], 31h ; day check
  4064 00001684 7706                    		ja	short date_error
  4065                                  		;cmp	byte [bin_date_time+3], 0 ; day check
  4066                                  		;;jbe	short date_error
  4067                                  		;jna	short date_error
  4068                                  		; 12/12/2022
  4069                                  		; cf=0
  4070                                  		;clc
  4071                                  		; 12/12/2022
  4072 00001686 803E[C206]01            		cmp	byte [bin_date_time+3], 1 ; day check
  4073 0000168B C3                      		retn
  4074                                  ;-----------------------------------------------------------------------------
  4075                                  
  4076                                  date_error:				
  4077 0000168C F9                      		stc
  4078                                  date_err2:
  4079 0000168D C3                      		retn
  4080                                  
  4081                                  ; =============== S U B	R O U T	I N E ========================================
  4082                                  
  4083                                  ; time_verify very loosely checks bcd date values to be in range
  4084                                  ; in bin_date_time
  4085                                  
  4086                                  time_verify:	; proc near		
  4087 0000168E 803E[BF06]24            		cmp	byte [bin_date_time], 24h ; hour check
  4088 00001693 770C                    		ja	short time_error
  4089 00001695 803E[C006]59            		cmp	byte [bin_date_time+1], 59h ; minute check
  4090 0000169A 7705                    		ja	short time_error
  4091                                  		; 12/12/2022h
  4092                                  		;cmp	byte [bin_date_time+2], 59h ; second check
  4093                                  		;ja	short time_error
  4094                                  		;clc
  4095                                  		;retn
  4096                                  		; 12/12/2022
  4097 0000169C 803E[C106]5A            		cmp	byte  [bin_date_time+2], 5Ah	
  4098                                  time_error:
  4099                                  bv_error:	
  4100 000016A1 F5                      		cmc	; cf=0 -> cf=1, cf=1 -> cf=0
  4101 000016A2 C3                      		retn
  4102                                  
  4103                                  ; ----------------------------------------------------------------------------
  4104                                  
  4105                                  ;time_error:				
  4106                                  		;stc
  4107                                  		;retn
  4108                                  
  4109                                  ; =============== S U B	R O U T	I N E ========================================
  4110                                  
  4111                                  ;   bcd_verify checks values in bin_date_time to be valid
  4112                                  ;   bcd numerals.  carry set if any nibble out of range
  4113                                  
  4114                                  bcd_verify:	; proc near		
  4115 000016A3 B90400                  		mov	cx, 4		; 4 bytes to check
  4116 000016A6 BB[BF06]                		mov	bx, bin_date_time
  4117                                  bv_loop:				
  4118 000016A9 8A07                    		mov	al, [bx]	; get a	bcd number (0..99)
  4119 000016AB 88C4                    		mov	ah, al
  4120 000016AD 250FF0                  		and	ax, 0F00Fh	; 10's place in high ah, 1's in al
  4121                                  					; is 1's place in range?
  4122 000016B0 3C0A                    		cmp	al, 10
  4123 000016B2 77ED                    		ja	short bv_error	; jmp out of range
  4124 000016B4 D0EC                    		shr	ah, 1
  4125 000016B6 D0EC                    		shr	ah, 1
  4126 000016B8 D0EC                    		shr	ah, 1
  4127 000016BA D0EC                    		shr	ah, 1
  4128 000016BC 80E40F                  		and	ah, 0Fh		; get rid of any erroneous bits
  4129 000016BF 80FC0A                  		cmp	ah, 10		; is 10's place in range
  4130 000016C2 77DD                    		ja	short bv_error	; jmp out of range
  4131 000016C4 43                      		inc	bx		; next byte
  4132 000016C5 49                      		dec	cx
  4133 000016C6 75E1                    		jnz	short bv_loop
  4134 000016C8 F8                      		clc			; set success flag
  4135 000016C9 C3                      		retn
  4136                                  ; ----------------------------------------------------------------------------
  4137                                  
  4138                                  		; 12/12/2022
  4139                                  ;bv_error:				
  4140                                  		;stc			; set error flag
  4141                                  		;retn
  4142                                  
  4143                                  ; ----------------------------------------------------------------------------
  4144                                  
  4145                                  endk09:
  4146                                  
  4147                                  ; ----------------------------------------------------------------------------
  4148                                  
  4149                                  ;------------------------------------------------------------------------
  4150                                  ;									:
  4151                                  ;	System initialization						:
  4152                                  ;									:
  4153                                  ;	The entry conditions are established by the bootstrap		:
  4154                                  ;	loader and are considered unknown. The following jobs		:
  4155                                  ;	will be performed by this module:				:
  4156                                  ;									:
  4157                                  ;	1.	All device initialization is performed			:
  4158                                  ;	2.	A local stack is set up and DS:SI are set		:
  4159                                  ;		to point to an initialization table. Then		:
  4160                                  ;		an inter-segment call is made to the first		:
  4161                                  ;		byte of the dos 					:
  4162                                  ;	3.	Once the dos returns from this call the ds		:
  4163                                  ;		register has been set up to point to the start		:
  4164                                  ;		of free memory. The initialization will then		:
  4165                                  ;		load the command program into this area 		:
  4166                                  ;		beginning at 100 hex and transfer control to		:
  4167                                  ;		this program.						:
  4168                                  ;									:
  4169                                  ;------------------------------------------------------------------------
  4170                                  
  4171                                  ; 01/10/2022
  4172                                  ; 08/01/2018 - Retro DOS v4.0
  4173                                  
  4174                                  ; drvfat must be the first location of freeable space!
  4175                                  
  4176                                  ; 22/12/2022
  4177                                  align 2
  4178                                  		;db 90h
  4179                                  
  4180 000016CA 0000                    drvfat:		dw 0			; drive	and fat	id of dos
  4181 000016CC 0000                    bios_l:		dw 0			; first	sector of data (low word)
  4182 000016CE 0000                    bios_h:		dw 0			; first	sector of data (high word)
  4183 000016D0 0000                    doscnt:		dw 0			; how many sectors to read
  4184 000016D2 00                      fbigfat:	db 0			; flags	for drive
  4185 000016D3 0000                    fatloc:		dw 0			; seg addr of fat sector
  4186 000016D5 0000                    init_bootseg:	dw 0			; seg addr of buffer for reading boot record
  4187 000016D7 80                      rom_drv_num:	db 80h			; rom drive number
  4188 000016D8 0002                    md_sectorsize:	dw 200h			; used by get_fat_sector proc.
  4189 000016DA 0000                    temp_cluster:	dw 0			; used by get_fat_sector proc.
  4190 000016DC FFFF                    last_fat_sec_num: dw 0FFFFh		; used by get_fat_sector proc.
  4191                                  
  4192                                  ; the following two bytes are used to save the info returned by int 13, ah = 8
  4193                                  ; call to determine drive parameters.
  4194                                  
  4195 000016DE 02                      num_heads:	db 2			; number of heads returned by rom
  4196 000016DF 09                      sec_trk:	db 9			; sec/trk returned by rom
  4197 000016E0 28                      num_cyln:	db 40			; number of cylinders returned by rom
  4198 000016E1 00                      fakefloppydrv:	db 0			; if 1,	then no	diskette drives	in the system.
  4199                                  
  4200                                  ; ----------------------------------------------------------------------------
  4201                                  
  4202 000016E2 0002000140000000        disktable:	dw 512,	256, 64, 0	; warning !!! old values
  4203 000016EA 0008010270000000        		dw 2048, 513, 112, 0
  4204 000016F2 0020020400010000        		dw 8192, 1026, 256, 0
  4205 000016FA A87F030800020000        		dw 32680, 2051,	512, 0	; warning !!! old values
  4206 00001702 FFFF041000040000        		dw 65535, 4100,	1024, 0	; default disktable under
  4207                                  					; the assumption of total fat size <= 128 kb,
  4208                                  					; and the maximum size of fat entry = 16 bit.
  4209                                  
  4210 0000170A 0000A87F0308000200-     disktable2:	dw 0, 32680, 2051, 512,	0 
  4210 00001713 00                 
  4211                                  					; for compatibility.
  4212 00001714 040000000204000240-     		dw 4, 0, 402h, 200h, 40h ; covers upto 134 mb media.
  4212 0000171D 00                 
  4213                                  					; fbig = 40h
  4214 0000171E 080000000308000240-     		dw 8, 0, 803h, 200h, 40h ; upto	268 mb
  4214 00001727 00                 
  4215 00001728 100000000410000240-     		dw 10h,	0, 1004h, 200h,	40h ; upto 536 mb
  4215 00001731 00                 
  4216 00001732 200000000520000240-     		dw 20h,	0, 2005h, 200h,	40h ; upto 1072	mb
  4216 0000173B 00                 
  4217 0000173C 400000000640000240-     		dw 40h,	0, 4006h, 200h,	40h ; upto 2144	mb
  4217 00001745 00                 
  4218 00001746 800000000780000240-     		dw 80h,	0, 8007h, 200h,	40h ; upto 4288	mb...
  4218 0000174F 00                 
  4219                                  					
  4220                                  ; ----------------------------------------------------------------------------
  4221                                  
  4222                                  ;******************************************************
  4223                                  ;variables for mini disk initialization
  4224                                  ;******************************************************
  4225                                  
  4226                                  ; 01/10/2022
  4227                                  ; [ Note: Minidisk == logical dos drive (in extended dos partition) ] 
  4228                                  
  4229 00001750 00                      rom_minidisk_num: db 0			; temp variable	for phys unit
  4230 00001751 00                      hnum:		db 0			; real number of hardfiles
  4231 00001752 [8706]                  last_dskdrv_table: dw dskdrvs		; index	into dskdrv table
  4232 00001754 [1709]                  end_of_bdss:	dw bdss			; offset value of the ending address
  4233                                  					; of bds table. needed to figure out
  4234                                  					; the dosdatasg address.
  4235 00001756 0000                    mini_hdlim:	dw 0			
  4236 00001758 0000                    mini_seclim:	dw 0
  4237                                  
  4238                                  ;end of mini disk init variables **********************
  4239                                  
  4240                                  ; ----------------------------------------------------------------------------
  4241                                  			
  4242 0000175A 30312F31302F383400      bios_date:	db '01/10/84',0 	; used for checking at rom bios	date.
  4243                                  
  4244                                  ; 13/12/2022
  4245                                  %if 0
  4246                                  
  4247                                  ;align 2
  4248                                  		db  90h	
  4249                                  
  4250                                  ; the following are the recommended bpbs for the media that we know of so far.
  4251                                  
  4252                                  ;struc bpbx
  4253                                  ;   resw 1 ; 512
  4254                                  ;   resb 1
  4255                                  ;   resw 1 ; 1
  4256                                  ;   resb 1 ; 2
  4257                                  ;   resw 1
  4258                                  ;   resw 1
  4259                                  ;   resb 1
  4260                                  ;   resw 1
  4261                                  ;   resw 1
  4262                                  ;   resw 1 ; 2
  4263                                  ;   resw 1
  4264                                  ;   resw 1 ; hidden sector high
  4265                                  ;   resd 1 ; extended total sectors
  4266                                  ;.size:
  4267                                  ;endstruc
  4268                                  
  4269                                  ; 08/01/2019 - Retro DOS v4.0
  4270                                  
  4271                                  ; 20/04/2019
  4272                                  
  4273                                  ; 01/10/2022 - Retro DOS v4.0 (MSDOS 5.0) IO.SYS
  4274                                  
  4275                                  ; 09/12/2022
  4276                                  BPB48T:
  4277                                  ;bpb48t:	; bpbx <512, 2, 1, 2, 112, 720, 0FDh, 2, 9, 2, 0, 0, 0, 0> 
  4278                                  		; 48 tpi diskettes	;
  4279                                  		dw	512		; physical sector size in bytes
  4280                                  		db	2		; sectors/allocation unit
  4281                                  		dw	1		; reserved sectors for dos
  4282                                  		db	2		; number of allocation tables
  4283                                  		dw	112		; number of directory entries
  4284                                  		dw	720 ; 2*9*40	; number of sectors (at 512 bytes each)
  4285                                  		db	0FDh		; media descriptor
  4286                                  		dw	2		; number of fat sectors
  4287                                  		dw	9		; sectors per track
  4288                                  		dw	2		; heads
  4289                                  		dw	0		; hidden sector count (low word)
  4290                                  		dw	0		; hidden sector (high)
  4291                                  		dw	0		; number of sectors (low)
  4292                                  		dw	0		; number of sectors (high)					
  4293                                  
  4294                                  		db 90h
  4295                                  ;align 2
  4296                                  BPB96T:
  4297                                  ;bpb96t:	; bpbx <512, 1, 1, 2, 224, 2400, 0F9h, 7, 15, 2, 0, 0, 0, 0> 
  4298                                  		; 96 tpi diskettes	;
  4299                                  		dw	512		; physical sector size in bytes
  4300                                  		db	1		; sectors/allocation unit
  4301                                  		dw	1		; reserved sectors for dos
  4302                                  		db	2		; number of allocation tables
  4303                                  		dw	224		; number of directory entries
  4304                                  		dw	2400 ; 2*15*80	; number of sectors (at 512 bytes each)
  4305                                  		db	0F9h		; media descriptor
  4306                                  		dw	7		; number of fat sectors
  4307                                  		dw	15		; sectors per track
  4308                                  		dw	2		; heads
  4309                                  		dw	0		; hidden sector count (low word)
  4310                                  		dw	0		; hidden sector (high)
  4311                                  		dw	0		; number of sectors (low)
  4312                                  		dw	0		; number of sectors (high)
  4313                                  
  4314                                  		db 90h
  4315                                  ;align 2
  4316                                  BPB35:
  4317                                  ;bpb35:		; bpbx <512, 2, 1, 2, 112, 1440, 0F9h, 3, 9, 2, 0, 0, 0, 0> 
  4318                                  		; 3.5" diskettes - 720 KB ;		
  4319                                  		dw	512		; physical sector size in bytes
  4320                                  		db	2		; sectors/allocation unit
  4321                                  		dw	1		; reserved sectors for dos
  4322                                  		db	2		; number of allocation tables
  4323                                  		dw	112		; number of directory entries
  4324                                  		dw	1440 ; 2*9*80	; number of sectors (at 512 bytes each)
  4325                                  		db	0F9h		; media descriptor
  4326                                  		dw	3		; number of fat sectors
  4327                                  		dw	9		; sectors per track
  4328                                  		dw	2		; heads
  4329                                  		dw	0		; hidden sector count (low word)
  4330                                  		dw	0		; hidden sector (high)
  4331                                  		dw	0		; number of sectors (low)
  4332                                  		dw	0		; number of sectors (high)
  4333                                  
  4334                                  		db 90h
  4335                                  ;align 2
  4336                                  
  4337                                  ;align 2
  4338                                  ;BPB144:
  4339                                  ;bpb144:	; Retro DOS v4.0 feature only !	; 1.44MB diskettes
  4340                                  ;
  4341                                  ;		dw	512		; physical sector size in bytes
  4342                                  ;		db	1		; sectors/allocation unit
  4343                                  ;		dw	1		; reserved sectors for dos
  4344                                  ;		db	2		; number of allocation tables
  4345                                  ;		dw	224		; number of directory entries
  4346                                  ;		dw	2880 ; 2*18*80	; number of sectors (at 512 bytes each)
  4347                                  ;		db	0F0h		; media descriptor
  4348                                  ;		dw	9		; number of fat sectors
  4349                                  ;		dw	18		; sectors per track
  4350                                  ;		dw	2		; heads
  4351                                  ;		dw	0		; hidden sector count (low word)
  4352                                  ;		dw	0		; hidden sector (high)
  4353                                  ;		dw	0		; number of sectors (low)
  4354                                  ;		dw	0		; number of sectors (high)
  4355                                  ;
  4356                                  ;		db 90h
  4357                                  ;align 2
  4358                                  
  4359                                  BPB288:
  4360                                  ;bpb288:	; bpbx <512, 2, 1, 2, 240, 5760, 0F0h, 9, 36, 2, 0, 0, 0, 0>
  4361                                  		; 3.5" diskettes - 2.88 MB ;	 
  4362                                  		dw	512		; physical sector size in bytes
  4363                                  		db	2		; sectors/allocation unit
  4364                                  		dw	1		; reserved sectors for dos
  4365                                  		db	2		; number of allocation tables
  4366                                  		dw	240		; number of directory entries
  4367                                  		dw	5760 ; 2*36*80	; number of sectors (at 512 bytes each)
  4368                                  		db	0F0h		; media descriptor
  4369                                  		dw	3		; number of fat sectors
  4370                                  		dw	9		; sectors per track
  4371                                  		dw	2		; heads
  4372                                  		dw	0		; hidden sector count (low word)
  4373                                  		dw	0		; hidden sector (high)
  4374                                  		dw	0		; number of sectors (low)
  4375                                  		dw	0		; number of sectors (high)
  4376                                  
  4377                                  		db 90h			;
  4378                                  ;align 2
  4379                                  
  4380                                  %endif
  4381                                  
  4382                                  ; ----------------------------------------------------------------------------
  4383                                  					; align	2
  4384                                  ; 09/12/2022
  4385                                  %if 0
  4386                                  bpbtable:	dw bpb48t		; 48tpi	drives
  4387                                  		dw bpb96t		; 96tpi	drives
  4388                                  		dw bpb35		; 3.5" drives
  4389                                  		dw bpb35		; unused 8" diskette
  4390                                  		dw bpb35		; unused 8" diskette
  4391                                  		dw bpb35		; used for hard	disk
  4392                                  		dw bpb35		; used for tape	drive
  4393                                  		dw bpb35		; FFOTHER
  4394                                  		dw bpb35		; ERIMO
  4395                                  		dw bpb288		; 2.88MB drive
  4396                                  		;
  4397                                  		;dw bpb144		; 1.44MB drive - Retro DOS v4.0 feature !
  4398                                  %endif
  4399                                  
  4400                                  ; 13/12/2022
  4401                                  %if 0
  4402                                  BPBTABLE:	dw BPB48T		; 48tpi	drives
  4403                                  		dw BPB96T		; 96tpi	drives
  4404                                  		dw BPB35		; 3.5" drives
  4405                                  		dw BPB35		; unused 8" diskette
  4406                                  		dw BPB35		; unused 8" diskette
  4407                                  		dw BPB35		; used for hard	disk
  4408                                  		dw BPB35		; used for tape	drive
  4409                                  		dw BPB35		; FFOTHER
  4410                                  		dw BPB35		; ERIMO
  4411                                  		dw BPB288		; 2.88MB drive
  4412                                  		;
  4413                                  		;dw BPB144		; 1.44MB drive - Retro DOS v4.0 feature !
  4414                                  
  4415                                  %endif
  4416                                  
  4417                                  ; ----------------------------------------------------------------------------
  4418                                  
  4419                                  ;	entry point to call utility functions in Bios_Code. At this time,
  4420                                  ;	  we aren't doing any A20 switching. During MSINIT time Bios_Code
  4421                                  ;	  will not yet be moved to its final resting place, so we know
  4422                                  ;	  it'll be low.
  4423                                  ;
  4424                                  ;	to use this function, do a "push cs" and load bp with the offset of
  4425                                  ;	  the function you want to call in Bios_Code. This routine will
  4426                                  ;	  push the address of a retf in Bios_Code onto the stack which
  4427                                  ;	  will get executed when the utility function finishes. It will
  4428                                  ;	  then transfer control to Bios_Code:bp using a couple of pushes
  4429                                  ;	  and a retf
  4430                                  
  4431                                  ; 16/10/2022
  4432                                  ;BC_RETF equ bc_retf - DOSBIOSEG_2C7h
  4433                                  ; 09/12/2022
  4434                                  BC_RETF equ bc_retf
  4435                                  
  4436                                  addr_of_bcretf:	;dw 0C8h		; dw bc_retf
  4437                                  					; 2C7h:0C8h = 70h:2638h
  4438 00001763 [C800]                  		dw BC_RETF
  4439                                  
  4440                                  ; ----------------------------------------------------------------------------
  4441                                  
  4442                                  call_bios_code:	; proc far			
  4443 00001765 2EFF36[6317]            		push	word [cs:addr_of_bcretf] 
  4444                                  					; set up near return to far return
  4445 0000176A 2EFF36[E006]            		push	word [cs:cdev+2] ; push Bios_Code segment
  4446 0000176F 55                      		push	bp		; save offset of utility function
  4447 00001770 CB                      		retf			; far jump to (DOS)BIOS code
  4448                                  
  4449                                  ; ----------------------------------------------------------------------------
  4450                                  
  4451 00001771 00                      flp_drvs	db 0			
  4452                                  
  4453                                  ; ----------------------------------------------------------------------------
  4454                                  
  4455                                  ; 01/10/2022 - Retro DOS v4.0 (MSDOS 5.0)
  4456                                  
  4457                                  ;-----------------------------------------------------------------------------
  4458                                  ; entry point from boot sector
  4459                                  ;-----------------------------------------------------------------------------
  4460                                  
  4461                                  init:		; 27/12/2018
  4462                                  		; MSDOS 6.0 (MSINIT.ASM)
  4463                                  		;=============================================================
  4464                                  		;
  4465                                  		; entry from boot sector. the register contents are:
  4466                                  		;
  4467                                  		;   dl = int 13 drive number we booted from
  4468                                  		;   ch = media byte
  4469                                  		;   bx = first data sector on disk.
  4470                                  		;   ax = first data sector (high)
  4471                                  		;   di = sectors/fat for the boot media.
  4472                                  
  4473                                  		; 07/04/2018
  4474                                  		;=============================================================
  4475                                  		; Retro DOS v2.0 - registers from FD Boot Sector 
  4476                                                  ; DL = [bsDriveNumber]
  4477                                  		; DH = [bsMedia]
  4478                                  		; AX = [bsSectors] ; Total sectors
  4479                                  		; DS = 0, SS = 0
  4480                                  		; BP = 7C00h
  4481                                  		
  4482 00001772 FA                      		cli
  4483                                  
  4484                                  		; 21/12/2022
  4485                                  		; ds = 0 (?)
  4486                                  		;push	ax
  4487                                  		;xor	ax, ax
  4488                                  		;mov	ds, ax
  4489                                  		;pop	ax
  4490                                  	
  4491                                  ; 02/10/2022
  4492                                  ; ------------------------------------------------------------------------------
  4493                                  ; Note: Retro DOS v4.0 Kernel does not use/contain MSLOAD part of IO.SYS (5.0)
  4494                                  ; 	Because, Retro DOS v2 boot sector loads complete/entire MSDOS.SYS
  4495                                  ;	(RETRODOS.SYS) Kernel file (IO.SYS & MSDOS.SYS together).
  4496                                  ;	As result of boot sector ve init differences, Retro DOS init code (here)
  4497                                  ;	moves kernel to segment 070h at first, then sets diskette parameters
  4498                                  ;	at segment 50h (while MSDOS 5.0 boot sector sets this).
  4499                                  ; ------------------------------------------------------------------------------
  4500                                  
  4501                                  ; msload will check the extended boot record and set ax, bx accordingly.
  4502                                  
  4503                                  ;	msload passes a 32 bit sector number hi word in ax and low in bx
  4504                                  ;	save this in cs:bios_h and cs:bios_l. this is for the start of
  4505                                  ;	data sector of the bios.
  4506                                  
  4507 00001773 2EA3[CE16]              		mov	[cs:bios_h], ax	; (start of) dos bios (IO.SYS) data sector
  4508 00001777 2E891E[CC16]            		mov	[cs:bios_l], bx
  4509                                  
  4510                                  ; with the following information from msload, we don't need the
  4511                                  ;     boot sector any more.-> this will solve the problem of 29 kb size
  4512                                  ;     limitation of msbio.com file.
  4513                                  
  4514 0000177C 0E                      		push	cs		; Save a peck of interrupt vectors...
  4515 0000177D 07                      		pop	es
  4516 0000177E 51                      		push	cx
  4517 0000177F 57                      		push	di
  4518                                  
  4519                                  		; 21/12/2022
  4520                                  		; ds = 0 (?)
  4521                                  		; 24/12/2022
  4522                                  		; ds = cs
  4523 00001780 31C9                    		xor	cx, cx
  4524 00001782 8ED9                    		mov	ds, cx
  4525                                  		; ds = 0
  4526                                  
  4527 00001784 B105                    		mov	cl, 5
  4528                                  		;mov	cx, 5		; NUMROMVECTORS
  4529                                  					; no. of rom vectors to	be saved
  4530                                  		;mov	si, offset RomVectors ; point to list of int vectors
  4531 00001786 BE[0001]                		mov	si, RomVectors
  4532                                  next_int_:		
  4533 00001789 2E                      		cs	; 16/10/2022
  4534 0000178A AC                      		lodsb		
  4535                                  		;lods	byte ptr cs:[si] ; cs lodsb
  4536 0000178B 98                      		cbw			; ax = interrupt number
  4537 0000178C D1E0                    		shl	ax, 1
  4538 0000178E D1E0                    		shl	ax, 1		; int no * 4
  4539 00001790 89C7                    		mov	di, ax		; interrupt vector address
  4540 00001792 87F7                    		xchg	si, di		; rombios interrupt vector address in si
  4541                                  					; saving address in di
  4542                                  		;lodsw			; movsw
  4543                                  		;stosw
  4544                                  		;lodsw			; movsw
  4545                                  		;stosw			; save the vector
  4546                                  		; 28/09/2023
  4547 00001794 A5                      		movsw
  4548 00001795 A5                      		movsw
  4549                                  
  4550 00001796 87F7                    		xchg	si, di
  4551 00001798 E2EF                    		loop	next_int_
  4552 0000179A 5F                      		pop	di
  4553 0000179B 59                      		pop	cx
  4554                                  
  4555                                  ; we need to save int13 in two places in case we are running on an at.
  4556                                  ; on ats we install the ibm supplied rom_bios patch which hooks
  4557                                  ; int13 ahead of orig13. since int19 must unhook int13 to point to the
  4558                                  ; rom int13 routine, we must have that rom address also stored away.
  4559                                  
  4560                                  		; 21/12/2022
  4561                                  		;mov	ax, [cs:Old13]	; save old13 in orig13 also
  4562                                  		;mov	[cs:Orig13], ax
  4563                                  		;mov	ax, [cs:Old13+2]
  4564                                  		;mov	[cs:Orig13+2], ax
  4565                                  
  4566                                  		; 16/10/2022
  4567 0000179C C7064C00[7407]          		mov	word [13h*4], block13
  4568                                  		;mov	word ptr ds:4Ch, offset	block13	; 13h*4
  4569                                  					; set up int 13	for new	action
  4570 000017A2 8C0E4E00                		mov	[13h*4+2], cs
  4571                                  		;mov	word ptr ds:4Eh, cs ; 13h*4+2
  4572 000017A6 C7065400[4808]          		mov	word [15h*4], Int15
  4573                                  		;mov	word ptr ds:54h, offset	Int15 ;	15h*4
  4574                                  					; set up int 15	for new	action
  4575 000017AC 8C0E5600                		mov	[15h*4+2], cs
  4576                                  		;mov	word ptr ds:56h, cs ; 15h*4+2
  4577 000017B0 C7066400[F907]          		mov	word [19h*4], int19
  4578                                  		;mov	word ptr ds:64h, offset	int19 ;	19h*4
  4579                                  					; set up int 19	for new	action
  4580 000017B6 8C0E6600                		mov	[19h*4+2], cs
  4581                                  		;mov	word ptr ds:66h, cs ; 19h*4+2
  4582                                  
  4583                                  		; 21/12/2022
  4584 000017BA 0E                      		push	cs
  4585 000017BB 1F                      		pop	ds
  4586                                  		
  4587 000017BC A1[0601]                		mov	ax, [Old13]	; save old13 in orig13 also
  4588 000017BF A3[B400]                		mov	[Orig13], ax
  4589 000017C2 A1[0801]                		mov	ax, [Old13+2]
  4590 000017C5 A3[B600]                		mov	[Orig13+2], ax
  4591                                  					; ;
  4592 000017C8 FB                      		sti
  4593 000017C9 CD11                    		int	11h		; EQUIPMENT DETERMINATION
  4594                                  					; Return: AX = equipment flag bits
  4595                                  
  4596                                  ; we have to support a system that does not have any diskette
  4597                                  ; drives but only hardfiles. this system will ipl from the hardfile.
  4598                                  ; if the equipment flag bit 0 is 1, then the system has diskette drive(s).
  4599                                  ; otherwise, the system has only hardfiles.
  4600                                  ;
  4601                                  ; important thing is that still, for compatibility reason, the drive letter
  4602                                  ; for the hardfiles start from "c".  so, we still need to allocate dummy bds
  4603                                  ; drive a and drive b. at sysinit time, we are going to set cds table entry
  4604                                  ; of dpb pointer for these drives to 0, so any user attempt to access this
  4605                                  ; drives will get "invalid drive letter ..." message. we are going to
  4606                                  ; establish "fakefloppydrv" flag. ***sysinit module should call int 11h to
  4607                                  ; determine whether there are any diskette drivers in the system or not.!!!***
  4608                                  
  4609                                  ; check the register returned by the equipment determination interrupt
  4610                                  ; we have to handle the case of no diskettes in the system by faking
  4611                                  ; two dummy drives.
  4612                                  ;
  4613                                  ; if the register indicates that we do have floppy drives we don't need
  4614                                  ; to do anything special.
  4615                                  ;
  4616                                  ; if the register indicates that we don't have any floppy drives then
  4617                                  ; what we need to do is set the fakefloppydrv variable, change the
  4618                                  ; register to say that we do have floppy drives and then go to execute
  4619                                  ; the code which starts at notsingle. this is because we can skip the
  4620                                  ; code given below which tries to find if there are one or two drives
  4621                                  ; since we already know about this.
  4622                                  
  4623                                  		; 12/12/2022
  4624 000017CB A801                    		test	al, 1
  4625                                  		;test	ax, 1		; floppy drives	present	?
  4626 000017CD 752C                    		jnz	short normalfloppydrv ;	yes.
  4627                                  
  4628                                  ; Some ROM BIOSs lie that there are no floppy drives. Lets find out
  4629                                  ; whether it is an old ROM BIOS or a new one
  4630                                  ;
  4631                                  ; WARNING !!!
  4632                                  ;
  4633                                  ; This sequence of code is present in SYSINIT1.ASM also. Any modification
  4634                                  ; here will require an equivalent modification in SYSINIT1.ASM also
  4635                                  
  4636 000017CF 50                      		push	ax
  4637 000017D0 53                      		push	bx
  4638 000017D1 51                      		push	cx
  4639 000017D2 52                      		push	dx
  4640 000017D3 57                      		push	di
  4641 000017D4 06                      		push	es
  4642 000017D5 B408                    		mov	ah, 8
  4643 000017D7 B200                    		mov	dl, 0
  4644 000017D9 CD13                    		int	13h		; DISK - DISK -	GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)
  4645                                  					; DL = drive number
  4646                                  					; Return: CF set on error, AH =	status code, BL	= drive	type
  4647                                  					; DL = number of consecutive drives
  4648                                  					; DH = maximum value for head number, ES:DI -> drive parameter
  4649 000017DB 7204                    		jb	short _gdskp_error
  4650                                  		;mov	[cs:flp_drvs], dl
  4651                                  		; 21/12/2022
  4652                                  		; ds = cs
  4653 000017DD 8816[7117]              		mov	[flp_drvs], dl
  4654                                  _gdskp_error:				
  4655 000017E1 07                      		pop	es
  4656 000017E2 5F                      		pop	di
  4657 000017E3 5A                      		pop	dx
  4658 000017E4 59                      		pop	cx
  4659 000017E5 5B                      		pop	bx
  4660 000017E6 58                      		pop	ax
  4661 000017E7 7212                    		jb	short normalfloppydrv
  4662                                  					; if error it is an old ROM BIOS
  4663                                  					; so, lets assume that ROM BIOS lied
  4664                                  
  4665                                  		; 21/12/2022
  4666                                  		;cmp	byte [cs:flp_drvs], 0 ; number of drvs == 0?
  4667                                  		;jz	short _set_fake_flpdrv
  4668                                  		;mov	al, [cs:flp_drvs]
  4669 000017E9 A0[7117]                		mov	al, [flp_drvs]
  4670 000017EC 08C0                    		or	al, al		; number of drvs == 0?
  4671 000017EE 7403                    		jz	short _set_fake_flpdrv
  4672                                  
  4673                                  		;dec	al		; make it zero based
  4674                                  		; 18/12/2022
  4675 000017F0 48                      		dec	ax
  4676 000017F1 EB0C                    		jmp	short got_num_flp_drvs
  4677                                  ; ----------------------------------------------------------------------------
  4678                                  
  4679                                  _set_fake_flpdrv:
  4680                                  		; 21/12/2022
  4681 000017F3 B80100                  		mov	ax, 1			
  4682 000017F6 A2[E116]                		mov	[fakefloppydrv], al ; 1
  4683                                  		;mov	byte [cs:fakefloppydrv], 1
  4684                                  		;			; we don't have any floppy drives.
  4685                                  		;mov	ax, 1
  4686 000017F9 EB09                    		jmp	short settwodrive ; well then set it for two drives!
  4687                                  ; ----------------------------------------------------------------------------
  4688                                  
  4689                                  normalfloppydrv:			; yes, bit 0 is 1.			
  4690 000017FB D0C0                    		rol	al, 1		; there	exist floppy drives.
  4691 000017FD D0C0                    		rol	al, 1		; put bits 6 & 7 into bits 0 & 1
  4692                                  got_num_flp_drvs:			
  4693                                  		;and	ax, 3		; only look at bits 0 &	1
  4694                                  		; 18/12/2022
  4695 000017FF 2403                    		and	al, 3
  4696 00001801 7505                    		jnz	short notsingle	; zero means single drive system
  4697 00001803 40                      		inc	ax		; pretend it's a two drive system
  4698                                  settwodrive:				; set this to two fakedrives
  4699                                  		; 21/12/2022
  4700                                  		; ds = cs
  4701 00001804 FE06[7800]              		inc	byte [single]
  4702                                  		;inc	byte [cs:single] ; remember this
  4703                                  notsingle:				
  4704 00001808 40                      		inc	ax		; ax has number	of drives, 2-4
  4705                                  					; is also 0 indexed boot drive if we
  4706                                  					; booted off hard file
  4707 00001809 88C1                    		mov	cl, al		; ch is	fat id,	cl # floppies
  4708                                  
  4709                                  ; 16/10/2022
  4710                                  ; MSDOS 3.3 - "MSEQU.INC" (24/07/1987)
  4711                                  INITSPOT EQU	534h	; IBM wants 4 zeros here
  4712                                  BRKADR	 EQU	1BH * 4	; 6CH, 1BH break vector address
  4713                                  TIMADR	EQU	1CH * 4	; 70H, 1CH timer interrupt
  4714                                  DSKADR	EQU	1EH * 4	; address of ptr to disk parameters
  4715                                  SEC9	EQU	522h	; address of disk parameters
  4716                                  CHROUT	EQU	29h
  4717                                  LSTDRV	EQU     504h
  4718                                  
  4719                                  ; determine whether we booted from floppy or hard disk...
  4720                                  
  4721 0000180B F6C280                  		test	dl, 80h		; boot from floppy ?
  4722 0000180E 7502                    		jnz	short gothrd	; no.
  4723 00001810 31C0                    		xor	ax, ax		; indicate boot	from drive a
  4724                                  gothrd:					
  4725 00001812 31D2                    		xor	dx, dx		; ax = 0-based drive we	booted from
  4726                                  					; bios_l, bios_h set.
  4727                                  					; cl = number of floppies including fake one
  4728                                  					; ch = media byte
  4729 00001814 FA                      		cli
  4730 00001815 8ED2                    		mov	ss, dx		; set stack segment and stack pointer
  4731 00001817 BC0007                  		mov	sp, 700h
  4732 0000181A FB                      		sti
  4733 0000181B 51                      		push	cx ; *		; save number of floppies and media byte
  4734 0000181C 88EC                    		mov	ah, ch		; FAT ID to AH
  4735 0000181E 50                      		push	ax ; **		; save boot drive number and media byte
  4736                                  		
  4737                                  ; let model_byte, secondary_model_byte be set here!!!
  4738                                  
  4739 0000181F B4C0                    		mov	ah, 0C0h
  4740 00001821 CD15                    		int	15h		; SYSTEM - GET CONFIGURATION (XT after 1/10/86,AT mdl 3x9,CONV,XT286,PS)
  4741 00001823 7215                    		jb	short no_rom_system_conf ; just	use Model_Byte
  4742 00001825 80FC00                  		cmp	ah, 0
  4743 00001828 7510                    		jnz	short no_rom_system_conf
  4744                                  
  4745                                  		; 21/12/2022
  4746                                  		; ds = cs
  4747 0000182A 268A4702                		mov	al, [es:bx+2]	; [es:bx+ROMBIOS_DESC.bios_sd_modelbyte]
  4748 0000182E A2[3E06]                		mov	[model_byte], al
  4749                                  		;mov	[cs:model_byte], al
  4750                                  					; get/save model byte
  4751 00001831 268A4703                		mov	al, [es:bx+3]	; [es:bx+ROMBIOS_DESC.bios_sd_scnd_modelbyte]
  4752 00001835 A2[3F06]                		mov	[secondary_model_byte], al
  4753                                  		;mov	[cs:secondary_model_byte], al
  4754                                  					; get/save secondary model byte
  4755 00001838 EB0C                    		jmp	short turn_timer_on
  4756                                  ;-----------------------------------------------------------------------------
  4757                                  
  4758                                  no_rom_system_conf:			
  4759 0000183A BEFFFF                  		mov	si, 0FFFFh
  4760 0000183D 8EC6                    		mov	es, si
  4761                                  		; 21/12/2022
  4762 0000183F 26A00E00                		mov	al, [es:0Eh]	; get model byte (from 0FFFFh:0Eh)
  4763 00001843 A2[3E06]                		mov	[model_byte], al
  4764                                  		;mov	[cs:model_byte], al ; save model byte
  4765                                  turn_timer_on:				
  4766 00001846 B020                    		mov	al, 20h	; ' '   ; turn on the timer
  4767 00001848 E620                    		out	20h, al		; Interrupt controller,	8259A.
  4768                                  					; AKPORT
  4769                                  
  4770                                  ; some olivetti m24 machines have an 8530 serial communications
  4771                                  ; chip installed at io address 50h and 52h. if we're running
  4772                                  ; on one of those, we must inhibit the normal aux port initialization
  4773                                  
  4774                                  		; 21/12/2022
  4775                                  		; ds = cs
  4776 0000184A 803E[3E06]00            		cmp	byte [model_byte], 0
  4777                                  		;cmp	byte [cs:model_byte], 0 ; next to last	byte in	rom bios
  4778 0000184F 7510                    		jnz	short not_olivetti_m24 ; skip for all other machines
  4779                                  					; (except olivetti m24)
  4780 00001851 E466                    		in	al, 66h		; is 8530 installed?
  4781 00001853 A820                    		test	al, 20h
  4782 00001855 740A                    		jz	short not_olivetti_m24 ; we're done if not
  4783 00001857 B00F                    		mov	al, 0Fh		; double check
  4784 00001859 E650                    		out	50h, al
  4785 0000185B E450                    		in	al, 50h
  4786 0000185D A801                    		test	al, 1		; this test was	copied from olivetti
  4787 0000185F 7414                    		jz	short skip_aux_port_init ; take	this branch if 8530 installed
  4788                                  
  4789                                  not_olivetti_m24:			
  4790 00001861 B003                    		mov	al, 3		; init com4
  4791 00001863 E80209                  		call	aux_init
  4792 00001866 B002                    		mov	al, 2		; init com3
  4793 00001868 E8FD08                  		call	aux_init
  4794 0000186B B001                    		mov	al, 1		; init com2
  4795 0000186D E8F808                  		call	aux_init
  4796 00001870 30C0                    		xor	al, al		; init com1
  4797 00001872 E8F308                  		call	aux_init
  4798                                  
  4799                                  skip_aux_port_init:			
  4800 00001875 B002                    		mov	al, 2		; init lpt3
  4801 00001877 E8E608                  		call	print_init
  4802 0000187A B001                    		mov	al, 1		; init lpt2
  4803 0000187C E8E108                  		call	print_init
  4804 0000187F 30C0                    		xor	al, al		; init lpt1
  4805 00001881 E8DC08                  		call	print_init
  4806                                  		
  4807 00001884 31D2                    		xor	dx, dx ; 0
  4808 00001886 8EDA                    		mov	ds, dx		; to initialize	print screen vector
  4809 00001888 8EC2                    		mov	es, dx
  4810 0000188A 31C0                    		xor	ax, ax
  4811                                  		; 16/10/2022
  4812 0000188C BF3405                  		mov	di, INITSPOT	; 0534h
  4813                                  		;mov	di, 534h	; INITSPOT (0000h:0534h)
  4814                                  					; IBM wants 4 zeros here
  4815 0000188F AB                      		stosw
  4816 00001890 AB                      		stosw
  4817 00001891 8CC8                    		mov	ax, cs		; fetch	segment
  4818 00001893 C7066C00[EE06]          		mov	word [BRKADR], cbreak
  4819                                  		;mov	word ptr ds:6Ch, offset	cbreak ; [BRKADR]
  4820                                  					; break	entry point
  4821 00001899 A36E00                  		mov	[BRKADR+2], ax		
  4822                                  		;mov	ds:6Eh,	ax	; vector for break
  4823 0000189C C706A400[6207]          		mov	word [CHROUT*4], outchr
  4824                                  		;mov	word ptr ds:0A4h, offset outchr	; [CHROUT*4]
  4825 000018A2 A3A600                  		mov	[CHROUT*4+2], ax
  4826                                  		;mov	ds:0A6h, ax	; [CHROUT*4+2]
  4827 000018A5 BF0400                  		mov	di, 4
  4828 000018A8 BB[F406]                		mov	bx, intret ; 19/10/2022
  4829                                  		;mov	bx, offset intret ; intret (cs:intret)
  4830                                  					; will initialize rest of interrupts
  4831 000018AB 93                      		xchg	ax, bx
  4832 000018AC AB                      		stosw			; location 4
  4833 000018AD 93                      		xchg	ax, bx		; cs:
  4834 000018AE AB                      		stosw			; int 1	; location 6
  4835 000018AF 83C704                  		add	di, 4
  4836 000018B2 93                      		xchg	ax, bx
  4837 000018B3 AB                      		stosw			; location 12
  4838 000018B4 93                      		xchg	ax, bx		; cs:
  4839 000018B5 AB                      		stosw			; int 3	; location 14
  4840 000018B6 93                      		xchg	ax, bx
  4841 000018B7 AB                      		stosw			; location 16
  4842 000018B8 93                      		xchg	ax, bx		; cs:
  4843 000018B9 AB                      		stosw			; int 4	; location 18
  4844 000018BA 89160005                		mov	[0500h], dx
  4845                                  		;mov	ds:500h, dx	; set print screen & break = 0
  4846 000018BE 89160405                		mov	[LSTDRV], dx	; [0504h]
  4847                                  		;mov	ds:504h, dx	; clean	out last drive spec
  4848                                  
  4849                                  ; we need to initalize the cs:motorstartup variable from the disk
  4850                                  ; parameter table at sec9. the offsets in this table are defined in
  4851                                  ; the disk_parms struc in msdskprm.inc. 2 locs
  4852                                  
  4853 000018C2 A02C05                  		mov	al, [SEC9+0Ah]	; 16/10/2022 
  4854                                  		;mov	al, ds:52Ch	; [SEC9+DISK_PARMS.DISK_MOTOR_STRT]
  4855                                  					; [522h+0Ah]
  4856                                  		; 21/12/2022
  4857                                  		; ds = 0
  4858                                  
  4859 000018C5 2EA2[2601]              		mov	[cs:motorstartup], al
  4860 000018C9 2E803E[3E06]FD          		cmp	byte [cs:model_byte], 0FDh ; is this an old rom?
  4861 000018CF 720B                    		jb	short no_diddle	; no
  4862 000018D1 C7062B050F02            		mov	word [SEC9+09h], 20Fh
  4863                                  		;mov	word ptr ds:52Bh, 20Fh ; [SEC9+DISK_PARMS.DISK_HEAD_STTL], 0200h+NORMSETTLE
  4864                                  					; set head settle and motor start on pc-1 pc-2 pc-xt hal0
  4865 000018D7 C6062205DF              		mov	byte [SEC9+0], 0DFh
  4866                                  		;mov	byte ptr ds:522h, 0DFh ; [SEC9+DISK_PARMS.DISK_SPECIFY_1]
  4867                                  					;  set 1st specify byte	on pc-1	pc-2 pc-xt hal0
  4868                                  no_diddle:				
  4869 000018DC CD12                    		int	12h		; MEMORY SIZE -
  4870                                  					; Return: AX = number of contiguous 1K blocks of memory
  4871 000018DE B106                    		mov	cl, 6
  4872 000018E0 D3E0                    		shl	ax, cl		; convert memory size to 16-byte blocks	(segment no.)
  4873                                  		
  4874                                  		; 21/12/2022
  4875                                  		;pop	cx
  4876                                  		;mov	[cs:drvfat], cx ; save drive to load dos, and fat id
  4877                                  		
  4878 000018E2 50                      		push	ax ; ***	; save real top	of memory
  4879                                  
  4880                                  ;M068 - BEGIN
  4881                                  ;------ Check if an RPL program is present at TOM and do not tromp over it
  4882                                  
  4883                                  		; 21/12/2022
  4884                                  		; ds = 0
  4885                                  		;push	ds
  4886                                  		;push	bx		; pushes not required but since this
  4887                                  		;			; happens to be a last minute change
  4888                                  		;			; & since it is only init code.
  4889                                  		;xor	bx, bx
  4890                                  		;mov	ds, bx
  4891                                  		
  4892                                  		;;mov	bx, ds:0BCh	; [2Fh*4]
  4893                                  		;mov	bx, [2Fh*4]
  4894                                  		;;mov	ds, word ptr ds:0BEh ; [2Fh*4+2]
  4895                                  		;mov	ds, [2Fh*4+2]
  4896                                  		; 29/09/2023
  4897 000018E3 C51EBC00                		lds	bx, [2Fh*4]
  4898                                  
  4899 000018E7 817F035250              		cmp	word [bx+3], 'RP' ; 'RPL'
  4900                                  		;cmp	word ptr [bx+3], 'PR' ; 'RPL'
  4901 000018EC 750F                    		jnz	short SkipRPL
  4902 000018EE 807F054C                		cmp	byte [bx+5], 'L'
  4903                                  		;cmp	byte ptr [bx+5], 'L'
  4904 000018F2 7509                    		jnz	short SkipRPL
  4905 000018F4 89C2                    		mov	dx, ax		; get TOM into DX
  4906 000018F6 B8064A                  		mov	ax, 4A06h	; (multMULT shl	8) + multMULTRPLTOM
  4907 000018F9 CD2F                    		int	2Fh		; Get new TOM from any RPL
  4908 000018FB 89D0                    		mov	ax, dx
  4909                                  SkipRPL:
  4910                                  		; 21/12/2022				
  4911                                  		;pop	bx
  4912                                  		;pop	ds
  4913                                  ;M068 - END
  4914                                  		; 21/12/2022
  4915 000018FD 0E                      		push	cs
  4916 000018FE 1F                      		pop	ds
  4917                                  
  4918 000018FF 83E840                  		sub	ax, 64		; room for fatloc segment. (1 kb buffer)
  4919                                  		; 21/12/2022
  4920 00001902 A3[D316]                		mov	[fatloc], ax
  4921                                  		;mov	[cs:fatloc], ax	; location to read fat
  4922                                  		
  4923 00001905 83E840                  		sub	ax, 64
  4924 00001908 A3[D516]                		mov	[init_bootseg], ax ; 21/12/2022
  4925                                  		;mov	[cs:init_bootseg], ax
  4926 0000190B 58                      		pop	ax ; ***	; get back real top of memory for
  4927                                  
  4928                                  		; 21/12/2022
  4929 0000190C 59                      		pop	cx ; **
  4930 0000190D 890E[CA16]              		mov	[drvfat], cx	; save drive to load dos, and fat id
  4931                                  
  4932                                  		;mov	dx, 46Dh	; SYSINIT segment
  4933 00001911 BA5704                  		mov	dx, SYSINITSEG	; 17/10/2022
  4934 00001914 8EDA                    		mov	ds, dx
  4935                                  
  4936                                  ; set pointer to resident device driver chain
  4937                                  
  4938                                  		; 17/10/2022
  4939 00001916 C706[7302][2300]        		mov	word [DEVICELIST], res_dev_list
  4940                                  		;mov	word [273h], res_dev_list
  4941                                  		;;mov	word ptr ds:273h, offset res_dev_list
  4942                                  					; [SYSINIT+DEVICE_LIST]
  4943 0000191C 8C0E[7502]              		mov	[DEVICELIST+2], cs		
  4944                                  		;mov	[275h], cs
  4945                                  		;;mov	word ptr ds:275h, cs ; [SYSINIT+DEVICE_LIST+2]
  4946                                  
  4947 00001920 A3[9202]                		mov	[MEMORYSIZE], ax
  4948                                  		;mov	[292h], ax
  4949                                  		;;mov	ds:292h, ax	; [SYSINIT+MEMORY_SIZE]
  4950                                  
  4951 00001923 FEC1                    		inc	cl
  4952 00001925 880E[9602]              		mov	[DEFAULTDRIVE], cl
  4953                                  		;mov	[296h], cl
  4954                                  		;;mov	ds:296h, cl	; [SYSINIT+DEFAULT_DRIVE]
  4955                                  
  4956 00001929 C706[7102]ED07          		mov	word [CURRENTDOSLOCATION], DOSLOADSEG
  4957                                  		;mov	word [271h], 83Fh ; (MSDOS.SYS segment)
  4958                                  		;;mov	word ptr ds:271h, 83Fh ; [SYSINIT+CURRENT_DOS_LOCATION]
  4959                                  					; dos_load_seg
  4960                                  
  4961                                  ; important: some old ibm hardware generates spurious int 0F's due to bogus
  4962                                  ; printer cards. we initialize this value to point to an iret only if
  4963                                  ;
  4964                                  ; 1) the original segment points to storage inside valid ram.
  4965                                  ;
  4966                                  ; 2) the original segment is 0F000:xxxx
  4967                                  
  4968                                  		;;mov	ax, 46Dh	; SYSINIT segment
  4969                                  		;mov	ax, SYSINITSEG	; 17/10/2022
  4970                                  		;mov	es, ax
  4971                                  		; 21/12/2022
  4972 0000192F 8EC2                    		mov	es, dx ; SYSINITSEG
  4973 00001931 31C9                    		xor	cx, cx ; 0
  4974 00001933 8ED9                    		mov	ds, cx		; segment 0
  4975                                  		;mov	ax, ds:3Eh	; [0Fh*4+2]
  4976 00001935 A13E00                  		mov	ax, [0Fh*4+2]	; segment for INT 0Fh
  4977                                  		; 18/10/2022
  4978 00001938 263B06[9202]            		cmp	ax, [es:MEMORYSIZE] ; es:292h
  4979                                  		;cmp	ax, es:292h	; [ES:SYSINIT+MEMORY_SIZE]  ; (condition 1)
  4980 0000193D 7605                    		jbe	short resetintf
  4981 0000193F 3D00F0                  		cmp	ax, 0F000h	; (condition 2)
  4982 00001942 750A                    		jnz	short keepintf
  4983                                  resetintf:	
  4984 00001944 C7063C00[F406]          		mov	word [0Fh*4], intret			
  4985                                  		;mov	word ptr ds:3Ch, offset	intret ; [0Fh*4]
  4986 0000194A 8C0E3E00                		mov	word [0Fh*4+2], cs
  4987                                  		;mov	word ptr ds:3Eh, cs ; [0Fh*4+2]
  4988                                  keepintf:				
  4989                                  ; end important
  4990                                  
  4991                                  ; 17/10/2022
  4992                                  ; 28/12/2018 - Retro DOS v4.0
  4993                                  
  4994                                  ; (MSDOS 6.0, MSINIT.ASM, 1991)
  4995                                  ;
  4996                                  ; we will check if the system has ibm extended keyboard by
  4997                                  ; looking at a byte at 40:96. if bit 4 is set, then extended keyboard
  4998                                  ; is installed, and we are going to set keyrd_func to 10h, keysts_func to 11h
  4999                                  ; for the extended keyboard function. use cx as the temporary register.
  5000                                  
  5001                                  		; 21/12/2022
  5002                                  		; ds = 0, cx = 0
  5003                                  		;xor	cx, cx
  5004                                  		;mov	ds, cx
  5005                                  		
  5006 0000194E 8A0E9604                		mov	cl, [496h]	; get keyboard flag
  5007                                  
  5008                                  		; 21/12/2022
  5009 00001952 0E                      		push	cs
  5010 00001953 1F                      		pop	ds
  5011                                  
  5012 00001954 F6C110                  		test	cl, 10h		; extended keyboard ?
  5013 00001957 740A                    		jz	short org_key	; no, original keyboard
  5014                                  
  5015                                  		; 21/12/2022
  5016                                  		; ds = cs
  5017 00001959 C606[E504]10            		mov	byte [keyrd_func], 10h ; extended keyboard
  5018 0000195E C606[E604]11            		mov	byte [keysts_func], 11h
  5019                                  		;mov	byte [cs:keyrd_func], 10h ; extended keyboard
  5020                                  		;mov	byte [cs:keysts_func], 11h
  5021                                  					; change for extended keyboard functions
  5022                                  org_key:
  5023                                  
  5024                                  ; 02/06/2018 - Retro DOS v3.0
  5025                                  
  5026                                  ;**************************************************************
  5027                                  ;	will initialize the number of drives
  5028                                  ;	after the equipment call (int 11h) bits 6&7 will tell
  5029                                  ;	the indications are as follows:
  5030                                  ;
  5031                                  ;	bits	7	6	drives
  5032                                  ;		0	0	1
  5033                                  ;		0	1	2
  5034                                  ;		1	0	3
  5035                                  ;		1	1	4
  5036                                  ;**************************************************************
  5037                                  				
  5038                                  		; 21/12/2022
  5039                                  		; ds = cs
  5040                                  		;push	cs
  5041                                  		;pop	ds
  5042                                  		;push	cs
  5043                                  		;pop	es
  5044                                  		
  5045 00001963 E84709                  		call	cmos_clock_read	; If cmos clock	exists,
  5046                                  					; then set the system time according to	that.
  5047                                  					; also,	reset the cmos clock rate.
  5048                                  		; 18/10/2022
  5049                                  		;mov	word ptr BData_start, offset harddrv ;
  5050                                  					; set up pointer to hdrive
  5051                                  		; 02/10/2022
  5052 00001966 C706[0000][1609]        		mov	word [hdrv_pat], harddrv 
  5053                                  					
  5054 0000196C 58                      		pop	ax ; *		; number of floppies and FAT ID
  5055 0000196D 30E4                    		xor	ah, ah		; chuck	fat id byte
  5056 0000196F A2[7500]                		mov	[drvmax], al	; remember which drive is hard disk
  5057 00001972 A2[2501]                		mov	[dsktnum], al	; and set initial number of drives
  5058 00001975 D1E0                    		shl	ax, 1
  5059 00001977 0106[5217]              		add	[last_dskdrv_table], ax
  5060                                  
  5061 0000197B B280                    		mov	dl, 80h
  5062 0000197D B408                    		mov	ah, 8
  5063 0000197F CD13                    		int	13h		; DISK - DISK -	GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)
  5064                                  					; DL = drive number
  5065                                  					; Return: CF set on error, AH =	status code, BL	= drive	type
  5066                                  					; DL = number of consecutive drives
  5067                                  					; DH = maximum value for head number, ES:DI -> drive parameter
  5068 00001981 7204                    		jc	short enddrv
  5069 00001983 8816[5117]              		mov	[hnum], dl
  5070                                  enddrv:
  5071                                  		; 21/12/2022
  5072 00001987 0E                      		push	cs
  5073 00001988 07                      		pop	es
  5074                                  
  5075                                  ; scan the list of drives to determine their type. we have three flavors of
  5076                                  ; diskette drives:
  5077                                  ;
  5078                                  ;   48tpi drives    we do nothing special for them
  5079                                  ;   96tpi drives    mark the fact that they have changeline support.
  5080                                  ;   3.5"  drives    mark changeline support and small.
  5081                                  ;
  5082                                  ; the following code uses registers for certain values:
  5083                                  ;
  5084                                  ;   dl - physical drive
  5085                                  ;   ds:di - points to current bds
  5086                                  ;   cx - flag bits for bds
  5087                                  ;   dh - form factor for the drive (1 - 48tpi, 2 - 96tpi, 3 - 3.5" medium)
  5088                                  					
  5089 00001989 30D2                    		xor	dl, dl
  5090                                  
  5091                                  		; 21/12/2022
  5092                                  		; ds = cs
  5093                                  		;push	cs
  5094                                  		;pop	ds
  5095                                  
  5096 0000198B C606[2C01]09            		mov	byte [eot], 9
  5097 00001990 BF[1901]                		mov	di, start_bds 	; if we	are faking floppy drives we need
  5098                                  					; to set aside two bdss	for the	two fake floppy	drives
  5099                                  
  5100                                  ; 02/10/2022 - Retro DOS v4.0 (MSDOS 5.0 IO.SYS)
  5101                                  ; 28/12/2018 - Retro DOS v4.0 (MSDOS 6.0, MSINIT.ASM)
  5102                                  
  5103                                  ; check to see if we are faking floppy drives. if not we don't
  5104                                  ; do anything special. if we are faking floppy drives we need
  5105                                  ; to set aside two bdss for the two fake floppy drives. we
  5106                                  ; don't need to initalise any fields though. so starting at start_bds
  5107                                  ; use the link field in the bds structure to go to the second bds
  5108                                  ; in the list and initalise it's link field to -1 to set the end of
  5109                                  ; the list. then jump to the routine at dohard to allocate/initialise
  5110                                  ; the bds for harddrives.
  5111                                  
  5112 00001993 803E[E116]01            		cmp	byte [fakefloppydrv], 1
  5113 00001998 750B                    		jnz	short loop_drive
  5114 0000199A 8B3D                    		mov	di, [di]	; [di+BDS.link]
  5115                                  					; di <-	first bds link
  5116 0000199C 8B3D                    		mov	di, [di]	; [di+BDS.link]
  5117                                  					; di <-	second bds link
  5118 0000199E C705FFFF                		mov	word [di], 0FFFFh ; set end of link
  5119 000019A2 E90F01                  		jmp	dohard		; allocate/initialise bds for harddrives
  5120                                  ;-----------------------------------------------------------------------------
  5121                                  
  5122                                  loop_drive:				
  5123 000019A5 3A16[7500]              		cmp	dl, [drvmax]
  5124 000019A9 7203                    		jb	short got_more
  5125 000019AB E90201                  		jmp	done_drives
  5126                                  ;-----------------------------------------------------------------------------
  5127                                  
  5128                                  got_more:				
  5129 000019AE 31C9                    		xor	cx, cx		; zero all flags
  5130 000019B0 8B3D                    		mov	di, [di]	; [di+BDS.link]
  5131                                  					; get next bds
  5132 000019B2 B600                    		mov	dh, 0		; ff48tpi
  5133                                  					; set form factor to 48	tpi
  5134 000019B4 C606[E016]28            		mov	byte [num_cyln], 40 ; 40 tracks per	side
  5135                                  		
  5136                                  		; 21/12/2022
  5137                                  		;push	ds
  5138 000019B9 57                      		push	di
  5139 000019BA 52                      		push	dx
  5140 000019BB 51                      		push	cx
  5141 000019BC 06                      		push	es ; es=cs=ds ; 21/12/2022
  5142 000019BD B408                    		mov	ah, 8
  5143 000019BF CD13                    		int	13h		; DISK - DISK -	GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)
  5144                                  					; DL = drive number
  5145                                  					; Return: CF set on error, AH =	status code, BL	= drive	type
  5146                                  					; DL = number of consecutive drives
  5147                                  					; DH = maximum value for head number, ES:DI -> drive parameter
  5148 000019C1 7276                    		jc	short noparmsfromrom
  5149                                  
  5150                                  ; if cmos is bad, it gives es,ax,bx,cx,dh,di=0. cy=0.
  5151                                  ; in this case, we are going to put bogus informations to bds table.
  5152                                  ; we are going to set ch=39,cl=9,dh=1 to avoid divide overflow when
  5153                                  ; they are calculated at the later time. this is just for the diagnostic
  5154                                  ; diskette which need msbio,msdos to boot up before it sets cmos.
  5155                                  ; this should only happen with drive b.
  5156                                  
  5157 000019C3 80FD00                  		cmp	ch, 0		; if ch=0, then	cl,dh=0	too.
  5158 000019C6 7505                    		jnz	short pfr_ok
  5159                                  		;mov	ch, 39		; rom gave wrong info.
  5160                                  		;mov	cl, 9		; let's default to 360k.
  5161                                  		; 21/12/2022
  5162 000019C8 B90927                  		mov	cx, 2709h
  5163 000019CB B601                    		mov	dh, 1
  5164                                  pfr_ok:					
  5165 000019CD FEC6                    		inc	dh		; make number of heads 1-based
  5166 000019CF FEC5                    		inc	ch		; make number of cylinders 1-based
  5167 000019D1 8836[DE16]              		mov	[num_heads], dh	; save parms returned by rom
  5168 000019D5 80E13F                  		and	cl, 3Fh
  5169 000019D8 880E[DF16]              		mov	[sec_trk], cl
  5170 000019DC 882E[E016]              		mov	[num_cyln], ch	; assume less than 256 cylinders!!
  5171                                  
  5172                                  ; make sure that eot contains the max number of sec/trk in system of floppies
  5173                                  
  5174 000019E0 3A0E[2C01]              		cmp	cl, [eot]	; may set carry
  5175                                  		;jbe	short eot_ok
  5176                                  		; 09/12/2022
  5177                                  		;jne	short eotok  ; wrong ! 14/08/2023
  5178                                  		; 14/08/2023
  5179 000019E4 7604                    		jbe	short eotok
  5180 000019E6 880E[2C01]              		mov	[eot], cl
  5181                                  ;eot_ok:					
  5182                                  eotok:
  5183 000019EA 07                      		pop	es ; es=cs=ds ; 21/12/2022
  5184 000019EB 59                      		pop	cx
  5185 000019EC 5A                      		pop	dx
  5186 000019ED 5F                      		pop	di
  5187                                  		; 21/12/2022
  5188                                  		;pop	ds
  5189                                  
  5190                                  ; Check	for presence of	changeline
  5191                                  
  5192 000019EE B415                    		mov	ah, 15h
  5193 000019F0 CD13                    		int	13h		; DISK - DISK -	GET TYPE (AT,XT2,XT286,CONV,PS)
  5194                                  					; DL = drive ID
  5195                                  					; Return: CF set on error, AH =	disk type (3 = hard drive)
  5196                                  					; CX:DX	= number of sectors on the media
  5197 000019F2 720D                    		jc	short changeline_done
  5198 000019F4 80FC02                  		cmp	ah, 2		; check	for presence of	changeline
  5199 000019F7 7508                    		jnz	short changeline_done
  5200                                  
  5201                                  ; we have a drive with change line support.
  5202                                  
  5203 000019F9 80C902                  		or	cl, 2		; fchangeline
  5204                                  					; signal type
  5205 000019FC C606[7700]01            		mov	byte [fhave96], 1 ; remember that we have 96tpi disks
  5206                                  
  5207                                  ; we now try to set up the form factor for the types of media that we know
  5208                                  ; and can recognise. for the rest, we set the form factor as "other".
  5209                                  
  5210                                  changeline_done:			
  5211 00001A01 803E[E016]28            		cmp	byte [num_cyln], 40
  5212 00001A06 750B                    		jnz	short try_80
  5213 00001A08 803E[DF16]09            		cmp	byte [sec_trk], 9
  5214 00001A0D 7653                    		jbe	short nextdrive
  5215                                  gotother:				
  5216 00001A0F B607                    		mov	dh, 7		; ffOther
  5217                                  					; we have a "strange" medium
  5218 00001A11 EB4F                    		jmp	short nextdrive
  5219                                  ;-----------------------------------------------------------------------------
  5220                                  
  5221                                  ; 80 cylinders and 9 sectors/track => 720 kb device
  5222                                  ; 80 cylinders and 15 sec/trk => 96 tpi medium
  5223                                  
  5224                                  try_80:					
  5225 00001A13 803E[E016]50            		cmp	byte [num_cyln], 80
  5226 00001A18 75F5                    		jnz	short gotother
  5227 00001A1A B609                    		mov	dh, 9		; ff288
  5228                                  					; assume 2.88 MB drive
  5229 00001A1C 803E[DF16]24            		cmp	byte [sec_trk], 36 ; is it	?
  5230 00001A21 743F                    		jz	short nextdrive	; yeah,	go update
  5231                                  
  5232                                  		; 12/05/2019 (ff144 type will not be used -compatibility problem-)
  5233                                  		; 08/01/2018 - Retro DOS v4.0 feature only ! for 1.44MB diskettes
  5234                                  		;mov	dh, ff144
  5235                                  		;cmp	byte [sec_trk], 18
  5236                                  		;je	short nextdrive
  5237                                  
  5238 00001A23 803E[DF16]0F            		cmp	byte [sec_trk], 15
  5239 00001A28 740B                    		jz	short got96
  5240                                  		
  5241 00001A2A 803E[DF16]09            		cmp	byte [sec_trk], 9
  5242 00001A2F 75DE                    		jnz	short gotother
  5243                                  		
  5244 00001A31 B602                    		mov	dh, 2		; ffSmall
  5245 00001A33 EB2D                    		jmp	short nextdrive
  5246                                  ; ----------------------------------------------------------------------------
  5247                                  
  5248                                  got96:					
  5249 00001A35 B601                    		mov	dh, 1		; ff96tpi
  5250 00001A37 EB29                    		jmp	short nextdrive
  5251                                  ; ----------------------------------------------------------------------------
  5252                                  
  5253                                  ; we have an old rom, so we either have a 48tpi or 96tpi drive. if the drive
  5254                                  ; has changeline, we assume it is a 96tpi, otherwise we treat it as a 48tpi.
  5255                                  
  5256                                  noparmsfromrom:				
  5257 00001A39 07                      		pop	es ; es=cs=ds ; 21/12/2022
  5258 00001A3A 59                      		pop	cx
  5259 00001A3B 5A                      		pop	dx
  5260 00001A3C 5F                      		pop	di
  5261                                  		; 21/12/2022
  5262                                  		;pop	ds
  5263                                  
  5264 00001A3D B415                    		mov	ah, 15h
  5265 00001A3F CD13                    		int	13h		; DISK - DISK -	GET TYPE (AT,XT2,XT286,CONV,PS)
  5266                                  					; DL = drive ID
  5267                                  					; Return: CF set on error, AH =	disk type (3 = hard drive)
  5268                                  					; CX:DX	= number of sectors on the media
  5269 00001A41 721F                    		jc	short nextdrive
  5270                                  
  5271 00001A43 80FC02                  		cmp	ah, 2		; is there changeline?
  5272 00001A46 751A                    		jnz	short nextdrive
  5273                                  
  5274 00001A48 80C902                  		or	cl, 2
  5275 00001A4B C606[7700]01            		mov	byte [fhave96], 1 ; fchangeline
  5276 00001A50 C606[E016]50            		mov	byte [num_cyln], 80
  5277 00001A55 B601                    		mov	dh, 1
  5278 00001A57 B00F                    		mov	al, 15
  5279 00001A59 3A06[2C01]              		cmp	al, [eot]
  5280 00001A5D 7603                    		jbe	short nextdrive
  5281 00001A5F A2[2C01]                		mov	[eot], al
  5282                                  ; ----------------------------------------------------------------------------
  5283                                  
  5284                                  nextdrive:				
  5285 00001A62 80C920                  		or	cl, 20h		; fi_own_physical
  5286                                  					; set this true	for all	drives
  5287 00001A65 88D7                    		mov	bh, dl		; save int13 drive number
  5288                                  
  5289                                  ; we need to do special things if we have a single drive system and are setting
  5290                                  ; up a logical drive. it needs to have the same int13 drive number as its
  5291                                  ; counterpart, but the next drive letter. also reset ownership flag.
  5292                                  ; we detect the presence of this situation by examining the flag single for the
  5293                                  ; value 2.
  5294 00001A67 803E[7800]02            		cmp	byte [single], 2
  5295 00001A6C 7505                    		jnz	short not_special
  5296 00001A6E FECF                    		dec	bh		; int13	drive number same for logical drive
  5297 00001A70 80F120                  		xor	cl, 20h		; reset	ownership flag for logical drive
  5298                                  not_special:
  5299                                  
  5300                                  ; the values that we put in for BDS_RBPB.BPB_HEADS and
  5301                                  ; BDS_RBPB.BPB_SECTORSPERTRACK will only remain if the
  5302                                  ; form factor is of type "ffother".
  5303                                  				
  5304 00001A73 31C0                    		xor	ax, ax		; fill BDS for drive
  5305 00001A75 A0[DE16]                		mov	al, [num_heads]
  5306 00001A78 894536                  		mov	[di+36h], ax	; [di+BDS.rheads]
  5307 00001A7B A0[DF16]                		mov	al, [sec_trk]
  5308 00001A7E 894534                  		mov	[di+34h], ax	; [di+BDS.rsecpertrack]
  5309 00001A81 894D23                  		mov	[di+23h], cx	; [di+BDS.flags]
  5310 00001A84 887522                  		mov	[di+22h], dh	; [di+BDS.formfactor]
  5311 00001A87 885505                  		mov	[di+5],	dl	; [di+BDS.drivelet]
  5312 00001A8A 887D04                  		mov	[di+4],	bh	; [di+BDS.drivenum]
  5313 00001A8D 8A1E[E016]              		mov	bl, [num_cyln]
  5314 00001A91 885D25                  		mov	[di+25h], bl	; [di+BDS.cylinders]
  5315 00001A94 803E[7800]01            		cmp	byte [single], 1 ; Special case for single drive system
  5316 00001A99 7511                    		jnz	short no_single
  5317 00001A9B C606[7800]02            		mov	byte [single], 2 ; Don't forget we have
  5318                                  					; single drive system
  5319                                  		; 18/12/2022
  5320 00001AA0 80C910                  		or	cl, 10h
  5321                                  		;or	cx, 10h		; fi_am_mult
  5322                                  					; set that this	is one of several drives
  5323 00001AA3 094D23                  		or	[di+23h], cx	; [di+BDS.flags]
  5324                                  					; save flags
  5325 00001AA6 8B3D                    		mov	di, [di]	; [di+BDS.link]
  5326                                  					; move to next BDS in list
  5327 00001AA8 FEC2                    		inc	dl		; add a	number
  5328 00001AAA EBB6                    		jmp	short nextdrive	; Use same info	for BDS	as previous
  5329                                  ; ----------------------------------------------------------------------------
  5330                                  
  5331                                  no_single:				
  5332                                  		;inc	dl
  5333                                  		; 18/12/2022
  5334 00001AAC 42                      		inc	dx
  5335 00001AAD E9F5FE                  		jmp	loop_drive
  5336                                  ; ----------------------------------------------------------------------------
  5337                                  
  5338                                  done_drives:	
  5339                                  		;mov	word [di+BDS.link], -1			
  5340 00001AB0 C705FFFF                		mov	word [di], -1	; set link to null
  5341                                  
  5342                                  ; set up all the hard drives in	the system
  5343                                  
  5344                                  dohard:					
  5345 00001AB4 8A36[5117]              		mov	dh, [hnum]
  5346 00001AB8 08F6                    		or	dh, dh		; done if no hardfiles
  5347 00001ABA 745B                    		jz	short static_configure
  5348 00001ABC B280                    		mov	dl, 80h
  5349                                  dohard1:				
  5350 00001ABE 52                      		push	dx
  5351 00001ABF 8B3E[5417]              		mov	di, [end_of_bdss]
  5352 00001AC3 8A1E[7500]              		mov	bl, [drvmax]
  5353 00001AC7 B700                    		mov	bh, 0		; first	primary	partition (or active)
  5354 00001AC9 E82702                  		call	sethard
  5355 00001ACC 7208                    		jb	short hardfile_err
  5356 00001ACE E89207                  		call	dmax_check	; error	if already 26 drives
  5357 00001AD1 7303                    		jnb	short hardfile_err
  5358 00001AD3 E8A207                  		call	xinstall_bds	; insert new bds into linked list
  5359                                  hardfile_err:				
  5360 00001AD6 5A                      		pop	dx
  5361 00001AD7 FEC2                    		inc	dl		; next hard drive
  5362 00001AD9 FECE                    		dec	dh
  5363 00001ADB 75E1                    		jnz	short dohard1
  5364                                  
  5365                                  ; end of physical drive	initialization
  5366                                  
  5367                                  ; *** do not change the position of the following statement.
  5368                                  ; *** domini routine will use [drvmax] value for the start of the logical
  5369                                  ; *** drive number of mini disk(s).
  5370                                  					
  5371 00001ADD E89106                  		call	domini		; for setting up mini disks, if found
  5372                                  
  5373                                  ; -- begin added section
  5374                                  
  5375 00001AE0 8A36[5117]              		mov	dh, [hnum]	; we already know this is >0
  5376 00001AE4 B280                    		mov	dl, 80h
  5377                                  dohardx1:				
  5378 00001AE6 B701                    		mov	bh, 1		; do all subsequent primary partitions
  5379                                  dohardx2:				
  5380 00001AE8 52                      		push	dx
  5381 00001AE9 53                      		push	bx
  5382 00001AEA 8B3E[5417]              		mov	di, [end_of_bdss]
  5383 00001AEE 8A1E[7500]              		mov	bl, [drvmax]
  5384 00001AF2 E8FE01                  		call	sethard
  5385 00001AF5 720E                    		jb	short dohardx4	; move to next hardfile	if error
  5386 00001AF7 E86907                  		call	dmax_check	; make sure <=26 drives
  5387 00001AFA 7309                    		jnb	short dohardx4	; skip if error
  5388 00001AFC E87907                  		call	xinstall_bds	; insert new bds into linked list
  5389 00001AFF 5B                      		pop	bx		; get partition	number
  5390 00001B00 5A                      		pop	dx		; restore physical drive counts
  5391 00001B01 FEC7                    		inc	bh
  5392 00001B03 EBE3                    		jmp	short dohardx2	; keep looping until we	fail
  5393                                  ; ----------------------------------------------------------------------------
  5394                                  
  5395                                  dohardx4:				
  5396 00001B05 5B                      		pop	bx		; unjunk partition number from stack
  5397 00001B06 5A                      		pop	dx		; restore physical drive counts
  5398 00001B07 FEC2                    		inc	dl		; next hard drive
  5399 00001B09 FECE                    		dec	dh
  5400 00001B0B 75D9                    		jnz	short dohardx1
  5401                                  
  5402                                  ; -- end changed section
  5403                                  
  5404                                  ;******************************************************************************
  5405                                  ; if more than 2 diskette drives on the system, then it is necessary to remap
  5406                                  ; the bds chain to adjust the logical drive num (drive letter) with greater
  5407                                  ; than two diskette drives
  5408                                  ;
  5409                                  ; new scheme:	if more than 2 disktte drives, first map the bds structure
  5410                                  ;		as usual and then rescan the bds chain to adjust the  drive
  5411                                  ;		letters. to do this, scan for disk drives and assign logical
  5412                                  ;		drive number starting from 2 and then rescan diskette drives
  5413                                  ;		and assign next to the last logical drive number of last disk
  5414                                  ;		drive to the 3rd and 4th diskette drives.
  5415                                  ;******************************************************************************
  5416                                  
  5417 00001B0D 803E[2501]02            		cmp	byte [dsktnum], 2 ; >2 diskette drives
  5418                                  		;jbe	short static_configure ; no - no need for remapping
  5419 00001B12 7603                    		jbe	short no_remap
  5420 00001B14 E85801                  		call	remap		; remap	bds chain to adjust driver letters
  5421                                  no_remap:
  5422                                  
  5423                                  ; End of drive initialization.
  5424                                  
  5425                                  ; ----------------------------------------------------------------------------
  5426                                  
  5427                                  ;we now decide, based on the configurations available so far, what
  5428                                  ;code or data we need to keep as a stay resident code. the following table
  5429                                  ;shows the configurations under consideration. they are listed in the order
  5430                                  ;of their current position memory.
  5431                                  ;
  5432                                  ;configuration will be done in two ways:
  5433                                  ;
  5434                                  ;first, we are going to set "static configuration". static configuration will
  5435                                  ;consider from basic configuration to endof96tpi configuration. the result
  5436                                  ;of static configuration will be the address the dynamic configuration will
  5437                                  ;use to start with.
  5438                                  ;
  5439                                  ;secondly, "dynamic cofiguration" will be performed. dynamic configuration
  5440                                  ;involves possible relocation of code or data. dynamic configuration routine
  5441                                  ;will take care of bdsm tables and at rom fix module thru k09 suspend/resume
  5442                                  ;code individually. after these operation, [dosdatasg] will be set.
  5443                                  ;this will be the place sysinit routine will relocate msdos module for good.
  5444                                  
  5445                                  ; -- begin changed section
  5446                                  ;
  5447                                  ;   1.	 basic configuration for msbio (endfloppy)
  5448                                  ;   2.   end96tpi	; a system that supports "change line error"
  5449                                  ;   3.	 end of bdss	; end of bdss for hard disks
  5450                                  ;   4.	 endatrom	;some of at rom fix module.
  5451                                  ;   5.	 endcmosclockset;supporting program for cmos clock write.
  5452                                  ;   6.	 endk09 	;k09 cmos clock module to handle suspend/resume operation.
  5453                                  ;
  5454                                  
  5455                                  ; 02/10/2022 - Retro DOS v4.0 (MSDOS v5.0 IO.SYS)
  5456                                  
  5457                                  static_configure:			
  5458 00001B17 8B3E[5417]              		mov	di, [end_of_bdss]
  5459 00001B1B 81FF[1709]              		cmp	di, bdss	; 19/10/2022
  5460                                  		;cmp	di, offset bdss	; did we allocate any hard drive bdss?
  5461 00001B1F 750D                    		jnz	short dynamic_configure	; that's the end, then
  5462                                  		; 18/10/2022
  5463 00001B21 BF[1709]                		mov	di, end96tpi
  5464                                  		;mov	di, offset harddrv ; end96tpi
  5465                                  					; keep everything up to	end96tpi
  5466 00001B24 803E[7700]00            		cmp	byte [fhave96], 0
  5467 00001B29 7503                    		jnz	short dynamic_configure
  5468                                  		
  5469 00001B2B BF[FC08]                		mov	di, endfloppy
  5470                                  dynamic_configure:			
  5471                                  		; 20/12/2022
  5472                                  		;push	cs
  5473                                  		;pop	es
  5474                                  		
  5475 00001B2E FC                      		cld
  5476                                  
  5477                                  ; -- end changed section
  5478                                  
  5479                                  		; 21/12/2022
  5480                                  		; ds = cs <> es
  5481                                  		; ss = 0
  5482                                  		; sp = 700h
  5483                                  
  5484 00001B2F 803E[3E06]FC            		cmp	byte [model_byte], 0FCh ; AT ?
  5485 00001B34 7577                    		jnz	short checkcmosclock
  5486 00001B36 803E[5117]00            		cmp	byte [hnum], 0	; No hard file?
  5487 00001B3B 7470                    		jz	short checkcmosclock
  5488 00001B3D 97                      		xchg	ax, di		; save allocation pointer in ax
  5489 00001B3E BE00F0                  		mov	si, 0F000h
  5490 00001B41 8EC6                    		mov	es, si		; ES ->	ROM BIOS segment
  5491 00001B43 BE[5A17]                		mov	si, bios_date	; "01/10/84"
  5492 00001B46 BFF5FF                  		mov	di, 0FFF5h	; ROM BIOS string is at	F000:FFF5
  5493 00001B49 B90900                  		mov	cx, 9		; bdate_l
  5494                                  					; Only patch ROM for bios 01/10/84
  5495 00001B4C F3A6                    		repe cmpsb		; check	for date + zero	on end
  5496 00001B4E 97                      		xchg	ax, di		; restore allocation pointer
  5497                                  
  5498                                  ; M015 -- begin changes
  5499                                  
  5500                                  		;jnz	short checkcmosclock
  5501                                  		; 02/10/2022
  5502 00001B4F 7508                    		jnz	short checkcompaqbug
  5503                                  
  5504                                  ; install at rom fix
  5505                                  
  5506                                  		; 19/10/2022
  5507                                  		;mov	cx, offset endatrom
  5508 00001B51 B9[0A14]                		mov	cx, endatrom
  5509                                  		;mov	si, offset ibm_disk_io
  5510 00001B54 BE[DC12]                		mov	si, ibm_disk_io
  5511 00001B57 EB46                    		jmp	short install_int13_patch
  5512                                  ; ----------------------------------------------------------------------------
  5513                                  
  5514                                  ; M065 -- begin changes
  5515                                  ;
  5516                                  ; On certain systems with Western Digital disk controllers, the
  5517                                  ; following detection scheme caused an unpredictable and serious
  5518                                  ; failure. In particular, they've implemented a nonstandard
  5519                                  ; Int13(ah=16h) which reconfigures the hard drive, depending on
  5520                                  ; what happens to be at es:[bx] and other memory locations indexed
  5521                                  ; off of it.
  5522                                  ;
  5523                                  ; Compaq was unable to tell us exactly which kind of systems have
  5524                                  ; the bug, except that they guarantee that the bug was fixed in
  5525                                  ; ROM BIOSs dated 08/04/86 and later. We'll check for the COMPAQ
  5526                                  ; string, and then look for date codes before 08/04/86 to decide
  5527                                  ; when to install the hook.
  5528                                  
  5529                                  ;checkcmosclock:
  5530                                  ; 02/10/2022				
  5531                                  checkcompaqbug:
  5532                                  		; 21/12/2022
  5533                                  		; es = 0F000h
  5534                                  		;mov	ax, 0F000h	; point	to ROM BIOS
  5535                                  		;mov	es, ax
  5536                                  
  5537                                  		; 19/10/2022
  5538 00001B59 26813EEAFF434F          		cmp	word [es:0FFEAh], 'CO'
  5539                                  		;cmp	word ptr es:0FFEAh, 'OC' ; look for COMPAQ
  5540 00001B60 754B                    		jnz	short not_compaq_patch
  5541 00001B62 26813EECFF4D50          		cmp	word [es:0FFECh], 'MP'
  5542                                  		;cmp	word ptr es:0FFECh, 'PM'
  5543 00001B69 7542                    		jnz	short not_compaq_patch
  5544 00001B6B 26813EEEFF4151          		cmp	word [es:0FFEEh], 'AQ'
  5545                                  		;cmp	word ptr es:0FFEEh, 'QA'
  5546 00001B72 7539                    		jnz	short not_compaq_patch
  5547                                  
  5548                                  ; We're running on a COMPAQ. Now look at the date code.
  5549                                  
  5550 00001B74 26A1FBFF                		mov	ax, [es:0FFFBh]	; get year
  5551 00001B78 86E0                    		xchg	ah, al
  5552 00001B7A 3D3638                  		cmp	ax, 3836h ; 02/10/2022 (NASM syntax)
  5553                                  		;cmp	ax, '86'        ; 3836h
  5554                                  					; is it	86?
  5555 00001B7D 772E                    		ja	short not_compaq_patch
  5556 00001B7F 7218                    		jb	short do_compaq_patch
  5557 00001B81 26A1F5FF                		mov	ax, [es:0FFF5h]	; get month
  5558 00001B85 86E0                    		xchg	ah, al
  5559 00001B87 3D3830                  		cmp	ax, 3038h ; 02/10/2022 (NASM syntax)
  5560                                  		;cmp	ax, '08'        ; 3038h
  5561                                  					; is it	08?
  5562 00001B8A 7721                    		ja	short not_compaq_patch
  5563 00001B8C 720B                    		jb	short do_compaq_patch
  5564 00001B8E 26A1F8FF                		mov	ax, [es:0FFF8h]	; get day
  5565 00001B92 86E0                    		xchg	ah, al
  5566 00001B94 3D3430                  		cmp	ax, 3034h ; 02/10/2022 (NASM syntax)
  5567                                  		;cmp	ax, '04'        ; 3034h
  5568                                  					; is it	04?
  5569 00001B97 7314                    		jnb	short not_compaq_patch
  5570                                  
  5571                                  do_compaq_patch:			
  5572 00001B99 B9[2B14]                		mov	cx, end_compaq_i13hook
  5573 00001B9C BE[0A14]                		mov	si, endatrom
  5574                                  
  5575                                  install_int13_patch:			
  5576 00001B9F 0E                      		push	cs
  5577 00001BA0 07                      		pop	es
  5578                                  		; 18/10/2022
  5579 00001BA1 893E[B400]              		mov	[Orig13], di	; set new rom bios int 13 vector
  5580 00001BA5 8C0E[B600]              		mov	[Orig13+2], cs
  5581 00001BA9 29F1                    		sub	cx, si		; size of rom fix module
  5582 00001BAB F3A4                    		rep movsb		; relocate it
  5583                                  
  5584                                  ; M065 -- end changes
  5585                                  
  5586                                  ; ----------------------------------------------------------------------------
  5587                                  not_compaq_patch:			; M065
  5588                                  		; 17/10/2022
  5589                                  checkcmosclock:	
  5590                                  		; 18/10/2022		
  5591 00001BAD 0E                      		push	cs
  5592 00001BAE 07                      		pop	es
  5593                                  
  5594                                  		; 21/12/2022
  5595                                  		; ds = cs = es
  5596                                  		; ss = 0
  5597                                  		; sp = 700h
  5598                                  
  5599 00001BAF 803E[F304]01            		cmp	byte [havecmosclock], 1 ; cmos clock exists?
  5600 00001BB4 7518                    		jnz	short checkk09	; no
  5601 00001BB6 893E[0605]              		mov	word [daycnttoday], di
  5602                                  		;mov	word ptr ds:daycnttoday, di ; set the address for mschar
  5603 00001BBA B9D100                  		mov	cx, 209		; enddaycnttoday - daycnt_to_day
  5604 00001BBD BE[2C14]                		mov	si, daycnt_to_day
  5605 00001BC0 F3A4                    		rep movsb
  5606 00001BC2 893E[0205]              		mov	word [bintobcd], di
  5607                                  		;mov	word ptr ds:bintobcd, di ; set the address for msclock
  5608                                  					; let original segment stay
  5609 00001BC6 B90B00                  		mov	cx, 11
  5610 00001BC9 BE[FD14]                		mov	si, bin_to_bcd
  5611 00001BCC F3A4                    		rep movsb
  5612                                  checkk09:				
  5613 00001BCE 57                      		push	di ; ? ; save ? ; 21/12/2022
  5614 00001BCF B80141                  		mov	ax, 4101h	; wait for bh=es:[di]
  5615 00001BD2 B301                    		mov	bl, 1		; wait for 1 clock tick
  5616 00001BD4 268A3D                  		mov	bh, [es:di]
  5617 00001BD7 F9                      		stc			; Assume we will fail
  5618 00001BD8 CD15                    		int	15h		; SYSTEM - WAIT	ON EXTERNAL EVENT (CONVERTIBLE)
  5619                                  					; AL = condition type, BH = condition compare or mask value
  5620                                  					; BL = timeout value times 55 milliseconds, 00h	means no timeout
  5621                                  					; DX = I/O port	address	if AL bit 4 set
  5622 00001BDA 5F                      		pop	di ; ?
  5623 00001BDB 721B                    		jc	short configdone ; 21/12/2022
  5624                                  
  5625 00001BDD C606[7900]01            		mov	byte [fhavek09], 1
  5626                                  					; remember we have a k09 type
  5627 00001BE2 1E                      		push	ds
  5628 00001BE3 31C0                    		xor	ax, ax
  5629 00001BE5 8ED8                    		mov	ds, ax
  5630                                  		
  5631 00001BE7 893EB001                		mov	[6Ch*4], di
  5632                                  		;mov	ds:1B0h, di	; [6Ch*4]
  5633                                  					; new int 6ch handler
  5634                                  		;mov	word ptr ds:1B2h, cs ; [6Ch*4+2]
  5635 00001BEB 8C0EB201                		mov	word [6Ch*4+2], cs
  5636 00001BEF 1F                      		pop	ds
  5637                                  		; 21/12/2022
  5638                                  		; ds = cs = es
  5639 00001BF0 BE[0815]                		mov	si, int6c
  5640 00001BF3 B9C201                  		mov	cx, endk09-int6c ; 459
  5641                                  		;mov	cx, 459		; endk09 - int6c
  5642                                  					; size of k09 routine
  5643 00001BF6 F3A4                    		rep movsb		;
  5644                                  					; set up config	stuff for sysinit
  5645                                  ; ----------------------------------------------------------------------------
  5646                                  ; Set up config stuff for SYSINIT
  5647                                  
  5648                                  ; 17/10/2022
  5649                                  ;SETDRIVE equ SetDrive - DOSBIOSEG_2C7h ; (4D7h for MSDOS 5.0 IO.SYS)
  5650                                  ;GETBP equ GetBp - DOSBIOSEG_2C7h ; (606h for MSDOS 5.0 IO.SYS)
  5651                                  ; 09/12/2022
  5652                                  SETDRIVE equ SetDrive
  5653                                  GETBP equ GetBp
  5654                                  		
  5655                                  		; 17/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
  5656                                  configdone:				
  5657                                  		; 28/09/2023
  5658                                  		; ds = cs
  5659                                  		;push	cs		; di is	final ending address of	msbio.
  5660                                  		;pop	ds
  5661                                  
  5662 00001BF8 83C70F                  		add	di, 15		; round	(up) to	paragraph
  5663                                  		; 10/12/2022
  5664                                  		;shr	di, 1
  5665                                  		;shr	di, 1
  5666                                  		;shr	di, 1
  5667                                  		;shr	di, 1
  5668 00001BFB B104                    		mov	cl, 4
  5669 00001BFD D3EF                    		shr	di, cl		
  5670                                  		; 10/12/2022
  5671                                  		;add	di, 70h		; KERNEL_SEGMENT (in fact: IO.SYS loading segment)
  5672                                  		; 19/10/2022 - Temporary !
  5673                                  		;db	81h, 0C7h, 70h, 0 ; add di, 0070h
  5674                                  		; 13/08/2023
  5675 00001BFF 83C770                  		add	di, 70h
  5676 00001C02 893E[0300]              		mov	[DosDataSg], di	; where	the dos	data segment will be
  5677 00001C06 A1[CA16]                		mov	ax, [drvfat]	; get drive and	fat id
  5678                                  		; 22/12/2022
  5679                                  		; Note: SETDRIVES uses AL (drive number) only
  5680 00001C09 BD[CB04]                		mov	bp, SETDRIVE
  5681                                  		;mov	bp, 4D7h	; set_drive (in	dosbios	code segment)
  5682                                  					; at 2C7h:4D7h = 70h:2A47h
  5683 00001C0C 0E                      		push	cs		; simulate far call
  5684 00001C0D E855FB                  		call	call_bios_code	; get bds for drive
  5685 00001C10 BD[F805]                		mov	bp, GETBP	; ensure valid bpb is present	
  5686                                  		;mov	bp, 606h	; GetBp (2C7h:606h = 70h:2B76h) 
  5687 00001C13 0E                      		push	cs
  5688 00001C14 E84EFB                  		call	call_bios_code
  5689                                  
  5690                                  	; resort to funky old segment definitions for now
  5691                                  
  5692                                  		; 22/12/2022
  5693                                  		;push	es		; copy bds to ds:di
  5694                                  		;pop	ds
  5695                                  
  5696                                  	; the following read of es:0000 was spurious anyway. Should look into it.
  5697                                  	;
  5698                                  	; hmmmmmm. j.k. took out a call to getfat right here a while
  5699                                  	;	  back. Apparently it was what actually setup es: for the following
  5700                                  	; cas----
  5701                                  
  5702                                  		; 22/12/2022
  5703                                  		;xor	di, di
  5704                                  		;mov	al, [es:di]	; get fat id byte
  5705                                  		;;mov	byte ptr es:drvfat+1, al ; save fat byte
  5706                                  		;mov	[es:drvfat+1], al
  5707                                  		;mov	ax, [es:drvfat]
  5708                                  		
  5709                                  		; 22/12/2022
  5710                                  		; ds = cs
  5711                                  	;;;	mov	al, [drvfat]
  5712                                  
  5713                                  	; cas -- why do a SECOND setdrive here???
  5714                                  
  5715                                  		; 22/12/2022
  5716                                  		;push	es		; save whatever's in es
  5717                                  		;push	ds		; copy bds to es:di
  5718                                  		;pop	es
  5719                                  		;push	cs		; copy Bios_Data to ds
  5720                                  		;pop	ds
  5721                                  	
  5722                                  	; 22/12/2022
  5723                                  	;;;	mov	bp, SETDRIVE
  5724                                  	;;;	;mov	bp, 4D7h	; SetDrive (2C7h:47Dh = 70h:2A47h)
  5725                                  	;;;	push	cs		; simulate far call
  5726                                  	;;;	call	call_bios_code	; get correct bds for this drive
  5727                                  	
  5728                                  		; 22/12/2022
  5729                                  		;push	es		; copy bds back to ds:di
  5730                                  		;pop	ds
  5731                                  		;pop	es		; pop whatever was in es
  5732                                  
  5733                                  	; Now we load in the MSDOS.SYS file
  5734                                  
  5735                                  	; 22/12/2022
  5736                                  	; -----
  5737                                  	;	mov	bx, [di+6]	; [di+BDS.BDS_BPB.BPB_BYTESPERSECTOR]
  5738                                  	;	mov	[cs:md_sectorsize], bx	; used by get_fat_sector proc.
  5739                                  	;	mov	bl, [di+1Fh]	; [di+BDS.fatsiz]
  5740                                  	;				; get size of fat on media
  5741                                  	;	;mov	es:16DEh, bl
  5742                                  	;	mov	[es:fbigfat], bl
  5743                                  	;	mov	cl, [di+8]
  5744                                  	;	mov	ax, [di+17h] ; [di+BDS.BDS_BPB.BPB_HIDDENSECTORS]
  5745                                  	;	;sub	es:16D8h, ax
  5746                                  	;	sub	[es:bios_l], ax	; subtract hidden sectors since we
  5747                                  	;				; need a logical sector number that will
  5748                                  	;				; be used by getclus(diskrd procedure)
  5749                                  	;	mov	ax, [di+19h] ; [di+BDS.BDS_BPB.BPB_HIDDENSECTORS+2]
  5750                                  	;	;sbb	es:16DAh, ax
  5751                                  	;	sbb	[es:bios_h], ax	; subtract upper 16 bits of sector num
  5752                                  	; -----
  5753                                  		
  5754                                  	; -----	; 22/12/2022
  5755 00001C17 268B5D06                		mov	bx, [es:di+6]	; [di+BDS.BDS_BPB.BPB_BYTESPERSECTOR]
  5756 00001C1B 891E[D816]              		mov	[md_sectorsize], bx ; used by get_fat_sector proc.
  5757 00001C1F 268A5D1F                		mov	bl, [es:di+1Fh]	; [di+BDS.fatsiz]
  5758                                  					; get size of fat on media
  5759 00001C23 881E[D216]              		mov	[fbigfat], bl
  5760 00001C27 268A4D08                		mov	cl, [es:di+8]
  5761 00001C2B 268B4517                		mov	ax, [es:di+17h] ; [di+BDS.BDS_BPB.BPB_HIDDENSECTORS]
  5762 00001C2F 2906[CC16]              		sub	[bios_l], ax	; subtract hidden sectors since we
  5763                                  					; need a logical sector number that will
  5764                                  					; be used by getclus(diskrd procedure)
  5765 00001C33 268B4519                		mov	ax, [es:di+19h] ; [di+BDS.BDS_BPB.BPB_HIDDENSECTORS+2]
  5766 00001C37 1906[CE16]              		sbb	[bios_h], ax	; subtract upper 16 bits of sector num
  5767                                  	; ------
  5768                                  
  5769 00001C3B 30ED                    		xor	ch, ch	 ; cx = sectors/cluster
  5770                                  
  5771                                  	; the boot program has left the directory at 0:500h
  5772                                  
  5773 00001C3D 1E                      		push	ds
  5774 00001C3E 31FF                    		xor	di, di
  5775 00001C40 8EDF                    		mov	ds, di
  5776 00001C42 8B1E3A05                		mov	bx, [53Ah]
  5777                                  		;mov	bx, ds:53Ah	; clus=*53Ah
  5778                                  					; (First cluster field of 2nd dir entry
  5779                                  					; of root directory in the buffer at 500h)
  5780 00001C46 1F                      		pop	ds
  5781                                  loadit:
  5782 00001C47 B85704                  		mov	ax, SYSINITSEG	; 46Dh
  5783                                  		;mov	ax, 46Dh	; sysinit segment
  5784 00001C4A 8EC0                    		mov	es, ax
  5785 00001C4C 268E06[7102]            		mov	es, [es:CURRENTDOSLOCATION] ; 09/12/2022
  5786                                  		;mov	es, [es:271h]
  5787                                  
  5788 00001C51 E80407                  		call	getclus		; read cluster at ES:DI (DI is updated)
  5789                                  ; ----------------------------------------------------------------------------
  5790                                  
  5791                                  		;test	byte [cs:fbigfat], fbig
  5792 00001C54 2EF606[D216]40          		test	byte [cs:fbigfat], 40h ; fbig
  5793 00001C5A 7506                    		jnz	short eofbig
  5794 00001C5C 81FBF70F                		cmp	bx, 0FF7h
  5795 00001C60 EB03                    		jmp	short iseofx
  5796                                  ; ----------------------------------------------------------------------------
  5797                                  
  5798                                  eofbig:
  5799 00001C62 83FBF7                  		cmp	bx, 0FFF7h
  5800                                  iseofx:
  5801 00001C65 72E0                    		jb	short loadit	; keep loading until cluster = eof
  5802 00001C67 E83D04                  		call	setdrvparms	; 
  5803                                  
  5804                                  		;;jmp	far ptr	46Dh:267h ; jmp	SYSINIT_SEG:SYSINIT_START
  5805                                  		;jmp	far 46Dh:267h
  5806 00001C6A EA[6702]5704            		jmp	SYSINITSEG:SYSINITSTART
  5807                                  
  5808                                  ; =============== S U B	R O U T	I N E ========================================
  5809                                  
  5810                                  ; Following are subroutines to support resident device driver initialization
  5811                                  ;
  5812                                  ;M011 -- note:  deleted setup_bdsms and reset_bdsms here
  5813                                  
  5814                                  ;	M035 -- begin changed section
  5815                                  
  5816                                  ;******************************************************************************
  5817                                  ; module name: remap
  5818                                  ;
  5819                                  ; descriptive name: all the code for himem that could be separated from msbio
  5820                                  ;
  5821                                  ; function:  remap the bds chain to adjusted logical drive numbers (drive
  5822                                  ;	     letters) if more than two diskette drives on the system.
  5823                                  ;
  5824                                  ;     scheme:  if more than 2 diskette drives, first map the bds structure
  5825                                  ;	       as usual and then rescan the bds chain to adjust the drive
  5826                                  ;	       letters. to do this, scan for disk drives and assign logical
  5827                                  ;	       drive number starting from 2 and then rescan diskette drives
  5828                                  ;	       and assign next to the last logical drive number of last disk
  5829                                  ;	       drive to the 3rd and 4th diskette drives.
  5830                                  
  5831                                  ; input:       none
  5832                                  ; exit:	drive letters have been remapped in bds chain
  5833                                  ; exit error:  none
  5834                                  ; called from: msinit
  5835                                  ;
  5836                                  ; notes:  this function  will be called only if more than 2 diskettes are
  5837                                  ;	  found in the system
  5838                                  ;	  this function assumes that there are no more than 26 drives assigned
  5839                                  ;	    this is guaranteed by the code that creates bdss for partitions
  5840                                  ;	  this function assumes that the first entries in the chain are
  5841                                  ;	   floppy drives, and all the rest are hard drives
  5842                                  ;	  will alter the boot drive if necessary to reflect remapping
  5843                                  ;
  5844                                  ;******************************************************************************
  5845                                  
  5846                                  ; 17/10/2022
  5847                                  ; 02/10/2022
  5848                                  
  5849                                  remap:		; proc near		
  5850 00001C6F 2E8B3E[1901]            		mov	di, [cs:start_bds] ; get first bds
  5851                                  
  5852                                  ; search for 1st fixed disk physical drive num
  5853                                  
  5854                                  drive_loop:				
  5855 00001C74 807D0480                		cmp	byte [di+4], 80h ; [di+BDS.drivenum]
  5856                                  					; first	hard disk??
  5857 00001C78 7409                    		jz	short fdrv_found ; yes,	continue
  5858 00001C7A 8B3D                    		mov	di, [di]	; [di+BDS.link]
  5859                                  					; get next bds,	assume segment
  5860 00001C7C 83FFFF                  		cmp	di, -1		; last bds?
  5861 00001C7F 75F3                    		jnz	short drive_loop ; loop	if not
  5862 00001C81 EB4F                    		jmp	short rmap_exit	; yes, no hard drive on	system
  5863                                  
  5864                                  ;------------------------------------------------------------------------------
  5865                                  ;first disk drive bds, now change the logical drive num to 2 and the subsequent
  5866                                  ;logical drive nums to 3, 4, 5 etc.
  5867                                  ;------------------------------------------------------------------------------
  5868                                  
  5869                                  fdrv_found:				
  5870 00001C83 B002                    		mov	al, 2		; start	with logical drv num=2
  5871                                  fdrv_loop:				
  5872 00001C85 884505                  		mov	[di+5],	al	; [di+BDS.drivelet]
  5873                                  					; found	??
  5874 00001C88 8B3D                    		mov	di, [di]	; [di+BDS.link]
  5875                                  					; ds:di--> next	bds
  5876                                  		;inc	al		; set num for next drive
  5877                                  		; 18/12/2022
  5878 00001C8A 40                      		inc	ax
  5879 00001C8B 83FFFF                  		cmp	di, 0FFFFh	; last hard drive ??
  5880 00001C8E 75F5                    		jnz	short fdrv_loop	; no - assign more disk	drives
  5881                                  
  5882                                  ;------------------------------------------------------------------------------
  5883                                  ; now, rescan and find bds of 3rd floppy drive and assign next drive letter
  5884                                  ; in al to 3rd. if the current drive letter is past z, then do not allocate
  5885                                  ; any more.
  5886                                  ;------------------------------------------------------------------------------
  5887                                  
  5888 00001C90 2E8B3E[1901]            		mov	di, [cs:start_bds] ; [start_bds]
  5889                                  					; get first bds
  5890 00001C95 8B3D                    		mov	di, [di]	; [di+BDS.link]
  5891                                  					; ds:di-->bds2
  5892 00001C97 2E8A26[2501]            		mov	ah, [cs:dsktnum] ; get number of floppies to remap
  5893 00001C9C 80EC02                  		sub	ah, 2		; adjust for a:	& b:
  5894                                  remap_loop1:				
  5895 00001C9F 8B3D                    		mov	di, [di]	; [di+BDS.link]
  5896                                  					; set new num to next floppy
  5897 00001CA1 884505                  		mov	[di+5],	al	; [di+BDS.drivelet]
  5898 00001CA4 FEC0                    		inc	al		; new number for next floppy
  5899 00001CA6 FECC                    		dec	ah		; count	down extra floppies
  5900 00001CA8 75F5                    		jnz	short remap_loop1
  5901                                  
  5902                                  ; now we've got to adjust the boot drive if we reassigned it
  5903                                  
  5904 00001CAA 2EA0[CA16]              		mov	al, [cs:drvfat]
  5905 00001CAE 3C02                    		cmp	al, 2		; is it	a: or b: ?
  5906 00001CB0 7220                    		jb	short rmap_exit
  5907 00001CB2 2E2A06[2501]            		sub	al, [cs:dsktnum] ; is it one of the other floppies?
  5908 00001CB7 7204                    		jb	short remap_boot_flop ;	brif so
  5909                                  
  5910                                  ; we've got to remap the boot hard drive
  5911                                  ; subtract the number of EXTRA floppies from it
  5912                                  
  5913 00001CB9 0402                    		add	al, 2		; bootdrv -= (dsktnum-2)
  5914 00001CBB EB05                    		jmp	short remap_change_boot_drv
  5915                                  ; ---------------------------------------------------------------------------
  5916                                  
  5917                                  ; we've got to remap the boot floppy.
  5918                                  ; add the number of hard drive partitions to it
  5919                                  
  5920                                  remap_boot_flop:			
  5921 00001CBD 2E0206[7500]            		add	al, [cs:drvmax]	; bootdrv += (drvmax-dsktnum)
  5922                                  remap_change_boot_drv:			
  5923 00001CC2 2EA2[CA16]              		mov	[cs:drvfat], al ; alter msdos.sys load drive
  5924 00001CC6 FEC0                    		inc	al
  5925 00001CC8 1E                      		push	ds
  5926 00001CC9 BF5704                  		mov	di, SYSINITSEG	; 46Dh
  5927                                  		;mov	di, 46Dh	; SYSINIT segment
  5928 00001CCC 8EDF                    		mov	ds, di
  5929 00001CCE A2[9602]                		mov	[DEFAULTDRIVE], al
  5930                                  		;mov	ds:296h, al	; [SYSINIT+DEFAULT_DRIVE]
  5931                                  					; pass it to sysinit as	well
  5932 00001CD1 1F                      		pop	ds
  5933                                  rmap_exit:				
  5934 00001CD2 C3                      		retn
  5935                                  
  5936                                  ; =============== S U B	R O U T	I N E =======================================
  5937                                  
  5938                                  ; 17/10/2022
  5939                                  ; 02/10/2022 - Retro DOS v4.0 (MSDOS 5.0 -actual-)
  5940                                  ; 28/12/2018 - Retro DOS v4.0 (MSDOS 6.21 -draft-)
  5941                                  ; 02/06/2018 - Retro DOS v3.0 (MSDOS 3.3)	
  5942                                  ; 19/03/2018 - Retro DOS v2.0 (MSDOS 2.11)
  5943                                  ;**************************************************
  5944                                  ; getboot - get the boot sector for a hard disk
  5945                                  ;
  5946                                  ; Reads the boot sector from a specified drive into
  5947                                  ; a buffer at the top of memory.
  5948                                  ;
  5949                                  ; dl = int13 drive number to read boot sector for
  5950                                  ;**************************************************
  5951                                  
  5952                                  ; 17/10/2022
  5953                                  bootbias equ 200h
  5954                                  
  5955                                  getboot:	; proc near		
  5956                                  		
  5957                                  		; 08/04/2018
  5958                                  		; Retro DOS v2.0 (IBMBIO.COM, IBMDOS 2.1)
  5959                                  		; 28/03/2018 - MSDOS 6.0 - MSINIT.ASM, 1991
  5960                                  		; 02/10/2022 - Retro DOS v4.0
  5961                                  		;	      (disassembled IO.SYS code of MSDOS 5.0)
  5962                                  
  5963 00001CD3 2EA1[D516]              		mov	ax, [cs:init_bootseg] ; 17/10/2022
  5964 00001CD7 8EC0                    		mov	es, ax
  5965                                  		; 17/10/2022
  5966 00001CD9 BB0002                  		mov	bx, bootbias ; 200h
  5967                                  		;mov	bx, 200h	; bootbias
  5968                                  					; load BX, ES:BX is where sector goes
  5969 00001CDC B80102                  		mov	ax, 201h
  5970 00001CDF 30F6                    		xor	dh, dh
  5971 00001CE1 B90100                  		mov	cx, 1
  5972 00001CE4 CD13                    		int	13h		; DISK - READ SECTORS INTO MEMORY
  5973                                  					; AL = number of sectors to read, CH = track, CL = sector
  5974                                  					; DH = head, DL	= drive, ES:BX -> buffer to fill
  5975                                  					; Return: CF set on error, AH =	status,	AL = number of sectors read
  5976 00001CE6 7209                    		jb	short erret
  5977                                  		; 17/10/2022
  5978 00001CE8 26813EFE0355AA          		cmp	word [es:bootbias+1FEh], 0AA55h
  5979                                  		;cmp	word ptr es:3FEh, 0AA55h ; [es:bootbias+1FEh]
  5980                                  					; Dave Litton magic word?
  5981 00001CEF 7401                    		jz	short norm_ret	; yes
  5982                                  erret:					
  5983 00001CF1 F9                      		stc
  5984                                  norm_ret:				
  5985 00001CF2 C3                      		retn
  5986                                  
  5987                                  ; =============== S U B	R O U T	I N E =======================================
  5988                                  
  5989                                  ; 28/12/2018 - Retro DOS v4.0 
  5990                                  
  5991                                  ;***************************************************************************
  5992                                  ;   sethard - generate bpb for a variable sized hard file. ibm has a
  5993                                  ;   partitioned hard file; we must read physical sector 0 to determine where
  5994                                  ;   our own logical sectors start. we also read in our boot sector to
  5995                                  ;   determine version number
  5996                                  ;
  5997                                  ;   inputs:	dl is rom drive number (80...)
  5998                                  ;		bh is partition number (0....) 
  5999                                  ;		ds:di points to bds
  6000                                  ;   outputs:	carry clear -> bpb is filled in
  6001                                  ;		carry set   -> bpb is left uninitialized due to error
  6002                                  ;	trashes (at least) si, cx
  6003                                  ;	MUST PRESERVE ES:!!!!
  6004                                  ;***************************************************************************
  6005                                  
  6006                                  sethard:	; proc near		
  6007 00001CF3 57                      		push	di
  6008 00001CF4 53                      		push	bx
  6009 00001CF5 1E                      		push	ds
  6010 00001CF6 06                      		push	es
  6011 00001CF7 885D05                  		mov	[di+5],	bl	; [di+BDS.drivelet]
  6012 00001CFA 885504                  		mov	[di+4],	dl	; [di+BDS.drivenum]
  6013 00001CFD 804D2301                		or	byte [di+23h], 1 ; [di+BDS.flags]
  6014                                  					; fnon_removable
  6015 00001D01 C6452205                		mov	byte [di+22h], 5 ; [di+BDS.formfactor]
  6016                                  					; ffHardFile
  6017 00001D05 C606[D216]00            		mov	byte [fbigfat], 0 ; assume 12 bit FAT
  6018 00001D0A 88FE                    		mov	dh, bh		; partition number
  6019 00001D0C 52                      		push	dx
  6020 00001D0D B408                    		mov	ah, 8
  6021 00001D0F CD13                    		int	13h		; DISK - DISK -	GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)
  6022                                  					; DL = drive number
  6023                                  					; Return: CF set on error, AH =	status code, BL	= drive	type
  6024                                  					; DL = number of consecutive drives
  6025                                  					; DH = maximum value for head number, ES:DI -> drive parameter
  6026 00001D11 FEC6                    		inc	dh
  6027 00001D13 887515                  		mov	[di+15h], dh	; [di+BDS.heads] ; get number of heads
  6028 00001D16 5A                      		pop	dx
  6029 00001D17 7263                    		jb	short setret	; error	if no hard disk
  6030 00001D19 80E13F                  		and	cl, 3Fh
  6031 00001D1C 884D13                  		mov	[di+13h], cl	; [di+BDS.secpertrack]
  6032 00001D1F 52                      		push	dx		; save partition number
  6033 00001D20 E8B0FF                  		call	getboot
  6034 00001D23 5A                      		pop	dx		; restore partition number
  6035 00001D24 7256                    		jb	short setret
  6036 00001D26 BBC203                  		mov	bx, 3C2h	; 1C2h+bootbias
  6037                                  
  6038                                  ; The first 'active' partition is 00, the second is 01....
  6039                                  ;   then the remainder of the 'primary' but non-active partitions
  6040                                  
  6041                                  act_part:				
  6042 00001D29 26F647FC80              		test	byte [es:bx-4], 80h ; is the partition active?
  6043 00001D2E 7418                    		jz	short no_act	; no
  6044 00001D30 26803F01                		cmp	byte [es:bx], 1 ; reject if partitiontype != 1, 4 or 6
  6045 00001D34 740C                    		jz	short got_good_act
  6046 00001D36 26803F04                		cmp	byte [es:bx], 4
  6047 00001D3A 7406                    		jz	short got_good_act
  6048 00001D3C 26803F06                		cmp	byte [es:bx], 6
  6049 00001D40 7506                    		jnz	short no_act
  6050                                  got_good_act:				
  6051 00001D42 08F6                    		or	dh, dh		; is this our target partition #?
  6052 00001D44 743A                    		jz	short set2	; WE GOT THE ONE WANTED!!
  6053 00001D46 FECE                    		dec	dh		; count	down
  6054                                  no_act:					
  6055 00001D48 83C310                  		add	bx, 16
  6056 00001D4B 81FB0204                		cmp	bx, 402h	; 202h+bootbias
  6057                                  					; last entry done?
  6058 00001D4F 75D8                    		jnz	short act_part	; no, process next entry
  6059 00001D51 BBC203                  		mov	bx, 3C2h	; 1C2h+bootbias
  6060                                  					; restore original value of bx
  6061                                  
  6062                                  ; Now scan the non-active partitions
  6063                                  
  6064                                  get_primary:				
  6065 00001D54 26F647FC80              		test	byte [es:bx-4], 80h
  6066 00001D59 7518                    		jnz	short not_prim	; we've already scanned
  6067                                  					; the ACTIVE ones
  6068 00001D5B 26803F01                		cmp	byte [es:bx], 1 ; see if partitiontype == 1, 4 or 6
  6069 00001D5F 740C                    		jz	short got_prim
  6070 00001D61 26803F04                		cmp	byte [es:bx], 4
  6071 00001D65 7406                    		jz	short got_prim
  6072 00001D67 26803F06                		cmp	byte [es:bx], 6
  6073 00001D6B 7506                    		jnz	short not_prim
  6074                                  got_prim:				
  6075 00001D6D 08F6                    		or	dh, dh		; is this our target partition?
  6076 00001D6F 740F                    		jz	short set2
  6077 00001D71 FECE                    		dec	dh
  6078                                  not_prim:				
  6079 00001D73 83C310                  		add	bx, 16
  6080 00001D76 81FB0204                		cmp	bx, 402h	; 202h+bootbias
  6081 00001D7A 75D8                    		jnz	short get_primary ; loop till we've gone through table
  6082                                  setret:					
  6083 00001D7C F9                      		stc			; error	return
  6084 00001D7D E9DC02                  		jmp	ret_hard_err
  6085                                  
  6086                                  ; ---------------------------------------------------------------------------
  6087                                  
  6088                                  ;  until we get the real logical boot record and get the bpb,
  6089                                  ;  BDS_BPB.BPB_BIGTOTALSECTORS will be used instead of BDS_BPB.BPB_TOTALSECTORS
  6090                                  ;  for the convenience of the computation.
  6091                                  ;
  6092                                  ;  at the end of this procedure, if a bpb information is gotten from
  6093                                  ;  the valid boot record, then we are going to use those bpb information
  6094                                  ;  without change.
  6095                                  ;
  6096                                  ;  otherwise, if (hidden sectors + total sectors) <= a word, then we will move
  6097                                  ;  BDS_BPB.BPB_BIGTOTALSECTORS (low) to BDS_BPB.BPB_TOTALSECTORS and zero out
  6098                                  ;  BDS_BPB.BPB_BIGTOTALSECTORS entry to make it a conventional bpb format.
  6099                                  
  6100                                  set2:					
  6101 00001D80 2E8816[D716]            		mov	[cs:rom_drv_num], dl
  6102                                  			; save the rom bios drive number we are handling now.
  6103 00001D85 268B4704                		mov	ax, [es:bx+4]	; hidden sectors (start	sector)
  6104 00001D89 268B5706                		mov	dx, [es:bx+6]
  6105                                  
  6106                                  ; decrement the sector count by 1 to make it zero based. exactly 64k
  6107                                  ; sectors should be allowed	
  6108                                  
  6109 00001D8D 83E801                  		sub	ax, 1
  6110 00001D90 83DA00                  		sbb	dx, 0
  6111 00001D93 26034708                		add	ax, [es:bx+8]	; sectors in partition
  6112 00001D97 2613570A                		adc	dx, [es:bx+10]
  6113 00001D9B 7305                    		jnb	short okdrive
  6114 00001D9D 800E[D216]80            		or	byte [fbigfat], 80h ; ftoobig
  6115                                  okdrive:				
  6116 00001DA2 268B4704                		mov	ax, [es:bx+4]
  6117 00001DA6 894517                  		mov	[di+17h], ax	; [di+BDS.hiddensecs]
  6118                                  					; BPB_HIDDENSECTORS = p->partitionbegin
  6119 00001DA9 268B4706                		mov	ax, [es:bx+6]
  6120 00001DAD 894519                  		mov	[di+19h], ax	; [di+BDS.hiddensecs+2]
  6121 00001DB0 268B570A                		mov	dx, [es:bx+10]	; # of sectors (high)
  6122 00001DB4 268B4708                		mov	ax, [es:bx+8]	; # of sectors (low)
  6123 00001DB8 89551D                  		mov	[di+1Dh], dx	; [di+BDS.totalsecs32+2]
  6124 00001DBB 89451B                  		mov	[di+1Bh], ax	; [di+BDS.totalsecs32]
  6125                                  					; bpb->maxsec =	p->partitionlength
  6126 00001DBE 83FA00                  		cmp	dx, 0
  6127 00001DC1 7705                    		ja	short okdrive_1
  6128 00001DC3 83F840                  		cmp	ax, 64		; if (p->partitionlength < 64)
  6129 00001DC6 72B4                    		jb	short setret	; return -1;
  6130                                  okdrive_1:				
  6131 00001DC8 8B5519                  		mov	dx, [di+19h]	; [di+BDS.hiddensecs+2]
  6132 00001DCB 8B4517                  		mov	ax, [di+17h]	; [di+BDS.hiddensecs]
  6133 00001DCE 31DB                    		xor	bx, bx		; boot sector number - for mini	disk
  6134                                  					; usually equal	to the # of sec/trk.
  6135 00001DD0 8A5D13                  		mov	bl, [di+13h]	; [di+BDS.secpertrack]
  6136 00001DD3 50                      		push	ax
  6137 00001DD4 89D0                    		mov	ax, dx
  6138 00001DD6 31D2                    		xor	dx, dx
  6139 00001DD8 F7F3                    		div	bx		; (sectors)dx:ax / (BDS.secpertrack)bx =
  6140                                  					; (track)temp_h:ax + (sector)dx
  6141                                  		; 17/10/2022
  6142 00001DDA 2EA3[2905]              		mov	[cs:temp_h], ax
  6143 00001DDE 58                      		pop	ax
  6144 00001DDF F7F3                    		div	bx
  6145 00001DE1 88D1                    		mov	cl, dl
  6146 00001DE3 FEC1                    		inc	cl
  6147 00001DE5 31DB                    		xor	bx, bx
  6148 00001DE7 8A5D15                  		mov	bl, [di+15h]	; [di+BDS.heads]
  6149 00001DEA 50                      		push	ax
  6150 00001DEB 31D2                    		xor	dx, dx
  6151 00001DED 2EA1[2905]              		mov	ax, [cs:temp_h]
  6152 00001DF1 F7F3                    		div	bx
  6153 00001DF3 2EA3[2905]              		mov	[cs:temp_h], ax
  6154 00001DF7 58                      		pop	ax
  6155 00001DF8 F7F3                    		div	bx		;  dl is head, ax is cylinder
  6156 00001DFA 2E833E[2905]00          		cmp	word [cs:temp_h], 0
  6157 00001E00 777C                    		ja	short setret_brdg ; exceeds the	limit of int 13h
  6158 00001E02 3D0004                  		cmp	ax, 1024
  6159 00001E05 7777                    		ja	short setret_brdg ; exceeds the	limit of int 13h
  6160                                  			; Retro DOS v3.2 note by Erdogan Tan - 28/07/2019
  6161                                  			; **MSDOS code accepts if ax = 1024 but it is nonsense here
  6162                                  			; ('ja' must be 'jnb')
  6163                                  okdrive_2:
  6164                                   		; 28/07/2019
  6165                                  ; dl is head.
  6166                                  ; ax is cylinder
  6167                                  ; cl is sector number (assume less than 2**6 = 64 for int 13h)
  6168                                  
  6169                                  ;*** for mini disks ***
  6170                                  
  6171 00001E07 837D4701                		cmp	word [di+47h], 1 ; [di+BDS.bdsm_ismini]
  6172                                  					; check	for mini disk
  6173 00001E0B 7503                    		jnz	short oknotmini	; not mini disk.
  6174 00001E0D 034549                  		add	ax, [di+49h]	; [di+BDS.bdsm_hidden_trks]
  6175                                  					; set the physical track number
  6176                                  oknotmini:
  6177                                  ;*** end of added logic for mini disk
  6178                                  				
  6179 00001E10 D0CC                    		ror	ah, 1		; move high two	bits of	cyl to high
  6180 00001E12 D0CC                    		ror	ah, 1		; two bits of upper byte
  6181 00001E14 80E4C0                  		and	ah, 0C0h	; turn off remainder of	bits
  6182 00001E17 08E1                    		or	cl, ah		; move two bits	to correct spot
  6183 00001E19 88C5                    		mov	ch, al		; ch is	cylinder (low 8	bits)
  6184                                  					; cl is	sector + 2 high	bits of	cylinder
  6185 00001E1B 88D6                    		mov	dh, dl		; dh is	head
  6186 00001E1D 2E8A16[D716]            		mov	dl, [cs:rom_drv_num] ; dl is drive number
  6187                                  
  6188                                  ; cl is sector + 2 high bits of cylinder
  6189                                  ; ch is low 8 bits of cylinder
  6190                                  ; dh is head
  6191                                  ; dl is drive
  6192                                  
  6193                                  ; for convenience, we are going to read the logical boot sector
  6194                                  ; into cs:disksector area.
  6195                                  
  6196                                  ; read in boot sector using bios disk interrupt. the buffer where it
  6197                                  ; is to be read in is cs:disksector.
  6198                                  
  6199 00001E22 0E                      		push	cs
  6200 00001E23 07                      		pop	es
  6201 00001E24 BB[4E01]                		mov	bx, disksector	; for convenience,
  6202                                  					; we are going to read the logical boot	sector
  6203                                  					; into cs:disksector area.
  6204 00001E27 B80102                  		mov	ax, 201h
  6205 00001E2A CD13                    		int	13h		; DISK - READ SECTORS INTO MEMORY
  6206                                  					; AL = number of sectors to read, CH = track, CL = sector
  6207                                  					; DH = head, DL	= drive, ES:BX -> buffer to fill
  6208                                  					; Return: CF set on error, AH =	status,	AL = number of sectors read
  6209                                  
  6210                                  ; cs:disksec contains the boot sector. in theory, (ha ha) the bpb in this thing
  6211                                  ; is correct. we can, therefore, suck out all the relevant statistics on the
  6212                                  ; media if we recognize the version number.
  6213                                  
  6214 00001E2C BB[4E01]                		mov	bx, disksector
  6215 00001E2F 53                      		push	bx
  6216 00001E30 50                      		push	ax
  6217 00001E31 2E803FE9                		cmp	byte [cs:bx], 0E9h ; is it a near jump?
  6218 00001E35 740D                    		jz	short check_1_ok ; yes
  6219 00001E37 2E803FEB                		cmp	byte [cs:bx], 0EBh ; is it a short jump?
  6220 00001E3B 7529                    		jnz	short invalid_boot_record ; no
  6221 00001E3D 2E807F0290              		cmp	byte [cs:bx+2], 90h ; yes, is the next one a nop?
  6222 00001E42 7522                    		jnz	short invalid_boot_record
  6223                                  check_1_ok:
  6224                                  		; 14/08/2023			
  6225 00001E44 BB[5901]                		mov	bx, disksector+11 ; disksector+EXT_BOOT.BPB				
  6226                                  		;mov	bx, 159h	; disksector+EXT_BOOT.BPB
  6227                                  					; point	to the bpb in the boot record
  6228 00001E47 2E8A470A                		mov	al, [cs:bx+10]	; [bx+EBPB.MEDIADESCRIPTOR]
  6229                                  					; get the mediadescriptor byte
  6230 00001E4B 24F0                    		and	al, 0F0h	; mask off low nibble
  6231 00001E4D 3CF0                    		cmp	al, 0F0h	; is high nibble = 0Fh?
  6232 00001E4F 7515                    		jnz	short invalid_boot_record ; no,	invalid	boot record
  6233 00001E51 2E813F0002              		cmp	word [cs:bx], 512 ; [bx+EBPB.BYTESPERSECTOR]
  6234 00001E56 750E                    		jnz	short invalid_boot_record ; invalidate non 512 byte sectors
  6235                                  
  6236                                  check2_ok:				; yes, mediadescriptor ok.
  6237 00001E58 2E8A4702                		mov	al, [cs:bx+2]	; now make sure	that
  6238                                  					; the sectorspercluster	is
  6239                                  					; a power of 2
  6240                                  					;
  6241                                  					; [bx+EBPB.SECTORSPERCLUSTER]
  6242                                  					; get the sectorspercluster
  6243 00001E5C 08C0                    		or	al, al		; is it	zero?
  6244 00001E5E 7406                    		jz	short invalid_boot_record ; yes, invalid boot record
  6245                                  
  6246                                  ck_power_of_two:			
  6247 00001E60 D0E8                    		shr	al, 1		; shift	until first bit	emerges
  6248 00001E62 73FC                    		jnb	short ck_power_of_two
  6249 00001E64 7405                    		jz	short valid_boot_record
  6250                                  
  6251                                  invalid_boot_record:			
  6252 00001E66 58                      		pop	ax
  6253 00001E67 5B                      		pop	bx
  6254 00001E68 E93301                  		jmp	unknown		; jump to invalid boot record
  6255                                  					; unformatted or illegal media.
  6256                                  ; ---------------------------------------------------------------------------
  6257                                  
  6258                                  valid_boot_record:			
  6259 00001E6B 58                      		pop	ax
  6260 00001E6C 5B                      		pop	bx
  6261                                  
  6262                                  ; Signature found. Now check version.
  6263                                  
  6264 00001E6D 2E817F08322E            		cmp	word [cs:bx+8], '2.' ; 03/10/2022 (NASM syntax)
  6265                                  		;cmp	word ptr cs:[bx+8], 2E32h ; '2.'
  6266 00001E73 750F                    		jnz	short try5
  6267 00001E75 2E807F0A30              		cmp	byte [cs:bx+0Ah], '0' ; 03/10/2022 (NASM syntax)
  6268                                  		;cmp	byte ptr cs:[bx+0Ah], 30h ; '0'
  6269 00001E7A 7508                    		jnz	short try5
  6270 00001E7C EB2F                    		jmp	short copybpb
  6271                                  ; ---------------------------------------------------------------------------
  6272                                  
  6273                                  setret_brdg:				
  6274 00001E7E E9FBFE                  		jmp	setret
  6275                                  ; ---------------------------------------------------------------------------
  6276                                  
  6277                                  unknown3_0_j:				
  6278 00001E81 E91E01                  		jmp	unknown3_0	; legally formatted media,
  6279                                  					; although, content might be bad.
  6280                                  ; ---------------------------------------------------------------------------
  6281                                  
  6282                                  try5:					
  6283 00001E84 E8DA01                  		call	cover_fdisk_bug
  6284                                  
  6285                                  ; see if it is an os2 signature
  6286                                  
  6287 00001E87 2E817F08302E            		cmp	word [cs:bx+8], '0.' ; 03/10/2022 (NASM syntax)
  6288                                  		;cmp	word ptr cs:[bx+8], 2E30h ; '0.'
  6289 00001E8D 750D                    		jnz	short no_os2
  6290 00001E8F 2E8A4707                		mov	al, [cs:bx+7]	; 17/10/2022 (NASM syntax)
  6291 00001E93 2C31                    		sub	al, '1'
  6292                                  		;sub	al, 31h		; '1'
  6293 00001E95 24FE                    		and	al, 0FEh
  6294 00001E97 7414                    		jz	short copybpb	; accept either	'1' or '2'
  6295 00001E99 E90201                  		jmp	unknown
  6296                                  ; ---------------------------------------------------------------------------
  6297                                  
  6298                                  ; no os2 signature, this is to check for real dos versions
  6299                                  
  6300                                  no_os2:					
  6301 00001E9C 2E817F08332E            		cmp	word [cs:bx+8], '3.' ; 03/10/2022 (NASM syntax)
  6302                                  		;cmp	word ptr cs:[bx+8], 2E33h ; '3.'
  6303 00001EA2 72DD                    		jb	short unknown3_0_j ; must be 2.1 boot record.
  6304                                  					; do not trust it, but still legal.
  6305 00001EA4 7507                    		jnz	short copybpb	; honor	os2 boot record
  6306                                  					; or dos 4.0 version
  6307 00001EA6 2E807F0A31              		cmp	byte [cs:bx+10], '1'
  6308                                  		;cmp	byte ptr cs:[bx+0Ah], 31h ; '1'
  6309 00001EAB 72D4                    		jb	short unknown3_0_j ; if version >=	3.1, then o.k.
  6310                                  copybpb:
  6311                                  
  6312                                  ; 03/10/2022
  6313                                  
  6314                                  ; we have a valid boot sector. use the bpb in it to build the
  6315                                  ; bpb in bios. it is assumed that only
  6316                                  ;	BDS_BPB.BPB_SECTORSPERCLUSTER
  6317                                  ;	BDS_BPB.BPB_ROOTENTRIES, and
  6318                                  ;	BDS_BPB.BPB_SECTORSPERFAT
  6319                                  ; need to be set (all other values in already). fbigfat is also set.
  6320                                  
  6321                                  ; if it is non fat based system, then just copy the bpb from the boot sector
  6322                                  ; into the bpb in bds table, and also set the boot serial number, volume id,
  6323                                  ; and system id according to the boot record.
  6324                                  ; for the non_fat system, don't need to set the other value. so just do goodret.
  6325                                  
  6326                                  		; 10/12/2022
  6327                                  		; (number of FATs optimization)
  6328 00001EAD BE[5901]                		mov	si, disksector+11 ; disksector+0Bh
  6329                                  		;mov	cl, [cs:disksector+10h] ; Number of FATs (may be 2 or 1)
  6330 00001EB0 2E8A4C05                		mov	cl, [cs:si+05h]
  6331                                  		
  6332 00001EB4 2E807C1B29              		cmp	byte [cs:si+1Bh], 29h ; 10/12/2022	
  6333                                  		;cmp	byte [cs:disksector+26h], 29h ; 17/10/2022
  6334                                  					; [disksector+EXT_BOOT.SIG]
  6335                                  					; EXT_BOOT_SIGNATURE
  6336 00001EB9 754E                    		jnz	short copybpb_fat ; conventional fat system
  6337                                  
  6338                                  		; 03/10/2022
  6339                                  		; 29/12/2018 - Retro DOS v4.0 modification note:
  6340                                  		; Regarding 'fat_big_small' part of this (MSDOS 6.0) code
  6341                                  		;	     number of FATs must be 2 ; =*?=
  6342                                  		; (Otherwise, '# of data sectors' would be calculated as wrong!!!)
  6343                                  		;
  6344                                  		;cmp	byte [disksector+EXT_BOOT.BPB+EBPB.NUMBEROFFATS], 2 ; =*?=
  6345                                  
  6346                                  		; 10/12/2022
  6347                                  		;cmp	byte [cs:disksector+10h], 0
  6348                                  					; [disksector+EXT_BOOT.BPB+EBPB.NUMBEROFFATS]
  6349                                  		;jnz	short copybpb_fat ; a fat system.
  6350 00001EBB 08C9                    		or	cl, cl	 ; [cs:disksector+10h]
  6351 00001EBD 754A                    		jnz	short copybpb_fat ; a fat system.
  6352                                  
  6353                                  ; non fat based	media.
  6354                                  
  6355 00001EBF 57                      		push	di
  6356 00001EC0 1E                      		push	ds
  6357 00001EC1 1E                      		push	ds
  6358 00001EC2 07                      		pop	es
  6359 00001EC3 0E                      		push	cs
  6360 00001EC4 1F                      		pop	ds
  6361                                  
  6362                                  		; 10/12/2022
  6363                                  		; (number of FATs optimization)
  6364                                  		; SI = disksector+11
  6365                                  		; 17/10/2022
  6366                                  		;;mov	si, 159h	; disksector+EXT_BOOT.BPB
  6367                                  		;mov	si, disksector+11
  6368 00001EC5 83C706                  		add	di, 6		; add di,BDS.BPB
  6369                                  
  6370                                  ; just for completeness, we'll make sure that total_sectors and
  6371                                  ; big_total_sectors aren't both zero. I've seen examples of
  6372                                  ; this on DOS 3.30 boot records. I don't know exactly how it
  6373                                  ; got that way. If it occurs, then use the values from the
  6374                                  ; partition table.
  6375                                  
  6376                                  		; 18/12/2022
  6377 00001EC8 29C9                    		sub	cx, cx 
  6378                                  
  6379                                  		;cmp	word [cs:si+8], 0 	; [cs:si+EBPB.TOTALSECTORS]
  6380                                  		;jnz	short already_nonz 
  6381                                  		;			; how about big_total?
  6382                                  		;cmp	word [cs:si+15h], 0	; [cs:si+EBPB.BIGTOTALSECTORS]
  6383                                  		;jnz	short already_nonz ; we're okay if any are != 0
  6384                                  		;cmp	word [cs:si+17h], 0	; [cs:si+EBPB.BIGTOTALSECTORS+2]
  6385                                  		;jnz	short already_nonz
  6386                                  
  6387                                  		; 18/12/2022
  6388 00001ECA 2E394C08                		cmp	[cs:si+8], cx ; 0	; [cs:si+EBPB.TOTALSECTORS]
  6389 00001ECE 7521                    		jnz	short already_nonz
  6390                                  					     ; how about big_total?
  6391 00001ED0 2E394C15                		cmp	word [cs:si+15h], cx ; 0 ; [cs:si+EBPB.BIGTOTALSECTORS]
  6392 00001ED4 751B                    		jnz	short already_nonz   ; we're okay if any are != 0
  6393 00001ED6 2E394C17                		cmp	word [cs:si+17h], cx ; 0 ; [cs:si+EBPB.BIGTOTALSECTORS+2]
  6394 00001EDA 7515                    		jnz	short already_nonz
  6395                                  
  6396                                  ; now let's copy the values from the partition table (now in the BDS)
  6397                                  ; into the BPB in the boot sector buffer, before they get copied back.
  6398                                  
  6399 00001EDC 8B4508                  		mov	ax, [di+8]	; [di+BDS.totalsecs16]
  6400 00001EDF 2E894408                		mov	[cs:si+8], ax	; [cs:si+EBPB.TOTALSECTORS]
  6401 00001EE3 8B4515                  		mov	ax, [di+15h]	; [di+BDS.totalsecs32]
  6402 00001EE6 2E894415                		mov	[cs:si+15h], ax	; [cs:si+EBPB.BIGTOTALSECTORS]
  6403 00001EEA 8B4517                  		mov	ax, [di+17h]	; [di+BDS.totalsecs32+2]
  6404 00001EED 2E894417                		mov	[cs:si+17h], ax	; [cs:si+EBPB.BIGTOTALSECTORS+2]
  6405                                  
  6406                                  already_nonz:	
  6407                                  		; 18/12/2022
  6408                                  		; cx = 0
  6409 00001EF1 B119                    		mov	cl, 25		
  6410                                  		;mov	cx, 25		; A_BPB.size - 6 ; Use SMALL version!
  6411 00001EF3 F3A4                    		rep movsb
  6412 00001EF5 1F                      		pop	ds
  6413 00001EF6 5F                      		pop	di
  6414 00001EF7 06                      		push	es
  6415 00001EF8 1E                      		push	ds
  6416 00001EF9 07                      		pop	es
  6417 00001EFA 0E                      		push	cs
  6418 00001EFB 1F                      		pop	ds
  6419                                  		; 13/08/2023
  6420 00001EFC BD[3807]                		mov	bp, MOVMEDIAIDS ; mov_media_ids
  6421                                  		; 18/12/2022
  6422                                  		;mov	bp, mov_media_ids
  6423                                  		;;mov	bp, 751h	; mov_media_ids
  6424                                  					; at 2C7h:751h = 70h:2CC1h
  6425                                  					; set volume id, systemid, serial.
  6426 00001EFF 0E                      		push	cs		; simulate far call
  6427 00001F00 E862F8                  		call	call_bios_code
  6428 00001F03 06                      		push	es
  6429 00001F04 1F                      		pop	ds
  6430 00001F05 07                      		pop	es
  6431 00001F06 E94B01                  		jmp	goodret
  6432                                  ; ---------------------------------------------------------------------------
  6433                                  
  6434                                  ; ****** cas ---
  6435                                  ; IBM DOS 3.30 doesn't seem to mind that the TOTAL_SECTORS and
  6436                                  ; BIG_TOTAL_SECTORS field in the boot sector are 0000. This
  6437                                  ; happens with some frequency -- perhaps through some OS/2 setup
  6438                                  ; program. We haven't actually been COPYING the TOTAL_SECTORS
  6439                                  ; from the boot sector into the DPB anyway, we've just been using
  6440                                  ; it for calculating the fat size. Pretty scary, huh? For now,
  6441                                  ; we'll go ahead and copy it into the DPB, except in the case
  6442                                  ; that it equals zero, in which case we just use the values in
  6443                                  ; the DPB from the partition table.
  6444                                  
  6445                                  ; 17/10/2022
  6446                                  ;MOVMEDIAIDS equ mov_media_ids - DOSBIOSEG_2C7h ; (751h for MSDOS 5.0 IO.SYS)
  6447                                  ;CLEARIDS equ clear_ids - DOSBIOSEG_2C7h ; (5D9h for MSDOS 5.0 IO.SYS)		    		
  6448                                  ; 09/12/2022
  6449                                  MOVMEDIAIDS equ mov_media_ids
  6450                                  CLEARIDS equ clear_ids
  6451                                  ; 11/09/2023
  6452                                  CLEARIDS_X equ clear_ids_x
  6453                                  
  6454                                  copybpb_fat:
  6455                                  		; 10/12/2022
  6456                                  		; (number of FATs optimization)
  6457                                  		; SI = disksector+11				
  6458                                  		; 17/10/2022
  6459                                  		;mov	si, disksector+11
  6460                                  		;;mov	si, 159h	; disksector+EXT_BOOT.BPB
  6461                                  					; cs:si	-> bpb in boot
  6462 00001F09 31D2                    		xor	dx, dx
  6463 00001F0B 2E8B4408                		mov	ax, [cs:si+8]	; [cs:si+EBPB.TOTALSECTORS]
  6464                                  					; get totsec from boot sec
  6465 00001F0F 09C0                    		or	ax, ax
  6466 00001F11 7516                    		jnz	short copy_totsec ; if non zero, use that
  6467 00001F13 2E8B4415                		mov	ax, [cs:si+15h]	; [cs:si+EBPB.BIGTOTALSECTORS]
  6468                                  					; get the big version
  6469                                  					; (32 bit total	sectors)
  6470 00001F17 2E8B5417                		mov	dx, [cs:si+17h]	; [cs:si+EBPB.BIGTOTALSECTORS+2]
  6471                                  		; 10/12/2022
  6472                                  		; (number of FATs optimization)
  6473                                  		; CL = number of FATs (2 or 1) 
  6474 00001F1B 89D3                    		mov	bx, dx		; see if it is a big zero
  6475 00001F1D 09C3                    		or	bx, ax
  6476 00001F1F 7508                    		jnz	short copy_totsec
  6477                                  			; screw it. it	was bogus.
  6478 00001F21 8B451B                  		mov	ax, [di+1Bh]	; [di+BDS.totalsecs32]
  6479 00001F24 8B551D                  		mov	dx, [di+1Dh]	; [di+BDS.totalsecs32+2]
  6480 00001F27 EB06                    		jmp	short fat_big_small
  6481                                  
  6482                                  		;mov	cx, dx
  6483                                  		;or	cx, ax		; see if it is a big zero
  6484                                  		;jz	short totsec_already_set ; screw it. it	was bogus.
  6485                                  copy_totsec:				
  6486 00001F29 89451B                  		mov	[di+1Bh], ax	; [di+BDS.totalsecs32]
  6487                                  					; make DPB match boot sec
  6488 00001F2C 89551D                  		mov	[di+1Dh], dx	; [di+BDS.totalsecs32+2]
  6489                                  
  6490                                  		; 10/12/2022
  6491                                  ;totsec_already_set:			
  6492                                  		;mov	ax, [di+1Bh]	; [di+BDS.totalsecs32]
  6493                                  		;mov	dx, [di+1Dh]	; [di+BDS.totalsecs32+2]
  6494                                  
  6495                                  ; determine fat entry size.
  6496                                  
  6497                                  fat_big_small:
  6498                                  
  6499                                  ;at this moment dx;ax = total sector number
  6500                                  
  6501                                  ;Do not assume 1 reserved sector. Update the reserved sector field in BDS 
  6502                                  ;from the BPB on the disk
  6503                                  				
  6504 00001F2F 2E8B5C03                		mov	bx, [cs:si+3]	; [cs:si+EBPB.RESERVEDSECTORS]
  6505                                  					; get #reserved_sectors	from BPB
  6506 00001F33 895D09                  		mov	[di+9],	bx	; [di+BDS.resectors]
  6507                                  					; update BDS field
  6508 00001F36 29D8                    		sub	ax, bx
  6509 00001F38 83DA00                  		sbb	dx, 0		; update the count
  6510 00001F3B 2E8B5C0B                		mov	bx, [cs:si+0Bh]	; [cs:si+EBPB.SECTORSPERFAT]
  6511                                  					; bx = sectors/fat
  6512 00001F3F 895D11                  		mov	[di+11h], bx	; [di+BDS.fatsecs]
  6513                                  					; set in bds bpb
  6514                                  		; 10/12/2022
  6515                                  		; (number of FATs optimization)
  6516                                  		; CL = number of FATs (2 or 1) 
  6517                                  		;dec	cl ; *
  6518                                  		; 18/12/2022
  6519 00001F42 49                      		dec	cx ; *
  6520 00001F43 D3E3                    		shl	bx, cl			
  6521                                  		;shl	bx, 1	; =*?=	; always 2 fats
  6522                                  		
  6523 00001F45 29D8                    		sub	ax, bx		; sub #	fat sectors
  6524 00001F47 83DA00                  		sbb	dx, 0
  6525 00001F4A 2E8B5C06                		mov	bx, [cs:si+6]	; [cs:si+EBPB.ROOTENTRIES]
  6526                                  					; # root entries
  6527 00001F4E 895D0C                  		mov	[di+0Ch], bx	; [di+BDS.direntries]
  6528                                  					; set in bds bpb
  6529 00001F51 B104                    		mov	cl, 4
  6530 00001F53 D3EB                    		shr	bx, cl		; div by 16 ents/sector
  6531 00001F55 29D8                    		sub	ax, bx		; sub #	dir sectors
  6532 00001F57 83DA00                  		sbb	dx, 0		;
  6533                                  					; dx:ax	now contains the
  6534                                  					; # of data sectors
  6535 00001F5A 31C9                    		xor	cx, cx ; *
  6536 00001F5C 2E8A4C02                		mov	cl, [cs:si+2]	; [cs:si+EBPB.SECTORSPERCLUSTER]
  6537                                  					; sectors per cluster
  6538 00001F60 884D08                  		mov	[di+8],	cl	; [di+BDS.secperclus]
  6539                                  					; set in bios bpb
  6540 00001F63 50                      		push	ax
  6541 00001F64 89D0                    		mov	ax, dx
  6542 00001F66 31D2                    		xor	dx, dx
  6543 00001F68 F7F1                    		div	cx		; cx = sectors per cluster
  6544 00001F6A 2EA3[2905]              		mov	[cs:temp_h], ax	; [temp_h]:ax now contains the
  6545                                  					; # clusters.
  6546 00001F6E 58                      		pop	ax
  6547 00001F6F F7F1                    		div	cx
  6548 00001F71 2E833E[2905]00          		cmp	word [cs:temp_h], 0
  6549 00001F77 771C                    		ja	short toobig_ret ; too big cluster number
  6550 00001F79 3DF60F                  		cmp	ax, 0FF6h	; 4096-10
  6551                                  					; is this 16-bit fat?
  6552 00001F7C 7205                    		jb	short copymediaid ; no,	small fat
  6553                                  		; 17/10/2022
  6554 00001F7E 800E[D216]40            		or	byte [fbigfat], 40h
  6555                                  		;or	ds:fbigfat, 40h	; fbig
  6556                                  					; 16 bit fat
  6557                                  copymediaid:				
  6558 00001F83 06                      		push	es
  6559 00001F84 1E                      		push	ds
  6560 00001F85 07                      		pop	es
  6561 00001F86 0E                      		push	cs
  6562 00001F87 1F                      		pop	ds
  6563                                  		; 17/10/2022
  6564 00001F88 BD[3807]                		mov	bp, MOVMEDIAIDS
  6565                                  		;mov	bp, 751h	; mov_media_ids
  6566                                  					; at 2C7h:751h = 70h:2CC1h
  6567                                  					; copy filesys_id, volume label
  6568 00001F8B 0E                      		push	cs		; simulate far call
  6569 00001F8C E8D6F7                  		call	call_bios_code
  6570 00001F8F 06                      		push	es
  6571 00001F90 1F                      		pop	ds
  6572 00001F91 07                      		pop	es
  6573 00001F92 E9A100                  		jmp	massage_bpb	; now final check for bpb info
  6574                                  					; and return.
  6575                                  ; ---------------------------------------------------------------------------
  6576                                  
  6577                                  toobig_ret:				
  6578 00001F95 2E800E[D216]80          		or	byte [cs:fbigfat], 80h
  6579 00001F9B E9B600                  		jmp	goodret		; still	drive letter is	assigned
  6580                                  					; but useless. to big for
  6581                                  					; current pc dos fat file system
  6582                                  ; ---------------------------------------------------------------------------
  6583                                  
  6584                                  unknown:	
  6585                                  		; 12/12/2022
  6586 00001F9E 804D2402                		or	byte [di+24h], 02h			
  6587                                  		;or	word [di+23h], 200h ; [di+BDS.flags]
  6588                                  					; unformatted_media
  6589                                  					; Set unformatted media	flag.
  6590                                  
  6591                                  ; the boot signature may not be	recognizable,
  6592                                  ; but we should	try and	read it	anyway.
  6593                                  
  6594                                  unknown3_0:				
  6595 00001FA2 8B551D                  		mov	dx, [di+1Dh]	; skip setting unformatted_media bit
  6596                                  					; [di+BDS.totalsecs32+2]
  6597 00001FA5 8B451B                  		mov	ax, [di+1Bh]	; [di+BDS.totalsecs32]
  6598 00001FA8 BE[0A17]                		mov	si, disktable2
  6599                                  
  6600                                  scan:					
  6601 00001FAB 2E3B14                  		cmp	dx, [cs:si]
  6602 00001FAE 720D                    		jb	short gotparm
  6603 00001FB0 7706                    		ja	short scan_next
  6604 00001FB2 2E3B4402                		cmp	ax, [cs:si+2]
  6605 00001FB6 7605                    		jbe	short gotparm
  6606                                  
  6607                                  scan_next:				
  6608 00001FB8 83C60A                  		add	si, 10		; 5*2
  6609 00001FBB EBEE                    		jmp	short scan	; covers upto 512 mb media
  6610                                  ; ---------------------------------------------------------------------------
  6611                                  
  6612                                  gotparm:				
  6613 00001FBD 8A4C08                  		mov	cl, [si+8]	; fat size for fbigfat flag
  6614                                  		;or	ds:fbigfat, cl
  6615                                  		; 17/10/2022
  6616 00001FC0 080E[D216]              		or	[fbigfat], cl
  6617 00001FC4 2E8B4C04                		mov	cx, [cs:si+4]	; ch = number of sectors per cluster
  6618                                  					; cl = log base	2 of ch
  6619 00001FC8 2E8B5406                		mov	dx, [cs:si+6]	; dx = number of root dir entries
  6620                                  
  6621                                  ; now calculate size of fat table
  6622                                  
  6623 00001FCC 89550C                  		mov	[di+0Ch], dx	; [di+BDS.direntries]
  6624                                  					; save number of (root)	dir entries
  6625 00001FCF 8B551D                  		mov	dx, [di+1Dh]	; [di+BDS.totalsecs32+2]
  6626 00001FD2 8B451B                  		mov	ax, [di+1Bh]	; [di+BDS.totalsecs32]
  6627 00001FD5 886D08                  		mov	[di+8],	ch	; [di+BDS.secperclus]
  6628                                  					; save sectors per cluster
  6629                                  		; 17/10/2022
  6630 00001FD8 F606[D216]40            		test	byte [fbigfat], 40h
  6631                                  		;test	ds:fbigfat, 40h	; fbig
  6632                                  					; if (fbigfat)
  6633 00001FDD 751E                    		jnz	short dobig	; goto dobig; (16 bit fat)
  6634                                  
  6635                                  ; we don't need to change "small fat" logic since it is gauranteed
  6636                                  ; that double word total sector will not use 12 bit fat (unless
  6637                                  ; it's sectors/cluster >= 16 which will never be in this case.)
  6638                                  ; so in this case we assume dx = 0 !!
  6639                                  
  6640 00001FDF 31DB                    		xor	bx, bx		; (12 bit fat)
  6641 00001FE1 88EB                    		mov	bl, ch
  6642 00001FE3 4B                      		dec	bx
  6643 00001FE4 01C3                    		add	bx, ax		; dx=0
  6644 00001FE6 D3EB                    		shr	bx, cl		; bx = 1+(bpb->maxsec+BDS.secperclus-1)/
  6645 00001FE8 43                      		inc	bx		; BDS.secperclus
  6646 00001FE9 80E3FE                  		and	bl, 0FEh	; bx &= ~1; (=number of clusters)
  6647 00001FEC 89DE                    		mov	si, bx
  6648 00001FEE D1EB                    		shr	bx, 1
  6649 00001FF0 01F3                    		add	bx, si
  6650 00001FF2 81C3FF01                		add	bx, 511		; bx +=	511 + bx/2
  6651 00001FF6 D0EF                    		shr	bh, 1		; bh >>= 1; (=bx/512)
  6652 00001FF8 887D11                  		mov	[di+11h], bh	; [di+BDS.fatsecs]
  6653                                  					; save number of fat sectors
  6654 00001FFB EB39                    		jmp	short massage_bpb
  6655                                  ; ---------------------------------------------------------------------------
  6656                                  
  6657                                  ; for bigfat we do need to extend this logic to 32 bit sector calculation.
  6658                                  
  6659                                  dobig:					
  6660 00001FFD B104                    		mov	cl, 4		; 16 (2^4) directory entries per sector
  6661 00001FFF 52                      		push	dx		; save total sectors (high)
  6662 00002000 8B550C                  		mov	dx, [di+0Ch]	; [di+BDS.direntries]
  6663 00002003 D3EA                    		shr	dx, cl		; root dir sectors = BDS.direntries / 16;
  6664 00002005 29D0                    		sub	ax, dx
  6665 00002007 5A                      		pop	dx
  6666 00002008 83DA00                  		sbb	dx, 0		; dx:ax	= total	sectors	- root dir sectors
  6667 0000200B 83E801                  		sub	ax, 1
  6668 0000200E 83DA00                  		sbb	dx, 0		; dx:ax	= t - r	- d
  6669                                  					; total	secs - reserved	secs - root dir	secs
  6670 00002011 B302                    		mov	bl, 2
  6671 00002013 8A7D08                  		mov	bh, [di+8]	; [di+BDS.secperclus]
  6672                                  					; bx = 256 * BDS.secperclus + 2
  6673                                  
  6674                                  ; I don't understand why to add bx here!!!
  6675                                  
  6676                                  		; 29/12/2018 - Erdogan Tan (Retro DOS v4.0)
  6677                                  		; 27/09/2022
  6678                                  		; (Microsoft FAT32 File	System Specification,
  6679                                  		; December 2000, Page 21)
  6680                                  		; TmpVal1 = DskSize - (BPB_ResvdSecCnt+RootrDirSectors)
  6681                                  		; TmpVal2 = (256*BPB_SecPerClus)+BPB_NumFATs
  6682                                  		; FATsz	= (TmpVal1+(TmpVal2-1))/TmpVal2
  6683                                  		; (If FATType == FAT16,	BPB_FATSz16 = LOWORD(FATSz))
  6684                                  		
  6685 00002016 01D8                    		add	ax, bx		; ax = t-r-d+256*spc+2
  6686 00002018 83D200                  		adc	dx, 0
  6687 0000201B 83E801                  		sub	ax, 1		; ax = t-r-d+256*spc+1
  6688 0000201E 83DA00                  		sbb	dx, 0
  6689                                  
  6690                                  ; assuming dx in the table will never be bigger than bx.
  6691                                  
  6692 00002021 F7F3                    		div	bx		; BDS.fatsecs =
  6693                                  					; ceil((total-dir-res)/(256*BDS.secperclus+2))
  6694 00002023 894511                  		mov	[di+11h], ax	; [di+BDS.fatsecs]
  6695                                  					; number of fat	sectors
  6696                                  
  6697                                  ; now, set the default filesys_id, volume label, serial number
  6698                                  
  6699                                  		;;mov	bl, ds:fbigfat
  6700                                  		; 11/09/2023
  6701                                  		; 17/10/2022
  6702                                  		;mov	bl, [fbigfat]
  6703                                  		;mov	[di+1Fh], bl	; [di+BDS.fatsiz] ; fat	size flag
  6704                                  
  6705 00002026 1E                      		push	ds
  6706 00002027 1E                      		push	ds
  6707 00002028 07                      		pop	es
  6708 00002029 0E                      		push	cs
  6709 0000202A 1F                      		pop	ds
  6710                                  		; 11/09/2023
  6711 0000202B A0[D216]                		mov	al, [fbigfat]
  6712 0000202E BD[D005]                		mov	bp, CLEARIDS_X	; clear_ids_x (uses AL value here)
  6713                                  		; 17/10/2022
  6714                                  		;mov	bp, CLEARIDS
  6715                                  		;;mov	bp, 5D9h	; clear_ids
  6716                                  					; at 2C7h:5D9h = 70h:2B49h
  6717 00002031 0E                      		push	cs
  6718 00002032 E830F7                  		call	call_bios_code
  6719 00002035 1F                      		pop	ds
  6720                                  
  6721                                  ; at this point, in bpb of bds table, BDS_BPB.BPB_BIGTOTALSECTORS which is
  6722                                  ; set according to the partition information. we are going to
  6723                                  ; see if (hidden sectors + total sectors) > a word. if it is true,
  6724                                  ; then no change. otherwise, BDS_BPB.BPB_BIGTOTALSECTORS will be moved
  6725                                  ; to BDS_BPB.BPB_TOTALSECTORS and BDS_BPB.BPB_BIGTOTALSECTORS will be set to 0.
  6726                                  ; we don't do this for the bpb information from the boot record. we
  6727                                  ; are not going to change the bpb information from the boot record.
  6728                                  
  6729                                  massage_bpb:
  6730                                  		; 11/09/2023
  6731                                  		;; 12/12/2022
  6732                                  		;mov	bl, [fbigfat]
  6733                                  		;mov	[di+1Fh], bl	; [di+BDS.fatsiz]
  6734                                  		;;			; set size of fat on media
  6735                                  		
  6736 00002036 8B551D                  		mov	dx, [di+1Dh]	; [di+BDS.totalsecs32+2]
  6737 00002039 8B451B                  		mov	ax, [di+1Bh]	; [di+BDS.totalsecs32]
  6738 0000203C 83FA00                  		cmp	dx, 0		; double word total sectors?
  6739                                  		;ja	short goodret	; don't have to change it.
  6740                                  		; 12/12/2022
  6741 0000203F 771B                    		ja	short short goodret2
  6742                                  		;cmp	word [di+19h], 0 ; [di+BDS.hiddensecs+2]
  6743                                  		;ja	short goodret	; don't have to change it.
  6744                                  		; 12/12/2022
  6745 00002041 395519                  		cmp	[di+19h], dx ; 0
  6746 00002044 7716                    		ja	short goodret2
  6747 00002046 034517                  		add	ax, [di+17h]	; [di+BDS.hiddensecs]
  6748                                  		;jb	short goodret
  6749                                  		; 12/12/2022
  6750 00002049 7209                    		jc	short goodret
  6751 0000204B 8B451B                  		mov	ax, [di+1Bh]	; [di+BDS.totalsecs32]
  6752 0000204E 89450E                  		mov	[di+0Eh], ax	; [di+BDS.totalsecs16]
  6753                                  		;mov	word [di+1Bh], 0 ; [di+BDS.totalsecs32]
  6754                                  		; 12/12/2022
  6755 00002051 89551B                  		mov	[di+1Bh], dx ; 0 
  6756                                  goodret:	
  6757                                  		;mov	bl, ds:fbigfat
  6758                                  		; 11/09/2023
  6759                                  		; 12/12/2022
  6760                                  		; 17/10/2022
  6761 00002054 8A1E[D216]              		mov	bl, [fbigfat]
  6762 00002058 885D1F                  		mov	[di+1Fh], bl	; [di+BDS.fatsiz]
  6763                                  		;			; set size of fat on media
  6764 0000205B F8                      		clc
  6765                                  ret_hard_err:
  6766                                  		; 12/12/2022
  6767                                  goodret2:					
  6768 0000205C 07                      		pop	es
  6769 0000205D 1F                      		pop	ds
  6770 0000205E 5B                      		pop	bx
  6771 0000205F 5F                      		pop	di
  6772 00002060 C3                      		retn
  6773                                  
  6774                                  ; =============== S U B	R O U T	I N E =======================================
  6775                                  
  6776                                  ; 15/10/2022
  6777                                  
  6778                                  ;fdisk of pc dos 3.3 and below, os2 1.0 has a bug. the maximum number of
  6779                                  ;sector that can be handled by pc dos 3.3 ibmbio should be 0ffffh.
  6780                                  ;instead, sometimes fdisk use 10000h to calculate the maximum number.
  6781                                  ;so, we are going to check that if BPB_TOTALSECTORS + hidden sector = 10000h
  6782                                  ;then subtract 1 from BPB_TOTALSECTORS.
  6783                                  
  6784                                  		; 17/10/2022
  6785                                  cover_fdisk_bug:	
  6786 00002061 50                      		push	ax
  6787 00002062 52                      		push	dx
  6788 00002063 56                      		push	si
  6789 00002064 2E803E[7401]29          		cmp	byte [cs:disksector+26h], 29h
  6790                                  					; [disksector+EXT_BOOT.SIG],
  6791                                  					; EXT_BOOT_SIGNATURE
  6792 0000206A 7431                    		jz	short cfb_retit	; if extended bpb, then	>= pc dos 4.00
  6793 0000206C 2E817F073130            		cmp	word [cs:bx+7], 3031h ; '10' ; os2 1.0 = ibm 10.0
  6794 00002072 7507                    		jnz	short cfb_chk_BPB_TOTALSECTORS
  6795 00002074 2E807F0A30              		cmp	byte [cs:bx+10], '0'
  6796 00002079 7522                    		jnz	short cfb_retit
  6797                                  cfb_chk_BPB_TOTALSECTORS:
  6798                                  		; 17/10/2022		
  6799 0000207B BE[5901]                		mov	si, disksector+11 ; 14Eh+0Bh
  6800                                  		;mov	si, 159h	; disksector+EXT_BOOT.BPB
  6801 0000207E 2E837C0800              		cmp	word [cs:si+8], 0 ; [cs:si+EBPB.TOTALSECTORS]
  6802                                  					; just to make sure.
  6803 00002083 7418                    		jz	short cfb_retit
  6804 00002085 2E8B4408                		mov	ax, [cs:si+8]	; [cs:si+EBPB.TOTALSECTORS]
  6805 00002089 2E034411                		add	ax, [cs:si+11h]	; [cs:si+EBPB.HIDDENSECTORS]
  6806 0000208D 730E                    		jnb	short cfb_retit
  6807 0000208F 750C                    		jnz	short cfb_retit	; if carry set and ax=0
  6808 00002091 2EFF4C08                		dec	word [cs:si+8]	; 0 -> 0FFFFh
  6809                                  					; then decrease	BPB_TOTALSECTORS by 1
  6810 00002095 836D1B01                		sub	word [di+1Bh], 1 ; [di+BDS.totalsecs32]
  6811 00002099 835D1D00                		sbb	word [di+1Dh], 0 ; [di+BDS.totalsecs32+2]
  6812                                  cfb_retit:				
  6813 0000209D 5E                      		pop	si
  6814 0000209E 5A                      		pop	dx
  6815 0000209F 58                      		pop	ax
  6816 000020A0 C3                      		retn
  6817                                  
  6818                                  ; ---------------------------------------------------------------------------
  6819                                  
  6820 000020A1 0200                    word2		dw 2			
  6821 000020A3 0300                    word3		dw 3			
  6822 000020A5 0002                    word512		dw 512			
  6823                                  
  6824                                  ; =============== S U B	R O U T	I N E =======================================
  6825                                  
  6826                                  ; 15/10/2022
  6827                                  
  6828                                  ; setdrvparms sets up the recommended bpb in each bds in the system based on
  6829                                  ; the form factor. it is assumed that the bpbs for the various form factors
  6830                                  ; are present in the bpbtable. for hard files, the recommended bpb is the same
  6831                                  ; as the bpb on the drive.
  6832                                  ;
  6833                                  ; no attempt is made to preserve registers since we are going to jump to
  6834                                  ; sysinit straight after this routine.
  6835                                  
  6836                                  setdrvparms:
  6837 000020A7 31DB                    		xor	bx, bx
  6838                                  		; 18/10/2022
  6839 000020A9 C43E[1901]              		les	di, [start_bds] ; get first bds in list
  6840                                  _next_bds:				
  6841 000020AD 06                      		push	es
  6842 000020AE 57                      		push	di
  6843 000020AF 268A5D22                		mov	bl, [es:di+22h]	; [es:di+BDS.formfactor]
  6844 000020B3 80FB05                  		cmp	bl, 5		; ffHardFile
  6845 000020B6 753E                    		jnz	short nothardff
  6846 000020B8 31D2                    		xor	dx, dx
  6847 000020BA 268B450E                		mov	ax, [es:di+0Eh]	; [es:di+BDS.totalsecs16]
  6848 000020BE 09C0                    		or	ax, ax
  6849 000020C0 7508                    		jnz	short get_ccyl
  6850 000020C2 268B551D                		mov	dx, [es:di+1Dh]	; [es:di+BDS.totalsecs32+2]
  6851 000020C6 268B451B                		mov	ax, [es:di+1Bh]	; [es:di+BDS.totalsecs32]
  6852                                  
  6853                                  get_ccyl:				
  6854 000020CA 52                      		push	dx
  6855 000020CB 50                      		push	ax
  6856 000020CC 268B4515                		mov	ax, [es:di+15h]	; [es:di+BDS.heads]
  6857 000020D0 26F76513                		mul	word [es:di+13h] ; [es:di+BDS.secpertrack]
  6858                                  					; assume sectors per cyl. < 64k.
  6859 000020D4 89C1                    		mov	cx, ax		; cx has # sectors per cylinder
  6860 000020D6 58                      		pop	ax
  6861 000020D7 5A                      		pop	dx		; dx:ax	= total	sectors
  6862 000020D8 50                      		push	ax
  6863 000020D9 89D0                    		mov	ax, dx
  6864 000020DB 31D2                    		xor	dx, dx
  6865 000020DD F7F1                    		div	cx
  6866 000020DF 2EA3[2905]              		mov	[cs:temp_h], ax	; ax be	0 here.
  6867 000020E3 58                      		pop	ax
  6868 000020E4 F7F1                    		div	cx		; div #sec by sec/cyl to get # cyl.
  6869 000020E6 09D2                    		or	dx, dx
  6870 000020E8 7401                    		jz	short no_cyl_rnd ; came out even
  6871 000020EA 40                      		inc	ax		; round	up
  6872                                  
  6873                                  no_cyl_rnd:				
  6874 000020EB 26894525                		mov	[es:di+25h], ax	; [es:di+BDS.cylinders]
  6875 000020EF 06                      		push	es
  6876 000020F0 1F                      		pop	ds
  6877 000020F1 8D7506                  		lea	si, [di+6]	; [di+BDS.bytespersec]
  6878                                  					; ds:si	-> bpb for hard	file
  6879 000020F4 EB55                    		jmp	short set_recbpb
  6880                                  ; ---------------------------------------------------------------------------
  6881                                  
  6882                                  nothardff:				
  6883 000020F6 0E                      		push	cs
  6884 000020F7 1F                      		pop	ds
  6885                                  
  6886                                  ; if fake floppy drive variable is set then we don't have to handle this bds.
  6887                                  ; we can just go and deal with the next bds at label go_to_next_bds.
  6888                                  
  6889                                  		; 10/12/2022
  6890                                  		; ds = cs
  6891                                  		; 17/10/2022 (ds=cs)
  6892 000020F8 803E[E116]01            		cmp	byte [fakefloppydrv], 1
  6893                                  		;cmp	byte [cs:fakefloppydrv], 1
  6894 000020FD 7454                    		jz	short go_to_next_bds
  6895 000020FF 80FB07                  		cmp	bl, 7		; ffother
  6896                                  					; special case "other" type of medium
  6897 00002102 753D                    		jnz	short not_process_other
  6898                                  process_other:
  6899 00002104 31D2                    		xor	dx, dx
  6900 00002106 8B4525                  		mov	ax, [di+25h]	; [di+BDS.cylinders]
  6901 00002109 F76536                  		mul	word [di+36h]	; [di+BDS.rheads]
  6902 0000210C F76534                  		mul	word [di+34h]	; [di+BDS.rsecpertrack]
  6903 0000210F 89452F                  		mov	[di+2Fh], ax	; [di+BDS.rtotalsecs16]
  6904                                  					; have the total number of sectors
  6905 00002112 48                      		dec	ax
  6906 00002113 B201                    		mov	dl, 1
  6907                                  _again:					
  6908 00002115 3DF60F                  		cmp	ax, 0FF6h	; 4096-10
  6909 00002118 7206                    		jb	short _@@
  6910 0000211A D1E8                    		shr	ax, 1
  6911 0000211C D0E2                    		shl	dl, 1
  6912 0000211E EBF5                    		jmp	short _again
  6913                                  ; ---------------------------------------------------------------------------
  6914                                  
  6915                                  _@@:					
  6916 00002120 80FA01                  		cmp	dl, 1		; is it	a small	disk ?
  6917 00002123 7405                    		jz	short __@@	; yes, 224 root	entries	is enuf
  6918 00002125 C7452DF000              		mov	word [di+2Dh], 240 ; [di+BDS.rdirentries]
  6919                                  __@@:					
  6920 0000212A 885529                  		mov	[di+29h], dl	; [di+BDS.rsecperclus]
  6921                                  
  6922                                  ; logic to get the sectors/fat area.
  6923                                  ; fat entry is assumed to be 1.5 bytes!!!
  6924                                  
  6925                                  		; 10/12/2022
  6926                                  		; ds = cs
  6927                                  		; 17/10/2022 (ds=cs)
  6928 0000212D F726[A320]              		mul	word [word3]
  6929 00002131 F736[A120]              		div	word [word2]
  6930 00002135 31D2                    		xor	dx, dx
  6931 00002137 F736[A520]              		div	word [word512]
  6932                                  		;
  6933                                  		; 10/12/2022
  6934                                  		;mul	word [cs:word3]	; * 3 ; mul word [cs:word3]
  6935                                  		;div	word [cs:word2]	; / 2 ; div word [cs:word2]
  6936                                  		;xor	dx, dx
  6937                                  		;div	word [cs:word512] ; / 512 ; div word [cs:word512]
  6938                                  		;
  6939 0000213B 40                      		inc	ax		; + 1
  6940                                  no_round_up:
  6941 0000213C 894532                  		mov	[di+32h], ax	; [di+BDS.rfatsecs]
  6942 0000213F EB12                    		jmp	short go_to_next_bds
  6943                                  ; ---------------------------------------------------------------------------
  6944                                  
  6945                                  not_process_other:			
  6946 00002141 D1E3                    		shl	bx, 1		; bx is	word index into	table of bpbs
  6947                                  		;mov	si, bpbtable
  6948                                  		;mov	si, [bpbtable+bx] ; 15/10/2022
  6949                                  		; 09/12/2022
  6950                                  		;mov	si, BPBTABLE
  6951                                  		;mov	si, [bx+si]	; get address of bpb
  6952                                  		; 10/12/2022
  6953                                  		;mov	si, [BPBTABLE+bx]
  6954                                  		; 13/12/2022
  6955                                  		;mov	si, [SYSINITOFFSET+bpbtable+bx] ; wrong ! 14/08/2023
  6956                                  		; 14/08/2023
  6957                                  		SYSINIT_OFFSET equ ((SYSINITSEG-DOSBIODATASEG)<<4)
  6958                                  							; correct offset
  6959                                  		
  6960 00002143 8BB7[F275]              		mov	si, [bx+SYSINIT_OFFSET+bpbtable]
  6961                                  
  6962                                  		; 28/08/2023
  6963 00002147 81C6703E                		add	si, SYSINIT_OFFSET
  6964                                  set_recbpb:				
  6965 0000214B 8D7D27                  		lea	di, [di+27h]	; [di+BDS.R_BPB]
  6966                                  					; es:di	-> recbpb
  6967 0000214E B91900                  		mov	cx, 25		; bpbx.size
  6968 00002151 F3A4                    		rep movsb		; move (size bpbx) bytes	
  6969                                  go_to_next_bds:				
  6970 00002153 5F                      		pop	di
  6971 00002154 07                      		pop	es		; restore pointer to bds
  6972 00002155 26C43D                  		les	di, [es:di]	; [es:di+BDS.link]
  6973 00002158 83FFFF                  		cmp	di, 0FFFFh	; -1
  6974 0000215B 740A                    		jz	short got_end_of_bds_chain
  6975 0000215D E94DFF                  		jmp	_next_bds
  6976                                  ; ---------------------------------------------------------------------------
  6977                                  
  6978                                  		; 18/12/2022
  6979                                  ;got_end_of_bds_chain:			
  6980                                  		;retn
  6981                                  
  6982                                  ; =============== S U B	R O U T	I N E =======================================
  6983                                  
  6984                                  ; 15/10/2022
  6985                                  ; 30/12/2018 - Retro DOS v4.0
  6986                                  
  6987                                  ; al = device number
  6988                                  
  6989                                  print_init:	
  6990 00002160 98                      		cbw
  6991 00002161 89C2                    		mov	dx, ax
  6992 00002163 B401                    		mov	ah, 1
  6993 00002165 CD17                    		int	17h		; PRINTER - INITIALIZE
  6994                                  					; DX = printer port (0-3)
  6995                                  					; Return: AH = status
  6996                                  got_end_of_bds_chain:	; 18/12/2022
  6997 00002167 C3                      		retn
  6998                                  
  6999                                  ; =============== S U B	R O U T	I N E =======================================
  7000                                  
  7001                                  ; al = device number
  7002                                  
  7003                                  aux_init:
  7004 00002168 98                      		cbw
  7005 00002169 89C2                    		mov	dx, ax
  7006                                  		;mov	al, 0A3h	; RSINIT ; 0A3h
  7007                                  					; 2400,n,1,8 (msequ.inc)
  7008                                  		;mov	ah, 0
  7009                                  		; 10/12/2022
  7010 0000216B B8A300                  		mov	ax, 00A3h
  7011 0000216E CD14                    		int	14h		; SERIAL I/O - INITIALIZE USART
  7012                                  					; 	AL = initializing parameters,
  7013                                  					;	DX = port number (0-3)
  7014                                  					; Return: AH = RS-232 status code bits,
  7015                                  					;	  AL = modem status bits
  7016 00002170 C3                      		retn
  7017                                  
  7018                                  ; =============== S U B	R O U T	I N E =======================================
  7019                                  
  7020                                  ; 15/10/2022 (Modified MSDOS 5.0 IO.SYS)
  7021                                  ; 30/12/2018 - Retro DOS v4.0
  7022                                  ; 03/06/2018 - Retro DOS v3.0
  7023                                  ; (19/03/2018 - Retro DOS v2.0)
  7024                                  
  7025                                  ; domini **********************************************************************
  7026                                  ;
  7027                                  ;mini disk initialization routine. called right after dohard
  7028                                  ;modified for >2 hardfile support
  7029                                  ;
  7030                                  ; **cs=ds=es=datagrp
  7031                                  ;
  7032                                  ; **domini will search for every extended partition in the system, and
  7033                                  ;   initialize it.
  7034                                  ;
  7035                                  ; **bdsm stands for bds table for mini disk and located right after the label
  7036                                  ;   end96tpi. end_of_bdsm will have the offset value of the ending
  7037                                  ;   address of bdsm table.
  7038                                  ;
  7039                                  ; **bdsm is the same as usual bds structure except that tim_lo, tim_hi entries
  7040                                  ;   are overlapped and used to identify mini disk and the number of hidden_trks.
  7041                                  ;   right now, they are called as ismini, hidden_trks respectively.
  7042                                  ;
  7043                                  ; **domini will use the same routine in sethard routine after label set2 to
  7044                                  ;   save coding.
  7045                                  ;
  7046                                  ; **drvmax determined in dohard routine will be used for the next
  7047                                  ;   available logical mini disk drive number.
  7048                                  ;
  7049                                  ; input: drvmax, dskdrvs
  7050                                  ;
  7051                                  ; output: minidisk installed. bdsm table established and installed to bds.
  7052                                  ;	  end_of_bdsm - ending offset address of bdsm.
  7053                                  ;
  7054                                  ; called modules:
  7055                                  ;		  getboot
  7056                                  ;		  find_mini_partition (new), xinstall_bds (new), M038
  7057                                  ;
  7058                                  ;		  setmini (new, it will use set2 routine)
  7059                                  ;
  7060                                  ; variables used: end_of_bdsm
  7061                                  ;		  rom_minidisk_num
  7062                                  ;		  mini_hdlim, mini_seclim
  7063                                  ;		  BDS_STRUC, start_bds
  7064                                  ;
  7065                                  ;******************************************************************************
  7066                                  
  7067                                  		; 19/10/2022
  7068                                  domini:	
  7069 00002171 8A36[5117]              		mov	dh, [hnum]	; get number of hardfiles
  7070                                  		; 10/12/2022
  7071 00002175 20F6                    		and	dh, dh
  7072                                  		;cmp	dh, 0
  7073 00002177 7431                    		jz	short dominiret	; no hard file?	then exit.
  7074 00002179 B280                    		mov	dl, 80h		; start	with hardfile 80h
  7075                                  domini_loop:				
  7076 0000217B 52                      		push	dx
  7077 0000217C 8816[5017]              		mov	[rom_minidisk_num], dl
  7078 00002180 B408                    		mov	ah, 8
  7079 00002182 CD13                    		int	13h		; DISK - DISK -	GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)
  7080                                  					; DL = drive number
  7081                                  					; Return: CF set on error, AH =	status code, BL	= drive	type
  7082                                  					; DL = number of consecutive drives
  7083                                  					; DH = maximum value for head number, ES:DI -> drive parameter
  7084 00002184 FEC6                    		inc	dh
  7085 00002186 31C0                    		xor	ax, ax
  7086 00002188 88F0                    		mov	al, dh
  7087 0000218A A3[5617]                		mov	[mini_hdlim], ax ; # of heads
  7088 0000218D 80E13F                  		and	cl, 3Fh
  7089 00002190 88C8                    		mov	al, cl
  7090 00002192 A3[5817]                		mov	[mini_seclim], ax ; # of sectors/track
  7091 00002195 06                      		push	es
  7092 00002196 8A16[5017]              		mov	dl, [rom_minidisk_num]
  7093 0000219A E836FB                  		call	getboot		; read master boot record into
  7094                                  					; initbootsegment:bootbias
  7095 0000219D 7203                    		jb	short domininext
  7096 0000219F E80900                  		call	find_mini_partition
  7097                                  domininext:				
  7098 000021A2 07                      		pop	es
  7099 000021A3 5A                      		pop	dx
  7100 000021A4 FEC2                    		inc	dl		; next hard file
  7101 000021A6 FECE                    		dec	dh
  7102 000021A8 75D1                    		jnz	short domini_loop
  7103                                  dominiret:				
  7104 000021AA C3                      		retn
  7105                                  
  7106                                  ; =============== S U B	R O U T	I N E =======================================
  7107                                  
  7108                                  ; 15/10/2022 (Modified MSDOS 5.0 IO.SYS)
  7109                                  ; 30/12/2018 - Retro DOS v4.0
  7110                                  
  7111                                  ;find_mini_partition tries to find every extended partition on a disk.
  7112                                  ;at entry:	di -> bdsm entry
  7113                                  ;		es:bx -> 07c0:bootbias - master boot record
  7114                                  ;		rom_minidisk_num - rom drive number
  7115                                  ;		drvmax - logical drive number
  7116                                  ;		mini_hdlim, mini_seclim
  7117                                  ;
  7118                                  ;called routine: setmini which uses set2 (in sethard routine)
  7119                                  ;variables & equates used from original bios - flags, fnon_removable, fbigfat
  7120                                  
  7121                                  
  7122                                  find_mini_partition:	
  7123 000021AB 81C3C201                		add	bx, 1C2h	; bx ->	file system id
  7124                                  fmpnext:				
  7125 000021AF 26803F05                		cmp	byte [es:bx], 5 ; 5 = extended partition id.
  7126 000021B3 740A                    		jz	short fmpgot
  7127 000021B5 83C310                  		add	bx, 16
  7128 000021B8 81FB0204                		cmp	bx, 402h	; 202h+bootbias
  7129 000021BC 75F1                    		jnz	short fmpnext
  7130                                  		;jmp	short fmpnextfound ; extended partition	not found
  7131                                  		; 18/12/2022
  7132                                  fmpnextfound:
  7133 000021BE C3                      		retn
  7134                                  
  7135                                  ;		; 30/07/2019 - Retro DOS v3.2
  7136                                  ;		jb	short fmpnext
  7137                                  ;fmpret:
  7138                                  ;		retn	; 29/05/2019
  7139                                  
  7140                                  ; ---------------------------------------------------------------------------
  7141                                  
  7142                                  		; 19/10/2022
  7143                                  fmpgot:					; found my partition.				
  7144 000021BF E8A100                  		call	dmax_check	; check	for drvmax already 26
  7145 000021C2 73FA                    		jnb	short fmpnextfound ; done if too many
  7146 000021C4 8B3E[5417]              		mov	di, [end_of_bdss] ; get next free	bds
  7147 000021C8 C745470100              		mov	word [di+47h], 1 ; [di+BDS.bdsm_ismini]
  7148                                  		; 10/12/2022
  7149 000021CD 804D2301                		or	byte [di+23h], 1
  7150                                  		;or	word [di+23h], 1 ; [di+BDS.flags]
  7151                                  					; fNon_Removable
  7152 000021D1 C6452205                		mov	byte [di+22h], 5 ; [di+BDS.formfactor]
  7153                                  					; ffHardFile
  7154 000021D5 C606[D216]00            		mov	byte [fbigfat], 0 ; assume 12 bit fat.
  7155 000021DA A1[5617]                		mov	ax, [mini_hdlim]
  7156 000021DD 894515                  		mov	[di+15h], ax	; [di+BDS.heads]
  7157 000021E0 A1[5817]                		mov	ax, [mini_seclim]
  7158 000021E3 894513                  		mov	[di+13h], ax	; [di+BDS.secpertrack]
  7159 000021E6 A0[5017]                		mov	al, [rom_minidisk_num]
  7160 000021E9 884504                  		mov	[di+4],	al	; [di+BDS.drivenum]
  7161                                  					; set physical number
  7162 000021EC A0[7500]                		mov	al, [drvmax]
  7163 000021EF 884505                  		mov	[di+5],	al	; [di+BDS.drivelet]
  7164                                  					; set logical number
  7165 000021F2 26837F0A00              		cmp	word [es:bx+10], 0
  7166 000021F7 7707                    		ja	short fmpgot_cont
  7167 000021F9 26837F0840              		cmp	word [es:bx+8], 64 ; with current bpb,
  7168                                  					; only lower word is meaningful.
  7169 000021FE 72BE                    		jb	short fmpnextfound
  7170                                  					; should be bigger than 64 sectors at least
  7171                                  fmpgot_cont:				
  7172 00002200 83EB04                  		sub	bx, 4		; let bx point to the start of the entry
  7173 00002203 268A7702                		mov	dh, [es:bx+2]	; cylinder
  7174 00002207 80E6C0                  		and	dh, 0C0h	; get higher bits of cyl
  7175 0000220A D0C6                    		rol	dh, 1
  7176 0000220C D0C6                    		rol	dh, 1
  7177 0000220E 268A5703                		mov	dl, [es:bx+3]	; cyl byte
  7178 00002212 895549                  		mov	[di+49h], dx	; [di+BDS.bdsm_hidden_trks]
  7179                                  					; set hidden trks
  7180 00002215 268B4F02                		mov	cx, [es:bx+2]	; cylinder,cylinder/sector
  7181 00002219 268A7701                		mov	dh, [es:bx+1]	; head
  7182 0000221D 8A16[5017]              		mov	dl, [rom_minidisk_num]
  7183 00002221 BB0002                  		mov	bx, 200h	; bootbias
  7184 00002224 B80102                  		mov	ax, 201h
  7185 00002227 CD13                    		int	13h		; DISK - READ SECTORS INTO MEMORY
  7186                                  					; AL = number of sectors to read, CH = track, CL = sector
  7187                                  					; DH = head, DL	= drive, ES:BX -> buffer to fill
  7188                                  					; Return: CF set on error, AH =	status,	AL = number of sectors read
  7189 00002229 7293                    		jb	short fmpnextfound
  7190 0000222B BBC203                  		mov	bx, 3C2h	; 1C2h+bootbias
  7191 0000222E 06                      		push	es
  7192 0000222F E80900                  		call	setmini		; install a mini disk.
  7193                                  					; bx value saved.
  7194 00002232 07                      		pop	es
  7195 00002233 7203                    		jb	short fmpnextchain
  7196 00002235 E84000                  		call	xinstall_bds	; -- install the bdsm into table
  7197                                  fmpnextchain:				
  7198 00002238 E974FF                  		jmp	fmpnext		; let's find out
  7199                                  					; if we	have any chained partition
  7200                                  ; ---------------------------------------------------------------------------
  7201                                  
  7202                                  		; 18/12/2022
  7203                                  ;fmpnextfound:				
  7204                                  		;retn
  7205                                  
  7206                                  ; =============== S U B	R O U T	I N E =======================================
  7207                                  
  7208                                  ; 15/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
  7209                                  ; 28/12/2018 - Retro DOS v4.0 (MSDOS 6.21)
  7210                                  
  7211                                  setmini:	; 'setmini' is called from 'find_mini_partition' procedure
  7212                                  	
  7213 0000223B 57                      		push	di
  7214 0000223C 53                      		push	bx
  7215 0000223D 1E                      		push	ds
  7216 0000223E 06                      		push	es
  7217                                  setmini_1:				
  7218 0000223F 26803F01                		cmp	byte [es:bx], 1 ; FAT12 partition
  7219 00002243 741B                    		jz	short setmini_2
  7220 00002245 26803F04                		cmp	byte [es:bx], 4 ; FAT16 partition
  7221 00002249 7415                    		jz	short setmini_2
  7222 0000224B 26803F06                		cmp	byte [es:bx], 6 ; FAT16 BIG	partition
  7223 0000224F 740F                    		jz	short setmini_2
  7224 00002251 83C310                  		add	bx, 16
  7225 00002254 81FB0204                		cmp	bx, 402h	; 202h+bootbias
  7226 00002258 75E5                    		jnz	short setmini_1
  7227 0000225A F9                      		stc
  7228 0000225B 07                      		pop	es
  7229 0000225C 1F                      		pop	ds
  7230 0000225D 5B                      		pop	bx
  7231 0000225E 5F                      		pop	di
  7232 0000225F C3                      		retn
  7233                                  
  7234                                  ; ---------------------------------------------------------------------------
  7235                                  setmini_2:				
  7236 00002260 E91DFB                  		jmp	set2		; branch into middle of sethard
  7237                                  
  7238                                  ; =============== S U B	R O U T	I N E =======================================
  7239                                  
  7240                                  ; 15/10/2022
  7241                                  ; 28/12/2018 - Retro DOS v4.0
  7242                                  ;
  7243                                  ; dmax_check --- call this when we want to install a new drive.
  7244                                  ;		it checks for drvmax < 26 to see if there is
  7245                                  ;		a drive letter left.
  7246                                  ;
  7247                                  ;	drvmax < 26 : carry SET!
  7248                                  ;	drvmax >=26 : carry RESET!, error flag set for message later
  7249                                  ;			trash ax
  7250                                  
  7251                                  dmax_check:	
  7252 00002263 803E[7500]1A            		cmp	byte [drvmax], 26 ; checks for drvmax < 26
  7253 00002268 720D                    		jb	short dmax_ok	; return with carry if okay
  7254 0000226A 06                      		push	es
  7255                                  		;mov	ax, 46Dh	; SYSINIT_SEG (SYSINIT segment)
  7256 0000226B B85704                  		mov	ax, SYSINITSEG	; 17/10/2022	
  7257 0000226E 8EC0                    		mov	es, ax
  7258                                  		; 18/10/2022
  7259 00002270 26C606[FF03]01          		mov	byte [es:TOOMANYDRIVESFLAG], 1 ; 09/12/2022 
  7260                                  		;mov	byte ptr es:3FFh, 1 ; [es:toomanydrivesflag]
  7261                                  					; set message flag
  7262                                  					; [SYSINIT+toomanydrivesflag]
  7263 00002276 07                      		pop	es
  7264                                  
  7265                                  		;;push	es
  7266                                  		;;mov	ax,SYSINIT_SEG
  7267                                  		;;mov	es,ax
  7268                                  		;;mov	byte [es:toomanydrivesflag],1
  7269                                  					; set message flag
  7270                                  		;;pop	es
  7271                                  		;
  7272                                  		;mov	byte [SYSINIT+toomanydrivesflag],1
  7273                                  dmax_ok:				
  7274 00002277 C3                      		retn
  7275                                  
  7276                                  ; =============== S U B	R O U T	I N E =======================================
  7277                                  
  7278                                  ; 18/10/2022
  7279                                  ; 15/10/2022
  7280                                  ; 28/12/2018 - Retro DOS v4.0						
  7281                                  ;								 
  7282                                  ;	link next bds (at ds:di) into the chain. assume that the
  7283                                  ;	  chain is entirely within ds == datagrp. also update drvmax,
  7284                                  ;	  dskdrv_table, and end_of_bdss.	
  7285                                  
  7286                                  xinstall_bds:		
  7287 00002278 56                      		push	si
  7288 00002279 53                      		push	bx
  7289 0000227A 8B36[1901]              		mov	si, [start_bds]	; get first bds
  7290                                  xinstall_bds_1:				
  7291 0000227E 833CFF                  		cmp	word [si], 0FFFFh ; is this the last one?
  7292 00002281 7404                    		jz	short xinstall_bds_2 ;	skip ahead if so
  7293                                  		;mov	si, [si+BDS.link]
  7294 00002283 8B34                    		mov	si, [si]	; chain	through	list
  7295 00002285 EBF7                    		jmp	short xinstall_bds_1
  7296                                  ; ---------------------------------------------------------------------------
  7297                                  
  7298                                  xinstall_bds_2:				
  7299                                  		;mov	[si+BDS.link], di
  7300 00002287 893C                    		mov	[si], di
  7301                                  		;mov	[si+BDS.link+2], ds
  7302 00002289 8C5C02                  		mov	[si+2], ds
  7303                                  		;mov	word [di+BDS.link], -1
  7304 0000228C C705FFFF                		mov	word [di], 0FFFFh ; make sure it is a null ptr.
  7305                                  		;mov	[di+BDS.link+2], ds
  7306 00002290 8C5D02                  		mov	[di+2], ds ; might as well plug segment
  7307                                  		; 20/03/2019 - Retro DOS v4.0
  7308                                  		;lea	bx, [di+BDS.BPB]
  7309 00002293 8D5D06                  		lea	bx, [di+6]
  7310 00002296 8B36[5217]              		mov	si, [last_dskdrv_table]
  7311 0000229A 891C                    		mov	[si], bx
  7312 0000229C 8306[5217]02            		add	word [last_dskdrv_table], 2
  7313 000022A1 FE06[7500]              		inc	byte [drvmax]
  7314 000022A5 8306[5417]64            		add	word [end_of_bdss], 100 ; BDS.size = 100
  7315 000022AA 5B                      		pop	bx
  7316 000022AB 5E                      		pop	si
  7317 000022AC C3                      		retn
  7318                                  
  7319                                  ; =============== S U B	R O U T	I N E =======================================
  7320                                  
  7321                                  ; 17/10/2022
  7322                                  ; 15/10/2022
  7323                                  ; 28/12/2018 - Retro DOS v4.0
  7324                                  ; 03/06/2018 - Retro DOS v3.0
  7325                                  
  7326                                  cmos_clock_read:	
  7327 000022AD 50                      		push	ax
  7328 000022AE 51                      		push	cx
  7329 000022AF 52                      		push	dx
  7330 000022B0 55                      		push	bp
  7331 000022B1 31ED                    		xor	bp, bp
  7332                                  loop_clock:				
  7333 000022B3 31C9                    		xor	cx, cx
  7334 000022B5 31D2                    		xor	dx, dx
  7335 000022B7 B402                    		mov	ah, 2
  7336 000022B9 CD1A                    		int	1Ah		; CLOCK	- READ REAL TIME CLOCK (AT,XT286,CONV,PS)
  7337                                  					; Return: CH = hours in	BCD
  7338                                  					; CL = minutes in BCD
  7339                                  					; DH = seconds in BCD
  7340 000022BB 83F900                  		cmp	cx, 0
  7341 000022BE 7512                    		jnz	short clock_present
  7342 000022C0 83FA00                  		cmp	dx, 0
  7343 000022C3 750D                    		jnz	short clock_present
  7344 000022C5 83FD01                  		cmp	bp, 1		; read again after a slight delay, in case clock
  7345 000022C8 741C                    		jz	short no_readdate ; was	at zero	setting.
  7346 000022CA 45                      		inc	bp		; only perform delay once.
  7347 000022CB B90040                  		mov	cx, 4000h	; 16384
  7348                                  delay:					
  7349 000022CE E2FE                    		loop	delay
  7350 000022D0 EBE1                    		jmp	short loop_clock
  7351                                  ; ---------------------------------------------------------------------------
  7352                                  
  7353                                  clock_present:				
  7354 000022D2 2EC606[F304]01          		mov	byte [cs:havecmosclock], 1 ; set the flag for cmos clock
  7355 000022D8 E81000                  		call	cmosck		; reset	cmos clock rate	that may be
  7356                                  					; possibly destroyed by	cp dos and
  7357                                  					; post routine did not restore that.
  7358 000022DB 56                      		push	si
  7359 000022DC E84AF2                  		call	read_real_date	; read real-time clock for date
  7360 000022DF FA                      		cli
  7361                                  		;mov	ds:daycnt, si	; set system date
  7362 000022E0 8936[F004]              		mov	[daycnt], si
  7363 000022E4 FB                      		sti
  7364 000022E5 5E                      		pop	si
  7365                                  
  7366                                  no_readdate:				
  7367 000022E6 5D                      		pop	bp
  7368 000022E7 5A                      		pop	dx
  7369 000022E8 59                      		pop	cx
  7370 000022E9 58                      		pop	ax
  7371 000022EA C3                      		retn
  7372                                  
  7373                                  ; ---------------------------------------------------------------------------
  7374                                  
  7375                                  ; the following code is written by jack gulley in engineering group.
  7376                                  ; cp dos (CP/DOS, OS/2) is changing cmos clock rate for its own purposes
  7377                                  ; and if the use cold boot the system to use pc dos while running cp dos,
  7378                                  ; the cmos clock rate are still slow which slow down disk operations
  7379                                  ; of pc dos which uses cmos clock. pc dos is put this code in msinit
  7380                                  ; to fix this problem at the request of cp dos.
  7381                                  ;
  7382                                  ; the program is modified to be run on msinit. equates are defined
  7383                                  ; in cmosequ.inc. this program will be called by cmos_clock_read procedure.
  7384                                  ;
  7385                                  ;  the following code cmosck is used to insure that the cmos has not
  7386                                  ;	had its rate controls left in an invalid state on older at's.
  7387                                  ;
  7388                                  ;	it checks for an at model byte "fc" with a submodel type of
  7389                                  ;	00, 01, 02, 03 or 06 and resets the periodic interrupt rate
  7390                                  ;	bits in case post has not done it. this initilization routine
  7391                                  ;	is only needed once when dos loads. it should be run as soon
  7392                                  ;	as possible to prevent slow diskette access.
  7393                                  ;
  7394                                  ;	this code exposes one to dos clearing cmos setup done by a
  7395                                  ;	resident program that hides and re-boots the system.
  7396                                  
  7397                                  cmosck:					; check and reset rtc rate bits	
  7398                                  
  7399                                  ;model byte and submodel byte were already determined in msinit.
  7400                                  
  7401                                  	; 16/06/2018 - Retro DOS v3.0
  7402                                  	; 19/03/2018 (Model: 0FCh, Sub Model: 01h, REF: AMIBIOS Prog. Guide)
  7403                                  			
  7404 000022EB 50                      		push	ax
  7405 000022EC 2E803E[3E06]FC          		cmp	byte [cs:model_byte], 0FCh
  7406 000022F2 7525                    		jnz	short cmosck9	; Exit if not an AT model
  7407 000022F4 2E803E[3F06]06          		cmp	byte [cs:secondary_model_byte], 6
  7408                                  					; Is it 06 for the industral AT ?
  7409 000022FA 7408                    		jz	short cmosck4	; Go reset CMOS	periodic rate if 06
  7410 000022FC 2E803E[3F06]04          		cmp	byte [cs:secondary_model_byte], 4
  7411                                  					; Is it 00, 01, 02, or 03 ?
  7412 00002302 7315                    		jnb	short cmosck9	; EXIT if problem fixed by POST  
  7413                                  					; Also,Secondary_model_byte = 0 
  7414                                  					;   when AH=0C0h, int 15h failed.
  7415                                  					;	RESET THE CMOS PERIODIC RATE 
  7416                                  					;  Model=FC submodel=00,01,02,03 or 06 
  7417                                  cmosck4:				
  7418 00002304 B08A                    		mov	al, 8Ah		; cmos_reg_a|nmi
  7419                                  					; NMI disabled on return
  7420 00002306 B426                    		mov	ah, 26h		; 00100110b
  7421                                  					; Set divider &	rate selection
  7422 00002308 E83000                  		call	cmos_write
  7423 0000230B B08B                    		mov	al, 8Bh		; cmos_reg_b|nmi
  7424                                  					; NMI disabled on return
  7425 0000230D E80B00                  		call	cmos_read
  7426 00002310 2407                    		and	al, 7		; 00000111b
  7427                                  					; clear	SET,PIE,AIE,UIE,SQWE
  7428 00002312 88C4                    		mov	ah, al
  7429 00002314 B00B                    		mov	al, 0Bh		; cmos_reg_b
  7430                                  					; NMI enabled on return
  7431 00002316 E82200                  		call	cmos_write
  7432                                  cmosck9:				
  7433 00002319 58                      		pop	ax
  7434 0000231A C3                      		retn
  7435                                  
  7436                                  ; =============== S U B	R O U T	I N E =======================================
  7437                                  
  7438                                  ;--- CMOS_READ -----------------------------------------------------------------
  7439                                  ;		read byte from cmos system clock configuration table	       :
  7440                                  ;									       :
  7441                                  ; input: (al)=	cmos table address to be read				       :
  7442                                  ;		bit    7 = 0 for nmi enabled and 1 for nmi disabled on exit    :
  7443                                  ;		bits 6-0 = address of table location to read		       :
  7444                                  ;									       :
  7445                                  ; output: (al)	value at location (al) moved into (al). if bit 7 of (al) was   :
  7446                                  ;		on then nmi left disabled.  during the cmos read both nmi and  :
  7447                                  ;		normal interrupts are disabled to protect cmos data integrity. :
  7448                                  ;		the cmos address register is pointed to a default value and    :
  7449                                  ;		the interrupt flag restored to the entry state on return.      :
  7450                                  ;		only the (al) register and the nmi state is changed.	       :
  7451                                  ;-------------------------------------------------------------------------------
  7452                                  
  7453                                  cmos_read:				; read location (al) into (al)	
  7454 0000231B 9C                      		pushf
  7455 0000231C FA                      		cli
  7456 0000231D 53                      		push	bx
  7457 0000231E 50                      		push	ax		; AL = cmos table address to be	read
  7458 0000231F 0C80                    		or	al, 80h
  7459 00002321 E670                    		out	70h, al		; CMOS Memory/RTC Index	Register:
  7460                                  					; RTC Seconds
  7461 00002323 90                      		nop			; (undocumented	delay needed)
  7462 00002324 E471                    		in	al, 71h		; CMOS Memory/RTC Data Register
  7463 00002326 89C3                    		mov	bx, ax
  7464 00002328 58                      		pop	ax
  7465 00002329 2480                    		and	al, 80h
  7466 0000232B 0C0F                    		or	al, 0Fh
  7467 0000232D E670                    		out	70h, al		; CMOS Memory/RTC Index	Register:
  7468                                  					; RTC Seconds
  7469 0000232F 90                      		nop
  7470 00002330 E471                    		in	al, 71h		; CMOS Memory/RTC Data Register
  7471 00002332 89D8                    		mov	ax, bx
  7472 00002334 5B                      		pop	bx
  7473 00002335 0E                      		push	cs		; *place code segment in stack and
  7474 00002336 E80100                  		call	cmos_popf	; *handle popf for b- level 80286
  7475 00002339 C3                      		retn			; return with flags restored
  7476                                  
  7477                                  ; ---------------------------------------------------------------------------
  7478                                  
  7479                                  cmos_popf:				
  7480 0000233A CF                      		iret			; popf for level b- parts
  7481                                  					; return far and restore flags
  7482                                  
  7483                                  ; =============== S U B	R O U T	I N E =======================================
  7484                                  
  7485                                  ;--- cmos_write ----------------------------------------------------------------
  7486                                  ;		write byte to cmos system clock configuration table	       :
  7487                                  ;									       :
  7488                                  ; input: (al)=	cmos table address to be written to			       :
  7489                                  ;		bit    7 = 0 for nmi enabled and 1 for nmi disabled on exit    :
  7490                                  ;		bits 6-0 = address of table location to write		       :
  7491                                  ;	 (ah)=	new value to be placed in the addressed table location	       :
  7492                                  ;									       :
  7493                                  ; output:	value in (ah) placed in location (al) with nmi left disabled   :
  7494                                  ;		if bit 7 of (al) is on. during the cmos update both nmi and    :
  7495                                  ;		normal interrupts are disabled to protect cmos data integrity. :
  7496                                  ;		the cmos address register is pointed to a default value and    :
  7497                                  ;		the interrupt flag restored to the entry state on return.      :
  7498                                  ;		only the cmos location and the nmi state is changed.	       :
  7499                                  ;-------------------------------------------------------------------------------
  7500                                  
  7501                                  cmos_write:				; write (ah) to location (al)	
  7502 0000233B 9C                      		pushf			; write (ah) to location (al)
  7503 0000233C 50                      		push	ax		; save work register values
  7504 0000233D FA                      		cli
  7505 0000233E 50                      		push	ax		; save user nmi	state
  7506 0000233F 0C80                    		or	al, 80h		; disable nmi for us
  7507 00002341 E670                    		out	70h, al		; CMOS Memory/RTC Index	Register:
  7508                                  					; RTC Seconds
  7509 00002343 90                      		nop
  7510 00002344 88E0                    		mov	al, ah
  7511 00002346 E671                    		out	71h, al		; CMOS Memory/RTC Data Register
  7512 00002348 58                      		pop	ax		; get user nmi
  7513 00002349 2480                    		and	al, 80h
  7514 0000234B 0C0F                    		or	al, 0Fh
  7515 0000234D E670                    		out	70h, al		; CMOS Memory/RTC Index	Register:
  7516                                  					; RTC Seconds
  7517 0000234F 90                      		nop
  7518 00002350 E471                    		in	al, 71h		; CMOS Memory/RTC Data Register
  7519 00002352 58                      		pop	ax		; restore work registers
  7520 00002353 0E                      		push	cs		; *place code segment in stack and
  7521 00002354 E8E3FF                  		call	cmos_popf	; *handle popf for b- level 80286
  7522 00002357 C3                      		retn
  7523                                  
  7524                                  ; ---------------------------------------------------------------------------
  7525                                  ; MSINIT.ASM (MSDOS 6.0, 1991)
  7526                                  ; ---------------------------------------------------------------------------
  7527                                  ; The following routines provide support for reading in the file MSDOS.SYS.
  7528                                  ; ---------------------------------------------------------------------------
  7529                                  
  7530                                  ; 15/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
  7531                                  ;
  7532                                  ; (For Retro DOS, 'IO.SYS' and 'MSDOS.SYS' are already loaded together
  7533                                  ;  at once -as single kernel file- by the Retro DOS boot sector code.
  7534                                  ;  So, following disk reads -MSDOS.SYS loading- is not needed!
  7535                                  ;  Only needing is to move MSDOS Kernel to it's final memory location.) 
  7536                                  
  7537                                  ; =============== S U B	R O U T	I N E =======================================
  7538                                  
  7539                                  ; GetClus, read in a cluster at a specified address
  7540                                  ;
  7541                                  ;  bx = cluster to read
  7542                                  ;  cx = sectors per cluster
  7543                                  ;  es:di = load location
  7544                                  
  7545                                  ; 17/10/2022
  7546                                  ;DISKRD equ diskrd - DOSBIOSEG_2C7h	; (8E5h for MSDOS 5.0 IO.SYS)
  7547                                  ; 09/12/2022
  7548                                  DISKRD equ diskrd
  7549                                  
  7550                                  		; 17/10/2022
  7551                                  getclus:				
  7552 00002358 51                      		push	cx
  7553 00002359 57                      		push	di
  7554 0000235A 2E890E[D016]            		mov	[cs:doscnt], cx
  7555 0000235F 89D8                    		mov	ax, bx
  7556 00002361 48                      		dec	ax
  7557 00002362 48                      		dec	ax
  7558 00002363 F7E1                    		mul	cx		; convert to logical sector
  7559                                  					; dx:ax	= matching logical sector number
  7560                                  					;	  starting from the data sector
  7561 00002365 2E0306[CC16]            		add	ax, [cs:bios_l]
  7562 0000236A 2E1316[CE16]            		adc	dx, [cs:bios_h]	; dx:ax	= first	logical	sector to read
  7563                                  unpack:					
  7564 0000236F 1E                      		push	ds
  7565 00002370 50                      		push	ax
  7566 00002371 53                      		push	bx
  7567 00002372 2E8B36[D316]            		mov	si, [cs:fatloc]
  7568 00002377 8EDE                    		mov	ds, si
  7569 00002379 89DE                    		mov	si, bx		; next cluster
  7570 0000237B 2EF606[D216]40          		test	byte [cs:fbigfat], 40h	; fbig
  7571                                  					; 16 bit fat?
  7572 00002381 753C                    		jnz	short unpack16	; yes
  7573 00002383 D1EE                    		shr	si, 1		; 12 bit fat. si=si/2
  7574                                  					; si = clus + clus/2
  7575 00002385 01DE                    		add	si, bx		;
  7576                                  					; (si =	byte offset of the cluster in the FAT)
  7577 00002387 52                      		push	dx
  7578 00002388 31D2                    		xor	dx, dx
  7579 0000238A E87C00                  		call	get_fat_sector
  7580 0000238D 5A                      		pop	dx
  7581 0000238E 8B07                    		mov	ax, [bx]	; save it into ax
  7582 00002390 7517                    		jnz	short even_odd	; if not a splitted fat, check even-odd.
  7583                                  		; 25/06/2023
  7584                                  		;mov	al, [bx]	; splitted fat
  7585 00002392 2EA2[DA16]              		mov	[cs:temp_cluster], al
  7586 00002396 46                      		inc	si		; (next	byte)
  7587 00002397 52                      		push	dx
  7588 00002398 31D2                    		xor	dx, dx
  7589 0000239A E86C00                  		call	get_fat_sector
  7590 0000239D 5A                      		pop	dx
  7591                                  		;mov	al, ds:0
  7592 0000239E A00000                  		mov	al, [0] ; 19/10/2022
  7593 000023A1 2EA2[DB16]              		mov	[cs:temp_cluster+1], al
  7594 000023A5 2EA1[DA16]              		mov	ax, [cs:temp_cluster]
  7595                                  even_odd:				
  7596 000023A9 5B                      		pop	bx		; restore old fat entry	value
  7597 000023AA 53                      		push	bx		; save it right	away.
  7598 000023AB D1EB                    		shr	bx, 1		; was it even or odd?
  7599 000023AD 7308                    		jnb	short havclus	; it was even.
  7600 000023AF D1E8                    		shr	ax, 1		; odd. massage fat value and keep
  7601                                  					; the highest 12 bits.
  7602 000023B1 D1E8                    		shr	ax, 1
  7603 000023B3 D1E8                    		shr	ax, 1
  7604 000023B5 D1E8                    		shr	ax, 1
  7605                                  havclus:				
  7606 000023B7 89C3                    		mov	bx, ax		; now bx = new fat entry.
  7607 000023B9 81E3FF0F                		and	bx, 0FFFh	; keep low 12 bits.
  7608 000023BD EB0E                    		jmp	short unpackx
  7609                                  ; ---------------------------------------------------------------------------
  7610                                  
  7611                                  unpack16:				
  7612 000023BF 52                      		push	dx
  7613 000023C0 31D2                    		xor	dx, dx
  7614 000023C2 D1E6                    		shl	si, 1		; extend to 32 bit offset
  7615 000023C4 83D200                  		adc	dx, 0
  7616 000023C7 E83F00                  		call	get_fat_sector
  7617 000023CA 5A                      		pop	dx
  7618 000023CB 8B1F                    		mov	bx, [bx]	;
  7619                                  					; bx = new fat entry.
  7620                                  unpackx:				
  7621 000023CD 5E                      		pop	si		; restore old bx value into si
  7622 000023CE 58                      		pop	ax		; restore logical sector (low)
  7623 000023CF 1F                      		pop	ds
  7624 000023D0 29DE                    		sub	si, bx
  7625 000023D2 83FEFF                  		cmp	si, -1		; one apart?
  7626 000023D5 7507                    		jnz	short getcl2
  7627 000023D7 2E010E[D016]            		add	[cs:doscnt], cx
  7628 000023DC EB91                    		jmp	short unpack
  7629                                  ; ---------------------------------------------------------------------------
  7630                                  
  7631                                  getcl2:					
  7632 000023DE 53                      		push	bx
  7633 000023DF 52                      		push	dx		; sector to read (high)
  7634 000023E0 50                      		push	ax		; sector to read (low)
  7635 000023E1 2EA1[CA16]              		mov	ax, [cs:drvfat]	; get drive and	fat spec
  7636 000023E5 2E8B0E[D016]            		mov	cx, [cs:doscnt]
  7637 000023EA 5A                      		pop	dx		; sector to read for diskrd (low)
  7638 000023EB 2E8F06[2B05]            		pop	word [cs:start_sec_h]
  7639                                  					; sector to read for diskrd (high)
  7640 000023F0 1E                      		push	ds
  7641 000023F1 0E                      		push	cs
  7642 000023F2 1F                      		pop	ds
  7643 000023F3 0E                      		push	cs		; simulate far call
  7644                                  		; 17/10/2022
  7645 000023F4 BD[C508]                		mov	bp, DISKRD	; 8E5h
  7646                                  		;mov	bp, 8E5h	; offset diskrd
  7647                                  					; 2C7h:8E5h = 70h:2E55h
  7648 000023F7 E86BF3                  		call	call_bios_code	; read the clusters
  7649 000023FA 1F                      		pop	ds
  7650 000023FB 5B                      		pop	bx
  7651 000023FC 5F                      		pop	di
  7652 000023FD 2EA1[D016]              		mov	ax, [cs:doscnt]	; get number of	sectors	read
  7653 00002401 86E0                    		xchg	ah, al		; multiply by 256
  7654 00002403 D1E0                    		shl	ax, 1		; times	2 equal	512
  7655 00002405 01C7                    		add	di, ax		; update load location
  7656 00002407 59                      		pop	cx		; restore sectors/cluster
  7657 00002408 C3                      		retn
  7658                                  
  7659                                  ; =============== S U B	R O U T	I N E =======================================
  7660                                  
  7661                                  
  7662                                  ;function: find and read the corresponding fat sector into ds:0
  7663                                  ;
  7664                                  ;in). dx:si - offset value (starting from fat entry 0) of fat entry to find. M054
  7665                                  ;     ds - fatloc segment
  7666                                  ;     cs:drvfat - logical drive number, fat id
  7667                                  ;     cs:md_sectorsize
  7668                                  ;     cs:last_fat_secnum - last fat sector number read in.
  7669                                  ;
  7670                                  ;out). corresponding fat sector read in.
  7671                                  ;      bx = offset value from fatlog segment.
  7672                                  ;      other registera saved.
  7673                                  ;      zero flag set if the fat entry is splitted, i.e., when 12 bit fat entry
  7674                                  ;      starts at the last byte of the fat sector. in this case, the caller
  7675                                  ;      should save this byte, and read the next fat sector to get the rest
  7676                                  ;      of the fat entry value. (this will only happen with the 12 bit fat.)
  7677                                  
  7678                                  		; 17/10/2022
  7679                                  get_fat_sector:	
  7680 00002409 50                      		push	ax
  7681 0000240A 51                      		push	cx
  7682 0000240B 57                      		push	di
  7683 0000240C 56                      		push	si
  7684 0000240D 06                      		push	es
  7685 0000240E 1E                      		push	ds
  7686 0000240F 89F0                    		mov	ax, si
  7687 00002411 2E8B0E[D816]            		mov	cx, [cs:md_sectorsize] ; 512
  7688 00002416 F7F1                    		div	cx		; ax = sector number, dx = offset
  7689 00002418 90                      		nop
  7690                                  
  7691                                  		; Get rid of the assumption that
  7692                                  		; there	is only	one reserved sector
  7693                                  
  7694 00002419 06                      		push	es
  7695 0000241A 1E                      		push	ds
  7696 0000241B 57                      		push	di
  7697 0000241C 50                      		push	ax
  7698 0000241D 0E                      		push	cs
  7699 0000241E 1F                      		pop	ds
  7700                                  
  7701 0000241F 2EA1[CA16]              		mov	ax, [cs:drvfat]	; get drive # and FAT id
  7702 00002423 BD[CB04]                		mov	bp, SETDRIVE
  7703                                  		;mov	bp, 4D7h	; setdrive
  7704                                  					; at 2C7h:4D7h = 70h:2A47h
  7705 00002426 0E                      		push	cs		; simulate far call
  7706 00002427 E83BF3                  		call	call_bios_code	; get bds for drive
  7707 0000242A 58                      		pop	ax		; (sector number -without reserved and hidden sectors-)
  7708 0000242B 26034509                		add	ax, [es:di+9]	; [es:di+BDS.resectors]
  7709                                  					; add #reserved_sectors
  7710 0000242F 5F                      		pop	di
  7711 00002430 1F                      		pop	ds
  7712 00002431 07                      		pop	es
  7713 00002432 2E3B06[DC16]            		cmp	ax, [cs:last_fat_sec_num]
  7714 00002437 742A                    		jz	short gfs_split_chk ; don't need to read it again.
  7715 00002439 2EA3[DC16]              		mov	[cs:last_fat_sec_num], ax 
  7716                                  					; sector number
  7717                                  					; (in the partition, without hidden sectors)
  7718 0000243D 52                      		push	dx
  7719 0000243E 2EC706[2B05]0000        		mov	word [cs:start_sec_h], 0 
  7720                                  					; prepare to read the fat sector
  7721                                  					; start_sec_h is always	0 for fat sector.
  7722 00002445 89C2                    		mov	dx, ax
  7723 00002447 B90100                  		mov	cx, 1		; 1 sector read
  7724 0000244A 2EA1[CA16]              		mov	ax, [cs:drvfat]
  7725 0000244E 1E                      		push	ds
  7726 0000244F 07                      		pop	es
  7727 00002450 31FF                    		xor	di, di		; es:di	-> fatloc segment:0
  7728 00002452 1E                      		push	ds
  7729 00002453 0E                      		push	cs
  7730 00002454 1F                      		pop	ds
  7731 00002455 0E                      		push	cs		; simulate far call
  7732 00002456 BD[C508]                		mov	bp, DISKRD	; 8E5h
  7733                                  		;mov	bp, 8E5h	; offset diskrd
  7734                                  					; 2C7h:8E5h = 70h:2E55h
  7735 00002459 E809F3                  		call	call_bios_code
  7736 0000245C 1F                      		pop	ds
  7737 0000245D 5A                      		pop	dx
  7738 0000245E 2E8B0E[D816]            		mov	cx, [cs:md_sectorsize] ; 512
  7739                                  
  7740                                  gfs_split_chk:				
  7741 00002463 49                      		dec	cx		; 511
  7742 00002464 39CA                    		cmp	dx, cx		; if offset points to the
  7743                                  					; last byte of this sector,
  7744                                  					; then splitted	entry.
  7745 00002466 89D3                    		mov	bx, dx		; set bx to dx
  7746 00002468 1F                      		pop	ds
  7747 00002469 07                      		pop	es
  7748 0000246A 5E                      		pop	si
  7749 0000246B 5F                      		pop	di
  7750 0000246C 59                      		pop	cx
  7751 0000246D 58                      		pop	ax
  7752 0000246E C3                      		retn
  7753                                  
  7754                                  ; 15/10/2022
  7755                                  ;Bios_Data_Init	ends
  7756                                  
  7757                                  ; ---------------------------------------------------------------------------
  7758                                  
  7759                                  		; 09/12/2022
  7760                                  		;db 0
  7761                                  
  7762                                  numbertodiv	equ ($-BData_start)
  7763                                  numbertomod	equ (numbertodiv % 16)
  7764                                  
  7765                                  %if (numbertomod>0) & (numbertomod<16) ; 17/09/2023
  7766 0000246F 00                      		times (16-numbertomod) db 0
  7767                                  %endif
  7768                                  
  7769                                  ;align 16
  7770                                  
  7771                                  ; 09/12/2022
  7772                                  IOSYSCODESEGOFF	equ $ - BData_start
  7773                                  IOSYSCODESEG	equ (IOSYSCODESEGOFF>>4)+(700h>>4)
  7774                                  
  7775                                  ;--- End of DOSBIOS data segment --------------------------------------------
  7776                                  ; ---------------------------------------------------------------------------
  7777                                  		;db 4 dup(0)
  7778                                  ; 09/12/2022		
  7779                                  ;		times 4 db 0	; 19/10/2022
  7780                                  ; ---------------------------------------------------------------------------
  7781                                  
  7782                                  ;============================================================================
  7783                                  ; DOS BIOS (IO.SYS) CODE SEGMENT 
  7784                                  ;============================================================================
  7785                                  ; 09/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
  7786                                  
  7787                                  section .BIOSCODE vstart=0  
  7788                                  
  7789                                  BCode_start:	 ; 09/12/2022
  7790                                   
  7791                                  ; 02/10/2022
  7792                                  
  7793                                  ;--- DOSBIOS code segment ---------------------------------------------------
  7794                                  ;----------------------------------------------------------------------------
  7795                                  ; MSBIO1.ASM (MSDOS 6.0, 1991)
  7796                                  ;----------------------------------------------------------------------------
  7797                                  
  7798                                  DOSBIOSEG_2C7h:	;db 30h dup(0)		; SEGMENT 2C7h (2C70h-700h=2570h)
  7799 00000000 00<rep 30h>             		times 48 db 0		; 19/10/2022	
  7800 00000030 7000                    BiosDataWord:	dw 70h
  7801                                  
  7802                                  ; 15/10/2022
  7803                                  ;BIOSDATAWORD	equ BiosDataWord - DOSBIOSEG_2C7h
  7804                                  ; 09/12/2022
  7805                                  BIOSDATAWORD	equ BiosDataWord
  7806                                  
  7807                                  ; ---------------------------------------------------------------------------
  7808                                  
  7809                                  ; 15/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS) 
  7810                                  
  7811                                  ;************************************************************************
  7812                                  ;*									*
  7813                                  ;*	seg_reinit is called with ax = our new code segment value,	*
  7814                                  ;*	  trashes di, cx, es						*
  7815                                  ;*									*
  7816                                  ;*	cas -- should be made disposable!				*
  7817                                  ;*									*
  7818                                  ;************************************************************************
  7819                                  
  7820                                  _seg_reinit:
  7821 00000032 2E8E06[3000]            		mov	es, [cs:BIOSDATAWORD]
  7822                                  					; at 2C7h:30h or 70h:25A0h
  7823                                  		;mov	di, (offset cdev+2)
  7824 00000037 BF[E006]                		mov	di, cdev+2	; 19/10/2022
  7825 0000003A B90400                  		mov	cx, 4		; (end_BC_entries - cdev)/4
  7826                                  
  7827                                  _seg_reinit_1:				
  7828 0000003D AB                      		stosw			; modify Bios_Code entry points
  7829 0000003E 47                      		inc	di
  7830 0000003F 47                      		inc	di
  7831 00000040 E2FB                    		loop	_seg_reinit_1
  7832 00000042 CB                      		retf
  7833                                  
  7834                                  ; ---------------------------------------------------------------------------
  7835                                  
  7836                                  ; 15/10/2022
  7837                                  
  7838                                  ;************************************************************************
  7839                                  ;*									*
  7840                                  ;*	chardev_entry - main device driver dispatch routine		*
  7841                                  ;*	   called with a dummy parameter block on the stack		*
  7842                                  ;*	   dw dispatch_table, dw prn/aux numbers (optional)		*
  7843                                  ;*									*
  7844                                  ;*	will eventually take care of doing the transitions in		*
  7845                                  ;*	   out of Bios_Code						*
  7846                                  ;*									*
  7847                                  ;************************************************************************
  7848                                  
  7849                                  chardev_entry:				; 0070h:25B3h =	02C7h:0043h
  7850 00000043 56                      		push	si
  7851 00000044 50                      		push	ax
  7852 00000045 51                      		push	cx
  7853 00000046 52                      		push	dx
  7854 00000047 57                      		push	di
  7855 00000048 55                      		push	bp
  7856 00000049 1E                      		push	ds
  7857 0000004A 06                      		push	es
  7858 0000004B 53                      		push	bx
  7859 0000004C 89E5                    		mov	bp, sp
  7860 0000004E 8B7612                  		mov	si, [bp+18]	; get return address (dispatch table)
  7861                                  		;;mov	ds, word [cs:0030h]
  7862                                  		;mov	ds, word ptr cs:BIOSDATAWORD ; [cs:0030h]
  7863 00000051 2E8E1E[3000]            		mov	ds, [cs:BIOSDATAWORD] ; 17/10/2022
  7864 00000056 8B4402                  		mov	ax, [si+2]	; get the device number	if present
  7865 00000059 A2[2100]                		mov	[auxnum], al
  7866 0000005C 8826[E704]              		mov	[printdev], ah
  7867 00000060 8B34                    		mov	si, [si]	; point	to the device dispatch table
  7868 00000062 C41E[1200]              		les	bx, [ptrsav]	; get pointer to i/o packet
  7869 00000066 268A4701                		mov	al, [es:bx+1]	; [es:bx+unit]	; al = unit code
  7870 0000006A 268A670D                		mov	ah, [es:bx+13]	; [es:bx+media]	; ah = media descrip
  7871 0000006E 268B4F12                		mov	cx, [es:bx+18]	; [es:bx+count]	; cx = count
  7872 00000072 268B5714                		mov	dx, [es:bx+20]	; [es:bx+start]	; dx = start sector
  7873                                  		; 17/10/2022
  7874 00000076 81FE[9604]              		cmp	si, DSKTBL
  7875                                  		;cmp	si, 4A2h	; dsktbl
  7876                                  					; at 2C7h:4A2h = 70h:2A12h
  7877 0000007A 7517                    		jnz	short no_sector32_mapping
  7878                                  
  7879                                  ; Special case for 32-bit start sector number:
  7880                                  ;   if (si==dsktbl) /* if this is a disk device call */
  7881                                  ;      set high 16 bits of secnum to 0
  7882                                  ;      if (secnum == 0xffff) fetch 32 bit sector number
  7883                                  ;
  7884                                  ; pass high word of sector number in start_sec_h, low word in dx
  7885                                  ;
  7886                                  ; note: start_l and start_h are the offsets within the io_request packet
  7887                                  ;	  which contain the low and hi words of the 32 bit start sector if
  7888                                  ;	  it has been used.
  7889                                  ;
  7890                                  ; note: remember not to destroy the registers which have been set up before
  7891                                  
  7892                                  		;mov	ds:start_sec_h,	0 ; initialize to 0
  7893 0000007C C706[2B05]0000          		mov	word [start_sec_h], 0
  7894 00000082 83FAFF                  		cmp	dx, 0FFFFh
  7895 00000085 750C                    		jnz	short no_sector32_mapping
  7896 00000087 268B571C                		mov	dx, [es:bx+28]	; [es:bx+start_h]
  7897                                  					; 32 bits dsk req
  7898                                  		;mov	ds:start_sec_h,	dx ; start_sec_h = packet.start_h
  7899 0000008B 8916[2B05]              		mov	[start_sec_h], dx
  7900 0000008F 268B571A                		mov	dx, [es:bx+26]	; [es:bx+start_l]
  7901                                  					; dx = packet.start_l
  7902                                  no_sector32_mapping:			
  7903 00000093 97                      		xchg	ax, di
  7904 00000094 268A4702                		mov	al, [es:bx+2]	; [es:bx+cmd]
  7905 00000098 2E3A04                  		cmp	al, cs:[si]
  7906 0000009B 732C                    		jnb	short command_error
  7907 0000009D 98                      		cbw			; note that al <= 15 means ok
  7908 0000009E D1E0                    		shl	ax, 1
  7909 000000A0 01C6                    		add	si, ax
  7910 000000A2 97                      		xchg	ax, di
  7911 000000A3 26C47F0E                		les	di, [es:bx+14]	; [es:bx+trans]
  7912 000000A7 FC                      		cld
  7913                                  		; 17/10/2022
  7914 000000A8 2EFF5401                		call	near [cs:si+1]
  7915                                  		;call	word ptr cs:si+1
  7916 000000AC 7202                    		jb	short already_got_ah_status
  7917 000000AE B401                    		mov	ah, 1
  7918                                  already_got_ah_status:
  7919                                  		;;mov	ds, [cs:0030h]	; 15/10/2022			
  7920                                  		;mov	ds, word ptr cs:BIOSDATAWORD ; [cs:0030h]
  7921                                  					; cas note: shouldn't be needed!
  7922 000000B0 2E8E1E[3000]            		mov	ds, [cs:BIOSDATAWORD] ; 17/10/2022
  7923                                  		;lds	bx, ds:ptrsav
  7924 000000B5 C51E[1200]              		lds	bx, [ptrsav]
  7925 000000B9 894703                  		mov	[bx+3],	ax	; [bx+status]
  7926                                  					; mark operation complete
  7927 000000BC 5B                      		pop	bx
  7928 000000BD 07                      		pop	es
  7929 000000BE 1F                      		pop	ds
  7930 000000BF 5D                      		pop	bp
  7931 000000C0 5F                      		pop	di
  7932 000000C1 5A                      		pop	dx
  7933 000000C2 59                      		pop	cx
  7934 000000C3 58                      		pop	ax
  7935 000000C4 5E                      		pop	si
  7936 000000C5 83C402                  		add	sp, 2		; get rid of fake return address
  7937                                  	
  7938                                  		; fall through into bc_retf
  7939                                  ; ---------------------------------------------------------------------------	
  7940                                  bc_retf:
  7941 000000C8 CB                      		retf
  7942                                  ; ---------------------------------------------------------------------------
  7943                                  
  7944                                  command_error:				
  7945 000000C9 E80900                  		call	bc_cmderr
  7946 000000CC EBE2                    		jmp	short already_got_ah_status
  7947                                  ; 15/10/2022
  7948                                  ; 01/05/2019
  7949                                  
  7950                                  ;----------------------------------------------------------------------------
  7951                                  ; The following piece of hack is for supporting CP/M compatibility
  7952                                  ; Basically at offset 5 we have a far call into 0:c0. But this does not call
  7953                                  ; 0:c0 directly instead it call f01d:fef0, because it needs to support 'lhld 6'
  7954                                  ; The following hack has to reside at ffff:d0 (= f01d:fef0) if BIOS is loaded
  7955                                  ; high.
  7956                                  ;----------------------------------------------------------------------------
  7957                                  
  7958                                  		;db 7 dup(0)
  7959                                  
  7960                                  		; 15/10/2022
  7961                                  
  7962 000000CE 0000                    		dw 0		; pad to bring offset to 0D0h
  7963                                  
  7964 000000D0 00<rep 5h>              off_d0: 	times 5 db 0	; 5 bytes from 0:c0 will be copied onto here
  7965                                  				;  which is the CP/M call 5 entry point
  7966                                  		
  7967                                  
  7968                                  ; ---------------------------------------------------------------------------
  7969                                  
  7970                                  ;	exit - all routines return through this path
  7971                                  
  7972                                  bc_cmderr:				
  7973 000000D5 B003                    		mov	al, 3		; 2C7h:D5h = 70h:2645h
  7974                                  					; unknown command error
  7975                                  
  7976                                  ; =============== S U B	R O U T	I N E =======================================
  7977                                  
  7978                                  ;	now zero the count field by subtracting its current value,
  7979                                  ;	  which is still in cx, from itself.
  7980                                  
  7981                                  ;	subtract the number of i/o's NOT YET COMPLETED from total
  7982                                  ;	  in order to return the number actually complete
  7983                                  
  7984                                  bc_err_cnt:	
  7985                                  		;les	bx, ds:ptrsav
  7986                                  		; 19/10/2022
  7987 000000D7 C41E[1200]              		les	bx, [ptrsav]
  7988 000000DB 26294F12                		sub	[es:bx+18], cx	; [es:bx+count]
  7989                                  					; # of successful i/o's
  7990 000000DF B481                    		mov	ah, 81h		; mark error return
  7991 000000E1 F9                      		stc			; indicate abnormal end
  7992 000000E2 C3                      		retn
  7993                                  
  7994                                  ; 15/10/2022
  7995                                  
  7996                                  ;Bios_Code ends
  7997                                  
  7998                                  ;----------------------------------------------------------------------------
  7999                                  ; MSCHAR.ASM - MSDOS 6.0 - 1991
  8000                                  ;----------------------------------------------------------------------------
  8001                                  ; 15/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
  8002                                  ; 10/01/2019 - Retro DOS v4.0
  8003                                  
  8004                                  ; 30/04/2019
  8005                                  
  8006                                  ;title	mschar - character and clock devices
  8007                                  
  8008                                  ;MODE_CTRLBRK	equ	0FFh
  8009                                  
  8010                                  ; BIOSCODE:00E4h (MSDOS 6.21, IO.SYS)
  8011                                  
  8012                                  ;************************************************************************
  8013                                  ;*									*
  8014                                  ;*	device driver dispatch tables					*
  8015                                  ;*									*
  8016                                  ;*	each table starts with a byte which lists the number of		*
  8017                                  ;*	legal functions, followed by that number of words. Each		*
  8018                                  ;*	word represents an offset of a routine in Bios_Code which	*
  8019                                  ;*	handles the function. The functions are terminated with		*
  8020                                  ;*	a near return. If carry is reset, a 'done' code is returned	*
  8021                                  ;*	to the caller. If carry is set, the ah/al registers are		*
  8022                                  ;*	returned as abnormal completion status. Notice that ds		*
  8023                                  ;*	is assumed to point to the Bios_Data segment throughout.	*
  8024                                  ;*									*
  8025                                  ;************************************************************************
  8026                                  
  8027                                  		; 13/12/2022
  8028                                  		;db 0
  8029                                  
  8030                                  		; 13/12/202
  8031 000000E3 0B                      con_table:	db ((con_table_end - con_table)-1)/2 ; 11
  8032                                  					; 2C7h:0E4h = 70h:2654h
  8033 000000E4 [F901]                  		dw bc_exvec  ; 1FBh	; bc_exvec at 2C7h:1FBh	= 70h:276Bh
  8034                                  					; 00 init
  8035 000000E6 [F901]                  		dw bc_exvec  ; 1FBh	; 01
  8036 000000E8 [F901]                  		dw bc_exvec  ; 1FBh	; 02
  8037 000000EA [D500]                  		dw bc_cmderr ; 0D5h	; bc_exvec at 2C7h:D5h = 70h:2645h
  8038                                  					; 03
  8039 000000EC [5B01]                  		dw con_read  ; 15Ch	; con_read at 2C7h:15Ch	= 70h:26CCh
  8040                                  					; 04
  8041 000000EE [9E01]                  		dw con_rdnd  ; 19Fh	; con_rdnd at 2C7h:19Fh	= 70h:270Fh
  8042                                  					; 05
  8043 000000F0 [F901]                  		dw bc_exvec  ; 1FBh	; 06
  8044 000000F2 [0702]                  		dw con_flush ; 209h	; con_flush at 2C7h:209h = 70h:2779h
  8045                                  					; 07
  8046 000000F4 [FB01]                  		dw con_writ  ; 1FDh	; con_writ at 2C7h:1FDh	= 70h:276Dh
  8047                                  					; 08
  8048 000000F6 [FB01]                  		dw con_writ  ; 1FDh	; 09
  8049 000000F8 [F901]                  		dw bc_exvec  ; 1FBh	; 0A
  8050                                  con_table_end:
  8051 000000FA 1A                      prn_table:	db ((prn_table_end - prn_table)-1)/2 ; 26			
  8052                                  					; 2C7h:0FBh = 70h:266Bh
  8053 000000FB [F901]                  		dw bc_exvec   ; 1FBh	; bc_exvec
  8054 000000FD [F901]                  		dw bc_exvec   ; 1FBh	; 01
  8055 000000FF [F901]                  		dw bc_exvec   ; 1FBh	; 02
  8056 00000101 [D500]                  		dw bc_cmderr  ;	0D5h	; bc_cmderr
  8057 00000103 [1802]                  		dw prn_input  ;	21Ah	; prn_input
  8058                                  					; 04 indicate zero chars read
  8059 00000105 [C601]                  		dw z_bus_exit ; 1C8h	; z_bus_exit
  8060                                  					; 05 read non-destructive
  8061 00000107 [F901]                  		dw bc_exvec   ; 1FBh	; 06
  8062 00000109 [F901]                  		dw bc_exvec   ; 1FBh	; 07
  8063 0000010B [1D02]                  		dw prn_writ   ;	21Fh	; prn_writ
  8064 0000010D [1D02]                  		dw prn_writ   ; 21Fh	; 09
  8065 0000010F [4E02]                  		dw prn_stat   ; 251h	; prn_stat
  8066 00000111 [F901]                  		dw bc_exvec   ; 1FBh	; 0B
  8067 00000113 [F901]                  		dw bc_exvec   ; 1FBh	; 0C
  8068 00000115 [F901]                  		dw bc_exvec   ; 1FBh	; 0D
  8069 00000117 [F901]                  		dw bc_exvec   ; 1FBh	; 0E
  8070 00000119 [F901]                  		dw bc_exvec   ; 1FBh	; 0F
  8071 0000011B [8802]                  		dw prn_tilbusy ; 28Bh	; prn_tilbusy
  8072 0000011D [F901]                  		dw bc_exvec   ; 1FBh	; 11
  8073 0000011F [F901]                  		dw bc_exvec   ; 1FBh	; 12
  8074 00000121 [B602]                  		dw prn_genioctl ; 2BAh	; prn_genioctl
  8075 00000123 [F901]                  		dw bc_exvec   ; 1FBh	; 14
  8076 00000125 [F901]                  		dw bc_exvec   ; 1FBh	; 15
  8077 00000127 [F901]                  		dw bc_exvec   ; 1FBh	; 16
  8078 00000129 [F901]                  		dw bc_exvec   ; 1FBh	; 17
  8079 0000012B [F901]                  		dw bc_exvec   ; 1FBh	; 18
  8080 0000012D [EB02]                  		dw prn_ioctl_query ; 2F0h ; prn_ioctl_query
  8081                                  prn_table_end:
  8082 0000012F 0B                      aux_table:	db ((aux_table_end - aux_table)-1)/2 ; 11			
  8083                                  					; 2C7h:130h = 70h:26A0h
  8084 00000130 [F901]                  		dw bc_exvec   ; 1FBh	; 00 - init
  8085 00000132 [F901]                  		dw bc_exvec   ; 1FBh	; 01
  8086 00000134 [F901]                  		dw bc_exvec   ; 1FBh	; 02
  8087 00000136 [D500]                  		dw bc_cmderr  ;	0D5h	; 03
  8088 00000138 [0603]                  		dw aux_read   ; 30Dh	; aux_read ; 04	- read
  8089 0000013A [2D03]                  		dw aux_rdnd   ; 335h	; aux_rdnd - 05	- read non-destructive
  8090 0000013C [F901]                  		dw bc_exvec   ; 1FBh	; 06
  8091 0000013E [6303]                  		dw aux_flsh   ;	36Ch	; aux_flsh
  8092 00000140 [6A03]                  		dw aux_writ   ;	374h	; aux_writ
  8093 00000142 [6A03]                  		dw aux_writ   ;	374h	; 09
  8094 00000144 [4D03]                  		dw aux_wrst   ;	355h	; aux_wrst
  8095                                  aux_table_end:
  8096 00000146 0A                      tim_table	db ((tim_table_end - tim_table)-1)/2 ; 10
  8097                                  					; 2C7h:147h = 70h:26B7h
  8098 00000147 [F901]                  		dw bc_exvec   ; 1FBh	; 00
  8099 00000149 [F901]                  		dw bc_exvec   ; 1FBh	; 01
  8100 0000014B [F901]                  		dw bc_exvec   ; 1FBh	; 02
  8101 0000014D [D500]                  		dw bc_cmderr  ;	0D5h	; 03
  8102 0000014F [2904]                  		dw tim_read   ;	435h	; tim_read
  8103 00000151 [C601]                  		dw z_bus_exit ; 1C8h	; z_bus_exit
  8104 00000153 [F901]                  		dw bc_exvec   ; 1FBh	; 06
  8105 00000155 [F901]                  		dw bc_exvec   ; 1FBh	; 07
  8106 00000157 [D003]                  		dw tim_writ   ; 3DBh	; tim_writ
  8107 00000159 [D003]                  		dw tim_writ   ; 3DBh	; 09
  8108                                  tim_table_end:
  8109                                  
  8110                                  ; ---------------------------------------------------------------------------
  8111                                  
  8112                                  ;************************************************************************
  8113                                  ;*									*
  8114                                  ;*	con_read - read cx bytes from keyboard into buffer at es:di	*
  8115                                  ;*									*
  8116                                  ;************************************************************************
  8117                                  
  8118                                  con_read:				; 2C7h:15Ch = 70h:26CCh
  8119                                  		;jcxz	short con_exit	; read cx bytes	from keyboard into buffer
  8120 0000015B E306                    		jcxz	con_exit	; 19/10/2022
  8121                                  con_loop:				
  8122 0000015D E80500                  		call	chrin		; get char in al
  8123 00000160 AA                      		stosb			; store	char at	es:di
  8124 00000161 E2FA                    		loop	con_loop
  8125                                  con_exit:				
  8126 00000163 F8                      		clc
  8127 00000164 C3                      		retn
  8128                                  
  8129                                  ; =============== S U B	R O U T	I N E =======================================
  8130                                  
  8131                                  ;************************************************************************
  8132                                  ;*									*
  8133                                  ;*	chrin - input single char from keyboard into al			*
  8134                                  ;*									*
  8135                                  ;*	  we are going to issue extended keyboard function, if		*
  8136                                  ;*	  supported. the returning value of the extended keystroke	*
  8137                                  ;*	  of the extended keyboard function uses 0E0h in al		*
  8138                                  ;*	  instead of 00h as in the conventional keyboard function.	*
  8139                                  ;*	  this creates a conflict when the user entered real		*
  8140                                  ;*	  greek alpha charater (= 0E0h) to  distinguish the extended	*
  8141                                  ;*	  keystroke and the greek alpha. this case will be handled	*
  8142                                  ;*	  in the following manner:					*
  8143                                  ;*									*
  8144                                  ;*	      ah = 16h							*
  8145                                  ;*	      int 16h							*
  8146                                  ;*	      if al == 0, then extended code (in ah)			*
  8147                                  ;*	      else if al == 0E0h, then					*
  8148                                  ;*	      if ah <> 0, then extended code (in ah)			*
  8149                                  ;*		else greek_alpha character.				*
  8150                                  ;*									*
  8151                                  ;*	also, for compatibility reason, if an extended code is		*
  8152                                  ;*	  detected, then we are going to change the value in al		*
  8153                                  ;*	  from 0E0h to 00h.						*
  8154                                  ;*									*
  8155                                  ;************************************************************************
  8156                                  
  8157                                  		; 19/10/2022
  8158                                  chrin:		
  8159 00000165 8A26[E504]              		mov	ah, [keyrd_func] ; set by msinit. 0 or 10h
  8160 00000169 30C0                    		xor	al, al
  8161 0000016B 8606[0C00]              		xchg	al, [altah]	; get character	& zero altah
  8162 0000016F 08C0                    		or	al, al
  8163 00000171 752A                    		jnz	short keyret
  8164 00000173 CD16                    		int	16h		; KEYBOARD -
  8165 00000175 09C0                    		or	ax, ax
  8166 00000177 74EC                    		jz	short chrin
  8167 00000179 3D0072                  		cmp	ax, 7200h	; check	for ctrl-prtsc
  8168 0000017C 7504                    		jnz	short alt_ext_chk
  8169 0000017E B010                    		mov	al, 10h
  8170 00000180 EB1B                    		jmp	short keyret
  8171                                  ; ---------------------------------------------------------------------------
  8172                                  
  8173                                  ;  if operation was extended function (i.e. keyrd_func != 0) then
  8174                                  ;    if character read was 0E0h then
  8175                                  ;      if extended byte was zero (i.e. ah == 0) then
  8176                                  ;	 goto keyret
  8177                                  ;      else
  8178                                  ;	 set al to zero
  8179                                  ;	 goto alt_save
  8180                                  ;      endif
  8181                                  ;    endif
  8182                                  ;  endif
  8183                                  
  8184                                  alt_ext_chk:
  8185 00000182 803E[E504]00            		cmp	byte [keyrd_func], 0
  8186 00000187 740C                    		jz	short not_ext
  8187 00000189 3CE0                    		cmp	al, 0E0h
  8188 0000018B 7508                    		jnz	short not_ext
  8189 0000018D 08E4                    		or	ah, ah
  8190 0000018F 740C                    		jz	short keyret
  8191 00000191 30C0                    		xor	al, al
  8192 00000193 EB04                    		jmp	short alt_save
  8193                                  ; ---------------------------------------------------------------------------
  8194                                  
  8195                                  not_ext:				
  8196 00000195 08C0                    		or	al, al		; special case?
  8197 00000197 7504                    		jnz	short keyret
  8198                                  alt_save:				
  8199 00000199 8826[0C00]              		mov	[altah], ah	; store	special	key
  8200                                  keyret:					
  8201 0000019D C3                      		retn
  8202                                  
  8203                                  ; ---------------------------------------------------------------------------
  8204                                  
  8205                                  ;************************************************************************
  8206                                  ;*									*
  8207                                  ;*	con_rdnd - keyboard non destructive read, no wait		*
  8208                                  ;*									*
  8209                                  ;*	pc-convertible-type machine: if bit 10 is set by the dos	*
  8210                                  ;*	in the status word of the request packet, and there is no	*
  8211                                  ;*	character in the input buffer, the driver issues a system	*
  8212                                  ;*	wait request to the rom. on return from the rom, it returns	*
  8213                                  ;*	a 'char-not-found' to the dos.					*
  8214                                  ;*									*
  8215                                  ;************************************************************************
  8216                                  
  8217                                  		; 19/10/2022
  8218                                  con_rdnd:				
  8219 0000019E A0[0C00]                		mov	al, [altah]
  8220 000001A1 08C0                    		or	al, al
  8221 000001A3 754C                    		jnz	short rdexit
  8222 000001A5 8A26[E604]              		mov	ah, [keysts_func]
  8223 000001A9 CD16                    		int	16h		; KEYBOARD -
  8224 000001AB 751D                    		jnz	short gotchr
  8225 000001AD 803E[7900]00            		cmp	byte [fhavek09], 0
  8226 000001B2 7412                    		jz	short z_bus_exit
  8227 000001B4 C41E[1200]              		les	bx, [ptrsav]
  8228                                  		; 12/12/2022
  8229 000001B8 26F6470404              		test	byte [es:bx+4], 04h
  8230                                  		;test	word [es:bx+3], 400h ; [es:bx+status]
  8231 000001BD 7407                    		jz	short z_bus_exit
  8232 000001BF B80041                  		mov	ax, 4100h
  8233 000001C2 30DB                    		xor	bl, bl
  8234 000001C4 CD15                    		int	15h		; SYSTEM - WAIT	ON EXTERNAL EVENT (CONVERTIBLE)
  8235                                  					; AL = condition type, BH = condition compare or mask value
  8236                                  					; BL = timeout value times 55 milliseconds, 00h	means no timeout
  8237                                  					; DX = I/O port	address	if AL bit 4 set
  8238                                  z_bus_exit:				
  8239 000001C6 F9                      		stc			; 2C7h:1C8h = 70h:2738h
  8240 000001C7 B403                    		mov	ah, 3		; indicate busy	status
  8241 000001C9 C3                      		retn
  8242                                  ; ---------------------------------------------------------------------------
  8243                                  
  8244                                  gotchr:					
  8245 000001CA 09C0                    		or	ax, ax
  8246 000001CC 7508                    		jnz	short notbrk	; check	for null after break
  8247 000001CE 8A26[E504]              		mov	ah, [keyrd_func] ; issue keyboard read function
  8248 000001D2 CD16                    		int	16h		; KEYBOARD -
  8249 000001D4 EBC8                    		jmp	short con_rdnd	; get a	real status
  8250                                  ; ---------------------------------------------------------------------------
  8251                                  
  8252                                  notbrk:					
  8253 000001D6 3D0072                  		cmp	ax, 7200h	; check	for ctrl-prtsc
  8254 000001D9 7504                    		jnz	short rd_ext_chk
  8255 000001DB B010                    		mov	al, 10h		; ('P' & 1Fh) ; return control p
  8256 000001DD EB12                    		jmp	short rdexit
  8257                                  ; ---------------------------------------------------------------------------
  8258                                  
  8259                                  rd_ext_chk:				
  8260 000001DF 803E[E504]00            		cmp	byte [keyrd_func], 0 ; extended keyboard function?
  8261 000001E4 740B                    		jz	short rdexit
  8262 000001E6 3CE0                    		cmp	al, 0E0h	; extended key value or	greek alpha?
  8263 000001E8 7507                    		jnz	short rdexit
  8264 000001EA 80FC00                  		cmp	ah, 0		; scan code exist?
  8265 000001ED 7402                    		jz	short rdexit	; yes. greek alpha char.
  8266 000001EF B000                    		mov	al, 0		; no. extended key stroke.
  8267                                  					; change it for	compatibility
  8268                                  rdexit:					
  8269 000001F1 C41E[1200]              		les	bx, [ptrsav]
  8270 000001F5 2688470D                		mov	[es:bx+13], al	; [es:bx+media]
  8271                                  					; return keyboard character here
  8272                                  bc_exvec:				
  8273 000001F9 F8                      		clc			; bc_exvec at 2C7h:1FBh	= 70h:276Bh
  8274                                  					; indicate normal termination
  8275 000001FA C3                      		retn
  8276                                  ; ---------------------------------------------------------------------------
  8277                                  
  8278                                  ;************************************************************************
  8279                                  ;*									*
  8280                                  ;*	con_write - console write routine				*
  8281                                  ;*									*
  8282                                  ;*	entry:	es:di -> buffer						*
  8283                                  ;*		cx    =  count						*
  8284                                  ;*									*
  8285                                  ;************************************************************************
  8286                                  
  8287                                  con_writ:
  8288                                  		;jcxz	short bc_exvec
  8289 000001FB E3FC                    		jcxz	bc_exvec	; 19/10/2022
  8290                                  		; 12/12/2022
  8291                                  		;jcxz	cc_ret
  8292                                  con_lp:					
  8293 000001FD 268A05                  		mov	al, [es:di]
  8294 00000200 47                      		inc	di
  8295 00000201 CD29                    		int	29h		; DOS 2+ internal - FAST PUTCHAR
  8296                                  					; AL = character to display
  8297 00000203 E2F8                    		loop	con_lp
  8298                                  cc_ret:					
  8299 00000205 F8                      		clc
  8300 00000206 C3                      		retn
  8301                                  
  8302                                  ; =============== S U B	R O U T	I N E =======================================
  8303                                  
  8304                                  ;************************************************************************
  8305                                  ;*									*
  8306                                  ;*	con_flush - flush out keyboard queue				*
  8307                                  ;*									*
  8308                                  ;************************************************************************
  8309                                  
  8310                                  con_flush:
  8311 00000207 C606[0C00]00            		mov	byte [altah], 0	; clear	out holding buffer
  8312                                  flloop:					; while	(charavail()) charread();	
  8313 0000020C B401                    		mov	ah, 1
  8314 0000020E CD16                    		int	16h		; KEYBOARD - CHECK BUFFER, DO NOT CLEAR
  8315                                  					; Return: ZF clear if character	in buffer
  8316                                  					; AH = scan code, AL = character
  8317                                  					; ZF set if no character in buffer
  8318 00000210 74F3                    		jz	short cc_ret
  8319 00000212 30E4                    		xor	ah, ah
  8320 00000214 CD16                    		int	16h		; KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY
  8321                                  					; Return: AH = scan code, AL = character
  8322 00000216 EBF4                    		jmp	short flloop
  8323                                  
  8324                                  ; ---------------------------------------------------------------------------
  8325                                  
  8326                                  ; 15/10/2022
  8327                                  
  8328                                  ;************************************************************************
  8329                                  ;*									*
  8330                                  ;*	some equates for rom bios printer i/o				*
  8331                                  ;*									*
  8332                                  ;************************************************************************
  8333                                  
  8334                                  ; ibm rom status bits (i don't trust them, neither should you)
  8335                                  ; warning!!! the ibm rom does not return just one bit. it returns a
  8336                                  ; whole slew of bits, only one of which is correct.
  8337                                  
  8338                                  ;notbusystatus	equ 10000000b		; not busy
  8339                                  ;nopaperstatus	equ 00100000b		; no more paper
  8340                                  ;prnselected	equ 00010000b		; printer selected
  8341                                  ;ioerrstatus	equ 00001000b		; some kinda error
  8342                                  ;timeoutstatus	equ 00000001b		; time out.
  8343                                  ;
  8344                                  ;noprinter	equ 00110000b		; no printer attached
  8345                                  
  8346                                  ; 18/03/2019 - Retro DOS v4.0
  8347                                  ;error_I24_out_of_paper	equ 9 ; MSDOS 6.0, ERR.INC, 1991
  8348                                  
  8349                                  ; ---------------------------------------------------------------------------
  8350                                  
  8351                                  ;************************************************************************
  8352                                  ;*									*
  8353                                  ;*	prn_input - return with no error but zero chars read		*
  8354                                  ;*									*
  8355                                  ;*	enter with cx = number of characters requested			*
  8356                                  ;*									*
  8357                                  ;************************************************************************
  8358                                  
  8359                                  prn_input:				; 2C7h:21Ah = 70h:278Ah
  8360 00000218 E8BCFE                  		call	bc_err_cnt	; reset	count to zero
  8361                                  					; (sub reqpkt.count,cx)
  8362                                  		; 12/12/2022
  8363                                  prn_done:
  8364 0000021B F8                      		clc			; but return with carry	reset for no error
  8365 0000021C C3                      		retn
  8366                                  ; ---------------------------------------------------------------------------
  8367                                  
  8368                                  ;************************************************************************
  8369                                  ;*									*
  8370                                  ;*	prn_writ - write cx bytes from es:di to printer device		*
  8371                                  ;*									*
  8372                                  ;*	auxnum has printer number					*
  8373                                  ;*									*
  8374                                  ;************************************************************************
  8375                                  
  8376                                  prn_writ:				; 2C7h:21Fh = 70h:278Fh
  8377                                  		;jcxz	short prn_done	; no chars to output
  8378 0000021D E3FC                    		jcxz	prn_done	; 19/10/2022
  8379                                  prn_loop:				
  8380 0000021F BB0200                  		mov	bx, 2		; retry	count
  8381                                  prn_out:				
  8382 00000222 E83600                  		call	prnstat		; get status
  8383 00000225 751D                    		jnz	short TestPrnError
  8384 00000227 268A05                  		mov	al, [es:di]	; get character	to print
  8385 0000022A 30E4                    		xor	ah, ah
  8386 0000022C E82E00                  		call	prnop		; print	to printer
  8387 0000022F 7419                    		jz	short prn_con	; no error - continue
  8388 00000231 80FCFF                  		cmp	ah, 0FFh	; MODE_CTRLBRK
  8389 00000234 7509                    		jnz	short _prnwf
  8390 00000236 B00C                    		mov	al, 0Ch		; error_I24_gen_failure
  8391 00000238 C606[0C00]00            		mov	byte [altah], 0
  8392 0000023D EB08                    		jmp	short pmessg
  8393                                  ; ---------------------------------------------------------------------------
  8394                                  
  8395                                  _prnwf:					
  8396 0000023F F6C401                  		test	ah, 1		; timeoutstatus
  8397 00000242 7406                    		jz	short prn_con
  8398                                  TestPrnError:				
  8399 00000244 4B                      		dec	bx		; retry	until count is exhausted.
  8400 00000245 75DB                    		jnz	short prn_out
  8401                                  pmessg:					
  8402 00000247 E98DFE                  		jmp	bc_err_cnt
  8403                                  ; ---------------------------------------------------------------------------
  8404                                  
  8405                                  prn_con:				
  8406 0000024A 47                      		inc	di		; point	to next	char and continue
  8407 0000024B E2D2                    		loop	prn_loop
  8408                                  ;prn_done:				
  8409                                  		; 12/12/2022
  8410                                  prn_done2:
  8411                                  		;clc
  8412                                  		; cf=0
  8413 0000024D C3                      		retn
  8414                                  ; ---------------------------------------------------------------------------
  8415                                  
  8416                                  ;************************************************************************
  8417                                  ;*									*
  8418                                  ;*	prn_stat - device driver entry to return printer status		*
  8419                                  ;*									*
  8420                                  ;************************************************************************
  8421                                  
  8422                                  prn_stat:				; 2C7h:251h = 70h:27C1h
  8423 0000024E E80A00                  		call	prnstat		; device in dx
  8424 00000251 75F4                    		jnz	short pmessg
  8425 00000253 F6C480                  		test	ah, 80h		; notbusystatus
  8426                                  		;jnz	short prn_done
  8427                                  		; 12/12/2022
  8428 00000256 75F5                    		jnz	short prn_done2 ; cf=0
  8429 00000258 E96BFF                  		jmp	z_bus_exit
  8430                                  ; ---------------------------------------------------------------------------
  8431                                  
  8432                                  ;************************************************************************
  8433                                  ;*									*
  8434                                  ;*	prnstat - utility function to call ROM BIOS to check		*
  8435                                  ;*		 printer status. Return meaningful error code		*
  8436                                  ;*									*
  8437                                  ;************************************************************************
  8438                                  
  8439                                  prnstat:				
  8440 0000025B B402                    		mov	ah, 2		; set command for get status
  8441                                  					; PRINTER - GET	STATUS
  8442                                  					; DX = printer port (0-3)
  8443                                  					; Return: AH = status
  8444                                  
  8445                                  ; =============== S U B	R O U T	I N E =======================================
  8446                                  
  8447                                  ;************************************************************************
  8448                                  ;*									*
  8449                                  ;*	prnop - call ROM BIOS printer function in ah			*
  8450                                  ;*		return zero true if no error				*
  8451                                  ;*		return zero false if error, al = error code		*
  8452                                  ;*									*
  8453                                  ;************************************************************************
  8454                                  
  8455                                  prnop:	
  8456 0000025D 8B16[2100]              		mov	dx, [auxnum]	; get printer number
  8457 00000261 CD17                    		int	17h
  8458                                  
  8459                                  	; This check was added to see if this is a case of no
  8460                                  	; printer being installed. This tests checks to be sure
  8461                                  	; the error is noprinter (30h)
  8462                                  
  8463 00000263 50                      		push	ax
  8464 00000264 80E430                  		and	ah, 30h
  8465 00000267 80FC30                  		cmp	ah, 30h		; noprinter
  8466 0000026A 58                      		pop	ax
  8467 0000026B 7506                    		jnz	short NextTest
  8468 0000026D 80E4DF                  		and	ah, 0DFh	; ~nopaperstatus
  8469 00000270 80CC08                  		or	ah, 8		; ioerrstatus
  8470                                  
  8471                                  ; examine the status bits to see if an error occurred. unfortunately, several
  8472                                  ; of the bits are set so we have to pick and choose. we must be extremely
  8473                                  ; careful about breaking basic.
  8474                                  
  8475                                  NextTest:				
  8476 00000273 F6C428                  		test	ah, 28h		; (ioerrstatus+nopaperstatus)
  8477                                  					; i/o error?
  8478 00000276 740A                    		jz	short checknotready ; no, try not ready
  8479                                  
  8480                                  ; at this point, we know we have an error. the converse is not true
  8481                                  
  8482 00000278 B009                    		mov	al, 9		; error_I24_out_of_paper
  8483                                  					; first, assume	out of paper
  8484 0000027A F6C420                  		test	ah, 20h		; out of paper set?
  8485 0000027D 7502                    		jnz	short ret1	; yes, error is	set
  8486 0000027F FEC0                    		inc	al		; return al=10 (i/o error)
  8487                                  ret1:					
  8488 00000281 C3                      		retn
  8489                                  ; ---------------------------------------------------------------------------
  8490                                  
  8491                                  checknotready:				
  8492 00000282 B002                    		mov	al, 2		; assume not-ready
  8493 00000284 F6C401                  		test	ah, 1
  8494 00000287 C3                      		retn
  8495                                  
  8496                                  ; ---------------------------------------------------------------------------
  8497                                  
  8498                                  ;************************************************************************
  8499                                  ;*									*
  8500                                  ;*	prn_tilbusy - output until busy. Used by print spooler.		*
  8501                                  ;*		     this entry point should never block waiting for	*
  8502                                  ;*		     device to come ready.				*
  8503                                  ;*									*
  8504                                  ;*	inputs:	cx = count, es:di -> buffer				*
  8505                                  ;*	outputs: set the number of bytes transferred in the		*
  8506                                  ;*		 device driver request packet				*
  8507                                  ;*									*
  8508                                  ;************************************************************************
  8509                                  
  8510                                  		; 19/10/2022
  8511                                  prn_tilbusy:				; 2C7h:28Bh = 70h:27FBh
  8512 00000288 89FE                    		mov	si, di		; everything is	set for	lodsb
  8513                                  prn_tilbloop:				
  8514 0000028A 51                      		push	cx
  8515 0000028B 53                      		push	bx
  8516 0000028C 30FF                    		xor	bh, bh
  8517 0000028E 8A1E[E704]              		mov	bl, [printdev]
  8518 00000292 D1E3                    		shl	bx, 1
  8519                                  		;mov	cx, ds:wait_count[bx] ;	wait count times to come ready
  8520 00000294 8B8F[E804]              		mov	cx, [wait_count+bx]
  8521 00000298 5B                      		pop	bx
  8522                                  prn_getstat:				
  8523 00000299 E8BFFF                  		call	prnstat		; get status
  8524 0000029C 7514                    		jnz	short prn_bperr	; error
  8525 0000029E F6C480                  		test	ah, 80h		; ready	yet?
  8526 000002A1 E1F6                    		loope	prn_getstat	; no, go for more
  8527 000002A3 59                      		pop	cx		; get original count
  8528 000002A4 740D                    		jz	short prn_berr	; still	not ready => done
  8529 000002A6 26                      		es
  8530 000002A7 AC                      		lodsb
  8531                                  		;lods	byte ptr es:[si] ; es
  8532                                  					; lodsb
  8533 000002A8 30E4                    		xor	ah, ah
  8534 000002AA E8B0FF                  		call	prnop
  8535 000002AD 7504                    		jnz	short prn_berr	; error
  8536 000002AF E2D9                    		loop	prn_tilbloop
  8537                                  		; 12/12/2022
  8538                                  		; cf=0 (prnop)
  8539                                  		;clc			; normal no-error return
  8540 000002B1 C3                      		retn			;   from device driver
  8541                                  
  8542                                  ; ---------------------------------------------------------------------------
  8543                                  
  8544                                  prn_bperr:				
  8545 000002B2 59                      		pop	cx		; restore transfer count from stack
  8546                                  prn_berr:				
  8547 000002B3 E921FE                  		jmp	bc_err_cnt
  8548                                  ; ---------------------------------------------------------------------------
  8549                                  
  8550                                  ; 15/10/2022
  8551                                  
  8552                                  ;************************************************************************
  8553                                  ;*									*
  8554                                  ;*	prn_genioctl - get/set printer retry count			*
  8555                                  ;*									*
  8556                                  ;************************************************************************
  8557                                  
  8558                                  ; IOCTL.INC (MSDOS 6.0, 1991)
  8559                                  ; 11/01/2019
  8560                                  
  8561                                  ;********************************;*
  8562                                  ; CHARACTER DEVICES (PRINTERS)	 ;*
  8563                                  ;********************************;*
  8564                                  
  8565                                  ;;RAWIO SUB-FUNCTIONS
  8566                                  ;;get_retry_count equ 65h
  8567                                  ;;set_retry_count equ 45h
  8568                                  
  8569                                  ;;struc A_RETRYCOUNT
  8570                                  ;;.rc_count: resw 1
  8571                                  ;;endstruc
  8572                                  
  8573                                  ;ioc_pc equ 5
  8574                                  
  8575                                  ; ---------------------------------------------------------------------------
  8576                                  
  8577                                  		; 19/10/2022
  8578                                  prn_genioctl:				; 2C7h:2BAh = 70h:282Ah
  8579 000002B6 C43E[1200]              		les	di, [ptrsav]
  8580 000002BA 26807D0D05              		cmp	byte [es:di+13], 5 ; [es:di+IOCTL_REQ.MAJORFUNCTION]
  8581                                  					; ioc_pc
  8582 000002BF 7403                    		jz	short prnfunc_ok
  8583                                  
  8584                                  prnfuncerr:				
  8585 000002C1 E911FE                  		jmp	bc_cmderr
  8586                                  ; ---------------------------------------------------------------------------
  8587                                  
  8588                                  prnfunc_ok:				
  8589 000002C4 268A450E                		mov	al, [es:di+14]	; [es:di+IOCTL_REQ.MINORFUNCTION]
  8590 000002C8 26C47D13                		les	di, [es:di+19]	; [es:di+IOCTL_REQ.GENERICIOCTL_PACKET]
  8591 000002CC 30FF                    		xor	bh, bh
  8592                                  		;mov	bl, ds:printdev	; get index into retry counts
  8593 000002CE 8A1E[E704]              		mov	bl, [printdev]
  8594 000002D2 D1E3                    		shl	bx, 1
  8595                                  		;mov	cx, ds:wait_count[bx] ;	pull out retry count for device
  8596 000002D4 8B8F[E804]              		mov	cx, [wait_count+bx]
  8597 000002D8 3C65                    		cmp	al, 65h		; get_retry_count
  8598 000002DA 7407                    		jz	short prngetcount
  8599 000002DC 3C45                    		cmp	al, 45h		; set_retry_count
  8600 000002DE 75E1                    		jnz	short prnfuncerr
  8601 000002E0 268B0D                  		mov	cx, [es:di]
  8602                                  prngetcount:				
  8603                                  		;mov	ds:wait_count[bx], cx
  8604 000002E3 898F[E804]              		mov	[wait_count+bx], cx
  8605 000002E7 26890D                  		mov	[es:di], cx	; [es:di+A_RETRYCOUNT.RC_COUNT]
  8606                                  					; return current retry count
  8607                                  		; 12/12/2022
  8608                                  		; cf=0
  8609                                  		;clc
  8610 000002EA C3                      		retn
  8611                                  ; ---------------------------------------------------------------------------
  8612                                  
  8613                                  ;************************************************************************
  8614                                  ;*									*
  8615                                  ;*  prn_ioctl_query							*
  8616                                  ;*									*
  8617                                  ;*  Added for 5.00							*
  8618                                  ;************************************************************************
  8619                                  
  8620                                  prn_ioctl_query:			; 2C7h:2F0h = 70h:2860h
  8621 000002EB C43E[1200]              		les	di, [ptrsav]
  8622 000002EF 26807D0D05              		cmp	byte [es:di+13], 5 ; [es:di+IOCTL_REQ.MAJORFUNCTION]
  8623                                  					; ioc_pc
  8624 000002F4 750D                    		jnz	short prn_query_err
  8625 000002F6 268A450E                		mov	al, [es:di+14]	; [es:di+IOCTL_REQ.MINORFUNCTION]
  8626 000002FA 3C65                    		cmp	al, 65h		; GET_RETRY_COUNT
  8627 000002FC 7404                    		jz	short IOCtlSupported
  8628 000002FE 3C45                    		cmp	al, 45h		; SET_RETRY_COUNT
  8629 00000300 7501                    		jnz	short prn_query_err
  8630                                  IOCtlSupported:	
  8631                                  		; 12/12/2022
  8632                                  		; cf=0		
  8633                                  		;clc
  8634 00000302 C3                      		retn
  8635                                  ; ---------------------------------------------------------------------------
  8636                                  
  8637                                  prn_query_err:
  8638                                  		; 12/12/2022				
  8639                                  		;stc
  8640 00000303 E9CFFD                  		jmp	bc_cmderr ; (bc_cmderr sets cf to 1)
  8641                                  ; ---------------------------------------------------------------------------
  8642                                  
  8643                                  ;************************************************************************
  8644                                  ;*									*
  8645                                  ;*	aux port driver code -- "aux" == "com1"				*
  8646                                  ;*									*
  8647                                  ;*	the device driver entry/dispatch code sets up auxnum to		*
  8648                                  ;*	give the com port number to use (0=com1, 1=com2, 2=com3...)	*
  8649                                  ;*									*
  8650                                  ;************************************************************************
  8651                                  
  8652                                  ;	values in ah, requesting function of int 14h in rom bios
  8653                                  
  8654                                  ;auxfunc_send	 equ	1	;transmit
  8655                                  ;auxfunc_receive equ	2	;read
  8656                                  ;auxfunc_status	 equ	3	;request status
  8657                                  
  8658                                  ;	error flags, reported by int 14h, reported in ah:
  8659                                  
  8660                                  ;flag_data_ready equ	01h	;data ready
  8661                                  ;flag_overrun	 equ	02h	;overrun error
  8662                                  ;flag_parity	 equ	04h	;parity error
  8663                                  ;flag_frame	 equ	08h	;framing error
  8664                                  ;flag_break	 equ	10h	;break detect
  8665                                  ;flag_tranhol_emp equ	20h	;transmit holding register empty
  8666                                  ;flag_timeout	 equ	80h	;timeout
  8667                                  
  8668                                  ;	these flags reported in al:
  8669                                  
  8670                                  ;flag_cts	 equ	10h	;clear to send
  8671                                  ;flag_dsr	 equ	20h	;data set ready
  8672                                  ;flag_rec_sig	 equ	80h	;receive line signal detect
  8673                                  
  8674                                  ; ---------------------------------------------------------------------------
  8675                                  
  8676                                  ;************************************************************************
  8677                                  ;*									*
  8678                                  ;*	aux_read - read cx bytes from [auxnum] aux port to buffer	*
  8679                                  ;*		   at es:di						*
  8680                                  ;*									*
  8681                                  ;************************************************************************
  8682                                  
  8683                                  aux_read:				; 2C7h:30Dh = 70h:287Dh
  8684                                  		;jcxz	short exvec2
  8685 00000306 E311                    		jcxz	exvec2		; 19/10/2022
  8686 00000308 E87700                  		call	getbx		; put address of auxbuf	in bx
  8687 0000030B 30C0                    		xor	al, al
  8688 0000030D 8607                    		xchg	al, [bx]
  8689 0000030F 08C0                    		or	al, al
  8690 00000311 7503                    		jnz	short aux2
  8691                                  aux1:					
  8692 00000313 E80500                  		call	auxin		; get character	from port
  8693                                  					; won't return if error
  8694                                  aux2:					
  8695 00000316 AA                      		stosb
  8696 00000317 E2FA                    		loop	aux1		; if more characters, go around	again
  8697                                  exvec2:					
  8698 00000319 F8                      		clc			; all done, successful exit
  8699                                  auxin_retn:	; 18/12/2022
  8700 0000031A C3                      		retn
  8701                                  ; ---------------------------------------------------------------------------
  8702                                  
  8703                                  ;************************************************************************
  8704                                  ;*									*
  8705                                  ;*	auxin - call rom bios to read character from aux port		*
  8706                                  ;*		if error occurs, map the error and return one		*
  8707                                  ;*		level up to device driver exit code, setting		*
  8708                                  ;*		the number of bytes transferred appropriately		*
  8709                                  ;*									*
  8710                                  ;************************************************************************
  8711                                  
  8712                                  auxin:					
  8713 0000031B B402                    		mov	ah, 2		; auxfunc_receive
  8714 0000031D E83C00                  		call	auxop
  8715 00000320 F6C40E                  		test	ah, 0Eh		; flag_frame|flag_parity|flag_overrun
  8716                                  		;jnz	short arbad	; skip if any error bits set
  8717                                  		;retn
  8718                                  		; 25/06/2023 (BugFix)
  8719 00000323 74F5                    		jz	short auxin_retn
  8720                                  ; ---------------------------------------------------------------------------
  8721                                  
  8722                                  arbad:					
  8723 00000325 58                      		pop	ax		; remove return	address	(near call)
  8724 00000326 30C0                    		xor	al, al
  8725 00000328 0CB0                    		or	al, 0B0h	; flag_rec_sig|	flag_dsr|flag_cts
  8726 0000032A E9AAFD                  		jmp	bc_err_cnt
  8727                                  
  8728                                  ; ---------------------------------------------------------------------------
  8729                                  
  8730                                  ;************************************************************************
  8731                                  ;*									*
  8732                                  ;*	aux_rdnd - non-destructive aux port read			*
  8733                                  ;*									*
  8734                                  ;************************************************************************
  8735                                  
  8736                                  aux_rdnd:				; 2C7h:335h = 70h:28A5h
  8737 0000032D E85200                  		call	getbx
  8738 00000330 8A07                    		mov	al, [bx]	; have bx point	to auxbuf
  8739 00000332 08C0                    		or	al, al		; if al	is non-zero (char in buffer)
  8740 00000334 7511                    		jnz	short auxdrx	; then return character
  8741 00000336 E82100                  		call	auxstat		; if not, get status of	aux device
  8742 00000339 F6C401                  		test	ah, 1		; flag_data_ready - test data ready
  8743 0000033C 740C                    		jz	short auxbus	; then device is busy (not ready)
  8744 0000033E A820                    		test	al, 20h		; flag_dsr - test data set ready
  8745 00000340 7408                    		jz	short auxbus	; then device is busy (not ready)
  8746 00000342 E8D6FF                  		call	auxin		; else aux is ready, get character
  8747 00000345 8807                    		mov	[bx], al
  8748                                  auxdrx:					
  8749 00000347 E9A7FE                  		jmp	rdexit		; return busy status
  8750                                  ; ---------------------------------------------------------------------------
  8751                                  
  8752                                  auxbus:					
  8753 0000034A E979FE                  		jmp	z_bus_exit
  8754                                  ; ---------------------------------------------------------------------------
  8755                                  
  8756                                  ;************************************************************************
  8757                                  ;*									*
  8758                                  ;*	aux_wrst - return aux port write status				*
  8759                                  ;*									*
  8760                                  ;************************************************************************
  8761                                  
  8762                                  aux_wrst:				; 2C7h:355h = 70h:28C5h
  8763 0000034D E80A00                  		call	auxstat		; get status of	aux in ax
  8764 00000350 A820                    		test	al, 20h		; test data set	ready
  8765 00000352 74F6                    		jz	short auxbus	; then device is busy (not ready)
  8766 00000354 F6C420                  		test	ah, 20h		; flag_tranhol_emp - test transmit hold	reg empty
  8767 00000357 74F1                    		jz	short auxbus	; then device is busy (not ready)
  8768                                  		; 12/12/2022
  8769                                  		; cf=0	; (test instruction resets cf)
  8770                                  		;clc
  8771 00000359 C3                      		retn
  8772                                  ; ---------------------------------------------------------------------------
  8773                                  
  8774                                  ;************************************************************************
  8775                                  ;*									*
  8776                                  ;*	auxstat - call rom bios to determine aux port status		*
  8777                                  ;*									*
  8778                                  ;*	exit:	ax = status						*
  8779                                  ;*		dx = [auxnum]						*
  8780                                  ;*									*
  8781                                  ;************************************************************************
  8782                                  
  8783                                  auxstat:				
  8784 0000035A B403                    		mov	ah, 3		; auxfunc_status
  8785                                  
  8786                                  		; fall into auxop
  8787                                  
  8788                                  ; =============== S U B	R O U T	I N E =======================================
  8789                                  
  8790                                  ;************************************************************************
  8791                                  ;*									*
  8792                                  ;*	auxop - perform rom-biox aux port interrupt			*
  8793                                  ;*									*
  8794                                  ;*	entry:	ah = int 14h function number				*
  8795                                  ;*	exit:	ax = results						*
  8796                                  ;*		dx = [auxnum]						*
  8797                                  ;*									*
  8798                                  ;************************************************************************
  8799                                  
  8800                                  auxop:		; proc near		
  8801 0000035C 8B16[2100]              		mov	dx, [auxnum]	; ah=function code
  8802                                  					; 0=init, 1=send, 2=receive, 3=status
  8803                                  					; get port number
  8804 00000360 CD14                    		int	14h		; SERIAL I/O - GET USART STATUS
  8805                                  					; DX = port number (0-3)
  8806                                  					; Return: AX = port status code
  8807 00000362 C3                      		retn
  8808                                  
  8809                                  ; ---------------------------------------------------------------------------
  8810                                  
  8811                                  ;************************************************************************
  8812                                  ;*									*
  8813                                  ;*	aux_flsh - flush aux input buffer - set contents of		*
  8814                                  ;*		   auxbuf [auxnum] to zero				*
  8815                                  ;*									*
  8816                                  ;*	cas - shouldn't this code call the rom bios input function	*
  8817                                  ;*	      repeatedly until it isn't ready?  to flush out any	*
  8818                                  ;*	      pending serial input queue if there's a tsr like MODE	*
  8819                                  ;*	      which is providing interrupt-buffering of aux port?	*
  8820                                  ;*									*
  8821                                  ;************************************************************************
  8822                                  
  8823                                  aux_flsh:				; 2C7h:36Ch = 70h:28DCh
  8824 00000363 E81C00                  		call	getbx		; flush	aux input buffer
  8825 00000366 C60700                  		mov	byte [bx], 0	; get bx to point to auxbuf
  8826                                  					; zero out buffer
  8827                                  		;clc			; all done, successful return
  8828                                  		; 12/12/2022
  8829                                  		; cf=0 ('add' instruction in 'getbx')
  8830 00000369 C3                      		retn
  8831                                  ; ---------------------------------------------------------------------------
  8832                                  
  8833                                  ;************************************************************************
  8834                                  ;*									*
  8835                                  ;*	aux_writ - write to aux device					*
  8836                                  ;*									*
  8837                                  ;************************************************************************
  8838                                  
  8839                                  aux_writ:				; 2C7h:374h = 70h:28E4h
  8840                                  		;jcxz	short exvec2	; write	to aux device (if cx > 0)
  8841 0000036A E3AD                    		jcxz	exvec2		; 19/10/2022
  8842                                  aux_loop:				
  8843 0000036C 268A05                  		mov	al, [es:di]	; get character	to be written
  8844                                  					; move di pointer to next character
  8845 0000036F 47                      		inc	di
  8846 00000370 B401                    		mov	ah, 1		; auxfunc_send - indicates a write
  8847 00000372 E8E7FF                  		call	auxop		; send character over aux port
  8848 00000375 F6C480                  		test	ah, 80h		; check	for error
  8849 00000378 7405                    		jz	short awok	; then no error
  8850 0000037A B00A                    		mov	al, 10		; else indicate	write fault
  8851 0000037C E958FD                  		jmp	bc_err_cnt	; call error routines
  8852                                  ; ---------------------------------------------------------------------------
  8853                                  
  8854                                  awok:					
  8855 0000037F E2EB                    		loop	aux_loop	; if cx	is non-zero,
  8856                                  					; still	more character to print
  8857                                  		;clc			; all done, successful return
  8858                                  		; 12/12/2022
  8859                                  		; cf=0 (test instruction above)	
  8860 00000381 C3                      		retn
  8861                                  
  8862                                  ; =============== S U B	R O U T	I N E =======================================
  8863                                  
  8864                                  ;************************************************************************
  8865                                  ;*									*
  8866                                  ;*	getbx - return bx -> single byte input buffer for		*
  8867                                  ;*		selected aux port ([auxnum])				*
  8868                                  ;*									*
  8869                                  ;************************************************************************
  8870                                  
  8871                                  getbx:	
  8872 00000382 8B1E[2100]              		mov	bx, [auxnum]	; return bx -> single byte input buffer
  8873                                  					; for selected aux port	([auxnum])
  8874                                  		;add	bx, offset auxbuf
  8875 00000386 81C3[1600]              		add	bx, auxbuf	; 19/10/2022
  8876                                  		; 12/12/2022
  8877                                  		; cf=0 (if [uaxnum] is valid number) 
  8878 0000038A C3                      		retn
  8879                                  
  8880                                  ; ---------------------------------------------------------------------------
  8881                                  
  8882                                  ; 15/10/2022
  8883                                  
  8884                                  ;----------------------------------------------------------------
  8885                                  ;								:
  8886                                  ;		    clock device driver 			:
  8887                                  ;								:
  8888                                  ;								:
  8889                                  ;   this file contains the clock device driver. 		:
  8890                                  ;								:
  8891                                  ;   the routines in this files are:				:
  8892                                  ;								:
  8893                                  ;	routine 		function			:
  8894                                  ;	------- 		--------			:
  8895                                  ;	tim_writ		set the current time		:
  8896                                  ;	tim_read		read the current time		:
  8897                                  ;	time_to_ticks		convert time to corresponding	:
  8898                                  ;				  number of clock ticks 	:
  8899                                  ;								:
  8900                                  ; the clock ticks at the rate of:				:
  8901                                  ;								:
  8902                                  ;	1193180/65536 ticks/second (about 18.2 ticks per second):
  8903                                  ; see each routine for information on the use.			:
  8904                                  ;								:
  8905                                  ;----------------------------------------------------------------
  8906                                  
  8907                                  ; convert time to ticks
  8908                                  ; input : time in cx and dx
  8909                                  ; ticks returned in cx:dx
  8910                                  
  8911                                  ;19/07/2019
  8912                                  ;09/03/2019
  8913                                  
  8914                                  time_to_ticks:				; 0070h:2906h =	02C7h:0396h
  8915                                  
  8916                                  ; first convert from hour,min,sec,hund. to
  8917                                  ; total number of 100th of seconds
  8918                                  
  8919 0000038B B03C                    		mov	al, 60
  8920 0000038D F6E5                    		mul	ch		; hours	to minutes
  8921 0000038F B500                    		mov	ch, 0
  8922 00000391 01C8                    		add	ax, cx		; total	minutes
  8923 00000393 B97017                  		mov	cx, 6000	; 60*100
  8924 00000396 89D3                    		mov	bx, dx		; get out of the way of	the multiply
  8925 00000398 F7E1                    		mul	cx		; convert to 1/100 sec
  8926 0000039A 89C1                    		mov	cx, ax
  8927 0000039C B064                    		mov	al, 100
  8928 0000039E F6E7                    		mul	bh		; convert seconds to 1/100 sec
  8929 000003A0 01C1                    		add	cx, ax		; combine seconds with hours and min
  8930 000003A2 83D200                  		adc	dx, 0		; ripple carry
  8931 000003A5 B700                    		mov	bh, 0
  8932 000003A7 01D9                    		add	cx, bx		; combine 1/100	sec
  8933 000003A9 83D200                  		adc	dx, 0
  8934                                  
  8935                                  	; dx:cx is time in 1/100 sec
  8936                                  
  8937 000003AC 92                      		xchg	ax, dx
  8938 000003AD 91                      		xchg	ax, cx		; now time is in cx:ax
  8939 000003AE BB0BE9                  		mov	bx, 59659
  8940 000003B1 F7E3                    		mul	bx		; multiply low half
  8941 000003B3 87D1                    		xchg	dx, cx
  8942 000003B5 92                      		xchg	ax, dx		; cx->ax, ax->dx, dx->cx
  8943 000003B6 F7E3                    		mul	bx		; multiply high	half
  8944 000003B8 01C8                    		add	ax, cx		; combine overlapping products
  8945 000003BA 83D200                  		adc	dx, 0
  8946 000003BD 92                      		xchg	ax, dx		; ax:dx=time*59659
  8947 000003BE BB0500                  		mov	bx, 5
  8948 000003C1 F6F3                    		div	bl		; divide high half by 5
  8949 000003C3 88C1                    		mov	cl, al
  8950 000003C5 B500                    		mov	ch, 0
  8951 000003C7 88E0                    		mov	al, ah		; remainder of divide-by-5
  8952 000003C9 98                      		cbw
  8953 000003CA 92                      		xchg	ax, dx		; use it to extend low half
  8954 000003CB F7F3                    		div	bx		; divide low half by 5
  8955 000003CD 89C2                    		mov	dx, ax		; cx:dx	is now number of ticks in time
  8956 000003CF CB                      		retf			; far return
  8957                                  
  8958                                  ; ---------------------------------------------------------------------------
  8959                                  
  8960                                  ; 17/10/2022
  8961                                  ; 15/10/2022
  8962                                  
  8963                                  ;--------------------------------------------------------------------
  8964                                  ;
  8965                                  ; tim_writ sets the current time
  8966                                  ;
  8967                                  ; on entry es:[di] has the current time:
  8968                                  ;
  8969                                  ;	number of days since 1-1-80	(word)
  8970                                  ;	minutes (0-59)			(byte)
  8971                                  ;	hours (0-23)			(byte)
  8972                                  ;	hundredths of seconds (0-99)	(byte)
  8973                                  ;	seconds (0-59)			(byte)
  8974                                  ;
  8975                                  ; each number has been checked for the correct range.
  8976                                  ;
  8977                                  ;	NOTE: Any changes in this routine probably require corresponding
  8978                                  ;	changes in the version that is built with the power manager driver.
  8979                                  ;	See ptime.asm.
  8980                                  ;
  8981                                  ;--------------------------------------------------------------------
  8982                                  
  8983                                  tim_writ:				; 2C7h:3DBh = 70h:294Bh
  8984 000003D0 268B05                  		mov	ax, [es:di]
  8985 000003D3 50                      		push	ax		; daycnt. we need to set this at the very
  8986                                  					; end to avoid tick windows.
  8987 000003D4 803E[F304]00            		cmp	byte [havecmosclock], 0
  8988                                  		;cmp	ds:havecmosclock, 0
  8989 000003D9 7426                    		jz	short no_cmos_1
  8990 000003DB 268A4503                		mov	al, [es:di+3]	; near indirect	calls
  8991                                  					; get binary hours
  8992                                  					; convert to bcd
  8993 000003DF FF1E[0205]              		call	far [bintobcd]
  8994                                  		;call	ds:bintobcd	; call far [bintobcd]
  8995 000003E3 88C5                    		mov	ch, al		; ch = bcd hours
  8996 000003E5 268A4502                		mov	al, [es:di+2]	; get binary minutes
  8997 000003E9 FF1E[0205]              		call	far [bintobcd]
  8998                                  		;call	ds:bintobcd	; convert to bcd
  8999 000003ED 88C1                    		mov	cl, al		; cl = bcd minutes
  9000 000003EF 268A4505                		mov	al, [es:di+5]	; get binary seconds
  9001 000003F3 FF1E[0205]              		call	far [bintobcd]
  9002                                  		;call	ds:bintobcd
  9003 000003F7 88C6                    		mov	dh, al		; dh = bcd seconds
  9004 000003F9 B200                    		mov	dl, 0		; dl = 0 (st) or 1 (dst)
  9005 000003FB FA                      		cli
  9006 000003FC B403                    		mov	ah, 3
  9007 000003FE CD1A                    		int	1Ah		; CLOCK	- SET REAL TIME	CLOCK (AT,XT286,CONV,PS)
  9008                                  					; CH = hours in	BCD, CL	= minutes in BCD
  9009                                  					;  DH =	seconds	in BCD,DL = 01h	if daylight savings, 00h if standard time
  9010                                  					; Return: CMOS clock set
  9011 00000400 FB                      		sti
  9012                                  no_cmos_1:				
  9013 00000401 268B4D02                		mov	cx, [es:di+2]
  9014 00000405 268B5504                		mov	dx, [es:di+4]
  9015                                  		; 17/10/2022
  9016 00000409 FF1E[E206]              		call	far [ttticks]
  9017                                  		;call	dword ptr ds:ttticks ; call far	[ttticks]
  9018                                  					; convert time to ticks
  9019                                  					; cx:dx	now has	time in	ticks
  9020 0000040D FA                      		cli			; turn off timer
  9021 0000040E B401                    		mov	ah, 1
  9022 00000410 CD1A                    		int	1Ah		; CLOCK	- SET TIME OF DAY
  9023                                  					; CX:DX	= clock	count
  9024                                  					; Return: time of day set
  9025                                  		;pop	ds:daycnt
  9026 00000412 8F06[F004]              		pop	word [daycnt]
  9027 00000416 FB                      		sti
  9028                                  		;cmp	ds:havecmosclock, 0
  9029 00000417 803E[F304]00            		cmp	byte [havecmosclock], 0
  9030 0000041C 740A                    		jz	short no_cmos_2
  9031 0000041E FF1E[0605]              		call	far [daycnttoday]
  9032                                  		;call	ds:daycnttoday	; call far [daycnttoday]
  9033                                  					; convert to bcd format
  9034 00000422 FA                      		cli
  9035 00000423 B405                    		mov	ah, 5
  9036 00000425 CD1A                    		int	1Ah		; CLOCK	- SET DATE IN REAL TIME	CLOCK (AT,XT286,CONV,PS)
  9037                                  					; DL = day in BCD, DH =	month in BCD, CL = year	in BCD
  9038                                  					; CH = century (19h or 20h)
  9039                                  					; Return: CMOS clock set
  9040 00000427 FB                      		sti
  9041                                  no_cmos_2:
  9042                                  		; 12/12/2022
  9043                                  		; cf=0				
  9044                                  		;clc
  9045 00000428 C3                      		retn
  9046                                  
  9047                                  ; ---------------------------------------------------------------------------
  9048                                  
  9049                                  ; 15/10/2022
  9050                                  
  9051                                  ;----------------------------------------------------------------------------
  9052                                  ; gettime reads date and time
  9053                                  ; and returns the following information:
  9054                                  ;
  9055                                  ;	es:[di]  =count of days since 1-1-80
  9056                                  ;	es:[di+2]=hours
  9057                                  ;	es:[di+3]=minutes
  9058                                  ;	es:[di+4]=seconds
  9059                                  ;	es:[di+5]=hundredths of seconds
  9060                                  ;
  9061                                  ;	NOTE:  Any changes in this routine probably require corresponding
  9062                                  ;	changes in the version that is built with the power manager driver.
  9063                                  ;	See ptime.asm.
  9064                                  ;----------------------------------------------------------------------------
  9065                                  
  9066                                  tim_read:				; 2C7h:435h = 70h:29A5h
  9067 00000429 E84E00                  		call	GetTickCnt
  9068 0000042C 8B36[F004]              		mov	si, [daycnt]
  9069                                  
  9070                                  ; we now need to convert the time in tick to the time in 100th of
  9071                                  ; seconds. the relation between tick and seconds is:
  9072                                  ;
  9073                                  ;		 65,536 seconds
  9074                                  ;	       ----------------
  9075                                  ;		1,193,180 tick
  9076                                  ;
  9077                                  ; to get to 100th of second we need to multiply by 100. the equation is:
  9078                                  ;
  9079                                  ;	ticks from clock  * 65,536 * 100
  9080                                  ;      --------------------------------- = time in 100th of seconds
  9081                                  ;		1,193,180
  9082                                  ;
  9083                                  ; fortunately this formula simplifies to:
  9084                                  ;
  9085                                  ;	ticks from clock * 5 * 65,536
  9086                                  ;      --------------------------------- = time in 100th of seconds
  9087                                  ;		59,659
  9088                                  ;
  9089                                  ; the calculation is done by first multipling tick by 5. next we divide by
  9090                                  ; 59,659. in this division we multiply by 65,536 by shifting the dividend
  9091                                  ; my 16 bits to the left.
  9092                                  ;
  9093                                  ; start with ticks in cx:dx
  9094                                  ; multiply by 5
  9095                                  
  9096 00000430 89C8                    		mov	ax, cx
  9097 00000432 89D3                    		mov	bx, dx		; start	with ticks in cx:dx
  9098                                  					; multiply by 5
  9099 00000434 D1E2                    		shl	dx, 1
  9100 00000436 D1D1                    		rcl	cx, 1		; times	2
  9101 00000438 D1E2                    		shl	dx, 1
  9102 0000043A D1D1                    		rcl	cx, 1		; times	4
  9103 0000043C 01DA                    		add	dx, bx
  9104 0000043E 11C8                    		adc	ax, cx		; times	5
  9105 00000440 92                      		xchg	ax, dx
  9106                                  
  9107                                  ; now have ticks * 5 in	dx:ax
  9108                                  ; we now need to multiply by 65536 and divide by 59659 d.
  9109                                  
  9110 00000441 B90BE9                  		mov	cx, 59659	; get divisor
  9111 00000444 F7F1                    		div	cx		; dx now has remainder
  9112                                  					; ax has high word of final quotient
  9113 00000446 89C3                    		mov	bx, ax		; put high word	in safe	place
  9114 00000448 31C0                    		xor	ax, ax		; this is the multiply by 65536
  9115 0000044A F7F1                    		div	cx		; bx:ax	now has	time in	100th of seconds
  9116                                  
  9117                                  ; rounding based on the	remainder may be added here
  9118                                  ; the result in	bx:ax is time in 1/100 second.
  9119                                  
  9120 0000044C 89DA                    		mov	dx, bx		
  9121 0000044E B9C800                  		mov	cx, 200		;extract 1/100's
  9122                                  
  9123                                  ; division by 200 is necessary to ensure no overflow--max result
  9124                                  ; is number of seconds in a day/2 = 43200.
  9125                                  
  9126 00000451 F7F1                    		div	cx
  9127 00000453 80FA64                  		cmp	dl, 100		; remainder over 100?
  9128 00000456 7203                    		jb	short noadj
  9129 00000458 80EA64                  		sub	dl, 100		; keep 1/100's less than 100
  9130                                  noadj:					
  9131 0000045B F5                      		cmc			; if we	subtracted 100,	carry is now set
  9132 0000045C 88D3                    		mov	bl, dl		; save 1/100's
  9133                                  
  9134                                  ; to compensate	for dividing by	200 instead of 100, we now multiply
  9135                                  ; by two, shifting a one in if the remainder had exceeded 100.
  9136                                  
  9137 0000045E D1D0                    		rcl	ax, 1		
  9138 00000460 B200                    		mov	dl, 0
  9139 00000462 D1D2                    		rcl	dx, 1
  9140 00000464 B93C00                  		mov	cx, 60		; divide out seconds
  9141 00000467 F7F1                    		div	cx
  9142 00000469 88D7                    		mov	bh, dl		; save the seconds
  9143 0000046B F6F1                    		div	cl		; break	into hours and minutes
  9144 0000046D 86C4                    		xchg	al, ah
  9145                                  
  9146                                  ; time is now in ax:bx (hours, minutes, seconds, 1/100 sec)
  9147                                  
  9148 0000046F 50                      		push	ax
  9149 00000470 89F0                    		mov	ax, si		; daycnt
  9150 00000472 AB                      		stosw
  9151 00000473 58                      		pop	ax
  9152 00000474 AB                      		stosw
  9153 00000475 89D8                    		mov	ax, bx
  9154 00000477 AB                      		stosw
  9155 00000478 F8                      		clc
  9156 00000479 C3                      		retn
  9157                                  
  9158                                  ; =============== S U B	R O U T	I N E =======================================
  9159                                  
  9160                                  ; 15/10/2022
  9161                                  
  9162                                  ;----------------------------------------------------------------------------
  9163                                  ;
  9164                                  ; procedure : GetTickCnt
  9165                                  ;
  9166                                  ;		Returns the tick count in CX:DX. Takes care of DayCnt in case
  9167                                  ;		of rollover [except when power management driver is in use]. 
  9168                                  ;		Uses the following logic for updating Daycnt
  9169                                  ;
  9170                                  ;		if ( rollover ) {
  9171                                  ;			if ( t_switch )
  9172                                  ;				daycnt++ ;
  9173                                  ;			else
  9174                                  ;				daycnt += rollover ;
  9175                                  ;		}
  9176                                  ;
  9177                                  ; USES : AX
  9178                                  ;
  9179                                  ; RETURNS : CX:DX - tick count
  9180                                  ; MODIFIES : daycnt
  9181                                  ;
  9182                                  ;----------------------------------------------------------------------------
  9183                                  
  9184                                  		; 17/10/2022
  9185                                  GetTickCnt:	
  9186 0000047A 30E4                    		xor	ah, ah
  9187 0000047C CD1A                    		int	1Ah		; CLOCK	- GET TIME OF DAY
  9188                                  					; Return: CX:DX	= clock	count
  9189                                  					; AL = 00h if clock was	read or	written	(via AH=0,1) since the previous
  9190                                  					; midnight
  9191                                  					; Otherwise, AL	> 0
  9192 0000047E 803E[F204]00            		cmp	byte [t_switch], 0 ; use old method ? (>0 is yes)
  9193 00000483 7507                    		jnz	short inc_case	; old method assumes  that Int 1Ah returns rollover flag
  9194 00000485 30E4                    		xor	ah, ah		; new method assumes that Int 1Ah returns roll over count
  9195                                  					; and not flag
  9196 00000487 0106[F004]              		add	[daycnt], ax
  9197 0000048B C3                      		retn
  9198                                  ; ---------------------------------------------------------------------------
  9199                                  
  9200                                  inc_case:				
  9201 0000048C 08C0                    		or	al, al
  9202 0000048E 7404                    		jz	short no_rollover
  9203 00000490 FF06[F004]              		inc	word [daycnt]
  9204                                  no_rollover:				
  9205 00000494 C3                      		retn
  9206                                  
  9207                                  ;----------------------------------------------------------------------------
  9208                                  ; MSDISK.ASM - MSDOS 6.0 - 1991
  9209                                  ;----------------------------------------------------------------------------
  9210                                  ; 15/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
  9211                                  ; 09/03/2019 - Retro DOS v4.0
  9212                                  
  9213                                  ; MSDISK.ASM - MSDOS 3.3 - 02/02/1988
  9214                                  ; 26/05/2018 - Retro DOS v3.0
  9215                                  ; 23/03/2018 - Retro DOS v2.0
  9216                                  
  9217                                  ;error_unknown_media equ	7	; for use in BUILD BPB call
  9218                                  
  9219                                  ;struc BPB_TYPE
  9220                                  ;.SECSIZE:	resw 1
  9221                                  ;.SECALL:	resb 1
  9222                                  ;.RESNUM:	resw 1
  9223                                  ;.FATNUM:	resb 1
  9224                                  ;.DIRNUM:	resw 1
  9225                                  ;.SECNUM:	resw 1
  9226                                  ;.FATID:	resb 1
  9227                                  ;.FATSIZE:	resw 1
  9228                                  ;.SLIM:		resw 1
  9229                                  ;.HLIM:		resw 1
  9230                                  ;.HIDDEN:	resw 1
  9231                                  ;.size:
  9232                                  ;endstruc
  9233                                  
  9234                                  ;-----------------------------------------------------------------
  9235                                  ;	disk interface routines
  9236                                  ;-----------------------------------------------------------------
  9237                                  
  9238                                  ; device attribute bits:
  9239                                  ;	bit 6 - get/set map for logical drives and generic ioctl.
  9240                                  
  9241                                  ;MAXERR		equ	5
  9242                                  ;MAX_HD_FMT_ERR	equ	2
  9243                                  
  9244                                  ;LSTDRV	equ 504h
  9245                                  
  9246                                  ; some floppies do not have changeline. as a result, media-check would
  9247                                  ; normally return i-don't-know, the dos would continually reread the fat and
  9248                                  ; discard cached data. we optimize this by implementing a logical door-latch:
  9249                                  ; it is physically impossible to change a disk in under 2 seconds. we retain
  9250                                  ; the time of the last successful disk operation and compare it with the current
  9251                                  ; time during media-check. if < 2 seconds and at least 1 timer tick has passed,
  9252                                  ; the we say no change. if > 2 seconds then we say i-don't-know. finally, 
  9253                                  ; since we cannot trust the timer to be always available, we record the number 
  9254                                  ; of media checks that have occurred when no apparent time has elapsed. while
  9255                                  ; this number is < a given threshold, we say no change. when it exceeds that
  9256                                  ; threshold, we say i-don't-know and reset the counter to 0. when we store 
  9257                                  ; the time of last successful access, if we see that time has passed too,
  9258                                  ; we reset the counter.
  9259                                  
  9260                                  accessmax	equ	5
  9261                                  
  9262                                  ; due to various bogosities, we need to continually adjust what the head
  9263                                  ; settle time is.  the following algorithm is used:
  9264                                  ;
  9265                                  ;   get the current head settle value.
  9266                                  ;   if it is 0, then
  9267                                  ;	set slow = 15
  9268                                  ;   else
  9269                                  ;	set slow = value
  9270                                  ;   ...
  9271                                  ;*********************************************
  9272                                  ;************ old algorithm ******************
  9273                                  ;*   if we are seeking and writing then
  9274                                  ;*	 use slow
  9275                                  ;*   else
  9276                                  ;*	 use fast
  9277                                  ;*********************************************
  9278                                  ;*********** ibm's requested logic ***********
  9279                                  ;   if we are seeking and writing and not on an at then
  9280                                  ;	use slow
  9281                                  ;   else
  9282                                  ;	use fast
  9283                                  ;   ...
  9284                                  ;   restore current head settle value
  9285                                  ;
  9286                                  ;
  9287                                  ;---------------------------------------
  9288                                  multrk_on	equ	10000000b	;user spcified mutitrack=on, or system turns
  9289                                  					; it on after handling config.sys file as a
  9290                                  					; default value, if multrk_flag = multrk_off1.
  9291                                  multrk_off1	equ	00000000b	;initial value. no "multitrack=" command entered.
  9292                                  multrk_off2	equ	00000001b	;user specified multitrack=off.
  9293                                  
  9294                                  ; close data segment, open Bios_Code segment
  9295                                  
  9296                                  ; 15/10/2022
  9297                                  
  9298                                  ; BIOSCODE:04A2h (MSDOS 6.21, IO.SYS)
  9299                                  
  9300                                  ;-----------------------------------------------------------------
  9301                                  ;	command jump table
  9302                                  ;-----------------------------------------------------------------
  9303                                  
  9304 00000495 00                      		db 0
  9305                                  
  9306                                  ; 11/12/2022
  9307                                  %if 0
  9308                                  
  9309                                  dsktbl:		db 26			; 2C7h:4A2h = 70h:2A12h
  9310                                  					; ((dtbl_siz-1)/2) ; this is the size of the table ; 26
  9311                                  		dw 1742h		; dsk_init
  9312                                  		dw 4EBh			; media_chk
  9313                                  		dw 592h			; get_bpb
  9314                                  		dw 0D5h			; bc_cmderr
  9315                                  		dw 857h			; dsk_read
  9316                                  		dw 83Dh			; x_bus_exit
  9317                                  		dw 558h			; ret_carry_clear
  9318                                  		dw 558h			; ret_carry_clear
  9319                                  		dw 849h			; dsk_writ
  9320                                  		dw 841h			; dsk_writv
  9321                                  		dw 558h			; ret_carry_clear
  9322                                  		dw 558h			; ret_carry_clear
  9323                                  		dw 0D5h			; bc_cmderr
  9324                                  		dw 80Ah			; dsk_open
  9325                                  		dw 81Ah			; dsk_close
  9326                                  		dw 831h			; dsk_rem
  9327                                  		dw 558h			; ret_carry_clear
  9328                                  		dw 558h			; ret_carry_clear
  9329                                  		dw 558h			; ret_carry_clear
  9330                                  		dw 0C6Bh		; do_generic_ioctl
  9331                                  		dw 558h			; ret_carry_clear
  9332                                  		dw 558h			; ret_carry_clear
  9333                                  		dw 558h			; ret_carry_clear
  9334                                  		dw 1124h		; ioctl_getown
  9335                                  		dw 1142h		; ioctl_setown
  9336                                  		dw 129Ah		; ioctl_support_query
  9337                                  
  9338                                  ;dtbl_siz equ $-dsktbl
  9339                                  
  9340                                  %endif
  9341                                  		; 11/12/2022
  9342 00000496 1A                      dsktbl:		db (dtbl_siz-1)/2	; 26 ; this is the size of the table
  9343 00000497 [E916]                  		dw dsk_init
  9344 00000499 [DF04]                  		dw media_chk
  9345 0000049B [8505]                  		dw get_bpb
  9346 0000049D [D500]                  		dw bc_cmderr
  9347 0000049F [3708]                  		dw dsk_read
  9348 000004A1 [1D08]                  		dw x_bus_exit
  9349 000004A3 [4B05]                  		dw ret_carry_clear
  9350 000004A5 [4B05]                  		dw ret_carry_clear
  9351 000004A7 [2908]                  		dw dsk_writ
  9352 000004A9 [2108]                  		dw dsk_writv
  9353 000004AB [4B05]                  		dw ret_carry_clear
  9354 000004AD [4B05]                  		dw ret_carry_clear
  9355 000004AF [D500]                  		dw bc_cmderr
  9356 000004B1 [ED07]                  		dw dsk_open
  9357 000004B3 [FC07]                  		dw dsk_close
  9358 000004B5 [1208]                  		dw dsk_rem
  9359 000004B7 [4B05]                  		dw ret_carry_clear
  9360 000004B9 [4B05]                  		dw ret_carry_clear
  9361 000004BB [4B05]                  		dw ret_carry_clear
  9362 000004BD [460C]                  		dw do_generic_ioctl
  9363 000004BF [4B05]                  		dw ret_carry_clear
  9364 000004C1 [4B05]                  		dw ret_carry_clear
  9365 000004C3 [4B05]                  		dw ret_carry_clear
  9366 000004C5 [EC10]                  		dw ioctl_getown
  9367 000004C7 [0911]                  		dw ioctl_setown
  9368 000004C9 [5812]                  		dw ioctl_support_query
  9369                                  
  9370                                  dtbl_siz equ $-dsktbl
  9371                                  
  9372                                  ; =============== S U B	R O U T	I N E =======================================
  9373                                  
  9374                                  ; ---------------------------------------------------------------------------
  9375                                  ; setdrive scans through the data structure of bdss, and returns a pointer to
  9376                                  ; the one that belongs to the drive specified. carry is set if none exists
  9377                                  ; for the drive. Pointer is returned in es:[di]
  9378                                  ;
  9379                                  ;  AL contains the logical drive number.
  9380                                  ; ---------------------------------------------------------------------------
  9381                                  
  9382                                  SetDrive:	
  9383                                  		;les	di, ds:start_bds ; Point es:di to first bds	
  9384 000004CB C43E[1901]              		les	di, [start_bds] ; 19/10/2022
  9385                                  X_Scan_Loop:				
  9386 000004CF 26384505                		cmp	[es:di+5], al	
  9387 000004D3 7409                    		jz	short X_SetDrv
  9388 000004D5 26C43D                  		les	di, [es:di]	; [es:di+BDS.link] ; Go	to next	bds
  9389 000004D8 83FFFF                  		cmp	di, 0FFFFh
  9390 000004DB 75F2                    		jnz	short X_Scan_Loop
  9391 000004DD F9                      		stc
  9392                                  X_SetDrv:				
  9393 000004DE C3                      		retn
  9394                                  
  9395                                  ; ---------------------------------------------------------------------------
  9396                                  
  9397                                  ; 15/10/2022
  9398                                  
  9399                                  ; ---------------------------------------------------------------------
  9400                                  ; if id is f9, have a 96tpi disk else
  9401                                  ; if bit 2 is 0 then media is not removable and could not have changed
  9402                                  ;  otherwise if within 2 secs of last disk operation media could not
  9403                                  ;    have changed, otherwise dont know if media has changed
  9404                                  ; ---------------------------------------------------------------------
  9405                                  
  9406                                  media_chk:				; 2C7h:4EBh = 70h:2A5Bh
  9407 000004DF E8E9FF                  		call	SetDrive
  9408 000004E2 BE0100                  		mov	si, 1
  9409 000004E5 26F6452401              		test	byte [es:di+24h], 1 ; [es:di+BDS.flags+1]
  9410                                  					; fchanged_by_format
  9411 000004EA 7416                    		jz	short WeAreNotFakingIt
  9412                                  		; 12/12/2022
  9413 000004EC 26806524FE              		and	byte [es:di+24h], 0FEh ; ~fchanged_by_format
  9414                                  		;and	word [es:di+23h], 0FEFFh ; [es:di+BDS.flags]
  9415                                  					; ~fchanged_by_format ;	reset flag
  9416 000004F1 C606[1E01]FF            		mov	byte [tim_drv], 0FFh ; -1
  9417                                  					; Ensure that we ask the rom if media has changed
  9418 000004F6 26F6452301              		test	byte [es:di+23h], 1 ; [es:di+BDS.flags]
  9419                                  					; fnon_removable
  9420 000004FB 740C                    		jz	short wehaveafloppy
  9421 000004FD BEFFFF                  		mov	si, 0FFFFh	; Indicate media changed
  9422 00000500 EB2C                    		jmp	short Media_Done ; Media_Done
  9423                                  ; ---------------------------------------------------------------------------
  9424                                  
  9425                                  WeAreNotFakingIt:
  9426                                  		;test	byte [es:di+BDS.flags], fnon_removable			
  9427 00000502 26F6452301              		test	byte [es:di+23h], 1
  9428 00000507 7525                    		jnz	short Media_Done
  9429                                  wehaveafloppy:				
  9430 00000509 31F6                    		xor	si, si		; Presume "I don't know"
  9431                                  
  9432                                  		; If we have a floppy with changeline support, we ask the ROM
  9433                                  		; to determine if media has changed. We do not perform the
  9434                                  		; 2 second check for these drives.
  9435                                  
  9436 0000050B 803E[7700]00            		cmp	byte [fhave96], 0	; Do we	have changeline	support?
  9437 00000510 740A                    		jz	short mChk_NoChangeLine	; Brif not
  9438 00000512 E89F12                  		call	mediacheck	;  Call	into removable routine
  9439 00000515 7236                    		jb	short err_exitj
  9440 00000517 E8F713                  		call	haschange
  9441 0000051A 7512                    		jnz	short Media_Done
  9442                                  mChk_NoChangeLine:
  9443                                  		; If we come here, we have a floppy with no changeline support
  9444                                  			
  9445 0000051C BE0100                  		mov	si, 1		; Presume no change
  9446 0000051F A0[1E01]                		mov	al, [tim_drv]	; Last drive accessed
  9447 00000522 263A4504                		cmp	al, [es:di+4]	; [es:di+BDS.drivenum]
  9448                                  					; Is drive of last access the same?
  9449 00000526 7505                    		jnz	short Media_Unk	; No, then "i don't know"
  9450 00000528 E82800                  		call	Check_Time_Of_Access
  9451 0000052B EB01                    		jmp	short Media_Done
  9452                                  ; ---------------------------------------------------------------------------
  9453                                  
  9454                                  Media_Unk:				
  9455 0000052D 4E                      		dec	si		; ; Return "I don't know"
  9456                                  
  9457                                  		; SI now contains the correct value for media change.
  9458                                  		; Clean up the left overs
  9459                                  Media_Done:	
  9460                                  		; 19/10/2022			
  9461 0000052E 06                      		push	es
  9462 0000052F C41E[1200]              		les	bx, [ptrsav]
  9463 00000533 2689770E                		mov	[es:bx+0Eh], si	; [es:bx+trans]
  9464 00000537 07                      		pop	es
  9465 00000538 09F6                    		or	si, si
  9466 0000053A 790F                    		jns	short ret_carry_clear ;	volidok
  9467 0000053C 803E[7700]00            		cmp	byte [fhave96], 0
  9468 00000541 7403                    		jz	short mChk1_NoChangeLine ; Brif	no changeline support
  9469 00000543 E85713                  		call	media_set_vid
  9470                                  mChk1_NoChangeLine:			
  9471 00000546 C606[1E01]FF            		mov	byte [tim_drv], 0FFh ; -1
  9472                                  					; Make sure we ask rom for media check
  9473                                  ret_carry_clear:			
  9474 0000054B F8                      		clc			; volidok
  9475 0000054C C3                      		retn
  9476                                  ; ---------------------------------------------------------------------------
  9477                                  
  9478                                  err_exitj:				
  9479 0000054D E88106                  		call	maperror	; guaranteed to	set carry
  9480                                  ret81:					
  9481 00000550 B481                    		mov	ah, 81h		; return error status
  9482 00000552 C3                      		retn			; return with carry set
  9483                                  
  9484                                  ; =============== S U B	R O U T	I N E =======================================
  9485                                  
  9486                                  ; ---------------------------------------------------------------------------
  9487                                  ; perform a check on the time passed since the last access for this physical
  9488                                  ; drive.
  9489                                  ; we are accessing the same drive. if the time of last successful access was
  9490                                  ; less than 2 seconds ago, then we may presume that the disk was not changed.
  9491                                  ; returns in si:
  9492                                  ;	0 - if time of last access was >= 2 seconds
  9493                                  ;	1 - if time was < 2 seconds (i.e no media change assumed)
  9494                                  ; registers affected ax,cx,dx, flags.
  9495                                  ;
  9496                                  ;	assume es:di -> bds, ds->Bios_Data
  9497                                  ; ---------------------------------------------------------------------------
  9498                                  
  9499                                  		; 19/10/2022
  9500                                  Check_Time_Of_Access:
  9501 00000553 BE0100                  		mov	si, 1		; presume no change.
  9502 00000556 E821FF                  		call	GetTickCnt	; cx:dx	is the elapsed time
  9503 00000559 268B4547                		mov	ax, [es:di+47h]	; [es:di+BDS.tim_lo]
  9504                                  					; get stored time
  9505 0000055D 29C2                    		sub	dx, ax
  9506 0000055F 268B4549                		mov	ax, [es:di+49h]	; [es:di+BDS.tim_hi]
  9507 00000563 19C1                    		sbb	cx, ax
  9508 00000565 751A                    		jnz	short timecheck_unk ; cx<>0 => >1 hour
  9509 00000567 09D2                    		or	dx, dx		; time must pass
  9510 00000569 7511                    		jnz	short timepassed ; yes, examine max value
  9511 0000056B FE06[1D01]              		inc	byte [accesscount]
  9512 0000056F 803E[1D01]05            		cmp	byte [accesscount], 5 
  9513                                  					; if count is less than threshold, ok
  9514 00000574 720C                    		jb	short timecheck_ret
  9515 00000576 FE0E[1D01]              		dec	byte [accesscount] ; don't let the count wrap
  9516 0000057A EB05                    		jmp	short timecheck_unk ; "i don't know" if media changed
  9517                                  ; ---------------------------------------------------------------------------
  9518                                  
  9519                                  timepassed:				
  9520 0000057C 83FA24                  		cmp	dx, 36		; 18*2 ; 18.2 tics per second.
  9521                                  					; min elapsed time? (2 seconds)
  9522 0000057F 7601                    		jbe	short timecheck_ret ; yes, presume no change
  9523                                  
  9524                                  		; everything indicates that we do not know what has happened.
  9525                                  timecheck_unk:				
  9526 00000581 4E                      		dec	si		; presume i don't know
  9527                                  timecheck_ret:				
  9528 00000582 C3                      		retn
  9529                                  
  9530                                  ; ---------------------------------------------------------------------------
  9531                                  ; 15/10/2022
  9532                                  Err_Exitj2:
  9533 00000583 EBC8                    		jmp	short err_exitj
  9534                                  
  9535                                  ; ---------------------------------------------------------------------------
  9536                                  
  9537                                  ; 15/10/2022
  9538                                  
  9539                                  ; ==========================================================================
  9540                                  ; Build a valid bpb for the disk in the drive.
  9541                                  ; ==========================================================================
  9542                                  
  9543                                  		; 19/10/2022
  9544                                  get_bpb:				; 2C7h:592h = 70h:2B02h
  9545 00000585 268A25                  		mov	ah, [es:di]	; get fat id byte read by dos
  9546 00000588 E840FF                  		call	SetDrive	; get the correct bds for the drive
  9547 0000058B 26F6452301              		test	byte [es:di+23h], 1 ; [es:di+BDS.flags]
  9548                                  					; fnon_removable
  9549 00000590 7523                    		jnz	short already_gotbpb ; no need to build	for fixed disks
  9550                                  
  9551                                  		; let's set the default value for volid,vol_serial,
  9552                                  		; filesys_id in bds table
  9553                                  
  9554 00000592 E83700                  		call	clear_ids
  9555                                  		;mov	ds:set_id_flag,	1 ; indicate to	set system id in bds
  9556 00000595 C606[0A05]01            		mov	byte [set_id_flag], 1
  9557 0000059A E85B00                  		call	GetBp		; build	a bpb if necessary
  9558 0000059D 72B1                    		jb	short ret81
  9559                                  		;cmp	ds:set_id_flag,	2 ; already, volume_label set from boot
  9560 0000059F 803E[0A05]02            		cmp	byte [set_id_flag], 2
  9561                                  		;mov	ds:set_id_flag,	0 ; record to bds table?
  9562 000005A4 C606[0A05]00            		mov	byte [set_id_flag], 0
  9563 000005A9 740A                    		jz	short already_gotbpb ; do not set it again from	root dir
  9564                                  					; otherwise, conventional boot record
  9565                                  		;cmp	ds:fhave96, 0	; do we	have changeline	support?
  9566 000005AB 803E[7700]00            		cmp	byte [fhave96], 0
  9567 000005B0 7403                    		jz	short already_gotbpb ; brif not
  9568 000005B2 E86213                  		call	set_volume_id
  9569                                  already_gotbpb:				
  9570 000005B5 83C706                  		add	di, 6		; BDS.BPB
  9571                                  					; return the bpb from the current bds
  9572                                  
  9573                                  ;		 fall into setptrsav, es:di -> result
  9574                                  
  9575                                  ; ---------------------------------------------------------------------------
  9576                                  
  9577                                  ; 15/10/2022
  9578                                  
  9579                                  ; ==========================================================================
  9580                                  ;Setptrsav is also jumped to from dsk_init (msbio2.asm). In both cases, the
  9581                                  ;pointer to be returned is in es:di. We were incorrectly returning ds:di.
  9582                                  ;Note that this works in most cases because most pointers are in Bios_Data.
  9583                                  ;It fails, for instance, when we install an external drive using driver.sys
  9584                                  ;because then the BDS segment is no longer Bios_Data. 
  9585                                  ;NB: It is fine to corrupt cx because this is not a return value and anyway
  9586                                  ;this returns to Chardev_entry (msbio1.asm) where all registers are 
  9587                                  ;restored before returning to the caller.
  9588                                  ; ==========================================================================
  9589                                  
  9590                                  		; 19/10/2022
  9591                                  SetPtrSav:	; return point for dsk_init				
  9592 000005B8 8CC1                    		mov	cx, es		; save es
  9593                                  		;les	bx, ds:ptrsav
  9594 000005BA C41E[1200]              		les	bx, [ptrsav]
  9595 000005BE 2688670D                		mov	[es:bx+0Dh], ah	; [es:bx+media]
  9596 000005C2 26897F12                		mov	[es:bx+12h], di	; [es:bx+count]
  9597 000005C6 26894F14                		mov	[es:bx+14h], cx	; [es:bx+count+2]
  9598 000005CA F8                      		clc
  9599 000005CB C3                      		retn
  9600                                  
  9601                                  ; =============== S U B	R O U T	I N E =======================================
  9602                                  
  9603                                  ; 15/10/2022
  9604                                  
  9605                                  ; -----------------------------------------------------
  9606                                  ; clear ids in bds table. only applied for floppies.
  9607                                  ;input:  es:di -> bds table
  9608                                  ;	assumes ds: -> Bios_Data
  9609                                  ;output: volid set to "NO NAME    "
  9610                                  ;	 vol_serial set to 0.
  9611                                  ;	 filesys_id set to "FAT12   " or "FAT16   "
  9612                                  ;	   depending on the flag fatsize in bds.
  9613                                  ;
  9614                                  ;	trashes si, cx
  9615                                  ; -----------------------------------------------------
  9616                                  
  9617                                  ;size_of_EXT_BOOT_VOL_LABEL equ 11
  9618                                  ;size_of_EXT_SYSTEM_ID equ 8
  9619                                  
  9620                                  clear_ids:
  9621                                  		; 11/09/2023 - Retro DOS v4.1 IO.SYS (Optimization & BugFix)
  9622 000005CC 268A451F                		mov	al, [es:di+1Fh] ; mov al,[es:di+BDS.fatsiz]
  9623                                  clear_ids_x:	; 11/09/2023		
  9624                                   		; (MSDOS 5.0 IO.SYS - BIOSCODE:05D9h)
  9625 000005D0 57                      		push	di
  9626 000005D1 31C9                    		xor	cx, cx		; no serial number
  9627 000005D3 26894D57                		mov	[es:di+57h], cx	; [es:di+BDS.vol_serial]
  9628 000005D7 26894D59                		mov	[es:di+59h], cx	; [es:di+BDS.vol_serial+2]
  9629                                  
  9630                                  		; BUGBUG - there's a lot in common here and with
  9631                                  		; mov_media_ids.. see if we can save some space by
  9632                                  		; merging them... jgl
  9633                                  
  9634                                  		;mov	cx, 11		; size_of_EXT_BOOT_VOL_LABEL
  9635                                  		; 10/12/2022
  9636 000005DB B10B                    		mov	cl, 11 ; cx = 11		
  9637                                  
  9638                                  		;mov	si, offset vol_no_name ; "NO NAME    "
  9639 000005DD BE[1D05]                		mov	si, vol_no_name	; 19/10/2022
  9640 000005E0 83C74B                  		add	di, 75		; BDS.volid
  9641 000005E3 F3A4                    		rep movsb
  9642                                  		
  9643                                  		; 11/09/2023 (BugFix, DI is not start addr of BDS structure here)
  9644                                  		;;test	byte [es:di+BDS.fatsiz], fbig
  9645                                  		; (MSDOS 5.0 IO.SYS - BIOSCODE:05EFh)
  9646                                  		;test	byte [es:di+1Fh], 40h
  9647                                  
  9648                                  			; ! NOTE - 11/08/2023 - Erdogan Tan (Retro DOS v4.2 IO.SYS bugfix)
  9649                                  			; Microsoft/IBM code has a bug here because the BDS's
  9650                                  			; .volid and .filesys_id fields will be reset
  9651                                  			; (to their default text) according to 'BDS.fatsiz' flags
  9652                                  			; at the BDS offset 31 but current (this) code checks flags
  9653                                  			; at ES:DI+31 while DI points the BDS offset 86!?
  9654                                  			;
  9655                                  			; Correct Code:
  9656                                  			; ;test byte [ES:31],40h or [ES:BDS.fatsiz],fbig
  9657                                  			; 11/09/2023
  9658                                  			; (before 'rep movsb') 'mov al,[es:di+BDS.Fatsiz]' and then
  9659                                  			; (after 'rep movsb') 'test al,fbig' (AL is free/proper to use here)	
  9660                                  			;
  9661                                  			; Same BUG is existing in PCDOS 7.1 IBMBIO.COM - BIOSCODE:06C3h
  9662                                  			; and in Windows ME IO.SYS - BIOSCODE:0E1Ah as 'test byte [es:di+59],20h'
  9663                                  			; (PCDOS 7.1 BUG note: 26/06/2023)
  9664                                  			;
  9665                                  			; (Why this bug did not affect MSDOS and PCDOS 7.x applications:
  9666                                  			; 'clear_ids' is used for floppy disks only and the default
  9667                                  			; option of 'clear_ids' is FAT12 volid and filesys_id text
  9668                                  			; when the flag bit has wrong value for FAT16/40h or FAT32/20h.)
  9669                                  
  9670 000005E5 A840                    		test	al, 40h ; * 
  9671                                  		
  9672                                  		;mov	si, offset fat_16_id ; "FAT16	"
  9673 000005E7 BE[1405]                		mov	si, fat_16_id	; 19/10/2022
  9674 000005EA 7503                    		jnz	short ci_bigfat
  9675                                  		;mov	si, offset fat_12_id ; "FAT12	"
  9676 000005EC BE[0B05]                		mov	si, fat_12_id	 ; 19/10/2022
  9677                                  ci_bigfat:				
  9678                                  		;mov	cx, 8		; size_of_EXT_SYSTEM_ID
  9679                                  		; 10/12/2022
  9680 000005EF B108                    		mov	cl, 8 ; cx = 8 
  9681 000005F1 83C705                  		add	di, 5		; (BDS.filesys_id-BDS.volid)-size_of_EXT_BOOT_VOL_LABEL
  9682                                  					; filesys_id field
  9683 000005F4 F3A4                    		rep movsb
  9684 000005F6 5F                      		pop	di		; restore bds pointer
  9685 000005F7 C3                      		retn
  9686                                  
  9687                                  ; =============== S U B	R O U T	I N E =======================================
  9688                                  
  9689                                  ; 15/10/2022
  9690                                  
  9691                                  ; ---------------------------------------------------------------------------
  9692                                  ;	getbp - return bpb from the drive specified by the bds.
  9693                                  ;	    if the return_fake_bpb flag is set, then it does nothing.
  9694                                  ;	    note that we never come here for fixed disks.
  9695                                  ;	    for all other cases,
  9696                                  ;	      - it reads boot sector to pull out the bpb
  9697                                  ;	      - if no valid bpb is found, it then reads the fat sector,
  9698                                  ;		to get the fat id byte to build the bpb from there.
  9699                                  ;
  9700                                  ;   inputs:	es:di point to correct bds.
  9701                                  ;
  9702                                  ;   outputs:	fills in bpb in current bds if valid bpb or fat id on disk.
  9703                                  ;		carry set, and al=7 if invalid disk.
  9704                                  ;		carry set and error code in al if other error.
  9705                                  ;		if failed to recognize the boot record, then will set the
  9706                                  ;		set_id_flag to 0.
  9707                                  ;		this routine will only work for a floppy diskette.
  9708                                  ;		     for a fixed disk, it will just return.
  9709                                  ;
  9710                                  ;	****** Note: getbp is a clone of getbp which uses the newer
  9711                                  ;	  segment definitions. It should be migrated towards.
  9712                                  ;	   now es:di has the bds, ds: has Bios_Data
  9713                                  ; ---------------------------------------------------------------------------
  9714                                  
  9715                                  GetBp:		; if returning fake bpb then return bpb as is.
  9716                                  		;test	byte [es:di+BDS.flags], return_fake_bpb|fnon_removable		
  9717 000005F8 26F6452305              		test	byte [es:di+23h], 5
  9718 000005FD 7403                    		jz	short getbp1	; getbp1
  9719 000005FF E99500                  		jmp	getret_exit
  9720                                  ; ---------------------------------------------------------------------------
  9721                                  
  9722                                  getbp1:					
  9723 00000602 51                      		push	cx
  9724 00000603 52                      		push	dx
  9725 00000604 53                      		push	bx
  9726                                  
  9727                                  		; attempt to read in boot sector and determine bpb.
  9728                                  		; we assume that the 2.x and greater dos disks all
  9729                                  		; have a valid boot sector.
  9730                                  
  9731 00000605 E8A400                  		call	readbootsec
  9732 00000608 7209                    		jb	short getbp_err_ret_brdg ; carry set if there was error.
  9733 0000060A 09DB                    		or	bx, bx		; bx is	0 if boot sector is valid.
  9734 0000060C 7508                    		jnz	short dofatbpb
  9735 0000060E E8F000                  		call	movbpb		; move bpb into	registers
  9736 00000611 EB57                    		jmp	short Has1
  9737                                  ; ---------------------------------------------------------------------------
  9738                                  
  9739                                  getbp_err_ret_brdg:			
  9740 00000613 E98200                  		jmp	getbp_err_ret
  9741                                  ; ---------------------------------------------------------------------------
  9742                                  
  9743                                  		; we have a 1.x diskette. In this case read in the fat ID byte
  9744                                  		; and fill in bpb from there.
  9745                                  dofatbpb:				
  9746 00000616 E85401                  		call	readfat		; puts media descriptor	byte in	ah
  9747 00000619 72F8                    		jb	short getbp_err_ret_brdg
  9748                                  		;cmp	ds:fhave96, 0	;  changeline support available?
  9749 0000061B 803E[7700]00            		cmp	byte [fhave96], 0 ; 19/10/2022
  9750 00000620 7403                    		jz	short bpb_nochangeline ; brif not
  9751 00000622 E88D12                  		call	hidensity	; may not return! May add sp, 2	and
  9752                                  					; jump to has1!!!!!! or	has720K
  9753                                  bpb_nochangeline:		; test for a valid 3.5" medium			
  9754 00000625 26807D2202              		cmp	byte [es:di+22h], 2	; [es:di+BDS.formfactor]
  9755                                  					; ffSmall
  9756 0000062A 7515                    		jnz	short is_floppy
  9757 0000062C 80FCF9                  		cmp	ah, 0F9h	; is it	a valid	fat id byte for	3.5" ?
  9758 0000062F 7571                    		jnz	short got_unknown_medium
  9759                                  Has720K:				
  9760                                  		;mov	bx, offset sm92 ; pointer to correct bpb
  9761 00000631 BB[DE04]                		mov	bx, sm92	; 19/10/2022
  9762                                  
  9763                                  		; es points to segment of bds. the following should be modified
  9764                                  		; to get spf,csec,spau,spt correctly. it had been wrong if
  9765                                  		; driver.sys is loaded since the bds is inside the driver.sys.
  9766                                  
  9767                                  		; 10/12/2022
  9768                                  		;mov	al, [bx+0]	; [bx+bpbtype.spf]
  9769                                  		; 21/12/2022
  9770 00000634 8A07                    		mov	al, [bx]
  9771 00000636 8B4F03                  		mov	cx, [bx+3]	; [bx+bpbtype.csec]
  9772 00000639 8B5705                  		mov	dx, [bx+5]	; [bx+bpbtype.spau]
  9773 0000063C 8B5F01                  		mov	bx, [bx+1]	; [bx+bpbtype.spt]
  9774                                  		; 19/10/2022 - Temporary !
  9775                                  		;db	8Ah, 87h, 0, 0	; mov al, [bx+0]
  9776                                  		;db	8Bh, 8Fh, 3, 0	; mov cx, [bx+3]
  9777                                  		;db	8Bh, 97h, 5, 0	; mov dx, [bx+5]
  9778                                  		;db	8Bh, 9Fh, 1, 0	; mov bx, [bx+1]	
  9779                                  
  9780 0000063F EB29                    		jmp	short Has1
  9781                                  ; ---------------------------------------------------------------------------
  9782                                  
  9783                                  is_floppy:			; must be a 5.25" floppy if we come here
  9784 00000641 80FCF8                  		cmp	ah, 0F8h	; valid	media??	(0F8h-0FFh)
  9785 00000644 725C                    		jb	short got_unknown_medium
  9786 00000646 B001                    		mov	al, 1		; set number of	fat sectors
  9787 00000648 BB0840                  		mov	bx, 16392	; 64*256+8
  9788                                  					; set dir entries and sector max
  9789 0000064B B94001                  		mov	cx, 320		; 40*8
  9790                                  					; set size of drive
  9791 0000064E BA0101                  		mov	dx, 257		; 01*256+1
  9792                                  					; set head limit and sec/all unit
  9793 00000651 F6C402                  		test	ah, 2		; test for 8 or	9 sector
  9794 00000654 7507                    		jnz	short has8	; nz = has 8 sectors
  9795 00000656 FEC0                    		inc	al		; inc number of	fat sectors
  9796 00000658 FEC3                    		inc	bl		; inc sector max
  9797                                  		;add	cx, 40		; increase size	(to 360)
  9798                                  		; 18/12/2022
  9799 0000065A 80C128                  		add	cl, 40
  9800                                  has8:					
  9801 0000065D F6C401                  		test	ah, 1		; test for 1 or	2 heads
  9802 00000660 7408                    		jz	short Has1	; jz = 1 head
  9803 00000662 01C9                    		add	cx, cx		; double size of disk
  9804 00000664 B770                    		mov	bh, 112		; increase number of directory entries
  9805 00000666 FEC6                    		inc	dh		; inc sec/all unit
  9806 00000668 FEC2                    		inc	dl		; inc head limit
  9807                                  Has1:					
  9808 0000066A 26887508                		mov	[es:di+8], dh	; [es:di+BDS.secperclus]
  9809 0000066E 26887D0C                		mov	[es:di+0Ch], bh	; [es:di+BDS.direntries]
  9810 00000672 26894D0E                		mov	[es:di+0Eh], cx	; [es:di+BDS.totalsecs16]
  9811 00000676 26886510                		mov	[es:di+10h], ah	; [es:di+BDS.media]
  9812 0000067A 26884511                		mov	[es:di+11h], al	; [es:di+BDS.fatsecs]
  9813 0000067E 26885D13                		mov	[es:di+13h], bl	; [es:di+BDS.secpertrack]
  9814 00000682 26885515                		mov	[es:di+15h], dl	; [es:di+BDS.heads]
  9815                                  
  9816                                  		; the BDS_BPB.BPB_HIDDENSECTORS+2 field and the
  9817                                  		; BDS_BPB.BPB_BIGTOTALSECTORS field need to be set
  9818                                  		; to 0 since this code is for floppies
  9819                                  
  9820                                  		; 18/12/2022
  9821                                  		;mov	word [es:di+19h], 0 ; [es:di+BDS.hiddensecs+2]
  9822                                  		;mov	word [es:di+17h], 0 ; [es:di+BDS.hiddensecs]
  9823                                  		;mov	word [es:di+1Dh], 0 ; [es:di+BDS.totalsecs32+2]
  9824                                  		; 18/12/2022
  9825 00000686 29C9                    		sub	cx, cx
  9826 00000688 26894D19                		mov	[es:di+19h], cx ; 0 ; [es:di+BDS.hiddensecs+2]
  9827 0000068C 26894D17                		mov	[es:di+17h], cx ; 0 ; [es:di+BDS.hiddensecs]
  9828 00000690 26894D1D                		mov	[es:di+1Dh], cx ; 0 ; [es:di+BDS.totalsecs32+2]
  9829                                  getret:					
  9830 00000694 5B                      		pop	bx
  9831 00000695 5A                      		pop	dx
  9832 00000696 59                      		pop	cx
  9833                                  getret_exit:				
  9834 00000697 C3                      		retn
  9835                                  ; ---------------------------------------------------------------------------
  9836                                  
  9837                                  getbp_err_ret:	; before doing anything else, set set_id_flag	to 0.			
  9838                                  		;mov	ds:set_id_flag,	0
  9839                                  		; 19/10/2022
  9840 00000698 C606[0A05]00            		mov	byte [set_id_flag], 0
  9841 0000069D E83105                  		call	maperror
  9842 000006A0 EBF2                    		jmp	short getret
  9843                                  ; ---------------------------------------------------------------------------
  9844                                  
  9845                                  		; we have a 3.5" diskette for	which we cannot	build a	bpb.
  9846                                  		; we do	not assume any type of bpb for this medium.
  9847                                  
  9848                                  got_unknown_medium:			
  9849                                  		;mov	ds:set_id_flag,	0 
  9850 000006A2 C606[0A05]00            		mov	byte [set_id_flag], 0
  9851 000006A7 B007                    		mov	al, 7
  9852 000006A9 F9                      		stc
  9853 000006AA EBE8                    		jmp	short getret
  9854                                  
  9855                                  ; =============== S U B	R O U T	I N E =======================================
  9856                                  
  9857                                  ; 15/10/2022 - Retro DOS 4.0 (Modified MSDOS 5.0 IO.SYS)
  9858                                  
  9859                                  ; ----------------------------------------------------------------
  9860                                  ; read in the boot sector. set carry if error in reading sector.
  9861                                  ; bx is set to 1 if the boot sector is invalid, otherwise it is 0.
  9862                                  ;
  9863                                  ;	assumes es:di -> bds, ds-> Bios_Data
  9864                                  ; ----------------------------------------------------------------
  9865                                  
  9866                                  ; 10/03/2019 - Retro DOS v4.0
  9867                                  
  9868                                  readbootsec:	
  9869 000006AC B600                    		mov	dh, 0		; head 0
  9870 000006AE B90100                  		mov	cx, 1		; cylinder 0, sector 1
  9871 000006B1 E8C600                  		call	read_sector
  9872 000006B4 724A                    		jb	short err_ret
  9873 000006B6 31DB                    		xor	bx, bx		; assume valid boot sector
  9874                                  
  9875                                  		; put a sanity check for the boot sector in here to detect
  9876                                  		; boot sectors that do not have valid bpbs. we examine the
  9877                                  		; first two bytes - they must contain a long jump (69h) or a
  9878                                  		; short jump (EBh) followed by a nop (90h), or a short jump
  9879                                  		; (E9h). if this test is passed, we further check by examining
  9880                                  		; the signature at the end of the boot sector for the word
  9881                                  		; AA55h. if the signature is not present, we examine the media
  9882                                  		; descriptor byte to see if it is valid. for dos 3.3, this
  9883                                  		; logic is modified a little bit. we are not going to check
  9884                                  		; signature. instead we are going to sanity check the media
  9885                                  		; byte in bpb regardless of the validity of signature. this is
  9886                                  		; to save the already developed commercial products that have
  9887                                  		; good jump instruction and signature but with the false bpb
  9888                                  		; informations
  9889                                  
  9890                                  ; that will crash the diskette drive operation. (for example, symphony diskette).
  9891                                  
  9892                                  		; 19/10/2022
  9893 000006B8 803E[4E01]69            		cmp	byte [disksector], 69h ; is it a direct jump?
  9894 000006BD 7415                    		jz	short check_bpb_mediabyte ; don't need to find a nop
  9895 000006BF 803E[4E01]E9            		cmp	byte [disksector], 0E9h ; dos 2.0 jump?
  9896 000006C4 740E                    		jz	short check_bpb_mediabyte ; no need for	nop
  9897 000006C6 803E[4E01]EB            		cmp	byte [disksector], 0EBh ; how about a short jump?
  9898 000006CB 7531                    		jnz	short invalidbootsec
  9899 000006CD 803E[5001]90            		cmp	byte [disksector+2], 90h ; is next one a nop?
  9900 000006D2 752A                    		jnz	short invalidbootsec
  9901                                  
  9902                                  ; 15/10/5022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
  9903                                  ;
  9904                                  ;; 10/03/2019
  9905                                  ;; (MSDOS 3.3, MSDISK.ASM, 1988)
  9906                                  ;;
  9907                                  ;; Don't have to perform the following signature check since
  9908                                  ;; we need to check the media byte even with the good signatured diskette.
  9909                                  ;;
  9910                                  ;;check_signature:
  9911                                  ;;		cmp	word [cs:disksector+1FEh],0AA55h ; see if non-ibm
  9912                                  ;;							 ; disk or 1.x media.
  9913                                  ;;		jz	short checksinglesided ; go see if singled sided medium.
  9914                                  ;;					       ; may need some special handling
  9915                                  
  9916                                  ; check for non-ibm disks which do not have the signature AA55h at the
  9917                                  ; end of the boot sector, but still have a valid boot sector. this is done
  9918                                  ; by examining the media descriptor in the boot sector.
  9919                                  
  9920                                  		; 19/10/2022
  9921                                  check_bpb_mediabyte:			
  9922 000006D4 A0[6301]                		mov	al, [disksector+15h]
  9923                                  					; [disksector+EXT_BOOT.BPB+EBPB.MEDIADESCRIPTOR]
  9924 000006D7 24F0                    		and	al, 0F0h
  9925 000006D9 3CF0                    		cmp	al, 0F0h	; allow	for strange media
  9926 000006DB 7521                    		jnz	short invalidbootsec
  9927                                  
  9928                                  ; there were some (apparently a lot of them) diskettes that had been formatted
  9929                                  ; under dos 3.1 and earlier versions which have invalid bpbs in their boot
  9930                                  ; sectors. these are specifically diskettes that were formatted in drives
  9931                                  ; with one head, or whose side 0 was bad. these contain bpbs in the boot
  9932                                  ; sector that have the sec/clus field set to 2 instead of 1, as is standard
  9933                                  ; in dos. in order to support them, we have to introduce a "hack" that will
  9934                                  ; help our build bpb routine to recognise these specific cases, and to
  9935                                  ; set up out copy of the bpb accordingly.
  9936                                  ; we do this by checking to see if the boot sector is off a diskette that
  9937                                  ; is single-sided and is a pre-dos 3.20 diskette. if it is, we set the
  9938                                  ; sec/clus field to 1. if not, we carry on as normal.
  9939                                  
  9940                                  checksinglesided:
  9941 000006DD A0[6301]                		mov	al, [disksector+15h]
  9942 000006E0 3CF0                    		cmp	al, 0F0h
  9943 000006E2 741B                    		jz	short gooddsk
  9944 000006E4 A801                    		test	al, 1
  9945 000006E6 7517                    		jnz	short gooddsk
  9946 000006E8 813E[5601]332E          		cmp	word [disksector+8], 2E33h ; "3."
  9947 000006EE 7507                    		jnz	short mustbeearlier
  9948 000006F0 803E[5801]32            		cmp	byte [disksector+0Ah], 32h ; "2"
  9949 000006F5 7308                    		jnb	short gooddsk
  9950                                  
  9951                                  ; we must have a pre-3.20 diskette. set the sec/clus field to 1
  9952                                  
  9953                                  mustbeearlier:				
  9954 000006F7 C606[5B01]01            		mov	byte [disksector+0Dh], 1
  9955                                  					; [disksector+EXT_BOOT.BPB+EBPB.SECTORSPERCLUSTER]
  9956 000006FC EB01                    		jmp	short gooddsk
  9957                                  ; ---------------------------------------------------------------------------
  9958                                  
  9959                                  invalidbootsec:				
  9960 000006FE 43                      		inc	bx		; indicate that boot sector invalid
  9961                                  		; 10/12/2022
  9962                                  movbpb_ret:
  9963                                  gooddsk:				
  9964 000006FF F8                      		clc
  9965                                  err_ret:
  9966 00000700 C3                      		retn
  9967                                  ; ---------------------------------------------------------------------------
  9968                                  
  9969                                  		; 10/12/2022
  9970                                  ;err_ret:				
  9971                                  		;retn
  9972                                  
  9973                                  ; =============== S U B	R O U T	I N E =======================================
  9974                                  
  9975                                  ; 15/10/2022
  9976                                  ; ---------------------------------------------------------------------------
  9977                                  ; 'movbpb' moves the bpb read from the boot sector into registers for use by
  9978                                  ; getbp routine at has1
  9979                                  ;
  9980                                  ; if the set_id_flag is 1, and if an extended boot record, then set volume
  9981                                  ; serial number, volume label, file system id in bds according to
  9982                                  ; the boot record.  after that, this routine will set the set_id_flag to 2
  9983                                  ; to signal that volume label is set already from the extended boot record
  9984                                  ; (so, don't set it again by calling "set_volume_id" routine which uses
  9985                                  ; the volume label in the root directory.)
  9986                                  ; ---------------------------------------------------------------------------
  9987                                  
  9988                                  ; 10/03/2019 - Retro DOS v4.0
  9989                                  
  9990                                  		; 19/10/2022
  9991                                  movbpb:	
  9992 00000701 8A36[5B01]              		mov	dh, [disksector+0Dh]
  9993                                  					; disksector+EXT_BOOT.BPB+EBPB.SECTORSPERCLUSTER]
  9994                                  					; sectors per unit
  9995 00000705 8A3E[5F01]              		mov	bh, [disksector+11h]
  9996                                  					; [disksector+EXT_BOOT.BPB+EBPB.ROOTENTRIES]
  9997                                  					; number of directory entries
  9998 00000709 8B0E[6101]              		mov	cx, [disksector+13h]
  9999                                  					; [disksector+EXT_BOOT.BPB+EBPB.TOTALSECTORS]
 10000                                  					; size of drive
 10001 0000070D 8A26[6301]              		mov	ah, [disksector+15h]
 10002                                  					; [disksector+EXT_BOOT.BPB+EBPB.MEDIADESCRIPTOR]
 10003                                  					; media	descriptor
 10004 00000711 A0[6401]                		mov	al, [disksector+16h];
 10005                                  					; [disksector+EXT_BOOT.BPB+EBPB.SECTORSPERFAT]
 10006                                  					; number of fat	sectors
 10007 00000714 8A1E[6601]              		mov	bl, [disksector+18h]
 10008                                  					; [disksector+EXT_BOOT.BPB+EBPB.SECTORSPERTRACK]
 10009                                  					; sectors per track
 10010 00000718 8A16[6801]              		mov	dl, [disksector+1Ah]
 10011                                  					; [disksector+EXT_BOOT.BPB+EBPB.HEADS]
 10012                                  					; number of heads
 10013 0000071C 803E[0A05]01            		cmp	byte [set_id_flag], 1 ; called by get_bpb?
 10014 00000721 75DC                    		jnz	short movbpb_ret
 10015 00000723 E81200                  		call	mov_media_ids
 10016 00000726 7205                    		jb	short movbpb_conv ; conventional boot record?
 10017 00000728 C606[0A05]02            		mov	byte [set_id_flag], 2 ; signals that volume id is set
 10018                                  movbpb_conv:				
 10019 0000072D 803E[7700]01            		cmp	byte [fhave96], 1
 10020 00000732 75CB                    		jnz	short movbpb_ret
 10021 00000734 E8D411                  		call	resetchanged	; reset	flags in bds to	not fchanged.
 10022                                  		; 10/12/2022
 10023                                  		; cf = 0
 10024                                  ;movbpb_ret:				
 10025                                  		;clc
 10026 00000737 C3                      		retn
 10027                                  
 10028                                  ; =============== S U B	R O U T	I N E =======================================
 10029                                  
 10030                                  ;copy the boot_serial number, volume id, and filesystem id from the
 10031                                  ;***extended boot record*** in ds:disksector to the bds table pointed
 10032                                  ;by es:di.
 10033                                  
 10034                                  ;in.) es:di -> bds
 10035                                  ;     ds:disksector = valid extended boot record.
 10036                                  ;out.) vol_serial, bds_volid and bds_system_id in bds are set according to
 10037                                  ;      the boot record information.
 10038                                  ;     carry flag set if not an extended bpb.
 10039                                  ;     all registers saved except the flag.
 10040                                  
 10041                                  		; 19/10/2022
 10042                                  mov_media_ids:		
 10043 00000738 803E[7401]29            		cmp	byte [disksector+26h], 29h
 10044                                  					; [disksector+EXT_BOOT.SIG],
 10045                                  					; EXT_BOOT_SIGNATURE
 10046 0000073D 752C                    		jnz	short mmi_not_ext
 10047 0000073F 51                      		push	cx
 10048 00000740 8B0E[7501]              		mov	cx, [disksector+27h]
 10049                                  					; [disksector+EXT_BOOT.SERIAL]
 10050 00000744 26894D57                		mov	[es:di+57h], cx	; [es:di+BDS.vol_serial]
 10051 00000748 8B0E[7701]              		mov	cx, [disksector+29h]
 10052                                  					; [disksector+EXT_BOOT.SERIAL+2]
 10053 0000074C 26894D59                		mov	[es:di+59h], cx	; [es:di+BDS.vol_serial+2]
 10054 00000750 57                      		push	di
 10055 00000751 56                      		push	si
 10056 00000752 B90B00                  		mov	cx, 11		; size_of_EXT_BOOT_VOL_LABEL
 10057 00000755 BE[7901]                		mov	si, disksector+2Bh
 10058                                  		;mov	si, (offset disksector+2Bh) ;
 10059                                  					; disksector+EXT_BOOT.VOL_LABEL
 10060 00000758 83C74B                  		add	di, 75		; BDS.volid
 10061 0000075B F3A4                    		rep movsb
 10062                                  		;mov	cx, 8		; size_of_EXT_SYSTEM_ID
 10063                                  		; 10/12/2022
 10064 0000075D B108                    		mov	cl, 8 ; cx = 8
 10065 0000075F BE[8401]                		mov	si, disksector+36h
 10066                                  		;mov	si, (offset disksector+36h) ; disksector+EXT_BOOT.SYSTEM_ID
 10067 00000762 83C705                  		add	di, 5		; (BDS.filesys_id-BDS.volid)-size_of_EXT_BOOT_VOL_LABEL
 10068 00000765 F3A4                    		rep movsb
 10069 00000767 5E                      		pop	si
 10070 00000768 5F                      		pop	di
 10071 00000769 59                      		pop	cx
 10072                                  		; 10/12/2022
 10073                                  		; cf = 0
 10074                                  		;clc		; this clc is not required (16/06/2019 - Erdogan Tan)
 10075                                  				; (20/09/2022)
 10076 0000076A C3                      		retn
 10077                                  ; ---------------------------------------------------------------------------
 10078                                  
 10079                                  mmi_not_ext:				
 10080 0000076B F9                      		stc
 10081 0000076C C3                      		retn
 10082                                  
 10083                                  ; =============== S U B	R O U T	I N E =======================================
 10084                                  
 10085                                  ; 15/10/2022
 10086                                  ; --------------------------------------------------------------
 10087                                  ; read in the fat sector and get the media byte from it.
 10088                                  ; input : es:di -> bds
 10089                                  ; output:
 10090                                  ;	  carry set if an error occurs, ax contains error code.
 10091                                  ;	  otherwise, ah contains media byte on exit
 10092                                  ; --------------------------------------------------------------
 10093                                  
 10094                                  readfat:	
 10095                                  		;mov	dh, 0
 10096                                  		; 10/12/2022
 10097 0000076D 30F6                    		xor	dh, dh
 10098 0000076F B90200                  		mov	cx, 2		; head 0
 10099                                  					; cylinder 0, sector 2
 10100 00000772 E80500                  		call	read_sector
 10101 00000775 7202                    		jb	short bad_fat_ret
 10102 00000777 8A27                    		mov	ah, [bx]	; media	byte
 10103                                  bad_fat_ret:				
 10104 00000779 C3                      		retn
 10105                                  
 10106                                  ; =============== S U B	R O U T	I N E =======================================
 10107                                  
 10108                                  ; 15/10/2022
 10109                                  
 10110                                  ; ---------------------------------------------------------------------------
 10111                                  ; read a single sector into the temp buffer.
 10112                                  ; perform three retries in case of error.
 10113                                  ;   inputs:	es:[di].bds_drivenum has physical drive to use
 10114                                  ;		cx has sector and cylinder
 10115                                  ;		dh has head
 10116                                  ;		es:di has bds
 10117                                  ;		ds has Bios_Data
 10118                                  ;
 10119                                  ;   outputs:	carry clear
 10120                                  ;		    Bios_Data:bx point to sector
 10121                                  ;		       (note: some callers assume location of buffer)
 10122                                  ;
 10123                                  ;		carry set
 10124                                  ;		    ax has rom error code
 10125                                  ;
 10126                                  ; register bp is preserved.
 10127                                  ; ---------------------------------------------------------------------------
 10128                                  
 10129                                  ; 10/03/2019 - Retro DOS v4.0
 10130                                  
 10131                                  		; 19/10/2022
 10132                                  read_sector:	
 10133 0000077A 55                      		push	bp
 10134 0000077B BD0300                  		mov	bp, 3		; make 3 attempts
 10135 0000077E 268A5504                		mov	dl, [es:di+4]	; [es:di+BDS.drivenum]
 10136 00000782 BB[4E01]                		mov	bx, disksector	; get es:bx to point to	buffer
 10137                                  rd_ret:					
 10138 00000785 06                      		push	es
 10139 00000786 1E                      		push	ds
 10140 00000787 07                      		pop	es
 10141 00000788 B80102                  		mov	ax, 201h
 10142 0000078B CD13                    		int	13h		; DISK - READ SECTORS INTO MEMORY
 10143                                  					; AL = number of sectors to read, CH = track, CL = sector
 10144                                  					; DH = head, DL	= drive, ES:BX -> buffer to fill
 10145                                  					; Return: CF set on error, AH =	status,	AL = number of sectors read
 10146 0000078D 07                      		pop	es
 10147 0000078E 734A                    		jnb	short okret2
 10148                                  rd_rty:					
 10149 00000790 E87604                  		call	again		; reset	disk, decrement	bp, preserve ax
 10150 00000793 7442                    		jz	short err_rd_ret
 10151 00000795 26F6452301              		test	byte [es:di+23h], 1
 10152                                  		;test	byte ptr [es:di+23h], 1	; [es:di+BDS.flags]
 10153                                  					; fnon_removable
 10154 0000079A 75E9                    		jnz	short rd_ret
 10155 0000079C 803E[3806]00            		cmp	byte [media_set_for_format], 0
 10156 000007A1 7510                    		jnz	short rd_skip1_dpt
 10157 000007A3 50                      		push	ax
 10158 000007A4 1E                      		push	ds		; for retry, set the head settle time to 0Fh
 10159 000007A5 C536[2D01]              		lds	si, [dpt]
 10160                                  		;mov	al, [si+9]	; [si+DISK_PARMS.DISK_HEAD_STTL]
 10161                                  		;mov	byte [si+9], 15 ; [si+DISK_PARMS.DISK_HEAD_STTL]
 10162                                  		;			; NORMSETTLE
 10163                                  		; 12/12/2022
 10164 000007A9 B00F                    		mov	al, 15
 10165 000007AB 864409                  		xchg	al, [si+9]
 10166                                  		; 
 10167 000007AE 1F                      		pop	ds
 10168 000007AF A2[2A01]                		mov	[save_head_sttl], al
 10169 000007B2 58                      		pop	ax
 10170                                  rd_skip1_dpt:				
 10171 000007B3 06                      		push	es
 10172 000007B4 1E                      		push	ds
 10173 000007B5 07                      		pop	es
 10174 000007B6 B80102                  		mov	ax, 201h
 10175 000007B9 CD13                    		int	13h		; DISK - READ SECTORS INTO MEMORY
 10176                                  					; AL = number of sectors to read, CH = track, CL = sector
 10177                                  					; DH = head, DL	= drive, ES:BX -> buffer to fill
 10178                                  					; Return: CF set on error, AH =	status,	AL = number of sectors read
 10179 000007BB 07                      		pop	es
 10180 000007BC 9C                      		pushf
 10181 000007BD 803E[3806]00            		cmp	byte [media_set_for_format], 0
 10182 000007C2 750E                    		jnz	short rd_skip2_dpt
 10183 000007C4 50                      		push	ax
 10184 000007C5 A0[2A01]                		mov	al, [save_head_sttl]
 10185 000007C8 1E                      		push	ds
 10186 000007C9 C536[2D01]              		lds	si, [dpt]
 10187 000007CD 884409                  		mov	[si+9],	al	; [si+DISK_PARMS.DISK_HEAD_STTL]
 10188 000007D0 1F                      		pop	ds
 10189 000007D1 58                      		pop	ax
 10190                                  rd_skip2_dpt:				
 10191 000007D2 9D                      		popf
 10192 000007D3 7305                    		jnb	short okret2
 10193 000007D5 EBB9                    		jmp	short rd_rty
 10194                                  ; ---------------------------------------------------------------------------
 10195                                  
 10196                                  err_rd_ret:				
 10197 000007D7 B2FF                    		mov	dl, 0FFh	; make sure we ask rom if media	has changed
 10198                                  					; return error
 10199 000007D9 F9                      		stc
 10200                                  
 10201                                  ; update information pertaining to last drive accessed, time of access, last
 10202                                  ; track accessed in that drive.
 10203                                  
 10204                                  okret2:					
 10205 000007DA 8816[7600]              		mov	[step_drv], dl	; set up for head settle logic in disk
 10206 000007DE 8816[1E01]              		mov	[tim_drv], dl	; save drive last accessed
 10207 000007E2 26886D46                		mov	[es:di+46h], ch	; [es:di+BDS.track]
 10208                                  					; save last track accessed on this drive
 10209                                  					; preserve flags in case error occurred
 10210 000007E6 9C                      		pushf
 10211 000007E7 E8FF03                  		call	set_tim
 10212 000007EA 9D                      		popf			; restore flags
 10213 000007EB 5D                      		pop	bp
 10214 000007EC C3                      		retn
 10215                                  
 10216                                  ;----------------------------------------------------------------------------
 10217                                  ;	disk open/close routines
 10218                                  ;----------------------------------------------------------------------------
 10219                                  
 10220                                  dsk_open:				; 2C7h:80Ah = 70h:2D7Ah
 10221 000007ED 803E[7700]00            		cmp	byte [fhave96], 0
 10222 000007F2 7407                    		jz	short dsk_open_exit ; done if no changeline support
 10223 000007F4 E8D4FC                  		call	SetDrive	; get bds for drive
 10224 000007F7 26FF4520                		inc	word [es:di+20h] ; [es:di+BDS.opcnt]
 10225                                  dsk_open_exit:	
 10226                                  		; 10/12/2022
 10227                                  		; cf = 0			
 10228                                  		;clc		; CF is	already	ZERO here (18/09/2022, MSDOS 5.0 IO.SYS)
 10229                                  				; (19/07/2019 -	Erdogan	Tan - MSDOS 6.0	IO.SYS - retrodos4.s)
 10230 000007FB C3                      		retn
 10231                                  ; ---------------------------------------------------------------------------
 10232                                  
 10233                                  dsk_close:				; 2C7h:81Ah = 70h:2D8Ah
 10234 000007FC 803E[7700]00            		cmp	byte [fhave96], 0
 10235 00000801 740E                    		jz	short exitjx	; done if no changeline	support
 10236 00000803 E8C5FC                  		call	SetDrive	; get bds for drive
 10237 00000806 26837D2000              		cmp	word [es:di+20h], 0 ; [es:di+BDS.opcnt]
 10238 0000080B 7404                    		jz	short exitjx	; watch	out for	wrap
 10239 0000080D 26FF4D20                		dec	word [es:di+20h]
 10240                                  exitjx:					
 10241                                  		; 10/12/2022
 10242                                  		; cf = 0
 10243                                  		;clc		; CF is	already	ZERO here (18/09/2022, MSDOS 5.0 IO.SYS)
 10244                                  				; (19/07/2019 -	Erdogan	Tan - MSDOS 6.0	IO.SYS - retrodos4.s)
 10245 00000811 C3                      		retn
 10246                                  
 10247                                  ;----------------------------------------------------------------------------
 10248                                  ;		disk removable routine
 10249                                  ;----------------------------------------------------------------------------
 10250                                  
 10251                                  		; al is	unit #
 10252                                  dsk_rem:				; 2C7h:831h = 70h:2DA1h
 10253 00000812 E8B6FC                  		call	SetDrive	; get bds for this drive
 10254                                  		;test	byte [es:di+BDS.flags], fnon_removable
 10255 00000815 26F6452301              		test	byte [es:di+23h], 1
 10256                                  		;jnz	short x_bus_exit ; non_rem
 10257 0000081A 7501                    		jnz	short non_rem	; 15/10/2022
 10258                                  		; 10/12/2022
 10259                                  		; cf = 0
 10260                                  		;clc			; CF is already ZERO here
 10261                                  					; 15/10/2022
 10262 0000081C C3                      		retn
 10263                                  ; ---------------------------------------------------------------------------
 10264                                  
 10265                                  non_rem:
 10266                                  x_bus_exit:				
 10267 0000081D B403                    		mov	ah, 3		; 2C7h:83Dh = 0070h:2DADh
 10268                                  					; return busy status
 10269 0000081F F9                      		stc
 10270                                  dsk_ret:				
 10271 00000820 C3                      		retn
 10272                                  
 10273                                  ;----------------------------------------------------------------------------
 10274                                  ;		disk i/o routines
 10275                                  ;----------------------------------------------------------------------------
 10276                                  
 10277                                  dsk_writv:				; 2C7h:841h = 70h:2DB1h
 10278                                  		;mov	word [wrtverify], 103h
 10279                                  		; 19/10/2022
 10280 00000821 C706[2001]0301          		mov	word [rflag], 103h
 10281                                  		;mov	word ptr ds:rflag, 103h	; write	and verify
 10282 00000827 EB06                    		jmp	short dsk_cl
 10283                                  ; ---------------------------------------------------------------------------
 10284                                  
 10285                                  dsk_writ:				; 2C7h:849h = 70h:2DB9h
 10286                                  		;mov	word [wrtverify], 3
 10287                                  		; 19/10/2022
 10288 00000829 C706[2001]0300          		mov	word [rflag], 3
 10289                                  		;mov	word ptr ds:rflag, 3 ; romwrite
 10290                                  
 10291                                  dsk_cl:					
 10292 0000082F E89800                  		call	diskio		; romwrite
 10293                                  ; ---------------------------------------------------------------------------
 10294                                  
 10295                                  dsk_io:					
 10296 00000832 73EC                    		jnb	short dsk_ret
 10297 00000834 E9A0F8                  		jmp	bc_err_cnt
 10298                                  ; ---------------------------------------------------------------------------
 10299                                  
 10300                                  dsk_read:				; ; 2C7h:857h =	70h:2DC7h
 10301 00000837 E88B00                  		call	diskrd
 10302 0000083A EBF6                    		jmp	short dsk_io
 10303                                  
 10304                                  ; =============== S U B	R O U T	I N E =======================================
 10305                                  
 10306                                  ; 15/10/2022
 10307                                  ; 10/03/2019 - Retro DOS v4.0
 10308                                  
 10309                                  ;-----------------------------------------------------------
 10310                                  ; miscellaneous odd jump routines. 
 10311                                  ; moved out of mainline for speed.
 10312                                  
 10313                                  ; if we have a system where we have virtual drives, we need 
 10314                                  ; to prompt the user to place the correct disk in the drive.
 10315                                  ;
 10316                                  ;	assume es:di -> bds, ds:->Bios_Data
 10317                                  ;-----------------------------------------------------------
 10318                                  
 10319                                  		; 19/10/2022
 10320                                  checksingle:		
 10321 0000083C 50                      		push	ax
 10322 0000083D 53                      		push	bx
 10323 0000083E 268B5D23                		mov	bx, [es:di+23h]	; [es:di+BDS.flags]
 10324                                  
 10325                                  ; if hard drive, cannot change disk.
 10326                                  ; if current owner of physical drive, no need to change diskette.
 10327                                  
 10328 00000842 F6C321                  		test	bl, 21h		; fnon_removable|fi_own_physical
 10329 00000845 7573                    		jnz	short singleret
 10330 00000847 F6C310                  		test	bl, 10h		; fi_am_mult
 10331                                  					; is there a drive sharing this	physical drive?
 10332 0000084A 746E                    		jz	short singleret
 10333                                  
 10334                                  
 10335                                  ; look for the previous owner of this physical drive
 10336                                  ; and reset its ownership flag.
 10337                                  
 10338 0000084C 268A4504                		mov	al, [es:di+4]	; [es:di+BDS.drivenum]
 10339                                  					; get physical drive number
 10340 00000850 06                      		push	es		; preserve pointer to current bds
 10341 00000851 57                      		push	di
 10342 00000852 C43E[1901]              		les	di, [start_bds] ; get first bds
 10343                                  scan_list:				
 10344 00000856 26384504                		cmp	[es:di+4], al
 10345 0000085A 7553                    		jnz	short scan_skip	; Not our drive. Try next bds.
 10346 0000085C B320                    		mov	bl, 20h	; ' '   ; fi_own_physical ; test ownership flag
 10347 0000085E 26845D23                		test	[es:di+23h], bl
 10348 00000862 744B                    		jz	short scan_skip	; he doesn't own it either. continue
 10349 00000864 26305D23                		xor	[es:di+23h], bl	; reset	ownership flag
 10350 00000868 5F                      		pop	di		; restore pointer to current bds
 10351 00000869 07                      		pop	es
 10352 0000086A 26085D23                		or	[es:di+23h], bl	; ; set	ownership flag
 10353                                  
 10354                                  ; we examine the fsetowner flag. if it is set, then we are using the code in
 10355                                  ; checksingle to just set the owner of a drive. we must not issue the prompt
 10356                                  ; in this case.
 10357 0000086E 803E[7A00]01            		cmp	byte [fsetowner], 1
 10358 00000873 7517                    		jnz	short not_fsetowner
 10359                                  		;cmp	byte ptr es:[di+4], 0 ;	are we handling	drive number 0 ?
 10360 00000875 26807D0400              		cmp	byte [es:di+4], 0
 10361 0000087A 753E                    		jnz	short singleret
 10362 0000087C 268A4505                		mov	al, [es:di+5]
 10363                                  		;mov	al, es:[di+5]	; [es:di+BDS.drivelet]
 10364                                  					; get the DOS drive letter
 10365 00000880 06                      		push	es
 10366 00000881 8E06[1A00]              		mov	es, [zeroseg]
 10367 00000885 26A20405                		mov	[es:LSTDRV], al
 10368                                  		;mov	es:504h, al	; [es:LSTDRV]
 10369                                  					; set up sdsb
 10370 00000889 07                      		pop	es		; restore bds pointer
 10371 0000088A EB2E                    		jmp	short singleret
 10372                                  ; ---------------------------------------------------------------------------
 10373                                  
 10374                                  ; to support "backward" compatibility with ibm's "single drive status byte"
 10375                                  ; we now check to see if we are in a single drive system and the application
 10376                                  ; has "cleverly" diddled the sdsb
 10377                                  
 10378                                  not_fsetowner:				
 10379 0000088C 803E[7800]02            		cmp	byte [single], 2 ; if (single_drive_system)
 10380 00000891 7517                    		jnz	short ignore_sdsb
 10381 00000893 50                      		push	ax
 10382 00000894 268A4505                		mov	al, [es:di+5]	; if (curr_drv == req_drv)
 10383 00000898 88C4                    		mov	ah, al
 10384 0000089A 06                      		push	es
 10385 0000089B 8E06[1A00]              		mov	es, [zeroseg]
 10386 0000089F 2686060405              		xchg	al, [es:LSTDRV]
 10387                                  		;xchg	al, es:504h	; [es:LSTDRV]
 10388                                  					; then swap(curr_drv,req_drv)
 10389 000008A4 07                      		pop	es
 10390 000008A5 38C4                    		cmp	ah, al		; else
 10391 000008A7 58                      		pop	ax		; swap(curr_drv,req_drv)
 10392 000008A8 7410                    		jz	short singleret	; issue	swap_dsk_msg
 10393                                  ignore_sdsb:				
 10394 000008AA E8800E                  		call	swpdsk
 10395 000008AD EB0B                    		jmp	short singleret
 10396                                  ; ---------------------------------------------------------------------------
 10397                                  
 10398                                  scan_skip:	
 10399 000008AF 26C43D                  		les	di, [es:di]			
 10400                                  		;les	di, es:[di]	; [es:di+BDS.link]
 10401                                  					; go to	next bds
 10402 000008B2 83FFFF                  		cmp	di, 0FFFFh	; end of list?
 10403 000008B5 759F                    		jnz	short scan_list	; ontinue until	hit end	of list
 10404 000008B7 F9                      		stc
 10405 000008B8 5F                      		pop	di		; restore current bds
 10406 000008B9 07                      		pop	es
 10407                                  
 10408                                  singleret:				
 10409 000008BA 5B                      		pop	bx
 10410 000008BB 58                      		pop	ax
 10411 000008BC C3                      		retn
 10412                                  
 10413                                  ; ---------------------------------------------------------------------------
 10414                                  
 10415                                  baddrive:				
 10416 000008BD B008                    		mov	al, 8		; sector not found
 10417 000008BF EB02                    		jmp	short baddrive_ret
 10418                                  ; ---------------------------------------------------------------------------
 10419                                  
 10420                                  unformatteddrive:				
 10421 000008C1 B007                    		mov	al, 7		; unknown media
 10422                                  baddrive_ret:				
 10423 000008C3 F9                      		stc
 10424                                  ; ---------------------------------------------------------------------------
 10425                                  
 10426                                  ioret:		
 10427 000008C4 C3                      		retn
 10428                                  
 10429                                  ; ---------------------------------------------------------------------------
 10430                                  
 10431                                  ; 15/10/52022
 10432                                  
 10433                                  ; ---------------------------------------------------------------------------
 10434                                  ;	disk i/o handler
 10435                                  ;
 10436                                  ;	al = drive number (0-6)
 10437                                  ;	ah = media descriptor
 10438                                  ;	cx = sector count
 10439                                  ;	dx = first sector (low)
 10440                                  ;	[start_sec_h] = first sector (high)  32 bit calculation.
 10441                                  ;	ds = cs
 10442                                  ;	es:di = transfer address
 10443                                  ;	[rflag]=operation (2=read, 3=write)
 10444                                  ;	[verify]=1 for verify after write
 10445                                  ;
 10446                                  ;	if successful carry flag = 0
 10447                                  ;	  else cf=1 and al contains error code
 10448                                  ; ---------------------------------------------------------------------------
 10449                                  
 10450                                  diskrd:	
 10451                                  		;mov	ds:rflag, 2	; romread
 10452                                  		; 19/10/2022
 10453 000008C5 C606[2001]02            		mov	byte [rflag], 2 ; romread
 10454                                  
 10455                                  ; =============== S U B	R O U T	I N E =======================================
 10456                                  
 10457                                  		; 19/10/2022
 10458                                  diskio:
 10459 000008CA 89FB                    		mov	bx, di		; es:bx	= transfer address
 10460 000008CC 8C06[3705]              		mov	[xfer_seg], es	; save transfer	segment
 10461 000008D0 E8F8FB                  		call	SetDrive
 10462 000008D3 268A4510                		mov	al, [es:di+10h]	; [es:di+BDS.media]
 10463 000008D7 A2[1F01]                		mov	[medbyt], al
 10464                                  		;jcxz	short ioret
 10465 000008DA E3E8                    		jcxz	ioret
 10466                                  
 10467                                  ; see if the media is formatted or not by checking the flags field in
 10468                                  ; in the bds. if it is unformatted we cannot allow i/o, so we should
 10469                                  ; go to the error exit at label unformatteddrive.
 10470                                  
 10471 000008DC 26F6452402              		test	byte [es:di+24h], 2
 10472                                  		;test	byte ptr es:[di+24h], 2	; [es:di+BDS.flags+1]
 10473                                  					; unformatted_media
 10474 000008E1 75DE                    		jnz	short unformatteddrive
 10475 000008E3 890E[2201]              		mov	[seccnt], cx	; save sector count
 10476 000008E7 8926[3501]              		mov	[spsav], sp	; save sp
 10477                                  
 10478                                  ; ensure that we are trying to access valid sectors on the drive
 10479                                  
 10480 000008EB 89D0                    		mov	ax, dx
 10481 000008ED 31F6                    		xor	si, si
 10482 000008EF 01CA                    		add	dx, cx
 10483 000008F1 83D600                  		adc	si, 0
 10484 000008F4 26837D0E00              		cmp	word [es:di+0Eh], 0 ; [es:di+BDS.totalsecs16]
 10485                                  					; > 32 bit sector ?
 10486 000008F9 740D                    		jz	short sanity32
 10487 000008FB 83FE00                  		cmp	si, 0
 10488 000008FE 75BD                    		jnz	short baddrive
 10489 00000900 263B550E                		cmp	dx, [es:di+0Eh]	; [es:di+BDS.totalsecs16]
 10490 00000904 77B7                    		ja	short baddrive
 10491 00000906 EB12                    		jmp	short sanityok
 10492                                  ; ---------------------------------------------------------------------------
 10493                                  
 10494                                  sanity32:				
 10495 00000908 0336[2B05]              		add	si, [start_sec_h]
 10496 0000090C 263B751D                		cmp	si, [es:di+1Dh]	; [es:di+BDS.totalsecs32+2]
 10497 00000910 7208                    		jb	short sanityok
 10498 00000912 77A9                    		ja	short baddrive
 10499 00000914 263B551B                		cmp	dx, [es:di+1Bh]	; [es:di+BDS.totalsecs32]
 10500 00000918 77A3                    		ja	short baddrive
 10501                                  
 10502                                  sanityok:				
 10503 0000091A 8B16[2B05]              		mov	dx, [start_sec_h]
 10504 0000091E 26034517                		add	ax, [es:di+17h]	; [es:di+BDS.hiddensecs]
 10505 00000922 26135519                		adc	dx, [es:di+19h]	; [es:di+BDS.hiddensecs+2]
 10506                                  
 10507                                  ; now dx;ax have the physical first sector.
 10508                                  ; since the following procedures is going to destroy ax, let's
 10509                                  ; save it temporarily to saved_word.
 10510                                  
 10511 00000926 A3[2D05]                		mov	[saved_word], ax ; save the sector number (low)
 10512                                  
 10513                                  ; set up pointer to disk base table in [dpt]. we cannot assume that iosetup
 10514                                  ; will do it because we will skip the set up stuff with hard disks.
 10515                                  
 10516 00000929 06                      		push	es
 10517 0000092A 8E06[1A00]              		mov	es, [zeroseg]
 10518 0000092E 26C4367800              		les	si, [es:DSKADR]
 10519                                  		;les	si, es:78h	; [es:DSKADR]
 10520                                  					; current disk parm table
 10521 00000933 8936[2D01]              		mov	[dpt], si
 10522 00000937 8C06[2F01]              		mov	[dpt+2], es
 10523 0000093B 07                      		pop	es
 10524 0000093C 26F6452301              		test	byte [es:di+23h], 1 ; [es:di+BDS.flags]
 10525                                  					; fnon_removable
 10526 00000941 7510                    		jnz	short skip_setup
 10527 00000943 E8F6FE                  		call	checksingle
 10528                                  
 10529                                  ; check to see if we have previously noted a change line. the routine
 10530                                  ; returns if everything is ok. otherwise, it pops off the stack and returns
 10531                                  ; the proper error code.
 10532                                  
 10533 00000946 803E[7700]00            		cmp	byte [fhave96], 0 ; do we have changeline support?
 10534 0000094B 7403                    		jz	short diskio_nochangeline ; brif not
 10535 0000094D E8AB0E                  		call	checklatchio	; will do a sneaky pop stack return
 10536                                  					; if a disk error occurs
 10537                                  diskio_nochangeline:			
 10538 00000950 E84700                  		call	iosetup		; set up tables	and variables for i/o
 10539                                  
 10540                                  ; now the settle values are correct for the following code
 10541                                  
 10542                                  skip_setup:
 10543                                  
 10544                                  ; 32 bit sector calculation.
 10545                                  ; dx:[saved_word] = starting sector number.
 10546                                  				
 10547 00000953 89D0                    		mov	ax, dx
 10548 00000955 31D2                    		xor	dx, dx
 10549 00000957 26F77513                		div	word [es:di+13h] ; [es:di+BDS.secpertrack]
 10550                                  					 ; divide by sec per track
 10551 0000095B A3[2905]                		mov	[temp_h], ax
 10552 0000095E A1[2D05]                		mov	ax, [saved_word]
 10553 00000961 26F77513                		div	word [es:di+13h] ; [es:di+BDS.secpertrack]
 10554                                  					; now, [temp_h]:ax = track #, dx = sector
 10555                                  		;inc	dl		; sector number	is 1 based.
 10556                                  		; 18/12/2022
 10557 00000965 42                      		inc	dx
 10558 00000966 8816[3101]              		mov	[cursec], dl	; save current sector
 10559 0000096A 268B4D15                		mov	cx, [es:di+15h]	; es:di+BDS.heads]
 10560                                  					; get number of	heads
 10561 0000096E 50                      		push	ax
 10562 0000096F 31D2                    		xor	dx, dx
 10563 00000971 A1[2905]                		mov	ax, [temp_h]	; divide tracks	by heads per cylinder
 10564 00000974 F7F1                    		div	cx
 10565 00000976 A3[2905]                		mov	[temp_h], ax
 10566 00000979 58                      		pop	ax
 10567 0000097A F7F1                    		div	cx		; now, [temp_h]:ax = cylinder #, dx = head
 10568 0000097C 833E[2905]00            		cmp	word [temp_h], 0
 10569 00000981 7714                    		ja	short baddrive_brdg
 10570 00000983 3D0004                  		cmp	ax, 1024	; 2^10 currently maxium	for track #.
 10571 00000986 770F                    		ja	short baddrive_brdg
 10572 00000988 8816[3201]              		mov	[curhd], dl	; save current head
 10573 0000098C A3[3301]                		mov	[curtrk], ax	; save current track
 10574                                  
 10575                                  ; we are now set up for the i/o. normally, we consider the dma boundary
 10576                                  ; violations here. not true. we perform the operation as if everything is
 10577                                  ; symmetric; let the int 13 handler worry about the dma violations.
 10578                                  
 10579 0000098F A1[2201]                		mov	ax, [seccnt]
 10580 00000992 E88400                  		call	block		; (cas - call/ret)
 10581                                  		;call	done
 10582                                  		;retn
 10583                                  		; 18/12/2022
 10584 00000995 EB4B                    		jmp	done
 10585                                  
 10586                                  ; ---------------------------------------------------------------------------
 10587                                  
 10588                                  baddrive_brdg:				
 10589 00000997 E923FF                  		jmp	baddrive
 10590                                  
 10591                                  ; =============== S U B	R O U T	I N E =======================================
 10592                                  
 10593                                  ;--------------------------------------------------------------
 10594                                  ; set the drive-last-accessed flag for diskette only. 
 10595                                  ; we know that the hard disk will not be removed.
 10596                                  ; es:di -> current bds.
 10597                                  ; ds -> Bios_Data
 10598                                  ; ax,cx,si are destroyed.
 10599                                  ;--------------------------------------------------------------
 10600                                  
 10601                                  		; 19/10/2022
 10602                                  iosetup:	
 10603 0000099A 268A4504                		mov	al, [es:di+4]	; [es:di+BDS.drivenum]
 10604 0000099E A2[1E01]                		mov	[tim_drv], al	; save drive letter
 10605                                  
 10606                                  ; determine proper head settle values
 10607                                  
 10608 000009A1 803E[3806]00            		cmp	byte [media_set_for_format], 0
 10609 000009A6 7539                    		jnz	short skip_dpt_setting
 10610 000009A8 A0[2C01]                		mov	al, [eot]	; fetch	up eot before changing ds
 10611 000009AB 1E                      		push	ds
 10612 000009AC C536[2D01]              		lds	si, [dpt]	; get pointer to disk base table
 10613 000009B0 884404                  		mov	[si+4],	al
 10614 000009B3 8A440A                  		mov	al, [si+10]	; [si+DISK_PARMS.DISK_MOTOR_STRT]
 10615 000009B6 8A6404                  		mov	ah, [si+4]	; [si+DISK_PARMS.DISK_EOT]
 10616 000009B9 1F                      		pop	ds
 10617 000009BA A2[2601]                		mov	[motorstartup], al
 10618 000009BD 8826[2B01]              		mov	[save_eot], ah
 10619                                  
 10620                                  ; for 3.5" drives, both external as well as on the k09, we need to set the
 10621                                  ; motor start time to 4. this checking for every i/o is going to affect
 10622                                  ; performance across the board, but is necessary!!
 10623                                  
 10624 000009C1 1E                      		push	ds
 10625 000009C2 C536[2D01]              		lds	si, [dpt]	; get pointer to disk base table
 10626 000009C6 26807D2202              		cmp	byte [es:di+22h], 2 ; [es:di+BDS.formfactor]
 10627                                  					; ffSmall
 10628 000009CB 7505                    		jnz	short motor_start_ok
 10629 000009CD B004                    		mov	al, 4
 10630 000009CF 86440A                  		xchg	al, [si+10]	; [si+DISK_PARMS.DISK_MOTOR_STRT]
 10631                                  motor_start_ok:
 10632                                  
 10633                                  ; ds:si now points to disk parameter table.
 10634                                  ; get current settle and set fast settle
 10635                                  				
 10636                                  		;xor	al, al
 10637                                  		;inc	al		; ibm wants fast settle	to be 1
 10638                                  		; 18/12/2022
 10639 000009D2 31C0                    		xor	ax, ax
 10640 000009D4 40                      		inc	ax
 10641 000009D5 864409                  		xchg	al, [si+9]	; [si+DISK_PARMS.DISK_HEAD_STTL]
 10642                                  					; get settle and set up	for fast
 10643 000009D8 1F                      		pop	ds
 10644 000009D9 A2[2701]                		mov	[settlecurrent], al
 10645 000009DC B00F                    		mov	al, 15		; NORMSETTLE
 10646                                  					; someone has diddled the settle
 10647 000009DE A2[2801]                		mov	[settleslow], al
 10648                                  skip_dpt_setting:			
 10649 000009E1 C3                      		retn
 10650                                  
 10651                                  ; =============== S U B	R O U T	I N E =======================================
 10652                                  
 10653                                  ;--------------------------------------------------------------
 10654                                  ; set time of last access, and reset default values in the dpt.
 10655                                  ;
 10656                                  ;	  note: trashes (at least) si
 10657                                  ;--------------------------------------------------------------
 10658                                  
 10659                                  		; 19/10/2022
 10660                                  done:
 10661 000009E2 26F6452301              		test	byte [es:di+23h], 1 ; [es:di+BDS.flags]
 10662                                  					; fnon_removable
 10663 000009E7 752F                    		jnz	short ddbx	; do not set for non-removable media
 10664 000009E9 E8FD01                  		call	set_tim
 10665                                  ;diddleback:
 10666                                  ; 09/12/2022
 10667                                  diddle_back:				
 10668 000009EC 9C                      		pushf
 10669 000009ED 803E[3806]00            		cmp	byte [media_set_for_format], 0
 10670 000009F2 7523                    		jnz	short nodiddleback
 10671 000009F4 50                      		push	ax
 10672 000009F5 06                      		push	es
 10673 000009F6 C436[2D01]              		les	si, [dpt]
 10674 000009FA A0[2B01]                		mov	al, [save_eot]
 10675 000009FD 26884404                		mov	[es:si+4], al	; [es:si+DISK_PARMS.DISK_EOT]
 10676 00000A01 A0[2701]                		mov	al, [settlecurrent]
 10677 00000A04 8A26[2601]              		mov	ah, [motorstartup]
 10678 00000A08 26884409                		mov	[es:si+9], al	; [es:si+DISK_PARMS.DISK_HEAD_STTL]
 10679 00000A0C 26C6440302              		mov	byte [es:si+3], 2 ; [es:si+DISK_PARMS.DISK_SECTOR_SIZ]
 10680 00000A11 2688640A                		mov	[es:si+0Ah], ah	; [es:si+DISK_PARMS.DISK_MOTOR_STRT]
 10681 00000A15 07                      		pop	es
 10682 00000A16 58                      		pop	ax
 10683                                  nodiddleback:				
 10684 00000A17 9D                      		popf
 10685                                  ddbx:					
 10686 00000A18 C3                      		retn
 10687                                  
 10688                                  ; =============== S U B	R O U T	I N E =======================================
 10689                                  
 10690                                  ;--------------------------------------------------------------
 10691                                  ;read the number of sectors specified in ax, 
 10692                                  ;handling track boundaries
 10693                                  ;es:di -> bds for this drive
 10694                                  ;--------------------------------------------------------------
 10695                                  
 10696                                  		 ; 19/10/2022
 10697                                  block:	
 10698 00000A19 09C0                    		or	ax, ax
 10699 00000A1B 74FB                    		jz	short ddbx
 10700 00000A1D 26F6452301              		test	byte [es:di+23h], 1 ; [es:di+BDS.flags]
 10701                                  					; fnon_removable
 10702 00000A22 740D                    		jz	short block_floppy ;
 10703                                  
 10704                                  ; check	to see if multi	track operation	is allowed. if not
 10705                                  ; we have to go	to the block_floppy below to break up the operation.
 10706                                  
 10707 00000A24 F606[2F05]80            		test	byte [multrk_flag], 80h
 10708                                  		;test	byte ptr ds:multrk_flag, 80h ; multrk_on
 10709 00000A29 7406                    		jz	short block_floppy
 10710 00000A2B E82900                  		call	Disk
 10711 00000A2E 31C0                    		xor	ax, ax
 10712 00000A30 C3                      		retn
 10713                                  ; ---------------------------------------------------------------------------
 10714                                  
 10715                                  block_floppy:
 10716                                  
 10717                                  ; read at most 1 track worth. perform minimization at sector / track
 10718                                  				
 10719 00000A31 268A4D13                		mov	cl, [es:di+19]	; [es:di+BDS.secpertrack]
 10720 00000A35 FEC1                    		inc	cl
 10721 00000A37 2A0E[3101]              		sub	cl, [cursec]
 10722 00000A3B 30ED                    		xor	ch, ch
 10723 00000A3D 39C8                    		cmp	ax, cx
 10724 00000A3F 7302                    		jnb	short gotmin
 10725 00000A41 89C1                    		mov	cx, ax
 10726                                  
 10727                                  gotmin:
 10728                                  
 10729                                  ; ax is the requested number of sectors to read
 10730                                  ; cx is the number that we can do on this track
 10731                                  					
 10732 00000A43 50                      		push	ax
 10733 00000A44 51                      		push	cx
 10734 00000A45 89C8                    		mov	ax, cx
 10735 00000A47 E80D00                  		call	Disk
 10736 00000A4A 59                      		pop	cx
 10737 00000A4B 58                      		pop	ax
 10738                                  
 10739                                  ; cx is the number of sectors just transferred
 10740                                  
 10741 00000A4C 29C8                    		sub	ax, cx		; reduce sectors-remaining by last i/o
 10742 00000A4E D0E1                    		shl	cl, 1
 10743 00000A50 00CF                    		add	bh, cl		; adjust transfer address
 10744 00000A52 EBC5                    		jmp	short block
 10745                                  dskerr_brdg:				
 10746 00000A54 E9EC00                  		jmp	dskerr
 10747                                  
 10748                                  ; =============== S U B	R O U T	I N E =======================================
 10749                                  
 10750                                  ; 15/10/2022
 10751                                  
 10752                                  ;--------------------------------------------------------------
 10753                                  ;perform disk i/o with retries
 10754                                  ; al = number of sectors (1-8, all on one track)
 10755                                  ; es:di point to drive parameters
 10756                                  ; xfer_seg:bx = transfer address 
 10757                                  ;		(must not cross a 64k physical boundary)
 10758                                  ; [rflag] = 2 if read, 3 if write
 10759                                  ; [verify] = 0 for normal, 1 for verify after write
 10760                                  ;--------------------------------------------------------------
 10761                                  
 10762                                  		 ; 19/10/2022
 10763                                  Disk:
 10764                                  
 10765                                  ; Check for hard disk format and
 10766                                  ; if TRUE then set max error count to 2
 10767                                  
 10768 00000A57 BD0500                  		mov	bp, 5		; MAXERR
 10769                                  					; set up retry count
 10770 00000A5A 26F6452301              		test	byte [es:di+23h], 1	;
 10771                                  					; [es:di+BDS.flags], fnon_removable
 10772 00000A5F 7408                    		jz	short GetRdWrInd
 10773 00000A61 80FC04                  		cmp	ah, 4		; romverify ; Is this a	track verify?
 10774 00000A64 7403                    		jz	short GetRdWrInd
 10775 00000A66 BD0200                  		mov	bp, 2		; This is not verify so only 1 retry
 10776                                  GetRdWrInd:				
 10777 00000A69 892E[3205]              		mov	[vretry_cnt], bp ; verify op. retry cnt for write-verify
 10778 00000A6D 892E[3405]              		mov	[soft_ecc_cnt], bp ; soft ecc error retry count.
 10779 00000A71 8A26[2001]              		mov	ah, [rflag]	; get read/write indicator
 10780                                  ;retry:
 10781                                  ; 09/12/2022
 10782                                  _retry:					
 10783 00000A75 50                      		push	ax
 10784 00000A76 8B16[3301]              		mov	dx, [curtrk]
 10785 00000A7A 26F6452301              		test	byte [es:di+23h], 1
 10786 00000A7F 740B                    		jz	short disk_not_mini
 10787 00000A81 26837D4701              		cmp	word [es:di+47h], 1 ; [es:di+BDS.bdsm_ismini]
 10788                                  					; is this a mini disk? ((logical dos partition))
 10789 00000A86 7504                    		jnz	short disk_not_mini ; no. continue to next.
 10790 00000A88 26035549                		add	dx, [es:di+49h]	; [es:di+BDS.bdsm_hidden_trks]
 10791                                  					; add hidden trks.
 10792                                  disk_not_mini:				
 10793 00000A8C D0CE                    		ror	dh, 1
 10794 00000A8E D0CE                    		ror	dh, 1
 10795 00000A90 0A36[3101]              		or	dh, [cursec]
 10796 00000A94 89D1                    		mov	cx, dx
 10797 00000A96 86E9                    		xchg	ch, cl		;  cl =	sector,	ch = cylinder
 10798 00000A98 8A36[3201]              		mov	dh, [curhd]	; load current head number and
 10799 00000A9C 268A5504                		mov	dl, [es:di+4]	; physical drive number
 10800                                  					; [es:di+BDS.drivenum]
 10801 00000AA0 26807D2205              		cmp	byte [es:di+22h], 5 ; [es:di+BDS.formfactor], ffHardFile
 10802 00000AA5 7413                    		jz	short do_fast	; hard files use fast speed
 10803                                  
 10804                                  ; if we have [step_drv] set to -1, we use the slow settle time.
 10805                                  ; this helps when we have just done a reset disk operation and the head has
 10806                                  ; been moved to another cylinder - the problem crops up with 3.5" drives.
 10807                                  
 10808 00000AA7 803E[7600]FF            		cmp	byte [step_drv], 0FFh ; -1
 10809 00000AAC 740A                    		jz	short do_writej
 10810 00000AAE 80FC02                  		cmp	ah, 2		; romread
 10811 00000AB1 7407                    		jz	short do_fast
 10812 00000AB3 80FC04                  		cmp	ah, 4		; romverify
 10813 00000AB6 7402                    		jz	short do_fast
 10814                                  do_writej:	
 10815                                  
 10816                                  ; reads always fast, unless we have just done a disk reset operation
 10817                                  			
 10818 00000AB8 EB56                    		jmp	short do_write	; reads	always fast
 10819                                  ; ---------------------------------------------------------------------------
 10820                                  
 10821                                  do_fast:				
 10822 00000ABA E8FC00                  		call	fastspeed	; change settle	mode
 10823                                  
 10824                                  testerr:				
 10825 00000ABD 7295                    		jb	short dskerr_brdg
 10826                                  
 10827                                  ; set drive and track of last access
 10828                                  
 10829 00000ABF 8816[7600]              		mov	[step_drv], dl
 10830 00000AC3 26886D46                		mov	[es:di+46h], ch	; [es:di+BDS.track]
 10831                                  no_set:
 10832                                  		;cmp	word [wrtverify], 103h
 10833 00000AC7 813E[2001]0301          		cmp	word [rflag], 103h ; check for write and verify
 10834 00000ACD 7452                    		jz	short doverify
 10835                                  noverify:				
 10836 00000ACF 58                      		pop	ax
 10837                                  
 10838                                  ; check the flags word in the bds to see if the drive is non removable
 10839                                  ; if not we needn't do anything special
 10840                                  ; if it is a hard disk then check to see if multi-track operation
 10841                                  ; is specified. if specified we don't have to calculate for the next
 10842                                  ; track since we are already done. so we can go to the exit of this routine.
 10843                                  
 10844 00000AD0 26F6452301              		test	byte [es:di+23h], 1 ; [es:di+BDS.flags]
 10845                                  					; fnon_removable
 10846 00000AD5 7407                    		jz	short its_removable
 10847 00000AD7 F606[2F05]80            		test	byte [multrk_flag], 80h ; multrk_on
 10848 00000ADC 7530                    		jnz	short disk_ret
 10849                                  its_removable:				
 10850 00000ADE 80E13F                  		and	cl, 3Fh		; eliminate cylinder bits from sector
 10851 00000AE1 30E4                    		xor	ah, ah
 10852 00000AE3 2906[2201]              		sub	[seccnt], ax	; reduce count of sectors to go	next sector
 10853 00000AE7 00C1                    		add	cl, al
 10854 00000AE9 880E[3101]              		mov	[cursec], cl
 10855 00000AED 263A4D13                		cmp	cl, [es:di+13h]	; [es:di+BDS.secpertrack]
 10856                                  					; see if sector/track limit reached
 10857 00000AF1 761B                    		jbe	short disk_ret
 10858 00000AF3 C606[3101]01            		mov	byte [cursec], 1 ; start with first sector of next track
 10859 00000AF8 8A36[3201]              		mov	dh, [curhd]
 10860 00000AFC FEC6                    		inc	dh
 10861 00000AFE 263A7515                		cmp	dh, [es:di+15h]	; [es:di+BDS.heads]
 10862 00000B02 7206                    		jb	short noxor
 10863 00000B04 30F6                    		xor	dh, dh
 10864 00000B06 FF06[3301]              		inc	word [curtrk]
 10865                                  noxor:					
 10866 00000B0A 8836[3201]              		mov	[curhd], dh
 10867                                  disk_ret:				
 10868 00000B0E F8                      		clc
 10869 00000B0F C3                      		retn
 10870                                  ; ---------------------------------------------------------------------------
 10871                                  
 10872                                  ; 15/10/2022
 10873                                  
 10874                                  ;--------------------------------------------------------------
 10875                                  ; the request is for write. determine if we are talking about
 10876                                  ; the same track and drive. if so, use the fast speed.
 10877                                  ;--------------------------------------------------------------
 10878                                  
 10879                                  do_write:				
 10880 00000B10 3A16[7600]              		cmp	dl, [step_drv]
 10881 00000B14 7506                    		jnz	short do_norm	; we have changed drives
 10882 00000B16 263A6D46                		cmp	ch, [es:di+46h]	; [es:di+BDS.track]
 10883 00000B1A 749E                    		jz	short do_fast	; we are still on the same track
 10884                                  
 10885                                  do_norm:				
 10886 00000B1C E87500                  		call	normspeed
 10887 00000B1F EB9C                    		jmp	short testerr
 10888                                  ; ---------------------------------------------------------------------------
 10889                                  
 10890                                  ;--------------------------------------------------------------
 10891                                  ; we have a verify request also. get state info and go verify
 10892                                  ;--------------------------------------------------------------
 10893                                  
 10894                                  doverify:				
 10895 00000B21 58                      		pop	ax
 10896 00000B22 50                      		push	ax
 10897 00000B23 B404                    		mov	ah, 4
 10898 00000B25 E89100                  		call	fastspeed
 10899 00000B28 73A5                    		jnb	short noverify
 10900                                  
 10901                                  ; check the error returned in ah to see if it is a soft ecc error.
 10902                                  ; if it is not we needn't do anything special. if it is a soft
 10903                                  ; ecc error then decrement the soft_ecc_cnt error retry count. if
 10904                                  ; this retry count becomes 0 then we just ignore the error and go to
 10905                                  ; no_verify but if we can still try then we call the routine to reset
 10906                                  ; the disk and go to dskerr1 to retry the operation.
 10907                                  
 10908 00000B2A 80FC11                  		cmp	ah, 11h		; soft ecc error ?
 10909 00000B2D 750B                    		jnz	short not_softecc_err
 10910 00000B2F FF0E[3405]              		dec	word [soft_ecc_cnt]
 10911 00000B33 749A                    		jz	short noverify	; no more retry
 10912 00000B35 E84405                  		call	ResetDisk	; reset	disk
 10913 00000B38 EB3E                    		jmp	short dskerr1	; retry
 10914                                  ; ---------------------------------------------------------------------------
 10915                                  
 10916                                  not_softecc_err:			; other error.			
 10917 00000B3A E83F05                  		call	ResetDisk
 10918 00000B3D FF0E[3205]              		dec	word [vretry_cnt]
 10919 00000B41 EB1C                    		jmp	short dskerr0
 10920                                  ; ---------------------------------------------------------------------------
 10921                                  
 10922                                  ;--------------------------------------------------------------
 10923                                  ; need to special case the change-line error ah=06h.
 10924                                  ; if we get this, we need to return it.
 10925                                  ;--------------------------------------------------------------
 10926                                  
 10927                                  dskerr:					
 10928 00000B43 803E[7700]00            		cmp	byte [fhave96], 0	; do we	have changeline	support?
 10929 00000B48 7403                    		jz	short dskerr_nochangeline ; brif not
 10930 00000B4A E8220D                  		call	checkio
 10931                                  dskerr_nochangeline:			
 10932 00000B4D 803E[3605]01            		cmp	byte [multitrk_format_flag], 1 ; multi trk format request?
 10933 00000B52 7508                    		jnz	short dochkagain ; no more retry.
 10934 00000B54 BD0100                  		mov	bp, 1
 10935 00000B57 C606[3605]00            		mov	byte [multitrk_format_flag], 0 ; clear the flag.
 10936                                  dochkagain:				
 10937 00000B5C E8AA00                  		call	again
 10938                                  dskerr0:				
 10939 00000B5F 7420                    		jz	short harderr
 10940 00000B61 26F6452301              		test	byte [es:di+23h], 1 ; [es:di+BDS.flags]
 10941                                  					; fnon_removable
 10942 00000B66 7505                    		jnz	short skip_timeout_chk
 10943 00000B68 80FC80                  		cmp	ah, 80h		; timeout?
 10944 00000B6B 7414                    		jz	short harderr
 10945                                  skip_timeout_chk:			
 10946 00000B6D 80FCCC                  		cmp	ah, 0CCh	; write	fault error?
 10947 00000B70 740A                    		jz	short write_fault_err ;	then, don't retry.
 10948 00000B72 C706[3405]0500          		mov	word [soft_ecc_cnt], 5 ; MAXERR
 10949                                  					; set soft_ecc_cnt back	to maxerr
 10950                                  dskerr1:				
 10951 00000B78 58                      		pop	ax		; restore sector count
 10952                                  		;jmp	retry
 10953                                  		; 09/12/2022
 10954 00000B79 E9F9FE                  		jmp	_retry
 10955                                  ; ---------------------------------------------------------------------------
 10956                                  
 10957                                  write_fault_err:			
 10958 00000B7C BD0100                  		mov	bp, 1		; just retry only once
 10959                                  					; for write fault error.
 10960 00000B7F EBF7                    		jmp	short dskerr1
 10961                                  
 10962                                  		; fall into harderr
 10963                                  ; ---------------------------------------------------------------------------
 10964                                  
 10965                                  ; entry point for routines that call maperror themselves
 10966                                  
 10967                                  harderr:				
 10968 00000B81 E84D00                  		call	maperror
 10969                                  harderr2:				
 10970 00000B84 C606[1E01]FF            		mov	byte [tim_drv], 0FFh
 10971                                  					; force a media check through rom
 10972 00000B89 8B0E[2201]              		mov	cx, [seccnt]	; get count of sectors to go
 10973 00000B8D 8B26[3501]              		mov	sp, [spsav]	; recover entry	stack pointer
 10974                                  
 10975                                  ; since we are performing a non-local goto, restore the disk parameters
 10976                                  
 10977                                  		;jmp	diddleback
 10978                                  		; 09/12/2022
 10979 00000B91 E958FE                  		jmp	diddle_back
 10980                                  
 10981                                  ; =============== S U B	R O U T	I N E =======================================
 10982                                  
 10983                                  ; change settle value from settlecurrent to whatever is appropriate
 10984                                  ; note that this routine is never called for a fixed disk.
 10985                                  
 10986                                  		; 19/10/2022
 10987                                  normspeed:
 10988 00000B94 803E[3806]00            		cmp	byte [media_set_for_format], 0
 10989 00000B99 751E                    		jnz	short fastspeed
 10990 00000B9B 06                      		push	es
 10991 00000B9C 50                      		push	ax
 10992 00000B9D A0[2801]                		mov	al, [settleslow]
 10993 00000BA0 C436[2D01]              		les	si, [dpt]	; current disk parm table
 10994 00000BA4 26884409                		mov	[es:si+9], al	; [es:si+DISK_PARMS.DISK_HEAD_STTL]
 10995 00000BA8 58                      		pop	ax
 10996 00000BA9 07                      		pop	es
 10997 00000BAA E80C00                  		call	fastspeed
 10998 00000BAD 06                      		push	es
 10999 00000BAE C436[2D01]              		les	si, [dpt]
 11000 00000BB2 26C6440901              		mov	byte [es:si+9], 1 ; [es:si+DISK_PARMS.DISK_HEAD_STTL]
 11001                                  					; 1 is fast settle value
 11002 00000BB7 07                      		pop	es
 11003 00000BB8 C3                      		retn
 11004                                  
 11005                                  ; =============== S U B	R O U T	I N E =======================================
 11006                                  
 11007                                  ; if the drive has been marked as too big (i.e. starting sector of the
 11008                                  ; partition is > 16 bits, then always return drive not ready.
 11009                                  
 11010                                  fastspeed:		
 11011 00000BB9 26F6451F80              		test	byte [es:di+1Fh], 80h ; [es:di+BDS.fatsiz]
 11012                                  					; ftoobig
 11013 00000BBE 750D                    		jnz	short notready
 11014 00000BC0 06                      		push	es
 11015 00000BC1 8E06[3705]              		mov	es, [xfer_seg]
 11016 00000BC5 CD13                    		int	13h		; DISK -
 11017 00000BC7 8C06[3705]              		mov	[xfer_seg], es
 11018 00000BCB 07                      		pop	es
 11019 00000BCC C3                      		retn
 11020                                  ; ---------------------------------------------------------------------------
 11021                                  
 11022                                  notready:				
 11023 00000BCD F9                      		stc
 11024 00000BCE B480                    		mov	ah, 80h
 11025 00000BD0 C3                      		retn
 11026                                  
 11027                                  ; =============== S U B	R O U T	I N E =======================================
 11028                                  
 11029                                  ; map error returned by rom in ah into corresponding code to be returned to
 11030                                  ; dos in al. trashes di. guaranteed to set carry.
 11031                                  
 11032                                  maperror:	
 11033 00000BD1 51                      		push	cx
 11034 00000BD2 06                      		push	es
 11035 00000BD3 1E                      		push	ds		; set es=Bios_Data
 11036 00000BD4 07                      		pop	es
 11037 00000BD5 88E0                    		mov	al, ah		; put error code in al
 11038 00000BD7 A2[4401]                		mov	[lsterr], al	; terminate list with error code
 11039 00000BDA B90900                  		mov	cx, 9		; numerr (= errout-errin)
 11040                                  					; number of possible error conditions
 11041 00000BDD BF[3C01]                		mov	di, errin	; point to error conditions
 11042 00000BE0 F2AE                    		repne scasb
 11043                                  		; 10/12/2022
 11044 00000BE2 8A4508                  		mov	al, [di+8]	; [di+numerr-1]
 11045                                  					; get translation
 11046                                  		; 19/10/2022 - Temporary ! 
 11047                                  		;db	8Ah, 85h, 8, 0	; mov al, [di+8]
 11048 00000BE5 07                      		pop	es
 11049 00000BE6 59                      		pop	cx
 11050 00000BE7 F9                      		stc			; flag error condition
 11051 00000BE8 C3                      		retn
 11052                                  
 11053                                  ; =============== S U B	R O U T	I N E =======================================
 11054                                  
 11055                                  ; set the time of last access for this drive.
 11056                                  ; this is done only for removable media. es:di -> bds
 11057                                  
 11058                                  set_tim:		
 11059 00000BE9 50                      		push	ax
 11060 00000BEA E88DF8                  		call	GetTickCnt	; Does INT 1A ah=0 & updates daycnt
 11061                                  
 11062                                  ; we have the new time. if we see that the time has passed,
 11063                                  ; then we reset the threshold counter...
 11064                                  
 11065 00000BED 263B5547                		cmp	dx, [es:di+47h]	; [es:di+BDS.tim_lo]
 11066 00000BF1 7506                    		jnz	short setaccess
 11067 00000BF3 263B4D49                		cmp	cx, [es:di+49h]	; [es:di+BDS.tim_hi]
 11068                                  		;jz	short done_set
 11069                                  		; 12/12/2022
 11070 00000BF7 740E                    		je	short done_set2
 11071                                  setaccess:				
 11072 00000BF9 C606[1D01]00            		mov	byte [accesscount], 0
 11073 00000BFE 26895547                		mov	[es:di+47h], dx	; [es:di+BDS.tim_lo]
 11074 00000C02 26894D49                		mov	[es:di+49h], cx	; [es:di+BDS.tim_hi]
 11075                                  done_set:				
 11076 00000C06 F8                      		clc
 11077                                  done_set2:		; 12/12/2022
 11078 00000C07 58                      		pop	ax
 11079 00000C08 C3                      		retn
 11080                                  
 11081                                  ; =============== S U B	R O U T	I N E =======================================
 11082                                  
 11083                                  ; this routine is called if an error occurs while formatting or verifying.
 11084                                  ; it resets the drive,and decrements the retry count.
 11085                                  ; on entry - ds:di - points to bds for the drive
 11086                                  ;	     bp    - contains retry count
 11087                                  ; on exit    flags indicate result of decrementing retry count
 11088                                  
 11089                                  again:	
 11090 00000C09 E87004                  		call	ResetDisk
 11091 00000C0C 80FC06                  		cmp	ah, 6
 11092 00000C0F 7402                    		jz	short dont_dec_retry_count ; If	it is a	media change error
 11093                                  					; do not decrement retry count.
 11094 00000C11 4D                      		dec	bp		; decrement retry count
 11095 00000C12 C3                      		retn
 11096                                  ; ---------------------------------------------------------------------------
 11097                                  
 11098                                  dont_dec_retry_count:			
 11099 00000C13 08E4                    		or	ah, ah
 11100 00000C15 C3                      		retn
 11101                                  
 11102                                  ; 16/10/2022 - Retro DOS 4.0 (Modified MSDOS 5.0 IO.SYS)
 11103                                  
 11104                                  ;----------------------------------------------------------------------------
 11105                                  ; MSDIOCTL.ASM - MSDOS 6.0 - 1991
 11106                                  ;----------------------------------------------------------------------------
 11107                                  ; 11/03/2019 - Retro DOS v4.0
 11108                                  
 11109                                  ; 18/03/2019
 11110                                  
 11111                                  ; ==========================================================================
 11112                                  ;
 11113                                  ; NOTE: GetAccessFlag/SetAccessFlag is unpublished function.
 11114                                  ;
 11115                                  ;      This function is intended to give the user to control the
 11116                                  ;      bds table flags of unformatted_media bit.
 11117                                  ;      GetAccessFlag will show the status -
 11118                                  ;	 a_DiskAccess_Control.dac_access_flag = 0 disk i/o not allowed
 11119                                  ;						1 disk i/o allowed
 11120                                  ;      SetAccessFlag will set/reset the unformatted_media bit in flags -
 11121                                  ;	 a_DiskAccess_Control.dac_access_flag = 0 allow disk i/o
 11122                                  ;						1 disallow disk i/o
 11123                                  ; ==========================================================================
 11124                                  
 11125                                  		; generic ioctl dispatch tables
 11126                                  
 11127                                  ; BIOSCODE:0C3Ch (MSDOS 6.21, IO.SYS)
 11128                                  
 11129                                  ; ---------------------------------------------------------------------------
 11130 00000C16 00                      		db 0
 11131                                  
 11132                                  ; 09/12/2022 
 11133                                  %if 0
 11134                                  
 11135                                  IoReadJumpTable: db 8	; ((IoWriteJumpTable-IoReadJumpTable)-1)/2
 11136                                  		dw 0CA7h	; 60h	; GetDeviceParameters
 11137                                  		dw 0EE8h	; 61h	; ReadTrack
 11138                                  		dw 0E86h	; 62h	; VerifyTrack
 11139                                  		dw 0CA3h	 	; Cmd_Error_Proc
 11140                                  		dw 0CA3h		; Cmd_Error_Proc
 11141                                  		dw 0CA3h		; Cmd_Error_Proc
 11142                                  		dw 119Ah	; 66h	; GetMediaId
 11143                                  		dw 1269h	; 67h	; GetAccessFlag ; unpublished function
 11144                                  		dw 12C1h	; 68h	; SenseMediaType
 11145                                  
 11146                                  IoWriteJumpTable: db 7	; ((IOC_DC_Table-IoWriteJumpTable)-1)/2
 11147                                  		dw 0CF3h	; 40h	; SetDeviceParameters
 11148                                  		dw 0EEFh	; 41h	; WriteTrack
 11149                                  		dw 0DC1h	; 42h	; FormatTrack
 11150                                  		dw 0CA3h		; Cmd_Error_Proc
 11151                                  		dw 0CA3h		; Cmd_Error_Proc
 11152                                  		dw 0CA3h		; Cmd_Error_Proc
 11153                                  		dw 11D2h	; 46h	; SetMediaId
 11154                                  		dw 1280h	; 47h	; SetAccessFlag ; unpublished function
 11155                                  
 11156                                  %endif
 11157                                  
 11158                                  		; 09/12/2022
 11159 00000C17 09                      IoReadJumpTable: db ((IoWriteJumpTable-IoReadJumpTable)-1)/2 ; 8
 11160 00000C18 [820C]                  		dw GetDeviceParameters	; 60h
 11161 00000C1A [BD0E]                  		dw ReadTrack		; 61h
 11162 00000C1C [5D0E]                  		dw VerifyTrack		; 62h
 11163 00000C1E [7E0C]                  		dw Cmd_Error_Proc
 11164 00000C20 [7E0C]                  		dw Cmd_Error_Proc
 11165 00000C22 [7E0C]                  		dw Cmd_Error_Proc
 11166 00000C24 [5E11]                  		dw GetMediaId		; 66h
 11167 00000C26 [2A12]                  		dw GetAccessFlag	; 67h ; unpublished function
 11168 00000C28 [7C12]                  		dw SenseMediaType	; 68h
 11169                                  
 11170 00000C2A 08                      IoWriteJumpTable: db ((IOC_DC_Table-IoWriteJumpTable)-1)/2 ; 7
 11171 00000C2B [CD0C]                  		dw SetDeviceParameters	; 40h
 11172 00000C2D [C40E]                  		dw WriteTrack		; 41h
 11173 00000C2F [980D]                  		dw FormatTrack		; 42h
 11174 00000C31 [7E0C]                  		dw Cmd_Error_Proc
 11175 00000C33 [7E0C]                  		dw Cmd_Error_Proc
 11176 00000C35 [7E0C]                  		dw Cmd_Error_Proc
 11177 00000C37 [9411]                  		dw SetMediaId		; 46h
 11178 00000C39 [4012]                  		dw SetAccessFlag	; 47h ; unpublished function
 11179                                  
 11180                                  ; ==========================================================================
 11181                                  ; IOC_DC_Table
 11182                                  ;
 11183                                  ; This table contains all of the valid generic IOCtl Minor codes for
 11184                                  ; major function 08 to be used by the Ioctl_Support_Query function.
 11185                                  ; Added for 5.00
 11186                                  ; ==========================================================================
 11187                                  
 11188 00000C3B 60                      IOC_DC_Table:	db 60h			; GET_DEVICE_PARAMETERS
 11189 00000C3C 40                      		db 40h			; SET_DEVICE_PARAMETERS
 11190 00000C3D 61                      		db 61h			; READ_TRACK
 11191 00000C3E 41                      		db 41h			; WRITE_TRACK
 11192 00000C3F 62                      		db 62h			; VERIFY_TRACK
 11193 00000C40 42                      		db 42h			; FORMAT_TRACK
 11194 00000C41 66                      		db 66h			; GET_MEDIA_ID
 11195 00000C42 46                      		db 46h			; SET_MEDIA_ID
 11196 00000C43 67                      		db 67h			; GET_ACCESS_FLAG
 11197 00000C44 47                      		db 47h			; SET_ACCESS_FLAG
 11198 00000C45 68                      		db 68h			; SENSE_MEDIA_TYPE
 11199                                  
 11200                                  ;IOC_DC_TABLE_LEN EQU $ - IOC_DC_Table
 11201                                  
 11202                                  ; ---------------------------------------------------------------------------
 11203                                  
 11204                                  ; 16/10/2022
 11205                                  
 11206                                  ; ==========================================================================
 11207                                  ; Do_Generic_IOCtl: perform generic ioctl request
 11208                                  ;
 11209                                  ;    input: AL contains logical drive
 11210                                  ;
 11211                                  ;	functions are dispatched through a call. On return, carry indicates
 11212                                  ;	error code in al. Note::bES:b& ds undefined on return from
 11213                                  ;	subfunctions.
 11214                                  ;
 11215                                  ; ==========================================================================
 11216                                  
 11217                                  ; 11/03/2019
 11218                                  		; 19/10/2022
 11219                                  do_generic_ioctl:			; 2C7h:0C6Bh = 70h:31DBh
 11220 00000C46 E882F8                  		call	SetDrive	; ES:DI	Points to bds for drive
 11221 00000C49 06                      		push	es
 11222 00000C4A C41E[1200]              		les	bx, [ptrsav]	; ES:BX	Points to request header
 11223 00000C4E 26807F0D08              		cmp	byte [es:bx+0Dh], 8 ; [es:bx+IOCTL_REQ.MAJORFUNCTION]
 11224                                  					; RAWIO
 11225 00000C53 268A470E                		mov	al, [es:bx+0Eh]	; [es:bx+IOCTL_REQ.MINORFUNCTION]
 11226 00000C57 07                      		pop	es
 11227 00000C58 7525                    		jnz	short IoctlFuncErr
 11228                                  
 11229                                  		; cas note: Could do the above two blocks in reverse order.
 11230                                  		; Would have to preserve al for SetDrive
 11231                                  
 11232                                  		; 10/12/2022
 11233 00000C5A BE[170C]                		mov	si, IoReadJumpTable
 11234                                  		;mov	si, 0C3Ch	; IoReadJumpTable
 11235                                  					; at 2C7h:0C3Ch	= 70h:31ACh
 11236 00000C5D A820                    		test	al, 20h		; GEN_IOCTL_FN_TST ; test of req. function
 11237 00000C5F 7503                    		jnz	short NotGenericWrite ; function is a read.
 11238                                  		; 10/12/2022
 11239 00000C61 BE[2A0C]                		mov	si, IoWriteJumpTable
 11240                                  		;mov	si, 0C4Fh	; IoWriteJumpTable
 11241                                  					; at 2C7h:0C4Fh	= 70h:31BFh
 11242                                  NotGenericWrite:			
 11243 00000C64 24DF                    		and	al, 0DFh	; ~GEN_IOCTL_FN_TST ; get rid of read/write bit
 11244 00000C66 2C40                    		sub	al, 40h		; offset for base function
 11245 00000C68 2E3A04                  		cmp	al, [cs:si]
 11246 00000C6B 7712                    		ja	short IoctlFuncErr
 11247 00000C6D 98                      		cbw
 11248 00000C6E D1E0                    		shl	ax, 1
 11249 00000C70 46                      		inc	si
 11250 00000C71 01C6                    		add	si, ax
 11251 00000C73 2EFF14                  		call	near [cs:si]
 11252                                  		;call	word ptr cs:[si]
 11253 00000C76 2E8E1E[3000]            		mov	ds, [cs:BIOSDATAWORD]
 11254                                  		;mov	ds, word ptr cs:BIOSDATAWORD ; [cs:Bios_Data_Word]
 11255                                  					; 2C7h:30h = 70h:25A0h
 11256 00000C7B B481                    		mov	ah, 81h		; Return this status in	case of	carry
 11257 00000C7D C3                      		retn			; Pass carry flag through to exit code
 11258                                  ; ---------------------------------------------------------------------------
 11259                                  
 11260                                  		; Cmd_Error_Proc is called as a procedure and also use
 11261                                  		; as a fall through from above
 11262                                  Cmd_Error_Proc:				; 2C7h:0CA3h = 70h:3213h
 11263 00000C7E 5A                      		pop	dx
 11264                                  
 11265                                  IoctlFuncErr:				
 11266 00000C7F E953F4                  		jmp	bc_cmderr
 11267                                  ; ---------------------------------------------------------------------------
 11268                                  
 11269                                  ; 16/10/2022
 11270                                  
 11271                                  ; ==========================================================================
 11272                                  ;**	GetDeviceParameters:
 11273                                  ;
 11274                                  ;	GetDeviceParameters implements the generic ioctl function:
 11275                                  ;	majorcode=RAWIO, minorcode=GetDeviceParameters (60h)
 11276                                  ;
 11277                                  ;	ENTRY	(ES:di) = BDS for drive
 11278                                  ;		PtrSav = long pointer to request header
 11279                                  ;	EXIT	??? BUGBUG
 11280                                  ;	USES	??? BUGBUG
 11281                                  ; ==========================================================================
 11282                                  
 11283                                  		; 19/10/2022
 11284                                  GetDeviceParameters:
 11285                                  		; Copy info from bds to the device parameters packet
 11286                                  
 11287 00000C82 C51E[1200]              		lds	bx, [ptrsav]	; DS:BX	points to request header
 11288 00000C86 C55F13                  		lds	bx, [bx+19]	; [bx+IOCTL_REQ.GENERICIOCTL_PACKET]
 11289                                  					; (DS:BX) = return buffer
 11290 00000C89 268A4522                		mov	al, [es:di+34]	; [es:di+BDS.formfactor]
 11291 00000C8D 884701                  		mov	[bx+1],	al	; [bx+A_DEVICEPARAMETERS.DP_DEVICETYPE]
 11292 00000C90 268B4523                		mov	ax, [es:di+35]	; [es:di+BDS.flags]
 11293 00000C94 83E003                  		and	ax, 3		; fnon_removable+fchangeline
 11294                                  					; Mask off other bits
 11295 00000C97 894702                  		mov	[bx+2],	ax	; [bx+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES]
 11296 00000C9A 268B4525                		mov	ax, [es:di+37]	; [es:di+BDS.cylinders]
 11297 00000C9E 894704                  		mov	[bx+4],	ax	; [bx+A_DEVICEPARAMETERS.DP_CYLINDERS]
 11298 00000CA1 30C0                    		xor	al, al		; Set media type to default
 11299 00000CA3 884706                  		mov	[bx+6],	al	; [bx+A_DEVICEPARAMETERS.DP_MEDIATYPE]
 11300                                  					
 11301                                  		; copy recommended bpb
 11302 00000CA6 8D7527                  		lea	si, [di+39]	; [di+BDS.rbytespersec]	= [di+BDS.R_BPB]
 11303 00000CA9 F60701                  		test	byte [bx], 1	; [bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS]
 11304                                  					; BUILD_DEVICE_BPB
 11305 00000CAC 7412                    		jz	short UseBpbPresent
 11306 00000CAE 1E                      		push	ds		; Save request packet segment
 11307 00000CAF 2E8E1E[3000]            		mov	ds, [cs:BIOSDATAWORD]
 11308                                  		;mov	ds, word ptr cs:BIOSDATAWORD ; [cs:Bios_Data_Word]
 11309                                  					; 2C7h:30h = 70h:25A0h
 11310                                  					; Point back to Bios_Data
 11311 00000CB4 E885FB                  		call	checksingle
 11312 00000CB7 E83EF9                  		call	GetBp		; Build	the bpb	from scratch
 11313 00000CBA 1F                      		pop	ds		; Restore request packet segment
 11314 00000CBB 720F                    		jb	short GetParmRet
 11315 00000CBD 8D7506                  		lea	si, [di+6]	; [di+BDS.bytespersec] = [di+BSD.DP_BPB]
 11316                                  					; Use this subfield of bds instead
 11317                                  UseBpbPresent:				
 11318 00000CC0 8D7F07                  		lea	di, [bx+7]	; [bx+A_DEVICEPARAMETERS.DP_BPB]
 11319                                  					; This is where	the result goes
 11320 00000CC3 B91900                  		mov	cx, 25		; A_BPB.size - 6
 11321                                  					; For now use 'small' bpb
 11322 00000CC6 1E                      		push	ds		; reverse segments for copy
 11323 00000CC7 06                      		push	es
 11324 00000CC8 1F                      		pop	ds
 11325 00000CC9 07                      		pop	es
 11326 00000CCA F3A4                    		rep movsb
 11327                                  		
 11328                                  		; 12/12/2022
 11329                                  		; cf=0 (test instruction -above- resets cf) 	
 11330                                  		;clc
 11331                                  GetParmRet:				
 11332 00000CCC C3                      		retn
 11333                                  ; ---------------------------------------------------------------------------
 11334                                  
 11335                                  ; 17/10/2022
 11336                                  ; 16/10/2022
 11337                                  
 11338                                  ; ==========================================================================
 11339                                  ; SetDeviceParameters:
 11340                                  ;
 11341                                  ; input: ES:di points to bds for drive
 11342                                  ; ==========================================================================
 11343                                  
 11344                                  		; 19/10/2022
 11345                                  SetDeviceParameters:			; 2C7h:0CF3h = 70h:3263h
 11346 00000CCD C51E[1200]              		lds	bx, [ptrsav]	; DS:BX	points to request header
 11347 00000CD1 C55F13                  		lds	bx, [bx+19]	; [bx+IOCTL_REQ.GENERICIOCTL_PACKET]
 11348 00000CD4 26814D234001            		or	word [es:di+23h], 140h ; [es:di+BDS.flags]
 11349                                  					; fchanged_by_format|fchanged
 11350 00000CDA F60702                  		test	byte [bx], 2	; [bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS]
 11351                                  					; ONLY_SET_TRACKLAYOUT
 11352 00000CDD 7579                    		jnz	short setTrackTable
 11353 00000CDF 8A4701                  		mov	al, [bx+1]	; [bx+A_DEVICEPARAMETERS.DP_DEVICETYPE]
 11354 00000CE2 26884522                		mov	[es:di+34], al	; [es:di+BDS.formfactor]
 11355 00000CE6 8B4704                  		mov	ax, [bx+4]	; [bx+A_DEVICEPARAMETERS.DP_CYLINDERS]
 11356 00000CE9 26894525                		mov	[es:di+37], ax	; [es:di+BDS.cylinders]
 11357 00000CED 8B4702                  		mov	ax, [bx+2]	; [bx+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES]
 11358 00000CF0 1E                      		push	ds
 11359                                  		; 17/10/2022
 11360 00000CF1 2E8E1E[3000]            		mov	ds, [cs:BIOSDATAWORD]
 11361                                  		;mov	ds, word ptr cs:BIOSDATAWORD ; [cs:Bios_Data_Word]
 11362                                  					; 2C7h:30h = 70h:25A0h
 11363                                  		;cmp	byte [fhave96], 0
 11364 00000CF6 803E[7700]00            		cmp	byte [fhave96], 0
 11365 00000CFB 1F                      		pop	ds
 11366 00000CFC 7502                    		jnz	short HaveChange ; we have changeline support
 11367                                  		; 10/12/2022
 11368 00000CFE 24FD                    		and	al, 0FDh
 11369                                  		;and	ax, 0FFFDh	; ~fchangeline
 11370                                  
 11371                                  		; Ignore all bits except non_removable and changeline
 11372                                  HaveChange:				
 11373 00000D00 83E003                  		and	ax, 3		; fnon_removable|fchangeline
 11374 00000D03 268B4D23                		mov	cx, [es:di+35]	; [es:di+BDS.flags]
 11375 00000D07 81E1F4FD                		and	cx, 0FDF4h	; ~(fnon_removable|fchangeline|good_tracklayout|unformatted_media)
 11376 00000D0B 09C8                    		or	ax, cx
 11377 00000D0D 26894523                		mov	[es:di+35], ax	; [es:di+BDS.flags]
 11378 00000D11 8A4706                  		mov	al, [bx+6]	; [bx+A_DEVICEPARAMETERS.DP_MEDIATYPE]
 11379                                  					; Set media type
 11380 00000D14 1E                      		push	ds
 11381 00000D15 2E8E1E[3000]            		mov	ds, [cs:BIOSDATAWORD]
 11382                                  		;mov	ds, word ptr cs:BIOSDATAWORD ; [cs:Bios_Data_Word]
 11383 00000D1A A2[3706]                		mov	[mediatype], al
 11384                                  		;mov	ds:mediatype, al
 11385 00000D1D 1F                      		pop	ds
 11386                                  
 11387                                  		; The media changed (maybe) so we will have to do a set dasd
 11388                                  		; the next time we format a track
 11389                                  
 11390                                  		; 10/12/2022
 11391 00000D1E 26804D2380              		or	byte [es:di+35], 80h
 11392                                  		;or	word [es:di+35], 80h ; [es:di+BDS.flags]
 11393                                  					; set_dasd_true
 11394 00000D23 57                      		push	di		; Save bds pointer
 11395                                  
 11396                                  		; Figure out what we are supposed to do with the bpb
 11397                                  		; were we asked to install a fake bpb?
 11398                                  
 11399 00000D24 F60701                  		test	byte [bx], 1	; [bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS]
 11400                                  					; INSTALL_FAKE_BPB
 11401 00000D27 7514                    		jnz	short InstallFakeBpb
 11402                                  
 11403                                  		; were we returning a fake bpb when asked to build a bpb?
 11404                                  
 11405                                  		; 10/12/2022
 11406 00000D29 26F6452304              		test	byte [es:di+35], 4
 11407                                  		;test	word [es:di+35], 4 ; [es:di+BDS.flags]
 11408                                  					; return_fake_bpb
 11409 00000D2E 7405                    		jz	short InstallRecommendedBpb
 11410                                  
 11411                                  		; we were returning a fake bpb but we can stop now
 11412                                  
 11413                                  		; 10/12/2022
 11414 00000D30 26806523FB              		and	byte [es:di+35], 0FBh
 11415                                  		;and	word [es:di+35], 0FFFBh ; [es:di+BDS.flags]
 11416                                  					; ~return_fake_bpb
 11417                                  InstallRecommendedBpb:			
 11418 00000D35 B91F00                  		mov	cx, 31		; A_BPB.size
 11419 00000D38 8D7D27                  		lea	di, [di+27h]	; [di+BDS.R_BPB] = [di+BDS.rbytespersec]
 11420 00000D3B EB0B                    		jmp	short CopyTheBpb
 11421                                  ; ---------------------------------------------------------------------------
 11422                                  
 11423                                  InstallFakeBpb:
 11424                                  		; 10/12/2022
 11425 00000D3D 26804D2304              		or	byte [es:di+35], 4				
 11426                                  		;or	word [es:di+35], 4 ; byte [es:di+BDS.flags]
 11427                                  					; return_fake_bpb
 11428 00000D42 B91900                  		mov	cx, 25		; A_BPB.size - 6
 11429                                  					; move 'smaller' bpb
 11430 00000D45 8D7D06                  		lea	di, [di+6]	; [es:di+BDS.BPB] = [es:di+BDS.bytespersec]
 11431                                  
 11432                                  CopyTheBpb:				
 11433 00000D48 8D7707                  		lea	si, [bx+7]	; [bx+A_DEVICEPARAMETERS.DP_BPB]
 11434 00000D4B F3A4                    		rep movsb
 11435 00000D4D 1E                      		push	ds		; Save packet segment
 11436                                  		; 17/10/2022
 11437 00000D4E 2E8E1E[3000]            		mov	ds, [cs:BIOSDATAWORD]
 11438                                  		;mov	ds, word ptr cs:BIOSDATAWORD ; [cs:Bios_Data_Word]
 11439                                  					; Setup	for ds -> Bios_Data
 11440 00000D53 E8DA03                  		call	RestoreOldDpt	; Restore the old Dpt from TempDpt
 11441 00000D56 1F                      		pop	ds		; Restore packet segment
 11442 00000D57 5F                      		pop	di		; Restore bds pointer
 11443                                  setTrackTable:				
 11444 00000D58 8B4F26                  		mov	cx, [bx+38]
 11445 00000D5B 1E                      		push	ds
 11446 00000D5C 2E8E1E[3000]            		mov	ds, [cs:BIOSDATAWORD]
 11447 00000D61 890E[3905]              		mov	[sectorspertrack], cx
 11448 00000D65 1F                      		pop	ds
 11449                                  		; 10/12/2022
 11450 00000D66 26806523F7              		and	byte [es:di+35], 0F7h
 11451                                  		;and	word [es:di+35], 0FFF7h ; [es:di+BDS.flags]
 11452                                  					; ~good_tracklayout
 11453 00000D6B F60704                  		test	byte [bx], 4	; [bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS]
 11454                                  					; TRACKLAYOUT_IS_GOOD
 11455 00000D6E 7405                    		jz	short UglyTrackLayOut
 11456                                  		; 10/12/2022
 11457 00000D70 26804D2308              		or	byte [es:di+35], 8
 11458                                  		;or	word [es:di+35], 8 ; [es:di+BDS.flags]
 11459                                  					; good_tracklayout
 11460                                  UglyTrackLayOut:			
 11461 00000D75 83F93F                  		cmp	cx, 63		; MAX_SECTORS_IN_TRACK
 11462 00000D78 771A                    		ja	short TooManyPerTrack
 11463                                  		;jcxz	short SectorInfoSaved
 11464 00000D7A E316                    		jcxz	SectorInfoSaved	; 19/10/2022
 11465 00000D7C BF[3B05]                		mov	di, tracktable
 11466 00000D7F 8D7728                  		lea	si, [bx+40]	; [bx+A_DEVICEPARAMETERS.DP_SECTORTABLE]
 11467                                  		; 17/10/2022
 11468 00000D82 2E8E06[3000]            		mov	es, [cs:BIOSDATAWORD]
 11469                                  		;mov	es, word ptr cs:BIOSDATAWORD ; [cs:Bios_Data_Word]
 11470                                  					; Trash	our bds	pointer
 11471                                  StoreSectorInfo:			
 11472 00000D87 47                      		inc	di
 11473 00000D88 47                      		inc	di		; Skip over cylinder and head
 11474 00000D89 AD                      		lodsw			; Get sector id
 11475 00000D8A AA                      		stosb			; Copy it
 11476 00000D8B AD                      		lodsw			; Get sector size
 11477 00000D8C E8E301                  		call	SectSizeToSectIndex
 11478 00000D8F AA                      		stosb			; Store	sector SIZE index
 11479 00000D90 E2F5                    		loop	StoreSectorInfo
 11480                                  SectorInfoSaved:			
 11481 00000D92 F8                      		clc
 11482 00000D93 C3                      		retn
 11483                                  ; ---------------------------------------------------------------------------
 11484                                  
 11485                                  TooManyPerTrack:			
 11486 00000D94 B00C                    		mov	al, 0Ch
 11487 00000D96 F9                      		stc
 11488 00000D97 C3                      		retn
 11489                                  ; ---------------------------------------------------------------------------
 11490                                  
 11491                                  ; 16/10/2022
 11492                                  
 11493                                  ; ==========================================================================
 11494                                  ; FormatTrack:
 11495                                  ; if specialfunction byte is 1,then this is a status call to see if there is
 11496                                  ; rom support for the combination of sec/trk and # of cyln,and if the
 11497                                  ; combination is legal. if specialfunction byte is 0,then format the track.
 11498                                  ;
 11499                                  ; input: ES:di points to bds for drive
 11500                                  ;
 11501                                  ; output:
 11502                                  ;	for status call:
 11503                                  ;	specialfunction byte set to:
 11504                                  ;		0 - rom support + legal combination
 11505                                  ;		1 - no rom support
 11506                                  ;		2 - illegal combination
 11507                                  ;		3 - no media present
 11508                                  ;	carry cleared.
 11509                                  ;
 11510                                  ;	for format track:
 11511                                  ;		carry set if error
 11512                                  ;
 11513                                  ; ==========================================================================
 11514                                  
 11515                                  ; 16/03/2019
 11516                                  
 11517                                  		; 19/10/2022
 11518                                  FormatTrack:
 11519 00000D98 C51E[1200]              		lds	bx, [ptrsav]
 11520 00000D9C C55F13                  		lds	bx, [bx+19]	; [bx+IOCTL_REQ.GENERICIOCTL_PACKET
 11521 00000D9F F60701                  		test	byte [bx], 1	; [bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS]
 11522                                  					; STATUS_FOR_FORMAT
 11523 00000DA2 740E                    		jz	short DoFormatTrack
 11524 00000DA4 1E                      		push	ds
 11525                                  		; 17/10/2022
 11526 00000DA5 2E8E1E[3000]            		mov	ds, [cs:BIOSDATAWORD]
 11527                                  		;mov	ds, word ptr cs:BIOSDATAWORD ; [cs:Bios_Data_Word]
 11528 00000DAA E83902                  		call	SetMediaForFormat ; Also moves current Dpt to TempDpt
 11529 00000DAD 1F                      		pop	ds
 11530 00000DAE 8807                    		mov	[bx], al	; [bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS]
 11531 00000DB0 F8                      		clc
 11532 00000DB1 C3                      		retn
 11533                                  ; ---------------------------------------------------------------------------
 11534                                  
 11535                                  DoFormatTrack:				
 11536 00000DB2 26807D2205              		cmp	byte [es:di+34], 5 ; [es:di+BDS.formfactor]
 11537                                  					; DEV_HARDDISK
 11538 00000DB7 7508                    		jnz	short DoFormatDiskette
 11539                                  		; 17/10/2022
 11540 00000DB9 2E8E1E[3000]            		mov	ds, [cs:BIOSDATAWORD]
 11541                                  		;mov	ds, word ptr cs:BIOSDATAWORD ; [cs:Bios_Data_Word]
 11542                                  					; Point	to Bios_Data (at 2C7h:30h or 70h:25A0h)
 11543 00000DBE E99C00                  		jmp	VerifyTrack
 11544                                  ; ---------------------------------------------------------------------------
 11545                                  
 11546                                  DoFormatDiskette:			
 11547 00000DC1 8B4F01                  		mov	cx, [bx+1]
 11548 00000DC4 8B5703                  		mov	dx, [bx+3]
 11549 00000DC7 F60702                  		test	byte [bx], 2
 11550                                  		; 17/10/2022
 11551 00000DCA 2E8E1E[3000]            		mov	ds, [cs:BIOSDATAWORD]
 11552                                  		;mov	ds, word ptr cs:BIOSDATAWORD ; [cs:Bios_Data_Word]
 11553                                  					; Setup	ds-> Bios_Data for verify
 11554 00000DCF 7403                    		jz	short DoFormatDiskette_1
 11555 00000DD1 E9E400                  		jmp	VerifyTrack_Err
 11556                                  ; ---------------------------------------------------------------------------
 11557                                  
 11558                                  DoFormatDiskette_1:			
 11559 00000DD4 E80F02                  		call	SetMediaForFormat ; Also moves current Dpt to TempDpt
 11560 00000DD7 3C01                    		cmp	al, 1		;  ROM support for sec/trk,# trks comb?
 11561 00000DD9 7406                    		jz	short NeedToSetDasd ; Old rom
 11562 00000DDB 3C03                    		cmp	al, 3		; Time out error?
 11563 00000DDD 7507                    		jnz	short NoSetDasd	; No,fine. (at this point, don't care
 11564                                  					; about	the illegal combination)
 11565 00000DDF EB67                    		jmp	short FormatFailed
 11566                                  ; ---------------------------------------------------------------------------
 11567                                  
 11568                                  NeedToSetDasd:				
 11569 00000DE1 52                      		push	dx
 11570 00000DE2 E8A001                  		call	SetDasd		; INT 13h, AH=17h
 11571 00000DE5 5A                      		pop	dx
 11572                                  NoSetDasd:				
 11573 00000DE6 E853FA                  		call	checksingle	; Do any needed	diskette swapping
 11574 00000DE9 89D0                    		mov	ax, dx		; Get track from packet
 11575 00000DEB A3[3901]                		mov	[trknum], ax
 11576 00000DEE 880E[3801]              		mov	[hdnum], cl	; Store	head from packet
 11577 00000DF2 88CC                    		mov	ah, cl
 11578 00000DF4 BB[3B05]                		mov	bx, tracktable
 11579 00000DF7 8B0E[3905]              		mov	cx, [sectorspertrack]
 11580                                  
 11581                                  StoreCylinderHead:			
 11582 00000DFB 8907                    		mov	[bx], ax	; Store	into TrackTable
 11583 00000DFD 83C304                  		add	bx, 4		; Skip to next sector field
 11584 00000E00 E2F9                    		loop	StoreCylinderHead
 11585 00000E02 B90500                  		mov	cx, 5		; MAXERR - Set up retry	count
 11586                                  FormatRetry:				
 11587 00000E05 51                      		push	cx
 11588 00000E06 BB[3B05]                		mov	bx, tracktable
 11589 00000E09 A0[3905]                		mov	al, [sectorspertrack]
 11590 00000E0C B405                    		mov	ah, 5		; romformat
 11591 00000E0E 8C1E[3705]              		mov	[xfer_seg], ds
 11592 00000E12 E87F02                  		call	ToRom
 11593 00000E15 59                      		pop	cx
 11594 00000E16 7216                    		jb	short FormatError
 11595 00000E18 51                      		push	cx		; Now verify the sectors just formatted.
 11596                                  					; NOTE:	because	of bug in some BIOSes we have to
 11597                                  					;	set ES:BX to 00:00
 11598 00000E19 53                      		push	bx
 11599 00000E1A 31DB                    		xor	bx, bx
 11600 00000E1C 891E[3705]              		mov	[xfer_seg], bx
 11601 00000E20 A0[3905]                		mov	al, [sectorspertrack]
 11602 00000E23 B404                    		mov	ah, 4		; romverify
 11603 00000E25 B101                    		mov	cl, 1
 11604 00000E27 E86A02                  		call	ToRom
 11605 00000E2A 5B                      		pop	bx
 11606 00000E2B 59                      		pop	cx
 11607 00000E2C 7329                    		jnb	short FormatOk
 11608                                  FormatError:				
 11609 00000E2E E84B02                  		call	ResetDisk
 11610 00000E31 C606[3906]01            		mov	byte [had_format_error], 1
 11611 00000E36 50                      		push	ax
 11612 00000E37 51                      		push	cx
 11613 00000E38 52                      		push	dx
 11614 00000E39 E8AA01                  		call	SetMediaForFormat
 11615 00000E3C 3C01                    		cmp	al, 1
 11616 00000E3E 7503                    		jnz	short WhileErr
 11617 00000E40 E84201                  		call	SetDasd
 11618                                  WhileErr:				
 11619 00000E43 5A                      		pop	dx
 11620 00000E44 59                      		pop	cx
 11621 00000E45 58                      		pop	ax
 11622 00000E46 E2BD                    		loop	FormatRetry
 11623                                  FormatFailed:				
 11624 00000E48 C606[3906]01            		mov	byte [had_format_error], 1
 11625                                  					; Set the format error flag
 11626 00000E4D 80FC06                  		cmp	ah, 6		; DSK_CHANGELINE_ERR - convert change line
 11627 00000E50 7502                    		jnz	short DoMapIt	; Error	to time	out error
 11628 00000E52 B480                    		mov	ah, 80h		; DSK_TIMEOUT_ERR
 11629                                  DoMapIt:				
 11630 00000E54 E97AFD                  		jmp	maperror
 11631                                  ; ---------------------------------------------------------------------------
 11632                                  
 11633                                  FormatOk:				
 11634 00000E57 C606[3906]00            		mov	byte [had_format_error], 0 ; reset the format error flag
 11635 00000E5C C3                      		retn
 11636                                  ; ---------------------------------------------------------------------------
 11637                                  
 11638                                  ; 16/10/2022
 11639                                  
 11640                                  ; ==========================================================================
 11641                                  ;
 11642                                  ; VerifyTrack:
 11643                                  ;
 11644                                  ; input: ES:di points to bds for drive
 11645                                  ; ==========================================================================
 11646                                  
 11647                                  VerifyTrack:				
 11648 00000E5D 1E                      		push	ds
 11649 00000E5E C51E[1200]              		lds	bx, [ptrsav]	; DS:BX points to request header.
 11650 00000E62 C55F13                  		lds	bx, [bx+19]	; [bx+IOCTL_REQ.GENERICIOCTL_PACKET]
 11651                                  
 11652                                  		; Come here with DS:[BX] -> packet, ES:[DI] -> bds
 11653                                  
 11654 00000E65 8B4F03                  		mov	cx, [bx+3]	; [bx+A_VERIFYPACKET.VP_CYLINDER]
 11655 00000E68 8B4701                  		mov	ax, [bx+1]	; [bx+A_VERIFYPACKET.VP_HEAD]
 11656 00000E6B 8B5705                  		mov	dx, [bx+5]	; [bx+A_FORMATPACKET.FP_TRACKCOUNT]
 11657 00000E6E 8A1F                    		mov	bl, [bx]	; [bx+A_FORMATPACKET.FP_SPECIALFUNCTIONS]
 11658                                  					; Get option flag word
 11659 00000E70 1F                      		pop	ds
 11660 00000E71 C606[2001]04            		mov	byte [rflag], 4	; romverify
 11661 00000E76 890E[3301]              		mov	[curtrk], cx
 11662 00000E7A A2[3201]                		mov	[curhd], al	; ASSUME heads < 256
 11663 00000E7D 8B0E[3905]              		mov	cx, [sectorspertrack]
 11664                                  
 11665                                  		; Check specialfunctions to see if DO_FAST_FORMAT has been
 11666                                  		; specified if not we should go to the normal track verification
 11667                                  		; routine. If fast format has been specified we should get the
 11668                                  		; number of tracks to be verified and check it to see if it is
 11669                                  		; > 255. If it is then it is an error and we should go to
 11670                                  		; VerifyTrack_Err. If not multiply the number of tracks by the
 11671                                  		; sectors per track to get the total number of sectors to be
 11672                                  		; verified. This should also be less than equal to 255
 11673                                  		; otherwise we go to same error exit. If everything is okay
 11674                                  		; we initalise cx to the total sectors. use ax as a temporary
 11675                                  		; register.
 11676                                  
 11677                                  					; Special function requested?	
 11678 00000E81 F6C302                  		test	bl, 2		; DO_FAST_FORMAT
 11679 00000E84 7421                    		jz	short NormVerifyTrack
 11680 00000E86 89D0                    		mov	ax, dx		; Get ax = number of trks to verify
 11681 00000E88 08E4                    		or	ah, ah
 11682 00000E8A 752C                    		jnz	short VerifyTrack_Err ; #tracks > 255
 11683 00000E8C F6E1                    		mul	cl
 11684 00000E8E 08E4                    		or	ah, ah
 11685 00000E90 7526                    		jnz	short VerifyTrack_Err ; #sectors > 255	
 11686 00000E92 89C1                    		mov	cx, ax
 11687                                  		; 10/12/2022
 11688 00000E94 26F6452301              		test	byte [es:di+35], 1
 11689                                  		;test	word [es:di+35], 1 ; [es:di+BDS.flags]
 11690                                  					; fnon_removable
 11691 00000E99 740C                    		jz	short NormVerifyTrack
 11692                                  					; Multitrack operation = on?
 11693                                  		; 10/12/2022
 11694                                  		; 19/10/2022
 11695 00000E9B F606[2F05]80            		test	byte [multrk_flag], 80h
 11696                                  		;test	word [multrk_flag], 80h ; MULTI_TRK_ON
 11697                                  		;;test	ds:multrk_flag,	80h ; MULTI_TRK_ON
 11698 00000EA0 7405                    		jz	short NormVerifyTrack
 11699 00000EA2 C606[3605]01            		mov	byte [multitrk_format_flag], 1
 11700                                  NormVerifyTrack:			
 11701 00000EA7 31C0                    		xor	ax, ax		; 1st sector
 11702 00000EA9 31DB                    		xor	bx, bx
 11703 00000EAB 891E[3705]              		mov	[xfer_seg], bx	; Use 0:0 as the transfer address for verify
 11704 00000EAF E83F00                  		call	TrackIo
 11705 00000EB2 C606[3605]00            		mov	byte [multitrk_format_flag], 0
 11706 00000EB7 C3                      		retn
 11707                                  ; ---------------------------------------------------------------------------
 11708                                  
 11709                                  VerifyTrack_Err:			
 11710 00000EB8 B401                    		mov	ah, 1
 11711 00000EBA E914FD                  		jmp	maperror
 11712                                  ; ---------------------------------------------------------------------------
 11713                                  
 11714                                  ; 16/10/2022
 11715                                  
 11716                                  ; ==========================================================================
 11717                                  ;
 11718                                  ; ReadTrack:
 11719                                  ;
 11720                                  ; input: ES:di points to bds for drive
 11721                                  ;
 11722                                  ; ==========================================================================
 11723                                  
 11724                                  ReadTrack:				
 11725 00000EBD C606[2001]02            		mov	byte [rflag], 2	; romread
 11726 00000EC2 EB05                    		jmp	short ReadWriteTrack
 11727                                  ; ---------------------------------------------------------------------------
 11728                                  
 11729                                  WriteTrack:
 11730                                  
 11731                                  ; ==========================================================================
 11732                                  ;
 11733                                  ; WriteTrack:
 11734                                  ;
 11735                                  ; input: ES:di points to bds for drive
 11736                                  ;
 11737                                  ; ==========================================================================
 11738                                  				
 11739 00000EC4 C606[2001]03            		mov	byte [rflag], 3	; romwrite
 11740                                  
 11741                                  		; Fall into ReadWriteTrack
 11742                                  
 11743                                  ; ==========================================================================
 11744                                  ;
 11745                                  ; readWriteTrack:
 11746                                  ;
 11747                                  ; input:
 11748                                  ;    ES:di points to bds for drive
 11749                                  ;    rFlag - 2 for read,3 for write
 11750                                  ;
 11751                                  ; ==========================================================================
 11752                                  
 11753                                  ReadWriteTrack:	
 11754                                  		; save bds pointer segment so we can use it to access
 11755                                  		; our packet. Notice that this is not the standard register
 11756                                  		; assignment for accessing packets
 11757                                  		
 11758                                  		; 19/10/2022	
 11759 00000EC9 06                      		push	es
 11760 00000ECA C41E[1200]              		les	bx, [ptrsav]	; ES:BX	-> to request header
 11761 00000ECE 26C45F13                		les	bx, [es:bx+19]	; [es:bx+IOCTL_REQ.GENERICIOCTL_PACKET]
 11762 00000ED2 268B4703                		mov	ax, [es:bx+3]	; [es:bx+A_TRACKREADWRITEPACKET.TRWP_CYLINDER]
 11763 00000ED6 A3[3301]                		mov	[curtrk], ax
 11764 00000ED9 268B4701                		mov	ax, [es:bx+1]	; [es:bx+A_TRACKREADWRITEPACKET.TRWP_HEAD]
 11765 00000EDD A2[3201]                		mov	[curhd], al	; Assume heads < 256!!!
 11766 00000EE0 268B4705                		mov	ax, [es:bx+5]	; [es:bx+A_TRACKREADWRITEPACKET.TRWP_FIRSTSECTOR]
 11767 00000EE4 268B4F07                		mov	cx, [es:bx+7]	; [es:bx+A_TRACKREADWRITEPACKET.TRWP_SECTORSTOREADWRITE]
 11768 00000EE8 26C45F09                		les	bx, [es:bx+9]	; [es:bx+A_TRACKREADWRITEPACKET.TRWP_TRANSFERADDRESS]
 11769                                  					; Get transfer address
 11770                                  
 11771                                  		; we just trashed our packet address, but we no longer care
 11772                                  
 11773 00000EEC 8C06[3705]              		mov	[xfer_seg], es	; Pass transfer	segment
 11774 00000EF0 07                      		pop	es
 11775                                  
 11776                                  		; Fall into TrackIo
 11777                                  
 11778                                  ; =============== S U B	R O U T	I N E =======================================
 11779                                  
 11780                                  ; 16/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 11781                                  
 11782                                  ; ==========================================================================
 11783                                  ;
 11784                                  ; TrackIo:
 11785                                  ;    performs track read/write/verify
 11786                                  ;
 11787                                  ;   input:
 11788                                  ;      rFlag	- 2 = read
 11789                                  ;		  3 = write
 11790                                  ;		  4 = verify
 11791                                  ;      AX	- Index into track table of first sector to io
 11792                                  ;      CX	- Number of sectors to io
 11793                                  ;      Xfer_Seg:BX - Transfer address
 11794                                  ;      ES:DI	- Pointer to bds
 11795                                  ;      CurTrk	- Current cylinder
 11796                                  ;      CurHd	- Current head
 11797                                  ;
 11798                                  ; ==========================================================================
 11799                                  
 11800                                  ; 16/03/2019 - Retro DOS v4.0
 11801                                  		
 11802                                  		; 19/10/2022
 11803                                  TrackIo:	
 11804                                  					; Procedure `disk' will pop stack to
 11805 00000EF1 8926[3501]              		mov	[spsav], sp	; SpSav	and return if error
 11806 00000EF5 E844F9                  		call	checksingle	; Ensure correct disk is in drv
 11807 00000EF8 803E[3806]01            		cmp	byte [media_set_for_format], 1
 11808                                  					; See if we have already set	disk
 11809 00000EFD 7407                    		jz	short Dptalreadyset ; base table
 11810 00000EFF 50                      		push	ax		; set up tables	and variables for i/o
 11811 00000F00 51                      		push	cx
 11812 00000F01 E896FA                  		call	iosetup
 11813 00000F04 59                      		pop	cx
 11814 00000F05 58                      		pop	ax
 11815                                  Dptalreadyset:				; Point si at the table entry of the			
 11816 00000F06 BE[3B05]                		mov	si, tracktable	; first sector to be io'd
 11817 00000F09 D1E0                    		shl	ax, 1
 11818 00000F0B D1E0                    		shl	ax, 1
 11819 00000F0D 01C6                    		add	si, ax
 11820                                  
 11821                                  		; WE WANT:
 11822                                  		; CX to	be the number of times we have to loop
 11823                                  		; DX to	be the number of sectors we read on each iteration
 11824                                  		
 11825 00000F0F BA0100                  		mov	dx, 1
 11826                                  		; 12/12/2022
 11827 00000F12 26F6452308              		test	byte [es:di+23h], 8
 11828                                  		;test	word [es:di+35], 8 ; [es:di+BDS.flags]
 11829                                  					; good_tracklayout
 11830 00000F17 7402                    		jz	short ionextsector
 11831                                  		
 11832 00000F19 87D1                    		xchg	dx, cx		; HEY! We can read all secs in one blow
 11833                                  ionextsector:				
 11834 00000F1B 51                      		push	cx
 11835 00000F1C 52                      		push	dx
 11836 00000F1D 46                      		inc	si
 11837 00000F1E 46                      		inc	si		; Skip over the	cylinder and head in
 11838                                  					; the track table
 11839 00000F1F AC                      		lodsb			; Get sector ID	from track table
 11840 00000F20 A2[3101]                		mov	[cursec], al
 11841                                  
 11842                                  		; assumptions for a fixed disk multi-track disk	i/o
 11843                                  		; 1). In the input CX (# of sectors to go) to TrackIo,
 11844                                  		;     only CL is valid.
 11845                                  		; 2). Sector size should be set	to 512 bytes.
 11846                                  		; 3). Good track layout
 11847                                  		
 11848                                  		; 12/12/2022
 11849 00000F23 26F6452301              		test	byte [es:di+23h], 1
 11850                                  		;test	word [es:di+35], 1 ; [es:di+BDS.flags]
 11851                                  					; fnon_removable ; Fixed disk?
 11852 00000F28 7414                    		jz	short IoRemovable ; No
 11853                                  		; 12/12/2022
 11854 00000F2A F606[2F05]80            		test	byte [multrk_flag], 80h
 11855                                  		;test	word [multrk_flag], 80h ; MULTI_TRK_ON
 11856                                  						; Allow multi-track operation?
 11857 00000F2F 740D                    		jz	short IoRemovable ; No,don't do that.
 11858 00000F31 8916[2201]              		mov	[seccnt], dx
 11859 00000F35 89D0                    		mov	ax, dx
 11860 00000F37 E81DFB                  		call	Disk
 11861 00000F3A 5A                      		pop	dx
 11862 00000F3B 59                      		pop	cx
 11863 00000F3C F8                      		clc
 11864 00000F3D C3                      		retn
 11865                                  ; ---------------------------------------------------------------------------
 11866                                  
 11867                                  IoRemovable:				
 11868 00000F3E AC                      		lodsb			; Get sector size index	from track
 11869                                  					; table	and save it
 11870 00000F3F 50                      		push	ax
 11871 00000F40 56                      		push	si
 11872 00000F41 1E                      		push	ds		; Save Bios_Data
 11873 00000F42 50                      		push	ax
 11874 00000F43 8A26[2C01]              		mov	ah, [eot]	; Preserve whatever might be in	ah
 11875                                  					; Fetch	EOT while ds-> Bios_Data
 11876 00000F47 C536[2D01]              		lds	si, [dpt]
 11877 00000F4B 884403                  		mov	[si+3],	al	; [si+DISK_PARMS.DISK_SECTOR_SIZ]
 11878 00000F4E 886404                  		mov	[si+4],	ah	; [si+DISK_PARMS.DISK_EOT]
 11879 00000F51 58                      		pop	ax
 11880 00000F52 1F                      		pop	ds
 11881 00000F53 88D0                    		mov	al, dl
 11882 00000F55 A3[2201]                		mov	[seccnt], ax
 11883 00000F58 E8FCFA                  		call	Disk
 11884 00000F5B 5E                      		pop	si		; Advance buffer pointer by adding
 11885                                  					; sector size
 11886 00000F5C 58                      		pop	ax
 11887 00000F5D E81D00                  		call	SectorSizeIndexToSectorSize
 11888 00000F60 01C3                    		add	bx, ax
 11889 00000F62 5A                      		pop	dx
 11890 00000F63 59                      		pop	cx
 11891 00000F64 E2B5                    		loop	ionextsector
 11892 00000F66 803E[3806]01            		cmp	byte [media_set_for_format], 1
 11893                                  		;jz	short NoNeedDone
 11894                                  		; 12/12/2022
 11895 00000F6B 7404                    		je	short NoNeedDone2
 11896 00000F6D E872FA                  		call	done		; set time of last access, and reset
 11897                                  					; entries in Dpt.
 11898                                  NoNeedDone:				
 11899 00000F70 F8                      		clc
 11900                                  NoNeedDone2:
 11901 00000F71 C3                      		retn
 11902                                  
 11903                                  ; =============== S U B	R O U T	I N E =======================================
 11904                                  
 11905                                  ; ---------------------------------------------------------------------------
 11906                                  ;
 11907                                  ; The sector size in bytes needs to be converted to an index value for the ibm
 11908                                  ; rom. (0=>128,1=>256,2=>512,3=>1024). It is assumed that only these values
 11909                                  ; are permissible.
 11910                                  ;
 11911                                  ; On Input   AX contains sector size in bytes
 11912                                  ; On Output  AL Contains index
 11913                                  ; All other registers preserved
 11914                                  ;
 11915                                  ; ---------------------------------------------------------------------------
 11916                                  
 11917                                  SectSizeToSectIndex:	
 11918 00000F72 80FC02                  		cmp	ah, 2		; (0=>128,1=>256,2=>512,3=>1024)
 11919                                  					; examine upper	byte only
 11920 00000F75 7703                    		ja	short OneK
 11921 00000F77 88E0                    		mov	al, ah		; value	in AH is the index!
 11922 00000F79 C3                      		retn
 11923                                  ; ---------------------------------------------------------------------------
 11924                                  
 11925                                  OneK:					
 11926 00000F7A B003                    		mov	al, 3
 11927 00000F7C C3                      		retn
 11928                                  
 11929                                  ; =============== S U B	R O U T	I N E =======================================
 11930                                  
 11931                                  
 11932                                  SectorSizeIndexToSectorSize:
 11933 00000F7D 88C1                    		mov	cl, al
 11934 00000F7F B88000                  		mov	ax, 128
 11935 00000F82 D3E0                    		shl	ax, cl
 11936 00000F84 C3                      		retn
 11937                                  
 11938                                  ; =============== S U B	R O U T	I N E =======================================
 11939                                  
 11940                                  ; 16/10/2022
 11941                                  
 11942                                  ; ---------------------------------------------------------------------------
 11943                                  ;
 11944                                  ; SetDASD
 11945                                  ;
 11946                                  ; Set up the rom for formatting.
 11947                                  ; we have to tell the rom bios what type of disk is in the drive.
 11948                                  ;
 11949                                  ; On Input   - ES:di - Points to bds
 11950                                  ;
 11951                                  ; ---------------------------------------------------------------------------
 11952                                  
 11953                                  		; 19/10/2022
 11954                                  SetDasd:	
 11955 00000F85 803E[3906]01            		cmp	byte [had_format_error], 1 ;
 11956                                  					; See if we've previously set dasd type
 11957 00000F8A 740C                    		jz	short DoSetDasd
 11958                                  		; 10/12/2022
 11959 00000F8C 26F6452380              		test	byte [es:di+23h], 80h
 11960                                  		;test	word [es:di+23h], 80h ; [es:di+BDS.flags]
 11961                                  					; set_dasd_true
 11962 00000F91 744A                    		jz	short DasdHasBeenSet
 11963                                  		; 10/12/2022
 11964 00000F93 268065237F              		and	byte [es:di+23h], 7Fh
 11965                                  		;and	word [es:di+23h], 0FF7Fh ; [es:di+BDS.flags]
 11966                                  					; ~set_dasd_true
 11967                                  DoSetDasd:				
 11968 00000F98 C606[3906]00            		mov	byte [had_format_error], 0 ; Reset it
 11969 00000F9D C606[3B01]50            		mov	byte [gap_patch], 50h ; Format gap for 48tpi disks
 11970 00000FA2 B004                    		mov	al, 4
 11971 00000FA4 26807D2202              		cmp	byte [es:di+22h], 2 ; [es:di+BDS.formfactor]
 11972                                  					; DEV_3INCH720KB
 11973 00000FA9 741A                    		jz	short DoSet
 11974 00000FAB 26807D2201              		cmp	byte [es:di+22h], 1 ; [es:di+BDS.formfactor]
 11975                                  					; DEV_5INCH96TPI
 11976 00000FB0 7404                    		jz	short GotBig
 11977 00000FB2 B001                    		mov	al, 1
 11978 00000FB4 EB0F                    		jmp	short DoSet
 11979                                  ; ---------------------------------------------------------------------------
 11980                                  
 11981                                  GotBig:					
 11982 00000FB6 B002                    		mov	al, 2		; 160/320k in a	1.2 meg	drive
 11983 00000FB8 803E[3706]00            		cmp	byte [mediatype], 0
 11984 00000FBD 7506                    		jnz	short DoSet
 11985                                  		;mov	al, 3		; 1.2meg in a 1.2meg drive
 11986                                  		; 10/12/2022
 11987                                  		;inc	al  ; al = 3
 11988                                  		; 18/12/2022
 11989 00000FBF 40                      		inc	ax  ; al = 3
 11990 00000FC0 C606[3B01]54            		mov	byte [gap_patch], 54h
 11991                                  DoSet:					
 11992 00000FC5 1E                      		push	ds
 11993 00000FC6 56                      		push	si
 11994 00000FC7 8E1E[1A00]              		mov	ds, [zeroseg]	; Point	to interrupt vectors
 11995                                  
 11996 00000FCB C5367800                		lds	si, [DSKADR]
 11997                                  		;lds	si, [78h]	; [DSKADR]  (Int 1Eh)
 11998                                  		;;lds	si, ds:78h		
 11999                                  
 12000 00000FCF C644090F                		mov	byte [si+9], 0Fh ;
 12001                                  					; [si+DISK_PARMS.DISK_HEAD_STTL]
 12002 00000FD3 5E                      		pop	si
 12003 00000FD4 1F                      		pop	ds
 12004 00000FD5 B417                    		mov	ah, 17h
 12005 00000FD7 268A5504                		mov	dl, [es:di+4]
 12006 00000FDB CD13                    		int	13h		; DISK - DISK -	SET TYPE (AT,XT2,XT286,CONV,PS
 12007                                  					; AL = disk type AL = 03h - high-capacity disk in high-capacity	drive
 12008                                  DasdHasBeenSet:				
 12009 00000FDD 268A6513                		mov	ah, [es:di+13h]	; [es:di+BDS.secpertrack]
 12010 00000FE1 8826[3701]              		mov	[formt_eot], ah
 12011 00000FE5 C3                      		retn
 12012                                  
 12013                                  ; =============== S U B	R O U T	I N E =======================================
 12014                                  
 12015                                  ; 16/10/2022
 12016                                  
 12017                                  ; ---------------------------------------------------------------------------
 12018                                  ;
 12019                                  ; Set Media Type for Format
 12020                                  ; Performs the int 13 with ah = 18h to see if the medium described in the
 12021                                  ; BPB area in the BDS can be handled by the rom.
 12022                                  ; On Input, ES:DI -> current BDS.
 12023                                  ; The status of the operation is returned in AL
 12024                                  ;
 12025                                  ;	- 0 - if the support is available,and the combination is valid.
 12026                                  ;	- 1 - no rom support
 12027                                  ;	- 2 - illegal combination
 12028                                  ;	- 3 - no media present (rom support exists but cannot determine now)
 12029                                  ;
 12030                                  ; Flags also may be altered. All other registers preserved.
 12031                                  ; If the call to rom returns no error,then the current Dpt is "replaced" by
 12032                                  ; the one returned by the rom. This is Done by changing the pointer in [Dpt]
 12033                                  ; to the one returned. the original pointer to the disk base table is stored
 12034                                  ; in TempDpt, until it is restored.
 12035                                  ;
 12036                                  ; ---------------------------------------------------------------------------
 12037                                  
 12038                                  		; 19/10/2022
 12039                                  SetMediaForFormat:	
 12040 00000FE6 51                      		push	cx
 12041 00000FE7 52                      		push	dx
 12042                                  
 12043                                  		; If we have a format error, then do not change Dpt, TempDpt.
 12044                                  		; but we need to call int 13h, ah=18h again.
 12045                                  
 12046 00000FE8 803E[3906]01            		cmp	byte [had_format_error], 1
 12047 00000FED 7425                    		jz	short SkipSaveDskAdr
 12048 00000FEF 30C0                    		xor	al, al		; If already done return 0
 12049 00000FF1 803E[3806]01            		cmp	byte [media_set_for_format], 1
 12050 00000FF6 7502                    		jnz	short DoSetMediaForFormat
 12051 00000FF8 EB7F                    		jmp	SetMediaRet	; Media	already	set
 12052                                  ; ---------------------------------------------------------------------------
 12053                                  
 12054                                  DoSetMediaForFormat:			
 12055 00000FFA 06                      		push	es
 12056 00000FFB 56                      		push	si
 12057 00000FFC 8E06[1A00]              		mov	es, [zeroseg]	; Point to interrupt vectors
 12058 00001000 26C4367800              		les	si, [es:DSKADR]
 12059                                  		;les	si, es:78h	; [es:DSKADR]
 12060                                  					; Get pointer to disk base table
 12061 00001005 8936[2D01]              		mov	[dpt], si
 12062 00001009 8C06[2F01]              		mov	[dpt+2], es	; Save pointer to table
 12063                                  
 12064                                  		; Initialize the head settle time to 0Fh. See the offsets
 12065                                  		; given in dskprm.inc.
 12066                                  
 12067 0000100D 26C644090F              		mov	byte [es:si+9], 0Fh ; [es:si+DISK_PARMS.DISK_HEAD_STTL]
 12068 00001012 5E                      		pop	si
 12069 00001013 07                      		pop	es
 12070                                  
 12071                                  SkipSaveDskAdr:				
 12072 00001014 268B4D25                		mov	cx, [es:di+25h]	; [es:di+BDS.cylinders]
 12073 00001018 49                      		dec	cx
 12074 00001019 80E503                  		and	ch, 3
 12075 0000101C D0CD                    		ror	ch, 1
 12076 0000101E D0CD                    		ror	ch, 1
 12077 00001020 86E9                    		xchg	ch, cl
 12078 00001022 260A4D13                		or	cl, [es:di+13h]	; [es:di+BDS.secpertrack]
 12079 00001026 268A5504                		mov	dl, [es:di+4]	; [es:di+BDS.drivenum]
 12080 0000102A 06                      		push	es
 12081 0000102B 1E                      		push	ds
 12082 0000102C 56                      		push	si
 12083 0000102D 57                      		push	di
 12084 0000102E B418                    		mov	ah, 18h
 12085 00001030 CD13                    		int	13h		; DISK - SET MEDIA TYPE	FOR FORMAT (AT model 3x9,XT2,XT286,PS)
 12086                                  					; DL = drive number, CH	= lower	8 bits of number of tracks, CL = sectors per track
 12087 00001032 7233                    		jb	short FormaStatErr
 12088 00001034 803E[3906]01            		cmp	byte [had_format_error], 1
 12089 00001039 7425                    		jz	short skip_disk_base_setting
 12090 0000103B 06                      		push	es		; Save segment returned	by the rom
 12091 0000103C 8E06[1A00]              		mov	es, [zeroseg]	; Point	to interrupt vector segment
 12092 00001040 26C4367800              		les	si, [es:DSKADR]
 12093                                  		;les	si, es:78h	; [es:DSKADR] (Int 1Eh)
 12094                                  					; Get current disk base	table
 12095 00001045 8936[3A06]              		mov	[tempdpt], si
 12096 00001049 8C06[3C06]              		mov	[tempdpt+2], es ; Save it
 12097 0000104D 8E06[1A00]              		mov	es, [zeroseg]
 12098                                  		;mov	es:78h,	di
 12099 00001051 26893E7800              		mov	[es:DSKADR], di
 12100                                  		;pop	word ptr es:7Ah	; replace with one returned by rom
 12101 00001056 268F067A00              		pop	word [es:DSKADR+2]
 12102 0000105B C606[3806]01            		mov	byte [media_set_for_format], 1
 12103                                  skip_disk_base_setting:			
 12104 00001060 30C0                    		xor	al, al		; Legal	combination + rom support code
 12105                                  		;mov	ds:had_format_error, al	; Reset	the flag
 12106 00001062 A2[3906]                		mov	[had_format_error], al
 12107 00001065 EB0E                    		jmp	short PopStatRet
 12108                                  ; ---------------------------------------------------------------------------
 12109                                  
 12110                                  FormaStatErr:
 12111                                  		; 10/12/2022
 12112 00001067 B003                    		mov	al, 3
 12113                                  				
 12114 00001069 80FC0C                  		cmp	ah, 0Ch		; DSK_ILLEGAL_COMBINATION
 12115                                  					; Illegal combination =	0Ch
 12116 0000106C 7406                    		jz	short FormatStatIllegalComb
 12117 0000106E 80FC80                  		cmp	ah, 80h		; DSK_TIMEOUT_ERR
 12118 00001071 7402                    		jz	short FormatStatTimeOut
 12119                                  		; 10/12/2022
 12120                                  		;dec	al
 12121                                  		; 18/12/2022
 12122 00001073 48                      		dec	ax
 12123                                  		; al = 2
 12124                                  		;mov	al, 1		; Function not supported.
 12125                                  		;jmp	short PopStatRet
 12126                                  ; ---------------------------------------------------------------------------
 12127                                  
 12128                                  FormatStatIllegalComb:
 12129                                  		; 10/12/2022
 12130                                  		;dec	al	; 3 -> 2 or 2 -> 1
 12131                                  		; 18/12/2022
 12132 00001074 48                      		dec	ax
 12133                                  		; al = 2				
 12134                                  		;mov	al, 2		; Function supported, but
 12135                                  					; Illegal sect/trk,trk combination.
 12136                                  		; 10/12/2022
 12137                                  		;jmp	short PopStatRet
 12138                                  ; ---------------------------------------------------------------------------
 12139                                  
 12140                                  FormatStatTimeOut:			
 12141                                  		; 10/12/2022
 12142                                  		; al = 3
 12143                                  		;mov	al, 3		; Function supported, but
 12144                                  					; Media	not present.
 12145                                  PopStatRet:				
 12146 00001075 5F                      		pop	di
 12147 00001076 5E                      		pop	si
 12148 00001077 1F                      		pop	ds
 12149 00001078 07                      		pop	es
 12150                                  SetMediaRet:				
 12151 00001079 5A                      		pop	dx
 12152 0000107A 59                      		pop	cx
 12153 0000107B C3                      		retn
 12154                                  
 12155                                  ; =============== S U B	R O U T	I N E =======================================
 12156                                  
 12157                                  ; 16/10/2022
 12158                                  
 12159                                  ; ---------------------------------------------------------------------------
 12160                                  ;
 12161                                  ; RESET THE DRIVE
 12162                                  ;
 12163                                  ; we also set [Step_Drv] to -1 to force the main disk routine to use the
 12164                                  ; slow head settle time for the next operation. this is because the reset
 12165                                  ; operation moves the head to cylinder 0,so we need to do a seek the next
 12166                                  ; time around - there is a problem with 3.5" drives in that the head does
 12167                                  ; not settle down in time,even for read operations!!
 12168                                  ;
 12169                                  ; ---------------------------------------------------------------------------
 12170                                  
 12171                                  ResetDisk:	
 12172 0000107C 50                      		push	ax
 12173 0000107D 803E[3806]01            		cmp	byte [media_set_for_format], 1
 12174                                  					; Reset while formatting?
 12175 00001082 7505                    		jnz	short ResetDisk_cont
 12176                                  					; Then verify operation in "fmt & vrfy"
 12177 00001084 C606[3906]01            		mov	byte [had_format_error], 1 ; Might have failed.
 12178                                  ResetDisk_cont:				
 12179 00001089 30E4                    		xor	ah, ah		; So signals that we had a format error
 12180 0000108B CD13                    		int	13h		; DISK - RESET DISK SYSTEM
 12181                                  					; DL = drive (if bit 7 is set both hard	disks and floppy disks reset)
 12182 0000108D C606[7600]FF            		mov	byte [step_drv], 0FFh ; -1
 12183                                  					; Zap up the speed
 12184 00001092 58                      		pop	ax
 12185 00001093 C3                      		retn
 12186                                  
 12187                                  ; =============== S U B	R O U T	I N E =======================================
 12188                                  
 12189                                  ; 16/10/2022
 12190                                  
 12191                                  ; ---------------------------------------------------------------------------
 12192                                  ;
 12193                                  ; This routine sets up the drive parameter table with the values needed for
 12194                                  ; format,does an int 13. values in Dpt are restored after a verify is done.
 12195                                  ;
 12196                                  ; on entry  -	ES:DI - points to bds for the drive
 12197                                  ;		Xfer_Seg:BX - points to trkbuf
 12198                                  ;		AL    - number of sectors
 12199                                  ;		AH    - int 13 function code
 12200                                  ;		CL    - sector number for verify
 12201                                  ;		DS    - Bios_Data
 12202                                  ;
 12203                                  ; ON EXIT   -	DS,DI,ES,BX remain unchanged.
 12204                                  ;		AX and flags are the results of the int 13
 12205                                  ;
 12206                                  ; ---------------------------------------------------------------------------
 12207                                  
 12208                                  		; 19/10/2022
 12209                                  ToRom:	
 12210 00001094 53                      		push	bx
 12211 00001095 56                      		push	si
 12212                                  
 12213                                  		; Compaq bug fix - check whether we are using new ROM
 12214                                  		; functionality to set up format, not merely if it exists.
 12215                                  		; This was formerly a check against [new_rom]
 12216                                  
 12217 00001096 F606[3806]01            		test	byte [media_set_for_format], 1
 12218 0000109B 7536                    		jnz	short GotValidDpt
 12219 0000109D 50                      		push	ax
 12220 0000109E 06                      		push	es		; Save bds segment
 12221 0000109F 26807D2202              		cmp	byte [es:di+22h], 2 ; [es:di+BDS.formfactor]
 12222                                  					; ffSmall ; is it a 3.5" drive?
 12223 000010A4 9C                      		pushf			; (Save	the cmp	result)
 12224 000010A5 8E06[1A00]              		mov	es, [zeroseg]
 12225                                  		;les	si, es:78h	; Get pointer to disk base table
 12226 000010A9 26C4367800              		les	si, [es:DSKADR]
 12227                                  		;mov	word ptr ds:dpt, si
 12228                                  		;mov	word ptr ds:dpt+2, es ;	 Save pointer to table
 12229 000010AE 8936[2D01]              		mov	[dpt], si
 12230 000010B2 8C06[2F01]              		mov	[dpt+2], es	; Save pointer to table
 12231                                  		
 12232 000010B6 A0[3701]                		mov	al, [formt_eot]
 12233 000010B9 26884404                		mov	[es:si+4], al	; [es:si+DISK_PARMS.DISK_EOT]
 12234 000010BD A0[3B01]                		mov	al, [gap_patch]
 12235 000010C0 26884407                		mov	[es:si+7], al	; [es:si+DISK_PARMS.DISK_FORMT_GAP]
 12236                                  					; Important for	format
 12237 000010C4 26C644090F              		mov	byte [es:si+9], 0Fh ; [es:si+DISK_PARMS.DISK_HEAD_STTL]
 12238                                  					; Assume we are	doing a	seek operation
 12239                                  					; Setup	motor start correctly for 3.5" drives
 12240 000010C9 9D                      		popf			; Get result of	earlier	cmp
 12241 000010CA 7505                    		jnz	short MotorStrtOK
 12242 000010CC 26C6440A04              		mov	byte [es:si+0Ah], 4 ; [es:si+DISK_PARMS.DISK_MOTOR_STRT]
 12243                                  MotorStrtOK:				
 12244 000010D1 07                      		pop	es		; Restore bds segment
 12245 000010D2 58                      		pop	ax
 12246                                  GotValidDpt:				
 12247 000010D3 8B16[3901]              		mov	dx, [trknum]	; Set track number
 12248 000010D7 88D5                    		mov	ch, dl		; Set low 8 bits in ch
 12249 000010D9 268A5504                		mov	dl, [es:di+4]	; Set drive number
 12250 000010DD 8A36[3801]              		mov	dh, [hdnum]	; Set head number
 12251 000010E1 06                      		push	es		; Save bds segment
 12252 000010E2 8E06[3705]              		mov	es, [xfer_seg]
 12253 000010E6 CD13                    		int	13h		; DISK -
 12254 000010E8 07                      		pop	es		; Restore bds segment
 12255 000010E9 5E                      		pop	si
 12256 000010EA 5B                      		pop	bx
 12257 000010EB C3                      		retn
 12258                                  
 12259                                  ; ---------------------------------------------------------------------------
 12260                                  
 12261                                  ; 16/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 12262                                  
 12263                                  ; BIOSCODE:1124h (MSDOS 6.21, IO.SYS)
 12264                                  
 12265                                  ; ==========================================================================
 12266                                  ;
 12267                                  ; get the owner of the physical drive represented by the logical drive in al.
 12268                                  ; the assumption is that we **always** keep track of the owner of a drive!!
 12269                                  ; if this is not the case, the system may hang, just following the linked list.
 12270                                  ;
 12271                                  ; ==========================================================================
 12272                                  
 12273                                  		; 19/10/2022
 12274                                  ioctl_getown:
 12275 000010EC E8DCF3                  		call	SetDrive
 12276 000010EF 268A4504                		mov	al, [es:di+4]	; [es:di+BDS.drivenum]
 12277                                  					; Get physical drive number
 12278 000010F3 C43E[1901]              		les	di, [start_bds] ; Get start of bds chain
 12279                                  ownloop:				
 12280 000010F7 26384504                		cmp	[es:di+4], al	; [es:di+BDS.drivenum]
 12281 000010FB 7507                    		jnz	short getnextBDS
 12282                                  		; 10/12/2022
 12283 000010FD 26F6452320              		test	byte [es:di+23h], 20h
 12284                                  		;test	word [es:di+23h], 20h ; [es:di+BDS.flags]
 12285                                  					; fi_own_physical
 12286 00001102 7515                    		jnz	short exitown
 12287                                  getnextBDS:				
 12288 00001104 26C43D                  		les	di, [es:di]	; [es:di+BDS.link]
 12289 00001107 EBEE                    		jmp	short ownloop
 12290                                  ; ---------------------------------------------------------------------------
 12291                                  
 12292                                  ; ==========================================================================
 12293                                  ;
 12294                                  ; set the ownership of the physical drive represented by the logical drive
 12295                                  ; in al to al.
 12296                                  ;
 12297                                  ; ==========================================================================
 12298                                  
 12299                                  		; 19/10/2022
 12300                                  ioctl_setown:
 12301 00001109 E8BFF3                  		call	SetDrive
 12302 0000110C C606[7A00]01            		mov	byte [fsetowner], 1
 12303                                  					; set flag for CheckSingle to look at.
 12304 00001111 E828F7                  		call	checksingle
 12305 00001114 C606[7A00]00            		mov	byte [fsetowner], 0
 12306                                  					; set ownership	of drive reset flag
 12307                                  		; Fall into ExitOwn
 12308                                  
 12309                                  ; ==========================================================================
 12310                                  ;
 12311                                  ; if there is only one logical drive assigned to this physical drive, return
 12312                                  ; 0 to user to indicate this. Enter with ES:di -> the owner's bds.
 12313                                  ;
 12314                                  ; ==========================================================================
 12315                                  
 12316                                  exitown:				
 12317 00001119 30C9                    		xor	cl, cl
 12318                                  		; 12/12/2022
 12319 0000111B 26F6452310              		test	byte [es:di+23h], 10h
 12320                                  		;test	word [es:di+23h], 10h ; [es:di+BDS.flags]
 12321                                  					; fi_am_mult
 12322 00001120 7406                    		jz	short exitnomult
 12323 00001122 268A4D05                		mov	cl, [es:di+5]	; [es:di+BDS.drivelet]
 12324                                  					; Get logical drive number
 12325                                  					; Get it 1-based
 12326 00001126 FEC1                    		inc	cl
 12327                                  exitnomult:				
 12328 00001128 C51E[1200]              		lds	bx, [ptrsav]
 12329 0000112C 884F01                  		mov	[bx+1],	cl	; [bx+unit]
 12330                                  					; Exit normal termination
 12331                                  		; 12/12/2022
 12332                                  		; cf=0
 12333                                  		;clc
 12334 0000112F C3                      		retn
 12335                                  
 12336                                  ; =============== S U B	R O U T	I N E =======================================
 12337                                  
 12338                                  ; 16/10/2022
 12339                                  
 12340                                  ; ---------------------------------------------------------------------------
 12341                                  ;
 12342                                  ; moves the old Dpt that had been saved in TempDpt back to Dpt. this is done
 12343                                  ; only if the first byte of TempDpt is not -1.
 12344                                  ; all registers (including flags) are preserved.
 12345                                  ;
 12346                                  ; ---------------------------------------------------------------------------
 12347                                  
 12348                                  		; 19/10/2022
 12349                                  RestoreOldDpt:
 12350                                  		; if we have already restored the disk base table earlier,
 12351                                  		; do not do it again.
 12352                                  	
 12353 00001130 50                      		push	ax
 12354 00001131 30C0                    		xor	al, al
 12355 00001133 A2[3906]                		mov	[had_format_error], al	; Reset flag and 
 12356 00001136 8606[3806]              		xchg	al, [media_set_for_format] ; get current flag setting
 12357 0000113A 08C0                    		or	al, al
 12358 0000113C 741E                    		jz	short DontRestore
 12359 0000113E 56                      		push	si
 12360 0000113F 1E                      		push	ds
 12361 00001140 06                      		push	es
 12362 00001141 C536[3A06]              		lds	si, [tempdpt]
 12363                                  
 12364                                  		; 17/10/2022
 12365 00001145 2E8E06[3000]            		mov	es, [cs:BIOSDATAWORD]
 12366                                  		;mov	es, word ptr cs:BIOSDATAWORD ; [cs:Bios_Data_Word]
 12367 0000114A 268E06[1A00]            		mov	es, [es:zeroseg]
 12368                                  		;mov	es, es:zeroseg	; CAS -- bleeeech!
 12369                                  
 12370                                  		;mov	es:78h,	si	; [es:DSKADR]
 12371 0000114F 2689367800              		mov	[es:DSKADR], si
 12372                                  		;mov	word ptr es:7Ah, ds ; [es:DSKADR+2]
 12373 00001154 268C1E7A00              		mov	[es:DSKADR+2], ds
 12374 00001159 07                      		pop	es
 12375 0000115A 1F                      		pop	ds
 12376 0000115B 5E                      		pop	si
 12377                                  DontRestore:				
 12378 0000115C 58                      		pop	ax
 12379                                  		; 12/12/2022
 12380                                  		; cf=0
 12381                                  		;clc			;  Clear carry
 12382 0000115D C3                      		retn
 12383                                  
 12384                                  ; ---------------------------------------------------------------------------
 12385                                  
 12386                                  ; 16/10/2022
 12387                                  
 12388                                  ; ==========================================================================
 12389                                  ;	get media id
 12390                                  ; ==========================================================================
 12391                                  ;
 12392                                  ; FUNCTION: get the volume label,the system id and the serial number from
 12393                                  ;	    the media that has the extended boot record.
 12394                                  ;	    for the conventional media,this routine will return "unknown
 12395                                  ;	    media type" error to dos.
 12396                                  ;
 12397                                  ; INPUT :   ES:di -> bds table for this drive.
 12398                                  ;
 12399                                  ; OUTPUT:   the request packet filled with the information,if not carry.
 12400                                  ;	    if carry set,then al contains the device driver error number
 12401                                  ;	    that will be returned to dos.
 12402                                  ;	    register DS,DX,AX,CX,DI,SI destroyed.
 12403                                  ;
 12404                                  ; SUBROUTINES TO BE CALLED:
 12405                                  ;	BootIo:NEAR
 12406                                  ;
 12407                                  ; LOGIC:
 12408                                  ;	to recognize the extended boot record,this logic will actually
 12409                                  ;	access the boot sector even if it is a hard disk.
 12410                                  ;	note:the valid extended bpb is recognized by looking at the mediabyte
 12411                                  ;	field of bpb and the extended boot signature.
 12412                                  ;
 12413                                  ; {
 12414                                  ;	get logical drive number from bds table;
 12415                                  ;	rFlag = read operation;
 12416                                  ;	BootIo;		 /*get the media boot record into the buffer
 12417                                  ;	if (no error) then
 12418                                  ;	     if (extended boot record) then
 12419                                  ;		{ set volume label,volume serial number and system id
 12420                                  ;		  of the request packet to those of the boot record;
 12421                                  ;		};
 12422                                  ;	     else		  /*not an extended bpb */
 12423                                  ;		{ set register al to "unknown media.." error code;
 12424                                  ;		  set carry bit;
 12425                                  ;		};
 12426                                  ;	else
 12427                                  ;	     ret;	/*already error code is set in the register al
 12428                                  ;
 12429                                  ; ==========================================================================
 12430                                  
 12431                                  ;size_of_EXT_BOOT_SERIAL equ 4
 12432                                  ;;size_of_EXT_BOOT_VOL_LABEL equ 11
 12433                                  ;;size_of_EXT_SYSTEM_ID equ 8
 12434                                  
 12435                                  		; 19/10/2022
 12436                                  GetMediaId:
 12437 0000115E E89F00                  		call	ChangeLineChk
 12438 00001161 268A4505                		mov	al, [es:di+5]	; [es:di+BDS.drivelet] ; Logical drive number
 12439 00001165 C606[2001]02            		mov	byte [rflag], 2	; Read operation
 12440 0000116A E87B00                  		call	BootIo		; Read boot sector into	DiskSector
 12441 0000116D 7224                    		jb	short IOCtl_If1
 12442                                  					; Valid? (0F0h-0FFh?)
 12443 0000116F 803E[6301]F0            		cmp	byte [disksector+15h], 0F0h
 12444                                  					; [disksector+EXT_BOOT.BPB+EBPB.MEDIADESCRIPTOR]
 12445 00001174 721A                    		jb	short IOCtl_If2	; brif not valid (0F0h - 0FFh)
 12446                                  		; 10/12/2022
 12447 00001176 BE[7401]                		mov	si, disksector+26h
 12448 00001179 803C29                  		cmp	byte [si], 29h
 12449                                  		;cmp	byte [disksector+26h], 29h ; [disksector+EXT_BOOT.SIG]
 12450                                  					; EXT_BOOT_SIGNATURE
 12451 0000117C 7512                    		jnz	short IOCtl_If2	; not extended boot record
 12452 0000117E C43E[1200]              		les	di, [ptrsav]	; es:di	points to request header
 12453 00001182 26C47F13                		les	di, [es:bx+19]	; [es:bx+IOCTL_REQ.GENERICIOCTL_PACKET]
 12454                                  		; 10/12/2022
 12455 00001186 46                      		inc	si
 12456                                  		; si = disksector+27h 
 12457                                  		;mov	si, disksector+27h ; disksector+EXT_BOOT.SERIAL
 12458 00001187 83C702                  		add	di, 2		; A_MEDIA_ID_INFO.MI_SERIAL
 12459 0000118A B91700                  		mov	cx, 23		; size_of_EXT_BOOT_SERIAL
 12460                                  					; L+size_of_EXT_BOOT_VOL_LABEL
 12461                                  					; +size_of_EXT_SYSTEM_ID
 12462 0000118D F3A4                    		rep movsb		; Move from Bios_Data into request packet
 12463                                  	
 12464                                  		; 10/12/2022
 12465                                  		; cf = 0
 12466                                  		;clc
 12467                                  
 12468 0000118F C3                      		retn
 12469                                  ; ---------------------------------------------------------------------------
 12470                                  
 12471                                  IOCtl_If2:				
 12472 00001190 B007                    		mov	al, 7		; error_unknown_media
 12473 00001192 F9                      		stc
 12474                                  IOCtl_If1:				
 12475 00001193 C3                      		retn
 12476                                  ; ---------------------------------------------------------------------------
 12477                                  
 12478                                  ; 16/10/2022
 12479                                  
 12480                                  ; ==========================================================================
 12481                                  ;  set media id
 12482                                  ; ==========================================================================
 12483                                  
 12484                                  ; function: set the volume label, the system id and the serial number of
 12485                                  ;	    the media that has the extended boot record.
 12486                                  ;	    for the conventional media, this routine will return "unknown
 12487                                  ;	    media.." error to dos.
 12488                                  ;	    this routine will also set the corresponding informations in
 12489                                  ;	    the bds table.
 12490                                  ;
 12491                                  ; input :   ES:di -> bds table for this drive.
 12492                                  ;
 12493                                  ; output:   the extended boot record in the media will be set according to
 12494                                  ;	    the request packet.
 12495                                  ;	    if carry set, then al contains the device driver error number
 12496                                  ;	    that will be returned to dos.
 12497                                  ;
 12498                                  ; subroutines to be called:
 12499                                  ;	BootIo:NEAR
 12500                                  ;
 12501                                  ; logic:
 12502                                  ;
 12503                                  ; {
 12504                                  ;	get drive_number from bds;
 12505                                  ;	rFlag = "read operation";
 12506                                  ;	BootIo;
 12507                                  ;	if (no error) then
 12508                                  ;	     if (extended boot record) then
 12509                                  ;		{ set volume label,volume serial number and system id
 12510                                  ;		  of the boot record to those of the request packet;
 12511                                  ;		  rFlag = "write operation";
 12512                                  ;		  get drive number from bds;
 12513                                  ;		  BootIo;	  /*write it back*/
 12514                                  ;		};
 12515                                  ;	     else		  /*not an extended bpb */
 12516                                  ;		{ set register al to "unknown media.." error code;
 12517                                  ;		  set carry bit;
 12518                                  ;		  ret;	 /*return back to caller */
 12519                                  ;		};
 12520                                  ;	else
 12521                                  ;	     ret;		 /*already error code is set */
 12522                                  ;
 12523                                  ; ==========================================================================
 12524                                  
 12525                                  		; 19/10/2022
 12526                                  SetMediaId:
 12527 00001194 E86900                  		call	ChangeLineChk
 12528 00001197 268A4505                		mov	al, [es:di+5]	; [es:di+BDS.drivelet]
 12529                                  					; Logical drive	number
 12530 0000119B 88C2                    		mov	dl, al
 12531 0000119D C606[2001]02            		mov	byte [rflag], 2	; romread
 12532 000011A2 52                      		push	dx
 12533 000011A3 E84200                  		call	BootIo		; Read boot sec	to Bios_Data:DiskSector
 12534 000011A6 5A                      		pop	dx
 12535 000011A7 723E                    		jb	short IOCtl_If6
 12536                                  					; Valid? (0F0h-0FFh?)
 12537 000011A9 803E[6301]F0            		cmp	byte [disksector+15h], 0F0h
 12538                                  					; [disksector+EXT_BOOT.BPB+EBPB.MEDIADESCRIPTOR]
 12539 000011AE 7234                    		jb	short IOCtl_If7	; Brif not
 12540 000011B0 803E[7401]29            		cmp	byte [disksector+26h], 29h ; [disksector+EXT_BOOT.SIG]
 12541                                  					; EXT_BOOT_SIGNATURE
 12542 000011B5 752D                    		jnz	short IOCtl_If7	; not extended boot record
 12543 000011B7 06                      		push	es		; Save BDS pointer
 12544 000011B8 57                      		push	di
 12545 000011B9 1E                      		push	ds		; Point	ES To boot record
 12546 000011BA 07                      		pop	es
 12547 000011BB BF[7501]                		mov	di, disksector+27h ; disksector+EXT_BOOT.SERIAL
 12548 000011BE C536[1200]              		lds	si, [ptrsav]	; ds:si	points to request header.
 12549 000011C2 C57413                  		lds	si, [si+19]	; [si+IOCTL_REQ.GENERICIOCTL_PACKET]
 12550 000011C5 83C602                  		add	si, 2		; A_MEDIA_ID_INFO.MI_SERIAL
 12551 000011C8 B91700                  		mov	cx, 23		; size_of_EXT_BOOT_SERIAL
 12552                                  					; +size_of_EXT_BOOT_VOL_LABEL
 12553                                  					; +size_of_EXT_SYSTEM_ID
 12554 000011CB F3A4                    		rep movsb
 12555 000011CD 06                      		push	es		; point	ds back	to Bios_Data
 12556 000011CE 1F                      		pop	ds
 12557 000011CF 5F                      		pop	di		; restore bds pointer
 12558 000011D0 07                      		pop	es
 12559 000011D1 E864F5                  		call	mov_media_ids	; update the bds media id info.
 12560 000011D4 88D0                    		mov	al, dl
 12561 000011D6 C606[2001]03            		mov	byte [rflag], 3	; romwrite
 12562 000011DB E80A00                  		call	BootIo		; write	it back.
 12563 000011DE C606[1E01]FF            		mov	byte [tim_drv], 0FFh
 12564                                  					; make sure chk_media check the driver
 12565                                  					; return with error code from BootIo
 12566 000011E3 C3                      		retn
 12567                                  ; ---------------------------------------------------------------------------
 12568                                  
 12569                                  IOCtl_If7:				
 12570 000011E4 B007                    		mov	al, 7		; error_unknown_media
 12571 000011E6 F9                      		stc
 12572                                  IOCtl_If6:				
 12573 000011E7 C3                      		retn
 12574                                  
 12575                                  ; =============== S U B	R O U T	I N E =======================================
 12576                                  
 12577                                  ; 16/10/2022
 12578                                  
 12579                                  ; ---------------------------------------------------------------------------
 12580                                  ;	BootIo
 12581                                  ; ---------------------------------------------------------------------------
 12582                                  ;
 12583                                  ; function: read/write the boot record into boot sector.
 12584                                  ;
 12585                                  ; input :
 12586                                  ;	    al=logical drive number
 12587                                  ;	    rFlag = operation (read/write)
 12588                                  ;
 12589                                  ; output:   for read operation,the boot record of the drive specified in bds
 12590                                  ;	    be read into the DiskSector buffer.
 12591                                  ;	    for write operation,the DiskSector buffer image will be written
 12592                                  ;	    to the drive specified in bds.
 12593                                  ;	    if carry set,then al contains the device driver error number
 12594                                  ;	    that will be returned to dos.
 12595                                  ;	    AX,CX,DX register destroyed.
 12596                                  ;	    if carry set,then al will contain the error code from DiskIO.
 12597                                  ;
 12598                                  ; subroutines to be called:
 12599                                  ;	DiskIO:NEAR
 12600                                  ;
 12601                                  ; logic:
 12602                                  ;
 12603                                  ; {
 12604                                  ;	first_sector = 0;	 /*logical sector 0 is the boot sector */
 12605                                  ;	sectorcount = 1;	 /*read 1 sector only */
 12606                                  ;	buffer = DiskSector;	 /*read it into the DiskSector buffer */
 12607                                  ;	call DiskIO (rFlag,drive_number,first_sector,sectorcount,buffer);
 12608                                  ; }
 12609                                  ; ==========================================================================
 12610                                  
 12611                                  		; 19/10/2022
 12612                                  BootIo:	
 12613 000011E8 06                      		push	es
 12614 000011E9 57                      		push	di
 12615 000011EA 53                      		push	bx
 12616 000011EB 1E                      		push	ds
 12617 000011EC 07                      		pop	es		; Point ES: to Bios_Data
 12618                                  
 12619                                  		; Call DiskIO to read/write the boot sec. The parameters which
 12620                                  		; need to be initialized for this subroutine out here are
 12621                                  		; - Transfer address to Bios_Data:DiskSector
 12622                                  		; - Low sector needs to be initalized to 0. this is a reg. param
 12623                                  		; - Hi sector in [Start_Sec_H] needs to be initialised to 0.
 12624                                  		; - Number of sectors <-- 1
 12625                                  
 12626 000011ED BF[4E01]                		mov	di, disksector	; es:di -> transfer address
 12627 000011F0 31D2                    		xor	dx, dx		; First	sector (h) -> 0
 12628 000011F2 8916[2B05]              		mov	[start_sec_h], dx ; Start sector (h) -> 0
 12629 000011F6 B90100                  		mov	cx, 1
 12630 000011F9 E8CEF6                  		call	diskio
 12631 000011FC 5B                      		pop	bx
 12632 000011FD 5F                      		pop	di
 12633 000011FE 07                      		pop	es
 12634 000011FF C3                      		retn
 12635                                  
 12636                                  ; =============== S U B	R O U T	I N E =======================================
 12637                                  
 12638                                  ; 16/10/2022
 12639                                  
 12640                                  ; ---------------------------------------------------------------------------
 12641                                  ;	ChangeLineChk
 12642                                  ; ---------------------------------------------------------------------------
 12643                                  ;
 12644                                  ; when the user calls get/set media id call before dos establishes the media
 12645                                  ; by calling "media_chk",the change line activity of the drive is going to be
 12646                                  ; lost.	this routine will check the change line activity and will save the
 12647                                  ; history in the flags.
 12648                                  ;
 12649                                  ; FUNCTION: check the change line error activity
 12650                                  ;
 12651                                  ; INPUT :  ES:di -> bds table.
 12652                                  ;
 12653                                  ; OUTPUT:   flag in bds table will be updated if change line occurs.
 12654                                  ;
 12655                                  ; SUBROUTINES TO BE CALLED:
 12656                                  ;	Set_Changed_DL
 12657                                  ;
 12658                                  ; ---------------------------------------------------------------------------
 12659                                  
 12660                                  ChangeLineChk:	
 12661 00001200 268A5504                		mov	dl, [es:di+4]	; [es:di+BDS.drivenum]
 12662 00001204 08D2                    		or	dl, dl		; Fixed	disk?
 12663 00001206 7821                    		js	short ChangeLnChkRet ; Yes, skip it.
 12664                                  		; 12/12/2022
 12665 00001208 26F6452304              		test	byte [es:di+23h], 4
 12666                                  		;test	word [es:di+23h], 4 ; [es:di+BDS.flags]
 12667                                  					; return_fake_bpb
 12668 0000120D 751A                    		jnz	short ChangeLnChkRet
 12669 0000120F 803E[7700]01            		cmp	byte [fhave96], 1	; This rom support change line?
 12670 00001214 7513                    		jnz	short ChangeLnChkRet
 12671 00001216 E8F806                  		call	haschange	; This drive support change line?
 12672 00001219 740E                    		jz	short ChangeLnChkRet ; Do nothing
 12673                                  
 12674                                  		; Execute the rom disk interrupt to check changeline activity.
 12675                                  
 12676 0000121B B416                    		mov	ah, 16h
 12677 0000121D CD13                    		int	13h		; DISK - FLOPPY	DISK - CHANGE OF DISK STATUS (AT,XT2,XT286,CONV,PS)
 12678                                  					; DL = drive to	check
 12679                                  					; Return: AH = disk change status
 12680 0000121F 7308                    		jnb	short ChangeLnChkRet
 12681 00001221 53                      		push	bx
 12682 00001222 BB4000                  		mov	bx, 40h		; fchanged
 12683                                  					; Update flag in BDS for this
 12684                                  					; physical drive
 12685 00001225 E8C206                  		call	set_changed_dl
 12686 00001228 5B                      		pop	bx
 12687                                  ChangeLnChkRet:				
 12688 00001229 C3                      		retn
 12689                                  
 12690                                  ; ---------------------------------------------------------------------------
 12691                                  
 12692                                  ; 16/10/2022
 12693                                  
 12694                                  ; ==========================================================================
 12695                                  ;	GetAccessFlag
 12696                                  ; ==========================================================================
 12697                                  ;
 12698                                  ; FUNCTION: get the status of UNFORMATTED_MEDIA bit of flags in bds table
 12699                                  ;
 12700                                  ; INPUT :
 12701                                  ;	    ES:di -> bds table
 12702                                  ;
 12703                                  ; OUTPUT:   a_DiskAccess_Control.dac_access_flag = 0 if disk i/o not allowed.
 12704                                  ;						 = 1 if disk i/o allowed.
 12705                                  ; ==========================================================================
 12706                                  
 12707                                  		; 19/10/2022
 12708                                  GetAccessFlag:				
 12709 0000122A C51E[1200]              		lds	bx, [ptrsav]	; DS:BX	points to request header
 12710 0000122E C55F13                  		lds	bx, [bx+19]	; [bx+IOCTL_REQ.GENERICIOCTL_PACKET]
 12711                                  		;mov	al, 0		; Assume result	is unformatted
 12712                                  		; 10/12/2022
 12713 00001231 28C0                    		sub	al, al
 12714                                  		; 10/12/2022
 12715 00001233 26F6452402              		test	byte [es:di+36], 02h
 12716                                  		;test	word [es:di+35], 200h ; [es:di+BDS.flags]
 12717                                  					; unformatted_media
 12718 00001238 7502                    		jnz	short GafDone	; Done if unformatted
 12719 0000123A FEC0                    		inc	al		; Return true for formatted
 12720                                  
 12721                                  GafDone:				
 12722 0000123C 884701                  		mov	[bx+1],	al	; [bx+A_DISKACCESS_CONTROL.DAC_ACCESS_FLAG]
 12723 0000123F C3                      		retn
 12724                                  ; ---------------------------------------------------------------------------
 12725                                  
 12726                                  ; 16/10/2022
 12727                                  
 12728                                  ; ==========================================================================
 12729                                  ;	SetAccessFlag
 12730                                  ; ==========================================================================
 12731                                  ;
 12732                                  ; function: set/reset the UNFORMATTED_MEDIA bit of flags in bds table
 12733                                  ;
 12734                                  ; input :
 12735                                  ;	    ES:di -> bds table
 12736                                  ;
 12737                                  ; output:   unformtted_media bit modified according to the user request
 12738                                  ; ==========================================================================
 12739                                  
 12740                                  		; 19/10/2022
 12741                                  SetAccessFlag:				
 12742 00001240 C51E[1200]              		lds	bx, [ptrsav]	; ES:BX	points to request header
 12743 00001244 C55F13                  		lds	bx, [bx+19]	; [bx+IOCTL_REQ.GENERICIOCTL_PACKET]
 12744                                  		; 10/12/2022
 12745 00001247 26806524FD              		and	byte [es:di+36], 0FDh
 12746                                  		;and	word [es:di+35], 0FDFFh ; [es:di+BDS.flags]
 12747                                  					; ~unformatted_media
 12748 0000124C 807F0100                		cmp	byte [bx+1], 0	; [bx+A_DISKACCESS_CONTROL.DAC_ACCESS_FLAG]
 12749 00001250 7505                    		jnz	short saf_Done
 12750                                  		; 10/12/2022
 12751 00001252 26804D2402              		or	byte [es:di+36], 02h
 12752                                  		;or	word [es:di+35], 200h ; [es:di+BDS.flags]
 12753                                  					; unformatted_media
 12754                                  saf_Done:				
 12755 00001257 C3                      		retn
 12756                                  ; ---------------------------------------------------------------------------
 12757                                  
 12758                                  ; 16/10/2022
 12759                                  
 12760                                  ; ==========================================================================
 12761                                  ; Ioctl_Support_Query
 12762                                  ; ==========================================================================
 12763                                  ;
 12764                                  ; New device command which was added in DOS 5.00 to allow a query of a 
 12765                                  ; specific GENERIC IOCtl to see if it is supported. Bit 7 in the
 12766                                  ; device attributes specifies if this function is supported.
 12767                                  ;
 12768                                  ; ==========================================================================
 12769                                  
 12770                                  		; 19/10/2022
 12771                                  ioctl_support_query:
 12772 00001258 06                      		push	es
 12773 00001259 C41E[1200]              		les	bx, [ptrsav]	; ES:BX Points to request header.
 12774 0000125D 268B470D                		mov	ax, [es:bx+13]	; [es:bx+IOCTL_REQ.MAJORFUNCTION]
 12775                                  					; AL ==	Major, AH == Minor
 12776 00001261 3C08                    		cmp	al, 8		; IOC_DC
 12777                                  					; See if major code is 8
 12778 00001263 7513                    		jnz	short nosupport
 12779 00001265 0E                      		push	cs
 12780 00001266 07                      		pop	es
 12781 00001267 B90B00                  		mov	cx, 11		; IOC_DC_TABLE_LEN
 12782                                  		; 10/12/2022
 12783 0000126A BF[3B0C]                		mov	di, IOC_DC_Table
 12784                                  		;mov	di, 0C60h	; IOC_DC_Table
 12785                                  					; at 2C7h:0C60h	= 70h:31D0h
 12786 0000126D 86C4                    		xchg	al, ah		; Put minor code in AL
 12787 0000126F F2AE                    		repne scasb		; Scan for minor code in AL
 12788 00001271 7505                    		jnz	short nosupport	; it was not found
 12789 00001273 B80001                  		mov	ax, 100h
 12790                                  		; 10/12/2022
 12791                                  		; (jump to ioctlsupexit is not required)
 12792                                  		;jmp	short $+2	; ioctlsupexit
 12793                                  					; Signal ioctl is supported
 12794                                  		;;jmp	short ioctlsupexit
 12795                                  ; ---------------------------------------------------------------------------
 12796                                  ioctlsupexit:				
 12797 00001276 07                      		pop	es
 12798                                  		; 10/12/2022
 12799                                  		; cf = 0
 12800                                  		;clc
 12801 00001277 C3                      		retn
 12802                                  ; ---------------------------------------------------------------------------
 12803                                  nosupport:				
 12804 00001278 07                      		pop	es
 12805 00001279 E959EE                  		jmp	bc_cmderr
 12806                                  ; ---------------------------------------------------------------------------
 12807                                  
 12808                                  ; 16/10/2022
 12809                                  
 12810                                  ; ==========================================================================
 12811                                  ;	GetMediaSenseStatus
 12812                                  ; ==========================================================================
 12813                                  ;
 12814                                  ; FUNCTION: Will return the type of diskette media in the specified DOS
 12815                                  ;	    diskette drive and whether the media is the default type
 12816                                  ;	    for that drive. (default type means the max size for that
 12817                                  ;	    drive)
 12818                                  ;
 12819                                  ; INPUT :   ES:DI -> BDS table
 12820                                  ; OUTPUT:   If carry clear
 12821                                  ;	    DS:BX -> Updated IOCtlPacket
 12822                                  ;
 12823                                  ;			 Special Function at offset 0:
 12824                                  ;				0	- Media detected is not default type
 12825                                  ;				1	- Media detected is default type
 12826                                  ;
 12827                                  ;			 Device Type at offset 1:
 12828                                  ;				2       - 720K 3.5" 80 tracks
 12829                                  ;				7	- 1.44M 3.5" 80 tracks
 12830                                  ;				9	- 2.88M 3.5" 80 tracks
 12831                                  ;
 12832                                  ; Error Codes returned in AX if carry set:
 12833                                  ;
 12834                                  ; 8102 - Drive not ready	- No disk is in the drive.
 12835                                  ; 8107 - Unknown media type	- Drive doesn't support this function or
 12836                                  ;				  the media is really unkown, any error
 12837                                  ;				  other than "media not present"
 12838                                  ; 
 12839                                  ; ==========================================================================
 12840                                  
 12841                                  		; 19/10/2022
 12842                                  SenseMediaType:				
 12843 0000127C C51E[1200]              		lds	bx, [ptrsav]	; DS:BX	points to request header.
 12844 00001280 C55F13                  		lds	bx, [bx+19]	; bx+IOCTL_REQ.GENERICIOCTL_PACKET]
 12845                                  		; 10/10/2022
 12846                                  		;mov	word [bx], 0	; Initialize the 2 packet bytes
 12847 00001283 31D2                    		xor	dx, dx
 12848 00001285 8917                    		mov	[bx], dx ; 0
 12849                                  		;
 12850 00001287 268A5504                		mov	dl, [es:di+4]	; [es:di+BDS.drivenum]
 12851                                  					; Get int 13h drive number from	BDS
 12852                                  		; 10/12/2022
 12853                                  		;xor	dh, dh		; DX = physical	drive number
 12854 0000128B B420                    		mov	ah, 20h		; Get Media Type function
 12855                                  					; If no	carry media type in AL
 12856 0000128D CD13                    		int	13h		; DISK - QCACHE	- DISMOUNT
 12857 0000128F 7216                    		jb	short MediaSenseEr ; error code	in AH
 12858 00001291 FE07                    		inc	byte [bx]	; Signal media type is default (bit 1)
 12859                                  DetermineMediaType:			
 12860 00001293 FEC8                    		dec	al
 12861 00001295 3C02                    		cmp	al, 2		; Chk for 720K ie: (3-1) = 2
 12862 00001297 740A                    		jz	short GotMediaType
 12863 00001299 0404                    		add	al, 4
 12864 0000129B 3C07                    		cmp	al, 7		; Chk for 1.44M ie: (4-1+4) = 7
 12865 0000129D 7404                    		jz	short GotMediaType
 12866 0000129F 3C09                    		cmp	al, 9		; Chk for 2.88M	ie: (6-1+4) = 9
 12867 000012A1 7510                    		jnz	short UnknownMediaType ; Just didn't recognize media type
 12868                                  GotMediaType:				
 12869 000012A3 884701                  		mov	[bx+1],	al	; Save the return value
 12870                                  		; 10/12/2022
 12871                                  		; cf = 0
 12872                                  		;clc			; Signal success
 12873 000012A6 C3                      		retn
 12874                                  ; ---------------------------------------------------------------------------
 12875                                  
 12876                                  MediaSenseEr:				
 12877 000012A7 80FC32                  		cmp	ah, 32h		; See if not default media error
 12878 000012AA 74E7                    		jz	short DetermineMediaType ; Not really an error
 12879 000012AC B002                    		mov	al, 2		; Now assume drive not ready
 12880 000012AE 80FC31                  		cmp	ah, 31h		; See if media was present
 12881 000012B1 7402                    		jz	short SenseErrExit ; Return drive not ready
 12882                                  UnknownMediaType:			
 12883 000012B3 B007                    		mov	al, 7		; Just don't know the media type
 12884                                  SenseErrExit:				
 12885 000012B5 B481                    		mov	ah, 81h		; Signal error return
 12886 000012B7 F9                      		stc
 12887 000012B8 C3                      		retn
 12888                                  
 12889                                  ; ---------------------------------------------------------------------------
 12890                                  		; 10/12/2022
 12891                                  		;db    0
 12892                                  ; ---------------------------------------------------------------------------
 12893                                  
 12894                                  ; 16/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 12895                                  
 12896                                  ;-----------------------------------------------------------------------------
 12897                                  ; MSINT13.ASM - MSDOS 6.0 - 1991
 12898                                  ;-----------------------------------------------------------------------------
 12899                                  ; 16/03/2019 - Retro DOS v4.0
 12900                                  
 12901                                  ;	int 2f function 13h allows the user to change the orig13 int_13 vector
 12902                                  ;	after booting. this allows testing and implementation of custom int_13
 12903                                  ;	handlers, without giving up ms-dos error recovery
 12904                                  ;	entry:	ds:dx	== addr. of new int_13 handler
 12905                                  ;		es:bx	== addr. of new int_13 vector used by warm boot (int19)
 12906                                  ;	exit:	orig13	== address of new int_13 handler
 12907                                  ;		ds:dx	== old orig13 value
 12908                                  ;		es:bx	== old old13  value
 12909                                  ;
 12910                                  ; int 2f handler for external block drivers to communicate with the internal
 12911                                  ; block driver in msdisk. the multiplex number chosen is 8. the handler
 12912                                  ; sets up the pointer to the request packet in [ptrsav] and then jumps to
 12913                                  ; dsk_entry, the entry point for all disk requests.
 12914                                  ;
 12915                                  ; on exit from this driver, we will return to the external driver
 12916                                  ; that issued this int 2f, and can then remove the flags from the stack.
 12917                                  ; this scheme allows us to have a small external device driver, and makes
 12918                                  ; the maintainance of the various drivers (driver and msbio) much easier,
 12919                                  ; since we only need to make changes in one place (most of the time).
 12920                                  ;
 12921                                  ;   ax=800h - check for installed handler - reserved
 12922                                  ;   ax=801h - install the bds into the linked list
 12923                                  ;   ax=802h - dos request
 12924                                  ;   ax=803h - return bds table starting pointer in ds:di
 12925                                  ;	   (ems device driver hooks int 13h to handle 16kb dma overrun
 12926                                  ;	    problem. bds table is going to be used to get head/sector
 12927                                  ;	    informations without calling generic ioctl get device parm call.)
 12928                                  
 12929                                  ;BIOSSEGMENT equ 70h
 12930                                  DOSBIOSSEG equ 0070h ; 17/10/2022	
 12931                                  
 12932                                  ;;BIOSCODE:1302h (MSDOS 6.21, IO.SYS)
 12933                                  
 12934                                  i2f_handler:				; here is 02C7h:1302h =	0070h:3872h
 12935 000012B9 80FC13                  		cmp	ah, 13h
 12936 000012BC 7413                    		jz	short int2f_replace_int13
 12937 000012BE 80FC08                  		cmp	ah, 8
 12938 000012C1 743B                    		jz	short mine
 12939                                  
 12940                                  ; Check for WIN386 startup and return the BIOS instance data
 12941                                  
 12942 000012C3 80FC16                  		cmp	ah, 16h		; MultWin386
 12943 000012C6 7479                    		jz	short win386call
 12944 000012C8 80FC4A                  		cmp	ah, 4Ah		; multMULT
 12945 000012CB 7503                    		jnz	short i2f_handler_iret
 12946 000012CD E9A500                  		jmp	handle_multmult
 12947                                  ; ---------------------------------------------------------------------------
 12948                                  
 12949                                  i2f_handler_iret:			
 12950 000012D0 CF                      		iret
 12951                                  ; ---------------------------------------------------------------------------
 12952                                  
 12953                                  int2f_replace_int13:			
 12954 000012D1 50                      		push	ax	; free up a register for caller's ds
 12955 000012D2 8CD8                    		mov	ax, ds	; then we can use ds: -> Bios_Data
 12956                                  		;;mov	ds, word [cs:0030h] ; 15/10/2022	
 12957                                  		;mov	ds, word ptr cs:BIOSDATAWORD ; [cs:0030h]
 12958                                  					; = [02C7h:0030h] = [0070h:25A0h]
 12959 000012D4 2E8E1E[3000]            		mov	ds, [cs:BIOSDATAWORD] ; 17/10/2022
 12960                                  		; 19/10/2022
 12961                                  		;push	word ptr ds:Orig13	; save old value of old13 and
 12962                                  		;push	word ptr ds:Orig13+2	; orig13 so that we can
 12963                                  		;push	word ptr ds:Old13	; return them to caller
 12964                                  		;push	word ptr ds:Old13+2
 12965 000012D9 FF36[B400]              		push	word [Orig13]
 12966 000012DD FF36[B600]              		push	word [Orig13+2]
 12967 000012E1 FF36[0601]              		push	word [Old13]
 12968 000012E5 FF36[0801]              		push	word [Old13+2]
 12969                                  
 12970                                  		;mov	word ptr ds:Orig13, dx	; orig13 := addr. of new int_13
 12971                                  		;mov	word ptr ds:Orig13+2, ax
 12972                                  		;mov	word ptr ds:Old13, bx	; old13 := addr. of new boot_13
 12973                                  		;mov	word ptr ds:Old13+2, es
 12974 000012E9 8916[B400]              		mov	[Orig13], dx
 12975 000012ED A3[B600]                		mov	[Orig13+2], ax
 12976 000012F0 891E[0601]              		mov	[Old13], bx
 12977 000012F4 8C06[0801]              		mov	[Old13+2], es
 12978                                  
 12979 000012F8 07                      		pop	es			; es:bx := old old13 vector
 12980 000012F9 5B                      		pop	bx
 12981 000012FA 1F                      		pop	ds			; ds:dx := old orig13 vector
 12982 000012FB 5A                      		pop	dx
 12983 000012FC 58                      		pop	ax
 12984                                  i2f_iret:				
 12985 000012FD CF                      		iret
 12986                                  ; ---------------------------------------------------------------------------
 12987                                  
 12988                                  mine:					
 12989 000012FE 3CF8                    		cmp	al, 0F8h 		; iret on reserved functions
 12990 00001300 73FB                    		jnb	short i2f_iret
 12991 00001302 08C0                    		or	al, al			; a get installed state request?
 12992 00001304 7504                    		jnz	short disp_func
 12993 00001306 B0FF                    		mov	al, 0FFh
 12994 00001308 EBF3                    		jmp	short i2f_iret
 12995                                  ; ---------------------------------------------------------------------------
 12996                                  
 12997                                  disp_func:				
 12998 0000130A 3C01                    		cmp	al, 1			; request for installing bds?
 12999 0000130C 7418                    		jz	short do_subfun_01
 13000 0000130E 3C03                    		cmp	al, 3			; get bds vector?
 13001 00001310 7424                    		jz	short do_get_bds_vector
 13002                                  
 13003                                  ; set up pointer to request packet
 13004                                  
 13005 00001312 1E                      		push	ds
 13006 00001313 2E8E1E[3000]            		mov	ds, [cs:BIOSDATAWORD] ; 17/10/2022	
 13007                                  		;mov	ds, word ptr cs:BIOSDATAWORD ; [cs:Bios_Data_Word]
 13008                                  					; = [0070h:25A0h] = [02C7h:0030h]
 13009                                  		; 19/10/2022
 13010                                  		;mov	word ptr ds:ptrsav, bx
 13011                                  		;mov	word ptr ds:ptrsav+2, es
 13012 00001318 891E[1200]              		mov	[ptrsav], bx
 13013 0000131C 8C06[1400]              		mov	[ptrsav+2], es
 13014 00001320 1F                      		pop	ds
 13015                                  		;jmp	far ptr	i2f_dskentry
 13016                                  		; 17/10/2022
 13017                                  		;jmp	far DOSBIOSSEG:dsk_entry		
 13018 00001321 EA[9608]7000            		jmp	DOSBIOSSEG:i2f_dskentry ; 70h:i2f_dskentry
 13019                                  					; NOTE: jump to a FAR function, not an
 13020                                  					;  IRET type function. Callers of
 13021                                  					;  this int2f subfunction will have
 13022                                  					;  to be careful to do a popf
 13023                                  
 13024                                  ; ---------------------------------------------------------------------------
 13025                                  
 13026                                  do_subfun_01:				
 13027 00001326 06                      		push	es
 13028 00001327 1E                      		push	ds
 13029 00001328 1E                      		push	ds
 13030 00001329 07                      		pop	es
 13031                                  		; 17/10/2022
 13032 0000132A 2E8E1E[3000]            		mov	ds, [cs:BIOSDATAWORD]	
 13033                                  		;mov	ds, word ptr cs:BIOSDATAWORD ; [cs:Bios_Data_Word]
 13034                                  					; point	ds: -> Bios_Data
 13035 0000132F E8C303                  		call	install_bds
 13036 00001332 1F                      		pop	ds
 13037 00001333 07                      		pop	es
 13038 00001334 EBC7                    		jmp	short i2f_iret
 13039                                  ; ---------------------------------------------------------------------------
 13040                                  
 13041                                  do_get_bds_vector:
 13042                                  		; 17/10/2022
 13043 00001336 2E8E1E[3000]            		mov	ds, [cs:BIOSDATAWORD]			
 13044                                  		;mov	ds, word ptr cs:BIOSDATAWORD ; [cs:Bios_Data_Word]
 13045 0000133B C53E[1901]              		lds	di, [start_bds]
 13046                                  		;lds	di, ds:start_bds
 13047                                  ;ii2f_iret:	; 10/12/2022				
 13048 0000133F EBBC                    		jmp	short i2f_iret
 13049                                  ; ---------------------------------------------------------------------------
 13050                                  
 13051                                  ; 17/10/2022
 13052                                  ; 16/10/2022
 13053                                  
 13054                                  ; WIN386 startup stuff is done here. If starting up we set our WIN386 present
 13055                                  ; flag and return instance data. If exiting, we reset the WIN386 present flag
 13056                                  ; NOTE: We assume that the BIOS int 2fh is at the bottom of the chain.
 13057                                  
 13058                                  win386call:				
 13059 00001341 1E                      		push	ds
 13060 00001342 2E8E1E[3000]            		mov	ds, [cs:BIOSDATAWORD]
 13061                                  		;mov	ds, word ptr cs:BIOSDATAWORD ; [cs:Bios_Data_Word]
 13062                                  					; at 2C7h:30h =	70h:25A0h
 13063 00001347 3C05                    		cmp	al, 5		; Win386_Init
 13064                                  					; is it	win386 initializing?
 13065 00001349 7410                    		jz	short Win386Init
 13066 0000134B 3C06                    		cmp	al, 6		; Win386_Exit
 13067                                  					; is it	win386 exiting?
 13068 0000134D 7523                    		jnz	short win_iret	; if not, continue int2f chain
 13069                                  		; 12/12/2022
 13070 0000134F F6C201                  		test	dl, 1
 13071                                  		;test	dx, 1		; is it	win386 or win286 dos extender?
 13072 00001352 751E                    		jnz	short win_iret	; if not win386, then continue
 13073                                  		;and	ds:IsWin386, 0	; indicate that	win386 is not present  
 13074 00001354 8026[CE08]00            		and	byte [IsWin386], 0 
 13075 00001359 EB17                    		jmp	short win_iret
 13076                                  ; ---------------------------------------------------------------------------
 13077                                  
 13078                                  Win386Init:	
 13079                                  		; 12/12/2022
 13080 0000135B F6C201                  		test	dl, 1			
 13081                                  		;test	dx, 1		; is it win386 or win286 dos extender?
 13082 0000135E 7512                    		jnz	short win_iret	; if not win386, then continue
 13083                                  		;or	ds:IsWin386, 1	; Indicate WIN386 present
 13084 00001360 800E[CE08]01            		or	byte [IsWin386], 1
 13085                                  		;mov	word ptr ds:SI_Next, bx	; Hook our structure into chain
 13086                                  		;mov	word ptr ds:SI_Next+2, es
 13087 00001365 891E[9C08]              		mov	[SI_Next], bx
 13088 00001369 8C06[9E08]              		mov	[SI_Next+2], es
 13089                                  		;mov	bx, offset Win386_SI ; point ES:BX to Win386_SI
 13090 0000136D BB[9A08]                		mov	bx, Win386_SI	; 19/10/2022
 13091 00001370 1E                      		push	ds
 13092 00001371 07                      		pop	es
 13093                                  win_iret:				
 13094 00001372 1F                      		pop	ds
 13095                                  ii2f_iret:	; 10/12/2022	
 13096 00001373 EB88                    		jmp	short i2f_iret	; return back up the chain
 13097                                  ; ---------------------------------------------------------------------------
 13098                                  
 13099                                  handle_multmult:			
 13100 00001375 3C01                    		cmp	al, 1
 13101 00001377 7515                    		jnz	short try_2
 13102 00001379 1E                      		push	ds
 13103 0000137A E84700                  		call	HMAPtr		; get offset of free HMA
 13104                                  		; 10/12/2022
 13105                                  		;xor	bx, bx
 13106                                  		;dec	bx
 13107 0000137D BBFFFF                  		mov	bx, 0FFFFh
 13108 00001380 8EC3                    		mov	es, bx		; seg of HMA
 13109 00001382 89FB                    		mov	bx, di
 13110 00001384 F7D3                    		not	bx
 13111 00001386 09DB                    		or	bx, bx
 13112 00001388 7401                    		jz	short try_1
 13113 0000138A 43                      		inc	bx
 13114                                  try_1:					
 13115 0000138B 1F                      		pop	ds
 13116 0000138C EBE5                    		jmp	short ii2f_iret
 13117                                  ; ---------------------------------------------------------------------------
 13118                                  
 13119                                  try_2:					
 13120 0000138E 3C02                    		cmp	al, 2		; multMULTALLOCHMA
 13121 00001390 7530                    		jnz	short try_3
 13122 00001392 1E                      		push	ds
 13123                                  		; 10/12/2022
 13124                                  		;xor	di, di
 13125                                  		;dec	di
 13126 00001393 BFFFFF                  		mov	di, 0FFFFh	; assume not enough space
 13127 00001396 8EC7                    		mov	es, di
 13128 00001398 E82900                  		call	HMAPtr		; get offset of free HMA
 13129 0000139B 83FFFF                  		cmp	di, 0FFFFh
 13130 0000139E 7421                    		jz	short InsuffHMA
 13131 000013A0 F7DF                    		neg	di		; free space in HMA
 13132 000013A2 39FB                    		cmp	bx, di
 13133 000013A4 7605                    		jbe	short try_4
 13134                                  		; 10/12/2022
 13135                                  		;sub	di, di
 13136                                  		;dec	di
 13137 000013A6 BFFFFF                  		mov	di, 0FFFFh
 13138 000013A9 EB16                    		jmp	short InsuffHMA
 13139                                  ; ---------------------------------------------------------------------------
 13140                                  
 13141                                  try_4:					
 13142                                  		;mov	di, ds:FreeHMAPtr
 13143 000013AB 8B3E[F508]              		mov	di, [FreeHMAPtr]
 13144 000013AF 83C30F                  		add	bx, 15
 13145                                  		;and	bx, 0FFF0h
 13146                                  		; 10/12/2022
 13147 000013B2 80E3F0                  		and	bl, 0F0h
 13148                                  		;add	ds:FreeHMAPtr, bx ; update the free pointer	
 13149 000013B5 011E[F508]              		add	[FreeHMAPtr], bx
 13150 000013B9 7506                    		jnz	short InsuffHMA
 13151 000013BB C706[F508]FFFF          		mov	word [FreeHMAPtr], 0FFFFh ; -1
 13152                                  		;mov	ds:FreeHMAPtr, 0FFFFh
 13153                                  					; no more HMA if we have wrapped
 13154                                  InsuffHMA:				
 13155 000013C1 1F                      		pop	ds
 13156                                  		; 10/12/2022
 13157                                  try_3:		
 13158 000013C2 EBAF                    		jmp	short ii2f_iret
 13159                                  ; ---------------------------------------------------------------------------
 13160                                  
 13161                                  		; 10/12/2022
 13162                                  ;try_3:					
 13163                                  		;jmp	ii2f_iret
 13164                                  
 13165                                  ; =============== S U B	R O U T	I N E =======================================
 13166                                  
 13167                                  ; 16/10/2022
 13168                                  
 13169                                  ;--------------------------------------------------------------------------
 13170                                  ;
 13171                                  ; procedure : HMAPtr
 13172                                  ;
 13173                                  ;		Gets the offset of the free HMA area ( with respect to
 13174                                  ;							seg ffff )
 13175                                  ;		If DOS has not moved high, tries to move DOS high.
 13176                                  ;		In the course of doing this, it will allocate all the HMA
 13177                                  ;		and set the FreeHMAPtr to past the end of the BIOS and 
 13178                                  ;		DOS code. The call to MoveDOSIntoHMA (which is a pointer)
 13179                                  ;		enters the routine in sysinit1 called FTryToMovDOSHi.
 13180                                  ;
 13181                                  ;	RETURNS : offset of free HMA in DI
 13182                                  ;		  BIOS_DATA, seg in DS
 13183                                  ;
 13184                                  ;--------------------------------------------------------------------------
 13185                                  
 13186                                  		; 17/10/2022
 13187                                  HMAPtr:
 13188 000013C4 2E8E1E[3000]            		mov	ds, [cs:BIOSDATAWORD]
 13189                                  		;mov	ds, word ptr cs:BIOSDATAWORD ; [cs:Bios_Data_Word]
 13190 000013C9 8B3E[F508]              		mov	di, [FreeHMAPtr]
 13191                                  		;mov	di, ds:FreeHMAPtr
 13192 000013CD 83FFFF                  		cmp	di, 0FFFFh
 13193 000013D0 750F                    		jnz	short HMAPtr_retn
 13194 000013D2 803E[FB08]00            		cmp	byte [SysinitPresent], 0
 13195                                  		;cmp	ds:SysinitPresent, 0
 13196 000013D7 7408                    		jz	short HMAPtr_retn
 13197 000013D9 FF1E[F708]              		call	far [MoveDOSIntoHMA]
 13198                                  		;call	ds:MoveDOSIntoHMA ; call far [MoveDOSIntoHMA]
 13199 000013DD 8B3E[F508]              		mov	di, [FreeHMAPtr]
 13200                                  		;mov	di, ds:FreeHMAPtr
 13201                                  HMAPtr_retn:				
 13202 000013E1 C3                      		retn
 13203                                  
 13204                                  ; =============== S U B	R O U T	I N E =======================================
 13205                                  
 13206                                  ; 16/10/2022
 13207                                  
 13208                                  ; move a 512 byte sector from ds:si to es:di, do not trash cx
 13209                                  ; but go ahead and update direction flag, si, & di
 13210                                  
 13211                                  move_sector:
 13212                                  
 13213                                  ; The 80386 microprocessor considers an access to WORD 0FFFFh in
 13214                                  ; any segment to be a fault. Theoretically, this could be handled
 13215                                  ; by the fault handler and the behavior of an 8086 could be emulated
 13216                                  ; by wrapping the high byte to offset 0000h. This would be a lot
 13217                                  ; of work and was, indeed, blown off by the Win386 guys. COMPAQ
 13218                                  ; also handles the fault incorrectly in their ROM BIOS for real
 13219                                  ; mode. Their fault handler was only designed to deal with one
 13220                                  ; special case which occurred in a magazine benchmark, but didn't
 13221                                  ; handle the general case worth beans.
 13222                                  ;
 13223                                  ; Simply changing this code to do a byte loop would work okay but
 13224                                  ; would involve a general case performance hit. Therefore, we'll
 13225                                  ; check for either source or destination offsets being within one
 13226                                  ; sector of the end of their segments and only in that case fall
 13227                                  ; back to a byte move.
 13228                                  
 13229 000013E2 FC                      		cld
 13230 000013E3 51                      		push	cx
 13231 000013E4 B90001                  		mov	cx, 256
 13232 000013E7 81FE00FE                		cmp	si, 0FE00h
 13233 000013EB 770A                    		ja	short movsec_bytes
 13234 000013ED 81FF00FE                		cmp	di, 0FE00h
 13235 000013F1 7704                    		ja	short movsec_bytes
 13236 000013F3 F3A5                    		rep movsw
 13237 000013F5 59                      		pop	cx
 13238 000013F6 C3                      		retn
 13239                                  ; ---------------------------------------------------------------------------
 13240                                  
 13241                                  movsec_bytes:				
 13242 000013F7 D1E1                    		shl	cx, 1
 13243 000013F9 F3A4                    		rep movsb
 13244 000013FB 59                      		pop	cx
 13245 000013FC C3                      		retn
 13246                                  
 13247                                  ; =============== S U B	R O U T	I N E =======================================
 13248                                  
 13249                                  ; 16/10/2022
 13250                                  
 13251                                  ; check_wrap is a routine that adjusts the starting sector, starting head
 13252                                  ; and starting cylinder for an int 13 request that requests i/o of a lot
 13253                                  ; of sectors. it only does this for fixed disks. it is used in the sections
 13254                                  ; of code that handle ecc errors and dma errors. it is necessary, because
 13255                                  ; ordinarily the rom would take care of wraps around heads and cylinders,
 13256                                  ; but we break down a request when we get an ecc or dma error into several
 13257                                  ; i/o of one or more sectors. in this case, we may already be beyond the
 13258                                  ; number of sectors on a track on the medium, and the request would fail.
 13259                                  ;
 13260                                  ; input conditions:
 13261                                  ;	all registers set up for an int 13 request.
 13262                                  ;
 13263                                  ; output:
 13264                                  ;	dh - contains starting head number for request
 13265                                  ;	cx - contains starting sector and cylinder numbers
 13266                                  ;	(the above may or may not have been changed, and are 0-based)
 13267                                  ;	all other registers preserved.
 13268                                  
 13269                                  check_wrap:	
 13270 000013FD 50                      		push	ax
 13271 000013FE 53                      		push	bx
 13272 000013FF 06                      		push	es
 13273 00001400 57                      		push	di
 13274 00001401 E86E00                  		call	find_bds	; get pointer to bds for drive in dl
 13275 00001404 7260                    		jb	short no_wrap	; finished if DOS doesn't use it
 13276                                  		; 12/12/2022
 13277 00001406 26F6452301              		test	byte [es:di+23h], 1
 13278                                  		;test	word [es:di+23h], 1 ; [es:di+BDS.flags],fnon_removable
 13279 0000140B 7459                    		jz	short no_wrap	; no wrapping for removable media
 13280 0000140D 268B5D13                		mov	bx, [es:di+13h]	; [es:di+BDS.secpertrack]
 13281 00001411 89C8                    		mov	ax, cx
 13282 00001413 83E03F                  		and	ax, 3Fh		; extract sector number
 13283 00001416 39D8                    		cmp	ax, bx		; are we going to wrap?
 13284 00001418 764C                    		jbe	short no_wrap
 13285 0000141A F6F3                    		div	bl		; ah=new sector	#, al=#	of head	wraps
 13286                                  
 13287                                  ; we need to be careful here. if the new sector # is 0, then we are on the
 13288                                  ; last sector on that track.
 13289                                  
 13290 0000141C 08E4                    		or	ah, ah
 13291 0000141E 7503                    		jnz	short not_on_bound
 13292                                  		; 18/12/2022
 13293 00001420 48                      		dec	ax ; *
 13294 00001421 88DC                    		mov	ah, bl		; set sector=BDS_BPB.BPB_SECTORSPERTRACK
 13295                                  					; if on	boundary
 13296                                  		;dec	al ; *		; also decrement # of head wraps
 13297                                  not_on_bound:				
 13298 00001423 80E1C0                  		and	cl, 0C0h	; zero out sector #
 13299 00001426 08E1                    		or	cl, ah		; or in	new sector #
 13300 00001428 30E4                    		xor	ah, ah		; ax = # of head wraps
 13301 0000142A 40                      		inc	ax
 13302 0000142B 00F0                    		add	al, dh		; add in starting head #
 13303 0000142D 80D400                  		adc	ah, 0		; catch	any carry
 13304 00001430 263B4515                		cmp	ax, [es:di+15h]	; [es:di+BDS.heads]
 13305                                  					; are we going to wrap around a	head?
 13306 00001434 7636                    		jbe	short no_wrap_head ; do	not lose new head number!!
 13307 00001436 52                      		push	dx		; preserve drive number and head number
 13308 00001437 31D2                    		xor	dx, dx
 13309 00001439 268B5D15                		mov	bx, [es:di+15h]	; [es:di+BDS.heads]
 13310 0000143D F7F3                    		div	bx		; dx=new head #, ax=# of cylinder wraps
 13311                                  
 13312                                  ; careful here! if new head # is 0, then we are on the last head.
 13313                                  
 13314 0000143F 09D2                    		or	dx, dx
 13315 00001441 7507                    		jnz	short no_head_bound
 13316 00001443 89DA                    		mov	dx, bx		; on boundary. set to BDS_BPB.BPB_HEADS
 13317                                  
 13318                                  ; if we had some cylinder wraps, we need to reduce them by one!!
 13319                                  
 13320 00001445 09C0                    		or	ax, ax
 13321 00001447 7401                    		jz	short no_head_bound
 13322 00001449 48                      		dec	ax		; reduce number	of cylinder wraps
 13323                                  no_head_bound:				
 13324 0000144A 88D7                    		mov	bh, dl		; bh has new head number
 13325 0000144C 5A                      		pop	dx		; restore drive number and head number
 13326 0000144D FECF                    		dec	bh		; get it 0-based
 13327 0000144F 88FE                    		mov	dh, bh		; set up new head number in dh
 13328 00001451 88CF                    		mov	bh, cl
 13329 00001453 80E73F                  		and	bh, 3Fh		; preserve sector number
 13330 00001456 B306                    		mov	bl, 6
 13331 00001458 86CB                    		xchg	cl, bl
 13332 0000145A D2EB                    		shr	bl, cl		; get ms cylinder bits to ls end
 13333 0000145C 00C5                    		add	ch, al		; add in cylinder wrap
 13334 0000145E 10E3                    		adc	bl, ah		; add in high byte
 13335 00001460 D2E3                    		shl	bl, cl		; move up to ms	end
 13336 00001462 86D9                    		xchg	bl, cl		; restore cylinder bits	into cl
 13337 00001464 08F9                    		or	cl, bh		; or in	sector number
 13338                                  no_wrap:				
 13339 00001466 F8                      		clc
 13340 00001467 5F                      		pop	di
 13341 00001468 07                      		pop	es
 13342 00001469 5B                      		pop	bx
 13343 0000146A 58                      		pop	ax
 13344 0000146B C3                      		retn
 13345                                  ; ---------------------------------------------------------------------------
 13346                                  
 13347                                  no_wrap_head:				
 13348 0000146C 88C6                    		mov	dh, al		; do not lose new head number
 13349 0000146E FECE                    		dec	dh		; get it 0-based
 13350 00001470 EBF4                    		jmp	short no_wrap
 13351                                  
 13352                                  ; =============== S U B	R O U T	I N E =======================================
 13353                                  
 13354                                  ; 16/10/2022
 13355                                  
 13356                                  ; this is a special version of the bds lookup code which is
 13357                                  ; based on physical drives rather than the usual logical drives
 13358                                  ; carry is set if the physical drive in dl is found, es:di -> its bds
 13359                                  ; otherwise carry is clear
 13360                                  ;
 13361                                  ; guaranteed to trash no registers except es:di
 13362                                  
 13363                                  		; 19/10/2022
 13364                                  find_bds:	
 13365 00001472 C43E[1901]              		les	di, [start_bds]	; point es:di to first bds
 13366                                  fbds_1:					
 13367 00001476 26385504                		cmp	[es:di+4], dl	; [es:di+BDS.drivenum]
 13368 0000147A 7409                    		jz	short fdbs_2
 13369 0000147C 26C43D                  		les	di, [es:di]	; [es:di+BDS.link]
 13370                                  					; go to next bds
 13371 0000147F 83FFFF                  		cmp	di, 0FFFFh
 13372 00001482 75F2                    		jnz	short fbds_1
 13373 00001484 F9                      		stc
 13374                                  fdbs_2:					
 13375 00001485 C3                      		retn
 13376                                  
 13377                                  ; =============== S U B	R O U T	I N E =======================================
 13378                                  
 13379                                  ; 16/10/2022
 13380                                  		; 17/10/2022
 13381                                  doint:
 13382                                  		; 10/12/2022
 13383 00001486 8A5608                  		mov	dl, [bp+8]	; [bp+INT13FRAME.olddx]
 13384                                  					; get physical drive number
 13385                                  		; 19/10/2022 - Temporary !
 13386                                  		;db	8Ah, 96h, 8, 0	; mov dl, [bp+8]	
 13387                                  		
 13388 00001489 30E4                    		xor	ah, ah
 13389 0000148B 08C0                    		or	al, al
 13390 0000148D 7410                    		jz	short dointdone	; if zero sectors, return ax=0
 13391                                  		; 10/12/2022
 13392 0000148F 8A6603                  		mov	ah, [bp+3]	; [bp+INT13FRAME.oldax+1]
 13393                                  					; get request code
 13394                                  		;db	8Ah, 0A6h, 3, 0	; mov ah, [bp+3]
 13395 00001492 FF7610                  		push	word [bp+10h]	; [bp+INT13FRAME.oldf]
 13396                                  		;db	0FFh, 0B6h, 10h, 0 ; push word [bp+10h]
 13397 00001495 9D                      		popf
 13398                                  		;call	far 70h:797h ; MSDOS 6.21 IO.SYS BIOSCODE:14EAh
 13399                                  		; 17/10/2022
 13400 00001496 9A[9707]7000            		call	DOSBIOSSEG:call_orig13
 13401                                  		;;call	call_orig13	; call far 70h:797h
 13402                                  					; call far KERNEL_SEGMENT:call_orig13
 13403 0000149B 9C                      		pushf
 13404                                  		; 10/12/2022
 13405 0000149C 8F4610                  		pop	word [bp+10h]	; [bp+INT13FRAME.oldf]
 13406                                  		;db	8Fh, 86h, 10h, 0 ; pop word [bp+10h]
 13407                                  dointdone:				
 13408 0000149F C3                      		retn
 13409                                  
 13410                                  ;----------------------------------------------------------------------------
 13411                                  
 13412                                  ; 16/10/2022
 13413                                  
 13414                                  ; this is the true int 13 handler. we parse the request to see if there is
 13415                                  ; a dma violation. if so, depending on the function, we:
 13416                                  ;   read/write break the request into three pieces and move the middle one
 13417                                  ;	       into our internal buffer.
 13418                                  ;
 13419                                  ;   format     copy the format table into the buffer
 13420                                  ;   verify     point the transfer address into the buffer
 13421                                  ;
 13422                                  ; this is the biggest bogosity of all. the ibm controller does not handle
 13423                                  ; operations that cross physical 64k boundaries. in these cases, we copy
 13424                                  ; the offending sector into the buffer below and do the i/o from there.
 13425                                  
 13426                                  ;struc INT13FRAME
 13427                                  ;.oldbp: resw
 13428                                  ;.oldax: resw 
 13429                                  ;.oldbx: resw
 13430                                  ;.oldcx: resw
 13431                                  ;.olddx: resw
 13432                                  ;.oldds: resw	; now we save caller's ds, too
 13433                                  ;.olddd: resd
 13434                                  ;.oldf:	resw
 13435                                  ;end struc
 13436                                  
 13437                                  ;----------------------------------------------------------------------------
 13438                                  
 13439                                  ;   entry conditions:
 13440                                  ;	ah = function
 13441                                  ;	al = number of sectors
 13442                                  ;	es:bx = dma address
 13443                                  ;	cx = packed track and sector
 13444                                  ;	dx = head and drive
 13445                                  ;   output conditions:
 13446                                  ;	no dma violation.
 13447                                  
 13448                                  ;	use extreme caution when working with this code. In general,
 13449                                  ;	  all registers are hot at all times.
 13450                                  ;
 13451                                  ;	question:  does this code handle cases where dma errors
 13452                                  ;	  occur during ecc retries, and where ecc errors occur during
 13453                                  ;	  dma breakdowns???? Hmmmmm.
 13454                                  
 13455                                  ;----------------------------------------------------------------------------
 13456                                  
 13457                                  ; ---------------------------------------------------------------------------
 13458                                  
 13459 000014A0 90004000                dtype_array:	dd 400090h		; 40:90	is drive type array
 13460                                  
 13461                                  ; 17/10/2022
 13462                                  ;DTYPEARRAY equ dtype_array - DOSBIOSEG_2C7h ; (14F5h for MSDOS 5.0 IO.SYS)
 13463                                  ; 09/12/2022
 13464                                  DTYPEARRAY equ dtype_array
 13465                                  
 13466                                  ; ---------------------------------------------------------------------------
 13467                                  
 13468                                  ; stick some special stuff out of mainline
 13469                                  
 13470                                  ; we know we're doing a format command. if we have changeline
 13471                                  ; support, then flag some special changed stuff and set changed
 13472                                  ; by format bit for all logical drives using this physical drive
 13473                                  
 13474                                  format_special_stuff:			
 13475 000014A4 803E[7700]00            		cmp	byte [fhave96], 0	; do we have changeline support?
 13476 000014A9 7459                    		jz	short format_special_stuff_done ; brif not
 13477 000014AB 53                      		push	bx
 13478 000014AC BB4001                  		mov	bx, 140h	; fchanged_by_format+fchanged
 13479 000014AF E83804                  		call	set_changed_dl	; indicate that media changed by format
 13480 000014B2 5B                      		pop	bx
 13481 000014B3 EB4F                    		jmp	short format_special_stuff_done
 13482                                  ; ---------------------------------------------------------------------------
 13483                                  
 13484                                  ; 16/10/2022
 13485                                  
 13486                                  ; we know we've got ec35's on the system. Now see if we're doing
 13487                                  ; a floppy. If so, create a mask and see if this particular
 13488                                  ; drive is an ec35. If so, set dtype_array[drive]=93h
 13489                                  
 13490                                  		; 19/10/2022
 13491                                  ec35_special_stuff:			
 13492 000014B5 84D2                    		test	dl, dl		; floppy or hard disk?
 13493 000014B7 7852                    		js	short ec35_special_stuff_done ;	if hard	drive, we're done
 13494 000014B9 50                      		push	ax		; see if this PARTICULAR drive is ec35
 13495 000014BA 51                      		push	cx
 13496 000014BB 88D1                    		mov	cl, dl		; turn drive number into bit map
 13497 000014BD B001                    		mov	al, 1		; assume drive 0
 13498 000014BF D2E0                    		shl	al, cl		; shift	over correct number of times
 13499 000014C1 8406[3105]              		test	[ec35flag], al	; electrically compatible 3.5 incher?
 13500 000014C5 59                      		pop	cx
 13501 000014C6 58                      		pop	ax
 13502 000014C7 7442                    		jz	short ec35_special_stuff_done
 13503                                  					; done if this floppy is not an	ec35
 13504 000014C9 53                      		push	bx		; free up a far	pointer	(es:bx)
 13505 000014CA 06                      		push	es
 13506                                  		; 17/10/2022
 13507 000014CB 2EC41E[A014]            		les	bx, [cs:DTYPEARRAY]
 13508                                  		;les	bx, dword ptr cs:DTYPEARRAY ; [cs:dtype_array]
 13509                                  					; 0070h:3A65h =	2C7h:14F5h
 13510 000014D0 00D3                    		add	bl, dl
 13511 000014D2 80D700                  		adc	bh, 0		; find entry for this drive
 13512 000014D5 26C60793                		mov	byte [es:bx], 93h ; establish drive type as:
 13513                                  					; (360k	disk in	360k drive,
 13514                                  					; no double-stepping, 250 kbs transfer rate)
 13515 000014D9 07                      		pop	es
 13516 000014DA 5B                      		pop	bx
 13517 000014DB EB2E                    		jmp	short ec35_special_stuff_done
 13518                                  ; ---------------------------------------------------------------------------
 13519                                  
 13520                                  ; 16/10/2022
 13521                                  
 13522                                  ; ps2_30 machine has some problem with ah=8h (read drive parm), int 13h.
 13523                                  ; this function does not reset the common buses after the execution.
 13524                                  ; to solve this problem, when we detect ah=8h, then we will save the result and
 13525                                  ; will issue ah=1 (read status) call to reset the buses.
 13526                                  
 13527                                  ps2_special_stuff:			
 13528 000014DD 803E[1E00]08            		cmp	byte [prevoper], 8 ; (ps2_30)
 13529                                  					; read driver parm ?
 13530 000014E2 7407                    		jz	short ps2_30_problem
 13531 000014E4 803E[1E00]15            		cmp	byte [prevoper], 15h
 13532                                  					; apparently function 15h fails, too
 13533 000014E9 752D                    		jnz	short ps2_special_stuff_done
 13534                                  ps2_30_problem:				
 13535 000014EB 50                      		push	ax
 13536 000014EC B401                    		mov	ah, 1
 13537                                  		;;call	far 70:797h ; MSDOS 6.21 IO.SYS BIOSCODE:1543h
 13538                                  		; 17/10/2022
 13539 000014EE 9A[9707]7000            		call	DOSBIOSSEG:call_orig13
 13540                                  		;call	call_orig13	; call far 70:797h
 13541                                  					; call far KERNEL_SEGMENT:call_orig13
 13542 000014F3 58                      		pop	ax
 13543 000014F4 EB22                    		jmp	short ps2_special_stuff_done
 13544                                  ; ---------------------------------------------------------------------------
 13545                                  
 13546                                  ; 17/10/2022
 13547                                  ; 16/10/2022
 13548                                  
 13549                                  ; here is the actual int13 handler
 13550                                  
 13551                                  i13z:					; 0070h:3ABBh =	02C7h:154Bh
 13552                                  
 13553                                  ; cas -- inefficient! could push ds and load ds-> Bios_Data before
 13554                                  ; vectoring up here from Bios_Data
 13555                                  
 13556                                  		; 19/10/2022
 13557 000014F6 1E                      		push	ds		; save caller's ds register first thing
 13558                                  		;;mov	ds, word [cs:0030h]
 13559                                  					; and set up our own ds -> Bios_Data
 13560 000014F7 2E8E1E[3000]            		mov	ds, [cs:BIOSDATAWORD]
 13561                                  		;mov	ds, word ptr cs:BIOSDATAWORD ; [cs:0030h]
 13562                                  					; = [02C7h:0030h] = [0070h:25A0h]
 13563                                  
 13564                                  ; let the operation proceed. if there is a dma violation, then we do things
 13565                                  
 13566 000014FC A3[1E00]                		mov	[prevoper], ax	; save request
 13567 000014FF 80FC05                  		cmp	ah, 5		; romformat
 13568 00001502 74A0                    		jz	short format_special_stuff
 13569                                  					; go do special stuff for format
 13570                                   format_special_stuff_done:		
 13571 00001504 803E[3105]00            		cmp	byte [ec35flag], 0 ; any electrically compat 3.5 inchers?
 13572 00001509 75AA                    		jnz	short ec35_special_stuff
 13573                                  					; go handle it out of line if so
 13574                                  ec35_special_stuff_done:
 13575                                  		;;call	far 70:797h ; MSDOS 6.21 IO.SYS BIOSCODE:1560h		
 13576 0000150B 9A[9707]7000            		call	DOSBIOSSEG:call_orig13
 13577                                  		;call	call_orig13	; call far KERNEL_SEGMENT:call_orig13
 13578                                  		
 13579 00001510 9C                      		pushf			; save result flags
 13580                                  		
 13581 00001511 803E[3E06]FA            		cmp	byte [model_byte], 0FAh ; is this a ps2/30?
 13582                                  					; mdl_ps2_30
 13583 00001516 74C5                    		jz	short ps2_special_stuff
 13584                                  					; exit mainline to address special
 13585                                  ps2_special_stuff_done:			; ps2/30 problem if so		
 13586 00001518 9D                      		popf
 13587 00001519 7221                    		jb	short goterr13	; error	on original orig13 call-thru?
 13588                                  ret_from_i13:				
 13589 0000151B 1F                      		pop	ds
 13590 0000151C CA0200                  		retf	2		; restore ds &	iret w/flags
 13591                                  ; ---------------------------------------------------------------------------
 13592                                  
 13593                                  ; most of our code exits through here. If carry isn't set, then
 13594                                  ; just do a simple exit. Else doublecheck that we aren't getting
 13595                                  ; a changeline error.
 13596                                  
 13597                                  i13ret_ck_chglinerr:			
 13598 0000151F 73FA                    		jnb	short ret_from_i13 ; done if not an error termination
 13599                                  i13_ret_error:				
 13600 00001521 80FC06                  		cmp	ah, 6		; did i	see a change event?
 13601 00001524 7513                    		jnz	short int13b	; skip if wrong	error
 13602 00001526 08D2                    		or	dl, dl		; is this for the hard disk?
 13603 00001528 780F                    		js	short int13b	; yes, ignore
 13604 0000152A 803E[7700]00            		cmp	byte [fhave96], 0
 13605 0000152F 7408                    		jz	short int13b	; just in case ROM returned this
 13606                                  					; error	even though it told us it
 13607                                  					; never	would
 13608 00001531 53                      		push	bx
 13609 00001532 BB4000                  		mov	bx, 40h		; fchanged
 13610 00001535 E8B203                  		call	set_changed_dl
 13611 00001538 5B                      		pop	bx
 13612                                  int13b:					
 13613 00001539 F9                      		stc			; now return the error
 13614 0000153A EBDF                    		jmp	short ret_from_i13
 13615                                  ; ---------------------------------------------------------------------------
 13616                                  
 13617                                  ; some kind of error occurred. see if it is dma violation
 13618                                  
 13619                                  goterr13:				
 13620 0000153C 80FC09                  		cmp	ah, 9		; dma error?
 13621 0000153F 747C                    		jz	short gotdmaerr
 13622                                  goterr13_xxxx:				
 13623 00001541 80FC11                  		cmp	ah, 11h		; ecc error?
 13624 00001544 75DB                    		jnz	short i13_ret_error ; other error. just	return back.
 13625 00001546 803E[3806]01            		cmp	byte [media_set_for_format], 1 ; formatting?
 13626 0000154B 74D4                    		jz	short i13_ret_error
 13627                                  
 13628 0000154D 803E[1F00]02            		cmp	byte [prevoper+1], 2
 13629                                  		;cmp	byte ptr ds:prevoper+1,	2 ; ecc-corrected error
 13630                                  					; (2 = romread)
 13631                                  					; ECC correction only applies to reads
 13632 00001552 75CD                    		jnz	short i13_ret_error
 13633                                  
 13634 00001554 30E4                    		xor	ah, ah
 13635                                  		;;call	far 70:797h ; MSDOS 6.21 IO.SYS BIOSCODE:15ABh
 13636                                  		; 17/10/2022
 13637 00001556 9A[9707]7000            		call	DOSBIOSSEG:call_orig13
 13638                                  		;call	call_orig13	; call far KERNEL_SEGMENT:call_orig13
 13639                                  					; call far 70:797h
 13640 0000155B A1[1E00]                		mov	ax, [prevoper]
 13641 0000155E 30E4                    		xor	ah, ah		; return code =	no error
 13642 00001560 3C01                    		cmp	al, 1		; if request for one sector, assume ok
 13643 00001562 74B7                    		jz	short ret_from_i13 ; return with carry clear
 13644 00001564 53                      		push	bx
 13645 00001565 51                      		push	cx
 13646 00001566 52                      		push	dx
 13647 00001567 A2[2000]                		mov	[number_of_sec], al
 13648                                  loop_ecc:				
 13649 0000156A B80102                  		mov	ax, 201h	; read one sector
 13650                                  
 13651                                  ; we do reads one sector at a time. this ensures that we will eventually
 13652                                  ; finish the request since ecc errors on one sector do read in that sector.
 13653                                  ;
 13654                                  ; we need to put in some "intelligence" into the ecc handler to handle reads
 13655                                  ; that attempt to read more sectors than are available on a particular
 13656                                  ; track.
 13657                                  ;
 13658                                  ; we call check_wrap to set up the sector #, head # and cylinder # for
 13659                                  ; this request.
 13660                                  ;
 13661                                  ; at this point, all registers are set up for the call to orig13, except
 13662                                  ; that there may be a starting sector number that is bigger than the number
 13663                                  ; of sectors on a track.
 13664                                  ;
 13665 0000156D E88DFE                  		call	check_wrap	; get correct parameters for int 13
 13666                                  		;;call	far 70:797h ; MSDOS 6.21 IO.SYS BIOSCODE:15C5h
 13667                                  		; 17/10/2022
 13668 00001570 9A[9707]7000            		call	DOSBIOSSEG:call_orig13
 13669                                  		;call	call_orig13	; call far KERNEL_SEGMENT:call_orig13
 13670 00001575 730C                    		jnb	short ok11_op
 13671 00001577 80FC09                  		cmp	ah, 9		; DMA error during ECC read?
 13672 0000157A 741B                    		jz	short handle_dma_during_ecc
 13673 0000157C 80FC11                  		cmp	ah, 11h		; only allow ecc errors
 13674 0000157F 7510                    		jnz	short ok11_exit_err
 13675                                  		; 10/12/2022
 13676                                  		; xor ax ax -> ah = 0
 13677                                  		;mov	ah, 0		; ecc error. reset the system again.
 13678 00001581 31C0                    		xor	ax, ax		; clear	the error code so that if this
 13679                                  					; was the last sector, no error	code
 13680                                  					; will be returned for the corrected
 13681                                  					; read.	(clear carry too.)
 13682                                  ok11_op:				
 13683 00001583 FE0E[2000]              		dec	byte [number_of_sec]
 13684 00001587 7409                    		jz	short ok11_exit	; all done?
 13685 00001589 FEC1                    		inc	cl		; advance sector number
 13686                                  					; add 200h to address
 13687 0000158B FEC7                    		inc	bh
 13688 0000158D FEC7                    		inc	bh
 13689 0000158F EBD9                    		jmp	short loop_ecc
 13690                                  ; ---------------------------------------------------------------------------
 13691                                  
 13692                                  ; locate error returns centrally
 13693                                  
 13694                                  ok11_exit_err:				
 13695 00001591 F9                      		stc			; set carry bit again.
 13696                                  ok11_exit:				
 13697 00001592 5A                      		pop	dx
 13698 00001593 59                      		pop	cx
 13699 00001594 5B                      		pop	bx
 13700 00001595 EB88                    		jmp	short i13ret_ck_chglinerr
 13701                                  ; ---------------------------------------------------------------------------
 13702                                  
 13703                                  ; do the single sector read again, this time into our temporary
 13704                                  ; buffer, which is guaranteed not to have a DMA error, then
 13705                                  ; move the data to its proper location and proceed
 13706                                  
 13707                                  handle_dma_during_ecc:			
 13708 00001597 06                      		push	es
 13709 00001598 53                      		push	bx
 13710 00001599 BB[4E01]                		mov	bx, disksector
 13711 0000159C 1E                      		push	ds
 13712 0000159D 07                      		pop	es		; point es:bx to buffer
 13713 0000159E B80102                  		mov	ax, 201h	; read one sector
 13714                                  		;;call	far 70:797h ; MSDOS 6.21 IO.SYS BIOSCODE:15F8h
 13715                                  		; 17/10/2022
 13716 000015A1 9A[9707]7000            		call	DOSBIOSSEG:call_orig13
 13717                                  		;call	call_orig13	; call far KERNEL_SEGMENT:call_orig13
 13718 000015A6 5B                      		pop	bx
 13719 000015A7 07                      		pop	es
 13720 000015A8 7305                    		jnb	short handle_dma_during_ecc_noerr
 13721 000015AA 80FC11                  		cmp	ah, 11h
 13722 000015AD 75E2                    		jnz	short ok11_exit_err ; if anything but ecc error, bomb out
 13723                                  
 13724                                  ; now we're kosher. Copy the data to where it belongs and resume
 13725                                  ; the ECC looping code.
 13726                                  
 13727                                  handle_dma_during_ecc_noerr:		
 13728 000015AF 56                      		push	si
 13729 000015B0 57                      		push	di
 13730 000015B1 89DF                    		mov	di, bx
 13731 000015B3 BE[4E01]                		mov	si, disksector
 13732 000015B6 E829FE                  		call	move_sector
 13733 000015B9 5F                      		pop	di
 13734 000015BA 5E                      		pop	si
 13735 000015BB EBC6                    		jmp	short ok11_op
 13736                                  ; ---------------------------------------------------------------------------
 13737                                  
 13738                                  ; we truly have a dma violation. restore register ax and retry the
 13739                                  ; operation as best we can.
 13740                                  
 13741                                  gotdmaerr:				
 13742 000015BD A1[1E00]                		mov	ax, [prevoper]	; 19/10/2022
 13743 000015C0 FB                      		sti
 13744 000015C1 80FC02                  		cmp	ah, 2		; romread
 13745 000015C4 723B                    		jb	short i13_done_dmaerr
 13746                                  					; just pass dma error thru for
 13747                                  					; functions we don't handle
 13748 000015C6 80FC04                  		cmp	ah, 4		; romverify
 13749 000015C9 743C                    		jz	short intverify
 13750 000015CB 80FC05                  		cmp	ah, 5		; romformat
 13751 000015CE 7448                    		jz	short intformat
 13752 000015D0 772F                    		ja	short i13_done_dmaerr
 13753                                  
 13754                                  ; we are doing a read/write call. check for dma problems
 13755                                  
 13756                                  ;	******** set up stack frame here!!! ********
 13757                                  
 13758 000015D2 52                      		push	dx
 13759 000015D3 51                      		push	cx
 13760 000015D4 53                      		push	bx
 13761 000015D5 50                      		push	ax
 13762 000015D6 55                      		push	bp
 13763 000015D7 89E5                    		mov	bp, sp
 13764 000015D9 8CC2                    		mov	dx, es		; check	for 64k	boundary error
 13765 000015DB D1E2                    		shl	dx, 1
 13766 000015DD D1E2                    		shl	dx, 1
 13767 000015DF D1E2                    		shl	dx, 1
 13768 000015E1 D1E2                    		shl	dx, 1		; segment converted to absolute	address
 13769 000015E3 01DA                    		add	dx, bx		; combine with offset
 13770 000015E5 81C2FF01                		add	dx, 511		; simulate a transfer
 13771                                  
 13772                                  ; if carry is set, then we are within 512 bytes of the end of the segment.
 13773                                  ; we skip the first transfer and perform the remaining buffering and transfer
 13774                                  
 13775 000015E9 7303                    		jnb	short no_skip_first
 13776 000015EB E98300                  		jmp	bufferx		; restore dh=head & do buffer
 13777                                  ; ---------------------------------------------------------------------------
 13778                                  
 13779                                  no_skip_first:				
 13780 000015EE D0EE                    		shr	dh, 1		; dh = number of sectors before	address
 13781 000015F0 B480                    		mov	ah, 128		; ah = max number of sectors in	segment
 13782 000015F2 28F4                    		sub	ah, dh
 13783                                  
 13784                                  ; ah is now the number of sectors that we can successfully write in this
 13785                                  ; segment. if this number is above or equal to the requested number, then we
 13786                                  ; continue the operation as normal. otherwise, we break it into pieces.
 13787                                  ;
 13788                                  ; wait a sec. this is goofy. the whole reason we got here in the
 13789                                  ; first place is because we got a dma error. so it's impossible
 13790                                  ; for the whole block to fit, unless the dma error was returned
 13791                                  ; in error.
 13792                                  
 13793 000015F4 38C4                    		cmp	ah, al		; can we fit it	in?
 13794 000015F6 7236                    		jb	short doblock	; no, perform blocking.
 13795                                  
 13796                                  ; yes, the request fits. let it happen.
 13797                                  
 13798 000015F8 8A7609                  		mov	dh, [bp+9]	; [bp+INT13FRAME.olddx+1]
 13799                                  					; set up head number
 13800 000015FB E888FE                  		call	doint
 13801 000015FE E9D900                  		jmp	bad13		; and return from this place
 13802                                  ; ---------------------------------------------------------------------------
 13803                                  
 13804                                  i13_done_dmaerr:			
 13805 00001601 B409                    		mov	ah, 9		; pass dma error thru to caller
 13806 00001603 F9                      		stc
 13807 00001604 E914FF                  		jmp	ret_from_i13	; return with error,
 13808                                  					; we know it's not a changeline error
 13809                                  ; ---------------------------------------------------------------------------
 13810                                  
 13811                                  ; verify the given sectors. place the buffer pointer into our space.
 13812                                  
 13813                                  intverify:				
 13814 00001607 06                      		push	es		; save caller's dma address
 13815 00001608 53                      		push	bx
 13816 00001609 1E                      		push	ds		; es:bx	-> Bios_Data:disksector
 13817 0000160A 07                      		pop	es
 13818                                  dosimple:				
 13819 0000160B BB[4E01]                		mov	bx, disksector
 13820                                  					; do the i/o from Bios_Data:disksector
 13821                                  		;;call	far 70:797h ; MSDOS 6.21 IO.SYS BIOSCODE:1665h
 13822                                  		; 17/10/2022
 13823 0000160E 9A[9707]7000            		call	DOSBIOSSEG:call_orig13
 13824                                  		;call	call_orig13	; call far KERNEL_SEGMENT:call_orig13
 13825 00001613 5B                      		pop	bx
 13826 00001614 07                      		pop	es
 13827 00001615 E907FF                  		jmp	i13ret_ck_chglinerr
 13828                                  ; ---------------------------------------------------------------------------
 13829                                  
 13830                                  ; format operation. copy the parameter table into Bios_Data:disksector
 13831                                  
 13832                                  intformat:				
 13833 00001618 06                      		push	es
 13834 00001619 53                      		push	bx
 13835 0000161A 56                      		push	si
 13836 0000161B 57                      		push	di
 13837 0000161C 1E                      		push	ds
 13838                                  
 13839                                  ; point ds to the caller's dma buffer, es to Bios_Data
 13840                                  ; in other words, swap (ds, es)
 13841                                  
 13842 0000161D 06                      		push	es
 13843 0000161E 1E                      		push	ds
 13844 0000161F 07                      		pop	es
 13845 00001620 1F                      		pop	ds
 13846 00001621 89DE                    		mov	si, bx
 13847 00001623 BF[4E01]                		mov	di, disksector
 13848 00001626 E8B9FD                  		call	move_sector	; user's data into Bios_Data:disksector
 13849 00001629 1F                      		pop	ds
 13850 0000162A 5F                      		pop	di
 13851 0000162B 5E                      		pop	si		; do the i/o from
 13852 0000162C EBDD                    		jmp	short dosimple	; Bios_Data:disksector
 13853                                  ; ---------------------------------------------------------------------------
 13854                                  
 13855                                  ; we can't fit the request into the entire block. perform the operation on
 13856                                  ; the first block.
 13857                                  ;
 13858                                  ; doblock is modified to correctly handle multi-sector disk i/o.
 13859                                  ; old doblock had added the number of sectors i/oed (ah in old doblock) after
 13860                                  ; the doint call to cl. observing only the lower 6 bits of cl(=max. 64) can
 13861                                  ; represent a starting sector, if ah was big, then cl would be clobbered.
 13862                                  ; by the way, we still are going to use cl for this purpose since checkwrap
 13863                                  ; routine will use it as an input. to prevent cl from being clobbered, a
 13864                                  ; safe number of sectors should be calculated like "63 - # of sectors/track".
 13865                                  ; doblock will handle the first block of requested sectors within the
 13866                                  ; boundary of this safe value.
 13867                                  
 13868                                  doblock:
 13869                                  
 13870                                  ; try to get the # of sectors/track from bds via rom drive number.
 13871                                  ; for any mini disks installed, here we have to pray that they have the
 13872                                  ; same # of sector/track as the main dos partition disk drive.
 13873                                  				
 13874 0000162E 8B5608                  		mov	dx, [bp+8]	; [bp+INT13FRAME.olddx]
 13875                                  					; get head #, drive #
 13876 00001631 51                      		push	cx
 13877 00001632 06                      		push	es
 13878 00001633 57                      		push	di		; ah - # of sectors before dma boundary
 13879                                  					; al - requested # of sectors for i/o.
 13880 00001634 E83BFE                  		call	find_bds
 13881 00001637 268B4D13                		mov	cx, [es:di+13h]	; [es:di+BDS.secpertrack]
 13882                                  		; 12/12/2022
 13883 0000163B 26F6452301              		test	byte [es:di+23h], 1
 13884                                  		;test	word [es:di+23h], 1 ; [es:di+BDS.flags],fnon_removable
 13885 00001640 5F                      		pop	di
 13886 00001641 07                      		pop	es
 13887 00001642 88E0                    		mov	al, ah		; set al=ah for	floppies
 13888 00001644 7404                    		jz	short doblockflop ; they are track by track operation
 13889 00001646 B43F                    		mov	ah, 63		; ah = 63-secpt	(# safe	sectors??)
 13890 00001648 28CC                    		sub	ah, cl		; al - # of sectors before dma boundary
 13891                                  doblockflop:				
 13892 0000164A 59                      		pop	cx
 13893                                  doblockcontinue:			
 13894 0000164B 38C4                    		cmp	ah, al		; if safe_# >= #_of_sectors_to_go_before dma,
 13895 0000164D 7305                    		jnb	short doblocklast ; then #_of_sectors_to_go as it is for doint.
 13896 0000164F 50                      		push	ax
 13897 00001650 88E0                    		mov	al, ah		; otherwise, set al to ah to operate.
 13898 00001652 EB03                    		jmp	short doblockdoint
 13899                                  ; ---------------------------------------------------------------------------
 13900                                  
 13901                                  doblocklast:				
 13902 00001654 88C4                    		mov	ah, al
 13903 00001656 50                      		push	ax
 13904                                  doblockdoint:				; let ah = al =	# of sectors for this shot	
 13905 00001657 E82CFE                  		call	doint
 13906 0000165A 727E                    		jb	short bad13	; something happened, bye!
 13907 0000165C 58                      		pop	ax
 13908 0000165D 286602                  		sub	[bp+2],	ah	; sub [bp+INT13FRAME.oldax], ah
 13909                                  					; decrement by the successful operation
 13910 00001660 00E1                    		add	cl, ah		; advance sector #. safety gauranteed.
 13911 00001662 00E7                    		add	bh, ah		; advance dma addres
 13912 00001664 00E7                    		add	bh, ah		; twice	for 512	byte sectors
 13913 00001666 38C4                    		cmp	ah, al		; check	the previous value
 13914 00001668 740A                    		jz	short buffer	; if #_of_sectors_to_go	< safe_#,
 13915                                  					; then we are done already.
 13916 0000166A 28E0                    		sub	al, ah		; otherwise,
 13917                                  					; #_sector_to_go = #_of_sector_to_go - safe_#
 13918 0000166C E88EFD                  		call	check_wrap	; get new cx, dh for the next operation.
 13919 0000166F EBDA                    		jmp	short doblockcontinue ;	handles	next sectors left.
 13920                                  ; ---------------------------------------------------------------------------
 13921                                  
 13922                                  bufferx:				
 13923 00001671 8A7609                  		mov	dh, [bp+9]	; [bp+INT13FRAME.olddx+1]
 13924                                  					; set up head number
 13925                                  buffer:					
 13926 00001674 53                      		push	bx
 13927 00001675 8A6603                  		mov	ah, [bp+3]	; [bp+INT13FRAME.oldax+1]
 13928 00001678 80FC03                  		cmp	ah, 3		; romwrite
 13929 0000167B 7525                    		jnz	short doread	;
 13930                                  					
 13931                                  ; copy the offending sector into local buffer
 13932                                  
 13933 0000167D 06                      		push	es
 13934 0000167E 1E                      		push	ds
 13935 0000167F 56                      		push	si
 13936 00001680 57                      		push	di
 13937 00001681 1E                      		push	ds		; exchange segment registers
 13938 00001682 06                      		push	es
 13939 00001683 1F                      		pop	ds
 13940 00001684 07                      		pop	es
 13941 00001685 BF[4E01]                		mov	di, disksector	; where to move
 13942 00001688 57                      		push	di		; save it
 13943 00001689 89DE                    		mov	si, bx		; source
 13944 0000168B E854FD                  		call	move_sector	; move sector into local buffer
 13945 0000168E 5B                      		pop	bx		; new transfer address
 13946                                  					; (es:bx = Bios_Data:diskbuffer)
 13947 0000168F 5F                      		pop	di		; restore caller's di & si
 13948 00001690 5E                      		pop	si
 13949 00001691 1F                      		pop	ds		; restore Bios_Data
 13950                                  
 13951                                  ; see if we are wrapping around a track or head
 13952                                  
 13953 00001692 B001                    		mov	al, 1		; [bp+INT13FRAME.olddx]
 13954                                  					; get drive number
 13955 00001694 8A5608                  		mov	dl, [bp+8]
 13956 00001697 E863FD                  		call	check_wrap	; sets up registers if wrap-around
 13957                                  					;
 13958                                  					; ah is	function
 13959                                  					; al is	1 for single sector transfer
 13960                                  					; es:bx	is local transfer addres
 13961                                  					; cx is	track/sector number
 13962                                  					; dx is	head/drive number
 13963                                  					; si,di	unchanged
 13964 0000169A E8E9FD                  		call	doint
 13965 0000169D 07                      		pop	es		; restore caller's dma segment
 13966 0000169E 723A                    		jb	short bad13	; go clean up
 13967 000016A0 EB22                    		jmp	short dotail
 13968                                  ; ---------------------------------------------------------------------------
 13969                                  
 13970                                  ; reading a sector. do int first, then move things around
 13971                                  
 13972                                  doread:					
 13973 000016A2 06                      		push	es
 13974 000016A3 53                      		push	bx
 13975 000016A4 1E                      		push	ds		; es = Bios_Code
 13976 000016A5 07                      		pop	es
 13977 000016A6 BB[4E01]                		mov	bx, disksector
 13978 000016A9 B001                    		mov	al, 1
 13979 000016AB 8A5608                  		mov	dl, [bp+8]	; [bp+INT13FRAME.olddx]
 13980                                  					; get drive number
 13981 000016AE E84CFD                  		call	check_wrap	;
 13982                                  					; ah = function
 13983                                  					; al = 1 for single sector
 13984                                  					; es:bx	points to local	buffer
 13985                                  					; cx, dx are track/sector, head/drive
 13986 000016B1 E8D2FD                  		call	doint
 13987 000016B4 5B                      		pop	bx
 13988 000016B5 07                      		pop	es
 13989 000016B6 7222                    		jb	short bad13
 13990 000016B8 56                      		push	si
 13991 000016B9 57                      		push	di
 13992 000016BA 89DF                    		mov	di, bx
 13993 000016BC BE[4E01]                		mov	si, disksector
 13994 000016BF E820FD                  		call	move_sector
 13995 000016C2 5F                      		pop	di
 13996 000016C3 5E                      		pop	si
 13997                                  
 13998                                  ; note the fact that we've done 1 more sector
 13999                                  
 14000                                  dotail:					
 14001 000016C4 5B                      		pop	bx		; retrieve new dma area
 14002 000016C5 80C702                  		add	bh, 2		; advance over sector
 14003 000016C8 41                      		inc	cx
 14004 000016C9 8A4602                  		mov	al, [bp+2]	; [bp+INT13FRAME.oldax]
 14005 000016CC F8                      		clc
 14006 000016CD FEC8                    		dec	al
 14007 000016CF 7409                    		jz	short bad13	; no more i/o
 14008                                  
 14009                                  ; see if we wrap around a track or head boundary with starting sector
 14010                                  ; we already have the correct head number to pass to check_wrap
 14011                                  
 14012 000016D1 8A5608                  		mov	dl, [bp+8]	; [bp+INT13FRAME.olddx]
 14013 000016D4 E826FD                  		call	check_wrap
 14014 000016D7 E8ACFD                  		call	doint
 14015                                  
 14016                                  ; we are done. ax has the final code; we throw away what we got before
 14017                                  
 14018                                  ; M046  -- okay gang. Now we've either terminated our DMA loop,
 14019                                  ;	   or we've finished. If carry is set now, our only
 14020                                  ;	   hope for salvation is that it was a read operation
 14021                                  ;	   and the error code is ECC error. In that case, we'll
 14022                                  ;	   just pop the registers and go do the old ECC thing.
 14023                                  ;	   When the DMA error that got us here in the first
 14024                                  ;	   place occurs, it'll handle it.
 14025                                  
 14026                                  bad13:					
 14027 000016DA 89EC                    		mov	sp, bp
 14028 000016DC 5D                      		pop	bp
 14029 000016DD 5B                      		pop	bx
 14030 000016DE 5B                      		pop	bx
 14031 000016DF 59                      		pop	cx
 14032 000016E0 5A                      		pop	dx
 14033 000016E1 7203                    		jb	short xgoterr13_xxxx ; go handle ECC errors
 14034 000016E3 E935FE                  		jmp	ret_from_i13	; non-error exit
 14035                                  ; ---------------------------------------------------------------------------
 14036                                  
 14037                                  xgoterr13_xxxx:				
 14038 000016E6 E958FE                  		jmp	goterr13_xxxx
 14039                                  
 14040                                  ; ---------------------------------------------------------------------------
 14041                                  		; 10/12/2022
 14042                                  		;db 	0
 14043                                  ; ---------------------------------------------------------------------------
 14044                                  
 14045                                  ;Bios_Code ends
 14046                                  
 14047                                  ; 16/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 14048                                  
 14049                                  ;-----------------------------------------------------------------------------
 14050                                  ; MSBIO2.ASM - MSDOS 6.0 - 1991
 14051                                  ;-----------------------------------------------------------------------------
 14052                                  ; 17/03/2019 - Retro DOS v4.0
 14053                                  
 14054                                  		; 19/10/2022
 14055                                  dsk_init:				; 2C7h:1742h = 70h:3CB2h
 14056 000016E9 8A26[7500]              		mov	ah, [drvmax]
 14057 000016ED BF[8706]                		mov	di, dskdrvs
 14058 000016F0 1E                      		push	ds		; pass result in es:di
 14059 000016F1 07                      		pop	es
 14060 000016F2 E9C3EE                  		jmp	SetPtrSav
 14061                                  
 14062                                  ; =============== S U B	R O U T	I N E =======================================
 14063                                  
 14064                                  ;---------------------------------------------------------------------------
 14065                                  ; install_bds installs a bds at location es:di into the current linked list of
 14066                                  ; bds maintained by this device driver. it places the bds at the end of the
 14067                                  ; list. Trashes (at least) ax, bx, di, si
 14068                                  ;---------------------------------------------------------------------------
 14069                                  
 14070                                  install_bds:		
 14071 000016F5 1E                      		push	ds		; save Bios_Data segment
 14072 000016F6 BE[1901]                		mov	si, start_bds	; beginning of chain
 14073                                  
 14074                                  		; ds:si now points to link to first bds
 14075                                  		; assume bds list is non-empty
 14076                                  loop_next_bds:				
 14077 000016F9 C534                    		lds	si, [si]	; [si+BDS.link]
 14078                                  					; fetch	next bds
 14079 000016FB 268A4504                		mov	al, [es:di+4]	; [es:di+BDS.drivenum]
 14080 000016FF 384404                  		cmp	[si+4],	al	; does this one	share a	physical
 14081                                  					; drive	with new one?
 14082 00001702 7518                    		jnz	short next_bds
 14083 00001704 B310                    		mov	bl, 10h		; fi_am_mult
 14084 00001706 26085D23                		or	[es:di+23h], bl	; [es:di+BDS.flags]
 14085                                  					; set both of them to i_am_mult	if so
 14086 0000170A 085C23                  		or	[si+23h], bl	; [si+BDS.flags]
 14087 0000170D 26806523DF              		and	byte [es:di+23h], 0DFh ; [es:di+BDS.flags],~fi_own_physical
 14088                                  					; we don't own it
 14089 00001712 8A5C23                  		mov	bl, [si+23h]	; [si+BDS.flags]
 14090                                  					; determine if changeline available
 14091 00001715 80E302                  		and	bl, 2		; fchangeline
 14092 00001718 26085D23                		or	[es:di+23h], bl	; [es:di+BDS.flags]
 14093                                  next_bds:				
 14094 0000171C 833CFF                  		cmp	word [si], 0FFFFh ; [si+BDS.link],-1
 14095                                  					; are we at end	of list?
 14096 0000171F 75D8                    		jnz	short loop_next_bds
 14097 00001721 8C4402                  		mov	word [si+2], es ; [si+BDS.link+2],es
 14098                                  					; install bds
 14099 00001724 893C                    		mov	[si], di
 14100 00001726 26C705FFFF              		mov	word [es:di], 0FFFFh ; [es:di+BDS.link],-1
 14101                                  					; set next pointer to null
 14102 0000172B 1F                      		pop	ds
 14103                                  
 14104                                  ; 16/10/2022 (MSDOS 6.0 Code)
 14105                                  ;
 14106                                  ; **** If the new drive has a higher EOT value, we must alter the
 14107                                  ;      'eot' variable appropriately.
 14108                                  ;
 14109                                  ;		; 01/06/2019
 14110                                  ;		;mov	al,[es:di+52]
 14111                                  ;		mov	al,[es:di+BDS.rsecpertrack]
 14112                                  ;
 14113                                  ;		cmp	al,[eot]
 14114                                  ;		jbe	short _eot_ok
 14115                                  ;		mov	[eot],al
 14116                                  
 14117 0000172C C3                      		retn
 14118                                  
 14119                                  ; ---------------------------------------------------------------------------
 14120                                  
 14121                                  ; 17/10/2022
 14122                                  ;DRVLET	equ drvlet - DOSBIOSEG_2C7h
 14123                                  ;SNGMSG	equ sngmsg - DOSBIOSEG_2C7h	
 14124                                  ; 09/12/2022
 14125                                  DRVLET equ drvlet
 14126                                  SNGMSG equ sngmsg
 14127                                  
 14128                                  ; 16/10/2022
 14129                                  
 14130                                  ;---------------------------------------------------------------------------
 14131                                  ;  ask to swap the disk in drive a:
 14132                                  ;	es:di -> bds
 14133                                  ;	ds -> Bios_Data
 14134                                  ;---------------------------------------------------------------------------
 14135                                  
 14136                                  		; 19/10/2022
 14137 0000172D F606[CE08]01            swpdsk:		test	byte [IsWin386], 1			
 14138                                  		;test	ds:IsWin386, 1	; Is win386 present?
 14139 00001732 7405                    		jz	short no_win386	; no, skip SetFocus
 14140                                  		
 14141                                  		; set focus to the correct VM
 14142                                  		;;call	far 70h:8D1h	; MSDOS 6.21 IO.SYS BIOSCODE:179Ah
 14143                                  		; 17/10/2022
 14144 00001734 9A[CF08]7000            		call	DOSBIOSSEG:V86_Crit_SetFocus
 14145                                  		;call	far ptr	V86_Crit_SetFocus ; call far 70h:8D1h
 14146                                  					; call far KERNEL_SEGMENT:V86_Crit_SetFocus
 14147                                  no_win386:				
 14148 00001739 51                      		push	cx
 14149 0000173A 52                      		push	dx
 14150 0000173B 268A5505                		mov	dl, [es:di+5]	; [es:di+BDS.drivelet]
 14151                                  					; get the drive	letter
 14152                                  
 14153                                  ; WARNING : next two instructions assume that if the new disk is for drive B
 14154                                  ;           then existing dsk is drive A & vice versa
 14155                                  
 14156 0000173F 88D6                    		mov	dh, dl
 14157 00001741 80F601                  		xor	dh, 1
 14158 00001744 29C9                    		sub	cx, cx		; nobody has handled swap disk
 14159 00001746 B8004A                  		mov	ax, 4A00h	; multMULT<<8)|multMULTSWPDSK
 14160                                  					; broad	cast code for swap disk
 14161                                  					; Broadcast it
 14162 00001749 CD2F                    		int	2Fh	
 14163 0000174B 41                      		inc	cx		; cx == -1 ?
 14164 0000174C 741E                    		jz	short swpdsk9	; somebody has handled it
 14165                                  
 14166                                  ; using a different drive in a one drive system so request the user change disks
 14167                                  
 14168 0000174E 80C241                  		add	dl, 'A'
 14169                                  		; 17/10/2022
 14170 00001751 2E8816[8B17]            		mov	[cs:DRVLET], dl
 14171                                  		; 16/10/2022
 14172                                  		;;mov	byte [cs:drvlet], dl
 14173                                  		;mov	byte ptr cs:17E4h, dl ; [cs:drvlet]
 14174                                  					; 0070h:3D54h =	2C7h:17E4h
 14175 00001756 BE[6F17]                		mov	si, SNGMSG
 14176                                  		;mov	si, 17C8h	; sngmsg
 14177                                  					; 0070h:3D38h =	2C7h:17C8h
 14178 00001759 53                      		push	bx
 14179 0000175A 2E                      		cs
 14180 0000175B AC                      		lodsb			; get the next character of the message
 14181                                  		;lods	byte ptr cs:[si]
 14182                                  wrmsg_loop:				
 14183 0000175C CD29                    		int	29h		; DOS 2+ internal - FAST PUTCHAR
 14184                                  					; AL = character to display
 14185 0000175E 2E                      		cs
 14186 0000175F AC                      		lodsb
 14187                                  		;lods	byte ptr cs:[si] ; cs lodsb
 14188                                  					; get the next character of the	message
 14189 00001760 08C0                    		or	al, al
 14190 00001762 75F8                    		jnz	short wrmsg_loop
 14191 00001764 E8A0EA                  		call	con_flush	; flush out keyboard queue
 14192                                  					; call rom-bios
 14193 00001767 30E4                    		xor	ah, ah
 14194 00001769 CD16                    		int	16h		; KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY
 14195                                  					; Return: AH = scan code, AL = character
 14196 0000176B 5B                      		pop	bx
 14197                                  swpdsk9:				
 14198 0000176C 5A                      		pop	dx
 14199 0000176D 59                      		pop	cx
 14200 0000176E C3                      		retn
 14201                                  
 14202                                  ; ---------------------------------------------------------------------------
 14203                                  
 14204                                  ; 16/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 14205                                  
 14206                                  ;--------------------------------------------------------
 14207                                  ; include msbio.cl2 (MSDOS 6.0, 1991)
 14208                                  ;--------------------------------------------------------
 14209                                  ; (MSDOS 6.21 IO.SYS BIOSCODE:17D5h)
 14210                                  ;--------------------------------------------------------
 14211                                  ; 17/03/2019 - Retro DOS v4.0
 14212                                  
 14213                                  		; MSDOS 5.0 IO.SYS offset 0070h:3D38h or 02C7h:17C8h
 14214 0000176F 0D0A                    sngmsg:		db 0Dh,0Ah
 14215 00001771 496E73657274206469-     		db 'Insert diskette for drive '
 14215 0000177A 736B6574746520666F-
 14215 00001783 7220647269766520   
 14216                                  
 14217                                  		; MSDOS 5.0 IO.SYS offset 0070h:3D54h or 02C7h:17E4h
 14218 0000178B 413A20616E64207072-     drvlet:		db 'A: and press any key when ready',0Dh,0Ah
 14218 00001794 65737320616E79206B-
 14218 0000179D 6579207768656E2072-
 14218 000017A6 656164790D0A       
 14219 000017AC 0A00                    		db 0Ah,0
 14220                                  
 14221                                  ; =============== S U B	R O U T	I N E =======================================
 14222                                  
 14223                                  ;---------------------------------------------------------------------------
 14224                                  ; input : es:di points to current bds for drive.
 14225                                  ; return : zero set if no open files
 14226                                  ;	   zero reset if open files
 14227                                  ;---------------------------------------------------------------------------
 14228                                  
 14229                                  chkopcnt:		
 14230 000017AE 26837D2000              		cmp	word [es:di+20h], 0 ; [es:di+BDS.opcnt]
 14231 000017B3 C3                      		retn
 14232                                  
 14233                                  ; =============== S U B	R O U T	I N E =======================================
 14234                                  
 14235                                  ;---------------------------------------------------------------------------
 14236                                  ; at media check time, we need to really get down and check what the change is.
 14237                                  ; this is guaranteed to be expensive.
 14238                                  ;
 14239                                  ;	es:di -> bds, ds -> Bios_Data
 14240                                  ;---------------------------------------------------------------------------
 14241                                  
 14242                                  mediacheck:	
 14243 000017B4 E885F0                  		call	checksingle	; make sure correct disk is in place
 14244 000017B7 31F6                    		xor	si, si
 14245 000017B9 E85501                  		call	haschange
 14246 000017BC 742F                    		jz	short mediaret
 14247 000017BE E84401                  		call	checkromchange
 14248 000017C1 752B                    		jnz	short mediadovolid
 14249 000017C3 50                      		push	ax
 14250 000017C4 52                      		push	dx
 14251 000017C5 268A5504                		mov	dl, [es:di+4]	; [es:di+BDS.drivenum]
 14252                                  					; set logical drive number
 14253 000017C9 B416                    		mov	ah, 16h
 14254 000017CB CD13                    		int	13h		; DISK - FLOPPY	DISK - CHANGE OF DISK STATUS (AT,XT2,XT286,CONV,PS)
 14255                                  					; DL = drive to	check
 14256                                  					; Return: AH = disk change status
 14257 000017CD 5A                      		pop	dx
 14258 000017CE 58                      		pop	ax
 14259 000017CF 721D                    		jb	short mediadovolid
 14260 000017D1 BE0100                  		mov	si, 1		; signal no change
 14261                                  
 14262                                  ; there are some drives with changeline that "lose" the changeline indication
 14263                                  ; if a different drive is accessed after the current one. in order to avoid
 14264                                  ; missing a media change, we return an "i don't know" to dos if the changeline
 14265                                  ; is not active and we are accessing a different drive from the last one.
 14266                                  ; if we are accessing the same drive, then we can safely rely on the changeline
 14267                                  ; status.
 14268                                  		; 19/10/2022
 14269 000017D4 8A1E[1E01]              		mov	bl, [tim_drv]	; get last drive accessed
 14270 000017D8 26385D04                		cmp	[es:di+4], bl	; [es:di+BDS.drivenum]
 14271                                  					; (If the last drive accessed is not current drive
 14272                                  					; media	change status may be incorrect.	So,
 14273                                  					; "I don't now" will be returned even if it is indicated
 14274                                  					; as media is not changed.)
 14275 000017DC 740F                    		jz	short mediaret	; (same	drive,
 14276                                  					; media	changeline indication is reliable)
 14277                                  
 14278                                  ; do the 2 second twiddle. if time >= 2 seconds, do a volid check.
 14279                                  ; otherwise return "i don't know" (strictly speaking, we should return a
 14280                                  ; "not changed" here since the 2 second test said no change.)
 14281                                  
 14282 000017DE 50                      		push	ax
 14283 000017DF 51                      		push	cx
 14284 000017E0 52                      		push	dx
 14285 000017E1 E86FED                  		call	Check_Time_Of_Access
 14286 000017E4 5A                      		pop	dx
 14287 000017E5 59                      		pop	cx
 14288 000017E6 58                      		pop	ax
 14289 000017E7 09F6                    		or	si, si
 14290 000017E9 7403                    		jz	short mediadovolid ; check_time	says ">= 2 secs	passed"
 14291                                  					; (volume id will be checked)
 14292 000017EB 31F6                    		xor	si, si		; return "i don't know"
 14293                                  mediaret:				
 14294 000017ED C3                      		retn
 14295                                  ; ---------------------------------------------------------------------------
 14296                                  
 14297                                  ; somehow the media was changed. look at vid to see. we do not look at fat
 14298                                  ; because this may be different since we only set medbyt when doing a read
 14299                                  ; or write.
 14300                                  
 14301                                  mediadovolid:				
 14302 000017EE E807EE                  		call	GetBp		; build	a new bpb in current bds
 14303 000017F1 72FA                    		jb	short mediaret
 14304 000017F3 E82D00                  		call	check_vid
 14305 000017F6 73F5                    		jnb	short mediaret
 14306 000017F8 E9D6F3                  		jmp	maperror	; fix up al for	return to dos
 14307                                  ; ---------------------------------------------------------------------------
 14308                                  
 14309                                  ; simple, quick check of latched change. if no indication, then return
 14310                                  ; otherwise do expensive check. if the expensive test fails, pop off the
 14311                                  ; return and set al = 15 (for invalid media change) which will be returned to
 14312                                  ; dos.
 14313                                  ;
 14314                                  ; for dos 3.3, this will work only for the drive that has changeline.
 14315                                  
 14316                                  ;	call with es:di -> bds, ds -> Bios_Data
 14317                                  ;	***** warning:  this routine will return one level up on the stack
 14318                                  ;			if an error occurs!
 14319                                  
 14320                                  checklatchio:	
 14321                                  
 14322                                  ; if returning fake bpb then assume the disk has not changed
 14323                                  			
 14324 000017FB E8B0FF                  		call	chkopcnt
 14325 000017FE 741B                    		jz	short checkret	; done if zero
 14326                                  
 14327                                  ; check for past rom indications. if no rom change indicated, then return ok.
 14328                                  
 14329 00001800 E80201                  		call	checkromchange
 14330 00001803 7416                    		jz	short checkret
 14331                                  
 14332                                  ; we now see that a change line has been seen in the past. let's do the
 14333                                  ; expensive verification.
 14334                                  
 14335 00001805 E8F0ED                  		call	GetBp		; build	bpb in current bds
 14336 00001808 720F                    		jb	short ret_no_error_map ; getbp has already called maperror
 14337 0000180A E81600                  		call	check_vid
 14338 0000180D 7207                    		jb	short checklatchret ; disk error trying	to read	in.
 14339 0000180F 09F6                    		or	si, si		; is changed for sure?
 14340 00001811 7908                    		jns	short checkret
 14341 00001813 E87D00                  		call	returnvid
 14342                                  checklatchret:				
 14343 00001816 E8B8F3                  		call	maperror	; fix up al for	return to dos
 14344                                  ret_no_error_map:			
 14345 00001819 F9                      		stc
 14346 0000181A 5E                      		pop	si		; pop off return address
 14347                                  checkret:				
 14348 0000181B C3                      		retn
 14349                                  ; ---------------------------------------------------------------------------
 14350                                  
 14351                                  ; check the fat and the vid. return in di -1 or 0. return with carry set
 14352                                  ; only if there was a disk error. return that error code in ax.
 14353                                  ;
 14354                                  ;	called with es:di -> bds, ds -> Bios_Data
 14355                                  
 14356                                  checkfatvid:				
 14357 0000181C E8CD01                  		call	fat_check	; check	the fat	and the	vid
 14358 0000181F 09F6                    		or	si, si
 14359 00001821 7827                    		js	short changed_drv ;
 14360                                  
 14361                                  ; the fat was the same. fall into check_vid and check volume id.
 14362                                  
 14363                                  		; fall into check_vid
 14364                                  
 14365                                  ; =============== S U B	R O U T	I N E =======================================
 14366                                  
 14367                                  ; now with the extended boot record, the logic should be enhanced.
 14368                                  ;
 14369                                  ; if it is the extended boot record, then we check the volume serial
 14370                                  ; number instead of volume id. if it is different, then set si to -1.
 14371                                  ;
 14372                                  ; if it is same, then si= 1 (no change).
 14373                                  ;
 14374                                  ; if it is not the extended boot record, then just follows the old
 14375                                  ; logic. dos 4.00 will check if the # of fat in the boot record bpb
 14376                                  ; is not 0.  if it is 0 then it must be non_fat based system and
 14377                                  ; should have already covered by extended boot structure checking.
 14378                                  ; so, we will return "i don't know" by setting si to 0.
 14379                                  ;
 14380                                  ; this routine assume the newest valid boot record is in cs:[disksector].
 14381                                  ; (this will be gauranteed by a successful getbp call right before this
 14382                                  ; routine.)
 14383                                  ;
 14384                                  ;	called with es:di -> bds, ds -> bds
 14385                                  
 14386                                  		; 19/10/2022
 14387                                  check_vid:
 14388                                  
 14389                                  ; check the disksector.EXT_BOOT_SIG variable for the extended
 14390                                  ; boot signature. if it is set then go to do the extended
 14391                                  ; id check otherwise continue with code below
 14392                                  
 14393 00001823 803E[7401]29            		cmp	byte [disksector+26h], 29h
 14394                                  					; [disksector+EXT_BOOT.SIG],
 14395                                  					; EXT_BOOT_SIGNATURE
 14396 00001828 7427                    		jz	short do_ext_check_id
 14397 0000182A E8E400                  		call	haschange
 14398 0000182D 74EC                    		jz	short checkret
 14399 0000182F 31F6                    		xor	si, si
 14400 00001831 803E[5E01]00            		cmp	byte [disksector+10h], 0 
 14401                                  					; [disksector+EXT_BOOT.BPB+EBPB.NUMBEROFFATS]
 14402 00001836 7411                    		jz	short checkfatret ; don't read vol id
 14403                                  					; if not fat system
 14404 00001838 E8F600                  		call	read_volume_id
 14405 0000183B 720C                    		jb	short checkfatret
 14406 0000183D E89B01                  		call	check_volume_id
 14407 00001840 BEFFFF                  		mov	si, 0FFFFh	; -1
 14408                                  					; definitely changed
 14409 00001843 7505                    		jnz	short changed_drv
 14410                                  
 14411 00001845 46                      		inc	si		; not changed
 14412                                  vid_no_changed:				
 14413 00001846 E8C200                  		call	resetchanged
 14414                                  		; 12/12/2022
 14415                                  		; cf=0 ('and' instruction in 'resetchanged' clears cf) 
 14416                                  		;clc
 14417                                  checkfatret:				
 14418 00001849 C3                      		retn
 14419                                  ; ---------------------------------------------------------------------------
 14420                                  
 14421                                  		; 12/12/2022
 14422                                  changed_drv:
 14423 0000184A F8                      		clc			; cas -- return	no error
 14424 0000184B C606[1E01]FF            		mov	byte  [tim_drv], 0FFh 
 14425                                  					; ensure that we ask rom for media
 14426 00001850 C3                      		retn			; check	next time round
 14427                                  ; ---------------------------------------------------------------------------
 14428                                  
 14429                                  ; extended id check
 14430                                  
 14431                                  ; 16/10/2022
 14432                                  
 14433                                  ; the code to check extended id is basically a check to see if the
 14434                                  ; volume serial number is still the same. the volume serial number
 14435                                  ; previously read is in cs:disksector.EXT_BOOT_SERIAL
 14436                                  ; ds:di points to the bds of the drive under consideration.
 14437                                  ; the bds has fields containing the high and low words 
 14438                                  ; of the volume serial number of the media in the drive.
 14439                                  ; compare these fields to the fields mentioned above. if these fields
 14440                                  ; do not match the media has changed and so we should jump to the code
 14441                                  ; starting at ext_changed else return "i don't know" status
 14442                                  ; in the register used for the changeline status and continue executing
 14443                                  ; the code given below. for temporary storage use the register which
 14444                                  ; has been saved and restored around this block.
 14445                                  ;
 14446                                  ; bds fields in inc\msbds.inc
 14447                                  
 14448                                  		; 19/10/2022
 14449                                  do_ext_check_id:			
 14450 00001851 50                      		push	ax
 14451                                  		;mov	ax, word ptr ds:disksector+27h
 14452                                  					; [DiskSector+EXT_BOOT.SERIAL]
 14453 00001852 A1[7501]                		mov	ax, [disksector+27h]
 14454 00001855 263B4557                		cmp	ax, [es:di+57h]	; [di+BDS.vol_serial]
 14455 00001859 750E                    		jnz	short ext_changed
 14456 0000185B A1[7701]                		mov	ax, [disksector+29h] ; [DiskSector+EXT_BOOT.SERIAL+2]
 14457 0000185E 263B4559                		cmp	ax, [es:di+59h]	; [di+BDS.vol_serial+2]
 14458 00001862 7505                    		jnz	short ext_changed
 14459 00001864 31F6                    		xor	si, si		; 0
 14460                                  					; don't know
 14461 00001866 58                      		pop	ax
 14462 00001867 EBDD                    		jmp	short vid_no_changed
 14463                                  					; reset the flag
 14464                                  ; ---------------------------------------------------------------------------
 14465                                  
 14466                                  ext_changed:				
 14467 00001869 58                      		pop	ax
 14468 0000186A BEFFFF                  		mov	si, 0FFFFh	; -1
 14469                                  					; disk changed!
 14470                                  		; 12/12/2022
 14471                                  		; ('changed_drv' clears cf)
 14472                                  		;clc
 14473 0000186D EBDB                    		jmp	short changed_drv
 14474                                  
 14475                                  ; ---------------------------------------------------------------------------
 14476                                  
 14477                                  ; at i/o time, we detected the error. now we need to determine whether the
 14478                                  ; media was truly changed or not. we return normally if media change unknown.
 14479                                  ; and we pop off the call and jmp to harderr if we see an error.
 14480                                  ;
 14481                                  ; es:di -> bds
 14482                                  
 14483                                  checkio:				
 14484 0000186F 80FC06                  		cmp	ah, 6
 14485 00001872 75D5                    		jnz	short checkfatret
 14486 00001874 E837FF                  		call	chkopcnt
 14487 00001877 74D0                    		jz	short checkfatret
 14488 00001879 E87CED                  		call	GetBp
 14489 0000187C 7212                    		jb	short no_error_map
 14490 0000187E E89BFF                  		call	checkfatvid
 14491 00001881 7209                    		jb	short checkioret ; disk	error trying to	read in.
 14492 00001883 09F6                    		or	si, si		; is changed for sure?
 14493 00001885 7802                    		js	short checkioerr ; yes changed
 14494 00001887 45                      		inc	bp		; allow	a retry
 14495 00001888 C3                      		retn
 14496                                  ; ---------------------------------------------------------------------------
 14497                                  
 14498                                  checkioerr:				
 14499 00001889 E80700                  		call	returnvid
 14500                                  
 14501                                  checkioret:				
 14502 0000188C F9                      		stc			; make sure carry gets passed through
 14503 0000188D E9F1F2                  		jmp	harderr
 14504                                  ; ---------------------------------------------------------------------------
 14505                                  
 14506                                  no_error_map:				
 14507 00001890 E9F1F2                  		jmp	harderr2
 14508                                  
 14509                                  ; =============== S U B	R O U T	I N E =======================================
 14510                                  
 14511                                  ; return vid sets up the vid for a return to dos.
 14512                                  ;  es:di -> bds, returns pointer in packet to bds_volid
 14513                                  ;  **** trashes si! ****
 14514                                  
 14515                                  returnvid:		
 14516 00001893 BE1600                  		mov	si, 22		; extra
 14517                                  					; offset into pointer to return	value
 14518 00001896 E80700                  		call	vid_into_packet
 14519 00001899 B406                    		mov	ah, 6
 14520 0000189B F9                      		stc
 14521 0000189C C3                      		retn
 14522                                  
 14523                                  ; ---------------------------------------------------------------------------
 14524                                  
 14525                                  ; moves the pointer to the volid for the drive into the original request packet
 14526                                  ; no attempt is made to preserve registers.
 14527                                  ;
 14528                                  ; assumes es:di -> bds
 14529                                  ; **trashes si**
 14530                                  
 14531                                  media_set_vid:				
 14532 0000189D BE0F00                  		mov	si, 15		; trans+1
 14533                                  					; return the value here	in packet
 14534                                  
 14535                                  		; fall into vid_into_packet
 14536                                  
 14537                                  ; =============== S U B	R O U T	I N E =======================================
 14538                                  
 14539                                  ; return pointer to vid in bds at es:di in packet[si]
 14540                                  
 14541                                  		; 19/10/2022
 14542                                  vid_into_packet:
 14543 000018A0 1E                      		push	ds		; return pointer to vid	in bds at es:di	in packet[si]
 14544 000018A1 C51E[1200]              		lds	bx, [ptrsav]
 14545 000018A5 83C74B                  		add	di, 75		; BDS.volid
 14546 000018A8 8938                    		mov	[bx+si], di
 14547 000018AA 83EF4B                  		sub	di, 75		; BDS.volid
 14548 000018AD 8C4002                  		mov	[bx+si+2], es
 14549 000018B0 1F                      		pop	ds
 14550                                  dofloppy:	; 18/12/2022
 14551 000018B1 C3                      		retn
 14552                                  
 14553                                  ; ---------------------------------------------------------------------------
 14554                                  
 14555                                  ;----------------------------------------------------------------------------
 14556                                  ;   hidensity - examine a drive/media descriptor to set the media type. if
 14557                                  ;   the media descriptor is not f9 (not 96tpi or 3 1/2), we return and let the
 14558                                  ;   caller do the rest. otherwise, we pop off the return and jump to the tail
 14559                                  ;   of getbp. for 3.5" media, we just return.
 14560                                  ;
 14561                                  ;   inputs:	es:di point to correct bds for this drive
 14562                                  ;		ah has media byte
 14563                                  ;
 14564                                  ;   outputs:	carry clear
 14565                                  ;		    no registers modified
 14566                                  ;		carry set
 14567                                  ;		    al = sectors/fat
 14568                                  ;		    bh = number of root directory entries
 14569                                  ;		    bl = sectors per track
 14570                                  ;		    cx = number of sectors
 14571                                  ;		    dh = sectors per allocation unit
 14572                                  ;		    dl = number of heads
 14573                                  ;
 14574                                  ;----------------------------------------------------------------------------
 14575                                  
 14576                                  hidensity:
 14577                                  
 14578                                  ; check for correct drive
 14579                                  		
 14580                                  		; 12/12/2022
 14581 000018B2 26F6452302              		test	byte [es:di+23h], 2		
 14582                                  		;test	word [es:di+23h], 2 ; is it special?	
 14583                                  					; [es:di+BDS.flags], fchangeline
 14584 000018B7 74F8                    		jz	short dofloppy	; no, do normal floppy test
 14585                                  
 14586                                  ; we have a media byte that is pretty complex. examine drive information
 14587                                  ; table to see what kind it is.
 14588                                  
 14589 000018B9 26807D2202              		cmp	byte [es:di+22h], 2 ; is it single-media?
 14590 000018BE 74F1                    		jz	short dofloppy	; [es:di+BDS.formfactor], ffSmall
 14591                                  					; yes, use fatid...
 14592                                  ; 96 tpi drive?
 14593 000018C0 80FCF9                  		cmp	ah, 0F9h
 14594 000018C3 75EC                    		jnz	short dofloppy
 14595                                  
 14596                                  ;------ If formfactor of drive = ffother or ff288 it has to be
 14597                                  ;------ a 720K diskette
 14598                                  
 14599 000018C5 26807D2207              		cmp	byte [es:di+22h], 7 ; [es:di+BDS.formfactor]
 14600                                  					; ffOther
 14601 000018CA 7418                    		jz	short Is720K
 14602 000018CC 26807D2209              		cmp	byte [es:di+22h], 9 ; [es:di+BDS.formfactor]
 14603                                  					; ff288
 14604 000018D1 7411                    		jz	short Is720K
 14605 000018D3 B007                    		mov	al, 7		; seven	sectors	/ fat
 14606 000018D5 BB0FE0                  		mov	bx, 57359	; 224*256+0Fh
 14607                                  					; 224 root dir entries
 14608                                  					; & 0Fh sector max
 14609 000018D8 B96009                  		mov	cx, 2400	; 80*15*2
 14610                                  					; 80 tracks, 15 sectors/track,
 14611                                  					; 2 sides
 14612 000018DB BA0201                  		mov	dx, 258		; 1*256+2
 14613                                  					; sectors/allocation unit
 14614                                  					; & head max
 14615 000018DE 83C402                  		add	sp, 2		; pop off return address
 14616 000018E1 E986ED                  		jmp	Has1		; return to tail of getbp
 14617                                  ; ---------------------------------------------------------------------------
 14618                                  
 14619                                  Is720K:					
 14620 000018E4 83C402                  		add	sp, 2		; pop off return address
 14621 000018E7 E947ED                  		jmp	Has720K		; return to 720K code
 14622                                  ; ---------------------------------------------------------------------------
 14623                                  
 14624                                  		; 18/12/2022
 14625                                  ;dofloppy:				
 14626                                  		;retn
 14627                                  
 14628                                  ; =============== S U B	R O U T	I N E =======================================
 14629                                  
 14630                                  ; 16/10/2022
 14631                                  
 14632                                  ;---------------------------------------------------------------------------
 14633                                  ; set_changed_dl - sets flag bits according to bits set in bx.
 14634                                  ;		   essentially used to indicate changeline, or format.
 14635                                  ;
 14636                                  ;   inputs:	dl contains physical drive number
 14637                                  ;		bx contains bits to set in the flag field in the bdss
 14638                                  ;   outputs:	none
 14639                                  ;   registers modified: flags
 14640                                  ;
 14641                                  ;	called from int13 hooker.  Must preserve ALL registers!!!
 14642                                  ;
 14643                                  ; in the virtual drive system we *must* flag the other drives as being changed
 14644                                  ;---------------------------------------------------------------------------
 14645                                  
 14646                                  set_changed_dl:	
 14647 000018EA 06                      		push	es
 14648 000018EB 57                      		push	di
 14649                                  		;les	di, ds:start_bds
 14650                                  		; 19/10/2022
 14651 000018EC C43E[1901]              		les	di, [start_bds]
 14652                                  
 14653                                  ; note: we assume that the list is non-empty
 14654                                  
 14655                                  scan_bds:				
 14656 000018F0 26385504                		cmp	[es:di+4], dl	; [es:di+BDS.drivenum]
 14657 000018F4 7504                    		jnz	short get_next_bds
 14658                                  
 14659                                  ; someone may complain, but this *always* must be done when a disk change is
 14660                                  ; noted. there are *no* other compromising circumstances.
 14661                                  
 14662 000018F6 26095D23                		or	[es:di+23h], bx	; [es:di+BDS.flags]
 14663                                  					; signal change	on other drive
 14664                                  get_next_bds:				
 14665 000018FA 26C43D                  		les	di, [es:di]	; [es:di+BDS.link]
 14666                                  					; go to	next bds
 14667 000018FD 83FFFF                  		cmp	di, 0FFFFh
 14668 00001900 75EE                    		jnz	short scan_bds	; loop unless we hit end of chain
 14669 00001902 5F                      		pop	di
 14670 00001903 07                      		pop	es
 14671 00001904 C3                      		retn
 14672                                  
 14673                                  ; =============== S U B	R O U T	I N E =======================================
 14674                                  
 14675                                  ;---------------------------------------------------------------------------
 14676                                  ; checkromchange - see if external program has diddled rom change line.
 14677                                  ;
 14678                                  ;   inputs:	es:di points to current bds.
 14679                                  ;   outputs:	zero set - no change
 14680                                  ;		zero reset - change
 14681                                  ;   registers modified: none
 14682                                  ;---------------------------------------------------------------------------
 14683                                  
 14684                                  checkromchange:	
 14685                                  		;test	word [es:di+BDS.flags], fchanged ; 40h
 14686                                  		; 10/12/2022
 14687 00001905 26F6452340              		test	byte [es:di+23h], 40h
 14688                                  		;test	word [es:di+23h], 40h ; [es:di+BDS.flags]
 14689                                  					; fchanged
 14690 0000190A C3                      		retn
 14691                                  
 14692                                  ; =============== S U B	R O U T	I N E =======================================
 14693                                  
 14694                                  ;---------------------------------------------------------------------------
 14695                                  ; resetchanged - restore value of change line
 14696                                  ;
 14697                                  ;   inputs:	es:di points to current bds
 14698                                  ;   outputs:	none
 14699                                  ;   registers modified: none
 14700                                  ;---------------------------------------------------------------------------
 14701                                  
 14702                                  resetchanged:	
 14703                                  		;and	word [es:di+BDS.flags], ~fchanged ; 0FFBFh	
 14704                                  		; 10/12/2022
 14705 0000190B 26806523BF              		and	byte [es:di+23h], 0BFh
 14706                                  		;and	word [es:di+23h], 0FFBFh ; [es:di+BDS.flags]
 14707                                  					; ~fchanged
 14708 00001910 C3                      		retn
 14709                                  
 14710                                  ; =============== S U B	R O U T	I N E =======================================
 14711                                  
 14712                                  ;---------------------------------------------------------------------------
 14713                                  ; haschange - see if drive can supply change line
 14714                                  ;
 14715                                  ;   inputs:	es:di points to current bds
 14716                                  ;   outputs:	zero set - no change line available
 14717                                  ;		zero reset - change line available
 14718                                  ;   registers modified: none
 14719                                  ;---------------------------------------------------------------------------
 14720                                  
 14721                                  haschange:
 14722                                  		;test	word [es:di+BDS.flags], fchangeline ; 2
 14723                                  		; 10/12/2022
 14724 00001911 26F6452302              		test	byte [es:di+23h], 2		
 14725                                  		;test	word [es:di+23h], 2 ; [es:di+BDS.flags]
 14726                                  					; fchangeline
 14727 00001916 C3                      		retn
 14728                                  
 14729                                  ; ---------------------------------------------------------------------------
 14730                                  
 14731                                  ; 16/10/2022
 14732                                  
 14733                                  ;-------------------------------------------------------------------------
 14734                                  ; set_volume_id      -	main routine, calls other routines.
 14735                                  ; read_volume_id     -	read the volume id and tells if it has been changed.
 14736                                  ; transfer_volume_id -	copy the volume id from tmp to special drive.
 14737                                  ; check_volume_id    -	compare volume id in tmp area with one expected for drive.
 14738                                  ; fat_check          -	see of the fatid has changed in the specified drive.
 14739                                  ;-------------------------------------------------------------------------
 14740                                  
 14741                                  ; set_volume_id
 14742                                  ;   if drive has changeline support, read in and set the volume_id
 14743                                  ; and the last fat_id byte. if no change line support then do nothing.
 14744                                  ;
 14745                                  ;   on entry:
 14746                                  ;	es:di points to the bds for this disk.
 14747                                  ;	ah contains media byte
 14748                                  ;
 14749                                  ;   on exit:
 14750                                  ;	carry clear:
 14751                                  ;	   successful call
 14752                                  ;	carry set
 14753                                  ;	   error and ax has error code
 14754                                  
 14755                                  set_volume_id:				
 14756 00001917 52                      		push	dx		; save registers
 14757 00001918 50                      		push	ax
 14758 00001919 E8F5FF                  		call	haschange	; does drive have changeline support?
 14759 0000191C 740B                    		jz	short setvret	; no, get out
 14760 0000191E E81000                  		call	read_volume_id
 14761 00001921 7209                    		jb	short seterr
 14762 00001923 E8A200                  		call	transfer_volume_id ; copy the volume id	to special drive
 14763 00001926 E8E2FF                  		call	resetchanged	; restore value	of change line
 14764                                  setvret:				
 14765                                  		; 10/12/2022
 14766                                  		; cf = 0
 14767                                  		;clc			; no error, clear carry flag
 14768 00001929 58                      		pop	ax		; restore registers
 14769 0000192A 5A                      		pop	dx
 14770 0000192B C3                      		retn
 14771                                  ; ---------------------------------------------------------------------------
 14772                                  
 14773                                  seterr:					
 14774 0000192C 5A                      		pop	dx		; pop stack but don't overwrite ax
 14775 0000192D 5A                      		pop	dx		; restore dx
 14776 0000192E C3                      		retn
 14777                                  ; ---------------------------------------------------------------------------
 14778 0000192F 0000                    root_sec:	dw 0			; root sector #
 14779                                  
 14780                                  ; 16/10/2022
 14781                                  ;ROOTSEC equ root_sec - DOSBIOSEG_2C7h		
 14782                                  ; 09/12/2022
 14783                                  ROOTSEC equ root_sec
 14784                                  
 14785                                  ; =============== S U B	R O U T	I N E =======================================
 14786                                  
 14787                                  ; 16/10/2022
 14788                                  
 14789                                  ; read_volume_id read the volume id and tells if it has been changed.
 14790                                  ;
 14791                                  ;   on entry:
 14792                                  ;	es:di points to current bds for drive.
 14793                                  ;
 14794                                  ;   on exit:
 14795                                  ;	carry clear
 14796                                  ;	    si = 1  no change
 14797                                  ;	    si = 0  ?
 14798                                  ;	    si = -1 change
 14799                                  ;
 14800                                  ;	carry set:
 14801                                  ;	    error and ax has error code.
 14802                                  
 14803                                  read_volume_id:
 14804 00001931 52                      		push	dx		; preserve registers
 14805 00001932 51                      		push	cx
 14806 00001933 53                      		push	bx
 14807 00001934 50                      		push	ax
 14808 00001935 06                      		push	es		; stack the bds last
 14809 00001936 57                      		push	di
 14810 00001937 1E                      		push	ds		; point es to Bios_Data
 14811 00001938 07                      		pop	es
 14812 00001939 BF[0A09]                		mov	di, tmp_vid	; "NO NAME	 "
 14813 0000193C BE[FE08]                		mov	si, nul_vid	; "NO NAME	 "
 14814 0000193F B90C00                  		mov	cx, 12		; initialize tmp_vid to	null vi_id
 14815 00001942 F3A4                    		rep movsb
 14816 00001944 5F                      		pop	di
 14817 00001945 07                      		pop	es
 14818 00001946 268A450B                		mov	al, [es:di+11]	; [es:di+BDS.fats]
 14819                                  					; # of fats
 14820 0000194A 268B4D11                		mov	cx, [es:di+17]	; [es:di+BDS.fatsecs]
 14821                                  					; sectors / fat
 14822 0000194E F6E1                    		mul	cl		; size taken by	fats
 14823 00001950 26034509                		add	ax, [es:di+9]	; [es:di+BDS.resectors]
 14824                                  					; add on reserved sectors
 14825                                  					;
 14826                                  					; ax is	now sector # (0	based)
 14827                                  		; 17/10/2022
 14828 00001954 2EA3[2F19]              		mov	[cs:ROOTSEC], ax
 14829                                  		;mov	word ptr cs:198Fh, ax ; [cs:root_sec]
 14830                                  					; 0070h:3EFFh =	2C7h:198Fh
 14831 00001958 268B450C                		mov	ax, [es:di+12]	; [es:di+BDS.direntries]
 14832                                  					; # root dir entries
 14833 0000195C B104                    		mov	cl, 4		; 16 entries/sector
 14834 0000195E D3E8                    		shr	ax, cl		; divide by 16
 14835 00001960 89C1                    		mov	cx, ax		; cx is	# of sectors to	scan
 14836                                  next_sec:				
 14837 00001962 51                      		push	cx		; save outer loop counter
 14838 00001963 2EA1[2F19]              		mov	ax, [cs:ROOTSEC]
 14839                                  		;mov	ax, word ptr cs:198Fh ; [cs:root_sec]
 14840                                  					; get sector #
 14841 00001967 268B4D13                		mov	cx, [es:di+19]	; [es:di+BDS.secpertrack]
 14842                                  					; sectors / track
 14843 0000196B 31D2                    		xor	dx, dx
 14844 0000196D F7F1                    		div	cx
 14845                                  
 14846                                  ; set up registers for call to read_sector
 14847                                  
 14848 0000196F 42                      		inc	dx		; dx= sectors into track
 14849                                  					; ax= track count from 0
 14850 00001970 88D1                    		mov	cl, dl		; sector to read
 14851 00001972 31D2                    		xor	dx, dx
 14852 00001974 26F77515                		div	word [es:di+21] ; [es:di+BDS.heads]
 14853                                  					; # heads on this disc
 14854 00001978 88D6                    		mov	dh, dl		; head number
 14855 0000197A 88C5                    		mov	ch, al		; track	#
 14856 0000197C E8FBED                  		call	read_sector	; get first sector of the root directory,
 14857                                  					; ds:bx	-> directory sector
 14858 0000197F 7243                    		jb	short readviderr
 14859 00001981 B91000                  		mov	cx, 16		; # of dir entries in a	block of root
 14860 00001984 B008                    		mov	al, 8		; volume label bit
 14861                                  fvid_loop:				
 14862 00001986 803F00                  		cmp	byte [bx], 0 ; end of dir?
 14863 00001989 7436                    		jz	short no_vid	; yes, no vol id
 14864 0000198B 803FE5                  		cmp	byte [bx], 0E5h ; empty entry?
 14865 0000198E 7405                    		jz	short ent_loop	; yes, skip
 14866 00001990 84470B                  		test	[bx+11], al	; is volume label bit set in fcb?
 14867 00001993 7511                    		jnz	short found_vid	; jmp yes
 14868                                  ent_loop:				
 14869 00001995 83C320                  		add	bx, 32		; add length of	directory entry
 14870 00001998 E2EC                    		loop	fvid_loop
 14871 0000199A 59                      		pop	cx		; outer loop
 14872 0000199B 2EFF06[2F19]            		inc	word [cs:ROOTSEC]
 14873                                  		;inc	word ptr cs:198Fh ; inc word [root_sec]
 14874                                  					; next sector
 14875 000019A0 E2C0                    		loop	next_sec	; continue
 14876                                  notfound:				
 14877 000019A2 31F6                    		xor	si, si
 14878 000019A4 EB16                    		jmp	short fvid_ret
 14879                                  ; ---------------------------------------------------------------------------
 14880                                  
 14881                                  found_vid:				
 14882 000019A6 59                      		pop	cx		; clean stack of outer loop counter
 14883 000019A7 89DE                    		mov	si, bx		; point	to volume_id
 14884 000019A9 06                      		push	es		; preserve current bds
 14885 000019AA 57                      		push	di
 14886 000019AB 1E                      		push	ds
 14887 000019AC 07                      		pop	es		; point es to Bios_Data
 14888 000019AD BF[0A09]                		mov	di, tmp_vid	; "NO NAME	 "
 14889 000019B0 B90B00                  		mov	cx, 11		; VOLID_SIZ-1
 14890                                  					; length of string minus nul
 14891 000019B3 F3A4                    		rep movsb		; mov volume label to tmp_vid
 14892 000019B5 30C0                    		xor	al, al
 14893 000019B7 AA                      		stosb			; null terminate
 14894 000019B8 31F6                    		xor	si, si
 14895 000019BA 5F                      		pop	di		; restore current bds
 14896 000019BB 07                      		pop	es
 14897                                  fvid_ret:				
 14898 000019BC 58                      		pop	ax
 14899                                  		; 10/12/2022
 14900                                  		; cf = 0
 14901                                  		;clc
 14902                                  rvidret:				
 14903 000019BD 5B                      		pop	bx		; restore registers
 14904 000019BE 59                      		pop	cx
 14905 000019BF 5A                      		pop	dx
 14906 000019C0 C3                      		retn
 14907                                  ; ---------------------------------------------------------------------------
 14908                                  
 14909                                  no_vid:					
 14910 000019C1 59                      		pop	cx		; clean stack of outer loop counter
 14911 000019C2 EBDE                    		jmp	short notfound	; not found
 14912                                  ; ---------------------------------------------------------------------------
 14913                                  
 14914                                  readviderr:				
 14915 000019C4 5E                      		pop	si		; trash the outer loop counter
 14916 000019C5 5E                      		pop	si		; caller's ax, return error code instead 
 14917 000019C6 EBF5                    		jmp	short rvidret
 14918                                  
 14919                                  ; =============== S U B	R O U T	I N E =======================================
 14920                                  
 14921                                  ; transfer_volume_id - copy the volume id from tmp to special drive
 14922                                  ;
 14923                                  ; inputs:	es:di has current bds
 14924                                  ; outputs:	bds for drive has volume id from tmp
 14925                                  
 14926                                  transfer_volume_id:	
 14927 000019C8 57                      		push	di		; copy the volume id from tmp to special drive
 14928 000019C9 56                      		push	si
 14929 000019CA 51                      		push	cx
 14930 000019CB BE[0A09]                		mov	si, tmp_vid	; "NO NAME	 "
 14931                                  		;add	di, BDS.volid
 14932 000019CE 83C74B                  		add	di, 75		; BDS.volid
 14933                                  		;mov	cx, VOLID_SIZ
 14934 000019D1 B90C00                  		mov	cx, 12		; VOLID_SIZ
 14935 000019D4 FC                      		cld
 14936 000019D5 F3A4                    		rep movsb
 14937 000019D7 59                      		pop	cx
 14938 000019D8 5E                      		pop	si
 14939 000019D9 5F                      		pop	di
 14940 000019DA C3                      		retn
 14941                                  
 14942                                  ; =============== S U B	R O U T	I N E =======================================
 14943                                  
 14944                                  ;  check_volume_id - compare volume id in tmp area with
 14945                                  ;		     one expected for drive
 14946                                  ;
 14947                                  ;   inputs:	es:di has current bds for drive
 14948                                  ;   outputs:	zero true means it matched
 14949                                  
 14950                                  check_volume_id:	
 14951 000019DB 57                      		push	di
 14952 000019DC 51                      		push	cx
 14953 000019DD BE[0A09]                		mov	si, tmp_vid	; "NO NAME	 "
 14954                                  		;add	di, BDS.volid
 14955 000019E0 83C74B                  		add	di, 75		; BDS.volid
 14956                                  		;mov	cx, VOLID_SIZ
 14957 000019E3 B90C00                  		mov	cx, 12		; VOLID_SIZ
 14958 000019E6 FC                      		cld
 14959 000019E7 F3A6                    		repe cmpsb		; are the 2 volume_ids the same?
 14960 000019E9 59                      		pop	cx
 14961 000019EA 5F                      		pop	di
 14962 000019EB C3                      		retn
 14963                                  
 14964                                  ; =============== S U B	R O U T	I N E =======================================
 14965                                  
 14966                                  ;   fat_check - see of the fatid has changed in the specified drive.
 14967                                  ;	      - uses the fat id obtained from the boot sector.
 14968                                  ;
 14969                                  ;   inputs:	medbyt is expected fat id
 14970                                  ;		es:di points to current bds
 14971                                  ;
 14972                                  ;   output:	si = -1 if fat id different,
 14973                                  ;		si = 0 otherwise
 14974                                  ;
 14975                                  ;   no other registers changed.
 14976                                  
 14977                                  fat_check:		
 14978 000019EC 50                      		push	ax
 14979 000019ED 31F6                    		xor	si, si		; say fat id's are same.
 14980 000019EF A0[1F01]                		mov	al, [medbyt]	; 19/10/2022
 14981 000019F2 263A4510                		cmp	al, [es:di+10h]	; [es:di+BDS.media]
 14982                                  					; compare it with the bds medbyte
 14983 000019F6 7401                    		jz	short okret1	; carry	clear
 14984 000019F8 4E                      		dec	si
 14985                                  okret1:					
 14986 000019F9 58                      		pop	ax
 14987 000019FA C3                      		retn
 14988                                  
 14989                                  ; ---------------------------------------------------------------------------
 14990                                  
 14991                                  ; BIOSCODE:1A69h (MSDOS 6.21, IO.SYS)
 14992                                  		;times 7 db 0
 14993                                  
 14994                                  ; BIOSCODE:180Bh (MSDOS 5.0 IO.SYS)	
 14995                                  
 14996                                  		; 09/12/2022
 14997                                  		;times 4 db 0	; 17/10/2022
 14998                                  		;db 4 dup(0)	; times 4 db 0
 14999                                  
 15000                                  ; ---------------------------------------------------------------------------
 15001                                  
 15002                                  		; 09/12/2022
 15003                                  		;db 0
 15004                                  
 15005                                  number2div	equ ($-BCode_start)
 15006                                  number2mod	equ (number2div % 16)
 15007                                  
 15008                                  %if (number2mod>0) & (number2mod<16) ; 17/09/2023
 15009 000019FB 00<rep 5h>              		times (16-number2mod) db 0
 15010                                  %endif
 15011                                  
 15012                                  ;align 16
 15013                                  
 15014                                  ; 09/12/2022
 15015                                  BCODE_END	equ $ - BCode_start
 15016                                  ; 29/09/2023
 15017                                  BCODEEND:
 15018                                  ;SYSINITSEG	equ IOSYSCODESEG+(BCODE_END>>4)
 15019                                  ; 13/12/2022
 15020                                  SYSINITOFFSET	equ BCODE_END
 15021                                  SYSINITSEG	equ IOSYSCODESEG+(SYSINITOFFSET>>4)
 15022                                  
 15023                                  ;--- End of DOSBIOS code segment ---------------------------------------------
 15024                                  
 15025                                  ; 16/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 15026                                  ; 01/05/2019 - Retro DOS v4.0 
 15027                                  ; ============================================================================
 15028                                  ; end of BIOSCODE
 15029                                  
 15030                                  ; ----------------------------------------------------------------------------
 15031                                  ; %include sysinit5.s	; 09/12/2022
 15032                                  ; ----------------------------------------------------------------------------
 15033                                  
 15034                                  ;=============================================================================
 15035                                  ; (IO.SYS) SYSINIT SEGMENT 
 15036                                  ;=============================================================================
 15037                                  ; 09/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 15038                                  
 15039                                  section .SYSINIT vstart=0
 15040                                  
 15041                                  ; ****************************************************************************
 15042                                  ; SYSINIT.BIN (MSDOS 5.0 IO.SYS) - RETRO DOS v4.0 by ERDOGAN TAN - 21/10/2022
 15043                                  ; ----------------------------------------------------------------------------
 15044                                  ; Last Update: 04/01/2023 (Modified IO.SYS)  ((Previous: 31/12/2022))
 15045                                  ; ----------------------------------------------------------------------------
 15046                                  ; Beginning: 03/06/2018 (Retro DOS 3.0), 21/03/2019 (Retro DOS 4.0)
 15047                                  ; ----------------------------------------------------------------------------
 15048                                  ; Assembler: NASM version 2.15
 15049                                  ; ----------------------------------------------------------------------------
 15050                                  ;	   ((nasm sysinit5.s -l sysinit5.lst -o SYSINIT5.BIN -Z error.txt)) 	
 15051                                  ; ----------------------------------------------------------------------------
 15052                                  ; Modified from 'sysinit2.s' (SYSINIT2.BIN) file of Retro DOS v3.0 (6/7/2018)
 15053                                  ; ----------------------------------------------------------------------------
 15054                                  ; Derived from 'SYSINIT1.ASM' and 'SYSINIT2.ASM' files of MSDOS 6.0
 15055                                  ; source code by Microsoft, 1991 
 15056                                  ; ----------------------------------------------------------------------------
 15057                                  ; Derived from 'SYSINIT.ASM' file of MSDOS 2.0 (IBM PCDOS v2.0) source code
 15058                                  ; by Microsoft, 12/10/1983
 15059                                  ; ****************************************************************************
 15060                                  ; main file: 'retrodos4.s'
 15061                                  ; incbin 'SYSINIT3.BIN' ; (SYINITSEG)
 15062                                  
 15063                                  ; 21/10/2022
 15064                                  ; ----------------------------------------------------------------------------
 15065                                  ; This source code (version) is based on SYSINIT source code of disassembled
 15066                                  ; MSDOS 5.0 IO.SYS file (SYSINIT.BIN) 
 15067                                  ; Dissassembler: Hex-Rays Interactive Disassembler (IDA)
 15068                                  ; ----------------------------------------------------------------------------
 15069                                  ; Binary file splitter & joiner: FFSJ v3.3
 15070                                  
 15071                                  ;--------------------------------------------------------------
 15072                                  ; SYSINIT.TXT (27/01/1983)
 15073                                  ;--------------------------------------------------------------
 15074                                  ;    SYSINIT is  a module linked behind the OEM bios.  It takes
 15075                                  ;over  the  system  initialization  after  the  OEM  bios   has
 15076                                  ;performed any  initialization  it  needs  to  do.   Control is
 15077                                  ;transfered with a long jump to the external  variable  SYSINIT
 15078                                  ;
 15079                                  ;
 15080                                  ;   The OEM  has  the  following  variables declared external:
 15081                                  ;
 15082                                  ;   CURRENT_DOS_LOCATION    WORD
 15083                                  ;
 15084                                  ;This word  contains  the  segment  number of the DOS before it
 15085                                  ;is relocated.  The OEM bios must set this value.
 15086                                  ;
 15087                                  ;   FINAL_DOS_LOCATION      WORD
 15088                                  ;
 15089                                  ;This word contains the segment number of the DOS after SYSINIT
 15090                                  ;moves it.  The OEM bios must set this value.
 15091                                  ;
 15092                                  ;   DEVICE_LIST             DWORD
 15093                                  ;
 15094                                  ;This  double  word  pointer  points  to  the  linked  list  of
 15095                                  ;character and block device drivers.  The  OEM  must  set  this
 15096                                  ;value.
 15097                                  ;
 15098                                  ;   MEMORY_SIZE             WORD
 15099                                  ;
 15100                                  ;This word  contains  the  number  of  RAM  paragraphs.  If the
 15101                                  ;bios doesn't set  this  variable  SYSINIT  will  automatically
 15102                                  ;calculate it.   NOTE:  systems with PARITY checked memory must
 15103                                  ;size memory in the BIOS.  SYSINITs method is to  write  memory
 15104                                  ;and read it back until it gets a mismatch.
 15105                                  ;
 15106                                  ;   DEFAULT_DRIVE           BYTE
 15107                                  ;
 15108                                  ;This is  the initial default drive when the system first comes
 15109                                  ;up.  drive a=0, drive b=1,  etc.   If  the  bios  doesn't  set
 15110                                  ;it then drive a is assumed.
 15111                                  ;
 15112                                  ;   BUFFERS                 BYTE
 15113                                  ;
 15114                                  ;This is  the  default  number of buffers for the system.  This
 15115                                  ;value may be overridden by the user in  the  CONFIG.SYS  file.
 15116                                  ;It is DBed to 2 in SYSINIT it should be greater than 1.
 15117                                  ;
 15118                                  ;   FILES                   BYTE
 15119                                  ;
 15120                                  ;This is  the  default  number  of  files for the system.  This
 15121                                  ;value may be overridden by the user in  the  CONFIG.SYS  file.
 15122                                  ;It is  DBed  to  8 in SYSINIT, values less than 5 are ignored.
 15123                                  ;
 15124                                  ;   SYSINIT                 FAR
 15125                                  ;
 15126                                  ;The entry  point  of  the  SYSINIT  module.  OEM BIOS jumps to
 15127                                  ;this label at the end of its INIT code.
 15128                                  ;
 15129                                  ;   The OEM  has  the  following  variables declared public:
 15130                                  ;
 15131                                  ;   RE_INIT                 FAR
 15132                                  ;
 15133                                  ;This is an entry point which allows the BIOS to do some INIT
 15134                                  ;work  after  the  DOS is initialized.  ALL REGISTERS MUST BE
 15135                                  ;PRESERVED.  On entry DS points to the first available memory
 15136                                  ;(after  the DOS).  DS:0 points to a 100H byte program header
 15137                                  ;prefix which represents  the  "program"  currently  running.
 15138                                  ;This  program  should  be  thought  of  as  the OEM BIOS and
 15139                                  ;SYSINIT taken together.  This is not  a  normal  program  in
 15140                                  ;that  no  memory  is  allocated to it, it is running in free
 15141                                  ;memory.
 15142                                  ;NOTES:
 15143                                  ;     At the time this routine is called SYSINIT occupies the
 15144                                  ;highest 10K of memory ("highest" is determined by the  value
 15145                                  ;of the MEMORY_SIZE variable), DO NOT DO WRITES THERE.
 15146                                  ;     Since this is called AFTER DOS is initialized, you can
 15147                                  ;make system calls.  This also implies that the code for this
 15148                                  ;routine    CANNOT   be   thrown   away   by   use   of   the
 15149                                  ;FINAL_DOS_LOCATION since the DOS has already been moved.
 15150                                  ;     If you don't want  anything done just set this to point
 15151                                  ;at a FAR RET instruction.
 15152                                  
 15153                                  ; ----------------------------------------------------------------------
 15154                                  ; TITLE   BIOS SYSTEM INITIALIZATION
 15155                                  ; ----------------------------------------------------------------------
 15156                                  
 15157                                  ;include version.inc
 15158                                  ; ----------------------------------------------------------------------
 15159                                  
 15160                                  ;FALSE   EQU     0
 15161                                  ;TRUE    EQU     0FFFFh
 15162                                  
 15163                                  ;IBMVER	    EQU     TRUE
 15164                                  ;IBMCOPYRIGHT EQU   FALSE
 15165                                  ;STACKSW    EQU	    TRUE		;Include Switchable Hardware Stacks
 15166                                  ;IBMJAPVER  EQU     FALSE		; If TRUE set KANJI true also
 15167                                  ;MSVER      EQU     FALSE
 15168                                  ;ALTVECT    EQU     FALSE		; Switch to build ALTVECT version
 15169                                  ;KANJI      EQU     FALSE
 15170                                  
 15171                                  ;(MSDOS 6.0, versiona.inc, 1991)
 15172                                  ; ----------------------------------------------------------------------
 15173                                  ;MAJOR_VERSION  EQU	6
 15174                                  ;;MINOR_VERSION	EQU	0	;6.00
 15175                                  ;MINOR_VERSION  EQU	21	;6.21  ; 21/03/2019 - Retro DOS v4.0
 15176                                  
 15177                                  ; 22/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0)
 15178                                  ; ----------------------------------------------------------------------
 15179                                  MAJOR_VERSION   EQU	5
 15180                                  MINOR_VERSION   EQU	0
 15181                                  
 15182                                  expected_version equ	(MINOR_VERSION<<8)+MAJOR_VERSION
 15183                                  
 15184                                  ;DOSREVNM equ	00000000b       ; m037 - bits 0-2 = revision number of DOS
 15185                                  				; currently 0.
 15186                                  DOSREVNM equ	00000111b	; [[[ 7 for Retro DOS v4.0 ]]] (21/03/2019)	
 15187                                  DOSINROM equ	00001000B       ; bit 3 of ver flags returned in BH
 15188                                  DOSINHMA equ	00010000B       ; bit 4 of ver flags 
 15189                                  
 15190                                  ;      if1
 15191                                  ;      %OUT  ... for DOS Version 5.00 ...
 15192                                  ;      endif
 15193                                  
 15194                                         ;******************************
 15195                                         ;Each assembler program should:
 15196                                         ;  mov ah,030h                   ;DOS Get Version function
 15197                                         ;  int 021h                      ;Version ret. in AX,minor version first
 15198                                         ;  cmp ax,expected_version       ;ALL utilities should check for an
 15199                                         ;  jne error_handler             ; EXACT version match.
 15200                                         ;******************************
 15201                                  
 15202                                  ; ----------------------------------------------------------------------
 15203                                  ; device definitions
 15204                                  
 15205                                  ;Attribute bit masks
 15206                                  DEVTYP  EQU     8000h           ;Bit 15 - 1  if Char, 0 if block
 15207                                  DEVIOCTL EQU    4000h           ;Bit 14 - CONTROL mode bit
 15208                                  ISFATBYDEV EQU  2000h           ;Bit 13 - Device uses FAT ID bytes, comp media.
 15209                                  ISCIN   EQU     0001h           ;Bit 0 - This device is the console input.
 15210                                  ISCOUT  EQU     0002h           ;Bit 1 - This device is the console output.
 15211                                  ISNULL  EQU     0004h           ;Bit 2 - This device is the null device.
 15212                                  ISCLOCK EQU     0008h           ;Bit 3 - This device is the clock device.
 15213                                  ISIBM   EQU     0010h           ;Bit 4 - This device is special
 15214                                  
 15215                                  ; The device table list has the form:
 15216                                  struc	SYSDEV
 15217 00000000 ????????                .NEXT:		resd 1		;Pointer to next device header
 15218 00000004 ????                    .ATT:		resw 1		;Attributes of the device
 15219 00000006 ????                    .STRAT:		resw 1		;Strategy entry point
 15220 00000008 ????                    .INT:		resw 1		;Interrupt entry point
 15221 0000000A ????????????????        .NAME:		resb 8		;Name of device (only first byte used for block)
 15222                                  .size:
 15223                                  endstruc
 15224                                  
 15225                                  ;Static Reguest Header
 15226                                  struc	SRHEAD
 15227 00000000 ??                      .REQLEN:	resb 1		;Length in bytes of request block
 15228 00000001 ??                      .REQUNIT:	resb 1		;Device unit number
 15229 00000002 ??                      .REQFUNC:	resb 1		;Type of request
 15230 00000003 ????                    .REQSTAT:	resw 1		;Status Word
 15231 00000005 ????????????????                	resb 8		;Reserved for queue links
 15232                                  .size:
 15233                                  endstruc
 15234                                  
 15235                                  ;Status word masks
 15236                                  STERR   EQU     8000H           ;Bit 15 - Error
 15237                                  STBUI   EQU     0200H           ;Bit 9 - Buisy
 15238                                  STDON   EQU     0100H           ;Bit 8 - Done
 15239                                  STECODE EQU     00FFH           ;Error code
 15240                                  WRECODE EQU     0
 15241                                  
 15242                                  ;Function codes
 15243                                  DEVINIT EQU     0               ;Initialization
 15244                                  DINITHL EQU     26              ;Size of init header
 15245                                  DEVMDCH EQU     1               ;Media check
 15246                                  DMEDHL  EQU     15              ;Size of media check header
 15247                                  DEVBPB  EQU     2               ;Get BPB
 15248                                  DEVRDIOCTL EQU  3               ;IOCTL read
 15249                                  DBPBHL  EQU     22              ;Size of Get BPB header
 15250                                  DEVRD   EQU     4               ;Read
 15251                                  DRDWRHL EQU     22              ;Size of RD/WR header
 15252                                  DEVRDND EQU     5               ;Non destructive read no wait (character devs)
 15253                                  DRDNDHL EQU     14              ;Size of non destructive read header
 15254                                  DEVIST  EQU     6               ;Input status
 15255                                  DSTATHL EQU     13              ;Size of status header
 15256                                  DEVIFL  EQU     7               ;Input flush
 15257                                  DFLSHL  EQU     15              ;Size of flush header
 15258                                  DEVWRT  EQU     8               ;Write
 15259                                  DEVWRTV EQU     9               ;Write with verify
 15260                                  DEVOST  EQU     10              ;Output status
 15261                                  DEVOFL  EQU     11              ;Output flush
 15262                                  DEVWRIOCTL EQU  12              ;IOCTL write
 15263                                  
 15264                                  ; ----------------------------------------------------------------------
 15265                                  struc	SYS_FCB
 15266 00000000 ??                      .fcb_drive:	resb 1
 15267 00000001 ????????????????        .fcb_name:	resb 8
 15268 00000009 ??????                  .fcb_ext:	resb 3
 15269 0000000C ????                    .fcb_EXTENT:	resw 1
 15270 0000000E ????                    .fcb_RECSIZ:	resw 1	; Size of record (user settable)
 15271 00000010 ????                    .fcb_FILSIZ:	resw 1	; Size of file in bytes; used with the following
 15272                                                          ; word
 15273 00000012 ????                    .fcb_DRVBP:	resw 1	; BP for SEARCH FIRST and SEARCH NEXT
 15274 00000014 ????                    .fcb_FDATE:	resw 1	; Date of last writing
 15275 00000016 ????                    .fcb_FTIME:	resw 1	; Time of last writing
 15276 00000018 ??                      .fcb_DEVID:	resb 1	; Device ID number, bits 0-5 if file.
 15277                                                          ; bit 7=0 for file, bit 7=1 for I/O device
 15278                                                          ; If file, bit 6=0 if dirty
 15279                                                          ; If I/O device, bit 6=0 if EOF (input)
 15280                                                          ;               Bit 5=1 if Raw mode
 15281                                                          ;               Bit 0=1 if console input device
 15282                                                          ;               Bit 1=1 if console output device
 15283                                                          ;               Bit 2=1 if null device
 15284                                                          ;               Bit 3=1 if clock device
 15285 00000019 ????                    .fcb_FIRCLUS:	resw 1	; First cluster of file
 15286 0000001B ????                    .fcb_CLUSPOS:	resw 1	; Position of last cluster accessed
 15287 0000001D ????                    .fcb_LSTCLUS:	resw 1	; Last cluster accessed and directory
 15288 0000001F ??                                   	resb 1	; pack 2 12 bit numbers into 24 bits...
 15289 00000020 ??                      .fcb_NR:	resb 1	; Next record
 15290 00000021 ????????                .fcb_RR:	resb 4	; Random record
 15291                                  .size:
 15292                                  endstruc
 15293                                  
 15294                                  ; ----------------------------------------------------------------------
 15295                                  ; Field definition for I/O buffer information
 15296                                  
 15297                                  ; 22/03/2019 - Retro DOS v4.0 (MSDOS 6.0, BUFFER.INC, 1991)
 15298                                  
 15299                                  struc buffinfo
 15300 00000000 ????                    .buf_next:	resw 1	; Pointer to next buffer in list
 15301 00000002 ????                    .buf_prev:	resw 1	; Pointer to previous buffer in list
 15302 00000004 ??                      .buf_ID:	resb 1	; Drive of buffer (bit 7 = 0)
 15303                                  			; SFT table index (bit 7 = 1)
 15304                                  			; = FFh if buffer free
 15305 00000005 ??                      .buf_flags:	resb 1	; Bit 7 = 1 if Remote file buffer
 15306                                  			;	= 0 if Local device buffer
 15307                                  			; Bit 6 = 1 if buffer dirty
 15308                                  			; Bit 5 = Reserved
 15309                                  			; Bit 4 = Search bit (bit 7 = 1)
 15310                                  			; Bit 3 = 1 if buffer is DATA
 15311                                  			; Bit 2 = 1 if buffer is DIR
 15312                                  			; Bit 1 = 1 if buffer is FAT
 15313                                  			; Bit 0 = Reserved
 15314 00000006 ????????                .buf_sector:	resd 1	; Sector number of buffer (bit 7 = 0)
 15315                                  ; The next two items are often refed as a word (bit 7 = 0)
 15316 0000000A ??                      .buf_wrtcnt:	resb 1	; For FAT sectors, # times sector written out
 15317 0000000B ????                    .buf_wrtcntinc:	resw 1	; "   "     "   , # sectors between each write
 15318 0000000D ????????                .buf_DPB :	resd 1	; Pointer to drive parameters
 15319 00000011 ????                    .buf_fill:	resw 1	; How full buffer is (bit 7 = 1)
 15320 00000013 ??                      .buf_reserved:	resb 1	; make DWORD boundary for 386
 15321                                  .size:
 15322                                  endstruc
 15323                                  
 15324                                  %define buf_offset	dword [buf_sector]
 15325                                  			;For bit 7 = 1, this is the byte
 15326                                  			;offset of the start of the buffer in
 15327                                  			;the file pointed to by buf_ID.  Thus
 15328                                  			;the buffer starts at location
 15329                                  			;buf_offset in the file and contains
 15330                                  			;buf_fill bytes.
 15331                                  
 15332                                  bufinsiz	equ	buffinfo.size ; ; Size of structure in bytes
 15333                                  
 15334                                  
 15335                                  buf_Free	equ	0FFh		; buf_id of free buffer
 15336                                  
 15337                                  ;Flag byte masks
 15338                                  buf_isnet	EQU	10000000B
 15339                                  buf_dirty	EQU	01000000B
 15340                                  ;***
 15341                                  buf_visit	EQU	00100000B
 15342                                  ;***
 15343                                  buf_snbuf	EQU	00010000B
 15344                                  
 15345                                  buf_isDATA	EQU	00001000B
 15346                                  buf_isDIR	EQU	00000100B
 15347                                  buf_isFAT	EQU	00000010B
 15348                                  buf_type_0	EQU	11110001B	; AND sets type to "none"
 15349                                  
 15350                                  buf_NetID	EQU	bufinsiz
 15351                                  
 15352                                  ; ----------------------------------------------------------------------
 15353                                  
 15354                                  ; ----------------------------------------------------------------------
 15355                                  ;**	DPB - Drive Parameter Block
 15356                                  
 15357                                  ; 25/03/2019 - Retro DOS v4.0 (MSDOS 6.0, DPB.INC, 1991)
 15358                                  
 15359                                  ;	BUGBUG - this isn't authorative - it's my probably incomplete and
 15360                                  ;	possibly inaccurate deductions from code study... - jgl
 15361                                  ;
 15362                                  ;	The DPB is DOS's main structure for describing block devices.
 15363                                  ;	It contains info about the "Drive" intermingled with info about
 15364                                  ;	the FAT file system which is presumably on the drive.  I don't know
 15365                                  ;	how those fields are used if it's not the FAT file system - BUGBUG
 15366                                  ;
 15367                                  ;	The DPBs are statically allocated and chained off of DPBHead.
 15368                                  ;	Users scan this chain looking for a match on DPB_DRIVE.
 15369                                  ;	The DPBs are built at init time from info in the SYSDEV structure.
 15370                                  
 15371                                  ; 08/06/2018 - Retro DOS v3.0 (MSDOS 3.3, DPB.INC, 24/07/1987)
 15372                                  
 15373                                  ; 12/05/2019 - Retro DOS v4.0
 15374                                  
 15375                                  struc	DPB
 15376 00000000 ??                      .DRIVE:		resb 1		; Logical drive # assoc with DPB (A=0,B=1,...)
 15377 00000001 ??                      .UNIT:		resb 1		; Driver unit number of DPB
 15378 00000002 ????                    .SECTOR_SIZE:	resw 1		; Size of physical sector in bytes
 15379 00000004 ??                      .CLUSTER_MASK:	resb 1		; Sectors/cluster - 1
 15380 00000005 ??                      .CLUSTER_SHIFT:	resb 1		; Log2 of sectors/cluster
 15381 00000006 ????                    .FIRST_FAT:	resw 1		; Starting record of FATs
 15382 00000008 ??                      .FAT_COUNT:	resb 1		; Number of FATs for this drive
 15383 00000009 ????                    .ROOT_ENTRIES:	resw 1		; Number of directory entries
 15384 0000000B ????                    .FIRST_SECTOR:	resw 1		; First sector of first cluster
 15385 0000000D ????                    .MAX_CLUSTER:	resw 1		; Number of clusters on drive + 1
 15386                                  ;.FAT_SIZE:	resb 1  ; MSDOS 3.3
 15387 0000000F ????                    .FAT_SIZE:	resw 1		; Number of records occupied by FAT
 15388 00000011 ????                    .DIR_SECTOR:	resw 1		; Starting record of directory
 15389 00000013 ????????                .DRIVER_ADDR:	resd 1		; Pointer to driver
 15390 00000017 ??                      .MEDIA:		resb 1		; Media byte
 15391 00000018 ??                      .FIRST_ACCESS:	resb 1		; This is initialized to -1 to force a media
 15392                                  				; check the first time this DPB is used
 15393 00000019 ????????                .NEXT_DPB:	resd 1		; Pointer to next Drive parameter block
 15394 0000001D ????                    .NEXT_FREE:	resw 1		; Cluster # of last allocated cluster
 15395 0000001F ????                    .FREE_CNT:	resw 1		; Count of free clusters, -1 if unknown
 15396                                  .size:
 15397                                  endstruc
 15398                                  
 15399                                  DPBSIZ  EQU     DPB.size	; Size of the structure in bytes
 15400                                  
 15401                                  DSKSIZ  EQU	DPB.MAX_CLUSTER	; Size of disk (temp used during init only)
 15402                                  
 15403                                  ; ----------------------------------------------------------------------
 15404                                  ; 26/03/2018
 15405                                  
 15406                                  ; IOCTL SUB-FUNCTIONS
 15407                                  IOCTL_GET_DEVICE_INFO	EQU	0
 15408                                  IOCTL_SET_DEVICE_INFO	EQU	1
 15409                                  IOCTL_READ_HANDLE	EQU	2
 15410                                  IOCTL_WRITE_HANDLE	EQU	3
 15411                                  IOCTL_READ_DRIVE	EQU	4
 15412                                  IOCTL_WRITE_DRIVE	EQU	5
 15413                                  IOCTL_GET_INPUT_STATUS	EQU	6
 15414                                  IOCTL_GET_OUTPUT_STATUS EQU	7
 15415                                  IOCTL_CHANGEABLE?	EQU	8
 15416                                  IOCTL_SHARING_RETRY	EQU	11
 15417                                  GENERIC_IOCTL_HANDLE	EQU	12
 15418                                  GENERIC_IOCTL		EQU	13
 15419                                  
 15420                                  ; GENERIC IOCTL SUB-FUNCTIONS
 15421                                  RAWIO			EQU	8
 15422                                  
 15423                                  ; RAWIO SUB-FUNCTIONS
 15424                                  GET_DEVICE_PARAMETERS	EQU	60H
 15425                                  SET_DEVICE_PARAMETERS	EQU	40H
 15426                                  READ_TRACK		EQU	61H
 15427                                  WRITE_TRACK		EQU	41H
 15428                                  VERIFY_TRACK		EQU	62H
 15429                                  FORMAT_TRACK		EQU	42H
 15430                                  
 15431                                  ; DEVICETYPE VALUES
 15432                                  MAX_SECTORS_IN_TRACK	EQU	63
 15433                                  DEV_5INCH		EQU	0
 15434                                  DEV_5INCH96TPI		EQU	1
 15435                                  DEV_3INCH720KB		EQU	2
 15436                                  DEV_8INCHSS		EQU	3
 15437                                  DEV_8INCHDS		EQU	4
 15438                                  DEV_HARDDISK		EQU	5
 15439                                  DEV_OTHER		EQU	7
 15440                                  ;DEV_3INCH1440KB	EQU	7
 15441                                  DEV_3INCH2880KB		EQU	9
 15442                                  ; Retro DOS v2.0 - 26/03/2018
 15443                                  ;;DEV_TAPE		EQU	6
 15444                                  ;;DEV_ERIMO		EQU	8
 15445                                  ;DEV_3INCH2880KB	EQU	9
 15446                                  DEV_3INCH1440KB		EQU	10
 15447                                  
 15448                                  ;MAX_DEV_TYPE		EQU	9	; MAXIMUM DEVICE TYPE THAT WE
 15449                                  					; CURRENTLY SUPPORT.
 15450                                  MAX_DEV_TYPE		EQU	10
 15451                                  
 15452                                  struc A_SECTORTABLE
 15453 00000000 ????                    .ST_SECTORNUMBER:	resw	1
 15454 00000002 ????                    .ST_SECTORSIZE:		resw	1
 15455                                  .size:
 15456                                  endstruc
 15457                                  
 15458                                  ; 25/03/2019 - Retro DOS v4.0  (MSDOS 6.0, BPB.INC, IOCTL.INC)
 15459                                  
 15460                                  ;**	BIOS PARAMETER BLOCK DEFINITION
 15461                                  ;
 15462                                  ;	The BPB contains information about the disk structure.  It dates
 15463                                  ;	back to the earliest FAT systems and so FAT information is
 15464                                  ;	intermingled with physical driver information.
 15465                                  ;
 15466                                  ;	A boot sector contains a BPB for its device; for other disks
 15467                                  ;	the driver creates a BPB.  DOS keeps copies of some of this
 15468                                  ;	information in the DPB.
 15469                                  ;
 15470                                  ;	The BDS structure contains a BPB within it.
 15471                                  
 15472                                  struc A_BPB
 15473 00000000 ????                    .BPB_BYTESPERSECTOR:	resw	1
 15474 00000002 ??                      .BPB_SECTORSPERCLUSTER:	resb	1
 15475 00000003 ????                    .BPB_RESERVEDSECTORS:	resw	1
 15476 00000005 ??                      .BPB_NUMBEROFFATS:	resb	1
 15477 00000006 ????                    .BPB_ROOTENTRIES: 	resw	1
 15478 00000008 ????                    .BPB_TOTALSECTORS:	resw	1
 15479 0000000A ??                      .BPB_MEDIADESCRIPTOR:	resb	1
 15480 0000000B ????                    .BPB_SECTORSPERFAT:	resw	1
 15481 0000000D ????                    .BPB_SECTORSPERTRACK:	resw	1
 15482 0000000F ????                    .BPB_HEADS:		resw	1
 15483 00000011 ????                    .BPB_HIDDENSECTORS:	resw	1
 15484 00000013 ????                    			resw	1
 15485 00000015 ????                    .BPB_BIGTOTALSECTORS:	resw	1
 15486 00000017 ????                    			resw	1
 15487 00000019 ????????????            			resb	6	; NOTE:  many times these
 15488                                  ;					; 	 6 bytes are omitted
 15489                                  ;					;	 when BPB manipulations
 15490                                  ;					;	 are performed!
 15491                                  .size:
 15492                                  endstruc
 15493                                  
 15494                                  struc A_DEVICEPARAMETERS
 15495 00000000 ??                      .DP_SPECIALFUNCTIONS:	resb	1
 15496 00000001 ??                      .DP_DEVICETYPE:		resb	1
 15497 00000002 ????                    .DP_DEVICEATTRIBUTES:	resw	1
 15498 00000004 ????                    .DP_CYLINDERS:		resw	1
 15499 00000006 ??                      .DP_MEDIATYPE:		resb	1
 15500 00000007 <res 1Fh>               .DP_BPB:		resb	A_BPB.size
 15501 00000026 ????                    .DP_TRACKTABLEENTRIES:	resw	1
 15502 00000028 <res FCh>               .DP_SECTORTABLE:	resb	MAX_SECTORS_IN_TRACK * A_SECTORTABLE.size
 15503                                  endstruc
 15504                                  
 15505                                  ; ----------------------------------------------------------------------
 15506                                  ; structure, equates for devmark for mem command.
 15507                                  
 15508                                  ; 25/03/2019 - Retro DOS v4.0 (MSDOS 6.0, DEVMARK.INC, 1991)
 15509                                  
 15510                                  struc devmark
 15511 00000000 ??                       .id:	    resb 1
 15512 00000001 ????                     .seg:	    resw 1
 15513 00000003 ????                     .size:	    resw 1
 15514 00000005 ??????                   .dum:	    resb 3
 15515 00000008 ????????????????         .filename: resb 8
 15516                                  endstruc
 15517                                  
 15518                                  devmark_stk	equ	'S'
 15519                                  devmark_device	equ	'D'
 15520                                  devmark_ifs	equ	'I'
 15521                                  devmark_buf	equ	'B'
 15522                                  devmark_cds	equ	'L' ; lastdrive
 15523                                  devmark_files	equ	'F'
 15524                                  devmark_fcbs	equ	'X'
 15525                                  devmark_inst	equ	'T' ; used for sysinit base for install= command.
 15526                                  devmark_ems_stub equ	'E'
 15527                                  
 15528                                  setbrkdone	equ	00000001b
 15529                                  for_devmark	equ	00000010b
 15530                                  not_for_devmark equ	11111101b
 15531                                  
 15532                                  ; ----------------------------------------------------------------------
 15533                                  ; Memory arena structure
 15534                                  
 15535                                  ; 24/03/2019 - Retro DOS v4.0 
 15536                                  ; (MSDOS 6.0, ARENA.INC)
 15537                                  
 15538                                  ;** Arena Header
 15539                                  
 15540                                  struc ARENA
 15541 00000000 ??                      .SIGNATURE:	resb 1		; 4D for valid item, 5A for last item
 15542 00000001 ????                    .OWNER:		resw 1		; owner of arena item
 15543 00000003 ????                    .SIZE:		resw 1		; size in paragraphs of item
 15544 00000005 ??????                  .RESERVED	resb 3		; reserved
 15545 00000008 ????????????????        .NAME:		resb 8		; owner file name
 15546                                  endstruc
 15547                                  
 15548                                  ; 12/04/2019
 15549                                  
 15550                                  arena_owner_system	EQU 0	; free block indication
 15551                                  
 15552                                  arena_signature_normal	EQU 4Dh ; valid signature, not end of arena
 15553                                  arena_signature_end	EQU 5Ah ; valid signature, last block in arena
 15554                                  
 15555                                  ; ----------------------------------------------------------------------
 15556                                  ; Process data block (otherwise known as program header)
 15557                                  
 15558                                  ; 23/03/2019 - Retro DOS v4.0
 15559                                  
 15560                                  ; (MSDOS 6.0 - PDB.INC, 1991)
 15561                                  
 15562                                  FILPERPROC	EQU     20
 15563                                  
 15564                                  struc PDB	; Process_data_block
 15565 00000000 ????                    .EXIT_CALL:	resw 1   	; INT int_abort system terminate
 15566 00000002 ????                    .BLOCK_LEN:	resw 1		; size of execution block
 15567 00000004 ??                                      resb 1
 15568 00000005 ??????????              .CPM_CALL:	resb 5		; ancient call to system
 15569 0000000A ????????                .EXIT:		resd 1		; pointer to exit routine
 15570 0000000E ????????                .CTRL_C:	resd 1		; pointer to ^C routine
 15571 00000012 ????????                .FATAL_ABORT:	resd 1		; pointer to fatal error
 15572 00000016 ????                    .PARENT_PID:	resw 1		; PID of parent (terminate PID)
 15573 00000018 <res 14h>               .JFN_TABLE:     resb FILPERPROC ; indices into system table
 15574 0000002C ????                    .ENVIRON:	resw 1		; seg addr of environment
 15575 0000002E ????????                .USER_STACK:	resd 1		; stack of self during system calls
 15576 00000032 ????                    .JFN_LENGTH:	resw 1 		; number of handles allowed
 15577 00000034 ????????                .JFN_POINTER:	resd 1 		; pointer to JFN table
 15578 00000038 ????????                .NEXT_PDB:	resd 1		; pointer to nested PDB's
 15579 0000003C ??                      .INTERCON:	resb 1 		; *** jh-3/28/90 ***
 15580 0000003D ??                      .APPEND:	resb 1		; *** Not sure if still used ***
 15581 0000003E ????                    .NOVELL_USED:	resb 2		; Novell shell (redir) uses these
 15582 00000040 ????                    .VERSION:	resw 1		; DOS version reported to this app
 15583 00000042 <res Eh>                .PAD1:		resb 14		; 	
 15584 00000050 ??????????              .CALL_SYSTEM:	resb 5		; portable method of system call
 15585 00000055 ??????????????          .PAD2:		resb 7 		; reserved so FCB 1 can be used as an extended FCB
 15586 0000005C <res 10h>               .FCB1:		resb 16		; default FCB 1
 15587 0000006C <res 10h>               .FCB2:		resb 16		; default FCB 2
 15588 0000007C ????????                .PAD3:		resb 4		; not sure if this is used by PDB_FCB2
 15589 00000080 <res 80h>               .TAIL:		resb 128	; command tail and default DTA
 15590                                  ;.size:
 15591                                  endstruc
 15592                                  
 15593                                  ; ----------------------------------------------------------------------
 15594                                  ; <system call definitions>
 15595                                  
 15596                                  ; 23/03/2019 - Retro DOS v4.0
 15597                                  
 15598                                  ; (MSDOS 6.0 - SYSCALL.INC, 1991)
 15599                                  
 15600                                  ABORT                           EQU 0   ;  0      0
 15601                                  STD_CON_INPUT                   EQU 1   ;  1      1
 15602                                  STD_CON_OUTPUT                  EQU 2   ;  2      2
 15603                                  STD_AUX_INPUT                   EQU 3   ;  3      3
 15604                                  STD_AUX_OUTPUT                  EQU 4   ;  4      4
 15605                                  STD_PRINTER_OUTPUT              EQU 5   ;  5      5
 15606                                  RAW_CON_IO                      EQU 6   ;  6      6
 15607                                  RAW_CON_INPUT                   EQU 7   ;  7      7
 15608                                  STD_CON_INPUT_NO_ECHO           EQU 8   ;  8      8
 15609                                  STD_CON_STRING_OUTPUT           EQU 9   ;  9      9
 15610                                  STD_CON_STRING_INPUT            EQU 10  ; 10      A
 15611                                  STD_CON_INPUT_STATUS            EQU 11  ; 11      B
 15612                                  STD_CON_INPUT_FLUSH             EQU 12  ; 12      C
 15613                                  DISK_RESET                      EQU 13  ; 13      D
 15614                                  SET_DEFAULT_DRIVE               EQU 14  ; 14      E
 15615                                  FCB_OPEN                        EQU 15  ; 15      F
 15616                                  FCB_CLOSE                       EQU 16  ; 16     10
 15617                                  DIR_SEARCH_FIRST                EQU 17  ; 17     11
 15618                                  DIR_SEARCH_NEXT                 EQU 18  ; 18     12
 15619                                  FCB_DELETE                      EQU 19  ; 19     13
 15620                                  FCB_SEQ_READ                    EQU 20  ; 20     14
 15621                                  FCB_SEQ_WRITE                   EQU 21  ; 21     15
 15622                                  FCB_CREATE                      EQU 22  ; 22     16
 15623                                  FCB_RENAME                      EQU 23  ; 23     17
 15624                                  GET_DEFAULT_DRIVE               EQU 25  ; 25     19
 15625                                  SET_DMA                         EQU 26  ; 26     1A
 15626                                  GET_DEFAULT_DPB                 EQU 31  ; 31     1F
 15627                                  FCB_RANDOM_READ                 EQU 33  ; 33     21
 15628                                  FCB_RANDOM_WRITE                EQU 34  ; 34     22
 15629                                  GET_FCB_FILE_LENGTH             EQU 35  ; 35     23
 15630                                  GET_FCB_POSITION                EQU 36  ; 36     24
 15631                                  SET_INTERRUPT_VECTOR            EQU 37  ; 37     25
 15632                                  CREATE_PROCESS_DATA_BLOCK       EQU 38  ; 38     26
 15633                                  FCB_RANDOM_READ_BLOCK           EQU 39  ; 39     27
 15634                                  FCB_RANDOM_WRITE_BLOCK          EQU 40  ; 40     28
 15635                                  PARSE_FILE_DESCRIPTOR           EQU 41  ; 41     29
 15636                                  GET_DATE                        EQU 42  ; 42     2A
 15637                                  SET_DATE                        EQU 43  ; 43     2B
 15638                                  GET_TIME                        EQU 44  ; 44     2C
 15639                                  SET_TIME                        EQU 45  ; 45     2D
 15640                                  SET_VERIFY_ON_WRITE             EQU 46  ; 46     2E
 15641                                  ; Extended functionality group
 15642                                  GET_DMA                         EQU 47  ; 47     2F
 15643                                  GET_VERSION                     EQU 48  ; 48     30
 15644                                  KEEP_PROCESS                    EQU 49  ; 49     31
 15645                                  GET_DPB                         EQU 50  ; 50     32
 15646                                  SET_CTRL_C_TRAPPING             EQU 51  ; 51     33
 15647                                  GET_INDOS_FLAG                  EQU 52  ; 52     34
 15648                                  GET_INTERRUPT_VECTOR            EQU 53  ; 53     35
 15649                                  GET_DRIVE_FREESPACE             EQU 54  ; 54     36
 15650                                  CHAR_OPER                       EQU 55  ; 55     37
 15651                                  INTERNATIONAL                   EQU 56  ; 56     38
 15652                                  ;   Directory Group
 15653                                  MKDIR                           EQU 57  ; 57     39
 15654                                  RMDIR                           EQU 58  ; 58     3A
 15655                                  CHDIR                           EQU 59  ; 59     3B
 15656                                  ;   File Group
 15657                                  CREAT                           EQU 60  ; 60     3C
 15658                                  OPEN                            EQU 61  ; 61     3D
 15659                                  CLOSE                           EQU 62  ; 62     3E
 15660                                  READ                            EQU 63  ; 63     3F
 15661                                  WRITE                           EQU 64  ; 64     40
 15662                                  UNLINK                          EQU 65  ; 65     41
 15663                                  LSEEK                           EQU 66  ; 66     42
 15664                                  CHMOD                           EQU 67  ; 67     43
 15665                                  IOCTL                           EQU 68  ; 68     44
 15666                                  XDUP                            EQU 69  ; 69     45
 15667                                  XDUP2                           EQU 70  ; 70     46
 15668                                  CURRENT_DIR                     EQU 71  ; 71     47
 15669                                  ;    Memory Group
 15670                                  ALLOC                           EQU 72  ; 72     48
 15671                                  DEALLOC                         EQU 73  ; 73     49
 15672                                  SETBLOCK                        EQU 74  ; 74     4A
 15673                                  ;    Process Group
 15674                                  EXEC                            EQU 75  ; 75     4B
 15675                                  EXIT                            EQU 76  ; 76     4C
 15676                                  WAITPROCESS			EQU 77  ; 77     4D
 15677                                  FIND_FIRST                      EQU 78  ; 78     4E
 15678                                  ;   Special Group
 15679                                  FIND_NEXT                       EQU 79  ; 79     4F
 15680                                  ; SPECIAL SYSTEM GROUP
 15681                                  SET_CURRENT_PDB                 EQU 80  ; 80     50
 15682                                  GET_CURRENT_PDB                 EQU 81  ; 81     51
 15683                                  GET_IN_VARS                     EQU 82  ; 82     52
 15684                                  SETDPB                          EQU 83  ; 83     53
 15685                                  GET_VERIFY_ON_WRITE             EQU 84  ; 84     54
 15686                                  DUP_PDB                         EQU 85  ; 85     55
 15687                                  RENAME                          EQU 86  ; 86     56
 15688                                  FILE_TIMES                      EQU 87  ; 87     57
 15689                                  ;
 15690                                  ALLOCOPER			EQU 88	; 88     58	
 15691                                  ; Network extention system calls
 15692                                  GetExtendedError		EQU 89	; 89	 59
 15693                                  CreateTempFile			EQU 90	; 90	 5A
 15694                                  CreateNewFile			EQU 91	; 91	 5B
 15695                                  LockOper			EQU 92	; 92	 5C Lock and Unlock
 15696                                  ServerCall			EQU 93	; 93	 5D CommitAll, ServerDOSCall,
 15697                                  					;	    CloseByName, CloseUser,
 15698                                  					;	    CloseUserProcess,
 15699                                  					;	    GetOpenFileList
 15700                                  UserOper			EQU 94	; 94	 5E Get and Set
 15701                                  AssignOper			EQU 95	; 95	 5F On, Off, Get, Set, Cancel
 15702                                  xNameTrans			EQU 96	; 96	 60
 15703                                  PathParse			EQU 97	; 97	 61
 15704                                  GetCurrentPSP			EQU 98	; 98	 62
 15705                                  Hongeul 			EQU 99	; 99	 63
 15706                                  ECS_CALL			EQU 99	; 99	 63  ;; DBCS support
 15707                                  Set_Printer_Flag		EQU 100 ; 100	 64
 15708                                  GetExtCntry			EQU 101 ; 101	 65
 15709                                  GetSetCdPg			EQU 102 ; 102	 66
 15710                                  ExtHandle			EQU 103 ; 103	 67
 15711                                  Commit				EQU 104 ; 104	 68
 15712                                  GetSetMediaID			EQU 105 ; 105	 69
 15713                                  IFS_IOCTL			EQU 107 ; 107	 6B
 15714                                  ExtOpen 			EQU 108 ; 108	 6C
 15715                                  ;
 15716                                  ;ifdef ROMEXEC
 15717                                  ;ROM_FIND_FIRST			EQU 109 ; 109    6D
 15718                                  ;ROM_FIND_NEXT			EQU 110 ; 110    6E
 15719                                  ;ROM_EXCLUDE			EQU 111 ; 111	 6F
 15720                                  ;endif
 15721                                  ;
 15722                                  Set_Oem_Handler 		EQU 248 ; 248	 F8
 15723                                  OEM_C1				EQU 249 ; 249	 F9
 15724                                  OEM_C2				EQU 250 ; 250	 FA
 15725                                  OEM_C3				EQU 251 ; 251	 FB
 15726                                  OEM_C4				EQU 252 ; 252	 FC
 15727                                  OEM_C5				EQU 253 ; 253	 FD
 15728                                  OEM_C6				EQU 254 ; 254	 FE
 15729                                  OEM_C7				EQU 255 ; 255	 FF
 15730                                  
 15731                                  ; ----------------------------------------------------------------------
 15732                                  ; SYSCONF.ASM (MSDOS 3.3 - 24/07/1987) 	
 15733                                  ; ----------------------------------------------------------------------
 15734                                  
 15735                                  ;;	IF	STACKSW
 15736                                  
 15737                                  ;;
 15738                                  ;; Internal Stack Parameters
 15739                                  ;EntrySize		equ	8
 15740                                  ;
 15741                                  ;MinCount		equ	8
 15742                                  ;DefaultCount		equ	9
 15743                                  ;MaxCount		equ	64
 15744                                  ;
 15745                                  ;MinSize 		equ	32
 15746                                  ;DefaultSize		equ	128
 15747                                  ;MaxSize 		equ	512
 15748                                  
 15749                                  ;;	ENDIF
 15750                                  
 15751                                  ; ----------------------------------------------------------------------
 15752                                  ; BIOSTRUC.INC (MSDOS 3.3 - 24/07/1987) 	
 15753                                  ; ----------------------------------------------------------------------
 15754                                  					  ;;Rev 3.30 Modification
 15755                                  ; ROM BIOS CALL PACKET STRUCTURES					  
 15756                                  									  
 15757                                  ;*******************************					  
 15758                                  ;System Service call ( Int 15h )					  
 15759                                  ;*******************************					  
 15760                                  ;Function AH = 0C0h, Return system configuration			  
 15761                                  ;For PC and PCJR on return:						  
 15762                                  ;	(AH)	= 80h							  
 15763                                  ;	(CY)	= 1							  
 15764                                  ;For PCXT, PC PORTABLE and PCAT on return:				  
 15765                                  ;	(AH)	= 86h							  
 15766                                  ;	(CY)	= 1							  
 15767                                  ;For all others:							  
 15768                                  ;	(AH)	= 0							  
 15769                                  ;	(CY)	= 0							  
 15770                                  ;	(ES:BX) = pointer to system descriptor vector in ROS		  
 15771                                  ; System descriptor :							  
 15772                                  ;	DW	xxxx		length of descriptor in bytes,		  
 15773                                  ;				minimum length = 8			  
 15774                                  ;	DB	xx		model byte				  
 15775                                  ;				0FFh	= PC				  
 15776                                  ;				0FEh	= PC/XT, Portable		  
 15777                                  ;				0FDh	= PC/JR 			  
 15778                                  ;				0FCh	= PC/AT				  
 15779                                  ;				0F9h	= Convertable			  
 15780                                  ;				0F8h	= Model 80			  
 15781                                  ;				0E0 thru 0EFh = reserved		  
 15782                                  ;									  
 15783                                  ;	DB	xx		secondary model byte			  
 15784                                  ;				000h	= PC1				  
 15785                                  ;				000h	= PC/XT, Portable		  
 15786                                  ;				000h	= PC/JR 			  
 15787                                  ;				000h	= PC/AT 			  
 15788                                  ;				001h	= PC/AT Model 339		  
 15789                                  ;				003h	= PC/RT				  
 15790                                  ;				000h	= Convertable			  
 15791                                  ;									  
 15792                                  ;	DB	xx		bios revision level			  
 15793                                  ;				00 for first release, subsequent release  
 15794                                  ;				of code with same model byte and	  
 15795                                  ;				secondary model byte require revison level
 15796                                  ;				to increase by one.			  
 15797                                  ;									  
 15798                                  ;	DB	xx		feature information byte 1		  
 15799                                  ;				X0000000 = 1, bios use DMA channel 3	  
 15800                                  ;					 = 0, DMA channel 3 not used	  
 15801                                  ;									  
 15802                                  ;				0X000000 = 1, 2nd Interrupt chip present  
 15803                                  ;					 = 0, 2nd Interrupt chip not present
 15804                                  ;									  
 15805                                  ;				00X00000 = 1, Real Time Clock present	  
 15806                                  ;					 = 0, Real Time Clock not present 
 15807                                  ;									  
 15808                                  ;				000X0000 = 1, Keyboard escape sequence(INT 15h)
 15809                                  ;						called in keyboard interrupt
 15810                                  ;						(Int 09h).		  
 15811                                  ;					 = 0, Keyboard escape sequence not
 15812                                  ;						called. 		  
 15813                                  ;				0000XXXX reserved			  
 15814                                  ;									  
 15815                                  ;	DB	xx		feature information byte 2 - reserved	  
 15816                                  ;									  
 15817                                  ;	DB	xx		feature information byte 2 - reserved	  
 15818                                  ;									  
 15819                                  ;	DB	xx		feature information byte 2 - reserved	  
 15820                                  ;									  
 15821                                  ;	DB	xx		feature information byte 2 - reserved	  
 15822                                  ;									  
 15823                                  
 15824                                  ; 22/03/2019									  
 15825                                  struc ROMBIOS_DESC		; BIOS_SYSTEM_DESCRIPTOR						  
 15826 00000000 ????                    .bios_sd_leng:		resw 1				  
 15827 00000002 ??                      .bios_sd_modelbyte:	resb 1					  
 15828                                  .bios_sd_scnd_modelbyte: 
 15829 00000003 ??                      			resb 1					  
 15830 00000004 ??                      			resb 1					  
 15831 00000005 ??                      .bios_sd_featurebyte1:	resb 1					  
 15832 00000006 ????????                			resb 4					  
 15833                                  endstruc					  
 15834                                  									  
 15835                                  ;FeatureByte1	bit map equates 					  
 15836                                  DMAchannel3		equ 10000000b					  
 15837                                  ScndIntController	equ 01000000b					  
 15838                                  RealTimeClock		equ 00100000b					  
 15839                                  KeyEscapeSeq		equ 00010000b					  
 15840                                  					;;End of Modification
 15841                                  
 15842                                  ; ----------------------------------------------------------------------
 15843                                  ; SYSVAR.INC (MSDOS 6.0 - 1991) 	
 15844                                  ; ----------------------------------------------------------------------
 15845                                  ; 22/03/2019 - Retro DOS v4.0
 15846                                  
 15847                                  ;	SCCSID = @(#)sysvar.asm 1.1 85/04/10
 15848                                  
 15849                                  struc SysInitVars
 15850                                  ; MSDOS 3.3
 15851 00000000 ????????                .SYSI_DPB:    resd 1			; DPB chain
 15852 00000004 ????????                .SYSI_SFT:    resd 1			; SFT chain
 15853 00000008 ????????                .SYSI_CLOCK:  resd 1			; CLOCK device
 15854 0000000C ????????                .SYSI_CON:    resd 1			; CON device
 15855 00000010 ????                    .SYSI_MAXSEC: resw 1			; maximum sector size
 15856 00000012 ????????                .SYSI_BUF:    resd 1			; buffer chain
 15857 00000016 ????????                .SYSI_CDS:    resd 1			; CDS list
 15858 0000001A ????????                .SYSI_FCB:    resd 1			; FCB chain
 15859 0000001E ????                    .SYSI_KEEP:   resw 1			; keep count
 15860 00000020 ??                      .SYSI_NUMIO:  resb 1			; number of block devices
 15861 00000021 ??                      .SYSI_NCDS:   resb 1			; number of CDS's
 15862 00000022 ????????                .SYSI_DEV:    resd 1			; device list
 15863                                  ; MSDOS 6.0
 15864 00000026 ????                    .SYSI_ATTR:	    resw 1		; null device attribute word
 15865 00000028 ????                    .SYSI_STRAT:	    resw 1		; null device strategy entry point
 15866 0000002A ????                    .SYSI_INTER:	    resw 1		; null device interrupt entry point
 15867 0000002C ????????????????        .SYSI_NAME:	    resb 8		; null device name
 15868                                  .SYSI_SPLICE:	    resb 0		; TRUE -> splicees being done
 15869 00000034 ????                    .SYSI_IBMDOS_SIZE:  resw 1		; DOS size in paragraphs
 15870 00000036 ????????                .SYSI_IFS_DOSCALL@: resd 1		; IFS DOS service rountine entry
 15871 0000003A ????????                .SYSI_IFS:	    resd 1	 	; IFS header chain
 15872 0000003E ????????                .SYSI_BUFFERS:	    resw 2		; BUFFERS= values (m,n)
 15873 00000042 ??                      .SYSI_BOOT_DRIVE:   resb 1		; boot drive A=1 B=2,..
 15874 00000043 ??                      .SYSI_DWMOVE:	    resb 1		; 1 if 386 machine
 15875 00000044 ????                    .SYSI_EXT_MEM:	    resw 1		; Extended memory size in KB.
 15876                                  .size:
 15877                                  endstruc
 15878                                  
 15879                                  ;This is added for more information exchage between DOS, BIOS.
 15880                                  ;DOS will give the pointer to SysInitTable in ES:DI. - J.K. 5/29/86
 15881                                  
 15882                                  ; 22/03/2019
 15883                                  struc SysInitVars_Ext
 15884 00000000 ????????                .SYSI_InitVars:	   resd 1	; Points to the above structure.
 15885 00000004 ????????                .SYSI_Country_Tab: resd 1	; DOS_Country_cdpg_info
 15886                                  endstruc
 15887                                  
 15888                                  ; 09/06/2018
 15889                                  ; 08/06/2018 - Retro DOS v3.0 (MSDOS 3.3)
 15890                                  SYSI_DPB    equ	0
 15891                                  SYSI_SFT    equ 4
 15892                                  SYSI_CLOCK  equ 8
 15893                                  SYSI_CON    equ 12
 15894                                  SYSI_MAXSEC equ 16
 15895                                  SYSI_BUF    equ 18 		
 15896                                  SYSI_CDS    equ 22
 15897                                  SYSI_FCB    equ 26
 15898                                  SYSI_KEEP   equ 30
 15899                                  SYSI_NUMIO  equ	32
 15900                                  SYSI_NCDS   equ	33
 15901                                  SYSI_DEV    equ 34
 15902                                  ; 22/03/2019 - Retro DOS v4.0 (MSDOS 6.0)
 15903                                  SYSI_ATTR	  equ 38
 15904                                  SYSI_STRAT	  equ 40
 15905                                  SYSI_INTER	  equ 42
 15906                                  SYSI_NAME	  equ 44
 15907                                  SYSI_SPLICE	  equ 52
 15908                                  SYSI_IBMDOS_SIZE  equ 53
 15909                                  SYSI_IFS_DOSCALL@ equ 55
 15910                                  SYSI_IFS	  equ 59
 15911                                  SYSI_BUFFERS	  equ 63
 15912                                  SYSI_BOOT_DRIVE   equ 67
 15913                                  SYSI_DWMOVE	  equ 68
 15914                                  SYSI_EXT_MEM	  equ 69
 15915                                  
 15916                                  ;The SYSI_BUF of SysInitVars points to the following structure
 15917                                  
 15918                                  EMS_MAP_BUFF_SIZE EQU 12	; EMS map buffer size
 15919                                  
 15920                                  struc BUFFINF 	; BUFFINFO
 15921 00000000 ????????                .Buff_Queue:	   resd	1	; Head of list of buffers
 15922 00000004 ????                    .Dirty_Buff_Count: resw 1	; number of dirty buffers in list
 15923 00000006 ????????                .Cache_ptr:	   resd 1	; pointer to secondary cache
 15924 0000000A ????                    .Cache_count:      resw 1	; number of secondary cache entries
 15925                                  
 15926 0000000C ??                      .Buff_In_HMA:	   resb 1	; flag to indicate that buffers
 15927                                  				; are in HMA
 15928 0000000D ????????                .Lo_Mem_Buff:	   resd 1	; Ptr to scratch buff in Low Mem
 15929                                  				;  used to read/write on disks
 15930 00000011 ????????                .UU_EMS_FIRST_PAGE:	resw 2
 15931 00000015 ????                    .UU_EMS_NPA640:		resw 1
 15932 00000017 ??                      .UU_EMS_mode:		resb 1	 ; no EMS = -1
 15933 00000018 ????                    .UU_EMS_handle:		resw 1	 ; EMS handle for buffers
 15934 0000001A ????                    .UU_EMS_PageFrame_Number: resw 1 ; EMS page frame number
 15935 0000001C ????                    .UU_EMS_Seg_Cnt:	resw 1	 ; EMS segment count
 15936 0000001E ????                    .UU_EMS_Page_Frame:	resw 1	 ; EMS page frame segment address
 15937 00000020 ????                    .UU_EMS_reserved:	resw 1	 ; EMS segment count
 15938 00000022 ??                      .UU_EMS_Map_Buff:	resb 1	 ; map buffer
 15939                                  .size:
 15940                                  endstruc
 15941                                  
 15942                                  ; ----------------------------------------------------------------------
 15943                                  ; CURDIR.INC (MSDOS 6.0 - 1991) 	
 15944                                  ; ----------------------------------------------------------------------
 15945                                  ; 22/03/2019 - Retro DOS v4.0
 15946                                  
 15947                                  ;**	CDS - Current Directory Structure
 15948                                  ;
 15949                                  ; CDS items are used bu the internal routines to store cluster numbers and
 15950                                  ; network identifiers for each logical name.  The ID field is used dually,
 15951                                  ; both as net ID and for a cluster number for local devices. In the case
 15952                                  ; of local devices, the cluster number will be -1 if there is a potential
 15953                                  ; of the disk being changed or if the path must be recracked.
 15954                                  ;
 15955                                  ;	Some pathnames have special preambles, such as
 15956                                  ;
 15957                                  ;		\\machine\sharename\...
 15958                                  ;	For these pathnames we can't allow ".." processing to back us
 15959                                  ;	up into the special front part of the name.  The CURDIR_END field
 15960                                  ;	holds the address of the seperator character which marks
 15961                                  ;	the split between the special preamble and the regular
 15962                                  ;	path list; ".." processing isn't allowed to back us up past
 15963                                  ;	(i.e., before) CURDIR_END
 15964                                  ;	For the root, it points at the leading /. For net
 15965                                  ;	assignments it points at the end (nul) of the initial assignment:
 15966                                  ;	A:/	\\foo\bar	    \\foo\bar\blech\bozo
 15967                                  ;	  ^		 ^		     ^
 15968                                  
 15969                                  DIRSTRLEN	EQU	64+3		; Max length in bytes of directory strings
 15970                                  TEMPLEN 	EQU	DIRSTRLEN*2
 15971                                  
 15972                                  struc 		curdir_list
 15973                                  ; MSDOS 3.3
 15974 00000000 <res 43h>               .cdir_text	resb	DIRSTRLEN	; text of assignment and curdir
 15975 00000043 ????                    .cdir_flags	resw	1		; various flags
 15976 00000045 ????????                .cdir_devptr	resd	1		; local pointer to DPB or net device
 15977 00000049 ????????                .cdir_ID	resw	2		; cluster of current dir (net ID)
 15978 0000004D ????                    .cdir_usr_word	resw	1
 15979 0000004F ????                    .cdir_end	resw	1		; end of assignment
 15980                                  ; MSDOS 6.0
 15981 00000051 ??                      .cdir_type:	resb	1		; IFS drive (2=ifs, 4=netuse)
 15982 00000052 ????????                .cdir_ifd_hdr:	resd	1		; Ptr to File System Header
 15983 00000056 ????                    .cdir_fsda:	resb	2		; File System Dependent Data Area
 15984                                  .size:
 15985                                  endstruc
 15986                                  
 15987                                  curdirlen	EQU	curdir_list.size	; Needed for screwed up
 15988                                  						; ASM87 which doesn't allow
 15989                                  						; Size directive as a macro
 15990                                  						; argument
 15991                                  %define curdir_netID	dword [curdir_list.cdir_ID]
 15992                                  
 15993                                  ;**	Flag values for CURDIR_FLAGS
 15994                                  
 15995                                  ;Flag word masks
 15996                                  curdir_isnet	EQU	1000000000000000B
 15997                                  curdir_isifs	EQU	1000000000000000B
 15998                                  curdir_inuse	EQU	0100000000000000B
 15999                                  curdir_splice	EQU	0010000000000000B
 16000                                  curdir_local	EQU	0001000000000000B
 16001                                  
 16002                                  ; ----------------------------------------------------------------------
 16003                                  ; SF.INC (MSDOS 6.0 - 1991) 	
 16004                                  ; ----------------------------------------------------------------------
 16005                                  ; 25/03/2019 - Retro DOS v4.0
 16006                                  
 16007                                  ; system file table
 16008                                  
 16009                                  ;**	System File Table SuperStructure
 16010                                  ;
 16011                                  ;	The system file table entries are allocated in contiguous groups.
 16012                                  ;	There may be more than one such groups; the SF "superstructure"
 16013                                  ;	tracks the groups.
 16014                                  
 16015                                  struc	SF
 16016 00000000 ????????                .SFLink:	resd	1
 16017 00000004 ????                    .SFCount:	resw	1		; number of entries
 16018 00000006 ????                    .SFTable:	resw	1		; beginning of array of the following
 16019                                  .size:
 16020                                  endstruc
 16021                                  
 16022                                  ;**	System file table entry
 16023                                  ;
 16024                                  ;	These are the structures which are at SFTABLE in the SF structure.
 16025                                  
 16026                                  struc	SF_ENTRY
 16027 00000000 ????                    .sf_ref_count:	resw	1		; number of processes sharing entry
 16028                                  					;   if FCB then ref count
 16029 00000002 ????                    .sf_mode: 	resw	1		; mode of access or high bit on if FCB
 16030 00000004 ??                      .sf_attr: 	resb	1		; attribute of file
 16031 00000005 ????                    .sf_flags:	resw	1		;Bits 8-15
 16032                                  					; Bit 15 = 1 if remote file
 16033                                  					;	 = 0 if local file or device
 16034                                  					; Bit 14 = 1 if date/time is not to be
 16035                                  					;   set from clock at CLOSE.  Set by
 16036                                  					;   FILETIMES and FCB_CLOSE.  Reset by
 16037                                  					;   other reseters of the dirty bit
 16038                                  					;   (WRITE)
 16039                                  					; Bit 13 = Pipe bit (reserved)
 16040                                  					;
 16041                                  					; Bits 0-7 (old FCB_devid bits)
 16042                                  					; If remote file or local file, bit
 16043                                  					; 6=0 if dirty Device ID number, bits
 16044                                  					; 0-5 if local file.
 16045                                  					; bit 7=0 for local file, bit 7
 16046                                  					;      =1 for local I/O device
 16047                                  					; If local I/O device, bit 6=0 if EOF (input)
 16048                                  					;		Bit 5=1 if Raw mode
 16049                                  					;		Bit 0=1 if console input device
 16050                                  					;		Bit 1=1 if console output device
 16051                                  					;		Bit 2=1 if null device
 16052                                  					;		Bit 3=1 if clock device
 16053 00000007 ????????                .sf_devptr:	resd	1		; Points to DPB if local file, points
 16054                                  					; to device header if local device,
 16055                                  					; points to net device header if
 16056                                  					; remote
 16057 0000000B ????                    .sf_firclus:	resw	1		; First cluster of file (bit 15 = 0)
 16058                                  ;.sf_lstclus:	resw	1 ; *	
 16059 0000000D ????                    .sf_time: 	resw	1		; Time associated with file
 16060 0000000F ????                    .sf_date: 	resw	1		; Date associated with file
 16061 00000011 ????????                .sf_size: 	resd	1		; Size associated with file
 16062 00000015 ????????                .sf_position:	resd	1		; Read/Write pointer or LRU count for FCBs
 16063                                  ;
 16064                                  ; Starting here, the next 7 bytes may be used by the file system to store an
 16065                                  ; ID
 16066                                  ;
 16067 00000019 ????                    .sf_cluspos:	resw	1		; Position of last cluster accessed
 16068 0000001B ????                    .sf_dirsec:	resw	1		; Sector number of directory sector for this file
 16069 0000001D ??                      .sf_dirpos:	resb	1		; Offset of this entry in the above
 16070                                  ;
 16071                                  ; End of 7 bytes of file-system specific info.
 16072                                  ;
 16073 0000001E <res Bh>                .sf_name:	resb	11		; 11 character name that is in the
 16074                                  					; directory entry.  This is used by
 16075                                  					; close to detect file deleted and
 16076                                  					; disk changed errors.
 16077                                  ; SHARING INFO
 16078 00000029 ????????                .sf_chain:	resd	1		; link to next SF
 16079 0000002D ????                    .sf_UID:	resw	1
 16080 0000002F ????                    .sf_PID:	resw	1
 16081 00000031 ????                    .sf_MFT:	resw	1
 16082 00000033 ????                    .sf_lstclus:	resw	1 ; *		; Last cluster accessed
 16083 00000035 ????????                .sf_IFS_HDR:	resd 	1 ; **
 16084                                  .size:
 16085                                  endstruc
 16086                                  
 16087                                  ; ----------------------------------------------------------------------
 16088                                  ; DOSCNTRY.INC (MSDOS 3.3 - 24/07/1987) 	
 16089                                  ; ----------------------------------------------------------------------
 16090                                  ; 11/06/2018 - Retro DOS v3.0
 16091                                  
 16092                                  ;Equates for COUNTRY INFORMATION.
 16093                                  SetCountryInfo		EQU	1	;country info
 16094                                  SetUcase		EQU	2	;uppercase table
 16095                                  SetLcase		EQU	3	;lowercase table (Reserved)
 16096                                  SetUcaseFile		EQU	4	;uppercase file spec table
 16097                                  SetFileList		EQU	5	;valid file character list
 16098                                  SetCollate		EQU	6	;collating sequence
 16099                                  SetDBCS 		EQU	7	;double byte character set
 16100                                  SetALL			EQU	-1	;all the entries
 16101                                  
 16102                                  ;DOS country and code page information table structure.
 16103                                  ;Internally, IBMDOS gives a pointer to this table.
 16104                                  ;IBMBIO, MODE and NLSFUNC modules communicate with IBMDOS through
 16105                                  ;this structure.
 16106                                  
 16107                                  struc country_cdpg_info ; DOS_country_cdpg_info
 16108 00000000 ????????????????        .ccInfo_reserved :	resb	8	;reserved for internal use
 16109 00000008 <res 40h>               .ccPath_CountrySys:	resb	64	;path and filename for country info
 16110 00000048 ????                    .ccSysCodePage:		resw	1	;system code page id
 16111 0000004A ????                    .ccNumber_of_entries:	resw	1 ; dw 5
 16112 0000004C ??                      .ccSetUcase:		resb	1 ; db SetUcase ; = 2
 16113 0000004D ????????                .ccUcase_ptr:		resd	1	;pointer to Ucase table
 16114                                  
 16115 00000051 ??                      .ccSetUcaseFile:	resb	1 ; db SetUcaseFile ; = 4
 16116 00000052 ????????                .ccFileUcase_ptr: 	resd	1	;pointer to File Ucase table
 16117                                  
 16118 00000056 ??                      .ccSetFileList:		resb	1 ; db SetFileList ; = 5
 16119 00000057 ????????                .ccFileChar_ptr:	resd	1	;pointer to File char list table
 16120                                  
 16121 0000005B ??                      .ccSetCollate:		resb	1 ; db SetCollate ; = 6
 16122 0000005C ????????                .ccCollate_ptr:		resd	1	;pointer to collate table
 16123                                  
 16124 00000060 ??                      .ccSetCountryInfo:	resb	1 ; db SetCountryInfo ; = 1
 16125 00000061 ????                    .ccCountryInfoLen:	resw	1	;length of country info
 16126 00000063 ????                    .ccDosCountry:		resw	1	;system country code id
 16127 00000065 ????                    .ccDosCodePage:		resw	1	;system code page id
 16128 00000067 ????                    .ccDFormat:		resw	1	;date format
 16129 00000069 ??????????              .ccCurSymbol:		resb	5 ; db "    ",0
 16130                                  					;5 byte of (currency symbol+0)
 16131 0000006E ????                    .cc1000Sep:		resb	2 ; db " ",0 ;2 byte of (1000 sep. + 0)
 16132 00000070 ????                    .ccDecSep:		resb	2 ; db " ",0 ;2 byte of (Decimal sep. + 0)
 16133 00000072 ????                    .ccDateSep:		resb	2 ; db " ",0 ;2 byte of (date sep. + 0)
 16134 00000074 ????                    .ccTimeSep:		resb 	2 ; db " ",0 ;2 byte of (time sep. + 0)
 16135 00000076 ??                      .ccCFormat:		resb	1 	;currency format flags
 16136 00000077 ??                      .ccCSigDigits:		resb	1	;# of digits in currency
 16137 00000078 ??                      .ccTFormat:		resb	1	;time format
 16138 00000079 ????????                .ccMono_Ptr:		resd	1	;monocase routine entry point
 16139 0000007D ????                    .ccListSep:		resb	2 ; db " ",0 ;data list separator
 16140 0000007F <res Ah>                .ccReserved_area: 	resw	5 ; dw 5 dup(?) ;reserved
 16141                                  .size:
 16142                                  endstruc
 16143                                  
 16144                                  NEW_COUNTRY_SIZE    equ  country_cdpg_info.size - country_cdpg_info.ccDosCountry
 16145                                  
 16146                                  ; ======================================================================
 16147                                  ; retrodos4.s (offset addresses in MSDOS.SYS or RETRODOS.SYS)
 16148                                  ; ======================================================================
 16149                                  ; 21/03/2019 - Retro DOS v4.0
 16150                                  ; 21/10/2022 - Retro DOS v4.0 (MOdified MSDOS 5.0 IO.SYS)
 16151                                  
 16152                                  ;KERNEL_SEGMENT	equ 0070h  ; (IO.SYS loading segment, BIOS_DATA segment)
 16153                                  ; 21/10/2022
 16154                                  DOSBIODATASEG equ 0070h	; (IO.SYS loading segment, BIOS_DATA segment)
 16155                                  ; 22/10/2022
 16156                                  ;DOSBIOCODESEG equ 02C7h ; (MSDOS 5.0 IO.SYS, BIOS_CODE segment)
 16157                                  ; 09/12/2022
 16158                                  DOSBIOCODESEG equ IOSYSCODESEG
 16159                                  
 16160                                  ; Note: These offset addresses must be chanqed when the code 
 16161                                  ; 	in retrodos4.s (MSDOS.SYS) file will be changed.
 16162                                  
 16163                                  ; (following addresses can be verified by searching them in retrodos4.lst) 
 16164                                  
 16165                                  ; 09/12/2022
 16166                                  %if 0
 16167                                  
 16168                                  ; 13/05/2019
 16169                                  
 16170                                  ;IsWin386         equ 08CFh
 16171                                  ;V86_Crit_SetFocus equ 08D0h
 16172                                  ; 21/10/2022
 16173                                  IsWin386          equ 08D0h
 16174                                  V86_Crit_SetFocus equ 08D1h 
 16175                                  
 16176                                  ;seg_reinit	  equ 0772h ; not used in Retro DOS v4.0
 16177                                  ; 21/10/2022 - Retro DOS v4.0 (MOdified MSDOS 5.0 IO.SYS)
 16178                                  seg_reinit	  equ 0032h ; DOSBIOCODESEG:0032h
 16179                                  
 16180                                  ;SysinitPresent	  equ 08FCh
 16181                                  ; 21/10/2022
 16182                                  SysinitPresent	  equ 08FDh
 16183                                  
 16184                                  inHMA		  equ 000Dh
 16185                                  xms		  equ 000Eh
 16186                                  ;FreeHMAPtr	  equ 08F6h
 16187                                  ;multrk_flag	  equ 0533h
 16188                                  ;ec35_flag	  equ 0535h
 16189                                  ;EOT		  equ 012Eh
 16190                                  ; 21/10/2022
 16191                                  FreeHMAPtr	  equ 08F7h
 16192                                  multrk_flag	  equ 052Fh
 16193                                  ec35_flag	  equ 0531h
 16194                                  EOT		  equ 012Ch
 16195                                  
 16196                                  ;NextStack	  equ 08BFh
 16197                                  ;IT_StackLoc	  equ 08C5h
 16198                                  ;IT_StackSize	  equ 08C9h
 16199                                  ; 21/10/2022
 16200                                  NextStack	  equ 08C0h
 16201                                  IT_StackLoc	  equ 08C6h
 16202                                  IT_StackSize	  equ 08CAh
 16203                                  
 16204                                  ;MoveDOSIntoHMA	  equ 08F8h
 16205                                  ; 21/10/2022
 16206                                  MoveDOSIntoHMA	  equ 08F9h
 16207                                  
 16208                                  ;INT19SEM equ 0644h ; 01/05/2019 - retrodos4.lst
 16209                                  ;I19_LST  equ 0645h ; 27/03/2019 - retrodos4.lst
 16210                                  ; 21/10/2022
 16211                                  INT19SEM equ 0640h ; (iosys5.txt)
 16212                                  I19_LST  equ 0641h ; (iosys5.txt)
 16213                                  
 16214                                  %endif
 16215                                  
 16216                                  ; 09/12/2022
 16217                                  seg_reinit equ _seg_reinit
 16218                                  ec35_flag  equ ec35flag		
 16219                                  INT19SEM   equ int19sem
 16220                                  I19_LST    equ i19_lst
 16221                                  
 16222                                  INT19OLD02 equ I19_LST+1 ; 0642h ; 21/10/2022
 16223                                  INT19OLD08 equ I19_LST+6
 16224                                  INT19OLD09 equ I19_LST+11
 16225                                  INT19OLD0A equ I19_LST+16
 16226                                  INT19OLD0B equ I19_LST+21
 16227                                  INT19OLD0C equ I19_LST+26
 16228                                  INT19OLD0D equ I19_LST+31
 16229                                  INT19OLD0E equ I19_LST+36
 16230                                  INT19OLD70 equ I19_LST+41
 16231                                  INT19OLD72 equ I19_LST+46
 16232                                  INT19OLD73 equ I19_LST+51
 16233                                  INT19OLD74 equ I19_LST+56
 16234                                  INT19OLD76 equ I19_LST+61
 16235                                  INT19OLD77 equ I19_LST+66 ; 0683h ; 21/10/2022
 16236                                  
 16237                                  ; 09/12/2022
 16238                                  %if 0
 16239                                  
 16240                                  ;keyrd_func	equ 04E9h
 16241                                  ;keysts_func	equ 04EAh
 16242                                  ;t_switch	equ 04F6h
 16243                                  ; 21/10/2022
 16244                                  keyrd_func	equ 04E5h
 16245                                  keysts_func	equ 04E6h
 16246                                  t_switch	equ 04F2h
 16247                                  
 16248                                  ; 22/10/2022
 16249                                  SYSINITSEG	equ 046Dh  ; SYSINIT segment
 16250                                  BCODE_END	equ (SYSINITSEG-DOSBIOCODESEG)*16 ; = 1A60h
 16251                                  BCODE_START	equ 30h  ; (offset BiosDataWord in DOSBIOCODESEG) 
 16252                                  RE_INIT		equ 089Bh ; (re_init offset in DOSBIODATASEG)
 16253                                  
 16254                                  %endif
 16255                                  
 16256                                  ; 09/12/2022
 16257                                  BCODESTART	equ BIOSDATAWORD
 16258                                  RE_INIT		equ re_init
 16259                                  
 16260                                  ; ----------------------------------------------------------------------
 16261                                  ; CONFIG.INC (MSDOS 6.0 - 1991) 	
 16262                                  ; ----------------------------------------------------------------------
 16263                                  ; 15/04/2019 - Retro DOS v4.0
 16264                                  
 16265                                  CONFIG_BEGIN        equ  '['
 16266                                  CONFIG_BREAK        equ  'C'
 16267                                  CONFIG_BUFFERS      equ  'B'
 16268                                  CONFIG_COMMENT      equ  'Y'
 16269                                  CONFIG_COUNTRY      equ  'Q'
 16270                                  CONFIG_DEVICE       equ  'D'
 16271                                  CONFIG_DEVICEHIGH   equ  'U'
 16272                                  CONFIG_DOS          equ  'H'
 16273                                  CONFIG_DRIVPARM     equ  'P'
 16274                                  CONFIG_FCBS         equ  'X'
 16275                                  CONFIG_FILES        equ  'F'
 16276                                  CONFIG_INCLUDE      equ  'J'
 16277                                  CONFIG_INSTALL      equ  'I'
 16278                                  CONFIG_INSTALLHIGH  equ  'W'
 16279                                  CONFIG_LASTDRIVE    equ  'L'
 16280                                  CONFIG_MENUCOLOR    equ  'R'
 16281                                  CONFIG_MENUDEFAULT  equ  'A'
 16282                                  CONFIG_MENUITEM     equ  'E'
 16283                                  CONFIG_MULTITRACK   equ  'M'
 16284                                  CONFIG_NUMLOCK      equ  'N'
 16285                                  CONFIG_REM          equ  '0'
 16286                                  CONFIG_SEMICOLON    equ  ';'
 16287                                  CONFIG_SET          equ  'V'
 16288                                  CONFIG_SHELL        equ  'S'
 16289                                  CONFIG_STACKS       equ  'K'
 16290                                  CONFIG_SUBMENU      equ  'O'
 16291                                  CONFIG_SWITCHES     equ  '1'
 16292                                  
 16293                                  CONFIG_UNKNOWN      equ  'Z'
 16294                                  
 16295                                  CONFIG_OPTION_QUERY equ 80h
 16296                                  
 16297                                  ; ----------------------------------------------------------------------
 16298                                  ; SYSINIT1.ASM (MSDOS 6.0 - 1991) 	
 16299                                  ; ----------------------------------------------------------------------
 16300                                  ; 21/03/2019 - Retro DOS v4.0
 16301                                  
 16302                                  true	equ	0FFFFh
 16303                                  false	equ	0
 16304                                  cr	equ	13
 16305                                  lf	equ	10
 16306                                  tab	equ	9
 16307                                  
 16308                                  multMULT	   equ	4Ah
 16309                                  multMULTGETHMAPTR  equ	1
 16310                                  multMULTALLOCHMA   equ	2
 16311                                  
 16312                                  ;NOEXEC    equ	FALSE
 16313                                  
 16314                                  stacksw    equ	true	;include switchable hardware stacks
 16315                                  mycds_size equ	88	;size of curdir_list. if it is not
 16316                                  			;the same, then will generate compile error.
 16317                                  
 16318                                  entrysize   equ     8
 16319                                  
 16320                                  mincount    equ     8
 16321                                  defaultcount equ    9
 16322                                  maxcount    equ     64
 16323                                  
 16324                                  minsize     equ     32
 16325                                  defaultsize equ     128
 16326                                  maxsize     equ     512
 16327                                  
 16328                                  ;%define allocbyte  byte [es:bp+0]
 16329                                  ;%define intlevel   byte [es:bp+1]
 16330                                  ;%define savedsp    word [es:bp+2]
 16331                                  ;%define savedss    word [es:bp+4]
 16332                                  ;%define newsp	    word [es:bp+6]
 16333                                  
 16334                                  allocbyte   equ     0
 16335                                  intlevel    equ     1
 16336                                  savedsp     equ     2
 16337                                  savedss     equ     4
 16338                                  newsp       equ     6
 16339                                  
 16340                                  free	    equ     0
 16341                                  allocated   equ     1
 16342                                  overflowed  equ     2
 16343                                  clobbered   equ     3
 16344                                  
 16345                                  ;---------------------------------------
 16346                                  ; external variable defined in ibmbio module for multi-track
 16347                                  
 16348                                  multrk_on equ	10000000b ;user specified mutitrack=on,or system turns
 16349                                  			  ; it on after handling config.sys file as a
 16350                                  			  ; default value,if multrk_flag = multrk_off1.
 16351                                  multrk_off1 equ 00000000b ;initial value. no "multitrack=" command entered.
 16352                                  multrk_off2 equ 00000001b ;user specified multitrack=off.
 16353                                  
 16354                                  ; SYSINITSEG	SEGMENT PUBLIC 'SYSTEM_INIT'
 16355                                  
 16356                                  SYSINIT$:
 16357                                  	;IF	STACKSW 
 16358                                  	; include MSSTACK.INC	;Main stack program and data definitions
 16359                                  	; include STKMES.INC	;Fatal stack error message
 16360                                  	;   public Endstackcode
 16361                                  ;Endstackcode	label byte
 16362                                  	;ENDIF
 16363                                  
 16364                                  ; 05/07/2018
 16365                                  ; ----------------------------------------------------------------------
 16366                                  ; 04/06/2018 - Retro DOS v3.0
 16367                                  
 16368                                  ; ----------------------------------------------------------------------
 16369                                  ; 21/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS - SYSINIT)
 16370                                  ; ----------------------------------------------------------------------
 16371                                  
 16372                                  ;	MSStack.inc
 16373                                  ;
 16374                                  ;	Interrupt level 2, 3, 4, 5, 6, 7,(10, 11, 12, 14, 15 - AT level)
 16375                                  ;	should follow the standard Interrupt Sharing Scheme which has
 16376                                  ;	a standard header structure.
 16377                                  ;	Fyi, the following shows the relations between
 16378                                  ;	the interrupt vector and interrupt level.
 16379                                  ; VEC(Hex)    2  8  9  A  B  C	D  E  70  72  73  74  76  77
 16380                                  ; LVL(Deci)   9  0  1  2  3  4	5  6   8  10  11  12  14  15
 16381                                  ;	MSSTACK module modifies the following interrupt vectors
 16382                                  ;	to meet the standard Interrupt Sharing standard;
 16383                                  ;	  A, B, C, D, E, 72, 73, 74, 76, 77.
 16384                                  ;	Also, for interrupt level 7 and 15, the FirstFlag in a standard header
 16385                                  ;	should be initialized to indicat whether this interrupt handler is
 16386                                  ;	the first (= 80h) or not.  The FirstFlag entry of INT77h's
 16387                                  ;	program header is initialized in STKINIT.INC module.
 16388                                  ;	FirstFlag is only meaningful for interrupt level 7 and 15.
 16389                                  ;
 16390                                  
 16391                                  ;  User specifies the number of stack elements - default = 9
 16392                                  ;						 minimum = 8
 16393                                  ;						 maximum = 64
 16394                                  ;
 16395                                  ;  Intercepts Asynchronous Hardware Interrupts only
 16396                                  ;
 16397                                  ;  Picks a stack from pool of stacks and switches to it
 16398                                  ;
 16399                                  ;  Calls the previously saved interrupt vector after pushing flags
 16400                                  ;
 16401                                  ;  On return, returns the stack to the stack pool
 16402                                  ;
 16403                                  
 16404                                  ; This is a modification of STACKS:
 16405                                  ; 1. To fix a bug which was causing the program to take up too much space.
 16406                                  ; 2. To dispense stack space from hi-mem first rather than low-mem first.
 16407                                  ;    . Clobbers the stack that got too big instead of innocent stack
 16408                                  ;    . Allows system to work if the only stack that got too big was the most
 16409                                  ;      deeply nested one
 16410                                  ; 3. Disables NMI interrupts while setting the NMI vector.
 16411                                  ; 4. Does not intercept any interupts on a PCjr.
 16412                                  ; 5. Double checks that a nested interrupt didn't get the same stack.
 16413                                  ; 6. Intercepts Ints 70, 72-77 for PC-ATs and other future products
 16414                                  
 16415                                  		;EVEN
 16416                                  ;align 2
 16417                                  		; 21/10/2022
 16418                                  
 16419 00000000 0000                    		dw	0	; spare field but leave these in order
 16420 00000002 0000                    stackcount:	dw	0
 16421 00000004 0000                    stackat: 	dw	0
 16422 00000006 0000                    stacksize:	dw	0
 16423 00000008 0000                    stacks:		dw	0
 16424 0000000A 0000                    		dw	0
 16425                                  
 16426 0000000C [0800]                  firstentry:	dw	stacks
 16427 0000000E [4800]                  lastentry:	dw	stacks+(defaultcount*entrysize)-entrysize
 16428 00000010 [4800]                  nextentry:	dw	stacks+(defaultcount*entrysize)-entrysize
 16429                                  
 16430                                  ;***********************************************************************
 16431                                  ; THESE ARE THE INDIVIDUAL INTERRUPT HANDLERS
 16432                                  
 16433                                  ; ----------------------------------------------------------------------
 16434                                  
 16435 00000012 00000000                old02:	dd	0
 16436                                  
 16437                                  int02:
 16438                                  
 16439                                  ; *********************************************************************
 16440                                  ;
 16441                                  ; this is special support for the pc convertible / nmi handler
 16442                                  ;
 16443                                  ;	on the pc convertible, there is a situation where an nmi can be 
 16444                                  ;	caused by using the "out" instructions to certain ports. when this
 16445                                  ;	occurs, the pc convertible hardware *guarantees* that **nothing** 
 16446                                  ;	can stop the nmi or interfere with getting to the nmi handler. this
 16447                                  ;	includes other type of interrupts (hardware and software), and
 16448                                  ;	also includes other type of nmi's. when any nmi has occured,
 16449                                  ;	no other interrtupt (hardware, software or nmi) can occur until
 16450                                  ;	the software takes specific steps to allow further interrupting.
 16451                                  ;
 16452                                  ;	for pc convertible, the situation where the nmi is generated by the
 16453                                  ;	"out" to a control port requires "fixing-up" and re-attempting. in
 16454                                  ;	otherwords, it is actually a "restartable exception". in this
 16455                                  ;	case, the software handler must be able to get to the stack in
 16456                                  ;	order to figure out what instruction caused the problem, where
 16457                                  ;	it was "out"ing to and what value it was "out"ing.  therefore,
 16458                                  ;	we will not switch stacks in this situation. this situation is
 16459                                  ;	detected by interrogating port 62h, and checking for a bit value
 16460                                  ;	of 80h. if set, *****do not switch stacks*****.
 16461                                  ;
 16462                                  ; *********************************************************************
 16463                                  
 16464 00000016 50                      	push	ax
 16465 00000017 06                      	push	es
 16466 00000018 B800F0                  	mov	ax,0F000h
 16467 0000001B 8EC0                    	mov	es,ax
 16468                                  	; 02/11/2022
 16469 0000001D 26803EFEFFF9            	cmp	byte [es:0FFFEh],0F9h ; mdl_convert ; check if convertible
 16470 00000023 07                      	pop	es
 16471 00000024 750C                    	jne	short normal02
 16472                                  
 16473 00000026 E462                    	in	al,62h		; PC/XT PPI port C. Bits:
 16474                                  				; 0-3: values of DIP switches
 16475                                  				; 5: 1=Timer 2 channel out
 16476                                  				; 6: 1=I/O channel check
 16477                                  				; 7: 1=RAM parity check error occurred.
 16478 00000028 A880                    	test	al,80h
 16479 0000002A 7406                    	jz	short normal02
 16480                                  special02:
 16481 0000002C 58                      	pop	ax
 16482 0000002D 2EFF2E[1200]            	jmp	far [cs:old02]
 16483                                  normal02:
 16484 00000032 58                      	pop	ax
 16485 00000033 E81101                  	call	do_int_stacks
 16486 00000036 [1200]                  	dw	old02
 16487                                  
 16488                                  ; ----------------------------------------------------------------------
 16489                                  
 16490 00000038 00000000                old08:	dd	0
 16491                                  
 16492                                  int08:
 16493 0000003C E80801                  	call	do_int_stacks
 16494 0000003F [3800]                  	dw	old08
 16495                                  
 16496                                  ; ----------------------------------------------------------------------
 16497                                  
 16498 00000041 00000000                old09:	dd	0
 16499                                  
 16500                                  int09:
 16501                                  
 16502                                  ; keyboard interrupt must have a three byte jump, a nop and a zero byte
 16503                                  ; as its first instruction for compatibility reasons
 16504                                  
 16505 00000045 EB02                    	jmp	short keyboard_lbl
 16506 00000047 90                      	nop
 16507 00000048 00                      	db	0
 16508                                  
 16509                                  keyboard_lbl:
 16510 00000049 E8FB00                  	call	do_int_stacks
 16511 0000004C [4100]                  	dw	old09
 16512                                  
 16513                                  ; ----------------------------------------------------------------------
 16514                                  
 16515 0000004E 00000000                old70:	dd	0
 16516                                  
 16517                                  int70:
 16518 00000052 E8F200                  	call	do_int_stacks
 16519 00000055 [4E00]                  	dw	old70
 16520                                  
 16521                                  ; ----------------------------------------------------------------------
 16522                                  
 16523                                  ;	irp	a,<0a,0b,0c,0d,0e,72,73,74,76,77>
 16524                                  ;public	int&a
 16525                                  ;public	old&a
 16526                                  ;public	firstflag&a
 16527                                  ;int&a	proc	far
 16528                                  ;	jmp	short entry_int&a&_stk
 16529                                  ;old&a	dd	  0		;forward pointer
 16530                                  ;	dw	  424bh 	;compatible signature for int. sharing
 16531                                  ;firstflag&a db   0		;the firstly hooked.
 16532                                  ;	jmp	short intret_&a	;reset routine. we don't care this.
 16533                                  ;	db	7 dup (0)	;reserved for future.
 16534                                  ;entry_int&a&_stk:
 16535                                  ;	call	do_int_stacks
 16536                                  ;	dw	old&a
 16537                                  ;intret_&a:
 16538                                  ;	iret
 16539                                  ;int&a	endp
 16540                                  ;	endm
 16541                                  
 16542                                  ; ----------------------------------------------------------------------
 16543                                  
 16544                                  int0A:
 16545 00000057 EB10                    	jmp	short entry_int0A_stk
 16546 00000059 00000000                old0A:	dd	0	
 16547 0000005D 4B42                    	dw	424Bh
 16548                                  firstflag0A:
 16549 0000005F 00                      	db	0
 16550 00000060 EB0C                    	jmp	short intret_0A
 16551 00000062 00<rep 7h>              	times	7 db 0
 16552                                  
 16553                                  entry_int0A_stk:
 16554 00000069 E8DB00                  	call	do_int_stacks
 16555 0000006C [5900]                  	dw	old0A
 16556                                  intret_0A:
 16557 0000006E CF                      	iret
 16558                                  
 16559                                  ; ----------------------------------------------------------------------
 16560                                  
 16561                                  int0B:
 16562 0000006F EB10                    	jmp	short entry_int0B_stk
 16563 00000071 00000000                old0B:	dd	0	
 16564 00000075 4B42                    	dw	424Bh
 16565                                  firstflag0B:
 16566 00000077 00                      	db	0
 16567 00000078 EB0C                    	jmp	short intret_0B
 16568 0000007A 00<rep 7h>              	times	7 db 0
 16569                                  
 16570                                  entry_int0B_stk:
 16571 00000081 E8C300                  	call	do_int_stacks
 16572 00000084 [7100]                  	dw	old0B
 16573                                  intret_0B:
 16574 00000086 CF                      	iret
 16575                                  
 16576                                  ; ----------------------------------------------------------------------
 16577                                  
 16578                                  int0C:
 16579 00000087 EB10                    	jmp	short entry_int0C_stk
 16580 00000089 00000000                old0C:	dd	0	
 16581 0000008D 4B42                    	dw	424Bh
 16582                                  firstflag0C:
 16583 0000008F 00                      	db	0
 16584 00000090 EB0C                    	jmp	short intret_0C
 16585 00000092 00<rep 7h>              	times	7 db 0
 16586                                  
 16587                                  entry_int0C_stk:
 16588 00000099 E8AB00                  	call	do_int_stacks
 16589 0000009C [8900]                  	dw	old0C
 16590                                  intret_0C:
 16591 0000009E CF                      	iret
 16592                                  
 16593                                  ; ----------------------------------------------------------------------
 16594                                  
 16595                                  int0D:
 16596 0000009F EB10                    	jmp	short entry_int0D_stk
 16597 000000A1 00000000                old0D:	dd	0	
 16598 000000A5 4B42                    	dw	424Bh
 16599                                  firstflag0D:
 16600 000000A7 00                      	db	0
 16601 000000A8 EB0C                    	jmp	short intret_0D
 16602 000000AA 00<rep 7h>              	times	7 db 0
 16603                                  
 16604                                  entry_int0D_stk:
 16605 000000B1 E89300                  	call	do_int_stacks
 16606 000000B4 [A100]                  	dw	old0D
 16607                                  intret_0D:
 16608 000000B6 CF                      	iret
 16609                                  
 16610                                  ; ----------------------------------------------------------------------
 16611                                  
 16612                                  int0E:
 16613 000000B7 EB10                    	jmp	short entry_int0E_stk
 16614 000000B9 00000000                old0E:	dd	0	
 16615 000000BD 4B42                    	dw	424Bh
 16616                                  firstflag0E:
 16617 000000BF 00                      	db	0
 16618 000000C0 EB0C                    	jmp	short intret_0E
 16619 000000C2 00<rep 7h>              	times	7 db 0
 16620                                  
 16621                                  entry_int0E_stk:
 16622 000000C9 E87B00                  	call	do_int_stacks
 16623 000000CC [B900]                  	dw	old0E
 16624                                  intret_0E:
 16625 000000CE CF                      	iret
 16626                                  
 16627                                  ; ----------------------------------------------------------------------
 16628                                  
 16629                                  int72:
 16630 000000CF EB10                    	jmp	short entry_int72_stk
 16631 000000D1 00000000                old72:	dd	0	
 16632 000000D5 4B42                    	dw	424Bh
 16633                                  firstflag72:
 16634 000000D7 00                      	db	0
 16635 000000D8 EB0C                    	jmp	short intret_72
 16636 000000DA 00<rep 7h>              	times	7 db 0
 16637                                  
 16638                                  entry_int72_stk:
 16639 000000E1 E86300                  	call	do_int_stacks
 16640 000000E4 [D100]                  	dw	old72
 16641                                  intret_72:
 16642 000000E6 CF                      	iret
 16643                                  
 16644                                  ; ----------------------------------------------------------------------
 16645                                  
 16646                                  int73:
 16647 000000E7 EB10                    	jmp	short entry_int73_stk
 16648 000000E9 00000000                old73:	dd	0	
 16649 000000ED 4B42                    	dw	424Bh
 16650                                  firstflag73:
 16651 000000EF 00                      	db	0
 16652 000000F0 EB0C                    	jmp	short intret_73
 16653 000000F2 00<rep 7h>              	times	7 db 0
 16654                                  
 16655                                  entry_int73_stk:
 16656 000000F9 E84B00                  	call	do_int_stacks
 16657 000000FC [E900]                  	dw	old73
 16658                                  intret_73:
 16659 000000FE CF                      	iret
 16660                                  
 16661                                  ; ----------------------------------------------------------------------
 16662                                  
 16663                                  int74:
 16664 000000FF EB10                    	jmp	short entry_int74_stk
 16665 00000101 00000000                old74:	dd	0	
 16666 00000105 4B42                    	dw	424Bh
 16667                                  firstflag74:
 16668 00000107 00                      	db	0
 16669 00000108 EB0C                    	jmp	short intret_74
 16670 0000010A 00<rep 7h>              	times	7 db 0
 16671                                  
 16672                                  entry_int74_stk:
 16673 00000111 E83300                  	call	do_int_stacks
 16674 00000114 [0101]                  	dw	old74
 16675                                  intret_74:
 16676 00000116 CF                      	iret
 16677                                  
 16678                                  ; ----------------------------------------------------------------------
 16679                                  
 16680                                  int76:
 16681 00000117 EB10                    	jmp	short entry_int76_stk
 16682 00000119 00000000                old76:	dd	0	
 16683 0000011D 4B42                    	dw	424Bh
 16684                                  firstflag76:
 16685 0000011F 00                      	db	0
 16686 00000120 EB0C                    	jmp	short intret_76
 16687 00000122 00<rep 7h>              	times	7 db 0
 16688                                  
 16689                                  entry_int76_stk:
 16690 00000129 E81B00                  	call	do_int_stacks
 16691 0000012C [1901]                  	dw	old76
 16692                                  intret_76:
 16693 0000012E CF                      	iret
 16694                                  
 16695                                  ; ----------------------------------------------------------------------
 16696                                  
 16697                                  int77:
 16698 0000012F EB10                    	jmp	short entry_int77_stk
 16699 00000131 00000000                old77:	dd	0	
 16700 00000135 4B42                    	dw	424Bh
 16701                                  firstflag77:
 16702 00000137 00                      	db	0
 16703 00000138 EB0C                    	jmp	short intret_77
 16704 0000013A 00<rep 7h>              	times	7 db 0
 16705                                  
 16706                                  entry_int77_stk:
 16707 00000141 E80300                  	call	do_int_stacks
 16708 00000144 [3101]                  	dw	old77
 16709                                  intret_77:
 16710 00000146 CF                      	iret
 16711                                  
 16712                                  ; ----------------------------------------------------------------------
 16713                                  
 16714                                  ;********************************************************************
 16715                                  ;common routines
 16716                                  ;********************************************************************
 16717                                  
 16718                                  ; do interrupt stack switching. the fake return address holds
 16719                                  ; a pointer to the far-pointer of the actual interrupt
 16720                                  ; service routine
 16721                                  
 16722                                  ; 21/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 SYSINIT)
 16723                                  ; 21/03/2019 - Retro DOS v4.0
 16724                                  
 16725                                  ;allocbyte   equ 0
 16726                                  ;intlevel    equ 1
 16727                                  ;savedsp     equ 2
 16728                                  ;savedss     equ 4
 16729                                  ;newsp       equ 6
 16730                                  
 16731                                  do_int_stacks:
 16732 00000147 50                      	push	ax
 16733 00000148 55                      	push	bp
 16734 00000149 06                      	push	es
 16735 0000014A 2E8E06[0A00]            	mov	es,[cs:stacks+2]	; Get segment of stacks
 16736 0000014F 2E8B2E[1000]            	mov	bp,[cs:nextentry]	; get most likely candidate
 16737 00000154 B001                    	mov	al,allocated ; 1
 16738                                  	; 21/10/2022
 16739                                  	;xchg	[es:bp+allocbyte],al 
 16740                                  	; 11/12/2022
 16741 00000156 26864600                	xchg	[es:bp],al		; grab the entry
 16742 0000015A 3C00                    	cmp	al,free ; 0		; still avail?
 16743 0000015C 754F                    	jne	short notfree02
 16744                                  
 16745 0000015E 2E832E[1000]08          	sub	word [cs:nextentry],entrysize ; set for next interrupt
 16746                                  
 16747                                  found02:
 16748 00000164 26896602                	mov	[es:bp+savedsp],sp	; save sp value
 16749 00000168 268C5604                	mov	[es:bp+savedss],ss	; save ss also
 16750                                  
 16751 0000016C 89E8                    	mov	ax,bp			; temp save of table offset
 16752                                  
 16753 0000016E 268B6E06                	mov	bp,[es:bp+newsp]	; get new SP value
 16754                                  	; 21/10/2022
 16755                                  	;mov	bp,[es:bp+6]
 16756                                  	; 11/12/2022
 16757                                  	;cmp	[es:bp+0],ax	
 16758 00000172 26394600                	cmp	[es:bp],ax		; check for offset into table
 16759 00000176 7542                    	jne	short foundbad02
 16760                                  
 16761                                  	;mov	ax,es			; point ss,sp to the new stack
 16762                                  	;mov	es,bp
 16763                                  	;mov	bp,sp
 16764                                  	;mov	bp,[bp+6]
 16765                                  	;mov	ss,ax
 16766                                  	;mov	sp,es
 16767                                  	;mov	es,ax
 16768                                  	;mov	bp,[cs:bp]
 16769                                  
 16770                                  	; 21/10/2022 (MSDOS 5.0 code SYSINIT code)
 16771 00000178 55                      	push    bp
 16772 00000179 89E5                    	mov     bp,sp
 16773 0000017B 8B4608                  	mov     ax,[bp+8]
 16774 0000017E 5D                      	pop     bp
 16775 0000017F 06                      	push    es
 16776 00000180 17                      	pop     ss
 16777 00000181 89EC                    	mov     sp,bp
 16778 00000183 89C5                    	mov     bp,ax
 16779                                  	; 11/12/2022
 16780                                  	;mov	bp,[cs:bp+0]	
 16781 00000185 2E8B6E00                	mov	bp,[cs:bp]	
 16782                                  
 16783 00000189 9C                      	pushf				; go execute the real interrupt handler
 16784                                  	; 11/12/2022
 16785 0000018A 2EFF5E00                	call	far [cs:bp]		;  which will iret back to here
 16786                                  	; 21/10/2022
 16787                                  	;call	far [cs:bp+0]
 16788                                  
 16789 0000018E 89E5                    	mov	bp,sp			; retrieve the table offset for us
 16790                                  	; 11/12/2022
 16791 00000190 268B6E00                	mov	bp,[es:bp]		;  but leave it on the stack
 16792                                  	; 21/10/2022
 16793                                  	;mov	bp,[es:bp+0]
 16794 00000194 268E5604                	mov	ss,[es:bp+savedss]	; get old stack back
 16795 00000198 268B6602                	mov	sp,[es:bp+savedsp]
 16796                                  
 16797                                  	; 11/12/2022
 16798                                  	;mov	byte [es:bp+allocbyte],free ; free the entry
 16799                                  	; 21/10/2022
 16800 0000019C 26C6460000              	mov	byte [es:bp],free ; 0
 16801 000001A1 2E892E[1000]            	mov	[cs:nextentry],bp	; setup to use next time
 16802                                  
 16803 000001A6 07                      	pop	es
 16804 000001A7 5D                      	pop	bp			; saved on entry
 16805 000001A8 58                      	pop	ax			; saved on entry
 16806 000001A9 83C402                  	add	sp,2
 16807 000001AC CF                      	iret				; done with this interrupt
 16808                                  
 16809                                  notfree02:
 16810 000001AD 3C01                    	cmp	al,allocated		; error flag
 16811 000001AF 7404                    	je	short findnext02	;  no, continue
 16812                                  	; 11/12/2022
 16813                                  	;xchg	[es:bp+allocbyte],al	;  yes, restore error value
 16814                                  	; 21/10/2022
 16815 000001B1 26864600                	xchg	[es:bp],al
 16816                                  
 16817                                  findnext02:
 16818 000001B5 E81200                  	call	longpath
 16819 000001B8 EBAA                    	jmp	short found02
 16820                                  
 16821                                  foundbad02:
 16822 000001BA 2E3B2E[0C00]            	cmp	bp,[cs:firstentry]
 16823 000001BF 72F4                    	jc	short findnext02
 16824 000001C1 89C5                    	mov	bp,ax			; flag this entry
 16825                                  	; 11/12/2022
 16826                                  	;mov	byte [es:bp+allocbyte],clobbered
 16827                                  	; 21/10/2022
 16828 000001C3 26C6460003              	mov	byte [es:bp],clobbered ; 3
 16829 000001C8 EBEB                    	jmp	short findnext02	; keep looking
 16830                                  
 16831                                  ; ----------------------------------------------------------------------
 16832                                  
 16833                                  ; Common routines
 16834                                  
 16835                                  longpath:
 16836                                  	; 21/03/2019
 16837 000001CA 2E8B2E[0E00]            	mov	bp,[cs:lastentry]	; start with last entry in table
 16838                                  lploopp:
 16839                                  	; 11/12/2022
 16840                                  	;cmp	byte [es:bp+allocbyte],free ; is entry free?
 16841                                  	; 21/10/2022
 16842 000001CF 26807E0000              	cmp	byte [es:bp],free
 16843 000001D4 7512                    	jne	short inuse		;  no, try next one
 16844                                  
 16845 000001D6 B001                    	mov	al,allocated
 16846                                  	; 11/12/2022
 16847                                  	;xchg	[es:bp+allocbyte],al	; allocate entry
 16848                                  	; 21/10/2022
 16849 000001D8 26864600                	xchg	[es:bp],al
 16850 000001DC 3C00                    	cmp	al,free 		; is it still free?
 16851 000001DE 7414                    	je	short found		;  yes, go use it
 16852                                  
 16853 000001E0 3C01                    	cmp	al,allocated		; is it other than Allocated or Free?
 16854 000001E2 7404                    	je	short inuse		;  no, check the next one
 16855                                  
 16856                                  	; 11/12/2022
 16857                                  	;mov	[es:bp+allocbyte],al	;  yes, put back the error state
 16858                                  	; 21/10/2022
 16859 000001E4 26884600                	mov	[es:bp],al
 16860                                  inuse:
 16861 000001E8 2E3B2E[0C00]            	cmp	bp,[cs:firstentry]
 16862 000001ED 7406                    	je	short fatal
 16863 000001EF 83ED08                  	sub	bp,entrysize
 16864 000001F2 EBDB                    	jmp	short lploopp
 16865                                  found:
 16866 000001F4 C3                      	retn
 16867                                  fatal:
 16868 000001F5 1E                      	push	ds
 16869 000001F6 B800F0                  	mov	ax,0F000h		;look at the model byte
 16870 000001F9 8ED8                    	mov	ds,ax
 16871 000001FB 803EFEFFF9              	cmp	byte [0FFFEh],0F9h ; mdl_convert ; convertible?
 16872 00000200 1F                      	pop	ds
 16873 00000201 7504                    	jne	short skip_nmis
 16874                                  
 16875 00000203 B007                    	mov	al,07h			; disable pc convertible nmis
 16876 00000205 E672                    	out	72h,al
 16877                                  
 16878                                  skip_nmis:
 16879 00000207 FA                      	cli				; disable and mask
 16880 00000208 B0FF                    	mov	al,0FFh			;   all other ints
 16881 0000020A E621                    	out	021h,al
 16882 0000020C E6A1                    	out	0A1h,al
 16883                                  
 16884 0000020E 8CCE                    	mov	si,cs
 16885 00000210 8EDE                    	mov	ds,si
 16886 00000212 BE[3902]                	mov	si,fatal_msg
 16887                                  ;SR;
 16888                                  ;   We set all foci to this VM to issue the stack failure message
 16889                                  ;
 16890 00000215 50                      	push	ax
 16891 00000216 1E                      	push	ds
 16892                                  	;;mov	ax,Bios_Data ; 0070h
 16893                                  	;mov	ax,KERNEL_SEGMENT ; 0070h
 16894                                  	; 21/10/2022
 16895 00000217 B87000                  	mov	ax,DOSBIODATASEG
 16896 0000021A 8ED8                    	mov	ds,ax
 16897                                  
 16898                                  	;test	byte [08D0h],1 	; (MSDOS 6.21, IO.SYS - SYSINIT:021Eh)
 16899 0000021C F606[CE08]01            	test	byte [IsWin386],1 ; (retrodos4.sys, offset: ****h)
 16900 00000221 1F                      	pop	ds
 16901 00000222 58                      	pop	ax
 16902 00000223 7405                    	jz	short fatal_loop	; win386 not present, continue
 16903                                  
 16904                                  	;;call	far ptr 0070h:08D1h ; (MSDOS 621, IO.SYS - SYSINIT:0227h)
 16905                                  	;call	KERNEL_SEGMENT:V86_Crit_SetFocus ; set focus to this VM
 16906                                  	; 21/10/2022
 16907 00000225 9A[CF08]7000            	call	DOSBIODATASEG:V86_Crit_SetFocus ; 0070h:08D1h
 16908                                  ;
 16909                                  ;SR; We do not bother about the returned status of this call. 
 16910                                  ;
 16911                                  fatal_loop:
 16912 0000022A AC                      	lodsb
 16913 0000022B 3C24                    	cmp	al,'$'
 16914 0000022D 7408                    	je	short fatal_done
 16915                                  
 16916 0000022F B307                    	mov	bl,7
 16917 00000231 B40E                    	mov	ah,14
 16918 00000233 CD10                    	int	10h			; whoops, this enables ints
 16919 00000235 EBF3                    	jmp	short fatal_loop
 16920                                  
 16921                                  fatal_done:
 16922 00000237 EBFE                    	jmp	short fatal_done
 16923                                  
 16924                                  
 16925                                  ; 21/03/2019 - Retro DOS v4.0 (MSDOS 6.0, SYSINIT1.ASM, 1991)
 16926                                  ; ----------------------------------------------------------------------
 16927                                  ;	include msbio.cl5		; fatal stack error message
 16928                                  
 16929                                  ; MSDOS 6.21, IO.SYS, SYSINIT:023Bh
 16930                                  
 16931                                  ; STKMES.INC - MSDOS 3.3 (24/07/1987)
 16932                                  ; ----------------------------------------------------------------------
 16933                                  ; 04/06/2018 - Retro DOS v3.0
 16934                                  
 16935                                  fatal_msg:
 16936 00000239 0D0A                    	db	0Dh,0Ah
 16937 0000023B 070D0A                  	db	7,0Dh,0Ah
 16938 0000023E 496E7465726E616C20-     	db	"Internal stack overflow",0Dh,0Ah
 16938 00000247 737461636B206F7665-
 16938 00000250 72666C6F770D0A     
 16939 00000257 53797374656D206861-     	db	"System halted",0Dh,0Ah,"$" 
 16939 00000260 6C7465640D0A24     
 16940                                  
 16941                                  endstackcode:
 16942                                  
 16943                                  ; ----------------------------------------------------------------------
 16944                                  ; SYINIT1.ASM (MSDOS 6.0, 1991) 'SYSINIT' jump addr from 'MSINIT.ASM'
 16945                                  ; ----------------------------------------------------------------------
 16946                                  ; 04/06/2018 - Retro DOS v3.0 (MSDOS 3.3, SYSINIT1.ASM, 24/07/1987)
 16947                                  
 16948                                  ; 22/03/2019 - Retro DOS v4.0
 16949                                  
 16950                                  ; SYSINIT:0269h (MSDOS 6.21 IO.SYS, SYSINIT segment, offset: 0269h)
 16951                                  
 16952                                  ; ('SYSINIT:' location/address is used in 'retrodos4.s'. If following
 16953                                  ; address will be changed, it must also be changed in 'retrodos4.s'.)
 16954                                  
 16955                                  ; 21/10/2022- Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 16956                                  ; ----------------------------------------------------------------------
 16957                                  ; SYSINITSEG:0267h (MSDOS 5.0 IO.SYS, SYSINIT segment, offset: 0267h)
 16958                                  
 16959                                  SYSINIT:	
 16960 00000267 E91C02                          JMP	GOINIT
 16961                                  	;JMP	SYSIN ; 25/02/2018 - Retro DOS 2.0 modification
 16962                                  
 16963                                  ; ----------------------------------------------------------------------
 16964                                  
 16965                                  struc DDHighInfo
 16966 00000000 ????????                 .ddhigh_CSegPtr resd 1	; pointer to code segment to be relocated
 16967 00000004 ????                     .ddhigh_CSegLen resw 1	; length of code segment to be relocated
 16968 00000006 ????????                 .ddhigh_CallBak resd 1	; pointer to the call back routine
 16969                                  endstruc
 16970                                  
 16971                                  ; 22/03/2019 - Retro DOS v4.0
 16972                                  
 16973 0000026A 00                      runhigh: db	0
 16974                                  
 16975                                  ; 02/11/2022
 16976                                  ;align 4
 16977                                  
 16978                                  DOSINFO: 
 16979 0000026B 00000000                	dd	0	; address of the DOS Sysini Variables
 16980                                  ;MSDOS:
 16981                                  dos_temp_location: ; dword ; MSDOS 6.0
 16982                                  dosinit:		; MSDOS 6.0
 16983 0000026F 0000                    	dw	0
 16984                                  
 16985                                  ; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 16986                                  ;FINAL_DOS_LOCATION: ; 20/04/2019 - Retro DOS v4.0
 16987                                  ;	dw	0
 16988                                  ;MSDOS 5.0 IO.SYS - SYSINIT:0271h
 16989                                  
 16990                                  CURRENT_DOS_LOCATION:
 16991 00000271 0000                    	dw	0
 16992                                  
 16993                                  ;DOSSIZE: ; Retro DOS 2.0 feature - 25/02/2018
 16994                                  ;	dw	0   ; 'MSDOS.BIN' kernel size in words
 16995                                  
 16996                                  ; 22/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 16997                                  ; (MSDOS 5.0 MSDOS.SYS size is 37394 bytes)
 16998                                  DOSSIZE	equ	0A000h	; (MSDOS 6.0 - SYSINIT1.ASM - 1991)
 16999                                  
 17000                                  DEVICE_LIST:
 17001 00000273 00000000                	dd	0
 17002                                  
 17003                                  ; 04/06/2018 - Retro DOS v3.0
 17004                                  ; 28/03/2018
 17005                                  ;; MSDOS 3.3 - SYSINIT1.ASM - 24/07/1987
 17006                                  ;
 17007                                  sysi_country:	
 17008 00000277 00000000                	dd	0 ; 5/29/86 Pointer to country table in DOS
 17009                                  
 17010                                  ; MSDOS 6.0
 17011 0000027B 00000000                dos_segreinit:	dw	0,0	; room for dword
 17012                                  
 17013 0000027F 0000                    lo_doscod_size:	dw	0	; dos code size when in low mem
 17014 00000281 0000                    hi_doscod_size:	dw	0	; dos code size when in HMA
 17015                                  
 17016 00000283 0000                    def_php:	dw	0
 17017                                  
 17018                                  ; M022--
 17019                                  ; pointer for calling into Bios_Code for re-initializing segment values.
 17020                                  ;  call with ax = new segment for Bios_Code. Notice that we'll
 17021                                  ;  call it in its temporary home, cuz seg_reinit won't get moved to
 17022                                  ;  the new home.
 17023                                  
 17024                                  ;Bios_Code	equ	KERNEL_SEGMENT  ; 0070h
 17025                                  ; 21/10/2022
 17026                                  ;DOSBIOCODESEG	equ	02C7h ; (MSDOS 5.0 IO.SYS)
 17027                                  
 17028                                  ; 22/10/2022
 17029                                  seg_reinit_ptr:	; label dword
 17030 00000285 [3200]                  		dw	seg_reinit ; Bios_Code:0032h for MSDOS 6.21 IO.SYS
 17031                                  temp_bcode_seg:
 17032                                  		;dw	Bios_Code  ; 02CCh for MSDOS 6.21 IO.SYS
 17033                                  		; 22/10/2022
 17034 00000287 B702                    		dw	DOSBIOCODESEG ; 02C7h for MSDOS 5.0 IO.SYS 		
 17035                                  
 17036                                  fake_floppy_drv:
 17037 00000289 00                      		db	0	; set to 1 if this machine
 17038                                  				; does not have any floppies!!!
 17039                                  
 17040                                  ; Internal Stack Parameters
 17041                                  
 17042 0000028A 0900                    stack_count:	dW	defaultcount ; 9
 17043 0000028C 8000                    stack_size:	dw	defaultsize  ; 128
 17044 0000028E 00000000                stack_addr:	dd	0	
 17045                                  
 17046                                  ; 05/06/2018 - Retro DOS v3.0
 17047                                  
 17048                                  ; various default values
 17049                                  
 17050 00000292 0100                    MEMORY_SIZE:	dw	1
 17051                                  
 17052                                  ; 22/03/2019 - Retro DOS v4.0 (MSDOS 6.0 source, MSDOS 6.21 disassembled src.)
 17053                                  
 17054 00000294 0000                    RPLMemTop:	dw	0  ; 22/10/2022 (MSDOS 5.0 IO.SYS SYSINIT:0294h)	
 17055 00000296 00                      DEFAULT_DRIVE:	db	0	;initialized by ibminit.
 17056 00000297 FFFF                    buffers:	dw	0FFFFh	; initialized during buffer allocation
 17057 00000299 0000                    h_buffers:	dw	0	; # of the heuristic buffers. initially 0.
 17058 0000029B 0000                    singlebuffersize: dw	0	; maximum sector size + buffer head
 17059                                  
 17060 0000029D 08                      FILES:	db	8	; enough files for pipe
 17061 0000029E 04                      FCBS:	db	4	; performance for recycling
 17062 0000029F 00                      KEEP:	db	0	; keep original set
 17063 000002A0 05                      NUM_CDS: db	5	; 5 net drives
 17064                                  ; 22/10/2022 (MSDOS 5.0 SYSINIT)
 17065                                  ;CONFBOT: dw	0
 17066                                  ;ALLOCLIM: dw	0
 17067                                  CONFBOT: ; 02/11/2022
 17068 000002A1 0000                    top_of_cdss: dw 0
 17069                                  ; 02/11/2022 (MSDOS 5.0 SYSINIT)
 17070 000002A3 0000                    ALLOCLIM: dw	0	; (SYSINIT:02A3h)	
 17071                                  
 17072 000002A5 413A5C00                DirStrng: db	"A:\",0	; string for the root directory of a drive
 17073                                  ; 30/10/2022 (MSDOS 5.0 IO.SYS SAYSINIT compatibility)
 17074                                  ; (SYSINIT:02A9h)
 17075                                  command_line:
 17076 000002A9 0200                    	db	2,0
 17077 000002AB 50                      	db	'P'
 17078 000002AC 00                      	db	0
 17079 000002AD 00<rep 7Ch>             	times	124 db 0 ; db 124 dup(0)	
 17080                                  ; (SYSINIT:0329h)
 17081 00000329 00                      ZERO:	db	0
 17082 0000032A 00                      sepchr:	db	0
 17083 0000032B 0000                    linecount: dw	0			; line count in config.sys
 17084 0000032D 20202020200D0A24        showcount: db	'     ',cr,lf,'$'	; used to convert linecount to ascii.
 17085 00000335 0000                    buffer_linenum: dw	0		; line count for "buffers=" command if entered.
 17086                                  
 17087 00000337 FF                      sys_model_byte:	db	0FFh		; model byte used in sysinit
 17088 00000338 00                      sys_scnd_model_byte: db 0		; secondary model byte used in sysinit
 17089                                  
 17090 00000339 0000                    buf_prev_off:	dw	0
 17091                                  
 17092                                          ;IF      NOT NOEXEC
 17093                                  ;COMEXE EXEC0 <0,COMMAND_LINE,DEFAULT_DRIVE,ZERO>
 17094                                          ;ENDIF
 17095                                  
 17096                                  ; 01/05/2018
 17097                                  COMEXE:
 17098 0000033B 0000                    EXEC0.ENVIRON:	dw	0	; seg addr of environment
 17099 0000033D [A902]                  EXEC0.COM_LINE:	dw	command_line ; pointer to asciz command line
 17100 0000033F 0000                    		dw	0 	; SYSINIT segment (0473h for MSDOS 6.21 IO.SYS)
 17101 00000341 [9602]                  EXEC0.5C_FCB:	dw	DEFAULT_DRIVE ; default fcb at 5C
 17102 00000343 0000                    		dw	0	; SYSINIT segment (0473h for MSDOS 6.21 IO.SYS)
 17103 00000345 [2903]                  EXEC0.6C_FCB:	dw	ZERO	; default fcb at 6C
 17104 00000347 0000                    		dw	0
 17105                                  
 17106                                  ; variables for install= command.
 17107                                  
 17108 00000349 00                      multi_pass_id:	db	0		; parameter passed to multi_pass
 17109                                  					;  indicating the pass number
 17110                                  					; 0 - do scan for DOS=HIGH/LOW
 17111                                  					; 1 - load device drivers
 17112                                  					; 2 - was to load IFS
 17113                                  					;      now it is unused
 17114                                  					; 3 - do install=
 17115                                  					; >3 - nop
 17116 0000034A 0000                    install_flag:	dw	0
 17117                                  
 17118                                  have_install_cmd equ	00000001b	; config.sys has install= commands
 17119                                  has_installed	equ	00000010b	; sysinit_base installed.
 17120                                  
 17121 0000034C 0000                    config_size:	dw	0		; size of config.sys file. set by sysconf.asm
 17122 0000034E 00000000                sysinit_base_ptr: dd	0		; pointer to sysinit_base
 17123 00000352 00000000                sysinit_ptr:	dd	0		; returning addr. from sysinit_base
 17124 00000356 0000                    checksum:	dw	0		; used by sum_up
 17125                                  
 17126 00000358 20<rep 14h>             ldexec_fcb:	times 20 db 20h ; db 20 dup (' ') ;big enough
 17127 0000036C 00                      ldexec_line:	db	0		;# of parm characters
 17128 0000036D 20                      ldexec_start:	db	' '
 17129 0000036E 00<rep 50h>             ldexec_parm:	times 80 db 0	; db 80 dup (0)
 17130                                  
 17131                                  ;instexe exec0	<0,ldexec_line,ldexec_fcb,ldexec_fcb>
 17132                                  
 17133                                  instexe:
 17134 000003BE 0000                    iexec.environ:	dw	0		; seg addr of environment
 17135 000003C0 [6C03]                  iexec.ldexec_line: dw	ldexec_line ; pointer to asciz command line
 17136 000003C2 0000                    		dw	0 	; SYSINIT segment (0473h for MSDOS 6.21 IO.SYS)
 17137 000003C4 [5803]                  iexec.ldexec_5c_fcb: dw	ldexec_fcb	; default fcb at 5C
 17138 000003C6 0000                    		dw	0	; SYSINIT segment (0473h for MSDOS 6.21 IO.SYS)
 17139 000003C8 [5803]                  iexec.ldexec_6c_fcb: dw	ldexec_fcb	; default fcb at 6C
 17140 000003CA 0000                    		dw	0
 17141                                  
 17142                                  ; variables for comment=
 17143                                  
 17144 000003CC 00                      com_level:	db	0		; level of " " in command line
 17145 000003CD 00                      cmmt:		db	0		; length of comment string token
 17146 000003CE 00                      cmmt1:		db	0		; token
 17147 000003CF 00                      cmmt2:		db	0		; token
 17148 000003D0 00                      cmd_indicator:	db	0
 17149 000003D1 00                      donotshownum:	db	0
 17150                                  
 17151 000003D2 0000                    count:		dw	0
 17152 000003D4 0000                    org_count:	dw	0
 17153 000003D6 0000                    chrptr:		dw	0
 17154 000003D8 0000                    cntryfilehandle: dw	0
 17155 000003DA 0000                    old_area:	dw	0
 17156 000003DC 0000                    impossible_owner_size: dw 0		; paragraph
 17157                                  
 17158                                  bucketptr: ; label dword
 17159                                  bufptr:	   ; label dword		; leave this stuff in order!
 17160 000003DE 0000                    memlo:	dw	0
 17161                                  prmblk:	   ; label word
 17162 000003E0 0000                    memhi:	dw	0
 17163 000003E2 0000                    ldoff:	dw	0
 17164 000003E4 0000                    area:	dw	0
 17165                                  
 17166                                  ; Following is the request packet used to call INIT routines for 
 17167                                  ; all device drivers. Some fields may be accessed individually in
 17168                                  ; the code, and hence have individual labels, but they should not
 17169                                  ; be separated.
 17170                                  
 17171 000003E6 18                      packet:	db	24			; was 22
 17172 000003E7 00                      	db	0
 17173 000003E8 00                      	db	0			; initialize code
 17174 000003E9 0000                    	dw	0
 17175 000003EB 00<rep 8h>              	times	8 db 0	; db 8 dup (?)
 17176                                  
 17177 000003F3 00                      unitcount:	db	0
 17178 000003F4 00000000                break_addr:	dd	0
 17179 000003F8 00000000                bpb_addr:	dd	0
 17180                                  drivenumber:	; 22/10/2022
 17181 000003FC 00                      devdrivenum:	db	0 
 17182 000003FD 0000                    configmsgflag:	dw	0  ; used to control "error in config.sys line #" message
 17183                                  
 17184                                  ; end of request packet
 17185                                  
 17186                                  ;drivenumber:	db	0  ; 22/03/2019
 17187                                  
 17188                                  toomanydrivesflag:
 17189 000003FF 00                      		db	0  ; >24 fixed disk partitions flag ; M029 
 17190                                  align 2
 17191                                  
 17192                                  BCodeSeg:	; 21/10/2022
 17193 00000400 B702                    	dw	DOSBIOCODESEG ; (02C7h for MSDOS 5.0 IO.SYS)
 17194                                  	;dw	Bios_Code ; = KERNEL_SEGMENT = 0070h (for Retro DOS v4.0)
 17195                                  			   ; BCodeSeg = 2CCh (for MSDOS 6.21 IO.SYS)
 17196                                  
 17197                                  ; 02/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 17198                                  ;; 19/04/2019
 17199                                  ;_timer_lw_:
 17200                                  ;	dw	0  ; MSDOS 6.21 IO.SYS - SYSINIT:038Ch
 17201                                  	
 17202                                  ;SR;
 17203                                  ; This is the communication block between the DOS and the BIOS. It starts at
 17204                                  ;the SysinitPresent flag. Any other data that needs to be communicated 
 17205                                  ;to the DOS should be added after SysinitPresent. The pointer to this block
 17206                                  ;is passed to DOS as part of the DOSINIT call.
 17207                                  ;
 17208                                  
 17209                                  BiosComBlock:
 17210                                  	;dd	Bios_Data:SysinitPresent 
 17211                                  		; 0070h:08FDh for MSDOS 6.21 IO.SYS
 17212 00000402 [FB08]                  	dw	SysinitPresent  ; (retrodos4.sys, offset: ****h)
 17213                                  	;dw	KERNEL_SEGMENT ; 0070h
 17214                                  	; 21/10/2022
 17215 00000404 7000                    	dw	DOSBIODATASEG ; 0070h
 17216                                  
 17217                                  ;align 2
 17218                                  
 17219                                  	; 22/10/2022 - (MSDOS 5.0 IO.SYS, SYSINIT:0406h)
 17220                                  tempstack:	
 17221 00000406 00<rep 80h>             	times	128 db 0  ; db	80h dup (?)
 17222                                  
 17223                                  ; ----------------------------------------------------------------------------
 17224                                  
 17225                                  	; 22/10/2022 - Retro DOS v4.0
 17226                                  	;	; (MSDOS 5.0 IO.SYS, SYSINIT:0486h)
 17227                                  GOINIT:		; (MSDOS 6.21 IO.SYS, SYSINIT:0412h)
 17228                                  	; 12/12/2022
 17229                                  	; 22/03/2019 - Retro DOS v4.0
 17230                                  	; 06/07/2018
 17231                                  	; 04/06/2018 - Retro DOS v3.0
 17232                                  ; before doing anything else, let's set the model byte
 17233 00000486 B4C0                    	mov	ah,0C0h 		; get system configuration
 17234 00000488 CD15                    	int	15h			; *
 17235 0000048A 7217                    	jc	short no_rom_config
 17236                                  
 17237 0000048C 80FC00                  	cmp	ah,0			; double check
 17238 0000048F 7512                    	jne	short no_rom_config
 17239 00000491 268A4702                	mov	al,[es:bx+ROMBIOS_DESC.bios_sd_modelbyte]
 17240 00000495 2EA2[3703]              	mov	[cs:sys_model_byte],al 
 17241 00000499 268A4703                	mov	al,[es:bx+ROMBIOS_DESC.bios_sd_scnd_modelbyte]
 17242 0000049D 2EA2[3803]              	mov	[cs:sys_scnd_model_byte],al
 17243                                  	;jmp	short SYSIN
 17244                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 17245 000004A1 EB2D                    	jmp	short move_myself
 17246                                  
 17247                                  no_rom_config:				; Old ROM
 17248 000004A3 B800F0                  	mov	ax,0F000h
 17249 000004A6 8ED8                    	mov	ds,ax
 17250 000004A8 A0FEFF                  	mov	al,[0FFFEh]
 17251 000004AB 2EA2[3703]              	mov	[cs:sys_model_byte],al	; set the model byte.
 17252                                  
 17253                                  ; set fake_floppy_drv if there is no diskette drives in this machine.
 17254                                  ; execute the equipment determination interrupt and then
 17255                                  ; check the returned value to see if we have any floppy drives
 17256                                  ; if we have no floppy drive we set cs:fake_floppy_drv to 1
 17257                                  ; see the at tech ref bios listings for help on the equipment
 17258                                  ; flag interrupt (11h)	
 17259                                  
 17260                                  	; 22/10/2022
 17261                                  check_for_fake_floppy:			; entry point for rom_config above
 17262 000004AF CD11                    	int	11h			; check equipment flag
 17263                                  
 17264                                  	; 12/12/2022
 17265 000004B1 A801                    	test	al,1		
 17266                                  	;test	ax,1			; have any floppies?
 17267 000004B3 751B                    	jnz	short move_myself	; yes,normal system
 17268                                  
 17269                                  ; Some ROM BIOSs lie that there are no floppy drives. Lets find out
 17270                                  ; whether it is an old ROM BIOS or a new one
 17271                                  ;
 17272                                  ; WARNING !!!
 17273                                  ;
 17274                                  ; This sequence of code is present in MSINIT.ASM also. Any modification
 17275                                  ; here will require an equivalent modification in MSINIT.ASM also
 17276                                  
 17277 000004B5 06                      	push	es
 17278                                  
 17279 000004B6 30C9                    	xor	cl,cl	
 17280 000004B8 B408                    	mov	ah,8			; get disk parameters
 17281 000004BA B200                    	mov	dl,0			; of drive 0
 17282 000004BC CD13                    	int	13h
 17283                                  
 17284 000004BE 07                      	pop	es
 17285                                  
 17286 000004BF 720F                    	jc	short move_myself	; if error lets assume that the
 17287                                  					;  ROM BIOS lied
 17288 000004C1 80F900                  	cmp	cl,0			; double check (max sec no cannot be 0)
 17289 000004C4 740A                    	je	short move_myself
 17290                                  
 17291 000004C6 08D2                    	or	dl,dl			; number of flp drvs == 0?
 17292 000004C8 7506                    	jnz	short move_myself
 17293                                  
 17294 000004CA 2EC606[8902]01          	mov	byte [cs:fake_floppy_drv],1 ; set fake flag.
 17295                                  
 17296                                  move_myself:
 17297 000004D0 FC                      	cld				; set up move
 17298 000004D1 31F6                    	xor	si,si
 17299 000004D3 89F7                    	mov	di,si
 17300                                  
 17301                                  	; 12/12/2022
 17302 000004D5 0E                      	push	cs
 17303 000004D6 1F                      	pop	ds
 17304                                  
 17305                                  	;mov	cx,[cs:MEMORY_SIZE]
 17306 000004D7 8B0E[9202]              	mov	cx,[MEMORY_SIZE] ; 12/12/2022
 17307                                  
 17308                                  	; (MSDOS 6.0 - SYSINIT1.ASM - 1991)
 17309                                  ;;;	if	msver
 17310                                  ;	cmp	cx,1		; 1 means do scan
 17311                                  ;	jnz	short noscan
 17312                                  ;	mov	cx,2048		; start scanning at 32k boundary
 17313                                  ;	xor	bx,bx
 17314                                  ;
 17315                                  ;memscan:inc	cx
 17316                                  ;	jz	setend
 17317                                  ;	mov	ds,cx
 17318                                  ;	mov	al,[bx]
 17319                                  ;	not	al
 17320                                  ;	mov	[bx],al
 17321                                  ;	cmp	al,[bx]
 17322                                  ;	not	al
 17323                                  ;	mov	[bx],al
 17324                                  ;	jz	short memscan
 17325                                  ;setend:
 17326                                  ;	mov	cs:[memory_size],cx
 17327                                  ;;;	endif
 17328                                  
 17329                                  ;noscan: 				; cx is mem size in para
 17330                                  ;;
 17331                                  ;;	cas -- a) if we got our memory size from the ROM, we should test it
 17332                                  ;;		  before we try to run.
 17333                                  ;;	       b) in any case, we should check for sufficient memory and give
 17334                                  ;;		  an appropriate error diagnostic if there isn't enough
 17335                                  ;
 17336                                  ;	push	cs
 17337                                  ;	pop	ds
 17338                                  ;
 17339                                  ;;	cas note:  It would be better to put dos + bios_code BELOW sysinit
 17340                                  ;;	  that way it would be easier to slide them down home in a minimal
 17341                                  ;;	  memory system after sysinit.  As it is, you need room to keep
 17342                                  ;;	  two full non-overlapping copies, since sysinit sits between the
 17343                                  ;;	  temporary home and the final one.  the problem with doing that
 17344                                  ;;	  is that sys*.asm are filled with "mov ax,cs, sub ax,11h" type stuff.
 17345                                  ;
 17346                                  ;	dec	cx			; one para for an arena at end of mem
 17347                                  ;					; in case of UMBs
 17348                                  
 17349                                  	; 22/10/2022
 17350                                  	; (MSDOS 5.0 IO.SYS SYSINIT:04DBh)
 17351                                  
 17352                                  	; 12/12/2022
 17353                                  	;push	cs
 17354                                  	;pop	ds
 17355                                  
 17356 000004DB 49                      	dec	cx
 17357                                  
 17358                                  ;------ Check if an RPL program is present at TOM and do not tromp over it
 17359                                  
 17360 000004DC 31DB                    	xor	bx,bx
 17361 000004DE 8EC3                    	mov	es,bx
 17362                                  	;mov	bx,[es:(2Fh*4)] ; INT 2Fh address (0:0BCh)
 17363                                  	;mov	es,[es:((2Fh*4)+2)] ; INT 2Fh segment (0:0BEh)
 17364                                  	; 29/09/2023
 17365 000004E0 26C41EBC00              	les	bx,[es:(2Fh*4)] 
 17366 000004E5 26817F035250            	cmp	word [es:bx+3],'RP'
 17367 000004EB 751B                    	jne	short NoRPL
 17368 000004ED 26807F054C              	cmp	byte [es:bx+5],'L'
 17369 000004F2 7514                    	jne	short NoRPL
 17370                                  
 17371 000004F4 89CA                    	mov	dx,cx			; get TOM into DX
 17372 000004F6 52                      	push	dx
 17373 000004F7 B8064A                  	mov	ax,4A06h
 17374                                  	;mov	ax,(multMULT<<8)+multMULTRPLTOM
 17375 000004FA CD2F                    	int	2Fh			; Get new TOM from any RPL
 17376 000004FC 58                      	pop	ax
 17377 000004FD 89D1                    	mov	cx,dx
 17378 000004FF 39C2                    	cmp	dx,ax
 17379 00000501 7405                    	je	short NoRPL
 17380                                  	
 17381                                  	; 11/12/2022
 17382                                  	; ds = cs
 17383 00000503 8916[9402]              	mov	[RPLMemTop],dx
 17384                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 17385                                  	;mov	[cs:RPLMemTop],dx
 17386                                  	
 17387 00000507 49                      	dec	cx
 17388                                  NoRPL:
 17389 00000508 B8[6039]                	mov	ax,SI_end		; need this much room for sysinit
 17390                                  					; (SI_end == sysinit code size)
 17391 0000050B E8B806                  	call	off_to_para
 17392 0000050E 29C1                    	sub	cx,ax
 17393                                  
 17394                                  ; we need to leave room for the DOS and (if not ROMDOS) for the BIOS
 17395                                  ; code above sysinit in memory
 17396                                  ;
 17397 00000510 81E9000A                	sub	cx,DOSSIZE/16		; leave this much room for DOS
 17398                                  
 17399 00000514 B8001A                  	mov	ax,BCODE_END 		; (1A60h for MSDOS 5.0 IO.SYS)
 17400 00000517 E8AC06                  	call	off_to_para		; leave this much room for BIOS code
 17401 0000051A 29C1                    	sub	cx,ax
 17402 0000051C 8EC1                    	mov	es,cx			; offset where sysinit will be located
 17403                                  
 17404 0000051E B9[6039]                	mov	cx,SI_end		; (sysinit code size)
 17405 00000521 D1E9                    	shr	cx,1			; divide by 2 to get words
 17406 00000523 F3A5                    	rep	movsw			; relocate sysinit
 17407                                  
 17408 00000525 06                      	push	es			; push relocated segment
 17409 00000526 B8[2B05]                	mov	ax,SYSIN
 17410 00000529 50                      	push	ax			; push relocated entry point
 17411                                  
 17412 0000052A CB                      	retf				; far jump to relocated sysinit
 17413                                  
 17414                                  ; ----------------------------------------------------------------------------
 17415                                  
 17416                                  ;	MOVE THE DOS TO ITS PROPER LOCATION
 17417                                  
 17418                                  	; 22/10/2022 - Retro DOS 4.0 (Modified MSDOS 5.0 IO.SYS)
 17419                                  	; (SYSINIT:0533h)
 17420                                  SYSIN:
 17421                                  	; Retro DOS 4.0 - 22/03/2019
 17422                                  	; Retro DOS 2.0 - 25/02/2018
 17423                                  
 17424                                  	; 23/04/2019
 17425                                  	;;mov	ax,Bios_Data
 17426                                  	;mov	ax,KERNEL_SEGMENT ; 0070h
 17427                                  	; 21/10/2022
 17428 0000052B B87000                  	mov	ax,DOSBIODATASEG ; 0070h
 17429 0000052E 8ED8                    	mov	ds,ax
 17430 00000530 8C0E[F908]              	mov	[MoveDOSIntoHMA+2],cs	; set seg of routine to move DOS
 17431 00000534 C606[FB08]01            	mov	byte [SysinitPresent],1	; flag that MoveDOSIntoHMA can be called
 17432                                  
 17433                                  ; first move the MSDOS.SYS image up to a harmless place 
 17434                                  ; on top of our new sysinitseg
 17435                                  
 17436                                  	; 22/10/2022
 17437 00000539 B8[6039]                	mov	ax,SI_end		; how big is sysinitseg?
 17438 0000053C E88706                  	call	off_to_para
 17439 0000053F 8CC9                    	mov	cx,cs			; pick a buffer for msdos above us
 17440 00000541 01C8                    	add	ax,cx
 17441 00000543 8EC0                    	mov	es,ax
 17442                                  	
 17443 00000545 31F6                    	xor	si,si
 17444 00000547 89F7                    	mov	di,si
 17445                                  
 17446 00000549 2E8E1E[7102]            	mov	ds,[cs:CURRENT_DOS_LOCATION] ; where it is (set by msinit)
 17447                                  
 17448                                  	;mov	ax,cs	
 17449                                  	;mov	ds,ax
 17450                                  
 17451                                  	;;;mov	cx,20480  ; MSDOS 6.21 IO.SYS - SYSINIT:04E2h
 17452                                  	;;mov	cx,dossize/2 ; MSDOS 6.0
 17453                                  	;mov	cx,[DOSSIZE] ; words (not bytes!)  ; Retro DOS v4.0 (3.0, 2.0)
 17454                                  	;mov	es,[FINAL_DOS_LOCATION] ; on top of SYSINIT code
 17455                                  	;mov	ds,[CURRENT_DOS_LOCATION]
 17456                                  
 17457                                  	; 22/10/2022
 17458 0000054E B90050                  	mov	cx,DOSSIZE/2 ; 5000h
 17459 00000551 F3A5                    	rep     movsw
 17460 00000553 2E8C06[7102]            	mov	[cs:CURRENT_DOS_LOCATION],es
 17461                                  
 17462                                  ; The DOS code is ORGed at a non-zero value to allow it to be located in
 17463                                  ; HIMEM. Thus, the DOS segment location must be adjusted accordingly.
 17464                                  ; If this is ROMDOS, however, only the init code is loaded into RAM, so
 17465                                  ; this ORG is not done. The entry point is at offset zero in the segment.
 17466                                  
 17467                                  	; 22/04/2019 (MSDOS 6.0 & MSDOS 6.21 kernel address modification)
 17468                                  	;mov	ax,cs
 17469                                  	; 02/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS, SYSINIT)
 17470                                  	;mov	ds,ax
 17471                                  
 17472                                  ; 29/04/2019 - Retro DOS v4.0 ! important MODIFICATION !
 17473                                  
 17474                                  ;	; 24/04/2019 
 17475                                  ;;ifndef ROMDOS
 17476                                  ;	mov	ax,[es:3] 		; get offset of dos
 17477                                  ;		; ax = 3DE0h for MSDOS 6.21 kernel (MSDOS.SYS, offset 3) 
 17478                                  ;	mov	[dosinit],ax		; that's the entry point offset
 17479                                  ;	call	off_to_para		; subtract this much from segment
 17480                                  ;	; 23/04/2019
 17481                                  ;	;sub	[CURRENT_DOS_LOCATION],ax
 17482                                  ;	sub	[FINAL_DOS_LOCATION],ax
 17483                                  ;;else
 17484                                  ;;	mov	word [dosinit],0	; entry to init is at zero
 17485                                  ;;
 17486                                  ;;endif ; ROMDOS
 17487                                  
 17488                                  	; 29/04/2019 - Retro DOS v4.0 ! important MODIFICATION !
 17489                                  	; (! MSDOS6.BIN starts with DOSDATA ! - Retro DOS v4.0 modification) 
 17490                                  
 17491                                  	;mov	ax,[es:0] ; DOSCODE start address = DOSDATA size (= 136Ah)
 17492                                  	;		  ; (Valid for Retro DOS v4.0 only!)
 17493                                  
 17494                                  	; 22/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS, SYSINIT)
 17495                                  	; (SYSINIT:0563h for MSDOS 5.0 IO.SYS SYSINIT)
 17496 00000558 A10300                  	mov	ax, [3]		; mov ax, word ptr ds:3
 17497                                  
 17498 0000055B 2EA3[6F02]              	mov	[cs:dosinit],ax ; (SYSINIT:0563h for MSDOS 5.0 IO.SYS SYSINIT)
 17499                                  	; 02/11/2022
 17500 0000055F E86406                  	call	off_to_para		; subtract this much from segment
 17501 00000562 2E2906[7102]            	sub	[cs:CURRENT_DOS_LOCATION],ax
 17502                                  
 17503                                  	; Current DOSCODE start address = dword [dosinit]
 17504                                  
 17505                                  ;; If this is not ROMDOS, then the BIOS code is moved to the top of memory
 17506                                  ;; until it is determined whether it will be running in HIMEM or not.
 17507                                  
 17508                                  ;ifndef ROMDOS
 17509                                  
 17510                                  ; now put Bios_Code up on top of that. Assume Bios_Code + dossize < 64k
 17511                                  
 17512                                  	; 22/10/2022
 17513 00000567 8CC0                    	mov	ax,es
 17514 00000569 05000A                  	add	ax,DOSSIZE/16		; get paragraph of end of dos
 17515 0000056C 8EC0                    	mov	es,ax
 17516 0000056E 2E8706[8702]            	xchg	ax,[cs:temp_bcode_seg]	; swap with original home of Bios_Code
 17517 00000573 8ED8                    	mov	ds,ax			; point to loaded image of Bios_Code
 17518                                  
 17519                                  	;mov	si,BCODE_START ; mov si,30h
 17520                                  	; 09/12/2022
 17521 00000575 BE[3000]                	mov	si,BCODESTART
 17522                                  	; 02/11/2022
 17523 00000578 89F7                    	mov	di,si
 17524                                  	;mov	cx,BCODE_END   ; mov cx,1A60h
 17525                                  	;sub	cx,si
 17526                                  	; 29/09/2023
 17527                                  	BCODESIZE equ BCODEEND-BCODESTART
 17528 0000057A B9D019                  	mov	cx,BCODESIZE
 17529 0000057D D1E9                    	shr	cx,1
 17530 0000057F F3A5                    	rep	movsw			; move Bios_Code into place
 17531                                  
 17532 00000581 8CC0                    	mov	ax,es			; tell it what segment it's in
 17533 00000583 2EFF1E[8502]            	call	far [cs:seg_reinit_ptr]	; far call to seg_reinit in Bios_Code (M022)
 17534                                  
 17535                                  ;endif	; not ROMDOS
 17536                                  
 17537                                  ; now call dosinit while it's in its temporary home
 17538                                  
 17539                                  	;mov	ax,cs
 17540                                  	;mov	ds,ax	 
 17541                                  
 17542                                  	;mov	dx,[MEMORY_SIZE]	; set for call to dosinit
 17543                                  
 17544                                  	; 22/10/2022
 17545                                  
 17546 00000588 2EC43E[0204]            	les	di,[cs:BiosComBlock]	; ptr to BIOS communication block
 17547                                  		; es = KERNEL_SEGMENT (70h), di = 'SysInitPresent' address
 17548 0000058D 2EC536[7302]            	lds	si,[cs:DEVICE_LIST]	; set for call to dosinit
 17549                                  		; ds = KERNEL_SEGMENT (70h), si = 'res_dev_list' address
 17550                                  
 17551 00000592 2E8B16[9202]            	mov	dx,[cs:MEMORY_SIZE]	; set for call to dosinit
 17552                                  
 17553 00000597 FA                      	cli
 17554 00000598 8CC8                    	mov	ax,cs
 17555 0000059A 8ED0                    	mov	ss,ax
 17556                                  
 17557                                  ; 22/03/2019 - Retro DOS v4.0 (MSDOS 6.0, SYSINIT1.ASM)
 17558                                  %define locstack ($ - SYSINIT$) & 0FFFEh  ; 532h in MSDOS 6.21 IO.SYS
 17559                                  					  ; 5A6h in MSDOS 5.0 IO.SYS SYSINIT
 17560                                  ;SYSINIT:0532h:
 17561                                  
 17562                                  ; 22/10/2022
 17563                                  ; ----------------------------------------------------------------------------
 17564                                  ;SYSINIT:05A6h:
 17565                                  ;locstack:	; (at SYSINIT:05A6h for MSDOS 5.0 IO.SYS)
 17566                                  
 17567                                  	;mov	sp, 05A6h
 17568 0000059C BC9C05                  	mov     sp,locstack		; set stack
 17569                                  
 17570 0000059F FB                      	sti
 17571                                  
 17572                                  ;align 2
 17573                                  	; 30/03/2018
 17574                                  ;LOCSTACK:
 17575                                          ;CALL	FAR [CS:MSDOS]	; FINAL_DOS_LOCATION:0 
 17576                                  		       		;('jmp DOSINIT' in 'MSHEAD.ASM')
 17577                                  		       		;('DOSINIT:' is in 'MSINIT.ASM')
 17578                                  
 17579                                  	; 22/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 17580                                  	; 22/03/2019 - Retro DOS v4.0 (MSDOS 6.0, 6.21)
 17581                                  
 17582                                  ; This call to DOSINIT will relocate the DOS data from its present location
 17583                                  ; at the top of memory, to its final location in low memory just above the
 17584                                  ; BIOS data. It will then build important DOS data structures in low 
 17585                                  ; memory following the DOS data. It returns (among many other things) the
 17586                                  ; new starting address of free memory.
 17587                                  
 17588 000005A0 2EFF1E[6F02]            	call	far [cs:dosinit]	; call dosinit	
 17589                                  			 ; es:di -> sysinitvars_ext
 17590                                  
 17591 000005A5 2E8C1E[8302]            	mov	[cs:def_php],ds		; save pointer to PSP
 17592                                  	
 17593                                  	; 11/12/2022
 17594                                  	; 22/03/2019
 17595 000005AA 0E                      	push	cs
 17596 000005AB 1F                      	pop	ds
 17597                                  	; 22/10/2022
 17598 000005AC A3[8102]                	mov	[hi_doscod_size],ax
 17599 000005AF 890E[7F02]              	mov	[lo_doscod_size],cx
 17600 000005B3 8916[7B02]              	mov	[dos_segreinit],dx
 17601                                  	
 17602                                  	; 11/12/2022
 17603                                  	; ds = cs
 17604                                  	;mov	[cs:hi_doscod_size],ax	; size of doscode (including exepatch)
 17605                                  	;mov	[cs:lo_doscod_size],cx	; (not including exepatch)
 17606                                  	;mov	[cs:dos_segreinit],dx	; save offset of segreinit
 17607                                  
 17608                                  	; 05/06/2018 - Retro DOS v3.0
 17609                                  	; ES:DI = Address of pointer to SYSINITVARS structure (MSDOS 3.3)
 17610                                  
 17611                                  	; 11/12/2022
 17612                                  	; ds = cs
 17613                                  	; 22/10/2022
 17614                                  	;mov	ax,[es:di+SysInitVars_Ext.SYSI_InitVars] ; 5/29/86
 17615 000005B7 268B05                  	mov	ax,[es:di] ; 22/03/2019
 17616                                  	;mov	[cs:DOSINFO],ax
 17617 000005BA A3[6B02]                	mov	[DOSINFO],ax
 17618                                  	;mov	ax,[es:di+SysInitVars_Ext.SYSI_InitVars+2]
 17619 000005BD 268B4502                	mov	ax,[es:di+2]
 17620                                  	;mov	[cs:DOSINFO+2],ax
 17621 000005C1 A3[6D02]                	mov	[DOSINFO+2],ax	; set the sysvar pointer
 17622                                  
 17623                                  	;mov	ax,[es:di+SysInitVars_Ext.SYSI_Country_Tab]
 17624 000005C4 268B4504                	mov	ax,[es:di+4]
 17625                                  	;mov	[cs:sysi_country],ax
 17626 000005C8 A3[7702]                	mov	[sysi_country],ax
 17627                                  	;mov	ax,[es:di+SysInitVars_Ext.SYSI_Country_Tab+2]
 17628 000005CB 268B4506                	mov	ax,[es:di+6]
 17629                                  	;mov	[cs:sysi_country+2],ax
 17630 000005CF A3[7902]                	mov	[sysi_country+2],ax	; set the SYSI_Country pointer
 17631                                  
 17632                                  	; 20/04/2019
 17633                                  	;mov	ax,[CURRENT_DOS_LOCATION]
 17634                                  	;;mov	es,[CURRENT_DOS_LOCATION]
 17635                                  	;mov	ax,[FINAL_DOS_LOCATION] ; give dos its temporary location
 17636                                  	; 22/10/2022
 17637                                  	;mov	ax,[cs:CURRENT_DOS_LOCATION]
 17638                                  	;;;mov	[dos_segreinit+2],es
 17639                                  	;;mov	[dos_segreinit+2],ax
 17640                                  	;mov	[cs:dos_segreinit+2],ax
 17641                                  	; 11/12/2022
 17642                                  	; ds = cs
 17643 000005D2 8E06[7102]              	mov	es,[CURRENT_DOS_LOCATION]
 17644 000005D6 8C06[7D02]              	mov	[dos_segreinit+2],es
 17645                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 17646                                  	;mov	es,[cs:CURRENT_DOS_LOCATION]
 17647                                  	;mov	[cs:dos_segreinit+2],es
 17648                                  
 17649                                  ; ----------------------------------------------------------------------------
 17650                                  
 17651                                  ;SYSINIT:0577h:
 17652                                  	; ... RPLArena ... MSDOS 6.21 IO.SYS (SYSINIT:0577h to SYSINIT:05D1h)
 17653                                  ;SYSINIT:05D1h:	; NoRPLArena 
 17654                                  
 17655                                  	; 22/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS SYSINIT)
 17656                                  ;------ Cover up RPL code with an arena
 17657                                  ;SYSINIT:05EBh:
 17658                                  	; 11/12/2022
 17659                                  	; ds = cs
 17660 000005DA 31DB                    	xor	bx,bx
 17661 000005DC 391E[9402]              	cmp	[RPLMemTop],bx ; 0
 17662                                  	;cmp	word [RPLMemTop],0
 17663                                  	;;cmp	word [cs:RPLMemTop],0
 17664 000005E0 7450                    	je	short NoRPLArena
 17665                                  
 17666                                  ;------ alloc all memory
 17667                                  
 17668                                  	; 11/12/2022
 17669                                  	;mov	bx,0FFFFh
 17670 000005E2 4B                      	dec	bx
 17671                                  	; bx = 0FFFFh
 17672 000005E3 B448                    	mov	ah,48h
 17673 000005E5 CD21                    	int	21h
 17674                                  			; DOS - 2+ - ALLOCATE MEMORY
 17675                                  			; BX = number of 16-byte paragraphs desired
 17676 000005E7 B448                    	mov	ah,48h
 17677 000005E9 CD21                    	int	21h
 17678                                  
 17679 000005EB 8EC0                    	mov	es,ax			; get it into ES and save it
 17680 000005ED 06                      	push	es
 17681                                  
 17682                                  ;------ resize upto RPL mem
 17683                                  
 17684                                  	; 11/12/2022
 17685                                  	; ds = cs
 17686                                  	;sub	ax,[cs:RPLMemTop]
 17687 000005EE 2B06[9402]              	sub	ax,[RPLMemTop]
 17688 000005F2 F7D8                    	neg	ax
 17689 000005F4 48                      	dec	ax
 17690 000005F5 89C3                    	mov	bx,ax
 17691 000005F7 B44A                    	mov	ah,4Ah
 17692 000005F9 CD21                    	int	21h
 17693                                    			; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
 17694                                  			; ES = segment address of block to change
 17695                                  			; BX = new size in paragraphs
 17696                                  
 17697                                  ;------ allocate the free (RPL MEM)
 17698                                  
 17699 000005FB BBFFFF                  	mov	bx,0FFFFh
 17700 000005FE B448                    	mov	ah,48h
 17701 00000600 CD21                    	int	21h
 17702 00000602 B448                    	mov	ah,48h
 17703 00000604 CD21                    	int	21h
 17704                                  
 17705                                  ;----- mark that it belongs to RPL
 17706                                  
 17707 00000606 48                      	dec	ax
 17708 00000607 8EC0                    	mov	es,ax
 17709                                  	;mov	word [es:arena_owner],8
 17710 00000609 26C70601000800          	mov	word [es:1],8
 17711                                  	;mov	word [es:arena_name],'RP'
 17712 00000610 26C70608005250          	mov	word [es:8],'RP'
 17713                                  	;mov	word [es:arena_name+2],'L'
 17714 00000617 26C7060A004C00          	mov	word [es:10],'L'
 17715                                  	;mov	word [es:arena_name+4],0
 17716 0000061E 26C7060C000000          	mov	word [es:12],0
 17717                                  	;mov	word [es:arena_name+6],0
 17718 00000625 26C7060E000000          	mov	word [es:14],0	
 17719                                  
 17720 0000062C 07                              pop     es                      ; get back ptr to first block
 17721 0000062D B449                            mov     ah,49h	; Dealloc	; and free it
 17722 0000062F CD21                    	int	21h		
 17723                                  					; DOS - 2+ - FREE MEMORY
 17724                                  					; ES = segment address of area to be freed
 17725                                  	; 11/12/2022
 17726 00000631 F8                      	clc
 17727                                  
 17728                                  ; ----------------------------------------------------------------------------
 17729                                  
 17730                                  NoRPLArena:
 17731                                  	; 11/12/2022
 17732                                  	; ds = cs
 17733                                  	; 22/03/2019 - Retro DOS v4.0 (MSDOS 6.0, 6.21, IO.SYS)
 17734 00000632 C43E[6B02]              	les	di,[DOSINFO]	; es:di -> dosinfo
 17735                                  	; 22/10/2022 - Retro DOS v4.0 (MSDOS 5.0 IO.SYS SYSINIT)
 17736                                  	;les	di,[cs:DOSINFO]	; es:di -> dosinfo
 17737                                  
 17738                                  	; 11/12/2022
 17739                                  	;clc				; get the extended memory size
 17740                                  
 17741                                  ;	execute the get extended memory size subfunction in the bios int 15h
 17742                                  ;	if the function reports an error do nothing else store the extended
 17743                                  ;	memory size reported at the appropriate location in the dosinfo buffer
 17744                                  ;	currently pointed to by es:di. use the offsets specified in the
 17745                                  ;	definition of the sysinitvars struct in inc\sysvar.inc
 17746                                  
 17747 00000636 B488                    	mov	ah,88h
 17748 00000638 CD15                    	int	15h			; check extended memory size
 17749 0000063A 720B                    	jc	short no_ext_memory
 17750                                  			; Get Extended Memory Size
 17751                                  			; Return: CF clear on success
 17752                                  			; AX = size of memory above 1M in K	
 17753                                  	;mov	[es:di+SYSI_EXT_MEM],ax ; save extended memory size
 17754                                  	; 22/10/2022
 17755 0000063C 26894545                	mov	[es:di+45h],ax ; save extended memory size
 17756 00000640 09C0                    	or	ax,ax
 17757 00000642 7403                    	jz	short no_ext_memory
 17758 00000644 E8F504                  	call	ClrVDISKHeader
 17759                                  no_ext_memory:
 17760                                  	;mov	ax,[es:di+SYSI_MAXSEC]	; get the sector size
 17761 00000647 268B4510                	mov	ax,[es:di+10h]
 17762                                  	;add	ax,bufinsiz
 17763 0000064B 83C014                  	add	ax,20			; size of buffer header
 17764                                  	; 11/12/2022
 17765                                  	; ds = cs
 17766 0000064E A3[9B02]                	mov	[singlebuffersize],ax	; total size for a buffer
 17767                                  	;mov	[cs:singlebuffersize],ax	
 17768                                  	; 11/12/2022
 17769 00000651 A0[9602]                	mov	al,[DEFAULT_DRIVE]	; get the 1 based boot drive number set by msinit
 17770                                  	;mov	al,[cs:DEFAULT_DRIVE]
 17771                                  	;mov	[es:di+SYSI_BOOT_DRIVE],al ; set sysi_boot_drive
 17772 00000654 26884543                	mov	[es:di+43h],al
 17773                                  
 17774                                  ; determine if 386 system...
 17775                                  
 17776                                  	;get_cpu_type			; macro to determine cpu type
 17777                                  
 17778                                  get_cpu_type:
 17779                                  	; 11/12/2022
 17780 00000658 9C                      	pushf
 17781                                  	;push	bx
 17782                                  	;xor	bx,bx
 17783                                  	; 11/12/2022
 17784                                  	;xor	cx,cx
 17785                                  	;
 17786 00000659 31C0                    	xor	ax,ax
 17787                                  	; ax = 0
 17788 0000065B 50                      	push    ax
 17789 0000065C 9D                      	popf
 17790 0000065D 9C                      	pushf
 17791 0000065E 58                      	pop	ax
 17792 0000065F 2500F0                  	and	ax,0F000h
 17793                                  	;cmp	ax,0F000h
 17794 00000662 80FCF0                  	cmp	ah,0F0h 
 17795 00000665 7410                    	je	short cpu_8086
 17796                                  	;mov	ax,0F000h
 17797 00000667 B4F0                    	mov	ah,0F0h
 17798                                  	; ax = 0F000h
 17799 00000669 50                      	push	ax
 17800 0000066A 9D                      	popf
 17801 0000066B 9C                      	pushf
 17802 0000066C 58                      	pop	ax
 17803                                  	;and	ax,0F000h
 17804 0000066D 80E4F0                  	and	ah,0F0h
 17805 00000670 7405                    	jz	short cpu_286
 17806                                  cpu_386:
 17807                                  	; 11/12/2022
 17808                                  	;;inc	bx
 17809                                  	;inc	cx
 17810                                  	; 11/12/2022
 17811                                  	;mov	byte [es:di+SYSI_DWMOVE],1
 17812 00000672 26C6454401              	mov	byte [es:di+44h],1
 17813                                  cpu_286:
 17814                                  	;;;inc	bx
 17815                                  	;;inc	cx
 17816                                  cpu_8086:
 17817                                  	; 11/12/2022
 17818                                  	;;mov	ax,bx	
 17819                                  	;pop	bx
 17820 00000677 9D                      	popf
 17821                                  
 17822                                  	;...
 17823                                  
 17824                                  	; 11/12/2022
 17825                                  	;or	cl,cl
 17826                                  	;jz	short not_386_system
 17827                                  	; 11/12/202
 17828                                  	;cmp	cl,2
 17829                                  	;;cmp	ax,2			; is it a 386?
 17830                                  	;jne	short not_386_system	; no: don't mess with flag
 17831                                  	;;mov	byte [es:di+SYSI_DWMOVE],1
 17832                                  	; 11/12/2022
 17833                                  	; 22/10/2022
 17834                                  	;mov	byte [es:di+44h],1
 17835                                  not_386_system:
 17836                                  	;mov	al,[es:di+SYSI_NUMIO]
 17837 00000678 268A4520                	mov	al,[es:di+20h]
 17838                                  	; 11/12/2022
 17839                                  	; ds = cs
 17840 0000067C A2[FC03]                	mov	[drivenumber],al	; save start of installable block drvs
 17841                                  	;mov	[cs:drivenumber],al
 17842                                  
 17843 0000067F 8CC8                    	mov	ax,cs
 17844 00000681 83E811                  	sub	ax,11h			; room for PSP we will copy shortly
 17845                                  	; 11/12/2022
 17846                                  	;mov	cx,[singlebuffersize]	; temporary single buffer area
 17847                                  	;;mov	cx,[cs:singlebuffersize]
 17848                                  	;shr	cx,1			
 17849                                  	;shr	cx,1			; divide size by 16...
 17850                                  	;shr	cx,1
 17851                                  	;shr	cx,1			; ...to get paragraphs...
 17852                                  	;inc	cx			; ... and round up
 17853                                  	; 11/12/2022
 17854 00000684 8B1E[9B02]              	mov	bx,[singlebuffersize]
 17855 00000688 B104                    	mov	cl,4
 17856 0000068A D3EB                    	shr	bx,cl
 17857 0000068C 43                      	inc	bx
 17858                                  
 17859                                  ;	cas note: this unorthodox paragraph rounding scheme wastes a byte
 17860                                  ;	  if [singlebuffersize] ever happens to be zero mod 16. Could this
 17861                                  ;	  ever happen? Only if the buffer overhead was zero mod 16, since
 17862                                  ;	  it is probably safe to assume that the sector size always will be.
 17863                                  ;
 17864                                  ;	 mohans also found a bug in CONFIG.SYS processing where it replaces
 17865                                  ;	  EOF's with cr,lf's, without checking for collision with [confbot].
 17866                                  ;	  perhaps the extra byte this code guarantees is what has kept that
 17867                                  ;	  other code from ever causing a problem???
 17868                                  
 17869                                  	; 11/12/2022
 17870 0000068D 29D8                    	sub	ax,bx
 17871                                  	;sub	ax,cx
 17872 0000068F A3[A102]                	mov	[top_of_cdss],ax	; temp "unsafe" location
 17873                                  	; 22/10/2022
 17874                                  	;mov	[cs:top_of_cdss],ax
 17875                                  
 17876                                  ;	chuckst -- 25 Jul 92 -- added code here to pre-allocate space
 17877                                  ;	for 26 temporary CDSs, which makes it easier to use alloclim
 17878                                  ;	for allocating memory for MagicDrv.
 17879                                  
 17880 00000692 06                      	push	es			; preserve pointer to dosinfo
 17881 00000693 57                      	push	di
 17882                                  
 17883                                  	; 22/10/2022
 17884                                  ;	mov	cx,ax			; save pointer for buffer
 17885                                  ;
 17886                                  ;;	now allocate space for 26 CDSs
 17887                                  ;
 17888                                  ;	sub	ax,((26 *(curdirlen))+15)/16
 17889                                  ;	mov	[ALLOCLIM],ax		; init top of free memory pointer
 17890                                  ;	mov	[CONFBOT],ax		; init this in case no CONFIG.SYS
 17891                                  
 17892                                  ; setup and initialize the temporary buffer at cx
 17893                                  
 17894                                  	;les	di,[es:di+SYSI_BUF]	; get the buffer chain entry pointer
 17895 00000694 26C47D12                	les	di,[es:di+12h]
 17896                                  	; 11/12/2022
 17897 00000698 31DB                    	xor	bx,bx
 17898                                  	;xor	ax,ax
 17899                                  	;mov	[es:di+BUFFINF.Dirty_Buff_Count],ax ; 0
 17900                                  	;mov	word [es:di+4],0
 17901 0000069A 26895D04                	mov	[es:di+4],bx ; 0
 17902                                  	;mov	[es:di+BUFFINF.Buff_Queue],ax ; 0
 17903                                  	;mov	word [es:di],0
 17904 0000069E 26891D                  	mov	[es:di],bx ; 0
 17905                                  	;;mov	[es:di+BUFFINF.Buff_Queue+2],cx ; cx = [top_of_cdss]
 17906                                  	;mov	[es:di+BUFFINF.Buff_Queue+2],ax ; ax = [top_of_cdss]
 17907 000006A1 26894502                	mov	[es:di+2],ax
 17908                                  
 17909                                  	;mov	es,cx
 17910 000006A5 8EC0                    	mov	es,ax	; [top_of_cdss] = [CONFBOT]
 17911                                  
 17912                                  	; 11/12/2022
 17913                                  	;xor	ax,ax
 17914                                  	;mov	di,ax			; es:di -> single buffer
 17915 000006A7 89DF                    	mov	di,bx
 17916                                  	; di = 0
 17917                                  
 17918                                  	;mov	[es:di+buffinfo.buf_next],ax ; points to itself
 17919                                  	; 11/12/2022
 17920                                  	;mov	[es:di],ax ; 0
 17921 000006A9 26891D                  	mov	[es:di],bx ; 0
 17922                                  	;mov	[es:di+buffinfo.buf_prev],ax ; points to itself
 17923                                  	; 11/12/2022
 17924                                  	;mov	[es:di+2],ax ; 0
 17925 000006AC 26895D02                	mov	[es:di+2],bx ; 0 
 17926                                  
 17927                                  	; 22/10/2022 - Retro DOS 4.0 (Modified MSDOS 5.0 IO.SYS SYINIT)
 17928                                  	; MSDOS 5.0 IO.SYS - SYSINIT:06E0h
 17929                                  
 17930                                  	;mov	word [es:di+buffinfo.buf_ID],00FFh ; free buffer,clear flag
 17931 000006B0 26C74504FF00            	mov	word [es:di+4],00FFh
 17932                                  ;SYSINIT:06E6h
 17933                                  	;;mov	[es:di+buffinfo.buf_sector],ax ; 0
 17934                                  	;mov	word [es:di+6],0
 17935                                  	; 11/12/2022
 17936                                  	;mov	[es:di+buffinfo.buf_sector],bx ; 0
 17937 000006B6 26895D06                	mov	[es:di+6],bx ; 0
 17938                                  	;;mov	[es:di+buffinfo.buf_sector+2],ax ; 0
 17939                                  	;mov	word [es:di+8],0
 17940                                  	; 11/12/2022
 17941                                  	;mov	[es:di+buffinfo.buf_sector+2],bx ; 0
 17942 000006BA 26895D08                	mov	[es:di+8],bx ; 0
 17943                                  
 17944 000006BE 5F                      	pop	di			; restore pointer to DOSINFO data
 17945 000006BF 07                      	pop	es
 17946                                  
 17947                                  	; 11/12/2022
 17948                                  	; ds = cs
 17949                                  	; 22/10/2022
 17950                                  	;push	cs
 17951                                  	;pop	ds
 17952                                  
 17953 000006C0 E80C05                  	call	TempCDS 		; set up cdss so re_init and sysinit
 17954                                  					;  can make disk system calls
 17955                                  					; tempcds trashes ds
 17956                                  	; 10/05/2019
 17957 000006C3 2E8E1E[8302]            	mov	ds,[cs:def_php]		; retrieve pointer to PSP returned by DOSINIT
 17958                                  
 17959                                  	;if not ibmjapver
 17960                                  	;call	far KERNEL_SEGMENT:re_init ; re-call the bios
 17961                                  	;endif
 17962                                  
 17963                                  	; 22/10/2022
 17964                                  ;SYSINIT:06FEh:	; (MSDOS 5.0 IO.SYS, SYSINIT)
 17965                                  	;call	far ptr 70h:89Bh
 17966 000006C8 9A[9908]7000            	call	DOSBIODATASEG:RE_INIT
 17967                                  
 17968 000006CD FB                      	sti				; ints ok
 17969 000006CE FC                      	cld				; make sure
 17970                                  
 17971                                  ; 23/03/2019
 17972                                  
 17973                                  ;SYSINIT:069Ch
 17974                                  
 17975                                  ; dosinit has set up a default "process" (php) at ds:0. we will move it out
 17976                                  ; of the way by putting it just below sysinit at end of memory.
 17977                                  
 17978 000006CF 8CCB                    	mov	bx,cs
 17979 000006D1 83EB10                  	sub	bx,10h
 17980 000006D4 8EC3                    	mov	es,bx
 17981 000006D6 31F6                    	xor	si,si
 17982 000006D8 89F7                    	mov	di,si
 17983 000006DA B98000                  	mov	cx,128
 17984 000006DD F3A5                    	rep	movsw
 17985                                  
 17986                                  	;mov	[es:PDB.JFN_POINTER+2],es ; Relocate
 17987                                  	; 22/10/2022
 17988 000006DF 268C063600              	mov	[es:36h],es
 17989                                  
 17990                                   	; Set Process Data Block - Program Segment Prefix address
 17991                                  	; BX = PDB/PSP segment
 17992 000006E4 B450                            mov	ah,50h ; SET_CURRENT_PDB
 17993 000006E6 CD21                    	int	21h			; tell DOS we moved it
 17994                                  			; DOS - 2+ internal - SET PSP SEGMENT
 17995                                  			; BX = segment address of new PSP
 17996                                  	; 22/10/2022
 17997                                  	; 27/03/2019
 17998 000006E8 1E                      	push	ds ; */			; preserve DS returned by DOSINIT
 17999                                  
 18000 000006E9 0E                      	push	cs	
 18001 000006EA 1F                      	pop	ds
 18002                                  
 18003                                  	; set up temp. critical error handler
 18004 000006EB BA[A033]                	mov	dx,int24		; set up int 24 handler
 18005                                  	;;mov	ax,(SET_INTERRUPT_VECTOR*256)+24h
 18006                                  	;mov	ax,(SET_INTERRUPT_VECTOR<<8)|24h
 18007 000006EE B82425                  	mov	ax,2524h
 18008 000006F1 CD21                    	int	21h
 18009                                  
 18010 000006F3 803E[FF03]00                    cmp     byte [toomanydrivesflag],0 ; Q: >24 partitions?      M029
 18011 000006F8 7405                            je      short no_err		   ;  N: continue            M029
 18012 000006FA BA[1639]                        mov     dx,TooManyDrivesMsg	   ;  Y: print error message M029
 18013                                          ; 22/10/2022
 18014                                  	;call	print 			   ;		             M029
 18015                                  	; 12/12/2022
 18016 000006FD EB03                    	jmp	short p_dosinit_msg ; 23/03/2019 - Retro DOS v4.0                    
 18017                                  no_err:
 18018                                  	; 12/05/2019
 18019                                  	;----------------------------------------------
 18020                                  	; 27/06/2018 - Retro DOS v3.0	; 23/03/2019 - Retro DOS v4.0
 18021                                  	; 22/10/2022 - Retro DOS v4.0
 18022                                  	; 12/12/2022
 18023 000006FF BA[1C34]                	mov	dx,BOOTMES		; Display (fake) MSDOS version message
 18024                                  p_dosinit_msg:
 18025 00000702 E8762C                  	call	print			; Print message
 18026                                  	;----------------------------------------------
 18027                                  	
 18028                                  	; 11/12/2022
 18029                                  	; 22/10/2022
 18030                                  	; 23/03/2019 - Retro DOS v4.0
 18031                                  	;pop	ds			; start of free memory
 18032                                  	;mov	dl,[cs:DEFAULT_DRIVE]
 18033                                  	
 18034                                  	; 11/12/2022
 18035                                  	; 27/03/2019
 18036 00000705 8A16[9602]              	mov	dl,[DEFAULT_DRIVE]	
 18037 00000709 1F                      	pop	ds ; */
 18038                                  
 18039 0000070A 08D2                    	or	dl,dl
 18040                                  	;jz	short nodrvset		; bios didn't say
 18041 0000070C 7405                    	jz	short ProcessConfig  ; (Retro DOS v4.0 does not contain DBLSPACE code)
 18042                                  	;dec	dl			; A = 0
 18043                                  	; 18/12/2022
 18044 0000070E 4A                      	dec	dx
 18045 0000070F B40E                    	mov	ah,0Eh	; SET_DEFAULT_DRIVE
 18046 00000711 CD21                    	int	21h			; select the disk
 18047                                  			; DOS - SELECT DISK
 18048                                  			; DL = new default drive number (0 = A, 1 = B, etc.)
 18049                                  			; Return: AL = number of logical drives
 18050                                  nodrvset:
 18051                                  	;ifdef	dblspace_hooks
 18052                                  	;	....
 18053                                  	;	....
 18054                                  	;endif	
 18055                                  
 18056                                  ; MSDOS 6.21 IO.SYS, SYSINIT:0744h
 18057                                  
 18058                                  ; 23/03/2019 - Retro DOS v4.0 (MSDOS 6.0, SYSINIT1.ASM, 1991)
 18059                                  ; ----------------------------------------------------------------------------
 18060                                  ; 22/10/2022 - Retro DOS v4.0 (MSDOS 5.0 IO.SYS SYSINIT)
 18061                                  
 18062                                  ProcessConfig:
 18063                                  	;; ds = cs ; 27/03/2019
 18064                                  	; 11/12/2022
 18065                                  	; ds <> cs	
 18066                                  
 18067                                  ; (MSDOS 5.0 IO.SYS - SYSINIT:0746h)
 18068                                  
 18069 00000713 E8FB17                  	call	doconf			; do pre-scan for dos=high/low
 18070                                  
 18071                                  	; 11/12/2022
 18072                                  	; 27/03/2019
 18073                                  	; ds = cs (at return from doconf)
 18074                                  
 18075                                  ; Now, if this is not romdos, we decide what to do with the DOS code.
 18076                                  ; It will either be relocated to low memory, above the DOS data structures,
 18077                                  ; or else it will be located in HiMem, in which case a stub with the DOS
 18078                                  ; code entry points will be located in low memory. Dos_segreinit is used
 18079                                  ; to tell the DOS data where the code has been placed, and to install the
 18080                                  ; low memory stub if necessary. If the DOS is going to go into HiMem, we
 18081                                  ; must first initialize it in its present location and load the installable
 18082                                  ; device drivers. Then, if a HiMem driver has been located, we can actually
 18083                                  ; relocate the DOS code into HiMem.
 18084                                  ;
 18085                                  ; For ROMDOS, if DOS=HIGH is indicated, then we need to call dos_segreinit
 18086                                  ; to install the low memory stub (this must be done before allowing any
 18087                                  ; device drivers to hook interrupt vectors). Otherwise, we don't need to 
 18088                                  ; call dos_segreinit at all, since the interrupt vector table has already 
 18089                                  ; been patched.
 18090                                  
 18091                                  	; 22/10/2022 - Retro DOS v4.0
 18092                                  	; (MSDOS 5.0 IO.SYS - SYSINIT:0749h)
 18093                                  	;cmp	byte [cs:runhigh],0	; Did user choose to run low ?
 18094                                  	; 11/12/2022
 18095 00000716 803E[6A02]00            	cmp	byte [runhigh],0
 18096 0000071B 740C                    	je	short dont_install_stub	; yes, don't install dos low mem stub
 18097                                  
 18098                                  ;------ user chose to load high
 18099                                  
 18100                                  	; 22/10/2022
 18101                                  	;mov	es,[cs:CURRENT_DOS_LOCATION] ; MSDOS 6.21 (& MSDOS 6.0)
 18102                                  	; 11/12/2022
 18103                                  	; ds = cs
 18104 0000071D 8E06[7102]              	mov	es,[CURRENT_DOS_LOCATION]
 18105                                  
 18106                                  	;mov	es,[cs:FINAL_DOS_LOCATION]   ; Retro DOS v4.0
 18107                                  	; 27/03/2019
 18108                                  	;;mov	es,[FINAL_DOS_LOCATION]
 18109                                  
 18110 00000721 31C0                    	xor	ax,ax			; ax = 0 ---> install stub
 18111                                  	; 11/12/2022
 18112                                  	; ds = cs
 18113                                  	;call	far [cs:dos_segreinit]	; call dos segreinit
 18114 00000723 FF1E[7B02]              	call	far [dos_segreinit]
 18115                                  
 18116 00000727 EB10                    	jmp	short do_multi_pass
 18117                                  
 18118                                  ;------ User chose to load dos low
 18119                                  
 18120                                  dont_install_stub:
 18121                                  	; 22/10/2022
 18122 00000729 31DB                    	xor	bx,bx			; M012
 18123                                  					; don't use int 21 call to alloc mem
 18124 0000072B E8D701                  	call	MovDOSLo		; move it !
 18125                                  
 18126 0000072E B80100                  	mov	ax,1			; dont install stub
 18127                                  	; 11/12/2022
 18128                                  	; ds = cs
 18129 00000731 8E06[7102]              	mov	es,[CURRENT_DOS_LOCATION]
 18130                                  	;mov	es,[cs:CURRENT_DOS_LOCATION] ; set_dos_final_position set it up
 18131                                  	;;mov	es,[cs:FINAL_DOS_LOCATION]   ; Retro DOS v4.0
 18132                                  	; 27/03/2019
 18133                                  ;do_multi_pass:
 18134                                  	;;mov	es,[FINAL_DOS_LOCATION] 
 18135                                  
 18136                                  	; 11/12/2022
 18137                                  	; ds =cs
 18138                                  	;call	far [cs:dos_segreinit]	; inform dos about new seg
 18139 00000735 FF1E[7B02]              	call	far [dos_segreinit]
 18140                                  do_multi_pass:
 18141 00000739 E81301                  	call	AllocFreeMem		; allocate all the free mem
 18142                                  					; & update [memhi] & [area]
 18143                                  					; start of free memory.
 18144                                  	;ifdef	dblspace_hooks
 18145                                  	;mov	bx,0			; magic backdoor to place int hooks
 18146                                  	;call	cs:MagicBackdoor
 18147                                  	;endif
 18148                                  
 18149                                  ; Now, process config.sys some more.  
 18150                                  ; Load the device drivers and install programs
 18151                                  
 18152                                  	; 22/10/2022
 18153                                  	;inc	byte [cs:multi_pass_id]	; multi_pass_id = 1
 18154                                  	; 11/12/2022
 18155                                  	; ds = cs
 18156 0000073C FE06[4903]              	inc	byte [multi_pass_id]
 18157 00000740 E86118                  	call	multi_pass		; load device drivers
 18158 00000743 E82425                  	call	ShrinkUMB
 18159 00000746 E84A25                  	call	UnlinkUMB		; unlink all UMBs	;M002
 18160                                  	; 02/11/2022
 18161                                  	;inc	byte [cs:multi_pass_id]	; multi_pass_id = 2
 18162                                  	; 11/12/2022
 18163                                  	; ds = cs
 18164 00000749 FE06[4903]              	inc	byte [multi_pass_id]
 18165 0000074D E85418                  	call	multi_pass		; was load ifs (now does nothing)
 18166                                  
 18167                                  	;ifdef	dblspace_hooks
 18168                                  	;call	MagicPostload		; make sure Magicdrv is final placed
 18169                                  	;endif
 18170                                  
 18171                                  	; ds = cs
 18172                                  	
 18173 00000750 E81405                  	call	endfile			; setup fcbs, files, buffers etc
 18174                                  
 18175                                  	;ifdef	dblspace_hooks
 18176                                  	;call	MagicSetCdss		; disable CDSs of reserved drives
 18177                                  	;endif
 18178                                  
 18179                                  ;Reset SysinitPresent flag here. This is needed for the special fix for lying
 18180                                  ;to device drivers. This has been moved up to this point to avoid problems 
 18181                                  ;with overlays called from installed programs
 18182                                  
 18183                                  	; 11/12/2022
 18184                                  	; ds = cs
 18185                                  
 18186                                  	;;mov	ax,Bios_Data ; 0070h
 18187                                  	;mov	ax,KERNEL_SEGMENT
 18188                                  	; 21/10/2022
 18189 00000753 B87000                  	mov	ax,DOSBIODATASEG ; 0070h
 18190 00000756 8EC0                    	mov	es,ax			; point ES to bios data
 18191                                  
 18192 00000758 26C606[FB08]00          	mov	byte [es:SysinitPresent],0 ; clear SysinitPresent flag
 18193                                  
 18194                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 18195                                  	;test	word [cs:install_flag],have_install_cmd ; 1
 18196                                  	;test	byte [cs:install_flag],1
 18197                                  	; 11/12/2022
 18198                                  	; ds = cs
 18199 0000075E F606[4A03]01            	test	byte [install_flag],1
 18200                                  	;test	byte [cs:install_flag],have_install_cmd
 18201                                  					; are there install commands?
 18202 00000763 7407                    	jz	short dolast		; no, no need for further processing
 18203                                  	;inc	byte [cs:multi_pass_id]	; mult_pass_id = 3
 18204                                  	; 11/12/2022
 18205                                  	; ds =cs
 18206 00000765 FE06[4903]              	inc	byte [multi_pass_id]
 18207 00000769 E83818                  	call	multi_pass		; execute install= commands
 18208                                  
 18209                                  dolast:
 18210                                  	
 18211                                  ; [area] has the segment address for the allocated memory of sysinit, confbot.
 18212                                  ;  free the confbot area used for config.sys and sysinit itself.
 18213                                  
 18214                                  ; Now if DOS is supposed to run high, we actually move it into high memory 
 18215                                  ; (if HiMem manager is available). For ROMDOS, we don't actually move
 18216                                  ; anything, but just set up the ROM area for suballocation (or print
 18217                                  ; a message if HiMem is not available).
 18218                                  ;
 18219                                  ; There is also this little hack for CPM style DOS calls that needs to
 18220                                  ; be done when A20 is set...
 18221                                  
 18222                                  	; 11/12/2022
 18223                                  	; ds = cs
 18224                                  
 18225                                  	; 22/10/2022
 18226                                  	;cmp	byte [cs:runhigh],0FFh	; are we still waiting to be moved?
 18227                                  	; 11/12/2022
 18228 0000076C 803E[6A02]FF            	cmp	byte [runhigh],0FFh
 18229 00000771 7503                    	jne	short _@@_ ; 09/12/2022 ; no, our job is over
 18230 00000773 E83E01                  	call	LoadDOSHiOrLo
 18231                                  _@@_:
 18232                                  	;cmp	byte [cs:runhigh],0	; are we running low
 18233                                  	; 11/12/2022
 18234                                  	; ds = cs
 18235 00000776 803E[6A02]00            	cmp	byte [runhigh],0
 18236                                  	;je	short _@@@
 18237 0000077B 7403                    	je	short ConfigDone	; yes, no CPM hack needed
 18238 0000077D E83004                  	call	CPMHack			; make ffff:d0 same as 0:c0
 18239                                  _@@@:
 18240                                  
 18241                                  ; We are now done with CONFIG.SYS processing
 18242                                  
 18243                                  ConfigDone:
 18244                                  	; 12/12/2022
 18245                                  	; 22/10/2022
 18246                                  	;mov	byte [cs:donotshownum],1 
 18247                                  					; done with config.sys.
 18248                                  					; do not show line number message.
 18249                                  	;mov	es,[cs:area]
 18250                                  	; 12/12/2022
 18251                                  	; ds = cs
 18252                                  	; 27/03/2019
 18253 00000780 C606[D103]01            	mov	byte [donotshownum],1
 18254 00000785 8E06[E403]              	mov	es,[area]
 18255                                  
 18256 00000789 B449                            mov     ah,49h ; DEALLOC	; free allocated memory for command.com
 18257 0000078B CD21                    	int	21h
 18258                                  			; DOS - 2+ - FREE MEMORY
 18259                                  			; ES = segment address of area to be freed
 18260                                  
 18261                                  	; 22/10/2022
 18262                                  	;test	word [cs:install_flag],2
 18263                                  	;test	word [cs:install_flag],has_installed ; sysinit_base installed?
 18264                                  	;test	byte [cs:install_flag],has_installed
 18265                                  	; 11/12/2022
 18266                                  	; ds = cs
 18267 0000078D F606[4A03]02            	test	byte [install_flag],2 ; has_installed
 18268                                  	;test	byte [install_flag],has_installed
 18269 00000792 741F                    	jz	short skip_free_sysinitbase ; no.
 18270                                  
 18271                                  ; set block from the old_area with impossible_owner_size.
 18272                                  ; this will free the unnecessary sysinit_base that had been put in memory to
 18273                                  ; handle install= command.
 18274                                  
 18275                                  	; 12/12/2022
 18276                                          ;push	es		; BUGBUG 3-30-92 JeffPar: no reason to save ES
 18277                                  	;push	bx
 18278                                  	
 18279                                  	; 22/10/2022
 18280                                  	;mov	es,[cs:old_area]
 18281                                  	;mov	bx,[cs:impossible_owner_size]
 18282                                  	; 12/12/2022
 18283                                  	; ds = cs
 18284 00000794 8E06[DA03]              	mov	es,[old_area]
 18285 00000798 8B1E[DC03]              	mov	bx,[impossible_owner_size]
 18286                                  	
 18287 0000079C B44A                    	mov	ah,4Ah ; SETBLOCK
 18288 0000079E CD21                    	int	21h
 18289                                  			; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
 18290                                  			; ES = segment address of block to change
 18291                                  			; BX = new size in paragraphs
 18292 000007A0 8CC0                    	mov	ax,es
 18293 000007A2 48                      	dec	ax
 18294 000007A3 8EC0                    	mov	es,ax			; point to arena
 18295                                  	;mov	word [es:ARENA.OWNER],8	; set impossible owner
 18296 000007A5 26C70601000800          	mov	word [es:1],8
 18297                                  	;mov	word [es:ARENA.NAME],'SD' ; 4453h ; System Data
 18298 000007AC 26C70608005344          	mov	word [es:8],'SD'
 18299                                  	
 18300                                  	; 12/12/2022
 18301                                  	;pop	bx
 18302                                          ;pop     es		; BUGBUG 3-30-92 JeffPar: no reason to save ES
 18303                                  
 18304                                  skip_free_sysinitbase:
 18305                                  	; 22/10/2022
 18306                                  	;cmp	byte [cs:runhigh],0
 18307                                  	; 12/12/2022
 18308                                  	; ds = cs
 18309 000007B3 803E[6A02]00            	cmp	byte [runhigh],0	
 18310 000007B8 7403                    	je	short _@@@@
 18311                                  
 18312 000007BA E8D502                  	call	InstVDiskHeader	; Install VDISK header (allocates some mem from DOS)
 18313                                  
 18314                                  ; ----------------------------------------------------------------------------
 18315                                  
 18316                                  _@@@@:
 18317                                  	; 12/12/2022
 18318                                  	; ds = cs
 18319                                  	; 22/10/2022
 18320                                  	; 27/03/2019
 18321                                  	;push	cs
 18322                                  	;pop	ds			; point DS to sysinitseg
 18323                                  
 18324                                  ; set up the parameters for command
 18325                                  
 18326                                  	; 22/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS SYSINIT)
 18327                                  ;;ifdef  MULTI_CONFIG
 18328                                  ;	mov	byte [config_cmd],0	; set special code for query_user
 18329                                  ;       call    query_user		; to issue the AUTOEXEC prompt
 18330                                  ;	jnc	short process_autoexec	; we should process autoexec normally
 18331                                  ;	; !!!
 18332                                  ;	or	byte [bQueryOpt],4 ; MSDOS 6.21 IO.SYS - SYSINIT:081Fh
 18333                                  ;       ; !!!
 18334                                  ;	call    disable_autoexec        ; no, we should disable it
 18335                                  ;process_autoexec:
 18336                                  ;;endif	; !!!
 18337                                  ;	call	CheckQueryOpt	; MSDOS 6.21 IO.SYS - SYSINIT:0827h	
 18338                                  ;	; !!!
 18339                                  
 18340                                  	; 22/10/2022 
 18341                                  	;mov     cl,[command_line]
 18342                                          ;mov     ch,0
 18343                                          ;inc     cx
 18344                                          ;mov     si,command_line	
 18345                                  	;add     si,cx
 18346                                          ;mov     byte [si],cr	; cr-terminate command line
 18347                                  
 18348                                  	; 22/10/2022 - Retro DOS 4.0 (Modified MSDOS 5.0 IO.SYS)
 18349                                  	; (SYSINIT:0809h)
 18350                                  	
 18351                                  	;mov	si,(offset command_line+1)
 18352 000007BD BE[AA02]                	mov	si,command_line+1
 18353 000007C0 1E                      	push    ds
 18354 000007C1 07                      	pop     es
 18355 000007C2 89F7                    	mov     di,si
 18356 000007C4 B1FF                    	mov     cl,0FFh ; -1
 18357                                  _@_loop:
 18358 000007C6 FEC1                    	inc     cl ; +1
 18359 000007C8 AC                      	lodsb
 18360 000007C9 AA                      	stosb
 18361 000007CA 08C0                    	or      al,al
 18362 000007CC 75F8                    	jnz     short _@_loop
 18363 000007CE 4F                      	dec     di
 18364 000007CF B00D                    	mov     al,0Dh
 18365 000007D1 AA                      	stosb			; cr-terminate command line
 18366 000007D2 880E[A902]              	mov     [command_line],cl ; command line length (except CR)
 18367                                  
 18368                                  ; ----------------------------------------------------------------------------
 18369                                  
 18370                                  ;   Once we get to this point, the above code, which is below "retry"
 18371                                  ;   in memory, can be trashed (and in fact is -- see references to retry
 18372                                  ;   which follow....)
 18373                                  
 18374                                  retry:
 18375 000007D6 BA[C934]                	mov	dx,commnd	; now pointing to file description
 18376                                  
 18377                                  ; we are going to open the command interpreter and size it as is done in
 18378                                  ; ldfil. the reason we must do this is that sysinit is in free memory. if
 18379                                  ; there is not enough room for the command interpreter,exec will probably
 18380                                  ; overlay our stack and code so when it returns with an error sysinit won't be
 18381                                  ; here to catch it. this code is not perfect (for instance .exe command
 18382                                  ; interpreters are possible) because it does its sizing based on the
 18383                                  ; assumption that the file being loaded is a .com file. it is close enough to
 18384                                  ; correctness to be usable.
 18385                                  
 18386                                  ; first, find out where the command interpreter is going to go.
 18387                                  
 18388 000007D9 52                      	push	dx		; save pointer to name
 18389 000007DA BBFFFF                  	mov	bx,0FFFFh
 18390 000007DD B448                    	mov	ah,48h	; ALLOC
 18391 000007DF CD21                            int     21h             ; get biggest piece
 18392 000007E1 B448                    	mov	ah,48h	; ALLOC
 18393 000007E3 CD21                    	int	21h		; second time gets it
 18394 000007E5 7243                    	jc	short memerrjx	; oooops
 18395                                  
 18396 000007E7 8EC0                    	mov	es,ax
 18397 000007E9 B449                    	mov	ah,49h	; DEALLOC
 18398 000007EB CD21                    	int	21h		; give it right back
 18399 000007ED 89DD                    	mov	bp,bx
 18400                                  
 18401                                  ; es:0 points to block,and bp is the size of the block in para.
 18402                                  
 18403                                  ; we will now adjust the size in bp down by the size of sysinit.
 18404                                  ; we need to do this because exec might get upset if some of the exec
 18405                                  ; data in sysinit is overlayed during the exec.
 18406                                  
 18407                                  	; 22/10/2022
 18408                                  	; (MSDOS 5.0 IO.SYS SYSINIT:083Bh)
 18409 000007EF 8B1E[9202]                      mov     bx,[MEMORY_SIZE] ; get location of end of memory
 18410 000007F3 8CC8                    	mov	ax,cs		 ; get location of beginning of sysinit
 18411                                  
 18412                                  ; Note that the "config_wrkseg" environment data is a segment in
 18413                                  ; unallocated memory (as of the Dealloc of [area], above). This is ideal
 18414                                  ; in one sense, because Exec is going to make a copy of it for COMMAND.COM
 18415                                  ; anyway, and no one has responsibility for freeing "config_wrkseg". But
 18416                                  ; we need to make sure that there's no way Exec will stomp on that data
 18417                                  ; before it can copy it, and one way to do that is to make the available
 18418                                  ; memory calculation even more "paranoid", by subtracting "config_wrkseg"
 18419                                  ; from the "memory_size" segment value (which is typically A000h) instead
 18420                                  ; of the current sysinit CS....
 18421                                  ;
 18422                                  ; The reason I use the term "paranoid" is because this code should have
 18423                                  ; slid the data required by Exec up to the very top of memory, because as
 18424                                  ; it stands, you have to have sizeof(COMMAND.COM) PLUS 64K to load just
 18425                                  ; COMMAND.COM (64k is about what sysinit, and all the goop above sysinit,
 18426                                  ; consumes). Now it's just a little worse (65K or more, depending on
 18427                                  ; the size of your CONFIG.SYS, since the size of the environment workspace
 18428                                  ; is determined by the size of CONFIG.SYS.... -JTP
 18429                                  
 18430                                  	; 22/10/2022
 18431                                  	;mov	cx,[config_envlen]
 18432                                          ;jcxz	no_env		; use config_wrkseg only if there's env data
 18433                                          ;mov	ax,[config_wrkseg]
 18434                                  ;no_env:
 18435                                  	; 22/10/2022
 18436                                  	; (MSDOS 5.0 IO.SYS SYSINIT:0841h)
 18437 000007F5 29C3                      	sub     bx,ax           ; bx is size of sysinit in para
 18438 000007F7 83C311                  	add	bx,11h		; add the sysinit php
 18439 000007FA 29DD                    	sub	bp,bx		; sub sysinit size from amount of free memory
 18440 000007FC 722C                    	jc	short memerrjx	; if there isn't even this much memory, give up
 18441                                  
 18442                                          ;mov	ax,(OPEN<<8)	; open the file being execed
 18443 000007FE B8003D                          mov	ax,3D00h
 18444 00000801 F9                      	stc                     ; in case of int 24
 18445 00000802 CD21                    	int	21h
 18446 00000804 7241                    	jc	short comerr	; ooops
 18447                                  			; DOS - 2+ - OPEN DISK FILE WITH HANDLE
 18448                                  			; DS:DX -> ASCIZ filename
 18449                                  			; AL = access mode
 18450                                  			; 0 - read
 18451                                  	; 22/10/2022
 18452                                  	; (MSDOS 5.0 IO.SYS SYSINIT:0852h)
 18453 00000806 89C3                            mov     bx,ax           ; handle in bx
 18454                                  
 18455                                  ;   If the standard command interpreter is being used, verify it is correct
 18456                                  
 18457                                  	; 22/10/2022
 18458                                  	;cmp	byte [newcmd],0	; was a new shell selected?
 18459                                  	;jne	short skip_validation ; yes
 18460                                  	;mov	dx,retry-4
 18461                                  	;mov	cx,4		;
 18462                                  	;mov	ah,READ		;
 18463                                  	;int	21h		;
 18464                                  	;cmp	byte [retry-4],0E9h
 18465                                  	;jne	short comerr
 18466                                  	;; 20/04/2019 - Retro DOS v4.0
 18467                                  	;cmp	byte [retry-1],64h ; MSDOS 6.21 IO.SYS - SYSINIT:088Ch
 18468                                  	;;cmp	byte [retry-1],((MAJOR_VERSION&0Fh)<<4)|(MINOR_VERSION&0Fh)
 18469                                  	;jne	short comerr	;
 18470                                  
 18471                                  ;skip_validation:
 18472                                  	; 22/10/2022
 18473                                  	; (MSDOS 5.0 IO.SYS SYSINIT:0854h)
 18474 00000808 31C9                    	xor	cx,cx
 18475 0000080A 31D2                    	xor	dx,dx
 18476                                  	;mov	ax,(LSEEK<<8)|2
 18477 0000080C B80242                  	mov	ax,4202h
 18478 0000080F F9                      	stc			;in case of int 24
 18479 00000810 CD21                    	int	21h		; get file size in dx:ax
 18480 00000812 7233                    	jc	short comerr
 18481                                  				; convert size in dx:ax to para in ax
 18482 00000814 83C00F                  	add	ax,15		; round up size for conversion to para
 18483 00000817 83D200                  	adc	dx,0
 18484 0000081A E8A903                  	call	off_to_para
 18485 0000081D B10C                    	mov	cl,12
 18486 0000081F D3E2                    	shl	dx,cl		; low nibble of dx to high nibble
 18487 00000821 09D0                    	or	ax,dx		; ax is now # of para for file
 18488 00000823 83C010                  	add	ax,10h		; 100h byte php
 18489 00000826 39E8                    	cmp	ax,bp		; will command fit in available mem?
 18490 00000828 7203                    	jb	short okld	; jump if yes.
 18491                                  
 18492                                  	; 22/10/2022
 18493                                  memerrjx:	; (MSDOS 5.0 IO.SYS SYSINIT:0876h)
 18494                                  	;jmp	memerr	; (MSDOS 5.0 IO.SYS SYSINIT:34D5h)
 18495                                  	; 02/11/2022
 18496                                  	;jmp	mem_err
 18497                                  	; 11/12/2022
 18498                                  	; ds = cs
 18499 0000082A E9D228                  	jmp	mem_err2
 18500                                  
 18501                                  ;memerrjx:
 18502                                  ;	mov	dx,badmem
 18503                                  ;	call	print
 18504                                  ;       jmp     short continue
 18505                                  
 18506                                  okld:
 18507 0000082D B43E                    	mov	ah,3Eh ; CLOSE
 18508 0000082F CD21                    	int	21h		; close file
 18509                                  
 18510                                  	; 22/10/2022
 18511 00000831 5A                      	pop	dx	; (MSDOS 5.0 IO.SYS SYSINIT:087Dh)
 18512                                  
 18513                                  	; 24/03/2019
 18514                                  
 18515 00000832 0E                      	push	cs		; point es to sysinitseg
 18516 00000833 07                      	pop	es
 18517 00000834 BB[3B03]                        mov     bx,COMEXE	; point to exec block
 18518                                  	; 22/10/2022
 18519                                  	;pop	dx              ; recover pointer to name
 18520                                  
 18521                                  ;;ifdef	MULTI_CONFIG
 18522                                  
 18523                                  ;   If there's any environment data in "config_wrkseg", pass it to shell;
 18524                                  ;   there will be data if there were any valid SET commands and/or if a menu
 18525                                  ;   selection was made (in which case the CONFIG environment variable will be
 18526                                  ;   set to that selection).
 18527                                  
 18528                                  	; 23/10/2022
 18529                                  	;mov	cx,[config_envlen]
 18530                                  	;jcxz	no_envdata
 18531                                          ;mov	cx,[config_wrkseg]
 18532                                  ;no_envdata:
 18533                                  	;;mov	[bx+EXEC0.ENVIRON],cx
 18534                                  	;mov	[bx],cx
 18535                                  
 18536                                  ;;endif	;MULTI_CONFIG
 18537                                  
 18538                                  	; 23/10/2022
 18539                                  	; (MSDOS 5.0 IO.SYS SYSINIT:0883h)
 18540                                  
 18541                                  	;mov	[bx+EXEC0.COM_LINE+2],cs ; set segments
 18542 00000837 8C4F04                  	mov	[bx+4],cs
 18543                                  	;mov	[bx+EXEC0.5C_FCB+2],cs
 18544 0000083A 8C4F08                  	mov	[bx+8],cs
 18545                                  	;mov	[bx+EXEC0.6C_FCB+2],cs
 18546 0000083D 8C4F0C                  	mov	[bx+12],cs
 18547                                  
 18548                                  	;mov	ax,(EXEC<<8) + 0
 18549                                  	; 23/10/2022
 18550 00000840 31C0                    	xor	ax,ax
 18551 00000842 B44B                    	mov	ah,4Bh        
 18552                                  
 18553 00000844 F9                      	stc                     ; in case of int 24
 18554 00000845 CD21                            int     21h             ; go start up command
 18555                                  			; DOS - 2+ - LOAD OR EXECUTE (EXEC)
 18556                                  			; DS:DX -> ASCIZ filename
 18557                                  			; ES:BX -> parameter block
 18558                                  			; AL = subfunc: load & execute program
 18559                                  	;push	cs
 18560                                  	;pop	ds
 18561                                  
 18562                                  	; 23/10/2022
 18563                                  	;push	dx		; push to balance fall-through pop
 18564                                  
 18565                                  ; note fall through if exec returns (an error)
 18566                                  comerr:
 18567                                  	; 23/10/2022
 18568                                  ;;ifdef	MULTI_CONFIG
 18569                                  	;cmp	byte [commnd4],0
 18570                                  	;je	short comerr2	; all defaults exhausted, print err msg
 18571                                  	;cmp	byte [newcmd],0
 18572                                  	;je	short continue	; don't print err msg for defaults just yet
 18573                                  ;comerr2:
 18574                                  ;;endif
 18575 00000847 BA[1938]                        mov     dx,badcom	; want to print command error
 18576 0000084A E8022B                  	call	badfil
 18577                                  continue:
 18578                                  	; 23/10/2022
 18579                                  	;pop	dx
 18580                                  
 18581                                  ;;ifndef MULTI_CONFIG
 18582                                  	;jmp	stall
 18583                                  	; 24/10/2022
 18584                                  stall:		; (MSDOS 5.0 IO.SYS, SYSINIT:0899h)
 18585 0000084D EBFE                    	jmp	short stall
 18586                                  ;;else
 18587                                  	; 23/10/2022
 18588                                  	;mov	ah,GET_DEFAULT_DRIVE ; 19h
 18589                                  	;int	21h             ;
 18590                                  	;add	al,'A'          ;
 18591                                  	;mov	dl,al           ; DL == default drive letter
 18592                                  	;mov	si,commnd2
 18593                                  	;cmp	byte [newcmd],0 ; if a SHELL= was given
 18594                                  	;jne	short do_def2	; then try the 2nd alternate;
 18595                                  	;mov	byte [si],0	; otherwise, the default SHELL= was tried,
 18596                                  	;jmp	short do_def3   ; which is the same as our 2nd alt, so skip it
 18597                                  ;do_def2:			
 18598                                  	;cmp	byte [si],0	; has 2nd alternate been tried?
 18599                                          ;jne	short do_alt    ; no
 18600                                  ;do_def3:
 18601                                  	;mov	si,commnd3
 18602                                  	;cmp	byte [si],0	; has 3rd alternate been tried?
 18603                                  	;jne	short do_alt	; no
 18604                                  	;mov	si,commnd4
 18605                                  	;cmp	byte [si],0	; has 4th alternate been tried?
 18606                                  	;jne	short do_alt	; no
 18607                                  	;push	dx              ;
 18608                                  	;mov	dx,badcomprmpt
 18609                                  	;call	print		;
 18610                                  	;pop	dx              ; recover default drive letter in DL
 18611                                  ;request_input:			;
 18612                                  	;mov	ah,STD_CON_OUTPUT
 18613                                  	;int	21h             ;
 18614                                  	;push	dx              ;
 18615                                  	;mov	dl,'>'          ;
 18616                                  	;int	21h             ;
 18617                                  	;mov	bl,[tmplate+1]	;
 18618                                  	;mov	bh,0            ;
 18619                                  	;mov	byte [commnd+bx],0Dh
 18620                                  	;mov	dx,tmplate
 18621                                  	;mov	ah,STD_CON_STRING_INPUT
 18622                                  	;int	21h             ; read a line of input
 18623                                  	;mov	dx,crlfm	;
 18624                                  	;call	print           ;
 18625                                  	;pop	dx              ;
 18626                                  	;mov	bl,[tmplate+1]	;
 18627                                  	;or	bl,bl           ; was anything typed?
 18628                                  	;jz	short request_input ;
 18629                                  	;mov	byte [newcmd],1 ; disable validation for user-specified binaries
 18630                                  	;mov	byte [commnd+bx],0 ; NULL-terminate it before execing it
 18631                                  	;mov	word [command_line],0D00h
 18632                                  	;jmp	short do_exec   ;
 18633                                  ;do_alt:
 18634                                  	;push	ds
 18635                                  	;pop	es
 18636                                  	;mov	byte [newcmd],0 ; force validation for alternate binaries
 18637                                  	;mov	di,commnd	;
 18638                                  ;do_alt1:
 18639                                  	;lodsb			; copy the alternate, zapping it as we go,
 18640                                  	;mov	byte [si-1],0	; so that we know it's been tried
 18641                                  	;stosb 			;
 18642                                  	;or	al,al		;
 18643                                  	;jnz	short do_alt1	;
 18644                                  	;mov	di,command_line
 18645                                  	;cmp	byte [si+2],':'
 18646                                  	;jne	short do_alt2	;
 18647                                  	;mov	[si+1],dl	; stuff default drive into alt. command line
 18648                                  ;do_alt2:			;
 18649                                  	;lodsb			;
 18650                                  	;stosb			;
 18651                                  	;or	al,al           ;
 18652                                  	;jnz	short do_alt2   ;
 18653                                  	;mov	byte [di-1],cr
 18654                                  
 18655                                  ;;   Last but not least, see if we need to call disable_autoexec
 18656                                  
 18657                                  	; MSDOS 6.0 (SYSINIT1.ASM)
 18658                                  	;;cmp	[command_line-1],0
 18659                                          ;;jne	short do_exec   ;
 18660                                          ;;mov	[command_line-1],'/'
 18661                                  	;;call	disable_autoexec ;
 18662                                  
 18663                                  	; MSDOS 6.21 IO.SYS (SYSINIT:0994h)
 18664                                  	;mov	byte [dae_flag],0 ; 24/03/2019 - Retro DOS v4.0 	
 18665                                  	;call	disable_autoexec
 18666                                  	;call	CheckQueryOpt	; 24/03/2019 - Retro DOS v4.0
 18667                                  ;do_exec:
 18668                                  	;jmp     retry		;
 18669                                  
 18670                                  ;;endif	;MULTI_CONFIG
 18671                                  
 18672                                  ; 24/03/2019 - Retro DOS v4.0
 18673                                  
 18674                                  ; ----------------------------------------------------------------------
 18675                                  ; procedure : AllocFreeMem
 18676                                  ;
 18677                                  ; Allocate Max memory from DOS to find out where to load DOS.
 18678                                  ; DOS is at temporary location when this call is being made
 18679                                  ;
 18680                                  ; Inputs : None
 18681                                  ; Outputs: The biggest chunk of memory is allocated (all mem at init time)
 18682                                  ;	   [area] & [memhi] set to the para value of the start of the
 18683                                  ;	   free memory.
 18684                                  ;
 18685                                  ; Uses   : AX, BX
 18686                                  ;
 18687                                  ; ----------------------------------------------------------------------
 18688                                  
 18689                                  	; 23/10/2022
 18690                                  AllocFreeMem:
 18691 0000084F BBFFFF                  	mov	bx,0FFFFh
 18692 00000852 B448                    	mov	ah,48h ; ALLOC
 18693 00000854 CD21                    	int	21h			; first time fails
 18694 00000856 B448                    	mov	ah,48h ; ALLOC
 18695 00000858 CD21                    	int	21h			; second time gets it
 18696                                  	; 11/12/2022
 18697                                  	; ds = cs
 18698                                  	;mov	[cs:area],ax
 18699                                  	;mov	[cs:memhi],ax		; memhi:memlo now points to
 18700 0000085A A3[E403]                	mov	[area],ax
 18701 0000085D A3[E003]                	mov	[memhi],ax		; memhi:memlo now points to			
 18702 00000860 C3                      	retn				; start of free memory
 18703                                  				
 18704                                  	; include msbio.cl6
 18705                                  ; ----------------------------------------------------------------------
 18706                                  DOSLOMSG:
 18707 00000861 484D41206E6F742061-     	db	'HMA not available: Loading DOS low',0Dh,0Ah,'$'
 18707 0000086A 7661696C61626C653A-
 18707 00000873 204C6F6164696E6720-
 18707 0000087C 444F53206C6F770D0A-
 18707 00000885 24                 
 18708                                  FEmsg:
 18709 00000886 466174616C20457272-     	db	'Fatal Error: Cannot allocate Memory for DOS',0Dh,0Ah,'$'
 18709 0000088F 6F723A2043616E6E6F-
 18709 00000898 7420616C6C6F636174-
 18709 000008A1 65204D656D6F727920-
 18709 000008AA 666F7220444F530D0A-
 18709 000008B3 24                 
 18710                                  
 18711                                  ; ----------------------------------------------------------------------
 18712                                  ;
 18713                                  ; procedure : LoadDOSHiOrLo
 18714                                  ;
 18715                                  ;		Tries to move DOS into HMA. If it fails then loads
 18716                                  ;		DOS into Low memory. For ROMDOS, nothing is actually
 18717                                  ;		moved; this just tries to allocate the HMA, and prints
 18718                                  ;		a message if this is not possible.
 18719                                  ;
 18720                                  ; ----------------------------------------------------------------------
 18721                                  
 18722                                  	; 23/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 18723                                  LoadDOSHiOrLo:
 18724                                  	; 27/03/2019 - Retro DOS v4.0
 18725                                  	; ds = cs
 18726 000008B4 E81F00                  	call	TryToMovDOSHi		; Try moving it into HMA (M024)
 18727                                  	;jc	short LdngLo		; If that don't work...
 18728                                  	;retn
 18729                                  	; 18/12/2022
 18730 000008B7 731C                    	jnc	short LoadDosHi_ok
 18731                                  LdngLo:
 18732                                  	; 23/10/2022
 18733                                  	;push	cs
 18734                                  	;pop	ds
 18735                                  	; 11/12/2022
 18736                                  	; ds = cs
 18737 000008B9 B409                    	mov	ah,9
 18738 000008BB BA[6108]                	mov	dx,DOSLOMSG		; inform user that we are
 18739 000008BE CD21                    	int	21h			; loading low
 18740                                  
 18741                                  ;ifndef ROMDOS
 18742                                  	; actually move the dos, and reinitialize it.
 18743                                  
 18744 000008C0 BB0100                  	mov	bx,1				; M012
 18745                                  						;  use int 21 alloc for mem
 18746 000008C3 E83F00                  	call	MovDOSLo
 18747                                  	; 11/12/2022
 18748                                  	; ds = cs
 18749                                  	;mov	es,[cs:CURRENT_DOS_LOCATION]	; give dos its temporary loc.
 18750                                  	; 23/10/2022
 18751 000008C6 8E06[7102]              	mov	es,[CURRENT_DOS_LOCATION]
 18752                                  	;;mov	es,[cs:FINAL_DOS_LOCATION]  ; 24/03/2019 - Retro DOS v4.0
 18753                                  	;mov	es,[FINAL_DOS_LOCATION] ; 27/03/2019
 18754 000008CA 31C0                    	xor	ax,ax				; ax = 00 ---> install stub
 18755                                  	; 11/12/2022
 18756                                  	; ds = cs
 18757                                  	;call	far [cs:dos_segreinit]		; call dos segreinit
 18758 000008CC FF1E[7B02]              	call	far [dos_segreinit] ; 27/03/2019
 18759                                  	
 18760                                  ;endif ; ROMDOS
 18761                                  	; 23/10/2022
 18762                                  	;mov	byte [cs:runhigh],0		; mark that we are running lo
 18763                                  	; 11/12/2022
 18764                                  	; ds = cs
 18765 000008D0 C606[6A02]00            	mov	byte [runhigh],0 ; 27/03/2019
 18766                                  LoadDosHi_ok:	; 18/12/2022
 18767 000008D5 C3                      	retn
 18768                                  
 18769                                  ; ----------------------------------------------------------------------
 18770                                  ;
 18771                                  ; procedure : TryToMovDOSHi
 18772                                  ;
 18773                                  ;		This tries to move DOS into HMA.
 18774                                  ;		Returns CY if it failed.
 18775                                  ;		If it succeeds returns with carry cleared.
 18776                                  ;
 18777                                  ;		For ROMDOS, dos_segreinit must be called again to allow
 18778                                  ;		the A20 switching code in the low mem stub to be installed.
 18779                                  ; 
 18780                                  ; ----------------------------------------------------------------------
 18781                                  
 18782                                  	; 23/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 18783                                  	; (MSDOS 5.0 IO.SYS - SYSINIT:092Ah)
 18784                                  TryToMovDOSHi:
 18785                                  	; 11/12/2022
 18786                                  	; 27/03/2019 - Retro DOS v4.0
 18787                                  	; ds = cs
 18788 000008D6 E81300                  	call	MovDOSHi
 18789 000008D9 7210                    	jc	short ttldhx
 18790                                  
 18791                                  ;ifndef ROMDOS
 18792                                  	; 23/10/2022
 18793                                  	;mov	es,[cs:CURRENT_DOS_LOCATION] ; give dos its temporary loc.
 18794                                  	;;mov	es,[cs:FINAL_DOS_LOCATION] ; 24/03/2019 - Retro DOS v4.0
 18795                                  	; 11/12/2022
 18796                                  	; ds = cs
 18797 000008DB 8E06[7102]              	mov	es,[CURRENT_DOS_LOCATION]
 18798                                  ;else
 18799                                  ;	..
 18800                                  ;endif ; ROMDOS
 18801                                  
 18802                                  	; 11/12/2022
 18803                                  	; ds = cs
 18804 000008DF 31C0                    	xor	ax,ax			; ax = 00 ---> install stub
 18805                                  	;call	far [cs:dos_segreinit]	; call dos segreinit
 18806 000008E1 FF1E[7B02]              	call	far [dos_segreinit]
 18807                                  	;mov	byte [cs:runhigh],1
 18808 000008E5 C606[6A02]01            	mov	byte [runhigh],1
 18809 000008EA F8                      	clc
 18810                                  ttldhx:
 18811 000008EB C3                      	retn
 18812                                  
 18813                                  ; ----------------------------------------------------------------------
 18814                                  ;
 18815                                  ; procedure : MovDOSHi
 18816                                  ;
 18817                                  ;		Tries to allocate HMA and Move DOS/BIOS code into HMA
 18818                                  ;		For ROMDOS, the code is not actually moved, but the
 18819                                  ;		HMA is allocated and prepared for sub-allocation.
 18820                                  ;
 18821                                  ;		Returns : CY if it failed
 18822                                  ;
 18823                                  ; ----------------------------------------------------------------------
 18824                                  
 18825                                  	; 23/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 18826                                  MovDOSHi:
 18827                                  	; 14/05/2019
 18828                                  	; 27/03/2019 - Retro DOS v4.0
 18829                                  	; ds = cs
 18830 000008EC E8D700                  	call	AllocHMA
 18831 000008EF 7213                    	jc	short mdhx			; did we get HMA?
 18832 000008F1 B8FFFF                  	mov	ax,0FFFFh			; yes, HMA seg = 0ffffh
 18833 000008F4 8EC0                    	mov	es,ax
 18834                                  
 18835                                  ;ifndef ROMDOS
 18836                                  	; actually move the BIOS and DOS
 18837                                  
 18838                                  	; NOTE: Retro DOS v4.0 does not move BIOS (IO.SYS) to HMA
 18839                                  	; 24/03/2019
 18840                                  	
 18841                                  	; 23/10/2022
 18842 000008F6 E83400                  	call	MovBIOS				; First move BIOS into HMA
 18843                                  
 18844                                  	; ES:DI points to free HMA after BIOS
 18845                                  	
 18846                                  	; 14/05/2019
 18847                                  	; 24/03/2019 - Retro DOS v4.0
 18848                                  	;xor	di,di
 18849                                  	
 18850                                  	; 23/10/2022
 18851                                  	;mov	cx,[cs:hi_doscod_size]		; pass the code size of DOS
 18852                                  	; 11/12/2022
 18853                                  	; ds = cs
 18854 000008F9 8B0E[8102]              	mov	cx,[hi_doscod_size]		; when it is in HMA
 18855 000008FD E81100                  	call	MovDOS				; and move it
 18856                                  
 18857                                  	; ES:DI points to free HMA after DOS
 18858                                  ;else
 18859                                  ;	; allocate space at beginning of HMA to allow for CPMHack
 18860                                  ;
 18861                                  ;	mov	di,0E0h				; room for 5 bytes at ffff:d0
 18862                                  ;
 18863                                  ;endif ; ROMDOS
 18864                                  
 18865 00000900 E86102                  	call	SaveFreeHMAPtr			; Save the Free HMA ptr
 18866 00000903 F8                      	clc
 18867                                  mdhx:
 18868 00000904 C3                      	retn
 18869                                  
 18870                                  ; ----------------------------------------------------------------------
 18871                                  ;
 18872                                  ; procedure : MovDOSLo
 18873                                  ;
 18874                                  ;		Allocates memory from DOS and moves BIOS/DOS code into it
 18875                                  ;
 18876                                  ; ----------------------------------------------------------------------
 18877                                  
 18878                                  	; 23/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 18879                                  
 18880                                  ;ifndef ROMDOS
 18881                                  
 18882                                  MovDOSLo:
 18883                                  	; 14/05/2019
 18884                                  	; 27/03/2019 - Retro DOS v4.0
 18885                                  	; ds = cs
 18886 00000905 E84700                  	call	AllocMemForDOS			; incestuosly!!!
 18887                                  	
 18888                                  	; 23/10/2022
 18889                                  	; 14/05/2019
 18890                                  	;inc	ax  ; skip MCB
 18891                                  	
 18892 00000908 8EC0                    	mov	es,ax				; pass the segment to MovBIOS
 18893                                  	; NOTE: Retro DOS v4.0 does not move BIOS (IO.SYS) to HMA
 18894                                  	; 24/03/2019
 18895                                  	
 18896                                  	; 23/10/2022
 18897 0000090A E82000                  	call	MovBIOS
 18898                                  
 18899                                  ;------ ES:DI points memory immediately after BIOS
 18900                                  
 18901                                  	; 14/05/2019
 18902                                  	; NOTE: 
 18903                                  	;     Order of (RETRO) DOS kernel sections at memory:
 18904                                  	;	BIOSDATA+BIOSCODE+BIOSDATAINIT+DOSDATA+DOSCODE(LOW)
 18905                                  
 18906                                  	; 24/03/2019 - Retro DOS v4.0
 18907                                  	;xor	di,di	
 18908                                  
 18909                                  	; 23/10/2022
 18910                                  	;mov	cx,[cs:lo_doscod_size]		; DOS code size when loaded
 18911                                  	; 11/12/2022
 18912                                  	; ds = cs
 18913 0000090D 8B0E[7F02]              	mov	cx,[lo_doscod_size]		; low
 18914                                  	;call	MovDOS
 18915                                  	;retn
 18916                                  	; 11/12/2022
 18917                                  	;jmp	short MovDOS
 18918                                  
 18919                                  ;endif ; ROMDOS
 18920                                  
 18921                                  ; 11/12/2022
 18922                                  
 18923                                  ; ----------------------------------------------------------------------
 18924                                  ;
 18925                                  ; procedure : MovDOS
 18926                                  ;
 18927                                  ;		Moves DOS code into requested area
 18928                                  ;
 18929                                  ;	In : ES:DI - pointer to memory where DOS is to be moved
 18930                                  ;	     CX    - size of DOS code to be moved
 18931                                  ;
 18932                                  ;	Out : ES:DI - pointer to memory immediately after DOS
 18933                                  ;
 18934                                  ; ----------------------------------------------------------------------
 18935                                  
 18936                                  	; 11/12/2022
 18937                                  	; 23/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 18938                                  
 18939                                  ;ifndef ROMDOS
 18940                                  
 18941                                  MovDOS:
 18942                                  	; 14/05/2019
 18943                                  	; 27/03/2019 - Retro DOS v4.0
 18944                                  
 18945                                  	; 11/12/2022
 18946                                  	; ds = cs
 18947                                  
 18948                                  	; 23/10/2022
 18949                                  	;push	ds ; *//
 18950                                  	
 18951 00000911 06                      	push	es
 18952 00000912 57                      	push	di
 18953                                  
 18954                                  	; 11/12/2022
 18955 00000913 1E                      	push	ds ; *// ; 11/12/202
 18956                                  
 18957                                  	; 29/04/2019
 18958 00000914 C536[6F02]              	lds	si,[dosinit] ; 11/12/2022
 18959                                  	; 23/10/2022
 18960                                  	;lds	si,[cs:dosinit]
 18961                                  	;;mov	ax,si
 18962                                  
 18963 00000918 F3A4                    	rep	movsb
 18964                                  
 18965 0000091A 1F                      	pop	ds ; *// ; 11/12/2022
 18966                                  
 18967 0000091B 5B                      	pop	bx				; get back offset into which
 18968                                  						;  DOS was moved
 18969                                  
 18970 0000091C 2EA1[6F02]              	mov	ax,[cs:dosinit]			; get the offset at which DOS
 18971                                  						;  wants to run
 18972 00000920 29D8                    	sub	ax,bx
 18973 00000922 E8A102                  	call	off_to_para
 18974 00000925 5B                      	pop	bx				; get the segment at which
 18975                                  						;  we moved DOS into
 18976 00000926 29C3                    	sub	bx,ax				; Adjust segment
 18977                                  	
 18978                                  	; 11/12/2022
 18979                                  	; 23/10/2022
 18980                                  	;mov	[cs:CURRENT_DOS_LOCATION],bx	; and save it
 18981                                  	;;mov	[cs:FINAL_DOS_LOCATION],bx
 18982                                  	; 11/12/2022
 18983 00000928 891E[7102]              	mov	[CURRENT_DOS_LOCATION],bx
 18984                                  		
 18985                                  	; 27/03/2019
 18986                                  	;pop	ds ; *//
 18987                                  	; ds = cs
 18988                                  	;mov	[FINAL_DOS_LOCATION],bx
 18989                                  
 18990 0000092C C3                      	retn
 18991                                  
 18992                                  ;endif ;ROMDOS
 18993                                  
 18994                                  ; NOTE: Retro DOS v4.0 does not move BIOS (IO.SYS) to HMA
 18995                                  ; 24/03/2019
 18996                                  ; ----------------------------------------------------------------------
 18997                                  ;
 18998                                  ; procedure : MovBIOS
 18999                                  ;
 19000                                  ;		Moves BIOS code into requested segment
 19001                                  ;
 19002                                  ;	In : ES - segment to which BIOS is to be moved
 19003                                  ;		  ( it moves always into offset BCode_Start)
 19004                                  ;
 19005                                  ;	Out : ES:DI - pointer to memory immediately after BIOS
 19006                                  ;
 19007                                  ; ----------------------------------------------------------------------
 19008                                  
 19009                                  	; 23/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 19010                                  
 19011                                  ;ifndef ROMDOS
 19012                                  
 19013                                  MovBIOS: ; proc	near
 19014                                  	; 11/12/2022
 19015 0000092D 1E                      	push	ds ; ds = cs	
 19016                                  	;
 19017                                  	; 23/10/2022
 19018                                  	;mov	ds,[cs:temp_bcode_seg]		; current BIOS code seg
 19019                                  	; 17/09/2023
 19020 0000092E 8E1E[8702]              	mov	ds,[temp_bcode_seg]
 19021                                  	;mov	si,BCODE_START ; mov si,30h
 19022                                  	; 09/12/2022
 19023 00000932 BE[3000]                	mov	si,BCODESTART
 19024 00000935 89F7                    	mov	di,si
 19025 00000937 B9001A                  	mov	cx,BCODE_END ; mov cx,1A60h
 19026 0000093A 29F1                    	sub	cx,si				; size of BIOS
 19027 0000093C D1E9                    	shr	cx,1				; Both the labels are para
 19028                                  						;  aligned
 19029 0000093E F3A5                    	rep	movsw
 19030                                  	
 19031                                  	; 11/12/2022
 19032 00000940 1F                      	pop	ds ; ds = cs
 19033                                  	;
 19034 00000941 06                      	push	es
 19035 00000942 57                      	push	di				; save end of BIOS
 19036 00000943 8CC0                    	mov	ax,es
 19037                                  	;
 19038                                  	; 11/12/2022
 19039                                  	;mov	[cs:BCodeSeg],ax		; save it for later use
 19040                                  	;;call	dword ptr cs:_seg_reinit_ptr
 19041                                  	;call	far [cs:seg_reinit_ptr]		; far call to seg_reinit (M022)
 19042                                  	; ds = cs
 19043 00000945 A3[0004]                	mov	[BCodeSeg],ax
 19044 00000948 FF1E[8502]              	call	far [seg_reinit_ptr]
 19045                                  	;
 19046 0000094C 5F                      	pop	di
 19047 0000094D 07                      	pop	es				; get back end of BIOS
 19048 0000094E C3                      	retn
 19049                                  
 19050                                  ;MovBIOS endp
 19051                                  
 19052                                  ;endif ; ROMDOS
 19053                                  
 19054                                  ; 11/12/2022
 19055                                  %if 0
 19056                                  
 19057                                  ; 24/03/2019
 19058                                  
 19059                                  ; ----------------------------------------------------------------------
 19060                                  ;
 19061                                  ; procedure : MovDOS
 19062                                  ;
 19063                                  ;		Moves DOS code into requested area
 19064                                  ;
 19065                                  ;	In : ES:DI - pointer to memory where DOS is to be moved
 19066                                  ;	     CX    - size of DOS code to be moved
 19067                                  ;
 19068                                  ;	Out : ES:DI - pointer to memory immediately after DOS
 19069                                  ;
 19070                                  ; ----------------------------------------------------------------------
 19071                                  
 19072                                  	; 23/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 19073                                  
 19074                                  ;ifndef ROMDOS
 19075                                  
 19076                                  MovDOS:
 19077                                  	; 14/05/2019
 19078                                  	; 27/03/2019 - Retro DOS v4.0
 19079                                  
 19080                                  	; 11/12/2022
 19081                                  	; ds = cs
 19082                                  
 19083                                  	; 23/10/2022
 19084                                  	;push	ds ; *//
 19085                                  	
 19086                                  	push	es
 19087                                  	push	di
 19088                                  
 19089                                  	; 11/12/2022
 19090                                  	push	ds ; *// ; 11/12/202
 19091                                  
 19092                                  	; 29/04/2019
 19093                                  	lds	si,[dosinit] ; 11/12/2022
 19094                                  	; 23/10/2022
 19095                                  	;lds	si,[cs:dosinit]
 19096                                  	;;mov	ax,si
 19097                                  
 19098                                  	rep	movsb
 19099                                  
 19100                                  	pop	ds ; *// ; 11/12/2022
 19101                                  
 19102                                  	pop	bx				; get back offset into which
 19103                                  						;  DOS was moved
 19104                                  
 19105                                  	mov	ax,[cs:dosinit]			; get the offset at which DOS
 19106                                  						;  wants to run
 19107                                  	sub	ax,bx
 19108                                  	call	off_to_para
 19109                                  	pop	bx				; get the segment at which
 19110                                  						;  we moved DOS into
 19111                                  	sub	bx,ax				; Adjust segment
 19112                                  	
 19113                                  	; 11/12/2022
 19114                                  	; 23/10/2022
 19115                                  	;mov	[cs:CURRENT_DOS_LOCATION],bx	; and save it
 19116                                  	;;mov	[cs:FINAL_DOS_LOCATION],bx
 19117                                  	; 11/12/2022
 19118                                  	mov	[CURRENT_DOS_LOCATION],bx
 19119                                  		
 19120                                  	; 27/03/2019
 19121                                  	;pop	ds ; *//
 19122                                  	; ds = cs
 19123                                  	;mov	[FINAL_DOS_LOCATION],bx
 19124                                  
 19125                                  	retn
 19126                                  
 19127                                  ;endif ;ROMDOS
 19128                                  
 19129                                  %endif
 19130                                  
 19131                                  ; ----------------------------------------------------------------------
 19132                                  ;
 19133                                  ; procedure : AllocMemForDOS
 19134                                  ;
 19135                                  ;		Allocate memory for DOS/BIOS code from DOS !!!
 19136                                  ;
 19137                                  ;	Out : AX - seg of allocated memoryblock
 19138                                  ;
 19139                                  ; ----------------------------------------------------------------------
 19140                                  
 19141                                  	; 23/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 19142                                  
 19143                                  ;ifndef ROMDOS
 19144                                  
 19145                                  AllocMemForDOS:
 19146                                  	; 11/12/2022
 19147                                  	; 14/05/2019
 19148                                  	; 27/03/2019 - Retro DOS v4.0
 19149                                  	; ds = cs
 19150                                  	;mov	ax,BCode_end
 19151                                  	;sub	ax,BCode_start		; BIOS code size
 19152                                  	; 23/10/2022
 19153 0000094F B8001A                  	mov	ax,BCODE_END ; 1A60h
 19154                                  	;sub	ax,BCODE_START ; 30h
 19155                                  	; 09/12/2022
 19156 00000952 2D[3000]                	sub	ax,BCODESTART 
 19157                                  	; 24/03/2019 - Retro DOS v4.0 
 19158                                  	; 02/11/2022
 19159                                  	;add	ax,[cs:lo_doscod_size]	; DOS code size
 19160                                  	; 11/12/2022
 19161                                  	; ds = cs
 19162 00000955 0306[7F02]              	add	ax,[lo_doscod_size]
 19163 00000959 83C00F                  	add	ax,15
 19164 0000095C E86702                  	call	off_to_para			; convert to para
 19165                                  	; 23/10/2022
 19166                                  	; 14/05/2019
 19167                                  	;inc	ax ; + 1 paragraph for MCB
 19168 0000095F 09DB                    	or	bx,bx				; M012
 19169 00000961 89C3                    	mov	bx,ax				;  can we use int 21 for alloc
 19170 00000963 741A                    	jz	short update_arena		; M012
 19171 00000965 B448                    	mov	ah,48h				; request DOS
 19172 00000967 CD21                    	int	21h
 19173 00000969 7250                    	jc	short FatalErr			; IF ERR WE ARE HOSED
 19174                                   	; 23/10/2022
 19175                                  	; 24/03/2019 - Retro DOS v4.0 (ORG 0)
 19176 0000096B 83E803                  	sub	ax,3				; Take care ORG 30h of
 19177                                  						;  BIOS code
 19178 0000096E 8EC0                    	mov	es,ax
 19179                                  	;mov	word [es:20h+ARENA.OWNER],08h	; mark it as system
 19180                                  	;mov	word [es:20h+ARENA.NAME],'SC'	;  code area
 19181                                  	; 14/05/2019
 19182                                  	;mov	word [es:ARENA.OWNER],08h	; mark it as system
 19183                                  	;mov	word [es:ARENA.NAME],'SC'	;  code area
 19184                                  	; 23/10/2022
 19185 00000970 26C70621000800          	mov	word [es:20h+1],08h		; mark it as system
 19186 00000977 26C70628005343          	mov	word [es:20h+8],'SC'		;  code area
 19187                                  
 19188 0000097E C3                      	retn
 19189                                  
 19190                                  ; BUGBUG -- 5 Aug 92 -- chuckst -- Allocating space for DOS
 19191                                  ;	  using DOS itself causes an arena to be generated.
 19192                                  ;	  Unfortunately, certain programs (like PROTMAN$)
 19193                                  ;	  assume that the device drivers are loaded into
 19194                                  ;	  the first arena. For this reason, MagicDrv's
 19195                                  ;	  main device driver header arena is manually
 19196                                  ;	  truncated from the arena chain, and the space
 19197                                  ;	  for DOS is allocated using the following
 19198                                  ;	  simple code, which also assumes that the
 19199                                  ;	  first arena is the free one where DOS's low
 19200                                  ;	  stub will go.
 19201                                  ;
 19202                                  ; M012 : BEGIN
 19203                                  
 19204                                  	; 23/10/2022
 19205                                  update_arena:
 19206 0000097F 1E                      	push	ds ; ds = cs
 19207 00000980 57                      	push	di
 19208 00000981 51                      	push	cx
 19209 00000982 52                      	push	dx
 19210                                  	; 23/10/2022
 19211                                  	;lds	di,[cs:DOSINFO]			; get ptr to DOS var
 19212                                  	; 11/12/2022
 19213                                  	; ds = cs 
 19214 00000983 C53E[6B02]              	lds	di,[DOSINFO] ; 27/03/2019	
 19215 00000987 4F                      	dec	di
 19216 00000988 4F                      	dec	di				; Arena head is immediately
 19217                                  						;  before sysvar
 19218 00000989 8E05                    	mov	es,[di]				; es = arena head
 19219                                  	;mov	cx,[es:ARENA.SIZE]		; cx = total low mem size
 19220 0000098B 268B0E0300              	mov	cx,[es:3]
 19221 00000990 39D9                    	cmp	cx,bx				; is it sufficient ?
 19222 00000992 7227                    	jb	short FatalErr			; no, fatal error
 19223                                  
 19224                                  	;mov	dl,[es:ARENA.SIGNATURE]
 19225 00000994 268A160000              	mov	dl,[es:0]
 19226 00000999 8CC0                    	mov	ax,es
 19227 0000099B 01D8                    	add	ax,bx				; ax = new arena head
 19228 0000099D 8905                    	mov	[di],ax				; store it in DOS data area
 19229 0000099F 8ED8                    	mov	ds,ax
 19230                                  	;mov	[ARENA.SIGNATURE],dl		; type of arena
 19231 000009A1 88160000                	mov	[0],dl
 19232                                  	;mov	word [ARENA.OWNER],0		; free
 19233 000009A5 C70601000000            	mov	word [1],0
 19234 000009AB 29D9                    	sub	cx,bx				; size of the new block
 19235                                  	;mov	[ARENA.SIZE],cx			; store it in the arena
 19236 000009AD 890E0300                	mov	[3],cx
 19237 000009B1 8CC0                    	mov	ax,es				; return seg to the caller
 19238                                  	; 23/10/2022
 19239                                  	;; 24/03/2019 - Retro DOS v4.0 (ORG 0)	; Take care ORG 30h of
 19240 000009B3 83E803                  	sub	ax,3				;  BIOS code
 19241 000009B6 5A                      	pop	dx
 19242 000009B7 59                      	pop	cx
 19243 000009B8 5F                      	pop	di
 19244 000009B9 1F                      	pop	ds ; ds = cs
 19245 000009BA C3                      	retn
 19246                                  ;
 19247                                  ; M012 : END
 19248                                  ;
 19249                                  FatalErr:
 19250 000009BB 0E                      	push	cs
 19251 000009BC 1F                      	pop	ds
 19252 000009BD BA[8608]                	mov	dx,FEmsg
 19253 000009C0 B409                    	mov	ah,9
 19254 000009C2 CD21                    	int	21h 		; DOS - PRINT STRING
 19255                                  				; DS:DX -> string terminated by "$"
 19256                                          ;jmp	stall
 19257                                  	; 23/10/2022
 19258 000009C4 FA                      	cli
 19259 000009C5 F4                      	hlt
 19260                                  
 19261                                  ;endif ;ROMDOS
 19262                                  
 19263                                  ; 25/03/2019 - Retro DOS v4.0
 19264                                  
 19265                                  ; ----------------------------------------------------------------------
 19266                                  ;
 19267                                  ; procedure : AllocHMA
 19268                                  ;
 19269                                  ;	grab_the_hma tries to enable a20 and make sure there is memory
 19270                                  ;	  up there. If it gets any sort of error, it will return with
 19271                                  ;	  carry set so that we can resort to running low.
 19272                                  ;
 19273                                  ;	It also returns ES: -> 0ffffh if it returns success
 19274                                  ;
 19275                                  ; ----------------------------------------------------------------------
 19276                                  
 19277                                  AllocHMA:
 19278                                  ;	cas note:  The pre-286 check is no longer needed here since the
 19279                                  ;		   presence of XMS is sufficient. However, this code hasn't
 19280                                  ;		   been deleted because it can be recycled for skipping the
 19281                                  ;		   extra pass of CONFIG.SYS and assuming we're running low
 19282                                  ;		   in the case of a pre-286.
 19283                                  
 19284                                  ;;	see if we're running on a pre-286. If not, force low.
 19285                                  ;
 19286                                  ;	xor	ax,ax
 19287                                  ;	pushf			; save flags (like int)
 19288                                  ;	push	ax
 19289                                  ;	popf
 19290                                  ;	pushf
 19291                                  ;	pop	ax
 19292                                  ;	popf			; restore original flags (like int)
 19293                                  ;	and	ax,0F000h
 19294                                  ;	cmp	ax,0F000h	; 8088/8086?
 19295                                  ;	jz	short grab_hma_error
 19296                                  
 19297                                  	; 23/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 19298                                  	; (SYSINIT:0A26h)
 19299                                  
 19300 000009C6 1E                      	push	ds
 19301                                  	;;mov	ax,Bios_Data
 19302                                  	;mov	ax,KERNEL_SEGMENT
 19303                                  	; 21/10/2022
 19304 000009C7 B87000                  	mov	ax,DOSBIODATASEG
 19305 000009CA 8ED8                    	mov	ds,ax
 19306                                  
 19307 000009CC E84A00                  	call	IsXMSLoaded
 19308 000009CF 7545                    	jnz	short grabhma_error
 19309                                  
 19310 000009D1 B81043                  	mov	ax,4310h
 19311 000009D4 CD2F                    	int	2Fh		; get the vector into es:bx
 19312                                  		; - Multiplex - XMS - GET DRIVER ADDRESS
 19313                                  		; Return: ES:BX -> driver entry point
 19314                                  
 19315 000009D6 891E[0E00]              	mov	[xms],bx
 19316                                  	;mov	[0Eh], bx
 19317 000009DA 8C06[1000]              	mov	[xms+2],es
 19318                                  	;mov	[10h],es
 19319                                  
 19320 000009DE B401                    	mov	ah,1		; request HMA
 19321 000009E0 BAFFFF                  	mov	dx,0FFFFh
 19322                                  	;call	dword ptr ds:0Eh
 19323 000009E3 FF1E[0E00]              	call	far [xms]
 19324 000009E7 48                      	dec	ax
 19325 000009E8 7409                    	jz	short allocHMA_1 ; error if not able to allocate HMA
 19326                                  
 19327                                  ;------ Himem may be lying because it has allocated mem for int 15
 19328                                  
 19329 000009EA B488                    	mov	ah,88h
 19330 000009EC CD15                    	int	15h
 19331                                  		; Get Extended Memory Size
 19332                                  		; Return: CF clear on success
 19333                                  		; AX = size of memory above 1M in K
 19334 000009EE 83F840                  	cmp	ax,64		; less than 64 K of hma ?
 19335                                  	;jb	short grabhma_error
 19336                                  	; 11/12/2022
 19337 000009F1 7224                    	jb	short grabhma_err ; cf=1
 19338                                  allocHMA_1:
 19339 000009F3 B405                    	mov	ah,5		; localenableA20
 19340                                  	;call	dword ptr ds:0Eh
 19341 000009F5 FF1E[0E00]              	call	far [xms]
 19342 000009F9 48                      	dec	ax
 19343 000009FA 751A                    	jnz	short grabhma_error ; error if couldn't enable A20
 19344                                  
 19345 000009FC E88901                  	call	IsVDiskInstalled
 19346 000009FF 7415                    	jz	short grabhma_error ; yes, we cant use HMA
 19347                                  
 19348 00000A01 B8FFFF                  	mov	ax,0FFFFh
 19349 00000A04 8EC0                    	mov	es,ax
 19350 00000A06 26C70610003412          	mov	word [es:10h],1234h ; see if we can really read/write there
 19351 00000A0D 26813E10003412          	cmp	word [es:10h],1234h
 19352                                  	;jne	short grabhma_error ; don't try to load there if XMS lied
 19353                                  	; 11/12/2022
 19354 00000A14 7401                    	je	short allocHMA_ok	
 19355                                  
 19356                                  ; 11/12/2022
 19357                                  ;	; 11/12/2022
 19358                                  ;	; cf=0
 19359                                  ;	;clc
 19360                                  ;	pop	ds
 19361                                  ;	retn
 19362                                  
 19363                                  grabhma_error:
 19364 00000A16 F9                      	stc
 19365                                  	; 11/12/022
 19366                                  grabhma_err:	; cf=1
 19367                                  allocHMA_ok:	; cf=0
 19368 00000A17 1F                      	pop	ds
 19369 00000A18 C3                      	retn
 19370                                  
 19371                                  ; ----------------------------------------------------------------------
 19372                                  ;
 19373                                  ; procedure : IsXMSLoaded
 19374                                  ;
 19375                                  ;             Checks whether a XMS driver is loaded
 19376                                  ;
 19377                                  ; Returns : Z flag set if XMS driver loaded
 19378                                  ;           Z flag reset if no XMS drivers are present
 19379                                  ;
 19380                                  ; ----------------------------------------------------------------------
 19381                                  
 19382                                  IsXMSLoaded:
 19383 00000A19 B80043                  	mov	ax,4300h
 19384 00000A1C CD2F                    	int	2Fh		; - Multiplex - XMS - INSTALLATION CHECK
 19385                                  				; Return: AL = 80h XMS driver installed
 19386                                  				; AL <> 80h no driver
 19387 00000A1E 3C80                    	cmp	al,80h		; XMS installed?
 19388 00000A20 C3                      	retn
 19389                                  
 19390                                  ; ----------------------------------------------------------------------
 19391                                  ; procedure : FTryToMovDOSHi
 19392                                  ;
 19393                                  ;		Called from HMA suballoc calls
 19394                                  ;	
 19395                                  ; ----------------------------------------------------------------------
 19396                                  
 19397                                  	; 23/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 19398                                  	; (SYSINIT:0A84h)
 19399                                  
 19400                                  FTryToMovDOSHi:	; proc	far
 19401                                  
 19402 00000A21 50                      	push	ax
 19403 00000A22 53                      	push	bx
 19404 00000A23 51                      	push	cx
 19405 00000A24 52                      	push	dx
 19406 00000A25 56                      	push	si
 19407 00000A26 57                      	push	di
 19408 00000A27 1E                      	push	ds
 19409 00000A28 06                      	push	es
 19410                                  
 19411                                  	; 23/10/2022
 19412                                  	; 27/03/2019 - Retro DOS v4.0
 19413                                  	; 11/12/2022
 19414 00000A29 0E                      	push	cs
 19415 00000A2A 1F                      	pop	ds
 19416                                  
 19417                                  	;cmp	byte [cs:runhigh],0FFh
 19418                                  	; 11/12/2022
 19419 00000A2B 803E[6A02]FF            	cmp	byte [runhigh],0FFh
 19420 00000A30 7503                    	jne	short _ftymdh_1
 19421                                  
 19422                                  	; ds = cs
 19423 00000A32 E8A1FE                  	call	TryToMovDOSHi
 19424                                  _ftymdh_1:
 19425 00000A35 07                      	pop	es
 19426 00000A36 1F                      	pop	ds
 19427 00000A37 5F                      	pop	di
 19428 00000A38 5E                      	pop	si
 19429 00000A39 5A                      	pop	dx
 19430 00000A3A 59                      	pop	cx
 19431 00000A3B 5B                      	pop	bx
 19432 00000A3C 58                      	pop	ax
 19433                                  
 19434 00000A3D CB                      	retf
 19435                                  
 19436                                  ; ----------------------------------------------------------------------
 19437                                  ;
 19438                                  ; following piece of code will be moved into a para boundary. And the para
 19439                                  ; address posted in seg of int 19h vector. Offset of int 19h will point to
 19440                                  ; VDint19. This is to protect HMA from apps which use VDISK header method
 19441                                  ; to determine free extended memory.
 19442                                  ;
 19443                                  ; For more details read "power programming" column by Ray Duncan in the
 19444                                  ; May 30 1989 issue of PC Magazine (pp 377-388) [USING EXTENDED MEMORY,PART 1]
 19445                                  ;
 19446                                  ; ----------------------------------------------------------------------
 19447                                  
 19448                                  StartVDHead:
 19449                                  ;-------------- what follows is a dummy device driver header (not used by DOS)
 19450                                  
 19451 00000A3E 00000000                	dd	0		; link to next device driver
 19452 00000A42 0080                    	dw	8000h		; device attribute
 19453 00000A44 0000                    	dw	0		; strategy routine offset
 19454 00000A46 0000                    	dw	0		; interrupt routine offset
 19455 00000A48 01                      	db	1		; number of units
 19456                                  	;db	7 dup(0) 
 19457 00000A49 00<rep 7h>              	times	7 db 0 		; reserved area
 19458                                  VDiskSig1:
 19459 00000A50 564449534B              	db	'VDISK'
 19460                                  
 19461                                  VLEN1	equ	($-VDiskSig1)
 19462                                  
 19463 00000A55 202056332E33            	db	'  V3.3'	; vdisk label
 19464                                  	;db	15 dup (0)	; pad
 19465 00000A5B 00<rep Fh>              	times	15 db 0
 19466 00000A6A 0000                    	dw	0		; bits 0-15 of free HMA
 19467 00000A6C 11                      	db	11h		; bits 16-23 of free HMA (1M + 64K)
 19468                                  VDInt19:
 19469 00000A6D EA                      	db	0EAh		; jmp to old vector
 19470                                  OldVDInt19:
 19471 00000A6E 00000000                	dd	0		; Saved int 19 vector
 19472                                  
 19473                                  EndVDHead: ; label byte
 19474                                  
 19475                                  VDiskHMAHead:	
 19476 00000A72 000000                  	db	0,0,0		; non-bootable disk
 19477                                  VDiskSig2:
 19478 00000A75 564449534B              	db	'VDISK'
 19479                                  
 19480                                  VLEN2	equ	($-VDiskSig2)
 19481                                  
 19482 00000A7A 332E33                  	db	'3.3'		; OEM - signature
 19483 00000A7D 8000                    	dw	128		; number of bytes/sector
 19484 00000A7F 01                      	db	1		; sectors/cluster
 19485 00000A80 0100                    	dw	1		; reserved sectors
 19486 00000A82 01                      	db	1		; number of FAT copies
 19487 00000A83 4000                    	dw	64		; number of root dir entries
 19488 00000A85 0002                    	dw	512		; number of sectors
 19489 00000A87 FE                      	db	0FEh		; media descriptor
 19490 00000A88 0600                    	dw	6		; number of sectors/FAT
 19491 00000A8A 0800                    	dw	8		; sectors per track
 19492 00000A8C 0100                    	dw	1		; number of heads
 19493 00000A8E 0000                    	dw	0		; number of hidden sectors
 19494 00000A90 4004                    	dw	440h		; Start of free HMA in K (1M+64K)
 19495                                  
 19496                                  EndVDiskHMAHead: ; label byte
 19497                                  
 19498                                  ; ----------------------------------------------------------------------
 19499                                  ;
 19500                                  ; procedure : InstVDiskHeader
 19501                                  ;
 19502                                  ;             Installs the VDISK header to reserve the 64k of HMA
 19503                                  ;	      It puts a 32 byte header at 10000:0 and
 19504                                  ;	      another header at (seg of int19):0
 19505                                  ;
 19506                                  ; Inputs : None
 19507                                  ;
 19508                                  ; Outputs : None
 19509                                  ;
 19510                                  ; USES : DS,SI,AX,CX,DX
 19511                                  ;
 19512                                  ; ----------------------------------------------------------------------
 19513                                  
 19514                                  	; 23/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 19515                                  
 19516                                  InstVDiskHeader:
 19517 00000A92 31C0                    	xor	ax,ax
 19518 00000A94 8ED8                    	mov	ds,ax			; seg of int vect table
 19519                                  
 19520                                  ;-------------- save old int 19 vector
 19521                                  
 19522                                  	; 23/10/2022
 19523 00000A96 A16400                  	mov	ax,[19h*4]
 19524                                  	;mov	[OldVDInt19],ax
 19525 00000A99 2EA3[6E0A]              	mov	[cs:OldVDInt19],ax
 19526 00000A9D A16600                  	mov	ax,[19h*4+2]
 19527                                  	;mov	[OldVDInt19+2],ax
 19528 00000AA0 2EA3[700A]              	mov	[cs:OldVDInt19+2],ax
 19529                                  
 19530                                  ;-------------- calculate seg of new int 19 handler
 19531                                  
 19532 00000AA4 B448                    	mov	ah,48h			; allocate memory
 19533                                  	;mov	bx,(EndVDHead-StartVDHead+15)>>4
 19534                                  	; 23/10/2022
 19535 00000AA6 BB0400                  	mov	bx,4
 19536 00000AA9 CD21                    	int	21h
 19537                                  
 19538                                  ;	if carry, fatal hanging error!!!!!
 19539                                  
 19540 00000AAB 48                      	dec	ax			; point to arena
 19541 00000AAC 8EC0                    	mov	es,ax
 19542                                  	;mov	word [es:ARENA.OWNER],8	; owner = System
 19543 00000AAE 26C70601000800          	mov	word [es:1],8
 19544                                  	;mov	word [es:ARENA.NAME],'SC' ; System Code
 19545 00000AB5 26C70608005343          	mov	word [es:8],'SC'
 19546 00000ABC 40                      	inc	ax
 19547 00000ABD 8EC0                    	mov	es,ax			; get back to allocated memory
 19548                                  
 19549                                  ;-------------- install new int 19 vector
 19550                                  
 19551 00000ABF FA                      	cli				; no reboots at this time
 19552                                  	;mov	word [19h*4],(VDInt19-StartVDHead)
 19553 00000AC0 C70664002F00            	mov	word [19h*4],47
 19554 00000AC6 A36600                  	mov	[19h*4+2],ax
 19555                                  
 19556                                  ;-------------- move the code into proper place
 19557                                  
 19558                                  	;mov	cx,(EndVDHead-StartVDHead)
 19559 00000AC9 B93400                  	mov	cx,52
 19560 00000ACC BE[3E0A]                	mov	si,StartVDHead
 19561 00000ACF 31FF                    	xor	di,di
 19562 00000AD1 0E                      	push	cs
 19563 00000AD2 1F                      	pop	ds
 19564 00000AD3 FC                      	cld
 19565 00000AD4 F3A4                    	rep	movsb
 19566 00000AD6 FB                      	sti				; BUGBUG is sti OK now?
 19567                                  
 19568                                  ;-------------- mov the HMA VDisk head into HMA
 19569                                  
 19570                                  	; 23/10/2022
 19571 00000AD7 57                      	push	di
 19572 00000AD8 06                      	push	es
 19573                                  
 19574 00000AD9 B8FFFF                  	mov	ax,0FFFFh
 19575 00000ADC 8EC0                    	mov	es,ax
 19576 00000ADE BF1000                  	mov	di,10h
 19577                                  	;mov	cx,(EndVDiskHMAHead-VDiskHMAHead)
 19578 00000AE1 B92000                  	mov	cx,32
 19579 00000AE4 BE[720A]                	mov	si,VDiskHMAHead
 19580 00000AE7 F3A4                    	rep	movsb			; ds already set to cs
 19581                                  
 19582 00000AE9 5F                      	pop	di
 19583 00000AEA 07                      	pop	es
 19584                                  
 19585 00000AEB C3                      	retn
 19586                                  
 19587                                  ; ----------------------------------------------------------------------
 19588                                  ; procedure : ClrVDISKHeader
 19589                                  ;
 19590                                  ;		Clears the first 32 bytes at 1MB boundary
 19591                                  ;		So that DOS/HIMEM is not confused about the VDISK header
 19592                                  ;		left by previous DOS=HIGH session
 19593                                  ;
 19594                                  ; ----------------------------------------------------------------------
 19595                                  
 19596                                  struc desc
 19597 00000000 ????                     .seg_lim:	resw	1		; seg limit 64K 
 19598 00000002 ????                     .lo_word:	resw	1		; 24 bit seg physical 
 19599 00000004 ??                       .hi_byte:	resb 	1		; address
 19600 00000005 ??                       .acc_rights:	resb	1		; access rights ( CPL0 - R/W )
 19601 00000006 ????                     .reserved:	resw	1		;
 19602                                   .size:
 19603                                  endstruc
 19604                                  
 19605                                  		; 23/10/2022
 19606                                  bmove:		;label byte
 19607                                  
 19608                                  dummy:		;times desc.size db 0	; desc	<>
 19609 00000AEC 00<rep 8h>              		times 8 db 0		 
 19610                                  gdt:		;times desc.size db 0	; desc	<>
 19611 00000AF4 00<rep 8h>              		times 8 db 0
 19612 00000AFC FFFF                    src_desc:	dw	0FFFFh		; desc	<0ffffh,0,0,93h,0>
 19613 00000AFE 0000                    		dw	0
 19614 00000B00 00                      		db	0
 19615 00000B01 93                      		db	93h
 19616 00000B02 0000                    		dw	0
 19617 00000B04 FFFF                    tgt_desc:	dw	0FFFFh		; desc	<0ffffh,0,10h,93h,0>  ; 1MB
 19618 00000B06 0000                    		dw	0
 19619 00000B08 10                      		db	10h
 19620 00000B09 93                      		db	93h
 19621 00000B0A 0000                    		dw	0
 19622                                  
 19623                                  rombios_code:	;times desc.size db 0	; desc	<>
 19624 00000B0C 00<rep 8h>              		times 8 db 0
 19625                                  temp_stack:	;times desc.size db 0	; desc	<>
 19626 00000B14 00<rep 8h>              		times 8 db 0
 19627                                  
 19628 00000B1C 00<rep 20h>             ClrdVDISKHead:	times 32 db 0		; db 32 dup (0)
 19629                                  
 19630                                  
 19631                                  ; 25/03/2019 - Retro DOS v4.0 (MSDOS 6.21 IO.SYS, MSDOS 6.0 SYSINIt1.ASM)
 19632                                  
 19633                                  ClrVDISKHeader:	; proc	near
 19634                                  
 19635                                  ;;-----------------------------------------------------------	      ;I070
 19636                                  ;; The following workaround get around a problem with the	      ;I070
 19637                                  ;; Tortugas and PS/2 30-286 BIOS when password server mode	      ;I070
 19638                                  ;; is set. On those machines the INT 15h block move code	      ;I070
 19639                                  ;; goes through the 8042 to twiddle A20 instead of port 92h.	      ;I070
 19640                                  ;; In password server mode the 8042 is disabled so the block	      ;I070
 19641                                  ;; move crashes the system. We can do this because these	      ;I070
 19642                                  ;; systems clear all of memory on a cold boot.			      ;I070
 19643                                  ;								      ;I070
 19644                                  ;               in      al,64h         ; Test for password servr mode ;I070
 19645                                  ;               test    al,10h         ; Is keyboard inhibited?	      ;I070
 19646                                  ;               jnz     short ClrVDISKok ; No, go do block move.      ;I070
 19647                                  ;                                      ; Check for Tortugas...	      ;I070
 19648                                  ;               cmp     word [cs:sys_model_byte],19F8h                ;I070
 19649                                  ;               je      short ClrVDISKno                              ;I070
 19650                                  ;                                      ; Check for mod 30-286	      ;I070
 19651                                  ;               cmp     word [cs:sys_model_byte],09FCh                ;I070
 19652                                  ;               jne     short ClrVDISKok			      ;I070
 19653                                  ;ClrVDISKno: 	retn	               ; Return w/o block move.	      ;I070
 19654                                  ;								      ;I070
 19655                                  ;ClrVDISKok:							      ;I070
 19656                                  ;-----------------------------------------------------------	      ;I070
 19657                                  
 19658                                  	; 12/12/2022
 19659                                  	; ds = cs
 19660                                  
 19661 00000B3C 06                      	push	es
 19662 00000B3D 8CC8                    	mov	ax,cs
 19663 00000B3F 89C2                    	mov	dx,ax
 19664 00000B41 B10C                    	mov	cl,12
 19665 00000B43 D3EA                    	shr	dx,cl
 19666 00000B45 B104                    	mov	cl,4
 19667 00000B47 D3E0                    	shl	ax,cl
 19668 00000B49 05[1C0B]                	add	ax,ClrdVDISKHead
 19669 00000B4C 80D200                  	adc	dl,0
 19670                                  
 19671                                  	;; 23/10/2022
 19672                                  	;;mov	[cs:src_desc+desc.lo_word],ax
 19673                                  	;mov	[cs:src_desc+2],ax
 19674                                  	;;mov	[cs:src_desc+desc.hi_byte],dl
 19675                                  	;mov	[cs:src_desc+4],dl
 19676                                  	; 12/12/2022
 19677                                  	;mov	[src_desc+desc.lo_word],ax
 19678 00000B4F A3[FE0A]                	mov	[src_desc+2],ax
 19679                                  	;mov	[src_desc+desc.hi_byte],dl
 19680 00000B52 8816[000B]              	mov	[src_desc+4],dl
 19681                                  
 19682 00000B56 B91000                  	mov	cx,16	; 16 words
 19683 00000B59 0E                      	push	cs
 19684 00000B5A 07                      	pop	es
 19685 00000B5B BE[EC0A]                	mov	si,bmove
 19686 00000B5E B487                    	mov	ah,87h
 19687 00000B60 CD15                    	int	15h	; EXTENDED MEMORY - BLOCK MOVE (AT,XT286,PS)
 19688                                  			; CX = number of words to move 
 19689                                  			; ES:SI -> global descriptor table
 19690                                  			; Return: CF set on error, AH = status
 19691 00000B62 07                      	pop	es
 19692 00000B63 C3                      	retn
 19693                                  
 19694                                  ; ----------------------------------------------------------------------
 19695                                  ;
 19696                                  ; procedure : SaveFreeHMAPtr
 19697                                  ;
 19698                                  ;		Save the Free HMA pointer in BIOS variable for later use.
 19699                                  ;		(INT 2f ax==4a01 call returns pointer to free HMA)
 19700                                  ;		Normalizes the pointer to ffff:xxxx format and stores only
 19701                                  ;		the offset.
 19702                                  ;
 19703                                  ; Inputs : ES:DI - pointer to free HMA
 19704                                  ; Output : FreeHMAPtr in BIOS data segment updated
 19705                                  ;
 19706                                  ; ----------------------------------------------------------------------
 19707                                  
 19708                                  SaveFreeHMAPtr:
 19709 00000B64 8CC3                    	mov	bx,es
 19710 00000B66 B8FFFF                  	mov	ax,0FFFFh		; HMA segment
 19711 00000B69 29D8                    	sub	ax,bx
 19712 00000B6B 83C70F                  	add	di,15			; para round
 19713 00000B6E 83E7F0                  	and	di,0FFF0h
 19714 00000B71 B104                    	mov	cl,4
 19715 00000B73 D3E0                    	shl	ax,cl
 19716 00000B75 29C7                    	sub	di,ax
 19717 00000B77 1E                      	push	ds
 19718                                  	;;mov	ax,Bios_Data ; 0070h
 19719                                  	;mov	ax,KERNEL_SEGMENT ; 0070h
 19720                                  	; 21/10/2022
 19721 00000B78 B87000                  	mov	ax,DOSBIODATASEG ; 0070h
 19722 00000B7B 8ED8                    	mov	ds,ax
 19723 00000B7D 893E[F508]              	mov	[FreeHMAPtr],di	   ; (ds:8F7h for MSDOS 6.21 IO.SYS)
 19724 00000B81 C606[0D00]FF            	mov	byte [inHMA],0FFh  ; (ds:0Dh)
 19725 00000B86 1F                      	pop	ds
 19726 00000B87 C3                      	retn
 19727                                  
 19728                                  ; ----------------------------------------------------------------------
 19729                                  ;
 19730                                  ; procedure : IsVDiskInstalled
 19731                                  ;
 19732                                  ;		Checks for the presence of VDISK header at 1MB boundary
 19733                                  ;		& INT 19 vector
 19734                                  ;
 19735                                  ; Inputs  : A20 flag should be ON
 19736                                  ; Outputs : Zero set if VDISK header found else Zero cleared
 19737                                  ;
 19738                                  ; ----------------------------------------------------------------------
 19739                                  
 19740                                  IsVDiskInstalled:
 19741 00000B88 31C0                    	xor	ax,ax
 19742 00000B8A 8ED8                    	mov	ds,ax
 19743 00000B8C 8E1E4E00                	mov	ds,[19*4+2]
 19744                                  	;mov	si,VDiskSig1-StartVDHead ; 12h
 19745                                  	; 23/10/2022
 19746 00000B90 BE1200                  	mov	si,18
 19747                                  	;mov	cx,VLEN1 ; 5
 19748 00000B93 B90500                  	mov	cx,5
 19749 00000B96 0E                      	push	cs
 19750 00000B97 07                      	pop	es
 19751 00000B98 BF[500A]                	mov	di,VDiskSig1
 19752 00000B9B F3A6                    	rep	cmpsb
 19753 00000B9D 7410                    	je	short ivdins_retn
 19754 00000B9F B8FFFF                  	mov	ax,0FFFFh
 19755 00000BA2 8ED8                    	mov	ds,ax
 19756                                  	;mov	si,10h+(VDiskSig2-VDiskHMAHead) ; 13h
 19757 00000BA4 BE1300                  	mov	si,13h
 19758 00000BA7 BF[750A]                	mov	di,VDiskSig2
 19759                                  	;mov	cx,VLEN2  ; 5
 19760 00000BAA B90500                  	mov	cx,5
 19761 00000BAD F3A6                    	rep	cmpsb
 19762                                  ivdins_retn: 
 19763 00000BAF C3                      	retn			; returns the Zero flag
 19764                                  
 19765                                  ; ----------------------------------------------------------------------
 19766                                  ;
 19767                                  ; procedure : CPMHack
 19768                                  ;
 19769                                  ;		Copies the code from 0:c0 into ffff:0d0h
 19770                                  ;		for CPM compatibility
 19771                                  ;
 19772                                  ; ----------------------------------------------------------------------
 19773                                  
 19774                                  	; 11/12/2022
 19775                                  CPMHack:
 19776 00000BB0 1E                      	push	ds
 19777 00000BB1 B9FFFF                  	mov	cx,0FFFFh
 19778 00000BB4 8EC1                    	mov	es,cx		; ES = FFFF
 19779                                  	;xor	cx,cx
 19780                                  	; 11/12/2022
 19781 00000BB6 41                      	inc	cx  ; cx = 0
 19782 00000BB7 8ED9                    	mov	ds,cx		; DS = 0
 19783 00000BB9 BEC000                  	mov	si,0C0h
 19784 00000BBC BFD000                  	mov	di,0D0h
 19785                                  	;mov	cx,5
 19786 00000BBF B105                    	mov	cl,5
 19787 00000BC1 FC                      	cld
 19788 00000BC2 F3A4                    	rep	movsb		; move 5 bytes from 0:C0 to FFFF:D0
 19789 00000BC4 1F                      	pop	ds
 19790 00000BC5 C3                      	retn
 19791                                  
 19792                                  ; ----------------------------------------------------------------------
 19793                                  ;
 19794                                  ; procedure : off_to_para
 19795                                  ;
 19796                                  ; ----------------------------------------------------------------------
 19797                                  off_to_para:
 19798 00000BC6 D1E8                    	shr	ax,1
 19799 00000BC8 D1E8                    	shr	ax,1
 19800 00000BCA D1E8                    	shr	ax,1
 19801 00000BCC D1E8                    	shr	ax,1
 19802 00000BCE C3                      	retn
 19803                                  
 19804                                  ; ----------------------------------------------------------------------
 19805                                  ;**	TempCDS - Create (Temporary?) CDS
 19806                                  ;
 19807                                  ;	ENTRY	?? BUGBUG
 19808                                  ;		(DS) = SysInitSeg
 19809                                  ;	EXIT	?? BUGBUG
 19810                                  ;	USES	?? BUGBUG
 19811                                  ; ----------------------------------------------------------------------
 19812                                  
 19813                                  	; 23/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 19814                                  TempCDS:
 19815 00000BCF C43E[6B02]              	les	di,[DOSINFO]
 19816 00000BD3 268A4D20                	mov	cl,[es:di+SYSI_NUMIO]
 19817                                  	;mov	cl,[es:di+20h]
 19818 00000BD7 30ED                    	xor	ch,ch			; (cx) = # of block devices
 19819                                  
 19820 00000BD9 26884D21                	mov	[es:di+SYSI_NCDS],cl	; one CDS per device
 19821                                  	;mov	[es:di+21h],cl	
 19822                                  
 19823 00000BDD 88C8                    	mov	al,cl
 19824 00000BDF B458                    	mov	ah,curdirlen ; curdir_list.size ; 88
 19825                                  	;mov	ah,88
 19826 00000BE1 F6E4                    	mul	ah			; (ax) = byte size for those CDSs
 19827 00000BE3 E8D304                  	call	ParaRound		; (ax) = paragraph size for CDSs
 19828 00000BE6 8B36[A102]              	mov	si,[top_of_cdss] ; mov si,[CONFBOT]
 19829                                  
 19830                                  ;	BUGBUG - we don't update confbot - won't someone else use it?
 19831                                  ;	chuckst -- answer: no. Confbot is used to access the CDSs,
 19832                                  ;	25 jul 92  which are stored BELOW it. Alloclim is the
 19833                                  ;		   variable which has the top of free memory for
 19834                                  ;		   device driver loads, etc.
 19835                                  
 19836 00000BEA 29C6                    	sub	si,ax
 19837                                  
 19838                                  ;	chuckst, 25 Jul 92 -- note: I'm removing the code here
 19839                                  ;		that automatically updates alloclim every time we
 19840                                  ;		set up some new CDSs. Instead, I've added code
 19841                                  ;		which pre-allocates space for 26 CDSs. This
 19842                                  ;	        way we've got room for worst case CDSs before
 19843                                  ;		we place MagicDrv.sys
 19844                                  ;
 19845                                  ;	mov	[ALLOCLIM],si		; can't alloc past here!
 19846                                  
 19847                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 19848                                  	; (SYSINIT:0C52h)
 19849 00000BEC 8936[A302]              	mov	[ALLOCLIM],si
 19850                                  
 19851 00000BF0 26897518                	mov	[es:di+SYSI_CDS+2],si
 19852                                  	;mov	[es:di+18h],si
 19853 00000BF4 89F0                    	mov	ax,si
 19854 00000BF6 26C745160000            	mov	word [es:di+SYSI_CDS],0	; set address of CDS list
 19855                                  	;mov	[word es:di+16h],0
 19856                                  	;lds	si,[es:di+SYSI_DPB]	; (ds:si) = address of first DPB
 19857 00000BFC 26C535                  	lds	si,[es:di]
 19858 00000BFF 8EC0                    	mov	es,ax
 19859 00000C01 31FF                    	xor	di,di			; (es:di) = address of 1st CDS
 19860                                  
 19861                                  ;*	Initialize our temporary CDSs. We'll init each CDS with the
 19862                                  ;	info from the corresponding DPB.
 19863                                  ;
 19864                                  ;	(cx) = count of CDSs left to process
 19865                                  ;	(es:di) = address of next CDS
 19866                                  
 19867                                  fooset:
 19868                                  	; 23/10/2022
 19869 00000C03 2EA1[A502]              	mov	ax,[cs:DirStrng] ; "A:"
 19870 00000C07 AB                      	stosw				; setup the root as the curdir
 19871                                  
 19872                                  	;call	get_dpb_for_drive_al	; get dpb for drive in dpb
 19873                                  
 19874                                  ;	(ds:si) = address of DPB
 19875                                  ;		 (si) = -1 if no drive
 19876                                  
 19877 00000C08 2EA1[A702]              	mov	ax,[cs:DirStrng+2] ; "\",0
 19878 00000C0C AB                      	stosw
 19879 00000C0D 2EFE06[A502]            	inc	byte [cs:DirStrng]
 19880 00000C12 31C0                    	xor	ax,ax
 19881 00000C14 51                      	push	cx
 19882                                  	;mov	cx,curdir_list.cdir_flags - 4 ; 63
 19883 00000C15 B93F00                  	mov	cx,63	; 23/10/2022
 19884 00000C18 F3AA                    	rep	stosb			; zero out rest of CURDIR_TEXTs
 19885                                  
 19886                                  ;	should handle the system that does not have any floppies.
 19887                                  ;	in this case,we are going to pretended there are two dummy floppies
 19888                                  ;	in the system. still they have dpb and cds,but we are going to
 19889                                  ;	0 out curdir_flags,curdir_devptr of cds so ibmdos can issue
 19890                                  ;	"invalid drive specification" message when the user try to
 19891                                  ;	access them.
 19892                                  ;
 19893                                  ;	(ax) = 0
 19894                                  ;	(es:di) = CURDIR_FLAGS in the CDS records
 19895                                  ;	(ds:si) = Next DPB (-1 if none)
 19896                                  
 19897 00000C1A 83FEFF                  	cmp	si,-1	; cmp si,0FFFFh
 19898 00000C1D 7414                    	je	short fooset_zero	; don't have any physical drive.
 19899                                  
 19900                                  ;	check to see if we are faking floppy drives. if not go to normcds.
 19901                                  ;	if we are faking floppy drives then see if this cds being initialised
 19902                                  ;	is for drive a: or b: by checking the appropriate field in the dpb
 19903                                  ;	pointed to by ds:si. if not for a: or b: then go to normcds. if
 19904                                  ;	for a: or b: then execute the code given below starting at fooset_zero.
 19905                                  ;	for dpb offsets look at inc\dpb.inc.
 19906                                  
 19907 00000C1F 2E803E[8902]01          	cmp	byte [cs:fake_floppy_drv],1
 19908 00000C25 7513                    	jne	short normcds 		; machine has floppy drives
 19909                                  	;cmp	byte [si+DPB.drive],1	; if dpb_drive = 0 (a) or 1 (b).
 19910 00000C27 803C01                  	cmp	byte [si],1
 19911 00000C2A 770E                    	ja	short normcds
 19912 00000C2C B103                    	mov	cl,3			; the next dbp pointer
 19913                                  					; AX should be zero here
 19914 00000C2E F3AB                    	rep	stosw
 19915 00000C30 59                      	pop	cx
 19916 00000C31 EB18                    	jmp	short get_next_dpb
 19917                                  
 19918                                  ;	(ax) = 0
 19919                                  
 19920                                  fooset_zero:
 19921 00000C33 B103                    	mov	cl,3
 19922 00000C35 F3AB                    	rep	stosw
 19923 00000C37 59                      	pop	cx
 19924 00000C38 EB14                    	jmp	short fincds
 19925                                  
 19926                                  ;*	We have a "normal" DPB and thus a normal CDS.
 19927                                  ;
 19928                                  ;	(ax) = 0
 19929                                  ;	(es:di) = CURDIR_FLAGS in the CDS records
 19930                                  ;	(ds:si) = Next DPB (-1 if none)
 19931                                  
 19932                                  normcds:
 19933 00000C3A 59                      	pop	cx
 19934                                  
 19935                                  ;	if a non-fat based media is detected (by dpb.numberoffat == 0), then
 19936                                  ;	set curdir_flags to 0. this is for signaling ibmdos and ifsfunc that
 19937                                  ;	this media is a non-fat based one.
 19938                                  
 19939                                  	;cmp	byte [si+DPB.FAT_COUNT],0 ; non fat system?
 19940                                  	; 23/10/2022
 19941 00000C3B 807C0800                	cmp	byte [si+8],0
 19942 00000C3F 7403                    	je	short setnormcds	; yes. set curdir_flags to 0. ax = 0 now.
 19943 00000C41 B80040                  	mov	ax,curdir_inuse ; 4000h	; else,fat system. set the flag to curdir_inuse.
 19944                                  	;mov	ax,4000h
 19945                                  setnormcds:
 19946 00000C44 AB                      	stosw				; curdir_flags
 19947 00000C45 89F0                    	mov	ax,si
 19948 00000C47 AB                      	stosw				; curdir_devptr
 19949 00000C48 8CD8                    	mov	ax,ds
 19950 00000C4A AB                      	stosw
 19951                                  
 19952                                  get_next_dpb:				; entry point for fake_fooset_zero
 19953                                  	; 23/10/2022
 19954 00000C4B C57419                  	lds	si,[si+19h]
 19955                                  	;lds	si,[si+DPB.NEXT_DPB] ; [si+19h]
 19956                                  fincds:
 19957 00000C4E B8FFFF                  	mov	ax,-1	; mov ax,0FFFFh
 19958 00000C51 AB                      	stosw				; curdir_id
 19959 00000C52 AB                      	stosw				; curdir_id
 19960 00000C53 AB                      	stosw				; curdir_user_word
 19961 00000C54 B80200                  	mov	ax,2
 19962 00000C57 AB                      	stosw				; curdir_end
 19963 00000C58 B000                    	mov	al,0			; clear out 7 bytes (curdir_type,
 19964 00000C5A AA                      	stosb
 19965 00000C5B AB                      	stosw				;  curdir_ifs_hdr,curdir_fsda)
 19966 00000C5C AB                      	stosw
 19967 00000C5D AB                      	stosw
 19968                                  
 19969 00000C5E E2A3                    	loop	fooset
 19970                                  	
 19971 00000C60 2EC606[A502]41          	mov	byte [cs:DirStrng],"A"	; "A:\"
 19972                                  	
 19973 00000C66 C3                      	retn
 19974                                  
 19975                                  ; ----------------------------------------------------------------------
 19976                                  ;***	get_dpb_for_drive_al -- lookup the DPB for drive in al
 19977                                  ;
 19978                                  ;	entry:
 19979                                  ;	   al == ASCII CAPS drive letter
 19980                                  ;
 19981                                  ;	exit:
 19982                                  ;	   ds:si -> DPB, or si = -1 if not found
 19983                                  ; ----------------------------------------------------------------------
 19984                                  
 19985                                  ;	; 23/10/2022 (get_dpb_for_drive_al
 19986                                  ;
 19987                                  ;get_dpb_for_drive_al:
 19988                                  ;	lds	si,[cs:DOSINFO]		; point to first DPB
 19989                                  ;	;lds	si,[si+SYSI_DPB]	; (ds:si) = address of first DPB
 19990                                  ;	lds	si,[si]
 19991                                  ;	sub	al,'A'
 19992                                  ;
 19993                                  ;get_dpb_for_drive_1:
 19994                                  ;	;cmp	al,[si+DPB.DRIVE]	; match?
 19995                                  ;	cmp	al,[si]
 19996                                  ;	je	short got_dpb_for_drive	;  done if so
 19997                                  ;
 19998                                  ;	lds	si,[si+DPB.NEXT_DPB] ; [si+19h]
 19999                                  ;	cmp	si,-1
 20000                                  ;	jne	short get_dpb_for_drive_1 ; loop until hit end of DPBs
 20001                                  ;
 20002                                  ;got_dpb_for_drive:
 20003                                  ;	retn
 20004                                  
 20005                                  ;=======================================================================
 20006                                  
 20007                                  ;**	EndFile - Build DOS structures
 20008                                  ;
 20009                                  ; This procedure is called after the config.sys has been processed and
 20010                                  ; installable device drivers have been loaded (but before "install="
 20011                                  ; programs are loaded) to create the dos structures such as SFTs, buffers,
 20012                                  ; FCBs, CDSs, etc. It also loads the sysinit_base module in low memory
 20013                                  ; to allow for the safe EXECing of "install=" programs. All memory
 20014                                  ; above these structures is deallocated back to DOS.
 20015                                  ;
 20016                                  ;	ENTRY	?? BUGBUG
 20017                                  ;	EXIT	?? BUGBUG
 20018                                  ;	USES	?? BUGBUG
 20019                                  
 20020                                  ;=======================================================================
 20021                                  ; allocate files
 20022                                  ; ----------------------------------------------------------------------
 20023                                  
 20024                                  	; 23/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 20025                                  	; (SYSINIT:0CCDh)
 20026                                  
 20027                                  endfile:
 20028                                  ; we are now setting up final cdss,buffers,files,fcss strings etc. we no
 20029                                  ; longer need the space taken by the temp stuff below confbot,so set alloclim
 20030                                  ; to confbot.
 20031                                  
 20032                                  ;	if this procedure has been called to take care of install= command,
 20033                                  ;	   then we have to save es,si registers.
 20034                                  
 20035                                  	; 11/12/2022
 20036                                  	; ds = cs
 20037                                  
 20038                                  	; 23/10/2022
 20039                                  	; 31/03/2019
 20040 00000C67 1E                      	push	ds
 20041                                  
 20042                                  	;;mov	ax,Bios_Data ; 0070h
 20043                                  	;mov	ax,KERNEL_SEGMENT ; 0070h
 20044                                  	; 21/10/2022
 20045 00000C68 B87000                  	mov	ax,DOSBIODATASEG ; 0070h
 20046 00000C6B 8ED8                    	mov	ds,ax
 20047                                  
 20048                                  	;cmp	word [052Fh],0
 20049 00000C6D 833E[2F05]00            	cmp	word [multrk_flag],multrk_off1 ;=0,multrack= command entered?
 20050 00000C72 7505                    	jne	short multrk_flag_done
 20051                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 20052                                  	;or	word [multrk_flag],multrk_on ; 80h  ; default will be on.
 20053                                  	; 12/12/2022
 20054 00000C74 800E[2F05]80            	or	byte [multrk_flag],multrk_on ; 80h
 20055                                  multrk_flag_done:
 20056                                  	; 23/10/2022
 20057                                  	; 31/03/2019
 20058 00000C79 1F                      	pop	ds
 20059                                  
 20060                                  	; 11/12/2022
 20061                                  	; ds = cs
 20062 00000C7A A1[A102]                	mov	ax,[top_of_cdss] ; mov ax,[CONFBOT]
 20063 00000C7D A3[A302]                	mov	[ALLOCLIM],ax
 20064                                  	; 23/10/2022
 20065                                  	;mov	ax, [cs:top_of_cdss]
 20066                                  	;mov	[cs:ALLOCLIM], ax 
 20067                                  
 20068                                  	; 11/12/2022
 20069                                  	; ds = cs
 20070                                  	;push	cs
 20071                                  	;pop	ds
 20072                                  	
 20073                                  	;mov	ax,[CONFBOT]
 20074                                  	;mov	[ALLOCLIM],ax
 20075                                  
 20076 00000C80 E83924                  	call	round
 20077                                  	; 11/12/2022
 20078                                  	; ds = cs
 20079 00000C83 A0[9D02]                	mov	al,[FILES]
 20080                                  	; 23/10/2022
 20081                                  	;mov	al,[cs:FILES]
 20082 00000C86 2C05                    	sub	al,5
 20083 00000C88 764B                    	jbe	short dofcbs
 20084                                  
 20085 00000C8A 50                      	push	ax
 20086                                  	;mov	al,devmark_files ; 'F'
 20087 00000C8B B046                    	mov	al,'F'
 20088 00000C8D E87B07                  	call	setdevmark		; set devmark for sfts (files)
 20089 00000C90 58                      	pop	ax
 20090 00000C91 30E4                    	xor	ah,ah			; do not use cbw instruction!!!!!
 20091                                  					;  it does sign extend.
 20092                                  	; 11/12/2022
 20093                                  	; ds = cs
 20094 00000C93 8B1E[DE03]              	mov	bx,[memlo]
 20095 00000C97 8B16[E003]              	mov	dx,[memhi]
 20096 00000C9B C53E[6B02]              	lds	di,[DOSINFO]		;get pointer to dos data
 20097                                  	; 23/10/2022
 20098                                  	;mov	bx,[cs:memlo]
 20099                                  	;mov	dx,[cs:memhi]
 20100                                  	;lds	di,[cs:DOSINFO]		
 20101                                  
 20102                                  	;lds	di,[di+SYSI_SFT]	;ds:bp points to sft
 20103 00000C9F C57D04                  	lds	di,[di+4]
 20104                                  
 20105                                  	;mov	[di+SF.SFLink],bx
 20106 00000CA2 891D                    	mov	[di],bx
 20107 00000CA4 895502                  	mov	[di+SF.SFLink+2],dx	;set pointer to new sft
 20108                                  
 20109 00000CA7 0E                      	push	cs
 20110 00000CA8 1F                      	pop	ds
 20111                                  
 20112                                  	; 11/12/2022
 20113                                  	; ds = cs
 20114 00000CA9 C43E[DE03]              	les	di,[memlo]		;point to new sft
 20115                                  	; 23/10/2022
 20116                                  	;les	di,[cs:memlo]
 20117                                  
 20118                                  	;mov	word [es:di+SF.SFLink],-1
 20119 00000CAD 26C705FFFF              	mov	word [es:di],-1		; 0FFFFh
 20120                                  	;mov	[es:di+SF.SFCount],ax
 20121 00000CB2 26894504                	mov	[es:di+4],ax
 20122                                  	;mov	bl,SF_ENTRY.size ; 59
 20123 00000CB6 B33B                    	mov	bl,59
 20124 00000CB8 F6E3                    	mul	bl			;ax = number of bytes to clear
 20125 00000CBA 89C1                    	mov	cx,ax
 20126                                  	; 11/12/2022
 20127                                  	; ds = cs
 20128 00000CBC 0106[DE03]              	add	[memlo],ax		;allocate memory
 20129                                  	; 23/10/2022
 20130                                  	;add	[cs:memlo],ax
 20131 00000CC0 B80600                  	mov	ax,6
 20132                                  	; 11/12/2022
 20133 00000CC3 0106[DE03]              	add	[memlo],ax		;remember the header too
 20134                                  	;add	[cs:memlo],ax
 20135                                  	; 11/12/2022
 20136 00000CC7 800E[2E14]02            	or	byte [setdevmarkflag],for_devmark ; 2
 20137                                  	; 23/10/2022
 20138                                  	;or	byte [cs:setdevmarkflag],2
 20139 00000CCC E8ED23                  	call	round			; check for mem error before the stosb
 20140 00000CCF 01C7                    	add	di,ax
 20141 00000CD1 31C0                    	xor	ax,ax
 20142 00000CD3 F3AA                    	rep	stosb			;clean out the stuff
 20143                                  
 20144                                  ; allocate fcbs
 20145                                  ; ----------------------------------------------------------------------
 20146                                  
 20147                                  	; 23/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 20148                                  	; (SYSINIT:0D48h)
 20149                                  dofcbs:
 20150                                  	; 11/12/2022
 20151                                  	; ds = cs
 20152                                  	;push	cs
 20153                                  	;pop	ds
 20154 00000CD5 E8E423                  	call	round
 20155                                  	;mov	al,devmark_fcbs	; 'X'	;='x'
 20156 00000CD8 B058                    	mov	al,'X'
 20157 00000CDA E82E07                  	call	setdevmark
 20158                                  	; 11/12/2022
 20159                                  	; ds = cs
 20160 00000CDD A0[9E02]                	mov	al,[FCBS]
 20161                                  	;mov	al,[cs:FCBS]
 20162 00000CE0 30E4                    	xor	ah,ah			; do not use cbw instruction!!!!!
 20163                                  					;  it does sign extend.
 20164                                  	; 11/12/2022
 20165 00000CE2 8B1E[DE03]              	mov	bx,[memlo]
 20166 00000CE6 8B16[E003]              	mov	dx,[memhi]
 20167 00000CEA C53E[6B02]              	lds	di,[DOSINFO]		;get pointer to dos data
 20168                                  	; 23/10/2022
 20169                                  	;mov	bx,[cs:memlo]
 20170                                  	;mov	dx,[cs:memhi]
 20171                                  	;lds	di,[cs:DOSINFO]
 20172                                  
 20173                                  	;mov	[di+SYSI_FCB],bx
 20174                                  	;mov	[di+SYSI_FCB+2],dx ;set pointer to new table
 20175                                  	; 23/10/2022
 20176 00000CEE 895D1A                  	mov	[di+1Ah],bx		; [di+SYSI_FCB]
 20177 00000CF1 89551C                  	mov	[di+1Ch],dx		; [di+SYSI_FCB+2]
 20178                                  
 20179 00000CF4 2E8A1E[9F02]            	mov	bl,[cs:KEEP]
 20180 00000CF9 30FF                    	xor	bh,bh
 20181                                  	;mov	[di+SYSI_KEEP],bx
 20182 00000CFB 895D1E                  	mov	[di+1Eh],bx		; [di+SYSI_KEEP]	
 20183                                  
 20184 00000CFE 0E                      	push	cs
 20185 00000CFF 1F                      	pop	ds
 20186                                  	
 20187 00000D00 C43E[DE03]              	les	di,[memlo]		;point to new table
 20188                                  	;mov	word [es:di+SF.SFLink],-1
 20189 00000D04 26C705FFFF              	mov	word [es:di],-1
 20190                                  	;mov	[es:di+SF.SFCount],ax
 20191                                  	; 02/11/2022
 20192 00000D09 26894504                	mov	[es:di+4],ax
 20193 00000D0D B339                    	mov	bl,SF_ENTRY.size ; 59
 20194 00000D0F 89C1                    	mov	cx,ax
 20195 00000D11 F6E3                    	mul	bl			;ax = number of bytes to clear
 20196 00000D13 0106[DE03]              	add	[memlo],ax		;allocate memory
 20197                                  	;mov	ax,6
 20198 00000D17 B80600                  	mov	ax,SF.size-2 ; 6
 20199 00000D1A 0106[DE03]              	add	[memlo],ax		;remember the header too
 20200                                  	;or	byte [setdevmarkflag],for_devmark ; 2
 20201 00000D1E 800E[2E14]02            	or	byte [setdevmarkflag],2
 20202 00000D23 E89623                  	call	round			; check for mem error before the stosb
 20203 00000D26 01C7                    	add	di,ax			;skip over header
 20204 00000D28 B041                    	mov	al,'A'
 20205                                  fillloop:
 20206 00000D2A 51                      	push	cx			; save count
 20207 00000D2B B93900                  	mov	cx,SF_ENTRY.size ; 59	; number of bytes to fill
 20208 00000D2E FC                      	cld
 20209 00000D2F F3AA                    	rep	stosb			; filled
 20210                                  
 20211                                  	;mov	word [es:di-(SF_ENTRY.size)+SF_ENTRY.sf_ref_count],0  ; [es:di-59]
 20212                                  	;mov	word [es:di-(SF_ENTRY.size)+SF_ENTRY.sf_position],0   ; [es:di-38]	
 20213                                  	;mov	word [es:di-(SF_ENTRY.size)+SF_ENTRY.sf_position+2],0 ; [es:di-36]
 20214                                  
 20215                                  	; 18/12/2022
 20216                                  	;cx = 0
 20217 00000D31 26894DC7                	mov	[es:di-(SF_ENTRY.size)+SF_ENTRY.sf_ref_count],cx ;0  ; [es:di-59]
 20218 00000D35 26894DDC                	mov	[es:di-(SF_ENTRY.size)+SF_ENTRY.sf_position],cx ;0   ; [es:di-38]	
 20219 00000D39 26894DDE                	mov	[es:di-(SF_ENTRY.size)+SF_ENTRY.sf_position+2],cx ;0 ; [es:di-36]
 20220                                  	
 20221                                  	; 23/10/2022	
 20222                                  	;mov     word [es:di-3Bh],0
 20223                                  	;mov     word [es:di-26h],0
 20224                                  	;mov     word [es:di-24h],0
 20225                                  
 20226 00000D3D 59                      	pop	cx
 20227 00000D3E E2EA                    	loop	fillloop
 20228                                  
 20229                                  ; allocate buffers
 20230                                  ; ----------------------------------------------------------------------
 20231                                  
 20232                                  ; search through the list of media supported and allocate 3 buffers if the
 20233                                  ; capacity of the drive is > 360kb
 20234                                  
 20235                                  	; 18/12/2022
 20236                                  	; cx = 0
 20237 00000D40 833E[9702]FF            	cmp	word [buffers],-1	; has buffers been already set?
 20238 00000D45 7403                    	je	short dodefaultbuff
 20239 00000D47 E98700                  	jmp	dobuff			; the user entered the buffers=.
 20240                                  
 20241                                  dodefaultbuff:
 20242                                  	; 18/12/2022
 20243 00000D4A 890E[9902]              	mov	[h_buffers],cx ; 0
 20244 00000D4E 41                      	inc	cx
 20245 00000D4F 41                      	inc	cx
 20246 00000D50 890E[9702]              	mov	[buffers],cx ; 2	
 20247                                  	
 20248                                  	;mov	word [h_buffers],0	; default is no heuristic buffers.
 20249                                  	;mov	word [buffers],2	; default to 2 buffers
 20250                                  
 20251                                  	; 23/10/2022	
 20252 00000D54 50                      	push	ax
 20253 00000D55 1E                      	push	ds ; 26/03/2019
 20254                                  	;les	bp,[DOSINFO]		; search through the dpb's
 20255 00000D56 2EC42E[6B02]            	les	bp,[cs:DOSINFO]
 20256                                  	;les	bp,[es:bp+SYSI_DPB]	; get first dpb
 20257                                  	; 11/12/2022
 20258 00000D5B 26C46E00                	les	bp,[es:bp]
 20259                                  	; 23/10/2022
 20260                                  	;les	bp,[es:bp+0]	; ! (MSDOS 5.0 IO.SYS address compability) !	
 20261                                  
 20262 00000D5F 0E                      	push	cs
 20263 00000D60 1F                      	pop	ds
 20264                                  ;SYSINIT:0DE2h:
 20265                                  nextdpb:				; test if the drive supports removeable media
 20266                                  	;mov	bl,[es:bp+DPB.drive]
 20267                                  	; 11/12/2022
 20268 00000D61 268A5E00                	mov	bl,[es:bp]
 20269                                  	; 23/10/2022
 20270                                  	;mov	bl,[es:bp+0]	; ! (MSDOS 5.0 IO.SYS address compability) !
 20271                                  
 20272                                  	;inc	bl
 20273                                  	; 18/12/2022
 20274 00000D65 43                      	inc	bx
 20275                                  
 20276                                  	;mov	ax,(IOCTL<<8)|8
 20277 00000D66 B80844                  	mov	ax,4408h
 20278 00000D69 CD21                    	int	21h		; DOS - 2+ - IOCTL -
 20279                                  
 20280                                  ; ignore fixed disks
 20281                                  
 20282 00000D6B 09C0                    	or	ax,ax			; ax is nonzero if disk is nonremoveable
 20283 00000D6D 7534                    	jnz	short nosetbuf
 20284                                  
 20285                                  ; get parameters of drive
 20286                                  
 20287 00000D6F 31DB                    	xor	bx,bx
 20288                                  	;;mov	bl,[es:bp+DPB.drive]
 20289                                  	; 11/12/2022
 20290 00000D71 268A5E00                	mov	bl,[es:bp]
 20291                                  	; 23/10/2022
 20292                                  	;mov	bl,[es:bp+0]	; ! (MSDOS 5.0 IO.SYS address compability) !
 20293                                  	
 20294                                  	;inc	bl
 20295                                  	; 18/12/2022
 20296 00000D75 43                      	inc	bx
 20297                                  
 20298 00000D76 BA[DA35]                	mov	dx,deviceparameters
 20299                                  	;mov	ax,(IOCTL<<8)|GENERIC_IOCTL
 20300 00000D79 B80D44                  	mov	ax,440Dh
 20301                                  	;mov	cx,(RAWIO<<8)|GET_DEVICE_PARAMETERS
 20302 00000D7C B96008                  	mov	cx,860h
 20303 00000D7F CD21                    	int	21h		; DOS - 2+ - IOCTL -
 20304 00000D81 7220                    	jc	short nosetbuf		; get next dpb if driver doesn't support
 20305                                  					; generic ioctl
 20306                                  ; determine capacity of drive
 20307                                  ; media capacity = #sectors * bytes/sector
 20308                                  
 20309                                  	;mov	bx,[deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_TOTALSECTORS]
 20310                                  	; 23/10/2022
 20311 00000D83 8B1E[E935]              	mov	bx,[deviceparameters+15] ; total sectors (16 bit)
 20312                                  	
 20313                                  ; to keep the magnitude of the media capacity within a word,
 20314                                  ; scale the sector size
 20315                                  ; (ie. 1 -> 512 bytes,2 -> 1024 bytes,...)
 20316                                  
 20317                                  	;mov	ax,[deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_BYTESPERSECTOR]
 20318                                  	; 23/10/2022
 20319 00000D87 A1[E135]                	mov	ax, [deviceparameters+7] ; bytes per sector
 20320 00000D8A 31D2                    	xor	dx,dx
 20321 00000D8C B90002                  	mov	cx,512
 20322 00000D8F F7F1                    	div	cx			; scale sector size in factor of
 20323                                  					; 512 bytes
 20324 00000D91 F7E3                    	mul	bx			; ax = #sectors * size factor
 20325 00000D93 09D2                    	or	dx,dx			; just in case of large floppies
 20326 00000D95 7505                    	jnz	short setbuf
 20327 00000D97 3DD002                  	cmp	ax,720			; 720 sectors * size factor of 1
 20328 00000D9A 7607                    	jbe	short nosetbuf
 20329                                  setbuf:
 20330                                  	; 18/12/2022
 20331                                  	; word [buffers] = 2
 20332 00000D9C C606[9702]03            	mov	byte [buffers],3
 20333                                  	;mov	word [buffers],3
 20334 00000DA1 EB0D                    	jmp	short chk_memsize_for_buffers ; now check the memory size
 20335                                  					; for default buffer count
 20336                                  nosetbuf:
 20337                                  	; 23/10/2022
 20338                                  	;cmp	word [es:bp+DPB.NEXT_DPB],-1
 20339 00000DA3 26837E19FF              	cmp	word [es:bp+19h], -1 ; 0FFFFh
 20340 00000DA8 7406                    	je	short chk_memsize_for_buffers
 20341                                  	;les	bp,[es:bp+DPB.NEXT_DPB] ; [es:bp+19h]
 20342 00000DAA 26C46E19                	les	bp,[es:bp+19h]
 20343 00000DAE EBB1                    	jmp	short nextdpb
 20344                                  
 20345                                  ;from dos 3.3,the default number of buffers will be changed according to the
 20346                                  ;memory size too.
 20347                                  ; default buffers = 2
 20348                                  ; if diskette media > 360 kb,then default buffers = 3
 20349                                  ; if memory size > 128 kb (2000h para),then default buffers = 5
 20350                                  ; if memory size > 256 kb (4000h para),then default buffers = 10
 20351                                  ; if memory size > 512 kb (8000h para),then default buffers = 15.
 20352                                  
 20353                                  chk_memsize_for_buffers:
 20354                                  	; 18/12/2022
 20355                                  	;cmp	word [MEMORY_SIZE],2000h
 20356                                  	;jbe	short bufset
 20357                                  	;mov	word [buffers],5
 20358                                  	;cmp	word [MEMORY_SIZE],4000h
 20359                                  	;jbe	short bufset
 20360                                  	;mov	word [buffers],10
 20361                                  	;cmp	word [MEMORY_SIZE],8000h
 20362                                  	;jbe	short bufset
 20363                                  	;mov	word [buffers],15
 20364                                  
 20365                                  	; 18/12/2022
 20366                                  	; word [buffers] = 3 or 2
 20367 00000DB0 BB[9702]                	mov	bx,buffers
 20368 00000DB3 A1[9202]                	mov	ax,[MEMORY_SIZE]
 20369 00000DB6 48                      	dec	ax	; [MEMORY_SIZE] - 1
 20370                                  
 20371 00000DB7 80FC20                  	cmp	ah,20h	; ax >= 2000h ([MEMORY_SIZE] > 2000h) ; *
 20372 00000DBA 7213                    	jb	short bufset
 20373 00000DBC C6070F                  	mov	byte [bx],15 ; [buffers] = 15 ; ***
 20374 00000DBF 80FC80                  	cmp	ah,80h	; ax >= 8000h ([MEMORY_SIZE] > 8000h) ; ***
 20375 00000DC2 730B                    	jnb	short bufset
 20376 00000DC4 C6070A                  	mov	byte [bx],10 ; [buffers] = 10 ; **
 20377 00000DC7 80FC40                  	cmp	ah,40h	; ax >= 4000h ([MEMORY_SIZE] > 4000h) ; **
 20378 00000DCA 7303                    	jnb	short bufset
 20379 00000DCC C60705                  	mov	byte [bx],5  ; [buffers] = 5 ; *
 20380                                  bufset:
 20381                                  	; 23/10/2022
 20382                                  	; 26/03/2019
 20383 00000DCF 1F                      	pop	ds
 20384 00000DD0 58                      	pop	ax
 20385                                  
 20386                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 20387                                  ;j.k. here we should put extended stuff and new allocation scheme!!!
 20388                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 20389                                  
 20390                                  ; 26/03/2019
 20391                                  
 20392                                  ;*******************************************************************************
 20393                                  ;									       *
 20394                                  ; function: actually allocate buffers in the memory and initialize it. 	       *
 20395                                  ; input :								       *
 20396                                  ;    memhi:memlo - start of the next available memory			       *
 20397                                  ;    buffers = number of buffers					       *
 20398                                  ;    h_buffers = number of secondary buffers				       *
 20399                                  ;									       *
 20400                                  ; output:								       *
 20401                                  ;	buffinfo.cache_count - # of caches to be installed.		       *
 20402                                  ;	buffinfo set.							       *
 20403                                  ;	bufferqueue set.						       *
 20404                                  ;									       *
 20405                                  ; subroutines to be called:						       *
 20406                                  ;									       *
 20407                                  ;*******************************************************************************
 20408                                  
 20409                                  	; 23/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 20410                                  	; (SYSINIT:0E60h)
 20411                                  dobuff:
 20412                                  	; ds = cs ; 31/03/2019
 20413                                  	; 23/10/2022
 20414 00000DD1 2EC51E[6B02]            	lds	bx,[cs:DOSINFO]	; ds:bx -> sysinitvar
 20415                                  	;mov	ax,[buffers] ; 31/03/2019
 20416                                  	;lds	bx,[DOSINFO]
 20417 00000DD6 2EA1[9702]              	mov	ax,[cs:buffers]	; set sysi_buffers
 20418                                  	;mov	[bx+SYSI_BUFFERS],ax ; [bx+3Fh]
 20419 00000DDA 89473F                  	mov	[bx+3Fh],ax
 20420 00000DDD 2EA1[9902]              	mov	ax,[cs:h_buffers]
 20421                                  	;mov	[bx+SYSI_BUFFERS+2],ax ; [bx+41h]
 20422 00000DE1 894741                  	mov	[bx+41h],ax
 20423 00000DE4 C55F12                  	lds	bx,[bx+12h]
 20424                                  	;lds	bx,[bx+SYSI_BUF] ; now,ds:bx -> buffinfo
 20425 00000DE7 E8D222                  	call	round		; get [memhi]:[memlo]
 20426                                  	;mov	al,devmark_buf	; ='B'
 20427 00000DEA B042                    	mov	al,'B'	
 20428 00000DEC E81C06                  	call	setdevmark
 20429                                  
 20430                                  ;allocate buffers
 20431                                  
 20432 00000DEF 1E                      	push	ds			; save buffer info. ptr.
 20433 00000DF0 53                      	push	bx
 20434                                  
 20435 00000DF1 E85203                  	call	set_buffer
 20436                                  
 20437 00000DF4 5B                      	pop	bx
 20438 00000DF5 1F                      	pop	ds
 20439                                  
 20440                                  ;now set the secondary buffer if specified.
 20441                                  
 20442 00000DF6 2E833E[9902]00          	cmp	word [cs:h_buffers],0
 20443 00000DFC 742D                    	je	short xif16
 20444 00000DFE E8BB22                  	call	round
 20445                                  	; 23/10/2022
 20446 00000E01 2E8B0E[DE03]            	mov	cx,[cs:memlo]
 20447                                  	;mov	[bx+BUFFINF.Cache_ptr],cx  ; [bx+6]
 20448 00000E06 894F06                  	mov	[bx+6],cx
 20449 00000E09 2E8B0E[E003]            	mov	cx,[cs:memhi]
 20450                                  	;mov	[bx+BUFFINF.Cache_ptr+2],cx ; [bx+8]
 20451 00000E0E 894F08                  	mov	[bx+8],cx
 20452 00000E11 2E8B0E[9902]            	mov	cx,[cs:h_buffers]
 20453                                  	;mov	[bx+BUFFINF.Cache_count],cx ; [bx+10]
 20454 00000E16 894F0A                  	mov	[bx+10],cx
 20455 00000E19 B80002                  	mov	ax,512			; 512 byte
 20456 00000E1C F7E1                    	mul	cx
 20457 00000E1E 2EA3[DE03]              	mov	[cs:memlo],ax
 20458                                  	;or	byte [cs:setdevmarkflag],for_devmark ; 2
 20459 00000E22 2E800E[2E14]02          	or	byte [cs:setdevmarkflag],2
 20460 00000E28 E89122                  	call	round
 20461                                  xif16:
 20462                                  
 20463                                  ; ----------------------------------------------------------------------
 20464                                  ; allocate cdss
 20465                                  ; ----------------------------------------------------------------------
 20466                                  
 20467                                  buf1:
 20468 00000E2B E88E22                  	call	round
 20469                                  
 20470 00000E2E 50                      	push	ax
 20471                                  	; 23/10/2022
 20472                                  	;mov	ax,devmark_cds		;='L'
 20473 00000E2F B84C00                  	mov	ax, 'L'
 20474 00000E32 E8D605                  	call	setdevmark
 20475 00000E35 58                      	pop	ax
 20476                                  
 20477 00000E36 2EC43E[6B02]            	les	di,[cs:DOSINFO]
 20478                                  	;mov	cl,[es:di+SYSI_NUMIO]
 20479 00000E3B 268A4D20                	mov	cl,[es:di+20h]
 20480 00000E3F 2E3A0E[A002]            	cmp	cl,[cs:NUM_CDS]
 20481 00000E44 7305                    	jae	short gotncds 		; user setting must be at least numio
 20482 00000E46 2E8A0E[A002]            	mov	cl,[cs:NUM_CDS]
 20483                                  gotncds:
 20484 00000E4B 30ED                    	xor	ch,ch
 20485                                  	;mov	[es:di+SYSI_NCDS],cl	; [es:di+33]
 20486 00000E4D 26884D21                	mov	[es:di+21h],cl
 20487 00000E51 2EA1[E003]              	mov	ax,[cs:memhi]
 20488                                  	;mov	[es:di+SYSI_CDS+2],ax
 20489 00000E55 26894518                	mov	[es:di+18h],ax
 20490 00000E59 2EA1[DE03]              	mov	ax,[cs:memlo]
 20491                                  	;mov	[es:di+SYSI_CDS],ax
 20492 00000E5D 26894516                	mov	[es:di+16h],ax
 20493 00000E61 88C8                    	mov	al,cl
 20494                                  	;mov	ah,curdirlen ; curdir_list.size
 20495 00000E63 B458                    	mov	ah,88
 20496 00000E65 F6E4                    	mul	ah
 20497 00000E67 E84F02                  	call	ParaRound
 20498 00000E6A 2E0106[E003]            	add	[cs:memhi],ax
 20499                                  
 20500                                  	;or	byte [cs:setdevmarkflag],for_devmark ; 2
 20501 00000E6F 2E800E[2E14]02          	or	byte [cs:setdevmarkflag],2
 20502 00000E75 E84422                  	call	round			; check for mem error before initializing
 20503                                  	;lds	si,[es:di+SYSI_DPB] ; [es:di+0]
 20504 00000E78 26C535                  	lds	si,[es:di]
 20505                                  	;les	di,[es:di+SYSI_CDS] ; [es:di+22]
 20506 00000E7B 26C47D16                	les	di,[es:di+16h]
 20507 00000E7F E881FD                  	call	fooset
 20508                                  
 20509                                  ; ----------------------------------------------------------------------
 20510                                  ; allocate space for internal stack
 20511                                  ; ----------------------------------------------------------------------
 20512                                  
 20513 00000E82 0E                      	push	cs
 20514 00000E83 1F                      	pop	ds
 20515                                  
 20516                                  ;	if the user did not entered stacks= command, as a default, do not install
 20517                                  ;	sytem stacks for pc1,pc xt,pc portable cases.
 20518                                  ;	otherwise,install it to the user specified value or to the default
 20519                                  ;	value of 9,128 for other systems.
 20520                                  
 20521 00000E84 833E[8E02]FF            	cmp	word [stack_addr],-1 ; has the user entered "stacks=" command?
 20522 00000E89 740E                    	je	short doinstallstack	; then install as specified by the user
 20523 00000E8B 803E[3803]00            	cmp	byte [sys_scnd_model_byte],0 ; pc1,xt has the secondary model byte = 0
 20524 00000E90 7507                    	jne	short doinstallstack	; other model should have default stack of 9,128
 20525 00000E92 803E[3703]FE            	cmp	byte [sys_model_byte],0FEh ; pc1, pc/xt or pc portable ?
 20526 00000E97 736D                    	jae	short skipstack
 20527                                  doinstallstack:
 20528 00000E99 A1[8A02]                	mov	ax,[stack_count]	; stack_count = 0?
 20529 00000E9C 09C0                    	or	ax,ax			; then, stack size must be 0 too.
 20530 00000E9E 7466                    	jz	short skipstack		; don't install stack.
 20531                                  
 20532                                  ;	dynamic relocation of stack code.
 20533                                  
 20534 00000EA0 E81922                  	call	round			;[memhi] = seg. for stack code
 20535                                  					;[memlo] = 0
 20536                                  
 20537                                  ; set devmark block into memory for mem command
 20538                                  ; devmark_id = 's' for stack
 20539                                  
 20540                                  	;mov	al,devmark_stk	;='S'
 20541                                  	; 23/10/2022
 20542 00000EA3 B053                    	mov	al,'S'
 20543 00000EA5 E86305                  	call	setdevmark
 20544                                  
 20545 00000EA8 A1[E003]                	mov	ax,[memhi]
 20546 00000EAB 8EC0                    	mov	es,ax		;es -> seg. the stack code is going to move.
 20547                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 20548                                  	; 11/12/2022
 20549                                  	; ds = cs
 20550                                  	;push	cs
 20551                                  	;pop	ds
 20552 00000EAD 31F6                    	xor	si,si		;!!we know that stack code is at the beginning of sysinit.
 20553 00000EAF 31FF                    	xor	di,di
 20554 00000EB1 B9[6702]                	mov	cx,endstackcode
 20555 00000EB4 890E[DE03]              	mov	[memlo],cx
 20556 00000EB8 E80122                  	call	round		;have enough space for relocation?
 20557 00000EBB F3A4                    	rep	movsb
 20558                                  
 20559 00000EBD 1E                      	push	ds		; stick the location of the NextStack entry
 20560                                  	;;mov	ax,Bios_Data	; into the Win386 Instance Data tables
 20561                                  	;mov	ax,KERNEL_SEGMENT ; 70h
 20562                                  	; 21/10/2022
 20563 00000EBE B87000                  	mov	ax,DOSBIODATASEG ; 0070h
 20564 00000EC1 8ED8                    	mov	ds,ax
 20565 00000EC3 C706[BE08][1000]        	mov	word [NextStack],nextentry ; (8C0h for MSDOS 6.21 IO.SYS)
 20566 00000EC9 8C06[C008]              	mov	[NextStack+2],es	   ; (8C2h for MSDOS 6.21 IO.SYS)
 20567                                  
 20568 00000ECD 2EA1[DE03]              	mov	ax,[cs:memlo]
 20569 00000ED1 2EA3[8E02]              	mov	[cs:stack_addr],ax ;set for stack area initialization
 20570 00000ED5 A3[C408]                	mov	[IT_StackLoc],ax ; pass it as Instance Data, too
 20571 00000ED8 2EA1[E003]              	mov	ax,[cs:memhi]	;this will be used by stack_init routine.
 20572 00000EDC 2EA3[9002]              	mov	[cs:stack_addr+2],ax
 20573 00000EE0 A3[C608]                	mov	[IT_StackLoc+2],ax
 20574                                  
 20575                                  ;	space for internal stack area = stack_count(entrysize + stack_size)
 20576                                  
 20577                                  	;mov	ax,entrysize ; mov ax,8
 20578                                  	; 23/10/2022
 20579 00000EE3 B80800                  	mov	ax,8
 20580 00000EE6 2E0306[8C02]            	add	ax,[cs:stack_size]
 20581 00000EEB 2EF726[8A02]            	mul	word [cs:stack_count]
 20582                                  
 20583 00000EF0 A3[C808]                	mov	[IT_StackSize],ax ; pass through to Instance Tables
 20584                                  
 20585 00000EF3 1F                      	pop	ds		; no more need to access Instance Table
 20586                                  
 20587 00000EF4 E8C201                  	call	ParaRound	; convert size to paragraphs
 20588                                  	
 20589                                  	; 11/12/2022
 20590                                  	; ds = cs
 20591                                  	;add	[cs:memhi],ax
 20592 00000EF7 0106[E003]              	add	[memhi],ax
 20593                                  	;or	byte [cs:setdevmarkflag],for_devmark ; 2
 20594                                  	;or	byte [cs:setdevmarkflag],2
 20595 00000EFB 800E[2E14]02            	or	byte [setdevmarkflag],2
 20596                                  	;or	byte [setdevmarkflag],for_devmark ; 2
 20597                                  				;to set the devmark_size for stack by round routine.
 20598 00000F00 E8B921                  	call	round		; check for memory error before
 20599                                  				; continuing
 20600 00000F03 E8E902                  	call	stackinit	; initialize hardware stack. 
 20601                                  				; cs=ds=sysinitseg,es=relocated stack code & data
 20602                                  skipstack:
 20603                                  	; 24/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 20604                                  	; (SYSINIT:0F99h)
 20605                                  
 20606                                  	; 11/12/2022
 20607                                  	; ds = cs
 20608                                  	;push	cs
 20609                                  	;pop	ds
 20610                                  
 20611 00000F06 A0[9D02]                	mov	al,[FILES]
 20612 00000F09 30E4                    	xor	ah,ah		; do not use cbw instruction!!!!!
 20613                                  				;  it does sign extend.
 20614 00000F0B 89C1                    	mov	cx,ax
 20615 00000F0D 31DB                    	xor	bx,bx		;close standard input
 20616 00000F0F B43E                    	mov	ah,3Eh ; CLOSE
 20617 00000F11 CD21                    	int	21h
 20618 00000F13 BB0200                  	mov	bx,2
 20619                                  rcclloop:			;close everybody but standard output
 20620 00000F16 B43E                    	mov	ah,3Eh ; CLOSE	; need output so we can print message
 20621 00000F18 CD21                    	int	21h		; in case we can't get new one open.
 20622 00000F1A 43                      	inc	bx
 20623 00000F1B E2F9                    	loop	rcclloop
 20624                                  
 20625 00000F1D BA[6434]                	mov	dx,condev
 20626 00000F20 B002                    	mov	al,2
 20627 00000F22 B43D                    	mov	ah,3Dh ; OPEN 	;open con for read/write
 20628 00000F24 F9                      	stc			; set for possible int 24
 20629 00000F25 CD21                    	int	21h
 20630 00000F27 7305                    	jnc	short goaux
 20631 00000F29 E82324                  	call	badfil
 20632 00000F2C EB13                    	jmp	short goaux2
 20633                                  goaux:	
 20634 00000F2E 50                      	push	ax
 20635 00000F2F BB0100                  	mov	bx,1		;close standard output
 20636 00000F32 B43E                    	mov	ah,3Eh ; CLOSE
 20637 00000F34 CD21                    	int	21h
 20638 00000F36 58                      	pop	ax
 20639                                  
 20640 00000F37 89C3                    	mov	bx,ax		;new device handle
 20641 00000F39 B445                    	mov	ah,45h ; XDUP
 20642 00000F3B CD21                    	int	21h		;dup to 1,stdout
 20643 00000F3D B445                    	mov	ah,45h ; XDUP
 20644 00000F3F CD21                    	int	21h		;dup to 2,stderr
 20645                                  goaux2: 
 20646 00000F41 BA[6834]                	mov	dx,auxdev
 20647 00000F44 B002                    	mov	al,2		;read/write access
 20648 00000F46 E83724                  	call	open_dev
 20649                                  
 20650 00000F49 BA[6C34]                	mov	dx,prndev
 20651 00000F4C B001                    	mov	al,1		;write only
 20652 00000F4E E82F24                  	call	open_dev
 20653                                  
 20654                                  ;global rearm command for shared interrupt devices attached in the system;
 20655                                  ;shared interrupt attachment has some problem when it issues interrupt
 20656                                  ;during a warm reboot. once the interrupt is presented by the attachment,
 20657                                  ;no further interrupts on that level will be presented until a global rearm
 20658                                  ;is issued. by the request of the system architecture group, msbio will
 20659                                  ;issue a global rearm after every device driver is loaded.
 20660                                  ;to issue a global rearm:	;for pc1,xt,palace
 20661                                  ;
 20662                                  ;			  out 02f2h,xx  ; interrupt level 2
 20663                                  ;			  out 02f3h,xx  ; interrupt level 3
 20664                                  ;			  out 02f4h,xx  ; interrupt level 4
 20665                                  ;			  out 02f5h,xx  ; interrupt level 5
 20666                                  ;			  out 02f6h,xx  ; interrupt level 6
 20667                                  ;			  out 02f7h,xx  ; interrupt level 7
 20668                                  ;
 20669                                  ;	for pc at,in addition to the above commands,
 20670                                  ;	need to handle the secondary interrupt handler
 20671                                  ;
 20672                                  ;			  out 06f2h,xx  ; interrupt level 10
 20673                                  ;			  out 06f3h,xx  ; interrupt level 11
 20674                                  ;			  out 06f4h,xx  ; interrupt level 12
 20675                                  ;			  out 06f6h,xx  ; interrupt level 14
 20676                                  ;			  out 06f7h,xx  ; interrupt level 15
 20677                                  ;
 20678                                  ;	for round-up machine
 20679                                  ;
 20680                                  ;			  none.
 20681                                  
 20682                                  ; where xx stands for any value.
 20683                                  ;
 20684                                  ; for your information,after naples level machine,the system service bios
 20685                                  ; call (int 15h),function ah=0c0h returns the system configuration parameters
 20686                                  
 20687                                  	; 24/10/2022
 20688                                  
 20689 00000F51 50                      	push	ax
 20690 00000F52 53                      	push	bx
 20691 00000F53 52                      	push	dx
 20692 00000F54 06                      	push	es
 20693                                  
 20694 00000F55 B0FF                    	mov	al,0FFh 		;reset h/w by writing to port
 20695 00000F57 BAF202                  	mov	dx,2F2h 		;get starting address
 20696 00000F5A EE                      	out	dx,al			; out 02f2h,0ffh
 20697 00000F5B 42                      	inc	dx
 20698 00000F5C EE                      	out	dx,al			; out 02f3h,0ffh
 20699 00000F5D 42                      	inc	dx
 20700 00000F5E EE                      	out	dx,al			; out 02f4h,0ffh
 20701 00000F5F 42                      	inc	dx
 20702 00000F60 EE                      	out	dx,al			; out 02f5h,0ffh
 20703 00000F61 42                      	inc	dx
 20704 00000F62 EE                      	out	dx,al			; out 02f6h,0ffh
 20705 00000F63 42                      	inc	dx
 20706 00000F64 EE                      	out	dx,al			; out 02f7h,0ffh
 20707                                  
 20708                                  ;sb secondary global rearm
 20709                                  
 20710 00000F65 B800F0                  	mov	ax,0F000h		;get machine type
 20711 00000F68 8EC0                    	mov	es,ax
 20712 00000F6A 26803EFEFFFC            	cmp	byte [es:0FFFEh],0FCh ;q:is it a at type machine
 20713 00000F70 740D                    	je	short startrearm	; *if at no need to check
 20714                                  
 20715 00000F72 B4C0                    	mov	ah,0C0h 		;get system configuration
 20716 00000F74 CD15                    	int	15h			; *
 20717 00000F76 7216                    	jc	short finishrearm	; *jmp if old rom
 20718                                  
 20719                                  ; test feature byte for secondary interrupt controller
 20720                                  
 20721 00000F78 26F6470540              	test	byte [es:bx+5],40h
 20722                                  	; 24/10/2022
 20723                                  	;test	byte [es:bx+ROMBIOS_DESC.bios_sd_featurebyte1],ScndIntController
 20724 00000F7D 740F                    	je	short finishrearm	;jmp if it is there
 20725                                  
 20726                                  startrearm:
 20727 00000F7F B0FF                    	mov	al,0FFh 		;write any pattern to port
 20728 00000F81 BAF206                  	mov	dx,6F2h 		;get starting address
 20729 00000F84 EE                      	out	dx,al			;out 06f2h,0ffh
 20730 00000F85 42                      	inc	dx			;bump address
 20731 00000F86 EE                      	out	dx,al			;out 06f3h,0ffh
 20732 00000F87 42                      	inc	dx			;bump address
 20733 00000F88 EE                      	out	dx,al			;out 06f4h,0ffh
 20734 00000F89 42                      	inc	dx			;bump address
 20735 00000F8A 42                      	inc	dx			;bump address
 20736 00000F8B EE                      	out	dx,al			;out 06f6h,0ffh
 20737 00000F8C 42                      	inc	dx			;bump address
 20738 00000F8D EE                      	out	dx,al			;out 06f7h,0ffh
 20739                                  
 20740                                  finishrearm:
 20741 00000F8E 07                      	pop	es
 20742 00000F8F 5A                      	pop	dx
 20743 00000F90 5B                      	pop	bx
 20744 00000F91 58                      	pop	ax
 20745                                  
 20746                                  ;    global rearm end *******************
 20747                                  
 20748                                  ; ----------------------------------------------------------------------
 20749                                  ; allocate sysinit_base for install= command
 20750                                  ; ----------------------------------------------------------------------
 20751                                  ; sysinit_base allocation.
 20752                                  ;   check if endfile has been called to handle install= command.
 20753                                  
 20754                                  set_sysinit_base:
 20755                                  
 20756                                  ; ----------------------------------------------------------------------
 20757                                  ;sysinit_base will be established in the secure area of
 20758                                  ;lower memory when it handles the first install= command.
 20759                                  ;sysinit_base is the place where the actual exec function will be called and
 20760                                  ;will check sysinit module in high memory if it is damaged by the application
 20761                                  ;program.  if sysinit module has been broken,then "memory error..." message
 20762                                  ;is displayed by sysinit_base.
 20763                                  ; ----------------------------------------------------------------------
 20764                                  
 20765                                  	; 24/10/2022 - Retro DOS v4.0 (MSDOS 5.0 IO.SYS, SYSINIT)
 20766                                  	; (SYSINIT:1028h)
 20767                                  
 20768                                  	; 11/12/2022
 20769                                  	; ds = cs
 20770 00000F92 50                      	push	ax			; set devmark for mem command
 20771 00000F93 A1[E003]                	mov	ax,[memhi]
 20772 00000F96 2B06[E403]              	sub	ax,[area]
 20773 00000F9A A3[DC03]                	mov	[impossible_owner_size],ax ;remember the size in case.
 20774                                  	;mov	al,devmark_inst ; 'T'
 20775 00000F9D B054                    	mov	al,'T'
 20776 00000F9F E86904                  	call	setdevmark
 20777 00000FA2 58                      	pop	ax
 20778                                  
 20779 00000FA3 8B3E[E003]              	mov	di,[memhi]
 20780 00000FA7 8EC7                    	mov	es,di
 20781 00000FA9 893E[5003]              	mov	[sysinit_base_ptr+2],di ; save this entry for the next use.
 20782 00000FAD 31FF                    	xor	di,di
 20783 00000FAF 893E[4E03]              	mov	[sysinit_base_ptr],di	; es:di -> destination.
 20784 00000FB3 BE[C510]                	mov	si,sysinit_base		;ds:si -> source code to be relocated.
 20785 00000FB6 B98100                  	mov	cx,end_sysinit_base-sysinit_base ; 129
 20786                                  	; 24/10/2022 
 20787                                  	;mov	cx,128	; 11DCh-115Ch 	; (MSDOS 5.0 IO.SYS, SYSINIT)
 20788 00000FB9 010E[DE03]              	add	[memlo],cx
 20789                                  	;or	byte cs:[setdevmarkflag],for_devmark ; 2
 20790                                  	; 11/12/2022
 20791                                  	; ds = cs
 20792                                  	;or	byte [cs:setdevmarkflag],2
 20793 00000FBD 800E[2E14]02            	or	byte [setdevmarkflag],2
 20794                                  	;or	byte [setdevmarkflag],for_devmark
 20795 00000FC2 E8F720                  	call	round			; check mem error. also,readjust memhi for the next use.
 20796 00000FC5 F3A4                    	rep	movsb			; reallocate it.
 20797                                  
 20798 00000FC7 C706[5203][9E10]        	mov	word [sysinit_ptr],sysinitptr ; returning address from
 20799 00000FCD 8C0E[5403]              	mov	[sysinit_ptr+2],cs	 ; sysinit_base back to sysinit.
 20800                                  	;or	word [install_flag],has_installed ; set the flag.
 20801                                  	;or	byte [install_flag],has_installed ; 2
 20802                                  	; 11/12/2022
 20803 00000FD1 800E[4A03]02            	or	byte [install_flag],2
 20804                                  	; 24/10/2022
 20805                                  	;or	word [install_flag],2	
 20806                                  
 20807                                  ; ----------------------------------------------------------------------
 20808                                  ; free the rest of the memory from memhi to confbot. still from confbot to
 20809                                  ; the top of the memory will be allocated for sysinit and config.sys if
 20810                                  ; have_install_cmd.
 20811                                  ; ----------------------------------------------------------------------
 20812                                  
 20813 00000FD6 E8E320                  	call	round
 20814 00000FD9 8B1E[E003]              	mov	bx,[memhi]
 20815 00000FDD A1[E403]                	mov	ax,[area]
 20816 00000FE0 A3[DA03]                	mov	[old_area],ax		; save [area]
 20817 00000FE3 8EC0                    	mov	es,ax			;calc what we needed
 20818 00000FE5 29C3                    	sub	bx,ax
 20819                                  	; 24/10/2022
 20820 00000FE7 B44A                    	mov	ah,4Ah ; SETBLOCK
 20821 00000FE9 CD21                    	int	21h			;give the rest back
 20822                                  		; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
 20823                                  		; ES = segment address of block to change
 20824                                  		; BX = new size in paragraphs
 20825 00000FEB 06                      	push	es
 20826 00000FEC 8CC0                    	mov	ax,es
 20827 00000FEE 48                      	dec	ax
 20828 00000FEF 8EC0                    	mov	es,ax			;point to arena
 20829                                  	;mov	word [es:ARENA.OWNER],8	;set impossible owner
 20830                                  	;;mov	word [es:ARENA.NAME],4453h	; System Data
 20831                                  	;mov	word [es:ARENA.NAME],'SD'	; System Data
 20832                                  	; 24/10/2022
 20833 00000FF1 26C70601000800          	mov	word [es:1],8		;set impossible owner
 20834 00000FF8 26C70608005344          	mov	word [es:8],'SD'	; System Data
 20835 00000FFF 07                      	pop	es
 20836                                  
 20837 00001000 BBFFFF                  	mov	bx,0FFFFh
 20838 00001003 B448                    	mov	ah,48h ; ALLOC
 20839 00001005 CD21                    	int	21h
 20840 00001007 B448                    	mov	ah,48h ; ALLOC
 20841 00001009 CD21                    	int	21h			; allocate the rest of the memory
 20842                                  		; DOS - 2+ - ALLOCATE MEMORY
 20843                                  		; BX = number of 16-byte paragraphs desired
 20844 0000100B A3[E003]                	mov	[memhi],ax		; start of the allocated memory
 20845 0000100E C706[DE03]0000          	mov	word [memlo],0		;  to be used next.
 20846                                  
 20847                                  ;;;; at this moment,memory from [memhi]:0 to top-of-the memory is
 20848                                  ;;;; allocated.
 20849                                  ;;;; to protect sysinit,confbot module (from confbot (or =alloclim at
 20850                                  ;;;; this time) to the top-of-the memory),here we are going to
 20851                                  ;;;; 1). "setblock" from memhi to confbot.
 20852                                  ;;;; 2). "alloc" from confbot to the top of the memory.
 20853                                  ;;;; 3). "free alloc memory" from memhi to confbot.
 20854                                  
 20855                                  ;memory allocation for sysinit,confbot module.
 20856                                  
 20857 00001014 8EC0                    	mov	es,ax
 20858                                  	;mov	bx,[CONFBOT]
 20859                                  	; 24/10/2022
 20860 00001016 8B1E[A102]              	mov	bx,[top_of_cdss]
 20861 0000101A 29C3                    	sub	bx,ax			; confbot - memhi
 20862 0000101C 4B                      	dec	bx			; make a room for the memory block id.
 20863 0000101D 4B                      	dec	bx			; make sure!!!.
 20864 0000101E B44A                    	mov	ah,4Ah ; SETBLOCK
 20865 00001020 CD21                    	int	21h			; this will free (confbot to top of memory)
 20866                                  		; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
 20867                                  		; ES = segment address of block to change
 20868                                  		; BX = new size in paragraphs
 20869 00001022 BBFFFF                  	mov	bx,0FFFFh
 20870 00001025 B448                    	mov	ah,48h ; ALLOC
 20871 00001027 CD21                    	int	21h
 20872 00001029 B448                    	mov	ah,48h ; ALLOC
 20873 0000102B CD21                    	int	21h			; allocate (confbot to top of memory)
 20874                                  		; DOS - 2+ - ALLOCATE MEMORY
 20875                                  		; BX = number of 16-byte paragraphs desired
 20876 0000102D A3[E403]                	mov	[area],ax		; save allocated memory segment.
 20877                                  					; need this to free this area for command.com.
 20878 00001030 8E06[E003]              	mov	es,[memhi]
 20879 00001034 B449                    	mov	ah,49h			; free allocated memory.
 20880 00001036 CD21                    	int	21h			; free (memhi to confbot(=area))
 20881                                  		; DOS - 2+ - FREE MEMORY
 20882                                  		; ES = segment address of area to be freed
 20883                                  endfile_ret:
 20884 00001038 C3                      	retn
 20885                                  
 20886                                  ; End of "EndFile" DOS structure configuration.
 20887                                  
 20888                                  ; ----------------------------------------------------------------------
 20889                                  ; 26/03/2019 - Retro DOS v4.0
 20890                                  ; 24/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS, SYSINIT)	
 20891                                  ; ----------------------------------------------------------------------
 20892                                  ; Do_Install_Exec
 20893                                  ;
 20894                                  ; This procedure is used to EXEC a program being loaded via the 
 20895                                  ; "install=" mechanism in config.sys. It does this by setting up
 20896                                  ; the parameters, and then jumping to sysinit_base, which has been
 20897                                  ; setup in low memory. When complete, sysinit_base will jump back
 20898                                  ; up to this procedure (if sysinit remains uncorrupted by the installed
 20899                                  ; program).
 20900                                  
 20901                                  ;SYSINIT:10CFh:
 20902                                  
 20903                                  do_install_exec:			; now,handles install= command.
 20904                                  
 20905 00001039 56                      	push	si			; save si for config.sys again.
 20906                                  
 20907                                  ; we are going to call load/exec function.
 20908                                  ; set es:bx to the parameter block here;;;;;;;
 20909                                  ; set ds:dx to the asciiz string. remember that we already has 0
 20910                                  ; after the filename. so parameter starts after that. if next
 20911                                  ; character is a line feed (i.e. 10),then assume that the 0
 20912                                  ; we already encountered used to be a carrage return. in this
 20913                                  ; case,let's set the length to 0 which will be followed by
 20914                                  ; carridge return.
 20915                                  
 20916                                  ; es:si -> command line in config.sys. points to the first non blank
 20917                                  ;character after =.
 20918                                  
 20919 0000103A 06                      	push	es
 20920 0000103B 1E                      	push	ds
 20921 0000103C 07                      	pop	es
 20922 0000103D 1F                      	pop	ds			; es->sysinitseg,ds->confbot seg
 20923 0000103E 89F2                    	mov	dx,si			; ds:dx->file name,0 in config.sys image.
 20924                                  
 20925 00001040 31C9                    	xor	cx,cx
 20926 00001042 FC                      	cld
 20927 00001043 2EC606[6D03]20          	mov	byte [cs:ldexec_start],' ' ; clear out the parm area
 20928 00001049 BF[6E03]                	mov	di,ldexec_parm
 20929                                  installfilename:			; skip the file name
 20930 0000104C AC                      	lodsb				; al = ds:si; si++
 20931 0000104D 3C00                    	cmp	al,0
 20932 0000104F 7402                    	je	short got_installparm
 20933 00001051 EBF9                    	jmp	short installfilename
 20934                                  got_installparm:			; copy the parameters to ldexec_parm
 20935 00001053 AC                      	lodsb
 20936 00001054 268805                  	mov	[es:di],al
 20937 00001057 3C0A                    	cmp	al,lf	; cmp al,0Ah	; line feed?
 20938 00001059 7405                    	je	short done_installparm
 20939 0000105B FEC1                    	inc	cl			; # of char. in the parm.
 20940 0000105D 47                      	inc	di
 20941 0000105E EBF3                    	jmp	short got_installparm
 20942                                  done_installparm:
 20943 00001060 2E880E[6C03]            	mov	byte [cs:ldexec_line],cl ; length of the parm.
 20944 00001065 80F900                  	cmp	cl,0			; if no parm,then
 20945 00001068 7506                    	jne	short install_seg_set 	; let the parm area
 20946 0000106A 2EC606[6D03]0D          	mov	byte [cs:ldexec_start],cr ; 0Dh 
 20947                                  					; starts with cr.
 20948                                  install_seg_set:
 20949 00001070 2EC70600000000          	mov	word [cs:0],0		; make a null environment segment
 20950 00001077 8CC8                    	mov	ax,cs			; by overlap jmp instruction of sysinitseg.
 20951                                  
 20952                                  ;---------------------------------------------------M067----------------
 20953                                  ;
 20954                                  ; 	the environment pointer is made 0. so the current environment ptr.
 20955                                  ; 	will be the same as pdb_environ which after dosinit is 0.
 20956                                  ;
 20957                                  ; 	mov	cs:[instexe.exec0_environ],0 ; set the environment seg.
 20958                                  ;
 20959                                  ; 	instexe.exec0_environ need not be initialized to 0 above. It was
 20960                                  ; 	done as a fix for bug #529. The actual bug was in NLSFUNC and
 20961                                  ; 	was fixed. 
 20962                                  ;
 20963                                  ; ----------------------------------------------------------------------
 20964                                  
 20965                                  ;;ifdef   MULTI_CONFIG
 20966                                  
 20967                                  ; If there's any environment data in "config_wrkseg", pass to app
 20968                                  
 20969                                  	; 24/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS SYSINIT)
 20970                                          ;mov     cx,ax
 20971                                          ;cmp     word [cs:config_envlen],0
 20972                                          ;je      short no_envdata2
 20973                                          ;mov     cx,[cs:config_wrkseg]
 20974                                  ;no_envdata2:
 20975                                  ;;endif  ;MULTI_CONFIG
 20976                                  
 20977                                  	;mov	[cs:instexe.exec0_environ],cx ; set the environment seg.
 20978                                  	; 24/10/2022
 20979                                  	;mov	[cs:iexec.environ],cx
 20980                                  	; 02/11/2022
 20981 00001079 2EA3[BE03]              	mov	[cs:iexec.environ],ax	
 20982                                  
 20983                                  	;mov	[cs:instexe.exec0_com_line+2],ax ; set the seg.
 20984 0000107D 2EA3[C203]              	mov	[cs:iexec.ldexec_line+2],ax
 20985                                  	;mov	[cs:instexe.exec0_5c_fcb+2],ax
 20986 00001081 2EA3[C603]              	mov	[cs:iexec.ldexec_5c_fcb+2],ax
 20987                                  	;mov	[cs:instexe.exec0_6c_fcb+2],ax
 20988 00001085 2EA3[CA03]              	mov	[cs:iexec.ldexec_6c_fcb+2],ax
 20989 00001089 E86E00                  	call	sum_up
 20990 0000108C 26A3[5603]              	mov	[es:checksum],ax	; save the value of the sum
 20991 00001090 31C0                    	xor	ax,ax
 20992 00001092 B44B                    	mov	ah,4Bh ; EXEC		; load/exec
 20993 00001094 BB[BE03]                	mov	bx,instexe		; es:bx -> parm block.
 20994 00001097 06                      	push	es			; save es,ds for load/exec
 20995 00001098 1E                      	push	ds			; these registers will be restored in sysinit_base.
 20996 00001099 2EFF2E[4E03]            	jmp	far [cs:sysinit_base_ptr] ; jmp to sysinit_base to execute
 20997                                  					; load/exec function and check sum.
 20998                                  
 20999                                  ;----------------------------------------
 21000                                  
 21001                                  ;j.k. this is the returning address from sysinit_base.
 21002                                  
 21003                                  	; 24/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS SYSINIT)
 21004                                  
 21005                                  sysinitptr:				; returning far address from sysinit_base
 21006 0000109E 5E                      	pop	si			; restore si for config.sys file.
 21007 0000109F 06                      	push	es
 21008 000010A0 1E                      	push	ds
 21009 000010A1 07                      	pop	es
 21010 000010A2 1F                      	pop	ds			; now ds - sysinitseg, es - confbot
 21011 000010A3 7306                            jnc     short install_exit_ret
 21012                                  
 21013 000010A5 56                      	push	si			; error in loading the file for install=.
 21014 000010A6 E8AA22                  	call	badload 		; es:si-> path,filename,0.
 21015 000010A9 5E                      	pop	si
 21016                                  
 21017                                  	; 24/10/2022
 21018                                  	;jmp	short sysinitptr_retn ; (MSDOS 5.0 IO.SYS, SYSINIT:1140h)
 21019                                  	; 11/12/2022
 21020                                  	; ds = cs
 21021 000010AA C3                      	retn
 21022                                  
 21023                                  install_exit_ret:
 21024                                  	;retn		; retn (MSDOS 6.21 IO.SYS, SYSINIT:1283h) ; 18/12/2022
 21025                                  
 21026                                  	; 24/10/2022 (MSDOS 5.0 IO.SYS SYSINIT)
 21027                                  ;SYSINIT:1142h:
 21028 000010AB B44D                    	mov     ah,4Dh
 21029 000010AD CD21                    	int     21h             ; DOS - 2+ - GET EXIT CODE OF SUBPROGRAM (WAIT)
 21030 000010AF 80FC03                  	cmp     ah,3
 21031 000010B2 7404                    	jz      short sysinitptr_retn
 21032 000010B4 E88F16                  	call    error_line
 21033 000010B7 F9                      	stc
 21034                                  sysinitptr_retn:	; (SYSINIT:114Fh)
 21035 000010B8 C3                      	retn		
 21036                                  
 21037                                  ; ----------------------------------------------------------------------
 21038                                  
 21039                                  ;**	ParaRound - Round Up length to paragraph multiple
 21040                                  ;
 21041                                  ;	ParaRound rounds a byte count up to a multiple of 16, then divides
 21042                                  ;	by 16 yielding a "length in paragraphs" value.
 21043                                  ;
 21044                                  ;	ENTRY	(ax) = byte length
 21045                                  ;	EXIT	(ax) = rounded up length in paragraphs
 21046                                  ;	USES	ax, flags
 21047                                  
 21048                                  ParaRound:
 21049 000010B9 83C00F                  	add	ax,15
 21050 000010BC D1D8                    	rcr	ax,1
 21051 000010BE D1E8                    	shr	ax,1
 21052 000010C0 D1E8                    	shr	ax,1
 21053 000010C2 D1E8                    	shr	ax,1
 21054 000010C4 C3                      	retn
 21055                                  
 21056                                  ; ----------------------------------------------------------------------
 21057                                  ; sysinit_base module.
 21058                                  ;
 21059                                  ; This module is relocated by the routine EndFile to a location in low
 21060                                  ; memory. It is then called by SYSINIT to perform the EXEC of programs
 21061                                  ; that are being loaded by the "install=" command. After the EXEC call
 21062                                  ; completes, this module performs a checksum on the SYSINIT code (at the
 21063                                  ; top of memory) to be sure that the EXECed program did not damage it.
 21064                                  ; If it did, then this module will print an error message and stop the
 21065                                  ; system. Otherwise, it returns control to SYSINIT.
 21066                                  ;
 21067                                  ;in: after relocation,
 21068                                  ;    ax = 4b00h - load and execute the program dos function.
 21069                                  ;    ds = confbot. segment of config.sys file image
 21070                                  ;    es = sysinitseg. segment of sysinit module itself.
 21071                                  ;    ds:dx = pointer to asciiz string of the path,filename to be executed.
 21072                                  ;    es:bx = pointer to a parameter block for load.
 21073                                  ;    SI_end (byte) - offset vaule of end of sysinit module label
 21074                                  ;    bigsize (word) - # of word from confbot to SI_end.
 21075                                  ;    chksum (word) - sum of every byte from confbot to SI_end in a
 21076                                  ;			word boundary moduler form.
 21077                                  ;    sysinit_ptr (dword ptr) - return address to sysinit module.
 21078                                  ;
 21079                                  ;note: sysinit should save necessary registers and when the control is back
 21080                                  
 21081                                  	; 24/10/2022
 21082                                  	; (SYSINIT:115Ch for MSDOS 5.0 SYSINIT)
 21083                                  sysinit_base:				
 21084 000010C5 2E8C166200              	mov	[cs:sysinit_base_ss],ss	; save stack
 21085 000010CA 2E89266400              	mov	[cs:sysinit_base_sp],sp	
 21086 000010CF CD21                    	int	21h			; load/exec dos call.
 21087 000010D1 2E8E166200              	mov	ss,[cs:sysinit_base_ss]	; restore stack
 21088 000010D6 2E8B266400              	mov	sp,[cs:sysinit_base_sp]
 21089 000010DB 1F                      	pop	ds			; restore confbot seg
 21090 000010DC 07                      	pop	es			; restore sysinitseg
 21091 000010DD 7216                    	jc	short sysinit_base_end	; load/exec function failed.
 21092                                  					; at this time,i don't have to worry about
 21093                                  					; that sysinit module has been broken or not.
 21094 000010DF E81800                  	call	sum_up			; otherwise,check if it is good.
 21095 000010E2 263906[5603]            	cmp	[es:checksum],ax
 21096 000010E7 740C                    	je	short sysinit_base_end
 21097                                  
 21098                                  ;	memory broken. show "memory allocation error" message and stall.
 21099                                  
 21100 000010E9 B409                    	mov	ah,9
 21101 000010EB 0E                      	push	cs
 21102 000010EC 1F                      	pop	ds
 21103 000010ED BA6600                  	mov	dx,mem_alloc_err_msgx-sysinit_base ; 65h (for MSDOS 5.0 SYSINIT)
 21104 000010F0 CD21                    	int	21h
 21105                                  		; DOS - PRINT STRING
 21106                                  		; DS:DX -> string terminated by "$"
 21107                                  	; 24/10/2022
 21108                                  _stall: 
 21109                                  	; 11/12/2022
 21110 000010F2 F4                      	hlt 
 21111                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 21112                                  	;hlt				;use HLT to minimize energy consumption
 21113 000010F3 EBFD                            jmp	short _stall
 21114                                  
 21115                                  sysinit_base_end: 
 21116 000010F5 26FF2E[5203]            	jmp	far [es:sysinit_ptr]	;return back to sysinit module
 21117                                  
 21118                                  ;-------------------------------------
 21119                                  
 21120                                  sum_up:
 21121                                  
 21122                                  ;in:   es - sysinitseg.
 21123                                  ;out:  ax - result
 21124                                  ;
 21125                                  ;remark: since this routine will only check starting from "locstack" to the end of
 21126                                  ;	 sysinit segment,the data area, and the current stack area are not
 21127                                  ;	 coverd. in this sense,this check sum routine only gives a minimal
 21128                                  ;	 gaurantee to be safe.
 21129                                  ;
 21130                                  ;first sum up confbot seg.
 21131                                  
 21132 000010FA 1E                      	push	ds
 21133                                  	;mov	ax,[es:CONFBOT]
 21134                                  	; 24/10/2022
 21135 000010FB 26A1[A102]              	mov	ax,[es:top_of_cdss]
 21136 000010FF 8ED8                    	mov	ds,ax
 21137 00001101 31F6                    	xor	si,si
 21138 00001103 31C0                    	xor	ax,ax
 21139 00001105 268B0E[4C03]            	mov	cx,[es:config_size]	; if config_size has been broken,then this
 21140                                  					;whole test better fail.
 21141 0000110A D1E9                    	shr	cx,1			; make it a word count
 21142 0000110C 7406                    	jz	short sum_sys_code	; when config.sys file not exist.
 21143                                  sum1:
 21144 0000110E 0304                    	add	ax,[si]
 21145 00001110 46                      	inc	si
 21146 00001111 46                      	inc	si
 21147 00001112 E2FA                    	loop	sum1
 21148                                  ;now,sum up sysinit module.
 21149                                  sum_sys_code:
 21150                                  	; 24/10/2022
 21151 00001114 BE1411                  	mov	si,locstack ; 5A6h (MSDOS 5.0 IO.SYS, SYSINIT)
 21152                                  				        ; starting after the stack.  M069
 21153                                  					;  this does not cover the possible stack code!!!
 21154                                  	;;mov	cx,22688  ; for MSDOS 6.21 IO.SYS
 21155                                  	; 02/11/2022
 21156                                  	;mov	cx,3D20h  ; (15648) for MSDOS 5.0 IO.SYS (SYSINIT)	
 21157                                  	; 30/12/2022 (BugFix)
 21158                                  	; (SI_End is 39D0h for this -Retro DOS v4.0- IO.SYS)
 21159 00001117 B9[6039]                	mov	cx,SI_end ; (22688) 	; SI_end is the label at the end of sysinit
 21160 0000111A 29F1                    	sub	cx,si			;  from after_checksum to SI_end
 21161 0000111C D1E9                    	shr	cx,1
 21162                                  sum2:
 21163 0000111E 260304                  	add	ax,[es:si]
 21164 00001121 46                      	inc	si
 21165 00001122 46                      	inc	si
 21166 00001123 E2F9                    	loop	sum2
 21167 00001125 1F                      	pop	ds
 21168 00001126 C3                      	retn
 21169                                  
 21170                                  ; 24/10/2022 - Retro DOS 4.0 (Modified MSDOS 5.0 IO.SYS, SYSINIT)
 21171                                  
 21172                                  sysinit_base_ss equ $-sysinit_base  ; = 61 (MSDOS 5.0 IO.SYS, SYSINIT:115Ch)
 21173                                  ;SYSINIT:11BDh:
 21174 00001127 0000                    	dw	0
 21175                                  sysinit_base_sp equ $-sysinit_base  ; = 63 (MSDOS 5.0 IO.SYS, SYSINIT:1161h)
 21176                                  ;SYSINIT:11BFh:
 21177 00001129 0000                    	dw	0
 21178                                  
 21179                                  mem_alloc_err_msgx:
 21180                                  
 21181                                         ;include msbio.cl4		; memory allocation error message
 21182                                  
 21183                                  ;SYSINIT:12F6:  ; MSDOS 6.21 IO.SYS SYSINIT:12F6h
 21184 0000112B 0D0A                    	db	0Dh,0Ah
 21185 0000112D 4D656D6F727920616C-     	db 	'Memory allocation error $'
 21185 00001136 6C6F636174696F6E20-
 21185 0000113F 6572726F722024     
 21186                                  
 21187                                  end_sysinit_base: ; label byte
 21188                                  	; 24/10/2022
 21189                                  	; (SYSINIT:11DCh for MSDOS 5.0 SYSINIT)
 21190                                  
 21191                                  ; ----------------------------------------------------------------------
 21192                                  ; Set_Buffer
 21193                                  ;
 21194                                  ;function: set buffers in the real memory.				  
 21195                                  ;	   lastly set the memhi,memlo for the next available free address.
 21196                                  ;
 21197                                  ;input:    ds:bx -> buffinfo.
 21198                                  ;	   [memhi]:[memlo = 0] = available space for the hash bucket.	  
 21199                                  ;	   singlebuffersize = buffer header size + sector size		  
 21200                                  ;
 21201                                  ;output:   buffers Queue established.	       				   
 21202                                  ;	   [memhi]:[memlo] = address of the next available free space.	   
 21203                                  ; ----------------------------------------------------------------------
 21204                                  
 21205                                  	; 25/10/2022 - Retro DOS 4.0 (Modified MSDOS 5.0 IO.SYS, SYSINIT)
 21206                                  	; (SYSINIT:11DCh)
 21207                                  
 21208                                  set_buffer:
 21209 00001146 30D2                    	xor	dl,dl				; assume buffers not in HMA
 21210 00001148 E85500                  	call	GetBufferAddr
 21211 0000114B 7402                    	jz	short set_buff_1
 21212 0000114D B201                    	mov	dl,1				; buffers in HMA
 21213                                  set_buff_1:
 21214                                  	; 25/10/2022
 21215                                  	;mov	[bx+BUFFINF.Buff_Queue],di	; head of Buff Q
 21216 0000114F 893F                    	mov	[bx],di
 21217                                  	;mov	[bx+BUFFINF.Buff_Queue+2],es
 21218 00001151 8C4702                  	mov	[bx+2],es
 21219                                  	;mov	word [bx+BUFFINF.Dirty_Buff_Count],0 ;set dirty_count to 0.
 21220 00001154 C747040000              	mov	word [bx+4],0
 21221                                  
 21222 00001159 89F8                    	mov	ax,di
 21223 0000115B 2E8B0E[9702]            	mov	cx,[cs:buffers]
 21224 00001160 57                      	push	di				; remember first buffer
 21225                                  
 21226                                  ;	for each buffer
 21227                                  
 21228                                  nxt_buff:
 21229 00001161 E86300                  	call	set_buffer_info 		; set buf_link,buf_id...
 21230 00001164 89C7                    	mov	di,ax
 21231 00001166 E2F9                    	loop	nxt_buff
 21232                                  
 21233 00001168 2E2B3E[9B02]            	sub	di,[cs:singlebuffersize]	; point to last buffer
 21234                                  
 21235 0000116D 59                      	pop	cx				; get first buffer
 21236                                  	;mov	[es:di+buffinfo.buf_next],cx	; last->next = first
 21237 0000116E 26890D                  	mov	[es:di],cx
 21238 00001171 87CF                    	xchg	cx,di
 21239                                  	;mov	[es:di+buffinfo.buf_prev],cx	; first->prev = last
 21240                                  	; 25/10/2022
 21241 00001173 26894D02                	mov	[es:di+2],cx
 21242                                  
 21243 00001177 08D2                    	or	dl,dl				; In HMa ?
 21244 00001179 7417                    	jz	short set_buff_2		; no
 21245                                  	;mov	byte [bx+BUFFINF.Buff_In_HMA],1
 21246 0000117B C6470C01                	mov	byte [bx+12],1
 21247 0000117F 2EA1[E003]              	mov	ax,[cs:memhi]			; seg of scratch buff
 21248                                  	;mov	word [bx+BUFFINF.Lo_Mem_Buff],0	; offset of sctarch buff is 0
 21249 00001183 C7470D0000              	mov	word [bx+13],0
 21250                                  	;mov	[bx+BUFFINF.Lo_Mem_Buff+2],ax
 21251 00001188 89470F                  	mov	word [bx+15],ax
 21252 0000118B 2EA1[9B02]              	mov	ax,[cs:singlebuffersize]	; size of scratch buff
 21253                                  	;sub	ax,bufinsiz ; 20		; buffer head not required
 21254 0000118F 83E814                  	sub	ax,20
 21255                                  set_buff_2:
 21256 00001192 2E0106[DE03]            	add	[cs:memlo],ax
 21257                                  	;or	byte [cs:setdevmarkflag],for_devmark ; 2
 21258 00001197 2E800E[2E14]02          	or	byte [cs:setdevmarkflag],2
 21259                                  	;call	round
 21260                                  	;retn
 21261                                  	; 12/12/2022
 21262 0000119D E91C1F                  	jmp	round
 21263                                  
 21264                                  ; ----------------------------------------------------------------------
 21265                                  ; procedure : GetBufferAddr
 21266                                  ;
 21267                                  ;	      Gets the buffer address either in HMA or in Lo Mem
 21268                                  ;
 21269                                  ; returns in es:di the buffer adress
 21270                                  ; returns NZ if allocated in HMA
 21271                                  ; ----------------------------------------------------------------------
 21272                                  
 21273                                  	; 25/10/2022 
 21274                                  GetBufferAddr:
 21275 000011A0 53                      	push	bx
 21276 000011A1 52                      	push	dx
 21277 000011A2 2EA1[9B02]              	mov	ax, [cs:singlebuffersize]
 21278 000011A6 2EF726[9702]            	mul	word [cs:buffers]
 21279                                  	;add	ax,0Fh
 21280 000011AB 83C00F                  	add	ax,15 
 21281                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 21282                                  	;and	ax,~15	; 0FFF0h	; para round
 21283                                  	; 12/12/2022
 21284 000011AE 24F0                    	and	al,~15	; 0F0h
 21285 000011B0 89C3                    	mov	bx,ax
 21286 000011B2 B8024A                  	mov	ax,4A02h
 21287                                  	;mov	ax,((multMULT<<8)+multMULTALLOCHMA)
 21288 000011B5 CD2F                    	int	2Fh
 21289 000011B7 83FFFF                  	cmp	di,0FFFFh
 21290 000011BA 7508                    	jne	short got_hma
 21291 000011BC BF0000                  	mov	di,0			; dont xor di,di Z flag needed
 21292                                  	;zf=1
 21293                                  	;xor	di,di	; 25/10/2022
 21294                                  	;zf=1
 21295 000011BF 2E8E06[E003]            	mov	es,[cs:memhi]
 21296                                  got_hma:
 21297 000011C4 5A                      	pop	dx
 21298 000011C5 5B                      	pop	bx
 21299 000011C6 C3                      	retn
 21300                                  
 21301                                  ; ----------------------------------------------------------------------
 21302                                  
 21303                                  set_buffer_info:
 21304                                  
 21305                                  ;function: set buf_link,buf_id,buf_sector
 21306                                  ;
 21307                                  ;in: es:di -> buffer header to be set.
 21308                                  ;    ax = di
 21309                                  ;
 21310                                  ;out:
 21311                                  ;    above entries set.
 21312                                  
 21313                                  	; 25/10/2022 
 21314 000011C7 2EFF36[3903]            	push	word [cs:buf_prev_off]
 21315                                  	;pop	word [es:di+buffinfo.buf_prev]
 21316 000011CC 268F4502                	pop	word [es:di+2]
 21317 000011D0 2EA3[3903]              	mov	[cs:buf_prev_off],ax
 21318 000011D4 2E0306[9B02]            	add	ax,[cs:singlebuffersize]	;adjust ax
 21319                                  	;mov	[es:di+buffinfo.buf_next],ax
 21320 000011D9 268905                  	mov	[es:di],ax
 21321                                  	;mov	word [es:di+buffinfo.buf_ID],00FFh  ; new buffer free
 21322 000011DC 26C74504FF00            	mov	word [es:di+4],00FFh
 21323                                  	;mov	word [es:di+buffinfo.buf_sector],0   ; to compensate the masm 3 bug
 21324 000011E2 26C745060000            	mov	word [es:di+6],0
 21325                                  	;mov	word [es:di+buffinfo.buf_sector+2],0 ; to compensate the masm 3 bug
 21326 000011E8 26C745080000            	mov	word [es:di+8],0
 21327 000011EE C3                      	retn
 21328                                  
 21329                                  ; ======================================================================
 21330                                  ; MSSTACK initialization routine - MSDOS 6.0 - SYSDINIT1.ASM - 1991
 21331                                  ; ----------------------------------------------------------------------
 21332                                  ; 27/03/2019 - Retro DOS v4.0
 21333                                  
 21334                                  ; ----------------------------------------------------------------------
 21335                                  ; ibmstack initialization routine.
 21336                                  ;
 21337                                  ;	to follow the standard interrupt sharing scheme, msstack.asm
 21338                                  ;	has been modified. this initialization routine also has to
 21339                                  ;	be modified because for the interrupt level 7 and 15, firstflag
 21340                                  ;	should be set to signal that this interrupt handler is the
 21341                                  ;	first handler hooked to this interrupt vector.
 21342                                  ;	we determine this by looking at the instruction pointed by
 21343                                  ;	this vector. if it is iret, then this handler should be the
 21344                                  ;	first one. in our case, only the interrupt vector 77h is the
 21345                                  ;	interrupt level 15. (we don't hook interrupt level 7.)
 21346                                  ;
 21347                                  ;	the followings are mainly due to m.r.t; ptm fix of p886 12/3/86
 21348                                  ;	some design changes are needed to the above interrupt sharing
 21349                                  ;	method. the above sharing scheme assumes that 1). interrupt
 21350                                  ;	sharing is never done on levels that have bios support. 2). "phantom"
 21351                                  ;	interrupts would only be generated on levels 7 and 15.
 21352                                  ;	these assumptions are not true any more. we have to use the firstflag
 21353                                  ;	for every level of interrupt. we will set the firstflag on the following
 21354                                  ;	conditions:
 21355                                  ;
 21356                                  ;	 a.	 if the cs portion of the vector is 0000, then "first"
 21357                                  ;	 b. else if cs:ip points to valid shared header, then not "first"
 21358                                  ;	 c. else if cs:ip points to an iret, then "first"
 21359                                  ;	 d. else if cs:ip points to dummy, then "first"
 21360                                  ;
 21361                                  ;	where dummy is - the cs portion must be f000, and the ip portion must
 21362                                  ;	be equal to the value at f000:ff01. this location is the initial value
 21363                                  ;	from vector_table for interrupt 7, one of the preserved addresses in all
 21364                                  ;	the bioses for all of the machines.
 21365                                  ;
 21366                                  ;	system design group requests bios to handle the phantom interrupts.
 21367                                  ;
 21368                                  ;	the "phantom" interrupt is an illegal interrupt such as an interrupt
 21369                                  ;	produced by the bogus adapter card even without interrupt request is
 21370                                  ;	set.  more specifically, 1). the 8259 has a feature when running in
 21371                                  ;	edge triggered mode to latch a pulse and present the interrupt when
 21372                                  ;	the processor indicates interrupt acknowledge (inta). the interrupt
 21373                                  ;	pulse was exist at the time of inta to get a "phantom" interrupt.
 21374                                  ;	2). or, this is caused by adapter cards placing a glitch on the
 21375                                  ;	interrupt line.
 21376                                  ;
 21377                                  ;	to handle those "phantom" interrupts, the main stack code will check
 21378                                  ;	the own firstflag, and if it is not "first" (which means the forward
 21379                                  ;	pointer points to the legal shared interrupt handler), then pass the
 21380                                  ;	control. if it is the first, then the following action should be
 21381                                  ;	taken. we don't have to implement skack logic in this case.
 21382                                  ;
 21383                                  ;	to implement this logic, we rather choose a simple method.
 21384                                  ;	if ont of the above "firstflag" conditions is met, we are not
 21385                                  ;	going to hook this interrupt vector. the reason is if the original
 21386                                  ;	vector points to "iret" and do nothing, we don't need
 21387                                  ;	to implement the stack logic for it. this will simplify implementation
 21388                                  ;	while maintaining compatibility with the old version of dos.
 21389                                  ;	this implies that in the main stack code, there might be a stack code
 21390                                  ;	that will never be used, a dead code.
 21391                                  ;
 21392                                  ;in - cs, ds -> sysinitseg, es -> relocated stack code & data.
 21393                                  
 21394                                  	; 25/10/2022 - Retro DOS 4.0 (Modified MSDOS 5.0 IO.SYS, SYSINIT)
 21395                                  	; (SYSINIT:1287h)
 21396                                  
 21397                                  	; 14/12/2022
 21398                                  stackinit:
 21399 000011EF 50                      	push	ax
 21400 000011F0 1E                      	push	ds
 21401 000011F1 06                      	push	es
 21402 000011F2 53                      	push	bx
 21403 000011F3 51                      	push	cx
 21404 000011F4 52                      	push	dx
 21405 000011F5 57                      	push	di
 21406 000011F6 56                      	push	si
 21407 000011F7 55                      	push	bp
 21408                                  
 21409                                  ;currently es -> stack code area
 21410                                  
 21411                                  	; 12/12/2022
 21412                                  	; ds = cs
 21413 000011F8 A1[8A02]                	mov	ax,[stack_count]
 21414 000011FB 89C1                    	mov	cx,ax  ; *!*!*  
 21415                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 21416                                  	; (MSDOS 5.0 IO.SYS - SYSINIT:1290h)
 21417                                  	;mov	ax,[cs:stack_count] ; !!	;defined in cs
 21418 000011FD 26A3[0200]              	mov	[es:stackcount],ax		;defined in stack code area
 21419                                  	; (MSDOS 5.0 IO.SYS - SYSINIT:1298h)
 21420 00001201 A1[8C02]                	mov	ax,[stack_size]	 ; !!		;in cs
 21421 00001204 26A3[0600]              	mov	[es:stacksize],ax
 21422                                  	; 12/12/2022
 21423 00001208 A1[8E02]                	mov	ax,[stack_addr]			; offset
 21424                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 21425                                  	; (MSDOS 5.0 IO.SYS - SYSINIT:129Fh)
 21426                                  	;mov	ax,[cs:stack_addr]  ; !!
 21427 0000120B 26A3[0800]              	mov	[es:stacks],ax
 21428                                  	; 12/12/2022
 21429 0000120F 89C5                    	mov	bp,ax ; *!*
 21430 00001211 A1[9002]                	mov	ax,[stack_addr+2]
 21431                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 21432                                  	; (MSDOS 5.0 IO.SYS - SYSINIT:129Fh)
 21433                                  	;mov	ax,[cs:stack_addr+2] ; !!	; segment
 21434 00001214 26A3[0A00]              	mov	[es:stacks+2],ax
 21435                                  
 21436                                  ; initialize the data fields with the parameters
 21437                                  
 21438                                  ; "firstentry" will always be at stacks
 21439                                  
 21440                                  	;mov	bp,[es:stacks]			; get offset of stack
 21441                                  	; 12/12/2022
 21442                                  	; bp = [es:stacks] ; *!*
 21443 00001218 26892E[0C00]            	mov	[es:firstentry],bp
 21444                                  
 21445                                  ; the stacks will always immediately follow the table entries
 21446                                  
 21447 0000121D B80800                  	mov	ax,entrysize ; 8
 21448                                  	;mov	cx,[es:stackcount]
 21449                                  	; 12/12/2022
 21450                                  	; cx = [es:stackcount] ; *!*!*
 21451 00001220 F7E1                    	mul	cx
 21452 00001222 01E8                    	add	ax,bp
 21453 00001224 26A3[0400]              	mov	[es:stackat],ax
 21454 00001228 89C3                    	mov	bx,ax
 21455 0000122A 83EB02                  	sub	bx,2
 21456                                  
 21457                                  ; zero the entire stack area to start with
 21458                                  
 21459 0000122D 268B3E[0400]            	mov	di,[es:stackat]
 21460 00001232 26A1[0600]              	mov	ax,[es:stacksize]
 21461 00001236 F7E1                    	mul	cx
 21462 00001238 89C1                    	mov	cx,ax
 21463 0000123A 31C0                    	xor	ax,ax
 21464 0000123C 06                      	push	es
 21465 0000123D 1F                      	pop	ds				;ds = relocated stack code seg.
 21466                                  
 21467                                  ;now, ds -> stack code area
 21468                                  
 21469 0000123E 8E06[0A00]              	mov	es,[stacks+2]			; get segment of stack area.
 21470 00001242 FC                      	cld
 21471 00001243 F3AA                    	rep	stosb
 21472                                  
 21473 00001245 8B0E[0200]              	mov	cx,[stackcount]
 21474                                  
 21475                                  ; loop for "count" times, building a table entry
 21476                                  ;  cs = sysinitseg, ds = relocated stack code seg, es = segment of stack space
 21477                                  ;  cx = number of entries
 21478                                  ;  es:bp => base of stacks - 2
 21479                                  ;  es:bx => first table entry
 21480                                  
 21481                                  buildloop:
 21482                                  	; 11/12/2022
 21483                                  	;mov	byte [es:bp+allocbyte],free	; mov [es:bp+0],0
 21484                                  	; 25/10/2022
 21485 00001249 26C6460000              	mov	byte [es:bp],free
 21486 0000124E 26884601                	mov	[es:bp+intlevel],al	; ax = 0
 21487                                  	;mov	[es:bp+1],al
 21488 00001252 26894602                	mov	[es:bp+savedsp],ax
 21489                                  	;mov	[es:bp2],ax
 21490 00001256 26894604                	mov	[es:bp+savedss],ax
 21491                                  	;mov	[es:bp+4],ax
 21492 0000125A 031E[0600]              	add	bx,[stacksize]
 21493 0000125E 26895E06                	mov	[es:bp+newsp],bx		; mov [es:bp+6],bx
 21494                                  	;mov	[es:bp+6],bx
 21495 00001262 26892F                  	mov	[es:bx],bp
 21496 00001265 83C508                  	add	bp,entrysize ; 8
 21497                                  
 21498 00001268 E2DF                    	loop	buildloop
 21499                                  
 21500 0000126A 83ED08                  	sub	bp,entrysize ; 8
 21501 0000126D 892E[0E00]              	mov	[lastentry],bp
 21502 00001271 892E[1000]              	mov	[nextentry],bp
 21503                                  
 21504 00001275 1E                      	push	ds
 21505 00001276 B800F0                  	mov	ax,0F000h		;look at the model byte
 21506 00001279 8ED8                    	mov	ds,ax
 21507 0000127B 803EFEFFF9              	cmp	byte [0FFFEh],0F9h ; mdl_convert ;convertible?
 21508 00001280 1F                      	pop	ds
 21509 00001281 7504                    	jne	short skip_disablenmis
 21510                                  
 21511 00001283 B007                    	mov	al,07h			; disable convertible nmis
 21512 00001285 E672                    	out	72h,al
 21513                                  
 21514                                  skip_disablenmis:
 21515 00001287 31C0                    	xor	ax,ax
 21516 00001289 8EC0                    	mov	es,ax			;es - segid of vector table at 0
 21517                                  					;ds - relocated stack code segment
 21518 0000128B FA                      	cli
 21519                                  
 21520                                  	;irp	aa,<02,08,09,70>
 21521                                  	;
 21522                                  	;mov	si,aa&h*4		;pass where vector is to be adjusted
 21523                                  	;mov	di,offset int19old&aa	;we have to set old&aa for int19 handler too.
 21524                                  	;mov	bx,offset old&aa	;pass where to save original owner pointer
 21525                                  	;mov	dx,offset int&aa	;pass where new handler is
 21526                                  	;call	new_init_loop		;adjust the vector to new handler,
 21527                                  	;				;saving pointer to original owner
 21528                                  	;endm
 21529                                  
 21530                                  stkinit_02:
 21531 0000128C BE0800                  	mov	si,02h*4 ; 8
 21532 0000128F BF[4206]                	mov	di,INT19OLD02
 21533 00001292 BB[1200]                	mov	bx,old02
 21534 00001295 BA[1600]                	mov	dx,int02
 21535 00001298 E84901                  	call	new_init_loop
 21536                                  stkinit_08:
 21537 0000129B BE2000                  	mov	si,08h*4 ; 32
 21538 0000129E BF[4706]                	mov	di,INT19OLD08
 21539 000012A1 BB[3800]                	mov	bx,old08
 21540 000012A4 BA[3C00]                	mov	dx,int08
 21541 000012A7 E83A01                  	call	new_init_loop
 21542                                  stkinit_09:
 21543 000012AA BE2400                  	mov	si,09h*4 ; 36
 21544 000012AD BF[4C06]                	mov	di,INT19OLD09
 21545 000012B0 BB[4100]                	mov	bx,old09
 21546 000012B3 BA[4500]                	mov	dx,int09
 21547 000012B6 E82B01                  	call	new_init_loop
 21548                                  stkinit_70:
 21549 000012B9 BEC001                  	mov	si,70h*4 ; 448
 21550 000012BC BF[6A06]                	mov	di,INT19OLD70
 21551 000012BF BB[4E00]                	mov	bx,old70
 21552 000012C2 BA[5200]                	mov	dx,int70
 21553 000012C5 E81C01                  	call	new_init_loop
 21554                                  
 21555                                  	;irp	aa,<0a,0b,0c,0d,0e,72,73,74,76,77> ;shared interrupts
 21556                                  	;
 21557                                  	;mov	si,aa&h*4		;pass where vector is to be adjusted
 21558                                  	;push	ds			;save relocated stack code segment
 21559                                  	;lds	bx, es:[si]		;ds:bx -> original interrupt handler
 21560                                  	;push	ds
 21561                                  	;pop	dx			;dx = segment value
 21562                                  	;	
 21563                                  	;cmp	dx,0
 21564                                  	;jz	int&aa&_first
 21565                                  	;
 21566                                  	;cmp	byte ptr ds:[bx],0cfh	;does vector point to an iret?
 21567                                  	;jz	int&aa&_first
 21568                                  	;
 21569                                  	;cmp	word ptr ds:[bx.6],424bh ;magic offset (see int&aa, msstack.inc)
 21570                                  	;jz	int&aa&_not_first
 21571                                  	;
 21572                                  	;cmp	dx,0f000h		;rom bios segment
 21573                                  	;jnz	int&aa&_not_first
 21574                                  	;
 21575                                  	;push	es
 21576                                  	;push	dx
 21577                                  	;mov	dx,0f000h
 21578                                  	;mov	es,dx
 21579                                  	;cmp	bx,word ptr es:0ff01h
 21580                                         	;pop	dx
 21581                                  	;pop	es
 21582                                  	;jz	int&aa&_first
 21583                                  	;
 21584                                  ;int&aa&_not_first:			;not the first. we are going to hook vector.
 21585                                  	;pop	ds
 21586                                  	;mov	di, offset int19old&aa	;we have to set old&aa for int19 handler too.
 21587                                  	;mov	bx, offset old&aa	;pass where to save original owner pointer
 21588                                  	;mov	dx, offset int&aa	;pass where new handler is
 21589                                  	;call	new_init_loop		;adjust the vector to new handler, saving
 21590                                  	;				;pointer to original owner.
 21591                                  	;jmp	short int&aa&_end
 21592                                  ;int&aa&_first:				;the first. don't have to hook stack code.
 21593                                  	;pop	ds
 21594                                  ;int&aa&_end:
 21595                                  	;
 21596                                  	;endm
 21597                                  
 21598                                  stkinit_0A:
 21599 000012C8 BE2800                  	mov	si,0Ah*4 ; 40
 21600                                  	
 21601                                  ; 14/12/2022
 21602                                  %if 0	
 21603                                  	; 25/10/2022 (MSDOS 5.0 IO.SYS compatibility)
 21604                                  	push	ds
 21605                                  	
 21606                                  	lds	bx,[es:si]
 21607                                  	push	ds
 21608                                  	pop	dx
 21609                                  		
 21610                                  	cmp	dx,0
 21611                                  	je	short int_0A_first
 21612                                  	
 21613                                  	cmp	byte [bx],0CFh
 21614                                  	je	short int_0A_first
 21615                                  	
 21616                                  	cmp	word [bx+6],424Bh
 21617                                  	je	short int_0A_not_first
 21618                                  	
 21619                                  	cmp	dx,0F000h
 21620                                  	jne	short int_0A_not_first
 21621                                  	
 21622                                  	push	es
 21623                                  	push	dx
 21624                                  	mov	dx,0F000h
 21625                                  	mov	es,dx
 21626                                  	cmp	bx,[es:0FF01h]
 21627                                         	pop	dx
 21628                                  	pop	es
 21629                                  	je	short int_0A_first
 21630                                  %Endif
 21631                                  
 21632                                  	; 14/12/2022
 21633                                  	; 25/10/2022
 21634 000012CB E8EB00                  	call	int_xx_first_check ; 27/03/2019 - Retro DOS v4.0
 21635 000012CE 730C                    	jnc	short int_0A_first
 21636                                  	
 21637                                  int_0A_not_first:
 21638                                  	; 14/12/2022
 21639                                  	; 25/10/2022
 21640                                  	;pop	ds
 21641 000012D0 BF[5106]                	mov	di,INT19OLD0A
 21642 000012D3 BB[5900]                	mov	bx,old0A
 21643 000012D6 BA[5700]                	mov	dx,int0A
 21644 000012D9 E80801                  	call	new_init_loop
 21645                                  	
 21646                                  	; 14/12/2022	
 21647                                  	;jmp	short int_0A_end
 21648                                  ;int_0A_first:
 21649                                  	; 25/10/2022
 21650                                  	;pop	ds
 21651                                  
 21652                                  	; 14/12/2022
 21653                                  int_0A_first:
 21654                                  int_0A_end:
 21655                                  
 21656                                  stkinit_0B:
 21657 000012DC BE2C00                  	mov	si,0Bh*4 ; 44
 21658                                  	
 21659                                  	; 14/12/2022
 21660                                  	; 25/10/2022
 21661 000012DF E8D700                  	call	int_xx_first_check ; 27/03/2019 - Retro DOS v4.0
 21662 000012E2 730C                    	jnc	short int_0B_end ; int_0B_first
 21663                                  
 21664                                  ; 14/12/2022
 21665                                  %if 0	
 21666                                  	; 25/10/2022 (MSDOS 5.0 IO.SYS compatibility)
 21667                                  	push	ds
 21668                                  	lds	bx,[es:si]
 21669                                  	push	ds
 21670                                  	pop	dx
 21671                                  		
 21672                                  	cmp	dx,0
 21673                                  	je	short int_0B_first
 21674                                  
 21675                                  	cmp	byte [bx],0CFh
 21676                                  	je	short int_0B_first
 21677                                  	
 21678                                  	cmp	word [bx+6],424Bh
 21679                                  	je	short int_0B_not_first
 21680                                  	
 21681                                  	cmp	dx,0F000h
 21682                                  	jne	short int_0B_not_first
 21683                                  
 21684                                  	push	es
 21685                                  	push	dx
 21686                                  	mov	dx,0F000h
 21687                                  	mov	es,dx
 21688                                  	cmp	bx,[es:0FF01h]
 21689                                  	pop	dx
 21690                                  	pop	es
 21691                                  	je	short int_0B_first
 21692                                  %endif
 21693                                  
 21694                                  int_0B_not_first:
 21695                                  	; 14/12/2022
 21696                                  	; 25/10/2022
 21697                                  	;pop	ds
 21698 000012E4 BF[5606]                	mov	di,INT19OLD0B
 21699 000012E7 BB[7100]                	mov	bx,old0B
 21700 000012EA BA[6F00]                	mov	dx,int0B
 21701 000012ED E8F400                  	call	new_init_loop
 21702                                  
 21703                                  	; 14/12/2022
 21704                                  	;jmp	short int_0B_end
 21705                                  ;int_0B_first:
 21706                                  	; 25/10/2022
 21707                                  	;pop	ds
 21708                                  
 21709                                  int_0B_end:
 21710                                  	
 21711                                  stkinit_0C:
 21712 000012F0 BE3000                  	mov	si,0Ch*4 ; 48
 21713                                  	
 21714                                  	; 14/12/2022
 21715                                  	; 25/10/2022
 21716 000012F3 E8C300                  	call	int_xx_first_check
 21717 000012F6 730C                    	jnc	short int_0C_end ; int_0C_first
 21718                                  
 21719                                  ; 14/12/2022
 21720                                  %if 0	
 21721                                  	; 25/10/2022 (MSDOS 5.0 IO.SYS compatibility)
 21722                                  	push	ds
 21723                                  	lds	bx,[es:si]
 21724                                  	push	ds
 21725                                  	pop	dx
 21726                                  		
 21727                                  	cmp	dx,0
 21728                                  	je	short int_0C_first
 21729                                  
 21730                                  	cmp	byte [bx],0CFh
 21731                                  	je	short int_0C_first
 21732                                  	
 21733                                  	cmp	word [bx+6],424Bh
 21734                                  	je	short int_0C_not_first
 21735                                  	
 21736                                  	cmp	dx,0F000h
 21737                                  	jne	short int_0C_not_first
 21738                                  
 21739                                  	push	es
 21740                                  	push	dx
 21741                                  	mov	dx,0F000h
 21742                                  	mov	es,dx
 21743                                  	cmp	bx,[es:0FF01h]
 21744                                  	pop	dx
 21745                                  	pop	es
 21746                                  	je	short int_0C_first
 21747                                  %endif
 21748                                  	
 21749                                  int_0C_not_first:
 21750                                  	; 14/12/2022
 21751                                  	; 25/10/2022
 21752                                  	;pop	ds
 21753 000012F8 BF[5B06]                	mov	di,INT19OLD0C
 21754 000012FB BB[8900]                	mov	bx,old0C
 21755 000012FE BA[8700]                	mov	dx,int0C
 21756 00001301 E8E000                  	call	new_init_loop
 21757                                  
 21758                                  	; 14/12/2022
 21759                                  	;jmp	short int_0C_end
 21760                                  ;int_0C_first:
 21761                                  	; 25/10/2022
 21762                                  	;pop	ds
 21763                                  
 21764                                  int_0C_end:
 21765                                  
 21766                                  stkinit_0D:
 21767 00001304 BE3400                  	mov	si,0Dh*4 ; 52
 21768                                  
 21769                                  	; 14/12/2022	
 21770                                  	; 25/10/2022
 21771 00001307 E8AF00                  	call	int_xx_first_check
 21772 0000130A 730C                    	jnc	short int_0D_end ; int_0D_first
 21773                                  
 21774                                  ; 14/12/2022
 21775                                  %if 0	
 21776                                  	; 25/10/2022 (MSDOS 5.0 IO.SYS compatibility)
 21777                                  	push	ds
 21778                                  	lds	bx,[es:si]
 21779                                  	push	ds
 21780                                  	pop	dx
 21781                                  		
 21782                                  	cmp	dx,0
 21783                                  	je	short int_0D_first
 21784                                  
 21785                                  	cmp	byte [bx],0CFh
 21786                                  	je	short int_0D_first
 21787                                  	
 21788                                  	cmp	word [bx+6],424Bh
 21789                                  	je	short int_0D_not_first
 21790                                  	
 21791                                  	cmp	dx,0F000h
 21792                                  	jne	short int_0D_not_first
 21793                                  
 21794                                  	push	es
 21795                                  	push	dx
 21796                                  	mov	dx,0F000h
 21797                                  	mov	es,dx
 21798                                  	cmp	bx,[es:0FF01h]
 21799                                  	pop	dx
 21800                                  	pop	es
 21801                                  	je	short int_0D_first
 21802                                  %endif
 21803                                  	
 21804                                  int_0D_not_first:
 21805                                  	; 14/12/2022
 21806                                  	; 25/10/2022
 21807                                  	;pop	ds
 21808 0000130C BF[6006]                	mov	di,INT19OLD0D
 21809 0000130F BB[A100]                	mov	bx,old0D
 21810 00001312 BA[9F00]                	mov	dx,int0D
 21811 00001315 E8CC00                  	call	new_init_loop
 21812                                  
 21813                                  	; 14/12/2022
 21814                                  	;jmp	short int_0D_end
 21815                                  	; 02/11/2022
 21816                                  ;int_0D_first:
 21817                                  	;pop	ds
 21818                                  
 21819                                  int_0D_end:
 21820                                  
 21821                                  stkinit_0E:
 21822 00001318 BE3800                  	mov	si,0Eh*4 ; 56
 21823                                  
 21824                                  	; 14/12/2022	
 21825                                  	; 25/10/2022
 21826 0000131B E89B00                  	call	int_xx_first_check
 21827 0000131E 730C                    	jnc	short int_0E_end ; int_0E_first
 21828                                  
 21829                                  ; 14/12/2022
 21830                                  %if 0	
 21831                                  	; 25/10/2022 (MSDOS 5.0 IO.SYS compatibility)
 21832                                  	push	ds
 21833                                  	lds	bx,[es:si]
 21834                                  	push	ds
 21835                                  	pop	dx
 21836                                  		
 21837                                  	cmp	dx,0
 21838                                  	je	short int_0E_first
 21839                                  
 21840                                  	cmp	byte [bx],0CFh
 21841                                  	je	short int_0E_first
 21842                                  	
 21843                                  	cmp	word [bx+6],424Bh
 21844                                  	je	short int_0E_not_first
 21845                                  	
 21846                                  	cmp	dx,0F000h
 21847                                  	jne	short int_0E_not_first
 21848                                  
 21849                                  	push	es
 21850                                  	push	dx
 21851                                  	mov	dx,0F000h
 21852                                  	mov	es,dx
 21853                                  	cmp	bx,[es:0FF01h]
 21854                                  	pop	dx
 21855                                  	pop	es
 21856                                  	je	short int_0E_first
 21857                                  %endif
 21858                                  	
 21859                                  int_0E_not_first:
 21860                                  	; 14/12/2022
 21861                                  	; 25/10/2022
 21862                                  	;pop	ds
 21863 00001320 BF[6506]                	mov	di,INT19OLD0E
 21864 00001323 BB[B900]                	mov	bx,old0E
 21865 00001326 BA[B700]                	mov	dx,int0E
 21866 00001329 E8B800                  	call	new_init_loop
 21867                                  
 21868                                  	; 14/12/2022
 21869                                  	;jmp	short int_0E_end
 21870                                  ;int_0E_first:
 21871                                  	; 25/10/2022
 21872                                  	;pop	ds	
 21873                                  
 21874                                  int_0E_end:
 21875                                  
 21876                                  stkinit_72:
 21877 0000132C BEC801                  	mov	si,72h*4 ; 456
 21878                                  	
 21879                                  	; 14/12/2022
 21880                                  	; 25/10/2022
 21881 0000132F E88700                  	call	int_xx_first_check
 21882 00001332 730C                    	jnc	short int_72_end ; int_72_first
 21883                                  
 21884                                  ; 14/12/2022
 21885                                  %if 0	
 21886                                  	; 25/10/2022 (MSDOS 5.0 IO.SYS compatibility)
 21887                                  	push	ds
 21888                                  	lds	bx,[es:si]
 21889                                  	push	ds
 21890                                  	pop	dx
 21891                                  		
 21892                                  	cmp	dx,0
 21893                                  	je	short int_72_first
 21894                                  
 21895                                  	cmp	byte [bx],0CFh
 21896                                  	je	short int_72_first
 21897                                  	
 21898                                  	cmp	word [bx+6],424Bh
 21899                                  	je	short int_72_not_first
 21900                                  	
 21901                                  	cmp	dx,0F000h
 21902                                  	jne	short int_72_not_first
 21903                                  
 21904                                  	push	es
 21905                                  	push	dx
 21906                                  	mov	dx,0F000h
 21907                                  	mov	es,dx
 21908                                  	cmp	bx,[es:0FF01h]
 21909                                  	pop	dx
 21910                                  	pop	es
 21911                                  	je	short int_72_first
 21912                                  %endif
 21913                                  	
 21914                                  int_72_not_first:
 21915                                  	; 14/12/2022
 21916                                  	; 25/10/2022
 21917                                  	;pop	ds
 21918 00001334 BF[6F06]                	mov	di,INT19OLD72
 21919 00001337 BB[D100]                	mov	bx,old72
 21920 0000133A BA[CF00]                	mov	dx,int72
 21921 0000133D E8A400                  	call	new_init_loop
 21922                                  
 21923                                  	; 14/12/2022
 21924                                  	;jmp	short int_72_end
 21925                                  ;int_72_first:
 21926                                  	; 25/10/2022
 21927                                  	;pop	ds
 21928                                  
 21929                                  int_72_end:
 21930                                  
 21931                                  stkinit_73:
 21932 00001340 BECC01                  	mov	si,73h*4 ; 460
 21933                                  	
 21934                                  	; 14/12/2022
 21935                                  	; 25/10/2022
 21936 00001343 E87300                  	call	int_xx_first_check
 21937 00001346 730C                    	jnc	short int_73_end ; int_73_first
 21938                                  
 21939                                  ; 14/12/2022
 21940                                  %if 0	
 21941                                  	; 25/10/2022 (MSDOS 5.0 IO.SYS compatibility)
 21942                                  	push	ds
 21943                                  	lds	bx,[es:si]
 21944                                  	push	ds
 21945                                  	pop	dx
 21946                                  		
 21947                                  	cmp	dx,0
 21948                                  	je	short int_73_first
 21949                                  
 21950                                  	cmp	byte [bx],0CFh
 21951                                  	je	short int_73_first
 21952                                  	
 21953                                  	cmp	word [bx+6],424Bh
 21954                                  	je	short int_73_not_first
 21955                                  	
 21956                                  	cmp	dx,0F000h
 21957                                  	jne	short int_73_not_first
 21958                                  
 21959                                  	push	es
 21960                                  	push	dx
 21961                                  	mov	dx,0F000h
 21962                                  	mov	es,dx
 21963                                  	cmp	bx,[es:0FF01h]
 21964                                  	pop	dx
 21965                                  	pop	es
 21966                                  	je	short int_73_first
 21967                                  %endif	
 21968                                  	
 21969                                  int_73_not_first:
 21970                                  	; 14/12/2022
 21971                                  	; 25/10/2022
 21972                                  	;pop	ds
 21973 00001348 BF[7406]                	mov	di,INT19OLD73
 21974 0000134B BB[E900]                	mov	bx,old73
 21975 0000134E BA[E700]                	mov	dx,int73
 21976 00001351 E89000                  	call	new_init_loop
 21977                                  
 21978                                  	; 14/12/2022
 21979                                  	;jmp	short int_73_end
 21980                                  ;int_73_first:
 21981                                  	; 25/10/2022
 21982                                  	;pop	ds
 21983                                  
 21984                                  int_73_end:
 21985                                  
 21986                                  stkinit_74:
 21987 00001354 BED001                  	mov	si,74h*4 ; 464
 21988                                  	
 21989                                  	; 14/12/2022
 21990                                  	; 25/10/2022
 21991 00001357 E85F00                  	call	int_xx_first_check
 21992 0000135A 730C                    	jnc	short int_74_end ; int_74_first
 21993                                  
 21994                                  ; 14/12/2022
 21995                                  %if 0		
 21996                                  	; 25/10/2022 (MSDOS 5.0 IO.SYS compatibility)
 21997                                  	push	ds
 21998                                  	lds	bx,[es:si]
 21999                                  	push	ds
 22000                                  	pop	dx
 22001                                  		
 22002                                  	cmp	dx,0
 22003                                  	je	short int_74_first
 22004                                  
 22005                                  	cmp	byte [bx],0CFh
 22006                                  	je	short int_74_first
 22007                                  	
 22008                                  	cmp	word [bx+6],424Bh
 22009                                  	je	short int_74_not_first
 22010                                  	
 22011                                  	cmp	dx,0F000h
 22012                                  	jne	short int_74_not_first
 22013                                  
 22014                                  	push	es
 22015                                  	push	dx
 22016                                  	mov	dx,0F000h
 22017                                  	mov	es,dx
 22018                                  	cmp	bx,[es:0FF01h]
 22019                                  	pop	dx
 22020                                  	pop	es
 22021                                  	je	short int_74_first
 22022                                  %endif
 22023                                  
 22024                                  int_74_not_first:
 22025                                  	; 14/12/2022
 22026                                  	; 25/10/2022
 22027                                  	;pop	ds
 22028 0000135C BF[7906]                	mov	di,INT19OLD74
 22029 0000135F BB[0101]                	mov	bx,old74
 22030 00001362 BA[FF00]                	mov	dx,int74
 22031 00001365 E87C00                  	call	new_init_loop
 22032                                  	
 22033                                  	; 14/12/2022
 22034                                  	;jmp	short int_74_end
 22035                                  ;int_74_first:
 22036                                  	; 25/10/2022
 22037                                  	;pop	ds
 22038                                  
 22039                                  int_74_end:
 22040                                  
 22041                                  stkinit_76:
 22042 00001368 BED801                  	mov	si,76h*4 ; 472
 22043                                  	
 22044                                  	; 14/12/2022
 22045                                  	; 25/10/2022
 22046 0000136B E84B00                  	call	int_xx_first_check
 22047 0000136E 730E                    	jnc	short int_76_end ; int_76_first
 22048                                  
 22049                                  ; 14/12/2022
 22050                                  %if 0	
 22051                                  	; 25/10/2022 (MSDOS 5.0 IO.SYS compatibility)
 22052                                  	push	ds
 22053                                  	lds	bx,[es:si]
 22054                                  	push	ds
 22055                                  	pop	dx
 22056                                  		
 22057                                  	cmp	dx,0
 22058                                  	je	short int_76_first
 22059                                  
 22060                                  	cmp	byte [bx],0CFh
 22061                                  	je	short int_76_first
 22062                                  	
 22063                                  	cmp	word [bx+6],424Bh
 22064                                  	je	short int_76_not_first
 22065                                  	
 22066                                  	cmp	dx,0F000h
 22067                                  	jne	short int_76_not_first
 22068                                  
 22069                                  	push	es
 22070                                  	push	dx
 22071                                  	mov	dx,0F000h
 22072                                  	mov	es,dx
 22073                                  	cmp	bx,[es:0FF01h]
 22074                                  	pop	dx
 22075                                  	pop	es
 22076                                  	je	short int_76_first
 22077                                  %endif
 22078                                  	
 22079                                  int_76_not_first:
 22080                                  	; 14/12/2022
 22081                                  	; 25/10/2022
 22082                                  	;pop	ds
 22083 00001370 BF[7E06]                	mov	di,INT19OLD76
 22084 00001373 BB[1901]                	mov	bx,old76
 22085 00001376 BA[1701]                	mov	dx,int76
 22086 00001379 E86800                  	call	new_init_loop
 22087                                  
 22088                                  	; 14/12/2022
 22089 0000137C EB00                    	jmp	short int_76_end
 22090                                  ;int_76_first:
 22091                                  	; 25/10/2022
 22092                                  	;pop	ds
 22093                                  
 22094                                  int_76_end:
 22095                                  
 22096                                  stkinit_77:
 22097 0000137E BEDC01                  	mov	si,77h*4 ; 476
 22098                                  	
 22099                                  	; 14/12/2022
 22100                                  	; 25/10/2022
 22101 00001381 E83500                  	call	int_xx_first_check
 22102 00001384 730C                    	jnc	short int_77_end ; int_77_first
 22103                                  
 22104                                  ; 14/12/2022
 22105                                  %if 0	
 22106                                  	; 25/10/2022 (MSDOS 5.0 IO.SYS compatibility)
 22107                                  	push	ds
 22108                                  	lds	bx,[es:si]
 22109                                  	push	ds
 22110                                  	pop	dx
 22111                                  		
 22112                                  	cmp	dx,0
 22113                                  	je	short int_77_first
 22114                                  
 22115                                  	cmp	byte [bx],0CFh
 22116                                  	je	short int_77_first
 22117                                  	
 22118                                  	cmp	word [bx+6],424Bh
 22119                                  	je	short int_77_not_first
 22120                                  	
 22121                                  	cmp	dx,0F000h
 22122                                  	jne	short int_77_not_first
 22123                                  
 22124                                  	push	es
 22125                                  	push	dx
 22126                                  	mov	dx,0F000h
 22127                                  	mov	es,dx
 22128                                  	cmp	bx,[es:0FF01h]
 22129                                  	pop	dx
 22130                                  	pop	es
 22131                                  	je	short int_77_first
 22132                                  %endif
 22133                                  	
 22134                                  int_77_not_first:
 22135                                  	; 14/12/2022
 22136                                  	; 25/10/2022
 22137                                  	;pop	ds
 22138 00001386 BF[8306]                	mov	di,INT19OLD77
 22139 00001389 BB[3101]                	mov	bx,old77
 22140 0000138C BA[2F01]                	mov	dx,int77
 22141 0000138F E85200                  	call	new_init_loop
 22142                                  
 22143                                  	; 14/12/2022
 22144                                  	;jmp	short int_77_end
 22145                                  ;int_77_first:
 22146                                  	; 25/10/2022
 22147                                  	;pop	ds
 22148                                  
 22149                                  int_77_end:
 22150 00001392 1E                      	push	ds
 22151 00001393 B800F0                  	mov	ax,0F000h		; look at the model byte
 22152 00001396 8ED8                    	mov	ds,ax
 22153 00001398 803EFEFFF9              	cmp	byte [0FFFEh],0F9h ; mdl_convert ; pc convertible?
 22154 0000139D 1F                      	pop	ds
 22155 0000139E 7504                    	jne	short skip_enablenmis
 22156                                  
 22157 000013A0 B027                    	mov	al,27h			; enable convertible nmis
 22158 000013A2 E672                    	out	72h,al
 22159                                  
 22160                                  ; 25/10/2022
 22161                                  ; (MSDOS 5.0 SYSINIT:15FBh)
 22162                                  
 22163                                  skip_enablenmis:
 22164 000013A4 FB                      	sti
 22165                                  	;;mov	ax,Bios_Data ; 70h
 22166                                  	;mov	ax,KERNEL_SEGMENT ; 70h
 22167                                  	; 21/10/2022
 22168 000013A5 B87000                  	mov	ax,DOSBIODATASEG ; 0070h
 22169 000013A8 8ED8                    	mov	ds,ax
 22170                                  
 22171                                  	;mov	[640h],1 ; SYSINIT:1736h for MSDOS 6.21 IO.SYS
 22172                                  
 22173 000013AA C606[4006]01            	mov	byte [INT19SEM],1	; indicate that int 19
 22174                                  					; initialization is complete
 22175                                  
 22176 000013AF 5D                      	pop	bp			; restore all
 22177 000013B0 5E                      	pop	si
 22178 000013B1 5F                      	pop	di
 22179 000013B2 5A                      	pop	dx
 22180 000013B3 59                      	pop	cx
 22181 000013B4 5B                      	pop	bx
 22182 000013B5 07                      	pop	es
 22183 000013B6 1F                      	pop	ds
 22184 000013B7 58                      	pop	ax
 22185 000013B8 C3                      	retn
 22186                                  
 22187                                  ; 14/12/2022
 22188                                  ; ----------------------------------------------------------------------
 22189                                  
 22190                                  	; 14/12/2022
 22191                                  	; 25/10/2022
 22192                                  ;%if 0
 22193                                  	; 27/03/2019 - Retro DOS v4.0
 22194                                  int_xx_first_check:
 22195 000013B9 1E                      	push	ds
 22196 000013BA 26C51C                  	lds	bx,[es:si]
 22197 000013BD 1E                      	push	ds
 22198 000013BE 5A                      	pop	dx
 22199                                  		
 22200 000013BF 83FA00                  	cmp	dx,0
 22201 000013C2 741E                    	je	short int_xx_first
 22202                                  	
 22203 000013C4 803FCF                  	cmp	byte [bx],0CFh
 22204 000013C7 7419                    	je	short int_xx_first
 22205                                  	
 22206 000013C9 817F064B42              	cmp	word [bx+6],424Bh
 22207 000013CE 7411                    	je	short int_xx_not_first
 22208                                  	
 22209 000013D0 81FA00F0                	cmp	dx,0F000h
 22210 000013D4 750B                    	jne	short int_xx_not_first
 22211                                  
 22212 000013D6 06                      	push	es
 22213                                  	;push	dx
 22214                                  	;mov	dx,0F000h
 22215 000013D7 8EC2                    	mov	es,dx
 22216 000013D9 263B1E01FF              	cmp	bx,[es:0FF01h]
 22217                                        	;pop	dx
 22218 000013DE 07                      	pop	es
 22219 000013DF 7401                    	je	short int_xx_first
 22220                                  
 22221                                  int_xx_not_first:
 22222 000013E1 F9                      	stc
 22223                                  int_xx_first:
 22224 000013E2 1F                      	pop	ds
 22225 000013E3 C3                      	retn
 22226                                  
 22227                                  ;%endif
 22228                                  
 22229                                  ; ----------------------------------------------------------------------
 22230                                  ; 27/03/2019 - Retro DOS v4.0
 22231                                  
 22232                                  ; 25/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS, SYSINIT)
 22233                                  ; (SYSINIT:1610h)
 22234                                  
 22235                                  new_init_loop:
 22236                                  
 22237                                  ;input: si=ofset into vector table of the particular int vector being adjusted
 22238                                  ;	bx=ds:offset of oldxx, where will be saved the pointer to original owner
 22239                                  ;	dx=ds:offset of intxx, the new interrupt handler
 22240                                  ;	di=offset value of int19old&aa variable in bios.
 22241                                  ;	es=zero, segid of vector table
 22242                                  ;	ds=relocated stack code segment
 22243                                  
 22244 000013E4 268B04                  	mov	ax,[es:si]		;remember offset in vector
 22245 000013E7 8907                    	mov	[bx],ax			; to original owner in ds
 22246 000013E9 268B4402                	mov	ax,[es:si+2]		;remember segid in vector
 22247 000013ED 894702                  	mov	[bx+2],ax		; to original owner in ds
 22248                                  
 22249 000013F0 1E                      	push	ds
 22250                                  	;;mov	ax,Bios_Data ; 70h
 22251                                  	;mov	ax,KERNEL_SEGMENT ; 70h
 22252                                  	; 21/10/2022
 22253 000013F1 B87000                  	mov	ax,DOSBIODATASEG ; 0070h
 22254 000013F4 8ED8                    	mov	ds,ax			;set int19oldxx value in bios for
 22255 000013F6 268B04                  	mov	ax,[es:si]		;int 19 handler
 22256 000013F9 8905                    	mov	[di],ax
 22257 000013FB 268B4402                	mov	ax,[es:si+2]
 22258 000013FF 894502                  	mov	word [di+2],ax
 22259 00001402 1F                      	pop	ds
 22260                                  
 22261 00001403 268914                  	mov	[es:si],dx  	;set vector to point to new int handler
 22262 00001406 268C5C02                	mov	[es:si+2],ds
 22263 0000140A C3                      	retn
 22264                                  
 22265                                  ; End of STACK initialization routine
 22266                                  ; ----------------------------------------------------------------------
 22267                                  
 22268                                  ; ----------------------------------------------------------------------
 22269                                  ;set the devmark for mem command.
 22270                                  ;in: [memhi] - the address to place devmark
 22271                                  ;    [memlo] = 0
 22272                                  ;    al = id for devmark_id
 22273                                  ;out: devmark established.
 22274                                  ;     the address saved in cs:[devmark_addr]
 22275                                  ;     [memhi] increase by 1.
 22276                                  ; ----------------------------------------------------------------------
 22277                                  
 22278                                  ; 25/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS, SYSINIT)
 22279                                  ; (SYSINIT:1637h)
 22280                                  
 22281                                  setdevmark:
 22282                                  
 22283 0000140B 06                      	push	es
 22284 0000140C 51                      	push	cx
 22285                                  
 22286 0000140D 2E8B0E[E003]            	mov	cx,[cs:memhi]
 22287 00001412 2E890E[2C14]            	mov	[cs:devmark_addr],cx
 22288 00001417 8EC1                    	mov	es,cx
 22289                                  	; 25/10/2022
 22290                                  	;mov	[es:devmark.id],al
 22291 00001419 26A20000                	mov	[es:0],al
 22292 0000141D 41                      	inc	cx
 22293                                  	;mov	[es:devmark.seg],cx
 22294 0000141E 26890E0100              	mov	[es:1],cx
 22295                                  
 22296 00001423 59                      	pop	cx
 22297 00001424 07                      	pop	es
 22298 00001425 2EFF06[E003]            	inc	word [cs:memhi]
 22299 0000142A C3                      	retn
 22300                                  
 22301                                  ; ----------------------------------------------------------------------
 22302                                  ; SYSCONF.ASM - MSDOS 6.0 - 1991
 22303                                  ; ----------------------------------------------------------------------
 22304                                  ; 27/03/2019 - Retro DOS v4.0
 22305                                  
 22306                                  ;MULTI_CONFIG	equ 1
 22307                                  
 22308                                  HIGH_FIRST 	equ 080h		; from ARENA.INC - modifier for
 22309                                                                          ; allocation strategy call
 22310                                  
 22311                                  ;have_install_cmd equ 00000001b 	; config.sys has install= commands
 22312                                  ;has_installed	  equ 00000010b 	; sysinit_base installed.
 22313                                  
 22314                                  default_filenum equ 8
 22315                                  
 22316                                  ;stacksw	equ true		; include switchable hardware stacks
 22317                                  
 22318                                  ; external variable defined in ibmbio module for multi-track
 22319                                  
 22320                                  ;multrk_on	equ 10000000b		;user spcified mutitrack=on,or system turns
 22321                                  					; it on after handling config.sys file as a
 22322                                  					; default value,if multrk_flag = multrk_off1.
 22323                                  ;multrk_off1	equ 00000000b		;initial value. no "multitrack=" command entered.
 22324                                  ;multrk_off2	equ 00000001b		;user specified multitrack=off.
 22325                                  
 22326                                  ; if stacksw
 22327                                  
 22328                                  ; internal stack parameters
 22329                                  
 22330                                  ;entrysize	equ 8
 22331                                  
 22332                                  ;mincount	equ 8
 22333                                  ;defaultcount	equ 9
 22334                                  ;maxcount	equ 64
 22335                                  
 22336                                  ;minsize 	equ 32
 22337                                  ;defaultsize	equ 128
 22338                                  ;maxsize 	equ 512
 22339                                  
 22340                                  DOS_FLAG_OFFSET	equ 86h
 22341                                  
 22342                                  ;ifdef MULTI_CONFIG
 22343                                  ;
 22344                                  ;   config_envlen must immediately precede config_wrkseg, because they
 22345                                  ;   may be loaded as a dword ptr
 22346                                  
 22347                                  ; 25/10/2022
 22348                                  ;config_envlen:	dw  0  			; when config_wrkseg is being used as
 22349                                  ;               			;  a scratch env, this is its length
 22350                                  ;config_wrkseg:	dw  0			; config work area (above confbot)
 22351                                  ;                   			;  segment of work area
 22352                                  ;
 22353                                  ;config_cmd:	db  0  			; current config cmd
 22354                                  ;                 			;  (with CONFIG_OPTION_QUERY bit intact)
 22355                                  ;config_multi:	db  0                   ; non-zero if multi-config config.sys
 22356                                  
 22357                                  ;endif ; MULTI_CONFIG
 22358                                  
 22359 0000142B 00                      multdeviceflag:	db  0
 22360                                  
 22361 0000142C 0000                    devmark_addr:	dw  0			;segment address for devmark.
 22362                                  
 22363 0000142E 00                      setdevmarkflag: db  0			;flag used for devmark
 22364                                  
 22365                                  ; 12/12/2022
 22366                                  ;driver_units:	db  0			;total unitcount for driver
 22367                                  
 22368                                  ; 12/12/2022
 22369                                  ;ems_stub_installed:
 22370                                  ;		db  0
 22371                                  
 22372                                  ; 12/12/2022	
 22373                                  ;align 2
 22374                                  
 22375                                  badparm_ptr:	; label	dword
 22376 0000142F 0000                    badparm_off:	dw  0
 22377 00001431 0000                    badparm_seg:	dw  0
 22378                                  
 22379                                  ;******************************************************************************
 22380                                  ;take care of config.sys file.
 22381                                  ;system parser data and code.
 22382                                  ;******************************************************************************
 22383                                  
 22384                                  ;*******************************************************************
 22385                                  ; parser options set for msbio sysconf module
 22386                                  ;*******************************************************************
 22387                                  ;
 22388                                  ;**** default assemble swiches definition **************************
 22389                                  
 22390                                  ;farsw	equ 0		; near call expected
 22391                                  ;datesw	equ 0		; check date format
 22392                                  ;timesw	equ 0		; check time format
 22393                                  ;filesw	equ 1		; check file specification
 22394                                  ;capsw	equ 0		; perform caps if specified
 22395                                  ;cmpxsw	equ 0		; check complex list
 22396                                  ;numsw	equ 1		; check numeric value
 22397                                  ;keysw	equ 0		; support keywords
 22398                                  ;swsw	equ 1		; support switches
 22399                                  ;val1sw	equ 1		; support value definition 1
 22400                                  ;val2sw	equ 0		; support value definition 2
 22401                                  ;val3sw	equ 1		; support value definition 3
 22402                                  ;drvsw	equ 1		; support drive only format
 22403                                  ;qussw	equ 0		; support quoted string format
 22404                                  
 22405                                  ; psdata_seg equ cs
 22406                                  
 22407                                  	;.xlist
 22408                                  	;include parse.asm		;together with psdata.inc
 22409                                  	;.list
 22410                                  
 22411                                  ; PSDATA.INC - MSDOS 6.0 - 1991
 22412                                  ; ======================================================================
 22413                                  ; 27/03/2019 - Retro DOS v4.0
 22414                                  
 22415                                  ; 30/03/2019
 22416                                  ; VERSION.INC (MSDOS 6.0) 
 22417                                  ; Set DBCS Blank constant
 22418                                  
 22419                                  ; ifndef DBCS
 22420                                  DB_SPACE EQU 2020h
 22421                                  DB_SP_HI EQU 20h
 22422                                  DB_SP_LO EQU 20h
 22423                                  ; else
 22424                                  
 22425                                  ;*******************************************************************
 22426                                  ; Parser include file
 22427                                  ;*******************************************************************
 22428                                  
 22429                                  ;**** Equation field
 22430                                  ;-------- Character code definition
 22431                                  
 22432                                  _$P_DBSP1	   equ	DB_SP_HI	;AN000; 1st byte of DBCS blank
 22433                                  _$P_DBSP2	   equ	DB_SP_LO	;AN000; 2nd byte of DBCS blank
 22434                                  _$P_Period	   equ	"."             ;AN020;
 22435                                  _$P_Slash	   equ	"/"             ;AN020;
 22436                                  _$P_Space	   equ	" "             ;AN000; SBCS blank
 22437                                  _$P_Comma	   equ	","             ;AN000;
 22438                                  _$P_Switch	   equ	"/"             ;AN000;
 22439                                  _$P_Keyword	   equ	"="             ;AN000;
 22440                                  _$P_Colon	   equ	":"             ;AN000;
 22441                                  _$P_Plus 	   equ	"+"             ;AN000;
 22442                                  _$P_Minus	   equ	"-"             ;AN000;
 22443                                  _$P_Rparen	   equ	")"             ;AN000;
 22444                                  _$P_Lparen	   equ	"("             ;AN000;
 22445                                  ;_$P_SQuote        equ  "'"			;AN025; deleted
 22446                                  _$P_DQuote	   equ	'"'             ;AN000;
 22447                                  _$P_NULL 	   equ	0		;AN000;
 22448                                  _$P_TAB		   equ	9		;AN000;
 22449                                  _$P_CR		   equ	0Dh		;AN000;
 22450                                  _$P_LF		   equ	0Ah		;AN000;
 22451                                  _$P_ASCII80	   equ	80h		;AN000; ASCII 80h character code
 22452                                  
 22453                                  ;-------- Masks
 22454                                  _$P_Make_Lower	   equ	20h		;AN000; make lower case character
 22455                                  _$P_Make_Upper	   equ	0FFh-_$P_Make_Lower ;AN000; make upper case character
 22456                                  
 22457                                  ;-------- DOS function call related equs
 22458                                  
 22459                                  _$P_DOS_Get_CDI	   equ	3800h		;AN000; get country dependent information
 22460                                  					; by this call, following information
 22461                                  struc _$P_CDI	
 22462 00000000 ????                     .DateF: resw 1
 22463 00000002 ??????????               .Money: resb 5
 22464 00000007 ????                     .1000:	 resb 2
 22465 00000009 ????                     .Dec:	 resb 2
 22466 0000000B ????                     .DateS: resb 2
 22467 0000000D ????                     .TimeS: resb 2
 22468 0000000F ??                          	 resb 1
 22469 00000010 ??                      	 resb 1
 22470 00000011 ??                       .TimeF: resb 1	 
 22471 00000012 ????????                	 resw 2
 22472 00000016 ????                    	 resb 2
 22473 00000018 <res Ah>                	 resw 5
 22474                                   .size:
 22475                                  endstruc
 22476                                  
 22477                                  _$P_Date_MDY	   equ	0		;AN000;
 22478                                  _$P_Date_DMY	   equ	1		;AN000;
 22479                                  _$P_Date_YMD	   equ	2		;AN000;
 22480                                  ;-------------
 22481                                  _$P_DOS_GetEV	   equ	6300h		;AN000; get DBCS EV call
 22482                                  					;AN000; DS:SI will points to DBCS EV
 22483                                  ;-------------
 22484                                  _$P_DOS_Get_TBL	   equ	65h		;AN000; get uppercase table call
 22485                                  					;AN000; following parameters are set
 22486                                  					;AN000; to get casemap table.
 22487                                  _$P_DOSTBL_Def	   equ	-1		;AN000; get default
 22488                                  _$P_DOSTBL_BL	   equ	5		;AN000; buffer length for Tbl pointer
 22489                                  _$P_DOSTBL_File	   equ	4		;AN000; get file uppercase table
 22490                                  _$P_DOSTBL_Char	   equ	2		;AN000; get character uppercase table
 22491                                  					; By this call following information
 22492                                  					; is returned.
 22493                                  struc _$P_DOS_TBL
 22494 00000000 ??                       .InfoID: resb 1			;AN000; information id for the table
 22495 00000001 ????                     .Off:	 resw 1				;AN000; offset address of the table
 22496 00000003 ????                     .Seg:	 resw 1				;AN000; segment address of the table
 22497                                  endstruc
 22498                                  
 22499                                  ; ----------------------------------------------------------------------------
 22500                                  ; PARMS 	LABEL	BYTE
 22501                                  ;		DW	PARMSX
 22502                                  ;		DB	2		; NUMBER OF STRINGS (0, 1, 2)
 22503                                  ;		DB	length		; LENGTH OF THE NEXT LIST, 0 IF NONE
 22504                                  ;		DB	" .. "          ; EXTRA DELIMITER LIST,
 22505                                  ;					; TYPICAL ARE ";", "="
 22506                                  ;					; "," & WHITESPACE ALWAYS
 22507                                  ;		DB	length		; LENGTH OF THE NEXT LIST, 0 IF NONE
 22508                                  ;		DB	" .. "          ; EXTRA END OF LINE LIST, CR, LF OR 0 ALWAYS
 22509                                  ; ----------------------------------------------------------------------------
 22510                                  
 22511                                  ;-------------------------------- PARMS block structure
 22512                                  struc _$P_PARMS_Blk
 22513 00000000 ????                     .PARMSX_Address:  resw 1		;AN000; Address of PARMSX
 22514 00000002 ??                       .Num_Extra:	   resb 1		;AN000; Number of extra stuff
 22515 00000003 ??                       .Len_Extra_Delim: resb 1		;AN000; Length of extra delimiter
 22516                                  endstruc
 22517                                  
 22518                                  _$P_Len_PARMS	   equ	4		;AN000;
 22519                                  _$P_I_Use_Default  equ	0		;AN000; no extra stuff specified
 22520                                  _$P_I_Have_Delim   equ	1		;AN000; extra delimiter specified
 22521                                  _$P_I_Have_EOL	   equ	2		;AN000; extra EOL specified
 22522                                  
 22523                                  ; ----------------------------------------------------------------------------
 22524                                  ; PARMSX	LABEL	BYTE
 22525                                  ;		DB	minp,maxp	; MIN, MAX POSITIONAL OPERANDS ALLOWED
 22526                                  ;		DW	CONTROL 	; DESCRIPTION OF POSITIONAL 1
 22527                                  ;		:			; REPEATS maxp-1 TIMES
 22528                                  ;		DB	maxs		; # OF SWITCHES
 22529                                  ;		DW	CONTROL 	; DESCRIPTION OF SWITCH 1
 22530                                  ;		:			; REPEATS maxs-1 TIMES
 22531                                  ;		DB	maxk		; # OF KEYWORD
 22532                                  ;		DW	CONTROL 	; DESCRIPTION OF KEYWORD 1
 22533                                  ;		:			; REPEATS maxk-1 TIMES
 22534                                  ; ----------------------------------------------------------------------------
 22535                                  
 22536                                  ;-------------------------------- PARMSX block structure
 22537                                  struc _$P_PARMSX_Blk		;AN000;
 22538 00000000 ??                       .MinP: resb 1			;AN000; Minimum positional number
 22539 00000001 ??                       .MaxP:	resb 1			;AN000; Maximum positional number
 22540 00000002 ????                     .1st_Control: resw 1		;AN000; Address of the 1st CONTROL block
 22541                                  endstruc
 22542                                  
 22543                                  ; ----------------------------------------------------------------------------
 22544                                  ; << Control field definition  >>
 22545                                  ;
 22546                                  ;
 22547                                  ;CONTROL   LABEL   BYTE
 22548                                  ;	   DW	   MATCH_FLAGS	   ; CONTROLS TYPE MATCHED
 22549                                  ;				   ; 8000H=NUMERIC VALUE, (VALUE LIST WILL BE CHECKED)
 22550                                  ;				   ; 4000H=SIGNED NUMERIC VALUE (VALUE LIST WILL BE CHECKED)
 22551                                  ;				   ; 2000H=SIMPLE STRING(VALUE LIST WILL BE CHECKED)
 22552                                  ;				   ; 1000H=DATE STRING (VALUE LIST WON'T BE CHECKED)
 22553                                  ;				   ; 0800H=TIME STRING (VALUE LIST WON'T BE CHECKED)
 22554                                  ;				   ; 0400H=COMPLEX LIST (VALUE LIST WON'T BE CHECKED)
 22555                                  ;				   ; 0200H=FILE SPEC (VALUE LIST WON'T BE CHECKED)
 22556                                  ;				   ; 0100H=DRIVE ONLY (VALUE LIST WON'T BE CHECKED)
 22557                                  ;				   ; 0080H=QUOTED STRING (VALUE LIST WON'T BE CHECKED)
 22558                                  ;				   ; 0010H=IGNORE ":" AT END IN MATCH
 22559                                  ;				   ; 0002H=REPEATS ALLOWED
 22560                                  ;				   ; 0001H=OPTIONAL
 22561                                  ;	   DW	   FUNCTION_FLAGS
 22562                                  ;				   ; 0001H=CAP RESULT BY FILE TABLE
 22563                                  ;				   ; 0002H=CAP RESULT BY CHAR TABLE
 22564                                  ;				   ; 0010H=REMOVE ":" AT END
 22565                                  ; (tm10)			   ; 0020H=colon is not necessary for switch
 22566                                  ;	   DW	   RESULT	   ; RESULT BUFFER
 22567                                  ;	   DW	   VALUES	   ; VALUE LISTS
 22568                                  ;	   DB	   nid		   ; NUMBER OF KEYWORD/SWITCH SYNONYMS IN FOLLOWING LIST
 22569                                  ;	   DB	   "...",0         ; IF n >0, KEYWORD 1
 22570                                  ;	   :
 22571                                  ;
 22572                                  ;Note:
 22573                                  ;    - The MATCH_FLAG is bit significant. You can set, for example, TIME bit and
 22574                                  ;      DATE bit simalteniously.
 22575                                  ;
 22576                                  ;      The parser examins each bit along with the following priority.
 22577                                  ;
 22578                                  ;      COMPLEX -> DATE -> TIME -> NUMERIC VAL -> SIGNED NUMERIC VAL -> DRIVE ->
 22579                                  ;      FILE SPEC -> SIMPLE STRING.
 22580                                  ;
 22581                                  ;    - When the FUNCTION_FLAG is 0001 or 0002, the STRING pointed to by a pointer
 22582                                  ;      in the result buffer is capitalized.
 22583                                  ;
 22584                                  ;    - Match_Flags 0001H and 0002H have meaning only for the positional.
 22585                                  ;
 22586                                  ;    - The "...",0 (bottom most line) does require '=' or '/'. When you need a
 22587                                  ;      switch, for example, '/A', then STRING points to;
 22588                                  ;
 22589                                  ;			DB    1 	; number of following synonyms
 22590                                  ;			DB   '/A',0
 22591                                  ;
 22592                                  ;      When you need a keyword, for example, 'CODEPAGE=', then "...",0 will be;
 22593                                  ;
 22594                                  ;			DB    1 	; number of following synonyms
 22595                                  ;			DB   'CODEPAGE=',0
 22596                                  ;
 22597                                  ;    - "..." must consist of upper case characters only because the parser
 22598                                  ;      performs pattern matching after converting input to upper case (by
 22599                                  ;      using the current country upper case table)
 22600                                  ;
 22601                                  ;    - One "..." can contain only one switch or keyword. If you need, for
 22602                                  ;      example /A and /B, the format will be;
 22603                                  ;
 22604                                  ;			DB    2 	; number of following synonyms
 22605                                  ;			DB    '/A',0
 22606                                  ;			DB    '/B',0
 22607                                  ; ----------------------------------------------------------------------------
 22608                                  
 22609                                  ;**** Match_Flags
 22610                                  
 22611                                  _$P_Num_Val	   equ	8000h		;AN000; Numeric Value
 22612                                  _$P_SNum_Val	   equ	4000h		;AN000; Signed numeric value
 22613                                  _$P_Simple_S	   equ	2000h		;AN000; Simple string
 22614                                  _$P_Date_S	   equ	1000h		;AN000; Date string
 22615                                  _$P_Time_S	   equ	0800h		;AN000; Time string
 22616                                  _$P_Cmpx_S	   equ	0400h		;AN000; Complex string
 22617                                  _$P_File_Spc	   equ	0200h		;AN000; File Spec
 22618                                  _$P_Drv_Only	   equ	0100h		;AN000; Drive Only
 22619                                  _$P_Qu_String	   equ	0080h		;AN000; Quoted string
 22620                                  _$P_Ig_Colon	   equ	0010h		;AN000; Ignore colon at end in match
 22621                                  _$P_Repeat	   equ	0002h		;AN000; Repeat allowed
 22622                                  _$P_Optional	   equ	0001h		;AN000; Optional
 22623                                  
 22624                                  ;**** Function flags
 22625                                  
 22626                                  _$P_CAP_File	   equ	0001h		;AN000; CAP result by file table
 22627                                  _$P_CAP_Char	   equ	0002h		;AN000; CAP result by character table
 22628                                  _$P_Rm_Colon	   equ	0010h		;AN000; Remove ":" at the end
 22629                                  _$P_colon_is_not_necessary equ 0020h	;AN000;(tm10) /+10 and /+:10
 22630                                  
 22631                                  ;-------------------------------- Control block structure
 22632                                  struc _$P_Control_Blk
 22633 00000000 ????                     .Match_Flag:	 resw 1		;AN000; Controls type matched
 22634 00000002 ????                     .Function_Flag: resw 1		;AN000; Function should be taken
 22635 00000004 ????                     .Result_Buf:	 resw 1		; Result buffer address
 22636 00000006 ????                     .Value_List:	 resw 1		;AN000; Value list address
 22637 00000008 ??                       .nid:		 resb 1		;AN000; # of keyword/SW synonyms
 22638 00000009 ??                       .KEYorSW:	 resb 1		;AN000; keyword or sw
 22639                                  endstruc
 22640                                  
 22641                                  ; ----------------------------------------------------------------------------
 22642                                  ; << Value List Definition >>
 22643                                  ;
 22644                                  ;VALUES 	LABEL	BYTE
 22645                                  ;		DB	nval			; NUMBER OF VALUE DEFINITIONS (0 - 3)
 22646                                  ;	     +-
 22647                                  ;	     |	DB	nrng			; NUMBER OF RANGES
 22648                                  ;	     | +DB	ITEM_TAG		; RETURN VALUE IF RANGE MATCHED
 22649                                  ;	     | +DD	X,Y			; RANGE OF VALUES
 22650                                  ;	     |	:
 22651                                  ;	     |	DB	nnval			; NUMBER OF CHOICES
 22652                                  ;	     | +DB	ITEM_TAG		; RETURN VALUE IF NUMBER CHOICE MATCHED
 22653                                  ;	     | +DD	VALUE			; SPECIFIC CHOICE IF NUMBER
 22654                                  ;	     |	:
 22655                                  ;	     |	DB	nstrval 		; NUMBER OF CHOICES
 22656                                  ;	     | +DB	ITEM_TAG		; RETURN VALUE IF STRING CHOICE MATCHED
 22657                                  ;	     | +DW	STRING			; SPECIFIC CHOICE IF STING
 22658                                  ;	     +-	:
 22659                                  ;
 22660                                  ;STRING 	DB	"...",0                 ; ASCIIZ STRING IMAGE
 22661                                  ;
 22662                                  ;Note:
 22663                                  ;    - ITEM_TAG must not be 0FFH, which will be used in the result buffer
 22664                                  ;      when no choice lists are provided.
 22665                                  ;
 22666                                  ;    - STRING must consist of upper case characters only because the parser
 22667                                  ;      performs pattern matching after converting input to upper case (by
 22668                                  ;      using the current country upper case table)
 22669                                  ; ----------------------------------------------------------------------------
 22670                                  
 22671                                  _$P_nval_None	   equ	0		;AN000; no value list ID
 22672                                  _$P_nval_Range	   equ	1		;AN000; range list ID
 22673                                  _$P_nval_Value	   equ	2		;AN000; value list ID
 22674                                  _$P_nval_String	   equ	3		;AN000; string list ID
 22675                                  _$P_Len_Range	   equ	9		;AN000; Length of a range choice(two DD plus one DB)
 22676                                  _$P_Len_Value	   equ	5		;AN000; Length of a value choice(one DD plus one DB)
 22677                                  _$P_Len_String	   equ	3		;AN000; Length of a string choice(one DW plus one DB)
 22678                                  _$P_No_nrng	   equ	0		;AN000; (tm07) no nrng. nnval must not be 0.
 22679                                  
 22680                                  struc _$P_Val_List
 22681 00000000 ??                       .NumofList: resb 1			;AN000; number of following choice
 22682 00000001 ????                     .Val_XL:    resw 1			;AN000; lower word of value
 22683 00000003 ????                     .Val_XH:    resw 1			;AN000; higher word of value
 22684 00000005 ????                     .Val_YL:    resw 1			;AN000; lower word of another value
 22685 00000007 ????                     .Val_YH:    resw 1			;AN000; higher word of another value
 22686                                  endstruc
 22687                                  
 22688                                  ; ----------------------------------------------------------------------------
 22689                                  ; << Result Buffer Definition  >>
 22690                                  ;
 22691                                  ;RESULT 	LABEL	BYTE			; BELOW FILLED IN FOR DEFAULTS
 22692                                  ;		DB	type			; TYPE RETURNED: 0=RESERVED,
 22693                                  ;						;	1=NUMBER, 2=LIST INDEX,
 22694                                  ;						;	3=STRING, 4=COMPLEX,
 22695                                  ;						;	5=FILESPEC, 6=DRIVE
 22696                                  ;						;	7=DATE, 8=TIME
 22697                                  ;						;	9=QUOTED STRING
 22698                                  ;		DB	ITEM_TAG		; MATCHED ITEM TAG
 22699                                  ;
 22700                                  ;		dw	synonym@		; es:@ points to found SYNONYM if provided.
 22701                                  ;
 22702                                  ;            +-
 22703                                  ;	    | DD	n			; VALUE IF NUMBER
 22704                                  ;	    | or
 22705                                  ;	    |	DW	i			; INDEX (OFFSET) INTO VALUE LIST
 22706                                  ;	    |					; (ES presents Segment address)
 22707                                  ;	    | or
 22708                                  ;	    |	DD	STRING			; OFFSET OF STRING VALUE
 22709                                  ;	    | or
 22710                                  ;	    |	DB	drv			; DRIVE NUMBER (1-A, 2-B,..., 26-Z)
 22711                                  ;	    | or
 22712                                  ;	    |	DW	YEAR	   ;(1980-2099)  IN CASE OF DATE
 22713                                  ;	    |	DB	MONTH	   ;(1-12)	 Note: Range check is not performed.
 22714                                  ;	    |	DB	DATE	   ;(1-31)	       0 is filled when the corresponding field was not specified.
 22715                                  ;	    | or
 22716                                  ;	    |	DB	HOUR	   ;(0-23)	  IN CASE OF TIME
 22717                                  ;	    |	DB	MINUTES    ;(0-59)	  Note: Range check is not performed .
 22718                                  ;	    |	DB	SECONDS    ;(0-59)		0 is filled when the corresponding field was not specified .
 22719                                  ;	    |	DB	HUNDREDTHS ;(0-99)
 22720                                  ;	    +-
 22721                                  ;
 22722                                  ;
 22723                                  ;Note: ITEM_TAG is 0FFH when the caller does not specify the choice
 22724                                  ;      list.
 22725                                  ;
 22726                                  ;      YEAR: If the input value for the year is less than 100, parser
 22727                                  ;	     adds 1900 to it.  For example, when 87 is input to parser for
 22728                                  ;	     the year value, he returns 1987.
 22729                                  ; ----------------------------------------------------------------------------
 22730                                  
 22731                                  ;-------------------------------- Result block structure
 22732                                  struc _$P_Result_Blk
 22733 00000000 ??                       .Type:        resb 1		;AN000; Type returned
 22734 00000001 ??                       .Item_Tag:    resb 1		;AN000; Matched item tag
 22735 00000002 ????                     .SYNONYM_Ptr: resw 1		;AN000; pointer to Synonym list returned
 22736 00000004 ????????                 .Picked_Val:  resb 4		;AN000; value
 22737                                  endstruc
 22738                                  
 22739                                  ;--------------------------------
 22740                                  ;**** values for the type field in the result block
 22741                                  
 22742                                  _$P_EOL		   equ	0		;AN000; End of line
 22743                                  _$P_Number	   equ	1		;AN000; Number
 22744                                  _$P_List_Idx	   equ	2		;AN000; List Index
 22745                                  _$P_String	   equ	3		;AN000; String
 22746                                  _$P_Complex	   equ	4		;AN000; Complex
 22747                                  _$P_File_Spec	   equ	5		;AN000; File Spec
 22748                                  _$P_Drive	   equ	6		;AN000; Drive
 22749                                  _$P_Date_F	   equ	7		;AN000; Date
 22750                                  _$P_Time_F	   equ	8		;AN000; Time
 22751                                  _$P_Quoted_String  equ	9		;AN000; Quoted String
 22752                                  
 22753                                  _$P_No_Tag	   equ	0FFh		;AN000; No ITEM_TAG found
 22754                                  
 22755                                  ;**** Return code
 22756                                  ;
 22757                                  ; following return code will be returned in the AX register.
 22758                                  
 22759                                  _$P_No_Error	   equ	0		;AN000; No error
 22760                                  _$P_Too_Many	   equ	1		;AN000; Too many operands
 22761                                  _$P_Op_Missing	   equ	2		;AN000; Required operand missing
 22762                                  _$P_Not_In_SW	   equ	3		;AN000; Not in switch list provided
 22763                                  _$P_Not_In_Key	   equ	4		;AN000; Not in keyword list provided
 22764                                  _$P_Out_Of_Range   equ	6		;AN000; Out of range specified
 22765                                  _$P_Not_In_Val	   equ	7		;AN000; Not in value list provided
 22766                                  _$P_Not_In_Str	   equ	8		;AN000; Not in string list provided
 22767                                  _$P_Syntax	   equ	9		;AN000; Syntax error
 22768                                  _$P_RC_EOL	   equ	-1		;AN000; End of command line
 22769                                  
 22770                                  ; DATA - Retro DOS v4.0 - 27/03/2019
 22771                                  
 22772                                  ; MSDOS 6.2 IO.SYS SYSINIT:179Ch
 22773                                  
 22774                                  ;********************** Local Data *************************************
 22775 00001433 0000                    _$P_ORDINAL:	   dw	0		;AN000; Operand ordinal save area
 22776 00001435 0000                    _$P_RC:		   dw	0		;AN000; Return code from parser
 22777 00001437 0000                    _$P_SI_Save:	   dw	0		;AN000; Pointer of command buffer
 22778 00001439 0000                    _$P_DX:		   dw	0		;AN000; Return result buffer address
 22779 0000143B 00                      _$P_Terminator:	   db	0		;AN000; Terminator code (ASCII)
 22780 0000143C 0000                    _$P_DBCSEV_OFF:	   dw	0		;AN000; Offset of DBCS EV
 22781 0000143E 0000                    _$P_DBCSEV_SEG:	   dw	0		;AN000; Segment of DBCS EV
 22782 00001440 0000                    _$P_Flags:	   dw	0		;AN000; Parser internal flags
 22783                                  %define _$P_Flags1 _$P_Flags		;AN038; to reference first byte flags
 22784                                  %define _$P_Flags2 _$P_Flags+1		;AN038; to reference second byte flags only
 22785                                  
 22786                                  ;in second byte of _$P_Flags, referenced as _$P_Flags2:
 22787                                  _$P_equ		   equ	01h	      ;AN000; "=" packed in string buffet
 22788                                  _$P_Neg		   equ	02h	      ;AN000; Negative value
 22789                                  _$P_Time12	   equ	04h	      ;AN000; set when PM is specified
 22790                                  _$P_Key_Cmp	   equ	08h	      ;AN000; set when keyword compare
 22791                                  _$P_SW_Cmp	   equ	10h	      ;AN000; set when switch compare
 22792                                  _$P_Extra	   equ	20h	      ;AN000; set when extra delimiter found
 22793                                  _$P_SW		   equ	40h	      ;AN000; set when switch found (tm08)
 22794                                  _$P_Signed	   equ	80h	      ;AN000; signed numeric specified
 22795                                  
 22796                                  ;in first byte of _$P_Flags, referenced as _$P_Flags1:
 22797                                  _$P_time12am	   equ	01h	      ;AN038; set when AM is specified on time
 22798                                  _$P_TIME_AGAIN	   equ	02h	      ;AN039; SET WHEN READY TO RE-PARSE TIME
 22799                                  
 22800 00001442 0000                    _$P_SaveSI_Cmpx:   dw	0		;AN000; save si for later use by complex
 22801 00001444 0000                    _$P_KEYorSW_Ptr:   dw	0		;AN000; points next to "=" or ":" code
 22802 00001446 0000                    _$P_Save_EOB:	   dw	0		;AN000; save pointer to EOB
 22803 00001448 0000                    _$P_Found_SYNONYM: dw	0		;AN000; es:@ points to found synonym
 22804                                  
 22805 0000144A 00<rep 80h>             _$P_STRING_BUF:	   times 128 db 0	;AN000; Pick a operand from command line
 22806                                  _$P_STRING_BUF_END equ	$		;AN000;
 22807                                  
 22808                                  ; 25/10/2022
 22809                                  ; (MSDOS 5.0 IO.SYS, SYSINIT:16F8h)
 22810                                  
 22811 000014CA FF                      _$P_Char_CAP_Ptr:  db	0FFh		;AN000; info id
 22812 000014CB 0000                    		   dw	0		;AN000; offset	of char case map table
 22813 000014CD 0000                    		   dw	0		;AN000; segment of char case map table
 22814                                  ; 25/10/2022
 22815                                  ;_$P_File_CAP_Ptr: db	0FFh		;AN000; info id
 22816                                  ;		   dw	0		;AN000; offset	of file case map table
 22817                                  ;		   dw	0		;AN000; segment of file case map table
 22818                                  
 22819                                  ; (tm06) IF FileSW			;AN000;(Check if file spec is supported)
 22820                                  ;
 22821                                  
 22822                                  ;M029
 22823                                  ;!!!WARNING!!!
 22824                                  ; In routine SYSPARSE (parse.asm), _$P_FileSp_Char is reinitialized using 
 22825                                  ;hardcoded strings. If the chars in the string are changed here, corresponding
 22826                                  ;changes need to be made in SYSPARSE
 22827                                  
 22828                                  ;IF FileSW+DrvSW 			;AN000;(Check if file spec is supported)
 22829                                  
 22830                                  ; 25/10/2022
 22831                                  ; (MSDOS 5.0 IO.SYS, SYSINIT:16FDh)
 22832                                  
 22833 000014CF 5B5D7C3C3E2B3D3B22      _$P_FileSp_Char	   db	'[]|<>+=;"'     ;AN000; delimitter of file spec
 22834                                  _$P_FileSp_Len	   equ	$-_$P_FileSp_Char ;AN000;
 22835                                  
 22836                                  ;ENDIF					;AN000;(of FileSW)
 22837                                  
 22838                                  ; delimiter parsing
 22839                                  _$P_colon_period   equ	01h		;AN032; check for colon & period
 22840                                  _$P_period_only	   equ	02h		;AN032; check only for period
 22841                                  
 22842                                  ;filespec error flag
 22843 000014D8 00                      _$P_err_flag:	   db	0		;AN033; flag set if filespec parsing error
 22844                                  					;AN033;  was detected.
 22845                                  _$P_error_filespec equ	01h		;AN033; mask to set flag
 22846                                  
 22847                                  
 22848                                  ; PARSE.ASM - MSDOS 6.0 - 1991
 22849                                  ; ======================================================================
 22850                                  ; 27/03/2019 - Retro DOS v4.0
 22851                                  
 22852                                  ;***********************************************************************
 22853                                  ; SysParse;
 22854                                  ;
 22855                                  ;  Function : Parser Entry
 22856                                  ;
 22857                                  ;  Input: DS:SI -> command line
 22858                                  ;	  ES:DI -> parameter block
 22859                                  ;	  cs -> psdata.inc
 22860                                  ;	  CX = operand ordinal
 22861                                  ;
 22862                                  ;	  Note:  ES is the segment containing all the control blocks defined
 22863                                  ;		 by the caller, except for the DOS COMMAND line parms, which
 22864                                  ;		 is in DS.
 22865                                  ;
 22866                                  ;  Output: CY = 1   error of caller, means invalid parameter block or
 22867                                  ;		    invalid value list. But this parser does NOT implement
 22868                                  ;		    this feature. Therefore CY always zero.
 22869                                  ;
 22870                                  ;	   CY = 0   AX = return code
 22871                                  ;		    BL = terminated delimiter code
 22872                                  ;		    CX = new operand ordinal
 22873                                  ;		    SI = set past scaned operand
 22874                                  ;		    DX = selected result buffer
 22875                                  ;
 22876                                  ; Use:	_$P_Skip_Delim, _$P_Chk_EOL, _$P_Chk_Delim, _$P_Chk_DBCS
 22877                                  ;	_$P_Chk_Swtch, _$P_Chk_Pos_Control, _$P_Chk_Key_Control
 22878                                  ;	_$P_Chk_Sw_Control, _$P_Fill_Result
 22879                                  ;
 22880                                  ; Vars: _$P_Ordinal(RW), _$P_RC(RW), _$P_SI_Save(RW), _$P_DX(R), _$P_Terminator(R)
 22881                                  ;	_$P_SaveSI_Cmpx(W), _$P_Flags(RW), _$P_Found_SYNONYM(R), _$P_Save_EOB(W)
 22882                                  ;
 22883                                  ;-------- Modification History -----------------------------------------
 22884                                  ;
 22885                                  ;  4/04/87 : Created by K. K,
 22886                                  ;  4/28/87 : _$P_Val_YH assemble error (tm01)
 22887                                  ;	   : JMP SHORT assemble error (tm02)
 22888                                  ;  5/14/87 : Someone doesn't want to include psdata (tm03)
 22889                                  ;  6/12/87 : _$P_Bridge is missing when TimeSw equ 0 and (CmpxSw equ 1 or
 22890                                  ;	     DateSW equ 1)	      (tm04)
 22891                                  ;  6/12/87 : _$P_SorD_Quote is missing when QusSw equ 0 and CmpxSW equ 1
 22892                                  ;				      (tm05) in PSDATA.INC
 22893                                  ;  6/12/87 : _$P_FileSp_Char and _$P_FileSP_Len are missing
 22894                                  ;	     when FileSW equ 0 and DrvSW equ 1 (tm06) in PSDATA.INC
 22895                                  ;  6/18/87 : $VAL1 and $VAL3, $VAL2 and $VAL3 can be used in the same
 22896                                  ;	     value-list block	      (tm07)
 22897                                  ;  6/20/87 : Add _$P_SW to check if there's an omiting parameter after
 22898                                  ;	     switch (keyword) or not. If there is, backup si for next call
 22899                                  ;	     (tm08)
 22900                                  ;  6/24/87 : Complex Item checking does not work correctly when CmpSW equ 1
 22901                                  ;	     and DateSW equ 0 and TimeSW equ 0 (tm09)
 22902                                  ;  6/24/87 : New function flag _$P_colon_is_not_necessary for switch
 22903                                  ;	     /+15 and /+:15 are allowed for user (tm10)
 22904                                  ;  6/29/87 : ECS call changes DS register but it causes the address problem
 22905                                  ;	     in user's routines. _$P_Chk_DBCS (tm11)
 22906                                  ;  7/10/87 : Switch with no_match flag (0x0000H) does not work correctly
 22907                                  ;					  (tm12)
 22908                                  ;  7/10/87 : Invalid switch/keyword does not work correctly
 22909                                  ;					  (tm13)
 22910                                  ;  7/10/87 : Drive_only breaks 3 bytes after the result buffer
 22911                                  ;					  (tm14)
 22912                                  ;  7/12/87 : Too_Many_Operands sets DX=0 as the PARSE result
 22913                                  ;					  (tm15)
 22914                                  ;  7/24/87 : Negative lower bound on numeric ranges cause trouble
 22915                                  
 22916                                  ;  7/24/87 : Quoted strings being returned with quotes.
 22917                                  
 22918                                  ;  7/28/87 : Kerry S (;AN018;)
 22919                                  ;	     Non optional value on switch (match flags<>0 and <>1) not flagged
 22920                                  ;	     as an error when missing.	Solution: return error 2.  Modules
 22921                                  ;	     affected: _$P_Chk_SW_Control.
 22922                                  
 22923                                  ;  7/29/87 : Kerry S (;AN019;)
 22924                                  ;	     Now allow the optional bit in match flags for switches.  This
 22925                                  ;	     allows the switch to be encountered with a value or without a
 22926                                  ;	     value and no error is returned.
 22927                                  ;
 22928                                  
 22929                                  ;  8/28/87 : Ed K, Kerry S (;AN020;)
 22930                                  ;  9/14/87   In PROC _$P_Get_DecNum, when checking for field separators
 22931                                  ;	     within a date response, instead of checking just for the one
 22932                                  ;	     character defined by the COUNTRY DEPENDENT INFO, check for
 22933                                  ;	     all three chars, "-", "/", and ".". Change _$P_Chk_Switch to allow
 22934                                  ;	     slashes in date strings when DateSw (assembler switch) is set.
 22935                                  
 22936                                  ;  9/1/87  : Kerry S (;AN021)
 22937                                  ;	     In PROC _$P_String_Comp, when comparing the switch or keyword on
 22938                                  ;	     the command line with the string in the control block the
 22939                                  ;	     comparing was stopping at a colon (switch) or equal (keyword)
 22940                                  ;	     on the command line and assuming a match.	This allowed a shorter
 22941                                  ;	     string on the command line than in the synonym list in the control
 22942                                  ;	     block.  I put in a test for a null in the control block so the
 22943                                  ;	     string in the control block must be the same length as the string
 22944                                  ;	     preceeding the colon or equal on the command line.
 22945                                  
 22946                                  ;  8/28/87 : Kerry S (;AN022;)
 22947                                  ;	     All references to data in PSDATA.INC had CS overrides.  This caused
 22948                                  ;	     problems for people who included it themselves in a segment other
 22949                                  ;	     than CS.  Added switch to allow including PSDATA.INC in any
 22950                                  ;	     segment.
 22951                                  
 22952                                  ;  9/16/87 : Ed K (;AN023;) PTM1040
 22953                                  ;	     in _$P_set_cdi PROC, it assumes CS points to psdata. Change Push CS
 22954                                  ;	     into PUSH cs.  In _$P_Get_DecNum PROC, fix AN020
 22955                                  ;	     forced both TIME and DATE to use the delims, "-","/",".".
 22956                                  ;	     Created FLag, in _$P_time_Format PROC, to request the delim in
 22957                                  ;	     BL be used if TIME is being parsed.
 22958                                  
 22959                                  ;  9/24/87 : Ed K
 22960                                  ;	     Removed the include to STRUC.INC.	Replaced the STRUC macro
 22961                                  ;	     invocations with their normally expanded code; made comments
 22962                                  ;	     out of the STRUC macro invocation statements to maintain readability.
 22963                                  
 22964                                  ;  9/24/87 : Ed K (;AN024;) PTM1222
 22965                                  ;	     When no CONTROL for a keyword found, tried to fill in RESULT
 22966                                  ;	     pointed to by non-existant CONTROL.
 22967                                  
 22968                                  ; 10/15/87 : Ed K (;AN025;) PTM1672
 22969                                  ;	     A quoted text string can be framed only by double quote.  Remove
 22970                                  ;	     support to frame quoted text string with single quote.
 22971                                  ;	     (apostrophe) _$P_SorD_Quote is removed from PSDATA.INC.
 22972                                  ;	     _$P_SQuote EQU also removed from PSDATA.INC.  Any references to
 22973                                  ;	     single quote in PROC prologues are left as is for history reasons.
 22974                                  
 22975                                  ;	     This fixes another bug, not mentioned in p1672, in that two
 22976                                  ;	     quote chars within a quoted string is supposed to be reported as
 22977                                  ;	     one quote character, but is reported as two quotes.  This changed
 22978                                  ;	     two instructions in PROC _$P_Quoted_Str.
 22979                                  
 22980                                  ;	     Also fixed are several JMP that caused a NOP, these changed to
 22981                                  ;	     have the SHORT operator to avoid the unneeded NOP.
 22982                                  
 22983                                  ;	     The code and PSDATA.INC have been aligned for ease of reading.
 22984                                  
 22985                                  ; 10/26/87 : Ed K (;AN026;) PTM2041, DATE within SWITCH, BX reference to
 22986                                  ;	     psdata buffer should have cs.
 22987                                  
 22988                                  ; 10/27/87 : Ed K (;AN027;) PTM2042 comma between keywords implies
 22989                                  ;	     positional missing.
 22990                                  
 22991                                  ; 11/06/87 : Ed K (;AN028;) PTM 2315 Parser should not use line feed
 22992                                  ;	     as a line delimiter, should use carriage return.
 22993                                  ;	     Define switch: LFEOLSW, if on, accept LF as end of line char.
 22994                                  
 22995                                  ; 11/11/87 : Ed K (;AN029;) PTM 1651 GET RID OF WHITESPACE AROUND "=".
 22996                                  
 22997                                  ; 11/18/87 : Ed K (;AN030;) PTM 2551 If filename is just "", then
 22998                                  ;	     endless loop since SI is returned still pointing to start
 22999                                  ;	     of that parm.
 23000                                  
 23001                                  ; 11/19/87 : Ed K (;AN031;) PTM 2585 date & time getting bad values.
 23002                                  ;	     Vector to returned string has CS instead of cs, but
 23003                                  ;	     when tried to fix it on previous version, changed similar
 23004                                  ;	     but wrong place.
 23005                                  
 23006                                  ; 12/09/87 : Bill L (;AN032;) PTM 2772 colon and period are now valid
 23007                                  ;	     delimiters between hours, minutes, seconds for time. And period
 23008                                  ;	     and comma are valid delimiters between seconds and 100th second.
 23009                                  
 23010                                  ; 12/14/87 : Bill L (;AN033;) PTM 2722 if illegal delimiter characters
 23011                                  ;	     in a filespec, then flag an error.
 23012                                  
 23013                                  ; 12/22/87 : Bill L (;AN034;)	    All local data to parser is now
 23014                                  ;	     indexed off of the cs equate instead of the DS register.
 23015                                  ;	     Using this method, DS can point to the segment of PSP or to psdata
 23016                                  ;  -->	     local parser data. Why were some references to local data changed
 23017                                  ;	     to do this before, but not all ?????
 23018                                  
 23019                                  ; 02/02/88 : Ed K (;AC035;) INSPECT utility, suggests optimizations.
 23020                                  
 23021                                  ; 02/05/88 : Ed K (;AN036;) P3372-UPPERCASE TRANSLATION, cs HOSED.
 23022                                  ;
 23023                                  ; 02/08/88 : Ed K (;AN037;) P3410-AVOID POP OF CS, CHECK BASESW FIRST.
 23024                                  
 23025                                  ; 02/19/88 : Ed K (;AN038;) p3524 above noon and "am" should be error
 23026                                  
 23027                                  ; 02/23/88 : Ed K (;AN039;) p3518 accept "comma" and "period" as decimal
 23028                                  ;	     separator in TIME before hundredths field.
 23029                                  ;
 23030                                  ; 08/09/90 : SA	M005	Prevented parser from recognizing '=' signs within
 23031                                  ;			strings as keywords.
 23032                                  ;
 23033                                  ;***********************************************************************
 23034                                  
 23035                                  ;IF FarSW				;AN000;(Check if need far return)
 23036                                  ;SysParse proc far			;AN000;
 23037                                  ;ELSE					;AN000;
 23038                                  ;SysParse proc near			;AN000;
 23039                                  ;ENDIF					;AN000;(of FarSW)
 23040                                  
 23041                                  ; 27/03/2019 - Retro DOS v4.0
 23042                                  ; (MSDOS 6.21 IO.SYS - SYSINIT:1842h)
 23043                                  
 23044                                  ; 25/10/2022 - Retro DOS v4.0
 23045                                  ; (MSDOS 5.0 IO.SYS - SYSINIT:1707h)
 23046                                  
 23047                                  SysParse:
 23048 000014D9 2EC706[4014]0000        	mov	word [cs:_$P_Flags],0	;AC034; Clear all internal flags
 23049 000014E0 FC                      	cld				;AN000; confirm forward direction
 23050 000014E1 2E890E[3314]            	mov	word [cs:_$P_ORDINAL],cx ;AC034; save operand ordinal
 23051 000014E6 2EC706[3514]0000        	mov	word [cs:_$P_RC],_$P_No_Error ;AC034; Assume no error
 23052 000014ED 2EC706[4814]0000        	mov	word [cs:_$P_Found_SYNONYM],0 ;AC034; initalize synonym pointer
 23053                                  
 23054 000014F4 2EC706[3914]0000        	mov	word [cs:_$P_DX],0	;AC034; (tm15)
 23055                                  
 23056                                  ;M029 -- Begin changes
 23057                                  ; The table of special chars _$P_FileSp_Char should be initialized on every
 23058                                  ;entry to SysParse. This is in the non-checksum region and any program that
 23059                                  ;corrupts this table but does not corrupt the checksum region will leave
 23060                                  ;command.com parsing in an inconsistent state.
 23061                                  ; NB: The special characters string has been hardcoded here. If any change
 23062                                  ;is made to it in psdata.inc, a corresponding change needs to be made here.
 23063                                  
 23064                                  ;IF FileSW + DrvSW
 23065 000014FB 2EC706[CF14]5D5B        	mov	word [cs:_$P_FileSp_Char], ']['
 23066 00001502 2EC706[D114]3C7C        	mov	word [cs:_$P_FileSp_Char+2], '<|'
 23067 00001509 2EC706[D314]2B3E        	mov	word [cs:_$P_FileSp_Char+4], '+>'
 23068 00001510 2EC706[D514]3B3D        	mov 	word [cs:_$P_FileSp_Char+6], ';='
 23069                                  ;ENDIFtHHH
 23070                                  
 23071                                  ;M029 -- End of changes
 23072                                  
 23073 00001517 E8B806                  	call	_$P_Skip_Delim		;AN000; Move si to 1st non white space
 23074 0000151A 7313                    	jnc	short _$P_Start		;AN000; If EOL is not encountered, do parse
 23075                                  ;--------------------------- End of Line
 23076 0000151C B8FFFF                  	mov	ax,_$P_RC_EOL		;AN000; set exit code to -1
 23077 0000151F 53                      	push	bx			;AN000;
 23078                                  	;mov	bx,[es:di+_$P_PARMS_Blk.PARMSX_Address]
 23079                                  					;AN000; Get the PARMSX address to
 23080 00001520 268B1D                  	mov	bx,[es:di]
 23081                                  	;cmp	cl,[es:bx+_$P_PARMSX_Blk.MinP]
 23082                                  					;AN000; check ORDINAL to see if the minimum
 23083 00001523 263A0F                  	cmp	cl,[es:bx]	
 23084 00001526 7303                    	jae	short _$P_Fin		;AN000; positional found.
 23085                                  
 23086 00001528 B80200                  	mov	ax,_$P_Op_Missing	;AN000; If no, set exit code to missing operand
 23087                                  _$P_Fin: 				;AN000;
 23088 0000152B 5B                      	pop	bx			;AN000;
 23089 0000152C E92301                  	jmp	_$P_Single_Exit		;AN000; return to the caller
 23090                                  ;---------------------------
 23091                                  _$P_Start:				;AN000;
 23092 0000152F 2E8936[4214]            	mov	[cs:_$P_SaveSI_Cmpx],si ;AN000;AC034; save ptr to command line for later use by complex,
 23093 00001534 53                      	push	bx			;AN000; quoted string or file spec.
 23094 00001535 57                      	push	di			;AN000;
 23095 00001536 55                      	push	bp			;AN000;
 23096                                  	;lea	bx,[cs:_$P_STRING_BUF] ;AC034; set buffer to copy from command string
 23097                                  	; 02/11/2022
 23098 00001537 8D1E[4A14]              	lea	bx,[_$P_STRING_BUF]
 23099 0000153B 2EF606[4114]20          	test	byte [cs:_$P_Flags2],_$P_Extra ;AC034; 3/9 extra delimiter encountered ?
 23100 00001541 7543                    	jnz	short _$P_Pack_End	;AN000; 3/9 if yes, no need to copy
 23101                                  
 23102                                  _$P_Pack_Loop:				;AN000;
 23103 00001543 AC                      	lodsb				;AN000; Pick a operand from buffer
 23104 00001544 E84507                  	call	_$P_Chk_Switch		;AN000; Check switch character
 23105 00001547 723C                    	jc	short _$P_Pack_End_BY_EOL ;AN020; if carry set found delimiter type slash, need backup si, else continue
 23106                                  
 23107 00001549 E8A906                  	call	_$P_Chk_EOL		;AN000; Check EOL character
 23108 0000154C 7437                    	je	short _$P_Pack_End_BY_EOL ;AN000; need backup si
 23109                                  
 23110 0000154E E8DA06                  	call	_$P_Chk_Delim		;AN000; Check delimiter
 23111 00001551 7518                    	jne	short _$P_PL01 		;AN000; If no, process next byte
 23112                                  
 23113 00001553 2EF606[4114]20          	test	byte [cs:_$P_Flags2],_$P_Extra ;AC034; 3/9 If yes and white spec,
 23114                                  ; (tm08)jne	short _$P_Pack_End	;AN000; 3/9 then
 23115 00001559 7505                    	jnz	short _$P_Pack_End_backup_si ;AN000; (tm08)
 23116                                  
 23117 0000155B E87406                  	call	_$P_Skip_Delim		;AN000; skip subsequent white space,too
 23118 0000155E EB26                    	jmp	short _$P_Pack_End	;AN000; finish copy by placing NUL at end
 23119                                  
 23120                                  _$P_Pack_End_backup_si:			;AN000; (tm08)
 23121 00001560 2EF606[4114]41          	test	byte [cs:_$P_Flags2],_$P_SW+_$P_equ ;AN000;AC034;  (tm08)
 23122 00001566 741E                    	jz	short _$P_Pack_End	;AN000; (tm08)
 23123                                  
 23124 00001568 4E                      	dec	si			;AN000; (tm08)
 23125 00001569 EB1B                    	jmp	short _$P_Pack_End	;AN025; (tm08)
 23126                                  
 23127                                  _$P_PL01:				;AN000;
 23128 0000156B 2E8807                  	mov	[cs:bx],al		;AN000; move byte to STRING_BUF
 23129 0000156E 3C3D                    	cmp	al,_$P_Keyword  ;'='	;AN000; if it is equal character,
 23130 00001570 7506                    	jne	short _$P_PL00 		;AN000; then
 23131                                  
 23132 00001572 2E800E[4114]01          	or	byte [cs:_$P_Flags2],_$P_equ ;AC034; remember it in flag
 23133                                  _$P_PL00:				;AN000;
 23134 00001578 43                      	inc	bx			;AN000; ready to see next byte
 23135 00001579 E82A07                  	call	_$P_Chk_DBCS		;AN000; was it 1st byte of DBCS ?
 23136 0000157C 73C5                    	jnc	_$P_Pack_Loop		;AN000; if no, process to next byte
 23137                                  
 23138 0000157E AC                      	lodsb				;AN000; if yes, store
 23139 0000157F 2E8807                  	mov	[cs:bx],al		;AN000;    2nd byte of DBCS
 23140 00001582 43                      	inc	bx			;AN000; update pointer
 23141 00001583 EBBE                    	jmp	short _$P_Pack_Loop	;AN000; process to next byte
 23142                                  
 23143                                  _$P_Pack_End_BY_EOL:			;AN000;
 23144 00001585 4E                      	dec	si			;AN000; backup si pointer
 23145                                  _$P_Pack_End:				;AN000;
 23146 00001586 2E8936[3714]            	mov	[cs:_$P_SI_Save],si     ;AC034; save next pointer, SI
 23147 0000158B 2EC60700                	mov	byte [cs:bx],_$P_NULL	;AN000; put NULL at the end
 23148 0000158F 2E891E[4614]            	mov	[cs:_$P_Save_EOB],bx    ;AC034; 3/17/87 keep the address for later use of complex
 23149                                  	;mov	bx,[es:di+_$P_PARMS_Blk.PARMSX_Address] ;AN000; get PARMSX address
 23150 00001594 268B1D                  	mov	bx,[es:di]
 23151                                  	;lea	si,[cs:_$P_STRING_BUF]	;AC034;
 23152                                  	; 02/11/2022
 23153 00001597 8D36[4A14]              	lea	si,[_$P_STRING_BUF]
 23154 0000159B 2E803C2F                	cmp	byte [cs:si],_$P_Switch ;AN000; the operand begins w/ switch char ?
 23155 0000159F 7436                    	je	short _$P_SW_Manager	;AN000; if yes, process as switch
 23156                                  
 23157 000015A1 2E803C22                	cmp	byte [cs:si],_$P_DQuote	;M005;is it a string?
 23158 000015A5 7408                    	je	short _$P_Positional_Manager ;M005;if so, process as one!
 23159                                  
 23160 000015A7 2EF606[4114]01          	test	byte [cs:_$P_Flags2],_$P_equ ;AC034; the operand includes equal char ?
 23161 000015AD 7554                    	jnz	short _$P_Key_Manager	;AN000; if yes, process as keyword
 23162                                  
 23163                                  _$P_Positional_Manager:			;AN000; else process as positional
 23164 000015AF 268A4701                	mov	al,[es:bx+_$P_PARMSX_Blk.MaxP] ;AN000; get maxp
 23165 000015B3 30E4                    	xor	ah,ah			;AN000; ax = maxp
 23166 000015B5 2E3906[3314]            	cmp	[cs:_$P_ORDINAL],ax	;AC034; too many positional ?
 23167 000015BA 7312                    	jae	short _$P_Too_Many_Error ;AN000; if yes, set exit code to too many
 23168                                  
 23169 000015BC 2EA1[3314]              	mov	ax,[cs:_$P_ORDINAL]	;AC034; see what the current ordinal
 23170 000015C0 D1E0                    	shl	ax,1			;AN000; ax = ax*2
 23171 000015C2 43                      	inc	bx			;AC035; add '2' to
 23172 000015C3 43                      	inc	bx			;AC035;  BX reg
 23173                                  					;AN000; now bx points to 1st CONTROL
 23174 000015C4 01C3                    	add	bx,ax			;AN000; now bx points to specified CONTROL address
 23175 000015C6 268B1F                  	mov	bx,[es:bx]		;AN000; now bx points to specified CONTROL itself
 23176 000015C9 E88800                  	call	_$P_Chk_Pos_Control	;AN000; Do process for positional
 23177 000015CC EB69                    	jmp	short _$P_Return_to_Caller ;AN000; and return to the caller
 23178                                  
 23179                                  _$P_Too_Many_Error:			;AN000;
 23180 000015CE 2EC706[3514]0100        	mov	word [cs:_$P_RC],_$P_Too_Many ;AC034; set exit code
 23181 000015D5 EB60                    	jmp	short _$P_Return_to_Caller ;AN000; and return to the caller
 23182                                  
 23183                                  _$P_SW_Manager:				;AN000;
 23184 000015D7 268A4701                	mov	al,[es:bx+_$P_PARMSX_Blk.MaxP] ;AN000; get maxp
 23185 000015DB 30E4                    	xor	ah,ah			;AN000; ax = maxp
 23186 000015DD 40                      	inc	ax			;AN000;
 23187 000015DE D1E0                    	shl	ax,1			;AN000; ax = (ax+1)*2
 23188 000015E0 01C3                    	add	bx,ax			;AN000; now bx points to maxs
 23189 000015E2 268A0F                  	mov	cl,[es:bx]		;AN000;
 23190 000015E5 30ED                    	xor	ch,ch			;AN000; cx = maxs
 23191 000015E7 09C9                    	or	cx,cx			;AN000; at least one switch ?
 23192 000015E9 740F                    	jz	short _$P_SW_Not_Found 	;AN000;
 23193                                  
 23194 000015EB 43                      	inc	bx			;AN000; now bx points to 1st CONTROL address
 23195                                  
 23196                                  _$P_SW_Mgr_Loop: 			;AN000;
 23197 000015EC 53                      	push	bx			;AN000;
 23198 000015ED 268B1F                  	mov	bx,[es:bx]		;AN000; bx points to Switch CONTROL itself
 23199 000015F0 E8C400                  	call	_$P_Chk_SW_Control	;AN000; do process for switch
 23200 000015F3 5B                      	pop	bx			;AN000;
 23201 000015F4 7341                    	jnc	short _$P_Return_to_Caller ;AN000; if the CONTROL is for the switch, exit
 23202                                  
 23203 000015F6 43                      	inc	bx			;AC035; add '2' to
 23204 000015F7 43                      	inc	bx			;AC035;  BX reg
 23205                                  					;AN000; else bx points to the next CONTROL
 23206 000015F8 E2F2                    	loop	_$P_SW_Mgr_Loop		;AN000; and loop
 23207                                  
 23208                                  _$P_SW_Not_Found:			;AN000;
 23209 000015FA 2EC706[3514]0300        	mov	word [cs:_$P_RC],_$P_Not_In_SW ;AC034; here no CONTROL for the switch has
 23210 00001601 EB34                    	jmp	short _$P_Return_to_Caller ;AN000; not been found, means error.
 23211                                  
 23212                                  _$P_Key_Manager: 			;AN000;
 23213 00001603 268A4701                	mov	al,[es:bx+_$P_PARMSX_Blk.MaxP] ;AN000; get maxp
 23214 00001607 30E4                    	xor	ah,ah			;AN000; ax = maxp
 23215 00001609 40                      	inc	ax			;AN000;
 23216 0000160A D1E0                    	shl	ax,1			;AN000; ax = (ax+1)*2
 23217 0000160C 01C3                    	add	bx,ax			;AN000; now bx points to maxs
 23218 0000160E 268A07                  	mov	al,[es:bx]		;AN000;
 23219 00001611 30E4                    	xor	ah,ah			;AN000; ax = maxs
 23220 00001613 D1E0                    	shl	ax,1			;AN000;
 23221 00001615 40                      	inc	ax			;AN000; ax = ax*2+1
 23222 00001616 01C3                    	add	bx,ax			;AN000; now bx points to maxk
 23223 00001618 268A0F                  	mov	cl,[es:bx]		;AN000;
 23224 0000161B 30ED                    	xor	ch,ch			;AN000; cx = maxk
 23225 0000161D 09C9                    	or	cx,cx			;AN000; at least one keyword ?
 23226 0000161F 740F                    	je	short _$P_Key_Not_Found	;AN000;
 23227                                  
 23228 00001621 43                      	inc	bx			;AN000; now bx points to 1st CONTROL
 23229                                  
 23230                                  _$P_Key_Mgr_Loop:			;AN000;
 23231 00001622 53                      	push	bx			;AN000;
 23232 00001623 268B1F                  	mov	bx,[es:bx]		;AN000; bx points to keyword CONTROL itself
 23233 00001626 E85B00                  	call	_$P_Chk_Key_Control	;AN000; do process for keyword
 23234 00001629 5B                      	pop	bx			;AN000;
 23235 0000162A 730B                    	jnc	short _$P_Return_to_Caller ;AN000; if the CONTROL is for the keyword, exit
 23236                                  
 23237 0000162C 43                      	inc	bx			;AC035; add '2' to
 23238 0000162D 43                      	inc	bx			;AC035;  BX reg
 23239                                  					;AN000; else bx points to the next CONTROL
 23240 0000162E E2F2                    	loop	_$P_Key_Mgr_Loop 	;AN000; and loop
 23241                                  
 23242                                  _$P_Key_Not_Found:			;AN000;
 23243 00001630 2EC706[3514]0400        	mov	word [cs:_$P_RC],_$P_Not_In_Key ;AC034; here no CONTROL for the keyword has
 23244                                  _$P_Return_to_Caller:			;AN000;
 23245 00001637 5D                      	pop	bp			;AN000;
 23246 00001638 5F                      	pop	di			;AN000;
 23247 00001639 5B                      	pop	bx			;AN000;
 23248 0000163A 2E8B0E[3314]            	mov	cx,[cs:_$P_ORDINAL]	;AC034; return next ordinal
 23249 0000163F 2EA1[3514]              	mov	ax,[cs:_$P_RC]		;AC034; return exit code
 23250 00001643 2E8B36[3714]            	mov	si,[cs:_$P_SI_Save]	;AC034; return next operand pointer
 23251 00001648 2E8B16[3914]            	mov	dx,[cs:_$P_DX]		;AC034; return result buffer address
 23252 0000164D 2E8A1E[3B14]            	mov	bl,[cs:_$P_Terminator]	;AC034; return delimiter code found
 23253                                  _$P_Single_Exit: 			;AN000;
 23254 00001652 F8                      	clc				;AN000;
 23255 00001653 C3                      	retn				;AN000;
 23256                                  
 23257                                  ;***********************************************************************
 23258                                  ; _$P_Chk_Pos_Control
 23259                                  ;
 23260                                  ; Function: Parse CONTROL block for a positional
 23261                                  ;
 23262                                  ; Input:     ES:BX -> CONTROL block
 23263                                  ;	     cs:SI -> _$P_STRING_BUF
 23264                                  ;
 23265                                  ; Output:    None
 23266                                  ;
 23267                                  ; Use:	 _$P_Fill_Result, _$P_Check_Match_Flags
 23268                                  ;
 23269                                  ; Vars: _$P_Ordinal(W), _$P_RC(W)
 23270                                  ;***********************************************************************
 23271                                  
 23272                                  _$P_Chk_Pos_Control:
 23273 00001654 50                      	push	ax			;AN000;
 23274                                  	;mov	ax,[es:bx+_$P_Control_Blk.Match_Flag] ;AN000;
 23275 00001655 268B07                  	mov	ax,[es:bx]
 23276                                  	; 12/12/2022
 23277 00001658 A802                    	test	al,_$P_Repeat
 23278                                  	;test	ax,_$P_Repeat		;AN000; repeat allowed ?
 23279 0000165A 7505                    	jnz	short _$P_CPC00		;AN000; then do not increment ORDINAL
 23280                                  
 23281 0000165C 2EFF06[3314]            	inc	word [cs:_$P_ORDINAL]	;AC034; update the ordinal
 23282                                  _$P_CPC00:				;AN000;
 23283 00001661 2E803C00                	cmp	byte [cs:si],_$P_NULL	;AN000; no data ?
 23284 00001665 7518                    	jne	short _$P_CPC01		;AN000;
 23285                                  
 23286                                  	; 12/12/2022
 23287 00001667 A801                    	test	al,_$P_Optional
 23288                                  	;test	ax,_$P_Optional		;AN000; yes, then is it optional ?
 23289 00001669 7509                    	jnz	short _$P_CPC02		;AN000;
 23290                                  
 23291 0000166B 2EC706[3514]0200        	mov	word [cs:_$P_RC],_$P_Op_Missing ;AC034; no, then error 3/17/87
 23292 00001672 EB0E                    	jmp	short _$P_CPC_Exit	;AN000;
 23293                                  
 23294                                  _$P_CPC02:				;AN000;
 23295 00001674 50                      	push	ax			;AN000;
 23296 00001675 B003                    	mov	al,_$P_String		;AN000; if it is optional return NULL
 23297 00001677 B4FF                    	mov	ah,_$P_No_Tag		;AN000; no item tag indication
 23298 00001679 E89B00                  	call	_$P_Fill_Result		;AN000;
 23299 0000167C 58                      	pop	ax			;AN000;
 23300 0000167D EB03                    	jmp	short _$P_CPC_Exit	;AN000;
 23301                                  
 23302                                  _$P_CPC01:				;AN000;
 23303 0000167F E81A01                  	call	_$P_Check_Match_Flags	;AN000;
 23304                                  _$P_CPC_Exit:				;AN000;
 23305 00001682 58                      	pop	ax			;AN000;
 23306 00001683 C3                      	retn				;AN000;
 23307                                  
 23308                                  ;***********************************************************************
 23309                                  ; _$P_Chk_Key_Control
 23310                                  ;
 23311                                  ; Function: Parse CONTROL block for a keyword
 23312                                  ;
 23313                                  ; Input:     ES:BX -> CONTROL block
 23314                                  ;	     cs:SI -> _$P_STRING_BUF
 23315                                  ;
 23316                                  ; Output:    CY = 1 : not match
 23317                                  ;
 23318                                  ; Use:	 _$P_Fill_Result, _$P_Search_KEYorSW, _$P_Check_Match_Flags
 23319                                  ;
 23320                                  ; Vars: _$P_RC(W), _$P_SaveSI_Cmpx(W), _$P_KEYorSW_Ptr(R), _$P_Flags(W)
 23321                                  ;***********************************************************************
 23322                                  
 23323                                  _$P_Chk_Key_Control:
 23324 00001684 F9                      	stc				;AN000; this logic works when the KeySW
 23325 00001685 C3                      	retn				;AN000; is reset.
 23326                                  
 23327                                  ;***********************************************************************
 23328                                  ; _$P_Search_KEYorSW:
 23329                                  ;
 23330                                  ; Function: Seach specified keyword or switch from CONTROL
 23331                                  ;
 23332                                  ; Input:     ES:BX -> CONTROL block
 23333                                  ;	     cs:SI -> _$P_STRING_BUF
 23334                                  ;
 23335                                  ; Output:    CY = 1 : not match
 23336                                  ;
 23337                                  ; Use:	 _$P_String_Comp, _$P_MoveBP_NUL, _$P_Found_SYNONYM
 23338                                  ;***********************************************************************
 23339                                  
 23340                                  	; 25/10/2022 - Retro DOS v4.0
 23341                                  	; (MSDOS 5.0 IO.SYS - SYSINIT:18B6h)
 23342                                  
 23343                                  _$P_Search_KEYorSW:			;AN000;
 23344 00001686 55                      	push	bp			;AN000;
 23345 00001687 51                      	push	cx			;AN000;
 23346 00001688 268A4F08                	mov	cl,[es:bx+_$P_Control_Blk.nid] ;AN000; Get synonym count
 23347 0000168C 30ED                    	xor	ch,ch			;AN000; and set it to cx
 23348 0000168E 09C9                    	or	cx,cx			;AN000; No synonyms specified ?
 23349 00001690 740D                    	jz	short _$P_KEYorSW_Not_Found ;AN000; then indicate not found by CY
 23350                                  
 23351                                  	;lea	bp,[es:bx+_$P_Control_Blk.KEYorSW] ;AN000; BP points to the 1st synonym
 23352                                  	; 25/10/2022
 23353 00001692 8D6F09                  	lea	bp,[bx+_$P_Control_Blk.KEYorSW]
 23354                                  	;lea	bp,[bx+9]
 23355                                  _$P_KEYorSW_Loop:			;AN000;
 23356 00001695 E8D403                  	call	_$P_String_Comp		;AN000; compare string in buffer w/ the synonym
 23357 00001698 7308                    	jnc	short _$P_KEYorSW_Found	;AN000; If match, set it to synonym pointer
 23358                                  
 23359 0000169A E80E00                  	call	_$P_MoveBP_NUL		;AN000; else, bp points to the next string
 23360 0000169D E2F6                    	loop	_$P_KEYorSW_Loop 	;AN000; loop nid times
 23361                                  _$P_KEYorSW_Not_Found:			;AN000;
 23362 0000169F F9                      	stc				;AN000; indicate not found in synonym list
 23363 000016A0 EB06                    	jmp	short _$P_KEYorSW_Exit	;AN000; and exit
 23364                                  
 23365                                  _$P_KEYorSW_Found:			;AN000;
 23366 000016A2 2E892E[4814]            	mov	[cs:_$P_Found_SYNONYM],bp ;AC034; set synonym pointer
 23367 000016A7 F8                      	clc				;AN000; indicate found
 23368                                  _$P_KEYorSW_Exit:			;AN000;
 23369 000016A8 59                      	pop	cx			;AN000;
 23370 000016A9 5D                      	pop	bp			;AN000;
 23371 000016AA C3                      	retn				;AN000;
 23372                                   
 23373                                  ;***********************************************************************
 23374                                  ; _$P_MoveBP_NUL
 23375                                  ;***********************************************************************
 23376                                  
 23377                                  _$P_MoveBP_NUL:
 23378                                  _$P_MBP_Loop:				;AN000;
 23379                                  	; 11/12/2022
 23380 000016AB 26807E0000              	cmp	byte [es:bp],_$P_NULL	;AN000; Increment BP that points
 23381                                  	; 25/10/2022 (MSDOS 5.0 IO.SYS compatibility)
 23382                                  	; (SYSINIT:18DBh)
 23383                                   	;cmp     byte [es:bp+0],0
 23384 000016B0 7403                    	je	short _$P_MBP_Exit	;AN000; to the synomym list
 23385                                  
 23386 000016B2 45                      	inc	bp			;AN000; until
 23387 000016B3 EBF6                    	jmp	short _$P_MBP_Loop	;AN000; NULL encountered.
 23388                                  
 23389                                  _$P_MBP_Exit:				;AN000;
 23390 000016B5 45                      	inc	bp			;AN000; bp points to next to NULL
 23391 000016B6 C3                      	retn				;AN000;
 23392                                  
 23393                                  ;***********************************************************************
 23394                                  ; _$P_Chk_SW_Control
 23395                                  ;
 23396                                  ; Function: Parse CONTROL block for a switch
 23397                                  ;
 23398                                  ; Input:     ES:BX -> CONTROL block
 23399                                  ;	     cs:SI -> _$P_STRING_BUF
 23400                                  ;
 23401                                  ; Output:    CY = 1 : not match
 23402                                  ;
 23403                                  ; Use:	 _$P_Fill_Result, _$P_Search_KEYorSW, _$P_Check_Match_Flags
 23404                                  ;
 23405                                  ; Vars:  _$P_SaveSI_Cmpx(W), _$P_KEYorSW_Ptr(R), _$P_Flags(W)
 23406                                  ;***********************************************************************
 23407                                  
 23408                                  _$P_Chk_SW_Control:
 23409                                  
 23410                                  ;IF SwSW				;AN000;(Check if switch is supported)
 23411                                  	;or	byte [cs:_$P_Flags+1],10h
 23412 000016B7 2E800E[4114]10          	or	byte [cs:_$P_Flags2],_$P_SW_Cmp ;AC034; Indicate switch for later string comparison
 23413 000016BD E8C6FF                  	call	_$P_Search_KEYorSW	;AN000; Search the switch in the CONTROL block
 23414 000016C0 7248                    	jc	short _$P_Chk_SW_Err0	;AN000; not found, then try next CONTROL
 23415                                  
 23416                                  	;and	[cs:_$P_Flags+],0EFh
 23417 000016C2 2E8026[4114]EF          	and	byte [cs:_$P_Flags2],0FFh-_$P_SW_Cmp 
 23418                                  					;AC034; reset the indicator previously set
 23419 000016C8 50                      	push	ax			;AN000; 	      /switch:
 23420 000016C9 2EA1[4414]              	mov	ax,[cs:_$P_KEYorSW_Ptr] ;AC034;	      ^       ^
 23421 000016CD 29F0                    	sub	ax,si			;AN000;  SI	KEYorSW
 23422 000016CF 2E0106[4214]            	add	[cs:_$P_SaveSI_Cmpx],ax	;AC034; update for complex list
 23423 000016D4 58                      	pop	ax			;AN000;
 23424                                  
 23425 000016D5 2E8B36[4414]            	mov	si,[cs:_$P_KEYorSW_Ptr] ;AC034; set si at the end or colon
 23426 000016DA 2E803C00                	cmp	byte [cs:si],_$P_NULL	;AN000; any data after colon
 23427 000016DE 7525                    	jne	short _$P_CSW00		;AN000; if yes, process match flags
 23428                                  
 23429 000016E0 2E807CFF3A              	cmp	byte [cs:si-1],_$P_Colon ;AN000; if no, the switch terminated by colon ?
 23430 000016E5 7509                    	jne	short _$P_Chk_if_data_required ;AN000; if yes,
 23431                                  
 23432 000016E7 2EC706[3514]0900        	mov	word [cs:_$P_RC],_$P_Syntax ;AC034; return syntax error
 23433 000016EE EB1C                    	jmp	short _$P_Chk_SW_Exit	;AN000;
 23434                                  
 23435                                  _$P_Chk_if_data_required:		;AN018; no data, no colon
 23436                                  	;cmp	word [es:bx+_$P_Control_Blk.Match_Flag],0 
 23437 000016F0 26833F00                	cmp	word [es:bx],0		;AN018; should have data? zero match flag means switch followed by nothing is OK
 23438 000016F4 7416                    	je	short _$P_Chk_SW_Exit	;AN018; match flags not zero so should have something if optional bit is not on
 23439                                  
 23440                                  	;test	word [es:bx+_$P_Control_Blk.Match_Flag],_$P_Optional 
 23441                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYINIT compatibility)
 23442                                  	;test	word [es:bx],1
 23443                                  	; 12/12/2022
 23444                                  	;test	word [es:bx],_$P_Optional ;AN019; see if no value is valid
 23445 000016F6 26F60701                	test	byte [es:bx],_$P_Optional
 23446 000016FA 7510                    	jnz	short _$P_Chk_SW_Exit	;AN019; if so, then leave, else yell
 23447                                  
 23448 000016FC 2EC706[3514]0200        	mov	word [cs:_$P_RC],_$P_Op_Missing ;AC034; return required operand missing
 23449 00001703 EB07                    	jmp	short _$P_Chk_SW_Exit	;AN018;
 23450                                  
 23451                                  _$P_CSW00:				;AN000;
 23452 00001705 E89400                  	call	_$P_Check_Match_Flags	;AN000; process match flag
 23453 00001708 F8                      	clc				;AN000; indicate match
 23454                                  	;jmp	short _$P_Chk_SW_Single_Exit ;AN000;
 23455                                  	; 12/12/2022
 23456 00001709 C3                      	retn
 23457                                  
 23458                                  _$P_Chk_SW_Err0: 			;AN000;
 23459 0000170A F9                      	stc				;AN000; not found in switch synonym list
 23460                                  	;jmp	short _$P_Chk_SW_Single_Exit ;AN000;
 23461                                  	; 12/12/2022
 23462 0000170B C3                      	retn	
 23463                                  
 23464                                  _$P_Chk_SW_Exit: 			;AN000;
 23465 0000170C 50                      	push	ax			;AN000;
 23466 0000170D B003                    	mov	al,_$P_String		;AN000; set
 23467 0000170F B4FF                    	mov	ah,_$P_No_Tag		;AN000;    result
 23468 00001711 E80300                  	call	_$P_Fill_Result		;AN000; 	 buffer
 23469 00001714 58                      	pop	ax			;AN000;
 23470 00001715 F8                      	clc				;AN000;
 23471                                  _$P_Chk_SW_Single_Exit:			;AN000;
 23472 00001716 C3                      	retn				;AN000;
 23473                                  ;ELSE					;AN000;(of IF SwSW)
 23474                                  ;	stc				;AN000; this logic works when the SwSW
 23475                                  ;	retn				;AN000; is reset.
 23476                                  
 23477                                  ;***********************************************************************
 23478                                  ; _$P_Fill_Result
 23479                                  ;
 23480                                  ; Function: Fill the result buffer
 23481                                  ;
 23482                                  ; Input:    AH = Item tag
 23483                                  ;	    AL = type
 23484                                  ;		  AL = 1: CX,DX has 32bit number (CX = high)
 23485                                  ;		  AL = 2: DX has index(offset) into value list
 23486                                  ;		  AL = 6: DL has driver # (1-A, 2-B, ... , 26 - Z)
 23487                                  ;		  AL = 7: DX has year, CL has month and CH has date
 23488                                  ;		  AL = 8: DL has hours, DH has minutes, CL has seconds,
 23489                                  ;			  amd CH has hundredths
 23490                                  ;		  AL = else: cs:SI points to returned string buffer
 23491                                  ;	    ES:BX -> CONTROL block
 23492                                  ;
 23493                                  ; Output:   None
 23494                                  ;
 23495                                  ; Use:	_$P_Do_CAPS_String, _$P_Remove_Colon, _$P_Found_SYNONYM
 23496                                  ;
 23497                                  ; Vars: _$P_DX(W)
 23498                                  ;***********************************************************************
 23499                                  
 23500                                  _$P_Fill_Result:
 23501 00001717 57                      	push	di			;AN000;
 23502 00001718 268B7F04                	mov	di,[es:bx+_$P_Control_Blk.Result_Buf]
 23503                                  					;AN000; di points to result buffer
 23504 0000171C 2E893E[3914]            	mov	[cs:_$P_DX],di		;AC034; set returned result address
 23505 00001721 268805                  	mov	[es:di+_$P_Result_Blk.Type],al ;AN000; store type
 23506 00001724 26886501                	mov	[es:di+_$P_Result_Blk.Item_Tag],ah ;AN000; store item tag
 23507 00001728 50                      	push	ax			;AN000;
 23508 00001729 2EA1[4814]              	mov	ax,[cs:_$P_Found_SYNONYM] ;AC034; if yes,
 23509 0000172D 26894502                	mov	[es:di+_$P_Result_Blk.SYNONYM_Ptr],ax 
 23510                                  					;AN000;   then set it to the result
 23511 00001731 58                      	pop	ax			;AN000;
 23512                                  _$P_RLT04:				;AN000;
 23513 00001732 3C01                    	cmp	al,_$P_Number		;AN000; if number
 23514 00001734 750A                    	jne	short _$P_RLT00		;AN000;
 23515                                  
 23516                                  _$P_RLT02:				;AN000;
 23517 00001736 26895504                	mov	[es:di+_$P_Result_Blk.Picked_Val],dx ;AN000; then store 32bit
 23518 0000173A 26894D06                	mov	[es:di+_$P_Result_Blk.Picked_Val+2],cx ;AN000; number
 23519 0000173E EB5A                    	jmp	short _$P_RLT_Exit	;AN000;
 23520                                  
 23521                                  _$P_RLT00:				;AN000;
 23522 00001740 3C02                    	cmp	al,_$P_List_Idx		;AN000; if list index
 23523 00001742 7506                    	jne	short _$P_RLT01		;AN000;
 23524                                  
 23525 00001744 26895504                	mov	word [es:di+_$P_Result_Blk.Picked_Val],dx 
 23526                                  					;AN000; then store list index
 23527 00001748 EB50                    	jmp	short _$P_RLT_Exit	;AN000;
 23528                                  
 23529                                  _$P_RLT01:				;AN000;
 23530 0000174A 3C07                    	cmp	al,_$P_Date_F		;AN000; Date format ?
 23531 0000174C 74E8                    	je	short _$P_RLT02		;AN000;
 23532                                  
 23533 0000174E 3C08                    	cmp	al,_$P_Time_F		;AN000; Time format ?
 23534 00001750 74E4                    	je	short _$P_RLT02		;AN000;
 23535                                  
 23536 00001752 3C06                    	cmp	al,_$P_Drive		;AN000; drive format ?
 23537 00001754 7506                    	jne	short _$P_RLT03		;AN000;
 23538                                  
 23539 00001756 26885504                	mov	[es:di+_$P_Result_Blk.Picked_Val],dl ;AN000; store drive number
 23540 0000175A EB3E                    	jmp	short _$P_RLT_Exit	;AN000;
 23541                                  
 23542                                  _$P_RLT03:				;AN000;
 23543 0000175C 3C04                    	cmp	al,_$P_Complex		;AN000; complex format ?
 23544 0000175E 750F                    	jne	short _$P_RLT05		;AN000;
 23545                                  
 23546 00001760 2EA1[4214]              	mov	ax,[cs:_$P_SaveSI_Cmpx] ;AC034; then get pointer in command buffer
 23547 00001764 40                      	inc	ax			;AN000; skip left Parentheses
 23548 00001765 26894504                	mov	[es:di+_$P_Result_Blk.Picked_Val],ax ;AN000; store offset
 23549 00001769 268C5D06                	mov	[es:di+_$P_Result_Blk.Picked_Val+2],ds ;AN000; store segment
 23550 0000176D EB2B                    	jmp	short _$P_RLT_Exit	;AN000;
 23551                                  
 23552                                  _$P_RLT05:				;AN000;
 23553                                  ;------------------------  AL = 3, 5, or 9
 23554 0000176F 26897504                	mov	[es:di+_$P_Result_Blk.Picked_Val],si 
 23555                                  					;AN000; store offset of STRING_BUF
 23556 00001773 268C4D06                	mov	[es:di+_$P_Result_Blk.Picked_Val+2],cs 
 23557                                  					;AN031; store segment of STRING_BUF
 23558 00001777 50                      	push	ax			;AN000;
 23559 00001778 26F6470201              	test	byte [es:bx+_$P_Control_Blk.Function_Flag],_$P_CAP_File 
 23560                                  					;AN000; need CAPS by file table?
 23561 0000177D 7404                    	jz	short _$P_RLT_CAP00	;AN000;
 23562                                  
 23563 0000177F B004                    	mov	al,_$P_DOSTBL_File	;AN000; use file upper case table
 23564 00001781 EB09                    	jmp	short _$P_RLT_CAP02	;AN000;
 23565                                  
 23566                                  _$P_RLT_CAP00:				;AN000;
 23567 00001783 26F6470202              	test	byte [es:bx+_$P_Control_Blk.Function_Flag],_$P_CAP_Char 
 23568                                  					;AN000; need CAPS by char table ?
 23569 00001788 7405                    	jz	short _$P_RLT_CAP01	;AN000;
 23570                                  
 23571 0000178A B002                    	mov	al,_$P_DOSTBL_Char	;AN000; use character upper case table
 23572                                  _$P_RLT_CAP02:				;AN000;
 23573 0000178C E8E000                  	call	_$P_Do_CAPS_String	;AN000;  process CAPS along the table
 23574                                  _$P_RLT_CAP01:				;AN000;
 23575 0000178F 58                      	pop	ax			;AN000;
 23576 00001790 26F6470210              	test	byte [es:bx+_$P_Control_Blk.Function_Flag],_$P_Rm_Colon 
 23577                                  					;AN000; removing colon at end ?
 23578 00001795 7403                    	jz	short _$P_RLT_Exit	;AN000;
 23579                                  
 23580 00001797 E8AF00                  	call	_$P_Remove_Colon 	;AN000; then process it.
 23581                                  _$P_RLT_Exit:				;AN000;
 23582 0000179A 5F                      	pop	di			;AN000;
 23583 0000179B C3                      	retn				;AN000;
 23584                                  
 23585                                  ;***********************************************************************
 23586                                  ; _$P_Check_Match_Flags
 23587                                  ;
 23588                                  ; Function:  Check the mutch_flags and make the exit code and set the
 23589                                  ;	     result buffer
 23590                                  ;
 23591                                  ;	    Check for types in this order:
 23592                                  ;		Complex
 23593                                  ;		Date
 23594                                  ;		Time
 23595                                  ;		Drive
 23596                                  ;		Filespec
 23597                                  ;		Quoted String
 23598                                  ;		Simple String
 23599                                  ;
 23600                                  ; Input:     cs:SI -> _$P_STRING_BUF
 23601                                  ;	     ES:BX -> CONTROL block
 23602                                  ;
 23603                                  ; Output:    None
 23604                                  ;
 23605                                  ; Use:	     _$P_Value, P$_SValue, _$P_Simple_String, _$P_Date_Format
 23606                                  ;	     _$P_Time_Format, _$P_Complex_Format, _$P_File_Foemat
 23607                                  ;	     _$P_Drive_Format
 23608                                  ;***********************************************************************
 23609                                  
 23610                                  	; 25/10/2022 - Retro DOS v4.0
 23611                                  	; (MSDOS 5.0 IO.SYS - SYSINIT:19CFh)
 23612                                  
 23613                                  	; 12/12/2022
 23614                                  _$P_Check_Match_Flags:
 23615 0000179C 2EC606[D814]00          	mov	byte [cs:_$P_err_flag],_$P_NULL 
 23616                                  					;AN033;AC034;; clear filespec error flag.
 23617 000017A2 50                      	push	ax			;AN000;
 23618                                  	;mov	ax,[es:bx+_$P_Control_Blk.Match_Flag]
 23619 000017A3 268B07                  	mov	ax,[es:bx]		;AN000; load match flag(16bit) to ax
 23620 000017A6 09C0                    	or	ax,ax			;AC035; test ax for zero
 23621 000017A8 7518                    	jnz	short _$P_Mat		;AN000; (tm12)
 23622 000017AA 50                      	push	ax			;AN000; (tm12)
 23623 000017AB 53                      	push	bx			;AN000; (tm12)
 23624 000017AC 52                      	push	dx			;AN000; (tm12)
 23625 000017AD 57                      	push	di			;AN000; (tm12)
 23626 000017AE 2EC706[3514]0900        	mov	word [cs:_$P_RC],_$P_Syntax ;AC034; (tm12)
 23627 000017B5 B4FF                    	mov	ah,_$P_No_Tag		;AN000; (tm12)
 23628 000017B7 B003                    	mov	al,_$P_String		;AN000; (tm12)
 23629 000017B9 E85BFF                  	call	_$P_Fill_Result		;AN000; (tm12)
 23630 000017BC 5F                      	pop	di			;AN000; (tm12)
 23631 000017BD 5A                      	pop	dx			;AN000; (tm12)
 23632 000017BE 5B                      	pop	bx			;AN000; (tm12)
 23633 000017BF 58                      	pop	ax			;AN000; (tm12)
 23634                                  	; 12/12/2022
 23635                                  	;jmp	short _$P_Bridge 	;AC035; (tm12)
 23636                                  	; 12/12/2022
 23637                                  ;_$P_Mat: 				;AN000; (tm12)
 23638                                  	;jmp	short _$P_Match03	;AN025; (tm09)
 23639                                  _$P_Bridge:
 23640 000017C0 EB6E                    	jmp	short _$P_Match_Exit	;AN000; (tm02)
 23641                                  	
 23642                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 23643                                  	; (SYSINIT:19F9h)
 23644                                  	; 12/12/2022
 23645                                  	;nop	; db 90h
 23646                                  
 23647                                  ; 12/12/2022
 23648                                  _$P_Mat:
 23649                                  _$P_Match03:				;AN000;
 23650 000017C2 A90080                  	test	ax,_$P_Num_Val		;AN000; Numeric value
 23651 000017C5 7412                    	jz	short _$P_Match04	;AN000;
 23652                                  
 23653 000017C7 2EC706[3514]0000        	mov	word [cs:_$P_RC],_$P_No_Error ;AC034; assume no error
 23654 000017CE E82201                  	call	_$P_Value		;AN000; do process
 23655 000017D1 2E833E[3514]09          	cmp	word [cs:_$P_RC],_$P_Syntax ;AC034; if error, examine the next type
 23656 000017D7 7557                    	jne	short _$P_Match_Exit	;AN000;
 23657                                  _$P_Match04:				;AN000;
 23658 000017D9 A90040                  	test	ax,_$P_SNum_Val		;AN000; Signed numeric value
 23659 000017DC 7412                    	jz	short _$P_Match05	;AN000;
 23660                                  
 23661 000017DE 2EC706[3514]0000        	mov	word [cs:_$P_RC],_$P_No_Error ;AC034; assume no error
 23662 000017E5 E8E700                  	call	_$P_SValue		;AN000; do process
 23663 000017E8 2E833E[3514]09          	cmp	word [cs:_$P_RC],_$P_Syntax ;AC034; if error, examine the next type
 23664 000017EE 7540                    	jne	short _$P_Match_Exit	;AN000;
 23665                                  _$P_Match05:				;AN000;
 23666 000017F0 A90001                  	test	ax,_$P_Drv_Only		;AN000; Drive only
 23667 000017F3 7415                    	jz	short _$P_Match06	;AN000;
 23668                                  
 23669 000017F5 2EC706[3514]0000        	mov	word [cs:_$P_RC],_$P_No_Error ;AC034; assume no error
 23670 000017FC E80B03                  	call	_$P_File_Format		;AN000; 1st, call file format
 23671 000017FF E88D03                  	call	_$P_Drive_Format	;AN000; check drive format, next
 23672 00001802 2E833E[3514]09          	cmp	word [cs:_$P_RC],_$P_Syntax ;AC034; if error, examine the next type
 23673 00001808 7526                    	jne	short _$P_Match_Exit	;AN000;
 23674                                  _$P_Match06:				;AN000;
 23675 0000180A A90002                  	test	ax,_$P_File_Spc		;AN000; File spec
 23676 0000180D 7412                    	jz	short _$P_Match07	;AN000;
 23677                                  
 23678 0000180F 2EC706[3514]0000        	mov	word [cs:_$P_RC],_$P_No_Error ;AC034; assume no error
 23679 00001816 E8F102                  	call	_$P_File_Format		;AN000; do process
 23680 00001819 2E833E[3514]09          	cmp	word [cs:_$P_RC],_$P_Syntax ;AC034; if error, examine the next type
 23681 0000181F 750F                    	jne	short _$P_Match_Exit	;AN000;
 23682                                  _$P_Match07:				;AN000;
 23683 00001821 A90020                  	test	ax,_$P_Simple_S		;AN000; Simple string
 23684 00001824 740A                    	jz	short _$P_Match09	;AN000;
 23685                                  
 23686 00001826 2EC706[3514]0000        	mov	word [cs:_$P_RC],_$P_No_Error ;AC034; assume no error
 23687 0000182D E8D301                  	call	_$P_Simple_String	;AN000; do process
 23688                                  _$P_Match09:				;AN000;
 23689                                  _$P_Match_Exit:				;AN000;
 23690 00001830 2E833E[D814]01          	cmp	word [cs:_$P_err_flag],_$P_error_filespec ;AC034; bad filespec ?
 23691 00001836 750F                    	jne	short _$P_Match2_Exit	;AN033; no, continue
 23692 00001838 2E833E[3514]00          	cmp	word [cs:_$P_RC],_$P_No_Error ;AN033;AC034;; check for other errors ?
 23693 0000183E 7507                    	jne	short _$P_Match2_Exit	;AN033; no, continue
 23694 00001840 2EC706[3514]0900        	mov	word [cs:_$P_RC],_$P_Syntax ;AN033;AC034;; set error flag
 23695                                  _$P_Match2_Exit: 			;AN033;
 23696 00001847 58                      	pop	ax			;AN000;
 23697 00001848 C3                      	retn				;AN000;
 23698                                  
 23699                                  ;***********************************************************************
 23700                                  ; _$P_Remove_Colon;
 23701                                  ;
 23702                                  ; Function: Remove colon at end
 23703                                  ;
 23704                                  ; Input:    cs:SI points to string buffer to be examineed
 23705                                  ;
 23706                                  ; Output:   None
 23707                                  ;
 23708                                  ; Use:	_$P_Chk_DBCS
 23709                                  ;***********************************************************************
 23710                                  
 23711                                  _$P_Remove_Colon:
 23712 00001849 50                      	push	ax			;AN000;
 23713 0000184A 56                      	push	si			;AN000;
 23714                                  _$P_RCOL_Loop:				;AN000;
 23715 0000184B 2E8A04                  	mov	al,[cs:si]		;AN000; get character
 23716 0000184E 08C0                    	or	al,al			;AN000; end of string ?
 23717 00001850 741A                    	jz	short _$P_RCOL_Exit	;AN000; if yes, just exit
 23718                                  
 23719 00001852 3C3A                    	cmp	al,_$P_Colon		;AN000; is it colon ?
 23720 00001854 750D                    	jne	short _$P_RCOL00	;AN000;
 23721                                  
 23722 00001856 2E807C0100              	cmp	byte [cs:si+1],_$P_NULL ;AN000; if so, next is NULL ?
 23723 0000185B 7506                    	jne	short _$P_RCOL00	;AN000; no, then next char
 23724                                  
 23725 0000185D 2EC60400                	mov	byte [cs:si],_$P_NULL	;AN000; yes, remove colon
 23726 00001861 EB09                    	jmp	short _$P_RCOL_Exit	;AN000; and exit.
 23727                                  
 23728                                  _$P_RCOL00:				;AN000;
 23729 00001863 E84004                  	call	_$P_Chk_DBCS		;AN000; if not colon, then check if
 23730 00001866 7301                    	jnc	short _$P_RCOL01	;AN000; DBCS leading byte.
 23731                                  
 23732 00001868 46                      	inc	si			;AN000; if yes, skip trailing byte
 23733                                  _$P_RCOL01:				;AN000;
 23734 00001869 46                      	inc	si			;AN000; si points to next byte
 23735 0000186A EBDF                    	jmp	short _$P_RCOL_Loop	;AN000; loop until NULL encountered
 23736                                  
 23737                                  _$P_RCOL_Exit:				;AN000;
 23738 0000186C 5E                      	pop	si			;AN000;
 23739 0000186D 58                      	pop	ax			;AN000;
 23740 0000186E C3                      	retn				;AN000;
 23741                                  
 23742                                  ;***********************************************************************
 23743                                  ; _$P_Do_CAPS_String;
 23744                                  ;
 23745                                  ; Function: Perform capitalization along with the file case map table
 23746                                  ;	    or character case map table.
 23747                                  ;
 23748                                  ; Input:    AL = 2 : Use character table
 23749                                  ;	    AL = 4 : Use file table
 23750                                  ;	    cs:SI points to string buffer to be capitalized
 23751                                  ;
 23752                                  ; Output:   None
 23753                                  ;
 23754                                  ; Use:	_$P_Do_CAPS_Char, _$P_Chk_DBCS
 23755                                  ;***********************************************************************
 23756                                  
 23757                                  _$P_Do_CAPS_String:
 23758 0000186F 56                      	push	si			;AN000;
 23759 00001870 52                      	push	dx			;AN000;
 23760 00001871 88C2                    	mov	dl,al			;AN000; save info id
 23761                                  
 23762                                  _$P_DCS_Loop:				;AN000;
 23763 00001873 2E8A04                  	mov	al,[cs:si]		;AN000; load charater and
 23764 00001876 E82D04                  	call	_$P_Chk_DBCS		;AN000; check if DBCS leading byte
 23765 00001879 720C                    	jc	short _$P_DCS00		;AN000; if yes, do not need CAPS
 23766                                  
 23767 0000187B 08C0                    	or	al,al			;AN000; end of string ?
 23768 0000187D 740C                    	jz	short _$P_DCS_Exit	;AN000; then exit.
 23769                                  
 23770 0000187F E80C00                  	call	_$P_Do_CAPS_Char 	;AN000; Here a SBCS char need to be CAPS
 23771 00001882 2E8804                  	mov	[cs:si],al		;AN000; stored upper case char to buffer
 23772 00001885 EB01                    	jmp	short _$P_DCS01		;AN000; process next
 23773                                  _$P_DCS00:				;AN000;
 23774 00001887 46                      	inc	si			;AN000; skip DBCS leading and trailing byte
 23775                                  _$P_DCS01:				;AN000;
 23776 00001888 46                      	inc	si			;AN000; si point to next byte
 23777 00001889 EBE8                    	jmp	short _$P_DCS_Loop	;AN000; loop until NULL encountered
 23778                                  _$P_DCS_Exit:				;AN000;
 23779 0000188B 5A                      	pop	dx			;AN000;
 23780 0000188C 5E                      	pop	si			;AN000;
 23781 0000188D C3                      	retn
 23782                                  
 23783                                  ;***********************************************************************
 23784                                  ; _$P_Do_CAPS_Char;
 23785                                  ;
 23786                                  ; Function: Perform capitalization along with the file case map table
 23787                                  ;	    or character case map table.
 23788                                  ;
 23789                                  ; Input:    DL = 2 : Use character table
 23790                                  ;	    DL = 4 : Use file table
 23791                                  ;	    AL = character to be capitalized
 23792                                  ;
 23793                                  ; Output:   None
 23794                                  ;
 23795                                  ; Use:	INT 21h /w AH=65h
 23796                                  ;***********************************************************************
 23797                                  
 23798                                  _$P_Do_CAPS_Char:
 23799 0000188E 3C80                    	cmp	al,_$P_ASCII80	;80h	;AN000; need upper case table ?
 23800 00001890 730C                    	jae	short _$P_DCC_Go	;AN000;
 23801                                  
 23802 00001892 3C61                    	cmp	al,"a"                  ;AN000; if no,
 23803 00001894 7238                    	jb	short _$P_CAPS_Ret	;AN000;   check if  "a" <= AL <= "z"
 23804                                  
 23805 00001896 3C7A                    	cmp	al,"z"                  ;AN000;
 23806 00001898 7734                    	ja	short _$P_CAPS_Ret	;AN000;   if yes, make CAPS
 23807                                  
 23808 0000189A 24DF                    	and	al,_$P_Make_Upper ;0DFh ;AN000;   else do nothing.
 23809 0000189C EB30                    	jmp	short _$P_CAPS_Ret	;AN000;
 23810                                  
 23811                                  _$P_DCC_Go:				;AN000;
 23812 0000189E 53                      	push	bx			;AN000;
 23813 0000189F 06                      	push	es			;AN000;
 23814 000018A0 57                      	push	di			;AN000;
 23815                                  
 23816                                  	;lea	di,[cs:_$P_Char_CAP_Ptr] ;AC034; or use char CAPS table ?
 23817 000018A1 8D3E[CA14]              	lea	di,[_$P_Char_CAP_Ptr]
 23818                                  _$P_DCC00:				;AN000;
 23819 000018A5 2E3815                  	cmp	[cs:di],dl		;AN000; already got table address ?
 23820 000018A8 7417                    	je	short _$P_DCC01		;AN000; if no,
 23821                                  
 23822                                  ;In this next section, ES will be used to pass a 5 byte workarea to INT 21h,
 23823                                  ; the GET COUNTYRY INFO call. This usage of ES is required by the function
 23824                                  ; call, regardless of what base register is currently be defined as cs.
 23825                                  
 23826 000018AA 50                      	push	ax			;AN000; get CAPS table thru DOS call
 23827 000018AB 51                      	push	cx			;AN000;
 23828 000018AC 52                      	push	dx			;AN000;
 23829                                  
 23830 000018AD 0E                      	push	cs			;AC036; pass current base seg into
 23831                                  					;(Note: this used to push CS.  BUG...
 23832 000018AE 07                      	pop	es			;AN000;   ES reg, required for
 23833                                  					;get extended country information
 23834 000018AF B465                    	mov	ah,_$P_DOS_Get_TBL	;AN000; get extended CDI
 23835 000018B1 88D0                    	mov	al,dl			;AN000; upper case table
 23836 000018B3 BBFFFF                  	mov	bx,_$P_DOSTBL_Def	;AN000; get active CON
 23837 000018B6 B90500                  	mov	cx,_$P_DOSTBL_BL 	;AN000; buffer length
 23838 000018B9 BAFFFF                  	mov	dx,_$P_DOSTBL_Def	;AN000; get for default code page
 23839                                  					;DI already set to point to buffer
 23840 000018BC CD21                    	int	21h			;AN000; es:di point to buffer that
 23841                                  					;now has been filled in with info
 23842 000018BE 5A                      	pop	dx			;AN000;
 23843 000018BF 59                      	pop	cx			;AN000;
 23844 000018C0 58                      	pop	ax			;AN000;
 23845                                  
 23846                                  _$P_DCC01:				;AN000;
 23847                                  
 23848                                  ;In this next section, ES will be used as the base of the XLAT table, provided
 23849                                  ; by the previous GET COUNTRY INFO DOS call.  This usage of ES is made
 23850                                  ; regardless of which base reg is currently the cs reg.
 23851                                  
 23852                                  	; 28/09/2023
 23853                                  	;mov	bx,[cs:di+_$P_DOS_TBL.Off] ;AN000; get offset of table
 23854                                  	;mov	es,[cs:di+_$P_DOS_TBL.Seg] ;AN000; get segment of table
 23855                                  	; 07/07/2023
 23856 000018C1 2EC45D01                	les	bx,[cs:di+_$P_DOS_TBL.Off]
 23857 000018C5 43                      	inc	bx			;AC035; add '2' to
 23858 000018C6 43                      	inc	bx			;AC035;  BX reg
 23859                                  					;AN000; skip length field
 23860 000018C7 2C80                    	sub	al,_$P_ASCII80 ; 80h	;AN000; make char to index
 23861                                  	;xlat	es:[bx] 		;AN000; perform case map
 23862 000018C9 26                      	es
 23863 000018CA D7                      	xlat
 23864 000018CB 5F                      	pop	di			;AN000;
 23865 000018CC 07                      	pop	es			;AN000;
 23866 000018CD 5B                      	pop	bx			;AN000;
 23867                                  _$P_CAPS_Ret:				;AN000;
 23868 000018CE C3                      	retn				;AN000;
 23869                                  
 23870                                  ;***********************************************************************
 23871                                  ; _$P_Value / _$P_SValue
 23872                                  ;
 23873                                  ; Function:  Make 32bit value from cs:SI and see value list
 23874                                  ;	     and make result buffer.
 23875                                  ;	     _$P_SValue is an entry point for the signed value
 23876                                  ;	     and this will simply call _$P_Value after the handling
 23877                                  ;	     of the sign character, "+" or "-"
 23878                                  ;
 23879                                  ; Input:     cs:SI -> _$P_STRING_BUF
 23880                                  ;	     ES:BX -> CONTROL block
 23881                                  ;
 23882                                  ; Output:    None
 23883                                  ;
 23884                                  ; Use:	_$P_Fill_Result, _$P_Check_OVF
 23885                                  ;
 23886                                  ; Vars: _$P_RC(W), _$P_Flags(RW)
 23887                                  ;***********************************************************************
 23888                                  
 23889                                  	; 26/10/2022 - Retro DOS v4.0
 23890                                  	; (MSDOS 5.0 IO.SYS - SYSINIT:1B0Bh)
 23891                                  
 23892                                  _$P_SValue:				;AN000; when signed value here
 23893 000018CF 50                      	push	ax			;AN000;
 23894 000018D0 2E800E[4114]80          	or	byte [cs:_$P_Flags2],_$P_Signed ;AC034; indicate a signed numeric
 23895 000018D6 2E8026[4114]FD          	and	byte [cs:_$P_Flags2],0FFh-_$P_Neg ;AC034; assume positive value
 23896 000018DC 2E8A04                  	mov	al,[cs:si]		;AN000; get sign
 23897 000018DF 3C2B                    	cmp	al,_$P_Plus		;AN000; "+" ?
 23898 000018E1 740A                    	je	short _$P_SVal00	;AN000;
 23899                                  
 23900 000018E3 3C2D                    	cmp	al,_$P_Minus		;AN000; "-" ?
 23901 000018E5 7507                    	jne	short _$P_Sval01	;AN000; else
 23902                                  
 23903 000018E7 2E800E[4114]02          	or	byte [cs:_$P_Flags2],_$P_Neg ;AC034; set this is negative value
 23904                                  _$P_SVal00:				;AN000;
 23905 000018ED 46                      	inc	si			;AN000; skip sign char
 23906                                  _$P_Sval01:				;AN000;
 23907 000018EE E80200                  	call	_$P_Value		;AN000; and process value
 23908 000018F1 58                      	pop	ax			;AN000;
 23909 000018F2 C3                      	retn
 23910                                  
 23911                                  ;***********************************************************************
 23912                                  
 23913                                  	; 26/10/2022
 23914                                  _$P_Value:				;AN000;
 23915 000018F3 50                      	push	ax			;AN000;
 23916 000018F4 51                      	push	cx			;AN000;
 23917 000018F5 52                      	push	dx			;AN000;
 23918 000018F6 56                      	push	si			;AN000;
 23919 000018F7 31C9                    	xor	cx,cx			;AN000; cx = higher 16 bits
 23920 000018F9 31D2                    	xor	dx,dx			;AN000; dx = lower 16 bits
 23921 000018FB 53                      	push	bx			;AN000; save control pointer
 23922                                  _$P_Value_Loop:				;AN000;
 23923 000018FC 2E8A04                  	mov	al,[cs:si]		;AN000; get character
 23924 000018FF 08C0                    	or	al,al			;AN000; end of line ?
 23925 00001901 7442                    	jz	short _$P_Value00	;AN000;
 23926                                  
 23927 00001903 E8F000                  	call	_$P_0099 		;AN000; make asc(0..9) to bin(0..9)
 23928 00001906 7239                    	jc	short _$P_Value_Err0	;AN000;
 23929                                  
 23930 00001908 30E4                    	xor	ah,ah			;AN000;
 23931 0000190A 89C5                    	mov	bp,ax			;AN000; save binary number
 23932 0000190C D1E2                    	shl	dx,1			;AN000; to have 2*x
 23933 0000190E D1D1                    	rcl	cx,1			;AN000; shift left w/ carry
 23934 00001910 E8D100                  	call	_$P_Check_OVF		;AN000; Overflow occurred ?
 23935 00001913 722C                    	jc	short _$P_Value_Err0	;AN000; then error, exit
 23936                                  
 23937 00001915 89D3                    	mov	bx,dx			;AN000; save low(2*x)
 23938 00001917 89C8                    	mov	ax,cx			;AN000; save high(2*x)
 23939 00001919 D1E2                    	shl	dx,1			;AN000; to have 4*x
 23940 0000191B D1D1                    	rcl	cx,1			;AN000; shift left w/ carry
 23941 0000191D E8C400                  	call	_$P_Check_OVF		;AN000; Overflow occurred ?
 23942 00001920 721F                    	jc	short _$P_Value_Err0	;AN000; then error, exit
 23943                                  
 23944 00001922 D1E2                    	shl	dx,1			;AN000; to have 8*x
 23945 00001924 D1D1                    	rcl	cx,1			;AN000; shift left w/ carry
 23946 00001926 E8BB00                  	call	_$P_Check_OVF		;AN000; Overflow occurred ?
 23947 00001929 7216                    	jc	short _$P_Value_Err0	;AN000; then error, exit
 23948                                  
 23949 0000192B 01DA                    	add	dx,bx			;AN000; now have 10*x
 23950 0000192D 11C1                    	adc	cx,ax			;AN000; 32bit ADD
 23951 0000192F E8B200                  	call	_$P_Check_OVF		;AN000; Overflow occurred ?
 23952 00001932 720D                    	jc	short _$P_Value_Err0	;AN000; then error, exit
 23953                                  
 23954 00001934 01EA                    	add	dx,bp			;AN000; Add the current one degree decimal
 23955 00001936 83D100                  	adc	cx,0			;AN000; if carry, add 1 to high 16bit
 23956 00001939 E8A800                  	call	_$P_Check_OVF		;AN000; Overflow occurred ?
 23957 0000193C 7203                    	jc	short _$P_Value_Err0	;AN000; then error, exit
 23958                                  
 23959 0000193E 46                      	inc	si			;AN000; update pointer
 23960 0000193F EBBB                    	jmp	short _$P_Value_Loop	;AN000; loop until NULL encountered
 23961                                  ;
 23962                                  _$P_Value_Err0:				;AN000;
 23963 00001941 5B                      	pop	bx			;AN000;
 23964 00001942 E98C00                  	jmp	_$P_Value_Err		;AN000; Bridge
 23965                                  ;
 23966                                  _$P_Value00:				;AN000;
 23967 00001945 5B                      	pop	bx			;AN000; restore control pointer
 23968 00001946 2EF606[4114]02          	test	byte [cs:_$P_Flags2],_$P_Neg ;AC034; here cx,dx = 32bit value
 23969 0000194C 740A                    	jz	short _$P_Value01	;AN000; was it negative ?
 23970                                  
 23971 0000194E F7D1                    	not	cx			;AN000; +
 23972 00001950 F7D2                    	not	dx			;AN000; |- Make 2's complement
 23973 00001952 83C201                  	add	dx,1			;AN000; |
 23974 00001955 83D100                  	adc	cx,0			;AN000; +
 23975                                  
 23976                                  _$P_Value01:				;AN000; / nval =0
 23977 00001958 268B7706                	mov	si,[es:bx+_$P_Control_Blk.Value_List] ;AN000; si points to value list
 23978 0000195C 268A04                  	mov	al,[es:si]		;AN000; get nval
 23979 0000195F 3C00                    	cmp	al,_$P_nval_None 	;AN000; no value list ?
 23980 00001961 7506                    	jne	short _$P_Value02	;AN000;
 23981                                  
 23982 00001963 B001                    	mov	al,_$P_Number		;AN000; Set type
 23983 00001965 B4FF                    	mov	ah,_$P_No_Tag		;AN000; No ITEM_TAG set
 23984 00001967 EB73                    	jmp	short _$P_Value_Exit	;AN000;
 23985                                  
 23986                                  	; 26/10/2022 (MSDOS 5.0 IO.SYS, SYSINIT compatibility)
 23987                                  	; (SYSINIT:1BA5h)
 23988                                  	; 12/12/2022
 23989                                  	;nop	; db  90h
 23990                                  
 23991                                  _$P_Value02:				;AN000; / nval = 1
 23992                                  ;IF	Val1SW				;AN000;(Check if value list id #1 is supported)
 23993                                  ;(tm07) cmp	al,_$P_nval_Range	;AN000; have range list ?
 23994                                  ;(tm07) jne	short _$P_Value03	;AN000;
 23995                                  
 23996 00001969 46                      	inc	si			;AN000;
 23997 0000196A 268A04                  	mov	al,[es:si]		;AN000; al = number of range
 23998 0000196D 3C00                    	cmp	al,_$P_No_nrng		;AN000; (tm07)
 23999 0000196F 7460                    	je	short _$P_Value03	;AN000; (tm07)
 24000                                  
 24001 00001971 46                      	inc	si			;AN000; si points to 1st item_tag
 24002                                  _$P_Val02_Loop:				;AN000;
 24003 00001972 2EF606[4114]80          	test	byte [cs:_$P_Flags2],_$P_Signed ;AC034;
 24004 00001978 751E                    	jnz	short _$P_Val02_Sign	;AN000;
 24005                                  
 24006 0000197A 263B4C03                	cmp	cx,[es:si+_$P_Val_List.Val_XH] ;AN000; comp cx with XH
 24007 0000197E 7236                    	jb	short _$P_Val02_Next	;AN000;
 24008 00001980 7706                    	ja	short _$P_Val_In	;AN000;
 24009                                  
 24010 00001982 263B5401                	cmp	dx,[es:si+_$P_Val_List.Val_XL] ;AN000; comp dx with XL
 24011 00001986 722E                    	jb	short _$P_Val02_Next	;AN000;
 24012                                  
 24013                                  _$P_Val_In:				;AN000;
 24014 00001988 263B4C07                	cmp	cx,[es:si+_$P_Val_List.Val_YH] ;AN000; comp cx with YH (tm01)
 24015 0000198C 7728                    	ja	short _$P_Val02_Next	;AN000;
 24016 0000198E 723A                    	jb	short _$P_Val_Found	;AN000;
 24017                                  
 24018 00001990 263B5405                	cmp	dx,[es:si+_$P_Val_List.Val_YL] ;AN000; comp dx with YL
 24019 00001994 7720                    	ja	short _$P_Val02_Next	;AN000;
 24020                                  
 24021 00001996 EB32                    	jmp	short _$P_Val_Found	;AN000;
 24022                                  
 24023                                  _$P_Val02_Sign:				;AN000;
 24024 00001998 263B4C03                	cmp	cx,[es:si+_$P_Val_List.Val_XH]	;AN000; comp cx with XH
 24025 0000199C 7C18                    	jl	short _$P_Val02_Next	;AN000;
 24026 0000199E 7F06                    	jg	short _$P_SVal_In	;AN000;
 24027                                  
 24028 000019A0 263B5401                	cmp	dx,[es:si+_$P_Val_List.Val_XL]	;AN000; comp dx with XL
 24029 000019A4 7C10                    	jl	short _$P_Val02_Next	;AN000;
 24030                                  
 24031                                  _$P_SVal_In:				;AN000;
 24032 000019A6 263B4C07                	cmp	cx,[es:si+_$P_Val_List.Val_YH]	;AN000; comp cx with YH
 24033 000019AA 7F0A                    	jg	short _$P_Val02_Next	;AN000;
 24034                                  
 24035 000019AC 7C1C                    	jl	short _$P_Val_Found	;AN000;
 24036                                  
 24037 000019AE 263B5405                	cmp	dx,[es:si+_$P_Val_List.Val_YL]	;AN000; comp dx with YL
 24038 000019B2 7F02                    	jg	short _$P_Val02_Next	;AN000;
 24039                                  
 24040 000019B4 EB14                    	jmp	short _$P_Val_Found	;AN000;
 24041                                  
 24042                                  _$P_Val02_Next:				;AN000;
 24043 000019B6 83C609                  	add	si,_$P_Len_Range 	;AN000;
 24044 000019B9 FEC8                    	dec	al			;AN000; loop nrng times in AL
 24045 000019BB 75B5                    	jne	short _$P_Val02_Loop	;AN000;
 24046                                  					; / Not found
 24047 000019BD 2EC706[3514]0600        	mov	word [cs:_$P_RC],_$P_Out_Of_Range ;AC034;
 24048 000019C4 B001                    	mov	al,_$P_Number		;AN000;
 24049 000019C6 B4FF                    	mov	ah,_$P_No_Tag		;AN000; No ITEM_TAG set
 24050 000019C8 EB12                    	jmp	short _$P_Value_Exit	;AN000;
 24051                                  
 24052                                  _$P_Val_Found:				;AN000;
 24053 000019CA B001                    	mov	al,_$P_Number		;AN000;
 24054 000019CC 268A24                  	mov	ah,[es:si]		;AN000; found ITEM_TAG set
 24055 000019CF EB0B                    	jmp	short _$P_Value_Exit	;AN000;
 24056                                  
 24057                                  _$P_Value03:				;AN000; / nval = 2
 24058                                  
 24059                                  ;IF	Val2SW				;AN000;(Check if value list id #2 is supported)
 24060                                  ;;;;	cmp	al,$P_nval_Value	; have match list ? ASSUME nval=2,
 24061                                  ;;;;	jne	$P_Value04		; even if it is 3 or more.
 24062                                  ;(tm07) inc	si			;AN000;
 24063                                  ;(tm07) mov	al,es:[si]		;AN000; al = nrng
 24064                                  ;	mov	ah,$P_Len_Range 	;AN000;
 24065                                  ;	mul	ah			;AN000;  Skip nrng field
 24066                                  ;	inc	ax			;AN000;
 24067                                  ;	add	si,ax			;AN000; si points to nnval
 24068                                  ;	mov	al,es:[si]		;AN000; get nnval
 24069                                  ;	inc	si			;AN000; si points to 1st item_tag
 24070                                  ;$P_Val03_Loop:				;AN000;
 24071                                  ;	cmp	cx,es:[si+$P_Val_XH]	;AN000; comp cx with XH
 24072                                  ;	jne	$P_Val03_Next		;AN000;
 24073                                  ;
 24074                                  ;	cmp	dx,es:[si+$P_Val_XL]	;AN000; comp dx with XL
 24075                                  ;	je	$P_Val_Found		;AN000;
 24076                                  ;
 24077                                  ;$P_Val03_Next:				;AN000;
 24078                                  ;	add	si,$P_Len_Value 	;AN000; points to next value choice
 24079                                  ;	dec	al			;AN000; loop nval times in AL
 24080                                  ;	jne	$P_Val03_Loop		;AN000;
 24081                                  ;					;AN000; / Not found
 24082                                  ;	mov	psdata_seg:$P_RC,$P_Not_in_Val ;AC034;
 24083                                  ;	mov	al,$P_Number		;AN000;
 24084                                  ;	mov	ah,$P_No_Tag		;AN000; No ITEM_TAG set
 24085                                  ;	jmp	short $P_Value_Exit	;AN000;
 24086                                  ;
 24087                                  ;ENDIF					;AN000;(of Val2SW)
 24088                                  ;$P_Value04:
 24089                                  
 24090                                  _$P_Value_Err:				;AN000;
 24091 000019D1 2EC706[3514]0900        	mov	word [cs:_$P_RC],_$P_Syntax ;AC034;
 24092 000019D8 B003                    	mov	al,_$P_String		;AN000; Set type
 24093 000019DA B4FF                    	mov	ah,_$P_No_Tag		;AN000; No ITEM_TAG set
 24094                                  _$P_Value_Exit:				;AN000;
 24095 000019DC E838FD                  	call	_$P_Fill_Result		;AN000;
 24096 000019DF 5E                      	pop	si			;AN000;
 24097 000019E0 5A                      	pop	dx			;AN000;
 24098 000019E1 59                      	pop	cx			;AN000;
 24099 000019E2 58                      	pop	ax			;AN000;
 24100 000019E3 C3                      	retn				;AN000;
 24101                                  
 24102                                  ; 28/03/2019 - Retro DOS v4.0
 24103                                  
 24104                                  ;***********************************************************************
 24105                                  ; _$P_Check_OVF
 24106                                  ;
 24107                                  ; Function:  Check if overflow is occurred with consideration of
 24108                                  ;	     signed or un-signed numeric value
 24109                                  ;
 24110                                  ; Input:     Flag register
 24111                                  ;
 24112                                  ; Output:    CY = 1  :	Overflow
 24113                                  ;
 24114                                  ; Vars:     _$P_Flags(R)
 24115                                  ;***********************************************************************
 24116                                  
 24117                                  	; 26/10/2022
 24118                                  _$P_Check_OVF:
 24119 000019E4 9C                      	pushf				;AN000;
 24120 000019E5 2EF606[4114]02          	test	byte [cs:_$P_Flags2],_$P_Neg ;AC034; is it negative value ?
 24121 000019EB 7502                    	jnz	short _$P_COVF 		;AN000; if no, check overflow
 24122                                  
 24123 000019ED 9D                      	popf				;AN000; by the CY bit
 24124 000019EE C3                      	retn				;AN000;
 24125                                  
 24126                                  _$P_COVF:				;AN000;
 24127 000019EF 9D                      	popf				;AN000; else,
 24128 000019F0 7002                    	jo	short _$P_COVF00	;AN000; check overflow by the OF
 24129                                  
 24130 000019F2 F8                      	clc				;AN000; indicate it with CY bit
 24131 000019F3 C3                      	retn				;AN000; CY=0 means no overflow
 24132                                  
 24133                                  _$P_COVF00:				;AN000;
 24134 000019F4 F9                      	stc				;AN000; and CY=1 means overflow
 24135 000019F5 C3                      	retn				;AN000;
 24136                                  
 24137                                  ;***********************************************************************
 24138                                  ; _$P_0099;
 24139                                  ;
 24140                                  ; Function:  Make ASCII 0-9 to Binary 0-9
 24141                                  ;
 24142                                  ; Input:     AL = character code
 24143                                  ;
 24144                                  ; Output:    CY = 1 : AL is not number
 24145                                  ;	     CY = 0 : AL contains binary value
 24146                                  ;***********************************************************************
 24147                                  
 24148                                  _$P_0099:
 24149 000019F6 3C30                    	cmp	al,"0"                  ;AN000;
 24150                                  	;jb	short _$P_0099Err	;AN000; must be 0 =< al =< 9
 24151                                  	; 12/12/2022
 24152 000019F8 7208                    	jb	short _$P_0099Err2  ; cf=1
 24153                                  
 24154 000019FA 3C39                    	cmp	al,"9"                  ;AN000;
 24155 000019FC 7703                    	ja	short _$P_0099Err	;AN000; must be 0 =< al =< 9
 24156                                  
 24157 000019FE 2C30                    	sub	al,"0"                  ;AN000; make char -> bin
 24158                                  	; 12/12/2022
 24159                                  	; cf=0	
 24160                                  	;clc				;AN000; indicate no error
 24161 00001A00 C3                      	retn				;AN000;
 24162                                  
 24163                                  _$P_0099Err:				;AN000;
 24164 00001A01 F9                      	stc				;AN000; indicate error
 24165                                  _$P_0099Err2: ; 12/12/2022	
 24166 00001A02 C3                      	retn				;AN000;
 24167                                  
 24168                                  ;***********************************************************************
 24169                                  ; _$P_Simple_String
 24170                                  ;
 24171                                  ; Function:  See value list for the simple string
 24172                                  ;	     and make result buffer.
 24173                                  ;
 24174                                  ; Input:     cs:SI -> _$P_STRING_BUF
 24175                                  ;	     ES:BX -> CONTROL block
 24176                                  ;
 24177                                  ; Output:    None
 24178                                  ;
 24179                                  ; Use:	_$P_Fill_Result, _$P_String_Comp
 24180                                  ;
 24181                                  ; Vars: _$P_RC(W)
 24182                                  ;***********************************************************************
 24183                                  
 24184                                  _$P_Simple_String:
 24185 00001A03 50                      	push	ax			;AN000;
 24186 00001A04 53                      	push	bx			;AN000;
 24187 00001A05 52                      	push	dx			;AN000;
 24188 00001A06 57                      	push	di			;AN000;
 24189 00001A07 268B7F06                	mov	di,[es:bx+_$P_Control_Blk.Value_List] ;AN000; di points to value list
 24190 00001A0B 268A05                  	mov	al,[es:di]		;AN000; get nval
 24191 00001A0E 08C0                    	or	al,al			;AN000; no value list ?
 24192 00001A10 7504                    	jnz	short _$P_Sim00		;AN000; then
 24193                                  
 24194 00001A12 B4FF                    	mov	ah,_$P_No_Tag		;AN000; No ITEM_TAG set
 24195 00001A14 EB4C                    	jmp	short _$P_Sim_Exit	;AN000; and set result buffer
 24196                                  
 24197                                  _$P_Sim00:				;AN000;
 24198                                  ;IF	Val3SW+KeySW			;AN000;(Check if keyword or value list id #3 is supported)
 24199 00001A16 3C03                    	cmp	al,_$P_nval_String	;AN000; String choice list provided ?
 24200 00001A18 753F                    	jne	short _$P_Sim01		;AN000; if no, syntax error
 24201                                  
 24202 00001A1A 47                      	inc	di			;AN000;
 24203 00001A1B 268A05                  	mov	al,[es:di]		;AN000; al = nrng
 24204 00001A1E B409                    	mov	ah,_$P_Len_Range 	;AN000;
 24205 00001A20 F6E4                    	mul	ah			;AN000; Skip nrng field
 24206 00001A22 40                      	inc	ax			;AN000; ax = (nrng*9)+1
 24207 00001A23 01C7                    	add	di,ax			;AN000; di points to nnval
 24208 00001A25 268A05                  	mov	al,[es:di]		;AN000; get nnval
 24209 00001A28 B405                    	mov	ah,_$P_Len_Value 	;AN000;
 24210 00001A2A F6E4                    	mul	ah			;AN000; Skip nnval field
 24211 00001A2C 40                      	inc	ax			;AN000; ax = (nnval*5)+1
 24212 00001A2D 01C7                    	add	di,ax			;AN000; di points to nstrval
 24213 00001A2F 268A05                  	mov	al,[es:di]		;AN000; get nstrval c
 24214 00001A32 47                      	inc	di			;AC035; add '2' to
 24215 00001A33 47                      	inc	di			;AC035;  DI reg
 24216                                  					;AN000; di points to 1st string in list
 24217                                  _$P_Sim_Loop:				;AN000;
 24218 00001A34 268B2D                  	mov	bp,[es:di]		;AN000; get string pointer
 24219 00001A37 E83200                  	call	_$P_String_Comp		;AN000; compare it with operand
 24220 00001A3A 7312                    	jnc	short _$P_Sim_Found	;AN000; found on list ?
 24221                                  
 24222 00001A3C 83C703                  	add	di,_$P_Len_String ; 3	;AN000; if no, point to next choice
 24223 00001A3F FEC8                    	dec	al			;AN000; loop nstval times in AL
 24224 00001A41 75F1                    	jne	short _$P_Sim_Loop	;AN000;
 24225                                  					;AN000; / Not found
 24226 00001A43 2EC706[3514]0800        	mov	word [cs:_$P_RC],_$P_Not_In_Str ;AC034;
 24227 00001A4A B4FF                    	mov	ah,_$P_No_Tag		;AN000; No ITEM_TAG set
 24228 00001A4C EB14                    	jmp	short _$P_Sim_Exit	;AN000;
 24229                                  
 24230                                  _$P_Sim_Found:				;AN000;
 24231 00001A4E 268A65FF                	mov	ah,[es:di-1]		;AN000; set item_tag
 24232 00001A52 B002                    	mov	al,_$P_List_Idx		;AN000;
 24233 00001A54 268B15                  	mov	dx,[es:di]		;AN000; get address of STRING
 24234 00001A57 EB0B                    	jmp	short _$P_Sim_Exit0	;AN000;
 24235                                  ;ENDIF					;AN000;(of Val3SW+KeySW)
 24236                                  _$P_Sim01:				;AN000;
 24237 00001A59 2EC706[3514]0900        	mov	word [cs:_$P_RC],_$P_Syntax ;AC034;
 24238 00001A60 B4FF                    	mov	ah,_$P_No_Tag		;AN000; No ITEM_TAG set
 24239                                  _$P_Sim_Exit:				;AN000;
 24240 00001A62 B003                    	mov	al,_$P_String		;AN000; Set type
 24241                                  _$P_Sim_Exit0:				;AN000;
 24242 00001A64 E8B0FC                  	call	_$P_Fill_Result		;AN000;
 24243 00001A67 5F                      	pop	di			;AN000;
 24244 00001A68 5A                      	pop	dx			;AN000;
 24245 00001A69 5B                      	pop	bx			;AN000;
 24246 00001A6A 58                      	pop	ax			;AN000;
 24247 00001A6B C3                      	retn				;AN000;
 24248                                  
 24249                                  ;***********************************************************************
 24250                                  ; _$P_String_Comp:
 24251                                  ;
 24252                                  ; Function:  Compare two string
 24253                                  ;
 24254                                  ; Input:     cs:SI -> 1st string
 24255                                  ;	     ES:BP -> 2nd string  (Must be upper case)
 24256                                  ;	     ES:BX -> CONTROL block
 24257                                  ;
 24258                                  ; Output:    CY = 1 if not match
 24259                                  ;
 24260                                  ; Use:	_$P_Chk_DBCS, _$P_Do_CAPS_Char
 24261                                  ;
 24262                                  ; Vars: _$P_KEYor_SW_Ptr(W), _$P_Flags(R). _$P_KEYorSW_Ptr
 24263                                  ;***********************************************************************
 24264                                  
 24265                                  _$P_String_Comp:
 24266 00001A6C 50                      	push	ax			;AN000;
 24267 00001A6D 55                      	push	bp			;AN000;
 24268 00001A6E 52                      	push	dx			;AN000;
 24269 00001A6F 56                      	push	si			;AN000;
 24270 00001A70 B202                    	mov	dl,_$P_DOSTBL_Char	;AN000; use character case map table
 24271                                  _$P_SCOM_Loop:				;AN000;
 24272 00001A72 2E8A04                  	mov	al,[cs:si]		;AN000; get command character
 24273 00001A75 E82E02                  	call	_$P_Chk_DBCS		;AN000; DBCS ?
 24274 00001A78 723A                    	jc	short _$P_SCOM00	;AN000; yes,DBCS
 24275                                  
 24276 00001A7A E811FE                  	call	_$P_Do_CAPS_Char 	;AN000; else, upper case map before comparison
 24277                                  ;IF KeySW+SwSW				;AN000;(Check if keyword or switch is supported)
 24278 00001A7D 2EF606[4114]08          	test	byte [cs:_$P_Flags2],_$P_Key_Cmp ;AC034; keyword search ?
 24279 00001A83 740D                    	jz	short _$P_SCOM04	;AN000;
 24280                                  
 24281 00001A85 3C3D                    	cmp	al,_$P_Keyword		;AN000; "=" is delimiter
 24282 00001A87 751F                    	jne	short _$P_SCOM03	;AN000; IF "=" on command line AND  (bp+1=> char after the "=" in synonym list)
 24283                                  
 24284 00001A89 26807E0100              	cmp	byte [es:bp+1],_$P_NULL ;AN021;  at end of keyword string in the control block THEN
 24285 00001A8E 756D                    	jne	short _$P_SCOM_Differ	;AN021;
 24286                                  
 24287 00001A90 EB13                    	jmp	short _$P_SCOM05 	;AN000; keyword found in synonym list
 24288                                  
 24289                                  _$P_SCOM04:				;AN000;
 24290 00001A92 2EF606[4114]10          	test	byte [cs:_$P_Flags2],_$P_SW_Cmp ;AC034; switch search ?
 24291 00001A98 740E                    	jz	short _$P_SCOM03	;AN000;
 24292                                  
 24293 00001A9A 3C3A                    	cmp	al,_$P_Colon		;AN000; ":" is delimiter, at end of switch on command line
 24294 00001A9C 750A                    	jne	short _$P_SCOM03	;AN000; continue compares
 24295                                  
 24296                                  	; 26/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 24297                                  	;cmp	byte [es:bp+0],_$P_NULL
 24298                                  	; 11/12/2022
 24299 00001A9E 26807E0000              	cmp	byte [es:bp],_$P_NULL	;AN021; IF at end of switch on command AND
 24300 00001AA3 7558                    	jne	short _$P_SCOM_Differ	;AN021;   at end of switch string in the control block THEN
 24301                                  
 24302                                  _$P_SCOM05:				;AN000;   found a match
 24303 00001AA5 46                      	inc	si			;AN000; si points to just after "=" or ":"
 24304 00001AA6 EB58                    	jmp	short _$P_SCOM_Same	;AN000; exit
 24305                                  
 24306                                  _$P_SCOM03:				;AN000;
 24307                                  ;ENDIF					;AN000;(of KeySW+SwSW)
 24308                                  	; 26/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 24309                                  	;cmp	al,[es:bp+0]
 24310                                  	; 11/12/2022
 24311 00001AA8 263A4600                	cmp	al,[es:bp]		;AN000; compare operand w/ a synonym
 24312 00001AAC 751B                    	jne	short _$P_SCOM_Differ0 	;AN000; if different, check ignore colon option
 24313                                  
 24314 00001AAE 08C0                    	or	al,al			;AN000; end of line
 24315 00001AB0 744E                    	jz	short _$P_SCOM_Same	;AN000; if so, exit
 24316                                  
 24317                                  	; 12/12/2022
 24318                                  	;inc	si			;AN000; update operand pointer
 24319                                  	;inc	bp			;AN000;    and synonym pointer
 24320                                  	; 26/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 24321 00001AB2 EB11                    	jmp	short _$P_SCOM01 	;AN000; loop until NULL or "=" or ":" found in case
 24322                                  
 24323                                  _$P_SCOM00:				;AN000; Here al is DBCS leading byte
 24324                                  	; 26/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 24325                                  	;cmp	al,[es:bp+0]
 24326                                  	; 11/12/2022
 24327 00001AB4 263A4600                	cmp	al,[es:bp]		;AN000; compare leading byte
 24328 00001AB8 7543                    	jne	short _$P_SCOM_Differ	;AN000; if not match, say different
 24329                                  
 24330 00001ABA 46                      	inc	si			;AN000; else, load next byte
 24331 00001ABB 2E8A04                  	mov	al,[cs:si]		;AN000; and
 24332 00001ABE 45                      	inc	bp			;AN000;
 24333                                  	; 26/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 24334                                  	;cmp	al,[es:bp+0]
 24335                                  	; 11/12/2022
 24336 00001ABF 263A4600                	cmp	al,[es:bp]		;AN000; compare 2nd byte
 24337 00001AC3 7538                    	jne	short _$P_SCOM_Differ	;AN000; if not match, say different, too
 24338                                  
 24339                                  	; 26/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 24340                                  	; 12/12/2022
 24341                                  _$P_SCOM01:
 24342 00001AC5 46                      	inc	si			;AN000; else update operand pointer
 24343 00001AC6 45                      	inc	bp			;AN000; 		and synonym pointer
 24344                                  ;_$P_SCOM01:				;AN000;
 24345 00001AC7 EBA9                    	jmp	short _$P_SCOM_Loop	;AN000; loop until NULL or "=" or "/" found in case
 24346                                  
 24347                                  _$P_SCOM_Differ0:			;AN000;
 24348                                  ;IF SwSW				;AN000;(tm10)
 24349 00001AC9 2EF606[4114]40          	test	byte [cs:_$P_Flags2],_$P_SW ;AC034;(tm10)
 24350 00001ACF 740E                    	jz	short _$P_not_applicable ;AN000;(tm10)
 24351                                  
 24352                                  	; 26/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 24353                                  	;test	word [es:bx+_$P_Control_Blk.Function_Flag],_$P_colon_is_not_necessary ;AN000;(tm10)
 24354                                  	; 12/12/2022
 24355 00001AD1 26F6470220              	test	byte [es:bx+_$P_Control_Blk.Function_Flag],_$P_colon_is_not_necessary
 24356 00001AD6 7407                    	je	short _$P_not_applicable ;AN000;(tm10)
 24357                                  
 24358                                  	; 26/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)	
 24359                                  	;cmp	byte [es:bp+0],_$P_NULL
 24360                                  	; 11/12/2022
 24361 00001AD8 26807E0000              	cmp	byte [es:bp],_$P_NULL	;AN000;(tm10)
 24362                                  ;(deleted ;AN025;) jne short _$P_not_applicable ;AN000;(tm10)
 24363 00001ADD 7421                    	je	short _$P_SCOM_Same	;AN025;(tm10)
 24364                                  
 24365                                  _$P_not_applicable:			;AN000;(tm10)
 24366                                  ;ENDIF					;AN000;(tm10)
 24367                                  
 24368                                  	;test	word [es:bx+_$P_Control_Blk.Match_Flag],_$P_Ig_Colon 
 24369                                  					;AN000; ignore colon option specified ?
 24370                                  	;test	byte [es:bx+_$P_Control_Blk.Match_Flag],_$P_Ig_Colon
 24371                                  	; 12/12/2022
 24372 00001ADF 26F60710                	test	byte [es:bx],_$P_Ig_Colon
 24373                                  	; 26/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)	
 24374                                  	;test	word [es:bx],_$P_Ig_Colon ; 10h
 24375 00001AE3 7418                    	jz	short _$P_SCOM_Differ	;AN000; if no, say different.
 24376                                  
 24377 00001AE5 3C3A                    	cmp	al,_$P_Colon		;AN000; End up with ":" and
 24378 00001AE7 7509                    	jne	short _$P_SCOM02	;AN000;    subseqently
 24379                                  
 24380                                  	; 26/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)	
 24381                                  	;cmp	byte [es:bp+0],_$P_NULL
 24382                                  	; 11/12/2022
 24383 00001AE9 26807E0000              	cmp	byte [es:bp],_$P_NULL	;AN000; NULL ?
 24384 00001AEE 750D                    	jne	short _$P_SCOM_Differ	;AN000; if no, say different
 24385                                  
 24386 00001AF0 EB0E                    	jmp	short _$P_SCOM_Same	;AN000; else, say same
 24387                                  
 24388                                  _$P_SCOM02:				;AN000;
 24389 00001AF2 3C00                    	cmp	al,_$P_NULL		;AN000; end up NULL and :
 24390 00001AF4 7507                    	jne	short _$P_SCOM_Differ	;AN000;
 24391                                  
 24392                                  	; 26/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)	
 24393                                  	;cmp	byte [es:bp+0],_$P_Colon
 24394                                  	; 11/12/2022
 24395 00001AF6 26807E003A              	cmp	byte [es:bp],_$P_Colon	;AN000; if no, say different
 24396 00001AFB 7403                    	je	short _$P_SCOM_Same	;AN000; else, say same
 24397                                  
 24398                                  _$P_SCOM_Differ: 			;AN000;
 24399 00001AFD F9                      	stc				;AN000; indicate not found
 24400 00001AFE EB05                    	jmp	short _$P_SCOM_Exit	;AN000;
 24401                                  
 24402                                  _$P_SCOM_Same:				;AN000;
 24403                                  	; 12/12/2022
 24404                                  	; cf=0
 24405 00001B00 2E8936[4414]            	mov	[cs:_$P_KEYorSW_Ptr],si ;AC034; for later use by keyword or switch
 24406                                  	; 12/12/2022
 24407                                  	;clc				;AN000; indicate found
 24408                                  _$P_SCOM_Exit:				;AN000;
 24409 00001B05 5E                      	pop	si			;AN000;
 24410 00001B06 5A                      	pop	dx			;AN000;
 24411 00001B07 5D                      	pop	bp			;AN000;
 24412 00001B08 58                      	pop	ax			;AN000;
 24413 00001B09 C3                      	retn
 24414                                  
 24415                                  ; 30/03/2019
 24416                                  
 24417                                  ;IF FileSW+DrvSW			;AN000;(Check if file spec or drive only is supported)
 24418                                  
 24419                                  ;***********************************************************************
 24420                                  ; _$P_File_Format;
 24421                                  ;
 24422                                  ; Function:  Check if the input string is valid file spec format.
 24423                                  ;	     And set the result buffer.
 24424                                  ;
 24425                                  ; Input:     cs:SI -> _$P_STRING_BUF
 24426                                  ;	     ES:BX -> CONTROL block
 24427                                  ;
 24428                                  ; Output:    None
 24429                                  ;
 24430                                  ; Use:	_$P_Fill_Result, _$P_Chk_DBCS, _$P_FileSp_Chk
 24431                                  ;
 24432                                  ; Vars: _$P_RC(W), _$P_SI_Save(W), _$P_Terminator(W), _$P_SaveSI_Cmpx(R)
 24433                                  ;	_$P_SaveSI_Cmpx(R)
 24434                                  ;***********************************************************************
 24435                                  
 24436                                  _$P_File_Format:
 24437 00001B0A 50                      	push	ax			;AN000;
 24438 00001B0B 57                      	push	di			;AN000;
 24439 00001B0C 56                      	push	si			;AN000;
 24440 00001B0D 2E8B3E[4214]            	mov	di,[cs:_$P_SaveSI_Cmpx]	;AC034; get user buffer address
 24441                                  _$P_FileF_Loop0: 			;AN000; / skip special characters
 24442 00001B12 2E8A04                  	mov	al,[cs:si]		;AN000; load character
 24443 00001B15 08C0                    	or	al,al			;AN000; end of line ?
 24444 00001B17 7413                    	jz	short _$P_FileF_Err	;AN000; if yes, error exit
 24445                                  
 24446 00001B19 E85E00                  	call	_$P_FileSp_Chk		;AN000; else, check if file special character
 24447 00001B1C 7523                    	jne	short _$P_FileF03	;AN000; if yes,
 24448                                  
 24449 00001B1E 2EC606[D814]01          	mov	byte [cs:_$P_err_flag],_$P_error_filespec 
 24450                                  					;AN033;AC034;; set error flag- bad char.
 24451 00001B24 5E                      	pop	si			;AN033;
 24452 00001B25 2EC60400                	mov	byte [cs:si],_$P_NULL	;AN033;
 24453 00001B29 5F                      	pop	di			;AN033;
 24454 00001B2A EB3E                    	jmp	short _$P_FileF02	;AN033;
 24455                                  
 24456                                  _$P_FileF_Err:				;AN000;
 24457 00001B2C 5E                      	pop	si			;AN000;
 24458 00001B2D 2EC60400                	mov	byte [cs:si],_$P_NULL	;AN000;
 24459 00001B31 5F                      	pop	di			;AN000;
 24460                                  
 24461                                  	;test	word [es:bx+_$P_Control_Blk.Match_Flag],_$P_Optional ;AN000; is it optional ?
 24462                                  	;test	byte [es:bx+_$P_Control_Blk.Match_Flag],_$P_Optional
 24463                                  	; 12/12/2022
 24464 00001B32 26F60701                	test	byte [es:bx],_$P_Optional
 24465                                  	; 26/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)	
 24466                                  	;test	word [es:bx],_$P_Optional
 24467 00001B36 7532                    	jnz	short _$P_FileF02	;AN000;
 24468                                  
 24469 00001B38 2EC706[3514]0200        	mov	word [cs:_$P_RC],_$P_Op_Missing ;AC034; 3/17/87
 24470 00001B3F EB29                    	jmp	short _$P_FileF02	;AN000;
 24471                                  
 24472                                  _$P_FileF03:				;AN000;
 24473 00001B41 58                      	pop	ax			;AN000; discard save si
 24474 00001B42 56                      	push	si			;AN000; save new si
 24475                                  _$P_FileF_Loop1: 			;AN000;
 24476 00001B43 2E8A04                  	mov	al,[cs:si]		;AN000; load character (not special char)
 24477 00001B46 08C0                    	or	al,al			;AN000; end of line ?
 24478 00001B48 741E                    	jz	short _$P_FileF_RLT	;AN000;
 24479                                  
 24480 00001B4A E82D00                  	call	_$P_FileSp_Chk		;AN000; File special character ?
 24481 00001B4D 740B                    	je	short _$P_FileF00	;AN000;
 24482                                  
 24483 00001B4F E85401                  	call	_$P_Chk_DBCS		;AN000; no, then DBCS ?
 24484 00001B52 7302                    	jnc	short _$P_FileF01	;AN000;
 24485 00001B54 47                      	inc	di			;AN000; if yes, skip next byte
 24486 00001B55 46                      	inc	si			;AN000;
 24487                                  _$P_FileF01:				;AN000;
 24488 00001B56 47                      	inc	di			;AN000;
 24489 00001B57 46                      	inc	si			;AN000;
 24490 00001B58 EBE9                    	jmp	short _$P_FileF_Loop1	;AN000;
 24491                                  ;
 24492                                  _$P_FileF00:				;AN000;
 24493 00001B5A 2EA2[3B14]              	mov	[cs:_$P_Terminator],al	;AC034;
 24494 00001B5E 2EC60400                	mov	byte [cs:si],_$P_NULL	;AN000; update end of string
 24495 00001B62 47                      	inc	di			;AN000;
 24496 00001B63 2E893E[3714]            	mov	[cs:_$P_SI_Save],di	;AC034; update next pointer in command line
 24497                                  _$P_FileF_RLT:				;AN000;
 24498 00001B68 5E                      	pop	si			;AN000;
 24499 00001B69 5F                      	pop	di			;AN000;
 24500                                  _$P_FileF02:				;AN000;
 24501 00001B6A 58                      	pop	ax			;AN000; (tm14)
 24502 00001B6B A90002                  	test	ax,_$P_File_Spc		;AN000; (tm14)
 24503 00001B6E 7409                    	jz	short _$P_Drv_Only_Exit	;AN000; (tm14)
 24504                                  
 24505 00001B70 50                      	push	ax			;AN000;  (tm14)
 24506                                  
 24507 00001B71 B4FF                    	mov	ah,_$P_No_Tag		;AN000; set
 24508 00001B73 B005                    	mov	al,_$P_File_Spec 	;AN000;    result
 24509 00001B75 E89FFB                  	call	_$P_Fill_Result		;AN000; 	 buffer to file spec
 24510 00001B78 58                      	pop	ax			;AN000;
 24511                                  
 24512                                  _$P_Drv_Only_Exit:			;AN000; (tm14)
 24513 00001B79 C3                      	retn				;AN000;
 24514                                  
 24515                                  ;***********************************************************************
 24516                                  ; _$P_FileSp_Chk
 24517                                  ;
 24518                                  ; Function:  Check if the input byte is one of file special characters
 24519                                  ;
 24520                                  ; Input:     cs:SI -> _$P_STRING_BUF
 24521                                  ;	     AL = character code to be examineed
 24522                                  ;
 24523                                  ; Output:    ZF = 1 , AL is one of special characters
 24524                                  ;***********************************************************************
 24525                                  
 24526                                  _$P_FileSp_Chk:
 24527 00001B7A 53                      	push	bx			;AN000;
 24528 00001B7B 51                      	push	cx			;AN000;
 24529                                  	;lea	bx,[cs:_$P_FileSp_Char] ;AC034; special character table
 24530 00001B7C 8D1E[CF14]              	lea	bx,[_$P_FileSp_Char]
 24531 00001B80 B90900                  	mov	cx,_$P_FileSp_Len	;AN000; load length of it
 24532                                  _$P_FileSp_Loop: 			;AN000;
 24533 00001B83 2E3A07                  	cmp	al,[cs:bx]		;AN000; is it one of special character ?
 24534 00001B86 7404                    	je	short _$P_FileSp_Exit	;AN000;
 24535                                  
 24536 00001B88 43                      	inc	bx			;AN000;
 24537 00001B89 E2F8                    	loop	_$P_FileSp_Loop		;AN000;
 24538                                  
 24539 00001B8B 41                      	inc	cx			;AN000; reset ZF
 24540                                  _$P_FileSp_Exit: 			;AN000;
 24541 00001B8C 59                      	pop	cx			;AN000;
 24542 00001B8D 5B                      	pop	bx			;AN000;
 24543 00001B8E C3                      	retn
 24544                                  
 24545                                  ;ENDIF					;AN000;(of FileSW+DrvSW)
 24546                                  
 24547                                  ;IF	DrvSW				;AN000;(Check if drive only is supported)
 24548                                  
 24549                                  ;***********************************************************************
 24550                                  ; _$P_Drive_Format;
 24551                                  ;
 24552                                  ; Function:  Check if the input string is valid drive only format.
 24553                                  ;	     And set the result buffer.
 24554                                  ;
 24555                                  ; Input:     cs:SI -> _$P_STRING_BUF
 24556                                  ;	     ES:BX -> CONTROL block
 24557                                  ;
 24558                                  ; Output:    None
 24559                                  ;
 24560                                  ; Use:	_$P_Fill_Result, _$P_Chk_DBCS
 24561                                  ;
 24562                                  ; Vars: _$P_RC(W)
 24563                                  ;***********************************************************************
 24564                                  
 24565                                  _$P_Drive_Format:
 24566 00001B8F 50                      	push	ax			;AN000;
 24567 00001B90 52                      	push	dx			;AN000;
 24568 00001B91 2E8A04                  	mov	al,[cs:si]		;AN000;
 24569 00001B94 08C0                    	or	al,al			;AN000; if null string
 24570 00001B96 7437                    	je	short _$P_Drv_Exit	;AN000; do nothing
 24571                                  
 24572 00001B98 E80B01                  	call	_$P_Chk_DBCS		;AN000; is it leading byte ?
 24573 00001B9B 722B                    	jc	short _$P_Drv_Err	;AN000;
 24574                                  
 24575 00001B9D 2E837C013A              	cmp	word [cs:si+1],_$P_Colon ;AN000; "d", ":", 0  ?
 24576 00001BA2 740D                    	je	short _$P_DrvF00	;AN000;
 24577                                  
 24578                                  	;test	word [es:bx+_$P_Control_Blk.Match_Flag],_$P_Ig_Colon 
 24579                                  	;test	byte [es:bx+_$P_Control_Blk.Match_Flag],_$P_Ig_Colon ;AN000; colon can be ignored?
 24580                                  	; 12/12/2022
 24581 00001BA4 26F60710                	test	byte [es:bx],_$P_Ig_Colon
 24582                                  	; 26/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)	
 24583                                  	;test	word [es:bx],_$P_Ig_Colon
 24584 00001BA8 741E                    	jz	short _$P_Drv_Err	;AN000;
 24585                                  
 24586 00001BAA 2E807C0100              	cmp	byte [cs:si+1],_$P_NULL ;AN000; "d", 0  ?
 24587 00001BAF 7517                    	jne	short _$P_Drv_Err	;AN000;
 24588                                  
 24589                                  _$P_DrvF00:				;AN000;
 24590 00001BB1 0C20                    	or	al,_$P_Make_Lower	;AN000; lower case
 24591 00001BB3 3C61                    	cmp	al,"a"                  ;AN000; drive letter must
 24592 00001BB5 7211                    	jb	short _$P_Drv_Err	;AN000; in range of
 24593                                  
 24594 00001BB7 3C7A                    	cmp	al,"z"                  ;AN000; "a" - "z"
 24595 00001BB9 770D                    	ja	short _$P_Drv_Err	;AN000; if no, error
 24596                                  
 24597 00001BBB 2C60                    	sub	al,"a"-1                ;AN000; make text drive to binary drive
 24598 00001BBD 88C2                    	mov	dl,al			;AN000; set
 24599 00001BBF B4FF                    	mov	ah,_$P_No_Tag		;AN000;    result
 24600 00001BC1 B006                    	mov	al,_$P_Drive		;AN000; 	 buffer
 24601 00001BC3 E851FB                  	call	_$P_Fill_Result		;AN000; 	       to drive
 24602 00001BC6 EB07                    	jmp	short _$P_Drv_Exit	;AN000;
 24603                                  
 24604                                  _$P_Drv_Err:				;AN000;
 24605 00001BC8 2EC706[3514]0900        	mov	word [cs:_$P_RC],_$P_Syntax ;AC034;
 24606                                  _$P_Drv_Exit:				;AN000;
 24607 00001BCF 5A                      	pop	dx			;AN000;
 24608 00001BD0 58                      	pop	ax			;AN000;
 24609 00001BD1 C3                      	retn				;AN000;
 24610                                  
 24611                                  ;ENDIF					;AN000;(of DrvSW)
 24612                                  
 24613                                  ;***********************************************************************
 24614                                  ; _$P_Skip_Delim;
 24615                                  ;
 24616                                  ; Function: Skip delimiters specified in the PARMS list, white space
 24617                                  ;	    and comma.
 24618                                  ;
 24619                                  ; Input:    DS:SI -> Command String
 24620                                  ;	    ES:DI -> Parameter List
 24621                                  ;
 24622                                  ; Output:   CY = 1 if the end of line encounterd
 24623                                  ;	    CY = 0 then SI move to 1st non-delimiter character
 24624                                  ;	    AL = Last examineed character
 24625                                  ;
 24626                                  ; Use:	    _$P_Chk_EOL, _$P_Chk_Delim,
 24627                                  ;
 24628                                  ; Vars:     _$P_Flags(R)
 24629                                  ;***********************************************************************
 24630                                  
 24631                                  _$P_Skip_Delim:
 24632                                  _$P_Skip_Delim_Loop:			;AN000;
 24633 00001BD2 AC                      	lodsb				;AN000;
 24634 00001BD3 E81F00                  	call	_$P_Chk_EOL		;AN000; is it EOL character ?
 24635 00001BD6 7417                    	jz	short _$P_Skip_Delim_CY	;AN000; if yes, exit w/ CY on
 24636                                  
 24637 00001BD8 E85000                  	call	_$P_Chk_Delim		;AN000; is it one of delimiters ?
 24638 00001BDB 7515                    	jnz	short _$P_Skip_Delim_NCY ;AN000; if no, exit w/ CY off
 24639                                  
 24640 00001BDD 2EF606[4114]20          	test	byte [cs:_$P_Flags2],_$P_Extra ;AC034; extra delim or comma found ?
 24641 00001BE3 74ED                    	jz	short _$P_Skip_Delim_Loop ;AN000; if no, loop
 24642                                  
 24643 00001BE5 2EF606[4114]41          	test	byte [cs:_$P_Flags2],_$P_SW+_$P_equ ;AC034; /x , or xxx=zzz , (tm08)
 24644 00001BEB 7407                    	jz	short _$P_Exit_At_Extra	;AN000; no switch, no keyword (tm08)
 24645                                  
 24646                                  	;dec	si			;AN000; backup si for next call (tm08)
 24647                                  	;jmp	short _$P_Exit_At_Extra	;AN000; else exit w/ CY off
 24648                                  	; 12/12/2022
 24649                                  	; cf=0
 24650 00001BED EB04                    	jmp	short _$P_Skip_Delim_Exit
 24651                                  
 24652                                  _$P_Skip_Delim_CY:			;AN000;
 24653 00001BEF F9                      	stc				;AN000; indicate EOL
 24654 00001BF0 EB01                    	jmp	short _$P_Skip_Delim_Exit ;AN000;
 24655                                  
 24656                                  _$P_Skip_Delim_NCY:			;AN000;
 24657 00001BF2 F8                      	clc				;AN000; indicate non delim
 24658                                  _$P_Skip_Delim_Exit:			;AN000; in this case, need
 24659 00001BF3 4E                      	dec	si			;AN000;  backup index pointer
 24660                                  	; 12/12/2022
 24661                                  _$P_Exit_At_Extra:	 ; cf=0
 24662 00001BF4 C3                      	retn				;AN000;
 24663                                  
 24664                                  	; 12/12/2022
 24665                                  ;_$P_Exit_At_Extra:			;AN000;
 24666                                  	;clc				;AN000; indicate extra delim
 24667                                  	;retn				;AN000;
 24668                                  
 24669                                  ;***********************************************************************
 24670                                  ; _$P_Chk_EOL;
 24671                                  ;
 24672                                  ; Function: Check if AL is one of End of Line characters.
 24673                                  ;
 24674                                  ; Input:    AL = character code
 24675                                  ;	    ES:DI -> Parameter List
 24676                                  ;
 24677                                  ; Output:   ZF = 1 if one of End of Line characters
 24678                                  ;**********************************************************************
 24679                                  
 24680                                  _$P_Chk_EOL:
 24681 00001BF5 53                      	push	bx			;AN000;
 24682 00001BF6 51                      	push	cx			;AN000;
 24683 00001BF7 3C0D                    	cmp	al,_$P_CR		;AN000; Carriage return ?
 24684 00001BF9 742D                    	je	short _$P_Chk_EOL_Exit 	;AN000;
 24685                                  
 24686 00001BFB 3C00                    	cmp	al,_$P_NULL		;AN000; zero ?
 24687 00001BFD 7429                    	je	short _$P_Chk_EOL_Exit 	;AN000;
 24688                                  
 24689                                  ;IF LFEOLSW				;AN028; IF LF TO BE ACCEPTED AS EOL
 24690 00001BFF 3C0A                    	cmp	al,_$P_LF		;AN000; Line feed ?
 24691 00001C01 7425                    	je	short _$P_Chk_EOL_Exit 	;AN000;
 24692                                  ;ENDIF					;AN028;
 24693                                  
 24694 00001C03 26807D0202              	cmp	byte [es:di+_$P_PARMS_Blk.Num_Extra],_$P_I_Have_EOL 
 24695                                  					;AN000; EOL character specified ?
 24696 00001C08 721E                    	jb	short _$P_Chk_EOL_Exit 	;AN000;
 24697                                  
 24698 00001C0A 31DB                    	xor	bx,bx			;AN000;
 24699 00001C0C 268A5D03                	mov	bl,[es:di+_$P_PARMS_Blk.Len_Extra_Delim]
 24700                                  					;AN000; get length of delimiter list
 24701 00001C10 83C304                  	add	bx,_$P_Len_PARMS 	;AN000; skip it
 24702 00001C13 26803900                	cmp	byte [es:bx+di],_$P_I_Use_Default ;AN000; No extra EOL character ?
 24703 00001C17 740D                    	je	short _$P_Chk_EOL_NZ	;AN000;
 24704                                  
 24705                                  	;xor	cx,cx			;AN000; Get number of extra character
 24706 00001C19 30ED                    	xor	ch,ch
 24707 00001C1B 268A09                  	mov	cl,[es:bx+di]		;AN000;
 24708                                  _$P_Chk_EOL_Loop:			;AN000;
 24709 00001C1E 43                      	inc	bx			;AN000;
 24710 00001C1F 263A01                  	cmp	al,[es:bx+di]		;AN000; Check extra EOL character
 24711 00001C22 7404                    	je	short _$P_Chk_EOL_Exit 	;AN000;
 24712                                  
 24713 00001C24 E2F8                    	loop	_$P_Chk_EOL_Loop 	;AN000;
 24714                                  
 24715                                  _$P_Chk_EOL_NZ:				;AN000;
 24716 00001C26 3C0D                    	cmp	al,_$P_CR		;AN000; reset ZF
 24717                                  _$P_Chk_EOL_Exit:			;AN000;
 24718 00001C28 59                      	pop	cx			;AN000;
 24719 00001C29 5B                      	pop	bx			;AN000;
 24720 00001C2A C3                      	retn
 24721                                  
 24722                                  ;***********************************************************************
 24723                                  ; _$P_Chk_Delim;
 24724                                  ;
 24725                                  ; Function: Check if AL is one of delimiter characters.
 24726                                  ;	    if AL+[si] is DBCS blank, it is replaced with two SBCS
 24727                                  ;	    blanks.
 24728                                  ;
 24729                                  ; Input:    AL = character code
 24730                                  ;	    DS:SI -> Next Character
 24731                                  ;	    ES:DI -> Parameter List
 24732                                  ;
 24733                                  ; Output:   ZF = 1 if one of delimiter characters
 24734                                  ;	    SI points to the next character
 24735                                  ; Vars:  _$P_Terminator(W), _$P_Flags(W)
 24736                                  ;***********************************************************************
 24737                                  
 24738                                  _$P_Chk_Delim:
 24739 00001C2B 53                      	push	bx			;AN000;
 24740 00001C2C 51                      	push	cx			;AN000;
 24741 00001C2D 2EC606[3B14]20          	mov	byte [cs:_$P_Terminator],_$P_Space 
 24742                                  					;AC034; Assume terminated by space
 24743                                  	;and	byte [cs:_$P_Flags20,0DFh
 24744 00001C33 2E8026[4114]DF          	and	byte [cs:_$P_Flags2],0FFh-_$P_Extra ;AC034;
 24745 00001C39 3C20                    	cmp	al,_$P_Space ; 20h	;AN000; Space ?
 24746 00001C3B 7436                    	je	short _$P_Chk_Delim_Exit ;AN000;
 24747                                  
 24748 00001C3D 3C09                    	cmp	al,_$P_TAB		;AN000; TAB ?
 24749 00001C3F 7432                    	je	short _$P_Chk_Delim_Exit ;AN000;
 24750                                  
 24751 00001C41 3C2C                    	cmp	al,_$P_Comma		;AN000; Comma ?
 24752 00001C43 7431                    	je	short _$P_Chk_Delim_Exit0 ;AN000;
 24753                                  
 24754                                  	; 26/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 24755                                  _$P_Chk_Delim00: 			;AN000;
 24756 00001C45 3C20                    	cmp	al,_$P_DBSP1	; 20h	;AN000; 1st byte of DBCS Space ?
 24757 00001C47 750C                    	jne	short _$P_Chk_Delim01	;AN000;
 24758                                  
 24759 00001C49 803C20                  	cmp	byte [si],_$P_DBSP2 ; 20h ;AN000; 2nd byte of DBCS Space ?
 24760 00001C4C 7507                    	jne	short _$P_Chk_Delim01	;AN000;
 24761                                  
 24762 00001C4E B020                    	mov	al,_$P_Space		;AN000;
 24763 00001C50 46                      	inc	si			;AN000; make si point to next character
 24764 00001C51 38C0                    	cmp	al,al			;AN000; Set ZF
 24765 00001C53 EB1E                    	jmp	short _$P_Chk_Delim_Exit ;AN000;
 24766                                  
 24767                                  _$P_Chk_Delim01: 			;AN000;
 24768 00001C55 26807DFE01              	cmp	byte [es:di-_$P_PARMS_Blk.Num_Extra],_$P_I_Have_Delim 
 24769                                  					;AN000; delimiter character specified ?
 24770 00001C5A 7217                    	jb	short _$P_Chk_Delim_Exit ;AN000;
 24771                                  
 24772                                  	;xor	cx,cx			;AN000;
 24773 00001C5C 30ED                    	xor	ch,ch
 24774                                  	;mov	cl,[es:di+3]
 24775 00001C5E 268A4D03                	mov	cl,[es:di+_$P_PARMS_Blk.Len_Extra_Delim] 
 24776                                  					;AN000; get length of delimiter list
 24777 00001C62 09C9                    	or	cx,cx			;AN000; No extra Delim character ?
 24778 00001C64 740B                    	jz	short _$P_Chk_Delim_NZ 	;AN000;
 24779                                  
 24780 00001C66 BB0300                  	mov	bx,_$P_Len_PARMS-1 ; 3	;AN000; set bx to 1st extra delimiter
 24781                                  _$P_Chk_Delim_Loop:			;AN000;
 24782 00001C69 43                      	inc	bx			;AN000;
 24783 00001C6A 263A01                  	cmp	al,[es:bx+di]		;AN000; Check extra Delim character
 24784 00001C6D 7407                    	je	short _$P_Chk_Delim_Exit0 ;AN000;
 24785                                  
 24786 00001C6F E2F8                    	loop	_$P_Chk_Delim_Loop	;AN000; examine all extra delimiter
 24787                                  
 24788                                  _$P_Chk_Delim_NZ:			;AN000;
 24789 00001C71 3C20                    	cmp	al,_$P_Space		;AN000; reset ZF
 24790                                  _$P_Chk_Delim_Exit:			;AN000;
 24791                                  _$P_ChkDfin:				;AN000;
 24792 00001C73 59                      	pop	cx			;AN000;
 24793 00001C74 5B                      	pop	bx			;AN000;
 24794 00001C75 C3                      	retn				;AN000;
 24795                                  
 24796                                  _$P_Chk_Delim_Exit0:			;AN000;
 24797 00001C76 2EA2[3B14]              	mov	[cs:_$P_Terminator],al ;AC034; keep terminated delimiter
 24798 00001C7A 2EF606[4114]01          	test	byte [cs:_$P_Flags2],_$P_equ ;AN027;AC034;; if terminating a key=
 24799 00001C80 7506                    	jnz	short _$P_No_Set_Extra 	;AN027; then do not set the EXTRA bit
 24800                                  
 24801 00001C82 2E800E[4114]20          	or	byte [cs:_$P_Flags2],_$P_Extra 
 24802                                  					;AC034; flag terminated extra delimiter or comma
 24803                                  _$P_No_Set_Extra:			;AN027;
 24804 00001C88 38C0                    	cmp	al,al			;AN000; set ZF
 24805 00001C8A EBE7                    	jmp	short _$P_Chk_Delim_Exit ;AN000;
 24806                                  
 24807                                  
 24808                                  ;***********************************************************************
 24809                                  ; _$P_Chk_Switch;
 24810                                  ;
 24811                                  ; Function: Check if AL is the switch character not in first position of
 24812                                  ;	    _$P_STRING_BUF
 24813                                  ;
 24814                                  ; Input:    AL = character code
 24815                                  ;	    BX = current pointer within _$P_String_Buf
 24816                                  ;	    SI =>next char on command line (following the one in AL)
 24817                                  ;
 24818                                  ; Output:   CF = 1 (set)if AL is switch character, and not in first
 24819                                  ;		 position, and has no chance of being part of a date string,
 24820                                  ;		 i.e. should be treated as a delimiter.
 24821                                  
 24822                                  ;	    CF = 0 (reset, cleared) if AL is not a switch char, is in the first
 24823                                  ;		 position, or is a slash but may be part of a date string, i.e.
 24824                                  ;		 should not be treated as a delimiter.
 24825                                  ;
 24826                                  ; Vars:  _$P_Terminator(W)
 24827                                  
 24828                                  ; Use:	 _$P_0099
 24829                                  ;***********************************************************************
 24830                                  
 24831                                  _$P_Chk_Switch:
 24832                                  	;lea	bp,[cs:_$P_STRING_BUF]	;AN020;AC034
 24833 00001C8C 8D2E[4A14]              	lea	bp,[_$P_STRING_BUF]	; BP=OFFSET of _$P_String_Buf even in group addressing
 24834                                  ;	.IF <BX NE BP> THEN		;AN020;IF not first char THEN
 24835 00001C90 39EB                    	cmp	bx,bp			;AN000;
 24836 00001C92 7406                    	je	short _$P_STRUC_L2	;AN000;
 24837                                  
 24838                                  ;	    .IF <AL EQ _$P_Switch> THEN	;AN020;otherwise see if a slash
 24839 00001C94 3C2F                    	cmp	al,_$P_Switch		;AN000;
 24840 00001C96 750C                    	jne	short _$P_STRUC_L5 	;AN000;
 24841                                  
 24842 00001C98 F9                      	stc				;AN020;not in first position and is slash
 24843                                  	;jmp     short _$P_STRUC_L1	;AN000;
 24844                                  	; 12/12/2022
 24845 00001C99 C3                      	retn
 24846                                  
 24847                                  ; 12/12/2022
 24848                                  ;_$P_STRUC_L5:				;AN000;
 24849                                  ;	CLC				;AN020;not a slash
 24850                                  ;;	    .ENDIF			;AN020;
 24851                                  ;;	.ELSE				;AN020;is first char in the buffer, ZF=0
 24852                                  ;	jmp	short _$P_STRUC_L1	;AN000;
 24853                                  
 24854                                  _$P_STRUC_L2:				;AN000;
 24855                                  ;	    .IF <AL EQ _$P_Switch> THEN	;AN020;
 24856 00001C9A 3C2F                    	cmp     al,_$P_Switch		;AN000;
 24857 00001C9C 7506                    	jne	short _$P_STRUC_L12	;AN000;
 24858                                  
 24859 00001C9E 2E800E[4114]40          	or	byte [cs:_$P_Flags2],_$P_SW ;AN020;AC034;;could be valid switch, first char and is slash
 24860                                  ;	    .ENDIF			;AN020;
 24861                                  
 24862                                  	; 12/12/2022
 24863                                  	; cf=0
 24864                                  	;retn
 24865                                  
 24866                                  _$P_STRUC_L5:
 24867                                  	; 12/12/2022
 24868                                  _$P_STRUC_L12:				;AN000;
 24869 00001CA4 F8                      	clc				;AN020;CF=0 indicating first char
 24870                                  ;	.ENDIF				;AN020;
 24871                                  _$P_STRUC_L1:				;AN000;
 24872 00001CA5 C3                      	retn				;AN000;
 24873                                  
 24874                                  ;**************************************************************************
 24875                                  ; _$P_Chk_DBCS:
 24876                                  ;
 24877                                  ;  Function: Check if a specified byte is in ranges of the DBCS lead bytes
 24878                                  ;
 24879                                  ;  Input:
 24880                                  ;	  AL	= Code to be examineed
 24881                                  ;
 24882                                  ;  Output:
 24883                                  ;	  If CF is on then a lead byte of DBCS
 24884                                  ;
 24885                                  ; Use: INT 21h w/AH=63
 24886                                  ;
 24887                                  ; Vars:  _$P_DBCSEV_Seg(RW), _$P_DBCSEV_Off(RW)
 24888                                  ;***************************************************************************
 24889                                  
 24890                                  _$P_Chk_DBCS:
 24891 00001CA6 1E                      	push	ds			;AN000;
 24892 00001CA7 56                      	push	si			;AN000;
 24893 00001CA8 53                      	push	bx			;AN000; (tm11)
 24894                                  	
 24895 00001CA9 2E833E[3E14]00          	cmp	word [cs:_$P_DBCSEV_SEG],0 ;AC034; ALREADY SET ?
 24896 00001CAF 7527                    	jne	short _$P_DBCS00	;AN000;
 24897                                  
 24898 00001CB1 50                      	push	ax			;AN000;
 24899 00001CB2 1E                      	push	ds			;AN000; (tm11)
 24900 00001CB3 51                      	push	cx			;AN000;
 24901 00001CB4 52                      	push	dx			;AN000;
 24902 00001CB5 57                      	push	di			;AN000;
 24903 00001CB6 55                      	push	bp			;AN000;
 24904 00001CB7 06                      	push	es			;AN000;
 24905 00001CB8 31F6                    	xor	si,si			;AN000;
 24906 00001CBA 8EDE                    	mov	ds,si			;AN000;
 24907 00001CBC B80063                  	MOV	ax,_$P_DOS_GetEV ; 6300h ;AN000; GET DBCS EV CALL
 24908 00001CBF CD21                    	int	21h			;AN000;
 24909                                  		; DOS - 3.2+ only - GET DOUBLE BYTE CHARACTER SET LEAD TABLE
 24910 00001CC1 8CDB                    	mov	bx,ds			;AN000; (tm11)
 24911 00001CC3 09DB                    	or	bx,bx			;AN000; (tm11)
 24912 00001CC5 07                      	pop	es			;AN000;
 24913 00001CC6 5D                      	pop	bp			;AN000;
 24914 00001CC7 5F                      	pop	di			;AN000;
 24915 00001CC8 5A                      	pop	dx			;AN000;
 24916 00001CC9 59                      	pop	cx			;AN000;
 24917 00001CCA 1F                      	pop	ds			;AN000; (tm11)
 24918 00001CCB 58                      	pop	ax			;AN000;
 24919 00001CCC 7429                    	jz	short _$P_NON_DBCS	;AN000;
 24920                                  
 24921                                  _$P_DBCS02:				;AN000;
 24922 00001CCE 2E8936[3C14]            	mov	[cs:_$P_DBCSEV_OFF],si	;AC034; save EV offset
 24923 00001CD3 2E891E[3E14]            	mov	[cs:_$P_DBCSEV_SEG],bx	;AC034; save EV segment (tm11)
 24924                                  _$P_DBCS00:				;AN000;
 24925 00001CD8 2E8B36[3C14]            	mov	si,[cs:_$P_DBCSEV_OFF]	;AC034; load EV offset
 24926 00001CDD 2E8E1E[3E14]            	mov	ds,[cs:_$P_DBCSEV_SEG]	;AC034; and segment
 24927                                  
 24928                                  _$P_DBCS_LOOP:				;AN000;
 24929 00001CE2 833C00                  	cmp	word [si],0		;AN000; zero vector ?
 24930 00001CE5 7410                    	je	short _$P_NON_DBCS	;AN000; then exit
 24931                                  
 24932 00001CE7 3A04                    	cmp	al,[si] 		;AN000;
 24933 00001CE9 7208                    	jb	short _$P_DBCS01	;AN000; Check if AL is in
 24934                                  
 24935 00001CEB 3A4401                  	cmp	al,[si+1]		;AN000;   range of
 24936 00001CEE 7703                    	ja	short _$P_DBCS01	;AN000;      the vector
 24937                                  
 24938 00001CF0 F9                      	stc				;AN000; if yes, indicate DBCS and exit
 24939 00001CF1 EB04                    	jmp	short _$P_DBCS_EXIT	;AN000;
 24940                                  
 24941                                  _$P_DBCS01:				;AN000;
 24942 00001CF3 46                      	inc	si			;AC035; add '2' to
 24943 00001CF4 46                      	inc	si			;AC035;  SI reg
 24944                                  					;AN000; get next vector
 24945 00001CF5 EBEB                    	jmp	short _$P_DBCS_LOOP	;AN000; loop until zero vector found
 24946                                  
 24947                                  _$P_NON_DBCS:				;AN000;
 24948                                  	; 12/12/2022
 24949                                  	; cf=0
 24950                                  	;clc				;AN000; indicate SBCS
 24951                                  _$P_DBCS_EXIT:				;AN000;
 24952 00001CF7 5B                      	pop	bx			;AN000; (tm11)
 24953 00001CF8 5E                      	pop	si			;AN000;
 24954 00001CF9 1F                      	pop	ds			;AN000;
 24955 00001CFA C3                      	retn				;AN000;
 24956                                  
 24957                                  ; SYSCONF.ASM - MSDOS 6.0 - 1991
 24958                                  ; ======================================================================
 24959                                  ; 27/03/2019 - Retro DOS v4.0
 24960                                  
 24961                                  ;control block definitions for parser.
 24962                                  ;-----------------------------------------------------------------------
 24963                                  ; buffer = [n | n,m] {/e}
 24964                                  
 24965                                  ; 30/03/2019
 24966                                  
 24967                                  struc p_parms
 24968 00000000 ????                    	resw	1	; dw ?
 24969 00000002 ??                      	resb	1	; db 1	; an extra delimiter list
 24970 00000003 ??                      	resb	1	; db 1	; length is 1
 24971 00000004 ??                      	resb 	1	; db ';' ; delimiter
 24972                                  .size:
 24973                                  endstruc
 24974                                  
 24975                                  struc p_pos
 24976 00000000 ????                    	resw	1	; dw ?	; numeric value??
 24977 00000002 ????                    	resw	1	; dw ?	; function
 24978 00000004 ????                    	resw	1	; dw ?	; result value buffer
 24979                                  
 24980                                  ; note: by defining result_val before this structure, we could remove
 24981                                  ;  the "result_val" from every structure invocation
 24982                                  
 24983 00000006 ????                    	resw	1	; dw ?	; value list
 24984 00000008 ??                      	resb	1	; db 0	; no switches/keywords
 24985                                  .size:
 24986                                  endstruc
 24987                                  
 24988                                  struc	p_range
 24989 00000000 ??                      	resb	1	; db 1	; range definition
 24990 00000001 ??                      	resb 	1	; db 1	; 1 definition of range
 24991 00000002 ??                      	resb 	1	; db 1	; item tag for this range
 24992 00000003 ????????                	resd	1	; dd ?	; numeric min
 24993 00000007 ????????                	resd	1	; dd ?	; numeric max
 24994                                  .size:
 24995                                  endstruc
 24996                                  
 24997                                  ;-----------------------------------------------------------------------
 24998                                  
 24999                                  	; 26/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 25000                                  	; (SYSINIT:1F48h)
 25001                                  
 25002                                  ; buffer = [n | n,m] {/e}
 25003                                  
 25004                                  ;buf_parms p_parms <buf_parmsx>
 25005                                  buf_parms: 
 25006 00001CFB [001D]                  	dw	buf_parmsx
 25007 00001CFD 01                      	db	1	; an extra delimiter list
 25008 00001CFE 01                      	db	1	; length is 1
 25009 00001CFF 3B                      	db	';'	; delimiter
 25010                                  
 25011                                  buf_parmsx:
 25012 00001D00 0102[0A1D][1E1D]        	dw	201h,buf_pos1,buf_pos2	; min 1, max 2 positionals
 25013 00001D06 01                      	db	1			; one switch
 25014 00001D07 [321D]                  	dw	sw_x_ctrl
 25015 00001D09 00                      	db	0			; no keywords
 25016                                  
 25017                                  ;buf_pos1 p_pos <8000h,0,result_val,buf_range_1>  ; numeric
 25018                                  buf_pos1:
 25019 00001D0A 0080                    	dw	8000h	; numeric value??
 25020 00001D0C 0000                    	dw	0	; function
 25021 00001D0E [441D]                  	dw	result_val ; result value buffer	
 25022 00001D10 [131D]                  	dw	buf_range_1 ; value list
 25023 00001D12 00                      	db	0  	; no switches/keywords
 25024                                  
 25025                                  ;buf_range_1 p_range <,,,1,99>		; M050
 25026                                  buf_range_1:
 25027 00001D13 01                      	db	1	; range definition
 25028 00001D14 01                      	db	1	; 1 definition of range
 25029 00001D15 01                      	db	1	; item tag for this range
 25030 00001D16 01000000                	dd	1	; numeric min
 25031 00001D1A 63000000                	dd	99	; numeric max
 25032                                  
 25033                                  ;buf_pos2 p_pos <8001h,0,result_val,buf_range_2> ; optional num.
 25034                                  buf_pos2:
 25035 00001D1E 0180                    	dw	8001h
 25036 00001D20 0000                    	dw	0
 25037 00001D22 [441D]                  	dw	result_val	
 25038 00001D24 [271D]                  	dw	buf_range_2
 25039 00001D26 00                      	db	0
 25040                                  
 25041                                  ;buf_range_2 p_range <,,,0,8>
 25042                                  buf_range_2:
 25043 00001D27 01                      	db	1
 25044 00001D28 01                      	db	1
 25045 00001D29 01                      	db	1
 25046 00001D2A 00000000                	dd	0
 25047 00001D2E 08000000                	dd	8
 25048                                  
 25049                                  ;sw_x_ctrl p_pos <0,0,result_val,noval,1> ; followed by one switch
 25050                                  sw_x_ctrl:
 25051 00001D32 0000                    	dw	0
 25052 00001D34 0000                    	dw	0
 25053 00001D36 [441D]                  	dw	result_val	
 25054 00001D38 [431D]                  	dw	noval
 25055 00001D3A 01                      	db	1	; 1 switch
 25056                                  	
 25057                                  switch_x:
 25058 00001D3B 2F5800                  	db	'/X',0		; M016
 25059                                  
 25060                                  p_buffers:
 25061 00001D3E 0000                    	dw	0	; local variables
 25062                                  p_h_buffers:
 25063 00001D40 0000                    	dw	0
 25064                                  	; 26/10/2022  (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 25065                                  p_buffer_slash_x:
 25066 00001D42 00                      	db	0 ; 31/03/2019
 25067                                  
 25068                                  ;-- common definitions -------------------------------------------------
 25069                                  
 25070 00001D43 00                      noval:	db	0
 25071                                  
 25072                                  result_val: 	;label	byte
 25073 00001D44 00                      	db	0		; type returned
 25074                                  result_val_itag:
 25075 00001D45 00                      	db	0		; item tag returned
 25076                                  result_val_swoff:
 25077 00001D46 0000                    	dw	0		; es:offset of the switch defined
 25078                                  rv_byte:	;label	byte
 25079 00001D48 00000000                rv_dword: dd	0		; value if number,or seg:offset to string.
 25080                                  
 25081                                  ;-----------------------------------------------------------------------
 25082                                  
 25083                                  	; 27/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 25084                                  	; (SYSINIT:1F99h)
 25085                                  
 25086                                  ; break = [ on | off ]
 25087                                  
 25088                                  ;brk_parms p_parms  <brk_parmsx>
 25089                                  brk_parms:
 25090 00001D4C [511D]                  	dw	brk_parmsx
 25091 00001D4E 01                      	db	1	; an extra delimiter list
 25092 00001D4F 01                      	db	1	; length is 1
 25093 00001D50 3B                      	db	';'	; delimiter
 25094                                  
 25095                                  brk_parmsx:
 25096 00001D51 0101[571D]              	dw	101h,brk_pos	; min,max = 1 positional
 25097 00001D55 00                      	db	0		; no switches
 25098 00001D56 00                      	db	0		; no keywords
 25099                                  
 25100                                  ;brk_pos p_pos <2000h,0,result_val,on_off_string> ; simple string
 25101                                  brk_pos:
 25102 00001D57 0020                    	dw	2000h
 25103 00001D59 0000                    	dw	0
 25104 00001D5B [441D]                  	dw	result_val	
 25105 00001D5D [601D]                  	dw	on_off_string
 25106 00001D5F 00                      	db	0
 25107                                  
 25108                                  on_off_string:	;label	byte
 25109 00001D60 03                      	db	3		; signals that there is a string choice
 25110 00001D61 00                      	db	0		; no range definition
 25111 00001D62 00                      	db	0		; no numeric values choice
 25112 00001D63 02                      	db	2		; 2 strings for choice
 25113 00001D64 01                      	db	1		; the 1st string tag
 25114 00001D65 [6A1D]                  	dw	on_string
 25115 00001D67 02                      	db	2		; the 2nd string tag
 25116 00001D68 [6D1D]                  	dw	off_string
 25117                                  
 25118                                  on_string:
 25119 00001D6A 4F4E00                  	db	"ON",0
 25120                                  off_string:
 25121 00001D6D 4F464600                	db	"OFF",0
 25122                                  
 25123                                  p_ctrl_break:
 25124 00001D71 00                      	db	0	; local variable
 25125                                  
 25126                                  ;-----------------------------------------------------------------------
 25127                                  
 25128                                  	; 27/10/2022
 25129                                  
 25130                                  ; country = n {m {path}}
 25131                                  ; or
 25132                                  ; country = n,,path
 25133                                  
 25134                                  ;cntry_parms p_parms <cntry_parmsx>
 25135                                  cntry_parms:
 25136 00001D72 [771D]                  	dw	cntry_parmsx
 25137 00001D74 01                      	db	1
 25138 00001D75 01                      	db	1
 25139 00001D76 3B                      	db	';'
 25140                                  	
 25141                                  cntry_parmsx:
 25142 00001D77 0103[811D][951D]-       	dw	301h,cntry_pos1,cntry_pos2,cntry_pos3 ; min 1, max 3 pos.
 25142 00001D7D [9E1D]             
 25143 00001D7F 00                      	db	0		; no switches
 25144 00001D80 00                      	db	0		; no keywords
 25145                                  
 25146                                  ;cntry_pos1 p_pos <8000h,0,result_val,cc_range> ; numeric value
 25147                                  cntry_pos1:
 25148 00001D81 0080                    	dw	8000h
 25149 00001D83 0000                    	dw	0
 25150 00001D85 [441D]                  	dw	result_val	
 25151 00001D87 [8A1D]                  	dw	cc_range
 25152 00001D89 00                      	db	0
 25153                                  
 25154                                  ;cc_range p_range <,,,1,999>
 25155                                  cc_range:
 25156 00001D8A 01                      	db	1
 25157 00001D8B 01                      	db	1
 25158 00001D8C 01                      	db	1
 25159 00001D8D 01000000                	dd	1
 25160 00001D91 E7030000                	dd	999
 25161                                  
 25162                                  ;cntry_pos2 p_pos <8001h,0,result_val,cc_range> ; optional num.
 25163                                  cntry_pos2:
 25164 00001D95 0180                    	dw	8001h
 25165 00001D97 0000                    	dw	0
 25166 00001D99 [441D]                  	dw	result_val	
 25167 00001D9B [8A1D]                  	dw	cc_range
 25168 00001D9D 00                      	db	0
 25169                                  
 25170                                  ;cntry_pos3 p_pos <201h,0,result_val,noval>     ; optional filespec
 25171                                  cntry_pos3:
 25172 00001D9E 0102                    	dw	201h
 25173 00001DA0 0000                    	dw	0
 25174 00001DA2 [441D]                  	dw	result_val	
 25175 00001DA4 [431D]                  	dw	noval
 25176 00001DA6 00                      	db	0	
 25177                                  
 25178                                  p_cntry_code:
 25179 00001DA7 0000                    	dw	0	; local variable
 25180                                  p_code_page:
 25181 00001DA9 0000                    	dw	0	; local variable
 25182                                  
 25183                                  ;-----------------------------------------------------------------------
 25184                                  
 25185                                  	; 27/10/2022
 25186                                  
 25187                                  ; files = n
 25188                                  
 25189                                  ;files_parms p_parms <files_parmsx>
 25190                                  files_parms:
 25191 00001DAB [B01D]                  	dw	files_parmsx
 25192 00001DAD 01                      	db	1
 25193 00001DAE 01                      	db	1
 25194 00001DAF 3B                      	db	';'
 25195                                  
 25196                                  files_parmsx:
 25197 00001DB0 0101[B61D]              	dw	101h,files_pos	; min,max 1 positional
 25198 00001DB4 00                      	db	0		; no switches
 25199 00001DB5 00                      	db	0		; no keywords
 25200                                  
 25201                                  ;files_pos p_pos <8000h,0,result_val,files_range,0> ; numeric value
 25202                                  files_pos:
 25203 00001DB6 0080                    	dw	8000h
 25204 00001DB8 0000                    	dw	0
 25205 00001DBA [441D]                  	dw	result_val	
 25206 00001DBC [BF1D]                  	dw	files_range
 25207 00001DBE 00                      	db	0
 25208                                  
 25209                                  ;files_range p_range <,,,8,255>
 25210                                  files_range:
 25211 00001DBF 01                      	db	1
 25212 00001DC0 01                      	db	1
 25213 00001DC1 01                      	db	1
 25214 00001DC2 08000000                	dd	8
 25215 00001DC6 FF000000                	dd	255
 25216                                  
 25217                                  p_files:
 25218 00001DCA 00                      	db	0		; local variable
 25219                                  
 25220                                  ;-----------------------------------------------------------------------
 25221                                  
 25222                                  	; 27/10/2022
 25223                                  
 25224                                  ; fcbs = n,m
 25225                                  
 25226                                  ;fcbs_parms p_parms <fcbs_parmsx>
 25227                                  fcbs_parms:
 25228 00001DCB [D01D]                  	dw	fcbs_parmsx
 25229 00001DCD 01                      	db	1
 25230 00001DCE 01                      	db	1
 25231 00001DCF 3B                      	db	';'
 25232                                  
 25233                                  fcbs_parmsx:
 25234 00001DD0 0102[D81D][EC1D]        	dw	201h,fcbs_pos_1,fcbs_pos_2 ; min,max = 2 positional
 25235 00001DD6 00                      	db	0		; no switches
 25236 00001DD7 00                      	db	0		; no keywords
 25237                                  
 25238                                  ;fcbs_pos_1 p_pos <8000h,0,result_val,fcbs_range> ; numeric value
 25239                                  fcbs_pos_1:
 25240 00001DD8 0080                    	dw	8000h
 25241 00001DDA 0000                    	dw	0
 25242 00001DDC [441D]                  	dw	result_val	
 25243 00001DDE [E11D]                  	dw	fcbs_range
 25244 00001DE0 00                      	db	0
 25245                                  
 25246                                  ;fcbs_range p_range <,,,1,255>
 25247                                  fcbs_range:
 25248 00001DE1 01                      	db	1
 25249 00001DE2 01                      	db	1
 25250 00001DE3 01                      	db	1
 25251 00001DE4 01000000                	dd	1
 25252 00001DE8 FF000000                	dd	255
 25253                                  
 25254                                  ;fcbs_pos_2 p_pos <8000h,0,result_val,fcbs_keep_range> ; numeric value
 25255                                  fcbs_pos_2:
 25256 00001DEC 0080                    	dw	8000h
 25257 00001DEE 0000                    	dw	0
 25258 00001DF0 [441D]                  	dw	result_val	
 25259 00001DF2 [F51D]                  	dw	fcbs_keep_range
 25260 00001DF4 00                      	db	0
 25261                                  
 25262                                  ;fcbs_keep_range p_range <,,,0,255>
 25263                                  fcbs_keep_range:
 25264 00001DF5 01                      	db	1
 25265 00001DF6 01                      	db	1
 25266 00001DF7 01                      	db	1
 25267 00001DF8 00000000                	dd	0
 25268 00001DFC FF000000                	dd	255
 25269                                  
 25270 00001E00 00                      p_fcbs:	db	0		; local variable
 25271 00001E01 00                      p_keep:	db	0		; local variable
 25272                                  
 25273                                  ;-----------------------------------------------------------------------
 25274                                  
 25275                                  	; 27/10/2022
 25276                                  
 25277                                  ; lastdrive = x
 25278                                  
 25279                                  ;ldrv_parms p_parms <ldrv_parmsx>
 25280                                  ldrv_parms:
 25281 00001E02 [071E]                  	dw	ldrv_parmsx
 25282 00001E04 01                      	db	1
 25283 00001E05 01                      	db	1
 25284 00001E06 3B                      	db	';'
 25285                                  
 25286                                  ldrv_parmsx:
 25287 00001E07 0101[0D1E]              	dw	101h,ldrv_pos	; min,max = 1 positional
 25288 00001E0B 00                      	db	0		; no switches
 25289 00001E0C 00                      	db	0		; no keywords
 25290                                  
 25291                                  ;ldrv_pos p_pos	<110h,10h,result_val,noval> ; drive only, ignore colon
 25292                                  ldrv_pos:				    ; remove colon at end
 25293 00001E0D 1001                    	dw	110h
 25294 00001E0F 1000                    	dw	10h
 25295 00001E11 [441D]                  	dw	result_val	
 25296 00001E13 [431D]                  	dw	noval
 25297 00001E15 00                      	db	0
 25298                                  	
 25299 00001E16 00                      p_ldrv:	db	0		; local variable
 25300                                  
 25301                                  ;-----------------------------------------------------------------------
 25302                                  
 25303                                  	; 27/10/2022
 25304                                  
 25305                                  ; stacks = n,m
 25306                                  
 25307                                  ;stks_parms p_parms <stks_parmsx>
 25308                                  stks_parms:
 25309 00001E17 [1C1E]                  	dw	stks_parmsx
 25310 00001E19 01                      	db	1
 25311 00001E1A 01                      	db	1
 25312 00001E1B 3B                      	db	';'
 25313                                  
 25314                                  stks_parmsx:
 25315 00001E1C 0202[241E][381E]        	dw	202h,stks_pos_1,stks_pos_2 ; min,max = 2 positionals
 25316 00001E22 00                      	db	0		; no switches
 25317 00001E23 00                      	db	0		; no keywords
 25318                                  
 25319                                  ;stks_pos_1 p_pos <8000h,0,result_val,stks_range> ; numeric value
 25320                                  stks_pos_1:
 25321 00001E24 0080                    	dw	8000h
 25322 00001E26 0000                    	dw	0
 25323 00001E28 [441D]                  	dw	result_val	
 25324 00001E2A [2D1E]                  	dw	stks_range
 25325 00001E2C 00                      	db	0
 25326                                  
 25327                                  ;stks_range p_range <,,,0,64>
 25328                                  stks_range:
 25329 00001E2D 01                      	db	1
 25330 00001E2E 01                      	db	1
 25331 00001E2F 01                      	db	1
 25332 00001E30 00000000                	dd	0
 25333 00001E34 40000000                	dd	64
 25334                                  
 25335                                  ;stks_pos_2 p_pos <8000h,0,result_val,stk_size_range> ; numeric value
 25336                                  stks_pos_2:
 25337 00001E38 0080                    	dw	8000h
 25338 00001E3A 0000                    	dw	0
 25339 00001E3C [441D]                  	dw	result_val	
 25340 00001E3E [411E]                  	dw	stk_size_range
 25341 00001E40 00                      	db	0
 25342                                  
 25343                                  ;stk_size_range p_range <,,,0,512>
 25344                                  stk_size_range:
 25345 00001E41 01                      	db	1
 25346 00001E42 01                      	db	1
 25347 00001E43 01                      	db	1
 25348 00001E44 00000000                	dd	0
 25349 00001E48 00020000                	dd	512	
 25350                                  
 25351                                  p_stack_count:
 25352 00001E4C 0000                    	dw	0	; local variable
 25353                                  p_stack_size:
 25354 00001E4E 0000                    	dw	0	; local variable
 25355                                  
 25356                                  ;-----------------------------------------------------------------------
 25357                                  
 25358                                  	; 27/10/2022
 25359                                  
 25360                                  ; multitrack = [ on | off ]
 25361                                  
 25362                                  ;mtrk_parms p_parms <mtrk_parmsx>
 25363                                  mtrk_parms:
 25364 00001E50 [551E]                  	dw	mtrk_parmsx
 25365 00001E52 01                      	db	1
 25366 00001E53 01                      	db	1
 25367 00001E54 3B                      	db	';'
 25368                                  
 25369                                  mtrk_parmsx:
 25370 00001E55 0101[5B1E]              	dw	101h,mtrk_pos	; min,max = 1 positional
 25371 00001E59 00                      	db	0		; no switches
 25372 00001E5A 00                      	db	0		; no keywords
 25373                                  
 25374                                  ;mtrk_pos p_pos <2000h,0,result_val,on_off_string> ; simple string
 25375                                  mtrk_pos:
 25376 00001E5B 0020                    	dw	2000h
 25377 00001E5D 0000                    	dw	0
 25378 00001E5F [441D]                  	dw	result_val	
 25379 00001E61 [601D]                  	dw	on_off_string
 25380 00001E63 00                      	db	0
 25381                                  
 25382 00001E64 00                      p_mtrk:	db	0		; local variable
 25383                                  
 25384                                  ;-----------------------------------------------------------------------
 25385                                  
 25386                                  	; 27/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 25387                                  	; (SYSINIT:20B2h)
 25388                                  
 25389                                  ; switches=/k
 25390                                  
 25391                                  ;swit_parms p_parms <swit_parmsx>
 25392                                  swit_parms:
 25393 00001E65 [6A1E]                  	dw	swit_parmsx
 25394 00001E67 01                      	db	1
 25395 00001E68 01                      	db	1
 25396 00001E69 3B                      	db	';'
 25397                                  
 25398                                  swit_parmsx:
 25399 00001E6A 0000                    	dw	0		; no positionals
 25400                                  	;db	5               ; # of switches
 25401                                  	; 27/10/2022 - Retro DOS v4.0 (MSDOS 5.0 IO.SYS, SYSINIT)
 25402 00001E6C 03                      	db	3
 25403 00001E6D [741E]                  	dw	swit_k_ctrl	; /k control
 25404                                  	;dw	swit_n_ctrl     ; /n control (for MULTI_CONFIG only)
 25405                                  	;dw	swit_f_ctrl     ; /f control (for MULTI_CONFIG only)
 25406 00001E6F [801E]                  	dw	swit_t_ctrl     ; /t control
 25407 00001E71 [8C1E]                  	dw	swit_w_ctrl     ; /w control
 25408 00001E73 00                      	db	0		; no keywords
 25409                                  
 25410                                  ;swit_k_ctrl p_pos <0,0,result_val,noval,1> ; switch string follows
 25411                                  swit_k_ctrl:
 25412 00001E74 00000000[441D]-         	dw	0,0,result_val,noval
 25412 00001E7A [431D]             
 25413 00001E7C 01                      	db	1
 25414 00001E7D 2F4B00                  swit_k:	db	'/K',0
 25415                                  
 25416                                  ; 27/10/2022 - Retro DOS v4.0 (MSDOS 5.0 IO.SYS, SYSINIT)
 25417                                  ;
 25418                                  ;;swit_n_ctrl p_pos <0,0,result_val,noval,1> ; switch string follows
 25419                                  ;swit_n_ctrl:
 25420                                  ;	dw	0,0,result_val,noval
 25421                                  ;	db	1
 25422                                  ;swit_n: db	'/N',0
 25423                                  ;
 25424                                  ;;swit_f_ctrl p_pos <0,0,result_val,noval,1> ; switch string follows
 25425                                  ;swit_f_ctrl:
 25426                                  ;	dw	0,0,result_val,noval
 25427                                  ;	db	1
 25428                                  ;swit_f: db 	'/F',0
 25429                                  
 25430                                  	; 27/10/2022
 25431                                  
 25432                                  ;swit_t_ctrl p_pos <0,0,result_val,noval,1> ; switch string follows	M059
 25433                                  swit_t_ctrl:
 25434 00001E80 00000000[441D]-         	dw	0,0,result_val,noval
 25434 00001E86 [431D]             
 25435 00001E88 01                      	db	1
 25436 00001E89 2F5400                  swit_t:	db	'/T',0			   ;				M059
 25437                                  ;swit_w_ctrl p_pos <0,0,result_val,noval,1> ; switch string follows	M063
 25438                                  swit_w_ctrl:
 25439 00001E8C 00000000[441D]-         	dw	0,0,result_val,noval
 25439 00001E92 [431D]             
 25440 00001E94 01                      	db	1
 25441 00001E95 2F5700                  swit_w:	db	'/W',0			   ;				M063
 25442                                  
 25443                                  ;   There doesn't need to be p_swit_n or p_swit_f because /N and /F are
 25444                                  ;   acted upon during MULTI_CONFIG processing; we only needed entries
 25445                                  ;   in the above table to prevent the parsing code from complaining about them
 25446                                  
 25447 00001E98 00                      p_swit_k:	db     0	; local variable
 25448 00001E99 00                      p_swit_t:	db     0	; local variable			M059
 25449 00001E9A 00                      p_swit_w:	db     0	; local variable			M063
 25450                                  
 25451                                  ;-----------------------------------------------------------------------
 25452                                  
 25453                                  	; 27/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 25454                                  	; (SYSINIT:20E8h)
 25455                                  
 25456                                  ; DOS = [ high | low ]
 25457                                  
 25458                                  ;dos_parms p_parms  <dos_parmsx>
 25459                                  dos_parms:
 25460 00001E9B [A01E]                  	dw	dos_parmsx
 25461 00001E9D 01                      	db	1
 25462 00001E9E 01                      	db	1
 25463 00001E9F 3B                      	db	';'
 25464                                  dos_parmsx:
 25465 00001EA0 01                      	db	1		; min parameters
 25466 00001EA1 02                      	db	2		; max parameters
 25467 00001EA2 [A81E]                  	dw	dos_pos		; 
 25468 00001EA4 [A81E]                  	dw	dos_pos		; 
 25469 00001EA6 00                      	db	0		; no switches
 25470 00001EA7 00                      	db	0		; no keywords
 25471                                  
 25472                                  ;dos_pos p_pos	<2000h,0,result_val,dos_strings> ; simple string
 25473                                  ;        p_pos	<2000h,0,result_val,dos_strings> ; simple string
 25474                                  dos_pos:
 25475 00001EA8 00200000[441D]-         	dw	2000h,0,result_val,dos_strings
 25475 00001EAE [BA1E]             
 25476 00001EB0 00                      	db	0
 25477 00001EB1 00200000[441D]-         	dw	2000h,0,result_val,dos_strings
 25477 00001EB7 [BA1E]             
 25478 00001EB9 00                      	db	0	
 25479                                  
 25480                                  dos_strings:	;label	byte
 25481 00001EBA 03                      	db	3		; signals that there is a string choice
 25482 00001EBB 00                      	db	0		; no range definition
 25483 00001EBC 00                      	db	0		; no numeric values choice
 25484 00001EBD 04                      	db	4		; 4 strings for choice
 25485 00001EBE 01                      	db	1		; the 1st string tag
 25486 00001EBF [CA1E]                  	dw	hi_string
 25487 00001EC1 02                      	db	2		; the 2nd string tag
 25488 00001EC2 [CF1E]                  	dw	lo_string
 25489 00001EC4 03                      	db	3
 25490 00001EC5 [D31E]                  	dw	umb_string
 25491 00001EC7 04                      	db	4
 25492 00001EC8 [D71E]                  	dw	noumb_string
 25493                                  
 25494 00001ECA 4849474800              hi_string:	db	"HIGH",0
 25495 00001ECF 4C4F5700                lo_string:	db	"LOW",0
 25496 00001ED3 554D4200                umb_string:	db	"UMB",0
 25497 00001ED7 4E4F554D4200            noumb_string:	db	"NOUMB",0
 25498                                  
 25499 00001EDD 00                      p_dos_hi:	db	0	; local variable
 25500                                  				; BUGBUG : I dont know whether PARSER uses
 25501                                  				;          this variable or not
 25502                                  
 25503                                  ; 27/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 25504                                  
 25505                                  %if 0
 25506                                  
 25507                                  ;****************************************************************** RICHID ****
 25508                                  
 25509                                  ;include	highvar.inc	; devicehigh variables (used by loadhigh also)
 25510                                  
 25511                                  ; 30/03/2019 - Retro DOS v4.0
 25512                                  ;------------------------------------------------------------------------------
 25513                                  
 25514                                  ;   Module:   HIGHVAR.INC - Data common to LOADHIGH and DEVICEHIGH, res seg
 25515                                  ;
 25516                                  ;   Date:     May 14, 1992
 25517                                  ;
 25518                                  ;******************************************************************************
 25519                                  ;
 25520                                  ;   Modification log:
 25521                                  ;
 25522                                  ;     DATE    WHO      DESCRIPTION
 25523                                  ;   --------  -------  --------------------------------------------------------
 25524                                  ;   05/14/92  t-richj  Original
 25525                                  ;   06/21/92  t-richj  Final revisions before check-in
 25526                                  ;
 25527                                  ;******************************************************************************
 25528                                  ;
 25529                                  ; There are two primary definitions which need to be made, selectively, before
 25530                                  ; this include file should be used.  These are:
 25531                                  ;    HV_Extern - If this has been defined, variables for this module will be
 25532                                  ;                declared as external.  Otherwise, variables will be declared
 25533                                  ;                public, as well as defined, here.  LoadHigh declares HV_Extern
 25534                                  ;                in stub.asm and loadhi.asm, and does not declare it in
 25535                                  ;                rdata.asm... DeviceHigh does not declare HV_Extern anywhere
 25536                                  ;                (as only one module, sysconf.asm, includes this file).
 25537                                  ;    HV_LoadHigh - This should be defined when this module is going into
 25538                                  ;                  command.com, for LoadHigh.  All of loadhi.asm, stub.asm and
 25539                                  ;                  rdata.asm define this, while io.sys' sysconf.asm does not.
 25540                                  ;
 25541                                  ;******************************************************************************
 25542                                  
 25543                                  ; To keep track of which UMBs were specified on the DH/LH command lines, and
 25544                                  ; to keep track of the minimum sizes given for each, there're two arrays kept
 25545                                  ; in { IO.SYS: sysinitseg / COMMAND.COM: DATARES }... each is MAXUMB elements
 25546                                  ; big.  16 should be around 14 too many for most users, so there's no expected
 25547                                  ; space problem (it's just such a nice round number, eh?).
 25548                                  
 25549                                  MAXUMB	equ	16
 25550                                  
 25551                                  ; Memory elements owned by the system are marked as PSP address 8 in both the
 25552                                  ; USA and Japan; Japanese systems also use 9 under more bizzarre conditions.
 25553                                  
 25554                                  FreePSPOwner	equ	0	; Free MCBs all have an owner PSP address of 0
 25555                                  SystemPSPOwner	equ	8
 25556                                  ;JapanPSPOwner	equ	9
 25557                                  
 25558                                  ; for LoadHigh and DeviceHigh:
 25559                                  ;
 25560                                  ;	fInHigh - Is set to 1 during HideUMBs(), and back to zero in
 25561                                  ;	          UnHideUMBs().
 25562                                  ;	fUmbTiny - Is set to 1 iff the user has specified /S on the command-
 25563                                  ;	           line.
 25564                                  ;	SegLoad - Segment address for first UMB specified; set automatically.
 25565                                  ;	UmbLoad - The load UMB number; for example, this is 3 if the user has
 25566                                  ;	          given a command-line like "/L:3,500;4"
 25567                                  ;	UmbUsed - An array of characters, each of which is 1 iff the UMB
 25568                                  ;	          matching its index number was specified on the command-line;
 25569                                  ;	          for example, after "/L:3,500;4;7", UmbUsed[3], [4] and [7]
 25570                                  ;	          will be set to 1.  All others will be set to 0.
 25571                                  ;	UmbSize - An array of words, each of which is interpereted as a size
 25572                                  ;	          specified by the user for a UMB (in the above example, all
 25573                                  ;	          elements would be zero save UmbSize[3], which would be 500.
 25574                                  ;	fm_umb - Set to the old UMB link-state (0x80 or 0x00)
 25575                                  ;	fm_strat - Set to the old memory-allocation strategy (0$00000???)
 25576                                  ;	fm_argc  - Number of arguments received by ParseVar() (see ParseVar()
 25577                                  ;	           for details).
 25578                                  
 25579                                  fInHigh:  db	0
 25580                                  fUmbTiny: db	0
 25581                                  SegLoad:  dw	0
 25582                                  UmbLoad:  db	0
 25583                                  UmbUsed:  times MAXUMB db 0 ; times 16 db 0  ; db 16 dup(?)
 25584                                  UmbSize:  times MAXUMB dw 0 ; times 16 dw 0  ; dw 16 dup(?)
 25585                                  fm_umb:   db	0
 25586                                  fm_strat: db	0
 25587                                  fm_argc:  db	0	
 25588                                  
 25589                                  ; UmbLoad is set to UNSPECIFED, below, until /L:umb is read; at which point
 25590                                  ; UmbLoad is set to the UMB number given.
 25591                                  
 25592                                  UNSPECIFIED	equ	-1
 25593                                  
 25594                                  %endif
 25595                                  
 25596                                  ;****************************************************************** RICHID ****
 25597                                  
 25598                                  ; 30/03/2019 - Retro DOS v4.0 (MSDOS 6.0, SYSCONF.ASM)
 25599                                  ; ((MSDOS 6.21 IO.SYS -> SYNINIT:22BAh))
 25600                                  
 25601                                  ; 27/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 25602                                  ; (SYSINIT:212Bh)	
 25603                                  
 25604                                  		;public	DevEntry
 25605                                  
 25606 00001EDE 0000                    DevSize:	dw	0	; size of the device driver being loaded(paras)
 25607 00001EE0 0000                    DevLoadAddr:	dw	0	; Mem addr where the device driver is 2 b loaded
 25608 00001EE2 0000                    DevLoadEnd:	dw	0	; MaxAddr to which device can be loaded
 25609 00001EE4 00000000                DevEntry:	dd	0	; Entry point to the device driver
 25610 00001EE8 00000000                DevBrkAddr:	dd	0	; Break address of the device driver
 25611                                  ; 27/10/2022 
 25612                                  ;ConvLoad:	db	0	; Use conventional (dos 5 -style) InitDevLoad?
 25613                                  ;
 25614 00001EEC 00                      DevUMB:		db	0	; byte indicating whether to load DDs in UMBs
 25615 00001EED 0000                    DevUMBAddr:	dw	0	; cuurent UMB used fro loading devices (paras)
 25616 00001EEF 0000                    DevUMBSize:	dw	0	; Size of the current UMB being used   (paras)
 25617 00001EF1 0000                    DevUMBFree:	dw	0	; Start of free are in the current UMB (paras)
 25618                                  ;
 25619 00001EF3 00000000                DevXMSAddr:	dd	0
 25620                                  ;
 25621 00001EF7 0000                    DevExecAddr:	dw	0	; Device load address parameter to Exec call
 25622 00001EF9 0000                    DevExecReloc:	dw	0	; Device load relocation factor
 25623                                  ;
 25624 00001EFB 00                      DeviceHi:	db	0	; Flag indicating whther the current device
 25625                                  				;  is being loaded into UMB
 25626 00001EFC 0000                    DevSizeOption:	dw	0	; SIZE= option
 25627                                  ;
 25628 00001EFE 00                      Int12Lied:	db	0	; did we trap int 12 ?
 25629 00001EFF 0000                    OldInt12Mem:	dw	0	; value in 40:13h (int 12 ram)
 25630 00001F01 50524F544D414E24        ThreeComName:	db	'PROTMAN$'	; 3Com Device name
 25631                                  ;
 25632 00001F09 00                      FirstUMBLinked:	db	0
 25633 00001F0A 0000                    DevDOSData:	dw	0	; segment of DOS Data
 25634 00001F0C 00000000                DevCmdLine:	dd	0	; Current Command line
 25635 00001F10 00                      DevSavedDelim:	db	0	; The delimiter which was replaced with null
 25636                                  				; to use the file name in the command line
 25637                                  ;
 25638                                  ;	ifdef	dblspace_hooks
 25639                                  ;MagicHomeFlag:	db	0	; set non-zero when MagicDrv is final placed
 25640                                  ;	endif
 25641                                  
 25642                                  ; ===========================================================================
 25643                                  
 25644                                  ; 31/03/2019 - Retro DOS v4.0
 25645                                  
 25646                                  ; 27/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 25647                                  ; (SYSINIT:215Eh)
 25648                                  
 25649                                  ;----------------------------------------------------------------------------
 25650                                  ;
 25651                                  ; procedure : doconf
 25652                                  ;
 25653                                  ;             Config file is parsed initially with this routine. For the
 25654                                  ;             Subsequent passes 'multi_pass' entry is used .
 25655                                  ;
 25656                                  ;----------------------------------------------------------------------------
 25657                                  
 25658                                  	; 27/10/2022
 25659                                  doconf:
 25660 00001F11 0E                      	push	cs
 25661 00001F12 1F                      	pop	ds
 25662                                  
 25663 00001F13 B80037                  	mov	ax,3700h
 25664                                          ;mov	ax,(CHAR_OPER<<8)	; get switch character
 25665 00001F16 CD21                    	int	21h
 25666 00001F18 8816[AA02]              	mov	[command_line+1],dl	; set in default command line
 25667                                  
 25668                                  ; 27/10/2022
 25669                                  ;;ifdef	MULTI_CONFIG
 25670                                  ;	;mov	[command_line-1],dl     ; save default switchchar
 25671                                  ;	mov	[def_swchr],dl ; 31/03/2019 
 25672                                  ;;endif	;MULTI_CONFIG
 25673                                  
 25674 00001F1C BA[7034]                	mov	dx,config ;'\CONFIG.SYS' ;now pointing to file description
 25675 00001F1F B8003D                  	mov	ax,3D00h
 25676                                  	;mov	ax,OPEN<<8		;open file "config.sys"
 25677 00001F22 F9                      	stc				;in case of int 24
 25678 00001F23 CD21                    	int	21h			;function request
 25679 00001F25 7306                    	jnc	short noprob		; brif opened okay
 25680                                  
 25681                                  ; 27/10/2022
 25682                                  ;;ifdef	MULTI_CONFIG
 25683                                  ;      	call	kbd_read		; we still want to give the guy
 25684                                  ;					; a chance to select clean boot!
 25685                                  ;;endif					; (ie, no autoexec.bat processing)
 25686 00001F27 C606[4903]0B            	mov	byte [multi_pass_id],11	; set it to unreasonable number
 25687 00001F2C C3                      	retn
 25688                                  noprob: 				;get file size (note < 64k!!)
 25689 00001F2D 89C3                    	mov	bx,ax  ; File handle
 25690 00001F2F 31C9                    	xor	cx,cx
 25691 00001F31 31D2                    	xor	dx,dx
 25692                                  	;mov	ax,4202h
 25693 00001F33 B80242                  	mov	ax,(LSEEK<<8)|2
 25694 00001F36 CD21                    	int	21h
 25695 00001F38 A3[D203]                	mov	[count],ax
 25696                                  
 25697 00001F3B 31D2                    	xor	dx,dx
 25698                                  	;mov	ax,4200h
 25699 00001F3D B80042                  	mov	ax,LSEEK<<8		;reset pointer to beginning of file
 25700 00001F40 CD21                    	int	21h
 25701                                  
 25702                                  	;mov	dx,[ALLOCLIM]		;use current alloclim value
 25703                                  	; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 25704 00001F42 8B16[A102]              	mov	dx,[top_of_cdss] 
 25705                                  
 25706 00001F46 A1[D203]                	mov	ax,[count]
 25707 00001F49 A3[4C03]                	mov	[config_size],ax	;save the size of config.sys file.
 25708 00001F4C E86AF1                  	call	ParaRound
 25709 00001F4F 29C2                    	sub	dx,ax
 25710                                  
 25711                                  ; 27/10/2022
 25712                                  ;;ifdef	MULTI_CONFIG
 25713                                  ;;
 25714                                  ;;  The size of the CONFIG.SYS workspace (for recreating the in-memory
 25715                                  ;;  CONFIG.SYS image, and later for building the initial environment) need
 25716                                  ;;  not be any larger than CONFIG.SYS itself, EXCEPT for the fact that
 25717                                  ;;  we (may) add a variable to the environment that does not explicity appear
 25718                                  ;;  in CONFIG.SYS, and that variable is CONFIG (as in CONFIG=COMMON).
 25719                                  ;;  The default setting for CONFIG cannot result in more than 1 paragraph
 25720                                  ;;  of extra space, so here we account for it (the worst case of course is
 25721                                  ;;  when CONFIG.SYS is some very small size, like 0 -JTP)
 25722                                  ;;
 25723                                  ;       dec     dx                      ;reserve 1 additional paragraph
 25724                                  ;       mov     [config_wrkseg],dx      ;this is the segment to be used for
 25725                                  ;       sub     dx,ax                   ;rebuilding the config.sys memory image
 25726                                  ;;endif	;MULTI_CONFIG
 25727                                  
 25728 00001F51 83EA11                  	sub	dx,11h			;room for header
 25729                                  	
 25730                                  	;mov	[ALLOCLIM],dx		;config starts here. new alloclim value.
 25731                                  	;mov	[CONFBOT],dx
 25732                                  	; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 25733 00001F54 8916[A102]              	mov	[top_of_cdss],dx
 25734 00001F58 E874EC                  	call    TempCDS 
 25735                                  	; 11/12/2022
 25736                                  	; ds <> cs 
 25737 00001F5B 2E8B16[A102]            	mov	dx,[cs:top_of_cdss]
 25738                                   
 25739 00001F60 8EDA                    	mov	ds,dx
 25740 00001F62 8EC2                    	mov	es,dx
 25741                                  
 25742 00001F64 31D2                    	xor	dx,dx
 25743 00001F66 2E8B0E[D203]            	mov	cx,[cs:count]
 25744 00001F6B B43F                    	mov	ah,3Fh
 25745                                  	;mov	ah,READ  ; 3Fh
 25746 00001F6D F9                      	stc				;in case of int 24
 25747 00001F6E CD21                    	int	21h			;function request
 25748 00001F70 9C                      	pushf
 25749                                  
 25750                                  ; find the eof mark in the file. if present,then trim length.
 25751                                  
 25752 00001F71 50                      	push	ax
 25753 00001F72 57                      	push	di
 25754 00001F73 51                      	push	cx
 25755 00001F74 B01A                    	mov	al,1Ah			; eof mark
 25756 00001F76 89D7                    	mov	di,dx			; point to buffer
 25757 00001F78 E305                    	jcxz	puteol			; no chars
 25758 00001F7A F2AE                    	repnz	scasb			; find end
 25759 00001F7C 7501                    	jnz	short puteol		; none found and count exhausted
 25760                                  
 25761                                  ; we found a 1a. back up
 25762                                  
 25763 00001F7E 4F                      	dec	di			; backup past 1Ah
 25764                                  
 25765                                  ;  just for the halibut, stick in an extra eol
 25766                                  
 25767                                  puteol:
 25768 00001F7F B00D                    	mov	al,cr ; 0Dh
 25769 00001F81 AA                      	stosb
 25770 00001F82 B00A                    	mov	al,lf  ;0Ah
 25771 00001F84 AA                      	stosb
 25772 00001F85 29D7                    	sub	di,dx			; difference moved
 25773                                  	; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 25774                                  	;mov	[cs:count],di		; new count
 25775                                  
 25776                                  	; 11/12/2022	
 25777                                  	; 31/03/2019 - Retro DOS v4.0
 25778 00001F87 0E                      	push	cs
 25779 00001F88 1F                      	pop	ds
 25780                                  
 25781 00001F89 893E[D203]              	mov	[count],di		; new count
 25782                                  
 25783 00001F8D 59                      	pop	cx
 25784 00001F8E 5F                      	pop	di
 25785 00001F8F 58                      	pop	ax
 25786                                  
 25787                                  	; 11/12/2022
 25788                                  	; 27/10/2022
 25789                                  	;push	cs
 25790                                  	;pop	ds
 25791                                  
 25792 00001F90 50                      	push	ax
 25793                                  	;mov	ah,CLOSE
 25794 00001F91 B43E                    	mov	ah,3Eh
 25795 00001F93 CD21                    	int	21h
 25796 00001F95 58                      	pop	ax
 25797 00001F96 9D                      	popf
 25798 00001F97 7204                    	jc	short conferr 		;if not we've got a problem
 25799 00001F99 39C1                    	cmp	cx,ax
 25800 00001F9B 742C                    	jz	short getcom		;couldn't read the file
 25801                                  conferr:
 25802 00001F9D BA[7034]                	mov	dx,config		;want to print config error
 25803 00001FA0 E8AC13                  	call	badfil
 25804                                  endconv:
 25805 00001FA3 C3                      	retn
 25806                                  
 25807                                  ;----------------------------------------------------------------------------
 25808                                  ;
 25809                                  ; entry : multi_pass
 25810                                  ;
 25811                                  ;             called to execute device=,install= commands
 25812                                  ;
 25813                                  ;----------------------------------------------------------------------------
 25814                                  
 25815                                  	; 27/10/2022
 25816                                  multi_pass:
 25817 00001FA4 0E                      	push	cs
 25818 00001FA5 1F                      	pop	ds
 25819                                  
 25820 00001FA6 803E[4903]0A            	cmp	byte [multi_pass_id],10
 25821                                  ;jae_endconv:
 25822 00001FAB 73F6                    	jae	short endconv 		; do nothing. just return.
 25823                                  
 25824                                  	;push	word [CONFBOT]
 25825                                  	; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 25826 00001FAD FF36[A102]              	push	word [top_of_cdss]
 25827 00001FB1 07                      	pop	es			; es -> confbot
 25828                                  
 25829 00001FB2 8B36[D403]              	mov	si,[org_count]
 25830 00001FB6 8936[D203]              	mov	[count],si		; set count
 25831 00001FBA 31F6                    	xor	si,si ; 0
 25832 00001FBC 8936[D603]                      mov     [chrptr],si		; reset chrptr
 25833 00001FC0 8936[2B03]                      mov     [linecount],si		; reset linecount
 25834                                  
 25835 00001FC4 E86807                  	call	getchr
 25836 00001FC7 EB06                    	jmp	short conflp
 25837                                  
 25838                                  getcom:
 25839 00001FC9 E8B10E                          call    organize                ; organize the file
 25840 00001FCC E86007                  	call	getchr
 25841                                  conflp: 
 25842 00001FCF 72D2                    	jc	short endconv
 25843                                  
 25844 00001FD1 FF06[2B03]                      inc     word [linecount]	; increase linecount
 25845                                  
 25846 00001FD5 C606[2B14]00            	mov	byte [multdeviceflag],0	; reset multdeviceflag.
 25847 00001FDA C606[2E14]00            	mov	byte [setdevmarkflag],0	; reset setdevmarkflag.
 25848 00001FDF 3C0A                    	cmp	al,lf			; linefeed?
 25849 00001FE1 7416                    	je	short blank_line	;  then ignore this line.
 25850                                  
 25851                                  ; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 25852                                  %if 0
 25853                                  
 25854                                  ;ifdef	MULTI_CONFIG
 25855                                  
 25856                                  ;   If this is a genuine CONFIG.SYS command, then there should be a line
 25857                                  ;   number immediately following it....
 25858                                  
 25859                                          mov     [config_cmd],al         ; save original command code
 25860                                  	;and	al,NOT CONFIG_OPTION_QUERY
 25861                                  	and	al,~CONFIG_OPTION_QUERY ; and al,7Fh
 25862                                          cmp     byte [config_multi],0	; is this a multi-config config.sys?
 25863                                          je      short not_final		; no, line number is not embedded
 25864                                  
 25865                                          push    ax                      ;
 25866                                          call    getchr                  ; ignore end-of-image errors,
 25867                                          mov     ah,al                   ; because if there's an error
 25868                                          call    getchr                  ; fetching the line number that's
 25869                                          xchg    al,ah                   ; supposed to be there, the next
 25870                                          mov     [linecount],ax          ; getchr call will get the same error
 25871                                          pop     ax
 25872                                  ;
 25873                                  ;   HACK: when 4DOS.COM is the shell and it doesn't have an environment from
 25874                                  ;   which to obtain its original program name, it grovels through all of
 25875                                  ;   memory to find the filename that was used to exec it; it wants to find
 25876                                  ;   the SHELL= line in the in-memory copy of CONFIG.SYS, and it knows that
 25877                                  ;   sysinit converts the SHELL= keyword to an 'S', so it expects to find an 'S'
 25878                                  ;   immediately before the filename, but since we are now storing line # info
 25879                                  ;   in the config.sys memory image, 4DOS fails to find the 'S' in the right
 25880                                  ;   spot.
 25881                                  ;
 25882                                  ;   So, on the final pass of CONFIG.SYS, copy the command code (eg, 'S')
 25883                                  ;   over the line number info, since we no longer need that info anyway. This
 25884                                  ;   relies on the fact that getchr leaves ES:SI pointing to the last byte
 25885                                  ;   retrieved.
 25886                                  ;
 25887                                          cmp	byte [multi_pass_id],2	; final pass?
 25888                                          jb	short not_final		; no
 25889                                          ;test	word [install_flag],have_install_cmd
 25890                                  	test	byte [install_flag],have_install_cmd ; 1
 25891                                          jz	short final		; no install cmds, so yes it is
 25892                                          cmp	byte [multi_pass_id],3	; final pass?
 25893                                          jb	short not_final		; no
 25894                                  final:                                  ;
 25895                                  	mov	[es:si],al		; save backward-compatible command code
 25896                                  not_final:                              ;
 25897                                  ;endif
 25898                                  
 25899                                  %endif
 25900 00001FE3 88C4                    	mov	ah,al
 25901 00001FE5 E84707                  	call	getchr
 25902 00001FE8 7314                    	jnc	short tryi
 25903                                  
 25904 00001FEA 803E[4903]02            	cmp	byte [multi_pass_id],2
 25905                                  	;jae	short jae_endconv	; do not show badop again for multi_pass.
 25906                                  	; 27/10/2022
 25907 00001FEF 73B2                    	jnb	short endconv	
 25908 00001FF1 E90707                  	jmp	badop
 25909                                  	
 25910                                  coff:	
 25911                                  	; 11/12/2022
 25912                                  	; ds = cs
 25913                                  	;push	cs
 25914                                  	;pop	ds
 25915 00001FF4 E89D10                  	call	newline
 25916 00001FF7 EBD6                    	jmp	short conflp	; 13/05/2019
 25917                                  
 25918                                  blank_line:
 25919 00001FF9 E83307                  	call	getchr
 25920 00001FFC EBD1                    	jmp	short conflp
 25921                                  
 25922                                  	; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 25923                                  ; 11/12/2022
 25924                                  ; (there is not a jump or call to here from anywhere!)
 25925                                  ;coff_p:
 25926                                  	;push	cs
 25927                                  	;pop	ds
 25928                                  
 25929                                  ;to handle install= commands,we are going to use multi-pass.
 25930                                  ;the first pass handles the other commands and only set install_flag when
 25931                                  ;it finds any install command. the second pass will only handle the
 25932                                  ;install= command.
 25933                                  
 25934                                  ;------------------------------------------------------------------------------
 25935                                  ;install command
 25936                                  ;------------------------------------------------------------------------------
 25937                                  
 25938                                  	; 27/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 25939                                  	; (SYSINIT:2250h)
 25940                                  tryi:
 25941 00001FFE 803E[4903]00            	cmp	byte [multi_pass_id],0	; the initial pass for DOS=HI
 25942 00002003 7503                    	jne	short not_init_pass
 25943 00002005 E92301                  	jmp	multi_try_doshi
 25944                                  not_init_pass:
 25945 00002008 803E[4903]02            	cmp	byte [multi_pass_id],2	; the second pass was for ifs=
 25946                                          ; 11/12/2022
 25947                                  	;je	short multi_pass_coff2	; now it is NOPs
 25948 0000200D 74E5                    	je	short coff
 25949                                  	; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 25950                                  	;je	short multi_pass_coff	
 25951                                  					; This pass can be made use of if
 25952                                  					; we want do some config.sys process
 25953                                  					; after device drivers are loaded
 25954                                  					; and before install= commands
 25955                                  					; are processed
 25956                                  
 25957 0000200F 803E[4903]03            	cmp	byte [multi_pass_id],3	; the third pass for install= ?
 25958 00002014 7411                    	je	short multi_try_i
 25959 00002016 80FC48                          cmp     ah, CONFIG_DOS  ; 'H'
 25960                                  	; 11/12/2022
 25961                                  	;je	short multi_pass_coff2
 25962 00002019 74D9                    	je	short coff
 25963                                  	; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 25964                                  	;je	short multi_pass_coff	
 25965                                  
 25966                                  ;       make note of any INSTALL= or INSTALLHIGH= commands we find,
 25967                                  ;       but don't process them now.        
 25968                                          
 25969 0000201B 80FC49                          cmp     ah,CONFIG_INSTALL ; 'I'	; install= command?
 25970                                  	;jne	short precheck_installhigh ; the first pass is for normal operation.
 25971                                  	; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 25972 0000201E 752A                    	jne	short tryb	
 25973                                  	
 25974                                  	;or	word [install_flag],have_install_cmd ; set the flag
 25975 00002020 800E[4A03]01            	or	byte [install_flag],have_install_cmd ; 1
 25976                                  multi_pass_coff2:
 25977 00002025 EBCD                    	jmp	short coff ; 13/05/2019	; and handles the next command
 25978                                  
 25979                                  	; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 25980                                  ;precheck_installhigh:
 25981                                  ;       cmp     ah,CONFIG_INSTALLHIGH ; 'W' ; signifier for INSTALLHIGH
 25982                                  ;       jne     short tryb		; carry on with normal processing
 25983                                  ;	;or	word [install_flag],have_install_cmd
 25984                                  ;	or	byte [install_flag],have_install_cmd ; 1
 25985                                  ;       jmp	short coff
 25986                                  
 25987                                  multi_try_i:
 25988 00002027 80FC49                          cmp     ah, CONFIG_INSTALL ; 'I' ; install= command?
 25989                                  	;jne	short multi_try_n	; no, check for installhigh
 25990                                  	; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 25991 0000202A 7505                    	jne	short multi_pass_filter
 25992                                  
 25993                                  ; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 25994                                  ;;ifdef	MULTI_CONFIG
 25995                                  ;       call    query_user              ; query the user if config_cmd
 25996                                  ;       jc	short multi_pass_filter	; has the CONFIG_OPTION_QUERY bit set
 25997                                  ;;endif
 25998                                  
 25999 0000202C E80AF0                  	call	do_install_exec 	;install it.
 26000 0000202F EBC3                    	jmp	short coff		;to handle next install= command.
 26001                                  
 26002                                  ; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 26003                                  %if 0
 26004                                  
 26005                                  multi_try_n:
 26006                                          cmp     ah,CONFIG_INSTALLHIGH   ; installhigh= command?
 26007                                          jne	short multi_pass_filter	; no. ignore this.
 26008                                  ;ifdef	MULTI_CONFIG
 26009                                          call    query_user              ; query the user if config_cmd
 26010                                          jc      short multi_pass_filter	; has the CONFIG_OPTION_QUERY bit set
 26011                                  ;endif
 26012                                  
 26013                                  ;       The memory environment is in its normal DOS state, so do
 26014                                  ;       the standard calls to set the alloc strategy for loading high
 26015                                  
 26016                                  	mov	ax,(ALLOCOPER<<8)|0 ; 5800h
 26017                                  	int	21h			;get alloc strategy
 26018                                  	mov	bx,ax
 26019                                          push    bx                      ; save for the return
 26020                                  
 26021                                          or	bx,HIGH_FIRST  ; 80h	;set alloc to HighFirst
 26022                                  	mov	ax,(ALLOCOPER<<8)|1 ; 5801h
 26023                                  	int	21h			;set alloc strategy
 26024                                  
 26025                                  	mov     ax,(ALLOCOPER<<8)|2 ; 5802h
 26026                                          int     21h                     ; get link state
 26027                                          xor     ah,ah                   ; clear top byte
 26028                                          push    ax                      ; save for return
 26029                                  
 26030                                          mov	ax,(ALLOCOPER<<8)|3 ; 5803h
 26031                                  	mov	bx,1
 26032                                  	int	21h			;link in UMBs
 26033                                  
 26034                                  	call	do_install_exec 	;install it.
 26035                                  
 26036                                          mov     ax,(ALLOCOPER<<8)|3
 26037                                          pop     bx                      ; recover original link state
 26038                                          int     21h
 26039                                          pop     bx                      ; recover original alloc strategy
 26040                                          mov     ax,(ALLOCOPER<<8)|1
 26041                                          int     21h
 26042                                  
 26043                                  	jmp	coff			;to handle next install= command.
 26044                                  
 26045                                  %endif
 26046                                  
 26047                                  multi_pass_filter:
 26048 00002031 80FC59                          cmp     ah,CONFIG_COMMENT ; 'Y' ; comment?
 26049 00002034 740A                    	je	short multi_pass_adjust
 26050 00002036 80FC5A                          cmp     ah,CONFIG_UNKNOWN ; 'Z' ; bad command?
 26051 00002039 7405                    	je	short multi_pass_adjust
 26052 0000203B 80FC30                          cmp     ah,CONFIG_REM  ; '0' 	; rem?
 26053 0000203E 7508                    	jne	short multi_pass_coff 	; ignore the rest of the commands.
 26054                                  
 26055                                  multi_pass_adjust:			; these commands need to
 26056 00002040 FF0E[D603]              	dec	word [chrptr]		;  adjust chrptr,count
 26057 00002044 FF06[D203]              	inc	word [count]		;  for newline proc.
 26058                                  
 26059                                  multi_pass_coff:
 26060                                  	; 11/12/2022
 26061 00002048 EBAA                    	jmp	short coff		; to handle next install= commands.
 26062                                  
 26063                                  ;------------------------------------------------------------------------------
 26064                                  ; buffer command
 26065                                  ;------------------------------------------------------------------------------
 26066                                  
 26067                                  ;******************************************************************************
 26068                                  ;									      *
 26069                                  ; function: parse the parameters of buffers= command.			      *
 26070                                  ;									      *
 26071                                  ; input :								      *
 26072                                  ;	es:si -> parameters in command line.				      *
 26073                                  ; output:								      *
 26074                                  ;	buffers set							      *
 26075                                  ;	buffer_slash_x	flag set if /x option chosen.			      *
 26076                                  ;	h_buffers set if secondary buffer cache specified.		      *
 26077                                  ;									      *
 26078                                  ; subroutines to be called:						      *
 26079                                  ;	sysinit_parse							      *
 26080                                  ; logic:								      *
 26081                                  ; {									      *
 26082                                  ;	set di points to buf_parms;  /*parse control definition*/	      *
 26083                                  ;	set dx,cx to 0; 						      *
 26084                                  ;	reset buffer_slash_x;						      *
 26085                                  ;	while (end of command line)					      *
 26086                                  ;	{ sysinit_parse;						      *
 26087                                  ;	  if (no error) then						      *
 26088                                  ;	       if (result_val._$P_synonym_ptr == slash_e) then /*not a switch *
 26089                                  ;		    buffer_slash_x = 1					      *
 26090                                  ;	       else if	 (cx == 1) then 	    /* first positional */    *
 26091                                  ;			  buffers = result_val._$P_picked_val;		      *
 26092                                  ;		    else  h_buffers = result_val._$P_picked_val; 	      *
 26093                                  ;	  else	{show error message;error exit} 			      *
 26094                                  ;	};								      *
 26095                                  ;	if (buffer_slash_x is off & buffers > 99) then show_error;	      *
 26096                                  ; };									      *
 26097                                  ;									      *
 26098                                  ;******************************************************************************
 26099                                  
 26100                                  	; 27/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 26101                                  	; (SYSINIT:229Ch)
 26102                                  tryb:
 26103 0000204A 80FC42                          cmp     ah,CONFIG_BUFFERS ; 'B'
 26104 0000204D 7557                    	jne	short tryc
 26105                                  
 26106                                  ; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 26107                                  ;;ifdef	MULTI_CONFIG
 26108                                  ;       call    query_user              ; query the user if config_cmd
 26109                                  ;       jc      short tryc		; has the CONFIG_OPTION_QUERY bit set
 26110                                  ;;endif
 26111                                  
 26112                                  	; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 26113                                  	; 18/12/2022
 26114 0000204F 31C9                    	xor	cx,cx
 26115                                  	;mov	byte [p_buffer_slash_x],0 ; 31/03/2019
 26116 00002051 880E[421D]              	mov	[p_buffer_slash_x],cl ; 0
 26117                                  
 26118 00002055 BF[FB1C]                	mov	di,buf_parms
 26119                                  	;xor	cx,cx	; 18/12/2022
 26120                                  	; 04/01/2023
 26121                                  	;mov	dx,cx
 26122                                  do7:
 26123 00002058 E87D06                  	call	sysinit_parse
 26124 0000205B 7303                    	jnc	short if7		; parse error,
 26125                                  	; 04/01/2023
 26126                                  	;call	badparm_p		;  and show messages and end the search loop.
 26127                                  	;;jmp	short sr7
 26128                                  	; 31/12/2022
 26129                                  ;sr7:
 26130                                  	;jmp	coff
 26131                                  	; 04/01/2023
 26132 0000205D E9F605                  	jmp	badparm_p_coff
 26133                                  if7:
 26134 00002060 83F8FF                  	cmp	ax,_$P_RC_EOL ; 0FFFFh	; end of line?
 26135 00002063 741A                    	je	short en7		;  then jmp to $endloop for semantic check
 26136                                  	;cmp	word [result_val_swoff],switch_x
 26137 00002065 813E[461D][3B1D]        	cmp	word [result_val+_$P_Result_Blk.SYNONYM_Ptr],switch_x
 26138                                  	;jne	short if11
 26139                                  	; 31/12/2022
 26140 0000206B 74EB                    	je	short do7 ;je short en11
 26141                                  
 26142                                  ;	mov	byte [p_buffer_slash_x],1 ; set the flag M016
 26143                                  	;jmp	short en11 ; 31/12/2022
 26144                                  if11:
 26145                                  	;mov	ax,[rv_dword]
 26146 0000206D A1[481D]                	mov	ax,[result_val+_$P_Result_Blk.Picked_Val]
 26147 00002070 83F901                  	cmp	cx,1
 26148 00002073 7505                    	jne	short if13
 26149                                  
 26150 00002075 A3[3E1D]                	mov	[p_buffers],ax
 26151                                  	;jmp	short en11
 26152                                  	; 31/12/2022
 26153 00002078 EBDE                    	jmp	short do7
 26154                                  if13:
 26155 0000207A A3[401D]                	mov	[p_h_buffers],ax
 26156                                  en11:
 26157 0000207D EBD9                    	jmp	short do7
 26158                                  en7:
 26159 0000207F 833E[3E1D]63            	cmp	word [p_buffers],99
 26160 00002084 760B                    	jbe	short if18
 26161                                  
 26162                                  ;	cmp	byte [p_buffer_slash_x],0 ; M016
 26163                                  ;	jne	short if18
 26164                                  
 26165 00002086 E87E06                  	call	badparm_p
 26166 00002089 C706[401D]0000          	mov	word [p_h_buffers],0
 26167 0000208F EB12                    	jmp	short sr7
 26168                                  if18:
 26169 00002091 A1[3E1D]                	mov	ax,[p_buffers]	; we don't have any problem.
 26170 00002094 A3[9702]                	mov	[buffers],ax	; now,let's set it really.
 26171                                  
 26172 00002097 A1[401D]                	mov	ax,[p_h_buffers]
 26173 0000209A A3[9902]                	mov	[h_buffers],ax
 26174                                  
 26175                                  ;	mov	al,[p_buffer_slash_x]	; M016
 26176                                  ;	mov	[buffer_slash_x],al
 26177                                  
 26178 0000209D A1[2B03]                	mov	ax,[linecount]
 26179 000020A0 A3[3503]                	mov	[buffer_linenum],ax ; save the line number for the future use.
 26180                                  	; 31/12/2022
 26181                                  	;jmp	short sr7
 26182                                  	; 04/01/2023
 26183                                  sr7:
 26184 000020A3 E94EFF                  	jmp	coff
 26185                                  
 26186                                  ;------------------------------------------------------------------------------
 26187                                  ; break command
 26188                                  ;------------------------------------------------------------------------------
 26189                                  
 26190                                  ;****************************************************************************
 26191                                  ;									    *
 26192                                  ; function: parse the parameters of break = command.			    *
 26193                                  ;									    *
 26194                                  ; input :								    *
 26195                                  ;	es:si -> parameters in command line.				    *
 26196                                  ; output:								    *
 26197                                  ;	turn the control-c check on or off.				    *
 26198                                  ;									    *
 26199                                  ; subroutines to be called:						    *
 26200                                  ;	sysinit_parse							    *
 26201                                  ; logic:								    *
 26202                                  ; {									    *
 26203                                  ;	set di to brk_parms;						    *
 26204                                  ;	set dx,cx to 0; 						    *
 26205                                  ;	while (end of command line)					    *
 26206                                  ;	{ sysinit_parse;						    *
 26207                                  ;	  if (no error) then						    *
 26208                                  ;	       if (result_val._$P_item_tag == 1) then	  /*on		 */ *
 26209                                  ;		   set p_ctrl_break,on;					    *
 26210                                  ;	       else					  /*off 	 */ *
 26211                                  ;		   set p_ctrl_break,off;				    *
 26212                                  ;	  else {show message;error_exit};				    *
 26213                                  ;	};								    *
 26214                                  ;	if (no error) then						    *
 26215                                  ;	   dos function call to set ctrl_break check according to	    *
 26216                                  ; };									    *
 26217                                  ;									    *
 26218                                  ;****************************************************************************
 26219                                  
 26220                                  	; 27/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 26221                                  	; (SYSINIT:22FFh)
 26222                                  tryc:
 26223 000020A6 80FC43                          cmp     ah,CONFIG_BREAK ; 'C'
 26224 000020A9 7534                    	jne	short trym
 26225                                  
 26226                                  ; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 26227                                  ;;ifdef MULTI_CONFIG
 26228                                  ;       call    query_user              ; query the user if config_cmd
 26229                                  ;       jc	short trym		; has the CONFIG_OPTION_QUERY bit set
 26230                                  ;;endif
 26231 000020AB BF[4C1D]                	mov	di,brk_parms
 26232 000020AE 31C9                    	xor	cx,cx
 26233                                  	; 04/01/2023
 26234                                  	;mov	dx,cx
 26235                                  do22:
 26236 000020B0 E82506                  	call	sysinit_parse
 26237 000020B3 7303                    	jnc	short if22		; parse error
 26238                                  	;call	badparm_p		;  show message and end the search loop.
 26239                                  	;;jmp	short sr22
 26240                                  	; 31/12/2022
 26241                                  ;sr22:
 26242                                  	;jmp	coff
 26243                                  	; 04/01/2023
 26244 000020B5 E99E05                  	jmp	badparm_p_coff
 26245                                  if22:
 26246 000020B8 83F8FF                  	cmp	ax,_$P_RC_EOL		; end of line?
 26247 000020BB 7415                    	je	short en22		; then end the $endloop
 26248                                  
 26249                                  	;cmp	byte [result_val_itag],1
 26250 000020BD 803E[451D]01            	cmp	byte [result_val+_$P_Result_Blk.Item_Tag],1
 26251 000020C2 7507                    	jne	short if26
 26252                                  
 26253 000020C4 C606[711D]01            	mov	byte [p_ctrl_break],1	; turn it on
 26254                                  	;jmp	short en26
 26255                                  	; 31/12/2022
 26256 000020C9 EBE5                    	jmp	short do22
 26257                                  if26:
 26258 000020CB C606[711D]00            	mov	byte [p_ctrl_break],0	; turn it off
 26259                                  en26:
 26260 000020D0 EBDE                    	jmp	short do22		; we actually set the ctrl break
 26261                                  en22:
 26262 000020D2 B433                    	mov	ah,SET_CTRL_C_TRAPPING ; if we don't have any parse error.
 26263 000020D4 B001                    	mov	al,1
 26264 000020D6 8A16[711D]              	mov	dl,[p_ctrl_break]
 26265 000020DA CD21                    	int	21h
 26266                                  	; 31/12/2022
 26267                                  	;jmp	short sr22
 26268                                  	; 04/01/2023
 26269                                  sr22:
 26270 000020DC E915FF                  	jmp	coff
 26271                                  
 26272                                  ;------------------------------------------------------------------------------
 26273                                  ; multitrack command
 26274                                  ;------------------------------------------------------------------------------
 26275                                  
 26276                                  ;******************************************************************************
 26277                                  ;									      *
 26278                                  ; function: parse the parameters of multitrack= command.		      *
 26279                                  ;									      *
 26280                                  ; input :								      *
 26281                                  ;	es:si -> parameters in command line.				      *
 26282                                  ; output:								      *
 26283                                  ;	turn multrk_flag on or off.					      *
 26284                                  ;									      *
 26285                                  ; subroutines to be called:						      *
 26286                                  ;	sysinit_parse							      *
 26287                                  ; logic:								      *
 26288                                  ; {									      *
 26289                                  ;	set di to brk_parms;						      *
 26290                                  ;	set dx,cx to 0; 						      *
 26291                                  ;	while (end of command line)					      *
 26292                                  ;	{ sysinit_parse;						      *
 26293                                  ;	  if (no error) then						      *
 26294                                  ;	       if (result_val._$P_item_tag == 1) then	  /*on		 */   *
 26295                                  ;		   set p_mtrk,on;					      *
 26296                                  ;	       else					  /*off 	 */   *
 26297                                  ;		   set p_mtrk,off;					      *
 26298                                  ;	  else {show message;error_exit};				      *
 26299                                  ;	};								      *
 26300                                  ;	if (no error) then						      *
 26301                                  ;	   dos function call to set multrk_flag according to p_mtrk.	      *
 26302                                  ;									      *
 26303                                  ; };									      *
 26304                                  ;									      *
 26305                                  ;******************************************************************************
 26306                                  
 26307                                  	; 27/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 26308                                  trym:
 26309 000020DF 80FC4D                          cmp     ah,CONFIG_MULTITRACK  ; 'M'
 26310 000020E2 7569                    	jne	short tryu
 26311                                  
 26312                                  ; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 26313                                  ;;ifdef	MULTI_CONFIG
 26314                                  ;       call    query_user      ; query the user if config_cmd
 26315                                  ;       jc      short tryu	; has the CONFIG_OPTION_QUERY bit set
 26316                                  ;;endif
 26317 000020E4 BF[501E]                	mov	di,mtrk_parms
 26318 000020E7 31C9                    	xor	cx,cx
 26319                                  	; 04/01/2023
 26320                                  	;mov	dx,cx
 26321                                  do31:
 26322 000020E9 E8EC05                  	call	sysinit_parse
 26323 000020EC 7303                    	jnc	short if31	; parse error
 26324                                  	;call	badparm_p	;  show message and end the search loop.
 26325                                  	;;jmp	short sr31
 26326                                  	; 31/12/2022
 26327                                  ;sr31:
 26328                                  	;jmp	coff
 26329                                  	; 04/01/2023
 26330 000020EE E96505                  	jmp	badparm_p_coff
 26331                                  if31:
 26332 000020F1 83F8FF                  	cmp	ax,_$P_RC_EOL	; end of line?
 26333 000020F4 7415                    	je	short en31	; then end the $endloop
 26334                                  
 26335                                  	;cmp	byte [result_val_itag],1
 26336 000020F6 803E[451D]01            	cmp	byte [result_val+_$P_Result_Blk.Item_Tag],1
 26337 000020FB 7507                    	jne	short if35
 26338                                  
 26339 000020FD C606[641E]01            	mov	byte [p_mtrk],1	; turn it on temporarily.
 26340                                  	;jmp	short en35
 26341                                  	; 31/12/2022
 26342 00002102 EBE5                    	jmp	short do31
 26343                                  if35:
 26344 00002104 C606[641E]00            	mov	byte [p_mtrk],0	; turn it off temporarily.
 26345                                  en35:
 26346 00002109 EBDE                    	jmp	short do31	; we actually set the multrk_flag here
 26347                                  en31:
 26348 0000210B 1E                      	push	ds
 26349                                  	;;mov	ax,Bios_Data ; 70h
 26350                                  	;mov	ax,KERNEL_SEGMENT ; 70h
 26351                                  	; 21/10/2022
 26352 0000210C B87000                  	mov	ax,DOSBIODATASEG ; 0070h
 26353 0000210F 8ED8                    	mov	ds,ax
 26354                                  
 26355 00002111 2E803E[641E]00          	cmp	byte [cs:p_mtrk],0
 26356 00002117 7508                    	jne	short if39
 26357                                  
 26358 00002119 C706[2F05]0100          	mov	word [multrk_flag],multrk_off2	; 0001h
 26359 0000211F EB06                    	jmp	short en39
 26360                                  if39:
 26361 00002121 C706[2F05]8000          	mov	word [multrk_flag],multrk_on	; 0080h
 26362                                  en39:
 26363 00002127 1F                      	pop	ds
 26364                                  	; 31/12/2022
 26365                                  	;jmp	short sr31
 26366                                  	; 04/01/2023
 26367                                  sr31:
 26368 00002128 E9C9FE                  	jmp	coff
 26369                                  
 26370                                  ;----------------------------------------------------------------------------
 26371                                  ; DOS=HIGH/LOW command
 26372                                  ;----------------------------------------------------------------------------
 26373                                  
 26374                                  	; 27/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 26375                                  multi_try_doshi:
 26376 0000212B 80FC48                          cmp     ah,CONFIG_DOS ; 'H'
 26377 0000212E 7403                    	je	short it_is_h
 26378                                  skip_it:
 26379 00002130 E9FEFE                  	jmp	multi_pass_filter
 26380                                  it_is_h:				; M003 - removed initing DevUMB
 26381                                  					;	 & runhigh
 26382                                  ; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 26383                                  ;;ifdef	MULTI_CONFIG
 26384                                  ;       call    query_user              ; query the user if config_cmd
 26385                                  ;       jc      short skip_it		; has the CONFIG_OPTION_QUERY bit set
 26386                                  ;;endif
 26387 00002133 BF[9B1E]                	mov	di,dos_parms
 26388 00002136 31C9                    	xor	cx,cx
 26389                                  	; 04/01/2023
 26390                                  	;mov	dx,cx
 26391                                  h_do_parse:
 26392 00002138 E89D05                  	call	sysinit_parse
 26393 0000213B 7303                    	jnc	short h_parse_ok	; parse error
 26394                                  h_badparm:
 26395                                  	; 04/01/2023
 26396                                  	;call	badparm_p		; show message and end the search loop.
 26397                                  	;;jmp	short h_end
 26398                                  	; 11/12/2022
 26399                                  ;h_end:
 26400                                  	;jmp	coff
 26401                                  	; 04/01/2023
 26402 0000213D E91605                  	jmp	badparm_p_coff	
 26403                                  h_parse_ok:
 26404 00002140 83F8FF                  	cmp	ax,_$P_RC_EOL		; end of line?
 26405 00002143 7405                    	je	short h_end		; then end the $endloop
 26406 00002145 E82D06                  	call	ProcDOS
 26407 00002148 EBEE                    	jmp	short h_do_parse
 26408                                  	; 11/12/2022
 26409                                  	; 04/01/2023
 26410                                  h_end:
 26411 0000214A E9A7FE                  	jmp	coff
 26412                                  
 26413                                  ;-----------------------------------------------------------------------------
 26414                                  ; devicehigh command
 26415                                  ;-----------------------------------------------------------------------------
 26416                                  
 26417                                  	; 28/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 26418                                  tryu:
 26419 0000214D 80FC55                          cmp     ah,CONFIG_DEVICEHIGH ; 'U'
 26420 00002150 7539                    	jne	short tryd
 26421                                  
 26422                                  ; 28/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 26423                                  ;;ifdef	MULTI_CONFIG
 26424                                  ;       call    query_user              ; query the user if config_cmd
 26425                                  ;       jc	short tryd		; has the CONFIG_OPTION_QUERY bit set
 26426                                  ;;endif
 26427                                  
 26428                                  ; 28/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 26429                                  ;	call	InitVar
 26430                                  ;	call	ParseSize		; process the size= option
 26431                                  ;	;jnc	short tryu_0
 26432                                  	
 26433                                  	;jc	short tryu_1 ; 31/03/2019 - Retro DOS v4.0
 26434                                  
 26435                                  	; 28/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 26436                                  	;mov	[cs:badparm_off], si	; stash it there in case of an error
 26437                                  	;mov	[cs:badparm_seg], es
 26438                                  	; 11/12/2022
 26439                                  	; ds = cs
 26440 00002152 8936[2F14]              	mov	[badparm_off], si
 26441 00002156 8C06[3114]              	mov	[badparm_seg], es
 26442                                  	;
 26443 0000215A E88A08                  	call	ParseSize
 26444 0000215D 7303                    	jnc	short tryu_2	; 28/10/2022
 26445                                  
 26446                                  	;call	badparm_p
 26447                                  	;jmp	coff
 26448                                  	; 04/01/2023
 26449 0000215F E9F404                  	jmp	badparm_p_coff
 26450                                  
 26451                                  ; 28/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 26452                                  ;tryu_0:
 26453                                  ;	mov	ax,[cs:DevSizeOption]
 26454                                  ;	or	ax,ax
 26455                                  ;	jnz	short tryu_2
 26456                                  ;
 26457                                  ;	call	ParseVar
 26458                                  ;	jnc	short tryu_2
 26459                                  ;tryu_1:
 26460                                  ;	mov	[cs:badparm_off], si	; If ParseVar up there failed, then
 26461                                  ;	mov	[cs:badparm_seg], es	; ES:SI points to its problem area...
 26462                                  ;	call	badparm_p		; so all we have to do is choke and
 26463                                  ;	jmp	coff			; die, rather verbosely.
 26464                                  
 26465                                  tryu_2:	
 26466 00002162 56                      	push	si
 26467 00002163 06                      	push	es
 26468                                  tryu_3:
 26469 00002164 268A04                  	mov	al,[es:si]
 26470 00002167 3C0D                    	cmp	al,cr
 26471 00002169 740C                    	je	short tryu_4
 26472 0000216B 3C0A                    	cmp	al,lf
 26473 0000216D 7408                    	je	short tryu_4
 26474 0000216F E8070F                  	call	delim
 26475 00002172 7403                    	jz	short tryu_4
 26476 00002174 46                      	inc	si
 26477 00002175 EBED                    	jmp	short tryu_3
 26478                                  tryu_4:	
 26479                                  	; 11/12/2022
 26480                                  	; ds = cs
 26481 00002177 A2[101F]                	mov	[DevSavedDelim],al
 26482                                  	;mov	[cs:DevSavedDelim],al	; Save the delimiter before replacing
 26483                                  					;  it with null
 26484                                  	; 18/12/2022
 26485 0000217A 29DB                    	sub	bx,bx
 26486 0000217C 26881C                  	mov	[es:si],bl ; 0
 26487                                   	;mov	byte [es:si],0
 26488                                  
 26489 0000217F 07                      	pop	es
 26490 00002180 5E                      	pop	si
 26491                                  
 26492                                  ;------------------------------------------------------------------------------
 26493                                  ; BEGIN PATCH TO CHECK FOR NON-EXISTANT UMBs   -- t-richj 7-21-92
 26494                                  ;------------------------------------------------------------------------------
 26495                                  
 26496                                  ; 28/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 26497                                  ;
 26498                                  ;	call	UmbTest			; See if UMBs are around...
 26499                                  ;	jnc	short NrmTst		; ...yep. So do that normal thang.
 26500                                  ;
 26501                                  ;	mov	byte [cs:DeviceHi],0	; ...nope... so load low.
 26502                                  ;	jmp	short LoadDevice
 26503                                  
 26504                                  ;------------------------------------------------------------------------------
 26505                                  ; END PATCH TO CHECK FOR NON-EXISTANT UMBs   -- t-richj 7-21-92
 26506                                  ;------------------------------------------------------------------------------
 26507                                  
 26508                                  NrmTst:
 26509                                  	; 11/12/2022
 26510                                  	; ds = cs
 26511                                  	;;mov	byte [cs:DeviceHi],0
 26512                                  	;mov	byte [DeviceHi],0
 26513                                  	; 18/12/2022
 26514                                  	; bx = 0
 26515 00002181 381E[EC1E]              	cmp	[DevUMB],bl ; 0
 26516                                  	;cmp	byte [DevUMB],0
 26517                                  	;;cmp	byte [cs:DevUMB],0	; do we support UMBs
 26518 00002185 7417                    	je	short LoadDevice	; no, we don't
 26519                                  	;mov	byte [cs:DeviceHi],1
 26520                                  	; 11/12/2022
 26521                                  	;mov	byte [DeviceHi],1
 26522                                  	; 18/12/2022
 26523 00002187 FEC3                    	inc	bl ; mov bl,1 ; (*)
 26524                                  	; 11/12/2022
 26525                                  	;jmp	short LoadDevice2	; 11/12/2022
 26526 00002189 EB13                    	jmp	short LoadDevice
 26527                                  
 26528                                  ;------------------------------------------------------------------------------
 26529                                  ; device command
 26530                                  ;------------------------------------------------------------------------------
 26531                                  
 26532                                  	; 28/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 26533                                  	; (SYSINIT:2401h)
 26534                                  tryd:
 26535                                  	; 11/12/2022
 26536 0000218B 31DB                    	xor 	bx, bx
 26537                                  	;
 26538 0000218D 80FC44                          cmp     ah,CONFIG_DEVICE ;  'D'
 26539 00002190 7403                    	je	short gotd
 26540                                  skip_it2:
 26541 00002192 E93502                  	jmp	tryq
 26542                                  gotd:
 26543                                  
 26544                                  ; 28/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 26545                                  ;;ifdef	MULTI_CONFIG
 26546                                  ;       call    query_user              ; query the user if config_cmd
 26547                                  ;       jc	short skip_it2		; has the CONFIG_OPTION_QUERY bit set
 26548                                  ;;endif
 26549                                  	; 11/12/2022
 26550                                  	; ds = cs
 26551                                  	;mov	byte [DeviceHi],0
 26552                                  	;mov	word [DevSizeOption],0
 26553 00002195 891E[FC1E]              	mov	[DevSizeOption],bx ; 0
 26554 00002199 C606[101F]20            	mov	byte [DevSavedDelim],' '
 26555                                  	;mov	byte [cs:DeviceHi],0	; not to be loaded in UMB ;M007
 26556                                  	;mov	word [cs:DevSizeOption],0
 26557                                  	;mov	byte [cs:DevSavedDelim],' ' ; In case of DEVICE= the null has to
 26558                                  					;  be replaced with a ' '
 26559                                  LoadDevice:                             ; device= or devicehigh= command.
 26560                                  	; 11/12/2022
 26561                                  	;mov	byte [DeviceHi],0
 26562 0000219E 881E[FB1E]              	mov	byte [DeviceHi],bl	; 0 or 1 (*)
 26563                                  LoadDevice2:
 26564                                  	; 28/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)        
 26565                                  	;
 26566                                  	;push    cs
 26567                                          ;pop     ds
 26568                                  	;
 26569                                  	;mov	[bpb_addr],si		; pass the command line to the dvice
 26570                                  	;mov	[bpb_addr+2],es
 26571                                  	;
 26572                                  	;mov	[DevCmdLine],si		; save it for ourself
 26573                                  	;mov	[DevCmdLine+2],es
 26574                                  	;
 26575                                  	;mov	byte [driver_units],0	; clear total block units for driver	
 26576                                  
 26577                                  	; 11/12/2022
 26578                                  	; ds = cs
 26579                                  	;mov	bx,cs
 26580                                  	;mov	ds,bx
 26581                                  
 26582                                  	;mov	[cs:bpb_addr],si	; pass the command line to the dvice
 26583 000021A2 8936[F803]              	mov	[bpb_addr],si
 26584                                  	;mov	[cs:bpb_addr+2],es
 26585 000021A6 8C06[FA03]              	mov	[bpb_addr+2],es
 26586                                  
 26587                                  	;mov	[cs:DevCmdLine],si	; save it for ourself
 26588 000021AA 8936[0C1F]              	mov	[DevCmdLine],si
 26589                                  	;mov	[cs:DevCmdLine+2],es	
 26590 000021AE 8C06[0E1F]              	mov	[DevCmdLine+2],es	
 26591                                  
 26592 000021B2 E8070F                  	call	round
 26593                                  	
 26594 000021B5 E83F07                  	call	SizeDevice
 26595 000021B8 7215                    	jc	short BadFile
 26596                                  
 26597                                  	; 11/12/2022
 26598                                  	; ds = cs
 26599                                  
 26600                                  ; - Begin DeviceHigh primary logic changes ------------------------------------
 26601                                  
 26602                                  ; 28/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 26603                                  ;
 26604                                  ;	mov	byte [ConvLoad],1	; Doesn't matter if DeviceHi==0
 26605                                  ;
 26606                                  ;	mov	al,[DeviceHi]		; If not using upper memory,
 26607                                  ;	or	byte [DeviceHi],0	; Skip all this and go on to
 26608                                  ;	jz	short DevConvLoad	; the actual load.
 26609                                  ;
 26610                                  ;	;call	GetLoadUMB		; Returns first UMB spec'ed in AX
 26611                                  ;	mov	al,[UmbLoad]	; 19/04/2019 - Retro DOS v4.0
 26612                                  ;
 26613                                  ;	cmp	al,-1			; If umb0 not specified, it's old style
 26614                                  ;	jz	short DevConvLoad	; so load high even if SIZE= is smaller
 26615                                  ;
 26616                                  ;	dec	byte [ConvLoad] ; 0 	; They specified /L, so use new loader
 26617                                  ;
 26618                                  ;	call	GetLoadSize		; Returns size of first UMB specified
 26619                                  ;	or	ax,ax
 26620                                  ;	jz	short tryd_1		; If size1 not specified, nada to do:
 26621                                  ;
 26622                                  ;	cmp	ax,[DevSize]		; /L:...,Size < DevSize?
 26623                                  ;	jge	short DevConvLoad
 26624                                  ;
 26625                                  ;tryd_1: mov	ax,[DevSize]		; Size < DevSize, so write DevSize as
 26626                                  ;	call	StoLoadSize		; minsize for load UMB.
 26627                                  
 26628                                  ; - End DeviceHigh primary logic changes --------------------------------------
 26629                                  
 26630                                  DevConvLoad:
 26631                                  	; 28/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 26632 000021BA E84F06                  	call	InitDevLoad
 26633                                  
 26634                                  	; 11/12/2022
 26635                                  	; ds = cs
 26636 000021BD A1[E01E]                	mov	ax,[DevLoadAddr]
 26637 000021C0 0306[DE1E]              	add	ax,[DevSize]
 26638 000021C4 7206                    	jc	short NoMem
 26639 000021C6 3906[E21E]              	cmp	[DevLoadEnd],ax
 26640 000021CA 7312                    	jae	short LoadDev
 26641                                  	
 26642                                  	; 11/12/2022
 26643                                  	;mov	ax,[cs:DevLoadAddr]
 26644                                  	;add	ax,[cs:DevSize]
 26645                                  	;jc	short NoMem
 26646                                  	;cmp	[cs:DevLoadEnd],ax
 26647                                  	;jae	short LoadDev
 26648                                  NoMem:
 26649                                  	; 11/12/2022
 26650                                  	; ds = cs
 26651                                  	;jmp	mem_err
 26652 000021CC E9300F                  	jmp	mem_err2
 26653                                  
 26654                                  BadFile:
 26655                                  	;28/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 26656                                  	;call	RetFromUM		; Does nothing if didn't call HideUMBs
 26657                                  	;cmp    byte [es:si],' '
 26658                                          ;jae	short tryd_2
 26659 000021CF 26803C0D                	cmp	byte [es:si],0Dh	; cr
 26660 000021D3 7503                            jne	short tryd_2
 26661 000021D5 E92305                  	jmp	badop
 26662                                  tryd_2:
 26663 000021D8 E87811                  	call	badload
 26664 000021DB E916FE                  	jmp	coff
 26665                                  
 26666                                  LoadDev:
 26667 000021DE 06                      	push	es
 26668 000021DF 1F                      	pop	ds
 26669                                  
 26670 000021E0 89F2                    	mov	dx,si			;ds:dx points to file name
 26671 000021E2 E86307                  	call	ExecDev			; load device driver using exec call
 26672                                  badldreset:
 26673 000021E5 1E                      	push	ds
 26674 000021E6 07                      	pop	es			;es:si back to config.sys
 26675 000021E7 0E                      	push	cs
 26676 000021E8 1F                      	pop	ds			;ds back to sysinit
 26677 000021E9 72E4                    	jc	short BadFile
 26678                                  goodld:
 26679                                  	; 11/12/2022
 26680                                  	; ds = cs
 26681                                  
 26682 000021EB 06                      	push	es
 26683 000021EC 56                      	push	si
 26684 000021ED E87507                  	call	RemoveNull
 26685 000021F0 06                      	push	es
 26686 000021F1 56                      	push	si
 26687                                  
 26688 000021F2 0E                      	push	cs
 26689 000021F3 07                      	pop	es
 26690                                  
 26691 000021F4 1E                      	push	ds
 26692 000021F5 56                      	push	si
 26693                                  
 26694                                  	;lds	si,[cs:DevEntry]	; peeks the header attribute
 26695                                  	; 31/12/2022
 26696                                  	; ds = cs
 26697 000021F6 C536[E41E]              	lds	si,[DevEntry]
 26698                                  	
 26699                                  	;test	word [si+4],8000h
 26700                                  	; 11/12/2022
 26701 000021FA F6440580                	test	byte [si+SYSDEV.ATT+1],DEVTYP>>8
 26702                                  	;test	word [si+SYSDEV.ATT],DEVTYP ; block device driver?
 26703 000021FE 7511                    	jnz	short got_device_com_cont   ; no.
 26704                                  
 26705 00002200 2EC536[6B02]            	lds	si,[cs:DOSINFO]		; ds:si -> sys_var
 26706                                  	;cmp	byte [si+32],26
 26707 00002205 807C201A                	cmp	byte [si+SYSI_NUMIO],26	; no more than 26 drive number
 26708 00002209 7206                    	jb	short got_device_com_cont
 26709                                  
 26710 0000220B 5E                      	pop	si
 26711 0000220C 1F                      	pop	ds
 26712                                  
 26713 0000220D 5E                      	pop	si			; clear the stack
 26714 0000220E 07                      	pop	es
 26715                                  
 26716                                  	; 28/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 26717                                  	;call	RetFromUM		; Do this before we leave
 26718                                  
 26719 0000220F EB57                    	jmp	short badnumblock
 26720                                  
 26721                                  got_device_com_cont:
 26722 00002211 5E                      	pop	si
 26723 00002212 1F                      	pop	ds
 26724                                  
 26725                                  	; 11/12/2022
 26726                                  	; ds = cs
 26727                                  
 26728 00002213 E88205                  	call	LieInt12Mem
 26729 00002216 E8E105                  	call	UpdatePDB		; update the PSP:2 value M020
 26730                                  
 26731                                  	; 11/12/2022
 26732                                  	; ds = cs
 26733 00002219 803E[2B14]00            	cmp	byte [multdeviceflag],0
 26734                                  	;cmp	byte [cs:multdeviceflag],0 ; Pass limit only for the 1st device
 26735                                  					;  driver in the file ; M027
 26736 0000221E 750E                    	jne	short skip_pass_limit	;		      ; M027
 26737                                  
 26738                                  	; 11/12/2022
 26739                                  	; ds = cs
 26740                                  	;mov	word [cs:break_addr],0	; pass the limit to the DD
 26741                                  	;mov	bx,[cs:DevLoadEnd]
 26742                                  	;mov	[cs:break_addr+2],bx
 26743                                  
 26744 00002220 C706[F403]0000          	mov	word [break_addr],0
 26745 00002226 8B1E[E21E]              	mov	bx,[DevLoadEnd]
 26746 0000222A 891E[F603]              	mov	[break_addr+2],bx
 26747                                  
 26748                                  skip_pass_limit:
 26749                                  ;	Note: sysi_numio (in DOS DATA) currently reflects the REAL
 26750                                  ;	number of installed devices (including DblSpace drives) where
 26751                                  ;	"drivenumber" is the number that the next block device will
 26752                                  ;	be assigned to. Because some naughty device drivers (like
 26753                                  ;	interlnk) look at the internal DOS variable instead of the
 26754                                  ;	value we pass it, we'll temporarily stick our value into
 26755                                  ;	DOS DATA while we're initializing the device drivers.
 26756                                  ;
 26757                                  ;	Note that this will make it impossible for this device
 26758                                  ;	driver to access the DblSpace drive letters, whether
 26759                                  ;	they are swapped-hosts or unswapped compressed drives,
 26760                                  ;	during its initialization phase.
 26761                                  
 26762                                  	; 29/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 26763                                  	;push	ds
 26764                                  	;lds	bx,[cs:DOSINFO]		; ds:bx -> sys_var
 26765                                  	;
 26766                                  	;mov	al,[cs:drivenumber]	; temporarily use this next drv value
 26767                                  	;mov	[cs:devdrivenum],al	; pass drive number in packet to driver
 26768                                  	;mov	ah,al
 26769                                  	;
 26770                                  	;xchg	ax,[bx+SYSI_NUMIO]	; swap with existing values
 26771                                  	;pop	ds
 26772                                  	;
 26773                                  	;push	ax			; save real sysi_numio/ncds in ax
 26774                                  
 26775                                  	; 29/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 26776                                  	; (SYSINIT:24B9h)
 26777                                  
 26778 0000222E BB0600                  	mov	bx,SYSDEV.STRAT ; 6
 26779 00002231 E8D40E                  	call	calldev 		; calldev (sdevstrat);
 26780 00002234 BB0800                  	mov	bx,SYSDEV.INT ; 8
 26781 00002237 E8CE0E                  	call	calldev 		; calldev (sdevint);
 26782                                  
 26783                                  	; 11/12/2022
 26784                                  	; ds <> cs
 26785                                  
 26786                                  	; 29/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 26787                                  	;pop	ax			; get real sysi_numio value
 26788                                  	;push	ds
 26789                                  	;lds	bx,[cs:DOSINFO]		; ds:bx -> sys_var
 26790                                  	;mov	[bx+SYSI_NUMIO],ax	; swap with existing values
 26791                                  	;pop	ds
 26792                                  
 26793                                  	; 11/12/2022
 26794 0000223A 0E                      	push	cs
 26795 0000223B 1F                      	pop	ds
 26796                                  
 26797 0000223C E88905                  	call	TrueInt12Mem
 26798                                  
 26799                                  	; 11/12/2022
 26800                                  	; ds = cs
 26801                                  	;mov	ax,[cs:break_addr]	; move break addr from the req packet
 26802                                  	;mov	[cs:DevBrkAddr],ax
 26803                                  	;mov	ax,[cs:break_addr+2]
 26804                                  	;mov	[cs:DevBrkAddr+2],ax
 26805 0000223F A1[F403]                	mov	ax,[break_addr]	
 26806 00002242 A3[E81E]                	mov	[DevBrkAddr],ax
 26807 00002245 A1[F603]                	mov	ax,[break_addr+2]
 26808 00002248 A3[EA1E]                	mov	[DevBrkAddr+2],ax
 26809                                  
 26810                                  	; 29/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 26811                                  	;call	RetFromUM		; There we go... all done.
 26812                                  
 26813                                  	; 11/12/2022
 26814 0000224B 803E[EC1E]00            	cmp	byte [DevUMB],0	
 26815                                  	;cmp	byte [cs:DevUMB],0
 26816 00002250 7403                    	je	short tryd_3
 26817 00002252 E83608                  	call	AllocUMB
 26818                                  	; 31/12/2022
 26819                                  	; ds= cs
 26820                                  tryd_3:
 26821                                  
 26822                                  ;ifndef ROMDOS
 26823                                  ;------ If we are waiting to be moved into hma lets try it now !!!
 26824                                  
 26825                                  	; 11/12/2022
 26826                                  	; ds = cs
 26827                                  	
 26828                                  	;cmp	byte [cs:runhigh],0FFh
 26829 00002255 803E[6A02]FF            	cmp	byte [runhigh],0FFh ; 11/12/2022
 26830 0000225A 7503                    	jne	short tryd_4
 26831                                  	
 26832                                  	; 11/12/2022
 26833                                  	; ds = cs
 26834 0000225C E877E6                  	call	TryToMovDOSHi		; move DOS into HMA if reqd
 26835                                  tryd_4:
 26836                                  ;endif ; ROMDOS
 26837                                  
 26838 0000225F 5E                      	pop	si
 26839 00002260 1F                      	pop	ds
 26840 00002261 C60400                  	mov	byte [si],0		; *p = 0;
 26841                                  
 26842 00002264 0E                      	push	cs
 26843 00002265 1F                      	pop	ds
 26844                                  
 26845 00002266 EB1F                    	jmp	short was_device_com
 26846                                  
 26847                                  ;----------------------------------------------------------------------------
 26848                                  
 26849                                  ;02/04/2019 - Retro DOS v4.0
 26850                                  
 26851                                  badnumblock:
 26852 00002268 0E                      	push	cs
 26853 00002269 1F                      	pop	ds
 26854 0000226A BA[C438]                	mov	dx,badblock
 26855 0000226D E80B11                  	call	print
 26856                                  
 26857                                  ;------ fall thru -----------------------------------------------------------
 26858                                  
 26859                                  erase_dev_do:				; modified to show message "error in config.sys..."
 26860                                  	
 26861                                  	;call	CheckDoubleSpace ; MSDOS 6.21 IO.SYS SYSINIT:27BBh
 26862                                  	
 26863 00002270 5E                      	pop	si
 26864 00002271 07                      	pop	es
 26865                                  
 26866 00002272 0E                      	push	cs
 26867 00002273 1F                      	pop	ds
 26868                                  
 26869                                  skip1_resetmemhi:
 26870                                  	; 11/12/2022
 26871                                  	; ds = cs
 26872 00002274 833E[FD03]00            	cmp	word [configmsgflag],0
 26873                                  	;cmp	word [cs:configmsgflag],0
 26874 00002279 7409                    	je	short no_error_line_msg
 26875                                  
 26876 0000227B E8C804                  	call	error_line		; no "error in config.sys" msg for device driver. dcr d493
 26877                                  	; 11/12/2022
 26878                                  	; ds = cs
 26879                                  	;mov	word [cs:configmsgflag],0
 26880 0000227E C706[FD03]0000          	mov	word [configmsgflag],0	; set the default value again.
 26881                                  
 26882                                  no_error_line_msg:
 26883 00002284 E96DFD                  	jmp	coff
 26884                                  
 26885                                  ;----------------------------------------------------------------------------
 26886                                  
 26887                                  was_device_com:
 26888                                  	; 14/12/2022
 26889                                  	; ds = cs
 26890 00002287 A1[EA1E]                	mov	ax,[DevBrkAddr+2]
 26891                                  	;mov	ax,[cs:DevBrkAddr+2] ; 13/05/2019
 26892 0000228A 3B06[E21E]              	cmp	ax,[DevLoadEnd]
 26893                                  	;cmp	ax,[cs:DevLoadEnd]
 26894 0000228E 7605                    	jbe	short breakok
 26895                                  
 26896 00002290 5E                      	pop	si
 26897 00002291 07                      	pop	es
 26898 00002292 E93AFF                  	jmp	BadFile
 26899                                  
 26900                                  breakok:
 26901                                  	; 14/12/2022
 26902                                  	; ds = cs
 26903 00002295 C43E[6B02]              	les	di,[DOSINFO] 
 26904 00002299 C516[E41E]              	lds	dx,[DevEntry]
 26905                                  	;lds	dx,[cs:DevEntry]	;set ds:dx to header
 26906 0000229D 89D6                    	mov	si,dx
 26907                                  
 26908                                  	; 14/11/2022
 26909                                  	;les	di,[cs:DOSINFO] 	;es:di point to dos info
 26910                                  
 26911                                  	; 14/12/2022
 26912                                  	; ds <> cs
 26913                                  	
 26914                                  	;mov	ax,[si+4]
 26915 0000229F 8B4404                  	mov	ax,[si+SYSDEV.ATT]	;get attributes
 26916                                  	; 12/12/2022
 26917 000022A2 F6C480                  	test	ah,DEVTYP>>8 ; 80h 
 26918                                  	;test	ax,DEVTYP ; 8000h	;test if block dev
 26919 000022A5 7426                    	jz	short isblock
 26920                                  
 26921                                  ;------ lets deal with character devices
 26922                                  
 26923 000022A7 2E800E[2E14]02          	or	byte [cs:setdevmarkflag],for_devmark ; 2
 26924 000022AD E8E806                  	call	DevSetBreak		;go ahead and alloc mem for device
 26925                                  jc_edd:
 26926 000022B0 72BE                    	jc	short erase_dev_do	;device driver's init routine failed.
 26927                                  
 26928                                  	; 12/12/2022
 26929 000022B2 A801                    	test	al,ISCIN
 26930                                  	;test	ax,ISCIN ; 1		;is it a console in?
 26931 000022B4 7408                    	jz	short tryclk
 26932                                  
 26933 000022B6 2689550C                	mov	[es:di+SYSI_CON],dx   ; es:di+12
 26934 000022BA 268C5D0E                	mov	[es:di+SYSI_CON+2],ds ; es:di+14
 26935                                  tryclk: 
 26936                                  	; 12/12/2022
 26937 000022BE A808                    	test	al,ISCLOCK
 26938                                  	;test	ax,ISCLOCK ; 8		;is it a clock device?
 26939 000022C0 7408                    	jz	short golink
 26940                                  
 26941 000022C2 26895508                	mov	[es:di+SYSI_CLOCK],dx	; es:di+8
 26942 000022C6 268C5D0A                	mov	[es:di+SYSI_CLOCK+2],ds ; es:di+10
 26943                                  golink: 
 26944 000022CA E9B000                  	jmp	linkit
 26945                                  
 26946                                  ;------ deal with block device drivers
 26947                                  
 26948                                  isblock:
 26949 000022CD 2EA0[F303]              	mov	al,[cs:unitcount]	;if no units found,erase the device
 26950 000022D1 08C0                    	or	al,al
 26951 000022D3 749B                    	jz	short erase_dev_do
 26952                                  	;mov	[si+10],al
 26953 000022D5 88440A                  	mov	[si+SYSDEV.NAME],al	; number of units in name field
 26954                                  	; 29/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 26955                                  	;add	[cs:driver_units],al	; keep total for all drivers in file
 26956                                  perdrv:
 26957 000022D8 98                      	cbw				; warning no device > 127 units
 26958 000022D9 89C1                    	mov	cx,ax
 26959 000022DB 88E6                    	mov	dh,ah
 26960                                  	;mov	dl,[es:di+32]
 26961 000022DD 268A5520                	mov	dl,[es:di+SYSI_NUMIO]	;get number of devices
 26962 000022E1 88D4                    	mov	ah,dl
 26963 000022E3 00C4                    	add	ah,al			; check for too many devices
 26964 000022E5 80FC1A                  	cmp	ah,26			; 'A' - 'Z' is 26 devices
 26965 000022E8 7603                    	jbe	short ok_block
 26966 000022EA E97BFF                  	jmp	badnumblock
 26967                                  
 26968                                  ok_block:
 26969 000022ED 2E800E[2E14]02          	or	byte [cs:setdevmarkflag],for_devmark ; 2
 26970 000022F3 E8A206                  	call	DevSetBreak		; alloc the device
 26971 000022F6 72B8                    	jc	short jc_edd
 26972 000022F8 26004520                	add	[es:di+SYSI_NUMIO],al	; update the amount
 26973                                  
 26974 000022FC 2E0006[FC03]            	add	[cs:drivenumber],al	; remember amount for next device
 26975 00002301 2EC51E[F803]            	lds	bx,[cs:bpb_addr]	; point to bpb array
 26976                                  perunit:
 26977 00002306 2EC42E[6B02]            	les	bp,[cs:DOSINFO]
 26978                                  	;les	bp,[es:bp+SYSI_DPB]	; get first dpb
 26979                                  	; 11/12/2022
 26980 0000230B 26C46E00                	les	bp,[es:bp]
 26981                                  	; 29/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 26982                                  	;les	bp,[es:bp+0]		; [es:bp+SYSI_DPB]
 26983                                  scandpb:
 26984                                  	;cmp	word [es:bp+25],-1
 26985 0000230F 26837E19FF              	cmp	word [es:bp+DPB.NEXT_DPB],-1
 26986 00002314 7406                    	je	short foundpb
 26987                                  	;les	bp,[es:bp+25]
 26988 00002316 26C46E19                	les	bp,[es:bp+DPB.NEXT_DPB]
 26989 0000231A EBF3                    	jmp	short scandpb
 26990                                  foundpb:
 26991 0000231C 2EA1[E81E]              	mov	ax,[cs:DevBrkAddr]
 26992 00002320 26894619                	mov	[es:bp+DPB.NEXT_DPB],ax
 26993 00002324 2EA1[EA1E]              	mov	ax,[cs:DevBrkAddr+2]
 26994 00002328 2689461B                	mov	[es:bp+DPB.NEXT_DPB+2],ax
 26995                                  
 26996 0000232C 2EC42E[E81E]            	les	bp,[cs:DevBrkAddr]
 26997 00002331 2E8306[E81E]21          	add	word [cs:DevBrkAddr],DPBSIZ ; 33
 26998                                  
 26999 00002337 E83D06                  	call	RoundBreakAddr
 27000                                  
 27001 0000233A 26C74619FFFF            	mov	word [es:bp+DPB.NEXT_DPB],-1
 27002 00002340 26C64618FF              	mov	byte [es:bp+DPB.FIRST_ACCESS],-1
 27003                                  
 27004 00002345 8B37                    	mov	si,[bx] 		;ds:si points to bpb
 27005 00002347 43                      	inc	bx
 27006 00002348 43                      	inc	bx			;point to next guy
 27007                                  	;mov	[es:bp+DPB.DRIVE],dx
 27008                                  	; 11/12/2022
 27009 00002349 26895600                	mov	[es:bp],dx ; 13/05/2019
 27010                                  	; 29/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 27011                                  	;mov	[es:bp+0],dx		; [es:bp+DPB.DRIVE]
 27012                                  	
 27013 0000234D B453                    	mov	ah,SETDPB ; 53h		;hidden system call
 27014 0000234F CD21                    	int	21h
 27015                                  			; DOS - 2+ internal - TRANSLATE BIOS PARAMETER BLOCK
 27016                                  			; DS:SI -> BPB (BIOS Parameter Block)
 27017                                  			; ES:BP -> buffer for DOS Drive Parameter Block
 27018                                  
 27019                                  	;mov	ax,[es:bp+2]
 27020 00002351 268B4602                	mov	ax,[es:bp+DPB.SECTOR_SIZE]
 27021 00002355 06                      	push	es
 27022 00002356 2EC43E[6B02]            	les	di,[cs:DOSINFO] 	;es:di point to dos info
 27023                                  	;cmp	ax,[es:di+10h]
 27024 0000235B 263B4510                	cmp	ax,[es:di+SYSI_MAXSEC]
 27025 0000235F 07                      	pop	es
 27026                                  	;jna	short iblk_1
 27027                                  	;jmp	short bad_bpb_size_sector
 27028                                  	; 29/10/2022
 27029 00002360 775A                    	ja	short bad_bpb_size_sector
 27030                                  iblk_1:
 27031 00002362 1E                      	push	ds
 27032 00002363 52                      	push	dx
 27033                                  
 27034 00002364 2EC516[E41E]            	lds	dx,[cs:DevEntry]
 27035                                  	;mov	[es:bp+13h],dx
 27036 00002369 26895613                	mov	[es:bp+DPB.DRIVER_ADDR],dx
 27037                                  	;mov	[es:bp+15h],ds
 27038 0000236D 268C5E15                	mov	[es:bp+DPB.DRIVER_ADDR+2],ds
 27039                                  
 27040 00002371 5A                      	pop	dx
 27041 00002372 1F                      	pop	ds
 27042                                  
 27043 00002373 42                      	inc	dx
 27044 00002374 FEC6                    	inc	dh
 27045 00002376 E28E                    	loop	perunit
 27046                                  
 27047 00002378 0E                      	push	cs
 27048 00002379 1F                      	pop	ds
 27049                                  
 27050 0000237A E852E8                  	call	TempCDS 		; set cds for new drives
 27051                                  linkit:
 27052 0000237D 2EC43E[6B02]            	les	di,[cs:DOSINFO] 	;es:di = dos table
 27053 00002382 268B4D22                	mov	cx,[es:di+SYSI_DEV]	;dx:cx = head of list
 27054 00002386 268B5524                	mov	dx,[es:di+SYSI_DEV+2]
 27055                                  
 27056 0000238A 2EC536[E41E]            	lds	si,[cs:DevEntry]	;ds:si = device location
 27057 0000238F 26897522                	mov	[es:di+SYSI_DEV],si	;set head of list in dos
 27058 00002393 268C5D24                	mov	[es:di+SYSI_DEV+2],ds
 27059 00002397 8B04                    	mov	ax,[si]			;get pointer to next device
 27060 00002399 2EA3[E41E]              	mov	[cs:DevEntry],ax	;and save it
 27061                                  
 27062 0000239D 890C                    	mov	[si],cx			;link in the driver
 27063 0000239F 895402                  	mov	[si+2],dx
 27064                                  enddev:
 27065 000023A2 5E                      	pop	si
 27066 000023A3 07                      	pop	es
 27067 000023A4 40                      	inc	ax			;ax = ffff (no more devs if yes)?
 27068 000023A5 740B                    	jz	short coffj3
 27069                                  
 27070 000023A7 2EFE06[2B14]            	inc	byte [cs:multdeviceflag] ; possibly multiple device driver.
 27071 000023AC E80B06                  	call	DevBreak		; M009
 27072                                  	; 11/12/2022
 27073                                  	; ds = cs (DevBreak)
 27074                                  
 27075                                  	; 03/04/2019 - Retro DOS v4.0
 27076                                  	; MSDOS 6.21 IO.SYS - SYSINIT:290Dh
 27077 000023AF E939FE                  	jmp	goodld			; otherwise pretend we loaded it in
 27078                                  coffj3: 
 27079                                  	; 18/12/2022
 27080                                  	; ax = 0
 27081 000023B2 2EA2[2B14]              	mov	[cs:multdeviceflag],al ; 0
 27082                                  	;mov	byte [cs:multdeviceflag],0 ; reset the flag
 27083 000023B6 E80106                  	call	DevBreak
 27084                                  	; 11/12/2022
 27085                                  	; ds = cs (DevBreak)
 27086                                  	
 27087                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS compatibility)
 27088                                  	;call	CheckProtmanArena	; adjust alloclim if Protman$ just
 27089                                  ;					;  created a bogus arena to try
 27090                                  ;					;  to protect some of its resident-
 27091                                  ;					;  init code.
 27092                                  	;call	CheckDoubleSpace
 27093 000023B9 E938FC                  	jmp	coff
 27094                                  
 27095                                  ;----------------------------------------------------------------------------
 27096                                  
 27097                                  ;CheckDoubleSpace:
 27098                                  ;;;;	ifdef	dblspace_hooks
 27099                                  ;
 27100                                  ;;	Now check for two special MagicDrv cases:
 27101                                  ;;
 27102                                  ;;       a) the last driver load was MagicDrv final placement:
 27103                                  ;;	   -> add number of MagicDrv reserved drives to drivenumber
 27104                                  ;;
 27105                                  ;;       b) MagicDrv is currently in temporary home:
 27106                                  ;;          -> call it to give it a chance to mount and shuffle drives
 27107                                  ;
 27108                                  ;	cmp	byte [cs:MagicHomeFlag],0 ; already home?
 27109                                  ;	jnz	short no_more_magic_calls ;  nothing more to do if so
 27110                                  ;
 27111                                  ;;	Now inquire of driver whether it is present, and final located
 27112                                  ;
 27113                                  ;	mov	ax,multMagicdrv ; 4A11h
 27114                                  ;	mov	bx,MD_VERSION ; 0
 27115                                  ;	int	2fh			; ch = number of MagicDrv drive letters
 27116                                  ;	or	ax,ax			; is it there?
 27117                                  ;	jnz	short no_more_magic_calls ; done if not
 27118                                  ;
 27119                                  ;	test	dx,8000h		; is it final placed?
 27120                                  ;	jnz	short magic_not_yet_home ;  skip if not
 27121                                  ;
 27122                                  ;;	Okay, now the driver is final placed!  Set the flag so we
 27123                                  ;;	don't keep checking it, and add its number of drive letters
 27124                                  ;;	to drivenumber.
 27125                                  ;
 27126                                  ;	mov	byte [cs:MagicHomeFlag],0ffh ; set the flag!
 27127                                  ;	add	[cs:drivenumber],ch	; add number of MagicDrv volumes to
 27128                                  ;;					;  the drive number we'll pass to the
 27129                                  ;;					;  next loadable block device.
 27130                                  ;
 27131                                  ;	jmp	short no_more_magic_calls ; and finished.
 27132                                  ;
 27133                                  ;magic_not_yet_home:
 27134                                  ;	push	es
 27135                                  ;	push	si
 27136                                  ;
 27137                                  ;	mov	cx,[cs:memhi]		; pass it a work buffer
 27138                                  ;	mov	dx,[cs:ALLOCLIM]	;   address in cx (segment)
 27139                                  ;	sub	dx,cx			;   for len dx (paragraphs)
 27140                                  ;
 27141                                  ;	mov	bx,2
 27142                                  ;	mov	al,[cs:driver_units]	; shuffle magicdrives and new drives
 27143                                  ;;					;   by this many units
 27144                                  ;
 27145                                  ;;BUGBUG 29-Oct-1992 bens Take this 55h out after Beta 4
 27146                                  ;	mov	ah,55h			; backdoor won't shuffle unless it
 27147                                  ;;					;  sees this, to prevent bad things
 27148                                  ;;					;  from happening if people run the
 27149                                  ;;					;  new driver with an old BIOS
 27150                                  ;	call	far [cs:MagicBackdoor]
 27151                                  ;
 27152                                  ;	pop	si
 27153                                  ;	pop	es
 27154                                  ;
 27155                                  ;no_more_magic_calls:
 27156                                  ;
 27157                                  ;;;;	endif
 27158                                  ;	retn
 27159                                  
 27160                                  ; 03/04/2019 - Retro DOS v4.0
 27161                                  
 27162                                  bad_bpb_size_sector:
 27163 000023BC 5E                      	pop	si
 27164 000023BD 07                      	pop	es
 27165 000023BE BA[E637]                	mov	dx,badsiz_pre
 27166 000023C1 BB[C437]                	mov	bx,crlfm
 27167 000023C4 E8920F                  	call	prnerr
 27168                                  
 27169 000023C7 E92AFC                  	jmp	coff
 27170                                  
 27171                                  ;------------------------------------------------------------------------------
 27172                                  ; country command
 27173                                  ;      the syntax is:
 27174                                  ;	country=country id {,codepage {,path}}
 27175                                  ;	country=country id {,,path}	:default codepage id in dos
 27176                                  ;------------------------------------------------------------------------------
 27177                                  
 27178                                  	; 30/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 27179                                  	; (SYSINIT:2663h)
 27180                                  tryq:
 27181 000023CA 80FC51                          cmp     ah,CONFIG_COUNTRY ; 'Q'
 27182 000023CD 7403                    	je	short tryq_cont
 27183                                  skip_it3:
 27184 000023CF E90801                  	jmp	tryf
 27185                                  tryq_cont:
 27186                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 27187                                  ;;ifdef	MULTI_CONFIG
 27188                                  ;       call    query_user		; query the user if config_cmd
 27189                                  ;       jc      short skip_it3		; has the CONFIG_OPTION_QUERY bit set
 27190                                  ;;endif
 27191                                  	; 14/12/2022
 27192                                  	; ds = cs
 27193                                  	; bx = 0
 27194                                  	;mov	byte [cs:cntry_drv],0	; reset the drive,path to default value.
 27195                                  	;mov	word [cs:p_code_page],0
 27196 000023D2 881E[7C34]              	mov	[cntry_drv],bl ; 0
 27197 000023D6 891E[A91D]              	mov	[p_code_page],bx ; 0
 27198                                  	
 27199 000023DA BF[721D]                	mov	di,cntry_parms
 27200 000023DD 31C9                    	xor	cx,cx
 27201                                  	; 04/01/2023
 27202                                  	;mov	dx,cx
 27203                                  do52:
 27204 000023DF E8F602                  	call	sysinit_parse
 27205 000023E2 730B                    	jnc	short if52		; parse error,check error code and
 27206                                  
 27207 000023E4 E8E000                  	call	cntry_error		; show message and end the search loop.
 27208                                  	; 14/12/2022
 27209                                  	; ds = cs
 27210 000023E7 C706[A71D]FFFF          	mov	word [p_cntry_code],-1
 27211                                  	;mov	word [cs:p_cntry_code],-1 ; signals that parse error.
 27212 000023ED EB34                    	jmp	short sr52
 27213                                  if52:
 27214 000023EF 83F8FF                  	cmp	ax,_$P_RC_EOL ; 0FFFFh	; end of line?
 27215 000023F2 742F                    	jz	short sr52		; then end the search loop
 27216                                  
 27217                                  	;cmp	byte [cs:result_val+_$P_Result_Blk.Type],_$P_number ; numeric?
 27218                                  	; 14/12/2022
 27219                                  	; ds = cs
 27220 000023F4 803E[441D]01            	cmp	byte [result_val],_$P_Number	
 27221                                  	;cmp	byte [cs:result_val],_$P_Number
 27222 000023F9 7512                    	jnz	short if56
 27223                                  
 27224                                  	;;mov	ax,[cs:rw_dword]
 27225                                  	;mov	ax,[cs:result_val+_$P_Result_Blk.Picked_Val]
 27226                                  	; 14/12/2022
 27227 000023FB A1[481D]                	mov	ax,[result_val+_$P_Result_Blk.Picked_Val]
 27228 000023FE 83F901                  	cmp	cx,1
 27229 00002401 7505                    	jne	short if57
 27230                                  
 27231                                  	;mov	[cs:p_cntry_code],ax
 27232                                  	; 14/12/2022
 27233 00002403 A3[A71D]                	mov	[p_cntry_code],ax
 27234                                  
 27235                                  	; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 27236                                  	;jmp	short en57
 27237                                  	; 12/12/2022
 27238                                  	;jmp	short en56
 27239 00002406 EBD7                    	jmp	short do52
 27240                                  
 27241                                  if57:
 27242                                  	;mov	[cs:p_code_page],ax
 27243                                  	; 14/12/2022
 27244                                  	; ds = cs
 27245 00002408 A3[A91D]                	mov	[p_code_page],ax
 27246                                  en57:
 27247                                  	;jmp	short en56		; path entered
 27248                                  	; 12/12/2022
 27249 0000240B EBD2                    	jmp	short do52
 27250                                  
 27251                                  if56:
 27252 0000240D 1E                      	push	ds
 27253 0000240E 06                      	push	es
 27254 0000240F 56                      	push	si
 27255 00002410 57                      	push	di
 27256                                  
 27257 00002411 0E                      	push	cs
 27258 00002412 07                      	pop	es
 27259                                  
 27260                                  	;lds	si,[cs:rv_dword]	; move the path to known place.
 27261                                  	; 14/12/2022
 27262 00002413 C536[481D]              	lds	si,[rv_dword]
 27263 00002417 BF[7C34]                	mov	di,cntry_drv
 27264 0000241A E82A0F                  	call	move_asciiz
 27265                                  
 27266 0000241D 5F                      	pop	di
 27267 0000241E 5E                      	pop	si
 27268 0000241F 07                      	pop	es
 27269 00002420 1F                      	pop	ds
 27270                                  
 27271                                  en56:
 27272 00002421 EBBC                    	jmp	short do52
 27273                                  
 27274                                  sr52:
 27275                                  	; 14/12/2022
 27276                                  	; ds = cs
 27277 00002423 833E[A71D]FF            	cmp	word [p_cntry_code],-1
 27278                                  	;cmp	word [cs:p_cntry_code],-1	; had a parse error?
 27279 00002428 7509                    	jne	short tryq_open
 27280 0000242A E9C7FB                  	jmp	coff
 27281                                  
 27282                                  tryqbad:				;"invalid country code or code page"
 27283 0000242D F9                      	stc
 27284 0000242E BA[2D38]                	mov     dx,badcountry
 27285 00002431 EB79                    	jmp     tryqchkerr
 27286                                  
 27287                                  tryq_open:
 27288                                  	; 14/12/2022
 27289                                  	; ds = cs
 27290 00002433 803E[7C34]00            	cmp	byte [cntry_drv],0
 27291                                  	;cmp	byte [cs:cntry_drv],0
 27292 00002438 7405                    	je	short tryq_def
 27293 0000243A BA[7C34]                	mov	dx,cntry_drv
 27294 0000243D EB03                    	jmp	short tryq_openit
 27295                                  
 27296                                  tryq_def:
 27297 0000243F BA[7E34]                	mov	dx,cntry_root
 27298                                  tryq_openit:
 27299 00002442 B8003D                  	mov	ax,3D00h		;open a file
 27300 00002445 F9                      	stc
 27301 00002446 CD21                    	int	21h
 27302 00002448 7242                    	jc	short tryqfilebad	;open failure
 27303                                  
 27304                                  	; 14/12/2022
 27305                                  	; ds = cs
 27306 0000244A A3[D803]                	mov	[cntryfilehandle],ax
 27307                                  	;mov	[cs:cntryfilehandle],ax	;save file handle
 27308 0000244D 89C3                    	mov	bx,ax
 27309 0000244F A1[A71D]                	mov	ax,[p_cntry_code]
 27310 00002452 8B16[A91D]              	mov	dx,[p_code_page]
 27311                                  	;mov	ax,[cs:p_cntry_code]
 27312                                  	;mov	dx,[cs:p_code_page]	; now,ax=country id,bx=filehandle
 27313                                  	;mov	cx,[cs:memhi]
 27314 00002456 8B0E[E003]              	mov	cx,[memhi]
 27315 0000245A 81C18001                	add	cx,384			; need 6k buffer to handle country.sys
 27316                                  					; M023
 27317                                  	; 14/12/2022
 27318                                  	; ds = cs
 27319 0000245E 3B0E[A302]              	cmp	cx,[ALLOCLIM]
 27320                                  	;cmp	cx,[cs:ALLOCLIM]
 27321 00002462 7745                    	ja	short tryqmemory	;cannot allocate the buffer for country.sys
 27322                                  
 27323 00002464 BE[7C34]                	mov	si,cntry_drv		;ds:si -> cntry_drv
 27324 00002467 803C00                  	cmp	byte [si],0 		;default path?
 27325 0000246A 7502                    	jne	short tryq_set_for_dos
 27326                                  
 27327 0000246C 46                      	inc	si
 27328 0000246D 46                      	inc	si			;ds:si -> cntry_root
 27329                                  
 27330                                  tryq_set_for_dos:
 27331                                  	; 14/12/2022
 27332                                  	; ds = cs
 27333 0000246E C43E[7702]              	les	di,[sysi_country]
 27334                                  	;les	di,[cs:sysi_country]	;es:di -> country info tab in dos
 27335 00002472 57                      	push	di			;save di
 27336                                  	;add	di,8
 27337 00002473 83C708                  	add	di,country_cdpg_info.ccPath_CountrySys ; 8
 27338 00002476 E8CE0E                  	call	move_asciiz		;set the path to country.sys in dos.
 27339 00002479 5F                      	pop	di			;es:di -> country info tab again.
 27340                                  
 27341                                  	; 14/12/2022	
 27342 0000247A 8B0E[E003]              	mov	cx,[memhi]
 27343                                  	;mov	cx,[cs:memhi]
 27344 0000247E 8ED9                    	mov	ds,cx
 27345 00002480 31F6                    	xor	si,si			;ds:si -> 2k buffer to be used.
 27346 00002482 E8060D                  	call	setdoscountryinfo	;now do the job!!!
 27347                                  	; ds <> cs ; 14/12/2022
 27348 00002485 7325                    	jnc	short tryqchkerr	;read error or could not find country,code page combination
 27349                                  
 27350 00002487 83F9FF                  	cmp	cx,-1			;could not find matching country_id,code page?
 27351 0000248A 74A1                    	je	short tryqbad 		;then "invalid country code or code page"
 27352                                  
 27353                                  tryqfilebad:
 27354 0000248C 0E                      	push	cs
 27355 0000248D 07                      	pop	es
 27356 0000248E 2E803E[7C34]00          	cmp	byte [cs:cntry_drv],0	;is the default file used?
 27357 00002494 7405                    	je	short tryqdefbad
 27358                                  
 27359 00002496 BE[7C34]                	mov	si,cntry_drv
 27360 00002499 EB03                    	jmp	short tryqbadload
 27361                                  
 27362                                  tryqdefbad:				;default file has been used.
 27363 0000249B BE[7E34]                	mov	si,cntry_root		;es:si -> \country.sys in sysinit_seg
 27364                                  tryqbadload:
 27365 0000249E E8B20E                  	call	badload 		;ds will be restored to sysinit_seg
 27366                                  	;mov	cx,[cs:CONFBOT]
 27367                                  	; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 27368                                  	;mov	cx,[cs:top_of_cdss]
 27369                                  	; 11/12/2022
 27370                                  	; ds = cs
 27371 000024A1 8B0E[A102]              	mov	cx,[top_of_cdss]  ; mov cx,[CONFBOT]	
 27372 000024A5 8EC1                    	mov	es,cx			;restore es -> confbot.
 27373 000024A7 EB13                    	jmp	short coffj4
 27374                                  
 27375                                  tryqmemory:
 27376 000024A9 BA[7038]                	mov	dx,insufmemory
 27377                                  tryqchkerr:
 27378                                  	;mov	cx,[cs:CONFBOT]
 27379                                  	; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 27380                                  	;mov	cx,[cs:top_of_cdss]
 27381                                  	; 12/12/2022
 27382 000024AC 0E                      	push	cs
 27383 000024AD 1F                      	pop	ds
 27384 000024AE 8B0E[A102]              	mov	cx,[top_of_cdss]  ; mov cx,[CONFBOT]
 27385 000024B2 8EC1                    	mov	es,cx			;restore es -> confbot seg
 27386                                  	;push	cs
 27387                                  	;pop	ds			;restore ds to sysinit_seg
 27388 000024B4 7306                    	jnc	short coffj4		;if no error,then exit
 27389                                  
 27390 000024B6 E8C20E                  	call	print			;else show error message
 27391 000024B9 E88A02                  	call	error_line
 27392                                  coffj4:
 27393                                  	;mov	bx,[cs:cntryfilehandle]
 27394                                  	; 11/12/2022
 27395                                  	; ds = cs
 27396 000024BC 8B1E[D803]              	mov	bx,[cntryfilehandle]
 27397 000024C0 B43E                    	mov	ah,3Eh
 27398 000024C2 CD21                    	int	21h			;close a file. don't care even if it fails.
 27399 000024C4 E92DFB                  	jmp	coff
 27400                                  
 27401                                  ;--------------------------------------------
 27402                                  
 27403                                  cntry_error:
 27404                                  
 27405                                  ;function: show "invalid country code or code page" messages,or
 27406                                  ;		"error in country command" depending on the error code
 27407                                  ;		in ax returned by sysparse;
 27408                                  ;in:	ax - error code
 27409                                  ;	ds - sysinitseg
 27410                                  ;	es - confbot
 27411                                  ;out:	show message.  dx destroyed.
 27412                                  
 27413 000024C7 83F806                  	cmp	ax,_$P_Out_Of_Range ; 6
 27414 000024CA 7505                    	jne	short if64
 27415 000024CC BA[2D38]                	mov	dx,badcountry		;"invalid country code or code page"
 27416 000024CF EB03                    	jmp	short en64
 27417                                  if64:
 27418 000024D1 BA[5338]                	mov	dx,badcountrycom	;"error in contry command"
 27419                                  en64:
 27420 000024D4 E8A40E                  	call	print
 27421                                  	;call	error_line
 27422                                  	;retn
 27423                                  	; 11/12/2022
 27424 000024D7 E96C02                  	jmp	error_line
 27425                                  
 27426                                  ;------------------------------------------------------------------------------
 27427                                  ; files command
 27428                                  ;------------------------------------------------------------------------------
 27429                                  
 27430                                  ;******************************************************************************
 27431                                  ; function: parse the parameters of files= command.			      *
 27432                                  ;									      *
 27433                                  ; input :								      *
 27434                                  ;	es:si -> parameters in command line.				      *
 27435                                  ; output:								      *
 27436                                  ;	variable files set.						      *
 27437                                  ;									      *
 27438                                  ; subroutines to be called:						      *
 27439                                  ;	sysinit_parse							      *
 27440                                  ; logic:								      *
 27441                                  ; {									      *
 27442                                  ;	set di points to files_parms;					      *
 27443                                  ;	set dx,cx to 0; 						      *
 27444                                  ;	while (end of command line)					      *
 27445                                  ;	{ sysinit_parse;						      *
 27446                                  ;	  if (no error) then						      *
 27447                                  ;	     files = result_val._$P_picked_val				      *
 27448                                  ;	  else								      *
 27449                                  ;	     error exit;						      *
 27450                                  ;	};								      *
 27451                                  ; };									      *
 27452                                  ;									      *
 27453                                  ;******************************************************************************
 27454                                  
 27455                                  tryf:
 27456 000024DA 80FC46                          cmp     ah,CONFIG_FILES ;  'F'
 27457 000024DD 7523                    	jne	short tryl
 27458                                  
 27459                                  	; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 27460                                  ;;ifdef	MULTI_CONFIG
 27461                                  ;       call    query_user              ; query the user if config_cmd
 27462                                  ;       jc      short tryl		; has the CONFIG_OPTION_QUERY bit set
 27463                                  ;;endif
 27464                                  
 27465                                  	; 14/12/2022
 27466                                  	; ds = cs
 27467                                  
 27468 000024DF BF[AB1D]                	mov	di,files_parms
 27469 000024E2 31C9                    	xor	cx,cx
 27470                                  	; 04/01/2023
 27471                                  	;mov	dx,cx
 27472                                  do67:
 27473 000024E4 E8F101                  	call	sysinit_parse
 27474 000024E7 7303                    	jnc	short if67		; parse error
 27475                                  	;call	badparm_p		;  and show messages and end the search loop.
 27476                                  	;jmp	short sr67
 27477                                  	; 04/01/2023
 27478 000024E9 E96A01                  	jmp	badparm_p_coff
 27479                                  if67:
 27480 000024EC 83F8FF                  	cmp	ax,_$P_RC_EOL		; end of line?
 27481 000024EF 7408                    	je	short en67		; then end the $endloop
 27482                                  
 27483                                  	; 14/12/2022
 27484                                  	; ds = cs
 27485                                  	;;mov	al,[cs:rv_dword]
 27486                                  	;mov	al,[cs:result_val+_$P_Result_Blk.Picked_Val]
 27487                                  	;mov	[cs:p_files],al		; save it temporarily
 27488                                  	;mov	al,[rv_dword]
 27489 000024F1 A0[481D]                	mov	al,[result_val+_$P_Result_Blk.Picked_Val]
 27490 000024F4 A2[CA1D]                	mov	[p_files],al
 27491                                  
 27492 000024F7 EBEB                    	jmp	short do67
 27493                                  en67:
 27494                                  	; 14/12/2022
 27495                                  	; ds = cs
 27496 000024F9 A0[CA1D]                	mov	al,[p_files]
 27497 000024FC A2[9D02]                	mov	[FILES],al	
 27498                                  	;mov	al,[cs:p_files]
 27499                                  	;mov	[cs:FILES],al		; no error. really set the value now.
 27500                                  sr67:
 27501 000024FF E9F2FA                  	jmp	coff
 27502                                  
 27503                                  ; 04/04/2019 - Retro DOS v4.0
 27504                                  
 27505                                  ;------------------------------------------------------------------------------
 27506                                  ; lastdrive command
 27507                                  ;------------------------------------------------------------------------------
 27508                                  
 27509                                  ;******************************************************************************
 27510                                  ; function: parse the parameters of lastdrive= command. 		      *
 27511                                  ;									      *
 27512                                  ; input :								      *
 27513                                  ;	es:si -> parameters in command line.				      *
 27514                                  ; output:								      *
 27515                                  ;	set the variable num_cds.					      *
 27516                                  ;									      *
 27517                                  ; subroutines to be called:						      *
 27518                                  ;	sysinit_parse							      *
 27519                                  ; logic:								      *
 27520                                  ; {									      *
 27521                                  ;	set di points to ldrv_parms;					      *
 27522                                  ;	set dx,cx to 0; 						      *
 27523                                  ;	while (end of command line)					      *
 27524                                  ;	{ sysinit_parse;						      *
 27525                                  ;	  if (no error) then						      *
 27526                                  ;	     set num_cds to the returned value; 			      *
 27527                                  ;	  else	/*error exit*/						      *
 27528                                  ;	     error exit;						      *
 27529                                  ;	};								      *
 27530                                  ; };									      *
 27531                                  ;									      *
 27532                                  ;******************************************************************************
 27533                                  
 27534                                  tryl:
 27535 00002502 80FC4C                          cmp     ah,CONFIG_LASTDRIVE ; 'L'
 27536 00002505 7523                    	jne	short tryp
 27537                                  
 27538                                  	; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 27539                                  ;;ifdef	MULTI_CONFIG
 27540                                  ;       call    query_user      ; query the user if config_cmd
 27541                                  ;       jc	short tryp	; has the CONFIG_OPTION_QUERY bit set
 27542                                  ;;endif
 27543                                  	; 14/12/2022
 27544                                  	; ds = cs
 27545                                  
 27546 00002507 BF[021E]                	mov	di,ldrv_parms
 27547 0000250A 31C9                    	xor	cx,cx
 27548                                  	; 04/01/2023
 27549                                  	;mov	dx,cx
 27550                                  do73:
 27551 0000250C E8C901                  	call	sysinit_parse
 27552 0000250F 7303                    	jnc	short if73	; parse error
 27553                                  	;call	badparm_p	;  and show messages and end the search loop.
 27554                                  	;jmp	short sr73
 27555                                  	; 04/01/2023
 27556 00002511 E94201                  	jmp	badparm_p_coff
 27557                                  if73:
 27558 00002514 83F8FF                  	cmp	ax,_$P_RC_EOL	; end of line?
 27559 00002517 7408                    	je	short en73	; then end the $endloop
 27560                                  
 27561                                  	; 14/12/2022
 27562                                  	; ds = cs
 27563                                  	;;mov	al,[cs:rv_dword]
 27564                                  	;mov	al,[cs:rv_byte]	; pick up the drive number
 27565                                  	;mov	[cs:p_ldrv],al	; save it temporarily
 27566                                  
 27567                                  	;mov	al,[rv_dword]
 27568 00002519 A0[481D]                	mov	al,[rv_byte]
 27569 0000251C A2[161E]                	mov	[p_ldrv],al
 27570                                  
 27571 0000251F EBEB                    	jmp	short do73
 27572                                  en73:
 27573                                  	; 14/12/2022
 27574                                  	; ds = cs
 27575 00002521 A0[161E]                	mov	al,[p_ldrv]
 27576 00002524 A2[A002]                	mov	[NUM_CDS],al
 27577                                  	;mov	al,[cs:p_ldrv]
 27578                                  	;mov	[cs:NUM_CDS],al	; no error. really set the value now.
 27579                                  sr73:
 27580 00002527 E9CAFA                  	jmp	coff
 27581                                  
 27582                                  ;--------------------------------------------------------------------------
 27583                                  ; setting drive parameters
 27584                                  ;--------------------------------------------------------------------------
 27585                                  
 27586                                  tryp:
 27587 0000252A 80FC50                          cmp     ah,CONFIG_DRIVPARM ; 'P'
 27588 0000252D 7511                    	jne	short tryk
 27589                                  
 27590                                  	; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 27591                                  ;;ifdef	MULTI_CONFIG
 27592                                  ;       call    query_user      ; query the user if config_cmd
 27593                                  ;       jc      short tryk	; has the CONFIG_OPTION_QUERY bit set
 27594                                  ;;endif
 27595                                  
 27596 0000252F E86908                  	call	parseline
 27597 00002532 7209                    	jc	short trypbad
 27598 00002534 E88907                  	call	setparms
 27599 00002537 E8BF07                  	call	diddleback
 27600                                  
 27601                                  ; No error check here, because setparms and diddleback have no error 
 27602                                  ; returns, and setparms as coded now can return with carry set. 
 27603                                  ;       jc	short trypbad
 27604                                  
 27605                                  	; 12/12/2022
 27606                                  	; cf = 0
 27607                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 27608                                  	;jc	short trypbad
 27609                                  	
 27610 0000253A E9B7FA                  	jmp	coff
 27611                                  trypbad:
 27612 0000253D E9BB01                  	jmp	badop
 27613                                  
 27614                                  ;--------------------------------------------------------------------------
 27615                                  ; setting internal stack parameters
 27616                                  ; stacks=m,n where
 27617                                  ;	m is the number of stacks (range 8 to 64,default 9)
 27618                                  ;	n is the stack size (range 32 to 512 bytes,default 128)
 27619                                  ; j.k. 5/5/86: stacks=0,0 implies no stack installation.
 27620                                  ;	any combinations that are not within the specified limits will
 27621                                  ;	result in "unrecognized command" error.
 27622                                  ;--------------------------------------------------------------------------
 27623                                  
 27624                                  ;**************************************************************************
 27625                                  ;									  *
 27626                                  ; function: parse the parameters of stacks= command.			  *
 27627                                  ;	    the minimum value for "number of stacks" and "stack size" is  *
 27628                                  ;	    8 and 32 each.  in the definition of sysparse value list,they *
 27629                                  ;	    are set to 0.  this is for accepting the exceptional case of  *
 27630                                  ;	    stacks=0,0 case (,which means do not install the stack.)	  *
 27631                                  ;	    so,after sysparse is done,we have to check if the entered	  *
 27632                                  ;	    values (stack_count,stack_size) are within the actual range,  *
 27633                                  ;	    (or if "0,0" pair has been entered.)			  *
 27634                                  ; input :								  *
 27635                                  ;	es:si -> parameters in command line.				  *
 27636                                  ; output:								  *
 27637                                  ;	set the variables stack_count,stack_size.			  *
 27638                                  ;									  *
 27639                                  ; subroutines to be called:						  *
 27640                                  ;	sysinit_parse							  *
 27641                                  ; logic:								  *
 27642                                  ; {									  *
 27643                                  ;	set di points to stks_parms;					  *
 27644                                  ;	set dx,cx to 0; 						  *
 27645                                  ;	while (end of command line)					  *
 27646                                  ;	{ sysinit_parse;						  *
 27647                                  ;	  if (no error) then						  *
 27648                                  ;	     { if (cx == 1) then /* first positional = stack count */	  *
 27649                                  ;		   p_stack_count = result_val._$P_picked_val;		  *
 27650                                  ;	       if (cx == 2) then /* second positional = stack size */	  *
 27651                                  ;		   p_stack_size = result_val._$P_picked_val;		  *
 27652                                  ;	     }								  *
 27653                                  ;	  else	/*error exit*/						  *
 27654                                  ;	     error exit;						  *
 27655                                  ;	};								  *
 27656                                  ;	here check p_stack_count,p_stack_size if it meets the condition;  *
 27657                                  ;	if o.k.,then set stack_count,stack_size;			  *
 27658                                  ;	 else error_exit;						  *
 27659                                  ; };									  *
 27660                                  ;**************************************************************************
 27661                                  
 27662                                  tryk:
 27663                                          ;if      stacksw
 27664                                  
 27665 00002540 80FC4B                          cmp     ah,CONFIG_STACKS ; 'K'
 27666 00002543 7402                    	je	short do_tryk
 27667                                  skip_it4:
 27668 00002545 EB74                    	jmp	short trys	; 15/12/2022
 27669                                  do_tryk:
 27670                                  	; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 27671                                  ;;ifdef	MULTI_CONFIG
 27672                                  ;       call    query_user              ; query the user if config_cmd
 27673                                  ;       jc	short skip_it4		; has the CONFIG_OPTION_QUERY bit set
 27674                                  ;;endif
 27675                                  	; 14/12/2022
 27676                                  	; ds = cs
 27677                                  
 27678 00002547 BF[171E]                	mov	di,stks_parms
 27679 0000254A 31C9                    	xor	cx,cx
 27680                                  	; 04/01/2023
 27681                                  	;mov	dx,cx
 27682                                  do79:
 27683 0000254C E88901                  	call	sysinit_parse
 27684 0000254F 730B                    	jnc	short if79		; parse error
 27685                                  
 27686 00002551 BA[DF38]                	mov	dx,badstack		; "invalid stack parameter"
 27687 00002554 E8240E                  	call	print			;  and show messages and end the search loop.
 27688 00002557 E8EC01                  	call	error_line
 27689                                  	;jmp	sr79
 27690                                  	; 11/12/2022
 27691 0000255A EB39                    	jmp	short sr79
 27692                                  if79:
 27693 0000255C 83F8FF                  	cmp	ax,_$P_RC_EOL		; end of line?
 27694 0000255F 7412                    	je	short en79		; then end the $endloop
 27695                                  
 27696                                  	; 14/12/2022
 27697                                  	; ds = cs
 27698                                  
 27699                                  	;;mov	ax,[cs:rv_dword]
 27700                                  	;mov	ax,[cs:result_val+_$P_Result_Blk.Picked_Val]
 27701                                  	;mov	ax,[rv_dword]
 27702 00002561 A1[481D]                	mov	ax,[result_val+_$P_Result_Blk.Picked_Val]
 27703                                  
 27704 00002564 83F901                  	cmp	cx,1
 27705 00002567 7505                    	jne	short if83
 27706                                  
 27707                                  	; 14/12/2022
 27708                                  	;mov	[cs:p_stack_count],ax
 27709                                  	;jmp	short en83
 27710 00002569 A3[4C1E]                	mov	[p_stack_count],ax
 27711 0000256C EBDE                    	jmp	short do79
 27712                                  if83:
 27713                                  	; 14/12/2022
 27714                                  	;mov	[cs:p_stack_size],ax
 27715 0000256E A3[4E1E]                	mov	[p_stack_size],ax
 27716                                  en83:
 27717 00002571 EBD9                    	jmp	short do79
 27718                                  en79:
 27719                                  	; 14/12/2022
 27720                                  	; ds = cs
 27721 00002573 A1[4C1E]                	mov	ax,[p_stack_count]
 27722 00002576 09C0                    	or	ax,ax
 27723 00002578 741E                    	jz	short if87		
 27724                                  
 27725                                  	; 14/12/2022
 27726                                  	;cmp	word [p_stack_count],0
 27727                                  	;;cmp	word [cs:p_stack_count],0
 27728                                  	;je	short if87
 27729                                  
 27730                                  	; 14/12/2022
 27731 0000257A 83F808                  	cmp	ax, mincount ; 8
 27732                                  	;cmp	word [cs:p_stack_count],mincount ; 8
 27733                                  	; 15/12/2022
 27734 0000257D 721F                    	jb	short en87
 27735 0000257F 833E[4E1E]20            	cmp	word [p_stack_size],minsize ; 32
 27736                                  	;cmp	word [cs:p_stack_size],minsize ; 32
 27737                                  	; 15/12/2022
 27738 00002584 7218                    	jb	short en87
 27739                                  if94:
 27740                                  	; 14/12/2022
 27741                                  	; ds = cs
 27742                                  	; ax = [p_stack_count]
 27743                                  	;mov	ax,[p_stack_count]
 27744                                  	;;mov	ax,[cs:p_stack_count]
 27745 00002586 A3[8A02]                	mov	[stack_count],ax
 27746                                  	;mov	[cs:stack_count],ax
 27747                                  	;mov	ax,[cs:p_stack_size]
 27748 00002589 A1[4E1E]                	mov	ax,[p_stack_size]
 27749                                  	;mov	[cs:stack_size],ax
 27750 0000258C A3[8C02]                	mov	[stack_size],ax
 27751                                  	;mov	word [cs:stack_addr],-1	; stacks= been accepted.
 27752 0000258F C706[8E02]FFFF          	mov	word [stack_addr],-1
 27753                                  sr79:
 27754 00002595 E95CFA                  	jmp	coff
 27755                                  
 27756                                  if87:
 27757                                  	; 14/12/2022
 27758 00002598 3906[4E1E]              	cmp	[p_stack_size],ax ; 0
 27759 0000259C 74E8                    	je	short if94 ; ax = [p_stack_count] = 0
 27760                                  	;cmp	word [cs:p_stack_size],0
 27761                                  	;je	short if94
 27762                                  en87:
 27763                                  	; 15/12/2022
 27764                                  	; ([p_stack_count] is invalid, use default values)
 27765                                  	; 14/12/2022
 27766                                  	; ds = cs
 27767 0000259E C706[8A02]0900          	mov	word [stack_count],defaultcount ; 9
 27768 000025A4 C706[8C02]8000          	mov	word [stack_size],defaultsize ; 128
 27769 000025AA C706[8E02]0000          	mov	word [stack_addr],0
 27770                                  	;mov	word [cs:stack_count],defaultcount ; 9
 27771                                  	;				; reset to default value.
 27772                                  	;mov	word [cs:stack_size],defaultsize ; 128
 27773                                  	;mov	word [cs:stack_addr],0
 27774                                  
 27775 000025B0 BA[DF38]                	mov	dx,badstack
 27776 000025B3 E8C50D                  	call	print
 27777 000025B6 E88D01                  	call	error_line
 27778 000025B9 EBDA                    	jmp	short sr79
 27779                                  
 27780                                  ; 15/12/2022
 27781                                  %if 0
 27782                                  	mov	di,stks_parms
 27783                                  	xor	cx,cx
 27784                                  	; 04/01/2023
 27785                                  	;mov	dx,cx
 27786                                  do79:
 27787                                  	call	sysinit_parse
 27788                                  	jnc	short if79		; parse error
 27789                                  
 27790                                  	mov	dx,badstack		; "invalid stack parameter"
 27791                                  	call	print			;  and show messages and end the search loop.
 27792                                  	call	error_line
 27793                                  	;jmp	sr79
 27794                                  	; 11/12/2022
 27795                                  	jmp	short sr79
 27796                                  if79:
 27797                                  	cmp	ax,_$P_RC_EOL		; end of line?
 27798                                  	je	short en79		; then end the $endloop
 27799                                  
 27800                                  	;mov	ax,[cs:rv_dword]
 27801                                  	mov	ax,[cs:result_val+_$P_Result_Blk.Picked_Val]
 27802                                  	cmp	cx,1
 27803                                  	jne	short if83
 27804                                  
 27805                                  	mov	[cs:p_stack_count],ax
 27806                                  	jmp	short en83
 27807                                  if83:
 27808                                  	mov	[cs:p_stack_size],ax
 27809                                  en83:
 27810                                  	jmp	short do79
 27811                                  en79:
 27812                                  	cmp	word [cs:p_stack_count],0
 27813                                  	je	short if87
 27814                                  
 27815                                  	cmp	word [cs:p_stack_count],mincount ; 8
 27816                                  	jb	short ll88
 27817                                  	cmp	word [cs:p_stack_size],minsize ; 32
 27818                                  	jnb	short if88
 27819                                  ll88:
 27820                                  	mov	word [cs:p_stack_count],-1 ; invalid
 27821                                  if88:
 27822                                  	jmp	short en87
 27823                                  
 27824                                  	; 11/12/2022
 27825                                  if94:
 27826                                  	mov	ax,[cs:p_stack_count]
 27827                                  	mov	[cs:stack_count],ax
 27828                                  	mov	ax,[cs:p_stack_size]
 27829                                  	mov	[cs:stack_size],ax
 27830                                  	mov	word [cs:stack_addr],-1	; stacks= been accepted.
 27831                                  sr79:
 27832                                  	jmp	coff
 27833                                  
 27834                                  if87:
 27835                                  	cmp	word [cs:p_stack_size],0
 27836                                  	je	short en87
 27837                                  	mov	word [cs:p_stack_count],-1 ; invalid
 27838                                  en87:
 27839                                  	cmp	word [cs:p_stack_count],-1 ; invalid?
 27840                                  	jne	short if94
 27841                                  
 27842                                  	mov	word [cs:stack_count],defaultcount ; 9
 27843                                  					; reset to default value.
 27844                                  	mov	word [cs:stack_size],defaultsize ; 128
 27845                                  	mov	word [cs:stack_addr],0
 27846                                  
 27847                                  	mov	dx,badstack
 27848                                  	call	print
 27849                                  	call	error_line
 27850                                  	jmp	short sr79
 27851                                  
 27852                                  %endif
 27853                                  
 27854                                  ; 11/12/2022
 27855                                  %if 0 
 27856                                  
 27857                                  if94:
 27858                                  	mov	ax,[cs:p_stack_count]
 27859                                  	mov	[cs:stack_count],ax
 27860                                  	mov	ax,[cs:p_stack_size]
 27861                                  	mov	[cs:stack_size],ax
 27862                                  	mov	word [cs:stack_addr],-1	; stacks= been accepted.
 27863                                  sr79:
 27864                                  	jmp	coff
 27865                                  
 27866                                  %endif
 27867                                  
 27868                                  	;endif
 27869                                  
 27870                                  ;------------------------------------------------------------------------
 27871                                  ; shell command
 27872                                  ;------------------------------------------------------------------------
 27873                                  
 27874                                  trys:
 27875 000025BB 80FC53                          cmp     ah,CONFIG_SHELL ; 'S'
 27876 000025BE 753C                    	jne	short tryx
 27877                                  
 27878                                  	; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 27879                                  ;;ifdef	MULTI_CONFIG
 27880                                  ;       call    query_user              ; query the user if config_cmd
 27881                                  ;       jc	short tryx		; has the CONFIG_OPTION_QUERY bit set
 27882                                  ;       mov	byte [cs:newcmd],1
 27883                                  ;;endif
 27884                                  
 27885                                  	;;mov	word [cs:command_line],0 ; zap length,first byte of command-line
 27886                                  	; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 27887                                  	;mov	byte [cs:command_line+1],0
 27888                                  	; 15/12/2022
 27889                                  	; ds = cs
 27890 000025C0 C606[AA02]00            	mov	byte [command_line+1],0
 27891                                  
 27892 000025C5 BF[CA34]                        mov     di,commnd+1		; we already have the first char
 27893 000025C8 8845FF                          mov     [di-1],al               ; of the new shell in AL, save it now
 27894                                  storeshell:
 27895 000025CB E86101                  	call	getchr
 27896 000025CE 08C0                            or      al,al                   ; this is the normal case: "organize"
 27897 000025D0 7419                            jz	short getshparms	; put a ZERO right after the filename
 27898                                  
 27899 000025D2 3C20                            cmp     al," "                  ; this may happen if there are no args
 27900 000025D4 7205                            jb	short endofshell	; I suppose...
 27901 000025D6 8805                    	mov	[di],al
 27902 000025D8 47                      	inc	di
 27903                                          ;cmp    di,commnd+63		; this makes sure we don't overflow
 27904                                          ;jb	short storeshell	; commnd (the filename)
 27905                                          ;jmp	short endofshell
 27906                                  	; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 27907 000025D9 EBF0                    	jmp	short storeshell
 27908                                  
 27909                                  ; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 27910                                  ;getshparms:
 27911                                  ;	mov     byte [di],0		; zero-terminate the filename
 27912                                  ;	mov     di,command_line+1	; prepare to process the command-line
 27913                                  ;
 27914                                  ;parmloop:
 27915                                  ;	call	getchr
 27916                                  ;	cmp	al," "
 27917                                  ;	jb	short endofparms
 27918                                  ;	mov	[di],al
 27919                                  ;	inc	di
 27920                                  ;	cmp     di,command_line+126
 27921                                  ;	jb	short parmloop
 27922                                  ;endofparms:
 27923                                  ;	mov     cx,di
 27924                                  ;	sub     cx,command_line+1
 27925                                  ;	mov     [cs:command_line],cl
 27926                                  ;
 27927                                  ;endofshell:
 27928                                  ;	mov     byte [di],0		; zero-terminate the filename (or
 27929                                  ;					; the command-line as the case may be)
 27930                                  ;skipline:
 27931                                  ;       cmp     al,lf	; 0Ah		; the safest way to eat the rest of
 27932                                  ;       je	short endofline		; the line: watch for ever-present LF
 27933                                  ;call	getchr
 27934                                  ;       jnc	short skipline		; keep it up as long as there are chars
 27935                                  ;
 27936                                  ;endofline:
 27937                                  ;       jmp     conflp
 27938                                  
 27939                                  	; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 27940                                  endofshell:
 27941 000025DB C60500                       	mov     byte [di],0		; zero-terminate the filename (or
 27942                                  					; the command-line as the case may be)
 27943 000025DE E84E01                  	call	getchr
 27944                                  skipline:
 27945 000025E1 3C0A                    	cmp     al,lf	; 0Ah		; the safest way to eat the rest of
 27946 000025E3 7403                    	je	short endofline		; the line: watch for ever-present LF
 27947 000025E5 E84701                  	call	getchr
 27948                                  endofline:
 27949 000025E8 E9E4F9                  	jmp     conflp
 27950                                  
 27951                                  	; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 27952                                  getshparms:
 27953                                  	; 18/12/2022
 27954                                  	; al = 0
 27955 000025EB 8805                    	mov	[di],al ; 0
 27956                                  	;mov	byte [di],0		; zero-terminate the filename
 27957 000025ED BF[AA02]                	mov     di,command_line+1	; prepare to process the command-line
 27958                                  parmloop:
 27959 000025F0 E83C01                  	call	getchr
 27960 000025F3 3C20                    	cmp	al," " ; 20h
 27961 000025F5 72E4                    	jb	short endofshell
 27962 000025F7 8805                    	mov	[di],al
 27963 000025F9 47                      	inc	di
 27964 000025FA EBF4                    	jmp	short parmloop
 27965                                  
 27966                                  ;------------------------------------------------------------------------
 27967                                  ; fcbs command
 27968                                  ;------------------------------------------------------------------------
 27969                                  
 27970                                  ;************************************************************************
 27971                                  ; function: parse the parameters of fcbs= command.			*
 27972                                  ;									*
 27973                                  ; input :								*
 27974                                  ;	es:si -> parameters in command line.				*
 27975                                  ; output:								*
 27976                                  ;	set the variables fcbs,keep.					*
 27977                                  ;									*
 27978                                  ; subroutines to be called:						*
 27979                                  ;	sysinit_parse							*
 27980                                  ; logic:								*
 27981                                  ; {									*
 27982                                  ;	set di points to fcbs_parms;					*
 27983                                  ;	set dx,cx to 0; 						*
 27984                                  ;	while (end of command line)					*
 27985                                  ;	{ sysparse;							*
 27986                                  ;	  if (no error) then						*
 27987                                  ;	     { if (cx == 1) then /* first positional = fcbs */		*
 27988                                  ;		   fcbs = result_val._$P_picked_val;			*
 27989                                  ;	       if (cx == 2) then /* second positional = keep */ 	*
 27990                                  ;		   keep = result_val._$P_picked_val;			*
 27991                                  ;	     }								*
 27992                                  ;	  else	/*error exit*/						*
 27993                                  ;	     error exit;						*
 27994                                  ;	};								*
 27995                                  ; };									*
 27996                                  ;************************************************************************
 27997                                  
 27998                                  tryx:
 27999 000025FC 80FC58                          cmp     ah,CONFIG_FCBS  ; 'X'
 28000                                          ;jne	short try1
 28001                                  	; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 28002 000025FF 752F                    	jne	short tryy	; comment command
 28003                                  
 28004                                  	; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 28005                                  ;;ifdef	MULTI_CONFIG
 28006                                  ;       call    query_user      ; query the user if config_cmd
 28007                                  ;       jc	short try1	; has the CONFIG_OPTION_QUERY bit set
 28008                                  ;;endif
 28009                                  
 28010 00002601 BF[CB1D]                	mov	di,fcbs_parms
 28011 00002604 31C9                    	xor	cx,cx
 28012                                  	; 04/01/2023
 28013                                  	;mov	dx,cx
 28014                                  do98:
 28015 00002606 E8CF00                  	call	sysinit_parse
 28016                                          ; 04/01/2023
 28017                                  	;jnc	short if98	; parse error
 28018                                          ;call	badparm_p	;  and show messages and end the search loop.
 28019                                  	;jmp	short sr98
 28020                                  	;------------------------
 28021                                  	; 04/01/2023
 28022 00002609 724B                    	jc	short badparm_p_coff
 28023                                  if98:
 28024 0000260B 83F8FF                  	cmp	ax,_$P_RC_EOL	; end of line?
 28025 0000260E 7412                    	je	short en98	; then end the $endloop
 28026                                  
 28027                                  	;;mov	al,[cs:rv_dword]
 28028                                  	;mov	al,[cs:result_val+_$P_Result_Blk.Picked_Val]
 28029                                  	; 15/12/2022
 28030                                  	; ds = cs
 28031 00002610 A0[481D]                	mov	al,[result_val+_$P_Result_Blk.Picked_Val]
 28032 00002613 83F901                  	cmp	cx,1		; the first positional?
 28033 00002616 7505                    	jne	short if102
 28034                                  	;mov	[cs:p_fcbs],al
 28035                                  	; 15/12/2022
 28036 00002618 A2[001E]                	mov	[p_fcbs],al
 28037                                  	;jmp	short en102
 28038 0000261B EBE9                    	jmp	short do98
 28039                                  if102:
 28040                                  	;mov	[cs:p_keep],al
 28041                                  	; 15/12/2022
 28042 0000261D A2[011E]                	mov	[p_keep],al
 28043                                  en102:
 28044 00002620 EBE4                    	jmp	short do98
 28045                                  en98:
 28046                                  	; 15/12/2022
 28047                                  	; ds = cs
 28048 00002622 A0[001E]                	mov	al,[p_fcbs]
 28049 00002625 A2[9E02]                	mov	[FCBS],al
 28050 00002628 C606[9F02]00            	mov	byte [KEEP],0
 28051                                  	;mov	al,[cs:p_fcbs]	 ; M017
 28052                                  	;mov	[cs:FCBS],al	 ; M017
 28053                                  	;mov	byte [cs:KEEP],0 ; M017
 28054                                  sr98:
 28055 0000262D E9C4F9                  	jmp	coff
 28056                                  
 28057                                  ; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 28058                                  ;-------------------------------------------------------------------------
 28059                                  ; comment= do nothing. just decrease chrptr,and increase count for correct
 28060                                  ;		line number
 28061                                  ;-------------------------------------------------------------------------
 28062                                  
 28063                                  tryy:
 28064 00002630 80FC59                  	cmp     ah,CONFIG_COMMENT ; 'Y'
 28065 00002633 750B                    	jne	short try0
 28066                                  
 28067                                  donothing:
 28068                                  	; 15/12/2022
 28069                                  	; ds = cs
 28070 00002635 FF0E[D603]              	dec	word [chrptr]
 28071 00002639 FF06[D203]              	inc	word [count]
 28072                                  	; 02/11/2022
 28073                                  	;dec	word [cs:chrptr]
 28074                                  	;inc	word [cs:count]
 28075                                  
 28076 0000263D E9B4F9                  	jmp	coff
 28077                                  
 28078                                  ;------------------------------------------------------------------------
 28079                                  ; rem command
 28080                                  ;------------------------------------------------------------------------
 28081                                  
 28082                                  try0:				; do nothing with this line.
 28083 00002640 80FC30                  	cmp     ah,CONFIG_REM ; '0'
 28084 00002643 74F0                    	je	short donothing
 28085                                  
 28086                                  ; 07/04/2019 - Retro DOS v4.0
 28087                                  
 28088                                  ;-----------------------------------------------------------------------
 28089                                  ; switches command
 28090                                  ;-----------------------------------------------------------------------
 28091                                  
 28092                                  ;***********************************************************************
 28093                                  ;								       *
 28094                                  ; function: parse the option switches specified.		       *
 28095                                  ; note - this command is intended for the future use also.	       *
 28096                                  ; when we need to set system data flag,use this command.	       *
 28097                                  ;								       *
 28098                                  ; input :							       *
 28099                                  ;	es:si -> parameters in command line.			       *
 28100                                  ; output:							       *
 28101                                  ;	p_swit_k set if /k option chosen.			       *
 28102                                  ;								       *
 28103                                  ; subroutines to be called:					       *
 28104                                  ;	sysinit_parse						       *
 28105                                  ; logic:							       *
 28106                                  ; {								       *
 28107                                  ;	set di points to swit_parms;  /*parse control definition*/     *
 28108                                  ;	set dx,cx to 0; 					       *
 28109                                  ;	while (end of command line)				       *
 28110                                  ;	{ sysinit_parse;					       *
 28111                                  ;	  if (no error) then					       *
 28112                                  ;	       if (result_val._$P_synonym_ptr == swit_k) then	       *
 28113                                  ;		    p_swit_k = 1				       *
 28114                                  ;	       endif						       *
 28115                                  ;	  else {show error message;error exit}			       *
 28116                                  ;	};							       *
 28117                                  ; };								       *
 28118                                  ;								       *
 28119                                  ;***********************************************************************
 28120                                  
 28121                                  SUPPRESS_WINA20	EQU 00000010b	; M025 ; (DOSSYM.INC, MSDOS 6.0)
 28122                                  
 28123                                  try1:
 28124 00002645 80FC31                          cmp     ah,CONFIG_SWITCHES ; '1'
 28125 00002648 7402                    	je	short do_try1	; switches= command entered?
 28126                                  skip_it5:
 28127                                  	;jmp	tryv
 28128                                  	; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 28129 0000264A EB7A                    	jmp	tryz
 28130                                  
 28131                                  do_try1:
 28132                                  
 28133                                  	; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 28134                                  ;;ifdef	MULTI_CONFIG
 28135                                  ;       call    query_user      ; query the user if config_cmd
 28136                                  ;       jc	short skip_it5	; has the CONFIG_OPTION_QUERY bit set
 28137                                  ;;endif
 28138                                  
 28139 0000264C BF[651E]                	mov	di,swit_parms
 28140 0000264F 31C9                    	xor	cx,cx
 28141                                  	; 04/01/2023
 28142                                  	;mov	dx,cx
 28143                                  do110:
 28144 00002651 E88400                  	call	sysinit_parse
 28145 00002654 7306                    	jnc	short if110	; parse error
 28146                                  	;call	badparm_p	;  and show messages and end the search loop.
 28147                                  	;jmp	short sr110
 28148                                  	; -----------------------
 28149                                  	; 04/01/2023
 28150                                  badparm_p_coff:
 28151 00002656 E8AE00                  	call	badparm_p
 28152 00002659 E998F9                  	jmp	coff
 28153                                  	;------------------------
 28154                                  if110:
 28155 0000265C 83F8FF                  	cmp	ax,_$P_RC_EOL	; end of line?
 28156 0000265F 742D                    	je	short en110	; then jmp to $endloop for semantic check
 28157                                  
 28158                                  	; 15/12/2022
 28159                                  	; ds = cs
 28160                                  	;;cmp	word [cs:result_val_swoff],swit_k
 28161                                  	;cmp	word [cs:result_val+_$P_Result_Blk.SYNONYM_Ptr],swit_k 
 28162 00002661 813E[461D][7D1E]        	cmp	word [result_val+_$P_Result_Blk.SYNONYM_Ptr],swit_k 
 28163 00002667 7507                    	jne	short if115	;				;M059
 28164                                  	; 15/12/2022
 28165 00002669 C606[981E]01            	mov	byte [p_swit_k],1
 28166                                  	;mov	byte [cs:p_swit_k],1	; set the flag
 28167 0000266E EBE1                    	jmp	short do110
 28168                                  if115:	
 28169                                  	; 15/12/2022							;M059
 28170                                  	;;cmp	word [cs:result_val_swoff],swit_t
 28171                                  	;cmp	word [cs:result_val+_$P_Result_Blk.SYNONYM_Ptr],swit_t	;M059
 28172 00002670 813E[461D][891E]        	cmp	word [result_val+_$P_Result_Blk.SYNONYM_Ptr],swit_t
 28173 00002676 7507                    	jne	short if116					;M059 M063
 28174                                  	; 15/12/2022
 28175 00002678 C606[991E]01            	mov	byte [p_swit_t],1
 28176                                  	;mov	byte [cs:p_swit_t],1				;M059
 28177 0000267D EBD2                    	jmp	short do110					;M059
 28178                                  if116:
 28179                                  	; 15/12/2022
 28180                                  	;;cmp	word [cs:result_val_swoff],swit_w
 28181                                  	;cmp	word [cs:result_val+_$P_Result_Blk.SYNONYM_Ptr],swit_w	;M063
 28182 0000267F 813E[461D][951E]        	cmp	word [result_val+_$P_Result_Blk.SYNONYM_Ptr],swit_w
 28183 00002685 75CA                    	jne	short do110					;M063
 28184                                  	; 15/12/2022
 28185 00002687 C606[9A1E]01            	mov	byte [p_swit_w],1
 28186                                  	;mov	byte [cs:p_swit_w],1				;M063
 28187 0000268C EBC3                    	jmp	short do110					;M063
 28188                                  en110:
 28189                                  	; 15/12/2022
 28190                                  	; ds = cs
 28191 0000268E 803E[981E]01            	cmp	byte [p_swit_k],1
 28192                                  	;cmp	byte [cs:p_swit_k],1	; if /k entered,
 28193 00002693 1E                      	push	ds
 28194                                  	;;mov	ax,Bios_Data
 28195                                  	;mov	ax,KERNEL_SEGMENT ; 0070h
 28196                                  	; 21/10/2022
 28197 00002694 B87000                  	mov	ax,DOSBIODATASEG ; 0070h
 28198 00002697 8ED8                    	mov	ds,ax
 28199 00002699 750A                    	jne	short if117
 28200 0000269B C606[E504]00            	mov	byte [keyrd_func],0 ; 4E5h ; use the conventional keyboard functions
 28201 000026A0 C606[E604]01            	mov	byte [keysts_func],1 ; 4E6h (for MSDOS 6.21 IO.SYS)
 28202                                  if117:
 28203                                  	; 15/12/2022
 28204                                  	; ds <> cs
 28205 000026A5 2EA0[991E]              	mov	al,[cs:p_swit_t]				;M059
 28206 000026A9 A2[F204]                	mov	[t_switch],al	; 4F2h (for MSDOS 6.21 IO.SYS)	;M059
 28207                                  
 28208 000026AC 2E803E[9A1E]00          	cmp	byte [cs:p_swit_w],0				;M063
 28209 000026B2 740E                    	je	short skip_dos_flag				;M063
 28210 000026B4 06                      	push	es
 28211 000026B5 53                      	push	bx
 28212 000026B6 B452                    	mov	ah,GET_IN_VARS ; 52h				;M063
 28213 000026B8 CD21                    	int	21h						;M063
 28214                                  			; DOS - 2+ internal - GET LIST OF LISTS
 28215                                  			; Return: ES:BX -> DOS list of lists
 28216                                  	;or	bytes [es:86h],2
 28217 000026BA 26800E860002            	or	byte [es:DOS_FLAG_OFFSET],SUPPRESS_WINA20 ; 2	;M063
 28218 000026C0 5B                      	pop	bx
 28219 000026C1 07                      	pop	es
 28220                                  skip_dos_flag:							;M063
 28221 000026C2 1F                      	pop	ds
 28222                                  sr110:
 28223 000026C3 E92EF9                  	jmp	coff
 28224                                  
 28225                                  ; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 28226                                  ;
 28227                                  ;tryv:
 28228                                  ;
 28229                                  ;;ifdef	MULTI_CONFIG
 28230                                  ;;------------------------------------------------------------------------
 28231                                  ;; set command (as in "set var=value<cr/lf>")
 28232                                  ;;------------------------------------------------------------------------
 28233                                  ;
 28234                                  ;       cmp     ah,CONFIG_SET  ; 'V'
 28235                                  ;       jne	short tryn
 28236                                  ;       call    query_user      ; query the user if config_cmd
 28237                                  ;       jc	short tryn 	; has the CONFIG_OPTION_QUERY bit set
 28238                                  ;       call    copy_envvar     ; copy var at ES:SI to "config_wrkseg"
 28239                                  ;       jnc	short sr110	; no error
 28240                                  ;err:    
 28241                                  ;	call    error_line      ; whoops, display error in line XXX
 28242                                  ;       jmp     short sr110     ; jump to coff (to skip to next line)
 28243                                  ;
 28244                                  ;;------------------------------------------------------------------------
 28245                                  ;; numlock command (as in "numlock=on|off")
 28246                                  ;;------------------------------------------------------------------------
 28247                                  ;tryn:
 28248                                  ;       cmp     ah,CONFIG_NUMLOCK  ;'N'
 28249                                  ;       jne	short tryy            ;
 28250                                  ;       call    query_user      ; query thye user if config_cmd
 28251                                  ;       jc	short tryy	; has the CONFIG_OPTION_QUERY bit set
 28252                                  ;       call    set_numlock
 28253                                  ;       jc	short err
 28254                                  ;       jmp	short sr110	; all done
 28255                                  ;
 28256                                  ;;endif	;MULTI_CONFIG
 28257                                  
 28258                                  ; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 28259                                  ;;-------------------------------------------------------------------------
 28260                                  ;; comment= do nothing. just decrese chrptr,and increase count for correct
 28261                                  ;;		line number
 28262                                  ;;-------------------------------------------------------------------------
 28263                                  ;
 28264                                  ;tryy:
 28265                                  ;       cmp     ah,CONFIG_COMMENT ; 'Y'
 28266                                  ;	jne	short try0
 28267                                  ;donothing:
 28268                                  ;	dec	word [chrptr]
 28269                                  ;	inc	word [count]
 28270                                  ;	jmp	coff
 28271                                  ;
 28272                                  ;;------------------------------------------------------------------------
 28273                                  ;; rem command
 28274                                  ;;------------------------------------------------------------------------
 28275                                  ;
 28276                                  ;try0:				;do nothing with this line.
 28277                                  ;	cmp     ah,CONFIG_REM ; '0'
 28278                                  ;	je	short donothing
 28279                                  
 28280                                  ; 30/10/2022
 28281                                  ; (MSSOS 5.0 IO.SYS - SYSINIT:29D7h)
 28282                                  
 28283                                  ;------------------------------------------------------------------------
 28284                                  ; bogus command
 28285                                  ;------------------------------------------------------------------------
 28286                                  
 28287                                  tryz:
 28288 000026C6 80FCFF                          cmp     ah,0FFh		;null command? (BUGBUG - who sets FFh anyway?)
 28289                                  	;je	short donothing
 28290                                  	; 02/11/2022
 28291 000026C9 740A                    	je	short tryz_donothing
 28292                                  
 28293 000026CB FF0E[D603]              	dec	word [chrptr]
 28294 000026CF FF06[D203]              	inc	word [count]
 28295 000026D3 EB26                    	jmp	short badop
 28296                                  
 28297                                  	; 02/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 28298                                  tryz_donothing:
 28299 000026D5 E95DFF                  	jmp	donothing
 28300                                  
 28301                                  ; 07/04/2019 - Retro DOS v4.0
 28302                                  
 28303                                  ;------------------------------------------------------------------------------
 28304                                  
 28305                                  ; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 28306                                  ;
 28307                                  ;
 28308                                  ;;***	CheckProtmanArena -- special hack for adjusting alloclim with Protman$
 28309                                  ;;
 28310                                  ;;	adjusts alloclim if Protman$ reduced our arena through a manual hack.
 28311                                  ;
 28312                                  ;CheckProtmanArena:
 28313                                  ;	push	es
 28314                                  ;	mov	ax,[cs:area]	; get our arena header
 28315                                  ;	dec	ax
 28316                                  ;	mov	es,ax
 28317                                  ;	add	ax,[es:3]	; find end of arena
 28318                                  ;	inc	ax
 28319                                  ;	cmp	ax,[cs:ALLOCLIM] ; is it less than alloclim?
 28320                                  ;	ja	short CheckProtmanDone
 28321                                  ;
 28322                                  ;	mov	[cs:ALLOCLIM],ax ; reduce alloclim then
 28323                                  ;CheckProtmanDone:
 28324                                  ;	pop	es
 28325                                  ;	retn
 28326                                  
 28327                                  ;------------------------------------------------------------------------------
 28328                                  
 28329                                  sysinit_parse:
 28330                                  
 28331                                  ;------------------------------------------------------------------------------
 28332                                  ;set up registers for sysparse
 28333                                  ;in)	es:si -> command line in confbot
 28334                                  ;	di -> offset of the parse control definition.
 28335                                  ;
 28336                                  ;out)	calls sysparse.
 28337                                  ;	carry will set if parse error.
 28338                                  ;	*** the caller should check the eol condition by looking at ax
 28339                                  ;	*** after each call.
 28340                                  ;	*** if no parameters are found,then ax will contain a error code.
 28341                                  ;	*** if the caller needs to look at the synomym@ of the result,
 28342                                  ;	***  the caller should use cs:@ instead of es:@.
 28343                                  ;	cx register should be set to 0 at the first time the caller calls this
 28344                                  ;	 procedure.
 28345                                  ;	ax - exit code
 28346                                  ;	bl - terminated delimeter code
 28347                                  ;	cx - new positional ordinal
 28348                                  ;	si - set to pase scanned operand
 28349                                  ;	dx - selected result buffer
 28350                                  ;------------------------------------------------------------------------------
 28351                                  
 28352                                  	; 24/10/2022
 28353 000026D8 06                      	push	es			;save es,ds
 28354 000026D9 1E                      	push	ds
 28355                                  
 28356 000026DA 06                      	push	es
 28357 000026DB 1F                      	pop	ds			;now ds:si -> command line
 28358                                  
 28359 000026DC 0E                      	push	cs
 28360 000026DD 07                      	pop	es			;now es:di -> control definition
 28361                                  
 28362 000026DE 2E8C1E[3114]            	mov	[cs:badparm_seg],ds	;save the pointer to the parm
 28363 000026E3 2E8936[2F14]            	mov	[cs:badparm_off],si	;we are about to parse for badparm msg.
 28364                                  	;mov	dx,0
 28365                                  	; 04/01/2023
 28366 000026E8 29D2                    	sub	dx,dx ; 0
 28367 000026EA E8ECED                  	call	SysParse
 28368 000026ED 83F800                  	cmp	ax,_$P_No_Error	; 0	;no error
 28369                                  
 28370                                  ;**cas note:  when zero true after cmp, carry clear
 28371                                  
 28372                                  	;je	short ll4
 28373                                  	; 24/10/2022 (MSDOS 5.0 IO.SYS compatibility, SYSINIT:2A02h)
 28374                                  	; 12/12/2022
 28375 000026F0 7406                    	je	short en4 ; cf=0
 28376 000026F2 83F8FF                  	cmp	ax,_$P_RC_EOL ; 0FFFFh	;or the end of line?
 28377                                  	;jne	short if4
 28378                                  	; 12/12/2022
 28379 000026F5 7401                    	je	short en4 ; cf=0
 28380                                  
 28381                                  ; 12/12/2022
 28382                                  ;ll4:
 28383                                  ;	; 12/12/2022
 28384                                  ;	; cf=0
 28385                                  ;	;clc
 28386                                  ;	jmp	short en4
 28387                                  
 28388                                  if4:
 28389                                  	; 24/10/2022
 28390 000026F7 F9                      	stc
 28391                                  en4:
 28392 000026F8 1F                      	pop	ds
 28393 000026F9 07                      	pop	es
 28394 000026FA C3                      	retn
 28395                                  
 28396                                  ; 11/12/2022
 28397                                  %if 0
 28398                                  
 28399                                  ;----------------------------------------------------------------------------
 28400                                  ;
 28401                                  ; procedure : badop_p
 28402                                  ;
 28403                                  ;             same thing as badop,but will make sure to set ds register back
 28404                                  ;             to sysinitseg and return back to the caller.
 28405                                  ;
 28406                                  ;----------------------------------------------------------------------------
 28407                                  
 28408                                  badop_p:
 28409                                  	push	cs
 28410                                  	pop	ds		;set ds to configsys seg.
 28411                                  	mov	dx,badopm
 28412                                  	call	print
 28413                                          ;call	error_line
 28414                                  	;retn
 28415                                  	; 11/12/2022
 28416                                  	jmp	error_line
 28417                                  
 28418                                  %endif
 28419                                  
 28420                                  ;----------------------------------------------------------------------------
 28421                                  ;
 28422                                  ; label : badop
 28423                                  ;
 28424                                  ;----------------------------------------------------------------------------
 28425                                  
 28426                                  badop:	
 28427 000026FB BA[A037]                	mov	dx,badopm	;want to print command error "unrecognized command..."
 28428 000026FE E87A0C                  	call	print
 28429 00002701 E84200                  	call	error_line	;show "error in config.sys ..." .
 28430 00002704 E9EDF8                  	jmp	coff
 28431                                  
 28432                                  ;----------------------------------------------------------------------------
 28433                                  ;
 28434                                  ; procedure : badparm_p
 28435                                  ;
 28436                                  ;             show "bad command or parameters - xxxxxx"
 28437                                  ;             in badparm_seg,badparm_off -> xxxxx
 28438                                  ;
 28439                                  ;----------------------------------------------------------------------------
 28440                                  
 28441                                  	; 24/10/2022
 28442                                  badparm_p:
 28443                                  	; 11/12/2022
 28444                                  	; ds = cs
 28445                                  	; 11/12/2022
 28446                                  	;push	ds ; *
 28447 00002707 52                      	push	dx
 28448 00002708 56                      	push	si
 28449                                  
 28450                                  	; 11/12/2022
 28451                                  	; ds = cs
 28452                                  	;push	cs
 28453                                  	;pop	ds
 28454                                  
 28455 00002709 BA[C737]                	mov	dx,badparm
 28456 0000270C E86C0C                  	call	print			; "bad command or parameters - "
 28457 0000270F C536[2F14]              	lds	si,[badparm_ptr]
 28458                                  
 28459                                  ;	print "xxxx" until cr.
 28460                                  
 28461                                  do1:
 28462 00002713 8A14                    	mov	dl,[si]			; get next character
 28463 00002715 80FA0D                  	cmp	dl,cr ; 0Dh		; is a carriage return?
 28464 00002718 7407                    	je	short en1		; exit loop if so
 28465                                  
 28466 0000271A B402                    	mov	ah,2 ; STD_CON_OUTPUT	; function 2
 28467 0000271C CD21                    	int	21h			; display character
 28468 0000271E 46                      	inc	si			; next character
 28469 0000271F EBF2                    	jmp	short do1
 28470                                  en1:
 28471 00002721 0E                      	push	cs
 28472 00002722 1F                      	pop	ds
 28473                                  
 28474 00002723 BA[C437]                	mov	dx,crlfm
 28475 00002726 E8520C                  	call	print
 28476 00002729 E81A00                  	call	error_line
 28477                                  
 28478 0000272C 5E                      	pop	si
 28479 0000272D 5A                      	pop	dx
 28480                                  	; 11/12/2022
 28481                                  	;pop	ds ; *
 28482                                  badparmp_ret:
 28483 0000272E C3                      	retn
 28484                                  
 28485                                  ;----------------------------------------------------------------------------
 28486                                  ;
 28487                                  ; procedure : getchr
 28488                                  ;
 28489                                  ;----------------------------------------------------------------------------
 28490                                  
 28491                                  	; 24/10/2022
 28492                                  getchr:
 28493                                  	; 12/12/2022
 28494                                  	;push	cx
 28495                                  	;mov	cx,[count]
 28496                                  	;jcxz	nochar
 28497                                  	; 12/12/2022
 28498 0000272F 833E[D203]01            	cmp	word [count],1 
 28499 00002734 720F                    	jb	short nochar ; cf=1 ([count] = 0)
 28500                                  	
 28501 00002736 8B36[D603]              	mov	si,[chrptr]
 28502 0000273A 268A04                  	mov	al,[es:si]
 28503 0000273D FF0E[D203]              	dec	word [count]
 28504 00002741 FF06[D603]              	inc	word [chrptr]
 28505                                  	; 12/12/202
 28506                                  	; cf=0
 28507                                  	;clc
 28508                                  ;get_ret:
 28509                                  	;pop	cx
 28510                                  	;retn
 28511                                  nochar: 
 28512                                  	; 12/12/2022
 28513                                  	; cf=1
 28514                                  	;stc
 28515                                  	;jmp	short get_ret
 28516                                  	
 28517 00002745 C3                      	retn
 28518                                  
 28519                                  ; 11/12/2022
 28520                                  %if 0
 28521                                  
 28522                                  ;----------------------------------------------------------------------------
 28523                                  ;
 28524                                  ; procedure : incorrect_order
 28525                                  ;
 28526                                  ;             show "incorrect order in config.sys ..." message.
 28527                                  ;
 28528                                  ;----------------------------------------------------------------------------
 28529                                  
 28530                                  incorrect_order:
 28531                                  	mov	dx,badorder
 28532                                  	call	print
 28533                                  	call	showlinenum
 28534                                  	retn
 28535                                  
 28536                                  %endif
 28537                                  
 28538                                  ;----------------------------------------------------------------------------
 28539                                  ;
 28540                                  ; procedure : error_line
 28541                                  ;
 28542                                  ;             show "error in config.sys ..." message.
 28543                                  ;
 28544                                  ;----------------------------------------------------------------------------
 28545                                  
 28546                                  	; 11/12/2022
 28547                                  	; 24/10/2022
 28548                                  error_line:
 28549                                  	; 11/12/2022
 28550                                  	; ds = cs
 28551                                  	;push	cs
 28552                                  	;pop	ds
 28553                                  
 28554 00002746 BA[FC38]                	mov	dx,errorcmd
 28555 00002749 E82F0C                  	call	print
 28556                                  	;call	showlinenum
 28557                                  	;retn
 28558                                  	; 11/12/2022
 28559                                  	;jmp	short shortlinemum
 28560                                  
 28561                                  ;----------------------------------------------------------------------------
 28562                                  ;
 28563                                  ; procedure : showlinenum
 28564                                  ;
 28565                                  ; convert the binary linecount to decimal ascii string in showcount
 28566                                  ; and display showcount at the current curser position.
 28567                                  ; in.) linecount
 28568                                  ;
 28569                                  ; out) the number is printed.
 28570                                  ;
 28571                                  ;----------------------------------------------------------------------------
 28572                                  
 28573                                  	; 11/12/2022
 28574                                  	; ds = cs
 28575                                  	; 24/10/2022
 28576                                  showlinenum:
 28577 0000274C 06                      	push	es
 28578                                  	; 11/12/2022
 28579                                  	;push	ds
 28580 0000274D 57                      	push	di
 28581                                  
 28582 0000274E 0E                      	push	cs
 28583 0000274F 07                      	pop	es		; es=cs
 28584                                  
 28585                                  	; 11/12/2022
 28586                                  	;push	cs
 28587                                  	;pop	ds
 28588                                  
 28589 00002750 BF[3103]                	mov	di,showcount+4	; di -> the least significant decimal field.
 28590 00002753 B90A00                  	mov	cx,10		; decimal divide factor
 28591                                  	;mov	ax,[cs:linecount]
 28592                                  	; 11/12/2022
 28593 00002756 A1[2B03]                	mov	ax,[linecount]
 28594                                  sln_loop:
 28595                                  	; 11/12/2022
 28596 00002759 39C8                    	cmp	ax,cx ; < 10 ?
 28597                                  	;cmp	ax,10		; < 10?
 28598 0000275B 720C                    	jb	short sln_last
 28599                                  
 28600 0000275D 31D2                    	xor	dx,dx
 28601 0000275F F7F1                    	div	cx	; cx = 10
 28602 00002761 80CA30                  	or	dl,30h		; add "0" (= 30h) to make it an ascii.
 28603 00002764 8815                    	mov	[di],dl
 28604 00002766 4F                      	dec	di
 28605 00002767 EBF0                    	jmp	short sln_loop
 28606                                  
 28607                                  sln_last:
 28608 00002769 0C30                    	or	al,30h	; "0"
 28609 0000276B 8805                    	mov	[di],al
 28610 0000276D 89FA                    	mov	dx,di
 28611 0000276F E8090C                  	call	print		; show it.
 28612 00002772 5F                      	pop	di
 28613                                  	; 11/12/2022
 28614                                  	;pop	ds
 28615 00002773 07                      	pop	es
 28616 00002774 C3                      	retn
 28617                                  
 28618                                  ; 07/04/2019 - Retro DOS v4.0
 28619                                  ; (MSDOS 6.21 IO.SYS, SYSINIT:2E44h)
 28620                                  
 28621                                  ;----------------------------------------------------------------------------
 28622                                  ;
 28623                                  ; procedure : ProcDOS
 28624                                  ;
 28625                                  ;	Process the result of DOS= parsing
 28626                                  ;
 28627                                  ;	result_val._$P_item_tag	= 1 for DOS=HIGH
 28628                                  ;				= 2 for DOS=LOW
 28629                                  ;				= 3 for DOS=UMB
 28630                                  ;				= 4 for DOS=NOUMB
 28631                                  ;----------------------------------------------------------------------------
 28632                                  
 28633                                  	; 01/11/2022 - Retro DOS v4.0 (Modififed MSDOS 5.0 IO.SYS)
 28634                                  	; (SYTSINIT:2AB5h)
 28635                                  ProcDOS:
 28636                                  	; 01/01/2023
 28637                                  	; ds = cs
 28638 00002775 30E4                    	xor	ah,ah
 28639                                  	;;mov	al,[cs:result_val_itag]
 28640                                  	;mov	al,[cs:result_val+_$P_Result_Blk.Item_Tag]
 28641                                  	; 04/01/2023
 28642 00002777 A0[451D]                	mov	al,[result_val+_$P_Result_Blk.Item_Tag]
 28643 0000277A 48                      	dec	ax
 28644 0000277B 7415                    	jz	short pd_hi
 28645 0000277D 48                      	dec	ax
 28646 0000277E 740E                    	jz	short pd_lo
 28647 00002780 48                      	dec	ax
 28648 00002781 7405                    	jz	short pd_umb
 28649                                  	;;mov	byte [cs:DevUMB],0
 28650                                  	; 18/12/2022
 28651                                  	;mov	byte [cs:DevUMB],ah ; 0
 28652                                  	; 01/01/2023
 28653 00002783 8826[EC1E]              	mov	byte [DevUMB],ah ; 0
 28654 00002787 C3                      	retn
 28655                                  pd_umb:
 28656                                  	; 04/01/2023
 28657 00002788 C606[EC1E]FF            	mov	byte [DevUMB],0FFh
 28658                                  	;mov	byte [cs:DevUMB],0FFh
 28659 0000278D C3                      	retn
 28660                                  pd_lo:
 28661                                  	; 04/01/2023
 28662 0000278E A2[6A02]                	mov	[runhigh],al ; 0
 28663                                  	; 18/12/2022
 28664                                  	;mov	[cs:runhigh],al ; 0
 28665                                  	;;mov	byte [cs:runhigh],0
 28666 00002791 C3                      	retn
 28667                                  pd_hi:
 28668                                  	; 04/01/2023
 28669 00002792 C606[6A02]FF            	mov	byte [runhigh],0FFh
 28670                                  	;mov	byte [cs:runhigh],0FFh
 28671                                  limx:	; 11/12/2022
 28672 00002797 C3                      	retn
 28673                                  
 28674                                  ;----------------------------------------------------------------------------
 28675                                  ;
 28676                                  ; procedure : LieInt12Mem
 28677                                  ;
 28678                                  ;	Input : DevEntry points to Device Start address (offset == 0)
 28679                                  ;		alloclim set to the limit of low memory.
 28680                                  ;
 28681                                  ;	Output : none
 28682                                  ;
 28683                                  ;	Changes the ROM BIOS variable which stores the total low memory
 28684                                  ;	If a 3com device driver (any character device with name 'PROTMAN$')
 28685                                  ;	is being loaded alloclim is converted into Ks and stored in 40:13h
 28686                                  ;	Else if a device driver being loaded into UMB the DevLoadEnd is
 28687                                  ;	converted into Ks and stored in 40:13h
 28688                                  ;
 28689                                  ;----------------------------------------------------------------------------
 28690                                  
 28691                                  LieInt12Mem:
 28692                                  	; 11/12/2022
 28693                                  	; ds = cs
 28694 00002798 A1[A302]                	mov	ax,[ALLOCLIM]
 28695                                  	;mov	ax,[cs:ALLOCLIM]	; lie INT 12 as alloclim
 28696                                  					; assuming that it is 3Com
 28697 0000279B E84400                  	call	IsIt3Com		; Is it 3Com driver?
 28698 0000279E 740A                    	jz	short lim_set		; yes, lie to him differently
 28699                                  	; 13/05/2019
 28700                                  	;cmp	byte [cs:DeviceHi],0	; Is the DD being loaded in UMB
 28701                                  	;je	short limx		; no, don't lie
 28702                                  	;mov	ax,[cs:DevLoadEnd]	; lie INT 12 as end of UMB
 28703                                  	; 11/12/2022
 28704                                  	; ds = cs
 28705 000027A0 803E[FB1E]00            	cmp	byte [DeviceHi],0
 28706 000027A5 74F0                    	je	short limx
 28707 000027A7 A1[E21E]                	mov	ax,[DevLoadEnd]
 28708                                  lim_set:
 28709                                  	; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 28710                                  	; 11/12/2022
 28711                                  	;call	SetInt12Mem
 28712                                  ;limx:
 28713                                  	;retn
 28714                                  	
 28715                                  	;jmp	short SetInt12Mem 
 28716                                  
 28717                                  ;----------------------------------------------------------------------------
 28718                                  ;
 28719                                  ; procedure : SetInt12Mem
 28720                                  ;
 28721                                  ;	Input : AX = Memory size to be set (in paras)
 28722                                  ;	Output : none
 28723                                  ;
 28724                                  ;	Sets the variable 40:13 to the memory size passed in AX
 28725                                  ;	It saves the old value in 40:13 in OldInt12Mem,
 28726                                  ;	It also sets a flag Int12Lied to 0ffh, which is checked before
 28727                                  ;	restoring the value of 40:13
 28728                                  ;
 28729                                  ;----------------------------------------------------------------------------
 28730                                  
 28731                                  	; 01/11/2022
 28732                                  SetInt12Mem:
 28733 000027AA 1E                      	push	ds
 28734 000027AB BB4000                  	mov	bx,40h
 28735 000027AE 8EDB                    	mov	ds,bx			; ROM BIOS Data Segment
 28736 000027B0 8B1E1300                	mov	bx,[13h]		; INT 12 memory variable
 28737 000027B4 2E891E[FF1E]            	mov	[cs:OldInt12Mem],bx	; save it
 28738 000027B9 B106                    	mov	cl,6
 28739 000027BB D3E8                    	shr	ax,cl			; convert paras into Ks
 28740 000027BD A31300                  	mov	[13h],ax		; Lie
 28741 000027C0 2EC606[FE1E]FF          	mov	byte [cs:Int12Lied],0FFh ; mark that we are lying
 28742 000027C6 1F                      	pop	ds
 28743                                  ;limx:
 28744 000027C7 C3                      	retn
 28745                                  
 28746                                  ;----------------------------------------------------------------------------
 28747                                  ;
 28748                                  ; procedure : TrueInt12Mem
 28749                                  ;
 28750                                  ;	Input : Int12Lied = 0 if we are not lying currently
 28751                                  ;			  = 0ffh if we are lying
 28752                                  ;		OldInt12Mem = Saved value of 40:13h
 28753                                  ;
 28754                                  ;	Output : none
 28755                                  ;
 28756                                  ;	Resets the INT 12 Memory variable if we were lying about int 12
 28757                                  ;	and resets the flag which indicates that we were lying
 28758                                  ;
 28759                                  ;----------------------------------------------------------------------------
 28760                                  
 28761                                  TrueInt12Mem:
 28762                                  	; 11/12/2022
 28763                                  	; ds = cs
 28764 000027C8 803E[FE1E]00            	cmp	byte [Int12Lied],0
 28765                                  	;cmp	byte [cs:Int12Lied],0	; were we lying so far?
 28766                                  	; 01/11/2022 (MSDOS 5.0 IO.SYS, SYS.INIT:2B1Dh)
 28767                                  	;mov	byte [cs:Int12Lied],0	; reset it anyway
 28768 000027CD 7412                    	je	short timx		; no, we weren't
 28769                                  	; 18/12/2022
 28770 000027CF B84000                  	mov	ax,40h
 28771 000027D2 8826[FE1E]              	mov	[Int12Lied],ah ; 0
 28772                                  	;mov	byte [Int12Lied],0
 28773                                  	;mov	byte [cs:Int12Lied],0
 28774 000027D6 1E                      	push	ds
 28775                                  	;mov	ax,40h
 28776 000027D7 8ED8                    	mov	ds,ax
 28777 000027D9 2EA1[FF1E]              	mov	ax,[cs:OldInt12Mem]
 28778 000027DD A31300                  	mov	[13h],ax		; restore INT 12 memory
 28779 000027E0 1F                      	pop	ds
 28780                                  timx:
 28781 000027E1 C3                      	retn
 28782                                  
 28783                                  ;----------------------------------------------------------------------------
 28784                                  ;
 28785                                  ; procedure : IsIt3Com?
 28786                                  ;
 28787                                  ;	Input : DevEntry = Seg:0 of device driver
 28788                                  ;	Output : Zero flag set if device name is 'PROTMAN$'
 28789                                  ;		 else Zero flag is reset
 28790                                  ;
 28791                                  ;----------------------------------------------------------------------------
 28792                                  
 28793                                  IsIt3Com:
 28794                                  	; 11/12/2022
 28795                                  	; ds = cs
 28796 000027E2 1E                      	push	ds
 28797 000027E3 06                      	push	es
 28798 000027E4 56                      	push	si
 28799                                  	; 11/12/2022
 28800 000027E5 C536[E41E]              	lds	si,[DevEntry]
 28801                                  	;lds	si,[cs:DevEntry]	; ptr to device header
 28802 000027E9 83C60A                  	add	si,SYSDEV.NAME ; 10 	; ptr device name
 28803 000027EC 0E                      	push	cs
 28804 000027ED 07                      	pop	es
 28805 000027EE BF[011F]                	mov	di,ThreeComName
 28806 000027F1 B90800                  	mov	cx,8			; name length
 28807 000027F4 F3A6                    	rep	cmpsb
 28808 000027F6 5E                      	pop	si
 28809 000027F7 07                      	pop	es
 28810 000027F8 1F                      	pop	ds
 28811 000027F9 C3                      	retn
 28812                                  
 28813                                  ;M020 : BEGIN
 28814                                  ;----------------------------------------------------------------------------
 28815                                  
 28816                                  UpdatePDB:
 28817 000027FA 1E                      	push	ds
 28818 000027FB B462                    	mov	ah,62h
 28819 000027FD CD21                    	int	21h	; DOS - 3+ - GET PSP ADDRESS
 28820 000027FF 8EDB                    	mov	ds,bx
 28821 00002801 2E8B1E[A302]            	mov	bx,[cs:ALLOCLIM]
 28822                                  	;mov	[2],bx
 28823 00002806 891E0200                	mov	[PDB.BLOCK_LEN],bx
 28824 0000280A 1F                      	pop	ds
 28825 0000280B C3                      	retn
 28826                                  
 28827                                  ; M020 : END
 28828                                  
 28829                                  ;----------------------------------------------------------------------------
 28830                                  
 28831                                  ; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 28832                                  
 28833                                  %if 0
 28834                                  
 28835                                  ;include highload.inc	; Routines for devicehigh parsing, control of HIDDEN
 28836                                  ;include highexit.inc	; umb's, etc
 28837                                  
 28838                                  ; ----------------------------------------------------------------------
 28839                                  ; HIGHLOAD.INC (MSDOS 6.0 - 1991) 	
 28840                                  ; ----------------------------------------------------------------------
 28841                                  ; 07/04/2019 - Retro DOS v4.0
 28842                                  
 28843                                  ;******************************************************************************
 28844                                  ;
 28845                                  ; This file contains routines needed to parse and implement user-given
 28846                                  ; command-line options of the form "/S/L:3,0x500;2;7,127;0x0BE4". InitVar()
 28847                                  ; and Parsevar() are used to parse this data and place it in encoded form into
 28848                                  ; the variables in highvar.inc, for use by the rest of the routines.
 28849                                  ;
 28850                                  ; DeviceHigh accepts this command-line (handled in sysconf.asm, not here):
 28851                                  ;    DEVICEHIGH SIZE=hhhhhh module opts
 28852                                  ; Or, DeviceHigh and LoadHigh accept any of the following:
 28853                                  ;    DH/LH module opts
 28854                                  ;    DH/LH [/S][/L:umb[,size][;umb[,size]]*] module opts
 28855                                  ;    DH/LH [/L:umb[,size][;umb[,size]]*][/S] module opts
 28856                                  ; The initial UMB,SIZE pair designates the module's load address; the remainder
 28857                                  ; of the UMB and SIZE pairs are used to indicate specific UMBs to be left
 28858                                  ; available during the load.
 28859                                  ;
 28860                                  ; When an actual load is ready to be performed, a call to HideUMBs() will
 28861                                  ; temporarily allocate (as owner 8+"HIDDEN  ") all free elements in any
 28862                                  ; upper-memory block which was not specified by the user... in addition, if
 28863                                  ; UMBs were marked to shrink (/S option) to a certain size ("umb,size"), any
 28864                                  ; elements in that umb SAVE the lower-half of the newly-shrunken one are also
 28865                                  ; allocated.  After the load, the function UnHideUMBs() (in highexit.inc) will
 28866                                  ; free any UMBs so allocated.
 28867                                  ;
 28868                                  ; When a device driver loads, there is the additional problem of allocating its
 28869                                  ; initial load site; this should be restricted to the first UMB specified on
 28870                                  ; the command-line. The function FreezeUM temporarily allocates all remaining
 28871                                  ; free upper-memory elements (as owner 8+"FROZEN  "), except those in the load
 28872                                  ; UMB. Then the initial allocation may be made, and a call to UnFreeze will
 28873                                  ; return any so-allocated memory elements to FREE, for the true load. Note
 28874                                  ; that UnFreeze leaves HIDDEN elements allocated; it only frees FROZEN ones.
 28875                                  ;
 28876                                  ;******************************************************************************
 28877                                  
 28878                                  SWTCH	equ	'/'		; Switch character
 28879                                  
 28880                                  DOS_CHECK_STRATEGY  equ	5800h	; Int 21h, Func 58h, Svc 0 = check alloc strat
 28881                                  DOS_SET_STRATEGY    equ	5801h	; Int 21h, Func 58h, Svc 1 = set alloc strategy
 28882                                  DOS_CHECK_UMBLINK   equ	5802h	; Int 21h, Func 58h, Svc 2 = check link state
 28883                                  DOS_GET_UMBLINK	    equ 5802h ; 20/04/2019
 28884                                  DOS_SET_UMBLINK     equ	5803h	; Int 21h, Func 58h, Svc 3 = set link state
 28885                                  DOS_GET_DOS_LISTS   equ	  52h	; Int 21h, Func 52h = return list of lists
 28886                                  DOS_UMB_HEAD        equ	  8Ch	; Offset from ES (after func52h) to get UMBHead
 28887                                  
 28888                                  CR	equ	0Dh		; Carriage Return
 28889                                  LF	equ	0Ah		; Line Feed
 28890                                  TAB	equ	09h		; Tab character (^I)
 28891                                  
 28892                                  ; -----------------------------------------------------------------------------
 28893                                  ;*** InitVar - initializes all the variables used in ParseVar and HideUMBs
 28894                                  ; -----------------------------------------------------------------------------
 28895                                  ; ENTRY:       None
 28896                                  ; EXIT:        Variables listed in highvar.inc are initialized
 28897                                  ; ERROR EXIT:  None
 28898                                  ; USES:        Flags, variables in highvar.inc
 28899                                  ; -----------------------------------------------------------------------------
 28900                                  ; Note that element 0 references UMB 0 (conventional), not UMB 1.  Its contents
 28901                                  ; are largely ignored, but it is initialized nonetheless.
 28902                                  ; -----------------------------------------------------------------------------
 28903                                  
 28904                                  InitVar:
 28905                                  	;pushreg <ax, cx, di, es>
 28906                                  	push	ax
 28907                                  	push	cx
 28908                                  	push	di
 28909                                  	push	es
 28910                                  
 28911                                  	;dataseg es			;Point ES into appropriate data segment
 28912                                  	push	cs
 28913                                  	pop	es
 28914                                  
 28915                                  	xor	ax,ax
 28916                                  	mov	[es:fUmbTiny],al	;Shrink UMBs? (made 1 if /S given)
 28917                                  	mov	[es:fInHigh],al		;Set to 1 when DH/LH has been called
 28918                                  	mov	[es:SegLoad],ax		;Load Address (seg), used for DH only
 28919                                  	mov	byte [es:UmbLoad],UNSPECIFIED ; 0FFh
 28920                                  					;Later is the # of the 1st spec'd UMB
 28921                                  	mov	[es:fm_argc], al	;Start with zero args having been read
 28922                                  
 28923                                  	cld
 28924                                  
 28925                                  	mov	cx,MAXUMB ; 16		;For each entry
 28926                                  	mov	di,UmbUsed		;on the UmbUsed array,
 28927                                  	rep	stosb			;	Store 0
 28928                                  
 28929                                  	mov	cx,MAXUMB ; 16		;Okay... for each entry
 28930                                  	mov	di,UmbSize		;on the UmbSize array,
 28931                                  	rep	stosw			;	Store 0
 28932                                  
 28933                                  	;normseg es			; Return ES
 28934                                  
 28935                                  	;popreg	<es, di, cx, ax>
 28936                                  	pop	es
 28937                                  	pop	di
 28938                                  	pop	cx
 28939                                  	pop	ax	 	
 28940                                  
 28941                                  	retn
 28942                                  
 28943                                  ; -----------------------------------------------------------------------------
 28944                                  ;*** FixMem - scans the upper memory chain and concatenates adjacent free MCBs
 28945                                  ; -----------------------------------------------------------------------------
 28946                                  ; ENTRY   : None
 28947                                  ; EXIT    : None
 28948                                  ; ERROR   : None
 28949                                  ; USES    : Flags, fm_umb, fm_strat
 28950                                  ; -----------------------------------------------------------------------------
 28951                                  
 28952                                  FixMem:
 28953                                  	push	ax
 28954                                  	push	bx
 28955                                  	push	cx
 28956                                  	push	dx
 28957                                  	push	es
 28958                                  
 28959                                  	call	fm_link		; Link in UMBs
 28960                                  
 28961                                  	call	UmbHead		; Get first upper-memory MCB address (0x9FFF)
 28962                                  	jc	short fmX	; (if couldn't get it, leave now).
 28963                                  
 28964                                  	mov	es,ax		; It returns in AX, so move it to ES.
 28965                                  
 28966                                  ; - Walk MCB Chain ------------------------------------------------------------
 28967                                  
 28968                                  	xor	dx,dx		; We're keeping the address of the last MCB
 28969                                  	mov 	cx,dx		; in CX... and the last owner
 28970                                  	inc	dx		; in dx as we go through the loop:
 28971                                  
 28972                                  ; ------------------------------------------
 28973                                  ; FM10--DX  = last MCB's owner's PSP address
 28974                                  ;       CX  = last MCB's address (segment)
 28975                                  ; ------------------------------------------
 28976                                  
 28977                                  fm10:	mov	al,[es:ARENA.SIGNATURE] ; if 'Z', don't repeat loop
 28978                                  	mov	bx,[es:ARENA.OWNER]	; if not zero, do nothing
 28979                                  	or	bx,dx			; dx was owner of previous MCB
 28980                                  	jnz	short fm30		; If not both zero, don't cat.
 28981                                  
 28982                                  	; - Coalesce memory blocks at ES:00 and CX:00 -------------------------
 28983                                  
 28984                                  fm20:	mov	bx,[es:ARENA.SIZE]	; Grab this block's Size,
 28985                                  	mov	es,cx			; Go back to prev MCB's address
 28986                                  	mov	[es:ARENA.SIGNATURE],al ; & move the SECOND sig here
 28987                                  
 28988                                  	add	bx,[es:ARENA.SIZE]	; Size += first MCB's size
 28989                                  	add	bx,1			; And add one for the header
 28990                                  	mov	[es:ARENA.SIZE],bx	; Write the size
 28991                                  
 28992                                  	; ---------------------------------------------------------------------
 28993                                  
 28994                                  fm30:	mov	cx,es			; Put this address on the stack
 28995                                  	mov	dx,[es:ARENA.OWNER]	; And remember its owner
 28996                                  
 28997                                  	mov	bx,es			; Move to the next MCB
 28998                                  	add	bx,[es:ARENA.SIZE]
 28999                                  	inc	bx
 29000                                  	mov	es,bx
 29001                                  
 29002                                  	;cmp	al,'Z'
 29003                                  	cmp	al,arena_signature_end
 29004                                  	jne	short fm10		; If signature != 'Z', there are more.
 29005                                  fmX:	
 29006                                  	call	fm_unlink		; Unlink UMBs
 29007                                  
 29008                                  	pop	es
 29009                                  	pop	dx
 29010                                  	pop	cx
 29011                                  	pop	bx
 29012                                  	pop	ax
 29013                                  
 29014                                  	retn
 29015                                  
 29016                                  ; -----------------------------------------------------------------------------
 29017                                  ;*** fm_link - links UMBs not already linked in
 29018                                  ; -----------------------------------------------------------------------------
 29019                                  ; ENTRY:    None
 29020                                  ; EXIT:     fm_umb == 0 if not linked in previously, 1 if already linked in
 29021                                  ; ERROR:    None
 29022                                  ; USES:     AX, BX, fm_umb
 29023                                  ; -----------------------------------------------------------------------------
 29024                                  
 29025                                  fm_link:
 29026                                  	mov	ax,DOS_CHECK_UMBLINK ; 5802h
 29027                                  	int	21h			; Current link-state is now in al
 29028                                  
 29029                                  	;putdata fm_umb,al		; So store it in fm_umb for later
 29030                                  	;
 29031                                  	;push	es
 29032                                  	;push	cs
 29033                                  	;pop	es
 29034                                  	;mov	[es:fm_umb],al
 29035                                  	;pop	es
 29036                                  	
 29037                                  	mov	[cs:fm_umb],al
 29038                                  
 29039                                  	mov	ax,DOS_SET_UMBLINK ; 5803h
 29040                                  	mov	bx,1
 29041                                  	int	21h
 29042                                  	retn
 29043                                  
 29044                                  ; -----------------------------------------------------------------------------
 29045                                  ;*** fm_unlink - unlinks UMBs if fm_umb is set to 0
 29046                                  ; -----------------------------------------------------------------------------
 29047                                  ; ENTRY:    fm_umb == 1 : leave linked, else unlink
 29048                                  ; EXIT:     None
 29049                                  ; ERROR:    None
 29050                                  ; USES:     AX, BX
 29051                                  ; -----------------------------------------------------------------------------
 29052                                  
 29053                                  fm_unlink:
 29054                                  	xor	bx,bx
 29055                                  	
 29056                                  	;getdata bl,fm_umb		; fm_umb already has the old link-state
 29057                                  	;
 29058                                  	;push	ds
 29059                                  	;push	cs
 29060                                  	;pop	ds
 29061                                  	;mov	bl,[fm_umb]	
 29062                                  	;pop	ds
 29063                                  	
 29064                                  	mov	bl,[cs:fm_umb]
 29065                                  
 29066                                  	mov	ax,DOS_SET_UMBLINK ; 5803h
 29067                                  	int	21h			; so just use that, and call int 21h
 29068                                  	retn
 29069                                  
 29070                                  ; 08/04/2019 - Retro DOS v4.0
 29071                                  
 29072                                  ; -----------------------------------------------------------------------------
 29073                                  ;*** ParseVar - parses [/S][/L:umb[,size][;umb[,size]]*] and builds the table
 29074                                  ; laid out in highvar.inc
 29075                                  ; -----------------------------------------------------------------------------
 29076                                  ; ENTRY:    ES:SI points to command tail of LoadHigh/DeviceHigh (whitespace ok)
 29077                                  ; EXIT:     ES:SI points to first character in child program name
 29078                                  ; ERROR:    ES:SI points to character which caused error, carry set, AX == code
 29079                                  ; USES:     ES:SI, AX, flags, variables in highvar.inc
 29080                                  ; -----------------------------------------------------------------------------
 29081                                  ; Error codes (in AX if carry set on return):
 29082                                  ;
 29083                                  PV_InvArg	equ	1	; Invalid argument passed
 29084                                  PV_BadUMB	equ	2	; Bad UMB number passed (duplicate?)
 29085                                  PV_InvSwt	equ	3	; Unrecognized switch passed
 29086                                  ;
 29087                                  ; This routine exects ES:SI to point to a string much like the following:
 29088                                  ;    "/S/L:1,200;2 module options"
 29089                                  ; Optionally, the string can begin with whitespace; neither /S nor /L is
 29090                                  ; required, though that's what this routine is supposed to parse.
 29091                                  ;
 29092                                  optS		equ	'S'	; /S
 29093                                  optL		equ	'L'	; /L:...
 29094                                  ;
 29095                                  ; -----------------------------------------------------------------------------
 29096                                  ; LoadHigh has a list of arguments, returned by cparse, which is used to create
 29097                                  ; a command-line for spawning a child process. For a typical LH command, say,
 29098                                  ;     lh /l:1,1000;2 print/d:lpt2
 29099                                  ; the arguments would look like (one per line):
 29100                                  ;     lh
 29101                                  ;     /l
 29102                                  ;     1
 29103                                  ;     1000
 29104                                  ;     2
 29105                                  ;     print
 29106                                  ;     /d
 29107                                  ;     :lpt2
 29108                                  ; In short, if "print" were, say, "43", there'd be no way to determine which
 29109                                  ; arg was the filename. So, inside this routine, we keep a running counter
 29110                                  ; of the number of arguments LH will need to skip in order to get to the
 29111                                  ; program name. The "lh" is implicit--it'll always have to skip that. So if
 29112                                  ; there's no "/l" or "/s", fm_argc will be 0 ... other than that, 1 is added
 29113                                  ; for:
 29114                                  ;    Each /L
 29115                                  ;    Each /S (there should be only one)
 29116                                  ;    Each UMB number (they follow ":" or ";")
 29117                                  ;    Each UMB size   (they follow ",")
 29118                                  ; So, in the above example, fm_argc would be 4-- and LH would skip right to
 29119                                  ; "print".  Note that InitVar initializes fm_argc to zero.
 29120                                  ; -----------------------------------------------------------------------------
 29121                                  
 29122                                  ParseVar:
 29123                                  	;pushreg <di, ds, es>
 29124                                  	push	di
 29125                                  	push	ds
 29126                                  	push	es
 29127                                  
 29128                                  	push	es		; Make DS:SI point to it, as well as ES:SI
 29129                                  	pop	ds		; (regardless if we're in devhigh or loadhigh)
 29130                                  	cld
 29131                                  
 29132                                  ; ------------------------------------------------
 29133                                  ; PV10--ES:SI = any whitespace on the command-line
 29134                                  ; ------------------------------------------------
 29135                                  
 29136                                  pv10:	lodsb			; here, ES:SI=="  /L..."--must eat whitespace
 29137                                  	call	isWhite
 29138                                  	jz	short pv10	;       ES:SI==" /L..."--keep eating.
 29139                                  	;cmp	al,'/'
 29140                                  	cmp	al,SWTCH
 29141                                  	je	short pv20	;       ES:SI=="/L..."--go process a switch
 29142                                  
 29143                                  	dec	si		; Backup--it's now "odule options", and we need
 29144                                  	clc			; that "m" we just read (or whatever it is).
 29145                                  	jmp	short pvX	; Then return with carry clear == we're done.
 29146                                  
 29147                                  pv20:	lodsb			; Just read 'S' or 'L', hopefully
 29148                                  	;toUpper al		; So we make it upper-case, and...
 29149                                  	and	al,0DFh
 29150                                  	;cmp	al,'S'
 29151                                  	cmp	al,optS		; just read 'S'?
 29152                                  	jne	short pv30
 29153                                  
 29154                                  	;call	incArgc		; If it's /S, it's another arg for LH to skip.
 29155                                  	inc	byte [cs:fm_argc] ; 19/04/2019
 29156                                  
 29157                                  	;putdata fUmbTiny,1	; /S, so ES:SI=="  /L..." or " module opts", or
 29158                                  	;
 29159                                  	;push	es
 29160                                  	;push	cs
 29161                                  	;pop	es
 29162                                  	;mov	[es:fUmbTiny],1	
 29163                                  	;pop	es
 29164                                  
 29165                                  	mov	byte [cs:fUmbTiny],1
 29166                                  
 29167                                  	jmp	short pv10	; possibly even "/L...".
 29168                                  
 29169                                  pv30:	;cmp	al,'L'
 29170                                  	cmp	al,optL		; If it's not 'L' either, then 'tis a bad
 29171                                  	jne	short pvE1		; switch!
 29172                                  
 29173                                  	;call	incArgc		; If it's /L, it's another arg for LH to skip.
 29174                                  	inc	byte [cs:fm_argc] ; 19/04/2019
 29175                                  
 29176                                  	call	parseL
 29177                                  	jnc	short pv10	; If no carry, go back and look for more
 29178                                  
 29179                                  	dec	si		; Else, back up and exit.
 29180                                  	jmp	short pvErr	; AX has already been set by parseL
 29181                                  
 29182                                  pvE1:	;mov	ax,3
 29183                                  	mov	ax,PV_InvSwt	; Unrecognized switch passed
 29184                                  pvErr:	dec	si
 29185                                  	dec	si
 29186                                  	stc
 29187                                  pvX:	;popreg	<es, ds, di>
 29188                                  	pop	es
 29189                                  	pop	ds
 29190                                  	pop	di
 29191                                  	retn
 29192                                  
 29193                                  ; -----------------------------------------------------------------------------
 29194                                  ;*** parseL - parses ":nnnn[,nnnn][;nnnn[,nnnn]]*" for ParseVar
 29195                                  ; -----------------------------------------------------------------------------
 29196                                  ; ENTRY:    ES:SI points to colon
 29197                                  ; EXIT:     ES:SI points to first character not parsed
 29198                                  ; ERROR:    Carry set; rewind three characters and return (see ParseVar)
 29199                                  ; USES:     ES:SI, flags, AX, CX, DX, variables in highvar.inc
 29200                                  ; -----------------------------------------------------------------------------
 29201                                  ; If the string here is terminated with anything other than whitespace or a
 29202                                  ; switchchar (perhaps it's /S or another /L:... ), then we return with carry
 29203                                  ; set, indicating that they've screwed up the syntax.  The 3-character rewind
 29204                                  ; makes sure the app /L: is reported as being the culprit.
 29205                                  ; -----------------------------------------------------------------------------
 29206                                  
 29207                                  parseL:
 29208                                  	lodsb
 29209                                  	cmp	al,':'		; Make sure they did /L:
 29210                                  	jne	short plE1	; If they didn't, return with carry set.
 29211                                  
 29212                                  ; ------------------------------------------
 29213                                  ; PL10--ES:SI = a UMB number, after /L: or ;
 29214                                  ; ------------------------------------------
 29215                                  
 29216                                  pl10:	call	GetXNum		; After this, 'tis ",size" or ";umb" or " mod"
 29217                                  	jc	short plE2	; And error if it's a bad number.
 29218                                  	call	convUMB		; Convert any address to a UMB number
 29219                                  
 29220                                  	mov	cl,al		; Remember the UMB number
 29221                                  	call	stowUMB		; Mark this UMB # as used;
 29222                                  	jc	short plE2	; If it was already marked, it'll error
 29223                                  
 29224                                  	;call	incArgc		; Each UMB number is another arg for LH to skip
 29225                                  	inc	byte [cs:fm_argc] ; 08/04/2019 - Retro DOS v4.0
 29226                                  
 29227                                  	lodsb
 29228                                  	cmp	al,';'		; Did "umb;" ?
 29229                                  	je	short pl10	; Yep: go back and get another UMB.
 29230                                  
 29231                                  	call	isWhite		; Did "umb " ?
 29232                                  	jz	short plX	; Yep: return (it'll go back to whitespace)
 29233                                  
 29234                                  	call	isEOL		; Did "umb" ?
 29235                                  	jz	short plSwX	; If so, backup and exit like everything's ok
 29236                                  
 29237                                  	;cmp	al,'/'
 29238                                  	cmp	al,SWTCH 	; Did "umb/" ? (as in, "/L:1,100;2/S")
 29239                                  	je	short plSwX	; If so, back up ES:SI one character and return
 29240                                  
 29241                                  	cmp	al,','		; Did "umb," ?
 29242                                  	jne	short plE1	; Just what the heck DID they do? Return error.
 29243                                  
 29244                                  ; --- Read a size -------------------------------------------------------------
 29245                                  
 29246                                  	call	GetXNum		; Stop on "size;" or "size " or anything else
 29247                                  	jc	short plE1	; And error if it's a bad size.
 29248                                  
 29249                                  	call	toPara		; Convert from bytes to paragraphs
 29250                                  
 29251                                  	call	stowSiz		; CL still has the UMB number for this routine
 29252                                  
 29253                                  	;call	incArgc		; Each UMB size is another arg for LH to skip
 29254                                  	inc	byte [cs:fm_argc] ; 08/04/2019 - Retro DOS v4.0
 29255                                  
 29256                                  	lodsb
 29257                                  	cmp	al,';'		; They did "umb,size;", so get another UMB.
 29258                                  	je	short pl10	;
 29259                                  
 29260                                  	call	isWhite		; Did it end with whitespace?
 29261                                  	jz	short plX	; If so, we're done here--go back.
 29262                                  
 29263                                  	call	isEOL		; Did they do "umb,size" and end??? (stupid)
 29264                                  	jz	short plSwX	; If so, backup and exit like everything's ok
 29265                                  
 29266                                  	;cmp	al,'/'
 29267                                  	cmp	al,SWTCH	; Did they do "umb,size/" ?
 29268                                  	je	short plSwX	; If so, again, we're done here.
 29269                                  plE1:	
 29270                                  	;mov	ax,1
 29271                                  	mov	ax,PV_InvArg	; If not, we don't know WHAT they did...
 29272                                  	dec	si
 29273                                  	stc
 29274                                  	retn
 29275                                  
 29276                                  plE2:	;mov	ax,2
 29277                                  	mov	ax,PV_BadUMB	; In this case, they've specified a UMB twice
 29278                                  	; 12/12/2022
 29279                                  	; cf=1
 29280                                  	;stc
 29281                                  	retn
 29282                                  plSwX:	
 29283                                  	dec	si		; If we hit a '/' character, back up one char
 29284                                  				; so the whitespace checker will see it too.
 29285                                  plX:	; 12/12/2022
 29286                                  	; cf=0
 29287                                  	;clc			; Then just return with carry clear, so
 29288                                  	retn			; ParseVar will go about its business.
 29289                                  
 29290                                  ; -----------------------------------------------------------------------------
 29291                                  ;*** incArgc - increments fm_argc, for use with LoadHigh command-line parsing
 29292                                  ; -----------------------------------------------------------------------------
 29293                                  ; ENTRY:    None
 29294                                  ; EXIT:     None
 29295                                  ; ERROR:    None
 29296                                  ; USES:     fm_argc, flags
 29297                                  ; -----------------------------------------------------------------------------
 29298                                  
 29299                                  ;incArgc:
 29300                                  	;push	ax
 29301                                  
 29302                                  	;;getdata al, fm_argc	; Obtain previous value of fm_argc,
 29303                                  
 29304                                  	;mov	al,[cs:fm_argc]
 29305                                  
 29306                                  	;inc	al		; Increment it,
 29307                                  
 29308                                  	;;putdata fm_argc, al	; And store it right back.
 29309                                  
 29310                                  	;mov	[cs:fm_argc],al
 29311                                  
 29312                                  	;pop	ax
 29313                                  	;retn
 29314                                  
 29315                                  ; -----------------------------------------------------------------------------
 29316                                  ;*** isEOL - returns with ZF set if AL contains CR or LF, or 0
 29317                                  ; -----------------------------------------------------------------------------
 29318                                  ; ENTRY:    AL contains character to test
 29319                                  ; EXIT:     ZF set iff AL contains CR or LF, or 0
 29320                                  ; ERROR:    None
 29321                                  ; USES:     ZF
 29322                                  ; -----------------------------------------------------------------------------
 29323                                  
 29324                                  isEOL:
 29325                                  	cmp	al,0		; Null-terminator
 29326                                  	je	short ieX
 29327                                  	cmp	al,CR ; 0Dh	; Carriage Return
 29328                                  	je	short ieX
 29329                                  	cmp	al,LF ; 0Ah	; LineFeed
 29330                                  ieX:	
 29331                                  	retn
 29332                                  
 29333                                  ; -----------------------------------------------------------------------------
 29334                                  ;*** isWhite - returns with ZF set if AL contains whitespace (or "=")
 29335                                  ; -----------------------------------------------------------------------------
 29336                                  ; ENTRY:    AL contains character to test
 29337                                  ; EXIT:     ZF set iff AL contains space, tab, or equals
 29338                                  ; ERROR:    None
 29339                                  ; USES:     ZF
 29340                                  ; -----------------------------------------------------------------------------
 29341                                  
 29342                                  isWhite:
 29343                                  	cmp	al,' '		; Space
 29344                                  	je	short iwX
 29345                                  	cmp	al,'='		; Equals (treat as whitespace)
 29346                                  	je	short iwX
 29347                                  	cmp	al,tab ; 9	; Tab
 29348                                  iwX:	
 29349                                  	retn
 29350                                  
 29351                                  ; -----------------------------------------------------------------------------
 29352                                  ;*** unMarkUMB - marks a given UMB as unused, even if previously marked used
 29353                                  ; -----------------------------------------------------------------------------
 29354                                  ; ENTRY:    AL contains UMB number
 29355                                  ; EXIT:     None
 29356                                  ; ERROR:    None
 29357                                  ; USES:     Flags, variables in highvar.inc
 29358                                  ; -----------------------------------------------------------------------------
 29359                                  
 29360                                  unMarkUMB:
 29361                                  	push	ax
 29362                                  	push	bx
 29363                                  	push	di
 29364                                  	push	es
 29365                                  
 29366                                  	push	cs
 29367                                  	pop	es
 29368                                  
 29369                                  	xor	ah,ah
 29370                                  	mov	bx,ax
 29371                                  
 29372                                  	; 19/04/2019
 29373                                  	
 29374                                  	;mov	byte [es:bx+UmbUsed],0
 29375                                  	mov	[es:bx+UmbUsed],ah ; 0
 29376                                  
 29377                                  	cmp	[es:UmbLoad],al
 29378                                  	jne	short umu10
 29379                                  
 29380                                  	;mov	[es:UmbLoad],0	; If unmarked the load UMB, load into convent.
 29381                                  	mov	[es:UmbLoad],ah ; 0
 29382                                  umu10:	
 29383                                  	pop	es
 29384                                  	pop	di
 29385                                  	pop	bx
 29386                                  	pop	ax
 29387                                  	retn
 29388                                  
 29389                                  ; -----------------------------------------------------------------------------
 29390                                  ;*** stowUMB - marks a given UMB as used, if it hasn't been so marked before
 29391                                  ;            -- accepts a UMB # in AL, and makes sure it hasn't yet been
 29392                                  ; listed in the /L:... chain. If it's the first one specified, it sets UmbLoad
 29393                                  ; to that UMB #... and in any case, it marks the UMB as specified.
 29394                                  ; -----------------------------------------------------------------------------
 29395                                  ; ENTRY:    AL contains UMB number, as specified by the user
 29396                                  ; EXIT:     None
 29397                                  ; ERROR:    Carry set if UMB # is less than 0 or >= MAXUMB (see highvar.inc)
 29398                                  ; USES:     AX, Flags, variables in highvar.inc
 29399                                  ; -----------------------------------------------------------------------------
 29400                                  
 29401                                  stowUMB:
 29402                                  	cmp	al,MAXUMB ; 16
 29403                                  	jb	short su10
 29404                                  	stc
 29405                                  	retn			; Ooops-- UMB>=MAXUMB
 29406                                  su10:	
 29407                                  	push	bx
 29408                                  	push	di
 29409                                  	push	si
 29410                                  	push	ds
 29411                                  	push	es
 29412                                  	push	cs
 29413                                  	pop	es
 29414                                  	push	cs
 29415                                  	pop	ds
 29416                                  	
 29417                                  	;cmp	byte [UmbLoad],0FFh
 29418                                  	cmp	byte [UmbLoad],UNSPECIFIED ; If this, we haven't been here before
 29419                                  	jne	short su20
 29420                                  	mov	[UmbLoad],al	; So remember this UMB as the load UMB slot.
 29421                                  su20:	
 29422                                  	or	al,al		; If they gave UMB 0, there's really nothing
 29423                                  	jz	short su30	; that we should do here.
 29424                                  
 29425                                  	mov	bl,al
 29426                                  	xor	bh,bh
 29427                                  	mov	ax,1		; Now, AX = 1, and BX = UMB Number
 29428                                  
 29429                                  	xchg	[es:bx+UmbUsed],al
 29430                                  
 29431                                  	or	al,al		; If it was already 1, then al==1... and that
 29432                                  	jz	short su30	; means an error.
 29433                                  
 29434                                  	stc			; OOOPS!  This one's been used before.  :(
 29435                                  su30:	
 29436                                  	pop	es
 29437                                  	pop	ds
 29438                                  	pop	si
 29439                                  	pop	di
 29440                                  	pop	bx
 29441                                  	retn
 29442                                  
 29443                                  ; -----------------------------------------------------------------------------
 29444                                  ;*** stowSiz - marks a given UMB as having a given minimum size
 29445                                  ; -----------------------------------------------------------------------------
 29446                                  ; ENTRY:    CL contains UMB number, AX contains size
 29447                                  ; EXIT:     None
 29448                                  ; ERROR:    None
 29449                                  ; USES:     AX, DX, Flags, variables in highvar.inc
 29450                                  ; -----------------------------------------------------------------------------
 29451                                  
 29452                                  ; 13/05/2019
 29453                                  
 29454                                  stowSiz:
 29455                                  	push	bx
 29456                                  	;push	di ; ?
 29457                                  	push	es
 29458                                  
 29459                                  	push	cs
 29460                                  	pop	es	
 29461                                  
 29462                                  	mov	bl,cl			; Now bl==UMB number, AX==size
 29463                                  	mov	bh,0			;     bx==UMB number, AX==size
 29464                                  	shl	bl,1			;     bx==offset into array, AX=size
 29465                                  	mov	[es:bx+UmbSize],ax	; Store the size
 29466                                  	
 29467                                  	pop	es
 29468                                  	;pop	di ; ?
 29469                                  	pop	bx
 29470                                  
 29471                                  	retn
 29472                                  
 29473                                  ; -----------------------------------------------------------------------------
 29474                                  ;*** toDigit - converts a character-digit to its binary counterpart
 29475                                  ;            -- verifies that CL contains a valid character-digit; if so, it
 29476                                  ; changes CL to its counterpart binary digit ((CL-'0') or (CL-'A'+10)).
 29477                                  ; A-F are considered valid iff gnradix is 16.
 29478                                  ; -----------------------------------------------------------------------------
 29479                                  ; ENTRY:    CL contains a digit ('0' to '9' or, if gnradix==16, 'A' to 'F')
 29480                                  ; EXIT:     CL contains digit in binary (0 to 9 or, if gnradix==16, 0 to 15)
 29481                                  ; ERROR:    Carry set indicates invalid digit; carry clear indicates good digit
 29482                                  ; USES:     CL, Flags
 29483                                  ; -----------------------------------------------------------------------------
 29484                                  ; If the string is preceeded with "0x", the value is read as hexadecimal; else,
 29485                                  ; as decimal. After a read, you may check the radix by examining gnradix--it
 29486                                  ; will be 10 or 16.
 29487                                  ; -----------------------------------------------------------------------------
 29488                                  
 29489                                  gnradix:
 29490                                  	dw	0		; Must be a word--16x16 multiplication
 29491                                  
 29492                                  toDigit:
 29493                                  	cmp	word [cs:gnradix],16
 29494                                  	jne	short td20	; Don't check hex digits if radix isn't 16
 29495                                  
 29496                                  toDigit_hex:
 29497                                  	cmp	cl,'a'	; 61h
 29498                                  	jb	short td10
 29499                                  	cmp	cl,'f'	; 66h
 29500                                  	ja	short tdE	; Nothing valid above 'z' at all...
 29501                                  	sub	cl,'a'-10 ; 57h	; Make 'a'==10 and return.
 29502                                  	;clc			; <- CLC is implicit from last SUB
 29503                                  	retn
 29504                                  td10:	
 29505                                  	cmp	cl,'A'  ; 41h
 29506                                  	jb	short td20	; Below 'A'?  Not a letter...
 29507                                  	cmp	cl,'F'	; 46h
 29508                                  	ja	short tdE	; Above 'F'?  Not a digit.
 29509                                  	sub	cl,'A'-10 ; 37h	; Make 'A'==10 and return.
 29510                                  	;clc			; <- CLC is implicit from last SUB
 29511                                  	retn
 29512                                  toDigit_dec:
 29513                                  td20:	
 29514                                  	cmp	cl,'0'		; If less than zero,
 29515                                  	;jb	short tdE	; Done.
 29516                                  	jb	short tdEr ; 08/04/2019
 29517                                  	cmp	cl,'9'		; Or, if greater than nine,
 29518                                  	ja	short tdE	; Done.
 29519                                  	sub	cl,'0'	; 30h	; Okay--make '0'==0 and return.
 29520                                  	;clc			; <- CLC is implicit from last SUB
 29521                                  	retn
 29522                                  tdE:	
 29523                                  	stc
 29524                                  tdEr:		; 08/04/2019 - Retro DOS v4.0	
 29525                                  	retn
 29526                                  
 29527                                  ; -----------------------------------------------------------------------------
 29528                                  ;*** GetXNum - reads a 32-bit ASCII number at ES:SI and returns it in DX:AX
 29529                                  ; -----------------------------------------------------------------------------
 29530                                  ; ENTRY:    ES:SI points to an ascii string to scan
 29531                                  ; EXIT:     ES:SI moved to first invalid digit, DX:AX contains value read
 29532                                  ; ERROR:    Carry set if # is too big, or has no digits (EOL possibly)
 29533                                  ; USES:     ES:SI, DX, AX, Flags, gnradix
 29534                                  ; -----------------------------------------------------------------------------
 29535                                  ; If the string is preceeded with "0x", the value is read as hexadecimal; else,
 29536                                  ; as decimal. After a read, you may check the radix by examining gnradix--it
 29537                                  ; will be 10 or 16.
 29538                                  ; -----------------------------------------------------------------------------
 29539                                  
 29540                                  ; 08/04/2019 - Retro DOS v4.0
 29541                                  
 29542                                  GetXNum:
 29543                                  	;pushreg <bx, cx, ds>
 29544                                  	push	bx
 29545                                  	push	cx
 29546                                  	push	ds
 29547                                  
 29548                                  	cld
 29549                                  	xor	ax,ax
 29550                                  	xor	bx,bx
 29551                                  	xor	cx,cx
 29552                                  	xor	dx,dx			; Start with 0 (makes sense)
 29553                                  
 29554                                  	mov	word [cs:gnradix],10	; And default to a radix of 10 (dec)
 29555                                  
 29556                                  	mov	cl,[es:si]		; Now AX=0, BX=0, CH=0/CL=char, DX=0
 29557                                  	;call	toDigit
 29558                                  	call	toDigit_dec
 29559                                  	jc	short gxnE		; If it's not a digit, leave now.
 29560                                  
 29561                                  	or	cl,cl
 29562                                  	jnz	short gxn20		; Doesn't have '0x'
 29563                                  	mov	cl,[es:si+1]
 29564                                  	cmp	cl,'x'			; Either 'x'...
 29565                                  	je	short gxn10
 29566                                  	cmp	cl,'X'			; ...or 'X' means it's hexadecimal
 29567                                  	jne	short gxn20
 29568                                  
 29569                                  gxn10:	
 29570                                  	mov	word [cs:gnradix], 16
 29571                                  	inc	si			; Since we read "0x", march over it.
 29572                                  	inc	si
 29573                                  
 29574                                  ; ------------------------------------------------------
 29575                                  ; GXN20--ES:SI = a digit in a number; if not, we're done
 29576                                  ;        DX:AX = current total
 29577                                  ;        BX    = 0
 29578                                  ;        CH    = 0
 29579                                  ; ------------------------------------------------------
 29580                                  
 29581                                  gxn20:	
 29582                                  	mov	cl,[es:si]	; Now DX:AX=current total, CH=0/CL=char
 29583                                  	inc	si
 29584                                  
 29585                                  	call	toDigit		; Accepts only valid digits, A-F -> 10-16
 29586                                  	jc	short gxnQ	; <- Ah... wasn't a digit. Stop.
 29587                                  
 29588                                  	call	mul32		; Multiply DX:AX by gnradix
 29589                                  	jc	short gxnX	; (if it's too big, error out)
 29590                                  
 29591                                  	add	ax,cx		; Add the digit
 29592                                  	adc	dx,bx		; (BX is 0!)--Adds 1 iff last add wrapped
 29593                                  	;jc	short gxnX	; If _that_ wrapped, it's too big.
 29594                                  	;jmp	short gxn20
 29595                                  	jnc	short gxn20
 29596                                  gxnE:	
 29597                                  	;stc			; In this case, we need to set the carry
 29598                                  	jmp	short gxnX	; and leave--there were no digits given.
 29599                                  gxnQ:	
 29600                                  	dec	si		; Don't read in the offensive character.
 29601                                  	clc			; And clear carry, so they know it's okay.
 29602                                  gxnX:	
 29603                                  	pop	ds
 29604                                  	pop	cx
 29605                                  	pop	bx
 29606                                  	retn
 29607                                  
 29608                                  ; -----------------------------------------------------------------------------
 29609                                  ;*** mul32 - multiplies the number in DX:AX by gnradix
 29610                                  ; -----------------------------------------------------------------------------
 29611                                  ; ENTRY:   DX:AX = the number to be multiplied, BX = 0, gnradix = multiplier
 29612                                  ; EXIT:    DX:AX has been multiplied by gnradix if carry clear; BX still 0
 29613                                  ; ERROR:   Carry set if number was too large
 29614                                  ; USES:    Flags, AX, DX
 29615                                  ; -----------------------------------------------------------------------------
 29616                                  
 29617                                  mul32:
 29618                                  	push	ax		; DX=old:hi, AX=old:lo, TOS=old:lo, BX=0
 29619                                  	mov	ax,dx		; DX=old:hi, AX=old:hi, TOS=old:lo, BX=0
 29620                                  	mul	word [cs:gnradix] ; DX=?, AX=new:hi, TOS=old:lo, BX=0
 29621                                  	jc	short m32E	; Too big?
 29622                                  
 29623                                  	mov	dx,ax		; DX=new:hi, AX=new:hi, TOS=old:lo, BX=0
 29624                                  	pop	ax		; DX=new:hi, AX=old:lo, TOS=orig, BX=0
 29625                                  
 29626                                  	xchg	dx,bx		; DX=0, AX=old:lo, TOS=orig, BX=new:hi
 29627                                  	mul	word [cs:gnradix] ; DX=carry,  AX=new:lo, TOS=orig, BX=new:hi
 29628                                  	xchg	dx,bx		; DX=new:hi, AX=new:lo, TOS=orig, BX=carry
 29629                                  	add	dx,bx		; DX=new:hi, AX=new:lo, TOS=orig, BX=carry
 29630                                  	xor	bx,bx		; DX=new:hi, AX=new:lo, TOS=orig, BX=0
 29631                                  	retn
 29632                                  m32E:	
 29633                                  	pop	ax
 29634                                  	retn
 29635                                  
 29636                                  ; -----------------------------------------------------------------------------
 29637                                  ;*** toPara - divides DX:AX by 16; result in AX only (discards extra DX data)
 29638                                  ; -----------------------------------------------------------------------------
 29639                                  ; ENTRY:   DX:AX = the number to be divided
 29640                                  ; EXIT:    Interpereting DX:AX as bytes, AX=paragraph equivalent, 0xFFFF max
 29641                                  ; ERROR:   None
 29642                                  ; USES:    Flags, AX, DX
 29643                                  ; -----------------------------------------------------------------------------
 29644                                  ; Note: The 386 has a 32-bit SHR, which would work perfectly for this... but we
 29645                                  ;       can't ensure a 386 host machine. Sorry.
 29646                                  ; -----------------------------------------------------------------------------
 29647                                  
 29648                                  toPara:
 29649                                  	push	cx		; DX:AX=HHHH hhhh hhhh hhhh:LLLL llll llll llll
 29650                                  
 29651                                  	mov	cl,4		;
 29652                                  	shr	ax,cl		; DX:AX=HHHH hhhh hhhh hhhh:0000 LLLL llll llll
 29653                                  	xchg	ax,dx		; DX:AX=0000 LLLL llll llll:HHHH hhhh hhhh hhhh
 29654                                  	mov	cl,12
 29655                                  	shl	ax,cl		; DX:AX=0000 LLLL llll llll:hhhh 0000 0000 0000
 29656                                  	or	ax,dx		;    AX=hhhh LLLL llll llll
 29657                                  
 29658                                  	pop	cx
 29659                                  	retn
 29660                                  
 29661                                  ; -----------------------------------------------------------------------------
 29662                                  ;*** UmbHead - returns in AX the address of the first UMB block (0x9FFF)
 29663                                  ; -----------------------------------------------------------------------------
 29664                                  ; ENTRY:  Nothing
 29665                                  ; EXIT:   AX contains 0x9FFF for most systems
 29666                                  ; ERROR:  Carry set if pointer is 0xFFFF (if not set up yet--DH runs into this)
 29667                                  ; USES:   Flags, AX
 29668                                  ; -----------------------------------------------------------------------------
 29669                                  ; Early in the boot-cycle, the pointer used to obtain this value isn't set up;
 29670                                  ; to be precise, before a UMB provider is around. In this event, the pointer
 29671                                  ; is always set to 0xFFFF; it changes once a provider is around. On most
 29672                                  ; machines (all of 'em I've seen), it changes to 0x9FFF at that point.
 29673                                  ; -----------------------------------------------------------------------------
 29674                                  
 29675                                  UmbHead:
 29676                                  	; 13/05/2019 (because of callers, pushs & pops are not needed here)
 29677                                  
 29678                                  	;push	si ; ?
 29679                                  	;push	ds ; ? 
 29680                                  	;push	es
 29681                                  	;push	bx ; *	
 29682                                  
 29683                                  	; 09/04/2019
 29684                                  	; !!! No need to save es,bx,ds,si above !!! (es,bx are changed here)
 29685                                  
 29686                                  	mov	ah,GET_IN_VARS		; Call int 21h, function 52h...
 29687                                  	int	21h
 29688                                  
 29689                                  	mov	ax,[es:DOS_UMB_HEAD]	; And read what's in ES:[008C]
 29690                                  	cmp	ax,0FFFFh
 29691                                  	je	short uhE		; If it's 0xFFFF, it's an error...
 29692                                  
 29693                                  	clc				; Else, it isn't (CLC done by prev cmp)
 29694                                  	;jmp	short uhX
 29695                                  	; 12/12/2022
 29696                                  	retn
 29697                                  uhE:	
 29698                                  	stc
 29699                                  uhX:	
 29700                                  	;pop	bx ; *
 29701                                  	;pop	es
 29702                                  	;pop	ds ; ?
 29703                                  	;pop	si ; ?
 29704                                  	retn
 29705                                  
 29706                                  ; -----------------------------------------------------------------------------
 29707                                  ;*** isSysMCB - sets ZF if ES points to an MCB owned by "SC" + (8 or 9)
 29708                                  ; -----------------------------------------------------------------------------
 29709                                  ; ENTRY:  ES:0 should point to a valid MCB
 29710                                  ; EXIT:   ZF set if owned by SC+8 or SC+9 (for japan)
 29711                                  ; USES:   Flags
 29712                                  ; -----------------------------------------------------------------------------
 29713                                  
 29714                                  isSysMCB:
 29715                                  	;push	ax
 29716                                  
 29717                                  	;mov	ax,[es:ARENA.OWNER]	; Check the owner...
 29718                                  	;cmp	ax,SystemPSPOwner	; 8 (for US OR Japan) is valid
 29719                                  	;je	short ism10
 29720                                  	;cmp	ax,JapanPSPOwner	; 9 (for Japan) is valid
 29721                                  	;;je	short ism10
 29722                                  	;;jmp	short ismX		; Anything else isn't.
 29723                                  	;jne	short ismX
 29724                                  	cmp	word [es:ARENA.OWNER],SystemPSPOwner ; 8  ; 09/04/2019
 29725                                  	jne	short ismX 
 29726                                  ism10:	
 29727                                  	;mov	ax,[es:ARENA.NAME]	; Check the name...
 29728                                  	;cmp	ax,'SC' ; 4353h
 29729                                  	cmp	word [es:ARENA.NAME],'SC'
 29730                                  ismX:	
 29731                                  	;pop	ax
 29732                                  	retn
 29733                                  
 29734                                  ; 09/04/2019 - Retro DOS v4.0
 29735                                  
 29736                                  ; -----------------------------------------------------------------------------
 29737                                  ;*** AddrToUmb - converts a segment address in AX to its appropriate UMB number
 29738                                  ; -----------------------------------------------------------------------------
 29739                                  ; ENTRY:  AX contains a segment address
 29740                                  ; EXIT:   AX will contain the UMB number which contains the address (0==conv)
 29741                                  ; ERROR:  If the address is above UM Range, AX will return as FFFF.
 29742                                  ; USES:   Flags, AX
 29743                                  ; -----------------------------------------------------------------------------
 29744                                  ; An address in the following areas is treated as:
 29745                                  ;    0      <-> umbhead (0x9FFF)          = Conventional memory
 29746                                  ;    0x9FFF <-> addr of first UM sys MCB  = UMB #1
 29747                                  ;      ...
 29748                                  ;    addr of last UM sys MCB <-> TOM      = invalid; returns #0xFFFF
 29749                                  ; -----------------------------------------------------------------------------
 29750                                  
 29751                                  AddrToUmb:
 29752                                  	push	cx
 29753                                  	push	dx
 29754                                  	push	es
 29755                                  
 29756                                  	mov	dx,ax		; DX = address to search for
 29757                                  
 29758                                  	call	UmbHead		; AX = first segment
 29759                                  	jc	short atuE	; If it couldn't get it, error out.
 29760                                  
 29761                                  	mov	es,ax		; ES = first UMB segment
 29762                                  	xor	cx,cx		; Pretend we're on UMB 0 for now... (cx = UMB#)
 29763                                  
 29764                                  ; ----------------------------------------
 29765                                  ; ATU10--ES - Current MCB address
 29766                                  ;        DX - Address given for conversion
 29767                                  ;        CX - Current UMB #
 29768                                  ; ----------------------------------------
 29769                                  
 29770                                  atu10:	mov	ax,es
 29771                                          cmp	ax,dx		; Present segment >= given segment?
 29772                                  	jae	short atuX	; Yep--done.
 29773                                  
 29774                                  	call	isSysMCB	; Returns with ZF set if this is a system MCB
 29775                                  	jnz	short atu20
 29776                                  
 29777                                  	inc	cx		; If it _was_ a system MCB, we're in a new UMB.
 29778                                  atu20:	
 29779                                  	mov	al,[es:ARENA.SIGNATURE]
 29780                                  	cmp	al,arena_signature_end  ; 'Z'
 29781                                  	je	short atu30		; 'Z' means this was the last MCB... that's it.
 29782                                  
 29783                                  	;NextMCB es, ax
 29784                                  
 29785                                  	mov     ax,es
 29786                                  	;add	ax,[es:3]
 29787                                  	add     ax,[es:ARENA.SIZE]
 29788                                  	inc     ax
 29789                                  	mov     es,ax
 29790                                  	
 29791                                  	jmp	short atu10
 29792                                  
 29793                                  ; -----------------------------------------------------------------------------
 29794                                  ; if we get to atu30, they specified a number that was past the last MCB.
 29795                                  ; make sure it's not _inside_ that MCB before we return an error condition.
 29796                                  ; -----------------------------------------------------------------------------
 29797                                  
 29798                                  atu30:	
 29799                                  	mov	ax,es
 29800                                  	add	ax,[es:ARENA.SIZE]
 29801                                  	cmp	ax,dx		; Present >= given?
 29802                                  	jae	short atuX	; Yep! It _was_ inside.
 29803                                  atuE:	
 29804                                  	xor	cx,cx		; Else, fall through with UMB # == -1
 29805                                  	dec	cx		; (that makes it return 0xFFFF and sets CF)
 29806                                  atuX:	
 29807                                  	mov	ax, cx		; Return the UMB number in AX
 29808                                  	
 29809                                  	pop	es	
 29810                                  	pop	dx
 29811                                  	pop	cx
 29812                                  	retn
 29813                                  
 29814                                  ; -----------------------------------------------------------------------------
 29815                                  ;*** convUMB - checks after GetXNum to convert an address to a UMB number
 29816                                  ;            -- if GetXNum read a hex number, we interperete that as a segment
 29817                                  ; address rather than a UMB number... and use that address to look up a UMB.
 29818                                  ; This routine checks for that condition and calls AddrToUmb if necessary.
 29819                                  ; -----------------------------------------------------------------------------
 29820                                  ; ENTRY:  AX contains a UMB number or segment, gnradix has been set by GetXNum
 29821                                  ; EXIT:   AX will contain a UMB number
 29822                                  ; ERROR:  None
 29823                                  ; USES:   Flags, AX
 29824                                  ; -----------------------------------------------------------------------------
 29825                                  
 29826                                  convUMB:
 29827                                  	cmp	word [cs:gnradix],16
 29828                                  	jne	short cu10	; If it didn't read in hex, it's not an address
 29829                                  	call	AddrToUmb	; Else, convert the address to a UMB number
 29830                                  	cmp	ax,0FFFFh
 29831                                  	jne	short cu10
 29832                                  	inc	ax		; If too high, ignore it (make it conventional)
 29833                                  cu10:	
 29834                                  	retn
 29835                                  
 29836                                  ; -----------------------------------------------------------------------------
 29837                                  ;*** setUMBs - links umbs and sets allocation strategy for a load
 29838                                  ;            -- if LoadHigh, the allocation strategy MAY be LOW_FIRST instead
 29839                                  ; of the usual HIGH_FIRST.  See the code.
 29840                                  ; -----------------------------------------------------------------------------
 29841                                  ; ENTRY:  None
 29842                                  ; EXIT:   None
 29843                                  ; ERROR:  None
 29844                                  ; USES:   Flags, fm_umb, fm_strat
 29845                                  ; -----------------------------------------------------------------------------
 29846                                  
 29847                                  setUMBs:
 29848                                  	push	ax
 29849                                  	push	bx
 29850                                  	call	fm_link
 29851                                  	pop	bx
 29852                                  	pop	ax
 29853                                  	retn
 29854                                  
 29855                                  ; -----------------------------------------------------------------------------
 29856                                  ;*** loadLow - returns AL==0 if UMB0 == 0, else AL==1
 29857                                  ; -----------------------------------------------------------------------------
 29858                                  ; ENTRY:  None
 29859                                  ; EXIT:   AL==0 if mem strategy should be set to LOW_FIRST, else AL==1
 29860                                  ;         Carry set if UMB0 not specified (_NOT_ an error)
 29861                                  ; ERROR:  None
 29862                                  ; USES:   Flags, fm_strat, fm_umb
 29863                                  ; -----------------------------------------------------------------------------
 29864                                  ; We want to set the memory strategy to LOW_FIRST if the user specified a
 29865                                  ; load UMB, and it is 0.  That 0 can be either from the user having _specified_
 29866                                  ; zero (/L:0;...), or from having specified a too-big min size (/L:1,99999999)
 29867                                  ; such that the load UMB is too small, and shouldn't be used.
 29868                                  ; -----------------------------------------------------------------------------
 29869                                  
 29870                                  loadLow:
 29871                                  	;push	ds
 29872                                  	;push	cs		; Point DS into appropriate data segment
 29873                                  	;pop	ds	
 29874                                  
 29875                                  	;mov	al,[UmbLoad]
 29876                                  	mov	al,[cs:UmbLoad]
 29877                                  	cmp	al,UNSPECIFIED ; 0FFh, -1
 29878                                  	jne	short ll10
 29879                                  
 29880                                  	stc
 29881                                  ll15:
 29882                                  	mov	al,1		; Return with AL==1 && STC if no UMBs specified
 29883                                  	;stc
 29884                                  	;jmp	short llX
 29885                                  	retn
 29886                                  ll10:	
 29887                                  	or	al,al		; AL=the load UMB: Is it == 0?
 29888                                  	;jz	short llX	; Yep... CF==0 (from OR) && AL=0, so just exit
 29889                                  
 29890                                  	jnz	short ll15	; 09/04/2019 - Retro DOS v4.0
 29891                                  	retn
 29892                                  
 29893                                  	;mov	al,1
 29894                                  	;clc
 29895                                  ;llX:
 29896                                  	;pop	ds		; Return DS to where it was
 29897                                  	;retn
 29898                                  
 29899                                  ; -----------------------------------------------------------------------------
 29900                                  ;*** HideUMBs - links UMBs and hides upper-memory as appropriate
 29901                                  ; -----------------------------------------------------------------------------
 29902                                  ; ENTRY:  None
 29903                                  ; EXIT:   None
 29904                                  ; ERROR:  None
 29905                                  ; USES:   Flags, fm_strat, fm_umb
 29906                                  ; -----------------------------------------------------------------------------
 29907                                  
 29908                                  HideUMBs:
 29909                                  	push	ax
 29910                                  	push	cx
 29911                                  	push	ds
 29912                                  	push	es
 29913                                  
 29914                                  	call	UmbTest		; See if we REALLY linked in anything...
 29915                                  	jc	short husX	; ...if not, there's nothing for us to do.
 29916                                  
 29917                                  	call	FixMem		; Concatenate adjacent free MCBs in upper mem
 29918                                  	call	setUMBs		; Link UMBs and set memory-allocation strategy
 29919                                  
 29920                                  	;putdata fInHigh,1	; Remember that we're now running high
 29921                                  	mov	byte [cs:fInHigh],1
 29922                                  
 29923                                  	;call	GetLoadUMB	; See if they gave us a list to leave free
 29924                                  	mov	al,[cs:UmbLoad] ; 09/04/2019 - Retro DOS v4.0
 29925                                  
 29926                                  	cmp	al,UNSPECIFIED	; If they didn't,
 29927                                  	je	short husX	; then we shouldn't do this loop:
 29928                                  
 29929                                  	xor	cx,cx
 29930                                  
 29931                                  ; -----------------------------------------------
 29932                                  ; HUS10-CX - UMB number (after inc, 1==first UMB)
 29933                                  ; -----------------------------------------------
 29934                                  
 29935                                  hus10:	inc	cx		; For each UMB:
 29936                                  	cmp	cx,MAXUMB ; 16
 29937                                  	jae	short hus20
 29938                                  
 29939                                  	mov	al,cl		; (stopping as soon as we're outside of the
 29940                                  	push	es
 29941                                  	call	findUMB		; valid range of UMBs)
 29942                                  	pop	es		; push/pop: trash what findumb finds.  :-)
 29943                                  	jc	short hus20
 29944                                  
 29945                                  	call	_hideUMB_	; hide what we need to hide.
 29946                                  
 29947                                  	jmp	short hus10
 29948                                  hus20:	
 29949                                  	;call	GetLoadUMB	; Now check if they offered /L:0
 29950                                  	mov	al,[cs:UmbLoad] ; 09/04/2019 - Retro DOS v4.0	
 29951                                  
 29952                                  	or	al,al		; --Is the load UMB 0? (-1==unspecified)
 29953                                  	jnz	short husX	; If not, we're done.
 29954                                  
 29955                                  	call	hl_unlink	; If so, however, fix UMBs and strategy.
 29956                                  husX:	
 29957                                  	pop	es
 29958                                  	pop	ds
 29959                                  	pop	cx
 29960                                  	pop	ax
 29961                                  	retn
 29962                                  
 29963                                  ; -----------------------------------------------------------------------------
 29964                                  ;*** GetLoadUMB - Returns the load UMB number in AL (-1 if not specified)
 29965                                  ; -----------------------------------------------------------------------------
 29966                                  ; ENTRY:  None
 29967                                  ; EXIT:   AL == load UMB
 29968                                  ; ERROR:  None
 29969                                  ; USES:   Flags, AX
 29970                                  ; -----------------------------------------------------------------------------
 29971                                  
 29972                                  ;GetLoadUMB:
 29973                                  ;	;getdata al, UmbLoad
 29974                                  ;	push	ds
 29975                                  ;	push	cs
 29976                                  ;	pop	ds
 29977                                  ;	mov	al,[UmLoad]
 29978                                  ;	pop	ds
 29979                                  ;	retn
 29980                                  
 29981                                  ; -----------------------------------------------------------------------------
 29982                                  ;*** GetLoadSize - Returns the load UMB minimum size (0 if not specified)
 29983                                  ; -----------------------------------------------------------------------------
 29984                                  ; ENTRY:  None
 29985                                  ; EXIT:   AX == load UMB minimum size
 29986                                  ; ERROR:  None
 29987                                  ; USES:   Flags, AX
 29988                                  ; -----------------------------------------------------------------------------
 29989                                  
 29990                                  GetLoadSize:
 29991                                  	; 09/04/2019 - Retro DOS v4.0
 29992                                  	mov	al,[cs:UmbLoad]
 29993                                  	jmp	short GetSize
 29994                                  
 29995                                  	;push	bx
 29996                                  	;;push	si
 29997                                  	;push	ds
 29998                                  	;push	cs
 29999                                  	;pop	ds
 30000                                  
 30001                                  	;mov	al,[UmbLoad]
 30002                                  
 30003                                  	;xor	ah,ah			;    ax==UMB
 30004                                  	;mov	bx,UmbSize		;    bx==array
 30005                                  	;shl	al,1	                ;    ax==offset
 30006                                  	;;add	ax,bx			;    ax==element index
 30007                                  	;;mov	si,ax			; ds:si==element index
 30008                                  
 30009                                  	;;lodsw				;    ax==size
 30010                                  
 30011                                  	;add	bx,ax
 30012                                  	;mov	ax,[bx]
 30013                                  
 30014                                  	;pop	ds
 30015                                  	;;pop	si
 30016                                  	;pop	bx
 30017                                  	;retn
 30018                                  
 30019                                  ; -----------------------------------------------------------------------------
 30020                                  ;*** GetSize - Returns the UMB in AL's minimum size (0 if not specified)
 30021                                  ; -----------------------------------------------------------------------------
 30022                                  ; ENTRY:  AL == a UMB number
 30023                                  ; EXIT:   AX == UMB minimum size, as specified by the user
 30024                                  ; ERROR:  None
 30025                                  ; USES:   Flags, AX
 30026                                  ; -----------------------------------------------------------------------------
 30027                                  
 30028                                  GetSize:
 30029                                  	; 09/04/2019 - Retro DOS v4.0
 30030                                  
 30031                                  	push	bx
 30032                                  	;push	si
 30033                                  	;push	ds
 30034                                  	;push	cs
 30035                                  	;pop	ds
 30036                                  
 30037                                  	xor	ah,ah			;    ax==UMB
 30038                                  	mov	bx,UmbSize		;    bx==array
 30039                                  	shl	al,1	                ;    ax==offset
 30040                                  	;add	ax,bx			;    ax==element index
 30041                                  	;mov	si,ax			; ds:si==element index
 30042                                  
 30043                                  	;lodsw				;    ax==size
 30044                                  
 30045                                  	add	bx,ax
 30046                                  	;mov	ax,[bx]
 30047                                  	mov	ax,[cs:bx]
 30048                                  
 30049                                  	;pop	ds
 30050                                  	;pop	si
 30051                                  	pop	bx
 30052                                  	retn
 30053                                  
 30054                                  ; -----------------------------------------------------------------------------
 30055                                  ;*** StoLoadUMB - Overrides the load UMB number with what's in AL
 30056                                  ; -----------------------------------------------------------------------------
 30057                                  ; ENTRY:   AL == new load UMB
 30058                                  ; EXIT:    None
 30059                                  ; ERROR:   None
 30060                                  ; USES:    Flags, AX
 30061                                  ; -----------------------------------------------------------------------------
 30062                                  ; CAUTION: Should only be used if /L:... was used.  Logically, that is the only
 30063                                  ;          time you would ever need this, so that's okay.
 30064                                  ; -----------------------------------------------------------------------------
 30065                                  
 30066                                  ;StoLoadUMB:
 30067                                  ;	;putdata UmbLoad, al
 30068                                  ;	push	es
 30069                                  ;	push	cs
 30070                                  ;	pop	es
 30071                                  ;	mov	[es:UmbLoad],al
 30072                                  ;	pop	es
 30073                                  ;	retn
 30074                                  
 30075                                  ; -----------------------------------------------------------------------------
 30076                                  ;*** StoLoadSize - Overrides the load UMB minimum size with what's in AX
 30077                                  ; -----------------------------------------------------------------------------
 30078                                  ; ENTRY:  AL == new load size
 30079                                  ; EXIT:   None
 30080                                  ; ERROR:  None
 30081                                  ; USES:   Flags, AX
 30082                                  ; -----------------------------------------------------------------------------
 30083                                  
 30084                                  StoLoadSize:
 30085                                  	push	dx
 30086                                  
 30087                                  	;getdata dl, UmbLoad		; Put UMB# in DL and size in AX
 30088                                  	;
 30089                                  	;push	ds
 30090                                  	;push	cs
 30091                                  	;pop	ds
 30092                                  	;mov	dl,[UmbLoad]
 30093                                  	;pop	ds	
 30094                                  
 30095                                  	mov	dl,[cs:UmbLoad]
 30096                                  
 30097                                  	cmp	dl,UNSPECIFIED ; 0FFh
 30098                                  	je	short sls10
 30099                                  
 30100                                  	call	stowSiz			; We've got a function to do just this
 30101                                  sls10:	
 30102                                  	pop	dx
 30103                                  	retn
 30104                                  
 30105                                  ; -----------------------------------------------------------------------------
 30106                                  ;*** hideUMB - marks as HIDDEN all FREE elements in UMB passed as AL
 30107                                  ; -----------------------------------------------------------------------------
 30108                                  ; ENTRY:    AL must indicate a valid UMB; 0==conv && is invalid.
 30109                                  ; EXIT:     None; free elements in UMB marked as hidden
 30110                                  ; ERROR:    None
 30111                                  ; USES:     Flags
 30112                                  ; -----------------------------------------------------------------------------
 30113                                  
 30114                                  hideUMB:
 30115                                  	push	ax
 30116                                  	push	es
 30117                                  
 30118                                  	call	findUMB		; Returns with carry if err, else ES == MCB
 30119                                  	jc	short huX
 30120                                  
 30121                                  ; ------------------------------------------------
 30122                                  ; HU10--ES - MCB inside UMB; if it's a system MCB,
 30123                                  ;            we're not in the same UMB, so exit.
 30124                                  ; ------------------------------------------------
 30125                                  
 30126                                  hu10:	call	isSysMCB	; Returns with ZF set if owner is SYSTEM
 30127                                  	jz	short huX	; If it is, we've finished the UMB.
 30128                                  	;call	isFreeMCB	; Returns with ZF set if owner is 0
 30129                                  	or	word [es:ARENA.OWNER],0
 30130                                  	jnz	short hu20
 30131                                  
 30132                                  	call	hideMCB
 30133                                  hu20:	
 30134                                  	mov	al,[es:ARENA.SIGNATURE]
 30135                                  	cmp	al,arena_signature_end  ;'Z'
 30136                                  	jz	short huX	; 'Z' means this was the last MCB... that's it.
 30137                                  
 30138                                  	;NextMCB es, ax		; Go on forward.
 30139                                  	mov     ax,es
 30140                                  	;add	ax,[es:3]
 30141                                  	add     ax,[es:ARENA.SIZE]
 30142                                  	inc     ax
 30143                                  	mov     es,ax
 30144                                  
 30145                                  	jmp	short hu10
 30146                                  huX:	
 30147                                  	pop	es
 30148                                  	pop	ax
 30149                                  	retn
 30150                                  
 30151                                  ; -----------------------------------------------------------------------------
 30152                                  ;*** isTiny - returns with ZF set if user didn't specify /S
 30153                                  ; -----------------------------------------------------------------------------
 30154                                  ; ENTRY:    None
 30155                                  ; EXIT:     ZF set if user DIDN'T specify /S
 30156                                  ; ERROR:    None
 30157                                  ; USES:     Flags
 30158                                  ; -----------------------------------------------------------------------------
 30159                                  
 30160                                  isTiny:
 30161                                  	push	ax
 30162                                  
 30163                                  	;getdata al, fUmbTiny
 30164                                  	;
 30165                                  	;push	ds
 30166                                  	;push	cs
 30167                                  	;pop	ds
 30168                                  	;mov	al,[fUmbTiny]
 30169                                  	;pop	ds
 30170                                  
 30171                                  	mov	al,[cs:fUmbTiny]		
 30172                                  
 30173                                  	or	al,al
 30174                                  	pop	ax
 30175                                  	retn
 30176                                  
 30177                                  ; -----------------------------------------------------------------------------
 30178                                  ;*** isFreeMCB - returns with ZF set if current MCB (ES:0) is FREE
 30179                                  ; -----------------------------------------------------------------------------
 30180                                  ; ENTRY:    ES:0 should point to an MCB
 30181                                  ; EXIT:     ZF set if MCB is free, else !ZF
 30182                                  ; ERROR:    None
 30183                                  ; USES:     Flags
 30184                                  ; -----------------------------------------------------------------------------
 30185                                  
 30186                                  ;isFreeMCB:
 30187                                  ;	or	word [es:ARENA.OWNER],0
 30188                                  ;	retn
 30189                                  
 30190                                  ; -----------------------------------------------------------------------------
 30191                                  ;*** hideMCB - marks as HIDDEN the MCB at ES:0
 30192                                  ; -----------------------------------------------------------------------------
 30193                                  ; ENTRY:    ES:0 should point to an MCB
 30194                                  ; EXIT:     None; MCB marked as HIDDEN
 30195                                  ; ERROR:    None
 30196                                  ; USES:     None
 30197                                  ; -----------------------------------------------------------------------------
 30198                                  
 30199                                  hideMCB:
 30200                                  	mov	word [es:ARENA.OWNER],SystemPSPOwner ; 8
 30201                                  	mov	word [es:ARENA.NAME+0], 'HI' ; 4948h
 30202                                  	mov	word [es:ARENA.NAME+2], 'DD' ; 4444h
 30203                                  	mov	word [es:ARENA.NAME+4], 'EN' ; 4E45h
 30204                                  	mov	word [es:ARENA.NAME+6], '  ' ; 2020h	
 30205                                  	retn
 30206                                  
 30207                                  ; -----------------------------------------------------------------------------
 30208                                  ;*** unHideMCB - marks as FREE the MCB at ES:0
 30209                                  ; -----------------------------------------------------------------------------
 30210                                  ; ENTRY:    ES:0 should point to an MCB
 30211                                  ; EXIT:     None; MCB marked as FREE
 30212                                  ; ERROR:    None
 30213                                  ; USES:     None
 30214                                  ; -----------------------------------------------------------------------------
 30215                                  
 30216                                  unHideMCB:
 30217                                  	push	ax
 30218                                  	mov	word [es:ARENA.OWNER],FreePSPOwner ; 0
 30219                                  	mov	ax,'  ' ; 2020h
 30220                                  	mov	[es:ARENA.NAME+0],ax
 30221                                  	mov	[es:ARENA.NAME+2],ax
 30222                                  	mov	[es:ARENA.NAME+4],ax
 30223                                  	mov	[es:ARENA.NAME+6],ax
 30224                                  	pop	ax
 30225                                  	retn
 30226                                  
 30227                                  ; -----------------------------------------------------------------------------
 30228                                  ;*** findUMB - makes ES:0 point to the first MCB in UMB given as AL
 30229                                  ;            -- returns UmbHEAD pointer (0x9FFF) if passed AL==0
 30230                                  ; -----------------------------------------------------------------------------
 30231                                  ; ENTRY:    AL should be to a valid UMB number
 30232                                  ; EXIT:     ES:0 points to first MCB in UMB (_not_ the 8+SC MCB that heads it)
 30233                                  ; ERROR:    Carry set if couldn't reach UMB (too high)
 30234                                  ; USES:     Flags, ES
 30235                                  ; -----------------------------------------------------------------------------
 30236                                  
 30237                                  findUMB:
 30238                                  	push	ax
 30239                                  	push	cx
 30240                                  	push	dx
 30241                                  
 30242                                  	xor	ah,ah		; Zap ah, so al==ax
 30243                                  
 30244                                  	mov	dx,ax		; Store the to-be-found UMB number in DX
 30245                                  
 30246                                  	call	UmbHead		; Returns first UMB segment in AX
 30247                                  	mov	es,ax
 30248                                  	xor	cx,cx		; Pretend we're on UMB 0 for now...
 30249                                  
 30250                                  ; ---------------------------------------------
 30251                                  ; FU10--CX - This UMB number; 0 == conventional
 30252                                  ;       DX - The UMB number they're looking for
 30253                                  ;       ES - The current MCB address
 30254                                  ; ---------------------------------------------
 30255                                  
 30256                                  fu10:	
 30257                                  	cmp	cx,dx		; If CX==DX, we've found the UMB we're
 30258                                  	je	short fuX	; searching for--so exit.
 30259                                  
 30260                                  	call	isSysMCB	; Returns with ZF set if owner is SYSTEM
 30261                                  	jnz	short fu20
 30262                                  
 30263                                  	inc	cx		; If it _was_ SYSTEM, we're in a new UMB.
 30264                                  fu20:	
 30265                                  	mov	al,[es:ARENA.SIGNATURE]
 30266                                  	cmp	al,arena_signature_end ; 'Z'
 30267                                  	je	short fuE	; 'Z' means this was the last MCB... that's it.
 30268                                  
 30269                                  	;NextMCB es, ax		; Go on forward.
 30270                                  	mov     ax,es
 30271                                  	;add	ax,[es:3]
 30272                                  	add     ax,[es:ARENA.SIZE]
 30273                                  	inc     ax
 30274                                  	mov     es,ax
 30275                                  
 30276                                  	jmp	short fu10
 30277                                  fuE:	
 30278                                  	stc
 30279                                  fuX:
 30280                                  	pop	dx
 30281                                  	pop	cx
 30282                                  	pop	ax		; The address is already in ES.
 30283                                  	retn
 30284                                  
 30285                                  ; -----------------------------------------------------------------------------
 30286                                  ;*** BigFree - makes ES:0 point to the largest free MCB in UMB given as AL
 30287                                  ; -----------------------------------------------------------------------------
 30288                                  ; ENTRY:    AL should be to a valid UMB number
 30289                                  ; EXIT:     ES:0 points to largest free MCB in UMB, AX returns its size
 30290                                  ; ERROR:    Carry set if couldn't reach UMB (0 or too high)
 30291                                  ; USES:     Flags, ES
 30292                                  ; -----------------------------------------------------------------------------
 30293                                  
 30294                                  BigFree:
 30295                                  	push	bx
 30296                                  	push	cx
 30297                                  
 30298                                  	call	findUMB			; Returns with CF if err, else ES==MCB
 30299                                  	jc	short bfX		; (would be "jc bfE"; it just does stc)
 30300                                  
 30301                                  	xor	bx,bx			; Segment address of largest free MCB
 30302                                  	xor	cx,cx			; Size of largest free MCB
 30303                                  
 30304                                  ; ---------------------------------------------
 30305                                  ; BF10--ES - Current MCB address
 30306                                  ;       BX - Address of largest free MCB so far
 30307                                  ;       CX - Size of largest free MCB so far
 30308                                  ; ---------------------------------------------
 30309                                  
 30310                                  bf10:	
 30311                                  	call	isSysMCB		; If we've left the MCB, we're done.
 30312                                  	jz	short bf30
 30313                                  
 30314                                  	;call	isFreeMCB		; Returns with ZF set if owner is 0
 30315                                  	or	word [es:ARENA.OWNER],0
 30316                                  	jnz	short bf20
 30317                                  
 30318                                  	mov	ax,[es:ARENA.SIZE]
 30319                                  	;cmp	cx,[es:ARENA.SIZE]	; Compare sizes...
 30320                                  	cmp	cx,ax
 30321                                  	jg	short bf20		; Unless we're bigger,
 30322                                  
 30323                                  	mov	bx,es			; Store this new element's address,
 30324                                  	;mov	cx,[es:ARENA.SIZE]	; and its size.
 30325                                  	mov	cx,ax
 30326                                  
 30327                                  bf20:	mov	al,[es:ARENA.SIGNATURE]
 30328                                  	cmp	al,arena_signature_end	; 'Z'
 30329                                  	jz	short bf30		; 'Z' means this was the last MCB.
 30330                                  
 30331                                  	;NextMCB es,ax		; Go on forward.
 30332                                  	mov     ax,es
 30333                                  	;add	ax,[es:3]
 30334                                  	add     ax,[es:ARENA.SIZE]
 30335                                  	inc     ax
 30336                                  	mov     es,ax
 30337                                  
 30338                                  	jmp	short bf10
 30339                                  
 30340                                  bf30:	mov	es,bx			; Return the address
 30341                                  	mov	ax,cx			; Return the size
 30342                                  	or	bx,bx
 30343                                  	jnz	short bfX		; (if size==0, there's nothing free)
 30344                                  bfE:	
 30345                                  	stc
 30346                                  bfX:
 30347                                  	pop	cx
 30348                                  	pop	bx
 30349                                  	retn
 30350                                  
 30351                                  ; -----------------------------------------------------------------------------
 30352                                  ;*** isSpecified - sets ZF if UMB in AL wasn't specified in DH/LH line.
 30353                                  ; -----------------------------------------------------------------------------
 30354                                  ; ENTRY:    AL should be to a valid UMB number
 30355                                  ; EXIT:     ZF set if UMB wasn't specified, ZF clear if it was
 30356                                  ; ERROR:    None
 30357                                  ; USES:     Flags
 30358                                  ; -----------------------------------------------------------------------------
 30359                                  
 30360                                  isSpecified:
 30361                                  	push	ax
 30362                                  
 30363                                  	xor	bh,bh
 30364                                  	mov	bl,al
 30365                                  
 30366                                  	;getdata al, DS:UmbUsed[bx]
 30367                                  	;
 30368                                  	;push	ds
 30369                                  	;push	cs
 30370                                  	;pop	ds
 30371                                  	;mov	al,[bx+UmbUsed]
 30372                                  	;pop	ds
 30373                                  	
 30374                                  	mov	al,[cs:bx+UmbUsed]
 30375                                  	or	al,al			; Sets ZF if al==0 (ie, if unspecified)
 30376                                  
 30377                                  	pop	ax
 30378                                  	retn
 30379                                  
 30380                                  ; -----------------------------------------------------------------------------
 30381                                  ;*** shrinkMCB - breaks an MCB into two pieces, the lowest one's size==AX
 30382                                  ; -----------------------------------------------------------------------------
 30383                                  ; ENTRY:    AX == new size, ES:0 == current MCB
 30384                                  ; EXIT:     None; MCB broken if carry clear
 30385                                  ; ERROR:    Carry set if MCB isn't as large as AX+0x20 (not a useful split)
 30386                                  ; USES:     Flags
 30387                                  ; -----------------------------------------------------------------------------
 30388                                  ; If the size of the to-be-split MCB isn't at least 0x20 bytes greater than
 30389                                  ; the specified new size, the split is useless; if it's only 0x10 bytes, that
 30390                                  ; 0x10 will be used to make a header that mentions a 0-byte free space, and
 30391                                  ; that just sucks up 0x10 bytes for nothing. So we make 0x20 bytes the
 30392                                  ; minimum for performing a split.
 30393                                  ; -----------------------------------------------------------------------------
 30394                                  
 30395                                  MIN_SPLIT_SIZE	equ	20h
 30396                                  
 30397                                  shrinkMCB:
 30398                                  	;pushreg <bx, cx, es>
 30399                                  	push	bx
 30400                                  	push	cx
 30401                                  	push	es
 30402                                  
 30403                                  	mov	bx,ax			; Move things around... and
 30404                                  	mov	ax,es			; save this one for later.
 30405                                  
 30406                                  	mov	cx,[es:ARENA.SIZE]
 30407                                  	sub	cx,MIN_SPLIT_SIZE ; 32
 30408                                  	;cmp	bx,cx			; {New size} vs {Current Size-20h}
 30409                                  	;ja	short smE		; if wanted_size > cur-20h, abort.
 30410                                  	; 18/12/2022
 30411                                  	cmp	cx,bx
 30412                                  	jb	short smE ; (*)
 30413                                  
 30414                                  	mov	dl,[es:ARENA.SIGNATURE]
 30415                                  	mov	cx,[es:ARENA.SIZE]
 30416                                  
 30417                                  	mov	[es:ARENA.SIZE],bx
 30418                                  	mov	byte [es:ARENA.SIGNATURE],'M'
 30419                                  
 30420                                  	add	ax,bx
 30421                                  	inc	ax
 30422                                  	mov	es,ax			; Move to new arena area
 30423                                  
 30424                                  	mov	ax,cx
 30425                                  	sub	ax,bx
 30426                                  	; 12/12/2022
 30427                                  	; ax > 0
 30428                                  	dec	ax			; And prepare the new size
 30429                                  
 30430                                  	; 18/12/2022
 30431                                  	mov	[es:ARENA.SIGNATURE],dl
 30432                                  	;mov	word [es:ARENA.OWNER],0 ; (**)
 30433                                  	mov	[es:ARENA.SIZE],ax
 30434                                  	;mov	ax,'  ' ; 2020h
 30435                                  	;mov	[es:ARENA.NAME+0],ax ; (**)
 30436                                  	;mov	[es:ARENA.NAME+2],ax ; (**)
 30437                                  	;mov	[es:ARENA.NAME+4],ax ; (**)
 30438                                  	;mov	[es:ARENA.NAME+6],ax ; (**)
 30439                                  
 30440                                  	; 18/12/2022
 30441                                  	call	freeMCB	; (**)
 30442                                  
 30443                                  	; 12/12/2022
 30444                                  	; cf=0
 30445                                  	;clc
 30446                                  	; 18/12/2022
 30447                                  	;jmp	short smX
 30448                                  smE:	
 30449                                  	; 18/12/2022
 30450                                  	; cf=1 (*)
 30451                                  	;stc
 30452                                  smX:	
 30453                                  	;popreg	<es, cx, bx>
 30454                                  	pop	es
 30455                                  	pop	cx
 30456                                  	pop	bx
 30457                                  	retn
 30458                                  
 30459                                  ; -----------------------------------------------------------------------------
 30460                                  ;*** hideUMB? - hides as appropriate the UMB in CL
 30461                                  ; -----------------------------------------------------------------------------
 30462                                  ; ENTRY:    CL should be to a valid UMB number, and AX to its address (findUMB)
 30463                                  ; EXIT:     None; UMB is hidden as necessary
 30464                                  ; ERROR:    None
 30465                                  ; USES:     Flags, AX, CX
 30466                                  ; -----------------------------------------------------------------------------
 30467                                  ; PRIMARY LOGIC:
 30468                                  ;
 30469                                  ; If the UMB is specified in the DH/LH statement, then:
 30470                                  ;    If the largest free segment is too small (check specified size), then:
 30471                                  ;       Pretend it wasn't ever specified, and fall out of this IF.
 30472                                  ;    Else, if largest free segment is LARGER than specified size, then:
 30473                                  ;       If /S was given on the command-line, then:
 30474                                  ;          Break that element into two pieces
 30475                                  ;          Set a flag that we're shrinking
 30476                                  ;       Endif
 30477                                  ;    Endif
 30478                                  ; Endif
 30479                                  ; If the UMB is NOT specified (or was removed by the above):
 30480                                  ;    Hide all free elements in the UMB
 30481                                  ;    If the flag that we're shrinking was set, then:
 30482                                  ;       UN-hide the lower portion of the shrunken UMB
 30483                                  ;    ENDIF
 30484                                  ; ENDIF
 30485                                  ; -----------------------------------------------------------------------------
 30486                                  
 30487                                  _hideUMB_:
 30488                                  	push	bx
 30489                                  	push	dx
 30490                                  	push	es
 30491                                  
 30492                                  	mov	al,cl
 30493                                  	call	isSpecified	; Returns ZF set if al's umb was NOT specified
 30494                                  	jz	short hu_20
 30495                                  
 30496                                  	mov	al,cl		; Retrieve the size of the largest
 30497                                  	call	BigFree		; free element in AX; put its address in ES
 30498                                  	jc	short hu_20	; Oops. Errors mean skip this part.
 30499                                  
 30500                                  	push	ax		; TOS==size of BigFree in UMB (popped as BX)
 30501                                  	mov	al,cl		; Retrieve the user's specified
 30502                                  	call	GetSize		; minimum size for this umb (into AX)
 30503                                  	pop	bx		; Now BX==BigFree, AX==Specified Size
 30504                                  
 30505                                  	or	ax,ax		; If they didn't specify one,
 30506                                  	jz	short hu_20	; Skip over all this.
 30507                                  
 30508                                  	cmp	ax,bx		; Ah... if (specified > max free)
 30509                                  	jbe	short hu_10
 30510                                  
 30511                                  	mov	al,cl		;   Then mark that UMB as unused. Nya nya.
 30512                                  	call	unMarkUMB
 30513                                  	jmp	short hu_20
 30514                                  hu_10:	
 30515                                  	call	isTiny		; Returns ZF clear if user specified /S
 30516                                  	jz	short hu_20
 30517                                  
 30518                                  	call	shrinkMCB	; They specified /S, so shrink the MCB to AX
 30519                                  	jc	short hu_20	; Ah... if didn't shrink after all, skip this:
 30520                                  
 30521                                  	mov	dx,es
 30522                                  	jmp	short hu_30	; Skip the spec check.. we wanna hide this one.
 30523                                  
 30524                                  hu_20:	mov	ax,cx
 30525                                  	call	isSpecified	; If they specified this UMB, we're done...
 30526                                  	jnz	short hu_X	; so leave.
 30527                                  
 30528                                  	xor	dx,dx
 30529                                  hu_30:	
 30530                                  	mov	al,cl
 30531                                  
 30532                                  	call	hideUMB		; Hides everything in UMB #al
 30533                                  
 30534                                  	or	dx,dx		; Did we shrink a UMB? If not, DX==0,
 30535                                  	jz	short hu_X	; So we should leave.
 30536                                  
 30537                                  	mov	es,dx		; Ah, but if it isn't, DX==the MCB's address;
 30538                                  	call	unHideMCB	; Un-hides the lower portion of that MCB.
 30539                                  hu_X:	
 30540                                  	pop	es
 30541                                  	pop	dx
 30542                                  	pop	bx
 30543                                  	retn
 30544                                  
 30545                                  ; -----------------------------------------------------------------------------
 30546                                  ;*** UnFreeze - Marks FROZEN elements as FREE
 30547                                  ; -----------------------------------------------------------------------------
 30548                                  ; Entry:  None
 30549                                  ; Exit:   None; all 8+FROZEN elements are marked as FREE, from any UMB.
 30550                                  ; Error:  None
 30551                                  ; Uses:   Flags
 30552                                  ; -----------------------------------------------------------------------------
 30553                                  
 30554                                  UnFreeze:
 30555                                  	push	ax
 30556                                  	push	es
 30557                                  
 30558                                  	call	UmbHead		; Returns with carry if err, else ES == MCB
 30559                                  	jc	short ufX
 30560                                  
 30561                                  	mov	es,ax
 30562                                  
 30563                                  ; ------------------------------
 30564                                  ; UF10--ES - Current MCB address
 30565                                  ; ------------------------------
 30566                                  
 30567                                  uf10:	call	isFrozMCB	; Returns with ZF set if MCB is FROZEN
 30568                                  	jnz	short uf20
 30569                                  	call	unHideMCB
 30570                                  uf20:	
 30571                                  	mov	al,[es:ARENA.SIGNATURE]
 30572                                  
 30573                                  	cmp	al,arena_signature_end ; 'Z'
 30574                                  	jz	short ufX	; 'Z' means this was the last MCB... that's it.
 30575                                  
 30576                                  	;NextMCB es, ax		; Go on forward.
 30577                                  	mov     ax,es
 30578                                  	;add	ax,[es:3]
 30579                                  	add     ax,[es:ARENA.SIZE]
 30580                                  	inc     ax
 30581                                  	mov     es,ax
 30582                                  
 30583                                  	jmp	short uf10
 30584                                  ufX:	
 30585                                  	pop	es
 30586                                  	pop	ax
 30587                                  	retn
 30588                                  
 30589                                  ; -----------------------------------------------------------------------------
 30590                                  ;*** isFrozMCB - returns with ZF set if current MCB (ES:0) is FROZEN
 30591                                  ; -----------------------------------------------------------------------------
 30592                                  ; ENTRY:    ES:0 should point to an MCB
 30593                                  ; EXIT:     ZF set if MCB is frozen, else !ZF
 30594                                  ; ERROR:    None
 30595                                  ; USES:     Flags
 30596                                  ; -----------------------------------------------------------------------------
 30597                                  
 30598                                  isFrozMCB:
 30599                                  	;push	ax
 30600                                  
 30601                                  	;mov	ax,[es:ARENA.OWNER]	; Check the owner...
 30602                                  	;cmp	ax,SystemPSPOwner	; 8 (for US OR Japan) is valid
 30603                                  	cmp	word [es:ARENA.OWNER],SystemPSPOwner
 30604                                  	jne	short ifmX
 30605                                  
 30606                                  	;mov	ax,[es:ARENA.NAME+0]
 30607                                  	;cmp	ax,'FR' ; 5246h
 30608                                  	cmp	word [es:ARENA.NAME+0],'FR'
 30609                                  	jne	short ifmX
 30610                                  	;mov	ax,[es:ARENA.NAME+2]
 30611                                  	;cmp	ax,'OZ' ; 5A4Fh
 30612                                  	cmp	word [es:ARENA.NAME+2],'OZ'
 30613                                  	jne	short ifmX
 30614                                  	;mov	ax,[es:ARENA.NAME+4]
 30615                                  	;cmp	ax,'EN' ; 4E45h
 30616                                  	cmp	word [es:ARENA.NAME+4],'EN'
 30617                                  	jne	short ifmX
 30618                                  	;mov	ax,[es:ARENA.NAME+6]
 30619                                  	;cmp	ax,'  ' ; 2020h
 30620                                  	cmp	word [es:ARENA.NAME+6],'  '
 30621                                  ifmX:	
 30622                                  	;pop	ax
 30623                                  	retn
 30624                                  
 30625                                  ; -----------------------------------------------------------------------------
 30626                                  ;*** frezMCB - marks as 8+FROZEN the MCB at ES:0
 30627                                  ; -----------------------------------------------------------------------------
 30628                                  ; ENTRY:    ES:0 should point to an MCB
 30629                                  ; EXIT:     None; MCB frozen
 30630                                  ; ERROR:    None
 30631                                  ; USES:     None
 30632                                  ; -----------------------------------------------------------------------------
 30633                                  
 30634                                  frezMCB:
 30635                                  	mov	word [es:ARENA.OWNER],SystemPSPOwner ; 8
 30636                                  	mov	word [es:ARENA.NAME+0],'FR'
 30637                                  	mov	word [es:ARENA.NAME+2],'OZ'
 30638                                  	mov	word [es:ARENA.NAME+4],'EN'
 30639                                  	mov	word [es:ARENA.NAME+6],'  '
 30640                                  	retn
 30641                                  
 30642                                  ; -----------------------------------------------------------------------------
 30643                                  ;*** FreezeUM - Marks FROZEN all UM elements now FREE, save those in load UMB
 30644                                  ; -----------------------------------------------------------------------------
 30645                                  ; Entry:  None
 30646                                  ; Exit:   None; all free elements not in load UMB marked as 8+FROZEN
 30647                                  ; Error:  None
 30648                                  ; Uses:   Flags
 30649                                  ; -----------------------------------------------------------------------------
 30650                                  
 30651                                  FreezeUM:
 30652                                  	push	ax
 30653                                  	push	cx
 30654                                  	push	dx
 30655                                  	push	es
 30656                                  
 30657                                  	;call	GetLoadUMB
 30658                                  	mov	al,[cs:UmbLoad] ; 19/04/2019 - Retro DOS v4.0
 30659                                  
 30660                                  	xor	ah,ah		; Zap ah, so al==ax
 30661                                  	mov	dx,ax		; Store the load UMB in DX, so we can skip it
 30662                                  
 30663                                  	call	UmbHead		; Returns first UMB segment in AX
 30664                                  	mov	es,ax
 30665                                  	xor	cx,cx		; Pretend we're on UMB 0 for now...
 30666                                  
 30667                                  ; -----------------------------------------
 30668                                  ; FUM10--ES - Current MCB address
 30669                                  ;        CX - Current UMB number
 30670                                  ;        DX - UMB number to skip (load UMB)
 30671                                  ; -----------------------------------------
 30672                                  
 30673                                  fum10:	call	isSysMCB	; Returns with ZF set if owner is SYSTEM
 30674                                  	jnz	short fum20
 30675                                  
 30676                                  	inc	cx		; If it _was_ SYSTEM, we're in a new UMB.
 30677                                  fum20:	
 30678                                  	cmp	cx,dx		; If this is the load UMB, we don't want to
 30679                                  	je	short fum30	; freeze anything... so skip that section.
 30680                                  
 30681                                  	;call	isFreeMCB	; Oh. If it's not free, we can't freeze it
 30682                                  	or	word [es:ARENA.OWNER],0
 30683                                  	jnz	short fum30	; either.
 30684                                  
 30685                                  	call	frezMCB
 30686                                  fum30:	
 30687                                  	mov	al,[es:ARENA.SIGNATURE]
 30688                                  	cmp	al,arena_signature_end ; 'Z'
 30689                                  	je	short fumX	; 'Z' means this was the last MCB... that's it.
 30690                                  
 30691                                  	;NextMCB es, ax		; Go on forward.
 30692                                  	mov     ax,es
 30693                                  	;add	ax,[es:3]
 30694                                  	add     ax,[es:ARENA.SIZE]
 30695                                  	inc     ax
 30696                                  	mov     es,ax
 30697                                  	
 30698                                  	jmp	short fum10
 30699                                  
 30700                                  fumX:	pop	es
 30701                                  	pop	dx
 30702                                  	pop	cx
 30703                                  	pop	ax
 30704                                  	retn
 30705                                  
 30706                                  ; -----------------------------------------------------------------------------
 30707                                  ;*** UmbTest - returns with carry set if UMBs are not available, else CF==false
 30708                                  ; -----------------------------------------------------------------------------
 30709                                  ; ENTRY:    None
 30710                                  ; EXIT:     Carry is clear if UMBs are available, or set if they are not
 30711                                  ; ERROR:    None
 30712                                  ; USES:     CF (AX,BX,DS,ES pushed 'cause they're used by others)
 30713                                  ; -----------------------------------------------------------------------------
 30714                                  
 30715                                  UmbTest:
 30716                                  	push	ax
 30717                                  	push	bx
 30718                                  	push	ds
 30719                                  	push	es
 30720                                  
 30721                                  	call	fm_link			; Link in UMBs (if not already linked)
 30722                                  	call	WalkMem			; Check to see if they're really linked
 30723                                  	pushf				; And remember what we found out
 30724                                  	call	fm_unlink		; Unlink UMBs (if WE have linked 'em)
 30725                                  	popf				; And restore what we found out.
 30726                                  
 30727                                  	pop	es
 30728                                  	pop	ds
 30729                                  	pop	bx
 30730                                  	pop	ax
 30731                                  	retn
 30732                                  
 30733                                  ; -----------------------------------------------------------------------------
 30734                                  ;*** WalkMem - travels memory chain and returns carry clear iff UMBs are linked
 30735                                  ; -----------------------------------------------------------------------------
 30736                                  ; ENTRY:    None
 30737                                  ; EXIT:     Carry SET if MCB chain stops before 9FFF, CLEAR if stops >= 9FFF.
 30738                                  ; ERROR:    None
 30739                                  ; USES:     Flags
 30740                                  ; -----------------------------------------------------------------------------
 30741                                  
 30742                                  WalkMem:
 30743                                  	push	ax ; ?
 30744                                  	push	bx ; ?
 30745                                  	push	es ; ? no need to save contents of these registers ?
 30746                                  		   	
 30747                                  	mov	ah,GET_IN_VARS		; Call int 21h, function 52h...
 30748                                  	int	21h
 30749                                  
 30750                                  	mov	ax,[es:bx-2]
 30751                                  	mov	es,ax
 30752                                  
 30753                                  ; ------------------------------
 30754                                  ; UM10: ES = Current MCB pointer
 30755                                  ; ------------------------------
 30756                                  
 30757                                  um10:	mov	al,[es:ARENA.SIGNATURE]
 30758                                  	cmp	al,arena_signature_end ;  'Z'
 30759                                  	je	short um20		; If signature == 'Z', hay no more.
 30760                                  
 30761                                  	;NextMCB es, bx			; Move to the next MCB
 30762                                  
 30763                                  	mov     bx,es
 30764                                  	;add	bx,[es:3]
 30765                                  	add     bx,[es:ARENA.SIZE]
 30766                                  	inc     bx
 30767                                  	mov     es,bx
 30768                                  		
 30769                                  	jmp	short um10		; And restart the loop.
 30770                                  um20:	
 30771                                  	mov	ax,es
 30772                                  
 30773                                  	cmp	ax,9FFFh		; This sets CF iff ax < 9FFF.
 30774                                  
 30775                                  	pop	es ; ?
 30776                                  	pop	bx ; ?
 30777                                  	pop	ax ; ?
 30778                                  	retn
 30779                                  
 30780                                  ; -----------------------------------------------------------------------------
 30781                                  ;*** hl_unlink - unlinks UMBs if fm_umb is set to 0; restores strategy too
 30782                                  ; -----------------------------------------------------------------------------
 30783                                  ; ENTRY:    fm_umb == 1 : leave linked, else unlink
 30784                                  ; EXIT:     None
 30785                                  ; ERROR:    None
 30786                                  ; USES:     AX, BX
 30787                                  ; -----------------------------------------------------------------------------
 30788                                  
 30789                                  hl_unlink:
 30790                                  	xor	bh,bh
 30791                                  
 30792                                  	;getdata bl,fm_umb		; Restore original link-state
 30793                                  	;
 30794                                  	;push	ds
 30795                                  	;push	cs
 30796                                  	;pop	ds
 30797                                  	;mov	bl,[fm_umb]
 30798                                  	;pop	ds
 30799                                  
 30800                                  	mov	bl,[cs:fm_umb]
 30801                                  
 30802                                  	mov	ax,DOS_SET_UMBLINK ; 5803h
 30803                                  	int	21h
 30804                                  	retn
 30805                                  
 30806                                  ; ----------------------------------------------------------------------
 30807                                  ; HIGHEXIT.INC (MSDOS 6.0 - 1991) 	
 30808                                  ; ----------------------------------------------------------------------
 30809                                  ; 09/04/2019 - Retro DOS v4.0
 30810                                  
 30811                                  ;   Module:   HIGHEXIT.INC - Code executed after LoadHigh or DeviceHigh
 30812                                  ;   Date:     May 14, 1992
 30813                                  
 30814                                  ;   Modification log:
 30815                                  ;
 30816                                  ;     DATE    WHO      DESCRIPTION
 30817                                  ;   --------  -------  --------------------------------------------------------
 30818                                  ;   05/14/92  t-richj  Original
 30819                                  ;   06/21/92  t-richj  Final revisions before check-in
 30820                                  
 30821                                  UMB_HeadIdx	equ	8Ch	; Offset from ES (after func52h) to get UMBHead
 30822                                  
 30823                                  ; -----------------------------------------------------------------------------
 30824                                  ;*** UnHideUMBs - Marks HIDDEN elements as FREE
 30825                                  ; -----------------------------------------------------------------------------
 30826                                  ; ENTRY:  None; perhaps, earlier, HideUMBs was called... if not, we have
 30827                                  ;               very little to do, as no elelments will be marked as HIDDEN.
 30828                                  ; EXIT:   Sets InHigh to zero; carry clear if HideUMBs was called earlier.
 30829                                  ; ERROR:  None
 30830                                  ; USES:   fInHigh (from highvar.inc), carry flag
 30831                                  ; -----------------------------------------------------------------------------
 30832                                  
 30833                                  UnHideUMBs:
 30834                                  	push	ax		; Save ax for what we're about to do
 30835                                  
 30836                                  ; -----------------------------------------------------------------------------
 30837                                  ; BUGBUG t-richj 11-8-92: The following six lines were commented out for a good
 30838                                  ;    length of time. Those six constitute a check of whether or not we should
 30839                                  ;    indeed clean up the upper-memory chain; without such a check, COMMAND.COM
 30840                                  ;    will destroy the current link-state and memory-allocation strategy after
 30841                                  ;    every command execution.
 30842                                  ; -----------------------------------------------------------------------------
 30843                                  
 30844                                  	;getdata al,fInHigh	; Get InHigh from data segment
 30845                                  	;
 30846                                  	;push	ds
 30847                                  	;push	cs
 30848                                  	;pop	ds
 30849                                  	;mov	al,[fInHigh]
 30850                                  	;pop	ds	
 30851                                  
 30852                                  	mov	al,[cs:fInHigh]
 30853                                  
 30854                                  	or	al,al
 30855                                  	jnz	short uhu10	; If didn't call loadhigh/devicehigh earlier,
 30856                                  
 30857                                  	pop	ax		; then there's nothing to do here... so
 30858                                  	stc			; restore everything and return. Just like
 30859                                  	retn			; that.
 30860                                  uhu10:	
 30861                                  	call	linkumb		; Make sure UMBs are linked in.
 30862                                  	call	FreeUMBs
 30863                                  
 30864                                  	;putdata fInHigh,0	; We're leaving, so update fInHigh.
 30865                                  	;
 30866                                  	;push	es
 30867                                  	;push	cs
 30868                                  	;pop	es
 30869                                  	;mov	byte [es:fInHigh],0
 30870                                  	;pop	ds	
 30871                                  
 30872                                  	mov	byte [cs:fInHigh],0	
 30873                                  
 30874                                  	call	he_unlink	; Unlink UMBs
 30875                                  
 30876                                  	pop	ax
 30877                                  	; 12/12/2022
 30878                                  	;clc	; 12/12/2022 (this clc may not be necessary!?)
 30879                                  	retn
 30880                                  
 30881                                  ; -----------------------------------------------------------------------------
 30882                                  ;*** he_unlink - unlinks UMBs if fm_umb is set to 0
 30883                                  ; -----------------------------------------------------------------------------
 30884                                  ; ENTRY:    fm_umb == 1 : leave linked, else unlink
 30885                                  ; EXIT:     None
 30886                                  ; ERROR:    None
 30887                                  ; USES:     AX, BX
 30888                                  ; -----------------------------------------------------------------------------
 30889                                  
 30890                                  he_unlink:
 30891                                  	xor	bh, bh
 30892                                  
 30893                                  	;getdata bl, fm_umb	; Restore original link-state
 30894                                  	mov	bl,[cs:fm_umb]	
 30895                                  
 30896                                  	mov	ax,DOS_SET_UMBLINK ; 5803h
 30897                                  	int	21h
 30898                                  	retn
 30899                                  
 30900                                  ; -----------------------------------------------------------------------------
 30901                                  ;*** freeUMBs - frees all HIDDEN memory elements in upper-memory.
 30902                                  ; -----------------------------------------------------------------------------
 30903                                  ; ENTRY:    None
 30904                                  ; EXIT:     None; HIDDEN memory elements returned to FREE
 30905                                  ; ERROR:    None (ignore CF)
 30906                                  ; USES:     Flags
 30907                                  ; -----------------------------------------------------------------------------
 30908                                  
 30909                                  FreeUMBs:
 30910                                  	push	ax
 30911                                  	push	es
 30912                                  
 30913                                  	call	HeadUmb		; Returns with carry if err, else ES == MCB
 30914                                  	jc	short fusX
 30915                                  
 30916                                  	mov	es,ax		; Prepare for the loop; ES = current MCB addr.
 30917                                  fus10:	
 30918                                  	call	isHideMCB	; Returns with ZF set if owner is 0
 30919                                  	jnz	short fus20
 30920                                  	call	freeMCB
 30921                                  fus20:	   
 30922                                  	mov	al,[es:ARENA.SIGNATURE]
 30923                                  	cmp	al,arena_signature_end ; 'Z'
 30924                                  	jz	short fusX	; That means this was the last MCB--that's it.
 30925                                  
 30926                                  	mov	ax,es
 30927                                  	add	ax,[es:ARENA.SIZE]
 30928                                  	inc	ax
 30929                                  	mov	es,ax		; Go on forward.
 30930                                  
 30931                                  	jmp	short fus10
 30932                                  fusX:	
 30933                                  	pop	es
 30934                                  	pop	ax
 30935                                  	retn
 30936                                  
 30937                                  ; -----------------------------------------------------------------------------
 30938                                  ;*** isHideMCB - returns with ZF set if current MCB (ES:0) is HIDDEN
 30939                                  ; -----------------------------------------------------------------------------
 30940                                  ; ENTRY:    ES:0 should point to an MCB
 30941                                  ; EXIT:     ZF set if MCB is hidden, else !ZF
 30942                                  ; ERROR:    None
 30943                                  ; USES:     Flags
 30944                                  ; -----------------------------------------------------------------------------
 30945                                  
 30946                                  isHideMCB:
 30947                                  	;push	ax
 30948                                  
 30949                                  	cmp	word [es:ARENA.OWNER],SystemPSPOwner ; If the owner's SYSTEM
 30950                                  	jne	short ihm_x				; then check for HIDDEN
 30951                                  
 30952                                  	;mov	ax,[es:ARENA.NAME]
 30953                                  	;cmp	ax,'HI' ; 4948h
 30954                                  	cmp	word [es:ARENA.NAME+0],'HI'
 30955                                  	jne	short ihm_x
 30956                                  	;mov	ax,[es:ARENA.NAME+2]
 30957                                  	;cmp	ax,'DD' ; 4444h
 30958                                  	cmp	word [es:ARENA.NAME+2],'DD'
 30959                                  	jne	short ihm_x
 30960                                  	;mov	ax,[es:ARENA.NAME+4]
 30961                                  	;cmp	ax,'EN' ; 4E45h
 30962                                  	cmp	word [es:ARENA.NAME+4],'EN'
 30963                                  	jne	short ihm_x
 30964                                  	;mov	ax,[es:ARENA.NAME+6]
 30965                                  	;cmp	ax,'  ' ; 2020h
 30966                                  	cmp	word [es:ARENA.NAME+6],'  '
 30967                                  ihm_x:	
 30968                                  	;pop	ax
 30969                                  	retn
 30970                                  
 30971                                  ; -----------------------------------------------------------------------------
 30972                                  ;*** freeMCB - marks as free the MCB at ES:0
 30973                                  ; -----------------------------------------------------------------------------
 30974                                  ; ENTRY:    ES:0 should point to an MCB
 30975                                  ; EXIT:     None; MCB free'd
 30976                                  ; ERROR:    None
 30977                                  ; USES:     AX
 30978                                  ; -----------------------------------------------------------------------------
 30979                                  
 30980                                  freeMCB:
 30981                                  	mov	word [es:ARENA.OWNER],0
 30982                                  	mov	ax,'  '
 30983                                  	mov	[es:ARENA.NAME+0],ax
 30984                                  	mov	[es:ARENA.NAME+2],ax
 30985                                  	mov	[es:ARENA.NAME+4],ax
 30986                                  	mov	[es:ARENA.NAME+6],ax
 30987                                  	retn
 30988                                  
 30989                                  ; -----------------------------------------------------------------------------
 30990                                  ;*** HeadUmb - returns in AX the address of the first UMB block (0x9FFF)
 30991                                  ; -----------------------------------------------------------------------------
 30992                                  ; ENTRY:  Nothing
 30993                                  ; EXIT:   AX contains 0x9FFF for most systems
 30994                                  ; ERROR:  Carry set if pointer is 0xFFFF (if not set up yet--DH runs into this)
 30995                                  ; USES:   Flags, AX
 30996                                  ; -----------------------------------------------------------------------------
 30997                                  
 30998                                  HeadUmb:
 30999                                  	; 13/05/2019
 31000                                  
 31001                                  	;push	si ; ?
 31002                                  	;push	ds ; ?
 31003                                  	;push	es
 31004                                  	;push	bx ; *
 31005                                  
 31006                                  	; 09/04/2019
 31007                                  	; !!! No need to save es,bx,ds,si above !!! (es,bx are changed here)
 31008                                  
 31009                                  	mov	ah,GET_IN_VARS		; Call int 21h, function 52h...
 31010                                  	int	21h
 31011                                  			; DOS - 2+ internal - GET LIST OF LISTS
 31012                                  			; Return: ES:BX -> DOS list of lists
 31013                                  	;mov	ax,[es:8Ch]
 31014                                  	mov	ax,[es:UMB_HeadIdx]	; And read what's in ES:008C
 31015                                  	cmp	ax,0FFFFh
 31016                                  	;je	short xhu_e		; If it's 0xFFFF, it's an error...
 31017                                  
 31018                                  	;clc				; Else, it isn't.
 31019                                  	;jmp	short xhu_x
 31020                                  xhu_e:	
 31021                                  	;stc
 31022                                  	cmc	; 09/04/2019 - Retro DOS v4.0 ; *
 31023                                  xhu_x:	
 31024                                  	;pop	bx ; *
 31025                                  	;pop	es	
 31026                                  	;pop	ds ; ?
 31027                                  	;pop	si ; ?
 31028                                  	retn
 31029                                  
 31030                                  ; -----------------------------------------------------------------------------
 31031                                  ;*** linkumb - links UMBs not already linked in; updates fm_umb as needed
 31032                                  ; -----------------------------------------------------------------------------
 31033                                  ; ENTRY:    None
 31034                                  ; EXIT:     fm_umb == 0 if not linked in previously, 1 if already linked in
 31035                                  ; ERROR:    None
 31036                                  ; USES:     AX, BX, fm_umb
 31037                                  ; -----------------------------------------------------------------------------
 31038                                  
 31039                                  linkumb:
 31040                                  	mov	ax,DOS_GET_UMBLINK ; 5802h
 31041                                  	int	21h			; Current link-state is now in al
 31042                                  
 31043                                  	or	al,al			; BUGBUG: proper check?
 31044                                  	jnz	short lumbX		; Jumps if UMBs already linked in
 31045                                  
 31046                                  	mov	ax,DOS_SET_UMBLINK ; 5803h
 31047                                  	mov	bx,1
 31048                                  	int	21h
 31049                                  lumbX:
 31050                                  	retn
 31051                                  
 31052                                  %endif
 31053                                  
 31054                                  ; 01/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 31055                                  ; (SYSINIT:2B5Fh)
 31056                                  
 31057                                  ; ----------------------------------------------------------------------
 31058                                  ; SYSCONF.ASM (MSDOS 6.0 - 1991) 	
 31059                                  ; ----------------------------------------------------------------------
 31060                                  ; 09/04/2019 - Retro DOS v4.0
 31061                                  
 31062                                  ;----------------------------------------------------------------------------
 31063                                  ;
 31064                                  ; procedure : InitDevLoad
 31065                                  ;
 31066                                  ;	Input : DeviceHi = 0 indicates load DD in low memory
 31067                                  ;			 = 1 indicates load in UMB:
 31068                                  ;		           ConvLoad = 0 indicates a new-style load (see below)
 31069                                  ;		                    = 1 indicates a DOS 5-style load
 31070                                  ;		DevSize  = Size of the device driver file in paras
 31071                                  ;
 31072                                  ;	Output : none
 31073                                  ;
 31074                                  ;	Initializes DevLoadAddr, DevLoadEnd & DevEntry.
 31075                                  ;	Also sets up a header for the Device driver entry for mem utility
 31076                                  ;
 31077                                  ;----------------------------------------------------------------------------
 31078                                  ; For a "new-style load", we break off the current DevEntry and link the umbs
 31079                                  ; as we see fit, using HideUMBs (and UnHideUMBs at exit, though _it_ decides
 31080                                  ; whether it's entitled to do anything). HideUMBs uses the chart built by
 31081                                  ; ParseVar to determine which UMBs to leave FREE, and which not.
 31082                                  ;----------------------------------------------------------------------------
 31083                                  
 31084                                  	; 01/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 31085                                  InitDevLoad:
 31086                                  	; 11/12/2022
 31087                                  	; ds = cs
 31088 0000280C 803E[FB1E]00            	cmp	byte [DeviceHi],0
 31089                                  	;cmp	byte [cs:DeviceHi],0	; Are we loading in UMB ?
 31090                                  	;je	short InitForLo		; no, init for lo mem
 31091 00002811 741F                    	je	short initforlo_x ; 09/04/2019
 31092                                  
 31093                                  ; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 31094                                  ;	cmp	byte [cs:ConvLoad],1	; Are we loading as per DOS 5?
 31095                                  ;	je	short InitForConv
 31096                                  ;
 31097                                  ;; There are two stages to preparing upper-memory; first, we mark as 8+HIDDEN
 31098                                  ;; any areas not specified on the /L:... chain. Second, we mark as 8+FROZEN
 31099                                  ;; any areas left in upper-memory, except for elements in the load UMB...
 31100                                  ;; we then malloc space as per Dos-5 style, and mark as free any spaces which
 31101                                  ;; are 8+FROZEN (but leave 8+HIDDEN still hidden). The load is performed,
 31102                                  ;; and UnHideUMBs later on marks all 8+HIDDEN as free.
 31103                                  ;
 31104                                  ;	call	ShrinkUMB		; Stop using the old device arena
 31105                                  ;
 31106                                  ;	call	HideUMBs		; Mark up the UM area as we see fit
 31107                                  ;	call	FreezeUM		; Hide everything BUT the load area
 31108                                  ;	call	GetUMBForDev		; And grab that load area as needed
 31109                                  ;	pushf
 31110                                  ;	call	UnFreeze		; Then unhide everything frozen
 31111                                  ;	popf
 31112                                  ;
 31113                                  ;	jc	short InitForLo		; (if carry, it's loading low)
 31114                                  ;
 31115                                  ;	jmp	short InitForHi
 31116                                  
 31117                                  	; 01/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 31118                                  	; (SYSINIT:2B67h)
 31119                                  InitForConv:
 31120                                  	; 11/12/2022
 31121                                  	; ds = cs
 31122 00002813 E83700                  	call	SpaceInUMB		; Do we have space left in the
 31123                                  					;  current UMB ?
 31124 00002816 7308                    	jnc	short InitForHi		; yes, we have
 31125 00002818 E84F04                  	call	ShrinkUMB		; shrink the current UMB in use
 31126 0000281B E84500                  	call	GetUMBForDev		; else try to allocate new UMB
 31127 0000281E 720D                    	jc	short InitForLo		; we didn't succeed, so load
 31128                                  					;  in low memory
 31129                                  InitForHi:
 31130                                  	; 11/12/2022
 31131                                  	; ds = cs
 31132                                  	;mov	ax,[cs:DevUMBFree]	; get Para addr of free mem
 31133                                  	;mov	dx,[cs:DevUMBAddr]	; UMB start addr
 31134                                  	;add	dx,[cs:DevUMBSize]	; DX = UMB End addr
 31135 00002820 A1[F11E]                	mov	ax,[DevUMBFree]
 31136 00002823 8B16[ED1E]              	mov	dx,[DevUMBAddr]
 31137 00002827 0316[EF1E]              	add	dx,[DevUMBSize]
 31138 0000282B EB0C                    	jmp	short idl1
 31139                                  
 31140                                  InitForLo:
 31141                                  	; 11/12/2022
 31142                                  	; ds = cs
 31143                                  	;mov	byte [cs:DeviceHi],0	; in case we failed to load
 31144 0000282D C606[FB1E]00            	mov	byte [DeviceHi],0
 31145                                  initforlo_x:
 31146                                  	; 11/12/2022
 31147                                  	; ds = cs
 31148                                  					;  into UMB indicate that
 31149                                  					;  we are loading low
 31150                                  	;mov	ax,[cs:memhi]		; AX = start of Low memory
 31151                                  	;mov	dx,[cs:ALLOCLIM]	; DX = End of Low memory
 31152 00002832 A1[E003]                	mov	ax,[memhi]
 31153 00002835 8B16[A302]              	mov	dx,[ALLOCLIM]
 31154                                  idl1:
 31155 00002839 E86C00                  	call	DevSetMark		; setup a sub-arena for DD
 31156                                  	; 11/12/2022
 31157                                  	; ds = cs
 31158                                  	;mov	[cs:DevLoadAddr],ax	; init the Device load address
 31159                                  	;mov	[cs:DevLoadEnd],dx	; init the limit of the block
 31160                                  	;mov	word [cs:DevEntry],0	; init Entry point to DD
 31161                                  	;mov	[cs:DevEntry+2],ax
 31162 0000283C A3[E01E]                	mov	[DevLoadAddr],ax
 31163 0000283F 8916[E21E]              	mov	[DevLoadEnd],dx
 31164 00002843 C706[E41E]0000          	mov	word [DevEntry],0
 31165 00002849 A3[E61E]                	mov	[DevEntry+2],ax
 31166 0000284C C3                      	retn
 31167                                  
 31168                                  ;----------------------------------------------------------------------------
 31169                                  ;
 31170                                  ; procedure : SpaceInUMB?
 31171                                  ;
 31172                                  ;	Input : DevUMBAddr, DevUMBSize, DevUMBFree & DevSize
 31173                                  ;	Output : Carry set if no space in UMB
 31174                                  ;		 Carry clear if Space is available for the device in
 31175                                  ;		   current UMB
 31176                                  ;
 31177                                  ;----------------------------------------------------------------------------
 31178                                  
 31179                                  SpaceInUMB:
 31180                                  	; 11/12/2022
 31181                                  	; ds = cs
 31182                                  	;mov	ax,[cs:DevUMBSize]
 31183                                  	;add	ax,[cs:DevUMBAddr]	; End of UMB
 31184                                  	;sub	ax,[cs:DevUMBFree]	; - Free = Remaining space
 31185 0000284D A1[EF1E]                	mov	ax,[DevUMBSize]
 31186 00002850 0306[ED1E]              	add	ax,[DevUMBAddr]		; End of UMB
 31187 00002854 2B06[F11E]              	sub	ax,[DevUMBFree]		; - Free = Remaining space
 31188                                  	; 11/12/2022
 31189                                  	;or	ax,ax			; Nospace ?
 31190                                  	;jnz	short spcinumb1
 31191                                  	;stc
 31192                                  	;retn
 31193                                  	; 11/12/2022
 31194 00002858 83F801                  	cmp	ax,1
 31195 0000285B 7205                    	jb	short spcinumb2	; cf=1
 31196                                  spcinumb1:
 31197 0000285D 48                      	dec	ax			; space for sub-arena
 31198                                  	; 11/12/2022
 31199                                  	; ds = cs
 31200 0000285E 3B06[DE1E]              	cmp	ax,[DevSize]
 31201                                  	;cmp	ax,[cs:DevSize]		; do we have space ?
 31202                                  spcinumb2:
 31203 00002862 C3                      	retn
 31204                                  
 31205                                  ;----------------------------------------------------------------------------
 31206                                  ;
 31207                                  ; procedure : PrepareMark
 31208                                  ;
 31209                                  ;	Input : AX==Address of MCB (not addr of free space), BX==Size
 31210                                  ;	Output : None; MCB marked appropriately and DevUMB* set as needed.
 31211                                  ;
 31212                                  ;----------------------------------------------------------------------------
 31213                                  
 31214                                  ;	; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 31215                                  ;
 31216                                  ;PrepareMark:
 31217                                  ;	push	ds
 31218                                  ;	mov	ds,ax
 31219                                  ;	mov	word [ARENA.OWNER],8
 31220                                  ;	mov	word [ARENA.NAME],'SD' ; 4453h
 31221                                  ;	pop	ds
 31222                                  ;
 31223                                  ;	inc	ax
 31224                                  ;	mov	[cs:DevUMBAddr],ax
 31225                                  ;	mov	[cs:DevUMBFree],ax
 31226                                  ;	mov	[cs:DevUMBSize],bx	; update the UMB Variables
 31227                                  ;	retn
 31228                                  
 31229                                  ;----------------------------------------------------------------------------
 31230                                  ;
 31231                                  ; procedure : GetUMBForDev
 31232                                  ;
 31233                                  ;	Input : DevSize
 31234                                  ;	Output : Carry set if couldn't allocate a UMB to fit the
 31235                                  ;		 the device.
 31236                                  ;		 If success carry clear
 31237                                  ;
 31238                                  ;	Allocates the biggest UMB for loading devices and updates
 31239                                  ;	DevUMBSize, DevUMBAddr & DevUMBFree if it succeeded in allocating
 31240                                  ;	UMB.
 31241                                  ;
 31242                                  ;	This routine relies on the fact that all of the low memory
 31243                                  ;	is allocated, and any DOS alloc calls should return memory
 31244                                  ;	from the UMB pool.
 31245                                  ;
 31246                                  ;----------------------------------------------------------------------------
 31247                                  
 31248                                  	; 01/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 31249                                  	; (SYSINIT:2BC6h)
 31250                                  
 31251                                  GetUMBForDev:
 31252                                  	; 11/12/2022
 31253                                  	; ds = cs
 31254 00002863 BBFFFF                  	mov	bx,0FFFFh
 31255 00002866 B80048                  	mov	ax,4800h
 31256 00002869 CD21                    	int	21h
 31257                                  		; DOS - 2+ - ALLOCATE MEMORY
 31258                                  		; BX = number of 16-byte paragraphs desired
 31259                                  
 31260 0000286B 09DB                    	or	bx,bx
 31261 0000286D 742C                    	jz	short gufd_err
 31262                                  
 31263 0000286F 4B                      	dec	bx
 31264                                  	; 11/12/2022
 31265                                  	; ds = cs
 31266 00002870 391E[DE1E]              	cmp	[DevSize],bx
 31267                                  	;cmp	[cs:DevSize],bx
 31268 00002874 7725                    	ja	short gufd_err
 31269 00002876 43                      	inc	bx
 31270                                  
 31271 00002877 B80048                  	mov	ax,4800h
 31272 0000287A CD21                    	int	21h
 31273 0000287C 721D                    	jc	short gufd_err
 31274                                  
 31275                                  	; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 31276                                  	;dec	ax
 31277                                  	;call	PrepareMark
 31278                                  	;
 31279                                  PrepareMark:
 31280 0000287E 1E                      	push	ds
 31281 0000287F 48                      	dec	ax
 31282 00002880 8ED8                    	mov	ds,ax
 31283 00002882 C70601000800            	mov	word [ARENA.OWNER],8
 31284 00002888 C70608005344            	mov	word [ARENA.NAME],'SD' ; 4453h
 31285 0000288E 40                      	inc	ax
 31286 0000288F 1F                      	pop	ds
 31287                                  	; 11/12/2022
 31288                                  	; ds = cs
 31289                                  	;mov	[cs:DevUMBSize],bx	; update the UMB Variables
 31290                                  	;mov	[cs:DevUMBAddr],ax
 31291                                  	;mov	[cs:DevUMBFree],ax
 31292 00002890 891E[EF1E]              	mov	[DevUMBSize],bx		; update the UMB Variables
 31293 00002894 A3[ED1E]                	mov	[DevUMBAddr],ax
 31294 00002897 A3[F11E]                	mov	[DevUMBFree],ax
 31295                                  	;
 31296                                  	; 11/12/2022
 31297                                  	; cf=0
 31298                                  	;clc				; mark no error
 31299 0000289A C3                      	retn
 31300                                  gufd_err:
 31301 0000289B 31C0                    	xor	ax,ax ; 0
 31302                                  	; 11/12/2022
 31303                                  	; ds = cs
 31304                                  	;mov	[cs:DevUMBSize],ax	; erase the previous values
 31305                                  	;mov	[cs:DevUMBAddr],ax
 31306                                  	;mov	[cs:DevUMBFree],ax
 31307 0000289D A3[EF1E]                	mov	[DevUMBSize],ax		; erase the previous values
 31308 000028A0 A3[ED1E]                	mov	[DevUMBAddr],ax
 31309 000028A3 A3[F11E]                	mov	[DevUMBFree],ax
 31310 000028A6 F9                      	stc
 31311 000028A7 C3                      	retn
 31312                                  
 31313                                  ;----------------------------------------------------------------------------
 31314                                  ;
 31315                                  ; procedure : DevSetMark
 31316                                  ;
 31317                                  ;	Input : AX - Free segment were device is going to be loaded
 31318                                  ;	Output : AX - Segment at which device can be loaded (AX=AX+1)
 31319                                  ;
 31320                                  ;	Creates a sub-arena for the device driver
 31321                                  ;	puts 'D' marker in the sub-arena
 31322                                  ;	Put the owner of the sub-arena as (AX+1)
 31323                                  ;	Copies the file name into sub-arena name field
 31324                                  ;
 31325                                  ;	Size field of the sub-arena will be set only at succesful
 31326                                  ;	completion of Device load.
 31327                                  ;
 31328                                  ;----------------------------------------------------------------------------
 31329                                  
 31330                                  	; 01/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 31331                                  	; (SYSINIT:2C13h)
 31332                                  
 31333                                  DevSetMark:
 31334 000028A8 06                      	push	es
 31335 000028A9 57                      	push	di
 31336 000028AA 1E                      	push	ds
 31337 000028AB 56                      	push	si
 31338 000028AC 8EC0                    	mov	es,ax
 31339 000028AE 26C606000044            	mov	byte [es:devmark.id],devmark_device ; 'D'
 31340 000028B4 40                      	inc	ax
 31341 000028B5 26A30100                	mov	[es:devmark.seg],ax
 31342                                  
 31343                                  ;-------------- Copy file name
 31344                                  
 31345 000028B9 50                      	push	ax			; save load addr
 31346 000028BA 2EC536[F803]            	lds	si,[cs:bpb_addr]	; command line is still there
 31347                                  
 31348 000028BF 89F7                    	mov	di,si
 31349 000028C1 FC                      	cld
 31350                                  dsm_again:
 31351 000028C2 AC                      	lodsb
 31352 000028C3 3C3A                    	cmp	al,':'
 31353 000028C5 7504                    	jne	short isit_slash
 31354 000028C7 89F7                    	mov	di,si
 31355 000028C9 EBF7                    	jmp	short dsm_again
 31356                                  isit_slash:
 31357 000028CB 3C5C                    	cmp	al, '\'
 31358 000028CD 7504                    	jne	short isit_null
 31359 000028CF 89F7                    	mov	di,si
 31360 000028D1 EBEF                    	jmp	short dsm_again
 31361                                  isit_null:
 31362 000028D3 08C0                    	or	al,al
 31363 000028D5 75EB                    	jnz	short dsm_again
 31364 000028D7 89FE                    	mov	si,di
 31365                                  
 31366 000028D9 BF0800                  	mov	di,devmark.filename ; 8
 31367 000028DC B90800                  	mov	cx,8			; maximum 8 characters
 31368                                  dsm_next_char:
 31369 000028DF AC                      	lodsb
 31370 000028E0 08C0                    	or	al, al
 31371 000028E2 7407                    	jz	short blankout
 31372 000028E4 3C2E                    	cmp	al, '.'
 31373 000028E6 7403                    	je	short blankout
 31374 000028E8 AA                      	stosb
 31375 000028E9 E2F4                    	loop	dsm_next_char
 31376                                  blankout:
 31377 000028EB E304                    	jcxz	dsm_exit
 31378 000028ED B020                    	mov	al, ' '
 31379 000028EF F3AA                    	rep	stosb			; blank out the rest
 31380                                  dsm_exit:
 31381 000028F1 58                      	pop	ax			; restore load addr
 31382 000028F2 5E                      	pop	si
 31383 000028F3 1F                      	pop	ds
 31384 000028F4 5F                      	pop	di
 31385 000028F5 07                      	pop	es
 31386 000028F6 C3                      	retn
 31387                                  
 31388                                  ;----------------------------------------------------------------------------
 31389                                  ;
 31390                                  ; procedure : SizeDevice
 31391                                  ;
 31392                                  ;	Input : ES:SI - points to device file to be sized
 31393                                  ;
 31394                                  ;	Output : Carry set if file cannot be opened or if it is an OS2EXE file
 31395                                  ;
 31396                                  ;	Calculates the size of the device file in paras and stores it
 31397                                  ;	in DevSize
 31398                                  ;
 31399                                  ;----------------------------------------------------------------------------
 31400                                  
 31401                                  	; 01/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 31402                                  SizeDevice:
 31403                                  	; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 31404                                  	; 11/12/2022 ; *
 31405 000028F7 1E                      	push	ds ; *
 31406 000028F8 06                      	push	es
 31407 000028F9 1F                      	pop	ds
 31408 000028FA 89F2                    	mov	dx,si			; ds:dx -> file name
 31409 000028FC B8003D                  	mov	ax,3D00h		; open
 31410 000028FF CD21                    	int	21h
 31411 00002901 7243                    	jc	short sd_err		; open failed
 31412                                  
 31413 00002903 89C3                    	mov	bx,ax			; BX - file handle
 31414 00002905 B80242                  	mov	ax,4202h		; seek
 31415 00002908 31C9                    	xor	cx,cx
 31416 0000290A 89CA                    	mov	dx,cx			; to end of file
 31417 0000290C CD21                    	int	21h
 31418 0000290E 722F                    	jc	short sd_close		; did seek fail (impossible)
 31419 00002910 83C00F                  	add	ax,15			; para convert
 31420 00002913 83D200                  	adc	dx,0
 31421 00002916 F7C2F0FF                	test	dx,0FFF0h		; size > 0ffff paras ?
 31422 0000291A 7409                    	jz	short szdev1		; no
 31423 0000291C 2EC706[DE1E]FFFF        	mov	word [cs:DevSize],0FFFFh ; invalid device size
 31424                                  					; assuming that we fail later
 31425 00002923 EB1A                    	jmp	short sd_close
 31426                                  szdev1:
 31427 00002925 B104                    	mov	cl,4			; convert it to paras
 31428 00002927 D3E8                    	shr	ax,cl
 31429 00002929 B10C                    	mov	cl,12
 31430 0000292B D3E2                    	shl	dx,cl
 31431 0000292D 09D0                    	or	ax,dx
 31432                                  	;
 31433                                  	; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 31434 0000292F 2E3B06[FC1E]            	cmp     ax,[cs:DevSizeOption]
 31435                                  	;ja	short szdev2
 31436                                  	; 14/08/2023
 31437 00002934 7305                    	jnb	short szdev2
 31438 00002936 2EA1[FC1E]              	mov     ax,[cs:DevSizeOption]
 31439                                  	; 12/12/2022
 31440 0000293A F8                      	clc
 31441                                  szdev2:
 31442 0000293B 2EA3[DE1E]              	mov	[cs:DevSize],ax		; save file size
 31443                                  
 31444                                  	; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 31445                                  	; 12/12/2022
 31446                                  	; cf=0
 31447                                  	;clc
 31448                                  sd_close:
 31449 0000293F 9C                      	pushf				; let close not spoil our
 31450                                  					;  carry flag
 31451 00002940 B8003E                  	mov	ax,3E00h		; close
 31452 00002943 CD21                    	int	21h			; we are not checking for err
 31453 00002945 9D                      	popf
 31454                                  sd_err:
 31455                                  	; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 31456                                  	; 11/12/2022 ; *
 31457 00002946 1F                      	pop     ds ; *
 31458 00002947 C3                      	retn
 31459                                  
 31460                                  ;----------------------------------------------------------------------------
 31461                                  ;
 31462                                  ; procedure : ExecDev
 31463                                  ;
 31464                                  ;	Input : ds:dx -> device to be executed
 31465                                  ;		DevLoadAddr - contains where device has to be loaded
 31466                                  ;
 31467                                  ;	Output : Carry if error
 31468                                  ;		 Carry clear if no error
 31469                                  ;
 31470                                  ;	Loads a device driver using the 4b03h function call
 31471                                  ;
 31472                                  ;----------------------------------------------------------------------------
 31473                                  
 31474                                  	; 01/11/2022
 31475                                  ExecDev:
 31476 00002948 2E8B1E[E01E]            	mov	bx,[cs:DevLoadAddr]
 31477 0000294D 2E891E[F71E]            	mov	[cs:DevExecAddr],bx	; Load the parameter block
 31478                                  					;  block for exec with
 31479                                  					;  Load address
 31480 00002952 2E891E[F91E]            	mov	[cs:DevExecReloc],bx
 31481 00002957 8CCB                    	mov	bx,cs
 31482 00002959 8EC3                    	mov	es,bx
 31483 0000295B BB[F71E]                	mov	bx,DevExecAddr		;es:bx points to parameters
 31484 0000295E B003                    	mov	al,3	; (load program only)
 31485 00002960 B44B                    	mov	ah,EXEC ; 4Bh
 31486 00002962 CD21                    	int	21h			;load in the device driver
 31487                                   		; DOS - 2+ - LOAD OR EXECUTE (EXEC)
 31488                                  		; DS:DX -> ASCIZ filename
 31489                                  		; ES:BX -> parameter block
 31490                                  		; AL = subfunction 
 31491 00002964 C3                      	retn
 31492                                  
 31493                                  ;----------------------------------------------------------------------------
 31494                                  ;
 31495                                  ; procedure : RetFromUM
 31496                                  ;
 31497                                  ;	Input : None
 31498                                  ;	Output : ConvLoad set if didn't previously call HideUMBs
 31499                                  ;		 ConvLoad clear if did.
 31500                                  ;
 31501                                  ;	Prepares memory for more devices after returning from loading one
 31502                                  ;	using the DOS 6 options (/L:... etc).
 31503                                  ;
 31504                                  ;----------------------------------------------------------------------------
 31505                                  
 31506                                  	; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 31507                                  ;RetFromUM:
 31508                                  ;	pushf
 31509                                  ;	mov	byte [cs:ConvLoad],1
 31510                                  ;	call	UnHideUMBs
 31511                                  ;	jc	short rfUM1		; Skip this if didn't HideUMBs
 31512                                  ;	mov	byte [cs:ConvLoad],0
 31513                                  ;rfUM1:	
 31514                                  ;	popf
 31515                                  ;	retn
 31516                                  
 31517                                  ;----------------------------------------------------------------------------
 31518                                  ;
 31519                                  ; procedure : RemoveNull
 31520                                  ;
 31521                                  ;	Input : ES:SI points to a null terminated string
 31522                                  ;
 31523                                  ;	Output : none
 31524                                  ;
 31525                                  ;	Replaces the null at the end of a string with blank
 31526                                  ;
 31527                                  ;----------------------------------------------------------------------------
 31528                                  
 31529                                  	; 01/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 31530                                  	; (SYSINIT:2CCEh)
 31531                                  RemoveNull:
 31532                                  	; 11/12/2022
 31533                                  	; ds = cs
 31534                                  rn_next:
 31535 00002965 268A1C                  	mov	bl,[es:si]
 31536 00002968 08DB                    	or	bl,bl			; null ?
 31537 0000296A 7403                    	jz	short rn_gotnull
 31538 0000296C 46                      	inc	si			; advance the pointer
 31539 0000296D EBF6                    	jmp	short rn_next
 31540                                  rn_gotnull:
 31541                                  	; 11/12/2022
 31542 0000296F 8A1E[101F]              	mov	bl,[DevSavedDelim]
 31543                                  	;mov	bl,[cs:DevSavedDelim]
 31544 00002973 26881C                  	mov	[es:si],bl		; replace null with blank
 31545                                  	; 02/11/2022
 31546                                  ; 11/12/2022
 31547                                  rba_ok:		; 10/04/2019
 31548 00002976 C3                      	retn
 31549                                  
 31550                                  ;----------------------------------------------------------------------------
 31551                                  ;
 31552                                  ; procedure : RoundBreakAddr
 31553                                  ;
 31554                                  ;	Input : DevBrkAddr
 31555                                  ;	Output : DevBrkAddr
 31556                                  ;
 31557                                  ;	Rounds DevBrkAddr to a para address so that it is of the form xxxx:0
 31558                                  ;
 31559                                  ;----------------------------------------------------------------------------
 31560                                  
 31561                                  RoundBreakAddr:
 31562 00002977 2EA1[E81E]              	mov	ax,[cs:DevBrkAddr]
 31563 0000297B E83BE7                  	call	ParaRound
 31564 0000297E 2E0106[EA1E]            	add	[cs:DevBrkAddr+2],ax
 31565 00002983 2EC706[E81E]0000        	mov	word [cs:DevBrkAddr],0
 31566 0000298A 2EA1[E21E]              	mov	ax,[cs:DevLoadEnd]
 31567 0000298E 2E3906[EA1E]            	cmp	[cs:DevBrkAddr+2],ax
 31568 00002993 76E1                    	jbe	short rba_ok
 31569 00002995 E96507                  	jmp	mem_err
 31570                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 31571                                  	; 11/12/2022
 31572                                  ;rba_ok:
 31573                                  ;	retn
 31574                                  
 31575                                  ;----------------------------------------------------------------------------
 31576                                  ;
 31577                                  ; procedure : DevSetBreak
 31578                                  ;
 31579                                  ;	Input : DevBrkAddr
 31580                                  ;	Output : Carry set if Device returned Init failed
 31581                                  ;		 Else carry clear
 31582                                  ;
 31583                                  ;----------------------------------------------------------------------------
 31584                                  
 31585                                  DevSetBreak:
 31586 00002998 50                      	push	ax
 31587                                  
 31588 00002999 2EA1[EA1E]              	mov	ax,[cs:DevBrkAddr+2]	 ;remove the init code
 31589 0000299D 2E803E[2B14]00          	cmp	byte [cs:multdeviceflag],0
 31590 000029A3 750F                    	jne	short set_break_continue ;do not check it.
 31591 000029A5 2E3B06[E01E]            	cmp	ax,[cs:DevLoadAddr]
 31592 000029AA 7508                    	jne	short set_break_continue ;if not same, then o.k.
 31593                                  
 31594                                  	;cmp	word [cs:DevBrkAddr],0
 31595                                  	;je	short break_failed	;[DevBrkAddr+2]=[memhi] & [DevBrkAddr]=0
 31596                                  	; 12/12/2022
 31597 000029AC 2E833E[E81E]01          	cmp	word [cs:DevBrkAddr],1
 31598 000029B2 7204                    	jb	short break_failed
 31599                                  
 31600                                  set_break_continue:
 31601 000029B4 E8C0FF                  	call	RoundBreakAddr
 31602                                  	; 12/12/2022
 31603 000029B7 F8                      	clc
 31604                                  break_failed:
 31605 000029B8 58                      	pop	ax
 31606                                  	;clc
 31607 000029B9 C3                      	retn
 31608                                  
 31609                                  	; 12/12/2022
 31610                                  ;break_failed:
 31611                                  	;pop	ax
 31612                                  	;stc
 31613                                  	;retn
 31614                                  
 31615                                  ;----------------------------------------------------------------------------
 31616                                  ;
 31617                                  ; procedure : DevBreak
 31618                                  ;
 31619                                  ;	Input : DevLoadAddr & DevBrkAddr
 31620                                  ;	Output : none
 31621                                  ;
 31622                                  ;	Marks a succesful install of a device driver
 31623                                  ;	Sets device size field in sub-arena &
 31624                                  ;	Updates Free ptr in UMB or adjusts memhi
 31625                                  ;
 31626                                  ;----------------------------------------------------------------------------
 31627                                  
 31628                                  	; 11/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 31629                                  DevBreak:
 31630                                  	;push	ds ; 11/12/2022
 31631                                  
 31632                                  	; 11/12/2022
 31633 000029BA 0E                      	push	cs
 31634 000029BB 1F                      	pop	ds
 31635                                  	;mov	ax,[cs:DevLoadAddr]
 31636                                  	;mov	bx,[cs:DevBrkAddr+2]
 31637 000029BC A1[E01E]                	mov	ax,[DevLoadAddr]
 31638 000029BF 8B1E[EA1E]              	mov	bx,[DevBrkAddr+2]
 31639                                  	; 11/12/2022
 31640 000029C3 1E                      	push	ds
 31641                                  
 31642 000029C4 48                      	dec	ax			; seg of sub-arena
 31643 000029C5 8ED8                    	mov	ds,ax
 31644 000029C7 40                      	inc	ax			; Back to Device segment
 31645 000029C8 29D8                    	sub	ax,bx
 31646 000029CA F7D8                    	neg	ax			; size of device in paras
 31647 000029CC A30300                  	mov	[devmark.size],ax	; store it in sub-arena
 31648                                  	
 31649                                  	; 11/12/2022
 31650 000029CF 1F                      	pop	ds
 31651                                  	; ds = cs
 31652                                   	
 31653 000029D0 803E[FB1E]00            	cmp	byte [DeviceHi],0
 31654                                  	;cmp	byte [cs:DeviceHi],0
 31655 000029D5 7405                    	je	short db_lo
 31656                                  	;mov	[cs:DevUMBFree],bx	; update Free ptr in UMB
 31657                                  	;jmp	short db_exit
 31658                                  	; 11/12/2022
 31659 000029D7 891E[F11E]              	mov	[DevUMBFree],bx
 31660 000029DB C3                      	retn	
 31661                                  db_lo:
 31662                                  	; 11/12/2022
 31663                                  	; ds = cs
 31664                                  	;mov	[cs:memhi],bx
 31665                                  	;mov	word [cs:memlo],0
 31666 000029DC 891E[E003]              	mov	[memhi],bx
 31667 000029E0 C706[DE03]0000          	mov	word [memlo],0 ; 18/12/2022
 31668                                  db_exit:
 31669                                  	;pop	ds ; 11/12/2022
 31670 000029E6 C3                      	retn
 31671                                  
 31672                                  ; 10/04/2019 - Retro DOS v4.0
 31673                                  
 31674                                  ;----------------------------------------------------------------------------
 31675                                  ;
 31676                                  ; procedure : ParseSize
 31677                                  ;
 31678                                  ;	Parses the command line for SIZE= command
 31679                                  ;
 31680                                  ;	ES:SI = command line to parsed
 31681                                  ;
 31682                                  ;	returns ptr to command line after SIZE= option in ES:SI
 31683                                  ;	updates the DevSizeOption variable with value supplied
 31684                                  ;	in SIZE=option
 31685                                  ;	Returns carry if the SIZE option was invalid
 31686                                  ;
 31687                                  ;----------------------------------------------------------------------------
 31688                                  
 31689                                  	; 02/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 31690                                  	; (SYSINIT:2D5Ah)
 31691                                  ParseSize:
 31692                                  	;push	bx
 31693                                  	;mov	bx,si
 31694                                  
 31695                                  	; 11/12/2022
 31696                                  	; ds = cs
 31697                                  	;mov	word [cs:DevSizeOption],0 ; init the value
 31698                                  	;mov	[cs:DevCmdLine],si
 31699                                  	;mov	[cs:DevCmdLine+2],es
 31700 000029E7 C706[FC1E]0000          	mov	word [DevSizeOption],0 ; init the value
 31701 000029ED 8936[0C1F]              	mov	[DevCmdLine],si
 31702 000029F1 8C06[0E1F]              	mov	[DevCmdLine+2],es	
 31703 000029F5 E82800                  	call	SkipDelim
 31704 000029F8 26813C5349              	cmp	word [es:si],'SI' ; 4953h
 31705 000029FD 751F                    	jne	short ps_no_size
 31706 000029FF 26817C025A45            	cmp	word [es:si+2],'ZE' ; 455Ah
 31707 00002A05 7517                    	jne	short ps_no_size
 31708 00002A07 268A4404                	mov	al,[es:si+4]
 31709 00002A0B E86B06                  	call	delim
 31710 00002A0E 750E                    	jne	short ps_no_size
 31711 00002A10 83C605                  	add	si,5
 31712 00002A13 E81500                  	call	GetHexNum
 31713 00002A16 7207                    	jc	short ps_err
 31714                                  	; 11/12/2022
 31715                                  	; ds = cs
 31716                                  	;mov	[cs:DevSizeOption],ax
 31717 00002A18 A3[FC1E]                	mov	[DevSizeOption],ax
 31718 00002A1B E80200                  	call	SkipDelim
 31719                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 31720                                  	;mov	bx,si
 31721                                  ps_no_size:	
 31722                                  	;mov	si,bx
 31723                                  	;pop	bx
 31724 00002A1E F8                      	clc	; cf=0
 31725                                  	;retn
 31726                                  	; 11/12/2022
 31727                                  ps_err:		; cf=1
 31728                                  sd_ret:		; cf=?
 31729 00002A1F C3                      	retn
 31730                                  ;ps_err:
 31731                                  	; 02/11/2022
 31732                                  	;pop	bx
 31733                                  	;stc
 31734                                  	; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 31735                                  	; 11/12/2022
 31736                                  	; cf=1
 31737                                  	;stc
 31738                                  	; 11/12/2022
 31739                                  ;sd_ret: 
 31740                                  	; 22/07/2023
 31741                                  	; 12/04/2019
 31742                                  	;retn
 31743                                  
 31744                                  ; 12/04/2019 - Retro DOS v4.0
 31745                                  
 31746                                  ;----------------------------------------------------------------------------
 31747                                  ;
 31748                                  ; procedure : SkipDelim
 31749                                  ;
 31750                                  ;	Skips delimiters in the string pointed to by ES:SI
 31751                                  ;	Returns ptr to first non-delimiter character in ES:SI
 31752                                  ;
 31753                                  ;----------------------------------------------------------------------------
 31754                                  	
 31755                                  	; 01/11/2022
 31756                                  SkipDelim:
 31757                                  sd_next_char:
 31758 00002A20 268A04                  	mov	al,[es:si]
 31759 00002A23 E85306                  	call	delim
 31760 00002A26 75F7                    	jnz	short sd_ret
 31761 00002A28 46                      	inc	si
 31762 00002A29 EBF5                    	jmp	short sd_next_char ; 01/11/2022
 31763                                  	; 11/12/2022
 31764                                  	; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 31765                                  ;sd_ret:
 31766                                  	;retn
 31767                                  
 31768                                  ;----------------------------------------------------------------------------
 31769                                  ;
 31770                                  ; procedure : GetHexNum
 31771                                  ;
 31772                                  ;	Converts an ascii string terminated by a delimiter into binary.
 31773                                  ;	Assumes that the ES:SI points to a Hexadecimal string
 31774                                  ;
 31775                                  ;	Returns in AX the number number of paras equivalent to the
 31776                                  ;	hex number of bytes specified by the hexadecimal string.
 31777                                  ;
 31778                                  ;	Returns carry in case it encountered a non-hex character or
 31779                                  ;	if it encountered crlf
 31780                                  ;
 31781                                  ;----------------------------------------------------------------------------
 31782                                  
 31783                                  ; 13/05/2019
 31784                                  
 31785                                  	; 01/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 31786                                  	; (SYSINIT:2DA5h)
 31787                                  GetHexNum:
 31788 00002A2B 31C0                    	xor	ax,ax
 31789 00002A2D 31D2                    	xor	dx,dx
 31790                                  ghn_next:
 31791 00002A2F 268A1C                  	mov	bl,[es:si]
 31792 00002A32 80FB0D                  	cmp	bl,cr  ; 0Dh
 31793 00002A35 7436                    	je	short ghn_err
 31794 00002A37 80FB0A                  	cmp	bl,lf  ; 0Ah
 31795 00002A3A 7431                    	je	short ghn_err
 31796 00002A3C 50                      	push	ax
 31797 00002A3D 88D8                    	mov	al,bl
 31798 00002A3F E83706                  	call	delim
 31799 00002A42 58                      	pop	ax
 31800                                  	; 04/01/2023
 31801 00002A43 B90400                  	mov	cx, 4
 31802 00002A46 7410                    	jz	short ghn_into_paras
 31803 00002A48 E82400                  	call	GetNibble
 31804                                  	;jc	short ghn_err
 31805                                  	; 11/12/2022
 31806 00002A4B 7221                    	jc	short ghn_ret ; cf=1
 31807                                  	; 04/01/2023
 31808                                  	;mov	cx,4
 31809                                  ghn_shift1:
 31810 00002A4D D1E0                    	shl	ax,1
 31811 00002A4F D1D2                    	rcl	dx,1
 31812 00002A51 E2FA                    	loop	ghn_shift1
 31813 00002A53 08D8                    	or	al,bl
 31814 00002A55 46                      	inc	si
 31815 00002A56 EBD7                    	jmp	short ghn_next
 31816                                  ghn_into_paras:
 31817 00002A58 83C00F                  	add	ax,15
 31818 00002A5B 83D200                  	adc	dx,0
 31819 00002A5E F7C2F0FF                	test	dx,0FFF0h
 31820 00002A62 7509                    	jnz	short ghn_err
 31821                                  	; 04/01/2023
 31822                                  	;mov	cx,4
 31823                                  ghn_shift2:
 31824 00002A64 F8                      	clc
 31825 00002A65 D1DA                    	rcr	dx,1
 31826 00002A67 D1D8                    	rcr	ax,1
 31827 00002A69 E2F9                    	loop	ghn_shift2
 31828 00002A6B F8                      	clc
 31829 00002A6C C3                      	retn
 31830                                  	; 11/12/2022
 31831                                  ghn_err:
 31832                                  gnib_err:
 31833 00002A6D F9                      	stc
 31834                                  ghn_ret:
 31835                                  gnib_ret:
 31836 00002A6E C3                      	retn
 31837                                  
 31838                                  ;----------------------------------------------------------------------------
 31839                                  ;
 31840                                  ; procedure : GetNibble
 31841                                  ;
 31842                                  ;	Convert one nibble (hex digit) in BL into binary
 31843                                  ;
 31844                                  ;	Retruns binary value in BL
 31845                                  ;
 31846                                  ;	Returns carry if BL contains non-hex digit
 31847                                  ;
 31848                                  ;----------------------------------------------------------------------------
 31849                                  
 31850                                  GetNibble:
 31851 00002A6F 80FB30                  	cmp	bl,'0'
 31852                                  	;jb	short gnib_err
 31853                                  	; 11/12/2022
 31854 00002A72 72FA                    	jb	short gnib_ret ; cf=1
 31855 00002A74 80FB39                  	cmp	bl,'9'
 31856 00002A77 7704                    	ja	short is_it_hex
 31857 00002A79 80EB30                  	sub	bl,'0'		; clc
 31858 00002A7C C3                      	retn
 31859                                  is_it_hex:
 31860 00002A7D 80FB41                  	cmp	bl,'A'
 31861                                  	;jb	short gnib_err
 31862                                  	; 11/12/2022
 31863 00002A80 72EC                    	jb	short gnib_ret ; cf=1
 31864 00002A82 80FB46                  	cmp	bl,'F'
 31865 00002A85 77E6                    	ja	short gnib_err ; 11/12/2022
 31866 00002A87 80EB37                  	sub	bl,'A'- 10	; clc
 31867 00002A8A C3                      	retn
 31868                                  	; 11/12/2022
 31869                                  ;gnib_err:
 31870                                  ;	stc
 31871                                  ;gnib_ret:
 31872                                  ;	retn
 31873                                  
 31874                                  ;============================================================================
 31875                                  
 31876                                  ; 12/04/2019 - Retro DOS v4.0
 31877                                  
 31878                                  ; umb.inc (MSDOS 6.0, 1991)
 31879                                  DOS_ARENA	equ 24h		; offset of arena_head var in DOS data segm.
 31880                                  UMB_ARENA	equ 8Ch		; offset of umb_head in DOS data
 31881                                  
 31882                                  XMM_REQUEST_UMB	equ 10h
 31883                                  XMM_RELEASE_UMB	equ 11h
 31884                                  
 31885                                  ;----------------------------------------------------------------------------
 31886                                  ;
 31887                                  ; procedure : AllocUMB
 31888                                  ;
 31889                                  ;	Allocate all UMBs and link it to DOS arena chain
 31890                                  ;
 31891                                  ;----------------------------------------------------------------------------
 31892                                  
 31893                                  AllocUMB:
 31894                                  	; 31/12/2022
 31895                                  	; ds = cs
 31896 00002A8B E81000                  	call	InitAllocUMB		; link in the first UMB
 31897 00002A8E 720D                    	jc	short au_exit		; quit on error
 31898                                  au_next:
 31899 00002A90 E83900                  	call	umb_allocate		; allocate
 31900 00002A93 7205                    	jc	short au_coalesce
 31901 00002A95 E85200                  	call	umb_insert		; & insert till no UMBs
 31902 00002A98 EBF6                    	jmp	short au_next
 31903                                  au_coalesce:
 31904 00002A9A E80B01                  	call	umb_coalesce		; coalesce all UMBs
 31905                                  au_exit:
 31906                                  	; 31/12/2022
 31907                                  	; ds = cs
 31908 00002A9D C3                      	retn
 31909                                  
 31910                                  ;----------------------------------------------------------------------------
 31911                                  ;
 31912                                  ; procedure : InitAllocUMB
 31913                                  ;
 31914                                  ;----------------------------------------------------------------------------
 31915                                  
 31916                                  InitAllocUMB:
 31917                                  	; 31/12/2022
 31918                                  	; ds = cs
 31919 00002A9E E878DF                  	call	IsXMSLoaded
 31920 00002AA1 7527                    	jnz	short iau_err		; quit on no XMS driver
 31921 00002AA3 B452                    	mov	ah,52h
 31922 00002AA5 CD21                    	int	21h			; get DOS DATA seg
 31923                                  	; 31/12/2022
 31924                                  	; ds = cs
 31925                                  	;mov	[cs:DevDOSData],es	; & save it for later
 31926 00002AA7 8C06[0A1F]              	mov	[DevDOSData],es		; & save it for later
 31927 00002AAB B81043                  	mov	ax,4310h
 31928 00002AAE CD2F                    	int	2Fh
 31929                                  	;mov	[cs:DevXMSAddr],bx	; get XMS driver address
 31930                                  	;mov	[cs:DevXMSAddr+2],es
 31931 00002AB0 891E[F31E]              	mov	[DevXMSAddr],bx		; get XMS driver address
 31932 00002AB4 8C06[F51E]              	mov	[DevXMSAddr+2],es	
 31933                                  	; 31/12/2022
 31934 00002AB8 803E[091F]00            	cmp	byte [FirstUMBLinked],0 
 31935                                  	;cmp	byte [cs:FirstUMBLinked],0 ; have we already linked a UMB?
 31936                                  	;jne	short ia_1		; quit if we already did it
 31937                                  	; 12/12/2022
 31938 00002ABD 770A                    	ja	short ia_1 ; cf=0
 31939 00002ABF E83401                  	call	LinkFirstUMB		; else link the first UMB
 31940                                  	;jc	short iau_err
 31941                                  	; 12/12/2022
 31942 00002AC2 7207                    	jc	short iau_err2  ; cf=1
 31943                                  	; 31/12/2022
 31944                                  	; ds = cs
 31945 00002AC4 C606[091F]FF            	mov	byte [FirstUMBLinked],0FFh ; mark that 1st UMB linked
 31946                                  	;mov	byte [cs:FirstUMBLinked],0FFh ; mark that 1st UMB linked
 31947                                  ia_1:
 31948                                  	; 12/12/2022
 31949                                  	; cf=0
 31950                                  	;clc
 31951 00002AC9 C3                      	retn
 31952                                  iau_err:
 31953 00002ACA F9                      	stc
 31954                                  iau_err2:
 31955 00002ACB C3                      	retn
 31956                                  
 31957                                  ;-------------------------------------------------------------------------
 31958                                  ;
 31959                                  ; Procedure Name	: umb_allocate
 31960                                  ;
 31961                                  ; Inputs		: DS = data
 31962                                  ;
 31963                                  ; Outputs		: if UMB available
 31964                                  ;				Allocates the largest available UMB and 
 31965                                  ;			  	BX = segment of allocated block
 31966                                  ;				DX = size of allocated block
 31967                                  ;				NC
 31968                                  ;			  else 
 31969                                  ;				CY
 31970                                  ;
 31971                                  ; Uses			: BX, DX
 31972                                  ;
 31973                                  ;-------------------------------------------------------------------------
 31974                                  
 31975                                  umb_allocate:
 31976                                  	; 31/12/2022
 31977                                  	; ds = cs
 31978 00002ACC 50                      	push	ax
 31979 00002ACD B410                    	mov	ah,XMM_REQUEST_UMB ; 16
 31980 00002ACF BAFFFF                  	mov	dx,0FFFFh		; try to allocate largest
 31981                                  					;   possible
 31982                                  	; 31/12/2022
 31983 00002AD2 FF1E[F31E]              	call	far [DevXMSAddr]
 31984                                  	;call	far [cs:DevXMSAddr]
 31985                                  					; dx now contains the size of
 31986                                  					; the largest UMB
 31987 00002AD6 09D2                    	or	dx,dx
 31988 00002AD8 740D                    	jz	short ua_err
 31989                                  	
 31990 00002ADA B410                    	mov	ah,XMM_REQUEST_UMB ; 16
 31991                                  
 31992                                  	; 31/12/2022
 31993 00002ADC FF1E[F31E]              	call	far [DevXMSAddr]
 31994                                  	;call	far [cs:DevXMSAddr]
 31995                                  
 31996 00002AE0 83F801                  	cmp	ax,1			; Q: was the reqst successful
 31997 00002AE3 7502                    	jne	short ua_err		; N: error
 31998                                  	;clc
 31999                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 32000                                  	; 12/12/2022
 32001                                  	; cf=0
 32002                                  	;clc 
 32003                                  ua_done:
 32004 00002AE5 58                      	pop	ax
 32005 00002AE6 C3                      	retn
 32006                                  ua_err:
 32007 00002AE7 F9                      	stc
 32008 00002AE8 EBFB                    	jmp	short ua_done
 32009                                  
 32010                                  ;---------------------------------------------------------------------------
 32011                                  ;
 32012                                  ; Procedure Name	: umb_insert
 32013                                  ;
 32014                                  ; Inputs		: DOSDATA:UMB_HEAD = start of umb chain
 32015                                  ;			: BX = seg address of UMB to be linked in
 32016                                  ;			: DX = size of UMB to be linked in paras
 32017                                  ;			; DS = data
 32018                                  ;
 32019                                  ; Outputs		: links the UMB into the arena chain
 32020                                  ;
 32021                                  ; Uses			: AX, CX, ES, DX, BX
 32022                                  ;
 32023                                  ;---------------------------------------------------------------------------
 32024                                  
 32025                                  umb_insert:
 32026 00002AEA 1E                      	push	ds
 32027                                  
 32028                                  	; 31/12/2022
 32029                                  	; ds = cs
 32030                                  
 32031                                  	;mov	ds,[cs:DevDOSData]
 32032 00002AEB 8E1E[0A1F]              	mov	ds,[DevDOSData] ; 31/12/2022 
 32033                                  	;mov	ds,[8Ch]
 32034 00002AEF 8E1E8C00                	mov	ds,[UMB_ARENA]		; es = UMB_HEAD
 32035 00002AF3 8CD8                    	mov	ax,ds
 32036 00002AF5 8EC0                    	mov	es,ax
 32037                                  ui_next:
 32038 00002AF7 39D8                    	cmp	ax,bx			; Q: is current block above
 32039                                  					;    new block
 32040 00002AF9 770F                    	ja	short ui_insert		; Y: insert it
 32041                                  					; Q: is current block the
 32042                                  					;    last
 32043 00002AFB 26803E00005A            	cmp	byte [es:ARENA.SIGNATURE],arena_signature_end ; 'Z'
 32044 00002B01 745C                    	je	short ui_append		; Y: append new block to chain
 32045                                  					; N: get next block
 32046 00002B03 8ED8                    	mov	ds,ax			; M005
 32047                                  	;call	get_next		; ax = es = next block
 32048 00002B05 E8E200                  	call	_get_next_ ; 13/04/2019 - Retro DOS v4.0
 32049 00002B08 EBED                    	jmp	short ui_next
 32050                                  
 32051                                  ui_insert:
 32052 00002B0A 8CD9                    	mov	cx,ds			; ds = previous arena
 32053 00002B0C 41                      	inc	cx			; top of previous block
 32054                                  
 32055 00002B0D 29D9                    	sub	cx,bx
 32056 00002B0F F7D9                    	neg	cx			; cx = size of used block
 32057                                  	;mov	byte [0],'M'
 32058 00002B11 C60600004D              	mov	byte [ARENA.SIGNATURE],arena_signature_normal ; 'M'
 32059                                  	;mov	word [1],8
 32060 00002B16 C70601000800            	mov	word [ARENA.OWNER],8	; mark as system owned
 32061                                  	;mov	[3],cx
 32062 00002B1C 890E0300                	mov	[ARENA.SIZE],cx	
 32063                                  	;mov	word [8],4353h ; 'SC'
 32064 00002B20 C70608005343            	mov	word [ARENA.NAME],'SC' ; 4353h
 32065                                  
 32066                                  ; prepare the arena at start of new block
 32067                                  
 32068 00002B26 8EC3                    	mov	es,bx
 32069 00002B28 26C60600004D            	mov	byte [es:ARENA.SIGNATURE],arena_signature_normal ; 'M'
 32070 00002B2E 26C70601000000          	mov	word [es:ARENA.OWNER],arena_owner_system ; 0
 32071                                  					; mark as free
 32072 00002B35 83EA02                  	sub	dx,2			; make room for arena at
 32073                                  					; start & end of new block
 32074 00002B38 2689160300              	mov	[es:ARENA.SIZE],dx
 32075                                  
 32076                                  ; prepare arena at end of new block
 32077                                  	
 32078 00002B3D 01D3                    	add	bx,dx
 32079 00002B3F 43                      	inc	bx
 32080 00002B40 8EC3                    	mov	es,bx			; es=arena at top of new block
 32081 00002B42 43                      	inc	bx			; bx=top of new block
 32082                                  
 32083                                  					; ax contains arena just above
 32084                                  					; this block
 32085 00002B43 29D8                    	sub	ax,bx			; ax = size of used block
 32086                                  	
 32087 00002B45 26C60600004D            	mov	byte [es:ARENA.SIGNATURE],arena_signature_normal
 32088 00002B4B 26C70601000800          	mov	word [es:ARENA.OWNER],8	; mark as system owned
 32089 00002B52 26A30300                	mov	[es:ARENA.SIZE],ax	
 32090 00002B56 26C70608005343          	mov	word [es:ARENA.NAME],'SC' ; 4353h
 32091                                  
 32092 00002B5D EB47                    	jmp	short ui_done
 32093                                  
 32094                                  ui_append:
 32095                                  					; es = arena of last block	
 32096 00002B5F 2603060300              	add	ax,[es:ARENA.SIZE]	; ax=top of last block-1 para
 32097 00002B64 26832E030001            	sub	word [es:ARENA.SIZE],1	; reflect the space we are
 32098                                  					; going to rsrv on top of this 
 32099                                  					; block for the next arena.
 32100                                  	; 13/05/2019
 32101 00002B6A 26C60600004D            	mov	byte [es:ARENA.SIGNATURE],arena_signature_normal
 32102                                  
 32103 00002B70 89C1                    	mov	cx,ax			; cx=top of prev block-1
 32104 00002B72 40                      	inc	ax
 32105 00002B73 29D8                    	sub	ax,bx			; ax=top of prev block - 
 32106                                  					;    seg. address of new block
 32107 00002B75 F7D8                    	neg	ax
 32108                                  
 32109 00002B77 8EC1                    	mov	es,cx			; ds = arena of unused block
 32110                                  
 32111 00002B79 26C60600004D            	mov	byte [es:ARENA.SIGNATURE],arena_signature_normal
 32112 00002B7F 26C70601000800          	mov	word [es:ARENA.OWNER],8	; mark as system owned
 32113 00002B86 26A30300                	mov	[es:ARENA.SIZE],ax	
 32114 00002B8A 26C70608005343          	mov	word [es:ARENA.NAME],'SC'
 32115                                  
 32116                                  ; prepare the arena at start of new block
 32117 00002B91 8EC3                    	mov	es,bx
 32118 00002B93 26C60600005A            	mov	byte [es:ARENA.SIGNATURE],arena_signature_end
 32119 00002B99 26C70601000000          	mov	word [es:ARENA.OWNER],arena_owner_system
 32120                                  					; mark as free
 32121 00002BA0 4A                      	dec	dx			; make room for arena
 32122 00002BA1 2689160300              	mov	[es:ARENA.SIZE],dx	
 32123                                  ui_done:
 32124                                  uc_done: ; 31/12/2022 ; *!
 32125 00002BA6 1F                      	pop	ds
 32126                                  	; ds = cs ; 31/12/2022
 32127                                  ;uc_done:	; 18/12/2022
 32128 00002BA7 C3                      	retn
 32129                                  
 32130                                  ; 13/04/2019 - Retro DOS v4.0
 32131                                  
 32132                                  ;----------------------------------------------------------------------------
 32133                                  ;
 32134                                  ;**	umb_coalesce - Combine free blocks ahead with current block
 32135                                  ;
 32136                                  ;	Coalesce adds the block following the argument to the argument block,
 32137                                  ;	iff it's free.  Coalesce is usually used to join free blocks, but
 32138                                  ;	some callers (such as $setblock) use it to join a free block to it's
 32139                                  ;	preceeding allocated block.
 32140                                  ;
 32141                                  ;	EXIT	'C' clear if OK
 32142                                  ;		  (ds) unchanged, this block updated
 32143                                  ;		  (ax) = address of next block, IFF not at end
 32144                                  ;		'C' set if arena trashed
 32145                                  ;	USES	cx, di, ds, es
 32146                                  ;
 32147                                  ;----------------------------------------------------------------------------
 32148                                  
 32149                                  umb_coalesce:
 32150                                  	; 31/12/2022
 32151                                  	; ds = cs
 32152 00002BA8 1E                      	push	ds ; *!
 32153                                  
 32154 00002BA9 31FF                    	xor	di, di
 32155                                  
 32156                                  	;mov	es,[cs:DevDOSData]
 32157                                  	; 31/12/2022
 32158 00002BAB 8E06[0A1F]              	mov	es,[DevDOSData]
 32159 00002BAF 268E068C00              	mov	es,[es:UMB_ARENA]	; es = UMB_HEAD
 32160                                  uc_nextfree:
 32161 00002BB4 8CC0                    	mov	ax,es
 32162 00002BB6 8ED8                    	mov	ds,ax
 32163                                  	;cmp	[es:1],di
 32164 00002BB8 26393E0100              	cmp	[es:ARENA.OWNER],di	; Q: is current arena free
 32165 00002BBD 7407                    	je	short uc_again		; Y: try to coalesce with next block
 32166                                  					; N: get next arena
 32167 00002BBF E82100                  	call	get_next		; es, ax = next arena
 32168 00002BC2 72E2                    	jc	short uc_done	; *!
 32169 00002BC4 EBEE                    	jmp	short uc_nextfree
 32170                                  uc_again:
 32171 00002BC6 E81A00                  	call	get_next		; ES, AX <- next block
 32172 00002BC9 72DB                    	jc	short uc_done	; *!
 32173                                  uc_check:
 32174 00002BCB 26393E0100              	cmp     [es:ARENA.OWNER],di	; Q: is arena free
 32175 00002BD0 75E2                    	jne	short uc_nextfree	; N: get next free arena
 32176                                  					; Y: coalesce
 32177 00002BD2 268B0E0300              	mov     cx,[es:ARENA.SIZE]      ; cx <- next block size
 32178 00002BD7 41                      	inc     cx                      ; cx <- cx + 1 (for header size)
 32179                                  	;add	[3],cx
 32180 00002BD8 010E0300                	add     [ARENA.SIZE],cx		; current size <- current size + cx
 32181 00002BDC 268A0D                  	mov     cl,[es:di]              ; move up signature
 32182 00002BDF 880D                    	mov     [di],cl
 32183 00002BE1 EBE3                    	jmp     short uc_again		; try again
 32184                                  
 32185                                  	; 18/12/2022
 32186                                  ;uc_done:
 32187                                  	;retn
 32188                                  
 32189                                  ;----------------------------------------------------------------------------
 32190                                  ;
 32191                                  ;**	get_next - Find Next item in Arena
 32192                                  ;
 32193                                  ;	ENTRY	dS - pointer to block head
 32194                                  ;	EXIT	AX,ES - pointers to next head
 32195                                  ;		'C' set if arena damaged
 32196                                  ;
 32197                                  ;----------------------------------------------------------------------------
 32198                                  
 32199                                  	; 01/11/2022
 32200                                  get_next:
 32201 00002BE3 803E00005A              	cmp	byte [0],arena_signature_end ; 'Z'
 32202 00002BE8 740A                    	je	short gn_err
 32203                                  _get_next_:
 32204 00002BEA 8CD8                    	mov     ax,ds                   ; ax=current block
 32205 00002BEC 03060300                	add     ax,[ARENA.SIZE]		; ax=ax + current block length
 32206 00002BF0 40                      	inc     ax                      ; remember that header!
 32207 00002BF1 8EC0                    	mov	es,ax
 32208                                  	;clc
 32209                                  	; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 32210                                  	; 11/12/2022
 32211                                  	; cf=0
 32212                                  	;clc
 32213 00002BF3 C3                      	retn
 32214                                  gn_err:
 32215 00002BF4 F9                      	stc
 32216                                  	; 11/12/2022	
 32217                                  lfu_err:	 ; cf=1
 32218 00002BF5 C3                      	retn
 32219                                  
 32220                                  ;----------------------------------------------------------------------------
 32221                                  ;
 32222                                  ; procedure : LinkFirstUMB
 32223                                  ;
 32224                                  ;----------------------------------------------------------------------------
 32225                                  
 32226                                  	; 01/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 32227                                  	; (SYSINIT:2F81h)
 32228                                  LinkFirstUMB:
 32229                                  	; 31/12/2022
 32230                                  	; ds = cs
 32231 00002BF6 E8D3FE                  	call	umb_allocate
 32232 00002BF9 72FA                    	jc	short lfu_err  ; ds = cs ; 31/12/2022
 32233                                  
 32234                                  ; bx = segment of allocated UMB
 32235                                  ; dx = size of UMB
 32236                                  
 32237                                  	; 31/12/2022
 32238                                  	; ds = cs
 32239                                  
 32240 00002BFB CD12                    	int	12h			; ax = size of memory
 32241 00002BFD B106                    	mov	cl,6
 32242 00002BFF D3E0                    	shl	ax,cl			; ax = size in paragraphs
 32243                                  
 32244 00002C01 89C1                    	mov	cx,ax			; cx = size in paras
 32245 00002C03 29D8                    	sub	ax,bx			; ax = - size of unused block
 32246                                  
 32247 00002C05 F7D8                    	neg	ax
 32248                                  
 32249 00002C07 83E901                  	sub	cx,1			; cx = first umb_arena
 32250 00002C0A 8EC1                    	mov	es,cx			; es = first umb_arena
 32251                                  	
 32252 00002C0C 26C60600004D            	mov	byte [es:ARENA.SIGNATURE],arena_signature_normal ; 'M'
 32253 00002C12 26C70601000800          	mov	word [es:ARENA.OWNER],8	; mark as system owned
 32254                                  					
 32255 00002C19 26A30300                	mov	[es:ARENA.SIZE],ax	
 32256 00002C1D 26C70608005343          	mov	word [es:ARENA.NAME],'SC' ; 4353h
 32257                                  
 32258                                  ; put in the arena for the first UMB
 32259                                  
 32260 00002C24 8EC3                    	mov	es,bx			; es has first free umb seg
 32261 00002C26 26C60600005A            	mov	byte [es:ARENA.SIGNATURE],arena_signature_end ; 'Z'
 32262 00002C2C 26C70601000000          	mov	word [es:ARENA.OWNER],arena_owner_system ; 0	
 32263                                  					; mark as free 
 32264 00002C33 4A                      	dec	dx			; make room for arena
 32265 00002C34 2689160300              	mov	[es:ARENA.SIZE],dx	
 32266                                  
 32267                                  	;mov	es,[cs:DevDOSData]
 32268                                  	; 31/12/2022
 32269 00002C39 8E06[0A1F]              	mov	es,[DevDOSData] ; ds = cs
 32270 00002C3D BF8C00                  	mov	di,UMB_ARENA ; 8Ch
 32271 00002C40 26890D                  	mov	[es:di],cx		; initialize umb_head in DOS
 32272                                  					;  data segment with the arena
 32273                                  					;  just below Top of Mem
 32274                                  
 32275                                  ; we must now scan the arena chain and update the size of the last arena
 32276                                  
 32277 00002C43 BF2400                  	mov	di,DOS_ARENA ; 24h
 32278 00002C46 268E05                  	mov	es,[es:di]		; es = start arena
 32279 00002C49 31FF                    	xor	di,di
 32280                                  ;scan_next
 32281                                  ; 09/12/2022
 32282                                  scannext:
 32283 00002C4B 26803D5A                	cmp	byte [es:di],arena_signature_end  ; 'Z'
 32284 00002C4F 740C                    	je	short got_last
 32285                                  	
 32286 00002C51 8CC0                    	mov	ax,es
 32287 00002C53 2603060300              	add	ax,[es:ARENA.SIZE]
 32288 00002C58 40                      	inc	ax
 32289 00002C59 8EC0                    	mov	es,ax
 32290                                  	;jmp	short scan_next
 32291                                  	; 09/12/2022
 32292 00002C5B EBEE                    	jmp	short scannext
 32293                                  got_last:
 32294 00002C5D 26832E030001            	sub	word [es:ARENA.SIZE],1
 32295 00002C63 26C60600004D            	mov	byte [es:ARENA.SIGNATURE],arena_signature_normal ; 'M'
 32296                                  	;clc
 32297                                  	; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 32298                                  	; 11/12/2022
 32299                                  	; cf=0
 32300                                  	;clc
 32301 00002C69 C3                      	retn
 32302                                  
 32303                                  ; 11/12/2022
 32304                                  ;;lfu_err:
 32305                                  ;	;stc
 32306                                  ;	; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 32307                                  ;	; 11/12/2022
 32308                                  ;	; cf=1
 32309                                  ;	;stc
 32310                                  ;	retn
 32311                                  
 32312                                  ;----------------------------------------------------------------------------
 32313                                  ;
 32314                                  ; procedure : ShrinkUMB
 32315                                  ;
 32316                                  ;	Shrinks the current UMB in use, so that the unused portions
 32317                                  ;	of the UMB is given back to the DOS free mem pool
 32318                                  ;
 32319                                  ;----------------------------------------------------------------------------
 32320                                  
 32321                                  ShrinkUMB:
 32322                                  	; 12/12/2022
 32323                                  	; ds = cs
 32324 00002C6A 833E[ED1E]00            	cmp	word [DevUMBAddr],0
 32325                                  	;cmp	word [cs:DevUMBAddr],0
 32326 00002C6F 7421                    	je	short su_exit
 32327 00002C71 06                      	push	es
 32328 00002C72 53                      	push	bx
 32329                                  	; 12/12/2022
 32330                                  	;mov	bx,[cs:DevUMBFree]
 32331                                  	;sub	bx,[cs:DevUMBAddr]
 32332                                  	;mov	es,[cs:DevUMBAddr]
 32333 00002C73 8B1E[F11E]              	mov	bx,[DevUMBFree]
 32334 00002C77 2B1E[ED1E]              	sub	bx,[DevUMBAddr]
 32335 00002C7B 8E06[ED1E]              	mov	es,[DevUMBAddr]
 32336                                  	
 32337 00002C7F B8004A                  	mov	ax,4A00h
 32338 00002C82 CD21                    	int	21h
 32339                                  		; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
 32340                                  		; ES = segment address of block to change
 32341                                  		; BX = new size in paragraphs
 32342 00002C84 8CC0                    	mov	ax,es
 32343 00002C86 48                      	dec	ax
 32344 00002C87 8EC0                    	mov	es,ax
 32345 00002C89 26C70601000800          	mov	word [es:ARENA.OWNER],8
 32346 00002C90 5B                      	pop	bx
 32347 00002C91 07                      	pop	es
 32348                                  su_exit:
 32349 00002C92 C3                      	retn
 32350                                  
 32351                                  ;----------------------------------------------------------------------------
 32352                                  ;
 32353                                  ; procedure : UnlinkUMB
 32354                                  ;
 32355                                  ;	Unlinks the UMBs from the DOS arena chain
 32356                                  ;
 32357                                  ;----------------------------------------------------------------------------
 32358                                  
 32359                                  UnlinkUMB:
 32360                                  	; 12/12/2022
 32361                                  	; ds = cs
 32362 00002C93 1E                      	push	ds
 32363 00002C94 06                      	push	es
 32364                                  	; 12/12/2022
 32365 00002C95 803E[091F]00            	cmp	byte [FirstUMBLinked],0
 32366                                  	;cmp	byte [cs:FirstUMBLinked],0
 32367 00002C9A 7420                    	je	short ulu_x		; nothing to unlink
 32368                                  	; 12/12/2022
 32369 00002C9C 8E06[0A1F]              	mov	es,[DevDOSData]
 32370                                  	;mov	es,[cs:DevDOSData]	; get DOS data seg
 32371 00002CA0 268E1E2400              	mov	ds,[es:DOS_ARENA]
 32372 00002CA5 268B3E8C00              	mov	di,[es:UMB_ARENA]
 32373                                  ulu_next:
 32374 00002CAA E836FF                  	call	get_next
 32375 00002CAD 720D                    	jc	short ulu_x
 32376 00002CAF 39C7                    	cmp	di,ax			; is the next one UMB ?
 32377 00002CB1 7404                    	je	short ulu_found
 32378 00002CB3 8ED8                    	mov	ds,ax
 32379 00002CB5 EBF3                    	jmp	short ulu_next
 32380                                  ulu_found:
 32381                                  	;mov	byte [0],'Z'
 32382 00002CB7 C60600005A              	mov     byte [ARENA.SIGNATURE],arena_signature_end ; 'Z'
 32383                                  ulu_x:
 32384 00002CBC 07                      	pop	es
 32385 00002CBD 1F                      	pop	ds
 32386 00002CBE C3                      	retn
 32387                                  
 32388                                  ; ----------------------------------------------------------------------
 32389                                  ; SYSINIT2.ASM - MSDOS 6.0 - 1991
 32390                                  ; ----------------------------------------------------------------------
 32391                                  ; 14/04/2019 - Retro DOS v4.0
 32392                                  
 32393                                  ; Multiple configuration block support  Created 16-Mar-1992 by JeffPar
 32394                                  ;
 32395                                  ; Summary:
 32396                                  ;
 32397                                  ;   The procedure "organize" crunches the in-memory copy of config.sys
 32398                                  ;   into lines delimited by CR/LF (sometimes no CR, but *always* an LF)
 32399                                  ;   with the leading "keyword=" replaced by single character codes (eg, B
 32400                                  ;   for BUFFERS, D for DEVICE, Z for any unrecognized keyword); see comtab
 32401                                  ;   and/or config.inc for the full list.
 32402                                  ;
 32403                                  ;   [blockname] and INCLUDE are the major syntactical additions for multi-
 32404                                  ;   configuration support. blockname is either MENU, which contains one
 32405                                  ;   or more MENUITEM lines, an optional MENUDEFAULT (which includes optional
 32406                                  ;   time-out), or any user-defined keyword, such as NETWORK, CD-ROM, etc.
 32407                                  ;   INCLUDE allows the current block to name another block for inclusion
 32408                                  ;   during the processing phase of CONFIG.SYS. An INCLUDE is only honored
 32409                                  ;   once, precluding nasty infinite-loop scenarios. If blocks are present
 32410                                  ;   without a MENU block, then only lines inside COMMON blocks are processed.
 32411                                  ;
 32412                                  ; Example:
 32413                                  ;
 32414                                  ;   [menu]
 32415                                  ;   menuitem=misc,Miscellaneous
 32416                                  ;   menuitem=network,Network Configuration
 32417                                  ;   menudefault=network,15
 32418                                  ;
 32419                                  ;   [network]
 32420                                  ;   include misc
 32421                                  ;   device=foo
 32422                                  ;
 32423                                  ;   [misc]
 32424                                  ;   device=bar
 32425                                  ;   include alternate
 32426                                  ;
 32427                                  ;   [alternate]
 32428                                  ;   device=tar
 32429                                  ;
 32430                                  ;
 32431                                  ;   When the menu is displayed
 32432                                  ;
 32433                                  ;    1. Miscellaneous
 32434                                  ;    2. Network Configuration
 32435                                  ;
 32436                                  ;   #2 is highlighted as the default option, and will be automatically
 32437                                  ;   selected after 15 seconds. It will invoke the following lines in the
 32438                                  ;   following order:
 32439                                  ;
 32440                                  ;       DEVICE=BAR
 32441                                  ;       DEVICE=TAR
 32442                                  ;       DEVICE=FOO
 32443                                  ;
 32444                                  
 32445                                  ;MULTI_CONFIG equ 1
 32446                                  
 32447                                  ; the following depend on the positions of the various letters in switchlist
 32448                                  
 32449                                  switchnum	equ 11111000b ; 0F8h	; which switches require number
 32450                                  
 32451                                  flagec35	equ 00000100b ; 4	; electrically compatible 3.5 inch disk drive
 32452                                  flagdrive	equ 00001000b ; 8 
 32453                                  flagcyln	equ 00010000b ; 16
 32454                                  flagseclim	equ 00100000b ; 32
 32455                                  flagheads	equ 01000000b ; 64
 32456                                  flagff		equ 10000000b ; 128
 32457                                  
 32458                                  ;----------------------------------------------------------------------------
 32459                                  ; 19/04/2019 - Retro DOS v4.0
 32460                                  
 32461                                  ; MSDOS 6.21 IO.SYS - SYSINIT:3E78h
 32462                                  
 32463                                  ; 01/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 32464                                  ; MSDOS 5.0 IO.SYS - SYSINIT:3054h
 32465                                  
 32466 00002CBF 00                      insert_blank:	db 	0
 32467                                  
 32468                                  ;----------------------------------------------------------------------------
 32469                                  ;
 32470                                  ; procedure : setparms
 32471                                  ;
 32472                                  ; the following set of routines is used to parse the drivparm = command in
 32473                                  ; the config.sys file to change the default drive parameters.
 32474                                  ;
 32475                                  ;----------------------------------------------------------------------------
 32476                                  
 32477                                  setparms:
 32478 00002CC0 1E                      	push	ds
 32479 00002CC1 50                      	push	ax
 32480 00002CC2 53                      	push	bx
 32481 00002CC3 51                      	push	cx
 32482 00002CC4 52                      	push	dx
 32483                                  
 32484 00002CC5 0E                      	push	cs
 32485 00002CC6 1F                      	pop	ds
 32486                                  
 32487 00002CC7 31DB                    	xor	bx,bx
 32488 00002CC9 8A1E[0237]              	mov	bl,[drive]
 32489                                  	; 18/12/2022
 32490 00002CCD 43                      	inc	bx
 32491                                  	;inc	bl			; get it correct for ioctl call
 32492                                  					; (1=a,2=b...)
 32493 00002CCE BA[DA35]                	mov	dx,deviceparameters
 32494 00002CD1 B444                    	mov	ah,IOCTL ; 44h
 32495 00002CD3 B00D                    	mov	al,GENERIC_IOCTL ; 0Dh
 32496 00002CD5 B508                    	mov	ch,RAWIO ; 8
 32497 00002CD7 B140                    	mov	cl,SET_DEVICE_PARAMETERS ; 40h
 32498 00002CD9 CD21                    	int	21h
 32499                                  
 32500                                  ; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 32501                                  ;
 32502                                  ;	;;mov	ax,Bios_Data		; get Bios_Data segment
 32503                                  ;	;mov	ax,KERNEL_SEGMENT ; 70h
 32504                                  ;	; 21/10/2022
 32505                                  ;	mov	ax,DOSBIODATASEG ; 0070h	
 32506                                  ;	mov	ds,ax			; set Bios_Data segment
 32507                                  ;
 32508                                  ;	test	word [cs:switches],flagec35 ; 4
 32509                                  ;	jz	short not_ec35
 32510                                  
 32511                                  	; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 32512                                  	;test	word [switches],flagec35 ; 4
 32513                                  	; 12/12/2022
 32514 00002CDB F606[0337]04            	test	byte [switches],flagec35 ; 4
 32515 00002CE0 7411                    	jz	short eot_ok
 32516                                  
 32517                                  	;mov	cl,[cs:drive]		; which drive was this for?
 32518                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 32519 00002CE2 8A0E[0237]              	mov	cl,[drive]
 32520 00002CE6 B87000                  	mov	ax,DOSBIODATASEG ; 0070h	
 32521 00002CE9 8ED8                    	mov	ds,ax	
 32522                                  
 32523 00002CEB B001                    	mov	al,1			; assume drive 0
 32524 00002CED D2E0                    	shl	al,cl			; set proper bit depending on drive
 32525                                  	;or	[531h],al ; (MSDOS 6.21 IO.SYS Offset SYINIT:3EACh)
 32526 00002CEF 0806[3105]              	or	[ec35_flag],al		; set the bit in the permanent flags
 32527                                  
 32528                                  ; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 32529                                  ;
 32530                                  ;not_ec35:
 32531                                  ;;	Now adjust the BIOS's EOT variable if our new drive has more
 32532                                  ;;	sectors per track than any old ones.
 32533                                  ;
 32534                                  ;	;mov	al,[cs:deviceparameters+20]
 32535                                  ;	mov	al,[cs:deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_SECTORSPERTRACK]
 32536                                  ;	;cmp	al,[12Ch] ; (MSDOS 6.21 IO.SYS Offset SYINIT:3EB4h)
 32537                                  ;	cmp	al,[EOT]
 32538                                  ;	jbe	short eot_ok
 32539                                  ;	mov	[EOT],al
 32540                                  
 32541                                  eot_ok:
 32542 00002CF3 5A                      	pop	dx			; fix up all the registers
 32543 00002CF4 59                      	pop	cx
 32544 00002CF5 5B                      	pop	bx
 32545 00002CF6 58                      	pop	ax
 32546 00002CF7 1F                      	pop	ds ; 13/05/2019
 32547 00002CF8 C3                      	retn
 32548                                  
 32549                                  ;----------------------------------------------------------------------------
 32550                                  ;
 32551                                  ; procedure : diddleback
 32552                                  ;
 32553                                  ; replace default values for further drivparm commands
 32554                                  ;
 32555                                  ;----------------------------------------------------------------------------
 32556                                  
 32557                                  diddleback:
 32558 00002CF9 1E                      	push	ds
 32559 00002CFA 0E                      	push	cs
 32560 00002CFB 1F                      	pop	ds
 32561                                  	;mov	word [deviceparameters+4],80
 32562 00002CFC C706[DE35]5000          	mov	word [deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS],80
 32563                                  	;mov	byte [deviceparameters+1],2
 32564 00002D02 C606[DB35]02            	mov	byte [deviceparameters+A_DEVICEPARAMETERS.DP_DEVICETYPE],DEV_3INCH720KB ; 2
 32565                                  	;mov	word [deviceparameters+2],0
 32566 00002D07 C706[DC35]0000          	mov	word [deviceparameters+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES],0
 32567 00002D0D C706[0337]0000          	mov	word [switches],0	    ; zero all switches
 32568 00002D13 1F                      	pop	ds
 32569 00002D14 C3                      	retn
 32570                                  
 32571                                  ; 04/01/2023
 32572                                  %if 0
 32573                                  
 32574                                  ; 15/04/2019 - Retro DOS v4.0
 32575                                  
 32576                                  ;----------------------------------------------------------------------------
 32577                                  ;
 32578                                  ; procedure : parseline
 32579                                  ;
 32580                                  ; entry point is parseline. al contains the first character in command line.
 32581                                  ;
 32582                                  ;----------------------------------------------------------------------------
 32583                                  
 32584                                  	; 01/11/2022 - Retrodos v4.0 (Modified MSDOS 5.0 IO.SYS)
 32585                                  	; (SYSINIT:30ACh)
 32586                                  
 32587                                  parseline:
 32588                                  	push	ds
 32589                                  
 32590                                  	push	cs
 32591                                  	pop	ds
 32592                                  
 32593                                  nextswtch:
 32594                                  	cmp	al,cr			; carriage return?
 32595                                  	je	short done_line
 32596                                  	cmp	al,lf			; linefeed?
 32597                                  	je	short put_back		; put it back and done
 32598                                  
 32599                                  ; anything less or equal to a space is ignored.
 32600                                  
 32601                                  	cmp	al,' '                  ; space?
 32602                                  	jbe	short getnext		; skip over space
 32603                                  	cmp	al,'/'
 32604                                  	je	short getparm
 32605                                  	stc				; mark error invalid-character-in-input
 32606                                  	jmp	short exitpl
 32607                                  
 32608                                  getparm:
 32609                                  	call	check_switch
 32610                                  	mov	[switches],bx		; save switches read so far
 32611                                  	jc	short swterr
 32612                                  getnext:
 32613                                  	call	getchr
 32614                                  	jc	short done_line
 32615                                  	jmp	short nextswtch
 32616                                  swterr:
 32617                                  	jmp	short exitpl		; exit if error
 32618                                  
 32619                                  done_line:
 32620                                  	; 12/12/2022
 32621                                  	test	byte [switches],flagdrive ; 8
 32622                                  	;test	word [switches],flagdrive ; 8 ; see if drive specified
 32623                                  	jnz	short okay
 32624                                  	stc				; mark error no-drive-specified
 32625                                  	jmp	short exitpl
 32626                                  
 32627                                  okay:
 32628                                  	mov	ax,[switches]
 32629                                  	and	ax,0003h	    ; get flag bits for changeline and non-rem
 32630                                  	mov	[deviceparameters+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES],ax
 32631                                  	mov	word [deviceparameters+A_DEVICEPARAMETERS.DP_TRACKTABLEENTRIES],0
 32632                                  	;clc			    ; everything is fine
 32633                                  	; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 32634                                  	; 12/12/2022
 32635                                  	; cf=0
 32636                                  	;clc
 32637                                  	call	setdeviceparameters
 32638                                  exitpl:
 32639                                  	pop	ds
 32640                                  	retn
 32641                                  put_back:
 32642                                  	inc	word [count]		; one more char to scan
 32643                                  	dec	word [chrptr]		; back up over linefeed
 32644                                  	jmp	short done_line
 32645                                  
 32646                                  %endif
 32647                                  
 32648                                  ;----------------------------------------------------------------------------
 32649                                  ;
 32650                                  ; procedure : check_switch
 32651                                  ;
 32652                                  ; processes a switch in the input. it ensures that the switch is valid, and
 32653                                  ; gets the number, if any required, following the switch. the switch and the
 32654                                  ; number *must* be separated by a colon. carry is set if there is any kind of
 32655                                  ; error.
 32656                                  ;
 32657                                  ;----------------------------------------------------------------------------
 32658                                  
 32659                                  check_switch:
 32660 00002D15 E817FA                  	call	getchr
 32661                                  	;jc	short err_check
 32662 00002D18 724E                    	jc	short err_chk
 32663 00002D1A 24DF                            and     al,0DFh                 ; convert it to upper case
 32664 00002D1C 3C41                    	cmp	al,'A'
 32665                                  	;jb	short err_check
 32666 00002D1E 7248                    	jb	short err_chk ; 15/04/2019 - Retro DOS v4.0
 32667 00002D20 3C5A                    	cmp	al,'Z'
 32668 00002D22 7743                    	ja	short err_check
 32669                                  
 32670 00002D24 06                      	push	es
 32671                                  
 32672 00002D25 0E                      	push	cs
 32673 00002D26 07                      	pop	es
 32674                                  
 32675 00002D27 8A0E[9637]              	mov	cl,[switchlist]		; get number of valid switches
 32676 00002D2B B500                    	mov	ch,0
 32677 00002D2D BF[9737]                	mov	di,1+switchlist		; point to string of valid switches
 32678 00002D30 F2AE                    	repne	scasb
 32679                                  
 32680 00002D32 07                      	pop	es
 32681 00002D33 7532                    	jnz	short err_check
 32682                                  
 32683 00002D35 B80100                  	mov	ax,1
 32684 00002D38 D3E0                    	shl	ax,cl			; set bit to indicate switch
 32685 00002D3A 8B1E[0337]              	mov	bx,[switches]		; get switches so far
 32686 00002D3E 09C3                    	or	bx,ax			; save this with other switches
 32687 00002D40 89C1                    	mov	cx,ax
 32688                                  	; 12/12/2022
 32689 00002D42 A8F8                    	test	al,switchnum ; 0F8h
 32690                                  	;test	ax,switchnum ; 0F8h	; test against switches that require number to follow
 32691 00002D44 741E                    	jz	short done_swtch
 32692                                  
 32693 00002D46 E8E6F9                  	call	getchr
 32694 00002D49 721A                    	jc	short err_swtch
 32695                                  
 32696 00002D4B 3C3A                    	cmp	al,':'
 32697 00002D4D 7516                    	jne	short err_swtch
 32698                                  
 32699 00002D4F E8DDF9                  	call	getchr
 32700 00002D52 53                      	push	bx			; preserve switches
 32701                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 32702                                  	;mov	byte [cs:sepchr],' '	; allow space separators
 32703                                  	; 12/12/2022
 32704                                  	; ds = cs
 32705 00002D53 C606[2A03]20            	mov	byte [sepchr],' '
 32706 00002D58 E8D803                  	call	getnum
 32707                                  	;mov	byte [cs:sepchr],0
 32708                                  	; 12/12/2022
 32709 00002D5B C606[2A03]00            	mov	byte [sepchr],0
 32710 00002D60 5B                      	pop	bx			; restore switches
 32711                                  
 32712                                  ; because getnum does not consider carriage-return or line-feed as ok, we do
 32713                                  ; not check for carry set here. if there is an error, it will be detected
 32714                                  ; further on (hopefully).
 32715                                  
 32716 00002D61 E80500                  	call	process_num
 32717                                  
 32718                                  done_swtch:
 32719                                  	;clc
 32720                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 32721                                  	; 12/12/2022
 32722                                  	; cf=0
 32723                                  	;clc
 32724 00002D64 C3                      	retn
 32725                                  
 32726                                  err_swtch:
 32727 00002D65 31CB                    	xor	bx,cx			; remove this switch from the records
 32728                                  err_check:
 32729 00002D67 F9                      	stc
 32730                                  err_chk:
 32731 00002D68 C3                      	retn
 32732                                  
 32733                                  ;----------------------------------------------------------------------------
 32734                                  ;
 32735                                  ; procedure : process_num
 32736                                  ;
 32737                                  ; this routine takes the switch just input, and the number following (if any),
 32738                                  ; and sets the value in the appropriate variable. if the number input is zero
 32739                                  ; then it does nothing - it assumes the default value that is present in the
 32740                                  ; variable at the beginning. zero is ok for form factor and drive, however.
 32741                                  ;
 32742                                  ;----------------------------------------------------------------------------
 32743                                  
 32744                                  	; 02/11/2022 - Retrodos v4.0 (Modified MSDOS 5.0 IO.SYS)
 32745                                  	; (SYSINIT:3156h)
 32746                                  process_num:
 32747 00002D69 850E[0337]              	test	[switches],cx		; if this switch has been done before,
 32748 00002D6D 752B                    	jnz	short done_ret		; ignore this one.
 32749                                  	; 12/12/2022
 32750 00002D6F F6C108                  	test	cl,flagdrive ; 8
 32751                                  	;test	cx,flagdrive ; 8
 32752 00002D72 7404                    	jz	short try_f
 32753 00002D74 A2[0237]                	mov	byte [drive],al
 32754                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 32755                                  	;jmp	short done_ret
 32756                                  	; 12/12/2022
 32757                                  	; cf=0
 32758 00002D77 C3                      	retn	; 13/05/2019
 32759                                  try_f:
 32760                                  	; 12/12/2022
 32761 00002D78 F6C180                  	test	cl,flagff ; 80h
 32762                                  	;test	cx,flagff ; 80h
 32763 00002D7B 7404                    	jz	short try_t
 32764                                  
 32765                                  ; ensure that we do not get bogus form factors that are not supported
 32766                                  
 32767                                  	;mov	[deviceparameters+1],al
 32768 00002D7D A2[DB35]                	mov	[deviceparameters+A_DEVICEPARAMETERS.DP_DEVICETYPE],al
 32769                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 32770                                  	;jmp	short done_ret
 32771                                  	; 12/12/2022
 32772                                  	; cf=0
 32773 00002D80 C3                      	retn	; 13/05/2019
 32774                                  try_t:
 32775 00002D81 09C0                    	or	ax,ax
 32776 00002D83 7415                    	jz	short done_ret		; if number entered was 0, assume default value
 32777                                  	; 12/12/2022
 32778 00002D85 F6C110                  	test	cl,flagcyln ; 10h
 32779                                  	;test	cx,flagcyln ; 10h
 32780 00002D88 7404                    	jz	short try_s
 32781                                  
 32782                                  	;mov	[deviceparameters+4],ax
 32783 00002D8A A3[DE35]                	mov	[deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS],ax
 32784                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 32785                                  	;jmp	short done_ret
 32786                                  	; 12/12/2022
 32787                                  	; cf=0
 32788 00002D8D C3                      	retn	; 13/05/2019
 32789                                  try_s:
 32790                                  	; 12/12/2022
 32791 00002D8E F6C120                  	test	cl,flagseclim ; 20h
 32792                                  	;test	cx,flagseclim ; 20h
 32793 00002D91 7404                    	jz	short try_h
 32794 00002D93 A3[0037]                	mov	[slim],ax
 32795                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 32796                                  	;jmp	short done_ret
 32797                                  	; 12/12/2022
 32798                                  	; cf=0
 32799 00002D96 C3                      	retn	; 13/05/2019
 32800                                  
 32801                                  ; must be for number of heads
 32802                                  
 32803                                  try_h:
 32804 00002D97 A3[FE36]                	mov	[hlim],ax
 32805                                  done_ret:
 32806                                  	;clc
 32807                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 32808                                  	; 12/12/2022
 32809                                  	; cf=0 (test instruction resets cf)
 32810                                  	;clc
 32811 00002D9A C3                      	retn
 32812                                  
 32813                                  ; 04/01/2023 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 32814                                  %if 1
 32815                                  
 32816                                  ; 15/04/2019 - Retro DOS v4.0
 32817                                  
 32818                                  ;----------------------------------------------------------------------------
 32819                                  ;
 32820                                  ; procedure : parseline
 32821                                  ;
 32822                                  ; entry point is parseline. al contains the first character in command line.
 32823                                  ;
 32824                                  ;----------------------------------------------------------------------------
 32825                                  
 32826                                  	; 01/11/2022 - Retrodos v4.0 (Modified MSDOS 5.0 IO.SYS)
 32827                                  	; (SYSINIT:30ACh)
 32828                                  parseline:
 32829                                  	; 04/01/2023
 32830                                  	; ds = cs ; *
 32831                                  
 32832                                  	;push	ds ; *
 32833                                  
 32834                                  	;push	cs ; *
 32835                                  	;pop	ds ; *
 32836                                  
 32837                                  nextswtch:
 32838 00002D9B 3C0D                    	cmp	al,cr			; carriage return?
 32839 00002D9D 741C                    	je	short done_line
 32840 00002D9F 3C0A                    	cmp	al,lf			; linefeed?
 32841 00002DA1 7421                    	je	short put_back		; put it back and done
 32842                                  
 32843                                  ; anything less or equal to a space is ignored.
 32844                                  
 32845 00002DA3 3C20                    	cmp	al,' '                  ; space?
 32846 00002DA5 760F                    	jbe	short getnext		; skip over space
 32847 00002DA7 3C2F                    	cmp	al,'/'
 32848 00002DA9 7402                    	je	short getparm
 32849 00002DAB F9                      	stc				; mark error invalid-character-in-input
 32850                                  	;jmp	short exitpl
 32851                                  	; 04/01/2023
 32852                                  swterr:
 32853 00002DAC C3                      	retn
 32854                                  
 32855                                  getparm:
 32856 00002DAD E865FF                  	call	check_switch
 32857 00002DB0 891E[0337]              	mov	[switches],bx		; save switches read so far
 32858 00002DB4 72F6                    	jc	short swterr
 32859                                  getnext:
 32860 00002DB6 E876F9                  	call	getchr
 32861                                  	;jc	short done_line
 32862                                  	;jmp	short nextswtch
 32863                                  	; 04/01/2023
 32864 00002DB9 73E0                    	jnc	short nextswtch
 32865                                  ;swterr:
 32866                                  	;jmp	short exitpl		; exit if error
 32867                                  
 32868                                  done_line:
 32869                                  	; 12/12/2022
 32870 00002DBB F606[0337]08            	test	byte [switches],flagdrive ; 8
 32871                                  	;test	word [switches],flagdrive ; 8 ; see if drive specified
 32872 00002DC0 750C                    	jnz	short okay
 32873 00002DC2 F9                      	stc				; mark error no-drive-specified
 32874                                  	;jmp	short exitpl
 32875                                  	; 04/01/2023
 32876 00002DC3 C3                      	retn
 32877                                  
 32878                                  ;exitpl:
 32879                                  	; 04/01/2023
 32880                                  	; ds = cs
 32881                                  	;;pop	ds ; *
 32882                                  	;retn
 32883                                  
 32884                                  put_back:
 32885 00002DC4 FF06[D203]              	inc	word [count]		; one more char to scan
 32886 00002DC8 FF0E[D603]              	dec	word [chrptr]		; back up over linefeed
 32887 00002DCC EBED                    	jmp	short done_line
 32888                                  
 32889                                  okay:
 32890 00002DCE A1[0337]                	mov	ax,[switches]
 32891 00002DD1 83E003                  	and	ax,0003h	    ; get flag bits for changeline and non-rem
 32892 00002DD4 A3[DC35]                	mov	[deviceparameters+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES],ax
 32893 00002DD7 C706[0036]0000          	mov	word [deviceparameters+A_DEVICEPARAMETERS.DP_TRACKTABLEENTRIES],0
 32894                                  	;clc			    ; everything is fine
 32895                                  	; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 32896                                  	; 12/12/2022
 32897                                  	; cf=0
 32898                                  	;clc
 32899                                  	;call	setdeviceparameters
 32900                                  	; 04/01/2023
 32901                                  	;jmp	short setdeviceparameters
 32902                                  
 32903                                  %endif
 32904                                  
 32905                                  ;	M047 -- Begin modifications (too numerous to mark specifically)
 32906                                  
 32907                                  ;----------------------------------------------------------------------------
 32908                                  ;
 32909                                  ; procedure : setdeviceparameters
 32910                                  ;
 32911                                  ; setdeviceparameters sets up the recommended bpb in each bds in the
 32912                                  ; system based on the form factor. it is assumed that the bpbs for the
 32913                                  ; various form factors are present in the bpbtable. for hard files,
 32914                                  ; the recommended bpb is the same as the bpb on the drive.
 32915                                  ; no attempt is made to preserve registers since we are going to jump to
 32916                                  ; sysinit straight after this routine.
 32917                                  ;
 32918                                  ;	if we return carry, the DRIVPARM will be aborted, but presently
 32919                                  ;	  we always return no carry
 32920                                  ;
 32921                                  ;	note:  there is a routine by the same name in msdioctl.asm
 32922                                  ;
 32923                                  ;----------------------------------------------------------------------------
 32924                                  
 32925                                  ; 15/04/2019 - Retro DOS v4.0
 32926                                  
 32927                                  	; 02/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 32928                                  setdeviceparameters:
 32929                                  	; 04/01/2023
 32930                                  	; ds = cs
 32931                                  	
 32932 00002DDD 06                      	push	es
 32933                                  
 32934 00002DDE 0E                      	push	cs
 32935 00002DDF 07                      	pop	es
 32936                                  
 32937 00002DE0 31DB                    	xor	bx,bx
 32938 00002DE2 8A1E[DB35]              	mov	bl,[deviceparameters+A_DEVICEPARAMETERS.DP_DEVICETYPE]
 32939 00002DE6 80FB00                  	cmp	bl,DEV_5INCH ; 0
 32940 00002DE9 7506                    	jne	short got_80
 32941                                  
 32942 00002DEB C706[DE35]2800          	mov	word [deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS],40
 32943                                  							; 48 tpi=40 cyl
 32944                                  got_80:
 32945 00002DF1 D1E3                    	shl	bx,1			; get index into bpb table
 32946 00002DF3 8BB7[8237]              	mov	si,[bpbtable+bx]	; get address of bpb
 32947                                  
 32948                                  	;mov	di,deviceparameters+7	
 32949                                  	; 02/11/2022
 32950 00002DF7 BF[E135]                	mov	di,deviceparameters+A_DEVICEPARAMETERS.DP_BPB ; es:di -> bpb
 32951 00002DFA B91F00                  	mov	cx,A_BPB.size ; 31
 32952 00002DFD FC                      	cld
 32953                                  	;repe	movsb
 32954                                  	; 02/11/2022
 32955 00002DFE F3A4                    	rep	movsb
 32956                                  
 32957 00002E00 07                      	pop	es
 32958                                  
 32959                                  	; 12/12/2022
 32960 00002E01 F606[0337]20            	test	byte [switches],flagseclim ; 20h
 32961                                  	;test	word [switches],flagseclim ; 20h
 32962 00002E06 7406                    	jz	short see_heads
 32963                                  
 32964 00002E08 A1[0037]                	mov	ax,[slim]
 32965                                  	;mov	[deviceparameters+20],ax
 32966 00002E0B A3[EE35]                	mov	[deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_SECTORSPERTRACK],ax
 32967                                  
 32968                                  see_heads:
 32969                                  	; 12/12/2022
 32970 00002E0E F606[0337]40            	test	byte [switches],flagheads ; 40h
 32971                                  	;test	word [switches],flagheads ; 40h
 32972 00002E13 7406                    	jz	short heads_not_altered
 32973                                  
 32974 00002E15 A1[FE36]                	mov	ax,[hlim]
 32975                                  	;mov	[deviceparameters+22],ax	
 32976 00002E18 A3[F035]                	mov	[deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_HEADS],ax
 32977                                  
 32978                                  heads_not_altered:
 32979                                  
 32980                                  ; set up correct media descriptor byte and sectors/cluster
 32981                                  ;   sectors/cluster is always 2 except for any one sided disk or 1.44M
 32982                                  
 32983                                  	;mov	byte [deviceparameters+9],2
 32984                                  	; 02/11/2022
 32985                                  	;mov	byte [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_SECTORSPERCLUSTER],2
 32986                                  	; 04/01/2023
 32987 00002E1B B80200                  	mov	ax,2	
 32988 00002E1E A2[E335]                	mov	[deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_SECTORSPERCLUSTER],al ; 2
 32989                                  
 32990 00002E21 B3F0                    	mov	bl,0F0h			; get default mediabyte
 32991                                  
 32992                                  ;	preload the mediadescriptor from the bpb into bh for convenient access
 32993                                  
 32994                                  	;mov	bh,[deviceparameters+17]
 32995                                  	; 02/11/2022
 32996 00002E23 8A3E[EB35]              	mov	bh,[deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_MEDIADESCRIPTOR]
 32997                                  
 32998                                  	; 04/01/2023
 32999                                  	; ax = 2
 33000 00002E27 3906[F035]              	cmp	[deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_HEADS],ax ; >2 heads?
 33001                                  	;cmp	word [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_HEADS],2 ; >2 heads?
 33002 00002E2B 773C                    	ja	short got_correct_mediad ; just use default if heads>2
 33003                                  
 33004 00002E2D 7524                    	jne	short only_one_head	; one head, do one head stuff
 33005                                  
 33006                                  ;	two head drives will use the mediadescriptor from the bpb
 33007                                  
 33008 00002E2F 88FB                    	mov	bl,bh			; get mediadescriptor from bpb
 33009                                  
 33010                                  ;	two sided drives have two special cases to look for. One is
 33011                                  ;	   a 320K diskette (40 tracks, 8 secs per track). It uses
 33012                                  ;	   a mediaid of 0fch. The other is 1.44M, which uses only
 33013                                  ;	   one sector/cluster.
 33014                                  
 33015                                  ;	any drive with 18secs/trk, 2 heads, 80 tracks, will be assumed
 33016                                  ;	   to be a 1.44M and use only 1 sector per cluster. Any other
 33017                                  ;	   type of 2 headed drive is all set.
 33018                                  
 33019 00002E31 833E[EE35]12            	cmp	word [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_SECTORSPERTRACK],18
 33020 00002E36 7509                    	jne	short not_144m
 33021 00002E38 833E[DE35]50            	cmp	word [deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS],80
 33022 00002E3D 7502                    	jne	short not_144m
 33023                                  
 33024                                  ;	We've got cyl=80, heads=2, secpertrack=18. Set cluster size to 1.
 33025                                  
 33026 00002E3F EB24                    	jmp	short got_one_secperclus_drive
 33027                                  
 33028                                  ;	check for 320K
 33029                                  
 33030                                  not_144m:
 33031 00002E41 833E[DE35]28            	cmp	word [deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS],40
 33032 00002E46 7521                    	jne	short got_correct_mediad
 33033 00002E48 833E[EE35]08            	cmp	word [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_SECTORSPERTRACK],8
 33034 00002E4D 751A                    	jne	short got_correct_mediad
 33035                                  
 33036 00002E4F B3FC                    	mov	bl,0FCh
 33037 00002E51 EB16                    	jmp	short got_correct_mediad
 33038                                  
 33039                                  only_one_head:
 33040                                  
 33041                                  ;	if we don't have a 360K drive, then just go use 0f0h as media descr.
 33042                                  
 33043 00002E53 803E[DB35]00            	cmp	byte [deviceparameters+A_DEVICEPARAMETERS.DP_DEVICETYPE],DEV_5INCH ; 0
 33044 00002E58 740B                    	je	short got_one_secperclus_drive
 33045                                  
 33046                                  ;	single sided 360K drive uses either 0fch or 0feh, depending on
 33047                                  ;	  whether sectorspertrack is 8 or 9. For our purposes, anything
 33048                                  ;	  besides 8 will be considered 0fch
 33049                                  
 33050 00002E5A B3FC                    	mov	bl,0FCh			; single sided 9 sector media id
 33051 00002E5C 833E[EE35]08            	cmp	word [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_SECTORSPERTRACK],8
 33052                                  	; 12/12/2022
 33053 00002E61 7502                    	jne	short got_one_secperclus_drive ; okay if anything besides 8
 33054                                  
 33055 00002E63 B3FE                    	mov	bl,0FEh			; 160K mediaid
 33056                                  
 33057                                  ;	we've either got a one sided drive, or a 1.44M drive
 33058                                  ;	  either case we'll use 1 sector per cluster instead of 2
 33059                                  
 33060                                  got_one_secperclus_drive:
 33061                                  	; 04/01/2023
 33062                                  	; ax = 2
 33063 00002E65 48                      	dec	ax  ; ax = 1
 33064 00002E66 A2[E335]                	mov	[deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_SECTORSPERCLUSTER],al ; 1
 33065                                  	;mov	byte [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_SECTORSPERCLUSTER],1
 33066                                  
 33067                                  got_correct_mediad:
 33068 00002E69 881E[EB35]              	mov	[deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_MEDIADESCRIPTOR],bl
 33069                                  
 33070                                  ;	 Calculate the correct number of Total Sectors on medium
 33071                                  
 33072 00002E6D A1[DE35]                	mov	ax,[deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS]
 33073 00002E70 F726[F035]              	mul	word [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_HEADS]
 33074 00002E74 F726[EE35]              	mul	word [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_SECTORSPERTRACK]
 33075 00002E78 A3[E935]                	mov	word [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_TOTALSECTORS],ax
 33076 00002E7B F8                      	clc				; we currently return no errors
 33077                                  
 33078 00002E7C C3                      	retn
 33079                                  
 33080                                  ;	M047 -- end rewritten routine
 33081                                  
 33082                                  ;----------------------------------------------------------------------------
 33083                                  ;
 33084                                  ; procedure : organize
 33085                                  ;
 33086                                  ;----------------------------------------------------------------------------
 33087                                  
 33088                                  	; 02/11/2022 - Retrodos v4.0 (Modified MSDOS 5.0 IO.SYS)
 33089                                  	; (SYSINIT:3234h)
 33090                                  
 33091                                  organize:
 33092                                  	; 04/01/2023
 33093                                  	; ds = cs
 33094 00002E7D 8B0E[D203]              	mov	cx,[count]
 33095                                  	;mov	cx,[cs:count]
 33096 00002E81 E326                    	jcxz	nochar1
 33097                                  
 33098                                  ;ifndef	MULTI_CONFIG
 33099                                  ;
 33100                                  ;;   In MULTI_CONFIG, we map to upper case on a line-by-line basis,
 33101                                  ;;   because we the case of values in SET commands preserved
 33102                                  ;
 33103                                  ;	call	mapcase
 33104                                  ;endif
 33105                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 33106 00002E83 E81B02                  	call	mapcase
 33107                                  
 33108 00002E86 31F6                    	xor	si,si
 33109 00002E88 89F7                    	mov	di,si
 33110 00002E8A 31C0                    	xor	ax,ax
 33111                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)	
 33112                                  	;;mov	byte [cs:com_level],0
 33113                                  	; 12/12/2022
 33114                                  	;mov	[cs:com_level],al ; 0
 33115                                  	; 04/01/2023
 33116                                  	; ds = cs
 33117 00002E8C A2[CC03]                	mov	[com_level],al ; 0
 33118                                  org1:
 33119 00002E8F E8B101                  	call	skip_comment
 33120 00002E92 740D                    	jz	short end_commd_line	; found a comment string and skipped.
 33121 00002E94 E89601                  	call	get2			; not a comment string. then get a char.
 33122 00002E97 3C0A                    	cmp	al,lf ; 0Ah
 33123 00002E99 7406                    	je	short end_commd_line	; starts with a blank line.
 33124 00002E9B 3C20                    	cmp	al,' ' ; 20h
 33125 00002E9D 76F0                    	jbe	short org1		; skip leading control characters
 33126 00002E9F EB0A                    	jmp	short findit
 33127                                  
 33128                                  end_commd_line:
 33129 00002EA1 AA                      	stosb				; store line feed char in buffer for the linecount.
 33130                                  	;mov	byte [cs:com_level],0	; reset the command level.
 33131                                  	; 04/01/2023
 33132                                  	; ds = cs
 33133 00002EA2 C606[CC03]00            	mov	byte [com_level],0
 33134 00002EA7 EBE6                    	jmp	short org1
 33135                                  
 33136                                  nochar1:
 33137 00002EA9 F9                      	stc
 33138 00002EAA C3                      	retn
 33139                                  
 33140                                  findit:
 33141 00002EAB 51                      	push	cx
 33142 00002EAC 56                      	push	si
 33143 00002EAD 57                      	push	di
 33144 00002EAE 89F5                    	mov	bp,si
 33145 00002EB0 4D                      	dec	bp
 33146 00002EB1 BE[4935]                        mov     si,comtab		; prepare to search command table
 33147 00002EB4 B500                    	mov	ch,0
 33148                                  findcom:
 33149 00002EB6 89EF                    	mov	di,bp
 33150 00002EB8 8A0C                    	mov	cl,[si]
 33151 00002EBA 46                      	inc	si
 33152 00002EBB E324                    	jcxz	nocom
 33153                                  
 33154                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 33155                                  
 33156                                  ;ifdef	MULTI_CONFIG
 33157                                  ;
 33158                                  ;;   Simplify future parsing by collapsing ";" onto "REM", and at the same
 33159                                  ;;   time skip the upcoming delimiter test (since ";" need not be followed by
 33160                                  ;;   anything in particular)
 33161                                  ;
 33162                                  ;       cmp     byte [es:di],CONFIG_SEMICOLON  ; ';'
 33163                                  ;       je	short semicolon
 33164                                  ;loopcom:
 33165                                  ;       mov     al,[es:di]
 33166                                  ;       inc     di
 33167                                  ;       and     al,~20h ; 0DFh		; force upper case
 33168                                  ;       inc     si                      ; compare to byte @es:di
 33169                                  ;       cmp     al,[si-1]
 33170                                  ;       loope   loopcom
 33171                                  ;;else
 33172                                  ;;	repe	cmpsb
 33173                                  ;endif
 33174                                  	; 02/11/2022
 33175 00002EBD F3A6                    	repe	cmpsb
 33176                                  
 33177 00002EBF 9F                      	lahf
 33178 00002EC0 01CE                            add     si,cx                   ; bump to next position without affecting flags
 33179 00002EC2 9E                      	sahf
 33180 00002EC3 AC                              lodsb                           ; get indicator letter
 33181 00002EC4 75F0                    	jnz	short findcom
 33182 00002EC6 26803D0D                        cmp     byte [es:di],cr		; the next char might be cr,lf
 33183 00002ECA 7410                    	je	short gotcom0 		; such as in "rem",cr,lf case.
 33184 00002ECC 26803D0A                	cmp	byte [es:di],lf
 33185 00002ED0 740A                    	je	short gotcom0
 33186                                  
 33187                                  ; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 33188                                  ;
 33189                                  ;;ifdef	MULTI_CONFIG
 33190                                  ;
 33191                                  ;;   Skip the delimiter test for the BEGIN identifier (it doesn't have one).
 33192                                  ;
 33193                                  ;       cmp     al,CONFIG_BEGIN  ; '['
 33194                                  ;       je	short gotcom0
 33195                                  ;;endif
 33196                                  ;	push	ax
 33197                                  ;       mov     al,[es:di]		; now the next char. should be a delim.
 33198                                  ;
 33199                                  ;;ifdef	MULTI_CONFIG
 33200                                  ;
 33201                                  ;;   If keyword is *immediately* followed by a question mark (?), then
 33202                                  ;;   set the high bit of the ASCII command code (CONFIG_OPTION_QUERY) that is
 33203                                  ;;   stored in the CONFIG.SYS memory image.
 33204                                  ;
 33205                                  ;       cmp     al,'?'                  ; explicit interactive command?
 33206                                  ;       jne	short no_query		; no
 33207                                  ;       pop     ax                      ; yes, so retrieve the original code
 33208                                  ;       or      al,CONFIG_OPTION_QUERY  ; and set the QUERY bit
 33209                                  ;       jmp     short gotcom0           ;
 33210                                  ;semicolon:
 33211                                  ;       mov     al,CONFIG_REM
 33212                                  ;       jmp     short gotcom0
 33213                                  ;no_query:
 33214                                  ;;endif  ;MULTI_CONFIG
 33215                                  
 33216                                  	; 02/11/2022
 33217 00002ED2 50                      	push	ax
 33218 00002ED3 268A05                  	mov	al,[es:di]		; now the next char. should be a delim.
 33219                                  
 33220 00002ED6 E8A001                  	call	delim
 33221                                  no_delim:
 33222 00002ED9 58                      	pop	ax
 33223 00002EDA 75DA                    	jnz	short findcom
 33224                                  gotcom0:
 33225 00002EDC 5F                      	pop	di
 33226 00002EDD 5E                      	pop	si
 33227 00002EDE 59                      	pop	cx
 33228 00002EDF EB0F                    	jmp	short gotcom
 33229                                  nocom:
 33230 00002EE1 5F                      	pop	di
 33231 00002EE2 5E                      	pop	si
 33232 00002EE3 59                      	pop	cx
 33233 00002EE4 B05A                            mov     al,CONFIG_UNKNOWN  ; 'Z'
 33234 00002EE6 AA                      	stosb				; save indicator char.
 33235                                  _skipline:
 33236 00002EE7 E84301                  	call	get2
 33237 00002EEA 3C0A                    	cmp	al,lf ; 0Ah		; skip this bad command line
 33238 00002EEC 75F9                            jne     short _skipline
 33239 00002EEE EBB1                    	jmp	short end_commd_line	; handle next command line
 33240                                  gotcom:
 33241 00002EF0 AA                              stosb                           ; save indicator char in buffer
 33242                                  
 33243                                  ; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 33244                                  ;;ifdef	MULTI_CONFIG
 33245                                  ;
 33246                                  ;;   Don't pollute "cmd_indicator" with the CONFIG_OPTION_QUERY bit though;
 33247                                  ;;   it screws up the direct comparisons below.
 33248                                  ;
 33249                                  ;       and     al,~CONFIG_OPTION_QUERY ; 7Fh
 33250                                  ;;endif
 33251                                  ;	mov	[cs:cmd_indicator],al	; save it for the future use.
 33252                                  ;
 33253                                  ;;ifdef	MULTI_CONFIG
 33254                                  ;
 33255                                  ;;   There is no whitespace/delimiter between the "begin block" character
 33256                                  ;;   ([) and the name of block (eg, [menu]), therefore skip this delimiter
 33257                                  ;;   skipping code
 33258                                  ;
 33259                                  ;       cmp     al,CONFIG_BEGIN
 33260                                  ;       je	short org31
 33261                                  ;       cmp     al,CONFIG_SUBMENU ; 'O'
 33262                                  ;       je      short no_mapcase
 33263                                  ;       cmp     al,CONFIG_MENUITEM ; 'E'
 33264                                  ;       je      short no_mapcase
 33265                                  ;       cmp     al,CONFIG_MENUDEFAULT ; 'A'
 33266                                  ;       je      short no_mapcase
 33267                                  ;       cmp     al,CONFIG_INCLUDE ; 'J'
 33268                                  ;       je      short no_mapcase
 33269                                  ;       call    mapcase                 ; map case of rest of line to UPPER
 33270                                  ;no_mapcase:
 33271                                  ;;endif
 33272                                  
 33273                                  	; 02/11/2022
 33274                                  	;mov	[cs:cmd_indicator],al	; save it for the future use.
 33275                                  	; 04/01/2023
 33276                                  	; ds = cs
 33277 00002EF1 A2[D003]                	mov	[cmd_indicator],al
 33278                                  org2:	
 33279 00002EF4 E83601                  	call    get2                    ; skip the command name until delimiter
 33280 00002EF7 3C0A                            cmp     al,lf
 33281 00002EF9 740B                    	je	short org21
 33282 00002EFB 3C0D                    	cmp	al,cr
 33283 00002EFD 7407                    	je	short org21
 33284                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 33285                                  	;cmp	al, '/'			; T-RICHJ: Added to allow DEVHIGH/L:...
 33286                                  	;je	short org21		; T-RICHJ: to be parsed properly.
 33287                                  
 33288 00002EFF E87701                  	call	delim
 33289 00002F02 75F0                            jnz	short org2
 33290 00002F04 EB02                    	jmp	short org3
 33291                                  org21:					;if cr or lf then
 33292 00002F06 4E                      	dec	si			; undo si, cx register
 33293 00002F07 41                      	inc	cx			;  and continue
 33294                                  org3:	
 33295                                  	;cmp	byte [cs:cmd_indicator],CONFIG_COMMENT ; 'Y'
 33296                                  	;je	short get_cmt_token
 33297                                  	;; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 33298                                          ;;cmp	byte [cs:cmd_indicator],CONFIG_DEVICE ; 'D'
 33299                                  	;;je	short org_file
 33300                                          ;cmp     byte [cs:cmd_indicator],CONFIG_INSTALL ; 'I'
 33301                                  	;je	short org_file
 33302                                          ;;cmp	byte [cs:cmd_indicator],CONFIG_INSTALLHIGH ; 'W'
 33303                                          ;;je	short org_file
 33304                                  	;; 02/11/2022
 33305                                  	;cmp     byte [cs:cmd_indicator],CONFIG_DEVICE ; 'D'
 33306                                  	;je	short org_file
 33307                                          ;cmp     byte [cs:cmd_indicator],CONFIG_SHELL ; 'S'
 33308                                  	;je	short org_file
 33309                                          ;cmp	byte [cs:cmd_indicator],CONFIG_SWITCHES ; '1'
 33310                                  	;je	short org_switch
 33311                                  
 33312                                  	; 04/01/2023
 33313                                  	; ds = cs
 33314                                  
 33315 00002F08 803E[D003]59            	cmp	byte [cmd_indicator],CONFIG_COMMENT ; 'Y'
 33316 00002F0D 7456                    	je	short get_cmt_token
 33317                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 33318                                          ;cmp	byte [cmd_indicator],CONFIG_DEVICE ; 'D'
 33319                                  	;je	short org_file
 33320 00002F0F 803E[D003]49                    cmp     byte [cmd_indicator],CONFIG_INSTALL ; 'I'
 33321 00002F14 7429                    	je	short org_file
 33322                                          ;cmp	byte [cmd_indicator],CONFIG_INSTALLHIGH ; 'W'
 33323                                          ;je	short org_file
 33324                                  	; 02/11/2022
 33325 00002F16 803E[D003]44            	cmp     byte [cmd_indicator],CONFIG_DEVICE ; 'D'
 33326 00002F1B 7422                    	je	short org_file
 33327 00002F1D 803E[D003]53                    cmp     byte [cmd_indicator],CONFIG_SHELL ; 'S'
 33328 00002F22 741B                    	je	short org_file
 33329 00002F24 803E[D003]31                    cmp	byte [cmd_indicator],CONFIG_SWITCHES ; '1'
 33330 00002F29 7403                    	je	short org_switch
 33331                                  	
 33332                                  org31:
 33333 00002F2B E99500                  	jmp	org4
 33334                                  
 33335                                  org_switch:
 33336 00002F2E E81201                  	call	skip_comment
 33337 00002F31 7472                    	jz	short end_commd_line_brdg
 33338                                  
 33339 00002F33 E8F700                  	call	get2
 33340 00002F36 E84801                  	call	org_delim
 33341 00002F39 74F3                    	jz	short org_switch
 33342                                  
 33343 00002F3B AA                      	stosb
 33344 00002F3C E99300                  	jmp	org5
 33345                                  
 33346                                  org_file:			; get the filename and put 0 at end
 33347 00002F3F E80101                  	call	skip_comment
 33348 00002F42 7464                    	jz	short org_put_zero
 33349                                  
 33350 00002F44 E8E600                  	call	get2		; not a comment
 33351 00002F47 E82F01                  	call	delim
 33352 00002F4A 74F3                    	jz	short org_file	; skip the possible delimiters
 33353                                  
 33354 00002F4C AA                      	stosb			; copy the first non delim char found in buffer
 33355                                  
 33356                                  org_copy_file:
 33357 00002F4D E8F300                  	call	skip_comment	; comment char in the filename?
 33358 00002F50 7456                    	jz	short org_put_zero ; then stop copying filename at that point
 33359                                  
 33360 00002F52 E8D800                  	call	get2
 33361 00002F55 3C2F                    	cmp	al,'/'		; a switch char? (device=filename/xxx)
 33362 00002F57 7457                    	je	short end_file_slash ; this will be the special case.
 33363                                  
 33364 00002F59 AA                      	stosb			; save the char. in buffer
 33365 00002F5A E81C01                  	call	delim
 33366 00002F5D 7459                    	jz	short end_copy_file
 33367                                  
 33368 00002F5F 3C20                    	cmp	al, ' '
 33369 00002F61 77EA                    	ja	short org_copy_file ; keep copying
 33370 00002F63 EB53                    	jmp	short end_copy_file ; otherwise, assume end of the filename.
 33371                                  
 33372                                  get_cmt_token:			; get the token. just max. 2 char.
 33373 00002F65 E8C500                  	call	get2
 33374 00002F68 3C20                    	cmp	al,' '		; skip white spaces or "=" char.
 33375 00002F6A 74F9                    	je	short get_cmt_token ; (we are allowing the other special
 33376 00002F6C 3C09                    	cmp	al,tab ; 9 	;  characters can used for comment id.
 33377 00002F6E 74F5                    	je	short get_cmt_token ;  character.)
 33378 00002F70 3C3D                    	cmp	al,'='		; = is special in this case.
 33379 00002F72 74F1                    	je	short get_cmt_token
 33380 00002F74 3C0D                    	cmp	al,cr
 33381 00002F76 7426                    	je	short get_cmt_end ; cannot accept the carriage return
 33382 00002F78 3C0A                    	cmp	al,lf
 33383 00002F7A 7422                    	je	short get_cmt_end
 33384                                  
 33385                                  	; 04/01/2023
 33386                                  	; ds = cs
 33387                                  	;mov	[cs:cmmt1],al	; store it
 33388                                  	;mov	byte [cs:cmmt],1 ; 1 char. so far.
 33389 00002F7C A2[CE03]                	mov	[cmmt1],al	; store it
 33390 00002F7F C606[CD03]01            	mov	byte [cmmt],1 ; 1 char. so far.
 33391 00002F84 E8A600                  	call	get2
 33392 00002F87 3C20                    	cmp	al,' ' ; 20h
 33393 00002F89 7413                    	je	short get_cmt_end
 33394 00002F8B 3C09                    	cmp	al,tab ; 9
 33395 00002F8D 740F                    	je	short get_cmt_end
 33396 00002F8F 3C0D                    	cmp	al,cr  ; 0Dh
 33397 00002F91 740B                    	je	short get_cmt_end
 33398 00002F93 3C0A                    	cmp	al,lf  ; 0Ah
 33399 00002F95 740E                    	je	short end_commd_line_brdg
 33400                                  
 33401                                  	;mov	[cs:cmmt2],al
 33402                                  	;inc	byte [cs:cmmt]
 33403                                  	; 04/01/2023
 33404 00002F97 A2[CF03]                	mov	[cmmt2],al
 33405 00002F9A FE06[CD03]              	inc	byte [cmmt]
 33406                                  
 33407                                  get_cmt_end:
 33408 00002F9E E88C00                  	call	get2
 33409 00002FA1 3C0A                    	cmp	al,lf
 33410 00002FA3 75F9                    	jne	short get_cmt_end	; skip it.
 33411                                  end_commd_line_brdg: 
 33412 00002FA5 E9F9FE                  	jmp	end_commd_line		; else jmp to end_commd_line
 33413                                  
 33414                                  org_put_zero:				; make the filename in front of
 33415 00002FA8 26C60500                	mov	byte [es:di],0		;  the comment string to be an asciiz.
 33416 00002FAC 47                      	inc	di
 33417 00002FAD E9F1FE                  	jmp	end_commd_line		;  (maybe null if device=/*)
 33418                                  
 33419                                  end_file_slash: 			; al = "/" option char.
 33420 00002FB0 26C60500                	mov	byte [es:di],0		; make a filename an asciiz
 33421 00002FB4 47                      	inc	di			; and
 33422 00002FB5 AA                      	stosb				; store "/" after that.
 33423 00002FB6 EB1A                    	jmp	short org5		; continue with the rest of the line
 33424                                  
 33425                                  end_copy_file:
 33426 00002FB8 26C645FF00              	mov	byte [es:di-1],0	; make it an asciiz and handle the next char.
 33427 00002FBD 3C0A                    	cmp	al,lf
 33428 00002FBF 74E4                    	je	short end_commd_line_brdg
 33429 00002FC1 EB0F                    	jmp	short org5
 33430                                  
 33431                                  org4:					; org4 skips all delimiters after the command name except for '/'
 33432 00002FC3 E87D00                  	call	skip_comment
 33433 00002FC6 74DD                    	jz	short end_commd_line_brdg
 33434                                  
 33435 00002FC8 E86200                  	call	get2
 33436 00002FCB E8B300                  	call	org_delim		; skip delimiters except '/' (mrw 4/88)
 33437 00002FCE 74F3                    	jz	short org4
 33438 00002FD0 EB08                    	jmp	short org51
 33439                                  
 33440                                  org5:					; rest of the line
 33441 00002FD2 E86E00                  	call	skip_comment		; comment?
 33442 00002FD5 74CE                    	jz	short end_commd_line_brdg
 33443 00002FD7 E85300                  	call	get2			; not a comment.
 33444                                  
 33445                                  org51:
 33446 00002FDA AA                      	stosb				; copy the character
 33447 00002FDB 3C22                    	cmp	al,'"' 	; 22h		; a quote ?
 33448 00002FDD 743A                    	je	short at_quote
 33449 00002FDF 3C20                    	cmp	al,' '  ; 20h
 33450 00002FE1 77EF                    	ja	short org5
 33451                                  					; M051 - Start
 33452                                  	; 04/01/2023
 33453                                  	; ds = cs
 33454 00002FE3 803E[D003]55                    cmp	byte [cmd_indicator],CONFIG_DEVICEHIGH
 33455                                  	;cmp	byte [cs:cmd_indicator],CONFIG_DEVICEHIGH ; Q: is this devicehigh
 33456 00002FE8 7514                    	jne	short not_dh		; N: 
 33457 00002FEA 3C0A                    	cmp	al,lf			; Q: is this line feed
 33458 00002FEC 7416                    	je	short org_dhlf		; Y: stuff a blank before the lf
 33459 00002FEE 3C0D                    	cmp	al,cr			; Q: is this a cr
 33460 00002FF0 75E0                    	jne	short org5		; N: 
 33461 00002FF2 26C645FF20              	mov	byte [es:di-1],' '	; overwrite cr with blank
 33462 00002FF7 AA                      	stosb				; put cr after blank
 33463 00002FF8 FE06[BF2C]              	inc	byte [insert_blank]
 33464                                  	;inc	byte [cs:insert_blank]	; indicate that blank has been 
 33465                                  					; inserted
 33466 00002FFC EBD4                    	jmp	short org5
 33467                                  not_dh:					; M051 - End
 33468                                  
 33469 00002FFE 3C0A                    	cmp	al,lf			; line feed?
 33470 00003000 740F                    	je	short org1_brdg		; handles the next command line.
 33471 00003002 EBCE                    	jmp	short org5		; handles next char in this line.
 33472                                  
 33473                                  org_dhlf:				; M051 - Start
 33474                                  	; 04/01/2023
 33475                                  	; ds = cs
 33476 00003004 803E[BF2C]01            	cmp	byte [insert_blank],1
 33477                                  	;cmp	byte [cs:insert_blank],1 ; Q:has a blank already been inserted
 33478 00003009 7406                    	je	short org1_brdg		; Y:
 33479 0000300B 26C645FF20              	mov	byte [es:di-1],' '	; overwrite lf with blank
 33480 00003010 AA                      	stosb				; put lf after blank
 33481                                  					; M051 - End
 33482                                  org1_brdg:
 33483 00003011 C606[BF2C]00            	mov	byte [insert_blank],0 
 33484                                  	;mov	byte [cs:insert_blank],0 ; M051: clear blank indicator for 
 33485                                  					; M051: devicehigh
 33486 00003016 E976FE                  	jmp	org1
 33487                                  
 33488                                  at_quote:
 33489 00003019 803E[CC03]00            	cmp	byte [com_level],0
 33490                                  	;cmp	byte [cs:com_level],0
 33491 0000301E 7407                    	je	short up_level
 33492                                  	;mov	byte [cs:com_level],0	; reset it.
 33493 00003020 C606[CC03]00            	mov	byte [com_level],0
 33494 00003025 EBAB                    	jmp	short org5
 33495                                  
 33496                                  up_level:
 33497                                  	;inc	byte [cs:com_level]	; set it.
 33498 00003027 FE06[CC03]              	inc	byte [com_level]
 33499 0000302B EBA5                    	jmp	short org5
 33500                                  
 33501                                  ;----------------------------------------------------------------------------
 33502                                  ;
 33503                                  ; procedure : get2
 33504                                  ;
 33505                                  ;----------------------------------------------------------------------------
 33506                                  
 33507                                  	; 02/11/2022 - Retrodos v4.0 (Modified MSDOS 5.0 IO.SYS)
 33508                                  	; (SYSINIT:33FAh)
 33509                                  	; 04/01/2023
 33510                                  get2:
 33511 0000302D E304                    	jcxz	noget
 33512                                  	;
 33513                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 33514                                  	;;lods	byte ptr es:[si]
 33515                                  	; 12/12/2022
 33516 0000302F 26                      	es	
 33517 00003030 AC                      	lodsb
 33518                                  	;mov	al, [es:si]
 33519                                  	;inc	si
 33520                                  	;
 33521 00003031 49                      	dec	cx
 33522 00003032 C3                      	retn
 33523                                  noget:
 33524 00003033 59                      	pop	cx
 33525                                  	; 04/01/2023
 33526                                  	; ds = cs
 33527                                  	;mov	[cs:count],di ; 13/05/2019
 33528                                  	;mov	[cs:org_count],di
 33529 00003034 893E[D203]              	mov	[count],di
 33530 00003038 893E[D403]              	mov	[org_count],di
 33531 0000303C 31F6                    	xor	si,si
 33532                                  	;mov	[cs:chrptr],si
 33533 0000303E 8936[D603]              	mov	[chrptr],si
 33534                                  
 33535                                  ; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 33536                                  ;;ifndef MULTI_CONFIG
 33537                                  ;;	retn
 33538                                  ;;else
 33539                                  ;
 33540                                  ;;   This was the rather kludgy way out of procedure "organize", but instead
 33541                                  ;;   of returning to doconf, we now want to check config.sys BEGIN/END blocks
 33542                                  ;;   and the new boot menu stuff...
 33543                                  ;
 33544                                  ;	mov     cx,di
 33545                                  ;	jmp     menu_check
 33546                                  ;;endif
 33547                                  
 33548                                  	; 02/11/2022
 33549 00003042 C3                      	retn
 33550                                  
 33551                                  ;----------------------------------------------------------------------------
 33552                                  ;
 33553                                  ; procedure : skip_comment
 33554                                  ;
 33555                                  ;skip the commented string until lf, if current es:si-> a comment string.
 33556                                  ;in) es:si-> string
 33557                                  ;	 cx -> length.
 33558                                  ;out) zero flag not set if not found a comment string.
 33559                                  ;	  zero flag set if found a comment string and skipped it. al will contain
 33560                                  ;	  the line feed character at this moment when return.
 33561                                  ;	  ax register destroyed.
 33562                                  ;	  if found, si, cx register adjusted accordingly.
 33563                                  ;
 33564                                  ;----------------------------------------------------------------------------
 33565                                  
 33566                                  	; 04/01/2023 - Retro DOS v4.0
 33567                                  
 33568                                  skip_comment:
 33569 00003043 E3EE                    	jcxz	noget		; get out of the organize routine.
 33570                                  
 33571                                  	; 04/01/2023
 33572                                  	; ds = cs	
 33573                                  
 33574 00003045 803E[CC03]00            	cmp	byte [com_level],0
 33575                                  	;cmp	byte [cs:com_level],0 ; only check it if parameter level is 0.
 33576 0000304A 752C                    	jne	short no_commt	 ; (not inside quotations)
 33577                                  
 33578 0000304C 803E[CD03]01            	cmp	byte [cmmt],1
 33579                                  	;cmp	byte [cs:cmmt],1
 33580 00003051 7225                    	jb	short no_commt
 33581                                  
 33582 00003053 268A04                  	mov	al,[es:si]
 33583                                  	
 33584 00003056 3806[CE03]              	cmp	[cmmt1],al
 33585                                  	;cmp	[cs:cmmt1],al
 33586 0000305A 751C                    	jne	short no_commt
 33587                                  
 33588 0000305C 803E[CD03]02            	cmp	byte [cmmt],2
 33589                                  	;cmp	byte [cs:cmmt],2
 33590 00003061 750A                    	jne	short skip_cmmt
 33591                                  
 33592 00003063 268A4401                	mov	al,[es:si+1]
 33593                                  	
 33594 00003067 3806[CF03]              	cmp	[cmmt2],al
 33595                                  	;cmp	[cs:cmmt2],al
 33596 0000306B 750B                    	jne	short no_commt
 33597                                  skip_cmmt:
 33598 0000306D E3C4                    	jcxz	noget		; get out of organize routine.
 33599 0000306F 268A04                  	mov	al,[es:si]
 33600 00003072 46                      	inc	si
 33601 00003073 49                      	dec	cx
 33602 00003074 3C0A                    	cmp	al,lf		; line feed?
 33603 00003076 75F5                    	jne	short skip_cmmt
 33604                                  no_commt:
 33605 00003078 C3                      	retn
 33606                                  
 33607                                  ; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 33608                                  %if 0
 33609                                  
 33610                                  ;ifdef	MULTI_CONFIG
 33611                                  
 33612                                  ;----------------------------------------------------------------------------
 33613                                  ;
 33614                                  ;   kbd_read: wait for keystroke
 33615                                  ;
 33616                                  ;   INPUT
 33617                                  ;       DS == CS == sysinitseg
 33618                                  ;
 33619                                  ;   OUTPUT
 33620                                  ;       Carry SET to clean boot, CLEAR otherwise
 33621                                  ;
 33622                                  ;   OTHER REGS USED
 33623                                  ;       All
 33624                                  ;
 33625                                  ;   HISTORY
 33626                                  ;       Created 16-Nov-1992 by JeffPar
 33627                                  ;
 33628                                  ;----------------------------------------------------------------------------
 33629                                  
 33630                                  kbd_read:
 33631                                          test    byte [bDisableUI],2
 33632                                          jnz     short kbd_nodelay
 33633                                  
 33634                                          push    ds              ; the bios timer tick count is incremented
 33635                                          sub     ax,ax           ; 18.2 times per second;
 33636                                          mov     ds,ax           ; watch the timer tick count for 37 transitions
 33637                                  	;mov	dx,[046Ch]	; get initial value
 33638                                  kbd_loop:
 33639                                          mov     ah,1            ;
 33640                                          int     16h             ; peek the keyboard
 33641                                          jnz	short kbd_loopdone ; something's there, get out
 33642                                          mov     ah,2            ; peek the shift states
 33643                                          int     16h             ;
 33644                                          test    al,03h          ; either right or left shift key bits set?
 33645                                          jnz	short kbd_loopdone ; yes
 33646                                          mov     ax,[046Ch]	;
 33647                                  	;sub	ax,dx           ; get difference
 33648                                  	; 15/04/2019 - Retro DOS v4.0
 33649                                  	sub	ax,[cs:_timer_lw_] ; MSDOS 6.21 IO.SYS - SYSINIT:42E5h        
 33650                                  
 33651                                  	cmp     al,37           ; reached limit?
 33652                                          jb	short kbd_loop	; not yet
 33653                                  kbd_loopdone:
 33654                                          pop     ds              ; delay complete!
 33655                                  kbd_nodelay:
 33656                                          sub     bx,bx           ; assume clean boot
 33657                                          mov     ah,2            ; peek the shift states
 33658                                          int     16h             ;
 33659                                          test    al,03h          ; either right or left shift key bits set?
 33660                                          jz      short kbd_notshift ; no
 33661                                          inc     bx              ; yes
 33662                                          inc     bx
 33663                                  	; MSDOS 6.21 IO.SYS - SYSINIT:4301h
 33664                                  	or	byte [bQueryOpt],4
 33665                                  kbd_notshift:                   ;
 33666                                          mov     ah,1            ; peek the keyboard
 33667                                          int     16h             ;
 33668                                          jz	short kbd_test	; no key present
 33669                                          or      al,al           ; is it a function key?
 33670                                          jnz	short kbd_test	; no
 33671                                  
 33672                                  	; MSDOS 6.21 IO.SYS - SYSINIT:430Bh
 33673                                          cmp     ah,62h          ; CTRL F5
 33674                                          je	short kbd_cfg_bypass
 33675                                  	
 33676                                          cmp     ah,3Fh          ; F5 function key?
 33677                                          jne	short kbd_notf5	; no
 33678                                  kbd_cfg_bypass:
 33679                                          mov     dx,_$CleanMsg
 33680                                          call    print
 33681                                  	; MSDOS 6.21 IO.SYS - SYSINIT:431Bh
 33682                                  	or	byte [bQueryOpt],4           ;
 33683                                          jmp     short kbd_eat   ; yes, clean boot selected
 33684                                  kbd_notf5:
 33685                                  	; MSDOS 6.21 IO.SYS - SYSINIT:4322h
 33686                                          cmp     ah,65h          ; CTRL F8
 33687                                          je	short kbd_cfg_confirm
 33688                                  
 33689                                          cmp     ah,42h          ; F8 function key?
 33690                                          jne	short kbd_exit	; no
 33691                                  kbd_cfg_confirm:
 33692                                          mov     dx,_$InterMsg
 33693                                          call    print           ;
 33694                                          mov     bl,1            ; yes, interactive-boot option enabled
 33695                                          mov     [bQueryOpt],bl  ; change default setting
 33696                                  kbd_eat:                        ;
 33697                                          mov     ah,0            ;
 33698                                          int     16h             ; eat the key we assumed was a signal
 33699                                          mov	byte [secElapsed],-1
 33700                                          or      bx,bx           ;
 33701                                          jz	short kbd_clean	;
 33702                                  kbd_test:                       ;
 33703                                          cmp     bl,2            ;
 33704                                          jb	short kbd_exit	;
 33705                                  kbd_clean:                      ;
 33706                                          call    disable_autoexec; yes, tell COMMAND to skip autoexec.bat
 33707                                          stc                     ; set carry to indicate abort
 33708                                          retn			;
 33709                                  kbd_exit:                       ;
 33710                                          clc                     ; clear carry to indicate success
 33711                                          retn			;
 33712                                  
 33713                                  ;----------------------------------------------------------------------------
 33714                                  ;
 33715                                  ;   set_numlock: set numlock LED
 33716                                  ;
 33717                                  ;   INPUT
 33718                                  ;       ES:SI -> numlock setting (ie, "ON" or "OFF")
 33719                                  ;
 33720                                  ;   OUTPUT
 33721                                  ;       None
 33722                                  ;
 33723                                  ;   OTHER REGS USED
 33724                                  ;       None
 33725                                  ;
 33726                                  ;   HISTORY
 33727                                  ;       Created 16-Nov-1992 by JeffPar
 33728                                  ;
 33729                                  ;----------------------------------------------------------------------------
 33730                                  
 33731                                  set_numlock:
 33732                                          push    ax
 33733                                          push    ds
 33734                                          sub     ax,ax
 33735                                          mov     ds,ax
 33736                                          mov     ax,[es:si]      ; get 1st 2 bytes of value (ON or OF)
 33737                                          cmp     ax,[cs:OnOff+2]	; should we turn it off?
 33738                                          jne	short not_off	; no
 33739                                          and     byte [0417h],~20h ; 0DFh
 33740                                          jmp     short set_done
 33741                                  not_off:
 33742                                          cmp     ax,[cs:OnOff]	; should we turn it on?
 33743                                          stc
 33744                                          jne	short set_done	; no
 33745                                          or      byte [0417h],20h
 33746                                  set_done:
 33747                                          pop     ds
 33748                                          pop     ax
 33749                                          retn
 33750                                  
 33751                                  ; 16/04/2019 - Retro DOS v4.0
 33752                                  
 33753                                  ;----------------------------------------------------------------------------
 33754                                  ;
 33755                                  ;   menu_check:  check for presence of menu (and other) configuration blocks
 33756                                  ;
 33757                                  ;   INPUT
 33758                                  ;       CX == "organized" config.sys memory image length
 33759                                  ;    ES:SI -> "organized" config.sys memory image
 33760                                  ;       DS == CS == sysinitseg
 33761                                  ;
 33762                                  ;   OUTPUT
 33763                                  ;       Same as above;  the idea is that menu_check simply transforms
 33764                                  ;       a block-structured config.sys image into a conventional image,
 33765                                  ;       based on the user's block selection and any other boot-time options
 33766                                  ;       the user may have employed...
 33767                                  ;
 33768                                  ;   OTHER REGS USED
 33769                                  ;       All
 33770                                  ;
 33771                                  ;   NOTES
 33772                                  ;       [count] and [org_count] are set to the new config.sys image length
 33773                                  ;
 33774                                  ;   HISTORY
 33775                                  ;       Created 16-Mar-1992 by JeffPar
 33776                                  ;
 33777                                  ;----------------------------------------------------------------------------
 33778                                  
 33779                                  menu_check:
 33780                                  
 33781                                  ;   Search for SWITCHES, determine if /N or /F are present;  if so, then
 33782                                  ;   disable clean/interactive boot options
 33783                                  
 33784                                          push    cx              ;
 33785                                          push    si              ;
 33786                                          sub     bx,bx           ; remains ZERO until first block
 33787                                  swchk_loop:                     ;
 33788                                          call    get_char        ; get first char of current line
 33789                                          jc	short swchk_end	; hit eof
 33790                                          cmp     al,CONFIG_BEGIN ;
 33791                                          jne	short swchk_next1 ;
 33792                                          inc     bx              ; remember that we've seen a block
 33793                                          jmp     short swchk_nextline
 33794                                  swchk_next1:                    ;
 33795                                          cmp     al,CONFIG_NUMLOCK
 33796                                          jne	short swchk_next2 ;
 33797                                          or      bx,bx           ; only do NUMLOCK commands that exist
 33798                                          jnz	short swchk_nextline ; before the first block
 33799                                          call    set_numlock     ; REM it out so we don't act on it later, too
 33800                                          mov     byte [es:si-1],CONFIG_REM
 33801                                          jmp     short swchk_nextline
 33802                                  swchk_next2:                    ;
 33803                                          cmp     al,CONFIG_SWITCHES
 33804                                          jne	short swchk_nextline ; this line ain't it
 33805                                  swchk_scan:                     ;
 33806                                          call    get_char        ; look for /N or /F
 33807                                  swchk_scan1:                    ;
 33808                                          cmp     al,LF           ; end of line?
 33809                                          je	short swchk_nextline ; yes
 33810                                          cmp     al,'/'          ; switch-char?
 33811                                          jne	short swchk_scan ; no
 33812                                          call    get_char        ;
 33813                                          and     al,~20h ; 0DFh	; convert to upper case
 33814                                          cmp     al,[swit_n+1]
 33815                                          jne	short swchk_scan2 ; no
 33816                                          or      byte [bDisableUI],1
 33817                                          jmp	short swchk_scan ; continue looking for switches of interest
 33818                                  swchk_scan2:                    ;
 33819                                          cmp     al,[swit_f+1]
 33820                                          jne	short swchk_scan1 ; no
 33821                                          or      byte [bDisableUI],2
 33822                                          jmp     short swchk_scan ; continue looking for switches of interest
 33823                                  swchk_nextline:                 ;
 33824                                          call    skip_opt_line   ;
 33825                                          jmp     short swchk_loop ;
 33826                                  swchk_end:                      ;
 33827                                          pop     si              ;
 33828                                          pop     cx              ;
 33829                                  
 33830                                  ;   Do the keyboard tests for clean/interactive boot now, but only if
 33831                                  ;   the DisableUI flag is still clear
 33832                                  
 33833                                          test    byte [bDisableUI],1
 33834                                          jnz	short menu_search
 33835                                  ;
 33836                                  ;   Wait for 2 seconds first, UNLESS the /F bit was set in bDisableUI, or
 33837                                  ;   there is anything at all in the keyboard buffer
 33838                                  ;
 33839                                          call    kbd_read
 33840                                          jnc	short menu_search
 33841                                          jmp	menu_abort
 33842                                  
 33843                                  ;   Search for MENU block;  it is allowed to be anywhere in config.sys
 33844                                  
 33845                                  menu_search:
 33846                                          sub     bx,bx           ; if no MENU, default to zero for no_selection
 33847                                          mov     di,szMenu	;
 33848                                          call    find_block      ; find the MENU block
 33849                                          jnc	short menu_found ;
 33850                                          mov     byte [szBoot],0
 33851                                          jmp	no_selection ; not found
 33852                                  
 33853                                  ;   Process the requested menu color(s)
 33854                                  
 33855                                  menu_color:
 33856                                          push    cx              ;
 33857                                          push    dx              ;
 33858                                          mov     dx,0007h        ; default color setting
 33859                                          call    get_number	; get first number
 33860                                          and     bl,0Fh		; first # is foreground color (for low nibble)
 33861                                          mov     ch,bl           ; save it in CH
 33862                                          and     dl,0F0h         ;
 33863                                          or      dl,bl           ;
 33864                                          call    delim           ; did we hit a delimiter
 33865                                          jne	short check_color ; no, all done
 33866                                          call    get_number	; get next number
 33867                                          and     bl,0Fh		; second # is background color (for high nibble)
 33868                                          mov     dh,bl           ; save it in DH
 33869                                          and     dl,0Fh		;
 33870                                          mov     cl,4            ;
 33871                                          shl     bl,cl           ;
 33872                                          or      dl,bl           ;
 33873                                  check_color:                    ;
 33874                                          cmp     ch,dh           ; are foreground/background the same?
 33875                                          jne	short set_color	; no
 33876                                          xor     dl,08h          ; yes, so modify the fgnd intensity
 33877                                  set_color:
 33878                                          mov     [bMenuColor],dl ;
 33879                                          pop     dx              ;
 33880                                          pop     cx              ;
 33881                                          jmp	menu_nextitem
 33882                                  
 33883                                  ;   Back to our regularly scheduled program (the COLOR and other goop
 33884                                  ;   above is there simply to alleviate short jump problems)
 33885                                  
 33886                                  menu_found:
 33887                                          mov     byte [bDefBlock],1
 33888                                          mov     word [offDefBlock],0
 33889                                          mov     byte [secTimeOut],-1
 33890                                          and     byte [bQueryOpt],~2 ; 0FDh
 33891                                  
 33892                                          call    skip_opt_line   ; skip to next line
 33893                                          sub     dx,dx           ; initialize total block count (0 => none yet)
 33894                                  
 33895                                  ;   Process the menu block now
 33896                                  
 33897                                  menu_process:
 33898                                          call    get_char        ; get first char of current line
 33899                                          jc	short to_menu_getdefault ; could happen if menu block at end (rare)
 33900                                          and     al,~CONFIG_OPTION_QUERY ; 7Fh
 33901                                          cmp     al,CONFIG_BEGIN ; BEGIN implies END
 33902                                          je	short to_menu_getdefault
 33903                                          cmp     al,CONFIG_SUBMENU
 33904                                          je	short menu_item	; go process sub-menu
 33905                                          cmp     al,CONFIG_MENUITEM
 33906                                          je	short menu_item	; go process menu item
 33907                                          cmp     al,CONFIG_MENUDEFAULT
 33908                                          je	short menu_default ; go process menu default
 33909                                          cmp     al,CONFIG_MENUCOLOR
 33910                                          je	short menu_color ; go process menu color
 33911                                          cmp     al,CONFIG_NUMLOCK
 33912                                          je	short menu_numlock ;
 33913                                          cmp     al,CONFIG_REM   ; allow remarks in menu block
 33914                                          je	short menu_nextitem ;
 33915                                          call    any_delim       ; allow blank lines and such
 33916                                          je	short menu_nextitem ;
 33917                                          stc                     ;
 33918                                          call    print_error     ; non-MENU command!
 33919                                          jmp     short menu_nextitem
 33920                                  menu_numlock:
 33921                                          call    set_numlock
 33922                                          jmp     short menu_nextitem
 33923                                  to_menu_getdefault:
 33924                                          jmp     short menu_getdefault
 33925                                  
 33926                                  ;   Save the offset of the default block name, we'll need it later
 33927                                  
 33928                                  menu_default:
 33929                                          mov     [offDefBlock],si; save address of default block name
 33930                                          cmp     byte [secElapsed],0
 33931                                          jne	short timeout_skip ; secElapsed is only zero for the FIRST menu,
 33932                                          call    skip_token      ; and for subsequent menus IF nothing was typed;
 33933                                          jc	short menu_nextitem ; secElapsed becomes -1 forever as soon as
 33934                                          call    skip_delim      ; something is typed
 33935                                          jc	short menu_nextitem ;
 33936                                          mov     si,bx           ;
 33937                                          call    get_number      ; get number (of seconds for timeout)
 33938                                          cmp     bl,90           ; limit it to a reasonable number
 33939                                          jb	short timeout_ok ; (besides, 99 is the largest # my simple
 33940                                          mov     bl,90           ;  display function can handle)
 33941                                  timeout_ok:                     ;
 33942                                          mov     [secTimeOut],bl ;
 33943                                  timeout_skip:
 33944                                          jmp     short menu_nextitem
 33945                                  
 33946                                  ;   Verify that this is a valid menu item by searching for the named block
 33947                                  
 33948                                  menu_item:
 33949                                          cmp     dl,MAX_MULTI_CONFIG ; have we reached the max # of items yet?
 33950                                          jae	short menu_nextitem ;
 33951                                          mov     di,si           ; DS:DI -> block name to search for
 33952                                          call    srch_block      ;
 33953                                          je	short menu_itemfound ;
 33954                                          stc                     ;
 33955                                          call    print_error     ; print error and pause
 33956                                          jmp     short menu_nextitem ; if not found, ignore this menu item
 33957                                  
 33958                                  ;   srch_block, having succeeded, returns DI -> past the token that it
 33959                                  ;   just matched, which in this case should be a descriptive string; ES:SI
 33960                                  ;   and CX are unmodified
 33961                                  
 33962                                  menu_itemfound:
 33963                                          inc     dx              ; otherwise, increment total block count
 33964                                          mov     bx,dx           ; and use it to index the arrays of offsets
 33965                                          mov	[abBlockType+bx],al
 33966                                          add     bx,bx           ; of recorded block names and descriptions
 33967                                  
 33968                                  ;   There should be a description immediately following the block name on
 33969                                  ;   MENUITEM line; failing that, we'll just use the block name as the
 33970                                  ;   description...
 33971                                  
 33972                                          mov     [aoffBlockName+bx],si
 33973                                          mov     [aoffBlockDesc+bx],si
 33974                                          mov     di,bx           ; skip_delim modifies BX, so stash it in DI
 33975                                          call    skip_token      ;
 33976                                          jc	short menu_nextitem ; hit eol/eof
 33977                                          call    skip_delim      ;
 33978                                          jc	short menu_nextitem ; hit eol/eof
 33979                                          xchg    bx,di           ;
 33980                                          mov     [aoffBlockDesc+bx],di
 33981                                  
 33982                                  menu_nextitem:
 33983                                          call    skip_opt_line   ;
 33984                                          jmp     menu_process    ; go back for more lines
 33985                                  
 33986                                  ;   Display menu items now, after determining which one is default
 33987                                  
 33988                                  menu_getdefault:
 33989                                          or      dl,dl           ; where there any valid blocks at all?
 33990                                          jnz	short menu_valid ; yes
 33991                                          sub     bx,bx           ; no, so force autoselect of 0
 33992                                          jmp     menu_autoselect ; (meaning: process common blocks only)
 33993                                  menu_valid:
 33994                                          sub     bx,bx           ;
 33995                                          mov     [bMaxBlock],dl  ; first, record how many blocks we found
 33996                                          mov     di,[offDefBlock];
 33997                                          or      di,di           ; does a default block exist?
 33998                                          jz	short menu_nodefault ; no
 33999                                          inc     bx              ; yes, walk name table, looking for default
 34000                                  menu_chkdefault:
 34001                                          push    bx              ;
 34002                                          add     bx,bx           ;
 34003                                          mov     si,[aoffBlockName+bx]
 34004                                          mov     cx,128          ; arbitrary maximum length of a name
 34005                                          push    ds              ;
 34006                                          push    es              ;
 34007                                          pop     ds              ;
 34008                                          call    comp_names      ; is this block the same as the default?
 34009                                          pop     ds              ;
 34010                                          pop     bx              ;
 34011                                          je	short menu_setdefault ; yes
 34012                                          inc     bx              ;
 34013                                          cmp     bl,[bMaxBlock]  ; all done searching?
 34014                                          jbe	short menu_chkdefault ; not yet
 34015                                  menu_nodefault:
 34016                                          mov     bl,1            ; if no default, force default to #1
 34017                                  menu_setdefault:
 34018                                          mov     [bDefBlock],bl  ; yes, this will be the initial current block
 34019                                  
 34020                                  ;   If the timeout was explicitly set to 0 (or technically, anything that
 34021                                  ;   failed to resolve to a number, like "NONE" or "EAT POTATOES"), then we're
 34022                                  ;   supposed to skip menu display and run with the specified default block;
 34023                                  ;   however, if the user hit Enter prior to boot, thereby requesting fully
 34024                                  ;   INTERACTIVE boot, then we shall display the menu block anyway (though still
 34025                                  ;   with no timeout)
 34026                                  
 34027                                          cmp     byte [secTimeOut],0 ; is timeout zero? (ie, assume default)
 34028                                          jne	short menu_display ; no
 34029                                          test    byte [bQueryOpt],1 ; yes, but was INTERACTIVE requested?
 34030                                          jnz	short menu_display ; yes, so *don't* assume default after all
 34031                                          jmp     not_topmenu	;
 34032                                  
 34033                                  ;   Reset the mode, so that we know screen is clean and cursor is home
 34034                                  
 34035                                  menu_display:
 34036                                          mov     ah,0Fh          ; get current video mode
 34037                                          int     10h             ;
 34038                                          mov     ah,00h          ; just re-select that mode
 34039                                          int     10h             ;
 34040                                          push    es              ;
 34041                                          mov     ax,40h          ; reach down into the ROM BIOS data area
 34042                                          mov     es,ax           ; and save the current (default) video page
 34043                                          mov     ax,[es:004Eh]   ; start address and page #, in case the
 34044                                          mov     [wCRTStart],ax  ; undocumented QUIET option was enabled
 34045                                          mov     al,[es:0062h]   ;
 34046                                          mov     [bCRTPage],al   ;
 34047                                          mov     ax,[bMenuPage]	; select new page for menu
 34048                                          int     10h             ;
 34049                                          mov     ax,0600h        ; clear entire screen
 34050                                          mov     bh,[bMenuColor] ; using this color
 34051                                          sub     cx,cx           ; upper left row/col
 34052                                          ;mov	dl,[es:CRT_Cols] 
 34053                                          mov	dl,[es:4Ah]
 34054                                  	dec     dl              ;
 34055                                          ;mov	dh,[es:CRT_Rows];
 34056                                          mov	dh,[es:84h]
 34057                                  	or      dh,dh           ; # of rows valid?
 34058                                          jnz	short menu_clear ; hopefully
 34059                                          mov     dh,[bLastRow]   ; no, use a default
 34060                                  menu_clear:
 34061                                          int     10h             ; clear the screen using the req. attribute
 34062                                          pop     es              ;
 34063                                          mov     [bLastRow],dh   ; save DH
 34064                                          mov     dx,_$MenuHeader
 34065                                          call    print           ; cursor now on row 3 (numbered from 0)
 34066                                  
 34067                                          test    byte [bDisableUI],1
 34068                                          jnz     short menu_nostatus
 34069                                          mov     bh,[bMenuPage]  ;
 34070                                          mov     dh,[bLastRow]   ; restore DH
 34071                                          mov     dl,0            ; print the status line on row DH, col 0,
 34072                                          mov     ah,02h          ; now that we can trash the cursor position
 34073                                          int     10h             ;
 34074                                          mov     dx,_$StatusLine
 34075                                          call    print           ;
 34076                                          mov     ah,3            ; get cursor position
 34077                                          int     10h             ;
 34078                                          sub     dl,2            ;
 34079                                          mov     [bLastCol],dl   ; save column where status char will go
 34080                                  
 34081                                  menu_nostatus:
 34082                                          mov     bx,1            ; now prepare to display all the menu items
 34083                                  menu_disploop:
 34084                                          call    print_item	; print item #BL
 34085                                          inc     bx              ; why "inc bx"?  because it's a 1-byte opcode
 34086                                          cmp     bl,[bMaxBlock]  ; all done?
 34087                                          jbe	short menu_disploop ; not yet
 34088                                  
 34089                                  ;   Set cursor position to just below the menu items
 34090                                  
 34091                                          mov     dl,0            ; select column
 34092                                          mov     dh,bl           ;
 34093                                          add     dh,4            ; select row below menu
 34094                                          mov     bh,[bMenuPage]  ;
 34095                                          mov     ah,02h          ; set cursor position beneath the block list
 34096                                          int     10h             ;
 34097                                  
 34098                                          mov     dx,_$MenuPrmpt
 34099                                          call    print           ;
 34100                                          call    select_item     ; make a selection, return # in BX
 34101                                          mov     dx,crlfm	
 34102                                          call    print           ;
 34103                                          push    word [bDisableUI]
 34104                                          or      byte [bDisableUI],1
 34105                                          call    show_status     ; clear the status line now
 34106                                          pop     word [bDisableUI]
 34107                                  
 34108                                  ;   Now begins the "re-organization" process...
 34109                                  
 34110                                  menu_autoselect:
 34111                                          cmp     bx,-1           ; clean boot requested?
 34112                                          jne	short normal_boot ; no
 34113                                          call    disable_autoexec; basically, add a /D to the command.com line
 34114                                  menu_abort:
 34115                                          sub     cx,cx           ; then immediately exit with 0 config.sys image
 34116                                          jmp	menu_exit	;
 34117                                  
 34118                                  normal_boot:
 34119                                          cmp     bx,-2           ; back to top-level menu?
 34120                                          jne	short not_topmenu ; no
 34121                                          mov     cx,[count]      ; yes, start all over
 34122                                          sub     si,si           ;
 34123                                          jmp     menu_search
 34124                                  
 34125                                  not_topmenu:
 34126                                          cmp     byte [abBlockType+bx],CONFIG_SUBMENU
 34127                                          jne	short not_submenu
 34128                                          add     bx,bx           ;
 34129                                          mov     di,[aoffBlockName+bx]
 34130                                          call    srch_block      ; THIS CANNOT FAIL!
 34131                                          mov     si,di           ;
 34132                                          mov     cx,bx           ; ES:SI and CX are ready for another round
 34133                                          jmp     menu_found
 34134                                  
 34135                                  not_submenu:
 34136                                          add     bx,bx           ; get BX -> name of selected block
 34137                                          mov     bx,[aoffBlockName+bx]
 34138                                  
 34139                                  ;   BX should now either be ZERO (meaning no block has been selected) or
 34140                                  ;   the offset relative to ES of the block name to be processed (along with
 34141                                  ;   all the "common" lines of course)
 34142                                  
 34143                                  no_selection:
 34144                                          mov     [offDefBlock],bx; save selection
 34145                                          mov     cx,[count]      ; reset ES:SI and CX for reprocessing
 34146                                          sub     si,si           ;
 34147                                          push    ds              ;
 34148                                          mov     ds,[config_wrkseg]; this is where we'll store new config.sys image
 34149                                          sub     di,di           ;
 34150                                  
 34151                                  ;   ES:SI-> config.sys, DS:DI -> new config.sys workspace
 34152                                  ;
 34153                                  ;   Work our way through the config.sys image again, this time copying
 34154                                  ;   all lines that are (A) "common" lines outside any block or (B) lines
 34155                                  ;   within the requested block.  Lines inside INCLUDEd blocks are transparently
 34156                                  ;   copied by copy_block in a recursive fashion;  the amount of recursion is
 34157                                  ;   limited by the fact INCLUDE statements are REMed by copy_block as they are
 34158                                  ;   processed and by the number of unique INCLUDE stmts in config.sys...
 34159                                  ;
 34160                                  ;   BUGBUG 20-Mar-1992 JeffPar: If we can figure out the lower bound of the
 34161                                  ;   stack we're running on, then we should check it inside copy_block
 34162                                  
 34163                                  copyblock_loop:
 34164                                          push    bx              ; save selected block name
 34165                                          call    copy_block      ; process (named or common) block
 34166                                          pop     bx              ;
 34167                                          jc	short move_config ; hit eof
 34168                                  
 34169                                  ;   copy_block can only return for two reasons:  it hit eof or a new block
 34170                                  
 34171                                  copyblock_begin:
 34172                                          push    ax              ;
 34173                                          push    cx              ;
 34174                                          push    si              ;
 34175                                          push    di              ; always do "common" blocks
 34176                                          mov     di,szCommon
 34177                                          push    ds              ;
 34178                                          push    cs              ;
 34179                                          pop     ds              ;
 34180                                          call    comp_names      ;
 34181                                          pop     ds              ;
 34182                                          pop     di              ;
 34183                                          pop     si              ;
 34184                                          pop     cx              ;
 34185                                          pop     ax              ;
 34186                                          je	short copyblock_check
 34187                                          or      bx,bx           ; is there a block name to check?
 34188                                          jz	short copyblock_skip ; no
 34189                                          push    di              ;
 34190                                          mov     di,bx           ; check block against given block name
 34191                                          push    ds              ;
 34192                                          push    es              ;
 34193                                          pop     ds              ;
 34194                                          call    comp_names      ; is this the block we really want to do?
 34195                                          pop     ds              ;
 34196                                          pop     di              ;
 34197                                  copyblock_check:
 34198                                          jc	short move_config ; hit eof
 34199                                          jne	short copyblock_skip  ;
 34200                                          call    skip_opt_line   ;
 34201                                          jmp	short copyblock_loop 
 34202                                  
 34203                                  copyblock_skip:                 ;
 34204                                          call    skip_opt_line   ; this ain't the block we wanted, so skip it
 34205                                          call    get_char        ;
 34206                                          jc	short move_config ; hit eof
 34207                                          and     al,~CONFIG_OPTION_QUERY ; 7Fh
 34208                                          cmp     al,CONFIG_BEGIN ;
 34209                                          je	short copyblock_begin
 34210                                          jmp     short copyblock_skip ; anything else is just skipped
 34211                                  ;
 34212                                  ;   To create as little risk to the rest of SysInit as little as possible,
 34213                                  ;   and to free the workspace at "config_wrkseg" for creating an environment,
 34214                                  ;   copy the new config.sys image to "confbot"
 34215                                  ;
 34216                                  move_config:
 34217                                          mov     cx,di           ; now copy workspace at DS:DI to "confbot"
 34218                                          push    cx              ;
 34219                                  ;
 34220                                  ;   But first, copy the CONFIG=<configuration><0> string to the workspace,
 34221                                  ;   since the configuration name only currently exists in the "confbot" area
 34222                                  ;
 34223                                   	;mov	cx,7
 34224                                  	mov     cx,szMenu-szBoot-1
 34225                                          mov     si,szBoot	; first copy the CONFIG= part
 34226                                          inc     di              ; skip a byte, in case absolutely nothing
 34227                                                                  ; was copied to the workspace, because we always
 34228                                                                  ; zero the first byte of the workspace (below)
 34229                                  copy_boot: 
 34230                                  	;lods    byte ptr cs:[si];
 34231                                          cs
 34232                                  	lodsb
 34233                                  	mov     [di],al         ;
 34234                                          inc     di              ;
 34235                                          loop    copy_boot       ;
 34236                                  
 34237                                          push    es              ; then copy the configuration name
 34238                                          mov     cx,128-7        ; put an upper limit on the name, to be safe
 34239                                          mov     si,[cs:offDefBlock]; ES:SI -> default block name
 34240                                          or      si,si           ; valid?
 34241                                          jnz	short l1	; yes
 34242                                          push    cs              ;
 34243                                          pop     es              ;
 34244                                          mov     si,szCommon
 34245                                  l1:     mov     al,[es:si]      ;
 34246                                          call    any_delim       ;
 34247                                          je	short l2	;
 34248                                          mov     [di],al         ;
 34249                                          inc     si              ;
 34250                                          inc     di              ;
 34251                                          loop    l1              ;
 34252                                  l2:     mov     byte [di],lf	; terminate the configuration string
 34253                                          pop     es              ;
 34254                                  
 34255                                  ;   Now we can copy "config_wrkseg" (DS) to "confbot" (ES)
 34256                                  
 34257                                          sub     di,di           ;
 34258                                          mov     [cs:config_envlen],di
 34259                                          sub     si,si           ;
 34260                                          pop     cx              ; recover the size of "config_wrkseg"
 34261                                  
 34262                                          push    cx              ;
 34263                                          rep     movsb           ; moved!
 34264                                          pop     cx              ;
 34265                                          mov     ax,ds           ;
 34266                                          pop     ds              ;
 34267                                  
 34268                                  ;   Now that the config_wrkseg is available once again, we shall
 34269                                  ;   use it to create an environment. The first thing to go in will be
 34270                                  ;   the "CONFIG=configuration" thing. It is also important to zero
 34271                                  ;   the first byte of the workspace, so that copy_envvar knows the buffer
 34272                                  ;   is empty.
 34273                                  
 34274                                          push    es              ;
 34275                                          mov     es,ax           ;
 34276                                          inc     si              ; ES:SI -> "CONFIG=configuration"
 34277                                          mov     byte [es:0],0	;empty the environment block
 34278                                          call    copy_envvar     ; copy envvar at ES:SI to "config_wrkseg"
 34279                                          pop     es
 34280                                  
 34281                                  ;   Before returning, restore the default video page setting but do NOT
 34282                                  ;   do it using INT 10h's Set Active Page function, because if the menu was
 34283                                  ;   displayed on a different page, then it's because we don't want to see
 34284                                  ;   all the device driver/TSR goop (which goes to the default page)
 34285                                  
 34286                                  menu_done:
 34287                                          cmp     byte [bMenuPage],0
 34288                                          je	short menu_exit	;
 34289                                          push    es              ;
 34290                                          mov     ax,40h          ;
 34291                                          mov     es,ax           ;
 34292                                          mov     ax,[wCRTStart]  ;
 34293                                          mov     [es:004Eh],ax   ;
 34294                                          mov     al,[bCRTPage]   ;
 34295                                          mov     [es:0062h],al   ;
 34296                                          pop     es              ;
 34297                                  menu_exit:
 34298                                          mov     [count],cx      ; set new counts
 34299                                          mov     [org_count],cx  ;
 34300                                          sub     si,si           ; always return ES:SI pointing to config.sys
 34301                                          retn
 34302                                  
 34303                                  ;----------------------------------------------------------------------------
 34304                                  ;
 34305                                  ;   copy_envvar:  copy the envvar at ES:SI to "config_wrkseg"
 34306                                  ;
 34307                                  ;   INPUT
 34308                                  ;    ES:SI -> environment variable (in the form "var=string<cr/lf>")
 34309                                  ;
 34310                                  ;   OUTPUT
 34311                                  ;       config_envlen (ie, where to put next envvar) updated appropriately
 34312                                  ;       carry set if error (eg, missing =); clear otherwise
 34313                                  ;
 34314                                  ;   OTHER REGS USED
 34315                                  ;       None
 34316                                  ;
 34317                                  ;   NOTES
 34318                                  ;       None
 34319                                  ;
 34320                                  ;   HISTORY
 34321                                  ;       Created 29-Mar-1992 by JeffPar
 34322                                  ;
 34323                                  ;----------------------------------------------------------------------------
 34324                                  
 34325                                  copy_envvar:
 34326                                          push    cx              ;
 34327                                          push    si              ;
 34328                                          push    ds              ;
 34329                                          push    es              ;
 34330                                          push    es              ;
 34331                                          mov     es,[config_wrkseg] ; ES:DI to point to next available byte
 34332                                          pop     ds                 ; DS:SI to point to envvar
 34333                                  
 34334                                  ;   Have to calculate the length of the variable name (and if we hit
 34335                                  ;   the end of the line before we hit '=', then it's curtains for this
 34336                                  ;   config.sys line)
 34337                                  ;
 34338                                  ;   The check for NULL is important because copy_envvar is also used to copy
 34339                                  ;   the initial CONFIG= setting, which will have been zapped by a NULL if no
 34340                                  ;   menu block existed (in order to prevent the creation of an environment)
 34341                                  
 34342                                          sub     cx,cx           ;
 34343                                  copy_varlen:                    ;
 34344                                          lodsb                   ;
 34345                                          or      al,al           ; NULL?
 34346                                          stc                     ;
 34347                                          jz	short copy_envexit ; yes, abort
 34348                                          cmp     al,cr          ;
 34349                                          stc                     ;
 34350                                          je	short copy_envexit
 34351                                          cmp     al,lf          ;
 34352                                          stc                     ;
 34353                                          je	short copy_envexit
 34354                                          inc     cx              ;
 34355                                          cmp     al,'='          ;
 34356                                          jne	short copy_varlen
 34357                                          mov     al,0            ;
 34358                                          mov     ah,[si]         ; save char after '='
 34359                                          sub     si,cx           ; back up to given varname
 34360                                          dec     cx              ; CX == # of bytes in varname
 34361                                          sub     di,di           ; start looking for DS:SI at ES:0
 34362                                  copy_varsrch:
 34363                                          cmp     byte [es:di],al
 34364                                          je	short copy_envprep ; search failed, just copy var
 34365                                          mov     bx,di           ; ES:BX -> start of this varname
 34366                                          push    cx              ;
 34367                                          push    si              ;
 34368                                          repe    cmpsb           ;
 34369                                          pop     si              ;
 34370                                          pop     cx              ;
 34371                                          jne	short copy_varnext ; no match, skip to next varname
 34372                                          cmp     byte [es:di],'='
 34373                                          jne     short copy_varnext ; no match, there's more characters
 34374                                  
 34375                                  ;   Previous occurrence of variable has been found; determine the
 34376                                  ;   entire length and then destroy it
 34377                                  
 34378                                          mov     cx,-1           ;
 34379                                          repne   scasb           ; guaranteed to get null (since we put it there)
 34380                                          push    si              ;
 34381                                          mov     si,di           ;
 34382                                          mov     di,bx           ;
 34383                                          mov     cx,[cs:config_envlen]
 34384                                          sub     cx,si           ; destroy variable now
 34385                                  	;rep movs byte ptr es:[di],byte ptr es:[si]
 34386                                  	;;db 0F3h,26h,0A4h ; MSDOS 6.21 IO:SYS - SYSINIT:4724h
 34387                                  
 34388                                  	rep	; 0F3h
 34389                                  	es	; 26h
 34390                                  	movsb	; 0A4h
 34391                                  
 34392                                  	pop     si
 34393                                  copy_envprep:
 34394                                          cmp     ah,cr          ; if there is nothing after the '='
 34395                                          je	short copy_envdel ; then just exit with variable deleted
 34396                                          cmp     ah,lf           ;
 34397                                          je	short copy_envdel
 34398                                          jmp     short copy_envloop
 34399                                  
 34400                                  copy_varnext:                   ;
 34401                                          push    cx              ;
 34402                                          mov     cx,-1           ;
 34403                                          repne   scasb           ;
 34404                                          pop     cx              ;
 34405                                          jmp	short copy_varsrch
 34406                                  
 34407                                  copy_envloop:                   ;
 34408                                          lodsb                   ;
 34409                                          cmp     al,cr           ;
 34410                                          je	short copy_envdone
 34411                                          cmp     al,lf           ;
 34412                                          je	short copy_envdone
 34413                                          stosb                   ;
 34414                                          jmp     short copy_envloop
 34415                                  
 34416                                  copy_envdone:                   ;
 34417                                          sub     al,al           ; do SUB to clear carry as well
 34418                                          stosb                   ; always null-terminate these puppies
 34419                                  copy_envdel:                    ;
 34420                                          mov     [es:di],al      ; and stick another null to terminate the env.
 34421                                          mov     [cs:config_envlen],di
 34422                                  
 34423                                  copy_envexit:                   ;
 34424                                          pop     es              ;
 34425                                          pop     ds              ;
 34426                                          pop     si              ;
 34427                                          pop     cx              ;
 34428                                  
 34429                                  copy_done:	; 18/12/2022
 34430                                          retn
 34431                                  
 34432                                  ;----------------------------------------------------------------------------
 34433                                  ;
 34434                                  ;   copy_block:  copy the current block to the new config.sys workspace
 34435                                  ;
 34436                                  ;   INPUT
 34437                                  ;       CX == remaining bytes in "organized" config.sys memory image
 34438                                  ;    ES:SI -> remaining bytes in "organized" config.sys memory image
 34439                                  ;    DS:DI -> new config.sys workspace (equal in size to the original
 34440                                  ;             config.sys image) where the current block is to be copied
 34441                                  ;
 34442                                  ;   OUTPUT
 34443                                  ;       Same as above
 34444                                  ;       AL also equals the last character read from the organized image
 34445                                  ;
 34446                                  ;   OTHER REGS USED
 34447                                  ;       All
 34448                                  ;
 34449                                  ;   NOTES
 34450                                  ;       None
 34451                                  ;
 34452                                  ;   HISTORY
 34453                                  ;       Created 16-Mar-1992 by JeffPar
 34454                                  ;
 34455                                  ;----------------------------------------------------------------------------
 34456                                  
 34457                                  copy_block:
 34458                                          call    get_char        ; check for include
 34459                                          jc	short copy_done	;
 34460                                  	and     al,~CONFIG_OPTION_QUERY ; 7Fh
 34461                                  	cmp     al,CONFIG_BEGIN ; another BEGIN implies END as well
 34462                                          je	short copy_done ;
 34463                                  
 34464                                          cmp     al,CONFIG_INCLUDE ; 'J'
 34465                                          mov     al,ah           ; AL == the original line code
 34466                                          jne	short copy_line	; not an "include" line
 34467                                  
 34468                                  ;   We have hit an "INCLUDE" line; first, REM out the line so that we
 34469                                  ;   never try to include the block again (no infinite include loops please),
 34470                                  ;   then search for the named block and call copy_block again.
 34471                                  
 34472                                          mov     byte [es:si-1],CONFIG_REM ; '0'
 34473                                          push    di              ;
 34474                                  
 34475                                          mov     di,szMenu
 34476                                          call    comp_names_safe ; don't allow INCLUDE MENU
 34477                                          je	short copy_skip	;
 34478                                  
 34479                                          mov     di,szCommon
 34480                                          call    comp_names_safe ; don't allow INCLUDE COMMON
 34481                                          je	short copy_skip	;
 34482                                  
 34483                                          mov     di,si           ; try to find the block
 34484                                          call    srch_block      ;
 34485                                          mov     dx,di           ;
 34486                                          pop     di              ;
 34487                                          jne	short copy_error ; no such block
 34488                                          push    cx              ;
 34489                                          mov     cx,bx           ;
 34490                                          push    si              ;
 34491                                          dec     dx              ;
 34492                                          mov     si,dx           ;
 34493                                          call    skip_line       ; skip the rest of the "block name" line
 34494                                          call    copy_block      ; and copy in the rest of that block
 34495                                          pop     si              ;
 34496                                          pop     cx              ;
 34497                                          sub     al,al           ; force skip_opt_line to skip...
 34498                                          jmp     short copy_nextline
 34499                                  
 34500                                  copy_skip:
 34501                                          pop     di
 34502                                  copy_error:
 34503                                          clc                     ;
 34504                                          call    print_error     ; note that carry is clear, no pause
 34505                                          jmp     short copy_nextline
 34506                                  
 34507                                  ;   Copy the line at ES:SI to the current location at DS:DI
 34508                                  
 34509                                  copy_line:
 34510                                          mov     [di],al         ;
 34511                                          inc     di              ;
 34512                                          cmp     al,' '          ; is this is a "real" line with a "real" code?
 34513                                          jb	short copy_nextline ; no
 34514                                          cmp     byte [cs:config_multi],0
 34515                                          je	short copy_loop	; not a multi-config config.sys, don't embed #s
 34516                                          call    get_linenum	; BX == line # of line @ES:SI
 34517                                          mov     [di],bx         ; stash it immediately following the line code
 34518                                          inc     di              ;
 34519                                          inc     di              ;
 34520                                          jmp     short copy_next ;
 34521                                  copy_loop:                      ;
 34522                                          call    get_char        ;
 34523                                          jc	short copy_done ; end of file
 34524                                          mov     [di],al         ;
 34525                                          inc     di              ;
 34526                                  copy_next:
 34527                                          cmp     al,lf ; 0Ah	; done with line?
 34528                                          jne	short copy_loop	; nope
 34529                                  
 34530                                  copy_nextline:
 34531                                          call    skip_opt_line   ;
 34532                                          jmp     short copy_block
 34533                                  
 34534                                  	; 18/12/2022
 34535                                  ;copy_done:
 34536                                          ;retn
 34537                                  
 34538                                  ;----------------------------------------------------------------------------
 34539                                  ;
 34540                                  ;   get_linenum:  return line # (in BX) of current line (@ES:SI)
 34541                                  ;
 34542                                  ;   INPUT
 34543                                  ;    ES:SI -> some line in the config.sys memory image
 34544                                  ;
 34545                                  ;   OUTPUT
 34546                                  ;       BX == line # (relative to 1)
 34547                                  ;
 34548                                  ;   OTHER REGS USED
 34549                                  ;       DX
 34550                                  ;
 34551                                  ;   NOTES
 34552                                  ;       None
 34553                                  ;
 34554                                  ;   HISTORY
 34555                                  ;       Created 16-Mar-1992 by JeffPar
 34556                                  ;
 34557                                  ;----------------------------------------------------------------------------
 34558                                  
 34559                                  get_linenum:
 34560                                          push    ax              ;
 34561                                          sub     bx,bx           ; BX == line # (to be returned)
 34562                                          push    cx              ;
 34563                                          mov     dx,si           ; DX == the offset we're looking for
 34564                                          push    si              ;
 34565                                          mov     cx,[cs:count]   ;
 34566                                          sub     si,si           ; prepare to scan entire file
 34567                                  get_linenum_loop:               ;
 34568                                          call    skip_line       ;
 34569                                          jc	short get_linenum_done
 34570                                          inc     bx              ;
 34571                                          cmp     si,dx           ; have we exceeded the desired offset yet?
 34572                                          jb	short get_linenum_loop ; no
 34573                                  get_linenum_done:               ;
 34574                                          pop     si              ;
 34575                                          pop     cx              ;
 34576                                          pop     ax              ;
 34577                                          retn
 34578                                  
 34579                                  ;----------------------------------------------------------------------------
 34580                                  ;
 34581                                  ;   srch_block:  searches entire config.sys for block name @ES:DI
 34582                                  ;
 34583                                  ;   INPUT
 34584                                  ;       ES -> config.sys image
 34585                                  ;    ES:DI -> block name to find
 34586                                  ;
 34587                                  ;   OUTPUT
 34588                                  ;       ZF flag set, if found
 34589                                  ;    ES:DI -> just past the name in the block heading, if found
 34590                                  ;       BX == # bytes remaining from that point, if found
 34591                                  ;
 34592                                  ;   OTHER REGS USED
 34593                                  ;       None
 34594                                  ;
 34595                                  ;   NOTES
 34596                                  ;       This differs from "find_block" in that it searches the ENTIRE
 34597                                  ;       config.sys image, not merely the remaining portion, and that it
 34598                                  ;       takes a pointer to block name that is *elsewhere* in the image
 34599                                  ;       (ie, ES) as opposed to some string constant in our own segment (DS).
 34600                                  ;
 34601                                  ;   HISTORY
 34602                                  ;       Created 16-Mar-1992 by JeffPar
 34603                                  ;
 34604                                  ;----------------------------------------------------------------------------
 34605                                  
 34606                                  srch_block:	          ; returns BX -> named block in CONFIG.SYS
 34607                                          push    ax              ;
 34608                                          push    cx              ;
 34609                                          mov     cx,[cs:count]   ;
 34610                                          push    si              ;
 34611                                          sub     si,si           ;
 34612                                          push    ds              ;
 34613                                          push    es              ;
 34614                                          pop     ds              ;
 34615                                          call    find_block      ;
 34616                                          mov     di,si           ;
 34617                                          mov     bx,cx           ;
 34618                                          pop     ds              ;
 34619                                          pop     si              ;
 34620                                          pop     cx              ;
 34621                                          pop     ax              ;
 34622                                  find_exit: ; 16/04/2019
 34623                                          retn			;
 34624                                  
 34625                                  ;----------------------------------------------------------------------------
 34626                                  ;
 34627                                  ;   find_block:  searches rest of config.sys for block name @DS:DI
 34628                                  ;
 34629                                  ;   INPUT
 34630                                  ;    DS:DI -> block name to find
 34631                                  ;    ES:SI -> remainder of config.sys image
 34632                                  ;       CX == remaining size of config.sys image
 34633                                  ;
 34634                                  ;   OUTPUT
 34635                                  ;       ZF flag set, if found (also, CF set if EOF)
 34636                                  ;    ES:SI -> where the search stopped (at end of block name or EOF)
 34637                                  ;       CX == # bytes remaining from that point
 34638                                  ;
 34639                                  ;   OTHER REGS USED
 34640                                  ;       AX
 34641                                  ;
 34642                                  ;   NOTES
 34643                                  ;       This differs from "srch_block" in that it searches only the
 34644                                  ;       remaining portion of the config.sys image and leaves SI and CX
 34645                                  ;       pointing to where the search left off, and that it takes a pointer
 34646                                  ;       to search string in our own segment (DS:DI instead of ES:DI).
 34647                                  ;
 34648                                  ;   HISTORY
 34649                                  ;       Created 16-Mar-1992 by JeffPar
 34650                                  ;
 34651                                  ;----------------------------------------------------------------------------
 34652                                  
 34653                                  find_block:
 34654                                          call    get_char        ; get line code
 34655                                          jc	short find_exit	; end of file
 34656                                          and     al,~CONFIG_OPTION_QUERY
 34657                                          cmp     al,CONFIG_BEGIN ; beginning of a block?
 34658                                          je	short check_line ; no
 34659                                          cmp     al,CONFIG_INCLUDE
 34660                                          jne	short next_line	;
 34661                                          or	byte [cs:config_multi],1
 34662                                          jmp     short next_line ;
 34663                                  check_line:
 34664                                          or      byte [cs:config_multi],1
 34665                                          call    comp_names      ; compare block names
 34666                                          jbe	short find_exit	; end of file, or names matched
 34667                                  next_line:
 34668                                          call    skip_opt_line   ; no, so skip to next line
 34669                                          jmp	short find_block  ;
 34670                                  ;find_exit:
 34671                                  ;	retn
 34672                                  
 34673                                  ;----------------------------------------------------------------------------
 34674                                  ;
 34675                                  ;   comp_names:  compares keyword @DS:DI to position in config.sys @ES:SI
 34676                                  ;
 34677                                  ;   INPUT
 34678                                  ;    DS:DI -> keyword to compare
 34679                                  ;    ES:SI -> position in config.sys
 34680                                  ;       CX == remaining bytes in config.sys
 34681                                  ;
 34682                                  ;   OUTPUT
 34683                                  ;       ZF flag set, if match (also, CF set if EOF)
 34684                                  ;    ES:SI -> where the comparison stopped (at end of block name or EOF)
 34685                                  ;       CX == # bytes remaining from that point
 34686                                  ;
 34687                                  ;   OTHER REGS USED
 34688                                  ;       AX
 34689                                  ;
 34690                                  ;   NOTES
 34691                                  ;       None
 34692                                  ;
 34693                                  ;   HISTORY
 34694                                  ;       Created 16-Mar-1992 by JeffPar
 34695                                  ;
 34696                                  ;----------------------------------------------------------------------------
 34697                                  
 34698                                  comp_names:
 34699                                          push    di              ;
 34700                                  comp_loop:                      ;
 34701                                          call    get_char        ;
 34702                                          jc	short comp_exit	;
 34703                                          call    any_delim       ; is next character a delimiter?
 34704                                          mov     ah,[di]         ; (get next character we're supposed to match)
 34705                                          je	short comp_almost ; yes, it *could* be a match
 34706                                          inc     di              ;
 34707                                          and     ax,~2020h ; 0DFDFh 
 34708                                  				; BUGBUG -- assumes both names are alphanumeric -JTP
 34709                                          cmp     al,ah           ; match?
 34710                                          je	short comp_loop ; yes, keep looking at the characters
 34711                                          clc                     ; prevent erroneous eof indication: clear carry
 34712                                  comp_exit:                      ;
 34713                                          pop     di              ;
 34714                                          retn			;
 34715                                  comp_almost:                    ;
 34716                                          xchg    al,ah           ; we don't know for sure if it's a match
 34717                                          call    any_delim       ; until we verify that the second string has
 34718                                          xchg    al,ah           ; been exhausted also...
 34719                                          jmp     comp_exit       ; if we are, this call to any_delim will tell...
 34720                                  
 34721                                  ;----------------------------------------------------------------------------
 34722                                  
 34723                                  comp_names_safe:
 34724                                          push    ax
 34725                                          push    cx
 34726                                          push	si
 34727                                          push    ds
 34728                                          push    cs
 34729                                          pop     ds
 34730                                          call    comp_names
 34731                                          pop     ds
 34732                                  	pop	si
 34733                                          pop     cx
 34734                                          pop     ax
 34735                                          retn
 34736                                  
 34737                                  ;----------------------------------------------------------------------------
 34738                                  ;
 34739                                  ;   print_item:  display menu item #BL
 34740                                  ;
 34741                                  ;   INPUT
 34742                                  ;       BL == menu item # to display
 34743                                  ;
 34744                                  ;   OUTPUT
 34745                                  ;       Menu item displayed, with appropriate highlighting if BL == bDefBlock
 34746                                  ;
 34747                                  ;   OTHER REGS USED
 34748                                  ;       None
 34749                                  ;
 34750                                  ;   NOTES
 34751                                  ;       This function saves/restores the current cursor position, so you
 34752                                  ;       needn't worry about it.
 34753                                  ;
 34754                                  ;   HISTORY
 34755                                  ;       Created 16-Mar-1992 by JeffPar
 34756                                  ;
 34757                                  ;----------------------------------------------------------------------------
 34758                                  
 34759                                  print_item:		; prints menu item #BL (1 to N)
 34760                                          push    ax              ;
 34761                                          push    bx              ;
 34762                                          push    cx              ;
 34763                                          push    dx              ;
 34764                                          push    si              ;
 34765                                          mov     ah,03h          ; get cursor position
 34766                                          mov     bh,[bMenuPage]  ; always page zero
 34767                                          int     10h             ; DH/DL = row/column
 34768                                          push    dx              ; save it
 34769                                          mov     ah,02h          ; set cursor position
 34770                                          mov     dh,bl           ;
 34771                                          add     dh,3            ;
 34772                                          mov     dl,5            ;
 34773                                          int     10h             ; set cursor position for correct row/col
 34774                                          mov     al,bl           ;
 34775                                          add     al,'0'          ; convert menu item # to ASCII digit
 34776                                          mov     ah,[bMenuColor] ; normal attribute
 34777                                          cmp     bl,[bDefBlock]  ; are we printing the current block?
 34778                                          jne	short print_other ; no
 34779                                          or      ah,70h          ; yes, set bgnd color to white
 34780                                          mov     ch,ah           ;
 34781                                          mov     cl,4            ;
 34782                                          rol     ch,cl           ;
 34783                                          cmp     ch,ah           ; are fgnd/bgnd the same?
 34784                                          jne	short print_other ; no
 34785                                          xor     ah,08h          ; yes, so modify the fgnd intensity
 34786                                  print_other:                    ;
 34787                                          mov     bh,0            ;
 34788                                          add     bx,bx           ;
 34789                                          mov     di,[aoffBlockDesc+bx]
 34790                                          mov     bl,ah           ; put the attribute in the correct register now
 34791                                          mov     bh,[bMenuPage]  ; get correct video page #
 34792                                          mov     ah,09h          ; write char/attr
 34793                                          mov     cx,1            ;
 34794                                          int     10h             ;
 34795                                          inc     dl              ; increment column
 34796                                          mov     ah,02h          ;
 34797                                          int     10h             ;
 34798                                          ;mov	ax,0900h+'.'    ;
 34799                                          mov	ax,092Eh
 34800                                  	int     10h             ; display '.'
 34801                                          inc     dl              ; increment column
 34802                                          mov     ah,02h          ;
 34803                                          int     10h             ;
 34804                                          ;mov	ax,0900h+' '    ;
 34805                                          mov	ax,0920h
 34806                                  	int     10h             ; display ' '
 34807                                          inc     dl              ; increment column
 34808                                          mov     ah,02h          ;
 34809                                          int     10h             ;
 34810                                          push    es              ;
 34811                                  print_loop:                     ;
 34812                                          mov     al,[es:di]	; get a character of the description
 34813                                          inc     di              ;
 34814                                          cmp     al,TAB ; 9	; substitute spaces for tabs
 34815                                          jne	short print_nontab ;
 34816                                          mov     al,' '          ;
 34817                                  print_nontab:                   ;
 34818                                          cmp     al,' '          ;
 34819                                          jb	short print_done ; stop at the 1st character < space
 34820                                          cmp     al,'$'          ;
 34821                                          je	short print_done ; also stop on $
 34822                                          mov     ah,09h          ; display function #
 34823                                          int     10h             ;
 34824                                          inc     dl              ; increment column
 34825                                          cmp     dl,78           ; far enough?
 34826                                          jae	short print_done ; yes
 34827                                          mov     ah,02h          ;
 34828                                          int     10h             ;
 34829                                          jmp     print_loop      ;
 34830                                  print_done:                     ;
 34831                                          pop     es              ;
 34832                                          pop     dx              ;
 34833                                          mov     ah,02h          ;
 34834                                          int     10h             ; restore previous row/col
 34835                                          pop     si              ;
 34836                                          pop     dx              ;
 34837                                          pop     cx              ;
 34838                                          pop     bx              ;
 34839                                          pop     ax              ;
 34840                                          retn			;
 34841                                  
 34842                                  ;----------------------------------------------------------------------------
 34843                                  ;
 34844                                  ;   select_item:  wait for user to select menu item, with time-out
 34845                                  ;
 34846                                  ;   INPUT
 34847                                  ;       None
 34848                                  ;
 34849                                  ;   OUTPUT
 34850                                  ;       BX == menu item # (1-N), or -1 for clean boot
 34851                                  ;       Selected menu item highlighted
 34852                                  ;       Cursor positioned beneath menu, ready for tty-style output now
 34853                                  ;
 34854                                  ;   OTHER REGS USED
 34855                                  ;       None
 34856                                  ;
 34857                                  ;   NOTES
 34858                                  ;       None
 34859                                  ;
 34860                                  ;   HISTORY
 34861                                  ;       Created 16-Mar-1992 by JeffPar
 34862                                  ;
 34863                                  ;----------------------------------------------------------------------------
 34864                                  
 34865                                  select_item:		; returns digit value in BX (trashes AX/CX/DX)
 34866                                          mov     bl,[bDefBlock]  ; BL will be the default block #
 34867                                          mov     al,bl           ;
 34868                                          call    disp_num        ;
 34869                                          call    show_status     ; display current interactive status
 34870                                          cmp     byte [secTimeOut],-1
 34871                                          je	short input_key	; no time-out, just go to input
 34872                                          mov     ah,GET_TIME ; 2Ch
 34873                                          int     21h             ;
 34874                                          mov     bh,dh           ; BH = initial # of seconds
 34875                                  check_time:
 34876                                          mov     al,[secTimeOut] ;
 34877                                          sub     al,[secElapsed] ;
 34878                                          jae	short show_time	;
 34879                                          or      byte [bQueryOpt],2  ; disable all further prompting
 34880                                          mov     byte [secElapsed],0
 34881                                          jmp	select_done	; time's up!
 34882                                  show_time:
 34883                                          push    bx              ;
 34884                                          mov     bl,al           ; save # in BL
 34885                                          mov     bh,[bMenuPage]  ;
 34886                                          mov     ah,03h          ; get cursor position
 34887                                          int     10h             ;
 34888                                          push    dx              ;
 34889                                  	add	dl,8		; move cursor to the right
 34890                                          mov     ah,02h          ; set cursor position
 34891                                          int     10h             ;
 34892                                          mov     dx,_$TimeOut
 34893                                          call    print           ; print the "Time remaining: " prompt
 34894                                          mov     al,bl           ; recover # from BL
 34895                                          cbw                     ; this works because AL is always <= 90
 34896                                          mov     cl,10           ;
 34897                                          div     cl              ; AL = tens digit, AH = ones digit
 34898                                          mov     cl,ah           ;
 34899                                          add     al,'0'          ;
 34900                                          mov     ah,0Eh          ;
 34901                                          int     10h             ; write TTY tens digit
 34902                                          mov     al,cl           ;
 34903                                          add     al,'0'          ;
 34904                                          mov     ah,0Eh          ;
 34905                                          int     10h             ; write TTY ones digit
 34906                                          pop     dx
 34907                                          mov     ah,02h          ; set cursor position back to where it was
 34908                                          int     10h             ;
 34909                                          pop     bx              ;
 34910                                  input_key:
 34911                                          mov     ah,RAW_CON_IO ; 6
 34912                                          mov     dl,0FFh         ; input request
 34913                                          int     21h             ;
 34914                                          jnz	short got_key	;
 34915                                          cmp     byte [secTimeOut],-1; is there a time-out?
 34916                                          je	short input_key	; no, just go back to input
 34917                                          mov     ah,GET_TIME     ;
 34918                                          int     21h             ; DH = seconds
 34919                                          mov     ah,dh           ;
 34920                                          sub     dh,bh           ; should generally be zero or one
 34921                                          mov     bh,ah           ;
 34922                                          jnc	short got_time	;
 34923                                          mov     dh,1            ; it wrapped back to zero, so assume one
 34924                                  got_time:
 34925                                          or      dh,dh           ; any change?
 34926                                          jz	short input_key	; no
 34927                                          add     [secElapsed],dh ;
 34928                                          jmp	short check_time ;
 34929                                  got_key:
 34930                                          push    ax              ;
 34931                                          mov     ax,-1           ; zap both secTimeOut and secElapsed
 34932                                          xchg    [secTimeOut],ax
 34933                                          cmp     al,-1           ; was time-out already disabled?
 34934                                          je	short timeout_disabled ; yes
 34935                                          push    bx              ; let's disable # seconds display
 34936                                          mov     ax,0A20h        ; write multiple spaces
 34937                                          mov     bx,[bMenuColor]
 34938                                          mov     cx,80           ; 80 of them, to be safe
 34939                                          int     10h             ; to completely obliterate # seconds display
 34940                                          pop     bx   		;
 34941                                  
 34942                                  timeout_disabled:
 34943                                          pop     ax              ;
 34944                                          or      al,al           ; extended key pressed?
 34945                                          jnz	short normal_key ; no
 34946                                          int     21h             ; get the next part of the key then
 34947                                          jz	short input_key	; hmmm, what happened to the second part?
 34948                                  
 34949                                          cmp     al,48h          ; up arrow?
 34950                                          jne	short not_up	; no
 34951                                          cmp     bl,1            ; are we as up as up can get?
 34952                                          jbe	short input_key	; yes, ignore it
 34953                                          dec     byte [bDefBlock] ;
 34954                                          call    print_item      ; re-print the current item
 34955                                          dec     bl              ; and then print the new current item
 34956                                          jmp     short print1
 34957                                  not_up:
 34958                                          cmp     al,50h          ; down arrow?
 34959                                          jne	short not_down	; no
 34960                                          cmp     bl,[bMaxBlock]  ; are we as down as down can get?
 34961                                          jae	short to_input_key ; yes, ignore it
 34962                                          inc     byte [bDefBlock] ;
 34963                                          call    print_item      ; re-print the current item
 34964                                          inc     bx              ; and then print the new current item
 34965                                  print1: 
 34966                                  	mov     al,bl           ;
 34967                                  print2: 
 34968                                  	call    print_item      ;
 34969                                          call    disp_num        ;
 34970                                  to_input_key:
 34971                                          jmp     input_key       ;
 34972                                  not_down:
 34973                                          test    byte [bDisableUI],1
 34974                                          jnz	short to_input_key ; don't allow F8 or F5
 34975                                          cmp     al,42h          ; F8 function key?
 34976                                          jne	short not_f8	; no
 34977                                          xor     byte [bQueryOpt],1
 34978                                          call    show_status     ;
 34979                                          jmp     input_key	;
 34980                                  not_f8:
 34981                                          cmp     al,3Fh          ; F5 function key?
 34982                                          jne	short to_input_key ; no
 34983                                          mov     bx,-1           ; special return code (-1) indicating clean boot
 34984                                          mov     al,' '          ; don't want to display anything really;
 34985                                          jmp     short disp_input; just want to display the cr/lf sequence...
 34986                                  
 34987                                  normal_key:
 34988                                          cmp     al,0Dh          ; Enter?
 34989                                          je	short select_done ; yes
 34990                                          cmp     al,08h          ; backspace?
 34991                                          jne	short not_backspace ; no
 34992                                          mov     bx,-2 ; 0FFFEh	; yes, special return code
 34993                                          retn			;
 34994                                  not_backspace:
 34995                                          sub     al,'0'          ; is greater than '0'?
 34996                                          jbe	short to_input_key ; no
 34997                                          cmp     al,[bMaxBlock]  ; is less than or equal to the maximum digit?
 34998                                          ja	short to_input_key ; no
 34999                                          mov	[bDefBlock],al  ;
 35000                                          call    print_item      ; redisplay the current selection
 35001                                          mov     bl,al           ; set new selection
 35002                                          jmp	short print2
 35003                                  
 35004                                  select_done:
 35005                                          mov     bh,0            ; return a full 16-bit value (for indexing)
 35006                                          mov     al,bl           ;
 35007                                          add     al,'0'          ; convert it into a digit, then display it
 35008                                  
 35009                                  	; fall into disp_input
 35010                                  
 35011                                  ; 16/04/2019 - Retro DOS v4.0
 35012                                  
 35013                                  ;----------------------------------------------------------------------------
 35014                                  ;
 35015                                  ;   disp_input:  display a single character + cr/lf
 35016                                  ;
 35017                                  ;   INPUT
 35018                                  ;       AL == character to display
 35019                                  ;
 35020                                  ;   OUTPUT
 35021                                  ;       None
 35022                                  ;
 35023                                  ;   OTHER REGS USED
 35024                                  ;       None
 35025                                  ;
 35026                                  ;   NOTES
 35027                                  ;       This function is used not only for the menu input selection but
 35028                                  ;       also for the interactive line prompting (the y/n/a thing).
 35029                                  ;
 35030                                  ;   HISTORY
 35031                                  ;       Created 16-Mar-1992 by JeffPar
 35032                                  ;
 35033                                  ;----------------------------------------------------------------------------
 35034                                  
 35035                                  disp_input:
 35036                                          push    ax
 35037                                          cmp     al,' '
 35038                                          jae	short disp_ok
 35039                                          mov     al,' '
 35040                                  disp_ok:
 35041                                          mov     dl,al
 35042                                          mov     ah,STD_CON_OUTPUT ; 2
 35043                                          int     21h
 35044                                          mov     dx,crlfm
 35045                                          call    print
 35046                                          pop     ax
 35047                                          retn
 35048                                  
 35049                                  ;----------------------------------------------------------------------------
 35050                                  
 35051                                  disp_num:
 35052                                          push    bx
 35053                                          add     al,'0'
 35054                                          mov     ah,0Ah
 35055                                          mov     bx,[bMenuColor]
 35056                                          mov     cx,1
 35057                                          int     10h
 35058                                          pop     bx
 35059                                          retn
 35060                                  
 35061                                  ;----------------------------------------------------------------------------
 35062                                  ;
 35063                                  ;   show_status:  display current interactive mode setting (on/off/none)
 35064                                  ;
 35065                                  ;   INPUT
 35066                                  ;       None
 35067                                  ;
 35068                                  ;   OUTPUT
 35069                                  ;       None
 35070                                  ;
 35071                                  ;   OTHER REGS USED
 35072                                  ;       None
 35073                                  ;
 35074                                  ;   NOTES
 35075                                  ;       None
 35076                                  ;
 35077                                  ;   HISTORY
 35078                                  ;       Created 16-Mar-1992 by JeffPar
 35079                                  ;
 35080                                  ;----------------------------------------------------------------------------
 35081                                  
 35082                                  show_status:
 35083                                          push    bx              ; BL = video page #
 35084                                          mov     bx,[bMenuColor]
 35085                                          mov     ah,03h          ; get cursor position
 35086                                          int     10h             ;
 35087                                          push    dx              ; save it
 35088                                          mov     ah,02h          ; set cursor position
 35089                                          mov     dx,[bLastCol]   ; set correct row/col
 35090                                          test    byte [bDisableUI],1
 35091                                          jz	short show_onoff ; just show on/off
 35092                                          mov     dl,0            ;
 35093                                          int     10h             ;
 35094                                          mov     ax,0A20h        ; write multiple spaces
 35095                                          mov     cx,80           ; 80 of them, to be exact
 35096                                          int     10h             ; to obliterate the status line
 35097                                          jmp     short show_done ;
 35098                                  show_onoff: 
 35099                                          int     10h
 35100                                  		; - VIDEO - WRITE CHARACTERS ONLY AT CURSOR POSITION
 35101                                  		; AL = character, BH = display page - alpha mode
 35102                                  		; BL = color of character (graphics mode, PCjr only)
 35103                                  		; CX = number of times to write character
 35104                                  
 35105                                          mov     al,[_$NO]	; assume OFF
 35106                                          cmp     byte [bQueryOpt],1 ; is interactive mode on?
 35107                                          jne	short show_noton ; no
 35108                                          mov     al,[_$YES]	; yes
 35109                                  show_noton:                     ;
 35110                                          mov     ah,0Eh          ; write TTY
 35111                                          int     10h             ;
 35112                                  show_done:                      ;
 35113                                          pop     dx              ;
 35114                                          mov     ah,02h          ;
 35115                                          int     10h             ; restore original cursor position
 35116                                          pop     bx              ;
 35117                                          retn			;
 35118                                  
 35119                                  ; 16/04/2019 - Retro DOS v4.0
 35120                                  
 35121                                  ;----------------------------------------------------------------------------
 35122                                  ;
 35123                                  ;   skip_token: advances ES:SI/CX past the current token
 35124                                  ;
 35125                                  ;   INPUT
 35126                                  ;    ES:SI -> position in config.sys
 35127                                  ;       CX == remaining bytes in config.sys
 35128                                  ;
 35129                                  ;   OUTPUT
 35130                                  ;       CF set if EOL/EOF hit
 35131                                  ;       AL == 1st char of delimiter
 35132                                  ;    ES:SI -> just past the delimiter
 35133                                  ;       CX == # bytes remaining from that point
 35134                                  ;
 35135                                  ;   OTHER REGS USED
 35136                                  ;       AX
 35137                                  ;
 35138                                  ;   NOTES
 35139                                  ;       None
 35140                                  ;
 35141                                  ;   HISTORY
 35142                                  ;       Created 16-Mar-1992 by JeffPar
 35143                                  ;
 35144                                  ;----------------------------------------------------------------------------
 35145                                  
 35146                                  skip_token:
 35147                                          call    get_char
 35148                                          jc	short skip_token_done
 35149                                          call    any_delim
 35150                                          jne	short skip_token
 35151                                  skip_check_eol:
 35152                                          cmp     al,cr ; 0Dh
 35153                                          je	short skip_token_eol
 35154                                          cmp     al,lf ; 0Ah
 35155                                          je	short skip_token_eol
 35156                                          clc
 35157                                          ;jmp	short skip_token_done
 35158                                  	retn
 35159                                  skip_token_eol:
 35160                                          stc
 35161                                  skip_token_done:
 35162                                          retn
 35163                                  
 35164                                  ;----------------------------------------------------------------------------
 35165                                  ;
 35166                                  ;   skip_delim: advances ES:SI/CX past the current delimiter
 35167                                  ;
 35168                                  ;   INPUT
 35169                                  ;    ES:SI -> position in config.sys
 35170                                  ;       CX == remaining bytes in config.sys
 35171                                  ;
 35172                                  ;   OUTPUT
 35173                                  ;       CF set if EOF hit
 35174                                  ;       AL == 1st char of token
 35175                                  ;    ES:SI -> just past the token
 35176                                  ;       CX == # bytes remaining from that point
 35177                                  ;    ES:BX -> new token (since ES:SI is already pointing 1 byte past token)
 35178                                  ;
 35179                                  ;   OTHER REGS USED
 35180                                  ;       AX
 35181                                  ;
 35182                                  ;   NOTES
 35183                                  ;       None
 35184                                  ;
 35185                                  ;   HISTORY
 35186                                  ;       Created 16-Mar-1992 by JeffPar
 35187                                  ;
 35188                                  ;----------------------------------------------------------------------------
 35189                                  
 35190                                  skip_delim:       ; returns carry set if eol/eof
 35191                                          call    get_char        ;
 35192                                          lea     bx,[si-1]       ; also returns BX -> next token
 35193                                          jc	short skip_token_done ;
 35194                                          call    delim           ;
 35195                                          je	short skip_delim ;
 35196                                          jmp	short skip_check_eol  ; 13/05/2019
 35197                                  
 35198                                  ;----------------------------------------------------------------------------
 35199                                  ;
 35200                                  ;   skip_opt_line: same as skip_line provided AL != LF
 35201                                  ;
 35202                                  ;   INPUT
 35203                                  ;       AL == last character read
 35204                                  ;    ES:SI -> position in config.sys
 35205                                  ;       CX == remaining bytes in config.sys
 35206                                  ;
 35207                                  ;   OUTPUT
 35208                                  ;       CF set if EOF hit
 35209                                  ;       AL == 1st char of new line
 35210                                  ;    ES:SI -> just past 1st char of new line
 35211                                  ;       CX == # bytes remaining from that point
 35212                                  ;
 35213                                  ;   OTHER REGS USED
 35214                                  ;       AX
 35215                                  ;
 35216                                  ;   NOTES
 35217                                  ;       In other words, the purpose here is to skip to the next line,
 35218                                  ;       unless ES:SI is already sitting at the front of the next line (which
 35219                                  ;       it would be if the last character fetched -- AL -- was a linefeed)
 35220                                  ;
 35221                                  ;   HISTORY
 35222                                  ;       Created 16-Mar-1992 by JeffPar
 35223                                  ;
 35224                                  ;----------------------------------------------------------------------------
 35225                                  
 35226                                  skip_opt_line:
 35227                                          cmp     al,lf ; 0Ah
 35228                                          je	short skip_line_done
 35229                                       
 35230                                  	; fall into skip_line
 35231                                  
 35232                                  ;----------------------------------------------------------------------------
 35233                                  ;
 35234                                  ;   skip_line: skip to the next line
 35235                                  ;
 35236                                  ;   INPUT
 35237                                  ;    ES:SI -> position in config.sys
 35238                                  ;       CX == remaining bytes in config.sys
 35239                                  ;
 35240                                  ;   OUTPUT
 35241                                  ;       CF set if EOF hit
 35242                                  ;    ES:SI -> just past 1st char of new line
 35243                                  ;       CX == # bytes remaining from that point
 35244                                  ;
 35245                                  ;   OTHER REGS USED
 35246                                  ;       AX
 35247                                  ;
 35248                                  ;   NOTES
 35249                                  ;       None
 35250                                  ;
 35251                                  ;   HISTORY
 35252                                  ;       Created 16-Mar-1992 by JeffPar
 35253                                  ;
 35254                                  ;----------------------------------------------------------------------------
 35255                                  
 35256                                  skip_line:
 35257                                          call    get_char
 35258                                          jc	short skip_line_done
 35259                                          cmp     al,lf ; 0Ah
 35260                                          jne	short skip_line
 35261                                  skip_line_done:
 35262                                  num_done:	; 18/12/2022
 35263                                          retn
 35264                                  
 35265                                  ;----------------------------------------------------------------------------
 35266                                  ;
 35267                                  ;   get_number: return binary equivalent of numeric string
 35268                                  ;
 35269                                  ;   INPUT
 35270                                  ;    ES:SI -> position in config.sys
 35271                                  ;       CX == remaining bytes in config.sys
 35272                                  ;
 35273                                  ;   OUTPUT
 35274                                  ;       AL == non-digit encountered
 35275                                  ;       BX == binary #
 35276                                  ;    ES:SI -> just past 1st non-digit
 35277                                  ;       CX == # bytes remaining from that point
 35278                                  ;
 35279                                  ;   OTHER REGS USED
 35280                                  ;       AX
 35281                                  ;
 35282                                  ;   NOTES
 35283                                  ;       None
 35284                                  ;
 35285                                  ;   HISTORY
 35286                                  ;       Created 16-Mar-1992 by JeffPar
 35287                                  ;
 35288                                  ;----------------------------------------------------------------------------
 35289                                  
 35290                                  ; 13/05/2019
 35291                                  
 35292                                  get_number:
 35293                                          sub     bx,bx           ; BX = result
 35294                                  num_loop:
 35295                                          call    get_char        ;
 35296                                          jc	short num_done	;
 35297                                          cmp     al,'0'          ; convert to value
 35298                                          jb	short num_done	; no more number
 35299                                          cmp     al,'9'          ;
 35300                                          ja	short num_done	;
 35301                                          push    ax              ;
 35302                                          mov     ax,10           ;
 35303                                          push    dx              ;
 35304                                          mul     bx              ;
 35305                                          pop     dx              ;
 35306                                          mov     bx,ax           ;
 35307                                          pop     ax              ;
 35308                                          sub     al,'0'          ;
 35309                                          cbw                     ;
 35310                                          add     bx,ax           ;
 35311                                          jmp	short num_loop	;
 35312                                  
 35313                                  	; 18/12/2022
 35314                                  ;num_done:
 35315                                          ;retn
 35316                                  
 35317                                  ;----------------------------------------------------------------------------
 35318                                  ;
 35319                                  ;   get_char:  return next character, advance ES:SI, and decrement CX
 35320                                  ;
 35321                                  ;   INPUT
 35322                                  ;    ES:SI -> position in config.sys
 35323                                  ;       CX == remaining bytes in config.sys
 35324                                  ;
 35325                                  ;   OUTPUT
 35326                                  ;       AL == next character
 35327                                  ;    ES:SI -> just past next character
 35328                                  ;       CX == # bytes remaining from that point
 35329                                  ;
 35330                                  ;   OTHER REGS USED
 35331                                  ;       AX
 35332                                  ;
 35333                                  ;   NOTES
 35334                                  ;       None
 35335                                  ;
 35336                                  ;   HISTORY
 35337                                  ;       Created 16-Mar-1992 by JeffPar
 35338                                  ;
 35339                                  ;----------------------------------------------------------------------------
 35340                                  
 35341                                  get_char:
 35342                                          sub     cx,1            ; use SUB to set carry,zero
 35343                                          jb	short get_fail	; out of data
 35344                                          ;lods	byte ptr es:[si] ;
 35345                                  	es	
 35346                                  	lodsb
 35347                                          mov     ah,al           ;
 35348                                          retn			;
 35349                                  get_fail:                       ; restore CX to zero
 35350                                          mov     cx,0            ; leave carry set, zero not set
 35351                                  nearby_ret:
 35352                                          retn
 35353                                  
 35354                                  ;----------------------------------------------------------------------------
 35355                                  ;
 35356                                  ;   query_user: ask user whether to execute current config.sys command
 35357                                  ;
 35358                                  ;   INPUT
 35359                                  ;       AL == current command code
 35360                                  ;    ES:SI -> current command line in config.sys
 35361                                  ;    config_cmd == current command code, but with QUERY bit intact
 35362                                  ;                  (00h used to generate "Process AUTOEXEC.BAT" prompt)
 35363                                  ;
 35364                                  ;   OUTPUT
 35365                                  ;       CF set if command should be ignored (it is also REM'ed out)
 35366                                  ;
 35367                                  ;   OTHER REGS USED
 35368                                  ;       BX, CX, DX, DI
 35369                                  ;
 35370                                  ;   NOTES
 35371                                  ;       None
 35372                                  ;
 35373                                  ;   HISTORY
 35374                                  ;       Created 16-Mar-1992 by JeffPar
 35375                                  ;
 35376                                  ;----------------------------------------------------------------------------
 35377                                  
 35378                                  	; 12/12/2022
 35379                                  query_user:
 35380                                          test    byte [bQueryOpt],4	; answer no to everything?
 35381                                          ;jz	short qu_1		;
 35382                                          ; 12/12/2022
 35383                                  	;jmp	short skip_all		;
 35384                                  	jnz	short skip_all
 35385                                  qu_1:
 35386                                  	test    byte [bQueryOpt],2	; answer yes to everything?
 35387                                          jnz	short nearby_ret	; yes (and return carry clear!)
 35388                                          push    ax                      ;
 35389                                          mov     al,[config_cmd]         ;
 35390                                          test    byte [bQueryOpt],1	; query every command?
 35391                                          jnz	short query_all		; yes
 35392                                          test    al,CONFIG_OPTION_QUERY  ;
 35393                                          ;jnz	short query_all		;
 35394                                          ; 12/12/2022
 35395                                  	;jmp	short do_cmd		;
 35396                                  	jz	short do_cmd ; cf=0
 35397                                  query_all:
 35398                                  
 35399                                  ;   Search for the command code (AL) in "comtab", and then print
 35400                                  ;   out the corresponding keyword, followed by the rest of the actual
 35401                                  ;   line pointed to by ES:SI
 35402                                  
 35403                                          push    si                      ; save pointer to rest of CONFIG.SYS line
 35404                                          mov     dx,_$AutoPrmpt    	;
 35405                                          and     al,~CONFIG_OPTION_QUERY ; 7Fh
 35406                                          jz	short generic_prompt	; config_cmd must have been 0
 35407                                  
 35408                                          mov     dh,al                   ; save config_cmd in DH
 35409                                          sub     bx,bx                   ;
 35410                                          mov     di,comtab		;
 35411                                  find_match:                             ;
 35412                                          mov     bl,[di]                 ; get size of current keyword
 35413                                          or      bl,bl                   ;
 35414                                          jz	short line_print	; end of table
 35415                                          inc     di                      ;
 35416                                          cmp     al,[di+bx]              ; match?
 35417                                          je	short cmd_match		; yes
 35418                                          lea     di,[di+bx+1]            ; otherwise, skip this command code
 35419                                  	; 13/05/2019	
 35420                                          jmp	short find_match	; loop
 35421                                  cmd_match:                              ;
 35422                                          mov     cl,[di-1]               ;
 35423                                          mov     ch,0                    ;
 35424                                          mov     ah,STD_CON_OUTPUT ; 2
 35425                                  cmd_print:                              ;
 35426                                          mov     al,[di]                 ;
 35427                                          inc     di                      ;
 35428                                          mov     dl,al                   ;
 35429                                          int     21h                     ;
 35430                                          loop    cmd_print               ;
 35431                                          mov     dl,'='                  ;
 35432                                          cmp     dh,CONFIG_SET  ; 'V'    ; for SET commands, don't display a '='
 35433                                          jne	short cmd_notset	;
 35434                                          mov     dl,' '                  ;
 35435                                  cmd_notset:
 35436                                          int     21h                     ; '=' looks funny on SET commands
 35437                                  line_print:                             ;
 35438                                  	;lods	byte ptr es:[si]        ;
 35439                                          es
 35440                                  	lodsb
 35441                                  	or      al,al                   ;
 35442                                          jnz	short non_null		;
 35443                                          mov     al,' '                  ;
 35444                                  non_null:                               ;
 35445                                          cmp     al,' '                  ; control code?
 35446                                          jb	short prompt_user	; yes, assume end of line
 35447                                          jne	short non_space		;
 35448                                          cmp     byte [es:si],' '	;
 35449                                          jb	short prompt_user	;
 35450                                  non_space:                              ;
 35451                                          mov     dl,al                   ;
 35452                                          mov     ah,STD_CON_OUTPUT ; 2	;
 35453                                          int     21h                     ;
 35454                                          jmp	short line_print	;
 35455                                  prompt_user:                            ;
 35456                                          mov     dx,_$InterPrmpt		;
 35457                                  
 35458                                  generic_prompt:
 35459                                          call    print                   ;
 35460                                  input_loop:                             ;
 35461                                          mov     ah,0                    ; read a key
 35462                                          int     16h                     ;
 35463                                          or      al,al                   ; is it a function key?
 35464                                          jnz	short not_func		; no
 35465                                          cmp     ah,3Fh                  ; F5 function key?
 35466                                          jne	short input_loop	; no
 35467                                          mov     al,[_$NO]                  ;
 35468                                          or      byte [bQueryOpt],4	; no more queries
 35469                                          jmp     short legal_char        ;
 35470                                  not_func:
 35471                                          and     al,~20h ; 0DFh		; converting to upper case
 35472                                          cmp     al,[_$NO]		; verify character is legal
 35473                                          je	short legal_char	;
 35474                                          cmp     al,[_$YES]		;
 35475                                          je	short legal_char	;
 35476                                          cmp     byte [config_cmd],0	;
 35477                                          je	short input_loop	; don't allow Esc on this query
 35478                                          cmp     al,1Bh                  ; Esc?
 35479                                          jne	short input_loop	;
 35480                                          or      byte [bQueryOpt],2	; no more interactive boot prompts
 35481                                          mov     al,[_$YES]
 35482                                  legal_char:                             ;
 35483                                          call    disp_input              ;
 35484                                          pop     si                      ; restore pointer to rest of CONFIG.SYS line
 35485                                  
 35486                                          cmp     al,[_$NO]		; process line?
 35487                                          je	short skip_cmd		; no
 35488                                  	; 12/12/2022
 35489                                  	clc
 35490                                  do_cmd:
 35491                                  	pop     ax			;
 35492                                  	; 12/12/2022
 35493                                  	; cf=0
 35494                                  	;clc				; just do the command
 35495                                  	retn
 35496                                  
 35497                                  skip_cmd:
 35498                                  	pop     ax			;
 35499                                  skip_all:
 35500                                  	mov     ah,CONFIG_REM ; '0'	; fake out the rest of sysinit's processing
 35501                                  	stc
 35502                                  	retn
 35503                                  
 35504                                  ;----------------------------------------------------------------------------
 35505                                  ;
 35506                                  ;   print_error: displays multi-config error conditions
 35507                                  ;
 35508                                  ;   INPUT
 35509                                  ;    Carry set to pause, clear to not
 35510                                  ;    ES:SI -> current command line in config.sys
 35511                                  ;
 35512                                  ;   OUTPUT
 35513                                  ;       None
 35514                                  ;
 35515                                  ;   OTHER REGS USED
 35516                                  ;       None
 35517                                  ;
 35518                                  ;   NOTES
 35519                                  ;       None
 35520                                  ;
 35521                                  ;   HISTORY
 35522                                  ;       Created 16-Mar-1992 by JeffPar
 35523                                  ;
 35524                                  ;----------------------------------------------------------------------------
 35525                                  
 35526                                  print_error:
 35527                                          push    ax
 35528                                          push    bx
 35529                                          push    cx
 35530                                          push    dx
 35531                                          push    ds
 35532                                          push    cs
 35533                                          pop     ds
 35534                                          pushf
 35535                                          call    get_linenum
 35536                                          mov     [linecount],bx
 35537                                          call    error_line
 35538                                          popf
 35539                                          jnc	short pe_ret
 35540                                          mov     dx,_$PauseMsg
 35541                                          call    print
 35542                                          mov     ax,0C07h		; flush input buffer, then wait for key
 35543                                          int     21h			; wait for a key
 35544                                          or      al,al			; extended key?
 35545                                          jnz	short pe_1		; no
 35546                                          mov     ah,07h			; yes
 35547                                          int     21h			; eat it too
 35548                                  pe_1:     
 35549                                  	mov     dx,crlfm
 35550                                          call    print
 35551                                  pe_ret: 
 35552                                  	pop     ds
 35553                                          pop     dx
 35554                                          pop     cx
 35555                                          pop     bx
 35556                                          pop     ax
 35557                                  	retn
 35558                                  
 35559                                  ;----------------------------------------------------------------------------
 35560                                  
 35561                                  ;   This function is very simple:  it merely prepends a "/D" to the
 35562                                  ;   command-line for the shell;  this (undocumented) switch disables
 35563                                  ;   AUTOEXEC.BAT processing and the date/time prompt that is usually
 35564                                  ;   displayed when there's no AUTOEXEC.BAT.
 35565                                  
 35566                                  disable_autoexec:
 35567                                  	; MSDOS 6.21 IO.SYS -  SYSINIT:4BE2h
 35568                                  	; 17/04/2019 - Retro DOS v4.0
 35569                                  
 35570                                  	test	byte [bQueryOpt],4
 35571                                  	jz	short disable_exit
 35572                                  	test	byte [dae_flag],1
 35573                                  	jnz	short disable_exit
 35574                                  	or	byte [dae_flag],1
 35575                                          ;or	byte [bQueryOpt],2 ; MSDOS 6.0 
 35576                                  	or      word [bQueryOpt],102h	; [bDefBlock] = 1
 35577                                  	mov     dx,'D ' ; 2044h
 35578                                  dae_1:
 35579                                          ;mov	al,[def_swchr]
 35580                                  	mov     al,[command_line-1]     ; get default switchchar
 35581                                          or      al,al                   ; anything there?
 35582                                          jz	short disable_exit	; no, disable_autoexec already called
 35583                                          mov     bl,[command_line]       ;
 35584                                          mov     bh,0                    ; BX == command-line length
 35585                                          mov     cx,bx                   ;
 35586                                          add     bl,3                    ;
 35587                                          cmp     bl,126                  ;
 35588                                          ja	short disable_exit	;
 35589                                          mov     [command_line],bl       ; update length
 35590                                          add     bx,command_line+1	; make sure we move the NULL too
 35591                                          inc     cx                      ; (just for consistency sake)
 35592                                  disable_loop:                           ;
 35593                                          mov     ah,[bx-3]               ;
 35594                                          mov     [bx],ah                 ;
 35595                                          dec     bx                      ;
 35596                                          loop    disable_loop            ;
 35597                                          mov     [bx-2],al               ;
 35598                                  	;mov	word [bx-1],'D ' ; 2044h ; /D is stuffed into place now
 35599                                  	mov	[bx-1],dx  ; MSDOS 6.21 IO.SYS - SYSINIT:4C29h		
 35600                                          ;mov	byte [command_line-1],0 ;
 35601                                  disable_exit:                           ;
 35602                                          retn
 35603                                  
 35604                                  CheckQueryOpt:	; MSDOS 6.21 IO.YSYS - SYSINIT:4C2Dh
 35605                                  	cmp     byte [bQueryOpt],1
 35606                                  	jnz     short disable_exit
 35607                                  	test	byte [dae_flag],2
 35608                                  	jnz     short disable_exit
 35609                                  	or      byte [dae_flag],2
 35610                                  	mov     dx,'Y ' ; 2059h ; 11/09/2023
 35611                                  	jmp     short dae_1
 35612                                  
 35613                                  ;endif  ;MULTI_CONFIG
 35614                                  
 35615                                  %endif	; 02/11/2022
 35616                                  
 35617                                  
 35618                                  ; 19/04/2019 - Retro DOS v4.0
 35619                                  
 35620                                  ;----------------------------------------------------------------------------
 35621                                  ;
 35622                                  ; procedure : delim
 35623                                  ;
 35624                                  ;----------------------------------------------------------------------------
 35625                                  
 35626                                  ;	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 35627                                  ;
 35628                                  ;;ifdef	MULTI_CONFIG
 35629                                  ;
 35630                                  ;any_delim:
 35631                                  ;       cmp     al,cr
 35632                                  ;       je	short delim_ret
 35633                                  ;       cmp     al,lf
 35634                                  ;       je	short delim_ret
 35635                                  ;       cmp     al,'['
 35636                                  ;       je	short delim_ret
 35637                                  ;       cmp     al,']'
 35638                                  ;       je	short delim_ret
 35639                                  ;
 35640                                  ;;endif  ;MULTI_CONFIG
 35641                                  
 35642                                  	; 02/11/2022 - Retrodos v4.0 (Modified MSDOS 5.0 IO.SYS)
 35643                                  	; (SYSINIT:3450h)	
 35644                                  delim:
 35645 00003079 3C2F                    	cmp	al,'/'		; ibm will assume "/" as an delimeter.
 35646 0000307B 7416                    	je	short delim_ret
 35647                                  
 35648 0000307D 3C00                    	cmp	al,0		; special case for sysinit!!!
 35649 0000307F 7412                    	je	short delim_ret
 35650                                  
 35651                                  org_delim:			; used by organize routine except for getting
 35652 00003081 3C20                    	cmp	al,' '          ; the filename.
 35653 00003083 740E                    	je	short delim_ret
 35654 00003085 3C09                            cmp     al,tab ; 9
 35655 00003087 740A                    	je	short delim_ret
 35656 00003089 3C3D                    	cmp	al,'='
 35657 0000308B 7406                    	je	short delim_ret
 35658 0000308D 3C2C                    	cmp	al,','
 35659 0000308F 7402                    	je	short delim_ret
 35660 00003091 3C3B                    	cmp	al,';'
 35661                                  
 35662                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 35663                                  ;;ifdef	MULTI_CONFIG
 35664                                  ;;   Make sure there's no chance of a false EOF indication
 35665                                  ;	clc
 35666                                  ;;endif
 35667                                  
 35668                                  	; 02/11/2022
 35669                                  delim_ret:
 35670 00003093 C3                      	retn
 35671                                  
 35672                                  ;----------------------------------------------------------------------------
 35673                                  ;
 35674                                  ; procedure : newline
 35675                                  ;
 35676                                  ;  newline returns with first character of next line
 35677                                  ;
 35678                                  ;----------------------------------------------------------------------------
 35679                                  
 35680                                  newline:
 35681 00003094 E898F6                  	call	getchr			;skip non-control characters
 35682 00003097 7207                    	jc	short nl_ret
 35683 00003099 3C0A                    	cmp	al,lf			;look for line feed
 35684 0000309B 75F7                    	jne	short newline
 35685 0000309D E88FF6                  	call	getchr
 35686                                  nl_ret:
 35687 000030A0 C3                      	retn
 35688                                  
 35689                                  ;----------------------------------------------------------------------------
 35690                                  ; 
 35691                                  ; procedure : mapcase
 35692                                  ;
 35693                                  ;----------------------------------------------------------------------------
 35694                                  
 35695                                  	; 02/11/2022 - Retro DOS 4.0 (Modified MSDOS 5.0 IO.SYS)
 35696                                  mapcase:
 35697 000030A1 51                      	push	cx
 35698 000030A2 56                      	push	si
 35699 000030A3 1E                      	push	ds
 35700                                  
 35701 000030A4 06                      	push	es
 35702 000030A5 1F                      	pop	ds
 35703                                  
 35704                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 35705                                  ;;ifdef	MULTI_CONFIG
 35706                                  ;
 35707                                  ;	mov	bl,al                   ; same cmd code this line
 35708                                  ;;else
 35709                                  ;;	xor	si,si
 35710                                  ;;endif
 35711                                  	; 02/11/2022
 35712 000030A6 31F6                    	xor	si, si
 35713                                  
 35714                                  convloop:
 35715 000030A8 AC                      	lodsb
 35716 000030A9 3C61                    	cmp	al,'a'
 35717 000030AB 7209                    	jb	short noconv
 35718 000030AD 3C7A                    	cmp	al,'z'
 35719 000030AF 7705                    	ja	short noconv
 35720 000030B1 2C20                    	sub	al,20h
 35721 000030B3 8844FF                  	mov	[si-1],al
 35722                                  noconv:
 35723                                  
 35724                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 35725                                  ;;ifdef	MULTI_CONFIG
 35726                                  ;;
 35727                                  ;;   When MULTI_CONFIG enabled, "mapcase" is used to map everything to
 35728                                  ;;   upper-case a line at a time, after we've been able to figure out whether
 35729                                  ;;   the line is a SET command or not (since we don't want to upper-case
 35730                                  ;;   anything after the "=" in a SET)
 35731                                  ;;
 35732                                  ;       cmp     bl,CONFIG_SET  ; 'V'	; preserve case for part of the line?
 35733                                  ;       jne	short check_eol		; no, just check for end-of-line
 35734                                  ;       cmp     al,'='                  ; separator between SET var and value?
 35735                                  ;       je	short convdone		; yes
 35736                                  ;check_eol:
 35737                                  ;       cmp     al,cr
 35738                                  ;       je	short convdone
 35739                                  ;       cmp     al,lf
 35740                                  ;       je	short convdone
 35741                                  ;;endif
 35742                                  	
 35743                                  	; 02/11/2022
 35744 000030B6 E2F0                    	loop	convloop
 35745                                  convdone:
 35746 000030B8 1F                      	pop	ds
 35747 000030B9 5E                      	pop	si
 35748 000030BA 59                      	pop	cx
 35749 000030BB C3                      	retn
 35750                                  
 35751                                  ;----------------------------------------------------------------------------
 35752                                  ;
 35753                                  ; procedure : round
 35754                                  ;
 35755                                  ; round the values in memlo and memhi to paragraph boundary.
 35756                                  ; perform bounds check.
 35757                                  ;
 35758                                  ;----------------------------------------------------------------------------
 35759                                  
 35760                                  round:
 35761 000030BC 50                      	push	ax
 35762 000030BD 2EA1[DE03]              	mov	ax,[cs:memlo]
 35763                                  
 35764 000030C1 E8F5DF                  	call	ParaRound		; para round up
 35765                                  
 35766 000030C4 2E0106[E003]            	add	[cs:memhi],ax
 35767 000030C9 2EC706[DE03]0000        	mov	word [cs:memlo],0
 35768 000030D0 2EA1[E003]              	mov	ax,[cs:memhi]		; ax = new memhi
 35769 000030D4 2E3B06[A302]            	cmp	ax,[cs:ALLOCLIM]	; if new memhi >= alloclim, error
 35770 000030D9 7322                    	jae	short mem_err
 35771 000030DB 2EF606[2E14]02          	test	byte [cs:setdevmarkflag],for_devmark ; 2
 35772 000030E1 7418                    	jz	short skip_set_devmarksize
 35773 000030E3 06                      	push	es
 35774 000030E4 56                      	push	si
 35775 000030E5 2E8B36[2C14]            	mov	si,[cs:devmark_addr]
 35776 000030EA 8EC6                    	mov	es,si
 35777 000030EC 29F0                    	sub	ax,si
 35778 000030EE 48                      	dec	ax
 35779                                  	;mov	[es:3],ax
 35780 000030EF 26A30300                	mov	[es:devmark.size],ax	; paragraph
 35781 000030F3 2E8026[2E14]FD          	and	byte [cs:setdevmarkflag],not_for_devmark ; 0FDh
 35782 000030F9 5E                      	pop	si
 35783 000030FA 07                      	pop	es
 35784                                  skip_set_devmarksize:
 35785 000030FB 58                      	pop	ax
 35786                                  	; 11/12/2022
 35787                                  	; cf = 0
 35788                                  	; 02/11/2022
 35789                                  	;clc	; ? (not needed here)	; clear carry
 35790 000030FC C3                      	retn
 35791                                  
 35792                                  ;----------------------------------------------------------------------------
 35793                                  
 35794                                  mem_err:
 35795                                  	; 11/12/2022
 35796 000030FD 0E                      	push	cs
 35797 000030FE 1F                      	pop	ds
 35798                                  mem_err2:
 35799 000030FF BA[9D38]                	mov	dx,badmem
 35800                                  	;push	cs
 35801                                  	;pop	ds
 35802 00003102 E87602                  	call	print
 35803 00003105 E945D7                  	jmp	stall
 35804                                  
 35805                                  ;----------------------------------------------------------------------------
 35806                                  ;
 35807                                  ; procedure : calldev
 35808                                  ;
 35809                                  ;----------------------------------------------------------------------------
 35810                                  
 35811                                  	; 02/11/2022 - Retrodos v4.0 (Modified MSDOS 5.0 IO.SYS)
 35812                                  	; (SYSINIT:34E0h)
 35813                                  calldev:
 35814 00003108 2E8E1E[E61E]            	mov	ds,[cs:DevEntry+2]
 35815 0000310D 2E031E[E41E]            	add	bx,[cs:DevEntry]	; do a little relocation
 35816 00003112 8B07                    	mov	ax,[bx]
 35817                                  
 35818 00003114 2EFF36[E41E]            	push	word [cs:DevEntry]
 35819 00003119 2EA3[E41E]              	mov	word [cs:DevEntry],ax
 35820 0000311D BB[E603]                	mov	bx,packet
 35821 00003120 2EFF1E[E41E]            	call	far [cs:DevEntry]
 35822 00003125 2E8F06[E41E]            	pop	word [cs:DevEntry]
 35823 0000312A C3                      	retn
 35824                                  
 35825                                  ;----------------------------------------------------------------------------
 35826                                  ;
 35827                                  ; procedure : todigit
 35828                                  ;
 35829                                  ;----------------------------------------------------------------------------
 35830                                  
 35831                                  todigit:
 35832 0000312B 2C30                    	sub	al,'0'
 35833                                  	;jb	short notdig  ; 02/11/2022
 35834                                  	; 12/12/2022
 35835 0000312D 7203                    	jb	short notdig2
 35836                                  	;cmp	al,9
 35837                                  	;ja	short notdig
 35838                                  	;clc
 35839                                  	;retn
 35840                                  	; 12/12/2022
 35841 0000312F 3C0A                    	cmp	al,10
 35842 00003131 F5                      	cmc
 35843                                  notdig:
 35844                                  	;stc
 35845                                  notdig2:
 35846 00003132 C3                      	retn
 35847                                  
 35848                                  ;----------------------------------------------------------------------------
 35849                                  ;
 35850                                  ; procedure : getnum
 35851                                  ;
 35852                                  ; getnum parses a decimal number.
 35853                                  ; returns it in ax, sets zero flag if ax = 0 (may be considered an
 35854                                  ; error), if number is bad carry is set, zero is set, ax=0.
 35855                                  ;
 35856                                  ;----------------------------------------------------------------------------
 35857                                  
 35858                                  getnum:
 35859 00003133 53                      	push	bx
 35860 00003134 31DB                    	xor	bx,bx			; running count is zero
 35861                                  b2:
 35862 00003136 E8F2FF                  	call	todigit 		; do we have a digit ?
 35863 00003139 7247                    	jc	short badnum		; no, bomb
 35864                                  
 35865 0000313B 93                      	xchg	ax,bx			; put total in ax
 35866 0000313C 53                      	push	bx			; save digit (0 to 9)
 35867                                  	;mov	bx,10			; base of arithmetic
 35868                                  	; 12/12/2022
 35869 0000313D B30A                    	mov	bl,10
 35870 0000313F F7E3                    	mul	bx			; shift by one decimal digit
 35871 00003141 5B                      	pop	bx			; get back digit (0 to 9)
 35872 00003142 00D8                    	add	al,bl			; get total
 35873 00003144 80D400                  	adc	ah,0			; make that 16 bits
 35874 00003147 7239                    	jc	short badnum		; too big a number
 35875                                  
 35876 00003149 93                      	xchg	ax,bx			; stash total
 35877                                  
 35878 0000314A E8E2F5                  	call	getchr			;get next digit
 35879 0000314D 722D                    	jc	short b1		; no more characters
 35880 0000314F 3C20                    	cmp	al,' ' 			; space?
 35881 00003151 741F                    	je	short b15		; then end of digits
 35882 00003153 3C2C                    	cmp	al,',' 			; ',' is a seperator!!!
 35883 00003155 741B                    	je	short b15		; then end of digits.
 35884 00003157 3C09                    	cmp	al, tab ; 9		; tab
 35885 00003159 7417                    	je	short b15
 35886 0000315B 2E3A06[2A03]            	cmp	al,[cs:sepchr]		; allow 0 or special separators
 35887 00003160 7410                    	je	short b15
 35888 00003162 3C2F                    	cmp	al,'/'			; see if another switch follows
 35889                                  	;nop				; cas - remnant of old bad code
 35890                                  	;nop
 35891                                  	; 12/12/2022
 35892                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 35893                                  	;nop
 35894                                  	;nop
 35895 00003164 740C                    	je	short b15
 35896 00003166 3C0A                    	cmp	al,lf			; line-feed?
 35897 00003168 7408                    	je	short b15
 35898 0000316A 3C0D                    	cmp	al,cr			; carriage return?
 35899 0000316C 7404                    	je	short b15
 35900 0000316E 08C0                    	or	al,al			; end of line separator?
 35901 00003170 75C4                    	jnz	short b2		; no, try as a valid char...
 35902                                  b15:
 35903 00003172 2EFF06[D203]            	inc	word [cs:count]		; one more character to s...
 35904 00003177 2EFF0E[D603]            	dec	word [cs:chrptr]	; back up over separator
 35905                                  b1:
 35906 0000317C 89D8                    	mov	ax,bx			; get proper count
 35907 0000317E 09C0                    	or	ax,ax			; clears carry, sets zero accordingly
 35908 00003180 5B                      	pop	bx
 35909 00003181 C3                      	retn
 35910                                  badnum:
 35911                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 35912                                  	;mov	byte [cs:sepchr],0
 35913 00003182 31C0                    	xor	ax,ax			; set zero flag, and ax = 0
 35914                                  	; 12 /12/2022
 35915 00003184 2EA2[2A03]              	mov	[cs:sepchr],al ; 0
 35916 00003188 5B                      	pop	bx
 35917 00003189 F9                      	stc				; and carry set
 35918 0000318A C3                      	retn
 35919                                  
 35920                                  ;****************************************************************************
 35921                                  
 35922                                  setdoscountryinfo:
 35923                                  
 35924                                  ;----------------------------------------------------------------------------
 35925                                  ;input: es:di -> pointer to dos_country_cdpg_info
 35926                                  ;	ds:0  -> buffer.
 35927                                  ;	si = 0
 35928                                  ;	ax = country id
 35929                                  ;	dx = code page id. (if 0, then use ccsyscodepage as a default.)
 35930                                  ;	bx = file handle
 35931                                  ;	this routine can handle maximum 438 country_data entries.
 35932                                  ;
 35933                                  ;output: dos_country_cdpg_info set.
 35934                                  ;	 carry set if any file read failure or wrong information in the file.
 35935                                  ;	 carry set and cx = -1 if cannot find the matching country_id, 
 35936                                  ;	 codepage_id in the file.
 35937                                  ;----------------------------------------------------------------------------
 35938                                  
 35939 0000318B 57                      	push	di
 35940 0000318C 50                      	push	ax
 35941 0000318D 52                      	push	dx
 35942                                  
 35943 0000318E 31C9                    	xor	cx,cx
 35944 00003190 31D2                    	xor	dx,dx
 35945 00003192 B80002                  	mov	ax,512			;read 512 bytes
 35946 00003195 E84F01                  	call	readincontrolbuffer	;read the file header
 35947 00003198 724D                    	jc	short setdosdata_fail
 35948                                  
 35949 0000319A 06                      	push	es
 35950 0000319B 56                      	push	si
 35951                                  
 35952 0000319C 0E                      	push	cs
 35953 0000319D 07                      	pop	es
 35954                                  
 35955 0000319E BF[BF34]                	mov	di,country_file_signature ; db 0FFh,'COUNTRY'
 35956 000031A1 B90800                  	mov	cx,8			;length of the signature
 35957 000031A4 F3A6                    	repz	cmpsb
 35958                                  
 35959 000031A6 5E                      	pop	si
 35960 000031A7 07                      	pop	es
 35961 000031A8 753D                    	jnz	short setdosdata_fail 	;signature mismatch
 35962                                  
 35963 000031AA 83C612                  	add	si,18			;si -> county info type
 35964 000031AD 803C01                  	cmp	byte [si],1		;only accept type 1 (currently only 1 header type)
 35965 000031B0 7535                    	jne	short setdosdata_fail 	;cannot proceed. error return
 35966                                  
 35967 000031B2 46                      	inc	si			;si -> file offset
 35968 000031B3 8B14                    	mov	dx,[si]			;get the info file offset.
 35969 000031B5 8B4C02                  	mov	cx,[si+2]
 35970 000031B8 B80018                  	mov	ax,6144			;read 6144 bytes.
 35971 000031BB E82901                  	call	readincontrolbuffer	;read info
 35972 000031BE 7227                    	jc	short setdosdata_fail
 35973                                  
 35974 000031C0 8B0C                    	mov	cx,[si]			;get the # of country, codepage combination entries
 35975 000031C2 81F9B601                	cmp	cx, 438			;cannot handle more than 438 entries.
 35976 000031C6 771F                    	ja	short setdosdata_fail
 35977                                  
 35978 000031C8 46                      	inc	si
 35979 000031C9 46                      	inc	si			;si -> entry information packet
 35980 000031CA 5A                      	pop	dx			;restore code page id
 35981 000031CB 58                      	pop	ax			;restore country id
 35982 000031CC 5F                      	pop	di
 35983                                  
 35984                                  setdoscntry_find:			;search for desired country_id,codepage_id.
 35985 000031CD 3B4402                  	cmp	ax,[si+2]		;compare country_id
 35986 000031D0 750A                    	jne	short setdoscntry_next
 35987                                  
 35988 000031D2 83FA00                  	cmp	dx,0			;no user specified code page ?
 35989 000031D5 7415                    	je	short setdoscntry_any_codepage ;then no need to match code page id.
 35990 000031D7 3B5404                  	cmp	dx,[si+4]		;compare code page id
 35991 000031DA 7413                    	je	short setdoscntry_got_it
 35992                                  
 35993                                  setdoscntry_next:
 35994 000031DC 0334                    	add	si,[si]			;next entry
 35995 000031DE 46                      	inc	si
 35996 000031DF 46                      	inc	si			;take a word for size of entry itself
 35997 000031E0 E2EB                    	loop	setdoscntry_find
 35998                                  
 35999 000031E2 B9FFFF                  	mov	cx,-1			;signals that bad country id entered.
 36000                                  setdoscntry_fail:
 36001 000031E5 F9                      	stc
 36002 000031E6 C3                      	retn
 36003                                  
 36004                                  setdosdata_fail:
 36005 000031E7 5E                      	pop	si
 36006 000031E8 59                      	pop	cx
 36007 000031E9 5F                      	pop	di
 36008 000031EA EBF9                    	jmp	short setdoscntry_fail
 36009                                  
 36010                                  setdoscntry_any_codepage:		;use the code_page_id of the country_id found.
 36011 000031EC 8B5404                  	mov	dx,[si+4]
 36012                                  
 36013                                  setdoscntry_got_it:			;found the matching entry
 36014 000031EF 2E8916[C734]            	mov	[cs:cntrycodepage_id],dx ;save code page id for this country.
 36015 000031F4 8B540A                  	mov	dx,[si+10]		;get the file offset of country data
 36016 000031F7 8B4C0C                  	mov	cx,[si+12]
 36017 000031FA B80002                  	mov	ax,512 			;read 512 bytes
 36018 000031FD E8E700                  	call	readincontrolbuffer
 36019 00003200 72E3                    	jc	short setdoscntry_fail
 36020                                  
 36021 00003202 8B0C                    	mov	cx,[si]			;get the number of entries to handle.
 36022 00003204 46                      	inc	si
 36023 00003205 46                      	inc	si			;si -> first entry
 36024                                  
 36025                                  setdoscntry_data:
 36026 00003206 57                      	push	di			;es:di -> dos_country_cdpg_info
 36027 00003207 51                      	push	cx			;save # of entry left
 36028 00003208 56                      	push	si			;si -> current entry in control buffer
 36029                                  
 36030 00003209 8A4402                  	mov	al,[si+2]		;get data entry id
 36031 0000320C E8AA00                  	call	getcountrydestination	;get the address of destination in es:di
 36032 0000320F 727D                    	jc	short setdoscntry_data_next ;no matching data entry id in dos
 36033                                  
 36034 00003211 8B5404                  	mov	dx,[si+4]		;get offset of data
 36035 00003214 8B4C06                  	mov	cx,[si+6]
 36036 00003217 B80042                  	mov	ax,4200h
 36037 0000321A F9                      	stc
 36038 0000321B CD21                    	int	21h			;move pointer
 36039 0000321D 72C8                    	jc	short setdosdata_fail
 36040                                  
 36041 0000321F BA0002                  	mov	dx,512			;start of data buffer
 36042 00003222 B91400                  	mov	cx,20			;read 20 bytes only. we only need to
 36043 00003225 B43F                    	mov	ah,3Fh			;look at the length of the data in the file.
 36044 00003227 F9                      	stc
 36045 00003228 CD21                    	int	21h			;read the country.sys data
 36046 0000322A 72BB                    	jc	short setdosdata_fail 	;read failure
 36047                                  
 36048 0000322C 39C8                    	cmp	ax,cx
 36049 0000322E 75B7                    	jne	short setdosdata_fail ; 13/05/2019
 36050                                  
 36051 00003230 8B5404                  	mov	dx,[si+4]		;get offset of data again.
 36052 00003233 8B4C06                  	mov	cx,[si+6]
 36053 00003236 B80042                  	mov	ax,4200h
 36054 00003239 F9                      	stc
 36055 0000323A CD21                    	int	21h			;move pointer back again
 36056 0000323C 72A9                    	jc	short setdosdata_fail
 36057                                  
 36058 0000323E 56                      	push	si
 36059 0000323F BE0802                  	mov	si,(512+8)		;get length of the data from the file
 36060 00003242 8B0C                    	mov	cx,[si]
 36061 00003244 5E                      	pop	si
 36062 00003245 BA0002                  	mov	dx,512			;start of data buffer
 36063 00003248 83C10A                  	add	cx,10			;signature + a word for the length itself
 36064 0000324B B43F                    	mov	ah,3Fh			;read the data from the file.
 36065 0000324D F9                      	stc
 36066 0000324E CD21                    	int	21h
 36067 00003250 7295                    	jc	short setdosdata_fail
 36068                                  
 36069 00003252 39C8                    	cmp	ax,cx
 36070 00003254 7591                    	jne	short setdosdata_fail
 36071                                  
 36072 00003256 8A4402                  	mov	al,[si+2]		;save data id for future use.
 36073 00003259 BE0802                  	mov	si,(512+8)		;si-> data buffer + id tag field
 36074 0000325C 8B0C                    	mov	cx,[si]			;get the length of the file
 36075 0000325E 41                      	inc	cx			;take care of a word for lenght of tab
 36076 0000325F 41                      	inc	cx			;itself.
 36077 00003260 81F9F805                	cmp	cx,(2048-512-8)	; 1528	;fit into the buffer?
 36078 00003264 7781                    	ja	short setdosdata_fail
 36079                                  
 36080                                  	;if	bugfix
 36081 00003266 E83500                  	call	setdbcs_before_copy
 36082                                  	;endif
 36083                                  
 36084 00003269 3C01                    	cmp	al,SetCountryInfo ; 1	;is the data for setcountryinfo table?
 36085 0000326B 7512                    	jne	short setdoscntry_mov 	;no, don't worry
 36086                                  
 36087 0000326D 26FF7518                	push	word [es:di+country_cdpg_info.ccMono_Ptr-country_cdpg_info.ccCountryInfoLen]  
 36088                                  	;push	word [es:di+24]		;cannot destroy ccmono_ptr address. save them.
 36089 00003271 26FF751A                	push	word [es:di+country_cdpg_info.ccMono_Ptr-country_cdpg_info.ccCountryInfoLen+2] 
 36090                                  	;push	word [es:di+26]		;at this time di -> cccountryinfolen
 36091                                  	
 36092 00003275 57                      	push	di			;save di
 36093                                  
 36094 00003276 50                      	push	ax
 36095 00003277 2EA1[C734]              	mov	ax,[cs:cntrycodepage_id] ;do not use the code page info in country_info
 36096 0000327B 894404                  	mov	[si+4],ax		;use the saved one for this !!!!
 36097 0000327E 58                      	pop	ax
 36098                                  
 36099                                  setdoscntry_mov:
 36100 0000327F F3A4                    	rep	movsb			;copy the table into dos
 36101 00003281 3C01                    	cmp	al,SetCountryInfo	;was the ccmono_ptr saved?
 36102 00003283 7509                    	jne	short setdoscntry_data_next
 36103                                  
 36104 00003285 5F                      	pop	di			;restore di
 36105 00003286 268F451A                	pop	word [es:di+country_cdpg_info.ccMono_Ptr-country_cdpg_info.ccCountryInfoLen+2]
 36106                                  	;pop	word [es:di+26]		;restore
 36107 0000328A 268F4518                	pop	word [es:di+country_cdpg_info.ccMono_Ptr-country_cdpg_info.ccCountryInfoLen] 
 36108                                  	;pop	word [es:di+24]
 36109                                  
 36110                                  setdoscntry_data_next:
 36111 0000328E 5E                      	pop	si			;restore control buffer pointer
 36112 0000328F 59                      	pop	cx			;restore # of entries left
 36113 00003290 5F                      	pop	di			;restore pointer to dso_country_cdpg
 36114 00003291 0334                    	add	si,[si]			;try to get the next entry
 36115 00003293 46                      	inc	si
 36116 00003294 46                      	inc	si			;take a word of entry length itself
 36117 00003295 49                      	dec	cx
 36118 00003296 83F900                  	cmp	cx,0
 36119 00003299 741D                    	je	short setdoscntry_ok
 36120 0000329B E968FF                  	jmp	setdoscntry_data
 36121                                  
 36122                                  	; 18/12/2022
 36123                                  ;setdoscntry_ok:
 36124                                  	;retn
 36125                                  
 36126                                  ;----------------------------------------------------------------------------
 36127                                  
 36128                                  	;if	bugfix
 36129                                  
 36130                                  setdbcs_before_copy:
 36131 0000329E 3C07                    	cmp	al,SetDBCS ; 7		; dbcs vector set?
 36132 000032A0 7516                    	jne	short sdbcsbc		; jump if not
 36133 000032A2 26833D00                	cmp	word [es:di],0		; zero byte data block?
 36134 000032A6 7410                    	je	short sdbcsbc		; jump if so
 36135                                  
 36136 000032A8 57                      	push	di
 36137 000032A9 50                      	push	ax
 36138 000032AA 51                      	push	cx
 36139 000032AB 268B0D                  	mov	cx,[es:di]		; load block length
 36140 000032AE 83C702                  	add	di,2			; points actual data
 36141 000032B1 30C0                    	xor	al,al			; fill bytes
 36142 000032B3 F3AA                    	rep	stosb			; clear data block
 36143 000032B5 59                      	pop	cx
 36144 000032B6 58                      	pop	ax
 36145 000032B7 5F                      	pop	di
 36146                                  sdbcsbc:
 36147                                  setdoscntry_ok:	; 18/12/2022	
 36148 000032B8 C3                      	retn
 36149                                  
 36150                                  	;endif
 36151                                  
 36152                                  ;----------------------------------------------------------------------------
 36153                                  
 36154                                  getcountrydestination:
 36155                                  
 36156                                  ;get the destination address in the dos country info table.
 36157                                  ;input: al - data id
 36158                                  ;	es:di -> dos_country_cdpg_info
 36159                                  ;on return:
 36160                                  ;	es:di -> destination address of the matching data id
 36161                                  ;	carry set if no matching data id found in dos.
 36162                                  
 36163 000032B9 51                      	push	cx
 36164                                  	;add	di,74
 36165 000032BA 83C74A                  	add	di,country_cdpg_info.ccNumber_of_entries	
 36166                                  					;skip the reserved area, syscodepage etc.
 36167 000032BD 268B0D                  	mov	cx,[es:di]		;get the number of entries
 36168 000032C0 47                      	inc	di
 36169 000032C1 47                      	inc	di			;si -> the first start entry id
 36170                                  
 36171                                  getcntrydest:
 36172 000032C2 263805                  	cmp	byte [es:di],al
 36173 000032C5 7413                    	je	short getcntrydest_ok
 36174 000032C7 26803D01                	cmp	byte [es:di],SetCountryInfo ;was it setcountryinfo entry?
 36175 000032CB 7405                    	je	short getcntrydest_1
 36176                                  
 36177 000032CD 83C705                  	add	di,5			;next data id
 36178 000032D0 EB03                    	jmp	short getcntrydest_loop
 36179                                  
 36180                                  getcntrydest_1:
 36181                                  	;add	di,41
 36182 000032D2 83C729                  	add	di,NEW_COUNTRY_SIZE+3	;next data id
 36183                                  getcntrydest_loop:
 36184 000032D5 E2EB                    	loop	getcntrydest
 36185 000032D7 F9                      	stc
 36186 000032D8 EB0B                    	jmp	short getcntrydest_exit
 36187                                  
 36188                                  getcntrydest_ok:
 36189 000032DA 3C01                    	cmp	al,SetCountryInfo ; 1	;select country info?
 36190 000032DC 7503                    	jne	short getcntrydest_ok1
 36191                                  
 36192 000032DE 47                      	inc	di			;now di -> cccountryinfolen
 36193 000032DF EB04                    	jmp	short getcntrydest_exit
 36194                                  
 36195                                  getcntrydest_ok1:
 36196 000032E1 26C47D01                	les	di,[es:di+1]		;get the destination in es:di
 36197                                  
 36198                                  getcntrydest_exit:
 36199 000032E5 59                      	pop	cx
 36200 000032E6 C3                      	retn
 36201                                  
 36202                                  ;----------------------------------------------------------------------------
 36203                                  
 36204                                  readincontrolbuffer:
 36205                                  
 36206                                  ;move file pointer to cx:dx
 36207                                  ;read ax bytes into the control buffer. (should be less than 2 kb)
 36208                                  ;si will be set to 0 hence ds:si points to the control buffer.
 36209                                  ;entry:  cx,dx offset from the start of the file where the read/write pointer
 36210                                  ;	 be moved.
 36211                                  ;	 ax - # of bytes to read
 36212                                  ;	 bx - file handle
 36213                                  ;	 ds - buffer seg.
 36214                                  ;return: the control data information is read into ds:0 - ds:0200.
 36215                                  ;	 cx,dx value destroyed.
 36216                                  ;	 carry set if error in reading file.
 36217                                  
 36218 000032E7 50                      	push	ax			;# of bytes to read
 36219 000032E8 B80042                  	mov	ax,4200h
 36220 000032EB F9                      	stc
 36221 000032EC CD21                    	int	21h			;move pointer
 36222 000032EE 59                      	pop	cx			;# of bytes to read
 36223 000032EF 7209                    	jc	short ricb_exit
 36224                                  
 36225 000032F1 31D2                    	xor	dx,dx			;ds:dx -> control buffer
 36226 000032F3 31F6                    	xor	si,si
 36227 000032F5 B43F                    	mov	ah,3Fh			;read into the buffer
 36228 000032F7 F9                      	stc
 36229 000032F8 CD21                    	int	21h			;should be less than 1024 bytes.
 36230                                  ricb_exit:
 36231 000032FA C3                      	retn
 36232                                  
 36233                                  ;----------------------------------------------------------------------------
 36234                                  
 36235                                  set_country_path:
 36236                                  
 36237                                  ;in:  ds - sysinitseg, es - confbot, si -> start of the asciiz path string
 36238                                  ;     dosinfo_ext, cntry_drv, cntry_root, cntry_path
 36239                                  ;     assumes current directory is the root directory.
 36240                                  ;out: ds:di -> full path (cntry_drv).
 36241                                  ;     set the cntry_drv string from the country=,,path command.
 36242                                  ;     ds, es, si value saved.
 36243                                  
 36244 000032FB 56                      	push	si
 36245                                  
 36246 000032FC 1E                      	push	ds			;switch ds, es
 36247 000032FD 06                      	push	es
 36248 000032FE 1F                      	pop	ds
 36249 000032FF 07                      	pop	es			;now ds -> confbot, es -> sysinitseg
 36250                                  
 36251 00003300 E82E00                  	call	chk_drive_letter	;current ds:[si] is a drive letter?
 36252 00003303 7206                    	jc	short scp_default_drv 	;no, use current default drive.
 36253                                  
 36254 00003305 8A04                    	mov	al,[si]
 36255 00003307 46                      	inc	si
 36256 00003308 46                      	inc	si			;si -> next char after ":"
 36257 00003309 EB06                    	jmp	short scp_setdrv
 36258                                  
 36259                                  scp_default_drv:
 36260 0000330B B419                    	mov	ah,19h
 36261 0000330D CD21                    	int	21h
 36262 0000330F 0441                    	add	al,"A"			;convert it to a character.
 36263                                  
 36264                                  scp_setdrv:
 36265 00003311 2EA2[7C34]              	mov	[cs:cntry_drv],al	;set the drive letter.
 36266 00003315 BF[7F34]                	mov	di,cntry_path
 36267 00003318 8A04                    	mov	al,[si]
 36268 0000331A 3C5C                    	cmp	al, "\"
 36269 0000331C 7406                    	je	short scp_root_dir
 36270                                  
 36271 0000331E 3C2F                    	cmp	al,"/"			;let's accept "/" as an directory delim
 36272 00003320 7402                    	je	short scp_root_dir
 36273                                  
 36274 00003322 EB01                    	jmp	short scp_path
 36275                                  
 36276                                  scp_root_dir:
 36277 00003324 4F                      	dec	di			;di -> cntry_root
 36278                                  scp_path:
 36279 00003325 E81F00                  	call	move_asciiz		;copy it
 36280                                  
 36281 00003328 BF[7C34]                	mov	di,cntry_drv
 36282                                  scpath_exit:
 36283                                  
 36284 0000332B 1E                      	push	ds			;switch ds, es
 36285 0000332C 06                      	push	es
 36286 0000332D 1F                      	pop	ds
 36287 0000332E 07                      	pop	es			;ds, es value restored
 36288                                  
 36289 0000332F 5E                      	pop	si
 36290 00003330 C3                      	retn
 36291                                  
 36292                                  ;----------------------------------------------------------------------------
 36293                                  
 36294                                  chk_drive_letter:
 36295                                  
 36296                                  ;check if ds:[si] is a drive letter followed by ":".
 36297                                  ;assume that every alpha character is already converted to upper case.
 36298                                  ;carry set if not.
 36299                                  
 36300 00003331 50                      	push	ax
 36301 00003332 803C41                  	cmp	byte [si],"A"
 36302                                  	;jb	short cdletter_no
 36303 00003335 720E                    	jb	short cdletter_exit
 36304 00003337 803C5A                  	cmp	byte [si],"Z"
 36305 0000333A 7708                    	ja	short cdletter_no
 36306 0000333C 807C013A                	cmp	byte [si+1],":"
 36307 00003340 7502                    	jne	short cdletter_no
 36308                                  
 36309 00003342 EB01                    	jmp	short cdletter_exit
 36310                                  
 36311                                  cdletter_no:
 36312 00003344 F9                      	stc
 36313                                  cdletter_exit:
 36314 00003345 58                      	pop	ax
 36315 00003346 C3                      	retn
 36316                                  
 36317                                  ;----------------------------------------------------------------------------
 36318                                  
 36319                                  move_asciiz:
 36320                                  
 36321                                  ;in: ds:si -> source es:di -> target
 36322                                  ;out: copy the string until 0.
 36323                                  ;assumes there exists a 0.
 36324                                  
 36325                                  masciiz_loop:
 36326 00003347 A4                      	movsb
 36327 00003348 807CFF00                	cmp	byte [si-1],0	; was it 0?
 36328 0000334C 75F9                    	jne	short masciiz_loop
 36329 0000334E C3                      	retn
 36330                                  
 36331                                  ;----------------------------------------------------------------------------
 36332                                  
 36333                                  ;	ds:dx points to string to output (asciz)
 36334                                  ;
 36335                                  ;	prints <badld_pre> <string> <badld_post>
 36336                                  
 36337                                  badfil:
 36338 0000334F 0E                      	push	cs
 36339 00003350 07                      	pop	es
 36340                                  
 36341 00003351 89D6                    	mov	si,dx
 36342                                  badload:
 36343 00003353 BA[0738]                	mov	dx,badld_pre	; want to print config error
 36344 00003356 BB[C437]                	mov	bx,crlfm
 36345                                  prnerr:
 36346 00003359 0E                      	push	cs
 36347 0000335A 1F                      	pop	ds ; *
 36348 0000335B E81D00                  	call	print
 36349                                  prn1:
 36350 0000335E 268A14                  	mov	dl,[es:si]
 36351 00003361 08D2                    	or	dl,dl
 36352 00003363 7407                    	jz	short prn2
 36353 00003365 B402                    	mov	ah,STD_CON_OUTPUT ; 2 
 36354 00003367 CD21                    	int	21h
 36355 00003369 46                      	inc	si
 36356 0000336A EBF2                    	jmp	short prn1
 36357                                  prn2:
 36358 0000336C 89DA                    	mov	dx,bx
 36359 0000336E E80A00                  	call	print
 36360                                  	; 11/12/2022
 36361                                  	; ds = cs ; *
 36362 00003371 803E[D103]01            	cmp	byte [donotshownum],1 ; suppress line number when handling command.com
 36363                                  	;cmp	byte [cs:donotshownum],1 
 36364 00003376 7407                    	je	short prnexit
 36365                                  	
 36366                                  	; 18/12/2022
 36367                                  	;call	error_line
 36368 00003378 E9CBF3                  	jmp	error_line
 36369                                  ;prnexit:
 36370                                  	;retn
 36371                                  
 36372                                  ;----------------------------------------------------------------------------
 36373                                  
 36374                                  print:
 36375 0000337B B409                    	mov	ah,STD_CON_STRING_OUTPUT ; 9
 36376 0000337D CD21                    	int	21h
 36377                                  prnexit:	; 18/12/2022
 36378 0000337F C3                      	retn
 36379                                  
 36380                                  ;----------------------------------------------------------------------------
 36381                                  
 36382                                  ;  open device pointed to by dx, al has access code
 36383                                  ;   if unable to open do a device open null device instead
 36384                                  
 36385                                  	; 02/11/2022 - Retrodos v4.0 (Modified MSDOS 5.0 IO.SYS)
 36386                                  	; (SYSINIT:3764h)
 36387                                  open_dev:
 36388 00003380 E80500                  	call	open_file
 36389 00003383 7309                    	jnc	short open_dev3
 36390                                  
 36391                                  open_dev1:
 36392 00003385 BA[6034]                	mov	dx,nuldev
 36393                                  	; 18/12/2022
 36394                                  	;call	open_file
 36395                                  ;of_retn:
 36396                                  	;retn
 36397                                  	; 18/12/2022
 36398                                  	;jmp	short open_file
 36399                                  open_file:
 36400 00003388 B43D                    	mov	ah,OPEN	; 3Dh
 36401 0000338A F9                      	stc
 36402 0000338B CD21                    	int	21h
 36403                                  of_retn:	; 18/12/2022
 36404 0000338D C3                      	retn
 36405                                  
 36406                                  open_dev3:
 36407 0000338E 89C3                    	mov	bx,ax			; handle from open to bx
 36408                                  	;;xor	ax,ax			; get device info
 36409                                  	;;mov	ah,IOCTL ; 44h
 36410                                  	;mov	ax,(IOCTL<<8) ; 13/05/2019
 36411                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 36412                                  	;xor	ax,ax
 36413                                  	;mov	ah,44h	; IOCTL
 36414                                  	; 11/12/2022
 36415 00003390 B80044                  	mov	ax,4400h ; IOCTL<<8 
 36416                                  
 36417 00003393 CD21                    	int	21h
 36418                                  
 36419 00003395 F6C280                  	test	dl,10000000b ; 80h
 36420 00003398 75F3                    	jnz	short of_retn
 36421                                  
 36422 0000339A B43E                    	mov	ah,CLOSE ; 3Eh
 36423 0000339C CD21                    	int	21h
 36424 0000339E EBE5                    	jmp	short open_dev1
 36425                                  
 36426                                  ;----------------------------------------------------------------------------
 36427                                  
 36428                                  ; 18/12/2022
 36429                                  %if 0
 36430                                  open_file:
 36431                                  	mov	ah,OPEN	; 3Dh
 36432                                  	stc
 36433                                  	int	21h
 36434                                  	retn
 36435                                  %endif
 36436                                  
 36437                                  ;----------------------------------------------------------------------------
 36438                                  
 36439                                  ; test int24. return back to dos with the fake user response of "fail"
 36440                                  
 36441                                  int24:
 36442 000033A0 B003                    	mov	al,3			; fail the system call
 36443 000033A2 CF                      	iret				; return back to dos.
 36444                                  
 36445                                  ; 19/04/2019 - Retro DOS v4.0
 36446                                  
 36447                                  ;----------------------------------------------------------------------------
 36448                                  ; DATA
 36449                                  ;----------------------------------------------------------------------------
 36450                                  
 36451                                  ;include copyrigh.inc			; copyright statement
 36452                                  
 36453                                  ; MSDOS 6.21 IO.SYS - SYSINIT:4FA3h
 36454                                  
 36455                                  ;MsDosVersion6Copyr:
 36456                                  ;	db	'MS DOS Version 6 (C)Copyright 1981-1993 Microsoft Corp '
 36457                                  ;	db	'Licensed Material - Property of Microsoft All rights reserved '
 36458                                  
 36459                                  ; 22/10/2022
 36460                                  ; MSDOS 5.0 IO.SYS - SYSINIT:378Ch
 36461                                  
 36462                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 36463                                  MsDosVersion5Copyr:
 36464 000033A3 4D5320444F53205665-     	db	'MS DOS Version 5.00 (C)Copyright 1981-1991 Microsoft Corp '
 36464 000033AC 7273696F6E20352E30-
 36464 000033B5 3020284329436F7079-
 36464 000033BE 726967687420313938-
 36464 000033C7 312D31393931204D69-
 36464 000033D0 63726F736F66742043-
 36464 000033D9 6F727020           
 36465 000033DD 4C6963656E73656420-     	db	'Licensed Material - Property of Microsoft All rights reserved '
 36465 000033E6 4D6174657269616C20-
 36465 000033EF 2D2050726F70657274-
 36465 000033F8 79206F66204D696372-
 36465 00003401 6F736F667420416C6C-
 36465 0000340A 207269676874732072-
 36465 00003413 6573657276656420   
 36466                                  
 36467                                  ; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 36468                                  ; 22/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 36469                                  ; 20/04/2019 - Retro DOS v4.0
 36470                                  ;BOOTMES:
 36471                                  ;	db      13
 36472                                  ;	db      10
 36473                                  ;	db      "MS-DOS version "
 36474                                  ;	db      MAJOR_VERSION + "0"
 36475                                  ;	db      "."
 36476                                  ;	db      (MINOR_VERSION / 10) + "0"
 36477                                  ;	db      (MINOR_VERSION % 10) + "0"
 36478                                  ;	db      13,10
 36479                                  ;	;db	"Copyright 1981-1993 Microsoft Corp.",13,10,"$"
 36480                                  ;	; 22/10/2022
 36481                                  ;	db	"Copyright 1981-1991 Microsoft Corp.",13,10,"$"
 36482                                  ;	;
 36483                                  ;	db	0
 36484                                  
 36485                                  	; 12/12/2022
 36486 0000341B 00                      	db	0
 36487                                  ; 12/12/2022
 36488                                  BOOTMES:
 36489 0000341C 0D0A                    	db	13,10
 36490 0000341E 526574726F20444F53-     	db 	"Retro DOS v4.0 (Modified MSDOS 5.0) "
 36490 00003427 2076342E3020284D6F-
 36490 00003430 646966696564204D53-
 36490 00003439 444F5320352E302920 
 36491 00003442 0D0A                    	db	13,10
 36492                                  	;db	"by Erdogan Tan [2022] "
 36493 00003444 6279204572646F6761-     	db	"by Erdogan Tan [2023] " ; 04/01/2023
 36493 0000344D 6E2054616E205B3230-
 36493 00003456 32335D20           
 36494 0000345A 0D0A                    	db	13,10
 36495 0000345C 0D0A2400                	db	13,10,"$",0
 36496                                  
 36497 00003460 4E554C00                nuldev:	db	"NUL",0
 36498 00003464 434F4E00                condev:	db	"CON",0
 36499 00003468 41555800                auxdev:	db	"AUX",0
 36500 0000346C 50524E00                prndev:	db	"PRN",0
 36501                                  
 36502                                  ;IFDEF	CONFIGPROC
 36503 00003470 5C434F4E4649472E53-     config:	db	"\CONFIG.SYS",0
 36503 00003479 595300             
 36504                                  
 36505 0000347C 413A                    cntry_drv:  db	"A:"
 36506 0000347E 5C                      cntry_root: db	"\"
 36507 0000347F 434F554E5452592E53-     cntry_path: db	"COUNTRY.SYS",0
 36507 00003488 595300             
 36508                                  	    ;db	52 dup (0)
 36509 0000348B 00<rep 34h>             	    times 52 db 0	
 36510                                  
 36511                                  country_file_signature:
 36512 000034BF FF434F554E545259        	db	0FFh,'COUNTRY'
 36513                                  
 36514                                  cntrycodepage_id: 
 36515 000034C7 0000                    	dw	0 	
 36516                                  
 36517                                  ;ENDIF ; CONFIGPROC
 36518                                  
 36519                                  ; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 36520                                  ;;ifdef	MULTI_CONFIG
 36521                                  ;newcmd:  db	0			; non-zero if non-std shell specified
 36522                                  ;tmplate: db	64                      ; must precede commnd
 36523                                  ;;endif
 36524                                  	; 02/11/2022
 36525                                  	;db	12                      ; size of commnd line (excl. null)
 36526                                  
 36527 000034C9 5C434F4D4D414E442E-     commnd:	db	"\COMMAND.COM",0
 36527 000034D2 434F4D00           
 36528                                  	;db	51 dup (0)
 36529 000034D6 00<rep 33h>             	times	51 db 0
 36530                                  ;endif
 36531                                  
 36532                                  ; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 36533                                  ;;ifdef	MULTI_CONFIG
 36534                                  ;commnd2: db 	"\COMMAND.COM",0	; alternate commands to exec,
 36535                                  ;	 db	2,"/P",0 		; followed by their respective alternate
 36536                                  ;commnd3: db	"\MSDOS\COMMAND.COM",0	; command lines
 36537                                  ;	 db	11,"A:\MSDOS /P",0 	;(the drive letter are dynamically replaced)
 36538                                  ;commnd4: db	"\DOS\COMMAND.COM",0 	;
 36539                                  ;	 db	9,"A:\DOS /P",0		;
 36540                                  ;def_swchr:	
 36541                                  ;	 db	0			; default switchchar (referenced as command_line-1)
 36542                                  ;;endif
 36543                                  
 36544                                  	; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 36545                                  ;command_line:
 36546                                  ;	db	2,"/P"			; default command.com args
 36547                                  ;	;db	125 dup (0)
 36548                                  ;	times	125 db 0
 36549                                  
 36550                                  pathstring:
 36551                                  	;db	64 dup (0)
 36552 00003509 00<rep 40h>             	times	64 db 0
 36553                                  
 36554                                  ; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 36555                                  %if 0
 36556                                  
 36557                                  dae_flag:
 36558                                  	db	0 ; MSDOS 6.21 IO.SYS - SYSINIT:51D2h 	
 36559                                  
 36560                                  ;ifdef	MULTI_CONFIG
 36561                                  
 36562                                  MAX_MULTI_CONFIG equ 10
 36563                                  
 36564                                  ;   Beware of byte pairs accessed as words (see all "KEEP AFTER" notes below)
 36565                                  
 36566                                  bMenuColor:	db      07h ;1Fh        ; default fgnd/bgnd color
 36567                                  bMenuPage:	db      0               ; menu video page (KEEP AFTER bMenuColor)
 36568                                  		db      5               ; video page function # (KEEP AFTER bMenuPage)
 36569                                  bLastCol:	db      0               ; ending column on status line
 36570                                  bLastRow:	db      24              ; row # of status line (KEEP AFTER bLastCol)
 36571                                  bDisableUI:	db      0               ; 1=disable clean/interactive
 36572                                                                          ; 2=disable default 2-second delay
 36573                                  bCRTPage:	db      0               ; value saved from BIOS data area
 36574                                  wCRTStart:	dw      0               ; value saved from BIOS data area
 36575                                  bQueryOpt:	db      0               ; 0=off, 1=prompt all, 2=prompt none, 4=skip all
 36576                                  bDefBlock:	db      1               ; default block #
 36577                                  bMaxBlock:	db      0               ; maxmimum block #
 36578                                  offDefBlock:	dw      0               ; offset of name of default block (if any)
 36579                                  secTimeOut:	db      -1              ; # of seconds for timeout (-1 == indefinite)
 36580                                  secElapsed:	db      0               ; # of seconds elapsed so far (KEEP AFTER secTimeOut)
 36581                                  abBlockType:	times MAX_MULTI_CONFIG+1 db 0 ; array of block types
 36582                                  aoffBlockName:	times MAX_MULTI_CONFIG+1 dw 0 ; array of offsets of block names
 36583                                  aoffBlockDesc:	times MAX_MULTI_CONFIG+1 dw 0 ; array of offsets of block descriptions
 36584                                  
 36585                                  szBoot:		db      "CONFIG=",0
 36586                                  szMenu:		db      "MENU",0
 36587                                  szCommon:	db      "COMMON",0
 36588                                  
 36589                                  ;endif	;MULTI_CONFIG
 36590                                  
 36591                                  comtab:	 ; label byte
 36592                                  
 36593                                  ;            cmd len    command         cmd code
 36594                                  ;            -------    -------         --------
 36595                                  
 36596                                  ;ifdef MULTI_CONFIG
 36597                                          db      1,      "[",            CONFIG_BEGIN
 36598                                  ;endif
 36599                                          db      5,      "BREAK",        CONFIG_BREAK
 36600                                          db      7,      "BUFFERS",      CONFIG_BUFFERS
 36601                                          db      7,      "COMMENT",      CONFIG_COMMENT
 36602                                          db      7,      "COUNTRY",      CONFIG_COUNTRY
 36603                                          db      6,      "DEVICE",       CONFIG_DEVICE
 36604                                          db      10,     "DEVICEHIGH",   CONFIG_DEVICEHIGH
 36605                                          db      3,      "DOS",          CONFIG_DOS
 36606                                          db      8,      "DRIVPARM",     CONFIG_DRIVPARM
 36607                                          db      4,      "FCBS",         CONFIG_FCBS
 36608                                          db      5,      "FILES",        CONFIG_FILES
 36609                                  ;ifdef MULTI_CONFIG
 36610                                          db      7,      "INCLUDE",      CONFIG_INCLUDE
 36611                                  ;endif
 36612                                          db      7,      "INSTALL",      CONFIG_INSTALL
 36613                                          db      11,     "INSTALLHIGH",  CONFIG_INSTALLHIGH
 36614                                          db      9,      "LASTDRIVE",    CONFIG_LASTDRIVE
 36615                                  ;ifdef MULTI_CONFIG
 36616                                          db      7,      "SUBMENU",      CONFIG_SUBMENU
 36617                                          db      9,      "MENUCOLOR",    CONFIG_MENUCOLOR
 36618                                          db      11,     "MENUDEFAULT",  CONFIG_MENUDEFAULT
 36619                                          db      8,      "MENUITEM",     CONFIG_MENUITEM
 36620                                  ;endif
 36621                                          db      10,     "MULTITRACK",   CONFIG_MULTITRACK
 36622                                  ;ifdef MULTI_CONFIG
 36623                                          db      7,      "NUMLOCK",      CONFIG_NUMLOCK
 36624                                  ;endif
 36625                                          db      3,      "REM",          CONFIG_REM
 36626                                  ;ifdef MULTI_CONFIG
 36627                                          db      3,      "SET",          CONFIG_SET
 36628                                  ;endif
 36629                                          db      5,      "SHELL",        CONFIG_SHELL
 36630                                  ;if    STACKSW
 36631                                          db      6,      "STACKS",       CONFIG_STACKS
 36632                                  ;endif
 36633                                          db      8,      "SWITCHES",     CONFIG_SWITCHES
 36634                                  	db	0
 36635                                  %endif
 36636                                  
 36637                                  comtab:
 36638                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 36639                                  	; (SYSINIT:38EDh)
 36640 00003549 074255464645525342      	db      7,      "BUFFERS",      CONFIG_BUFFERS
 36641 00003552 05425245414B43          	db      5,      "BREAK",        CONFIG_BREAK
 36642 00003559 0644455649434544        	db      6,      "DEVICE",       CONFIG_DEVICE
 36643 00003561 0A4445564943454849-     	db      10,     "DEVICEHIGH",   CONFIG_DEVICEHIGH
 36643 0000356A 474855             
 36644 0000356D 0546494C455346          	db      5,      "FILES",        CONFIG_FILES
 36645 00003574 044643425358            	db      4,      "FCBS",         CONFIG_FCBS
 36646 0000357A 094C41535444524956-     	db      9,      "LASTDRIVE",    CONFIG_LASTDRIVE
 36646 00003583 454C               
 36647 00003585 0A4D554C5449545241-     	db      10,     "MULTITRACK",   CONFIG_MULTITRACK
 36647 0000358E 434B4D             
 36648 00003591 08445249565041524D-     	db      8,      "DRIVPARM",     CONFIG_DRIVPARM
 36648 0000359A 50                 
 36649 0000359B 06535441434B534B        	db      6,      "STACKS",       CONFIG_STACKS
 36650 000035A3 07434F554E54525951      	db      7,      "COUNTRY",      CONFIG_COUNTRY
 36651 000035AC 055348454C4C53          	db      5,      "SHELL",        CONFIG_SHELL
 36652 000035B3 07494E5354414C4C49      	db      7,      "INSTALL",      CONFIG_INSTALL
 36653 000035BC 07434F4D4D454E5459      	db      7,      "COMMENT",      CONFIG_COMMENT
 36654 000035C5 0352454D30              	db      3,      "REM",          CONFIG_REM
 36655 000035CA 085357495443484553-     	db      8,      "SWITCHES",     CONFIG_SWITCHES
 36655 000035D3 31                 
 36656 000035D4 03444F5348              	db      3,      "DOS",          CONFIG_DOS
 36657 000035D9 00                      	db	0
 36658                                  
 36659                                  deviceparameters:	
 36660                                  	; A_DEVICEPARAMETERS <0,dev_3inch720kb,0,80>
 36661                                  devp.specialfunc:	; deviceparameters +
 36662 000035DA 00                      	db	0	; A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS
 36663                                  devp.devtype:
 36664 000035DB 02                      	db	2	; A_DEVICEPARAMETERS.DP_DEVICETYPE
 36665                                  devp.devattr:
 36666 000035DC 0000                    	dw	0	; A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES
 36667                                  devp.cylinders:
 36668 000035DE 5000                    	dw	80	; A_DEVICEPARAMETERS.DP_CYLINDERS
 36669                                  
 36670 000035E0 00<rep 11Eh>            	times	286	db 0
 36671                                  	
 36672 000036FE 0200                    hlim:	dw	2
 36673 00003700 0900                    slim:	dw	9
 36674                                  
 36675 00003702 00                      drive:	db	0
 36676                                  
 36677                                  switches:
 36678 00003703 0000                    	dw	0
 36679                                  
 36680                                  ; the following are the recommended bpbs for the media that
 36681                                  ; we know of so far.
 36682                                  
 36683                                  ; 02/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 36684                                  ; MSDOS 5.0 IO.SYS - SYSINIT:3AA9h
 36685                                  
 36686                                  ; 48 tpi diskettes
 36687                                  
 36688 00003705 0002                    bpb48t	dw	512
 36689 00003707 02                      	db	2
 36690 00003708 0100                    	dw	1
 36691 0000370A 02                      	db	2
 36692 0000370B 7000                    	dw	112
 36693 0000370D D002                    	dw	2*9*40 ; 720
 36694 0000370F FD                      	db	0FDh
 36695 00003710 0200                    	dw	2
 36696 00003712 0900                    	dw	9
 36697 00003714 0200                    	dw	2
 36698 00003716 00000000                	dd	0
 36699 0000371A 00000000                        dd      0
 36700                                  
 36701                                  ; 96tpi diskettes
 36702                                  
 36703 0000371E 0002                    bpb96t:	dw	512
 36704 00003720 01                      	db	1
 36705 00003721 0100                    	dw	1
 36706 00003723 02                      	db	2
 36707 00003724 E000                    	dw	224
 36708 00003726 6009                    	dw	2*15*80 ; 2400
 36709 00003728 F9                      	db	0F9h
 36710 00003729 0700                    	dw	7
 36711 0000372B 0F00                    	dw	15
 36712 0000372D 0200                    	dw	2
 36713 0000372F 00000000                	dd	0
 36714 00003733 00000000                        dd      0
 36715                                  
 36716                                  ; 3 1/2 inch diskette bpb
 36717                                  
 36718 00003737 0002                    bpb35:	dw	512
 36719 00003739 02                      	db	2
 36720 0000373A 0100                    	dw	1
 36721 0000373C 02                      	db	2
 36722 0000373D 7000                    	dw	112
 36723 0000373F A005                    	dw	2*9*80 ; 1440
 36724 00003741 F9                      	db	0F9h
 36725 00003742 0300                    	dw	3
 36726 00003744 0900                    	dw	9
 36727 00003746 0200                    	dw	2
 36728 00003748 00000000                	dd	0
 36729 0000374C 00000000                        dd      0
 36730                                        
 36731 00003750 0002                    bpb35h:	dw	512
 36732 00003752 01                      	db	1
 36733 00003753 0100                    	dw	1
 36734 00003755 02                      	db	2
 36735 00003756 E000                    	dw	224
 36736 00003758 400B                    	dw	2*18*80 ; 2880
 36737 0000375A F0                      	db	0F0h
 36738 0000375B 0900                    	dw	9
 36739 0000375D 1200                    	dw	18
 36740 0000375F 0200                    	dw	2
 36741 00003761 00000000                	dd	0
 36742 00003765 00000000                        dd      0
 36743                                  
 36744                                  ; m037 - BEGIN
 36745                                  
 36746 00003769 0002                    bpb288:	dw	512
 36747 0000376B 02                      	db	2
 36748 0000376C 0100                    	dw	1
 36749 0000376E 02                      	db	2
 36750 0000376F F000                    	dw	240
 36751 00003771 8016                    	dw	2*36*80 ; 5760
 36752 00003773 F0                      	db	0F0h
 36753 00003774 0900                    	dw	9
 36754 00003776 2400                    	dw	36
 36755 00003778 0200                    	dw	2
 36756 0000377A 00000000                	dd	0
 36757 0000377E 00000000                        dd      0
 36758                                  
 36759                                  ; m037 - END
 36760                                  
 36761                                  ; 12/05/2019
 36762                                  
 36763                                  align 2
 36764                                  
 36765                                  ; 02/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 36766                                  ; MSDOS 5.0 IO.SYS - SYSINIT:3B26h
 36767                                  
 36768 00003782 [0537]                  bpbtable:   dw	    bpb48t		; 48tpi drives
 36769 00003784 [1E37]                  	    dw	    bpb96t		; 96tpi drives
 36770 00003786 [3737]                  	    dw	    bpb35		; 3.5" drives
 36771                                  ; the following are not supported, so default to 3.5" media layout
 36772 00003788 [3737]                  	    dw	    bpb35		; not used - 8" drives
 36773 0000378A [3737]                  	    dw	    bpb35		; not used - 8" drives
 36774 0000378C [3737]                  	    dw	    bpb35		; not used - hard files
 36775 0000378E [3737]                  	    dw	    bpb35		; not used - tape drives
 36776 00003790 [5037]                  	    dw	    bpb35h		; 3-1/2" 1.44mb drive
 36777 00003792 [3737]                  	    dw	    bpb35		; ERIMO				m037
 36778 00003794 [6937]                  	    dw	    bpb288		; 2.88 MB diskette drives	m037
 36779                                  
 36780                                  switchlist: 
 36781 00003796 08464853544449434E      	db	8,"FHSTDICN"	     ; preserve the positions of n and c.
 36782                                  
 36783                                  ;----------------------------------------------------------------------------
 36784                                  ; Messages
 36785                                  ;----------------------------------------------------------------------------
 36786                                  
 36787                                  ; 19/04/2019 - Retro DOS v4.0
 36788                                  
 36789                                  ; MSDOS 6.21 IO.SYS - SYSINIT:54D1h
 36790                                  
 36791 0000379F 00                      	db 	0
 36792                                  
 36793                                  ; 02/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 36794                                  ; MSDOS 5.0 IO.SYS - SYSINIT:3B44h
 36795                                  
 36796                                  badopm:
 36797 000037A0 0D0A                    	db	0Dh,0Ah 
 36798 000037A2 556E7265636F676E69-     	db	'Unrecognized command in CONFIG.SYS'
 36798 000037AB 7A656420636F6D6D61-
 36798 000037B4 6E6420696E20434F4E-
 36798 000037BD 4649472E535953     
 36799                                  crlfm:
 36800 000037C4 0D0A24                  	db	0Dh,0Ah,'$'
 36801                                  badparm:
 36802 000037C7 0D0A                    	db	0Dh,0Ah
 36803 000037C9 42616420636F6D6D61-     	db	'Bad command or parameters - $'
 36803 000037D2 6E64206F7220706172-
 36803 000037DB 616D6574657273202D-
 36803 000037E4 2024               
 36804                                  badsiz_pre:
 36805 000037E6 0D0A                    	db	0Dh,0Ah
 36806 000037E8 536563746F72207369-     	db	'Sector size too large in file $'
 36806 000037F1 7A6520746F6F206C61-
 36806 000037FA 72676520696E206669-
 36806 00003803 6C652024           
 36807                                  badld_pre:
 36808 00003807 0D0A                    	db	0Dh,0Ah
 36809 00003809 426164206F72206D69-     	db	'Bad or missing $'
 36809 00003812 7373696E672024     
 36810                                  badcom:
 36811 00003819 436F6D6D616E642049-     	db	'Command Interpreter',0
 36811 00003822 6E7465727072657465-
 36811 0000382B 7200               
 36812                                  badcountry:
 36813 0000382D 0D0A                    	db	0Dh,0Ah
 36814 0000382F 496E76616C69642063-     	db	'Invalid country code or code page',0Dh,0Ah,'$'
 36814 00003838 6F756E74727920636F-
 36814 00003841 6465206F7220636F64-
 36814 0000384A 6520706167650D0A24 
 36815                                  badcountrycom:
 36816 00003853 0D0A                    	db	0Dh,0Ah
 36817 00003855 4572726F7220696E20-     	db	'Error in COUNTRY command',0Dh,0Ah,'$'
 36817 0000385E 434F554E5452592063-
 36817 00003867 6F6D6D616E640D0A24 
 36818                                  insufmemory:
 36819 00003870 0D0A                    	db	0Dh,0Ah
 36820 00003872 496E73756666696369-     	db	'Insufficient memory for COUNTRY.SYS file',0Dh,0Ah,'$'
 36820 0000387B 656E74206D656D6F72-
 36820 00003884 7920666F7220434F55-
 36820 0000388D 4E5452592E53595320-
 36820 00003896 66696C650D0A24     
 36821                                  badmem:
 36822 0000389D 0D0A                    	db	0Dh,0Ah
 36823 0000389F 436F6E666967757261-     	db	'Configuration too large for memory',0Dh,0Ah,'$'
 36823 000038A8 74696F6E20746F6F20-
 36823 000038B1 6C6172676520666F72-
 36823 000038BA 206D656D6F72790D0A-
 36823 000038C3 24                 
 36824                                  badblock:
 36825 000038C4 0D0A                    	db	0Dh,0Ah
 36826 000038C6 546F6F206D616E7920-     	db	'Too many block devices',0Dh,0Ah,'$'
 36826 000038CF 626C6F636B20646576-
 36826 000038D8 696365730D0A24     
 36827                                  badstack:
 36828 000038DF 0D0A                    	db	0Dh,0Ah
 36829 000038E1 496E76616C69642053-     	db	'Invalid STACK parameters',0Dh,0Ah,'$'
 36829 000038EA 5441434B2070617261-
 36829 000038F3 6D65746572730D0A24 
 36830                                  	; 18/12/2022
 36831                                  ;badorder:
 36832                                  	;db	0Dh,0Ah
 36833                                  	;db	'Incorrect order in CONFIG.SYS line $'
 36834                                  errorcmd:
 36835 000038FC 4572726F7220696E20-     	db	'Error in CONFIG.SYS line $'
 36835 00003905 434F4E4649472E5359-
 36835 0000390E 53206C696E652024   
 36836                                  
 36837                                  ; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 36838                                  %if 0
 36839                                  
 36840                                  OnOff:	db	'ON'
 36841                                  OnOff2:	db	'OFF'
 36842                                  
 36843                                  StartMsg:
 36844                                  	db	'Starting MS-DOS...',0Dh,0Ah
 36845                                  	db	0Ah,0
 36846                                  _$PauseMsg:
 36847                                  	db	'Press any key to continue . . .',0Dh,0Ah,'$'
 36848                                  _$CleanMsg:
 36849                                  	db	'MS-DOS is bypassing your CONFIG.SYS and AUTOEXEC.BAT files.',0Dh,0Ah,'$'
 36850                                  _$InterMsg:
 36851                                  	db	'MS-DOS will prompt you to confirm each CONFIG.SYS command.',0Dh,0Ah,'$'
 36852                                  _$MenuHeader:
 36853                                  	db	0Dh,0Ah
 36854                                  	db	'  MS-DOS 6.2 Startup Menu',0Dh,0Ah
 36855                                  	db	'  =======================',0Dh,0Ah,'$'
 36856                                  _$MenuPrmpt:
 36857                                  	db	'  Enter a choice: $'
 36858                                  _$StatusLine:
 36859                                  	db	'F5=Bypass startup files F8=Confirm each line of CONFIG.SYS'
 36860                                  	db	'and AUTOEXEC.BAT [ ]$'
 36861                                  _$InterPrmpt:
 36862                                  	db	' [Y,N]?$'
 36863                                  _$YES:	db	'YES$'
 36864                                  _$NO:	db	'NO $'
 36865                                  _$TimeOut:
 36866                                  	db	'Time remaining: $'
 36867                                  badcomprmpt:
 36868                                  	db	'Enter correct name of Command Interpreter (eg, C:\COMMAND.COM)'
 36869                                  	db	0Dh,0Ah,'$'
 36870                                  _$AutoPrmpt:
 36871                                  	db	'Process AUTOEXEC.BAT [Y,N]?$'
 36872                                  
 36873                                  %endif
 36874                                  
 36875                                  ; 02/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 36876                                  ; MSDOS 5.0 IO.SYS - SYSINIT:3CE0h
 36877                                  
 36878                                  TooManyDrivesMsg:
 36879 00003916 5741524E494E472120-     	db	'WARNING! Logical drives past Z: exist and will be ignored',0Dh,0Ah,'$'
 36879 0000391F 4C6F676963616C2064-
 36879 00003928 726976657320706173-
 36879 00003931 74205A3A2065786973-
 36879 0000393A 7420616E642077696C-
 36879 00003943 6C2062652069676E6F-
 36879 0000394C 7265640D0A24       
 36880                                  
 36881                                  ;MSDOS 6.21 IO.SYS - SYSINIT:587Ch
 36882                                  	;db	'Wrong DBLSPACE.BIN version',0Dh,0Ah,'$'
 36883                                  	;db	7 dup(0)
 36884                                  
 36885                                  	;times	7 db 0
 36886                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 36887                                  ;MSDOS 5.0 IO.SYS - SYSINIT:3D1Ch
 36888                                  	; 09/12/2022
 36889                                  	;times 4 db 0
 36890                                  
 36891                                  ;----------------------------------------------------------------------------
 36892                                  		; 09/12/2022
 36893                                  		;db 0
 36894                                  
 36895                                  number3div	equ ($-SYSINIT$)
 36896                                  number3mod	equ (number3div % 16)
 36897                                  
 36898                                  %if (number3mod>0) & (number3mod<16) ; 17/09/2023
 36899 00003952 00<rep Eh>              		times (16-number3mod) db 0
 36900                                  %endif
 36901                                  
 36902                                  ;---------------------------------------------------------------------------- 
 36903                                  ; 09/12/2022 - MSDOS 5.0 IO.SYS:3D20h ;;; SI_end = 3D20h for MSDOS 5.0 IO.SYS 
 36904                                  ;---------------------------------------------------------------------------- 
 36905                                  
 36906                                  ;MSDOS 6.21 IO.SYS - SYSINIT:5899h
 36907                                  
 36908                                  ;----------------------------------------------------------------------------
 36909                                  ; 20/04/2019 - Retro DOS v4.0
 36910                                  
 36911                                  ; 09/12/2022
 36912                                  ;
 36913                                  ;bss_start:
 36914                                  ;
 36915                                  ;ABSOLUTE bss_start
 36916                                  ;
 36917                                  ;alignb 16
 36918                                  
 36919                                  SI_end:  ; SI_end equ $
 36920                                  
 36921                                  ;----------------------------------------------------------------------------
 36922                                  
 36923                                  ;sysinitseg	ends
 36924                                  
 36925                                  ; ****************************************************************************  
 36926                                  
 36927                                  ; 09/12/2022 - MSDOS 5.0 IO.SYS:3D20h ;;; SI_end = 3D20h for MSDOS 5.0 IO.SYS
 36928                                  
 36929                                  SYSINITSIZE	equ SI_end - SYSINIT$
 36930                                  DOSLOADSEG	equ SYSINITSEG+((SYSINITSIZE+15)/16)
 36931                                  
 36932                                  ;----------------------------------------------------------------------------	
 36933                                  ; End of Retro DOS v4.0 (MSDOS 5.0) IO.SYS source by Erdogan Tan - 09/12/2022
 36934                                  ;----------------------------------------------------------------------------
