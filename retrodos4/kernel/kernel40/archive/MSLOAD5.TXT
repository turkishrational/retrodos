     1                                  ; ****************************************************************************
     2                                  ; MSLOADS5.S (MSDOS 5.0 IO.SYS) - RETRO DOS v4.0 by ERDOGAN TAN - 01/10/2022
     3                                  ; ----------------------------------------------------------------------------
     4                                  ; Last Update: 20/12/2022 (Modified IO.SYS loader)  ((Previous: 20/10/2022))
     5                                  ; ----------------------------------------------------------------------------
     6                                  ; Beginning: 21/10/2022 (Retro DOS 4.0)
     7                                  ; ----------------------------------------------------------------------------
     8                                  ; Assembler: NASM version 2.11 (2.15) 
     9                                  ; ----------------------------------------------------------------------------
    10                                  ;	   ((nasm msload5.s -l msload5.lst -o MSLOAD5.BIN -Z error.txt)) 
    11                                  ; ----------------------------------------------------------------------------
    12                                  ; Converted to NASM source code from disassembled MSDOS 5.0 (IO.SYS) MSLOAD
    13                                  ; code by Erdogan Tan (disassembly: 18/09/2022, Converted source: 21/10/2022) 
    14                                  ; ----------------------------------------------------------------------------
    15                                  
    16                                  ; +-------------------------------------------------------------------------+
    17                                  ; |   This file	has been generated by The Interactive Disassembler (IDA)    |
    18                                  ; |	      Copyright	(c) 2013 Hex-Rays, <support@hex-rays.com>	    |
    19                                  ; |			 Licensed to: Freeware version			    |
    20                                  ; +-------------------------------------------------------------------------+
    21                                  ;
    22                                  ; Input	MD5   :	B2FA03653E5C5D545327EE28B8A24356
    23                                  ; Input	CRC32 :	20FC79BF
    24                                  
    25                                  ; ---------------------------------------------------------------------------
    26                                  ; File Name   :	C:\Users\Erdoðan\Desktop\IO.SYS
    27                                  ; Format      :	Binary file
    28                                  ; Base Address:	0000h Range: 0000h - 8296h Loaded length: 00008296h
    29                                  
    30                                  ;		.386
    31                                  ;		.model flat
    32                                  
    33                                  ; ===========================================================================
    34                                  
    35                                  ; 09/12/2022
    36                                  ; Comments are from MSDOS 6.0 MSLOAD.ASM (1991) & HEX-RAYS IDA disasm output
    37                                  
    38                                  ; ===========================================================================
    39                                  ;	NOTE: The boot loader should be verifying that the first
    40                                  ;	  block of io.sys is, in fact, at cluster 2. This would be saving
    41                                  ;	  a whole lot of time during system debugging.
    42                                  ;
    43                                  ;============================================================================
    44                                  ;
    45                                  ;     for dos 4.00, msload program has been changed to allow:
    46                                  ;	  1. 32 bit calculation,
    47                                  ;	  2. reading a fat sector when needed, instead of reading the whole
    48                                  ;	     fat sectors at once. this will make the boot time faster,
    49                                  ;	     and eliminate the memory size limitation problem,
    50                                  ;	  3. solving the limitation of the file size (29 kb) of io.sys0,
    51                                  ;	  4. adding the boot error message. show the same boot error message
    52                                  ;	     and do the same behavior when the read operation of io.sys
    53                                  ;	     fails as the msboot program, since msload program is the
    54                                  ;	     extention of msboot program.
    55                                  ;
    56                                  ; ===========================================================================
    57                                  
    58                                  ;
    59                                  ;----------------------------------------------------------------------------
    60                                  ;
    61                                  ; M056 : Added RPL support, so that RPL's fake INT 13 code can be safe from
    62                                  ;		SYSINIT & transient portion of COMMAND.COM
    63                                  ;
    64                                  ;----------------------------------------------------------------------------
    65                                  		
    66                                  		[ORG 0]			; segment 0x0070h
    67                                  
    68                                  START$:
    69 00000000 E93501                  		jmp	SaveInputValuess
    70                                  ; 20/12/2022
    71                                  ; 09/12/2022
    72                                  ; ---------------------------------------------------------------------------
    73 00000003 0500                    SysVersion:	dw 5			; expected_version	
    74 00000005 000000000000000000-     MyStacks:	db 256 dup(0)		; local stack
    74 0000000E 000000000000000000-
    74 00000017 000000000000000000-
    74 00000020 000000000000000000-
    74 00000029 000000000000000000-
    74 00000032 000000000000000000-
    74 0000003B 000000000000000000-
    74 00000044 000000000000000000-
    74 0000004D 000000000000000000-
    74 00000056 000000000000000000-
    74 0000005F 000000000000000000-
    74 00000068 000000000000000000-
    74 00000071 000000000000000000-
    74 0000007A 000000000000000000-
    74 00000083 000000000000000000-
    74 0000008C 000000000000000000-
    74 00000095 000000000000000000-
    74 0000009E 000000000000000000-
    74 000000A7 000000000000000000-
    74 000000B0 000000000000000000-
    74 000000B9 000000000000000000-
    74 000000C2 000000000000000000-
    74 000000CB 000000000000000000-
    74 000000D4 000000000000000000-
    74 000000DD 000000000000000000-
    74 000000E6 000000000000000000-
    74 000000EF 000000000000000000-
    74 000000F8 000000000000000000-
    74 00000101 00000000           
    75 00000105 0000                    NumHeads:	dw 0			; ...
    76 00000107 0000                    ClusterSize:	db 2 dup(0)		; ...
    77 00000109 0000                    StartSecL:	dw 0			; ...
    78 0000010B 0000                    StartSecH:	dw 0			; ...
    79 0000010D 0000                    TempH:		dw 0			; for 32 bit calculation
    80 0000010F 0000                    TempCluster:	db 2 dup(0)		; temporary place for cluster number
    81 00000111 FFFF                    LastFatSector:	db 2 dup(0FFh)		; fat sec # start from 1st FAT entry
    82 00000113 0000                    SectorCount:	dw 0			; ...
    83 00000115 0000                    SecPerFat:	dw 0			; ...
    84 00000117 0000                    HiddenSectorsL:	dw 0			; ...
    85 00000119 0000                    HiddenSectorsH:	dw 0			; ...
    86 0000011B 0000                    BytesPerSec:	dw 0			; ...
    87 0000011D 0000                    ReservSectors:	db 2 dup(0)		; ...
    88 0000011F 0000                    CurrentCluster:	db 2 dup(0)		; ...
    89 00000121 0000                    NextBioLocation: db 2 dup(0)		; ...
    90 00000123 0000                    FirstSectorL:	dw 0			; ...
    91 00000125 0000                    FirstSectorH:	dw 0			; ...
    92 00000127 0000                    TotalSectorsL:	dw 0			; max. number of sectors
    93 00000129 0000                    TotalSectorsH:	dw 0			; ...
    94 0000012B 0000                    SecPerTrack:	db 2 dup(0)		; ...
    95 0000012D 00                      BootDrive:	db 0			; ...
    96 0000012E 00                      Fatsize:	db 0			; ...
    97 0000012F 00                      MediaByte:	db 0			; ...
    98 00000130 00                      EndOfFile:	db 0			; ...
    99 00000131 00000000                OrgDasdPtr:	db 4 dup(0)		; ...
   100 00000135 0000                    FatSegment:	db 2 dup(0)		; ...
   101 00000137 00                      SecPerCluster:	db 0			; ...
   102                                  ; ---------------------------------------------------------------------------
   103                                  
   104                                  ; SaveInputValuess
   105                                  ; ---------------------------------------------------------------------------
   106                                  ; INPUT:     none
   107                                  ;
   108                                  ;   dl = int 13 drive number we booted from
   109                                  ;   ch = media byte
   110                                  ;   bx = first data sector (low) on disk (0-based)
   111                                  ;   ds:si = original rom bios diskette parameter table.
   112                                  ;
   113                                  ; if an extended boot record, then ax will be the first data sector
   114                                  ; high word. save ax and set FirstSectorH according to ax if it is an
   115                                  ; extended boot record.
   116                                  ;
   117                                  ;   ax = first data sector (high) on disk ;
   118                                  ; OUTPUT:
   119                                  ;
   120                                  ;   bx = first data sector on disk
   121                                  ;
   122                                  ;   MediaByte = input ch
   123                                  ;   BootDrive = input dl
   124                                  ;   FirstSectorL = input bx
   125                                  ;   FirstSectorH = input AX, if an extended boot record.;j.k.
   126                                  ;   TotalSectorsL = maximum sector number in this media ;j.k.
   127                                  ;   TotalSectorsH = high word of the above
   128                                  ;   HiddenSectorsL = hidden secotrs
   129                                  ;   HiddenSectorsH
   130                                  ;   ReservSectors = reserved sectors
   131                                  ;   SecPerTrack = sectors/track
   132                                  ;   NumHeads = heads/cylinder
   133                                  ;
   134                                  ;   ds = 0
   135                                  ;   AX,DX,SI destroyed
   136                                  ;
   137                                  ; calls:     none
   138                                  ; ---------------------------------------------------------------------------
   139                                  ;FUNCTION:
   140                                  ; save input information and bpb informations from the boot record.
   141                                  ; ---------------------------------------------------------------------------
   142                                  
   143                                  Sec9 equ 522h
   144                                  ; 20/12/2022	
   145                                  DskAddr	equ 1Eh*4 ; 7Eh
   146                                  StackPtr equ MyStacks+(NumHeads-MyStacks)
   147                                  
   148                                  SaveInputValuess:			; ...
   149 00000138 2E891E[2301]            		mov	[cs:FirstSectorL], bx
   150 0000013D 2E882E[2F01]            		mov	[cs:MediaByte], ch
   151 00000142 2E8816[2D01]            		mov	[cs:BootDrive], dl
   152 00000147 2E8936[3101]            		mov	[cs:OrgDasdPtr], si
   153 0000014C 1E                      		push	ds
   154 0000014D 2E8F06[3301]            		pop	word [cs:OrgDasdPtr+2]
   155 00000152 31C9                    		xor	cx, cx		; segment 0 (obviously)
   156 00000154 8ED9                    		mov	ds, cx		; ZERO
   157 00000156 06                      		push	es
   158 00000157 8EC1                    		mov	es, cx
   159                                  		;mov	si, [DskAddr]	; 0000h:0078h (Int 1Eh)
   160                                  		;mov	ds, [DskAddr+2]	; DS:SI -> current table
   161                                  		; 20/12/2022
   162 00000159 BE2205                  		mov	si, Sec9
   163 0000015C 89F7                    		mov	di, si
   164 0000015E 87367800                		xchg	si, [DskAddr]
   165 00000162 870E7A00                		xchg	cx, [DskAddr+2]
   166 00000166 8ED9                    		mov	ds, cx
   167                                  		;mov	di, Sec9	; 522h  ; ES:DI -> new table
   168 00000168 B90B00                  		mov	cx, 11			; taken from ibmboot.asm
   169 0000016B FC                      		cld
   170 0000016C F3A4                    		rep movsb		; copy table
   171                                  		;push	es
   172                                  		;pop	ds		; ds = 0
   173                                  		; 20/12/2022
   174 0000016E 8ED9                    		mov	ds, cx ; 0
   175                                  		;mov	word [DskAddr], Sec9 ; 522h
   176                                  		;mov	[DskAddr+2], ds	; point disk parm vector to new table
   177 00000170 07                      		pop	es
   178 00000171 8B0E0B7C                		mov	cx, [7C0Bh] 	; BootSector.ext_boot_bpb.BPB_bytespersector
   179 00000175 2E890E[1B01]            		mov	[cs:BytesPerSec], cx
   180 0000017A 8A0E0D7C                		mov	cl, [7C0Dh]	; BootSector.ext_boot_bpb.BPB_sectorspercluster
   181 0000017E 2E880E[3701]            		mov	[cs:SecPerCluster], cl
   182 00000183 8B0E187C                		mov	cx, [7C18h]	; BootSector.ext_boot_bpb.BPB_sectorspertrack	
   183 00000187 2E890E[2B01]            		mov	[cs:SecPerTrack], cx
   184 0000018C 8B0E1A7C                		mov	cx, [7C1Ah]	; BootSector.ext_boot_bpb.BPB_heads
   185 00000190 2E890E[0501]            		mov	[cs:NumHeads], cx
   186 00000195 8B0E167C                		mov	cx, [7C16h]	; BootSector.ext_boot_bpb.BPB_sectorsperfat
   187 00000199 2E890E[1501]            		mov	[cs:SecPerFat], cx
   188 0000019E 8B0E0E7C                		mov	cx, [7C0Eh]	; BootSector.ext_boot_bpb.BPB_reservedsectors	
   189 000001A2 2E890E[1D01]            		mov	[cs:ReservSectors], cx
   190 000001A7 8B0E1C7C                		mov	cx, [7C1Ch]	; BootSector.ext_boot_bpb.BPB_hiddensectors
   191 000001AB 2E890E[1701]            		mov	[cs:HiddenSectorsL], cx
   192 000001B0 8B0E137C                		mov	cx, [7C13h]	; BootSector.ext_boot_bpb.BPB_totalsectors
   193 000001B4 2E890E[2701]            		mov	[cs:TotalSectorsL], cx
   194                                  
   195                                  		; First of all, check if it the boot record is an extended one.
   196                                  		; This is just a safe guard in case some user just "copy" the
   197                                  		; 4.00 iosys.com to a media with a conventional boot record.
   198                                  
   199 000001B9 803E267C29              		cmp	byte [7C26h], 29h ; ext_boot_signature
   200 000001BE 751D                    		jnz	short relocate
   201 000001C0 2EA3[2501]              		mov	[cs:FirstSectorH], ax ; ax = first data sector (high) on disk
   202 000001C4 A11E7C                  		mov	ax, [7C1Eh]
   203 000001C7 2EA3[1901]              		mov	[cs:HiddenSectorsH], ax
   204                                  		; 10/12/2022
   205 000001CB 09C9                    		or	cx, cx
   206                                  		;cmp	cx, 0		; cx set already before (=totalsectors)
   207 000001CD 750E                    		jnz	short relocate
   208 000001CF A1207C                  		mov	ax, [7C20h]	; BootSector.ext_boot_bpb.BPB_bigtotalsectors
   209 000001D2 2EA3[2701]              		mov	[cs:TotalSectorsL], ax
   210 000001D6 A1227C                  		mov	ax, [7C22h]	; BootSector.ext_boot_bpb.BPB_bigtotalsectors+2
   211 000001D9 2EA3[2901]              		mov	[cs:TotalSectorsH], ax
   212                                  
   213                                  ; Relocate
   214                                  ; -------------------------------------------------------------------------
   215                                  ;
   216                                  ; NOTES:
   217                                  ;
   218                                  ;   Relocates the loader code to top-of-memory.
   219                                  ;
   220                                  ; INPUT:     none
   221                                  ;
   222                                  ; OUTPUT:    code and data relocated.
   223                                  ;	     AX,CX,SI,DI destroyed
   224                                  ;
   225                                  ; calls:     none
   226                                  ; -------------------------------------------------------------------------
   227                                  ;
   228                                  ; Determine the number of paragraphs (16 byte blocks) of memory.
   229                                  ; this involves invoking the memory size determination interrupt,
   230                                  ; which returns the number of 1k blocks of memory, and then
   231                                  ; converting this to the number of paragraphs.
   232                                  ; Find out whether RPL code is present at top of memory and modify the
   233                                  ; available amount of memory in AX
   234                                  ; leave the number of paragraphs of memory in ax.
   235                                  ;
   236                                  ; -------------------------------------------------------------------------
   237                                  ; copy code from start to top of memory.
   238                                  ;
   239                                  ; the length to copy is EndOfLoader
   240                                  ;
   241                                  ; jump to relocated code
   242                                  ; -------------------------------------------------------------------------
   243                                  
   244                                  relocate:				; ...
   245 000001DD FC                      		cld
   246 000001DE 31F6                    		xor	si, si
   247 000001E0 89F7                    		mov	di, si
   248 000001E2 CD12                    		int	12h		; MEMORY SIZE -
   249                                  					; Return: AX = number of contiguous 1K blocks of memory
   250 000001E4 B106                    		mov	cl, 6
   251 000001E6 D3E0                    		shl	ax, cl		; Memory size in paragraphs
   252                                  
   253                                  ;------ Check if an RPL program is present at TOM and do not tromp over it
   254                                  
   255                                  		; 10/12/2022
   256                                  		; dx = 0
   257                                  		;xor	bx, bx
   258                                  		;mov	ds, bx		; ZERO
   259                                  		
   260                                  		;mov	bx, [DskAddr+44h] ; 2Fh*4 (Int 2Fh)
   261                                  		;mov	ds, [DskAddr+46h] ; 2Fh*4+2
   262                                  		; 10/12/2022
   263 000001E8 8B1EBC00                		mov	bx, [2Fh*4]	; (Int 2Fh)
   264 000001EC 8E1EBE00                		mov	ds, [2Fh*4+2]		
   265                                  
   266                                  		;cmp	word ptr [bx+3], 'PR'
   267                                  		; 09/12/2022
   268 000001F0 817F035250              		cmp	word [bx+3], 'RP' ; 'RPL'
   269 000001F5 750F                    		jnz	short Skip_RPL
   270 000001F7 807F054C                		cmp	byte [bx+5], 'L'
   271 000001FB 7509                    		jnz	short Skip_RPL
   272 000001FD 89C2                    		mov	dx, ax		; get TOM into DX
   273 000001FF B8064A                  		mov	ax, 4A06h	; (multMULT shl	8) + multMULTRPLTOM
   274 00000202 CD2F                    		int	2Fh		; Get new TOM from any RPL
   275 00000204 89D0                    		mov	ax, dx
   276                                  Skip_RPL:				; ...
   277 00000206 B104                    		mov	cl, 4
   278 00000208 2E8B16[1B01]            		mov	dx, [cs:BytesPerSec]
   279 0000020D D3EA                    		shr	dx, cl
   280 0000020F 42                      		inc	dx
   281 00000210 29D0                    		sub	ax, dx
   282 00000212 2EA3[3501]              		mov	[cs:FatSegment], ax ; This will be used for fat sector
   283 00000216 BA[9405]                		mov	dx, EndOfLoader
   284 00000219 D3EA                    		shr	dx, cl
   285 0000021B 42                      		inc	dx
   286 0000021C 29D0                    		sub	ax, dx
   287 0000021E 8EC0                    		mov	es, ax		; ES:DI -> place be relocated.
   288                                  
   289 00000220 0E                      		push	cs
   290 00000221 1F                      		pop	ds		; DS:si -> sourc
   291 00000222 B9[9405]                		mov	cx, EndOfLoader
   292 00000225 F3A4                    		rep movsb
   293 00000227 06                      		push	es
   294 00000228 B8[2D02]                		mov	ax, SetupStack
   295 0000022B 50                      		push	ax		; Massage stack for destin of CS:IP
   296 0000022C CB                      		retf
   297                                  ; ---------------------------------------------------------------------------
   298                                  
   299                                  ; Start of relocated code
   300                                  ;----------------------------------------------------------------------------
   301                                  ;
   302                                  ; Move the stack to just under the boot record and relocation area (0:7c00h)
   303                                  ;
   304                                  
   305                                  SetupStack:				; ...
   306 0000022D 8CC8                    		mov	ax, cs		; Start	of relocated code
   307 0000022F 8ED0                    		mov	ss, ax
   308                                  		;mov	sp, NumHeads	; StackPtr offset
   309                                  		; 20/12/2022
   310 00000231 BC[0501]                		mov	sp, StackPtr	; StackPtr offset
   311                                  
   312                                  ; FindClusterSize
   313                                  ; ---------------------------------------------------------------------------
   314                                  ;
   315                                  ; INPUT:     bpb information in loaded boot record at 0:7c00h
   316                                  ;
   317                                  ; OUTPUT:
   318                                  ;
   319                                  ;	ds = 0
   320                                  ;	ax = bytes/cluster
   321                                  ;	bx = sectors/cluster
   322                                  ;	si destroyed
   323                                  ; calls:     none
   324                                  ;----------------------------------------------------------------------------
   325                                  ;
   326                                  ; get bytes/sector from bpb
   327                                  ;
   328                                  ; get sectors/cluster from bpb
   329                                  ;
   330                                  ; bytes/cluster = bytes/sector * sector/cluster
   331                                  ; ---------------------------------------------------------------------------
   332                                  
   333                                  FindClusterSize:
   334                                  
   335                                  ;for the time being just ASSUME the boot record is valid and the bpb is there.
   336                                  
   337 00000234 31C0                    		xor	ax, ax
   338 00000236 8ED8                    		mov	ds, ax
   339 00000238 A10B7C                  		mov	ax, [7C0Bh]	; get bpb bytes/sector
   340 0000023B 31DB                    		xor	bx, bx
   341 0000023D 8A1E0D7C                		mov	bl, [7C0Dh]	; get sectors/cluster
   342 00000241 F7E3                    		mul	bx
   343 00000243 2EA3[0701]              		mov	[cs:ClusterSize], ax
   344                                  
   345                                  ; CalcFatSize
   346                                  ; ---------------------------------------------------------------------------
   347                                  ;
   348                                  ; NOTES:
   349                                  ;
   350                                  ;   Determine if fat is 12 or 16 bit fat. 12 bit fat if floppy, read mbr
   351                                  ;   to find out what system id byte is.
   352                                  ;
   353                                  ; INPUT:
   354                                  ;
   355                                  ; OUTPUT:
   356                                  ;
   357                                  ;   CS:FatSize = FAT_12_BIT or FAT_16_BIT
   358                                  ;   all other registers destroyed
   359                                  ;
   360                                  ; ---------------------------------------------------------------------------
   361                                  
   362                                  CalcFatSize:
   363 00000247 2EC606[2E01]01          		mov	byte [cs:Fatsize], 1 ; FAT_12_BIT (assume)
   364 0000024D 2E8B16[2901]            		mov	dx, [cs:TotalSectorsH]
   365 00000252 2EA1[2701]              		mov	ax, [cs:TotalSectorsL] ; DX:AX = total disk sectors
   366 00000256 2E2B06[1D01]            		sub	ax, [cs:ReservSectors]
   367 0000025B 83DA00                  		sbb	dx, 0		; DX:AX	= Total	avail sectors
   368 0000025E 2E8B1E[1501]            		mov	bx, [cs:SecPerFat]
   369 00000263 D1E3                    		shl	bx, 1		; (Assume 2 FATs)
   370 00000265 29D8                    		sub	ax, bx
   371 00000267 83DA00                  		sbb	dx, 0
   372 0000026A 8B1E117C                		mov	bx, [7C11h]	; Root directory entry count
   373 0000026E B104                    		mov	cl, 4
   374 00000270 D3EB                    		shr	bx, cl		; BX = Total directory sectors
   375 00000272 29D8                    		sub	ax, bx
   376 00000274 83DA00                  		sbb	dx, 0		; DX:AX	= Sectors in data area
   377 00000277 31C9                    		xor	cx, cx
   378 00000279 8A0E0D7C                		mov	cl, [7C0Dh]	; Sectors per cluster
   379 0000027D 50                      		push	ax
   380 0000027E 89D0                    		mov	ax, dx
   381 00000280 31D2                    		xor	dx, dx
   382 00000282 F7F1                    		div	cx
   383 00000284 2EA3[0D01]              		mov	[cs:TempH], ax	; AX = Total number of clusters
   384 00000288 58                      		pop	ax
   385 00000289 F7F1                    		div	cx
   386 0000028B 3DF60F                  		cmp	ax, 4086	; 4096-10
   387 0000028E 7206                    		jb	short ReadInFirstClusters ; 12 bit FAT
   388 00000290 2EC606[2E01]04          		mov	byte [cs:Fatsize], 4 ; FAT_16_BIT
   389                                  
   390                                  ; ReadInFirstClusters
   391                                  ; ---------------------------------------------------------------------------
   392                                  ;
   393                                  ; NOTES: read the start of the clusters that covers at least IbmLoadSize
   394                                  ;	 fully.  for example, if sector/cluster = 2, and IbmLoadSize=3
   395                                  ;	 then we are going to re-read the second cluster to fully cover
   396                                  ;	 msload program in the cluster boundary.
   397                                  ;
   398                                  ; INPUT:
   399                                  ;   IbmLoadSize - make sure this value is the same as the one in
   400                                  ;		  msboot program when you build the new version!!!!!
   401                                  ;
   402                                  ;   SecPerCluster
   403                                  ;   ClusterSize
   404                                  ;   FirstSectorL
   405                                  ;   FirstSectorH
   406                                  ;
   407                                  ; OUTPUT: msload program is fully covered in a cluster boundary.
   408                                  ;	  ax = # of clusters we read in so far.
   409                                  ;
   410                                  ; calls:     ReadSectors
   411                                  ; logic:
   412                                  ;	ax; dx = IbmLoadSize / # of sector in a cluster.
   413                                  ;	if dx = 0 then ok. (msload is in a cluster boundary.)
   414                                  ;      else		   (has to read (ax+1)th cluster to cover msload)
   415                                  ;	read (ax+1)th cluster into the address after the clusters we
   416                                  ;	read in so far.
   417                                  ; ---------------------------------------------------------------------------
   418                                  
   419                                  ; 09/12/2022
   420                                  ; BiosStart equ 51Ah ; AX = IO.SYS starting cluster
   421                                  ; IbmLoadSize equ 3  ; AX = Number sectors in MSLOAD
   422                                  ; BiosOffset equ 700h ; Address where loader was read in
   423                                  	
   424                                  ReadInFirstClusters:
   425                                  		;mov	ax, [BioSStart]	; ...
   426 00000296 A11A05                  		mov	ax, [51Ah]	; IO.SYS First Cluster
   427 00000299 48                      		dec	ax		; Root dir buffer at 500h (segment=0)
   428                                  					; IO.SYS first cluster ptr at 51Ah
   429 0000029A 48                      		dec	ax		; AX = word [51Ah] - 2
   430 0000029B 2EA3[1F01]              		mov	[cs:CurrentCluster], ax ;  Initialize to this cluster
   431                                  		;mov	ax, IbmLoadSize
   432 0000029F B80300                  		mov	ax, 3		; Load the 3rd and other IO.SYS	sectors
   433 000002A2 2EF636[3701]            		div	byte [cs:SecPerCluster]
   434                                  					; AL = total cluster read in
   435                                  					; AH = remaining sectors in last cluster
   436                                  		; 10/12/2022
   437 000002A7 20E4                    		and	ah, ah
   438                                  		;cmp	ah, 0
   439 000002A9 745C                    		jz	short SetNextClusterNum	; next cluster
   440 000002AB 30E4                    		xor	ah, ah
   441 000002AD 50                      		push	ax		; AX = total clusters in the loader
   442                                  					; already read in
   443 000002AE 2E8B0E[2301]            		mov	cx, [cs:FirstSectorL] ;	Put starting sector of disk data
   444 000002B3 2E890E[0901]            		mov	[cs:StartSecL], cx    ; area in StartSecH:StartSecL
   445 000002B8 2E8B0E[2501]            		mov	cx, [cs:FirstSectorH]
   446 000002BD 2E890E[0B01]            		mov	[cs:StartSecH], cx
   447 000002C2 2EF626[3701]            		mul	byte [cs:SecPerCluster]
   448 000002C7 2E0106[0901]            		add	[cs:StartSecL], ax ; Add number of sectors already loaded
   449 000002CC 2E8316[0B01]00          		adc	word [cs:StartSecH], 0 ; to start sector
   450                                  		;mov	ax, [BiosStart]
   451 000002D2 A11A05                  		mov	ax, [51Ah] ; AX = [51Ah] = IO.SYS 1st clust
   452 000002D5 48                      		dec	ax
   453 000002D6 48                      		dec	ax
   454 000002D7 31DB                    		xor	bx, bx
   455 000002D9 2E8A1E[3701]            		mov	bl, [cs:SecPerCluster]
   456 000002DE F7E3                    		mul	bx		; DX:AX = logical start sector
   457 000002E0 2E0106[0901]            		add	[cs:StartSecL], ax
   458 000002E5 2E1116[0B01]            		adc	[cs:StartSecH], dx
   459                                  					; abs start sector for next read of
   460                                  					; the rest of the last loader cluster
   461 000002EA 58                      		pop	ax
   462 000002EB 50                      		push	ax
   463 000002EC 2EF726[0701]            		mul	word [cs:ClusterSize]
   464                                  		;mov	di, BiosOffset
   465 000002F1 BF0007                  		mov	di, 700h	; IO.SYS offset	(segment = 0)
   466 000002F4 01C7                    		add	di, ax
   467 000002F6 31C0                    		xor	ax, ax
   468 000002F8 8EC0                    		mov	es, ax		; ES = segment 0
   469 000002FA 2EA0[3701]              		mov	al, [cs:SecPerCluster]
   470                                  					; Read in the entire last cluster
   471 000002FE 2EA3[1301]              		mov	[cs:SectorCount], ax
   472 00000302 E8A200                  		call	ReadSectors
   473 00000305 58                      		pop	ax		; AX = total clust read	by boot	loader
   474 00000306 40                      		inc	ax		; AX = total clust read	in now
   475                                  SetNextClusterNum:			; ...
   476 00000307 40                      		inc	ax		; AX = total clusters read in based 2
   477 00000308 2E0106[1F01]            		add	[cs:CurrentCluster], ax
   478 0000030D 48                      		dec	ax		; CurrentCluster = Last	cluster	read
   479                                  					; AX = number of clusters loaded
   480                                  
   481                                  ; SaveLoadedBios
   482                                  ; ---------------------------------------------------------------------------
   483                                  ;
   484                                  ; NOTES:
   485                                  ;
   486                                  ;   Determine how much of iosys was loaded in when the loader was loaded
   487                                  ;   by the boot record (only the portion that is guaranteed to be contiguous)
   488                                  ;
   489                                  ; INPUT:
   490                                  ;   AX:Total cluster already read in (loader & bios)
   491                                  ;   CS:CurrentCluster = number of clusters used for loader+2
   492                                  ;
   493                                  ; OUTPUT:
   494                                  ;	ES = 70h
   495                                  ;	DI = next offset to load iosys code
   496                                  ;	AX,BX,CX,DX,SI destroyed
   497                                  ;
   498                                  ;	CS:NextBioLocation = di on output
   499                                  ;	CS:last_cluster = last cluster loaded
   500                                  ;
   501                                  ; calls:     none
   502                                  ;
   503                                  ; ---------------------------------------------------------------------------
   504                                  ;
   505                                  ; Multiply cluster * cluster size in bytes to get total loaded for msload
   506                                  ;
   507                                  ; Subtract total_loaded - (EndOfLoader) to get loaded io.sys in last cluster
   508                                  ;
   509                                  ; Relocate this piece of iosys down to 70:0
   510                                  ;
   511                                  ; ---------------------------------------------------------------------------
   512                                  
   513                                  SaveLoadedBios:
   514 0000030E 1E                      		push	ds
   515 0000030F 2EF726[0701]            		mul	word [cs:ClusterSize]
   516                                  					; Get total bytes loaded by
   517                                  					; this is always < 64k, so
   518                                  					; lower 16 bits ok
   519                                  
   520 00000314 2D[9405]                		sub	ax, EndOfLoader ; (OFFSET EndOfLoader)-(OFFSET Start)
   521 00000317 89C1                    		mov	cx, ax
   522 00000319 B87000                  		mov	ax, 70h		; Segment at 70h
   523 0000031C 8ED8                    		mov	ds, ax
   524 0000031E 8EC0                    		mov	es, ax
   525 00000320 BE[9405]                		mov	si, EndOfLoader ; EndOfLoader
   526 00000323 31FF                    		xor	di, di
   527 00000325 F3A4                    		rep movsb		; Relocate this code to 0070h:0000h
   528 00000327 2E893E[2101]            		mov	[cs:NextBioLocation], di
   529 0000032C 1F                      		pop	ds		; Save where location for next read
   530                                  
   531                                  ; GetContigClusters
   532                                  ; ---------------------------------------------------------------------------
   533                                  ;
   534                                  ; NOTES: go find clusters as long as they are contiguous
   535                                  ;
   536                                  ;
   537                                  ; INPUT:
   538                                  ;   CS:NextBioLocation
   539                                  ;   CS:
   540                                  ;
   541                                  ; OUTPUT:
   542                                  ;
   543                                  ; calls: GetNextFatEntry
   544                                  ; ---------------------------------------------------------------------------
   545                                  ;
   546                                  ;Set CS:SectorCount to sectors per cluster
   547                                  ;
   548                                  ;Call GetNextFatEntry to get next cluster in file
   549                                  ;
   550                                  ;Call check_for_eof
   551                                  ;
   552                                  ;if (nc returned)
   553                                  ;
   554                                  ;   {call GetNextFatEntry
   555                                  ;
   556                                  ;    if (new cluster is contig to old cluster)
   557                                  ;	{add sectors per cluster to CS:SectorCount
   558                                  ;
   559                                  ;	 call check_for_eof
   560                                  ;
   561                                  ;	 if (nc returned)
   562                                  ;
   563                                  ; ---------------------------------------------------------------------------
   564                                  
   565                                  ; 09/12/2022
   566                                  ; END_OF_FILE equ 0FFh
   567                                  ; DosLoadSeg equ 70h
   568                                  
   569                                  GetContigClusters:			; ...
   570 0000032D 30E4                    		xor	ah, ah
   571 0000032F 2EA0[3701]              		mov	al, [cs:SecPerCluster]	; Assume we will get one cluster
   572 00000333 2EA3[1301]              		mov	[cs:SectorCount], ax	; Sector count = sectors in 1 cluster
   573 00000337 2EFF36[1301]            		push	word [cs:SectorCount]
   574 0000033C E81401                  		call	GetNextFatEntry		; Returns next cluster to read in AX	
   575 0000033F 2E8F06[1301]            		pop	word [cs:SectorCount]
   576 00000344 2EA3[1F01]              		mov	word [cs:CurrentCluster], ax ; Update the last one found
   577 00000348 2E803E[3001]FF          		cmp	byte [cs:EndOfFile], 0FFh ; END_OF_FILE
   578 0000034E 743F                    		jz	short GoToBioInit
   579 00000350 31D2                    		xor	dx, dx
   580                                  		;sub	ax, 2			; Zero base the cluster
   581                                  		; 10/12/2022
   582 00000352 48                      		dec	ax
   583 00000353 48                      		dec	ax
   584 00000354 30ED                    		xor	ch, ch
   585 00000356 2E8A0E[3701]            		mov	cl, [cs:SecPerCluster]
   586 0000035B F7E1                    		mul	cx			; How many sectors (before next cluster) 
   587 0000035D 2E0306[2301]            		add	ax, [cs:FirstSectorL]	; See where the data sector starts
   588 00000362 2E1316[2501]            		adc	dx, [cs:FirstSectorH]
   589 00000367 2EA3[0901]              		mov	[cs:StartSecL], ax	; Save it (used by ReadSectors)
   590 0000036B 2E8916[0B01]            		mov	[cs:StartSecH], dx
   591 00000370 2E8B3E[2101]            		mov	di, [cs:NextBioLocation] ; Get where to put code
   592 00000375 2EFF36[1301]            		push	word [cs:SectorCount]	; Save how many sectors
   593                                  		;mov	ax, DosLoadSeg
   594 0000037A B87000                  		mov	ax, 70h
   595 0000037D 8EC0                    		mov	es, ax
   596 0000037F E82500                  		call	ReadSectors
   597 00000382 58                      		pop	ax			; Get back total sectors read in
   598 00000383 2EF726[1B01]            		mul	word [cs:BytesPerSec]	; Get number of bytes we loaded
   599 00000388 2E0106[2101]            		add	[cs:NextBioLocation], ax ; Point to where to load next	
   600 0000038D EB9E                    		jmp	short GetContigClusters
   601                                  ; ---------------------------------------------------------------------------
   602                                  
   603                                  ; GoToBiosInit
   604                                  ; ---------------------------------------------------------------------------
   605                                  ;
   606                                  ; NOTES:
   607                                  ;
   608                                  ;  Set up required registers for iosys, then jump to it (70:0)
   609                                  ;
   610                                  ; INPUT:     none
   611                                  ;
   612                                  ;   CS:MediaByte = media byte
   613                                  ;   CS:BootDrive = int 13 drive number we booted from
   614                                  ;   CS:FirstSectorL = first data sector on disk (low) (0-based)
   615                                  ;   CS:FirstSectorH = first data sector on disk (high)
   616                                  ;
   617                                  ; OUTPUT:
   618                                  ;
   619                                  ;   required by msinit
   620                                  ;   DL = int 13 drive number we booted from
   621                                  ;   CH = media byte
   622                                  ;   BX = first data sector on disk (0-based)
   623                                  ;   AX = first data sector on disk (high)
   624                                  ;   DI = sectors/fat for the boot media.
   625                                  ;
   626                                  ; calls:     none
   627                                  ; ---------------------------------------------------------------------------
   628                                  ;
   629                                  ; set up registers for msinit then do far jmp
   630                                  ;
   631                                  ; ---------------------------------------------------------------------------
   632                                  
   633                                  GoToBioInit:				; ...
   634 0000038F 2E8A2E[2F01]            		mov	ch, [cs:MediaByte] ; Restore regs required for msint
   635 00000394 2E8A16[2D01]            		mov	dl, [cs:BootDrive] ; Physical drv number we booted from.
   636 00000399 2E8B1E[2301]            		mov	bx, [cs:FirstSectorL] ; BX:AX = first data sector of disk
   637 0000039E 2EA1[2501]              		mov	ax, [cs:FirstSectorH]
   638 000003A2 EA00007000              		jmp	70h:0	; Far jump to IoSysAddr	(DOSBIOS)
   639                                  
   640                                  ; =============== S U B	R O U T	I N E =======================================
   641                                  
   642                                  ; ReadSectors
   643                                  ; ---------------------------------------------------------------------------
   644                                  ; notES:
   645                                  ;
   646                                  ;  read in the CS:SectorCount number of sectors at ES:di
   647                                  ;
   648                                  ;
   649                                  ; INPUT:
   650                                  ;
   651                                  ;   DI = OFFSET of start of read
   652                                  ;   ES = segment of read
   653                                  ;   CS:SectorCount = number of sectors to read
   654                                  ;   CS:StartSecL = starting sector (low)
   655                                  ;   CS:StartSecH = starting sector (high)
   656                                  ;   following is bpb info that must be setup prior to call
   657                                  ;   CS:NumHeads
   658                                  ;   CS:number_of_sectors
   659                                  ;   CS:BootDrive
   660                                  ;   CS:SecPerTrack
   661                                  ;
   662                                  ; OUTPUT:
   663                                  ;
   664                                  ;   AX,BX,CX,DX,SI,DI destroyed
   665                                  ; ---------------------------------------------------------------------------
   666                                  ; divide start sector by sectors per track
   667                                  ; the remainder is the actual sector number, 0 based
   668                                  ;
   669                                  ; increment actual sector number to get 1 based
   670                                  ;
   671                                  ; the quotient is the number of tracks - divide by heads to get the cyl
   672                                  ;
   673                                  ; the remainder is actual head, the quotient is cylinder
   674                                  ;
   675                                  ; figure the number of sectors in that track, set al to this
   676                                  ;
   677                                  ; do the read
   678                                  ;
   679                                  ; if error, do reset, then redo the int 13h
   680                                  ;
   681                                  ; if successful read, subtract # sectors read from SectorCount, add to logical
   682                                  ; sector, add #sectors read * BytesPerSec to bx;
   683                                  ;
   684                                  ; if SectorCount <> 0 do next read
   685                                  ; ---------------------------------------------------------------------------
   686                                  
   687                                  ReadSectors:
   688                                  DoDivide:					; ...
   689 000003A7 B90500                  		mov	cx, 5			; 5 retries
   690                                  
   691                                  		; Convert a logical sector into track/sector/head. AX has the
   692                                  		; logical sector number
   693                                  TryRead:					; ...
   694 000003AA 51                      		push	cx
   695 000003AB 2EA1[0901]              		mov	ax, [cs:StartSecL]	; Get starting sector
   696 000003AF 2E8B16[0B01]            		mov	dx, [cs:StartSecH]
   697 000003B4 50                      		push	ax
   698 000003B5 89D0                    		mov	ax, dx
   699 000003B7 31D2                    		xor	dx, dx
   700 000003B9 2EF736[2B01]            		div	word [cs:SecPerTrack]	
   701 000003BE 2EA3[0D01]              		mov	[cs:TempH], ax
   702 000003C2 58                      		pop	ax
   703 000003C3 2EF736[2B01]            		div	word [cs:SecPerTrack]	; [TempH]:ax = track,
   704                                  						; dx = sector number
   705 000003C8 2E8B1E[2B01]            		mov	bx, [cs:SecPerTrack]	; Get number of sectors we can
   706                                  						; read in this track
   707 000003CD 29D3                    		sub	bx, dx
   708 000003CF 89DE                    		mov	si, bx
   709 000003D1 2E3936[1301]            		cmp	[cs:SectorCount], si	; Is possible sectors in track more
   710 000003D6 7305                    		jnb	short GotLength		; than what we need to read?
   711 000003D8 2E8B36[1301]            		mov	si, [cs:SectorCount]	; Yes, only read what we need to
   712                                  GotLength:				; ...
   713                                  		;inc	dl			; Sector numbers are 1-based
   714                                  		; 18/12/2022
   715 000003DD 42                      		inc	dx
   716 000003DE 88D3                    		mov	bl, dl			; Start sector in BL
   717 000003E0 2E8B16[0D01]            		mov	dx, [cs:TempH]		; DX:AX = Track
   718 000003E5 50                      		push	ax
   719 000003E6 89D0                    		mov	ax, dx
   720 000003E8 31D2                    		xor	dx, dx
   721 000003EA 2EF736[0501]            		div	word [cs:NumHeads]	; Start cyl in AX, head in dl
   722 000003EF 2EA3[0D01]              		mov	[cs:TempH], ax
   723 000003F3 58                      		pop	ax
   724 000003F4 2EF736[0501]            		div	word [cs:NumHeads]	; [TempH]:AX = Cylinder, DX = Head
   725                                  
   726                                  			; At this moment, we assume that TempH = 0,
   727                                  			; ax <= 1024, dx <= 255
   728                                  
   729 000003F9 88D6                    		mov	dh, dl
   730                                  		
   731 000003FB B106                    		mov	cl, 6
   732 000003FD D2E4                    		shl	ah, cl			; Shift cyl high bits up
   733 000003FF 08DC                    		or	ah, bl			; Mix in with sector bits
   734 00000401 88C5                    		mov	ch, al			; Setup cyl low
   735 00000403 88E1                    		mov	cl, ah			; Setup cyl/high - sector
   736 00000405 89FB                    		mov	bx, di			; Get back OFFSET
   737 00000407 2E8A16[2D01]            		mov	dl, [cs:BootDrive]	; Get drive
   738 0000040C 89F0                    		mov	ax, si			; Get number of sectors to read (al)
   739 0000040E B402                    		mov	ah, 2			; Read sectors
   740 00000410 50                      		push	ax
   741 00000411 57                      		push	di
   742                                  
   743                                  			; Issue one read request. ES:BX have the transfer address,
   744                                  			; AL is the number of sectors.	
   745                                  
   746 00000412 CD13                    		int	13h		; DISK - READ SECTORS INTO MEMORY
   747                                  					; AL = number of sectors to read, CH = track, CL = sector
   748                                  					; DH = head, DL	= drive, ES:BX -> buffer to fill
   749                                  					; Return: CF set on error, AH =	status,	AL = number of sectors read
   750 00000414 5F                      		pop	di
   751 00000415 58                      		pop	ax
   752 00000416 59                      		pop	cx		; Get retry count back
   753 00000417 7318                    		jnb	short ReadOk
   754 00000419 89FB                    		mov	bx, di		; Get offset
   755 0000041B 30E4                    		xor	ah, ah
   756 0000041D 51                      		push	cx
   757 0000041E 2E8A16[2D01]            		mov	dl, [cs:BootDrive]
   758 00000423 57                      		push	di
   759 00000424 CD13                    		int	13h		; DISK - RESET DISK SYSTEM
   760                                  					; DL = drive (if bit 7 is set both hard	disks and floppy disks reset)
   761 00000426 5F                      		pop	di
   762 00000427 59                      		pop	cx
   763 00000428 49                      		dec	cx
   764 00000429 7403                    		jz	short ReadError
   765 0000042B E97CFF                  		jmp	TryRead
   766                                  ; ---------------------------------------------------------------------------
   767                                  
   768                                  ReadError:				; ...
   769 0000042E E9F000                  		jmp	ErrorOut
   770                                  ; ---------------------------------------------------------------------------
   771                                  
   772                                  ReadOk:					; ...
   773 00000431 30E4                    		xor	ah, ah		; Mask out read command, just get # read
   774 00000433 2E2906[1301]            		sub	[cs:SectorCount], ax ; Bump number down
   775 00000438 7418                    		jz	short EndRead
   776 0000043A 2E0106[0901]            		add	[cs:StartSecL], ax	; Where to start next time
   777 0000043F 2E8316[0B01]00          		adc	word [cs:StartSecH], 0
   778                                  		;xor	bx, bx			; Get number sectors read
   779                                  		;mov	bl, al
   780                                  		; 10/12/2022
   781 00000445 89C3                    		mov	bx, ax
   782 00000447 2EA1[1B01]              		mov	ax, [cs:BytesPerSec]	; Bytes per sector
   783 0000044B F7E3                    		mul	bx			; Get total bytes read	
   784 0000044D 01C7                    		add	di, ax			; Add it to OFFSET
   785                                  		;jmp	DoDivide	; 09/12/2022
   786 0000044F E955FF                  		jmp	ReadSectors
   787                                  ; ---------------------------------------------------------------------------
   788                                  	
   789                                  EndRead:				; ...
   790 00000452 C3                      		retn
   791                                  
   792                                  ; =============== S U B	R O U T	I N E =======================================
   793                                  
   794                                  ; GetNextFatEntry
   795                                  ; ---------------------------------------------------------------------------
   796                                  ;
   797                                  ; NOTES:
   798                                  ;
   799                                  ;   given the last cluster found, this will return the next cluster of
   800                                  ;   iosys. if the last cluster is (f)ff8 - (f)fff, then the final cluster
   801                                  ;   of iosys has been loaded, and control is passed to goto_iosys
   802                                  ;   msload can handle maximum fat area size of 128 kb.
   803                                  ;
   804                                  ; INPUT:
   805                                  ;
   806                                  ;    CS:CurrentCluster
   807                                  ;    CS:FatSize
   808                                  ;
   809                                  ; OUTPUT:
   810                                  ;
   811                                  ;   CS:CurrentCluster (updated)
   812                                  ;
   813                                  ; calls:  GetFatSector
   814                                  ; ---------------------------------------------------------------------------
   815                                  ; get CurrentCluster
   816                                  ;
   817                                  ; if (16 bit fat)
   818                                  ;    {if (CurrentCluster = fff8 - ffff)
   819                                  ;	 {jmp goto_iosys}
   820                                  ;     else
   821                                  ;	{get OFFSET by multiply cluster by 2}
   822                                  ;
   823                                  ; else
   824                                  ;    {if (CurrentCluster = ff8 - fff)
   825                                  ;	 {jmp goto_iosys}
   826                                  ;     else
   827                                  ;	{get OFFSET by	- multiply cluster by 3
   828                                  ;
   829                                  ;	 rotate right to divide by 2
   830                                  ;
   831                                  ;	 if (cy set - means odd number)
   832                                  ;	    {shr 4 times to keep high twelve bits}
   833                                  ;
   834                                  ;	 else
   835                                  ;	    {and with 0fffh to keep low 12 bits}
   836                                  ;	}
   837                                  ;    }
   838                                  ;
   839                                  ; ---------------------------------------------------------------------------
   840                                  
   841                                  ; 09/12/2022
   842                                  ; FAT_12_BIT equ 1
   843                                  ; NOT_END_OF_FILE equ 0  ; ~END_OF_FILE ; END_OF_FILE equ 0FFh
   844                                  
   845                                  GetNextFatEntry:			; ...
   846 00000453 06                      		push	es
   847 00000454 2EA1[3501]              		mov	ax, [cs:FatSegment]
   848 00000458 8EC0                    		mov	es, ax		; ES-> FAT area segment
   849                                  		; 09/12/2022
   850                                  		;mov	byte [cs:EndOfFile], END_OF_FILE
   851 0000045A 2EC606[3001]FF          		mov	byte [cs:EndOfFile], 0FFh ; Assume last cluster
   852 00000460 2EA1[1F01]              		mov	ax, [cs:CurrentCluster] ; Get last cluster
   853                                  		;cmp	byte [cs:FatSize], FAT_12_BIT
   854 00000464 2E803E[2E01]01          		cmp	byte [cs:Fatsize], 1
   855 0000046A 7547                    		jnz	short Got16Bit
   856 0000046C 89C6                    		mov	si, ax
   857 0000046E D1E8                    		shr	ax, 1
   858 00000470 01C6                    		add	si, ax		 ; SI = AX * 1.5 = AX + AX/2
   859 00000472 52                      		push	dx
   860 00000473 31D2                    		xor	dx, dx
   861 00000475 E85900                  		call	GetFatSector
   862 00000478 5A                      		pop	dx
   863 00000479 751D                    		jnz	short ClusterOk
   864 0000047B 268A07                  		mov	al, [es:bx]
   865 0000047E 2EA2[0F01]              		mov	[cs:TempCluster], al
   866 00000482 46                      		inc	si
   867 00000483 52                      		push	dx
   868 00000484 31D2                    		xor	dx, dx
   869 00000486 E84800                  		call	GetFatSector	; Read next fat sector
   870 00000489 5A                      		pop	dx
   871 0000048A 26A00000                		mov	al, [es:0]
   872 0000048E 2EA2[1001]              		mov	[cs:TempCluster+1], al
   873 00000492 2EA1[0F01]              		mov	ax, [cs:TempCluster]
   874 00000496 EB03                    		jmp	short EvenOdd
   875                                  ; ---------------------------------------------------------------------------
   876                                  
   877                                  ClusterOk:				; ...
   878 00000498 268B07                  		mov	ax, [es:bx]
   879                                  EvenOdd:	
   880                                  		; 10/12/2022		; ...
   881 0000049B 2EF606[1F01]01          		test	byte [cs:CurrentCluster], 1 ; 09/12/2022
   882                                  		;test	word [cs:CurrentCluster], 1 ; Was last cluster odd?
   883 000004A1 7505                    		jnz	short OddResult		; If not zero it was odd
   884 000004A3 25FF0F                  		and	ax, 0FFFh		; Keep low 12 bits
   885 000004A6 EB04                    		jmp	short TestEOF
   886                                  ; ---------------------------------------------------------------------------
   887                                  
   888                                  OddResult:				; ...
   889 000004A8 B104                    		mov	cl, 4			; Keep high 12 bits for odd
   890 000004AA D3E8                    		shr	ax, cl
   891                                  TestEOF:				; ...
   892 000004AC 3DF80F                  		cmp	ax, 0FF8h		; Is it last cluster?
   893 000004AF 731E                    		jnb	short GotClusterDone	; Yep, all done here
   894 000004B1 EB16                    		jmp	short NotLastCluster
   895                                  ; ---------------------------------------------------------------------------
   896                                  
   897                                  Got16Bit:				; ...
   898 000004B3 52                      		push	dx
   899 000004B4 31D2                    		xor	dx, dx
   900 000004B6 D1E0                    		shl	ax, 1			; Multiply cluster by 2
   901 000004B8 83D200                  		adc	dx, 0
   902 000004BB 89C6                    		mov	si, ax			; Get the final buffer OFFSET
   903 000004BD E81100                  		call	GetFatSector
   904 000004C0 5A                      		pop	dx
   905 000004C1 268B07                  		mov	ax, [es:bx]
   906 000004C4 83F8F8                  		cmp	ax, 0FFF8h
   907 000004C7 7306                    		jnb	short GotClusterDone
   908                                  NotLastCluster:				; ...
   909                                  		;mov	byte [cs:EndOfFile], NOT_END_OF_FILE ; ~END_OF_FILE
   910 000004C9 2EC606[3001]00          		mov	byte [cs:EndOfFile], 0	; Assume not last cluster
   911                                  
   912                                  GotClusterDone:				; ...
   913 000004CF 07                      		pop	es
   914 000004D0 C3                      		retn
   915                                  
   916                                  ; =============== S U B	R O U T	I N E =======================================
   917                                  
   918                                  ; GetFatSector
   919                                  ; ---------------------------------------------------------------------------
   920                                  ;function: find and read the corresponding fat sector into ES:0
   921                                  ;
   922                                  ;in). SI = offset value (starting from fat entry 0) of fat entry to find.
   923                                  ;     ES = fat sector segment
   924                                  ;     CS:BytesPerSec
   925                                  ;
   926                                  ;out). corresponding fat sector read in.
   927                                  ;      BX = offset value of the corresponding fat entry in the fat sector.
   928                                  ;      CX destroyed.
   929                                  ;      zero flag set if the fat entry is splitted, i.e. when 12 bit fat entry
   930                                  ;      starts at the last byte of the fat sector.  in this case, the caller
   931                                  ;      should save this byte, and read the next fat sector to get the rest
   932                                  ;      of the fat entry value.	(this will only happen with the 12 bit fat).
   933                                  ;
   934                                  ; ---------------------------------------------------------------------------
   935                                  
   936                                  GetFatSector:				; ...
   937 000004D1 50                      		push	ax
   938 000004D2 56                      		push	si
   939 000004D3 57                      		push	di
   940 000004D4 89F0                    		mov	ax, si
   941 000004D6 2E8B0E[1B01]            		mov	cx, [cs:BytesPerSec]
   942 000004DB F7F1                    		div	cx			; AX = Sector number, DX = Offset
   943 000004DD 2E3B06[1101]            		cmp	ax, [cs:LastFatSector]	; The same fat sector?
   944 000004E2 7434                    		jz	short SplitChk		; Don't need to read it again.
   945 000004E4 2EA3[1101]              		mov	[cs:LastFatSector], ax
   946 000004E8 52                      		push	dx
   947 000004E9 31D2                    		xor	dx, dx
   948 000004EB 2E0306[1701]            		add	ax, [cs:HiddenSectorsL]
   949 000004F0 2E1316[1901]            		adc	dx, [cs:HiddenSectorsH]
   950 000004F5 2E0306[1D01]            		add	ax, [cs:ReservSectors]
   951 000004FA 83D200                  		adc	dx, 0
   952 000004FD 2EA3[0901]              		mov	[cs:StartSecL], ax
   953 00000501 2E8916[0B01]            		mov	[cs:StartSecH], dx	; Set up for ReadSectors
   954                                  					; ...
   955 00000506 2EC706[1301]0100        		mov	word [cs:SectorCount], 1 ; 1 sector
   956 0000050D 31FF                    		xor	di, di
   957 0000050F E895FE                  		call	ReadSectors
   958 00000512 5A                      		pop	dx
   959 00000513 2E8B0E[1B01]            		mov	cx, [cs:BytesPerSec]
   960                                  SplitChk:				; ...
   961 00000518 49                      		dec	cx			; CX = SECTOR SIZE - 1
   962 00000519 39CA                    		cmp	dx, cx			; If last byte of sector, splitted entry.
   963 0000051B 89D3                    		mov	bx, dx			; set bx to dx
   964 0000051D 5F                      		pop	di
   965 0000051E 5E                      		pop	si
   966 0000051F 58                      		pop	ax
   967                                  EndWrite:		; 10/12/2022
   968 00000520 C3                      		retn
   969                                  
   970                                  ; ---------------------------------------------------------------------------
   971                                  
   972                                  ErrorOut:				; ...
   973 00000521 0E                      		push	cs
   974 00000522 1F                      		pop	ds
   975 00000523 BE[4C05]                		mov	si, NonSystemDiskMsg ; "\r\nNon-System disk or disk error\r\nRe"...
   976 00000526 E81600                  		call	WriteTTY
   977                                  
   978                                  		; Wait for a keypress on the keyboard.
   979                                  		; Use the bios keyboard interrupt.
   980                                  
   981 00000529 30E4                    		xor	ah, ah
   982 0000052B CD16                    		int	16h		; KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY
   983                                  					; Return: AH = scan code, AL = character
   984                                  
   985                                  		; We have to restore the address of the original rom disk
   986                                  		; parameter table to the location at [0:DskAddr]. The address
   987                                  		; of this original table has been saved previously in
   988                                  		; 0:OrgDasdPtr and 0:OrgDasdPtr+2. After this table address
   989                                  		; has been restored we can reboot by invoking the bootstrap
   990                                  		; loader bios interrupt.
   991                                  
   992 0000052D 31DB                    		xor	bx, bx
   993 0000052F 8EDB                    		mov	ds, bx
   994 00000531 C41E[3101]              		les	bx, [OrgDasdPtr]
   995 00000535 BE7800                  		mov	si, DskAddr	; (Int 1Eh)
   996 00000538 891C                    		mov	[si], bx	; restore offset		
   997 0000053A 8C4402                  		mov	[si+2], es	; restore segment
   998 0000053D CD19                    		int	19h		; reboot
   999                                  
  1000                                  ; =============== S U B	R O U T	I N E =======================================
  1001                                  
  1002                                  ; WriteTTY
  1003                                  ; ---------------------------------------------------------------------------
  1004                                  ; in) DS:si -> asciiz string.
  1005                                  ;
  1006                                  ; WriteTTY the character in al to the screen.
  1007                                  ; use video service 'write teletype to active page' (ROM_TTY)
  1008                                  ; use normal character attribute
  1009                                  ; ---------------------------------------------------------------------------
  1010                                  
  1011                                  WriteTTY:				; ...
  1012 0000053F AC                      		lodsb
  1013 00000540 08C0                    		or	al, al
  1014 00000542 74DC                    		jz	short EndWrite
  1015                                  		;mov	AH, ROM_TTY	; 09/12/2022
  1016 00000544 B40E                    		mov	ah, 0Eh
  1017 00000546 B307                    		mov	bl, 7		; "normal" attribute
  1018 00000548 CD10                    		int	10h		; - VIDEO - WRITE CHARACTER AND	ADVANCE	CURSOR (TTY WRITE)
  1019                                  					; AL = character, BH = display page (alpha modes)
  1020                                  					; BL = foreground color	(graphics modes)
  1021 0000054A EBF3                    		jmp	short WriteTTY
  1022                                  ; ---------------------------------------------------------------------------
  1023                                  
  1024                                  ; 10/12/2022	
  1025                                  ;EndWrite:				; ...
  1026                                  ;		retn
  1027                                  
  1028                                  ; ---------------------------------------------------------------------------
  1029                                  
  1030                                  ; 09/12/2022
  1031                                  ;include msbio.cl1
  1032                                  
  1033                                  		; 20/12/2022
  1034                                  		; 18/12/2022
  1035                                  		;db 0	; (word alignment)
  1036                                  NonSystemDiskMsg:
  1037 0000054C 0D0A                    		db 0Dh,0Ah		; ...
  1038 0000054E 4E6F6E2D5379737465-     		db 'Non-System disk or disk error',0Dh,0Ah
  1038 00000557 6D206469736B206F72-
  1038 00000560 206469736B20657272-
  1038 00000569 6F720D0A           
  1039 0000056D 5265706C6163652061-     		db 'Replace and press any key when ready',0Dh,0Ah,0
  1039 00000576 6E6420707265737320-
  1039 0000057F 616E79206B65792077-
  1039 00000588 68656E207265616479-
  1039 00000591 0D0A00             
  1040                                  EndOfLoader:
  1041                                  		;dw 01A1h	; 10/12/2022
  1042                                  
  1043                                  ; ---------------------------------------------------------------------------
