DOSBIOS:0000 ;
DOSBIOS:0000 ; +-------------------------------------------------------------------------+
DOSBIOS:0000 ; |   This	file has been generated	by The Interactive Disassembler	(IDA)	 |
DOSBIOS:0000 ; |	   Copyright (c) 2013 Hex-Rays,	<support@hex-rays.com>		 |
DOSBIOS:0000 ; |		      Licensed to: Freeware version			 |
DOSBIOS:0000 ; +-------------------------------------------------------------------------+
DOSBIOS:0000 ;
DOSBIOS:0000 ; Input MD5   : B2FA03653E5C5D545327EE28B8A24356
DOSBIOS:0000 ; Input CRC32 : 20FC79BF
DOSBIOS:0000
DOSBIOS:0000 ; ---------------------------------------------------------------------------
DOSBIOS:0000
DOSBIOS:0000		     .386
DOSBIOS:0000		     .model flat
DOSBIOS:0000
DOSBIOS:0000 ; ===========================================================================
DOSBIOS:0000
DOSBIOS:0000 ; Segment type: Pure code
DOSBIOS:0000 DOSBIOS	     segment byte public 'CODE' use16
DOSBIOS:0000		     assume cs:DOSBIOS
DOSBIOS:0000		     assume es:nothing,	ss:nothing, ds:nothing,	fs:nothing, gs:nothing
DOSBIOS:0000
DOSBIOS:0000 BData_start:			     ; DATA XREF: DOSBIOS:1A1Fw
DOSBIOS:0000		     jmp     init	     ; MSBIO1.ASM, MSSBDATA.INC
DOSBIOS:0000 ; ---------------------------------------------------------------------------
DOSBIOS:0003 DosDataSg	     dw	0		     ; DATA XREF: cdev_entry+9r
DOSBIOS:0003					     ; DOSBIOS:1CCEw
DOSBIOS:0005 bios_i2f	     db	0EAh		     ; far jump	to int_2f (segment may not be at 70h)
DOSBIOS:0006 off_706	     dw	offset int_2f
DOSBIOS:0008 word_708	     dw	70h		     ; KERNEL_SEGMENT
DOSBIOS:000A romstartaddr    dw	0
DOSBIOS:000C altah	     db	0		     ; DATA XREF: DOSBIOS:cbreakw
DOSBIOS:000C					     ; DOSBIOS:08BAo ...
DOSBIOS:000D inHMA	     db	0		     ; DATA XREF: cdev_entryr
DOSBIOS:000D					     ; DOSBIOS:block13r ...
DOSBIOS:000E xms	     dd	0		     ; DATA XREF: EnableA20+4r
DOSBIOS:000E					     ; DOSBIOS:07F3r
DOSBIOS:0012 ptrsav	     dd	0		     ; DATA XREF: strategyw
DOSBIOS:0012					     ; DOSBIOS:25D2r ...
DOSBIOS:0016 auxbuf	     db	4 dup(0)	     ; DATA XREF: getbx+4o
DOSBIOS:001A zeroseg	     dw	0		     ; DATA XREF: DOSBIOS:07FDr
DOSBIOS:001A					     ; checksingle+45r	...
DOSBIOS:001C i13_ds	     dw	0		     ; DATA XREF: DOSBIOS:skipa20w
DOSBIOS:001C					     ; DOSBIOS:078Fr ...
DOSBIOS:001E prevoper	     dw	0		     ; DATA XREF: DOSBIOS:ps2_special_stuffr
DOSBIOS:001E					     ; DOSBIOS:3AA9r ...
DOSBIOS:0020 number_of_sec   db	0		     ; DATA XREF: DOSBIOS:3B2Cw
DOSBIOS:0020					     ; DOSBIOS:ok11_opw
DOSBIOS:0021 auxnum	     dw	0		     ; DATA XREF: DOSBIOS:25C9w
DOSBIOS:0021					     ; prnopr ...
DOSBIOS:0023 res_dev_list    dw	offset auxdev2	     ; DATA XREF: DOSBIOS:19C4o
DOSBIOS:0023					     ; ConHeader:
DOSBIOS:0025		     dw	70h		     ; Device Header for the CON Device	Driver
DOSBIOS:0027 word_727	     dw	8013h
DOSBIOS:0029		     dw	offset strategy
DOSBIOS:002B		     dw	offset con_entry
DOSBIOS:002D aCon	     db	'CON     '           ; DATA XREF: DOSBIOS:_seg_reinitr
DOSBIOS:002D					     ; DOSBIOS:25C1r ...
DOSBIOS:0035 auxdev2	     dw	offset prndev2	     ; DATA XREF: DOSBIOS:res_dev_listo
DOSBIOS:0037		     dw	70h
DOSBIOS:0039		     dw	8000h
DOSBIOS:003B		     dw	offset strategy
DOSBIOS:003D		     dw	offset aux0_entry
DOSBIOS:003F aAux	     db	'AUX     '
DOSBIOS:0047 prndev2	     dw	offset timdev	     ; DATA XREF: DOSBIOS:auxdev2o
DOSBIOS:0049		     dw	70h
DOSBIOS:004B word_74B	     dw	0A0C0h
DOSBIOS:004D		     dw	offset strategy
DOSBIOS:004F		     dw	offset prn0_entry
DOSBIOS:0051 aPrn	     db	'PRN     '
DOSBIOS:0059 timdev	     dw	offset dskdev	     ; DATA XREF: DOSBIOS:prndev2o
DOSBIOS:005B		     dw	70h
DOSBIOS:005D		     dw	8008h
DOSBIOS:005F		     dw	offset strategy
DOSBIOS:0061		     dw	offset tim_entry
DOSBIOS:0063 aClock	     db	'CLOCK$  '
DOSBIOS:006B dskdev	     dw	offset com1dev	     ; DATA XREF: DOSBIOS:timdevo
DOSBIOS:006D		     dw	70h
DOSBIOS:006F		     dw	8C2h
DOSBIOS:0071		     dw	offset strategy
DOSBIOS:0073		     dw	offset dsk_entry
DOSBIOS:0075 drvmax	     db	4		     ; DATA XREF: DOSBIOS:1306r
DOSBIOS:0075					     ; DOSBIOS:1A28w ...
DOSBIOS:0076 step_drv	     db	0FEh		     ; DATA XREF: read_sector:okret2w
DOSBIOS:0076					     ; Disk+50r ...
DOSBIOS:0077 fhave96	     db	0		     ; DATA XREF: DOSBIOS:1AB8w
DOSBIOS:0077					     ; DOSBIOS:1B08w ...
DOSBIOS:0078 single	     db	0		     ; DATA XREF: DOSBIOS:settwodrivew
DOSBIOS:0078					     ; DOSBIOS:1B24r ...
DOSBIOS:0079 fhavek09	     db	0		     ; DATA XREF: DOSBIOS:1CA2w
DOSBIOS:0079					     ; DOSBIOS:271Er
DOSBIOS:007A fsetowner	     db	0		     ; DATA XREF: checksingle+32r
DOSBIOS:007A					     ; DOSBIOS:36B5w ...
DOSBIOS:007B com1dev	     dw	offset lpt1dev	     ; DATA XREF: DOSBIOS:dskdevo
DOSBIOS:007D		     dw	70h
DOSBIOS:007F		     dw	8000h
DOSBIOS:0081		     dw	offset strategy
DOSBIOS:0083		     dw	offset aux0_entry
DOSBIOS:0085 aCom1	     db	'COM1    '
DOSBIOS:008D lpt1dev	     dw	offset lpt2dev	     ; DATA XREF: DOSBIOS:com1devo
DOSBIOS:008F word_78F	     dw	70h
DOSBIOS:0091		     dw	0A0C0h
DOSBIOS:0093		     dw	offset strategy
DOSBIOS:0095		     dw	offset prn1_entry
DOSBIOS:0097 aLpt1	     db	'LPT1    '
DOSBIOS:009F lpt2dev	     dw	offset lpt3dev	     ; DATA XREF: DOSBIOS:lpt1devo
DOSBIOS:00A1		     dw	70h
DOSBIOS:00A3 word_7A3	     dw	0A0C0h
DOSBIOS:00A5		     dw	offset strategy
DOSBIOS:00A7		     dw	offset prn2_entry
DOSBIOS:00A9 aLpt2	     db	'LPT2    ',0,0,0
DOSBIOS:00B4 Orig13	     dd	0		     ; DATA XREF: call_orig13+5r
DOSBIOS:00B4					     ; DOSBIOS:182Ew ...
DOSBIOS:00B8 lpt3dev	     dw	offset com2dev	     ; DATA XREF: DOSBIOS:lpt2devo
DOSBIOS:00BA		     dw	70h
DOSBIOS:00BC		     dw	0A0C0h
DOSBIOS:00BE		     dw	offset strategy
DOSBIOS:00C0		     dw	offset prn3_entry
DOSBIOS:00C2 asc_7C2	     db	'LPT3    '
DOSBIOS:00CA com2dev	     dw	offset com3dev	     ; DATA XREF: DOSBIOS:lpt3devo
DOSBIOS:00CC		     dw	70h
DOSBIOS:00CE		     dw	8000h
DOSBIOS:00D0		     dw	offset strategy
DOSBIOS:00D2		     dw	offset aux1_entry
DOSBIOS:00D4		     db	'COM2    '
DOSBIOS:00DC com3dev	     dw	offset com4dev	     ; DATA XREF: DOSBIOS:com2devo
DOSBIOS:00DE		     dw	70h
DOSBIOS:00E0		     dw	8000h
DOSBIOS:00E2		     dw	offset strategy
DOSBIOS:00E4		     dw	offset aux2_entry
DOSBIOS:00E6		     db	'COM3    '
DOSBIOS:00EE com4dev	     dw	0FFFFh		     ; DATA XREF: DOSBIOS:com3devo
DOSBIOS:00F0		     dw	70h
DOSBIOS:00F2		     dw	8000h
DOSBIOS:00F4		     dw	offset strategy
DOSBIOS:00F6		     dw	offset aux3_entry
DOSBIOS:00F8		     db	'COM4    '
DOSBIOS:0100 RomVectors	     db	10h		     ; DATA XREF: DOSBIOS:0804o
DOSBIOS:0100					     ; DOSBIOS:1812o
DOSBIOS:0101 Old10	     dd	0
DOSBIOS:0105		     db	13h
DOSBIOS:0106 Old13	     dd	0		     ; DATA XREF: DOSBIOS:atd1r
DOSBIOS:0106					     ; DOSBIOS:no_hookitr ...
DOSBIOS:010A		     db	15h
DOSBIOS:010B Old15	     dd	0		     ; DATA XREF: Int15+5r
DOSBIOS:010B					     ; Int15+29r
DOSBIOS:010F		     db	19h
DOSBIOS:0110 Old19	     dd	0
DOSBIOS:0114		     db	1Bh
DOSBIOS:0115 Old1B	     dd	0
DOSBIOS:0119 start_bds	     dd	70034Eh		     ; DATA XREF: DOSBIOS:1A49o
DOSBIOS:0119					     ; remapr ...
DOSBIOS:0119					     ; Start of	linked list of BDS's
DOSBIOS:011D accesscount     db	0		     ; DATA XREF: Check_Time_Of_Access+18w
DOSBIOS:011D					     ; Check_Time_Of_Access+1Cr ...
DOSBIOS:011E tim_drv	     db	0FFh		     ; DATA XREF: DOSBIOS:2A6Ew
DOSBIOS:011E					     ; DOSBIOS:2A9Cr ...
DOSBIOS:011F medbyt	     db	0		     ; DATA XREF: diskio+Dw
DOSBIOS:011F					     ; fat_check+3r
DOSBIOS:0120 rflag	     db	2		     ; DATA XREF: DOSBIOS:dsk_writvw
DOSBIOS:0120					     ; DOSBIOS:dsk_writw ...
DOSBIOS:0120					     ; 2 for read, 3 for write
DOSBIOS:0121 verify	     db	0		     ; 1 if verify after write
DOSBIOS:0122 seccnt	     dw	0		     ; DATA XREF: diskio+19w
DOSBIOS:0122					     ; diskio+C6r ...
DOSBIOS:0124		     db	0		     ; -- pad where hardnum was
DOSBIOS:0125 dsktnum	     db	1		     ; DATA XREF: DOSBIOS:1A2Bw
DOSBIOS:0125					     ; DOSBIOS:1BCBr ...
DOSBIOS:0126 motorstartup    db	0		     ; DATA XREF: DOSBIOS:1966w
DOSBIOS:0126					     ; iosetup+20w ...
DOSBIOS:0127 settlecurrent   db	0		     ; DATA XREF: iosetup+40w
DOSBIOS:0127					     ; done+1Fr
DOSBIOS:0127					     ; value from table
DOSBIOS:0128 settleslow	     db	0		     ; DATA XREF: iosetup+45w
DOSBIOS:0128					     ; normspeed+9r
DOSBIOS:0128					     ; slow settle value
DOSBIOS:0129 nextspeed	     db	0		     ; value of	speed to be used
DOSBIOS:012A save_head_sttl  db	0		     ; DATA XREF: read_sector+37w
DOSBIOS:012A					     ; read_sector+4Dr
DOSBIOS:012A					     ; used by read_sector routine
DOSBIOS:012B save_eot	     db	0		     ; DATA XREF: iosetup+23w
DOSBIOS:012B					     ; done+18r
DOSBIOS:012B					     ; saved eot from the default DPT
DOSBIOS:012C eot	     db	9		     ; DATA XREF: DOSBIOS:1A44w
DOSBIOS:012C					     ; DOSBIOS:1A9Br ...
DOSBIOS:012D dpt	     dd	0		     ; DATA XREF: read_sector+2Br
DOSBIOS:012D					     ; read_sector+51r	...
DOSBIOS:0131 cursec	     db	0		     ; DATA XREF: diskio+9Dw
DOSBIOS:0131					     ; block+1Er ...
DOSBIOS:0131					     ; current sector
DOSBIOS:0132 curhd	     db	0		     ; DATA XREF: diskio+BFw
DOSBIOS:0132					     ; Disk+41r ...
DOSBIOS:0132					     ; current head
DOSBIOS:0133 curtrk	     dw	0		     ; DATA XREF: diskio+C3w
DOSBIOS:0133					     ; Disk+1Fr ...
DOSBIOS:0133					     ; current track
DOSBIOS:0135 spsav	     dw	0		     ; DATA XREF: diskio+1Dw
DOSBIOS:0135					     ; Disk+136r ...
DOSBIOS:0135					     ; save the	stack pointer
DOSBIOS:0137 formt_eot	     db	8		     ; DATA XREF: SetDasd+5Fw
DOSBIOS:0137					     ; ToRom+22r
DOSBIOS:0137					     ; eot used	for format
DOSBIOS:0138 hdnum	     db	0		     ; DATA XREF: DOSBIOS:3387w
DOSBIOS:0138					     ; ToRom+49r
DOSBIOS:0138					     ; head number
DOSBIOS:0139 trknum	     dw	0		     ; DATA XREF: DOSBIOS:3384w
DOSBIOS:0139					     ; ToRom:GotValidDptr
DOSBIOS:0139					     ; track being manipulated
DOSBIOS:013B gap_patch	     db	50h		     ; DATA XREF: SetDasd+1Aw
DOSBIOS:013B					     ; SetDasd+3Ew ...
DOSBIOS:013B					     ; format gap patched into dpt
DOSBIOS:013C errin	     db	0CCh		     ; DATA XREF: maperror+Co
DOSBIOS:013C					     ; write fault error
DOSBIOS:013D		     db	80h		     ; no response
DOSBIOS:013E		     db	40h		     ; seek failure
DOSBIOS:013F		     db	10h		     ; bad crc
DOSBIOS:0140		     db	8		     ; dma overrun
DOSBIOS:0141		     db	6		     ; media change
DOSBIOS:0142		     db	4		     ; sector not found
DOSBIOS:0143		     db	3		     ; write attempt to	write-protect disk
DOSBIOS:0144 lsterr	     db	0		     ; DATA XREF: maperror+6w
DOSBIOS:0144					     ; all other errors
DOSBIOS:0145 errout	     db	10		     ; write fault error
DOSBIOS:0146		     db	2		     ; no response
DOSBIOS:0147		     db	6		     ; seek failure
DOSBIOS:0148		     db	4		     ; bad crc
DOSBIOS:0149		     db	4		     ; dma overrun
DOSBIOS:014A		     db	15		     ; invalid media change
DOSBIOS:014B		     db	8		     ; sector not found
DOSBIOS:014C		     db	0		     ; write attempt to	write-protect disk
DOSBIOS:014D		     db	12		     ; general error
DOSBIOS:014E disksector	     db	512 dup(0)	     ; DATA XREF: sethard+131o
DOSBIOS:014E					     ; sethard+139o ...
DOSBIOS:014E					     ; read in boot sector here
DOSBIOS:034E bds1	     dw	offset bds2
DOSBIOS:0350		     dw	70h		     ; dword link to next structure
DOSBIOS:0352		     db	0		     ; int 13h drive number
DOSBIOS:0353		     db	0		     ; logical drive letter
DOSBIOS:0354 fdrive1	     dw	512		     ; DATA XREF: DOSBIOS:dskdrvso
DOSBIOS:0354					     ; physical	sector size in bytes
DOSBIOS:0356		     db	0FFh		     ; sectors/allocation unit
DOSBIOS:0357		     dw	1		     ; reserved	sectors	for dos
DOSBIOS:0359		     db	2		     ; no of file allocation tables
DOSBIOS:035A		     dw	64		     ; number of root directory	entries
DOSBIOS:035C		     dw	360		     ; number sectors (at 512 bytes each)
DOSBIOS:035E		     db	0		     ; media descriptor, initially 0
DOSBIOS:035F		     dw	2		     ; number of fat sectors
DOSBIOS:0361		     dw	9		     ; sector limit (sectors per track)
DOSBIOS:0363		     dw	1		     ; head limit (number of heads - 1)
DOSBIOS:0365		     dw	0		     ; hidden sector count (low	word)
DOSBIOS:0367		     dw	0		     ; hidden sector (high)
DOSBIOS:0369		     dw	0		     ; number sectors (low)
DOSBIOS:036B		     dw	0		     ; number sectors (high)
DOSBIOS:036D		     db	0		     ; true => large fats
DOSBIOS:036E		     dw	0		     ; open ref. count
DOSBIOS:0370		     db	3		     ; form factor
DOSBIOS:0371		     dw	20h		     ; various flags
DOSBIOS:0373		     dw	40		     ; number of cylinders
DOSBIOS:0375 recommended_bps dw	512		     ; recommended bps for this	drive
DOSBIOS:0377		     db	1
DOSBIOS:0378		     dw	1
DOSBIOS:037A		     db	2
DOSBIOS:037B		     dw	224		     ; number of root directory	entries
DOSBIOS:037D		     dw	360
DOSBIOS:037F		     db	0F0h ; ð	     ; media descriptor, initially 0F0h
DOSBIOS:0380		     dw	2
DOSBIOS:0382		     dw	9
DOSBIOS:0384		     dw	2
DOSBIOS:0386		     dw	0
DOSBIOS:0388		     dw	0
DOSBIOS:038A		     dw	0
DOSBIOS:038C		     dw	0
DOSBIOS:038E		     db	6 dup(0)
DOSBIOS:0394		     db	0FFh		     ; last track accessed on this drive
DOSBIOS:0395 word_A95	     dw	0FFFFh		     ; keep these two contiguous (?)
DOSBIOS:0397		     dw	0FFFFh
DOSBIOS:0399		     db	'NO NAME    ',0      ; volume id for this disk
DOSBIOS:03A5		     dd	0		     ; current volume serial from boot record
DOSBIOS:03A9		     db	'FAT12   ',0         ; current file system id from boot record
DOSBIOS:03B2 bds2	     dw	offset bds3	     ; DATA XREF: DOSBIOS:bds1o
DOSBIOS:03B4		     dw	70h
DOSBIOS:03B6		     db	0
DOSBIOS:03B7		     db	0
DOSBIOS:03B8 fdrive2	     dw	512		     ; DATA XREF: DOSBIOS:0689o
DOSBIOS:03BA byte_ABA	     db	0FFh, 1, 0, 2, 40h, 0, 68h, 1, 0, 2, 0,	9, 0, 1, 0
DOSBIOS:03BA		     db	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 3, 20h, 0, 28h, 0
DOSBIOS:03BA		     db	0, 2, 1, 1, 0, 2, 0E0h,	0, 68h,	1, 0F0h, 2, 0, 9, 0
DOSBIOS:03BA		     db	2, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0FFh
DOSBIOS:03BA		     db	0FFh, 0FFh, 0FFh, 0FFh,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh
DOSBIOS:03BA		     db	45h, 20h, 20h, 20h, 20h, 0, 0, 0, 0, 0,	46h, 41h, 54h
DOSBIOS:03BA		     db	31h, 32h, 20h, 20h, 20h, 0
DOSBIOS:0416 bds3	     dw	offset bds4	     ; DATA XREF: DOSBIOS:bds2o
DOSBIOS:0418		     dw	70h
DOSBIOS:041A		     db	0
DOSBIOS:041B		     db	0
DOSBIOS:041C fdrive3	     dw	512		     ; DATA XREF: DOSBIOS:068Bo
DOSBIOS:041E		     db	0FFh, 1, 0, 2, 40h, 0, 68h, 1, 0, 2, 0,	9, 0, 1, 0
DOSBIOS:041E		     db	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 3, 20h, 0, 28h, 0
DOSBIOS:041E		     db	0, 2, 1, 1, 0, 2, 0E0h,	0, 68h,	1, 0F0h, 2, 0, 9, 0
DOSBIOS:041E		     db	2, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0FFh
DOSBIOS:041E		     db	0FFh, 0FFh, 0FFh, 0FFh,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh
DOSBIOS:041E		     db	45h, 20h, 20h, 20h, 20h, 0, 0, 0, 0, 0,	46h, 41h, 54h
DOSBIOS:041E		     db	31h, 32h, 20h, 20h, 20h, 0
DOSBIOS:047A bds4	     dw	0FFFFh		     ; DATA XREF: DOSBIOS:bds3o
DOSBIOS:047C		     dw	70h
DOSBIOS:047E		     db	0
DOSBIOS:047F		     db	0
DOSBIOS:0480 fdrive4	     dw	512		     ; DATA XREF: DOSBIOS:068Do
DOSBIOS:0482 byte_B82	     db	0FFh, 1, 0, 2, 40h, 0, 68h, 1, 0, 2, 0,	9, 0, 1, 0
DOSBIOS:0482		     db	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 3, 20h, 0, 28h, 0
DOSBIOS:0482		     db	0, 2, 1, 1, 0, 2, 0E0h,	0, 68h,	1, 0F0h, 2, 0, 9, 0
DOSBIOS:0482		     db	2, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0FFh
DOSBIOS:0482		     db	0FFh, 0FFh, 0FFh, 0FFh,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh
DOSBIOS:0482		     db	45h, 20h, 20h, 20h, 20h, 0, 0, 0, 0, 0,	46h, 41h, 54h
DOSBIOS:0482		     db	31h, 32h, 20h, 20h, 20h, 0
DOSBIOS:04DE sm92	     db	3		     ; DATA XREF: GetBp:Has720Ko
DOSBIOS:04DF		     db	9
DOSBIOS:04E0		     db	70h
DOSBIOS:04E1		     dw	1440		     ; 2*9*80
DOSBIOS:04E3		     db	2
DOSBIOS:04E4		     db	2
DOSBIOS:04E5 keyrd_func	     db	0		     ; DATA XREF: DOSBIOS:1A0Cw
DOSBIOS:04E5					     ; chrinr ...
DOSBIOS:04E6 keysts_func     db	1		     ; DATA XREF: DOSBIOS:1A12w
DOSBIOS:04E6					     ; DOSBIOS:2716r
DOSBIOS:04E7 printdev	     db	0		     ; DATA XREF: DOSBIOS:25CCw
DOSBIOS:04E7					     ; DOSBIOS:2801r ...
DOSBIOS:04E7					     ; printer device index
DOSBIOS:04E8 wait_count	     dw	4 dup(50h)	     ; DATA XREF: DOSBIOS:2807r
DOSBIOS:04E8					     ; DOSBIOS:2848r ...
DOSBIOS:04E8					     ; retry counts for	printers
DOSBIOS:04F0 daycnt	     dw	0		     ; DATA XREF: daycnt_to_dayr
DOSBIOS:04F0					     ; daycnt_to_day+5r ...
DOSBIOS:04F2 t_switch	     db	0		     ; DATA XREF: GetTickCnt+4r
DOSBIOS:04F2					     ; flag for	updating daycnt
DOSBIOS:04F3 havecmosclock   db	0		     ; DATA XREF: DOSBIOS:1C74r
DOSBIOS:04F3					     ; cmos_clock_read:clock_presentw ...
DOSBIOS:04F4 base_century    db	19		     ; DATA XREF: daycnt_to_day+Ew
DOSBIOS:04F4					     ; daycnt_to_day:century20w ...
DOSBIOS:04F5 base_year	     db	80		     ; DATA XREF: daycnt_to_day+14w
DOSBIOS:04F5					     ; daycnt_to_day+22w ...
DOSBIOS:04F6 month_tab	     db	31, 28,	31, 30,	31, 30,	31, 31,	30, 31,	30, 31
DOSBIOS:04F6					     ; DATA XREF: daycnt_to_day+8Ao
DOSBIOS:04F6					     ; daycnt_to_day:leapyearw	...
DOSBIOS:0502 bintobcd	     dd	bin_to_bcd	     ; DATA XREF: daycnt_to_day+AFr
DOSBIOS:0502					     ; daycnt_to_day+B6r ...
DOSBIOS:0502					     ; points to bin_to_bcd proc in msinit
DOSBIOS:0506 daycnttoday     dd	daycnt_to_day	     ; DATA XREF: DOSBIOS:1C7Bw
DOSBIOS:0506					     ; DOSBIOS:2999r
DOSBIOS:0506					     ; points to daycnt_to_day in msinit
DOSBIOS:050A set_id_flag     db	0		     ; DATA XREF: DOSBIOS:2B12w
DOSBIOS:050A					     ; DOSBIOS:2B1Cr ...
DOSBIOS:050A					     ; flag for	getbp routine
DOSBIOS:050B fat_12_id	     db	'FAT12   ',0         ; DATA XREF: clear_ids+20o
DOSBIOS:0514 fat_16_id	     db	'FAT16   ',0         ; DATA XREF: clear_ids+1Bo
DOSBIOS:051D vol_no_name     db	'NO NAME    ',0      ; DATA XREF: clear_ids+Eo
DOSBIOS:0529 temp_h	     dw	0		     ; DATA XREF: sethard+E7w
DOSBIOS:0529					     ; sethard+FAr ...
DOSBIOS:0529					     ; temporary for 32	bit calculation
DOSBIOS:052B start_sec_h     dw	0		     ; DATA XREF: DOSBIOS:24E8w
DOSBIOS:052B					     ; get_fat_sector+35w ...
DOSBIOS:052B					     ; starting	sector number high word
DOSBIOS:052D saved_word	     dw	0		     ; DATA XREF: diskio+5Cw
DOSBIOS:052D					     ; diskio+94r
DOSBIOS:052D					     ; tempory saving place for	a word
DOSBIOS:052F multrk_flag     dw	0		     ; DATA XREF: block+Br
DOSBIOS:052F					     ; Disk+80r ...
DOSBIOS:0531 ec35flag	     db	0		     ; DATA XREF: DOSBIOS:3A86r
DOSBIOS:0531					     ; DOSBIOS:format_special_stuff_doner
DOSBIOS:0531					     ; flags for 3.5 inch disk drives
DOSBIOS:0532 vretry_cnt	     dw	0		     ; DATA XREF: Disk:GetRdWrIndw
DOSBIOS:0532					     ; Disk+E6w
DOSBIOS:0534 soft_ecc_cnt    dw	0		     ; DATA XREF: Disk+16w
DOSBIOS:0534					     ; Disk+D8w ...
DOSBIOS:0536 multitrk_format_flag db 0		     ; DATA XREF: Disk:dskerr_nochangeliner
DOSBIOS:0536					     ; Disk+100w ...
DOSBIOS:0536					     ; multi track format request flag
DOSBIOS:0537 xfer_seg	     dw	0		     ; DATA XREF: diskio+2w
DOSBIOS:0537					     ; fastspeed+8r ...
DOSBIOS:0537					     ; temp for	transfer segment
DOSBIOS:0539 sectorspertrack dw	36		     ; DATA XREF: DOSBIOS:32FAw
DOSBIOS:0539					     ; DOSBIOS:3390r ...
DOSBIOS:053B tracktable	     db	0, 0, 1, 2	     ; DATA XREF: DOSBIOS:3315o
DOSBIOS:053B					     ; DOSBIOS:338Do ...
DOSBIOS:053B		     db	0, 0, 2, 2
DOSBIOS:053B		     db	0, 0, 3, 2
DOSBIOS:053B		     db	0, 0, 4, 2
DOSBIOS:053B		     db	0, 0, 5, 2
DOSBIOS:053B		     db	0, 0, 6, 2
DOSBIOS:053B		     db	0, 0, 7, 2
DOSBIOS:053B		     db	0, 0, 8, 2
DOSBIOS:053B		     db	0, 0, 9, 2
DOSBIOS:053B		     db	0, 0, 10, 2
DOSBIOS:053B		     db	0, 0, 11, 2
DOSBIOS:053B		     db	0, 0, 12, 2
DOSBIOS:053B		     db	0, 0, 13, 2
DOSBIOS:053B		     db	0, 0, 14, 2
DOSBIOS:053B		     db	0, 0, 15, 2
DOSBIOS:053B		     db	0, 0, 16, 2
DOSBIOS:053B		     db	0, 0, 17, 2
DOSBIOS:053B		     db	0, 0, 18, 2
DOSBIOS:053B		     db	0, 0, 19, 2
DOSBIOS:053B		     db	0, 0, 20, 2
DOSBIOS:053B		     db	0, 0, 21, 2
DOSBIOS:053B		     db	0, 0, 22, 2
DOSBIOS:053B		     db	0, 0, 23, 2
DOSBIOS:053B		     db	0, 0, 24, 2
DOSBIOS:053B		     db	0, 0, 25, 2
DOSBIOS:053B		     db	0, 0, 26, 2
DOSBIOS:053B		     db	0, 0, 27, 2
DOSBIOS:053B		     db	0, 0, 28, 2
DOSBIOS:053B		     db	0, 0, 29, 2
DOSBIOS:053B		     db	0, 0, 30, 2
DOSBIOS:053B		     db	0, 0, 31, 2
DOSBIOS:053B		     db	0, 0, 32, 2
DOSBIOS:053B		     db	0, 0, 33, 2
DOSBIOS:053B		     db	0, 0, 34, 2
DOSBIOS:053B		     db	0, 0, 35, 2
DOSBIOS:053B		     db	0, 0, 36, 2
DOSBIOS:05CB		     db	108 dup(0)	     ; 4*max_sectors_curr_sup -	($ - tracktable) dup (0)
DOSBIOS:05CB					     ; times ((4*63) - 144) db 0
DOSBIOS:0637 mediatype	     db	0		     ; DATA XREF: DOSBIOS:32B1w
DOSBIOS:0637					     ; SetDasd+35r
DOSBIOS:0638 media_set_for_format db 0		     ; DATA XREF: read_sector+22r
DOSBIOS:0638					     ; read_sector+45r	...
DOSBIOS:0639 had_format_error db 0		     ; DATA XREF: DOSBIOS:33CAw
DOSBIOS:0639					     ; DOSBIOS:FormatFailedw ...
DOSBIOS:063A tempdpt	     dd	0FFFFFFFFh	     ; DATA XREF: SetMediaForFormat+60w
DOSBIOS:063A					     ; RestoreOldDpt+11r ...
DOSBIOS:063A					     ; temp disk base table
DOSBIOS:063E model_byte	     db	0FFh		     ; DATA XREF: DOSBIOS:18CBw
DOSBIOS:063E					     ; DOSBIOS:18E2w ...
DOSBIOS:063E					     ; model byte set at init time
DOSBIOS:063F secondary_model_byte db 0		     ; DATA XREF: DOSBIOS:18D3w
DOSBIOS:063F					     ; DOSBIOS:23EFr ...
DOSBIOS:0640 int19sem	     db	0		     ; DATA XREF: DOSBIOS:0815r
DOSBIOS:0640					     ; i19_lst
DOSBIOS:0641 i19_lst	     db	2		     ; DATA XREF: DOSBIOS:081Co
DOSBIOS:0641					     ; Int19old&aa
DOSBIOS:0642 int19old02	     dd	0FFFFFFFFh
DOSBIOS:0646		     db	8
DOSBIOS:0647 int19old08	     dd	0FFFFFFFFh	     ; original	hardware int. vectors for int 19h
DOSBIOS:064B		     db	9
DOSBIOS:064C int19old09	     dd	0FFFFFFFFh
DOSBIOS:0650		     db	0Ah
DOSBIOS:0651 int19old0A	     dd	0FFFFFFFFh
DOSBIOS:0655		     db	0Bh
DOSBIOS:0656 int19old0B	     dd	0FFFFFFFFh
DOSBIOS:065A		     db	0Ch
DOSBIOS:065B int19old0C	     dd	0FFFFFFFFh
DOSBIOS:065F		     db	0Dh
DOSBIOS:0660 int19old0D	     dd	0FFFFFFFFh
DOSBIOS:0664		     db	0Eh
DOSBIOS:0665 int19old0E	     dd	0FFFFFFFFh
DOSBIOS:0669		     db	70h
DOSBIOS:066A int19old70	     dd	0FFFFFFFFh
DOSBIOS:066E		     db	72h
DOSBIOS:066F int19old72	     dd	0FFFFFFFFh
DOSBIOS:0673		     db	73h
DOSBIOS:0674 int19old73	     dd	0FFFFFFFFh
DOSBIOS:0678		     db	74h
DOSBIOS:0679 int19old74	     dd	0FFFFFFFFh
DOSBIOS:067D		     db	76h
DOSBIOS:067E int19old76	     dd	0FFFFFFFFh
DOSBIOS:0682		     db	77h
DOSBIOS:0683 int19old77	     dd	0FFFFFFFFh
DOSBIOS:0687 dskdrvs	     dw	offset fdrive1	     ; DATA XREF: DOSBIOS:last_dskdrv_tableo
DOSBIOS:0687					     ; DOSBIOS:3CB6o
DOSBIOS:0689		     dw	offset fdrive2
DOSBIOS:068B		     dw	offset fdrive3
DOSBIOS:068D		     dw	offset fdrive4
DOSBIOS:068F		     dw	22 dup(0)	     ; up to 26	drives for mini	disks
DOSBIOS:06BB int6c_ret_addr  dd	0		     ; DATA XREF: DOSBIOS:150Cw
DOSBIOS:06BB					     ; DOSBIOS:1527r ...
DOSBIOS:06BF bin_date_time   db	0, 0, 0, 0	     ; DATA XREF: read_real_date:read_okw
DOSBIOS:06BF					     ; read_real_date+54r ...
DOSBIOS:06BF					     ; century,	year, month, day
DOSBIOS:06C3 month_table     dw	0		     ; DATA XREF: read_real_date+A5o
DOSBIOS:06C3					     ; january
DOSBIOS:06C5		     dw	31		     ; february
DOSBIOS:06C7		     dw	59
DOSBIOS:06C9		     dw	90
DOSBIOS:06CB		     dw	120
DOSBIOS:06CD		     dw	151
DOSBIOS:06CF		     dw	181
DOSBIOS:06D1		     dw	212
DOSBIOS:06D3		     dw	243
DOSBIOS:06D5		     dw	273
DOSBIOS:06D7		     dw	304
DOSBIOS:06D9		     dw	334		     ; december
DOSBIOS:06DB daycnt2	     dw	0		     ; DATA XREF: read_real_date+Ew
DOSBIOS:06DB					     ; read_real_date+2Ew ...
DOSBIOS:06DD feb29	     db	0		     ; february	29 in a	leap year flag
DOSBIOS:06DE cdev	     dw	43h, 2C7h	     ; DATA XREF: cdev_entry:ce_enter_codesegr
DOSBIOS:06DE					     ; DOSBIOS:17F3r ...
DOSBIOS:06DE					     ; chardev_entry
DOSBIOS:06DE					     ; at 2C7h:43h = 70h:25B3h
DOSBIOS:06E2 ttticks	     dw	396h, 2C7h	     ; DATA XREF: read_real_time+34r
DOSBIOS:06E2					     ; DOSBIOS:2984r
DOSBIOS:06E2					     ; time_to_ticks
DOSBIOS:06E2					     ; at 2C7h:396h = 70h:2906h
DOSBIOS:06E6 bcode_i2f	     dw	1302h, 2C7h	     ; DATA XREF: DOSBIOS:int_2fr
DOSBIOS:06E6					     ; i2f_handler
DOSBIOS:06E6					     ; at 2C7h:1302h = 70h:3872h
DOSBIOS:06EA i13x	     dw	154Bh, 2C7h	     ; DATA XREF: DOSBIOS:078Ar
DOSBIOS:06EA					     ; i13z
DOSBIOS:06EA					     ; at 2C7h:154Bh = 70h:3ABBh
DOSBIOS:06EE ; ---------------------------------------------------------------------------
DOSBIOS:06EE
DOSBIOS:06EE cbreak:				     ; DATA XREF: DOSBIOS:1934o
DOSBIOS:06EE		     mov     cs:altah, 3     ; break key handling
DOSBIOS:06EE					     ; indicate	break key set
DOSBIOS:06F4
DOSBIOS:06F4 intret:				     ; DATA XREF: DOSBIOS:1949o
DOSBIOS:06F4					     ; DOSBIOS:resetintfo
DOSBIOS:06F4		     iret
DOSBIOS:06F5
DOSBIOS:06F5 ; =============== S U B R O U T I N E =======================================
DOSBIOS:06F5
DOSBIOS:06F5
DOSBIOS:06F5 strategy	     proc far		     ; DATA XREF: DOSBIOS:0029o
DOSBIOS:06F5					     ; DOSBIOS:003Bo ...
DOSBIOS:06F5		     mov     word ptr cs:ptrsav, bx ; store es:bx (device driver request packet)
DOSBIOS:06F5					     ; away at [ptrsav]	for next driver	function call
DOSBIOS:06FA		     mov     word ptr cs:ptrsav+2, es
DOSBIOS:06FF		     retf
DOSBIOS:06FF strategy	     endp
DOSBIOS:06FF
DOSBIOS:0700 ; ---------------------------------------------------------------------------
DOSBIOS:0700
DOSBIOS:0700 con_entry:				     ; DATA XREF: DOSBIOS:002Bo
DOSBIOS:0700		     call    cdev_entry
DOSBIOS:0700 ; ---------------------------------------------------------------------------
DOSBIOS:0703		     dw	0E4h		     ; con_table
DOSBIOS:0703					     ; 2C7h:0E4h = 70h:2654h
DOSBIOS:0705 ; ---------------------------------------------------------------------------
DOSBIOS:0705
DOSBIOS:0705 prn0_entry:			     ; DATA XREF: DOSBIOS:004Fo
DOSBIOS:0705		     call    cdev_entry
DOSBIOS:0705 ; ---------------------------------------------------------------------------
DOSBIOS:0708		     dw	0FBh		     ; prn_table
DOSBIOS:0708					     ; 2C7h:0FBh = 70h:266Bh
DOSBIOS:070A		     db	0, 0
DOSBIOS:070C ; ---------------------------------------------------------------------------
DOSBIOS:070C
DOSBIOS:070C prn1_entry:			     ; DATA XREF: DOSBIOS:0095o
DOSBIOS:070C		     call    cdev_entry
DOSBIOS:070C ; ---------------------------------------------------------------------------
DOSBIOS:070F		     dw	0FBh		     ; prn_table
DOSBIOS:070F					     ; 2C7h:0FBh = 70h:266Bh
DOSBIOS:0711		     db	0, 1
DOSBIOS:0713 ; ---------------------------------------------------------------------------
DOSBIOS:0713
DOSBIOS:0713 prn2_entry:			     ; DATA XREF: DOSBIOS:00A7o
DOSBIOS:0713		     call    cdev_entry
DOSBIOS:0713 ; ---------------------------------------------------------------------------
DOSBIOS:0716		     dw	0FBh		     ; prn_table
DOSBIOS:0716					     ; 2C7h:0FBh = 70h:266Bh
DOSBIOS:0718		     db	1, 2
DOSBIOS:071A ; ---------------------------------------------------------------------------
DOSBIOS:071A
DOSBIOS:071A prn3_entry:			     ; DATA XREF: DOSBIOS:00C0o
DOSBIOS:071A		     call    cdev_entry
DOSBIOS:071A ; ---------------------------------------------------------------------------
DOSBIOS:071D		     dw	0FBh		     ; prn_table
DOSBIOS:071D					     ; 2C7h:0FBh = 70h:266Bh
DOSBIOS:071F		     db	2, 3
DOSBIOS:0721 ; ---------------------------------------------------------------------------
DOSBIOS:0721
DOSBIOS:0721 aux0_entry:			     ; DATA XREF: DOSBIOS:003Do
DOSBIOS:0721					     ; DOSBIOS:0083o
DOSBIOS:0721		     call    cdev_entry
DOSBIOS:0721 ; ---------------------------------------------------------------------------
DOSBIOS:0724		     dw	130h		     ; aux_table
DOSBIOS:0724					     ; 2C7h:130h = 70h:26A0h
DOSBIOS:0726		     db	0
DOSBIOS:0727 ; ---------------------------------------------------------------------------
DOSBIOS:0727
DOSBIOS:0727 aux1_entry:			     ; DATA XREF: DOSBIOS:00D2o
DOSBIOS:0727		     call    cdev_entry
DOSBIOS:0727 ; ---------------------------------------------------------------------------
DOSBIOS:072A		     dw	130h		     ; aux_table
DOSBIOS:072A					     ; 2C7h:130h = 70h:26A0h
DOSBIOS:072C		     db	1
DOSBIOS:072D ; ---------------------------------------------------------------------------
DOSBIOS:072D
DOSBIOS:072D aux2_entry:			     ; DATA XREF: DOSBIOS:00E4o
DOSBIOS:072D		     call    cdev_entry
DOSBIOS:072D ; ---------------------------------------------------------------------------
DOSBIOS:0730		     dw	130h		     ; aux_table
DOSBIOS:0730					     ; 2C7h:130h = 70h:26A0h
DOSBIOS:0732		     db	2
DOSBIOS:0733 ; ---------------------------------------------------------------------------
DOSBIOS:0733
DOSBIOS:0733 aux3_entry:			     ; DATA XREF: DOSBIOS:00F6o
DOSBIOS:0733		     call    cdev_entry
DOSBIOS:0733 ; ---------------------------------------------------------------------------
DOSBIOS:0736		     dw	130h		     ; aux_table
DOSBIOS:0736					     ; 2C7h:130h = 70h:26A0h
DOSBIOS:0738		     db	3
DOSBIOS:0739 ; ---------------------------------------------------------------------------
DOSBIOS:0739
DOSBIOS:0739 tim_entry:				     ; DATA XREF: DOSBIOS:0061o
DOSBIOS:0739		     call    cdev_entry
DOSBIOS:0739 ; ---------------------------------------------------------------------------
DOSBIOS:073C		     dw	147h		     ; tim_table
DOSBIOS:073C					     ; 2C7h:147h = 70h:26B7h
DOSBIOS:073E ; ---------------------------------------------------------------------------
DOSBIOS:073E
DOSBIOS:073E dsk_entry:				     ; CODE XREF: DOSBIOS:i2f_dskentryj
DOSBIOS:073E					     ; DATA XREF: DOSBIOS:0073o
DOSBIOS:073E		     call    cdev_entry
DOSBIOS:073E ; ---------------------------------------------------------------------------
DOSBIOS:0741		     dw	4A2h		     ; dsktbl
DOSBIOS:0741					     ; 2C7h:4A2h = 70h:2A12h
DOSBIOS:0743
DOSBIOS:0743 ; =============== S U B R O U T I N E =======================================
DOSBIOS:0743
DOSBIOS:0743
DOSBIOS:0743 cdev_entry	     proc near		     ; CODE XREF: DOSBIOS:con_entryp
DOSBIOS:0743					     ; DOSBIOS:prn0_entryp ...
DOSBIOS:0743		     cmp     cs:inHMA, 0
DOSBIOS:0749		     jz	     short ce_enter_codeseg
DOSBIOS:074B		     push    ax
DOSBIOS:074C		     mov     ax, cs:DosDataSg
DOSBIOS:0750		     cmp     word ptr cs:ptrsav+2, ax
DOSBIOS:0755		     pop     ax
DOSBIOS:0756		     jnz     short not_from_dos
DOSBIOS:0758
DOSBIOS:0758 ce_enter_codeseg:			     ; CODE XREF: cdev_entry+6j
DOSBIOS:0758					     ; cdev_entry+1Dj
DOSBIOS:0758		     jmp     dword ptr cs:cdev ; jmp far [cs:cdev]
DOSBIOS:075D ; ---------------------------------------------------------------------------
DOSBIOS:075D
DOSBIOS:075D not_from_dos:			     ; CODE XREF: cdev_entry+13j
DOSBIOS:075D		     call    EnsureA20On
DOSBIOS:0760		     jmp     short ce_enter_codeseg
DOSBIOS:0760 cdev_entry	     endp
DOSBIOS:0760
DOSBIOS:0762 ; ---------------------------------------------------------------------------
DOSBIOS:0762
DOSBIOS:0762 outchr:				     ; DATA XREF: DOSBIOS:193Do
DOSBIOS:0762		     push    ax		     ; int 29h handler
DOSBIOS:0763		     push    si
DOSBIOS:0764		     push    di
DOSBIOS:0765		     push    bp
DOSBIOS:0766		     push    bx
DOSBIOS:0767		     mov     ah, 0Eh
DOSBIOS:0769		     mov     bx, 7
DOSBIOS:076C		     int     10h	     ; - VIDEO - WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)
DOSBIOS:076C					     ; AL = character, BH = display page (alpha	modes)
DOSBIOS:076C					     ; BL = foreground color (graphics modes)
DOSBIOS:076E		     pop     bx
DOSBIOS:076F		     pop     bp
DOSBIOS:0770		     pop     di
DOSBIOS:0771		     pop     si
DOSBIOS:0772		     pop     ax
DOSBIOS:0773		     iret
DOSBIOS:0774 ; ---------------------------------------------------------------------------
DOSBIOS:0774
DOSBIOS:0774 block13:				     ; DATA XREF: DOSBIOS:183Ao
DOSBIOS:0774		     cmp     cs:inHMA, 0
DOSBIOS:077A		     jz	     short skipa20
DOSBIOS:077C		     call    IsA20Off	     ; A20 Off?
DOSBIOS:077F		     jnz     short skipa20
DOSBIOS:0781		     call    EnableA20	     ; assure a20 enabled
DOSBIOS:0784
DOSBIOS:0784 skipa20:				     ; CODE XREF: DOSBIOS:077Aj
DOSBIOS:0784					     ; DOSBIOS:077Fj
DOSBIOS:0784		     mov     cs:i13_ds,	ds   ; save caller's ds for call-through
DOSBIOS:0789		     pushf		     ; fake interrupt
DOSBIOS:078A		     call    dword ptr cs:i13x ; call far [cs:i13x]
DOSBIOS:078A					     ; call through Bios_Code entry table
DOSBIOS:078F		     mov     ds, cs:i13_ds
DOSBIOS:0794		     retf    2
DOSBIOS:0797
DOSBIOS:0797 ; =============== S U B R O U T I N E =======================================
DOSBIOS:0797
DOSBIOS:0797
DOSBIOS:0797 call_orig13     proc far		     ; CODE XREF: doint+13P
DOSBIOS:0797					     ; DOSBIOS:3AB3P ...
DOSBIOS:0797		     mov     ds, ds:i13_ds   ;	get caller's ds register
DOSBIOS:079B		     pushf
DOSBIOS:079C		     call    cs:Orig13	     ; call far	[cs:orig13]
DOSBIOS:07A1		     mov     cs:i13_ds,	ds
DOSBIOS:07A6		     push    cs
DOSBIOS:07A7		     pop     ds		     ; restore ds -> Bios_Data before return
DOSBIOS:07A8		     assume ds:DOSBIOS
DOSBIOS:07A8		     pushf
DOSBIOS:07A9		     cmp     cs:inHMA, 0
DOSBIOS:07AF		     jz	     short corig13_popf_retf
DOSBIOS:07B1		     call    IsA20Off
DOSBIOS:07B4		     jnz     short corig13_popf_retf
DOSBIOS:07B6		     call    EnableA20
DOSBIOS:07B9
DOSBIOS:07B9 corig13_popf_retf:			     ; CODE XREF: call_orig13+18j
DOSBIOS:07B9					     ; call_orig13+1Dj
DOSBIOS:07B9		     popf
DOSBIOS:07BA		     retf
DOSBIOS:07BA call_orig13     endp
DOSBIOS:07BA
DOSBIOS:07BA ; ---------------------------------------------------------------------------
DOSBIOS:07BB HiMem	     dd	0FFFF0090h	     ; DATA XREF: IsA20Off+5r
DOSBIOS:07BF LoMem	     dd	80h		     ; DATA XREF: IsA20Off+Ar
DOSBIOS:07C3
DOSBIOS:07C3 ; =============== S U B R O U T I N E =======================================
DOSBIOS:07C3
DOSBIOS:07C3
DOSBIOS:07C3 EnsureA20On     proc near		     ; CODE XREF: cdev_entry:not_from_dosp
DOSBIOS:07C3					     ; EraseVDiskHead+4p
DOSBIOS:07C3		     call    IsA20Off
DOSBIOS:07C6		     jz	     short EnableA20
DOSBIOS:07C8		     retn
DOSBIOS:07C8 EnsureA20On     endp
DOSBIOS:07C8
DOSBIOS:07C9
DOSBIOS:07C9 ; =============== S U B R O U T I N E =======================================
DOSBIOS:07C9
DOSBIOS:07C9
DOSBIOS:07C9 EnableA20	     proc near		     ; CODE XREF: DOSBIOS:0781p
DOSBIOS:07C9					     ; call_orig13+1Fp	...
DOSBIOS:07C9		     push    ax
DOSBIOS:07CA		     push    bx
DOSBIOS:07CB		     mov     ah, 5
DOSBIOS:07CD		     call    cs:xms
DOSBIOS:07D2		     pop     bx
DOSBIOS:07D3		     pop     ax
DOSBIOS:07D4		     retn
DOSBIOS:07D4 EnableA20	     endp
DOSBIOS:07D4
DOSBIOS:07D5
DOSBIOS:07D5 ; =============== S U B R O U T I N E =======================================
DOSBIOS:07D5
DOSBIOS:07D5
DOSBIOS:07D5 IsA20Off	     proc near		     ; CODE XREF: DOSBIOS:077Cp
DOSBIOS:07D5					     ; call_orig13+1Ap	...
DOSBIOS:07D5		     push    ds
DOSBIOS:07D6		     push    es
DOSBIOS:07D7		     push    cx
DOSBIOS:07D8		     push    si
DOSBIOS:07D9		     push    di
DOSBIOS:07DA		     lds     si, cs:HiMem
DOSBIOS:07DF		     assume ds:nothing
DOSBIOS:07DF		     les     di, cs:LoMem
DOSBIOS:07E4		     mov     cx, 8
DOSBIOS:07E7		     repe cmpsw
DOSBIOS:07E9		     pop     di
DOSBIOS:07EA		     pop     si
DOSBIOS:07EB		     pop     cx
DOSBIOS:07EC		     pop     es
DOSBIOS:07ED		     pop     ds
DOSBIOS:07EE		     retn
DOSBIOS:07EE IsA20Off	     endp
DOSBIOS:07EE
DOSBIOS:07EF ; ---------------------------------------------------------------------------
DOSBIOS:07EF
DOSBIOS:07EF DisableA20:
DOSBIOS:07EF		     push    ax
DOSBIOS:07F0		     push    bx
DOSBIOS:07F1		     mov     ah, 6	     ; localdisable A20
DOSBIOS:07F3		     call    cs:xms
DOSBIOS:07F8		     pop     bx
DOSBIOS:07F9		     pop     ax
DOSBIOS:07FA		     retn
DOSBIOS:07FB ; ---------------------------------------------------------------------------
DOSBIOS:07FB
DOSBIOS:07FB int19:				     ; DATA XREF: DOSBIOS:184Eo
DOSBIOS:07FB		     push    cs		     ; bootstrap interrupt -- we must restore a	bunch of the
DOSBIOS:07FB					     ; interrupt vectors before	resuming the original int19 code
DOSBIOS:07FC		     pop     ds
DOSBIOS:07FD		     assume ds:DOSBIOS
DOSBIOS:07FD		     mov     es, zeroseg
DOSBIOS:0801		     assume es:nothing
DOSBIOS:0801		     mov     cx, 5	     ; NUMROMVECTORS
DOSBIOS:0804		     mov     si, offset	RomVectors
DOSBIOS:0807
DOSBIOS:0807 next_int:				     ; CODE XREF: DOSBIOS:0813j
DOSBIOS:0807		     lodsb		     ; get int number
DOSBIOS:0808		     cbw		     ; assume <	128
DOSBIOS:0809		     shl     ax, 1
DOSBIOS:080B		     shl     ax, 1	     ; int * 4
DOSBIOS:080D		     mov     di, ax
DOSBIOS:080F		     lodsw
DOSBIOS:0810		     stosw
DOSBIOS:0811		     lodsw
DOSBIOS:0812		     stosw		     ; install the saved vector
DOSBIOS:0813		     loop    next_int
DOSBIOS:0815		     cmp     int19sem, 0
DOSBIOS:081A		     jz	     short doint19
DOSBIOS:081C		     mov     si, offset	i19_lst	; stacks code has changed these	hardware interrupt vectors
DOSBIOS:081C					     ; stkinit in sysinit1 will	initialize int19oldxx values
DOSBIOS:081F		     mov     cx, 14	     ; num_i19
DOSBIOS:0822
DOSBIOS:0822 i19_restore_loop:			     ; CODE XREF: DOSBIOS:i19_restor_1j
DOSBIOS:0822		     lodsb		     ; get interrupt number
DOSBIOS:0823		     cbw		     ; assume <	128
DOSBIOS:0824		     mov     di, ax
DOSBIOS:0826		     lodsw		     ; get original vector offset
DOSBIOS:0827		     mov     bx, ax	     ; save it
DOSBIOS:0829		     lodsw
DOSBIOS:082A		     cmp     bx, 0FFFFh	     ; check for 0ffffh	(unlikely segment)
DOSBIOS:082D		     jz	     short i19_restor_1	; opt no need to check selector	too
DOSBIOS:082F		     cmp     ax, 0FFFFh	     ; opt 0ffffh is unlikely offset
DOSBIOS:0832		     jz	     short i19_restor_1
DOSBIOS:0834		     add     di, di
DOSBIOS:0836		     add     di, di
DOSBIOS:0838		     xchg    ax, bx
DOSBIOS:0839		     stosw
DOSBIOS:083A		     xchg    ax, bx
DOSBIOS:083B		     stosw		     ; put the vector back
DOSBIOS:083C
DOSBIOS:083C i19_restor_1:			     ; CODE XREF: DOSBIOS:082Dj
DOSBIOS:083C					     ; DOSBIOS:0832j
DOSBIOS:083C		     loop    i19_restore_loop
DOSBIOS:083E
DOSBIOS:083E doint19:				     ; CODE XREF: DOSBIOS:081Aj
DOSBIOS:083E		     cmp     inHMA, 0	     ; ; Is dos	running	from HMA
DOSBIOS:0843		     jz	     short SkipVDisk
DOSBIOS:0845		     call    EraseVDiskHead  ; Then erase our VDISK header at 1MB boundary
DOSBIOS:0845					     ; Some m/c's (AST 386 & HP QS/16 do not clear
DOSBIOS:0845					     ; the memory above	1MB during a warm boot.
DOSBIOS:0848
DOSBIOS:0848 SkipVDisk:				     ; CODE XREF: DOSBIOS:0843j
DOSBIOS:0848		     int     19h	     ; DISK BOOT
DOSBIOS:0848					     ; causes reboot of	disk system
DOSBIOS:084A
DOSBIOS:084A ; =============== S U B R O U T I N E =======================================
DOSBIOS:084A
DOSBIOS:084A
DOSBIOS:084A Int15	     proc near		     ; DATA XREF: DOSBIOS:1844o
DOSBIOS:084A		     cmp     ax, 4F53h	     ; del keystroke ?
DOSBIOS:084D		     jz	     short int15_1
DOSBIOS:084F		     jmp     cs:Old15
DOSBIOS:0854 ; ---------------------------------------------------------------------------
DOSBIOS:0854
DOSBIOS:0854 int15_1:				     ; CODE XREF: Int15+3j
DOSBIOS:0854		     push    ds
DOSBIOS:0855		     push    ax
DOSBIOS:0856		     mov     ax, 40h	     ; ROMDATASEG
DOSBIOS:0859		     mov     ds, ax
DOSBIOS:085B		     assume ds:nothing
DOSBIOS:085B		     mov     al, ds:17h	     ; [KBFLAG]
DOSBIOS:085E		     and     al, 0Ch	     ; (CTRLSTATE | ALTSTATE)
DOSBIOS:0860		     cmp     al, 0Ch	     ; (CTRLSTATE | ALTSTATE)
DOSBIOS:0862		     jnz     short int15_2
DOSBIOS:0864		     push    cs
DOSBIOS:0865		     pop     ds
DOSBIOS:0866		     assume ds:DOSBIOS
DOSBIOS:0866		     cmp     inHMA, 0	     ; is DOS running from HMA
DOSBIOS:086B		     jz	     short int15_2
DOSBIOS:086D		     call    EraseVDiskHead
DOSBIOS:0870
DOSBIOS:0870 int15_2:				     ; CODE XREF: Int15+18j
DOSBIOS:0870					     ; Int15+21j
DOSBIOS:0870		     pop     ax
DOSBIOS:0871		     pop     ds
DOSBIOS:0872		     assume ds:nothing
DOSBIOS:0872		     stc
DOSBIOS:0873		     jmp     cs:Old15
DOSBIOS:0873 Int15	     endp
DOSBIOS:0873
DOSBIOS:0878
DOSBIOS:0878 ; =============== S U B R O U T I N E =======================================
DOSBIOS:0878
DOSBIOS:0878
DOSBIOS:0878 EraseVDiskHead  proc near		     ; CODE XREF: DOSBIOS:0845p
DOSBIOS:0878					     ; Int15+23p
DOSBIOS:0878		     push    ax		     ; Erases the VDisk	Header present
DOSBIOS:0878					     ; in the 1MB boundary
DOSBIOS:0879		     push    cx
DOSBIOS:087A		     push    di
DOSBIOS:087B		     push    es
DOSBIOS:087C		     call    EnsureA20On
DOSBIOS:087F		     mov     ax, 0FFFFh	     ; HMA seg
DOSBIOS:0882		     mov     es, ax
DOSBIOS:0884		     assume es:nothing
DOSBIOS:0884		     mov     di, 10h	     ; point to	VDISK header
DOSBIOS:0887		     mov     cx, 10h	     ; size of vdisk header
DOSBIOS:088A		     xor     ax, ax
DOSBIOS:088C		     rep stosw		     ; clear it
DOSBIOS:088E		     pop     es
DOSBIOS:088F		     assume es:nothing
DOSBIOS:088F		     pop     di
DOSBIOS:0890		     pop     cx
DOSBIOS:0891		     pop     ax
DOSBIOS:0892		     retn
DOSBIOS:0892 EraseVDiskHead  endp
DOSBIOS:0892
DOSBIOS:0893 ; ---------------------------------------------------------------------------
DOSBIOS:0893
DOSBIOS:0893 int_2f:				     ; DATA XREF: DOSBIOS:off_706o
DOSBIOS:0893		     jmp     dword ptr cs:bcode_i2f
DOSBIOS:0898 ; ---------------------------------------------------------------------------
DOSBIOS:0898
DOSBIOS:0898 i2f_dskentry:			     ; CODE XREF: DOSBIOS:38DAJ
DOSBIOS:0898		     jmp     dsk_entry
DOSBIOS:089B ; ---------------------------------------------------------------------------
DOSBIOS:089B
DOSBIOS:089B re_init_:				     ; called back by sysinit after
DOSBIOS:089B		     retf		     ; a bunch of stuff	is done.
DOSBIOS:089B					     ; presently does nothing
DOSBIOS:089B ; ---------------------------------------------------------------------------
DOSBIOS:089C Win386_SI	     db	3, 0		     ; DATA XREF: DOSBIOS:3928o
DOSBIOS:089C					     ; SI_Version
DOSBIOS:089C					     ; Startup Info for	Win386
DOSBIOS:089E SI_Next	     dd	0		     ; DATA XREF: DOSBIOS:3920w
DOSBIOS:089E					     ; DOSBIOS:3924w
DOSBIOS:089E					     ; pointer to next info structure
DOSBIOS:08A2		     dd	0		     ; a field we don't need
DOSBIOS:08A6		     dd	0		     ; another field we	don't need
DOSBIOS:08AA SI_Instance     dw	offset Instance_Table
DOSBIOS:08AC		     dw	70h
DOSBIOS:08AE Instance_Table  dw	0, 50h		     ; DATA XREF: DOSBIOS:SI_Instanceo
DOSBIOS:08AE					     ; print screen status...
DOSBIOS:08B2		     dw	2		     ;	...2 bytes
DOSBIOS:08B4		     dw	0Eh, 50h	     ; ROM Basic data...
DOSBIOS:08B8		     dw	14h		     ; ...14H bytes
DOSBIOS:08BA		     dw	offset altah	     ; a con device buffer...
DOSBIOS:08BC		     dw	70h		     ; Bios_Data segment
DOSBIOS:08BE		     dw	1		     ; ... 1 byte
DOSBIOS:08C0 NextStack	     dw	0, 0		     ; pointer to next stack to	be used...
DOSBIOS:08C4		     dw	2		     ; ...2 bytes
DOSBIOS:08C6 IT_StackLoc     dd	0		     ; location	of hardware stacks
DOSBIOS:08CA IT_StackSize    dw	0		     ; size of hardware	stacks
DOSBIOS:08CC		     dd	0		     ; terminate the instance table
DOSBIOS:08CC					     ; SR;
DOSBIOS:08D0 IsWin386	     db	0		     ; DATA XREF: DOSBIOS:390Ew
DOSBIOS:08D0					     ; DOSBIOS:391Bw ...
DOSBIOS:08D0					     ; Flag to indicate	whether
DOSBIOS:08D0					     ; Win386 is running or not
DOSBIOS:08D1 ; ---------------------------------------------------------------------------
DOSBIOS:08D1
DOSBIOS:08D1 V86_Crit_SetFocus:			     ; CODE XREF: DOSBIOS:3CFDP
DOSBIOS:08D1		     push    di		     ; This routine was	originally in BIOS_CODE	but this causes	a lot of problems
DOSBIOS:08D1					     ; when we call it including checking of A20. The code being only about
DOSBIOS:08D1					     ; 30 bytes, we might as well put it in BIOS_DATA
DOSBIOS:08D2		     push    es
DOSBIOS:08D3		     push    bx
DOSBIOS:08D4		     push    ax
DOSBIOS:08D5		     xor     di, di
DOSBIOS:08D7		     mov     es, di
DOSBIOS:08D9		     assume es:nothing
DOSBIOS:08D9		     mov     bx, 15h	     ; Device ID of DOSMGR device
DOSBIOS:08DC		     mov     ax, 1684h	     ; Get API entry point
DOSBIOS:08DF		     int     2Fh	     ; - Multiplex - MS	WINDOWS	- GET DEVICE API ENTRY POINT
DOSBIOS:08DF					     ; BX = virtual device (VxD) ID, ES:DI = 0000h:0000h
DOSBIOS:08DF					     ; Return: ES:DI ->	VxD API	entry point, or	0:0 if the VxD does not	support	an API
DOSBIOS:08E1		     mov     ax, es
DOSBIOS:08E3		     or	     ax, di
DOSBIOS:08E5		     jz	     short Skip	     ; Here, es:di is address of API routine.
DOSBIOS:08E5					     ; Set up stack frame to simulate a	call.
DOSBIOS:08E7		     push    cs
DOSBIOS:08E8		     mov     ax, offset	Skip
DOSBIOS:08EB		     push    ax
DOSBIOS:08EC		     push    es
DOSBIOS:08ED		     push    di		     ; API far call address
DOSBIOS:08EE		     mov     ax, 1	     ; SetFocus	function number
DOSBIOS:08F1		     retf		     ; do the call
DOSBIOS:08F2 ; ---------------------------------------------------------------------------
DOSBIOS:08F2
DOSBIOS:08F2 Skip:				     ; CODE XREF: DOSBIOS:08E5j
DOSBIOS:08F2					     ; DATA XREF: DOSBIOS:08E8o
DOSBIOS:08F2		     pop     ax
DOSBIOS:08F3		     pop     bx
DOSBIOS:08F4		     pop     es
DOSBIOS:08F5		     assume es:nothing
DOSBIOS:08F5		     pop     di
DOSBIOS:08F6		     retf
DOSBIOS:08F6 ; ---------------------------------------------------------------------------
DOSBIOS:08F7 FreeHMAPtr	     dw	0FFFFh		     ; DATA XREF: DOSBIOS:try_4r
DOSBIOS:08F7					     ; DOSBIOS:3970w ...
DOSBIOS:08F9 MoveDOSIntoHMA  dd	46D0A84h	     ; DATA XREF: HMAPtr+15r
DOSBIOS:08F9					     ; FTryToMovDOSHi
DOSBIOS:08F9					     ; (procedure in SYSINIT segment)
DOSBIOS:08FD SysinitPresent  db	0		     ; DATA XREF: HMAPtr+Er
DOSBIOS:08FE endfloppy	     db	0, 0		     ; DATA XREF: DOSBIOS:1BE9o
DOSBIOS:08FE					     ; Bios_Data ends
DOSBIOS:08FE					     ; Possibly	disposable BIOS	data
DOSBIOS:08FE					     ; This data follows the regular BIOS data,
DOSBIOS:08FE					     ; and is part of the same group.
DOSBIOS:0900 nul_vid	     db	'NO NAME    ',0      ; DATA XREF: read_volume_id+Bo
DOSBIOS:0900					     ; null volume id
DOSBIOS:090C tmp_vid	     db	'NO NAME    ',0      ; DATA XREF: read_volume_id+8o
DOSBIOS:090C					     ; read_volume_id+7Co ...
DOSBIOS:090C					     ; vid scratch buffer
DOSBIOS:0918 harddrv	     db	80h		     ; DATA XREF: DOSBIOS:1A1Fo
DOSBIOS:0918					     ; DOSBIOS:1BDFo
DOSBIOS:0918					     ; end96tpi
DOSBIOS:0918					     ; memory allocation for bdss
DOSBIOS:0919 bdss	     dw	0FFFFh		     ; DATA XREF: DOSBIOS:end_of_bdsso
DOSBIOS:0919					     ; DOSBIOS:1BD9o
DOSBIOS:091B		     db	0, 0, 50h, 3, 0, 2, 1, 1, 0, 2,	10h, 0,	0, 0, 0F8h
DOSBIOS:091B		     db	1, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 3
DOSBIOS:091B		     db	20h, 0,	28h, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0
DOSBIOS:091B		     db	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0
DOSBIOS:091B		     db	0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
DOSBIOS:091B		     db	20h, 20h, 20h, 20h, 0, 0, 0, 0,	0, 46h,	41h, 54h, 31h
DOSBIOS:091B		     db	32h, 20h, 20h, 20h, 0
DOSBIOS:097D		     dw	0FFFFh
DOSBIOS:097F		     db	0, 0, 50h, 3, 0, 2, 1, 1, 0, 2,	10h, 0,	0, 0, 0F8h
DOSBIOS:097F		     db	1, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 3
DOSBIOS:097F		     db	20h, 0,	28h, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0
DOSBIOS:097F		     db	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0
DOSBIOS:097F		     db	0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
DOSBIOS:097F		     db	20h, 20h, 20h, 20h, 0, 0, 0, 0,	0, 46h,	41h, 54h, 31h
DOSBIOS:097F		     db	32h, 20h, 20h, 20h, 0
DOSBIOS:09E1		     dw	0FFFFh
DOSBIOS:09E3		     db	0, 0, 50h, 3, 0, 2, 1, 1, 0, 2,	10h, 0,	0, 0, 0F8h
DOSBIOS:09E3		     db	1, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 3
DOSBIOS:09E3		     db	20h, 0,	28h, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0
DOSBIOS:09E3		     db	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0
DOSBIOS:09E3		     db	0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
DOSBIOS:09E3		     db	20h, 20h, 20h, 20h, 0, 0, 0, 0,	0, 46h,	41h, 54h, 31h
DOSBIOS:09E3		     db	32h, 20h, 20h, 20h, 0
DOSBIOS:0A45		     dw	0FFFFh
DOSBIOS:0A47		     db	0, 0, 50h, 3, 0, 2, 1, 1, 0, 2,	10h, 0,	0, 0, 0F8h
DOSBIOS:0A47		     db	1, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 3
DOSBIOS:0A47		     db	20h, 0,	28h, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0
DOSBIOS:0A47		     db	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0
DOSBIOS:0A47		     db	0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
DOSBIOS:0A47		     db	20h, 20h, 20h, 20h, 0, 0, 0, 0,	0, 46h,	41h, 54h, 31h
DOSBIOS:0A47		     db	32h, 20h, 20h, 20h, 0
DOSBIOS:0AA9		     dw	0FFFFh
DOSBIOS:0AAB		     db	0, 0, 50h, 3, 0, 2, 1, 1, 0, 2,	10h, 0,	0, 0, 0F8h
DOSBIOS:0AAB		     db	1, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 3
DOSBIOS:0AAB		     db	20h, 0,	28h, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0
DOSBIOS:0AAB		     db	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0
DOSBIOS:0AAB		     db	0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
DOSBIOS:0AAB		     db	20h, 20h, 20h, 20h, 0, 0, 0, 0,	0, 46h,	41h, 54h, 31h
DOSBIOS:0AAB		     db	32h, 20h, 20h, 20h, 0
DOSBIOS:0B0D		     dw	0FFFFh
DOSBIOS:0B0F		     db	0, 0, 50h, 3, 0, 2, 1, 1, 0, 2,	10h, 0,	0, 0, 0F8h
DOSBIOS:0B0F		     db	1, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 3
DOSBIOS:0B0F		     db	20h, 0,	28h, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0
DOSBIOS:0B0F		     db	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0
DOSBIOS:0B0F		     db	0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
DOSBIOS:0B0F		     db	20h, 20h, 20h, 20h, 0, 0, 0, 0,	0, 46h,	41h, 54h, 31h
DOSBIOS:0B0F		     db	32h, 20h, 20h, 20h, 0
DOSBIOS:0B71		     dw	0FFFFh
DOSBIOS:0B73		     db	0, 0, 50h, 3, 0, 2, 1, 1, 0, 2,	10h, 0,	0, 0, 0F8h
DOSBIOS:0B73		     db	1, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 3
DOSBIOS:0B73		     db	20h, 0,	28h, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0
DOSBIOS:0B73		     db	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0
DOSBIOS:0B73		     db	0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
DOSBIOS:0B73		     db	20h, 20h, 20h, 20h, 0, 0, 0, 0,	0, 46h,	41h, 54h, 31h
DOSBIOS:0B73		     db	32h, 20h, 20h, 20h, 0
DOSBIOS:0BD5		     dw	0FFFFh
DOSBIOS:0BD7		     db	0, 0, 50h, 3, 0, 2, 1, 1, 0, 2,	10h, 0,	0, 0, 0F8h
DOSBIOS:0BD7		     db	1, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 3
DOSBIOS:0BD7		     db	20h, 0,	28h, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0
DOSBIOS:0BD7		     db	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0
DOSBIOS:0BD7		     db	0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
DOSBIOS:0BD7		     db	20h, 20h, 20h, 20h, 0, 0, 0, 0,	0, 46h,	41h, 54h, 31h
DOSBIOS:0BD7		     db	32h, 20h, 20h, 20h, 0
DOSBIOS:0C39		     dw	0FFFFh
DOSBIOS:0C3B		     db	0, 0, 50h, 3, 0, 2, 1, 1, 0, 2,	10h, 0,	0, 0, 0F8h
DOSBIOS:0C3B		     db	1, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 3
DOSBIOS:0C3B		     db	20h, 0,	28h, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0
DOSBIOS:0C3B		     db	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0
DOSBIOS:0C3B		     db	0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
DOSBIOS:0C3B		     db	20h, 20h, 20h, 20h, 0, 0, 0, 0,	0, 46h,	41h, 54h, 31h
DOSBIOS:0C3B		     db	32h, 20h, 20h, 20h, 0
DOSBIOS:0C9D		     dw	0FFFFh
DOSBIOS:0C9F		     db	0, 0, 50h, 3, 0, 2, 1, 1, 0, 2,	10h, 0,	0, 0, 0F8h
DOSBIOS:0C9F		     db	1, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 3
DOSBIOS:0C9F		     db	20h, 0,	28h, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0
DOSBIOS:0C9F		     db	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0
DOSBIOS:0C9F		     db	0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
DOSBIOS:0C9F		     db	20h, 20h, 20h, 20h, 0, 0, 0, 0,	0, 46h,	41h, 54h, 31h
DOSBIOS:0C9F		     db	32h, 20h, 20h, 20h, 0
DOSBIOS:0D01		     dw	0FFFFh
DOSBIOS:0D03		     db	0, 0, 50h, 3, 0, 2, 1, 1, 0, 2,	10h, 0,	0, 0, 0F8h
DOSBIOS:0D03		     db	1, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 3
DOSBIOS:0D03		     db	20h, 0,	28h, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0
DOSBIOS:0D03		     db	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0
DOSBIOS:0D03		     db	0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
DOSBIOS:0D03		     db	20h, 20h, 20h, 20h, 0, 0, 0, 0,	0, 46h,	41h, 54h, 31h
DOSBIOS:0D03		     db	32h, 20h, 20h, 20h, 0
DOSBIOS:0D65		     dw	0FFFFh
DOSBIOS:0D67		     db	0, 0, 50h, 3, 0, 2, 1, 1, 0, 2,	10h, 0,	0, 0, 0F8h
DOSBIOS:0D67		     db	1, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 3
DOSBIOS:0D67		     db	20h, 0,	28h, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0
DOSBIOS:0D67		     db	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0
DOSBIOS:0D67		     db	0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
DOSBIOS:0D67		     db	20h, 20h, 20h, 20h, 0, 0, 0, 0,	0, 46h,	41h, 54h, 31h
DOSBIOS:0D67		     db	32h, 20h, 20h, 20h, 0
DOSBIOS:0DC9		     dw	0FFFFh
DOSBIOS:0DCB		     db	0, 0, 50h, 3, 0, 2, 1, 1, 0, 2,	10h, 0,	0, 0, 0F8h
DOSBIOS:0DCB		     db	1, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 3
DOSBIOS:0DCB		     db	20h, 0,	28h, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0
DOSBIOS:0DCB		     db	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0
DOSBIOS:0DCB		     db	0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
DOSBIOS:0DCB		     db	20h, 20h, 20h, 20h, 0, 0, 0, 0,	0, 46h,	41h, 54h, 31h
DOSBIOS:0DCB		     db	32h, 20h, 20h, 20h, 0
DOSBIOS:0E2D		     dw	0FFFFh
DOSBIOS:0E2F		     db	0, 0, 50h, 3, 0, 2, 1, 1, 0, 2,	10h, 0,	0, 0, 0F8h
DOSBIOS:0E2F		     db	1, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 3
DOSBIOS:0E2F		     db	20h, 0,	28h, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0
DOSBIOS:0E2F		     db	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0
DOSBIOS:0E2F		     db	0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
DOSBIOS:0E2F		     db	20h, 20h, 20h, 20h, 0, 0, 0, 0,	0, 46h,	41h, 54h, 31h
DOSBIOS:0E2F		     db	32h, 20h, 20h, 20h, 0
DOSBIOS:0E91		     dw	0FFFFh
DOSBIOS:0E93		     db	0, 0, 50h, 3, 0, 2, 1, 1, 0, 2,	10h, 0,	0, 0, 0F8h
DOSBIOS:0E93		     db	1, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 3
DOSBIOS:0E93		     db	20h, 0,	28h, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0
DOSBIOS:0E93		     db	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0
DOSBIOS:0E93		     db	0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
DOSBIOS:0E93		     db	20h, 20h, 20h, 20h, 0, 0, 0, 0,	0, 46h,	41h, 54h, 31h
DOSBIOS:0E93		     db	32h, 20h, 20h, 20h, 0
DOSBIOS:0EF5		     dw	0FFFFh
DOSBIOS:0EF7		     db	0, 0, 50h, 3, 0, 2, 1, 1, 0, 2,	10h, 0,	0, 0, 0F8h
DOSBIOS:0EF7		     db	1, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 3
DOSBIOS:0EF7		     db	20h, 0,	28h, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0
DOSBIOS:0EF7		     db	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0
DOSBIOS:0EF7		     db	0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
DOSBIOS:0EF7		     db	20h, 20h, 20h, 20h, 0, 0, 0, 0,	0, 46h,	41h, 54h, 31h
DOSBIOS:0EF7		     db	32h, 20h, 20h, 20h, 0
DOSBIOS:0F59		     dw	0FFFFh
DOSBIOS:0F5B		     db	0, 0, 50h, 3, 0, 2, 1, 1, 0, 2,	10h, 0,	0, 0, 0F8h
DOSBIOS:0F5B		     db	1, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 3
DOSBIOS:0F5B		     db	20h, 0,	28h, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0
DOSBIOS:0F5B		     db	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0
DOSBIOS:0F5B		     db	0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
DOSBIOS:0F5B		     db	20h, 20h, 20h, 20h, 0, 0, 0, 0,	0, 46h,	41h, 54h, 31h
DOSBIOS:0F5B		     db	32h, 20h, 20h, 20h, 0
DOSBIOS:0FBD		     dw	0FFFFh
DOSBIOS:0FBF		     db	0, 0, 50h, 3, 0, 2, 1, 1, 0, 2,	10h, 0,	0, 0, 0F8h
DOSBIOS:0FBF		     db	1, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 3
DOSBIOS:0FBF		     db	20h, 0,	28h, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0
DOSBIOS:0FBF		     db	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0
DOSBIOS:0FBF		     db	0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
DOSBIOS:0FBF		     db	20h, 20h, 20h, 20h, 0, 0, 0, 0,	0, 46h,	41h, 54h, 31h
DOSBIOS:0FBF		     db	32h, 20h, 20h, 20h, 0
DOSBIOS:1021		     dw	0FFFFh
DOSBIOS:1023		     db	0, 0, 50h, 3, 0, 2, 1, 1, 0, 2,	10h, 0,	0, 0, 0F8h
DOSBIOS:1023		     db	1, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 3
DOSBIOS:1023		     db	20h, 0,	28h, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0
DOSBIOS:1023		     db	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0
DOSBIOS:1023		     db	0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
DOSBIOS:1023		     db	20h, 20h, 20h, 20h, 0, 0, 0, 0,	0, 46h,	41h, 54h, 31h
DOSBIOS:1023		     db	32h, 20h, 20h, 20h, 0
DOSBIOS:1085		     dw	0FFFFh
DOSBIOS:1087		     db	0, 0, 50h, 3, 0, 2, 1, 1, 0, 2,	10h, 0,	0, 0, 0F8h
DOSBIOS:1087		     db	1, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 3
DOSBIOS:1087		     db	20h, 0,	28h, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0
DOSBIOS:1087		     db	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0
DOSBIOS:1087		     db	0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
DOSBIOS:1087		     db	20h, 20h, 20h, 20h, 0, 0, 0, 0,	0, 46h,	41h, 54h, 31h
DOSBIOS:1087		     db	32h, 20h, 20h, 20h, 0
DOSBIOS:10E9		     dw	0FFFFh
DOSBIOS:10EB		     db	0, 0, 50h, 3, 0, 2, 1, 1, 0, 2,	10h, 0,	0, 0, 0F8h
DOSBIOS:10EB		     db	1, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 3
DOSBIOS:10EB		     db	20h, 0,	28h, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0
DOSBIOS:10EB		     db	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0
DOSBIOS:10EB		     db	0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
DOSBIOS:10EB		     db	20h, 20h, 20h, 20h, 0, 0, 0, 0,	0, 46h,	41h, 54h, 31h
DOSBIOS:10EB		     db	32h, 20h, 20h, 20h, 0
DOSBIOS:114D		     dw	0FFFFh
DOSBIOS:114F		     db	0, 0, 50h, 3, 0, 2, 1, 1, 0, 2,	10h, 0,	0, 0, 0F8h
DOSBIOS:114F		     db	1, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 3
DOSBIOS:114F		     db	20h, 0,	28h, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0
DOSBIOS:114F		     db	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0
DOSBIOS:114F		     db	0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
DOSBIOS:114F		     db	20h, 20h, 20h, 20h, 0, 0, 0, 0,	0, 46h,	41h, 54h, 31h
DOSBIOS:114F		     db	32h, 20h, 20h, 20h, 0
DOSBIOS:11B1		     dw	0FFFFh
DOSBIOS:11B3		     db	0, 0, 50h, 3, 0, 2, 1, 1, 0, 2,	10h, 0,	0, 0, 0F8h
DOSBIOS:11B3		     db	1, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 3
DOSBIOS:11B3		     db	20h, 0,	28h, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0
DOSBIOS:11B3		     db	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0
DOSBIOS:11B3		     db	0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
DOSBIOS:11B3		     db	20h, 20h, 20h, 20h, 0, 0, 0, 0,	0, 46h,	41h, 54h, 31h
DOSBIOS:11B3		     db	32h, 20h, 20h, 20h, 0
DOSBIOS:1215		     dw	0FFFFh
DOSBIOS:1217		     db	0, 0, 50h, 3, 0, 2, 1, 1, 0, 2,	10h, 0,	0, 0, 0F8h
DOSBIOS:1217		     db	1, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 3
DOSBIOS:1217		     db	20h, 0,	28h, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0
DOSBIOS:1217		     db	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0
DOSBIOS:1217		     db	0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
DOSBIOS:1217		     db	20h, 20h, 20h, 20h, 0, 0, 0, 0,	0, 46h,	41h, 54h, 31h
DOSBIOS:1217		     db	32h, 20h, 20h, 20h, 0
DOSBIOS:1279		     dw	0FFFFh
DOSBIOS:127B		     db	0, 0, 50h, 3, 0, 2, 1, 1, 0, 2,	10h, 0,	0, 0, 0F8h
DOSBIOS:127B		     db	1, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 3
DOSBIOS:127B		     db	20h, 0,	28h, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0
DOSBIOS:127B		     db	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0
DOSBIOS:127B		     db	0, 0FFh, 1, 0, 0, 0, 4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
DOSBIOS:127B		     db	20h, 20h, 20h, 20h, 0, 0, 0, 0,	0, 46h,	41h, 54h, 31h
DOSBIOS:127B		     db	32h, 20h, 20h, 20h, 0
DOSBIOS:12DD		     db	0
DOSBIOS:12DE ; ---------------------------------------------------------------------------
DOSBIOS:12DE
DOSBIOS:12DE ibm_disk_io:			     ; DATA XREF: DOSBIOS:1C14o
DOSBIOS:12DE		     cmp     dl, 80h	     ; main routine, fixes at rom bug
DOSBIOS:12E1		     jb	     short atd1
DOSBIOS:12E3		     cmp     ah, 2
DOSBIOS:12E6		     jz	     short atd2
DOSBIOS:12E8		     cmp     ah, 0Ah
DOSBIOS:12EB		     jz	     short atd2
DOSBIOS:12ED
DOSBIOS:12ED atd1:				     ; CODE XREF: DOSBIOS:12E1j
DOSBIOS:12ED		     jmp     cs:Old13	     ; jmp far [cs:Old13]
DOSBIOS:12ED					     ; use rom int 13h handler
DOSBIOS:12F2 ; ---------------------------------------------------------------------------
DOSBIOS:12F2
DOSBIOS:12F2 atd2:				     ; CODE XREF: DOSBIOS:12E6j
DOSBIOS:12F2					     ; DOSBIOS:12EBj
DOSBIOS:12F2		     push    bx
DOSBIOS:12F3		     push    cx
DOSBIOS:12F4		     push    dx
DOSBIOS:12F5		     push    di
DOSBIOS:12F6		     push    ds
DOSBIOS:12F7		     push    es
DOSBIOS:12F8		     push    ax
DOSBIOS:12F9		     mov     ax, 40h	     ; bioseg
DOSBIOS:12F9					     ; establish bios segment addressing
DOSBIOS:12FC		     mov     ds, ax
DOSBIOS:12FE		     assume ds:nothing
DOSBIOS:12FE		     mov     byte ptr ds:74h, 0	; [disk_status1]
DOSBIOS:1303		     and     dl, 7Fh
DOSBIOS:1306		     cmp     dl, ds:drvmax   ; [hf_num]
DOSBIOS:130A		     jb	     short atd3
DOSBIOS:130C		     mov     byte ptr ds:74h, 1	; bad_disk
DOSBIOS:1311		     jmp     short atd4
DOSBIOS:1313 ; ---------------------------------------------------------------------------
DOSBIOS:1313
DOSBIOS:1313 atd3:				     ; CODE XREF: DOSBIOS:130Aj
DOSBIOS:1313		     push    bx
DOSBIOS:1314		     mov     ax, es
DOSBIOS:1316		     shr     bx, 4
DOSBIOS:1319		     add     ax, bx
DOSBIOS:131B		     mov     es, ax
DOSBIOS:131D		     pop     bx
DOSBIOS:131E		     and     bx, 0Fh
DOSBIOS:1321		     push    cs
DOSBIOS:1322		     call    check_dma
DOSBIOS:1325 ; ---------------------------------------------------------------------------
DOSBIOS:1325		     jb	     short atd4
DOSBIOS:1327		     pop     ax
DOSBIOS:1328		     push    ax
DOSBIOS:1329		     call    setcmd
DOSBIOS:132C ; ---------------------------------------------------------------------------
DOSBIOS:132C		     mov     dx, 3F6h
DOSBIOS:132F		     out     dx, al	     ; AT only.	Fixed disk register
DOSBIOS:1330		     call    docmd
DOSBIOS:1333 ; ---------------------------------------------------------------------------
DOSBIOS:1333
DOSBIOS:1333 atd4:				     ; CODE XREF: DOSBIOS:1311j
DOSBIOS:1333					     ; DOSBIOS:1325j
DOSBIOS:1333		     pop     ax
DOSBIOS:1334		     mov     ah, ds:74h	     ; [disk_status1]
DOSBIOS:1338		     or	     ah, ah
DOSBIOS:133A		     jz	     short atd5
DOSBIOS:133C		     stc
DOSBIOS:133D
DOSBIOS:133D atd5:				     ; CODE XREF: DOSBIOS:133Aj
DOSBIOS:133D		     pop     es
DOSBIOS:133E		     pop     ds
DOSBIOS:133F		     assume ds:nothing
DOSBIOS:133F		     pop     di
DOSBIOS:1340		     pop     dx
DOSBIOS:1341		     pop     cx
DOSBIOS:1342		     pop     bx
DOSBIOS:1343		     retf    2		     ; far return, dropping flags
DOSBIOS:1346
DOSBIOS:1346 ; =============== S U B R O U T I N E =======================================
DOSBIOS:1346
DOSBIOS:1346 ; Attributes: noreturn
DOSBIOS:1346
DOSBIOS:1346 setcmd	     proc near		     ; CODE XREF: DOSBIOS:1329p
DOSBIOS:1346		     mov     ds:43h, al	     ; [cmd_block+sec_cnt]
DOSBIOS:1349		     mov     byte ptr ds:48h, 20h ; [cmd_block+cmd_reg]
DOSBIOS:134E		     cmp     ah, 2
DOSBIOS:1351		     jz	     short setc1     ; cmd_reg = 20h if	function 02h (read)
DOSBIOS:1353		     mov     byte ptr ds:48h, 22h ; [cmd_block+cmd_reg]
DOSBIOS:1353					     ; cmd_reg = 22h if	function 0Ah (read long)
DOSBIOS:1358
DOSBIOS:1358 setc1:				     ; CODE XREF: setcmd+Bj
DOSBIOS:1358		     mov     al, cl
DOSBIOS:135A		     and     al, 3Fh	     ; mask sector number
DOSBIOS:135C		     mov     ds:44h, al	     ; [cmd_block+sec_num]
DOSBIOS:135F		     mov     ds:45h, ch	     ; [cmd_block+cyl_low]
DOSBIOS:1363		     mov     al, cl
DOSBIOS:1365		     shr     al, 6	     ; get two high bits of cylinder number
DOSBIOS:1368		     mov     ds:46h, al	     ; [cmd_block+cyl_high]
DOSBIOS:136B		     mov     ax, dx
DOSBIOS:136D		     shl     al, 4	     ; drive number
DOSBIOS:1370		     and     ah, 0Fh
DOSBIOS:1373		     or	     al, ah	     ; head number
DOSBIOS:1375		     or	     al, 0A0h	     ; set ecc and 512 bytes per sector
DOSBIOS:1377		     mov     ds:47h, al	     ; [cmd_block+drv_head]
DOSBIOS:137A		     push    es
DOSBIOS:137B		     push    bx
DOSBIOS:137C		     push    cs
DOSBIOS:137D		     call    get_vec
DOSBIOS:1380 ; ---------------------------------------------------------------------------
DOSBIOS:1380		     mov     ax, es:[bx+5]   ; [es:bx+fdp_precomp]
DOSBIOS:1384		     shr     ax, 2
DOSBIOS:1387		     mov     ds:42h, al	     ; [cmd_block+pre_comp]
DOSBIOS:138A		     mov     al, es:[bx+8]   ; [es:bx+fdp_control]
DOSBIOS:138E		     pop     bx
DOSBIOS:138F		     pop     es
DOSBIOS:1390		     mov     ah, ds:76h	     ; [control_byte]
DOSBIOS:1394		     and     ah, 0C0h
DOSBIOS:1397		     or	     ah, al
DOSBIOS:1399		     mov     ds:76h, ah
DOSBIOS:139D		     retn
DOSBIOS:139D setcmd	     endp
DOSBIOS:139D
DOSBIOS:139E
DOSBIOS:139E ; =============== S U B R O U T I N E =======================================
DOSBIOS:139E
DOSBIOS:139E ; Attributes: noreturn
DOSBIOS:139E
DOSBIOS:139E docmd	     proc near		     ; CODE XREF: DOSBIOS:1330p
DOSBIOS:139E		     mov     di, bx
DOSBIOS:13A0		     push    cs
DOSBIOS:13A1		     call    command
DOSBIOS:13A4 ; ---------------------------------------------------------------------------
DOSBIOS:13A4		     jnz     short doc3
DOSBIOS:13A6
DOSBIOS:13A6 doc1:				     ; CODE XREF: docmd+3Bj
DOSBIOS:13A6		     push    cs
DOSBIOS:13A7		     call    waitt	     ; wait for	controller to complete read
DOSBIOS:13AA ; ---------------------------------------------------------------------------
DOSBIOS:13AA		     jnz     short doc3
DOSBIOS:13AC		     mov     cx, 256
DOSBIOS:13AF		     mov     dx, 1F0h	     ; hf_port
DOSBIOS:13B2		     cld
DOSBIOS:13B3		     cli
DOSBIOS:13B4
DOSBIOS:13B4 rsct_loop:				     ; CODE XREF: docmd+17j
DOSBIOS:13B4		     insw
DOSBIOS:13B5		     loop    rsct_loop
DOSBIOS:13B7		     sti
DOSBIOS:13B8		     test    byte ptr ds:48h, 2	; [cmd_block+cmd_reg]
DOSBIOS:13B8					     ; (ds = 40h)
DOSBIOS:13BD		     jz	     short doc2
DOSBIOS:13BF		     push    cs
DOSBIOS:13C0		     call    wait_drq
DOSBIOS:13C3 ; ---------------------------------------------------------------------------
DOSBIOS:13C3		     jb	     short doc3
DOSBIOS:13C5		     mov     cx, 4
DOSBIOS:13C8		     mov     dx, 1F0h
DOSBIOS:13CB		     cli
DOSBIOS:13CC		     rep insb
DOSBIOS:13CE		     sti
DOSBIOS:13CF
DOSBIOS:13CF doc2:				     ; CODE XREF: docmd+1Fj
DOSBIOS:13CF		     push    cs
DOSBIOS:13D0		     call    check_status
DOSBIOS:13D3 ; ---------------------------------------------------------------------------
DOSBIOS:13D3		     jnz     short doc3
DOSBIOS:13D5		     dec     byte ptr ds:43h ; [cmd_block+sec_cnt]
DOSBIOS:13D9		     jnz     short doc1
DOSBIOS:13DB
DOSBIOS:13DB doc3:				     ; CODE XREF: docmd+6j
DOSBIOS:13DB					     ; docmd+Cj ...
DOSBIOS:13DB		     retn
DOSBIOS:13DB docmd	     endp
DOSBIOS:13DB
DOSBIOS:13DC
DOSBIOS:13DC ; =============== S U B R O U T I N E =======================================
DOSBIOS:13DC
DOSBIOS:13DC ; Attributes: noreturn
DOSBIOS:13DC
DOSBIOS:13DC get_vec	     proc near		     ; CODE XREF: setcmd+37p
DOSBIOS:13DC		     push    0FF65h	     ; romfret ; far return in rom
DOSBIOS:13DF		     jmp     far ptr 0F000h:2F8Eh ; jmp	romsegment:romget_vec
DOSBIOS:13DF get_vec	     endp
DOSBIOS:13DF
DOSBIOS:13E4
DOSBIOS:13E4 ; =============== S U B R O U T I N E =======================================
DOSBIOS:13E4
DOSBIOS:13E4 ; Attributes: noreturn
DOSBIOS:13E4
DOSBIOS:13E4 command	     proc near		     ; CODE XREF: docmd+3p
DOSBIOS:13E4		     push    0FF65h	     ; romfret ; far return in rom
DOSBIOS:13E7		     jmp     far ptr 0F000h:2E1Eh ; jmp	romsegment:romcommand
DOSBIOS:13E7 command	     endp
DOSBIOS:13E7
DOSBIOS:13EC
DOSBIOS:13EC ; =============== S U B R O U T I N E =======================================
DOSBIOS:13EC
DOSBIOS:13EC ; Attributes: noreturn
DOSBIOS:13EC
DOSBIOS:13EC waitt	     proc near		     ; CODE XREF: docmd+9p
DOSBIOS:13EC		     push    0FF65h	     ; romfret ; far return in rom
DOSBIOS:13EF		     jmp     far ptr 0F000h:2E7Fh ; jmp	romsegment:romwait
DOSBIOS:13EF waitt	     endp
DOSBIOS:13EF
DOSBIOS:13F4
DOSBIOS:13F4 ; =============== S U B R O U T I N E =======================================
DOSBIOS:13F4
DOSBIOS:13F4 ; Attributes: noreturn
DOSBIOS:13F4
DOSBIOS:13F4 wait_drq	     proc near		     ; CODE XREF: docmd+22p
DOSBIOS:13F4		     push    0FF65h	     ; romfret ; far return in rom
DOSBIOS:13F7		     jmp     far ptr 0F000h:2EE2h ; romsegment:romwait_drq
DOSBIOS:13F7 wait_drq	     endp
DOSBIOS:13F7
DOSBIOS:13FC
DOSBIOS:13FC ; =============== S U B R O U T I N E =======================================
DOSBIOS:13FC
DOSBIOS:13FC ; Attributes: noreturn
DOSBIOS:13FC
DOSBIOS:13FC check_status    proc near		     ; CODE XREF: docmd+32p
DOSBIOS:13FC		     push    0FF65h	     ; romfret ; far return in rom
DOSBIOS:13FF		     jmp     far ptr 0F000h:2EF8h ; jmp	romsegment:romcheck_status
DOSBIOS:13FF check_status    endp
DOSBIOS:13FF
DOSBIOS:1404
DOSBIOS:1404 ; =============== S U B R O U T I N E =======================================
DOSBIOS:1404
DOSBIOS:1404 ; Attributes: noreturn
DOSBIOS:1404
DOSBIOS:1404 check_dma	     proc near		     ; CODE XREF: DOSBIOS:1322p
DOSBIOS:1404		     push    0FF65h	     ; romfret ; far return in rom
DOSBIOS:1407		     jmp     far ptr 0F000h:2F69h ; jmp	romsegment:romcheck_dma
DOSBIOS:1407 check_dma	     endp
DOSBIOS:1407
DOSBIOS:140C ; ---------------------------------------------------------------------------
DOSBIOS:140C
DOSBIOS:140C endatrom:				     ; DATA XREF: DOSBIOS:1C11o
DOSBIOS:140C					     ; DOSBIOS:1C61o
DOSBIOS:140C		     cmp     ah, 15h	     ; compaq_disk_io proc far
DOSBIOS:140C					     ;
DOSBIOS:140C					     ; the following label defines the end of the at rom patch.
DOSBIOS:140C					     ; this is used at configuration time.
DOSBIOS:140C					     ;
DOSBIOS:140C					     ; warning!!!
DOSBIOS:140C					     ; this code will be dynamically relocated by msinit
DOSBIOS:140F		     ja	     short mebbe_hookit	; only deal with functions > 15h
DOSBIOS:1411
DOSBIOS:1411 no_hookit:				     ; CODE XREF: DOSBIOS:1419j
DOSBIOS:1411		     jmp     cs:Old13
DOSBIOS:1416 ; ---------------------------------------------------------------------------
DOSBIOS:1416
DOSBIOS:1416 mebbe_hookit:			     ; CODE XREF: DOSBIOS:140Fj
DOSBIOS:1416		     cmp     dl, 80h
DOSBIOS:1419		     jb	     short no_hookit
DOSBIOS:141B		     push    ds
DOSBIOS:141C		     push    ax
DOSBIOS:141D		     mov     ax, 40h
DOSBIOS:1420		     mov     ds, ax
DOSBIOS:1422		     assume ds:nothing
DOSBIOS:1422		     pop     ax
DOSBIOS:1423		     pushf
DOSBIOS:1424		     call    cs:Old13
DOSBIOS:1429		     pop     ds
DOSBIOS:142A		     assume ds:nothing
DOSBIOS:142A		     retf    2
DOSBIOS:142A ; ---------------------------------------------------------------------------
DOSBIOS:142D end_compaq_i13hook	db 0		     ; DATA XREF: DOSBIOS:do_compaq_patcho
DOSBIOS:142E
DOSBIOS:142E ; =============== S U B R O U T I N E =======================================
DOSBIOS:142E
DOSBIOS:142E
DOSBIOS:142E daycnt_to_day   proc far		     ; CODE XREF: DOSBIOS:2999P
DOSBIOS:142E					     ; DATA XREF: DOSBIOS:daycnttodayo	...
DOSBIOS:142E		     push    cs:daycnt
DOSBIOS:1433		     cmp     cs:daycnt,	7305 ; (365*20+(20/4))
DOSBIOS:1433					     ; # days from 1-1-1980 to 1-1-2000
DOSBIOS:143A		     jnb     short century20
DOSBIOS:143C		     mov     cs:base_century, 19
DOSBIOS:1442		     mov     cs:base_year, 80
DOSBIOS:1448		     jmp     short years
DOSBIOS:144A ; ---------------------------------------------------------------------------
DOSBIOS:144A
DOSBIOS:144A century20:				     ; CODE XREF: daycnt_to_day+Cj
DOSBIOS:144A		     mov     cs:base_century, 20
DOSBIOS:1450		     mov     cs:base_year, 0
DOSBIOS:1456		     sub     cs:daycnt,	7305 ; (365*20+(20/4))
DOSBIOS:1456					     ; adjust daycnt
DOSBIOS:145D
DOSBIOS:145D years:				     ; CODE XREF: daycnt_to_day+1Aj
DOSBIOS:145D		     xor     dx, dx
DOSBIOS:145F		     mov     ax, cs:daycnt
DOSBIOS:1463		     mov     bx, 1461	     ; (366+365*3)
DOSBIOS:1463					     ; # of days in a Leap year	block
DOSBIOS:1466		     div     bx		     ; AX = # of leap block, DX	= daycnt
DOSBIOS:1468		     mov     cs:daycnt,	dx   ; save daycnt left
DOSBIOS:146D		     mov     bl, 4
DOSBIOS:146F		     mul     bl		     ; AX = # of years.	Less than 100
DOSBIOS:1471		     add     cs:base_year, al ;	So, ah = 0. Adjust year
DOSBIOS:1476		     inc     cs:daycnt	     ; set daycnt to 1 base
DOSBIOS:147B		     cmp     cs:daycnt,	366  ; daycnt=remainder	of leap	year bk
DOSBIOS:1482		     jbe     short leapyear  ; within 366+355+355+355 days.
DOSBIOS:1484		     inc     cs:base_year    ; if daycnt <= 366, then leap year
DOSBIOS:1489		     sub     cs:daycnt,	366  ; else daycnt--, base_year++ ;
DOSBIOS:1490		     mov     cx, 3	     ; And next	three years are	normal
DOSBIOS:1493
DOSBIOS:1493 regularyear:			     ; CODE XREF: daycnt_to_day+7Aj
DOSBIOS:1493		     cmp     cs:daycnt,	365  ; for(i=1;	i>3 or daycnt <=365; i++)
DOSBIOS:149A		     jbe     short yeardone  ; {if (daycnt > 365)
DOSBIOS:149C		     inc     cs:base_year    ;	 { daycnt -= 365
DOSBIOS:14A1		     sub     cs:daycnt,	365  ;	 }
DOSBIOS:14A8		     loop    regularyear     ; }
DOSBIOS:14A8					     ;
DOSBIOS:14A8					     ; should never fall through loop
DOSBIOS:14AA
DOSBIOS:14AA leapyear:				     ; CODE XREF: daycnt_to_day+54j
DOSBIOS:14AA		     mov     cs:month_tab+1, 29	; leap year.
DOSBIOS:14AA					     ; change month table.
DOSBIOS:14B0
DOSBIOS:14B0 yeardone:				     ; CODE XREF: daycnt_to_day+6Cj
DOSBIOS:14B0		     xor     bx, bx
DOSBIOS:14B2		     xor     dx, dx
DOSBIOS:14B4		     mov     ax, cs:daycnt
DOSBIOS:14B8		     mov     si, offset	month_tab
DOSBIOS:14BB		     mov     cx, 12
DOSBIOS:14BE
DOSBIOS:14BE months:				     ; CODE XREF: daycnt_to_day+9Bj
DOSBIOS:14BE		     inc     bl
DOSBIOS:14C0		     mov     dl, [si]	     ; mov dl, [cs:si]
DOSBIOS:14C2		     cmp     ax, dx	     ; cmp daycnt for each month till fit
DOSBIOS:14C2					     ; dh=0
DOSBIOS:14C4		     jbe     short month_done
DOSBIOS:14C6		     inc     si		     ; next month
DOSBIOS:14C7		     sub     ax, dx	     ; adjust daycnt
DOSBIOS:14C9		     loop    months	     ;
DOSBIOS:14C9					     ; should never fall through loop
DOSBIOS:14CB
DOSBIOS:14CB month_done:			     ; CODE XREF: daycnt_to_day+96j
DOSBIOS:14CB		     mov     cs:month_tab+1, 28	; restore month	table value
DOSBIOS:14D1		     mov     dl, bl
DOSBIOS:14D3		     mov     dh, cs:base_year
DOSBIOS:14D8		     mov     cl, cs:base_century ; al=day,dl=month,dh=year,cl=cntry
DOSBIOS:14DD		     call    cs:bintobcd     ; convert "day" to	bcd
DOSBIOS:14DD					     ; dl = bcd	day, al	= month
DOSBIOS:14E2		     xchg    dl, al
DOSBIOS:14E4		     call    cs:bintobcd     ; call far	[cs:bintobcd]
DOSBIOS:14E4					     ; dh = bcd	month, al = year
DOSBIOS:14E9		     xchg    dh, al
DOSBIOS:14EB		     call    cs:bintobcd     ;
DOSBIOS:14EB					     ; cl = bcd	year, al = century
DOSBIOS:14F0		     xchg    cl, al
DOSBIOS:14F2
DOSBIOS:14F2 loc_1BF2:				     ; DATA XREF: DOSBIOS:3A90r
DOSBIOS:14F2		     call    cs:bintobcd     ; ch = bcd	century
DOSBIOS:14F7		     mov     ch, al
DOSBIOS:14F9		     pop     cs:daycnt	     ; restore original	value
DOSBIOS:14FE		     retf
DOSBIOS:14FE daycnt_to_day   endp
DOSBIOS:14FE
DOSBIOS:14FF
DOSBIOS:14FF ; =============== S U B R O U T I N E =======================================
DOSBIOS:14FF
DOSBIOS:14FF
DOSBIOS:14FF bin_to_bcd	     proc far		     ; CODE XREF: daycnt_to_day+AFP
DOSBIOS:14FF					     ; daycnt_to_day+B6P ...
DOSBIOS:14FF		     push    cx		     ; real time clock support
DOSBIOS:1500		     aam		     ; al=high digit bcd, ah=low digit bc
DOSBIOS:1502		     mov     cl, 4
DOSBIOS:1504		     shl     ah, cl	     ; mov the high digit to high nibble
DOSBIOS:1506		     or	     al, ah
DOSBIOS:1508		     pop     cx
DOSBIOS:1509		     retf
DOSBIOS:1509 bin_to_bcd	     endp
DOSBIOS:1509
DOSBIOS:150A ; ---------------------------------------------------------------------------
DOSBIOS:150A
DOSBIOS:150A int6c:				     ; DATA XREF: DOSBIOS:1CB5o
DOSBIOS:150A		     push    cs		     ; warning!!!
DOSBIOS:150A					     ; this code will be dynamically relocated by msinit.
DOSBIOS:150B		     pop     ds
DOSBIOS:150C		     assume ds:DOSBIOS
DOSBIOS:150C		     pop     word ptr int6c_ret_addr ; pop off return address
DOSBIOS:1510		     pop     word ptr int6c_ret_addr+2
DOSBIOS:1514		     popf
DOSBIOS:1515		     call    read_real_date  ; get the date from the clock
DOSBIOS:1518		     cli
DOSBIOS:1519		     mov     daycnt, si	     ; update dos copy of date
DOSBIOS:151D		     sti
DOSBIOS:151E		     call    read_real_time  ; get the time from the rtc
DOSBIOS:1521		     cli
DOSBIOS:1522		     mov     ah, 1
DOSBIOS:1524		     int     1Ah	     ; CLOCK - SET TIME	OF DAY
DOSBIOS:1524					     ; CX:DX = clock count
DOSBIOS:1524					     ; Return: time of day set
DOSBIOS:1526		     sti
DOSBIOS:1527		     jmp     int6c_ret_addr
DOSBIOS:152B
DOSBIOS:152B ; =============== S U B R O U T I N E =======================================
DOSBIOS:152B
DOSBIOS:152B
DOSBIOS:152B read_real_date  proc near		     ; CODE XREF: DOSBIOS:1515p
DOSBIOS:152B					     ; cmos_clock_read+2Fp
DOSBIOS:152B		     push    ax
DOSBIOS:152C		     push    cx
DOSBIOS:152D		     push    dx
DOSBIOS:152E		     xor     ah, ah	     ; throw away clock	roll over
DOSBIOS:1530		     int     1Ah	     ; CLOCK - GET TIME	OF DAY
DOSBIOS:1530					     ; Return: CX:DX = clock count
DOSBIOS:1530					     ; AL = 00h	if clock was read or written (via AH=0,1) since	the previous
DOSBIOS:1530					     ; midnight
DOSBIOS:1530					     ; Otherwise, AL > 0
DOSBIOS:1532		     pop     dx
DOSBIOS:1533		     pop     cx
DOSBIOS:1534		     pop     ax
DOSBIOS:1535		     push    ax
DOSBIOS:1536		     push    bx
DOSBIOS:1537		     push    cx
DOSBIOS:1538		     push    dx
DOSBIOS:1539		     mov     cs:daycnt2, 1   ; REAL TIME CLOCK ERROR FLAG (+1 DAY)
DOSBIOS:1540		     mov     ah, 4
DOSBIOS:1542		     int     1Ah	     ; CLOCK - READ DATE FROM REAL TIME	CLOCK (AT,XT286,CONV,PS)
DOSBIOS:1542					     ; Return: DL = day	in BCD
DOSBIOS:1542					     ; DH = month in BCD
DOSBIOS:1542					     ; CL = year in BCD
DOSBIOS:1542					     ; CH = century (19h or 20h)
DOSBIOS:1544		     jnb     short read_ok
DOSBIOS:1546		     jmp     r_d_ret
DOSBIOS:1549 ; ---------------------------------------------------------------------------
DOSBIOS:1549
DOSBIOS:1549 read_ok:				     ; CODE XREF: read_real_date+19j
DOSBIOS:1549		     mov     bin_date_time, ch
DOSBIOS:154D		     mov     bin_date_time+1, cl
DOSBIOS:1551		     mov     bin_date_time+2, dh
DOSBIOS:1555		     mov     bin_date_time+3, dl
DOSBIOS:1559		     mov     cs:daycnt2, 2   ; READ OF R-T CLOCK SUCCESSFUL
DOSBIOS:1560		     call    bcd_verify	     ; verify bcd values in range
DOSBIOS:1563		     jb	     short r_d_ret   ;	some value out of range
DOSBIOS:1565		     mov     cs:daycnt2, 3
DOSBIOS:156C		     call    date_verify
DOSBIOS:156F		     jb	     short r_d_ret
DOSBIOS:1571		     mov     cs:daycnt2, 0
DOSBIOS:1578		     call    in_bin
DOSBIOS:157B		     mov     al, bin_date_time+1
DOSBIOS:157E		     cbw
DOSBIOS:157F		     cmp     bin_date_time, 20 ; 20th century?
DOSBIOS:1584		     jnz     short century_19 ;	no
DOSBIOS:1586		     add     ax, 100	     ; add in a	century
DOSBIOS:1589
DOSBIOS:1589 century_19:			     ; CODE XREF: read_real_date+59j
DOSBIOS:1589		     sub     ax, 80	     ; subtract	off 1-1-80
DOSBIOS:158C		     mov     cl, 4	     ; leap year every 4
DOSBIOS:158E		     div     cl		     ; al= # leap year blocks, ah= remainder
DOSBIOS:1590		     mov     bl, ah	     ; save odd	years
DOSBIOS:1592		     cbw		     ; zero ah
DOSBIOS:1593		     mov     cx, 1461	     ; 366+(3*365)
DOSBIOS:1593					     ; # of days in leap year blocks
DOSBIOS:1596		     mul     cx
DOSBIOS:1598		     mov     cs:daycnt2, ax  ; SAVE COUNT OF DAYS
DOSBIOS:159C		     mov     al, bl	     ; get odd years count
DOSBIOS:159E		     cbw
DOSBIOS:159F		     or	     ax, ax
DOSBIOS:15A1		     jz	     short leap_year
DOSBIOS:15A3		     mov     cx, 365	     ; days in year
DOSBIOS:15A6		     mul     cx
DOSBIOS:15A8		     add     cs:daycnt2, ax  ; ADD ON DAYS IN ODD YEARS
DOSBIOS:15AD		     jmp     short leap_adjustment ; account for leap year
DOSBIOS:15AD					     ; possibly	account	for a leap day
DOSBIOS:15AF ; ---------------------------------------------------------------------------
DOSBIOS:15AF
DOSBIOS:15AF leap_year:				     ; CODE XREF: read_real_date+76j
DOSBIOS:15AF		     cmp     bin_date_time+2, 2	; is month february?
DOSBIOS:15B4		     jbe     short no_leap_adjustment ;	jan or feb. no leap day	yet.
DOSBIOS:15B6
DOSBIOS:15B6 leap_adjustment:			     ; CODE XREF: read_real_date+82j
DOSBIOS:15B6		     inc     cs:daycnt2	     ; account for leap	day
DOSBIOS:15BB
DOSBIOS:15BB no_leap_adjustment:		     ; CODE XREF: read_real_date+89j
DOSBIOS:15BB		     mov     cl, bin_date_time+3 ; get days of month
DOSBIOS:15BF		     xor     ch, ch
DOSBIOS:15C1		     dec     cx		     ; because of offset from day 1, not day 0
DOSBIOS:15C2		     add     cs:daycnt2, cx  ; GET DAYS	IN MONTHS PRECEEDING
DOSBIOS:15C7		     mov     cl, bin_date_time+2 ; get month
DOSBIOS:15CB		     xor     ch, ch
DOSBIOS:15CD		     dec     cx		     ; january starts at offset	0
DOSBIOS:15CE		     shl     cx, 1	     ; word offset
DOSBIOS:15D0		     mov     si, offset	month_table
DOSBIOS:15D3		     add     si, cx
DOSBIOS:15D5		     mov     ax, [si]	     ; mov ax, [cs:si]
DOSBIOS:15D5					     ; get # days in previous months
DOSBIOS:15D7		     add     cs:daycnt2, ax
DOSBIOS:15DC
DOSBIOS:15DC r_d_ret:				     ; CODE XREF: read_real_date+1Bj
DOSBIOS:15DC					     ; read_real_date+38j ...
DOSBIOS:15DC		     mov     si, cs:daycnt2
DOSBIOS:15E1		     pop     dx
DOSBIOS:15E2		     pop     cx
DOSBIOS:15E3		     pop     bx
DOSBIOS:15E4		     pop     ax
DOSBIOS:15E5		     retn
DOSBIOS:15E5 read_real_date  endp
DOSBIOS:15E5
DOSBIOS:15E6 ; ---------------------------------------------------------------------------
DOSBIOS:15E6 ; START OF	FUNCTION CHUNK FOR read_real_time
DOSBIOS:15E6
DOSBIOS:15E6 r_t_retj:				     ; CODE XREF: read_real_time+4j
DOSBIOS:15E6					     ; read_real_time+1Aj ...
DOSBIOS:15E6		     xor     cx, cx
DOSBIOS:15E8		     xor     dx, dx
DOSBIOS:15EA		     jmp     short r_t_ret
DOSBIOS:15EA ; END OF FUNCTION CHUNK FOR read_real_time
DOSBIOS:15EC
DOSBIOS:15EC ; =============== S U B R O U T I N E =======================================
DOSBIOS:15EC
DOSBIOS:15EC
DOSBIOS:15EC read_real_time  proc near		     ; CODE XREF: DOSBIOS:151Ep
DOSBIOS:15EC
DOSBIOS:15EC ; FUNCTION	CHUNK AT DOSBIOS:15E6 SIZE 00000006 BYTES
DOSBIOS:15EC
DOSBIOS:15EC		     mov     ah, 2
DOSBIOS:15EE		     int     1Ah	     ; CLOCK - READ REAL TIME CLOCK (AT,XT286,CONV,PS)
DOSBIOS:15EE					     ; Return: CH = hours in BCD
DOSBIOS:15EE					     ; CL = minutes in BCD
DOSBIOS:15EE					     ; DH = seconds in BCD
DOSBIOS:15F0		     jb	     short r_t_retj
DOSBIOS:15F2		     mov     bin_date_time, ch ; hours
DOSBIOS:15F6		     mov     bin_date_time+1, cl ; minutes
DOSBIOS:15FA		     mov     bin_date_time+2, dh ; seconds
DOSBIOS:15FE		     mov     bin_date_time+3, 0	; unused for time
DOSBIOS:1603		     call    bcd_verify
DOSBIOS:1606		     jb	     short r_t_retj
DOSBIOS:1608		     call    time_verify
DOSBIOS:160B		     jb	     short r_t_retj
DOSBIOS:160D		     call    in_bin	     ; from bcd	to bin
DOSBIOS:1610		     mov     ch, bin_date_time
DOSBIOS:1614		     mov     cl, bin_date_time+1
DOSBIOS:1618		     mov     dh, bin_date_time+2
DOSBIOS:161C		     mov     dl, bin_date_time+3
DOSBIOS:1620		     call    dword ptr ttticks ; call far [ttticks]
DOSBIOS:1620					     ; note: indirect far call
DOSBIOS:1620					     ;
DOSBIOS:1620					     ; cx:dx = number of ticks
DOSBIOS:1620					     ; (at 18.2	ticks per sec.)
DOSBIOS:1624
DOSBIOS:1624 r_t_ret:				     ; CODE XREF: read_real_time-2j
DOSBIOS:1624		     retn
DOSBIOS:1624 read_real_time  endp
DOSBIOS:1624
DOSBIOS:1625
DOSBIOS:1625 ; =============== S U B R O U T I N E =======================================
DOSBIOS:1625
DOSBIOS:1625
DOSBIOS:1625 in_bin	     proc near		     ; CODE XREF: read_real_date+4Dp
DOSBIOS:1625					     ; read_real_time+21p
DOSBIOS:1625		     mov     al, bin_date_time ; century or hours
DOSBIOS:1628		     call    bcd_to_bin
DOSBIOS:162B		     mov     bin_date_time, al
DOSBIOS:162E		     mov     al, bin_date_time+1 ; years or minutes
DOSBIOS:1631		     call    bcd_to_bin
DOSBIOS:1634		     mov     bin_date_time+1, al
DOSBIOS:1637		     mov     al, bin_date_time+2 ; months or seconds
DOSBIOS:163A		     call    bcd_to_bin
DOSBIOS:163D		     mov     bin_date_time+2, al
DOSBIOS:1640		     mov     al, bin_date_time+3 ; days	(not used for time)
DOSBIOS:1643		     call    bcd_to_bin
DOSBIOS:1646		     mov     bin_date_time+3, al
DOSBIOS:1649		     retn
DOSBIOS:1649 in_bin	     endp
DOSBIOS:1649
DOSBIOS:164A
DOSBIOS:164A ; =============== S U B R O U T I N E =======================================
DOSBIOS:164A
DOSBIOS:164A
DOSBIOS:164A bcd_to_bin	     proc near		     ; CODE XREF: in_bin+3p
DOSBIOS:164A					     ; in_bin+Cp ...
DOSBIOS:164A		     mov     ah, al
DOSBIOS:164C		     and     al, 0Fh
DOSBIOS:164E		     mov     cl, 4
DOSBIOS:1650		     shr     ah, cl
DOSBIOS:1652		     aad
DOSBIOS:1654		     retn
DOSBIOS:1654 bcd_to_bin	     endp
DOSBIOS:1654
DOSBIOS:1655
DOSBIOS:1655 ; =============== S U B R O U T I N E =======================================
DOSBIOS:1655
DOSBIOS:1655
DOSBIOS:1655 date_verify     proc near		     ; CODE XREF: read_real_date+41p
DOSBIOS:1655		     cmp     bin_date_time, 20h	; century check
DOSBIOS:165A		     ja	     short date_error
DOSBIOS:165C		     jz	     short century_20 ;	jmp in 21th century
DOSBIOS:165E		     cmp     bin_date_time, 19h	; century check
DOSBIOS:1663		     jb	     short date_error
DOSBIOS:1665		     cmp     bin_date_time+1, 80h ; year check
DOSBIOS:166A		     jb	     short date_error
DOSBIOS:166C
DOSBIOS:166C century_20:			     ; CODE XREF: date_verify+7j
DOSBIOS:166C		     cmp     bin_date_time+1, 99h ; year check
DOSBIOS:1671		     ja	     short date_error
DOSBIOS:1673		     cmp     bin_date_time+2, 12h ; month check
DOSBIOS:1678		     ja	     short date_error
DOSBIOS:167A		     cmp     bin_date_time+2, 0
DOSBIOS:167F		     jbe     short date_error
DOSBIOS:1681		     cmp     bin_date_time+3, 31h ; day	check
DOSBIOS:1686		     ja	     short date_error
DOSBIOS:1688		     cmp     bin_date_time+3, 0	; day check
DOSBIOS:168D		     jbe     short date_error
DOSBIOS:168F		     clc
DOSBIOS:1690		     retn
DOSBIOS:1691 ; ---------------------------------------------------------------------------
DOSBIOS:1691
DOSBIOS:1691 date_error:			     ; CODE XREF: date_verify+5j
DOSBIOS:1691					     ; date_verify+Ej ...
DOSBIOS:1691		     stc
DOSBIOS:1692		     retn
DOSBIOS:1692 date_verify     endp
DOSBIOS:1692
DOSBIOS:1693
DOSBIOS:1693 ; =============== S U B R O U T I N E =======================================
DOSBIOS:1693
DOSBIOS:1693
DOSBIOS:1693 time_verify     proc near		     ; CODE XREF: read_real_time+1Cp
DOSBIOS:1693		     cmp     bin_date_time, 24h	; hour check
DOSBIOS:1698		     ja	     short time_error
DOSBIOS:169A		     cmp     bin_date_time+1, 59h ; minute check
DOSBIOS:169F		     ja	     short time_error
DOSBIOS:16A1		     cmp     bin_date_time+2, 59h ; second check
DOSBIOS:16A6		     ja	     short time_error
DOSBIOS:16A8		     clc
DOSBIOS:16A9		     retn
DOSBIOS:16AA ; ---------------------------------------------------------------------------
DOSBIOS:16AA
DOSBIOS:16AA time_error:			     ; CODE XREF: time_verify+5j
DOSBIOS:16AA					     ; time_verify+Cj ...
DOSBIOS:16AA		     stc
DOSBIOS:16AB		     retn
DOSBIOS:16AB time_verify     endp
DOSBIOS:16AB
DOSBIOS:16AC
DOSBIOS:16AC ; =============== S U B R O U T I N E =======================================
DOSBIOS:16AC
DOSBIOS:16AC
DOSBIOS:16AC bcd_verify	     proc near		     ; CODE XREF: read_real_date+35p
DOSBIOS:16AC					     ; read_real_time+17p
DOSBIOS:16AC		     mov     cx, 4	     ; 4 bytes to check
DOSBIOS:16AF		     mov     bx, offset	bin_date_time
DOSBIOS:16B2
DOSBIOS:16B2 bv_loop:				     ; CODE XREF: bcd_verify+23j
DOSBIOS:16B2		     mov     al, [bx]	     ; get a bcd number	(0..99)
DOSBIOS:16B4		     mov     ah, al
DOSBIOS:16B6		     and     ax, 0F00Fh	     ; 10's place in high ah, 1's in al
DOSBIOS:16B6					     ; is 1's place in range?
DOSBIOS:16B9		     cmp     al, 10
DOSBIOS:16BB		     ja	     short bv_error  ; jmp out of range
DOSBIOS:16BD		     shr     ah, 1
DOSBIOS:16BF		     shr     ah, 1
DOSBIOS:16C1		     shr     ah, 1
DOSBIOS:16C3		     shr     ah, 1
DOSBIOS:16C5		     and     ah, 0Fh	     ; get rid of any erroneous	bits
DOSBIOS:16C8		     cmp     ah, 10	     ; is 10's place in range
DOSBIOS:16CB		     ja	     short bv_error  ; jmp out of range
DOSBIOS:16CD		     inc     bx		     ; next byte
DOSBIOS:16CE		     dec     cx
DOSBIOS:16CF		     jnz     short bv_loop
DOSBIOS:16D1		     clc		     ; set success flag
DOSBIOS:16D2		     retn
DOSBIOS:16D3 ; ---------------------------------------------------------------------------
DOSBIOS:16D3
DOSBIOS:16D3 bv_error:				     ; CODE XREF: bcd_verify+Fj
DOSBIOS:16D3					     ; bcd_verify+1Fj
DOSBIOS:16D3		     stc		     ; set error flag
DOSBIOS:16D4		     retn
DOSBIOS:16D4 bcd_verify	     endp
DOSBIOS:16D4
DOSBIOS:16D4 ; ---------------------------------------------------------------------------
DOSBIOS:16D5 endk09	     db	90h
DOSBIOS:16D6 drvfat	     dw	0		     ; DATA XREF: DOSBIOS:1984w
DOSBIOS:16D6					     ; DOSBIOS:1CD2r ...
DOSBIOS:16D6					     ; drive and fat id	of dos
DOSBIOS:16D8 bios_l	     dw	0		     ; DATA XREF: DOSBIOS:1806w
DOSBIOS:16D8					     ; DOSBIOS:2460r
DOSBIOS:16D8					     ; first sector of data (low word)
DOSBIOS:16DA bios_h	     dw	0		     ; DATA XREF: DOSBIOS:1802w
DOSBIOS:16DA					     ; DOSBIOS:2465r
DOSBIOS:16DA					     ; first sector of data (high word)
DOSBIOS:16DC doscnt	     dw	0		     ; DATA XREF: DOSBIOS:2455w
DOSBIOS:16DC					     ; DOSBIOS:24D4w ...
DOSBIOS:16DC					     ; how many	sectors	to read
DOSBIOS:16DE fbigfat	     db	0		     ; DATA XREF: DOSBIOS:1D3Dr
DOSBIOS:16DE					     ; sethard+12w ...
DOSBIOS:16DE					     ; flags for drive
DOSBIOS:16DF fatloc	     dw	0		     ; DATA XREF: DOSBIOS:19B3w
DOSBIOS:16DF					     ; DOSBIOS:246Dr
DOSBIOS:16DF					     ; seg addr	of fat sector
DOSBIOS:16E1 init_bootseg    dw	0		     ; DATA XREF: DOSBIOS:19BAw
DOSBIOS:16E1					     ; getbootr
DOSBIOS:16E1					     ; seg addr	of buffer for reading boot record
DOSBIOS:16E3 rom_drv_num     db	80h		     ; DATA XREF: sethard:set2w
DOSBIOS:16E3					     ; sethard+12Ar
DOSBIOS:16E3					     ; rom drive number
DOSBIOS:16E4 md_sectorsize   dw	200h		     ; DATA XREF: DOSBIOS:1D04w
DOSBIOS:16E4					     ; get_fat_sector+8r ...
DOSBIOS:16E4					     ; used by get_fat_sector proc.
DOSBIOS:16E6 temp_cluster    dw	0		     ; DATA XREF: DOSBIOS:248Fw
DOSBIOS:16E6					     ; DOSBIOS:24A2r ...
DOSBIOS:16E6					     ; used by get_fat_sector proc.
DOSBIOS:16E8 last_fat_sec_num dw 0FFFFh		     ; DATA XREF: get_fat_sector+29r
DOSBIOS:16E8					     ; get_fat_sector+30w
DOSBIOS:16E8					     ; used by get_fat_sector proc.
DOSBIOS:16EA num_heads	     db	2		     ; DATA XREF: DOSBIOS:1A8Cw
DOSBIOS:16EA					     ; DOSBIOS:1B32r
DOSBIOS:16EA					     ; number of heads returned	by rom
DOSBIOS:16EB sec_trk	     db	9		     ; DATA XREF: DOSBIOS:1A93w
DOSBIOS:16EB					     ; DOSBIOS:1AC4r ...
DOSBIOS:16EB					     ; sec/trk returned	by rom
DOSBIOS:16EC num_cyln	     db	40		     ; DATA XREF: DOSBIOS:1A6Dw
DOSBIOS:16EC					     ; DOSBIOS:1A97w ...
DOSBIOS:16EC					     ; number of cylinders returned by rom
DOSBIOS:16ED fakefloppydrv   db	0		     ; DATA XREF: DOSBIOS:_set_fake_flpdrvw
DOSBIOS:16ED					     ; DOSBIOS:1A4Cr ...
DOSBIOS:16ED					     ; if 1, then no diskette drives in	the system.
DOSBIOS:16EE disktable	     dw	512, 256, 64, 0	     ; warning !!! old values
DOSBIOS:16F6		     dw	2048, 513, 112,	0
DOSBIOS:16FE		     dw	8192, 1026, 256, 0
DOSBIOS:1706		     dw	32680, 2051, 512, 0  ; warning !!! old values
DOSBIOS:170E		     dw	65535, 4100, 1024, 0 ; default disktable under
DOSBIOS:170E					     ; the assumption of total fat size	<= 128 kb,
DOSBIOS:170E					     ; and the maximum size of fat entry = 16 bit.
DOSBIOS:1716 disktable2	     dw	0, 32680, 2051,	512, 0 ; DATA XREF: sethard+2B9o
DOSBIOS:1716					     ; for compatibility.
DOSBIOS:1720		     dw	4, 0, 402h, 200h, 40h ;	covers upto 134	mb media.
DOSBIOS:1720					     ; fbig = 40h
DOSBIOS:172A		     dw	8, 0, 803h, 200h, 40h ;	upto 268 mb
DOSBIOS:1734		     dw	10h, 0,	1004h, 200h, 40h ; upto	536 mb
DOSBIOS:173E		     dw	20h, 0,	2005h, 200h, 40h ; upto	1072 mb
DOSBIOS:1748		     dw	40h, 0,	4006h, 200h, 40h ; upto	2144 mb
DOSBIOS:1752		     dw	80h, 0,	8007h, 200h, 40h ; upto	4288 mb...
DOSBIOS:1752					     ;
DOSBIOS:1752					     ; variables for mini disk initialization
DOSBIOS:175C rom_minidisk_num db 0		     ; DATA XREF: domini+Cw
DOSBIOS:175C					     ; domini+26r ...
DOSBIOS:175C					     ; temp variable for phys unit
DOSBIOS:175D hnum	     db	0		     ; DATA XREF: DOSBIOS:1A3Cw
DOSBIOS:175D					     ; DOSBIOS:dohardr	...
DOSBIOS:175D					     ; real number of hardfiles
DOSBIOS:175E last_dskdrv_table dw offset dskdrvs     ; DATA XREF: DOSBIOS:1A30w
DOSBIOS:175E					     ; xinstall_bds+1Er ...
DOSBIOS:175E					     ; index into dskdrv table
DOSBIOS:1760 end_of_bdss     dw	offset bdss	     ; DATA XREF: DOSBIOS:1B7Dr
DOSBIOS:1760					     ; DOSBIOS:1BA8r ...
DOSBIOS:1760					     ; offset value of the ending address
DOSBIOS:1762 mini_hdlim	     dw	0		     ; DATA XREF: domini+1Aw
DOSBIOS:1762					     ; find_mini_partition+30r
DOSBIOS:1764 mini_seclim     dw	0		     ; DATA XREF: domini+22w
DOSBIOS:1764					     ; find_mini_partition+36r
DOSBIOS:1766 bios_date	     db	'01/10/84',0         ; DATA XREF: DOSBIOS:1C03o
DOSBIOS:1766					     ; used for	checking at rom	bios date.
DOSBIOS:176F		     db	 90h ; 	     ;
DOSBIOS:176F					     ; the following are the recommended bpbs
DOSBIOS:176F					     ; for the media that we know of so	far.
DOSBIOS:1770 bpb48t	     bpbx <512,	2, 1, 2, 112, 720, 0FDh, 2, 9, 2, 0, 0,	0, 0>
DOSBIOS:1770					     ; DATA XREF: DOSBIOS:bpbtableo
DOSBIOS:1770					     ;
DOSBIOS:1770					     ; physical	sector size in bytes
DOSBIOS:1770					     ; sectors/allocation unit
DOSBIOS:1770					     ; reserved	sectors	for dos
DOSBIOS:1770					     ; number of allocation tables
DOSBIOS:1770					     ; number of directory entries
DOSBIOS:1770					     ; number of sectors (at 512 bytes each)
DOSBIOS:1770					     ; media descriptor
DOSBIOS:1770					     ; number of fat sectors
DOSBIOS:1770					     ; sectors per track
DOSBIOS:1770					     ; heads
DOSBIOS:1770					     ; hidden sector count (low	word)
DOSBIOS:1770					     ; hidden sector (high)
DOSBIOS:1770					     ; number of sectors (low)
DOSBIOS:1770					     ; number of sectors (high)
DOSBIOS:1789		     db	90h
DOSBIOS:178A bpb96t	     bpbx <512,	1, 1, 2, 224, 2400, 0F9h, 7, 15, 2, 0, 0, 0, 0>
DOSBIOS:178A					     ; DATA XREF: DOSBIOS:17DAo
DOSBIOS:17A3		     db	90h
DOSBIOS:17A4 bpb35	     bpbx <512,	2, 1, 2, 112, 1440, 0F9h, 3, 9,	2, 0, 0, 0, 0>
DOSBIOS:17A4					     ; DATA XREF: DOSBIOS:17DCo
DOSBIOS:17A4					     ; DOSBIOS:17DEo ...
DOSBIOS:17BD		     db	90h
DOSBIOS:17BE bpb288	     bpbx <512,	2, 1, 2, 240, 5760, 0F0h, 9, 36, 2, 0, 0, 0, 0>
DOSBIOS:17BE					     ; DATA XREF: DOSBIOS:17EAo
DOSBIOS:17D7		     db	90h		     ;
DOSBIOS:17D7					     ; align 2
DOSBIOS:17D8 bpbtable	     dw	offset bpb48t	     ; DATA XREF: setdrvparms+A0o
DOSBIOS:17D8					     ; 48tpi drives
DOSBIOS:17DA		     dw	offset bpb96t	     ; 96tpi drives
DOSBIOS:17DC		     dw	offset bpb35	     ; 3.5" drives
DOSBIOS:17DE		     dw	offset bpb35	     ; unused 8" diskette
DOSBIOS:17E0		     dw	offset bpb35	     ; unused 8" diskette
DOSBIOS:17E2		     dw	offset bpb35	     ; used for	hard disk
DOSBIOS:17E4 off_1EE4	     dw	offset bpb35	     ; DATA XREF: DOSBIOS:3D1Aw
DOSBIOS:17E4					     ; used for	tape drive
DOSBIOS:17E6		     dw	offset bpb35	     ; FFOTHER
DOSBIOS:17E8		     dw	offset bpb35	     ; ERIMO
DOSBIOS:17EA		     dw	offset bpb288	     ; 2.88MB drive
DOSBIOS:17EC addr_of_bcretf  dw	0C8h		     ; DATA XREF: DOSBIOS:call_bios_coder
DOSBIOS:17EC					     ; dw bc_retf
DOSBIOS:17EC					     ; 2C7h:0C8h = 70h:2638h
DOSBIOS:17EE ; ---------------------------------------------------------------------------
DOSBIOS:17EE
DOSBIOS:17EE call_bios_code:			     ; CODE XREF: DOSBIOS:1CD9p
DOSBIOS:17EE					     ; DOSBIOS:1CE0p ...
DOSBIOS:17EE		     push    cs:addr_of_bcretf ; set up	near return to far return
DOSBIOS:17F3		     push    cs:cdev+2	     ; push Bios_Code segment
DOSBIOS:17F8		     push    bp		     ; save offset of utility function
DOSBIOS:17F9		     retf
DOSBIOS:17F9 ; ---------------------------------------------------------------------------
DOSBIOS:17FA flp_drvs	     db	0		     ; DATA XREF: DOSBIOS:186Ew
DOSBIOS:17FA					     ; DOSBIOS:187Br ...
DOSBIOS:17FB ; ---------------------------------------------------------------------------
DOSBIOS:17FB
DOSBIOS:17FB init:				     ; CODE XREF: DOSBIOS:BData_startj
DOSBIOS:17FB		     cli		     ; MSINIT.ASM
DOSBIOS:17FB					     ; --------------------------------------------------
DOSBIOS:17FB					     ; entry from boot sector. the register contents are:
DOSBIOS:17FB					     ;
DOSBIOS:17FB					     ;	dl = int 13 drive number we booted from
DOSBIOS:17FB					     ;	ch = media byte
DOSBIOS:17FB					     ;	bx = first data	sector on disk.
DOSBIOS:17FB					     ;	ax = first data	sector (high)
DOSBIOS:17FB					     ;	di = sectors/fat for the boot media.
DOSBIOS:17FC		     push    ax
DOSBIOS:17FD		     xor     ax, ax
DOSBIOS:17FF		     mov     ds, ax
DOSBIOS:1801		     assume ds:nothing
DOSBIOS:1801		     pop     ax
DOSBIOS:1802		     mov     cs:bios_h,	ax   ; (start of) dos bios (IO.SYS) data sector
DOSBIOS:1806		     mov     cs:bios_l,	bx
DOSBIOS:180B		     push    cs		     ; Save a peck of interrupt	vectors...
DOSBIOS:180C		     pop     es
DOSBIOS:180D		     assume es:DOSBIOS
DOSBIOS:180D		     push    cx
DOSBIOS:180E		     push    di
DOSBIOS:180F		     mov     cx, 5	     ; NUMROMVECTORS
DOSBIOS:180F					     ; no. of rom vectors to be	saved
DOSBIOS:1812		     mov     si, offset	RomVectors ; point to list of int vectors
DOSBIOS:1815
DOSBIOS:1815 next_int_:				     ; CODE XREF: DOSBIOS:1826j
DOSBIOS:1815		     lods    byte ptr cs:[si] ;	cs lodsb
DOSBIOS:1817		     cbw		     ; ax = interrupt number
DOSBIOS:1818		     shl     ax, 1
DOSBIOS:181A		     shl     ax, 1	     ; int no *	4
DOSBIOS:181C		     mov     di, ax	     ; interrupt vector	address
DOSBIOS:181E		     xchg    si, di	     ; rombios interrupt vector	address	in si
DOSBIOS:181E					     ; saving address in di
DOSBIOS:1820		     lodsw		     ; movsw
DOSBIOS:1821		     stosw
DOSBIOS:1822		     lodsw		     ; movsw
DOSBIOS:1823		     stosw		     ; save the	vector
DOSBIOS:1824		     xchg    si, di
DOSBIOS:1826		     loop    next_int_
DOSBIOS:1828		     pop     di
DOSBIOS:1829		     pop     cx
DOSBIOS:182A		     mov     ax, word ptr cs:Old13 ; save old13	in orig13 also
DOSBIOS:182E		     mov     word ptr cs:Orig13, ax
DOSBIOS:1832		     mov     ax, word ptr cs:Old13+2
DOSBIOS:1836		     mov     word ptr cs:Orig13+2, ax
DOSBIOS:183A		     mov     word ptr ds:4Ch, offset block13 ; 13h*4
DOSBIOS:183A					     ; set up int 13 for new action
DOSBIOS:1840		     mov     word ptr ds:4Eh, cs ; 13h*4+2
DOSBIOS:1844		     mov     word ptr ds:54h, offset Int15 ; 15h*4
DOSBIOS:1844					     ; set up int 15 for new action
DOSBIOS:184A		     mov     word ptr ds:56h, cs ; 15h*4+2
DOSBIOS:184E		     mov     word ptr ds:64h, offset int19 ; 19h*4
DOSBIOS:184E					     ; set up int 19 for new action
DOSBIOS:1854		     mov     word ptr ds:66h, cs ; 19h*4+2
DOSBIOS:1854					     ; ;
DOSBIOS:1858		     sti
DOSBIOS:1859		     int     11h	     ; EQUIPMENT DETERMINATION
DOSBIOS:1859					     ; Return: AX = equipment flag bits
DOSBIOS:185B		     test    ax, 1	     ; floppy drives present ?
DOSBIOS:185E		     jnz     short normalfloppydrv ; yes.
DOSBIOS:1860		     push    ax
DOSBIOS:1861		     push    bx
DOSBIOS:1862		     push    cx
DOSBIOS:1863		     push    dx
DOSBIOS:1864		     push    di
DOSBIOS:1865		     push    es
DOSBIOS:1866		     mov     ah, 8
DOSBIOS:1868		     mov     dl, 0
DOSBIOS:186A		     int     13h	     ; DISK - DISK - GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)
DOSBIOS:186A					     ; DL = drive number
DOSBIOS:186A					     ; Return: CF set on error,	AH = status code, BL = drive type
DOSBIOS:186A					     ; DL = number of consecutive drives
DOSBIOS:186A					     ; DH = maximum value for head number, ES:DI -> drive parameter
DOSBIOS:186C		     jb	     short _gdskp_error
DOSBIOS:186E		     mov     cs:flp_drvs, dl
DOSBIOS:1873
DOSBIOS:1873 _gdskp_error:			     ; CODE XREF: DOSBIOS:186Cj
DOSBIOS:1873		     pop     es
DOSBIOS:1874		     assume es:nothing
DOSBIOS:1874		     pop     di
DOSBIOS:1875		     pop     dx
DOSBIOS:1876		     pop     cx
DOSBIOS:1877		     pop     bx
DOSBIOS:1878		     pop     ax
DOSBIOS:1879		     jb	     short normalfloppydrv
DOSBIOS:187B		     cmp     cs:flp_drvs, 0  ; number of drvs == 0?
DOSBIOS:1881		     jz	     short _set_fake_flpdrv
DOSBIOS:1883		     mov     al, cs:flp_drvs
DOSBIOS:1887		     dec     al		     ; make it zero based
DOSBIOS:1889		     jmp     short got_num_flp_drvs
DOSBIOS:188B ; ---------------------------------------------------------------------------
DOSBIOS:188B
DOSBIOS:188B _set_fake_flpdrv:			     ; CODE XREF: DOSBIOS:1881j
DOSBIOS:188B		     mov     cs:fakefloppydrv, 1 ; we don't have any floppy drives.
DOSBIOS:1891		     mov     ax, 1
DOSBIOS:1894		     jmp     short settwodrive ; well then set it for two drives!
DOSBIOS:1896 ; ---------------------------------------------------------------------------
DOSBIOS:1896
DOSBIOS:1896 normalfloppydrv:			     ; CODE XREF: DOSBIOS:185Ej
DOSBIOS:1896					     ; DOSBIOS:1879j
DOSBIOS:1896		     rol     al, 1	     ; there exist floppy drives.
DOSBIOS:1896					     ; put bits	6 & 7 into bits	0 & 1
DOSBIOS:1898		     rol     al, 1
DOSBIOS:189A
DOSBIOS:189A got_num_flp_drvs:			     ; CODE XREF: DOSBIOS:1889j
DOSBIOS:189A		     and     ax, 3	     ; only look at bits 0 & 1
DOSBIOS:189D		     jnz     short notsingle ; zero means single drive system
DOSBIOS:189F		     inc     ax		     ; pretend it's a two drive system
DOSBIOS:18A0
DOSBIOS:18A0 settwodrive:			     ; CODE XREF: DOSBIOS:1894j
DOSBIOS:18A0		     inc     cs:single	     ; set this	to two fakedrives
DOSBIOS:18A0					     ; remember	this
DOSBIOS:18A5
DOSBIOS:18A5 notsingle:				     ; CODE XREF: DOSBIOS:189Dj
DOSBIOS:18A5		     inc     ax		     ; ax has number of	drives,	2-4
DOSBIOS:18A5					     ; is also 0 indexed boot drive if we
DOSBIOS:18A5					     ; booted off hard file
DOSBIOS:18A6		     mov     cl, al	     ; ch is fat id, cl	# floppies
DOSBIOS:18A8		     test    dl, 80h	     ; boot from floppy	?
DOSBIOS:18AB		     jnz     short gothrd    ; no.
DOSBIOS:18AD		     xor     ax, ax	     ; indicate	boot from drive	a
DOSBIOS:18AF
DOSBIOS:18AF gothrd:				     ; CODE XREF: DOSBIOS:18ABj
DOSBIOS:18AF		     xor     dx, dx	     ; ax = 0-based drive we booted from
DOSBIOS:18AF					     ; bios_l, bios_h set.
DOSBIOS:18AF					     ; cl = number of floppies including fake one
DOSBIOS:18AF					     ; ch = media byte
DOSBIOS:18B1		     cli
DOSBIOS:18B2		     mov     ss, dx	     ;	set stack segment and stack pointer
DOSBIOS:18B4		     assume ss:nothing
DOSBIOS:18B4		     mov     sp, 700h
DOSBIOS:18B7		     sti
DOSBIOS:18B8		     push    cx		     ; save number of floppies and media byte
DOSBIOS:18B9		     mov     ah, ch	     ; FAT ID to AH
DOSBIOS:18BB		     push    ax		     ; save boot drive number and media	byte
DOSBIOS:18BC		     mov     ah, 0C0h
DOSBIOS:18BE		     int     15h	     ; SYSTEM -	GET CONFIGURATION (XT after 1/10/86,AT mdl 3x9,CONV,XT286,PS)
DOSBIOS:18C0		     jb	     short no_rom_system_conf ;	just use Model_Byte
DOSBIOS:18C2		     cmp     ah, 0
DOSBIOS:18C5		     jnz     short no_rom_system_conf
DOSBIOS:18C7		     mov     al, es:[bx+2]   ; [es:bx+ROMBIOS_DESC.bios_sd_modelbyte]
DOSBIOS:18CB		     mov     cs:model_byte, al ; get/save model	byte
DOSBIOS:18CF		     mov     al, es:[bx+3]   ; [es:bx+ROMBIOS_DESC.bios_sd_scnd_modelbyte]
DOSBIOS:18D3		     mov     cs:secondary_model_byte, al ; get/save secondary model byte
DOSBIOS:18D7		     jmp     short turn_timer_on
DOSBIOS:18D9 ; ---------------------------------------------------------------------------
DOSBIOS:18D9
DOSBIOS:18D9 no_rom_system_conf:		     ; CODE XREF: DOSBIOS:18C0j
DOSBIOS:18D9					     ; DOSBIOS:18C5j
DOSBIOS:18D9		     mov     si, 0FFFFh
DOSBIOS:18DC		     mov     es, si
DOSBIOS:18DE		     assume es:nothing
DOSBIOS:18DE		     mov     al, es:0Eh	     ; get model byte (from 0FFFFh:0Eh)
DOSBIOS:18E2		     mov     cs:model_byte, al ; save model byte
DOSBIOS:18E6
DOSBIOS:18E6 turn_timer_on:			     ; CODE XREF: DOSBIOS:18D7j
DOSBIOS:18E6		     mov     al, 20h ; ' '   ; turn on the timer
DOSBIOS:18E8		     out     20h, al	     ; Interrupt controller, 8259A.
DOSBIOS:18E8					     ; AKPORT
DOSBIOS:18EA		     cmp     cs:model_byte, 0 ;	next to	last byte in rom bios
DOSBIOS:18F0		     jnz     short not_olivetti_m24 ; skip for all other machines
DOSBIOS:18F0					     ; (except olivetti	m24)
DOSBIOS:18F2		     in	     al, 66h	     ; is 8530 installed?
DOSBIOS:18F4		     test    al, 20h
DOSBIOS:18F6		     jz	     short not_olivetti_m24 ; we're done if not
DOSBIOS:18F8		     mov     al, 0Fh	     ; double check
DOSBIOS:18FA		     out     50h, al
DOSBIOS:18FC		     in	     al, 50h
DOSBIOS:18FE		     test    al, 1	     ; this test was copied from olivetti
DOSBIOS:1900		     jz	     short skip_aux_port_init ;	take this branch if 8530 installed
DOSBIOS:1902
DOSBIOS:1902 not_olivetti_m24:			     ; CODE XREF: DOSBIOS:18F0j
DOSBIOS:1902					     ; DOSBIOS:18F6j
DOSBIOS:1902		     mov     al, 3	     ; init com4
DOSBIOS:1904		     call    aux_init
DOSBIOS:1907		     mov     al, 2	     ; init com3
DOSBIOS:1909		     call    aux_init
DOSBIOS:190C		     mov     al, 1	     ; init com2
DOSBIOS:190E		     call    aux_init
DOSBIOS:1911		     xor     al, al	     ; init com1
DOSBIOS:1913		     call    aux_init
DOSBIOS:1916
DOSBIOS:1916 skip_aux_port_init:		     ; CODE XREF: DOSBIOS:1900j
DOSBIOS:1916		     mov     al, 2	     ; init lpt3
DOSBIOS:1918		     call    print_init
DOSBIOS:191B		     mov     al, 1	     ; init lpt2
DOSBIOS:191D		     call    print_init
DOSBIOS:1920		     xor     al, al	     ; init lpt1
DOSBIOS:1922		     call    print_init
DOSBIOS:1925		     xor     dx, dx
DOSBIOS:1927		     mov     ds, dx	     ; to initialize print screen vector
DOSBIOS:1929		     mov     es, dx
DOSBIOS:192B		     assume es:nothing
DOSBIOS:192B		     xor     ax, ax
DOSBIOS:192D		     mov     di, 534h	     ; INITSPOT	(0000h:0534h)
DOSBIOS:192D					     ; IBM wants 4 zeros here
DOSBIOS:1930		     stosw
DOSBIOS:1931		     stosw
DOSBIOS:1932		     mov     ax, cs	     ; fetch segment
DOSBIOS:1934		     mov     word ptr ds:6Ch, offset cbreak ; [BRKADR]
DOSBIOS:1934					     ; break entry point
DOSBIOS:193A		     mov     ds:6Eh, ax	     ; vector for break
DOSBIOS:193D		     mov     word ptr ds:0A4h, offset outchr ; [CHROUT*4]
DOSBIOS:1943		     mov     ds:0A6h, ax     ; [CHROUT*4+2]
DOSBIOS:1946		     mov     di, 4
DOSBIOS:1949		     mov     bx, offset	intret ; intret	(cs:intret)
DOSBIOS:1949					     ; will initialize rest of interrupts
DOSBIOS:194C		     xchg    ax, bx
DOSBIOS:194D		     stosw		     ; location	4
DOSBIOS:194E		     xchg    ax, bx	     ; cs:
DOSBIOS:194F		     stosw		     ; int 1 ; location	6
DOSBIOS:1950		     add     di, 4
DOSBIOS:1953		     xchg    ax, bx
DOSBIOS:1954		     stosw		     ; location	12
DOSBIOS:1955		     xchg    ax, bx	     ; cs:
DOSBIOS:1956		     stosw		     ; int 3 ; location	14
DOSBIOS:1957		     xchg    ax, bx
DOSBIOS:1958		     stosw		     ; location	16
DOSBIOS:1959		     xchg    ax, bx	     ; cs:
DOSBIOS:195A		     stosw		     ; int 4 ; location	18
DOSBIOS:195B		     mov     ds:500h, dx     ; set print screen	& break	= 0
DOSBIOS:195F		     mov     ds:504h, dx     ; [LSTDRV]
DOSBIOS:195F					     ; clean out last drive spec
DOSBIOS:1963		     mov     al, ds:52Ch     ; [SEC9+DISK_PARMS.DISK_MOTOR_STRT]
DOSBIOS:1963					     ; [522h+0Ch]
DOSBIOS:1966		     mov     cs:motorstartup, al
DOSBIOS:196A		     cmp     cs:model_byte, 0FDh ; is this an old rom?
DOSBIOS:1970		     jb	     short no_diddle ; no
DOSBIOS:1972		     mov     word ptr ds:52Bh, 20Fh ; [SEC9+DISK_PARMS.DISK_HEAD_STTL],	0200h+NORMSETTLE
DOSBIOS:1972					     ; set head	settle and motor start on pc-1 pc-2 pc-xt hal0
DOSBIOS:1978		     mov     byte ptr ds:522h, 0DFh ; [SEC9+DISK_PARMS.DISK_SPECIFY_1]
DOSBIOS:1978					     ;	set 1st	specify	byte on	pc-1 pc-2 pc-xt	hal0
DOSBIOS:197D
DOSBIOS:197D no_diddle:				     ; CODE XREF: DOSBIOS:1970j
DOSBIOS:197D		     int     12h	     ; MEMORY SIZE -
DOSBIOS:197D					     ; Return: AX = number of contiguous 1K blocks of memory
DOSBIOS:197F		     mov     cl, 6
DOSBIOS:1981		     shl     ax, cl	     ; convert memory size to 16-byte blocks (segment no.)
DOSBIOS:1983		     pop     cx
DOSBIOS:1984		     mov     cs:drvfat,	cx
DOSBIOS:1989		     push    ax		     ; save real top of	memory
DOSBIOS:198A		     push    ds
DOSBIOS:198B		     push    bx
DOSBIOS:198C		     xor     bx, bx
DOSBIOS:198E
DOSBIOS:198E loc_208E:				     ; DATA XREF: read_volume_id+23w
DOSBIOS:198E					     ; read_volume_id+32r ...
DOSBIOS:198E		     mov     ds, bx	     ; Check if	an RPL program is present at TOM
DOSBIOS:198E					     ; and do not tromp	over it
DOSBIOS:1990		     mov     bx, ds:0BCh     ; [2Fh*4]
DOSBIOS:1994		     mov     ds, word ptr ds:0BEh ; [2Fh*4+2]
DOSBIOS:1998		     assume ds:nothing
DOSBIOS:1998		     cmp     word ptr [bx+3], 'PR' ; 'RPL'
DOSBIOS:199D		     jnz     short SkipRPL
DOSBIOS:199F		     cmp     byte ptr [bx+5], 'L'
DOSBIOS:19A3		     jnz     short SkipRPL
DOSBIOS:19A5		     mov     dx, ax	     ; get TOM into DX
DOSBIOS:19A7		     mov     ax, 4A06h	     ; (multMULT shl 8)	+ multMULTRPLTOM
DOSBIOS:19AA		     int     2Fh	     ; Get new TOM from	any RPL
DOSBIOS:19AC		     mov     ax, dx
DOSBIOS:19AE
DOSBIOS:19AE SkipRPL:				     ; CODE XREF: DOSBIOS:199Dj
DOSBIOS:19AE					     ; DOSBIOS:19A3j
DOSBIOS:19AE		     pop     bx
DOSBIOS:19AF		     pop     ds
DOSBIOS:19B0		     sub     ax, 64
DOSBIOS:19B3		     mov     cs:fatloc,	ax
DOSBIOS:19B7		     sub     ax, 64
DOSBIOS:19BA		     mov     cs:init_bootseg, ax
DOSBIOS:19BE		     pop     ax
DOSBIOS:19BF		     mov     dx, 46Dh	     ; SYSINIT segment
DOSBIOS:19C2		     mov     ds, dx
DOSBIOS:19C4		     assume ds:nothing
DOSBIOS:19C4		     mov     word ptr ds:273h, offset res_dev_list ;
DOSBIOS:19C4					     ; [SYSINIT+DEVICE_LIST]
DOSBIOS:19CA		     mov     word ptr ds:275h, cs ; [SYSINIT+DEVICE_LIST+2]
DOSBIOS:19CE		     mov     ds:292h, ax     ; [SYSINIT+MEMORY_SIZE]
DOSBIOS:19D1		     inc     cl
DOSBIOS:19D3		     mov     ds:296h, cl     ; [SYSINIT+DEFAULT_DRIVE]
DOSBIOS:19D7		     mov     word ptr ds:271h, 83Fh ; [SYSINIT+CURRENT_DOS_LOCATION]
DOSBIOS:19D7					     ; dos_load_seg
DOSBIOS:19DD		     mov     ax, 46Dh	     ; SYSINIT segment
DOSBIOS:19E0		     mov     es, ax
DOSBIOS:19E2		     assume es:nothing
DOSBIOS:19E2		     xor     ax, ax	     ; Some old	ibm hardware generates spurious	int 0F's
DOSBIOS:19E2					     ; due to bogus printer cards.
DOSBIOS:19E2					     ; we initialize this value	to point to an iret
DOSBIOS:19E2					     ; only if
DOSBIOS:19E2					     ;
DOSBIOS:19E2					     ; 1) the original segment points to storage
DOSBIOS:19E2					     ;	  inside valid ram.
DOSBIOS:19E2					     ;
DOSBIOS:19E2					     ; 2) the original segment is 0F000:xxxx
DOSBIOS:19E4		     mov     ds, ax
DOSBIOS:19E6		     assume ds:nothing
DOSBIOS:19E6		     mov     ax, ds:3Eh	     ; [0Fh*4+2]
DOSBIOS:19E9		     cmp     ax, es:292h     ; [ES:SYSINIT+MEMORY_SIZE]	 ; (condition 1)
DOSBIOS:19EE		     jbe     short resetintf
DOSBIOS:19F0		     cmp     ax, 0F000h	     ; (condition 2)
DOSBIOS:19F3		     jnz     short keepintf
DOSBIOS:19F5
DOSBIOS:19F5 resetintf:				     ; CODE XREF: DOSBIOS:19EEj
DOSBIOS:19F5		     mov     word ptr ds:3Ch, offset intret ; [0Fh*4]
DOSBIOS:19FB		     mov     word ptr ds:3Eh, cs ; [0Fh*4+2]
DOSBIOS:19FF
DOSBIOS:19FF keepintf:				     ; CODE XREF: DOSBIOS:19F3j
DOSBIOS:19FF		     xor     cx, cx
DOSBIOS:1A01		     mov     ds, cx
DOSBIOS:1A03		     mov     cl, ds:496h     ; get keyboard flag
DOSBIOS:1A07		     test    cl, 10h	     ; extended	keyboard ?
DOSBIOS:1A0A		     jz	     short org_key   ; no
DOSBIOS:1A0C		     mov     cs:keyrd_func, 10h	; extended keyboard
DOSBIOS:1A12		     mov     cs:keysts_func, 11h ; change for extended keyboard	functions
DOSBIOS:1A18
DOSBIOS:1A18 org_key:				     ; CODE XREF: DOSBIOS:1A0Aj
DOSBIOS:1A18		     push    cs		     ; original	keyboard
DOSBIOS:1A19		     pop     ds
DOSBIOS:1A1A		     assume ds:DOSBIOS
DOSBIOS:1A1A		     push    cs
DOSBIOS:1A1B		     pop     es
DOSBIOS:1A1C		     assume es:DOSBIOS
DOSBIOS:1A1C		     call    cmos_clock_read ; If cmos clock exists,
DOSBIOS:1A1C					     ; then set	the system time	according to that.
DOSBIOS:1A1C					     ; also, reset the cmos clock rate.
DOSBIOS:1A1F		     mov     word ptr BData_start, offset harddrv ;
DOSBIOS:1A1F					     ; set up pointer to hdrive
DOSBIOS:1A25		     pop     ax		     ; number of floppies and FAT ID
DOSBIOS:1A26		     xor     ah, ah	     ; chuck fat id byte
DOSBIOS:1A28		     mov     drvmax, al	     ; remember	which drive is hard disk
DOSBIOS:1A2B		     mov     dsktnum, al     ; and set initial number of drives
DOSBIOS:1A2E		     shl     ax, 1
DOSBIOS:1A30		     add     last_dskdrv_table,	ax
DOSBIOS:1A34		     mov     dl, 80h
DOSBIOS:1A36		     mov     ah, 8
DOSBIOS:1A38		     int     13h	     ; DISK - DISK - GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)
DOSBIOS:1A38					     ; DL = drive number
DOSBIOS:1A38					     ; Return: CF set on error,	AH = status code, BL = drive type
DOSBIOS:1A38					     ; DL = number of consecutive drives
DOSBIOS:1A38					     ; DH = maximum value for head number, ES:DI -> drive parameter
DOSBIOS:1A3A		     jb	     short enddrv
DOSBIOS:1A3C		     mov     hnum, dl
DOSBIOS:1A40
DOSBIOS:1A40 enddrv:				     ; CODE XREF: DOSBIOS:1A3Aj
DOSBIOS:1A40		     xor     dl, dl
DOSBIOS:1A42		     push    cs
DOSBIOS:1A43		     pop     ds
DOSBIOS:1A44		     mov     eot, 9
DOSBIOS:1A49		     mov     di, offset	start_bds ;
DOSBIOS:1A49					     ; if we are faking	floppy drives we need
DOSBIOS:1A49					     ; to set aside two	bdss for the two fake floppy drives
DOSBIOS:1A4C		     cmp     fakefloppydrv, 1
DOSBIOS:1A51		     jnz     short loop_drive
DOSBIOS:1A53		     mov     di, [di]	     ; [di+BDS.link]
DOSBIOS:1A53					     ; di <- first bds link
DOSBIOS:1A55		     mov     di, [di]	     ; [di+BDS.link]
DOSBIOS:1A55					     ; di <- second bds	link
DOSBIOS:1A57		     mov     word ptr [di], 0FFFFh ; set end of	link
DOSBIOS:1A5B		     jmp     dohard	     ; allocate/initialise bds for harddrives
DOSBIOS:1A5E ; ---------------------------------------------------------------------------
DOSBIOS:1A5E
DOSBIOS:1A5E loop_drive:			     ; CODE XREF: DOSBIOS:1A51j
DOSBIOS:1A5E					     ; DOSBIOS:1B6Bj
DOSBIOS:1A5E		     cmp     dl, drvmax
DOSBIOS:1A62		     jb	     short got_more
DOSBIOS:1A64		     jmp     done_drives
DOSBIOS:1A67 ; ---------------------------------------------------------------------------
DOSBIOS:1A67
DOSBIOS:1A67 got_more:				     ; CODE XREF: DOSBIOS:1A62j
DOSBIOS:1A67		     xor     cx, cx	     ; zero all	flags
DOSBIOS:1A69		     mov     di, [di]	     ; [di+BDS.link]
DOSBIOS:1A69					     ; get next	bds
DOSBIOS:1A6B		     mov     dh, 0	     ; ff48tpi
DOSBIOS:1A6B					     ; set form	factor to 48 tpi
DOSBIOS:1A6D		     mov     num_cyln, 40    ; 40 tracks per side
DOSBIOS:1A72		     push    ds
DOSBIOS:1A73		     push    di
DOSBIOS:1A74		     push    dx
DOSBIOS:1A75		     push    cx
DOSBIOS:1A76		     push    es
DOSBIOS:1A77		     mov     ah, 8
DOSBIOS:1A79		     int     13h	     ; DISK - DISK - GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)
DOSBIOS:1A79					     ; DL = drive number
DOSBIOS:1A79					     ; Return: CF set on error,	AH = status code, BL = drive type
DOSBIOS:1A79					     ; DL = number of consecutive drives
DOSBIOS:1A79					     ; DH = maximum value for head number, ES:DI -> drive parameter
DOSBIOS:1A7B		     jb	     short noparmsfromrom
DOSBIOS:1A7D		     cmp     ch, 0	     ; if ch=0,	then cl,dh=0 too.
DOSBIOS:1A80		     jnz     short pfr_ok
DOSBIOS:1A82		     mov     ch, 39	     ; rom gave	wrong info.
DOSBIOS:1A84		     mov     cl, 9	     ; let's default to 360k.
DOSBIOS:1A86		     mov     dh, 1
DOSBIOS:1A88
DOSBIOS:1A88 pfr_ok:				     ; CODE XREF: DOSBIOS:1A80j
DOSBIOS:1A88		     inc     dh		     ; make number of heads 1-based
DOSBIOS:1A8A		     inc     ch		     ; make number of cylinders	1-based
DOSBIOS:1A8C		     mov     num_heads,	dh   ; save parms returned by rom
DOSBIOS:1A90		     and     cl, 3Fh
DOSBIOS:1A93		     mov     sec_trk, cl
DOSBIOS:1A97		     mov     num_cyln, ch    ; assume less than	256 cylinders!!
DOSBIOS:1A9B		     cmp     cl, eot	     ; may set carry
DOSBIOS:1A9F		     jbe     short eot_ok
DOSBIOS:1AA1		     mov     eot, cl
DOSBIOS:1AA5
DOSBIOS:1AA5 eot_ok:				     ; CODE XREF: DOSBIOS:1A9Fj
DOSBIOS:1AA5		     pop     es
DOSBIOS:1AA6		     assume es:nothing
DOSBIOS:1AA6		     pop     cx
DOSBIOS:1AA7		     pop     dx
DOSBIOS:1AA8		     pop     di
DOSBIOS:1AA9		     pop     ds		     ;
DOSBIOS:1AA9					     ; Check for presence of changeline
DOSBIOS:1AAA		     assume ds:nothing
DOSBIOS:1AAA		     mov     ah, 15h
DOSBIOS:1AAC		     int     13h	     ; DISK - DISK - GET TYPE (AT,XT2,XT286,CONV,PS)
DOSBIOS:1AAC					     ; DL = drive ID
DOSBIOS:1AAC					     ; Return: CF set on error,	AH = disk type (3 = hard drive)
DOSBIOS:1AAC					     ; CX:DX = number of sectors on the	media
DOSBIOS:1AAE		     jb	     short changeline_done
DOSBIOS:1AB0		     cmp     ah, 2	     ; check for presence of changeline
DOSBIOS:1AB3		     jnz     short changeline_done
DOSBIOS:1AB5		     or	     cl, 2	     ; fchangeline
DOSBIOS:1AB5					     ; signal type
DOSBIOS:1AB8		     mov     ds:fhave96, 1   ; remember	that we	have 96tpi disks
DOSBIOS:1ABD
DOSBIOS:1ABD changeline_done:			     ; CODE XREF: DOSBIOS:1AAEj
DOSBIOS:1ABD					     ; DOSBIOS:1AB3j
DOSBIOS:1ABD		     cmp     ds:num_cyln, 40
DOSBIOS:1AC2		     jnz     short try_80
DOSBIOS:1AC4		     cmp     ds:sec_trk, 9
DOSBIOS:1AC9		     jbe     short nextdrive
DOSBIOS:1ACB
DOSBIOS:1ACB gotother:				     ; CODE XREF: DOSBIOS:1AD4j
DOSBIOS:1ACB					     ; DOSBIOS:1AEBj
DOSBIOS:1ACB		     mov     dh, 7	     ; ffOther
DOSBIOS:1ACB					     ; we have a "strange" medium
DOSBIOS:1ACD		     jmp     short nextdrive
DOSBIOS:1ACF ; ---------------------------------------------------------------------------
DOSBIOS:1ACF
DOSBIOS:1ACF try_80:				     ; CODE XREF: DOSBIOS:1AC2j
DOSBIOS:1ACF		     cmp     ds:num_cyln, 80
DOSBIOS:1AD4		     jnz     short gotother
DOSBIOS:1AD6		     mov     dh, 9	     ; ff288
DOSBIOS:1AD6					     ; assume 2.88 MB drive
DOSBIOS:1AD8		     cmp     ds:sec_trk, 36  ; is it ?
DOSBIOS:1ADD		     jz	     short nextdrive ; yeah, go	update
DOSBIOS:1ADF		     cmp     ds:sec_trk, 15
DOSBIOS:1AE4		     jz	     short got96
DOSBIOS:1AE6		     cmp     ds:sec_trk, 9
DOSBIOS:1AEB		     jnz     short gotother
DOSBIOS:1AED		     mov     dh, 2	     ; ffSmall
DOSBIOS:1AEF		     jmp     short nextdrive
DOSBIOS:1AF1 ; ---------------------------------------------------------------------------
DOSBIOS:1AF1
DOSBIOS:1AF1 got96:				     ; CODE XREF: DOSBIOS:1AE4j
DOSBIOS:1AF1		     mov     dh, 1	     ; ff96tpi
DOSBIOS:1AF3		     jmp     short nextdrive
DOSBIOS:1AF5 ; ---------------------------------------------------------------------------
DOSBIOS:1AF5
DOSBIOS:1AF5 noparmsfromrom:			     ; CODE XREF: DOSBIOS:1A7Bj
DOSBIOS:1AF5		     pop     es		     ; we have an old rom, so we either	have a 48tpi or	96tpi drive
DOSBIOS:1AF5					     ; if the drive has	changeline, we assume it is a 96tpi
DOSBIOS:1AF6		     pop     cx
DOSBIOS:1AF7		     pop     dx
DOSBIOS:1AF8		     pop     di
DOSBIOS:1AF9		     pop     ds
DOSBIOS:1AFA		     mov     ah, 15h
DOSBIOS:1AFC		     int     13h	     ; DISK - DISK - GET TYPE (AT,XT2,XT286,CONV,PS)
DOSBIOS:1AFC					     ; DL = drive ID
DOSBIOS:1AFC					     ; Return: CF set on error,	AH = disk type (3 = hard drive)
DOSBIOS:1AFC					     ; CX:DX = number of sectors on the	media
DOSBIOS:1AFE		     jb	     short nextdrive
DOSBIOS:1B00		     cmp     ah, 2	     ; is there	changeline?
DOSBIOS:1B03		     jnz     short nextdrive
DOSBIOS:1B05		     or	     cl, 2
DOSBIOS:1B08		     mov     ds:fhave96, 1   ; fchangeline
DOSBIOS:1B0D		     mov     ds:num_cyln, 80
DOSBIOS:1B12		     mov     dh, 1
DOSBIOS:1B14		     mov     al, 15
DOSBIOS:1B16		     cmp     al, ds:eot
DOSBIOS:1B1A		     jbe     short nextdrive
DOSBIOS:1B1C		     mov     ds:eot, al
DOSBIOS:1B1F
DOSBIOS:1B1F nextdrive:				     ; CODE XREF: DOSBIOS:1AC9j
DOSBIOS:1B1F					     ; DOSBIOS:1ACDj ...
DOSBIOS:1B1F		     or	     cl, 20h	     ; fi_own_physical
DOSBIOS:1B1F					     ; set this	true for all drives
DOSBIOS:1B22		     mov     bh, dl	     ;
DOSBIOS:1B22					     ; we need to do special things if
DOSBIOS:1B22					     ; we have a single	drive system
DOSBIOS:1B22					     ; and are setting up a logical drive
DOSBIOS:1B24		     cmp     ds:single,	2
DOSBIOS:1B29		     jnz     short not_special
DOSBIOS:1B2B		     dec     bh		     ; int13 drive number same for logical drive
DOSBIOS:1B2D		     xor     cl, 20h	     ; reset ownership flag for	logical	drive
DOSBIOS:1B30
DOSBIOS:1B30 not_special:			     ; CODE XREF: DOSBIOS:1B29j
DOSBIOS:1B30		     xor     ax, ax	     ; fill BDS	for drive
DOSBIOS:1B32		     mov     al, ds:num_heads
DOSBIOS:1B35		     mov     [di+36h], ax    ; [di+BDS.rheads]
DOSBIOS:1B38		     mov     al, ds:sec_trk
DOSBIOS:1B3B		     mov     [di+34h], ax    ; [di+BDS.rsecpertrack]
DOSBIOS:1B3E		     mov     [di+23h], cx    ; [di+BDS.flags]
DOSBIOS:1B41		     mov     [di+22h], dh    ; [di+BDS.formfactor]
DOSBIOS:1B44		     mov     [di+5], dl	     ; [di+BDS.drivelet]
DOSBIOS:1B47		     mov     [di+4], bh	     ; [di+BDS.drivenum]
DOSBIOS:1B4A		     mov     bl, ds:num_cyln
DOSBIOS:1B4E		     mov     [di+25h], bl    ; [di+BDS.cylinders]
DOSBIOS:1B51		     cmp     ds:single,	1    ; Special case for	single drive system
DOSBIOS:1B56		     jnz     short no_single
DOSBIOS:1B58		     mov     ds:single,	2    ; Don't forget we have
DOSBIOS:1B58					     ; single drive system
DOSBIOS:1B5D		     or	     cx, 10h	     ; fi_am_mult
DOSBIOS:1B5D					     ; set that	this is	one of several drives
DOSBIOS:1B60		     or	     [di+23h], cx    ; [di+BDS.flags]
DOSBIOS:1B60					     ; save flags
DOSBIOS:1B63		     mov     di, [di]	     ; [di+BDS.link]
DOSBIOS:1B63					     ; move to next BDS	in list
DOSBIOS:1B65		     inc     dl		     ; add a number
DOSBIOS:1B67		     jmp     short nextdrive ; Use same	info for BDS as	previous
DOSBIOS:1B69 ; ---------------------------------------------------------------------------
DOSBIOS:1B69
DOSBIOS:1B69 no_single:				     ; CODE XREF: DOSBIOS:1B56j
DOSBIOS:1B69		     inc     dl
DOSBIOS:1B6B		     jmp     loop_drive
DOSBIOS:1B6E ; ---------------------------------------------------------------------------
DOSBIOS:1B6E
DOSBIOS:1B6E done_drives:			     ; CODE XREF: DOSBIOS:1A64j
DOSBIOS:1B6E		     mov     word ptr [di], -1 ; set link to null
DOSBIOS:1B6E					     ;
DOSBIOS:1B6E					     ; set up all the hard drives in the system
DOSBIOS:1B72
DOSBIOS:1B72 dohard:				     ; CODE XREF: DOSBIOS:1A5Bj
DOSBIOS:1B72		     mov     dh, ds:hnum
DOSBIOS:1B76		     or	     dh, dh	     ; done if no hardfiles
DOSBIOS:1B78		     jz	     short static_configure
DOSBIOS:1B7A		     mov     dl, 80h
DOSBIOS:1B7C
DOSBIOS:1B7C dohard1:				     ; CODE XREF: DOSBIOS:1B99j
DOSBIOS:1B7C		     push    dx
DOSBIOS:1B7D		     mov     di, ds:end_of_bdss
DOSBIOS:1B81		     mov     bl, ds:drvmax
DOSBIOS:1B85		     mov     bh, 0	     ; first primary partition (or active)
DOSBIOS:1B87		     call    sethard
DOSBIOS:1B8A		     jb	     short hardfile_err
DOSBIOS:1B8C		     call    dmax_check	     ; error if	already	26 drives
DOSBIOS:1B8F		     jnb     short hardfile_err
DOSBIOS:1B91		     call    xinstall_bds    ; insert new bds into linked list
DOSBIOS:1B94
DOSBIOS:1B94 hardfile_err:			     ; CODE XREF: DOSBIOS:1B8Aj
DOSBIOS:1B94					     ; DOSBIOS:1B8Fj
DOSBIOS:1B94		     pop     dx
DOSBIOS:1B95		     inc     dl		     ; next hard drive
DOSBIOS:1B97		     dec     dh
DOSBIOS:1B99		     jnz     short dohard1   ;
DOSBIOS:1B99					     ; end of physical drive initialization
DOSBIOS:1B99					     ; ;
DOSBIOS:1B9B		     call    domini	     ; for setting up mini disks,
DOSBIOS:1B9B					     ; if found
DOSBIOS:1B9E		     mov     dh, ds:hnum     ; we already know this is >0
DOSBIOS:1BA2		     mov     dl, 80h
DOSBIOS:1BA4
DOSBIOS:1BA4 dohardx1:				     ; CODE XREF: DOSBIOS:1BC9j
DOSBIOS:1BA4		     mov     bh, 1	     ; do all subsequent primary partitions
DOSBIOS:1BA6
DOSBIOS:1BA6 dohardx2:				     ; CODE XREF: DOSBIOS:1BC1j
DOSBIOS:1BA6		     push    dx
DOSBIOS:1BA7		     push    bx
DOSBIOS:1BA8		     mov     di, ds:end_of_bdss
DOSBIOS:1BAC		     mov     bl, ds:drvmax
DOSBIOS:1BB0		     call    sethard
DOSBIOS:1BB3		     jb	     short dohardx4  ; move to next hardfile if	error
DOSBIOS:1BB5		     call    dmax_check	     ; make sure <=26 drives
DOSBIOS:1BB8		     jnb     short dohardx4  ; skip if error
DOSBIOS:1BBA		     call    xinstall_bds    ; insert new bds into linked list
DOSBIOS:1BBD		     pop     bx		     ; get partition number
DOSBIOS:1BBE		     pop     dx		     ; restore physical	drive counts
DOSBIOS:1BBF		     inc     bh
DOSBIOS:1BC1		     jmp     short dohardx2  ; keep looping until we fail
DOSBIOS:1BC3 ; ---------------------------------------------------------------------------
DOSBIOS:1BC3
DOSBIOS:1BC3 dohardx4:				     ; CODE XREF: DOSBIOS:1BB3j
DOSBIOS:1BC3					     ; DOSBIOS:1BB8j
DOSBIOS:1BC3		     pop     bx		     ; unjunk partition	number from stack
DOSBIOS:1BC4		     pop     dx		     ; restore physical	drive counts
DOSBIOS:1BC5		     inc     dl		     ; next hard drive
DOSBIOS:1BC7		     dec     dh
DOSBIOS:1BC9		     jnz     short dohardx1
DOSBIOS:1BCB		     cmp     ds:dsktnum, 2   ; >2 diskette drives
DOSBIOS:1BD0		     jbe     short static_configure ;  no - no need for	remapping
DOSBIOS:1BD2		     call    remap	     ; remap bds chain to adjust driver	letters
DOSBIOS:1BD2					     ;
DOSBIOS:1BD2					     ; End of drive initialization.
DOSBIOS:1BD5
DOSBIOS:1BD5 static_configure:			     ; CODE XREF: DOSBIOS:1B78j
DOSBIOS:1BD5					     ; DOSBIOS:1BD0j
DOSBIOS:1BD5		     mov     di, ds:end_of_bdss
DOSBIOS:1BD9		     cmp     di, offset	bdss ; did we allocate any hard	drive bdss?
DOSBIOS:1BDD		     jnz     short dynamic_configure ; that's the end, then
DOSBIOS:1BDF		     mov     di, offset	harddrv	; end96tpi
DOSBIOS:1BDF					     ; keep everything up to end96tpi
DOSBIOS:1BE2		     cmp     ds:fhave96, 0
DOSBIOS:1BE7		     jnz     short dynamic_configure
DOSBIOS:1BE9		     mov     di, offset	endfloppy
DOSBIOS:1BEC
DOSBIOS:1BEC dynamic_configure:			     ; CODE XREF: DOSBIOS:1BDDj
DOSBIOS:1BEC					     ; DOSBIOS:1BE7j
DOSBIOS:1BEC		     push    cs
DOSBIOS:1BED		     pop     es
DOSBIOS:1BEE		     assume es:DOSBIOS
DOSBIOS:1BEE		     cld
DOSBIOS:1BEF		     cmp     ds:model_byte, 0FCh ; AT ?
DOSBIOS:1BF4		     jnz     short checkcmosclock
DOSBIOS:1BF6		     cmp     ds:hnum, 0	     ; No hard file?
DOSBIOS:1BFB		     jz	     short checkcmosclock
DOSBIOS:1BFD		     xchg    ax, di	     ; save allocation pointer in ax
DOSBIOS:1BFE		     mov     si, 0F000h
DOSBIOS:1C01		     mov     es, si	     ; ES -> ROM BIOS segment
DOSBIOS:1C03		     assume es:nothing
DOSBIOS:1C03		     mov     si, offset	bios_date ; "01/10/84"
DOSBIOS:1C06		     mov     di, 0FFF5h	     ; ROM BIOS	string is at F000:FFF5
DOSBIOS:1C09		     mov     cx, 9	     ; bdate_l
DOSBIOS:1C09					     ; Only patch ROM for bios 01/10/84
DOSBIOS:1C0C		     repe cmpsb		     ; check for date +	zero on	end
DOSBIOS:1C0E		     xchg    ax, di	     ; restore allocation pointer
DOSBIOS:1C0F		     jnz     short checkcmosclock
DOSBIOS:1C11		     mov     cx, offset	endatrom
DOSBIOS:1C14		     mov     si, offset	ibm_disk_io
DOSBIOS:1C17		     jmp     short install_int13_patch
DOSBIOS:1C19 ; ---------------------------------------------------------------------------
DOSBIOS:1C19
DOSBIOS:1C19 checkcmosclock:			     ; CODE XREF: DOSBIOS:1BF4j
DOSBIOS:1C19					     ; DOSBIOS:1BFBj ...
DOSBIOS:1C19		     mov     ax, 0F000h	     ; checkcompaqbug
DOSBIOS:1C1C		     mov     es, ax	     ; point to	ROM BIOS
DOSBIOS:1C1E		     cmp     word ptr es:0FFEAh, 'OC' ; look for COMPAQ
DOSBIOS:1C25		     jnz     short not_compaq_patch
DOSBIOS:1C27		     cmp     word ptr es:0FFECh, 'PM'
DOSBIOS:1C2E		     jnz     short not_compaq_patch
DOSBIOS:1C30		     cmp     word ptr es:0FFEEh, 'QA'
DOSBIOS:1C37		     jnz     short not_compaq_patch
DOSBIOS:1C39		     mov     ax, es:0FFFBh   ; get year
DOSBIOS:1C3D		     xchg    ah, al
DOSBIOS:1C3F		     cmp     ax, '86'        ; 3836h
DOSBIOS:1C3F					     ; is it 86?
DOSBIOS:1C42		     ja	     short not_compaq_patch
DOSBIOS:1C44		     jb	     short do_compaq_patch
DOSBIOS:1C46		     mov     ax, es:0FFF5h   ; get month
DOSBIOS:1C4A		     xchg    ah, al
DOSBIOS:1C4C		     cmp     ax, '08'        ; 3038h
DOSBIOS:1C4C					     ; is it 08?
DOSBIOS:1C4F		     ja	     short not_compaq_patch
DOSBIOS:1C51		     jb	     short do_compaq_patch
DOSBIOS:1C53		     mov     ax, es:0FFF8h   ; get day
DOSBIOS:1C57		     xchg    ah, al
DOSBIOS:1C59		     cmp     ax, '04'        ; 3034h
DOSBIOS:1C59					     ; is it 04?
DOSBIOS:1C5C		     jnb     short not_compaq_patch
DOSBIOS:1C5E
DOSBIOS:1C5E do_compaq_patch:			     ; CODE XREF: DOSBIOS:1C44j
DOSBIOS:1C5E					     ; DOSBIOS:1C51j
DOSBIOS:1C5E		     mov     cx, offset	end_compaq_i13hook
DOSBIOS:1C61		     mov     si, offset	endatrom
DOSBIOS:1C64
DOSBIOS:1C64 install_int13_patch:		     ; CODE XREF: DOSBIOS:1C17j
DOSBIOS:1C64		     push    cs
DOSBIOS:1C65		     pop     es
DOSBIOS:1C66		     assume es:DOSBIOS
DOSBIOS:1C66		     mov     word ptr ds:Orig13, di ; set new rom bios int 13 vector
DOSBIOS:1C6A		     mov     word ptr ds:Orig13+2, cs
DOSBIOS:1C6E		     sub     cx, si	     ; size of rom fix module
DOSBIOS:1C70		     rep movsb		     ; relocate	it
DOSBIOS:1C72
DOSBIOS:1C72 not_compaq_patch:			     ; CODE XREF: DOSBIOS:1C25j
DOSBIOS:1C72					     ; DOSBIOS:1C2Ej ...
DOSBIOS:1C72		     push    cs
DOSBIOS:1C73		     pop     es
DOSBIOS:1C74		     cmp     ds:havecmosclock, 1 ; cmos	clock exists?
DOSBIOS:1C79		     jnz     short checkk09  ; no
DOSBIOS:1C7B		     mov     word ptr ds:daycnttoday, di ;
DOSBIOS:1C7B					     ; set the address for mschar
DOSBIOS:1C7F		     mov     cx, 209	     ; enddaycnttoday -	daycnt_to_day
DOSBIOS:1C82		     mov     si, offset	daycnt_to_day
DOSBIOS:1C85		     rep movsb
DOSBIOS:1C87		     mov     word ptr ds:bintobcd, di ;
DOSBIOS:1C87					     ; set the address for msclock
DOSBIOS:1C87					     ; let original segment stay
DOSBIOS:1C8B		     mov     cx, 11
DOSBIOS:1C8E		     mov     si, offset	bin_to_bcd
DOSBIOS:1C91		     rep movsb
DOSBIOS:1C93
DOSBIOS:1C93 checkk09:				     ; CODE XREF: DOSBIOS:1C79j
DOSBIOS:1C93		     push    di
DOSBIOS:1C94		     mov     ax, 4101h	     ; wait for	bh=es:[di]
DOSBIOS:1C97		     mov     bl, 1	     ; wait for	1 clock	tick
DOSBIOS:1C99		     mov     bh, es:[di]
DOSBIOS:1C9C		     stc		     ; Assume we will fail
DOSBIOS:1C9D		     int     15h	     ; SYSTEM -	WAIT ON	EXTERNAL EVENT (CONVERTIBLE)
DOSBIOS:1C9D					     ; AL = condition type, BH = condition compare or mask value
DOSBIOS:1C9D					     ; BL = timeout value times	55 milliseconds, 00h means no timeout
DOSBIOS:1C9D					     ; DX = I/O	port address if	AL bit 4 set
DOSBIOS:1C9F		     pop     di
DOSBIOS:1CA0		     jb	     short configdone
DOSBIOS:1CA2		     mov     ds:fhavek09, 1  ; remember	we have	a k09 type
DOSBIOS:1CA7		     push    ds
DOSBIOS:1CA8		     xor     ax, ax
DOSBIOS:1CAA		     mov     ds, ax
DOSBIOS:1CAC		     assume ds:nothing
DOSBIOS:1CAC		     mov     ds:1B0h, di     ; [6Ch*4]
DOSBIOS:1CAC					     ; new int 6ch handler
DOSBIOS:1CB0		     mov     word ptr ds:1B2h, cs ; [6Ch*4+2]
DOSBIOS:1CB4		     pop     ds
DOSBIOS:1CB5		     assume ds:nothing
DOSBIOS:1CB5		     mov     si, offset	int6c
DOSBIOS:1CB8		     mov     cx, 459	     ; endk09 -	int6c
DOSBIOS:1CB8					     ; size of k09 routine
DOSBIOS:1CBB		     rep movsb		     ;
DOSBIOS:1CBB					     ; set up config stuff for sysinit
DOSBIOS:1CBD
DOSBIOS:1CBD configdone:			     ; CODE XREF: DOSBIOS:1CA0j
DOSBIOS:1CBD		     push    cs		     ; di is final ending address of msbio.
DOSBIOS:1CBE		     pop     ds
DOSBIOS:1CBF		     assume ds:DOSBIOS
DOSBIOS:1CBF		     add     di, 15	     ; round (up) to paragraph
DOSBIOS:1CC2		     shr     di, 1
DOSBIOS:1CC4		     shr     di, 1
DOSBIOS:1CC6		     shr     di, 1
DOSBIOS:1CC8		     shr     di, 1
DOSBIOS:1CCA		     add     di, 70h	     ; KERNEL_SEGMENT (in fact:	IO.SYS loading segment)
DOSBIOS:1CCE		     mov     DosDataSg,	di   ; where the dos data segment will be
DOSBIOS:1CD2		     mov     ax, drvfat	     ; get drive and fat id
DOSBIOS:1CD5		     mov     bp, 4D7h	     ; set_drive (in dosbios code segment)
DOSBIOS:1CD5					     ; at 2C7h:4D7h = 70h:2A47h
DOSBIOS:1CD8		     push    cs		     ; simulate	far call
DOSBIOS:1CD9		     call    call_bios_code  ; get bds for drive
DOSBIOS:1CDC		     mov     bp, 606h	     ; GetBp (2C7h:606h	= 70h:2B76h)
DOSBIOS:1CDF		     push    cs
DOSBIOS:1CE0		     call    call_bios_code
DOSBIOS:1CE3		     push    es		     ; copy bds	to ds:di
DOSBIOS:1CE4		     pop     ds		     ;
DOSBIOS:1CE4					     ; the following read of es:0000 was spurious anyway. Should look into it.
DOSBIOS:1CE4					     ;
DOSBIOS:1CE4					     ; hmmmmmm.	j.k. took out a	call to	getfat right here a while
DOSBIOS:1CE4					     ; back. Apparently	it was what actually setup es: for the following   ; cas----
DOSBIOS:1CE5		     xor     di, di
DOSBIOS:1CE7		     mov     al, es:[di]     ; get fat id byte
DOSBIOS:1CEA		     mov     byte ptr es:drvfat+1, al ;	; save fat byte
DOSBIOS:1CEE		     mov     ax, es:drvfat   ;
DOSBIOS:1CEE					     ; cas -- why do a SECOND setdrive here???
DOSBIOS:1CF2		     push    es
DOSBIOS:1CF3		     push    ds		     ; copy bds	to es:di
DOSBIOS:1CF4		     pop     es
DOSBIOS:1CF5		     push    cs		     ; copy Bios_Data to ds
DOSBIOS:1CF6		     pop     ds
DOSBIOS:1CF7		     mov     bp, 4D7h	     ; SetDrive	(2C7h:47Dh = 70h:2A47h)
DOSBIOS:1CFA		     push    cs
DOSBIOS:1CFB		     call    call_bios_code
DOSBIOS:1CFE		     push    es
DOSBIOS:1CFF		     pop     ds
DOSBIOS:1D00		     pop     es
DOSBIOS:1D01		     assume es:nothing
DOSBIOS:1D01		     mov     bx, [di+6]	     ; [di+BDS.BDS_BPB.BPB_BYTESPERSECTOR]
DOSBIOS:1D04		     mov     cs:md_sectorsize, bx ;  used by get_fat_sector proc.
DOSBIOS:1D09		     mov     bl, [di+1Fh]    ; [di+BDS.fatsiz]
DOSBIOS:1D09					     ; get size	of fat on media
DOSBIOS:1D0C		     mov     es:16DEh, bl    ; es:fbigfat
DOSBIOS:1D11		     mov     cl, [di+8]
DOSBIOS:1D14		     mov     ax, [di+17h]    ; [di+BDS.BDS_BPB.BPB_HIDDENSECTORS]
DOSBIOS:1D17		     sub     es:16D8h, ax    ; es:bios_l
DOSBIOS:1D1C		     mov     ax, [di+19h]    ; subtract	hidden sectors since we
DOSBIOS:1D1C					     ; need a logical sector number that will
DOSBIOS:1D1C					     ; be used by getclus(diskrd procedure)
DOSBIOS:1D1F		     sbb     es:16DAh, ax    ; es:bios_h
DOSBIOS:1D1F					     ; subtract	upper 16 bits of sector	num
DOSBIOS:1D24		     xor     ch, ch	     ; cx = sectors/cluster
DOSBIOS:1D24					     ;
DOSBIOS:1D24					     ; the boot	program	has left the directory at 0:500h
DOSBIOS:1D26		     push    ds
DOSBIOS:1D27		     xor     di, di
DOSBIOS:1D29		     mov     ds, di
DOSBIOS:1D2B		     assume ds:nothing
DOSBIOS:1D2B		     mov     bx, ds:53Ah     ; clus=*53Ah
DOSBIOS:1D2B					     ; (First cluster field of 2nd dir entry
DOSBIOS:1D2B					     ; of root directory in the	buffer at 500h)
DOSBIOS:1D2F		     pop     ds
DOSBIOS:1D30		     assume ds:nothing
DOSBIOS:1D30
DOSBIOS:1D30 loadit:				     ; CODE XREF: DOSBIOS:iseofxj
DOSBIOS:1D30		     mov     ax, 46Dh
DOSBIOS:1D33		     mov     es, ax	     ; SYSINIT segment
DOSBIOS:1D35		     assume es:nothing
DOSBIOS:1D35		     mov     es, word ptr es:271h ; current_dos_location
DOSBIOS:1D3A		     assume es:nothing
DOSBIOS:1D3A		     call    getclus	     ; read cluster at ES:DI (DI is updated)
DOSBIOS:1D3D ; ---------------------------------------------------------------------------
DOSBIOS:1D3D		     test    cs:fbigfat, 40h ; fbig
DOSBIOS:1D43		     jnz     short eofbig
DOSBIOS:1D45		     cmp     bx, 0FF7h
DOSBIOS:1D49		     jmp     short iseofx
DOSBIOS:1D4B ; ---------------------------------------------------------------------------
DOSBIOS:1D4B
DOSBIOS:1D4B eofbig:				     ; CODE XREF: DOSBIOS:1D43j
DOSBIOS:1D4B		     cmp     bx, 0FFF7h
DOSBIOS:1D4E
DOSBIOS:1D4E iseofx:				     ; CODE XREF: DOSBIOS:1D49j
DOSBIOS:1D4E		     jb	     short loadit    ; keep loading until cluster = eof
DOSBIOS:1D50		     call    setdrvparms
DOSBIOS:1D53		     jmp     far ptr 46Dh:267h ; jmp far SYSINITSEG:SYSINITSTART
DOSBIOS:1D58
DOSBIOS:1D58 ; =============== S U B R O U T I N E =======================================
DOSBIOS:1D58
DOSBIOS:1D58
DOSBIOS:1D58 remap	     proc near		     ; CODE XREF: DOSBIOS:1BD2p
DOSBIOS:1D58		     mov     di, word ptr cs:start_bds ; this function	will be	called only if
DOSBIOS:1D58					     ; more than 2 diskettes are found in the system
DOSBIOS:1D58					     ;
DOSBIOS:1D58					     ; get first bds
DOSBIOS:1D5D
DOSBIOS:1D5D drive_loop:			     ; CODE XREF: remap+10j
DOSBIOS:1D5D		     cmp     byte ptr [di+4], 80h ; [di+BDS.drivenum]
DOSBIOS:1D5D					     ; first hard disk??
DOSBIOS:1D61		     jz	     short fdrv_found ;	yes, continue
DOSBIOS:1D63		     mov     di, [di]	     ; [di+BDS.link]
DOSBIOS:1D63					     ; get next	bds, assume segment
DOSBIOS:1D65		     cmp     di, -1	     ; last bds?
DOSBIOS:1D68		     jnz     short drive_loop ;	loop if	not
DOSBIOS:1D6A		     jmp     short rmap_exit ; yes, no hard drive on system
DOSBIOS:1D6C ; ---------------------------------------------------------------------------
DOSBIOS:1D6C
DOSBIOS:1D6C fdrv_found:			     ; CODE XREF: remap+9j
DOSBIOS:1D6C		     mov     al, 2	     ; start with logical drv num=2
DOSBIOS:1D6E
DOSBIOS:1D6E fdrv_loop:				     ; CODE XREF: remap+20j
DOSBIOS:1D6E		     mov     [di+5], al	     ; [di+BDS.drivelet]
DOSBIOS:1D6E					     ; found ??
DOSBIOS:1D71		     mov     di, [di]	     ; [di+BDS.link]
DOSBIOS:1D71					     ; ds:di-->	next bds
DOSBIOS:1D73		     inc     al		     ; set num for next	drive
DOSBIOS:1D75		     cmp     di, 0FFFFh	     ; last hard drive ??
DOSBIOS:1D78		     jnz     short fdrv_loop ; no - assign more	disk drives
DOSBIOS:1D7A		     mov     di, word ptr cs:start_bds ; [start_bds]
DOSBIOS:1D7A					     ; get first bds
DOSBIOS:1D7F		     mov     di, [di]	     ; [di+BDS.link]
DOSBIOS:1D7F					     ; ds:di-->bds2
DOSBIOS:1D81		     mov     ah, cs:dsktnum  ; get number of floppies to remap
DOSBIOS:1D86		     sub     ah, 2	     ; adjust for a: & b:
DOSBIOS:1D89
DOSBIOS:1D89 remap_loop1:			     ; CODE XREF: remap+3Aj
DOSBIOS:1D89		     mov     di, [di]	     ; [di+BDS.drivelet]
DOSBIOS:1D89					     ; set new num to next floppy
DOSBIOS:1D8B		     mov     [di+5], al
DOSBIOS:1D8E		     inc     al		     ; new number for next floppy
DOSBIOS:1D90		     dec     ah		     ; count down extra	floppies
DOSBIOS:1D92		     jnz     short remap_loop1
DOSBIOS:1D94		     mov     al, byte ptr cs:drvfat ; now we've got to adjust the boot drive
DOSBIOS:1D94					     ; if we reassigned	it
DOSBIOS:1D98		     cmp     al, 2	     ; is it a:	or b: ?
DOSBIOS:1D9A		     jb	     short rmap_exit
DOSBIOS:1D9C		     sub     al, cs:dsktnum  ; is it one of the	other floppies?
DOSBIOS:1DA1		     jb	     short remap_boot_flop ; brif so
DOSBIOS:1DA3		     add     al, 2	     ; bootdrv -= (dsktnum-2)
DOSBIOS:1DA5		     jmp     short remap_change_boot_drv
DOSBIOS:1DA7 ; ---------------------------------------------------------------------------
DOSBIOS:1DA7
DOSBIOS:1DA7 remap_boot_flop:			     ; CODE XREF: remap+49j
DOSBIOS:1DA7		     add     al, cs:drvmax   ; bootdrv += (drvmax-dsktnum)
DOSBIOS:1DAC
DOSBIOS:1DAC remap_change_boot_drv:		     ; CODE XREF: remap+4Dj
DOSBIOS:1DAC		     mov     byte ptr cs:drvfat, al ; alter msdos.sys load drive
DOSBIOS:1DB0		     inc     al
DOSBIOS:1DB2		     push    ds
DOSBIOS:1DB3		     mov     di, 46Dh	     ; SYSINIT segment
DOSBIOS:1DB6		     mov     ds, di
DOSBIOS:1DB8		     assume ds:nothing
DOSBIOS:1DB8		     mov     ds:296h, al     ; [SYSINIT+DEFAULT_DRIVE]
DOSBIOS:1DB8					     ; pass it to sysinit as well
DOSBIOS:1DBB		     pop     ds
DOSBIOS:1DBC		     assume ds:nothing
DOSBIOS:1DBC
DOSBIOS:1DBC rmap_exit:				     ; CODE XREF: remap+12j
DOSBIOS:1DBC					     ; remap+42j
DOSBIOS:1DBC		     retn
DOSBIOS:1DBC remap	     endp
DOSBIOS:1DBC
DOSBIOS:1DBD
DOSBIOS:1DBD ; =============== S U B R O U T I N E =======================================
DOSBIOS:1DBD
DOSBIOS:1DBD
DOSBIOS:1DBD getboot	     proc near		     ; CODE XREF: sethard+2Dp
DOSBIOS:1DBD					     ; domini+2Ap
DOSBIOS:1DBD		     mov     ax, cs:init_bootseg
DOSBIOS:1DC1		     mov     es, ax
DOSBIOS:1DC3		     mov     bx, 200h	     ; bootbias
DOSBIOS:1DC3					     ; load BX,	ES:BX is where sector goes
DOSBIOS:1DC6		     mov     ax, 201h
DOSBIOS:1DC9		     xor     dh, dh
DOSBIOS:1DCB		     mov     cx, 1
DOSBIOS:1DCE		     int     13h	     ; DISK - READ SECTORS INTO	MEMORY
DOSBIOS:1DCE					     ; AL = number of sectors to read, CH = track, CL =	sector
DOSBIOS:1DCE					     ; DH = head, DL = drive, ES:BX -> buffer to fill
DOSBIOS:1DCE					     ; Return: CF set on error,	AH = status, AL	= number of sectors read
DOSBIOS:1DD0		     jb	     short erret
DOSBIOS:1DD2		     cmp     word ptr es:3FEh, 0AA55h ;	[es:bootbias+1FEh]
DOSBIOS:1DD2					     ; Dave Litton magic word?
DOSBIOS:1DD9		     jz	     short norm_ret
DOSBIOS:1DDB
DOSBIOS:1DDB erret:				     ; CODE XREF: getboot+13j
DOSBIOS:1DDB		     stc
DOSBIOS:1DDC
DOSBIOS:1DDC norm_ret:				     ; CODE XREF: getboot+1Cj
DOSBIOS:1DDC		     retn
DOSBIOS:1DDC getboot	     endp
DOSBIOS:1DDC
DOSBIOS:1DDD
DOSBIOS:1DDD ; =============== S U B R O U T I N E =======================================
DOSBIOS:1DDD
DOSBIOS:1DDD
DOSBIOS:1DDD sethard	     proc near		     ; CODE XREF: DOSBIOS:1B87p
DOSBIOS:1DDD					     ; DOSBIOS:1BB0p
DOSBIOS:1DDD		     push    di		     ; generate	bpb for	a variable sized hard file.
DOSBIOS:1DDD					     ; ibm has a partitioned hard file
DOSBIOS:1DDD					     ; we must read physical sector 0 to
DOSBIOS:1DDD					     ; determine where our own logical sectors start.
DOSBIOS:1DDD					     ; we also read in our boot	sector to determine
DOSBIOS:1DDD					     ; version number
DOSBIOS:1DDD					     ;
DOSBIOS:1DDD					     ; inputs:
DOSBIOS:1DDD					     ; dl is rom drive number (80...)
DOSBIOS:1DDD					     ; bh is partition number (0....)
DOSBIOS:1DDD					     ; ds:di points to bds
DOSBIOS:1DDD					     ;
DOSBIOS:1DDD					     ; outputs:
DOSBIOS:1DDD					     ; carry clear -> bpb is filled in
DOSBIOS:1DDD					     ; carry set   -> bpb is left uninitialized	due to error
DOSBIOS:1DDE		     push    bx
DOSBIOS:1DDF		     push    ds
DOSBIOS:1DE0		     push    es
DOSBIOS:1DE1		     mov     [di+5], bl	     ; [di+BDS.drivelet]
DOSBIOS:1DE4		     mov     [di+4], dl	     ; [di+BDS.drivenum]
DOSBIOS:1DE7		     or	     byte ptr [di+23h],	1 ; [di+BDS.flags]
DOSBIOS:1DE7					     ; fnon_removable
DOSBIOS:1DEB		     mov     byte ptr [di+22h],	5 ; [di+BDS.formfactor]
DOSBIOS:1DEB					     ; ffHardFile
DOSBIOS:1DEF		     mov     ds:fbigfat, 0   ; assume 12 bit FAT
DOSBIOS:1DF4		     mov     dh, bh	     ; partition number
DOSBIOS:1DF6		     push    dx
DOSBIOS:1DF7		     mov     ah, 8
DOSBIOS:1DF9		     int     13h	     ; DISK - DISK - GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)
DOSBIOS:1DF9					     ; DL = drive number
DOSBIOS:1DF9					     ; Return: CF set on error,	AH = status code, BL = drive type
DOSBIOS:1DF9					     ; DL = number of consecutive drives
DOSBIOS:1DF9					     ; DH = maximum value for head number, ES:DI -> drive parameter
DOSBIOS:1DFB		     inc     dh
DOSBIOS:1DFD		     mov     [di+15h], dh    ; [di+BDS.heads] ;	get number of heads
DOSBIOS:1E00		     pop     dx
DOSBIOS:1E01		     jb	     short setret    ; error if	no hard	disk
DOSBIOS:1E03		     and     cl, 3Fh
DOSBIOS:1E06		     mov     [di+13h], cl    ; [di+BDS.secpertrack]
DOSBIOS:1E09		     push    dx		     ; save partition number
DOSBIOS:1E0A		     call    getboot
DOSBIOS:1E0D		     pop     dx		     ; restore partition number
DOSBIOS:1E0E		     jb	     short setret
DOSBIOS:1E10		     mov     bx, 3C2h	     ; 1C2h+bootbias
DOSBIOS:1E13
DOSBIOS:1E13 act_part:				     ; CODE XREF: sethard+5Cj
DOSBIOS:1E13		     test    byte ptr es:[bx-4], 80h ; The first 'active' partition is 00,
DOSBIOS:1E13					     ; the second is 01....
DOSBIOS:1E13					     ; then the	remainder of the 'primary'
DOSBIOS:1E13					     ; but non-active partitions
DOSBIOS:1E13					     ;
DOSBIOS:1E13					     ; is the partition	active?
DOSBIOS:1E18		     jz	     short no_act    ; no
DOSBIOS:1E1A		     cmp     byte ptr es:[bx], 1 ; reject if partitiontype != 1, 4 or 6
DOSBIOS:1E1E		     jz	     short got_good_act
DOSBIOS:1E20		     cmp     byte ptr es:[bx], 4
DOSBIOS:1E24		     jz	     short got_good_act
DOSBIOS:1E26		     cmp     byte ptr es:[bx], 6
DOSBIOS:1E2A		     jnz     short no_act
DOSBIOS:1E2C
DOSBIOS:1E2C got_good_act:			     ; CODE XREF: sethard+41j
DOSBIOS:1E2C					     ; sethard+47j
DOSBIOS:1E2C		     or	     dh, dh	     ; is this our target partition #?
DOSBIOS:1E2E		     jz	     short set2	     ; WE GOT THE ONE WANTED!!
DOSBIOS:1E30		     dec     dh		     ; count down
DOSBIOS:1E32
DOSBIOS:1E32 no_act:				     ; CODE XREF: sethard+3Bj
DOSBIOS:1E32					     ; sethard+4Dj
DOSBIOS:1E32		     add     bx, 16
DOSBIOS:1E35		     cmp     bx, 402h	     ; 202h+bootbias
DOSBIOS:1E35					     ; last entry done?
DOSBIOS:1E39		     jnz     short act_part  ; no,process next entry
DOSBIOS:1E39					     ;
DOSBIOS:1E39					     ; Now scan	the non-active partitions
DOSBIOS:1E3B		     mov     bx, 3C2h	     ; 1C2h+bootbias
DOSBIOS:1E3B					     ; restore original	value of bx
DOSBIOS:1E3E
DOSBIOS:1E3E get_primary:			     ; CODE XREF: sethard+87j
DOSBIOS:1E3E		     test    byte ptr es:[bx-4], 80h
DOSBIOS:1E43		     jnz     short not_prim  ; we've already scanned
DOSBIOS:1E43					     ; the ACTIVE ones
DOSBIOS:1E45		     cmp     byte ptr es:[bx], 1 ; see if partitiontype	== 1, 4	or 6
DOSBIOS:1E49		     jz	     short got_prim
DOSBIOS:1E4B		     cmp     byte ptr es:[bx], 4
DOSBIOS:1E4F		     jz	     short got_prim
DOSBIOS:1E51		     cmp     byte ptr es:[bx], 6
DOSBIOS:1E55		     jnz     short not_prim
DOSBIOS:1E57
DOSBIOS:1E57 got_prim:				     ; CODE XREF: sethard+6Cj
DOSBIOS:1E57					     ; sethard+72j
DOSBIOS:1E57		     or	     dh, dh	     ; is this our target partition?
DOSBIOS:1E59		     jz	     short set2
DOSBIOS:1E5B		     dec     dh
DOSBIOS:1E5D
DOSBIOS:1E5D not_prim:				     ; CODE XREF: sethard+66j
DOSBIOS:1E5D					     ; sethard+78j
DOSBIOS:1E5D		     add     bx, 16
DOSBIOS:1E60		     cmp     bx, 402h	     ; 202h+bootbias
DOSBIOS:1E64		     jnz     short get_primary ; loop till we've gone through table
DOSBIOS:1E66
DOSBIOS:1E66 setret:				     ; CODE XREF: sethard+24j
DOSBIOS:1E66					     ; sethard+31j ...
DOSBIOS:1E66		     stc		     ; error return
DOSBIOS:1E67		     jmp     ret_hard_err
DOSBIOS:1E6A ; ---------------------------------------------------------------------------
DOSBIOS:1E6A
DOSBIOS:1E6A set2:				     ; CODE XREF: sethard+51j
DOSBIOS:1E6A					     ; sethard+7Cj ...
DOSBIOS:1E6A		     mov     cs:rom_drv_num, dl
DOSBIOS:1E6F		     mov     ax, es:[bx+4]   ; hidden sectors (start sector)
DOSBIOS:1E73		     mov     dx, es:[bx+6]
DOSBIOS:1E77		     sub     ax, 1	     ; decrement the sector count by 1
DOSBIOS:1E77					     ; to make it zero based
DOSBIOS:1E7A		     sbb     dx, 0
DOSBIOS:1E7D		     add     ax, es:[bx+8]   ; sectors in partition
DOSBIOS:1E81		     adc     dx, es:[bx+10]
DOSBIOS:1E85		     jnb     short okdrive
DOSBIOS:1E87		     or	     ds:fbigfat, 80h ; ftoobig
DOSBIOS:1E8C
DOSBIOS:1E8C okdrive:				     ; CODE XREF: sethard+A8j
DOSBIOS:1E8C		     mov     ax, es:[bx+4]
DOSBIOS:1E90		     mov     [di+17h], ax    ; [di+BDS.hiddensecs]
DOSBIOS:1E90					     ; BPB_HIDDENSECTORS = p->partitionbegin
DOSBIOS:1E93		     mov     ax, es:[bx+6]
DOSBIOS:1E97		     mov     [di+19h], ax    ; [di+BDS.hiddensecs+2]
DOSBIOS:1E9A		     mov     dx, es:[bx+10]  ; # of sectors (high)
DOSBIOS:1E9E		     mov     ax, es:[bx+8]   ; # of sectors (low)
DOSBIOS:1EA2		     mov     [di+1Dh], dx    ; [di+BDS.totalsecs32+2]
DOSBIOS:1EA5		     mov     [di+1Bh], ax    ; [di+BDS.totalsecs32]
DOSBIOS:1EA5					     ; bpb->maxsec = p->partitionlength
DOSBIOS:1EA8		     cmp     dx, 0
DOSBIOS:1EAB		     ja	     short okdrive_1
DOSBIOS:1EAD		     cmp     ax, 64	     ; if (p->partitionlength <	64)
DOSBIOS:1EB0		     jb	     short setret    ; return -1;
DOSBIOS:1EB2
DOSBIOS:1EB2 okdrive_1:				     ; CODE XREF: sethard+CEj
DOSBIOS:1EB2		     mov     dx, [di+19h]    ; [di+BDS.hiddensecs+2]
DOSBIOS:1EB5		     mov     ax, [di+17h]    ; [di+BDS.hiddensecs]
DOSBIOS:1EB8		     xor     bx, bx	     ; boot sector number - for	mini disk
DOSBIOS:1EB8					     ; usually equal to	the # of sec/trk.
DOSBIOS:1EBA		     mov     bl, [di+13h]    ; [di+BDS.secpertrack]
DOSBIOS:1EBD		     push    ax
DOSBIOS:1EBE		     mov     ax, dx
DOSBIOS:1EC0		     xor     dx, dx
DOSBIOS:1EC2		     div     bx		     ; (sectors)dx:ax /	(BDS.secpertrack)bx =
DOSBIOS:1EC2					     ; (track)temp_h:ax	+ (sector)dx
DOSBIOS:1EC4		     mov     cs:temp_h,	ax
DOSBIOS:1EC8		     pop     ax
DOSBIOS:1EC9		     div     bx
DOSBIOS:1ECB		     mov     cl, dl
DOSBIOS:1ECD		     inc     cl
DOSBIOS:1ECF		     xor     bx, bx
DOSBIOS:1ED1		     mov     bl, [di+15h]    ; [di+BDS.heads]
DOSBIOS:1ED4		     push    ax
DOSBIOS:1ED5		     xor     dx, dx
DOSBIOS:1ED7		     mov     ax, cs:temp_h
DOSBIOS:1EDB		     div     bx
DOSBIOS:1EDD		     mov     cs:temp_h,	ax
DOSBIOS:1EE1		     pop     ax
DOSBIOS:1EE2		     div     bx		     ;	dl is head, ax is cylinder
DOSBIOS:1EE4		     cmp     cs:temp_h,	0
DOSBIOS:1EEA		     ja	     short setret_brdg ; exceeds the limit of int 13h
DOSBIOS:1EEC		     cmp     ax, 1024
DOSBIOS:1EEF		     ja	     short setret_brdg ; exceeds the limit of int 13h
DOSBIOS:1EF1		     cmp     word ptr [di+47h],	1 ; [di+BDS.bdsm_ismini]
DOSBIOS:1EF1					     ; check for mini disk
DOSBIOS:1EF5		     jnz     short oknotmini ; not mini	disk.
DOSBIOS:1EF7		     add     ax, [di+49h]    ; [di+BDS.bdsm_hidden_trks]
DOSBIOS:1EF7					     ; set the physical	track number
DOSBIOS:1EFA
DOSBIOS:1EFA oknotmini:				     ; CODE XREF: sethard+118j
DOSBIOS:1EFA		     ror     ah, 1	     ; move high two bits of cyl to high
DOSBIOS:1EFC		     ror     ah, 1	     ; two bits	of upper byte
DOSBIOS:1EFE		     and     ah, 0C0h	     ; turn off	remainder of bits
DOSBIOS:1F01		     or	     cl, ah	     ; move two	bits to	correct	spot
DOSBIOS:1F03		     mov     ch, al	     ; ch is cylinder (low 8 bits)
DOSBIOS:1F03					     ; cl is sector + 2	high bits of cylinder
DOSBIOS:1F05		     mov     dh, dl	     ; dh is head
DOSBIOS:1F07		     mov     dl, cs:rom_drv_num	; dl is	drive number
DOSBIOS:1F0C		     push    cs
DOSBIOS:1F0D		     pop     es
DOSBIOS:1F0E		     assume es:DOSBIOS
DOSBIOS:1F0E		     mov     bx, offset	disksector ; for convenience,
DOSBIOS:1F0E					     ; we are going to read the	logical	boot sector
DOSBIOS:1F0E					     ; into cs:disksector area.
DOSBIOS:1F11		     mov     ax, 201h
DOSBIOS:1F14		     int     13h	     ; DISK - READ SECTORS INTO	MEMORY
DOSBIOS:1F14					     ; AL = number of sectors to read, CH = track, CL =	sector
DOSBIOS:1F14					     ; DH = head, DL = drive, ES:BX -> buffer to fill
DOSBIOS:1F14					     ; Return: CF set on error,	AH = status, AL	= number of sectors read
DOSBIOS:1F16		     mov     bx, offset	disksector
DOSBIOS:1F19		     push    bx
DOSBIOS:1F1A		     push    ax
DOSBIOS:1F1B		     cmp     byte ptr cs:[bx], 0E9h ; is it a near jump?
DOSBIOS:1F1F		     jz	     short check_1_ok ;	yes
DOSBIOS:1F21		     cmp     byte ptr cs:[bx], 0EBh ; is it a short jump?
DOSBIOS:1F25		     jnz     short invalid_boot_record ; no
DOSBIOS:1F27		     cmp     byte ptr cs:[bx+2], 90h ; yes, is the next	one a nop?
DOSBIOS:1F2C		     jnz     short invalid_boot_record
DOSBIOS:1F2E
DOSBIOS:1F2E check_1_ok:			     ; CODE XREF: sethard+142j
DOSBIOS:1F2E		     mov     bx, 159h	     ; disksector+EXT_BOOT.BPB
DOSBIOS:1F2E					     ; point to	the bpb	in the boot record
DOSBIOS:1F31		     mov     al, cs:[bx+10]  ; [bx+EBPB.MEDIADESCRIPTOR]
DOSBIOS:1F31					     ; get the mediadescriptor byte
DOSBIOS:1F35		     and     al, 0F0h	     ; mask off	low nibble
DOSBIOS:1F37		     cmp     al, 0F0h	     ; is high nibble =	0Fh?
DOSBIOS:1F39		     jnz     short invalid_boot_record ; no, invalid boot record
DOSBIOS:1F3B		     cmp     word ptr cs:[bx], 512 ; [bx+EBPB.BYTESPERSECTOR]
DOSBIOS:1F40		     jnz     short invalid_boot_record ; invalidate non	512 byte sectors
DOSBIOS:1F42
DOSBIOS:1F42 check2_ok:				     ; yes, mediadescriptor ok.
DOSBIOS:1F42		     mov     al, cs:[bx+2]   ; now make	sure that
DOSBIOS:1F42					     ; the sectorspercluster is
DOSBIOS:1F42					     ; a power of 2
DOSBIOS:1F42					     ;
DOSBIOS:1F42					     ; [bx+EBPB.SECTORSPERCLUSTER]
DOSBIOS:1F42					     ; get the sectorspercluster
DOSBIOS:1F46		     or	     al, al	     ; is it zero?
DOSBIOS:1F48		     jz	     short invalid_boot_record ; yes, invalid boot record
DOSBIOS:1F4A
DOSBIOS:1F4A ck_power_of_two:			     ; CODE XREF: sethard+16Fj
DOSBIOS:1F4A		     shr     al, 1	     ; shift until first bit emerges
DOSBIOS:1F4C		     jnb     short ck_power_of_two
DOSBIOS:1F4E		     jz	     short valid_boot_record
DOSBIOS:1F50
DOSBIOS:1F50 invalid_boot_record:		     ; CODE XREF: sethard+148j
DOSBIOS:1F50					     ; sethard+14Fj ...
DOSBIOS:1F50		     pop     ax
DOSBIOS:1F51		     pop     bx
DOSBIOS:1F52		     jmp     unknown	     ; jump to invalid boot record
DOSBIOS:1F52					     ;	unformatted or illegal media.
DOSBIOS:1F55 ; ---------------------------------------------------------------------------
DOSBIOS:1F55
DOSBIOS:1F55 valid_boot_record:			     ; CODE XREF: sethard+171j
DOSBIOS:1F55		     pop     ax		     ; Signature found.	Now check version.
DOSBIOS:1F56		     pop     bx
DOSBIOS:1F57		     cmp     word ptr cs:[bx+8], 2E32h ; '2.'
DOSBIOS:1F5D		     jnz     short try5
DOSBIOS:1F5F		     cmp     byte ptr cs:[bx+0Ah], 30h ; '0'
DOSBIOS:1F64		     jnz     short try5
DOSBIOS:1F66		     jmp     short copybpb
DOSBIOS:1F68 ; ---------------------------------------------------------------------------
DOSBIOS:1F68
DOSBIOS:1F68 setret_brdg:			     ; CODE XREF: sethard+10Dj
DOSBIOS:1F68					     ; sethard+112j
DOSBIOS:1F68		     jmp     setret
DOSBIOS:1F6B ; ---------------------------------------------------------------------------
DOSBIOS:1F6B
DOSBIOS:1F6B unknown3_0_j:			     ; CODE XREF: sethard+1AFj
DOSBIOS:1F6B					     ; sethard+1B8j
DOSBIOS:1F6B		     jmp     unknown3_0	     ; legally formatted media,
DOSBIOS:1F6B					     ; although, content might be bad.
DOSBIOS:1F6E ; ---------------------------------------------------------------------------
DOSBIOS:1F6E
DOSBIOS:1F6E try5:				     ; CODE XREF: sethard+180j
DOSBIOS:1F6E					     ; sethard+187j
DOSBIOS:1F6E		     call    cover_fdisk_bug ;
DOSBIOS:1F6E					     ; see if it is an os2 signature
DOSBIOS:1F71		     cmp     word ptr cs:[bx+8], 2E30h ; '0.'
DOSBIOS:1F77		     jnz     short no_os2
DOSBIOS:1F79		     mov     al, cs:[bx+7]
DOSBIOS:1F7D		     sub     al, 31h	     ; '1'
DOSBIOS:1F7F		     and     al, 0FEh
DOSBIOS:1F81		     jz	     short copybpb   ; accept either '1' or '2'
DOSBIOS:1F83		     jmp     unknown
DOSBIOS:1F86 ; ---------------------------------------------------------------------------
DOSBIOS:1F86
DOSBIOS:1F86 no_os2:				     ; CODE XREF: sethard+19Aj
DOSBIOS:1F86		     cmp     word ptr cs:[bx+8], 2E33h ; '3.'
DOSBIOS:1F8C		     jb	     short unknown3_0_j	; must be 2.1 boot record.
DOSBIOS:1F8C					     ; do not trust it,	but still legal.
DOSBIOS:1F8E		     jnz     short copybpb   ; honor os2 boot record
DOSBIOS:1F8E					     ; or dos 4.0 version
DOSBIOS:1F90		     cmp     byte ptr cs:[bx+0Ah], 31h ; '1'
DOSBIOS:1F95		     jb	     short unknown3_0_j	;
DOSBIOS:1F95					     ; if version >= 3.1, then o.k.
DOSBIOS:1F97
DOSBIOS:1F97 copybpb:				     ; CODE XREF: sethard+189j
DOSBIOS:1F97					     ; sethard+1A4j ...
DOSBIOS:1F97		     cmp     cs:disksector+26h,	29h ; [disksector+EXT_BOOT.SIG]
DOSBIOS:1F97					     ; EXT_BOOT_SIGNATURE
DOSBIOS:1F9D		     jnz     short copybpb_fat ; conventional fat system
DOSBIOS:1F9F		     cmp     cs:disksector+10h,	0 ;
DOSBIOS:1F9F					     ; [disksector+EXT_BOOT.BPB+EBPB.NUMBEROFFATS]
DOSBIOS:1FA5		     jnz     short copybpb_fat ; a fat system.
DOSBIOS:1FA5					     ;
DOSBIOS:1FA5					     ; non fat based media.
DOSBIOS:1FA7		     push    di
DOSBIOS:1FA8		     push    ds
DOSBIOS:1FA9		     push    ds
DOSBIOS:1FAA		     pop     es
DOSBIOS:1FAB		     assume es:nothing
DOSBIOS:1FAB		     push    cs
DOSBIOS:1FAC		     pop     ds
DOSBIOS:1FAD		     assume ds:DOSBIOS
DOSBIOS:1FAD		     mov     si, 159h	     ; disksector+EXT_BOOT.BPB
DOSBIOS:1FB0		     add     di, 6	     ; add di,BDS.BPB
DOSBIOS:1FB3		     cmp     word ptr cs:[si+8], 0 ; [cs:si+EBPB.TOTALSECTORS]
DOSBIOS:1FB8		     jnz     short already_nonz	;
DOSBIOS:1FB8					     ;	how about big_total?
DOSBIOS:1FBA		     cmp     word ptr cs:[si+15h], 0 ; [cs:si+EBPB.BIGTOTALSECTORS]
DOSBIOS:1FBF		     jnz     short already_nonz
DOSBIOS:1FC1		     cmp     word ptr cs:[si+17h], 0 ; [cs:si+EBPB.BIGTOTALSECTORS+2]
DOSBIOS:1FC6		     jnz     short already_nonz	;
DOSBIOS:1FC6					     ; now let's copy the values from the partition table
DOSBIOS:1FC6					     ; (now in the BDS)	into the BPB in	the boot sector	buffer,
DOSBIOS:1FC6					     ; before they get copied back
DOSBIOS:1FC8		     mov     ax, [di+8]	     ; [di+BDS.totalsecs16]
DOSBIOS:1FCB		     mov     cs:[si+8],	ax   ; [cs:si+EBPB.TOTALSECTORS]
DOSBIOS:1FCF		     mov     ax, [di+15h]    ; [di+BDS.totalsecs32]
DOSBIOS:1FD2		     mov     cs:[si+15h], ax ; [cs:si+EBPB.BIGTOTALSECTORS]
DOSBIOS:1FD6		     mov     ax, [di+17h]    ; [di+BDS.totalsecs32+2]
DOSBIOS:1FD9		     mov     cs:[si+17h], ax ; [cs:si+EBPB.BIGTOTALSECTORS+2]
DOSBIOS:1FDD
DOSBIOS:1FDD already_nonz:			     ; CODE XREF: sethard+1DBj
DOSBIOS:1FDD					     ; sethard+1E2j ...
DOSBIOS:1FDD		     mov     cx, 25
DOSBIOS:1FE0		     rep movsb
DOSBIOS:1FE2		     pop     ds
DOSBIOS:1FE3		     assume ds:nothing
DOSBIOS:1FE3		     pop     di
DOSBIOS:1FE4		     push    es
DOSBIOS:1FE5		     push    ds
DOSBIOS:1FE6		     pop     es
DOSBIOS:1FE7		     push    cs
DOSBIOS:1FE8		     pop     ds
DOSBIOS:1FE9		     assume ds:DOSBIOS
DOSBIOS:1FE9		     mov     bp, 751h	     ; mov_media_ids
DOSBIOS:1FE9					     ; at 2C7h:751h = 70h:2CC1h
DOSBIOS:1FE9					     ; set volume id, systemid,	serial.
DOSBIOS:1FEC		     push    cs		     ; simulate	far call
DOSBIOS:1FED		     call    call_bios_code
DOSBIOS:1FF0		     push    es
DOSBIOS:1FF1		     pop     ds
DOSBIOS:1FF2		     assume ds:nothing
DOSBIOS:1FF2		     pop     es
DOSBIOS:1FF3		     jmp     goodret
DOSBIOS:1FF6 ; ---------------------------------------------------------------------------
DOSBIOS:1FF6
DOSBIOS:1FF6 copybpb_fat:			     ; CODE XREF: sethard+1C0j
DOSBIOS:1FF6					     ; sethard+1C8j
DOSBIOS:1FF6		     mov     si, 159h	     ; disksector+EXT_BOOT.BPB
DOSBIOS:1FF6					     ; cs:si ->	bpb in boot
DOSBIOS:1FF9		     xor     dx, dx
DOSBIOS:1FFB		     mov     ax, cs:[si+8]   ; [cs:si+EBPB.TOTALSECTORS]
DOSBIOS:1FFB					     ; get totsec from boot sec
DOSBIOS:1FFF		     or	     ax, ax
DOSBIOS:2001		     jnz     short copy_totsec ; if non	zero, use that
DOSBIOS:2003		     mov     ax, cs:[si+15h] ; [cs:si+EBPB.BIGTOTALSECTORS]
DOSBIOS:2003					     ; get the big version
DOSBIOS:2003					     ; (32 bit total sectors)
DOSBIOS:2007		     mov     dx, cs:[si+17h] ; [cs:si+EBPB.BIGTOTALSECTORS+2]
DOSBIOS:200B		     mov     cx, dx
DOSBIOS:200D		     or	     cx, ax	     ; see if it is a big zero
DOSBIOS:200F		     jz	     short totsec_already_set ;	screw it. it was bogus.
DOSBIOS:2011
DOSBIOS:2011 copy_totsec:			     ; CODE XREF: sethard+224j
DOSBIOS:2011		     mov     [di+1Bh], ax    ; [di+BDS.totalsecs32]
DOSBIOS:2011					     ; make DPB	match boot sec
DOSBIOS:2014		     mov     [di+1Dh], dx    ; [di+BDS.totalsecs32+2]
DOSBIOS:2017
DOSBIOS:2017 totsec_already_set:		     ; CODE XREF: sethard+232j
DOSBIOS:2017		     mov     ax, [di+1Bh]    ; [di+BDS.totalsecs32]
DOSBIOS:201A		     mov     dx, [di+1Dh]    ; [di+BDS.totalsecs32+2]
DOSBIOS:201D
DOSBIOS:201D fat_big_small:			     ; [cs:si+EBPB.RESERVEDSECTORS]
DOSBIOS:201D		     mov     bx, cs:[si+3]   ; get #reserved_sectors from BPB
DOSBIOS:2021		     mov     [di+9], bx	     ; [di+BDS.resectors]
DOSBIOS:2021					     ; update BDS field
DOSBIOS:2024		     sub     ax, bx
DOSBIOS:2026		     sbb     dx, 0	     ; update the count
DOSBIOS:2029		     mov     bx, cs:[si+0Bh] ; [cs:si+EBPB.SECTORSPERFAT]
DOSBIOS:2029					     ; bx = sectors/fat
DOSBIOS:202D		     mov     [di+11h], bx    ; [di+BDS.fatsecs]
DOSBIOS:202D					     ; set in bds bpb
DOSBIOS:2030		     shl     bx, 1	     ; always 2	fats
DOSBIOS:2032		     sub     ax, bx	     ; sub # fat sectors
DOSBIOS:2034		     sbb     dx, 0
DOSBIOS:2037		     mov     bx, cs:[si+6]   ; [cs:si+EBPB.ROOTENTRIES]
DOSBIOS:2037					     ; # root entries
DOSBIOS:203B		     mov     [di+0Ch], bx    ; [di+BDS.direntries]
DOSBIOS:203B					     ; set in bds bpb
DOSBIOS:203E		     mov     cl, 4
DOSBIOS:2040		     shr     bx, cl	     ; div by 16 ents/sector
DOSBIOS:2042		     sub     ax, bx	     ; sub # dir sectors
DOSBIOS:2044		     sbb     dx, 0	     ;
DOSBIOS:2044					     ; dx:ax now contains the
DOSBIOS:2044					     ; # of data sectors
DOSBIOS:2047		     xor     cx, cx
DOSBIOS:2049		     mov     cl, cs:[si+2]   ; [cs:si+EBPB.SECTORSPERCLUSTER]
DOSBIOS:2049					     ; sectors per cluster
DOSBIOS:204D		     mov     [di+8], cl	     ; [di+BDS.secperclus]
DOSBIOS:204D					     ; set in bios bpb
DOSBIOS:2050		     push    ax
DOSBIOS:2051		     mov     ax, dx
DOSBIOS:2053		     xor     dx, dx
DOSBIOS:2055		     div     cx		     ; cx = sectors per	cluster
DOSBIOS:2057		     mov     cs:temp_h,	ax   ; [temp_h]:ax now contains	the
DOSBIOS:2057					     ; # clusters.
DOSBIOS:205B		     pop     ax
DOSBIOS:205C		     div     cx
DOSBIOS:205E		     cmp     cs:temp_h,	0
DOSBIOS:2064		     ja	     short toobig_ret ;	too big	cluster	number
DOSBIOS:2066		     cmp     ax, 0FF6h	     ; 4096-10
DOSBIOS:2066					     ; is this 16-bit fat?
DOSBIOS:2069		     jb	     short copymediaid ; no, small fat
DOSBIOS:206B		     or	     ds:fbigfat, 40h ; fbig
DOSBIOS:206B					     ; 16 bit fat
DOSBIOS:2070
DOSBIOS:2070 copymediaid:			     ; CODE XREF: sethard+28Cj
DOSBIOS:2070		     push    es
DOSBIOS:2071		     push    ds
DOSBIOS:2072		     pop     es
DOSBIOS:2073		     push    cs
DOSBIOS:2074		     pop     ds
DOSBIOS:2075		     assume ds:DOSBIOS
DOSBIOS:2075		     mov     bp, 751h	     ; mov_media_ids
DOSBIOS:2075					     ; at 2C7h:751h = 70h:2CC1h
DOSBIOS:2075					     ; copy filesys_id,	volume label
DOSBIOS:2078		     push    cs		     ; simulate	far call
DOSBIOS:2079		     call    call_bios_code
DOSBIOS:207C		     push    es
DOSBIOS:207D		     pop     ds
DOSBIOS:207E		     assume ds:nothing
DOSBIOS:207E		     pop     es
DOSBIOS:207F		     jmp     massage_bpb     ; now final check for bpb info
DOSBIOS:207F					     ; and return.
DOSBIOS:2082 ; ---------------------------------------------------------------------------
DOSBIOS:2082
DOSBIOS:2082 toobig_ret:			     ; CODE XREF: sethard+287j
DOSBIOS:2082		     or	     cs:fbigfat, 80h
DOSBIOS:2088		     jmp     goodret	     ; still drive letter is assigned
DOSBIOS:2088					     ; but useless. to big for
DOSBIOS:2088					     ; current pc dos fat file system
DOSBIOS:208B ; ---------------------------------------------------------------------------
DOSBIOS:208B
DOSBIOS:208B unknown:				     ; CODE XREF: sethard+175j
DOSBIOS:208B					     ; sethard+1A6j
DOSBIOS:208B		     or	     word ptr [di+23h],	200h ; [di+BDS.flags]
DOSBIOS:208B					     ; unformatted_media
DOSBIOS:208B					     ; Set unformatted media flag.
DOSBIOS:208B					     ; ;
DOSBIOS:208B					     ; the boot	signature may not be recognizable,
DOSBIOS:208B					     ; but we should try and read it anyway.
DOSBIOS:2090
DOSBIOS:2090 unknown3_0:			     ; CODE XREF: sethard:unknown3_0_jj
DOSBIOS:2090		     mov     dx, [di+1Dh]    ; skip setting unformatted_media bit
DOSBIOS:2090					     ; [di+BDS.totalsecs32+2]
DOSBIOS:2093		     mov     ax, [di+1Bh]    ; [di+BDS.totalsecs32]
DOSBIOS:2096		     mov     si, offset	disktable2
DOSBIOS:2099
DOSBIOS:2099 scan:				     ; CODE XREF: sethard+2CCj
DOSBIOS:2099		     cmp     dx, cs:[si]
DOSBIOS:209C		     jb	     short gotparm
DOSBIOS:209E		     ja	     short scan_next
DOSBIOS:20A0		     cmp     ax, cs:[si+2]
DOSBIOS:20A4		     jbe     short gotparm
DOSBIOS:20A6
DOSBIOS:20A6 scan_next:				     ; CODE XREF: sethard+2C1j
DOSBIOS:20A6		     add     si, 10	     ; 5*2
DOSBIOS:20A9		     jmp     short scan	     ; covers upto 512 mb media
DOSBIOS:20AB ; ---------------------------------------------------------------------------
DOSBIOS:20AB
DOSBIOS:20AB gotparm:				     ; CODE XREF: sethard+2BFj
DOSBIOS:20AB					     ; sethard+2C7j
DOSBIOS:20AB		     mov     cl, [si+8]	     ; fat size	for fbigfat flag
DOSBIOS:20AE		     or	     ds:fbigfat, cl
DOSBIOS:20B2		     mov     cx, cs:[si+4]   ; ch = number of sectors per cluster
DOSBIOS:20B2					     ; cl = log	base 2 of ch
DOSBIOS:20B6		     mov     dx, cs:[si+6]
DOSBIOS:20BA		     mov     [di+0Ch], dx    ; [di+BDS.direntries]
DOSBIOS:20BA					     ; save number of (root) dir entries
DOSBIOS:20BD		     mov     dx, [di+1Dh]    ; [di+BDS.totalsecs32+2]
DOSBIOS:20C0		     mov     ax, [di+1Bh]    ; [di+BDS.totalsecs32]
DOSBIOS:20C3		     mov     [di+8], ch	     ; [di+BDS.secperclus]
DOSBIOS:20C3					     ; save sectors per	cluster
DOSBIOS:20C6		     test    ds:fbigfat, 40h ; fbig
DOSBIOS:20C6					     ; if (fbigfat)
DOSBIOS:20CB		     jnz     short dobig     ; goto dobig; (16 bit fat)
DOSBIOS:20CD		     xor     bx, bx	     ; (12 bit fat)
DOSBIOS:20CF		     mov     bl, ch
DOSBIOS:20D1		     dec     bx
DOSBIOS:20D2		     add     bx, ax	     ; dx=0
DOSBIOS:20D4		     shr     bx, cl	     ; bx = 1+(bpb->maxsec+BDS.secperclus-1)/
DOSBIOS:20D6		     inc     bx		     ; BDS.secperclus
DOSBIOS:20D7		     and     bl, 0FEh	     ;	bx &= ~1; (=number of clusters)
DOSBIOS:20DA		     mov     si, bx
DOSBIOS:20DC		     shr     bx, 1
DOSBIOS:20DE		     add     bx, si
DOSBIOS:20E0		     add     bx, 511	     ; bx += 511 + bx/2
DOSBIOS:20E4		     shr     bh, 1	     ; bh >>= 1; (=bx/512)
DOSBIOS:20E6		     mov     [di+11h], bh    ; [di+BDS.fatsecs]
DOSBIOS:20E6					     ; save number of fat sectors
DOSBIOS:20E9		     jmp     short massage_bpb
DOSBIOS:20EB ; ---------------------------------------------------------------------------
DOSBIOS:20EB
DOSBIOS:20EB dobig:				     ; CODE XREF: sethard+2EEj
DOSBIOS:20EB		     mov     cl, 4	     ; 16 (2^4)	directory entries
DOSBIOS:20EB					     ; per sector
DOSBIOS:20ED		     push    dx		     ; save total sectors (high)
DOSBIOS:20EE		     mov     dx, [di+0Ch]    ; [di+BDS.direntries]
DOSBIOS:20F1		     shr     dx, cl	     ; root dir	sectors	= BDS.direntries / 16;
DOSBIOS:20F3		     sub     ax, dx
DOSBIOS:20F5		     pop     dx
DOSBIOS:20F6		     sbb     dx, 0	     ; dx:ax = total sectors - root dir	sectors
DOSBIOS:20F9		     sub     ax, 1
DOSBIOS:20FC		     sbb     dx, 0	     ; dx:ax = t - r - d
DOSBIOS:20FC					     ; total secs - reserved secs - root dir secs
DOSBIOS:20FF		     mov     bl, 2	     ; ;
DOSBIOS:20FF					     ; ; 29/12/2018 - Erdogan Tan (Retro DOS v4.0)
DOSBIOS:20FF					     ; ; 27/09/2022
DOSBIOS:20FF					     ; (Microsoft FAT32	File System Specification,
DOSBIOS:20FF					     ; December	2000, Page 21)
DOSBIOS:20FF					     ; TmpVal1 = DskSize - (BPB_ResvdSecCnt+RootrDirSectors)
DOSBIOS:20FF					     ; TmpVal2 = (256*BPB_SecPerClus)+BPB_NumFATs
DOSBIOS:20FF					     ; FATsz = (TmpVal1+(TmpVal2-1))/TmpVal2
DOSBIOS:20FF					     ; (If FATType == FAT16, BPB_FATSz16 = LOWORD(FATSz))
DOSBIOS:20FF					     ; ;
DOSBIOS:2101		     mov     bh, [di+8]	     ; [di+BDS.secperclus]
DOSBIOS:2101					     ; bx = 256	* BDS.secperclus + 2
DOSBIOS:2104		     add     ax, bx	     ; ax = t-r-d+256*spc+2
DOSBIOS:2106		     adc     dx, 0
DOSBIOS:2109		     sub     ax, 1	     ; ax = t-r-d+256*spc+1
DOSBIOS:210C		     sbb     dx, 0
DOSBIOS:210F		     div     bx		     ; BDS.fatsecs =
DOSBIOS:210F					     ; ceil((total-dir-res)/(256*BDS.secperclus+2))
DOSBIOS:2111		     mov     [di+11h], ax    ; [di+BDS.fatsecs]
DOSBIOS:2111					     ; number of fat sectors
DOSBIOS:2114		     mov     bl, ds:fbigfat
DOSBIOS:2118		     mov     [di+1Fh], bl    ; [di+BDS.fatsiz] ; fat size flag
DOSBIOS:211B		     push    ds
DOSBIOS:211C		     push    ds
DOSBIOS:211D		     pop     es
DOSBIOS:211E		     push    cs
DOSBIOS:211F		     pop     ds
DOSBIOS:2120		     assume ds:DOSBIOS
DOSBIOS:2120		     mov     bp, 5D9h	     ; clear_ids
DOSBIOS:2120					     ; at 2C7h:5D9h = 70h:2B49h
DOSBIOS:2123		     push    cs
DOSBIOS:2124		     call    call_bios_code
DOSBIOS:2127		     pop     ds
DOSBIOS:2128		     assume ds:nothing
DOSBIOS:2128
DOSBIOS:2128 massage_bpb:			     ; CODE XREF: sethard+2A2j
DOSBIOS:2128					     ; sethard+30Cj
DOSBIOS:2128		     mov     dx, [di+1Dh]    ; [di+BDS.totalsecs32+2]
DOSBIOS:212B		     mov     ax, [di+1Bh]    ; [di+BDS.totalsecs32]
DOSBIOS:212E		     cmp     dx, 0	     ; double word total sectors?
DOSBIOS:2131		     ja	     short goodret   ;	don't have to change it.
DOSBIOS:2133		     cmp     word ptr [di+19h],	0 ; [di+BDS.hiddensecs+2]
DOSBIOS:2137		     ja	     short goodret   ; don't have to change it.
DOSBIOS:2139		     add     ax, [di+17h]    ; [di+BDS.hiddensecs]
DOSBIOS:213C		     jb	     short goodret
DOSBIOS:213E		     mov     ax, [di+1Bh]    ; [di+BDS.totalsecs32]
DOSBIOS:2141		     mov     [di+0Eh], ax    ; [di+BDS.totalsecs16]
DOSBIOS:2144		     mov     word ptr [di+1Bh],	0 ; [di+BDS.totalsecs32]
DOSBIOS:2149
DOSBIOS:2149 goodret:				     ; CODE XREF: sethard+216j
DOSBIOS:2149					     ; sethard+2ABj ...
DOSBIOS:2149		     mov     bl, ds:fbigfat
DOSBIOS:214D		     mov     [di+1Fh], bl    ; [di+BDS.fatsiz]
DOSBIOS:214D					     ; set size	of fat on media
DOSBIOS:2150		     clc
DOSBIOS:2151
DOSBIOS:2151 ret_hard_err:			     ; CODE XREF: sethard+8Aj
DOSBIOS:2151		     pop     es
DOSBIOS:2152		     pop     ds
DOSBIOS:2153		     pop     bx
DOSBIOS:2154		     pop     di
DOSBIOS:2155		     retn
DOSBIOS:2155 sethard	     endp
DOSBIOS:2155
DOSBIOS:2156
DOSBIOS:2156 ; =============== S U B R O U T I N E =======================================
DOSBIOS:2156
DOSBIOS:2156
DOSBIOS:2156 cover_fdisk_bug proc near		     ; CODE XREF: sethard:try5p
DOSBIOS:2156		     push    ax		     ; If BPB_TOTALSECTORS + hidden sector = 10000h
DOSBIOS:2156					     ; then subtract 1 from BPB_TOTALSECTORS.
DOSBIOS:2157		     push    dx
DOSBIOS:2158		     push    si
DOSBIOS:2159		     cmp     cs:disksector+26h,	29h ; [disksector+EXT_BOOT.SIG]
DOSBIOS:2159					     ; EXT_BOOT_SIGNATURE
DOSBIOS:215F		     jz	     short cfb_retit ; if extended bpb,	then >=	pc dos 4.00
DOSBIOS:2161		     cmp     word ptr cs:[bx+7], 3031h ; '10' ; os2 1.0 = ibm 10.0
DOSBIOS:2167		     jnz     short cfb_chk_BPB_TOTALSECTORS
DOSBIOS:2169		     cmp     byte ptr cs:[bx+10], '0'
DOSBIOS:216E		     jnz     short cfb_retit
DOSBIOS:2170
DOSBIOS:2170 cfb_chk_BPB_TOTALSECTORS:		     ; CODE XREF: cover_fdisk_bug+11j
DOSBIOS:2170		     mov     si, 159h	     ; disksector+EXT_BOOT.BPB
DOSBIOS:2173		     cmp     word ptr cs:[si+8], 0 ; [cs:si+EBPB.TOTALSECTORS]
DOSBIOS:2173					     ; just to make sure.
DOSBIOS:2178		     jz	     short cfb_retit
DOSBIOS:217A		     mov     ax, cs:[si+8]   ; [cs:si+EBPB.TOTALSECTORS]
DOSBIOS:217E		     add     ax, cs:[si+11h] ; [cs:si+EBPB.HIDDENSECTORS]
DOSBIOS:2182		     jnb     short cfb_retit
DOSBIOS:2184		     jnz     short cfb_retit ; if carry	set and	ax=0
DOSBIOS:2186		     dec     word ptr cs:[si+8]	; 0 -> 0FFFFh
DOSBIOS:2186					     ; then decrease BPB_TOTALSECTORS by 1
DOSBIOS:218A		     sub     word ptr [di+1Bh],	1 ; [di+BDS.totalsecs32]
DOSBIOS:218E		     sbb     word ptr [di+1Dh],	0 ; [di+BDS.totalsecs32+2]
DOSBIOS:2192
DOSBIOS:2192 cfb_retit:				     ; CODE XREF: cover_fdisk_bug+9j
DOSBIOS:2192					     ; cover_fdisk_bug+18j ...
DOSBIOS:2192		     pop     si
DOSBIOS:2193		     pop     dx
DOSBIOS:2194		     pop     ax
DOSBIOS:2195		     retn
DOSBIOS:2195 cover_fdisk_bug endp
DOSBIOS:2195
DOSBIOS:2195 ; ---------------------------------------------------------------------------
DOSBIOS:2196 word2	     dw	2		     ; DATA XREF: setdrvparms+8Cr
DOSBIOS:2198 word3	     dw	3		     ; DATA XREF: setdrvparms+87r
DOSBIOS:219A word512	     dw	512		     ; DATA XREF: setdrvparms+93r
DOSBIOS:219C
DOSBIOS:219C ; =============== S U B R O U T I N E =======================================
DOSBIOS:219C
DOSBIOS:219C
DOSBIOS:219C setdrvparms     proc near		     ; CODE XREF: DOSBIOS:1D50p
DOSBIOS:219C		     xor     bx, bx
DOSBIOS:219E		     les     di, ds:start_bds ;	get first bds in list
DOSBIOS:21A2
DOSBIOS:21A2 _next_bds:				     ; CODE XREF: setdrvparms+B7j
DOSBIOS:21A2		     push    es
DOSBIOS:21A3		     push    di
DOSBIOS:21A4		     mov     bl, es:[di+22h] ; [es:di+BDS.formfactor]
DOSBIOS:21A8		     cmp     bl, 5	     ; ffHardFile
DOSBIOS:21AB		     jnz     short nothardff
DOSBIOS:21AD		     xor     dx, dx
DOSBIOS:21AF		     mov     ax, es:[di+0Eh] ; [es:di+BDS.totalsecs16]
DOSBIOS:21B3		     or	     ax, ax
DOSBIOS:21B5		     jnz     short get_ccyl
DOSBIOS:21B7		     mov     dx, es:[di+1Dh] ; [es:di+BDS.totalsecs32+2]
DOSBIOS:21BB		     mov     ax, es:[di+1Bh] ; [es:di+BDS.totalsecs32]
DOSBIOS:21BF
DOSBIOS:21BF get_ccyl:				     ; CODE XREF: setdrvparms+19j
DOSBIOS:21BF		     push    dx
DOSBIOS:21C0		     push    ax
DOSBIOS:21C1		     mov     ax, es:[di+15h] ; [es:di+BDS.heads]
DOSBIOS:21C5		     mul     word ptr es:[di+13h] ; [es:di+BDS.secpertrack]
DOSBIOS:21C5					     ; assume sectors per cyl. < 64k.
DOSBIOS:21C9		     mov     cx, ax	     ; cx has #	sectors	per cylinder
DOSBIOS:21CB		     pop     ax
DOSBIOS:21CC		     pop     dx		     ; dx:ax = total sectors
DOSBIOS:21CD		     push    ax
DOSBIOS:21CE		     mov     ax, dx
DOSBIOS:21D0		     xor     dx, dx
DOSBIOS:21D2		     div     cx
DOSBIOS:21D4		     mov     cs:temp_h,	ax   ; ax be 0 here.
DOSBIOS:21D8		     pop     ax
DOSBIOS:21D9		     div     cx		     ; div #sec	by sec/cyl to get # cyl.
DOSBIOS:21DB		     or	     dx, dx
DOSBIOS:21DD		     jz	     short no_cyl_rnd
DOSBIOS:21DF		     inc     ax		     ; round up
DOSBIOS:21E0
DOSBIOS:21E0 no_cyl_rnd:			     ; CODE XREF: setdrvparms+41j
DOSBIOS:21E0		     mov     es:[di+25h], ax ; [es:di+BDS.cylinders]
DOSBIOS:21E4		     push    es
DOSBIOS:21E5		     pop     ds
DOSBIOS:21E6		     lea     si, [di+6]	     ; [di+BDS.bytespersec]
DOSBIOS:21E6					     ; ds:si ->	bpb for	hard file
DOSBIOS:21E9		     jmp     short set_recbpb
DOSBIOS:21EB ; ---------------------------------------------------------------------------
DOSBIOS:21EB
DOSBIOS:21EB nothardff:				     ; CODE XREF: setdrvparms+Fj
DOSBIOS:21EB		     push    cs
DOSBIOS:21EC		     pop     ds
DOSBIOS:21ED		     assume ds:DOSBIOS
DOSBIOS:21ED		     cmp     cs:fakefloppydrv, 1 ; if fake floppy drive	variable is set
DOSBIOS:21ED					     ; then we don't have to handle this bds
DOSBIOS:21F3		     jz	     short go_to_next_bds
DOSBIOS:21F5		     cmp     bl, 7	     ; ffother
DOSBIOS:21F5					     ; special case "other" type of medium
DOSBIOS:21F8		     jnz     short not_process_other
DOSBIOS:21FA		     xor     dx, dx
DOSBIOS:21FC		     mov     ax, [di+25h]    ; [di+BDS.cylinders]
DOSBIOS:21FF		     mul     word ptr [di+36h] ; [di+BDS.rheads]
DOSBIOS:2202		     mul     word ptr [di+34h] ; [di+BDS.rsecpertrack]
DOSBIOS:2205		     mov     [di+2Fh], ax    ; [di+BDS.rtotalsecs16]
DOSBIOS:2208		     dec     ax
DOSBIOS:2209		     mov     dl, 1
DOSBIOS:220B
DOSBIOS:220B _again:				     ; CODE XREF: setdrvparms+78j
DOSBIOS:220B		     cmp     ax, 0FF6h	     ; 4096-10
DOSBIOS:220E		     jb	     short _@@
DOSBIOS:2210		     shr     ax, 1
DOSBIOS:2212		     shl     dl, 1
DOSBIOS:2214		     jmp     short _again
DOSBIOS:2216 ; ---------------------------------------------------------------------------
DOSBIOS:2216
DOSBIOS:2216 _@@:				     ; CODE XREF: setdrvparms+72j
DOSBIOS:2216		     cmp     dl, 1	     ; is it a small disk ?
DOSBIOS:2219		     jz	     short __@@	     ; yes, 224	root entries is	enuf
DOSBIOS:221B		     mov     word ptr [di+2Dh],	240 ; [di+BDS.rdirentries]
DOSBIOS:2220
DOSBIOS:2220 __@@:				     ; CODE XREF: setdrvparms+7Dj
DOSBIOS:2220		     mov     [di+29h], dl    ; [di+BDS.rsecperclus]
DOSBIOS:2220					     ;
DOSBIOS:2220					     ; logic to	get the	sectors/fat area.
DOSBIOS:2220					     ; fat entry is assumed to be 1.5 bytes
DOSBIOS:2223		     mul     cs:word3	     ; * 3
DOSBIOS:2228		     div     cs:word2	     ; / 2
DOSBIOS:222D		     xor     dx, dx
DOSBIOS:222F		     div     cs:word512	     ; / 512
DOSBIOS:2234		     inc     ax		     ; + 1
DOSBIOS:2235		     mov     [di+32h], ax    ; [di+BDS.rfatsecs]
DOSBIOS:2238		     jmp     short go_to_next_bds
DOSBIOS:223A ; ---------------------------------------------------------------------------
DOSBIOS:223A
DOSBIOS:223A not_process_other:			     ; CODE XREF: setdrvparms+5Cj
DOSBIOS:223A		     shl     bx, 1	     ; bx is word index	into table of bpbs
DOSBIOS:223C		     mov     si, offset	bpbtable
DOSBIOS:223F		     mov     si, [bx+si]     ; get address of bpb
DOSBIOS:2241
DOSBIOS:2241 set_recbpb:			     ; CODE XREF: setdrvparms+4Dj
DOSBIOS:2241		     lea     di, [di+27h]    ; [di+BDS.R_BPB]
DOSBIOS:2241					     ; es:di ->	recbpb
DOSBIOS:2244		     mov     cx, 25
DOSBIOS:2247		     rep movsb
DOSBIOS:2249
DOSBIOS:2249 go_to_next_bds:			     ; CODE XREF: setdrvparms+57j
DOSBIOS:2249					     ; setdrvparms+9Cj
DOSBIOS:2249		     pop     di
DOSBIOS:224A		     pop     es
DOSBIOS:224B		     les     di, es:[di]     ; [es:di+BDS.link]
DOSBIOS:224E		     cmp     di, 0FFFFh	     ; -1
DOSBIOS:2251		     jz	     short got_end_of_bds_chain
DOSBIOS:2253		     jmp     _next_bds
DOSBIOS:2256 ; ---------------------------------------------------------------------------
DOSBIOS:2256
DOSBIOS:2256 got_end_of_bds_chain:		     ; CODE XREF: setdrvparms+B5j
DOSBIOS:2256		     retn
DOSBIOS:2256 setdrvparms     endp
DOSBIOS:2256
DOSBIOS:2257
DOSBIOS:2257 ; =============== S U B R O U T I N E =======================================
DOSBIOS:2257
DOSBIOS:2257
DOSBIOS:2257 print_init	     proc near		     ; CODE XREF: DOSBIOS:1918p
DOSBIOS:2257					     ; DOSBIOS:191Dp ...
DOSBIOS:2257		     cbw
DOSBIOS:2258		     mov     dx, ax
DOSBIOS:225A		     mov     ah, 1
DOSBIOS:225C		     int     17h	     ; PRINTER - INITIALIZE
DOSBIOS:225C					     ; DX = printer port (0-3)
DOSBIOS:225C					     ; Return: AH = status
DOSBIOS:225E		     retn
DOSBIOS:225E print_init	     endp
DOSBIOS:225E
DOSBIOS:225F
DOSBIOS:225F ; =============== S U B R O U T I N E =======================================
DOSBIOS:225F
DOSBIOS:225F
DOSBIOS:225F aux_init	     proc near		     ; CODE XREF: DOSBIOS:1904p
DOSBIOS:225F					     ; DOSBIOS:1909p ...
DOSBIOS:225F		     cbw
DOSBIOS:2260		     mov     dx, ax
DOSBIOS:2262		     mov     al, 0A3h	     ; RSINIT ;	0A3h
DOSBIOS:2262					     ; 2400,n,1,8 (msequ.inc)
DOSBIOS:2264		     mov     ah, 0
DOSBIOS:2266		     int     14h	     ; SERIAL I/O - INITIALIZE USART
DOSBIOS:2266					     ; AL = initializing parameters, DX	= port number (0-3)
DOSBIOS:2266					     ; Return: AH = RS-232 status code bits, AL	= modem	status bits
DOSBIOS:2268		     retn
DOSBIOS:2268 aux_init	     endp
DOSBIOS:2268
DOSBIOS:2269
DOSBIOS:2269 ; =============== S U B R O U T I N E =======================================
DOSBIOS:2269
DOSBIOS:2269
DOSBIOS:2269 domini	     proc near		     ; CODE XREF: DOSBIOS:1B9Bp
DOSBIOS:2269		     mov     dh, hnum	     ; mini disk initialization	routine.
DOSBIOS:2269					     ; called right after dohard
DOSBIOS:226D		     cmp     dh, 0
DOSBIOS:2270		     jz	     short dominiret ; no hard file? then exit.
DOSBIOS:2272		     mov     dl, 80h	     ; start with hardfile 80h
DOSBIOS:2274
DOSBIOS:2274 domini_loop:			     ; CODE XREF: domini+38j
DOSBIOS:2274		     push    dx
DOSBIOS:2275		     mov     rom_minidisk_num, dl
DOSBIOS:2279		     mov     ah, 8
DOSBIOS:227B		     int     13h	     ; DISK - DISK - GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)
DOSBIOS:227B					     ; DL = drive number
DOSBIOS:227B					     ; Return: CF set on error,	AH = status code, BL = drive type
DOSBIOS:227B					     ; DL = number of consecutive drives
DOSBIOS:227B					     ; DH = maximum value for head number, ES:DI -> drive parameter
DOSBIOS:227D		     inc     dh
DOSBIOS:227F		     xor     ax, ax
DOSBIOS:2281		     mov     al, dh
DOSBIOS:2283		     mov     mini_hdlim, ax  ; # of heads
DOSBIOS:2286		     and     cl, 3Fh
DOSBIOS:2289		     mov     al, cl
DOSBIOS:228B		     mov     mini_seclim, ax ; # of sectors/track
DOSBIOS:228E		     push    es
DOSBIOS:228F		     mov     dl, rom_minidisk_num
DOSBIOS:2293		     call    getboot	     ; read master boot	record into
DOSBIOS:2293					     ; initbootsegment:bootbias
DOSBIOS:2296		     jb	     short domininext
DOSBIOS:2298		     call    find_mini_partition
DOSBIOS:229B
DOSBIOS:229B domininext:			     ; CODE XREF: domini+2Dj
DOSBIOS:229B		     pop     es
DOSBIOS:229C		     pop     dx
DOSBIOS:229D		     inc     dl
DOSBIOS:229F		     dec     dh
DOSBIOS:22A1		     jnz     short domini_loop
DOSBIOS:22A3
DOSBIOS:22A3 dominiret:				     ; CODE XREF: domini+7j
DOSBIOS:22A3		     retn
DOSBIOS:22A3 domini	     endp
DOSBIOS:22A3
DOSBIOS:22A4
DOSBIOS:22A4 ; =============== S U B R O U T I N E =======================================
DOSBIOS:22A4
DOSBIOS:22A4
DOSBIOS:22A4 find_mini_partition proc near	     ; CODE XREF: domini+2Fp
DOSBIOS:22A4		     add     bx, 1C2h	     ; tries to	find every extended partition on a disk
DOSBIOS:22A4					     ; bx -> file system id
DOSBIOS:22A8
DOSBIOS:22A8 fmpnext:				     ; CODE XREF: find_mini_partition+11j
DOSBIOS:22A8					     ; find_mini_partition:fmpnextchainj
DOSBIOS:22A8		     cmp     byte ptr es:[bx], 5 ; 5 = extended	partition id.
DOSBIOS:22AC		     jz	     short fmpgot
DOSBIOS:22AE		     add     bx, 16
DOSBIOS:22B1		     cmp     bx, 402h	     ; 202h+bootbias
DOSBIOS:22B5		     jnz     short fmpnext
DOSBIOS:22B7		     jmp     short fmpnextfound	; extended partition not found
DOSBIOS:22B9 ; ---------------------------------------------------------------------------
DOSBIOS:22B9
DOSBIOS:22B9 fmpgot:				     ; CODE XREF: find_mini_partition+8j
DOSBIOS:22B9		     call    dmax_check	     ; check for drvmax	already	26
DOSBIOS:22BC		     jnb     short fmpnextfound	; done if too many
DOSBIOS:22BE		     mov     di, end_of_bdss ; get next	free bds
DOSBIOS:22C2		     mov     word ptr [di+47h],	1 ; [di+BDS.bdsm_ismini]
DOSBIOS:22C7		     or	     word ptr [di+23h],	1 ; [di+BDS.flags]
DOSBIOS:22C7					     ; fNon_Removable
DOSBIOS:22CB		     mov     byte ptr [di+22h],	5 ; [di+BDS.formfactor]
DOSBIOS:22CB					     ; ffHardFile
DOSBIOS:22CF		     mov     fbigfat, 0	     ; assume 12 bit fat.
DOSBIOS:22D4		     mov     ax, mini_hdlim
DOSBIOS:22D7		     mov     [di+15h], ax    ; [di+BDS.heads]
DOSBIOS:22DA		     mov     ax, mini_seclim
DOSBIOS:22DD		     mov     [di+13h], ax    ; [di+BDS.secpertrack]
DOSBIOS:22E0		     mov     al, rom_minidisk_num
DOSBIOS:22E3		     mov     [di+4], al	     ; [di+BDS.drivenum]
DOSBIOS:22E3					     ; set physical number
DOSBIOS:22E6		     mov     al, drvmax
DOSBIOS:22E9		     mov     [di+5], al	     ; [di+BDS.drivelet]
DOSBIOS:22E9					     ; set logical number
DOSBIOS:22EC		     cmp     word ptr es:[bx+10], 0
DOSBIOS:22F1		     ja	     short fmpgot_cont
DOSBIOS:22F3		     cmp     word ptr es:[bx+8], 64 ; with current bpb,
DOSBIOS:22F3					     ; only lower word is meaningful.
DOSBIOS:22F8		     jb	     short fmpnextfound
DOSBIOS:22FA
DOSBIOS:22FA fmpgot_cont:			     ; CODE XREF: find_mini_partition+4Dj
DOSBIOS:22FA		     sub     bx, 4	     ; let bx point to the start of the	entry
DOSBIOS:22FD		     mov     dh, es:[bx+2]   ; cylinder
DOSBIOS:2301		     and     dh, 0C0h	     ; get higher bits of cyl
DOSBIOS:2304		     rol     dh, 1
DOSBIOS:2306		     rol     dh, 1
DOSBIOS:2308		     mov     dl, es:[bx+3]   ; cyl byte
DOSBIOS:230C		     mov     [di+49h], dx    ; [di+BDS.bdsm_hidden_trks]
DOSBIOS:230C					     ; set hidden trks
DOSBIOS:230F		     mov     cx, es:[bx+2]   ; cylinder,cylinder/sector
DOSBIOS:2313		     mov     dh, es:[bx+1]   ; head
DOSBIOS:2317		     mov     dl, rom_minidisk_num
DOSBIOS:231B		     mov     bx, 200h	     ; bootbias
DOSBIOS:231E		     mov     ax, 201h
DOSBIOS:2321		     int     13h	     ; DISK - READ SECTORS INTO	MEMORY
DOSBIOS:2321					     ; AL = number of sectors to read, CH = track, CL =	sector
DOSBIOS:2321					     ; DH = head, DL = drive, ES:BX -> buffer to fill
DOSBIOS:2321					     ; Return: CF set on error,	AH = status, AL	= number of sectors read
DOSBIOS:2323		     jb	     short fmpnextfound
DOSBIOS:2325		     mov     bx, 3C2h	     ; 1C2h+bootbias
DOSBIOS:2328		     push    es
DOSBIOS:2329		     call    setmini	     ; install a mini disk.
DOSBIOS:2329					     ; bx value	saved.
DOSBIOS:232C		     pop     es
DOSBIOS:232D		     jb	     short fmpnextchain
DOSBIOS:232F		     call    xinstall_bds
DOSBIOS:2332
DOSBIOS:2332 fmpnextchain:			     ; CODE XREF: find_mini_partition+89j
DOSBIOS:2332		     jmp     fmpnext	     ; let's find out
DOSBIOS:2332					     ; if we have any chained partition
DOSBIOS:2335 ; ---------------------------------------------------------------------------
DOSBIOS:2335
DOSBIOS:2335 fmpnextfound:			     ; CODE XREF: find_mini_partition+13j
DOSBIOS:2335					     ; find_mini_partition+18j	...
DOSBIOS:2335		     retn
DOSBIOS:2335 find_mini_partition endp
DOSBIOS:2335
DOSBIOS:2336
DOSBIOS:2336 ; =============== S U B R O U T I N E =======================================
DOSBIOS:2336
DOSBIOS:2336
DOSBIOS:2336 setmini	     proc near		     ; CODE XREF: find_mini_partition+85p
DOSBIOS:2336		     push    di		     ; 'setmini' is called
DOSBIOS:2336					     ; from 'find_mini_partition' procedure
DOSBIOS:2337		     push    bx
DOSBIOS:2338		     push    ds
DOSBIOS:2339		     push    es
DOSBIOS:233A
DOSBIOS:233A setmini_1:				     ; CODE XREF: setmini+1Dj
DOSBIOS:233A		     cmp     byte ptr es:[bx], 1 ; FAT12 partition
DOSBIOS:233E		     jz	     short setmini_2
DOSBIOS:2340		     cmp     byte ptr es:[bx], 4 ; FAT16 partition
DOSBIOS:2344		     jz	     short setmini_2
DOSBIOS:2346		     cmp     byte ptr es:[bx], 6 ; FAT16 BIG partition
DOSBIOS:234A		     jz	     short setmini_2
DOSBIOS:234C		     add     bx, 16
DOSBIOS:234F		     cmp     bx, 402h	     ; 202h+bootbias
DOSBIOS:2353		     jnz     short setmini_1
DOSBIOS:2355		     stc
DOSBIOS:2356		     pop     es
DOSBIOS:2357		     pop     ds
DOSBIOS:2358		     assume ds:nothing
DOSBIOS:2358		     pop     bx
DOSBIOS:2359		     pop     di
DOSBIOS:235A		     retn
DOSBIOS:235B ; ---------------------------------------------------------------------------
DOSBIOS:235B
DOSBIOS:235B setmini_2:				     ; CODE XREF: setmini+8j
DOSBIOS:235B					     ; setmini+Ej ...
DOSBIOS:235B		     jmp     set2
DOSBIOS:235B setmini	     endp
DOSBIOS:235B
DOSBIOS:235E
DOSBIOS:235E ; =============== S U B R O U T I N E =======================================
DOSBIOS:235E
DOSBIOS:235E
DOSBIOS:235E dmax_check	     proc near		     ; CODE XREF: DOSBIOS:1B8Cp
DOSBIOS:235E					     ; DOSBIOS:1BB5p ...
DOSBIOS:235E		     cmp     ds:drvmax,	26   ; checks for drvmax < 26
DOSBIOS:2363		     jb	     short dmax_ok   ; return with carry if okay
DOSBIOS:2365		     push    es
DOSBIOS:2366		     mov     ax, 46Dh	     ; SYSINIT_SEG (SYSINIT segment)
DOSBIOS:2369		     mov     es, ax
DOSBIOS:236B		     assume es:nothing
DOSBIOS:236B		     mov     byte ptr es:3FFh, 1 ; [es:toomanydrivesflag]
DOSBIOS:236B					     ; set message flag
DOSBIOS:236B					     ; [SYSINIT+toomanydrivesflag]
DOSBIOS:2371		     pop     es
DOSBIOS:2372		     assume es:nothing
DOSBIOS:2372
DOSBIOS:2372 dmax_ok:				     ; CODE XREF: dmax_check+5j
DOSBIOS:2372		     retn
DOSBIOS:2372 dmax_check	     endp
DOSBIOS:2372
DOSBIOS:2373
DOSBIOS:2373 ; =============== S U B R O U T I N E =======================================
DOSBIOS:2373
DOSBIOS:2373
DOSBIOS:2373 xinstall_bds    proc near		     ; CODE XREF: DOSBIOS:1B91p
DOSBIOS:2373					     ; DOSBIOS:1BBAp ...
DOSBIOS:2373		     push    si		     ; link next bds (at ds:di)	into the chain
DOSBIOS:2374		     push    bx
DOSBIOS:2375		     mov     si, word ptr ds:start_bds ; get first bds
DOSBIOS:2379
DOSBIOS:2379 xinstall_bds_1:			     ; CODE XREF: xinstall_bds+Dj
DOSBIOS:2379		     cmp     word ptr [si], 0FFFFh ; is	this the last one?
DOSBIOS:237C		     jz	     short xinstall_bds_2 ;  skip ahead	if so
DOSBIOS:237E		     mov     si, [si]	     ; [si+BDS.link]
DOSBIOS:237E					     ; chain through list
DOSBIOS:2380		     jmp     short xinstall_bds_1
DOSBIOS:2382 ; ---------------------------------------------------------------------------
DOSBIOS:2382
DOSBIOS:2382 xinstall_bds_2:			     ; CODE XREF: xinstall_bds+9j
DOSBIOS:2382		     mov     [si], di	     ; [si+BDS.link]
DOSBIOS:2384		     mov     word ptr [si+2], ds ; [si+BDS.link+2]
DOSBIOS:2387		     mov     word ptr [di], 0FFFFh ; mov word [di+BDS.link], -1
DOSBIOS:2387					     ; make sure it is a null ptr.
DOSBIOS:238B		     mov     word ptr [di+2], ds ; [di+BDS.link+2]
DOSBIOS:238B					     ; might as	well plug segment
DOSBIOS:238E		     lea     bx, [di+6]	     ; [di+BDS.BPB]
DOSBIOS:2391		     mov     si, ds:last_dskdrv_table
DOSBIOS:2395		     mov     [si], bx
DOSBIOS:2397		     add     ds:last_dskdrv_table, 2
DOSBIOS:239C		     inc     ds:drvmax
DOSBIOS:23A0		     add     ds:end_of_bdss, 100 ; BDS.size = 100
DOSBIOS:23A5		     pop     bx
DOSBIOS:23A6		     pop     si
DOSBIOS:23A7		     retn
DOSBIOS:23A7 xinstall_bds    endp
DOSBIOS:23A7
DOSBIOS:23A8
DOSBIOS:23A8 ; =============== S U B R O U T I N E =======================================
DOSBIOS:23A8
DOSBIOS:23A8
DOSBIOS:23A8 cmos_clock_read proc near		     ; CODE XREF: DOSBIOS:1A1Cp
DOSBIOS:23A8		     push    ax
DOSBIOS:23A9		     push    cx
DOSBIOS:23AA		     push    dx
DOSBIOS:23AB		     push    bp
DOSBIOS:23AC		     xor     bp, bp
DOSBIOS:23AE
DOSBIOS:23AE loop_clock:			     ; CODE XREF: cmos_clock_read+23j
DOSBIOS:23AE		     xor     cx, cx
DOSBIOS:23B0		     xor     dx, dx
DOSBIOS:23B2		     mov     ah, 2
DOSBIOS:23B4		     int     1Ah	     ; CLOCK - READ REAL TIME CLOCK (AT,XT286,CONV,PS)
DOSBIOS:23B4					     ; Return: CH = hours in BCD
DOSBIOS:23B4					     ; CL = minutes in BCD
DOSBIOS:23B4					     ; DH = seconds in BCD
DOSBIOS:23B6		     cmp     cx, 0
DOSBIOS:23B9		     jnz     short clock_present
DOSBIOS:23BB		     cmp     dx, 0
DOSBIOS:23BE		     jnz     short clock_present
DOSBIOS:23C0		     cmp     bp, 1	     ; read again after	a slight delay,	in case	clock
DOSBIOS:23C3		     jz	     short no_readdate ; was at	zero setting.
DOSBIOS:23C5		     inc     bp		     ; only perform delay once.
DOSBIOS:23C6		     mov     cx, 4000h	     ; 16384
DOSBIOS:23C9
DOSBIOS:23C9 delay:				     ; CODE XREF: cmos_clock_read:delayj
DOSBIOS:23C9		     loop    delay
DOSBIOS:23CB		     jmp     short loop_clock
DOSBIOS:23CD ; ---------------------------------------------------------------------------
DOSBIOS:23CD
DOSBIOS:23CD clock_present:			     ; CODE XREF: cmos_clock_read+11j
DOSBIOS:23CD					     ; cmos_clock_read+16j
DOSBIOS:23CD		     mov     cs:havecmosclock, 1 ; set the flag	for cmos clock
DOSBIOS:23D3		     call    cmosck	     ; reset cmos clock	rate that may be
DOSBIOS:23D3					     ; possibly	destroyed by cp	dos and
DOSBIOS:23D3					     ; post routine did	not restore that.
DOSBIOS:23D6		     push    si
DOSBIOS:23D7		     call    read_real_date  ; read real-time clock for	date
DOSBIOS:23DA		     cli
DOSBIOS:23DB		     mov     ds:daycnt,	si   ; set system date
DOSBIOS:23DF		     sti
DOSBIOS:23E0		     pop     si
DOSBIOS:23E1
DOSBIOS:23E1 no_readdate:			     ; CODE XREF: cmos_clock_read+1Bj
DOSBIOS:23E1		     pop     bp
DOSBIOS:23E2		     pop     dx
DOSBIOS:23E3		     pop     cx
DOSBIOS:23E4		     pop     ax
DOSBIOS:23E5		     retn
DOSBIOS:23E5 cmos_clock_read endp
DOSBIOS:23E5
DOSBIOS:23E6 ; ---------------------------------------------------------------------------
DOSBIOS:23E6
DOSBIOS:23E6 cmosck:				     ; CODE XREF: cmos_clock_read+2Bp
DOSBIOS:23E6		     push    ax
DOSBIOS:23E7		     cmp     cs:model_byte, 0FCh
DOSBIOS:23ED		     jnz     short cmosck9   ; Exit if not an AT model
DOSBIOS:23EF		     cmp     cs:secondary_model_byte, 6	; Is it	06 for the industral AT	?
DOSBIOS:23F5		     jz	     short cmosck4   ; Go reset	CMOS periodic rate if 06
DOSBIOS:23F7		     cmp     cs:secondary_model_byte, 4	; Is it	00, 01,	02, or 03 ?
DOSBIOS:23FD		     jnb     short cmosck9
DOSBIOS:23FF
DOSBIOS:23FF cmosck4:				     ; CODE XREF: DOSBIOS:23F5j
DOSBIOS:23FF		     mov     al, 8Ah	     ; cmos_reg_a|nmi
DOSBIOS:23FF					     ; NMI disabled on return
DOSBIOS:2401		     mov     ah, 26h	     ; 00100110b
DOSBIOS:2401					     ; Set divider & rate selection
DOSBIOS:2403		     call    cmos_write
DOSBIOS:2406		     mov     al, 8Bh	     ; cmos_reg_b|nmi
DOSBIOS:2406					     ; NMI disabled on return
DOSBIOS:2408		     call    cmos_read
DOSBIOS:240B		     and     al, 7	     ; 00000111b
DOSBIOS:240B					     ; clear SET,PIE,AIE,UIE,SQWE
DOSBIOS:240D		     mov     ah, al
DOSBIOS:240F		     mov     al, 0Bh	     ; cmos_reg_b
DOSBIOS:240F					     ; NMI enabled on return
DOSBIOS:2411		     call    cmos_write
DOSBIOS:2414
DOSBIOS:2414 cmosck9:				     ; CODE XREF: DOSBIOS:23EDj
DOSBIOS:2414					     ; DOSBIOS:23FDj
DOSBIOS:2414		     pop     ax
DOSBIOS:2415		     retn
DOSBIOS:2416
DOSBIOS:2416 ; =============== S U B R O U T I N E =======================================
DOSBIOS:2416
DOSBIOS:2416
DOSBIOS:2416 cmos_read	     proc near		     ; CODE XREF: DOSBIOS:2408p
DOSBIOS:2416		     pushf
DOSBIOS:2417		     cli
DOSBIOS:2418		     push    bx
DOSBIOS:2419		     push    ax		     ; AL = cmos table address to be read
DOSBIOS:241A		     or	     al, 80h
DOSBIOS:241C		     out     70h, al	     ; CMOS Memory/RTC Index Register:
DOSBIOS:241C					     ; RTC Seconds
DOSBIOS:241E		     nop		     ; (undocumented delay needed)
DOSBIOS:241F		     in	     al, 71h	     ; CMOS Memory/RTC Data Register
DOSBIOS:2421		     mov     bx, ax
DOSBIOS:2423		     pop     ax
DOSBIOS:2424		     and     al, 80h
DOSBIOS:2426		     or	     al, 0Fh
DOSBIOS:2428		     out     70h, al	     ; CMOS Memory/RTC Index Register:
DOSBIOS:2428					     ; RTC Seconds
DOSBIOS:242A		     nop
DOSBIOS:242B		     in	     al, 71h	     ; CMOS Memory/RTC Data Register
DOSBIOS:242D		     mov     ax, bx
DOSBIOS:242F		     pop     bx
DOSBIOS:2430		     push    cs		     ; *place code segment in stack and
DOSBIOS:2431		     call    cmos_popf	     ; *handle popf for	b- level 80286
DOSBIOS:2434		     retn
DOSBIOS:2434 cmos_read	     endp
DOSBIOS:2434
DOSBIOS:2435 ; ---------------------------------------------------------------------------
DOSBIOS:2435
DOSBIOS:2435 cmos_popf:				     ; CODE XREF: cmos_read+1Bp
DOSBIOS:2435					     ; cmos_write+19p
DOSBIOS:2435		     iret		     ; popf for	level b- parts
DOSBIOS:2435					     ; return far and restore flags
DOSBIOS:2436
DOSBIOS:2436 ; =============== S U B R O U T I N E =======================================
DOSBIOS:2436
DOSBIOS:2436
DOSBIOS:2436 cmos_write	     proc near		     ; CODE XREF: DOSBIOS:2403p
DOSBIOS:2436					     ; DOSBIOS:2411p
DOSBIOS:2436		     pushf
DOSBIOS:2437		     push    ax
DOSBIOS:2438		     cli
DOSBIOS:2439		     push    ax		     ; save user nmi state
DOSBIOS:243A		     or	     al, 80h	     ; disable nmi for us
DOSBIOS:243C		     out     70h, al	     ; CMOS Memory/RTC Index Register:
DOSBIOS:243C					     ; RTC Seconds
DOSBIOS:243E		     nop
DOSBIOS:243F		     mov     al, ah
DOSBIOS:2441		     out     71h, al	     ; CMOS Memory/RTC Data Register
DOSBIOS:2443		     pop     ax		     ; get user	nmi
DOSBIOS:2444		     and     al, 80h
DOSBIOS:2446		     or	     al, 0Fh
DOSBIOS:2448		     out     70h, al	     ; CMOS Memory/RTC Index Register:
DOSBIOS:2448					     ; RTC Seconds
DOSBIOS:244A		     nop
DOSBIOS:244B		     in	     al, 71h	     ; CMOS Memory/RTC Data Register
DOSBIOS:244D		     pop     ax
DOSBIOS:244E		     push    cs		     ; *place code segment in stack and
DOSBIOS:244F		     call    cmos_popf	     ; *handle popf for	b- level 80286
DOSBIOS:2452		     retn
DOSBIOS:2452 cmos_write	     endp
DOSBIOS:2452
DOSBIOS:2453 ; ---------------------------------------------------------------------------
DOSBIOS:2453
DOSBIOS:2453 getclus:				     ; CODE XREF: DOSBIOS:1D3Ap
DOSBIOS:2453		     push    cx		     ; read in a cluster at a specified	address
DOSBIOS:2453					     ; cx = sectors per	cluster
DOSBIOS:2453					     ; bx = cluster to read
DOSBIOS:2453					     ; es:di = load location
DOSBIOS:2454		     push    di
DOSBIOS:2455		     mov     cs:doscnt,	cx
DOSBIOS:245A		     mov     ax, bx
DOSBIOS:245C		     dec     ax
DOSBIOS:245D		     dec     ax
DOSBIOS:245E		     mul     cx		     ; convert to logical sector
DOSBIOS:245E					     ; dx:ax = matching	logical	sector number starting
DOSBIOS:245E					     ;	       from the	data sector
DOSBIOS:2460		     add     ax, cs:bios_l
DOSBIOS:2465		     adc     dx, cs:bios_h   ;
DOSBIOS:2465					     ; dx:ax = first logical sector to read
DOSBIOS:246A
DOSBIOS:246A unpack:				     ; CODE XREF: DOSBIOS:24D9j
DOSBIOS:246A		     push    ds
DOSBIOS:246B		     push    ax
DOSBIOS:246C		     push    bx
DOSBIOS:246D		     mov     si, cs:fatloc
DOSBIOS:2472		     mov     ds, si
DOSBIOS:2474		     mov     si, bx	     ; next cluster
DOSBIOS:2476		     test    cs:fbigfat, 40h ; fbig
DOSBIOS:2476					     ; 16 bit fat?
DOSBIOS:247C		     jnz     short unpack16  ; yes
DOSBIOS:247E		     shr     si, 1	     ; 12 bit fat. si=si/2
DOSBIOS:247E					     ; si = clus + clus/2
DOSBIOS:2480		     add     si, bx	     ;
DOSBIOS:2480					     ; (si = byte offset of the	cluster	in the FAT)
DOSBIOS:2482		     push    dx
DOSBIOS:2483		     xor     dx, dx
DOSBIOS:2485		     call    get_fat_sector
DOSBIOS:2488		     pop     dx
DOSBIOS:2489		     mov     ax, [bx]	     ; save it into ax
DOSBIOS:2489					     ; if not a	splitted fat, check even-odd.
DOSBIOS:248B		     jnz     short even_odd
DOSBIOS:248D		     mov     al, [bx]	     ; splitted	fat
DOSBIOS:248F		     mov     byte ptr cs:temp_cluster, al
DOSBIOS:2493		     inc     si		     ; (next byte)
DOSBIOS:2494		     push    dx
DOSBIOS:2495		     xor     dx, dx
DOSBIOS:2497		     call    get_fat_sector
DOSBIOS:249A		     pop     dx
DOSBIOS:249B		     mov     al, ds:0
DOSBIOS:249E		     mov     byte ptr cs:temp_cluster+1, al
DOSBIOS:24A2		     mov     ax, cs:temp_cluster
DOSBIOS:24A6
DOSBIOS:24A6 even_odd:				     ; CODE XREF: DOSBIOS:248Bj
DOSBIOS:24A6		     pop     bx		     ; restore old fat entry value
DOSBIOS:24A7		     push    bx		     ; save it right away.
DOSBIOS:24A8		     shr     bx, 1	     ; was it even or odd?
DOSBIOS:24AA		     jnb     short havclus   ; it was even.
DOSBIOS:24AC		     shr     ax, 1	     ; odd. massage fat	value and keep
DOSBIOS:24AC					     ; the highest 12 bits.
DOSBIOS:24AE		     shr     ax, 1
DOSBIOS:24B0		     shr     ax, 1
DOSBIOS:24B2		     shr     ax, 1
DOSBIOS:24B4
DOSBIOS:24B4 havclus:				     ; CODE XREF: DOSBIOS:24AAj
DOSBIOS:24B4		     mov     bx, ax	     ; now bx =	new fat	entry.
DOSBIOS:24B6		     and     bx, 0FFFh	     ; keep low	12 bits.
DOSBIOS:24BA		     jmp     short unpackx
DOSBIOS:24BC ; ---------------------------------------------------------------------------
DOSBIOS:24BC
DOSBIOS:24BC unpack16:				     ; CODE XREF: DOSBIOS:247Cj
DOSBIOS:24BC		     push    dx
DOSBIOS:24BD		     xor     dx, dx
DOSBIOS:24BF		     shl     si, 1	     ; extend to 32 bit	offset
DOSBIOS:24C1		     adc     dx, 0
DOSBIOS:24C4		     call    get_fat_sector
DOSBIOS:24C7		     pop     dx
DOSBIOS:24C8		     mov     bx, [bx]	     ;
DOSBIOS:24C8					     ; bx = new	fat entry.
DOSBIOS:24CA ; START OF	FUNCTION CHUNK FOR getclus
DOSBIOS:24CA
DOSBIOS:24CA unpackx:				     ; CODE XREF: DOSBIOS:24BAj
DOSBIOS:24CA		     pop     si		     ; restore old bx value into si
DOSBIOS:24CB		     pop     ax		     ; restore logical sector (low)
DOSBIOS:24CC		     pop     ds
DOSBIOS:24CD		     sub     si, bx
DOSBIOS:24CF		     cmp     si, -1	     ; one apart?
DOSBIOS:24D2		     jnz     short getcl2
DOSBIOS:24D4		     add     cs:doscnt,	cx
DOSBIOS:24D9		     jmp     short unpack
DOSBIOS:24DB ; ---------------------------------------------------------------------------
DOSBIOS:24DB
DOSBIOS:24DB getcl2:				     ; CODE XREF: DOSBIOS:24D2j
DOSBIOS:24DB		     push    bx
DOSBIOS:24DC		     push    dx		     ; sector to read (high)
DOSBIOS:24DD		     push    ax		     ; sector to read (low)
DOSBIOS:24DE		     mov     ax, cs:drvfat   ; get drive and fat spec
DOSBIOS:24E2		     mov     cx, cs:doscnt
DOSBIOS:24E7		     pop     dx		     ; sector to read for diskrd (low)
DOSBIOS:24E8		     pop     cs:start_sec_h  ; sector to read for diskrd (high)
DOSBIOS:24ED		     push    ds
DOSBIOS:24EE		     push    cs
DOSBIOS:24EF		     pop     ds
DOSBIOS:24F0		     assume ds:DOSBIOS
DOSBIOS:24F0		     push    cs		     ; simulate	far call
DOSBIOS:24F1		     mov     bp, 8E5h	     ; offset diskrd
DOSBIOS:24F1					     ; 2C7h:8E5h = 70h:2E55h
DOSBIOS:24F4		     call    call_bios_code
DOSBIOS:24F7		     pop     ds
DOSBIOS:24F8		     assume ds:nothing
DOSBIOS:24F8		     pop     bx
DOSBIOS:24F9		     pop     di
DOSBIOS:24FA		     mov     ax, cs:doscnt   ; get number of sectors read
DOSBIOS:24FE		     xchg    ah, al	     ; multiply	by 256
DOSBIOS:2500		     shl     ax, 1	     ; times 2 equal 512
DOSBIOS:2502		     add     di, ax	     ; update load location
DOSBIOS:2504		     pop     cx		     ; restore sectors/cluster
DOSBIOS:2505		     retn
DOSBIOS:2505 ; END OF FUNCTION CHUNK FOR getclus
DOSBIOS:2506
DOSBIOS:2506 ; =============== S U B R O U T I N E =======================================
DOSBIOS:2506
DOSBIOS:2506
DOSBIOS:2506 get_fat_sector  proc near		     ; CODE XREF: DOSBIOS:2485p
DOSBIOS:2506					     ; DOSBIOS:2497p ...
DOSBIOS:2506		     push    ax		     ; find and	read the corresponding fat sector into ds:0
DOSBIOS:2507		     push    cx
DOSBIOS:2508		     push    di
DOSBIOS:2509		     push    si
DOSBIOS:250A		     push    es
DOSBIOS:250B		     push    ds
DOSBIOS:250C		     mov     ax, si
DOSBIOS:250E		     mov     cx, cs:md_sectorsize ; 512
DOSBIOS:2513		     div     cx		     ; ax=sector number, dx = offset
DOSBIOS:2515		     nop		     ;
DOSBIOS:2515					     ; Get rid of the assumption that
DOSBIOS:2515					     ; there is	only one reserved sector
DOSBIOS:2516		     push    es
DOSBIOS:2517		     push    ds
DOSBIOS:2518		     push    di
DOSBIOS:2519		     push    ax
DOSBIOS:251A		     push    cs
DOSBIOS:251B		     pop     ds
DOSBIOS:251C		     assume ds:DOSBIOS
DOSBIOS:251C		     mov     ax, cs:drvfat   ; get drive # and FAT id
DOSBIOS:2520		     mov     bp, 4D7h	     ; setdrive
DOSBIOS:2520					     ; at 2C7h:4D7h = 70h:2A47h
DOSBIOS:2523		     push    cs		     ; simulate	far call
DOSBIOS:2524		     call    call_bios_code  ; get bds for drive
DOSBIOS:2527		     pop     ax		     ; (sector number -without reserved	and hidden sectors-)
DOSBIOS:2528		     add     ax, es:[di+9]   ; [es:di+BDS.resectors]
DOSBIOS:2528					     ; add #reserved_sectors
DOSBIOS:252C		     pop     di
DOSBIOS:252D		     pop     ds
DOSBIOS:252E		     assume ds:nothing
DOSBIOS:252E		     pop     es
DOSBIOS:252F		     cmp     ax, cs:last_fat_sec_num
DOSBIOS:2534		     jz	     short gfs_split_chk ; don't need to read it again.
DOSBIOS:2536		     mov     cs:last_fat_sec_num, ax ; sector number (in the partition,	without	hidden sectors)
DOSBIOS:253A		     push    dx
DOSBIOS:253B		     mov     cs:start_sec_h, 0 ; prepare to read the fat sector
DOSBIOS:253B					     ; start_sec_h is always 0 for fat sector.
DOSBIOS:2542		     mov     dx, ax
DOSBIOS:2544		     mov     cx, 1	     ; 1 sector	read
DOSBIOS:2547		     mov     ax, cs:drvfat
DOSBIOS:254B		     push    ds
DOSBIOS:254C		     pop     es
DOSBIOS:254D		     xor     di, di	     ; es:di ->	fatloc segment:0
DOSBIOS:254F		     push    ds
DOSBIOS:2550		     push    cs
DOSBIOS:2551		     pop     ds
DOSBIOS:2552		     assume ds:DOSBIOS
DOSBIOS:2552		     push    cs		     ; simulate	far call
DOSBIOS:2553		     mov     bp, 8E5h	     ; offset diskrd
DOSBIOS:2553					     ; 2C7h:8E5h = 70h:2E55h
DOSBIOS:2556		     call    call_bios_code
DOSBIOS:2559		     pop     ds
DOSBIOS:255A		     assume ds:nothing
DOSBIOS:255A		     pop     dx
DOSBIOS:255B		     mov     cx, cs:md_sectorsize ; 512
DOSBIOS:2560
DOSBIOS:2560 gfs_split_chk:			     ; CODE XREF: get_fat_sector+2Ej
DOSBIOS:2560		     dec     cx		     ; 511
DOSBIOS:2561		     cmp     dx, cx	     ; if offset points	to the
DOSBIOS:2561					     ; last byte of this sector,
DOSBIOS:2561					     ; then splitted entry.
DOSBIOS:2563		     mov     bx, dx	     ; set bx to dx
DOSBIOS:2565		     pop     ds
DOSBIOS:2566		     pop     es
DOSBIOS:2567		     pop     si
DOSBIOS:2568		     pop     di
DOSBIOS:2569		     pop     cx
DOSBIOS:256A		     pop     ax
DOSBIOS:256B		     retn
DOSBIOS:256B get_fat_sector  endp
DOSBIOS:256B
DOSBIOS:256B ; ---------------------------------------------------------------------------
DOSBIOS:256C		     db	4 dup(0)
DOSBIOS:2570 DOSBIOSEG_27Ch  db	30h dup(0)	     ; SEGMENT 2C7h (2C70h-700h=2570h)
DOSBIOS:25A0 BiosDataWord    dw	70h
DOSBIOS:25A2 ; ---------------------------------------------------------------------------
DOSBIOS:25A2
DOSBIOS:25A2 _seg_reinit:			     ; [cs:BiosDataWord]
DOSBIOS:25A2		     mov     es, word ptr cs:aCon+3 ; at 2C7h:30h or 70h:25A0h
DOSBIOS:25A7		     assume es:nothing
DOSBIOS:25A7		     mov     di, (offset cdev+2)
DOSBIOS:25AA		     mov     cx, 4	     ; (end_BC_entries - cdev)/4
DOSBIOS:25AD
DOSBIOS:25AD _seg_reinit_1:			     ; CODE XREF: DOSBIOS:25B0j
DOSBIOS:25AD		     stosw		     ; modify Bios_Code	entry points
DOSBIOS:25AE		     inc     di
DOSBIOS:25AF		     inc     di
DOSBIOS:25B0		     loop    _seg_reinit_1
DOSBIOS:25B2		     retf
DOSBIOS:25B3 ; ---------------------------------------------------------------------------
DOSBIOS:25B3
DOSBIOS:25B3 chardev_entry:			     ; 0070h:25B3h = 02C7h:0043h
DOSBIOS:25B3		     push    si
DOSBIOS:25B4		     push    ax
DOSBIOS:25B5		     push    cx
DOSBIOS:25B6		     push    dx
DOSBIOS:25B7		     push    di
DOSBIOS:25B8		     push    bp
DOSBIOS:25B9		     push    ds
DOSBIOS:25BA		     push    es
DOSBIOS:25BB		     push    bx
DOSBIOS:25BC		     mov     bp, sp
DOSBIOS:25BE		     mov     si, [bp+18]     ; get return address (dispatch table)
DOSBIOS:25C1		     mov     ds, word ptr cs:aCon+3 ; [cs:Bios_Data_Word]
DOSBIOS:25C6		     assume ds:nothing
DOSBIOS:25C6		     mov     ax, [si+2]	     ; get the device number if	present
DOSBIOS:25C9		     mov     byte ptr ds:auxnum, al
DOSBIOS:25CC		     mov     ds:printdev, ah
DOSBIOS:25D0		     mov     si, [si]	     ; point to	the device dispatch table
DOSBIOS:25D2		     les     bx, ds:ptrsav   ; get pointer to i/o packet
DOSBIOS:25D6		     assume es:nothing
DOSBIOS:25D6		     mov     al, es:[bx+1]   ; [es:bx+unit]  ; al = unit code
DOSBIOS:25DA		     mov     ah, es:[bx+13]  ; [es:bx+media] ; ah = media descrip
DOSBIOS:25DE		     mov     cx, es:[bx+18]  ; [es:bx+count] ; cx = count
DOSBIOS:25E2		     mov     dx, es:[bx+20]  ; [es:bx+start] ; dx = start sector
DOSBIOS:25E6		     cmp     si, 4A2h	     ; dsktbl
DOSBIOS:25E6					     ; at 2C7h:4A2h = 70h:2A12h
DOSBIOS:25EA		     jnz     short no_sector32_mapping
DOSBIOS:25EC		     mov     ds:start_sec_h, 0 ; initialize to 0
DOSBIOS:25F2		     cmp     dx, 0FFFFh
DOSBIOS:25F5		     jnz     short no_sector32_mapping
DOSBIOS:25F7		     mov     dx, es:[bx+28]  ; [es:bx+start_h]
DOSBIOS:25F7					     ; 32 bits dsk req
DOSBIOS:25FB		     mov     ds:start_sec_h, dx	; start_sec_h =	packet.start_h
DOSBIOS:25FF		     mov     dx, es:[bx+26]  ; [es:bx+start_l]
DOSBIOS:25FF					     ; dx = packet.start_l
DOSBIOS:2603
DOSBIOS:2603 no_sector32_mapping:		     ; CODE XREF: DOSBIOS:25EAj
DOSBIOS:2603					     ; DOSBIOS:25F5j
DOSBIOS:2603		     xchg    ax, di
DOSBIOS:2604		     mov     al, es:[bx+2]   ; [es:bx+cmd]
DOSBIOS:2608		     cmp     al, cs:[si]
DOSBIOS:260B		     jnb     short command_error
DOSBIOS:260D		     cbw		     ; note that al <= 15 means	ok
DOSBIOS:260E		     shl     ax, 1
DOSBIOS:2610		     add     si, ax
DOSBIOS:2612		     xchg    ax, di
DOSBIOS:2613		     les     di, es:[bx+14]  ; [es:bx+trans]
DOSBIOS:2617		     cld
DOSBIOS:2618		     call    word ptr cs:[si+1]
DOSBIOS:261C		     jb	     short already_got_ah_status
DOSBIOS:261E		     mov     ah, 1
DOSBIOS:2620
DOSBIOS:2620 already_got_ah_status:		     ; CODE XREF: DOSBIOS:261Cj
DOSBIOS:2620					     ; DOSBIOS:263Cj
DOSBIOS:2620		     mov     ds, word ptr cs:aCon+3 ; [cs:Bios_Data_Word]
DOSBIOS:2620					     ; cas note: shouldn't be needed!
DOSBIOS:2625		     lds     bx, ds:ptrsav
DOSBIOS:2629		     assume ds:nothing
DOSBIOS:2629		     mov     [bx+3], ax	     ; [bx+status]
DOSBIOS:2629					     ; mark operation complete
DOSBIOS:262C		     pop     bx
DOSBIOS:262D		     pop     es
DOSBIOS:262E		     pop     ds
DOSBIOS:262F		     pop     bp
DOSBIOS:2630		     pop     di
DOSBIOS:2631		     pop     dx
DOSBIOS:2632		     pop     cx
DOSBIOS:2633		     pop     ax
DOSBIOS:2634		     pop     si
DOSBIOS:2635		     add     sp, 2	     ; get rid of fake return address
DOSBIOS:2638
DOSBIOS:2638 bc_retf:
DOSBIOS:2638		     retf
DOSBIOS:2639 ; ---------------------------------------------------------------------------
DOSBIOS:2639
DOSBIOS:2639 command_error:			     ; CODE XREF: DOSBIOS:260Bj
DOSBIOS:2639		     call    bc_cmderr
DOSBIOS:263C		     jmp     short already_got_ah_status
DOSBIOS:263C ; ---------------------------------------------------------------------------
DOSBIOS:263E		     db	7 dup(0)
DOSBIOS:2645 ; ---------------------------------------------------------------------------
DOSBIOS:2645
DOSBIOS:2645 bc_cmderr:				     ; CODE XREF: DOSBIOS:command_errorp
DOSBIOS:2645					     ; DOSBIOS:prnfuncerrj ...
DOSBIOS:2645		     mov     al, 3	     ; 2C7h:D5h	= 70h:2645h
DOSBIOS:2645					     ; unknown command error
DOSBIOS:2647
DOSBIOS:2647 ; =============== S U B R O U T I N E =======================================
DOSBIOS:2647
DOSBIOS:2647
DOSBIOS:2647 bc_err_cnt	     proc near		     ; CODE XREF: DOSBIOS:prn_inputp
DOSBIOS:2647					     ; DOSBIOS:pmessgj	...
DOSBIOS:2647		     les     bx, ds:ptrsav
DOSBIOS:264B		     sub     es:[bx+18], cx  ; [es:bx+count]
DOSBIOS:264F		     mov     ah, 81h
DOSBIOS:2651		     stc
DOSBIOS:2652		     retn
DOSBIOS:2652 bc_err_cnt	     endp
DOSBIOS:2652
DOSBIOS:2652 ; ---------------------------------------------------------------------------
DOSBIOS:2653		     db	0
DOSBIOS:2654 con_table	     db	11		     ; 2C7h:0E4h = 70h:2654h
DOSBIOS:2654					     ; (((offset con_table_end)	- (offset con_table) - 1)/2)
DOSBIOS:2655		     dw	1FBh		     ; bc_exvec	at 2C7h:1FBh = 70h:276Bh
DOSBIOS:2655					     ; 00 init
DOSBIOS:2657		     dw	1FBh		     ; 01
DOSBIOS:2659		     dw	1FBh		     ; 02
DOSBIOS:265B		     dw	0D5h		     ; bc_exvec	at 2C7h:D5h = 70h:2645h
DOSBIOS:265B					     ; 03
DOSBIOS:265D		     dw	15Ch		     ; con_read	at 2C7h:15Ch = 70h:26CCh
DOSBIOS:265D					     ; 04
DOSBIOS:265F		     dw	19Fh		     ; con_rdnd	at 2C7h:19Fh = 70h:270Fh
DOSBIOS:265F					     ; 05
DOSBIOS:2661		     dw	1FBh		     ; 06
DOSBIOS:2663		     dw	209h		     ; con_flush at 2C7h:209h =	70h:2779h
DOSBIOS:2663					     ; 07
DOSBIOS:2665		     dw	1FDh		     ; con_writ	at 2C7h:1FDh = 70h:276Dh
DOSBIOS:2665					     ; 08
DOSBIOS:2667		     dw	1FDh		     ; 09
DOSBIOS:2669		     dw	1FBh		     ; 0A
DOSBIOS:266B prn_table	     db	26		     ; 2C7h:0FBh = 70h:266Bh
DOSBIOS:266B					     ; ((prn_table_end - prn_table) - 1)/2 ; 26
DOSBIOS:266C		     dw	1FBh		     ; bc_exvec
DOSBIOS:266E		     dw	1FBh		     ; 01
DOSBIOS:2670		     dw	1FBh		     ; 02
DOSBIOS:2672		     dw	0D5h		     ; bc_cmderr
DOSBIOS:2674		     dw	21Ah		     ; prn_input
DOSBIOS:2674					     ; 04 indicate zero	chars read
DOSBIOS:2676		     dw	1C8h		     ; z_bus_exit
DOSBIOS:2676					     ; 05 read non-destructive
DOSBIOS:2678		     dw	1FBh		     ; 06
DOSBIOS:267A		     dw	1FBh		     ; 07
DOSBIOS:267C		     dw	21Fh		     ; prn_writ
DOSBIOS:267E		     dw	21Fh		     ; 09
DOSBIOS:2680		     dw	251h		     ; prn_stat
DOSBIOS:2682		     dw	1FBh		     ; 0B
DOSBIOS:2684		     dw	1FBh		     ; 0C
DOSBIOS:2686		     dw	1FBh		     ; 0D
DOSBIOS:2688		     dw	1FBh		     ; 0E
DOSBIOS:268A		     dw	1FBh		     ; 0F
DOSBIOS:268C		     dw	28Bh		     ; prn_tilbusy
DOSBIOS:268E		     dw	1FBh		     ; 11
DOSBIOS:2690		     dw	1FBh		     ; 12
DOSBIOS:2692		     dw	2BAh		     ; prn_genioctl
DOSBIOS:2694		     dw	1FBh		     ; 14
DOSBIOS:2696		     dw	1FBh		     ; 15
DOSBIOS:2698		     dw	1FBh		     ; 16
DOSBIOS:269A		     dw	1FBh		     ; 17
DOSBIOS:269C		     dw	1FBh		     ; 18
DOSBIOS:269E		     dw	2F0h		     ; prn_ioctl_query
DOSBIOS:26A0 aux_table	     db	11		     ; 2C7h:130h = 70h:26A0h
DOSBIOS:26A0					     ; ((aux_table_end - aux_table) - 1)/2 ; 11
DOSBIOS:26A1		     dw	1FBh		     ; 00 - init
DOSBIOS:26A3		     dw	1FBh		     ; 01
DOSBIOS:26A5		     dw	1FBh		     ; 02
DOSBIOS:26A7		     dw	0D5h		     ; 03
DOSBIOS:26A9		     dw	30Dh		     ; aux_read	; 04 - read
DOSBIOS:26AB		     dw	335h		     ; aux_rdnd	- 05 - read non-destructive
DOSBIOS:26AD		     dw	1FBh		     ; 06
DOSBIOS:26AF		     dw	36Ch		     ; aux_flsh
DOSBIOS:26B1		     dw	374h		     ; aux_writ
DOSBIOS:26B3		     dw	374h		     ; 09
DOSBIOS:26B5		     dw	355h		     ; aux_wrst
DOSBIOS:26B7 tim_table	     db	10		     ; 2C7h:147h = 70h:26B7h
DOSBIOS:26B7					     ; ((tim_table_end - tim_table) - 1)/2 ; 10
DOSBIOS:26B8		     dw	1FBh		     ; 00
DOSBIOS:26BA		     dw	1FBh		     ; 01
DOSBIOS:26BC		     dw	1FBh		     ; 02
DOSBIOS:26BE		     dw	0D5h		     ; 03
DOSBIOS:26C0		     dw	435h		     ; tim_read
DOSBIOS:26C2		     dw	1C8h		     ; z_bus_exit
DOSBIOS:26C4		     dw	1FBh		     ; 06
DOSBIOS:26C6		     dw	1FBh		     ; 07
DOSBIOS:26C8		     dw	3DBh		     ; tim_writ
DOSBIOS:26CA		     dw	3DBh		     ; 09
DOSBIOS:26CC ; ---------------------------------------------------------------------------
DOSBIOS:26CC
DOSBIOS:26CC con_read:				     ; 2C7h:15Ch = 70h:26CCh
DOSBIOS:26CC		     jcxz    short con_exit  ; read cx bytes from keyboard into	buffer
DOSBIOS:26CE
DOSBIOS:26CE con_loop:				     ; CODE XREF: DOSBIOS:26D2j
DOSBIOS:26CE		     call    chrin	     ; get char	in al
DOSBIOS:26D1		     stosb		     ; store char at es:di
DOSBIOS:26D2		     loop    con_loop
DOSBIOS:26D4
DOSBIOS:26D4 con_exit:				     ; CODE XREF: DOSBIOS:con_readj
DOSBIOS:26D4		     clc
DOSBIOS:26D5		     retn
DOSBIOS:26D6
DOSBIOS:26D6 ; =============== S U B R O U T I N E =======================================
DOSBIOS:26D6
DOSBIOS:26D6
DOSBIOS:26D6 chrin	     proc near		     ; CODE XREF: DOSBIOS:con_loopp
DOSBIOS:26D6					     ; chrin+12j
DOSBIOS:26D6		     mov     ah, ds:keyrd_func ; set by	msinit.	0 or 10h
DOSBIOS:26DA		     xor     al, al
DOSBIOS:26DC		     xchg    al, ds:altah    ; get character & zero altah
DOSBIOS:26E0		     or	     al, al
DOSBIOS:26E2		     jnz     short keyret
DOSBIOS:26E4		     int     16h	     ; KEYBOARD	-
DOSBIOS:26E6		     or	     ax, ax
DOSBIOS:26E8		     jz	     short chrin
DOSBIOS:26EA		     cmp     ax, 7200h	     ; check for ctrl-prtsc
DOSBIOS:26ED		     jnz     short alt_ext_chk
DOSBIOS:26EF		     mov     al, 10h
DOSBIOS:26F1		     jmp     short keyret
DOSBIOS:26F3 ; ---------------------------------------------------------------------------
DOSBIOS:26F3
DOSBIOS:26F3 alt_ext_chk:			     ; CODE XREF: chrin+17j
DOSBIOS:26F3		     cmp     ds:keyrd_func, 0
DOSBIOS:26F8		     jz	     short not_ext
DOSBIOS:26FA		     cmp     al, 0E0h
DOSBIOS:26FC		     jnz     short not_ext
DOSBIOS:26FE		     or	     ah, ah
DOSBIOS:2700		     jz	     short keyret
DOSBIOS:2702		     xor     al, al
DOSBIOS:2704		     jmp     short alt_save
DOSBIOS:2706 ; ---------------------------------------------------------------------------
DOSBIOS:2706
DOSBIOS:2706 not_ext:				     ; CODE XREF: chrin+22j
DOSBIOS:2706					     ; chrin+26j
DOSBIOS:2706		     or	     al, al	     ; special case?
DOSBIOS:2708		     jnz     short keyret
DOSBIOS:270A
DOSBIOS:270A alt_save:				     ; CODE XREF: chrin+2Ej
DOSBIOS:270A		     mov     ds:altah, ah    ; store special key
DOSBIOS:270E
DOSBIOS:270E keyret:				     ; CODE XREF: chrin+Cj
DOSBIOS:270E					     ; chrin+1Bj ...
DOSBIOS:270E		     retn
DOSBIOS:270E chrin	     endp
DOSBIOS:270E
DOSBIOS:270F ; ---------------------------------------------------------------------------
DOSBIOS:270F
DOSBIOS:270F con_rdnd:				     ; CODE XREF: DOSBIOS:2746j
DOSBIOS:270F		     mov     al, ds:altah
DOSBIOS:2712		     or	     al, al
DOSBIOS:2714		     jnz     short rdexit
DOSBIOS:2716		     mov     ah, ds:keysts_func
DOSBIOS:271A		     int     16h	     ; KEYBOARD	-
DOSBIOS:271C		     jnz     short gotchr
DOSBIOS:271E		     cmp     ds:fhavek09, 0
DOSBIOS:2723		     jz	     short z_bus_exit
DOSBIOS:2725		     les     bx, ds:ptrsav
DOSBIOS:2729		     test    word ptr es:[bx+3], 400h ;	[es:bx+status]
DOSBIOS:272F		     jz	     short z_bus_exit
DOSBIOS:2731		     mov     ax, 4100h
DOSBIOS:2734		     xor     bl, bl
DOSBIOS:2736		     int     15h	     ; SYSTEM -	WAIT ON	EXTERNAL EVENT (CONVERTIBLE)
DOSBIOS:2736					     ; AL = condition type, BH = condition compare or mask value
DOSBIOS:2736					     ; BL = timeout value times	55 milliseconds, 00h means no timeout
DOSBIOS:2736					     ; DX = I/O	port address if	AL bit 4 set
DOSBIOS:2738
DOSBIOS:2738 z_bus_exit:			     ; CODE XREF: DOSBIOS:2723j
DOSBIOS:2738					     ; DOSBIOS:272Fj ...
DOSBIOS:2738		     stc		     ; 2C7h:1C8h = 70h:2738h
DOSBIOS:2739		     mov     ah, 3	     ; indicate	busy status
DOSBIOS:273B		     retn
DOSBIOS:273C ; ---------------------------------------------------------------------------
DOSBIOS:273C
DOSBIOS:273C gotchr:				     ; CODE XREF: DOSBIOS:271Cj
DOSBIOS:273C		     or	     ax, ax
DOSBIOS:273E		     jnz     short notbrk    ; check for null after break
DOSBIOS:2740		     mov     ah, ds:keyrd_func ; issue keyboard	read function
DOSBIOS:2744		     int     16h	     ; KEYBOARD	-
DOSBIOS:2746		     jmp     short con_rdnd  ; get a real status
DOSBIOS:2748 ; ---------------------------------------------------------------------------
DOSBIOS:2748
DOSBIOS:2748 notbrk:				     ; CODE XREF: DOSBIOS:273Ej
DOSBIOS:2748		     cmp     ax, 7200h	     ; check for ctrl-prtsc
DOSBIOS:274B		     jnz     short rd_ext_chk
DOSBIOS:274D		     mov     al, 10h	     ; ('P' & 1Fh) ; return control p
DOSBIOS:274F		     jmp     short rdexit
DOSBIOS:2751 ; ---------------------------------------------------------------------------
DOSBIOS:2751
DOSBIOS:2751 rd_ext_chk:			     ; CODE XREF: DOSBIOS:274Bj
DOSBIOS:2751		     cmp     ds:keyrd_func, 0 ;	extended keyboard function?
DOSBIOS:2756		     jz	     short rdexit
DOSBIOS:2758		     cmp     al, 0E0h	     ; extended	key value or greek alpha?
DOSBIOS:275A		     jnz     short rdexit
DOSBIOS:275C		     cmp     ah, 0	     ; scan code exist?
DOSBIOS:275F		     jz	     short rdexit    ; yes. greek alpha	char.
DOSBIOS:2761		     mov     al, 0	     ; no. extended key	stroke.
DOSBIOS:2761					     ; change it for compatibility
DOSBIOS:2763
DOSBIOS:2763 rdexit:				     ; CODE XREF: DOSBIOS:2714j
DOSBIOS:2763					     ; DOSBIOS:274Fj ...
DOSBIOS:2763		     les     bx, ds:ptrsav
DOSBIOS:2767		     mov     es:[bx+13], al  ; [es:bx+media]
DOSBIOS:2767					     ; return keyboard character here
DOSBIOS:276B
DOSBIOS:276B bc_exvec:				     ; CODE XREF: DOSBIOS:con_writj
DOSBIOS:276B		     clc		     ; bc_exvec	at 2C7h:1FBh = 70h:276Bh
DOSBIOS:276B					     ; indicate	normal termination
DOSBIOS:276C		     retn
DOSBIOS:276D ; ---------------------------------------------------------------------------
DOSBIOS:276D
DOSBIOS:276D con_writ:
DOSBIOS:276D		     jcxz    short bc_exvec
DOSBIOS:276F
DOSBIOS:276F con_lp:				     ; CODE XREF: DOSBIOS:2775j
DOSBIOS:276F		     mov     al, es:[di]
DOSBIOS:2772		     inc     di
DOSBIOS:2773		     int     29h	     ; DOS 2+ internal - FAST PUTCHAR
DOSBIOS:2773					     ; AL = character to display
DOSBIOS:2775		     loop    con_lp
DOSBIOS:2777 ; START OF	FUNCTION CHUNK FOR con_flush
DOSBIOS:2777
DOSBIOS:2777 cc_ret:				     ; CODE XREF: con_flush+9j
DOSBIOS:2777		     clc
DOSBIOS:2778		     retn
DOSBIOS:2778 ; END OF FUNCTION CHUNK FOR con_flush
DOSBIOS:2779
DOSBIOS:2779 ; =============== S U B R O U T I N E =======================================
DOSBIOS:2779
DOSBIOS:2779
DOSBIOS:2779 con_flush	     proc near		     ; CODE XREF: DOSBIOS:3D2Dp
DOSBIOS:2779
DOSBIOS:2779 ; FUNCTION	CHUNK AT DOSBIOS:2777 SIZE 00000002 BYTES
DOSBIOS:2779
DOSBIOS:2779		     mov     ds:altah, 0     ; clear out holding buffer
DOSBIOS:2779					     ; while (charavail()) charread();
DOSBIOS:277E
DOSBIOS:277E flloop:				     ; CODE XREF: con_flush+Fj
DOSBIOS:277E		     mov     ah, 1
DOSBIOS:2780		     int     16h	     ; KEYBOARD	- CHECK	BUFFER,	DO NOT CLEAR
DOSBIOS:2780					     ; Return: ZF clear	if character in	buffer
DOSBIOS:2780					     ; AH = scan code, AL = character
DOSBIOS:2780					     ; ZF set if no character in buffer
DOSBIOS:2782		     jz	     short cc_ret
DOSBIOS:2784		     xor     ah, ah
DOSBIOS:2786		     int     16h	     ; KEYBOARD	- READ CHAR FROM BUFFER, WAIT IF EMPTY
DOSBIOS:2786					     ; Return: AH = scan code, AL = character
DOSBIOS:2788		     jmp     short flloop
DOSBIOS:2788 con_flush	     endp
DOSBIOS:2788
DOSBIOS:278A ; ---------------------------------------------------------------------------
DOSBIOS:278A
DOSBIOS:278A prn_input:				     ; 2C7h:21Ah = 70h:278Ah
DOSBIOS:278A		     call    bc_err_cnt	     ; reset count to zero
DOSBIOS:278A					     ; (sub reqpkt.count,cx)
DOSBIOS:278D		     clc		     ; but return with carry reset for no error
DOSBIOS:278E		     retn
DOSBIOS:278F ; ---------------------------------------------------------------------------
DOSBIOS:278F
DOSBIOS:278F prn_writ:				     ; 2C7h:21Fh = 70h:278Fh
DOSBIOS:278F		     jcxz    short prn_done  ; no chars	to output
DOSBIOS:2791
DOSBIOS:2791 prn_loop:				     ; CODE XREF: DOSBIOS:27BDj
DOSBIOS:2791		     mov     bx, 2	     ; retry count
DOSBIOS:2794
DOSBIOS:2794 prn_out:				     ; CODE XREF: DOSBIOS:27B7j
DOSBIOS:2794		     call    prnstat	     ; get status
DOSBIOS:2797		     jnz     short TestPrnError
DOSBIOS:2799		     mov     al, es:[di]     ; get character to	print
DOSBIOS:279C		     xor     ah, ah
DOSBIOS:279E		     call    prnop	     ; print to	printer
DOSBIOS:27A1		     jz	     short prn_con   ; no error	- continue
DOSBIOS:27A3		     cmp     ah, 0FFh	     ; MODE_CTRLBRK
DOSBIOS:27A6		     jnz     short _prnwf
DOSBIOS:27A8		     mov     al, 0Ch	     ; error_I24_gen_failure
DOSBIOS:27AA		     mov     ds:altah, 0
DOSBIOS:27AF		     jmp     short pmessg
DOSBIOS:27B1 ; ---------------------------------------------------------------------------
DOSBIOS:27B1
DOSBIOS:27B1 _prnwf:				     ; CODE XREF: DOSBIOS:27A6j
DOSBIOS:27B1		     test    ah, 1	     ; timeoutstatus
DOSBIOS:27B4		     jz	     short prn_con
DOSBIOS:27B6
DOSBIOS:27B6 TestPrnError:			     ; CODE XREF: DOSBIOS:2797j
DOSBIOS:27B6		     dec     bx		     ; retry until count is exhausted.
DOSBIOS:27B7		     jnz     short prn_out
DOSBIOS:27B9
DOSBIOS:27B9 pmessg:				     ; CODE XREF: DOSBIOS:27AFj
DOSBIOS:27B9					     ; DOSBIOS:27C4j
DOSBIOS:27B9		     jmp     bc_err_cnt
DOSBIOS:27BC ; ---------------------------------------------------------------------------
DOSBIOS:27BC
DOSBIOS:27BC prn_con:				     ; CODE XREF: DOSBIOS:27A1j
DOSBIOS:27BC					     ; DOSBIOS:27B4j
DOSBIOS:27BC		     inc     di		     ; point to	next char and continue
DOSBIOS:27BD		     loop    prn_loop
DOSBIOS:27BF
DOSBIOS:27BF prn_done:				     ; CODE XREF: DOSBIOS:prn_writj
DOSBIOS:27BF					     ; DOSBIOS:27C9j
DOSBIOS:27BF		     clc
DOSBIOS:27C0		     retn
DOSBIOS:27C1 ; ---------------------------------------------------------------------------
DOSBIOS:27C1
DOSBIOS:27C1 prn_stat:				     ; 2C7h:251h = 70h:27C1h
DOSBIOS:27C1		     call    prnstat	     ; device in dx
DOSBIOS:27C4		     jnz     short pmessg
DOSBIOS:27C6		     test    ah, 80h	     ; notbusystatus
DOSBIOS:27C9		     jnz     short prn_done
DOSBIOS:27CB		     jmp     z_bus_exit
DOSBIOS:27CE ; ---------------------------------------------------------------------------
DOSBIOS:27CE
DOSBIOS:27CE prnstat:				     ; CODE XREF: DOSBIOS:prn_outp
DOSBIOS:27CE					     ; DOSBIOS:prn_statp ...
DOSBIOS:27CE		     mov     ah, 2	     ; set command for get status
DOSBIOS:27D0
DOSBIOS:27D0 ; =============== S U B R O U T I N E =======================================
DOSBIOS:27D0
DOSBIOS:27D0
DOSBIOS:27D0 prnop	     proc near		     ; CODE XREF: DOSBIOS:279Ep
DOSBIOS:27D0					     ; DOSBIOS:281Dp
DOSBIOS:27D0		     mov     dx, ds:auxnum   ; get printer number
DOSBIOS:27D4		     int     17h	     ; PRINTER - GET STATUS
DOSBIOS:27D4					     ; DX = printer port (0-3)
DOSBIOS:27D4					     ; Return: AH = status
DOSBIOS:27D6		     push    ax
DOSBIOS:27D7		     and     ah, 30h
DOSBIOS:27DA		     cmp     ah, 30h	     ; noprinter
DOSBIOS:27DD		     pop     ax
DOSBIOS:27DE		     jnz     short NextTest
DOSBIOS:27E0		     and     ah, 0DFh	     ; ~nopaperstatus
DOSBIOS:27E3		     or	     ah, 8	     ; ioerrstatus
DOSBIOS:27E6
DOSBIOS:27E6 NextTest:				     ; CODE XREF: prnop+Ej
DOSBIOS:27E6		     test    ah, 28h	     ; (ioerrstatus+nopaperstatus)
DOSBIOS:27E6					     ; i/o error?
DOSBIOS:27E9		     jz	     short checknotready ; no, try not ready
DOSBIOS:27EB		     mov     al, 9	     ; error_I24_out_of_paper
DOSBIOS:27EB					     ; first, assume out of paper
DOSBIOS:27ED		     test    ah, 20h	     ; out of paper set?
DOSBIOS:27F0		     jnz     short ret1	     ; yes, error is set
DOSBIOS:27F2		     inc     al		     ; return al=10 (i/o error)
DOSBIOS:27F4
DOSBIOS:27F4 ret1:				     ; CODE XREF: prnop+20j
DOSBIOS:27F4		     retn
DOSBIOS:27F5 ; ---------------------------------------------------------------------------
DOSBIOS:27F5
DOSBIOS:27F5 checknotready:			     ; CODE XREF: prnop+19j
DOSBIOS:27F5		     mov     al, 2	     ; assume not-ready
DOSBIOS:27F7		     test    ah, 1
DOSBIOS:27FA		     retn
DOSBIOS:27FA prnop	     endp
DOSBIOS:27FA
DOSBIOS:27FB ; ---------------------------------------------------------------------------
DOSBIOS:27FB
DOSBIOS:27FB prn_tilbusy:			     ; 2C7h:28Bh = 70h:27FBh
DOSBIOS:27FB		     mov     si, di	     ; everything is set for lodsb
DOSBIOS:27FD
DOSBIOS:27FD prn_tilbloop:			     ; CODE XREF: DOSBIOS:2822j
DOSBIOS:27FD		     push    cx
DOSBIOS:27FE		     push    bx
DOSBIOS:27FF		     xor     bh, bh
DOSBIOS:2801		     mov     bl, ds:printdev
DOSBIOS:2805		     shl     bx, 1
DOSBIOS:2807		     mov     cx, ds:wait_count[bx] ; wait count	times to come ready
DOSBIOS:280B		     pop     bx
DOSBIOS:280C
DOSBIOS:280C prn_getstat:			     ; CODE XREF: DOSBIOS:2814j
DOSBIOS:280C		     call    prnstat	     ; get status
DOSBIOS:280F		     jnz     short prn_bperr ; error
DOSBIOS:2811		     test    ah, 80h	     ; ready yet?
DOSBIOS:2814		     loope   prn_getstat     ; no, go for more
DOSBIOS:2816		     pop     cx		     ; get original count
DOSBIOS:2817		     jz	     short prn_berr  ; still not ready => done
DOSBIOS:2819		     lods    byte ptr es:[si] ;	es
DOSBIOS:2819					     ; lodsb
DOSBIOS:281B		     xor     ah, ah
DOSBIOS:281D		     call    prnop
DOSBIOS:2820		     jnz     short prn_berr  ; error
DOSBIOS:2822		     loop    prn_tilbloop
DOSBIOS:2824		     clc
DOSBIOS:2825		     retn
DOSBIOS:2826 ; ---------------------------------------------------------------------------
DOSBIOS:2826
DOSBIOS:2826 prn_bperr:				     ; CODE XREF: DOSBIOS:280Fj
DOSBIOS:2826		     pop     cx		     ; restore transfer	count from stack
DOSBIOS:2827
DOSBIOS:2827 prn_berr:				     ; CODE XREF: DOSBIOS:2817j
DOSBIOS:2827					     ; DOSBIOS:2820j
DOSBIOS:2827		     jmp     bc_err_cnt
DOSBIOS:282A ; ---------------------------------------------------------------------------
DOSBIOS:282A
DOSBIOS:282A prn_genioctl:			     ; 2C7h:2BAh = 70h:282Ah
DOSBIOS:282A		     les     di, ds:ptrsav
DOSBIOS:282E		     cmp     byte ptr es:[di+13], 5 ; [es:di+IOCTL_REQ.MAJORFUNCTION]
DOSBIOS:282E					     ; ioc_pc
DOSBIOS:2833		     jz	     short prnfunc_ok
DOSBIOS:2835
DOSBIOS:2835 prnfuncerr:			     ; CODE XREF: DOSBIOS:2852j
DOSBIOS:2835		     jmp     bc_cmderr
DOSBIOS:2838 ; ---------------------------------------------------------------------------
DOSBIOS:2838
DOSBIOS:2838 prnfunc_ok:			     ; CODE XREF: DOSBIOS:2833j
DOSBIOS:2838		     mov     al, es:[di+14]  ; [es:di+IOCTL_REQ.MINORFUNCTION]
DOSBIOS:283C		     les     di, es:[di+19]  ; [es:di+IOCTL_REQ.GENERICIOCTL_PACKET]
DOSBIOS:2840		     xor     bh, bh
DOSBIOS:2842		     mov     bl, ds:printdev ; get index into retry counts
DOSBIOS:2846		     shl     bx, 1
DOSBIOS:2848		     mov     cx, ds:wait_count[bx] ; pull out retry count for device
DOSBIOS:284C		     cmp     al, 65h	     ; get_retry_count
DOSBIOS:284E		     jz	     short prngetcount
DOSBIOS:2850		     cmp     al, 45h	     ; set_retry_count
DOSBIOS:2852		     jnz     short prnfuncerr
DOSBIOS:2854		     mov     cx, es:[di]
DOSBIOS:2857
DOSBIOS:2857 prngetcount:			     ; CODE XREF: DOSBIOS:284Ej
DOSBIOS:2857		     mov     ds:wait_count[bx],	cx
DOSBIOS:285B		     mov     es:[di], cx     ; [es:di+A_RETRYCOUNT.RC_COUNT]
DOSBIOS:285B					     ; return current retry count
DOSBIOS:285E		     clc
DOSBIOS:285F		     retn
DOSBIOS:2860 ; ---------------------------------------------------------------------------
DOSBIOS:2860
DOSBIOS:2860 prn_ioctl_query:			     ; 2C7h:2F0h = 70h:2860h
DOSBIOS:2860		     les     di, ds:ptrsav
DOSBIOS:2864		     cmp     byte ptr es:[di+13], 5 ; [es:di+IOCTL_REQ.MAJORFUNCTION]
DOSBIOS:2864					     ; ioc_pc
DOSBIOS:2869		     jnz     short prn_query_err
DOSBIOS:286B		     mov     al, es:[di+14]  ; [es:di+IOCTL_REQ.MINORFUNCTION]
DOSBIOS:286F		     cmp     al, 65h	     ; GET_RETRY_COUNT
DOSBIOS:2871		     jz	     short IOCtlSupported
DOSBIOS:2873		     cmp     al, 45h	     ; SET_RETRY_COUNT
DOSBIOS:2875		     jnz     short prn_query_err
DOSBIOS:2877
DOSBIOS:2877 IOCtlSupported:			     ; CODE XREF: DOSBIOS:2871j
DOSBIOS:2877		     clc
DOSBIOS:2878		     retn
DOSBIOS:2879 ; ---------------------------------------------------------------------------
DOSBIOS:2879
DOSBIOS:2879 prn_query_err:			     ; CODE XREF: DOSBIOS:2869j
DOSBIOS:2879					     ; DOSBIOS:2875j
DOSBIOS:2879		     stc
DOSBIOS:287A		     jmp     bc_cmderr
DOSBIOS:287D ; ---------------------------------------------------------------------------
DOSBIOS:287D
DOSBIOS:287D aux_read:				     ; 2C7h:30Dh = 70h:287Dh
DOSBIOS:287D		     jcxz    short exvec2
DOSBIOS:287F		     call    getbx	     ; put address of auxbuf in	bx
DOSBIOS:2882		     xor     al, al
DOSBIOS:2884		     xchg    al, [bx]
DOSBIOS:2886		     or	     al, al
DOSBIOS:2888		     jnz     short aux2
DOSBIOS:288A
DOSBIOS:288A aux1:				     ; CODE XREF: DOSBIOS:288Ej
DOSBIOS:288A		     call    auxin	     ; get character from port
DOSBIOS:288A					     ; won't return if error
DOSBIOS:288D
DOSBIOS:288D aux2:				     ; CODE XREF: DOSBIOS:2888j
DOSBIOS:288D		     stosb
DOSBIOS:288E		     loop    aux1	     ; if more characters, go around again
DOSBIOS:2890
DOSBIOS:2890 exvec2:				     ; CODE XREF: DOSBIOS:aux_readj
DOSBIOS:2890					     ; DOSBIOS:aux_writj
DOSBIOS:2890		     clc		     ; all done, successful exit
DOSBIOS:2891		     retn
DOSBIOS:2892 ; ---------------------------------------------------------------------------
DOSBIOS:2892
DOSBIOS:2892 auxin:				     ; CODE XREF: DOSBIOS:aux1p
DOSBIOS:2892					     ; DOSBIOS:28BAp
DOSBIOS:2892		     mov     ah, 2	     ; auxfunc_receive
DOSBIOS:2894		     call    auxop
DOSBIOS:2897		     test    ah, 0Eh	     ; flag_frame|flag_parity|flag_overrun
DOSBIOS:289A		     jnz     short arbad     ; skip if any error bits set
DOSBIOS:289C		     retn
DOSBIOS:289D ; ---------------------------------------------------------------------------
DOSBIOS:289D
DOSBIOS:289D arbad:				     ; CODE XREF: DOSBIOS:289Aj
DOSBIOS:289D		     pop     ax		     ; remove return address (near call)
DOSBIOS:289E		     xor     al, al
DOSBIOS:28A0		     or	     al, 0B0h	     ; flag_rec_sig| flag_dsr|flag_cts
DOSBIOS:28A2		     jmp     bc_err_cnt
DOSBIOS:28A5 ; ---------------------------------------------------------------------------
DOSBIOS:28A5
DOSBIOS:28A5 aux_rdnd:				     ; 2C7h:335h = 70h:28A5h
DOSBIOS:28A5		     call    getbx
DOSBIOS:28A8		     mov     al, [bx]	     ; have bx point to	auxbuf
DOSBIOS:28AA		     or	     al, al	     ; if al is	non-zero (char in buffer)
DOSBIOS:28AC		     jnz     short auxdrx    ; then return character
DOSBIOS:28AE		     call    auxstat	     ; if not, get status of aux device
DOSBIOS:28B1		     test    ah, 1	     ; flag_data_ready - test data ready
DOSBIOS:28B4		     jz	     short auxbus    ; then device is busy (not	ready)
DOSBIOS:28B6		     test    al, 20h	     ; flag_dsr	- test data set	ready
DOSBIOS:28B8		     jz	     short auxbus    ; then device is busy (not	ready)
DOSBIOS:28BA		     call    auxin	     ; else aux	is ready, get character
DOSBIOS:28BD		     mov     [bx], al
DOSBIOS:28BF
DOSBIOS:28BF auxdrx:				     ; CODE XREF: DOSBIOS:28ACj
DOSBIOS:28BF		     jmp     rdexit	     ; return busy status
DOSBIOS:28C2 ; ---------------------------------------------------------------------------
DOSBIOS:28C2
DOSBIOS:28C2 auxbus:				     ; CODE XREF: DOSBIOS:28B4j
DOSBIOS:28C2					     ; DOSBIOS:28B8j ...
DOSBIOS:28C2		     jmp     z_bus_exit
DOSBIOS:28C5 ; ---------------------------------------------------------------------------
DOSBIOS:28C5
DOSBIOS:28C5 aux_wrst:				     ; 2C7h:355h = 70h:28C5h
DOSBIOS:28C5		     call    auxstat	     ; get status of aux in ax
DOSBIOS:28C8		     test    al, 20h	     ; test data set ready
DOSBIOS:28CA		     jz	     short auxbus    ; then device is busy (not	ready)
DOSBIOS:28CC		     test    ah, 20h	     ; flag_tranhol_emp	- test transmit	hold reg empty
DOSBIOS:28CF		     jz	     short auxbus    ; then device is busy (not	ready)
DOSBIOS:28D1		     clc
DOSBIOS:28D2		     retn
DOSBIOS:28D3 ; ---------------------------------------------------------------------------
DOSBIOS:28D3
DOSBIOS:28D3 auxstat:				     ; CODE XREF: DOSBIOS:28AEp
DOSBIOS:28D3					     ; DOSBIOS:aux_wrstp
DOSBIOS:28D3		     mov     ah, 3	     ; auxfunc_status
DOSBIOS:28D5
DOSBIOS:28D5 ; =============== S U B R O U T I N E =======================================
DOSBIOS:28D5
DOSBIOS:28D5
DOSBIOS:28D5 auxop	     proc near		     ; CODE XREF: DOSBIOS:2894p
DOSBIOS:28D5					     ; DOSBIOS:28ECp
DOSBIOS:28D5		     mov     dx, ds:auxnum   ; ah=function code
DOSBIOS:28D5					     ; 0=init, 1=send, 2=receive, 3=status
DOSBIOS:28D5					     ; get port	number
DOSBIOS:28D9		     int     14h	     ; SERIAL I/O - GET	USART STATUS
DOSBIOS:28D9					     ; DX = port number	(0-3)
DOSBIOS:28D9					     ; Return: AX = port status	code
DOSBIOS:28DB		     retn
DOSBIOS:28DB auxop	     endp
DOSBIOS:28DB
DOSBIOS:28DC ; ---------------------------------------------------------------------------
DOSBIOS:28DC
DOSBIOS:28DC aux_flsh:				     ; 2C7h:36Ch = 70h:28DCh
DOSBIOS:28DC		     call    getbx	     ; flush aux input buffer
DOSBIOS:28DF		     mov     byte ptr [bx], 0 ;	get bx to point	to auxbuf
DOSBIOS:28DF					     ; zero out	buffer
DOSBIOS:28E2		     clc		     ; all done, successful return
DOSBIOS:28E3		     retn
DOSBIOS:28E4 ; ---------------------------------------------------------------------------
DOSBIOS:28E4
DOSBIOS:28E4 aux_writ:				     ; 2C7h:374h = 70h:28E4h
DOSBIOS:28E4		     jcxz    short exvec2    ; write to	aux device (if cx > 0)
DOSBIOS:28E6
DOSBIOS:28E6 aux_loop:				     ; CODE XREF: DOSBIOS:awokj
DOSBIOS:28E6		     mov     al, es:[di]     ; get character to	be written
DOSBIOS:28E6					     ; move di pointer to next character
DOSBIOS:28E9		     inc     di
DOSBIOS:28EA		     mov     ah, 1	     ; auxfunc_send - indicates	a write
DOSBIOS:28EC		     call    auxop	     ; send character over aux port
DOSBIOS:28EF		     test    ah, 80h	     ; check for error
DOSBIOS:28F2		     jz	     short awok	     ; then no error
DOSBIOS:28F4		     mov     al, 10	     ; else indicate write fault
DOSBIOS:28F6		     jmp     bc_err_cnt	     ; call error routines
DOSBIOS:28F9 ; ---------------------------------------------------------------------------
DOSBIOS:28F9
DOSBIOS:28F9 awok:				     ; CODE XREF: DOSBIOS:28F2j
DOSBIOS:28F9		     loop    aux_loop	     ; if cx is	non-zero,
DOSBIOS:28F9					     ; still more character to print
DOSBIOS:28FB		     clc		     ; all done, successful return
DOSBIOS:28FC		     retn
DOSBIOS:28FD
DOSBIOS:28FD ; =============== S U B R O U T I N E =======================================
DOSBIOS:28FD
DOSBIOS:28FD
DOSBIOS:28FD getbx	     proc near		     ; CODE XREF: DOSBIOS:287Fp
DOSBIOS:28FD					     ; DOSBIOS:aux_rdndp ...
DOSBIOS:28FD		     mov     bx, ds:auxnum   ; return bx -> single byte	input buffer
DOSBIOS:28FD					     ; for selected aux	port ([auxnum])
DOSBIOS:2901		     add     bx, offset	auxbuf
DOSBIOS:2905		     retn
DOSBIOS:2905 getbx	     endp
DOSBIOS:2905
DOSBIOS:2906 ; ---------------------------------------------------------------------------
DOSBIOS:2906
DOSBIOS:2906 time_to_ticks:			     ; 0070h:2906h = 02C7h:0396h
DOSBIOS:2906		     mov     al, 60	     ; convert time to ticks
DOSBIOS:2908		     mul     ch		     ; hours to	minutes
DOSBIOS:290A		     mov     ch, 0
DOSBIOS:290C		     add     ax, cx	     ; total minutes
DOSBIOS:290E		     mov     cx, 6000	     ; 60*100
DOSBIOS:2911		     mov     bx, dx	     ; get out of the way of the multiply
DOSBIOS:2913		     mul     cx		     ; convert to 1/100	sec
DOSBIOS:2915		     mov     cx, ax
DOSBIOS:2917		     mov     al, 100
DOSBIOS:2919		     mul     bh		     ; convert seconds to 1/100	sec
DOSBIOS:291B		     add     cx, ax	     ; combine seconds with hours and min
DOSBIOS:291D		     adc     dx, 0	     ; ripple carry
DOSBIOS:2920		     mov     bh, 0
DOSBIOS:2922		     add     cx, bx	     ; combine 1/100 sec
DOSBIOS:2924		     adc     dx, 0	     ; dx:cx is	time in	1/100 sec
DOSBIOS:2927		     xchg    ax, dx
DOSBIOS:2928		     xchg    ax, cx	     ; now time	is in cx:ax
DOSBIOS:2929		     mov     bx, 59659
DOSBIOS:292C		     mul     bx		     ; multiply	low half
DOSBIOS:292E		     xchg    dx, cx
DOSBIOS:2930		     xchg    ax, dx	     ; cx->ax, ax->dx, dx->cx
DOSBIOS:2931		     mul     bx		     ; multiply	high half
DOSBIOS:2933		     add     ax, cx	     ; combine overlapping products
DOSBIOS:2935		     adc     dx, 0
DOSBIOS:2938		     xchg    ax, dx	     ; ax:dx=time*59659
DOSBIOS:2939		     mov     bx, 5
DOSBIOS:293C		     div     bl		     ; divide high half	by 5
DOSBIOS:293E		     mov     cl, al
DOSBIOS:2940		     mov     ch, 0
DOSBIOS:2942		     mov     al, ah	     ; remainder of divide-by-5
DOSBIOS:2944		     cbw
DOSBIOS:2945		     xchg    ax, dx	     ; use it to extend	low half
DOSBIOS:2946		     div     bx		     ; divide low half by 5
DOSBIOS:2948		     mov     dx, ax	     ; cx:dx is	now number of ticks in time
DOSBIOS:294A		     retf		     ; far return
DOSBIOS:294B ; ---------------------------------------------------------------------------
DOSBIOS:294B
DOSBIOS:294B tim_writ:				     ; 2C7h:3DBh = 70h:294Bh
DOSBIOS:294B		     mov     ax, es:[di]
DOSBIOS:294E		     push    ax		     ; daycnt. we need to set this at the very
DOSBIOS:294E					     ; end to avoid tick windows.
DOSBIOS:294F		     cmp     ds:havecmosclock, 0
DOSBIOS:2954		     jz	     short no_cmos_1
DOSBIOS:2956		     mov     al, es:[di+3]   ; near indirect calls
DOSBIOS:2956					     ; get binary hours
DOSBIOS:2956					     ; convert to bcd
DOSBIOS:295A		     call    ds:bintobcd     ; call far	[bintobcd]
DOSBIOS:295E		     mov     ch, al	     ; ch = bcd	hours
DOSBIOS:2960		     mov     al, es:[di+2]   ; get binary minutes
DOSBIOS:2964		     call    ds:bintobcd     ; convert to bcd
DOSBIOS:2968		     mov     cl, al	     ; cl = bcd	minutes
DOSBIOS:296A		     mov     al, es:[di+5]   ; get binary seconds
DOSBIOS:296E		     call    ds:bintobcd
DOSBIOS:2972		     mov     dh, al	     ; dh = bcd	seconds
DOSBIOS:2974		     mov     dl, 0	     ; dl = 0 (st) or 1	(dst)
DOSBIOS:2976		     cli
DOSBIOS:2977		     mov     ah, 3
DOSBIOS:2979		     int     1Ah	     ; CLOCK - SET REAL	TIME CLOCK (AT,XT286,CONV,PS)
DOSBIOS:2979					     ; CH = hours in BCD, CL = minutes in BCD
DOSBIOS:2979					     ;	DH = seconds in	BCD,DL = 01h if	daylight savings, 00h if standard time
DOSBIOS:2979					     ; Return: CMOS clock set
DOSBIOS:297B		     sti
DOSBIOS:297C
DOSBIOS:297C no_cmos_1:				     ; CODE XREF: DOSBIOS:2954j
DOSBIOS:297C		     mov     cx, es:[di+2]
DOSBIOS:2980		     mov     dx, es:[di+4]
DOSBIOS:2984		     call    dword ptr ds:ttticks ; call far [ttticks]
DOSBIOS:2984					     ; convert time to ticks
DOSBIOS:2984					     ; cx:dx now has time in ticks
DOSBIOS:2988		     cli		     ; turn off	timer
DOSBIOS:2989		     mov     ah, 1
DOSBIOS:298B		     int     1Ah	     ; CLOCK - SET TIME	OF DAY
DOSBIOS:298B					     ; CX:DX = clock count
DOSBIOS:298B					     ; Return: time of day set
DOSBIOS:298D		     pop     ds:daycnt
DOSBIOS:2991		     sti
DOSBIOS:2992		     cmp     ds:havecmosclock, 0
DOSBIOS:2997		     jz	     short no_cmos_2
DOSBIOS:2999		     call    ds:daycnttoday  ; call far	[daycnttoday]
DOSBIOS:2999					     ; convert to bcd format
DOSBIOS:299D		     cli
DOSBIOS:299E		     mov     ah, 5
DOSBIOS:29A0		     int     1Ah	     ; CLOCK - SET DATE	IN REAL	TIME CLOCK (AT,XT286,CONV,PS)
DOSBIOS:29A0					     ; DL = day	in BCD,	DH = month in BCD, CL =	year in	BCD
DOSBIOS:29A0					     ; CH = century (19h or 20h)
DOSBIOS:29A0					     ; Return: CMOS clock set
DOSBIOS:29A2		     sti
DOSBIOS:29A3
DOSBIOS:29A3 no_cmos_2:				     ; CODE XREF: DOSBIOS:2997j
DOSBIOS:29A3		     clc
DOSBIOS:29A4		     retn
DOSBIOS:29A5 ; ---------------------------------------------------------------------------
DOSBIOS:29A5
DOSBIOS:29A5 tim_read:				     ; 2C7h:435h = 70h:29A5h
DOSBIOS:29A5		     call    GetTickCnt
DOSBIOS:29A8		     mov     si, ds:daycnt
DOSBIOS:29AC		     mov     ax, cx
DOSBIOS:29AE		     mov     bx, dx	     ; start with ticks	in cx:dx
DOSBIOS:29AE					     ; multiply	by 5
DOSBIOS:29B0		     shl     dx, 1
DOSBIOS:29B2		     rcl     cx, 1	     ; times 2
DOSBIOS:29B4		     shl     dx, 1
DOSBIOS:29B6		     rcl     cx, 1	     ; times 4
DOSBIOS:29B8		     add     dx, bx
DOSBIOS:29BA		     adc     ax, cx	     ; times 5
DOSBIOS:29BC		     xchg    ax, dx	     ; now have	ticks *	5 in dx:ax
DOSBIOS:29BC					     ; we now need to multiply by 65,536
DOSBIOS:29BC					     ; and divide by 59659 d.
DOSBIOS:29BD		     mov     cx, 59659	     ; get divisor
DOSBIOS:29C0		     div     cx		     ; dx now has remainder
DOSBIOS:29C0					     ; ax has high word	of final quotient
DOSBIOS:29C2		     mov     bx, ax	     ; put high	word in	safe place
DOSBIOS:29C4		     xor     ax, ax	     ; this is the multiply by 65536
DOSBIOS:29C6		     div     cx		     ; bx:ax now has time in 100th of seconds
DOSBIOS:29C8		     mov     dx, bx	     ; rounding	based on the remainder may be added here
DOSBIOS:29C8					     ; the result in bx:ax is time in 1/100 second.
DOSBIOS:29CA		     mov     cx, 200	     ; division	by 200 is necessary to ensure
DOSBIOS:29CA					     ; no overflow--max	result
DOSBIOS:29CA					     ; is number of seconds in a day/2 = 43200.
DOSBIOS:29CD		     div     cx
DOSBIOS:29CF		     cmp     dl, 100	     ; remainder over 100?
DOSBIOS:29D2		     jb	     short noadj
DOSBIOS:29D4		     sub     dl, 100	     ; keep 1/100's less than 100
DOSBIOS:29D7
DOSBIOS:29D7 noadj:				     ; CODE XREF: DOSBIOS:29D2j
DOSBIOS:29D7		     cmc		     ; if we subtracted	100, carry is now set
DOSBIOS:29D8		     mov     bl, dl	     ; save 1/100's
DOSBIOS:29DA		     rcl     ax, 1	     ; to compensate for dividing by 200 instead of 100,
DOSBIOS:29DA					     ; we now multiply by two, shifting	a one in
DOSBIOS:29DA					     ; if the remainder	had exceeded 100.
DOSBIOS:29DC		     mov     dl, 0
DOSBIOS:29DE		     rcl     dx, 1
DOSBIOS:29E0		     mov     cx, 60	     ; divide out seconds
DOSBIOS:29E3		     div     cx
DOSBIOS:29E5		     mov     bh, dl	     ; save the	seconds
DOSBIOS:29E7		     div     cl		     ; break into hours	and minutes
DOSBIOS:29E9		     xchg    al, ah	     ; time is now in ax:bx
DOSBIOS:29E9					     ; (hours, minutes,	seconds, 1/100 sec)
DOSBIOS:29EB		     push    ax
DOSBIOS:29EC		     mov     ax, si	     ; daycnt
DOSBIOS:29EE		     stosw
DOSBIOS:29EF		     pop     ax
DOSBIOS:29F0		     stosw
DOSBIOS:29F1		     mov     ax, bx
DOSBIOS:29F3		     stosw
DOSBIOS:29F4		     clc
DOSBIOS:29F5		     retn
DOSBIOS:29F6
DOSBIOS:29F6 ; =============== S U B R O U T I N E =======================================
DOSBIOS:29F6
DOSBIOS:29F6
DOSBIOS:29F6 GetTickCnt	     proc near		     ; CODE XREF: DOSBIOS:tim_readp
DOSBIOS:29F6					     ; Check_Time_Of_Access+3p	...
DOSBIOS:29F6		     xor     ah, ah
DOSBIOS:29F8		     int     1Ah	     ; CLOCK - GET TIME	OF DAY
DOSBIOS:29F8					     ; Return: CX:DX = clock count
DOSBIOS:29F8					     ; AL = 00h	if clock was read or written (via AH=0,1) since	the previous
DOSBIOS:29F8					     ; midnight
DOSBIOS:29F8					     ; Otherwise, AL > 0
DOSBIOS:29FA		     cmp     ds:t_switch, 0  ; use old method ?	(>0 is yes)
DOSBIOS:29FF		     jnz     short inc_case  ; old method assumes  that	Int 1Ah	returns	rollover flag
DOSBIOS:2A01		     xor     ah, ah	     ; new method assumes that Int 1Ah returns roll over count
DOSBIOS:2A01					     ; and not flag
DOSBIOS:2A03		     add     ds:daycnt,	ax
DOSBIOS:2A07		     retn
DOSBIOS:2A08 ; ---------------------------------------------------------------------------
DOSBIOS:2A08
DOSBIOS:2A08 inc_case:				     ; CODE XREF: GetTickCnt+9j
DOSBIOS:2A08		     or	     al, al
DOSBIOS:2A0A		     jz	     short no_rollover
DOSBIOS:2A0C		     inc     ds:daycnt
DOSBIOS:2A10
DOSBIOS:2A10 no_rollover:			     ; CODE XREF: GetTickCnt+14j
DOSBIOS:2A10		     retn
DOSBIOS:2A10 GetTickCnt	     endp
DOSBIOS:2A10
DOSBIOS:2A10 ; ---------------------------------------------------------------------------
DOSBIOS:2A11		     db	0
DOSBIOS:2A12 dsktbl	     db	26		     ; 2C7h:4A2h = 70h:2A12h
DOSBIOS:2A12					     ; ((dtbl_siz-1)/2)	; this is the size of the table	; 26
DOSBIOS:2A13		     dw	1742h		     ; dsk_init
DOSBIOS:2A15		     dw	4EBh		     ; media_chk
DOSBIOS:2A17		     dw	592h		     ; get_bpb
DOSBIOS:2A19		     dw	0D5h		     ; bc_cmderr
DOSBIOS:2A1B		     dw	857h		     ; dsk_read
DOSBIOS:2A1D		     dw	83Dh		     ; x_bus_exit
DOSBIOS:2A1F		     dw	558h		     ; ret_carry_clear
DOSBIOS:2A21		     dw	558h		     ; ret_carry_clear
DOSBIOS:2A23		     dw	849h		     ; dsk_writ
DOSBIOS:2A25		     dw	841h		     ; dsk_writv
DOSBIOS:2A27		     dw	558h		     ; ret_carry_clear
DOSBIOS:2A29		     dw	558h		     ; ret_carry_clear
DOSBIOS:2A2B		     dw	0D5h		     ; bc_cmderr
DOSBIOS:2A2D		     dw	80Ah		     ; dsk_open
DOSBIOS:2A2F		     dw	81Ah		     ; dsk_close
DOSBIOS:2A31		     dw	831h		     ; dsk_rem
DOSBIOS:2A33		     dw	558h		     ; ret_carry_clear
DOSBIOS:2A35		     dw	558h		     ; ret_carry_clear
DOSBIOS:2A37		     dw	558h		     ; ret_carry_clear
DOSBIOS:2A39		     dw	0C6Bh		     ; do_generic_ioctl
DOSBIOS:2A3B		     dw	558h		     ; ret_carry_clear
DOSBIOS:2A3D		     dw	558h		     ; ret_carry_clear
DOSBIOS:2A3F		     dw	558h		     ; ret_carry_clear
DOSBIOS:2A41		     dw	1124h		     ; ioctl_getown
DOSBIOS:2A43		     dw	1142h		     ; ioctl_setown
DOSBIOS:2A45		     dw	129Ah		     ; ioctl_support_query
DOSBIOS:2A47
DOSBIOS:2A47 ; =============== S U B R O U T I N E =======================================
DOSBIOS:2A47
DOSBIOS:2A47
DOSBIOS:2A47 SetDrive	     proc near		     ; CODE XREF: DOSBIOS:media_chkp
DOSBIOS:2A47					     ; DOSBIOS:2B05p ...
DOSBIOS:2A47		     les     di, ds:start_bds
DOSBIOS:2A4B
DOSBIOS:2A4B X_Scan_Loop:			     ; CODE XREF: SetDrive+10j
DOSBIOS:2A4B		     cmp     es:[di+5],	al   ; [es:di+BDS.link]	; Go to	next bds
DOSBIOS:2A4F		     jz	     short X_SetDrv
DOSBIOS:2A51		     les     di, es:[di]
DOSBIOS:2A54		     cmp     di, 0FFFFh
DOSBIOS:2A57		     jnz     short X_Scan_Loop
DOSBIOS:2A59		     stc
DOSBIOS:2A5A
DOSBIOS:2A5A X_SetDrv:				     ; CODE XREF: SetDrive+8j
DOSBIOS:2A5A		     retn
DOSBIOS:2A5A SetDrive	     endp
DOSBIOS:2A5A
DOSBIOS:2A5B ; ---------------------------------------------------------------------------
DOSBIOS:2A5B
DOSBIOS:2A5B media_chk:				     ; 2C7h:4EBh = 70h:2A5Bh
DOSBIOS:2A5B		     call    SetDrive
DOSBIOS:2A5E		     mov     si, 1
DOSBIOS:2A61		     test    byte ptr es:[di+24h], 1 ; [es:di+BDS.flags+1]
DOSBIOS:2A61					     ; fchanged_by_format
DOSBIOS:2A66		     jz	     short WeAreNotFakingIt
DOSBIOS:2A68		     and     word ptr es:[di+23h], 0FEFFh ; [es:di+BDS.flags]
DOSBIOS:2A68					     ; ~fchanged_by_format ; reset flag
DOSBIOS:2A6E		     mov     ds:tim_drv, 0FFh ;	Ensure that we ask the rom if media has	changed
DOSBIOS:2A73		     test    byte ptr es:[di+23h], 1 ; [es:di+BDS.flags]
DOSBIOS:2A73					     ; fnon_removable
DOSBIOS:2A78		     jz	     short wehaveafloppy
DOSBIOS:2A7A		     mov     si, 0FFFFh	     ; Indicate	media changed
DOSBIOS:2A7D		     jmp     short Media_Done ;	Media_Done
DOSBIOS:2A7F ; ---------------------------------------------------------------------------
DOSBIOS:2A7F
DOSBIOS:2A7F WeAreNotFakingIt:			     ; CODE XREF: DOSBIOS:2A66j
DOSBIOS:2A7F		     test    byte ptr es:[di+23h], 1
DOSBIOS:2A84		     jnz     short Media_Done
DOSBIOS:2A86
DOSBIOS:2A86 wehaveafloppy:			     ; CODE XREF: DOSBIOS:2A78j
DOSBIOS:2A86		     xor     si, si
DOSBIOS:2A88		     cmp     ds:fhave96, 0   ; Do we have changeline support?
DOSBIOS:2A8D		     jz	     short mChk_NoChangeLine ; Brif not
DOSBIOS:2A8F		     call    mediacheck	     ;	Call into removable routine
DOSBIOS:2A92		     jb	     short err_exitj
DOSBIOS:2A94		     call    haschange
DOSBIOS:2A97		     jnz     short Media_Done
DOSBIOS:2A99
DOSBIOS:2A99 mChk_NoChangeLine:			     ; CODE XREF: DOSBIOS:2A8Dj
DOSBIOS:2A99		     mov     si, 1	     ; Presume no change
DOSBIOS:2A9C		     mov     al, ds:tim_drv  ; Last drive accessed
DOSBIOS:2A9F		     cmp     al, es:[di+4]   ; [es:di+BDS.drivenum]
DOSBIOS:2A9F					     ; Is drive	of last	access the same?
DOSBIOS:2AA3		     jnz     short Media_Unk ; No, then	"i don't know"
DOSBIOS:2AA5		     call    Check_Time_Of_Access
DOSBIOS:2AA8		     jmp     short Media_Done
DOSBIOS:2AAA ; ---------------------------------------------------------------------------
DOSBIOS:2AAA
DOSBIOS:2AAA Media_Unk:				     ; CODE XREF: DOSBIOS:2AA3j
DOSBIOS:2AAA		     dec     si		     ; ; Return	"I don't know"
DOSBIOS:2AAB
DOSBIOS:2AAB Media_Done:			     ; CODE XREF: DOSBIOS:2A7Dj
DOSBIOS:2AAB					     ; DOSBIOS:2A84j ...
DOSBIOS:2AAB		     push    es
DOSBIOS:2AAC		     les     bx, ds:ptrsav
DOSBIOS:2AB0		     mov     es:[bx+0Eh], si ; [es:bx+trans]
DOSBIOS:2AB4		     pop     es
DOSBIOS:2AB5		     or	     si, si
DOSBIOS:2AB7		     jns     short ret_carry_clear ; volidok
DOSBIOS:2AB9		     cmp     ds:fhave96, 0
DOSBIOS:2ABE		     jz	     short mChk1_NoChangeLine ;	Brif no	changeline support
DOSBIOS:2AC0		     call    media_set_vid
DOSBIOS:2AC3
DOSBIOS:2AC3 mChk1_NoChangeLine:		     ; CODE XREF: DOSBIOS:2ABEj
DOSBIOS:2AC3		     mov     ds:tim_drv, 0FFh ;	Make sure we ask rom for media check
DOSBIOS:2AC8
DOSBIOS:2AC8 ret_carry_clear:			     ; CODE XREF: DOSBIOS:2AB7j
DOSBIOS:2AC8		     clc		     ; volidok
DOSBIOS:2AC9		     retn
DOSBIOS:2ACA ; ---------------------------------------------------------------------------
DOSBIOS:2ACA
DOSBIOS:2ACA err_exitj:				     ; CODE XREF: DOSBIOS:2A92j
DOSBIOS:2ACA					     ; DOSBIOS:2B00j
DOSBIOS:2ACA		     call    maperror	     ; guaranteed to set carry
DOSBIOS:2ACD
DOSBIOS:2ACD ret81:				     ; CODE XREF: DOSBIOS:2B1Aj
DOSBIOS:2ACD		     mov     ah, 81h	     ; return error status
DOSBIOS:2ACF		     retn		     ; return with carry set
DOSBIOS:2AD0
DOSBIOS:2AD0 ; =============== S U B R O U T I N E =======================================
DOSBIOS:2AD0
DOSBIOS:2AD0
DOSBIOS:2AD0 Check_Time_Of_Access proc near	     ; CODE XREF: DOSBIOS:2AA5p
DOSBIOS:2AD0					     ; mediacheck+2Dp
DOSBIOS:2AD0		     mov     si, 1
DOSBIOS:2AD3		     call    GetTickCnt	     ; cx:dx is	the elapsed time
DOSBIOS:2AD6		     mov     ax, es:[di+47h] ; [es:di+BDS.tim_lo]
DOSBIOS:2AD6					     ; get stored time
DOSBIOS:2ADA		     sub     dx, ax
DOSBIOS:2ADC		     mov     ax, es:[di+49h] ; [es:di+BDS.tim_hi]
DOSBIOS:2AE0		     sbb     cx, ax
DOSBIOS:2AE2		     jnz     short timecheck_unk ; cx<>0 => >1 hour time must pass
DOSBIOS:2AE4		     or	     dx, dx
DOSBIOS:2AE6		     jnz     short timepassed ;	yes, examine max value
DOSBIOS:2AE8		     inc     ds:accesscount
DOSBIOS:2AEC		     cmp     ds:accesscount, 5 ; if count is less than threshold, ok
DOSBIOS:2AF1		     jb	     short timecheck_ret
DOSBIOS:2AF3		     dec     ds:accesscount  ; don't let the count wrap
DOSBIOS:2AF7		     jmp     short timecheck_unk ; "i don't know" if media changed
DOSBIOS:2AF9 ; ---------------------------------------------------------------------------
DOSBIOS:2AF9
DOSBIOS:2AF9 timepassed:			     ; CODE XREF: Check_Time_Of_Access+16j
DOSBIOS:2AF9		     cmp     dx, 36	     ; 18*2 ; 18.2 tics	per second.
DOSBIOS:2AF9					     ; min elapsed time? (2 seconds)
DOSBIOS:2AFC		     jbe     short timecheck_ret ; yes,	presume	no change
DOSBIOS:2AFE
DOSBIOS:2AFE timecheck_unk:			     ; CODE XREF: Check_Time_Of_Access+12j
DOSBIOS:2AFE					     ; Check_Time_Of_Access+27j
DOSBIOS:2AFE		     dec     si		     ; presume i don't know
DOSBIOS:2AFF
DOSBIOS:2AFF timecheck_ret:			     ; CODE XREF: Check_Time_Of_Access+21j
DOSBIOS:2AFF					     ; Check_Time_Of_Access+2Cj
DOSBIOS:2AFF		     retn
DOSBIOS:2AFF Check_Time_Of_Access endp
DOSBIOS:2AFF
DOSBIOS:2B00 ; ---------------------------------------------------------------------------
DOSBIOS:2B00		     jmp     short err_exitj
DOSBIOS:2B02 ; ---------------------------------------------------------------------------
DOSBIOS:2B02
DOSBIOS:2B02 get_bpb:				     ; 2C7h:592h = 70h:2B02h
DOSBIOS:2B02		     mov     ah, es:[di]     ; get fat id byte read by dos
DOSBIOS:2B05		     call    SetDrive	     ; get the correct bds for the drive
DOSBIOS:2B08		     test    byte ptr es:[di+23h], 1 ; [es:di+BDS.flags]
DOSBIOS:2B08					     ; fnon_removable
DOSBIOS:2B0D		     jnz     short already_gotbpb ; no need to build for fixed disks
DOSBIOS:2B0F		     call    clear_ids
DOSBIOS:2B12		     mov     ds:set_id_flag, 1 ; indicate to set system	id in bds
DOSBIOS:2B17		     call    GetBp	     ; build a bpb if necessary
DOSBIOS:2B1A		     jb	     short ret81
DOSBIOS:2B1C		     cmp     ds:set_id_flag, 2 ; already, volume_label set from	boot
DOSBIOS:2B21		     mov     ds:set_id_flag, 0 ; record	to bds table?
DOSBIOS:2B26		     jz	     short already_gotbpb ; do not set it again	from root dir
DOSBIOS:2B26					     ; otherwise, conventional boot record
DOSBIOS:2B28		     cmp     ds:fhave96, 0   ; do we have changeline support?
DOSBIOS:2B2D		     jz	     short already_gotbpb ; brif not
DOSBIOS:2B2F		     call    set_volume_id
DOSBIOS:2B32
DOSBIOS:2B32 already_gotbpb:			     ; CODE XREF: DOSBIOS:2B0Dj
DOSBIOS:2B32					     ; DOSBIOS:2B26j ...
DOSBIOS:2B32		     add     di, 6	     ; BDS.BPB
DOSBIOS:2B32					     ; return the bpb from the current bds
DOSBIOS:2B35
DOSBIOS:2B35 SetPtrSav:				     ; CODE XREF: DOSBIOS:3CBBj
DOSBIOS:2B35		     mov     cx, es	     ; return point for	dsk_init
DOSBIOS:2B35					     ; save es
DOSBIOS:2B37		     les     bx, ds:ptrsav
DOSBIOS:2B3B		     mov     es:[bx+0Dh], ah ; [es:bx+media]
DOSBIOS:2B3F		     mov     es:[bx+12h], di ; [es:bx+count]
DOSBIOS:2B43		     mov     es:[bx+14h], cx ; [es:bx+count+2]
DOSBIOS:2B47		     clc
DOSBIOS:2B48		     retn
DOSBIOS:2B49
DOSBIOS:2B49 ; =============== S U B R O U T I N E =======================================
DOSBIOS:2B49
DOSBIOS:2B49
DOSBIOS:2B49 clear_ids	     proc near		     ; CODE XREF: DOSBIOS:2B0Fp
DOSBIOS:2B49		     push    di
DOSBIOS:2B4A		     xor     cx, cx
DOSBIOS:2B4C		     mov     es:[di+57h], cx ; [es:di+BDS.vol_serial]
DOSBIOS:2B50		     mov     es:[di+59h], cx ; [es:di+BDS.vol_serial+2]
DOSBIOS:2B54		     mov     cx, 11	     ; size_of_EXT_BOOT_VOL_LABEL
DOSBIOS:2B57		     mov     si, offset	vol_no_name ; "NO NAME	  "
DOSBIOS:2B5A		     add     di, 75	     ; BDS.volid
DOSBIOS:2B5D		     rep movsb
DOSBIOS:2B5F		     test    byte ptr es:[di+1Fh], 40h
DOSBIOS:2B64		     mov     si, offset	fat_16_id ; "FAT16   "
DOSBIOS:2B67		     jnz     short ci_bigfat
DOSBIOS:2B69		     mov     si, offset	fat_12_id ; "FAT12   "
DOSBIOS:2B6C
DOSBIOS:2B6C ci_bigfat:				     ; CODE XREF: clear_ids+1Ej
DOSBIOS:2B6C		     mov     cx, 8	     ; size_of_EXT_SYSTEM_ID
DOSBIOS:2B6F		     add     di, 5	     ; (BDS.filesys_id-BDS.volid)-size_of_EXT_BOOT_VOL_LABEL
DOSBIOS:2B6F					     ; filesys_id field
DOSBIOS:2B72		     rep movsb
DOSBIOS:2B74		     pop     di
DOSBIOS:2B75		     retn
DOSBIOS:2B75 clear_ids	     endp
DOSBIOS:2B75
DOSBIOS:2B76
DOSBIOS:2B76 ; =============== S U B R O U T I N E =======================================
DOSBIOS:2B76
DOSBIOS:2B76
DOSBIOS:2B76 GetBp	     proc near		     ; CODE XREF: DOSBIOS:2B17p
DOSBIOS:2B76					     ; DOSBIOS:324Cp ...
DOSBIOS:2B76		     test    byte ptr es:[di+23h], 5 ; return bpb from the drive specified by the bds
DOSBIOS:2B76					     ; [es:di+BDS.flags]
DOSBIOS:2B76					     ; return_fake_bpb|fnon_removable
DOSBIOS:2B7B		     jz	     short getbp1    ; getbp1
DOSBIOS:2B7D		     jmp     getret_exit
DOSBIOS:2B80 ; ---------------------------------------------------------------------------
DOSBIOS:2B80
DOSBIOS:2B80 getbp1:				     ; CODE XREF: GetBp+5j
DOSBIOS:2B80		     push    cx
DOSBIOS:2B81		     push    dx
DOSBIOS:2B82		     push    bx
DOSBIOS:2B83		     call    readbootsec
DOSBIOS:2B86		     jb	     short getbp_err_ret_brdg
DOSBIOS:2B88		     or	     bx, bx	     ; bx is 0 if boot sector is valid.
DOSBIOS:2B8A		     jnz     short dofatbpb
DOSBIOS:2B8C		     call    movbpb	     ; move bpb	into registers
DOSBIOS:2B8F		     jmp     short Has1
DOSBIOS:2B91 ; ---------------------------------------------------------------------------
DOSBIOS:2B91
DOSBIOS:2B91 getbp_err_ret_brdg:		     ; CODE XREF: GetBp+10j
DOSBIOS:2B91					     ; GetBp+21j
DOSBIOS:2B91		     jmp     getbp_err_ret
DOSBIOS:2B94 ; ---------------------------------------------------------------------------
DOSBIOS:2B94
DOSBIOS:2B94 dofatbpb:				     ; CODE XREF: GetBp+14j
DOSBIOS:2B94		     call    readfat	     ; puts media descriptor byte in ah
DOSBIOS:2B97		     jb	     short getbp_err_ret_brdg
DOSBIOS:2B99		     cmp     ds:fhave96, 0   ;	changeline support available?
DOSBIOS:2B9E		     jz	     short bpb_nochangeline ; brif not
DOSBIOS:2BA0		     call    hidensity	     ; may not return! May add sp, 2 and
DOSBIOS:2BA0					     ; jump to has1!!!!!! or has720K
DOSBIOS:2BA3
DOSBIOS:2BA3 bpb_nochangeline:			     ; CODE XREF: GetBp+28j
DOSBIOS:2BA3		     cmp     byte ptr es:[di+22h], 2 ; [es:di+BDS.formfactor]
DOSBIOS:2BA3					     ; ffSmall
DOSBIOS:2BA8		     jnz     short is_floppy
DOSBIOS:2BAA		     cmp     ah, 0F9h	     ; is it a valid fat id byte for 3.5" ?
DOSBIOS:2BAD		     jnz     short got_unknown_medium
DOSBIOS:2BAF
DOSBIOS:2BAF Has720K:				     ; CODE XREF: DOSBIOS:3EB3j
DOSBIOS:2BAF		     mov     bx, offset	sm92
DOSBIOS:2BB2		     mov     al, [bx+0]	     ; [bx+bpbtype.spf]
DOSBIOS:2BB6		     mov     cx, [bx+3]	     ; [bx+bpbtype.csec]
DOSBIOS:2BBA		     mov     dx, [bx+5]	     ; [bx+bpbtype.spau]
DOSBIOS:2BBE		     mov     bx, [bx+1]	     ; [bx+bpbtype.spt]
DOSBIOS:2BC2		     jmp     short Has1
DOSBIOS:2BC4 ; ---------------------------------------------------------------------------
DOSBIOS:2BC4
DOSBIOS:2BC4 is_floppy:				     ; CODE XREF: GetBp+32j
DOSBIOS:2BC4		     cmp     ah, 0F8h	     ; must be a 5.25" floppy if we come here
DOSBIOS:2BC4					     ; valid media?? (0F8h-0FFh)
DOSBIOS:2BC7		     jb	     short got_unknown_medium
DOSBIOS:2BC9		     mov     al, 1	     ; set number of fat sectors
DOSBIOS:2BCB		     mov     bx, 16392	     ; 64*256+8
DOSBIOS:2BCB					     ; set dir entries and sector max
DOSBIOS:2BCE		     mov     cx, 320	     ; 40*8
DOSBIOS:2BCE					     ; set size	of drive
DOSBIOS:2BD1		     mov     dx, 257	     ; 01*256+1
DOSBIOS:2BD1					     ; set head	limit and sec/all unit
DOSBIOS:2BD4		     test    ah, 2	     ; test for	8 or 9 sector
DOSBIOS:2BD7		     jnz     short has8	     ; nz = has	8 sectors
DOSBIOS:2BD9		     inc     al		     ; inc number of fat sectors
DOSBIOS:2BDB		     inc     bl		     ; inc sector max
DOSBIOS:2BDD		     add     cx, 40	     ; increase	size (to 360)
DOSBIOS:2BE0
DOSBIOS:2BE0 has8:				     ; CODE XREF: GetBp+61j
DOSBIOS:2BE0		     test    ah, 1	     ; test for	1 or 2 heads
DOSBIOS:2BE3		     jz	     short Has1	     ; jz = 1 head
DOSBIOS:2BE5		     add     cx, cx	     ; double size of disk
DOSBIOS:2BE7		     mov     bh, 112	     ; increase	number of directory entries
DOSBIOS:2BE9		     inc     dh		     ; inc sec/all unit
DOSBIOS:2BEB		     inc     dl		     ; inc head	limit
DOSBIOS:2BED
DOSBIOS:2BED Has1:				     ; CODE XREF: GetBp+19j
DOSBIOS:2BED					     ; GetBp+4Cj ...
DOSBIOS:2BED		     mov     es:[di+8],	dh   ; [es:di+BDS.secperclus]
DOSBIOS:2BF1		     mov     es:[di+0Ch], bh ; [es:di+BDS.direntries]
DOSBIOS:2BF5		     mov     es:[di+0Eh], cx ; [es:di+BDS.totalsecs16]
DOSBIOS:2BF9		     mov     es:[di+10h], ah ; [es:di+BDS.media]
DOSBIOS:2BFD		     mov     es:[di+11h], al ; [es:di+BDS.fatsecs]
DOSBIOS:2C01		     mov     es:[di+13h], bl ; [es:di+BDS.secpertrack]
DOSBIOS:2C05		     mov     es:[di+15h], dl ; [es:di+BDS.heads]
DOSBIOS:2C09		     mov     word ptr es:[di+19h], 0 ; [es:di+BDS.hiddensecs+2]
DOSBIOS:2C0F		     mov     word ptr es:[di+17h], 0 ; [es:di+BDS.hiddensecs]
DOSBIOS:2C15		     mov     word ptr es:[di+1Dh], 0 ; [es:di+BDS.totalsecs32+2]
DOSBIOS:2C1B
DOSBIOS:2C1B getret:				     ; CODE XREF: GetBp+B1j
DOSBIOS:2C1B					     ; GetBp+BBj
DOSBIOS:2C1B		     pop     bx
DOSBIOS:2C1C		     pop     dx
DOSBIOS:2C1D		     pop     cx
DOSBIOS:2C1E
DOSBIOS:2C1E getret_exit:			     ; CODE XREF: GetBp+7j
DOSBIOS:2C1E		     retn
DOSBIOS:2C1F ; ---------------------------------------------------------------------------
DOSBIOS:2C1F
DOSBIOS:2C1F getbp_err_ret:			     ; CODE XREF: GetBp:getbp_err_ret_brdgj
DOSBIOS:2C1F		     mov     ds:set_id_flag, 0 ; before	doing anything else, set set_id_flag to	0.
DOSBIOS:2C24		     call    maperror
DOSBIOS:2C27		     jmp     short getret
DOSBIOS:2C29 ; ---------------------------------------------------------------------------
DOSBIOS:2C29
DOSBIOS:2C29 got_unknown_medium:		     ; CODE XREF: GetBp+37j
DOSBIOS:2C29					     ; GetBp+51j
DOSBIOS:2C29		     mov     ds:set_id_flag, 0 ; we have a 3.5"	diskette for which we cannot build a bpb.
DOSBIOS:2C29					     ; we do not assume	any type of bpb	for this medium.
DOSBIOS:2C2E		     mov     al, 7
DOSBIOS:2C30		     stc
DOSBIOS:2C31		     jmp     short getret
DOSBIOS:2C31 GetBp	     endp
DOSBIOS:2C31
DOSBIOS:2C33
DOSBIOS:2C33 ; =============== S U B R O U T I N E =======================================
DOSBIOS:2C33
DOSBIOS:2C33
DOSBIOS:2C33 readbootsec     proc near		     ; CODE XREF: GetBp+Dp
DOSBIOS:2C33		     mov     dh, 0	     ; read in the boot	sector.	set carry if error in reading sector.
DOSBIOS:2C33					     ; bx is set to 1 if the boot sector is invalid, otherwise it is 0.
DOSBIOS:2C35		     mov     cx, 1	     ; head 0
DOSBIOS:2C35					     ; cylinder	0, sector 1
DOSBIOS:2C38		     call    read_sector
DOSBIOS:2C3B		     jb	     short err_ret
DOSBIOS:2C3D		     xor     bx, bx	     ; assume valid boot sector
DOSBIOS:2C3F		     cmp     ds:disksector, 69h	; is it	a direct jump?
DOSBIOS:2C44		     jz	     short check_bpb_mediabyte ; don't need to find a nop
DOSBIOS:2C46		     cmp     ds:disksector, 0E9h ; dos 2.0 jump?
DOSBIOS:2C4B		     jz	     short check_bpb_mediabyte ; no need for nop
DOSBIOS:2C4D		     cmp     ds:disksector, 0EBh ; how about a short jump?
DOSBIOS:2C52		     jnz     short invalidbootsec
DOSBIOS:2C54		     cmp     ds:disksector+2, 90h ; is next one	a nop?
DOSBIOS:2C59		     jnz     short invalidbootsec
DOSBIOS:2C5B
DOSBIOS:2C5B check_bpb_mediabyte:		     ; CODE XREF: readbootsec+11j
DOSBIOS:2C5B					     ; readbootsec+18j
DOSBIOS:2C5B		     mov     al, ds:disksector+15h ;
DOSBIOS:2C5B					     ; [disksector+EXT_BOOT.BPB+EBPB.MEDIADESCRIPTOR]
DOSBIOS:2C5E		     and     al, 0F0h
DOSBIOS:2C60		     cmp     al, 0F0h	     ; allow for strange media
DOSBIOS:2C62		     jnz     short invalidbootsec
DOSBIOS:2C64
DOSBIOS:2C64 checksinglesided:
DOSBIOS:2C64		     mov     al, ds:disksector+15h
DOSBIOS:2C67		     cmp     al, 0F0h
DOSBIOS:2C69		     jz	     short gooddsk
DOSBIOS:2C6B		     test    al, 1
DOSBIOS:2C6D		     jnz     short gooddsk
DOSBIOS:2C6F		     cmp     word ptr ds:disksector+8, 2E33h ; "3."
DOSBIOS:2C75		     jnz     short mustbeearlier
DOSBIOS:2C77		     cmp     ds:disksector+0Ah,	32h ; "2"
DOSBIOS:2C7C		     jnb     short gooddsk
DOSBIOS:2C7E
DOSBIOS:2C7E mustbeearlier:			     ; CODE XREF: readbootsec+42j
DOSBIOS:2C7E		     mov     ds:disksector+0Dh,	1 ;
DOSBIOS:2C7E					     ; [disksector+EXT_BOOT.BPB+EBPB.SECTORSPERCLUSTER]
DOSBIOS:2C83		     jmp     short gooddsk
DOSBIOS:2C85 ; ---------------------------------------------------------------------------
DOSBIOS:2C85
DOSBIOS:2C85 invalidbootsec:			     ; CODE XREF: readbootsec+1Fj
DOSBIOS:2C85					     ; readbootsec+26j	...
DOSBIOS:2C85		     inc     bx
DOSBIOS:2C86
DOSBIOS:2C86 gooddsk:				     ; CODE XREF: readbootsec+36j
DOSBIOS:2C86					     ; readbootsec+3Aj	...
DOSBIOS:2C86		     clc
DOSBIOS:2C87		     retn
DOSBIOS:2C88 ; ---------------------------------------------------------------------------
DOSBIOS:2C88
DOSBIOS:2C88 err_ret:				     ; CODE XREF: readbootsec+8j
DOSBIOS:2C88		     retn
DOSBIOS:2C88 readbootsec     endp
DOSBIOS:2C88
DOSBIOS:2C89
DOSBIOS:2C89 ; =============== S U B R O U T I N E =======================================
DOSBIOS:2C89
DOSBIOS:2C89
DOSBIOS:2C89 movbpb	     proc near		     ; CODE XREF: GetBp+16p
DOSBIOS:2C89		     mov     dh, ds:disksector+0Dh ;
DOSBIOS:2C89					     ; disksector+EXT_BOOT.BPB+EBPB.SECTORSPERCLUSTER]
DOSBIOS:2C89					     ; sectors per unit
DOSBIOS:2C8D		     mov     bh, ds:disksector+11h ;
DOSBIOS:2C8D					     ; [disksector+EXT_BOOT.BPB+EBPB.ROOTENTRIES]
DOSBIOS:2C8D					     ; number of directory entries
DOSBIOS:2C91		     mov     cx, word ptr ds:disksector+13h ;
DOSBIOS:2C91					     ; [disksector+EXT_BOOT.BPB+EBPB.TOTALSECTORS]
DOSBIOS:2C91					     ; size of drive
DOSBIOS:2C95		     mov     ah, ds:disksector+15h ;
DOSBIOS:2C95					     ; [disksector+EXT_BOOT.BPB+EBPB.MEDIADESCRIPTOR]
DOSBIOS:2C95					     ; media descriptor
DOSBIOS:2C99		     mov     al, ds:disksector+16h ;
DOSBIOS:2C99					     ; [disksector+EXT_BOOT.BPB+EBPB.SECTORSPERFAT]
DOSBIOS:2C99					     ; number of fat sectors
DOSBIOS:2C9C		     mov     bl, ds:disksector+18h ;
DOSBIOS:2C9C					     ; [disksector+EXT_BOOT.BPB+EBPB.SECTORSPERTRACK]
DOSBIOS:2C9C					     ; sectors per track
DOSBIOS:2CA0		     mov     dl, ds:disksector+1Ah ;
DOSBIOS:2CA0					     ; [disksector+EXT_BOOT.BPB+EBPB.HEADS]
DOSBIOS:2CA0					     ; number of heads
DOSBIOS:2CA4		     cmp     ds:set_id_flag, 1 ; called	by get_bpb?
DOSBIOS:2CA9		     jnz     short movbpb_ret
DOSBIOS:2CAB		     call    mov_media_ids
DOSBIOS:2CAE		     jb	     short movbpb_conv ; conventional boot record?
DOSBIOS:2CB0		     mov     ds:set_id_flag, 2 ; signals that volume id	is set
DOSBIOS:2CB5
DOSBIOS:2CB5 movbpb_conv:			     ; CODE XREF: movbpb+25j
DOSBIOS:2CB5		     cmp     ds:fhave96, 1
DOSBIOS:2CBA		     jnz     short movbpb_ret
DOSBIOS:2CBC		     call    resetchanged    ; reset flags in bds to not fchanged.
DOSBIOS:2CBF
DOSBIOS:2CBF movbpb_ret:			     ; CODE XREF: movbpb+20j
DOSBIOS:2CBF					     ; movbpb+31j
DOSBIOS:2CBF		     clc
DOSBIOS:2CC0		     retn
DOSBIOS:2CC0 movbpb	     endp
DOSBIOS:2CC0
DOSBIOS:2CC1
DOSBIOS:2CC1 ; =============== S U B R O U T I N E =======================================
DOSBIOS:2CC1
DOSBIOS:2CC1
DOSBIOS:2CC1 mov_media_ids   proc near		     ; CODE XREF: movbpb+22p
DOSBIOS:2CC1					     ; DOSBIOS:377Fp
DOSBIOS:2CC1		     cmp     ds:disksector+26h,	29h ; [disksector+EXT_BOOT.SIG]
DOSBIOS:2CC1					     ; EXT_BOOT_SIGNATURE
DOSBIOS:2CC6		     jnz     short mmi_not_ext
DOSBIOS:2CC8		     push    cx
DOSBIOS:2CC9		     mov     cx, word ptr ds:disksector+27h ;
DOSBIOS:2CC9					     ; [disksector+EXT_BOOT.SERIAL]
DOSBIOS:2CCD		     mov     es:[di+57h], cx ; [es:di+BDS.vol_serial]
DOSBIOS:2CD1		     mov     cx, word ptr ds:disksector+29h ;
DOSBIOS:2CD1					     ; [disksector+EXT_BOOT.SERIAL+2]
DOSBIOS:2CD5		     mov     es:[di+59h], cx ; [es:di+BDS.vol_serial+2]
DOSBIOS:2CD9		     push    di
DOSBIOS:2CDA		     push    si
DOSBIOS:2CDB		     mov     cx, 11	     ; size_of_EXT_BOOT_VOL_LABEL
DOSBIOS:2CDE		     mov     si, (offset disksector+2Bh) ;
DOSBIOS:2CDE					     ; disksector+EXT_BOOT.VOL_LABEL
DOSBIOS:2CE1		     add     di, 75	     ; BDS.volid
DOSBIOS:2CE4		     rep movsb
DOSBIOS:2CE6		     mov     cx, 8	     ; size_of_EXT_SYSTEM_ID
DOSBIOS:2CE9		     mov     si, (offset disksector+36h) ; disksector+EXT_BOOT.SYSTEM_ID
DOSBIOS:2CEC		     add     di, 5	     ; (BDS.filesys_id-BDS.volid)-size_of_EXT_BOOT_VOL_LABEL
DOSBIOS:2CEF		     rep movsb
DOSBIOS:2CF1		     pop     si
DOSBIOS:2CF2		     pop     di
DOSBIOS:2CF3		     pop     cx
DOSBIOS:2CF4		     clc		     ; this clc	is not required	(16/06/2019 - Erdogan Tan)
DOSBIOS:2CF4					     ; (20/09/2022)
DOSBIOS:2CF5		     retn
DOSBIOS:2CF6 ; ---------------------------------------------------------------------------
DOSBIOS:2CF6
DOSBIOS:2CF6 mmi_not_ext:			     ; CODE XREF: mov_media_ids+5j
DOSBIOS:2CF6		     stc
DOSBIOS:2CF7		     retn
DOSBIOS:2CF7 mov_media_ids   endp
DOSBIOS:2CF7
DOSBIOS:2CF8
DOSBIOS:2CF8 ; =============== S U B R O U T I N E =======================================
DOSBIOS:2CF8
DOSBIOS:2CF8
DOSBIOS:2CF8 readfat	     proc near		     ; CODE XREF: GetBp:dofatbpbp
DOSBIOS:2CF8		     mov     dh, 0
DOSBIOS:2CFA		     mov     cx, 2	     ; head 0
DOSBIOS:2CFA					     ; cylinder	0, sector 2
DOSBIOS:2CFD		     call    read_sector
DOSBIOS:2D00		     jb	     short bad_fat_ret
DOSBIOS:2D02		     mov     ah, [bx]	     ; media byte
DOSBIOS:2D04
DOSBIOS:2D04 bad_fat_ret:			     ; CODE XREF: readfat+8j
DOSBIOS:2D04		     retn
DOSBIOS:2D04 readfat	     endp
DOSBIOS:2D04
DOSBIOS:2D05
DOSBIOS:2D05 ; =============== S U B R O U T I N E =======================================
DOSBIOS:2D05
DOSBIOS:2D05
DOSBIOS:2D05 read_sector     proc near		     ; CODE XREF: readbootsec+5p
DOSBIOS:2D05					     ; readfat+5p ...
DOSBIOS:2D05		     push    bp
DOSBIOS:2D06		     mov     bp, 3	     ; make 3 attempts
DOSBIOS:2D09		     mov     dl, es:[di+4]   ; [es:di+BDS.drivenum]
DOSBIOS:2D0D		     mov     bx, offset	disksector ;
DOSBIOS:2D0D					     ; get es:bx to point to buffer
DOSBIOS:2D10
DOSBIOS:2D10 rd_ret:				     ; CODE XREF: read_sector+20j
DOSBIOS:2D10		     push    es
DOSBIOS:2D11		     push    ds
DOSBIOS:2D12		     pop     es
DOSBIOS:2D13		     mov     ax, 201h
DOSBIOS:2D16		     int     13h	     ; DISK - READ SECTORS INTO	MEMORY
DOSBIOS:2D16					     ; AL = number of sectors to read, CH = track, CL =	sector
DOSBIOS:2D16					     ; DH = head, DL = drive, ES:BX -> buffer to fill
DOSBIOS:2D16					     ; Return: CF set on error,	AH = status, AL	= number of sectors read
DOSBIOS:2D18		     pop     es
DOSBIOS:2D19		     jnb     short okret2
DOSBIOS:2D1B
DOSBIOS:2D1B rd_rty:				     ; CODE XREF: read_sector+5Dj
DOSBIOS:2D1B		     call    again	     ; reset disk, decrement bp, preserve ax
DOSBIOS:2D1E		     jz	     short err_rd_ret
DOSBIOS:2D20		     test    byte ptr es:[di+23h], 1 ; [es:di+BDS.flags]
DOSBIOS:2D20					     ; fnon_removable
DOSBIOS:2D25		     jnz     short rd_ret
DOSBIOS:2D27		     cmp     ds:media_set_for_format, 0
DOSBIOS:2D2C		     jnz     short rd_skip1_dpt
DOSBIOS:2D2E		     push    ax
DOSBIOS:2D2F		     push    ds		     ; for retry, set the head settle time to 0Fh
DOSBIOS:2D30		     lds     si, ds:dpt
DOSBIOS:2D34		     mov     al, [si+9]	     ; [si+DISK_PARMS.DISK_HEAD_STTL]
DOSBIOS:2D37		     mov     byte ptr [si+9], 15 ; [si+DISK_PARMS.DISK_HEAD_STTL]
DOSBIOS:2D37					     ; NORMSETTLE
DOSBIOS:2D3B		     pop     ds
DOSBIOS:2D3C		     mov     ds:save_head_sttl,	al
DOSBIOS:2D3F		     pop     ax
DOSBIOS:2D40
DOSBIOS:2D40 rd_skip1_dpt:			     ; CODE XREF: read_sector+27j
DOSBIOS:2D40		     push    es
DOSBIOS:2D41		     push    ds
DOSBIOS:2D42		     pop     es
DOSBIOS:2D43		     mov     ax, 201h
DOSBIOS:2D46		     int     13h	     ; DISK - READ SECTORS INTO	MEMORY
DOSBIOS:2D46					     ; AL = number of sectors to read, CH = track, CL =	sector
DOSBIOS:2D46					     ; DH = head, DL = drive, ES:BX -> buffer to fill
DOSBIOS:2D46					     ; Return: CF set on error,	AH = status, AL	= number of sectors read
DOSBIOS:2D48		     pop     es
DOSBIOS:2D49		     pushf
DOSBIOS:2D4A		     cmp     ds:media_set_for_format, 0
DOSBIOS:2D4F		     jnz     short rd_skip2_dpt
DOSBIOS:2D51		     push    ax
DOSBIOS:2D52		     mov     al, ds:save_head_sttl
DOSBIOS:2D55		     push    ds
DOSBIOS:2D56		     lds     si, ds:dpt
DOSBIOS:2D5A		     mov     [si+9], al	     ; [si+DISK_PARMS.DISK_HEAD_STTL]
DOSBIOS:2D5D		     pop     ds
DOSBIOS:2D5E		     pop     ax
DOSBIOS:2D5F
DOSBIOS:2D5F rd_skip2_dpt:			     ; CODE XREF: read_sector+4Aj
DOSBIOS:2D5F		     popf
DOSBIOS:2D60		     jnb     short okret2
DOSBIOS:2D62		     jmp     short rd_rty
DOSBIOS:2D64 ; ---------------------------------------------------------------------------
DOSBIOS:2D64
DOSBIOS:2D64 err_rd_ret:			     ; CODE XREF: read_sector+19j
DOSBIOS:2D64		     mov     dl, 0FFh	     ; make sure we ask	rom if media has changed
DOSBIOS:2D64					     ; return error
DOSBIOS:2D66		     stc
DOSBIOS:2D67
DOSBIOS:2D67 okret2:				     ; CODE XREF: read_sector+14j
DOSBIOS:2D67					     ; read_sector+5Bj
DOSBIOS:2D67		     mov     ds:step_drv, dl ; set up for head settle logic in disk
DOSBIOS:2D6B		     mov     ds:tim_drv, dl  ; save drive last accessed
DOSBIOS:2D6F		     mov     es:[di+46h], ch ; [es:di+BDS.track]
DOSBIOS:2D6F					     ; save last track accessed	on this	drive
DOSBIOS:2D6F					     ; preserve	flags in case error occurred
DOSBIOS:2D73		     pushf
DOSBIOS:2D74		     call    set_tim
DOSBIOS:2D77		     popf		     ; restore flags
DOSBIOS:2D78		     pop     bp
DOSBIOS:2D79		     retn
DOSBIOS:2D79 read_sector     endp
DOSBIOS:2D79
DOSBIOS:2D7A ; ---------------------------------------------------------------------------
DOSBIOS:2D7A
DOSBIOS:2D7A dsk_open:				     ; 2C7h:80Ah = 70h:2D7Ah
DOSBIOS:2D7A		     cmp     ds:fhave96, 0
DOSBIOS:2D7F		     jz	     short dsk_open_exit ; done	if no changeline support
DOSBIOS:2D81		     call    SetDrive	     ; get bds for drive
DOSBIOS:2D84		     inc     word ptr es:[di+20h] ; [es:di+BDS.opcnt]
DOSBIOS:2D88
DOSBIOS:2D88 dsk_open_exit:			     ; CODE XREF: DOSBIOS:2D7Fj
DOSBIOS:2D88		     clc		     ; CF is already ZERO here (18/09/2022, MSDOS 5.0 IO.SYS)
DOSBIOS:2D88					     ; (19/07/2019 - Erdogan Tan - MSDOS 6.0 IO.SYS - retrodos4.s)
DOSBIOS:2D89		     retn
DOSBIOS:2D8A ; ---------------------------------------------------------------------------
DOSBIOS:2D8A
DOSBIOS:2D8A dsk_close:				     ; 2C7h:81Ah = 70h:2D8Ah
DOSBIOS:2D8A		     cmp     ds:fhave96, 0
DOSBIOS:2D8F		     jz	     short exitjx    ; done if no changeline support
DOSBIOS:2D91		     call    SetDrive	     ; get bds for drive
DOSBIOS:2D94		     cmp     word ptr es:[di+20h], 0 ; [es:di+BDS.opcnt]
DOSBIOS:2D99		     jz	     short exitjx    ; watch out for wrap
DOSBIOS:2D9B		     dec     word ptr es:[di+20h]
DOSBIOS:2D9F
DOSBIOS:2D9F exitjx:				     ; CODE XREF: DOSBIOS:2D8Fj
DOSBIOS:2D9F					     ; DOSBIOS:2D99j
DOSBIOS:2D9F		     clc		     ; CF is already ZERO here (18/09/2022, MSDOS 5.0 IO.SYS)
DOSBIOS:2D9F					     ; (19/07/2019 - Erdogan Tan - MSDOS 6.0 IO.SYS - retrodos4.s)
DOSBIOS:2DA0		     retn
DOSBIOS:2DA1 ; ---------------------------------------------------------------------------
DOSBIOS:2DA1
DOSBIOS:2DA1 dsk_rem:				     ; 2C7h:831h = 70h:2DA1h
DOSBIOS:2DA1		     call    SetDrive	     ; al is unit #
DOSBIOS:2DA4		     test    byte ptr es:[di+23h], 1
DOSBIOS:2DA9		     jnz     short x_bus_exit ;	non_rem
DOSBIOS:2DAB		     clc
DOSBIOS:2DAC		     retn
DOSBIOS:2DAD ; ---------------------------------------------------------------------------
DOSBIOS:2DAD
DOSBIOS:2DAD x_bus_exit:			     ; CODE XREF: DOSBIOS:2DA9j
DOSBIOS:2DAD		     mov     ah, 3	     ; 2C7h:83Dh = 0070h:2DADh
DOSBIOS:2DAD					     ; return busy status
DOSBIOS:2DAF		     stc
DOSBIOS:2DB0
DOSBIOS:2DB0 dsk_ret:				     ; CODE XREF: DOSBIOS:dsk_ioj
DOSBIOS:2DB0		     retn
DOSBIOS:2DB1 ; ---------------------------------------------------------------------------
DOSBIOS:2DB1
DOSBIOS:2DB1 dsk_writv:				     ; 2C7h:841h = 70h:2DB1h
DOSBIOS:2DB1		     mov     word ptr ds:rflag,	103h ; write and verify
DOSBIOS:2DB7		     jmp     short dsk_cl
DOSBIOS:2DB9 ; ---------------------------------------------------------------------------
DOSBIOS:2DB9
DOSBIOS:2DB9 dsk_writ:				     ; 2C7h:849h = 70h:2DB9h
DOSBIOS:2DB9		     mov     word ptr ds:rflag,	3 ; romwrite
DOSBIOS:2DBF
DOSBIOS:2DBF dsk_cl:				     ; CODE XREF: DOSBIOS:2DB7j
DOSBIOS:2DBF		     call    diskio	     ; romwrite
DOSBIOS:2DC2 ; ---------------------------------------------------------------------------
DOSBIOS:2DC2
DOSBIOS:2DC2 dsk_io:				     ; CODE XREF: DOSBIOS:2DCAj
DOSBIOS:2DC2		     jnb     short dsk_ret
DOSBIOS:2DC4		     jmp     bc_err_cnt
DOSBIOS:2DC7 ; ---------------------------------------------------------------------------
DOSBIOS:2DC7
DOSBIOS:2DC7 dsk_read:				     ; ; 2C7h:857h = 70h:2DC7h
DOSBIOS:2DC7		     call    diskrd
DOSBIOS:2DCA		     jmp     short dsk_io
DOSBIOS:2DCC
DOSBIOS:2DCC ; =============== S U B R O U T I N E =======================================
DOSBIOS:2DCC
DOSBIOS:2DCC
DOSBIOS:2DCC checksingle     proc near		     ; CODE XREF: diskio+79p
DOSBIOS:2DCC					     ; DOSBIOS:3249p ...
DOSBIOS:2DCC		     push    ax
DOSBIOS:2DCD		     push    bx
DOSBIOS:2DCE		     mov     bx, es:[di+23h] ; [es:di+BDS.flags]
DOSBIOS:2DD2		     test    bl, 21h	     ; fnon_removable|fi_own_physical
DOSBIOS:2DD5		     jnz     short singleret
DOSBIOS:2DD7		     test    bl, 10h	     ; fi_am_mult
DOSBIOS:2DD7					     ; is there	a drive	sharing	this physical drive?
DOSBIOS:2DDA		     jz	     short singleret
DOSBIOS:2DDC		     mov     al, es:[di+4]   ; [es:di+BDS.drivenum]
DOSBIOS:2DDC					     ; get physical drive number
DOSBIOS:2DE0		     push    es		     ; preserve	pointer	to current bds
DOSBIOS:2DE1		     push    di
DOSBIOS:2DE2		     les     di, ds:start_bds ;	get first bds
DOSBIOS:2DE6
DOSBIOS:2DE6 scan_list:				     ; CODE XREF: checksingle+79j
DOSBIOS:2DE6		     cmp     es:[di+4],	al
DOSBIOS:2DEA		     jnz     short scan_skip ; Not our drive. Try next bds.
DOSBIOS:2DEC		     mov     bl, 20h ; ' '   ; fi_own_physical ; test ownership flag
DOSBIOS:2DEE		     test    es:[di+23h], bl
DOSBIOS:2DF2		     jz	     short scan_skip ; he doesn't own it either. continue
DOSBIOS:2DF4		     xor     es:[di+23h], bl ; reset ownership flag
DOSBIOS:2DF8		     pop     di		     ; restore pointer to current bds
DOSBIOS:2DF9		     pop     es
DOSBIOS:2DFA		     or	     es:[di+23h], bl ; ; set ownership flag
DOSBIOS:2DFE		     cmp     ds:fsetowner, 1
DOSBIOS:2E03		     jnz     short not_fsetowner
DOSBIOS:2E05		     cmp     byte ptr es:[di+4], 0 ; are we handling drive number 0 ?
DOSBIOS:2E0A		     jnz     short singleret
DOSBIOS:2E0C		     mov     al, es:[di+5]   ; [es:di+BDS.drivelet]
DOSBIOS:2E0C					     ; get the DOS drive letter
DOSBIOS:2E10		     push    es
DOSBIOS:2E11		     mov     es, ds:zeroseg
DOSBIOS:2E15		     assume es:nothing
DOSBIOS:2E15		     mov     es:504h, al     ; [es:LSTDRV]
DOSBIOS:2E15					     ; set up sdsb
DOSBIOS:2E19		     pop     es		     ; restore bds pointer
DOSBIOS:2E1A		     assume es:nothing
DOSBIOS:2E1A		     jmp     short singleret
DOSBIOS:2E1C ; ---------------------------------------------------------------------------
DOSBIOS:2E1C
DOSBIOS:2E1C not_fsetowner:			     ; CODE XREF: checksingle+37j
DOSBIOS:2E1C		     cmp     ds:single,	2    ; if (single_drive_system)
DOSBIOS:2E21		     jnz     short ignore_sdsb
DOSBIOS:2E23		     push    ax
DOSBIOS:2E24		     mov     al, es:[di+5]   ; if (curr_drv == req_drv)
DOSBIOS:2E28		     mov     ah, al
DOSBIOS:2E2A		     push    es
DOSBIOS:2E2B		     mov     es, ds:zeroseg
DOSBIOS:2E2F		     assume es:nothing
DOSBIOS:2E2F		     xchg    al, es:504h     ; [es:LSTDRV] ; then swap(curr_drv,req_drv)
DOSBIOS:2E34		     pop     es
DOSBIOS:2E35		     assume es:nothing
DOSBIOS:2E35		     cmp     ah, al	     ; else
DOSBIOS:2E37		     pop     ax		     ; swap(curr_drv,req_drv)
DOSBIOS:2E38		     jz	     short singleret ; issue swap_dsk_msg
DOSBIOS:2E3A
DOSBIOS:2E3A ignore_sdsb:			     ; CODE XREF: checksingle+55j
DOSBIOS:2E3A		     call    swpdsk
DOSBIOS:2E3D		     jmp     short singleret
DOSBIOS:2E3F ; ---------------------------------------------------------------------------
DOSBIOS:2E3F
DOSBIOS:2E3F scan_skip:				     ; CODE XREF: checksingle+1Ej
DOSBIOS:2E3F					     ; checksingle+26j
DOSBIOS:2E3F		     les     di, es:[di]     ; [es:di+BDS.link]
DOSBIOS:2E3F					     ; go to next bds
DOSBIOS:2E42		     cmp     di, 0FFFFh	     ; end of list?
DOSBIOS:2E45		     jnz     short scan_list ; ontinue until hit end of	list
DOSBIOS:2E47		     stc
DOSBIOS:2E48		     pop     di		     ; restore current bds
DOSBIOS:2E49		     pop     es
DOSBIOS:2E4A
DOSBIOS:2E4A singleret:				     ; CODE XREF: checksingle+9j
DOSBIOS:2E4A					     ; checksingle+Ej ...
DOSBIOS:2E4A		     pop     bx
DOSBIOS:2E4B		     pop     ax
DOSBIOS:2E4C		     retn
DOSBIOS:2E4C checksingle     endp
DOSBIOS:2E4C
DOSBIOS:2E4D ; ---------------------------------------------------------------------------
DOSBIOS:2E4D ; START OF	FUNCTION CHUNK FOR diskio
DOSBIOS:2E4D
DOSBIOS:2E4D baddrive:				     ; CODE XREF: diskio+34j
DOSBIOS:2E4D					     ; diskio+3Aj ...
DOSBIOS:2E4D		     mov     al, 8	     ; sector not found
DOSBIOS:2E4F		     jmp     short baddrive_ret
DOSBIOS:2E51 ; ---------------------------------------------------------------------------
DOSBIOS:2E51
DOSBIOS:2E51 unformatteddrive:			     ; CODE XREF: diskio+17j
DOSBIOS:2E51		     mov     al, 7	     ; unknown media
DOSBIOS:2E53
DOSBIOS:2E53 baddrive_ret:			     ; CODE XREF: diskio-Bj
DOSBIOS:2E53		     stc
DOSBIOS:2E53 ; END OF FUNCTION CHUNK FOR diskio
DOSBIOS:2E54
DOSBIOS:2E54 ; =============== S U B R O U T I N E =======================================
DOSBIOS:2E54
DOSBIOS:2E54
DOSBIOS:2E54 ioret	     proc near		     ; CODE XREF: diskio+10j
DOSBIOS:2E54		     retn
DOSBIOS:2E54 ioret	     endp
DOSBIOS:2E54
DOSBIOS:2E55 ; ---------------------------------------------------------------------------
DOSBIOS:2E55
DOSBIOS:2E55 diskrd:				     ; CODE XREF: DOSBIOS:dsk_readp
DOSBIOS:2E55		     mov     ds:rflag, 2     ; romread
DOSBIOS:2E5A
DOSBIOS:2E5A ; =============== S U B R O U T I N E =======================================
DOSBIOS:2E5A
DOSBIOS:2E5A
DOSBIOS:2E5A diskio	     proc near		     ; CODE XREF: DOSBIOS:dsk_clp
DOSBIOS:2E5A					     ; BootIo+11p
DOSBIOS:2E5A
DOSBIOS:2E5A ; FUNCTION	CHUNK AT DOSBIOS:2E4D SIZE 00000007 BYTES
DOSBIOS:2E5A
DOSBIOS:2E5A		     mov     bx, di	     ; es:bx = transfer	address
DOSBIOS:2E5C		     mov     ds:xfer_seg, es ; save transfer segment
DOSBIOS:2E60		     call    SetDrive
DOSBIOS:2E63		     mov     al, es:[di+10h] ; [es:di+BDS.media]
DOSBIOS:2E67		     mov     ds:medbyt,	al
DOSBIOS:2E6A		     jcxz    short ioret
DOSBIOS:2E6C		     test    byte ptr es:[di+24h], 2 ; [es:di+BDS.flags+1]
DOSBIOS:2E6C					     ; unformatted_media
DOSBIOS:2E71		     jnz     short unformatteddrive
DOSBIOS:2E73		     mov     ds:seccnt,	cx   ; save sector count
DOSBIOS:2E77		     mov     ds:spsav, sp    ; save sp
DOSBIOS:2E7B		     mov     ax, dx
DOSBIOS:2E7D		     xor     si, si
DOSBIOS:2E7F		     add     dx, cx
DOSBIOS:2E81		     adc     si, 0
DOSBIOS:2E84		     cmp     word ptr es:[di+0Eh], 0 ; [es:di+BDS.totalsecs16]
DOSBIOS:2E84					     ; > 32 bit	sector ?
DOSBIOS:2E89		     jz	     short sanity32
DOSBIOS:2E8B		     cmp     si, 0
DOSBIOS:2E8E		     jnz     short baddrive
DOSBIOS:2E90		     cmp     dx, es:[di+0Eh] ; [es:di+BDS.totalsecs16]
DOSBIOS:2E94		     ja	     short baddrive
DOSBIOS:2E96		     jmp     short sanityok
DOSBIOS:2E98 ; ---------------------------------------------------------------------------
DOSBIOS:2E98
DOSBIOS:2E98 sanity32:				     ; CODE XREF: diskio+2Fj
DOSBIOS:2E98		     add     si, ds:start_sec_h
DOSBIOS:2E9C		     cmp     si, es:[di+1Dh] ; [es:di+BDS.totalsecs32+2]
DOSBIOS:2EA0		     jb	     short sanityok
DOSBIOS:2EA2		     ja	     short baddrive
DOSBIOS:2EA4		     cmp     dx, es:[di+1Bh] ; [es:di+BDS.totalsecs32]
DOSBIOS:2EA8		     ja	     short baddrive
DOSBIOS:2EAA
DOSBIOS:2EAA sanityok:				     ; CODE XREF: diskio+3Cj
DOSBIOS:2EAA					     ; diskio+46j
DOSBIOS:2EAA		     mov     dx, ds:start_sec_h
DOSBIOS:2EAE		     add     ax, es:[di+17h] ; [es:di+BDS.hiddensecs]
DOSBIOS:2EB2		     adc     dx, es:[di+19h] ; [es:di+BDS.hiddensecs+2]
DOSBIOS:2EB6		     mov     ds:saved_word, ax ; save the sector number	(low)
DOSBIOS:2EB9		     push    es
DOSBIOS:2EBA		     mov     es, ds:zeroseg
DOSBIOS:2EBE		     assume es:nothing
DOSBIOS:2EBE		     les     si, es:78h	     ; [es:DSKADR]
DOSBIOS:2EBE					     ; current disk parm table
DOSBIOS:2EC3		     assume es:nothing
DOSBIOS:2EC3		     mov     word ptr ds:dpt, si
DOSBIOS:2EC7		     mov     word ptr ds:dpt+2,	es
DOSBIOS:2ECB		     pop     es
DOSBIOS:2ECC		     test    byte ptr es:[di+23h], 1 ; [es:di+BDS.flags]
DOSBIOS:2ECC					     ; fnon_removable
DOSBIOS:2ED1		     jnz     short skip_setup
DOSBIOS:2ED3		     call    checksingle
DOSBIOS:2ED6		     cmp     ds:fhave96, 0   ; do we have changeline support?
DOSBIOS:2EDB		     jz	     short diskio_nochangeline ; brif not
DOSBIOS:2EDD		     call    checklatchio    ; will do a sneaky	pop stack return
DOSBIOS:2EDD					     ; if a disk error occurs
DOSBIOS:2EE0
DOSBIOS:2EE0 diskio_nochangeline:		     ; CODE XREF: diskio+81j
DOSBIOS:2EE0		     call    iosetup	     ; set up tables and variables for i/o
DOSBIOS:2EE3
DOSBIOS:2EE3 skip_setup:			     ; CODE XREF: diskio+77j
DOSBIOS:2EE3		     mov     ax, dx
DOSBIOS:2EE5		     xor     dx, dx
DOSBIOS:2EE7		     div     word ptr es:[di+13h] ; [es:di+BDS.secpertrack]
DOSBIOS:2EE7					     ; divide by sec per track
DOSBIOS:2EEB		     mov     ds:temp_h,	ax
DOSBIOS:2EEE		     mov     ax, ds:saved_word
DOSBIOS:2EF1		     div     word ptr es:[di+13h] ; [es:di+BDS.secpertrack]
DOSBIOS:2EF1					     ; now, [temp_h]:ax	= track	#, dx =	sector
DOSBIOS:2EF5		     inc     dl		     ; sector number is	1 based.
DOSBIOS:2EF7		     mov     ds:cursec,	dl   ; save current sector
DOSBIOS:2EFB		     mov     cx, es:[di+15h] ; es:di+BDS.heads]
DOSBIOS:2EFB					     ; get number of heads
DOSBIOS:2EFF		     push    ax
DOSBIOS:2F00		     xor     dx, dx
DOSBIOS:2F02		     mov     ax, ds:temp_h   ; divide tracks by	heads per cylinder
DOSBIOS:2F05		     div     cx
DOSBIOS:2F07		     mov     ds:temp_h,	ax
DOSBIOS:2F0A		     pop     ax
DOSBIOS:2F0B		     div     cx		     ; now, [temp_h]:ax	= cylinder #, dx = head
DOSBIOS:2F0D		     cmp     ds:temp_h,	0
DOSBIOS:2F12		     ja	     short baddrive_brdg
DOSBIOS:2F14		     cmp     ax, 1024	     ; 2^10 currently maxium for track #.
DOSBIOS:2F17		     ja	     short baddrive_brdg
DOSBIOS:2F19		     mov     ds:curhd, dl    ; save current head
DOSBIOS:2F1D		     mov     ds:curtrk,	ax   ; save current track
DOSBIOS:2F20		     mov     ax, ds:seccnt
DOSBIOS:2F23		     call    block	     ; (cas - call/ret)
DOSBIOS:2F26		     call    done
DOSBIOS:2F29		     retn
DOSBIOS:2F2A ; ---------------------------------------------------------------------------
DOSBIOS:2F2A
DOSBIOS:2F2A baddrive_brdg:			     ; CODE XREF: diskio+B8j
DOSBIOS:2F2A					     ; diskio+BDj
DOSBIOS:2F2A		     jmp     baddrive
DOSBIOS:2F2A diskio	     endp ; sp-analysis	failed
DOSBIOS:2F2A
DOSBIOS:2F2D
DOSBIOS:2F2D ; =============== S U B R O U T I N E =======================================
DOSBIOS:2F2D
DOSBIOS:2F2D
DOSBIOS:2F2D iosetup	     proc near		     ; CODE XREF: diskio:diskio_nochangelinep
DOSBIOS:2F2D					     ; TrackIo+10p
DOSBIOS:2F2D		     mov     al, es:[di+4]   ; [es:di+BDS.drivenum]
DOSBIOS:2F31		     mov     ds:tim_drv, al
DOSBIOS:2F34		     cmp     ds:media_set_for_format, 0
DOSBIOS:2F39		     jnz     short skip_dpt_setting
DOSBIOS:2F3B		     mov     al, ds:eot	     ; fetch up	eot before changing ds
DOSBIOS:2F3E		     push    ds
DOSBIOS:2F3F		     lds     si, ds:dpt	     ; get pointer to disk base	table
DOSBIOS:2F43		     mov     [si+4], al
DOSBIOS:2F46		     mov     al, [si+10]     ; [si+DISK_PARMS.DISK_MOTOR_STRT]
DOSBIOS:2F49		     mov     ah, [si+4]	     ; [si+DISK_PARMS.DISK_EOT]
DOSBIOS:2F4C		     pop     ds
DOSBIOS:2F4D		     mov     ds:motorstartup, al
DOSBIOS:2F50		     mov     ds:save_eot, ah
DOSBIOS:2F54		     push    ds
DOSBIOS:2F55		     lds     si, ds:dpt
DOSBIOS:2F59		     cmp     byte ptr es:[di+22h], 2 ; [es:di+BDS.formfactor]
DOSBIOS:2F59					     ; ffSmall
DOSBIOS:2F5E		     jnz     short motor_start_ok
DOSBIOS:2F60		     mov     al, 4
DOSBIOS:2F62		     xchg    al, [si+10]     ; [si+DISK_PARMS.DISK_MOTOR_STRT]
DOSBIOS:2F65
DOSBIOS:2F65 motor_start_ok:			     ; CODE XREF: iosetup+31j
DOSBIOS:2F65		     xor     al, al
DOSBIOS:2F67		     inc     al		     ; ibm wants fast settle to	be 1
DOSBIOS:2F69		     xchg    al, [si+9]	     ; [si+DISK_PARMS.DISK_HEAD_STTL]
DOSBIOS:2F69					     ; get settle and set up for fast
DOSBIOS:2F6C		     pop     ds
DOSBIOS:2F6D		     mov     ds:settlecurrent, al
DOSBIOS:2F70		     mov     al, 15	     ; NORMSETTLE
DOSBIOS:2F70					     ; someone has diddled the settle
DOSBIOS:2F72		     mov     ds:settleslow, al
DOSBIOS:2F75
DOSBIOS:2F75 skip_dpt_setting:			     ; CODE XREF: iosetup+Cj
DOSBIOS:2F75		     retn
DOSBIOS:2F75 iosetup	     endp
DOSBIOS:2F75
DOSBIOS:2F76
DOSBIOS:2F76 ; =============== S U B R O U T I N E =======================================
DOSBIOS:2F76
DOSBIOS:2F76
DOSBIOS:2F76 done	     proc near		     ; CODE XREF: diskio+CCp
DOSBIOS:2F76					     ; TrackIo+7Fp
DOSBIOS:2F76		     test    byte ptr es:[di+23h], 1 ; [es:di+BDS.flags]
DOSBIOS:2F76					     ; fnon_removable
DOSBIOS:2F7B		     jnz     short ddbx	     ; do not set for non-removable media
DOSBIOS:2F7D		     call    set_tim
DOSBIOS:2F80
DOSBIOS:2F80 diddleback:			     ; CODE XREF: Disk+13Aj
DOSBIOS:2F80		     pushf
DOSBIOS:2F81		     cmp     ds:media_set_for_format, 0
DOSBIOS:2F86		     jnz     short nodiddleback
DOSBIOS:2F88		     push    ax
DOSBIOS:2F89		     push    es
DOSBIOS:2F8A		     les     si, ds:dpt
DOSBIOS:2F8E		     mov     al, ds:save_eot
DOSBIOS:2F91		     mov     es:[si+4],	al   ; [es:si+DISK_PARMS.DISK_EOT]
DOSBIOS:2F95		     mov     al, ds:settlecurrent
DOSBIOS:2F98		     mov     ah, ds:motorstartup
DOSBIOS:2F9C		     mov     es:[si+9],	al   ; [es:si+DISK_PARMS.DISK_HEAD_STTL]
DOSBIOS:2FA0		     mov     byte ptr es:[si+3], 2 ; [es:si+DISK_PARMS.DISK_SECTOR_SIZ]
DOSBIOS:2FA5		     mov     es:[si+0Ah], ah ; [es:si+DISK_PARMS.DISK_MOTOR_STRT]
DOSBIOS:2FA9		     pop     es
DOSBIOS:2FAA		     pop     ax
DOSBIOS:2FAB
DOSBIOS:2FAB nodiddleback:			     ; CODE XREF: done+10j
DOSBIOS:2FAB		     popf
DOSBIOS:2FAC
DOSBIOS:2FAC ddbx:				     ; CODE XREF: done+5j
DOSBIOS:2FAC					     ; block+2j
DOSBIOS:2FAC		     retn
DOSBIOS:2FAC done	     endp
DOSBIOS:2FAC
DOSBIOS:2FAD
DOSBIOS:2FAD ; =============== S U B R O U T I N E =======================================
DOSBIOS:2FAD
DOSBIOS:2FAD
DOSBIOS:2FAD block	     proc near		     ; CODE XREF: diskio+C9p
DOSBIOS:2FAD					     ; block+39j
DOSBIOS:2FAD		     or	     ax, ax
DOSBIOS:2FAF		     jz	     short ddbx
DOSBIOS:2FB1		     test    byte ptr es:[di+23h], 1 ; [es:di+BDS.flags]
DOSBIOS:2FB1					     ; fnon_removable
DOSBIOS:2FB6		     jz	     short block_floppy	;
DOSBIOS:2FB6					     ; check to	see if multi track operation is	allowed. if not
DOSBIOS:2FB6					     ; we have to go to	the block_floppy below to break	up the operation.
DOSBIOS:2FB8		     test    byte ptr ds:multrk_flag, 80h ; multrk_on
DOSBIOS:2FBD		     jz	     short block_floppy
DOSBIOS:2FBF		     call    Disk
DOSBIOS:2FC2		     xor     ax, ax
DOSBIOS:2FC4		     retn
DOSBIOS:2FC5 ; ---------------------------------------------------------------------------
DOSBIOS:2FC5
DOSBIOS:2FC5 block_floppy:			     ; CODE XREF: block+9j
DOSBIOS:2FC5					     ; block+10j
DOSBIOS:2FC5		     mov     cl, es:[di+19]  ; read at most 1 track worth.
DOSBIOS:2FC5					     ; perform minimization at sector /	track
DOSBIOS:2FC5					     ; [es:di+BDS.secpertrack]
DOSBIOS:2FC9		     inc     cl
DOSBIOS:2FCB		     sub     cl, ds:cursec
DOSBIOS:2FCF		     xor     ch, ch
DOSBIOS:2FD1		     cmp     ax, cx
DOSBIOS:2FD3		     jnb     short gotmin
DOSBIOS:2FD5		     mov     cx, ax
DOSBIOS:2FD7
DOSBIOS:2FD7 gotmin:				     ; CODE XREF: block+26j
DOSBIOS:2FD7		     push    ax
DOSBIOS:2FD8		     push    cx
DOSBIOS:2FD9		     mov     ax, cx
DOSBIOS:2FDB		     call    Disk
DOSBIOS:2FDE		     pop     cx
DOSBIOS:2FDF		     pop     ax
DOSBIOS:2FE0		     sub     ax, cx	     ; reduce sectors-remaining	by last	i/o
DOSBIOS:2FE2		     shl     cl, 1
DOSBIOS:2FE4		     add     bh, cl	     ; adjust transfer address
DOSBIOS:2FE6		     jmp     short block
DOSBIOS:2FE6 block	     endp
DOSBIOS:2FE6
DOSBIOS:2FE8 ; ---------------------------------------------------------------------------
DOSBIOS:2FE8 ; START OF	FUNCTION CHUNK FOR Disk
DOSBIOS:2FE8
DOSBIOS:2FE8 dskerr_brdg:			     ; CODE XREF: Disk:testerrj
DOSBIOS:2FE8		     jmp     dskerr
DOSBIOS:2FE8 ; END OF FUNCTION CHUNK FOR Disk
DOSBIOS:2FEB
DOSBIOS:2FEB ; =============== S U B R O U T I N E =======================================
DOSBIOS:2FEB
DOSBIOS:2FEB
DOSBIOS:2FEB Disk	     proc near		     ; CODE XREF: block+12p
DOSBIOS:2FEB					     ; block+2Ep ...
DOSBIOS:2FEB
DOSBIOS:2FEB ; FUNCTION	CHUNK AT DOSBIOS:2FE8 SIZE 00000003 BYTES
DOSBIOS:2FEB
DOSBIOS:2FEB		     mov     bp, 5	     ; MAXERR
DOSBIOS:2FEB					     ; set up retry count
DOSBIOS:2FEE		     test    byte ptr es:[di+23h], 1 ;
DOSBIOS:2FEE					     ; [es:di+BDS.flags], fnon_removable
DOSBIOS:2FF3		     jz	     short GetRdWrInd
DOSBIOS:2FF5		     cmp     ah, 4	     ; romverify ; Is this a track verify?
DOSBIOS:2FF8		     jz	     short GetRdWrInd
DOSBIOS:2FFA		     mov     bp, 2	     ; This is verify so only 1	retry
DOSBIOS:2FFD
DOSBIOS:2FFD GetRdWrInd:			     ; CODE XREF: Disk+8j
DOSBIOS:2FFD					     ; Disk+Dj
DOSBIOS:2FFD		     mov     ds:vretry_cnt, bp ;
DOSBIOS:2FFD					     ; verify op. retry	cnt for	write-verify
DOSBIOS:3001		     mov     ds:soft_ecc_cnt, bp ; soft	ecc error retry	count.
DOSBIOS:3005		     mov     ah, ds:rflag    ; get read/write indicator
DOSBIOS:3009
DOSBIOS:3009 retry:				     ; CODE XREF: Disk+122j
DOSBIOS:3009		     push    ax
DOSBIOS:300A		     mov     dx, ds:curtrk
DOSBIOS:300E		     test    byte ptr es:[di+23h], 1
DOSBIOS:3013		     jz	     short disk_not_mini
DOSBIOS:3015		     cmp     word ptr es:[di+47h], 1 ; [es:di+BDS.bdsm_ismini]
DOSBIOS:3015					     ; is this a mini disk? ((logical dos partition))
DOSBIOS:301A		     jnz     short disk_not_mini ; no. continue	to next.
DOSBIOS:301C		     add     dx, es:[di+49h] ; [es:di+BDS.bdsm_hidden_trks]
DOSBIOS:301C					     ; add hidden trks.
DOSBIOS:3020
DOSBIOS:3020 disk_not_mini:			     ; CODE XREF: Disk+28j
DOSBIOS:3020					     ; Disk+2Fj
DOSBIOS:3020		     ror     dh, 1
DOSBIOS:3022		     ror     dh, 1
DOSBIOS:3024		     or	     dh, ds:cursec
DOSBIOS:3028		     mov     cx, dx
DOSBIOS:302A		     xchg    ch, cl	     ;	cl = sector, ch	= cylinder
DOSBIOS:302C		     mov     dh, ds:curhd    ; load current head number	and
DOSBIOS:3030		     mov     dl, es:[di+4]   ; physical	drive number
DOSBIOS:3030					     ; [es:di+BDS.drivenum]
DOSBIOS:3034		     cmp     byte ptr es:[di+22h], 5 ; [es:di+BDS.formfactor], ffHardFile
DOSBIOS:3039		     jz	     short do_fast   ; hard files use fast speed
DOSBIOS:303B		     cmp     ds:step_drv, 0FFh ; -1
DOSBIOS:3040		     jz	     short do_writej
DOSBIOS:3042		     cmp     ah, 2	     ; romread
DOSBIOS:3045		     jz	     short do_fast
DOSBIOS:3047		     cmp     ah, 4	     ; romverify
DOSBIOS:304A		     jz	     short do_fast
DOSBIOS:304C
DOSBIOS:304C do_writej:				     ; CODE XREF: Disk+55j
DOSBIOS:304C		     jmp     short do_write  ; reads always fast
DOSBIOS:304E ; ---------------------------------------------------------------------------
DOSBIOS:304E
DOSBIOS:304E do_fast:				     ; CODE XREF: Disk+4Ej
DOSBIOS:304E					     ; Disk+5Aj ...
DOSBIOS:304E		     call    fastspeed	     ; change settle mode
DOSBIOS:3051
DOSBIOS:3051 testerr:				     ; CODE XREF: Disk+C8j
DOSBIOS:3051		     jb	     short dskerr_brdg
DOSBIOS:3053		     mov     ds:step_drv, dl
DOSBIOS:3057		     mov     es:[di+46h], ch ; [es:di+BDS.track]
DOSBIOS:305B		     cmp     word ptr ds:rflag,	103h ; check for write and verify
DOSBIOS:3061		     jz	     short doverify
DOSBIOS:3063
DOSBIOS:3063 noverify:				     ; CODE XREF: Disk+D1j
DOSBIOS:3063					     ; Disk+DCj
DOSBIOS:3063		     pop     ax
DOSBIOS:3064		     test    byte ptr es:[di+23h], 1 ; [es:di+BDS.flags]
DOSBIOS:3064					     ; fnon_removable
DOSBIOS:3069		     jz	     short its_removable
DOSBIOS:306B		     test    byte ptr ds:multrk_flag, 80h ; multrk_on
DOSBIOS:3070		     jnz     short disk_ret
DOSBIOS:3072
DOSBIOS:3072 its_removable:			     ; CODE XREF: Disk+7Ej
DOSBIOS:3072		     and     cl, 3Fh	     ; eliminate cylinder bits from sector
DOSBIOS:3075		     xor     ah, ah
DOSBIOS:3077		     sub     ds:seccnt,	ax   ; reduce count of sectors to go next sector
DOSBIOS:307B		     add     cl, al
DOSBIOS:307D		     mov     ds:cursec,	cl
DOSBIOS:3081		     cmp     cl, es:[di+13h] ; [es:di+BDS.secpertrack]
DOSBIOS:3081					     ; see if sector/track limit reached
DOSBIOS:3085		     jbe     short disk_ret
DOSBIOS:3087		     mov     ds:cursec,	1    ; start with first	sector of next track
DOSBIOS:308C		     mov     dh, ds:curhd
DOSBIOS:3090		     inc     dh
DOSBIOS:3092		     cmp     dh, es:[di+15h] ; [es:di+BDS.heads]
DOSBIOS:3096		     jb	     short noxor
DOSBIOS:3098		     xor     dh, dh
DOSBIOS:309A		     inc     ds:curtrk
DOSBIOS:309E
DOSBIOS:309E noxor:				     ; CODE XREF: Disk+ABj
DOSBIOS:309E		     mov     ds:curhd, dh
DOSBIOS:30A2
DOSBIOS:30A2 disk_ret:				     ; CODE XREF: Disk+85j
DOSBIOS:30A2					     ; Disk+9Aj
DOSBIOS:30A2		     clc
DOSBIOS:30A3		     retn
DOSBIOS:30A4 ; ---------------------------------------------------------------------------
DOSBIOS:30A4
DOSBIOS:30A4 do_write:				     ; CODE XREF: Disk:do_writejj
DOSBIOS:30A4		     cmp     dl, ds:step_drv
DOSBIOS:30A8		     jnz     short do_norm   ; we have changed drives
DOSBIOS:30AA		     cmp     ch, es:[di+46h] ; [es:di+BDS.track]
DOSBIOS:30AE		     jz	     short do_fast   ; we are still on the same	track
DOSBIOS:30B0
DOSBIOS:30B0 do_norm:				     ; CODE XREF: Disk+BDj
DOSBIOS:30B0		     call    normspeed
DOSBIOS:30B3		     jmp     short testerr
DOSBIOS:30B5 ; ---------------------------------------------------------------------------
DOSBIOS:30B5
DOSBIOS:30B5 doverify:				     ; CODE XREF: Disk+76j
DOSBIOS:30B5		     pop     ax
DOSBIOS:30B6		     push    ax
DOSBIOS:30B7		     mov     ah, 4
DOSBIOS:30B9		     call    fastspeed
DOSBIOS:30BC		     jnb     short noverify
DOSBIOS:30BE		     cmp     ah, 11h	     ; soft ecc	error ?
DOSBIOS:30C1		     jnz     short not_softecc_err
DOSBIOS:30C3		     dec     ds:soft_ecc_cnt
DOSBIOS:30C7		     jz	     short noverify  ; no more retry
DOSBIOS:30C9		     call    ResetDisk	     ; reset disk
DOSBIOS:30CC		     jmp     short dskerr1   ; retry
DOSBIOS:30CE ; ---------------------------------------------------------------------------
DOSBIOS:30CE
DOSBIOS:30CE not_softecc_err:			     ; CODE XREF: Disk+D6j
DOSBIOS:30CE		     call    ResetDisk
DOSBIOS:30D1		     dec     ds:vretry_cnt
DOSBIOS:30D5		     jmp     short dskerr0
DOSBIOS:30D7 ; ---------------------------------------------------------------------------
DOSBIOS:30D7
DOSBIOS:30D7 dskerr:				     ; CODE XREF: Disk:dskerr_brdgj
DOSBIOS:30D7		     cmp     ds:fhave96, 0   ; do we have changeline support?
DOSBIOS:30DC		     jz	     short dskerr_nochangeline ; brif not
DOSBIOS:30DE		     call    checkio
DOSBIOS:30E1
DOSBIOS:30E1 dskerr_nochangeline:		     ; CODE XREF: Disk+F1j
DOSBIOS:30E1		     cmp     ds:multitrk_format_flag, 1	; multi	trk format request?
DOSBIOS:30E6		     jnz     short dochkagain ;	no more	retry.
DOSBIOS:30E8		     mov     bp, 1
DOSBIOS:30EB		     mov     ds:multitrk_format_flag, 0	; clear	the flag.
DOSBIOS:30F0
DOSBIOS:30F0 dochkagain:			     ; CODE XREF: Disk+FBj
DOSBIOS:30F0		     call    again
DOSBIOS:30F3
DOSBIOS:30F3 dskerr0:				     ; CODE XREF: Disk+EAj
DOSBIOS:30F3		     jz	     short harderr
DOSBIOS:30F5		     test    byte ptr es:[di+23h], 1 ; [es:di+BDS.flags]
DOSBIOS:30F5					     ; fnon_removable
DOSBIOS:30FA		     jnz     short skip_timeout_chk
DOSBIOS:30FC		     cmp     ah, 80h	     ; timeout?
DOSBIOS:30FF		     jz	     short harderr
DOSBIOS:3101
DOSBIOS:3101 skip_timeout_chk:			     ; CODE XREF: Disk+10Fj
DOSBIOS:3101		     cmp     ah, 0CCh	     ; write fault error?
DOSBIOS:3104		     jz	     short write_fault_err ; then, don't retry.
DOSBIOS:3106		     mov     ds:soft_ecc_cnt, 5	; MAXERR
DOSBIOS:3106					     ; set soft_ecc_cnt	back to	maxerr
DOSBIOS:310C
DOSBIOS:310C dskerr1:				     ; CODE XREF: Disk+E1j
DOSBIOS:310C					     ; Disk+128j
DOSBIOS:310C		     pop     ax		     ; restore sector count
DOSBIOS:310D		     jmp     retry
DOSBIOS:3110 ; ---------------------------------------------------------------------------
DOSBIOS:3110
DOSBIOS:3110 write_fault_err:			     ; CODE XREF: Disk+119j
DOSBIOS:3110		     mov     bp, 1	     ; just retry only once
DOSBIOS:3110					     ; for write fault error.
DOSBIOS:3113		     jmp     short dskerr1
DOSBIOS:3115 ; ---------------------------------------------------------------------------
DOSBIOS:3115
DOSBIOS:3115 harderr:				     ; CODE XREF: Disk:dskerr0j
DOSBIOS:3115					     ; Disk+114j ...
DOSBIOS:3115		     call    maperror
DOSBIOS:3118
DOSBIOS:3118 harderr2:				     ; CODE XREF: DOSBIOS:no_error_mapj
DOSBIOS:3118		     mov     ds:tim_drv, 0FFh ;	force a	media check through rom
DOSBIOS:311D		     mov     cx, ds:seccnt   ; get count of sectors to go
DOSBIOS:3121		     mov     sp, ds:spsav    ; recover entry stack pointer
DOSBIOS:3125		     jmp     diddleback	     ; restore the disk	parameters
DOSBIOS:3125 Disk	     endp
DOSBIOS:3125
DOSBIOS:3128
DOSBIOS:3128 ; =============== S U B R O U T I N E =======================================
DOSBIOS:3128
DOSBIOS:3128
DOSBIOS:3128 normspeed	     proc near		     ; CODE XREF: Disk:do_normp
DOSBIOS:3128		     cmp     ds:media_set_for_format, 0
DOSBIOS:312D		     jnz     short fastspeed
DOSBIOS:312F		     push    es
DOSBIOS:3130		     push    ax
DOSBIOS:3131		     mov     al, ds:settleslow
DOSBIOS:3134		     les     si, ds:dpt	     ; current disk parm table
DOSBIOS:3138		     mov     es:[si+9],	al   ; [es:si+DISK_PARMS.DISK_HEAD_STTL]
DOSBIOS:313C		     pop     ax
DOSBIOS:313D		     pop     es
DOSBIOS:313E		     call    fastspeed
DOSBIOS:3141		     push    es
DOSBIOS:3142		     les     si, ds:dpt
DOSBIOS:3146		     mov     byte ptr es:[si+9], 1 ; [es:si+DISK_PARMS.DISK_HEAD_STTL]
DOSBIOS:3146					     ; 1 is fast settle	value
DOSBIOS:314B		     pop     es
DOSBIOS:314C		     retn
DOSBIOS:314C normspeed	     endp
DOSBIOS:314C
DOSBIOS:314D
DOSBIOS:314D ; =============== S U B R O U T I N E =======================================
DOSBIOS:314D
DOSBIOS:314D
DOSBIOS:314D fastspeed	     proc near		     ; CODE XREF: Disk:do_fastp
DOSBIOS:314D					     ; Disk+CEp ...
DOSBIOS:314D		     test    byte ptr es:[di+1Fh], 80h ; if the	drive has been marked as too big
DOSBIOS:314D					     ; (i.e. starting sector of	the partition is > 16 bits),
DOSBIOS:314D					     ; then always return drive	not ready.
DOSBIOS:314D					     ;
DOSBIOS:314D					     ; [es:di+BDS.fatsiz]
DOSBIOS:314D					     ; ftoobig
DOSBIOS:3152		     jnz     short notready
DOSBIOS:3154		     push    es
DOSBIOS:3155		     mov     es, ds:xfer_seg
DOSBIOS:3159		     int     13h	     ; DISK -
DOSBIOS:315B		     mov     ds:xfer_seg, es
DOSBIOS:315F		     pop     es
DOSBIOS:3160		     retn
DOSBIOS:3161 ; ---------------------------------------------------------------------------
DOSBIOS:3161
DOSBIOS:3161 notready:				     ; CODE XREF: fastspeed+5j
DOSBIOS:3161		     stc
DOSBIOS:3162		     mov     ah, 80h
DOSBIOS:3164		     retn
DOSBIOS:3164 fastspeed	     endp
DOSBIOS:3164
DOSBIOS:3165
DOSBIOS:3165 ; =============== S U B R O U T I N E =======================================
DOSBIOS:3165
DOSBIOS:3165
DOSBIOS:3165 maperror	     proc near		     ; CODE XREF: DOSBIOS:err_exitjp
DOSBIOS:3165					     ; GetBp+AEp ...
DOSBIOS:3165		     push    cx
DOSBIOS:3166		     push    es
DOSBIOS:3167		     push    ds		     ; set es=Bios_Data
DOSBIOS:3168		     pop     es
DOSBIOS:3169		     mov     al, ah	     ; put error code in al
DOSBIOS:316B		     mov     ds:lsterr,	al   ; terminate list with error code
DOSBIOS:316E		     mov     cx, 9	     ; numerr (= errout-errin)
DOSBIOS:316E					     ; number of possible error	conditions
DOSBIOS:3171		     mov     di, offset	errin ;	point to error conditions
DOSBIOS:3174		     repne scasb
DOSBIOS:3176		     mov     al, [di+8]	     ; [di+numerr-1]
DOSBIOS:3176					     ; get translation
DOSBIOS:317A		     pop     es
DOSBIOS:317B		     pop     cx
DOSBIOS:317C		     stc		     ; flag error condition
DOSBIOS:317D		     retn
DOSBIOS:317D maperror	     endp
DOSBIOS:317D
DOSBIOS:317E
DOSBIOS:317E ; =============== S U B R O U T I N E =======================================
DOSBIOS:317E
DOSBIOS:317E
DOSBIOS:317E set_tim	     proc near		     ; CODE XREF: read_sector+6Fp
DOSBIOS:317E					     ; done+7p
DOSBIOS:317E		     push    ax		     ; set the time of last access for this drive.
DOSBIOS:317E					     ; this is done only for removable media.
DOSBIOS:317E					     ; es:di ->	bds
DOSBIOS:317F		     call    GetTickCnt	     ; Does INT	1A ah=0	& updates daycnt
DOSBIOS:317F					     ;
DOSBIOS:317F					     ; we have the new time.
DOSBIOS:317F					     ; if we see that the time has passed,
DOSBIOS:317F					     ; then we reset the threshold counter
DOSBIOS:3182		     cmp     dx, es:[di+47h] ; [es:di+BDS.tim_lo]
DOSBIOS:3186		     jnz     short setaccess
DOSBIOS:3188		     cmp     cx, es:[di+49h] ; [es:di+BDS.tim_hi]
DOSBIOS:318C		     jz	     short done_set
DOSBIOS:318E
DOSBIOS:318E setaccess:				     ; CODE XREF: set_tim+8j
DOSBIOS:318E		     mov     ds:accesscount, 0
DOSBIOS:3193		     mov     es:[di+47h], dx ; [es:di+BDS.tim_lo]
DOSBIOS:3197		     mov     es:[di+49h], cx ; [es:di+BDS.tim_hi]
DOSBIOS:319B
DOSBIOS:319B done_set:				     ; CODE XREF: set_tim+Ej
DOSBIOS:319B		     clc
DOSBIOS:319C		     pop     ax
DOSBIOS:319D		     retn
DOSBIOS:319D set_tim	     endp
DOSBIOS:319D
DOSBIOS:319E
DOSBIOS:319E ; =============== S U B R O U T I N E =======================================
DOSBIOS:319E
DOSBIOS:319E
DOSBIOS:319E again	     proc near		     ; CODE XREF: read_sector:rd_rtyp
DOSBIOS:319E					     ; Disk:dochkagainp
DOSBIOS:319E		     call    ResetDisk
DOSBIOS:31A1		     cmp     ah, 6
DOSBIOS:31A4		     jz	     short dont_dec_retry_count	; If it	is a media change error
DOSBIOS:31A4					     ; do not decrement	retry count.
DOSBIOS:31A6		     dec     bp		     ; decrement retry count
DOSBIOS:31A7		     retn
DOSBIOS:31A8 ; ---------------------------------------------------------------------------
DOSBIOS:31A8
DOSBIOS:31A8 dont_dec_retry_count:		     ; CODE XREF: again+6j
DOSBIOS:31A8		     or	     ah, ah
DOSBIOS:31AA		     retn
DOSBIOS:31AA again	     endp
DOSBIOS:31AA
DOSBIOS:31AA ; ---------------------------------------------------------------------------
DOSBIOS:31AB		     db	   0
DOSBIOS:31AC IoReadJumpTable db	8
DOSBIOS:31AD		     dw	0CA7h		     ; GetDeviceParameters
DOSBIOS:31AF		     dw	0EE8h		     ; ReadTrack
DOSBIOS:31B1		     dw	0E86h		     ; VerifyTrack
DOSBIOS:31B3		     dw	0CA3h		     ; Cmd_Error_Proc
DOSBIOS:31B5		     dw	0CA3h		     ; Cmd_Error_Proc
DOSBIOS:31B7		     dw	0CA3h		     ; Cmd_Error_Proc
DOSBIOS:31B9		     dw	119Ah		     ; GetMediaId
DOSBIOS:31BB		     dw	1269h		     ; GetAccessFlag
DOSBIOS:31BD		     dw	12C1h		     ; SenseMediaType
DOSBIOS:31BF IoWriteJumpTable db 7
DOSBIOS:31C0		     dw	0CF3h		     ; SetDeviceParameters
DOSBIOS:31C2		     dw	0EEFh		     ; WriteTrack
DOSBIOS:31C4		     dw	0DC1h		     ; FormatTrack
DOSBIOS:31C6		     dw	0CA3h		     ; Cmd_Error_Proc
DOSBIOS:31C8		     dw	0CA3h		     ; Cmd_Error_Proc
DOSBIOS:31CA		     dw	0CA3h		     ; Cmd_Error_Proc
DOSBIOS:31CC		     dw	11D2h		     ; SetMediaId
DOSBIOS:31CE		     dw	1280h		     ; SetAccessFlag
DOSBIOS:31D0 IOC_DC_Table    db	60h		     ; GET_DEVICE_PARAMETERS
DOSBIOS:31D1		     db	40h		     ; SET_DEVICE_PARAMETERS
DOSBIOS:31D2		     db	61h		     ; READ_TRACK
DOSBIOS:31D3		     db	41h		     ; WRITE_TRACK
DOSBIOS:31D4		     db	62h		     ; VERIFY_TRACK
DOSBIOS:31D5		     db	42h		     ; FORMAT_TRACK
DOSBIOS:31D6		     db	66h		     ; GET_MEDIA_ID
DOSBIOS:31D7		     db	46h		     ; SET_MEDIA_ID
DOSBIOS:31D8		     db	67h		     ; GET_ACCESS_FLAG
DOSBIOS:31D9		     db	47h		     ; SET_ACCESS_FLAG
DOSBIOS:31DA		     db	68h		     ; SENSE_MEDIA_TYPE
DOSBIOS:31DB ; ---------------------------------------------------------------------------
DOSBIOS:31DB
DOSBIOS:31DB do_generic_ioctl:			     ; 2C7h:0C6Bh = 70h:31DBh
DOSBIOS:31DB		     call    SetDrive	     ; ES:DI Points to bds for drive
DOSBIOS:31DE		     push    es
DOSBIOS:31DF		     les     bx, ds:ptrsav   ; ES:BX Points to request header
DOSBIOS:31E3		     cmp     byte ptr es:[bx+0Dh], 8 ; [es:bx+IOCTL_REQ.MAJORFUNCTION]
DOSBIOS:31E3					     ; RAWIO
DOSBIOS:31E8		     mov     al, es:[bx+0Eh] ; [es:bx+IOCTL_REQ.MINORFUNCTION]
DOSBIOS:31EC		     pop     es
DOSBIOS:31ED		     jnz     short IoctlFuncErr
DOSBIOS:31EF		     mov     si, 0C3Ch	     ; IoReadJumpTable
DOSBIOS:31EF					     ; at 2C7h:0C3Ch = 70h:31ACh
DOSBIOS:31F2		     test    al, 20h	     ; GEN_IOCTL_FN_TST	; test of req. function
DOSBIOS:31F4		     jnz     short NotGenericWrite
DOSBIOS:31F6		     mov     si, 0C4Fh	     ; IoWriteJumpTable
DOSBIOS:31F6					     ; at 2C7h:0C4Fh = 70h:31BFh
DOSBIOS:31F9
DOSBIOS:31F9 NotGenericWrite:			     ; CODE XREF: DOSBIOS:31F4j
DOSBIOS:31F9		     and     al, 0DFh	     ; ~GEN_IOCTL_FN_TST ; get rid of read/write bit
DOSBIOS:31FB		     sub     al, 40h	     ; offset for base function
DOSBIOS:31FD		     cmp     al, cs:[si]
DOSBIOS:3200		     ja	     short IoctlFuncErr
DOSBIOS:3202		     cbw
DOSBIOS:3203		     shl     ax, 1
DOSBIOS:3205		     inc     si
DOSBIOS:3206		     add     si, ax
DOSBIOS:3208		     call    word ptr cs:[si]
DOSBIOS:320B		     mov     ds, word ptr cs:aCon+3 ; [cs:Bios_Data_Word]
DOSBIOS:320B					     ; 2C7h:30h	= 70h:25A0h
DOSBIOS:3210		     assume ds:nothing
DOSBIOS:3210		     mov     ah, 81h	     ; Return this status in case of carry
DOSBIOS:3212		     retn		     ; Pass carry flag through to exit code
DOSBIOS:3213 ; ---------------------------------------------------------------------------
DOSBIOS:3213
DOSBIOS:3213 Cmd_Error_Proc:			     ; 2C7h:0CA3h = 70h:3213h
DOSBIOS:3213		     pop     dx
DOSBIOS:3214
DOSBIOS:3214 IoctlFuncErr:			     ; CODE XREF: DOSBIOS:31EDj
DOSBIOS:3214					     ; DOSBIOS:3200j
DOSBIOS:3214		     jmp     bc_cmderr
DOSBIOS:3217 ; ---------------------------------------------------------------------------
DOSBIOS:3217
DOSBIOS:3217 GetDeviceParameters:		     ; DS:BX points to request header
DOSBIOS:3217		     lds     bx, ds:ptrsav
DOSBIOS:321B		     assume ds:nothing
DOSBIOS:321B		     lds     bx, [bx+19]     ; [bx+IOCTL_REQ.GENERICIOCTL_PACKET]
DOSBIOS:321B					     ; (DS:BX) = return	buffer
DOSBIOS:321E		     mov     al, es:[di+34]  ; [es:di+BDS.formfactor]
DOSBIOS:3222		     mov     [bx+1], al	     ; [bx+A_DEVICEPARAMETERS.DP_DEVICETYPE]
DOSBIOS:3225		     mov     ax, es:[di+35]  ; [es:di+BDS.flags]
DOSBIOS:3229		     and     ax, 3	     ; fnon_removable+fchangeline
DOSBIOS:3229					     ; Mask off	other bits
DOSBIOS:322C		     mov     [bx+2], ax	     ; [bx+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES]
DOSBIOS:322F		     mov     ax, es:[di+37]  ; [es:di+BDS.cylinders]
DOSBIOS:3233		     mov     [bx+4], ax	     ; [bx+A_DEVICEPARAMETERS.DP_CYLINDERS]
DOSBIOS:3236		     xor     al, al	     ; Set media type to default
DOSBIOS:3238		     mov     [bx+6], al	     ; [bx+A_DEVICEPARAMETERS.DP_MEDIATYPE]
DOSBIOS:323B		     lea     si, [di+39]     ; [di+BDS.rbytespersec] = [di+BDS.R_BPB]
DOSBIOS:323B					     ; copy recommended	bpb
DOSBIOS:323E		     test    byte ptr [bx], 1 ;	[bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS]
DOSBIOS:323E					     ; BUILD_DEVICE_BPB
DOSBIOS:3241		     jz	     short UseBpbPresent
DOSBIOS:3243		     push    ds		     ; Save request packet segment
DOSBIOS:3244		     mov     ds, word ptr cs:aCon+3 ; [cs:Bios_Data_Word]
DOSBIOS:3244					     ; 2C7h:30h	= 70h:25A0h
DOSBIOS:3244					     ; Point back to Bios_Data
DOSBIOS:3249		     assume ds:nothing
DOSBIOS:3249		     call    checksingle
DOSBIOS:324C		     call    GetBp	     ; Build the bpb from scratch
DOSBIOS:324F		     pop     ds		     ; Restore request packet segment
DOSBIOS:3250		     assume ds:nothing
DOSBIOS:3250		     jb	     short GetParmRet
DOSBIOS:3252		     lea     si, [di+6]	     ; [di+BDS.bytespersec] = [di+BSD.DP_BPB]
DOSBIOS:3252					     ; Use this	subfield of bds	instead
DOSBIOS:3255
DOSBIOS:3255 UseBpbPresent:			     ; CODE XREF: DOSBIOS:3241j
DOSBIOS:3255		     lea     di, [bx+7]	     ; [bx+A_DEVICEPARAMETERS.DP_BPB]
DOSBIOS:3255					     ; This is where the result	goes
DOSBIOS:3258		     mov     cx, 25	     ; A_BPB.size - 6
DOSBIOS:3258					     ; For now use 'small' bpb
DOSBIOS:325B		     push    ds		     ; reverse segments	for copy
DOSBIOS:325C		     push    es
DOSBIOS:325D		     pop     ds
DOSBIOS:325E		     pop     es
DOSBIOS:325F		     rep movsb
DOSBIOS:3261		     clc
DOSBIOS:3262
DOSBIOS:3262 GetParmRet:			     ; CODE XREF: DOSBIOS:3250j
DOSBIOS:3262		     retn
DOSBIOS:3263 ; ---------------------------------------------------------------------------
DOSBIOS:3263
DOSBIOS:3263 SetDeviceParameters:		     ; 2C7h:0CF3h = 70h:3263h
DOSBIOS:3263		     lds     bx, ds:ptrsav   ; DS:BX points to request header
DOSBIOS:3267		     lds     bx, [bx+19]     ; [bx+IOCTL_REQ.GENERICIOCTL_PACKET]
DOSBIOS:326A		     or	     word ptr es:[di+23h], 140h	; [es:di+BDS.flags]
DOSBIOS:326A					     ; fchanged_by_format|fchanged
DOSBIOS:3270		     test    byte ptr [bx], 2 ;	[bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS]
DOSBIOS:3270					     ; ONLY_SET_TRACKLAYOUT
DOSBIOS:3273		     jnz     short setTrackTable
DOSBIOS:3275		     mov     al, [bx+1]	     ; [bx+A_DEVICEPARAMETERS.DP_DEVICETYPE]
DOSBIOS:3278		     mov     es:[di+34], al  ; [es:di+BDS.formfactor]
DOSBIOS:327C		     mov     ax, [bx+4]	     ; [bx+A_DEVICEPARAMETERS.DP_CYLINDERS]
DOSBIOS:327F		     mov     es:[di+37], ax  ; [es:di+BDS.cylinders]
DOSBIOS:3283		     mov     ax, [bx+2]	     ; [bx+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES]
DOSBIOS:3286		     push    ds
DOSBIOS:3287		     mov     ds, word ptr cs:aCon+3 ; [cs:Bios_Data_Word]
DOSBIOS:3287					     ; 2C7h:30h	= 70h:25A0h
DOSBIOS:328C		     assume ds:nothing
DOSBIOS:328C		     cmp     ds:fhave96, 0
DOSBIOS:3291		     pop     ds
DOSBIOS:3292		     assume ds:nothing
DOSBIOS:3292		     jnz     short HaveChange ;	we have	changeline support
DOSBIOS:3294		     and     ax, 0FFFDh	     ; ~fchangeline
DOSBIOS:3297
DOSBIOS:3297 HaveChange:			     ; CODE XREF: DOSBIOS:3292j
DOSBIOS:3297		     and     ax, 3	     ; fnon_removable|fchangeline
DOSBIOS:329A		     mov     cx, es:[di+35]  ; [es:di+BDS.flags]
DOSBIOS:329E		     and     cx, 0FDF4h	     ; ~(fnon_removable|fchangeline|good_tracklayout|unformatted_media)
DOSBIOS:32A2		     or	     ax, cx
DOSBIOS:32A4		     mov     es:[di+35], ax  ; [es:di+BDS.flags]
DOSBIOS:32A8		     mov     al, [bx+6]	     ; [bx+A_DEVICEPARAMETERS.DP_MEDIATYPE]
DOSBIOS:32A8					     ; Set media type
DOSBIOS:32AB		     push    ds
DOSBIOS:32AC		     mov     ds, word ptr cs:aCon+3 ; [cs:Bios_Data_Word]
DOSBIOS:32B1		     assume ds:nothing
DOSBIOS:32B1		     mov     ds:mediatype, al
DOSBIOS:32B4		     pop     ds
DOSBIOS:32B5		     assume ds:nothing
DOSBIOS:32B5		     or	     word ptr es:[di+35], 80h ;	[es:di+BDS.flags]
DOSBIOS:32B5					     ; set_dasd_true
DOSBIOS:32BB		     push    di		     ; Save bds	pointer
DOSBIOS:32BC		     test    byte ptr [bx], 1 ;	[bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS]
DOSBIOS:32BC					     ; INSTALL_FAKE_BPB
DOSBIOS:32BF		     jnz     short InstallFakeBpb
DOSBIOS:32C1		     test    word ptr es:[di+35], 4 ; [es:di+BDS.flags]
DOSBIOS:32C1					     ; return_fake_bpb
DOSBIOS:32C7		     jz	     short InstallRecommendedBpb
DOSBIOS:32C9		     and     word ptr es:[di+35], 0FFFBh ; [es:di+BDS.flags]
DOSBIOS:32C9					     ; ~return_fake_bpb
DOSBIOS:32CE
DOSBIOS:32CE InstallRecommendedBpb:		     ; CODE XREF: DOSBIOS:32C7j
DOSBIOS:32CE		     mov     cx, 31	     ; A_BPB.size
DOSBIOS:32D1		     lea     di, [di+27h]    ; [di+BDS.R_BPB] =	[di+BDS.rbytespersec]
DOSBIOS:32D4		     jmp     short CopyTheBpb
DOSBIOS:32D6 ; ---------------------------------------------------------------------------
DOSBIOS:32D6
DOSBIOS:32D6 InstallFakeBpb:			     ; CODE XREF: DOSBIOS:32BFj
DOSBIOS:32D6		     or	     word ptr es:[di+35], 4 ; byte [es:di+BDS.flags]
DOSBIOS:32D6					     ; return_fake_bpb
DOSBIOS:32DB		     mov     cx, 25	     ; A_BPB.size - 6
DOSBIOS:32DB					     ; move 'smaller' bpb
DOSBIOS:32DE		     lea     di, [di+6]	     ; [es:di+BDS.BPB] = [es:di+BDS.bytespersec]
DOSBIOS:32E1
DOSBIOS:32E1 CopyTheBpb:			     ; CODE XREF: DOSBIOS:32D4j
DOSBIOS:32E1		     lea     si, [bx+7]	     ; [bx+A_DEVICEPARAMETERS.DP_BPB]
DOSBIOS:32E4		     rep movsb
DOSBIOS:32E6		     push    ds		     ; Save packet segment
DOSBIOS:32E7		     mov     ds, word ptr cs:aCon+3 ; [cs:Bios_Data_Word]
DOSBIOS:32E7					     ; Setup for ds -> Bios_Data
DOSBIOS:32EC		     assume ds:nothing
DOSBIOS:32EC		     call    RestoreOldDpt   ; Restore the old Dpt from	TempDpt
DOSBIOS:32EF		     pop     ds		     ; Restore packet segment
DOSBIOS:32F0		     assume ds:nothing
DOSBIOS:32F0		     pop     di		     ; Restore bds pointer
DOSBIOS:32F1
DOSBIOS:32F1 setTrackTable:			     ; CODE XREF: DOSBIOS:3273j
DOSBIOS:32F1		     mov     cx, [bx+38]
DOSBIOS:32F4		     push    ds
DOSBIOS:32F5		     mov     ds, word ptr cs:aCon+3 ; [cs:Bios_Data_Word]
DOSBIOS:32FA		     assume ds:nothing
DOSBIOS:32FA		     mov     ds:sectorspertrack, cx
DOSBIOS:32FE		     pop     ds
DOSBIOS:32FF		     assume ds:nothing
DOSBIOS:32FF		     and     word ptr es:[di+35], 0FFF7h ; [es:di+BDS.flags]
DOSBIOS:32FF					     ; ~good_tracklayout
DOSBIOS:3304		     test    byte ptr [bx], 4 ;	[bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS]
DOSBIOS:3304					     ; TRACKLAYOUT_IS_GOOD
DOSBIOS:3307		     jz	     short UglyTrackLayOut
DOSBIOS:3309		     or	     word ptr es:[di+35], 8 ; [es:di+BDS.flags]
DOSBIOS:3309					     ; good_tracklayout
DOSBIOS:330E
DOSBIOS:330E UglyTrackLayOut:			     ; CODE XREF: DOSBIOS:3307j
DOSBIOS:330E		     cmp     cx, 63	     ; MAX_SECTORS_IN_TRACK
DOSBIOS:3311		     ja	     short TooManyPerTrack
DOSBIOS:3313		     jcxz    short SectorInfoSaved
DOSBIOS:3315		     mov     di, offset	tracktable
DOSBIOS:3318		     lea     si, [bx+40]     ; [bx+A_DEVICEPARAMETERS.DP_SECTORTABLE]
DOSBIOS:331B		     mov     es, word ptr cs:aCon+3 ; [cs:Bios_Data_Word]
DOSBIOS:331B					     ; Trash our bds pointer
DOSBIOS:3320		     assume es:nothing
DOSBIOS:3320
DOSBIOS:3320 StoreSectorInfo:			     ; CODE XREF: DOSBIOS:3329j
DOSBIOS:3320		     inc     di
DOSBIOS:3321		     inc     di		     ; Skip over cylinder and head
DOSBIOS:3322		     lodsw		     ; Get sector id
DOSBIOS:3323		     stosb		     ; Copy it
DOSBIOS:3324		     lodsw		     ; Get sector size
DOSBIOS:3325		     call    SectSizeToSectIndex
DOSBIOS:3328		     stosb		     ; Store sector SIZE index
DOSBIOS:3329		     loop    StoreSectorInfo
DOSBIOS:332B
DOSBIOS:332B SectorInfoSaved:			     ; CODE XREF: DOSBIOS:3313j
DOSBIOS:332B		     clc
DOSBIOS:332C		     retn
DOSBIOS:332D ; ---------------------------------------------------------------------------
DOSBIOS:332D
DOSBIOS:332D TooManyPerTrack:			     ; CODE XREF: DOSBIOS:3311j
DOSBIOS:332D		     mov     al, 0Ch
DOSBIOS:332F		     stc
DOSBIOS:3330		     retn
DOSBIOS:3331 ; ---------------------------------------------------------------------------
DOSBIOS:3331
DOSBIOS:3331 FormatTrack:
DOSBIOS:3331		     lds     bx, ds:ptrsav
DOSBIOS:3335		     lds     bx, [bx+19]     ; [bx+IOCTL_REQ.GENERICIOCTL_PACKET
DOSBIOS:3338		     test    byte ptr [bx], 1 ;	[bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS]
DOSBIOS:3338					     ; STATUS_FOR_FORMAT
DOSBIOS:333B		     jz	     short DoFormatTrack
DOSBIOS:333D		     push    ds
DOSBIOS:333E		     mov     ds, word ptr cs:aCon+3 ; [cs:Bios_Data_Word]
DOSBIOS:3343		     assume ds:nothing
DOSBIOS:3343		     call    SetMediaForFormat ; Also moves current Dpt	to TempDpt
DOSBIOS:3346		     pop     ds
DOSBIOS:3347		     assume ds:nothing
DOSBIOS:3347		     mov     [bx], al	     ; [bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS]
DOSBIOS:3349		     clc
DOSBIOS:334A		     retn
DOSBIOS:334B ; ---------------------------------------------------------------------------
DOSBIOS:334B
DOSBIOS:334B DoFormatTrack:			     ; CODE XREF: DOSBIOS:333Bj
DOSBIOS:334B		     cmp     byte ptr es:[di+34], 5 ; [es:di+BDS.formfactor]
DOSBIOS:334B					     ; DEV_HARDDISK
DOSBIOS:3350		     jnz     short DoFormatDiskette
DOSBIOS:3352		     mov     ds, word ptr cs:aCon+3 ; [cs:Bios_Data_Word]
DOSBIOS:3352					     ; Point to	Bios_Data (at 2C7h:30h or 70h:25A0h)
DOSBIOS:3357		     assume ds:nothing
DOSBIOS:3357		     jmp     VerifyTrack
DOSBIOS:335A ; ---------------------------------------------------------------------------
DOSBIOS:335A
DOSBIOS:335A DoFormatDiskette:			     ; CODE XREF: DOSBIOS:3350j
DOSBIOS:335A		     mov     cx, [bx+1]
DOSBIOS:335D		     mov     dx, [bx+3]
DOSBIOS:3360		     test    byte ptr [bx], 2
DOSBIOS:3363		     mov     ds, word ptr cs:aCon+3 ; [cs:Bios_Data_Word]
DOSBIOS:3363					     ; Setup ds-> Bios_Data for	verify
DOSBIOS:3368		     jz	     short DoFormatDiskette_1
DOSBIOS:336A		     jmp     VerifyTrack_Err
DOSBIOS:336D ; ---------------------------------------------------------------------------
DOSBIOS:336D
DOSBIOS:336D DoFormatDiskette_1:		     ; CODE XREF: DOSBIOS:3368j
DOSBIOS:336D		     call    SetMediaForFormat ; Also moves current Dpt	to TempDpt
DOSBIOS:3370		     cmp     al, 1	     ;	ROM support for	sec/trk,# trks comb?
DOSBIOS:3372		     jz	     short NeedToSetDasd ; Old rom
DOSBIOS:3374		     cmp     al, 3	     ; Time out	error?
DOSBIOS:3376		     jnz     short NoSetDasd ; No,fine.	(at this point,	don't care
DOSBIOS:3376					     ; about the illegal combination)
DOSBIOS:3378		     jmp     short FormatFailed
DOSBIOS:337A ; ---------------------------------------------------------------------------
DOSBIOS:337A
DOSBIOS:337A NeedToSetDasd:			     ; CODE XREF: DOSBIOS:3372j
DOSBIOS:337A		     push    dx
DOSBIOS:337B		     call    SetDasd	     ; INT 13h,	AH=17h
DOSBIOS:337E		     pop     dx
DOSBIOS:337F
DOSBIOS:337F NoSetDasd:				     ; CODE XREF: DOSBIOS:3376j
DOSBIOS:337F		     call    checksingle     ; Do any needed diskette swapping
DOSBIOS:3382		     mov     ax, dx	     ; Get track from packet
DOSBIOS:3384		     mov     ds:trknum,	ax
DOSBIOS:3387		     mov     ds:hdnum, cl    ; Store head from packet
DOSBIOS:338B		     mov     ah, cl
DOSBIOS:338D		     mov     bx, offset	tracktable
DOSBIOS:3390		     mov     cx, ds:sectorspertrack
DOSBIOS:3394
DOSBIOS:3394 StoreCylinderHead:			     ; CODE XREF: DOSBIOS:3399j
DOSBIOS:3394		     mov     [bx], ax	     ; Store into TrackTable
DOSBIOS:3396		     add     bx, 4	     ; Skip to next sector field
DOSBIOS:3399		     loop    StoreCylinderHead
DOSBIOS:339B		     mov     cx, 5	     ; MAXERR -	Set up retry count
DOSBIOS:339E
DOSBIOS:339E FormatRetry:			     ; CODE XREF: DOSBIOS:33DFj
DOSBIOS:339E		     push    cx
DOSBIOS:339F		     mov     bx, offset	tracktable
DOSBIOS:33A2		     mov     al, byte ptr ds:sectorspertrack
DOSBIOS:33A5		     mov     ah, 5	     ; romformat
DOSBIOS:33A7		     mov     ds:xfer_seg, ds
DOSBIOS:33AB		     call    ToRom
DOSBIOS:33AE		     pop     cx
DOSBIOS:33AF		     jb	     short FormatError
DOSBIOS:33B1		     push    cx		     ; Now verify the sectors just formatted.
DOSBIOS:33B1					     ; NOTE: because of	bug in some BIOSes we have to
DOSBIOS:33B1					     ;	     set ES:BX to 00:00
DOSBIOS:33B2		     push    bx
DOSBIOS:33B3		     xor     bx, bx
DOSBIOS:33B5		     mov     ds:xfer_seg, bx
DOSBIOS:33B9		     mov     al, byte ptr ds:sectorspertrack
DOSBIOS:33BC		     mov     ah, 4	     ; romverify
DOSBIOS:33BE		     mov     cl, 1
DOSBIOS:33C0		     call    ToRom
DOSBIOS:33C3		     pop     bx
DOSBIOS:33C4		     pop     cx
DOSBIOS:33C5		     jnb     short FormatOk
DOSBIOS:33C7
DOSBIOS:33C7 FormatError:			     ; CODE XREF: DOSBIOS:33AFj
DOSBIOS:33C7		     call    ResetDisk
DOSBIOS:33CA		     mov     ds:had_format_error, 1
DOSBIOS:33CF		     push    ax
DOSBIOS:33D0		     push    cx
DOSBIOS:33D1		     push    dx
DOSBIOS:33D2		     call    SetMediaForFormat
DOSBIOS:33D5		     cmp     al, 1
DOSBIOS:33D7		     jnz     short WhileErr
DOSBIOS:33D9		     call    SetDasd
DOSBIOS:33DC
DOSBIOS:33DC WhileErr:				     ; CODE XREF: DOSBIOS:33D7j
DOSBIOS:33DC		     pop     dx
DOSBIOS:33DD		     pop     cx
DOSBIOS:33DE		     pop     ax
DOSBIOS:33DF		     loop    FormatRetry
DOSBIOS:33E1
DOSBIOS:33E1 FormatFailed:			     ; CODE XREF: DOSBIOS:3378j
DOSBIOS:33E1		     mov     ds:had_format_error, 1 ; Set the format error flag
DOSBIOS:33E6		     cmp     ah, 6	     ; DSK_CHANGELINE_ERR - convert change line
DOSBIOS:33E9		     jnz     short DoMapIt   ; Error to	time out error
DOSBIOS:33EB		     mov     ah, 80h	     ; DSK_TIMEOUT_ERR
DOSBIOS:33ED
DOSBIOS:33ED DoMapIt:				     ; CODE XREF: DOSBIOS:33E9j
DOSBIOS:33ED		     jmp     maperror
DOSBIOS:33F0 ; ---------------------------------------------------------------------------
DOSBIOS:33F0
DOSBIOS:33F0 FormatOk:				     ; CODE XREF: DOSBIOS:33C5j
DOSBIOS:33F0		     mov     ds:had_format_error, 0 ; reset the	format error flag
DOSBIOS:33F5		     retn
DOSBIOS:33F6 ; ---------------------------------------------------------------------------
DOSBIOS:33F6
DOSBIOS:33F6 VerifyTrack:			     ; CODE XREF: DOSBIOS:3357j
DOSBIOS:33F6		     push    ds
DOSBIOS:33F7		     lds     bx, ds:ptrsav
DOSBIOS:33FB		     assume ds:nothing
DOSBIOS:33FB		     lds     bx, [bx+19]     ; [bx+IOCTL_REQ.GENERICIOCTL_PACKET]
DOSBIOS:33FE		     mov     cx, [bx+3]	     ; [bx+A_VERIFYPACKET.VP_CYLINDER]
DOSBIOS:3401		     mov     ax, [bx+1]	     ; [bx+A_VERIFYPACKET.VP_HEAD]
DOSBIOS:3404		     mov     dx, [bx+5]	     ; [bx+A_FORMATPACKET.FP_TRACKCOUNT]
DOSBIOS:3407		     mov     bl, [bx]	     ; [bx+A_FORMATPACKET.FP_SPECIALFUNCTIONS]
DOSBIOS:3407					     ; Get option flag word
DOSBIOS:3409		     pop     ds
DOSBIOS:340A		     mov     ds:rflag, 4     ; romverify
DOSBIOS:340F		     mov     ds:curtrk,	cx
DOSBIOS:3413		     mov     ds:curhd, al    ; ASSUME heads < 256
DOSBIOS:3416		     mov     cx, ds:sectorspertrack
DOSBIOS:341A		     test    bl, 2	     ; DO_FAST_FORMAT
DOSBIOS:341D		     jz	     short NormVerifyTrack
DOSBIOS:341F		     mov     ax, dx
DOSBIOS:3421		     or	     ah, ah
DOSBIOS:3423		     jnz     short VerifyTrack_Err
DOSBIOS:3425		     mul     cl
DOSBIOS:3427		     or	     ah, ah
DOSBIOS:3429		     jnz     short VerifyTrack_Err
DOSBIOS:342B		     mov     cx, ax
DOSBIOS:342D		     test    word ptr es:[di+35], 1 ; [es:di+BDS.flags]
DOSBIOS:342D					     ; fnon_removable
DOSBIOS:3433		     jz	     short NormVerifyTrack
DOSBIOS:3435		     test    ds:multrk_flag, 80h ; MULTI_TRK_ON
DOSBIOS:343B		     jz	     short NormVerifyTrack
DOSBIOS:343D		     mov     ds:multitrk_format_flag, 1
DOSBIOS:3442
DOSBIOS:3442 NormVerifyTrack:			     ; CODE XREF: DOSBIOS:341Dj
DOSBIOS:3442					     ; DOSBIOS:3433j ...
DOSBIOS:3442		     xor     ax, ax	     ;	1st sector
DOSBIOS:3444		     xor     bx, bx
DOSBIOS:3446		     mov     ds:xfer_seg, bx ; Use 0:0 as the transfer address for verify
DOSBIOS:344A		     call    TrackIo
DOSBIOS:344D		     mov     ds:multitrk_format_flag, 0
DOSBIOS:3452		     retn
DOSBIOS:3453 ; ---------------------------------------------------------------------------
DOSBIOS:3453
DOSBIOS:3453 VerifyTrack_Err:			     ; CODE XREF: DOSBIOS:336Aj
DOSBIOS:3453					     ; DOSBIOS:3423j ...
DOSBIOS:3453		     mov     ah, 1
DOSBIOS:3455		     jmp     maperror
DOSBIOS:3458 ; ---------------------------------------------------------------------------
DOSBIOS:3458
DOSBIOS:3458 ReadTrack:				     ; romread
DOSBIOS:3458		     mov     ds:rflag, 2
DOSBIOS:345D		     jmp     short ReadWriteTrack
DOSBIOS:345F ; ---------------------------------------------------------------------------
DOSBIOS:345F
DOSBIOS:345F WriteTrack:			     ; romwrite
DOSBIOS:345F		     mov     ds:rflag, 3
DOSBIOS:3464
DOSBIOS:3464 ReadWriteTrack:			     ; CODE XREF: DOSBIOS:345Dj
DOSBIOS:3464		     push    es
DOSBIOS:3465		     les     bx, ds:ptrsav   ; ES:BX ->	to request header
DOSBIOS:3469		     assume es:nothing
DOSBIOS:3469		     les     bx, es:[bx+19]  ; [es:bx+IOCTL_REQ.GENERICIOCTL_PACKET]
DOSBIOS:346D		     mov     ax, es:[bx+3]   ; [es:bx+A_TRACKREADWRITEPACKET.TRWP_CYLINDER]
DOSBIOS:3471		     mov     ds:curtrk,	ax
DOSBIOS:3474		     mov     ax, es:[bx+1]   ; [es:bx+A_TRACKREADWRITEPACKET.TRWP_HEAD]
DOSBIOS:3478		     mov     ds:curhd, al    ; Assume heads < 256!!!
DOSBIOS:347B		     mov     ax, es:[bx+5]   ; [es:bx+A_TRACKREADWRITEPACKET.TRWP_FIRSTSECTOR]
DOSBIOS:347F		     mov     cx, es:[bx+7]   ; [es:bx+A_TRACKREADWRITEPACKET.TRWP_SECTORSTOREADWRITE]
DOSBIOS:3483		     les     bx, es:[bx+9]   ; [es:bx+A_TRACKREADWRITEPACKET.TRWP_TRANSFERADDRESS]
DOSBIOS:3483					     ; Get transfer address
DOSBIOS:3487		     mov     ds:xfer_seg, es ; Pass transfer segment
DOSBIOS:348B		     pop     es
DOSBIOS:348C
DOSBIOS:348C ; =============== S U B R O U T I N E =======================================
DOSBIOS:348C
DOSBIOS:348C
DOSBIOS:348C TrackIo	     proc near		     ; CODE XREF: DOSBIOS:344Ap
DOSBIOS:348C		     mov     ds:spsav, sp    ; performs	track read/write/verify
DOSBIOS:348C					     ; Procedure `disk' will pop stack to
DOSBIOS:348C					     ; SpSav and return	if error
DOSBIOS:3490		     call    checksingle
DOSBIOS:3493		     cmp     ds:media_set_for_format, 1	; See if we have already set disk
DOSBIOS:3498		     jz	     short Dptalreadyset ; base	table
DOSBIOS:349A		     push    ax		     ; set up tables and variables for i/o
DOSBIOS:349B		     push    cx
DOSBIOS:349C		     call    iosetup
DOSBIOS:349F		     pop     cx
DOSBIOS:34A0		     pop     ax
DOSBIOS:34A1
DOSBIOS:34A1 Dptalreadyset:			     ; CODE XREF: TrackIo+Cj
DOSBIOS:34A1		     mov     si, offset	tracktable
DOSBIOS:34A4		     shl     ax, 1
DOSBIOS:34A6		     shl     ax, 1
DOSBIOS:34A8		     add     si, ax	     ; CX to be	the number of times we have to loop
DOSBIOS:34A8					     ; DX to be	the number of sectors we read on each iteration
DOSBIOS:34AA		     mov     dx, 1
DOSBIOS:34AD		     test    word ptr es:[di+35], 8 ; [es:di+BDS.flags]
DOSBIOS:34AD					     ; good_tracklayout
DOSBIOS:34B3		     jz	     short ionextsector
DOSBIOS:34B5		     xchg    dx, cx
DOSBIOS:34B7
DOSBIOS:34B7 ionextsector:			     ; CODE XREF: TrackIo+27j
DOSBIOS:34B7					     ; TrackIo+76j
DOSBIOS:34B7		     push    cx
DOSBIOS:34B8		     push    dx
DOSBIOS:34B9		     inc     si
DOSBIOS:34BA		     inc     si		     ; Skip over the cylinder and head in
DOSBIOS:34BA					     ; the track table
DOSBIOS:34BB		     lodsb		     ; Get sector ID from track	table
DOSBIOS:34BC		     mov     ds:cursec,	al   ; assumptions for a fixed disk multi-track	disk i/o
DOSBIOS:34BC					     ; 1). In the input	CX (# of sectors to go)	to TrackIo,
DOSBIOS:34BC					     ;	   only	CL is valid.
DOSBIOS:34BC					     ; 2). Sector size should be set to	512 bytes.
DOSBIOS:34BC					     ; 3). Good	track layout
DOSBIOS:34BF		     test    word ptr es:[di+35], 1 ; [es:di+BDS.flags]
DOSBIOS:34BF					     ; fnon_removable ;	Fixed disk?
DOSBIOS:34C5		     jz	     short IoRemovable ; No
DOSBIOS:34C7		     test    ds:multrk_flag, 80h ; MULTI_TRK_ON	- Allow	multi-track operation?
DOSBIOS:34CD		     jz	     short IoRemovable ; No,don't do that.
DOSBIOS:34CF		     mov     ds:seccnt,	dx
DOSBIOS:34D3		     mov     ax, dx
DOSBIOS:34D5		     call    Disk
DOSBIOS:34D8		     pop     dx
DOSBIOS:34D9		     pop     cx
DOSBIOS:34DA		     clc
DOSBIOS:34DB		     retn
DOSBIOS:34DC ; ---------------------------------------------------------------------------
DOSBIOS:34DC
DOSBIOS:34DC IoRemovable:			     ; CODE XREF: TrackIo+39j
DOSBIOS:34DC					     ; TrackIo+41j
DOSBIOS:34DC		     lodsb		     ; Get sector size index from track
DOSBIOS:34DC					     ; table and save it
DOSBIOS:34DD		     push    ax
DOSBIOS:34DE		     push    si
DOSBIOS:34DF		     push    ds		     ; Save Bios_Data
DOSBIOS:34E0		     push    ax
DOSBIOS:34E1		     mov     ah, ds:eot	     ; Preserve	whatever might be in ah
DOSBIOS:34E1					     ; Fetch EOT while ds-> Bios_Data
DOSBIOS:34E5		     lds     si, ds:dpt
DOSBIOS:34E9		     mov     [si+3], al	     ; [si+DISK_PARMS.DISK_SECTOR_SIZ]
DOSBIOS:34EC		     mov     [si+4], ah	     ; [si+DISK_PARMS.DISK_EOT]
DOSBIOS:34EF		     pop     ax
DOSBIOS:34F0		     pop     ds
DOSBIOS:34F1		     mov     al, dl
DOSBIOS:34F3		     mov     ds:seccnt,	ax
DOSBIOS:34F6		     call    Disk
DOSBIOS:34F9		     pop     si		     ; Advance buffer pointer by adding
DOSBIOS:34F9					     ; sector size
DOSBIOS:34FA		     pop     ax
DOSBIOS:34FB		     call    SectorSizeIndexToSectorSize
DOSBIOS:34FE		     add     bx, ax
DOSBIOS:3500		     pop     dx
DOSBIOS:3501		     pop     cx
DOSBIOS:3502		     loop    ionextsector
DOSBIOS:3504		     cmp     ds:media_set_for_format, 1
DOSBIOS:3509		     jz	     short NoNeedDone
DOSBIOS:350B		     call    done	     ; set time	of last	access,	and reset
DOSBIOS:350B					     ; entries in Dpt.
DOSBIOS:350E
DOSBIOS:350E NoNeedDone:			     ; CODE XREF: TrackIo+7Dj
DOSBIOS:350E		     clc
DOSBIOS:350F		     retn
DOSBIOS:350F TrackIo	     endp
DOSBIOS:350F
DOSBIOS:3510
DOSBIOS:3510 ; =============== S U B R O U T I N E =======================================
DOSBIOS:3510
DOSBIOS:3510
DOSBIOS:3510 SectSizeToSectIndex proc near	     ; CODE XREF: DOSBIOS:3325p
DOSBIOS:3510		     cmp     ah, 2	     ; (0=>128,1=>256,2=>512,3=>1024)
DOSBIOS:3510					     ; examine upper byte only
DOSBIOS:3513		     ja	     short OneK
DOSBIOS:3515		     mov     al, ah	     ; value in	AH is the index!
DOSBIOS:3517		     retn
DOSBIOS:3518 ; ---------------------------------------------------------------------------
DOSBIOS:3518
DOSBIOS:3518 OneK:				     ; CODE XREF: SectSizeToSectIndex+3j
DOSBIOS:3518		     mov     al, 3
DOSBIOS:351A		     retn
DOSBIOS:351A SectSizeToSectIndex endp
DOSBIOS:351A
DOSBIOS:351B
DOSBIOS:351B ; =============== S U B R O U T I N E =======================================
DOSBIOS:351B
DOSBIOS:351B
DOSBIOS:351B SectorSizeIndexToSectorSize proc near   ; CODE XREF: TrackIo+6Fp
DOSBIOS:351B		     mov     cl, al
DOSBIOS:351D		     mov     ax, 128
DOSBIOS:3520		     shl     ax, cl
DOSBIOS:3522		     retn
DOSBIOS:3522 SectorSizeIndexToSectorSize endp
DOSBIOS:3522
DOSBIOS:3523
DOSBIOS:3523 ; =============== S U B R O U T I N E =======================================
DOSBIOS:3523
DOSBIOS:3523
DOSBIOS:3523 SetDasd	     proc near		     ; CODE XREF: DOSBIOS:337Bp
DOSBIOS:3523					     ; DOSBIOS:33D9p
DOSBIOS:3523		     cmp     ds:had_format_error, 1 ;
DOSBIOS:3523					     ; See if we've previously set dasd type
DOSBIOS:3528		     jz	     short DoSetDasd
DOSBIOS:352A		     test    word ptr es:[di+23h], 80h ; [es:di+BDS.flags]
DOSBIOS:352A					     ; set_dasd_true
DOSBIOS:3530		     jz	     short DasdHasBeenSet
DOSBIOS:3532		     and     word ptr es:[di+23h], 0FF7Fh ; [es:di+BDS.flags]
DOSBIOS:3532					     ; ~set_dasd_true
DOSBIOS:3538
DOSBIOS:3538 DoSetDasd:				     ; CODE XREF: SetDasd+5j
DOSBIOS:3538		     mov     ds:had_format_error, 0
DOSBIOS:353D		     mov     ds:gap_patch, 50h ; Format	gap for	48tpi disks
DOSBIOS:3542		     mov     al, 4
DOSBIOS:3544		     cmp     byte ptr es:[di+22h], 2 ; [es:di+BDS.formfactor]
DOSBIOS:3544					     ; DEV_3INCH720KB
DOSBIOS:3549		     jz	     short DoSet
DOSBIOS:354B		     cmp     byte ptr es:[di+22h], 1 ; [es:di+BDS.formfactor]
DOSBIOS:354B					     ; DEV_5INCH96TPI
DOSBIOS:3550		     jz	     short GotBig
DOSBIOS:3552		     mov     al, 1
DOSBIOS:3554		     jmp     short DoSet
DOSBIOS:3556 ; ---------------------------------------------------------------------------
DOSBIOS:3556
DOSBIOS:3556 GotBig:				     ; CODE XREF: SetDasd+2Dj
DOSBIOS:3556		     mov     al, 2	     ; 160/320k	in a 1.2 meg drive
DOSBIOS:3558		     cmp     ds:mediatype, 0
DOSBIOS:355D		     jnz     short DoSet
DOSBIOS:355F		     mov     al, 3	     ; 1.2meg in a 1.2meg drive
DOSBIOS:3561		     mov     ds:gap_patch, 54h
DOSBIOS:3566
DOSBIOS:3566 DoSet:				     ; CODE XREF: SetDasd+26j
DOSBIOS:3566					     ; SetDasd+31j ...
DOSBIOS:3566		     push    ds
DOSBIOS:3567		     push    si
DOSBIOS:3568		     mov     ds, ds:zeroseg  ; Point to	interrupt vectors
DOSBIOS:356C		     assume ds:nothing
DOSBIOS:356C		     lds     si, ds:78h	     ; [DSKADR]	 (Int 1Eh)
DOSBIOS:3570		     assume ds:nothing
DOSBIOS:3570		     mov     byte ptr [si+9], 0Fh ;
DOSBIOS:3570					     ; [si+DISK_PARMS.DISK_HEAD_STTL]
DOSBIOS:3574		     pop     si
DOSBIOS:3575		     pop     ds
DOSBIOS:3576		     mov     ah, 17h
DOSBIOS:3578		     mov     dl, es:[di+4]
DOSBIOS:357C		     int     13h	     ; DISK - DISK - SET TYPE (AT,XT2,XT286,CONV,PS
DOSBIOS:357C					     ; AL = disk type AL = 03h - high-capacity disk in high-capacity drive
DOSBIOS:357E
DOSBIOS:357E DasdHasBeenSet:			     ; CODE XREF: SetDasd+Dj
DOSBIOS:357E		     mov     ah, es:[di+13h] ; [es:di+BDS.secpertrack]
DOSBIOS:3582		     mov     ds:formt_eot, ah
DOSBIOS:3586		     retn
DOSBIOS:3586 SetDasd	     endp
DOSBIOS:3586
DOSBIOS:3587
DOSBIOS:3587 ; =============== S U B R O U T I N E =======================================
DOSBIOS:3587
DOSBIOS:3587
DOSBIOS:3587 SetMediaForFormat proc near	     ; CODE XREF: DOSBIOS:3343p
DOSBIOS:3587					     ; DOSBIOS:DoFormatDiskette_1p ...
DOSBIOS:3587		     push    cx
DOSBIOS:3588		     push    dx
DOSBIOS:3589		     cmp     ds:had_format_error, 1
DOSBIOS:358E		     jz	     short SkipSaveDskAdr
DOSBIOS:3590		     xor     al, al	     ; If already done return 0
DOSBIOS:3592		     cmp     ds:media_set_for_format, 1
DOSBIOS:3597		     jnz     short DoSetMediaForFormat
DOSBIOS:3599		     jmp     SetMediaRet     ; Media already set
DOSBIOS:359C ; ---------------------------------------------------------------------------
DOSBIOS:359C
DOSBIOS:359C DoSetMediaForFormat:		     ; CODE XREF: SetMediaForFormat+10j
DOSBIOS:359C		     push    es
DOSBIOS:359D		     push    si
DOSBIOS:359E		     mov     es, ds:zeroseg
DOSBIOS:35A2		     assume es:nothing
DOSBIOS:35A2		     les     si, es:78h	     ; [es:DSKADR]
DOSBIOS:35A2					     ; Get pointer to disk base	table
DOSBIOS:35A7		     assume es:nothing
DOSBIOS:35A7		     mov     word ptr ds:dpt, si
DOSBIOS:35AB		     mov     word ptr ds:dpt+2,	es ; Save pointer to table
DOSBIOS:35AF		     mov     byte ptr es:[si+9], 0Fh ; [es:si+DISK_PARMS.DISK_HEAD_STTL]
DOSBIOS:35B4		     pop     si
DOSBIOS:35B5		     pop     es
DOSBIOS:35B6
DOSBIOS:35B6 SkipSaveDskAdr:			     ; CODE XREF: SetMediaForFormat+7j
DOSBIOS:35B6		     mov     cx, es:[di+25h] ; [es:di+BDS.cylinders]
DOSBIOS:35BA		     dec     cx
DOSBIOS:35BB		     and     ch, 3
DOSBIOS:35BE		     ror     ch, 1
DOSBIOS:35C0		     ror     ch, 1
DOSBIOS:35C2		     xchg    ch, cl
DOSBIOS:35C4		     or	     cl, es:[di+13h] ; [es:di+BDS.secpertrack]
DOSBIOS:35C8		     mov     dl, es:[di+4]   ; [es:di+BDS.drivenum]
DOSBIOS:35CC		     push    es
DOSBIOS:35CD		     push    ds
DOSBIOS:35CE		     push    si
DOSBIOS:35CF		     push    di
DOSBIOS:35D0		     mov     ah, 18h
DOSBIOS:35D2		     int     13h	     ; DISK - SET MEDIA	TYPE FOR FORMAT	(AT model 3x9,XT2,XT286,PS)
DOSBIOS:35D2					     ; DL = drive number, CH = lower 8 bits of number of tracks, CL = sectors per track
DOSBIOS:35D4		     jb	     short FormaStatErr
DOSBIOS:35D6		     cmp     ds:had_format_error, 1
DOSBIOS:35DB		     jz	     short skip_disk_base_setting
DOSBIOS:35DD		     push    es		     ; Save segment returned by	the rom
DOSBIOS:35DE		     mov     es, ds:zeroseg  ; Point to	interrupt vector segment
DOSBIOS:35E2		     assume es:nothing
DOSBIOS:35E2		     les     si, es:78h	     ; [es:DSKADR] (Int	1Eh)
DOSBIOS:35E2					     ; Get current disk	base table
DOSBIOS:35E7		     assume es:nothing
DOSBIOS:35E7		     mov     word ptr ds:tempdpt, si
DOSBIOS:35EB		     mov     word ptr ds:tempdpt+2, es ; Save it
DOSBIOS:35EF		     mov     es, ds:zeroseg
DOSBIOS:35F3		     assume es:nothing
DOSBIOS:35F3		     mov     es:78h, di
DOSBIOS:35F8		     pop     word ptr es:7Ah ; replace with one	returned by rom
DOSBIOS:35FD		     mov     ds:media_set_for_format, 1
DOSBIOS:3602
DOSBIOS:3602 skip_disk_base_setting:		     ; CODE XREF: SetMediaForFormat+54j
DOSBIOS:3602		     xor     al, al	     ; Legal combination + rom support code
DOSBIOS:3604		     mov     ds:had_format_error, al ; Reset the flag
DOSBIOS:3607		     jmp     short PopStatRet
DOSBIOS:3609 ; ---------------------------------------------------------------------------
DOSBIOS:3609
DOSBIOS:3609 FormaStatErr:			     ; CODE XREF: SetMediaForFormat+4Dj
DOSBIOS:3609		     cmp     ah, 0Ch	     ; DSK_ILLEGAL_COMBINATION
DOSBIOS:3609					     ; Illegal combination = 0Ch
DOSBIOS:360C		     jz	     short FormatStatIllegalComb
DOSBIOS:360E		     cmp     ah, 80h	     ; DSK_TIMEOUT_ERR
DOSBIOS:3611		     jz	     short FormatStatTimeOut
DOSBIOS:3613		     mov     al, 1	     ; Function	not supported.
DOSBIOS:3615		     jmp     short PopStatRet
DOSBIOS:3617 ; ---------------------------------------------------------------------------
DOSBIOS:3617
DOSBIOS:3617 FormatStatIllegalComb:		     ; CODE XREF: SetMediaForFormat+85j
DOSBIOS:3617		     mov     al, 2	     ; Function	supported, but
DOSBIOS:3617					     ; Illegal sect/trk,trk combination.
DOSBIOS:3619		     jmp     short PopStatRet
DOSBIOS:361B ; ---------------------------------------------------------------------------
DOSBIOS:361B
DOSBIOS:361B FormatStatTimeOut:			     ; CODE XREF: SetMediaForFormat+8Aj
DOSBIOS:361B		     mov     al, 3	     ; Function	supported, but
DOSBIOS:361B					     ; Media not present.
DOSBIOS:361D
DOSBIOS:361D PopStatRet:			     ; CODE XREF: SetMediaForFormat+80j
DOSBIOS:361D					     ; SetMediaForFormat+8Ej ...
DOSBIOS:361D		     pop     di
DOSBIOS:361E		     pop     si
DOSBIOS:361F		     pop     ds
DOSBIOS:3620		     pop     es
DOSBIOS:3621		     assume es:nothing
DOSBIOS:3621
DOSBIOS:3621 SetMediaRet:			     ; CODE XREF: SetMediaForFormat+12j
DOSBIOS:3621		     pop     dx
DOSBIOS:3622		     pop     cx
DOSBIOS:3623		     retn
DOSBIOS:3623 SetMediaForFormat endp
DOSBIOS:3623
DOSBIOS:3624
DOSBIOS:3624 ; =============== S U B R O U T I N E =======================================
DOSBIOS:3624
DOSBIOS:3624
DOSBIOS:3624 ResetDisk	     proc near		     ; CODE XREF: Disk+DEp
DOSBIOS:3624					     ; Disk:not_softecc_errp ...
DOSBIOS:3624		     push    ax
DOSBIOS:3625		     cmp     ds:media_set_for_format, 1	; Reset	while formatting?
DOSBIOS:362A		     jnz     short ResetDisk_cont ; Then verify	operation in "fmt & vrfy"
DOSBIOS:362C		     mov     ds:had_format_error, 1 ; Might have failed.
DOSBIOS:3631
DOSBIOS:3631 ResetDisk_cont:			     ; CODE XREF: ResetDisk+6j
DOSBIOS:3631		     xor     ah, ah	     ; So signals that we had a	format error
DOSBIOS:3633		     int     13h	     ; DISK - RESET DISK SYSTEM
DOSBIOS:3633					     ; DL = drive (if bit 7 is set both	hard disks and floppy disks reset)
DOSBIOS:3635		     mov     ds:step_drv, 0FFh ; Zap up	the speed
DOSBIOS:363A		     pop     ax
DOSBIOS:363B		     retn
DOSBIOS:363B ResetDisk	     endp
DOSBIOS:363B
DOSBIOS:363C
DOSBIOS:363C ; =============== S U B R O U T I N E =======================================
DOSBIOS:363C
DOSBIOS:363C
DOSBIOS:363C ToRom	     proc near		     ; CODE XREF: DOSBIOS:33ABp
DOSBIOS:363C					     ; DOSBIOS:33C0p
DOSBIOS:363C		     push    bx
DOSBIOS:363D		     push    si		     ; Compaq bug fix
DOSBIOS:363E		     test    ds:media_set_for_format, 1
DOSBIOS:3643		     jnz     short GotValidDpt
DOSBIOS:3645		     push    ax
DOSBIOS:3646		     push    es		     ; Save bds	segment
DOSBIOS:3647		     cmp     byte ptr es:[di+22h], 2 ; [es:di+BDS.formfactor]
DOSBIOS:3647					     ; ffSmall ; is it a 3.5" drive?
DOSBIOS:364C		     pushf		     ; (Save the cmp result)
DOSBIOS:364D		     mov     es, ds:zeroseg
DOSBIOS:3651		     assume es:nothing
DOSBIOS:3651		     les     si, es:78h	     ; Get pointer to disk base	table
DOSBIOS:3656		     assume es:nothing
DOSBIOS:3656		     mov     word ptr ds:dpt, si
DOSBIOS:365A		     mov     word ptr ds:dpt+2,	es ;  Save pointer to table
DOSBIOS:365E		     mov     al, ds:formt_eot
DOSBIOS:3661		     mov     es:[si+4],	al   ; [es:si+DISK_PARMS.DISK_EOT]
DOSBIOS:3665		     mov     al, ds:gap_patch
DOSBIOS:3668		     mov     es:[si+7],	al   ; [es:si+DISK_PARMS.DISK_FORMT_GAP]
DOSBIOS:3668					     ; Important for format
DOSBIOS:366C		     mov     byte ptr es:[si+9], 0Fh ; [es:si+DISK_PARMS.DISK_HEAD_STTL]
DOSBIOS:366C					     ; Assume we are doing a seek operation
DOSBIOS:366C					     ; Setup motor start correctly for 3.5" drives
DOSBIOS:3671		     popf		     ; Get result of earlier cmp
DOSBIOS:3672		     jnz     short MotorStrtOK
DOSBIOS:3674		     mov     byte ptr es:[si+0Ah], 4 ; [es:si+DISK_PARMS.DISK_MOTOR_STRT]
DOSBIOS:3679
DOSBIOS:3679 MotorStrtOK:			     ; CODE XREF: ToRom+36j
DOSBIOS:3679		     pop     es		     ; Restore bds segment
DOSBIOS:367A		     pop     ax
DOSBIOS:367B
DOSBIOS:367B GotValidDpt:			     ; CODE XREF: ToRom+7j
DOSBIOS:367B		     mov     dx, ds:trknum   ; Set track number
DOSBIOS:367F		     mov     ch, dl	     ; Set low 8 bits in ch
DOSBIOS:3681		     mov     dl, es:[di+4]   ; Set drive number
DOSBIOS:3685		     mov     dh, ds:hdnum    ; Set head	number
DOSBIOS:3689		     push    es		     ; Save bds	segment
DOSBIOS:368A		     mov     es, ds:xfer_seg
DOSBIOS:368E		     int     13h	     ; DISK -
DOSBIOS:3690		     pop     es		     ; Restore bds segment
DOSBIOS:3691		     pop     si
DOSBIOS:3692		     pop     bx
DOSBIOS:3693		     retn
DOSBIOS:3693 ToRom	     endp
DOSBIOS:3693
DOSBIOS:3694 ; ---------------------------------------------------------------------------
DOSBIOS:3694
DOSBIOS:3694 ioctl_getown:
DOSBIOS:3694		     call    SetDrive
DOSBIOS:3697		     mov     al, es:[di+4]   ; [es:di+BDS.drivenum]
DOSBIOS:3697					     ; Get physical drive number
DOSBIOS:369B		     les     di, ds:start_bds ;	Get start of bds chain
DOSBIOS:369F
DOSBIOS:369F ownloop:				     ; CODE XREF: DOSBIOS:36B0j
DOSBIOS:369F		     cmp     es:[di+4],	al   ; [es:di+BDS.drivenum]
DOSBIOS:36A3		     jnz     short getnextBDS
DOSBIOS:36A5		     test    word ptr es:[di+23h], 20h ; [es:di+BDS.flags]
DOSBIOS:36A5					     ; fi_own_physical
DOSBIOS:36AB		     jnz     short exitown
DOSBIOS:36AD
DOSBIOS:36AD getnextBDS:			     ; CODE XREF: DOSBIOS:36A3j
DOSBIOS:36AD		     les     di, es:[di]     ; [es:di+BDS.link]
DOSBIOS:36B0		     jmp     short ownloop
DOSBIOS:36B2 ; ---------------------------------------------------------------------------
DOSBIOS:36B2
DOSBIOS:36B2 ioctl_setown:
DOSBIOS:36B2		     call    SetDrive
DOSBIOS:36B5		     mov     ds:fsetowner, 1 ; set flag	for CheckSingle	to look	at.
DOSBIOS:36BA		     call    checksingle
DOSBIOS:36BD		     mov     ds:fsetowner, 0 ; set ownership of	drive reset flag
DOSBIOS:36C2
DOSBIOS:36C2 exitown:				     ; CODE XREF: DOSBIOS:36ABj
DOSBIOS:36C2		     xor     cl, cl
DOSBIOS:36C4		     test    word ptr es:[di+23h], 10h ; [es:di+BDS.flags]
DOSBIOS:36C4					     ; fi_am_mult
DOSBIOS:36CA		     jz	     short exitnomult
DOSBIOS:36CC		     mov     cl, es:[di+5]   ; [es:di+BDS.drivelet]
DOSBIOS:36CC					     ; Get logical drive number
DOSBIOS:36CC					     ; Get it 1-based
DOSBIOS:36D0		     inc     cl
DOSBIOS:36D2
DOSBIOS:36D2 exitnomult:			     ; CODE XREF: DOSBIOS:36CAj
DOSBIOS:36D2		     lds     bx, ds:ptrsav
DOSBIOS:36D6		     mov     [bx+1], cl	     ; [bx+unit]
DOSBIOS:36D6					     ; Exit normal termination
DOSBIOS:36D9		     clc
DOSBIOS:36DA		     retn
DOSBIOS:36DB
DOSBIOS:36DB ; =============== S U B R O U T I N E =======================================
DOSBIOS:36DB
DOSBIOS:36DB
DOSBIOS:36DB RestoreOldDpt   proc near		     ; CODE XREF: DOSBIOS:32ECp
DOSBIOS:36DB		     push    ax
DOSBIOS:36DC		     xor     al, al
DOSBIOS:36DE		     mov     ds:had_format_error, al ; Reset flag and get current flag setting
DOSBIOS:36E1		     xchg    al, ds:media_set_for_format
DOSBIOS:36E5		     or	     al, al
DOSBIOS:36E7		     jz	     short DontRestore
DOSBIOS:36E9		     push    si
DOSBIOS:36EA		     push    ds
DOSBIOS:36EB		     push    es
DOSBIOS:36EC		     lds     si, ds:tempdpt
DOSBIOS:36F0		     mov     es, word ptr cs:aCon+3 ; [cs:Bios_Data_Word]
DOSBIOS:36F5		     assume es:nothing
DOSBIOS:36F5		     mov     es, es:zeroseg
DOSBIOS:36FA		     assume es:nothing
DOSBIOS:36FA		     mov     es:78h, si	     ; [es:DSKADR]
DOSBIOS:36FF		     mov     word ptr es:7Ah, ds ; [es:DSKADR+2]
DOSBIOS:3704		     pop     es
DOSBIOS:3705		     assume es:nothing
DOSBIOS:3705		     pop     ds
DOSBIOS:3706		     pop     si
DOSBIOS:3707
DOSBIOS:3707 DontRestore:			     ; CODE XREF: RestoreOldDpt+Cj
DOSBIOS:3707		     pop     ax
DOSBIOS:3708		     clc		     ;	Clear carry
DOSBIOS:3709		     retn
DOSBIOS:3709 RestoreOldDpt   endp
DOSBIOS:3709
DOSBIOS:370A ; ---------------------------------------------------------------------------
DOSBIOS:370A
DOSBIOS:370A GetMediaId:
DOSBIOS:370A		     call    ChangeLineChk
DOSBIOS:370D		     mov     al, es:[di+5]   ; [es:di+BDS.drivelet] ; Logical drive number
DOSBIOS:3711		     mov     ds:rflag, 2     ; Read operation
DOSBIOS:3716		     call    BootIo	     ; Read boot sector	into DiskSector
DOSBIOS:3719 ; ---------------------------------------------------------------------------
DOSBIOS:3719		     jb	     short IOCtl_If1
DOSBIOS:371B		     cmp     ds:disksector+15h,	0F0h ; [disksector+EXT_BOOT.BPB+EBPB.MEDIADESCRIPTOR]
DOSBIOS:3720		     jb	     short IOCtl_If2 ; brif not	valid (0F0h - 0FFh)
DOSBIOS:3722		     cmp     ds:disksector+26h,	29h ; [disksector+EXT_BOOT.SIG]
DOSBIOS:3722					     ; EXT_BOOT_SIGNATURE
DOSBIOS:3727		     jnz     short IOCtl_If2 ; not extended boot record
DOSBIOS:3729		     les     di, ds:ptrsav   ; es:di points to request header
DOSBIOS:372D		     les     di, es:[bx+19]  ; [es:bx+IOCTL_REQ.GENERICIOCTL_PACKET]
DOSBIOS:3731		     mov     si, (offset disksector+27h) ; disksector+EXT_BOOT.SERIAL
DOSBIOS:3734		     add     di, 2	     ; A_MEDIA_ID_INFO.MI_SERIAL
DOSBIOS:3737		     mov     cx, 23	     ; size_of_EXT_BOOT_SERIA
DOSBIOS:3737					     ; L+size_of_EXT_BOOT_VOL_LABEL
DOSBIOS:3737					     ; +size_of_EXT_SYSTEM_ID
DOSBIOS:373A		     rep movsb		     ; Move from Bios_Data into	request	packet
DOSBIOS:373C		     clc
DOSBIOS:373D		     retn
DOSBIOS:373E ; ---------------------------------------------------------------------------
DOSBIOS:373E
DOSBIOS:373E IOCtl_If2:				     ; CODE XREF: DOSBIOS:3720j
DOSBIOS:373E					     ; DOSBIOS:3727j
DOSBIOS:373E		     mov     al, 7	     ; error_unknown_media
DOSBIOS:3740		     stc
DOSBIOS:3741
DOSBIOS:3741 IOCtl_If1:				     ; CODE XREF: DOSBIOS:3719j
DOSBIOS:3741		     retn
DOSBIOS:3742 ; ---------------------------------------------------------------------------
DOSBIOS:3742
DOSBIOS:3742 SetMediaId:
DOSBIOS:3742		     call    ChangeLineChk
DOSBIOS:3745		     mov     al, es:[di+5]   ; [es:di+BDS.drivelet]
DOSBIOS:3745					     ; Logical drive number
DOSBIOS:3749		     mov     dl, al
DOSBIOS:374B		     mov     ds:rflag, 2     ; romread
DOSBIOS:3750		     push    dx
DOSBIOS:3751		     call    BootIo	     ; Read boot sec to	Bios_Data:DiskSector
DOSBIOS:3754 ; ---------------------------------------------------------------------------
DOSBIOS:3754		     pop     dx
DOSBIOS:3755		     jb	     short IOCtl_If6
DOSBIOS:3757		     cmp     ds:disksector+15h,	0F0h ;	Valid? (0F0h-0FFh?)
DOSBIOS:3757					     ; [disksector+EXT_BOOT.BPB+EBPB.MEDIADESCRIPTOR]
DOSBIOS:375C		     jb	     short IOCtl_If7 ; Brif not
DOSBIOS:375E		     cmp     ds:disksector+26h,	29h ; [disksector+EXT_BOOT.SIG]
DOSBIOS:375E					     ; EXT_BOOT_SIGNATURE
DOSBIOS:3763		     jnz     short IOCtl_If7 ; not extended boot record
DOSBIOS:3765		     push    es		     ; Save BDS	pointer
DOSBIOS:3766		     push    di
DOSBIOS:3767		     push    ds		     ; Point ES	To boot	record
DOSBIOS:3768		     pop     es
DOSBIOS:3769		     mov     di, (offset disksector+27h) ; disksector+EXT_BOOT.SERIAL
DOSBIOS:376C		     lds     si, ds:ptrsav   ; ds:si points to request header.
DOSBIOS:3770		     lds     si, [si+19]     ; [si+IOCTL_REQ.GENERICIOCTL_PACKET]
DOSBIOS:3773		     add     si, 2	     ; A_MEDIA_ID_INFO.MI_SERIAL
DOSBIOS:3776		     mov     cx, 23	     ; size_of_EXT_BOOT_SERIAL
DOSBIOS:3776					     ; +size_of_EXT_BOOT_VOL_LABEL
DOSBIOS:3776					     ; +size_of_EXT_SYSTEM_ID
DOSBIOS:3779		     rep movsb
DOSBIOS:377B		     push    es		     ; point ds	back to	Bios_Data
DOSBIOS:377C		     pop     ds
DOSBIOS:377D		     pop     di		     ; restore bds pointer
DOSBIOS:377E		     pop     es
DOSBIOS:377F		     call    mov_media_ids   ; update the bds media id info.
DOSBIOS:3782		     mov     al, dl
DOSBIOS:3784		     mov     ds:rflag, 3     ; romwrite
DOSBIOS:3789		     call    BootIo	     ; write it	back.
DOSBIOS:378C ; ---------------------------------------------------------------------------
DOSBIOS:378C		     mov     ds:tim_drv, 0FFh ;	make sure chk_media check the driver
DOSBIOS:378C					     ; return with error code from BootIo
DOSBIOS:3791		     retn
DOSBIOS:3792 ; ---------------------------------------------------------------------------
DOSBIOS:3792
DOSBIOS:3792 IOCtl_If7:				     ; CODE XREF: DOSBIOS:375Cj
DOSBIOS:3792					     ; DOSBIOS:3763j
DOSBIOS:3792		     mov     al, 7	     ; error_unknown_media
DOSBIOS:3794		     stc
DOSBIOS:3795
DOSBIOS:3795 IOCtl_If6:				     ; CODE XREF: DOSBIOS:3755j
DOSBIOS:3795		     retn
DOSBIOS:3796
DOSBIOS:3796 ; =============== S U B R O U T I N E =======================================
DOSBIOS:3796
DOSBIOS:3796 ; Attributes: noreturn
DOSBIOS:3796
DOSBIOS:3796 BootIo	     proc near		     ; CODE XREF: DOSBIOS:3716p
DOSBIOS:3796					     ; DOSBIOS:3751p ...
DOSBIOS:3796		     push    es		     ; Call DiskIO to read/write the boot sec.
DOSBIOS:3797		     push    di
DOSBIOS:3798		     push    bx
DOSBIOS:3799		     push    ds
DOSBIOS:379A		     pop     es
DOSBIOS:379B		     mov     di, offset	disksector ; es:di -> transfer address
DOSBIOS:379E		     xor     dx, dx	     ; First sector (h)	-> 0
DOSBIOS:37A0		     mov     ds:start_sec_h, dx	; Start	sector (h) -> 0
DOSBIOS:37A4		     mov     cx, 1
DOSBIOS:37A7		     call    diskio
DOSBIOS:37AA		     pop     bx
DOSBIOS:37AB		     pop     di
DOSBIOS:37AC		     pop     es
DOSBIOS:37AD		     retn
DOSBIOS:37AD BootIo	     endp
DOSBIOS:37AD
DOSBIOS:37AE
DOSBIOS:37AE ; =============== S U B R O U T I N E =======================================
DOSBIOS:37AE
DOSBIOS:37AE
DOSBIOS:37AE ChangeLineChk   proc near		     ; CODE XREF: DOSBIOS:GetMediaIdp
DOSBIOS:37AE					     ; DOSBIOS:SetMediaIdp
DOSBIOS:37AE		     mov     dl, es:[di+4]   ; [es:di+BDS.drivenum]
DOSBIOS:37B2		     or	     dl, dl	     ; Fixed disk?
DOSBIOS:37B4		     js	     short ChangeLnChkRet ; Yes, skip it.
DOSBIOS:37B6		     test    word ptr es:[di+23h], 4 ; [es:di+BDS.flags]
DOSBIOS:37B6					     ; return_fake_bpb
DOSBIOS:37BC		     jnz     short ChangeLnChkRet
DOSBIOS:37BE		     cmp     ds:fhave96, 1   ; This rom	support	change line?
DOSBIOS:37C3		     jnz     short ChangeLnChkRet
DOSBIOS:37C5		     call    haschange	     ; This drive support change line?
DOSBIOS:37C8		     jz	     short ChangeLnChkRet ; Do nothing
DOSBIOS:37CA		     mov     ah, 16h
DOSBIOS:37CC		     int     13h	     ; DISK - FLOPPY DISK - CHANGE OF DISK STATUS (AT,XT2,XT286,CONV,PS)
DOSBIOS:37CC					     ; DL = drive to check
DOSBIOS:37CC					     ; Return: AH = disk change	status
DOSBIOS:37CE		     jnb     short ChangeLnChkRet
DOSBIOS:37D0		     push    bx
DOSBIOS:37D1		     mov     bx, 40h	     ; fchanged
DOSBIOS:37D1					     ; Update flag in BDS for this
DOSBIOS:37D1					     ; physical	drive
DOSBIOS:37D4		     call    set_changed_dl
DOSBIOS:37D7		     pop     bx
DOSBIOS:37D8
DOSBIOS:37D8 ChangeLnChkRet:			     ; CODE XREF: ChangeLineChk+6j
DOSBIOS:37D8					     ; ChangeLineChk+Ej ...
DOSBIOS:37D8		     retn
DOSBIOS:37D8 ChangeLineChk   endp
DOSBIOS:37D8
DOSBIOS:37D9 ; ---------------------------------------------------------------------------
DOSBIOS:37D9
DOSBIOS:37D9 GetAccessFlag:			     ; DS:BX points to request header
DOSBIOS:37D9		     lds     bx, ds:ptrsav
DOSBIOS:37DD		     lds     bx, [bx+19]     ; [bx+IOCTL_REQ.GENERICIOCTL_PACKET]
DOSBIOS:37E0		     mov     al, 0	     ; Assume result is	unformatted
DOSBIOS:37E2		     test    word ptr es:[di+35], 200h ; [es:di+BDS.flags]
DOSBIOS:37E2					     ; unformatted_media
DOSBIOS:37E8		     jnz     short GafDone   ; Done if unformatted
DOSBIOS:37EA		     inc     al		     ; Return true for formatted
DOSBIOS:37EC
DOSBIOS:37EC GafDone:				     ; CODE XREF: DOSBIOS:37E8j
DOSBIOS:37EC		     mov     [bx+1], al	     ; [bx+A_DISKACCESS_CONTROL.DAC_ACCESS_FLAG]
DOSBIOS:37EF		     retn
DOSBIOS:37F0 ; ---------------------------------------------------------------------------
DOSBIOS:37F0
DOSBIOS:37F0 SetAccessFlag:			     ; ES:BX points to request header
DOSBIOS:37F0		     lds     bx, ds:ptrsav
DOSBIOS:37F4		     lds     bx, [bx+19]     ; [bx+IOCTL_REQ.GENERICIOCTL_PACKET]
DOSBIOS:37F7		     and     word ptr es:[di+35], 0FDFFh ; es:di+BDS.flags]
DOSBIOS:37F7					     ; ~unformatted_media
DOSBIOS:37FD		     cmp     byte ptr [bx+1], 0	; [bx+A_DISKACCESS_CONTROL.DAC_ACCESS_FLAG]
DOSBIOS:3801		     jnz     short saf_Done
DOSBIOS:3803		     or	     word ptr es:[di+35], 200h ; [es:di+BDS.flags]
DOSBIOS:3803					     ; unformatted_media
DOSBIOS:3809
DOSBIOS:3809 saf_Done:				     ; CODE XREF: DOSBIOS:3801j
DOSBIOS:3809		     retn
DOSBIOS:380A ; ---------------------------------------------------------------------------
DOSBIOS:380A
DOSBIOS:380A ioctl_support_query:
DOSBIOS:380A		     push    es
DOSBIOS:380B		     les     bx, ds:ptrsav
DOSBIOS:380F		     mov     ax, es:[bx+13]  ; [es:bx+IOCTL_REQ.MAJORFUNCTION]
DOSBIOS:380F					     ; AL == Major, AH == Minor
DOSBIOS:3813		     cmp     al, 8	     ; IOC_DC
DOSBIOS:3813					     ; See if major code is 8
DOSBIOS:3815		     jnz     short nosupport
DOSBIOS:3817		     push    cs
DOSBIOS:3818		     pop     es
DOSBIOS:3819		     assume es:DOSBIOS
DOSBIOS:3819		     mov     cx, 11	     ; IOC_DC_TABLE_LEN
DOSBIOS:381C		     mov     di, 0C60h	     ; IOC_DC_Table
DOSBIOS:381C					     ; at 2C7h:0C60h = 70h:31D0h
DOSBIOS:381F		     xchg    al, ah	     ; Put minor code in AL
DOSBIOS:3821		     repne scasb	     ; Scan for	minor code in AL
DOSBIOS:3823		     jnz     short nosupport ; it was not found
DOSBIOS:3825		     mov     ax, 100h
DOSBIOS:3828		     jmp     short $+2	     ; ioctlsupexit
DOSBIOS:3828					     ; Signal ioctl is supported
DOSBIOS:382A ; ---------------------------------------------------------------------------
DOSBIOS:382A
DOSBIOS:382A ioctlsupexit:			     ; CODE XREF: DOSBIOS:3828j
DOSBIOS:382A		     pop     es
DOSBIOS:382B		     assume es:nothing
DOSBIOS:382B		     clc
DOSBIOS:382C		     retn
DOSBIOS:382D ; ---------------------------------------------------------------------------
DOSBIOS:382D
DOSBIOS:382D nosupport:				     ; CODE XREF: DOSBIOS:3815j
DOSBIOS:382D					     ; DOSBIOS:3823j
DOSBIOS:382D		     pop     es
DOSBIOS:382E		     jmp     bc_cmderr
DOSBIOS:3831 ; ---------------------------------------------------------------------------
DOSBIOS:3831
DOSBIOS:3831 SenseMediaType:			     ; DS:BX points to request header.
DOSBIOS:3831		     lds     bx, ds:ptrsav
DOSBIOS:3835		     lds     bx, [bx+19]     ; bx+IOCTL_REQ.GENERICIOCTL_PACKET]
DOSBIOS:3838		     mov     word ptr [bx], 0 ;	Initialize the 2 packet	bytes
DOSBIOS:383C		     mov     dl, es:[di+4]   ; [es:di+BDS.drivenum]
DOSBIOS:383C					     ; Get int 13h drive number	from BDS
DOSBIOS:3840		     xor     dh, dh	     ; DX = physical drive number
DOSBIOS:3842		     mov     ah, 20h	     ; Get Media Type function
DOSBIOS:3842					     ; If no carry media type in AL
DOSBIOS:3844		     int     13h	     ; DISK - QCACHE - DISMOUNT
DOSBIOS:3846		     jb	     short MediaSenseEr	; error	code in	AH
DOSBIOS:3848		     inc     byte ptr [bx]   ; Signal media type is default (bit 1)
DOSBIOS:384A
DOSBIOS:384A DetermineMediaType:		     ; CODE XREF: DOSBIOS:3862j
DOSBIOS:384A		     dec     al
DOSBIOS:384C		     cmp     al, 2	     ;	Chk for	720K ie: (3-1) = 2
DOSBIOS:384E		     jz	     short GotMediaType
DOSBIOS:3850		     add     al, 4
DOSBIOS:3852		     cmp     al, 7	     ;	Chk for	1.44M  ie: (4-1+4) = 7
DOSBIOS:3854		     jz	     short GotMediaType
DOSBIOS:3856		     cmp     al, 9	     ; Chk for 2.88M  ie: (6-1+4) =  9
DOSBIOS:3858		     jnz     short UnknownMediaType ; Just didn't recognize media type
DOSBIOS:385A
DOSBIOS:385A GotMediaType:			     ; CODE XREF: DOSBIOS:384Ej
DOSBIOS:385A					     ; DOSBIOS:3854j
DOSBIOS:385A		     mov     [bx+1], al	     ; Save the	return value
DOSBIOS:385D		     clc		     ; Signal success
DOSBIOS:385E		     retn
DOSBIOS:385F ; ---------------------------------------------------------------------------
DOSBIOS:385F
DOSBIOS:385F MediaSenseEr:			     ; CODE XREF: DOSBIOS:3846j
DOSBIOS:385F		     cmp     ah, 32h	     ; See if not default media	error
DOSBIOS:3862		     jz	     short DetermineMediaType ;	Not really an error
DOSBIOS:3864		     mov     al, 2	     ; Now assume drive	not ready
DOSBIOS:3866		     cmp     ah, 31h	     ; See if media was	present
DOSBIOS:3869		     jz	     short SenseErrExit	; Return drive not ready
DOSBIOS:386B
DOSBIOS:386B UnknownMediaType:			     ; CODE XREF: DOSBIOS:3858j
DOSBIOS:386B		     mov     al, 7	     ; Just don't know the media type
DOSBIOS:386D
DOSBIOS:386D SenseErrExit:			     ; CODE XREF: DOSBIOS:3869j
DOSBIOS:386D		     mov     ah, 81h	     ; Signal error return
DOSBIOS:386F		     stc
DOSBIOS:3870		     retn
DOSBIOS:3870 ; ---------------------------------------------------------------------------
DOSBIOS:3871		     db	   0
DOSBIOS:3872 ; ---------------------------------------------------------------------------
DOSBIOS:3872
DOSBIOS:3872 i2f_handler:			     ; here is 02C7h:1302h = 0070h:3872h
DOSBIOS:3872		     cmp     ah, 13h
DOSBIOS:3875		     jz	     short int2f_replace_int13
DOSBIOS:3877		     cmp     ah, 8
DOSBIOS:387A		     jz	     short mine
DOSBIOS:387C		     cmp     ah, 16h	     ; MultWin386
DOSBIOS:387F		     jz	     short win386call
DOSBIOS:3881		     cmp     ah, 4Ah	     ; multMULT
DOSBIOS:3884		     jnz     short i2f_handler_iret
DOSBIOS:3886		     jmp     handle_multmult
DOSBIOS:3889 ; ---------------------------------------------------------------------------
DOSBIOS:3889
DOSBIOS:3889 i2f_handler_iret:			     ; CODE XREF: DOSBIOS:3884j
DOSBIOS:3889		     iret
DOSBIOS:388A ; ---------------------------------------------------------------------------
DOSBIOS:388A
DOSBIOS:388A int2f_replace_int13:		     ; CODE XREF: DOSBIOS:3875j
DOSBIOS:388A		     push    ax
DOSBIOS:388B		     mov     ax, ds
DOSBIOS:388D		     mov     ds, word ptr cs:aCon+3 ; [cs:BiosDataWord]
DOSBIOS:388D					     ; = [02C7h:0030h] = [0070h:25A0h]
DOSBIOS:3892		     assume ds:nothing
DOSBIOS:3892		     push    word ptr ds:Orig13
DOSBIOS:3896		     push    word ptr ds:Orig13+2
DOSBIOS:389A		     push    word ptr ds:Old13
DOSBIOS:389E		     push    word ptr ds:Old13+2
DOSBIOS:38A2		     mov     word ptr ds:Orig13, dx
DOSBIOS:38A6		     mov     word ptr ds:Orig13+2, ax
DOSBIOS:38A9		     mov     word ptr ds:Old13,	bx
DOSBIOS:38AD		     mov     word ptr ds:Old13+2, es
DOSBIOS:38B1		     pop     es
DOSBIOS:38B2		     pop     bx
DOSBIOS:38B3		     pop     ds
DOSBIOS:38B4		     assume ds:nothing
DOSBIOS:38B4		     pop     dx
DOSBIOS:38B5		     pop     ax
DOSBIOS:38B6
DOSBIOS:38B6 i2f_iret:				     ; CODE XREF: DOSBIOS:38B9j
DOSBIOS:38B6					     ; DOSBIOS:38C1j ...
DOSBIOS:38B6		     iret
DOSBIOS:38B7 ; ---------------------------------------------------------------------------
DOSBIOS:38B7
DOSBIOS:38B7 mine:				     ; CODE XREF: DOSBIOS:387Aj
DOSBIOS:38B7		     cmp     al, 0F8h
DOSBIOS:38B9		     jnb     short i2f_iret
DOSBIOS:38BB		     or	     al, al
DOSBIOS:38BD		     jnz     short disp_func
DOSBIOS:38BF		     mov     al, 0FFh
DOSBIOS:38C1		     jmp     short i2f_iret
DOSBIOS:38C3 ; ---------------------------------------------------------------------------
DOSBIOS:38C3
DOSBIOS:38C3 disp_func:				     ; CODE XREF: DOSBIOS:38BDj
DOSBIOS:38C3		     cmp     al, 1
DOSBIOS:38C5		     jz	     short do_subfun_01
DOSBIOS:38C7		     cmp     al, 3
DOSBIOS:38C9		     jz	     short do_get_bds_vector
DOSBIOS:38CB		     push    ds
DOSBIOS:38CC		     mov     ds, word ptr cs:aCon+3 ; [cs:Bios_Data_Word]
DOSBIOS:38CC					     ; = [0070h:25A0h] = [02C7h:0030h]
DOSBIOS:38D1		     assume ds:nothing
DOSBIOS:38D1		     mov     word ptr ds:ptrsav, bx
DOSBIOS:38D5		     mov     word ptr ds:ptrsav+2, es
DOSBIOS:38D9		     pop     ds
DOSBIOS:38DA		     assume ds:nothing
DOSBIOS:38DA		     jmp     far ptr i2f_dskentry
DOSBIOS:38DF ; ---------------------------------------------------------------------------
DOSBIOS:38DF
DOSBIOS:38DF do_subfun_01:			     ; CODE XREF: DOSBIOS:38C5j
DOSBIOS:38DF		     push    es
DOSBIOS:38E0		     push    ds
DOSBIOS:38E1		     push    ds
DOSBIOS:38E2		     pop     es
DOSBIOS:38E3		     mov     ds, word ptr cs:aCon+3 ; [cs:Bios_Data_Word]
DOSBIOS:38E3					     ; point ds: -> Bios_Data
DOSBIOS:38E8		     assume ds:nothing
DOSBIOS:38E8		     call    install_bds
DOSBIOS:38EB		     pop     ds
DOSBIOS:38EC		     assume ds:nothing
DOSBIOS:38EC		     pop     es
DOSBIOS:38ED		     jmp     short i2f_iret
DOSBIOS:38EF ; ---------------------------------------------------------------------------
DOSBIOS:38EF
DOSBIOS:38EF do_get_bds_vector:			     ; CODE XREF: DOSBIOS:38C9j
DOSBIOS:38EF		     mov     ds, word ptr cs:aCon+3 ; [cs:Bios_Data_Word]
DOSBIOS:38F4		     assume ds:nothing
DOSBIOS:38F4		     lds     di, ds:start_bds
DOSBIOS:38F8		     assume ds:nothing
DOSBIOS:38F8
DOSBIOS:38F8 ii2f_iret:				     ; CODE XREF: DOSBIOS:3947j
DOSBIOS:38F8					     ; DOSBIOS:397Dj ...
DOSBIOS:38F8		     jmp     short i2f_iret
DOSBIOS:38FA ; ---------------------------------------------------------------------------
DOSBIOS:38FA
DOSBIOS:38FA win386call:			     ; CODE XREF: DOSBIOS:387Fj
DOSBIOS:38FA		     push    ds
DOSBIOS:38FB		     mov     ds, word ptr cs:aCon+3 ; [cs:Bios_Data_Word]
DOSBIOS:38FB					     ; at 2C7h:30h = 70h:25A0h
DOSBIOS:3900		     assume ds:nothing
DOSBIOS:3900		     cmp     al, 5	     ; Win386_Init
DOSBIOS:3900					     ; is it win386 initializing?
DOSBIOS:3902		     jz	     short Win386Init
DOSBIOS:3904		     cmp     al, 6	     ; Win386_Exit
DOSBIOS:3904					     ; is it win386 exiting?
DOSBIOS:3906		     jnz     short win_iret  ; if not, continue	int2f chain
DOSBIOS:3908		     test    dx, 1	     ; is it win386 or win286 dos extender?
DOSBIOS:390C		     jnz     short win_iret  ; if not win386, then continue
DOSBIOS:390E		     and     ds:IsWin386, 0  ; indicate	that win386 is not present
DOSBIOS:3913		     jmp     short win_iret
DOSBIOS:3915 ; ---------------------------------------------------------------------------
DOSBIOS:3915
DOSBIOS:3915 Win386Init:			     ; CODE XREF: DOSBIOS:3902j
DOSBIOS:3915		     test    dx, 1	     ; is it win386 or win286 dos extender?
DOSBIOS:3919		     jnz     short win_iret  ; if not win386, then continue
DOSBIOS:391B		     or	     ds:IsWin386, 1  ; Indicate	WIN386 present
DOSBIOS:3920		     mov     word ptr ds:SI_Next, bx ; Hook our	structure into chain
DOSBIOS:3924		     mov     word ptr ds:SI_Next+2, es
DOSBIOS:3928		     mov     bx, offset	Win386_SI ; point ES:BX	to Win386_SI
DOSBIOS:392B		     push    ds
DOSBIOS:392C		     pop     es
DOSBIOS:392D		     assume es:nothing
DOSBIOS:392D
DOSBIOS:392D win_iret:				     ; CODE XREF: DOSBIOS:3906j
DOSBIOS:392D					     ; DOSBIOS:390Cj ...
DOSBIOS:392D		     pop     ds
DOSBIOS:392E		     assume ds:nothing
DOSBIOS:392E		     jmp     short i2f_iret  ; return back up the chain
DOSBIOS:3930 ; ---------------------------------------------------------------------------
DOSBIOS:3930
DOSBIOS:3930 handle_multmult:			     ; CODE XREF: DOSBIOS:3886j
DOSBIOS:3930		     cmp     al, 1
DOSBIOS:3932		     jnz     short try_2
DOSBIOS:3934		     push    ds
DOSBIOS:3935		     call    HMAPtr
DOSBIOS:3938		     mov     bx, 0FFFFh
DOSBIOS:393B		     mov     es, bx
DOSBIOS:393D		     assume es:nothing
DOSBIOS:393D		     mov     bx, di
DOSBIOS:393F		     not     bx
DOSBIOS:3941		     or	     bx, bx
DOSBIOS:3943		     jz	     short try_1
DOSBIOS:3945		     inc     bx
DOSBIOS:3946
DOSBIOS:3946 try_1:				     ; CODE XREF: DOSBIOS:3943j
DOSBIOS:3946		     pop     ds
DOSBIOS:3947		     jmp     short ii2f_iret
DOSBIOS:3949 ; ---------------------------------------------------------------------------
DOSBIOS:3949
DOSBIOS:3949 try_2:				     ; CODE XREF: DOSBIOS:3932j
DOSBIOS:3949		     cmp     al, 2	     ; multMULTALLOCHMA
DOSBIOS:394B		     jnz     short try_3
DOSBIOS:394D		     push    ds
DOSBIOS:394E		     mov     di, 0FFFFh
DOSBIOS:3951		     mov     es, di
DOSBIOS:3953		     call    HMAPtr
DOSBIOS:3956		     cmp     di, 0FFFFh
DOSBIOS:3959		     jz	     short InsuffHMA
DOSBIOS:395B		     neg     di
DOSBIOS:395D		     cmp     bx, di
DOSBIOS:395F		     jbe     short try_4
DOSBIOS:3961		     mov     di, 0FFFFh
DOSBIOS:3964		     jmp     short InsuffHMA
DOSBIOS:3966 ; ---------------------------------------------------------------------------
DOSBIOS:3966
DOSBIOS:3966 try_4:				     ; CODE XREF: DOSBIOS:395Fj
DOSBIOS:3966		     mov     di, ds:FreeHMAPtr
DOSBIOS:396A		     add     bx, 15
DOSBIOS:396D		     and     bx, 0FFF0h
DOSBIOS:3970		     add     ds:FreeHMAPtr, bx
DOSBIOS:3974		     jnz     short InsuffHMA
DOSBIOS:3976		     mov     ds:FreeHMAPtr, 0FFFFh
DOSBIOS:397C
DOSBIOS:397C InsuffHMA:				     ; CODE XREF: DOSBIOS:3959j
DOSBIOS:397C					     ; DOSBIOS:3964j ...
DOSBIOS:397C		     pop     ds
DOSBIOS:397D		     jmp     ii2f_iret
DOSBIOS:3980 ; ---------------------------------------------------------------------------
DOSBIOS:3980
DOSBIOS:3980 try_3:				     ; CODE XREF: DOSBIOS:394Bj
DOSBIOS:3980		     jmp     ii2f_iret
DOSBIOS:3983
DOSBIOS:3983 ; =============== S U B R O U T I N E =======================================
DOSBIOS:3983
DOSBIOS:3983
DOSBIOS:3983 HMAPtr	     proc near		     ; CODE XREF: DOSBIOS:3935p
DOSBIOS:3983					     ; DOSBIOS:3953p
DOSBIOS:3983		     mov     ds, word ptr cs:aCon+3 ; [cs:Bios_Data_Word]
DOSBIOS:3988		     assume ds:nothing
DOSBIOS:3988		     mov     di, ds:FreeHMAPtr
DOSBIOS:398C		     cmp     di, 0FFFFh
DOSBIOS:398F		     jnz     short HMAPtr_retn
DOSBIOS:3991		     cmp     ds:SysinitPresent,	0
DOSBIOS:3996		     jz	     short HMAPtr_retn
DOSBIOS:3998		     call    ds:MoveDOSIntoHMA ; call far [MoveDOSIntoHMA]
DOSBIOS:399C		     mov     di, ds:FreeHMAPtr
DOSBIOS:39A0
DOSBIOS:39A0 HMAPtr_retn:			     ; CODE XREF: HMAPtr+Cj
DOSBIOS:39A0					     ; HMAPtr+13j
DOSBIOS:39A0		     retn
DOSBIOS:39A0 HMAPtr	     endp
DOSBIOS:39A0
DOSBIOS:39A1
DOSBIOS:39A1 ; =============== S U B R O U T I N E =======================================
DOSBIOS:39A1
DOSBIOS:39A1
DOSBIOS:39A1 move_sector     proc near		     ; CODE XREF: DOSBIOS:3B7Dp
DOSBIOS:39A1					     ; DOSBIOS:3BEDp ...
DOSBIOS:39A1		     cld
DOSBIOS:39A2		     push    cx
DOSBIOS:39A3		     mov     cx, 256
DOSBIOS:39A6		     cmp     si, 0FE00h
DOSBIOS:39AA		     ja	     short movsec_bytes
DOSBIOS:39AC		     cmp     di, 0FE00h
DOSBIOS:39B0		     ja	     short movsec_bytes
DOSBIOS:39B2		     rep movsw
DOSBIOS:39B4		     pop     cx
DOSBIOS:39B5		     retn
DOSBIOS:39B6 ; ---------------------------------------------------------------------------
DOSBIOS:39B6
DOSBIOS:39B6 movsec_bytes:			     ; CODE XREF: move_sector+9j
DOSBIOS:39B6					     ; move_sector+Fj
DOSBIOS:39B6		     shl     cx, 1
DOSBIOS:39B8		     rep movsb
DOSBIOS:39BA		     pop     cx
DOSBIOS:39BB		     retn
DOSBIOS:39BB move_sector     endp
DOSBIOS:39BB
DOSBIOS:39BC
DOSBIOS:39BC ; =============== S U B R O U T I N E =======================================
DOSBIOS:39BC
DOSBIOS:39BC
DOSBIOS:39BC check_wrap	     proc near		     ; CODE XREF: DOSBIOS:3B32p
DOSBIOS:39BC					     ; DOSBIOS:3C34p ...
DOSBIOS:39BC		     push    ax
DOSBIOS:39BD		     push    bx
DOSBIOS:39BE		     push    es
DOSBIOS:39BF		     push    di
DOSBIOS:39C0		     call    find_bds
DOSBIOS:39C3		     jb	     short no_wrap
DOSBIOS:39C5		     test    word ptr es:[di+23h], 1 ; word [es:di+BDS.flags],fnon_removable
DOSBIOS:39CB		     jz	     short no_wrap
DOSBIOS:39CD		     mov     bx, es:[di+13h] ; [es:di+BDS.secpertrack]
DOSBIOS:39D1		     mov     ax, cx
DOSBIOS:39D3		     and     ax, 3Fh	     ; extract sector number
DOSBIOS:39D6		     cmp     ax, bx	     ; are we going to wrap?
DOSBIOS:39D8		     jbe     short no_wrap
DOSBIOS:39DA		     div     bl		     ; ah=new sector #,	al=# of	head wraps
DOSBIOS:39DC		     or	     ah, ah	     ; if the new sector # is 0,
DOSBIOS:39DC					     ; it is the last sector on	that track.
DOSBIOS:39DE		     jnz     short not_on_bound
DOSBIOS:39E0		     mov     ah, bl	     ; set sector=BDS_BPB.BPB_SECTORSPERTRACK
DOSBIOS:39E0					     ; if on boundary
DOSBIOS:39E2		     dec     al		     ; also decrement #	of head	wraps
DOSBIOS:39E4
DOSBIOS:39E4 not_on_bound:			     ; CODE XREF: check_wrap+22j
DOSBIOS:39E4		     and     cl, 0C0h	     ; zero out	sector #
DOSBIOS:39E7		     or	     cl, ah	     ; or in new sector	#
DOSBIOS:39E9		     xor     ah, ah	     ; ax = # of head wraps
DOSBIOS:39EB		     inc     ax
DOSBIOS:39EC		     add     al, dh	     ; add in starting head #
DOSBIOS:39EE		     adc     ah, 0	     ; catch any carry
DOSBIOS:39F1		     cmp     ax, es:[di+15h] ; [es:di+BDS.heads]
DOSBIOS:39F1					     ; are we going to wrap around a head?
DOSBIOS:39F5		     jbe     short no_wrap_head	; do not lose new head number!!
DOSBIOS:39F7		     push    dx
DOSBIOS:39F8		     xor     dx, dx
DOSBIOS:39FA		     mov     bx, es:[di+15h] ; [es:di+BDS.heads]
DOSBIOS:39FE		     div     bx		     ; dx=new head #, ax=# of cylinder wraps
DOSBIOS:3A00		     or	     dx, dx	     ; if new head # is	0,
DOSBIOS:3A00					     ; it is the last head.
DOSBIOS:3A02		     jnz     short no_head_bound
DOSBIOS:3A04		     mov     dx, bx	     ; on boundary. set	to BDS_BPB.BPB_HEADS
DOSBIOS:3A06		     or	     ax, ax
DOSBIOS:3A08		     jz	     short no_head_bound
DOSBIOS:3A0A		     dec     ax		     ; reduce number of	cylinder wraps
DOSBIOS:3A0B
DOSBIOS:3A0B no_head_bound:			     ; CODE XREF: check_wrap+46j
DOSBIOS:3A0B					     ; check_wrap+4Cj
DOSBIOS:3A0B		     mov     bh, dl	     ; bh has new head number
DOSBIOS:3A0D		     pop     dx
DOSBIOS:3A0E		     dec     bh		     ; get it 0-based
DOSBIOS:3A10		     mov     dh, bh	     ; set up new head number in dh
DOSBIOS:3A12		     mov     bh, cl
DOSBIOS:3A14		     and     bh, 3Fh	     ; preserve	sector number
DOSBIOS:3A17		     mov     bl, 6
DOSBIOS:3A19		     xchg    cl, bl
DOSBIOS:3A1B		     shr     bl, cl	     ; get ms cylinder bits to ls end
DOSBIOS:3A1D		     add     ch, al	     ; add in cylinder wrap
DOSBIOS:3A1F		     adc     bl, ah	     ; add in high byte
DOSBIOS:3A21		     shl     bl, cl	     ; move up to ms end
DOSBIOS:3A23		     xchg    bl, cl	     ; restore cylinder	bits into cl
DOSBIOS:3A25		     or	     cl, bh	     ; or in sector number
DOSBIOS:3A27
DOSBIOS:3A27 no_wrap:				     ; CODE XREF: check_wrap+7j
DOSBIOS:3A27					     ; check_wrap+Fj ...
DOSBIOS:3A27		     clc
DOSBIOS:3A28		     pop     di
DOSBIOS:3A29		     pop     es
DOSBIOS:3A2A		     assume es:nothing
DOSBIOS:3A2A		     pop     bx
DOSBIOS:3A2B		     pop     ax
DOSBIOS:3A2C		     retn
DOSBIOS:3A2D ; ---------------------------------------------------------------------------
DOSBIOS:3A2D
DOSBIOS:3A2D no_wrap_head:			     ; CODE XREF: check_wrap+39j
DOSBIOS:3A2D		     mov     dh, al	     ; do not lose new head number
DOSBIOS:3A2F		     dec     dh		     ; get it 0-based
DOSBIOS:3A31		     jmp     short no_wrap
DOSBIOS:3A31 check_wrap	     endp
DOSBIOS:3A31
DOSBIOS:3A33
DOSBIOS:3A33 ; =============== S U B R O U T I N E =======================================
DOSBIOS:3A33
DOSBIOS:3A33
DOSBIOS:3A33 find_bds	     proc near		     ; CODE XREF: check_wrap+4p
DOSBIOS:3A33					     ; DOSBIOS:3BFBp
DOSBIOS:3A33		     les     di, ds:start_bds
DOSBIOS:3A37
DOSBIOS:3A37 fbds_1:				     ; CODE XREF: find_bds+10j
DOSBIOS:3A37		     cmp     es:[di+4],	dl   ; [es:di+BDS.drivenum]
DOSBIOS:3A3B		     jz	     short fdbs_2
DOSBIOS:3A3D		     les     di, es:[di]     ; [es:di+BDS.link]
DOSBIOS:3A40		     cmp     di, 0FFFFh
DOSBIOS:3A43		     jnz     short fbds_1
DOSBIOS:3A45		     stc
DOSBIOS:3A46
DOSBIOS:3A46 fdbs_2:				     ; CODE XREF: find_bds+8j
DOSBIOS:3A46		     retn
DOSBIOS:3A46 find_bds	     endp
DOSBIOS:3A46
DOSBIOS:3A47
DOSBIOS:3A47 ; =============== S U B R O U T I N E =======================================
DOSBIOS:3A47
DOSBIOS:3A47
DOSBIOS:3A47 doint	     proc near		     ; CODE XREF: DOSBIOS:3BC2p
DOSBIOS:3A47					     ; DOSBIOS:doblockdointp ...
DOSBIOS:3A47		     mov     dl, [bp+8]	     ; [bp+INT13FRAME.olddx]
DOSBIOS:3A47					     ; get physical drive number
DOSBIOS:3A4B		     xor     ah, ah
DOSBIOS:3A4D		     or	     al, al
DOSBIOS:3A4F		     jz	     short dointdone ; if zero sectors,	return ax=0
DOSBIOS:3A51		     mov     ah, [bp+3]	     ; [bp+INT13FRAME.oldax+1]
DOSBIOS:3A51					     ; get request code
DOSBIOS:3A55		     push    word ptr [bp+10h] ; [bp+INT13FRAME.oldf]
DOSBIOS:3A59		     popf
DOSBIOS:3A5A		     call    call_orig13     ; call far	70h:797h
DOSBIOS:3A5A					     ; call far	KERNEL_SEGMENT:call_orig13
DOSBIOS:3A5F		     pushf
DOSBIOS:3A60		     pop     word ptr [bp+10h] ; [bp+INT13FRAME.oldf]
DOSBIOS:3A64
DOSBIOS:3A64 dointdone:				     ; CODE XREF: doint+8j
DOSBIOS:3A64		     retn
DOSBIOS:3A64 doint	     endp
DOSBIOS:3A64
DOSBIOS:3A64 ; ---------------------------------------------------------------------------
DOSBIOS:3A65 dtype_array     dd	400090h		     ; 40:90 is	drive type array
DOSBIOS:3A69 ; ---------------------------------------------------------------------------
DOSBIOS:3A69
DOSBIOS:3A69 format_special_stuff:		     ; CODE XREF: DOSBIOS:3AC7j
DOSBIOS:3A69		     cmp     ds:fhave96, 0
DOSBIOS:3A6E		     jz	     short format_special_stuff_done
DOSBIOS:3A70		     push    bx
DOSBIOS:3A71		     mov     bx, 140h	     ; fchanged_by_format+fchanged
DOSBIOS:3A74		     call    set_changed_dl
DOSBIOS:3A77		     pop     bx
DOSBIOS:3A78		     jmp     short format_special_stuff_done
DOSBIOS:3A7A ; ---------------------------------------------------------------------------
DOSBIOS:3A7A
DOSBIOS:3A7A ec35_special_stuff:		     ; CODE XREF: DOSBIOS:3ACEj
DOSBIOS:3A7A		     test    dl, dl
DOSBIOS:3A7C		     js	     short ec35_special_stuff_done ; if	hard drive, we're done
DOSBIOS:3A7E		     push    ax
DOSBIOS:3A7F		     push    cx
DOSBIOS:3A80		     mov     cl, dl	     ; turn drive number into bit map
DOSBIOS:3A82		     mov     al, 1	     ; assume drive 0
DOSBIOS:3A84		     shl     al, cl	     ; shift over correct number of times
DOSBIOS:3A86		     test    ds:ec35flag, al
DOSBIOS:3A8A		     pop     cx
DOSBIOS:3A8B		     pop     ax
DOSBIOS:3A8C		     jz	     short ec35_special_stuff_done ;
DOSBIOS:3A8C					     ; done if this floppy is not an ec35
DOSBIOS:3A8E		     push    bx		     ; free up a far pointer (es:bx)
DOSBIOS:3A8F		     push    es
DOSBIOS:3A90		     les     bx, dword ptr cs:loc_1BF2+3 ; [cs:dtype_array]
DOSBIOS:3A90					     ; 0070h:3A65h = 2C7h:14F5h
DOSBIOS:3A95		     add     bl, dl
DOSBIOS:3A97		     adc     bh, 0
DOSBIOS:3A9A		     mov     byte ptr es:[bx], 93h ; establish drive type as:
DOSBIOS:3A9A					     ; (360k disk in 360k drive,
DOSBIOS:3A9A					     ; no double-stepping, 250 kbs transfer rate)
DOSBIOS:3A9E		     pop     es
DOSBIOS:3A9F		     pop     bx
DOSBIOS:3AA0		     jmp     short ec35_special_stuff_done
DOSBIOS:3AA2 ; ---------------------------------------------------------------------------
DOSBIOS:3AA2
DOSBIOS:3AA2 ps2_special_stuff:			     ; CODE XREF: DOSBIOS:3ADBj
DOSBIOS:3AA2		     cmp     ds:prevoper, 8  ; (ps2_30)
DOSBIOS:3AA2					     ; read driver parm	?
DOSBIOS:3AA7		     jz	     short ps2_30_problem
DOSBIOS:3AA9		     cmp     ds:prevoper, 15h ;	apparently function 15h	fails, too
DOSBIOS:3AAE		     jnz     short ps2_special_stuff_done
DOSBIOS:3AB0
DOSBIOS:3AB0 ps2_30_problem:			     ; CODE XREF: DOSBIOS:3AA7j
DOSBIOS:3AB0		     push    ax
DOSBIOS:3AB1		     mov     ah, 1
DOSBIOS:3AB3		     call    call_orig13     ; call far	70:797h
DOSBIOS:3AB3					     ; call far	KERNEL_SEGMENT:call_orig13
DOSBIOS:3AB8		     pop     ax
DOSBIOS:3AB9		     jmp     short ps2_special_stuff_done
DOSBIOS:3ABB ; ---------------------------------------------------------------------------
DOSBIOS:3ABB
DOSBIOS:3ABB i13z:				     ; 0070h:3ABBh = 02C7h:154Bh
DOSBIOS:3ABB		     push    ds
DOSBIOS:3ABC		     mov     ds, word ptr cs:aCon+3 ; [cs:BiosdataWord]
DOSBIOS:3ABC					     ; = [02C7h:0030h] = [0070h:25A0h]
DOSBIOS:3AC1		     mov     ds:prevoper, ax
DOSBIOS:3AC4		     cmp     ah, 5	     ; romformat
DOSBIOS:3AC7		     jz	     short format_special_stuff
DOSBIOS:3AC9
DOSBIOS:3AC9 format_special_stuff_done:		     ; CODE XREF: DOSBIOS:3A6Ej
DOSBIOS:3AC9					     ; DOSBIOS:3A78j
DOSBIOS:3AC9		     cmp     ds:ec35flag, 0
DOSBIOS:3ACE		     jnz     short ec35_special_stuff
DOSBIOS:3AD0
DOSBIOS:3AD0 ec35_special_stuff_done:		     ; CODE XREF: DOSBIOS:3A7Cj
DOSBIOS:3AD0					     ; DOSBIOS:3A8Cj ...
DOSBIOS:3AD0		     call    call_orig13
DOSBIOS:3AD5		     pushf
DOSBIOS:3AD6		     cmp     ds:model_byte, 0FAh ; 'ú'
DOSBIOS:3ADB		     jz	     short ps2_special_stuff
DOSBIOS:3ADD
DOSBIOS:3ADD ps2_special_stuff_done:		     ; CODE XREF: DOSBIOS:3AAEj
DOSBIOS:3ADD					     ; DOSBIOS:3AB9j
DOSBIOS:3ADD		     popf
DOSBIOS:3ADE		     jb	     short goterr13  ; error on	original orig13	call-thru?
DOSBIOS:3AE0
DOSBIOS:3AE0 ret_from_i13:			     ; CODE XREF: DOSBIOS:i13ret_ck_chglinerrj
DOSBIOS:3AE0					     ; DOSBIOS:3AFFj ...
DOSBIOS:3AE0		     pop     ds
DOSBIOS:3AE1		     assume ds:nothing
DOSBIOS:3AE1		     retf    2		     ; restore ds & iret w/flags
DOSBIOS:3AE4 ; ---------------------------------------------------------------------------
DOSBIOS:3AE4
DOSBIOS:3AE4 i13ret_ck_chglinerr:		     ; CODE XREF: DOSBIOS:3B5Cj
DOSBIOS:3AE4					     ; DOSBIOS:3BDCj
DOSBIOS:3AE4		     jnb     short ret_from_i13	; done if not an error termination
DOSBIOS:3AE6
DOSBIOS:3AE6 i13_ret_error:			     ; CODE XREF: DOSBIOS:3B09j
DOSBIOS:3AE6					     ; DOSBIOS:3B10j ...
DOSBIOS:3AE6		     cmp     ah, 6	     ; did i see a change event?
DOSBIOS:3AE9		     jnz     short int13b    ; skip if wrong error
DOSBIOS:3AEB		     or	     dl, dl	     ; is this for the hard disk?
DOSBIOS:3AED		     js	     short int13b    ; yes, ignore
DOSBIOS:3AEF		     cmp     ds:fhave96, 0
DOSBIOS:3AF4		     jz	     short int13b    ; just in case ROM	returned this
DOSBIOS:3AF4					     ; error even though it told us it
DOSBIOS:3AF4					     ; never would
DOSBIOS:3AF6		     push    bx
DOSBIOS:3AF7		     mov     bx, 40h	     ; fchanged
DOSBIOS:3AFA		     call    set_changed_dl
DOSBIOS:3AFD		     pop     bx
DOSBIOS:3AFE
DOSBIOS:3AFE int13b:				     ; CODE XREF: DOSBIOS:3AE9j
DOSBIOS:3AFE					     ; DOSBIOS:3AEDj ...
DOSBIOS:3AFE		     stc
DOSBIOS:3AFF		     jmp     short ret_from_i13
DOSBIOS:3B01 ; ---------------------------------------------------------------------------
DOSBIOS:3B01
DOSBIOS:3B01 goterr13:				     ; CODE XREF: DOSBIOS:3ADEj
DOSBIOS:3B01		     cmp     ah, 9	     ; dma error?
DOSBIOS:3B04		     jz	     short gotdmaerr
DOSBIOS:3B06
DOSBIOS:3B06 goterr13_xxxx:			     ; CODE XREF: DOSBIOS:xgoterr13_xxxxj
DOSBIOS:3B06		     cmp     ah, 11h	     ; ecc error?
DOSBIOS:3B09		     jnz     short i13_ret_error ; other error.	just return back.
DOSBIOS:3B0B		     cmp     ds:media_set_for_format, 1	; formatting?
DOSBIOS:3B10		     jz	     short i13_ret_error
DOSBIOS:3B12		     cmp     byte ptr ds:prevoper+1, 2 ; ecc-corrected error
DOSBIOS:3B12					     ; (2 = romread)
DOSBIOS:3B12					     ; ECC correction only applies to reads
DOSBIOS:3B17		     jnz     short i13_ret_error
DOSBIOS:3B19		     xor     ah, ah
DOSBIOS:3B1B		     call    call_orig13     ; call far	KERNEL_SEGMENT:call_orig13
DOSBIOS:3B1B					     ; call far	70:797h
DOSBIOS:3B20		     mov     ax, ds:prevoper
DOSBIOS:3B23		     xor     ah, ah	     ; return code = no	error
DOSBIOS:3B25		     cmp     al, 1	     ; if request for one sector, assume ok
DOSBIOS:3B27		     jz	     short ret_from_i13	; return with carry clear
DOSBIOS:3B29		     push    bx
DOSBIOS:3B2A		     push    cx
DOSBIOS:3B2B		     push    dx
DOSBIOS:3B2C		     mov     ds:number_of_sec, al
DOSBIOS:3B2F
DOSBIOS:3B2F loop_ecc:				     ; CODE XREF: DOSBIOS:3B56j
DOSBIOS:3B2F		     mov     ax, 201h	     ; read one	sector
DOSBIOS:3B32		     call    check_wrap	     ; get correct parameters for int 13
DOSBIOS:3B35		     call    call_orig13     ; call far	KERNEL_SEGMENT:call_orig13
DOSBIOS:3B3A		     jnb     short ok11_op
DOSBIOS:3B3C		     cmp     ah, 9	     ; DMA error during	ECC read?
DOSBIOS:3B3F		     jz	     short handle_dma_during_ecc
DOSBIOS:3B41		     cmp     ah, 11h	     ; only allow ecc errors
DOSBIOS:3B44		     jnz     short ok11_exit_err
DOSBIOS:3B46		     mov     ah, 0	     ; ecc error. reset	the system again.
DOSBIOS:3B48		     xor     ax, ax	     ; clear the error code so that if this
DOSBIOS:3B48					     ; was the last sector, no error code
DOSBIOS:3B48					     ; will be returned	for the	corrected
DOSBIOS:3B48					     ; read. (clear carry too.)
DOSBIOS:3B4A
DOSBIOS:3B4A ok11_op:				     ; CODE XREF: DOSBIOS:3B3Aj
DOSBIOS:3B4A					     ; DOSBIOS:3B82j
DOSBIOS:3B4A		     dec     ds:number_of_sec
DOSBIOS:3B4E		     jz	     short ok11_exit ; all done?
DOSBIOS:3B50		     inc     cl		     ; advance sector number
DOSBIOS:3B50					     ; add 200h	to address
DOSBIOS:3B52		     inc     bh
DOSBIOS:3B54		     inc     bh
DOSBIOS:3B56		     jmp     short loop_ecc
DOSBIOS:3B58 ; ---------------------------------------------------------------------------
DOSBIOS:3B58
DOSBIOS:3B58 ok11_exit_err:			     ; CODE XREF: DOSBIOS:3B44j
DOSBIOS:3B58					     ; DOSBIOS:3B74j
DOSBIOS:3B58		     stc
DOSBIOS:3B59
DOSBIOS:3B59 ok11_exit:				     ; CODE XREF: DOSBIOS:3B4Ej
DOSBIOS:3B59		     pop     dx
DOSBIOS:3B5A		     pop     cx
DOSBIOS:3B5B		     pop     bx
DOSBIOS:3B5C		     jmp     short i13ret_ck_chglinerr
DOSBIOS:3B5E ; ---------------------------------------------------------------------------
DOSBIOS:3B5E
DOSBIOS:3B5E handle_dma_during_ecc:		     ; CODE XREF: DOSBIOS:3B3Fj
DOSBIOS:3B5E		     push    es
DOSBIOS:3B5F		     push    bx
DOSBIOS:3B60		     mov     bx, offset	disksector
DOSBIOS:3B63		     push    ds
DOSBIOS:3B64		     pop     es
DOSBIOS:3B65		     mov     ax, 201h
DOSBIOS:3B68		     call    call_orig13     ; call far	KERNEL_SEGMENT:call_orig13
DOSBIOS:3B6D		     pop     bx
DOSBIOS:3B6E		     pop     es
DOSBIOS:3B6F		     jnb     short handle_dma_during_ecc_noerr
DOSBIOS:3B71		     cmp     ah, 11h
DOSBIOS:3B74		     jnz     short ok11_exit_err ; if anything but ecc error, bomb out
DOSBIOS:3B76
DOSBIOS:3B76 handle_dma_during_ecc_noerr:	     ; CODE XREF: DOSBIOS:3B6Fj
DOSBIOS:3B76		     push    si		     ; kosher
DOSBIOS:3B77		     push    di
DOSBIOS:3B78		     mov     di, bx
DOSBIOS:3B7A		     mov     si, offset	disksector
DOSBIOS:3B7D		     call    move_sector
DOSBIOS:3B80		     pop     di
DOSBIOS:3B81		     pop     si
DOSBIOS:3B82		     jmp     short ok11_op
DOSBIOS:3B84 ; ---------------------------------------------------------------------------
DOSBIOS:3B84
DOSBIOS:3B84 gotdmaerr:				     ; CODE XREF: DOSBIOS:3B04j
DOSBIOS:3B84		     mov     ax, ds:prevoper ; dma violation
DOSBIOS:3B87		     sti
DOSBIOS:3B88		     cmp     ah, 2	     ; romread
DOSBIOS:3B8B		     jb	     short i13_done_dmaerr
DOSBIOS:3B8D		     cmp     ah, 4	     ; romverify
DOSBIOS:3B90		     jz	     short intverify
DOSBIOS:3B92		     cmp     ah, 5	     ; romformat
DOSBIOS:3B95		     jz	     short intformat
DOSBIOS:3B97		     ja	     short i13_done_dmaerr
DOSBIOS:3B99		     push    dx
DOSBIOS:3B9A		     push    cx
DOSBIOS:3B9B		     push    bx
DOSBIOS:3B9C		     push    ax
DOSBIOS:3B9D		     push    bp
DOSBIOS:3B9E		     mov     bp, sp
DOSBIOS:3BA0		     mov     dx, es	     ; check for 64k boundary error
DOSBIOS:3BA2		     shl     dx, 1
DOSBIOS:3BA4		     shl     dx, 1
DOSBIOS:3BA6		     shl     dx, 1
DOSBIOS:3BA8		     shl     dx, 1	     ; segment converted to absolute address
DOSBIOS:3BAA		     add     dx, bx	     ; combine with offset
DOSBIOS:3BAC		     add     dx, 511	     ; simulate	a transfer
DOSBIOS:3BAC					     ; if carry	is set,
DOSBIOS:3BAC					     ; then we are within 512 bytes of
DOSBIOS:3BAC					     ; the end of the segment
DOSBIOS:3BB0		     jnb     short no_skip_first
DOSBIOS:3BB2		     jmp     bufferx	     ; restore dh=head & do buffer
DOSBIOS:3BB5 ; ---------------------------------------------------------------------------
DOSBIOS:3BB5
DOSBIOS:3BB5 no_skip_first:			     ; CODE XREF: DOSBIOS:3BB0j
DOSBIOS:3BB5		     shr     dh, 1	     ; dh = number of sectors before address
DOSBIOS:3BB7		     mov     ah, 128	     ; ah = max	number of sectors in segment
DOSBIOS:3BB9		     sub     ah, dh
DOSBIOS:3BBB		     cmp     ah, al	     ; can we fit it in?
DOSBIOS:3BBD		     jb	     short doblock   ; no, perform blocking.
DOSBIOS:3BBF		     mov     dh, [bp+9]	     ; [bp+INT13FRAME.olddx+1]
DOSBIOS:3BBF					     ; set up head number
DOSBIOS:3BC2		     call    doint
DOSBIOS:3BC5		     jmp     bad13	     ; and return from this place
DOSBIOS:3BC8 ; ---------------------------------------------------------------------------
DOSBIOS:3BC8
DOSBIOS:3BC8 i13_done_dmaerr:			     ; CODE XREF: DOSBIOS:3B8Bj
DOSBIOS:3BC8					     ; DOSBIOS:3B97j
DOSBIOS:3BC8		     mov     ah, 9	     ; pass dma	error thru to caller
DOSBIOS:3BCA		     stc
DOSBIOS:3BCB		     jmp     ret_from_i13    ; return with error,
DOSBIOS:3BCB					     ; we know it's not a changeline error
DOSBIOS:3BCE ; ---------------------------------------------------------------------------
DOSBIOS:3BCE
DOSBIOS:3BCE intverify:				     ; CODE XREF: DOSBIOS:3B90j
DOSBIOS:3BCE		     push    es		     ; save caller's dma address
DOSBIOS:3BCF		     push    bx
DOSBIOS:3BD0		     push    ds		     ; es:bx ->	Bios_Data:disksector
DOSBIOS:3BD1		     pop     es
DOSBIOS:3BD2
DOSBIOS:3BD2 dosimple:				     ; CODE XREF: DOSBIOS:3BF3j
DOSBIOS:3BD2		     mov     bx, offset	disksector
DOSBIOS:3BD5		     call    call_orig13     ; call far	KERNEL_SEGMENT:call_orig13
DOSBIOS:3BDA		     pop     bx
DOSBIOS:3BDB		     pop     es
DOSBIOS:3BDC		     jmp     i13ret_ck_chglinerr
DOSBIOS:3BDF ; ---------------------------------------------------------------------------
DOSBIOS:3BDF
DOSBIOS:3BDF intformat:				     ; CODE XREF: DOSBIOS:3B95j
DOSBIOS:3BDF		     push    es
DOSBIOS:3BE0		     push    bx
DOSBIOS:3BE1		     push    si
DOSBIOS:3BE2		     push    di
DOSBIOS:3BE3		     push    ds
DOSBIOS:3BE4		     push    es
DOSBIOS:3BE5		     push    ds
DOSBIOS:3BE6		     pop     es
DOSBIOS:3BE7		     pop     ds
DOSBIOS:3BE8		     mov     si, bx
DOSBIOS:3BEA		     mov     di, offset	disksector
DOSBIOS:3BED		     call    move_sector     ; user's data into Bios_Data:disksector
DOSBIOS:3BF0		     pop     ds
DOSBIOS:3BF1		     pop     di
DOSBIOS:3BF2		     pop     si		     ; do the i/o from
DOSBIOS:3BF3		     jmp     short dosimple  ; Bios_Data:disksector
DOSBIOS:3BF5 ; ---------------------------------------------------------------------------
DOSBIOS:3BF5
DOSBIOS:3BF5 doblock:				     ; CODE XREF: DOSBIOS:3BBDj
DOSBIOS:3BF5		     mov     dx, [bp+8]	     ; we can't fit the request into the entire block.
DOSBIOS:3BF5					     ; perform the operation on	the first block
DOSBIOS:3BF5					     ; [bp+INT13FRAME.olddx]
DOSBIOS:3BF5					     ; get head	#, drive #
DOSBIOS:3BF8		     push    cx
DOSBIOS:3BF9		     push    es
DOSBIOS:3BFA		     push    di		     ; ah - # of sectors before	dma boundary
DOSBIOS:3BFA					     ; al - requested #	of sectors for i/o.
DOSBIOS:3BFB		     call    find_bds
DOSBIOS:3BFE		     mov     cx, es:[di+13h] ; [es:di+BDS.secpertrack]
DOSBIOS:3C02		     test    word ptr es:[di+23h], 1 ; [es:di+BDS.flags],fnon_removable
DOSBIOS:3C08		     pop     di
DOSBIOS:3C09		     pop     es
DOSBIOS:3C0A		     mov     al, ah	     ; set al=ah for floppies
DOSBIOS:3C0C		     jz	     short doblockflop ; they are track	by track operation
DOSBIOS:3C0E		     mov     ah, 63	     ; ah = 63-secpt (#	safe sectors??)
DOSBIOS:3C10		     sub     ah, cl	     ; al - # of sectors before	dma boundary
DOSBIOS:3C12
DOSBIOS:3C12 doblockflop:			     ; CODE XREF: DOSBIOS:3C0Cj
DOSBIOS:3C12		     pop     cx
DOSBIOS:3C13
DOSBIOS:3C13 doblockcontinue:			     ; CODE XREF: DOSBIOS:3C37j
DOSBIOS:3C13		     cmp     ah, al	     ; if safe_# >= #_of_sectors_to_go_before dma,
DOSBIOS:3C15		     jnb     short doblocklast ; then #_of_sectors_to_go as it is for doint.
DOSBIOS:3C17		     push    ax
DOSBIOS:3C18		     mov     al, ah	     ; otherwise, set al to ah to operate.
DOSBIOS:3C1A		     jmp     short doblockdoint
DOSBIOS:3C1C ; ---------------------------------------------------------------------------
DOSBIOS:3C1C
DOSBIOS:3C1C doblocklast:			     ; CODE XREF: DOSBIOS:3C15j
DOSBIOS:3C1C		     mov     ah, al
DOSBIOS:3C1E		     push    ax
DOSBIOS:3C1F
DOSBIOS:3C1F doblockdoint:			     ; CODE XREF: DOSBIOS:3C1Aj
DOSBIOS:3C1F		     call    doint	     ; let ah =	al = # of sectors for this shot
DOSBIOS:3C22		     jb	     short bad13     ; something happened, bye!
DOSBIOS:3C24		     pop     ax
DOSBIOS:3C25		     sub     [bp+2], ah	     ; sub [bp+INT13FRAME.oldax], ah
DOSBIOS:3C25					     ; decrement by the	successful operation
DOSBIOS:3C28		     add     cl, ah	     ; advance sector #. safety	gauranteed.
DOSBIOS:3C2A		     add     bh, ah	     ; advance dma addres
DOSBIOS:3C2C		     add     bh, ah	     ; twice for 512 byte sectors
DOSBIOS:3C2E		     cmp     ah, al	     ; check the previous value
DOSBIOS:3C30		     jz	     short buffer    ; if #_of_sectors_to_go < safe_#,
DOSBIOS:3C30					     ; then we are done	already.
DOSBIOS:3C32		     sub     al, ah	     ; otherwise,
DOSBIOS:3C32					     ; #_sector_to_go =	#_of_sector_to_go - safe_#
DOSBIOS:3C34		     call    check_wrap	     ; get new cx, dh for the next operation.
DOSBIOS:3C37		     jmp     short doblockcontinue ; handles next sectors left.
DOSBIOS:3C39 ; ---------------------------------------------------------------------------
DOSBIOS:3C39
DOSBIOS:3C39 bufferx:				     ; CODE XREF: DOSBIOS:3BB2j
DOSBIOS:3C39		     mov     dh, [bp+9]	     ; [bp+INT13FRAME.olddx+1]
DOSBIOS:3C39					     ; set up head number
DOSBIOS:3C3C
DOSBIOS:3C3C buffer:				     ; CODE XREF: DOSBIOS:3C30j
DOSBIOS:3C3C		     push    bx
DOSBIOS:3C3D		     mov     ah, [bp+3]	     ; [bp+INT13FRAME.oldax+1]
DOSBIOS:3C40		     cmp     ah, 3	     ; romwrite
DOSBIOS:3C43		     jnz     short doread    ;
DOSBIOS:3C43					     ; copy the	offending sector into local buffer
DOSBIOS:3C45		     push    es
DOSBIOS:3C46		     push    ds
DOSBIOS:3C47		     push    si
DOSBIOS:3C48		     push    di
DOSBIOS:3C49		     push    ds
DOSBIOS:3C4A		     push    es
DOSBIOS:3C4B		     pop     ds
DOSBIOS:3C4C		     pop     es
DOSBIOS:3C4D		     mov     di, offset	disksector
DOSBIOS:3C50		     push    di
DOSBIOS:3C51		     mov     si, bx
DOSBIOS:3C53		     call    move_sector     ; move sector into	local buffer
DOSBIOS:3C56		     pop     bx		     ; new transfer address
DOSBIOS:3C56					     ; (es:bx =	Bios_Data:diskbuffer)
DOSBIOS:3C57		     pop     di
DOSBIOS:3C58		     pop     si
DOSBIOS:3C59		     pop     ds
DOSBIOS:3C5A		     mov     al, 1	     ; [bp+INT13FRAME.olddx]
DOSBIOS:3C5A					     ; get drive number
DOSBIOS:3C5C		     mov     dl, [bp+8]
DOSBIOS:3C5F		     call    check_wrap	     ; sets up registers if wrap-around
DOSBIOS:3C5F					     ;
DOSBIOS:3C5F					     ; ah is function
DOSBIOS:3C5F					     ; al is 1 for single sector transfer
DOSBIOS:3C5F					     ; es:bx is	local transfer addres
DOSBIOS:3C5F					     ; cx is track/sector number
DOSBIOS:3C5F					     ; dx is head/drive	number
DOSBIOS:3C5F					     ; si,di unchanged
DOSBIOS:3C62		     call    doint
DOSBIOS:3C65		     pop     es
DOSBIOS:3C66		     jb	     short bad13
DOSBIOS:3C68		     jmp     short dotail
DOSBIOS:3C6A ; ---------------------------------------------------------------------------
DOSBIOS:3C6A
DOSBIOS:3C6A doread:				     ; CODE XREF: DOSBIOS:3C43j
DOSBIOS:3C6A		     push    es
DOSBIOS:3C6B		     push    bx
DOSBIOS:3C6C		     push    ds
DOSBIOS:3C6D		     pop     es
DOSBIOS:3C6E		     mov     bx, offset	disksector
DOSBIOS:3C71		     mov     al, 1
DOSBIOS:3C73		     mov     dl, [bp+8]	     ; [bp+INT13FRAME.olddx]
DOSBIOS:3C73					     ; get drive number
DOSBIOS:3C76		     call    check_wrap	     ;
DOSBIOS:3C76					     ; ah = function
DOSBIOS:3C76					     ; al = 1 for single sector
DOSBIOS:3C76					     ; es:bx points to local buffer
DOSBIOS:3C76					     ; cx, dx are track/sector,	head/drive
DOSBIOS:3C79		     call    doint
DOSBIOS:3C7C		     pop     bx
DOSBIOS:3C7D		     pop     es
DOSBIOS:3C7E		     jb	     short bad13
DOSBIOS:3C80		     push    si
DOSBIOS:3C81		     push    di
DOSBIOS:3C82		     mov     di, bx
DOSBIOS:3C84		     mov     si, offset	disksector
DOSBIOS:3C87		     call    move_sector
DOSBIOS:3C8A		     pop     di
DOSBIOS:3C8B		     pop     si
DOSBIOS:3C8C
DOSBIOS:3C8C dotail:				     ; CODE XREF: DOSBIOS:3C68j
DOSBIOS:3C8C		     pop     bx		     ; retrieve	new dma	area
DOSBIOS:3C8D		     add     bh, 2	     ; advance over sector
DOSBIOS:3C90		     inc     cx
DOSBIOS:3C91		     mov     al, [bp+2]	     ; [bp+INT13FRAME.oldax]
DOSBIOS:3C94		     clc
DOSBIOS:3C95		     dec     al
DOSBIOS:3C97		     jz	     short bad13
DOSBIOS:3C99		     mov     dl, [bp+8]	     ; [bp+INT13FRAME.olddx]
DOSBIOS:3C9C		     call    check_wrap
DOSBIOS:3C9F		     call    doint
DOSBIOS:3CA2
DOSBIOS:3CA2 bad13:				     ; CODE XREF: DOSBIOS:3BC5j
DOSBIOS:3CA2					     ; DOSBIOS:3C22j ...
DOSBIOS:3CA2		     mov     sp, bp
DOSBIOS:3CA4		     pop     bp
DOSBIOS:3CA5		     pop     bx
DOSBIOS:3CA6		     pop     bx
DOSBIOS:3CA7		     pop     cx
DOSBIOS:3CA8		     pop     dx
DOSBIOS:3CA9		     jb	     short xgoterr13_xxxx ; go handle ECC errors
DOSBIOS:3CAB		     jmp     ret_from_i13    ; non-error exit
DOSBIOS:3CAE ; ---------------------------------------------------------------------------
DOSBIOS:3CAE
DOSBIOS:3CAE xgoterr13_xxxx:			     ; CODE XREF: DOSBIOS:3CA9j
DOSBIOS:3CAE		     jmp     goterr13_xxxx
DOSBIOS:3CAE ; ---------------------------------------------------------------------------
DOSBIOS:3CB1		     db	   0
DOSBIOS:3CB2 ; ---------------------------------------------------------------------------
DOSBIOS:3CB2
DOSBIOS:3CB2 dsk_init:				     ; 2C7h:1742h = 70h:3CB2h
DOSBIOS:3CB2		     mov     ah, ds:drvmax
DOSBIOS:3CB6		     mov     di, offset	dskdrvs
DOSBIOS:3CB9		     push    ds		     ; pass result in es:di
DOSBIOS:3CBA		     pop     es
DOSBIOS:3CBB		     jmp     SetPtrSav
DOSBIOS:3CBE
DOSBIOS:3CBE ; =============== S U B R O U T I N E =======================================
DOSBIOS:3CBE
DOSBIOS:3CBE
DOSBIOS:3CBE install_bds     proc near		     ; CODE XREF: DOSBIOS:38E8p
DOSBIOS:3CBE		     push    ds		     ; install_bds installs a bds at location es:di
DOSBIOS:3CBE					     ; into the	current	linked list of bds
DOSBIOS:3CBE					     ; maintained by this device driver. it places
DOSBIOS:3CBE					     ; the bds at the end of the list.
DOSBIOS:3CBE					     ; Trashes (at least) ax, bx, di, si
DOSBIOS:3CBF		     mov     si, offset	start_bds
DOSBIOS:3CC2
DOSBIOS:3CC2 loop_next_bds:			     ; CODE XREF: install_bds+2Aj
DOSBIOS:3CC2		     lds     si, [si]	     ; [si+BDS.link]
DOSBIOS:3CC2					     ; fetch next bds
DOSBIOS:3CC4		     mov     al, es:[di+4]   ; [es:di+BDS.drivenum]
DOSBIOS:3CC8		     cmp     [si+4], al	     ; does this one share a physical
DOSBIOS:3CC8					     ; drive with new one?
DOSBIOS:3CCB		     jnz     short next_bds
DOSBIOS:3CCD		     mov     bl, 10h	     ; fi_am_mult
DOSBIOS:3CCF		     or	     es:[di+23h], bl ; [es:di+BDS.flags]
DOSBIOS:3CCF					     ; set both	of them	to i_am_mult if	so
DOSBIOS:3CD3		     or	     [si+23h], bl    ; [si+BDS.flags]
DOSBIOS:3CD6		     and     byte ptr es:[di+23h], 0DFh	; [es:di+BDS.flags],~fi_own_physical
DOSBIOS:3CD6					     ; we don't own it
DOSBIOS:3CDB		     mov     bl, [si+23h]    ; [si+BDS.flags]
DOSBIOS:3CDB					     ; determine if changeline available
DOSBIOS:3CDE		     and     bl, 2	     ; fchangeline
DOSBIOS:3CE1		     or	     es:[di+23h], bl ; [es:di+BDS.flags]
DOSBIOS:3CE5
DOSBIOS:3CE5 next_bds:				     ; CODE XREF: install_bds+Dj
DOSBIOS:3CE5		     cmp     word ptr [si], 0FFFFh ; [si+BDS.link],-1
DOSBIOS:3CE5					     ; are we at end of	list?
DOSBIOS:3CE8		     jnz     short loop_next_bds
DOSBIOS:3CEA		     mov     word ptr [si+2], es ; [si+BDS.link+2],es
DOSBIOS:3CEA					     ; install bds
DOSBIOS:3CED		     mov     [si], di
DOSBIOS:3CEF		     mov     word ptr es:[di], 0FFFFh ;	[es:di+BDS.link],-1
DOSBIOS:3CEF					     ; set next	pointer	to null
DOSBIOS:3CF4		     pop     ds
DOSBIOS:3CF5		     retn
DOSBIOS:3CF5 install_bds     endp
DOSBIOS:3CF5
DOSBIOS:3CF6 ; ---------------------------------------------------------------------------
DOSBIOS:3CF6
DOSBIOS:3CF6 swpdsk:				     ; CODE XREF: checksingle:ignore_sdsbp
DOSBIOS:3CF6		     test    ds:IsWin386, 1  ; Is win386 present?
DOSBIOS:3CFB		     jz	     short no_win386 ; no, skip	SetFocus
DOSBIOS:3CFD		     call    far ptr V86_Crit_SetFocus ; call far 70h:8D1h
DOSBIOS:3CFD					     ; call far	KERNEL_SEGMENT:V86_Crit_SetFocus
DOSBIOS:3D02
DOSBIOS:3D02 no_win386:				     ; CODE XREF: DOSBIOS:3CFBj
DOSBIOS:3D02		     push    cx
DOSBIOS:3D03		     push    dx
DOSBIOS:3D04		     mov     dl, es:[di+5]   ; [es:di+BDS.drivelet]
DOSBIOS:3D04					     ; get the drive letter
DOSBIOS:3D08		     mov     dh, dl
DOSBIOS:3D0A		     xor     dh, 1
DOSBIOS:3D0D		     sub     cx, cx	     ; nobody has handled swap disk
DOSBIOS:3D0F		     mov     ax, 4A00h	     ; multMULT<<8)|multMULTSWPDSK
DOSBIOS:3D0F					     ; broad cast code for swap	disk
DOSBIOS:3D0F					     ; Broadcast it
DOSBIOS:3D12		     int     2Fh
DOSBIOS:3D14		     inc     cx
DOSBIOS:3D15		     jz	     short swpdsk9   ; somebody	has handled it
DOSBIOS:3D17		     add     dl, 'A'
DOSBIOS:3D1A		     mov     byte ptr cs:off_1EE4, dl ;	[cs:drvlet]
DOSBIOS:3D1A					     ; 0070h:3D54h = 2C7h:17E4h
DOSBIOS:3D1F		     mov     si, 17C8h	     ; sngmsg
DOSBIOS:3D1F					     ; 0070h:3D38h = 2C7h:17C8h
DOSBIOS:3D22		     push    bx
DOSBIOS:3D23		     lods    byte ptr cs:[si]
DOSBIOS:3D25
DOSBIOS:3D25 wrmsg_loop:			     ; CODE XREF: DOSBIOS:3D2Bj
DOSBIOS:3D25		     int     29h	     ; DOS 2+ internal - FAST PUTCHAR
DOSBIOS:3D25					     ; AL = character to display
DOSBIOS:3D27		     lods    byte ptr cs:[si] ;	cs lodsb
DOSBIOS:3D27					     ; get the next character of the message
DOSBIOS:3D29		     or	     al, al
DOSBIOS:3D2B		     jnz     short wrmsg_loop
DOSBIOS:3D2D		     call    con_flush
DOSBIOS:3D30		     xor     ah, ah
DOSBIOS:3D32		     int     16h	     ; KEYBOARD	- READ CHAR FROM BUFFER, WAIT IF EMPTY
DOSBIOS:3D32					     ; Return: AH = scan code, AL = character
DOSBIOS:3D34		     pop     bx
DOSBIOS:3D35
DOSBIOS:3D35 swpdsk9:				     ; CODE XREF: DOSBIOS:3D15j
DOSBIOS:3D35		     pop     dx
DOSBIOS:3D36		     pop     cx
DOSBIOS:3D37		     retn
DOSBIOS:3D37 ; ---------------------------------------------------------------------------
DOSBIOS:3D38 sngmsg	     db	0Dh,0Ah
DOSBIOS:3D38		     db	'Insert diskette for drive '
DOSBIOS:3D54 drvlet	     db	'A: and press any key when ready',0Dh,0Ah
DOSBIOS:3D54		     db	0Ah,0
DOSBIOS:3D77
DOSBIOS:3D77 ; =============== S U B R O U T I N E =======================================
DOSBIOS:3D77
DOSBIOS:3D77
DOSBIOS:3D77 chkopcnt	     proc near		     ; CODE XREF: DOSBIOS:checklatchiop
DOSBIOS:3D77					     ; DOSBIOS:3E3Fp
DOSBIOS:3D77		     cmp     word ptr es:[di+20h], 0 ; [es:di+BDS.opcnt]
DOSBIOS:3D7C		     retn
DOSBIOS:3D7C chkopcnt	     endp
DOSBIOS:3D7C
DOSBIOS:3D7D
DOSBIOS:3D7D ; =============== S U B R O U T I N E =======================================
DOSBIOS:3D7D
DOSBIOS:3D7D
DOSBIOS:3D7D mediacheck	     proc near		     ; CODE XREF: DOSBIOS:2A8Fp
DOSBIOS:3D7D		     call    checksingle     ; make sure correct disk is in place
DOSBIOS:3D80		     xor     si, si
DOSBIOS:3D82		     call    haschange
DOSBIOS:3D85		     jz	     short mediaret
DOSBIOS:3D87		     call    checkromchange
DOSBIOS:3D8A		     jnz     short mediadovolid
DOSBIOS:3D8C		     push    ax
DOSBIOS:3D8D		     push    dx
DOSBIOS:3D8E		     mov     dl, es:[di+4]   ; [es:di+BDS.drivenum]
DOSBIOS:3D8E					     ; set logical drive number
DOSBIOS:3D92		     mov     ah, 16h
DOSBIOS:3D94		     int     13h	     ; DISK - FLOPPY DISK - CHANGE OF DISK STATUS (AT,XT2,XT286,CONV,PS)
DOSBIOS:3D94					     ; DL = drive to check
DOSBIOS:3D94					     ; Return: AH = disk change	status
DOSBIOS:3D96		     pop     dx
DOSBIOS:3D97		     pop     ax
DOSBIOS:3D98		     jb	     short mediadovolid
DOSBIOS:3D9A		     mov     si, 1	     ; signal no change
DOSBIOS:3D9D		     mov     bl, ds:tim_drv  ; get last	drive accessed
DOSBIOS:3DA1		     cmp     es:[di+4],	bl   ; [es:di+BDS.drivenum]
DOSBIOS:3DA1					     ; (If the last drive accessed is not current drive
DOSBIOS:3DA1					     ; media change status may be incorrect. So,
DOSBIOS:3DA1					     ; "I don't now" will be returned even if it is indicated
DOSBIOS:3DA1					     ; as media	is not changed.)
DOSBIOS:3DA5		     jz	     short mediaret  ; (same drive,
DOSBIOS:3DA5					     ; media changeline	indication is reliable)
DOSBIOS:3DA7		     push    ax
DOSBIOS:3DA8		     push    cx
DOSBIOS:3DA9		     push    dx
DOSBIOS:3DAA		     call    Check_Time_Of_Access
DOSBIOS:3DAD		     pop     dx
DOSBIOS:3DAE		     pop     cx
DOSBIOS:3DAF		     pop     ax
DOSBIOS:3DB0		     or	     si, si
DOSBIOS:3DB2		     jz	     short mediadovolid	; check_time says ">= 2	secs passed"
DOSBIOS:3DB2					     ; (volume id will be checked)
DOSBIOS:3DB4		     xor     si, si	     ; return "i don't know"
DOSBIOS:3DB6
DOSBIOS:3DB6 mediaret:				     ; CODE XREF: mediacheck+8j
DOSBIOS:3DB6					     ; mediacheck+28j ...
DOSBIOS:3DB6		     retn
DOSBIOS:3DB7 ; ---------------------------------------------------------------------------
DOSBIOS:3DB7
DOSBIOS:3DB7 mediadovolid:			     ; CODE XREF: mediacheck+Dj
DOSBIOS:3DB7					     ; mediacheck+1Bj ...
DOSBIOS:3DB7		     call    GetBp	     ; build a new bpb in current bds
DOSBIOS:3DBA		     jb	     short mediaret
DOSBIOS:3DBC		     call    check_vid
DOSBIOS:3DBF		     jnb     short mediaret
DOSBIOS:3DBF mediacheck	     endp
DOSBIOS:3DBF
DOSBIOS:3DC1		     jmp     maperror	     ; fix up al for return to dos
DOSBIOS:3DC4 ; ---------------------------------------------------------------------------
DOSBIOS:3DC4
DOSBIOS:3DC4 checklatchio:			     ; CODE XREF: diskio+83p
DOSBIOS:3DC4		     call    chkopcnt	     ; if returning fake bpb
DOSBIOS:3DC4					     ; then assume the disk has	not changed
DOSBIOS:3DC7		     jz	     short checkret
DOSBIOS:3DC9		     call    checkromchange  ; check for past rom indications.
DOSBIOS:3DC9					     ; if no rom change	indicated, then	return ok.
DOSBIOS:3DCC		     jz	     short checkret
DOSBIOS:3DCE		     call    GetBp	     ; build bpb in current bds
DOSBIOS:3DD1		     jb	     short ret_no_error_map ; getbp has	already	called maperror
DOSBIOS:3DD3		     call    check_vid
DOSBIOS:3DD6		     jb	     short checklatchret ; disk	error trying to	read in.
DOSBIOS:3DD8		     or	     si, si	     ; is changed for sure?
DOSBIOS:3DDA		     jns     short checkret
DOSBIOS:3DDC		     call    returnvid
DOSBIOS:3DDF
DOSBIOS:3DDF checklatchret:			     ; CODE XREF: DOSBIOS:3DD6j
DOSBIOS:3DDF		     call    maperror	     ; fix up al for return to dos
DOSBIOS:3DE2
DOSBIOS:3DE2 ret_no_error_map:			     ; CODE XREF: DOSBIOS:3DD1j
DOSBIOS:3DE2		     stc
DOSBIOS:3DE3		     pop     si		     ; pop off return address
DOSBIOS:3DE4
DOSBIOS:3DE4 checkret:				     ; CODE XREF: DOSBIOS:3DC7j
DOSBIOS:3DE4					     ; DOSBIOS:3DCCj ...
DOSBIOS:3DE4		     retn
DOSBIOS:3DE5 ; ---------------------------------------------------------------------------
DOSBIOS:3DE5
DOSBIOS:3DE5 checkfatvid:			     ; CODE XREF: DOSBIOS:3E49p
DOSBIOS:3DE5		     call    fat_check	     ; check the fat and the vid
DOSBIOS:3DE8		     or	     si, si
DOSBIOS:3DEA		     js	     short changed_drv ;
DOSBIOS:3DEA					     ; the fat was the same.
DOSBIOS:3DEA					     ; fall into check_vid and check volume id.
DOSBIOS:3DEC
DOSBIOS:3DEC ; =============== S U B R O U T I N E =======================================
DOSBIOS:3DEC
DOSBIOS:3DEC
DOSBIOS:3DEC check_vid	     proc near		     ; CODE XREF: mediacheck+3Fp
DOSBIOS:3DEC					     ; DOSBIOS:3DD3p
DOSBIOS:3DEC		     cmp     ds:disksector+26h,	29h ; [disksector+EXT_BOOT.SIG]
DOSBIOS:3DEC					     ; EXT_BOOT_SIGNATURE
DOSBIOS:3DF1		     jz	     short do_ext_check_id
DOSBIOS:3DF3		     call    haschange
DOSBIOS:3DF6		     jz	     short checkret
DOSBIOS:3DF8		     xor     si, si
DOSBIOS:3DFA		     cmp     ds:disksector+10h,	0 ; [disksector+EXT_BOOT.BPB+EBPB.NUMBEROFFATS]
DOSBIOS:3DFF		     jz	     short checkfatret ; don't read vol id
DOSBIOS:3DFF					     ; if not fat system
DOSBIOS:3E01		     call    read_volume_id
DOSBIOS:3E04		     jb	     short checkfatret
DOSBIOS:3E06		     call    check_volume_id
DOSBIOS:3E09		     mov     si, 0FFFFh	     ; -1
DOSBIOS:3E09					     ; definitely changed
DOSBIOS:3E0C		     jnz     short changed_drv
DOSBIOS:3E0E		     inc     si		     ; not changed
DOSBIOS:3E0F
DOSBIOS:3E0F vid_no_changed:			     ; CODE XREF: check_vid+45j
DOSBIOS:3E0F		     call    resetchanged
DOSBIOS:3E12		     clc
DOSBIOS:3E13
DOSBIOS:3E13 checkfatret:			     ; CODE XREF: check_vid+13j
DOSBIOS:3E13					     ; check_vid+18j ...
DOSBIOS:3E13		     retn
DOSBIOS:3E14 ; ---------------------------------------------------------------------------
DOSBIOS:3E14
DOSBIOS:3E14 changed_drv:			     ; CODE XREF: DOSBIOS:3DEAj
DOSBIOS:3E14					     ; check_vid+20j ...
DOSBIOS:3E14		     clc		     ; cas -- return no	error
DOSBIOS:3E15		     mov     ds:tim_drv, 0FFh ;	ensure that we ask rom for media
DOSBIOS:3E1A		     retn		     ; check next time round
DOSBIOS:3E1B ; ---------------------------------------------------------------------------
DOSBIOS:3E1B
DOSBIOS:3E1B do_ext_check_id:			     ; CODE XREF: check_vid+5j
DOSBIOS:3E1B		     push    ax
DOSBIOS:3E1C		     mov     ax, word ptr ds:disksector+27h ; [DiskSector+EXT_BOOT.SERIAL]
DOSBIOS:3E1F		     cmp     ax, es:[di+57h] ; [di+BDS.vol_serial]
DOSBIOS:3E23		     jnz     short ext_changed
DOSBIOS:3E25		     mov     ax, word ptr ds:disksector+29h ; [DiskSector+EXT_BOOT.SERIAL+2]
DOSBIOS:3E28		     cmp     ax, es:[di+59h] ; [di+BDS.vol_serial+2]
DOSBIOS:3E2C		     jnz     short ext_changed
DOSBIOS:3E2E		     xor     si, si	     ; 0
DOSBIOS:3E2E					     ; don't know
DOSBIOS:3E30		     pop     ax
DOSBIOS:3E31		     jmp     short vid_no_changed ; reset the flag
DOSBIOS:3E33 ; ---------------------------------------------------------------------------
DOSBIOS:3E33
DOSBIOS:3E33 ext_changed:			     ; CODE XREF: check_vid+37j
DOSBIOS:3E33					     ; check_vid+40j
DOSBIOS:3E33		     pop     ax
DOSBIOS:3E34		     mov     si, 0FFFFh	     ; -1
DOSBIOS:3E34					     ; disk changed!
DOSBIOS:3E37		     clc
DOSBIOS:3E38		     jmp     short changed_drv
DOSBIOS:3E38 check_vid	     endp
DOSBIOS:3E38
DOSBIOS:3E3A ; ---------------------------------------------------------------------------
DOSBIOS:3E3A
DOSBIOS:3E3A checkio:				     ; CODE XREF: Disk+F3p
DOSBIOS:3E3A		     cmp     ah, 6
DOSBIOS:3E3D		     jnz     short checkfatret
DOSBIOS:3E3F		     call    chkopcnt
DOSBIOS:3E42		     jz	     short checkfatret
DOSBIOS:3E44		     call    GetBp
DOSBIOS:3E47		     jb	     short no_error_map
DOSBIOS:3E49		     call    checkfatvid
DOSBIOS:3E4C		     jb	     short checkioret ;	disk error trying to read in.
DOSBIOS:3E4E		     or	     si, si	     ; is changed for sure?
DOSBIOS:3E50		     js	     short checkioerr ;	yes changed
DOSBIOS:3E52		     inc     bp		     ; allow a retry
DOSBIOS:3E53		     retn
DOSBIOS:3E54 ; ---------------------------------------------------------------------------
DOSBIOS:3E54
DOSBIOS:3E54 checkioerr:			     ; CODE XREF: DOSBIOS:3E50j
DOSBIOS:3E54		     call    returnvid
DOSBIOS:3E57
DOSBIOS:3E57 checkioret:			     ; CODE XREF: DOSBIOS:3E4Cj
DOSBIOS:3E57		     stc		     ; make sure carry gets passed through
DOSBIOS:3E58		     jmp     harderr
DOSBIOS:3E5B ; ---------------------------------------------------------------------------
DOSBIOS:3E5B
DOSBIOS:3E5B no_error_map:			     ; CODE XREF: DOSBIOS:3E47j
DOSBIOS:3E5B		     jmp     harderr2
DOSBIOS:3E5E
DOSBIOS:3E5E ; =============== S U B R O U T I N E =======================================
DOSBIOS:3E5E
DOSBIOS:3E5E
DOSBIOS:3E5E returnvid	     proc near		     ; CODE XREF: DOSBIOS:3DDCp
DOSBIOS:3E5E					     ; DOSBIOS:checkioerrp
DOSBIOS:3E5E		     mov     si, 22	     ; extra
DOSBIOS:3E5E					     ; offset into pointer to return value
DOSBIOS:3E61		     call    vid_into_packet
DOSBIOS:3E64		     mov     ah, 6
DOSBIOS:3E66		     stc
DOSBIOS:3E67		     retn
DOSBIOS:3E67 returnvid	     endp
DOSBIOS:3E67
DOSBIOS:3E68 ; ---------------------------------------------------------------------------
DOSBIOS:3E68
DOSBIOS:3E68 media_set_vid:			     ; CODE XREF: DOSBIOS:2AC0p
DOSBIOS:3E68		     mov     si, 15	     ; trans+1
DOSBIOS:3E68					     ; return the value	here in	packet
DOSBIOS:3E6B
DOSBIOS:3E6B ; =============== S U B R O U T I N E =======================================
DOSBIOS:3E6B
DOSBIOS:3E6B
DOSBIOS:3E6B vid_into_packet proc near		     ; CODE XREF: returnvid+3p
DOSBIOS:3E6B		     push    ds		     ; return pointer to vid in	bds at es:di in	packet[si]
DOSBIOS:3E6C		     lds     bx, ds:ptrsav
DOSBIOS:3E70		     add     di, 75	     ; BDS.volid
DOSBIOS:3E73		     mov     [bx+si], di
DOSBIOS:3E75		     sub     di, 75	     ; BDS.volid
DOSBIOS:3E78		     mov     word ptr [bx+si+2], es
DOSBIOS:3E7B		     pop     ds
DOSBIOS:3E7C		     retn
DOSBIOS:3E7C vid_into_packet endp
DOSBIOS:3E7C
DOSBIOS:3E7D ; ---------------------------------------------------------------------------
DOSBIOS:3E7D
DOSBIOS:3E7D hidensity:				     ; CODE XREF: GetBp+2Ap
DOSBIOS:3E7D		     test    word ptr es:[di+23h], 2 ; [es:di+BDS.flags]
DOSBIOS:3E7D					     ; fchangeline
DOSBIOS:3E83		     jz	     short dofloppy
DOSBIOS:3E85		     cmp     byte ptr es:[di+22h], 2 ; [es:di+BDS.formfactor]
DOSBIOS:3E85					     ; ffSmall
DOSBIOS:3E8A		     jz	     short dofloppy
DOSBIOS:3E8C		     cmp     ah, 0F9h	     ; 96 tpi drive ?
DOSBIOS:3E8F		     jnz     short dofloppy
DOSBIOS:3E91		     cmp     byte ptr es:[di+22h], 7 ; [es:di+BDS.formfactor]
DOSBIOS:3E91					     ; ffOther
DOSBIOS:3E96		     jz	     short Is720K
DOSBIOS:3E98		     cmp     byte ptr es:[di+22h], 9 ; [es:di+BDS.formfactor]
DOSBIOS:3E98					     ; ff288
DOSBIOS:3E9D		     jz	     short Is720K
DOSBIOS:3E9F		     mov     al, 7	     ; seven sectors / fat
DOSBIOS:3EA1		     mov     bx, 57359	     ; 224*256+0Fh
DOSBIOS:3EA4		     mov     cx, 2400	     ; 80*15*2
DOSBIOS:3EA7		     mov     dx, 258	     ; 1*256+2
DOSBIOS:3EAA		     add     sp, 2
DOSBIOS:3EAD		     jmp     Has1
DOSBIOS:3EB0 ; ---------------------------------------------------------------------------
DOSBIOS:3EB0
DOSBIOS:3EB0 Is720K:				     ; CODE XREF: DOSBIOS:3E96j
DOSBIOS:3EB0					     ; DOSBIOS:3E9Dj
DOSBIOS:3EB0		     add     sp, 2
DOSBIOS:3EB3		     jmp     Has720K
DOSBIOS:3EB6 ; ---------------------------------------------------------------------------
DOSBIOS:3EB6
DOSBIOS:3EB6 dofloppy:				     ; CODE XREF: DOSBIOS:3E83j
DOSBIOS:3EB6					     ; DOSBIOS:3E8Aj ...
DOSBIOS:3EB6		     retn
DOSBIOS:3EB7
DOSBIOS:3EB7 ; =============== S U B R O U T I N E =======================================
DOSBIOS:3EB7
DOSBIOS:3EB7
DOSBIOS:3EB7 set_changed_dl  proc near		     ; CODE XREF: ChangeLineChk+26p
DOSBIOS:3EB7					     ; DOSBIOS:3A74p ...
DOSBIOS:3EB7		     push    es
DOSBIOS:3EB8		     push    di
DOSBIOS:3EB9		     les     di, ds:start_bds
DOSBIOS:3EBD
DOSBIOS:3EBD scan_bds:				     ; CODE XREF: set_changed_dl+16j
DOSBIOS:3EBD		     cmp     es:[di+4],	dl   ; [es:di+BDS.drivenum]
DOSBIOS:3EC1		     jnz     short get_next_bds
DOSBIOS:3EC3		     or	     es:[di+23h], bx ; [es:di+BDS.flags]
DOSBIOS:3EC3					     ; signal change on	other drive
DOSBIOS:3EC7
DOSBIOS:3EC7 get_next_bds:			     ; CODE XREF: set_changed_dl+Aj
DOSBIOS:3EC7		     les     di, es:[di]     ; [es:di+BDS.link]
DOSBIOS:3EC7					     ; go to next bds
DOSBIOS:3ECA		     cmp     di, 0FFFFh
DOSBIOS:3ECD		     jnz     short scan_bds  ; loop unless we hit end of chain
DOSBIOS:3ECF		     pop     di
DOSBIOS:3ED0		     pop     es
DOSBIOS:3ED1		     retn
DOSBIOS:3ED1 set_changed_dl  endp
DOSBIOS:3ED1
DOSBIOS:3ED2
DOSBIOS:3ED2 ; =============== S U B R O U T I N E =======================================
DOSBIOS:3ED2
DOSBIOS:3ED2
DOSBIOS:3ED2 checkromchange  proc near		     ; CODE XREF: mediacheck+Ap
DOSBIOS:3ED2					     ; DOSBIOS:3DC9p
DOSBIOS:3ED2		     test    word ptr es:[di+23h], 40h ; [es:di+BDS.flags]
DOSBIOS:3ED2					     ; fchanged
DOSBIOS:3ED8		     retn
DOSBIOS:3ED8 checkromchange  endp
DOSBIOS:3ED8
DOSBIOS:3ED9
DOSBIOS:3ED9 ; =============== S U B R O U T I N E =======================================
DOSBIOS:3ED9
DOSBIOS:3ED9
DOSBIOS:3ED9 resetchanged    proc near		     ; CODE XREF: movbpb+33p
DOSBIOS:3ED9					     ; check_vid:vid_no_changedp ...
DOSBIOS:3ED9		     and     word ptr es:[di+23h], 0FFBFh ; [es:di+BDS.flags]
DOSBIOS:3ED9					     ; ~fchanged
DOSBIOS:3EDE		     retn
DOSBIOS:3EDE resetchanged    endp
DOSBIOS:3EDE
DOSBIOS:3EDF
DOSBIOS:3EDF ; =============== S U B R O U T I N E =======================================
DOSBIOS:3EDF
DOSBIOS:3EDF
DOSBIOS:3EDF haschange	     proc near		     ; CODE XREF: DOSBIOS:2A94p
DOSBIOS:3EDF					     ; ChangeLineChk+17p ...
DOSBIOS:3EDF		     test    word ptr es:[di+23h], 2 ; [es:di+BDS.flags]
DOSBIOS:3EDF					     ; fchangeline
DOSBIOS:3EE5		     retn
DOSBIOS:3EE5 haschange	     endp
DOSBIOS:3EE5
DOSBIOS:3EE6 ; ---------------------------------------------------------------------------
DOSBIOS:3EE6
DOSBIOS:3EE6 set_volume_id:			     ; CODE XREF: DOSBIOS:2B2Fp
DOSBIOS:3EE6		     push    dx
DOSBIOS:3EE7		     push    ax
DOSBIOS:3EE8		     call    haschange	     ; does drive have changeline support?
DOSBIOS:3EEB		     jz	     short setvret   ; no, get out
DOSBIOS:3EED		     call    read_volume_id
DOSBIOS:3EF0		     jb	     short seterr
DOSBIOS:3EF2		     call    transfer_volume_id	; copy the volume id to	special	drive
DOSBIOS:3EF5		     call    resetchanged    ; restore value of	change line
DOSBIOS:3EF8
DOSBIOS:3EF8 setvret:				     ; CODE XREF: DOSBIOS:3EEBj
DOSBIOS:3EF8		     clc
DOSBIOS:3EF9		     pop     ax
DOSBIOS:3EFA		     pop     dx
DOSBIOS:3EFB		     retn
DOSBIOS:3EFC ; ---------------------------------------------------------------------------
DOSBIOS:3EFC
DOSBIOS:3EFC seterr:				     ; CODE XREF: DOSBIOS:3EF0j
DOSBIOS:3EFC		     pop     dx
DOSBIOS:3EFD		     pop     dx
DOSBIOS:3EFE		     retn
DOSBIOS:3EFE ; ---------------------------------------------------------------------------
DOSBIOS:3EFF root_sec	     dw	0		     ; root sector #
DOSBIOS:3F01
DOSBIOS:3F01 ; =============== S U B R O U T I N E =======================================
DOSBIOS:3F01
DOSBIOS:3F01
DOSBIOS:3F01 read_volume_id  proc near		     ; CODE XREF: check_vid+15p
DOSBIOS:3F01					     ; DOSBIOS:3EEDp
DOSBIOS:3F01		     push    dx
DOSBIOS:3F02		     push    cx
DOSBIOS:3F03		     push    bx
DOSBIOS:3F04		     push    ax
DOSBIOS:3F05		     push    es
DOSBIOS:3F06		     push    di
DOSBIOS:3F07		     push    ds
DOSBIOS:3F08		     pop     es
DOSBIOS:3F09		     mov     di, offset	tmp_vid	; "NO NAME    "
DOSBIOS:3F0C		     mov     si, offset	nul_vid	; "NO NAME    "
DOSBIOS:3F0F		     mov     cx, 12	     ; initialize tmp_vid to null vi_id
DOSBIOS:3F12		     rep movsb
DOSBIOS:3F14		     pop     di
DOSBIOS:3F15		     pop     es
DOSBIOS:3F16		     mov     al, es:[di+11]  ; [es:di+BDS.fats]
DOSBIOS:3F16					     ; # of fats
DOSBIOS:3F1A		     mov     cx, es:[di+17]  ; [es:di+BDS.fatsecs]
DOSBIOS:3F1A					     ; sectors / fat
DOSBIOS:3F1E		     mul     cl		     ; size taken by fats
DOSBIOS:3F20		     add     ax, es:[di+9]   ; [es:di+BDS.resectors]
DOSBIOS:3F20					     ; add on reserved sectors
DOSBIOS:3F20					     ;
DOSBIOS:3F20					     ; ax is now sector	# (0 based)
DOSBIOS:3F24		     mov     word ptr cs:loc_208E+1, ax	; [cs:root_sec]
DOSBIOS:3F24					     ; 0070h:3EFFh = 2C7h:198Fh
DOSBIOS:3F28		     mov     ax, es:[di+12]  ; [es:di+BDS.direntries]
DOSBIOS:3F28					     ; # root dir entries
DOSBIOS:3F2C		     mov     cl, 4	     ; 16 entries/sector
DOSBIOS:3F2E		     shr     ax, cl	     ; divide by 16
DOSBIOS:3F30		     mov     cx, ax	     ; cx is # of sectors to scan
DOSBIOS:3F32
DOSBIOS:3F32 next_sec:				     ; CODE XREF: read_volume_id+6Fj
DOSBIOS:3F32		     push    cx
DOSBIOS:3F33		     mov     ax, word ptr cs:loc_208E+1	; [cs:root_sec]
DOSBIOS:3F33					     ; get sector #
DOSBIOS:3F37		     mov     cx, es:[di+19]  ; [es:di+BDS.secpertrack]
DOSBIOS:3F37					     ; sectors / track
DOSBIOS:3F3B		     xor     dx, dx
DOSBIOS:3F3D		     div     cx
DOSBIOS:3F3F		     inc     dx		     ; dx= sectors into	track
DOSBIOS:3F3F					     ; ax= track count from 0
DOSBIOS:3F40		     mov     cl, dl	     ; sector to read
DOSBIOS:3F42		     xor     dx, dx
DOSBIOS:3F44		     div     word ptr es:[di+21] ; [es:di+BDS.heads]
DOSBIOS:3F44					     ; # heads on this disc
DOSBIOS:3F48		     mov     dh, dl	     ; head number
DOSBIOS:3F4A		     mov     ch, al	     ; track #
DOSBIOS:3F4C		     call    read_sector     ; get first sector	of the root directory,
DOSBIOS:3F4C					     ; ds:bx ->	directory sector
DOSBIOS:3F4F		     jb	     short readviderr
DOSBIOS:3F51		     mov     cx, 16	     ; # of dir	entries	in a block of root
DOSBIOS:3F54		     mov     al, 8	     ; volume label bit
DOSBIOS:3F56
DOSBIOS:3F56 fvid_loop:				     ; CODE XREF: read_volume_id+67j
DOSBIOS:3F56		     cmp     byte ptr [bx], 0 ;	end of dir?
DOSBIOS:3F59		     jz	     short no_vid    ; yes, no vol id
DOSBIOS:3F5B		     cmp     byte ptr [bx], 0E5h ; empty entry?
DOSBIOS:3F5E		     jz	     short ent_loop  ; yes, skip
DOSBIOS:3F60		     test    [bx+11], al     ; is volume label bit set in fcb?
DOSBIOS:3F63		     jnz     short found_vid ; jmp yes
DOSBIOS:3F65
DOSBIOS:3F65 ent_loop:				     ; CODE XREF: read_volume_id+5Dj
DOSBIOS:3F65		     add     bx, 32	     ; add length of directory entry
DOSBIOS:3F68		     loop    fvid_loop
DOSBIOS:3F6A		     pop     cx
DOSBIOS:3F6B		     inc     word ptr cs:loc_208E+1 ; inc word [root_sec]
DOSBIOS:3F6B					     ; next sector
DOSBIOS:3F70		     loop    next_sec
DOSBIOS:3F72
DOSBIOS:3F72 notfound:				     ; CODE XREF: read_volume_id+92j
DOSBIOS:3F72		     xor     si, si
DOSBIOS:3F74		     jmp     short fvid_ret
DOSBIOS:3F76 ; ---------------------------------------------------------------------------
DOSBIOS:3F76
DOSBIOS:3F76 found_vid:				     ; CODE XREF: read_volume_id+62j
DOSBIOS:3F76		     pop     cx
DOSBIOS:3F77		     mov     si, bx	     ; point to	volume_id
DOSBIOS:3F79		     push    es
DOSBIOS:3F7A		     push    di
DOSBIOS:3F7B		     push    ds
DOSBIOS:3F7C		     pop     es
DOSBIOS:3F7D		     mov     di, offset	tmp_vid	; "NO NAME    "
DOSBIOS:3F80		     mov     cx, 11	     ; VOLID_SIZ-1
DOSBIOS:3F80					     ; length of string	minus nul
DOSBIOS:3F83		     rep movsb		     ; mov volume label	to tmp_vid
DOSBIOS:3F85		     xor     al, al	     ; null terminate
DOSBIOS:3F87		     stosb
DOSBIOS:3F88		     xor     si, si
DOSBIOS:3F8A		     pop     di
DOSBIOS:3F8B		     pop     es
DOSBIOS:3F8C
DOSBIOS:3F8C fvid_ret:				     ; CODE XREF: read_volume_id+73j
DOSBIOS:3F8C		     pop     ax
DOSBIOS:3F8D		     clc
DOSBIOS:3F8E
DOSBIOS:3F8E rvidret:				     ; CODE XREF: read_volume_id+96j
DOSBIOS:3F8E		     pop     bx
DOSBIOS:3F8F		     pop     cx
DOSBIOS:3F90		     pop     dx
DOSBIOS:3F91		     retn
DOSBIOS:3F92 ; ---------------------------------------------------------------------------
DOSBIOS:3F92
DOSBIOS:3F92 no_vid:				     ; CODE XREF: read_volume_id+58j
DOSBIOS:3F92		     pop     cx
DOSBIOS:3F93		     jmp     short notfound
DOSBIOS:3F95 ; ---------------------------------------------------------------------------
DOSBIOS:3F95
DOSBIOS:3F95 readviderr:			     ; CODE XREF: read_volume_id+4Ej
DOSBIOS:3F95		     pop     si
DOSBIOS:3F96		     pop     si
DOSBIOS:3F97		     jmp     short rvidret
DOSBIOS:3F97 read_volume_id  endp
DOSBIOS:3F97
DOSBIOS:3F99
DOSBIOS:3F99 ; =============== S U B R O U T I N E =======================================
DOSBIOS:3F99
DOSBIOS:3F99
DOSBIOS:3F99 transfer_volume_id	proc near	     ; CODE XREF: DOSBIOS:3EF2p
DOSBIOS:3F99		     push    di		     ; copy the	volume id from tmp to special drive
DOSBIOS:3F9A		     push    si
DOSBIOS:3F9B		     push    cx
DOSBIOS:3F9C		     mov     si, offset	tmp_vid	; "NO NAME    "
DOSBIOS:3F9F		     add     di, 75	     ; BDS.volid
DOSBIOS:3FA2		     mov     cx, 12	     ; VOLID_SIZ
DOSBIOS:3FA5		     cld
DOSBIOS:3FA6		     rep movsb
DOSBIOS:3FA8		     pop     cx
DOSBIOS:3FA9		     pop     si
DOSBIOS:3FAA		     pop     di
DOSBIOS:3FAB		     retn
DOSBIOS:3FAB transfer_volume_id	endp
DOSBIOS:3FAB
DOSBIOS:3FAC
DOSBIOS:3FAC ; =============== S U B R O U T I N E =======================================
DOSBIOS:3FAC
DOSBIOS:3FAC
DOSBIOS:3FAC check_volume_id proc near		     ; CODE XREF: check_vid+1Ap
DOSBIOS:3FAC		     push    di
DOSBIOS:3FAD		     push    cx
DOSBIOS:3FAE		     mov     si, offset	tmp_vid	; "NO NAME    "
DOSBIOS:3FB1		     add     di, 75	     ; BDS.volid
DOSBIOS:3FB4		     mov     cx, 12	     ; VOLID_SIZ
DOSBIOS:3FB7		     cld
DOSBIOS:3FB8		     repe cmpsb		     ; are the 2 volume_ids the	same?
DOSBIOS:3FBA		     pop     cx
DOSBIOS:3FBB		     pop     di
DOSBIOS:3FBC		     retn
DOSBIOS:3FBC check_volume_id endp
DOSBIOS:3FBC
DOSBIOS:3FBD
DOSBIOS:3FBD ; =============== S U B R O U T I N E =======================================
DOSBIOS:3FBD
DOSBIOS:3FBD
DOSBIOS:3FBD fat_check	     proc near		     ; CODE XREF: DOSBIOS:checkfatvidp
DOSBIOS:3FBD		     push    ax
DOSBIOS:3FBE		     xor     si, si	     ; say fat id's are same.
DOSBIOS:3FC0		     mov     al, ds:medbyt
DOSBIOS:3FC3		     cmp     al, es:[di+10h] ; [es:di+BDS.media]
DOSBIOS:3FC3					     ; compare it with the bds medbyte
DOSBIOS:3FC7		     jz	     short okret1    ; carry clear
DOSBIOS:3FC9		     dec     si
DOSBIOS:3FCA
DOSBIOS:3FCA okret1:				     ; CODE XREF: fat_check+Aj
DOSBIOS:3FCA		     pop     ax
DOSBIOS:3FCB		     retn
DOSBIOS:3FCB fat_check	     endp
DOSBIOS:3FCB
DOSBIOS:3FCB ; ---------------------------------------------------------------------------
DOSBIOS:3FCC		     db	4 dup(0)	     ; times 4 db 0
DOSBIOS:3FCC DOSBIOS	     ends
DOSBIOS:3FCC
DOSBIOS:3FCC
DOSBIOS:3FCC		     end
