; ****************************************************************************
; MSDOS5BS.S (MSDOS 5.0 BOOT SECTOR) - source code by ERDOGAN TAN - 03/11/2022
; ----------------------------------------------------------------------------
; Last Update: 03/11/2022
; ----------------------------------------------------------------------------
; Assembler: NASM version 2.11 (2.15) 
; ----------------------------------------------------------------------------
;	   ((nasm msdos5bs.s -l msdos5bs.lst -o MSDOS5BS.BIN -Z error.txt)) 	
; ----------------------------------------------------------------------------
; Ref:	MSDOS 6.0 source code - MSBOOT.ASM (1991) - boot sector code
; Ref:	Disassembled MSDOS 5.0 (bootable fd) boot sector code
;	(Disassembler: HEX-RAYS IDA Pro)
; 				Converted to NASM source code by Erdogan Tan 
; ----------------------------------------------------------------------------

; [[ Most of comments here are from the original MSDOS 6.0 boot source code ]]

;-----------------------------------------------------------------------------
; MSBOOT.ASM (Microsoft, 1991)
;-----------------------------------------------------------------------------

; The ROM in the IBM PC starts the boot process by performing a hardware
; initialization and a verification of all external devices.  If all goes
; well, it will then load from the boot drive the sector from track 0, head 0,
; sector 1.  This sector is placed at physical address 07C00h.	The initial
; registers are set up as follows:  CS=DS=ES=SS=0.  IP=7C00h, SP=0400H.
;
; The code in this sector is responsible for locating the MSDOS device drivers
; (IBMBIO) and for placing the directory sector with this information at
; physical address 00500h.  After loading in this sector, it reads in the
; entirety of the BIOS at BIOSEG:0 and does a long jump to that point.
;
; If no BIOS/DOS pair is found an error message is displayed and the user is
; prompted to reinsert another disk.  If there is a disk error during the
; process, a message is displayed and things are halted.
;
; At the beginning of the boot sector, there is a table which describes the
; MSDOS structure of the media.  This is equivalent to the BPB with some
; additional information describing the physical layout of the driver (heads,
; tracks, sectors)

;-----------------------------------------------------------------------------

ORIGIN		EQU	7C00h		; Origin of bootstrap LOADER
BIO_SEG		EQU	70h		; Destination segment of BIOS
BIO_OFFSET	EQU	700h		; Offset of bios
SECTOR_SIZE	EQU	512		; Sector size in bytes
DIR_ENTRY_SIZE	EQU	32		; Size of directory entry in bytes
DIR_OFF		EQU	500h
IBM_LOAD_SIZE	EQU	3		; Size of IBMLOAD module in sectors
ROM_DISKRD	EQU	2
DSK_PARMS	EQU	1Eh*4		; POINTER TO DRIVE PARAMETERS

;=============================================================================

; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2013 Hex-Rays, <support@hex-rays.com>	    |
; |			 Licensed to: Freeware version			    |
; +-------------------------------------------------------------------------+

;=============================================================================

		[BITS 16]
	
		[ORG 7C00h]
START:
		jmp	short MAIN	; 0EBh,3Ch
;-----------------------------------------------------------------------------
		nop			; 90h
;-----------------------------------------------------------------------------
OS:		db 'MSDOS'		; (OEM name or Operating System name)
OsVersion:	db '5.0'		; DOS version number
BytesPerSector:	dw 512			; Size of a physical sector
SecsPerClust:	db 1			; Sectors per allocation unit
ReservedSecs:	dw 1			; Number of reserved sectors
NumFats:	db 2			; Number of FATs
NumDirEntries:	dw 224			; Number of directory entries
TotalSectors:	dw 2880			; Number of sectors - number of hidden
					; sectors (0 when 32 bit sector number)
MediaByte:	db 0F0h			; MediaByte (MediaID) byte
NumFatSecs:	dw 9			; Number of FAT sectors
SecPerTrack:	dw 18			; Sectors per track
NumHeads:	dw 2			; Number of drive heads
HiddenSecs:	dd 0			; Number of hidden sectors
BigTotalSecs:	dd 0			; 32 bit version of number of sectors
BootDrv:	db 0			; (0 for fd, 80h for hd).
CurrentHead:	db 0			; Current head
ExtBootSig:	db 29h			; Extended boot signature
SerialNum:	dd 350518E3h		; Volume serial number (Volume ID)
VolumeLabel:	db 'BOOT500    '	; Volume label ('NO NAME    ') 
FatId:		db 'FAT12   '		; ('FAT16   ' or 'FAT12   ') 
;-----------------------------------------------------------------------------

uData	equ	$			; Equates to allow access to
					; storage where Main is now
Sec9	equ	uData+0			; 11 byte diskette parm. table
BiosLow	equ	uData+11
BiosHigh equ	uData+13
CurTrk	equ	uData+15
CurSec	equ	uData+17
DirLow	equ	uData+18
DirHigh	equ	uData+20

;-----------------------------------------------------------------------------

	; First thing is to reset the stack to a better and more known
	; place. The ROM  may change, but we'd like to get the stack
	; in the correct place.
MAIN:
		cli			; Stop interrupts till stack ok
		xor	ax,ax
		mov	ss,ax		; Work in stack just below this routine

		mov	sp,ORIGIN	; 7C00h	
		push	ss
		pop	es

	; We copy the disk parameter table into a local area. We scan
	; the table above for non-zero parameters. Any we see get
	; changed to their non-zero values. We copy the disk parameter
	; table into a local area (overlayed into the code)

		mov	bx,DSK_PARMS	; 78h (1Eh*4) -INT 1Eh vector-
		lds	si,[ss:bx]	; get address of disk table
		push	ds		; save original vector for possible
		push	si		; restore
		push	ss
		push	bx
		mov	di,Sec9		; 7C3Eh
		mov	cx,11
		cld
		rep	movsb
		push	es
		pop	ds		; DS = ES = code = 0.

	; Set the head settle time to 15ms because we don't have room
	; to do a disk retry and then set sectors per from the value
	; in the BPB

		mov	byte [di-2],0Fh	; Head settle time
		mov	cx,[SecPerTrack]
		mov	byte [di-7],cl	; End of Track

		mov	[bx+2],AX	; Place in new disk parameter
		mov	word [bx],Sec9	; table vector

	; We may now turn interrupts back on. Before this, there is
	; a small window when a reboot command may come in when the
	; disk parameter table is garbage

		sti			; Interrupts OK now
		int	13h		; Reset the disk system just in case
		jc	short CkErr	; any thing funny has happened.

		; The system is now prepared for us to begin reading.
		; First, determine logical sector numbers of the start of the
		; directory and the start of the data area.

		xor	ax,ax		; 0
		cmp	[TotalSectors],ax ; 32 bit calculation?
		je	short Dir_Cont

		mov	cx,[TotalSectors]
		mov	[BigTotalSecs],cx ; Low 16 bit of 32 bit total sectors

Dir_Cont:
		mov	al,[NumFats]	; Determine sector dir starts on
		mul	word [NumFatSecs] ; DX:AX
		add	ax,[HiddenSecs]
		adc	dx,[HiddenSecs+2]
		add	ax,[ReservedSecs]
		adc	dx,0

	; DX:AX = NumFats * NumFatSecs + ReservedSecs + cSecHid

		mov	[DirLow],ax
		mov	[DirHigh],dx
		mov	[BiosLow],ax
		mov	[BiosHigh],dx

	; Take into account size of directory (only know number
	; of directory entries)

		mov	ax,DIR_ENTRY_SIZE ; bytes per directory entry
		mul	word [NumDirEntries] ; convert to bytes in directory
		mov	bx,[BytesPerSector] ; add in sector size
		add	ax,bx
		dec	ax		; decrement so that we round up
		div	bx		; convert to sector number
		add	[BiosLow],ax	; Start sector # of Data area
		adc	word [BiosHigh],0
	
	; -------------------------------------------------------------	
	; NOTE:
	; Microsoft dos programmers were calling 'IO.SYS' as dos 'BIOS'
	; (Also, they were calling 'ROMBIOS' as 'ROM' only!)
	; -------------------------------------------------------------

	; We load in the first directory sector and examine it to
	; make sure the the BIOS and DOS are the first two directory
	; entries. If they are not found, the user is prompted to
	; insert a new disk. The directory sector is loaded into 00500h

		mov	bx,DIR_OFF	; sector to go in at 00500h

		mov	dx,[DirHigh]
		mov	ax,[DirLow]	; logical sector of directory
		call	DODIV		; convert to sector, track, head
		jc	short CkErr	; Overflow? BPB must be wrong!!

		mov	al,1		; disk read 1 sector
		call	DOCALL		; do the disk read
		jb	short CkErr	; if errors try to recover

	; Now we scan for the presence of BIOS file.

		mov	di,bx
		mov	cx,11
		mov	SI,Bio ; IO.SYS	; point to "ibmbio  com"
		repz	cmpsb		; see if the same
		jnz	short CkErr	; if not there advise the user

	; Found the BIOS. Check the second directory entry.
	; SI will already point to "MSDOS  SYS" if first compare
	; was successful

		lea	di,[bx+20h]
	;**	mov	si,Dos ; MSDOS.SYS
		mov	cx,11
		repz	cmpsb
		jz	short DoLoad

	; There has been some recoverable error. Display a message
	; and wait for a keystroke.

CkErr:		mov	si,SysMsg	; point to no system message
ErrOut:		call	WRITE		; and write on the screen

		xor	ax,ax		; wait for response
		int	16h		; get character from keyboard
		pop	si		; reset disk parameter table
		pop	ds		; back to rom
		pop	word [si]
		pop	word [si+2]
		int	19h		; Continue in loop till good disk
Load_Failure:
		pop	ax		; adjust the stack
		pop	ax
		pop	ax
		jmp	short CkErr	; display message and reboot.

	; We now begin to load the BIOS in.
	; All we have to do is just read is multiply the BioStartClus
	; by SecsPerClust to find the logical sector for the start
	; of the BIOS file. When this value is added to the double
	; word BiosHigh:BiosLow we get the absolute sector offset
	; for the start of the file and then read the  sectors
	; contiguously IBM_LOAD_SIZE times. We here assume that
	; IBMLOAD module is contiguous. Currently we estimate that
	; IBMLOAD module will not be more than 3 sectors.
DoLoad:
		mov	ax,[bx+1Ah]	; AX = BIOS starting cluster
		dec	ax		; Subtract first 2 reserved clusters
		dec	ax
		mov	bl,[SecsPerClust] ; BX = Sectors per cluster
		xor	bh,bh
		mul	bx		; DX:AX = first logical sector of bios

		add	ax,[BiosLow]	; Add absolute start sector
		adc	dx,[BiosHigh]	; DX:AX = Absolute bios sector offset

		mov	bx,BIO_OFFSET	; offset of ibmbio(IBMLOAD) to be loaded.
		mov	cx,IBM_LOAD_SIZE ; # of sectors to read.
Do_While:
		push	ax
		push	dx
		push	cx
		call	DODIV		; DX:AX = sector number.
		jc	short Load_Failure ; Adjust stack. Show error message
		mov	al,1		; Read 1 sector at a time.
					; This is to handle a case of media
					; when the first sector of IBMLOAD is
					; the last sector in a track.
		call	DOCALL		; Read the sector.
		pop	cx
		pop	dx
		pop	ax
		jc	short CkErr	; Read error?
		add	ax,1		; Next sector number.
		adc	dx,0
		add	bx,[BytesPerSector] ; Adjust buffer address.
		loop	Do_While


;-----------------------------------------------------------------------------
; Main read-in loop.
; ES:BX points to area to read.
; Count is the number of sectors remaining.
; BIOS$ is the next logical sector number to read
;
; CurrentHead is the head for this next disk request
; CurTrk is the track for this next request
; CurSec is the beginning sector number for this request
;
; AX is the number of sectors that we may read.
;
;-----------------------------------------------------------------------------
;
; IBMINIT requires the following input conditions:
;
;   DL = INT 13 drive number we booted from
;   CH = media byte
;   IBMBIO init routine should check if the boot record is the
;   extended one by looking at the extended_boot_signature.
;   If it is, then should us AX:BX for the starting data sector number.
;-----------------------------------------------------------------------------

DISKOK:
		mov	ch,[MediaByte]
		mov	dl,[BootDrv]
		mov	bx,[BiosLow]	; Get bios sector in ax:bx
		mov	ax,[BiosHigh]	;
		;jmp	70h:0
		jmp	BIO_SEG:0	; CRANK UP THE DOS

;-----------------------------------------------------------------------------

WRITE:
		lodsb			; GET NEXT CHARACTER
		or	al,al		; Clear the high bit
		jz	short EndWr	; ERROR MESSAGE UP, JUMP TO BASIC
		mov	ah,14		; WILL WRITE CHARACTER & ATTRIBUTE
		mov	bx,7		; ATTRIBUTE
		int	10h		; PRINT THE CHARACTER
		jmp	short WRITE

;-----------------------------------------------------------------------------

	; Convert a logical sector into Track/sector/head.
	; DX:AX has the sector number. Because of not enough space, we
	; are  going to use Simple 32 bit division here.
	; Carry set if DX:AX is too big to handle.

DODIV:
		cmp	dx,[SecPerTrack]  ; To prevent overflow!!!
		jae	short DivOverFlow ; Compare high word with the divisor.
		div	word [SecPerTrack] ; AX = Total tracks
					; DX = sector number
		inc	dl		; We assume SecPerTrack < 255 & DH=0
					; curSec is 1-based.
		mov	[CurSec],dl	; Save it
		xor	dx,dx
		div	word [NumHeads]
		mov	[CurrentHead],dl ; Also, NumHeads < 255.
		mov	[CurTrk],ax
		clc
		retn
DivOverFlow:
		stc
EndWr:
		retn

;-----------------------------------------------------------------------------
;
; Issue one read request. ES:BX have the transfer address,
; AL is the number of sectors.
;
;-----------------------------------------------------------------------------

DOCALL:
		mov	ah,ROM_DISKRD	; =2
		mov	dx,[CurTrk]
		mov	cl,6
		shl	dh,cl
		or	dh,[CurSec]
		mov	cx,dx
		xchg	ch,cl
		mov	dl,[BootDrv]
		mov	dh,[CurrentHead]
		int	13h
		retn

;-----------------------------------------------------------------------------

; include boot.cl1 - 'non system disk' message

;-----------------------------------------------------------------------------

SysMsg:		db 0Dh,0Ah		; crlf
		db 'Non-System disk or disk error',0Dh,0Ah
		db 'Replace and press any key when ready',0Dh,0Ah,0

;-----------------------------------------------------------------------------

; MSDOS bios and kernel files: IO.SYS and MSDOS.SYS

;-----------------------------------------------------------------------------

	;IF IBMCOPYRIGHT
;Bio:		db	"IBMBIO  COM"
;Dos:		db	"IBMDOS  COM"
	;ELSE
Bio:		db	"IO      SYS"
Dos:		db	"MSDOS   SYS"
	;ENDIF

;-----------------------------------------------------------------------------

		times	(SECTOR_SIZE - 2) - ($-START) db 0

;-----------------------------------------------------------------------------

		db	55h,0AAh		; Boot sector signature

;=============================================================================

; Erdogan Tan - Istanbul - 03/11/2022
