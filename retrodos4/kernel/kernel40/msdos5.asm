
;
; +-------------------------------------------------------------------------+
; |   This file has been generated by The Interactive Disassembler (IDA)    |
; |           Copyright (c) 2013 Hex-Rays, <support@hex-rays.com>           |
; |                      Licensed to: Freeware version                      |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	926BAF897B78FE053F29FC8FF8CFD7C5
; Input	CRC32 :	64D3C385

; ---------------------------------------------------------------------------
; File Name   :	C:\Users\Erdoðan\Desktop\MSDOS5.SYS
; Format      :	Binary file
; Base Address:	0000h Range: 0000h - 9212h Loaded length: 9212h

		.386
		.model flat

; ===========================================================================

; Segment type:	Pure code
DOSCODE		segment	byte public 'CODE' use16
		assume cs:DOSCODE
		;org 3DD0h
		assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing

_$STARTCODE:				; ...
		jmp	DOSINIT
; ---------------------------------------------------------------------------
		dw offset _$STARTCODE	; PARASTART
BioDataSeg	dw 70h
DosDSeg		dw 0			; ...
MSMAJOR		db 5			; MAJOR_VERSION
MSMINOR		db 0			; MINOR_VERSION
I21_MAP_E_TAB	db 38h,	2, 1, 2		; ...
		db 39h,	3, 3, 2, 5
		db 3Ah,	4, 10h,	3, 2, 5
		db 3Bh,	2, 2, 3
		db 3Ch,	4, 3, 2, 4, 5
		db 3Dh,	6, 3, 2, 0Ch, 4, 1Ah, 5
		db 3Eh,	1, 6
		db 3Fh,	2, 6, 5
		db 40h,	2, 6, 5
		db 41h,	3, 3, 2, 5
		db 42h,	2, 6, 1
		db 43h,	4, 3, 2, 1, 5
		db 44h,	5, 0Fh,	0Dh, 1,	6, 5
		db 45h,	2, 6, 4
		db 46h,	2, 6, 4
		db 47h,	2, 1Ah,	0Fh
		db 48h,	2, 7, 8
		db 49h,	2, 7, 9
		db 4Ah,	3, 7, 9, 8
		db 4Bh,	8, 3, 1, 2, 4, 0Bh, 0Ah, 8, 5
		db 4Eh,	3, 3, 2, 12h
		db 4Fh,	1, 12h
		db 56h,	5, 11h,	3, 2, 10h, 5
		db 57h,	4, 6, 8, 0Dh, 1
		db 58h,	1, 1
		db 5Ah,	4, 3, 2, 4, 5
		db 5Bh,	5, 50h,	3, 2, 4, 5
		db 5Ch,	4, 6, 1, 24h, 21h
		db 65h,	2, 1, 2
		db 66h,	2, 1, 2
		db 68h,	1, 6
		db 67h,	3, 4, 8, 1
		db 6Ch,	0Ah, 3,	2, 0Ch,	4, 50h,	8, 1Ah,	0Dh, 1,	5
		db 69h,	4, 0Fh,	0Dh, 1,	5, 0FFh
DISPATCH	dw offset $ABORT	; ...
		dw offset $STD_CON_INPUT
		dw offset $STD_CON_OUTPUT
		dw offset $STD_AUX_INPUT
		dw offset $STD_AUX_OUTPUT
		dw offset $STD_PRINTER_OUTPUT
		dw offset $RAW_CON_IO
		dw offset $RAW_CON_INPUT
		dw offset $STD_CON_INPUT_NO_ECHO
		dw offset $STD_CON_STRING_OUTPUT
		dw offset $STD_CON_STRING_INPUT
		dw offset $STD_CON_INPUT_STATUS
		dw offset $STD_CON_INPUT_FLUSH
		dw offset $DISK_RESET
		dw offset $SET_DEFAULT_DRIVE
		dw offset $FCB_OPEN
		dw offset $FCB_CLOSE
		dw offset $DIR_SEARCH_FIRST
		dw offset $DIR_SEARCH_NEXT
		dw offset $FCB_DELETE
		dw offset $FCB_SEQ_READ
		dw offset $FCB_SEQ_WRITE
		dw offset $FCB_CREATE
		dw offset $FCB_RENAME
		dw offset NO_OP
		dw offset $GET_DEFAULT_DRIVE
		dw offset $SET_DMA
		dw offset $SLEAZEFUNC
		dw offset $SLEAZEFUNCDL
		dw offset NO_OP
		dw offset NO_OP
		dw offset $GET_DEFAULT_DPB
		dw offset NO_OP
		dw offset $FCB_RANDOM_READ
		dw offset $FCB_RANDOM_WRITE
		dw offset $GET_FCB_FILE_LENGTH
		dw offset $GET_FCB_POSITION
		dw offset $SET_INTERRUPT_VECTOR
		dw offset $CREATE_PROCESS_DATA_BLOCK
		dw offset $FCB_RANDOM_READ_BLOCK
		dw offset $FCB_RANDOM_WRITE_BLOCK
		dw offset $PARSE_FILE_DESCRIPTOR
		dw offset $GET_DATE
		dw offset $SET_DATE
		dw offset $GET_TIME
		dw offset $SET_TIME
		dw offset $SET_VERIFY_ON_WRITE
		dw offset $GET_DMA
		dw offset $GET_VERSION
		dw offset $KEEP_PROCESS
		dw offset $GET_DPB
		dw offset $SET_CTRL_C_TRAPPING
		dw offset $GET_INDOS_FLAG
		dw offset $GET_INTERRUPT_VECTOR
		dw offset $GET_DRIVE_FREESPACE
		dw offset $CHAR_OPER
		dw offset $INTERNATIONAL
		dw offset $MKDIR
		dw offset $RMDIR
		dw offset $CHDIR
		dw offset $CREAT
		dw offset $OPEN
		dw offset $CLOSE
		dw offset $READ
		dw offset $WRITE
		dw offset $UNLINK
		dw offset $LSEEK
		dw offset $CHMOD
		dw offset $IOCTL
		dw offset $DUP
		dw offset $DUP2
		dw offset $CURRENT_DIR
		dw offset $ALLOC
		dw offset $DEALLOC
		dw offset $SETBLOCK
		dw offset $EXEC
		dw offset $EXIT
		dw offset $WAIT
		dw offset $FIND_FIRST
		dw offset $FIND_NEXT
		dw offset $SET_CURRENT_PDB
		dw offset $GET_CURRENT_PDB
		dw offset $GET_IN_VARS
		dw offset $SETDPB
		dw offset $GET_VERIFY_ON_WRITE
		dw offset $DUP_PDB
		dw offset $RENAME
		dw offset $FILE_TIMES
		dw offset $ALLOCOPER
		dw offset $GetExtendedError
		dw offset $CreateTempFile
		dw offset $CreateNewFile
		dw offset $LockOper
		dw offset $ServerCall
		dw offset $UserOper
		dw offset $AssignOper
		dw offset $NameTrans
		dw offset NO_OP
		dw offset $GET_CURRENT_PDB
		dw offset $ECS_Call
		dw offset $SET_PRINTER_FLAG
		dw offset $GetExtCntry
		dw offset $GetSetCdPg
		dw offset $ExtHandle
		dw offset $COMMIT
		dw offset $GSetMediaID
		dw offset $COMMIT
		dw offset NO_OP
		dw offset $Extended_Open
FOO		dw offset Leave2F	; ...
Dtab		dw offset DOSTable	; ...
DOSTable	db 48			; ...
		dw offset DOSInstall
		dw offset DOS_CLOSE
		dw offset RECSET
		dw offset DOSGetGroup
		dw offset PATHCHRCMP
		dw offset OUTT
		dw offset NET_I24_ENTRY
		dw offset PLACEBUF
		dw offset FREE_SFT
		dw offset BUFWRITE
		dw offset SHARE_VIOLATION
		dw offset SHARE_ERROR
		dw offset SET_SFT_MODE
		dw offset DATE16
		dw offset Idle
		dw offset SCANPLACE
		dw offset Idle
		dw offset StrCpy
		dw offset StrLen
		dw offset UCase
		dw offset POINTCOMP
		dw offset CHECKFLUSH
		dw offset SFFromSFN
		dw offset GetCDSFromDrv
		dw offset Get_User_Stack
		dw offset GETTHISDRV
		dw offset DriveFromText
		dw offset SETYEAR
		dw offset DSUM
		dw offset DSLIDE
		dw offset StrCmp
		dw offset InitCDS
		dw offset pJFNFromHandle
		dw offset $NameTrans
		dw offset CAL_LK
		dw offset DEVNAME
		dw offset Idle
		dw offset DStrLen
		dw offset NLS_OPEN
		dw offset $CLOSE
		dw offset NLS_LSEEK
		dw offset $READ
		dw offset FastInit
		dw offset NLS_IOCTL
		dw offset GetDevList
		dw offset NLS_GETEXT
		dw offset MSG_RETRIEVAL
		dw offset NO_OP
ms_copyright	db 'MS DOS Version 5.00 (C)Copyright 1981-1991 Microsoft Corp License'
		db 'd Material - Property of Microsoft All rights reserved '
; ---------------------------------------------------------------------------

$SET_CTRL_C_TRAPPING:			; ...
		cmp	al, 6
		jbe	short scct_1
		mov	al, 0FFh
		iret
; ---------------------------------------------------------------------------

scct_1:					; ...
		push	ds
		mov	ds, cs:DosDSeg
		push	ax
		push	si
		mov	si, offset CNTCFLAG
		xor	ah, ah
		or	ax, ax
		jnz	short scct_2
		mov	dl, [si]
		jmp	short scct_6	; scct_9s
; ---------------------------------------------------------------------------

scct_2:					; ...
		dec	ax
		jnz	short scct_3
		and	dl, 1
		mov	[si], dl
		jmp	short scct_6	; scct_9s
; ---------------------------------------------------------------------------

scct_3:					; ...
		dec	ax
		jnz	short scct_4
		and	dl, 1
		xchg	dl, [si]
		jmp	short scct_6	; scct_9s
; ---------------------------------------------------------------------------

scct_4:					; ...
		cmp	ax, 3
		jnz	short scct_5
		mov	dl, ds:BOOTDRIVE
		jmp	short scct_6	; scct_9s
; ---------------------------------------------------------------------------

scct_5:					; ...
		cmp	ax, 4
		jnz	short scct_6	; scct_9s
		mov	bx, 5		; (MINOR_VERSION<<8)+MAJOR_VERSION
		mov	dl, 0		; DOSREVNM
		xor	dh, dh
		cmp	ds:DosHasHMA, 0
		jz	short scct_6
		or	dh, 10h		; DOSINHMA

scct_6:					; ...
		pop	si		; scct_9s
		pop	ax
		pop	ds
		iret
; ---------------------------------------------------------------------------

SetCtrlShortEntry:			; ...
		jmp	short $SET_CTRL_C_TRAPPING
; ---------------------------------------------------------------------------

$SET_CURRENT_PDB:			; ...
		push	ds
		mov	ds, cs:DosDSeg
		mov	ds:CurrentPDB, bx
		pop	ds
		iret
; ---------------------------------------------------------------------------

$GET_CURRENT_PDB:			; ...
		push	ds
		mov	ds, cs:DosDSeg
		mov	bx, ds:CurrentPDB
		pop	ds
		iret
; ---------------------------------------------------------------------------

$SET_PRINTER_FLAG:			; ...
		push	ds
		mov	ds, cs:DosDSeg
		mov	ds:PRINTER_FLAG, al
		pop	ds
		iret
; ---------------------------------------------------------------------------

QUIT:					; ...
		xor	ah, ah
		jmp	short SAVREGS
; ---------------------------------------------------------------------------

BADCALL:				; ...
		xor	al, al

IRETT:					; ...
		iret
; ---------------------------------------------------------------------------

CALL_ENTRY:				; ...
		push	ds
		mov	ds, cs:DosDSeg
		pop	ds:SAVEDS
		pop	ax
		pop	ax
		pop	ds:USER_SP
		pushf
		cli
		push	ax
		push	ds:USER_SP
		push	ds:SAVEDS
		pop	ds
		cmp	cl, 36		; MAXCALL
		ja	short BADCALL
		mov	ah, cl
		jmp	short SAVREGS
; ---------------------------------------------------------------------------

COMMAND:				; ...
		cli
		cmp	ah, 6Ch
		ja	short BADCALL

SAVREGS:				; ...
		cmp	ah, 33h
		jb	short loc_410E
		jz	short SetCtrlShortEntry
		cmp	ah, 64h
		ja	short loc_410E
		jz	short $SET_PRINTER_FLAG
		cmp	ah, 51h
		jz	short $GET_CURRENT_PDB
		cmp	ah, 62h
		jz	short $GET_CURRENT_PDB
		cmp	ah, 50h
		jz	short $SET_CURRENT_PDB

loc_410E:				; ...
		push	es
		push	ds
		push	bp
		push	di
		push	si
		push	dx
		push	cx
		push	bx
		push	ax
		mov	ax, ds
		mov	ds, cs:DosDSeg
		mov	ds:SAVEDS, ax
		mov	ds:SAVEBX, bx
		mov	ax, ds:USER_SP
		mov	ds:NSP,	ax
		mov	ax, ds:USER_SS
		mov	ds:NSS,	ax
		xor	ax, ax
		mov	ds:FSHARING, al
		test	ds:IsWin386, 1
		jnz	short loc_4140
		mov	ds:USER_ID, ax

loc_4140:				; ...
		inc	ds:INDOS
		mov	ds:USER_SP, sp
		mov	ds:USER_SS, ss
		mov	ax, ds:CurrentPDB
		mov	ds:PROC_ID, ax
		mov	ds, ax
		pop	ax
		push	ax
		mov	ds:2Eh,	sp	; [PDB.USER_STACK]
		mov	word ptr ds:30h, ss ; [PDB.USER_STACK+2]
		mov	ss, cs:DosDSeg

REDISP:					; ...
		mov	sp, offset AUXSTACK
		sti
		mov	bx, ss
		mov	ds, bx
		xchg	ax, bx
		xor	ax, ax
		mov	ss:EXTOPEN_ON, al
		and	ss:DOS34_FLAG, 800h
		mov	ss:CONSWAP, al
		mov	ss:NoSetDir, al
		mov	ss:FAILERR, al
		inc	ax
		mov	ss:IDLEINT, al	; 1
		xchg	ax, bx
		mov	bl, ah
		shl	bx, 1
		cld
		or	ah, ah
		jz	short DSKROUT
		cmp	ah, 59h		; GETEXTENDEDERROR
		jz	short DISPCALL
		cmp	ah, 12		; STD_CON_INPUT_FLUSH
		ja	short DSKROUT

IOROUT:
		cmp	ss:ERRORMODE, 0
		jnz	short DISPCALL
		mov	sp, offset PRINTER_FLAG	; IOSTACK
		jmp	short DISPCALL
; ---------------------------------------------------------------------------

DSKROUT:				; ...
		mov	ss:USER_IN_AX, ax
		mov	ss:EXTERR_LOCUS, 1
		mov	ss:ERRORMODE, 0
		mov	ss:WPERR, 0FFh
		push	ax
		mov	ah, 82h
		int	2Ah		; Microsoft Networks - END DOS CRITICAL	SECTIONS 0 THROUGH 7
		pop	ax
		mov	ss:IDLEINT, 0
		mov	sp, offset DSKSTACK
		test	ss:CNTCFLAG, 0FFh ; -1
		jz	short DISPCALL
		push	ax
		call	DSKSTATCHK
		pop	ax

DISPCALL:				; ...
		mov	bx, cs:DISPATCH[bx] ; [CS:BX+DISPATCH]
		xchg	bx, ss:SAVEBX
		mov	ds, ss:SAVEDS
		call	ss:SAVEBX
		and	ss:DOS_FLAG, 0FBh

LeaveDOS:				; ...
		cli
		mov	ds, cs:DosDSeg
		cmp	ds:A20OFF_COUNT, 0
		jnz	short disa20

LeaveA20On:				; ...
		dec	ds:INDOS
		mov	ss, ds:USER_SS
		mov	sp, ds:USER_SP
		mov	bp, sp
		mov	[bp+0],	al
		mov	ax, ds:NSP
		mov	ds:USER_SP, ax
		mov	ax, ds:NSS
		mov	ds:USER_SS, ax
		pop	ax
		pop	bx
		pop	cx
		pop	dx
		pop	si
		pop	di
		pop	bp
		pop	ds
		pop	es
		iret
; ---------------------------------------------------------------------------

disa20:					; ...
		mov	bx, ds:A20OFF_PSP
		cmp	bx, ds:CurrentPDB
		jnz	short LeaveA20On
		dec	ds:A20OFF_COUNT
		push	ds
		mov	bx, offset disa20_iret
		push	bx
		retf
; ---------------------------------------------------------------------------

restore_world:				; ...
		mov	es, cs:DosDSeg
		pop	es:RESTORE_TMP
		pop	ax
		pop	bx
		pop	cx
		pop	dx
		pop	si
		pop	di
		pop	bp
		pop	ds
		jmp	es:RESTORE_TMP
; ---------------------------------------------------------------------------

save_world:				; ...
		mov	es, cs:DosDSeg
		pop	es:RESTORE_TMP
		push	ds
		push	bp
		push	di
		push	si
		push	dx
		push	cx
		push	bx
		push	ax
		push	es:RESTORE_TMP
		push	bp
		mov	bp, sp
		mov	es, word ptr [bp+20]
		pop	bp
		retn

; =============== S U B	R O U T	I N E =======================================


Get_User_Stack	proc near		; ...
		mov	ds, cs:DosDSeg
		lds	si, dword ptr ds:USER_SP
		retn
Get_User_Stack	endp

; ---------------------------------------------------------------------------
ERRIN		db 2			; ...
		db 6
		db 12
		db 4
		db 8
		db 0
ERROUT		db 80h
		db 40h
		db 2
		db 10h
		db 4
		db 3

; =============== S U B	R O U T	I N E =======================================


AbsSetup	proc near		; ...
		inc	ss:INDOS
		sti
		cld
		push	ds
		push	ss
		pop	ds
		call	GETBP
		jb	short errdriv
		mov	word ptr es:[bp+1Fh], -1 ; [ES:BP+DPB.FREE_CNT]

errdriv:				; ...
		pop	ds
		jnb	short AbsSetup2

AbsSetup_retn:				; ...
		retn
; ---------------------------------------------------------------------------

AbsSetup2:				; ...
		mov	ss:HIGH_SECTOR,	0
		call	RW32_CONVERT
		jb	short AbsSetup_retn
		call	SET_RQ_SC_PARMS
		push	ds
		push	si
		push	ax
		push	ss
		pop	ds
		mov	si, offset OPENBUF
		mov	[si], al
		add	byte ptr [si], 'A' ; 41h
		mov	word ptr [si+1], ':' ; 3Ah
		mov	ax, 300h
		clc
		int	2Ah		; Microsoft Networks - CHECK DIRECT I/O
					; DS:SI	-> ASCIZ disk device name (may be full path or only drive
					; specifier--must include the colon)
					; Return: CF clear if absolute disk access allowed
		pop	ax
		pop	si
		pop	ds
		jnb	short AbsSetup_retn
		mov	ss:EXTERR, 32h
		retn
AbsSetup	endp

; ---------------------------------------------------------------------------

ABSDRD:					; ...
		cli
		push	ax
		mov	ax, ds
		mov	ds, cs:DosDSeg
		mov	ds:TEMPSEG, ax
		pop	ax
		push	es
		mov	ds:AbsRdWr_SS, ss
		mov	ds:AbsRdWr_SP, sp
		mov	ss, cs:DosDSeg
		mov	sp, offset DSKSTACK
		mov	ds, ds:TEMPSEG
		push	es
		call	save_world
		push	es
		call	AbsSetup
		jb	short ILEAVE
		call	ECritDisk
		mov	ss:CurSC_DRIVE,	0FFh ; -1
		call	LCritDisk
		call	DSKREAD
		jnz	short ERR_LEAVE
		mov	cx, di
		mov	ss:TEMP_VAR2, ds
		mov	ss:TEMP_VAR, bx
		call	DskRdBufScan
		jmp	short ILEAVE
; ---------------------------------------------------------------------------

TLEAVE:					; ...
		jz	short ILEAVE

ERR_LEAVE:				; ...
		push	es
		push	cs
		pop	es
		xor	ah, ah
		mov	cx, 6		; NUMERR
		mov	di, offset ERRIN
		repne scasb
		jnz	short LEAVECODE
		mov	ah, es:[di+5]

LEAVECODE:				; ...
		pop	es
		mov	ss:AbsDskErr, ax
		stc

ILEAVE:					; ...
		pop	es
		call	restore_world
		pop	es
		cli
		mov	ax, ss:AbsDskErr
		dec	ss:INDOS
		push	ss
		pop	es
		mov	ss, es:AbsRdWr_SS
		mov	sp, es:AbsRdWr_SP
		pop	es
		sti
		retf
; ---------------------------------------------------------------------------

ABSDWRT:				; ...
		cli
		push	ax
		mov	ax, ds
		mov	ds, cs:DosDSeg
		mov	ds:TEMPSEG, ax
		pop	ax
		push	es
		mov	ds:AbsRdWr_SS, ss
		mov	ds:AbsRdWr_SP, sp
		mov	ss, cs:DosDSeg
		mov	sp, offset DSKSTACK
		mov	ds, ds:TEMPSEG
		push	es
		call	save_world
		push	es
		call	AbsSetup
		jb	short ILEAVE
		call	ECritDisk
		mov	ss:CurSC_DRIVE,	0FFh ; -1
		call	Fastxxx_Purge
		call	LCritDisk
		push	ds
		call	DskWrtBufPurge
		pop	ds
		call	DSKWRITE
		jmp	short TLEAVE

; =============== S U B	R O U T	I N E =======================================


GETBP		proc near		; ...
		push	ax
		add	al, 1
		jb	short SKIPGET
		call	GETTHISDRV
		jnb	short SKIPGET
		xor	ah, ah
		cmp	ax, 1Ah		; error_not_DOS_disk
		jz	short SKIPGET
		stc
		mov	ds:EXTERR, ax
		mov	ds:AbsDskErr, 201h

SKIPGET:				; ...
		pop	ax
		jnb	short getbp_t
		retn
; ---------------------------------------------------------------------------

getbp_t:				; ...
		les	bp, ds:THISCDS
		test	word ptr es:[bp+43h], 8000h ; [ES:BP+curdir.flags],
					; curdir_isnet
		jz	short GETBP_CDS
		mov	ds:EXTERR, 32h ; '2' ; error_not_supported
		stc

GETBP_RETN:
		retn
; ---------------------------------------------------------------------------

GETBP_CDS:				; ...
		les	bp, es:[bp+45h]	; [ES:BP+curdir.devptr]

GOTDPB:					; ...
		mov	word ptr ds:THISDPB, bp
		mov	word ptr ds:THISDPB+2, es
		retn
GETBP		endp

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR $CLOSE

SYS_RETURN:				; ...
		call	Get_User_Stack	; SYS_RETURN_OK
		and	word ptr [si+16h], 0FFFEh ; [SI+user_env.user_F],
					; ~f_Carry
		jmp	short DO_RET
; ---------------------------------------------------------------------------

SYS_RET_ERR:				; ...
		xor	ah, ah
		call	ETAB_LK
		call	ErrorMap

From_GetSet:				; ...
		call	Get_User_Stack
		or	word ptr [si+16h], 1 ; [SI+user_env.user_F],
					; f_Carry
		stc

DO_RET:					; ...
		mov	[si], ax
		retn
; END OF FUNCTION CHUNK	FOR $CLOSE
; ---------------------------------------------------------------------------

NO_OP:					; ...
		xor	al, al
		retn

; =============== S U B	R O U T	I N E =======================================


FCB_RET_ER	proc near		; ...
		xor	ah, ah
		mov	ss:EXTERR, ax
		call	ErrorMap
		mov	al, 0FFh	; -1
		retn
FCB_RET_ER	endp


; =============== S U B	R O U T	I N E =======================================


ErrorMap	proc near		; ...
		push	si
		mov	si, offset ERR_TABLE_21
		cmp	ss:FAILERR, 0
		jz	short EXTENDED_NORMAL
		mov	ss:EXTERR, 53h	; error_FAIL_I24

EXTENDED_NORMAL:			; ...
		call	CAL_LK
		pop	si
		retn
ErrorMap	endp


; =============== S U B	R O U T	I N E =======================================


CAL_LK		proc near		; ...
		push	ds
		push	ax
		push	bx
		mov	ds, cs:DosDSeg
		mov	bx, ds:EXTERR

TABLK1:					; ...
		lodsb
		cmp	al, 0FFh
		jz	short GOT_VALS
		cmp	al, bl
		jz	short GOT_VALS
		add	si, 3
		jmp	short TABLK1
; ---------------------------------------------------------------------------

GOT_VALS:				; ...
		lodsw
		cmp	ah, 0FFh
		jz	short NO_SET_ACT
		mov	ds:EXTERR_ACTION, ah

NO_SET_ACT:				; ...
		cmp	al, 0FFh
		jz	short NO_SET_CLS
		mov	ds:EXTERR_CLASS, al

NO_SET_CLS:				; ...
		lodsb
		cmp	al, 0FFh
		jz	short NO_SET_LOC
		mov	ds:EXTERR_LOCUS, al

NO_SET_LOC:				; ...
		pop	bx
		pop	ax
		pop	ds
		retn
CAL_LK		endp


; =============== S U B	R O U T	I N E =======================================


ETAB_LK		proc near		; ...
		push	ds
		push	si
		push	cx
		push	bx
		push	ss
		pop	ds
		mov	ds:EXTERR, ax
		mov	si, offset I21_MAP_E_TAB
		mov	bh, al
		mov	bl, byte ptr ds:USER_IN_AX+1

TABLK2:					; ...
		lods	word ptr cs:[si] ; cs lodsw
		cmp	al, 0FFh
		jz	short NOT_IN_TABLE
		cmp	al, bl
		jz	short GOT_CALL
		xchg	ah, al
		xor	ah, ah
		add	si, ax
		jmp	short TABLK2
; ---------------------------------------------------------------------------

NOT_IN_TABLE:				; ...
		mov	al, bh
		jmp	short NO_MAP
; ---------------------------------------------------------------------------

GOT_CALL:				; ...
		mov	cl, ah
		xor	ch, ch

CHECK_CODE:				; ...
		lods	byte ptr cs:[si] ; cs lodsb
		cmp	al, bh
		jz	short NO_MAP
		loop	CHECK_CODE

NO_MAP:					; ...
		xor	ah, ah
		pop	bx
		pop	cx
		pop	si
		pop	ds
		retn
ETAB_LK		endp


; =============== S U B	R O U T	I N E =======================================


SetBad		proc near		; ...
		mov	ax, 1		; error_invalid_function
		push	ds
		mov	ds, cs:DosDSeg
		mov	ds:EXTERR_LOCUS, 1 ; errLOC_Unk
		pop	ds
		stc
		retn
SetBad		endp


; =============== S U B	R O U T	I N E =======================================


BadCall		proc far		; ...
		call	SetBad
		retf
BadCall		endp

; ---------------------------------------------------------------------------

OKCall:
		clc
		retf
; ---------------------------------------------------------------------------

INT2F:					; ...
		sti
		cmp	ah, 11h		; MultNET
		jnz	short INT2FSHR

TestInstall:				; ...
		or	al, al
		jz	short Leave2F

BadFunc:				; ...
		call	SetBad

Leave2F:				; ...
		retf	2
; ---------------------------------------------------------------------------

INT2FSHR:				; ...
		cmp	ah, 10h		; MultSHARE
		jz	short TestInstall
		cmp	ah, 14h		; NLSFUNC
		jz	short TestInstall
		cmp	ah, 12h		; MultDOS
		jnz	short check_win
		jmp	DispatchDOS
; ---------------------------------------------------------------------------

check_win:				; ...
		cmp	ah, 16h		; MultWin386
		jz	short Win386_Msg
		cmp	ah, 46h		; WINOLDAP
		jnz	short next_i2f
		jmp	winold_swap
; ---------------------------------------------------------------------------

next_i2f:				; ...
		jmp	far ptr	70h:5
; ---------------------------------------------------------------------------

Win386_Msg:				; ...
		push	ds
		mov	ds, cs:DosDSeg
		cmp	al, 3
		jnz	short Win386_Msg_exit
		jmp	OldWin386Init
; ---------------------------------------------------------------------------

Win386_Msg_exit:			; ...
		cmp	al, 6
		jnz	short Win386_Msg_devcall
		jmp	Win386_Leaving
; ---------------------------------------------------------------------------

Win386_Msg_devcall:			; ...
		cmp	al, 7
		jnz	short Win386_Msg_init
		jmp	Win386_Query
; ---------------------------------------------------------------------------

Win386_Msg_init:			; ...
		cmp	al, 5
		jz	short Win386_Starting
		jmp	win_nexti2f
; ---------------------------------------------------------------------------

Win386_Starting:			; ...
		test	dx, 1
		jz	short Win386_vchk
		jmp	win_nexti2f
; ---------------------------------------------------------------------------

Win386_vchk:				; ...
		mov	word ptr ds:Win386_Info+6, 0 ; [Win386_Info+Win386_SIS.Virt_Dev_File_Ptr]
		mov	word ptr ds:Win386_Info+8, 0 ; [Win386_Info+Win386_SIS.Virt_Dev_File_Ptr+2]
		cmp	di, 30Ah	; version 3.10
		jb	short Win386_vxd
		jmp	noVxD31
; ---------------------------------------------------------------------------

Win386_vxd:				; ...
		push	ax
		push	bx
		push	cx
		push	dx
		push	si
		push	di
		mov	bx, ds:UMB_HEAD
		cmp	bx, 0FFFFh
		jz	short Vxd31
		mov	ds:UmbSaveFlag,	1
		push	ds
		push	es
		mov	ax, ds
		mov	es, ax
		mov	ds, bx
		xor	si, si
		cld
		mov	di, offset UmbSave1
		mov	cx, 11
		rep movsb
		mov	di, offset UmbSave2
		mov	cx, 5
		rep movsb
		pop	es
		pop	ds

Vxd31:					; ...
		test	ds:DOS_FLAG, 2
		jz	short Dont_Supress
		pop	di
		pop	si
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		jmp	short noVxD31
; ---------------------------------------------------------------------------

Dont_Supress:				; ...
		mov	al, ds:BOOTDRIVE
		add	al, 40h	; '@'   ; 'A' - 1
		mov	byte ptr ds:VxDpath, al	; "c:\\wina20.386"
		mov	ah, 6Ch		; ExtOpen
		mov	al, 0
		mov	bx, 2080h
		mov	cx, 7
		mov	dx, 1
		mov	si, offset VxDpath ; "c:\\wina20.386"
		mov	di, 0FFFFh
		int	21h		; DOS -	4.0 - EXTENDED OPEN/CREATE
					; BL = open mode as in AL for normal open (INT 21h/AH=3Dh)
					; BH = flags, CX = create attribute, DL	= action if file exists/does not exists
					; DH = 00h (reserved), DS:SI ->	ASCIZ file name
		pop	di
		pop	si
		pop	dx
		pop	cx
		jnb	short VxDthere
		push	dx
		push	ds
		push	si
		mov	si, offset NoVxDErrMsg ; "You must have	the file WINA20.386 in th"...
		push	cs
		pop	ds
		mov	cx, 99
		mov	ah, 2
		cld

vxdlp:					; ...
		lodsb
		xchg	dl, al
		int	21h		; DOS -	DISPLAY	OUTPUT
					; DL = character to send to standard output
		loop	vxdlp
		pop	si
		pop	ds
		pop	dx
		pop	bx
		pop	ax
		inc	cx
		jmp	win_nexti2f
; ---------------------------------------------------------------------------

VxDthere:				; ...
		mov	bx, ax
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		mov	bx, offset Win386_Info
		mov	word ptr [bx+6], offset	VxDpath	; [Win386_Info+Win386_SIS.Virt_Dev_File_Ptr],
					; VxDpath
		mov	word ptr [bx+8], ds ; [Win386_Info+Win386_SIS.Virt_Dev_File_Ptr+2]
		pop	bx
		pop	ax

noVxD31:				; ...
		or	ds:IsWin386, 1
		or	ds:redir_patch,	1
		push	dx
		mov	dx, bx
		mov	bx, offset Win386_Info
		mov	[bx+2],	dx
		mov	word ptr [bx+4], es
		pop	dx
		push	ds
		pop	es
		jmp	win_nexti2f
; ---------------------------------------------------------------------------

Win386_Leaving:				; ...
		test	dx, 1
		jz	short Win386_Leaving_c
		jmp	win_nexti2f
; ---------------------------------------------------------------------------

Win386_Leaving_c:			; ...
		cmp	ds:UmbSaveFlag,	1
		jnz	short noumb
		mov	ds:UmbSaveFlag,	0
		push	ax
		push	es
		push	cx
		push	si
		push	di
		mov	ax, ds:UMB_HEAD
		mov	es, ax
		xor	di, di
		cld
		mov	si, offset UmbSave1
		mov	cx, 11
		rep movsb
		mov	si, offset UmbSave2
		mov	cx, 5
		rep movsb
		pop	di
		pop	si
		pop	cx
		pop	es
		pop	ax

noumb:					; ...
		and	ds:IsWin386, 0
		and	ds:redir_patch,	0
		jmp	short win_nexti2f
; ---------------------------------------------------------------------------

Win386_Query:				; ...
		cmp	bx, 15h		; Win386_DOSMGR
		jnz	short win_nexti2f
		or	cx, cx
		jnz	short dosmgr_func
		inc	cx
		mov	bx, offset Win386_DOSVars
		push	ds
		pop	es
		jmp	short PopIret
; ---------------------------------------------------------------------------

OldWin386Init:				; ...
		pop	ax
		mov	si, offset OldInstanceJunk
		mov	ax, 5248h	; 'HR'
		jmp	next_i2f
; ---------------------------------------------------------------------------

dosmgr_func:				; ...
		dec	cx
		jz	short win386_patch
		dec	cx
		jz	short PopIret
		dec	cx
		jz	short win386_size
		dec	cx
		jz	short win386_inst
		dec	cx
		jnz	short PopIret
		mov	ax, es
		dec	ax
		push	es
		mov	es, ax
		cmp	byte ptr es:[di], 'D'
		jnz	short cantsize
		inc	ax
		cmp	es:[di+1], ax
		jnz	short cantsize
		mov	ax, es:[di+3]
		pop	es
		mov	bx, 16
		mul	bx
		mov	cx, ax
		mov	bx, dx
		jmp	short win386_done
; ---------------------------------------------------------------------------

cantsize:				; ...
		pop	es
		xor	ax, ax
		xor	dx, dx
		jmp	short PopIret
; ---------------------------------------------------------------------------

win386_patch:				; ...
		mov	bx, dx
		jmp	short win386_done
; ---------------------------------------------------------------------------

win386_size:				; ...
		test	dx, 1
		jz	short PopIret
		mov	cx, 88		; curdirLen
		jmp	short win386_done
; ---------------------------------------------------------------------------

win386_inst:				; ...
		xor	dx, dx
		jmp	short PopIret
; ---------------------------------------------------------------------------

win386_done:				; ...
		mov	ax, 0B97Ch	; WIN_OP_DONE
		mov	dx, 0A2ABh	; DOSMGR_OP_DONE

PopIret:				; ...
		pop	ds
		iret
; ---------------------------------------------------------------------------

win_nexti2f:				; ...
		pop	ds
		jmp	next_i2f
; ---------------------------------------------------------------------------

getwinlast:				; ...
		mov	si, ds:CurrentPDB
		dec	si
		mov	es, si
		add	si, es:3
		retn
; ---------------------------------------------------------------------------

winold_swap:				; ...
		push	ds
		push	es
		push	si
		push	di
		push	cx
		mov	ds, cs:DosDSeg
		cmp	al, 1
		jnz	short swapin
		call	getwinlast
		push	ds
		pop	es
		mov	ds, si
		xor	si, si
		mov	di, offset WinoldPatch1
		mov	cx, 8
		cld
		push	cx
		rep movsb
		pop	cx
		mov	di, offset WinoldPatch2
		rep movsb
		jmp	short winold_done
; ---------------------------------------------------------------------------

swapin:					; ...
		cmp	al, 2
		jnz	short winold_done
		call	getwinlast
		mov	es, si
		xor	di, di
		mov	si, 6
		mov	cx, 8
		cld
		push	cx
		rep movsb
		pop	cx
		mov	si, offset WinoldPatch2
		rep movsb

winold_done:				; ...
		pop	cx
		pop	di
		pop	si
		pop	es
		pop	ds
		jmp	next_i2f
; ---------------------------------------------------------------------------

DispatchDOS:				; ...
		push	cs:FOO
		push	cs:Dtab
		push	ax
		push	bp
		mov	bp, sp
		mov	ax, [bp+0Eh]
		pop	bp
		call	TableDispatch
		jmp	BadFunc
; ---------------------------------------------------------------------------

DOSGetGroup:				; ...
		mov	ds, cs:DosDSeg
		retn
; ---------------------------------------------------------------------------

DOSInstall:				; ...
		mov	al, 0FFh
		retn

; =============== S U B	R O U T	I N E =======================================


RW32_CONVERT	proc near		; ...
		cmp	cx, 0FFFFh
		jz	short new32format
		push	ax
		push	dx
		mov	ax, es:[bp+0Dh]	; [ES:BP+DPB.MAX_CLUSTER]
		mov	dl, es:[bp+4]	; [ES:BP+DPB.CLUSTER_MASK]
		cmp	dl, 0FEh	; Sectors/cluster - 1
		jz	short letold
		inc	dl
		xor	dh, dh
		mul	dx
		or	dx, dx

letold:					; ...
		pop	dx
		pop	ax
		jz	short old_style
		push	ds
		mov	ds, cs:DosDSeg
		mov	ds:AbsDskErr, 207h
		pop	ds
		stc
		retn
; ---------------------------------------------------------------------------

new32format:				; ...
		mov	dx, [bx+2]	; [BX+ABS_32RW.SECTOR_RBA+2]
		push	ds
		mov	ds, cs:DosDSeg
		mov	ds:HIGH_SECTOR,	dx
		pop	ds
		mov	dx, [bx]	; [BX+ABS_32RW.SECTOR_RBA]
		mov	cx, [bx+4]	; [BX+ABS_32RW.ABS_RW_COUNT]
		lds	bx, [bx+6]	; [BX+ABS_32RW.BUFFER_ADDR]

old_style:				; ...
		clc
		retn
RW32_CONVERT	endp


; =============== S U B	R O U T	I N E =======================================


Fastxxx_Purge	proc near		; ...
		push	ax
		push	si
		push	dx
		push	ds
		mov	ds, cs:DosDSeg
		test	ds:FastOpenFlg,	80h ; Fast_yes
		pop	ds
		jz	short nofast
		mov	ah, 1		; FastOpen_ID
		mov	al, 5		; FONC_purge
		mov	dl, es:[bp+0]
		call	Fast_Dispatch

nofast:					; ...
		pop	dx
		pop	si
		pop	ax
		retn
Fastxxx_Purge	endp

; ---------------------------------------------------------------------------
DIVMES		db 0Dh,0Ah		; ...
		db 'Divide overflow',0Dh,0Ah
DivMesLen	dw 19			; ...
NoVxDErrMsg	db 'You must have the file WINA20.386 in the root of your boot drive',0Dh ; ...
		db 0Ah
		db 'to run Windows in Enhanced Mode',0Dh,0Ah
NLS_YES		db 'Y'                  ; ...
NLS_NO		db 'N'                  ; ...
NLS_yes2	db 'y'                  ; ...
NLS_no2		db 'n'                  ; ...
CANCHAR		db 1Bh			; ...
ESCCHAR		db 0			; ...
ESCTAB		db 64			; ...
		db 77
		db 59
		db 83
		db 60
		db 62
		db 61
		db 61
		db 63
		db 75
		db 82
		db 82
		db 65
		db 65
ESCFUNC		dw offset GETCH		; ...
		dw offset TWOESC
		dw offset EXITINS
		dw offset EXITINS	; ENTERINS
		dw offset BACKSP
		dw offset REEDIT
		dw offset KILNEW
		dw offset COPYLIN
		dw offset SKIPSTR
		dw offset COPYSTR
		dw offset SKIPONE
		dw offset COPYONE
		dw offset COPYONE
		dw offset CTRLZ
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR $STD_CON_STRING_INPUT

OEMFunctionKey:				; ...
		call	$STD_CON_INPUT_NO_ECHO
		mov	cl, 14		; ESCTABLEN
		push	di
		mov	di, offset ESCTAB
		push	es
		push	cs
		pop	es
		repne scasb
		pop	es
		pop	di
		shl	cx, 1
		mov	bp, cx
		jmp	cs:ESCFUNC[bp]	; [CS:BP+ESCFUNC]
; END OF FUNCTION CHUNK	FOR $STD_CON_STRING_INPUT
; ---------------------------------------------------------------------------

$GET_DATE:				; ...
		push	ss
		pop	ds
		call	READTIME
		mov	ax, ds:YEAR
		mov	bx, word ptr ds:DAY
		call	Get_User_Stack
		mov	[si+6],	bx	; [SI+user_env.user_DX]
		add	ax, 1980
		mov	[si+4],	ax	; [SI+user_env.user_CX]
		mov	al, ss:WEEKDAY

RET20:					; ...
		retn
; ---------------------------------------------------------------------------

$SET_DATE:				; ...
		mov	al, -1		; 0FFh
		sub	cx, 1980
		jb	short RET20
		cmp	cx, 119
		ja	short RET24
		or	dh, dh
		jz	short RET20
		or	dl, dl
		jz	short RET20
		cmp	dh, 0Ch
		ja	short RET24
		push	ss
		pop	ds
		call	DODATE

RET24:					; ...
		retn
; ---------------------------------------------------------------------------

$GET_TIME:				; ...
		push	ss
		pop	ds
		call	READTIME
		call	Get_User_Stack
		mov	[si+6],	dx	; [SI+user_env.user_DX]
		mov	[si+4],	cx	; [SI+user_env.user_CX]
		xor	al, al

RET26:					; ...
		retn
; ---------------------------------------------------------------------------

$SET_TIME:				; ...
		mov	al, -1
		cmp	ch, 24
		jnb	short RET26
		cmp	cl, 60
		jnb	short RET26
		cmp	dh, 60
		jnb	short RET26
		cmp	dl, 100
		jnb	short RET26
		push	cx
		push	dx
		push	ss
		pop	ds
		mov	bx, offset TIMEBUF
		mov	cx, 6
		xor	dx, dx
		mov	ax, dx
		push	bx
		call	SETREAD
		push	ds
		lds	si, ds:BCLOCK
		call	DEVIOCALL2
		pop	ds
		pop	bx
		call	SETWRITE
		pop	ds:TIMEBUF+4
		pop	ds:TIMEBUF+2
		lds	si, ds:BCLOCK
		call	DEVIOCALL2
		xor	al, al
		retn

; =============== S U B	R O U T	I N E =======================================


DATE16		proc near		; ...
		mov	ds, cs:DosDSeg
		push	cx
		push	es
		call	READTIME
		pop	es
		shl	cl, 1
		shl	cl, 1
		shl	cx, 1
		shl	cx, 1
		shl	cx, 1
		shr	dh, 1
		or	cl, dh
		mov	dx, cx
		mov	ax, word ptr ds:MONTH
		mov	cl, 4
		shl	al, cl
		shl	ax, 1
		pop	cx
		or	al, ds:DAY

RET21:					; ...
		retn
DATE16		endp


; =============== S U B	R O U T	I N E =======================================


READTIME	proc near		; ...
		mov	ds:DATE_FLAG, 0
		push	si
		push	bx
		mov	bx, offset TIMEBUF
		mov	cx, 6
		xor	dx, dx
		mov	ax, dx
		call	SETREAD
		push	ds
		lds	si, ds:BCLOCK
		call	DEVIOCALL2
		pop	ds
		pop	bx
		pop	si
		mov	ax, ds:TIMEBUF
		mov	cx, ds:TIMEBUF+2
		mov	dx, ds:TIMEBUF+4
		cmp	ax, ds:DAYCNT
		jz	short RET21
		cmp	ax, 43830	; FOURYEARS*30
		jnb	short RET22
		mov	ds:DAYCNT, ax
		push	si
		push	cx
		push	dx
		xor	dx, dx
		mov	cx, 1461	; FOURYEARS
		div	cx
		shl	ax, 1
		shl	ax, 1
		shl	ax, 1
		mov	cx, ax
		mov	si, offset YRTAB
		call	DSLIDE
		shr	cx, 1
		jnb	short SK
		add	dx, 200

SK:					; ...
		call	SETYEAR
		mov	cl, 1
		mov	si, offset MONTAB
		call	DSLIDE
		mov	ds:MONTH, cl
		inc	dx
		mov	ds:DAY,	dl
		call	WKDAY
		pop	dx
		pop	cx
		pop	si

RET22:					; ...
		retn
READTIME	endp


; =============== S U B	R O U T	I N E =======================================


DSLIDE		proc near		; ...
		mov	ah, 0

DSLIDE1:				; ...
		lodsb
		cmp	dx, ax
		jb	short RET22
		sub	dx, ax
		inc	cx
		jmp	short DSLIDE1
DSLIDE		endp


; =============== S U B	R O U T	I N E =======================================


SETYEAR		proc near		; ...
		mov	ds, cs:DosDSeg
		mov	byte ptr ds:YEAR, cl

CHKYR:					; ...
		test	cl, 3
		mov	al, 28
		jnz	short SAVFEB
		inc	al

SAVFEB:					; ...
		mov	ds:february, al	; [MONTAB+1]

RET23:					; ...
		retn
SETYEAR		endp


; =============== S U B	R O U T	I N E =======================================


DODATE		proc near		; ...
		call	CHKYR
		mov	al, dh
		mov	bx, (offset YRTAB+7) ; offset MONTAB-1
		xlat
		cmp	al, dl
		mov	al, -1
		jb	short RET23
		call	SETYEAR
		mov	word ptr ds:DAY, dx
		shr	cx, 1
		shr	cx, 1
		mov	ax, 1461	; FOURYEARS
		mov	bx, dx
		mul	cx
		mov	cl, byte ptr ds:YEAR
		and	cl, 3
		mov	si, offset YRTAB
		mov	dx, ax
		shl	cx, 1
		call	DSUM
		mov	cl, bh
		mov	si, offset MONTAB
		dec	cx
		call	DSUM
		mov	cl, bl
		dec	cx
		add	dx, cx
		xchg	ax, dx
		mov	ds:DAYCNT, ax
		push	si
		push	bx
		push	ax
		mov	bx, offset TIMEBUF
		mov	cx, 6
		xor	dx, dx
		mov	ax, dx
		push	bx
		call	SETREAD
		push	ds
		lds	si, ds:BCLOCK
		call	DEVIOCALL2
		pop	ds
		pop	bx
		call	SETWRITE
		pop	ds:TIMEBUF
		push	ds
		lds	si, ds:BCLOCK
		call	DEVIOCALL2
		pop	ds
		pop	bx
		pop	si

WKDAY:					; ...
		mov	ax, ds:DAYCNT
		xor	dx, dx
		mov	cx, 7
		inc	ax
		inc	ax
		div	cx
		mov	ds:WEEKDAY, dl
		xor	al, al
		retn
DODATE		endp


; =============== S U B	R O U T	I N E =======================================


DSUM		proc near		; ...
		mov	ah, 0
		jcxz	short DUSUM9

DSUM1:					; ...
		lodsb
		add	dx, ax
		loop	DSUM1

DUSUM9:					; ...
		retn
DSUM		endp

; ---------------------------------------------------------------------------

$GET_VERSION:				; ...
		push	ss
		pop	ds
		mov	bx, word ptr ds:USERNUM+2
		mov	cx, word ptr ds:USERNUM
		cmp	al, 1
		jnz	short Norm_Vers
		xor	bh, bh

Norm_Vers:				; ...
		push	ds
		mov	ds, ds:CurrentPDB
		mov	ax, ds:40h	; [PDB.Version]
		pop	ds
		call	Get_User_Stack
		mov	[si], ax	; [SI+user_env.user_AX]
		mov	[si+2],	bx	; [SI+user_env.user_BX]
		mov	[si+4],	cx	; [SI+user_env.user_CX]
		retn
; ---------------------------------------------------------------------------

$GET_VERIFY_ON_WRITE:			; ...
		mov	al, ss:VERFLG
		retn
; ---------------------------------------------------------------------------

$SET_VERIFY_ON_WRITE:			; ...
		and	al, 1
		mov	ss:VERFLG, al

RET27:					; ...
		retn
; ---------------------------------------------------------------------------

$INTERNATIONAL:				; ...
		cmp	al, 0FFh
		jz	short BX_HAS_CODE
		mov	bl, al
		xor	bh, bh

BX_HAS_CODE:				; ...
		push	ds
		pop	es
		push	dx
		pop	di
		push	ss
		pop	ds
		cmp	di, 0FFFFh	; -1
		jz	short international_set
		or	bx, bx
		jnz	short international_find
		mov	si, offset COUNTRY_CDPG
		jmp	short international_copy
; ---------------------------------------------------------------------------

international_find:			; ...
		mov	bp, 0
		call	international_get
		jb	short errtn
		cmp	bx, 0
		jnz	short international_copy
		mov	bx, dx
		jmp	short international_ok3

; =============== S U B	R O U T	I N E =======================================


international_get proc near		; ...
		mov	si, offset COUNTRY_CDPG
		cmp	bx, ss:[si+68h]	; [SI+DOS_CCDPG.ccDosCountry]
		jz	short RET27
		mov	dx, bx
		xor	bx, bx
		mov	ax, 1400h
		int	2Fh		; - Multiplex -	NLSFUNC.COM - INSTALLATION CHECK
					; Return: AL = 00h not installed, OK to	install
					; 01h not installed, not OK
					; FFh installed
		cmp	al, 0FFh
		jnz	short interr
		or	bp, bp
		jnz	short stcdpg
		mov	ax, 1404h
		int	2Fh		; - Multiplex -	NLSFUNC.COM - GET COUNTRY INFO
					; BX = code page, DX = country code, DS:SI -> internal code page structure
					; ES:DI	-> user	buffer
					; Return: AL = status
		jmp	short chkok
; ---------------------------------------------------------------------------

stcdpg:					; ...
		mov	ax, 1403h
		int	2Fh		; - Multiplex -	NLSFUNC.COM - SET COUNTRY INFO
					; DS:SI	-> internal code page structure
					; BX = code page, DX = country code
					; Return: AL = status

chkok:					; ...
		or	al, al
		jz	short RET27

setcarry:				; ...
		stc
		retn
; ---------------------------------------------------------------------------

interr:					; ...
		mov	al, 0FFh
		jmp	short setcarry
international_get endp

; ---------------------------------------------------------------------------

international_copy:			; ...
		mov	bx, ss:[si+68h]	; [ss:SI+DOS_CCDPG.ccDosCountry]
		mov	si, offset COUNTRY_CDPG_108 ; COUNTRY_CDPG + 108
		mov	cx, 24		; OLD_COUNTRY_SIZE
		push	ds
		push	ss
		pop	ds
		rep movsb
		pop	ds

international_ok3:			; ...
		call	Get_User_Stack
		mov	[si+2],	bx	; [SI+user_env.user_BX]

international_ok:			; ...
		mov	ax, bx

SYS_RET_OK_jmp:				; ...
		jmp	SYS_RETURN	; SYS_RET_OK
; ---------------------------------------------------------------------------

international_set:			; ...
		mov	bp, 1
		call	international_get
		jnb	short international_ok

errtn:					; ...
		cmp	al, 0FFh
		jz	short errtn2

errtn1:					; ...
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

errtn2:					; ...
		mov	al, 1		; error_invalid_function
		jmp	short errtn1
; ---------------------------------------------------------------------------

$GetExtCntry:				; ...
		cmp	al, 20h		; CAP_ONE_CHAR
		jb	short notcap
		test	al, 80h		; UPPER_TABLE
		jnz	short fileupper
		mov	bx, offset UCASE_TAB_2 ; UCASE_TAB+2
		jmp	short capit
; ---------------------------------------------------------------------------

fileupper:				; ...
		mov	bx, offset FILE_UCASE_TAB_2 ; FILE_UCASE_TAB+2

capit:					; ...
		cmp	al, 20h		; CAP_ONE_CHAR
		jnz	short chkyes
		mov	al, dl
		call	GETLET3
		call	Get_User_Stack
		mov	[si+6],	al	; [SI+user_env.user_DX]
		jmp	short nono
; ---------------------------------------------------------------------------

chkyes:					; ...
		cmp	al, 23h		; CHECK_YES_NO
		jnz	short capstring
		xor	ax, ax
		cmp	dl, cs:NLS_YES	; 'Y'
		jz	short yesyes
		cmp	dl, cs:NLS_yes2	; 'y'
		jz	short yesyes
		cmp	dl, cs:NLS_NO	; 'n'
		jz	short nono
		cmp	dl, cs:NLS_no2
		jz	short nono
		inc	ax

yesyes:					; ...
		inc	ax

nono:					; ...
		jmp	short SYS_RET_OK_jmp
; ---------------------------------------------------------------------------

capstring:				; ...
		mov	si, dx
		cmp	al, 21h		; CAP_STRING
		jnz	short capascii
		or	cx, cx
		jz	short nono

concap:					; ...
		lodsb
		call	GETLET3
		mov	[si-1],	al
		loop	concap
		jmp	short nono
; ---------------------------------------------------------------------------

capascii:				; ...
		cmp	al, 22h		; CAP_ASCIIZ
		jnz	short capinval

concap2:				; ...
		lodsb
		or	al, al
		jz	short nono
		call	GETLET3
		mov	[si-1],	al
		jmp	short concap2
; ---------------------------------------------------------------------------

notcap:					; ...
		cmp	cx, 5
		jb	short sizeerror
		push	ss
		pop	ds
		mov	si, offset COUNTRY_CDPG
		cmp	dx, 0FFFFh	; -1
		jnz	short GETCDPG
		mov	dx, [si+68h]	; [SI+DOS_CCDPG.ccDosCountry]

GETCDPG:				; ...
		cmp	bx, 0FFFFh	; -1
		jnz	short CHKAGAIN
		mov	bx, [si+6Ah]	; [SI+DOS_CCDPG.ccDosCodePage]

CHKAGAIN:				; ...
		cmp	dx, [si+68h]	; [SI+DOS_CCDPG.ccDosCountry]
		jnz	short CHKNLS
		cmp	bx, [si+6Ah]	; [SI+DOS_CCDPG.ccDosCodePage]
		jnz	short CHKNLS
		mov	bx, [si+48h]	; [SI+DOS_CCDPG.ccSysCodePage]
		push	cx
		mov	cx, [si+4Ah]	; [SI+DOS_CCDPG.ccNumber_of_entries]
		mov	si, offset COUNTRY_CDPG_76 ; COUNTRY_CDPG+76
					; COUNTRY_CDPG+DOS_CCDPG.ccSetUcase

NXTENTRY:				; ...
		cmp	al, [si]
		jz	short FOUNDIT
		add	si, 5
		loop	NXTENTRY
		pop	cx

capinval:				; ...
		mov	al, 1

SYS_RET_ERR_jmp:			; ...
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

FOUNDIT:				; ...
		movsb
		pop	cx
		cmp	al, 1		; SetCountryInfo
		jz	short setsize
		mov	cx, 4
		mov	ax, 5

OK_RETN:				; ...
		rep movsb
		mov	cx, ax
		mov	ax, bx

GETDONE:				; ...
		call	Get_User_Stack
		mov	[si+4],	cx	; [SI+user_env.user_CX]

nono_jmp:				; ...
		jmp	short nono
; ---------------------------------------------------------------------------

setsize:				; ...
		sub	cx, 3
		cmp	[si], cx
		jnb	short setsize2
		mov	cx, [si]

setsize2:				; ...
		mov	es:[di], cx
		add	di, 2
		add	si, 2
		mov	ax, cx
		add	ax, 3
		jmp	short OK_RETN
; ---------------------------------------------------------------------------

CHKNLS:					; ...
		xor	ah, ah
		push	ax
		pop	bp
		mov	ax, 1400h
		int	2Fh		; - Multiplex -	NLSFUNC.COM - INSTALLATION CHECK
					; Return: AL = 00h not installed, OK to	install
					; 01h not installed, not OK
					; FFh installed
		cmp	al, 0FFh
		jz	short NLSNXT

sizeerror:				; ...
		mov	al, 1		; error_invalid_function

sys_ret_err_jmp2:			; ...
		jmp	short SYS_RET_ERR_jmp
; ---------------------------------------------------------------------------

NLSNXT:					; ...
		mov	ax, 1402h
		int	2Fh		; - Multiplex -	NLSFUNC.COM - GET COUNTRY INFO
					; BP = subfunction, BX = code page
					; DX = country code, DS:SI -> internal code page structure
					; ES:DI	-> user	buffer,	CX = size of user buffer
					; Return: AL = status
					; 00h successful
					; else DOS error code
		cmp	al, 0
		jnz	short NLSERROR
		mov	ax, [si+48h]	; [SI+DOS_CCDPG.ccSysCodePage]
		jmp	short GETDONE
; ---------------------------------------------------------------------------

NLSERROR:				; ...
		jmp	short sys_ret_err_jmp2
; ---------------------------------------------------------------------------

$GetSetCdPg:				; ...
		push	ss
		pop	ds
		mov	si, offset COUNTRY_CDPG
		cmp	al, 1
		jnz	short setglpg
		mov	bx, [si+6Ah]	; [SI+DOS_CCDPG.ccDosCodePage]
		mov	dx, [si+48h]	; [SI+DOS_CCDPG.ccSysCodePage]
		call	Get_User_Stack
		mov	[si+2],	bx
		mov	[si+6],	dx

OK_RETURN:				; ...
		jmp	short nono_jmp
; ---------------------------------------------------------------------------

setglpg:				; ...
		cmp	al, 2
		jnz	short nomem
		mov	dx, [si+68h]	; [SI+DOS_CCDPG.ccDosCountry]
		mov	ax, 1400h
		int	2Fh		; - Multiplex -	NLSFUNC.COM - INSTALLATION CHECK
					; Return: AL = 00h not installed, OK to	install
					; 01h not installed, not OK
					; FFh installed
		cmp	al, 0FFh
		jnz	short nomem
		mov	ax, 1401h
		int	2Fh		; - Multiplex -	NLSFUNC.COM - CHANGE CODE PAGE
					; DS:SI	-> internal code page structure
					; BX = new code	page, DX = country code???
					; Return: AL = status
					; 00h successful
					; else DOS error code
		or	al, al
		jz	short OK_RETURN
		cmp	al, 65
		jnz	short seterr
		mov	ax, 65
		mov	ds:EXTERR, ax
		mov	ds:EXTERR_ACTION, 6 ; errACT_Ignore
		mov	ds:EXTERR_CLASS, 5 ; errCLASS_HrdFail
		mov	ds:EXTERR_LOCUS, 4 ; errLOC_SerDev
		jmp	From_GetSet
; ---------------------------------------------------------------------------

seterr:					; ...
		jmp	short NLSERROR
; ---------------------------------------------------------------------------

nomem:					; ...
		mov	al, 1		; error_invalid_function
		jmp	short seterr
; ---------------------------------------------------------------------------

$GET_DRIVE_FREESPACE:			; ...
		push	ss
		pop	ds
		mov	al, dl
		call	GETTHISDRV

SET_AX_RET:				; ...
		jb	short BADFDRV
		call	DISK_INFO
		xchg	dx, bx
		jb	short SET_AX_RET
		xor	ah, ah

DoSt:					; ...
		call	Get_User_Stack
		mov	[si+6],	dx	; [SI+user_env.user_DX]
		mov	[si+4],	cx	; [SI+user_env.user_CX]
		mov	[si+2],	bx	; [SI+user_env.user_BX]
		mov	[si], ax	; [SI+user_env.user_AX]
		retn
; ---------------------------------------------------------------------------

BADFDRV:				; ...
		call	FCB_RET_ER
		mov	ax, 0FFFFh	; -1
		jmp	short DoSt
; ---------------------------------------------------------------------------

$GET_DMA:				; ...
		mov	bx, word ptr ss:DMAADD
		mov	cx, word ptr ss:DMAADD+2
		call	Get_User_Stack
		mov	[si+2],	bx	; [SI+user_env.user_BX]
		mov	[si+10h], cx	; [SI+user_env.user_ES]
		retn
; ---------------------------------------------------------------------------

$SET_DMA:				; ...
		mov	word ptr ss:DMAADD, dx
		mov	word ptr ss:DMAADD+2, ds
		retn
; ---------------------------------------------------------------------------

$GET_DEFAULT_DRIVE:			; ...
		mov	al, ss:CURDRV
		retn
; ---------------------------------------------------------------------------

$SET_DEFAULT_DRIVE:			; ...
		mov	al, dl
		inc	al
		call	GetVisDrv
		jb	short SETRET
		mov	ss:CURDRV, al

SETRET:					; ...
		mov	al, ss:CDSCOUNT
		retn

; =============== S U B	R O U T	I N E =======================================


$GET_INTERRUPT_VECTOR proc near		; ...
		call	RECSET
		les	bx, es:[bx]
		call	Get_User_Stack
		mov	[si+2],	bx	; [SI+user_env.user_BX]
		mov	word ptr [si+10h], es ;	[SI+user_env.user_ES]
		retn
$GET_INTERRUPT_VECTOR endp

; ---------------------------------------------------------------------------

$SET_INTERRUPT_VECTOR:			; ...
		call	RECSET
		cli
		mov	es:[bx], dx
		mov	word ptr es:[bx+2], ds
		sti
		test	ss:DOS_FLAG, 4	; EXECA20OFF
		jnz	short siv_1
		retn
; ---------------------------------------------------------------------------

siv_1:					; ...
		cmp	ss:A20OFF_COUNT, 0
		jnz	short siv_2
		mov	ss:A20OFF_COUNT, 1

siv_2:					; ...
		retn

; =============== S U B	R O U T	I N E =======================================


RECSET		proc near		; ...
		xor	bx, bx
		mov	es, bx
		mov	bl, al
		shl	bx, 1
		shl	bx, 1
		retn
RECSET		endp

; ---------------------------------------------------------------------------

$CHAR_OPER:				; ...
		or	al, al
		mov	dl, '/'
		jz	short chop_1
		cmp	al, 2
		mov	dl, 0FFh	; -1
		jz	short chop_1
		retn
; ---------------------------------------------------------------------------

chop_1:					; ...
		call	Get_User_Stack
		mov	[si+6],	dx	; [SI+user_env.user_DX]
		retn
; ---------------------------------------------------------------------------

$GetExtendedError:			; ...
		push	ss
		pop	ds
		mov	ax, ds:EXTERR
		les	di, ds:EXTERRPT
		mov	bx, word ptr ds:EXTERR_ACTION ;	BL = Action
					; BH = Class
		mov	ch, ds:EXTERR_LOCUS
		call	Get_User_Stack
		mov	[si+0Ah], di	; [SI+user_env.user_DI]
		mov	word ptr [si+10h], es ;	[SI+user_env.user_ES]
		mov	[si+2],	bx	; [SI+user_env.user_BX]
		mov	[si+4],	cx	; [SI+user_env.user_CX]

jmp_SYS_RET_OK:				; ...
		jmp	SYS_RETURN
; ---------------------------------------------------------------------------
		push	si
		mov	si, offset COUNTRY_CDPG
		mov	ax, ss:[si+6Ah]	; [SI+DOS_CCDPG.ccDosCodePage]
		pop	si
		retn
; ---------------------------------------------------------------------------

$ECS_Call:				; ...
		or	al, al
		jnz	short _okok
		call	Get_User_Stack
		mov	word ptr [si+8], (offset DBCS_TAB+2) ;
					; [si+user_env.user_SI]
		push	es
		mov	es, cs:DosDSeg
		mov	word ptr [si+0Eh], es ;	[SI+user_env.user_DS]
		pop	es

_okok:					; ...
		jmp	short jmp_SYS_RET_OK
; ---------------------------------------------------------------------------

$PARSE_FILE_DESCRIPTOR:			; ...
		call	MAKEFCB
		push	si
		call	Get_User_Stack
		pop	word ptr [si+8]	; [SI+user_env.user_SI]
		retn
; ---------------------------------------------------------------------------

$SLEAZEFUNC:				; ...
		mov	dl, 0

$SLEAZEFUNCDL:				; ...
		push	ss
		pop	ds
		mov	al, dl
		call	GETTHISDRV

SET_AL_RET:				; ...
		jb	short BADSLDRIVE
		call	DISK_INFO
		jb	short SET_AL_RET
		mov	ds:FATBYTE, ah
		mov	di, offset FATBYTE
		xor	ah, ah
		call	Get_User_Stack
		mov	[si+4],	cx	; [SI+user_env.user_CX]
		mov	[si+6],	bx	; [SI+user_env.user_DCX]
		mov	[si+2],	di	; [SI+user_env.user_BX]
		mov	word ptr [si+0Eh], ss ;	[SI+user_env.user_DS]
		retn
; ---------------------------------------------------------------------------

BADSLDRIVE:				; ...
		jmp	FCB_RET_ER
; ---------------------------------------------------------------------------

$GET_INDOS_FLAG:			; ...
		call	Get_User_Stack
		mov	word ptr [si+2], offset	INDOS ;	word [SI+user_env.user_BX]
		mov	word ptr [si+10h], ss ;	[SI+user_env.user_ES]
		retn
; ---------------------------------------------------------------------------

$GET_IN_VARS:				; ...
		call	Get_User_Stack
		mov	word ptr [si+2], offset	SYSINITVARS ;
					; [SI+user_env.user_BX]
		mov	word ptr [si+10h], ss ;	[SI+user_env.user_ES]
		retn
; ---------------------------------------------------------------------------

$GET_DEFAULT_DPB:			; ...
		mov	dl, 0

$GET_DPB:				; ...
		push	ss
		pop	ds
		mov	al, dl
		call	GETTHISDRV
		jb	short ISNODRV
		les	di, ds:THISCDS
		test	byte ptr es:[di+44h], 80h ; [ES:DI+curdir.flags+1],
					; (curdir_isnet>>8)
		jnz	short ISNODRV
		call	ECritDisk
		call	FATREAD_CDS
		call	LCritDisk
		jb	short ISNODRV
		call	Get_User_Stack
		mov	[si+2],	bp	; [SI+user_env.user_BX]
		mov	word ptr [si+0Eh], es ;	[SI+user_env.user_DS]
		xor	al, al
		retn
; ---------------------------------------------------------------------------

ISNODRV:				; ...
		mov	al, 0FFh	; -1
		retn
; ---------------------------------------------------------------------------

$DISK_RESET:				; ...
		mov	al, -1		; 0FFh
		push	ss
		pop	ds
		call	ECritDisk
		or	ds:DOS34_FLAG, 4 ; FROM_DISK_RESET
		call	FLUSHBUF
		and	ds:DOS34_FLAG, 0FFFBh ;	NO_FROM_DISK_RESET
		mov	ds:SC_STATUS, 0
		mov	bx, -1
		mov	word ptr ds:LastBuffer+2, bx
		mov	word ptr ds:LastBuffer,	bx
		call	LCritDisk
		mov	ax, -1		; 0FFFFh
		push	ax
		mov	ax, 1120h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - FLUSH ALL DISK BUFFERS
					; DS = DOS CS
					; Return: CF clear (successful)
		pop	ax
		retn
; ---------------------------------------------------------------------------
_word_3		dw 3			; ...
; ---------------------------------------------------------------------------

$SETDPB:				; ...
		mov	di, bp
		add	di, 2
		lodsw
		stosw
		cmp	byte ptr [si+3], 0 ; [SI+A_BPB.BPB_NUMBEROFFATS-2]
		jnz	short yesfat
		mov	byte ptr es:[di+4], 0 ;	[ES:DI+DPB.FAT_COUNT-4]
		jmp	short setend
; ---------------------------------------------------------------------------

yesfat:					; ...
		mov	dx, ax
		lodsb
		dec	al
		stosb
		inc	al
		xor	ah, ah

LOG2LOOP:				; ...
		test	al, 1
		jnz	short SAVLOG
		inc	ah
		shr	al, 1
		jmp	short LOG2LOOP
; ---------------------------------------------------------------------------

SAVLOG:					; ...
		mov	al, ah
		stosb
		mov	bl, al
		movsw
		lodsb
		stosb
		mov	bh, al
		lodsw
		stosw
		mov	cl, 5
		shr	dx, cl
		dec	ax
		add	ax, dx
		mov	cx, dx
		xor	dx, dx
		div	cx
		mov	cx, ax
		inc	di
		inc	di
		movsw
		lodsb
		mov	es:[bp+17h], al	; [ES:BP+DPB.MEDIA]
		lodsw
		stosw
		mov	dl, bh
		xor	dh, dh
		mul	dx
		add	ax, es:[bp+6]	; [ES:BP+DPB.FIRST_FAT]
		stosw
		add	ax, cx
		mov	es:[bp+0Bh], ax	; [ES:BP+DPB.FIRST_SECTOR]
		mov	cl, bl
		cmp	word ptr es:[bp+0Dh], 0
		jnz	short normal_dpb
		xor	ch, ch
		mov	bx, [si+8]	; [SI+A_BPB.BPB_BIGTOTALSECTORS-A_BPB.BPB_SECTORSPERTRACK]
		mov	dx, [si+0Ah]	; [SI+A_BPB.BPB_BIGTOTALSECTORS-A_BPB.BPB_SECTORSPERTRACK+2]
		sub	bx, ax
		sbb	dx, 0
		or	cx, cx
		jz	short norot

rott:					; ...
		clc
		rcr	dx, 1
		rcr	bx, 1
		loop	rott

norot:					; ...
		mov	ax, bx
		jmp	short setend
; ---------------------------------------------------------------------------

normal_dpb:				; ...
		sub	ax, es:[bp+0Dh]
		neg	ax
		shr	ax, cl

setend:					; ...
		inc	ax
		mov	bx, ax
		mov	ax, es:[bp+0Fh]	; [ES:BP+DPB.FAT_SIZE]
		mul	word ptr es:[bp+2] ; [ES:BP+DPB.SECTOR_SIZE]
		cmp	bx, 0FF6h	; 4096-10
		jb	short setend_fat12
		shr	dx, 1
		rcr	ax, 1
		cmp	ax, 0FF7h	; 4096-10+1
		jb	short setend_faterr
		jmp	short setend_fat16
; ---------------------------------------------------------------------------

setend_fat12:				; ...
		add	ax, ax
		adc	dx, dx
		div	cs:_word_3

setend_fat16:				; ...
		dec	ax
		cmp	ax, bx
		jbe	short setend_fat

setend_faterr:				; ...
		mov	ax, bx

setend_fat:				; ...
		mov	es:[bp+0Dh], ax	; [ES:BP+DPB.MAX_CLUSTER]
		mov	word ptr es:[bp+1Dh], 0	; [ES:BP+DPB.NEXT_FREE]
		mov	word ptr es:[bp+1Fh], -1 ; [ES:BP+DPB.FREE_CNT]
		retn

; =============== S U B	R O U T	I N E =======================================


$DUP_PDB	proc near		; ...
		mov	ds, cs:DosDSeg
		mov	ds:CreatePDB, 0FFh
		mov	ds, ds:CurrentPDB
		push	si
		jmp	short CreateCopy
; ---------------------------------------------------------------------------

$CREATE_PROCESS_DATA_BLOCK:		; ...
		call	Get_User_Stack
		mov	ds, word ptr [si+14h] ;	[SI+user_env.user_CS]
		push	word ptr ds:2	; [PDB.BLOCK_LEN]

CreateCopy:				; ...
		mov	es, dx
		xor	si, si
		mov	di, si
		mov	cx, 128
		rep movsw
		mov	cx, 20		; FILPERPROC
		mov	di, 18h		; PDB.JFN_TABLE
		push	ds
		lds	si, ds:34h	; [PDB.JFN_Pointer]
		rep movsb
		pop	ds
		mov	ds, cs:DosDSeg
		cmp	ds:CreatePDB, 0
		jz	short Create_PDB_cont
		mov	ds, cs:DosDSeg
		xor	bx, bx
		mov	cx, 20

Create_dup_jfn:				; ...
		push	es
		call	SFFromHandle
		mov	al, -1		; 0FFh
		jb	short CreateStash
		test	byte ptr es:[di+6], 10h	; [ES:DI+SF_ENTRY.sf_flags+1],
					; (sf_no_inherit>>8)
		jnz	short CreateStash
		mov	ah, es:[di+2]	; [ES:DI+SF_ENTRY.sf_mode]
		and	ah, 0F0h	; SHARING_MASK
		cmp	ah, 70h		; SHARING_NET_FCB
		jz	short CreateStash
		mov	word ptr ds:THISSFT, di
		mov	word ptr ds:THISSFT+2, es
		call	DOS_DUP
		call	pJFNFromHandle
		mov	al, es:[di]

CreateStash:				; ...
		pop	es
		mov	es:[bx+18h], al	; [ES:BX+PDB.JFN_TABLE]
		inc	bx
		loop	Create_dup_jfn
		mov	bx, ds:CurrentPDB
		mov	es:16h,	bx	; [ES:PDB.PARENT_PID]
		mov	ds:CurrentPDB, es
		mov	ds, bx

Create_PDB_cont:			; ...
		push	ds
		mov	ds, cs:DosDSeg
		mov	ds:CreatePDB, 0
		pop	ds
		pop	ax

SETMEM:					; ...
		xor	cx, cx
		mov	ds, cx
		mov	es, dx
		mov	si, 88h		; addr_int_terminate
		mov	di, 0Ah		; SAVEXIT
		mov	cx, 6
		rep movsw
		mov	es:2, ax
		sub	ax, dx
		cmp	ax, 0FFFh	; MAXDIF
		jbe	short HAVDIF
		mov	ax, 0FFFh

HAVDIF:					; ...
		sub	ax, 10h
		mov	bx, 0Ch		; ENTRYPOINTSEG
		sub	bx, ax
		mov	cl, 4
		shl	ax, cl
		mov	ds, dx
		mov	ds:6, ax	; [PDB.CPM_CALL+1]
		mov	ds:8, bx	; [PDB.CPM_CALL+3]
		cmp	ax, 0FEF0h	; WRAPOFFSET
		jz	short addr_ok
		mov	word ptr ds:6, 0C0h
		mov	word ptr ds:8, 0

addr_ok:				; ...
		mov	word ptr ds:0, 20CDh ; [PDB.EXIT_CALL],
					; (int_abort*256) + mi_INT
		mov	byte ptr ds:5, 9Ah ; [PDB.CPM_CALL],mi_Long_CALL
		mov	word ptr ds:50h, 21CDh ; [PDB.CALL_SYSTEM],
					; (int_command*256) + mi_INT
		mov	byte ptr ds:52h, 0CBh ;	[PDB.CALL_SYSTEM+2],mi_Long_RET
		mov	word ptr ds:34h, 18h ; [PDB.JFN_Pointer],PDB.JFN_TABLE
		mov	word ptr ds:36h, ds ; [PDB.JFN_Pointer+2]
		mov	word ptr ds:32h, 20 ; [PDB.JFN_Length],FILPERPROC
		mov	word ptr ds:38h, 0FFFFh	; [PDB.Next_PDB],-1
		mov	word ptr ds:3Ah, 0FFFFh	; [PDB.Next_PDB+2],-1
		mov	word ptr es:40h, 5 ; [ES:PDB.Version],
					; (MINOR_VERSION*256)+MAJOR_VERSION
		retn
$DUP_PDB	endp

; ---------------------------------------------------------------------------

$GSetMediaID:				; ...
		mov	cx, 866h	; RAWIO	- GET_MEDIA_ID
		cmp	al, 0		; get ?
		jz	short doioctl	; yes
		cmp	al, 1		; set ?
		jnz	short errorfunc	; no, error
		mov	cx, 846h	; RAWIO	- SET_MEDIA_ID

doioctl:				; ...
		mov	al, 0Dh		; generic IOCTL
		call	$IOCTL
		retn
; ---------------------------------------------------------------------------

errorfunc:				; ...
		mov	al, 1		; error_invalid_function
		jmp	SYS_RET_ERR

; =============== S U B	R O U T	I N E =======================================


StrCmp		proc near		; ...
		push	si
		push	di
		push	ax

Cmplp:					; ...
		lodsb
		call	UCase
		call	PATHCHRCMP
		mov	ah, al
		mov	al, es:[di]
		inc	di
		call	UCase
		call	PATHCHRCMP
		cmp	ah, al
		jnz	short PopRet
		or	al, al
		jnz	short Cmplp

PopRet:					; ...
		pop	ax
		pop	di
		pop	si
		retn
StrCmp		endp


; =============== S U B	R O U T	I N E =======================================


StrCpy		proc near		; ...
		push	ax

CPYLoop:				; ...
		lodsb
		call	UCase
		call	PATHCHRCMP
		stosb
		or	al, al
		jnz	short CPYLoop
		pop	ax
		retn
StrCpy		endp


; =============== S U B	R O U T	I N E =======================================


FStrCpy		proc near		; ...
		push	ax

FCPYLoop:				; ...
		lodsb
		stosb
		or	al, al
		jnz	short FCPYLoop
		pop	ax
		retn
FStrCpy		endp


; =============== S U B	R O U T	I N E =======================================


StrLen		proc near		; ...
		push	di
		push	ax
		mov	cx, 65535
		xor	al, al
		repne scasb
		not	cx
		pop	ax
		pop	di
		retn
StrLen		endp


; =============== S U B	R O U T	I N E =======================================


DStrLen		proc near		; ...
		call	XCHGP
		call	StrLen
		call	XCHGP
		retn
DStrLen		endp


; =============== S U B	R O U T	I N E =======================================


XCHGP		proc near		; ...
		push	ds
		push	es
		pop	ds
		pop	es
		xchg	si, di

xchgp_retn:				; ...
		retn
XCHGP		endp


; =============== S U B	R O U T	I N E =======================================


Idle		proc near		; ...
		cmp	ss:FSHARING, 0
		jnz	short xchgp_retn
		push	cx
		mov	cx, ss:RetryLoop
		jcxz	short Idle3

Idle1:					; ...
		push	cx
		xor	cx, cx

Idle2:					; ...
		loop	Idle2
		pop	cx
		loop	Idle1

Idle3:					; ...
		pop	cx
		retn
Idle		endp

; ---------------------------------------------------------------------------

TableDispatch:				; ...
		push	bp
		mov	bp, sp
		push	bx
		mov	bx, [bp+6]	; [BP+TFrame.Tab]
		mov	bl, cs:[bx]
		cmp	[bp+4],	bl	; [BP+TFrame.Index]
		jnb	short TableError
		mov	bl, [bp+4]	; [BP+TFrame.Index]
		xor	bh, bh
		shl	bx, 1
		inc	bx
		add	bx, [bp+6]	; [BP+TFrame.Tab]
		mov	bx, cs:[bx]
		mov	[bp+6],	bx	; [BP+TFrame.Tab]
		pop	bx
		pop	bp
		add	sp, 4
		retn
; ---------------------------------------------------------------------------

TableError:				; ...
		pop	bx
		pop	bp
		retn	6

; =============== S U B	R O U T	I N E =======================================


TestNet		proc near		; ...
		mov	es, cs:DosDSeg
		les	di, es:THISCDS
		cmp	di, -1
		jz	short CMCRet
		test	byte ptr es:[di+44h], 80h ; [ES:DI+curdir.flags+1],
					; (curdir_isnet>>8)
		jnz	short CMCRet
		retn
; ---------------------------------------------------------------------------

CMCRet:					; ...
		cmc
		retn
TestNet		endp


; =============== S U B	R O U T	I N E =======================================


IsSFTNet	proc near		; ...
		test	byte ptr es:[di+6], 80h	; [ES:DI+SF_ENTRY.sf_flags+1],
					; (sf_isnet>>8)
		retn
IsSFTNet	endp

; ---------------------------------------------------------------------------

FastInit:				; ...
		push	es
		mov	es, cs:DosDSeg
		mov	di, offset FastOpenTable_2 ; FastTable+2
		dec	bx
		mov	dx, bx
		shl	bx, 1
		shl	bx, 1
		add	di, bx
		mov	ax, es:[di+2]
		mov	cx, cs
		cmp	ax, cx
		jz	short ok_install
		or	ax, ax
		jz	short ok_install
		stc
		jmp	short FSret
; ---------------------------------------------------------------------------

ok_install:				; ...
		cmp	si, -1
		jz	short FSret
		mov	cx, ds
		mov	es:[di+2], cx
		mov	es:[di], si
		mov	di, offset FastOpenFlg ; FastFlg
		add	di, dx
		or	byte ptr es:[di], 80h ;	Fast_yes

FSret:					; ...
		pop	es
		retn
; ---------------------------------------------------------------------------

FastRet:				; ...
		stc
		sbb	ax, ax
		retf
; ---------------------------------------------------------------------------

NLS_OPEN:				; ...
		mov	al, cl
		call	$OPEN
		retn
; ---------------------------------------------------------------------------

NLS_LSEEK:				; ...
		push	ss:USER_SP
		push	ss:USER_SS
		call	Fake_User_Stack
		mov	ax, bp
		call	$LSEEK
		pop	ss:USER_SS
		pop	ss:USER_SP
		retn

; =============== S U B	R O U T	I N E =======================================


Fake_User_Stack	proc near		; ...
		mov	ax, ss:USER_SP_2F
		mov	ss:USER_SP, ax
		mov	ax, ss
		mov	ss:USER_SS, ax
		retn
Fake_User_Stack	endp

; ---------------------------------------------------------------------------

GetDevList:				; ...
		mov	si, offset SysInitTable
		mov	ds, cs:DosDSeg
		lds	si, [si]
		mov	ax, [si+22h]	; [SI+SYSI.DEV]
		mov	bx, [si+24h]	; [SI+SYSI.DEV+2]
		retn
; ---------------------------------------------------------------------------

NLS_IOCTL:				; ...
		push	ss:USER_SP
		push	ss:USER_SS
		call	Fake_User_Stack
		mov	ax, bp
		call	$IOCTL
		pop	ss:USER_SS
		pop	ss:USER_SP
		retn
; ---------------------------------------------------------------------------

NLS_GETEXT:				; ...
		mov	ax, ss:EXTERR
		retn
; ---------------------------------------------------------------------------

MSG_RETRIEVAL:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================


ECritDisk	proc near		; ...
		pushf			; ECritMEM
					; ECritSFT
		cmp	ss:redir_patch,	0
		jz	short ECritDisk_2
		jmp	short ECritDisk_1
; ---------------------------------------------------------------------------

ECritDisk_iret:				; ...
		iret
; ---------------------------------------------------------------------------

ECritDisk_1:				; ...
		push	cs
		call	ECritDisk_iret

ECritDisk_0:
		push	ax
		mov	ax, 8001h
		int	2Ah		; Microsoft Networks - BEGIN DOS CRITICAL SECTION
					; AL = critical	section	number (00h-0Fh)
		pop	ax
		retn
; ---------------------------------------------------------------------------

ECritDisk_2:				; ...
		jmp	short ECritDisk_3
; ---------------------------------------------------------------------------

ECritDisk_iret2:			; ...
		iret
; ---------------------------------------------------------------------------

ECritDisk_3:				; ...
		push	cs
		call	ECritDisk_iret2
		retn
ECritDisk	endp


; =============== S U B	R O U T	I N E =======================================


LCritDisk	proc near		; ...
		pushf			; LCritMEM
					; LCritSFT
		cmp	ss:redir_patch,	0
		jz	short LCritDisk_2
		jmp	short LCritDisk_1
; ---------------------------------------------------------------------------

LCritDisk_iret:				; ...
		iret
; ---------------------------------------------------------------------------

LCritDisk_1:				; ...
		push	cs
		call	LCritDisk_iret
		push	ax
		mov	ax, 8101h
		int	2Ah		; Microsoft Networks - END DOS CRITICAL	SECTION
					; AL = critical	section	number (00h-0Fh)
		pop	ax
		retn
; ---------------------------------------------------------------------------

LCritDisk_2:				; ...
		jmp	short LCritDisk_3
; ---------------------------------------------------------------------------

LCritDisk_iret2:			; ...
		iret
; ---------------------------------------------------------------------------

LCritDisk_3:				; ...
		push	cs
		call	LCritDisk_iret2
		retn
LCritDisk	endp


; =============== S U B	R O U T	I N E =======================================


ECritDevice	proc near		; ...
		pushf
		cmp	ss:redir_patch,	0
		jz	short ECritDevice_2
		jmp	short ECritDevice_1
; ---------------------------------------------------------------------------

ECritDevice_iret:			; ...
		iret
; ---------------------------------------------------------------------------

ECritDevice_1:				; ...
		push	cs
		call	ECritDevice_iret
		push	ax
		mov	ax, 8002h
		int	2Ah		; Microsoft Networks - BEGIN DOS CRITICAL SECTION
					; AL = critical	section	number (00h-0Fh)
		pop	ax
		retn
; ---------------------------------------------------------------------------

ECritDevice_2:				; ...
		jmp	short ECritDevice_3
; ---------------------------------------------------------------------------

ECritDevice_iret2:			; ...
		iret
; ---------------------------------------------------------------------------

ECritDevice_3:				; ...
		push	cs
		call	ECritDevice_iret2
		retn
ECritDevice	endp


; =============== S U B	R O U T	I N E =======================================


LCritDevice	proc near		; ...
		pushf			; LCritMEM
					; LCritSFT
		cmp	ss:redir_patch,	0
		jz	short LCritDevice_2
		jmp	short LCritDevice_1
; ---------------------------------------------------------------------------

LCritDevice_iret:			; ...
		iret
; ---------------------------------------------------------------------------

LCritDevice_1:				; ...
		push	cs
		call	LCritDevice_iret
		push	ax
		mov	ax, 8102h
		int	2Ah		; Microsoft Networks - END DOS CRITICAL	SECTION
					; AL = critical	section	number (00h-0Fh)
		pop	ax
		retn
; ---------------------------------------------------------------------------

LCritDevice_2:				; ...
		jmp	short LCritDevice_3
; ---------------------------------------------------------------------------

LCritDevice_iret2:			; ...
		iret
; ---------------------------------------------------------------------------

LCritDevice_3:				; ...
		push	cs
		call	LCritDevice_iret2
		retn
LCritDevice	endp


; =============== S U B	R O U T	I N E =======================================


$STD_CON_INPUT_NO_ECHO proc near	; ...
		push	ds
		push	si

INTEST:					; ...
		call	STATCHK
		jnz	short GET
		cmp	ss:PRINTER_FLAG, 0
		jnz	short no_sys_wait
		mov	ah, 5
		call	IOFUNC

no_sys_wait:				; ...
		mov	ah, 84h
		int	2Ah		; Microsoft Networks - KEYBOARD	BUSY LOOP
		cmp	byte ptr ss:DATE_FLAG, 0FFh ; -1
		jnz	short NoUpdate
		push	ax
		push	bx
		push	cx
		push	dx
		push	ds
		push	ss
		pop	ds
		mov	ax, 0
		call	Save_Restore_Packet
		call	READTIME
		mov	ax, 1
		call	Save_Restore_Packet
		pop	ds
		pop	dx
		pop	cx
		pop	bx
		pop	ax

NoUpdate:				; ...
		inc	ss:DATE_FLAG
		jmp	short INTEST
; ---------------------------------------------------------------------------

GET:					; ...
		xor	ah, ah
		call	IOFUNC
		pop	si
		pop	ds
		mov	ss:SCAN_FLAG, 0
		cmp	al, 0
		jnz	short noscan
		mov	ss:SCAN_FLAG, 1

noscan:					; ...
		retn
$STD_CON_INPUT_NO_ECHO endp

; ---------------------------------------------------------------------------

$STD_CON_STRING_OUTPUT:			; ...
		mov	si, dx

STRING_OUT1:				; ...
		lodsb
		cmp	al, '$'
		jz	short noscan
		call	OUTT
		jmp	short STRING_OUT1

; =============== S U B	R O U T	I N E =======================================


$STD_CON_STRING_INPUT proc near		; ...

; FUNCTION CHUNK AT 4813 SIZE 00000019 BYTES

		mov	ax, ss
		mov	es, ax
		mov	si, dx
		xor	ch, ch
		lodsw
		or	al, al
		jz	short noscan
		mov	bl, ah
		mov	bh, ch
		cmp	al, bl
		jbe	short NOEDIT
		cmp	byte ptr [bx+si], 0Dh ;	c_CR
		jz	short EDITON

NOEDIT:					; ...
		mov	bl, ch

EDITON:					; ...
		mov	dl, al
		dec	dx

NEWLIN:					; ...
		mov	al, ss:CARPOS
		mov	ss:STARTPOS, al
		push	si
		mov	di, offset INBUF
		mov	ss:INSMODE, ch
		mov	bh, ch
		mov	dh, ch
		call	$STD_CON_INPUT_NO_ECHO
		cmp	al, 0Ah		; c_LF
		jnz	short GOTCH

GETCH:					; ...
		call	$STD_CON_INPUT_NO_ECHO

GOTCH:					; ...
		cmp	al, 6		; "F"-"@"
		jz	short GETCH
		cmp	al, cs:ESCCHAR
		jz	short ESCAPE
		cmp	al, 7Fh		; c_DEL
		jz	short BACKSPJ
		cmp	al, 8		; c_BS
		jz	short BACKSPJ
		cmp	al, 17h		; W"-"@"
		nop
		nop
		cmp	al, 15h		; "U"-"@"
		nop
		nop
		cmp	al, 0Dh		; c_CR
		jz	short ENDLIN
		cmp	al, 0Ah		; c_LF
		jz	short PHYCRLF
		cmp	al, cs:CANCHAR	; 1Bh
		jz	short KILNEW

SAVCH:					; ...
		cmp	dh, dl
		jnb	short BUFFUL
		stosb
		inc	dh
		call	BUFOUT
		cmp	ss:INSMODE, 0
		jnz	short GETCH
		cmp	bh, bl
		jnb	short GETCH
		inc	si
		inc	bh
		jmp	short GETCH
; ---------------------------------------------------------------------------

BACKSPJ:				; ...
		jmp	short BACKSP
; ---------------------------------------------------------------------------

BUFFUL:					; ...
		mov	al, 7
		call	OUTT
		jmp	short GETCH
; ---------------------------------------------------------------------------

ESCAPE:					; ...
		jmp	OEMFunctionKey
; ---------------------------------------------------------------------------

ENDLIN:					; ...
		stosb
		call	OUTT
		pop	di
		mov	[di-1],	dh
		inc	dh

COPYNEW:				; ...
		push	ds
		push	es
		pop	ds
		pop	es
		mov	si, offset INBUF
		mov	cl, dh
		rep movsb

OLDBAK_RETN:				; ...
		retn
; ---------------------------------------------------------------------------

PHYCRLF:				; ...
		call	CRLF
		jmp	short GETCH
; ---------------------------------------------------------------------------

LineDel:				; ...
		or	dh, dh
		jz	short GETCH
		call	BackSpace
		jmp	short LineDel
; ---------------------------------------------------------------------------

WordDel:				; ...
		call	BackSpace	; WordLoop
		or	dh, dh
		jz	short GetChJ
		mov	al, es:[di-1]
		cmp	al, '0'
		jb	short GetChJ
		cmp	al, '9'
		jbe	short WordDel
		or	al, 20h
		cmp	al, 'a'
		jb	short GetChJ
		cmp	al, 'z'
		jbe	short WordDel

GetChJ:					; ...
		jmp	GETCH
; ---------------------------------------------------------------------------

KILNEW:					; ...
		mov	al, '\'
		call	OUTT
		pop	si

PUTNEW:					; ...
		call	CRLF
		mov	al, ss:STARTPOS
		call	TAB
		jmp	NEWLIN
; ---------------------------------------------------------------------------

BACKSP:					; ...
		call	BackSpace
		jmp	GETCH
$STD_CON_STRING_INPUT endp


; =============== S U B	R O U T	I N E =======================================


BackSpace	proc near		; ...
		or	dh, dh
		jz	short OLDBAK
		call	BACKUP
		mov	al, es:[di]
		cmp	al, 20h	; ' '
		jnb	short OLDBAK
		cmp	al, 9		; c_HT
		jz	short BAKTAB
		cmp	al, 15h		; "U"-"@"
		jz	short OLDBAK
		cmp	al, 14h		; "T"-"@"
		jz	short OLDBAK
		call	BACKMES

OLDBAK:					; ...
		cmp	ss:INSMODE, 0
		jnz	short OLDBAK_RETN
		or	bh, bh
		jz	short OLDBAK_RETN
		dec	bh
		dec	si
		retn
; ---------------------------------------------------------------------------

BAKTAB:					; ...
		push	di
		dec	di
		std
		mov	cl, dh
		mov	al, 20h	; ' '
		push	bx
		mov	bl, 7
		jcxz	short FIGTAB

FNDPOS:					; ...
		scasb
		jbe	short CHKCNT
		cmp	byte ptr es:[di+1], 9
		jz	short HAVTAB
		dec	bl

CHKCNT:					; ...
		loop	FNDPOS

FIGTAB:					; ...
		sub	bl, ss:STARTPOS

HAVTAB:					; ...
		sub	bl, dh
		add	cl, bl
		and	cl, 7
		cld
		pop	bx
		pop	di
		jz	short OLDBAK

TABBAK:					; ...
		call	BACKMES
		loop	TABBAK
		jmp	short OLDBAK
BackSpace	endp

; ---------------------------------------------------------------------------

BACKUP:					; ...
		dec	dh
		dec	di

BACKMES:				; ...
		mov	al, 8		; c_BS
		call	OUTT
		mov	al, 20h	; ' '
		call	OUTT
		mov	al, 8
		jmp	OUTT
; ---------------------------------------------------------------------------

TWOESC:					; ...
		mov	al, cs:ESCCHAR
		jmp	SAVCH
; ---------------------------------------------------------------------------

COPYLIN:				; ...
		mov	cl, bl
		sub	cl, bh
		jmp	short COPYEACH
; ---------------------------------------------------------------------------

COPYSTR:				; ...
		call	FINDOLD
		jmp	short COPYEACH
; ---------------------------------------------------------------------------

COPYONE:				; ...
		mov	cl, 1

COPYEACH:				; ...
		mov	ss:INSMODE, 0
		cmp	dh, dl
		jz	short GETCH2
		cmp	bh, bl
		jz	short GETCH2
		lodsb
		stosb
		call	BUFOUT
		inc	bh
		inc	dh
		loop	COPYEACH

GETCH2:					; ...
		jmp	GETCH
; ---------------------------------------------------------------------------

SKIPONE:				; ...
		cmp	bh, bl
		jz	short GETCH2
		inc	bh
		inc	si
		jmp	GETCH
; ---------------------------------------------------------------------------

SKIPSTR:				; ...
		call	FINDOLD
		add	si, cx
		add	bh, cl
		jmp	GETCH
; ---------------------------------------------------------------------------

FINDOLD:				; ...
		call	$STD_CON_INPUT_NO_ECHO
		cmp	al, cs:ESCCHAR
		jnz	short FINDSETUP
		call	$STD_CON_INPUT_NO_ECHO
		jmp	short NOTFND
; ---------------------------------------------------------------------------

FINDSETUP:				; ...
		mov	cl, bl
		sub	cl, bh
		jz	short NOTFND
		dec	cx
		jz	short NOTFND
		push	es
		push	ds
		pop	es
		push	di
		mov	di, si
		inc	di
		repne scasb
		pop	di
		pop	es
		jnz	short NOTFND
		not	cl
		add	cl, bl
		sub	cl, bh

; =============== S U B	R O U T	I N E =======================================


FINDOLD_RETN	proc near		; ...
		retn
FINDOLD_RETN	endp

; ---------------------------------------------------------------------------

NOTFND:					; ...
		pop	bp
		jmp	GETCH
; ---------------------------------------------------------------------------

REEDIT:					; ...
		mov	al, '@'
		call	OUTT
		pop	di
		push	di
		push	es
		push	ds
		call	COPYNEW
		pop	ds
		pop	es
		pop	si
		mov	bl, dh
		jmp	PUTNEW
; ---------------------------------------------------------------------------

EXITINS:				; ...
		not	ss:INSMODE	; ENTERINS
		jmp	GETCH
; ---------------------------------------------------------------------------

CTRLZ:					; ...
		mov	al, 1Ah		; "Z"-"@"
		jmp	SAVCH

; =============== S U B	R O U T	I N E =======================================


CRLF		proc near		; ...
		mov	al, 0Dh		; c_CR
		call	OUTT
		mov	al, 0Ah		; c_LF
		jmp	OUTT
CRLF		endp


; =============== S U B	R O U T	I N E =======================================


$RAW_CON_IO	proc near		; ...
		mov	al, dl
		cmp	al, 0FFh
		jz	short rci1
		jmp	short RAWOUT
; ---------------------------------------------------------------------------
		nop			; db 90h ; align 2

rci1:					; ...
		les	di, dword ptr ss:USER_SP
		xor	bx, bx
		call	GET_IO_SFT
		jb	short FINDOLD_RETN
		mov	ah, 1
		call	IOFUNC
		jnz	short RESFLG
		call	SPOOLINT
		or	byte ptr es:[di+16h], 40h ; [ES:DI+user_env.user_F]
		xor	al, al

RET17:					; ...
		retn
; ---------------------------------------------------------------------------

RESFLG:					; ...
		and	byte ptr es:[di+16h], 0BFh

rci0:					; ...
		call	SPOOLINT

$RAW_CON_INPUT:				; ...
		push	bx
		xor	bx, bx
		call	GET_IO_SFT
		pop	bx
		jb	short RET17
		mov	ah, 1
		call	IOFUNC
		jnz	short rci5
		mov	ah, 84h
		int	2Ah		; Microsoft Networks - KEYBOARD	BUSY LOOP
		jmp	short rci0
; ---------------------------------------------------------------------------

rci5:					; ...
		xor	ah, ah
		call	IOFUNC
		retn
$RAW_CON_IO	endp


; =============== S U B	R O U T	I N E =======================================


RAWOUT		proc near		; ...
		push	bx
		mov	bx, 1
		call	GET_IO_SFT
		jb	short RAWRET1
		mov	bx, [si+5]	; [SI+SF_ENTRY.sf_flags]
		and	bx, 8080h	; sf_isnet+devid_device
		cmp	bx, 80h
		jnz	short RAWNORM
		push	ds
		lds	bx, [si+7]	; [SI+SF_ENTRY.sf_devptr]
		test	byte ptr [bx+4], 10h ; [BX+SYSDEV.ATT],
					; ISSPEC
		pop	ds
		jz	short RAWNORM
		int	29h		; DOS 2+ internal - FAST PUTCHAR
					; AL = character to display

RAWRET:					; ...
		clc

RAWRET1:				; ...
		pop	bx

RAWRET2:				; ...
		retn
; ---------------------------------------------------------------------------

RAWNORM:				; ...
		call	RAWOUT3
		jmp	short RAWRET
RAWOUT		endp

; ---------------------------------------------------------------------------

RAWOUT2:				; ...
		call	GET_IO_SFT
		jb	short RAWRET2

; =============== S U B	R O U T	I N E =======================================


RAWOUT3		proc near		; ...
		push	ax
		jmp	short RAWOSTRTRAWOSTRT
; ---------------------------------------------------------------------------

ROLP:					; ...
		call	SPOOLINT
		or	ss:DOS34_FLAG, 200h ; CTRL_BREAK_FLAG
		call	DSKSTATCHK

RAWOSTRTRAWOSTRT:			; ...
		mov	ah, 3
		call	IOFUNC
		jz	short ROLP
		inc	ax
		pop	ax
		jz	short nosend
		mov	ah, 2
		call	IOFUNC

nosend:					; ...
		clc
		retn
RAWOUT3		endp


; =============== S U B	R O U T	I N E =======================================


Save_Restore_Packet proc near		; ...
		push	ds
		push	es
		push	si
		push	di
		cmp	ax, 0
		jz	short save_packet
		mov	si, offset FAKE_STACK_2F
		mov	di, offset DEVCALL
		jmp	short set_seg
; ---------------------------------------------------------------------------

save_packet:				; ...
		mov	di, offset FAKE_STACK_2F
		mov	si, offset DEVCALL

set_seg:				; ...
		mov	ax, ss
		mov	ds, ax
		mov	es, ax
		mov	cx, 11
		rep movsw
		pop	di
		pop	si
		pop	es
		pop	ds
		retn
Save_Restore_Packet endp


; =============== S U B	R O U T	I N E =======================================


$STD_CON_INPUT	proc near		; ...
		call	$STD_CON_INPUT_NO_ECHO
		push	ax
		call	OUTT
		pop	ax

CON_INPUT_RETN:				; ...
		retn
$STD_CON_INPUT	endp

; ---------------------------------------------------------------------------

$STD_CON_OUTPUT:			; ...
		mov	al, dl

OUTT:					; ...
		cmp	al, 20h	; ' '
		jb	short CTRLOUT
		cmp	al, 7Fh		; c_DEL	; 127
		jz	short OUTCH

OUTCHA:
		inc	ss:CARPOS

OUTCH:					; ...
		push	ds
		push	si
		inc	ss:CHARCO
		and	ss:CHARCO, 3Fh	; 00111111b
		jnz	short OUTSKIP
		push	ax
		call	STATCHK
		pop	ax

OUTSKIP:				; ...
		call	RAWOUT
		pop	si
		pop	ds
		test	ss:PFLAG, 0FFh	; -1
		jz	short CON_INPUT_RETN
		push	bx
		push	ds
		push	si
		mov	bx, 1
		call	GET_IO_SFT
		jb	short TRIPOPJ
		mov	bx, [si+5]	; [SI+SF_ENTRY.sf_flags]
		test	bh, 80h		; (sf_isnet>>8)
		jnz	short TRIPOPJ
		test	bl, 80h		; devid_device
		jz	short TRIPOPJ
		mov	bx, 4
		call	GET_IO_SFT
		jb	short TRIPOPJ
		test	byte ptr [si+6], 8 ; [SI+SF_ENTRY.sf_flags+1],
					; (sf_net_spool>>8)
		jz	short LISSTRT2J
		mov	ss:PFLAG, 0

TRIPOPJ:				; ...
		jmp	TRIPOP
; ---------------------------------------------------------------------------

LISSTRT2J:				; ...
		jmp	LISSTRT2
; ---------------------------------------------------------------------------

CTRLOUT:				; ...
		cmp	al, 0Dh		; c_CR
		jz	short ZERPOS
		cmp	al, 8		; c_BS
		jz	short BACKPOS
		cmp	al, 9		; c_HT
		jnz	short OUTCH
		mov	al, ss:CARPOS
		or	al, 0F8h
		neg	al

TAB:					; ...
		push	cx
		mov	cl, al
		mov	ch, 0
		jcxz	short POPTAB

TABLP:					; ...
		mov	al, 20h	; ' '
		call	OUTT
		loop	TABLP

POPTAB:					; ...
		pop	cx
		retn
; ---------------------------------------------------------------------------

ZERPOS:					; ...
		mov	ss:CARPOS, 0
		jmp	short OUTCH
; ---------------------------------------------------------------------------

OUTJ:					; ...
		jmp	OUTT
; ---------------------------------------------------------------------------

BACKPOS:				; ...
		dec	ss:CARPOS
		jmp	OUTCH

; =============== S U B	R O U T	I N E =======================================


BUFOUT		proc near		; ...
		cmp	al, 20h	; ' '
		jnb	short OUTJ
		cmp	al, 9
		jz	short OUTJ
		cmp	al, 15h		; "U"-"@"
		jz	short CTRLU
		cmp	al, 14h		; "T"-"@"
		jz	short CTRLU

NOT_CTRLU:
		push	ax
		mov	al, '^'
		call	OUTT
		pop	ax
		or	al, 40h

CTRLU:					; ...
		call	OUTT

BUFOUT_RETN:				; ...
		retn
BUFOUT		endp

; ---------------------------------------------------------------------------

$STD_AUX_INPUT:				; ...
		call	STATCHK
		mov	bx, 3
		call	GET_IO_SFT
		jb	short BUFOUT_RETN
		jmp	short TAISTRT
; ---------------------------------------------------------------------------

AUXILP:					; ...
		call	SPOOLINT

TAISTRT:				; ...
		mov	ah, 1
		call	IOFUNC
		jz	short AUXILP
		xor	ah, ah
		call	IOFUNC
		retn
; ---------------------------------------------------------------------------

$STD_AUX_OUTPUT:			; ...
		push	bx
		mov	bx, 3
		jmp	short SENDOUT
; ---------------------------------------------------------------------------

$STD_PRINTER_OUTPUT:			; ...
		push	bx
		mov	bx, 4

SENDOUT:				; ...
		mov	al, dl
		push	ax
		call	STATCHK
		pop	ax
		push	ds
		push	si

LISSTRT2:				; ...
		call	RAWOUT2

TRIPOP:					; ...
		pop	si
		pop	ds
		pop	bx

SCIS_RETN:				; ...
		retn
; ---------------------------------------------------------------------------

$STD_CON_INPUT_STATUS:			; ...
		call	STATCHK
		mov	al, 0
		jz	short SCIS_RETN
		or	al, 0FFh	; -1
		retn
; ---------------------------------------------------------------------------

$STD_CON_INPUT_FLUSH:			; ...
		push	ax
		push	dx
		xor	bx, bx
		call	GET_IO_SFT
		jb	short BADJFNCON
		mov	ah, 4
		call	IOFUNC

BADJFNCON:				; ...
		pop	dx
		pop	ax
		mov	ah, al
		cmp	al, 1
		jz	short REDISPJ
		cmp	al, 6
		jz	short REDISPJ
		cmp	al, 7
		jz	short REDISPJ
		cmp	al, 8
		jz	short REDISPJ
		cmp	al, 10
		jz	short REDISPJ
		mov	al, 0
		retn
; ---------------------------------------------------------------------------

REDISPJ:				; ...
		cli
		jmp	REDISP
; ---------------------------------------------------------------------------

$GET_FCB_POSITION:			; ...
		call	GetExtended
		call	GetExtent
		mov	[si+21h], ax	; [SI+SYS_FCB.RR]
		mov	[si+23h], dl	; [SI+SYS_FCB.RR+2]
		cmp	word ptr [si+0Eh], 64 ;	[SI+SYS_FCB.RECSIZ]
		jnb	short GetFCBBye
		mov	[si+24h], dh	; [SI+SYS_FCB.RR+2+1]

GetFCBBye:				; ...
		jmp	NO_OP
; ---------------------------------------------------------------------------

$FCB_DELETE:				; ...
		mov	di, offset OPENBUF
		call	TransFCB
		jb	short BadPath
		push	ss
		pop	ds
		call	DOS_DELETE
		jb	short BadPath

GoodPath:				; ...
		jmp	short GetFCBBye
; ---------------------------------------------------------------------------

BadPath:				; ...
		jmp	FCB_RET_ER
; ---------------------------------------------------------------------------

$GET_FCB_FILE_LENGTH:			; ...
		call	GetExtended
		mov	di, offset OPENBUF
		push	ds
		push	si
		call	TransFCB
		pop	si
		pop	ds
		jb	short BadPath
		push	ds
		push	si
		push	ss
		pop	ds
		call	GET_FILE_INFO
		pop	si
		pop	ds
		jb	short BadPath
		mov	dx, bx
		mov	ax, di
		mov	bx, [si+0Eh]	; [SI+SYS_FCB.RECSIZ]
		or	bx, bx
		jnz	short GetSize
		mov	bx, 128

GetSize:				; ...
		mov	di, ax
		mov	ax, dx
		xor	dx, dx
		div	bx
		push	ax
		mov	ax, di
		div	bx
		mov	cx, dx
		pop	dx
		jcxz	short LengthStore
		add	ax, 1
		adc	dx, 0

LengthStore:				; ...
		mov	[si+21h], ax	; [SI+SYS_FCB.RR]
		mov	[si+23h], dl	; [SI+SYS_FCB.RR+2]
		or	dh, dh
		jz	short GoodPath
		mov	[si+24h], dh	; [SI+SYS_FCB.RR+3]

GoodRet:				; ...
		jmp	short GoodPath
; ---------------------------------------------------------------------------

$FCB_CLOSE:				; ...
		xor	al, al
		call	GetExtended
		jz	short NoAttr
		mov	al, [si-1]

NoAttr:					; ...
		mov	ss:ATTRIB, al
		call	SFTFromFCB
		jb	short GoodRet
		mov	al, es:[di+4]	; [ES:DI+SF_ENTRY.sf_attr]
		xor	ah, ah
		push	ax
		call	CheckShare
		jnz	short NoStash
		mov	al, ss:ATTRIB
		mov	es:[di+4], al	; [ES:DI+SF_ENTRY.sf_attr]

NoStash:				; ...
		mov	ax, [si+14h]	; [SI+SYS_FCB.FDATE]
		mov	es:[di+0Fh], ax	; [ES:DI+SF_ENTRY.sf_date]
		mov	ax, [si+16h]	; [SI+SYS_FCB.FTIME]
		mov	es:[di+0Dh], ax	; [ES:DI+SF_ENTRY.sf_time]
		mov	ax, [si+10h]	; [SI+SYS_FCB.FILSIZ]
		mov	es:[di+11h], ax	; [ES:DI+SF_ENTRY.sf_size]
		mov	ax, [si+12h]	; [SI+SYS_FCB.FILSIZ+2]
		mov	es:[di+13h], ax	; [ES:DI+SF_ENTRY.sf_size+2]
		or	word ptr es:[di+5], 4000h ; [ES:DI+SF_ENTRY.sf_flags],
					; sf_close_nodate
		push	ss
		pop	ds
		call	DOS_CLOSE
		les	di, ds:THISSFT
		pop	cx
		mov	es:[di+4], cl	; [ES:DI+SF_ENTRY.sf_attr]
		pushf
		cmp	word ptr es:[di], 0 ; [ES:DI+SF_ENTRY.sf_ref_count]
		jnz	short CloseOK
		push	ax
		mov	al, 'M'         ; 4Dh
		call	BlastSFT
		pop	ax

CloseOK:				; ...
		popf
		jnb	short GoodRet
		cmp	al, 6		; error_invalid_handle
		jz	short GoodRet
		mov	al, 2		; error_file_not_found

fcb_close_err:				; ...
		jmp	FCB_RET_ER
; ---------------------------------------------------------------------------

$FCB_RENAME:				; ...
		call	GetExtended
		push	dx
		mov	al, [si]
		add	si, 10h
		mov	di, offset RENBUF
		push	word ptr [si]
		push	ds
		push	si
		mov	[si], al
		mov	dx, si
		call	TransFCB
		pop	si
		pop	ds
		pop	word ptr [si]
		pop	dx
		jb	short fren90
		mov	si, ss:WFP_START
		mov	ss:REN_WFP, si
		mov	di, offset OPENBUF
		call	TransFCB
		jb	short fren90
		call	DOS_RENAME
		jb	short fren90
		jmp	NO_OP		; FCB_RET_OK
; ---------------------------------------------------------------------------

fren90:					; ...
		jmp	short fcb_close_err

; =============== S U B	R O U T	I N E =======================================


SaveFCBInfo	proc near		; ...
		les	di, ss:THISSFT
		call	IsSFTNet
		jz	short SaveLocal
		mov	ax, es:[di+0Bh]	; [ES:DI+sf_serial_ID]
		mov	[si+1Ch], ax	; [SI+fcb_netID]
		mov	bl, 80h		; FCBNETWORK
		jmp	short SaveSFN
; ---------------------------------------------------------------------------

SaveLocal:				; ...
		call	CheckShare
		jz	short SaveNoShare
		jmp	short SaveShare
; ---------------------------------------------------------------------------

SaveNoShare:				; ...
		test	byte ptr es:[di+5], 80h	; [ES:DI+SF_ENTRY.sf_flags],
					; devid_device
		jnz	short SaveNoShareDev
		mov	ax, es:[di+1Bh]	; [ES:DI+SF_ENTRY.sf_dirsec]
		mov	[si+1Dh], ax	; [SI+fcb_nsl_dirsec]
		mov	ax, es:[di+1Dh]	; [es:di+SF_ENTRY.sf_dirsec+2]
		mov	bl, es:[di+4]	; [es:di+SF_ENTRY.sf_attr]
		mov	bh, bl
		ror	bl, 1
		shl	bh, 1
		or	bl, bh
		and	bl, 0C0h
		or	al, bl
		mov	[si+18h], al	; [si+fcb_sfn]
		mov	al, es:[di+1Fh]	; [ES:DI+SF_ENTRY.sf_dirpos]
		mov	[si+1Fh], al	; [SI+fcb_nsl_dirpos]
		mov	ax, es:[di+0Bh]	; [ES:DI+SF_ENTRY.sf_firclus]
		mov	[si+1Bh], ax	; [SI+fcb_nsl_firclus]
		mov	bl, 0

SetFCBBits:				; ...
		mov	ax, es:[di+5]	; [ES:DI+SF_ENTRY.sf_flags]
		and	al, 0C0h
		or	al, es:[di+2]	; [ES:DI+SF_ENTRY.sf_mode]
		mov	[si+1Ah], al	; [SI+fcb_nsl_bits]
		or	bl, bl
		jz	short SaveNoSFN
		jmp	short SaveSFN
; ---------------------------------------------------------------------------

SaveNoShareDev:				; ...
		mov	ax, es:[di+7]	; [ES:DI+SF_ENTRY.sf_devptr]
		mov	[si+1Ah], ax	; [SI+fcb_nsld_drvptr]
		mov	ax, es:[di+9]	; [ES:DI+SF_ENTRY.sf_devptr+2]
		mov	[si+1Ch], ax	; [SI+fcb_nsld_drvptr+2]
		mov	bl, 40h		; FCBDEVICE
		jmp	short SetFCBBits
; ---------------------------------------------------------------------------

SaveShare:				; ...
		call	dword ptr ss:ShSave ; Call far [ss:JShare+(10*4)]

SaveSFN:				; ...
		lea	ax, [di-6]	; [DI-SFT.SFTable]
		sub	ax, word ptr ss:SFTFCB
		push	bx
		mov	bl, 59		; SF_ENTRY.size
		div	bl
		mov	[si+18h], al	; [SI+fcb_sfn]
		pop	bx

SaveNoSFN:				; ...
		mov	ax, es:[di+5]	; [ES:DI+SF_ENTRY.sf_flags]
		and	al, 3Fh
		or	al, bl
		mov	[si+19h], al	; [SI+fcb_l_drive]
		mov	ax, ss:FCBLRU
		inc	ax
		mov	es:[di+15h], ax	; [ES:DI+sf_LRU]
		jnz	short SimpleStuff
		mov	bx, 15h		; SF_ENTRY.sf_position
		call	ResetLRU

SimpleStuff:				; ...
		mov	ss:FCBLRU, ax
		retn
SaveFCBInfo	endp


; =============== S U B	R O U T	I N E =======================================


ResetLRU	proc near		; ...
		mov	ax, 8000h
		push	es
		push	di
		les	di, ss:SFTFCB
		mov	cx, es:[di+4]	; [ES:DI+SFT.SFCount]
		lea	di, [di+6]	; [DI+SFT.SFTable]

ovScan:					; ...
		sub	es:[bx+di], ax
		ja	short ovLoop
		mov	es:[bx+di], ax

ovLoop:					; ...
		add	di, 59		; SF_ENTRY.size
		loop	ovScan
		pop	di
		pop	es
		mov	es:[bx+di], ax
		retn
ResetLRU	endp


; =============== S U B	R O U T	I N E =======================================


LRUFCB		proc near		; ...
		push	es
		call	save_world
		mov	ds, cs:DosDSeg
		or	al, al
		jnz	short lru1
		mov	di, word ptr ds:LocalSFT
		or	di, word ptr ds:LocalSFT+2
		jz	short lru1
		les	di, ds:LocalSFT

gotlocalSFT:				; ...
		mov	word ptr ds:THISSFT, di
		mov	word ptr ds:THISSFT+2, es
		clc
		jmp	LRUDone
; ---------------------------------------------------------------------------

lru1:					; ...
		les	di, ds:SFTFCB
		mov	cx, es:[di+4]	; [es:di+SFT.SFCount]
		lea	di, [di+6]	; [di+SFT.SFTable]
		mov	bx, 0FFFFh	; -1
		mov	si, bx
		mov	dx, bx
		mov	bp, bx

findSFT:				; ...
		or	word ptr es:[di], 0 ; [es:di+SF_ENTRY.sf_ref_count]
		jz	short gotSFT
		cmp	word ptr es:[di], 0FFFFh ; [es:di+SF_ENTRY.sf_ref_count],
					; sf_busy
		jz	short gotSFT
		test	word ptr es:[di+5], 8000h ; [ES:DI+SF_ENTRY.sf_flags],
					; sf_isnet
		jnz	short lru5
		call	CheckShare
		jnz	short lru5

hackpoint:				; ...
		mov	word ptr ds:LocalSFT, di
		mov	word ptr ds:LocalSFT+2,	es
		or	al, al
		jz	short gotlocalSFT
		cmp	es:[di+15h], bx	; [es:di+sf_LRU]
		jnb	short lru4
		mov	bx, es:[di+15h]	; [es:di+sf_LRU]
		mov	si, di

lru4:					; ...
		add	di, 59		; SF_ENTRY.size
		loop	findSFT
		mov	di, si
		cmp	si, -1
		jnz	short gotSFT
		mov	di, bp
		cmp	bp, -1
		jnz	short gotnetSFT

noSFT:
		jmp	short errorbadSFT
; ---------------------------------------------------------------------------

lru5:					; ...
		cmp	es:[di+15h], dx	; [es:di+sf_LRU]
		jnb	short lru4
		mov	dx, es:[di+15h]	; [es:di+sf_LRU]
		mov	bp, di
		jmp	short lru4
; ---------------------------------------------------------------------------

gotSFT:					; ...
		or	al, al
		jz	short hackpoint
		mov	ax, es
		cmp	word ptr ds:LocalSFT, di
		jnz	short notinvalid
		cmp	word ptr ds:LocalSFT+2,	ax
		jz	short zerolocalSFT

notinvalid:				; ...
		jmp	gotlocalSFT
; ---------------------------------------------------------------------------

zerolocalSFT:				; ...
		xor	ax, ax
		mov	word ptr ds:LocalSFT, ax
		mov	word ptr ds:LocalSFT+2,	ax
		jmp	gotlocalSFT
; ---------------------------------------------------------------------------

gotnetSFT:				; ...
		or	al, al
		jnz	short closenet
		mov	word ptr ds:LocalSFT, di
		mov	word ptr ds:LocalSFT+2,	es

closenet:				; ...
		mov	word ptr ds:THISSFT, di
		mov	word ptr ds:THISSFT+2, es

LRUClose:				; ...
		cmp	word ptr es:[di], 0 ; [es:di+SF_ENTRY.sf_ref_count]
		jz	short LRUDone
		call	DOS_CLOSE
		jnb	short LRUClose
		cmp	al, 6
		jz	short LRUClose

errorbadSFT:				; ...
		stc
		jmp	short LRUDead
; ---------------------------------------------------------------------------

LRUDone:				; ...
		xor	al, al
		call	BlastSFT

LRUDead:				; ...
		call	restore_world
		pop	es
		mov	es, cs:DosDSeg
		les	di, es:THISSFT
		jb	short LruFCB_err
		retn
; ---------------------------------------------------------------------------

LruFCB_err:				; ...
		mov	al, 23h		; error_FCB_unavailable
		retn
LRUFCB		endp


; =============== S U B	R O U T	I N E =======================================


RegenCopyName	proc near		; ...
		lodsb
		call	UCase

StuffChar2:
		stosb
		loop	RegenCopyName	; CopyName
		retn
RegenCopyName	endp


; =============== S U B	R O U T	I N E =======================================


FCBRegen	proc near		; ...
		mov	al, [si+19h]	; [SI+fcb_l_drive]
		test	al, 80h
		jz	short RegenNoSharing
		call	CheckShare
		jnz	short RegenFail
		mov	ax, 1100h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - INSTALLATION	CHECK
					; Return: AL = 00h  not	installed, OK to install
					; 01h  not installed, not OK to	install
					; FFh  installed
		or	al, al
		jz	short RegenDead

RegenFail:				; ...
		mov	ax, ss:USER_IN_AX
		cmp	ah, 10h
		jz	short RegenDead
		call	FCBHardErr

RegenDead:				; ...
		stc

FCBRegen_retn:				; ...
		retn
; ---------------------------------------------------------------------------

RegenNoSharing:				; ...
		call	CheckShare
		jnz	short RegenFail
		push	ax
		mov	al, 0
		call	LRUFCB
		pop	ax
		jb	short FCBRegen_retn
		mov	word ptr es:[di+2], 8002h ; [ES:DI+SF_ENTRY.sf_mode],
					; sf_isFCB+open_for_both+SHARING_COMP
		and	al, 3Fh
		cbw
		or	ax, 4000h	; sf_close_nodate
		mov	cl, [si+1Ah]	; [SI+fcb_nsl_bits]
		mov	ch, cl
		and	ch, 0C0h
		or	al, ch
		and	cl, 0Fh		; access_mask
		mov	es:[di+2], cl	; ES:DI+SF_ENTRY.sf_mode]
		mov	es:[di+5], ax	; [ES:DI+SF_ENTRY.sf_flags]
		mov	ax, ss:PROC_ID
		mov	es:[di+31h], ax	; [ES:DI+SF_ENTRY.sf_PID]
		push	ds
		push	si
		push	es
		push	di
		push	ss
		pop	es
		mov	di, offset NAME1
		mov	cx, 8
		inc	si
		call	RegenCopyName
		push	ss
		pop	ds
		mov	ds:ATTRIB, 16h	; attr_hidden+attr_system+attr_directory
		call	DEVNAME
		pop	di
		pop	es
		pop	si
		pop	ds
		jb	short RegenFileNoSharing
		mov	es:[di+5], bh	; [ES:DI+SF_ENTRY.sf_flags]
		mov	byte ptr es:[di+4], 0 ;	[ES:DI+SF_ENTRY.sf_attr]
		lds	si, ss:DEVPT
		mov	es:[di+7], si	; [ES:DI+SF_ENTRY.sf_devptr]
		mov	word ptr es:[di+9], ds ; [ES:DI+SF_ENTRY.sf_devptr+2]
		retn
; ---------------------------------------------------------------------------

RegenDeadJ:				; ...
		jmp	short RegenDead
; ---------------------------------------------------------------------------

RegenFileNoSharing:			; ...
		mov	ax, es:[di+5]	; [ES:DI+SF_ENTRY.sf_flags]
		and	ax, 3Fh
		push	ds
		push	si
		call	FIND_DPB
		mov	es:[di+7], si	; [ES:DI+SF_ENTRY.sf_devptr]
		mov	word ptr es:[di+9], ds ; [ES:DI+SF_ENTRY.sf_devptr+2]
		pop	si
		pop	ds
		jb	short RegenDeadJ
		mov	ax, [si+1Dh]	; [SI+fcb_nsl_dirsec]
		mov	es:[di+1Bh], ax	; [ES:DI+SF_ENTRY.sf_dirsec]
		mov	al, [si+18h]	; [si+fcb_sfn]
		and	al, 0C0h
		mov	ah, al
		rol	ah, 1
		shr	al, 1
		or	al, ah
		and	al, 3Fh
		mov	es:[di+4], al	; [es:di+SF_ENTRY.sf_attr]
		mov	al, [si+18h]	; [si+fcb_sfn]
		and	al, 3Fh
		sub	ah, ah
		mov	es:[di+1Dh], ax	; [es:di+SF_ENTRY.sf_dirsec+2]
		mov	ax, [si+1Bh]	; [SI+fcb_nsl_firclus]
		mov	es:[di+0Bh], ax	; [ES:DI+SF_ENTRY.sf_firclus]
		mov	es:[di+35h], ax	; [ES:DI+SF_ENTRY.sf_lstclus]
		mov	al, [si+1Fh]	; SI+fcb_nsl_dirpos]
		mov	es:[di+1Fh], al	; [ES:DI+SF_ENTRY.sf_dirpos]
		inc	word ptr es:[di] ; [ES:DI+SF_ENTRY.sf_ref_count]
		lea	si, [si+1]	; [SI+SYS_FCB.name]
		lea	di, [di+20h]	; [DI+SF_ENTRY.sf_name]
		mov	cx, 11		; SYS_FCB.EXTENT-SYS_FCB.name ;	12-1
		call	RegenCopyName
		clc
		retn
FCBRegen	endp


; =============== S U B	R O U T	I N E =======================================


BlastSFT	proc near		; ...
		push	di
		mov	cx, 59		; SF_ENTRY.size
		rep stosb
		pop	di
		sub	ax, ax
		mov	es:[di], ax	; [es:di+SFT_ENTRY.sf_ref_count]
		mov	es:[di+15h], ax	; [es:di+sf_LRU]
		dec	ax
		mov	es:[di+17h], ax	; [es:di+sf_OpenAge]
		retn
BlastSFT	endp


; =============== S U B	R O U T	I N E =======================================


CheckFCB	proc near		; ...
		test	byte ptr [si+19h], 0C0h	; [si+fcb_l_drive],
					; FCBNETWORK|FCBSHARE|FCBDEVICE
		jz	short BadSFT
		les	di, ss:SFTFCB
		cmp	es:[di+4], al	; [ES:DI+SFT.SFCount]
		jb	short BadSFT
		mov	bl, 59		; SF_ENTRY.size
		mul	bl
		lea	di, [di+6]	; [DI+SFT.SFTable]
		add	di, ax
		mov	ax, ss:PROC_ID
		cmp	es:[di+31h], ax	; [ES:DI+SF_ENTRY.sf_PID]
		jnz	short BadSFT
		cmp	word ptr es:[di], 0 ; [ES:DI+SF_ENTRY.sf_ref_count]
		jz	short BadSFT
		mov	al, [si+19h]	; [SI+fcb_l_drive]
		test	al, 80h		; FCBSPECIAL
		jz	short CheckNoShare
		push	ax
		and	al, 0C0h	; FCBMASK
		cmp	al, 0C0h	; FCBSHARE
		pop	ax
		jnz	short CheckNet
		call	dword ptr ss:ShChk ; Call far [ss:JShare+(11*4)]
		jb	short BadSFT
		jmp	short CheckD
; ---------------------------------------------------------------------------

CheckFirClus:				; [ES:DI+SF_ENTRY.sf_firclus]
		cmp	bx, es:[di+0Bh]
		jnz	short BadSFT

CheckD:					; ...
		and	al, 3Fh
		mov	ah, es:[di+5]
		and	ah, 3Fh
		cmp	ah, al
		jnz	short BadSFT

CheckD_retn:				; ...
		retn
; ---------------------------------------------------------------------------

BadSFT:					; ...
		stc
		retn
; ---------------------------------------------------------------------------

CheckNet:				; ...
		mov	ax, [si+1Ch]	; [SI+fcb_netID]
		cmp	ax, es:[di+0Bh]	; [ES:DI+sf_serial_ID]
		jnz	short BadSFT
		retn
; ---------------------------------------------------------------------------

CheckNoShare:				; ...
		test	al, 40h		; FCBDEVICE
		jnz	short $+2	; CheckNoShareDev

CheckNoShareDev:			; ...
		mov	bx, [si+1Ah]	; [SI+fcb_nsld_drvptr]
		cmp	bx, es:[di+7]	; [ES:DI+SF_ENTRY.sf_devptr]
		jnz	short BadSFT
		mov	bx, [si+1Ch]	; [SI+fcb_nsld_drvptr+2]
		cmp	bx, es:[di+9]	; [ES:DI+SF_ENTRY.sf_devptr+2]
		jnz	short BadSFT
		jmp	short CheckD
CheckFCB	endp


; =============== S U B	R O U T	I N E =======================================


SFTFromFCB	proc near		; ...
		push	ax
		push	bx
		mov	al, [si+18h]	; [SI+fcb_sfn]
		call	CheckFCB
		pop	bx
		pop	ax
		mov	word ptr ss:THISSFT, di
		mov	word ptr ss:THISSFT+2, es
		jnb	short Set_SFT
		push	es
		call	save_world
		call	FCBRegen
		call	restore_world
		pop	es
		mov	ax, ss:EXTERR
		jb	short CheckD_retn

Set_SFT:				; ...
		les	di, ss:THISSFT
		push	ss:PROC_ID
		pop	word ptr es:[di+31h] ; [ES:DI+SF_ENTRY.sf_PID]
		retn
SFTFromFCB	endp


; =============== S U B	R O U T	I N E =======================================


FCBHardErr	proc near		; ...
		mov	es, cs:DosDSeg
		mov	ax, 23h		; error_FCB_unavailable
		mov	es:ALLOWED, 8	; Allowed_FAIL
		les	bp, es:THISDPB
		mov	di, 1
		mov	cx, di
		mov	dx, es:[bp+0Bh]	; [ES:BP+DPB.FIRST_SECTOR]
		call	HARDERR
		stc
		retn
FCBHardErr	endp


; =============== S U B	R O U T	I N E =======================================


GetRR		proc near		; ...
		mov	ax, [si+21h]	; [SI+SYS_FCB.RR]
		mov	dx, [si+23h]	; [SI+SYS_FCB.RR+2]
		cmp	bx, 64
		jb	short GetRRBye
		xor	dh, dh

GetRRBye:				; ...
		retn
GetRR		endp


; =============== S U B	R O U T	I N E =======================================


GetExtent	proc near		; ...
		mov	al, [si+20h]	; [SI+SYS_FCB.NR]
		mov	dx, [si+0Ch]	; [SI+SYS_FCB.EXTENT]
		shl	al, 1
		shr	dx, 1
		rcr	al, 1
		mov	ah, dl
		mov	dl, dh
		xor	dh, dh
		retn
GetExtent	endp


; =============== S U B	R O U T	I N E =======================================


SetExtent	proc near		; ...
		push	ax
		push	dx
		mov	cx, ax
		and	al, 7Fh
		mov	[si+20h], al	; [SI+SYS_FCB.NR]
		and	cl, 80h
		shl	cx, 1
		rcl	dx, 1
		mov	al, ch
		mov	ah, dl
		mov	[si+0Ch], ax	; [SI+SYS_FCB.EXTENT]
		pop	dx
		pop	ax
		retn
SetExtent	endp


; =============== S U B	R O U T	I N E =======================================


GetExtended	proc near		; ...
		mov	si, dx
		cmp	byte ptr [si], 0FFh ; -1
		jnz	short GetBye
		add	si, 7

GetBye:					; ...
		cmp	si, dx

getextd_retn:				; ...
		retn
GetExtended	endp


; =============== S U B	R O U T	I N E =======================================


GetRecSize	proc near		; ...
		mov	bx, [si+0Eh]	; [SI+SYS_FCB.RECSIZ]
		or	bx, bx
		jnz	short getextd_retn
		mov	bx, 128
		mov	[si+0Eh], bx	; [SI+SYS_FCB.RECSIZ]
		retn
GetRecSize	endp

; ---------------------------------------------------------------------------

FCBIO:					; ...
		push	bp
		mov	bp, sp
		sub	sp, 14h
		mov	[bp-14h], al	; FCBOp
		mov	byte ptr [bp-1], 0 ; FCBErr
		call	GetExtended
		test	byte ptr [bp-14h], 8 ; FCBOp,BLOCK
		jnz	short GetPos
		mov	cx, 1

GetPos:					; ...
		mov	[bp-3],	cx	; cRec
		call	GetExtent
		call	GetRecSize
		mov	[bp-9],	bx	; RecSize
		test	byte ptr [bp-14h], 2 ; FCBOp,RANDOM
		jz	short GetRec
		call	GetRR

GetRec:					; ...
		mov	[bp-7],	ax	; RecPosL
		mov	[bp-5],	dx	; RecPosH
		call	SetExtent
		mov	ax, [bp-5]	; RecPosH
		mul	bx
		mov	di, ax
		mov	ax, [bp-7]	; RecPosL
		mul	bx
		add	dx, di
		mov	[bp-0Dh], ax	; bPosL
		mov	[bp-0Bh], dx	; bPosH
		mov	ax, [bp-3]	; cRec
		mul	bx
		mov	[bp-0Fh], ax	; cByte
		add	ax, word ptr ss:DMAADD
		adc	dx, 0
		jz	short DoOper
		mov	byte ptr [bp-1], 2 ; FCBErr,FTRIM
		mov	ax, word ptr ss:DMAADD
		neg	ax
		jnz	short DoDiv
		dec	ax

DoDiv:					; ...
		xor	dx, dx
		div	bx
		mov	[bp-3],	ax	; cRec
		mul	bx
		mov	[bp-0Fh], ax	; cByte

DoOper:					; ...
		xor	bx, bx
		mov	[bp-11h], bx	; cResult
		cmp	[bp-0Fh], bx	; cByte
		jnz	short DoGetExt
		test	byte ptr [bp-1], 2 ; FCBErr,FTRIM
		jz	short DoGetExt
		jmp	short SkipOp
; ---------------------------------------------------------------------------

DoGetExt:				; ...
		call	SFTFromFCB
		jnb	short ContinueOp

FCBDeath:				; ...
		call	FCB_RET_ER
		mov	word ptr [bp-13h], 0 ; cRecRes
		mov	byte ptr [bp-1], 1 ; FCBErr,FEOF
		jmp	FCBSave
; ---------------------------------------------------------------------------

ContinueOp:				; ...
		mov	ax, [si+10h]	; [SI+SYS_FCB.FILSIZ]
		mov	es:[di+11h], ax	; [ES:DI+SF_ENTRY.sf_size]
		mov	ax, [si+12h]	; [SI+SYS_FCB.FILSIZ+2]
		mov	es:[di+13h], ax	; [ES:DI+SF_ENTRY.sf_size+2]
		mov	ax, [bp-0Dh]	; bPosL
		mov	dx, [bp-0Bh]	; bPosH
		mov	es:[di+15h], ax	; [ES:DI+SF_ENTRY.sf_position]
		xchg	dx, es:[di+17h]	; [ES:DI+SF_ENTRY.sf_position+2]
		push	dx
		mov	cx, [bp-0Fh]	; cByte
		mov	di, offset DOS_READ
		test	byte ptr [bp-14h], 4 ; FCBOp,FCBREAD
		jnz	short DoContext
		mov	di, offset DOS_WRITE

DoContext:				; ...
		push	bp
		push	ds
		push	si
		push	ss
		pop	ds
		call	di ; DOS_READ	; or DOS_WRITE
		pop	si
		pop	ds
		pop	bp
		jb	short FCBDeath
		cmp	ss:DISK_FULL, 0
		jz	short NODSKFULL
		mov	ss:DISK_FULL, 0
		mov	byte ptr [bp-1], 1 ; FCBErr,FEOF

NODSKFULL:				; ...
		mov	[bp-11h], cx	; cResult
		call	SaveFCBInfo
		pop	word ptr es:[di+17h] ; [ES:DI+SF_ENTRY.sf_position+2]
		mov	ax, es:[di+11h]	; [ES:DI+SF_ENTRY.sf_size]
		mov	[si+10h], ax	; [SI+SYS_FCB.FILSIZ]
		mov	ax, es:[di+13h]	; [ES:DI+SF_ENTRY.sf_size+2]
		mov	[si+12h], ax	; [SI+SYS_FCB.FILSIZ+2]

SkipOp:					; ...
		mov	ax, [bp-11h]	; cResult
		xor	dx, dx
		div	word ptr [bp-9]	; RecSize
		mov	[bp-13h], ax	; cRecRes
		add	[bp-7],	ax	; RecPosL
		adc	word ptr [bp-5], 0 ; RecPosH
		cmp	ax, [bp-3]	; cRec
		jz	short TryBlank
		test	byte ptr [bp-14h], 4 ; FCBOp,FCBREAD
		jnz	short SetEOF
		test	byte ptr es:[di+5], 80h
		jnz	short TryBlank

SetEOF:					; ...
		mov	byte ptr [bp-1], 1 ; FCBErr,FEOF

TryBlank:				; ...
		or	dx, dx
		jz	short SetExt
		add	word ptr [bp-7], 1 ; RecPosL
		adc	word ptr [bp-5], 0 ; RecPosH
		test	byte ptr [bp-14h], 4 ; FCBOp,FCBREAD
		jz	short SetExt
		inc	word ptr [bp-13h] ; cRecRes
		mov	byte ptr [bp-1], 3 ; FCBErr,FTRIM+FEOF
		mov	cx, [bp-9]	; RecSize
		sub	cx, dx
		xor	al, al
		les	di, ss:DMAADD
		add	di, [bp-11h]	; cResult
		rep stosb

SetExt:					; ...
		mov	dx, [bp-5]	; RecPosH
		mov	ax, [bp-7]	; RecPosL
		test	byte ptr [bp-14h], 2 ; FCBOp,RANDOM
		jz	short DoSetExt
		test	byte ptr [bp-14h], 8 ; FCBOp,BLOCK
		jz	short TrySetRR

DoSetExt:				; ...
		call	SetExtent

TrySetRR:				; ...
		test	byte ptr [bp-14h], 8 ; FCBOp,BLOCK
		jz	short TryReturn
		mov	[si+21h], ax	; [SI+SYS_FCB.RR]
		mov	[si+23h], dl	; [SI+SYS_FCB.RR+2]
		cmp	word ptr [si+0Eh], 64 ;	[SI+SYS_FCB.RECSIZ]
		jnb	short TryReturn
		mov	[si+24h], dh	; [SI+SYS_FCB.RR+2+1]

TryReturn:				; ...
		test	byte ptr [bp-14h], 4 ; FCBOp,FCBREAD
		jnz	short FCBSave
		push	ds
		call	DATE16
		pop	ds
		mov	[si+14h], ax	; [SI+SYS_FCB.FDATE]
		mov	[si+16h], dx	; [SI+SYS_FCB.FTIME]

FCBSave:				; ...
		test	byte ptr [bp-14h], 8 ; FCBOp,BLOCK
		jz	short DoReturn
		mov	cx, [bp-13h]	; cRecRes
		call	Get_User_Stack
		mov	[si+4],	cx	; [SI+user_env.user_CX]

DoReturn:				; ...
		mov	al, [bp-1]	; FCBErr
		mov	sp, bp
		pop	bp
		retn

; =============== S U B	R O U T	I N E =======================================


$FCB_OPEN	proc near		; ...
		mov	ax, 2		; SHARING_COMPAT+open_for_both
		mov	cx, offset DOS_OPEN

DoAccess:				; ...
		push	ds
		push	dx
		push	cx
		push	ax
		mov	di, offset OPENBUF
		call	TransFCB
		pop	ax
		pop	cx
		pop	dx
		pop	ds
		jnb	short FindFCB

FCBOpenErr:				; ...
		jmp	FCB_RET_ER
; ---------------------------------------------------------------------------

FindFCB:				; ...
		call	GetExtended
		push	ax
		mov	al, 1
		call	LRUFCB
		pop	ax
		jb	short HardMessage
		mov	word ptr es:[di+2], 8000h ; [es:di+SF_ENTRY.sf_mode],
					; sf_isFCB
		push	ds
		push	si
		push	bx
		mov	si, cx
		push	ss
		pop	ds
		call	si
		pop	bx
		pop	si
		pop	ds
		les	di, ss:THISSFT
		jnb	short FCBOK
		push	ax
		mov	al, 'R'         ; 52h
		call	BlastSFT
		pop	ax
		cmp	ax, 4		; error_too_many_open_files
		jz	short HardMessage
		cmp	ax, 24h		; error_sharing_buffer_exceeded
		jnz	short DeadFCB

HardMessage:				; ...
		push	ax
		call	FCBHardErr
		pop	ax

DeadFCB:				; ...
		jmp	short FCBOpenErr
; ---------------------------------------------------------------------------

FCBOK:					; ...
		call	IsSFTNet
		jnz	short FCBOK2
		call	CheckShare
		jnz	short FCBOK2
		mov	word ptr ss:LocalSFT, di
		mov	word ptr ss:LocalSFT+2,	es

FCBOK2:					; ...
		inc	word ptr es:[di] ; [ES:DI+SF_ENTRY.sf_ref_count]
		call	SaveFCBInfo
		test	byte ptr es:[di+5], 80h	; [ES:DI+SF_ENTRY.sf_flags],
					; devid_device
		jnz	short FCBNoDrive
		mov	al, [si]
		call	GETTHISDRV
		inc	al
		mov	[si], al

FCBNoDrive:				; ...
		mov	word ptr [si+0Eh], 128 ; [SI+SYS_FCB.RECSIZ]
		mov	ax, es:[di+0Dh]	; [ES:DI+SF_ENTRY.sf_time]
		mov	[si+16h], ax	; [SI+SYS_FCB.FTIME]
		mov	ax, es:[di+0Fh]	; [ES:DI+SF_ENTRY.sf_date]
		mov	[si+14h], ax	; [SI+SYS_FCB.FDATE]
		mov	ax, es:[di+11h]	; [ES:DI+SF_ENTRY.sf_size]
		mov	[si+10h], ax	; [SI+SYS_FCB.FILSIZ]
		mov	ax, es:[di+13h]	; [ES:DI+SF_ENTRY.sf_size+2]
		mov	[si+12h], ax	; [SI+SYS_FCB.FILSIZ+2]
		xor	ax, ax
		mov	[si+0Ch], ax	; [SI+SYS_FCB.EXTENT]
		les	di, ss:SFTFCB
		mov	ah, es:[di+4]	; [ES:DI+SFT.SFCount]

OpenScan:				; ...
		cmp	al, [si+18h]	; [SI+fcb_sfn]
		jz	short SkipCheck
		push	ax
		call	CheckFCB
		pop	ax
		jnb	short OpenFound

SkipCheck:				; ...
		inc	al
		cmp	al, ah
		jnz	short OpenScan

OpenDone:				; ...
		xor	al, al
		retn
; ---------------------------------------------------------------------------

OpenFound:				; ...
		mov	[si+18h], al	; [SI+fcb_sfn]
		inc	word ptr es:[di] ; [ES:DI+SF_ENTRY.sf_ref_count]
		mov	ax, ss:FCBLRU
		mov	es:[di+15h], ax	; [ES:DI+sf_LRU]
		push	ss
		pop	ds
		les	di, ds:THISSFT
		dec	word ptr es:[di] ; [ES:DI+SF_ENTRY.sf_ref_count]
		call	ShareEnd
		mov	al, 'C'         ; 43h
		call	BlastSFT
		jmp	short OpenDone
$FCB_OPEN	endp

; ---------------------------------------------------------------------------

$FCB_CREATE:				; ...
		mov	cx, offset DOS_CREATE
		xor	ax, ax
		call	GetExtended
		jz	short DoAccessJ
		mov	al, [si-1]

DoAccessJ:				; ...
		jmp	DoAccess
; ---------------------------------------------------------------------------

$FCB_RANDOM_WRITE_BLOCK:		; ...
		mov	al, 0Ah		; RANDOM+BLOCK
		jmp	FCBIO
; ---------------------------------------------------------------------------

$FCB_RANDOM_READ_BLOCK:			; ...
		mov	al, 0Eh		; RANDOM+FCBREAD+BLOCK
		jmp	FCBIO
; ---------------------------------------------------------------------------

$FCB_SEQ_READ:				; ...
		mov	al, 4		; FCBREAD
		jmp	FCBIO
; ---------------------------------------------------------------------------

$FCB_SEQ_WRITE:				; ...
		mov	al, 0
		jmp	FCBIO
; ---------------------------------------------------------------------------

$FCB_RANDOM_READ:			; ...
		mov	al, 6		; RANDOM+FCBREAD
		jmp	FCBIO
; ---------------------------------------------------------------------------

$FCB_RANDOM_WRITE:			; ...
		mov	al, 2		; RANDOM
		jmp	FCBIO
; ---------------------------------------------------------------------------

$DIR_SEARCH_FIRST:			; ...
		mov	word ptr ss:THISFCB, dx
		mov	word ptr ss:THISFCB+2, ds
		mov	si, dx
		cmp	byte ptr [si], 0FFh
		jnz	short NORMFCB4
		add	si, 7

NORMFCB4:				; ...
		push	word ptr [si]
		push	ss
		pop	es
		mov	di, offset OPENBUF
		call	TransFCB
		jnb	short SearchIt
		pop	bx

dcf_errj:				; ...
		jmp	FCB_RET_ER
; ---------------------------------------------------------------------------

SearchIt:				; ...
		push	ss
		pop	ds
		push	word ptr ds:DMAADD
		push	word ptr ds:DMAADD+2
		mov	word ptr ds:DMAADD, offset SEARCHBUF
		mov	word ptr ds:DMAADD+2, ds
		call	GET_FAST_SEARCH
		pop	word ptr ds:DMAADD+2
		pop	word ptr ds:DMAADD
		jnb	short SearchSet
		pop	bx
		jmp	short dcf_errj
; ---------------------------------------------------------------------------

SearchSet:				; ...
		mov	si, offset SEARCHBUF
		les	di, ds:THISFCB
		test	ds:EXTFCB, 0FFh
		jz	short NORMFCB1
		add	di, 7

NORMFCB1:				; ...
		pop	bx
		or	bl, bl
		jnz	short SearchDrv
		mov	bl, ds:CURDRV
		inc	bl

SearchDrv:				; ...
		lodsb
		xchg	al, bl
		inc	di
		mov	cx, 10		; 20/2
		rep movsw
		xchg	al, bl
		stosb
		les	di, ds:DMAADD
		test	ds:EXTFCB, 0FFh
		jz	short NORMFCB2
		mov	al, 0FFh
		stosb
		inc	al
		mov	cx, 5
		rep stosb
		mov	al, ds:SATTRIB
		stosb

NORMFCB2:				; ...
		mov	al, bl
		stosb
		mov	cx, 16
		rep movsw
		jmp	NO_OP		; FCB_RET_OK
; ---------------------------------------------------------------------------

$DIR_SEARCH_NEXT:			; ...
		mov	word ptr ss:THISFCB, dx
		mov	word ptr ss:THISFCB+2, ds
		mov	ss:SATTRIB, 0
		mov	ss:EXTFCB, 0
		push	ss
		pop	es
		mov	di, offset SEARCHBUF
		mov	si, dx
		cmp	byte ptr [si], 0FFh
		jnz	short NORMFCB6
		add	si, 6
		lodsb
		mov	ss:SATTRIB, al
		dec	ss:EXTFCB

NORMFCB6:				; ...
		lodsb
		push	ax
		mov	al, [si+20]
		stosb
		mov	cx, 10		; 20/2
		rep movsw
		push	ss
		pop	ds
		push	word ptr ds:DMAADD
		push	word ptr ds:DMAADD+2
		mov	word ptr ds:DMAADD, offset SEARCHBUF
		mov	word ptr ds:DMAADD+2, ds
		call	DOS_SEARCH_NEXT
		pop	word ptr ds:DMAADD+2
		pop	word ptr ds:DMAADD
		jb	short SearchNoMore
		jmp	SearchSet
; ---------------------------------------------------------------------------

SearchNoMore:				; ...
		les	di, ds:THISFCB
		test	ds:EXTFCB, 0FFh
		jz	short NORMFCB8
		add	di, 7

NORMFCB8:				; ...
		pop	bx
		mov	es:[di], bl
		jmp	FCB_RET_ER
; ---------------------------------------------------------------------------

$FIND_FIRST:				; ...
		mov	si, dx
		mov	ss:SATTRIB, cl
		mov	di, offset OPENBUF
		call	TransPathSet
		jnb	short Find_it

FindError:
		mov	al, 3

FF_errj:				; ...
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

Find_it:				; ...
		push	ss
		pop	ds
		push	word ptr ds:DMAADD
		push	word ptr ds:DMAADD+2
		mov	word ptr ds:DMAADD, offset SEARCHBUF
		mov	word ptr ds:DMAADD+2, ds
		call	GET_FAST_SEARCH
		pop	word ptr ds:DMAADD+2
		pop	word ptr ds:DMAADD
		jnb	short FindSet

FFF_errj:				; ...
		jmp	short FF_errj
; ---------------------------------------------------------------------------

FindSet:				; ...
		mov	si, offset SEARCHBUF
		les	di, ds:DMAADD
		mov	cx, 21
		rep movsb
		push	si
		mov	al, [si+0Bh]	; [SI+dir_entry.dir_attr]
		stosb
		add	si, 16h		; dir_entry.dir_time
		movsw
		movsw
		inc	si
		inc	si
		movsw
		movsw
		pop	si
		call	PackName
		jmp	SYS_RETURN	; SYS_RET_OK
; ---------------------------------------------------------------------------

$FIND_NEXT:				; ...
		push	ss
		pop	es
		mov	di, offset SEARCHBUF
		lds	si, ss:DMAADD
		mov	cx, 21
		rep movsb
		push	ss
		pop	ds
		push	word ptr ds:DMAADD
		push	word ptr ds:DMAADD+2
		mov	word ptr ds:DMAADD, offset SEARCHBUF
		mov	word ptr ds:DMAADD+2, ds
		call	DOS_SEARCH_NEXT
		pop	word ptr ds:DMAADD+2
		pop	word ptr ds:DMAADD
		jnb	short FindSet
		jmp	short FFF_errj

; =============== S U B	R O U T	I N E =======================================


PackName	proc near		; ...
		mov	cx, 8
		rep movsb

main_kill_tail:				; ...
		cmp	byte ptr es:[di-1], 20h	; ' '
		jnz	short find_check_dot
		dec	di
		inc	cx
		cmp	cx, 8
		jb	short main_kill_tail

find_check_dot:				; ...
		cmp	word ptr [si], 2020h ; (" " << 8) | " "
		jnz	short got_ext
		cmp	byte ptr [si+2], 20h ; ' '
		jz	short find_done

got_ext:				; ...
		mov	al, '.'         ; 2Eh
		stosb
		mov	cx, 3
		rep movsb

ext_kill_tail:				; ...
		cmp	byte ptr es:[di-1], 20h	; ' '
		jnz	short find_done
		dec	di
		jmp	short ext_kill_tail
; ---------------------------------------------------------------------------

find_done:				; ...
		xor	ax, ax
		stosb
		retn
PackName	endp


; =============== S U B	R O U T	I N E =======================================


GET_FAST_SEARCH	proc near		; ...
		or	ss:DOS34_FLAG, 400h ; SEARCH_FASTOPEN
		call	DOS_SEARCH_FIRST
		retn
GET_FAST_SEARCH	endp

; ---------------------------------------------------------------------------

$CURRENT_DIR:				; ...
		call	ECritDisk
		mov	al, dl
		call	GetVisDrv
		jnb	short CurrentValidate

CurdirErr:				; ...
		call	LCritDisk
		push	ds
		mov	ds, cs:DosDSeg
		mov	al, ds:DrvErr
		pop	ds

curdir_errj:				; ...
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

CurrentValidate:			; ...
		push	ds
		push	si
		mov	ds, cs:DosDSeg
		lds	si, ds:THISCDS
		test	word ptr [si+43h], 8000h ; [SI+curdir.flags],
					; curdir_isnet
		jnz	short $+2

DoCheck:				; ...
		push	ds
		mov	ds, cs:DosDSeg
		mov	ds:NoSetDir, 0
		pop	ds
		mov	di, offset OPENBUF
		call	ValidateCDS
		push	es
		push	di
		pop	si
		pop	ds
		pop	di
		pop	es
		jb	short CurdirErr
		add	si, 0		; curdir.text
		add	si, [si+4Fh]	; [SI+curdir.end]
		cmp	byte ptr [si], '\' ; 5Ch
		jnz	short CurrentCopy
		inc	si

CurrentCopy:				; ...
		push	ax
		lodsb
		or	al, al
		jz	short FOK
		cmp	al, 5
		jz	short FCHANGE
		jmp	short FFF
; ---------------------------------------------------------------------------

FCPYNEXT:				; ...
		lodsb

FFF:					; ...
		cmp	al, '\'
		jnz	short FOK
		stosb
		lodsb
		cmp	al, 5
		jnz	short FOK

FCHANGE:				; ...
		mov	al, 0E5h

FOK:					; ...
		stosb
		or	al, al
		jnz	short FCPYNEXT
		pop	ax
		xor	al, al
		call	LCritDisk
		jmp	SYS_RETURN
; ---------------------------------------------------------------------------

$RMDIR:					; ...
		push	dx
		push	ds
		mov	si, dx
		mov	di, offset OPENBUF
		push	di
		call	TransPathNoSet
		pop	di
		jnb	short rmlset
		pop	ds
		pop	dx
		mov	al, 3

rmdir_errj:				; ...
		jmp	short curdir_errj
; ---------------------------------------------------------------------------

rmlset:					; ...
		cmp	ss:CMETA, 0FFh	; -1
		jnz	short rmerr
		push	ss
		pop	es
		xor	al, al

rmloop:					; ...
		call	GetCDSFromDrv
		jb	short rmcont
		call	StrCmp
		jz	short rmerr
		inc	al
		jmp	short rmloop
; ---------------------------------------------------------------------------

rmerr:					; ...
		pop	ds
		pop	dx
		mov	al, 10h		; error_current_directory

chdir_errj:				; ...
		jmp	short rmdir_errj
; ---------------------------------------------------------------------------

rmcont:					; ...
		pop	ds
		pop	dx
		mov	si, offset DOS_RMDIR
		jmp	DoDirCall
; ---------------------------------------------------------------------------

$CHDIR:					; ...
		mov	di, offset OPENBUF
		mov	si, dx
		call	TransPath
		jnb	short ChDirCrack

ChDirErrP:				; ...
		mov	al, 3		; error_path_not_found

ChDirErr:				; ...
		jmp	short chdir_errj
; ---------------------------------------------------------------------------

ChDirCrack:				; ...
		cmp	ds:CMETA, 0FFh	; -1
		jnz	short ChDirErrP
		les	di, ds:THISCDS
		cmp	di, 0FFFFh	; -1
		jz	short ChDirErrP
		call	DOS_CHDIR
		jb	short ChDirErr
		les	di, ds:THISCDS
		test	word ptr es:[di+43h], 2000h ; [ES:DI+curdir.flags],
					; curdir_splice
		jz	short GotCDS
		push	es
		push	di
		push	cx
		call	Get_User_Stack
		mov	di, [si+6]	; [SI+user_env.user_DX]
		mov	ds, word ptr [si+0Eh] ;	[SI+user_env.user_DS]
		mov	si, offset OPENBUF
		xchg	si, di
		xor	al, al
		push	di
		call	TransPathNoSet
		pop	si
		les	di, ds:THISCDS
		mov	word ptr es:[di+49h], 0FFFFh ; [ES:DI+curdir.ID]
		pop	cx
		pop	di
		pop	es

GotCDS:					; ...
		call	Check_PathLen
		ja	short ChDirErrP
		test	word ptr es:[di+43h], 8000h ; [ES:DI+curdir.flags],
					; curdir_isnet
		jnz	short SkipRecency
		test	word ptr es:[di+43h], 2000h ; [ES:DI+curdir.flags],
					; curdir_splice
		jz	short setdirclus
		mov	cx, 0FFFFh	; -1

setdirclus:				; ...
		mov	es:[di+49h], cx	; [ES:DI+curdir.ID]
		les	di, ds:THISCDS

SkipRecency:				; ...
		call	FStrCpy
		xor	al, al

mkdir_ok:				; ...
		jmp	SYS_RETURN
; ---------------------------------------------------------------------------

$MKDIR:					; ...
		mov	si, offset DOS_MKDIR

DoDirCall:				; ...
		mov	di, offset OPENBUF
		push	si
		mov	si, dx
		call	TransPath
		pop	si
		jnb	short MkDirCrack

MkErrP:					; ...
		mov	al, 3		; error_path_not_found

MkErr:					; ...
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

MkDirCrack:				; ...
		cmp	ss:CMETA, 0FFh	; -1
		jnz	short MkErrP
		push	si
		call	Check_PathLen
		pop	si
		jbe	short pathok
		mov	al, 5		; error_access_denied
		jmp	short MkErr
; ---------------------------------------------------------------------------

pathok:					; ...
		call	si
		jb	short MkErr
		jmp	short mkdir_ok

; =============== S U B	R O U T	I N E =======================================


Check_PathLen	proc near		; ...
		mov	si, ss:WFP_START

Check_PathLen2:				; ...
		push	ss
		pop	ds
		push	cx
		call	DStrLen
		cmp	cx, 67		; DIRSTRLEN
		pop	cx
		retn
Check_PathLen	endp

; ---------------------------------------------------------------------------
IOCTLJMPTABLE	dw offset ioctl_getset_data ; ...
		dw offset ioctl_getset_data
		dw offset ioctl_control_string
		dw offset ioctl_control_string
		dw offset ioctl_get_dev
		dw offset ioctl_get_dev
		dw offset ioctl_status
		dw offset ioctl_status
		dw offset ioctl_rem_media
		dw offset ioctl_drive_attr
		dw offset ioctl_handle_redir
		dw offset Set_Retry_Parameters
		dw offset GENERICIOCTLHANDLE
		dw offset GENERICIOCTL
		dw offset ioctl_drive_owner
		dw offset ioctl_drive_owner
		dw offset GENERICIOCTLHANDLE
		dw offset GENERICIOCTL

; =============== S U B	R O U T	I N E =======================================


$IOCTL		proc near		; ...

; FUNCTION CHUNK AT 628F SIZE 00000003 BYTES
; FUNCTION CHUNK AT 62DF SIZE 00000002 BYTES
; FUNCTION CHUNK AT 62E3 SIZE 00000003 BYTES
; FUNCTION CHUNK AT 62F4 SIZE 00000003 BYTES
; FUNCTION CHUNK AT 62FC SIZE 0000005E BYTES

		mov	si, ds
		push	ss
		pop	ds
		cmp	al, 11h
		ja	short ioctl_bad_funj2
		push	ax
		mov	di, ax
		and	di, 0FFh
		shl	di, 1
		pop	ax
		jmp	cs:IOCTLJMPTABLE[di]
; ---------------------------------------------------------------------------

ioctl_bad_funj2:			; ...
		jmp	ioctl_bad_fun
; ---------------------------------------------------------------------------

ioctl_getset_data:			; ...
		call	SFFromHandle
		jnb	short ioctl_check_permissions

ioctl_bad_handle:			; ...
		mov	al, 6		; error_invalid_handle

ioctl_error:				; ...
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

ioctl_check_permissions:		; ...
		cmp	al, 0
		mov	al, es:[di+5]	; [ES:DI+SF_ENTRY.sf_flags]
		jz	short ioctl_read
		or	dh, dh
		jz	short ioctl_check_device
		mov	al, 0Dh		; error_invalid_data
		jmp	short ioctl_error
; ---------------------------------------------------------------------------

ioctl_check_device:			; ...
		test	al, 80h		; devid_device
		jz	short ioctl_bad_funj2
		or	dl, 80h		; devid_device
		mov	ds:EXTERR_LOCUS, 4 ; errLOC_SerDev
		mov	es:[di+5], dl	; [ES:DI+SF_ENTRY.sf_flags]

ioctl_ok:				; ...
		jmp	SYS_RETURN	; SYS_RET_OK
; ---------------------------------------------------------------------------

ioctl_read:				; ...
		mov	ds:EXTERR_LOCUS, 2
		xor	ah, ah
		test	al, 80h		; devid_device
		jz	short ioctl_no_high
		mov	ds:EXTERR_LOCUS, 4 ; errLOC_SerDev
		les	di, es:[di+7]	; [ES:DI+SF_ENTRY.sf_devptr]
		mov	ah, es:[di+5]	; [ES:DI+SYSDEV.ATT+1]

ioctl_no_high:				; ...
		mov	dx, ax
		call	Get_User_Stack
		mov	[si+6],	dx	; [SI+user_env.user_DX]

ioctl_ok_j:				; ...
		jmp	short ioctl_ok
; ---------------------------------------------------------------------------

ioctl_control_string:			; ...
		call	SFFromHandle
		jb	short ioctl_bad_handle
		test	byte ptr es:[di+5], 80h	; [ES:DI+SF_ENTRY.sf_flags],
					; devid_device
		jz	short ioctl_bad_funj2
		mov	ds:EXTERR_LOCUS, 4 ; [EXTERR_LOCUS],errLOC_SerDev
		les	di, es:[di+7]	; [ES:DI+SF_ENTRY.sf_devptr]
		xor	bl, bl
		jmp	ioctl_do_string
; ---------------------------------------------------------------------------

ioctl_status:				; ...
		mov	ah, 1
		sub	al, 6
		jz	short ioctl_get_status
		mov	ah, 3

ioctl_get_status:			; ...
		push	ax
		call	GET_IO_SFT
		pop	ax
		jnb	short DO_IOFUNC
		jmp	short ioctl_bad_handle
; ---------------------------------------------------------------------------

DO_IOFUNC:				; ...
		call	IOFUNC
		mov	ah, al
		mov	al, 0FFh
		jnz	short ioctl_status_ret
		inc	al

ioctl_status_ret:			; ...
		jmp	short ioctl_ok_j
; ---------------------------------------------------------------------------

Set_Retry_Parameters:			; ...
		mov	ds:RetryLoop, cx
		or	dx, dx
		jz	short ioctl_bad_fun
		mov	ds:RetryCount, dx
		jmp	short ioctl_status_ret
; ---------------------------------------------------------------------------

GENERICIOCTLHANDLE:			; ...
		call	SFFromHandle
		jb	short ioctl_bad_handlej
		test	byte ptr es:[di+6], 80h	; [ES:DI+SF_ENTRY.sf_flags+1],
					; (sf_isnet>>8)
		jnz	short ioctl_bad_fun
		mov	ds:EXTERR_LOCUS, 4 ; errLOC_SerDev
		les	di, es:[di+7]	; [es:di+SF_ENTRY.sf_devptr]
		jmp	short Do_GenIOCTL
; ---------------------------------------------------------------------------

GENERICIOCTL:				; ...
		mov	ds:EXTERR_LOCUS, 2 ; errLOC_Disk
		cmp	ch, 8		; IOC_DC
		jnz	short ioctl_bad_fun
		call	Check_If_Net
		jnz	short ioctl_bad_fun

Do_GenIOCTL:				; ...
		test	byte ptr es:[di+4], 40h	; [ES:DI+SYSDEV.ATT],
					; DEV320
		jz	short ioctl_bad_fun
		mov	ds:IOCALL_REQFUNC, 13h ; GENIOCTL
		cmp	al, 10h		; IOCTL_QUERY_HANDLE
		jl	short SetIOCtlBlock
		test	byte ptr es:[di+4], 80h	; [ES:DI+SYSDEV.ATT],IOQUERY
		jz	short ioctl_bad_fun
		mov	ds:IOCALL_REQFUNC, 19h ; IOCTL_QUERY

SetIOCtlBlock:				; ...
		push	es
		push	di
		mov	ds:IOCALL_REQLEN, 17h ;	IOCTL_REQ.size
		mov	ds:IOCALL_REQUNIT, bl
		mov	ds:IOCTL_REQ_MAJORFUNCTION, ch ; [IOCALL+IOCTL_REQ.MAJORFUNCTION]
		mov	ds:IOCTL_REQ_MINORFUNCTION, cl ; [IOCALL+IOCTL_REQ.MINORFUNCTION]
		mov	word ptr ds:IOCTL_REQ_REG_SI, si ; [IOCALL+IOCTL_REQ.REG_SI]
		mov	word ptr ds:IOCTL_REQ_REG_DI, di ; [IOCALL+IOCTL_REQ.REG_DI]
		mov	ds:IOCTL_REQ_GENERICIOCTL_PACKET, dx ; [IOCALL+IOCTL_REQ.GENERICIOCTL_PACKET]
		mov	word ptr ds:IOCTL_REQ_GENERICIOCTL_PACKET_2, si	; [IOCALL+IOCTL_REQ.GENERICIOCTL_PACKET+2]
		mov	bx, offset IOCALL_REQLEN ; IOCALL
		push	ss
		pop	es
		pop	si
		pop	ds
		jmp	ioctl_do_IO
; ---------------------------------------------------------------------------

ioctl_bad_fun:				; ...
		mov	al, 1		; error_invalid_function
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

ioctl_bad_handlej:			; ...
		jmp	ioctl_bad_handle
$IOCTL		endp

; ---------------------------------------------------------------------------

ioctl_rem_media:			; ...
		call	Check_If_Net
		jnz	short ioctl_bad_fun
		test	byte ptr es:[di+5], 8 ;	[es:di+SYSDEV.ATT+1],
					; (DEVOPCL>>8)
		jz	short ioctl_bad_fun
		mov	ss:IOCALL_REQFUNC, 0Fh ; DEVRMD	; 15
		mov	al, 0Dh		; REMHL	; 13
		mov	ah, bl
		mov	word ptr ss:IOCALL_REQLEN, ax
		xor	ax, ax
		mov	word ptr ss:IOCALL_REQSTAT, ax
		push	es
		pop	ds
		mov	si, di
		push	ss
		pop	es
		mov	bx, offset IOCALL_REQLEN ; IOCALL
		push	ds
		push	si
		call	DEVIOCALL2
		pop	si
		pop	ds
		mov	ax, word ptr ss:IOCALL_REQSTAT
		and	ax, 200h	; STBUI
		mov	cl, 9
		shr	ax, cl
; START	OF FUNCTION CHUNK FOR $IOCTL

ioctl_da_ok_j:				; ...
		jmp	SYS_RETURN	; SYS_RET_OK
; END OF FUNCTION CHUNK	FOR $IOCTL
; ---------------------------------------------------------------------------

ioctl_drive_attr:			; ...
		mov	al, bl
		call	GETTHISDRV
		jb	short ioctl_drv_err
		call	Get_Driver_BL
		jb	short ioctl_drv_err
		mov	dx, es:[di+4]	; [es:di+SYSDEV.ATT]
		mov	bl, al
		les	di, ss:THISCDS
		test	byte ptr es:[di+44h], 80h ; [ES:DI+curdir.flags+1],
					; (curdir_isnet>>8)
		jz	short IOCTLShare
		mov	dx, 1000h

IOCTLShare:				; ...
		push	ss
		pop	ds
		mov	si, offset OPENBUF
		add	bl, 'A'         ; 41h
		mov	[si], bl
		mov	word ptr [si+1], 3Ah ; ':'
		mov	ax, 300h
		clc
		int	2Ah		; Microsoft Networks - CHECK DIRECT I/O
					; DS:SI	-> ASCIZ disk device name (may be full path or only drive
					; specifier--must include the colon)
					; Return: CF clear if absolute disk access allowed
		jnb	short IOCTLLocal
		or	dx, 200h

IOCTLLocal:				; ...
		test	byte ptr es:[di+44h], 10h ; [ES:DI+curdir.flags+1],
					; (curdir_local>>8)
		jz	short ioctl_set_DX
		or	dx, 8000h

ioctl_set_DX:				; ...
		call	Get_User_Stack
		mov	[si+6],	dx	; [SI+user_env.user_DX]
; START	OF FUNCTION CHUNK FOR $IOCTL

ioctl_gd_ok_j:				; ...
		jmp	short ioctl_da_ok_j
; END OF FUNCTION CHUNK	FOR $IOCTL
; ---------------------------------------------------------------------------

ioctl_drv_err:				; ...
		mov	al, 0Fh		; error_invalid_drive
; START	OF FUNCTION CHUNK FOR $IOCTL

ioctl_gd_err_j:				; ...
		jmp	SYS_RET_ERR
; END OF FUNCTION CHUNK	FOR $IOCTL
; ---------------------------------------------------------------------------

ioctl_handle_redir:			; ...
		call	SFFromHandle
		jnb	short ioctl_got_sft
		jmp	ioctl_bad_handle
; ---------------------------------------------------------------------------

ioctl_got_sft:				; ...
		mov	dx, es:[di+5]	; [ES:DI+SF_ENTRY.sf_flags]
		jmp	short ioctl_set_DX
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR $IOCTL

ioctl_bad_funj:				; ...
		jmp	ioctl_bad_fun
; END OF FUNCTION CHUNK	FOR $IOCTL
; ---------------------------------------------------------------------------

ioctl_get_dev:				; ...
		call	Check_If_Net
		jnz	short ioctl_bad_funj
; START	OF FUNCTION CHUNK FOR $IOCTL

ioctl_do_string:			; ...
		test	byte ptr es:[di+5], 40h	; [ES:DI+SYSDEV.ATT+1],
					; (DEVIOCTL>>8)
		jz	short ioctl_bad_funj
		mov	ds:IOCALL_REQFUNC, 3 ; DEVRDIOCTL
		test	al, 1
		jz	short ioctl_control_call
		mov	ds:IOCALL_REQFUNC, 12 ;	[IOCALL_REQFUNC],
					; DEVWRIOCTL

ioctl_control_call:			; ...
		mov	al, 22		; DRDWRHL
		mov	ah, bl
		mov	word ptr ds:IOCALL_REQLEN, ax
		xor	ax, ax
		mov	word ptr ds:IOCALL_REQSTAT, ax
		mov	ds:IOCTL_REQ_MAJORFUNCTION, al ; [IOMED]
		mov	word ptr ds:IOCTL_IOSCNT, cx ; [IOSCNT]
		mov	word ptr ds:IOCTL_REQ_MINORFUNCTION, dx	; [IOXAD]
		mov	word ptr ds:IOCTL_IOXAD_2, si ;	[IOXAD+2]
		push	es
		pop	ds
		mov	si, di
		push	ss
		pop	es
		mov	bx, offset IOCALL_REQLEN ; IOCALL

ioctl_do_IO:				; ...
		call	DEVIOCALL2
		test	ss:IOCALL_REQSTAT+1, 80h ; [SS:IOCALL_REQSTAT+1],
					; (STERR>>8)
		jnz	short ioctl_string_err
		mov	ax, word ptr ss:IOCTL_IOSCNT ; [SS:IOSCNT]
		jmp	short ioctl_gd_ok_j
; ---------------------------------------------------------------------------

ioctl_string_err:			; ...
		mov	di, word ptr ss:IOCALL_REQSTAT

device_err:				;
		and	di, 0FFh	; STECODE
		mov	ax, di
		call	SET_I24_EXTENDED_ERROR
		mov	ax, ss:EXTERR
		jmp	short ioctl_gd_err_j
; END OF FUNCTION CHUNK	FOR $IOCTL

; =============== S U B	R O U T	I N E =======================================


Get_Driver_BL	proc near		; ...
		push	ax
		mov	al, bl
		call	GETTHISDRV
		jb	short ioctl_bad_drv
		xor	bl, bl
		mov	ds:EXTERR_LOCUS, 3 ; errLOC_Net
		les	di, ds:THISCDS
		test	byte ptr es:[di+44h], 80h ; [ES:DI+curdir.flags+1],
					; (curdir_isnet>>8)
		les	di, es:[di+45h]	; [ES:DI+curdir.devptr]
		jnz	short got_dev_ptr
		mov	ds:EXTERR_LOCUS, 2 ; errLOC_Disk
		mov	bl, es:[di+1]	; [ES:DI+DPB.UNIT]
		les	di, es:[di+13h]	; [ES:DI+DPB.DRIVER_ADDR]

got_dev_ptr:				; ...
		clc

ioctl_bad_drv:				; ...
		pop	ax
		retn
Get_Driver_BL	endp

; ---------------------------------------------------------------------------

Check_If_Net:				; ...
		call	Get_Driver_BL
		jb	short ioctl_drv_err_pop
		push	es
		push	di
		les	di, ds:THISCDS
		test	byte ptr es:[di+44h], 80h ; [ES:DI+curdir.flags+1],
					; (curdir_isnet>>8)
		pop	di
		pop	es
		retn
; ---------------------------------------------------------------------------

ioctl_drv_err_pop:			; ...
		pop	ax
		jmp	ioctl_drv_err
; ---------------------------------------------------------------------------

ioctl_bad_funj3:			; ...
		jmp	ioctl_bad_fun
; ---------------------------------------------------------------------------

ioctl_string_errj:			; ...
		jmp	short ioctl_string_err
; ---------------------------------------------------------------------------

ioctl_drive_owner:			; ...
		call	Check_If_Net
		jnz	short ioctl_bad_funj3
		test	byte ptr es:[di+4], 40h	; [ES:DI+SYSDEV.ATT],
					; DEV320
		jz	short ioctl_bad_funj3
		mov	ds:IOCALL_REQFUNC, 23 ;	DEVGETOWN
		cmp	al, 0Eh
		jz	short GetOwner

SetOwner:				; DEVSETOWN
		mov	ds:IOCALL_REQFUNC, 24

GetOwner:				; ...
		mov	al, 13		; OWNHL
		mov	ah, bl
		mov	word ptr ds:IOCALL_REQLEN, ax
		xor	ax, ax
		mov	word ptr ds:IOCALL_REQSTAT, ax
		push	es
		pop	ds
		mov	si, di
		push	ss
		pop	es
		mov	bx, offset IOCALL_REQLEN ; IOCALL
		push	ds
		push	si
		call	DEVIOCALL2
		pop	si
		pop	ds
		test	ss:IOCALL_REQSTAT+1, 80h ; (STERR>>8)
		jnz	short ioctl_string_errj
		mov	al, ss:IOCALL_REQUNIT
		jmp	SYS_RETURN	; SYS_RET_OK

; =============== S U B	R O U T	I N E =======================================


DOS_DELETE	proc near		; ...
		call	TestNet
		jnb	short LOCAL_DELETE
		mov	ax, 1113h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - DELETE REMOTE FILE
					; SS = DS = DOS	CS, SDA	first filename pointer -> fully-qualified filename in DOS CS
					; SDA CDS pointer -> current directory structure for drive with	file
					; Return: CF set on error
		retn
; ---------------------------------------------------------------------------

LOCAL_DELETE:				; ...
		mov	ds:FOUNDDEL, 0
		call	ECritDisk
		mov	word ptr ds:CREATING, 0E500h ; DIRFREE*256+0
		mov	si, ds:WFP_START

SKPNUL:					; ...
		lodsb
		or	al, al
		jnz	short SKPNUL
		sub	si, 4
		cmp	word ptr [si], 2E2Ah ; "*."
		jnz	short TEST_QUEST
		cmp	byte ptr [si+2], '*'
		jz	short CHECK_ATTS

TEST_QUEST:				; ...
		sub	si, 9
		xchg	di, si
		push	ss
		pop	es
		mov	ax, '??'        ; 3F3Fh
		mov	cx, 4
		repe scasw
		jnz	short NOT_ALL
		xchg	di, si
		lodsw
		cmp	ax, 3F2Eh	; ".?"
		jnz	short NOT_ALL
		lodsw
		cmp	ax, '??'
		jnz	short NOT_ALL

CHECK_ATTS:				; ...
		mov	al, ds:SATTRIB
		and	al, 1Fh		; attr_hidden+attr_system+attr_directory
					; +attr_volume_id+attr_read_only
		cmp	al, 1Fh
		jnz	short NOT_ALL
		mov	ds:DELALL, 0

NOT_ALL:				; ...
		mov	ds:NoSetDir, 1
		call	GetPathNoSet
		jnb	short Del_found
		jnz	short _bad_path
		or	cl, cl
		jz	short _bad_path

No_file:				; ...
		mov	ax, 2		; error_file_not_found

ErrorReturn:				; ...
		stc
		call	LCritDisk
		retn
; ---------------------------------------------------------------------------

_bad_path:				; ...
		mov	ax, 3		; error_path_not_found
		jmp	short ErrorReturn
; ---------------------------------------------------------------------------

Del_found:				; ...
		jnz	short NOT_DIR
		cmp	ds:DELALL, 0
		jz	short NOT_DIR

Del_access_err:				; ...
		mov	ax, 5		; error_access_denied
		jmp	short ErrorReturn
; ---------------------------------------------------------------------------

NOT_DIR:				; ...
		or	ah, ah
		js	short Del_access_err

DELFILE:				; ...
		or	ds:FOUNDDEL, 1	; FILEFOUND
		push	ds
		mov	ah, ds:DELALL
		lds	di, ds:CURBUF
		test	ss:ATTRIB, 1	; attr_read_only
		jnz	short DoDelete
		test	byte ptr [bx+0Bh], 1 ; [BX+dir_entry.dir_attr],
					; attr_read_only
		jz	short DoDelete
		pop	ds
		jmp	short DELNXT
; ---------------------------------------------------------------------------

DoDelete:				; ...
		call	REN_DEL_Check
		jnb	short DEL_SHARE_OK
		pop	ds
		jmp	short DELNXT
; ---------------------------------------------------------------------------

DEL_SHARE_OK:				; ...
		test	byte ptr [di+5], 40h ; [DI+BUFFINFO.buf_flags],buf_dirty
		jnz	short yesdirty
		call	INC_DIRTY_COUNT
		or	byte ptr [di+5], 40h

yesdirty:				; ...
		mov	[bx], ah	; [BX+dir_entry.dir_name]
		mov	bx, [si]
		pop	ds
		or	ds:FOUNDDEL, 10h ; FILEDELETED
		cmp	bx, 2
		jb	short DELNXT
		cmp	bx, es:[bp+0Dh]	; [ES:BP+DPB.MAX_CLUSTER]
		ja	short DELNXT
		call	RELEASE
		jb	short No_fileJ
		call	FastOpen_Delete

DELNXT:					; ...
		les	bp, ds:THISDPB
		call	GETENTRY
		jb	short No_fileJ
		call	NEXTENT
		jnb	short DELFILE
		les	bp, ds:THISDPB
		mov	al, es:[bp+0]
		call	FLUSHBUF
		jb	short No_fileJ
		test	ds:FOUNDDEL, 10h ; FILEDELETED
		jz	short DelError
		test	ds:ATTRIB, 8	; attr_volume_id
		jz	short No_Set_Flag
		push	ax
		push	es
		push	di
		les	di, ds:THISCDS
		mov	ah, es:[di]
		sub	ah, 'A'
		mov	ds:VOLCHNG_FLAG, ah
		xor	bh, bh
		call	Set_Media_ID
		call	FATREAD_CDS
		pop	di
		pop	es
		pop	ax

No_Set_Flag:				; ...
		call	LCritDisk
		retn
; ---------------------------------------------------------------------------

DelError:				; ...
		test	ds:FOUNDDEL, 1	; FILEFOUND
		jnz	short Del_access_errJ

No_fileJ:				; ...
		jmp	No_file
; ---------------------------------------------------------------------------

Del_access_errJ:			; ...
		jmp	Del_access_err
DOS_DELETE	endp


; =============== S U B	R O U T	I N E =======================================


REN_DEL_Check	proc near		; ...
		push	ds
		push	di
		push	ax
		push	bx
		push	si
		push	ss
		pop	es
		mov	di, ss:WFP_START
		mov	si, bx
		mov	ds, word ptr ss:CURBUF+2
		mov	bx, di
		add	bx, 2
		call	StrLen
		dec	cx
		add	di, cx
		call	SkipBack
		inc	di
		mov	ss:SAVE_BX, di
		call	PackName
		pop	si
		pop	bx
		push	bx
		push	si
		push	ss
		pop	ds
		call	dword ptr ds:ShCloseFile ; Call	far [JShare+(13*4)]
		mov	word ptr ds:THISSFT+2, ds
		mov	word ptr ds:THISSFT, 765h ; AUXSTACK-SF_ENTRY.size
		xor	ah, ah
		call	DOOPEN
		les	di, ds:THISSFT
		mov	word ptr es:[di+2], 10h	; [ES:DI+SF_ENTRY.sf_mode],
					; SHARING_DENY_BOTH
		mov	word ptr es:[di], 1 ; [ES:DI+SF_ENTRY.sf_ref_count]
		call	ShareEnter
		jb	short CheckDone
		les	di, ds:THISSFT
		mov	word ptr es:[di], 0
		call	ShareEnd
		clc

CheckDone:				; ...
		les	bp, ds:THISDPB
		pop	si
		pop	bx
		pop	ax
		pop	di
		pop	ds
		retn
REN_DEL_Check	endp

; ---------------------------------------------------------------------------

FastOpen_Delete:			; ...
		pushf
		push	si
		push	bx
		push	ax
		mov	si, ss:WFP_START
		mov	al, 3		; FONC_delete
; START	OF FUNCTION CHUNK FOR FastOpen_Update

fastinvoke:				; ...
		mov	bx, offset FastOpenTable_2 ; FastTable+2
		call	dword ptr [bx]	; CALL far [BX]
		pop	ax
		pop	bx
		pop	si
		popf
		retn
; END OF FUNCTION CHUNK	FOR FastOpen_Update

; =============== S U B	R O U T	I N E =======================================


FastOpen_Rename	proc near		; ...
		pushf
		push	si
		push	di
		push	bx
		push	ax
		mov	si, ss:REN_WFP
		mov	di, offset NAME1
		mov	al, 6		; FONC_Rename
		mov	bx, offset FastOpenTable_2
		call	dword ptr [bx]	; CALL far [BX]
		pop	ax
		pop	bx
		pop	di
		pop	si
		popf
		retn
FastOpen_Rename	endp


; =============== S U B	R O U T	I N E =======================================


FastOpen_Update	proc near		; ...

; FUNCTION CHUNK AT 6596 SIZE 0000000A BYTES

		pushf
		push	si
		push	bx
		push	ax
		mov	al, 4		; FONC_update
		jmp	short fastinvoke
FastOpen_Update	endp


; =============== S U B	R O U T	I N E =======================================


Fast_Dispatch	proc near		; ...
		mov	si, offset FastOpenTable_2 ; FastTable+2
		call	dword ptr ss:[si] ; CALL far [SS:SI]
		retn
Fast_Dispatch	endp


; =============== S U B	R O U T	I N E =======================================


DOS_RENAME	proc near		; ...
		call	TestNet
		jnb	short LOCAL_RENAME
		mov	ax, 1111h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - RENAME REMOTE FILE
					; SS = DS = DOS	CS, SDA	first filename pointer = offset	of fully-qualified old name
					; SDA CDS pointer -> current directory
					; Return: CF set on error
		retn
; ---------------------------------------------------------------------------

LOCAL_RENAME:				; ...
		mov	ds:EXTERR_LOCUS, 2 ; errLOC_Disk
		mov	si, ds:WFP_START
		mov	di, ds:REN_WFP
		mov	al, [si]
		mov	ah, [di]
		or	ax, 2020h	; Lower	case
		cmp	al, ah
		jz	short SAMEDRV
		mov	ax, 11h		; error_not_same_device
		stc
		retn
; ---------------------------------------------------------------------------

SAMEDRV:				; ...
		push	word ptr ds:DMAADD+2
		push	word ptr ds:DMAADD
		mov	word ptr ds:DMAADD+2, ds
		mov	word ptr ds:DMAADD, offset RENAMEDMA
		mov	ds:FOUND_DEV, 0
		call	ECritDisk
		call	DOS_SEARCH_FIRST
		jnb	short Check_Dev
		cmp	ax, 12h		; error_no_more_files
		jnz	short GOTERR
		mov	ax, 2		; error_file_not_found

GOTERR:					; ...
		stc

RENAME_POP:				; ...
		pop	word ptr ds:DMAADD
		pop	word ptr ds:DMAADD+2
		call	LCritDisk
		retn
; ---------------------------------------------------------------------------

Check_Dev:				; ...
		mov	ax, 5		; error_access_denied
		push	ds
		lds	si, ds:DMAADD
		add	si, 21		; find_buf.attr
		test	byte ptr [si+11], 10h ;	[SI+dir_entry.dir_attr],
					; attr_directory
		jz	short notdir
		mov	si, ds:REN_WFP
		call	Check_PathLen2

notdir:					; ...
		pop	ds
		ja	short GOTERR
		cmp	ds:FOUND_DEV, 0
		jnz	short GOTERR
		mov	si, bx
		add	si, 26		; dir_entry.dir_first
		call	REN_DEL_Check
		jnb	short REN_OK1
		mov	ax, 20h		; error_sharing_violation
		jmp	short RENAME_POP
; ---------------------------------------------------------------------------

REN_OK1:				; ...
		push	si
		lds	si, ds:DMAADD
		add	si, 21
		test	byte ptr [si+11], 10h ;	[SI+dir_entry.dir_attr],
					; attr_directory
		jz	short NOT_DIR1
		pop	si
		jmp	short SWAP_SOURCE
; ---------------------------------------------------------------------------

NOT_DIR1:				; ...
		pop	si
		call	FastOpen_Delete

SWAP_SOURCE:				; ...
		mov	ax, ds:WFP_START
		mov	si, ds:REN_WFP
		mov	ds:WFP_START, si
		mov	ds:REN_WFP, ax
		mov	ds:CURR_DIR_END, 0FFFFh	; -1
		mov	word ptr ds:CREATING, 0E5FFh ; DIRFREE*256+0FFh
		call	GetPathNoSet
		jb	short NODEST
		or	ah, ah
		jns	short SAVEDEST

BAD_ACC:				; ...
		mov	ax, 5		; error_access_denied
		stc

RENAME_CLEAN:				; ...
		pushf
		push	ax
		mov	al, ds:THISDRV
		call	FLUSHBUF
		pop	ax
		cmp	ds:FAILERR, 0
		jnz	short BAD_ERR
		popf
		jmp	RENAME_POP
; ---------------------------------------------------------------------------

BAD_ERR:				; ...
		pop	ax

_BAD_PATH:				; error_path_not_found
		mov	ax, 3
		jmp	GOTERR
; ---------------------------------------------------------------------------

NODEST:					; ...
		jnz	short BAD_PATH
		cmp	ds:FAILERR, 0
		jnz	short BAD_PATH
		or	cl, cl
		jnz	short SAVEDEST

BAD_PATH:				; ...
		mov	ax, 3		; error_path_not_found
		stc
		jmp	RENAME_POP
; ---------------------------------------------------------------------------

SAVEDEST:				; ...
		push	ss
		pop	es
		mov	di, offset NAME2
		mov	si, offset NAME1
		mov	cx, 11
		rep movsb
		mov	ax, ds:DIRSTART
		mov	ds:DESTSTART, ax

BUILDDEST:				; ...
		push	ss
		pop	es
		mov	bx, (offset RENAMEDMA+15h) ; RENAMEDMA+21
		mov	di, offset NAME1
		mov	si, offset NAME2
		mov	cx, 11
		call	NEW_RENAME
		mov	ds:ATTRIB, 16h	; attr_all
		mov	ds:CREATING, 0FFh
		call	DEVNAME
		jnb	short BAD_ACC
		mov	bx, ds:DESTSTART
		les	bp, ds:THISDPB
		call	SETDIRSRCH
		jb	short BAD_ACC
		call	FINDENTRY
		jnb	short BAD_ACC
		cmp	ds:FAILERR, 0
		jnz	short BAD_ACCJ
		mov	ax, ds:DESTSTART
		cmp	ax, word ptr ds:RENAMEDMA+0Fh ;	[RENAMEDMA+15]
		jz	short SIMPLE_RENAME
		mov	al, ds:RENAMEDMA+20h ; [RENAMEDMA+32]
					; [RENAMEDMA+21+dir_entry.dir_attr]
		test	al, 10h		; attr_directory
		jnz	short BAD_ACCJ
		mov	ds:ATTRIB, al
		mov	word ptr ds:THISSFT+2, ds
		mov	si, (offset RENAMEDMA+145h) ; [RENAMEDMA+325]
					; AUXSTACK-SF_ENTRY.size
		mov	word ptr ds:THISSFT, si
		mov	word ptr [si+2], 2 ; [SI+SF_ENTRY.sf_mode],
					; SHARING_COMPAT+open_for_both
		xor	cx, cx
		call	RENAME_MAKE
		jnb	short GOT_DEST

BAD_ACCJ:				; ...
		jmp	BAD_ACC
; ---------------------------------------------------------------------------

GOT_DEST:				; ...
		push	bx
		les	di, ds:THISSFT
		call	ShareEnd
		pop	bx
		les	di, ds:CURBUF
		test	byte ptr es:[di+5], 40h	; [ES:DI+BUFFINFO.buf_flags],
					; buf_dirty
		jnz	short yesdirty1
		call	INC_DIRTY_COUNT
		or	byte ptr es:[di+5], 40h	; [ES:DI+BUFFINFO.buf_flags],
					; buf_dirty

yesdirty1:				; ...
		mov	di, bx
		add	di, 11		; dir_entry.dir_attr
		mov	si, (offset RENAMEDMA+20h)
		mov	cx, 21		; dir_entry.size-dir_entry.dir_attr
		rep movsb
		call	GET_SOURCE
		jb	short RENAME_OVER
		mov	di, bx
		mov	es, word ptr ds:CURBUF+2
		mov	al, 0E5h	; DIRFREE
		stosb
		jmp	short DIRTY_IT
; ---------------------------------------------------------------------------

SIMPLE_RENAME:				; ...
		call	GET_SOURCE
		jb	short RENAME_OVER
		mov	di, bx
		mov	es, word ptr ds:CURBUF+2
		mov	si, offset NAME1
		mov	cx, 11
		rep movsb

DIRTY_IT:				; ...
		mov	di, word ptr ds:CURBUF
		test	byte ptr es:[di+5], 40h	; [ES:DI+BUFFINFO.buf_flags],
					; buf_dirty
		jnz	short yesdirty2
		call	INC_DIRTY_COUNT
		or	byte ptr es:[di+5], 40h	; [ES:DI+BUFFINFO.buf_flags],
					; buf_dirty

yesdirty2:				; ...
		push	si
		lds	si, ds:DMAADD
		add	si, 21		; find_buf.attr
		test	byte ptr [si+11], 10h ;	[SI+dir_entry.dir_attr],
					; attr_directory
		jz	short NOT_DIR2
		call	FastOpen_Rename
		pop	si
		jmp	short NOT_DIRTY1
; ---------------------------------------------------------------------------

NOT_DIR2:				; ...
		pop	si

NOT_DIRTY1:				; ...
		mov	si, (offset RENAMEDMA+1)
		call	ECritDisk
		mov	ds:CREATING, 0
		call	RENAME_NEXT
		jb	short RENAME_OVER
		lea	si, [bx+26]	; [BX+dir_entry.dir_first]
		call	REN_DEL_Check
		jnb	short REN_OK2
		mov	ax, 20h		; error_sharing_violation
		jmp	RENAME_CLEAN
; ---------------------------------------------------------------------------

REN_OK2:				; ...
		mov	al, ds:RENAMEDMA+20h ; [RENAMEDMA+21+dir_entry.dir_attr]
		test	al, 10h		; attr_directory
		jz	short Ren_Directory
		call	FastOpen_Delete
		jmp	BUILDDEST
; ---------------------------------------------------------------------------

Ren_Directory:				; ...
		call	FastOpen_Rename
		jmp	BUILDDEST
; ---------------------------------------------------------------------------

RENAME_OVER:				; ...
		clc
		jmp	RENAME_CLEAN
DOS_RENAME	endp


; =============== S U B	R O U T	I N E =======================================


GET_SOURCE	proc near		; ...
		mov	bx, word ptr ds:RENAMEDMA+0Fh
		les	bp, ds:THISDPB
		call	SETDIRSRCH
		jb	short gs_ret_label
		call	STARTSRCH
		mov	ax, word ptr ds:RENAMEDMA+0Dh
		call	GETENT

gs_ret_label:				; ...
		retn
GET_SOURCE	endp


; =============== S U B	R O U T	I N E =======================================


NEW_RENAME	proc near		; ...
		lodsb
		cmp	al, '?'         ; 3Fh
		jnz	short NOCHG
		mov	al, [bx]

NOCHG:					; ...
		stosb
		inc	bx
		loop	NEW_RENAME
		retn
NEW_RENAME	endp


; =============== S U B	R O U T	I N E =======================================


GET_FILE_INFO	proc near		; ...
		call	TestNet
		jnb	short LOCAL_INFO
		mov	ax, 110Fh	; (MultNET SHL 8) OR 15
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - GET REMOTE FILE'S ATTRIBUTES
					; SS = DOS CS, SDA first filename pointer -> fully-qualified name of file
					; SDA CDS pointer -> current directory
					; Return: CF set on error, AX =	file attributes
		retn
; ---------------------------------------------------------------------------

LOCAL_INFO:				; ...
		call	ECritDisk
		mov	ds:NoSetDir, 1
		call	GET_FAST_PATH
		jnb	short info_check_dev

NO_PATH:				; ...
		jnz	short bad_path1
		or	cl, cl
		jz	short bad_path1

info_no_file:				; ...
		mov	ax, 2		; error_file_not_found

BadRet:					; ...
		stc

JustRet:				; ...
		call	LCritDisk
		retn
; ---------------------------------------------------------------------------

bad_path1:				; ...
		mov	ax, 3		; error_path_not_found
		jmp	short BadRet
; ---------------------------------------------------------------------------

info_check_dev:				; ...
		or	ah, ah
		js	short info_no_file
		cmp	word ptr ds:CURBUF, 0FFFFh ; -1
		jnz	short not_root
		xor	ah, ah
		mov	al, 10h		; attr_directory
		clc
		jmp	short JustRet
; ---------------------------------------------------------------------------

not_root:				; ...
		push	ds
		mov	ds, word ptr ds:CURBUF+2
		mov	si, bx
		xor	bx, bx
		mov	di, bx
		mov	cx, [si+16h]	; [SI+dir_entry.dir_time]
		mov	dx, [si+18h]	; [SI+dir_entry.dir_date]
		xor	ah, ah
		mov	al, [si+0Bh]	; [SI+dir_entry.dir_attr]
		test	al, 10h		; attr_directory
		jnz	short NO_SIZE
		mov	di, [si+1Ch]	; [SI+dir_entry.dir_size_l]
		mov	bx, [si+1Eh]	; [SI+dir_entry.dir_size_h]

NO_SIZE:				; ...
		pop	ds
		clc
		jmp	short JustRet
GET_FILE_INFO	endp


; =============== S U B	R O U T	I N E =======================================


SET_FILE_ATTRIBUTE proc	near		; ...
		test	ax, 0FFD8h	; ~attr_changeable
		jz	short set_look

_BAD_ACC:				; ...
		mov	ds:EXTERR_LOCUS, 1 ; errLOC_Unk
		mov	ds:EXTERR_CLASS, 7 ; errCLASS_Apperr
		mov	ds:EXTERR_ACTION, 4 ; errACT_Abort
		mov	ax, 5		; error_access_denied
		stc
		retn
; ---------------------------------------------------------------------------

set_look:				; ...
		call	TestNet
		jnb	short LOCAL_SET
		push	ax
		mov	ax, 110Eh	; (MultNET SHL 8) OR 14
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - SET REMOTE FILE'S ATTRIBUTES
					; SS = DOS CS, SDA first filename pointer -> fully-qualified name of file
					; SDA CDS pointer -> current directory
					; STACK: WORD new file attributes
					; Return: CF set on error
		pop	bx
		retn
; ---------------------------------------------------------------------------

LOCAL_SET:				; ...
		call	ECritDisk
		push	ax
		mov	ds:NoSetDir, 1
		call	GETPATH
		jnb	short set_check_device
		pop	bx
		jmp	short NO_PATH
; ---------------------------------------------------------------------------

set_check_device:			; ...
		or	ah, ah
		jns	short set_check_share
		pop	ax
		call	LCritDisk
		jmp	short _BAD_ACC
; ---------------------------------------------------------------------------

set_check_share:			; ...
		pop	ax
		cmp	word ptr ds:CURBUF, -1 ; 0FFFFh
		jz	short cannot_set_root
		call	REN_DEL_Check
		jnb	short set_do
		mov	ax, 20h		; error_sharing_violation
		jmp	short OK_BYE
; ---------------------------------------------------------------------------

cannot_set_root:			; ...
		mov	ax, 5		; error_access_denied
		stc
		jmp	short OK_BYE
; ---------------------------------------------------------------------------

set_do:					; ...
		les	di, ds:CURBUF
		and	byte ptr es:[bx+0Bh], 0D8h ; [ES:BX+dir_entry.dir_attr],~attr_changeable
		or	es:[bx+0Bh], al	; [ES:BX+dir_entry.dir_attr]
		test	byte ptr es:[di+5], 40h	; [ES:DI+BUFFINFO.buf_flags],buf_dirty
		jnz	short yesdirty3
		call	INC_DIRTY_COUNT
		or	byte ptr es:[di+5], 40h	; [ES:DI+BUFFINFO.buf_flags],buf_dirty

yesdirty3:				; ...
		mov	al, ds:THISDRV
		push	dx
		push	di
		mov	ah, 0
		mov	dl, al
		mov	di, bx
		call	FastOpen_Update
		pop	di
		pop	dx
		call	FLUSHBUF
		jnb	short OK_BYE
		mov	ax, 2		; error_file_not_found

OK_BYE:					; ...
		call	LCritDisk
		retn
SET_FILE_ATTRIBUTE endp


; =============== S U B	R O U T	I N E =======================================


GET_FAST_PATH	proc near		; ...
		or	ss:FastOpenFlg,	1 ; FastOpen_Set
		call	GETPATH
		pushf
		and	ss:FastOpenFlg,	80h ; Fast_yes
		popf
		retn
GET_FAST_PATH	endp


; =============== S U B	R O U T	I N E =======================================


DOS_DUP		proc near		; ...
		mov	es, cs:DosDSeg
		les	di, es:THISSFT

DOS_Dup_Direct:				; ...
		call	IsSFTNet
		jnz	short DO_INC
		call	DEV_OPEN_SFT

DO_INC:					; ...
		inc	word ptr es:[di] ; [ES:DI+SF_ENTRY.sf_ref_count]
		retn
DOS_DUP		endp

; ---------------------------------------------------------------------------

DOS_CREATE:				; ...
		xor	ah, ah

Create_inter:				; ...
		test	al, 80h		; ~(attr_all+attr_ignore+attr_volume_id)
		jnz	short AttErr
		test	al, 8		; attr_volume_id
		jz	short NoReset
		or	ds:DOS34_FLAG, 80h ; DBCS_VOLID
		mov	al, 8		; attr_volume_id

NoReset:				; ...
		or	al, 20h		; attr_archive
		test	al, 50h		; attr_directory+attr_device
		jz	short ATT_OK

AttErr:					; ...
		mov	ax, 5		; Attribute problem
		mov	ds:EXTERR_LOCUS, 1 ; errLOC_Unk
		jmp	short SET_MKND_ERR
; ---------------------------------------------------------------------------

ATT_OK:					; ...
		les	di, ds:THISSFT
		push	es
		les	si, ds:THISCDS
		cmp	si, -1		; 0FFFFh
		jnz	short TEST_RE_NET
		pop	es
		test	ds:EXTOPEN_ON, 1 ; EXT_OPEN_ON
		jz	short NOEXTOP

IFS_extopen:				; ...
		push	ax
		mov	ax, 112Eh	; (MultNET SHL 8) OR 46
		int	2Fh		; Multiplex - DOS 4 IFSFUNC.EXE	- ???
					; SS = DS = DOS	CS, STACK: WORD	???   low byte = ???
					; Return: CF set on error
					; CF clear if successful
		pop	bx
		mov	ds:EXTOPEN_ON, 0
		retn
; ---------------------------------------------------------------------------

NOEXTOP:				; ...
		push	ax
		mov	ax, 1118h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - CREATE/TRUNCATE FILE
					; ES:DI	-> uninitialized SFT, SS = DOS CS
					; SDA first filename pointer ->	fully-qualified	name of	file
					; STACK: WORD file creation mode???
		pop	bx
		retn
; ---------------------------------------------------------------------------

TEST_RE_NET:				; ...
		test	word ptr es:[si+43h], 8000h ; [ES:SI+curdir.flags],
					; curdir_isnet
		pop	es
		jz	short LOCAL_CREATE
		call	Set_EXT_mode
		jb	short dochk
		or	word ptr es:[di+2], 2 ;	[ES:DI+SF_ENTRY.sf_mode],
					; SHARING_COMPAT+open_for_both

dochk:					; ...
		test	ds:EXTOPEN_ON, 1
		jnz	short IFS_extopen
		push	ax
		mov	ax, 1117h	; (MultNET SHL 8) OR 23
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - CREATE/TRUNCATE REMOTE FILE
					; ES:DI	-> uninitialized SFT, SS = DOS CS
					; SDA first filename pointer ->	fully-qualified	name of	file to	open
					; SDA CDS pointer -> current directory
					; Return: CF set on error
		pop	bx
		retn
; ---------------------------------------------------------------------------

LOCAL_CREATE:				; ...
		call	Set_EXT_mode
		jb	short setdone
		or	word ptr es:[di+2], 2 ;	[ES:DI+SF_ENTRY.sf_mode],
					; SHARING_COMPAT+open_for_both

setdone:				; ...
		call	ECritDisk
		call	MakeNode
		jnb	short Create_ok
		mov	ds:VOLCHNG_FLAG, 0FFh ;	-1
		call	LCritDisk

SET_MKND_ERR:				; ...
		mov	bx, offset CRTERRTAB
		xlat	byte ptr cs:[bx] ; CS XLAT
		stc
		retn
; ---------------------------------------------------------------------------
CRTERRTAB	db 0			; ...
		db 5			; error_access_denied
		db 52h			; error_cannot_make
		db 50h			; error_file_exists
		db 3			; error_path_not_found
		db 5			; error_access_denied
		db 20h			; error_sharing_violation
		db 2			; error_file_not_found
; ---------------------------------------------------------------------------

Create_ok:				; ...
		call	FastOpen_Delete
		mov	al, ds:SATTRIB
		test	al, 8		; attr_volume_id
		jz	short NoVolLabel
		les	di, ds:THISCDS
		mov	ah, es:[di]	; [ES:DI+curdir.text]
		sub	ah, 'A'         ; 41h
		mov	ds:VOLCHNG_FLAG, ah
		mov	bh, 1
		call	Set_Media_ID
		call	ECritDisk
		call	FATREAD_CDS
		call	LCritDisk

NoVolLabel:				; ...
		mov	ax, 2
		les	di, ds:THISSFT
		call	dword ptr ds:ShSU ; call far [JShare+(14*4)]
		call	LCritDisk
		jmp	SET_SFT_MODE
; ---------------------------------------------------------------------------

DOS_Create_New:				; ...
		mov	ah, 1
		jmp	Create_inter

; =============== S U B	R O U T	I N E =======================================


Set_Media_ID	proc near		; ...
		push	ax
		push	es
		push	di
		inc	ah
		mov	bl, ah
		mov	al, 0Dh		; generic IOCTL
		mov	cx, 866h	; get media id
		mov	dx, offset FAKE_STACK_2F ; Packet_Temp
		push	bx
		push	dx
		xor	bh, bh
		call	$IOCTL
		pop	dx
		pop	bx
		jb	short geterr
		or	bh, bh
		jz	short NoName	; delete volume	id
		mov	si, offset NAME1 ; set volume id
		jmp	short doset
; ---------------------------------------------------------------------------

NoName:					; ...
		mov	si, offset NO_NAME_ID ;	"NO NAME    "

doset:					; ...
		mov	di, dx
		add	di, 6		; MEDIA_ID_INFO.MEDIA_Label
		push	ss
		pop	ds
		push	ss
		pop	es
		mov	cx, 11
		rep movsb
		mov	cx, 846h	; set volume id
		mov	al, 0Dh
		xor	bh, bh
		call	$IOCTL

geterr:					; ...
		push	ss
		pop	ds
		pop	di
		pop	es
		pop	ax
		retn
Set_Media_ID	endp


; =============== S U B	R O U T	I N E =======================================


Set_EXT_mode	proc near		; ...
		test	ss:EXTOPEN_ON, 1 ; [ss:EXTOPEN_ON],EXT_OPEN_ON
		jz	short NOTEX
		push	ax
		mov	ax, ss:SAVE_BX
		or	es:[di+2], ax	; [ES:DI+SF_ENTRY.sf_mode]
		pop	ax
		stc

NOTEX:					; ...
		retn
Set_EXT_mode	endp

; ---------------------------------------------------------------------------

DOS_OPEN:				; ...
		mov	ds:NoSetDir, 0
		call	Check_Access_AX
		jb	short do_ret_label
		les	di, ds:THISSFT
		xor	ah, ah
		mov	es:[di+2], al	; [ES:DI+SF_ENTRY.sf_mode]
		push	es
		les	si, ds:THISCDS
		cmp	si, -1
		jnz	short TEST_RE_NET1
		pop	es
		test	ds:EXTOPEN_ON, 1 ; EXT_OPEN_ON
		jz	short _NOEXTOP

_IFS_extopen:				; ...
		mov	al, byte ptr ds:SAVE_BX
		push	ax
		mov	ax, 112Eh	; (MultNET*256)+46
		int	2Fh		; Multiplex - DOS 4 IFSFUNC.EXE	- ???
					; SS = DS = DOS	CS, STACK: WORD	???   low byte = ???
					; Return: CF set on error
					; CF clear if successful
		pop	bx
		mov	ds:EXTOPEN_ON, 0

do_ret_label:				; ...
		retn
; ---------------------------------------------------------------------------

_NOEXTOP:				; ...
		test	ds:DOS_FLAG, 1	; EXECOPEN
		jz	short not_exec_open
		test	byte ptr ds:DOS34_FLAG+1, 8 ; (EXEC_AWARE_REDIR>>8)
		jz	short not_exec_open
		mov	al, 23h		; SHARING_DENY_WRITE+EXEC_OPEN

not_exec_open:				; ...
		push	ax
		mov	ax, 1116h	; (MultNET SHL 8) OR 22
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - OPEN	EXISTING REMOTE	FILE
					; ES:DI	-> uninitialized SFT, SS = DOS CS
					; SDA first filename pointer ->	fully-qualified	name of	file to	open
					; STACK: WORD file open	mode
					; Return: CF set on error
		pop	bx
		retn
; ---------------------------------------------------------------------------

TEST_RE_NET1:				; ...
		test	word ptr es:[si+43h], 8000h ; [ES:SI+curdir.flags],
					; curdir_isnet
		pop	es
		jz	short LOCAL_OPEN
		test	ds:EXTOPEN_ON, 1
		jnz	short _IFS_extopen
		jmp	short _NOEXTOP
; ---------------------------------------------------------------------------

LOCAL_OPEN:				; ...
		call	ECritDisk
		or	ds:FastOpenFlg,	5 ; FastOpen_Set+Special_Fill_Set
		call	GETPATH
		jnb	short Open_found
		jnz	short bad_path2
		or	cl, cl
		jz	short bad_path2
		mov	ax, 2		; error_file_not_found

OpenBadRet:				; ...
		and	ss:FastOpenFlg,	80h ; Fast_yes
		stc
		call	LCritDisk
		jmp	Clear_FastOpen
; ---------------------------------------------------------------------------

bad_path2:				; ...
		mov	ax, 3		; error_path_not_found
		jmp	short OpenBadRet
; ---------------------------------------------------------------------------

Open_Bad_Access:			; ...
		mov	ax, 5		; error_access_denied
		jmp	short OpenBadRet
; ---------------------------------------------------------------------------

Open_found:				; ...
		jz	short Open_Bad_Access
		or	ah, ah
		js	short open_ok
		mov	es, word ptr ds:CURBUF+2
		mov	al, es:[bx+0Bh]	; [ES:BX+dir_entry.dir_attr]
		test	al, 8		; attr_volume_id
		jnz	short Open_Bad_Access
		test	al, 1		; attr_read_only
		jz	short open_ok
		push	ds
		push	si
		lds	si, ds:THISSFT
		mov	cx, [si+2]	; [SI+SF_ENTRY.sf_mode]
		test	cx, 8000h	; sf_isFCB
		jnz	short ResetAccess
		mov	dl, cl
		and	dl, 0F0h	; SHARING_MASK
		cmp	dl, 70h		; SHARING_NET_FCB
		jnz	short NormalOpen

ResetAccess:				; ...
		and	cx, 0FFF0h	; ~access_mask
		mov	[si+2],	cx	; [SI+SF_ENTRY.sf_mode]
		jmp	short FillSFT
; ---------------------------------------------------------------------------

NormalOpen:				; ...
		and	cl, 0Fh		; access_mask
		cmp	cl, 0		; open_for_read
		jz	short FillSFT
		pop	si
		pop	ds
		jmp	short Open_Bad_Access
; ---------------------------------------------------------------------------

FillSFT:				; ...
		pop	si
		pop	ds

open_ok:				; ...
		call	DOOPEN
		and	ss:FastOpenFlg,	80h ; Fast_yes
		call	DO_SHARE_CHECK
		jnb	short SHARE_OK
		call	LCritDisk
		jmp	short Clear_FastOpen
; ---------------------------------------------------------------------------

SHARE_OK:				; ...
		mov	ax, 3
		les	di, ds:THISSFT
		call	dword ptr ds:ShSU ; call far [JShare+(14*4)]
		call	LCritDisk

SET_SFT_MODE:				; ...
		les	di, ds:THISSFT
		call	DEV_OPEN_SFT
		test	word ptr es:[di+2], 8000h ; ES:DI+SF_ENTRY.sf_mode],
					; sf_isFCB
		jz	short Clear_FastOpen
		mov	ax, ds:CurrentPDB
		mov	es:[di+31h], ax	; [ES:DI+SF_ENTRY.sf_PID]

Clear_FastOpen:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================


SHARE_ERROR	proc near		; ...
		test	word ptr es:[di+2], 8000h ; [ES:DI+SF_ENTRY.sf_mode],
					; sf_isFCB
		jnz	short _HARD_ERR
		mov	cl, es:[di+2]	; [ES:DI+SF_ENTRY.sf_mode]
		and	cl, 0F0h	; SHARING_MASK
		cmp	cl, 0		; SHARING_COMPAT
		jnz	short _NO_HARD_ERR

_HARD_ERR:				; ...
		call	SHARE_VIOLATION
		jnb	short Clear_FastOpen

_NO_HARD_ERR:				; ...
		mov	ax, 20h		; error_sharing_violation
		stc
		retn
SHARE_ERROR	endp


; =============== S U B	R O U T	I N E =======================================


DO_SHARE_CHECK	proc near		; ...
		call	ECritDisk

OPN_RETRY:				; ...
		mov	cx, ds:RetryCount

OpenShareRetry:				; ...
		push	cx
		call	SHARE_CHECK
		pop	cx
		jnb	short Share_Ok2
		call	Idle
		loop	OpenShareRetry
		les	di, ds:THISSFT
		call	SHARE_ERROR
		jnb	short OPN_RETRY

Share_Ok2:				; ...
		call	LCritDisk
		retn
DO_SHARE_CHECK	endp


; =============== S U B	R O U T	I N E =======================================


Check_Access_AX	proc near		; ...
		mov	ds:OPEN_ACCESS,	al
		push	bx
		mov	bl, al
		and	bl, 0F0h	; SHARING_MASK
		cmp	ds:FSHARING, -1
		jnz	short CheckShareMode
		cmp	bl, 70h		; SHARING_NET_FCB
		jz	short CheckAccessMode

CheckShareMode:				; ...
		cmp	bl, 40h
		ja	short Make_Bad_Access

CheckAccessMode:			; ...
		mov	bl, al
		and	bl, 0Fh		; access_mask
		cmp	bl, 2
		ja	short Make_Bad_Access
		pop	bx
		clc
		retn
; ---------------------------------------------------------------------------

Make_Bad_Access:			; ...
		mov	ax, 0Ch		; error_invalid_access
		pop	bx
		stc
		retn
Check_Access_AX	endp


; =============== S U B	R O U T	I N E =======================================


DISK_INFO	proc near		; ...
		call	TestNet
		jnb	short LOCAL_DSK_INFO
		mov	ax, 110Ch
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - GET DISK SPACE
					; ES:DI	-> current directory
					; Return: AL = sectors per cluster, BX = total clusters
					; CX = bytes per sector, DX = number of	available clusters
		retn
; ---------------------------------------------------------------------------

LOCAL_DSK_INFO:				; ...
		mov	ds:EXTERR_LOCUS, 2 ; errLOC_Disk
		call	ECritDisk
		call	FATREAD_CDS
		jb	short CRIT_LEAVE
		mov	bx, 2
		call	UNPACK
		jb	short CRIT_LEAVE
		lds	si, ds:CURBUF
		mov	ah, [si+14h]	; [SI+BUFINSIZ]
		push	ss
		pop	ds
		mov	cx, es:[bp+0Dh]	; [ES:BP+DPB.MAX_CLUSTER]
		mov	dx, es:[bp+1Fh]	; [ES:BP+DPB.FREE_CNT]
		cmp	dx, -1		; 0FFFFh
		jz	short DoScan
		cmp	dx, cx
		jb	short GotVal

DoScan:					; ...
		xor	dx, dx
		dec	cx

SCANFREE:				; ...
		call	UNPACK
		jb	short CRIT_LEAVE
		jnz	short NOTFREECLUS
		inc	dx

NOTFREECLUS:				; ...
		inc	bx
		loop	SCANFREE
		dec	bx

ReturnVals:				; ...
		dec	bx
		mov	al, es:[bp+4]	; [ES:BP+DPB.CLUSTER_MASK]
		inc	al
		mov	cx, es:[bp+2]	; [ES:BP+DPB.SECTOR_SIZE]
		mov	es:[bp+1Fh], dx	; [ES:BP+DPB.FREE_CNT]
		clc

CRIT_LEAVE:				; ...
		call	LCritDisk
		retn
; ---------------------------------------------------------------------------

GotVal:					; ...
		mov	bx, cx
		jmp	short ReturnVals
DISK_INFO	endp


; =============== S U B	R O U T	I N E =======================================


DOS_SEARCH_FIRST proc near		; ...
		les	di, ds:THISCDS
		cmp	di, 0FFFFh	; -1
		jnz	short TEST_RE_NET2
		mov	ax, 1119h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - ???
		retn
; ---------------------------------------------------------------------------

TEST_RE_NET2:				; ...
		test	word ptr es:[di+43h], 8000h ; [ES:DI+curdir.flags],
					; curdir_isnet
		jz	short LOCAL_SEARCH_FIRST
		mov	ax, 111Bh	; (MultNET<<8)|27
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - FINDFIRST
					; SS = DS = DOS	CS, [DTA] = uninitialized 21-byte findfirst search data
					; SDA first filename pointer ->	fully-qualified	search template
					; SDA CDS pointer -> current directory
					; Return: CF set on error
		retn
; ---------------------------------------------------------------------------

LOCAL_SEARCH_FIRST:			; ...
		call	ECritDisk
		test	ds:DOS34_FLAG, 400h ; SEARCH_FASTOPEN
		jz	short NOFN
		or	ds:FastOpenFlg,	1 ; FastOpen_Set

NOFN:					; ...
		mov	ds:NoSetDir, 1
		call	CHECK_QUESTION
		jnb	short norm_GETPATH
		and	ds:FastOpenFlg,	80h ; Fast_yes

norm_GETPATH:				; ...
		call	GETPATH
		jnb	short find_check_dev
		jnz	short bad_path3
		or	cl, cl
		jz	short bad_path3

find_no_more:				; ...
		mov	ax, 12h		; error_no_more_files

BadBye:					; ...
		and	ss:FastOpenFlg,	80h ; Fast_yes
		stc
		call	LCritDisk
		retn
; ---------------------------------------------------------------------------

bad_path3:				; ...
		mov	ax, 3
		jmp	short BadBye
; ---------------------------------------------------------------------------

find_check_dev:				; ...
		or	ah, ah
		jns	short found_entry
		mov	ds:LASTENT, 0FFFFh ; -1
		inc	ds:FOUND_DEV

found_entry:				; ...
		les	di, ds:DMAADD
		mov	si, ds:WFP_START
		lodsb
		sub	al, 40h		; 'A'-1
		stosb

found_it:				; ...
		les	di, ds:DMAADD
		inc	di
		push	ds
		test	ds:FastOpenFlg,	10h ; Set_For_Search
		jz	short notfast
		mov	si, bx
		mov	ds, word ptr ds:CURBUF+2
		jmp	short movmov
; ---------------------------------------------------------------------------

notfast:				; ...
		mov	si, offset NAME1

movmov:					; ...
		movsb
		cmp	byte ptr es:[di-1], 5
		jnz	short NOTKANJB
		mov	byte ptr es:[di-1], 0E5h

NOTKANJB:				; ...
		mov	cx, 10
		rep movsb
		pop	ds
		mov	al, ds:ATTRIB
		stosb
		push	ax
		mov	ax, ds:LASTENT
		stosw
		mov	ax, ds:DIRSTART
		stosw
		add	di, 4
		pop	ax
		or	ah, ah
		js	short DOSREL
		cmp	word ptr ds:CURBUF, -1 ; 0FFFFh
		jnz	short OKSTORE
		test	ds:FastOpenFlg,	10h ; Set_For_Search
		jnz	short OKSTORE
		mov	word ptr es:[di-8], 0FFFFh ; -1
		jmp	find_no_more
; ---------------------------------------------------------------------------

OKSTORE:				; ...
		mov	ds, word ptr ds:CURBUF+2

DOSREL:					; ...
		mov	si, bx
		mov	cx, 32		; dir_entry.size
		mov	ax, di
		rep movsb
		mov	di, ax
		cmp	byte ptr es:[di], 5
		jnz	short NO05
		mov	byte ptr es:[di], 0E5h

NO05:					; ...
		and	ss:FastOpenFlg,	80h ; Fast_yes
		push	ss
		pop	ds
		clc
		call	LCritDisk
		retn
DOS_SEARCH_FIRST endp


; =============== S U B	R O U T	I N E =======================================


DOS_SEARCH_NEXT	proc near		; ...
		les	di, ds:DMAADD
		mov	al, es:[di]
		test	al, 80h
		jz	short LOCAL_SEARCH_NEXT
		mov	ax, 111Ch
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - FINDNEXT
					; SS = DS = DOS	CS, [DTA] = 21-byte findfirst search data
					; Return: CF set on error, AX =	DOS error code
					; CF clear if successful
		retn
; ---------------------------------------------------------------------------

LOCAL_SEARCH_NEXT:			; ...
		mov	ds:EXTERR_LOCUS, 2 ; errLOC_Disk
		call	ECritDisk
		mov	word ptr ds:THISCDS, offset DUMMYCDS
		mov	word ptr ds:THISCDS+2, ds
		add	al, 40h		; 'A'-1
		call	InitCDS
		jb	short No_files
		les	di, ds:THISCDS
		les	bp, es:[di+45h]	; [ES:DI+curdir.devptr]
		call	GOTDPB
		mov	al, es:[bp+0]	; [ES:BP+DPB.DRIVE]
		mov	ds:THISDRV, al
		mov	word ptr ds:CREATING, 0E500h ; (DIRFREE*256)+0
		mov	ds:NoSetDir, 1
		lds	si, ds:DMAADD
		lodsb

RENAME_NEXT:				; ...
		push	ss
		pop	es
		mov	di, offset NAME1
		mov	cx, 11
		rep movsb
		lodsb
		mov	ss:ATTRIB, al
		lodsw
		or	ax, ax
		jns	short cont_load

No_files:				; ...
		jmp	find_no_more
; ---------------------------------------------------------------------------

cont_load:				; ...
		push	ax
		lodsw
		mov	bx, ax
		push	ss
		pop	ds
		les	bp, ds:THISDPB
		call	SETDIRSRCH
		jnb	short SEARCH_GOON
		pop	ax
		jmp	short No_files
; ---------------------------------------------------------------------------

SEARCH_GOON:				; ...
		call	STARTSRCH
		pop	ax
		call	GETENT
		jb	short No_files
		call	NEXTENT
		jb	short No_files
		xor	ah, ah
		jmp	found_it
DOS_SEARCH_NEXT	endp


; =============== S U B	R O U T	I N E =======================================


CHECK_QUESTION	proc near		; ...
		push	ss
		pop	ds
		mov	si, ss:WFP_START

getnext:				; ...
		lodsb
		or	al, al
		jz	short NO_Question
		cmp	al, '?'
		jnz	short getnext
		stc

NO_Question:				; ...
		retn
CHECK_QUESTION	endp


; =============== S U B	R O U T	I N E =======================================


DOS_ABORT	proc near		; ...
		mov	es, ss:CurrentPDB
		mov	cx, es:32h	; [ES:PDB.JFN_Length]

reset_free_jfn:				; ...
		mov	bx, cx
		push	cx
		dec	bx
		call	$CLOSE
		pop	cx
		loop	reset_free_jfn
		push	ss
		pop	ds
		mov	ax, 111Dh	; Net_Abort, MultNET, 29
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - CLOSE ALL REMOTE FILES FOR PROCESS
					; DS???, SS = DOS CS
		call	dword ptr ds:MFTCloseP ; call far [JShare+(4*4)]
		les	di, ss:SFTFCB
		mov	cx, es:[di+4]	; [es:di+SFT.SFCount]
		jcxz	short FCBScanDone
		lea	di, [di+6]	; [DI+SFT.SFTable]
		mov	ax, ss:PROC_ID

FCBTest:				; ...
		cmp	es:[di+31h], ax	; [es:di+SF_ENTRY.sf_PID]
		jnz	short FCBNext
		mov	word ptr es:[di], 0 ; [es:di+SF_ENTRY.sf_ref_count]

FCBNext:				; ...
		add	di, 3Bh	; ';'
		loop	FCBTest

FCBScanDone:				; ...
		xor	bx, bx

Scan:					; ...
		push	bx
		call	SFFromSFN
		pop	bx
		jnb	short Scan1
		retn
; ---------------------------------------------------------------------------

Scan1:					; ...
		cmp	word ptr es:[di], 0FFFFh ; [es:di+SF_ENTRY.sf_ref_count],
					; sf_busy
		jnz	short scan_next
		mov	ax, ss:PROC_ID
		cmp	es:[di+31h], ax	; [es:di+SF_ENTRY.sf_PID]
		jnz	short scan_next
		mov	ax, ss:USER_ID
		cmp	es:[di+2Fh], ax	; [es:di+SF_ENTRY.sf_UID]
		jnz	short scan_next
		mov	word ptr es:[di], 0 ; [es:di+SF_ENTRY.sf_ref_count]

scan_next:				; ...
		inc	bx
		jmp	short Scan
DOS_ABORT	endp


; =============== S U B	R O U T	I N E =======================================


DOS_CLOSE	proc near		; ...
		les	di, ds:THISSFT
		mov	bx, es:[di+5]	; [ES:DI+SF_ENTRY.sf_flags]
		test	bx, 8000h	; sf_isnet
		jz	short LocalClose
		mov	ax, 1106h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - CLOSE REMOTE	FILE
					; ES:DI	-> SFT
					; SFT DPB field	-> DPB of drive	containing file
					; Return: CF set on error, AX =	DOS error code
					; CF clear if successful
		retn
; ---------------------------------------------------------------------------

LocalClose:				; ...
		call	ECritDisk
		call	SetSFTTimes
		call	FREE_SFT
		push	ss
		pop	ds
		push	ax
		push	bx
		call	ShareEnd
		pop	bx
		pop	ax

CloseEntry:				; ...
		push	ax
		test	bx, 0C0h	; devid_file_clean+devid_device
		jz	short rdir
		jmp	FREE_SFT_OK
; ---------------------------------------------------------------------------

rdir:					; ...
		call	DirFromSFT
		mov	al, 5		; error_access_denied
		jnb	short clook
		jmp	CloseFinish
; ---------------------------------------------------------------------------

clook:					; ...
		push	di
		push	si
		lea	si, [si+20h]	; [SI+SF_ENTRY.sf_name]
		call	XCHGP
		call	MetaCompare
		call	XCHGP
		pop	si
		pop	di
		jz	short CLOSE_GO
		mov	di, si
		push	ds
		pop	es
		push	ss
		pop	ds
		stc
		mov	al, 2
		jmp	CloseFinish
; ---------------------------------------------------------------------------

CLOSE_GO:				; ...
		test	word ptr [si+2], 8000h ; [SI+SF_ENTRY.sf_mode],
					; sf_isFCB
		jz	short nofcb
		mov	ch, es:[di+0Bh]	; [ES:DI+dir_entry.dir_attr]
		mov	al, [si+4]	; [SI+SF_ENTRY.sf_attr]
		mov	ss:ATTRIB, al
		jmp	short setattr
; ---------------------------------------------------------------------------

nofcb:					; ...
		mov	al, [si+4]	; [SI+SF_ENTRY.sf_attr]
		mov	es:[di+0Bh], al	; [ES:DI+dir_entry.dir_attr]

setattr:				; ...
		or	byte ptr es:[di+0Bh], 20h ; [ES:DI+dir_entry.dir_attr],
					; attr_archive
		mov	ax, es:[di+1Ah]	; [ES:DI+dir_entry.dir_first]
		mov	ss:OLD_FIRSTCLUS, ax
		mov	ax, [si+0Bh]	; [SI+SF_ENTRY.sf_firclus]
		mov	es:[di+1Ah], ax	; [ES:DI+dir_entry.dir_first]
		mov	ax, [si+11h]	; [SI+SF_ENTRY.sf_size]
		mov	es:[di+1Ch], ax	; [ES:DI+dir_entry.dir_size_l]
		mov	ax, [si+13h]	; [SI+SF_ENTRY.sf_size+2]
		mov	es:[di+1Eh], ax	; [ES:DI+dir_entry.dir_size_h]
		mov	ax, [si+0Fh]	; [SI+SF_ENTRY.sf_date]
		mov	es:[di+18h], ax	; [ES:DI+dir_entry.dir_date]
		mov	ax, [si+0Dh]	; [SI+SF_ENTRY.sf_time]
		mov	es:[di+16h], ax	; [ES:DI+dir_entry.dir_time]
		test	byte ptr es:[bx+5], 40h	; [ES:BX+BUFFINFO.buf_flags],
					; buf_dirty
		jnz	short yesdirty4
		call	INC_DIRTY_COUNT
		or	byte ptr es:[bx+5], 40h	; [ES:BX+BUFFINFO.buf_flags],
					; buf_dirty

yesdirty4:				; ...
		push	ds
		push	si
		mov	cx, [si+0Bh]	; [SF_ENTRY.sf_firclus]
		mov	al, ss:THISDRV
		push	dx
		mov	ah, 0
		mov	dl, al
		or	cx, cx
		jnz	short do_update2
		mov	ah, 3
		mov	di, [si+1Bh]	; [SI+SF_ENTRY.sf_dirsec]
		mov	cx, [si+1Dh]	; [SI+SF_ENTRY.sf_dirsec+2]
		mov	dh, [si+1Fh]	; [SI+SF_ENTRY.sf_dirpos]
		jmp	short do_update
; ---------------------------------------------------------------------------

do_update2:				; ...
		cmp	cx, ss:OLD_FIRSTCLUS
		jz	short do_update
		mov	ah, 2
		mov	cx, ss:OLD_FIRSTCLUS

do_update:				; ...
		push	ss
		pop	ds
		call	FastOpen_Update
		pop	dx
		call	FLUSHBUF
		pop	di
		pop	es
		mov	al, 5		; error_access_denied
		jb	short CloseFinish

FREE_SFT_OK:				; ...
		clc

CloseFinish:				; ...
		pushf
		call	DEV_CLOSE_SFT
		popf
		pop	cx
		pushf
		dec	cx
		jnz	short NoFree
		mov	es:[di], cx	; [ES:DI+SF_ENTRY.sf_ref_Count]

NoFree:					; ...
		call	LCritDisk
		popf
		retn
DOS_CLOSE	endp


; =============== S U B	R O U T	I N E =======================================


FREE_SFT	proc near		; ...
		pushf
		mov	ax, es:[di]	; [ES:DI+SF_ENTRY.sf_ref_count]
		dec	ax
		jnz	short SetCount
		dec	ax

SetCount:				; ...
		xchg	ax, es:[di]	; [ES:DI+SF_ENTRY.sf_ref_count]
		popf
		retn
FREE_SFT	endp


; =============== S U B	R O U T	I N E =======================================


DirFromSFT	proc near		; ...
		mov	ds:EXTERR_LOCUS, 2 ; errLOC_Disk
		push	es
		push	di
		mov	dx, es:[di+1Dh]	; [ES:DI+SF_ENTRY.sf_dirsec+2]
		mov	ds:HIGH_SECTOR,	dx
		mov	dx, es:[di+1Bh]	; [ES:DI+SF_ENTRY.sf_dirsec]
		push	ds:HIGH_SECTOR
		push	dx
		call	FATREAD_SFT
		pop	dx
		pop	ds:HIGH_SECTOR
		jb	short PopDone
		xor	al, al
		mov	ds:ALLOWED, 18h	; Allowed_FAIL+Allowed_RETRY
		call	GETBUFFR
		jb	short PopDone
		pop	si
		pop	ds
		les	di, ss:5E2h
		or	byte ptr es:[di+5], 4
		mov	bx, di
		lea	di, [di+14h]
		mov	al, 20h	; ' '
		mul	byte ptr [si+1Fh]
		add	di, ax
		retn
; ---------------------------------------------------------------------------

PopDone:				; ...
		pop	di
		pop	es

PopDone_retn:				; ...
		retn
DirFromSFT	endp


; =============== S U B	R O U T	I N E =======================================


DOS_COMMIT	proc near		; ...
		les	di, ds:THISSFT
		mov	bx, es:[di+5]	; [ES:DI+SF_ENTRY.sf_flags]
		test	bx, 0C0h	; devid_file_clean+devid_device
		jnz	short PopDone_retn
		test	bx, 8000h	; sf_isnet
		jz	short LOCAL_COMMIT
		mov	ax, 1107h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - COMMIT REMOTE FILE
					; ES:DI	-> SFT
					; SFT DPB field	-> DPB of drive	containing file
					; Return: CF set on error, AX =	DOS error code
					; CF clear if successful
		retn
; ---------------------------------------------------------------------------

LOCAL_COMMIT:				; ...
		call	ECritDisk
		call	ECritDisk
		call	SetSFTTimes
		mov	ax, -1
		call	CloseEntry
		pushf
		call	DEV_OPEN_SFT
		popf
		call	LCritDisk

localcommit_retn:			; ...
		retn
DOS_COMMIT	endp


; =============== S U B	R O U T	I N E =======================================


SetSFTTimes	proc near		; ...
		test	bx, 0C0h	; devid_file_clean+devid_device
		jnz	short localcommit_retn
		test	bx, 4000h	; sf_close_nodate
		jnz	short localcommit_retn
		push	ax
		push	bx
		call	DATE16
		mov	es:[di+0Fh], ax	; [ES:DI+SF_ENTRY.sf_date]
		mov	es:[di+0Dh], dx	; [ES:DI+SF_ENTRY.sf_time]
		xor	ax, ax
		call	dword ptr ds:ShSU ; call far [JShare+(14*4)]
		pop	bx
		pop	ax
		retn
SetSFTTimes	endp

; ---------------------------------------------------------------------------

DOS_MKDIR:				; ...
		call	TestNet
		jnb	short LOCAL_MKDIR
		mov	ax, 1103h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - MAKE	REMOTE DIRECTORY
					; SS = DOS CS
					; SDA first filename pointer ->	fully-qualified	directory name
					; SDA CDS pointer -> current directory
					; Return: CF set on error, AX =	DOS error code
					; CF clear if successful
		retn
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR DOS_CHDIR

NODEACCERRJ:				; ...
		mov	ax, 5		; error_access_denied

_BadRet:				; ...
		stc
		call	LCritDisk
		retn
; END OF FUNCTION CHUNK	FOR DOS_CHDIR
; ---------------------------------------------------------------------------

PATHNFJ:				; ...
		call	LCritDisk
		jmp	SET_MKND_ERR
; ---------------------------------------------------------------------------

LOCAL_MKDIR:				; ...
		call	ECritDisk
		mov	word ptr ds:THISSFT+2, ss
		mov	word ptr ds:THISSFT, offset RENBUF
		mov	word ptr ds:RENBUF+33h,	0 ; [RENBUF+SF_ENTRY.sf_MFT]
		mov	al, 10h		; attr_directory
		call	MakeNode
		jb	short PATHNFJ
		cmp	ax, 3
		jz	short NODEACCERRJ
		les	bp, ds:THISDPB
		lds	di, ds:CURBUF
		sub	si, di
		push	si
		push	word ptr [di+8]	; [DI+BUFFINFO.buf_sector+2]
		push	word ptr [di+6]	; [DI+BUFFINFO.buf_sector]
		push	ss
		pop	ds
		push	ds:DIRSTART
		xor	ax, ax
		mov	ds:DIRSTART, ax
		call	NEWDIR
		jb	short NODEEXISTSPOPDEL
		call	GETENT
		jb	short NODEEXISTSPOPDEL
		les	di, ds:CURBUF
		test	byte ptr es:[di+5], 40h	; [ES:DI+BUFFINFO.buf_flags],
					; buf_dirty
		jnz	short yesdirty5
		call	INC_DIRTY_COUNT
		or	byte ptr es:[di+5], 40h	; [ES:DI+BUFFINFO.buf_flags],buf_dirty

yesdirty5:				; ...
		add	di, 20		; BUFINSIZ
		mov	ax, 202Eh	; ". "
		mov	dx, ds:DIRSTART
		call	SETDOTENT
		mov	ax, 2E2Eh	; ".."
		pop	dx
		call	SETDOTENT
		les	bp, ds:THISDPB
		mov	ds:ALLOWED, 18h	; Allowed_FAIL+Allowed_RETRY
		pop	dx
		pop	ds:HIGH_SECTOR
		xor	al, al
		call	GETBUFFR
		jb	short NODEEXISTSP
		mov	dx, ds:5C2h
		lds	di, ds:5E2h
		or	byte ptr [di+5], 4
		pop	si
		add	si, di
		mov	[si], dx
		xor	dx, dx
		mov	[si+2],	dx
		mov	[si+4],	dx

; =============== S U B	R O U T	I N E =======================================


DIRUP		proc near		; ...
		test	byte ptr [di+5], 40h ; [DI+BUFFINFO.buf_flags],buf_dirty
		jnz	short yesdirty6
		call	INC_DIRTY_COUNT
		or	byte ptr [di+5], 40h ; [DI+BUFFINFO.buf_flags],buf_dirty

yesdirty6:				; ...
		push	ss
		pop	ds
		mov	al, es:[bp+0]
		call	FLUSHBUF
		mov	ax, 5
		call	LCritDisk
		retn
DIRUP		endp

; ---------------------------------------------------------------------------

NODEEXISTSPOPDEL:			; ...
		pop	dx
		pop	dx
		pop	ds:HIGH_SECTOR
		les	bp, ds:THISDPB
		mov	ds:ALLOWED, 18h	; Allowed_FAIL+Allowed_RETRY
		xor	al, al
		call	GETBUFFR
		jb	short NODEEXISTSP
		lds	di, ds:5E2h
		or	byte ptr [di+5], 4
		pop	si
		add	si, di
		sub	si, 1Ah
		mov	byte ptr [si], 0E5h ; 'å'
		call	DIRUP

NODEEXISTS:				; ...
		jmp	NODEACCERRJ
; ---------------------------------------------------------------------------

NODEEXISTSP:				; ...
		pop	si
		jmp	short NODEEXISTS

; =============== S U B	R O U T	I N E =======================================


DOS_CHDIR	proc near		; ...

arg_7E		= byte ptr  80h

; FUNCTION CHUNK AT 6FD1 SIZE 00000008 BYTES
; FUNCTION CHUNK AT 713D SIZE 00000003 BYTES

		call	TestNet
		jnb	short LOCAL_CHDIR
		mov	ax, 1105h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - CHDIR
					; SS = DOS CS
					; SDA first filename pointer ->	fully-qualified	directory name
					; SDA CDS pointer -> current directory
					; Return: CF set on error, AX =	DOS error code
					; CF clear if successful
		retn
; ---------------------------------------------------------------------------

LOCAL_CHDIR:				; ...
		call	ECritDisk
		test	word ptr es:[di+43h], 2000h ; [ES:DI+curdir.flags],curdir_splice
		jz	short nojoin
		mov	word ptr es:[di+49h], 0FFFFh ; [ES:DI+curdir.ID]

nojoin:					; ...
		mov	ds:NoSetDir, 0
		mov	ds:SATTRIB, 16h	; attr_directory+attr_system+attr_hidden
		or	ds:FastOpenFlg,	1 ; FastOpen_Set
		call	GETPATH
		pushf
		and	ds:FastOpenFlg,	80h ; Fast_yes
		popf
		mov	ax, 3		; error_path_not_found
		jb	short ChDirDone
		jnz	short NOTDIRPATH
		mov	cx, ds:DIRSTART
		clc

ChDirDone:				; ...
		call	LCritDisk
		retn
DOS_CHDIR	endp

; ---------------------------------------------------------------------------

DOS_RMDIR:				; ...
		call	TestNet
		jnb	short LOCAL_RMDIR
		mov	ax, 1101h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - REMOVE REMOTE DIRECTORY
					; SS = DOS CS
					; SDA first filename pointer ->	fully-qualified	directory name
					; SDA CDS pointer -> current directory
					; Return: CF set on error, AX =	DOS error code
					; CF clear if successful
		retn
; ---------------------------------------------------------------------------

LOCAL_RMDIR:				; ...
		call	ECritDisk
		mov	ds:NoSetDir, 0
		mov	ds:SATTRIB, 16h	; attr_directory+attr_system+attr_hidden
		call	GETPATH
		jb	short NOPATH
		jnz	short NOTDIRPATH
		mov	di, ds:DIRSTART
		or	di, di
		jnz	short rmdir_get_buf
		jmp	short NOTDIRPATH
; ---------------------------------------------------------------------------

NOPATH:					; ...
		mov	ax, 3		; error_path_not_found
		jmp	_BadRet
; ---------------------------------------------------------------------------

NOTDIRPATHPOP:				; ...
		pop	ax
		pop	ax

NOTDIRPATHPOP2:				; ...
		pop	ax
; START	OF FUNCTION CHUNK FOR DOS_CHDIR

NOTDIRPATH:				; ...
		jmp	NODEACCERRJ
; END OF FUNCTION CHUNK	FOR DOS_CHDIR
; ---------------------------------------------------------------------------

rmdir_get_buf:				; ...
		lds	di, ds:CURBUF
		sub	bx, di
		push	bx
		push	word ptr [di+8]	; [DI+BUFFINFO.buf_sector+2]
		push	word ptr [di+6]	; [DI+BUFFINFO.buf_sector]
		push	ss
		pop	ds
		push	ss
		pop	es
		mov	di, offset NAME1
		mov	al, '?'
		mov	cx, 11
		rep stosb
		xor	al, al
		stosb
		call	STARTSRCH
		call	GETENTRY
		jb	short NOTDIRPATHPOP
		mov	ds, word ptr ds:CURBUF+2
		mov	si, bx
		lodsw
		cmp	ax, 202Eh	; (' ' SHL 8) OR '.'
		jnz	short NOTDIRPATHPOP
		add	si, 30		; dir_entry.size-2
		lodsw
		cmp	ax, 2E2Eh	; ('.' SHL 8) OR '.'
		jnz	short NOTDIRPATHPOP
		push	ss
		pop	ds
		mov	ds:LASTENT, 2
		call	GETENTRY
		jb	short NOTDIRPATHPOP
		mov	ds:ATTRIB, 16h	; attr_directory+attr_hidden+attr_system
		call	SRCH
		jnb	short NOTDIRPATHPOP
		cmp	ds:FAILERR, 0
		jnz	short NOTDIRPATHPOP
		les	bp, ds:THISDPB
		mov	bx, ds:DIRSTART
		call	RELEASE
		jb	short NOTDIRPATHPOP
		pop	dx
		pop	ds:HIGH_SECTOR
		mov	ds:ALLOWED, 18h	; Allowed_FAIL+Allowed_RETRY
		xor	al, al
		call	GETBUFFR
		jb	short NOTDIRPATHPOP2
		lds	di, ds:5E2h
		or	byte ptr [di+5], 4
		pop	bx
		add	bx, di
		mov	byte ptr [bx], 0E5h ; 'å'
		push	ds
		push	ss
		pop	ds
		call	FastOpen_Delete
		pop	ds
		jmp	DIRUP

; =============== S U B	R O U T	I N E =======================================


SWAPBACK	proc near		; ...
		mov	ds:CONSWAP, 0
		retn
SWAPBACK	endp


; =============== S U B	R O U T	I N E =======================================


SWAPCON		proc near		; ...
		mov	ds:CONSWAP, 1
		push	ax
		mov	ax, word ptr ds:THISSFT
		mov	word ptr ds:CONSFT, ax
		mov	ax, word ptr ds:THISSFT+2
		mov	word ptr ds:CONSFT+2, ax
		pop	ax
		retn
SWAPCON		endp


; =============== S U B	R O U T	I N E =======================================


DOS_READ	proc near		; ...
		les	di, ds:THISSFT
		mov	al, es:[di+2]	; [ES:DI+SF_ENTRY.sf_mode]
		and	al, 0Fh		; access_mask
		cmp	al, 1
		jnz	short READ_NO_MODE
		jmp	SET_ACC_ERR
; ---------------------------------------------------------------------------

READ_NO_MODE:				; ...
		call	SETUP
		jcxz	short NoIORet
		call	IsSFTNet
		jz	short LOCAL_READ
		mov	ax, 1108h	; (MultNET<<8)|8
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - READ	FROM REMOTE FILE
					; ES:DI	-> SFT
					; SFT DPB field	-> DPB of drive	containing file
					; CX = number of bytes,	SS = DOS CS, SDA DTA field -> user buffer
					; Return: CF set on error, CX =	bytes read
		retn
; ---------------------------------------------------------------------------

NoIORet:				; ...
		clc
		retn
; ---------------------------------------------------------------------------

LOCAL_READ:				; ...
		test	byte ptr es:[di+5], 80h	; [ES:DI+SF_ENTRY.sf_flags],devid_device
		jnz	short READDEV
		mov	ds:EXTERR_LOCUS, 2 ; errLOC_Disk
		call	ECritDisk
		call	DISKREAD
		call	LCritDisk
		retn
; ---------------------------------------------------------------------------

READDEV:				; ...
		mov	ds:EXTERR_LOCUS, 4 ; errLOC_SerDev
		mov	bl, es:[di+5]	; [ES:DI+SF_ENTRY.sf_flags]
		les	di, ds:DMAADD
		test	bl, 40h		; devid_device_EOF
		jz	short ENDRDDEVJ3
		test	bl, 4		; devid_device_null
		jz	short TESTRAW
		xor	al, al

ENDRDDEVJ3:				; ...
		jmp	ENDRDDEVJ2
; ---------------------------------------------------------------------------

TESTRAW:				; ...
		test	bl, 20h		; devid_device_raw
		jnz	short DVRDRAW
		test	bl, 1
		jz	short NOTRDCON
		jmp	READCON
; ---------------------------------------------------------------------------

DVRDRAW:				; ...
		push	es
		pop	ds
		test	ss:IsWin386, 1
		jz	short ReadRawRetry
		test	bl, 1		; devid_device_con_in
		jz	short ReadRawRetry
		jmp	do_polling
; ---------------------------------------------------------------------------

ReadRawRetry:				; ...
		mov	bx, di
		xor	ax, ax
		mov	dx, ax
		call	SETREAD
		push	ds
		lds	si, ss:THISSFT
		call	DEVIOCALL
		mov	dx, di
		mov	ah, 86h
		mov	di, ss:DEVCALL_REQSTAT
		or	di, di
		jns	short CRDROK
		call	CHARHARD
		mov	di, dx
		add	di, ss:CALLSCNT
		sub	cx, ss:CALLSCNT
		or	al, al
		jz	short CRDROK
		cmp	al, 3
		jz	short CRDFERR
		pop	ds
		jmp	short ReadRawRetry
; ---------------------------------------------------------------------------

CRDFERR:				; ...
		pop	di

DEVIOFERR:				; ...
		les	di, ss:THISSFT
		jmp	SET_ACC_ERR_DS
; ---------------------------------------------------------------------------

CRDROK:					; ...
		pop	di
		mov	di, dx
		add	di, ss:CALLSCNT
		jmp	short ENDRDDEVJ3
; ---------------------------------------------------------------------------

NOTRDCON:				; ...
		mov	ax, es
		mov	ds, ax
		mov	bx, di
		xor	dx, dx
		mov	ax, dx
		push	cx
		mov	cx, 1
		call	SETREAD
		pop	cx
		lds	si, ss:THISSFT
		lds	si, [si+7]	; [SI+SF_ENTRY.sf_devptr]

DVRDLP:					; ...
		call	DSKSTATCHK
		call	DEVIOCALL2
		push	di
		mov	ah, 86h
		mov	di, ss:DEVCALL_REQSTAT
		or	di, di
		jns	short CRDOK
		call	CHARHARD
		pop	di
		mov	ss:CALLSCNT, 1
		cmp	al, 1
		jz	short DVRDLP
		cmp	al, 3
		jz	short DEVIOFERR
		xor	al, al
		jmp	short DVRDIGN
; ---------------------------------------------------------------------------

CRDOK:					; ...
		pop	di
		cmp	ss:CALLSCNT, 1
		jnz	short ENDRDDEVJ2
		push	ds
		mov	ds, word ptr ss:CALLXADD+2
		mov	al, [di]
		pop	ds

DVRDIGN:				; ...
		inc	word ptr ss:CALLXADD
		mov	ss:DEVCALL_REQSTAT, 0
		inc	di
		cmp	al, 1Ah		; ^Z?
		jz	short ENDRDDEVJ2
		cmp	al, 0Dh		; c_CR
		loopne	DVRDLP
		inc	ax

ENDRDDEVJ2:				; ...
		jmp	ENDRDDEV
; ---------------------------------------------------------------------------

do_polling:				; ...
		mov	bx, di
		xor	ax, ax
		mov	dx, ax
		call	SETREAD

do_io:					; ...
		mov	byte ptr es:[bx+2], 5 ;	DEVRDND
		push	ds
		lds	si, ss:THISSFT
		call	DEVIOCALL
		pop	ds
		test	word ptr es:[bx+3], 8000h ; [es:bx+SRHEAD.REQSTAT],STERR
		jz	short check_busy
		push	ds
		mov	dx, di
		call	CHARHARD
		mov	di, dx
		or	al, al
		jz	short pop_done_read
		cmp	al, 3
		jz	short devrderr
		pop	ds
		jmp	short do_io
; ---------------------------------------------------------------------------

check_busy:				; ...
		test	word ptr es:[bx+3], 200h ; [es:bx+SRHEAD.REQSTAT]
		jnz	short no_char
		mov	byte ptr es:[bx+2], 4 ;	DEVRD
		mov	word ptr es:[bx+12h], 1
		push	ds
		lds	si, ss:THISSFT
		call	DEVIOCALL
		mov	dx, di
		mov	ah, 86h
		mov	di, es:[bx+3]
		test	di, 8000h	; STERR
		jz	short next_char
		call	CHARHARD
		mov	di, dx
		or	al, al
		jz	short pop_done_read
		cmp	al, 3
		jz	short devrderr
		pop	ds
		jmp	short do_io
; ---------------------------------------------------------------------------

next_char:				; ...
		pop	ds
		mov	di, dx
		dec	cx
		jcxz	short done_read
		inc	word ptr es:[bx+14]
		jmp	short do_io
; ---------------------------------------------------------------------------

devrderr:				; ...
		pop	di
		les	di, ss:THISSFT
		jmp	SET_ACC_ERR_DS
; ---------------------------------------------------------------------------

no_char:				; ...
		push	ax
		mov	ah, 84h
		int	2Ah		; Microsoft Networks - KEYBOARD	BUSY LOOP
		pop	ax
		jmp	do_io
; ---------------------------------------------------------------------------

pop_done_read:				; ...
		pop	ds

done_read:				; ...
		add	di, ss:CALLSCNT
		jmp	ENDRDDEVJ3
; ---------------------------------------------------------------------------

TRANBUF:				; ...
		lodsb
		stosb
		cmp	al, 0Dh		; c_CR
		jnz	short NORMCH
		mov	byte ptr [si], 0Ah ; c_LF

NORMCH:					; ...
		cmp	al, 0Ah		; c_LF
		loopne	TRANBUF
		jnz	short ENDRDCON
		xor	si, si
		call	OUTT
		or	al, 1

ENDRDCON:				; ...
		push	ss
		pop	ds
		call	SWAPBACK
		mov	ds:CONTPOS, si

ENDRDDEV:				; ...
		push	ss
		pop	ds
		mov	ds:NEXTADD, di
		jnz	short SETSFTC
		les	di, ds:THISSFT
		and	byte ptr es:[di+5], 0BFh ; [ES:DI+SF_ENTRY.sf_flags],
					; ~devid_device_EOF

SETSFTC:				; ...
		call	SETSFT
		retn
; ---------------------------------------------------------------------------

READCON:				; ...
		call	SWAPCON
		mov	si, ds:CONTPOS
		or	si, si
		jnz	short TRANBUF
		cmp	ds:CONBUF, 128	; 80h
		jz	short GETBUF
		mov	word ptr ds:CONBUF, 0FF80h

GETBUF:					; ...
		push	cx
		push	es
		push	di
		mov	dx, offset CONBUF
		call	$STD_CON_STRING_INPUT
		pop	di
		pop	es
		pop	cx
		mov	si, (offset CONBUF+2)
		cmp	byte ptr [si], 1Ah
		jnz	short TRANBUF
		mov	al, 1Ah
		stosb
		dec	di
		mov	al, 0Ah		; c_LF
		call	OUTT
		xor	si, si
		jmp	short ENDRDCON
DOS_READ	endp


; =============== S U B	R O U T	I N E =======================================


DOS_WRITE	proc near		; ...
		les	di, ds:THISSFT
		mov	al, es:[di+2]	; [ES:DI+SF_ENTRY.sf_mode]
		and	al, 0Fh		; access_mask
		cmp	al, 0		; open_for_read
		jnz	short Check_FCB_RO

BadMode:				; ...
		jmp	SET_ACC_ERR
; ---------------------------------------------------------------------------

Check_FCB_RO:				; ...
		test	byte ptr es:[di+3], 80h	; [ES:DI+SF_ENTRY.sf_mode+1],(sf_isFCB>>8)
		jz	short WRITE_NO_MODE
		test	byte ptr es:[di+4], 1 ;	[ES:DI+SF_ENTRY.sf_attr],attr_read_only
		jnz	short BadMode

WRITE_NO_MODE:				; ...
		call	SETUP
		call	IsSFTNet
		jz	short LOCAL_WRITE
		mov	ax, 1109h	; (MultNET<<8)|9
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - WRITE TO REMOTE FILE
					; ES:DI	-> SFT
					; SFT DPB field	-> DPB of drive	containing file
					; CX = number of bytes,	SS = DOS CS, SDA DTA field -> user buffer
					; Return: CF set on error, CX =	bytes written
		retn
; ---------------------------------------------------------------------------

LOCAL_WRITE:				; ...
		test	byte ptr es:[di+5], 80h	; [ES:DI+SF_ENTRY.sf_flags],
					; devid_device
		jnz	short WRTDEV
		mov	ds:EXTERR_LOCUS, 2
		call	ECritDisk
		call	DISKWRITE
		jb	short nocommit
		les	di, ds:THISSFT
		test	byte ptr es:[di+3], 40h	; [ES:DI+SF_ENTRY.sf_mode],
					; auto_commit_write
		jz	short nocommit
		push	cx
		call	DOS_COMMIT
		pop	cx

nocommit:				; ...
		call	LCritDisk
		retn
; ---------------------------------------------------------------------------

DVWRTRAW:				; ...
		xor	ax, ax
		call	SETWRITE
		push	ds
		lds	si, ss:THISSFT
		call	DEVIOCALL
		mov	dx, di
		mov	ah, 87h
		mov	di, ss:DEVCALL_REQSTAT
		or	di, di
		jns	short CWRTROK
		call	CHARHARD
		sub	cx, ss:CALLSCNT
		mov	bx, dx
		add	bx, ss:CALLSCNT
		mov	di, bx
		or	al, al
		jz	short CWRTROK
		cmp	al, 3
		jz	short CWRFERR
		pop	ds
		jmp	short DVWRTRAW
; ---------------------------------------------------------------------------

CWRFERR:				; ...
		pop	ax
		jmp	CRDFERR
; ---------------------------------------------------------------------------

CWRTROK:				; ...
		pop	ax
		pop	ds
		mov	ax, ds:CALLSCNT

ENDWRDEV:				; ...
		les	di, ds:THISSFT
		mov	cx, ax
		call	ADDREC
		retn
; ---------------------------------------------------------------------------

WRTNUL:					; ...
		mov	dx, cx

WRTCOOKJ:				; ...
		jmp	WRTCOOKDONE
; ---------------------------------------------------------------------------

WRTDEV:					; ...
		mov	ds:EXTERR_LOCUS, 4 ; errLOC_SerDev
		or	byte ptr es:[di+5], 40h	; [ES:DI+SF_ENTRY.sf_flags],
					; devid_device_EOF
		mov	bl, es:[di+5]	; [ES:DI+SF_ENTRY.sf_flags]
		xor	ax, ax
		jcxz	short ENDWRDEV
		push	ds
		mov	al, bl
		lds	bx, ds:DMAADD
		mov	di, bx
		xor	dx, dx
		test	al, 20h		; devid_device_raw
		jz	short TEST_DEV_CON
		jmp	short DVWRTRAW
; ---------------------------------------------------------------------------

TEST_DEV_CON:				; ...
		test	al, 2		; devid_device_con_out
		jnz	short WRITECON
		test	al, 4		; devid_device_null
		jnz	short WRTNUL
		mov	ax, dx
		cmp	byte ptr [bx], 1Ah ; ^Z?
		jz	short WRTCOOKJ
		push	cx
		mov	cx, 1
		call	SETWRITE
		pop	cx
		lds	si, ss:THISSFT
		lds	si, [si+7]	; [SI+SF_ENTRY.sf_devptr]

DVWRTLP:				; ...
		call	DSKSTATCHK
		call	DEVIOCALL2
		push	di
		mov	ah, 87h
		mov	di, ss:DEVCALL_REQSTAT
		or	di, di
		jns	short CWROK
		call	CHARHARD
		pop	di
		mov	ss:CALLSCNT, 1
		cmp	al, 1
		jz	short DVWRTLP
		or	al, al
		jz	short DVWRTIGN
		jmp	CRDFERR
; ---------------------------------------------------------------------------

CWROK:					; ...
		pop	di
		cmp	ss:CALLSCNT, 0
		jz	short WRTCOOKDONE

DVWRTIGN:				; ...
		inc	dx
		inc	word ptr ss:CALLXADD
		inc	di
		push	ds
		mov	ds, word ptr ss:CALLXADD+2
		cmp	byte ptr [di], 1Ah ; ^Z?
		pop	ds
		jz	short WRTCOOKDONE
		mov	ss:DEVCALL_REQSTAT, 0
		loop	DVWRTLP

WRTCOOKDONE:				; ...
		mov	ax, dx
		pop	ds
		jmp	ENDWRDEV
; ---------------------------------------------------------------------------

WRITECON:				; ...
		push	ds
		push	ss
		pop	ds
		call	SWAPCON
		pop	ds
		mov	si, bx
		push	cx

WRCONLP:				; ...
		lodsb
		cmp	al, 1Ah		; ^Z?
		jz	short CONEOF
		call	OUTT
		loop	WRCONLP

CONEOF:					; ...
		pop	ax
		sub	ax, cx
		pop	ds
		call	SWAPBACK
		jmp	ENDWRDEV
DOS_WRITE	endp


; =============== S U B	R O U T	I N E =======================================


GET_IO_SFT	proc near		; ...
		cmp	ss:CONSWAP, 0
		jnz	short GetRedir

GetNormal:				; ...
		push	ss
		pop	ds
		push	es
		push	di
		call	SFFromHandle
		jb	short RET44P
		mov	si, es
		mov	ds, si
		mov	si, di

RET44P:					; ...
		pop	di
		pop	es
		retn
; ---------------------------------------------------------------------------

GetRedir:				; ...
		cmp	bx, 1
		ja	short GetNormal
		lds	si, ss:CONSFT
		clc

get_io_sft_retn:			; ...
		retn
GET_IO_SFT	endp


; =============== S U B	R O U T	I N E =======================================


DIRREAD		proc near		; ...
		xor	dx, dx
		cmp	ds:DIRSTART, 0
		jnz	short SubDir
		xchg	ax, dx
		jmp	short DoRead
; ---------------------------------------------------------------------------

SubDir:					; ...
		mov	dl, al
		and	dl, es:[bp+4]	; [ES:BP+DPB.CLUSTER_MASK]
		mov	cl, es:[bp+5]	; [ES:BP+DPB.CLUSTER_SHIFT]
		shr	ax, cl

DoRead:					; ...
		mov	ds:SECCLUSPOS, dl
		mov	cx, ax
		mov	ah, dl
		mov	dx, word ptr ds:DIRSEC+2
		mov	ds:HIGH_SECTOR,	dx
		mov	dx, word ptr ds:DIRSEC
		add	dl, ah
		adc	dh, 0
		adc	ds:HIGH_SECTOR,	0
		mov	bx, ds:CLUSNUM
		mov	ds:NXTCLUSNUM, bx
		jcxz	short FIRSTCLUSTER

SKPCLLP:				; ...
		call	UNPACK
		jb	short get_io_sft_retn
		xchg	bx, di
		call	IsEOF
		jnb	short HAVESKIPPED
		loop	SKPCLLP

HAVESKIPPED:				; ...
		mov	ds:NXTCLUSNUM, bx
		mov	dx, di
		mov	bl, ah
		call	FIGREC

FIRSTCLUSTER:				; ...
		mov	ds:ALLOWED, 18h	; Allowed_RETRY+Allowed_FAIL
		xor	al, al
		call	GETBUFFR
		jb	short get_io_sft_retn

SET_BUF_AS_DIR:				; ...
		push	ds
		push	si
		lds	si, ds:CURBUF
		or	byte ptr [si+5], 4 ; [SI+BUFFINFO.buf_flags],buf_isDIR
		pop	si
		pop	ds

dirread_retn:				; ...
		retn
DIRREAD		endp


; =============== S U B	R O U T	I N E =======================================


FATSECRD	proc near		; ...
		mov	ss:ALLOWED, 18h	; Allowed_RETRY+Allowed_FAIL
		mov	di, cx
		mov	cl, es:[bp+8]	; [ES:BP+DPB.FAT_COUNT]
		mov	ax, es:[bp+0Fh]	; [ES:BP+DPB.FAT_SIZE]
		xor	ch, ch
		push	dx

NXTFAT:					; ...
		mov	ss:HIGH_SECTOR,	0
		push	cx
		push	ax
		mov	cx, di
		call	DSKREAD
		pop	ax
		pop	cx
		jz	short RET41P
		add	dx, ax
		loop	NXTFAT
		pop	dx
		mov	cx, di

DREAD:					; ...
		call	DSKREAD
		jz	short dirread_retn
		mov	ss:READOP, 0
		call	HARDERRRW
		cmp	al, 1
		jz	short DREAD
		cmp	al, 3
		clc
		jnz	short NO_CAR
		stc

NO_CAR:					; ...
		retn
; ---------------------------------------------------------------------------

RET41P:					; ...
		pop	dx
		retn
FATSECRD	endp


; =============== S U B	R O U T	I N E =======================================


CHECK_WRITE_LOCK proc near		; ...
		test	byte ptr es:[di+4], 8 ;	[ES:DI+SF_ENTRY.sf_attr],
					; attr_volume_id
		jz	short write_cont
		call	SET_ACC_ERR_DS
		retn
; ---------------------------------------------------------------------------

write_cont:				; ...
		push	cx
		or	cx, cx
		jnz	short Not_Truncate
		dec	cx

Not_Truncate:				; ...
		mov	al, 80h
		call	LOCK_CHECK
		pop	cx
		jnb	short WRITE_OK
		call	WRITE_LOCK_VIOLATION
		jnb	short write_cont

WRITE_OK:				; ...
		retn
CHECK_WRITE_LOCK endp


; =============== S U B	R O U T	I N E =======================================


CHECK_READ_LOCK	proc near		; ...
		test	byte ptr es:[di+4], 8 ;	[ES:DI+SF_ENTRY.sf_attr],
					; attr_volume_id
		jz	short do_retry
		call	SET_ACC_ERR
		retn
; ---------------------------------------------------------------------------

do_retry:				; ...
		xor	al, al
		call	LOCK_CHECK
		jnb	short READLOCK_OK
		call	READ_LOCK_VIOLATION
		jnb	short do_retry

READLOCK_OK:				; ...
		retn
CHECK_READ_LOCK	endp


; =============== S U B	R O U T	I N E =======================================


DSKREAD		proc near		; ...
		push	cx
		mov	ah, es:[bp+17h]	; [ES:BP+DPB.MEDIA]
		mov	al, es:[bp+1]	; [ES:BP+DPB.UNIT]
		push	bx
		push	es
		call	SETREAD
		jmp	short DODSKOP
DSKREAD		endp


; =============== S U B	R O U T	I N E =======================================


DWRITE		proc near		; ...
		call	DSKWRITE
		jz	short dw_ret_label
		mov	ss:READOP, 1
		call	HARDERRRW
		cmp	al, 1
		jz	short DWRITE
		cmp	al, 3
		clc
		jnz	short dw_ret_label ; NO_CAR2
		stc

dw_ret_label:				; ...
		retn			; NO_CAR2
DWRITE		endp


; =============== S U B	R O U T	I N E =======================================


DSKWRITE	proc near		; ...
		push	cx
		mov	ah, es:[bp+17h]	; [ES:BP+DPB.MEDIA]
		mov	al, es:[bp+1]	; [ES:BP+DPB.UNIT]
		push	bx
		push	es
		call	SETWRITE

DODSKOP:				; ...
		mov	cx, ds
		pop	ds
		push	ds
		lds	si, ds:[bp+13h]	; LDS SI,[DS:BP+DPB.DRIVER_ADDR]
		call	DEVIOCALL2
		mov	ds, cx
		pop	es
		pop	bx
		mov	cx, ss:CALLSCNT
		pop	di
		sub	cx, di
		neg	cx
		mov	ax, ss:DEVCALL_REQSTAT
		test	ax, 8000h	; STERR
		retn
DSKWRITE	endp


; =============== S U B	R O U T	I N E =======================================


HARDERRRW	proc near		; ...
		cmp	al, 0Fh		; error_I24_wrong_disk
		jnz	short DO_ERR
		push	ax
		mov	ax, word ptr ss:CALLVIDRW
		mov	word ptr ss:EXTERRPT, ax
		mov	ax, word ptr ss:CALLVIDRW+2
		mov	word ptr ss:EXTERRPT+2,	ax
		pop	ax

DO_ERR:					; ...
		call	HARDERR
		retn
HARDERRRW	endp

; ---------------------------------------------------------------------------

SETUP:					; ...
		lds	si, es:[di+7]	; [ES:DI+SF_ENTRY.sf_devptr]
		mov	word ptr ss:THISDPB+2, ds
		push	ss
		pop	ds
		mov	word ptr ds:THISDPB, si
		mov	bx, word ptr ds:DMAADD
		mov	ds:NEXTADD, bx
		mov	ds:TRANS, 0
		mov	ax, es:[di+15h]	; [ES:DI+SF_ENTRY.sf_position]
		mov	dx, es:[di+17h]	; [ES:DI+SF_ENTRY.sf_position+2]
		mov	word ptr ds:BYTPOS+2, dx
		mov	word ptr ds:BYTPOS, ax
		test	word ptr es:[di+5], 8080h ; [ES:DI+SF_ENTRY.sf_flags],
					; sf_isnet+devid_device
		jnz	short NOSETSTUFF
		push	es
		les	bp, ds:THISDPB
		mov	bl, es:[bp+0]	; [ES:BP+DPB.drive]
		mov	ds:THISDRV, bl
		mov	bx, es:[bp+2]	; [ES:BP+DPB.SECTOR_SIZE]
		push	cx
		call	DIV32
		mov	ds:BYTSECPOS, dx
		mov	word ptr ds:SECPOS, ax
		mov	word ptr ds:SECPOS+2, cx
		mov	dx, cx
		mov	bx, ax
		and	bl, es:[bp+4]	; [ES:BP+DPB.CLUSTER_MASK]
		mov	ds:SECCLUSPOS, bl
		call	SHR32
		pop	cx
		jnz	short EOFERR
		cmp	ax, es:[bp+0Dh]	; [ES:BP+DPB.MAX_CLUSTER]
		ja	short EOFERR
		mov	ds:CLUSNUM, ax
		pop	es

NOSETSTUFF:				; ...
		mov	ax, cx
		add	ax, word ptr ds:DMAADD
		jnb	short setup_OK
		mov	ax, word ptr ds:DMAADD
		neg	ax
		jnz	short NoDec
		dec	ax

NoDec:					; ...
		mov	cx, ax
		jcxz	short NOROOM

setup_OK:				; ...
		retn
; ---------------------------------------------------------------------------

EOFERR:					; ...
		pop	es
		xor	cx, cx

NOROOM:					; ...
		pop	bx
		clc
		retn

; =============== S U B	R O U T	I N E =======================================


BREAKDOWN	proc near		; ...
		mov	ax, ds:BYTSECPOS
		mov	bx, cx
		or	ax, ax
		jz	short SAVFIR
		sub	ax, es:[bp+2]	; [ES:BP+DPB.SECTOR_SIZE]
		neg	ax
		sub	bx, ax
		jnb	short SAVFIR
		add	ax, bx
		xor	bx, bx

SAVFIR:					; ...
		mov	ds:BYTCNT1, ax
		mov	ax, bx
		xor	dx, dx
		div	word ptr es:[bp+2] ; [ES:BP+DPB.SECTOR_SIZE]
		mov	ds:SECCNT, ax
		mov	ds:BYTCNT2, dx

_RET45:					; ...
		retn
BREAKDOWN	endp


; =============== S U B	R O U T	I N E =======================================


READ_LOCK_VIOLATION proc near		; ...
		mov	ds:READOP, 0

ERR_ON_CHECK:				; ...
		test	byte ptr es:[di+3], 80h	; [ES:DI+SF_ENTRY.sf_mode+1],
					; (sf_isFCB>>8)
		jnz	short HARD_ERR
		push	cx
		mov	cl, es:[di+2]	; [ES:DI+SF_ENTRY.sf_mode]
		and	cl, 0F0h	; SHARING_MASK
		cmp	cl, 0		; SHARING_COMPAT
		pop	cx
		jnz	short NO_HARD_ERR

HARD_ERR:				; ...
		call	LOCK_VIOLATION
		jnb	short _RET45

NO_HARD_ERR:				; ...
		xor	cx, cx
		mov	ax, 21h		; error_lock_violation
		stc
		retn
READ_LOCK_VIOLATION endp


; =============== S U B	R O U T	I N E =======================================


WRITE_LOCK_VIOLATION proc near		; ...
		mov	ds:READOP, 1
		jmp	short ERR_ON_CHECK
WRITE_LOCK_VIOLATION endp

; ---------------------------------------------------------------------------

DISKREAD:				; ...
		mov	ax, es:[di+11h]	; [ES:DI+SF_ENTRY.sf_size]
		mov	bx, es:[di+13h]	; [ES:DI+SF_ENTRY.sf_size+2]
		sub	ax, word ptr ds:BYTPOS
		sbb	bx, word ptr ds:BYTPOS+2
		jb	short RDERR
		jnz	short ENUF
		or	ax, ax
		jz	short RDERR
		cmp	ax, cx
		jnb	short ENUF
		mov	cx, ax

ENUF:					; ...
		call	CHECK_READ_LOCK
		jnb	short _READ_OK
		retn
; ---------------------------------------------------------------------------

_READ_OK:				; ...
		les	bp, ds:THISDPB
		call	BREAKDOWN
		mov	cx, ds:CLUSNUM
		call	FNDCLUS
		jb	short SET_ACC_ERR_DS
		or	cx, cx
		jz	short SKIPERR

RDERR:					; ...
		mov	ah, 0Eh
		jmp	WRTERR22
; ---------------------------------------------------------------------------

SETSFTJ2:				; ...
		jmp	SETSFT
; ---------------------------------------------------------------------------

CANOT_READ:				; ...
		pop	cx
		pop	bx

SET_ACC_ERR_DS:				; ...
		push	ss
		pop	ds

SET_ACC_ERR:				; ...
		xor	cx, cx
		mov	ax, 5		; error_access_denied
		stc
		retn
; ---------------------------------------------------------------------------

SKIPERR:				; ...
		mov	ds:LASTPOS, dx
		mov	ds:CLUSNUM, bx
		cmp	ds:BYTCNT1, 0
		jz	short RDMID
		call	BUFRD
; ---------------------------------------------------------------------------
		jb	short SET_ACC_ERR_DS

RDMID:					; ...
		cmp	ds:SECCNT, 0
		jz	short RDLAST
		call	NEXTSEC
		jb	short SETSFTJ2
		mov	ds:TRANS, 1
		mov	dl, ds:SECCLUSPOS
		mov	cx, ds:SECCNT
		mov	bx, ds:CLUSNUM

RDLP:					; ...
		call	OPTIMIZE
		jb	short SET_ACC_ERR_DS
		push	di
		push	ax
		push	bx
		mov	ds:ALLOWED, 38h	; Allowed_RETRY+Allowed_FAIL+Allowed_IGNORE
		mov	ds, word ptr ds:DMAADD+2
		push	dx
		push	cx
		call	SET_RQ_SC_PARMS
		call	DREAD
		pop	cx
		pop	dx
		pop	ss:TEMP_VAR
		jb	short CANOT_READ
		mov	ss:TEMP_VAR2, ds
		call	DskRdBufScan
		push	ss
		pop	ds
		pop	cx
		pop	bx
		jcxz	short RDLAST
		call	IsEOF
		jnb	short SETSFT
		mov	dl, 0
		inc	ds:LASTPOS
		jmp	short RDLP
; ---------------------------------------------------------------------------

RDLAST:					; ...
		mov	ax, ds:BYTCNT2
		or	ax, ax
		jz	short SETSFT
		mov	ds:BYTCNT1, ax
		call	NEXTSEC
		jb	short SETSFT
		mov	ds:BYTSECPOS, 0
		call	BUFRD
; ---------------------------------------------------------------------------
		db  73h	; s
		db    3
		db 0E9h	; é
		db  6Ch	; l
		db 0FFh

; =============== S U B	R O U T	I N E =======================================


SETSFT		proc near		; ...
		les	di, ds:THISSFT

SETCLUS:				; ...
		mov	cx, ds:NEXTADD
		sub	cx, word ptr ds:DMAADD
		test	byte ptr es:[di+5], 80h	; [ES:DI+SF_ENTRY.sf_flags],
					; devid_device
		jnz	short ADDREC
		mov	ax, ds:CLUSNUM
		mov	es:[di+35h], ax	; [ES:DI+SF_ENTRY.sf_lstclus]
		mov	ax, ds:LASTPOS
		mov	es:[di+19h], ax	; [ES:DI+SF_ENTRY.sf_cluspos]

ADDREC:					; ...
		jcxz	short RET28
		add	es:[di+15h], cx	; [ES:DI+SF_ENTRY.sf_position]
		adc	word ptr es:[di+17h], 0	; [ES:DI+SF_ENTRY.sf_position+2]

RET28:					; ...
		clc
		retn
SETSFT		endp


; =============== S U B	R O U T	I N E =======================================


DskRdBufScan	proc near		; ...
		cmp	ss:DirtyBufferCount, 0
		jz	short bufx
		mov	bx, ss:HIGH_SECTOR
		mov	si, bx
		add	cx, dx
		adc	si, 0
		call	GETCURHEAD
		mov	ax, [di+2]	; [di+BUFFINFO.buf_prev]
		mov	ss:FIRST_BUFF_ADDR, ax
		mov	al, es:[bp+0]

bufq:					; ...
		cmp	al, [di+4]	; [di+BUFFINFO.buf_ID]
		jnz	short bufq1
		cmp	bx, [di+8]	; [di+BUFFINFO.buf_sector+2]
		jnz	short bufq01
		cmp	dx, [di+6]	; [di+BUFFINFO.buf_sector]

bufq01:					; ...
		ja	short bufq1
		cmp	si, [di+8]
		jnz	short bufq02
		cmp	cx, [di+6]

bufq02:					; ...
		ja	short bufq2

bufq1:					; ...
		cmp	di, ss:FIRST_BUFF_ADDR
		mov	di, [di]	; [di+BUFFINFO.buf_next]
		jnz	short bufq

bufx:					; ...
		retn
; ---------------------------------------------------------------------------

bufq2:					; ...
		push	ax
		test	byte ptr [di+5], 40h ; [di+BUFFINFO.buf_flags],
					; buf_dirty
		jz	short bufq3
		push	cx
		push	dx
		push	si
		push	di
		push	es
		mov	ax, dx
		sub	ax, [di+6]	; [di+BUFFINFO.buf_sector]
		neg	ax
		lea	si, [di+20]	; [di+BUFINSIZ]
		mov	cx, es:[bp+2]	; [es:bp+DPB.SECTOR_SIZE]
		mul	cx
		mov	di, ss:TEMP_VAR
		add	di, ax
		mov	es, ss:TEMP_VAR2
		shr	cx, 1
		rep movsw
		adc	cx, 0
		rep movsb
		pop	es
		pop	di
		pop	si
		pop	dx
		pop	cx

bufq3:					; ...
		mov	ax, di
		call	SCANPLACE
		cmp	ax, ss:FIRST_BUFF_ADDR
		pop	ax
		jnz	short bufq
		jmp	short bufx
DskRdBufScan	endp


; =============== S U B	R O U T	I N E =======================================


DISKWRITE	proc near		; ...
		call	CHECK_WRITE_LOCK
		jnb	short _WRITE_OK
		retn
; ---------------------------------------------------------------------------

WRTEOFJ:				; ...
		jmp	WRTEOF
; ---------------------------------------------------------------------------

_WRITE_OK:				; ...
		and	word ptr es:[di+5], 0BFBFh ; [ES:DI+SF_ENTRY.sf_flags],
					; ~(sf_close_nodate|devid_file_clean)
		mov	ax, es:[di+11h]	; [ES:DI+SF_ENTRY.sf_size]
		mov	ds:TEMP_VAR, ax
		mov	ax, es:[di+13h]	; [ES:DI+SF_ENTRY.sf_size+2]
		mov	ds:TEMP_VAR2, ax
		les	bp, ds:THISDPB
		call	BREAKDOWN
		mov	ax, word ptr ds:BYTPOS
		mov	dx, word ptr ds:BYTPOS+2
		jcxz	short WRTEOFJ
		add	ax, cx
		adc	dx, 0
		mov	bx, es:[bp+2]	; [ES:BP+DPB.SECTOR_SIZE]
		call	DIV32
		mov	si, ax
		mov	ds:HIGH_SECTOR,	cx
		or	dx, dx
		push	dx
		mov	dx, cx
		jnz	short CALCLUS
		sub	ax, 1
		sbb	dx, 0

CALCLUS:				; ...
		call	SHR32
		pop	dx
		push	ax
		push	dx
		mov	dx, ds:TEMP_VAR2
		mov	ax, ds:TEMP_VAR
		call	DIV32
		mov	ds:TEMP_VAR2, cx
		mov	word ptr ds:VALSEC+2, cx
		mov	cx, ax
		mov	bx, si
		or	dx, dx
		jz	short NORND
		add	ax, 1
		adc	word ptr ds:VALSEC+2, 0

NORND:					; ...
		mov	word ptr ds:VALSEC, ax
		xor	ax, ax
		mov	word ptr ds:GROWCNT, ax
		mov	word ptr ds:GROWCNT+2, ax
		pop	ax
		mov	di, ds:HIGH_SECTOR
		cmp	di, ds:TEMP_VAR2
		jb	short NOGROW
		jz	short lowsec
		sub	bx, cx
		sbb	di, ds:TEMP_VAR2
		jmp	short yesgrow
; ---------------------------------------------------------------------------

lowsec:					; ...
		mov	di, 0
		sub	bx, cx
		jb	short NOGROW
		jz	short TESTTAIL

yesgrow:				; ...
		mov	cx, dx
		xchg	ax, bx
		mul	word ptr es:[bp+2] ; [ES:BP+DPB.SECTOR_SIZE]
		mov	ds:HIGH_SECTOR,	dx
		mov	ds:TEMP_VAR2, ax
		mov	ax, di
		mul	word ptr es:[bp+2] ; [ES:BP+DPB.SECTOR_SIZE]
		add	ax, ds:HIGH_SECTOR
		mov	dx, ax
		mov	ax, ds:TEMP_VAR2
		sub	ax, cx
		sbb	dx, 0
		add	ax, bx
		adc	dx, 0
		jmp	short SETGRW
; ---------------------------------------------------------------------------

HAVSTART:				; ...
		mov	cx, ax
		call	SKPCLP
		jcxz	short DOWRTJ
		call	ALLOCATE
		jnb	short DOWRTJ

WRTERR:					; ...
		mov	ah, 0Fh

WRTERR22:				; ...
		mov	al, ds:THISDRV
		xor	cx, cx
		les	di, ds:THISSFT
		clc
		retn
; ---------------------------------------------------------------------------

DOWRTJ:					; ...
		jmp	short DOWRT
; ---------------------------------------------------------------------------

ACC_ERRWJ:				; ...
		jmp	SET_ACC_ERRW
; ---------------------------------------------------------------------------

TESTTAIL:				; ...
		sub	ax, dx
		jbe	short NOGROW
		xor	dx, dx

SETGRW:					; ...
		mov	word ptr ds:GROWCNT, ax
		mov	word ptr ds:GROWCNT+2, dx

NOGROW:					; ...
		pop	ax
		mov	cx, ds:CLUSNUM
		call	FNDCLUS
		jb	short ACC_ERRWJ
		mov	ds:CLUSNUM, bx
		mov	ds:LASTPOS, dx
		sub	ax, dx
		jz	short DOWRT
		jcxz	short HAVSTART
		push	cx
		mov	cx, ax
		call	ALLOCATE
		pop	cx
		jb	short WRTERR
		mov	dx, ds:LASTPOS
		inc	dx
		dec	cx
		jz	short NOSKIP
		call	SKPCLP
		jb	short ACC_ERRWJ

NOSKIP:					; ...
		mov	ds:CLUSNUM, bx
		mov	ds:LASTPOS, dx

DOWRT:					; ...
		cmp	ds:BYTCNT1, 0
		jz	short WRTMID
		mov	bx, ds:CLUSNUM
		call	BUFWRT
; ---------------------------------------------------------------------------
		db  72h	; r
		db 0AAh	; ª
; ---------------------------------------------------------------------------

WRTMID:					; ...
		mov	ax, ds:SECCNT
		or	ax, ax
		jz	short WRTLAST
		add	word ptr ds:SECPOS, ax
		adc	word ptr ds:SECPOS+2, 0
		call	NEXTSEC
		jb	short SET_ACC_ERRW
		mov	ds:TRANS, 1
		mov	dl, ds:SECCLUSPOS
		mov	bx, ds:CLUSNUM
		mov	cx, ds:SECCNT

WRTLP:					; ...
		call	OPTIMIZE
		jb	short SET_ACC_ERRW
		push	di
		push	ax
		call	DskWrtBufPurge
		mov	ds, word ptr ss:DMAADD+2
		mov	ss:ALLOWED, 38h	; Allowed_RETRY+Allowed_FAIL+Allowed_IGNORE
		call	DWRITE
		pop	cx
		pop	bx
		push	ss
		pop	ds
		jb	short SET_ACC_ERRW
		jcxz	short WRTLAST
		mov	dl, 0
		inc	ds:LASTPOS
		jmp	short WRTLP
; ---------------------------------------------------------------------------

WRTLAST:				; ...
		mov	ax, ds:BYTCNT2
		or	ax, ax
		jz	short FINWRT
		mov	ds:BYTCNT1, ax
		call	NEXTSEC
		jb	short SET_ACC_ERRW
		mov	ds:BYTSECPOS, 0
		call	BUFWRT
; ---------------------------------------------------------------------------
		db  72h	; r
		db  23h	; #
; ---------------------------------------------------------------------------

FINWRT:					; ...
		les	di, ds:THISSFT
		mov	ax, word ptr ds:GROWCNT
		mov	cx, word ptr ds:GROWCNT+2
		or	ax, ax
		jnz	short UPDATE_size
		jcxz	short SAMSIZ

UPDATE_size:				; ...
		add	es:[di+11h], ax	; [ES:DI+SF_ENTRY.sf_size]
		adc	es:[di+13h], cx	; [ES:DI+SF_ENTRY.sf_size+2]
		mov	ax, 1
		call	dword ptr ds:ShSU ; call far [JShare+(14*4)]  ;	14 = ShSU

SAMSIZ:					; ...
		jmp	SETCLUS
; ---------------------------------------------------------------------------

SET_ACC_ERRW:				; ...
		jmp	SET_ACC_ERR_DS
; ---------------------------------------------------------------------------

WRTEOF:					; ...
		mov	cx, ax
		or	cx, dx
		jz	short KILLFIL
		sub	ax, 1
		sbb	dx, 0
		push	bx
		mov	bx, es:[bp+2]	; [ES:BP+DPB.SECTOR_SIZE]
		call	DIV32
		pop	bx
		mov	dx, cx
		mov	ds:HIGH_SECTOR,	cx
		call	SHR32
		mov	cx, ax
		call	FNDCLUS

SET_ACC_ERRWJ2:				; ...
		jb	short SET_ACC_ERRW
		jcxz	short RELFILE
		call	ALLOCATE
		jb	short WRTERRJ

UPDATE:					; ...
		les	di, ds:THISSFT
		mov	ax, word ptr ds:BYTPOS
		mov	es:[di+11h], ax	; [ES:DI+SF_ENTRY.sf_size]
		mov	ax, word ptr ds:BYTPOS+2
		mov	es:[di+13h], ax	; [ES:DI+SF_ENTRY.sf_size+2]
		mov	ax, 2
		call	dword ptr ds:ShSU ; call far [JShare+(14*4)]
		xor	cx, cx
		jmp	ADDREC
; ---------------------------------------------------------------------------

WRTERRJ:				; ...
		jmp	WRTERR
; ---------------------------------------------------------------------------

RELFILE:				; ...
		push	es
		les	di, ds:THISSFT
		cmp	dx, es:[di+19h]	; [ES:DI+SF_ENTRY.sf_cluspos]
		jnb	short SKIPRESET
		mov	word ptr es:[di+19h], 0
		mov	dx, es:[di+0Bh]	; [ES:DI+SF_ENTRY.sf_firclus]
		mov	es:[di+35h], dx	; [ES:DI+SF_ENTRY.sf_lstclus]

SKIPRESET:				; ...
		pop	es
		mov	dx, 0FFFFh
		call	RELBLKS

SET_ACC_ERRWJJ:				; ...
		jb	short SET_ACC_ERRWJ2
		jmp	short UPDATE
; ---------------------------------------------------------------------------

KILLFIL:				; ...
		xor	bx, bx
		push	es
		les	di, ds:THISSFT
		mov	es:[di+19h], bx	; [ES:DI+SF_ENTRY.sf_cluspos]
		mov	es:[di+35h], bx	; [ES:DI+SF_ENTRY.sf_lstclus]
		xchg	bx, es:[di+0Bh]	; [ES:DI+SF_ENTRY.sf_firclus]
		pop	es
		or	bx, bx
		jz	short UPDATEJ
		push	es
		push	bp
		push	ax
		push	cx
		push	dx
		les	bp, ds:THISDPB
		mov	dl, es:[bp+0]
		mov	cx, bx
		mov	ah, 2
		call	FastOpen_Update
		pop	dx
		pop	cx
		pop	ax
		pop	bp
		pop	es
		call	RELEASE
		jb	short SET_ACC_ERRWJJ

UPDATEJ:				; ...
		jmp	short UPDATE
DISKWRITE	endp


; =============== S U B	R O U T	I N E =======================================


DskWrtBufPurge	proc near		; ...
		push	bx
		push	cx
		mov	bx, ss:HIGH_SECTOR
		mov	si, bx
		add	cx, dx
		adc	si, 0
		mov	al, es:[bp+0]
		cmp	ss:SC_CACHE_COUNT, 0
		jz	short nosc
		cmp	al, ss:CurSC_DRIVE
		jnz	short nosc
		push	ax
		mov	ax, word ptr ss:CurSC_SECTOR
		mov	di, word ptr ss:CurSC_SECTOR+2
		cmp	si, di
		jnz	short sc01
		cmp	cx, ax

sc01:					; ...
		jbe	short sc5
		add	ax, ss:SC_CACHE_COUNT
		adc	di, 0
		cmp	bx, di
		jnz	short sc02
		cmp	dx, ax

sc02:					; ...
		jnb	short sc5
		mov	ss:SC_STATUS, 0

sc5:					; ...
		pop	ax

nosc:					; ...
		call	GETCURHEAD

_bufq:					; ...
		cmp	al, [di+4]	; [di+BUFFINFO.buf_ID]
		jnz	short bufq5
		cmp	bx, [di+8]	; [di+BUFFINFO.buf_sector+2]
		jnz	short bufq04
		cmp	dx, [di+6]	; [di+BUFFINFO.buf_sector]

bufq04:					; ...
		ja	short bufq5
		cmp	si, [di+8]
		jnz	short bufq05
		cmp	cx, [di+6]

bufq05:					; ...
		jbe	short bufq5
		test	byte ptr [di+5], 40h ; [di+BUFFINFO.buf_flags],
					; buf_dirty
		jz	short bufq4
		call	DEC_DIRTY_COUNT

bufq4:					; ...
		mov	word ptr [di+4], 20FFh ; [di+BUFFINFO.buf_ID],
					; ((buf_visit<<8)|0FFh)
		call	SCANPLACE
		jmp	short bufq6
; ---------------------------------------------------------------------------

bufq5:					; ...
		mov	di, [di]	; [di+BUFFINFO.buf_next]

bufq6:					; ...
		cmp	di, ss:FIRST_BUFF_ADDR
		jnz	short _bufq
		pop	cx
		pop	bx
		retn
DskWrtBufPurge	endp


; =============== S U B	R O U T	I N E =======================================


DIV32		proc near		; ...
		cmp	bx, 512
		jnz	short div5
		mov	cx, dx
		mov	dx, ax		; CX:AX	= Dividend
					; DX = Remainder
		and	dx, 1FFh	; 511
		mov	al, ah
		mov	ah, cl
		mov	cl, ch
		xor	ch, ch
		shr	cx, 1
		rcr	ax, 1
		retn
; ---------------------------------------------------------------------------

div5:					; ...
		mov	cx, ax
		mov	ax, dx
		xor	dx, dx
		div	bx		; 0:AX/BX
		xchg	ax, cx
		div	bx		; DX:AX/BX
		retn
DIV32		endp


; =============== S U B	R O U T	I N E =======================================


SHR32		proc near		; ...
		mov	cl, es:[bp+5]	; [ES:BP+DPB.CLUSTER_SHIFT]
		xor	ch, ch
		jcxz	short norota

rotashft2:				; ...
		shr	dx, 1
		rcr	ax, 1
		loop	rotashft2

norota:					; ...
		retn
SHR32		endp


; =============== S U B	R O U T	I N E =======================================


FINDENTRY	proc near		; ...
		call	STARTSRCH
		mov	al, ds:ATTRIB
		and	al, 9Eh		; ~attr_ignore
		cmp	al, 8		; attr_volume_id
		jnz	short NOTVOLSRCH
		call	SETROOTSRCH

NOTVOLSRCH:				; ...
		call	GETENTRY
		jnb	short SRCH
		jmp	SETESRET
; ---------------------------------------------------------------------------

SRCH:					; ...
		push	ds
		mov	ds, word ptr ds:CURBUF+2
		mov	ah, [bx]	; [BX+dir_entry.dir_name] ; mov	ah,[bx+0]
		or	ah, ah
		jz	short FREE
		cmp	ah, ss:DELALL
		jz	short FREE
		test	byte ptr [bx+0Bh], 8 ; [BX+dir_entry.dir_attr],
					; attr_volume_id
		jz	short CHKFNAM
		inc	ss:VOLID

CHKFNAM:				; ...
		mov	si, ss
		mov	es, si
		mov	si, bx
		mov	di, offset NAME1
		cmp	ss:NAME1, 0E5h
		jnz	short NO_E5
		mov	ss:NAME1, 5

NO_E5:					; ...
		call	MetaCompare
		jz	short FOUND
		pop	ds

NEXTENT:				; ...
		les	bp, ds:THISDPB
		call	NEXTENTRY
		jnb	short SRCH
		jmp	short SETESRET
; ---------------------------------------------------------------------------

FREE:					; ...
		pop	ds
		mov	cx, ds:LASTENT
		cmp	cx, ds:ENTFREE
		jnb	short TSTALL
		mov	ds:ENTFREE, cx

TSTALL:					; ...
		cmp	ah, ds:DELALL

NEXTENTJ:				; ...
		jz	short NEXTENT
		mov	ds:ENTLAST, cx
		stc
		jmp	short SETESRET
; ---------------------------------------------------------------------------

FOUND:					; ...
		mov	ch, [si]
		pop	ds
		mov	ah, ds:ATTRIB
		and	ah, 9Eh		; ~attr_ignore
		lea	si, [si+15]	; [SI+dir_entry.dir_first-dir_entry.dir_attr]
		test	ch, 8		; attr_volume_id
		jz	short check_one_volume_id
		test	ah, 8		; attr_volume_id
		jz	short NEXTENTJ
		xor	ah, ah
		jmp	short RETFF
; ---------------------------------------------------------------------------

check_one_volume_id:			; ...
		cmp	ah, 8
		jz	short NEXTENTJ
		call	MatchAttributes
		jz	short RETFF
		test	ds:CREATING, 0FFh ; -1
		jz	short NEXTENTJ

RETFF:					; ...
		les	bp, ds:THISDPB
		mov	ah, es:[bp+0]	; [ES:BP+DPB.DRIVE]

SETESRET:				; ...
		push	ss
		pop	es
		retn
FINDENTRY	endp


; =============== S U B	R O U T	I N E =======================================


MetaCompare	proc near		; ...
		mov	cx, 11

WILDCRD:				; ...
		repe cmpsb
		jz	short MetaRet

CHECK_META:				; 3Fh
		cmp	byte ptr es:[di-1], '?'
		jz	short WILDCRD

MetaRet:				; ...
		retn
MetaCompare	endp


; =============== S U B	R O U T	I N E =======================================


NEXTENTRY	proc near		; ...
		mov	ax, ds:LASTENT
		cmp	ax, ds:ENTLAST
		jz	short NONE
		inc	ax
		lea	bx, [bx+32]
		cmp	bx, dx
		jb	short HAVIT
		mov	bl, ds:SECCLUSPOS
		inc	bl
		cmp	bl, ds:CLUSFAC
		jb	short SAMECLUS
		mov	bx, ds:NXTCLUSNUM
		call	IsEOF
		jnb	short NONE
		cmp	bx, 2
		jb	short NONE
		jmp	short GETENT
; ---------------------------------------------------------------------------

NONE:					; ...
		stc
		retn
; ---------------------------------------------------------------------------

HAVIT:					; ...
		mov	ds:LASTENT, ax
		clc

nextentry_retn:				; ...
		retn
; ---------------------------------------------------------------------------

SAMECLUS:				; ...
		mov	ds:SECCLUSPOS, bl
		mov	ds:LASTENT, ax
		push	ds
		lds	di, ds:CURBUF
		mov	dx, [di+8]	; [DI+BUFFINFO.buf_sector+2]
		mov	ss:HIGH_SECTOR,	dx
		mov	dx, [di+6]	; [DI+BUFFINFO.buf_sector]
		add	dx, 1
		adc	ss:HIGH_SECTOR,	0
		pop	ds
		call	FIRSTCLUSTER
		xor	bx, bx
		jmp	short SETENTRY
NEXTENTRY	endp


; =============== S U B	R O U T	I N E =======================================


GETENTRY	proc near		; ...
		mov	ax, ds:LASTENT

GETENT:					; ...
		mov	ds:LASTENT, ax
		mov	cl, 5
		rol	ax, cl		; * 32
		mov	dx, ax
		and	ax, 0FFE0h	; ~(32-1)
		and	dx, 1Fh		; 32-1
		mov	bx, es:[bp+2]	; [ES:BP+DPB.SECTOR_SIZE]
		and	bl, 0E0h	; 255-31
		div	bx
		mov	bx, dx
		push	bx
		call	DIRREAD
		pop	bx
		jb	short nextentry_retn

SETENTRY:				; ...
		mov	dx, word ptr ds:CURBUF
		add	dx, 20		; BUFINSIZ
		add	bx, dx
		add	dx, es:[bp+2]	; [ES:BP+DPB.SECTOR_SIZE]
		retn
GETENTRY	endp


; =============== S U B	R O U T	I N E =======================================


SETDIRSRCH	proc near		; ...
		or	bx, bx
		jz	short SETROOTSRCH
		mov	ds:DIRSTART, bx
		mov	al, es:[bp+4]	; [ES:BP+DPB.CLUSTER_MASK]
		inc	al
		mov	ds:CLUSFAC, al
		push	si
		test	ds:FastOpenFlg,	2 ; Lookup_Success
		jnz	short UNP_OK
		call	UNPACK
		jnb	short UNP_OK
		pop	si
		retn
; ---------------------------------------------------------------------------

UNP_OK:					; ...
		mov	ds:CLUSNUM, di
		mov	dx, bx
		xor	bl, bl
		mov	ds:SECCLUSPOS, bl
		call	FIGREC
		pop	si
		push	dx
		mov	dx, ds:HIGH_SECTOR
		mov	word ptr ds:DIRSEC+2, dx
		pop	dx
		mov	word ptr ds:DIRSEC, dx
		clc
		retn
SETDIRSRCH	endp


; =============== S U B	R O U T	I N E =======================================


SETROOTSRCH	proc near		; ...
		xor	ax, ax
		mov	ds:DIRSTART, ax
		mov	ds:SECCLUSPOS, al
		dec	ax
		mov	ds:CLUSNUM, ax
		mov	ax, es:[bp+0Bh]	; [ES:BP+DPB.FIRST_SECTOR]
		mov	dx, es:[bp+11h]	; [ES:BP+DPB.DIR_SECTOR]
		sub	ax, dx
		mov	ds:CLUSFAC, al
		mov	word ptr ds:DIRSEC, dx
		mov	word ptr ds:DIRSEC+2, 0
		clc
		retn
SETROOTSRCH	endp


; =============== S U B	R O U T	I N E =======================================


GETPATH		proc near		; ...

; FUNCTION CHUNK AT 7F47 SIZE 000001A5 BYTES

		mov	word ptr ds:CREATING, 0E500h ; DIRFREE*256+0

GetPathNoSet:				; ...
		mov	ds:EXTERR_LOCUS, 2 ; errLOC_Disk
		mov	word ptr ds:CURBUF, -1 ; 0FFFFh
		mov	di, ds:WFP_START
		cmp	word ptr [di+1], 5C3Ah ; '\' << 8 + ':'
		jz	short CrackIt
		add	di, 3
		mov	si, di
		call	CHKDEV
		jb	short InternalError

Build_devJ:				; ...
		mov	al, ds:SATTRIB
		mov	ds:ATTRIB, al
		mov	ds:EXTERR_LOCUS, 1 ; errLOC_Unk
		push	ss
		pop	es
		mov	si, offset NAME1
		mov	di, ds:WFP_START
		mov	dx, di
		mov	cx, 8

MoveLoop:				; ...
		lodsb
		stosb
		cmp	al, 20h	; ' '
		jz	short NoSave
		mov	dx, di

NoSave:					; ...
		loop	MoveLoop
		mov	di, dx
		mov	byte ptr [di], 0
		call	Build_device_ent
		inc	al
		retn
; ---------------------------------------------------------------------------

InternalError:				; ...
		jmp	short InternalError
; ---------------------------------------------------------------------------

CrackIt:				; ...
		mov	si, ds:CURR_DIR_END
		cmp	si, -1		; 0FFFFh
		jnz	short LOOK_SING
		lea	si, [di+3]

LOOK_SING:				; ...
		mov	ds:ATTRIB, 16h	; attr_directory+attr_system+attr_hidden
		les	di, ds:THISCDS
		mov	ax, 0FFFFh	; -1
		mov	bx, es:[di+49h]	; [ES:DI+curdir.ID]
		mov	si, ds:CURR_DIR_END
		cmp	si, ax
		jz	short NO_CURR_D
		cmp	bx, ax
		jz	short NO_CURR_D
		test	ds:FastOpenFlg,	1 ; FastOpen_Set
		jz	short GOT_SEARCH_CLUSTER
		push	es
		push	di
		push	cx
		push	word ptr [si-1]
		push	si
		push	bx
		mov	byte ptr [si-1], 0
		mov	si, ds:WFP_START
		mov	bx, offset FastOpenTable
		mov	di, offset Dir_Info_Buff
		mov	cx, offset FastOpen_Ext_Info
		mov	al, 1		; FONC_Look_up
		push	ds
		pop	es
		call	dword ptr [bx+2] ; CALL	far [BX+fastopen_entry.name_caching]
		jb	short GO_Chk_end1
		cmp	byte ptr [si], 0
		jz	short GO_Chk_end
		stc
		jmp	short GO_Chk_end
; ---------------------------------------------------------------------------

GO_Chk_end1:				; ...
		clc

GO_Chk_end:				; ...
		pop	bx
		pop	si
		pop	word ptr [si-1]
		pop	cx
		pop	di
		pop	es
		jnb	short GOT_SEARCH_CLUSTER

NO_CURR_D:				; ...
		mov	si, ds:WFP_START
		lea	si, [si+3]
		les	bp, ds:THISDPB
		jmp	short ROOTPATH
; ---------------------------------------------------------------------------

GOT_SEARCH_CLUSTER:			; ...
		les	bp, ds:THISDPB
		call	SETDIRSRCH
		jb	short SETFERR
		jmp	short FINDPATH
; ---------------------------------------------------------------------------

SETFERR:				; ...
		xor	cl, cl
		stc
		retn
GETPATH		endp


; =============== S U B	R O U T	I N E =======================================


CHKDEV		proc near		; ...
		mov	si, di
		mov	di, ss
		mov	es, di
		mov	di, offset NAME1
		mov	cx, 9

TESTLOOP:				; ...
		call	GETLET
		cmp	al, 2Eh	; '.'
		jz	short TESTDEVICE
		call	PATHCHRCMP
		jz	short NOTDEV
		or	al, al
		jz	short TESTDEVICE
		stosb
		loop	TESTLOOP

NOTDEV:					; ...
		stc
		retn
; ---------------------------------------------------------------------------

TESTDEVICE:				; ...
		add	cx, 2
		mov	al, 20h	; ' '
		rep stosb
		mov	ax, ss
		mov	ds, ax
		call	DEVNAME
		retn
CHKDEV		endp

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR GETPATH

ROOTPATH:				; ...
		call	SETROOTSRCH
		cmp	byte ptr [si], 0
		jnz	short FINDPATH
		mov	al, ds:SATTRIB
		mov	ds:ATTRIB, al
		xor	ah, ah
		retn
; ---------------------------------------------------------------------------

FINDPATH:				; ...
		push	es
		push	si
		mov	di, si
		mov	cx, ds:DIRSTART
		cmp	ds:CURR_DIR_END, 0FFFFh	; -1
		jz	short NOIDS
		cmp	di, ds:CURR_DIR_END
		jnz	short NOIDS
		les	di, ds:THISCDS
		mov	es:[di+49h], cx	; [ES:DI+curdir.ID]

NOIDS:					; ...
		mov	ax, ss
		mov	es, ax
		mov	di, offset NAME1
		mov	ax, 2020h	; '  '
		stosb
		stosw
		stosw
		stosw
		stosw
		stosw
		mov	di, offset NAME1
		xor	ah, ah

GetNam:					; ...
		inc	cl
		lodsb
		cmp	al, 2Eh	; '.'
		jz	short _SetExt
		or	al, al
		jz	short _GetDone
		cmp	al, 5Ch	; '\'
		jz	short _GetDone
		cmp	al, 3Fh	; '?'
		jnz	short StoNam
		or	ah, 1

StoNam:					; ...
		stosb
		jmp	short GetNam
; ---------------------------------------------------------------------------

_SetExt:				; ...
		mov	di, (offset NAME1+8)

GetExt:					; ...
		lodsb
		or	al, al
		jz	short _GetDone
		cmp	al, 5Ch	; '\'
		jz	short _GetDone
		cmp	al, 3Fh	; '?'
		jnz	short StoExt
		or	ah, 1

StoExt:					; ...
		stosb
		jmp	short GetExt
; ---------------------------------------------------------------------------

_GetDone:				; ...
		dec	si
		mov	cl, ah
		or	cl, 80h
		pop	di
		pop	es
		cmp	si, di
		jnz	short check_device
		jmp	_BADPATH
; ---------------------------------------------------------------------------

check_device:				; ...
		push	si
		mov	al, [si]
		or	al, al
		jnz	short NOT_LAST
		mov	bh, ds:SATTRIB
		mov	ds:ATTRIB, bh

NOT_LAST:				; ...
		push	es
		push	ss
		pop	es
		call	DEVNAME
		pop	es
		jb	short FindFile
		or	al, al
		jz	short GO_BDEV
		jmp	FILEINPATH
; ---------------------------------------------------------------------------

GO_BDEV:				; ...
		pop	si
		jmp	Build_devJ
; ---------------------------------------------------------------------------

FindFile:				; ...
		cmp	ds:NAME1, 0E5h
		jnz	short NOE5
		mov	ds:NAME1, 5

NOE5:					; ...
		push	di
		push	es
		push	cx
		call	LookupPath
		jnb	short DIR_FOUND
		call	FINDENTRY

DIR_FOUND:				; ...
		pop	cx
		pop	es
		pop	di
		jnb	short LOAD_BUF
		jmp	BADPATHPOP
; ---------------------------------------------------------------------------

LOAD_BUF:				; ...
		lds	di, ds:CURBUF
		test	byte ptr [bx+0Bh], 10h ; [BX+dir_entry.dir_attr],
					; attr_directory
		jnz	short GO_NEXT
		jmp	FILEINPATH
; ---------------------------------------------------------------------------

GO_NEXT:				; ...
		cmp	ss:NoSetDir, 0
		jz	short SetDir
		mov	dx, di
		mov	cx, ds
		push	ss
		pop	ds
		pop	di
		test	ds:FastOpenFlg,	1 ; FastOpen_Set
		jz	short _nofast
		test	ds:FastOpenFlg,	2 ; Lookup_Success
		jz	short _nofast
		mov	di, ds:Next_Element_Start

_nofast:				; ...
		cmp	byte ptr [di], 0
		jnz	short NEXT_ONE
		jmp	_SETRET
; ---------------------------------------------------------------------------

NEXT_ONE:				; ...
		push	di
		mov	di, dx
		mov	ds, cx

SetDir:					; ...
		mov	dx, [si]
		push	ds
		push	ss
		pop	ds
		test	ds:FastOpenFlg,	2 ; Lookup_Success
		jz	short DO_NORMAL
		mov	bx, dx
		mov	di, ds:CLUSNUM
		push	ax
		call	SETDIRSRCH
		pop	ax
		add	sp, 2
		jmp	short FAST_OPEN_SKIP
; ---------------------------------------------------------------------------

DO_NORMAL:				; ...
		pop	ds
		sub	bx, di
		sub	si, di
		push	bx
		push	ax
		push	si
		push	cx
		push	word ptr [di+6]	; [DI+BUFFINFO.buf_sector]
		push	word ptr [di+8]	; [DI+BUFFINFO.buf_sector+2]
		mov	bx, dx
		push	ss
		pop	ds
		call	SETDIRSRCH
		pop	ds:HIGH_SECTOR
		pop	dx
		jb	short SKIP_GETB
		mov	ds:ALLOWED, 18h	; Allowed_RETRY+Allowed_FAIL
		xor	al, al
		call	GETBUFFR

SKIP_GETB:				; ...
		pop	cx
		pop	si
		pop	ax
		pop	bx
		jnb	short SET_THE_BUF
		pop	di
		mov	si, di
		jmp	short _BADPATH
; ---------------------------------------------------------------------------

SET_THE_BUF:				; ...
		call	SET_BUF_AS_DIR
		mov	di, word ptr ds:CURBUF
		add	si, di
		add	bx, di

FAST_OPEN_SKIP:				; ...
		pop	di
		call	InsertPath
		mov	al, [di]
		or	al, al
		jz	short _SETRET
		inc	di
		mov	si, di
		call	PATHCHRCMP
		jnz	short find_bad_name
		jmp	FINDPATH
; ---------------------------------------------------------------------------

find_bad_name:				; ...
		dec	si

_BADPATH:				; ...
		xor	cl, cl
		jmp	short BADPRET
; ---------------------------------------------------------------------------

FILEINPATH:				; ...
		pop	di
		push	ss
		pop	ds
		test	ds:FastOpenFlg,	1 ; FastOpen_Set
		jz	short NO_FAST
		test	ds:FastOpenFlg,	2 ; Lookup_Success
		jz	short NO_FAST
		mov	di, ds:Next_Element_Start

NO_FAST:				; ...
		mov	al, [di]
		or	al, al
		jz	short INCRET
		mov	si, di
		jmp	short BADPRET
; ---------------------------------------------------------------------------

INCRET:					; ...
		call	InsertPath
		inc	al

_SETRET:				; ...
		retn
; ---------------------------------------------------------------------------

BADPATHPOP:				; ...
		pop	si
		mov	al, [si]
		mov	si, di
		or	al, al

BADPRET:				; ...
		mov	al, ds:SATTRIB
		mov	ds:ATTRIB, al
		stc
		retn
; END OF FUNCTION CHUNK	FOR GETPATH

; =============== S U B	R O U T	I N E =======================================


STARTSRCH	proc near		; ...
		les	bp, ds:THISDPB
		xor	ax, ax
		mov	ds:LASTENT, ax
		mov	ds:VOLID, al
		dec	ax
		mov	ds:ENTFREE, ax
		mov	ds:ENTLAST, ax
		retn
STARTSRCH	endp


; =============== S U B	R O U T	I N E =======================================


MatchAttributes	proc near		; ...
		push	ax
		mov	al, ss:ATTRIB
		not	al
		and	al, ch
		and	al, 16h		; attr_all
		pop	ax
		retn
MatchAttributes	endp


; =============== S U B	R O U T	I N E =======================================


DEVNAME		proc near		; ...
		push	si
		push	di
		push	cx
		push	ax
		push	word ptr ds:NAME1
		cmp	ds:NAME1, 5
		jnz	short NOKTR
		mov	ds:NAME1, 0E5h

NOKTR:					; ...
		test	ds:ATTRIB, 8	; attr_volume_id
		jnz	short RET31
		mov	si, offset NULDEV

LOOKIO:					; ...
		test	word ptr [si+4], 8000h ; [SI+SYSDEV.ATT],DEVTYP
		jz	short SKIPDEV
		mov	ax, si
		add	si, 10		; SYSDEV.NAME
		mov	di, offset NAME1
		mov	cx, 4
		repe cmpsw
		mov	si, ax
		jz	short IOCHK

SKIPDEV:				; ...
		lds	si, [si]
		cmp	si, 0FFFFh	; -1
		jnz	short LOOKIO

RET31:					; ...
		stc

RETNV:					; ...
		mov	cx, ss
		mov	ds, cx
		pop	word ptr ds:NAME1
		pop	ax
		pop	cx
		pop	di
		pop	si
		retn
; ---------------------------------------------------------------------------

IOCHK:					; ...
		mov	word ptr ss:DEVPT+2, ds
		mov	bh, [si+4]	; [SI+SYSDEV.ATT]
		or	bh, 0C0h
		and	bh, 0DFh	; ~20h
		mov	word ptr ss:DEVPT, si
		jmp	short RETNV
DEVNAME		endp


; =============== S U B	R O U T	I N E =======================================


Build_device_ent proc near		; ...
		mov	ax, 2020h	; '  '
		mov	di, (offset NAME1+8) ; DEVFCB+8
		stosw
		stosb
		mov	al, 40h		; attr_device
		stosb
		xor	ax, ax
		mov	cx, 10
		rep stosw
		call	DATE16
		mov	di, (offset NAME2+0Ah) ; DEVFCB+dir_entry.dir_time
		xchg	ax, dx
		stosw
		xchg	ax, dx
		stosw
		mov	si, di
		mov	ax, word ptr ds:DEVPT
		stosw
		mov	ax, word ptr ds:DEVPT+2
		stosw
		mov	ah, bh
		mov	bx, offset NAME1 ; DEVFCB
		xor	al, al
		retn
Build_device_ent endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

ValidateCDS	proc near		; ...

SaveCDS		= dword	ptr -6
Temp		= word ptr -2

		push	bp
		mov	bp, sp
		sub	sp, 6
		mov	[bp+Temp], di	; [bp-2]
		lds	si, ss:THISCDS
		mov	word ptr [bp+SaveCDS], si ; [bp-6]
		mov	word ptr [bp+SaveCDS+2], ds ; [bp-4]
		call	ECritDisk
		test	word ptr [si+67], 8000h	; [SI+curdir.flags],
					; curdir_isnet
		jz	short _DoSplice
		jmp	FatFail
; ---------------------------------------------------------------------------

_DoSplice:				; ...
		xor	dl, dl
		xchg	dl, ss:NoSetDir
		push	ss
		pop	es
		call	FStrCpy
		mov	si, [bp+Temp]	; [bp-2]
		push	ss
		pop	ds
		call	Splice
		push	ss
		pop	ds
		mov	ds:NoSetDir, dl
		les	di, ds:THISCDS
		push	bp
		call	FATREAD_CDS
		pop	bp
		jb	short FatFail
		lds	si, ds:THISCDS
		cmp	word ptr [si+49h], 0FFFFh ; [SI+curdir.ID],-1
		jnz	short RestoreCDS
		push	ss
		pop	es
		push	ss:WFP_START
		cmp	si, word ptr [bp+SaveCDS] ; [bp-6] ; SaveCDSL
		jnz	short DoChdir
		mov	di, [bp+Temp]	; [bp-2]
		mov	ss:WFP_START, di
		call	FStrCpy

DoChdir:				; ...
		push	ss
		pop	ds
		push	word ptr ds:SATTRIB
		push	bp
		call	DOS_CHDIR
		pop	bp
		pop	bx
		pop	ds:WFP_START
		mov	ds:SATTRIB, bl
		lds	si, [bp+SaveCDS] ; [bp-6]
		jnb	short SetCluster
		mov	word ptr ss:THISCDS, si
		mov	word ptr ss:THISCDS+2, ds
		xor	cx, cx
		mov	[si+3],	cl

SetCluster:				; ...
		mov	word ptr [si+49h], 0FFFFh ; [SI+curdir.ID],-1
		lds	si, ss:THISCDS
		test	word ptr [si+43h], 2000h ; SI+curdir.flags],
					; curdir_splice
		jz	short _setdirclus
		mov	cx, -1		; 0FFFFh ; 65535

_setdirclus:				; ...
		mov	[si+49h], cx	; [SI+curdir.ID]

RestoreCDS:				; ...
		les	di, [bp+SaveCDS] ; [bp-6]
		mov	word ptr ss:THISCDS, di
		mov	word ptr ss:THISCDS+2, es
		clc

FatFail:				; ...
		call	LCritDisk
		les	di, [bp+SaveCDS] ; [bp-6]
		mov	sp, bp
		pop	bp
		retn
ValidateCDS	endp


; =============== S U B	R O U T	I N E =======================================


CheckThisDevice	proc near		; ...
		push	di
		push	si
		mov	di, si
		mov	al, [si]
		call	PATHCHRCMP
		jnz	short ParseDev
		inc	si
		lodsw
		or	ax, 2020h
		cmp	ax, 6564h	; 'dev'
		jnz	short NotDevice
		lodsb
		or	al, 20h
		cmp	al, 'v'
		jnz	short NotDevice
		lodsb
		call	PATHCHRCMP
		jnz	short NotDevice

ParseDev:				; ...
		push	ds
		push	si
		call	NameTrans
		cmp	byte ptr [si], 0
		stc
		jnz	short SkipSearch
		push	ss
		pop	ds
		mov	al, ds:SATTRIB
		mov	ds:ATTRIB, al
		call	DEVNAME

SkipSearch:				; ...
		pop	si
		pop	ds

CheckReturn:				; ...
		pop	di
		jnb	short Check_Done
		mov	si, di

Check_Done:				; ...
		pop	di
		cmc
		retn
; ---------------------------------------------------------------------------

NotDevice:				; ...
		stc
		jmp	short CheckReturn
CheckThisDevice	endp


; =============== S U B	R O U T	I N E =======================================


LookupPath	proc near		; ...
		test	ss:FastOpenFlg,	1 ; FastOpen_Set
		jnz	short FASTINST

NOLOOK:					; ...
		jmp	NOLOOKUP
; ---------------------------------------------------------------------------

FASTINST:				; ...
		test	ss:FastOpenFlg,	8 ; No_Lookup
		jnz	short NOLOOK
		mov	bx, offset FastOpenTable
		mov	si, ss:WFP_START
		mov	di, offset Dir_Info_Buff
		mov	cx, offset FastOpen_Ext_Info
		mov	al, 1
		push	ds
		pop	es
		call	dword ptr [bx+2] ; CALL	far [BX+fastopen_entry.name_caching]
		jb	short NOTFOUND
		lea	bx, [si-2]
		cmp	bx, ss:WFP_START
		jz	short NOTFOUND
		cmp	byte ptr [si], 0
		jnz	short parfnd
		push	cx
		mov	cl, ss:ATTRIB
		mov	ch, ss:SATTRIB
		mov	ss:ATTRIB, ch
		mov	ch, es:[di+0Bh]	; [ES:DI+dir_entry.dir_attr]
		call	MatchAttributes
		pop	cx
		jnz	short NOLOOKUP

parfnd:					; ...
		mov	ss:Next_Element_Start, si
		mov	bx, cx
		mov	ax, [bx+7]	; [BX+FEI.lastent]
		mov	ss:LASTENT, ax
		mov	ax, [bx+9]	; [BX+FEI.dirstart]
		mov	ss:DIRSTART, ax
		mov	ax, [bx+5]	; [BX+FEI.clusnum]
		mov	ss:CLUSNUM, ax
		push	es
		les	bx, ss:THISDPB
		mov	ah, es:[bx]	; [ES:BX+DPB.DRIVE]
		pop	es
		mov	word ptr ss:CURBUF, 0
		mov	word ptr ss:CURBUF+2, es
		mov	bx, di
		lea	si, [di+1Ah]	; [DI+dir_entry.dir_first]
		or	ss:FastOpenFlg,	12h ; Lookup_Success+Set_For_Search
		retn
; ---------------------------------------------------------------------------

NOTFOUND:				; ...
		cmp	ax, 0FFFFh	; -1
		jnz	short Partial_Success
		mov	ss:FastOpenFlg,	0

Partial_Success:			; ...
		and	ss:FastOpenFlg,	0FBh ; Special_Fill_Reset

NOLOOKUP:				; ...
		stc
		retn
LookupPath	endp


; =============== S U B	R O U T	I N E =======================================


InsertPath	proc near		; ...
		pushf
		test	ss:FastOpenFlg,	1 ; FastOpen_Set
		jz	short GET_NEXT_ELEMENT
		test	ss:FastOpenFlg,	2 ; Lookup_Success
		jz	short INSERT_DIR_INFO
		and	ss:FastOpenFlg,	0FDh ; Lookup_Reset
		mov	di, ss:Next_Element_Start
		jmp	short GET_NEXT2
; ---------------------------------------------------------------------------

INSERT_DIR_INFO:			; ...
		push	ds
		push	es
		push	bx
		push	si
		push	di
		push	cx
		push	ax
		lds	di, ss:CURBUF
		mov	si, offset FastOpen_Ext_Info
		mov	ax, [di+6]	; [DI+BUFFINFO.buf_sector]
		mov	ss:[si+1], ax	; [SS:SI+FEI.dirsec]
		mov	ax, [di+8]	; [DI+BUFFINFO.buf_sector+2]
		push	ss
		pop	ds
		mov	[si+3],	ax	; [SI+FEI.dirsec+2]
		mov	ax, ds:CLUSNUM
		mov	[si+5],	ax	; [SI+FEI.clusnum]
		mov	ax, ds:LASTENT
		mov	[si+7],	ax	; [SI+FEI.lastent]
		mov	ax, ds:DIRSTART
		mov	[si+9],	ax	; [SI+FEI.dirstart]
		mov	ax, bx
		add	di, 20		; BUFINSIZ
		sub	ax, di
		mov	cl, 32		; dir_entry.size
		div	cl
		mov	[si], al	; [SI+FEI.dirpos]
		push	ds
		pop	es
		mov	ds, word ptr ds:CURBUF+2
		mov	di, bx
		cmp	word ptr [di+26], 0 ; [DI+dir_entry.dir_first]
		jz	short SKIP_INSERT
		push	si
		pop	bx
		mov	al, 2		; FONC_insert
		mov	si, offset FastOpenTable
		call	dword ptr es:[si+2] ; CALL far [SI+fastopen_entry.name_caching]
		clc

SKIP_INSERT:				; ...
		pop	ax
		pop	cx
		pop	di
		pop	si
		pop	bx
		pop	es
		pop	ds

GET_NEXT2:				; ...
		or	ss:FastOpenFlg,	8 ; No_Lookup

GET_NEXT_ELEMENT:			; ...
		popf
		retn
InsertPath	endp

; ---------------------------------------------------------------------------
LenTab		db 22, 14, 22, 13, 15, 14 ; ...
					; DRDWRHL, DRDNDHL, DRDWRHL,
					; DSTATHL, DFLSHL, DRDNDHL
CmdTab		db 86h,	4		; ...
					; DEVRD	  ; 0 input
		db 86h,	5		; DEVRDND ; 1 input status
		db 87h,	8		; DEVWRT  ; 2 output
		db 87h,	0Ah		; DEVOST  ; 3 output status
		db 86h,	7		; DEVIFL  ; 4 input flush
		db 86h,	5		; 5 input status with system WAIT

; =============== S U B	R O U T	I N E =======================================


IOFUNC		proc near		; ...
		mov	word ptr ss:IOCTL_IOXAD_2, ss ;	[SS:IOXAD+2]
		mov	word ptr ss:IOCTL_REQ_MINORFUNCTION, offset DEVIOBUF ;
					; [SS:IOXAD],DEVIOBUF
		mov	word ptr ss:IOCTL_IOSCNT, 1 ; [SS:IOSCNT]
		mov	ss:DEVIOBUF, ax
		test	byte ptr [si+6], 80h ; [SI+SF_ENTRY.sf_flags+1],
					; (sf_isnet>>8)
		jz	short IOTO22
		jmp	IOTOFILE
; ---------------------------------------------------------------------------

IOTO22:					; ...
		test	byte ptr [si+5], 80h ; [SI+SF_ENTRY.sf_flags],
					; devid_device
		jnz	short IOTO33
		jmp	IOTOFILE
; ---------------------------------------------------------------------------

IOTO33:					; ...
		push	es
		call	save_world
		mov	dx, ds
		mov	bx, ss
		mov	ds, bx
		mov	es, bx
		xor	bx, bx
		cmp	ah, 5
		jnz	short no_sys_wait
		or	bx, 400h

no_sys_wait:				; ...
		mov	word ptr ds:IOCALL_REQSTAT, bx
		xor	bx, bx
		mov	ds:IOCTL_REQ_MAJORFUNCTION, bl ; [IOMED]
		mov	bl, ah
		mov	ah, cs:LenTab[bx] ; [cs:BX+LenTab]
		shl	bx, 1
		mov	cx, word ptr cs:CmdTab[bx] ; [cs:BX+CmdTab]
		mov	bx, offset IOCALL_REQLEN ; IOCALL ; DOSDATA:037Ch
		mov	ds:IOCALL_REQLEN, ah
		mov	ds:IOCALL_REQFUNC, ch
		mov	ds, dx
		call	DEVIOCALL
		mov	di, word ptr ss:IOCALL_REQSTAT
		and	di, di
		js	short DevErr

OKDevIO:				; ...
		mov	ax, ss
		mov	ds, ax
		cmp	ch, 5		; DEVRDND
		jnz	short DNODRD
		mov	al, ds:IOCTL_REQ_MAJORFUNCTION ; [IORCHR]
		mov	byte ptr ds:DEVIOBUF, al

DNODRD:					; ...
		mov	ah, ds:IOCALL_REQSTAT+1
		not	ah
		and	ah, 2		; STBUI>>8
		call	restore_world
		pop	es
		pushf
		mov	al, ss:IoStatFail
		cbw
		cmp	ax, -1		; 0FFFFh
		jnz	short not_fail_ret
		inc	ss:IoStatFail
		popf
		retn
; ---------------------------------------------------------------------------

not_fail_ret:				; ...
		mov	ax, ss:DEVIOBUF
		popf
		retn
; ---------------------------------------------------------------------------

DevErr:					; ...
		mov	ah, cl
		call	CHARHARD
		cmp	al, 1
		jnz	short NO_RETRY
		call	restore_world
		pop	es
		jmp	IOFUNC
; ---------------------------------------------------------------------------

NO_RETRY:				; ...
		and	ss:IOCALL_REQSTAT+1, 0FDh ; ~(STBUI>>8)
		cmp	al, 3
		jnz	short not_fail
		dec	ss:IoStatFail

not_fail:				; ...
		jmp	short OKDevIO
; ---------------------------------------------------------------------------

IOTOFILE:				; ...
		or	ah, ah
		jz	short IOIN
		dec	ah
		jz	short IOIST
		dec	ah
		jz	short IOUT
		retn
; ---------------------------------------------------------------------------

IOIST:					; ...
		push	word ptr [si+15h] ; [SI+SF_ENTRY.sf_position]
		push	word ptr [si+17h] ; [SI+SF_ENTRY.sf_position+2]
		call	IOIN
		pop	word ptr [si+17h]
		pop	word ptr [si+15h]
		retn
; ---------------------------------------------------------------------------

IOUT:					; ...
		call	SETXADDR
		call	DOS_WRITE
		call	RESTXADDR

IOUT_retn:				; ...
		retn
; ---------------------------------------------------------------------------

IOIN:					; ...
		call	SETXADDR
		or	ss:DOS34_FLAG, 40h ; Disable_EOF_I24
		call	DOS_READ
		and	ss:DOS34_FLAG, 0FFBFh ;	NO_Disable_EOF_I24
		or	cx, cx
		call	RESTXADDR
		mov	al, byte ptr ss:DEVIOBUF
		jnz	short IOUT_retn
		mov	al, 1Ah		; ^Z
		retn
IOFUNC		endp


; =============== S U B	R O U T	I N E =======================================


SETXADDR	proc near		; ...

; FUNCTION CHUNK AT 8529 SIZE 00000005 BYTES

		pop	ss:CALLSCNT
		push	es
		call	save_world
		push	word ptr ss:DMAADD
		push	word ptr ss:DMAADD+2
		mov	word ptr ss:THISSFT+2, ds
		push	ss
		pop	ds
		mov	word ptr ds:THISSFT, si
		mov	cx, word ptr ds:IOCTL_IOXAD_2 ;	[IOXAD+2]
		mov	word ptr ds:DMAADD+2, cx
		mov	cx, word ptr ds:IOCTL_REQ_MINORFUNCTION	; [IOXAD]
		mov	word ptr ds:DMAADD, cx
		mov	cx, word ptr ds:IOCTL_IOSCNT ; [IOCNT]
		jmp	short RESTRET
SETXADDR	endp

; ---------------------------------------------------------------------------

RESTXADDR:				; ...
		pop	ds:CALLSCNT
		pop	word ptr ds:DMAADD+2
		pop	word ptr ds:DMAADD
		call	restore_world
		pop	es
; START	OF FUNCTION CHUNK FOR SETXADDR

RESTRET:				; ...
		jmp	ss:CALLSCNT	; JMP WORD [SS:CALLSCNT]
; END OF FUNCTION CHUNK	FOR SETXADDR

; =============== S U B	R O U T	I N E =======================================


DEV_OPEN_SFT	proc near		; ...
		push	es
		call	save_world
		mov	al, 0Dh		; DEVOPN
		jmp	short DO_OPCLS
DEV_OPEN_SFT	endp


; =============== S U B	R O U T	I N E =======================================


DEV_CLOSE_SFT	proc near		; ...
		push	es
		call	save_world
		mov	al, 0Eh

DO_OPCLS:				; ...
		test	byte ptr es:[di+6], 80h	; [es:di+SF_ENTRY.sf_flags+1],
					; (sf_isnet>>8)
		jnz	short OPCLS_DONE
		xor	ah, ah
		test	byte ptr es:[di+5], 80h	; [ES:DI+SF_ENTRY.sf_flags],
					; devid_device
		les	di, es:[di+7]	; [ES:DI+SF_ENTRY.sf_devptr]
		jnz	short GOT_DEV_ADDR
		cmp	ss:fShare, 1
		jbe	short OPCLS_DONE
		mov	ah, es:[di+1]	; [ES:DI+DPB.UNIT]
		mov	cl, es:[di]	; [ES:DI+DPB.DRIVE]
		les	di, es:[di+13h]	; [ES:DI+DPB.DRIVER_ADDR]

GOT_DEV_ADDR:				; ...
		test	byte ptr es:[di+5], 8 ;	[ES:DI+SYSDEV.ATT+1],
					; (DEVOPCL>>8)
		jz	short OPCLS_DONE
		push	es
		pop	ds
		mov	si, di

OPCLS_RETRY:				; ...
		push	ss
		pop	es
		mov	di, offset DEVCALL
		mov	bx, di
		push	ax
		mov	al, 13		; DOPCLHL
		stosb
		pop	ax
		xchg	ah, al
		stosb
		xchg	ah, al
		stosb
		mov	word ptr es:[di], 0
		push	ax
		call	DEVIOCALL2
		mov	di, es:[bx+3]	; [ES:BX+SRHEAD.REQSTAT]
		and	di, di
		jns	short OPCLS_DONEP
		test	byte ptr [si+5], 80h ; [ES:DI+SYSDEV.ATT+1],
					; (DEVTYP>>8)
		jz	short BLKDEV
		mov	ah, 86h
		jmp	short HRDERR
; ---------------------------------------------------------------------------

BLKDEV:					; ...
		mov	al, cl
		mov	ah, 6

HRDERR:					; ...
		call	CHARHARD
		cmp	al, 1
		jnz	short OPCLS_DONEP
		pop	ax
		jmp	short OPCLS_RETRY
; ---------------------------------------------------------------------------

OPCLS_DONEP:				; ...
		pop	ax

OPCLS_DONE:				; ...
		call	restore_world
		pop	es
		retn
DEV_CLOSE_SFT	endp


; =============== S U B	R O U T	I N E =======================================


DEVIOCALL	proc near		; ...
		lds	si, [si+7]	; [SI+SF_ENTRY.sf_devptr]

DEVIOCALL2:				; ...
		call	ECritDevice
		test	byte ptr [si+5], 80h ; [si+SYSDEV.ATT+1],(DEVTYP>>8)
		jnz	short chardev2
		cmp	byte ptr es:[bx+2], 4 ;	[ES:BX+SRHEAD.REQFUNC],DEVRD
		jz	short chkext
		cmp	byte ptr es:[bx+2], 8 ;	[ES:BX+SRHEAD.REQFUNC],DEVWRT
		jz	short chkext
		cmp	byte ptr es:[bx+2], 9 ;	[ES:BX+SRHEAD.REQFUNC],DEVWRTV
		jnz	short chardev2

chkext:					; ...
		call	RW_SC
		jb	short dev_exit
		test	byte ptr [si+4], 2 ; [SI+SYSDEV.ATT],EXTDRVR
		jz	short chksector
		add	byte ptr es:[bx], 8
		mov	ax, ss:CALLSSEC
		mov	ss:CALLSSEC, 0FFFFh ; -1
		mov	word ptr ss:CALLNEWSC, ax
		mov	ax, ss:HIGH_SECTOR
		mov	word ptr ss:CALLNEWSC+2, ax
		jmp	short chardev2
; ---------------------------------------------------------------------------

chksector:				; ...
		cmp	ss:HIGH_SECTOR,	0
		jz	short chardev2
		mov	word ptr es:[bx+3], 8107h ; [ES:BX+SRHEAD.REQSTAT],
					; STERR+STDON+error_I24_not_DOS_disk
		jmp	short dev_exit
; ---------------------------------------------------------------------------

chardev2:				; ...
		mov	ax, [si+6]	; [SI+SYSDEV.STRAT]
		mov	word ptr ss:CALLDEVAD, ax
		mov	word ptr ss:CALLDEVAD+2, ds
		call	ss:CALLDEVAD
		mov	ax, [si+8]	; [SI+SYSDEV.INT]
		mov	word ptr ss:CALLDEVAD, ax
		call	ss:CALLDEVAD
		call	VIRREAD
		jb	short chardev2

dev_exit:				; ...
		call	LCritDevice
		retn
DEVIOCALL	endp


; =============== S U B	R O U T	I N E =======================================


SETREAD		proc near		; ...
		push	di
		push	cx
		push	ax
		mov	cl, 4		; DEVRD

SETCALLHEAD:				; ...
		mov	al, 16h		; DRDWRHL
		push	ss
		pop	es
		mov	di, offset DEVCALL
		stosb
		pop	ax
		stosb
		push	ax
		mov	al, cl
		stosb
		xor	ax, ax
		stosw
		add	di, 8
		pop	ax
		xchg	ah, al
		stosb
		xchg	al, ah
		push	ax
		mov	ax, bx
		stosw
		mov	ax, ds
		stosw
		pop	cx
		pop	ax
		stosw
		xchg	ax, dx
		stosw
		xchg	ax, cx
		xchg	dx, cx
		pop	di
		mov	bx, offset DEVCALL
		retn
SETREAD		endp


; =============== S U B	R O U T	I N E =======================================


SETWRITE	proc near		; ...
		push	di
		push	cx
		push	ax
		mov	cl, 8		; DEVWRT
		add	cl, ss:VERFLG
		jmp	short SETCALLHEAD
SETWRITE	endp


; =============== S U B	R O U T	I N E =======================================


RW_SC		proc near		; ...
		cmp	ss:SC_CACHE_COUNT, 0
		jz	short scexit4
		cmp	ss:CALLSCNT, 1
		jnz	short scexit4
		push	cx
		push	dx
		push	ds
		push	si
		push	es
		push	di
		mov	dx, ss:CALLSSEC
		cmp	ss:DEVCALL_REQFUNC, 4 ;	DEVRD
		jz	short doread
		call	INVALIDATE_SC
		jmp	scexit2
; ---------------------------------------------------------------------------

scexit4:				; ...
		clc
		retn
; ---------------------------------------------------------------------------

doread:					; ...
		call	SC2BUF
		jb	short readSC
		mov	ss:DEVCALL_REQSTAT, 100h ; STDON
		stc
		jmp	short saveseq
; ---------------------------------------------------------------------------

readSC:					; ...
		mov	ax, ss:HIGH_SECTOR
		mov	cx, ss:CALLSSEC
		sub	cx, word ptr ss:SEQ_SECTOR
		sbb	ax, word ptr ss:SEQ_SECTOR+2
		cmp	ax, 0
		jnz	short saveseq2
		cmp	cx, 1
		ja	short saveseq2
		mov	ss:SC_STATUS, 0FFFFh
		mov	ax, ss:SC_CACHE_COUNT
		mov	ss:CALLSCNT, ax
		mov	ax, word ptr ss:CALLXADD+2
		mov	ss:TEMP_VAR2, ax
		mov	ax, word ptr ss:CALLXADD
		mov	ss:TEMP_VAR, ax
		mov	ax, word ptr ss:SC_CACHE_PTR
		mov	word ptr ss:CALLXADD, ax
		mov	ax, word ptr ss:SC_CACHE_PTR+2
		mov	word ptr ss:CALLXADD+2,	ax
		mov	ss:SC_FLAG, 1
		mov	al, ss:SC_DRIVE
		mov	ss:CurSC_DRIVE,	al
		mov	ax, ss:CALLSSEC
		mov	word ptr ss:CurSC_SECTOR, ax
		mov	ax, ss:HIGH_SECTOR
		mov	word ptr ss:CurSC_SECTOR+2, ax

saveseq2:				; ...
		clc

saveseq:				; ...
		mov	ax, ss:HIGH_SECTOR
		mov	word ptr ss:SEQ_SECTOR+2, ax
		mov	ax, ss:CALLSSEC
		mov	word ptr ss:SEQ_SECTOR,	ax
		jmp	short scexit
; ---------------------------------------------------------------------------

scexit2:				; ...
		clc

scexit:					; ...
		pop	di
		pop	es
		pop	si
		pop	ds
		pop	dx
		pop	cx
		retn
RW_SC		endp


; =============== S U B	R O U T	I N E =======================================


IN_SC		proc near		; ...
		mov	al, ss:SC_DRIVE
		cmp	al, ss:CurSC_DRIVE
		jnz	short outrange2
		mov	ax, ss:HIGH_SECTOR
		mov	cx, dx
		sub	cx, word ptr ss:CurSC_SECTOR
		sbb	ax, word ptr ss:CurSC_SECTOR+2
		cmp	ax, 0
		jnz	short outrange2
		cmp	cx, ss:SC_CACHE_COUNT
		jnb	short outrange2
		clc
		jmp	short inexit
; ---------------------------------------------------------------------------

outrange2:				; ...
		stc

inexit:					; ...
		retn
IN_SC		endp


; =============== S U B	R O U T	I N E =======================================


INVALIDATE_SC	proc near		; ...
		call	IN_SC
		jb	short outrange
		mov	ax, 1
		shl	ax, cl
		not	ax
		and	ss:SC_STATUS, ax

outrange:				; ...
		retn
INVALIDATE_SC	endp


; =============== S U B	R O U T	I N E =======================================


VIRREAD		proc near		; ...
		cmp	ss:SC_FLAG, 0
		jz	short sc2end
		mov	ax, ss:TEMP_VAR2
		mov	word ptr ss:CALLXADD+2,	ax
		mov	ax, ss:TEMP_VAR
		mov	word ptr ss:CALLXADD, ax
		mov	ss:SC_FLAG, 0
		mov	ss:CALLSCNT, 1
		test	byte ptr ss:DEVCALL_REQSTAT+1, 80h ; (STERR>>8)
		jnz	short scerror
		push	ds
		push	si
		push	es
		push	di
		push	dx
		push	cx
		xor	cx, cx
		call	SC2BUF2
		pop	cx
		pop	dx
		pop	di
		pop	es
		pop	si
		pop	ds
		jmp	short sc2end
; ---------------------------------------------------------------------------

scerror:				; ...
		mov	ss:CALLSCNT, 1
		mov	ss:SC_STATUS, 0
		mov	ss:CurSC_DRIVE,	0FFh ; -1
		stc
		retn
; ---------------------------------------------------------------------------

sc2end:					; ...
		clc
		retn
VIRREAD		endp

; ---------------------------------------------------------------------------

SC2BUF:					; ...
		call	IN_SC
		jb	short noSC
		mov	ax, 1
		shl	ax, cl
		test	ss:SC_STATUS, ax
		jz	short noSC

SC2BUF2:				; ...
		mov	ax, cx
		mul	ss:SC_SECTOR_SIZE
		add	ax, word ptr ss:SC_CACHE_PTR
		adc	dx, word ptr ss:SC_CACHE_PTR+2
		mov	ds, dx
		mov	si, ax
		mov	es, word ptr ss:CALLXADD+2
		mov	di, word ptr ss:CALLXADD
		mov	cx, ss:SC_SECTOR_SIZE
		shr	cx, 1
		cmp	ss:DDMOVE, 0
		jz	short nodd
		shr	cx, 1
; ---------------------------------------------------------------------------
		db 66h			; rep movsd (dword move	prefix)
; ---------------------------------------------------------------------------

nodd:					; ...
		rep movsw
		clc
		retn
; ---------------------------------------------------------------------------

noSC:					; ...
		stc
		retn

; =============== S U B	R O U T	I N E =======================================


BUILDDIR	proc near		; ...
		mov	ax, ds:ENTFREE
		cmp	ax, 0FFFFh	; -1
		jz	short CHECK_IF_ROOT
		clc
		retn
; ---------------------------------------------------------------------------

CHECK_IF_ROOT:				; ...
		cmp	ds:DIRSTART, 0
		jnz	short NEWDIR
		stc

builddir_retn:				; ...
		retn
; ---------------------------------------------------------------------------

NEWDIR:					; ...
		mov	bx, ds:DIRSTART
		or	bx, bx
		jz	short NULLDIR
		call	GETEOF
		jb	short builddir_retn

NULLDIR:				; ...
		mov	cx, 1
		call	ALLOCATE
		jb	short builddir_retn
		mov	dx, ds:DIRSTART
		or	dx, dx
		jnz	short ADDINGDIR
		call	SETDIRSRCH
		jb	short builddir_retn
		mov	ds:LASTENT, 0FFFFh ; -1
		jmp	short GOTDIRREC
; ---------------------------------------------------------------------------

ADDINGDIR:				; ...
		push	bx
		mov	bx, ds:CLUSNUM
		call	IsEOF
		pop	bx
		jb	short NOTFIRSTGROW
		mov	ds:CLUSNUM, bx
		push	cx
		push	ax
		push	bp
		mov	ah, 1
		mov	dl, es:[bp+0]	; [ES:BP+DPB.DRIVE]
		mov	cx, ds:DIRSTART
		mov	bp, bx
		call	FastOpen_Update
		pop	bp
		pop	ax
		pop	cx

NOTFIRSTGROW:				; ...
		mov	dx, bx
		xor	bl, bl
		call	FIGREC

GOTDIRREC:				; ...
		mov	cl, es:[bp+4]	; [ES:BP+DPB.CLUSTER_MASK]
		inc	cl
		xor	ch, ch

ZERODIR:				; ...
		push	cx
		mov	ds:ALLOWED, 18h	; Allowed_FAIL+Allowed_RETRY
		mov	al, 0FFh
		call	GETBUFFR
		jnb	short GET_SSIZE
		pop	cx
		retn
; ---------------------------------------------------------------------------

GET_SSIZE:				; ...
		mov	cx, es:[bp+2]	; [ES:BP+DPB.SECTOR_SIZE]
		push	es
		les	di, ds:CURBUF
		or	byte ptr es:[di+5], 4 ;	[ES:DI+BUFFINFO.buf_flags],
					; buf_isDIR
		push	di
		add	di, 20		; BUFINSIZ
		xor	ax, ax
		shr	cx, 1
		rep stosw
		jnb	short EVENZ
		stosb

EVENZ:					; ...
		pop	di
		test	byte ptr es:[di+5], 40h	; [ES:DI+BUFFINFO.buf_flags],
					; buf_dirty
		jnz	short yesdirty7
		call	INC_DIRTY_COUNT
		or	byte ptr es:[di+5], 40h

yesdirty7:				; ...
		pop	es
		pop	cx
		add	dx, 1
		adc	ds:HIGH_SECTOR,	0
		loop	ZERODIR
		mov	ax, ds:LASTENT
		inc	ax
		clc
		retn
BUILDDIR	endp


; =============== S U B	R O U T	I N E =======================================


SETDOTENT	proc near		; ...
		stosw
		mov	cx, 4
		mov	ax, 2020h	; '  '
		rep stosw
		stosb
		mov	al, 10h		; attr_directory
		stosb
		add	di, 10
		mov	si, word ptr ds:THISSFT
		mov	ax, [si+0Dh]	; [SI+SF_ENTRY.sf_time]
		stosw
		mov	ax, [si+0Fh]	; [SI+SF_ENTRY.sf_date]
		stosw
		mov	ax, dx
		stosw
		xor	ax, ax
		stosw
		stosw
		retn
SETDOTENT	endp

; ---------------------------------------------------------------------------

MakeNode:				; ...
		mov	word ptr ds:CREATING, 0E5FFh ; DIRFREE*256 + 0FFh
		push	ax
		mov	ds:NoSetDir, 0
		mov	ds:SATTRIB, al
		call	GetPathNoSet
		mov	dl, cl
		mov	cx, ax
		pop	ax
		jnb	short make_exists
		jnz	short make_err_4
		cmp	dl, 80h
		jz	short RENAME_MAKE ; make_type

make_err_4:				; ...
		mov	al, 4

make_err_ret:				; ...
		xor	ah, ah
		stc
		retn
; ---------------------------------------------------------------------------

RENAME_MAKE:				; ...
		test	ds:EXTOPEN_ON, 1 ; make_type
					; EXT_OPEN_ON
		jz	short make_type2
		or	ds:EXTOPEN_ON, 4 ; EXT_FILE_NOT_EXISTS
		test	byte ptr ds:EXTOPEN_FLAG, 0F0h
		jnz	short make_type2
		stc
		mov	ax, 7

; =============== S U B	R O U T	I N E =======================================


make_retn	proc near		; ...
		retn
make_retn	endp

; ---------------------------------------------------------------------------

make_type2:				; ...
		les	di, ds:THISSFT
		xor	ax, ax
		stc
		jmp	short make_new
; ---------------------------------------------------------------------------

make_exists:				; ...
		jz	short make_exists_dir
		mov	al, 3
		test	ds:ATTRIB, 18h	; attr_volume_id+attr_directory
		jnz	short make_err_ret_5
		or	ch, ch
		js	short make_share
		or	ah, ah
		jnz	short make_err_ret
		push	cx
		mov	es, word ptr ds:CURBUF+2
		mov	ch, es:[bx+0Bh]	; [ES:BX+dir_entry.dir_attr]
		test	ch, 1
		jnz	short make_err_ret_5P
		call	MatchAttributes
		pop	cx
		jnz	short make_err_ret_5
		xor	al, al

make_share:				; ...
		xor	ah, ah
		push	ax
		push	cx
		mov	ah, ch
		call	DOOPEN
		les	di, ds:THISSFT
		push	si
		push	bx
		call	ShareEnter
		jnb	short MakeEndShare
		pop	bx
		pop	si
		pop	cx
		pop	ax

Make_Share_ret:				; ...
		mov	al, 6
		jmp	short make_err_ret
; ---------------------------------------------------------------------------

make_err_ret_5P:			; ...
		pop	cx

make_err_ret_5:				; ...
		mov	al, 5
		jmp	short make_err_ret
; ---------------------------------------------------------------------------

make_exists_dir:			; ...
		mov	al, 1
		jmp	short make_err_ret

; =============== S U B	R O U T	I N E =======================================


make_save	proc near		; ...
		push	ax
		mov	ax, cx
		call	NEWENTRY
		pop	ax
		jnb	short make_retn
		mov	al, 2

make_save_retn:				; ...
		retn
make_save	endp

; ---------------------------------------------------------------------------

make_new:				; ...
		call	make_save
		jb	short make_save_retn
		test	ds:ATTRIB, 10h	; attr_directory
		jnz	short make_save_retn
		push	ax
		push	bx
		push	si
		call	ShareEnter
		pop	si
		pop	bx
		pop	ax
		jnb	short make_save_retn
		push	ax
		les	di, ds:CURBUF
		mov	byte ptr es:[bx], 0E5h ; DIRFREE
		test	byte ptr es:[di+5], 40h	; [ES:DI+BUFFINFO.buf_flags],
					; buf_dirty
		jnz	short yesdirty8
		call	INC_DIRTY_COUNT
		or	byte ptr es:[di+5], 40h

yesdirty8:				; ...
		les	bp, ds:THISDPB
		mov	al, es:[bp+0]	; [ES:BP+DPB.DRIVE]
		call	FLUSHBUF
		pop	ax
		jmp	short Make_Share_ret
; ---------------------------------------------------------------------------

MakeEndShare:				; ...
		les	di, ds:THISSFT
		xor	ax, ax
		call	ECritDisk	; call ECritSFT
		xchg	ax, es:[di]	; [ES:DI+SF_ENTRY.sf_ref_count]
		push	ax
		push	di
		push	es
		pushf
		call	ShareEnd
		popf
		pop	es
		pop	di
		pop	word ptr es:[di] ; [ES:DI+SF_ENTRY.sf_ref_count]
		call	LCritDisk	; call LCritSFT
		pop	bx
		pop	si
		pop	cx
		pop	ax
		call	make_save
		jb	short make_save_retn
		push	ax
		push	bx
		push	si
		pushf
		call	ShareEnter
		popf
		pop	si
		pop	bx
		pop	ax

makeendshare_retn:			; ...
		retn

; =============== S U B	R O U T	I N E =======================================


NEWENTRY	proc near		; ...
		les	bp, ds:THISDPB
		jnb	short EXISTENT
		cmp	ds:FAILERR, 0
		stc
		jnz	short makeendshare_retn
		call	BUILDDIR
		jb	short makeendshare_retn
		call	GETENT
		jb	short makeendshare_retn
		jmp	short FREESPOT
; ---------------------------------------------------------------------------

ERRRET3:				; ...
		stc

newentry_retn:				; ...
		retn
; ---------------------------------------------------------------------------

EXISTENT:				; ...
		or	ah, ah
		jns	short NOT_DEV1
		jmp	DOOPEN
; ---------------------------------------------------------------------------

NOT_DEV1:				; ...
		call	FREEENT
		jb	short newentry_retn

FREESPOT:				; ...
		test	ds:ATTRIB, 8	; attr_volume_id
		jz	short NOTVOLID
		cmp	ds:VOLID, 0
		jnz	short ERRRET3

NOTVOLID:				; ...
		mov	es, word ptr ds:CURBUF+2
		mov	di, bx
		mov	si, offset NAME1
		mov	cx, 5
		rep movsw
		movsb
		mov	al, ds:ATTRIB
		stosb
		mov	cl, 5
		xor	ax, ax
		rep stosw
		call	DATE16
		xchg	ax, dx
		stosw
		xchg	ax, dx
		stosw
		xor	ax, ax
		push	di
		stosw
		stosw
		stosw
		mov	si, word ptr ds:CURBUF
		test	byte ptr es:[si+5], 40h	; [ES:SI+BUFFINFO.buf_flags],
					; buf_dirty
		jnz	short yesdirty9
		call	INC_DIRTY_COUNT
		or	byte ptr es:[si+5], 40h

yesdirty9:				; ...
		les	bp, ds:THISDPB
		mov	al, es:[bp+0]	; [ES:BP+DPB.DRIVE]
		push	ax
		push	bx
		push	es
		push	di
		les	di, ds:THISSFT
		test	byte ptr es:[di+5], 80h	; [ES:DI+SF_ENTRY.sf_flags],
					; devid_device
		jnz	short GotADevice
		push	ds
		push	bx
		lds	bx, ds:THISDPB
		mov	es:[di+7], bx	; [ES:DI+SF_ENTRY.sf_devptr]
		mov	bx, ds
		mov	es:[di+9], bx	; [ES:DI+SF_ENTRY.sf_devptr+2]
		pop	bx
		pop	ds
		call	DEV_OPEN_SFT
		mov	ds:VIRTUAL_OPEN, 1

GotADevice:				; ...
		pop	di
		pop	es
		call	FLUSHBUF
		call	CHECK_VIRT_OPEN
		pop	bx
		pop	ax
		pop	si
		mov	ah, al
		jnb	short DOOPEN
		retn
NEWENTRY	endp


; =============== S U B	R O U T	I N E =======================================


DOOPEN		proc near		; ...
		mov	dh, ah
		les	di, ds:THISSFT
		add	di, 4		; SF_ENTRY.sf_attr
		xor	al, al
		or	dh, dh
		js	short DEV_SFT
		mov	ds, word ptr ds:CURBUF+2
		mov	al, [bx+0Bh]	; [BX+dir_entry.dir_attr]

DEV_SFT:				; ...
		stosb
		xor	ax, ax
		mov	al, dh
		or	al, 40h		; devid_file_clean
		stosw
		push	ds
		lds	ax, [bx+1Ah]	; [BX+dir_entry.dir_first]
		or	dh, dh
		js	short DEV_SFT2
		lds	ax, ss:THISDPB

DEV_SFT2:				; ...
		stosw
		mov	ax, ds
		pop	ds
		stosw
		push	si
		movsw
		sub	si, 6		; dir_entry.dir_size_l - dir_entry.dir_time
		movsw
		movsw
		lodsw
		lodsw
		mov	cx, ax
		lodsw
		or	dh, dh
		jns	short FILE_SFT1
		xor	ax, ax
		mov	cx, ax

FILE_SFT1:				; ...
		xchg	ax, cx
		stosw
		xchg	ax, cx
		stosw
		xor	ax, ax
		stosw
		stosw
		or	dh, dh
		js	short DEV_SFT3
		stosw
		mov	ax, [bx+1Ah]	; [BX+dir_entry.dir_first]
		push	di
		sub	di, 1Bh		; SF_ENTRY.sf_dirsec
		mov	es:[di+35h], ax	; [ES:DI+SF_ENTRY.sf_lstclus]
		pop	di
		push	ds
		push	ss
		pop	ds
		test	ds:FastOpenFlg,	4 ; Special_Fill_Set
		jz	short Not_FastOpen
		mov	si, offset FastOpen_Ext_Info
		mov	ax, [si+1]	; [SI+FEI.dirsec]
		stosw
		mov	ax, [si+3]	; [SI+FEI.dirsec+2]
		stosw
		mov	al, [si]	; [SI+FEI.dirpos]
		stosb
		pop	ds
		jmp	short Next_Name
; ---------------------------------------------------------------------------

Not_FastOpen:				; ...
		pop	ds
		mov	si, word ptr ss:CURBUF
		mov	ax, [si+6]	; [SI+BUFFINFO.buf_sector]
		stosw
		mov	ax, [si+8]	; [SI+BUFFINFO.buf_sector+2]
		stosw
		mov	ax, bx
		add	si, 20		; BUFINSIZ
		sub	ax, si
		mov	cl, 32		; dir_entry.size
		div	cl
		stosb

Next_Name:				; ...
		jmp	short FILE_SFT2
; ---------------------------------------------------------------------------

DEV_SFT3:				; ...
		add	di, 7		; SF_ENTRY.sf_name-SF_ENTRY.sf_cluspos

FILE_SFT2:				; ...
		mov	si, bx
		mov	cx, 11
		rep movsb
		pop	si
		push	ss
		pop	ds
		clc
		retn
DOOPEN		endp


; =============== S U B	R O U T	I N E =======================================


FREEENT		proc near		; ...
		push	ds
		lds	di, ds:CURBUF
		mov	cx, [si]
		mov	dx, [di+8]	; [DI+BUFFINFO.buf_sector+2]
		mov	ss:HIGH_SECTOR,	dx
		mov	dx, [di+6]	; [DI+BUFFINFO.buf_sector]
		pop	ds
		cmp	cx, 2
		jb	short RET1
		cmp	cx, es:[bp+0Dh]	; [ES:BP+DPB.MAX_CLUSTER]
		ja	short RET1
		sub	bx, di
		push	bx
		push	ds:HIGH_SECTOR
		push	dx
		mov	bx, cx
		call	RELEASE
		pop	dx
		pop	ds:HIGH_SECTOR
		jnb	short GET_BUF_BACK
		pop	bx

freeent_retn:				; ...
		retn
; ---------------------------------------------------------------------------

GET_BUF_BACK:				; ...
		mov	ds:ALLOWED, 18h	; Allowed_RETRY+Allowed_FAIL
		xor	al, al
		call	GETBUFFR
		pop	bx
		jb	short freeent_retn
		call	SET_BUF_AS_DIR
		add	bx, ds:5E2h
		mov	si, bx
		add	si, 1Ah

RET1:					; ...
		clc
		retn
FREEENT		endp


; =============== S U B	R O U T	I N E =======================================


CHECK_VIRT_OPEN	proc near		; ...
		push	ax
		lahf
		cmp	ds:VIRTUAL_OPEN, 0
		jz	short ALL_CLOSED
		mov	ds:VIRTUAL_OPEN, 0
		push	es
		push	di
		les	di, ds:THISSFT
		call	DEV_CLOSE_SFT
		pop	di
		pop	es

ALL_CLOSED:				; ...
		sahf
		pop	ax
		retn
CHECK_VIRT_OPEN	endp


; =============== S U B	R O U T	I N E =======================================


FNDCLUS		proc near		; ...
		push	es
		les	di, ds:THISSFT
		mov	bx, es:[di+35h]	; [ES:DI+SF_ENTRY.sf_lstclus]
		mov	dx, es:[di+19h]	; [ES:DI+SF_ENTRY.sf_cluspos]
		or	bx, bx
		jz	short NOCLUS
		sub	cx, dx
		jnb	short FINDIT
		add	cx, dx
		xor	dx, dx
		mov	bx, es:[di+0Bh]	; [ES:DI+SF_ENTRY.sf_firclus]

FINDIT:					; ...
		pop	es
		jcxz	short RET9

SKPCLP:					; ...
		call	UNPACK
		jb	short fndclus_retn
		xchg	bx, di
		call	IsEOF
		xchg	bx, di
		jnb	short RET9
		xchg	bx, di
		inc	dx
		loop	SKPCLP

RET9:					; ...
		clc
		retn
; ---------------------------------------------------------------------------

NOCLUS:					; ...
		pop	es
		inc	cx
		dec	dx
		clc

fndclus_retn:				; ...
		retn
FNDCLUS		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn

BUFSEC		proc near		; ...
		mov	dx, ds:CLUSNUM
		mov	bl, ds:SECCLUSPOS
		mov	ds:ALLOWED, 38h	; Allowed_FAIL+Allowed_RETRY+Allowed_IGNORE
		call	FIGREC
		call	GETBUFFR
		jb	short fndclus_retn
		mov	ds:TRANS, 1
		mov	si, ds:NEXTADD
		mov	di, si
		mov	cx, ds:BYTCNT1
		add	di, cx
		mov	ds:NEXTADD, di
		les	di, ds:CURBUF
		or	byte ptr es:[di+5], 8 ;	[ES:DI+BUFFINFO.buf_flags],
					; buf_isDATA
		lea	di, [di+20]	;  LEA DI,[DI+BUFINSIZ]
		add	di, ds:BYTSECPOS
		clc
		retn
BUFSEC		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn

BUFRD		proc near		; ...
		push	es
		xor	ax, ax
		call	BUFSEC
BUFRD		endp

; ---------------------------------------------------------------------------
		jnb	short BUF_OK
; START	OF FUNCTION CHUNK FOR BUFWRT

BUF_IO_FAIL:				; ...
		pop	es
		jmp	short RBUFPLACED
; END OF FUNCTION CHUNK	FOR BUFWRT
; ---------------------------------------------------------------------------

BUF_OK:					; ...
		mov	bx, es
		mov	es, word ptr ds:DMAADD+2
		mov	ds, bx
		xchg	di, si
		shr	cx, 1
		rep movsw
		adc	cx, 0
		rep movsb

EVENRD:
		pop	es
		lds	di, ss:CURBUF
		lea	bx, [di+20]	; LEA BX,[DI+BUFINSIZ]
		sub	si, bx
		call	PLACEBUF
		cmp	si, es:[bp+2]	; [ES:BP+DPB.SECTOR_SIZE]
		jb	short RBUFPLACEDC
		mov	word ptr ss:BufferQueue, di

RBUFPLACEDC:				; ...
		clc
; START	OF FUNCTION CHUNK FOR BUFWRT

RBUFPLACED:				; ...
		push	ss
		pop	ds
		retn
; END OF FUNCTION CHUNK	FOR BUFWRT

; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn

BUFWRT		proc near		; ...

; FUNCTION CHUNK AT 8C35 SIZE 00000003 BYTES
; FUNCTION CHUNK AT 8C65 SIZE 00000003 BYTES

		mov	ax, word ptr ds:SECPOS
		add	ax, 1
		mov	word ptr ds:SECPOS, ax
		adc	word ptr ds:SECPOS+2, 0
		mov	ax, word ptr ds:SECPOS+2
		cmp	ax, word ptr ds:VALSEC+2
		mov	al, 1
		ja	short NOREAD
		jb	short _doread
		mov	ax, word ptr ds:SECPOS
		cmp	ax, word ptr ds:VALSEC
		mov	al, 1
		ja	short NOREAD

_doread:				; ...
		xor	al, al

NOREAD:					; ...
		push	es
		call	BUFSEC
; ---------------------------------------------------------------------------
		jb	short BUF_IO_FAIL
		mov	ds, word ptr ds:DMAADD+2
		shr	cx, 1
		rep movsw
		adc	cx, 0
		rep movsb

EVENWRT:
		pop	es
		lds	bx, ss:CURBUF
		test	byte ptr [bx+5], 40h
		jnz	short yesdirty10
		call	INC_DIRTY_COUNT
		or	byte ptr [bx+5], 40h ; [BX+BUFFINFO.buf_flags],
					; buf_dirty

yesdirty10:				; ...
		lea	si, [bx+20]	; LEA BX,[BX+BUFINSIZ]
		sub	di, si
		cmp	di, es:[bp+2]	; [ES:BP+DPB.SECTOR_SIZE]
		jb	short WBUFPLACED
		mov	word ptr ss:BufferQueue, bx

WBUFPLACED:				; ...
		clc
		push	ss
		pop	ds
		retn
BUFWRT		endp


; =============== S U B	R O U T	I N E =======================================


NEXTSEC		proc near		; ...
		test	ds:TRANS, 0FFh	; -1
		jz	short CLRET
		mov	al, ds:SECCLUSPOS
		inc	al
		cmp	al, es:[bp+4]	; [ES:BP+DPB.CLUSTER_MASK]
		jbe	short SAVPOS
		mov	bx, ds:CLUSNUM
		call	IsEOF
		jnb	short NONEXT
		call	UNPACK
		jb	short NONEXT
		mov	ds:CLUSNUM, di
		inc	ds:LASTPOS
		mov	al, 0

SAVPOS:					; ...
		mov	ds:SECCLUSPOS, al

CLRET:					; ...
		clc
		retn
; ---------------------------------------------------------------------------

NONEXT:					; ...
		stc
		retn
NEXTSEC		endp


; =============== S U B	R O U T	I N E =======================================


OPTIMIZE	proc near		; ...
		push	dx
		push	bx
		mov	al, es:[bp+4]	; [ES:BP+DPB.CLUSTER_MASK]
		inc	al
		mov	ah, al
		sub	al, dl
		mov	dx, cx
		mov	cx, 0

do_norm3:				; ...
		call	UNPACK		; OPTCLUS
		jb	short OP_ERR
		add	cl, al
		adc	ch, 0
		cmp	cx, dx
		jnb	short BLKDON
		mov	al, ah
		inc	bx
		cmp	di, bx
		jz	short do_norm3	; OPTCLUS
		dec	bx

FINCLUS:				; ...
		mov	ds:CLUSNUM, bx
		sub	dx, cx
		push	dx
		mov	ax, cx
		mul	word ptr es:[bp+2] ; [ES:BP+DPB.SECTOR_SIZE]
		mov	si, ds:NEXTADD
		add	ax, si
		mov	ds:NEXTADD, ax
		pop	ax
		pop	dx
		sub	bx, dx
		add	ds:LASTPOS, bx
		pop	bx
		call	FIGREC
		mov	bx, si
		clc
		retn
; ---------------------------------------------------------------------------

OP_ERR:					; ...
		add	sp, 4
		stc
		retn
; ---------------------------------------------------------------------------

BLKDON:					; ...
		sub	cx, dx
		sub	ah, cl
		dec	ah
		mov	ds:SECCLUSPOS, ah
		mov	cx, dx
		jmp	short FINCLUS
OPTIMIZE	endp


; =============== S U B	R O U T	I N E =======================================


FIGREC		proc near		; ...
		push	cx
		mov	cl, es:[bp+5]	; [ES:BP+DPB.CLUSTER_SHIFT]
		dec	dx
		dec	dx
		mov	ss:HIGH_SECTOR,	0
		or	cl, cl
		jz	short noshift
		xor	ch, ch

rotleft:				; ...
		clc
		rcl	dx, 1
		rcl	ss:HIGH_SECTOR,	1
		loop	rotleft

noshift:				; ...
		or	dl, bl
		add	dx, es:[bp+0Bh]	; [ES:BP+DPB.FIRST_SECTOR]
		adc	ss:HIGH_SECTOR,	0
		pop	cx

figrec_retn:				; ...
		retn
FIGREC		endp


; =============== S U B	R O U T	I N E =======================================


ALLOCATE	proc near		; ...
		push	bx
		xor	bx, bx
		call	UNPACK
		mov	ds:FATBYT, di
		pop	bx
		jb	short figrec_retn
		push	cx
		push	bx
		mov	dx, bx
		mov	bx, es:[bp+1Dh]	; [ES:BP+DPB.NEXT_FREE]
		cmp	bx, 2
		ja	short FINDFRE

ads1:					; ...
		mov	word ptr es:[bp+1Dh], 2	; [ES:BP+DPB.NEXT_FREE]
		mov	bx, 1

FINDFRE:				; ...
		inc	bx
		cmp	bx, es:[bp+0Dh]	; [ES:BP+DPB.MAX_CLUSTER]
		ja	short ads7
		call	UNPACK
		jb	short ads4
		jnz	short FINDFRE
		mov	es:[bp+1Dh], bx	; [ES:BP+DPB.NEXT_FREE]
		xchg	ax, dx
		mov	dx, 1
		call	PACK
		jb	short ads4
		cmp	word ptr es:[bp+1Fh], 0FFFFh ; [ES:BP+DPB.FREE_CNT],-1
		jz	short NO_ALLOC
		dec	word ptr es:[bp+1Fh] ; [ES:BP+DPB.FREE_CNT]

NO_ALLOC:				; ...
		xchg	ax, dx
		xchg	bx, dx
		mov	ax, dx
		call	PACK
		jb	short ads4
		xchg	ax, bx
		mov	dx, bx
		loop	FINDFRE
		mov	dx, 0FFFFh
		call	PACK

ads4:					; ...
		pop	bx
		pop	cx
		jb	short figrec_retn
		call	UNPACK
		jb	short figrec_retn
		call	RESTFATBYT
		jb	short figrec_retn
		xchg	bx, di
		or	di, di
		jnz	short figrec_retn
		push	dx
		mov	dl, es:[bp+0]	; [ES:BP+DPB.DRIVE]
		push	es
		les	di, ds:THISSFT
		mov	es:[di+0Bh], bx	; [ES:DI+SF_ENTRY.sf_firclus]
		mov	es:[di+35h], bx	; [ES:DI+SF_ENTRY.sf_lstclus]
		pop	es
		pop	dx
		retn
; ---------------------------------------------------------------------------

ads7:					; ...
		cmp	word ptr es:[bp+1Dh], 2	; [ES:BP+DPB.NEXT_FREE]
		jnz	short ads1
		pop	bx
		mov	dx, 0FFFFh
		call	RELBLKS
		pop	ax
		sub	ax, cx
		call	RESTFATBYT
		mov	ds:DISK_FULL, 1
		stc
		retn
ALLOCATE	endp


; =============== S U B	R O U T	I N E =======================================


RESTFATBYT	proc near		; ...
		push	bx
		push	dx
		push	di
		xor	bx, bx
		mov	dx, ds:FATBYT
		call	PACK
		pop	di
		pop	dx
		pop	bx

RELEASE_flush:				; ...
		retn
RESTFATBYT	endp


; =============== S U B	R O U T	I N E =======================================


RELEASE		proc near		; ...
		xor	dx, dx

RELBLKS:				; ...
		call	UNPACK
		jb	short RELEASE_flush
		jz	short RELEASE_flush
		mov	ax, di
		push	dx
		call	PACK
		pop	dx
		jb	short RELEASE_flush
		or	dx, dx
		jnz	short NO_DEALLOC
		cmp	word ptr es:[bp+1Fh], 0FFFFh
		jz	short NO_DEALLOC
		inc	word ptr es:[bp+1Fh]

NO_DEALLOC:				; ...
		mov	bx, ax
		dec	ax
		jz	short RELEASE_flush
		call	IsEOF
		jb	short RELEASE

RET12:					; ...
		retn
RELEASE		endp


; =============== S U B	R O U T	I N E =======================================


GETEOF		proc near		; ...
		call	UNPACK
		jb	short RET12
		push	bx
		mov	bx, di
		call	IsEOF
		pop	bx
		jnb	short RET12
		mov	bx, di
		jmp	short GETEOF
GETEOF		endp


; =============== S U B	R O U T	I N E =======================================


MAKEFCB		proc near		; ...
		mov	ss:SpaceFlag, 0
		xor	dl, dl
		test	al, 2		; DRVBIT
		jnz	short DEFDRV
		mov	byte ptr es:[di], 0

DEFDRV:					; ...
		inc	di
		mov	cx, 8
		test	al, 4		; NAMBIT
		xchg	ax, bx
		mov	al, 20h	; ' '
		jz	short FILLB
		add	di, cx
		xor	cx, cx

FILLB:					; ...
		rep stosb
		mov	cl, 3
		test	bl, 8		; EXTBIT
		jz	short FILLB2
		add	di, cx
		xor	cx, cx

FILLB2:					; ...
		rep stosb
		xchg	ax, cx
		stosw
		stosw
		sub	di, 16
		test	bl, 1		; SCANSEPARATOR
		jz	short SKPSPC
		call	SCANB
		call	DELIM
		jnz	short NOSCAN
		inc	si

SKPSPC:					; ...
		call	SCANB

NOSCAN:					; ...
		call	GETLET
		jbe	short NODRV
		cmp	byte ptr [si], ':'
		jnz	short NODRV
		inc	si
		sub	al, '@'
		jbe	short BADDRV
		push	ax
		call	GetVisDrv
		pop	ax
		jnb	short HAVDRV
		cmp	ss:DrvErr, 1Ah	; error_not_DOS_disk
		jz	short HAVDRV

BADDRV:					; ...
		mov	dl, 0FFh	; -1

HAVDRV:					; ...
		stosb
		inc	si
		dec	di

NODRV:					; ...
		dec	si
		inc	di

NORMSCAN:				; ...
		mov	cx, 8
		call	GETWORD
		cmp	byte ptr [si], '.'
		jnz	short NODOT
		inc	si
		test	byte ptr ss:DOS34_FLAG+1, 1 ; (DBCS_VOLID2>>8)
		jz	short VOLOK
		movsb
		mov	cx, 2
		jmp	short contvol
; ---------------------------------------------------------------------------

VOLOK:					; ...
		mov	cx, 3

contvol:				; ...
		call	MUSTGETWORD

NODOT:					; ...
		mov	al, dl
		and	ss:DOS34_FLAG, 0FEFFh ;	~DBCS_VOLID2
		retn
MAKEFCB		endp

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR GETWORD

NONAM:					; ...
		add	di, cx
		dec	si
		retn
; END OF FUNCTION CHUNK	FOR GETWORD

; =============== S U B	R O U T	I N E =======================================


GETWORD		proc near		; ...

; FUNCTION CHUNK AT 8F0B SIZE 00000004 BYTES

		call	GETLET
		jbe	short NONAM
		dec	si

MUSTGETWORD:				; ...
		call	GETLET
		jnz	short MustCheckCX
		test	ss:SpaceFlag, 0FFh
		jz	short FILLNAM
		cmp	al, 20h	; ' '
		jnz	short FILLNAM

MustCheckCX:				; ...
		jcxz	short MUSTGETWORD
		dec	cx
		cmp	al, 2Ah	; '*'
		jnz	short NOSTAR
		mov	al, 3Fh	; '?'
		rep stosb

NOSTAR:					; ...
		stosb
		cmp	al, 3Fh	; '?'
		jnz	short MUSTGETWORD
		or	dl, 1
		jmp	short MUSTGETWORD
; ---------------------------------------------------------------------------

FILLNAM:				; ...
		mov	al, 20h	; ' '
		rep stosb
		dec	si
		retn
GETWORD		endp


; =============== S U B	R O U T	I N E =======================================


SCANB		proc near		; ...
		lodsb
		call	SPCHK
		jz	short SCANB
		dec	si

scanb_retn:				; ...
		retn
SCANB		endp


; =============== S U B	R O U T	I N E =======================================


NameTrans	proc near		; ...
		mov	ss:SpaceFlag, 1
		push	ss
		pop	es
		mov	di, offset NAME1
		push	di
		mov	ax, 2020h	; '  '
		mov	cx, 5
		stosb
		rep stosw
		xor	al, al
		mov	dl, al
		stosb
		pop	di
		call	NORMSCAN
		cmp	ss:NAME1, 0E5h
		jnz	short scanb_retn
		mov	ss:NAME1, 5
		retn
NameTrans	endp

; ---------------------------------------------------------------------------
CharType	db 66h,66h,66h,66h, 6,66h,66h,66h ; ...
		db 66h,66h,66h,66h,66h,66h,66h,66h
		db 0F8h,0F6h,0FFh,0FFh,0FFh,4Fh,0F4h,6Eh
		db 0FFh,0FFh,0FFh,0FFh,0FFh,44h,44h,0F4h
		db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
		db 0FFh,0FFh,0FFh,0FFh,0FFh,6Fh,66h,0FFh
		db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
		db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0F4h
; ---------------------------------------------------------------------------

GETLET:					; ...
		lodsb

; =============== S U B	R O U T	I N E =======================================


UCase		proc near		; ...
		push	bx
		mov	bx, offset FILE_UCASE_TAB_2 ; FILE_UCASE_TAB+2

gl_0:					; ...
		cmp	al, 'a'         ; 61h
		jb	short gl_2
		cmp	al, 'z'         ; 7Ah
		ja	short gl_1
		sub	al, 20h

gl_1:					; ...
		cmp	al, 80h
		jb	short gl_2
		sub	al, 80h
		push	ds
		mov	ds, cs:DosDSeg
		xlat
		pop	ds

gl_2:					; ...
		push	ax
		call	GetCharType
		test	al, 1		; FCHK
		pop	ax
		pop	bx
		retn
UCase		endp


; =============== S U B	R O U T	I N E =======================================


GETLET3		proc near		; ...
		push	bx
		jmp	short gl_0
GETLET3		endp


; =============== S U B	R O U T	I N E =======================================


DELIM		proc near		; ...
		push	ax
		call	GetCharType
		test	al, 2		; FDELIM
		pop	ax
		retn
DELIM		endp


; =============== S U B	R O U T	I N E =======================================


SPCHK		proc near		; ...
		push	ax
		call	GetCharType
		test	al, 4		; FSPCHK
		pop	ax
		retn
SPCHK		endp


; =============== S U B	R O U T	I N E =======================================


GetCharType	proc near		; ...
		cmp	al, 7Eh	; '~'   ; CharType_last
		jnb	short gct_90
		push	bx
		mov	bx, offset CharType
		shr	al, 1
		xlat	byte ptr cs:[bx] ; cs xlat
		pop	bx
		jnb	short gct_80
		shr	al, 1
		shr	al, 1
		shr	al, 1
		shr	al, 1

gct_80:					; ...
		and	al, 0Fh
		retn
; ---------------------------------------------------------------------------

gct_90:					; ...
		mov	al, 0Fh
		retn
GetCharType	endp


; =============== S U B	R O U T	I N E =======================================


PATHCHRCMP	proc near		; ...
		cmp	al, 2Fh	; '/'
		jbe	short PathRet
		cmp	al, 5Ch	; '\'
		retn
; ---------------------------------------------------------------------------

GotFor:					; ...
		mov	al, 5Ch	; '\'
		retn
; ---------------------------------------------------------------------------

PathRet:				; ...
		jz	short GotFor
		retn
PATHCHRCMP	endp

; ---------------------------------------------------------------------------
LowInt23Addr	dw offset LowInt23	; ...
LowInt23Seg	dw 0			; ...
LowInt24Addr	dw offset LowInt24	; ...
LowInt24Seg	dw 0			; ...
LowInt28Addr	dw offset LowInt28	; ...
LowInt28Seg	dw 0			; ...

; =============== S U B	R O U T	I N E =======================================


DSKSTATCHK	proc near		; ...
		cmp	ss:INDOS, 1
		jz	short _RET37
		retn
; ---------------------------------------------------------------------------

_RET37:					; ...
		push	cx
		push	es
		push	bx
		push	ds
		push	si
		mov	bx, ss
		mov	es, bx
		mov	ds, bx
		mov	ss:DSKSTCOM, 5	; DEVRDND
		mov	ss:DSKSTCALL, 14 ; DRDNDHL
		mov	ss:DSKSTST, 0
		mov	bx, offset DSKSTCALL
		lds	si, ss:BCON
		call	DEVIOCALL2
		test	byte ptr ss:DSKSTST+1, 2 ; (STBUI>>8)
		jz	short _GotCh
		xor	al, al

RET36:					; ...
		pop	si
		pop	ds
		pop	bx
		pop	es
		pop	cx
		retn
; ---------------------------------------------------------------------------

_GotCh:					; ...
		mov	al, ss:DSKCHRET
		cmp	al, 3		; "C"-"@"
		jnz	short RET36
		mov	ss:DSKSTCOM, 4	; DEVRD
		mov	ss:DSKSTCALL, 22 ; DRDWRHL
		mov	ss:DSKCHRET, cl
		mov	ss:DSKSTST, 0
		mov	ss:DSKSTCNT, 1
		call	DEVIOCALL2
		pop	si
		pop	ds
		pop	bx
		pop	es
		pop	cx
		jmp	CNTCHAND
DSKSTATCHK	endp

; ---------------------------------------------------------------------------

NOSTOP:					; ...
		cmp	al, 10h		; "P"-"@"
		jnz	short check_next
		cmp	ss:SCAN_FLAG, 0
		jz	short INCHKJ
		retn
; ---------------------------------------------------------------------------

check_next:				; ...
		cmp	al, 3		; "C"-"@"
		jz	short INCHKJ

check_end:				; ...
		retn
; ---------------------------------------------------------------------------

INCHKJ:					; ...
		jmp	INCHK

; =============== S U B	R O U T	I N E =======================================


SPOOLINT	proc near		; ...
		pushf
		cmp	ss:IDLEINT, 0
		jz	short POPFRET
		cmp	ss:ERRORMODE, 0
		jnz	short POPFRET
		push	word ptr ss:IDLEINT
		cmp	ss:DosHasHMA, 0
		jnz	short do_low_int28
		int	28h		; DOS 2+ internal - KEYBOARD BUSY LOOP
		jmp	short spool_ret_addr
; ---------------------------------------------------------------------------

do_low_int28:				; ...
		call	dword ptr cs:LowInt28Addr ; call far [cs:LowInt28Addr]

spool_ret_addr:				; ...
		pop	word ptr ss:IDLEINT

POPFRET:				; ...
		popf

_RET18:					; ...
		retn
SPOOLINT	endp

; ---------------------------------------------------------------------------

STATCHK:				; ...
		call	DSKSTATCHK
		push	bx
		xor	bx, bx
		call	GET_IO_SFT
		pop	bx
		jb	short _RET18
		mov	ah, 1
		call	IOFUNC
		jz	short SPOOLINT
		cmp	al, 13h		; 'S'-'@'
		jnz	short NOSTOP
		cmp	ss:SCAN_FLAG, 0
		jnz	short check_end
		xor	ah, ah
		call	IOFUNC
		jmp	short PAUSOSTRT
; ---------------------------------------------------------------------------

PRINT_ON_OFF:				; ...
		not	ss:PFLAG
		push	bx
		mov	bx, 4
		call	GET_IO_SFT
		pop	bx
		jb	short _RET18
		push	es
		push	di
		push	ds
		pop	es
		mov	di, si
		test	byte ptr es:[di+6], 8 ;	[ES:DI+SF_ENTRY.sf_flags+1],
					; (sf_net_spool>>8)
		jz	short NORM_PR
		push	ax
		mov	ax, 1126h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - ???
					; Return: CF set on error, AX =	error code
					; STACK	unchanged
		pop	ax
		jnb	short NORM_PR
		mov	ss:PFLAG, 0
		push	ax
		mov	ax, 1124h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - ???
					; ES:DI	-> SFT,	SS = DOS CS
		pop	ax
		jmp	short RETP6
; ---------------------------------------------------------------------------

NORM_PR:				; ...
		cmp	ss:PFLAG, 0
		jnz	short PRNOPN
		call	DEV_CLOSE_SFT
		jmp	short RETP6
; ---------------------------------------------------------------------------

PRNOPN:					; ...
		call	DEV_OPEN_SFT

RETP6:					; ...
		pop	di
		pop	es

STATCHK_RETN:				; ...
		retn
; ---------------------------------------------------------------------------

PAUSOLP:				; ...
		call	SPOOLINT

PAUSOSTRT:				; ...
		mov	ah, 1
		call	IOFUNC
		jz	short PAUSOLP

INCHK:					; ...
		push	bx
		xor	bx, bx
		call	GET_IO_SFT
		pop	bx
		jb	short STATCHK_RETN
		xor	ah, ah
		call	IOFUNC
		cmp	al, 10h		; "P"-"@"
		jz	short PRINT_ON_OFF ; PRINTON
		cmp	al, 3		; "C"-"@"
		jnz	short STATCHK_RETN

CNTCHAND:				; ...
		test	byte ptr ss:DOS34_FLAG+1, 2 ; (CTRL_BREAK_FLAG>>8)
		jnz	short around_deadlock
		mov	al, 3
		call	BUFOUT
		call	CRLF

around_deadlock:			; ...
		push	ss
		pop	ds
		cmp	ds:CONSWAP, 0
		jz	short NOSWAP
		call	SWAPBACK

NOSWAP:					; ...
		cli
		mov	ss, ds:USER_SS
		mov	sp, ds:USER_SP
		call	restore_world
		pop	es
		push	ds
		mov	ds, cs:DosDSeg
		mov	ds:INDOS, 0
		mov	ds:ERRORMODE, 0
		mov	ds:ConC_Spsave,	sp
		add	ds:ConC_Spsave,	2
		cmp	ds:DosHasHMA, 0
		pop	ds
		jnz	short do_low_int23
		clc
		int	23h		; DOS -	CONTROL	"C" EXIT ADDRESS
					; Return: return via RETF 2 with CF set
					; DOS will abort program with errorlevel 0
					; else
					; interrupted DOS call continues
		jmp	short ctrlc_ret_addr
; ---------------------------------------------------------------------------

do_low_int23:				; ...
		clc
		call	dword ptr cs:LowInt23Addr ; call far [cs:LowInt23Addr]

ctrlc_ret_addr:				; ...
		cli
		push	ax
		mov	ax, ds
		mov	ds, cs:DosDSeg
		mov	ds:TEMPSEG, ax
		pop	ax
		mov	ds:USER_IN_AX, ax
		pushf
		pop	ax
		cmp	sp, ds:ConC_Spsave
		jnz	short ctrlc_try_new

ctrlc_repeat:				; ...
		mov	ax, ds:USER_IN_AX
		mov	ds, ds:TEMPSEG

COMMANDJ:				; ...
		jmp	COMMAND
; ---------------------------------------------------------------------------

ctrlc_try_new:				; ...
		add	sp, 2
		test	al, 1		; f_Carry
		jz	short ctrlc_repeat
		mov	ds, ds:TEMPSEG

ctrlc_abort:				; ...
		mov	ax, 4C00h	; (EXIT<<8)+0
		push	ds
		mov	ds, cs:DosDSeg
		mov	ds:DidCTRLC, 0FFh ; -1
		pop	ds
		jmp	short COMMANDJ
; ---------------------------------------------------------------------------

DIVOV:					; ...
		mov	si, offset DIVMES ; "\r\nDivide	overflow\r\n"
		mov	bx, cs:DivMesLen
		mov	ss, cs:DosDSeg
		mov	sp, offset AUXSTACK
		call	_OUTMES		; RealDivOv
		jmp	short ctrlc_abort

; =============== S U B	R O U T	I N E =======================================


_OUTMES		proc near		; ...
		push	ss
		pop	es
		push	ss
		pop	ds
		mov	ds:DSKSTCOM, 8	; DEVWRT
		mov	ds:DSKSTCALL, 16h ; DRDWRHL
		mov	ds:DSKSTST, 0
		mov	ds:DSKSTCNT, bx
		mov	bx, offset DSKSTCALL
		mov	ds:DSKCHRET_1, si ; [DSKCHRET+1]
		mov	ds:DSKCHRET_3, cs ; [DSKCHRET+3]
		lds	si, ds:BCON
		call	DEVIOCALL2
		mov	es:DSKCHRET_1, offset DEVIOBUF ; [ES:DSKCHRET+1]
		mov	es:DSKSTCNT, 1
		retn
_OUTMES		endp


; =============== S U B	R O U T	I N E =======================================


CHARHARD	proc near		; ...
		cmp	ss:ERRORMODE, 0
		jnz	short chard1
		or	ah, 10h
		test	ss:PFLAG, 0FFh	; -1
		jnz	short ctrlp

chard1:					; ...
		or	ah, 38h		; Allowed_IGNORE+Allowed_RETRY+Allowed_FAIL

ctrlp:					; ...
		mov	ss:ALLOWED, ah
		mov	word ptr ss:EXITHOLD+2,	es
		mov	word ptr ss:EXITHOLD, bp
		push	si
		and	di, 0FFh	; STECODE
		mov	bp, ds
		call	FATALC
		pop	si
		retn
CHARHARD	endp

; ---------------------------------------------------------------------------

HARDERR:				; ...
		xchg	ax, di
		and	di, 0FFh	; STECODE
		cmp	di, 0		; error_I24_write_protect
		jnz	short NOSETWRPERR
		push	ax
		mov	al, es:[bp+0]
		mov	ss:WPERR, al
		pop	ax

NOSETWRPERR:				; ...
		sub	ax, cx
		add	dx, ax
		push	dx
		mul	word ptr es:[bp+2] ; [ES:BP+DPB.SECTOR_SIZE]
		pop	dx
		add	bx, ax
		xor	ah, ah
		cmp	dx, es:[bp+6]	; [ES:BP+DPB.FIRST_FAT]
		jb	short ERRINT
		inc	ah
		cmp	dx, es:[bp+11h]	; [ES:BP+DPB.DIR_SECTOR]
		jnb	short TESTDIR
		mov	word ptr es:[bp+1Fh], 0FFFFh ; [ES:BP+DPB.FREE_CNT],-1
		jmp	short ERRINT
; ---------------------------------------------------------------------------

TESTDIR:				; ...
		inc	ah
		cmp	dx, es:[bp+0Bh]	; [ES:BP+DPB.FIRST_SECTOR]
		jb	short ERRINT
		inc	ah

ERRINT:					; ...
		shl	ah, 1
		or	ah, ss:READOP
		or	ah, ss:ALLOWED

FATAL:					; ...
		mov	al, es:[bp+0]

FATAL1:					; ...
		mov	word ptr ss:EXITHOLD+2,	es
		mov	word ptr ss:EXITHOLD, bp
		les	si, es:[bp+13h]	; [ES:BP+DPB.DRIVER_ADDR]
		mov	bp, es

FATALC:					; ...
		call	SET_I24_EXTENDED_ERROR
		cmp	di, 0Ch		; error_I24_gen_failure
		jbe	short NET_I24_ENTRY
		mov	di, 0Ch

NET_I24_ENTRY:				; ...
		cmp	ss:ERRORMODE, 0	; GOT_RIGHT_CODE
		jz	short NoSetFail
		mov	al, 3
		jmp	short FailRet
; ---------------------------------------------------------------------------

NoSetFail:				; ...
		mov	ss:CONTSTK, sp
		push	ss
		pop	es
		cmp	ss:SFN,	0FFFFh	; -1
		jz	short _NoFree
		push	ds
		push	si
		lds	si, ss:PJFN
		mov	byte ptr [si], 0FFh
		pop	si
		pop	ds

_NoFree:				; ...
		cli
		inc	ss:ERRORMODE
		dec	ss:INDOS
		test	ss:EXTOPEN_ON, 2 ; EXT_OPEN_I24_OFF
		jz	short i24yes
		mov	al, 3
		jmp	short passi24
; ---------------------------------------------------------------------------

i24yes:					; ...
		mov	ss, ss:USER_SS
		mov	sp, es:USER_SP
		cmp	es:DosHasHMA, 0
		jnz	short do_low_int24
		int	24h		; DOS -	FATAL ERROR HANDLER ADDRESS
					; Automatically	called upon detection of unrecoverable I/O error.
		jmp	short criterr_ret_addr
; ---------------------------------------------------------------------------

do_low_int24:				; ...
		call	dword ptr cs:LowInt24Addr ; call far [cs:LowInt24Addr]

criterr_ret_addr:			; ...
		mov	es:USER_SP, sp
		mov	es:USER_SS, ss
		mov	bp, es
		mov	ss, bp

passi24:				; ...
		mov	sp, ss:CONTSTK
		inc	ss:INDOS
		mov	ss:ERRORMODE, 0
		sti

FailRet:				; ...
		les	bp, ss:EXITHOLD
		cmp	al, 1
		jb	short CheckIgnore
		jz	short CheckRetry
		cmp	al, 3
		jnz	short DoAbort
		test	ss:ALLOWED, 8
		jz	short DoAbort

DoFail:					; ...
		mov	al, 3
		test	ss:EXTOPEN_ON, 2 ; EXT_OPEN_I24_OFF
		jnz	short CleanUp
		inc	ss:FAILERR

CleanUp:				; ...
		mov	ss:WPERR, 0FFh	; -1
		cmp	ss:SFN,	0FFFFh	; -1
		jnz	short CleanUp2
		retn
; ---------------------------------------------------------------------------

CleanUp2:				; ...
		push	ds
		push	si
		push	ax
		mov	ax, ss:SFN
		lds	si, ss:PJFN
		mov	[si], al
		pop	ax
		pop	si
		pop	ds
		retn
; ---------------------------------------------------------------------------

CheckIgnore:				; ...
		test	ss:ALLOWED, 20h	; Allowed_IGNORE
		jz	short DoFail
		jmp	short CleanUp
; ---------------------------------------------------------------------------

CheckRetry:				; ...
		test	ss:ALLOWED, 10h	; Allowed_RETRY
		jz	short DoFail
		jmp	short CleanUp
; ---------------------------------------------------------------------------

DoAbort:				; ...
		push	ss
		pop	ds
		cmp	ds:CONSWAP, 0
		jz	short NOSWAP2
		call	SWAPBACK

NOSWAP2:				; ...
		cmp	ds:fAborting, 0
		jnz	short DoFail
		mov	ds:EXIT_TYPE, 2	; EXIT_HARD_ERROR
		xor	al, al
		jmp	exit_inner
; ---------------------------------------------------------------------------

reset_environment:			; ...
		push	ds
		mov	ah, 82h
		int	2Ah		; Microsoft Networks - END DOS CRITICAL	SECTIONS 0 THROUGH 7
		mov	ss:fAborting, 0FFh ; -1
		mov	ax, 1122h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - PROCESS TERMINATION HOOK
					; SS = DOS CS
		mov	al, 22h		; int_terminate
		call	$GET_INTERRUPT_VECTOR
		pop	cx
		push	es
		push	bx
		mov	bx, ss:CurrentPDB
		mov	ds, bx
		mov	ax, ds:16h	; [PDB.PARENT_PID]
		cmp	ax, bx
		jz	short reset_return
		cmp	bx, cx
		jnz	short reset_return
		push	ax
		cmp	ss:EXIT_TYPE, 3	; EXIT_KEEP_PROCESS
		jz	short reset_to_parent
		call	arena_free_process
		call	DOS_ABORT

reset_to_parent:			; ...
		pop	ss:CurrentPDB

reset_return:				; ...
		push	ss
		pop	ds
		mov	al, 0FFh	; -1
		call	ECritDisk
		call	FLUSHBUF
		call	LCritDisk
		call	CHECK_VIRT_OPEN
		cli
		mov	ds:INDOS, 0
		mov	ds:WPERR, 0FFh
		mov	ds:fAborting, 0
		pop	word ptr ds:EXITHOLD
		pop	word ptr ds:EXITHOLD+2
		mov	ds, ds:CurrentPDB
		mov	ss, word ptr ds:BCLOCK+2
		mov	sp, word ptr ds:BCLOCK
		call	restore_world
		pop	es
		push	ax
		mov	ax, ds
		mov	ds, cs:DosDSeg
		mov	ds:TEMPSEG, ax
		pop	ax
		mov	ds:USER_SP, ax
		pop	ax
		pop	ax
		pop	ax
		lahf
		xchg	ah, al
		and	al, 2
		mov	ah, 0F2h
		push	ax
		push	word ptr ds:EXITHOLD+2
		push	word ptr ds:EXITHOLD
		mov	ax, ds:USER_SP
		mov	ds, ds:TEMPSEG
		iret

; =============== S U B	R O U T	I N E =======================================


SET_I24_EXTENDED_ERROR proc near	; ...
		push	ax
		mov	ax, offset FIRST_BUFF_ADDR ; ErrMap24End
		sub	ax, offset ErrMap24
		push	ds
		mov	ds, cs:DosDSeg
		cmp	di, ax
		mov	ax, di
		jnb	short NoTrans
		mov	al, ds:ErrMap24[di] ; [ErrMap24+di]
		xor	ah, ah

NoTrans:				; ...
		mov	ds:EXTERR, ax
		pop	ds
		pop	ax
		push	si
		mov	si, offset ERR_TABLE_24
		call	CAL_LK
		pop	si
		retn
SET_I24_EXTENDED_ERROR endp


; =============== S U B	R O U T	I N E =======================================


IsEOF		proc near		; ...
		cmp	word ptr es:[bp+0Dh], 0FF6h ; [ES:BP+DPB.MAX_CLUSTER],
					; 4096-10
		jnb	short EOF16
		cmp	bx, 0FF0h
		jz	short IsEOF_other
		cmp	bx, 0FF8h

IsEOF_other:				; ...
		retn
; ---------------------------------------------------------------------------

EOF16:					; ...
		cmp	bx, 0FFF8h
		retn
IsEOF		endp


; =============== S U B	R O U T	I N E =======================================


UNPACK		proc near		; ...
		or	bx, bx
		jnz	short up_cont
		mov	di, ds:CL0FATENTRY
		or	di, di
		retn
; ---------------------------------------------------------------------------

up_cont:				; ...
		cmp	bx, es:[bp+0Dh]	; [ES:BP+DPB.MAX_CLUSTER]
		ja	short HURTFAT
		call	MAPCLUSTER
		jb	short _DoContext
		mov	di, [di]
		jnz	short High12
		mov	si, es:[bp+0Dh]	; [ES:BP+DPB.MAX_CLUSTER]
		cmp	si, 0FF6h	; 4096-10
		jb	short Unpack12
		or	di, di
		jmp	short _DoContext
; ---------------------------------------------------------------------------

High12:					; ...
		shr	di, 1
		shr	di, 1
		shr	di, 1
		shr	di, 1

Unpack12:				; ...
		and	di, 0FFFh

_DoContext:				; ...
		push	ss
		pop	ds
		retn
; ---------------------------------------------------------------------------

HURTFAT:				; ...
		mov	word ptr es:[bp+1Fh], 0FFFFh ; [ES:BP+DPB.FREE_CNT],-1
		push	ax
		mov	ah, 88h		; Allowed_FAIL+80h
		mov	ss:ALLOWED, 8	; Allowed_FAIL
		mov	di, 0FFFh
		call	FATAL
		cmp	al, 3
		clc
		jnz	short OKU_RET
		stc

OKU_RET:				; ...
		pop	ax

hurtfat_retn:				; ...
		retn
UNPACK		endp


; =============== S U B	R O U T	I N E =======================================


PACK		proc near		; ...
		or	bx, bx
		jnz	short p_cont
		mov	ds:CL0FATENTRY,	dx
		retn
; ---------------------------------------------------------------------------

p_cont:					; ...
		call	MAPCLUSTER
		jb	short _DoContext
		mov	si, [di]
		jz	short ALIGNED
		push	cx
		mov	cl, 4
		shl	dx, cl
		pop	cx
		and	si, 0Fh
		jmp	short PACKIN
; ---------------------------------------------------------------------------

ALIGNED:				; ...
		cmp	word ptr es:[bp+0Dh], 0FF6h ; [ES:BP+DPB.MAX_CLUSTER],
					; 4096-10
		jnb	short Pack16
		and	si, 0F000h
		and	dx, 0FFFh
		jmp	short PACKIN
; ---------------------------------------------------------------------------

Pack16:					; ...
		xor	si, si

PACKIN:					; ...
		or	si, dx
		mov	[di], si
		lds	si, ss:CURBUF
		test	byte ptr [si+5], 40h ; [SI+BUFFINFO.buf_flags],buf_dirty
		jnz	short yesdirty11
		call	INC_DIRTY_COUNT
		or	byte ptr [si+5], 40h

yesdirty11:				; ...
		cmp	ss:CLUSSPLIT, 0
		push	ss
		pop	ds
		jz	short hurtfat_retn
		push	ax
		push	bx
		push	cx
		mov	ax, ds:CLUSSAVE
		mov	ds, word ptr ds:CURBUF+2
		add	si, 20		; BUFINSIZ
		mov	[si], ah
		push	ss
		pop	ds
		push	ax
		mov	dx, word ptr ds:CLUSSEC+2
		mov	ds:HIGH_SECTOR,	dx
		mov	dx, word ptr ds:CLUSSEC
		mov	si, 1
		xor	al, al
		call	GETBUFFRB
		pop	ax
		jb	short POPP_RET
		lds	di, ds:CURBUF
		test	byte ptr [di+5], 40h
		jnz	short yesdirty12
		call	INC_DIRTY_COUNT
		or	byte ptr [di+5], 40h ; [DI+BUFFINFO.buf_flags],buf_dirty

yesdirty12:				; ...
		add	di, 20		; BUFINSIZ
		dec	di
		add	di, es:[bp+2]	; [ES:BP+DPB.SECTOR_SIZE]
		mov	[di], al
		clc

POPP_RET:				; ...
		push	ss
		pop	ds
		pop	cx
		pop	bx
		pop	ax
		retn
PACK		endp


; =============== S U B	R O U T	I N E =======================================


MAPCLUSTER	proc near		; ...
		mov	ds:CLUSSPLIT, 0
		push	ax
		push	bx
		push	cx
		push	dx
		mov	ax, bx
		cmp	word ptr es:[bp+0Dh], 0FF6h ; [ES:BP+DPB.MAX_CLUSTER],
					; 4096-10
		jnb	short Map16
		shr	ax, 1

Map16:					; ...
		xor	di, di
		add	ax, bx
		adc	di, di
		mov	cx, es:[bp+2]	; [ES:BP+DPB.SECTOR_SIZE]
		cmp	cx, 512
		jnz	short _DoDiv
		mov	dx, ax
		and	dx, 1FFh
		mov	al, ah
		shr	di, 1
		rcr	al, 1
		xor	ah, ah
		jmp	short DivDone
; ---------------------------------------------------------------------------

_DoDiv:					; ...
		mov	dx, di
		div	cx

DivDone:				; ...
		add	ax, es:[bp+6]	; ES:BP+DPB.FIRST_FAT]
		dec	cx
		push	ax
		push	dx
		push	cx
		mov	dx, ax
		mov	ds:HIGH_SECTOR,	0
		xor	al, al
		mov	si, 1
		call	GETBUFFRB
		pop	cx
		pop	ax
		pop	dx
		jb	short MAP_POP
		lds	si, ds:CURBUF
		lea	di, [si+20]	; [SI+BUFINSIZ]
		add	di, ax
		cmp	ax, cx
		jnz	short MAPRET
		mov	al, [di]
		push	ss
		pop	ds
		inc	ds:CLUSSPLIT
		mov	byte ptr ds:CLUSSAVE, al
		mov	word ptr ds:CLUSSEC, dx
		mov	word ptr ds:CLUSSEC+2, 0
		inc	dx
		mov	ds:HIGH_SECTOR,	0
		xor	al, al
		mov	si, 1
		call	GETBUFFRB
		jb	short MAP_POP
		lds	si, ds:CURBUF
		lea	di, [si+20]	; [SI+BUFINSIZ]
		mov	al, [di]
		push	ss
		pop	ds
		mov	byte ptr ds:CLUSSAVE+1,	al
		mov	di, offset CLUSSAVE

MAPRET:					; ...
		pop	dx
		pop	cx
		pop	bx
		xor	ax, ax
		cmp	word ptr es:[bp+0Dh], 0FF6h ; [ES:BP+DPB.MAX_CLUSTER],
					; 4096-10
		jnb	short MapSet
		mov	ax, bx

MapSet:					; ...
		test	al, 1
		pop	ax
		retn
; ---------------------------------------------------------------------------

MAP_POP:				; ...
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		retn
MAPCLUSTER	endp


; =============== S U B	R O U T	I N E =======================================


FATREAD_SFT	proc near		; ...
		les	bp, es:[di+7]	; [ES:DI+SF_ENTRY.sf_devptr]
		mov	al, es:[bp+0]
		mov	ds:THISDRV, al
		call	GOTDPB
		call	FAT_GOT_DPB

fatread_sft_retn:			; ...
		retn
FATREAD_SFT	endp


; =============== S U B	R O U T	I N E =======================================


FATREAD_CDS	proc near		; ...
		push	es
		push	di
		les	bp, es:[di+45h]	; [ES:DI+curdir.devptr]
		mov	al, es:[bp+0]
		mov	ds:THISDRV, al
		call	GOTDPB
		call	FAT_GOT_DPB
		pop	di
		pop	es
		jb	short fatread_sft_retn
		jnz	short NO_CHANGE
		xor	ax, ax
		dec	ax
		push	ds
		mov	cl, ds:CDSCOUNT
		xor	ch, ch
		lds	si, es:[di+45h]	; [ES:DI+curdir.devptr]
		les	di, ss:CDSADDR

frcd20:					; ...
		test	byte ptr es:[di+44h], 80h ; [ES:DI+curdir.flags+1],
					; (curdir_isnet>>8)
		jnz	short frcd25
		cmp	si, es:[di+45h]	; [ES:DI+curdir.devptr]
		jnz	short frcd25
		mov	bx, ds
		cmp	bx, es:[di+47h]	; [ES:DI+curdir.devptr+2]
		jnz	short frcd25
		test	es:[di+49h], ax	; [ES:DI+curdir.ID]
		jz	short frcd25
		mov	es:[di+49h], ax

frcd25:					; ...
		add	di, 88		; curdir.size
		loop	frcd20
		pop	ds

NO_CHANGE:				; ...
		les	bp, ds:THISDPB
		clc
		retn
FATREAD_CDS	endp

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR FAT_GOT_DPB

FAT_operation:				; ...
		mov	word ptr es:[bp+1Fh], 0FFFFh ; [ES:BP+DPB.FREE_CNT],-1
		and	di, 0FFh	; STECODE
		mov	ds:ALLOWED, 18h	; Allowed_FAIL+Allowed_RETRY
		mov	ah, 1Ah		; 2+Allowed_FAIL+Allowed_RETRY
		mov	al, ds:THISDRV
		call	FATAL1
		les	bp, ds:THISDPB
		cmp	al, 3
		jnz	short FAT_GOT_DPB
		stc
		retn
; END OF FUNCTION CHUNK	FOR FAT_GOT_DPB

; =============== S U B	R O U T	I N E =======================================


FAT_GOT_DPB	proc near		; ...

; FUNCTION CHUNK AT 96C0 SIZE 00000021 BYTES

		push	ss
		pop	ds
		mov	al, 0Fh		; DMEDHL
		mov	ah, es:[bp+1]	; [ES:BP+DPB.UNIT]
		mov	ds:DEVCALL, ax
		mov	ds:DEVCALL_REQFUNC, 1 ;	DEVMDCH
		mov	ds:DEVCALL_REQSTAT, 0
		mov	al, es:[bp+17h]	; [ES:BP+DPB.MEDIA]
		mov	ds:CALLMED, al
		push	es
		push	ds
		mov	bx, offset DEVCALL
		lds	si, es:[bp+13h]	; [ES:BP+DPB.DRIVER_ADDR]
		pop	es
		call	DEVIOCALL2
		push	ss
		pop	ds
		pop	es
		mov	di, ds:DEVCALL_REQSTAT
		or	di, di
		js	short FAT_operation
		xor	ah, ah
		xchg	ah, es:[bp+18h]	; [ES:BP+DPB.FIRST_ACCESS]
		mov	al, ds:THISDRV
		cmp	ds:VOLCHNG_FLAG, al
		jnz	short CHECK_BYT
		mov	ds:VOLCHNG_FLAG, 0FFh ;	-1
		jmp	GOGETBPB
; ---------------------------------------------------------------------------

CHECK_BYT:				; ...
		or	ah, ds:CALLXADD
		jns	short CHECK_ZR
		jmp	short NEWDSK
; ---------------------------------------------------------------------------

CHECK_ZR:				; ...
		jz	short CHKBUFFDIRT
		clc
		retn
; ---------------------------------------------------------------------------

DISK_CHNG_ERR:				; ...
		push	es
		push	bp
		les	bp, es:[bp+13h]	; [ES:BP+DPB.DRIVER_ADDR]
		test	byte ptr es:[bp+5], 8 ;	[es:bp+SYSDEV.ATT+1],
					; (DEVOPCL>>8)
		pop	bp
		pop	es
		jz	short FAIL_OPJ2
		push	ds
		push	di
		push	ss
		pop	ds
		mov	ds:ALLOWED, 18h
		push	es
		les	di, dword ptr ds:CALLXADD+1 ; les di,[CALLVIDM]
		mov	word ptr ds:EXTERRPT+2,	es
		pop	es
		mov	word ptr ds:EXTERRPT, di
		mov	ax, 0Fh		; error_I24_wrong_disk
		mov	ds:READOP, 1
		call	HARDERR
		pop	di
		pop	ds
		cmp	al, 3

FAIL_OPJ2:				; ...
		jz	short FAIL_OP
		jmp	FAT_GOT_DPB
; ---------------------------------------------------------------------------

CHKBUFFDIRT:				; ...
		cmp	ss:DirtyBufferCount, 0
		jz	short NEWDSK
		call	GETCURHEAD

nbuffer:				; ...
		cmp	[di+4],	al	; [di+BUFFINFO.buf_ID]
		jnz	short lfnxt
		test	byte ptr [di+5], 40h ; [di+BUFFINFO.buf_flags],
					; buf_dirty
		jz	short lfnxt
		push	ss
		pop	ds
		clc
		retn
; ---------------------------------------------------------------------------

FAIL_OP:				; ...
		push	ss
		pop	ds
		stc
		retn
; ---------------------------------------------------------------------------

lfnxt:					; ...
		mov	di, [di]	; [di+BUFFINFO.buf_next]
		cmp	ss:FIRST_BUFF_ADDR, di
		jnz	short nbuffer

NEWDSK:					; ...
		mov	word ptr es:[bp+1Fh], 0FFFFh ; [ES:BP+DPB.FREE_CNT],-1
		call	GETCURHEAD

nxbuffer:				; ...
		cmp	[di+4],	al	; [DI+BUFFINFO.buf_ID]
		jnz	short lfnxt2
		test	byte ptr [di+5], 40h ; [DI+BUFFINFO.buf_flags],buf_dirty
		jnz	short DISK_CHNG_ERR
		mov	word ptr [di+4], 20FFh ; [DI+BUFFINFO.buf_ID],
					; (buf_visit*256)+0FFh
		call	SCANPLACE
		jmp	short skpbuff
; ---------------------------------------------------------------------------

lfnxt2:					; ...
		mov	di, [di]	; [di+BUFFINFO.buf_next]

skpbuff:				; ...
		cmp	di, ss:FIRST_BUFF_ADDR
		jnz	short nxbuffer
		cmp	ss:SC_CACHE_COUNT, 0
		jz	short GOGETBPB
		cmp	al, ss:CurSC_DRIVE
		jnz	short GOGETBPB
		mov	ss:CurSC_DRIVE,	0FFh ; -1

GOGETBPB:				; ...
		lds	di, es:[bp+13h]	; [ES:BP+DPB.DRIVER_ADDR]
		test	byte ptr [di+5], 20h ; [DI+SYSDEV.ATT+1],
					; (ISFATBYDEV>>8)
		jnz	short GETFREEBUF
		push	ss
		pop	ds
		mov	bx, 2
		call	UNPACK

FAIL_OPJ:				; ...
		jb	short FAIL_OP
		lds	di, ds:CURBUF
		jmp	short GOTGETBUF
; ---------------------------------------------------------------------------

GETFREEBUF:				; ...
		push	es
		push	bp
		xor	dx, dx
		mov	ss:HIGH_SECTOR,	dx
		call	GETCURHEAD
		call	BUFWRITE
		pop	bp
		pop	es
		jb	short FAIL_OPJ

GOTGETBUF:				; ...
		add	di, 20		; BUFINSIZ
		mov	word ptr ss:CALLXADD+2,	ds
		push	ss
		pop	ds
		mov	word ptr ds:CALLXADD, di
		mov	al, 16h		; DBPBHL
		mov	ah, es:[bp+1]	; [ES:BP+DPB.UNIT]
		mov	ds:DEVCALL, ax	; [DEVCALL_REQLEN]
		mov	ds:DEVCALL_REQFUNC, 2 ;	DEVBPB
		mov	ds:DEVCALL_REQSTAT, 0
		mov	al, es:[bp+17h]	; [ES:BP+DPB.MEDIA]
		mov	ds:CALLMED, al
		push	es
		push	ds
		push	word ptr es:[bp+15h] ; [ES:BP+DPB.DRIVER_ADDR+2]
		push	word ptr es:[bp+13h] ; [ES:BP+DPB.DRIVER_ADDR]
		mov	bx, offset DEVCALL
		pop	si
		pop	ds
		pop	es
		call	DEVIOCALL2
		pop	es
		push	ss
		pop	ds
		mov	di, ds:DEVCALL_REQSTAT
		or	di, di
		js	short FATERRJ
		mov	al, es:[bp+17h]	; [ES:BP+DPB.MEDIA]
		lds	si, dword ptr ds:CALLSCNT ; lds	si,[CALLBPB]
		mov	word ptr es:[bp+1Dh], 0	; [ES:BP+DPB.NEXT_FREE]
		call	$SETDPB
		lds	di, dword ptr ss:CALLXADD
		mov	al, es:[bp+8]	; [ES:BP+DPB.FAT_COUNT]
		mov	[di-0Ah], al	; [DI+BUFFINFO.buf_wrtcnt-BUFINSIZ]
		mov	ax, es:[bp+0Fh]	; [ES:BP+DPB.FAT_SIZE]
		mov	[di-9],	ax	; [DI+BUFFINFO.buf_wrtcntinc-BUFINSIZ]
		push	ss
		pop	ds
		xor	al, al
		retn
; ---------------------------------------------------------------------------

FATERRJ:				; ...
		jmp	FAT_operation
FAT_GOT_DPB	endp


; =============== S U B	R O U T	I N E =======================================


GETCURHEAD	proc near		; ...
		lds	di, ss:BufferQueue
		mov	word ptr ss:LastBuffer,	0FFFFh ; -1
		mov	ss:FIRST_BUFF_ADDR, di
		retn
GETCURHEAD	endp


; =============== S U B	R O U T	I N E =======================================


SCANPLACE	proc near		; ...
		push	word ptr [di]	; [di+BUFFINFO.buf_next]
		call	PLACEBUF
		pop	di
		retn
SCANPLACE	endp


; =============== S U B	R O U T	I N E =======================================


PLACEBUF	proc near		; ...
		push	ax
		push	bx
		push	si
		mov	ax, [di]	; [di+BUFFINFO.buf_next]
		mov	bx, word ptr ss:BufferQueue
		cmp	ax, bx
		jz	short nret
		cmp	di, bx
		jnz	short not_first
		mov	word ptr ss:BufferQueue, ax
		jmp	short nret
; ---------------------------------------------------------------------------

not_first:				; ...
		mov	si, [di+2]	; [DI+BUFFINFO.buf_prev]
		mov	[si], ax	; [SI+BUFFINFO.buf_next]
		xchg	ax, si
		mov	[si+2],	ax	; [SI+BUFFINFO.buf_prev]
		mov	si, [bx+2]	; [BX+BUFFINFO.buf_prev]
		mov	[si], di
		mov	[bx+2],	di
		mov	[di+2],	si
		mov	[di], bx	; [DI+BUFFINFO.buf_next]

nret:					; ...
		pop	si
		pop	bx
		pop	ax
		cmp	byte ptr [di+4], 0FFh ;	[di+BUFFINFO.buf_ID],-1
		jnz	short pbx
		mov	word ptr ss:BufferQueue, di

pbx:					; ...
		retn
PLACEBUF	endp

; ---------------------------------------------------------------------------

POINTCOMP:				; ...
		cmp	si, di
		jnz	short placehead_retn
		push	cx
		push	dx
		mov	cx, ds
		mov	dx, es
		cmp	cx, dx
		pop	dx
		pop	cx

placehead_retn:				; ...
		retn
; ---------------------------------------------------------------------------

GETBUFFR:				; ...
		xor	si, si

GETBUFFRB:				; ...
		mov	ds:PREREAD, ax
		mov	al, es:[bp+0]	; [ES:BP+DPB.DRIVE]
		lds	di, ds:LastBuffer
		mov	cx, ss:HIGH_SECTOR
		cmp	di, 0FFFFh	; -1
		jz	short getb5
		cmp	dx, [di+6]	; [DI+BUFFINFO.buf_sector]
		jnz	short getb5
		cmp	cx, [di+8]	; [DI+BUFFINFO.buf_sector+2]
		jnz	short getb5
		cmp	al, [di+4]	; [DI+BUFFINFO.buf_ID]
		jnz	short getb5
		jmp	getb35
; ---------------------------------------------------------------------------

getb5:					; ...
		call	GETCURHEAD

getb10:					; ...
		cmp	dx, [di+6]	; [DI+BUFFINFO.buf_sector]
		jnz	short getb12
		cmp	cx, [di+8]	; [DI+BUFFINFO.buf_sector+2]
		jnz	short getb12
		cmp	al, [di+4]	; [DI+BUFFINFO.buf_ID]
		jnz	short getb12
		jmp	getb25
; ---------------------------------------------------------------------------

getb12:					; ...
		mov	di, [di]	; [DI+BUFFINFO.BUF_NEXT]
		cmp	di, ss:FIRST_BUFF_ADDR
		jnz	short getb10
		push	cx
		push	si
		push	dx
		push	bp
		push	es
		call	BUFWRITE
		pop	es
		pop	bp
		pop	dx
		pop	si
		pop	ss:HIGH_SECTOR
		jnb	short getb13
		jmp	getbx
; ---------------------------------------------------------------------------

getb13:					; ...
		call	SET_RQ_SC_PARMS
		xor	ah, ah
		cmp	byte ptr ss:PREREAD, ah
		jnz	short getb20
		lea	bx, [di+20]	; [DI+BUFINSIZ]
		mov	cx, 1
		push	si
		push	di
		push	dx
		push	es
		cmp	ss:BuffInHMA, 0
		jz	short getb14
		push	ds
		push	bx
		lds	bx, ss:LoMemBuff

getb14:					; ...
		or	si, si
		jz	short getb15
		call	FATSECRD
		mov	ah, 2		; buf_isFAT
		jmp	short getb17
; ---------------------------------------------------------------------------

getb15:					; ...
		call	DREAD
		mov	ah, 0

getb17:					; ...
		pushf
		cmp	ss:BuffInHMA, 0
		jz	short not_in_hma
		popf
		mov	cx, es:[bp+2]	; [ES:BP+DPB.SECTOR_SIZE]
		shr	cx, 1
		mov	si, bx
		pop	di
		pop	es
		cld
		rep movsw
		push	es
		pop	ds
		jmp	short getb19
; ---------------------------------------------------------------------------

not_in_hma:				; ...
		popf

getb19:					; ...
		pop	es
		pop	dx
		pop	di
		pop	si
		jb	short getbx

getb20:					; ...
		mov	cx, ss:HIGH_SECTOR
		mov	[di+8],	cx	; [DI+BUFFINFO.buf_sector+2]
		mov	[di+6],	dx	; [DI+BUFFINFO.buf_sector]
		mov	[di+0Dh], bp	; [DI+BUFFINFO.buf_DPB]
		mov	word ptr [di+0Fh], es ;	[DI+BUFFINFO.buf_DPB+2]
		mov	al, es:[bp+0]	; [ES:BP+DPB.DRIVE]
		mov	[di+4],	ax	; [DI+BUFFINFO.buf_ID]

getb25:					; ...
		mov	byte ptr [di+0Ah], 1 ;	[DI+BUFFINFO.buf_wrtcnt]
		xor	ax, ax
		or	si, si
		jz	short getb30
		mov	al, es:[bp+8]	; [ES:BP+DPB.FAT_COUNT]
		mov	[di+0Ah], al	; [DI+BUFFINFO.buf_wrtcnt]
		mov	ax, es:[bp+0Fh]	; [ES:BP+DPB.FAT_SIZE]

getb30:					; ...
		mov	[di+0Bh], ax	; [DI+BUFFINFO.buf_wrtcntinc]
		call	PLACEBUF

getb35:					; ...
		mov	word ptr ss:CURBUF+2, ds
		mov	word ptr ss:LastBuffer+2, ds
		mov	word ptr ss:CURBUF, di
		mov	word ptr ss:LastBuffer,	di
		clc

getbx:					; ...
		push	ss
		pop	ds

getbuffrb_retn:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================


FLUSHBUF	proc near		; ...
		call	GETCURHEAD
		test	byte ptr ss:DOS34_FLAG,	4 ; FROM_DISK_RESET
		jnz	short scan_buf_queue
		cmp	ss:DirtyBufferCount, 0
		jz	short end_scan

scan_buf_queue:				; ...
		call	CHECKFLUSH
		mov	ah, [di+4]	; [DI+BUFFINFO.buf_ID]
		cmp	ss:WPERR, ah
		jz	short free_the_buf
		test	byte ptr ss:DOS34_FLAG,	4 ; FROM_DISK_RESET
		jz	short dont_free_the_buf

free_the_buf:				; ...
		mov	word ptr [di+4], 0FFh ;	[DI+BUFFINFO.buf_ID],00FFh

dont_free_the_buf:			; ...
		mov	di, [di]	; [DI+BUFFINFO.buf_next]
		cmp	di, ss:FIRST_BUFF_ADDR
		jnz	short scan_buf_queue

end_scan:				; ...
		push	ss
		pop	ds
		cmp	ds:FAILERR, 0
		jnz	short bad_flush
		retn
; ---------------------------------------------------------------------------

bad_flush:				; ...
		stc
		retn
FLUSHBUF	endp


; =============== S U B	R O U T	I N E =======================================


CHECKFLUSH	proc near		; ...
		mov	ah, 0FFh	; -1
		cmp	[di+4],	ah	; [DI+BUFFINFO.buf_ID]
		jz	short getbuffrb_retn ; flushbuf_retn
		cmp	ah, al
		jz	short DOBUFFER
		cmp	al, [di+4]
		clc
		jnz	short getbuffrb_retn ; flushbuf_retn

DOBUFFER:				; ...
		test	byte ptr [di+5], 40h ; [DI+BUFFINFO.buf_flags],
					; buf_dirty
		jz	short getbuffrb_retn ; flushbuf_retn
		push	ax
		push	word ptr [di+4]	; [DI+BUFFINFO.buf_ID]
		call	BUFWRITE
		pop	ax
		jb	short LEAVE_BUF
		and	ah, 0BFh	; ~buf_dirty
		mov	[di+4],	ax

LEAVE_BUF:				; ...
		pop	ax

checkflush_retn:			; ...
		retn
CHECKFLUSH	endp


; =============== S U B	R O U T	I N E =======================================


BUFWRITE	proc near		; ...
		mov	ax, 0FFh
		xchg	ax, [di+4]	; [DI+BUFFINFO.buf_ID]
		cmp	al, 0FFh
		jz	short checkflush_retn
		test	ah, 40h		; buf_dirty
		jz	short checkflush_retn
		call	DEC_DIRTY_COUNT
		cmp	al, ss:WPERR
		jz	short checkflush_retn
		mov	ss:SC_DRIVE, al
		les	bp, [di+13]	; [DI+BUFFINFO.buf_DPB]
		lea	bx, [di+20]	; [DI+BUFINSIZ]
		mov	dx, [di+6]	; [DI+BUFFINFO.buf_sector]
		mov	cx, [di+8]	; [DI+BUFFINFO.buf_sector+2]
		mov	ss:HIGH_SECTOR,	cx
		mov	cl, [di+10]	; [DI+BUFFINFO.buf_wrtcnt]
		xor	ch, ch
		mov	ss:ALLOWED, 18h	; Allowed_RETRY+Allowed_FAIL
		test	ah, 8		; buf_isDATA
		jz	short NO_IGNORE
		or	ss:ALLOWED, 20h	; Allowed_IGNORE

NO_IGNORE:				; ...
		mov	ax, [di+11]	; [DI+BUFFINFO.buf_wrtcntinc]
		push	di
		xor	di, di
		push	ds
		push	bx

WRTAGAIN:				; ...
		push	di
		push	cx
		push	ax
		mov	cx, 1
		push	bx
		push	dx
		push	ds
		cmp	ss:BuffInHMA, 0
		jz	short NBUFFINHMA
		push	cx
		push	es
		mov	si, bx
		mov	cx, es:[bp+2]	; [es:bp+DPB.SECTOR_SIZE]
		shr	cx, 1
		les	di, ss:LoMemBuff
		mov	bx, di
		cld
		rep movsw
		push	es
		pop	ds
		pop	es
		pop	cx

NBUFFINHMA:				; ...
		call	DWRITE
		pop	ds
		pop	dx
		pop	bx
		pop	ax
		pop	cx
		pop	di
		jb	short NOSET
		inc	di

NOSET:					; ...
		add	dx, ax
		loop	WRTAGAIN
		pop	bx
		pop	ds
		or	di, di
		jnz	short BWROK
		stc

BWROK:					; ...
		pop	di
		retn
BUFWRITE	endp


; =============== S U B	R O U T	I N E =======================================


SET_RQ_SC_PARMS	proc near		; ...
		push	ax
		mov	ax, es:[bp+2]	; [ES:BP+DPB.SECTOR_SIZE]
		mov	ss:SC_SECTOR_SIZE, ax
		mov	al, es:[bp+0]
		mov	ss:SC_DRIVE, al
		pop	ax
		retn
SET_RQ_SC_PARMS	endp


; =============== S U B	R O U T	I N E =======================================


INC_DIRTY_COUNT	proc near		; ...
		inc	ss:DirtyBufferCount
		retn
INC_DIRTY_COUNT	endp


; =============== S U B	R O U T	I N E =======================================


DEC_DIRTY_COUNT	proc near		; ...
		cmp	ss:DirtyBufferCount, 0
		jz	short ddcx
		dec	ss:DirtyBufferCount

ddcx:					; ...
		retn
DEC_DIRTY_COUNT	endp

; ---------------------------------------------------------------------------

$WAIT:					; ...
		xor	ax, ax
		xchg	ax, ss:exit_code
		jmp	SYS_RETURN	; SYS_RET_OK
; ---------------------------------------------------------------------------

$EXEC:					; ...
		mov	ss:A20OFF_COUNT, 0
		cmp	al, 5
		jnz	short Exec_@f
		pop	cx
		mov	cx, offset LeaveDOS
		push	cx

Exec_@f:				; ...
		push	bp
		mov	bp, sp
		sub	sp, 29
		cmp	al, 5
		jbe	short Exec_Check_2

Exec_Bad_Fun:				; ...
		mov	ss:EXTERR_LOCUS, 1 ; errLOC_Unk
		mov	al, 1		; error_invalid_function

Exec_Ret_Err:				; ...
		mov	sp, bp
		pop	bp
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

ExecReadyJ:				; ...
		call	ExecReady
		jmp	norm_ovl
; ---------------------------------------------------------------------------

Exec_Check_2:				; ...
		cmp	al, 2
		jz	short Exec_Bad_Fun
		cmp	al, 4
		jz	short Exec_Bad_Fun
		cmp	al, 5
		jz	short ExecReadyJ
		mov	[bp-4],	bx	; Exec_BlkL
		mov	word ptr [bp-2], es
		mov	[bp-5],	al	; Exec_Func
		mov	byte ptr [bp-6], 0 ; Exec_Load_High
		mov	[bp-26], dx	; ExecNameL
		mov	word ptr [bp-24], ds ; ExecNameH
		mov	si, dx
		call	DStrLen
		mov	[bp-22], cx	; ExecNameLen
		mov	al, ss:AllocMethod
		mov	ss:ALLOCMSAVE, al
		xor	al, al
		push	bp
		or	ss:DOS_FLAG, 1	; EXECOPEN
		call	$OPEN
		pushf
		and	ss:DOS_FLAG, 0FEh ; ~EXECOPEN
		popf
		pop	bp
		jb	short Exec_Ret_Err
		mov	[bp-8],	ax	; Exec_FH
		mov	bx, ax
		xor	al, al
		call	$IOCTL
		jb	short Exec_BombJ
		test	dl, 80h		; devid_ISDEV
		jz	short Exec_Check_Environ
		mov	al, 2		; error_file_not_found

Exec_BombJ:				; ...
		jmp	Exec_Bomb
; ---------------------------------------------------------------------------

BadEnv:					; ...
		mov	al, 0Ah		; error_bad_environment
		jmp	Exec_Bomb
; ---------------------------------------------------------------------------

Exec_Check_Environ:			; ...
		mov	word ptr [bp-18], 0 ; Exec_Load_Block
		mov	word ptr [bp-14], 0 ; Exec_Environ
		test	byte ptr [bp-5], 2 ; Exec_Func,exec_func_overlay
		jnz	short Exec_Read_Header
		lds	si, [bp-4]	; Exec_Blk
		mov	ax, [si]	; [SI+EXEC1.ENVIRON]
		or	ax, ax
		jnz	short Exec_Scan_Env
		mov	ds, ss:CurrentPDB
		mov	ax, ds:2Ch	; [PDB.ENVIRON]
		or	ax, ax
		jz	short Exec_Read_Header

Exec_Scan_Env:				; ...
		mov	es, ax
		xor	di, di
		mov	cx, 8000h
		xor	al, al

Exec_Get_Environ_Len:			; ...
		repne scasb
		jnz	short BadEnv
		dec	cx
		js	short BadEnv
		scasb
		jnz	short Exec_Get_Environ_Len
		push	di
		lea	bx, [di+11h]	; [DI+0Fh+2]
		add	bx, [bp-22]	; ExecNameLen
		mov	cl, 4
		shr	bx, cl
		push	es
		call	$ALLOC
		pop	ds
		pop	cx
		jnb	short Exec_Save_Environ
		jmp	short Exec_No_Mem
; ---------------------------------------------------------------------------

Exec_Save_Environ:			; ...
		mov	es, ax
		mov	[bp-14], ax	; Exec_Environ
		xor	si, si
		mov	di, si
		rep movsb
		mov	ax, 1
		stosw
		lds	si, [bp-26]	; ExecName
		mov	cx, [bp-22]	; ExecNameLen
		rep movsb

Exec_Read_Header:			; ...
		push	ss
		pop	ds
		mov	cx, 26		; exec_header_len
		mov	dx, offset exec_signature
		push	es
		push	ds
		call	ExecRead
		pop	ds
		pop	es
		jb	short Exec_Bad_File
		or	ax, ax
		jz	short Exec_Bad_File
		cmp	ax, 26		; exec_header_len
		jnz	short Exec_Com_Filej
		test	ds:exec_max_BSS, 0FFFFh	; -1
		jnz	short Exec_Check_Sig
		mov	byte ptr [bp-6], 0FFh ;	Exec_Load_High,-1

Exec_Check_Sig:				; ...
		mov	ax, ds:exec_signature
		cmp	ax, 5A4Dh	; 'MZ'
		jz	short Exec_Save_Start
		cmp	ax, 4D5Ah	; 'ZM'
		jz	short Exec_Save_Start

Exec_Com_Filej:				; ...
		jmp	Exec_Com_File
; ---------------------------------------------------------------------------

Exec_Save_Start:			; ...
		mov	ax, ds:exec_pages
		mov	cl, 5
		shl	ax, cl
		sub	ax, ds:exec_par_dir
		mov	[bp-12], ax	; Exec_Res_Len_Para
		test	byte ptr [bp-5], 2 ; Exec_Func,exec_func_overlay
		jz	short Exec_Allocate
		les	di, [bp-4]	; Exec_Blk
		mov	ax, es:[di]	; [ES:DI+EXEC3.load_addr]
		mov	[bp-20], ax	; Exec_DMA
		mov	ax, es:[di+2]	; [ES:DI+EXEC3.reloc_fac]
		mov	[bp-10], ax	; Exec_Rel_Fac
		jmp	Exec_Find_Res
; ---------------------------------------------------------------------------

Exec_No_Mem:				; ...
		mov	al, 8		; error_not_enough_memory
		jmp	short Exec_Bomb
; ---------------------------------------------------------------------------

Exec_Bad_File:				; ...
		mov	al, 0Bh		; error_bad_format

Exec_Bomb:				; ...
		mov	bx, [bp-8]	; Exec_FH
		call	Exec_Dealloc
		call	LCritDisk	; call LCritMEM
		push	ax
		push	bp
		call	$CLOSE
		pop	bp
		pop	ax
		jmp	Exec_Ret_Err
; ---------------------------------------------------------------------------

Exec_Chk_Mem:				; ...
		mov	al, ss:AllocMethod
		mov	bl, ss:ALLOCMSAVE
		mov	ss:AllocMethod,	bl
		test	bl, 40h		; HIGH_ONLY
		jnz	short Exec_No_Mem
		test	al, 40h
		jz	short Exec_No_Mem
		mov	ax, ss:SAVE_AX
		jmp	short Exec_Norm_Alloc
; ---------------------------------------------------------------------------

Exec_Allocate:				; ...
		mov	byte ptr [bp-29], 0 ; Exec_NoStack
		cmp	ds:exec_SS, 0
		jnz	short ea1
		cmp	ds:exec_SP, 0
		jnz	short ea1
		inc	byte ptr [bp-29]
		cmp	ax, 0FF0h	; 1000h-10h
		jnb	short ea1
		add	ax, 10h

ea1:					; ...
		test	ds:AllocMethod,	80h ; HIGH_FIRST
		jz	short Exec_Norm_Alloc
		or	ds:AllocMethod,	40h ; HIGH_ONLY

Exec_Norm_Alloc:			; ...
		mov	ds:SAVE_AX, ax
		mov	bx, 0FFFFh
		push	ds
		call	$ALLOC
		pop	ds
		mov	ax, ds:SAVE_AX
		add	ax, 10h
		cmp	bx, 11h
		jb	short Exec_Chk_Mem
		cmp	ax, bx
		ja	short Exec_Chk_Mem
		test	byte ptr [bp-6], 0FFh ;	Exec_Load_High,-1
		jnz	short Exec_BX_Max
		add	ax, ds:exec_min_BSS
		jb	short Exec_Chk_Mem
		cmp	ax, bx
		ja	short Exec_Chk_Mem
		sub	ax, ds:exec_min_BSS
		add	ax, ds:exec_max_BSS
		jb	short Exec_BX_Max
		cmp	ax, bx
		jbe	short Exec_Got_Block

Exec_BX_Max:				; ...
		mov	ax, bx

Exec_Got_Block:				; ...
		push	ds
		mov	bx, ax
		mov	[bp-16], bx	; Exec_Size
		call	$ALLOC
		pop	ds
		jnb	short ea0
		jmp	Exec_Chk_Mem
; ---------------------------------------------------------------------------

ea0:					; ...
		mov	cl, ds:ALLOCMSAVE
		mov	ds:AllocMethod,	cl
		cmp	byte ptr [bp-29], 0 ; Exec_NoStack
		jz	short ea2
		cmp	bx, 1000h
		jnb	short ea2
		mov	cl, 4
		shl	bx, cl
		sub	bx, 100h
		mov	ds:exec_SP, bx

ea2:					; ...
		mov	[bp-18], ax	; Exec_Load_Block
		add	ax, 10h
		test	byte ptr [bp-6], 0FFh ;	Exec_Load_High,-1
		jz	short Exec_Use_AX
		add	ax, [bp-16]	; Exec_Size
		sub	ax, [bp-12]	; Exec_Res_Len_Para
		sub	ax, 10h

Exec_Use_AX:				; ...
		mov	[bp-10], ax	; Exec_Rel_Fac
		mov	[bp-20], ax	; Exec_DMA

Exec_Find_Res:				; ...
		mov	dx, [bp-20]	; Exec_DMA
		mov	[bp-28], dx	; Exec_DMA_Save
		mov	dx, ds:exec_par_dir
		push	dx
		mov	cl, 4
		shl	dx, cl
		pop	ax
		mov	cl, 12
		shr	ax, cl
		mov	cx, ax
		mov	bx, [bp-8]	; Exec_FH
		push	ds
		xor	al, al
		call	$LSEEK
		pop	ds
		jnb	short Exec_Big_Read
		jmp	Exec_Bomb
; ---------------------------------------------------------------------------

Exec_Big_Read:				; ...
		mov	bx, [bp-12]	; Exec_Res_Len_Para
		cmp	bx, 1000h
		jb	short Exec_Read_OK
		mov	bx, 0FE0h

Exec_Read_OK:				; ...
		sub	[bp-12], bx	; Exec_Res_Len_Para
		push	bx
		mov	cl, 4
		shl	bx, cl
		mov	cx, bx
		push	ds
		mov	ds, word ptr [bp-20] ; Exec_DMA
		xor	dx, dx
		push	cx
		call	ExecRead
		pop	cx
		pop	ds
		jb	short Exec_Bad_FileJ
		cmp	cx, ax
		pop	bx
		jz	short ExecCheckEnd
		sub	cx, ax
		cmp	cx, 512
		jnb	short Exec_Bad_FileJ

ExecCheckEnd:				; ...
		add	[bp-20], bx	; Exec_DMA
		test	word ptr [bp-0Ch], 0FFFFh ; Exec_Res_Len_Para,-1
		jnz	short Exec_Big_Read
		mov	cx, [bp-10]	; Exec_Rel_Fac
		mov	ax, ds:exec_SS
		add	ax, cx
		mov	ds:exec_init_SS, ax
		mov	ax, ds:exec_SP
		mov	ds:exec_init_SP, ax
		les	ax, dword ptr ds:exec_IP ; les ax,[exec_IP]
		mov	ds:exec_init_IP, ax
		mov	ax, es
		add	ax, cx
		mov	ds:exec_init_CS, ax
		xor	cx, cx
		mov	dx, ds:exec_rle_table
		mov	bx, [bp-8]	; Exec_FH
		push	ds
		xor	ax, ax
		call	$LSEEK
		pop	ds
		jnb	short exec_get_entries

Exec_Bad_FileJ:				; ...
		jmp	Exec_Bad_File
; ---------------------------------------------------------------------------

exec_get_entries:			; ...
		mov	dx, ds:exec_rle_count

exec_read_reloc:			; ...
		push	dx
		mov	dx, offset OPENBUF
		mov	cx, 396		; ((Exec_Internal_Buffer_Size)/4)*4
					; (397>>2)<<2
		push	ds
		call	ExecRead
		pop	es
		pop	dx
		jb	short Exec_Bad_FileJ
		mov	cx, 99		; (Exec_Internal_Buffer_Size)/4	; (397>>2)
		mov	di, offset OPENBUF ; Exec_Internal_Buffer
		mov	si, [bp-10]	; Exec_Rel_Fac

exec_reloc_one:				; ...
		or	dx, dx
		jz	short Exec_Set_PDBJ

exec_get_addr:
		lds	bx, es:[di]
		mov	ax, ds
		add	ax, [bp-28]	; Exec_DMA_Save
		mov	ds, ax
		add	[bx], si
		add	di, 4
		dec	dx
		loop	exec_reloc_one
		push	es
		pop	ds
		jmp	short exec_read_reloc
; ---------------------------------------------------------------------------

Exec_Set_PDBJ:				; ...
		push	es
		push	ax
		push	cx
		mov	es, word ptr [bp-28] ; Exec_DMA_Save
		mov	ax, ss:exec_init_CS
		mov	cx, ss:exec_init_IP
		call	ss:FixExePatch	; call word [ss:FixExePatch]
		pop	cx
		pop	ax
		pop	es
		jmp	Exec_Set_PDB
; ---------------------------------------------------------------------------

Exec_No_Memj:				; ...
		jmp	Exec_No_Mem
; ---------------------------------------------------------------------------

Exec_Com_File:				; ...
		test	byte ptr [bp-5], 2 ; Exec_Func,exec_func_overlay
		jz	short Exec_Alloc_Com_File
		lds	si, [bp-4]	; lds si,Exec_Blk
		lodsw
		mov	[bp-14h], ax	; mov Exec_DMA,ax
		mov	ax, 0FFFFh
		jmp	short Exec_Read_Block
; ---------------------------------------------------------------------------

Exec_Chk_Com_Mem:			; ...
		mov	al, ss:AllocMethod
		mov	bl, ss:ALLOCMSAVE
		mov	ss:AllocMethod,	bl
		test	bl, 40h		; HIGH_ONLY
		jnz	short Exec_No_Memj
		test	al, 40h
		jz	short Exec_No_Memj
		mov	ax, [bp-18]	; Exec_Load_Block
		xor	bx, bx
		call	ChangeOwner
		jmp	short Exec_Norm_Com_Alloc
; ---------------------------------------------------------------------------

Exec_Alloc_Com_File:			; ...
		test	ss:AllocMethod,	80h ; HIGH_FIRST
		jz	short Exec_Norm_Com_Alloc
		or	ss:AllocMethod,	40h ; HIGH_ONLY

Exec_Norm_Com_Alloc:			; ...
		mov	bx, 0FFFFh
		call	$ALLOC
		or	bx, bx
		jz	short Exec_Chk_Com_Mem
		mov	[bp-16], bx	; Exec_Size
		push	bx
		call	$ALLOC
		pop	bx
		mov	[bp-18], ax	; Exec_Load_Block
		add	ax, 10h
		mov	[bp-20], ax	; Exec_DMA
		xor	ax, ax
		cmp	bx, 1000h
		jnb	short Exec_Read_Com
		mov	ax, bx
		mov	cl, 4
		shl	ax, cl
		cmp	ax, 100h
		jbe	short Exec_Chk_Com_Mem
		sub	ax, 100h

Exec_Read_Com:				; ...
		sub	ax, 100h

Exec_Read_Block:			; ...
		push	ax
		mov	bx, [bp-8]	; Exec_FH
		xor	cx, cx
		mov	dx, cx
		xor	ax, ax
		call	$LSEEK
		pop	cx
		mov	ds, word ptr [bp-20] ; Exec_DMA
		xor	dx, dx
		push	cx
		call	ExecRead
		pop	si
		jnb	short OkRead
		jmp	Exec_Bad_File
; ---------------------------------------------------------------------------

OkRead:					; ...
		cmp	ax, si
		jnz	short OkRead2
		jmp	Exec_Chk_Com_Mem
; ---------------------------------------------------------------------------

OkRead2:				; ...
		mov	bl, ss:ALLOCMSAVE
		mov	ss:AllocMethod,	bl
		test	byte ptr [bp-5], 2 ; Exec_Func,exec_func_overlay
		jnz	short Exec_Set_PDB
		mov	ax, [bp-20]	; Exec_DMA
		sub	ax, 10h
		mov	ss:exec_init_CS, ax
		mov	ss:exec_init_IP, 100h
		add	si, 0FEh
		cmp	si, 0FFFEh
		jz	short Exec_St_Ok
		add	si, 100h

Exec_St_Ok:				; ...
		mov	ss:exec_init_SP, si
		mov	ss:exec_init_SS, ax
		mov	ds, ax
		mov	word ptr [si], 0
		call	ss:ChkCopyProt	; call word [ss:ChkCopyProt]

Exec_Set_PDB:				; ...
		mov	bx, [bp-8]	; Exec_FH
		call	Exec_Dealloc
		push	bp
		call	$CLOSE
		pop	bp
		call	Exec_Alloc
		test	byte ptr [bp-5], 2 ; Exec_Func,exec_func_overlay
		jz	short Exec_Build_Header
		call	Scan_Execname
		call	Scan_Special_Entries
		cmp	ss:DriverLoad, 0
		jz	short norm_ovl
		push	si
		push	es
		les	si, ss:BiosDataPtr
		cmp	byte ptr es:[si], 0
		jz	short sysinit_done
		mov	es, ss:CurrentPDB
		push	ss:SPECIAL_VERSION ; push word [ss:SPECIAL_VERSION]
		pop	word ptr es:SFTFCB ; pop word [es:PDB.Version]
		jmp	short setver_done
; ---------------------------------------------------------------------------

sysinit_done:				; ...
		mov	ss:DriverLoad, 0

setver_done:				; ...
		pop	es
		pop	si

norm_ovl:				; ...
		mov	sp, bp
		pop	bp
		jmp	SYS_RETURN	; SYS_RET_OK
; ---------------------------------------------------------------------------

Exec_Build_Header:			; ...
		mov	dx, [bp-18]	; Exec_Load_Block
		mov	si, 1		; ARENA.OWNER
		mov	ax, [bp-14]	; Exec_Environ
		or	ax, ax
		jz	short No_Owner
		dec	ax
		mov	ds, ax
		mov	[si], dx

No_Owner:				; ...
		mov	ax, [bp-18]	; Exec_Load_Block
		dec	ax
		mov	ds, ax
		mov	[si], dx
		push	ds
		pop	es
		mov	di, 8		; ARENA.NAME
		call	Scan_Execname
		push	cx
		push	si

MoveName:				; ...
		lodsb
		cmp	al, '.'         ; 2Eh
		jz	short Mem_Done
		stosb
		cmp	di, 16		; ARENAHEADERSIZE
		jnb	short Mem_Done
		loop	MoveName

Mem_Done:				; ...
		xor	al, al
		cmp	di, 16		; ARENAHEADERSIZE
		jnb	short Fill8
		stosb

Fill8:					; ...
		pop	si
		pop	cx
		call	Scan_Special_Entries
		push	dx
		mov	si, [bp-16]	; Exec_Size
		add	si, dx
		call	$DUP_PDB
		pop	dx
		push	word ptr [bp-14] ; Exec_Environ
		pop	word ptr es:2Ch	; [ES:PDB.ENVIRON]
		push	ss:SPECIAL_VERSION
		pop	word ptr es:SFTFCB ; [ES:PDB.Version]
		lds	si, [bp-4]	; Exec_Blk
		push	ds
		push	si
		lds	si, [si+6]	; [SI+EXEC0.5C_FCB]
		mov	cx, 12
		push	cx
		mov	di, 5Ch
		mov	bl, [si]
		rep movsb
		xor	ax, ax
		stosw
		stosw
		pop	cx
		pop	si
		pop	ds
		push	ds
		push	si
		lds	si, [si+0Ah]	; [SI+EXEC0.6C_FCB]
		mov	bh, [si]
		rep movsb
		stosw
		stosw
		pop	si
		pop	ds
		lds	si, [si+2]	; [SI+EXEC0.COM_LINE]
		or	cl, 80h
		mov	di, cx
		rep movsb
		dec	cl
		mov	al, bh
		xor	bh, bh
		call	GetVisDrv
		jnb	short Exec_BL
		mov	bh, cl

Exec_BL:				; ...
		mov	al, bl
		xor	bl, bl
		call	GetVisDrv
		jnb	short Exec_Set_Return
		mov	bl, cl

Exec_Set_Return:			; ...
		call	Get_User_Stack
		push	word ptr [si+14h] ; [SI+user_env.user_CS]
		push	word ptr [si+12h] ; [SI+user_env.user_IP]
		push	word ptr [si+14h] ; [SI+user_env.user_CS]
		push	word ptr [si+12h] ; [SI+user_env.user_IP]
		pop	word ptr es:0Ah	; [ES:PDB.EXIT]
		pop	word ptr es:0Ch	; [ES:PDB.EXIT+2]
		xor	ax, ax
		mov	ds, ax
		pop	word ptr ds:88h	; [addr_int_terminate] ; 22h*4
		pop	word ptr ds:8Ah	; [addr_int_terminate+2] ; (22h*4)+2
		mov	word ptr ss:DMAADD, 80h
		mov	ds, ss:CurrentPDB
		mov	word ptr ss:DMAADD+2, ds
		test	byte ptr [bp-5], 1 ; Exec_Func,exec_func_no_execute
		jz	short exec_go
		lds	si, dword ptr ss:exec_init_SP
		les	di, [bp-4]	; Exec_Blk
		mov	word ptr es:[di+10h], ds ; [ES:DI+EXEC1.SS]
		dec	si
		dec	si
		mov	[si], bx
		mov	es:[di+0Eh], si	; [ES:DI+EXEC1.SP]
		lds	ax, dword ptr ss:exec_init_IP
		mov	word ptr es:[di+14h], ds ; [ES:DI+EXEC1.CS]
		mov	es:[di+12h], ax	; [ES:DI+EXEC1.IP]
		mov	sp, bp
		pop	bp
		jmp	SYS_RETURN	; SYS_RET_OK
; ---------------------------------------------------------------------------

exec_go:				; ...
		lds	si, dword ptr ss:exec_init_IP
		les	di, dword ptr ss:exec_init_SP
		mov	ax, es
		cmp	ss:DosHasHMA, 0
		jz	short Xfer_To_User
		push	ds
		mov	ds, cs:DosDSeg
		or	ds:DOS_FLAG, 4	; EXECA20OFF
		mov	ds:A20OFF_PSP, dx
		mov	ax, ds
		pop	ds
		push	ax
		mov	ax, offset disa20_xfer
		push	ax
		mov	ax, es
		retf
; ---------------------------------------------------------------------------

Xfer_To_User:				; ...
		cli
		mov	ss:INDOS, 0
		mov	ss, ax
		mov	sp, di
		sti
		push	ds
		push	si
		mov	es, dx
		mov	ds, dx
		mov	ax, bx
		retf

; =============== S U B	R O U T	I N E =======================================


ExecRead	proc near		; ...
		call	Exec_Dealloc
		mov	bx, [bp-8]	; Exec_FH
		push	bp
		call	$READ
		pop	bp
		call	Exec_Alloc
		retn
ExecRead	endp


; =============== S U B	R O U T	I N E =======================================


Exec_Dealloc	proc near		; ...
		push	bx
		sub	bx, bx
		call	ECritDisk	; call ECritMEM
		call	ChangeOwners
		pop	bx
		retn
Exec_Dealloc	endp


; =============== S U B	R O U T	I N E =======================================


Exec_Alloc	proc near		; ...
		push	bx
		mov	bx, ss:CurrentPDB
		call	ChangeOwners
		call	LCritDisk	; call LCritMEM
		pop	bx
		retn
Exec_Alloc	endp


; =============== S U B	R O U T	I N E =======================================


ChangeOwners	proc near		; ...
		pushf
		push	ax
		mov	ax, [bp-14]	; Exec_Environ
		call	ChangeOwner
		mov	ax, [bp-18]	; Exec_Load_Block
		call	ChangeOwner
		pop	ax
		popf

chgown_retn:				; ...
		retn
ChangeOwners	endp


; =============== S U B	R O U T	I N E =======================================


ChangeOwner	proc near		; ...
		or	ax, ax
		jz	short chgown_retn
		dec	ax
		push	ds
		mov	ds, ax
		mov	ds:1, bx	; [ARENA.OWNER]
		pop	ds
		retn
ChangeOwner	endp


; =============== S U B	R O U T	I N E =======================================


Scan_Execname	proc near		; ...
		lds	si, [bp-26]	; ExecName

Save_Begin:				; ...
		mov	cx, si

Scan0:					; ...
		lodsb
		cmp	al, ':'         ; 3Ah
		jz	short Save_Begin
		cmp	al, '\'         ; 5Ch
		jz	short Save_Begin
		cmp	al, 0
		jnz	short Scan0
		sub	si, cx
		xchg	si, cx
		retn
Scan_Execname	endp


; =============== S U B	R O U T	I N E =======================================


Scan_Special_Entries proc near		; ...
		dec	cx
		mov	ss:SPECIAL_VERSION, 5
		les	di, ss:UU_IFS_DOS_CALL
		mov	ax, es
		or	ax, di
		jz	short End_List

GetEntries:				; ...
		mov	al, es:[di]
		or	al, al
		jz	short End_List
		mov	ss:TEMP_VAR2, di
		cmp	al, cl
		jnz	short SkipOne
		inc	di
		push	cx
		push	si
		push	ax

sse_next_char:				; ...
		lodsb
		call	UCase
		scasb
		jnz	short Not_Matched
		loop	sse_next_char
		pop	ax
		mov	ax, es:[di]
		mov	ss:SPECIAL_VERSION, ax
		pop	si
		pop	cx
		jmp	short End_List
; ---------------------------------------------------------------------------

Not_Matched:				; ...
		pop	ax
		pop	si
		pop	cx

SkipOne:				; ...
		mov	di, ss:TEMP_VAR2
		xor	ah, ah
		add	di, ax
		add	di, 3
		jmp	short GetEntries
; ---------------------------------------------------------------------------

End_List:				; ...
		retn
Scan_Special_Entries endp

; ---------------------------------------------------------------------------

$KEEP_PROCESS:				; ...
		push	ax
		mov	ss:EXIT_TYPE, 3	; EXIT_KEEP_PROCESS
		mov	es, ss:CurrentPDB
		cmp	dx, 6
		jnb	short Keep_Shrink
		mov	dx, 6

Keep_Shrink:				; ...
		mov	bx, dx
		push	bx
		push	es
		call	$SETBLOCK
		pop	ds
		pop	bx
		jb	short Keep_Done
		mov	ax, ds
		add	ax, bx
		mov	ds:2, ax	; [PDB.BLOCK_LEN]

Keep_Done:				; ...
		pop	ax
		jmp	short exit_inner
; ---------------------------------------------------------------------------

STAY_RESIDENT:				; ...
		mov	ax, 3100h	; (KEEP_PROCESS<<8)+0
		add	dx, 15
		rcr	dx, 1
		mov	cl, 3
		shr	dx, cl
		jmp	COMMAND
; ---------------------------------------------------------------------------

$EXIT:					; ...
		xor	ah, ah
		xchg	ah, ss:DidCTRLC
		or	ah, ah
		mov	ss:EXIT_TYPE, 0	; EXIT_TERMINATE
		jz	short exit_inner
		mov	ss:EXIT_TYPE, 1	; EXIT_CTRL_C

exit_inner:				; ...
		call	Get_User_Stack
		push	ss:CurrentPDB
		pop	word ptr [si+14h] ; [SI+user_env.user_CS]
		jmp	short abort_inner
; ---------------------------------------------------------------------------

$ABORT:					; ...
		xor	al, al
		mov	ss:EXIT_TYPE, 0	; EXIT_ABORT

abort_inner:				; ...
		mov	ah, ss:EXIT_TYPE
		mov	ss:exit_code, ax
		call	Get_User_Stack
		mov	ds, word ptr [si+14h] ;	[SI+user_env.user_CS]
		xor	ax, ax
		mov	es, ax
		mov	si, 10		; SAVEXIT
		mov	di, 88h		; addr_int_terminate
		movsw
		movsw
		movsw
		movsw
		movsw
		movsw
		jmp	reset_environment
; ---------------------------------------------------------------------------

RetExePatch:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================


arena_free_process proc	near		; ...
		mov	ax, ss:arena_head

arena_free_process_start:		; ...
		mov	di, 0		; ARENA.SIGNATURE
		call	check_signature

arena_free_process_loop:		; ...
		jb	short AFP_RETN
		push	es
		pop	ds
		cmp	ds:1, bx	; [ARENA.OWNER]
		jnz	short arena_free_next
		mov	ds:1, di

arena_free_next:			; ...
		cmp	byte ptr [di], 5Ah ; 'Z' ; arena_signature_end
		jz	short arena_chk_umbs
		call	arena_next
		jmp	short arena_free_process_loop
; ---------------------------------------------------------------------------

arena_chk_umbs:				; ...
		mov	ax, ss:UMB_HEAD
		cmp	ax, 0FFFFh
		jz	short AFP_RETN
		mov	di, ds
		cmp	di, ax
		jnb	short AFP_RETN
		jmp	short arena_free_process_start
arena_free_process endp

; ---------------------------------------------------------------------------

arena_next:				; ...
		mov	ax, ds
		add	ax, ds:3	; [ARENA.SIZE]
		inc	ax

; =============== S U B	R O U T	I N E =======================================


check_signature	proc near		; ...
		mov	es, ax
		cmp	byte ptr es:[di], 4Dh ;	'M' ; arena_signature_normal
		jz	short AFP_RETN
		cmp	byte ptr es:[di], 5Ah ;	'Z' ; arena_signature_end
		jz	short AFP_RETN
		stc

AFP_RETN:				; ...
		retn			; COALESCE_RETN
check_signature	endp


; =============== S U B	R O U T	I N E =======================================


Coalesce	proc near		; ...
		cmp	byte ptr [di], 5Ah ; 'Z' ; arena_signature_end
		jz	short AFP_RETN	; COALESCE_RETN
		call	arena_next
		jb	short AFP_RETN	; COALESCE_RETN
		cmp	es:1, di	; [ES:ARENA.OWNER]
		jnz	short AFP_RETN	; COALESCE_RETN
		mov	cx, es:3	; [ES:ARENA.SIZE]
		inc	cx
		add	ds:3, cx	; [ARENA.SIZE]
		mov	cl, es:[di]
		mov	[di], cl
		jmp	short Coalesce
Coalesce	endp

; ---------------------------------------------------------------------------

$ALLOC:					; ...
		call	ECritDisk	; call ECritMEM
		mov	ax, ss:arena_head
		mov	ss:START_ARENA,	ax
		test	ss:AllocMethod,	0C0h ; HIGH_FIRST+HIGH_ONLY
		jz	short norm_alloc
		test	ss:UMBFLAG, 1	; LINKSTATE
		jz	short norm_alloc
		mov	ax, ss:UMB_HEAD
		mov	ss:START_ARENA,	ax

norm_alloc:				; ...
		xor	ax, ax
		mov	di, ax
		mov	ss:FirstArena, ax
		mov	ss:BestArena, ax
		mov	ss:LastArena, ax
		push	ax

start_scan:				; ...
		mov	ax, ss:START_ARENA
		call	check_signature
		jb	short alloc_err

alloc_scan:				; ...
		push	es
		pop	ds
		cmp	ds:1, di	; [ARENA.OWNER]
		jz	short alloc_free

alloc_next:				; ...
		test	ss:UMBFLAG, 1	; LINKSTATE
		jz	short norm_strat
		test	ss:AllocMethod,	80h ; HIGH_FIRST
		jz	short norm_strat
		mov	ax, ss:START_ARENA
		cmp	ax, ss:arena_head
		jnz	short norm_strat
		mov	ax, ds
		cmp	ax, ss:UMB_HEAD
		jmp	short alloc_chk_end
; ---------------------------------------------------------------------------

norm_strat:				; ...
		cmp	byte ptr [di], 5Ah ; 'Z' ; arena_signature_end

alloc_chk_end:				; ...
		jz	short alloc_end
		call	arena_next
		jnb	short alloc_scan

alloc_err:				; ...
		pop	ax
; START	OF FUNCTION CHUNK FOR $SETBLOCK

alloc_trashed:				; ...
		call	LCritDisk	; call LCritMEM
		mov	al, 7		; error_arena_trashed

alloc_errj:				; ...
		jmp	SYS_RET_ERR
; END OF FUNCTION CHUNK	FOR $SETBLOCK
; ---------------------------------------------------------------------------

alloc_end:				; ...
		cmp	ss:FirstArena, 0
		jz	short alloc_chk
		jmp	alloc_do_split
; ---------------------------------------------------------------------------

alloc_chk:				; ...
		mov	ax, ss:arena_head
		cmp	ax, ss:START_ARENA
		jz	short alloc_fail
		test	ss:AllocMethod,	40h ; HIGH_ONLY
		jnz	short alloc_fail
		mov	ss:START_ARENA,	ax
		jmp	short start_scan
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR $SETBLOCK

alloc_fail:				; ...
		call	Get_User_Stack
		pop	bx
		mov	[si+2],	bx	; [SI+user_env.user_BX]
		call	LCritDisk	; call LCritMEM
		mov	al, 8		; error_not_enough_memory
		jmp	short alloc_errj
; END OF FUNCTION CHUNK	FOR $SETBLOCK
; ---------------------------------------------------------------------------

alloc_free:				; ...
		call	Coalesce
		jb	short alloc_err
		mov	cx, ds:3	; [ARENA.SIZE]
		pop	dx
		cmp	cx, dx
		jbe	short alloc_test
		mov	dx, cx

alloc_test:				; ...
		push	dx
		cmp	bx, cx
		ja	short alloc_next
		cmp	ss:FirstArena, 0
		jnz	short alloc_best
		mov	ss:FirstArena, ds

alloc_best:				; ...
		cmp	ss:BestArena, 0
		jz	short alloc_make_best
		push	es
		mov	es, ss:BestArena
		cmp	es:3, cx	; [ES:ARENA.SIZE]
		pop	es
		jbe	short alloc_last

alloc_make_best:			; ...
		mov	ss:BestArena, ds

alloc_last:				; ...
		mov	ss:LastArena, ds
		jmp	alloc_next
; ---------------------------------------------------------------------------

alloc_do_split_high:			; ...
		mov	ds, ss:LastArena
		mov	cx, ds:3	; [ARENA.SIZE]
		sub	cx, bx
		mov	dx, ds
		jz	short alloc_set_owner
		add	dx, cx
		mov	es, dx
		dec	cx
		xchg	bx, cx
		jmp	short alloc_set_sizes
; ---------------------------------------------------------------------------

alloc_do_split:				; ...
		xor	cx, cx
		mov	cl, ss:AllocMethod
		and	cx, 0FF3Fh	; STRAT_MASK
		cmp	cx, 1		; BEST_FIT
		ja	short alloc_do_split_high
		mov	ds, ss:FirstArena
		jb	short alloc_get_size
		mov	ds, ss:BestArena
; START	OF FUNCTION CHUNK FOR $SETBLOCK

alloc_get_size:				; ...
		mov	cx, ds:3	; [ARENA.SIZE]
		sub	cx, bx
		mov	ax, ds
		mov	dx, ax
		jz	short alloc_set_owner
		add	ax, bx
		inc	ax
		mov	es, ax
		dec	cx

alloc_set_sizes:			; ...
		mov	ds:3, bx	; [ARENA.SIZE]
		mov	es:3, cx	; [ES:ARENA.SIZE]
		mov	bl, 4Dh	; 'M'   ; arena_signature_normal
		xchg	bl, [di]
		mov	es:[di], bl
		mov	es:1, di	; [ES:ARENA.OWNER]

alloc_set_owner:			; ...
		mov	ds, dx
		mov	ax, ss:CurrentPDB
		mov	ds:1, ax	; [ARENA.OWNER]
		mov	ax, ds
		inc	ax
		pop	bx
		call	LCritDisk	; call LCritMEM

alloc_ok:				; ...
		jmp	SYS_RETURN	; SYS_RET_OK
; END OF FUNCTION CHUNK	FOR $SETBLOCK

; =============== S U B	R O U T	I N E =======================================


$SETBLOCK	proc near		; ...

; FUNCTION CHUNK AT A2A2 SIZE 00000008 BYTES
; FUNCTION CHUNK AT A2CE SIZE 0000000E BYTES
; FUNCTION CHUNK AT A355 SIZE 0000003A BYTES

		call	ECritDisk	; call ECritMEM
		mov	di, 0		; ARENA.SIGNATURE
		mov	ax, es
		dec	ax
		call	check_signature
		jnb	short setblock_grab

setblock_bad:				; ...
		jmp	alloc_trashed
; ---------------------------------------------------------------------------

setblock_grab:				; ...
		mov	ds, ax
		call	Coalesce
		jb	short setblock_bad
		mov	cx, ds:3	; [ARENA.SIZE]
		push	cx
		cmp	bx, cx
		jbe	short alloc_get_size
		jmp	alloc_fail
$SETBLOCK	endp


; =============== S U B	R O U T	I N E =======================================


$DEALLOC	proc near		; ...
		call	ECritDisk	; call ECritMEM
		test	ss:DOS_FLAG, 4	; EXECA20OFF
		jz	short deallocate
		cmp	ss:A20OFF_COUNT, 0
		jnz	short deallocate
		mov	ss:A20OFF_COUNT, 1

deallocate:				; ...
		mov	di, 0		; ARENA.SIGNATURE
		mov	ax, es
		dec	ax
		call	check_signature
		jb	short dealloc_err
		mov	es:1, di	; [ES:ARENA.OWNER]
		call	LCritDisk	; call LCritMEM

dealloc_ok:				; ...
		jmp	short alloc_ok
; ---------------------------------------------------------------------------

dealloc_err:				; ...
		call	LCritDisk	; call LCritMEM
		mov	al, 9		; error_invalid_block

dealloc_errj:				; ...
		jmp	SYS_RET_ERR
$DEALLOC	endp

; ---------------------------------------------------------------------------

$ALLOCOPER:				; ...
		or	al, al
		jz	short AllocGetStrat
		cmp	al, 1
		jz	short AllocSetStrat
		cmp	al, 2
		jz	short AllocGetLink
		cmp	al, 3
		jz	short AllocSetLink

AllocOperError:				; ...
		mov	ss:EXTERR_LOCUS, 5 ; errLOC_Mem
		mov	al, 1		; error_invalid_function

AllocOperErrj:				; ...
		jmp	short dealloc_errj
; ---------------------------------------------------------------------------

AllocArenaError:			; ...
		mov	ss:EXTERR_LOCUS, 5 ; errLOC_Mem
		mov	al, 7		; error_arena_trashed
		jmp	short AllocOperErrj
; ---------------------------------------------------------------------------

AllocGetStrat:				; ...
		mov	al, ss:AllocMethod
		xor	ah, ah

AllocOperOk:				; ...
		jmp	short dealloc_ok
; ---------------------------------------------------------------------------

AllocSetStrat:				; ...
		push	bx
		and	bx, 0FF3Fh
		cmp	bx, 2
		pop	bx
		ja	short AllocOperError
		mov	ss:AllocMethod,	bl

AllocOperOkj:				; ...
		jmp	short AllocOperOk
; ---------------------------------------------------------------------------

AllocGetLink:				; ...
		mov	al, ss:UMBFLAG
		and	al, 1		; LINKSTATE

AllocOperOkj2:				; ...
		jmp	short AllocOperOkj
; ---------------------------------------------------------------------------

AllocSetLink:				; ...
		mov	cx, ss:UMB_HEAD
		cmp	cx, 0FFFFh
		jz	short AllocOperError
		cmp	bx, 1
		jb	short UnlinkUmbs
		jz	short LinkUmbs
		jmp	short AllocOperError
; ---------------------------------------------------------------------------

UnlinkUmbs:				; ...
		test	ss:UMBFLAG, 1	; LINKSTATE
		jz	short unlinked
		call	GetLastArena
		jb	short AllocArenaError
		mov	byte ptr ds:0, 5Ah ; 'Z' ; arena_signature_end
		and	ss:UMBFLAG, 0FEh ; ~LINKSTATE

unlinked:				; ...
		jmp	short AllocOperOkj2
; ---------------------------------------------------------------------------

LinkUmbs:				; ...
		test	ss:UMBFLAG, 1	; LINKSTATE
		jnz	short linked
		call	GetLastArena
		jb	short AllocArenaError
		mov	byte ptr ds:0, 4Dh ; 'M' ; arena_signature_normal
		or	ss:UMBFLAG, 1	; LINKSTATE

linked:					; ...
		jmp	short unlinked

; =============== S U B	R O U T	I N E =======================================


GetLastArena	proc near		; ...
		push	ax
		mov	ax, ss:arena_head
		mov	es, ax
		xor	di, di
		cmp	byte ptr es:[di], 5Ah ;	'Z' ; arena_signature_end
		jz	short GLA_done

GLA_next:				; ...
		mov	ds, ax
		call	arena_next
		jb	short GLA_err
		test	ss:UMBFLAG, 1	; LINKSTATE
		jnz	short GLA_chkumb
		cmp	byte ptr es:[di], 5Ah ;	'Z'
		jmp	short GLA_@f
; ---------------------------------------------------------------------------

GLA_chkumb:				; ...
		cmp	ax, cx

GLA_@f:					; ...
		jnz	short GLA_next

GLA_done:				; ...
		test	ss:UMBFLAG, 1
		jnz	short GLA_ret
		mov	ds, ax
		call	arena_next
		jb	short GLA_err
		cmp	ax, cx
		jnz	short GLA_err

GLA_ret:				; ...
		clc
		pop	ax
		retn
; ---------------------------------------------------------------------------

GLA_err:				; ...
		stc
		pop	ax
		retn
GetLastArena	endp

; ---------------------------------------------------------------------------
SERVERTAB	dw offset SERVER_DISP	; ...
					; SRVC001S
SERVERLEAVE	dw offset SERVERRETURN	; ...
SERVER_DISP	db 11			; ...
					; (SERVER_DISP_END-SERVER_DISP-1)/2
					; ; = 11
		dw offset SRV_CALL	; 0
		dw offset COMMIT_ALL	; 1
		dw offset CLOSE_NAME	; 2
		dw offset CLOSE_UID	; 3
		dw offset CLOSE_UID_PID	; 4
		dw offset GET_LIST	; 5
		dw offset GET_DOS_DATA	; 6
		dw offset SPOOL_OPER	; 7
		dw offset SPOOL_OPER	; 8
		dw offset SPOOL_OPER	; 9
		dw offset _$SetExtendedError ; 10
; ---------------------------------------------------------------------------

$ServerCall:				; ...
		cmp	al, 7
		jb	short SET_STUFF
		cmp	al, 9
		jbe	short NO_SET_ID

SET_STUFF:				; ...
		mov	si, dx
		mov	bx, [si+12h]	; [SI+DPL.UID]
		test	ss:IsWin386, 1
		jnz	short skip_win386
		mov	ss:USER_ID, bx

skip_win386:				; ...
		mov	bx, [si+14h]	; [SI+DPL.PID]
		mov	ss:PROC_ID, bx

NO_SET_ID:				; ...
		push	cs:SERVERLEAVE
		push	cs:SERVERTAB
		push	ax
		call	TableDispatch
		mov	ss:EXTERR_LOCUS, 1 ; errLOC_Unk
		mov	al, 1		; error_invalid_function

servercall_error:			; ...
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

SERVERRETURN:				; ...
		retn
; ---------------------------------------------------------------------------

COMMIT_ALL:				; ...
		xor	bx, bx
		push	ss
		pop	ds
		call	ECritDisk	; call ECritSFT

CommitLoop:				; ...
		push	bx
		call	SFFromSFN
		jb	short CommitDone
		cmp	word ptr es:[di], 0 ; [ES:DI+SF_ENTRY.sf_Ref_Count]
		jz	short CommitNext
		cmp	word ptr es:[di], 0FFFFh ; [ES:DI+SF_ENTRY.sf_Ref_Count],
					; sf_busy
		jz	short CommitNext
		test	word ptr es:[di+5], 8000h ; [ES:DI+SF_ENTRY.sf_flags],
					; sf_isnet
		jnz	short CommitNext
		mov	word ptr ds:THISSFT, di
		mov	word ptr ds:THISSFT+2, es
		call	DOS_COMMIT

CommitNext:				; ...
		pop	bx
		inc	bx
		jmp	short CommitLoop
; ---------------------------------------------------------------------------

CommitDone:				; ...
		call	LCritDisk	; call LCritSFT
		pop	bx

Commit_Ok:				; ...
		jmp	SYS_RETURN	; SYS_RET_OK
; ---------------------------------------------------------------------------

CLOSE_NAME:				; ...
		call	dword ptr ss:MFTcloN ; Call far	[SS:JShare+(5*4)] ; 5 =	MFTcloN

CheckReturns:				; ...
		jb	short func_err

Commit_Okj:				; ...
		jmp	short Commit_Ok
; ---------------------------------------------------------------------------

func_err:				; ...
		jmp	short servercall_error
; ---------------------------------------------------------------------------

CLOSE_UID:				; ...
		call	ss:MFTclU	; Call far [SS:JShare+(3*4)] ; 3 = MTFTclu
		jmp	short CheckReturns
; ---------------------------------------------------------------------------

CLOSE_UID_PID:				; ...
		call	dword ptr ss:MFTCloseP
		jmp	short CheckReturns
; ---------------------------------------------------------------------------

GET_LIST:				; ...
		call	ss:MFT_get	; Call far [SS:JShare+(9*4)] ; 9 = MFT_get
		jb	short func_err
		call	Get_User_Stack
		mov	[si+2],	bx	; [SI+user_env.user_BX]
		mov	[si+10], di	; [SI+user_env.user_DI]
		mov	word ptr [si+16], es ; [SI+user_env.user_ES]

SetCXOK:				; ...
		mov	[si+4],	cx	; [SI+user_env.user_CX]

Commit_Okj2:				; ...
		jmp	short Commit_Okj
; ---------------------------------------------------------------------------

SRV_CALL:				; ...
		pop	ax
		push	ds
		push	si
		call	Get_User_Stack
		pop	di
		pop	es
		call	XCHGP
		push	si
		mov	cx, 6
		rep movsw
		inc	di
		inc	di
		movsw
		movsw
		pop	si
		mov	ax, [si]	; [SI+DPL.AX]
		mov	bx, [si+2]	; [SI+DPL.BX]
		mov	cx, [si+4]	; [SI+DPL.CX]
		mov	dx, [si+6]	; [SI+DPL.DX]
		mov	di, [si+10]	; [SI+DPL.DI]
		mov	es, word ptr [si+14] ; [SI+DPL.ES]
		push	word ptr [si+8]	; [SI+DPL.SI]
		mov	ds, word ptr [si+12] ; [SI+DPL.DS]
		pop	si
		mov	ss:SAVEDS, ds
		mov	ss:SAVEBX, bx
		mov	ss:FSHARING, 0FFh ; -1
		jmp	REDISP
; ---------------------------------------------------------------------------

GET_DOS_DATA:				; ...
		push	ss
		pop	es
		mov	di, offset ERRORMODE ; SWAP_START
		mov	cx, offset SWAP_END
		mov	dx, offset USER_IN_AX ;	SWAP_ALWAYS
		sub	cx, di
		sub	dx, di
		shr	cx, 1
		adc	cx, 0
		shl	cx, 1
		call	Get_User_Stack
		mov	word ptr [si+14], es ; [SI+user_env.user_DS]
		mov	[si+8],	di	; [SI+user_env.user_SI]
		mov	[si+6],	dx	; [SI+user_env.user_DX]
		jmp	short SetCXOK
; ---------------------------------------------------------------------------

SPOOL_OPER:				; ...
		push	ax
		mov	ax, 1125h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - REDIRECTED PRINTER MODE
					; STACK: WORD subfunction
					; Return: CF set on error, AX =	error code
					; STACK	unchanged
		pop	bx
		jb	short func_err2
		jmp	short Commit_Okj2
; ---------------------------------------------------------------------------

func_err2:				; ...
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

_$SetExtendedError:			; ...
		mov	ax, [si]	; [SI+DPL.AX]
		mov	ss:EXTERR, ax
		mov	ax, [si+10]	; [SI+DPL.DI]
		mov	word ptr ss:EXTERRPT, ax
		mov	ax, [si+14]	; [SI+DPL.ES]
		mov	word ptr ss:EXTERRPT+2,	ax
		mov	ax, [si+2]	; [SI+DPL.BX]
		mov	word ptr ss:EXTERR_ACTION, ax
		mov	ax, [si+4]	; [SI+DPL.CX]
		mov	ss:EXTERR_LOCUS, ah
		retn

; =============== S U B	R O U T	I N E =======================================


pJFNFromHandle	proc near		; ...
		mov	es, cs:DosDSeg
		mov	es, es:CurrentPDB
		cmp	bx, es:32h	; [ES:PDB.JFN_Length]
		jb	short pjfn10
		mov	al, 6		; error_invalid_handle

ReturnCarry:				; ...
		stc
		retn
; ---------------------------------------------------------------------------

pjfn10:					; ...
		les	di, es:34h	; [ES:PDB.JFN_Pointer]
		add	di, bx

pJFNFromHandle_error:			; ...
		retn
pJFNFromHandle	endp


; =============== S U B	R O U T	I N E =======================================


SFFromHandle	proc near		; ...
		call	pJFNFromHandle
		jb	short pJFNFromHandle_error
		cmp	byte ptr es:[di], 0FFh ; -1
		jnz	short GetSF
		mov	al, 6
		jmp	short ReturnCarry
; ---------------------------------------------------------------------------

GetSF:					; ...
		push	bx
		mov	bl, es:[di]
		xor	bh, bh
		call	SFFromSFN
		pop	bx
		retn
SFFromHandle	endp


; =============== S U B	R O U T	I N E =======================================


SFFromSFN	proc near		; ...
		mov	es, cs:DosDSeg
		les	di, es:SFT_ADDR

sfsfn5:					; ...
		cmp	bx, es:[di+4]	; [ES:DI+SFT.SFCount]
		jb	short sfsfn7
		sub	bx, es:[di+4]
		les	di, es:[di]	; [ES:DI+SFT.SFLink]
		cmp	di, 0FFFFh	; -1
		jnz	short sfsfn5
		stc
		retn
; ---------------------------------------------------------------------------

sfsfn7:					; ...
		push	ax
		mov	ax, 59		; SF_ENTRY.size
		mul	bl
		add	di, ax
		pop	ax
		add	di, 6		; SFT.SFTable
		retn
SFFromSFN	endp


; =============== S U B	R O U T	I N E =======================================


JFNFree		proc near		; ...
		xor	bx, bx

jfnf1:					; ...
		call	pJFNFromHandle
		jb	short jfnf5
		cmp	byte ptr es:[di], 0FFh ; -1
		jz	short jfnfx
		inc	bx
		jmp	short jfnf1
; ---------------------------------------------------------------------------

jfnf5:					; ...
		mov	al, 4		; error_too_many_open_files

jfnfx:					; ...
		retn
JFNFree		endp


; =============== S U B	R O U T	I N E =======================================


SFNFree		proc near		; ...
		push	ax
		xor	bx, bx

sfnf5:					; ...
		push	bx
		call	SFFromSFN
		pop	bx
		jb	short sfnf95
		cmp	word ptr es:[di], 0 ; [ES:DI+SF_ENTRY.sf_Ref_Count]
		jz	short sfnf20
		cmp	word ptr es:[di], 0FFFFh ; [ES:DI+SF_ENTRY.sf_ref_count],
					; sf_busy
		jz	short sfnf10

sfnf7:					; ...
		inc	bx
		jmp	short sfnf5
; ---------------------------------------------------------------------------

sfnf10:					; ...
		mov	ax, ss:USER_ID
		cmp	es:[di+2Fh], ax	; [ES:DI+SF_ENTRY.sf_UID]
		jnz	short sfnf7
		mov	ax, ss:PROC_ID
		cmp	es:[di+31h], ax	; [ES:DI+SF_ENTRY.sf_PID]
		jnz	short sfnf7

sfnf20:					; ...
		mov	word ptr es:[di], 0FFFFh ; sf_busy
		mov	ax, ss:USER_ID
		mov	es:[di+2Fh], ax	; [ES:DI+SF_ENTRY.sf_UID]
		mov	ax, ss:PROC_ID
		mov	es:[di+31h], ax	; [ES:DI+SF_ENTRY.sf_PID]
		pop	ax
		clc
		retn
; ---------------------------------------------------------------------------

sfnf95:					; ...
		pop	ax
		mov	al, 4		; error_too_many_open_files
		retn
SFNFree		endp


; =============== S U B	R O U T	I N E =======================================


$CLOSE		proc near		; ...

; FUNCTION CHUNK AT 43E4 SIZE 0000001C BYTES

		call	CheckOwner
		jb	short CloseError
		push	ss
		pop	ds
		mov	word ptr ds:THISSFT, di
		mov	word ptr ds:THISSFT+2, es
		cmp	word ptr es:[di], 1 ; [ES:DI+SF_ENTRY.sf_ref_count]
		jz	short FreeJFN
		mov	al, es:[di+2]	; [ES:DI+SF_ENTRY.sf_mode]
		and	al, 0F0h	; SHARING_MASK
		cmp	al, 70h		; SHARING_NET_FCB
		jz	short PostFree

FreeJFN:				; ...
		call	pJFNFromHandle
		mov	byte ptr es:[di], 0FFh

PostFree:				; ...
		call	DOS_CLOSE
		jb	short CloseError
		mov	ah, 3Eh		; CLOSE

CloseOk:				; ...
		jmp	SYS_RETURN	; SYS_RET_OK
; ---------------------------------------------------------------------------

CloseError:				; ...
		jmp	SYS_RET_ERR
$CLOSE		endp

; ---------------------------------------------------------------------------

$COMMIT:				; ...
		call	CheckOwner
		jb	short CommitError
		push	ss
		pop	ds
		mov	word ptr ds:THISSFT, di
		mov	word ptr ds:THISSFT+2, es
		call	DOS_COMMIT
		jb	short CommitError
		mov	ah, 68h		; COMMIT
; START	OF FUNCTION CHUNK FOR $READ

CommitOk:				; ...
		jmp	short CloseOk
; ---------------------------------------------------------------------------

CommitError:				; ...
		jmp	short CloseError
; END OF FUNCTION CHUNK	FOR $READ
; ---------------------------------------------------------------------------

$ExtHandle:				; ...
		xor	bp, bp
		cmp	bx, 20		; FILPERPROC
		jnb	short exth2
		mov	bx, 20

exth2:					; ...
		mov	es, ss:CurrentPDB
		mov	cx, es:32h	; [ES:PDB.JFN_Length]
		cmp	bx, cx
		jz	short ok_done
		ja	short larger
		mov	bp, 1
		mov	ds, word ptr es:36h ; [ES:PDB.JFN_Pointer+2]
		mov	si, bx
		sub	cx, bx

chck_handles:				; ...
		cmp	byte ptr [si], 0FFh ; -1
		jnz	short too_many_files
		inc	si
		loop	chck_handles
		cmp	bx, 20		; FILPERPROC
		ja	short larger
		mov	bp, 2
		mov	di, 24		; PDB.JFN_TABLE
		push	bx
		jmp	short movhandl
; ---------------------------------------------------------------------------

larger:					; ...
		cmp	bx, 0FFFFh	; -1
		jz	short invalid_func
		clc
		push	bx
		add	bx, 0Fh
		mov	cl, 4
		rcr	bx, cl
		and	bx, 1FFFh
		push	bp
		call	$ALLOC
		pop	bp
		jb	short no_memory
		mov	es, ax
		xor	di, di

movhandl:				; ...
		mov	ds, ss:CurrentPDB
		test	bp, 3
		jz	short enlarge
		pop	cx
		push	cx
		jmp	short copy_hand
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR $READ

ok_done:				; ...
		jmp	short CommitOk
; END OF FUNCTION CHUNK	FOR $READ
; ---------------------------------------------------------------------------

too_many_files:				; ...
		mov	al, 4		; error_too_many_open_files
; START	OF FUNCTION CHUNK FOR $READ

CommitErrorj:				; ...
		jmp	short CommitError
; END OF FUNCTION CHUNK	FOR $READ
; ---------------------------------------------------------------------------

enlarge:				; ...
		mov	cx, ds:32h	; [PDB.JFN_Length]

copy_hand:				; ...
		mov	dx, cx
		lds	si, ds:34h	; [PDB.JFN_Pointer]
		rep movsb
		pop	cx
		push	cx
		sub	cx, dx
		mov	al, 0FFh	; -1
		rep stosb
		mov	ds, ss:CurrentPDB
		cmp	word ptr ds:34h, 0 ; [PDB.JFN_Pointer]
		jnz	short update_info
		push	bp
		push	ds
		push	es
		mov	es, word ptr ds:36h ; [PDB.JFN_Pointer+2]
		call	$DEALLOC
		pop	es
		pop	ds
		pop	bp

update_info:				; ...
		test	bp, 2
		jz	short non_psp
		mov	word ptr ds:34h, 18h ; [PDB.JFN_Pointer],PDB.JFN_TABLE
		jmp	short final
; ---------------------------------------------------------------------------

non_psp:				; ...
		mov	word ptr ds:34h, 0 ; [PDB.JFN_Pointer]

final:					; ...
		mov	word ptr ds:36h, es ; [PDB.JFN_Pointer+2]
		pop	word ptr ds:32h	; [PDB.JFN_Length]
; START	OF FUNCTION CHUNK FOR $READ

ok_done_j:				; ...
		jmp	short ok_done
; END OF FUNCTION CHUNK	FOR $READ
; ---------------------------------------------------------------------------

no_memory:				; ...
		pop	bx
		mov	al, 8		; error_not_enough_memory
; START	OF FUNCTION CHUNK FOR $READ

CommitErrorj2:				; ...
		jmp	short CommitErrorj
; END OF FUNCTION CHUNK	FOR $READ
; ---------------------------------------------------------------------------

invalid_func:				; ...
		mov	al, 1		; error_invalid_function
; START	OF FUNCTION CHUNK FOR $READ

CommitErrorj3:				; ...
		jmp	short CommitErrorj2
; END OF FUNCTION CHUNK	FOR $READ

; =============== S U B	R O U T	I N E =======================================


$READ		proc near		; ...

; FUNCTION CHUNK AT A714 SIZE 00000004 BYTES
; FUNCTION CHUNK AT A780 SIZE 00000002 BYTES
; FUNCTION CHUNK AT A784 SIZE 00000002 BYTES
; FUNCTION CHUNK AT A7CF SIZE 00000002 BYTES
; FUNCTION CHUNK AT A7D4 SIZE 00000002 BYTES
; FUNCTION CHUNK AT A7D8 SIZE 00000002 BYTES

		mov	si, offset DOS_READ

ReadDo:					; ...
		call	pJFNFromHandle
		jb	short ReadError
		mov	al, es:[di]
		call	CheckOwner
		jnb	short ReadSetup

ReadError:				; ...
		jmp	short CommitErrorj3
; ---------------------------------------------------------------------------

ReadSetup:				; ...
		mov	word ptr ss:THISSFT, di
		mov	word ptr ss:THISSFT+2, es
		test	byte ptr es:[di+3], 20h	; [ES:DI+SF_ENTRY.sf_mode+1],
					; (INT_24_ERROR>>8)
		jz	short needi24
		or	ss:EXTOPEN_ON, 2 ; EXT_OPEN_I24_OFF

needi24:				; ...
		push	word ptr ss:DMAADD
		push	word ptr ss:DMAADD+2
		call	Align_Buffer
		push	ss
		pop	ds
		call	si ; DOS_READ
		pop	word ptr ds:DMAADD+2
		pop	word ptr ds:DMAADD
		jnb	short READ_OK
		jmp	short ReadError
; ---------------------------------------------------------------------------

READ_OK:				; ...
		mov	ax, cx

Read_Okj:				; ...
		jmp	short ok_done_j
$READ		endp


; =============== S U B	R O U T	I N E =======================================


Align_Buffer	proc near		; ...
		mov	bx, dx
		push	cx
		mov	cl, 4
		shr	bx, cl
		pop	cx
		mov	ax, ds
		add	ax, bx
		mov	ds, ax
		and	dx, 0Fh
		mov	word ptr ss:DMAADD, dx
		mov	word ptr ss:DMAADD+2, ds
		retn
Align_Buffer	endp

; ---------------------------------------------------------------------------

$WRITE:					; ...
		mov	si, offset DOS_WRITE
		jmp	short ReadDo

; =============== S U B	R O U T	I N E =======================================


$LSEEK		proc near		; ...
		call	CheckOwner

LSeekError:				; ...
		jnb	short CHKOWN_OK
		jmp	short ReadError
; ---------------------------------------------------------------------------

CHKOWN_OK:				; ...
		cmp	al, 2
		jbe	short LSeekDisp
		mov	ss:EXTERR_LOCUS, 1 ; errLOC_Unk
		mov	al, 1		; error_invalid_function

LSeekError2:				; ...
		jmp	short ReadError
; ---------------------------------------------------------------------------

LSeekDisp:				; ...
		cmp	al, 1
		jb	short LSeekStore
		ja	short LSeekEOF
		add	dx, es:[di+21]	; [ES:DI+SF_ENTRY.sf_position]
		adc	cx, es:[di+23]	; [ES:DI+SF_ENTRY.sf_position+2]

LSeekStore:				; ...
		mov	ax, cx
		xchg	ax, dx

LSeekSetpos:				; ...
		mov	es:[di+21], ax
		mov	es:[di+23], dx
		call	Get_User_Stack
		mov	[si+6],	dx

LSeekOk:				; ...
		jmp	short Read_Okj
; ---------------------------------------------------------------------------

LSeekEOF:				; ...
		test	byte ptr es:[di+6], 80h	; [ES:DI+SF_ENTRY.sf_flags+1],
					; (sf_isnet>>8)
		jnz	short Check_LSeek_Mode

LOCAL_LSeek:				; ...
		add	dx, es:[di+17]	; [ES:DI+SF_ENTRY.sf_size]
		adc	cx, es:[di+19]	; [ES:DI+SF_ENTRY.sf_size+2]
		jmp	short LSeekStore
; ---------------------------------------------------------------------------

Check_LSeek_Mode:			; ...
		test	byte ptr es:[di+3], 80h	; [ES:DI+SF_ENTRY.sf_mode+1],
					; (sf_isFCB>>8)
		jnz	short LOCAL_LSeek
		mov	ax, es:[di+2]	; [ES:DI+SF_ENTRY.sf_mode]
		and	ax, 0F0h
		cmp	ax, 40h		; SHARING_MASK
		jz	short NET_LSEEK
		cmp	ax, 30h		; SHARING_DENY_READ
		jnz	short LOCAL_LSeek

NET_LSEEK:				; ...
		mov	ax, 1121h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - SEEK	FROM END OF REMOTE FILE
					; CX:DX	= offset (in bytes) from end
					; ES:DI	-> SFT,	SFT DPB	field -> DPB of	drive with file
					; SS = DOS CS
					; Return: CF set on error
					; CF clear if successful, DX:AX	= new file position
		jnb	short LSeekSetpos

LSeekError3:				; ...
		jmp	short LSeekError2
$LSEEK		endp

; ---------------------------------------------------------------------------

$FILE_TIMES:				; ...
		cmp	al, 2
		jnb	short inval_func
		call	CheckOwner
		jb	short LSeekError
		or	al, al
		jnz	short ft_set_time
		cli
		mov	cx, es:[di+13]	; [es:di+SF_ENTRY.sf_time]
		mov	dx, es:[di+15]	; [es:di+SF_ENTRY.sf_date]
		sti
		call	Get_User_Stack
		mov	[si+4],	cx
		mov	[si+6],	dx
		jmp	short ok_ret
; ---------------------------------------------------------------------------

ft_set_time:				; ...
		call	ECritDisk	; call ECritSFT
		mov	es:[di+13], cx	; [es:di+SF_ENTRY.sf_time]
		mov	es:[di+15], dx	; [es:di+SF_ENTRY.sf_date]
		xor	ax, ax
		call	dword ptr ss:ShSU ; call far [ss:JShare+(14*4)]	; 14 = ShSU
		and	word ptr es:[di+5], 0FFBFh ; ~devid_file_clean
		or	word ptr es:[di+5], 4000h ; sf_close_nodate
		call	LCritDisk	; call ECritSFT

ok_ret:					; ...
		jmp	short LSeekOk
; ---------------------------------------------------------------------------

inval_func:				; ...
		mov	ss:EXTERR_LOCUS, 1 ; errLOC_Unk
		mov	al, 1		; error_invalid_function

ft_error:				; ...
		jmp	short LSeekError3
; ---------------------------------------------------------------------------

$DUP:					; ...
		mov	ax, bx
		call	JFNFree

DupErrorCheck:				; ...
		jb	short DupErr
		push	es
		push	di
		pop	si
		pop	ds
		xchg	ax, bx
		call	CheckOwner
		jb	short DupErr
		call	DOS_Dup_Direct
		call	pJFNFromHandle
		mov	bl, es:[di]
		mov	[si], bl
		jmp	short ok_ret
; ---------------------------------------------------------------------------

DupErr:					; ...
		jmp	short ft_error
; ---------------------------------------------------------------------------

$DUP2:					; ...
		push	bx
		push	cx
		mov	bx, cx
		call	$CLOSE
		pop	bx
		pop	ax
		call	pJFNFromHandle
		jmp	short DupErrorCheck

; =============== S U B	R O U T	I N E =======================================


CheckOwner	proc near		; ...
		call	SFFromHandle
		jb	short co_ret_label
		push	ax
		test	ss:IsWin386, 1
		jz	short no_win386
		xor	ax, ax
		jmp	short _skip_win386
; ---------------------------------------------------------------------------

no_win386:				; ...
		mov	ax, ss:USER_ID
		cmp	ax, es:[di+2Fh]	; [es:di+SF_ENTRY.sf_UID]

_skip_win386:				; ...
		pop	ax
		jnz	short CheckOwner_err
		retn
; ---------------------------------------------------------------------------

CheckOwner_err:				; ...
		mov	al, 6
		stc

co_ret_label:				; ...
		retn
CheckOwner	endp

; ---------------------------------------------------------------------------

$AssignOper:				; ...
		cmp	al, 7
		jnz	short chk08

srinuse:				; ...
		push	ax
		mov	al, dl
		call	GetCDSFromDrv
		pop	ax
		jb	short baddrv
		cmp	word ptr [si+45h], 0 ; [SI+curdir.devptr]
		jz	short baddrv
		cmp	al, 7
		jnz	short resetdrv
		or	word ptr [si+43h], 4000h ; [SI+curdir.flags],
					; curdir_inuse
		jmp	short okdone
; ---------------------------------------------------------------------------

resetdrv:				; ...
		and	word ptr [si+43h], 0BFFFh ; ~curdir_inuse
		jmp	short okdone
; ---------------------------------------------------------------------------

baddrv:					; ...
		mov	ax, 0Fh		; error_invalid_drive
		jmp	short ASS_ERR
; ---------------------------------------------------------------------------

chk08:					; ...
		cmp	al, 8
		jz	short srinuse
		push	ax
		mov	ax, 111Eh	; (MultNET SHL 8) OR 30
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - DO REDIRECTION
					; SS = DOS CS
					; STACK: WORD function to execute
					; Return: CF set on error, AX =	error code
					; STACK	unchanged
		pop	bx
		jb	short ASS_ERR

okdone:					; ...
		jmp	SYS_RETURN	; SYS_RET_OK
; ---------------------------------------------------------------------------

ASS_ERR:				; ...
		jmp	SYS_RET_ERR

; =============== S U B	R O U T	I N E =======================================


FIND_DPB	proc near		; ...
		lds	si, ss:SYSINITVARS ; [SS:DPBHEAD]

fdpb5:					; ...
		cmp	si, 0FFFFh	; -1
		jz	short fdpb10
		cmp	al, [si]	; [SI+DPB.DRIVE]
		jz	short ret_label15
		lds	si, [si+19h]	; [SI+DPB.NEXT_DPB]
		jmp	short fdpb5
; ---------------------------------------------------------------------------

fdpb10:					; ...
		stc

ret_label15:				; ...
		retn
FIND_DPB	endp


; =============== S U B	R O U T	I N E =======================================


InitCDS		proc near		; ...
		push	ax
		les	di, ss:THISCDS
		mov	word ptr es:[di+43h], 0	; [ES:DI+curdir.flags]
		sub	al, 40h	; '@'   ; 'A'-1
		cmp	ss:NUMIO, al
		jb	short icdsx
		dec	ax
		push	ax
		add	al, 41h	; 'A'
		mov	ah, 3Ah	; ':'
		mov	es:[di], ax	; [ES:DI+curdir.text]
		mov	word ptr es:[di+2], 5Ch	; '\' ; [ES:DI+curdir.text+2]
		or	byte ptr es:[di+44h], 40h ; [ES:DI+curdir.flags+1],
					; (curdir_inuse>>8)
		sub	ax, ax
		mov	es:[di+49h], ax	; [ES:DI+curdir.ID]
		mov	es:[di+4Bh], ax	; [ES:DI+curdir.ID+2]
		mov	al, 2
		mov	es:[di+4Fh], ax	; [ES:DI+curdir.end]
		pop	ax
		push	ds
		push	si
		call	FIND_DPB
		jb	short icds5
		mov	es:[di+45h], si	; [ES:DI+curdir.devptr]
		mov	word ptr es:[di+47h], ds ; [ES:DI+curdir.devptr+2]

icds5:					; ...
		pop	si
		pop	ds

icdsx:					; ...
		pop	ax

RET45:					; ...
		retn
InitCDS		endp

; ---------------------------------------------------------------------------

$UserOper:				; ...
		push	ax
		sub	al, 1
		pop	ax
		jb	short UserGet
		jz	short UserSet
		cmp	al, 5
		jbe	short UserPrint
		mov	ss:EXTERR_LOCUS, 1 ; errLOC_Unk
		mov	al, 1		; error_invalid_function

useroper_error:				; ...
		jmp	short ASS_ERR
; ---------------------------------------------------------------------------

UserGet:				; ...
		push	ds
		pop	es
		mov	di, dx
		mov	cx, ss:MYNUM
		call	Get_User_Stack
		mov	[si+4],	cx	; [SI+user_env.user_CX]
		push	ss
		pop	ds
		mov	si, offset MYNAME

UserMove:				; ...
		mov	cx, 15
		rep movsb
		xor	ax, ax
		stosb

UserBye:				; ...
		jmp	SYS_RETURN	; SYS_RET_OK
; ---------------------------------------------------------------------------

UserSet:				; ...
		mov	ss:MYNUM, cx
		mov	si, dx
		push	ss
		pop	es
		mov	di, offset MYNAME
		inc	ss:DIFFNAM
		jmp	short UserMove
; ---------------------------------------------------------------------------

UserPrint:				; ...
		push	ax
		mov	ax, 111Fh	; (MultNET SHL 8) OR 31
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - PRINTER SETUP
					; STACK: WORD function
					; Return: CF set on error, AX =	error code
					; STACK	unchanged
		pop	dx
		jnb	short OKPA
		jmp	short useroper_error
; ---------------------------------------------------------------------------

OKPA:					; ...
		jmp	short UserBye

; =============== S U B	R O U T	I N E =======================================


GetVisDrv	proc near		; ...
		call	GETTHISDRV
		jb	short RET45
		push	ds
		push	si
		lds	si, ss:THISCDS
		test	word ptr [si+43h], 2000h ; [SI+curdir.flags],
					; curdir_splice
		pop	si
		pop	ds
		jz	short RET45
		mov	ss:DrvErr, 0Fh	; error_invalid_drive
		stc
		retn
GetVisDrv	endp


; =============== S U B	R O U T	I N E =======================================


GETTHISDRV	proc near		; ...
		or	al, al
		jnz	short GTD10
		mov	al, ss:CURDRV
		inc	ax

GTD10:					; ...
		dec	ax
		push	ds
		push	si
		mov	ss:EXTERR_LOCUS, 2 ; errLOC_Disk
		test	ss:FSHARING, 0FFh ; -1
		jz	short GTD20
		push	ax
		push	es
		push	di
		mov	word ptr ss:THISCDS, offset DUMMYCDS
		mov	word ptr ss:THISCDS+2, ss
		add	al, 41h	; 'A'
		call	InitCDS
		test	word ptr es:[di+43h], 4000h ; [ES:DI+curdir.flags],
					; curdir_inuse
		pop	di
		pop	es
		pop	ax
		jz	short GTD30
		jmp	short GTDX
; ---------------------------------------------------------------------------

GTD20:					; ...
		call	GetCDSFromDrv
		jb	short GTD30
		test	word ptr [si+43h], 4000h ; [SI+curdir.flags],
					; curdir_inuse
		jnz	short GTDX

GTD30:					; ...
		mov	al, 0Fh		; error_invalid_drive
		mov	ss:DrvErr, al
		mov	ss:EXTERR_LOCUS, 1 ; errLOC_Unk
		stc

GTDX:					; ...
		pop	si
		pop	ds
		retn
GETTHISDRV	endp


; =============== S U B	R O U T	I N E =======================================


GetCDSFromDrv	proc near		; ...
		cmp	al, ss:CDSCOUNT
		jb	short GetCDS
		stc
		retn
; ---------------------------------------------------------------------------

GetCDS:					; ...
		push	bx
		push	ax
		lds	si, ss:CDSADDR
		mov	bl, 88		; curdir.size
		mul	bl
		add	si, ax
		mov	word ptr ss:THISCDS, si
		mov	word ptr ss:THISCDS+2, ds
		pop	ax
		pop	bx
		clc
		retn
GetCDSFromDrv	endp

; ---------------------------------------------------------------------------

TransFCB:				; ...
		push	bp
		mov	bp, sp
		sub	sp, 16
		push	ss
		pop	es
		push	es
		push	di
		lea	di, [bp-16]	; FCBTmp
		mov	ss:EXTFCB, 0
		mov	ss:SATTRIB, 0
		call	GetExtended
		jz	short GetDrive
		mov	al, [si-1]
		mov	ss:SATTRIB, al
		mov	ss:EXTFCB, 0FFh	; -1

GetDrive:				; ...
		lodsb
		call	GETTHISDRV
		jb	short BadPack
		call	TextFromDrive
		mov	cx, 11
		push	si

FCBScan:				; ...
		lodsb
		call	GetCharType
		test	al, 8		; FFCB
		jz	short BadPack
		loop	FCBScan
		pop	si
		mov	bx, di
		call	PackName
		pop	di
		pop	es
		push	ss
		pop	ds
		lea	si, [bp-16]	; FCBTmp
		cmp	byte ptr [bx], 0
		jz	short BadPack
		push	bp
		call	TransPathSet
		pop	bp
		jnb	short FCBRet

BadPack:				; ...
		stc
		mov	al, 3		; error_path_not_found

FCBRet:					; ...
		mov	sp, bp
		pop	bp

TransPath_retn:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================


TransPath	proc near		; ...
		xor	al, al
		jmp	short SetSplice
; ---------------------------------------------------------------------------

TransPathSet:				; ...
		mov	al, 0FFh	; -1

SetSplice:				; ...
		mov	ss:NoSetDir, al
		mov	al, 0FFh	; -1

TransPathNoSet:				; ...
		mov	ss:FSPLICE, al
		mov	ss:CMETA, 0FFh	; -1
		mov	ss:WFP_START, di
		mov	ss:CURR_DIR_END, 0FFFFh	; -1
		push	ss
		pop	es
		lea	bp, [di+134]	; [DI+TEMPLEN]
		test	ss:FSHARING, 0FFh ; -1
		jz	short CheckUNC
		call	DriveFromText
		call	GETTHISDRV
		jb	short NoPath
		call	TextFromDrive
		lea	bx, [di+1]
		call	Canonicalize
		jb	short TransPath_retn
		push	ss
		pop	ds
		mov	si, ds:WFP_START
		test	ds:FSPLICE, 0FFh ; -1
		jz	short NoServerSplice
		call	Splice

NoServerSplice:				; ...
		push	ss
		pop	ds
		les	di, ds:THISCDS
		call	ECritDisk
		call	FATREAD_CDS
		call	LCritDisk

NoPath:					; ...
		mov	al, 3		; error_path_not_found
		retn
; ---------------------------------------------------------------------------

CheckUNC:				; ...
		mov	word ptr ss:THISCDS, 0FFFFh
		mov	ax, 1123h
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - QUALIFY REMOTE FILENAME
					; DS:SI	-> ASCIZ filename to canonicalize
					; ES:DI	-> 128-byte buffer for qualified name
					; Return: CF set if not	resolved
		jnb	short UNCDone
		call	DriveFromText
		push	ax
		mov	ax, [si]
		call	PATHCHRCMP
		xchg	ah, al
		call	PATHCHRCMP
		jnz	short CheckDevice
		cmp	ah, al
		jnz	short CheckDevice
		pop	ax
		movsw

UNCCpy:					; ...
		lodsb
		call	UCase
		or	al, al
		jz	short UNCTerm
		call	PATHCHRCMP
		mov	bx, di
		stosb
		jnz	short UNCCpy
		call	Canonicalize

UNCDone:				; ...
		push	ss
		pop	ds
		retn
; ---------------------------------------------------------------------------

UNCTerm:				; ...
		stosb
		jmp	short UNCDone
; ---------------------------------------------------------------------------

CheckDevice:				; ...
		pop	ax
		cmp	byte ptr [si], 0
		jnz	short CheckPath
		mov	al, 2		; error_file_not_found
		stc
		retn
; ---------------------------------------------------------------------------

CheckPath:				; ...
		push	ax
		push	bp
		call	CheckThisDevice
		pop	bp
		pop	ax
		jnb	short DoFile
		mov	ss:FSHARING, 0FFh ; -1
		call	GETTHISDRV
		mov	ss:FSHARING, 0
		call	TextFromDrive
		mov	al, '/'
		stosb
		call	StrCpy
		clc
		push	ss
		pop	ds

DoFile_retn:				; ...
		retn
; ---------------------------------------------------------------------------

DoFile:					; ...
		call	GetVisDrv
		mov	al, 3		; error_path_not_found
		jb	short DoFile_retn
		push	ds
		push	si
		push	es
		push	di
		call	ValidateCDS
		pop	di
		pop	es
		pop	si
		pop	ds
		mov	al, 3
		jb	short DoFile_retn
		push	ds
		push	si
		lds	si, ss:THISCDS
		mov	bx, di
		add	bx, [si+79]	; [SI+curdir.end]
		lea	bp, [di+134]	; [DI+TEMPLEN]
		call	FStrCpy
		dec	di
		mov	al, '\'
		cmp	es:[di-1], al
		jz	short GetOrig
		stosb

GetOrig:				; ...
		dec	di
		pop	si
		pop	ds
		call	PathSep
		jnz	short PathAssure
		or	al, al
		jz	short DoCanon
		mov	di, bx

SkipPath:				; ...
		lodsb
		call	PATHCHRCMP
		jz	short SkipPath
		dec	si
		or	al, al
		jz	short DoCanon

PathAssure:				; ...
		mov	al, 5Ch	; '\'
		stosb

DoCanon:				; ...
		call	Canonicalize
		jb	short DoFile_retn
		push	ss
		pop	ds
		mov	di, ds:WFP_START
		lds	si, ds:THISCDS
		call	PathPref
		jnz	short DoSplice
		mov	al, [si-1]
		call	PATHCHRCMP
		jz	short DoSplice
		cmp	byte ptr es:[di], 0
		jz	short DoSplice
		inc	di
		mov	ss:CURR_DIR_END, di

DoSplice:				; ...
		push	ss
		pop	ds
		mov	si, ds:WFP_START
		xor	cx, cx
		test	ds:FSPLICE, 0FFh ; -1
		jz	short SkipSplice
		call	Splice

SkipSplice:				; ...
		push	ss
		pop	ds
		les	di, ds:THISCDS
		test	word ptr es:[di+67], 8000h ; [ES:DI+curdir.flags],
					; curdir_isnet
		jnz	short Done
		jcxz	short Done
		call	ECritDisk
		call	FATREAD_CDS
		call	LCritDisk
		mov	al, 3		; error_path_not_found

Done:					; ...
		retn
TransPath	endp


; =============== S U B	R O U T	I N E =======================================


Canonicalize	proc near		; ...
		lodsb
		call	PATHCHRCMP
		jnz	short CanonDec
		cmp	di, bp
		jnb	short CanonBad
		stosb
		jmp	short Canonicalize
; ---------------------------------------------------------------------------

CanonDec:				; ...
		dec	si

CanonLoop:				; ...
		xor	ax, ax
		cmp	[si], al
		jnz	short DoComponent
		cmp	byte ptr es:[di-1], ':'
		jnz	short DoTerminate
		mov	al, '\'
		stosb
		mov	al, ah

DoTerminate:				; ...
		stosb
		clc
		retn
; ---------------------------------------------------------------------------

CanonBad:				; ...
		call	ScanPathChar
		mov	al, 3		; error_path_not_found
		jz	short PathEnc
		mov	al, 2		; error_file_not_found

PathEnc:				; ...
		stc

CanonBad_retn:				; ...
		retn
; ---------------------------------------------------------------------------

DoComponent:				; ...
		call	CopyComponent
		jb	short CanonBad_retn
		cmp	word ptr es:[di], 2Eh ;	'.'
		jz	short Skip1
		cmp	word ptr es:[di], 2E2Eh
		jnz	short CanonNormal
		dec	di

Skip1:					; ...
		call	SkipBack
		mov	al, 3		; error_path_not_found
		jb	short CanonBad_retn
		jmp	short CanonPath
; ---------------------------------------------------------------------------

CanonNormal:				; ...
		add	di, cx

CanonPath:				; ...
		call	PathSep
		jnz	short CanonBad
		lodsb
		call	PATHCHRCMP
		jnz	short CanonDec
		cmp	di, bp
		jnb	short CanonBad
		stosb

CanonPathLoop:				; ...
		lodsb
		call	PATHCHRCMP
		jz	short CanonPathLoop
		dec	si
		jmp	short CanonLoop
Canonicalize	endp


; =============== S U B	R O U T	I N E =======================================


PathSep		proc near		; ...
		mov	al, [si]

PathSepGotCh:				; ...
		or	al, al
		jz	short CanonBad_retn
		call	PATHCHRCMP
		retn
PathSep		endp


; =============== S U B	R O U T	I N E =======================================


SkipBack	proc near		; ...
		cmp	di, bx
		jb	short SkipBad
		dec	di
		mov	al, es:[di]
		call	PATHCHRCMP
		jnz	short SkipBack
		clc
		retn
; ---------------------------------------------------------------------------

SkipBad:				; ...
		mov	al, 3		; error_path_not_found
		stc
		retn
SkipBack	endp


; =============== S U B	R O U T	I N E =======================================


CopyComponent	proc near		; ...
		sub	sp, 14
		push	ds
		push	si
		push	es
		push	di
		push	bp
		mov	bp, sp
		mov	ah, '.'
		lodsb
		stosb
		cmp	al, ah
		jnz	short NormalComp
		call	PathSep
		jz	short NulTerm

TryTwoDot:
		lodsb
		stosb
		cmp	al, ah
		jnz	short CopyBad
		call	PathSep
		jnz	short CopyBad

NulTerm:				; ...
		xor	al, al
		stosb
		mov	[bp+6],	si	; CopySoff
		jmp	short _GoodRet
; ---------------------------------------------------------------------------

NormalComp:				; ...
		mov	si, [bp+6]	; CopySoff
		call	NameTrans
		cmp	si, [bp+6]
		jz	short CopyBad
		test	ss:FSHARING, 0FFh ; -1
		jnz	short DoPack
		and	dl, 1
		add	ss:CMETA, dl
		jg	short CopyBad
		jnz	short DoPack
		or	dl, dl
		jz	short CopyBadPath

DoPack:					; ...
		mov	[bp+6],	si
		push	ss
		pop	ds
		mov	si, offset NAME1
		lea	di, [bp+10]	; CopyTemp
		push	di
		call	PackName
		pop	di
		call	StrLen
		dec	cx
		add	cx, [bp+2]	; CopyDoff
		cmp	cx, [bp+0]	; CopyBP
		jnb	short CopyBad
		mov	si, di
		les	di, [bp+2]	; CopyD
		call	FStrCpy

_GoodRet:				; ...
		clc
		jmp	short CopyEnd
; ---------------------------------------------------------------------------

CopyBad:				; ...
		stc
		call	ScanPathChar
		mov	al, 2		; error_file_not_found
		jnz	short CopyEnd

CopyBadPath:				; ...
		stc
		mov	al, 3		; error_path_not_found

CopyEnd:				; ...
		pop	bp
		pop	di
		pop	es
		pop	si
		pop	ds
		lahf
		add	sp, 14
		call	StrLen
		dec	cx
		sahf
		retn
CopyComponent	endp


; =============== S U B	R O U T	I N E =======================================


Splice		proc near		; ...
		test	ss:SPLICES, 0FFh ; -1
		jz	short AllDone
		push	word ptr ss:THISCDS
		push	word ptr ss:THISCDS+2
		push	ds
		push	si
		pop	di
		pop	es
		xor	ax, ax

SpliceScan:				; ...
		call	GetCDSFromDrv
		jb	short SpliceDone
		inc	al
		test	word ptr [si+67], 2000h	; [SI+curdir.flags],
					; curdir_splice
		jz	short SpliceScan
		push	di
		call	PathPref
		jz	short SpliceFound

SpliceSkip:				; ...
		pop	di
		jmp	short SpliceScan
; ---------------------------------------------------------------------------

SpliceFound:				; ...
		cmp	byte ptr es:[di], 0
		jnz	short SpliceDo
		test	ss:NoSetDir, 0FFh ; -1
		jnz	short SpliceSkip

SpliceDo:				; ...
		mov	si, di
		push	es
		pop	ds
		pop	di
		call	TextFromDrive1
		mov	ax, ss:CURR_DIR_END
		or	ax, ax
		js	short NoPoke
		add	ax, di
		sub	ax, si
		mov	ss:CURR_DIR_END, ax

NoPoke:					; ...
		cmp	byte ptr [si], 0
		jnz	short SpliceCopy
		mov	al, '\'
		stosb

SpliceCopy:				; ...
		call	FStrCpy
		add	sp, 4
		or	cl, 1
		jmp	short DoSet
; ---------------------------------------------------------------------------

SpliceDone:				; ...
		pop	word ptr ss:THISCDS+2
		pop	word ptr ss:THISCDS

AllDone:				; ...
		xor	cx, cx

DoSet:					; ...
		lds	si, ss:THISCDS
		les	di, [si+69]	; [SI+curdir.devptr]
		mov	word ptr ss:THISDPB, di
		mov	word ptr ss:THISDPB+2, es

Splice_retn:				; ...
		retn
Splice		endp

; ---------------------------------------------------------------------------

$NameTrans:				; ...
		push	ds
		push	si
		push	es
		push	di
		push	cx
		mov	ch, 16h		; attr_hidden+attr_system+attr_directory
		call	SetAttrib
		mov	di, offset OPENBUF
		call	TransPath
		pop	cx
		pop	di
		pop	es
		pop	si
		pop	ds
		jnb	short TransOK
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

TransOK:				; ...
		mov	si, offset OPENBUF
		push	ss
		pop	ds
		call	FStrCpy
		jmp	SYS_RETURN	; SYS_RET_OK

; =============== S U B	R O U T	I N E =======================================


DriveFromText	proc near		; ...
		xor	al, al
		cmp	byte ptr [si], 0
		jz	short Splice_retn
		cmp	byte ptr [si+1], ':'
		jnz	short Splice_retn
		lodsw
		or	al, 20h
		sub	al, 60h		; 'a'-1
		jnz	short Splice_retn
		mov	al, 0FFh	; -1
		retn
DriveFromText	endp


; =============== S U B	R O U T	I N E =======================================


TextFromDrive	proc near		; ...
		inc	al

TextFromDrive1:				; ...
		add	al, 40h		; 'A'-1
		mov	ah, ':'         ; 3Ah
		stosw

PathPref_retn:				; ...
		retn
TextFromDrive	endp


; =============== S U B	R O U T	I N E =======================================


PathPref	proc near		; ...
		call	DStrLen
		dec	cx
		repe cmpsb
		jnz	short PathPref_retn
		push	ax
		mov	al, [si-1]
		call	PATHCHRCMP
		jz	short Prefix
		mov	al, es:[di]
		call	PathSepGotCh

Prefix:					; ...
		pop	ax
		retn
PathPref	endp


; =============== S U B	R O U T	I N E =======================================


ScanPathChar	proc near		; ...
		lodsb
		call	PathSepGotCh
		jnz	short ScanPathChar
		call	PATHCHRCMP
		retn
ScanPathChar	endp


; =============== S U B	R O U T	I N E =======================================


$OPEN		proc near		; ...
		xor	ah, ah

_$Open2:				; ...
		mov	ch, 16h		; attr_hidden+attr_system+attr_directory
		call	SetAttrib
		mov	cx, offset DOS_OPEN
		push	ax

AccessFile:				; ...
		call	ECritDisk	; call ECritSFT
		call	SFNFree
		call	LCritDisk	; call LCritSFT
		jb	short OpenFailJ
		mov	ss:SFN,	bx
		mov	word ptr ss:THISSFT, di
		mov	word ptr ss:THISSFT+2, es
		call	JFNFree
		jnb	short SaveJFN

OpenFailJ:				; ...
		jmp	OpenFail
; ---------------------------------------------------------------------------

SaveJFN:				; ...
		mov	word ptr ss:PJFN, di
		mov	word ptr ss:PJFN+2, es
		mov	ss:JFN,	bx
		mov	bx, ss:SFN
		mov	es:[di], bl
		mov	si, dx
		mov	di, offset OPENBUF
		push	cx
		call	TransPath
		pop	bx
		lds	si, ss:THISSFT
		jb	short OpenCleanJ
		cmp	ss:CMETA, 0FFh	; -1
		jz	short SetSearch
		mov	al, 2

OpenCleanJ:				; ...
		jmp	short OpenClean
; ---------------------------------------------------------------------------

SetSearch:				; ...
		pop	ax
		xor	cx, cx
		mov	[si+2],	cx	; [SI+SF_ENTRY.sf_mode]
		mov	[si+33h], cx	; [SI+SF_ENTRY.sf_MFT]
		cmp	bx, offset DOS_OPEN
		jnz	short _DoOper
		test	al, 80h
		jz	short _DoOper
		and	al, 7Fh
		mov	cx, 1000h	; sf_no_inherit

_DoOper:				; ...
		push	di
		push	es
		push	ds
		pop	es
		push	si
		pop	di
		call	Set_EXT_mode
		pop	es
		pop	di
		push	ss
		pop	ds
		push	cx
		call	bx
		pop	cx
		lds	si, ds:THISSFT
		jb	short OpenE2
		mov	word ptr [si], 1
		or	[si+5],	cx	; [SI+SF_ENTRY.sf_flags]
		mov	ax, ss:JFN
		call	ss:ShCol	; Call far [ss:JShare+(12*4)] ;	12 = ShCol
		mov	ss:SFN,	0FFFFh	; -1

OpenOkj:				; ...
		jmp	SYS_RETURN	; SYS_RET_OK
; ---------------------------------------------------------------------------

OpenE2:					; ...
		cmp	ax, 57h		; error_invalid_parameter
		jnz	short OpenE
		jmp	short OpenCritLeave
; ---------------------------------------------------------------------------

OpenClean:				; ...
		pop	bx

OpenE:					; ...
		mov	word ptr [si], 0
		lds	si, ss:PJFN
		mov	byte ptr [si], 0FFh ; -1
		jmp	short OpenCritLeave
; ---------------------------------------------------------------------------

OpenFail:				; ...
		sti
		pop	cx

OpenCritLeave:				; ...
		mov	ss:SFN,	0FFFFh	; -1
		cmp	ss:EXTERR, 25h	; error_Code_Page_Mismatched
		jnz	short NORERR
		jmp	From_GetSet
; ---------------------------------------------------------------------------

NORERR:					; ...
		jmp	SYS_RET_ERR
$OPEN		endp

; ---------------------------------------------------------------------------

$CREAT:					; ...
		push	cx
		mov	cx, offset DOS_CREATE
; START	OF FUNCTION CHUNK FOR $CreateNewFile

AccessSet:				; ...
		mov	ss:SATTRIB, 6	; attr_hidden+attr_system
		jmp	AccessFile
; END OF FUNCTION CHUNK	FOR $CreateNewFile
; ---------------------------------------------------------------------------

$CHMOD:					; ...
		mov	di, offset OPENBUF
		push	ax
		push	cx
		mov	si, dx
		call	TransPathSet
		pop	cx
		pop	ax
		jb	short ChModErr
		push	ss
		pop	ds
		cmp	ds:CMETA, 0FFh	; -1
		jnz	short ChModErr
		mov	ds:SATTRIB, 16h	; attr_hidden+attr_system+attr_directory
		sub	al, 1
		jb	short ChModGet
		jz	short ChModSet
		mov	ds:EXTERR_LOCUS, 1 ; errLOC_Unk
		mov	al, 1		; error_invalid_function
; START	OF FUNCTION CHUNK FOR $UNLINK

chmod_errj:				; ...
		jmp	short NORERR
; END OF FUNCTION CHUNK	FOR $UNLINK
; ---------------------------------------------------------------------------

ChModGet:				; ...
		call	GET_FILE_INFO
		jb	short ChModE
		call	Get_User_Stack
		mov	[si+4],	ax	; [SI+user_env.user_CX]
; START	OF FUNCTION CHUNK FOR $UNLINK

OpenOkj2:				; ...
		jmp	short OpenOkj
; END OF FUNCTION CHUNK	FOR $UNLINK
; ---------------------------------------------------------------------------

ChModSet:				; ...
		mov	ax, cx
		call	SET_FILE_ATTRIBUTE
		jb	short ChModE
; START	OF FUNCTION CHUNK FOR $UNLINK

OpenOkj3:				; ...
		jmp	short OpenOkj2
; ---------------------------------------------------------------------------

ChModErr:				; ...
		mov	al, 3

ChModE:					; ...
		jmp	short chmod_errj
; END OF FUNCTION CHUNK	FOR $UNLINK

; =============== S U B	R O U T	I N E =======================================


$UNLINK		proc near		; ...

; FUNCTION CHUNK AT AFBA SIZE 00000002 BYTES
; FUNCTION CHUNK AT AFC7 SIZE 00000002 BYTES
; FUNCTION CHUNK AT AFD0 SIZE 00000006 BYTES

		push	cx
		mov	si, dx
		mov	di, offset OPENBUF
		call	TransPathSet
		pop	cx
		jb	short ChModErr
		cmp	ss:CMETA, 0FFh	; -1
		jnz	short NotFound
		push	ss
		pop	ds
		mov	ch, 6		; attr_hidden+attr_system
		call	SetAttrib
		call	DOS_DELETE
		jb	short UnlinkE

UnlinkOk:				; ...
		jmp	short OpenOkj3
; ---------------------------------------------------------------------------

NotFound:				; ...
		mov	al, 3

UnlinkE:				; ...
		jmp	short ChModE
$UNLINK		endp

; ---------------------------------------------------------------------------

$RENAME:				; ...
		push	cx
		push	ds
		push	dx
		push	es
		pop	ds
		mov	si, di
		mov	di, offset RENBUF
		call	TransPathSet
		push	ss:WFP_START
		pop	ss:REN_WFP
		pop	si
		pop	ds
		pop	cx

epjc2:					; ...
		jb	short ChModErr
		cmp	ss:CMETA, 0FFh	; -1
		jnz	short NotFound
		push	cx
		mov	di, offset OPENBUF
		call	TransPathSet
		pop	cx
		jb	short epjc2
		push	ss
		pop	ds
		cmp	ds:CMETA, 0FFh
		jb	short NotFound
		push	word ptr ds:THISCDS
		push	word ptr ds:THISCDS+2
		mov	di, offset OPENBUF
		push	ss
		pop	es
		xor	al, al

rnloop:					; ...
		call	GetCDSFromDrv
		jb	short dorn
		call	StrCmp
		jz	short rnerr
		inc	al
		jmp	short rnloop
; ---------------------------------------------------------------------------

rnerr:					; ...
		add	sp, 4
		mov	al, 10h		; error_current_directory
		jmp	short UnlinkE
; ---------------------------------------------------------------------------

dorn:					; ...
		pop	word ptr ss:THISCDS+2
		pop	word ptr ss:THISCDS
		push	ss
		pop	ds
		mov	ch, 16h		; attr_directory+attr_hidden+attr_system
		call	SetAttrib
		call	DOS_RENAME
		jb	short UnlinkE
		jmp	short UnlinkOk

; =============== S U B	R O U T	I N E =======================================


$CreateNewFile	proc near		; ...

; FUNCTION CHUNK AT AF88 SIZE 00000009 BYTES

		push	cx
		mov	cx, offset DOS_Create_New
		jmp	AccessSet
$CreateNewFile	endp


; =============== S U B	R O U T	I N E =======================================


BinToAscii	proc near		; ...
		mov	cx, 404h

bta5:					; ...
		rol	ax, cl
		push	ax
		and	al, 0Fh
		add	al, 'A'
		stosb
		pop	ax
		dec	ch
		jnz	short bta5
		retn
BinToAscii	endp

; ---------------------------------------------------------------------------

$CreateTempFile:			; ...
		push	bp
		mov	bp, sp
		sub	sp, 10
		test	cx, 0FFD8h	; ~attr_changeable
		jz	short OKatts
		mov	ax, 5		; error_access_denied
		jmp	short SETTMPERR
; ---------------------------------------------------------------------------

OKatts:					; ...
		mov	[bp-10], cx	; attr
		mov	[bp-8],	dx	; FilPtrL
		mov	word ptr [bp-6], ds ; FilPtrH
		mov	word ptr [bp-2], ds ; EndPtrH
		push	ds
		pop	es
		mov	di, dx
		mov	cx, di
		neg	cx
		or	cx, cx
		jnz	short okok
		mov	cx, 0FFFFh

okok:					; ...
		xor	ax, ax
		repne scasb
		dec	di
		mov	al, es:[di-1]
		call	PATHCHRCMP
		jz	short SETENDPTR

STOREPTH:
		mov	al, '\'
		stosb

SETENDPTR:				; ...
		mov	[bp-4],	di	; EndPtrL

CreateLoop:				; ...
		push	ss
		pop	ds
		push	bp
		call	READTIME
		pop	bp
		les	di, [bp-4]	; EndPtr
		mov	ax, cx
		call	BinToAscii
		mov	ax, dx
		call	BinToAscii
		xor	al, al
		stosb
		lds	dx, [bp-8]	; FilPtr
		mov	cx, [bp-10]	; Attr
		push	bp
		call	$CreateNewFile
		pop	bp
		jnb	short CreateDone
		cmp	al, 50h		; error_file_exists
		jz	short CreateLoop
		cmp	al, 5		; error_access_denied
		jnz	short SETTMPERR
		cmp	ss:EXTERR, 41h	; error_net_access_denied
		jz	short SETTMPERR
		cmp	ss:EXTERR, 53h	; error_FAIL_I24
		jz	short SETTMPERR
		jmp	short CreateLoop
; ---------------------------------------------------------------------------

SETTMPERR:				; ...
		stc

CreateDone:				; ...
		mov	sp, bp
		pop	bp
		jb	short CreateFail
		jmp	SYS_RETURN	; SYS_RET_OK
; ---------------------------------------------------------------------------

CreateFail:				; ...
		jmp	SYS_RET_ERR

; =============== S U B	R O U T	I N E =======================================


SetAttrib	proc near		; ...
		test	ss:FSHARING, 0FFh ; -1
		jnz	short Set
		mov	cl, ch

Set:					; ...
		mov	ss:SATTRIB, cl
		retn
SetAttrib	endp

; ---------------------------------------------------------------------------

$Extended_Open:				; ...
		mov	ss:EXTOPEN_FLAG, dx
		mov	ss:EXTOPEN_IO_MODE, 0
		test	dx, 0FE00h	; RESERVED_BITS_MASK
		jnz	short ext_inval2
		mov	ah, dl
		cmp	dl, 0
		jz	short ext_inval2
		and	dl, 0Fh
		cmp	dl, 2
		ja	short ext_inval2
		and	ah, 0F0h	; NOT_EXISTS_MASK
		cmp	ah, 10h
		ja	short ext_inval2
		mov	ss:SAVE_ES, es
		mov	ss:SAVE_DI, di
		push	ss:EXTOPEN_FLAG
		pop	ss:SAVE_DX
		mov	ss:SAVE_CX, cx
		mov	ss:SAVE_BX, bx
		mov	ss:SAVE_DS, ds
		mov	ss:SAVE_SI, si
		mov	dx, si
		mov	ax, bx
		jmp	short goopen2
; ---------------------------------------------------------------------------

ext_inval2:				; ...
		mov	al, 1		; error_invalid_function

eo_err:					; ...
		jmp	short CreateFail
; ---------------------------------------------------------------------------
		pop	cx
		pop	si
		mov	al, 13		; error_invalid_data
		jmp	short eo_err
; ---------------------------------------------------------------------------

error_return:				; ...
		retn
; ---------------------------------------------------------------------------

goopen2:				; ...
		test	bx, 2000h
		jz	short goopen
		or	ss:EXTOPEN_ON, 2 ; EXT_OPEN_I24_OFF

goopen:					; ...
		or	ss:EXTOPEN_ON, 1 ; EXT_OPEN_ON
		and	ss:EXTOPEN_FLAG, 0FFh
		cmp	ss:EXTOPEN_FLAG, 10h ; EXT_EXISTS_FAIL+EXT_NEXISTS_CREATE
		jnz	short chknext
		call	$CreateNewFile
		jb	short error_return
		cmp	ss:EXTOPEN_ON, 0
		jz	short ok_return2
		mov	ss:EXTOPEN_FLAG, 2 ; ACTION_CREATED_OPENED
		jmp	setXAttr
; ---------------------------------------------------------------------------

ok_return2:				; ...
		jmp	SYS_RETURN	; SYS_RET_OK
; ---------------------------------------------------------------------------

chknext:				; ...
		test	ss:EXTOPEN_FLAG, 1 ; EXT_EXISTS_OPEN
		jnz	short exist_open
		call	$CREAT
		jb	short error_return
		cmp	ss:EXTOPEN_ON, 0
		jz	short ok_return2
		mov	ss:EXTOPEN_FLAG, 2 ; ACTION_CREATED_OPENED
		test	ss:EXTOPEN_ON, 4 ; EXT_FILE_NOT_EXISTS
		jnz	short setXAttr
		mov	ss:EXTOPEN_FLAG, 3 ; ACTION_REPLACED_OPENED
		jmp	short setXAttr
; ---------------------------------------------------------------------------

error_return2:				; ...
		stc
		retn
; ---------------------------------------------------------------------------

exist_open:				; ...
		test	ss:FSHARING, 0FFh ; -1
		jz	short noserver
		mov	cl, ch

noserver:				; ...
		call	_$Open2
		jnb	short ext_ok
		cmp	ss:EXTOPEN_ON, 0
		jz	short error_return2
		cmp	ax, 2		; error_file_not_found
		jnz	short error_return2
		test	ss:EXTOPEN_FLAG, 10h ; EXT_NEXISTS_CREATE
		jnz	short do_creat
		jmp	short extexit
; ---------------------------------------------------------------------------

do_creat:				; ...
		mov	cx, ss:SAVE_CX
		lds	si, dword ptr ss:SAVE_SI
		mov	dx, si
		call	$CREAT
		jb	short extexit
		mov	ss:EXTOPEN_FLAG, 2 ; ACTION_CREATED_OPENED
		jmp	short setXAttr
; ---------------------------------------------------------------------------

ext_ok:					; ...
		cmp	ss:EXTOPEN_ON, 0
		jz	short ok_return
		mov	ss:EXTOPEN_FLAG, 1 ; ACTION_OPENED

setXAttr:				; ...
		push	ax
		call	Get_User_Stack
		mov	ax, ss:EXTOPEN_FLAG
		mov	[si+4],	ax	; [SI+user_env.user_CX]
		pop	ax
		mov	[si], ax	; [SI+user_env.user_AX]

ok_return:				; ...
		jmp	SYS_RETURN	; SYS_RET_OK
; ---------------------------------------------------------------------------
		pop	bx
		push	ax
		cmp	ss:EXTOPEN_FLAG, 2 ; ACTION_CREATED_OPENED
		jnz	short justopen
		lds	si, dword ptr ss:SAVE_SI
		lds	dx, [si]
		call	$UNLINK
		jmp	short reserror
; ---------------------------------------------------------------------------

justopen:				; ...
		call	$CLOSE

reserror:				; ...
		pop	ax
		jmp	short extexit
; ---------------------------------------------------------------------------
		mov	ax, 2		; error_file_not_found
		jmp	short extexit
; ---------------------------------------------------------------------------
		mov	ax, 1		; error_invalid_function

extexit:				; ...
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

$LockOper:				; ...
		cmp	al, 1
		ja	short lock_bad_func
		push	di
		call	SFFromHandle
		jnb	short lock_do
		pop	di
		mov	al, 6		; error_invalid_handle

lockoperr:				; ...
		jmp	SYS_RET_ERR
; ---------------------------------------------------------------------------

lock_bad_func:				; ...
		mov	ss:EXTERR_LOCUS, 1 ; errLOC_Unk
		mov	al, 1		; error_invalid_function

lockoperrj:				; ...
		jmp	short lockoperr
; ---------------------------------------------------------------------------

lock_do:				; ...
		mov	bx, ax
		mov	bp, offset Lock_Buffer
		mov	[bp+0],	dx	; [BP+LockBuf.Lock_position]
		mov	[bp+2],	cx	; [BP+LockBuf.Lock_position+2]
		pop	cx
		mov	[bp+4],	cx	; [BP+LockBuf.Lock_length]
		mov	[bp+6],	si	; [BP+LockBuf.Lock_length+2]
		mov	cx, 1
		push	ss
		pop	ds
		mov	dx, bp
		test	al, 1		; UNLOCK_ALL
		jnz	short DOS_Unlock
		jmp	short DOS_Lock
; ---------------------------------------------------------------------------

DOS_Unlock:				; ...
		test	byte ptr es:[di+6], 80h	; [ES:DI+SF_ENTRY.sf_flags+1],
					; (sf_isnet>>8)
		jz	short LOCAL_UNLOCK
		mov	ax, 110Ah
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - LOCK	REGION OF FILE
					; BX = file handle, CX:DX = starting offset, SI	= high word of size
					; STACK: WORD low word of size,	ES:DI -> SFT
					; SFT DPB field	-> DPB of drive	containing file, SS = DOS CS
					; Return: CF set error
		jmp	short ValChk
; ---------------------------------------------------------------------------

LOCAL_UNLOCK:				; ...
		call	ds:clr_block	; Call far [JShare+(7*4)] ; 7 =	clr_block

ValChk:					; ...
		jnb	short Lock_OK
		jmp	short lockoperrj
; ---------------------------------------------------------------------------

Lock_OK:				; ...
		mov	ax, ds:TEMP_VAR
		jmp	SYS_RETURN	; SYS_RET_OK
; ---------------------------------------------------------------------------

DOS_Lock:				; ...
		test	byte ptr es:[di+6], 80h
		jz	short LOCAL_LOCK
		mov	ax, 110Ah
		int	2Fh		; Multiplex - NETWORK REDIRECTOR - LOCK	REGION OF FILE
					; BX = file handle, CX:DX = starting offset, SI	= high word of size
					; STACK: WORD low word of size,	ES:DI -> SFT
					; SFT DPB field	-> DPB of drive	containing file, SS = DOS CS
					; Return: CF set error
		jmp	short ValChk
; ---------------------------------------------------------------------------

LOCAL_LOCK:				; ...
		call	ds:set_block	; Call far [JShare+(6*4)] ; 6 =	Set_Block
		jmp	short ValChk

; =============== S U B	R O U T	I N E =======================================


LOCK_CHECK	proc near		; ...
		mov	bx, ds:RetryCount

LockRetry:				; ...
		push	bx
		push	ax
		call	ds:chk_block	; Call far [JShare+(8*4)] ; 8 =	chk_block
		pop	ax
		pop	bx
		jnb	short lc_ret_label
		call	Idle
		dec	bx
		jnz	short LockRetry
		stc

lc_ret_label:				; ...
		retn
LOCK_CHECK	endp


; =============== S U B	R O U T	I N E =======================================


LOCK_VIOLATION	proc near		; ...
		push	ds
		push	es
		push	di
		push	cx
		mov	ax, 21h		; error_lock_violation
		mov	ds:ALLOWED, 18h	; Allowed_FAIL+Allowed_RETRY
		les	bp, ds:THISDPB
		mov	di, 1
		mov	cx, di
		mov	dx, es:[bp+11]	; [ES:BP+DPB.FIRST_SECTOR]
		call	HARDERR
		pop	cx
		pop	di
		pop	es
		pop	ds
		cmp	al, 1
		jz	short lc_ret_label
		stc
		retn
LOCK_VIOLATION	endp


; =============== S U B	R O U T	I N E =======================================


CheckShare	proc near		; ...
		push	ds
		mov	ds, cs:DosDSeg
		cmp	ds:fShare, 0
		pop	ds
		retn
CheckShare	endp


; =============== S U B	R O U T	I N E =======================================


SHARE_CHECK	proc near		; ...
		call	ds:MFT_enter	; call far [JShare+(1*4)] ; 1 =	MFT_Enter

shchk_retn:				; ...
		retn
SHARE_CHECK	endp


; =============== S U B	R O U T	I N E =======================================


SHARE_VIOLATION	proc near		; ...
		push	ds
		push	es
		push	di
		mov	ds:READOP, 0
		mov	ds:ALLOWED, 18h	; Allowed_FAIL+Allowed_RETRY
		les	bp, ds:THISDPB
		mov	di, 1
		mov	cx, di
		mov	dx, es:[bp+17]	; [ES:BP+DPB.DIR_SECTOR]
		call	HARDERR
		pop	di
		pop	es
		pop	ds
		cmp	al, 1
		jz	short shchk_retn
		stc
		retn
SHARE_VIOLATION	endp


; =============== S U B	R O U T	I N E =======================================


ShareEnd	proc near		; ...
		call	ds:MFTClose	; call far [JShare+(2*4)] ; 2 =	MFTClose
		retn
ShareEnd	endp


; =============== S U B	R O U T	I N E =======================================


ShareEnter	proc near		; ...
		push	cx

retry:					; ...
		mov	cx, ds:RetryCount

attempt:				; ...
		les	di, ds:THISSFT
		xor	ax, ax
		mov	es:[di+51], ax	; [ES:DI+SF_ENTRY.sf_MFT]
		push	cx
		call	SHARE_CHECK
		pop	cx
		jnb	short done
		call	Idle
		loop	attempt
		call	SHARE_VIOLATION
		jnb	short retry

done:					; ...
		pop	cx
		retn
ShareEnter	endp


; =============== S U B	R O U T	I N E =======================================


ExecReady	proc near		; ...
		mov	si, dx
		test	word ptr [si+2], 1 ; [si+ERStruc.ER_Flags],ER_EXE
		jz	short er_setver
		mov	ax, [si+8]	; [si+ERStruc.ER_PSP]
		add	ax, 10h
		mov	es, ax
		mov	cx, [si+10]	; [si+ERStruc.ER_StartAddr]
		mov	ax, [si+12]	; [si+ERStruc.ER_StartAddr+2]
		call	ss:FixExePatch

er_setver:				; ...
		test	word ptr [si+2], 2 ; [si+ERStruc.ER_Flags],ER_OVERLAY
		jnz	short er_chkdoshi
		push	ds
		push	si
		lds	si, [si+4]	; [si+ERStruc.ER_ProgName]
		call	Save_Begin	; call Scan_Execname1
		call	Scan_Special_Entries
		pop	si
		pop	ds
		mov	es, word ptr [si+8] ; [si+ERStruc.ER_PSP]
		mov	ax, ss:SPECIAL_VERSION
		mov	word ptr es:SFTFCB, ax ; [es:PDB.Version]

er_chkdoshi:				; ...
		cmp	ss:DosHasHMA, 0
		jz	short er_done
		mov	ax, [si+8]	; [si+ERStruc.ER_PSP]
		or	ss:DOS_FLAG, 4
		test	word ptr [si+2], 1 ; EXECA20OFF
		jnz	short er_setA20
		push	ds
		mov	ds, ax
		call	IsCopyProt
		pop	ds

er_setA20:				; ...
		inc	ss:A20OFF_COUNT
		mov	ss:A20OFF_PSP, ax

er_done:				; ...
		xor	ax, ax
		retn
ExecReady	endp

; ---------------------------------------------------------------------------
exepatch_start	db 6			; ...
		db 8Ch,0D8h
_first_stop	db 2Bh,0C2h
		db 8Eh,0D8h
		db 8Eh,0C0h
		db 0BFh,0Fh,0
		db 57h
		db 0B9h,10h,0
		db 0B0h,0FFh
		db 0F3h,0AEh
		db 47h
		db 8Bh,0F7h
		db 5Fh,58h
_second_stop	db 2Bh,0C2h
second		db 8Eh,0C0h
		db 0B9h,4,2
		db 8Bh,0C6h
		db 0F7h,0D0h
		db 0D3h,0E8h
		db 74h,13h
		db 8Ch,0DAh
		db 83h,0CEh,0F0h
		db 2Bh,0D0h
		db 73h,8
		db 0F7h,0DAh
		db 0D3h,0E2h
		db 2Bh,0F2h
		db 33h,0D2h
		db 8Eh,0DAh
		db 87h,0F7h
		db 1Eh
		db 6
		db 1Fh
		db 7
		db 0FEh,0CDh
		db 75h,0DBh
		db 0ACh
		db 92h
		db 4Eh
		db 0ADh
		db 8Bh,0C8h
		db 46h
		db 8Ah,0C2h
		db 24h,0FEh
		db 3Ch,0B0h
		db 75h,5
		db 0ACh
		db 0F3h,0AAh
		db 0EBh,6
		db 3Ch,0B2h
		db 75h,6Ch
		db 0F3h,0A4h
		db 92h
		db 0A8h,1
		db 74h,0B9h
		db 90h,90h
scan_patch1	db 8Ch,0C3h		; ...
		db 8Ch,0D8h
		db 2Bh,0C2h
		db 8Eh,0D8h
		db 8Eh,0C0h
		db 0BFh,0Fh,0
		db 0B9h,10h,0
		db 0B0h,0FFh
		db 0F3h,0AEh
		db 47h
		db 8Bh,0F7h
		db 8Bh,0C3h
		db 2Bh,0C2h
		db 8Eh,0C0h
		db 0BFh,0Fh,0
		db 0B1h,4
		db 8Bh,0C6h
		db 0F7h,0D0h
		db 0D3h,0E8h
		db 74h,9
		db 8Ch,0DAh
		db 2Bh,0D0h
		db 8Eh,0DAh
		db 83h,0CEh,0F0h
		db 8Bh,0C7h
		db 0F7h,0D0h
		db 0D3h,0E8h
		db 74h,9
		db 8Ch,0C2h
		db 2Bh,0D0h
		db 8Eh,0C2h
		db 83h,0CFh,0F0h
scan_patch2	db 8Ch,0C3h		; ...
		db 8Ch,0D8h
		db 48h
		db 8Eh,0D8h
		db 8Eh,0C0h
		db 0BFh,0Fh,0
		db 0B9h,10h,0
		db 0B0h,0FFh
		db 0F3h,0AEh
		db 47h
		db 8Bh,0F7h
		db 8Bh,0C3h
		db 48h
		db 8Eh,0C0h
		db 0BFh,0Fh,0
		db 0B1h,4
		db 8Bh,0C6h
		db 0F7h,0D0h
		db 0D3h,0E8h
		db 74h,0Ah
		db 8Ch,0DAh
		db 2Bh,0D0h
		db 8Eh,0DAh
		db 81h,0CEh,0F0h,0FFh
		db 8Bh,0C7h
		db 0F7h,0D0h
		db 0D3h,0E8h
		db 74h,0Ah
		db 8Ch,0C2h
		db 2Bh,0D0h
		db 8Eh,0C2h
		db 81h,0CFh,0F0h,0FFh
scan_patch3	db 8Ch,0C3h		; ...
		db 8Ch,0D8h
		db 48h
		db 8Eh,0D8h
		db 8Eh,0C0h
		db 0BFh,0Fh,0
		db 0B9h,10h,0
		db 0B0h,0FFh
		db 0F3h,0AEh
		db 47h
		db 8Bh,0F7h
		db 8Bh,0C3h
		db 48h
		db 8Eh,0C0h
		db 0BFh,0Fh,0
		db 0B1h,4
		db 8Bh,0C6h
		db 0F7h,0D0h
		db 0D3h,0E8h
		db 74h,9
		db 8Ch,0DAh
		db 2Bh,0D0h
		db 8Eh,0DAh
		db 83h,0CEh,0F0h
		db 8Bh,0C7h
		db 0F7h,0D0h
		db 0D3h,0E8h
		db 74h,9
		db 8Ch,0C2h
		db 2Bh,0D0h
		db 8Eh,0C2h
		db 83h,0CFh,0F0h
scan_com	db 0ACh			; ...
		db 8Ah,0D0h
		db 4Eh
		db 0ADh
		db 8Bh,0C8h
		db 46h
		db 8Ah,0C2h
		db 24h,0FEh
		db 3Ch,0B0h
		db 75h,6
		db 0ACh
		db 0F3h,0AAh
		db 0EBh,7,90h
		db 3Ch,0B2h
		db 75h,6Bh
		db 0F3h,0A4h
		db 8Ah,0C2h
		db 0A8h,1

; =============== S U B	R O U T	I N E =======================================


ExePatch	proc near		; ...
		call	ExePackPatch
		call	ss:RationalPatchPtr
		retn
ExePatch	endp


; =============== S U B	R O U T	I N E =======================================


ExePackPatch	proc near		; ...
		push	bx
		mov	bx, es
		cmp	bx, 0FFFh
		jbe	short ep_cont
		pop	bx
		retn
; ---------------------------------------------------------------------------

ep_cont:				; ...
		push	ds
		push	es
		push	ax
		push	cx
		push	si
		push	di
		sub	cx, 2
		jnb	short epp_1
		jmp	ep_notpacked
; ---------------------------------------------------------------------------

epp_1:					; ...
		mov	di, cx
		mov	es, ax
		assume ds:nothing
		mov	ss:UNPACK_OFFSET, di
		cmp	word ptr es:[di], 4252h	; 'RB'
		jz	short epp_2
		jmp	ep_notpacked
; ---------------------------------------------------------------------------

epp_2:					; ...
		push	cs
		pop	ds
		assume ds:nothing
		add	di, 6Ch		; PATCH1_COM_OFFSET
		call	chk_common_str
		jnz	short ep_chkpatch2
		mov	si, offset scan_patch1
		mov	di, ss:UNPACK_OFFSET
		add	di, 28h		; PATCH1_OFFSET
		mov	cx, 68		; size_scan_patch1
					; = scan_patch2	- scan_patch1
		mov	bx, 142
		mov	ax, 0EF4Eh	; PATCH1_CHKSUM
		call	chk_patchsum
		jb	short ep_done1
		mov	si, offset exepatch_start ; str1
		mov	cx, 102
		rep movsb

ep_done1:				; ...
		jmp	ep_notpacked	; ep_done
; ---------------------------------------------------------------------------

ep_chkpatch2:				; ...
		mov	di, 76h		; PATCH2_COM_OFFSET
		call	chk_common_str
		jnz	short ep_chkpatch3
		mov	si, offset scan_patch2
		mov	di, 32h		; PATCH2_OFFSET
		mov	cx, 68		; size_scan_patch2
		mov	bx, 140		; CHKSUM2_LEN
		mov	ax, 78B2h	; PATCH2_CHKSUM
		call	chk_patchsum
		jnb	short ep_patchcode2
		mov	si, offset scan_patch2
		mov	cx, 68		; size_scan_patch2
					; = scan_patch3	- scan_patch2
		mov	bx, 129		; CHKSUM2A_LEN
		mov	ax, 1C47h	; PATCH2A_CHKSUM
		call	chk_patchsum
		jb	short ep_notpacked

ep_patchcode2:				; ...
		mov	si, offset exepatch_start ; str1
		mov	cx, 3		; first_stop =
					; _first_stop -	exepact_start (str1)
		rep movsb
		mov	ax, 4890h	; dec ax, nop
		stosw
		add	si, 2
		mov	cx, 20		; second_stop =
					; _secondstop -	_first_stop
		rep movsb
		stosw			; dec ax, nop
		add	si, 2
		mov	cx, 75		; last_stop =
					; scan_patch1 -	second
		rep movsb
		jmp	short ep_notpacked ; ep_done
; ---------------------------------------------------------------------------

ep_chkpatch3:				; ...
		mov	di, 74h		; PATCH3_COM_OFFSET
		call	chk_common_str
		jnz	short ep_notpacked
		mov	si, offset scan_patch3
		mov	di, 32h		; PATCH3_OFFSET
		mov	cx, 66		; size_scan_patch3
					; = scan_com - scan_patch3
		mov	bx, 139		; CHKSUM3_LEN
		mov	ax, 4EDEh	; PATCH3_CHKSUM
		call	chk_patchsum
		jb	short ep_notpacked
		mov	si, offset exepatch_start ; str1
		mov	cx, 3		; first_stop
		rep movsb
		mov	al, 48h		; dec ax
		stosb
		add	si, 2
		mov	cx, 20		; second_stop
		rep movsb
		stosb			; dec ax
		add	si, 2
		mov	cx, 75		; last_stop
		rep movsb

ep_notpacked:				; ...
		pop	di
		pop	si
		pop	cx
		pop	ax
		pop	es
		pop	ds
		pop	bx
		retn
ExePackPatch	endp


; =============== S U B	R O U T	I N E =======================================


chk_common_str	proc near		; ...
		mov	si, offset scan_com
		mov	cx, 32		; size_scan_com
					; = offset ExePatch - offset scan_com
		repe cmpsb
		jz	short ccs_done
		cmp	byte ptr es:[di-1], 56h
		jnz	short ccs_done
		repe cmpsb

ccs_done:				; ...
		retn
chk_common_str	endp

; ---------------------------------------------------------------------------

chk_patchsum:				; ...
		push	di
		repe cmpsb
		jnz	short cp_fail
		mov	di, ss:UNPACK_OFFSET
		mov	cx, bx
		mov	bx, ax
		xor	ax, ax

ep_chksum:				; ...
		add	ax, es:[di]
		add	di, 2
		loop	ep_chksum
		pop	di
		cmp	ax, bx
		jnz	short cp_fail
		clc
		retn
; ---------------------------------------------------------------------------

cp_fail:				; ...
		stc
		retn
; ---------------------------------------------------------------------------
RScanPattern1	db 0, 0, 20h, 0, 0, 0, 40h, 0, 1, 0 ; ...
RScanPattern2	db 8Bh,	0Eh, 10h, 0, 90h, 0E2h,	0FEh, 0E8h ; ...
RScanPattern3	db 8Bh,	0Eh, 10h, 0, 0E2h, 0FEh, 0E8h ;	...

; =============== S U B	R O U T	I N E =======================================


RationalPatch	proc near		; ...
		cld
		push	ax
		push	bx
		push	cx
		push	dx
		push	si
		push	di
		push	es
		push	ds
		mov	di, 0Ah
		push	cs
		pop	ds
		mov	si, offset RScanPattern1
		mov	cx, 10		; RLen1
		repe cmpsb
		jnz	short rpexit
		mov	ax, es:0
		cmp	ax, 348
		jb	short rpexit
		cmp	ax, 383
		ja	short rpexit
		call	VerifyVersion
		jnz	short rpexit
		mov	cx, es:16h
		sub	cx, 200h
		mov	es, word ptr es:20h
		mov	si, offset RScanPattern2
		mov	dx, 8		; RLen2
		call	ScanCodeSeq
		jz	short rpfound
		mov	si, offset RScanPattern3
		mov	dx, 15		; RLen3
		call	ScanCodeSeq
		jnz	short rpexit

rpfound:				; ...
		mov	al, 9Ah		; far call opcode
		stosb
		mov	ax, offset RatBugCode
		stosw
		mov	ax, ss
		stosw
		mov	cx, dx
		sub	cx, 6
		mov	al, 90h		; NOPs
		rep stosb

rpexit:					; ...
		pop	ds
		pop	es
		pop	di
		pop	si
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		retn
RationalPatch	endp


; =============== S U B	R O U T	I N E =======================================


ScanCodeSeq	proc near		; ...
		push	cx
		sub	cx, dx
		inc	cx
		mov	di, 200h

scsagain:				; ...
		push	si
		push	di
		push	cx
		mov	cx, dx
		repe cmpsb
		pop	cx
		pop	di
		pop	si
		jz	short scsfound
		inc	di
		loop	scsagain

scsfound:				; ...
		pop	cx
		retn
ScanCodeSeq	endp


; =============== S U B	R O U T	I N E =======================================


VerifyVersion	proc near		; ...
		mov	si, es:2Ah
		mov	bl, 10
		add	si, 3
		call	VVDigit
		jnz	short vvexit
		call	VVDigit
		jnz	short vvexit
		cmp	byte ptr es:[si], '.' ; 2Eh
		jnz	short vvexit
		dec	si
		call	VVDigit

vvexit:					; ...
		retn
VerifyVersion	endp


; =============== S U B	R O U T	I N E =======================================


VVDigit		proc near		; ...
		div	bl
		add	ah, '0'         ; 30h
		dec	si
		cmp	es:[si+1], ah
		mov	ah, 0
		retn
VVDigit		endp

; ---------------------------------------------------------------------------
CPScanPattern	db 89h,	26h, 48h, 1	; ...
					; mov [148],sp
		db 8Ch,	0Eh, 4Ch, 1	; mov [14C],cs
		db 0C7h, 6, 4Ah, 1, 0, 1 ; mov [14A],100h
		db 8Ch,	0Eh, 13h, 1	; mov [113],cs
		db 0B8h, 20h, 1		; mov ax,120h
		db 0BEh, 0, 1		; mov si,100h

; =============== S U B	R O U T	I N E =======================================


IsCopyProt	proc near		; ...
		cmp	word ptr ds:11Bh, 5343h	; [CPID1Offset], ID1
		jnz	short CP_done
		cmp	word ptr ds:173h, 5044h	; [CPID2Offset], ID2
		jnz	short CP_done
		cmp	word ptr ds:146h, 0F413h ; [CPID3Offset], ID3
		jnz	short CP_done
		cmp	word ptr ds:124h, 8000h	; [CPID4Offset], ID4
		jnz	short CP_done
		push	cs
		pop	es
		mov	di, offset CPScanPattern
		mov	si, 175h	; CPStartOffset
		mov	cx, 24		; CPSPlen
		repe cmpsb
		jnz	short CP_done
		mov	ss:A20OFF_COUNT, 0Ah

CP_done:				; ...
		retn
IsCopyProt	endp

; ---------------------------------------------------------------------------

SYSBUF:					; ...
		iret			; initiret
; ---------------------------------------------------------------------------
InitBioDataSeg	dw 70h			; ...

; =============== S U B	R O U T	I N E =======================================


ParaRound	proc near		; ...
		add	ax, 0Fh		; add ax, 15
		rcr	ax, 1
		shr	ax, 1
		shr	ax, 1
		shr	ax, 1
		retn
ParaRound	endp

; ---------------------------------------------------------------------------

DOSINIT:				; ...
		cli
		cld
		push	dx
		push	si
		push	ds
		push	di
		mov	bx, es
		mov	ax, offset DOSCODE_END ; MEMSTRT
		add	ax, 15
		and	ax, 0FFF0h	; ~15
		mov	si, ax
		mov	ax, cs
		mov	ds, ax
		mov	es, cs:InitBioDataSeg
		assume es:nothing
		mov	es, word ptr es:3
		assume es:nothing
		xor	di, di
		mov	cx, 4962	; MSDAT001E ; size of DOSDATA
		rep movsb
		pop	di
		pop	ds
		pop	si
		pop	dx
		push	es
		push	ds
		pop	es
		pop	ds
		mov	word ptr ds:BiosDataPtr, di
		mov	word ptr ds:BiosDataPtr+2, bx
		mov	cs:DosDSeg, ds
		mov	cs:LowInt23Seg,	ds
		mov	cs:LowInt24Seg,	ds
		mov	cs:LowInt28Seg,	ds
		mov	ds:ENDMEM, dx
		mov	ds:USER_SP, sp
		mov	ds:USER_SS, ss
		mov	ax, ds
		mov	ss, ax
		mov	sp, offset DSKSTACK
		mov	ds:FixExePatch,	offset RetExePatch
		mov	ds:RationalPatchPtr, offset RetExePatch
		mov	ds:ChkCopyProt,	offset RetExePatch
		mov	ax, cs
		mov	ds:TEMP_DOSLOC,	ax
		mov	word ptr ds:NULDEV+2, es
		mov	word ptr ds:NULDEV, si
		mov	ds:Win386_Info_16, ds ;	[Win386_Info+16]
					; [Win386_Info+Win386_SIS.Instance_Data_Ptr+2]
		push	si
		mov	cx, 7
		mov	si, offset Instance_Table_2 ; Instance_Table+2

Instance_init_loop:			; ...
		mov	word ptr [si], ds
		add	si, 6		; size_of_Win386_IIS
		loop	Instance_init_loop
		mov	cx, 5
		mov	si, offset OldInstanceJunk_6 ; OldInstanceJunk+6

OldInstance_init_loop:			; ...
		mov	word ptr [si], ds
		add	si, 6
		loop	OldInstance_init_loop
		pop	si
		push	es
		pop	ds
		push	ds
		xor	ax, ax
		mov	ds, ax
		mov	ax, offset SYSBUF ; initiret
		mov	ds:0A8h, ax	; [2Ah*4] ; [addr_int_ibm]
		mov	ax, cs
		mov	ds:0AAh, ax	; [(2Ah*4)+2] ;	[addr_int_ibm+2]
		pop	ds
		call	CHARINIT
		push	si
		push	ss
		pop	es
		mov	di, offset SFTABL_6 ; SFTABL+6
					; SFTABL+SFT.SFTable
		mov	ax, 3
		stosw
		dec	al
		stosw
		xor	al, al
		stosb
		mov	al, 0C3h	; devid_device_EOF|devid_device|ISCIN|ISCOUT
		stosw
		mov	ax, si
		stosw
		mov	ax, ds
		stosw
		xor	ax, ax		; 0
		stosw
		stosw
		stosw
		dec	ax		; -1
		stosw
		stosw
		inc	ax		; 0
		stosw
		stosw
		add	di, 7		; SF_ENTRY.sf_name-SF_ENTRY.sf_cluspos
		add	si, 10		; SYSDEV.NAME
		mov	cx, 4
		rep movsw
		mov	cl, 3
		mov	al, 20h	; ' '
		rep stosb
		pop	si
		or	byte ptr [si+4], 3 ; [SI+SYSDEV.ATT],ISCIN|ISCOUT
		mov	word ptr ss:BCON, si
		mov	word ptr ss:BCON+2, ds

CHAR_INIT_LOOP:				; ...
		lds	si, [si]
		call	CHARINIT
		test	byte ptr [si+4], 8 ; [SI+SYSDEV.ATT],ISCLOCK
		jz	short CHAR_INIT_LOOP
		mov	word ptr ss:BCLOCK, si
		mov	word ptr ss:BCLOCK+2, ds
		mov	bp, 4962	; MSDAT001E
		mov	word ptr ss:SYSINITVARS, bp ; [ss:DPBHEAD]
		mov	word ptr ss:SYSINITVARS+2, es ;	[ss:DPBHEAD+2]

PERDRV:					; ...
		lds	si, [si]	; [SI+SYSDEV.NEXT]
		cmp	si, 0FFFFh	; -1
		jz	short CONTINIT
		call	CHARINIT
		test	word ptr [si+4], 8000h ; [SI+SYSDEV.ATT],DEVTYP
		jnz	short PERDRV
		mov	cl, ss:CALLMED	; [SS:CALLUNIT]
		xor	ch, ch
		mov	[si+10], cl	; [si+SYSDEV.NAME]
		mov	dl, ss:NUMIO
		xor	dh, dh
		add	ss:NUMIO, cl
		push	ds
		push	si
		lds	bx, dword ptr ss:CALLSCNT ; [SS:CALLBPB]

PERUNIT:				; ...
		mov	si, [bx]
		inc	bx
		inc	bx
		mov	es:[bp+0], dl	; [ES:BP+DPB.DRIVE]
		mov	es:[bp+1], dh	; [ES:BP+DPB.UNIT]
		push	bx
		push	cx
		push	dx
		call	$SETDPB
		mov	ax, es:[bp+2]	; [ES:BP+DPB.SECTOR_SIZE]
		cmp	ax, ss:MAXSEC
		jbe	short NOTMAX
		mov	ss:MAXSEC, ax

NOTMAX:					; ...
		mov	ax, bp
		add	ax, 33		; DPBSIZ
		mov	es:[bp+25], ax	; [ES:BP+DPB.NEXT_DPB]
		mov	word ptr es:[bp+27], es	; [ES:BP+DPB.NEXT_DPB+2]
		mov	byte ptr es:[bp+24], 0FFh ; [ES:BP+DPB.FIRST_ACCESS],-1
		pop	dx
		pop	cx
		pop	bx
		mov	ax, ds
		pop	si
		pop	ds
		mov	es:[bp+19], si	; [ES:BP+DPB.DRIVER_ADDR]
		mov	word ptr es:[bp+21], ds	; [ES:BP+DPB.DRIVER_ADDR+2]
		push	ds
		push	si
		inc	dh
		inc	dl
		mov	ds, ax
		add	bp, 33		; DPBSIZ
		loop	PERUNIT
		pop	si
		pop	ds
		jmp	PERDRV
; ---------------------------------------------------------------------------

CONTINIT:				; ...
		sub	bp, 33		; DPBSIZ
		mov	word ptr [bp+25], 0FFFFh ; -1
		mov	word ptr [bp+27], 0FFFFh ; -1
		add	bp, 33
		push	ss
		pop	ds
		mov	ax, bp
		call	ParaRound
		mov	dx, ds
		add	dx, ax
		mov	bx, 0Fh
		mov	cx, ds:ENDMEM
		mov	ds:DSKCHRET_3, ds ; [DSKCHRET+3] ; [DOSSEG_INIT]
		push	dx
		mov	ax, ds:TEMP_DOSLOC
		mov	es, ax
		mov	ds:TEMP_DOSLOC,	0FFFFh ; -1
		call	patch_vec_segments
		call	patch_misc_segments
		mov	ds:TEMP_DOSLOC,	es
		pop	dx
		xor	ax, ax
		mov	ds, ax
		mov	es, ax
		mov	di, 90h		; addr_int_fatal_abort
					; 4*int_fatal_abort
		mov	ax, ss:TEMP_DOSLOC
		mov	[di+2],	ax
		mov	di, 82h		; INTBASE+2
		mov	word ptr ds:0, offset DIVOV
		mov	di, 80h		; INTBASE
		mov	ax, offset IRETT
		mov	cx, 9

iset1:					; ...
		stosw
		add	di, 2
		loop	iset1
		add	di, 4
		mov	cx, 6

iset2:					; ...
		stosw
		add	di, 2
		loop	iset2
		add	di, 8
		mov	cx, 14

iset3:					; ...
		stosw
		add	di, 2
		loop	iset3
		mov	word ptr ds:0BCh, offset INT2F ; [02Fh*4],INT2F
		mov	ax, ss:TEMP_DOSLOC
		mov	ds:0BEh, ax	; [(02Fh*4)+2]
		mov	byte ptr ds:0C0h, 0EAh ; [ENTRYPOINT],mi_long_jmp
		mov	word ptr ds:0C1h, offset CALL_ENTRY ;  [ENTRYPOINT+1]
		mov	word ptr ds:80h, offset	QUIT ; [addr_int_abort]
		mov	word ptr ds:84h, offset	COMMAND	; [addr_int_command]
		mov	word ptr ds:88h, 100h ;	[addr_int_terminate]
		mov	ds:8Ah,	dx	; [addr_int_terminate+2]
		mov	word ptr ds:94h, offset	ABSDRD ; [addr_int_disk_read]
		mov	word ptr ds:98h, offset	ABSDWRT	; [addr_int_disk_write]
		mov	word ptr ds:9Ch, offset	STAY_RESIDENT ;	[addr_int_keep_process]
		push	ss
		pop	ds
		push	ss
		pop	es
		push	dx
		inc	dx
		mov	ds:CurrentPDB, dx
		xor	di, di
		mov	es, dx
		xor	ax, ax
		mov	cx, 128
		rep stosw
		mov	ax, ds:ENDMEM
		call	SETMEM
		push	ss
		pop	ds
		mov	di, 24		; PDB.JFN_TABLE
		xor	ax, ax
		stosw
		stosb
		mov	al, 0FFh
		mov	cx, 17		; FILPERPROC-3
		rep stosb
		push	ss
		pop	es
		mov	word ptr ds:SFT_ADDR+2,	ds
		mov	si, offset SysInitTable
		mov	word ptr es:[si+6], es ; [es:si+SYSI_EXT.Country_Tab+2]
		mov	word ptr es:[si+2], es ; [es:si+SYSI_EXT.SysInitVars+2]
		mov	word ptr es:BUFFHEAD+2,	es
		mov	si, offset BufferQueue ; HASHINITVAR
		mov	word ptr es:BUFFHEAD, si
		pop	dx
		mov	word ptr ds:DMAADD+2, dx
		mov	es:arena_head, dx
		mov	ds, dx
		mov	byte ptr ds:0, 5Ah ; 'Z' ; [ARENA.SIGNATURE],
					; arena_signature_end
		mov	word ptr ds:1, 0 ; [ARENA.OWNER],
					; arena_owner_system
		mov	ax, ss:ENDMEM
		sub	ax, dx
		dec	ax
		mov	ds:3, ax	; [ARENA.SIZE]
		mov	di, offset SFTABL_6 ; SFTABL+6
					; SFTABL+SFT.SFTable
		mov	ax, 3
		stosw
		mov	di, offset SysInitTable
		inc	dx
		mov	ds, dx
		mov	dx, offset _seg_reinit
		mov	cx, offset exepatch_start
		sub	cx, offset _$STARTCODE
		mov	ax, offset SYSBUF
		sub	ax, offset _$STARTCODE
		mov	sp, ss:USER_SP
		mov	ss, ss:USER_SS
		retf

; =============== S U B	R O U T	I N E =======================================


CHARINIT	proc near		; ...
		mov	byte ptr ss:DEVCALL, 1Ah ; [SS:DEVCALL_REQLEN],DINITHL
		mov	byte ptr ss:DEVCALL+1, 0 ; [SS:DEVCALL_REQUNIT],0
		mov	ss:DEVCALL_REQFUNC, 0 ;	[SS:DEVCALL_REQFUNC],DEVINIT
		mov	ss:DEVCALL_REQSTAT, 0 ;	[SS:DEVCALL_REQSTAT],0
		push	es
		push	bx
		push	ax
		mov	bx, offset DEVCALL
		push	ss
		pop	es
		call	DEVIOCALL2
		pop	ax
		pop	bx
		pop	es
		retn
CHARINIT	endp


; =============== S U B	R O U T	I N E =======================================


check_XMM	proc near		; ...
		push	ax
		mov	ax, 4300h	; (XMM_MULTIPLEX<<8)+XMM_INSTALL_CHECK
		int	2Fh		; - Multiplex -	XMS - INSTALLATION CHECK
					; Return: AL = 80h XMS driver installed
					; AL <>	80h no driver
		cmp	al, 80h
		jnz	short cXMM_no_driver
		push	bx
		push	dx
		push	ds
		push	es
		mov	ax, 4310h	; (XMM_MULTIPLEX<<8)+XMM_FUNCTION_ADDR
		int	2Fh		; - Multiplex -	XMS - GET DRIVER ADDRESS
					; Return: ES:BX	-> driver entry	point
		mov	ds, cs:DosDSeg
		mov	word ptr ds:XMMcontrol,	bx
		mov	word ptr ds:XMMcontrol+2, es

cXMMexit:
		clc
		pop	es
		pop	ds
		pop	dx
		pop	bx
		pop	ax
		retn
; ---------------------------------------------------------------------------

cXMM_no_driver:				; ...
		stc
		pop	ax
		retn
check_XMM	endp

; ---------------------------------------------------------------------------
num_entry	db 0			; ...
; ---------------------------------------------------------------------------

_seg_reinit:				; ...
		push	ds
		mov	ds, cs:DosDSeg
		call	patch_misc_segments
		cmp	ax, 0
		jnz	short patch_vec_seg
		cmp	cs:num_entry, 0
		jnz	short second_entry
		mov	ax, ds
		call	patch_vec_segments
		call	patch_offset

second_entry:				; ...
		mov	ax, es
		mov	di, offset DOSINTTABLE
		mov	cx, 9
		push	ds
		pop	es

dosinttabloop:				; ...
		add	di, 2
		stosw
		loop	dosinttabloop
		cmp	ax, 0F000h
		jb	short sr_done
		call	check_XMM
		jb	short sr_done
		call	patch_in_nops
		mov	ds:DosHasHMA, 1
		mov	ds:FixExePatch,	offset ExePatch
		mov	ds:ChkCopyProt,	offset IsCopyProt

Get_CPU_Type:				; WhatCPUType
		pushf
		push	bx
		xor	bx, bx
		xor	ax, ax
		push	ax
		popf
		pushf
		pop	ax
		and	ax, 0F000h
		cmp	ax, 0F000h
		jz	short cpu_8086
		mov	ax, 0F000h
		push	ax
		popf
		pushf
		pop	ax
		and	ax, 0F000h
		jz	short cpu_286
		inc	bx

cpu_286:				; ...
		inc	bx

cpu_8086:				; ...
		mov	ax, bx
		pop	bx
		popf
		cmp	al, 1
		jnz	short sr_done
		mov	ds:RationalPatchPtr, offset RationalPatch
		jmp	short sr_done
; ---------------------------------------------------------------------------

patch_vec_seg:				; ...
		mov	ax, es
		call	patch_vec_segments

sr_done:				; ...
		mov	cs:num_entry, 1
		pop	ds
		retf

; =============== S U B	R O U T	I N E =======================================


patch_vec_segments proc	near		; ...
		push	es
		xor	cx, cx
		mov	es, cx
		mov	di, 82h		; INTBASE+2
					; di ->	segment	of int 20 vector
		mov	es:2, ax
		mov	cx, 2

ps_set1:				; ...
		stosw
		add	di, 2
		loop	ps_set1
		add	di, 4
		stosw
		add	di, 6
		mov	cx, 4

ps_set2:				; ...
		stosw
		add	di, 2
		loop	ps_set2
		add	di, 4
		mov	cx, 6

ps_set3:				; ...
		stosw
		add	di, 2
		loop	ps_set3
		add	di, 8
		mov	cx, 14

ps_set4:				; ...
		stosw
		add	di, 2
		loop	ps_set4
		mov	es:0C3h, ax	; [es:ENTRYPOINT+3]
		pop	es
		retn
patch_vec_segments endp


; =============== S U B	R O U T	I N E =======================================


patch_misc_segments proc near		; ...
		push	bx
		push	es
		push	ax
		mov	ax, es
		push	ds
		pop	es
		mov	di, offset JShare
		mov	bx, ds:TEMP_DOSLOC
		mov	cx, 15

jumptabloop:				; ...
		add	di, 2
		cmp	bx, -1
		jz	short share_patch
		cmp	bx, es:[di]
		jnz	short no_share_patch

share_patch:				; ...
		stosw

no_share_patch:				; ...
		loop	jumptabloop
		mov	si, offset COUNTRY_CDPG
		mov	word ptr [si+4Fh], ds ;	[si+DOS_CCDPG.ccUcase_ptr+2]
		mov	word ptr [si+54h], ds ;	[si+DOS_CCDPG.ccFileUcase_ptr+2]
		mov	word ptr [si+59h], ds ;	[si+DOS_CCDPG.ccFileChar_ptr+2]
		mov	word ptr [si+5Eh], ds ;	[si+DOS_CCDPG.ccCollate_ptr+2]
		mov	word ptr [si+80h], ds ;	[si+DOS_CCDPG.ccMono_ptr+2]
		mov	word ptr [si+63h], ds ;	[si+DOS_CCDPG.ccDBCS_ptr+2]
		mov	si, offset FastOpenTable
		cmp	ds:TEMP_DOSLOC,	0FFFFh ; -1
		jz	short fast_patch
		mov	cx, ds:TEMP_DOSLOC
		cmp	cx, [si+4]	; [si+fastopen_entry.name_caching+2]
		jnz	short no_fast_patch

fast_patch:				; ...
		mov	[si+4],	ax

no_fast_patch:				; ...
		pop	ax
		pop	es
		pop	bx
		retn
patch_misc_segments endp


; =============== S U B	R O U T	I N E =======================================


patch_offset	proc near		; ...
		push	es
		xor	ax, ax
		mov	es, ax
		mov	word ptr es:0, offset ldivov
		mov	di, 80h		; INTBASE
					; di-> offset of int 20	handler
		mov	ax, offset lirett
		mov	cx, 2

po_iset1:				; ...
		stosw
		add	di, 2
		loop	po_iset1
		add	di, 4
		stosw
		add	di, 6
		mov	cx, 4

po_iset2:				; ...
		stosw
		add	di, 2
		loop	po_iset2
		add	di, 4
		mov	cx, 6

po_iset3:				; ...
		stosw
		add	di, 2
		loop	po_iset3
		add	di, 8
		mov	cx, 14

po_iset4:				; ...
		stosw
		add	di, 2
		loop	po_iset4
		mov	word ptr es:0BCh, offset lint2f
		mov	byte ptr es:0C0h, 0EAh ; [es:ENTRYPOINT],mi_long_jmp
		mov	word ptr es:0C1h, offset lcall_entry
		mov	word ptr es:80h, offset	lquit ;	[es:addr_int_abort]
		mov	word ptr es:84h, offset	lcommand ; [es:addr_int_command]
		mov	word ptr es:94h, offset	labsdrd	; [es:addr_int_disk_read]
		mov	word ptr es:98h, offset	labsdwrt ; [es:addr_int_disk_write]
		mov	word ptr es:9Ch, offset	lstay_resident ; [es:addr_int_keep_process]
		pop	es
		retn
patch_offset	endp

; ---------------------------------------------------------------------------
patch_table	dw offset ldivov	; ...
					; i0patch
		dw offset lquit		; i20patch
		dw offset lcommand	; i21patch
		dw offset labsdrd	; i25patch
		dw offset labsdwrt	; i26patch
		dw offset lstay_resident ; i27patch
		dw offset lint2f	; i2fpatch
		dw offset lcall_entry	; cpmpatch
; ---------------------------------------------------------------------------

patch_in_nops:				; ...
		push	ax
		push	si
		mov	si, offset patch_table
		mov	ax, 9090h	; nop, nop
		mov	cx, 8		; patch_table_size

pin_loop:				; ...
		mov	di, cs:[si]
		stosw
		add	si, 2
		loop	pin_loop
		pop	si
		pop	ax
		retn
; ---------------------------------------------------------------------------
DOSCODE_END	db 9 dup(0)		; ...
DOSCODE		ends

; ===========================================================================

; Segment type:	Pure data
DOSDATA		segment	byte public 'DATA' use16
		assume cs:DOSDATA
DATASTART	db 4 dup(0)
DataVersion	dw 1
WinoldPatch1	db 8 dup(0)		; ...
MYNUM		dw 0			; ...
FCBLRU		dw 0			; ...
OpenLRU		dw 0
OEM_HANDLER	dd 0FFFFFFFFh
LeaveAddr	dw offset LeaveDOS	; DOSCODE:LeaveDOS
RetryCount	dw 3			; ...
RetryLoop	dw 1			; ...
LastBuffer	dd 0FFFFFFFFh		; ...
CONTPOS		dw 0			; ...
arena_head	dw 0			; ...
SYSINITVARS	dd 0			; ...
					; DPBHEAD
SFT_ADDR	dd 0CCh			; ...
BCLOCK		dd 0			; ...
BCON		dd 0			; ...
MAXSEC		dw 128			; ...
BUFFHEAD	dd 0			; ...
CDSADDR		dd 0			; ...
SFTFCB		dd 0			; ...
KEEPCOUNT	dw 0
NUMIO		db 0			; ...
CDSCOUNT	db 0			; ...
NULDEV		dd 0			; ...
		dw 8004h		; DEVTYP|ISNULL
		dw offset SNULDEV
		dw offset INULDEV
		db 'NUL     '
SPLICES		db 0			; ...
Special_Entries	dw 0
UU_IFS_DOS_CALL	dd 0			; ...
ChkCopyProt	dw 0			; ...
A20OFF_PSP	dw 0			; ...
BUFFERS_PARM1	dw 0
BUFFERS_PARM2	dw 0
BOOTDRIVE	db 0			; ...
DDMOVE		db 0			; ...
EXT_MEM_SIZE	dw 0
BufferQueue	dd 0			; ...
DirtyBufferCount dw 0			; ...
SC_CACHE_PTR	dd 0			; ...
SC_CACHE_COUNT	dw 0			; ...
BuffInHMA	db 0			; ...
LoMemBuff	dd 0			; ...
UU_BUF_EMS_FIRST_PAGE db 3 dup(0)
CL0FATENTRY	dw -1			; ...
IoStatFail	db 0			; ...
ALLOCMSAVE	db 0			; ...
A20OFF_COUNT	db 0			; ...
DOS_FLAG	db 0			; ...
UNPACK_OFFSET	dw 0			; ...
UMBFLAG		db 0			; ...
SAVE_AX		dw 0			; ...
UMB_HEAD	dw -1			; ...
START_ARENA	dw 1			; ...
JShare		dw offset BadCall	; ...
		dw 0
MFT_enter	dd 44AEh		; ...
MFTClose	dd 44AEh		; ...
MFTclU		dd 44AAh		; ...
MFTCloseP	dw offset BadCall	; ...
		dw 0
MFTcloN		dw offset BadCall	; ...
		dw 0
set_block	dd 44AAh		; ...
clr_block	dd 44AAh		; ...
chk_block	dd 44AEh		; ...
MFT_get		dd 44AAh		; ...
ShSave		dw offset BadCall	; ...
		dw 0
ShChk		dw offset BadCall	; ...
		dw 0
ShCol		dd 44AEh		; ...
ShCloseFile	dw offset BadCall	; ...
		dw 0
ShSU		dw offset BadCall	; ...
		dw 0
SFTABL		dw -1
		dw -1
		dw 5
SFTABL_6	db 295 dup(0)		; ...
CARPOS		db 0			; ...
STARTPOS	db 0			; ...
INBUF		db 128 dup(0)		; ...
CONBUF		db 131 dup(0)		; ...
PFLAG		db 0			; ...
VERFLG		db 0			; ...
CHARCO		db 11b			; ...
chSwitch	db '/'
AllocMethod	db 0			; ...
fShare		db 0			; ...
DIFFNAM		db 1			; ...
MYNAME		db 16 dup(32)		; ...
CritPatch	dw offset redir_patch	; ...
		dw offset redir_patch
		dw offset redir_patch
		dw offset redir_patch
		dw 0
		db 90h			; align	2
ERRORMODE	db 0			; ...
					; SWAP_START
INDOS		db 0			; ...
WPERR		db -1			; ...
EXTERR_LOCUS	db 0			; ...
EXTERR		dw 0			; ...
EXTERR_ACTION	db 0			; ...
EXTERR_CLASS	db 0			; ...
EXTERRPT	dd 0			; ...
DMAADD		dd 80h			; ...
CurrentPDB	dw 0			; ...
ConC_Spsave	dw 0			; ...
exit_code	dw 0			; ...
CURDRV		db 0			; ...
CNTCFLAG	db 0			; ...
CPSWFLAG	db 0
CPSWSAVE	db 0
USER_IN_AX	dw 0			; ...
					; SWAP_ALWAYS
PROC_ID		dw 0			; ...
USER_ID		dw 0			; ...
FirstArena	dw 0			; ...
BestArena	dw 0			; ...
LastArena	dw 0			; ...
ENDMEM		dw 0			; ...
LASTENT		dw 0			; ...
FAILERR		db 0			; ...
ALLOWED		db 0			; ...
NoSetDir	db 0			; ...
DidCTRLC	db 0			; ...
SpaceFlag	db 0			; ...
		db 90h			; align	2
DAY		db 0			; ...
MONTH		db 0			; ...
YEAR		dw 0			; ...
DAYCNT		dw 0FFFFh		; ...
WEEKDAY		db 0			; ...
CONSWAP		db 0			; ...
IDLEINT		db 1			; ...
fAborting	db 0			; ...
DEVCALL		dw 0			; ...
DEVCALL_REQFUNC	db 0			; ...
DEVCALL_REQSTAT	dw 0			; ...
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
CALLMED		db 0			; ...
CALLXADD	db 0,0,0,0		; ...
CALLSCNT	dw 0			; ...
CALLSSEC	dw 0			; ...
CALLVIDRW	dd 0			; ...
CALLNEWSC	dd 0			; ...
CALLDEVAD	dd 0			; ...
IOCALL_REQLEN	db 0			; ...
					; IOCALL
IOCALL_REQUNIT	db 0			; ...
IOCALL_REQFUNC	db 0			; ...
IOCALL_REQSTAT	db 2 dup(0)		; ...
		db 8 dup(0)
IOCTL_REQ_MAJORFUNCTION	db 0		; ...
IOCTL_REQ_MINORFUNCTION	db 0		; ...
IOCTL_REQ_REG_SI db 0			; ...
IOCTL_IOXAD_2	db 0			; ...
IOCTL_REQ_REG_DI db 0			; ...
IOCTL_IOSCNT	db 0			; ...
IOCTL_REQ_GENERICIOCTL_PACKET dw 0	; ...
IOCTL_REQ_GENERICIOCTL_PACKET_2	db 0	; ...
DSKSTCALL	db 14			; ...
					; DRDNDHL
		db 0
DSKSTCOM	db 5			; ...
					; DEVRDND
DSKSTST		dw 0			; ...
		db 8 dup(0)
DSKCHRET	db 0			; ...
DSKCHRET_1	dw offset DEVIOBUF	; ...
DSKCHRET_3	dw 0			; ...
DSKSTCNT	dw 1			; ...
		dw 0
CreatePDB	db 0			; ...
Lock_Buffer	db 8 dup(0)		; ...
		db  90h	; 
USERNUM		dd 0FF000000h		; ...
TIMEBUF		dw 3 dup(0)		; ...
DEVIOBUF	dw 0			; ...
OPENBUF		db 128 dup(0)		; ...
RENBUF		db 128 dup(0)		; ...
SEARCHBUF	db 53 dup(0)		; ...
DUMMYCDS	db 88 dup(0)		; ...
NAME1		db 12 dup(0)		; ...
NAME2		db 13 dup(0)		; ...
DESTSTART	dw 0			; ...
		db 5 dup(0)
ATTRIB		db 0			; ...
EXTFCB		db 0			; ...
SATTRIB		db 0			; ...
OPEN_ACCESS	db 0			; ...
FOUNDDEL	db 0			; ...
FOUND_DEV	db 0			; ...
FSPLICE		db 0			; ...
FSHARING	db 0			; ...
SECCLUSPOS	db 0			; ...
TRANS		db 0			; ...
READOP		db 0			; ...
THISDRV		db 0			; ...
CLUSFAC		db 0			; ...
CLUSSPLIT	db 0			; ...
INSMODE		db 0			; ...
CMETA		db 0			; ...
VOLID		db 0			; ...
EXIT_TYPE	db 0			; ...
		db 90h
CREATING	db 0			; ...
DELALL		db 0			; ...
EXITHOLD	dd 0			; ...
USER_SP		dw 0			; ...
USER_SS		dw 0			; ...
CONTSTK		dw 0			; ...
THISDPB		dd 0			; ...
CLUSSAVE	dw 0			; ...
CLUSSEC		dd 0			; ...
PREREAD		dw 0			; ...
FATBYT		dw 0			; ...
FATBYTE		db 0			; ...
		db 0
DEVPT		dd 0			; ...
THISSFT		dd 0			; ...
THISCDS		dd 0			; ...
THISFCB		dd 0			; ...
SFN		dw 0FFFFh		; ...
JFN		dw 0			; ...
PJFN		dd 0			; ...
WFP_START	dw 0			; ...
REN_WFP		dw 0			; ...
CURR_DIR_END	dw 0			; ...
NEXTADD		dw 0			; ...
LASTPOS		dw 0			; ...
CLUSNUM		dw 0			; ...
DIRSEC		dd 0			; ...
DIRSTART	dw 0			; ...
SECPOS		dd 0			; ...
VALSEC		dd 0			; ...
BYTSECPOS	dw 0			; ...
BYTPOS		dd 0			; ...
BYTCNT1		dw 0			; ...
BYTCNT2		dw 0			; ...
SECCNT		dw 0			; ...
ENTFREE		dw 0			; ...
ENTLAST		dw 0			; ...
NXTCLUSNUM	dw 0			; ...
GROWCNT		dd 0			; ...
CURBUF		dd 0			; ...
CONSFT		dd 0			; ...
SAVEBX		dw 0			; ...
SAVEDS		dw 0			; ...
RESTORE_TMP	dw 0			; ...
NSS		dw 0			; ...
NSP		dw 0			; ...
EXTOPEN_FLAG	dw 0			; ...
EXTOPEN_ON	db 0			; ...
EXTOPEN_IO_MODE	dw 0			; ...
SAVE_DI		dw 0			; ...
SAVE_ES		dw 0			; ...
SAVE_DX		dw 0			; ...
SAVE_CX		dw 0			; ...
SAVE_BX		dw 0			; ...
SAVE_SI		dw 0			; ...
SAVE_DS		dw 0			; ...
HIGH_SECTOR	dw 0			; ...
		dw 0
DISK_FULL	db 0			; ...
TEMP_VAR	dw 0			; ...
TEMP_VAR2	dw 0			; ...
DrvErr		db 0			; ...
DOS34_FLAG	dw 0			; ...
		db 8 dup(0)
AbsRdWr_SS	dw 0			; ...
AbsRdWr_SP	dw 0			; ...
		db    0
RENAMEDMA	db 384 dup(0)		; ...
AUXSTACK	db 384 dup(0)		; ...
DSKSTACK	db 384 dup(0)		; ...
PRINTER_FLAG	db 0			; ...
					; IOSTACK
VOLCHNG_FLAG	db 0			; ...
VIRTUAL_OPEN	db 0			; ...
FSeek_drive	db 0
FSeek_firclus	dw 0
FSeek_logclus	dw 0
FSeek_logsave	dw 0
TEMP_DOSLOC	dw -1			; ...
SWAP_END	db 0			; ...
UCASE_TAB	dw 128			; ...
UCASE_TAB_2	db 128,154,069,065,142,065,143,128 ; ...
		db 069,069,069,073,073,073,142,143
		db 144,146,146,079,153,079,085,085
		db 089,153,154,155,156,157,158,159
		db 065,073,079,085,165,165,166,167
		db 168,169,170,171,172,173,174,175
		db 176,177,178,179,180,181,182,183
		db 184,185,186,187,188,189,190,191
		db 192,193,194,195,196,197,198,199
		db 200,201,202,203,204,205,206,207
		db 208,209,210,211,212,213,214,215
		db 216,217,218,219,220,221,222,223
		db 224,225,226,227,228,229,230,231
		db 232,233,234,235,236,237,238,239
		db 240,241,242,243,244,245,246,247
		db 248,249,250,251,252,253,254,255
FILE_UCASE_TAB	dw 128			; ...
FILE_UCASE_TAB_2 db 128,154,069,065,142,065,143,128 ; ...
		db 069,069,069,073,073,073,142,143
		db 144,146,146,079,153,079,085,085
		db 089,153,154,155,156,157,158,159
		db 065,073,079,085,165,165,166,167
		db 168,169,170,171,172,173,174,175
		db 176,177,178,179,180,181,182,183
		db 184,185,186,187,188,189,190,191
		db 192,193,194,195,196,197,198,199
		db 200,201,202,203,204,205,206,207
		db 208,209,210,211,212,213,214,215
		db 216,217,218,219,220,221,222,223
		db 224,225,226,227,228,229,230,231
		db 232,233,234,235,236,237,238,239
		db 240,241,242,243,244,245,246,247
		db 248,249,250,251,252,253,254,255
FILE_CHAR_TAB	dw 22			; ...
		db 1, 0, 255
		db 0, 0, 20h
		db 2, 14
		db '."/\[]:|<>+=;,'
		db 24 dup(0)
COLLATE_TAB	dw 256			; ...
		db 0, 1, 2, 3, 4, 5, 6,	7
		db 8, 9, 10, 11, 12, 13, 14, 15
		db 16, 17, 18, 19, 20, 21, 22, 23
		db 24, 25, 26, 27, 28, 29, 30, 31
		db ' ', '!', '"', '#', '$', '%', '&'
		db 27h
		db '(', ')', '*', '+', ',', '-', '.', '/'
		db '0', '1', '2', '3', '4', '5', '6', '7'
		db '8', '9', ':', ';', '<', '=', '>', '?'
		db '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G'
		db 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O'
		db 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W'
		db 'X', 'Y', 'Z', '[', '\', ']', '^', '_'
		db '`', 'A', 'B', 'C', 'D', 'E', 'F', 'G'
		db 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O'
		db 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W'
		db 'X', 'Y', 'Z', '{', '|', '}', '~', ''
		db 'C', 'U', 'E', 'A', 'A', 'A', 'A', 'C'
		db 'E', 'E', 'E', 'I', 'I', 'I', 'A', 'A'
		db 'E', 'A', 'A', 'O', 'O', 'O', 'U', 'U'
		db 'Y', 'O', 'U', '$', '$', '$', '$', '$'
		db 'A', 'I', 'O', 'U', 'N', 'N'
		db 166,	167
		db '?'
		db 169,	170, 171, 172
		db '!', '"', '"'
		db 176,	177, 178, 179, 180, 181, 182, 183
		db 184,	185, 186, 187, 188, 189, 190, 191
		db 192,	193, 194, 195, 196, 197, 198, 199
		db 200,	201, 202, 203, 204, 205, 206, 207
		db 208,	209, 210, 211, 212, 213, 214, 215
		db 216,	217, 218, 219, 220, 221, 222, 223
		db 224
		db 'S'
		db 226,	227, 228, 229, 230, 231, 232, 233
		db 234,	235, 236, 237, 238, 239, 240, 241
		db 242,	243, 244, 245, 246, 247, 248, 249
		db 250,	251, 252, 253, 254, 255
DBCS_TAB	dw 9 dup(0)		; ...
; ---------------------------------------------------------------------------

MAP_CASE:				; ...
		cmp	al, 80h
		jnb	short Map1
		retf
; ---------------------------------------------------------------------------

Map1:					; ...
		sub	al, 80h
		push	ds
		push	bx
		mov	bx, offset UCASE_TAB_2 ; UCASE_TAB+2
		push	cs
		pop	ds
		xlat
		pop	bx
		pop	ds
		retf
; ---------------------------------------------------------------------------
InterChar	db 0
InterCon	db 0
SaveCurFlg	db 0
TEMPSEG		dw 0			; ...
redir_patch	db 0			; ...
		db 5 dup(0)
		db 5
		db 0
YRTAB		db 200,	166		; ...
		db 200,	165
		db 200,	165
		db 200,	165
MONTAB		db 31			; ...
february	db 28			; ...
		db 31
		db 30
		db 31
		db 30
		db 31
		db 31
		db 30
		db 31
		db 30
		db 31
SysInitTable	dw offset SYSINITVARS	; ...
		dw 0
		dw offset COUNTRY_CDPG
		dw 0
FastOpenTable	dw 2			; ...
FastOpenTable_2	dw offset FastRet	; ...
		dw 0
		dw offset FastRet
		dw 0
FastOpenFlg	db 0			; ...
FastOpen_Ext_Info db 11	dup( 0)		; ...
Dir_Info_Buff	db 32 dup( 0)		; ...
Next_Element_Start dw 0			; ...
Del_ExtCluster	dw 0
USER_SP_2F	dw offset FAKE_STACK_2F	; ...
FAKE_STACK_2F	dw 14 dup(0)		; ...
					; DOS_TEMP
Hash_Temp	dw 4 dup(0)
SCAN_FLAG	db 0			; ...
DATE_FLAG	dw 0			; ...
FETCHI_TAG	dw 0			; OBSOLETE
MSG_EXTERROR	dd 0
		dd 0
		dd 0
		dd 0
		dd 0
SEQ_SECTOR	dd -1			; ...
SC_SECTOR_SIZE	dw 0			; ...
SC_DRIVE	db 0			; ...
CurSC_DRIVE	db -1			; ...
CurSC_SECTOR	dd 0			; ...
SC_STATUS	dw 0			; ...
SC_FLAG		db 0			; ...
AbsDskErr	dw 0			; ...
NO_NAME_ID	db 'NO NAME    '        ; ...
LOOKSIZ		db 0
; ---------------------------------------------------------------------------

SNULDEV:				; ...
		or	word ptr es:[bx+3], 100h ; [es:bx+SRHEAD.REQSTAT],
					; STDON

INULDEV:				; ...
		retf
; ---------------------------------------------------------------------------
WinoldPatch2	db 8 dup(0)		; ...
UmbSave2	db 5 dup(0)		; ...
UmbSaveFlag	db 0			; ...
ERR_TABLE_21	db 1, 7, 4, 0FFh	; ...
		db 2, 8, 3, 2
		db 3, 8, 3, 2
		db 4, 1, 4, 1
		db 5, 3, 3, 0FFh
		db 6, 7, 4, 1
		db 7, 7, 5, 5
		db 8, 1, 4, 5
		db 9, 7, 4, 5
		db 0Ah,	7, 4, 5
		db 0Bh,	9, 3, 1
		db 0Ch,	7, 4, 1
		db 0Dh,	9, 4, 1
		db 0Fh,	8, 3, 2
		db 10h,	3, 3, 2
		db 11h,	0Dh, 3,	2
		db 12h,	8, 3, 2
		db 50h,	0Ch, 3,	2
		db 20h,	0Ah, 2,	2
		db 21h,	0Ah, 2,	2
		db 54h,	1, 4, 0FFh
		db 56h,	3, 3, 1
		db 52h,	1, 4, 2
		db 32h,	9, 3, 3
		db 55h,	0Ch, 3,	3
		db 57h,	9, 3, 1
		db 53h,	0Dh, 4,	1
		db 24h,	1, 4, 5
		db 26h,	1, 4, 1
		db 27h,	1, 4, 1
		db 5Ah,	0Dh, 4,	2
		db 0FFh, 0FFh, 0FFh, 0FFh
ERR_TABLE_24	db 13h,	0Bh, 7,	2	; ...
		db 14h,	4, 5, 1
		db 15h,	5, 7, 0FFh
		db 16h,	4, 5, 1
		db 17h,	0Bh, 4,	2
		db 18h,	4, 5, 1
		db 19h,	5, 1, 2
		db 1Ah,	0Bh, 7,	2
		db 1Bh,	0Bh, 4,	2
		db 1Ch,	2, 7, 4
		db 1Dh,	5, 4, 0FFh
		db 1Eh,	5, 4, 0FFh
		db 1Fh,	0Dh, 4,	0FFh
		db 20h,	0Ah, 2,	2
		db 21h,	0Ah, 2,	2
		db 22h,	0Bh, 7,	2
		db 32h,	9, 3, 3
		db 23h,	7, 4, 1
		db 24h,	1, 4, 5
		db 0FFh, 0Dh, 5, 0FFh
ErrMap24	db 13h,	14h, 15h, 16h, 17h, 18h, 19h, 1Ah ; ...
		db 1Bh,	1Ch, 1Dh, 1Eh, 1Fh, 1Fh, 1Fh, 22h
FIRST_BUFF_ADDR	dw 0			; ...
SPECIAL_VERSION	dw 0			; ...
FAKE_COUNT	db 255 dup(0)
OLD_FIRSTCLUS	dw 0			; ...
exec_init_SP	dw 0			; ...
exec_init_SS	dw 0			; ...
exec_init_IP	dw 0			; ...
exec_init_CS	dw 0			; ...
exec_signature	dw 0			; ...
exec_len_mod_512 dw 0
exec_pages	dw 0			; ...
exec_rle_count	dw 0			; ...
exec_par_dir	dw 0			; ...
exec_min_BSS	dw 0			; ...
exec_max_BSS	dw 0			; ...
exec_SS		dw 0			; ...
exec_SP		dw 0			; ...
exec_chksum	dw 0
exec_IP		dw 0			; ...
exec_CS		dw 0
exec_rle_table	dw 0			; ...
Win386_Info	db 3, 13 dup(0)		; ...
		dw offset Instance_Table
Win386_Info_16	dw 0			; ...
Instance_Table	dw offset CONTPOS	; ...
Instance_Table_2 dw 0			; ...
		dw 2
		dw offset BCON
		dw 0
		dw 4
		dw offset CARPOS
		dw 0
		dw 106h
		dw offset CHARCO
		dw 0
		dw 1
		dw offset exec_init_SP
		dw 0
		dw 22h
		dw offset UMBFLAG
		dw 0
		dw 1
		dw offset UMB_HEAD
		dw 0
		dw 2
		dw 0
		dw 0
Win386_DOSVars	db 5			; ...
					; Major	version	5
		db 0			; Minor	version	0
		dw offset SAVEDS
		dw offset SAVEBX
		dw offset INDOS
		dw offset USER_ID
		dw offset CritPatch
		dw offset UMB_HEAD
IsWin386	db 0			; ...
VxDpath		db 'c:\wina20.386',0    ; ...
DriverLoad	db 1			; ...
BiosDataPtr	dd 0			; ...
		db 36h,	0F6h, 6, 20h, 3, 0FFh ;	Patch for Sidekick
		db 75h,	0Ch
		db 36h,	0FFh, 36h, 58h,	3
		db 0CDh, 28h
		db 80h,	3Eh, 20h, 3, 0	; Patch	for PortOfEntry
		db 75h,	37h
		db 0BCh, 0A0h, 0Ah
LocalSFT	dd 0			; ...
		db 90h			; align	2
DOSINTTABLE	dw offset DIVOV		; ...
		dw 0
DOSINTTABLE_4	dw offset QUIT		; ...
		dw 0
DOSINTTABLE_8	dw offset COMMAND	; ...
		dw 0
DOSINTTABLE_12	dw offset ABSDRD	; ...
		dw 0
DOSINTTABLE_16	dw offset ABSDWRT	; ...
		dw 0
DOSINTTABLE_20	dw offset STAY_RESIDENT	; ...
		dw 0
DOSINTTABLE_24	dw offset INT2F		; ...
		dw 0
DOSINTTABLE_28	dw offset CALL_ENTRY	; ...
		dw 0
		dw offset IRETT
		dw 0
SS_Save		dw 0			; ...
SP_Save		dw 0			; ...
; ---------------------------------------------------------------------------

ldivov:					; ...
		jmp	short divov_cont ; i0patch
; ---------------------------------------------------------------------------
		call	EnsureA20ON

divov_cont:				; ...
		jmp	dword ptr cs:DOSINTTABLE
; ---------------------------------------------------------------------------

lquit:					; ...
		jmp	short quit_cont	; i20patch
; ---------------------------------------------------------------------------
		call	EnsureA20ON

quit_cont:				; ...
		jmp	dword ptr cs:DOSINTTABLE_4
; ---------------------------------------------------------------------------

lcommand:				; ...
		jmp	short command_cont ; i21patch
; ---------------------------------------------------------------------------
		call	EnsureA20ON

command_cont:				; ...
		jmp	dword ptr cs:DOSINTTABLE_8
; ---------------------------------------------------------------------------

labsdrd:				; ...
		jmp	short absdrd_cont ; i25patch
; ---------------------------------------------------------------------------
		call	EnsureA20ON

absdrd_cont:				; ...
		jmp	dword ptr cs:DOSINTTABLE_12
; ---------------------------------------------------------------------------

labsdwrt:				; ...
		jmp	short absdwrt_cont ; i26patch
; ---------------------------------------------------------------------------
		call	EnsureA20ON

absdwrt_cont:				; ...
		jmp	dword ptr cs:DOSINTTABLE_16
; ---------------------------------------------------------------------------

lstay_resident:				; ...
		jmp	short sr_cont	; i27patch
; ---------------------------------------------------------------------------
		call	EnsureA20ON

sr_cont:				; ...
		jmp	dword ptr cs:DOSINTTABLE_20
; ---------------------------------------------------------------------------

lint2f:					; ...
		jmp	short int2f_cont ; i2fpatch
; ---------------------------------------------------------------------------
		call	EnsureA20ON

int2f_cont:				; ...
		jmp	dword ptr cs:DOSINTTABLE_24
; ---------------------------------------------------------------------------

lcall_entry:				; ...
		jmp	short callentry_cont ; cpmpatch
; ---------------------------------------------------------------------------
		call	EnsureA20ON

callentry_cont:				; ...
		jmp	dword ptr cs:DOSINTTABLE_28
; ---------------------------------------------------------------------------

lirett:					; ...
		iret
; ---------------------------------------------------------------------------
DosRetAddr23	dd 0			; ...
DosRetAddr24	dd 0			; ...
DosRetAddr28	dd 0
; ---------------------------------------------------------------------------

LowInt23:				; ...
		pop	word ptr cs:DosRetAddr23
		pop	word ptr cs:DosRetAddr23+2
		int	23h		; DOS -	CONTROL	"C" EXIT ADDRESS
					; Return: return via RETF 2 with CF set
					; DOS will abort program with errorlevel 0
					; else
					; interrupted DOS call continues
		call	EnsureA20ON
		jmp	cs:DosRetAddr23
; ---------------------------------------------------------------------------

LowInt24:				; ...
		pop	word ptr cs:DosRetAddr24
		pop	word ptr cs:DosRetAddr24+2
		int	24h		; DOS -	FATAL ERROR HANDLER ADDRESS
					; Automatically	called upon detection of unrecoverable I/O error.
		call	EnsureA20ON
		jmp	cs:DosRetAddr24
; ---------------------------------------------------------------------------

LowInt28:				; ...
		int	28h		; DOS 2+ internal - KEYBOARD BUSY LOOP
		call	EnsureA20ON
		retf
; ---------------------------------------------------------------------------

disa20_xfer:				; ...
		call	XMMDisableA20
		cli
		mov	cs:INDOS, 0
		mov	ss, ax
		mov	sp, di
		sti
		push	ds
		push	si
		mov	es, dx
		mov	ds, dx
		mov	ax, bx
		retf
; ---------------------------------------------------------------------------

disa20_iret:				; ...
		call	XMMDisableA20
		dec	byte ptr ds:321h
		mov	ss, word ptr ds:586h
		mov	sp, ds:584h
		mov	bp, sp
		mov	[bp+0],	al
		mov	ax, ds:5F2h
		mov	ds:584h, ax
		mov	ax, ds:5F0h
		mov	ds:586h, ax
		pop	ax
		pop	bx
		pop	cx
		pop	dx
		pop	si
		pop	di
		pop	bp
		pop	ds
		pop	es
		iret

; =============== S U B	R O U T	I N E =======================================


XMMDisableA20	proc near		; ...
		push	bx
		push	ax
		mov	ah, 6
		call	cs:XMMcontrol
		pop	ax
		pop	bx
		retn
XMMDisableA20	endp

; ---------------------------------------------------------------------------
XMMcontrol	dd 0			; ...
LowMemory	dd 80h			; ...
HighMemory	dd 0FFFF0090h		; ...

; =============== S U B	R O U T	I N E =======================================


EnsureA20ON	proc near		; ...
		pushf
		push	ds
		push	es
		push	cx
		push	si
		push	di
		lds	si, cs:LowMemory
		les	di, cs:HighMemory
		mov	cx, 4
		cld
		repe cmpsw
		jz	short EA20_OFF

EA20_RET:				; ...
		pop	di
		pop	si
		pop	cx
		pop	es
		pop	ds
		popf
		retn
; ---------------------------------------------------------------------------

EA20_OFF:				; ...
		push	bx
		push	ax
		mov	ax, ss
		mov	cs:SS_Save, ax
		mov	cs:SP_Save, sp
		mov	ax, cs
		mov	ss, ax
		mov	sp, offset AUXSTACK
		mov	ah, 5		; XMM_LOCAL_ENABLE_A20
		call	cs:XMMcontrol
		or	ax, ax
		jz	short XMMerror
		mov	ax, cs:SS_Save
		mov	ss, ax
		mov	sp, cs:SP_Save
		pop	ax
		pop	bx
		jmp	short EA20_RET
; ---------------------------------------------------------------------------

XMMerror:				; ...
		mov	ah, 0Fh
		int	10h		; - VIDEO - SELECT DISPLAY PAGE
					; AL = display page, 0-7  for modes 0 &	1, 0-3	for modes 2 & 3
		cmp	al, 7
		jz	short XMMcont
		xor	ah, ah
		mov	al, 2
		int	10h		; - VIDEO -

XMMcont:				; ...
		mov	ah, 5
		xor	al, al
		int	10h		; - VIDEO - WRITE CHARACTER AND	ADVANCE	CURSOR (TTY WRITE)
					; AL = character, BH = display page (alpha modes)
					; BL = foreground color	(graphics modes)
		mov	si, offset XMMERRMSG ; "\r\nA20	Hardware Error\r\n$"
		push	cs
		pop	ds
		cld

XMMprnt:				; ...
		lodsb
		cmp	al, '$'
		jz	short XMMStall
		mov	ah, 0Eh
		mov	bx, 7
		int	10h		; - VIDEO -
		jmp	short XMMprnt
; ---------------------------------------------------------------------------

XMMStall:				; ...
		sti
		jmp	short XMMStall
EnsureA20ON	endp

; ---------------------------------------------------------------------------
OldInstanceJunk	dw 70h			; ...
		dw 0
		dw 6
OldInstanceJunk_6 dw 0			; ...
		dw offset CONTPOS
		dw 2
		dw 0
		dw offset BCON
		dw 4
		dw 0
		dw offset CARPOS
		dw 106h
		dw 0
		dw offset CHARCO
		dw 1
		dw 0
		dw offset exec_init_SP
		dw 34
		dw 70h
		dw 0Ch			; DOSBIODATASEG:ALTAH
		dw 1
DosHasHMA	db 0			; ...
FixExePatch	dw 0			; ...
RationalPatchPtr dw 0			; ...
; ---------------------------------------------------------------------------

RatBugCode:				; ...
		push	cx
		mov	cx, FCBLRU	; [10h]

rbc_loop:				; ...
		loop	rbc_loop
		pop	cx
		retf
; ---------------------------------------------------------------------------
UmbSave1	db 11 dup(0)		; ...
COUNTRY_CDPG	db 0, 0, 0, 0, 0, 0, 0,	0 ; ...
		db '\COUNTRY.SYS',0
		db 51 dup(0)
		dw 437
		dw 6
COUNTRY_CDPG_76	db 2			; ...
		dw offset UCASE_TAB
		dw 0
		db 4
		dw offset FILE_UCASE_TAB
		dw 0
		db 5
		dw offset FILE_CHAR_TAB
		dw 0
		db 6
		dw offset COLLATE_TAB
		dw 0
		db 7
		dw offset DBCS_TAB
		dw 0
		db 1
		dw 38			; NEW_COUNTRY_SIZE
		dw 1
		dw 437
COUNTRY_CDPG_108 dw 0			; ...
		db '$',0,0,0,0
		db ',',0,'.',0,'-',0,':',0
		db 0
		db 2
		db 0
		dw offset MAP_CASE
		dw 0
		db ',',0
		dw 0, 0, 0, 0, 0
XMMERRMSG	db 0Dh,0Ah		; ...
		db 'A20 Hardware Error',0Dh,0Ah,'$'
DOSP1_ID	db 36h,	0C5h, 36h
DOSP1_THISSFT	db 36h,	5, 0C5h, 74h, 7, 0E8h
		db 90h
		db 90h
DOSP12_ID	db 36h,	0C5h, 36h
DOSP12_THISSFT	db 36h,	5, 0C5h, 74h, 7, 0E8h
DOSP3_ID	db 51h,	6, 57h,	0BAh
DOSP3_CONBUF	db 29h,	2, 0E8h
		db 9Ah,	0E3h, 5Fh, 7
		db 59h
DOSP5_ID	db 51h
		db 0ACh, 3Ch, 1Ah, 74h,	5
		db 0E8h
DOSP7_ID	db 2Eh,	8Ch, 1Eh
DOSP7_SAVEDS	db 7Eh,	5
		db 2Eh,	89h, 1Eh
DOSP7_SAVEBX	db 7Ch,	5
		db 8Ch,	0CBh
		db 8Eh,	0DBh
		db 0FEh, 6
DOSP7_INDOS	db 0CFh, 2
		db 33h,	0C0h
DOSP8_ID	db 50h
		db 36h,	0A1h
DOSP8_USER_ID	db 0EAh, 2
		db 26h,	3Bh, 45h
		db 2Fh,	58h
DOSP10_ID	db 6, 1Fh
DOSP10_LOC	db 8Bh,	0DFh
		db 33h,	0C0h, 8Bh, 0D0h, 0E8h
		db 0DFh, 0Eh
		db 1Eh,	36h, 0C5h, 36h,	36h, 5,	0E8h, 0AFh, 0Eh
		db 8Bh,	0D7h, 0B4h, 86h, 36h, 8Bh, 3Eh
		db 9, 3
		db 0F7h, 0C7h, 0, 80h, 74h, 19h, 0E8h, 47h, 17h
		db 8Bh,	0FAh, 0Ah, 0C0h, 74h, 10h, 3Ch,	3, 74h,	3
		db 1Fh,	0EBh, 0CFh
		db 5Fh
		db 36h,	0C4h, 3Eh, 36h,	5, 0E9h, 0A1h, 4
		db 5Fh,	8Bh, 0FAh
DOSP13_ID	db 0ACh
		db 3Ch,	24h
		db 74h,	8
		db 0B3h, 7
		db 0B4h, 0Eh
		db 0CDh, 10h
		db 0EBh, 0F3h
		db 0EBh, 0FEh
DOSDATA		ends


		end
