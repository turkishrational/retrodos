;*****************************************************************************
; MSDOS6.BIN (MSDOS 6.0 Kernel) - RETRO DOS v4.0 by ERDOGAN TAN - 03/11/2022
; ----------------------------------------------------------------------------
; Last Update: 07/02/2024 - Retro DOS v4.2 ((Previous: 29/09/2023))
; ----------------------------------------------------------------------------
; Beginning: 07/07/2018 (Retro DOS 3.0), 22/04/2019 (Retro DOS 4.0)
; ----------------------------------------------------------------------------
; Assembler: NASM version 2.15
; ----------------------------------------------------------------------------
;	   ((nasm msdos6.s -l msdos6.lst -o MSDOS6.BIN -Z error.txt)) 	
; ----------------------------------------------------------------------------
; Modified from 'msdos3.s' file of Retro DOS 3.0 source code (10/09/2018)
; ----------------------------------------------------------------------------
; Derived from 'msdos2.s' file of Retro DOS 2.0 source code (04/05/2018)
; ----------------------------------------------------------------------------
; Derived from 'MSCODE.ASM' file of MSDOS 2.0 (IBM PCDOS v2.0) source code
; by Microsoft, 25/08/1983 (DOSLINK - 'MSDOS.ASM')
;*****************************************************************************
; main file: 'retrodos4.s'
; incbin 'MSDOS5.BIN'
;=============================================================================
; Modified from 'msdos6.s' (modified MSDOS 6.21 kernel src as Retro DOS v4.0)
; 28/07/2019  /// Retro DOS v4.0 (2022) -> Modified MSDOS 5.0 IO.SYS+MSDOS.SYS
;=============================================================================

; 30/12/2022 - Retro DOS v4.2 Kernel ('msdos6.s')
; Modified from 'msdos5.s' (29/12/2022, Retro DOS v4.1 Kernel) file
; as below:
;	1) MS-DOS version has been changed to 6.22 (It was 5.0) 
;	2) Retro DOS version has been changed to 4.2 (It was 4.1)
; (The content has not been changed except kernel version because the kernel
;  code is already compatible with MSDOS 6.x and it is optimized before.)
;	(But IO.SYS part of the kernel is not same with Retro DOS v4.1 code.)	

; ----------------------------------------------------------------------------

; 03/11/2022 - Erdogan Tan (Istanbul)

; Note:	This code is a part of Retro DOS 4.0 kernel source code
;	(as included binary, 'MSDOS5.BIN') 
;	Equivalent of MSDOS 5.0 MSDOS.SYS kernel file 
;	
;	((MSDOS 6.0 kernel source code has been modified by using disassembled
;	MSDOS 5.0 MSDOS.SYS)) -- Disassembler: HEX-RAYS IDA Pro --
;	((Disassembly -Reverse engineering- reference: MSDOS 6.0 kernel src))
      
;------ Retro DOS v2 (v3) boot sector loads RETRODOS.SYS (MSDOS.SYS)
;	at 1000h:0000h and loader (initialization) part of RETRODOS kernel
;	moves IO.SYS (DOSBIOSCODE & DOSBIOSDATA, 'IOSYS5.BIN') to 70h:0000h.
;	Then SYSINIT code to the next segment (4D6h for current version)..
;	SYSINIT code relocates itself and DOSBIOSCODE and MSDOS.SYS
;	(MSDOS5.BIN) according to request/setting in 'config.sys' file.

;=============================================================================
; Most of comments in this file are from the original MSDOS 6.0 source code
;-----------------------------------------------------------------------------

; MSDOS 6.0 Kernel source files:
;	MSDATA.ASM, 
; 		(MSHEAD.ASM, MSCONST.ASM,CONST2.ASM, MS_DATA.ASM,
;		DOSTAB.ASM, LMSTUB.ASM, WPATCH.INC, MPATCH.ASM)
;	MSTABLE.ASM, MSCODE.ASM, MSDOSME.ASM (DOSMES.INC), TIME.ASM,
;	GETSET.ASM, PARSE.ASM, MISC.ASM, MISC2.ASM, CRIT.ASM, CPMIO.ASM,
;	CPMIO2.ASM, FCBIO.ASM, FCBIO2.ASM, SEARCH.ASM, PATH.ASM, IOCTL.ASM,
;	DELETE.ASM, RENAME.ASM, FINFO.ASM, DUP.ASM, CREATE.ASM, OPEN.ASM,
;	DINFO.ASM, ISEARCH.ASM, BUF.ASM, ABORT.ASM,CLOSE.ASM, DIRCALL.ASM,
;	DISK.ASM, DISK2.ASM, DISK3.ASM, DIR.ASM, DIR2.ASM, DEV.ASM,
;	MKNODE.ASM, ROM.ASM, FCB.ASM, MSCTRLC.ASM, FAT.ASM, MSPROC.ASM
;	ALLOC.ASM, SRVCALL.ASM, UTIL.ASM, MACRO.ASM, MACRO2.ASM, HANDLE.ASM
;	FILE.ASM, LOCK.ASM, ROMFIND.ASM, SHARE.ASM, MSINIT.ASM, ORIGIN.ASM
;
; MSDOS 2.0 Kernel source files:
; 	MSDOS.ASM (STDSW.ASM + MSHEAD.ASM + MSDATA.ASM)
;	MSCODE.ASM
;	DOSMES.ASM ... STDIO.ASM, TIME.ASM, XENIX.ASM, XENIX2.ASM

;============================================================================
; DOSLINK
;============================================================================
;msdos mscode dosmes misc getset dircall alloc dev dir +
;disk fat rom stdbuf stdcall stdctrlc stdfcb stdproc +
;stdio time xenix xenix2

;============================================================================
; This MSDOS source code is verified & modified by using IDA Pro Disassembler
; output in TASM syntax (July 2018 -> NASM syntax) [ IBMDOS.COM, 17/03/1987 ]
;============================================================================
;
; ###########################################################################
; #	This file is generated by The Interactive Disassembler (IDA)	    #
; #	Copyright (c) 2010 by Hex-Rays SA, <support@hex-rays.com>	    #
; #			 Licensed to: Freeware version			    #
; ###########################################################################
;
; Input	MD5   :	75959BC417C19135B982F7959EE9C92A

; ---------------------------------------------------------------------------
; File Name   :	C:\Documents and Settings\Erdoðan Tan\Desktop\MSDOS621.BIN
; Format      :	Binary file
;============================================================================
; MSDOS621.BIN = MSDOS.SYS, 13/02/1994, 38138 bytes (MSDOS 6.21 kernel) 2019
;----------------------------------------------------------------------------
; MSDOS5.BIN = MSDOS.SYS, 11/11/1991, 37394 bytes (MSDOS 5.0 kernel) 2022

;============================================================================
; MSDOS.ASM
;============================================================================

;TITLE   Standard MSDOS
;NAME    MSDOS_2

; Number of disk I/O buffers

;	INCLUDE STDSW.ASM
;       INCLUDE MSHEAD.ASM
;       INCLUDE MSDATA.ASM

;	END

;============================================================================
; STDSW.ASM
;============================================================================

TRUE    EQU     0FFFFH
FALSE   EQU     ~TRUE ; NOT TRUE

; Use the switches below to produce the standard Microsoft version or the IBM
; version of the operating system
;MSVER   EQU	false
;IBM     EQU	true
;WANG    EQU	FALSE
;ALTVECT EQU	FALSE

; Set this switch to cause DOS to move itself to the end of memory
;HIGHMEM EQU     FALSE

;	IF      IBM
ESCCH    EQU	 0			;character to begin escape seq.
CANCEL   EQU	 27			;Cancel with escape
TOGLINS  EQU	TRUE			;One key toggles insert mode
TOGLPRN  EQU	TRUE			;One key toggles printer echo
ZEROEXT  EQU	TRUE
;       ELSE
;       IF      WANG			;Are we assembling for WANG?
;ESCCH	 EQU	1FH			;Yes. Use 1FH for escape character
;       ELSE
;ESCCH	 EQU	1BH
;       ENDIF
;CANCEL  EQU	"X"-"@"			;Cancel with Ctrl-X
;TOGLINS EQU	WANG			;Separate keys for insert mode on
					;and off if not WANG
;TOGLPRN EQU	FALSE			;Separate keys for printer echo on
					;and off
;ZEROEXT EQU	TRUE
;        ENDIF

;============================================================================
; MSHEAD.ASM
;============================================================================

;--------------------------------------------------------------
; TITLE   MSHEAD.ASM -- MS-DOS DEFINITIONS
;--------------------------------------------------------------

; MS-DOS High-performance operating system for the 8086  version 1.28
;        by Microsoft MSDOS development group:
;           Tim Paterson (Ret.)
;           Aaron Reynolds
;           Nancy Panners (Parenting)
;           Mark Zbikowski
;           Chris Peters (BIOS) (ret.)

; ****************** Revision History *************************
;          >> EVERY change must noted below!! <<
;
; 0.34 12/29/80 General release, updating all past customers
; 0.42 02/25/81 32-byte directory entries added
; 0.56 03/23/81 Variable record and sector sizes
; 0.60 03/27/81 Ctrl-C exit changes, including register save on user stack
; 0.74 04/15/81 Recognize I/O devices with file names
; 0.75 04/17/81 Improve and correct buffer handling
; 0.76 04/23/81 Correct directory size when not 2^N entries
; 0.80 04/27/81 Add console input without echo, Functions 7 & 8
; 1.00 04/28/81 Renumber for general release
; 1.01 05/12/81 Fix bug in `STORE'
; 1.10 07/21/81 Fatal error trapping, NUL device, hidden files, date & time,
;               RENAME fix, general cleanup
; 1.11 09/03/81 Don't set CURRENT BLOCK to 0 on open; fix SET FILE SIZE
; 1.12 10/09/81 Zero high half of CURRENT BLOCK after all (CP/M programs don't)
; 1.13 10/29/81 Fix classic "no write-through" error in buffer handling
; 1.20 12/31/81 Add time to FCB; separate FAT from DPT; Kill SMALLDIR; Add
;               FLUSH and MAPDEV calls; allow disk mapping in DSKCHG; Lots
;               of smaller improvements
; 1.21 01/06/82 HIGHMEM switch to run DOS in high memory
; 1.22 01/12/82 Add VERIFY system call to enable/disable verify after write
; 1.23 02/11/82 Add defaulting to parser; use variable escape character Don't
;               zero extent field in IBM version (back to 1.01!)
; 1.24 03/01/82 Restore fcn. 27 to 1.0 level; add fcn. 28
; 1.25 03/03/82 Put marker (00) at end of directory to speed searches
; 1.26 03/03/82 Directory buffers searched as a circular queue, current buffer
;               is searched first when possible to minimize I/O
;      03/03/82 STORE routine optimized to tack on partial sector tail as
;               full sector write when file is growing
;      03/09/82 Multiple I/O buffers
;      03/29/82 Two bugs:  Delete all case resets search to start at beginning
;               of directory (infinite loop possible otherwise), DSKRESET
;               must invalidate all buffers (disk and directory).
; 1.27 03/31/82 Installable device drivers
;                 Function call 47 - Get pointer to device table list
;                 Function call 48 - Assign CON AUX LIST
;      04/01/82 Spooler interrupt (INT 28) added.
; 1.28 04/15/82 DOS retructured to use ASSUMEs and PROC labels around system
;               call entries.  Most CS relative references changed to SS
;               relative with an eye toward putting a portion of the DOS in
;               ROM.  DOS source also broken into header, data and code pieces
;      04/15/82 GETDMA and GETVECT calls added as 24 and 32.  These calls
;               return the current values.
;      04/15/82 INDOS flag implemented for interrupt processing along with
;               call to return flag location (call 29)
;      04/15/82 Volume ID attribute added
;      04/17/82 Changed ABORT return to user to a long ret from a long jump to
;               avoid a CS relative reference.
;      04/17/82 Put call to STATCHK in dispatcher to catch ^C more often
;      04/20/82 Added INT int_upooler into loop ^S wait
;      04/22/82 Dynamic disk I/O buffer allocation and call to manage them
;               call 49.
;      04/23/82 Added GETDSKPTDL as call 50, similar to GETFATPT(DL), returns
;               address of DPB
;      04/29/82 Mod to WRTDEV to look for ^C or ^S at console input when
;               writting to console device via file I/O.  Added a console
;               output attribute to devices.
;      04/30/82 Call to en/dis able ^C check in dispatcher Call 51
;      04/30/82 Code to allow assignment of func 1-12 to disk files as well
;               as devices....  pipes, redirection now possible
;      04/30/82 Expanded GETLIST call to 2.0 standard
;      05/04/82 Change to INT int_fatal_abort callout int HARDERR.  DOS SS
;               (data segment) stashed in ES, INT int_fatal_abort routines must
;               preserve ES.  This mod so HARDERR can be ROMed.
; 1.29 06/01/82 Installable block and character devices as per 2.0 spec
;      06/04/82 Fixed Bug in CLOSE regarding call to CHKFATWRT.  It got left
;               out back about 1.27 or so (oops).  ARR
; 1.30 06/07/82 Directory sector buffering added to main DOS buffer queue
; 1.40 06/15/82 Tree structured directories.  XENIX Path Parser MKDIR CHDIR
;               RMDIR Xenix calls
; 1.41 06/13/82 Made GETBUFFR call PLACEBUF
; 1.50 06/17/82 FATs cached in buffer pool, get FAT pointer calls disappear
;               Frees up lots of memory.
; 1.51 06/24/82 BREAKDOWN modified to do EXACT one sector read/write through
;               system buffers
; 1.52 06/30/82 OPEN, CLOSE, READ, WRITE, DUP, DUP2, LSEEK implemented
; 1.53 07/01/82 OPEN CLOSE mod for Xenix calls, saves and gets remote dir
; 1.54 07/11/82 Function calls 1-12 make use of new 2.0 PDB. Init code
;               changed to set file handle environment.
; 2.00 08/01/82 Number for IBM release
;      01/19/83 No environ bug in EXEC
;      01/19/83 MS-DOS OEM INT 21 extensions (SET_OEM_HANDLER)
;      01/19/83 Performance bug fix in cooked write to NUL
;      01/27/83 Growcnt fixed for 32-bits
;      01/27/83 Find-first problem after create
; 2.01 02/17/83 International DOS
; 2.11 08/12/83 Dos split into several more modules for assembly on
;               an IBM PC
; 08/07/2018 - Retro DOS v3.0 by Erdogan Tan
; (MSHEAD.ASM, MSDOS 6.0, 1991) - mshead.asm 1.1 85/04/10 -
; 2.10 03/09/83 Start of NETWORK support
;		New Buffer structure
;		New Sytem file table structure
;		FCB moved to internal representation
;		DOS re-organized
; 2.11 04/21/83 Continuation of 2.10, preliminary Network
;		device interface.
; 2.11 08/12/83 Dos split into several more modules for assembly on
;               an IBM PC
; 2.50 09/12/83 More network stuff
;
; *************************************************************

; ----------------------------------------------------------------------------
; EQUATES

; Interrupt Entry Points:

; INTBASE:      ABORT
; INTBASE+4:    COMMAND
; INTBASE+8:    BASE EXIT ADDRESS
; INTBASE+C:    CONTROL-C ABORT
; INTBASE+10H:  FATAL ERROR ABORT
; INTBASE+14H:  BIOS DISK READ
; INTBASE+18H:  BIOS DISK WRITE
; INTBASE+1CH:  END BUT STAY RESIDENT (NOT SET BY DOS)
; INTBASE+20H:  SPOOLER INTERRUPT
; INTBASE+40H:  Long jump to CALL entry point

ENTRYPOINTSEG   EQU     0Ch
MAXDIF          EQU     0FFFh
SAVEXIT         EQU     10
; 06/05/2019
WRAPOFFSET	EQU	0FEF0h  ; (MISC.ASM, MSDOS 6.0, 1991)

       ; INCLUDE DOSSYM.ASM
       ; INCLUDE DEVSYM.ASM

; SUBTTL ^C, terminate/abort/exit and Hard error actions
; PAGE
; There are three kinds of context resets that can occur during normal DOS
; functioning:  ^C trap, terminate/abort/exit, and Hard-disk error.  These must
; be handles in a clean fashion that allows nested executions along with the
; ability to trap one's own errors.
;
; ^C trap - A process may elect to catch his own ^Cs.  This is achieved by
;           using the $GET_INTERRUPT_VECTOR and $SET_INTERRUPT_VECTOR as
;           follows:
;
;           $GET_INTERRUPT_VECTOR for INT int_ctrl_c
;           Save it in static memory.
;           $SET_INTERRUPT_VECTOR for INT int_ctrl_c
;
;           The interrupt service routine must preserve all registers and
;           return carry set iff the operation is to be aborted (via abort
;           system call), otherwise, carry is reset and the operation is
;           restarted.  ANY DEVIATION FROM THIS WILL LEAD TO UNRELIABLE
;           RESULTS.
;
;           To restore original ^C processing (done on terminate/abort/exit),
;           restore INT int_ctrl_c from the saved vector.
;
; Hard-disk error -- The interrupt service routine for INT int_fatal_abort must
;           also preserve registers and return one of three values in AL: 0 and
;           1 imply retry and ignore (???)  and 2 indicates an abort.  The user
;           himself is not to issue the abort, rather, the dos will do it for
;           him by simulating a normal abort/exit system call.  ANY DEVIATION
;           FROM THIS WILL LEAD TO UNRELIABLE RESULTS.
;
; terminate/abort/exit -- The user may not, under any circumstances trap an
;           abort call.  This is reserved for knowledgeable system programs.
;           ANY DEVIATION FROM THIS WILL LEAD TO UNRELIABLE RESULTS.

;SUBTTL SEGMENT DECLARATIONS

; The following are all of the segments used.  They are declared in the order
; that they should be placed in the executable

;
; segment ordering for MSDOS
;

;START           SEGMENT BYTE PUBLIC 'START'
;START           ENDS

;CONSTANTS       SEGMENT BYTE PUBLIC 'CONST'
;CONSTANTS       ENDS

;DATA            SEGMENT WORD PUBLIC 'DATA'
;DATA            ENDS

;CODE            SEGMENT BYTE PUBLIC 'CODE'
;CODE            ENDS

;LAST            SEGMENT BYTE PUBLIC 'LAST'
;LAST            ENDS

;DOSGROUP    GROUP   CODE,CONSTANTS,DATA,LAST

; The following segment is defined such that the data/const classes appear
; before the code class for ROMification

;START		SEGMENT BYTE PUBLIC 'START'
;           	ASSUME  CS:DOSGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING
;		JMP     DOSINIT
;START		ENDS

;============================================================================
; BPB.INC, MSDOS 6.0, 1991
;============================================================================
; 09/07/2018 - Retro DOS v3.0

;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;

;**	BIOS PARAMETER BLOCK DEFINITION
;
;	The BPB contains information about the disk structure. It dates
;	back to the earliest FAT systems and so FAT information is
;	intermingled with physical driver information.
;
;	A boot sector contains a BPB for its device; for other disks
;	the driver creates a BPB. DOS keeps copies of some of this
;	information in the DPB.
;
;	The BDS structure contains a BPB within it. 

struc A_BPB
.BPB_BYTESPERSECTOR:	resw	1
.BPB_SECTORSPERCLUSTER:	resb	1
.BPB_RESERVEDSECTORS:	resw	1
.BPB_NUMBEROFFATS:	resb	1
.BPB_ROOTENTRIES: 	resw	1
.BPB_TOTALSECTORS:	resw	1
.BPB_MEDIADESCRIPTOR:	resb	1
.BPB_SECTORSPERFAT:	resw	1
.BPB_SECTORSPERTRACK:	resw	1
.BPB_HEADS:		resw	1
.BPB_HIDDENSECTORS:	resw	1
			resw	1
.BPB_BIGTOTALSECTORS:	resw	1
			resw	1
			resb	6	; NOTE:  many times these
;					; 	 6 bytes are omitted
;					;	 when BPB manipulations
;					;	 are performed!
.size:
endstruc

;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;

;============================================================================
; BUFFER.INC, MSDOS 6.0, 1991
;============================================================================
; 04/05/2019 - Retro DOS v4.0

; <Disk I/O Buffer Header>

;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;

; Field definition for I/O buffer information

struc BUFFINFO
.buf_next:	resw 1		; Pointer to next buffer in list
.buf_prev:	resw 1		; Pointer to prev buffer in list
.buf_ID:	resb 1		; Drive of buffer (bit 7 = 0)
				; SFT table index (bit 7 = 1)
				; = FFH if buffer free
.buf_flags:	resb 1		; Bit 7 = 1 if Remote file buffer
				;	= 0 if Local device buffer
				; Bit 6 = 1 if buffer dirty
				; Bit 5 = Reserved
				; Bit 4 = Search bit (bit 7 = 1)
				; Bit 3 = 1 if buffer is DATA
				; Bit 2 = 1 if buffer is DIR
				; Bit 1 = 1 if buffer is FAT
				; Bit 0 = Reserved
.buf_sector:	resd 1		; Sector number of buffer (flags bit 7 = 0)
; The next two items are often refed as a word (flags bit 7 = 0)
.buf_wrtcnt:	resb 1		; For FAT sectors, # times sector written out
.buf_wrtcntinc:	resw 1		; "   "     "   , # sectors between each write
.buf_DPB:	resd 1		; Pointer to drive parameters
.buf_fill:	resw 1		; How full buffer is (flags bit 7 = 1)
.buf_reserved:	resb 1		; make DWORD boundary for 386
.size:	; 20 bytes
endstruc

%define buf_offset	BUFFINFO.buf_sector ; 22/07/2019
				;For buf_flags bit 7 = 1, this is the byte
				;offset of the start of the buffer in
				;the file pointed to by buf_ID. Thus
				;the buffer starts at location
				;buf_offset in the file and contains
				;buf_fill bytes.

BUFINSIZ        EQU     BUFFINFO.size

buf_Free	EQU	0FFh	; buf_id of free buffer

;Flag byte masks
buf_isnet	EQU	10000000B
buf_dirty	EQU	01000000B
;***
buf_visit	EQU	00100000B
;***
buf_snbuf	EQU	00010000B

buf_isDATA	EQU	00001000B
buf_isDIR	EQU	00000100B
buf_isFAT	EQU	00000010B
buf_type_0	EQU	11110001B	; AND sets type to "none"

buf_NetID	EQU	BUFINSIZ

;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;

;============================================================================
; DOSSSYM.INC, MSDOS 6.0, 1991
;============================================================================
; 04/05/2019 - Retro DOS v4.0

; <Control character definitions>

c_DEL	    EQU     7Fh 	;    ASCII rubout or delete previous char
c_BS	    EQU     08h 	; ^H ASCII backspace
c_CR	    EQU     0Dh 	; ^M ASCII carriage return
c_LF	    EQU     0Ah 	; ^J ASCII linefeed
c_ETB	    EQU     17h 	; ^W ASCII end of transmission
c_NAK	    EQU     15h 	; ^U ASCII negative acknowledge
c_ETX	    EQU     03h 	; ^C ASCII end of text
c_HT	    EQU     09h 	; ^I ASCII tab

; <User stack inside of system call>
; Location of user registers relative user stack pointer

struc	user_env   ; user_environ
.user_AX: resw 1
.user_BX: resw 1
.user_CX: resw 1
.user_DX: resw 1
.user_SI: resw 1
.user_DI: resw 1
.user_BP: resw 1
.user_DS: resw 1
.user_ES: resw 1
.user_IP: resw 1
.user_CS: resw 1
.user_F:  resw 1
.size:
endstruc

; ---- <Disk map> ----

;	MSDOS partitions the disk into 4 sections:
;
;  phys sector 0:   +-------------------+
;	|	    | boot/reserved	|
;	|	    +-------------------+
;	|	    |  File allocation	|
;	v	    |	   table(s)	|
;		    |  (multiple copies |
;		    |	  are kept)	|
;		    +-------------------+
;		    |	  Directory	|
;		    +-------------------+
;		    |	  File space	|
;		    +-------------------+
;		    |	Unaddressable	|
;		    |  (to end of disk) |
;		    +-------------------+
;
; All partition boundaries are sector boundaries.  The size of the FAT is
; adjusted to maximize the file space addressable.

; <File allocation Table information>

; The File Allocation Table uses a 12-bit entry for each allocation unit on
; the disk.  These entries are packed, two for every three bytes.  The contents
; of entry number N is found by 1) multiplying N by 1.5; 2) adding the result
; to the base address of the Allocation Table; 3) fetching the 16-bit word
; at this address; 4) If N was odd (so that N*1.5 was not an integer), shift
; the word right four bits; 5) mask to 12 bits (AND with 0FFF hex).  Entry
; number zero is used as an end-of-file trap in the OS and is passed to the
; BIOS to help determine disk format.  Entry 1 is reserved for future use.
; The first available allocation unit is assigned entry number two, and even
; though it is the first, is called cluster 2.	Entries greater than 0FF8H
; (12-bit fats) or 0FFF8H (16-bit fats) are end of file marks; entries of zero
; are unallocated.  Otherwise, the contents of a FAT entry is the number of
; the next cluster in the file.
;
; Clusters with bad sectors are tagged with FF7H.  Any non-zero number would
; do because these clusters show as allocated, but are not part of any
; allocation chain and thus will never be allocated to a file.	A particular
; number is selected so that disk checking programs know what to do (ie.  a
; cluster with entry FF7H which is not in a chain is not an error).

;**	Character Type Flags
;
;	These flags are used in a lookup table indexed by the character code.
;	They're used to quickly classify characters when parsing paths.
;	I think that these are only used to parse FCBs - jgl

FCHK	equ 1		; I think this means "normal name char, no chks needed" -jgl
FDELIM	equ 2		; is a delimiter
FSPCHK	equ 4		; set if character is not a space or equivalent
FFCB	equ 8		; is valid in an FCB

;** Bit definitions for DOS_FLAG
;
; Bit 0 - this is set when a $open call is made from $exec. This is used in
;	  $open to indicate to the redirector that this open is being made
;	  by an exec call.
;
; Bit 2
;
; M003, M027:
;
; The start up code of MS PASCAL 3.2 programs depend on the 1M address wrap 
; if they load below 64K. This is a likely possiblity in DOS 5.x with DOS in
; the HMA. By default DOS will turn A20 OFF before Xferring control to the
; user program in the case of an Exec call. The next call to DOS will turn
; A20 line ON. It has been observed that MS PASCAL 3.2 start up does an int
; 21 ah=25h call before executing the faulty code. This will turn A20 On. 
; In order to support this we will set Bit 2 of this flag in the DOS exec
; call (msproc.asm) if DOS is running in the HMA. In $set_interrupt_vector in
; getset.asm A20OFF_COUNT is set to 1 if bit 2 of DOS_FLAG was previously set 
; by a call to exec and if A20OFF_COUNT is 0. In msdisp.asm, if A20OFF_COUNT 
; is non zero then A20 will be turned OFF before returning to the user. 
; Bit 2 will be unconditionally cleared here.
;
; M009, M027:
;
; Mace utilities MKEYRATE.COM version 1.0 copyright 1987 is an execpacked 
; program converted to a com file. Therefore if DOS is loaded high and if 
; this program is loaded below 64K it will blurt out "packed file is corrupt".
; This program does an int 21 ah=49h before executing the buggy execpacked
; code. This int21 call turns a20 on and hence the problem. In $dealloc
; alloc.asm A20OFF_COUNT is set to 1 if bit 2 of DOS_FLAG was previously set 
; by a call to exec and if A20OFF_COUNT is 0. In msdisp.asm, if A20OFF_COUNT 
; is non zero then A20 will be turned OFF before returning to the user. 
; Bit 2 will be unconditionally cleared here.

EXECOPEN	EQU	00000001b	; bit 0 of DOS_FLAG
SUPPRESS_WINA20	EQU	00000010b	; M025
EXECA20OFF	EQU	00000100b	; bit 2 of DOS_FLAG

;============================================================================
; VECTOR.INC, MSDOS 6.0, 1991
;============================================================================
; 04/05/2019 - Retro DOS v4.0

; 09/07/2018 - Retro DOS v3.0 (VECTOR.INC, MSDOS 3.3, 1987)

; <interrupt definitions>

INTTAB          EQU     20H
INTBASE         EQU     4 * INTTAB
ENTRYPOINT      EQU     INTBASE+40H

;	IF      ALTVECT
;ALTTAB  EQU     0F0H
;ALTBASE EQU     4 * ALTTAB
;	ENDIF

;
; interrupt assignments
;
;	IF	NOT ALTVECT
int_abort	    EQU     INTTAB	; abort process
int_command	    EQU     int_abort+1 ; call MSDOS
int_terminate	    EQU     int_abort+2 ; int to terminate address
int_ctrl_c	    EQU     int_abort+3 ; ^c trapper
int_fatal_abort     EQU     int_abort+4 ; hard disk error
int_disk_read	    EQU     int_abort+5 ; logical sector disk read
int_disk_write	    EQU     int_abort+6 ; logical sector disk write
int_keep_process    EQU     int_abort+7 ; terminate program and stay
					; resident
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
int_spooler	    EQU     int_abort+8 ; spooler call
int_fastcon	    EQU     int_abort+9 ; fast CON interrupt
int_IBM 	    EQU     int_abort+10; critical section maintenance
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	ELSE
;int_abort	    EQU     INTTAB	; abort process
;int_command	    EQU     int_abort+1 ; call MSDOS
;int_terminate	    EQU     ALTTAB	; int to terminate address
;int_ctrl_c	    EQU     int_terminate+1 ; ^c trapper
;int_fatal_abort    EQU     int_terminate+2 ; hard disk error
;int_disk_read	    EQU     int_abort+5 ; logical sector disk read
;int_disk_write	    EQU     int_abort+6 ; logical sector disk write
;int_keep_process   EQU     int_abort+7 ; terminate program and stay resident
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
;int_spooler	    EQU     int_terminate+3 ; spooler call
;int_fastcon	    EQU     int_abort+9 ; fast CON interrupt
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	ENDIF

addr_int_abort		EQU    4 * int_abort
addr_int_command	EQU    4 * int_command
addr_int_terminate	EQU    4 * int_terminate
addr_int_ctrl_c 	EQU    4 * int_ctrl_c
addr_int_fatal_abort	EQU    4 * int_fatal_abort
addr_int_disk_read	EQU    4 * int_disk_read
addr_int_disk_write	EQU    4 * int_disk_write
addr_int_keep_process	EQU    4 * int_keep_process
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
addr_int_spooler	EQU    4 * int_spooler
addr_int_fastcon	EQU    4 * int_fastcon
addr_int_ibm		EQU    4 * int_IBM
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;

;============================================================================
; DIRENT.INC, MSDOS 6.0, 1991
;============================================================================
; 04/05/2019 - Retro DOS v4.0

; BREAK <Directory entry>

;
;       +---------------------------+
;       |  (12 BYTE) filename/ext   |       0       0
;       +---------------------------+
;       |     (BYTE) attributes     |       11      B
;       +---------------------------+
;       |    (10 BYTE) reserved     |       12      C
;       +---------------------------+
;       | (WORD) time of last write |       22      16
;       +---------------------------+
;       | (WORD) date of last write |       24      18
;       +---------------------------+
;       |   (WORD) First cluster    |       26      1A
;       +---------------------------+
;       |     (DWORD) file size     |       28      1C
;       +---------------------------+
;
;   First byte of filename  = E5 -> free directory entry
;                           = 00 -> end of allocated directory
;   Time:   Bits 0-4=seconds/2, bits 5-10=minute, 11-15=hour
;   Date:   Bits 0-4=day, bits 5-8=month, bits 9-15=year-1980
;
struc dir_entry
.dir_name:	resb 11			; file name
.dir_attr:	resb 1			; attribute bits
.dir_codepg:	resw 1			; code page DOS 4.00
.dir_extcluster: resw 1			; extended attribute starting cluster
.dir_attr2:	resb 1			; reserved
.dir_pad:	resb 5			; reserved for expansion
.dir_time:	resw 1			; time of last write
.dir_date:	resw 1			; date of last write
.dir_first:	resw 1			; first allocation unit of file
.dir_size_l:	resw 1			; low 16 bits of file size
.dir_size_h:	resw 1			; high 16 bits of file size
.size:
endstruc

attr_read_only      EQU      1h
attr_hidden         EQU      2h
attr_system         EQU      4h
attr_volume_id      EQU      8h
attr_directory      EQU     10h
attr_archive        EQU     20h
attr_device	    EQU     40h	; This is a VERY special bit.
				;   NO directory entry on a disk EVER
				;   has this bit set. It is set non-zero
				;   when a device is found by GETPATH

attr_all            EQU     attr_hidden+attr_system+attr_directory
                                        ; OR of hard attributes for FINDENTRY

attr_ignore         EQU     attr_read_only+attr_archive
                                        ; ignore this(ese) attribute(s)
                                        ; during search first/next

attr_changeable     EQU     attr_read_only+attr_hidden+attr_system+attr_archive
                                        ; changeable via CHMOD

DIRFREE		equ	0E5h	; stored in dir_name[0] to indicate free slot

;============================================================================
; DPB.INC, MSDOS 6.0, 1991
;============================================================================
; 24/04/2019 - Retro DOS v4.0

; 19/07/2018 - Retro DOS v3.0 (DPB.INC, MSDOS 3.3, 1987)
; 07/07/2018 - Retro DOS v3.0 (DPB.INC, MSDOS 6.0, 1991)

; ---------------------------------------------------------------------------
;**	DPB - Drive Parameter Block
;
;	BUGBUG - this isn't authorative - it's my probably incomplete and
;	possibly inaccurate deductions from code study... - jgl
;
;	The DPB is DOS's main structure for describing block devices.
;	It contains info about the "Drive" intermingled with info about
;	the FAT file system which is presumably on the drive.  I don't know
;	how those fields are used if it's not the FAT file system - BUGBUG
;
;	The DPBs are statically allocated and chained off of DPBHead.
;	Users scan this chain looking for a match on DPB_DRIVE.
;	The DPBs are built at init time from info in the SYSDEV structure.
; ---------------------------------------------------------------------------

struc	DPB
.DRIVE:		resb 1		; Logical drive # assoc with DPB (A=0,B=1,...)
.UNIT:		resb 1		; Driver unit number of DPB
.SECTOR_SIZE:	resw 1		; Size of physical sector in bytes
.CLUSTER_MASK:	resb 1		; Sectors/cluster - 1
.CLUSTER_SHIFT:	resb 1		; Log2 of sectors/cluster
.FIRST_FAT:	resw 1		; Starting record of FATs
.FAT_COUNT:	resb 1		; Number of FATs for this drive
.ROOT_ENTRIES:	resw 1		; Number of directory entries
.FIRST_SECTOR:	resw 1		; First sector of first cluster
.MAX_CLUSTER:	resw 1		; Number of clusters on drive + 1
; MSDOS 3.3
;.FAT_SIZE:	resb 1		; Number of records occupied by FAT
; MSDOS 6.0
.FAT_SIZE:	resw 1		; Number of records occupied by FAT
.DIR_SECTOR:	resw 1		; Starting record of directory
.DRIVER_ADDR:	resd 1		; Pointer to driver
.MEDIA:		resb 1		; Media byte
.FIRST_ACCESS:	resb 1		; This is initialized to -1 to force a media
				; check the first time this DPB is used
.NEXT_DPB:	resd 1		; Pointer to next Drive parameter block
.NEXT_FREE:	resw 1		; Cluster # of last allocated cluster
.FREE_CNT:	resw 1		; Count of free clusters, -1 if unknown
.size:
endstruc

DPBSIZ  EQU     DPB.size	; Size of the structure in bytes

DSKSIZ  EQU	DPB.MAX_CLUSTER	; Size of disk (temp used during init only)

;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;

;============================================================================
; SF.INC, MSDOS 6.0, 1991
;============================================================================
; 25/04/2019 - Retro DOS v4.0
; 07/07/2018 - Retro DOS v3.0

;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;

; ---------------------------------------------------------------------------
;**	SF.INC - System File Table
;
;   AN000   version 4.00   Jan. 1988
;   AN003   PTM 3680 --  make NAME offset the same as before (<=3.30)
;   AN009   PTM 3839	 reorder SFT for MS WINDOWS
; ---------------------------------------------------------------------------
;**	System File Table SuperStructure
;
;	The system file table entries are allocated in contiguous groups.
;	There may be more than one such groups; the SF "superstructure"
;	tracks the groups.
; ---------------------------------------------------------------------------

struc	SFT
.SFLink:	resd 1
.SFCount:	resw 1		; number of entries
.SFTable:	resw 1		; beginning of array of the following
.size:
endstruc

; ---------------------------------------------------------------------------
;**	System file table entry
;
;	These are the structures which are at SFTABLE in the SF structure.
; ---------------------------------------------------------------------------

; 25/04/2019 - Retro DOS v4.0

struc SF_ENTRY
.sf_ref_count:	resw 1		; number of processes sharing entry
				;   if FCB then ref count
.sf_mode:	resw 1		; mode of access or high bit on if FCB
.sf_attr:	resb 1		; attribute of file
.sf_flags:	resw 1		;Bits 8-15
				; Bit 15 = 1 if remote file
				;	 = 0 if local file or device
				; Bit 14 = 1 if date/time is not to be
				;   set from clock at CLOSE.  Set by
				;   FILETIMES and FCB_CLOSE.  Reset by
				;   other reseters of the dirty bit
				;   (WRITE)
				; Bit 13 = Pipe bit (reserved)
				;
				; Bits 0-7 (old FCB_devid bits)
				; If remote file or local file, bit
				; 6=0 if dirty Device ID number, bits
				; 0-5 if local file.
				; bit 7=0 for local file, bit 7
				;      =1 for local I/O device
				; If local I/O device, bit 6=0 if EOF (input)
				;		Bit 5=1 if Raw mode
				;		Bit 0=1 if console input device
				;		Bit 1=1 if console output device
				;		Bit 2=1 if null device
				;		Bit 3=1 if clock device
.sf_devptr:	resd	1	; Points to DPB if local file, points
				; to device header if local device,
				; points to net device header if
				; remote
.sf_firclus:	resw	1	; First cluster of file (bit 15 = 0)
.sf_time:	resw	1	; Time associated with file
.sf_date:	resw	1	; Date associated with file
.sf_size:	resd 	1	; Size associated with file
.sf_position:	resd	1	; Read/Write pointer or LRU count for FCBs

; Starting here, the next 7 bytes may be used by the file system to store
; an ID

; 09/07/2018 - Retro DOS v3.0

; MSDOS 3.3 SF.INC, 1987
;.sf_cluspos:	resw	1	; Position of last cluster accessed
;.sf_lstclus	resw	1	; Last cluster accessed
;.sf_dirsec:	resw	1	; Sector number of directory sector
;				; for this file
;.sf_dirpos:	resb	1	; Offset of this entry in the above

; MSDOS 6.0, SF.INC, 1991
.sf_cluspos:	resw	1	; Position of last cluster accessed
.sf_dirsec:	resd	1	; Sector number of directory sector
				; for this file
.sf_dirpos:	resb	1	; Offset of this entry in the above

; End of 7 bytes of file-system specific info.

.sf_name:	resb	11	; 11 character name that is in the
				; directory entry.  This is used by
				; close to detect file deleted and
				; disk changed errors.
; SHARING INFO
.sf_chain:	resd	1	; link to next SF
.sf_UID:	resw	1
.sf_PID:	resw	1
.sf_MFT:	resw	1

; MSDOS 6.0, SF.INC, 1991
.sf_lstclus:	resw	1	;AN009; Last cluster accessed
.sf_IFS_HDR:	resd	1

.size:
endstruc

; 20/07/2018
; MSDOS 3.3, SF.INC, 1987
%define sf_netid   SF_ENTRY.sf_cluspos    ; byte
%define sf_OpenAge SF_ENTRY.sf_position+2 ; word
%define sf_LRU	   SF_ENTRY.sf_position	  ; word
; MSDOS 6.0, SF.INC, 1991
%define sf_fsda	     SF_ENTRY.sf_cluspos  ; byte ;DOS 4.00
%define sf_serial_ID SF_ENTRY.sf_firclus  ; word ;DOS 4.00

; 19/07/2018
; MSDOS 3.3, SF.INC, 1987

sf_default_number  EQU	5

; Note that we need to mark an SFT as being busy for OPEN/CREATE.  This is
; because an INT 24 may prevent us from 'freeing' it.  We mark this as such
; by placing a -1 in the ref_count field.

sf_busy EQU -1

; mode mask for FCB detection
sf_isFCB		EQU	1000000000000000B

; Flag word masks
sf_isnet		EQU	1000000000000000B
sf_close_nodate 	EQU	0100000000000000B
sf_pipe 		EQU	0010000000000000B
sf_no_inherit		EQU	0001000000000000B
sf_net_spool		EQU	0000100000000000B

; 25/04/2019
sf_entry_size equ SF_ENTRY.size ; 59 (MSDOS 6.0)

; ---------------------------------------------------------------------------
; Local file/device flag masks
; ---------------------------------------------------------------------------

devid_file_clean        EQU     40h     ; true if file and not written
devid_file_mask_drive   EQU     3Fh     ; mask for drive number

devid_device            EQU     80h     ; true if a device
devid_device_EOF        EQU     40h     ; true if end of file reached
devid_device_raw        EQU     20h     ; true if in raw mode
devid_device_special    EQU     10h     ; true if special device
devid_device_clock      EQU     08h     ; true if clock device
devid_device_null       EQU     04h     ; true if null device
devid_device_con_out    EQU     02h     ; true if console output
devid_device_con_in     EQU     01h     ; true if console input

; ---------------------------------------------------------------------------
; structure of devid field as returned by IOCTL is:
;
;       BIT     7   6   5   4   3   2   1   0
;             |---|---|---|---|---|---|---|---|
;             | I | E | R | S | I | I | I | I |
;             | S | O | A | P | S | S | S | S |
;             | D | F | W | E | C | N | C | C |
;             | E |   |   | C | L | U | O | I |
;             | V |   |   | L | K | L | T | N |
;             |---|---|---|---|---|---|---|---|
;       ISDEV = 1 if this channel is a device
;             = 0 if this channel is a disk file
;
;       If ISDEV = 1
;
;             EOF = 0 if End Of File on input
;             RAW = 1 if this device is in Raw mode
;                 = 0 if this device is cooked
;             ISCLK = 1 if this device is the clock device
;             ISNUL = 1 if this device is the null device
;             ISCOT = 1 if this device is the console output
;             ISCIN = 1 if this device is the console input
;
;       If ISDEV = 0
;             EOF = 0 if channel has been written
;             Bits 0-5 are the block device number for
;                 the channel (0 = A, 1 = B, ...)
; ---------------------------------------------------------------------------

devid_ISDEV     EQU     80h
devid_EOF       EQU     40h
devid_RAW       EQU     20h
devid_SPECIAL   EQU     10H
devid_ISCLK     EQU     08h
devid_ISNUL     EQU     04h
devid_ISCOT     EQU     02h
devid_ISCIN     EQU     01h

devid_block_dev EQU     1Fh             ; mask for block device number

;============================================================================
; PDB.INC, MSDOS 6.0, 1991
;============================================================================
; 04/05/2019 - Retro DOS v4.0
; 08/07/2018 - Retro DOS v3.0

; ---------------------------------------------------------------------------
; BREAK <Process data block>
; ---------------------------------------------------------------------------
;**	Process data block (otherwise known as program header)
;

;	These offset are documented in the MSDOS Encyclopedia, so nothing
;	can be rearranged here, ever. Reserved areas are probably safe
;	for use.
; ---------------------------------------------------------------------------

FILPERPROC	EQU     20

struc PDB	; Process_data_block
.EXIT_CALL:	resw 1   	; INT int_abort system terminate
.BLOCK_LEN:	resw 1		; size of execution block
                resb 1
.CPM_CALL:	resb 5		; ancient call to system
.EXIT:		resd 1		; pointer to exit routine
.CTRL_C:	resd 1		; pointer to ^C routine
.FATAL_ABORT:	resd 1		; pointer to fatal error
.PARENT_PID:	resw 1		; PID of parent (terminate PID)
.JFN_TABLE:     resb FILPERPROC ; indices into system table
.ENVIRON:	resw 1		; seg addr of environment
.USER_STACK:	resd 1		; stack of self during system calls
.JFN_Length:	resw 1		; number of handles allowed
.JFN_Pointer:	resd 1		; pointer to JFN table
.Next_PDB:	resd 1		; pointer to nested PDB's
.InterCon:	resb 1	; MSDOS 6.0 ; *** jh-3/28/90 *** 
.Append:	resb 1	; MSDOS 6.0 ; *** Not sure if still used ***
.Novell_Used:	resb 2	; MSDOS 6.0 ; Novell shell (redir) uses these
.Version:	resw 1	; MSDOS 6.0 ; DOS version reported to this app
.PAD1:		resb 14 ; 0Eh
.CALL_SYSTEM:	resb 5		; portable method of system call
.PAD2:		resb 7		; reserved so FCB 1 can be used as
				;  an extended FCB
;endstruc 	; MSDOS 3.3
	  	; MSDOS 6.0
.FCB1:		resb 16 ; 10h	; default FCB 1
.FCB2:		resb 16 ; 10h	; default FCB 2
.PAD3:		resb 4		; not sure if this is used by PDB_FCB2
.TAIL:		resb 128	; command tail and default DTA
endstruc

;============================================================================
; EXE.INC, MSDOS 6.0, 1991
;============================================================================
; 04/05/2019 - Retro DOS v4.0

;**	EXE.INC - Definitions for the EXEC command and EXE files
; ---------------------------------------------------------------------------
; The following get used as arguments to the EXEC system call.  They indicate
; whether or not the program is executed or whether or not a program header
; gets created.

exec_func_no_execute EQU 1	; no execute bit
exec_func_overlay    EQU 2	; overlay bit

struc EXEC0
.ENVIRON:	resw 1		; seg addr of environment
.COM_LINE:	resd 1		; pointer to asciz command line
.5C_FCB:	resd 1		; default fcb at 5C
.6C_FCB:	resd 1		; default fcb at 6C
.size:
endstruc

struc EXEC1
.ENVIRON:	resw 1		; seg addr of environment
.COM_LINE:	resd 1		; pointer to asciz command line
.5C_FCB:	resd 1		; default fcb at 5C
.6C_FCB:	resd 1		; default fcb at 6C
.SP:		resw 1		; stack pointer of program
.SS:		resw 1		; stack seg register of program
.IP:		resw 1		; entry point IP
.CS:		resw 1		; entry point CS
.size:
endstruc

struc EXEC3
.load_addr:	resw 1		; seg address of load point
.reloc_fac:	resw 1		; relocation factor
endstruc

;**	Exit codes (in upper byte) for terminating programs

EXIT_TERMINATE		EQU	0
EXIT_ABORT		EQU	0
EXIT_CTRL_C		EQU	1
EXIT_HARD_ERROR 	EQU	2
EXIT_KEEP_PROCESS	EQU	3

;**	EXE File Header Description

struc EXE
.signature:   resw 1		; must contain 4D5A (yay zibo!)
.len_mod_512: resw 1		; low 9 bits of length
.pages:       resw 1		; number of 512b pages in file
.rle_count:   resw 1		; count of reloc entries
.par_dir:     resw 1		; number of paragraphs before image
.min_BSS:     resw 1		; minimum number of para of BSS
.max_BSS:     resw 1		; max number of para of BSS
.SS:          resw 1		; stack of image
.SP:          resw 1		; SP of image
.chksum:      resw 1		; checksum of file (ignored)
.IP:          resw 1		; IP of entry
.CS:          resw 1		; CS of entry
.rle_table:   resw 1		; byte offset of reloc table
.iov:         resw 1		; overlay number (0 for root)
.sym_tab:     resd 1		; offset of symbol table in file
.size:
endstruc

exe_valid_signature     EQU 5A4Dh
exe_valid_old_signature EQU 4D5Ah

;**	EXE file symbol info definitions

struc symbol_entry
.value:	resd 1
.type:	resw 1
.len:	resb 1
.name:	resb 255
endstruc

;**	Data structure passed for ExecReady call

struc ERStruc
 .ER_Reserved:	resw	1	; reserved, should be zero
 .ER_Flags:	resw	1
 .ER_ProgName:	resd	1	; ptr to ASCIIZ str of prog name
 .ER_PSP:	resw	1	; PSP of the program
 .ER_StartAddr:	resd	1	; Start CS:IP of the program
 .ER_ProgSize:	resd	1	; Program size including PSP
 .size:
endstruc

;** bit fields in ER_Flags

ER_EXE		equ	0001h
ER_OVERLAY	equ	0002h


;============================================================================
; ARENA.INC, MSDOS 6.0, 1991
;============================================================================
; 24/04/2019 - Retro DOS v4.0
; 04/08/2018 - Retro DOS v3.0

;BREAK <Memory arena structure>

;**	Arena Header

struc ARENA
.SIGNATURE:	resb 1		; 4D for valid item, 5A for last item
.OWNER:		resw 1		; owner of arena item
.SIZE:		resw 1		; size in paragraphs of item
.RESERVED:	resb 3		; reserved
.NAME:		resb 8		; owner file name
.headersize:			
endstruc

; 20/05/2019 - Retro DOS v4.0
ARENAHEADERSIZE equ ARENA.headersize 

; CAUTION: The routines in ALLOC.ASM rely on the fact that arena_signature
; and arena_owner_system are all equal to zero and are contained in DI.
; Change them and change ALLOC.ASM.

arena_owner_system  EQU 0               ; free block indication

arena_signature_normal	EQU 4Dh		; valid signature, not end of arena
arena_signature_end     EQU 5Ah         ; valid signature, last block in arena

FIRST_FIT	EQU	00000000B
BEST_FIT	EQU	00000001B
LAST_FIT	EQU	00000010B

; MSDOS 6.0
LOW_FIRST	EQU	00000000B	; M001
HIGH_FIRST	EQU	10000000B	; M001
HIGH_ONLY	EQU	01000000B	; M001

LINKSTATE	EQU	00000001B	; M002

HF_MASK		EQU	~HIGH_FIRST	; M001
HO_MASK		EQU	~HIGH_ONLY	; M001

STRAT_MASK	EQU	HF_MASK & HO_MASK	; M001;
						; M026: used to mask of bits
						; M026: 6 & 7 of AllocMethod

;============================================================================
; MI.INC, MSDOS 6.0, 1991
;============================================================================
; 07/07/2018 - Retro DOS v3.0

;BREAK <Machine instruction, flag definitions and character types>

mi_INT		EQU	0CDh
mi_long_jmp	EQU	0EAh
mi_Long_CALL	EQU	09Ah
mi_Long_RET	EQU	0CBh
mi_Near_RET	EQU	0C3h

;			xxxxoditszxaxpxc
f_Overflow	EQU	0000100000000000B
f_Direction	EQU	0000010000000000B
f_Interrupt	EQU	0000001000000000B
f_Trace 	EQU	0000000100000000B
f_Sign		EQU	0000000010000000B
f_Zero		EQU	0000000001000000B
f_Aux		EQU	0000000000010000B
f_Parity	EQU	0000000000000100B
f_Carry 	EQU	0000000000000001B

;============================================================================
; FILEMODE.INC, MSDOS 6.0, 1991
;============================================================================
; 13/07/2018 - Retro DOS v3.0
; 29/04/2019 - Retro DOS v4.0

;**	Standard I/O file handles

stdin       EQU     0
stdout      EQU     1
stderr      EQU     2
stdaux      EQU     3
stdprn      EQU     4

;**	File Modes
; <Xenix subfunction assignments>  ; MSDOS 3.3 FILEMODE.INC

open_for_read   EQU 0
open_for_write  EQU 1
open_for_both   EQU 2

; MSDOS 6.0
OPEN_FOR_BOTH	equ 2
EXEC_OPEN	equ 3	; access code of 3 indicates that open was 
				; made from exec

access_mask	EQU 0Fh ; 09/08/2018

SHARING_MASK	    equ 0F0h
SHARING_COMPAT	    equ 000h
SHARING_DENY_BOTH   equ 010h
SHARING_DENY_WRITE  equ 020h
SHARING_DENY_READ   equ 030h
SHARING_DENY_NONE   equ 040h
SHARING_NET_FCB     equ 070h
SHARING_NO_INHERIT  equ 080h

; 29/04/2019

;**	Extended Open Definitions

RESERVED_BITS_MASK equ 0FE00h	; reserved bits for extended open flags
EXISTS_MASK	   equ 0Fh 	; "file exists" action field
NOT_EXISTS_MASK    equ 0F0h

;*	SF_MODE values

AUTO_COMMIT_WRITE	equ 4000h
INT_24_ERROR		equ 2000h

;*	Flags in EXTOPEN_ON

EXT_OPEN_ON		equ 01h
EXT_FILE_NOT_EXISTS	equ 04h
EXT_OPEN_I24_OFF	equ 02h

;*	Flags in EXTOPEN_FLAG

ACTION_OPENED		equ 01h
ACTION_CREATED_OPENED	equ 02h
ACTION_REPLACED_OPENED	equ 03h
EXT_EXISTS_OPEN 	equ 01h
EXT_EXISTS_FAIL 	equ 00h
EXT_NEXISTS_CREATE	equ 10h

;**	Extended Open Structure

struc EXT_OPEN_PARM
.SET_LIST:	resd 1
.NUM_OF_PARM:	resw 1
endstruc

;============================================================================
; SYSCALL.INC, MSDOS 6.0, 1991
;============================================================================
; 29/04/2019 - Retro DOS v4.0
; 09/07/2018 - Retro DOS v3.0 (SYSCALL.INC, MSDOS 3.3, 1987)

; <system call definitions>

ABORT                           EQU 0   ;  0      0
STD_CON_INPUT                   EQU 1   ;  1      1
STD_CON_OUTPUT                  EQU 2   ;  2      2
STD_AUX_INPUT                   EQU 3   ;  3      3
STD_AUX_OUTPUT                  EQU 4   ;  4      4
STD_PRINTER_OUTPUT              EQU 5   ;  5      5
RAW_CON_IO                      EQU 6   ;  6      6
RAW_CON_INPUT                   EQU 7   ;  7      7
STD_CON_INPUT_NO_ECHO           EQU 8   ;  8      8
STD_CON_STRING_OUTPUT           EQU 9   ;  9      9
STD_CON_STRING_INPUT            EQU 10  ; 10      A
STD_CON_INPUT_STATUS            EQU 11  ; 11      B
STD_CON_INPUT_FLUSH             EQU 12  ; 12      C
DISK_RESET                      EQU 13  ; 13      D
SET_DEFAULT_DRIVE               EQU 14  ; 14      E
FCB_OPEN                        EQU 15  ; 15      F
FCB_CLOSE                       EQU 16  ; 16     10
DIR_SEARCH_FIRST                EQU 17  ; 17     11
DIR_SEARCH_NEXT                 EQU 18  ; 18     12
FCB_DELETE                      EQU 19  ; 19     13
FCB_SEQ_READ                    EQU 20  ; 20     14
FCB_SEQ_WRITE                   EQU 21  ; 21     15
FCB_CREATE                      EQU 22  ; 22     16
FCB_RENAME                      EQU 23  ; 23     17
GET_DEFAULT_DRIVE               EQU 25  ; 25     19
SET_DMA                         EQU 26  ; 26     1A
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
GET_DEFAULT_DPB                 EQU 31  ; 31     1F
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
FCB_RANDOM_READ                 EQU 33  ; 33     21
FCB_RANDOM_WRITE                EQU 34  ; 34     22
GET_FCB_FILE_LENGTH             EQU 35  ; 35     23
GET_FCB_POSITION                EQU 36  ; 36     24
SET_INTERRUPT_VECTOR            EQU 37  ; 37     25
CREATE_PROCESS_DATA_BLOCK       EQU 38  ; 38     26
FCB_RANDOM_READ_BLOCK           EQU 39  ; 39     27
FCB_RANDOM_WRITE_BLOCK          EQU 40  ; 40     28
PARSE_FILE_DESCRIPTOR           EQU 41  ; 41     29
GET_DATE                        EQU 42  ; 42     2A
SET_DATE                        EQU 43  ; 43     2B
GET_TIME                        EQU 44  ; 44     2C
SET_TIME                        EQU 45  ; 45     2D
SET_VERIFY_ON_WRITE             EQU 46  ; 46     2E
; Extended functionality group
GET_DMA                         EQU 47  ; 47     2F
GET_VERSION                     EQU 48  ; 48     30
KEEP_PROCESS                    EQU 49  ; 49     31
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
GET_DPB                         EQU 50  ; 50     32
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
SET_CTRL_C_TRAPPING             EQU 51  ; 51     33
GET_INDOS_FLAG                  EQU 52  ; 52     34
GET_INTERRUPT_VECTOR            EQU 53  ; 53     35
GET_DRIVE_FREESPACE             EQU 54  ; 54     36
CHAR_OPER                       EQU 55  ; 55     37
INTERNATIONAL                   EQU 56  ; 56     38
; XENIX CALLS
;   Directory Group
MKDIR                           EQU 57  ; 57     39
RMDIR                           EQU 58  ; 58     3A
CHDIR                           EQU 59  ; 59     3B
;   File Group
CREAT                           EQU 60  ; 60     3C
OPEN                            EQU 61  ; 61     3D
CLOSE                           EQU 62  ; 62     3E
READ                            EQU 63  ; 63     3F
WRITE                           EQU 64  ; 64     40
UNLINK                          EQU 65  ; 65     41
LSEEK                           EQU 66  ; 66     42
CHMOD                           EQU 67  ; 67     43
IOCTL                           EQU 68  ; 68     44
XDUP                            EQU 69  ; 69     45
XDUP2                           EQU 70  ; 70     46
CURRENT_DIR                     EQU 71  ; 71     47
;    Memory Group
ALLOC                           EQU 72  ; 72     48
DEALLOC                         EQU 73  ; 73     49
SETBLOCK                        EQU 74  ; 74     4A
;    Process Group
EXEC                            EQU 75  ; 75     4B
EXIT                            EQU 76  ; 76     4C
_WAIT				EQU 77  ; 77     4D
FIND_FIRST                      EQU 78  ; 78     4E
;   Special Group
FIND_NEXT                       EQU 79  ; 79     4F
; SPECIAL SYSTEM GROUP
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
SET_CURRENT_PDB                 EQU 80  ; 80     50
GET_CURRENT_PDB                 EQU 81  ; 81     51
GET_IN_VARS                     EQU 82  ; 82     52
SETDPB                          EQU 83  ; 83     53
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
GET_VERIFY_ON_WRITE             EQU 84  ; 84     54
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
DUP_PDB                         EQU 85  ; 85     55
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
RENAME                          EQU 86  ; 86     56
FILE_TIMES                      EQU 87  ; 87     57
ALLOCOPER			EQU 88	; 88	 58
; Network extention system calls
GETEXTENDEDERROR		EQU 89	; 89	 59
CREATETEMPFILE			EQU 90	; 90	 5A
CREATENEWFILE			EQU 91	; 91	 5B
LOCKOPER			EQU 92	; 92	 5C Lock and Unlock
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
SERVERCALL			EQU 93	; 93	 5D CommitAll, ServerDOSCall,
					;	    CloseByName, CloseUser,
					;	    CloseUserProcess,
					;	    GetOpenFileList
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
USEROPER			EQU 94	; 94	 5E Get and Set
ASSINGOPER			EQU 95	; 95	 5F On, Off, Get, Set, Cancel
XNAMETRANS			EQU 96	; 96	 60
PATHPARSE			EQU 97	; 97	 61
GETCURRENTPSP			EQU 98	; 98	 62
HONGEUL 			EQU 99	; 99	 63
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
SET_PRINTER_FLAG		EQU 100 ; 100	 64
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
GETEXTCNTRY			EQU 101 ; 101	 65 
GETSETCDPG			EQU 102 ; 102	 66
EXTHANDLE			EQU 103 ; 103	 67
COMMIT				EQU 104 ; 104	 68

; 29/04/2019 - Retro DOS v4.0
; (MSDOS 6.0, SYSCALL.INC, 1987)

GetSetMediaID			EQU 105 ; 105	 69
IFS_IOCTL			EQU 107 ; 107	 6B
ExtOpen 			EQU 108 ; 108	 6C

;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
;ifdef ROMEXEC
;ROM_FIND_FIRST			EQU 109 ; 109    6D
;ROM_FIND_NEXT			EQU 110 ; 110    6E
;ROM_EXCLUDE			EQU 111 ; 111	 6F		; M035
;endif
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;

SET_OEM_HANDLER			EQU 248 ; 248    F8
;OEM_C1				EQU 249 ; 249    F9
;OEM_C2				EQU 250 ; 250    FA
;OEM_C3				EQU 251 ; 251    FB
;OEM_C4				EQU 252 ; 252    FC
;OEM_C5				EQU 253 ; 253    FD
;OEM_C6				EQU 254 ; 254    FE
;OEM_C7				EQU 255 ; 255    FF

;============================================================================
; VERSIONA.INC (MSDOS 6.0, 1991)
;============================================================================
; 24/04/2019 - Retro DOS 4.0

;MAJOR_VERSION	EQU     6
;;MINOR_VERSION	EQU	00
;MINOR_VERSION	EQU     21  ; MSDOS 6.21

; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
;MAJOR_VERSION	EQU     5
;MINOR_VERSION	EQU     0

; 30/12/2022 - Retro DOS v4.2
MAJOR_VERSION	EQU     6
MINOR_VERSION	EQU     22

;============================================================================
; INTNAT.INC, MSDOS 3.3, 1987
;============================================================================
; 09/07/2018 - Retro DOS 3.0

; Current structure of the data returned by the international call

struc	INTERNAT_BLOCK		; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
.Date_tim_format:
		RESW 1		; 0-USA, 1-EUR, 2-JAP
.Currency_sym:
		RESB 5		; Currency Symbol 5 bytes
.Thous_sep:
		RESB 2		; Thousands separator 2 bytes
.Decimal_sep:
		RESB 2		; Decimal separator 2 bytes
.Date_sep:
		RESB 2		; Date separator 2 bytes
.Time_sep:
		RESB 2		; Time separator 2 bytes
.Bit_field:	
		RESB 1		; Bit values
                                   ;   Bit 0 = 0 if currency symbol first
                                   ;         = 1 if currency symbol last
                                   ;   Bit 1 = 0 if No space after currency symbol
                                   ;         = 1 if space after currency symbol
.Currency_cents:
		RESB 	1	; Number of places after currency dec point
.Time_24:
		RESB 	1	; 1 if 24 hour time, 0 if 12 hour time
.Map_call:
		RESW	1	; Address of case mapping call (DWORD)
                RESW	1       ; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
				;  in pieces.
.Data_sep:
		RESB	2	; Data list separator character
.size:		
endstruc

; Max size of the block returned by the INTERNATIONAL call

internat_block_max	EQU	32

;============================================================================
; SYSVAR.INC (MSDOS 6.0, 1991)
;============================================================================
; 08/07/2018 - Retro DOS v3.0

;SysInitVars STRUC
struc SYSI
.DPB:	    resd 1		; DPB chain
.SFT:	    resd 1		; SFT chain
.CLOCK:	    resd 1		; CLOCK device
.CON:	    resd 1		; CON device
.MAXSEC:    resw 1		; maximum sector size
.BUF:	    resd 1		; points to Hashinitvar
.CDS:	    resd 1		; CDS list
.FCB:	    resd 1		; FCB chain
.Keep:	    resw 1		; keep count
.NUMIO:	    resb 1		; Number of block devices
.NCDS:	    resb 1		; number of CDS's
.DEV:	    resd 1		; device list
; 09/07/2018
; Above parameters are described in MSDOS 3.3 SYSVAR.INC (85/04/10)
; Following parameters are used with MSDOS 6.0 (Retro DOS v4.0)
.ATTR:	    resw 1		; null device attribute word
.STRAT:	    resw 1		; null device strategy entry point
.INTER:	    resw 1		; null device interrupt entry point
.NAME:	    resb 8		; null device name
.SPLICE:    resb 1		; TRUE -> splicees being done
.IBMDOS_SIZE: resw 1		; DOS size in paragraphs
.IFS_DOSCALL@: resd 1		; IFS DOS service routine entry
.IFS:	    resd 1		; IFS header chain
.BUFFERS:   resw 2		; BUFFERS= values (m,n)
.BOOT_DRIVE: resb 1		; boot drive A=1 B=2,..
.DWMOVE:    resb 1		; 1 if 386 machine
.EXT_MEM:   resw 1		; Extended memory size in KB.
endstruc
;SysInitVars ENDS

;This is added for more information exchange between DOS, BIOS.
;DOS will give the pointer to SysInitTable in ES:DI. - J.K. 5/29/86

;SysInitVars_Ext struc
struc SYSI_EXT
.SysInitVars:	resd 1		; Points to the above structure.
.Country_Tab:	resd 1		; DOS_Country_cdpg_info
endstruc
;SysInitVars_Ext ends

;============================================================================
; IOCTL.INC - MSDOS 6.0 - 1991
;============================================================================
; 09/07/2018 - Retro DOS v3.0

;*** J.K.
;General Guide -
;Category Code:
; 0... .... DOS Defined
; 1... .... User defined
; .xxx xxxx Code

;Function Code:
; 0... .... Return error if unsupported
; 1... .... Ignore if unsupported
; .0.. .... Intercepted by DOS
; .1.. .... Passed to driver
; ..0. .... Sends data/commands to device
; ..1. .... Quries data/info from device
; ...x .... Subfunction
;
; Note that "Sends/queries" data bit is intended only to regularize the
; function set.  It plays no critical role; some functions may contain both
; command and query elements. The convention is that such commands are
; defined as "sends data".

;*****************************;*
; BLOCK DRIVERS 	      ;*
;*****************************;*

; IOCTL SUB-FUNCTIONS
; (MSDOS 3.3 + MSDOS 6.0)
IOCTL_GET_DEVICE_INFO	EQU	0
IOCTL_SET_DEVICE_INFO	EQU	1
IOCTL_READ_HANDLE	EQU	2
IOCTL_WRITE_HANDLE	EQU	3
IOCTL_READ_DRIVE	EQU	4
IOCTL_WRITE_DRIVE	EQU	5
IOCTL_GET_INPUT_STATUS	EQU	6
IOCTL_GET_OUTPUT_STATUS EQU	7
IOCTL_CHANGEABLE?	EQU	8
IOCTL_DeviceLocOrRem?	EQU	9
IOCTL_HandleLocOrRem?	EQU	0Ah   ;10
IOCTL_SHARING_RETRY	EQU	0Bh   ;11
GENERIC_IOCTL_HANDLE	EQU	0Ch   ;12
GENERIC_IOCTL		EQU	0Dh   ;13
; (MSDOS 6.0 + MSDOS 3.3)
IOCTL_GET_DRIVE_MAP 	EQU	0Eh   ;14
IOCTL_SET_DRIVE_MAP	EQU	0Fh   ;15
; (MSDOS 6.0)
IOCTL_QUERY_HANDLE	EQU	10h   ;16
IOCTL_QUERY_BLOCK	EQU	11h   ;17

; GENERIC IOCTL CATEGORY CODES
IOC_OTHER		EQU	0	; Other device control J.K. 4/29/86
IOC_SE			EQU	1	; SERIAL DEVICE CONTROL
IOC_TC			EQU	2	; TERMINAL CONTROL
IOC_SC			EQU	3	; SCREEN CONTROL
IOC_KC			EQU	4	; KEYBOARD CONTROL
IOC_PC			EQU	5	; PRINTER CONTROL
IOC_DC			EQU	8	; DISK CONTROL (SAME AS RAWIO)

; GENERIC IOCTL SUB-FUNCTIONS
RAWIO			EQU	8

; RAWIO SUB-FUNCTIONS
; (MSDOS 3.3 + MSDOS 6.0)
GET_DEVICE_PARAMETERS	EQU	60H
SET_DEVICE_PARAMETERS	EQU	40H
READ_TRACK		EQU	61H
WRITE_TRACK		EQU	41H
VERIFY_TRACK		EQU	62H
FORMAT_TRACK		EQU	42H
; (MSDOS 6.0)
GET_MEDIA_ID		EQU	66h	;AN000;AN003;changed from 63h
SET_MEDIA_ID		EQU	46h	;AN000;AN003;changed from 43h
GET_ACCESS_FLAG 	EQU	67h	;AN002;AN003;Unpublished function.Changed from 64h
SET_ACCESS_FLAG 	EQU	47h	;AN002;AN003;Unpublished function.Changed from 44h
SENSE_MEDIA_TYPE	EQU	68H	;Added for 5.00

; SPECIAL FUNCTION FOR GET DEVICE PARAMETERS
BUILD_DEVICE_BPB	EQU	000000001B

; SPECIAL FUNCTIONS FOR SET DEVICE PARAMETERS
INSTALL_FAKE_BPB	EQU	000000001B
ONLY_SET_TRACKLAYOUT	EQU	000000010B
TRACKLAYOUT_IS_GOOD	EQU	000000100B

; SPECIAL FUNCTION FOR FORMAT TRACK
; (MSDOS 3.3 + MSDOS 6.0)
STATUS_FOR_FORMAT	EQU	000000001B
; (MSDOS 6.0)
DO_FAST_FORMAT		EQU	000000010B ;AN001;

; CODES RETURNED FROM FORMAT STATUS CALL
FORMAT_NO_ROM_SUPPORT	EQU	000000001B
FORMAT_COMB_NOT_SUPPORTED EQU	000000010B

; DEVICETYPE VALUES
; (MSDOS 3.3 + MSDOS 6.0)
MAX_SECTORS_IN_TRACK	EQU	63	; MAXIMUM SECTORS ON A DISK.(Was 40 in DOS 3.2)
DEV_5INCH		EQU	0
DEV_5INCH96TPI		EQU	1
DEV_3INCH720KB		EQU	2
DEV_8INCHSS		EQU	3
DEV_8INCHDS		EQU	4
DEV_HARDDISK		EQU	5
DEV_OTHER		EQU	7
; (MSDOS 6.0)
;DEV_3INCH1440KB	EQU	7
DEV_3INCH2880KB		EQU	9
; Retro DOS v2.0 - 26/03/2018
;;DEV_TAPE		EQU	6
;;DEV_ERIMO		EQU	8
;DEV_3INCH2880KB	EQU	9
DEV_3INCH1440KB		EQU	10

; (MSDOS 3.3)
;MAX_DEV_TYPE		EQU	7

; (MSDOS 6.0)
MAX_DEV_TYPE		EQU	10	; MAXIMUM DEVICE TYPE THAT WE
					; CURRENTLY SUPPORT.
struc A_SECTORTABLE
.ST_SECTORNUMBER:	resw	1
.ST_SECTORSIZE:		resw	1
.size:
endstruc

;============================================================================
; DEVSYM.INC
;============================================================================
; 07/07/2018 - Retro DOS v3.0
; 30/04/2019 - Retro DOS v4.0 (DEVSYM.INC, MSDOS 6.0, 1991)

;**	DevSym.inc - Device Symbols

; The device table list has the form:
struc	SYSDEV
.NEXT:		resd 1		;Pointer to next device header
.ATT:		resw 1		;Attributes of the device
.STRAT:		resw 1		;Strategy entry point
.INT:		resw 1		;Interrupt entry point
.NAME:		resb 8		;Name of device (only first byte used for block)
.size:
endstruc

;
; ATTRIBUTE BIT MASKS
;
; CHARACTER DEVICES:
;
; BIT 15 -> MUST BE 1
;     14 -> 1 IF THE DEVICE UNDERSTANDS IOCTL CONTROL STRINGS
;     13 -> 1 IF THE DEVICE SUPPORTS OUTPUT-UNTIL-BUSY
;     12 -> UNUSED
;     11 -> 1 IF THE DEVICE UNDERSTANDS OPEN/CLOSE
;     10 -> MUST BE 0
;      9 -> MUST BE 0
;      8 -> UNUSED
;      7 -> UNUSED
;      6 -> UNUSED
;      5 -> UNUSED
;      4 -> 1 IF DEVICE IS RECIPIENT OF INT 29H
;      3 -> 1 IF DEVICE IS CLOCK DEVICE
;      2 -> 1 IF DEVICE IS NULL DEVICE
;      1 -> 1 IF DEVICE IS CONSOLE OUTPUT
;      0 -> 1 IF DEVICE IS CONSOLE INPUT
;
; BLOCK DEVICES:
;
; BIT 15 -> MUST BE 0
;     14 -> 1 IF THE DEVICE UNDERSTANDS IOCTL CONTROL STRINGS
;     13 -> 1 IF THE DEVICE DETERMINES MEDIA BY EXAMINING THE FAT ID BYTE.
;	    THIS REQUIRES THE FIRST SECTOR OF THE FAT TO *ALWAYS* RESIDE IN
;	    THE SAME PLACE.
;     12 -> UNUSED
;     11 -> 1 IF THE DEVICE UNDERSTANDS OPEN/CLOSE/REMOVABLE MEDIA
;     10 -> MUST BE 0
;      9 -> MUST BE 0
;      8 -> UNUSED
;      7 -> UNUSED
;      6 -> IF DEVICE HAS SUPPORT FOR GETMAP/SETMAP OF LOGICAL DRIVES.
;	    IF THE DEVICE UNDERSTANDS GENERIC IOCTL FUNCTION CALLS.
;      5 -> UNUSED
;      4 -> UNUSED
;      3 -> UNUSED
;      2 -> UNUSED
;      1 -> UNUSED
;      0 -> UNUSED
;

;Attribute bit masks
DEVTYP	EQU     8000H           ;Bit 15 - 1 if Char, 0 if block
DEVIOCTL EQU    4000H           ;Bit 14 - CONTROL mode bit
ISFATBYDEV EQU  2000H           ;Bit 13 - Device uses FAT ID bytes, comp media.

; 09/07/2018 - Retro DOS (DEVSYM.INC, MSDOS 3.3, 1987) 

OUTTILBUSY EQU	2000H		; OUTPUT UNTIL BUSY IS ENABLED
ISNET	   EQU	1000H		; BIT 12 - 1 IF A NET DEVICE, 0 IF
				;  NOT.  CURRENTLY BLOCK ONLY.
DEVOPCL    EQU	0800H		; BIT 11 - 1 IF THIS DEVICE HAS
				;  OPEN,CLOSE AND REMOVABLE MEDIA
				;  ENTRY POINTS, 0 IF NOT

EXTENTBIT  EQU	0400H		; BIT 10 - CURRENTLY 0 ON ALL DEVS
				;  THIS BIT IS RESERVED FOR FUTURE USE
				;  TO EXTEND THE DEVICE HEADER BEYOND
				;  ITS CURRENT FORM.

; NOTE BIT 9 IS CURRENTLY USED ON IBM SYSTEMS TO INDICATE "DRIVE IS SHARED".
;    SEE IOCTL FUNCTION 9. THIS USE IS NOT DOCUMENTED, IT IS USED BY SOME
;    OF THE UTILITIES WHICH ARE SUPPOSED TO FAIL ON SHARED DRIVES ON SERVER
;    MACHINES (FORMAT,CHKDSK,RECOVER,..).

IOQUERY	EQU	0080H		;Bit 7 - Supports generic IOCtl query

DEV320	EQU	0040H		;BIT 6 - FOR BLOCK DEVICES, THIS
				;DEVICE SUPPORTS SET/GET MAP OF
				;LOGICAL DRIVES, AND SUPPORTS
				;GENERIC IOCTL CALLS.
				;FOR CHARACTER DEVICES, THIS
				;DEVICE SUPPORTS GENERIC IOCTL.
				;THIS IS A DOS 3.2 DEVICE DRIVER.

ISSPEC	EQU     0010H		;Bit 4 - This device is special ; 15/03/2018
;ISIBM	EQU     0010H		;Bit 4 - This device is special
ISCLOCK EQU     0008H           ;Bit 3 - This device is the clock device.
ISNULL  EQU     0004H           ;Bit 2 - This device is the null device.
ISCOUT  EQU     0002H           ;Bit 1 - This device is the console output.
ISCIN   EQU     0001H           ;Bit 0 - This device is the console input.

EXTDRVR	EQU	0002h		;BIT 1 - BLOCK DEVICE EXTENDED DRIVER
				; (MSDOS 6.0, DEVSYM.INC, 1991) ; 30/04/2019

;Static Reguest Header
struc	SRHEAD
.REQLEN:	resb 1		;Length in bytes of request block
.REQUNIT:	resb 1		;Device unit number
.REQFUNC:	resb 1		;Type of request
.REQSTAT:	resw 1		;Status Word
        	resb 8		;Reserved for queue links
.size:
endstruc

;Status word masks
STERR   EQU     8000H           ;Bit 15 - Error
STBUI   EQU     0200H           ;Bit 9 - Buisy
STDON   EQU     0100H           ;Bit 8 - Done
STECODE EQU     00FFH           ;Error code
WRECODE EQU     0

;Function codes
DINITHL EQU     26              ;Size of init header
DMEDHL  EQU     15              ;Size of media check header
DBPBHL  EQU     22              ;Size of Get BPB header
DRDWRHL EQU     22              ;Size of RD/WR header
DRDNDHL EQU     14              ;Size of non destructive read header
DSTATHL EQU     13              ;Size of status header
DFLSHL  EQU     15              ;Size of flush header

DEVINIT EQU     0               ;Initialization
DEVMDCH EQU     1               ;Media check
DEVBPB  EQU     2               ;Get BPB
DEVRDIOCTL EQU  3               ;IOCTL read
DEVRD   EQU     4               ;Read
DEVRDND EQU     5               ;Non destructive read no wait (character devs)
DEVIST  EQU     6               ;Input status
DEVIFL  EQU     7               ;Input flush
DEVWRT  EQU     8               ;Write
DEVWRTV EQU     9               ;Write with verify
DEVOST  EQU     10              ;Output status
DEVOFL  EQU     11              ;Output flush
DEVWRIOCTL EQU  12              ;IOCTL write

; 09/07/2018 - Retro DOS v3.0 (DEVSYM.INC, MSDOS 3.3, 1987) 
DEVOPN	EQU	13		;DEVICE OPEN
DEVCLS	EQU	14		;DEVICE CLOSE
DOPCLHL EQU	13		;SIZE OF OPEN/CLOSE HEADER
DEVRMD	EQU	15		;REMOVABLE MEDIA
; 07/08/2018 - Retro DOS v3.0
REMHL	EQU	13		;SIZE OF REMOVABLE MEDIA HEADER
GENIOCTL EQU	19

; THE NEXT THREE ARE USED IN DOS 4.0
;		     20
;		     21
;		     22

DEVGETOWN      EQU   23		;GET DEVICE OWNER
DEVSETOWN      EQU   24		;SET DEVICE OWNER
; 18/05/2019 - Retro DOS v4.0
IOCTL_QUERY    EQU   25		;Query generic ioctl support

OWNHL	       EQU   13		;SIZE OF DEVICE OWNER HEADER

DEVOUT	       EQU   16		; OUTPUT UNTIL BUSY.
DEVOUTL        EQU   DEVWRT	; LENGTH OF OUTPUT UNTIL BUSY

; ADDED FOR DOS 5.00

; GENERIC IOCTL REQUEST STRUCTURE
;	SEE THE DOS 4.0 DEVICE DRIVER SPEC FOR FURTHER ELABORATION.

struc IOCTL_REQ
.SRHEAD:	resb SRHEAD.size
				; GENERIC IOCTL ADDITION.
.MAJORFUNCTION: resb 1		;FUNCTION CODE
.MINORFUNCTION: resb 1		;FUNCTION CATEGORY
.REG_SI:	resw 1
.REG_DI:	resw 1
.GENERICIOCTL_PACKET: resd 1	; POINTER TO DATA BUFFER
.size: ; 07/08/2018
endstruc

; DEFINITIONS FOR IOCTL_REQ.MINORFUNCTION
GEN_IOCTL_WRT_TRK EQU	40H
GEN_IOCTL_RD_TRK  EQU	60H
GEN_IOCTL_FN_TST  EQU	20H	; USED TO DIFF. BET READS AND WRTS

;; 32-bit absolute read/write input list structure

struc ABS_32RW
.SECTOR_RBA:	resd 1		; relative block address
.ABS_RW_COUNT:	resw 1		; number of sectors to be transferred
.BUFFER_ADDR:	resd 1		; data addrress
.size:
endstruc

;; media ID info

struc MEDIA_ID_INFO
.MEDIA_level:	resw	1	; info level
.MEDIA_Serial:	resd	1	; serial #
.MEDIA_Label:	resb	11	; volume label
.MEDIA_System:	resb	8	; system type
.size:
endstruc

; equates for DOS34_FLAG
; (BUGBUG: why are bits 0,1,3 and 4 not defined.)

FROM_DISK_RESET       EQU   000000000100b   ;from disk reset
Force_I24_Fail	      EQU   000000100000b   ;form IFS CALL BACK
Disable_EOF_I24       EQU   000001000000b   ;disable EOF int24 for input status
DBCS_VOLID	      EQU   000010000000b   ;indicate from volume id
DBCS_VOLID2	      EQU   000100000000b   ;indicate 8th char is DBCS
CTRL_BREAK_FLAG       EQU   001000000000b   ;indicate control break is input
SEARCH_FASTOPEN       EQU   010000000000b   ;set fastopen flag for search
EXEC_AWARE_REDIR      EQU   100000000000b   ;M018: this bit is set by a redir 
					    ;M018: that knows how to handle 
					    ;M018: open for exec

NO_FROM_DISK_RESET    EQU   ~FROM_DISK_RESET	;not from disk reset
NO_Force_I24_Fail     EQU   ~Force_I24_Fail	;not form IFS CALL BACK
NO_Disable_EOF_I24    EQU   ~Disable_EOF_I24

;============================================================================
; ERROR.INC (MSDOS 6.0, 1991)
;============================================================================
; 16/07/2018 - Retro DOS v3.0 

;**	ERROR.INC - DOS Error Codes
;
;    The newer (DOS 2.0 and above) "XENIX-style" calls
;    return error codes through AX. If an error occurred then
;    the carry bit will be set and the error code is in AX. If no error
;    occurred then the carry bit is reset and AX contains returned info.
;
;    Since the set of error codes is being extended as we extend the operating
;    system, we have provided a means for applications to ask the system for a
;    recommended course of action when they receive an error.
;
;    The GetExtendedError system call returns a universal error, an error
;    location and a recommended course of action. The universal error code is
;    a symptom of the error REGARDLESS of the context in which GetExtendedError
;    is issued.

;	2.0 error codes

error_invalid_function		EQU	1
error_file_not_found		EQU	2
error_path_not_found		EQU	3
error_too_many_open_files	EQU	4
error_access_denied		EQU	5
error_invalid_handle		EQU	6
error_arena_trashed		EQU	7
error_not_enough_memory 	EQU	8
error_invalid_block		EQU	9
error_bad_environment		EQU	10
error_bad_format		EQU	11
error_invalid_access		EQU	12
error_invalid_data		EQU	13
;**** reserved			EQU	14	; *****
error_invalid_drive		EQU	15
error_current_directory 	EQU	16
error_not_same_device		EQU	17
error_no_more_files		EQU	18

;	These are the universal int 24 mappings for the old INT 24 set of errors

error_write_protect		EQU	19
error_bad_unit			EQU	20
error_not_ready 		EQU	21
error_bad_command		EQU	22
error_CRC			EQU	23
error_bad_length		EQU	24
error_seek			EQU	25
error_not_DOS_disk		EQU	26
error_sector_not_found		EQU	27
error_out_of_paper		EQU	28
error_write_fault		EQU	29
error_read_fault		EQU	30
error_gen_failure		EQU	31

;	the new 3.0 error codes reported through INT 24

error_sharing_violation 	EQU	32
error_lock_violation		EQU	33
error_wrong_disk		EQU	34
error_FCB_unavailable		EQU	35
error_sharing_buffer_exceeded	EQU	36
error_Code_Page_Mismatched	EQU	37    ; DOS 4.00  ;AN000;
error_handle_EOF		EQU	38    ; DOS 4.00  ;AN000;
error_handle_Disk_Full		EQU	39    ; DOS 4.00  ;AN000;

;	New OEM network-related errors are 50-79

error_not_supported		EQU	50

error_net_access_denied		EQU	65	;M028

;	End of INT 24 reportable errors

error_file_exists		EQU	80
error_DUP_FCB			EQU	81	; *****
error_cannot_make		EQU	82
error_FAIL_I24			EQU	83

;	New 3.0 network related error codes

error_out_of_structures 	EQU	84
error_already_assigned		EQU	85
error_invalid_password		EQU	86
error_invalid_parameter 	EQU	87
error_NET_write_fault		EQU	88
error_sys_comp_not_loaded	EQU	90    ; DOS 4.00  ;AN000;

;	BREAK <Interrupt 24 error codes>

;**	Int24 Error Codes

error_I24_write_protect 	EQU	0
error_I24_bad_unit		EQU	1
error_I24_not_ready		EQU	2
error_I24_bad_command		EQU	3
error_I24_CRC			EQU	4
error_I24_bad_length		EQU	5
error_I24_Seek			EQU	6
error_I24_not_DOS_disk		EQU	7
error_I24_sector_not_found	EQU	8
error_I24_out_of_paper		EQU	9
error_I24_write_fault		EQU	0Ah
error_I24_read_fault		EQU	0Bh
error_I24_gen_failure		EQU	0Ch
; NOTE: Code 0DH is used by MT-DOS.
error_I24_wrong_disk		EQU	0Fh

;	THE FOLLOWING ARE MASKS FOR THE AH REGISTER ON Int 24
;
;	NOTE: ABORT is ALWAYS allowed

Allowed_FAIL			EQU	00001000B
Allowed_RETRY			EQU	00010000B
Allowed_IGNORE			EQU	00100000B

I24_operation			EQU	00000001B  ;Z if READ,NZ if Write
I24_area			EQU	00000110B  ; 00 if DOS
						   ; 01 if FAT
						   ; 10 if root DIR
						   ; 11 if DATA
I24_class			EQU	10000000B  ;Z if DISK, NZ if FAT or char

;	BREAK <GetExtendedError CLASSes ACTIONs LOCUSs>

;**	The GetExtendedError call takes an error code and returns CLASS,
;	ACTION and LOCUS codes to help programs determine the proper action
;	to take for error codes that they don't explicitly understand.

;	Values for error CLASS

errCLASS_OutRes 	EQU	1	; Out of Resource
errCLASS_TempSit	EQU	2	; Temporary Situation
errCLASS_Auth		EQU	3	; Permission problem
errCLASS_Intrn		EQU	4	; Internal System Error
errCLASS_HrdFail	EQU	5	; Hardware Failure
errCLASS_SysFail	EQU	6	; System Failure
errCLASS_Apperr 	EQU	7	; Application Error
errCLASS_NotFnd 	EQU	8	; Not Found
errCLASS_BadFmt 	EQU	9	; Bad Format
errCLASS_Locked 	EQU	10	; Locked
errCLASS_Media		EQU	11	; Media Failure
errCLASS_Already	EQU	12	; Collision with Existing Item
errCLASS_Unk		EQU	13	; Unknown/other

;	Values for error ACTION

errACT_Retry		EQU	1	; Retry
errACT_DlyRet		EQU	2	; Delay Retry, retry after pause
errACT_User		EQU	3	; Ask user to regive info
errACT_Abort		EQU	4	; abort with clean up
errACT_Panic		EQU	5	; abort immediately
errACT_Ignore		EQU	6	; ignore
errACT_IntRet		EQU	7	; Retry after User Intervention

;	Values for error LOCUS

errLOC_Unk		EQU	1	; No appropriate value
errLOC_Disk		EQU	2	; Random Access Mass Storage
errLOC_Net		EQU	3	; Network
errLOC_SerDev		EQU	4	; Serial Device
errLOC_Mem		EQU	5	; Memory

;============================================================================
; INT2A.INC (MSDOS 6.0, 1991)
;============================================================================
; 04/05/2019 - Retro DOS v4.0

;**	Int 2A functions
; ---------------------------------------------------------------------------
;	Int 2A is an interface to the network code; it's also overloaded
;		as a critical section handler since critical sections
;		were originally created to support the net.
; ---------------------------------------------------------------------------

; ---------------------------------------------------------------------------
;**	This table was created by examining the source and may not be
;	complete or completely accurate - JGL
;
;	M010	MD	8/31/90 - Added definition for AH = 5

;	(ah) = 0	installation check
;			   (returns ah !=0 if installed)
;	(ah) = 1	cooked net bios call
;	(ah) = 3	query drive shared
;			   (ds:si) = "n:" asciz string
;	(ah) = 4	net bios
;	       (al) = 0	   cooked net bios call
;	       (al) = 1	   raw net bios call
;	       (al) = 2	   ???
;
;	(ah) = 5	Get Net Adaptor Resources. CX returns the number of
;			NCBs available/outstanding. DX returns the number of
;			sessions. Supposedly, this is documented in an old
;			IBM PC-LAN reference. Lotus Notes uses it. DOS LAN
;			Manager 2.0 Enhanced responds to it. But it should
;			not be used, as it is a hack, only to get Lotus
;			Notes running.
;
;	(ah) = 80h	enter critical section
;	(ah) = 81h	leave critical section
;	(ah) = 82h	free all critical sections (Leave-all)
;	(ah) = 84h	entering idle loop (don't understand how this works)
; ---------------------------------------------------------------------------

;**	Critical section definitions
; ---------------------------------------------------------------------------
;	Although DOS is not designed to be reentrant there are some hacks
;	which various programs use to make it so, in a limited fashion.
;	Both WIN386 and some servers block copy a section of the DOS data
;	area so that DOS can be reentered on behalf of another thread/program.
;	DOS's global data structures, such as the memory arena, are not
;	in this area, so critical section indicators are used to protect
;	those areas.  DOS flags a critical section by issuing an INT_IBM
;	(int 2Ah) at each critical section entry and exit.  Some clients
;	(such as WIN386) just don't "context switch" the DOS when one
;	of these is in effect, others, such as the IBM server, go ahead
;	and reenter the DOS and if they get an int 2A to reenter the same
;	critical section they then switch away from that second thread and
;	let the first one finish and exit the section.
; ---------------------------------------------------------------------------

; These below are subject to leave-all sections
critDisk    EQU     1			; Disk I/O critical section
critShare   EQU     1			; Sharer I/O critical section
critMem     EQU     1			; memory maintenance critical section
critSFT     EQU     1			; sft table allocation
critDevice  EQU     2			; Device I/O critical section
critNet     EQU     5			; network critical section
critIFS     EQU     6			; ifsfunc critical section
; These below are not subject to leave-all sections
critASSIGN  EQU     8			; Assign has munged a system call

;============================================================================
; MULT.INC (MSDOS 6.0, 1991)
;============================================================================
; 04/05/2019 - Retro DOS v4.0

;Break <Multiplex channels>

; ---------------------------------------------------------------------------
; The current set of defined multiplex channels is (* means documented):
;
;   Channel(h)  Issuer          Receiver    Function
;      00       server          PSPRINT     print job control
;     *01       print/apps      PRINT       Queueing of files
;      02       BIOS            REDIR       signal open/close of printers
;
;      05       command         REDIR       obtain text of net int 24 message
;     *06       server/assign   ASSIGN      Install check
;
;      08       external driver IBMBIO      interface to internal routines
;
;      10       sharer/server   Sharer      install check
;      11       DOS/server      Redir       install check/redirection funcs
;      12       sharer/redir    DOS         dos functions and structure maint
;      13       MSNET           MSNET       movement of NCBs
;      13       external driver IBMBIO      Reset_Int_13, allows installation
;                                           of alternative INT_13 drivers after
;                                           boot_up
;      14 (IBM) DOS             NLSFUNC     down load NLS country info,DOS 3.3
;      14 (MS)  APPS            POPUP       MSDOS 4 popup screen functions
;      15       APPS            MSCDEX      CD-ROM extensions interface
;      16       WIN386          WIN386      Windows communications
;      17       Clipboard       WINDOWS     Clipboard interface
;     *18       Applications    MS-Manger   Toggle interface to manager
;      19       Shell
;      1A       Ansi.sys
;      1B       Fastopen,Vdisk   IBMBIO     EMS INT 67H stub handler
;
;      40h      OS/2
;      41h      Lanman
;      42h      Lanman
;      43h      Himem
;                               AL = 20h    reserved for Mach 20 Himem support
;                               AL = 30h    reserved for Himem external A20 code
;      44h      Dosextender
;      45H      Windows profiler
;      46h      Windows/286 DOS extender
;      47h      Basic Compiler Vn. 7.0
;      48h      Doskey
;      49h      DOS 5.x install 
;      4Ah      Multi Purpose
;                multMULTSWPDSK         0 - Swap Disk in drive A (BIOS)
;                multMULTGETHMAPTR      1 - Get available HMA & ptr
;                multMULTALLOCHMA       2 - Allocate HMA (bx == no of bytes)
;                multMULTTASKSHELL      5 - Shell/switcher API
;                multMULTRPLTOM         6 - Top Of Memory for RPL support
;
;                multSmartdrv           10h
;                multMagicdrv           11h
;      4Bh      Task Switcher API
;
;      4Ch      APPS            APM         Advanced power management
;      4Dh      Kana Kanji Converter, MSKK
;
;      51h      ODI real mode support driver (for Chicago)
;
;      53h      POWER.EXE - used for broadcasting APM events    ; M036
;      54h      POWER.EXE - used for POWER API                  ; M036
;
;      55h      COMMAND.COM
;                multCOMFIRST           0 - API to determine whether 1st
;                                           instance of command.com
;                multCOMFIRSTROM        1 - API to determine whether 1st
;                                           instance of ROM COMMAND
;      56h      Sewell Development
;               INTERLNK
;
;      57h      Iomega Corp.
;
;      ABh      Unspecified IBM use
;      ACh      Graphics
;      ADh      NLS (toronto)
;      AEh
;      AFh      Mode
;      B0h      GRAFTABL        GRAFTABL
;
;      D7h      Banyan VINES
; ---------------------------------------------------------------------------

;MUX 00-3F reserverd for IBM
;MUX 80-BF reserverd for IBM

;MUX 40-7F reserved for Microsoft

;MUX C0-FF users

MultSHARE   EQU     10h 		; sharer
    ;	1   MFT_enter
    ;	2   MFTClose
    ;	3   MFTclU
    ;	4   MFTCloseP
    ;	5   MFTCloN
    ;	6   set_block
    ;	7   clr_block
    ;	8   chk_block
    ;	9   MFT_get
    ;	10  ShSave
    ;	11  ShChk
    ;	12  ShCol
    ;	13  ShCloseFile

MultNET     EQU     11h 		; Network support
MultIFS     EQU     11h                 ; Network support
    ;   1   IFS_RMDIR
    ;   2   IFS_SEQ_RMDIR
    ;   3   IFS_MKDIR
    ;   4   IFS_SEQ_MKDIR
    ;   5   IFS_CHDIR
    ;   6   IFS_CLOSE
    ;   7   IFS_COMMIT
    ;   8   IFS_READ
    ;   9   IFS_WRITE
    ;   10  IFS_LOCK
    ;   11  IFS_UNLOCK
    ;   12  IFS_DISK_INFO
    ;   13  IFS_SET_FILE_ATTRIBUTE
    ;   14  IFS_SEQ_SET_FILE_ATTRIBUTE
    ;   15  IFS_GET_FILE_INFO
    ;   16  IFS_SEQ_GET_FILE_INFO
    ;   17  IFS_RENAME
    ;   18  IFS_SEQ_RENAME
    ;   19  IFS_DELETE
    ;   20  IFS_SEQ_DELETE
    ;   21  IFS_OPEN
    ;   22  IFS_SEQ_OPEN
    ;   23  IFS_CREATE
    ;   24  IFS_SEQ_CREATE
    ;   25  IFS_SEQ_SEARCH_FIRST
    ;   26  IFS_SEQ_SEARCH_NEXT
    ;   27  IFS_SEARCH_FIRST
    ;   28  IFS_SEARCH_NEXT
    ;   29  IFS_ABORT
    ;   30  IFS_ASSOPER
    ;   31  Printer_SET_STRING
    ;   32  IFSFlushBuf
    ;   33  IFSBufWrite
    ;   34  IFSResetEnvironment
    ;   35  IFSSpoolCheck
    ;   36  IFSSpoolClose
    ;   37  IFSDeviceOper
    ;   38  IFSSpoolEchoCheck
    ;   39      - - -   Unused   - - -
    ;   40      - - -   Unused   - - -
    ;   41      - - -   Unused   - - -
    ;   42  SERVER_DOSCALL_CLOSEFILES_FOR_UID
    ;   43  DEVICE_IOCTL
    ;   44  IFS_UPDATE_CB
    ;   45  IFS_FILE_XATTRIBUTES
    ;   46  IFS_XOPEN
    ;   47  IFS_DEPENDENT_IOCTL

MultDOS     EQU     12h 		; DOS call back
    ;	1   DOS_CLOSE
    ;	2   RECSET
    ;	3   Get DOSGROUP
    ;	4   PATHCHRCMP
    ;	5   OUT
    ;	6   NET_I24_ENTRY
    ;	7   PLACEBUF
    ;	8   FREE_SFT
    ;	9   BUFWRITE
    ;	10  SHARE_VIOLATION
    ;	11  SHARE_ERROR
    ;	12  SET_SFT_MODE
    ;	13  DATE16
    ;	14  SETVISIT
    ;	15  SCANPLACE
    ;	16  SKIPVISIT
    ;	17  StrCpy
    ;	18  StrLen
    ;	19  UCase
    ;	20  POINTCOMP
    ;	21  CHECKFLUSH
    ;	22  SFFromSFN
    ;	23  GetCDSFromDrv
    ;	24  Get_User_Stack
    ;	25  GetThisDrv
    ;	26  DriveFromText
    ;	27  SETYEAR
    ;	28  DSUM
    ;	29  DSLIDE
    ;	30  StrCmp
    ;	31  initcds
    ;	32  pjfnfromhandle
    ;	33  $NameTrans
    ;	34  CAL_LK
    ;	35  DEVNAME
    ;	36  Idle
    ;   37  DStrLen
    ;   38  NLS_OPEN      DOS 3.3
    ;   39  $CLOSE        DOS 3.3
    ;   40  NLS_LSEEK     DOS 3.3
    ;   41  $READ         DOS 3.3
    ;   42  FastInit      DOS 4.0
    ;   43  NLS_IOCTL     DOS 3.3
    ;   44  GetDevList    DOS 3.3
    ;   45  NLS_GETEXT    DOS 3.3
    ;   46  MSG_RETRIEVAL DOS 4.0
    ;   47  FAKE_VERSION  DOS 4.0

NLSFUNC     EQU     14h 		; NLSFUNC CALL , DOS 3.3
    ;	0   NLSInstall
    ;	1   ChgCodePage
    ;	2   GetExtInfo
    ;	3   SetCodePage
    ;	4   GetCntry

multANSI    EQU     1Ah                 ; ANSI multiplex number
    ;   0   INSTALL_CHECK               ; install check for ANSI
    ;   1   IOCTL_2F                    ; 2F interface to IOCTL
    ;   2   DA_INFO_2F                  ; J.K. Information passing to ANSI.

multMULT        EQU     4Ah
multMAGIC       EQU     256*multMULT + 11h
multMULTRPLTOM  EQU     06h

    ;   0   swap disk function for single floppy drive m/cs
    ;       BIOS broadcasts with cx==0, and apps who handle
    ;       swap disk messaging set cx == -1. BIOS sets dl == requested
    ;       drive
    ;
    ;   1   Get available HMA & pointer to it. Returns in BX & ES:DI
    ;   2   Allocate HMA. BX == number of bytes in HMA to be allocated
    ;       returns pointer in ES:DI
    ;
    ;   3-4 currently used by nobody
    ;   5   Switcher API
    ;   6   Top of Memory for RPL.
    ;           BIOS issues INT 2f AX=4a06 & DX = Top of Mem and any RPL
    ;           code present in TOM should respond with a new TOM in DX
    ;           to protect itself from MSLOAD & SYSINIT tromping over it.
    ;           SYSINIT builds an arena with owner type 8 & name 'RPL' to
    ;           protect the RPL code from COMMAND.COM transient protion.
    ;           It is the responsibility of RPL program to release the mem.
    ;   7   Reserved for PROTMAN support.
    ;  10   smartdrv 4.0
    ;  11   dblspace api
    ;  12   MRCI     api
    ;  13   dblspace/mrci stealth packet api

MultAPM     EQU     4ch             ; Obselete ???
    ;       00h     APM_VER_CHK
    ;       01h     APM_SUS_SYS_REQ
    ;       FFh     APM_SUS_RES_BATT_NOTIFY

MultPWR_BRDCST  EQU     53h     ; Used by POWER.EXE to broadcast      ; M036
				;  APM events                         ; M036
MultPWR_API     EQU     54h     ; Used for accessing POWER.EXE's API  ; M036

;FASTOPEN is not chained through INT 2F   ; DOS 3.3 F.C.
;	  it calls Multdos 42 to set up an entry routine address
    ;	0   Install status  (reserved)
    ;	1   Lookup
    ;	2   Insert
    ;	3   Delete
    ;	4   Purge	    (reserved)

;============================================================================
; FIND.INC (MSDOS 6.0, 1991)
;============================================================================
; 17/05/2019 - Retro DOS v4.0
; 09/07/2018 - Retro DOS v3.0 (MSDOS 3.3, 1987)

;Break	<find first/next buffer>

struc find_buf
.drive:	    resb 1		; drive of search
.name:	    resb 11		; formatted name
.sattr:	    resb 1		; attribute of search
.LastEnt:   resw 1		; LastEnt
.DirStart:  resw 1		; DirStart
.NETID:	    resb 4 ; MSDOS 6.0 	; Reserved for NET
.attr:	    resb 1		; attribute found
.time:	    resw 1		; time
.date:	    resw 1		; date
.size_l:    resw 1		; low(size)
.size_h:    resw 1		; high(size)
.pname:	    resb 13		; packed name
.size:
endstruc

;============================================================================
; DOSCNTRY.INC (MSDOS 6.0, 1991)
;============================================================================
; 29/04/2019 - Retro DOS v4.0
; 09/07/2018 - Retro DOS v3.0 (MSDOS 3.3, 1987)

;Equates for COUNTRY INFORMATION.
SetCountryInfo	EQU	1	;country info
SetUcase	EQU	2	;uppercase table
SetLcase	EQU	3	;lowercase table (Reserved)
SetUcaseFile	EQU	4	;uppercase file spec table
SetFileList	EQU	5	;valid file character list
SetCollate	EQU	6	;collating sequence
SetDBCS 	EQU	7	;double byte character set
SetALL		EQU	-1	;all the entries

;DOS country and code page information table structure.
;Internally, IBMDOS gives a pointer to this table.
;IBMBIO, MODE and NLSFUNC modules communicate with IBMDOS through
;this structure.

struc  DOS_CCDPG	; DOS_country_cdpg_info
.ccInfo_reserved: 	resb 8	;reserved for internal use
.ccPath_CountrySys:	resb 64 ;path and filename for country info
.ccSysCodePage:		resw 1	;system code page id
.ccNumber_of_entries:	resw 1  ; (default value = 6)
.ccSetUcase:		resb 1  ; (default value = SetUcase)
.ccUcase_ptr:		resd 1	;pointer to Ucase table

.ccSetUcaseFile:	resb 1	; (default value = SetUcaseFile)
.ccFileUcase_ptr: 	resd 1	;pointer to File Ucase table

.ccSetFileList:		resb 1 	; (default value = SetFileList)
.ccFileChar_ptr:	resd 1	;pointer to File char list table

.ccSetCollate:		resb 1	; (default value = SetCollate)
.ccCollate_ptr:		resd 1	;pointer to collate table

; MSDOS 6.0
.ccSetDBCS:		resb 1	; (default value = SetDBCS)
.ccDBCS_ptr:		resd 1	; pointer to DBCS table

.ccSetCountryInfo:	resb 1  ; (default value = SetCountryInfo)
.ccCountryInfoLen:	resw 1	;length of country info
.ccDosCountry:		resw 1	;system country code id
.ccDosCodePage:		resw 1	;system code page id
.ccDFormat:		resw 1	;date format
.ccCurSymbol:		resb 5	;5 byte of (currency symbol+0)
.cc1000Sep:		resb 2	;2 byte of (1000 sep. + 0)
.ccDecSep:		resb 2	;2 byte of (Decimal sep. + 0)
.ccDateSep:		resb 2	;2 byte of (date sep. + 0)
.ccTimeSep:		resb 2	;2 byte of (time sep. + 0)
.ccCFormat:		resb 1	;currency format flags
.ccCSigDigits:		resb 1	;# of digits in currency
.ccTFormat:		resb 1	;time format
.ccMono_ptr:		resd 1	;monocase routine entry point
.ccListSep:		resb 2	;data list separator
.ccReserved_area: 	resw 5	;reserved
.size:
endstruc

;Ucase table
struc CC_UCASE_TAB
.ccUcase_leng:		resw 1	; (default value = 128)
.ccUcase_data:		resb 128
endstruc

;File Ucase table
struc CC_FILE_UCASE_TAB
.ccFileucase_leng:	resw 1	; (default value = 128)
.ccFileucase_data:	resb 128
endstruc

;File char list
struc CC_FILE_CHAR_TAB
.ccFilechar_leng:	resw 1
.ccFilechar_data:	resb 46
endstruc

;collate table
struc CC_COLLATE_TAB
.ccCollate_leng:	resw 1	; (default value = 128)
.ccCollate_data:	resb 256
endstruc

OLD_COUNTRY_SIZE  equ	(DOS_CCDPG.size - DOS_CCDPG.ccDFormat - 10)
NEW_COUNTRY_SIZE  equ	(DOS_CCDPG.size - DOS_CCDPG.ccDosCountry) ; 38

; 06/08/2018
; DOSCNTRY.INC (MSDOS 6.0, 1991)

;CAPITALIZATION equates
CAP_ONE_CHAR	equ	20H
CAP_STRING	equ	21H
CAP_ASCIIZ	equ	22H
CHECK_YES_NO	equ	23H
UPPER_TABLE	equ	80H

;NLS_YES	equ	59H  ; 'Y'
;NLS_yes2	equ	79H  ; 'y' 	
;NLS_NO		equ	4EH  ; 'N'	
;NLS_no2	equ	6EH  ; 'n'	

;============================================================================
; CURDIR.INC (MSDOS 6.0, 1991)
;============================================================================
; 25/04/2019 - Retro DOS v4.0
; 09/07/2018 - Retro DOS v3.0 (CURDIR.INC, MSDOS 3.3, 1987)

;BREAK <Current directory list structure>

;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
; CDS items are used bu the internal routines to store cluster numbers and ;
; network identifiers for each logical name.  The ID field is used dually, ;
; both as net ID and for a cluster number for local devices.  In the case  ;
; of local devices, the cluster number will be -1 if there is a potential  ;
; of the disk being changed or if the path must be recracked.		   ;
;
;	Some pathnames have special preambles, such as
;
;		\\machine\sharename\...
;	For these pathnames we can't allow ".." processing to back us
;	up into the special front part of the name.  The CURDIR_END field
;	holds the address of the seperator character which marks
;	the split between the special preamble and the regular
;	path list; ".." processing isn't allowed to back us up past
;	(i.e., before) CURDIR_END
;	For the root, it points at the leading /.  For net
;	assignments it points at the end (nul) of the initial assignment:
;	A:/	\\foo\bar	    \\foo\bar\blech\bozo
;	  ^		 ^		     ^

DIRSTRLEN	EQU	64+3		; Max length in bytes of directory strings
TEMPLEN 	EQU	DIRSTRLEN*2

struc curdir	; curdir_list
.text:		resb DIRSTRLEN		; text of assignment and curdir
.flags:		resw 1			; various flags
.devptr:	resd 1			; local pointer to DPB or net device
.ID:		resw 2			; cluster of current dir (net ID)
.user_word:	resw 1
.end:		resw 1			; index to ".." backup limit - see above
; MSDOS 6.0
.type:		resb 1			; IFS drive (2=ifs, 4=netuse)
.ifs_hdr:	resd 1			; Ptr to File System Header
.fsda:		resb 2			; File System Dependent Data Area
.size:
endstruc

curdirLen	EQU curdir.size	; 88	; Needed for screwed up

%define curdir_netID curdir_ID  ; dword

;**	Flag values for CURDIR_FLAGS

curdir_isnet	EQU	1000000000000000B
CURDIR_isifs	EQU	1000000000000000B ; MSDOS 6.0	
curdir_inuse	EQU	0100000000000000B
curdir_splice	EQU	0010000000000000B
curdir_local	EQU	0001000000000000B

;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;

;============================================================================
; CPMFCB.INC (MSDOS 3.3, 1987)
;============================================================================
; 09/07/2018 - Retro DOS v3.0

;BREAK <File Control Block definition>

;
; Field definition for FCBs
; The FCB has the following structure:
;
;	+---------------------------+
;	|   Drive indicator(byte)   |
;	+---------------------------+
;	|    Filename (8 chars)     |
;	+---------------------------+
;	|    Extension (3 chars)    |
;	+---------------------------+
;	|   Current Extent(word)    |
;	+---------------------------+
;	|    Record size (word)     |
;	+---------------------------+
;	|    File Size (2 words)    |
;	+---------------------------+
;	|	Date of write	    |
;	+---------------------------+
;	|	Time of write	    |
;	+---------------------------+
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
;	+---------------------------+
;	|   8 bytes reserved	    |
;	+---------------------------+
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	|    next record number     |
;	+---------------------------+
;	|   random record number    |
;	+---------------------------+
;

struc	SYS_FCB
.drive:	resb 1
.name:	resb 8
.ext:	resb 3
.EXTENT: resw 1
.RECSIZ: resw 1			; Size of record (user settable)
.FILSIZ: resw 1			; Size of file in bytes; used with the
				; following word
.DRVBP:	resw 1			; BP for SEARCH FIRST and SEARCH NEXT
.FDATE:	resw 1			; Date of last writing
.FTIME:	resw 1			; Time of last writing
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
.reserved: resb 8		; RESERVED
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
.NR:	resb 1			; Next record
.RR:	resb 4			; Random record
.size:
endstruc

FILDIRENT EQU SYS_FCB.FILSIZ	; Used only by SEARCH FIRST and SEARCH
				; NEXT
; 20/07/2018
%define fcb_sfn	SYS_FCB.reserved ; byte

; Note that fcb_net_handle, fcb_nsl_drive, fcb_nsld_drive and fcb_l_drive
; all must point to the same byte.  Otherwise, the FCBRegen will fail.
; NOTE about this byte (fcb_nsl_drive)
;   The high two bits of this byte are used as follows to indicate the FCB type
;	00 means a local file or device with sharing loaded
;	10 means a remote (network) file
;	01 means a local file with no sharing loaded
;	11 means a local device with no sharing loaded

; 20/07/2018

;
; Network FCB
;

%define fcb_net_drive	SYS_FCB.reserved+1  ; byte
%define fcb_net_handle	SYS_FCB.reserved+2  ; word
%define fcb_netID	SYS_FCB.reserved+4  ; dword		

;
; No sharing local file FCB
;

%define fcb_nsl_drive	SYS_FCB.reserved+1  ; byte
%define fcb_nsl_bits	SYS_FCB.reserved+2  ; byte	
%define fcb_nsl_firclus SYS_FCB.reserved+3  ; word	
%define fcb_nsl_dirsec	SYS_FCB.reserved+5  ; word
%define fcb_nsl_dirpos  SYS_FCB.reserved+7  ; byte

;
; No sharing local device FCB
;

%define fcb_nsld_drive	SYS_FCB.reserved+1  ; byte	
%define fcb_nsld_drvptr SYS_FCB.reserved+2  ; dword

;
; Sharing local FCB
;

%define fcb_l_drive	SYS_FCB.reserved+1  ; byte
%define fcb_l_firclus	SYS_FCB.reserved+2  ; word
%define fcb_l_mfs	SYS_FCB.reserved+4  ; word
%define fcb_l_attr	SYS_FCB.reserved+6  ; byte

;
; Bogusness:  the four cases are:
;
;   local file	    00
;   local device    40
;   local sharing   C0
;   network	    80
;
; Since sharing and network collide, we cannot use a test instruction for
; deciding whether a network or a share check in involved
;
FCBDEVICE   EQU 040h
FCBNETWORK  EQU 080h
FCBSHARE    EQU 0C0h

; FCBSPECIAL must be able to mask off both net and share
FCBSPECIAL  EQU 080h
FCBMASK     EQU 0C0h

;============================================================================
; FASTOPEN.INC, MSDOS 6.0, 1991
;============================================================================
; 11/07/2018 - Retro DOS v3.0
; 25/04/2019 - Retro DOS v4.0

struc FEI	; FASTOPEN_EXTENDED_INFO
.dirpos:	resb 1
.dirsec:	resd 1 ; MSDOS 6.0
;.dirsec:	resw 1 ; MSDOS 3.3
.clusnum:	resw 1
.lastent:	resw 1	; for search first ; MSDOS 6.0
.dirstart:	resw 1	; for search first ; MSDOS 6.0
.size:
endstruc

; 23/07/2018
;FASTOPEN NAME CACHING Subfunctions
FONC_Look_up	equ	1
FONC_insert	equ	2
FONC_delete	equ	3
FONC_update	equ	4
FONC_purge	equ	5	;reserved for the future use.
FONC_Rename	equ	6	;AN001

; 27/07/2018
;FastOpen Data Structure
struc fastopen_entry	;Fastopen Entry pointer in DOS
.entry_size:	resw 1	; = 4	; size of the following
.name_caching:	resd 1
; MSDOS 6.0
;.fatchain_caching: resd 1	;reserved for future use
.size:
endstruc

; 27/07/2018
;Equates used in DOS.
FastOpen_Set	       equ     00000001b
FastOpen_Reset	       equ     11111110b
Lookup_Success	       equ     00000010b
Lookup_Reset	       equ     11111101b
Special_Fill_Set       equ     00000100b
Special_Fill_Reset     equ     11111011b
No_Lookup	       equ     00001000b
Set_For_Search	       equ     00010000b	;DCR 167

; 09/08/2018 
; (FASTXXXX.INC, MSDOS 6.0, 1991)
; Fastxxx equates
FastOpen_ID	   equ	   1
FastSeek_ID	   equ	   2
Fast_yes	   equ	   10000000B	 ; fastxxx flag

;Structure definitions
;
struc Fasttable_Entry	 ; Fastxxx  Entry pointer in DOS
.Fast_Entry_Num: resw 1	 ; number of entries
.FastOpen_Seek:	 resd 1	 ; fastopen & fastseek entry address
endstruc

;============================================================================
; LOCK.INC, MSDOS 6.0, 1991
;============================================================================
; 14/07/2018 - Retro DOS v3.0

;**	LOCK.INC - Definitions for Record Locking

;**	LOCK functions

LOCK_ALL	    equ    0
UNLOCK_ALL	    equ    1
LOCK_MUL_RANGE	    equ    2
UNLOCK_MUL_RANGE    equ    3
LOCK_READ	    equ    4
WRITE_UNLOCK	    equ    5
LOCK_ADD	    equ    6

;**	Structure for Lock buffer

struc LockBuf
.Lock_position:	resd 1		; file position for LOCK
.Lock_length:	resd 1		; number of bytes to LOCK
endstruc

;============================================================================
; DPL.ASM, MSDOS 6.0, 1991
;============================================================================
; 04/08/2018 - Retro DOS v3.0

; (SRVCALL.ASM)

struc DPL
.AX:	resw	1	; AX register
.BX:	resw	1	; BX register
.CX:	resw	1	; CX register
.DX:	resw	1	; DX register
.SI:	resw	1	; SI register
.DI:	resw	1	; DI register
.DS:	resw	1	; DS register
.ES:	resw	1	; ES register
.rsrvd: resw	1	; Reserved
.UID:	resw	1	; User (Machine) ID (0 = local macine)
.PID:	resw	1	; Process ID (0 = local user PID)
.size:
endstruc
 
;----------------------------------------------------------------------------
; DOSDATA
;----------------------------------------------------------------------------
;============================================================================
; 24/04/2019 - Retro DOS v4.0

DosDataSg equ 3 ; DOS Data Segment address (dw in 'retrodos4.s')
		; ((just after resident IO.SYS code&data))

;============================================================================
; WIN386.INC, MSDOS 6.0, 1991
;============================================================================
; 24/04/2019 - Retro DOS 4.0

;
;  Symbols and structures relating to WIN386 support.
;
;  Used by files in both the DOS and the BIOS.
;
;  Created: 7-13-89 by MRW
;

; WIN386 broadcast int 2fh multiplex number and subfunction numbers

MultWin386		equ     16h	; Int 2f multiplex number

Win386_Init		equ	05h	; Win386 initialization
Win386_Exit		equ	06h	; Win386 exit
Win386_Devcall		equ	07h	; Win386 device call out
Win386_InitDone		equ	08h	; Win386 initialization is complete

; When Win386_Devcall is broadcast, BX is the Device ID. DOS must 
; answer call outs from the DOSMGR

Win386_DOSMGR		equ	15H

; The following structures are used to communicate instance data to 
; Win386 from the DOS and the BIOS. See Win386 API documentation
; (chapter 3, "Call Out Interfaces") for further description.

struc Win386_SIS	; Startup Info Structure
 .Version:		resb	2	; db 3, 0
 .Next_Dev_Ptr:		resd	1	; pointer to next SIS in list
 .Virt_Dev_File_Ptr:	resd	1
 .Reference_Data:	resd	1
 .Instance_Data_Ptr:	resd	1	; pointer to instance data array
endstruc

size_of_Win386_SIS equ 18 ; 24/04/2019 - Retro DOS v4.0

struc Win386_IIS	; Instance Item Structure
.Ptr:			resd	1	; pointer to an instance item
.Size:			resw	1	; size of an instance item
endstruc

size_of_Win386_IIS equ 6 ; 24/04/2019 - Retro DOS v4.0

;Win386 DOSMGR function return values to indicate operation done

WIN_OP_DONE		equ	0B97Ch	; 
DOSMGR_OP_DONE		equ	0A2ABh	;

;M021
; WInoldap callout multiplex number

WINOLDAP		equ	46h	;

;============================================================================
;----------------------------------------------------------------------------
; DOSCODE
;----------------------------------------------------------------------------
; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)

;============================================================================
; MSHEAD.ASM (MSDOS 6.0, 1991)
;============================================================================
; 16/07/2018 - Retro DOS 3.0
;----------------------------------------------------------------------------
; 24/04/2019 - Retro DOS 4.0

; MSDOS 6.0
;----------------------------------------------------------------------------
; FILE : ORIGIN.INC
;----------------------------------------------------------------------------
; This is included in origin.asm and mshead.asm. Contains the equate that
; is used for ORGing the DOS code.
;
; Brief Description of the necessacity of this ORG:
; -------------------------------------------------
;
; A special problem exits when running out of the HMA. The HMA starts at 
; address FFFF:10. There is no place in the HMA with an offset of zero.
; This means programs running out off the HMA must use non-zero offset base
; addresses. It also means that if we're running multiple programs from the
; HMA, the base offset of each segment must atleast be as big as all of the
; HMA segments that precede it.
; 
; One solution to this problem to ORG each module at 64K minus its size.
; For instance a code segment 1234h bytes in length would org'd at edcbh.
; This gives max. flexibility regarding it's location in the HMA. By 
; selecting segment values between f124h and ffffh it could be located 
; anywhere in the HMA. The problem with this is that programs with such 
; high ORGs would not be able to run in low RAM.
;
; A compromise solution is to set the ORG address somewhere between 0010h
; and ffffh - their size. In the particular case of the BIOS and the DOS 
; the following solution has been implemented:
;
; The Bios Code segment will have a very small offset and run at the very
; front of the HMA, after the VDISK header. THE Dos Code segment will have 
; a base offset of (700+<min. size off RAM based BIOS>+<min. size of the DOS
; DATA segment when DOS is running low>). This will reflect the lowest 
; possible physical address at which DOS code will run, while still providing
; max. possible flexibility in HMA positioning. This offset MUST NOT be 
; smaller then that 20+size of Bios Code segment when running high. This is 
; mostly true.
;
; Also this ORG'd value must be communicated to the BIOS. This is done by
; putting this value after the first jmp instruction in the DOS code in
; mshead.asm. 
;
; In order for the stripz utility to know how many zeroes to be stripped 
; out, this value is placed at the beginning of the binary in origin.asm.
;
; Revision History:
;
; Currently this is being done manually. Therefore any change in the DOS DATA
; Size or the BIOS size should be reflected here. --- Feb 90
;
; BDSIZE.INC contains the equates for BIODATASIZE, BIOCODESIZ and DOSDATASIZ.
; A utility called getsize will obtain the corresponding values from msdos
; and msbio.map and update the values in BDSIZ.INC if they are different. 
; DOS should now be built using the batch file makedos.bat which invokes this
; utility. The FORMAT of BDSIZE.INC should not be changed as getsize is 
; dependant on that.				  --- Apr 3 '90
;
; For ROMDOS, however, there is no need to org the doscode to any location
; other than zero.  Therefore the stripz utility will not need to be used,
; so the offset will not need to be included at the beginning of the code
; segment.  Also, the BIOS can just assume that the resident code begins
; at offset zero within the segment.
; 
;
;--------------------------------------------------------------------------

BIODATASTART	EQU	00700h
;include	bdsize.inc	; this sets the values:
				;	BIODATASIZ
				;	BIOCODESIZ
				;	DOSDATASIZ

; 05/12/2022
;BIODATASIZ EQU 00910H	; 0900h for MSDOS 6.21 IO.SYS
			; 0900h for MSDOS 5.0 IO.SYS
;BIOCODESIZ EQU 01A70H	; 1A70h for MSDOS 6.21 IO.SYS
			; 1A60h for MSDOS 5.0 IO.SYS
;DOSDATASIZ EQU 01370H	; 1370h for MSDOS 6.21 IO.SYS
			; 1370h for MSDOS 5.0 IO.SYS
;ifndef ROMDOS
;
;BYTSTART	EQU    	BIODATASTART+BIODATASIZ+BIOCODESIZ+DOSDATASIZ
;PARASTART	EQU	(BYTSTART + 0FH) AND (NOT 0FH)	
;
;else
;
;BYTSTART	EQU	0
;PARASTART	EQU	0
;
;endif ; ROMDOS

; 24/04/2019 - Retro DOS v4.0 - Modification
; -----------------------------------------------------------------
;MSDAT001E equ 136Ah ; 4970 ; for MSDOS 6.21	
;MSDAT001E equ 1370h ; 4976 ; for Retro DOS v4.0 modif. 25/05/2019	
;DOSDATASIZE equ MSDAT001E
; 05/12/2022
;DOSDATASIZE equ $ ; 29/04/2019 ; -only- for RETRO DOS v4.0 :
;_PARASTART_ equ DOSDATASIZE ; segment value will point to start of
			    ; of DOSDATA (in low memory) while
			    ; dos/kernel code starts just after 
			    ; this data block ((org = DOSDATASIZE))
			    ; (in low memory or in HMA)	
; -----------------------------------------------------------------

; 04/11/2022	
; -----------------------------------------------------------------	
; NOTE:
; Microsoft dos programmers were calling 'IO.SYS' as dos 'BIOS'
; (Also, they were calling 'ROMBIOS' as 'ROM' only!)
; -----------------------------------------------------------------

; ----------------------------------------------------------------------------
; 06/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; ----------------------------------------------------------------------------

;segment .code vstart=3DD0h ; 06/12/2022
; 29/09/2023
segment .code vstart=3DE0h ; 19/09/2023 - Retro DOS v4.2 (Modified MSDOS 6.22)
								
; ============================================================================


;[ORG 3DE0h]

;[ORG _PARASTART_]     ; [org 136Ah]

;[ORG 1370h] ; 25/05/2019 - Retro DOS v4.0

	; 05/12/2022 - RetroDOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	;PARASTART equ 3DD0h ; BIOSDATASTART+BIOSDATASIZE
			     ; +BIOSCODESIZE+DOSDATASIZE (rounded up)
	
	; 29/09/2023 
	; 19/09/2023 - Retro DOS v4.2 (Modified MSDOS 6.22 MSDOS.SYS)
	PARASTART equ 3DE0h	; (MSDOS 6.22 MSDOS.SYS)

	[ORG PARASTART]	

_$STARTCODE:

;PARASTART:
        JMP     DOSINIT

	;dw	PARASTART	; PARASTART = 3DE0h for MSDOS 6.0, 6.22
	; 04/11/2022
	dw	_$STARTCODE	; PARASTART = 3DD0h for MSDOS 5.0

BioDataSeg:
	dw	0070h		; Bios data segment fixed at 70h

; DosDSeg is a data word in the DOSCODE segment that is loaded with
; the segment address of DOSDATA. This is purely an optimization, that
; allows getting the DOS data segment without going through the 
; BIOS data segment. It is used by the "getdseg" macro.

DosDSeg:
	dw	0
	
;============================================================================
; MSTABLE.ASM (MSDOS 6.0, 1991)
;============================================================================
; 16/07/2018 - Retro DOS 3.0
; 29/04/2019 - Retro DOS 4.0

	; (MSDOS version)
	; DOSCODE:3DE9h (MSDOS 6.21, MSDOS.SYS)
	;db	6
	;db	20
	; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS) 
	; DOSCODE:3DD9h (MSDOS 5.0, MSDOS.SYS)
	;db	5
	;db	0	

	; Offset 0C78h in IBMDOS.COM (MSDOS 3.3, 1987)
MSVERS:				; MS-DOS version in hex for $GET_VERSION
MSMAJOR: DB	MAJOR_VERSION	; DOS_MAJOR_VERSION
MSMINOR: DB	MINOR_VERSION	; DOS_MINOR_VERSION  

;;hkn YRTAB & MONTAB moved to DOSDATA in ms_data.asm
;	I_am	YRTAB,8,<200,166,200,165,200,165,200,165>   ; [SYSTEM]
;	I_am	MONTAB,12,<31,28,31,30,31,30,31,31,30,31,30,31> ; [SYSTEM]

; DOSTAB.ASM (MSDOS 6.0, 1991)
; YRTAB & MONTAB moved from TABLE segment in ms_table.asm
;
;	I_am    YRTAB,8,<200,166,200,165,200,165,200,165>   
;	I_am    MONTAB,12,<31,28,31,30,31,30,31,31,30,31,30,31> 

; This is the error code mapping table for INT 21 errors. This table defines
; those error codes which are "allowed" for each system call. If the error
; code ABOUT to be returned is not "allowed" for the call, the correct action
; is to return the "real" error via Extended error, and one of the allowed
; errors on the actual call.
;
; The table is organized as follows:
;
;    Each entry in the table is of variable size, but the first
;       two bytes are always:
;
;       Call#,Cnt of bytes following this byte
;
; EXAMPLE:
;       Call 61 (OPEN)
;
;       DB      61,5,12,3,2,4,5
;
;       61 is the AH INT 21 call value for OPEN.
;        5 indicates that there are 5 bytes after this byte (12,3,2,4,5).
;       Next five bytes are those error codes which are "allowed" on OPEN.
;       The order of these values is not important EXCEPT FOR THE LAST ONE (in
;       this case 5).  The last value will be the one returned on the call if
;       the "real" error is not one of the allowed ones.
;
; There are a number of calls (for instance all of the FCB calls) for which
;   there is NO entry.  This means that NO error codes are returned on this
;   call, so set up an Extended error and leave the current error code alone.
;
; The table is terminated by a call value of 0FFh

;PUBLIC I21_MAP_E_TAB
	; 10/08/2018

; 29/04/2019
; DOSCODE:3DE9h (MSDOS 6.21, MSDOS.SYS)
; 04/11/2022
; DOSCODE:3DDBh	(MSDOS 5.0 MSDOS.SYS)

I21_MAP_E_TAB:	; LABEL	BYTE
    DB  INTERNATIONAL,2,error_invalid_function,error_file_not_found
    DB  MKDIR,3,error_path_not_found,error_file_not_found,error_access_denied
    DB  RMDIR,4,error_current_directory,error_path_not_found
    DB          error_file_not_found,error_access_denied
    DB  CHDIR,2,error_file_not_found,error_path_not_found
    DB  CREAT,4,error_path_not_found,error_file_not_found
    DB          error_too_many_open_files
    DB          error_access_denied
    ; MSDOS 6.0
    DB	OPEN,6,error_path_not_found,error_file_not_found,error_invalid_access
    DB          error_too_many_open_files
    DB          error_not_DOS_disk,error_access_denied
    ; MSDOS 3.3
    ;DB	OPEN,5,error_path_not_found,error_file_not_found,error_invalid_access
    ;DB		error_too_many_open_files,error_access_denied
    DB  CLOSE,1,error_invalid_handle
    DB  READ,2,error_invalid_handle,error_access_denied
    DB  WRITE,2,error_invalid_handle,error_access_denied
    DB  UNLINK,3,error_path_not_found,error_file_not_found,error_access_denied
    DB  LSEEK,2,error_invalid_handle,error_invalid_function
    DB  CHMOD,4,error_path_not_found,error_file_not_found,error_invalid_function
    DB          error_access_denied
    DB  IOCTL,5,error_invalid_drive,error_invalid_data,error_invalid_function
    DB          error_invalid_handle,error_access_denied
    DB  XDUP,2,error_invalid_handle,error_too_many_open_files
    DB  XDUP2,2,error_invalid_handle,error_too_many_open_files
    ; MSDOS 6.0	
    DB  CURRENT_DIR,2,error_not_DOS_disk,error_invalid_drive
    ; MSDOS 3.3	
    ;DB  CURRENT_DIR,1,error_invalid_drive
    DB  ALLOC,2,error_arena_trashed,error_not_enough_memory
    DB  DEALLOC,2,error_arena_trashed,error_invalid_block
    DB  SETBLOCK,3,error_arena_trashed,error_invalid_block,error_not_enough_memory
    DB  EXEC,8,error_path_not_found,error_invalid_function,error_file_not_found
    DB          error_too_many_open_files,error_bad_format,error_bad_environment
    DB          error_not_enough_memory,error_access_denied
    DB  FIND_FIRST,3,error_path_not_found,error_file_not_found,error_no_more_files
    DB  FIND_NEXT,1,error_no_more_files
    ; MSDOS 6.0
    DB  RENAME,5,error_not_same_device,error_path_not_found,error_file_not_found
    DB		error_current_directory,error_access_denied
    ; MSDOS 3.3
    ;DB  RENAME,4,error_not_same_device,error_path_not_found,error_file_not_found
    ;DB		error_access_denied
    ; MSDOS 6.0	
    DB  FILE_TIMES,4,error_invalid_handle,error_not_enough_memory
    DB		error_invalid_data,error_invalid_function
    ; MSDOS 3.3	
    ;DB  FILE_TIMES,2,error_invalid_handle,error_invalid_function
    DB  ALLOCOPER,1,error_invalid_function
    DB  CREATETEMPFILE,4,error_path_not_found,error_file_not_found
    DB          error_too_many_open_files,error_access_denied
    DB  CREATENEWFILE,5,error_file_exists,error_path_not_found
    DB          error_file_not_found,error_too_many_open_files,error_access_denied
    DB  LOCKOPER,4,error_invalid_handle,error_invalid_function
    DB          error_sharing_buffer_exceeded,error_lock_violation
    DB  GETEXTCNTRY,2,error_invalid_function,error_file_not_found	;DOS 3.3
    DB  GETSETCDPG,2,error_invalid_function,error_file_not_found        ;DOS 3.3
    DB  COMMIT,1,error_invalid_handle                                   ;DOS 3.3
    DB  EXTHANDLE,3,error_too_many_open_files,error_not_enough_memory
    DB              error_invalid_function
    ; MSDOS 6.0		
    DB	ExtOpen,10
    DB	  error_path_not_found,error_file_not_found,error_invalid_access
    DB		error_too_many_open_files,error_file_exists,error_not_enough_memory
    DB		error_not_DOS_disk,error_invalid_data
    DB		error_invalid_function,error_access_denied
    DB	GetSetMediaID,4,error_invalid_drive,error_invalid_data
    DB		error_invalid_function,error_access_denied
    DB  0FFh

;19/09/2023
;22/12/2022
;04/11/2022	
;29/04/2019 - Retro DOS v4.0
;============================================================================
; 	Retro DOS v4.0
;============================================================================
	db 	0
RETRODOSMSG:
	db	13,10
	;;;;;db	"Retro DOS v4.0 by Erdogan Tan [2019]"
	;;;;db	"Retro DOS v4.0 by Erdogan Tan [2022]"
	;;;db	"Retro DOS v4.1 by Erdogan Tan [2022]"	; 28/12/2022
	;;db	"Retro DOS v4.2 by Erdogan Tan [2022]"	; 30/12/2022
	;db	"Retro DOS v4.2 by Erdogan Tan [2023]"
	db	"Retro DOS v4.2 by Erdogan Tan [2024]"	; 05/01/2024
	db	13,10,"$", 0 

;============================================================================
; MSTABLE.ASM, MSDOS 6.0, 1991
;============================================================================
; 11/07/2018 - Retro DOS v3.0

	%define short_addr dw  ; 03/03/2018 - Retro DOS v2.0
align 2
	; IBMDOS.COM (MSDOS 3.3) - Offset 0E00h

; Standard Functions
;DISPATCH  LABEL WORD
DISPATCH:
	; 16/07/2018 - Retro DOS v3.0
	; (MSDOS 3.3)

; 29/04/2019
; DOSCODE:3E9Eh (MSDOS 6.21, MSDOS.SYS)

; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:3E8Eh (MSDOS 5.0, MSDOS.SYS)

        short_addr  _$ABORT			    ;  0      0
        short_addr  _$STD_CON_INPUT		    ;  1      1
        short_addr  _$STD_CON_OUTPUT		    ;  2      2
        short_addr  _$STD_AUX_INPUT		    ;  3      3
        short_addr  _$STD_AUX_OUTPUT		    ;  4      4
        short_addr  _$STD_PRINTER_OUTPUT	    ;  5      5
        short_addr  _$RAW_CON_IO		    ;  6      6
        short_addr  _$RAW_CON_INPUT		    ;  7      7
        short_addr  _$STD_CON_INPUT_NO_ECHO	    ;  8      8
        short_addr  _$STD_CON_STRING_OUTPUT	    ;  9      9
        short_addr  _$STD_CON_STRING_INPUT	    ; 10      A
        short_addr  _$STD_CON_INPUT_STATUS	    ; 11      B
        short_addr  _$STD_CON_INPUT_FLUSH	    ; 12      C
        short_addr  _$DISK_RESET		    ; 13      D
        short_addr  _$SET_DEFAULT_DRIVE		    ; 14      E
        short_addr  _$FCB_OPEN			    ; 15      F
        short_addr  _$FCB_CLOSE			    ; 16     10
        short_addr  _$DIR_SEARCH_FIRST		    ; 17     11
        short_addr  _$DIR_SEARCH_NEXT		    ; 18     12
        short_addr  _$FCB_DELETE		    ; 19     13
        short_addr  _$FCB_SEQ_READ		    ; 20     14
        short_addr  _$FCB_SEQ_WRITE	            ; 21     15
        short_addr  _$FCB_CREATE		    ; 22     16
        short_addr  _$FCB_RENAME		    ; 23     17
	; 16/07/2018
        ;short_addr _CPMFUNC			    ; 24     18	
        short_addr  NO_OP			    ; 24     18
        short_addr  _$GET_DEFAULT_DRIVE		    ; 25     19
        short_addr  _$SET_DMA			    ; 26     1A

;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
        short_addr  _$SLEAZEFUNC		    ; 27     1B
        short_addr  _$SLEAZEFUNCDL		    ; 28     1C
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;

        ;short_addr  _CPMFUNC			    ; 29     1D
        ;short_addr  _CPMFUNC			    ; 30     1E

; 08/07/2018 - Retro DOS v3.0
; MSDOS 6.0 - MSTABLE.ASM, 1991

	short_addr  NO_OP			    ; 29     1D
	short_addr  NO_OP			    ; 30     1E

;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
        short_addr  _$GET_DEFAULT_DPB               ; 31     1F
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
        ;short_addr _CPMFUNC			    ; 32     20

; 08/07/2018 - Retro DOS v3.0
; MSDOS 6.0 - MSTABLE.ASM, 1991

	short_addr  NO_OP			    ; 32     20

        short_addr  _$FCB_RANDOM_READ               ; 33     21
        short_addr  _$FCB_RANDOM_WRITE              ; 34     22
        short_addr  _$GET_FCB_FILE_LENGTH	    ; 35     23
        short_addr  _$GET_FCB_POSITION		    ; 36     24

;MAXCALL = ($-DISPATCH)/2 - 1
MAXCALL EQU ($-DISPATCH)/2 - 1

; Extended Functions
        short_addr  _$SET_INTERRUPT_VECTOR	    ; 37     25
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
        short_addr  _$CREATE_PROCESS_DATA_BLOCK	    ; 38     26
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
        short_addr  _$FCB_RANDOM_READ_BLOCK	    ; 39     27
        short_addr  _$FCB_RANDOM_WRITE_BLOCK        ; 40     28
        short_addr  _$PARSE_FILE_DESCRIPTOR	    ; 41     29
        short_addr  _$GET_DATE                      ; 42     2A
        short_addr  _$SET_DATE                      ; 43     2B
        short_addr  _$GET_TIME                      ; 44     2C
        short_addr  _$SET_TIME                      ; 45     2D
        short_addr  _$SET_VERIFY_ON_WRITE           ; 46     2E

; Extended functionality group
        short_addr  _$GET_DMA                       ; 47     2F
        short_addr  _$GET_VERSION                   ; 48     30
        short_addr  _$KEEP_PROCESS		    ; 49     31
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
        short_addr  _$GET_DPB			    ; 50     32
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
        short_addr  _$SET_CTRL_C_TRAPPING           ; 51     33
        short_addr  _$GET_INDOS_FLAG                ; 52     34
        short_addr  _$GET_INTERRUPT_VECTOR          ; 53     35
        short_addr  _$GET_DRIVE_FREESPACE           ; 54     36
        short_addr  _$CHAR_OPER                     ; 55     37
        short_addr  _$INTERNATIONAL                 ; 56     38
; XENIX CALLS
;   Directory Group
        short_addr  _$MKDIR			    ; 57     39
        short_addr  _$RMDIR			    ; 58     3A
        short_addr  _$CHDIR			    ; 59     3B
;   File Group
        short_addr  _$CREAT			    ; 60     3C
        short_addr  _$OPEN			    ; 61     3D
        short_addr  _$CLOSE		 	    ; 62     3E
        short_addr  _$READ			    ; 63     3F
        short_addr  _$WRITE			    ; 64     40
        short_addr  _$UNLINK			    ; 65     41
        short_addr  _$LSEEK			    ; 66     42
        short_addr  _$CHMOD			    ; 67     43
        short_addr  _$IOCTL			    ; 68     44
        short_addr  _$DUP			    ; 69     45
        short_addr  _$DUP2			    ; 70     46
        short_addr  _$CURRENT_DIR		    ; 71     47
;   Memory Group
        short_addr  _$ALLOC			    ; 72     48
        short_addr  _$DEALLOC                       ; 73     49
        short_addr  _$SETBLOCK                      ; 74     4A
;   Process Group
        short_addr  _$EXEC			    ; 75     4B
        short_addr  _$EXIT			    ; 76     4C
        short_addr  _$WAIT			    ; 77     4D
        short_addr  _$FIND_FIRST		    ; 78     4E
;   Special Group
        short_addr  _$FIND_NEXT			    ; 79     4F
; SPECIAL SYSTEM GROUP
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
        short_addr  _$SET_CURRENT_PDB		    ; 80     50
        short_addr  _$GET_CURRENT_PDB               ; 81     51
        short_addr  _$GET_IN_VARS                   ; 82     52
        short_addr  _$SETDPB			    ; 83     53
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
        short_addr  _$GET_VERIFY_ON_WRITE	    ; 84     54
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
        short_addr  _$DUP_PDB                       ; 85     55
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
        short_addr  _$RENAME			    ; 86     56
        short_addr  _$FILE_TIMES                    ; 87     57
        short_addr  _$ALLOCOPER                     ; 88     58

; 08/07/2018 - Retro DOS v3.0
; -------------------------------------------------------------------------;
; MSDOS 6.0 - MSTABLE.ASM, 1991

; Network extention system calls
        short_addr  _$GetExtendedError              ; 89     59
        short_addr  _$CreateTempFile                ; 90     5A
        short_addr  _$CreateNewFile                 ; 91     5B
        short_addr  _$LockOper                      ; 92     5C
        short_addr  _$ServerCall                    ; 93     5D
        short_addr  _$UserOper                      ; 94     5E
        short_addr  _$AssignOper                    ; 95     5F
        short_addr  _$NameTrans                     ; 96     60
	short_addr  NO_OP			    ; 97     61
        short_addr  _$GET_CURRENT_PDB		    ; 98     62
; the next call is reserved for hangool sys call
	; 29/04/2019 - Retro DOS v4.0 (MSDOS 6.0)
	short_addr  _$ECS_Call			    ; 99     63
	;short_addr  NO_OP  ;  MSDOS 3.3	    ; 99     63
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
        short_addr  _$SET_PRINTER_FLAG              ; 100    64
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
        short_addr  _$GetExtCntry                   ; 101    65
        short_addr  _$GetSetCdPg                    ; 102    66
        short_addr  _$ExtHandle                     ; 103    67
        short_addr  _$COMMIT                        ; 104    68

; 08/07/2018
; Above system calls are valid for Retro DOS v3.0 (MSDOS 3.3) 
; Following system calls are valid for Retro DOS v4.0 (MSDOS 6.0)

; 29/04/2019 - Retro DOS v4.0 (MSDOS 6.0)
	short_addr  _$GSetMediaID                   ; 105    69   ;AN000;
	short_addr  _$COMMIT                        ; 106    6A   ;AN000;
	short_addr  NO_OP                           ; 107    6B   
						    ; IFS_IOCTL no longer 
						    ; supported
	short_addr  _$Extended_Open                 ; 108    6C   ;AN000;

;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
;ifdef ROMEXEC
;       short_addr  $ROM_FIND_FIRST	   	    ; 109    6D
;       short_addr  $ROM_FIND_NEXT	   	    ; 110    6E
;	short_addr  $ROM_EXCLUDE		    ; 111    6F	  ; M078
;endif
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;

;MAXCOM  = ($-DISPATCH)/2 - 1

MAXCOM  EQU ($-DISPATCH)/2 - 1

; 08/07/2018 - Retro DOS v3.0
; MSDOS 6.0 - MSTABLE.ASM, 1991

;	If 	Installed

align 2

;PUBLIC FOO

FOO:	; LABEL WORD
        short_addr  Leave2F

DTab:	DW  DOSTable

	;PUBLIC FOO,DTAB

	; IBMDOS.COM (MSDOS 3.3) - Offset 0ED6h

; 29/04/2019
; DOSCODE:3F7Ch (MSDOS 6.21, MSDOS.SYS)


; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:3F6Ch (MSDOS 5.0, MSDOS.SYS)
       
DOSTable:  ; LABEL  WORD
        DB      (DOSTableEnd-DOSTable-1)/2 ; db  48
        short_addr  DOSInstall          ;   0 install check
        short_addr  DOS_CLOSE           ;   1   DOS_CLOSE
        short_addr  RECSET              ;   2   RECSET
        short_addr  DosGetGroup         ;   3   Get DOSGROUP
        short_addr  PATHCHRCMP          ;   4   PATHCHRCMP
        short_addr  OUTT                ;   5   OUT
        short_addr  NET_I24_ENTRY       ;   6   NET_I24_ENTRY
        short_addr  PLACEBUF            ;   7   PLACEBUF
        short_addr  FREE_SFT            ;   8   FREE_SFT
        short_addr  BUFWRITE            ;   9   BUFWRITE
        short_addr  SHARE_VIOLATION     ;   10  SHARE_VIOLATION
        short_addr  SHARE_ERROR         ;   11  SHARE_ERROR
        short_addr  SET_SFT_MODE        ;   12  SET_SFT_MODE
        short_addr  DATE16              ;   13  DATE16
        short_addr  Idle		;   14      empty slot
        short_addr  SCANPLACE           ;   15  SCANPLACE
        short_addr  Idle		;   16      empty slot
        short_addr  StrCpy              ;   17  StrCpy
        short_addr  StrLen              ;   18  StrLen
        short_addr  UCase		;   19  UCase
        short_addr  POINTCOMP           ;   20  POINTCOMP
        short_addr  CHECKFLUSH          ;   21  CHECKFLUSH
        short_addr  SFFromSFN           ;   22  SFFromSFN
        short_addr  GetCDSFromDrv       ;   23  GetCDSFromDrv
        short_addr  Get_User_Stack      ;   24  Get_User_Stack
        short_addr  GETTHISDRV          ;   25  GetThisDrv
        short_addr  DriveFromText       ;   26  DriveFromText
        short_addr  SETYEAR             ;   27  SETYEAR
        short_addr  DSUM                ;   28  DSUM
        short_addr  DSLIDE              ;   29  DSLIDE
        short_addr  StrCmp              ;   30  StrCmp
        short_addr  InitCDS             ;   31  initcds
        short_addr  pJFNFromHandle      ;   32  pJfnFromHandle
        short_addr  _$NameTrans		;   33  $NameTrans
        short_addr  CAL_LK              ;   34  CAL_LK
        short_addr  DEVNAME             ;   35  DEVNAME
        short_addr  Idle                ;   36  Idle
        short_addr  DStrLen             ;   37  DStrLen
        short_addr  NLS_OPEN            ;   38  NLS_OPEN      DOS 3.3
        short_addr  _$CLOSE		;   39  $CLOSE        DOS 3.3
        short_addr  NLS_LSEEK           ;   40  NLS_LSEEK     DOS 3.3
        short_addr  _$READ		;   41  $READ         DOS 3.3
        short_addr  FastInit            ;   42  FastInit      DOS 3.4  ;AN000;
        short_addr  NLS_IOCTL           ;   43  NLS_IOCTL     DOS 3.3
        short_addr  GetDevList          ;   44  GetDevList    DOS 3.3
        short_addr  NLS_GETEXT          ;   45  NLS_GETEXT    DOS 3.3
        
	; 29/04/2019 - Retro DOS v4.0
	short_addr  MSG_RETRIEVAL	;   46  MSG_RETRIEVAL DOS 4.0  ;AN000;

	short_addr  NO_OP		;   M006: 47  no longer supported
;*** 	short_addr  Fake_Version	;   47  Fake_Version  DOS 4.0  ;AN006;

DOSTableEnd:  ; LABEL BYTE

	;ENDIF

; ----------------------------------------------------------------------------
; BREAK   <Copyright notice and version>
; ----------------------------------------------------------------------------

;CODSTRT EQU	$

; 08/07/2018 - Retro DOS v3.0 by Erdogan Tan
; (MSTABLE.ASM, MSDOS 6.0, 1991)

; NOTE WARNING: This declaration of HEADER must be THE LAST thing in this
;       module. The reason is so that the data alignments are the same in
;       IBM-DOS and MS-DOS up through header.

	;PUBLIC	HEADER

HEADER:	; LABEL	BYTE
        ;IF	DEBUG
        ;DB	13,10,"Debugging DOS version "
        ;DB	MAJOR_VERSION + "0"
        ;DB	"."
        ;DB	(MINOR_VERSION / 10) + "0"
        ;DB	(MINOR_VERSION MOD 10) + "0"
        ;ENDIF

; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; (MSDOS 5.0 MSDOS.SYS compatibility)
%if 0
        ;IF	NOT IBM
        DB	13,10,"MS-DOS version "
        DB	MAJOR_VERSION + "0"
        DB	"."
        DB	(MINOR_VERSION / 10) + "0"
        ;DB	(MINOR_VERSION MOD 10) + "0"
        DB	(MINOR_VERSION % 10) + "0"

        ;IF	HIGHMEM
        ;DB	"H"
        ;ENDIF

	;DB	13,10,"Copyright 1981,82,83,84,88 Microsoft Corp.",13,10,"$"
	; 30/04/2019 - Retro DOS v4.0
	DB	13,10,"Copyright 1981-1993 Microsoft Corp.",13,10,"$"	

	;ENDIF

%endif

;IF DEBUG
;	DB	13,10,"$"
;ENDIF

;include copyrigh.inc

; DOSCODE:3FDDh (MSDOS 6.21, MSDOS.SYS)

	;DB	"MS DOS Version 6 (C)Copyright 1981-1993 Microsoft Corp "
	;DB	"Licensed Material - Property of Microsoft "
	;DB	"All rights reserved "

; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:3FCDh (MSDOS 5.0, MSDOS.SYS)

; 28/12/2022 - Retro DOS v4.1
%if 0
	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
ms_copyright:
	db	'MS DOS Version 5.00 (C)Copyright 1981-1991 Microsoft Corp '
	db	'Licensed Material - Property of Microsoft '
	db	'All rights reserved '

%endif
	;; 28/12/2022 - Retro DOS v4.1
;ms_copyright:	
  	;db	13,10,"MS DOS Version 5.0"
	;db	13,10,"Copyright 1981-1991 Microsoft Corp.",13,10,"$",0	

;	; 21/09/2023 - Retro DOS v4.2 MSDOS.SYS
;	; (MSDOS 6.22 MSDOS.SYS - DOSCODE:3FDDh (File offset: 509))
;ms_copyright:
;	db 'MS DOS Version 6 (C)Copyright 1981-1994 Microsoft Corp '
;	db 'Licensed Material - Property of Microsoft All rights reserved '

	; 20/09/2023 - Retro DOS v4.2
ms_copyright:	
  	db	13,10,"MS DOS Version 6.22"
	db	13,10,"Copyright 1981-1994 Microsoft Corp.",13,10,"$",0	

;============================================================================
; MSCODE.ASM
;============================================================================

; Retro DOS v2.0 (NASM 2.11) source code modifications by Erdogan Tan
; 03/03/2018

;
; MSCODE.ASM -- MSDOS code
;

;INCLUDE DOSSEG.ASM
;INCLUDE STDSW.ASM

;CODE    SEGMENT BYTE PUBLIC  'CODE'
;ASSUME  CS:DOSGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING

;.xcref
;INCLUDE DOSSYM.ASM
;INCLUDE DEVSYM.ASM
;.cref
;.list

;IFNDEF  KANJI
;KANJI   EQU     0       ; FALSE
;ENDIF

;IFNDEF  IBM
;IBM     EQU     0
;ENDIF

;IFNDEF  HIGHMEM
;HIGHMEM  EQU     0
;ENDIF

        ;i_need  USER_SP,WORD
        ;i_need  USER_SS,WORD
        ;i_need  SAVEDS,WORD
        ;i_need  SAVEBX,WORD
        ;i_need  INDOS,BYTE
        ;i_need  NSP,WORD
        ;i_need  NSS,WORD
        ;i_need  CURRENTPDB,WORD
        ;i_need  AUXSTACK,BYTE
        ;i_need  CONSWAP,BYTE
        ;i_need  IDLEINT,BYTE
        ;i_need  NOSETDIR,BYTE
        ;i_need  ERRORMODE,BYTE
        ;i_need  IOSTACK,BYTE
        ;i_need  WPERR,BYTE
        ;i_need  DSKSTACK,BYTE
        ;i_need  CNTCFLAG,BYTE
        ;i_need  LEAVEADDR,WORD
        ;i_need  NULLDEVPT,DWORD

        ;IF NOT IBM
        ;i_need  OEM_HANDLER,DWORD
        ;ENDIF

        ;EXTRN   DSKSTATCHK:NEAR,GETBP:NEAR,DSKREAD:NEAR,DSKWRITE:NEAR

;============================================================================
; MSDISP.ASM, MSDOS 6.0, 1991
;============================================================================
; 11/07/2018 - Retro DOS v3.0
; 01/05/2019 - Retro DOS v4.0

; DosCode SEGMENT

; ==========================================================================
;
; $Set_CTRL_C_Trapping
;
; Function:
;	Enable disable ^C checking in dispatcher
;
; Inputs:
;		AL = 0 read ^C status
;		AL = 1 Set ^C status, DL = 0/1 for ^C off/on
;		AL = 2 Set ^C status to contents of DL.	Output is old state.
;		AL = 5 get DOS boot drive
;		AL = 6 Get version number
;			RETURNS:
;				BH = Minor version number
;				BL = Major version number
;				DL = DOS internal revision
;				DH = DOS type flags
;					Bit 3 	- DOS in ROM
;					Bit 4 	- DOS in HMA
;					Bit 0-2, 5-7 - Reserved
; Outputs:
;		If AL = 0 then DL = 0/1 for ^C off/on
;
; History:
;      removed	AL = 3 Get CPSW state to DL	    DOS 3.4
;      removed	AL = 4 Set CPSW state from DL	    DOS 3.4
; ==========================================================================

; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:4045h (MSDOS 5.0, MSDOS.SYS)

; 01/01/2024 - Retro DOS v4.2 (Modified MSDOS 6.22 MSDOS.SYS)
; DOSCODE:4052h (MSDOS 6.21, MSDOS.SYS)
; DOSCODE:4052h (MSDOS 6.22, MSDOS.SYS)
; DOSCODE:4123h (PCDOS 7.1, IBMDOS.COM)

_$SET_CTRL_C_TRAPPING:
	; 01/05/2019 - Retro DOS v4.0

	cmp	AL,6			; Is this a valid subfunction?
	jbe	short scct_1		; If yes continue processing

	mov	AL,0FFh			; Else set AL to -1 and
	iret
scct_1:
	push	DS

	;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
	mov	ds,[cs:DosDSeg]
	
	push	AX			; DL only register that can change
	push	SI

	mov	SI,CNTCFLAG		; DS:SI --> Ctrl C Status byte
	xor	AH,AH			; Clear high byte of AX
	or	AX,AX			; Check for subfunction 0
	jnz	short scct_2		; If not 0 jmp to next check

	mov	DL,[SI]			; Else move current ctrl C status
	jmp	SHORT scct_9s		; into DL and jmp to exit
scct_2:
	dec	AX			; Now dec AX and see if it was 1
	jnz	short scct_3		; If not 0 it wasn't 1 so do next chk

	and	DL,1			; Else mask off bit 0 of DL and
	mov	[SI],DL			; save it as new Ctrl C status
	jmp	SHORT scct_9s		; Jmp to exit
scct_3:
	dec	AX			; Dec AX again to see if it was 2
	jnz	short scct_4		; If not 0 wasn't 2 so go to next chk

	and	DL,1			; Else mask off bit 0 of DL and
	xchg	[SI],DL			; Exchange DL with old status byte
	jmp	SHORT scct_9s		; Jump to exit (returning old status)
scct_4:
	cmp	al,3 ; 01/01/2024 (PCDOS 7.1 IBMDOS.COM)
	;cmp	AX,3 			; Test for 5 after it was dec twice
	jne	short scct_5		; If not equal then not get boot drv
	mov	DL,[BOOTDRIVE]		; Else return boot drive in DL
	jmp	SHORT scct_9s		; Jump to exit (returning boot drive)
scct_5:
	cmp	al,4 ; 01/01/2024 (PCDOS 7.1 IBMDOS.COM)
	;cmp	AX,4 			; Test for 6 after it was dec twice
	jne	short scct_9s		; If not equal then not get version
	
	;mov	BX,(Minor_Version SHL 8) + Major_Version
	;mov	bx,1406h	; DOSCODE:4092h (MSDOS 6.21, MSDOS.SYS)
	mov	bx,(MINOR_VERSION<<8)+MAJOR_VERSION
	
	;mov	dl,0
	;mov	DL,DOSREVNM ; 0

	;xor	dh,dh			; assume vanilla DOS
	; 01/01/2024
	mov	dx,0
	cmp	byte [DosHasHMA],dh ; 0
	;cmp	byte [DosHasHMA],0	; is DOS in HMA?  (M021)
	;je	short @F
	je	short scct_6
	; 01/01/2024
	mov	dh,10h
	;or	dh,10h
	;;or	DH,DOSINHMA ; 10h
;@@:
scct_6:

;ifdef ROMDOS
;	or	DH,DOSINROM ; 08h
;endif ; ROMDOS

scct_9s:
	pop	SI
	pop	AX
	pop	DS
scct_9f:
	iret

SetCtrlShortEntry:			; This allows a conditional entry
					; from main dispatch code
	jmp	SHORT _$SET_CTRL_C_TRAPPING

; ==========================================================================
;									   
; The following two routines are dispatched to directly with ints disabled
; immediately after the int 21h entry.	no DIS state is set.
;
; $Set_current_PDB takes BX and sets it to be the current process
;   *** THIS FUNCTION CALL IS SUBJECT TO CHANGE!!! ***
;
; ==========================================================================

_$SET_CURRENT_PDB:
	push	DS
	;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
	mov	ds,[cs:DosDSeg]
	mov	[CurrentPDB],BX		; Set new PSP segment from caller's BX
	pop	DS
	iret

; ==========================================================================
;
; $get_current_PDB returns in BX the current process
;   *** THIS FUNCTION CALL IS SUBJECT TO CHANGE!!! ***
;
; ==========================================================================

_$GET_CURRENT_PDB:
	push	DS
	;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
	mov	ds,[cs:DosDSeg]
	mov	BX,[CurrentPDB]		; Return current PSP segment in BX
	pop	DS
	iret

; ==========================================================================
;
; Sets the Printer Flag to whatever is in AL.
; NOTE: THIS PROCEDURE IS SUBJECT TO CHANGE!!!
;
; ==========================================================================

_$SET_PRINTER_FLAG:
	push	ds
	;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
	mov	ds,[cs:DosDSeg]
	mov	[PRINTER_FLAG],AL 	; Set printer flag from caller's AL
	pop	ds
	iret

; 01/05/2019 - Retro DOS v4.0
; 08/07/2018 - Retro DOS v3.0
; (MSDISP.ASM, MSDOS 6.0, 1991)

; ----------------------------------------------------------------------------
; BREAK   <System call entry points and dispatcher>
; ----------------------------------------------------------------------------

; DOSCODE:40CCh (MSDOS 6.21, MSDOS.SYS)

; ==========================================================================
;
; The Quit entry point is where all INT 20h's come from. These are old- style
; exit system calls. The CS of the caller indicates which Process is dying.
; The error code is presumed to be 0. We simulate an ABORT system call.
;
; ==========================================================================

SYSTEM_CALL:    ; PROC NEAR

; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:40BFh (MSDOS 5.0, MSDOS.SYS)

;entry	QUIT				
QUIT:				; INT 20H entry point	
	;MOV	AH,0
	xor	ah,ah ; 08/07/2018
	JMP     SHORT SAVREGS

; ---------------------------------------------------------------------------

	; The system call in AH is out of the range that we know how
	; to handle. We arbitrarily set the contents of AL to 0 and
	; IRET. Note that we CANNOT set the carry flag to indicate an
	; error as this may break some programs compatability.

BADCALL:
        ;MOV	AL,0
	xor	al,al ; 08/07/2018
IRETT:	; 06/05/2019
_IRET:
        IRET

; ---------------------------------------------------------------------------

; 01/05/2019 - Retro DOS v4.0
; DOSCODE:40D3h (MSDOS 6.21 MSDOS.SYS)
; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:40C6h (MSDOS 5.0 MSDOS.SYS)

	; An alternative method of entering the system is to perform a
	; CALL 5 in the program segment prefix with the contents of CL
	; indicating what system call the user would like. A subset of
	; the possible system calls is allowed here only the
	; CPM-compatible calls may get dispatched.

		; System call entry point and dispatcher
CALL_ENTRY:
	push	DS
	;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
	mov	ds,[cs:DosDSeg]
	pop	word [SAVEDS]		; Save original DS

        POP     AX                      ; IP from the long call at 5
        POP     AX                      ; Segment from the long call at 5
	POP	WORD [USER_SP]		; IP from the CALL 5

		; Re-order the stack to simulate an interrupt 21.

	PUSHF				; Start re-ordering the stack
	CLI
        PUSH    AX                      ; Save segment
        PUSH	WORD [USER_SP]		; Stack now ordered as if INT had been used
	; 04/11/2022
	; DOSCODE:40EAh (MSDOS 6.21 MSDOS.SYS)
	; DOSCODE:40DDh (MSDOS 5.0 MSDOS.SYS)
	push	word [SAVEDS]
	pop	ds
	;
	;cmp	cl,36
        CMP     CL,MAXCALL              ; This entry point doesn't get as many calls
        JA      SHORT BADCALL
        MOV     AH,CL
	; 08/07/2018
	jmp	short SAVREGS

; ---------------------------------------------------------------------------

; 01/05/2019 - Retro DOS v4.0

	; This is the normal INT 21 entry point. We first perform a
	; quick test to see if we need to perform expensive DOS-entry
	; functions. Certain system calls are done without interrupts
	; being enabled.

	;entry	COMMAND 		; Interrupt call entry point (int 21h)

; DOSCODE:40F8h (MSDOS 6.21, MSDOS.SYS)
; 04/11/2022
; DOSCODE:40EBh (MSDOS 5.0, MSDOS.SYS)

COMMAND:
	; 22/12/2022
	cli

	; 01/05/2019 - Retro DOS v4.0
	; 08/07/2018 - Retro DOS v3.0

; 22/12/2022
; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	;IF	NOT IBM
	CMP	AH,SET_OEM_HANDLER
	JB	SHORT NOTOEM
	JMP	_$SET_OEM_HANDLER

NOTOEM:
	;ENDIF

; DOSCODE:40F8h (MSDOS 6.21, MSDOS.SYS)
; DOSCODE:40EBh (MSDOS 5.0, MSDOS.SYS)

	; 22/12/2022
	;cli	; 08/07/2018

_COMMAND: ; MSDOS 3.3 (IBM)
	;cmp	ah,6Ch   ; MSDOS 6.21 ; Max int 21h function call number
	; 04/11/2022
	CMP     AH,MAXCOM  ; 6Ch for MSDOS 6.0 (6.21,6.22) & MSDOS 5.0
	;JBE	SHORT SAVREGS
        JA	SHORT BADCALL ; 08/07/2018

	; 31/05/2019

	; The following set of calls are issued by the server at
	; *arbitrary* times and, therefore, must be executed on
	; the user's entry stack and executed with interrupts off.

SAVREGS:
	; 01/05/2019 - Retro DOS v4.0
	; 10/08/2018
	; 08/07/2018 - Retro DOS v3.0
	cmp	ah,33h			; Check Minimum special case #
	;;je	_$SET_CTRL_C_TRAPPING
	;je	short SetCtrlShortEntry ; If equal jmp directly to function
	jb	short SaveAllRegs	; Not special case so continue	
	; 04/11/2022
	je	short SetCtrlShortEntry ; If equal jmp directly to function
	cmp	ah,64h			; Check Max case number
	ja	short SaveAllRegs	; Not special case so continue
	je	short _$SET_PRINTER_FLAG ; If equal jmp directly to function
	cmp	ah,51h			; Is this a Get PSP call (51h)?
	je	short _$GET_CURRENT_PDB	; Yes, jmp directly to function
	cmp	ah,62h			; Is this a Get PSP call (62h)?
	je	short _$GET_CURRENT_PDB	; Yes, jmp directly to function
	cmp     ah,50h			; Is this a Set PSP call (50h) ?
	je	short _$SET_CURRENT_PDB	; Yes, jmp directly to function

SaveAllRegs:
	; 01/05/2019 - Retro DOS v4.0

        push	ES
	push	DS
	push	BP
	push	DI
	push	SI
	push	DX
	push	CX
	push	BX
	push	AX

	mov	AX,DS
	;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
	mov	ds,[cs:DosDSeg]
	mov	[SAVEDS],AX		; save caller's DS
	mov	[SAVEBX],BX

        ;INC     BYTE [INDOS]		; Flag that we're in the DOS
	
	; 08/07/2018 - Retro DOS v3.0        
	;xor     ax,ax
	;mov     [USER_ID],ax
	;mov     ax,[CurrentPDB]
	;mov     [PROC_ID],ax

	; 01/05/2019

	; Note: Nsp and Nss have to be unconditionally initialized here 
	; even if InDOS is zero. Programs like CROSSTALK 3.7 depend on
	; this!!!

	MOV     AX,[USER_SP]
        MOV     [NSP],AX
        MOV     AX,[USER_SS]
        MOV     [NSS],AX

	xor	AX,AX ; 0
	mov	[FSHARING],AL		; allow redirection

	test	byte [IsWin386],1	; WIN386 patch. Do not update USER_ID
	jnz	short set_indos_flag	; if win386 present
	mov	[USER_ID],AX
set_indos_flag:
	INC     BYTE [INDOS]		; Flag that we're in the DOS

        MOV     [USER_SP],SP
        MOV     [USER_SS],SS

	mov	AX,[CurrentPDB]
	mov	[PROC_ID],AX
	mov	DS,AX
	pop	AX
	push	AX

	; save user stack in his area for later returns (possibly from EXEC)

        MOV     [PDB.USER_STACK],SP
        MOV     [PDB.USER_STACK+2],SS

	; 18/07/2018
	;mov	byte [CS:FSHARING], 0

	;MOV     BX,CS			; no holes here.
	;MOV     SS,BX

	;getdseg <ss>			; ss -> dosdat, already flag is CLI
	mov	ss,[cs:DosDSeg]
					;entry	REDISP
REDISP:
        MOV     SP,AUXSTACK		; Enough stack for interrupts
        STI                             ; stack is in our space now...

	mov	bx,ss
	mov	ds,bx

	xchg	ax,bx

	xor	ax,ax ; 0

	; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; MSDOS 5.0 MSDOS.SYS - DOSCODE:416Eh  (from org 3DD0h)
	; MSDOS 6.21 MSDOS.SYS - DOSCODE:417Bh (from org 3DE0h)

	; (Note: ss: segment prefix was not needed here! ds=ss ! -04/11/2022-)

	;mov	[ss:EXTOPEN_ON],al ; 0	; Clear extended open flag
	;;and	word [ss:DOS34_FLAG],EXEC_AWARE_REDIR
	;and	word [ss:DOS34_FLAG],800h ; clear all bits except bit 11
	;mov	[ss:CONSWAP],al  ; 0	; random clean up of possibly mis-set flags
	;mov	[ss:NoSetDir],al ; 0	; set directories on search
	;mov	[ss:FAILERR],al ; 0	; FAIL not in progress
	;inc	ax
	;;inc	AL			; AL = 1
	;mov	[ss:IDLEINT],al		; presume that we can issue INT 28

	; 15/12/2022
	mov	[EXTOPEN_ON],al ; 0	; Clear extended open flag
	;and	word [DOS34_FLAG],EXEC_AWARE_REDIR
	and	word [DOS34_FLAG],800h	; clear all bits except bit 11
	mov	[CONSWAP],al  ; 0	; random clean up of possibly mis-set flags
	;mov	byte [IDLEINT],1
	mov	[NoSetDir],al ; 0	; set directories on search
	mov	[FAILERR],al ; 0	; FAIL not in progress
	inc	ax
	;inc	al			; AL = 1
	mov	[IDLEINT],al		; presume that we can issue INT 28

	XCHG	AX,BX			; Restore AX and BX = 1		

	MOV     BL,AH			
        SHL     BX,1			; 2 bytes per call in table
       
	CLD
		; Since the DOS maintains mucho state information across system
		; calls, we must be very careful about which stack we use.
		; First, all abort operations must be on the disk stack. This
		; is due to the fact that we may be hitting the disk (close
		; operations, flushing) and may need to report an INT 24.
        
	OR      AH,AH
        JZ      SHORT DSKROUT		; ABORT

        ;CMP	AH,12
        ;JBE	SHORT IOROUT		; Character I/O
        ;CMP	AH,GET_CURRENT_PDB      ; INT 24 needs GET,SET PDB
        ;JZ	SHORT IOROUT
        ;CMP	AH,SET_CURRENT_PDB
        ;JNZ	SHORT DSKROUT

		; Second, PRINT and PSPRINT and the server issue
		; GetExtendedError calls at INT 28 and INT 24 time.
		; This call MUST, therefore, use the AUXSTACK.

	; 10/08/2018
	cmp     ah,GETEXTENDEDERROR ; 59h
	je      short DISPCALL
	
	; 01/05/2019
	
		; Old 1-12 system calls may be either on the IOSTACK (normal
		; operation) or on the AUXSTACK (at INT 24 time).

	cmp     ah,12 ; STD_CON_INPUT_FLUSH ; 0Ch
	ja      short DSKROUT

IOROUT:
	; 04/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	; (ss: prefix was not needed here! ds=ss)
	;cmp	byte [ss:ERRORMODE],0	; Are we in an INT 24? 
	; 15/12/2022
	cmp     BYTE [ERRORMODE],0	; Are we in an INT 24?
        JNZ     SHORT DISPCALL		; Stay on AUXSTACK if INT 24
        MOV     SP,IOSTACK
        JMP     SHORT DISPCALL

		; We are on a system call that is classified as "the rest".
		; We place ourselves onto the DSKSTACK and away we go.
		; We know at this point:
		; *  An INT 24 cannot be in progress. Therefore we reset
		;    ErrorMode and WpErr
		; *  That there can be no critical sections in effect.
		;    We signal the server to remove all the resources.

DSKROUT:
	; 01/01/2024
	; 15/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; 08/07/2018 - Retro DOS v3.0
	mov     [USER_IN_AX],ax		; Remember what user is doing
	; 01/01/2024
	;mov	byte [EXTERR_LOCUS],1	; errLOC_Unk (Default)
	;MOV	BYTE [WPERR],-1		; error mode, so good place to
	                   		; make sure flags are reset
	mov	word [WPERR],1FFh ; (PCDOS 7.1 IBMDOS.COM))

	; 04/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	; (ss: prefix was not needed here! ds=ss)

	;mov	[ss:USER_IN_AX],ax	; Remember what user is doing
	;mov	byte [ss:EXTERR_LOCUS],1 ; errLOC_Unk (Default)
	;mov	byte [ss:ERRORMODE],0	; Cannot make non 1-12 calls in
	;mov	byte [ss:WPERR],-1	; error mode, so good place to
                                        ; make sure flags are reset
	push    ax
	mov     ah,82h			; Release all resource information
	int     2Ah 		; Microsoft Networks 
				; END DOS CRITICAL SECTIONS 0 THROUGH 7
	pop     ax

		; Since we are going to be running on the DSKStack and since
		; INT 28 people will use the DSKStack, we must turn OFF the
		; generation of INT 28's.

	; 15/12/2022
	;mov     byte [ss:IDLEINT],0
	;
        ;mov	sp,DSKSTACK
	;test	byte [ss:CNTCFLAG],-1  ; 0FFh
        ;jz	short DISPCALL

	mov     byte [IDLEINT],0

	MOV     SP,DSKSTACK
	TEST    BYTE [CNTCFLAG],-1
	JZ      SHORT DISPCALL

        PUSH    AX
        ;invoke	DSKSTATCHK
        CALL	DSKSTATCHK
	POP     AX
DISPCALL:
	; 01/05/2019 - Retro DOS v4.0
	mov	bx,[CS:BX+DISPATCH]

	; 15/12/2022
	xchg	bx,[SAVEBX]
	MOV	DS,[SAVEDS]

	; 04/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	; (ss: prefix was not needed here! ds=ss)        
	;xchg	bx,[ss:SAVEBX]
	;mov	ds,[ss:SAVEDS]

	call	word [SS:SAVEBX] ; near call

	; The EXEXA20OFF bit of DOS_FLAG will now be unconditionally cleared
	; here. Please see under M003, M009 and M068 tags in dossym.inc
	; for explanation. Also NOTE that a call to ExecReady (ax=4b05) will
	; return to LeaveDos and hence will not clear this bit. This is 
	; because this bit is used to indicate to the next int 21 call that
	; the previous int 21 was an exec.
	;
	; So do not add any code between the call above and the label 
	; LeaveDOS if it needs to be executed even for ax=4b05

	;and	byte [ss:DOS_FLAG],~EXECA20OFF
	and	byte [ss:DOS_FLAG],0FBh

; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:41F7h

; 01/01/2024 - Retro DOS v4.2 (Modified MSDOS 6.22 MSDOS.SYS)
; DOSCODE:4204h

;entry LEAVE
;;;_LEAVE:				; Exit from a system call
LeaveDOS: ; 18/07/2018 
;ASSUME	SS:NOTHING			; User routines may misbehave
	CLI

	; 01/05/2019
	;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
	mov	ds,[cs:DosDSeg]
	cmp	byte [A20OFF_COUNT],0	; M068: Q: is count 0
	jne	short disa20		; M068: N: dec count and turn a20 off

LeaveA20On:
        DEC     BYTE [INDOS]
        ; 04/11/2022
	mov	ss,[USER_SS]
	MOV     SP,[USER_SP]
	;MOV	SS,[USER_SS]
	MOV     BP,SP
	;MOV	[BP.user_AX],AL	
        ; 04/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;;mov	[bp+0],al ; MSDOS 5.0 MSDOS.SYS - DOSCODE:4212h
	;MOV	[BP+user_env.user_AX],AL  ; user_env.user_AX = 0

	; 15/12/2022
	MOV	[BP],AL	; mov [bp+0],al
	
	;MOV	AX,[NSP]
        ;MOV	[USER_SP],AX
        ;MOV	AX,[NSS]
        ;MOV	[USER_SS],AX
	; 01/01/2024
	les	ax,[NSS] ; (PCDOS 7.1 IBMDOS.COM)
	mov	[USER_SS],ax
	mov	[USER_SP],es

	pop	AX
	pop	BX
	pop	CX
	pop	DX
	pop	SI
	pop	DI
	pop	BP
	pop	DS
	pop	ES

        IRET

disa20:	   				; M068 - Start
	mov	bx,[A20OFF_PSP]		; bx = PSP for which a20 to be off'd
	cmp	bx,[CurrentPDB]		; Q: do the PSP's match
	jne	short LeaveA20On	; N: don't clear bit and don't turn 
					;    a20 off
					; Y: turn a20 off and dec a20off_count
	dec	byte [A20OFF_COUNT]	; M068 - End
 					; Start - M004
	push	ds			; segment of stub
	mov	bx,disa20_iret		; offset in stub
	push	bx
	retf	  			; go to stub
					; End - M004
;SYSTEM_CALL ENDP

; DOSCODE:424Ch (MSDOS 6.21, MSDOS.SYS)
; 04/11/2022
; DOSCODE:423Fh (MSDOS 5.0, MSDOS.SYS)

; ==========================================================================
;
; Restore_World restores all registers ('cept SS:SP, CS:IP, flags) from
; the stack prior to giving the user control
;
; ==========================================================================

; 01/05/2019 - Retro DOS v4.0

        ;procedure restore_world,NEAR
restore_world:
	;getdseg <es>		; es -> dosdata
	mov	es,[cs:DosDSeg]

        POP	WORD [ES:RESTORE_TMP]

        POP     AX
        POP     BX
        POP     CX
        POP     DX
        POP     SI
        POP     DI
        POP     BP
        POP     DS

       	jmp	word [ES:RESTORE_TMP]

;restore_world	ENDP

; 01/05/2019 - Retro DOS v4.0 (MSDOS 6.0, MSDISP.ASM, 1991)

; DOSCODE:4263h (MSDOS 6.21, MSDOS.SYS)
; 04/11/2022
; DOSCODE:4256h (MSDOS 5.0, MSDOS.SYS)

; ==========================================================================
;
; Save_World saves complete registers on the stack
;
; ==========================================================================

        ;procedure save_world,NEAR
save_world:
	;getdseg <es>		; es -> dosdata
	mov	es,[cs:DosDSeg]

        POP	WORD [ES:RESTORE_TMP]

	; 12/05/2019
        
	PUSH    DS
        PUSH    BP
        PUSH    DI
        PUSH    SI
        PUSH    DX
        PUSH    CX
        PUSH    BX
        PUSH    AX

	push	word [ES:RESTORE_TMP]

	push	BP		
	mov	BP,SP
	mov	ES,[BP+20]	; es was pushed before call
	pop	BP
	
	retn

;save_world	ENDP

; 01/05/2019

; DOSCODE:4282h (MSDOS 6.21, MSDOS.SYS)
; 04/11/2022
; DOSCODE:4275h (MSDOS 5.0, MSDOS.SYS)

; ==========================================================================
;
; Get_User_Stack returns the user's stack (and hence registers) in DS:SI
;
; ==========================================================================

        ;procedure get_user_stack,NEAR
Get_User_Stack:
        ;getdseg <DS>			; DS -> DosData, ASSUME DS:DosSeg
	mov	ds,[cs:DosDSeg]
        lds	si,[USER_SP]
	retn

;get_user_stack  ENDP

; 22/12/2022
; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0, MSDOS.SYS)
;%if 0

; ---------------------------------------------------------------------------
;
; Set_OEM_Handler -- Set OEM sys call address and handle OEM Calls
; Inputs:
;	User registers, User Stack, INTS disabled
;	If CALL F8, DS:DX is new handler address
; Function:
;	Process OEM INT 21 extensions
; Outputs:
;	Jumps to OEM_HANDLER if appropriate
;
; ---------------------------------------------------------------------------

;IF	NOT IBM

_$SET_OEM_HANDLER:
	; 01/05/2019 - Retro DOS v4.0
	
	;(cmp	ah,SET OEM HANDLER  ; 0F8h)
	;(jb	short NOTOOEM)

	push	es ; *
	;getdseg <es>			; es -> dosdata
	mov	es,[cs:DosDSeg]

	jne	short check_trueversion_request ; check Retro DOS true version
						; (message) request	
	; AH = 0F8h = SET OEM HANDLER

	MOV     [es:OEM_HANDLER],DX	; Set Handler
	MOV     [es:OEM_HANDLER+2],DS

	pop	es ; *

	IRET                            ; Quick return, Have altered no registers

check_trueversion_request:
	; 18/07/2019 - Retro DOS v3.0

	; Retro DOS v2.0 - 20/04/2018
	CMP	AX,0FFFFh
	; 18/07/2018
	jne	short DO_OEM_FUNC ; 01/05/2019

	; 01/05/2019
	pop	es ; *

	mov	ah,0Eh

	; Retro DOS v4.0 feature only!
	cmp	bx,417  ; Signature to bypass
			; Retro DOS true version message	
	je	short true_version_iret

	push	si
	push	bx

	mov	si,RETRODOSMSG
wrdosmsg:
	;movb	ah,0Eh
	mov	bx,7
wrdosmsg_nxt:
	cs	lodsb
	cmp	al,'$'
	je	short wrdosmsg_ok		
	int	10h
	jmp	short wrdosmsg_nxt

wrdosmsg_ok:
	pop	bx
	pop	si

true_version_iret:
	; ah = 0Eh
	;mov	al,40h ; Retro DOS v4.0
	; 
	;mov	al,41h ; Retro DOS v4.1 
	; 30/12/2022
	mov	al,42h ; Retro DOS v4.2
	iret

	; If above F8 try to jump to handler

DO_OEM_FUNC:
	; 01/05/2019
	cmp     word [es:OEM_HANDLER],-1
	JNE     short OEM_JMP
	pop	es ; *
	JMP     BADCALL                 ; Handler not initialized
OEM_JMP:
	push	es
	pop	ds ; DOSDATA segment !
	pop	es ; *

	; 22/12/2022
	sti	; (enable interrupts before jumping to private handler)  

	JMP     FAR [OEM_HANDLER]

;       ENDIF

; ---------------------------------------------------------------------------

;%endif

;============================================================================
; MCODE.ASM, MSDOS 6.0, 1991
;============================================================================
; 17/07/2018 - Retro DOS v3.0

;	TITLE	MISC DOS ROUTINES - Int 25 and 26 handlers and other
;	NAME	IBMCODE

;BREAK <NullDev -- Driver for null device>

; ROMDOS note:
;	NUL device driver used to be here, but it was removed and placed in
;	DOSDATA, because the entry points have to be in the segment as the
;	header, which is also in DOSDATA.

;BREAK <AbsDRD, AbsDWRT -- INT int_disk_read, int_disk_write handlers>

;----------------------------------------------------------------------------
; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0, MSDOS.SYS)
;----------------------------------------------------------------------------
; DOSCODE:428Ch (MSDOS 6.21 MSDOS.SYS)
; DOSCODE:427Fh (MSDOS 5.0 MSDOS.SYS)

;Public MSC001S,MSC001E
;MSC001S label byte
	;IF	IBM
; Codes returned by BIOS
ERRIN:
	DB	2			; NO RESPONSE
	DB	6			; SEEK FAILURE
	DB	12			; GENERAL ERROR
	DB	4			; BAD CRC
	DB	8			; SECTOR NOT FOUND
	DB	0			; WRITE ATTEMPT ON WRITE-PROTECT DISK
ERROUT:
; DISK ERRORS RETURNED FROM INT 25 and 26
	DB	80H			; NO RESPONSE
	DB	40H			; Seek failure
	DB	2			; Address Mark not found
	DB	10H			; BAD CRC
	DB	4			; SECTOR NOT FOUND
	DB	3			; WRITE ATTEMPT TO WRITE-PROTECT DISK

NUMERR	EQU	$-ERROUT
	;ENDIF
;MSC001E label byte
;----------------------------------------------------------------------------

;============================================================================
; MSCODE.ASM - MSDOS 6.0 - 1991
;============================================================================
; 18/07/2018 - Retro DOS v3.0
; 15/05/2019 - Retro DOS v4.0

;BREAK <AbsDRD, AbsDWRT -- INT int_disk_read, int_disk_write handlers>>

;   AbsSetup - setup for abs disk functions
;----------------------------------------------------------------------------

AbsSetup:
	; 02/01/2024
	push	ds ; *
	push	ss
	pop	ds
	inc	byte [INDOS]
	;INC	byte [SS:INDOS]		; SS override
	STI
	CLD
	; 02/01/2024
	;PUSH	DS
	;push	ss
	;pop	ds
	CALL	GETBP
	; 02/01/2024
	pop	ds ; *
	JC	short errdriv 		; PM. error drive ;AN000;
	;mov	word [es:bp+1Fh]
	MOV	WORD [ES:BP+DPB.FREE_CNT],-1 ; do not trust user at all.

	; 02/01/2024
;errdriv:
;	POP	DS
;	jnc	short AbsSetup2
;AbsSetup_retn:
;	retn

AbsSetup2:
	; 15/05/2019 - Retro DOS v4.0
	; MSDOS 6.0
					; SS override
	MOV	word [SS:HIGH_SECTOR],0 ;>32mb	from API		;AN000;
	CALL	RW32_CONVERT		;>32mb convert 32bit format to 16bit ;AN000;
	jc	short AbsSetup_retn
	call	SET_RQ_SC_PARMS 	;LB. set up SC parms		;AN000;

	; MSDOS 3.3 (& MSDOS 6.0)
	PUSH	DS
	PUSH	SI
	PUSH	AX

	push	ss
	pop	ds
	
	MOV	SI,OPENBUF
	MOV	[SI],AL
	ADD	BYTE [SI],"A"
	MOV	WORD [SI+1],003AH ; ":",0
	MOV	AX,0300H
	CLC
	INT	int_IBM ; int 2Ah	; Will set carry if shared
		
		; 04/11/2022
		; (INT 2Ah - AX = 0300h)
		; Microsoft Networks - CHECK DIRECT I/O
		; DS:SI -> ASCIIZ disk device name (may be full path or
		;    only drive specifier--must include the colon)
		; Return: CF clear if absolute disk access allowed

	POP	AX
	POP	SI
	POP	DS
	jnc	short AbsSetup_retn

	;mov	word [ss:EXTERR],32h
	MOV	word [ss:EXTERR],error_not_supported
errdriv:	; 02/01/2024
AbsSetup_retn:
	retn

;---------------------------------------------------------------------------
;
; Procedure Name : ABSDRD
;
; Interrupt 25 handler. Performs absolute disk read.
; Inputs:	AL - 0-based drive number
;		DS:BX point to destination buffer
;		CX number of logical sectors to read
;		DX starting logical sector number (0-based)
; Outputs:	Original flags still on stack
;		Carry set
;		    AH error from BIOS
;		    AL same as low byte of DI from INT 24
;
;---------------------------------------------------------------------------
        ;procedure   ABSDRD,FAR
ABSDRD:
	; 15/05/2019 - Retro DOS v4.0
	; MSDOS 6.21 (DOSCODE:42E5h)
	; 04/11/2022
	; MSDOS 5.0 (DOSCODE:42D8h)
	
	; MSDOS 6.0
	CLI
	
;	set up ds to point to DOSDATA

	push	ax			; preserve AX value
	mov	ax,ds			; store DS value in AX
	;getdseg <ds>
	mov	ds,[cs:DosDSeg]
	mov	[TEMPSEG],ax		; store DS value in TEMPSEG
	pop	ax			; restore AX value

	; M072:
	; We shall save es on the user stack here. We need to use ES in
	; order to access the DOSDATA variables AbsRdWr_SS/SP at exit 
	; time in order to restore the user stack.

	push	es  ; ****		; M072

	MOV	[AbsRdWr_SS],SS		; M013
	MOV	[AbsRdWr_SP],SP		; M013

; 	set up ss to point to DOSDATA
;
; NOTE! Due to an obscure bug in the 80286, you cannot use the ROMDOS
; version of the getdseg macro with the SS register! An interrupt will
; sneak through.

;ifndef ROMDOS
	;getdseg <ss>			; cli in entry of routine
	mov     ss,[cs:DosDSeg]
;else
;	mov	ds, cs:[BioDataSeg]
;	assume	ds:bdata
;
;	mov	ss, ds:[DosDataSg]
;	assume	ss:DOSDATA
;
;endif ; ROMDOS

	MOV	SP,DSKSTACK

	mov	ds,[TEMPSEG]		; restore DS value

	push	es ; *** (MSDOS 6.21)
	call	save_world		; save all regs

	PUSH	ES ; **
	CALL	AbsSetup
	JC	short ILEAVE

	; Here is a gross temporary fix to get around a serious design flaw in
	;  the secondary cache. The secondary cache does not check for media
	;  changed (it should). Hence, you can change disks, do an absolute
	;  read, and get data from the previous disk. To get around this,
	;  we just won't use the secondary cache for absolute disk reads.
	;                                                      -mw 8/5/88

	;EnterCrit critDisk
	call	ECritDisk
	MOV	byte [ss:CurSC_DRIVE],-1 ; invalidate SC  ;AN000;
	;LeaveCrit critDisk
	call	LCritDisk

        ;invoke	DSKREAD
	CALL	DSKREAD
        jnz	short ERR_LEAVE		;Jump if read unsuccessful.

        mov     cx,di
        mov     [ss:TEMP_VAR2],ds
        mov     [ss:TEMP_VAR],bx

;       CX = # of contiguous sectors read. (These constitute a block of
;            sectors, also termed an "Extent".)
;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
;       [TEMP_VAR2]:[TEMP_VAR] = Transfer address (destination data address).
;       ES:BP -> Drive Parameter Block (DPB).
;
;	The Buffer Queue must now be scanned: the contents of any dirty
;	buffers must be "read" into the transfer memory block, so that the
;       transfer memory reflects the most recent data.

	;invoke	DskRdBufScan		;This trashes DS, but don't care.
        call	DskRdBufScan
	jmp     short ILEAVE

TLEAVE:
	JZ	short ILEAVE

ERR_LEAVE:				; M039
	; 15/07/2018 - Retro DOS v3.0
        ;IF	IBM
; Translate the error code to ancient 1.1 codes
        PUSH    ES ; *
        PUSH    CS
        POP     ES
        XOR     AH,AH			; Nul error code
	;mov	cx,6
        MOV     CX,NUMERR		; Number of possible error conditions
        MOV     DI,ERRIN		; Point to error conditions
        REPNE   SCASB
        JNZ     SHORT LEAVECODE		; Not found
	;mov	ah,[ES:DI+5]
        MOV     AH,[ES:DI+NUMERR-1]	; Get translation
LEAVECODE:
        POP     ES ; *
	; 15/05/2019 - Retro DOS v4.0
	mov	[ss:AbsDskErr],ax
        ;ENDIF

        STC
ILEAVE:
	; 15/05/2019
        POP     ES ; **
	call	restore_world
        pop	es ; *** (MSDOS 6.21)
	CLI
	mov     ax,[ss:AbsDskErr]	; restore error
	DEC	BYTE [SS:INDOS]
        push	ss			; M072 - Start
	pop	es			; es - dosdata
        mov	ss,[es:AbsRdWr_SS]	; M013
	mov	sp,[es:AbsRdWr_SP]	; M013
	pop	es  ; ****		; Note es was saved on user
					; stack at entry 
					; M072 - End
        STI
	RETF   ; ! FAR return !

;ABSDRD	ENDP

;---------------------------------------------------------------------------
;
; Procedure Name : ABSDWRT
;
; Interrupt 26 handler. Performs absolute disk write.
; Inputs:	AL - 0-based drive number
;		DS:BX point to source buffer
;		CX number of logical sectors to write
;		DX starting logical sector number (0-based)
; Outputs:	Original flags still on stack
;		Carry set
;		    AH error from BIOS
;		    AL same as low byte of DI from INT 24
;
;---------------------------------------------------------------------------
        ;procedure   ABSDWRT,FAR
ABSDWRT:
	; 15/05/2019 - Retro DOS v4.0
	; MSDOS 6.21 (DOSCODE:436Ch)
	; 04/11/2022
	; MSDOS 5.0 (DOSCODE:435Fh)

	CLI

;	set up ds to point to DOSDATA

	push	ax
	mov	ax,ds
	;getdseg <ds>
	mov	ds,[cs:DosDSeg]
	mov	[TEMPSEG],ax
	pop	ax

	; M072:
	; We shall save es on the user stack here. We need to use ES in
	; order to access the DOSDATA variables AbsRdWr_SS/SP at exit 
	; time in order to restore the user stack.

	push	es ; ****		; M072

	MOV	[AbsRdWr_SS],SS		; M013
	MOV	[AbsRdWr_SP],SP		; M013

	; set up ss to point to DOSDATA
	;
	; NOTE! Due to an obscure bug in the 80286, you cannot use the 
	; ROMDOS version of the getdseg macro with the SS register!
	; An interrupt will sneak through.

;ifndef ROMDOS
	;getdseg <ss>			; cli in entry of routine
	mov     ss,[cs:DosDSeg]
;else
;	mov	ds, cs:[BioDataSeg]
;	assume	ds:bdata
;
;	mov	ss, ds:[DosDataSg]
;	assume	ss:DOSDATA
;
;endif ; ROMDOS

	MOV	SP,DSKSTACK
		; we are now switched to DOS's disk stack

	mov	ds,[TEMPSEG]		; restore user's ds

	push	es ; *** (MSDOS 6.21)

	call	save_world	      	; save all regs

	PUSH	ES ; **
	CALL	AbsSetup
	JC	short ILEAVE

	;EnterCrit critDisk
	call	ECritDisk
	MOV	byte [ss:CurSC_DRIVE],-1 ; invalidate SC ;AN000;
	CALL	Fastxxx_Purge		 ; purge fatopen ;AN000;
	;LeaveCrit critDisk
	call	LCritDisk

;M039
;       DS:BX = transfer address (source data address).
;       CX = # of contiguous sectors to write. (These constitute a block of
;	     sectors, also termed an "Extent".)
;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
;       ES:BP -> Drive Parameter Block (DPB).
;       [CURSC_DRIVE] = -1 (invalid drive).
;
;       Free any buffered sectors which are in Extent; they are being over-
;       written. Note that all the above registers are preserved for
;       DSKWRITE.

        push    ds
	;invoke	DskWrtBufPurge          ;This trashes DS.
	call	DskWrtBufPurge
        pop     ds
;M039
	;invoke	DSKWRITE
	call	DSKWRITE
	JMP	short TLEAVE

;ABSDWRT ENDP

;----------------------------------------------------------------------------
;
; Procedure Name : GETBP
;
; Inputs:
;	AL = Logical unit number (A = 0)
; Function:
;	Find Drive Parameter Block
; Outputs:
;	ES:BP points to DPB
;	[THISDPB] = ES:BP
;	Carry set if unit number bad or unit is a NET device.
;		Later case sets extended error error_I24_not_supported
; No other registers alteredjjj
;
;----------------------------------------------------------------------------

	; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
GETBP:
	; 15/05/2019 - Retro DOS v4.0
	; 11/07/2018 - Retro DOS v3.0
	PUSH	AX
	ADD	AL, 1		; No increment; need carry flag
	JC	SHORT SKIPGET
	CALL	GETTHISDRV
	; MSDOS 6.0
	JNC	SHORT SKIPGET		;PM. good drive		;AN000;
	XOR	AH,AH			;DCR. ax= error code 	;AN000;
	CMP	AX,error_not_DOS_disk	;DCR. is unknown media ? ;AN000;
	JZ	SHORT SKIPGET 		;DCR. yes, let it go 	;AN000;
	STC				;DCR.			;AN000;
	MOV	[EXTERR],AX	;PM. invalid drive or Non DOS drive ;AN000;
	MOV	WORD [AbsDskErr],201h
SKIPGET:
	POP	AX
	JC	SHORT GETBP_RETN ; 15/12/2022
	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;jnc	short getbp_t
	;retn
getbp_t:
	LES	BP,[THISCDS]
	; 15/12/2022
	test	byte [es:bp+curdir.flags+1],curdir_isnet>>8
	; 07/12/2022
	;TEST	WORD [ES:BP+43H],8000H
	;TEST	WORD [ES:BP+curdir.flags],curdir_isnet ; Clears carry
	JZ	SHORT GETBP_CDS
	MOV	WORD [EXTERR],error_not_supported  ; 32h
	STC
GETBP_RETN:
	RETN

GETBP_CDS:
	;LES	BP,[ES:BP+45H]
	LES	BP,[ES:BP+curdir.devptr]
GOTDPB:
	; Load THISDPB from ES:BP
	MOV	[THISDPB],BP
	MOV	[THISDPB+2],ES
	RETN

;BREAK <SYS_RET_OK SYS_RET_ERR CAL_LK ETAB_LK set system call returns>

;----------------------------------------------------------------------------
;
; Procedure Name : SYS_RETURN
;
; These are the general system call exit mechanisms. All internal system
; calls will transfer (jump) to one of these at the end. Their sole purpose
; is to set the user's flags and set his AX register for return.
;
;----------------------------------------------------------------------------

        ;procedure   SYS_RETURN,NEAR
SYS_RETURN:        
        ;entry	SYS_RET_OK
SYS_RET_OK:   
	call    Get_User_Stack
		; turn off user's carry flag
SYS_RET_OK_clc: ; 25/06/2019 
        ;;and	word [SI+16h],0FFFEh 
	;and	word [SI+user_env.user_F],~f_Carry 
        ; 25/06/2019
	and	byte [SI+user_env.user_F],~f_Carry ; 0FEh
	JMP     SHORT DO_RET

        ;entry   SYS_RET_ERR
SYS_RET_ERR:        
	XOR     AH,AH 		; hack to allow for smaller error rets
	call	ETAB_LK 	; Make sure code is OK, EXTERR gets set
	CALL	ErrorMap

	;entry	From_GetSet
From_GetSet:
        call    Get_User_Stack
		 ; signal carry to user
	;;or	word [SI+16h],1
	;OR	word [SI+user_env.user_F],f_Carry
	; 25/06/2019
	or	byte [SI+user_env.user_F],f_Carry
	STC			; also, signal internal error
DO_RET:
        ;MOV	[SI+user_env.user_AX],AX ; Really only sets AH
	MOV	[SI],AX
	RETN

	;entry	FCB_RET_OK
FCB_RET_OK:
	;entry	NO_OP		; obsolete system calls dispatch to here
NO_OP:
	XOR	AL,AL
	retn

	;entry	FCB_RET_ERR
FCB_RET_ERR:
	XOR	AH,AH
	mov	[ss:EXTERR],AX
	CALL	ErrorMap
	MOV	AL,-1
	retn

	;entry	ErrorMap
ErrorMap:
	PUSH	SI
				; ERR_TABLE_21 is now in DOSDATA
	MOV	SI,ERR_TABLE_21
				; SS override for FAILERR and EXTERR
	CMP	byte [SS:FAILERR],0 ; Check for SPECIAL case.
	JZ	short EXTENDED_NORMAL ; All is OK.
		 ; Ooops, this is the REAL reason
	;mov	word [SS:EXTERR],53h
	MOV	word [SS:EXTERR],error_FAIL_I24
EXTENDED_NORMAL:
	call	CAL_LK		; Set CLASS,ACTION,LOCUS for EXTERR
	POP	SI
	retn

	;EndProc SYS_RETURN

;---------------------------------------------------------------------------
;
; Procedure Name : CAL_LK
;
; Inputs:
;	SI is OFFSET in DOSDATA of CLASS,ACTION,LOCUS Table to use
;		(DS NEED not be DOSDATA)
;	[EXTERR] is set with error
; Function:
;	Look up and set CLASS ACTION and LOCUS values for GetExtendedError
; Outputs:
;	[EXTERR_CLASS] set
;	[EXTERR_ACTION] set
;	[EXTERR_LOCUS] set  (EXCEPT on certain errors as determined by table)
; Destroys SI, FLAGS
;
;---------------------------------------------------------------------------

	;procedure CAL_LK,NEAR
CAL_LK:
	PUSH	DS
	PUSH	AX
	PUSH	BX

;M048	Context DS		; DS:SI -> Table
;
; Since this function can be called thru int 2f we shall not assume that SS
; is DOSDATA

	;getdseg  <ds>	; M048: DS:SI -> Table
	; 15/05/2019 - Retro DOS v4.0
	mov	ds,[cs:DosDSeg]

	; 18/07/2018
	;push	ss
	;pop	ds

	MOV	BX,[EXTERR]	; Get error in BL
TABLK1:
	LODSB

	CMP	AL,0FFH
	JZ	short GOT_VALS	; End of table
	CMP	AL,BL
	JZ	short GOT_VALS	; Got entry
	ADD	SI,3		; Next table entry
	; 15/08/2018
	JMP	short TABLK1

GOT_VALS:
	LODSW			; AL is CLASS, AH is ACTION

	CMP	AH,0FFH
	JZ	short NO_SET_ACT
	MOV	[EXTERR_ACTION],AH ; Set ACTION
NO_SET_ACT:
	CMP	AL,0FFH
	JZ	short NO_SET_CLS
	MOV	[EXTERR_CLASS],AL ; Set CLASS
NO_SET_CLS:
	LODSB			; Get LOCUS

	CMP	AL,0FFH
	JZ	short NO_SET_LOC
	MOV	[EXTERR_LOCUS],AL
NO_SET_LOC:
	POP	BX
	POP	AX
	POP	DS
	retn

	;EndProc CAL_LK

;---------------------------------------------------------------------------
;
; Procedure Name : ETAB_LK
;
; Inputs:
;	AX is error code
;	[USER_IN_AX] has AH value of system call involved
; Function:
;	Make sure error code is appropriate to this call.
; Outputs:
;	AX MAY be mapped error code
;	[EXTERR] = Input AX
; Destroys ONLY AX and FLAGS
;
;---------------------------------------------------------------------------

	;procedure ETAB_LK,NEAR

ETAB_LK: ; 10/08/2018 - Retro DOS v3.0
	PUSH	DS
	PUSH	SI
	PUSH	CX
	PUSH	BX

	;Context DS			; SS is DOSDATA

	push	ss
	pop	ds

	MOV	[EXTERR],AX		; Set EXTERR with "real" error

					; I21_MAP_E_TAB is now in DOSCODE
	MOV	SI,I21_MAP_E_TAB
	MOV	BH,AL			; Real code to BH
	MOV	BL,[USER_IN_AX+1]	; Sys call to BL
TABLK2:
	; 15/05/2019 - Retro DOS v4.0
	cs
	lodsw	; MSDOS 6.0 (MSDOS 6.21 - MSDOS.SYS, DOSCODE:447Dh)
	
	; 18/07/2018 - Retro DOS v3.0
	;lodsw		; IBMDOS.COM (MSDOS 3.3) - Offset 16F7h

	CMP	AL,0FFH 		; End of table?
	JZ	short NOT_IN_TABLE	; Yes
	CMP	AL,BL			; Found call?
	JZ	short GOT_CALL		; Yes
	XCHG	AH,AL			; Count to AL
	XOR	AH,AH			; Make word for add
	ADD	SI,AX			; Next table entry
	JMP	short TABLK2

NOT_IN_TABLE:
	MOV	AL,BH			; Restore original code
	JMP	SHORT NO_MAP

GOT_CALL:
	MOV	CL,AH
	XOR	CH,CH			; Count of valid err codes to CX
CHECK_CODE:
	; 15/05/2019 - Retro DOS v4.0
	cs
	lodsb	; MSDOS 6.0 (MSDOS 6.21 - MSDOS.SYS, DOSCODE:4497h)

	; 18/07/2018
	;lodsb		; IBMDOS.COM (MSDOS 3.3) - Offset 1710h

	CMP	AL,BH			; Code OK?
	JZ	short NO_MAP		; Yes
	LOOP	CHECK_CODE
NO_MAP:
	XOR	AH,AH			; AX is now valid code
	POP	BX
	POP	CX
	POP	SI
	POP	DS
	retn

	;EndProc ETAB_LK

; 18/07/2018 - Retro DOS v3.0
;---------------------------------------------------------------------------
; BREAK <DOS 2F Handler and default NET 2F handler>

;IF installed ; (*)

;---------------------------------------------------------------------------
;
; Procedure Name : SetBad
;
; SetBad sets up info for bad functions
;
;---------------------------------------------------------------------------

SetBad:
	;mov	ax,1
	MOV	AX,error_invalid_function ; ALL NET REQUESTS get inv func

	; MSDOS 3.3
	;;mov	byte [cs:EXTERR_LOCUS],1
	;MOV	byte [CS:EXTERR_LOCUS],errLOC_Unk

;	set up ds to point to DOSDATA

	; 15/05/2019 - Retro DOS v4.0
	; MSDOS 6.0
	push	ds

	;getdseg <ds>
	mov	ds,[cs:DosDSeg]

	MOV	byte [EXTERR_LOCUS],errLOC_Unk ; 1	

	pop	ds	  	;hkn; restore ds

	STC
	retn

;--------------------------------------------------------------------------
;
; Procedure Name : BadCall
;
; BadCall is the initial routine for bad function calls
;
;--------------------------------------------------------------------------

BadCall:
	call	SetBad
	retf

;--------------------------------------------------------------------------
;
; OKCall always sets carry to off.
;
;-----------------------------------------------------------------------

OKCall:
	CLC
	retf

;---------------------------------------------------------------------------
;
; Procedure Name : INT2F
;
; INT 2F handler works as follows:
;   PUSH    AX
;   MOV     AX,multiplex:function
;   INT     2F
;   POP     ...
; The handler itself needs to make the AX available for the various routines.
;
;----------------------------------------------------------------------------

; 15/05/2019 - Retro DOS v4.0

;KERNEL_SEGMENT equ 70h
; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
DOSBIODATASEG equ 70h

; retrodos4.s - offset in BIOSDATA
bios_i2f equ 5

;PUBLIC	Int2F
;INT2F	PROC	FAR

; 15/05/2019
; DOSCODE:44BDh (MSDOS 6.21, MSDOS.SYS)

; 04/11/2022
; DOSCODE:44B0h (MSDOS 5.0, MSDOS.SYS)

	; 05/01/2024
	; 15/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; 18/07/2018 - Retro DOS v3.0
INT2F:
	; Offset 172Fh in IBMDOS.COM (MSDOS 3.3), 1987
INT2FNT:
	;ASSUME	CS:DOSCODE,DS:NOTHING,ES:NOTHING,SS:NOTHING
	STI
	;cmp	ah,11h
	CMP	AH,MultNET
	JNZ	short INT2FSHR
TestInstall:
	OR	AL,AL
	JZ	short Leave2F
BadFunc:
	CALL	SetBad

	;entry	Leave2F
Leave2F:
	RETF	2			; long return + clear flags off stack

INT2FSHR:
	;cmp	ah,10h
	CMP	AH,MultSHARE		; is this a share request
	JZ	short TestInstall	; yes, check for installation
INT2FNLS:
	;cmp	ah,14h
	CMP	AH,NLSFUNC		; is this a DOS 3.3 NLSFUNC request
	JZ	short TestInstall	; yes check for installation
INT2FDOS:
	;ASSUME	CS:DOSCODE,DS:NOTHING,ES:NOTHING,SS:NOTHING

	; 18/07/2018
	; MSDOS 3.3
	;;cmp	ah,12h	
	;CMP	AH,MultDOS
	;jz	short DispatchDOS
	;iret

	; 15/05/2019
	; MSDOS 6.0
	;cmp	ah,12h	; 07/12/2022
	CMP	AH,MultDOS
	JNZ	short check_win		;check if win386 broadcast
	jmp	DispatchDOS

	; .... win386 .... 

check_win:
	;cmp	ah,16h
	cmp	ah,MultWin386		; Is this a broadcast from Win386?
	je	short Win386_Msg

	; M044
	; Check if the callout is from Winoldap indicating swapping out or in 
	; of Windows. If so, do special action of going and saving last para
	; of the Windows memory arena which Winoldap does not save due to a 
	; bug

	cmp	ah,WINOLDAP ; 46h	; from Winoldap?
	;jne	short next_i2f		; no, chain on
	; 15/12/2022
	;jmp	winold_swap		; yes, do desired action
	je	short winold_swap
	jmp	next_i2f

	; 15/12/2022
;next_i2f:
;	;;;jmp	bios_i2f
;	;;jmp	far ptr 70h:5 ; MSDOS 6.21 (MSDOS.SYS, DOSCODE:44F1h)
;	;jmp	KERNEL_SEGMENT:bios_i2f
;	; 04/11/2022
;	jmp	DOSBIODATASEG:bios_i2f

;	IRET				; This assume that we are at the head
					; of the list
;INT2F	ENDP

; 15/05/2019 - Retro DOS v4.0

; We have received a message from Win386. There are three possible
; messages we could get from Win386:
;
; Init 		- for this, we set the IsWin386 flag and return a pointer
;		  to the Win386 startup info structure.
; Exit		- for this, we clear the IsWin386 flag.
; DOSMGR query 	- for this, we need to indicate that instance data
;		  has already been handled. this is indicated by setting
;		  CX to a non-zero value.

Win386_Msg:
	push	ds

	;getdseg <DS>			; ds is DOSDATA
	mov	ds,[cs:DosDSeg]

	; For WIN386 2.xx instance data

	cmp	al,3			; win386 2.xx instance data call?
	jne	short Win386_Msg_exit
	jmp	OldWin386Init		; yes, return instance data
Win386_Msg_exit:
	cmp	al,Win386_Exit	 ; 6	; is it an exit call?
	jne	short Win386_Msg_devcall
	jmp	Win386_Leaving
Win386_Msg_devcall:
	cmp	al,Win386_Devcall ; 7	; is it call from DOSMGR?
	jne	short Win386_Msg_init
	jmp	Win386_Query
Win386_Msg_init:
	cmp	al,Win386_Init	; 5	; is it an init call?
	je	short Win386_Starting
	jmp	win_nexti2f		; no, return
Win386_Starting:
	; 17/12/2022
	test	dl,1
	;test	dx,1			; is this really win386?
	jz	short Win386_vchk	; YES! go and handle it
	jmp	win_nexti2f		; NO! It's win 286 dos extender! M002
Win386_vchk:
	; M018 -- start of block changes
	; The VxD needs to be loaded only for Win 3.0. If version is greater 
	; than 030Ah, we skip the VxD presence check

;M067 -- Begin changes
; If Win 3.0 is run, the VxD ptr has been initialized. If Win 3.1 is now
;run, it tries to unnecesarily load the VxD even though it is not needed.
;So, we null out the VxD ptr before the check.

	;mov	word [Win386_Info+6],0
	mov	word [Win386_Info+Win386_SIS.Virt_Dev_File_Ptr],0
	;mov	word [Win386_Info+8],0
	mov	word [Win386_Info+Win386_SIS.Virt_Dev_File_Ptr+2],0

;M067 -- End changes

;ifdef JAPAN
;	cmp	di,0300h		; version >= 300 i.e 3.10 ;M037
;else
	cmp	di,030Ah		; version >= 30a i.e 3.10 ;M037
;endif
	;ljae	noVxD31			; yes, VxD not needed 	 ;M037
	jb	short Win386_vxd
	jmp	noVxD31

	; 15/12/2022
winold_swap:
	push	ds
	push	es
	push	si
	push	di
	push	cx

	;getdseg <ds>			;ds = DOSDATA
	mov	ds,[cs:DosDSeg]

	cmp	al,1			;swap Windows out call
	jne	short swapin		;no, check if Swap in call
	call	getwinlast
	push	ds
	pop	es
	mov	ds,si			;ds = memory arena of Windows
	xor	si,si
	mov	di,WinoldPatch1
	mov	cx,8
	cld
	push	cx
	rep	movsb			;save first 8 bytes
	pop	cx
	mov	di,WinoldPatch2
	rep	movsb			;save next 8 bytes
	jmp	short winold_done
swapin:
	cmp	al,2			;swap Windows in call?
	jne	short winold_done	;no, something else, pass it on
	call	getwinlast
	mov	es,si
	xor	di,di
	mov	si,WinoldPatch1
	mov	cx,8
	cld
	push	cx
	rep	movsb			;restore first 8 bytes
	pop	cx
	mov	si,WinoldPatch2
	rep	movsb			;restore next 8 bytes
winold_done:
	pop	cx
	pop	di
	pop	si
	pop	es
	pop	ds
	jmp	short next_i2f		;chain on
	; 15/12/2022
	;jmp	next_i2f	

Win386_vxd:
	push	ax
	push	bx
	push	cx
	push	dx
	push	si
	push	di			; save regs !!dont change order!!

	mov	bx,[UMB_HEAD]		; M062 - Start
	cmp	bx,0FFFFh    		; Q: have umbs been initialized
	je	short Vxd31		; N: continue
					; Y: save arena associated with 
					;    umb_head

	mov	byte [UmbSaveFlag],1	; indicate that we're saving 
					; umb_arena
	push	ds
	push	es

	;mov	ax,ds
	;mov	es,ax			; es - > dosdata
	; 05/01/2024
	push	ds
	pop	es

	mov	ds,bx
	xor	si,si			; ds:si -> umb_head

	cld

	mov	di,UmbSave1
	mov	cx,11
	rep	movsb

	mov	di,UmbSave2
	;mov	cx,5
	; 18/12/2022
	mov	cl,5
	rep	movsb	

	pop	es
	pop	ds			; M062 - End

Vxd31:
	;test	byte [DOS_FLAG],2
	test	byte [DOS_FLAG],SUPPRESS_WINA20	; M066
	jz	short Dont_Supress		; M066
	pop	di				; M066
	pop	si				; M066
	pop	dx				; M066
	pop	cx				; M066
	pop	bx				; M066
	pop	ax				; M066
	jmp	short noVxD31			; M066

	; We check here if the VxD is available in the root of the boot drive. 
	; We do an extended open to suppress any error messages
	
Dont_Supress:
	mov	al,[BOOTDRIVE]
	add	al,'A' - 1		; get drive letter
	mov	[VxDpath],al		; path is root of bootdrive
	;mov	ah,ExtOpen  ;6Ch	; extended open
	;mov	al,0			; no extended attributes
	; 18/12/2022
	mov	ax,ExtOpen<<8 ; 6C00h
	mov	bx,2080h		; read access, compatibility mode
					; no inherit, suppress crit err
	mov	cx,7			; hidden,system,read-only attr
	mov	dx,1			; fail if file does not exist
	mov	si,VxDpath	
					; path of VxD file
	mov	di,0FFFFh		; no extended attributes

	int	21h			; do extended open

	pop	di
	pop	si
	pop	dx
	pop	cx

	jnc	short VxDthere		; we found the VxD, go ahead

	; We could not find the VxD. Cannot let windows load. Return cx != 0 
	; to indicate error to Windows after displaying message to user that 
	; VxD needs to be present to run Windows in enhanced mode.

	push	dx
	push	ds
	push	si
	mov	si,NoVxDErrMsg
	push	cs
	pop	ds
	mov	cx,VxDMesLen ; 99	;
	mov	ah,2			; write char to console
	cld
vxdlp:
	lodsb
	xchg	dl,al			; get char in dl
	int	21h
	loop	vxdlp

	pop	si
	pop	ds
	pop	dx
	pop	bx
	pop	ax			;all registers restored
	inc	cx			;cx != 0 to indicate error
	; 15/12/22022
	;jmp	win_nexti2f		;chain on
	;jmp	short win_nexti2f

	; 15/12/2022
win_nexti2f:
	pop	ds
	;jmp	short next_i2f		; go to BIOS i2f handler
	; 15/12/2022
next_i2f:
	;;;jmp	bios_i2f
	;;jmp	far ptr 70h:5 ; MSDOS 6.21 (MSDOS.SYS, DOSCODE:44F1h)
	;jmp	KERNEL_SEGMENT:bios_i2f
	; 04/11/2022
	jmp	DOSBIODATASEG:bios_i2f

VxDthere:
	mov	bx,ax
	mov	ah,CLOSE ; 3Eh
	int	21h			;close the file

	; Update the VxD ptr in the instance data structure with path to VxD

	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;mov	bx,Win386_Info
	;mov	word [bx+Win386_SIS.Virt_Dev_File_Ptr],VxDpath
	;mov	word [bx+Win386_SIS.Virt_Dev_File_Ptr+2],ds
	; 15/12/2022
	mov	word [Win386_Info+Win386_SIS.Virt_Dev_File_Ptr],VxDpath
	mov	word [Win386_Info+Win386_SIS.Virt_Dev_File_Ptr+2],ds

	pop	bx
	pop	ax
noVxD31:
	; M018; End of block changes

	or	byte [IsWin386],1 	; Indicate WIN386 present
	or	byte [redir_patch],1	; Enable critical sections; M002

	; M002;
	; Save the previous es:bx (instance data ptr) into our instance table

	push	dx			; M002
	mov	dx,bx			; M002
					; point ES:BX to Win386_Info ; M002
	mov	bx,Win386_Info 
	mov	[bx+2],dx		; M002
	mov	[bx+4],es		; M002
	pop	dx			; M002
	push	ds			; M002
	pop	es			; M002
	;jmp	win_nexti2f		; M002
	; 15/12/2022
	jmp	short win_nexti2f

	; 15/12/2022
	; Code to return Win386 2.xx instance table
OldWin386Init:
	pop	ax			; discard ds pushed on stack
	mov	si,OldInstanceJunk 
					; ds:si = instance table
	mov	ax,5248h ; 'HR'		; indicate instance data present
	;jmp	next_i2f
	; 15/12/2022
	jmp	short next_i2f

Win386_Leaving:
	; 15/12/2022
	test 	dl,1
	;test	dx,1			; is this really win386?
	;jz	short Win386_Leaving_c
	;jmp	win_nexti2f		; NO! It's win 286 dos extender! M002
	; 15/12/2022
	jnz	short win_nexti2f	

Win386_Leaving_c:
					; M062 - Start
	cmp	byte [UmbSaveFlag],1	; Q: was umb_arena saved at win start
					;    up.
	jne	short noumb		; N: not saved 
	mov	byte [UmbSaveFlag],0	; Y: clear UmbSaveFlag and restore 
					;    previously saved umb_head
	; 05/01/2024
	;push	ax ; (not necessary)
	push	es
	push	cx
	push	si
	push	di

	;mov	ax,[UMB_HEAD]
	;mov	es,ax
	; 05/01/2024
	mov	es,[UMB_HEAD]
	xor	di,di			; es:di -> umb_head

	cld

	mov	si,UmbSave1
	mov	cx,11
	rep	movsb
	mov	si,UmbSave2
	;mov	cx,5
	; 18/12/2022
	mov	cl,5
	rep	movsb

	pop	di
	pop	si
	pop	cx
	pop	es
	; 05/01/2024
	;pop	ax
noumb:					; M062 - End
	and	byte [IsWin386],0	; Win386 is gone
	and	byte [redir_patch],0	; Disable critical sections ; M002
	jmp	short win_nexti2f

;	; 15/12/2022
;	; Code to return Win386 2.xx instance table
;OldWin386Init:
;	pop	ax			; discard ds pushed on stack
;	mov	si,OldInstanceJunk 
;					; ds:si = instance table
;	mov	ax,5248h ; 'RH'		; indicate instance data present
;	;jmp	next_i2f
;	; 15/12/2022
;	jmp	short _next_i2f

Win386_Query:
	cmp	bx,Win386_DOSMGR ; 15h	; is this from DOSMGR?
	jne	short win_nexti2f     	; no, ignore it & chain to next
	or	cx,cx			; is it an instance query?
	jne	short dosmgr_func	; no, some DOSMGR query
	inc	cx			; indicate that data is instanced
;
; M001; We were previously returning a null ptr in es:bx. This will not work.
; M001; WIN386 needs a ptr to a table in es:bx with the following offsets:
; M001;  
; M001; OFFSETS STRUC
; M001; 	Major_version	db	?
; M001; 	Minor_version	db	?
; M001; 	SaveDS		dw	?
; M001; 	SaveBX		dw	?
; M001; 	Indos		dw	?
; M001; 	User_id		dw	?
; M001; 	CritPatch	dw	?
; M001; OFFSETS	ENDS
; M001; 
; M001; User_Id is the only variable really important for proper functioning  
; M001; of Win386. The other variables are used at init time to patch stuff
; M001; out. In DOS 5.0, we do the patching ourselves. But we still need to 
; M001; pass this table because Win386 depends on this table to get the 
; M001; User_Id offset.
; M001; 
	mov	bx,Win386_DOSVars	; M001 
	push	ds			; M001
	pop	es			; es:bx points at offset table ; M001
	jmp	short PopIret		; M001

; 15/12/2022
;	; Code to return Win386 2.xx instance table
;OldWin386Init:
;	pop	ax			; discard ds pushed on stack
;	mov	si,OldInstanceJunk 
;					; ds:si = instance table
;	mov	ax,5248h ; 'RH'		; indicate instance data present
;	;jmp	next_i2f
;	; 15/12/2022
;	jmp	short _next_i2f

dosmgr_func:
	dec	cx
	jz	short win386_patch	; call to patch DOS
	dec	cx
	jz	short PopIret		; remove DOS patches, ignore
	dec	cx
	jz	short win386_size	; get size of DOS data structures
	dec	cx
	jz	short win386_inst	; instance more data
	;dec	cx
	;jnz	short PopIret		; no functions above this
	; 05/01/2024 (PCDOS 7.1 IBMDOS.COM DOSCODE:4771h)
	loop	PopIret

	; Get DOS device driver size -- es:di points at device driver header
	; In DOS 4.x, the para before the device header contains an arena 
	; header for the driver.

	mov	ax,es			; ax = device header segment

	; We check to see if we have a memory arena for this device driver. 
	; The way to do this would be to look at the previous para to see if
	; it has a 'D' marking it as an arena and also see if the owner-field 
	; in the arena is the same as the device header segment. These two 
	; checks together should take care of all cases

	dec	ax			; get arena header
	push	es
	mov	es,ax			; arena header for device driver

	cmp	byte [es:di],'D'	; is it a device arena?
	jnz	short cantsize		; no, cant size this driver
	inc	ax			; get back device header segment
	cmp	[es:di+1],ax		; owner field pointing at driver?
	jnz	short cantsize		; no, not a proper arena

	mov	ax,[es:di+3]		; get arena size in paras
	pop	es

	; We have to multiply by 16 to get the number of bytes in (bx:cx)
	; Speed is not critical and so we choose the shortest method 
	; -- use "mul"

	mov	bx,16
	mul	bx
	mov	cx,ax
	mov	bx,dx
	jmp	short win386_done	; return with device driver size
cantsize:
	pop	es
	xor	ax,ax
win386_inst:	; 05/01/2024
	xor	dx,dx			; ask DOSMGR to use its methods
	jmp	short PopIret		; return

win386_patch:
	; dx contains bits marking the patches to be applied. We return 
	; the field with all bits set to indicate that all patches have been
	; done

	mov	bx,dx			; move patch bitfield to bx
 	;jmp	short win386_done	; done, return
	; 15/12/2022
	; 15/12/2022
win386_done:
	mov	ax,WIN_OP_DONE		; 0B97Ch
	mov	dx,DOSMGR_OP_DONE	; 0A2ABh
PopIret:
	pop	ds
	iret	

win386_size:
	; Return the size of DOS data structures -- currently only CDS size

	; 17/12/2022
	test	dl,1
	;test	dx,1			; check for CDS size bit
	jz	short PopIret		; no, unknown structure -- return

	mov	cx,curdirLen	; 88 	; cx = CDS size
	jmp	short win386_done	; return with the size

; 05/01/2024
%if 0
win386_inst:
	; WIN386 check to see if DOS has identified the CDS,SFT and device
	; chain as instance data. Currently, we let the WIN386 DOSMGR handle
	; this by returning a status of not previously instanced. The basic
	; structure of these things have not changed and so the current
	; DOSMGR code should be able to work it out

	xor	dx,dx			; make sure dx has a not done value
	jmp	short PopIret		; skip done indication
%endif

	; 15/12/2022
;win386_done:
;	mov	ax,WIN_OP_DONE		; 0B97Ch
;	mov	dx,DOSMGR_OP_DONE	; 0A2ABh
;PopIret:
;	pop	ds
;	iret				; return back up the chain

	; 15/12/2022
;win_nexti2f:
	;pop	ds
	;jmp	next_i2f		; go to BIOS i2f handler

;End WIN386 support

; 15/05/2019

;M044; Start of changes
; Winoldap has a bug in that its calculations for the Windows memory image
; to save is off by 1 para. This para can happen to be a Windows arena if the
; DOS top of memory happens to be at an odd boundary (as is the case when
; UMBs are present). This is because Windows builds its arenas only at even
; para boundaries. This arena now gets trashed when Windows is swapped back
; in leading to a crash. Winoldap issues callouts when it swaps Windows out
; and back in. We sit on these callouts. On the Windows swapout, we save the
; last para of the Windows memory block and then restore this para on the
; Windows swapin callout. 

getwinlast:
	; 07/12/2022
	mov	si,[CurrentPDB]
	dec	si
	mov	es,si
	add	si,[es:3]
	retn

; 15/12/2022
%if 0
winold_swap:
	push	ds
	push	es
	push	si
	push	di
	push	cx

	;getdseg <ds>			;ds = DOSDATA
	mov	ds,[cs:DosDSeg]

	cmp	al,1			;swap Windows out call
	jne	short swapin		;no, check if Swap in call
	call	getwinlast
	push	ds
	pop	es
	mov	ds,si			;ds = memory arena of Windows
	xor	si,si
	mov	di,WinoldPatch1
	mov	cx,8
	cld
	push	cx
	rep	movsb			;save first 8 bytes
	pop	cx
	mov	di,WinoldPatch2
	rep	movsb			;save next 8 bytes
	jmp	short winold_done
swapin:
	cmp	al,2			;swap Windows in call?
	jne	short winold_done	;no, something else, pass it on
	call	getwinlast
	mov	es,si
	xor	di,di
	mov	si,WinoldPatch1
	mov	cx,8
	cld
	push	cx
	rep	movsb			;restore first 8 bytes
	pop	cx
	mov	si,WinoldPatch2
	rep	movsb			;restore next 8 bytes
winold_done:
	pop	cx
	pop	di
	pop	si
	pop	es
	pop	ds
	jmp	next_i2f		;chain on

%endif

;M044; End of changes

; 15/05/2019

DispatchDOS:
	PUSH	word [CS:FOO]		; push return address
	PUSH	word [CS:DTab]		; push table address
	PUSH	AX			; push index
	PUSH	BP
	MOV	BP,SP
		; stack looks like:
		;   0	BP
		;   2	DISPATCH
		;   4	TABLE
		;   6	RETURN
		;   8	LONG-RETURN
		;   C	FLAGS
		;   E	AX
	
	MOV	AX,[BP+0Eh]		; get AX value
	POP	BP
	call	TableDispatch
	JMP	BadFunc 		; return indicates invalid function

INT2F_etcetera:
	;entry	DosGetGroup
DosGetGroup:
	; MSDOS 3.3
	;push	cs
	;pop	ds
	;retn

	; MSDOS 6.0
;SR; Cannot use CS now
;
;	PUSH	CS
;	POP	DS

	; 04/11/2022
	; (MSDOS 5.0 MSDOS.SYS - DOSCODE:46FBh)

	;getdseg <ds>
	mov	ds,[cs:DosDSeg]
	retn

	;entry	DOSInstall
DOSInstall:
	MOV	AL,0FFh
	retn

;ENDIF ; (*)


; 15/05/2019 - Retro DOS v4.0

;------------------------------------------------------------------------
;
; Procedure Name : RW32_CONVERT
;
;Input: same as ABSDRD and ABSDWRT
;	 ES:BP -> DPB
;Functions: convert 32bit absolute RW input parms to 16bit input parms
;Output: carry set when CX=-1 and drive is less then 32mb
;	 carry clear, parms ok
;
;------------------------------------------------------------------------

	; 06/01/2024
RW32_CONVERT:
	;inc	cx ; *	; 01 -> 0
	CMP	CX,-1			   ;>32mb  new format ?	;AN000;
	JZ	short new32format	   ;>32mb  yes		;AN000;
	;dec	cx ; *
	PUSH	AX			   ;>32mb  save ax	;AN000;
	PUSH	DX			   ;>32mb  save dx	;AN000;
	;mov	ax,[es:bp+0Dh]
	MOV	AX,[ES:BP+DPB.MAX_CLUSTER] ;>32mb  get max cluster # ;AN000;
	;mov	dl,[es:bp+4]
	MOV	DL,[ES:BP+DPB.CLUSTER_MASK] ;>32mb		;AN000;
	CMP	DL,0FEh ; 254		;>32mb  removable ?	;AN000;
	JZ	short letold		;>32mb  yes		;AN000;
	;INC	DL			;>32mb			;AN000;
	; 17/12/2022
	inc	dx
	XOR	DH,DH			;>32mb  dx = sector/cluster ;AN000;
	MUL	DX			;>32mb  dx:ax= max sector # ;AN000;
	OR	DX,DX	; (clears CF)	;>32mb  > 32mb ?	;AN000;
letold:
	POP	DX			;>32mb  restore dx	;AN000;
	POP	AX			;>32mb  restore ax 	;AN000;
	JZ	short old_style	; cf=0	;>32mb  no 		;AN000;

	push	ds
	;getdseg <ds>
	mov	ds,[cs:DosDSeg]
	mov	word [AbsDskErr],207h	;>32mb  bad address mark
	pop	ds

	STC				;>32mb			;AN000;
	retn				;>32mb			;AN000;

new32format:
	;mov	dx,[bx+2]
	MOV	DX,[BX+ABS_32RW.SECTOR_RBA+2] ;>32mb		;AN000;

	push	ds			; set up ds to DOSDATA
	;getdseg <ds>
	mov	ds,[cs:DosDSeg]
	MOV	[HIGH_SECTOR],DX	;>32mb			;AN000;
	pop	ds

	mov	dx,[bx]
	;MOV	DX,[BX+ABS_32RW.SECTOR_RBA]  ;>32mb		;AN000;
	;mov	cx,[bx+4]
	MOV	CX,[BX+ABS_32RW.ABS_RW_COUNT] ;>32mb		;AN000;
	;lds	bx,[bx+6]
	LDS	BX,[BX+ABS_32RW.BUFFER_ADDR] ;>32mb		;AN000;
old_style:				;>32mb			;AN000;
	; 06/01/2024
	; cf=0
	;CLC				;>32mb			;AN000;
	retn				;>32mb			;AN000;

;------------------------------------------------------------------------
;
; Procedure Name : Fastxxx_Purge
;
; Input: None
; Functions: Purge Fastopen/ Cache Buffers
; Output: None
;
;------------------------------------------------------------------------

; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)

Fastxxx_Purge:
	PUSH	AX			; save regs.	;AN000;
	PUSH	SI						;AN000;
	PUSH	DX						;AN000;
topen:
	push	ds			; set up ds to DOSDATA
	;getdseg <ds>
	mov	ds,[cs:DosDSeg]

	TEST	byte [FastOpenFlg],Fast_yes ; 80h 
					; fastopen installed ?	;AN000;
	pop	ds
	JZ	short nofast		; no			;AN000;
	MOV	AH,FastOpen_ID	; 1				;AN000;
dofast:
	MOV	AL,FONC_purge  ;5	; purge			;AN000;
	;;mov	dl,[es:bp+0]
	; 05/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;MOV	DL,[ES:BP+DPB.DRIVE]	; set up drive number	;AN000;
	; 15/12/2022
	mov	dl,[es:bp]
	;invoke	Fast_Dispatch		; call fastopen/seek	;AN000;
	call	Fast_Dispatch
nofast:
	POP	DX						;AN000;
	POP	SI			; restore regs		;AN000;
	POP	AX			 			;AN000;
	retn				; exit

;============================================================================
; DOSMES.INC (MSDOS 6.0, 1991)
;============================================================================
; 29/04/2019 - Retro DOS v4.0

;include dossym.inc
;include dosmac.inc
;include doscntry.inc

; DOSCODE Segment

; 17/07/2018 - Retro DOS v3.0  [ DOSMES.INC (MSDOS 3.3, 1987) ]
; ---------------------------------------------------------------------------
;include divmes.inc

; DOSCODE:4778h (MSDOS 6.21, MSDOS.SYS)
; -------------------------------------
; DOSCODE:476Bh (MSDOS 5.0, MSDOS.SYS) - 05/11/2022 -

; THIS IS THE ONLY DOS "MESSAGE". IT DOES NOT NEED A TERMINATOR.
	;PUBLIC	DIVMES

DIVMES:	DB	13,10,"Divide overflow",13,10

	;PUBLIC	DivMesLen
DivMesLen:
	DW	$-DIVMES  ; 19	; Length of the above message in bytes

; DOSCODE:478Dh (MSDOS 6.21, MSDOS.SYS)
; -------------------------------------
; DOSCODE:4780h (MSDOS 5.0, MSDOS.SYS) - 05/11/2022 -

; (MSDOS 6.0)
; VxD not found error message

NoVxDErrMsg:
	db  'You must have the file WINA20.386 in the root of your boot drive'
	db  0Dh,0Ah,'to run Windows in Enhanced Mode',0Dh,0Ah

VxDMesLen equ $ - NoVxDErrMsg  ; 99

; 13/05/2019 - Retro DOS v4.0
; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)

;include yesno.asm  (MNSDOS 6.0)
; -------------------------------------
; DOSCODE:47F0h (MSDOS 6.21, MSDOS.SYS)
; DOSCODE:47E3h (MSDOS 5.0, MSDOS.SYS) - 05/11/2022 -

; This is for country Yes and No

NLS_YES:	db 'Y'
NLS_NO:		db 'N'
NLS_yes2:	db 'y'
NLS_no2:	db 'n'

; ---------------------------------------------------------------------------

; DOSCODE:47F4h (MSDOS 6.21, MSDOS.SYS)
; DOSCODE:47E7h (MSDOS 5.0, MSDOS.SYS) - 05/11/2022 -

;SUBTTL EDIT FUNCTION ASSIGNMENTS AND HEADERS

; The following two tables implement the current buffered input editing
; routines. The tables are pairwise associated in reverse order for ease
; in indexing. That is; The first entry in ESCTAB corresponds to the last
; entry in ESCFUNC, and the last entry in ESCTAB to the first entry in ESCFUNC.

	;PUBLIC	CANCHAR
CANCHAR:
	DB	CANCEL	; 1Bh	;Cancel line character
	
	;PUBLIC	ESCCHAR
ESCCHAR:
	DB	ESCCH	; 0	;Lead-in character for escape sequences
	
	;IF	NOT Rainbow

ESCTAB:	; LABEL BYTE

	;IF	IBM
	DB	64		; Ctrl-Z - F6
	DB	77		; Copy one char - -->
	DB	59		; Copy one char - F1
	DB	83		; Skip one char - DEL
	DB	60		; Copy to char - F2
	DB	62		; Skip to char - F4
	DB	61		; Copy line - F3
	DB	61		; Kill line (no change to template ) - Not used
	DB	63		; Reedit line (new template) - F5
	DB	75		; Backspace - <--
	DB	82		; Enter insert mode - INS (toggle)
	DB	82		; Exit insert mode - INS (toggle)
	DB	65		; Escape character - F7
	DB	65		; End of table
	;ENDIF

ESCEND: ; LABEL BYTE

ESCTABLEN EQU ESCEND-ESCTAB

ESCFUNC: ; LABEL WORD
	
	short_addr  GETCH	; Ignore the escape sequence
	short_addr  TWOESC
	short_addr  EXITINS
	short_addr  ENTERINS
	short_addr  BACKSP
	short_addr  REEDIT
	short_addr  KILNEW
	short_addr  COPYLIN
	short_addr  SKIPSTR
	short_addr  COPYSTR
	short_addr  SKIPONE
	short_addr  COPYONE
	short_addr  COPYONE
	short_addr  CTRLZ

	;ENDIF

; DOSMES.INC (MSDOS 6.0, 1991)
; ---------------------------------------------------------------------------
; DOSMES.ASM (MSDOS 2.11, 1983)

; OEMFunction key is expected to process a single function
;   key input from a device and dispatch to the proper
;   routines leaving all registers UNTOUCHED.
;
; Inputs:   CS, SS are DOSGROUP
; Outputs:  None. This function is expected to JMP to onw of
;           the following labels:
;
;           GetCh       - ignore the sequence
;           TwoEsc      - insert an ESCChar in the buffer
;           ExitIns     - toggle insert mode
;           EnterIns    - toggle insert mode
;           BackSp      - move backwards one space
;           ReEdit      - reedit the line with a new template
;           KilNew      - discard the current line and start from scratch
;           CopyLin     - copy the rest of the template into the line
;           SkipStr     - read the next character and skip to it in the template
;           CopyStr     - read next char and copy from template to line until char
;           SkipOne     - advance position in template one character
;           CopyOne     - copy next character in template into line
;           CtrlZ       - place a ^Z into the template
; Registers that are allowed to be modified by this function are:
;           AX, CX, BP

; 13/05/2019 - Retro DOS v4.0
; -------------------------------------
; DOSCODE:4820h (MSDOS 6.21, MSDOS.SYS)

; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; -------------------------------------
; DOSCODE:4813h (MSDOS 5.0, MSDOS.SYS)

OEMFunctionKey:
	CALL	_$STD_CON_INPUT_NO_ECHO	; Get the second byte of the sequence
	MOV     CL,ESCTABLEN ; 14	; length of table for scan
	PUSH    DI                      ; save DI (cannot change it!)
	MOV     DI,ESCTAB		; offset of second byte table
	push	es
	push	cs
	pop	es
	REPNE   SCASB                   ; Look it up in the table
	pop	es
	POP     DI                      ; restore DI
	SHL     CX,1                    ; convert byte offset to word
	MOV     BP,CX                   ; move to indexable register
	;JMP	word [BP+ESCFUNC]	; Go to the right routine
	JMP	word [CS:BP+ESCFUNC]

;DOSCODE ENDS
	
;============================================================================
; TIME.ASM (MSDOS 6.0, 1991)
;============================================================================
; Retro DOS v3.0 - 18/07/2018

; SYSCALL.ASM (MSDOS 2.11, 1983)
;----------------------------------------------------------------------------
; Retro DOS v2.0 - 13/03/2018

;**	TIME.ASM - System Calls and low level routines for DATE and TIME

	;BREAK <DATE AND TIME - SYSTEM CALLS 42,43,44,45>

;**	$GET_DATE - Get Current Date
;----------------------------------------
;	ENTRY	none
;	EXIT	(cx:dx) = current date
;	USES	all

; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)

_$GET_DATE:	;System call 42

	PUSH	SS
	POP	DS
	CALL	READTIME	;Check for rollover to next day
	MOV	AX,[YEAR]

;	WARNING!!!! DAY and MONTH must be adjacently allocated!

	MOV	BX,[DAY]	; fetch both day and month
	CALL	Get_User_Stack	;Get pointer to user registers
	;MOV	[SI+6],BX	;DH=month, DL=day
	MOV	[SI+user_env.user_DX],BX
	ADD	AX,1980		;Put bias back
	;MOV	[SI+4],AX	;CX=year
	MOV	[SI+user_env.user_CX],AX
	MOV	AL,[SS:WEEKDAY]	;hkn; SS override
RET20:	; 05/11/2022
RET24:	; 18/12/2022
	RETN

;**	$SET_DATE - Set Current Date
;----------------------------------------
;	ENTRY	(cx:dx) = current date
;	EXIT	(al) = -1 iff bad date
;		(al) = 0 if ok
;	USES	all

_$SET_DATE:	;System call 43

	MOV	AL,-1		;Be ready to flag error
	SUB	CX,1980		;Fix bias in year
	;JC	SHORT RET24	;Error if not big enough
	; 05/11/2022
	jc	short RET20
	CMP	CX,119		;Year must be less than 2100
	JA	SHORT RET24
	OR	DH,DH
	;JZ	SHORT RET24
 	; 05/11/2022
	jz	short RET20
	OR	DL,DL
	;JZ	SHORT RET24	;Error if either month or day is 0
	; 05/11/2022
	jz	short RET20
	CMP	DH,12		;Check against max. month
	JA	SHORT RET24
	PUSH	SS
	POP	DS
	;CALL	DODATE
	; 18/12/2022
	jmp	DODATE
;RET24:  
	;RETN

;**	$GET_TIME - Get Current Time
;----------------------------------------
;	ENTRY	none
;	EXIT	(cx:dx) = current time
;	USES	all

_$GET_TIME:			;System call 44

	PUSH	SS
	POP	DS
	CALL	READTIME
	CALL	Get_User_Stack	;Get pointer to user registers
	;MOV	[SI+6],DX
	MOV	[SI+user_env.user_DX],DX
	;MOV	[SI+4],CX
	MOV	[SI+user_env.user_CX],CX
set_time_ok:	; 06/01/2024
	XOR	AL,AL
RET26:  
	RETN

;**	$SET_TIME - Set Current Time
;----------------------------------------
;	ENTRY	(cx:dx) = time
;	EXIT	(al) = 0 if 0k
;		(al) = -1 if invalid
;	USES	ALL

_$SET_TIME:			;System call 45

	MOV	AL,-1		;Flag in case of error
	CMP	CH,24		;Check hours
	JAE	SHORT RET26
	CMP	CL,60		;Check minutes
	JAE	SHORT RET26
	CMP	DH,60		;Check seconds
	JAE	SHORT RET26
	CMP	DL,100		;Check 1/100's
	JAE	SHORT RET26
	PUSH	CX
	PUSH	DX
	PUSH	SS
	POP	DS

; 07/02/2024
%if 0
	MOV	BX,TIMEBUF
	MOV	CX,6
	; 06/02/2024 ; *
	;;XOR	DX,DX
	;;MOV	AX,DX
	;xor	ax,ax
	;cwd	; 06/01/2024
	PUSH	BX
	;CALL	SETREAD
	; 06/02/2024 ; *
	call	SETREAD_X
%else
	call	SETREAD_XT
%endif

	PUSH	DS
	LDS	SI,[BCLOCK]
	CALL	DEVIOCALL2	;Get correct day count
	POP	DS
	POP	BX
	CALL	SETWRITE
	POP	WORD [TIMEBUF+4]
	POP	WORD [TIMEBUF+2]
	LDS	SI,[BCLOCK]
	CALL	DEVIOCALL2	;Set the time
	; 06/01/2024
	;XOR	AL,AL
	;RETN
	jmp	short set_time_ok

; 11/07/2018 - Retro DOS v3.0
; Retro DOS v2.0 - 14/03/2018

FOURYEARS EQU 3*365 + 366  ; = 1461 

;SUBTTL DATE16, READTIME, DODATE -- GUTS OF TIME AND DATE
;----------------------------------------------------------
; Date16 returns the current date in AX, current time in DX
;   AX - YYYYYYYMMMMDDDDD  years months days
;   DX - HHHHHMMMMMMSSSSS  hours minutes seconds/2

DATE16:
	
;M048	Context DS
;
; Since this function can be called thru int 2f we shall not assume that SS
; is DOSDATA

	;push	ss
	;pop	ds

	;getdseg <ds>		; M048

	; 13/05/2019 - Retro DOS v4.0
	mov	ds, [cs:DosDSeg]	

	PUSH	CX
	PUSH	ES
	CALL	READTIME
	POP	ES
	SHL	CL,1		;Minutes to left part of byte
	SHL	CL,1
	SHL	CX,1		;Push hours and minutes to left end
	SHL	CX,1
	SHL	CX,1
	SHR	DH,1		;Count every two seconds
	OR	CL,DH		;Combine seconds with hours and minutes
	MOV	DX,CX

;	WARNING! MONTH and YEAR must be adjacently allocated

	MOV	AX,[MONTH]	;Fetch month and year
	MOV	CL,4
	SHL	AL,CL		;Push month to left to make room for day
	SHL	AX,1
	POP	CX
	OR	AL,[DAY]
RET21:
	RETN

;----------------------------------------------------------

READTIME:

;Gets time in CX:DX. Figures new date if it has changed.
;Uses AX, CX, DX.

	MOV	word [DATE_FLAG],0 ; reset date flag for CPMIO
	PUSH	SI
	PUSH	BX

	MOV	BX,TIMEBUF
; 07/02/2024
%if 0
	MOV	CX,6
	; 06/02/2024
	;;XOR	DX,DX
	;;MOV	AX,DX
	;; 06/01/2024
	;xor	ax,ax
	;cwd
	;CALL	SETREAD
	; 06/02/2024
	call	SETREAD_X
%else
	call	SETREAD_XTC
%endif
	PUSH	DS
	LDS	SI,[BCLOCK]
	CALL	DEVIOCALL2	;Get correct date and time
	POP	DS
	POP	BX
	POP	SI
	MOV	AX,[TIMEBUF]
	MOV	CX,[TIMEBUF+2]
	MOV	DX,[TIMEBUF+4]
	CMP	AX,[DAYCNT]	;See if day count is the same
	;JZ	SHORT RET22
	JZ	SHORT RET21 ; 18/07/2018
	;cmp	ax,43830
	CMP	AX,FOURYEARS*30 ;Number of days in 120 years
	JAE	SHORT RET22	;Ignore if too large
	MOV	[DAYCNT],AX
	PUSH	SI
	PUSH	CX
	PUSH	DX		;Save time
	XOR	DX,DX
	;mov	cx,1461
	MOV	CX,FOURYEARS	;Number of days in 4 years
	DIV	CX		;Compute number of 4-year units
	SHL	AX,1
	SHL	AX,1
	SHL	AX,1		;Multiply by 8 (no. of half-years)
	MOV	CX,AX		;<240 implies AH=0

	MOV	SI,YRTAB	;Table of days in each year

	CALL	DSLIDE		;Find out which of four years we're in
	SHR	CX,1		;Convert half-years to whole years
	JNC	SHORT SK	;Extra half-year?
	ADD	DX,200
SK:
	CALL	SETYEAR
	MOV	CL,1		;At least at first month in year

	MOV	SI,MONTAB	;Table of days in each month
	
	CALL	DSLIDE		;Find out which month we're in
	MOV	[MONTH],CL
	INC	DX		;Remainder is day of month (start with one)
	MOV	[DAY],DL
	CALL	WKDAY		;Set day of week
	POP	DX
	POP	CX
	POP	SI
RET22:  
	RETN

;----------------------------------------------------------

DSLIDE:
	;MOV	AH,0
	; 06/01/2024
	; (AH=0)
DSLIDE1:
	LODSB			;Get count of days
	CMP	DX,AX		;See if it will fit
	;JB	SHORT RET23	;If not, done
	jb	short RET22 ; 13/05/2019 - Retro DOS v4.0
	SUB	DX,AX
	INC	CX		;Count one more month/year
	JMP	SHORT DSLIDE1

;----------------------------------------------------------

SETYEAR:

;Set year with value in CX. Adjust length of February for this year.

; NOTE: This can also be called thru int 2f. If this is called then it will
;	  set DS to DOSDATA. Since the only guy calling this should be the DOS
;	redir, DS will be DOSDATA anyway. It is going to be in-efficient to
;	preserve DS as CHKYR is also called as a routine.

	; MSDOS 6.0 (18/07/2018) ; *

	;GETDSEG DS

	;PUSH	CS  ; *
	;POP	DS  ; *

	; 13/05/2019 - Retro DOS v4.0
	mov	ds,[cs:DosDSeg]

	; Offset 18CEh in IBMDOS.COM (MSDOS 3.3), 1987
	; 05/11/2022 
	; DOSCODE:4970h in MSDOS.SYS (MSDOS 5.0), 1991 

	MOV	[YEAR],CL
CHKYR:
	TEST	CL,3		;Check for leap year
	MOV	AL,28
	JNZ	SHORT SAVFEB	;28 days if no leap year
	INC	AL		;Add leap day
SAVFEB:
	mov	[february],al
	;MOV	[MONTAB+1],AL	;Store for February
RET23:  
	RETN

;----------------------------------------------------------

DODATE:
	CALL	CHKYR		;Set Feb. up for new year
	MOV	AL,DH

	MOV	BX,MONTAB-1	;DOSDATA:0D1Bh for MSDOS 6.21

	XLAT			;Look up days in month
	CMP	AL,DL
	MOV	AL,-1		;Restore error flag, just in case
	;JB	SHORT RET25	;Error if too many days
	jb	short RET23 ; 18/07/2018
	CALL	SETYEAR
;
; WARNING! DAY and MONTH must be adjacently allocated
;
	MOV	[DAY],DX	;Set both day and month
	SHR	CX,1
	SHR	CX,1
	;mov	ax,1461
	MOV	AX,FOURYEARS
	MOV	BX,DX
	MUL	CX
	MOV	CL,[YEAR]
	AND	CL,3

	MOV	SI,YRTAB

	MOV	DX,AX
	SHL	CX,1		;Two entries per year, so double count
	CALL	DSUM		;Add up the days in each year
	MOV	CL,BH		;Month of year

	MOV	SI,MONTAB

	DEC	CX		;Account for months starting with one
	CALL	DSUM		;Add up days in each month
	MOV	CL,BL		;Day of month
	DEC	CX		;Account for days starting with one
	ADD	DX,CX		;Add in to day total
	XCHG	AX,DX		;Get day count in AX
	MOV	[DAYCNT],AX
	PUSH	SI
	PUSH	BX
	PUSH	AX

; 07/02/2024
%if 0
	MOV	BX,TIMEBUF
	MOV	CX,6
	; 06/02/2024 ; *
	;;XOR	DX,DX
	;;MOV	AX,DX
	;; 06/01/2024
	;xor	ax,ax
	;cwd
	PUSH	BX
	;CALL	SETREAD
	; 06/02/2024 ; *
	call	SETREAD_X
%else
	call	SETREAD_XT
%endif

	PUSH	DS
	LDS	SI,[BCLOCK]
	CALL	DEVIOCALL2	;Get correct date and time
	POP	DS
	POP	BX
	CALL	SETWRITE
	POP	WORD [TIMEBUF]
	PUSH	DS
	LDS	SI,[BCLOCK]
	CALL	DEVIOCALL2	;Set the date
	POP	DS
	POP	BX
	POP	SI
WKDAY:
	MOV	AX,[DAYCNT]
	XOR	DX,DX
	MOV	CX,7
	INC	AX
	INC	AX		;First day was Tuesday
	DIV	CX		;Compute day of week
	MOV	[WEEKDAY],DL
	XOR	AL,AL		;Flag OK
RET25:
	RETN

;----------------------------------------------------------

;**	DSUM - Compute the sum of a string of bytes
;
;	ENTRY	(cx) = byte count
;		(ds:si) = byte address
;		(dx) = sum register, initialized by caller
;	EXIT	(dx) updated
;	USES	ax, cx, dx, si, flags

DSUM:
	MOV	AH,0
	JCXZ	DSUM9 ; 13/05/2019 - Retro DOS v4.0
	;JCXZ	RET25 ; 18/07/2018
DSUM1:
	LODSB
	ADD	DX,AX
	LOOP	DSUM1
DSUM9:
	RETN

;============================================================================
; GETSET.ASM (MSDOS 6.0, 1991)
;============================================================================
; 29/04/2019 - Retro DOS v4.0
; 18/07/2018 - Retro DOS v3.0 (GETSET.ASM, MSDOS 6.0, 1991)

; 12/03/2018 - Retro DOS v2.0 

;TITLE	GETSET - GETting and SETting MS-DOS system calls
;NAME	GETSET

;CODE	SEGMENT BYTE PUBLIC  'CODE'
;       ASSUME  SS:DOSGROUP,CS:DOSGROUP

;USERNUM:
;	DW	0			; 24 bit user number
;       DB      0
;;	IF      IBM
;;OEMNUM: DB    0			; 8 bit OEM number
;;	ELSE
;OEMNUM: DB     0FFH			; 8 bit OEM number
;;	ENDIF

;MSVERS:		; MS-DOS version in hex for $GET_VERSION
;; 08/07/2018 - Retro DOS v3.0
;MSMAJOR: DB	MAJOR_VERSION	; DOS_MAJOR_VERSION
;MSMINOR: DB	MINOR_VERSION	; DOS_MINOR_VERSION  

;BREAK <$Get_Version -- Return MSDOS version number>
;----------------------------------------------------------------------------

; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:4A0Fh (MSDOS 5.0 MSDOS.SYS)

_$GET_VERSION:

; Inputs:
;       None
; Function:
;       Return MS-DOS version number
; Outputs:
;       OEM number in BH
;       User number in BL:CX (24 bits)
;       Version number as AL.AH in binary
;       NOTE: On pre 1.28 DOSs AL will be zero

; MSDOS 6.0
;
;	Fake_Count is used to lie about the version numbers to support
;	old binarys. See ms_table.asm for more info.
;
;		if input al = 00
;		  (bh) = OEM number			
;		else if input al = 01
;		  (bh) = version flags
;		 
;		       	 bits 0-2 = DOS internal revision
;		       	 bits 3-7 = DOS type flags
;		              bit 3    = DOS is in ROM
;		              bit 4    = DOS in in HMA
;		              bits 5-7 = reserved
;               M007 change - only bit 3 is now valid. Other bits
;               are 0 when AL = 1

	; 06/01/2024 (PCDOS 7.1 IBMDOS.COM)
	lds	cx, [ss:USERNUM]
	mov	bx, ds

	; MSDOS 3.3 (IBMDOS.COM, offset 196Dh)
	;--------------------------------------
	; MSDOS 6.21 (MSDOS.SYS, DOSCODE:4A1Ch)

        PUSH    SS
        POP     DS
        
	; 06/01/2024
	;MOV	BX,[USERNUM+2]
        ;MOV	CX,[USERNUM]

	; 13/05/2019 - Retro DOS v4.0

	;If AL == 1, ROMDOS will return BH = dos internal version # &
	;DOS flags

	cmp	AL,1
	jne	short Norm_Vers

;ifdef ROMDOS
;	mov	BH,DOSINROM 	; Just set the bit for ROM version
;				(DOSINROM = 8)
;else
        xor     bh,bh		; Otherwise return 0
;endif				;M007 end

Norm_Vers:
	;MOV	AX,[MSVERS]  ; MSDOS 3.3

        	; MSDOS 6.0	; MSVERS is a label in TABLE segment	
	; 13/05/2019 - Retro DOS v4.0
	push	ds		; Get the version number from the
	mov	ds,[CurrentPDB]	; current app's PSP segment
	;mov	ax,[40h]
	mov	ax,[PDB.Version] ; AX = DOS version number	
	; 07/12/2022
	pop	ds
	call	Get_User_Stack
				; Put values for return registers
				; in the proper place on the user's	 
				; stack addressed by DS:SI
	; 06/01/2024 (PCDOS 7.1 IBMDOS.COM)
gdrvfspc_ret:
        ;MOV	[SI+user_env.user_AX],AX
        MOV	[SI],AX
        ;MOV	[SI+4],CX
	mov	[SI+user_env.user_CX],CX
set_user_bx:
	;MOV	[SI+2],BX
	mov	[SI+user_env.user_BX],BX

	RETN

; 18/07/2018 - Retro DOS v3.0

;BREAK <$Get/Set_Verify_on_Write - return/set verify-after-write flag>
;----------------------------------------------------------------------------

;**	$Get_Verify_On_Write - Get Status of Verify on write flag
;
;	ENTRY	none
;	EXIT	(al) = value of VERIFY flag
;	USES	all


_$GET_VERIFY_ON_WRITE:

;hkn; SS override
	MOV	AL,[SS:VERFLG]	; Retro DOS v2.0 - 12/03/2018
	retn

;**	$Set_Verify_On_Write - Set Status of Verify on write flag
;
;	ENTRY	(al) = value of VERIFY flag
;	EXIT	none
;	USES	all

_$SET_VERIFY_ON_WRITE:

	AND	AL,1
;hkn; SS override
	MOV	[SS:VERFLG],AL	; Retro DOS v2.0 - 12/03/2018
RET27:	; 18/07/2018
	retn

; 19/07/2018 - Retro DOS v3.0

;BREAK <$International - return country-dependent information>
;----------------------------------------------------------------------------
;
; Procedure Name : $INTERNATIONAL
;
; Inputs:
;	MOV	AH,International
;	MOV	AL,country	(al = 0 => current country)
;      [MOV	BX,country]
;	LDS	DX,block
;	INT	21
; Function:
;	give users an idea of what country the application is running
; Outputs:
;	IF DX != -1 on input (get country)
;	  AL = 0 means return current country table.
;	  0<AL<0FFH means return country table for country AL
;	  AL = 0FF means return country table for country BX
;	  No Carry:
;	     Register BX will contain the 16-bit country code.
;	     Register AL will contain the low 8 bits of the country code.
;	     The block pointed to by DS:DX is filled in with the information
;	     for the particular country.
;		BYTE  Size of this table excluding this byte and the next
;		BYTE  Country code represented by this table
;			A sequence of n bytes, where n is the number specified
;			by the first byte above and is not > internat_block_max,
;			in the correct order for being returned by the
;			INTERNATIONAL call as follows:
;		WORD	Date format 0=mdy, 1=dmy, 2=ymd
;		5 BYTE	Currency symbol null terminated
;		2 BYTE	thousands separator null terminated
;		2 BYTE	Decimal point null terminated
;		2 BYTE	Date separator null terminated
;		2 BYTE	Time separator null terminated
;		1 BYTE	Bit field.  Currency format.
;			Bit 0.	=0 $ before #  =1 $ after #
;			Bit 1.	no. of spaces between # and $ (0 or 1)
;		1 BYTE	No. of significant decimal digits in currency
;		1 BYTE	Bit field.  Time format.
;			Bit 0.	=0 12 hour clock  =1 24 hour
;		DWORD	Call address of case conversion routine
;		2 BYTE	Data list separator null terminated.
;	  Carry:
;	     Register AX has the error code.
;	IF DX = -1 on input (set current country)
;	  AL = 0 is an error
;	  0<AL<0FFH means set current country to country AL
;	  AL = 0FF means set current country to country BX
;	  No Carry:
;	    Current country SET
;	    Register AL will contain the low 8 bits of the country code.
;	  Carry:
;	     Register AX has the error code.
;-----------------------------------------------------------------------------

;procedure   $INTERNATIONAL,NEAR   ; DOS 3.3

; 13/05/2019 - Retro DOS v4.0
; DOSCODE:4A4Dh (MSDOS 6.21, MSDOS.SYS)

; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:4A40h (MSDOS 5.0, MSDOS.SYS)

_$INTERNATIONAL:  ; IBMDOS.COM (MSDOS 3.3), offset 1992h
	 
	CMP	AL,0FFH
	JZ	short BX_HAS_CODE	; -1 means country code is in BX
	MOV	BL,AL			; Put AL country code in BX
	XOR	BH,BH
BX_HAS_CODE:
	PUSH	DS
	POP	ES
	PUSH	DX
	POP	DI			; User buffer to ES:DI

;hkn; SS is DOSDATA
;	context DS

	push	ss
	pop	ds

	CMP	DI,-1
	JZ	short international_set
	OR	BX,BX
	JNZ	short international_find

;hkn; country_cdpg is in DOSDATA segment.
	MOV	SI,COUNTRY_CDPG

	JMP	SHORT international_copy

international_find:
	;MOV	BP,0			 ; flag it for GetCntry only
	; 06/01/2024
	xor	bp,bp ; 0
	CALL	international_get
	JC	short errtn
	;CMP	BX,0			 ; nlsfunc finished it ?
	; 06/01/2024
	or	bx,bx
	JNZ	SHORT international_copy ; no, copy by myself
	MOV	BX,DX			 ; put country back
	JMP	SHORT international_ok3

international_get:
	MOV	SI,COUNTRY_CDPG

;hkn; country_cdpg is in DOSDATA segment.
;hkn; use ss override to access COUNTRY_CDPG fields

	; MSDOS 3.3
	;;cmp	bx,[SI+63h]
	;CMP	BX,[SI+DOS_CCDPG.ccDosCountry]
	;jz	short RET27

	; 13/05/2019 - Retro DOS v4.0

	; MSDOS 6.0
	;cmp	bx,[ss:si+68h]
	CMP	BX,[ss:SI+DOS_CCDPG.ccDosCountry] ; = current country id
	jz	short RET27			; return if equal

	MOV	DX,BX
	XOR	BX,BX			; bx = 0, default code page
	;CallInstall NLSInstall,NLSFUNC,0 ; check if NLSFUNC in memory
	mov	ax,1400h
	int     2Fh	; - Multiplex - NLSFUNC.COM - INSTALLATION CHECK
			; Return: AL = 00h not installed, OK to install
			; 01h not installed, not OK
			; FFh installed
	CMP	AL,0FFH
	JNZ	short interr		; not in memory
	
	; 06/01/2024
	mov	ax,1403h		; set country info

	;cmp	bp,0
	or	bp,bp			; GetCntry ?
	JNZ	short stcdpg
	
	;CallInstall GetCntry,NLSFUNC,4	; get country info
	;mov	ax,1404h
	inc	ax	; AX = 1404h ; get country info

	; 06/01/2024
	;int	2Fh	; - Multiplex - NLSFUNC.COM - GET COUNTRY INFO
	;		; BX = code page, DX = country code,
	;		; DS:SI -> internal code page structure
	;		; ES:DI -> user buffer
	;		; Return: AL = status
	;
	;JMP	short chkok
	
	;nop

stcdpg:
	;CallInstall SetCodePage,NLSFUNC,3  ; set country info
	; 06/01/2024
	;mov     ax,1403h
gscdpg:
	int     2Fh	; - Multiplex - NLSFUNC.COM - SET COUNTRY INFO
			; DS:SI -> internal code page structure
			; BX = code page, DX = country code
			; Return: AL = status
chkok:
	or	al,al			; success ?
	;retz				; yes
	jz	short RET27

setcarry:
	STC				; set carry
	retn
interr:
	MOV	AL,0FFH			; flag nlsfunc error
	JMP	short setcarry

international_copy:

;hkn; country_cdpg is in DOSDATA segment.
;hkn; use ss override to access COUNTRY_CDPG fields

	; MSDOS 3.3
	;;mov	bx,[SI+63h]
	;mov	BX,[SI+DOS_CCDPG.ccDosCountry]
	;mov	SI,COUNTRY_CDPG+DOS_CCDPG.ccDFormat ; 08/09/2018

	; 13/05/2019 - Retro DOS v4.0

	; MSDOS 6.0
	;mov	bx,[ss:si+68h]
	MOV	BX,[ss:SI+DOS_CCDPG.ccDosCountry] ; = current country id
	MOV	SI,COUNTRY_CDPG+DOS_CCDPG.ccDFormat ; COUNTRY_CDPG + 108

	;mov	cx,24
	MOV	CX,OLD_COUNTRY_SIZE

	; MSDOS 6.0

;hkn;	must set up DS to SS so that international info can be copied
	
	push	ds

	push	ss			; cs -> ss
	pop	ds

	REP	MOVSB			; copy country info

	; MSDOS 6.0

	pop	ds	;hkn;	restore ds

international_ok3:
	call	Get_User_Stack
;ASSUME	DS:NOTHING
	;MOV	[SI+2],BX
	MOV	[SI+user_env.user_BX],BX
international_ok:
	MOV	AX,BX			; Return country code in AX too.
;SYS_RET_OK_jmp:
	; 05/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
nono:	; 15/12/2022
SYS_RET_OK_jmp:
	jmp	SYS_RET_OK

international_set:

;hkn; ASSUME	DS:DOSGROUP
;ASSUME	DS:DOSDATA

	MOV	BP,1			; flag it for SetCodePage only
	CALL	international_get
	JNC	short international_ok
errtn:
	CMP	AL,0FFH
	JZ	short errtn2
errtn1:
	jmp	SYS_RET_ERR		; return what we got from NLSFUNC
errtn2:
	;error	error_invalid_function	; NLSFUNC not existent

	;mov	al,1
	mov	al,error_invalid_function 
	jmp	short errtn1 ; 13/05/2019 - Retro DOS v4.0
;errtn3:
;	jmp	SYS_RET_ERR

;EndProc $INTERNATIONAL

; 19/07/2018

;BREAK <$GetExtCntry - return extended country-dependent information>

;----------------------------------------------------------------------------
;
; Procedure Name : $GetExtCntry
;
; Inputs:
;	if AL >= 20H
;	  AL= 20H    capitalize single char, DL= char
;	      21H    capitalize string, CX= string length
;	      22H    capitalize ASCIIZ string
;	      23H    YES/NO check, DL=1st char DH= 2nd char (DBCS)
;	      80H bit 0 = use normal upper case table
;		      1 = use file upper case table
;	   DS:DX points to string
;
;	else
;
;	MOV	AH,GetExtCntry	 ; DOS 3.3
;	MOV	AL,INFO_ID	( info type,-1 selects all )
;	MOV	BX,CODE_PAGE	( -1 = active code page )
;	MOV	DX,COUNTRY_ID	( -1 = active country )
;	MOV	CX,SIZE 	( amount of data to return )
;	LES	DI,COUNTRY_INFO ( buffer for returned data )
;	INT	21
; Function:
;	give users extended country dependent information
;	or capitalize chars
; Outputs:
;	  No Carry:
;	     extended country info is succesfully returned
;	  Carry:
;	     Register AX has the error code.
;	     AX=0, NO	 for YES/NO CHECK
;		1, YES
;----------------------------------------------------------------------------

;procedure   $GetExtCntry,NEAR	; DOS 3.3

	; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)

	; MSDOS 6.0
_$GetExtCntry:
	CMP	AL,CAP_ONE_CHAR 	; < 20H ?
	JB	short notcap
capcap: 				;
	TEST	AL,UPPER_TABLE	; 80h	; which upper case table
	JNZ	short fileupper		; file upper case

;hkn; UCASE_TAB in DOSDATA
	MOV	BX,UCASE_TAB+2		; get normal upper case
	JMP	SHORT capit

fileupper:
	; 06/01/2024 (PCDOS 7.1 IBMDOS.COM - DOSCODE:4C57h)
	; ((Note: This must be a bugfix, because bit 7 of AX is 1 here!))
	; AL >= 80h
	and	al,7Fh 

;hkn; FILE_UCASE_TAB in DOSDATA
	MOV	BX,FILE_UCASE_TAB+2 ; get file upper case
capit:					;
	CMP	AL,CAP_ONE_CHAR 	; cap one char ?
	JNZ	short chkyes		; no
	MOV	AL,DL			; set up AL
	call	GETLET3 		; upper case it
	call	Get_User_Stack		; get user stack
	;mov	[si+6],al
	MOV	[SI+user_env.user_DX],AL ; user's DL=AL
	JMP	SHORT nono		; done
chkyes: 				;
	CMP	AL,CHECK_YES_NO	; 23h	; check YES or NO ?
	JNZ	short capstring		; no

	XOR	AX,AX			; presume NO
		      
;hkn; NLS_YES, NLS_NO, NLS_yes2, NLS_no2 is defined in msdos.cl3 which is
;hkn; included in yesno.asm in the DOSCODE segment.

	; 06/08/2018 - Retro DOS v3.0
	; 13/05/2019 - Retro DOS v4.0
	;cmp	dl,'Y'
	CMP	DL,[cs:NLS_YES]		; is 'Y' ?
	JZ	short yesyes		; yes
	;cmp	dl,'y'
	CMP	DL,[cs:NLS_yes2]	; is 'y' ?
	JZ	short yesyes		; yes
	;cmp	dl,'N'
	CMP	DL,[cs:NLS_NO]		; is  'N'?
	JZ	short nono		; no
	;cmp	dl,'n'
	CMP	DL,[cs:NLS_no2]		; is 'n' ?
	JZ	short nono		; no
;dbcs_char:				;
	INC	AX			; not YES or NO
yesyes: 				;
	INC	AX			; return 1
	; 15/12/2022
;nono:	
	jmp	short SYS_RET_OK_jmp	;
	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;jmp	SYS_RET_OK		; done

capstring:				;
	MOV	SI,DX			; si=dx
	CMP	AL,CAP_STRING	; 21h	; cap string ?
	JNZ	short capascii		; no
	;OR	CX,CX			; check count 0
	;JZ	short nono		; yes finished
	; 06/01/2024
	jcxz	nono
concap: 				;
	LODSB				; get char
	call	GETLET3 		; upper case it
	MOV	byte [SI-1],AL		; store back
;next99: 				;
	LOOP	concap			; continue
	JMP	short nono		; done
capascii:				;
	CMP	AL,CAP_ASCIIZ	; 22h	; cap ASCIIZ string ?
	JNZ	short capinval		; no
concap2:				;
	LODSB				; get char
	or	al,al			; end of string ?
	JZ	short nono		; yes
	call	GETLET3 		; upper case it
	MOV	[SI-1],AL		; store back
	JMP	short concap2 		; continue

	; MSDOS 3.3 (& MSDOS 6.0)

; Offset 1A19h in IBMDOS.COM (MSDOS 3.3), 1987 	
; _$GetExtCntry:

notcap:
	CMP	CX,5			; minimum size is 5
	jb	short sizeerror

GEC_CONT:
;hkn; SS is DOSDATA
	;context DS

	push	ss
	;pop	es  ; ! (Retro DOS v3.0 BUG) !
	pop	ds  ; 13/05/2019 - Retro DOS v4.0	
	
;hkn; COUNTRY_CDPG is in DOSDATA
	MOV	SI,COUNTRY_CDPG

	CMP	DX,-1			; active country ?
	JNZ	short GETCDPG 		; no

;hkn; use DS override to accesss country_cdpg fields
	;;mov	dx,[si+63h] ; MSDOS 3.3
	;mov	dx,[si+68h] ; MSDOS 6.0
	MOV	DX,[SI+DOS_CCDPG.ccDosCountry]
					; get active country id;smr;use DS
GETCDPG:
	CMP	BX,-1			; active code page?
	JNZ	short CHKAGAIN		; no, check again

;hkn; use DS override to accesss country_cdpg fields
	;;mov	bx,[si+65h] ; MSDOS 3.3	
	;mov	bx,[si+6Ah] ; MSDOS 6.0
	MOV	BX,[SI+DOS_CCDPG.ccDosCodePage]
					; get active code page id;smr;Use DS
CHKAGAIN:
	;cmp	dx,[si+68h] ; MSDOS 6.0
	CMP	DX,[SI+DOS_CCDPG.ccDosCountry]
					; same as active country id?;smr;use DS
	JNZ	short CHKNLS		; no
	;cmp	bx,[si+6Ah] ; MSDOS 6.0	
	CMP	BX,[SI+DOS_CCDPG.ccDosCodePage]	
					; same as active code pg id?;smr;use DS
	JNZ	short CHKNLS		; no
CHKTYPE:
	;mov	bx,[si+48h]
	MOV	BX,[SI+DOS_CCDPG.ccSysCodePage]	
					; bx = sys code page id;smr;use DS
	PUSH	CX			; save cx
	;mov	cx,[si+4Ah]
	MOV	CX,[SI+DOS_CCDPG.ccNumber_of_entries]  ;smr;use DS
	;mov	si,COUNTRY_CDPG+76
	MOV	SI,COUNTRY_CDPG+DOS_CCDPG.ccSetUcase   ;smr;CDPG in DOSDATA
NXTENTRY:
	CMP	AL,[SI] 		; compare info type;smr;use DS
	JZ	short FOUNDIT
	ADD	SI,5			; next entry
	LOOP	NXTENTRY
	POP	CX
capinval:
	;error	error_invalid_function	; info type not found
	;mov	al,1
	mov	al,error_invalid_function
;SYS_RET_ERR_jmp:
	;jmp	SYS_RET_ERR
	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
SYS_RET_ERR_jmp:
	jmp	SYS_RET_ERR	

FOUNDIT:
	MOVSB				; move info id byte
	POP	CX			; restore char count
	;cmp	al,1
	CMP	AL,SetCountryInfo	; select country info type ?
	JZ	short setsize
	MOV	CX,4			; 4 bytes will be moved
	MOV	AX,5			; 5 bytes will be returned in CX
OK_RETN:
	REP	MOVSB			; copy info
	MOV	CX,AX			; CX = actual length returned
	MOV	AX,BX			; return sys code page in ax
GETDONE:
	call	Get_User_Stack		; return actual length to user's CX
	;mov	[si+4],cx 
	MOV	[SI+user_env.user_CX],CX
	;jmp	SYS_RET_OK
	; 15/12/2022
	; 25/06/2019
	jmp	SYS_RET_OK_clc
	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	; 15/12/2022
;nono_jmp:
	;jmp	short nono
setsize:
	SUB	CX,3			; size after length field
	CMP	[SI],CX			; less than table size ;smr;use ds
	JAE	short setsize2		; no
	MOV	CX,[SI]			; truncate to table size ;smr;use ds
setsize2:
	MOV	[ES:DI],CX		; copy actual length to user's
	;ADD	DI,2			; update index
	;ADD	SI,2
	; 06/01/2024
	inc	di
	inc	di
	inc	si
	inc	si
	MOV	AX,CX
	ADD	AX,3			; AX has the actual length
	JMP	short OK_RETN 		; go move it
CHKNLS:
	XOR	AH,AH
	;PUSH	AX			; save info type
	;POP	BP			; bp = info type
	; 06/01/2024
	mov	bp,ax
	
	;CallInstall NLSInstall,NLSFUNC,0 ; check if NLSFUNC in memory
	mov     ax,1400h
	int     2Fh     ; - Multiplex - NLSFUNC.COM - INSTALLATION CHECK
			; Return: AL = 00h not installed, OK to install
			; 01h not installed, not OK
			; FFh installed
	CMP	AL,0FFH
	JZ	short NLSNXT		; in memory

sizeerror:
	;error	error_invalid_function
	;mov	al,1
	mov	al,error_invalid_function
	;jmp	SYS_RET_ERR
	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
sys_ret_err_jmp2:
	jmp	short SYS_RET_ERR_jmp

NLSNXT: 
	;CallInstall GetExtInfo,NLSFUNC,2 ;get extended info
	mov     ax,1402h
	int     2Fh	; - Multiplex - NLSFUNC.COM - GET COUNTRY INFO
			; BP = subfunction, BX = code page
			; DX = country code, DS:SI -> internal code page structure
			; ES:DI -> user buffer, CX = size of user buffer
			; Return: AL = status
			; 00h successful
			; else DOS error code

	CMP	AL,0			; success ?
	JNZ	short NLSERROR
	;mov	ax,[si+48h] ; 13/05/2019
	MOV	AX,[SI+DOS_CCDPG.ccSysCodePage]
			; ax = sys code page id;smr;use ds;
			;BUGBUG;check whether DS is OK after the above calls
	JMP	short GETDONE
seterr:
	; 15/12/2022
NLSERROR:
	;jmp	SYS_RET_ERR		; return what is got from NLSFUNC
	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;jmp	short sys_ret_err_jmp2
	; 15/12/2022
	jmp	short SYS_RET_ERR_jmp

;EndProc $GetExtCntry

; 13/05/2019 - Retro DOS v4.0
; DOSCODE:4BD6h (MSDOS 6.21, MSDOS.SYS)

;BREAK <$GetSetCdPg - get or set global code page>
;----------------------------------------------------------------------------
;**	$GetSetCdPg - Get or Set Global Code Page
;
;   System call format:
;
;	MOV	AH,GetSetCdPg	; DOS 3.3
;	MOV	AL,n		; n = 1 : get code page, n = 2 : set code page
;	MOV	BX,CODE_PAGE	(set code page only)
;	INT	21
;
;	ENTRY	(al) = n
;		(bx) = code page
;	EXIT	'C' clear
;		  global code page is set	(set global code page)
;		  (BX) = active code page id	(get global code page)
;		  (DX) = system code page id	(get global code page)
;		'C' set
;		  (AX) = error code

;procedure  $GetSetCdPg,NEAR   ; DOS 3.3

	; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; DOSCODE:4BC9h

_$GetSetCdPg:

;hkn; SS is DOSDATA
	;context DS

	push	ss
	pop	ds

;hkn; COUNTRY_CDPG is in DOSDATA
	MOV	SI,COUNTRY_CDPG	  ; (DOSDATA:122Ah for MSDOS 6.21)

	CMP	AL,1		       ; get global code page
	JNZ	short setglpg 	       ; set global code page
	
	;;mov	bx,[si+65h] ; MSDOS 3.3
	;mov	bx,[si+6Ah] ; MSDOS 6.0
	MOV	BX,[SI+DOS_CCDPG.ccDosCodePage]
					; get active code page id;smr;use ds
	;mov	dx,[si+48h]
	MOV	DX,[SI+DOS_CCDPG.ccSysCodePage]
				  	; get sys code page id;smr;use ds
	call	Get_User_Stack
;ASSUME DS:NOTHING
	;;mov	[si+2],bx
	;MOV	[SI+user_env.user_BX],BX ; update returned bx
	; 06/01/2024 (PCDOS 7.1 IBMDOS.COM)
	call    set_user_bx	; MOV [SI+user_env.user_BX],BX 
	;mov	[si+6],dx
	MOV	[SI+user_env.user_DX],DX ; update returned dx
OK_RETURN:
	; 15/12/2022
	;transfer SYS_RET_OK
	jmp	SYS_RET_OK
	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;jmp	short nono_jmp

;hkn; ASSUME DS:DOSGROUP
;ASSUME	DS:DOSDATA

setglpg:
	CMP	AL,2
	JNZ	short nomem
	
	;;mov	dx,[si+63h] ; MSDOS 3.3
	;mov	dx,[si+68h] ; MSDOS 6.0
	MOV	DX,[SI+DOS_CCDPG.ccDosCountry]	;smr;use ds
	
	;CallInstall NLSInstall,NLSFUNC,0 ; check if NLSFUNC in memory
	mov     ax,1400h
	int     2Fh	; - Multiplex - NLSFUNC.COM - INSTALLATION CHECK
			; Return: AL = 00h not installed, OK to install
			; 01h not installed, not OK
			; FFh installed
	CMP	AL,0FFH
	JNZ	short nomem		; not in memory

	;CallInstall SetCodePage,NLSFUNC,1 ;set the code page
	mov     ax,1401h
	int     2Fh	; - Multiplex - NLSFUNC.COM - CHANGE CODE PAGE
			; DS:SI -> internal code page structure
			; BX = new code page, DX = country code???
			; Return: AL = status
			; 00h successful
			; else DOS error code
	;cmp	al,0
	or	al,al			; success ?
	JZ	short OK_RETURN		; yes

	CMP	AL,65			; set device code page failed
	JNZ	short seterr
	;MOV	AX,65
	; 06/01/2024
	cbw
	MOV	[EXTERR],AX
	;mov	byte [EXTERR_ACTION],6
	;mov	byte [EXTERR_CLASS],5
	;mov	byte [EXTERR_LOCUS],4
	MOV	byte [EXTERR_ACTION],errACT_Ignore
	MOV	byte [EXTERR_CLASS],errCLASS_HrdFail
	MOV	byte [EXTERR_LOCUS],errLOC_SerDev
	;transfer From_GetSet
	jmp	From_GetSet

	; 15/12/2022
;seterr:
	;;;transfer SYS_RET_ERR
	;;jmp	SYS_RET_ERR
	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;jmp	short NLSERROR

nomem:
	;error	error_invalid_function	; function not defined
	;mov	al,1
	mov	al,error_invalid_function
	jmp	short seterr

;EndProc $GetSetCdPg

; 09/01/2024
; 13/05/2019 - Retro DOS v4.0
; DOSCODE:4C2Bh (MSDOS 6.21, MSDOS.SYS)

;BREAK <$Get_Drive_Freespace -- Return bytes of free disk space on a drive>
;----------------------------------------------------------------------------
;**	$Get_Drive_Freespace - Return amount of drive free space
;
;	$Get_Drive_Freespace returns the # of free allocation units on a
;		drive.
;
;	This call returns the same info in the same registers (except for the
;	FAT pointer) as the old FAT pointer calls
;
;	ENTRY	DL = Drive number
;	EXIT	AX = Sectors per allocation unit
;		   = -1 if bad drive specified
;		On User Stack
;		    BX = Number of free allocation units
;		    DX = Total Number of allocation units on disk
;		    CX = Sector size

;procedure   $GET_DRIVE_FREESPACE,NEAR

_$GET_DRIVE_FREESPACE:

;hkn; SS is DOSDATA
	;context DS
	push	ss
	pop	ds

	MOV	AL,DL
	;invoke	GetThisDrv		; Get drive
	call	GETTHISDRV
SET_AX_RET:
	JC	short BADFDRV
	;invoke	DISK_INFO
	call	DISK_INFO
	XCHG	DX,BX
	;JC	short SET_AX_RET	; User FAILed to I 24
	; 06/01/2024
	jc	short BADFDRV
	XOR	AH,AH			; Chuck Fat ID byte
DoSt:
	call	Get_User_Stack
;ASSUME	DS:NOTHING
	;mov	[si+6],dx
	;;mov	[si+4],cx
	;;mov	[si+2],bx
	; 09/01/2024 (PCDOS 7.1 IBMDOS.COM)
	MOV	[SI+user_env.user_DX],DX ; total clusters
	;MOV	[SI+user_env.user_CX],CX
	;MOV	[SI+user_env.user_BX],BX
	;;MOV	[SI+user_env.user_AX],AX
	;mov	[si],ax
	;;return
	;retn
	; 09/01/2024
	jmp     gdrvfspc_ret    ; ax = sectors per cluster (modified)

BADFDRV:
	; MSDOS 3.3
	;;mov	al,0Fh
	;mov	al,error_invalid_drive	; Assume error

	; 13/05/2019 - Retro DOS v4.0

	; MSDOS 6.0 & MSDOS 3.3
	;invoke	FCB_RET_ERR
	call	FCB_RET_ERR
	
	MOV	AX,-1
	JMP	short DoSt

;EndProc $GET_DRIVE_FREESPACE

;	BREAK <$Get_DMA, $Set_DMA -- Get/Set current DMA address>
;----------------------------------------------------------------------------
;**	$Get_DMA - Get Disk Transfer Address
;
;	ENTRY	none
;	EXIT	ES:BX is current transfer address
;	USES	all

	; 09/01/2024
_$GET_DMA:
	MOV	BX,[SS:DMAADD]
	MOV	CX,[SS:DMAADD+2]
	call	Get_User_Stack
	;mov	[si+2],bx
	;mov	[si+10h],cx
	; 09/01/2024
	;MOV	[SI+user_env.user_BX],BX
	MOV	[SI+user_env.user_ES],CX
	;retn
	; 09/01/2024
	jmp	set_user_bx ; (PCDOS 7.1 IBMDOS.COM)

;**	$Set_DMA - Set Disk Transfer Address
;----------------------------------------------------------------------------
;	ENTRY	DS:DX is current transfer address
;	EXIT	none
;	USES	all

_$SET_DMA:
	MOV	[SS:DMAADD],DX
	MOV	[SS:DMAADD+2],DS
	retn

;	BREAK <$Get_Default_Drive, $Set_Default_Drive -- Set/Get default drive>
;------------------------------------------------------------------------------

;**	$Get_Default_Drive - Get Current Default Drive
;-----------------------------------------------------
;	ENTRY	none
;	EXIT	(AL) = drive number
;	USES	all

_$GET_DEFAULT_DRIVE:
	MOV	AL,[SS:CURDRV]
	retn

;**	$Set_Default_Drive - Specify new Default Drive
;-----------------------------------------------------
;	ENTRY	(DL) = Drive number for new default drive
;	EXIT	(AL) = Number of drives, NO ERROR RETURN IF DRIVE NUMBER BAD

_$SET_DEFAULT_DRIVE:
	MOV	AL,DL
	INC	AL			; A=1, B=2...
	call	GetVisDrv		; see if visible drive
	JC	short SETRET		; errors do not set
	MOV	[SS:CURDRV],AL		; no, set

SETRET:
	MOV	AL,[SS:CDSCOUNT]	; let user see what the count really is
	retn

;BREAK <$Get/Set_Interrupt_Vector - Get/Set interrupt vectors>
;----------------------------------------------------------------------------

;**	$Get_Interrupt_Vector - Get Interrupt Vector
;---------------------------------------------------
;	$Get_Interrupt_Vector is the official way for user pgms to get the
;	contents of an interrupt vector.
;
;	ENTRY	(AL) = interrupt number
;	EXIT	(ES:BX) = current interrupt vector

_$GET_INTERRUPT_VECTOR:
	CALL	RECSET
	LES	BX,[ES:BX]
	call	Get_User_Stack
set_user_es_bx:
	; 09/01/2024 (PCDOS 7.1 IBMDOS.COM)
	;;mov	[si+2],bx
	;mov	[si+10h],es
	;MOV	[SI+user_env.user_BX],BX
	MOV	[SI+user_env.user_ES],ES
	;retn
	jmp	set_user_bx

;**	$Set_Interrupt_Vector - Set Interrupt Vector
;---------------------------------------------------
;	$Set_Interrupt_Vector is the official way for user pgms to set the
;	contents of an interrupt vector.
;
;	M004, M068: Also set A20OFF_COUNT to 1 if EXECA20OFF bit has been set 
;	and if A20OFF_COUNT is non-zero. See under tag M003 in inc\dossym.inc 
;	for explanation.
;
;	ENTRY	(AL) = interrupt number
;		(ds:dx) = desired new vector value
;	EXIT	none
;	USES	all

; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; 13/05/2019 - Retro DOS v4.0

_$SET_INTERRUPT_VECTOR:
	CALL	RECSET
	CLI				; Watch out!!!!! Folks sometimes use
	MOV	[ES:BX],DX		;   this for hardware ints (like timer).
	MOV	[ES:BX+2],DS
	STI
					; M004, M068 - Start
	; MSDOS 6.0
	test	byte [ss:DOS_FLAG],EXECA20OFF ; 4
					; Q: was the previous call an int 21h
					;    exec call
	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;jnz	short siv_1		; Y: go set count
	;retn				; N: return
	; 15/12/2022
	jz	short siv_2
siv_1:	
	cmp	byte [ss:A20OFF_COUNT],0 ; Q: is count 0
	jnz	short siv_2		 ; N: done
	; 20/09/2023
	inc	byte [ss:A20OFF_COUNT]
	;mov	byte [ss:A20OFF_COUNT],1 ; Y: set it to 1 to indicate to dos
					 ; dispatcher to turn A20 Off before
					 ; returning to user.
siv_2:
	; 07/12/2022
	retn				; M004, M068 - End
	
RECSET:
	XOR	BX,BX
	MOV	ES,BX
	MOV	BL,AL
	SHL	BX,1
	SHL	BX,1
	retn

;	BREAK <$Char_Oper - hack on paths, switches so that xenix can look like PCDOS>
;-------------------------------------------------------------------------------------

;**	$Char_Oper - Manipulate Switch Character
;
;	This function was put in to facilitate XENIX path/switch compatibility
;
;	ENTRY	AL = function:
;		    0 - read switch char
;		    1 - set switch char (char in DL)
;		    2 - read device availability
;			Always returns available
;		    3 - set device availability
;			No longer supported (NOP)
;	EXIT	(al) = 0xff iff error
;		(al) != 0xff if ok
;		  (dl) = character/flag, if "read switch char" subfunction
;	USES	AL, DL
;
;	NOTE	This already obsolete function has been deactivated in DOS 5.0
;		The character / is always returned for subfunction 0,
;		subfunction 2 always returns -1, all other subfunctions are ignored.

; 13/05/2019 - Retro DOS v4.0
; DOSCODE:4CC9h (MSDOS 6.21, MSDOS.SYS)

; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:4CBCh (MSDOS 5.0, MSDOS.SYS)

_$CHAR_OPER:
	; MSDOS 6.0
	or	al,al				; get switch?
	mov	dl,'/'				; assume yes
	jz	short chop_1			; jump if yes
	cmp	al,2				; check device availability?
	mov	dl,-1				; assume yes
	jz	short chop_1			; jump if yes
	retn					; otherwise just quit

; subfunctions requiring return of value to user come here. DL holds
; value to return

chop_1:
	call	Get_User_Stack
	mov	[SI+user_env.user_DX],dx	; store value for user
	retn

	; MSDOS 3.3
	; Offset 1B87h in IBMDOS.COM (MSDOS 3.3), 1987
	;push	ss
	;pop	ds
	;cmp	al,1
	;jb	short chop_1
	;jz	short chop_2
	;cmp	al,3
	;jb	short chop_3
	;jz	short chop_5
	;mov	al,0FFh
	;retn
;chop_1:
	;mov	dl,[chSwitch]
	;jmp	short chop_4
;chop_2:
	;mov	[chSwitch],dl
	;retn
;chop_3:
	;mov	dl, FFh
;chop_4:
	;call	Get_User_Stack
	;mov	[si+6],dx
;chop_5:
	;retn

;**	$GetExtendedError - Return Extended error code
;----------------------------------------------------------------------------
;	This function reads up the extended error info from the static
;	variables where it was stored.
;
;	ENTRY	none
;	EXIT	AX = Extended error code (0 means no extended error)
;		BL = recommended action
;		BH = class of error
;		CH = locus of error
;		ES:DI = may be pointer
;	USES	ALL

	; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)

_$GetExtendedError:
	push	ss
	pop	ds
	MOV	AX,[EXTERR]
	LES	DI,[EXTERRPT]
	MOV	BX,[EXTERR_ACTION]	; BL = Action, BH = Class
	MOV	CH,[EXTERR_LOCUS]
	call	Get_User_Stack
	;mov	[si+0Ah],di
	MOV	[SI+user_env.user_DI],DI

	; 09/01/2024 (PCDOS 7.1 IBMDOS.COM)
	;;mov	[si+10h],es
	;MOV	[SI+user_env.user_ES],ES
	;;mov	[si+2],bx
	;MOV	[SI+user_env.user_BX],BX
	call	set_user_es_bx

	;mov	[si+4],cx
	MOV	[SI+user_env.user_CX],CX
jmp_SYS_RET_OK:
	; 15/12/2022
	;jmp	SYS_RET_OK
	; 25/06/2019
	jmp	SYS_RET_OK_clc ; 15/12/2022
	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
;jmp_SYS_RET_OK:
	;jmp	SYS_RET_OK

; --------------------------------------------------------------------------
; 09/01/2024
%if 0
	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	; DOSCODE:4CF3h
;patch_or_unknown:
;get_code_page:
	push    si
	mov     si, COUNTRY_CDPG
	;mov	ax, [si+DOS_CCDPG.ccDosCodePage]
	mov     ax, [ss:si+6Ah]
	pop     si
	retn
%endif
; --------------------------------------------------------------------------

; 29/04/2019 - Retro DOS v4.0

;BREAK	<ECS_call - Extended Code System support function>
;---------------------------------------------------------------------------
; Inputs:
;	AL = 0	get lead byte table
;		on return DS:SI has the table location
;
;	AL = 1	set / reset interim console flag
;		DL = flag (00H or 01H)
;		no return
;
;	AL = 2	get interim console flag
;		on return DL = current flag value
;
;	AL = OTHER then error, and returns with:
;		AX = error_invalid_function
;
;  NOTE: THIS CALL DOES GUARANTEE THAT REGISTER OTHER THAN
;	 SS:SP WILL BE PRESERVED!
;---------------------------------------------------------------------------

_$ECS_Call:
	or	al,al			; AL = 0 (get table)?
	;jnz	short _okok
	; 15/12/2022
	jz	short get_lbt
;_okok:
	jmp	SYS_RET_OK
get_lbt:
	call	Get_User_Stack		; *

;hkn; dbcs_table moved low to dosdata
	;mov	word [si+8],DBCS_TAB+2
	mov	word [si+user_env.user_SI],DBCS_TAB+2

	push	es
	;getdseg <es>			; es = DOSDATA
	mov	es,[cs:DosDSeg]
	;mov	[si+14],es
	mov	[SI+user_env.user_DS],es
	pop	es

	; 15/12/2022
	jmp	short jmp_SYS_RET_OK ; jmp SYS_RET_OK_clc ; *
;_okok:
	; 15/12/2022	
	;;transfer SYS_RET_OK
	;jmp	short jmp_SYS_RET_OK
	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;;jmp	SYS_RET_OK
	;jmp	short jmp_SYS_RET_OK

;============================================================================
; PARSE.ASM, MSDOS 6.0, 1991
;============================================================================
; 19/07/2018 - Retro DOS v3.0
; 15/05/2019 - Retro DOS v4.0

; System calls for parsing command lines
;
;   $PARSE_FILE_DESCRIPTOR
;
;   Modification history:
;
;       Created: ARR 30 March 1983
;               EE PathParse 10 Sept 1983
;

;BREAK <$Parse_File_Descriptor -- Parse an arbitrary string into an FCB>
;---------------------------------------------------------------------------
; Inputs:
;       DS:SI Points to a command line
;       ES:DI Points to an empty FCB
;       Bit 0 of AL = 1 At most one leading separator scanned off
;                   = 0 Parse stops if separator encountered
;       Bit 1 of AL = 1 If drive field blank in command line - leave FCB
;                   = 0  "    "    "     "         "      "  - put 0 in FCB
;       Bit 2 of AL = 1 If filename field blank - leave FCB
;                   = 0  "       "      "       - put blanks in FCB
;       Bit 3 of AL = 1 If extension field blank - leave FCB
;                   = 0  "       "      "        - put blanks in FCB
; Function:
;       Parse command line into FCB
; Returns:
;       AL = 1 if '*' or '?' in filename or extension, 0 otherwise
;       DS:SI points to first character after filename
;---------------------------------------------------------------------------

_$PARSE_FILE_DESCRIPTOR:
	call	MAKEFCB
	PUSH    SI
	call	Get_User_Stack
	;pop	word [si+8]
	POP     word [SI+user_env.user_SI]
	retn

;============================================================================
; MISC.ASM, MSDOS 6.0, 1991
;============================================================================
; 19/07/2018 - Retro DOS v3.0

; 29/04/2019 - Retro DOS v4.0

;ENTRYPOINTSEG	EQU	0CH
;MAXDIF		EQU	0FFFH
;SAVEXIT 	EQU	10
;WRAPOFFSET	EQU	0FEF0h

;
;----------------------------------------------------------------------------
;
;**	$SLEAZEFUNC - Get a Pointer to the Media Byte
;
;	Return Stuff sort of like old get fat call
;
;	ENTRY	none
;	EXIT	DS:BX = Points to FAT ID byte (IBM only)
;			GOD help anyone who tries to do ANYTHING except
;			READ this ONE byte.
;		DX = Total Number of allocation units on disk
;		CX = Sector size
;		AL = Sectors per allocation unit
;		   = -1 if bad drive specified
;	USES	all
;
;**	$SLEAZEFUNCDL - Get a Pointer to the Media Byte
;
;	Identical to $SLEAZEFUNC except (dl) = drive
;
;	ENTRY	(dl) = drive (0=default, 1=A, 2=B, etc.)
;	EXIT	DS:BX = Points to FAT ID byte (IBM only)
;			GOD help anyone who tries to do ANYTHING except
;			READ this ONE byte.
;		DX = Total Number of allocation units on disk
;		CX = Sector size
;		AL = Sectors per allocation unit
;		   = -1 if bad drive specified
;	USES	all
;
;----------------------------------------------------------------------------
;

_$SLEAZEFUNC:
	; 10/01/2024
	; 15/05/2019 - Retro DOS v4.0
	MOV	DL,0
_$SLEAZEFUNCDL:
	push	ss
	pop	ds
	
	MOV	AL,DL
	call	GETTHISDRV		; Get CDS structure
SET_AL_RET:
	; MSDOS 3.3
	;;mov	al, 0Fh
	;MOV	AL,error_invalid_drive	; Assume error	;AC000;
	
	; MSDOS 6.0 & MSDOS 3.3
	JC	short BADSLDRIVE

	call	DISK_INFO
	;JC	short SET_AL_RET	; User FAILed to I 24
	jc	short BADSLDRIVE
	MOV	[FATBYTE],AH

; NOTE THAT A FIXED MEMORY CELL IS USED --> THIS CALL IS NOT
; RE-ENTRANT. USERS BETTER GET THE ID BYTE BEFORE THEY MAKE THE
; CALL AGAIN

	; 10/01/2024
	;MOV	DI,FATBYTE
	XOR	AH,AH			; AL has sectors/cluster
	call	Get_User_Stack
	;mov	[si+4],cx
	;mov	[si+6],bx
	;mov	[si+2],di
	MOV	[SI+user_env.user_CX],CX
	MOV	[SI+user_env.user_DX],BX
	;MOV	[SI+user_env.user_BX],DI
	; 10/01/2024
	MOV	word [SI+user_env.user_BX],FATBYTE
	
	;mov	[si+0Eh],ss
	MOV     [SI+user_env.user_DS],SS ; stash correct pointer

	retn

BADSLDRIVE:
	jmp	FCB_RET_ERR

;
;----------------------------------------------------------------------------
;
;**	$Get_INDOS_Flag - Return location of DOS Critical Section Flag
;
;	Returns location of DOS status for interrupt routines
;
;	ENTRY	none
;	EXIT	(es:bx) = flag location
;	USES	all
;
;----------------------------------------------------------------------------
;

_$GET_INDOS_FLAG:
        CALL	Get_User_Stack
        ;MOV	WORD [SI+2],INDOS
	MOV     word [SI+user_env.user_BX],INDOS
getin_segm:	; 13/01/2024
	;MOV	[SI+10H],SS
	MOV	[SI+user_env.user_ES],SS
	RETN 
;
;----------------------------------------------------------------------------
;
;**	$Get_IN_Vars - Return Pointer to DOS Variables
;
;	Return a pointer to interesting DOS variables This call is version
;	dependent and is subject to change without notice in future versions.
;	Use at risk.
;
;	ENTRY	none
;	EXIT	(es:bx) = address of SYSINITVAR
;	uses	ALL
;
;----------------------------------------------------------------------------
;

	; 13/01/2024
	; PCDOS 7.1 IBMDOS.COM - DOSCODE:5226h
	; MSDOS 6.22 MSDOS.SYS - DOSCODE:4D65h
	; MSDOS 5.0 MSDOS.SYS - DOSCODE:4D58h	

_$GET_IN_VARS:
	CALL	Get_User_Stack
	;MOV	WORD [SI+2],SYSINITVAR
	;MOV	word [SI+user_env.user_BX],SYSINITVAR
	MOV	word [SI+user_env.user_BX],SYSINITVARS
	; 13/01/2024
	;;MOV	[SI+10H],SS
	;MOV	[SI+user_env.user_ES],SS
	;RETN
	jmp	short getin_segm

;
;----------------------------------------------------------------------------
;
;**	$Get_Default_DPB - Return a pointer to the Default DPB
;
;	Return pointer to drive parameter table for default drive
;
;	ENTRY	none
;	EXIT	(ds:bx) = DPB address
;	USES	all
;
;**	$Get_DPB - Return a pointer to a specified DPB
;
;	Return pointer to a specified drive parameter table
;
;	ENTRY	(dl) = drive # (0 = default, 1=A, 2=B, etc.)
;	EXIT	(al) = 0 iff ok
;		  (ds:bx) = DPB address
;		(al) = -1 if bad drive
;	USES	all
;
;----------------------------------------------------------------------------
;

; 15/05/2019 - Retro DOS v4.0

_$GET_DEFAULT_DPB:
	MOV	DL,0
_$GET_DPB:
	push	ss
	pop	ds

	MOV	AL,DL
	call	GETTHISDRV		; Get CDS structure
	JC	short ISNODRV 		; no valid drive
	LES	DI,[THISCDS]		; check for net CDS
	;;test	word [es:di+43h],8000h
	;TEST	word [ES:DI+curdir.flags],curdir_isnet
	;test	byte [es:di+44h],80h
	test	byte [ES:DI+curdir.flags+1],(curdir_isnet>>8)
	JNZ	short ISNODRV 		; No DPB to point at on NET stuff
	call	ECritDisk
	call	FATREAD_CDS		; Force Media Check and return DPB
	call	LCritDisk
	JC	short ISNODRV 		; User FAILed to I 24, only error we
					;   have.
	call	Get_User_Stack
	;mov	[si+2],bp
	MOV	[SI+user_env.user_BX],BP
	;mov	[si+0Eh],es
	MOV	[SI+user_env.user_DS],ES
	XOR	AL,AL
	retn
ISNODRV:
	MOV	AL,-1
	retn

;
;----------------------------------------------------------------------------
;
;**	$Disk_Reset - Flush out Dirty Buffers
;
;	$DiskReset flushes and invalidates all buffers.  BUGBUG - do
;		we really invalidate?  SHould we?  THis screws non-removable
;		caching.  Maybe CHKDSK relies upon it, though....
;
;	ENTRY	none
;	EXIT	none
;	USES	all
;
;----------------------------------------------------------------------------
;

	; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; DOSCODE:4D94h
_$DISK_RESET:
	; 15/05/2019 - Retro DOS v4.0
	mov	al,0FFh	; -1
	push	ss
	pop	ds
	; 06/11/2022
	;MOV	AL,-1
	call	ECritDisk
	; MSDOS 6.0
	;;or	word [DOS34_FLAG],4
	;or	word [DOS34_FLAG],FROM_DISK_RESET    ;AN000;
	or	byte [DOS34_FLAG],FROM_DISK_RESET ; 4 ; 15/05/2019
	call	FLUSHBUF
	; MSDOS 6.0
	;and	word [DOS34_FLAG],0FFFBh
	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;and	word [DOS34_FLAG],NO_FROM_DISK_RESET ;AN000;
	; 15/12/2022
	and	byte [DOS34_FLAG],NO_FROM_DISK_RESET ; 0FBh ; 15/05/2019
	mov	word [SC_STATUS],0	; Throw out secondary cache M041
;
; We will "ignore" any errors on the flush, and go ahead and invalidate. This
; call doesn't return any errors and it is supposed to FORCE a known state, so
; let's do it.
;
; Invalidate 'last-buffer' used
;
	MOV	BX,-1 ; 0FFFFh	
	MOV	[LastBuffer+2],BX
	MOV	[LastBuffer],BX

	; MSDOS 3.3 
	; IBMDOS.COM, Offset 1C66h
	;;;;
	;lds	si,[BUFFHEAD]
	;mov	ax,20FFh	; .buf_ID,    AL = FFh (Free buffer)
				; .buf_flags, AH = 0, reset/clear
;DRST_1:
	;;mov	[si+4],ax
	;mov	[si+BUFFINFO.buf_ID],ax
	;lds	si,[SI]
	;cmp	si,bx ; -1
	;je	short DRST_2
	;;mov	[si+4],ax
	;mov	[si+BUFFINFO.buf_ID],ax
	;lds	si,[SI]
	;cmp	si,bx
	;jne	short DRST_1
	;;;;
;DRST_2:
	call	LCritDisk
	MOV	AX,-1
	; 07/12/2022
	;mov	ax,0FFFFh
	;CallInstall NetFlushBuf,MultNET,32,AX,AX
	push	ax ; * MSDOS 6.0 ; 15/05/2019
	mov     ax,1120h
	int     2Fh	; Multiplex - NETWORK REDIRECTOR - FLUSH ALL DISK BUFFERS
			; DS = DOS CS
			; Return: CF clear (successful)
	pop	ax ; * MSDOS 6.0 ; 15/05/2019
	
	retn

	; 19/07/2018 - Retro DOS v3.0

;
;	BREAK <$SetDPB - Create a valid DPB from a user-specified BPB>
;
;----------------------------------------------------------------------------
;
;**	$SetDPB - Create a DPB
;
;	SetDPB Creates a valid DPB from a user-specified BPB
;
;	ENTRY	ES:BP Points to DPB
;		DS:SI Points to BPB
;	EXIT	DPB setup
;	USES	ALL but BP, DS, ES
;
;----------------------------------------------------------------------------
;

; 10/05/2019 - Retro DOS v4.0

; DOSCODE:4DD6h (MSDOS 6.21, MSDOS.SYS)

; MSDOS 6.0
word3:	dw	3			; M008 -- word value for divides

; 13/01/2024
; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:4DC9h (MSDOS 5.0, MSDOS.SYS)

;procedure   $SETDPB,NEAR

_$SETDPB:
	MOV	DI,BP
	;ADD	DI,2			; Skip over dpb_drive and dpb_UNIT
	; 13/01/2024
	inc	di
	inc	di
	LODSW
	STOSW				; dpb_sector_size
	; MSDOS 6.0
	;cmp	byte [si+3],0
	CMP	BYTE [SI+A_BPB.BPB_NUMBEROFFATS-2],0 ; FAT file system drive ;AN000;
	JNZ	short yesfat			     ; yes		;AN000;
	;mov	byte [es:di+4],0
	MOV	BYTE [ES:DI+DPB.FAT_COUNT-4],0
	; 13/01/2024
	mov	bx,ax
	JMP	short setend			     ; NO		;AN000;

yesfat: ; 10/08/2018
	MOV	DX,AX
	LODSB
	;DEC	AL
	; 17/12/2022
	dec	ax
	STOSB				; dpb_cluster_mask
	;INC	AL
	inc	ax
	XOR	AH,AH
LOG2LOOP:
	test	AL,1
	JNZ	short SAVLOG
	INC	AH
	SHR	AL,1
	JMP	SHORT LOG2LOOP
SAVLOG:
	MOV	AL,AH
	STOSB				; dpb_cluster_shift
	MOV	BL,AL
	MOVSW				; dpb_first_FAT Start of FAT (# of reserved sectors)
	LODSB
	STOSB				; dpb_FAT_count Number of FATs
;	OR	AL,AL			; NONFAT ?				;AN000;
;	JZ	short setend		; yes, don't do anything                ;AN000;
	MOV	BH,AL
	LODSW
	STOSW				; dpb_root_entries Number of directory entries
	MOV	CL,5
	SHR	DX,CL			; Directory entries per sector
	DEC	AX
	ADD	AX,DX			; Cause Round Up
	MOV	CX,DX
	XOR	DX,DX
	DIV	CX
	MOV	CX,AX			; Number of (root) directory sectors
	INC	DI
	INC	DI			; Skip dpb_first_sector
	MOVSW			; Total number of sectors in DSKSIZ (temp as dpb_max_cluster)
	LODSB
	;mov	[es:bp+17h],al
	MOV	[ES:BP+DPB.MEDIA],AL	; Media byte
	LODSW				; Number of sectors in a FAT
	
	;;;
	;MSDOS 3.3
	;
	;STOSB		; DPB.FAT_SIZE
	;MUL	BH
	
	;MSDOS 6.0
	;
	STOSW		; DPB.FAT_SIZE	;AC000;;>32mb dpb_FAT_size
	MOV	DL,BH			;AN000;;>32mb
	XOR	DH,DH			;AN000;;>32mb
	MUL	DX			;AC000;;>32mb Space occupied by all FATs
	;;;
	
	;add	ax,[es:bp+6]
	ADD	AX,[ES:BP+DPB.FIRST_FAT]
	STOSW				; dpb_dir_sector
	ADD	AX,CX			; Add number of (root) directory sectors
	;mov	[es:bp+0Bh],ax
	MOV	[ES:BP+DPB.FIRST_SECTOR],AX
	
	; MSDOS 6.0
	MOV	CL,BL			;F.C. >32mb				;AN000;
	;;cmp	word [es:bp+0Dh],0
	;CMP	WORD [ES:BP+DSKSIZ],0	;F.C. >32mb				;AN000;
	;JNZ	short normal_dpb	;F.C. >32mb				;AN000;
	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	; 15/12/2022
	; 28/07/2019
	mov	bx,[ES:BP+DSKSIZ]
	or	bx,bx
	JNZ	short normal_dpb	;F.C. >32mb				;AN000;
	;CMP	WORD [ES:BP+DSKSIZ],0	;F.C. >32mb				;AN000;
	;JNZ	short normal_dpb	;F.C. >32mb				;AN000;
	

	XOR	CH,CH			;F.C. >32mb				;AN000;
	;mov	bx,[si+8]
	MOV	BX,[SI+A_BPB.BPB_BIGTOTALSECTORS-A_BPB.BPB_SECTORSPERTRACK]	;AN000;
	;mov	dx,[si+10]
	MOV	DX,[SI+A_BPB.BPB_BIGTOTALSECTORS-A_BPB.BPB_SECTORSPERTRACK+2]	;AN000;
	SUB	BX,AX			;AN000;;F.C. >32mb
	SBB	DX,0			;AN000;;F.C. >32mb
	OR	CX,CX			;AN000;;F.C. >32mb
	JZ	short norot		;AN000;;F.C. >32mb
rott:					;AN000;;F.C. >32mb
	CLC				;AN000;;F.C. >32mb
	RCR	DX,1			;AN000;;F.C. >32mb
	RCR	BX,1			;AN000;;F.C. >32mb
	LOOP	rott			;AN000;;F.C. >32mb
norot:					;AN000;
	; 15/12/2022
	;MOV	AX,BX			;AN000;;F.C. >32mb
	JMP	short setend		;AN000;;F.C. >32mb
normal_dpb:
	;;sub	ax,[es:bp+0Dh]
	;SUB	AX,[ES:BP+DSKSIZ]
	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	; 15/12/2022
	; bx = [es:bp+DSKSIZ]
	;sub	ax,bx ; 28/07/2019
	;;SUB	AX,[ES:BP+DSKSIZ]
	; 15/12/2022
	sub	bx,ax
	;NEG	AX			; Sectors in data area
;;	MOV	CL,BL			; dpb_cluster_shift
	; 15/12/2022
	; CL = cluster shift
	; BX = number of data sectors 
	;SHR	AX,CL			; Div by sectors/cluster
	shr	bx,cl 
setend:
;	M008 - CAS
;
	; 15/12/2022
	inc	bx
	;INC	AX			; +2 (reserved), -1 (count -> max)
;
;	There has been a bug in our fatsize calculation for so long
;	  that we can't correct it now without causing some user to
;	  experience data loss. There are even cases where allowing
;	  the number of clusters to exceed the fats is the optimal
;	  case -- where adding 2 more fat sectors would make the
;	  data field smaller so that there's nothing to use the extra
;	  fat sectors for.
;
;	Note that this bug had very minor known symptoms. CHKDSK would
;	  still report that there was a cluster left when the disk was
;	  actually full. Very graceful failure for a corrupt system
;	  configuration. There may be worse cases that were never
;	  properly traced back to this bug. The problem cases only
;	  occurred when partition sizes were very near FAT sector
;	  rounding boundaries, which were rare cases.
;
;	Also, it's possible that some third-party partition program might
;	  create a partition that had a less-than-perfect FAT calculation
;	  scheme. In this hypothetical case, the number of allocation
;	  clusters which don't actually have FAT entries to represent
;	  them might be larger and might create a more catastrophic
;	  failure. So we'll provide the safeguard of limiting the
;	  max_cluster to the amount that will fit in the FATs.
;
;	ax = maximum legal cluster, ES:BP -> dpb

;	make sure the number of fat sectors is actually enough to
;	  hold that many clusters. otherwise, back the number of
;	  clusters down

	; 15/12/2022
	; bx = number of clusters

	; 19/07/2018 - Retro DOS v3.0
	; MSDOS 6.0
	; 15/12/2022
	;mov	bx,ax			; remember calculated # clusters

	; 01/08/2018 (MSDOS 3.3)
	;mov	al,[ES:BP+DPB.FAT_SIZE]
	;xor	ah,ah 

	; 10/05/2019 - Retro DOS v4.0
	;mov	ax,[ES:BP+0Fh]
	mov	ax,[ES:BP+DPB.FAT_SIZE]

	;mul	word [es:bp+2]	
	mul	word [ES:BP+DPB.SECTOR_SIZE] ; how big is the FAT?
	cmp	bx,4096-10  ; 0FF6h	; test for 12 vs. 16 bit fat
	jb	short setend_fat12
	shr	dx,1

; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	; 15/12/2022
;cs3 7/2/92
	jnz	short setend_faterr	; some bonehead gave us more fatspace
					; than enough for the maximum FAT,
					; so go ahead and use the calculated
					; number of clusters.
;cs3 7/2/92

	rcr	ax,1			; find number of entries
	cmp	ax,4096-10+1		; would this truncation move us
;					;  into 12-bit fatland?
	jb	short setend_faterr	; then go ahead and let the
;					;  inconsistency pass through
;					;  rather than lose data by
;					;  correcting the fat type
	jmp	short setend_fat16

setend_fat12:
	add	ax,ax			; (fatsiz*2)/3 = # of fat entries
	adc	dx,dx

; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
;cs3 7/2/92
	; 15/12/2022
	cmp	dx,3			; if our fatspace is WAY more than
	jnb	short setend_faterr	; we need, we may get an overflow
					; here. Check for it and use
					; the calculated size in this case.
;cs3 7/2/92

	div	word [cs:word3]

setend_fat16:
	dec	ax			; limit at 1
	cmp	ax,bx			; is fat big enough?
	jbe	short setend_fat	; use max value that'll fit

setend_faterr:
	mov	ax,bx			; use calculated value

setend_fat:

;	now ax = maximum legal cluster

;	end M008

	;mov	[es:bp+0Dh], ax
	MOV	[ES:BP+DPB.MAX_CLUSTER],AX
	;;mov	word [es:bp+1Ch],0  ; MSDOS 3.3
	;mov	word [es:bp+1Dh],0  ; MSDOS 6.0
	MOV	word [ES:BP+DPB.NEXT_FREE],0 
					; Init so first ALLOC starts at
					; begining of FAT
	;;mov	word [es:bp+1Eh],-1 ; MSDOS 3.3
	;mov	word [es:bp+1Fh],-1 ; MSDOS 6.0
	MOV	word [ES:BP+DPB.FREE_CNT],-1 ; current count is invalid.

	retn

;EndProc $SETDPB

;BREAK <$Create_Process_Data_Block,SetMem -- Set up process data block>

;
;----------------------------------------------------------------------------
;
;**	$Dup_PDB
;
; Inputs:   DX is new segment address of process
;	    SI is end of new allocation block
;
;----------------------------------------------------------------------------
;

_$DUP_PDB:

;hkn;	CreatePDB would have a CS override. This is not valid.
;hkn;	Must set up ds in order to acess CreatePDB. Also SS is 
;hkn;	has been assumed to be NOTHING. It may not have DOSDATA.

	; MSDOS 3.3
	;MOV	byte [CS:CreatePDB],0FFh  ; indicate a new process
	;MOV	DS,[CS:CurrentPDB]

	; 15/05/2019 - Retro DOS v4.0
	; MSDOS 6.0
	mov	ds,[cs:DosDSeg]
	MOV	byte [CreatePDB],0FFh
	MOV	DS,[CurrentPDB]

	PUSH	SI
	JMP	SHORT CreateCopy

;
;----------------------------------------------------------------------------
;
; Inputs:
;	DX = Segment number of new base
; Function:
;	Set up program base and copy term and ^C from int area
; Returns:
;	None
; Called at DOS init
;
;----------------------------------------------------------------------------
;

; 15/05/2019 - Retro DOS v4.0
; DOSCODE:4EB6h (MSDOS 6.21, MSDOS.SYS)

; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:4EA2h (MSDOS 5.0, MSDOS.SYS)

_$CREATE_PROCESS_DATA_BLOCK:
			; Offset 1D02h in IBMDOS.COM (MSDOS 3.3), 1987
	CALL	Get_User_Stack
	;mov	ds,[si+14h]
	MOV	DS,[SI+user_env.user_CS]
	;push	word [2]
	PUSH	word [PDB.BLOCK_LEN] ;*
CreateCopy:
	MOV	ES,DX

	XOR	SI,SI			; copy entire PDB
	MOV	DI,SI
	MOV	CX,128
	REP	MOVSW

; DOS 3.3 7/9/86
	;mov	cx,20
	;MOV	CX,FILPERPROC		; copy handles in case of
	; 15/12/2022
	mov	cl,FILPERPROC ; 06/07/2019
	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;mov	cx,FILPERPROC

	;mov	di,18h
	MOV	DI,PDB.JFN_TABLE	; Set Handle Count has been issued
	;;PUSH	DS ; * 15/05/2019
	;;lds	si,[34h]
	;LDS	SI,[PDB.JFN_Pointer]
	;REP	MOVSB
	;;POP	DS ; * 15/05/2019
	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	; 05/12/2022
	; (push ds then pop ds is not needed here!)
	;push	ds
	;lds	si,[34h]
	lds	si,[PDB.JFN_Pointer]
	rep	movsb
	;pop	ds

; DOS 3.3 7/9/86
	;hkn ;CreatePDB would have a CS override. This is not valid.
	;hkn ;Must set up ds in order to access CreatePDB. Also SS is 
	;hkn ;has been assumed to be NOTHING. It may not have DOSDATA.

	mov	ds,[cs:DosDSeg] ; 15/05/2019

	;;test	byte [cs:CreatePDB],0FFh
	;cmp	byte [CS:CreatePDB],0	; Shall we create a process?
	; 17/12/2022
	cmp	[CreatePDB],cl ; 0
	;cmp	byte [CreatePDB],0 ; 15/05/2019
	JZ	short Create_PDB_cont 	; nope, old style call

; Here we set up for a new process...

	;PUSH	CS			; Called at DOSINIT time, NO SS
	;POP	DS

	; MSDOS 6.0
	;;getdseg <ds>			; ds -> dosdata
	;mov	ds,[cs:DosDSeg] ; 15/05/2019
	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	; (nonsense! but i put this for addr compatibility as temporary)
	; 15/12/2022
	;mov	ds,[cs:DosDSeg] ; 15/05/2019

	XOR	BX,BX			; dup all jfns
	;mov	cx,20
	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;MOV	CX,FILPERPROC		; only 20 of them
	; 15/12/2022
	mov	cl,FILPERPROC ; 06/07/2019

Create_dup_jfn:
	PUSH	ES ;**			; save new PDB
	call	SFFromHandle		; get sf pointer
	MOV	AL,-1			; unassigned JFN
	JC	short CreateStash	; file was not really open
	;;test	word [es:di+5],1000h
	;TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_no_inherit
	; 15/05/2019
	;test	byte [es:di+6],10h
	test	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_no_inherit>>8)
	JNZ	short CreateStash	; if no-inherit bit is set, skip dup.

; We do not inherit network file handles.

	;mov	ah,[es:di+2]
	MOV	AH,[ES:DI+SF_ENTRY.sf_mode]
	;and	ah,0F0h
	AND	AH,SHARING_MASK
	;cmp	ah,70h
	CMP	AH,SHARING_NET_FCB
	jz	short CreateStash

; The handle we have found is duplicatable (and inheritable). Perform
; duplication operation.

	MOV	[THISSFT],DI
	MOV	[THISSFT+2],ES
	call	DOS_DUP 		; signal duplication

; get the old sfn for copy

	call	pJFNFromHandle		; ES:DI is jfn
	MOV	AL,[ES:DI]		; get sfn

; Take AL (old sfn or -1) and stash it into the new position

CreateStash:
	POP	ES ;**
	;mov	[es:bx+18h],al
	MOV	[ES:BX+PDB.JFN_TABLE],AL ; copy into new place!
	INC	BX			; next jfn...
	LOOP	Create_dup_jfn

	MOV	BX,[CurrentPDB]		; get current process
	; 06/11/2022
	;mov	[es:16h],bx
	MOV	[ES:PDB.PARENT_PID],BX	; stash in child
	MOV	[CurrentPDB],ES
	;MOV	DS,BX ; 28/07/2019
	; 07/12/2022
	;mov	ds,[cs:DosDSeg]
	; 15/12/2022
	; ds = [cs:DosDSeg]
	mov	byte [CreatePDB],0	; reset flag
	;mov	ds,bx
	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	; 15/12/2022
	;mov	ds,bx

; end of new process create

Create_PDB_cont:
	;MOV	BYTE [CS:CreatePDB],0	; reset flag

;hkn; It comes to this point from 2 places. So, change to DOSDATA temporarily	

	;; 28/07/2019
	;;push	ds
	;;mov	ds,[cs:DosDSeg]
	;mov	byte [CreatePDB],0
	;;pop	ds

; 05/12/2022
;	; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
;	; (push-pop ds is nonsense here! 
;	;  but i am using same code with original MSDOS.SYS
;	;  for address compatibility.)
;	push	ds
;	; ds = [cs:DosDSeg] !
;	mov	ds,[cs:DosDSeg]  ; again !
;	mov	byte [CreatePDB],0
;	pop	ds

	POP	AX ;*

	;entry	SETMEM

	; 17/12/2022
	; cx = 0

;---------------------------------------------------------------------------
; Inputs:
;	AX = Size of memory in paragraphs
;	DX = Segment
; Function:
;	Completely prepares a program base at the
;	specified segment.
; Called at DOS init
; Outputs:
;	DS = DX
;	ES = DX
;	[0] has INT int_abort
;	[2] = First unavailable segment
;	[5] to [9] form a long call to the entry point
;	[10] to [13] have exit address (from int_terminate)
;	[14] to [17] have ctrl-C exit address (from int_ctrl_c)
;	[18] to [21] have fatal error address (from int_fatal_abort)
; DX,BP unchanged. All other registers destroyed.
;---------------------------------------------------------------------------

SETMEM:
	;XOR	CX,CX
	; 17/12/2022
	; cx = 0
	MOV	DS,CX
	MOV	ES,DX
	;mov	si,88h
	MOV	SI,addr_int_terminate
	;mov	di,10 ; 0Ah
	MOV	DI,SAVEXIT
	;MOV	CX,6
	; 15/12/2022
	mov	cl,6
	REP	MOVSW
	MOV	[ES:2],AX
	SUB	AX,DX
	CMP	AX,MAXDIF ; 0FFFh
	JBE	short HAVDIF
	MOV	AX,MAXDIF
HAVDIF:
	SUB	AX,10h			; Allow for 100h byte "stack"
	MOV	BX,ENTRYPOINTSEG ; 0Ch	;	in .COM files
	SUB	BX,AX
	MOV	CL,4
	SHL	AX,CL
	MOV	DS,DX

	; (MSDOS 6.0 note)
	;
	; The address in BX:AX will be F01D:FEF0 if there is 64K or more 
	; memory in the system. This is equivalent to 0:c0 if A20 is OFF.
	; If DOS is in HMA this equivalence is no longer valid as A20 is ON.
	; But the BIOS which now resides in FFFF:30 has 5 bytes in FFFF:D0
	; (F01D:FEF0) which is the same as the ones in 0:C0, thereby 
	; making this equvalence valid for this particular case. If however
	; there is less than 64K remaining the address in BX:AX will not 
	; be the same as above. We will then stuff 0:c0, the call 5 address
	; into the PSP.
	;
	; Therefore for the case where there is less than 64K remaining in 
	; the system old CPM Apps that look at PSP:6 to determine memory
	; requirements will not work. Call 5, however will continue to work
	; for all cases.
	;

	;mov	[6],ax
	;mov	[8],bx

	MOV	[PDB.CPM_CALL+1],AX
	MOV	[PDB.CPM_CALL+3],BX

	; 06/05/2019 - Retro DOS v4.0
	cmp	ax,WRAPOFFSET ; 0FEF0h	; Q: does the system have >= 64k of
					;    memory left
	je	short addr_ok		; Y: the above calculated address is
					;    OK
					; N: 

	MOV	WORD [PDB.CPM_CALL+1],0C0h
	MOV	WORD [PDB.CPM_CALL+3],0
addr_ok:
	;mov	word [0],20CDh
	MOV	word [PDB.EXIT_CALL],(int_abort*256) + mi_INT
	;mov	byte [5],9Ah
	MOV	BYTE [PDB.CPM_CALL],mi_Long_CALL
	;mov	word [50h],21CDh
	MOV	WORD [PDB.CALL_SYSTEM],(int_command*256) + mi_INT
	;mov	byte [52h],0CBh
	MOV	BYTE [PDB.CALL_SYSTEM+2],mi_Long_RET
	;mov	word [34h],18h
	MOV	WORD [PDB.JFN_Pointer],PDB.JFN_TABLE
	;mov	word [36h],ds
	MOV	WORD [PDB.JFN_Pointer+2],DS
	;mov	word [32h],20
	MOV	WORD [PDB.JFN_Length],FILPERPROC
;
; The server runs several PDB's without creating them VIA EXEC.  We need to
; enumerate all PDB's at CPS time in order to find all references to a
; particular SFT.  We perform this by requiring that the server link together
; for us all sub-PDB's that he creates. The requirement for us, now, is to
; initialize this pointer.
;
 	;mov	word [38h],-1
	MOV	word [PDB.Next_PDB],-1
	;mov	word [3Ah],-1
	MOV	word [PDB.Next_PDB+2],-1

	; 06/05/2019
	; Set the real version number in the PSP - 5.00

	;mov	word [es:PDB.Version],1406h ; MSDOS 6.21 (DOSCODE:4FB6h)
	; 07/12/2022
	mov	word [ES:PDB.Version],(MINOR_VERSION*256)+MAJOR_VERSION

	retn

; 29/04/2019 - Retro DOS v4.0

;BREAK <$GSetMediaID -- get set media ID>

;---------------------------------------------------------------------------
; Inputs:
;	BL= drive number as defined in IOCTL
;	AL= 0 get media ID
;	    1 set media ID
;	DS:DX= buffer containing information
;		DW  0  info level (set on input)
;		DD  ?  serial #
;		DB  11 dup(?)  volume id
;		DB   8 dup(?)  file system type
; Function:
;	Get or set media ID
; Returns:
;	carry clear, DS:DX is filled
;	carry set, error
;---------------------------------------------------------------------------

	; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
_$GSetMediaID:
	; RAWIO - GET_MEDIA_ID
	mov	cx,0866h	      ;AN000;MS.; assume get  for IOCTL
	cmp	al,0		      ;AN001;MS.; get ?
	je	short doioctl 	      ;AN000;MS.; yes
	;cmp	al,1		      ;AN000;MS.; set ?
	;jne	short errorfunc	      ;AN000;MS.; no
	; 15/12/2022
	dec	al
	jnz	short errorfunc ; al > 1
	; RAWIO - SET_MEDIA_ID
	;mov	cx,0846h	      ;AN001;MS.;
	; 15/12/2022
	mov	cl,46h	; cx = 0846h 
doioctl:			      ;AN000;
	mov	al,0Dh		      ;AN000;MS.; generic IOCTL
	;invoke	$IOCTL		      ;AN000;MS.; let IOCTL take care of it
	;call	_$IOCTL
	;retn			      ;AN000;MS.;
	; 15/12/2022
	jmp	_$IOCTL
errorfunc:			      ;AN000;
	;error	error_invalid_function;AN000;MS. ; invalid function
	;mov	al,1
	mov	al,error_invalid_function
	jmp	SYS_RET_ERR

; 16/05/2019 - Retro DOS v4.0

;============================================================================
; MISC2.ASM, MSDOS 6.0, 1991
;============================================================================
; 20/07/2018 - Retro DOS v3.0
; 29/04/2019 - Retro DOS v4.0

; Break <STRCMP - compare two ASCIZ strings DS:SI to ES:DI>
;----------------------------------------------------------------------------
;
;   Strcmp - compare ASCIZ DS:SI to ES:DI. Case INSENSITIVE. '/' = '\'
;	     Strings of different lengths don't match.
;   Inputs:  DS:SI - pointer to source string  ES:DI - pointer to dest string
;   Outputs: Z if strings same, NZ if different
;   Registers modified: NONE
;----------------------------------------------------------------------------

	; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
StrCmp:
	push	si
	push	di
	push	ax
Cmplp:
	LODSB
	call	UCase			; convert to upper case
	call	PATHCHRCMP		; convert '/' to '\' ; 07/12/2022 ('\')
	MOV	AH,AL
	MOV	AL,[ES:DI]
	INC	DI
	call	UCase			; convert to upper case
	call	PATHCHRCMP		; convert '/' to '\' ; 07/12/2022 ('\')
	CMP	AH,AL
	JNZ	short PopRet		; Strings dif

	OR	AL,AL
	JNZ	short Cmplp		; More string
PopRet:
	pop	ax
	pop	di
	pop	si
	retn

;Break <STRCPY - copy ASCIZ string from DS:SI to ES:DI>
;----------------------------------------------------------------------------
;
;   Strcpy - copy an ASCIZ string from DS:SI to ES:DI and make uppercase
;   FStrcpy - copy an ASCIZ string from DS:SI to ES:DI. no modification of
;	characters.
;
;   Inputs:	DS:SI - pointer to source string
;		ES:DI - pointer to destination string
;   Outputs:	ES:DI point byte after nul byte at end of dest string
;		DS:SI point byte after nul byte at end of source string
;   Registers modified: SI,DI
;----------------------------------------------------------------------------

StrCpy:
	push	ax
CPYLoop:
	LODSB
	call	UCase			; convert to upper case
	call	PATHCHRCMP		; convert / to \ ;
	STOSB

	OR	AL,AL
	JNZ	short CPYLoop
	pop	ax
	retn

;----------------------------------------------------------------------------
; Procedure Name : FStrCpy
;----------------------------------------------------------------------------

FStrCpy:
	push	ax
FCPYLoop:
	LODSB
	STOSB
	OR	AL,AL
	JNZ	short FCPYLoop
	pop	ax
	retn

; 20/07/2018 - Retro DOS v3.0
;----------------------------------------------------------------------------
; UCase, IBMDOS.COM (MSDOS 3.3), 1987 - Offset 1E2Fh
;----------------------------------------------------------------------------
;
;UCase:	
;	call	_UCase	 ; Offset 5518h (GetLet, Offset 5517h)
;	retn

;Break <StrLen - compute length of string ES:DI>
;----------------------------------------------------------------------------
;**	StrLen - Compute Length of String
;
;	StrLen computes the length of a string, including the trailing 00
;
;	ENTRY	(es:di) = address of string
;	EXIT	(cx) = size of string
;	USES	cx, flags
;----------------------------------------------------------------------------

StrLen:
	push	di
	push	ax
	;MOV	CX,-1
	mov	cx,65535
	XOR	AL,AL
	REPNE	SCASB
	NOT	CX
	pop	ax
	pop	di
	retn

;----------------------------------------------------------------------------
;**	DStrLen - Compute Length of String
;
;	ENTRY	(ds:si) = address of string
;	EXIT	(cx) = size of string, including trailing NUL
;	USES	cx, flags
;----------------------------------------------------------------------------

DStrLen:	; BUGBUG - this guy is a pig, who uses him?
	CALL	XCHGP
	CALL	StrLen
	;CALL	XCHGP
	;retn
	; 18/12/2022
	;jmp	short XCHGP

;----------------------------------------------------------------------------
;**	XCHGP - Exchange Source and Destination Pointers
;
;	XCHGP exchanges (DS:SI) and (ES:DI)
;
;	ENTRY	none
;	EXIT	pairs exchanged
;	USES	SI, DI, DS, ES
;----------------------------------------------------------------------------

XCHGP:
	push	ds
	push	es
	pop	ds
	pop	es
	XCHG	SI,DI
xchgp_retn:
	retn

;Break	<Idle - wait for a specified amount of time>
;----------------------------------------------------------------------------
;
;   Idle - when retrying an operation due to a lock/sharing violation,
;   	   we spin until RetryLoop is exhausted.
;
;   Inputs:	RetryLoop is the number of times we spin
;   Outputs:	Wait
;   Registers modified: none
;----------------------------------------------------------------------------

Idle:
	;test	byte [SS:FSHARING],0FFh
	cmp	byte [SS:FSHARING],0	;hkn; SS override
	;retnz
	jnz	short xchgp_retn
	;SAVE	<CX>
	push	cx
	MOV	CX,[ss:RetryLoop]	;hkn; SS override
	JCXZ	Idle3
Idle1:	
	PUSH	CX
	XOR	CX,CX
Idle2:	
	LOOP	Idle2
	POP	CX
	LOOP	Idle1
Idle3:	
	;RESTORE <CX>
	pop	cx
	retn

;Break	<TableDispatch - dispatch to a table>
;----------------------------------------------------------------------------
;
;   TableDispatch - given a table and an index, jmp to the approptiate
;   routine. Preserve all input registers to the routine.
;
;   Inputs:	Push	return address
;		Push	Table address
;		Push	index (byte)
;   Outputs:	appropriate routine gets jumped to.
;		return indicates invalid index
;   Registers modified: none.
;----------------------------------------------------------------------------

struc TFrame	 ; TableFrame
.OldBP:	 resw 1  ; 0
.OldRet: resw 1  ; 2
.Index:	 resb 1  ; 4
.Pad:	 resb 1  ; 5  
.Tab:	 resw 1  ; 6
.NewRet: resw 1  ; 8
endstruc

TableDispatch:
	PUSH	BP
	MOV	BP,SP
	PUSH	BX			; save BX
	;mov	bx,[bp+6]
	MOV	BX,[BP+TFrame.Tab]	; get pointer to table
	MOV	BL,[CS:BX]		; maximum index
	;cmp	[bp+4],bl
	CMP	[BP+TFrame.Index],BL	; table error?
	JAE	short TableError	; yes
	;mov	bl,[bp+4]
	MOV	BL,[BP+TFrame.Index]	; get desired table index
	XOR	BH,BH			; convert to word
	SHL	BX,1			; convert to word pointer
	INC	BX			; point past first length byte
	; 17/08/2018
	;add	bx,[bp+6]
	ADD	BX,[BP+TFrame.Tab]	; get real offset
	MOV	BX,[CS:BX]		; get contents of table entry
	;mov	[bp+6],bx
	MOV	[BP+TFrame.Tab],BX	; put table entry into return address
	POP	BX			; restore BX
	POP	BP			; restore BP
	ADD	SP,4			; clean off Index and our return addr
	retn				; do operation
TableError:
	POP	BX			; restore BX
	POP	BP			; restore BP
	RETN	6			; clean off Index, Table and RetAddr

;Break	<TestNet - determine if a CDS is for the network>
;----------------------------------------------------------------------------
;
;   TestNet - examine CDS pointed to by ThisCDS and see if it indicates a
;	network CDS. This will handle NULL cds also.
;
;   Inputs:	ThisCDS points to CDS or NULL
;   Outputs:	ES:DI = ThisCDS
;		carry Set => network
;		carry Clear => local
;   Registers modified: none.
;----------------------------------------------------------------------------

TestNet:
	;LES	DI,[CS:THISCDS]

	; 16/05/2019 - Retro DOS v4.0
	mov	es,[cs:DosDSeg]
	LES	DI,[ES:THISCDS]
	CMP	DI,-1
	JZ	short CMCRet		; UNC? carry is clear
	;;test	word [es:di+43h],8000h
	;TEST	word [ES:DI+curdir.flags],curdir_isnet
	;test	byte [es:di+44h],80h
	TEST	byte [ES:DI+curdir.flags+1],(curdir_isnet>>8)
	JNZ	short CMCRet		; jump has carry clear
	retn				; carry is clear
CMCRet: 
	CMC
	retn

;Break	<IsSFTNet - see if an sft is for the network>
;----------------------------------------------------------------------------
;
;   IsSFTNet - examine SF pointed to by ES:DI and see if it indicates a
;	network file.
;
;   Inputs:	ES:DI point to SFT
;   Outputs:	Zero set if not network sft
;		zero reset otherwise
;		Carry CLEAR!!!
;   Registers modified: none.
;----------------------------------------------------------------------------

IsSFTNet:
	;;test	word [es:di+5],8000h
	;TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
	; 16/05/2019 
	;test	byte [es:di+6],80h
	TEST	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
	retn

;Break	<FastInit - Initialize FastTable entries >
;----------------------------------------------------------------------------
;   DOS 4.00   2/9/87
;   FastInit  - initialize the FASTXXX routine entry
;		  in the FastTable
;
;   Inputs:	BX = FASTXXX ID ( 1=fastopen )
;		DS:SI = address of FASTXXX routine entry
;		   SI = -1 for query only
;   Outputs:	Carry flag clear, if success
;		Carry flag set,   if failure
;
;
;----------------------------------------------------------------------------

;Procedure FastInit,NEAR
;	ASSUME	CS:DOSCODE,SS:NOTHING

;	; MSDOS 3.3
;	; IBMDOS.COM (1987) - Offset 1EB3h
;FastInit:
;	mov	di,FastTable ; FastOpenTable
;	mov	ax,[cs:di+4]		; Entry segment
;	mov	bx,cs			; get DOS segment
;	cmp	ax,bx			; first time installed ?	
;	je	short ok_install	; yes
;	stc				; set carry
;	retn				; (cf=1 means) already installed !
;
;ok_install:
;	mov	bx,FastTable ; FastOpenTable
;	mov	cx,ds
;	; set address of FASTXXX (FASTOPEN) routine entry
;	mov	[cs:bx+4],cx
;	mov	[cs:bx+2],si
;	retn

; 16/05/2019 - Retro DOS v4.0

FastInit:
	; MSDOS 6.0
	;hkn; set up es to dosdataseg.
	push	es
	;getdseg <es>			; es -> dosdata
	mov	es,[cs:DosDSeg]

	;hkn; FastTable is in DOSDATA
	MOV	DI,FastTable+2		;AN000;FO. points to fastxxx entry
	DEC	BX			;AN000;FO.;; decrement index
	MOV	DX,BX			;AN000;FO.;; save bx
	SHL	BX,1			;AN000;FO.;; times 4, each entry is DWORD
	SHL	BX,1			;AN000;FO.
	ADD	DI,BX			;AN000;FO. index to the entry
	MOV	AX,[ES:DI+2]		;AN000;FO. get entry segment
fcheck: 				;AN000;
	MOV	CX,CS			;AN000;FO.;; get DOS segment
	CMP	AX,CX			;AN000;FO.;; first time installed ?
	JZ	short ok_install	;AN000;FO.;; yes
	OR	AX,AX			;AN000;FO.;
	;JZ	short ok_install	;AN000;FO.;
	;STC				;AN000;FO.;; already installed !
	;JMP	SHORT FSret		;AN000;FO. set carry
	; 14/01/2024
	stc
	jnz	short FSret
ok_install:				;AN000;
	CMP	SI,-1			;AN000;FO.; Query only ?
	JZ	short FSret		;AN000;FO.; yes
	MOV	CX,DS			;AN000;FO.; get FASTXXX entry segment
	MOV	[ES:DI+2],CX		;AN000;FO.; initialize routine entry
	MOV	[ES:DI],SI		;AN000;FO.; initialize routine offset

;hkn; FastFlg moved to DOSDATA
	MOV	DI,FastFlg		;AN000;FO.; get addr of FASTXXX flags
	ADD	DI,DX			;AN000;FO.; index to a FASTXXX flag
	;or	byte [es:di],80h
	OR	byte [ES:DI],Fast_yes	;AN000;FO.; indicate installed
FSret:					;AN000;
	pop	es
	retn				;AN000;FO.

;EndProc FastInit

;Break	<FastRet - initial routine in FastOpenTable >
;----------------------------------------------------------------------------
;   DOS 3.3   6/10/86
;   FastRet	- indicate FASTXXXX  not in memory
;
;   Inputs:	None
;   Outputs:	AX = -1 and carry flag set
;
;   Registers modified: none.
;----------------------------------------------------------------------------

FastRet:
	;mov	ax,-1
	;stc
	;retf
	STC
	sbb	ax,ax		; (ax) = -1, 'C' set
	RETF

;Break	<NLS_OPEN - do $open for NLSFUNC>
;----------------------------------------------------------------------------
;   DOS 3.3   6/10/86
;   NLS_OPEN	- call $OPEN for NLSFUNC
;
;   Inputs:	Same input as $OPEN except CL = mode
;   Outputs:	same output as $OPEN
;
;----------------------------------------------------------------------------

;hkn; NOTE! SS MUST HAVE BEEN SET UP TO DOSDATA BY THE TIME THESE
;hkn; NLS FUNCTIONS ARE CALLED!!! THERE FORE WE WILL USE SS OVERRIDES
;hkn; IN ORDER TO ACCESS DOS DATA VARIABLES!

NLS_OPEN:
;	MOV	BL,[CPSWFLAG]	 ; disable code page matching logic
;	MOV	BYTE [CPSWFLAG],0
;	PUSH	BX		 ; save current state

	MOV	AL,CL		 ; set up correct interface for $OPEN
	call	_$OPEN

;	POP	BX		 ; restore current state
;	MOV	[CPSWFLAG],BL

	RETN

;Break	<NLS_LSEEK - do $LSEEK for NLSFUNC>
;----------------------------------------------------------------------------
;   DOS 3.3   6/10/86
;   NLS_LSEEK	- call $LSEEK for NLSFUNC
;
;   Inputs:	BP = open mode
;   Outputs:	same output as $LSEEK
;
;----------------------------------------------------------------------------

; 16/05/2019 - Retro DOS v4.0

NLS_LSEEK:
	PUSH	word [SS:USER_SP] ; save user stack
	PUSH	word [SS:USER_SS]
	CALL	Fake_User_Stack
	MOV	AX,BP		; set up correct interface for $LSEEK
	call	_$LSEEK
	POP	word [SS:USER_SS] ; restore user stack
	POP	word [SS:USER_SP]
	RETN

;Break	<Fake_User_Stack - save user stack>
;----------------------------------------------------------------------------
;   DOS 3.3   6/10/86
;   Fake_User_Stack - save user stack pointer
;
;----------------------------------------------------------------------------

Fake_User_Stack:
	MOV	AX,[SS:USER_SP_2F] ; replace with INT 2F stack
	MOV	[SS:USER_SP],AX
	MOV	AX,SS
	MOV	[SS:USER_SS],AX
	RETN

;Break	<GetDevList - get device header list pointer>
;----------------------------------------------------------------------------
;   DOS 3.3   7/25/86
;   GetDevList - get device header list pointer
;
;   Output: AX:BX points to the device header list
;----------------------------------------------------------------------------

GetDevList:
	; 16/05/2019 - Retro DOS v4.0
	MOV	SI,SysInitTable
	mov	ds,[cs:DosDSeg]
	LDS	SI,[SI]
	;mov	ax,[si+34]  ; SSYSINITVARS offset 34 = [SI+SYSI.DEV]
	MOV	AX,[SI+SYSI.DEV]
	;mov	bx,[si+36]  ; SSYSINITVARS offset 36 = [SI+SYSI.DEV+2]
	MOV	BX,[SI+SYSI.DEV+2]
	RETN

;Break	<NLS_IOCTL - do $IOCTL for NLSFUNC>
;----------------------------------------------------------------------------
;   DOS 3.3   7/25/86
;   NLS_IOCTL	- call $IOCTL for NLSFUNC
;
;   Inputs:	BP = function code 0CH
;   Outputs:	same output as generic $IOCTL
;
;----------------------------------------------------------------------------

NLS_IOCTL:
	; 16/05/2019 - Retro DOS v4.0
	PUSH	word [SS:USER_SP] ; save user stack
	PUSH	word [SS:USER_SS]
	CALL	Fake_User_Stack
	MOV	AX,BP		; set up correct interface for $IOCTL
	call	_$IOCTL
	POP	word [SS:USER_SS] ; restore user stack
	POP	word [SS:USER_SP]
	RETN

;Break	<NLS_GETEXT- get extended error for NLSFUNC>
;----------------------------------------------------------------------------
;   DOS 3.3   7/25/86
;   NLS_GETEXT	-
;
;   Inputs:	none
;   Outputs:	AX = extended error
;
;----------------------------------------------------------------------------

NLS_GETEXT:
	; 16/05/2019 - Retro DOS v4.0
	MOV	AX,[SS:EXTERR]	 ; return extended error
	; 23/09/2023
MSG_RETRIEVAL:
	RETN

; 29/04/2019 - Retro DOS v4.0

;Break	<MSG_RETRIEVAL- get beginning addr of system and parser messages>

;----------------------------------------------------------------------------
;   DOS 4.00
;
;   Inputs:	DL=0 get extended error message addr
;		  =1 set extended error message addr
;		  =2 get parser error message addr
;		  =3 set parser error message addr
;		  =4 get critical error message addr
;		  =5 set critical error message addr
;		  =6 get file system error message addr
;		  =7 set file system error message addr
;		  =8 get address for code reduction
;		  =9 set address for code reduction
;   Function:	get/set message address
;   Outputs:	ES:DI points to addr when get
;----------------------------------------------------------------------------

;Procedure MSG_RETRIEVAL,NEAR
;	ASSUME	CS:DOSCODE,SS:NOTHING

; 23/09/2023
;MSG_RETRIEVAL:

;;	NOTE:  This function lives in command.com resident code now.
;;	If the int 2F ever gets this far, we'll return registers
;;	unchanged, which produces the same result as before, if
;;	command.com wasn't present (and therefore no messages available).
;;
;;	I didn't point the entry in the 2F table to No_Op because
;;	No_Op zeroes AL.
;;
;;;hkn; set up ds to point to DOSDATA
;;	push	ds
;;	getdseg	<ds>			; ds -> dosdata
;;
;;	PUSH	AX		    ;AN000;;MS. save regs
;;	PUSH	SI		    ;AN000;;MS. save regs
;;	MOV	AX,DX		    ;AN000;;MS.
;;	MOV	SI,OFFSET DOSDATA:MSG_EXTERROR ;AN000;;MS.
;;	test	AL,1		    ;AN000;;MS. get ?
;;	JZ	toget		    ;AN000;;MS. yes
;;	DEC	AL		    ;AN000;;MS.
;;toget:				    ;AN000;
;;	SHL	AL,1		    ;AN000;;MS. times 2
;;	XOR	AH,AH		    ;AN000;;MS.
;;	ADD	SI,AX		    ;AN000;;MS. position to the entry
;;	test	DL,1		    ;AN000;;MS. get ?
;;	JZ	getget			     ;AN000;;MS. yes
;;	MOV	WORD PTR DS:[SI],DI    ;AN000;;MS. set MSG
;;	MOV	WORD PTR DS:[SI+2],ES  ;AN000;;MS. address to ES:DI
;;	JMP	SHORT MSGret		     ;AN000;;MS. exit
;;getget: 				     ;AN000;
;;	LES	DI,DWORD PTR DS:[SI]	     ;AN000;;MS. get msg addr
;;MSGret: 				     ;AN000;
;;	POP	SI			     ;AN000;;MS.
;;	POP	AX			     ;AN000;;MS.
;;
;;	pop	ds

;	return				     ;AN000;;MS. exit

; 23/09/2023
;	retn	; 29/04/2019

;============================================================================
; ECritDisk, LCritDisk, ECritDevice, LCritDevice
; IBMDOS.COM (MSDOS 3.3), 1987 - Offset 1F36h
;============================================================================
; 20/07/2018 - Retro DOS v3.0

;	; MSDOS 3.3
;	; 08/08/2018 - Retro DOS v3.0
;ECritMEM:
;ECritSFT:
;	;
;ECritDisk:
;	retn
;	;push	ax
;	
;	mov	ax,8001h
;	int	2Ah	; Microsoft Networks - BEGIN DOS CRITICAL SECTION
;			; AL = critical section number (00h-0Fh)
;	pop	ax
;	retn
;
;	; MSDOS 3.3
;	; 08/08/2018 - Retro DOS v3.0
;LCritMEM:
;LCritSFT:
;	;
;LCritDisk:
;	retn
;	;push	ax
;	
;	mov	ax,8101h
;	int	2Ah	; Microsoft Networks - END DOS CRITICAL SECTION
;			; AL = critical section number (00h-0Fh)
;	pop	ax
;	retn
;
;ECritDevice:
;	retn
;	;push	ax
;	
;	mov	ax,8002h
;	int	2Ah	; Microsoft Networks - BEGIN DOS CRITICAL SECTION
;			; AL = critical section number (00h-0Fh)
;	pop	ax
;	retn
;
;LCritDevice:
;	retn
;	;push	ax
;	
;	mov	ax,8102h
;	int	2Ah	; Microsoft Networks - END DOS CRITICAL SECTION
;			; AL = critical section number (00h-0Fh)
;	pop	ax
;	retn

;============================================================================
; CRIT.ASM, MSDOS 6.0, 1991
;============================================================================
; 12/05/2019 - Retro DOS v4.0

; Critical Section Routines

; MSDOS 6.21 - MSDOS.SYS - DOSCODE:513Ah

; 06/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:5126h (MSDOS 5.0 MSDOS.SYS)

; ---------------------------------------------------------------------------
; Each handler must leave everything untouched; including flags!
;
; Sleaze for time savings: first instruction is a return. This is patched
; by the sharer to be a PUSH AX to complete the correct routines.
; ---------------------------------------------------------------------------

; (DOSMAC.INC, MSDOS 6.0, 1991)
; ---------------------------------------------------------------------------
; Some old versions of the 80286 have a bug in the chip. The popf instruction
; will enable interrupts. Therefore in a section of code with interrupts
; disabled and you need a popf instruction use the 'popff' macro instead.
; ---------------------------------------------------------------------------

;%macro POPFF 0
;	jmp	$+3
;	iret
;	push	cs
;	call	$-2
;%endmacro

; ---------------------------

;Procedure  ECritDisk,NEAR
	;public  ECritMEM
	;public  ECritSFT
ECritMEM:
ECritSFT:
;
ECritDisk:

;SR; Check if critical section is to be entered

	pushf
	cmp	byte [ss:redir_patch],0
	jz	short ECritDisk_2

; 06/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
;	;popff  ; * (macro)
;	jmp	short ECritDisk_1 ; *
;
;ECritDisk_iret: ; *
;	iret ; *

	; 16/12/2022
	; 13/11/2022
	;jmp	short ECritDisk_1
	; 06/11/2022
;ECritDisk_iret:
;	iret	

	; 06/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
ECritDisk_1:
	push	cs ; *
	call	ECritDisk_iret ; *		
	
ECritDisk_0:
	PUSH    AX
	;MOV	AX,8000h+critDisk
	;INT	int_IBM
	mov	ax,8001h
	int	2Ah	; Microsoft Networks - BEGIN DOS CRITICAL SECTION
			; AL = critical section number (00h-0Fh)
	POP     AX
	retn

	; 16/12/2022
	; 13/11/2022
ECritDisk_iret:  ; 12/05/2019 - Retro DOS v4.0
LCritDisk_iret: 
	iret

ECritDisk_2:
	;;popff ; *
	;;retn
;	jmp	short ECritDisk_3 ; *
;ECritDisk_iret2: ; *
;	iret
	
	; 16/12/2022
	; 13/11/2022
	;jmp	short ECritDisk_3
;ECritDisk_iret2:
	;iret

ECritDisk_3:
	push    cs ; *
	; 13/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;call	ECritDisk_iret2 ; *
	;retn
	; 16/12/2022
	call	ECritDisk_iret
	retn

;EndProc ECritDisk

; ---------------------------

;Procedure   LCritDisk,NEAR
	;public  LCritMEM
	;public  LCritSFT
LCritMEM:
LCritSFT:
;
LCritDisk:

;SR; Check if critical section is to be entered

	pushf
	cmp	byte [ss:redir_patch],0
	jz	short LCritDisk_2
	;popff  ; * (macro)
;	jmp	short LCritDisk_1 ; *
;
;LCritDisk_iret: ; *
;	iret ; *

	; 16/12/2022
	; 13/11/2022
	;jmp	short LCritDisk_1
;LCritDisk_iret:
	;iret

LCritDisk_1:
	push	cs ; *
	call	LCritDisk_iret ; *		
	
LCritDisk_0:
	PUSH	AX
	;MOV	AX,8100h+critDisk
	;INT	int_IBM
	mov	ax,8101h
	int	2Ah	; Microsoft Networks - END DOS CRITICAL SECTION
			; AL = critical section number (00h-0Fh)
	POP	AX
	retn

;LCritDisk_iret:  ; 12/05/2019 - Retro DOS v4.0 
;	iret

LCritDisk_2:
	;;popff ; *
	;;retn
;	jmp	short LCritDisk_3 ; *
;LCritDisk_iret2: ; *
;	iret

	; 16/12/2022
	; 13/11/2022
	;jmp	short LCritDisk_3
;LCritDisk_iret2:
	;iret

LCritDisk_3:
	push    cs ; *
	; 13/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;call	LCritDisk_iret2 ; *
	;retn
	; 16/12/2022
	call	LCritDisk_iret
	retn

;EndProc LCritDisk

; ---------------------------

;Procedure   ECritDevice,NEAR

ECritDevice:

;SR; Check if critical section is to be entered

	pushf
	cmp	byte [ss:redir_patch],0
	jz	short ECritDevice_2
	;popff  ; * (macro)
;	jmp	short ECritDevice_1 ; *
;
;ECritDevice_iret: ; *
;	iret ; *

	; 16/12/2022	
	; 13/11/2022
	;jmp	short ECritDevice_1
;ECritDevice_iret:
	;iret

ECritDevice_1:
	push	cs ; *
	call	ECritDevice_iret ; *		
	
ECritDevice_0:
	PUSH	AX
	;MOV	AX,8000h+critDevice
	;INT	int_IBM
	mov	ax,8002h
	int	2Ah	; Microsoft Networks - BEGIN DOS CRITICAL SECTION
			; AL = critical section number (00h-0Fh)
	POP     AX
	retn

	; 16/12/2022
	; 06/12/2022
ECritDevice_iret:  ; 12/05/2019 - Retro DOS v4.0
LCritDevice_iret: 
	iret

ECritDevice_2:
	;;popff ; *
	;;retn
;	jmp	short ECritDevice_3 ; *
;ECritDevice_iret2: ; *
;	iret

	; 16/12/2022
	; 13/11/2022
	;jmp	short ECritDevice_3
;ECritDevice_iret2:
	;iret

ECritDevice_3:
	push    cs ; *
	; 13/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;call	ECritDevice_iret2 ; *
	;retn
	; 16/12/2022
	call	ECritDevice_iret
	retn

;EndProc ECritDevice

; ---------------------------

;Procedure   LCritDevice,NEAR

LCritDevice:

;SR; Check if critical section is to be entered

	pushf
	cmp	byte [ss:redir_patch],0
	jz	short LCritDevice_2
	;popff  ; * (macro)
;	jmp	short LCritDevice_1 ; *
;
;LCritDevice_iret: ; *
;	iret ; *

	; 16/12/2022
	; 13/11/2022
	;jmp	short LCritDevice_1
;LCritDevice_iret:
	;iret

LCritDevice_1:
	push	cs ; *
	call	LCritDevice_iret ; *		
	
LCritDevice_0:
	PUSH	AX
	;MOV	AX,8100h+critDevice
	;INT	int_IBM
	mov	ax,8102h
	int	2Ah	; Microsoft Networks - END DOS CRITICAL SECTION
			; AL = critical section number (00h-0Fh)
	POP     AX
	retn

;LCritDevice_iret:  ; 12/05/2019 - Retro DOS v4.0 
;	iret

LCritDevice_2:
	;;popff ; *
	;;retn
;	jmp	short LCritDevice_3 ; *
;LCritDevice_iret2: ; *
;	iret

	; 16/12/2022
	; 13/11/2022
	;jmp	short LCritDevice_3
;LCritDevice_iret2:
	;iret

LCritDevice_3:
	push    cs ; *
	; 13/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;call	LCritDevice_iret2 ; *
	;retn
	; 16/12/2022
	call	LCritDevice_iret
	retn

;EndProc LCritDevice

;============================================================================
; CPMIO.ASM, MSDOS 6.0, 1991
;============================================================================
; 20/07/2018 - Retro DOS v3.0

;============================================================================
; STDIO.ASM - (MSDOS 2.0)
;============================================================================

;
; Standard device IO for MSDOS (first 12 function calls)
;

;.xlist
;.xcref
;INCLUDE STDSW.ASM
;INCLUDE DOSSEG.ASM
;.cref
;.list

;TITLE   STDIO - device IO for MSDOS
;NAME    STDIO

;INCLUDE IO.ASM

; ---------------------------------------------------------------------------
;
; NOTE for Retro DOS v2.0 :  (ERDOGAN TAN - 13/03/2018)
;	  I0.ASM is missing in MSDOS 2.0 kernel source code files !!!
;	  INSTEAD of IO.ASM, I have disassembled IBMDOS.COM (MSDOS 2.0)
;			    and I have used CPMIO.ASM (MSDOS 6.0 source code)
;			    to restore MSDOS 2.0 device IO source code 
;
;		(STRIN.ASM has '$STD_CON_STRING_INPUT' code.)	
	
;============================================================================
; STDIO.ASM - (MSDOS 2.0)
;============================================================================

;
; Standard device IO for MSDOS (first 12 function calls)
;

;.xlist
;.xcref
;INCLUDE STDSW.ASM
;INCLUDE DOSSEG.ASM
;.cref
;.list

;TITLE   STDIO - device IO for MSDOS
;NAME    STDIO

;INCLUDE IO.ASM

; ---------------------------------------------------------------------------
;
; NOTE for Retro DOS v2.0 :  (ERDOGAN TAN - 13/03/2018)
;	  I0.ASM is missing in MSDOS 2.0 kernel source code files !!!
;	  INSTEAD of IO.ASM, I have disassembled IBMDOS.COM (MSDOS 2.0)
;			    and I have used CPMIO.ASM (MSDOS 6.0 source code)
;			    to restore MSDOS 2.0 device IO source code 
;
;		(STRIN.ASM has '$STD_CON_STRING_INPUT' code.)		
;
;============================================================================
; IO.ASM (MSDOS 2.0) (IBMDOS.COM 2.0) - STRIN.ASM (MSDOS 2.0, 19/08/1983)
;============================================================================
; Retro DOS v2.0 by Erdogan Tan, 13/03/2018 - 14/03/2018

; (Disassembled code of IBMDOS.COM, 08/03/1983) - Dissassembler: IDA Pro Free
; (Comments are from CPMIO.ASM - 1991, MSDOS 6.0) 

;============================================================================
; CPMIO.ASM (MSDOS 6.0, 1991)
;============================================================================
; Retro DOS v4.0 by Erdogan Tan, 04/05/2019

	; 08/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)

;**	Standard device IO for MSDOS (first 12 function calls)
;
;	TITLE	IBMCPMIO - device IO for MSDOS
;	NAME	IBMCPMIO

;	Old style CP/M 1-12 system calls to talk to reserved devices
;
;	$Std_Con_Input_No_Echo
;	$Std_Con_String_Output
;	$Std_Con_String_Input
;	$RawConIO
;	$RawConInput
;	RAWOUT
;	RAWOUT2
;

; The following routines form the console I/O group (funcs 1,2,6,7,8,9,10,11).
; They assume ES and DS NOTHING, while not strictly correct, this forces data
; references to be SS or CS relative which is desired.

; ---------------------------------------------------------------------------

;	TITLE	CPMIO2 - device IO for MSDOS
;	NAME	CPMIO2

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	Old style CP/M 1-12 system calls to talk to reserved devices
;
;	$Std_Con_Input
;	$Std_Con_Output
;	OUTT
;	TAB
;	BUFOUT
;	$Std_Aux_Input
;	$Std_Aux_Output
;	$Std_Printer_Output
;	$Std_Con_Input_Status
;	$Std_Con_Input_Flush
;
;	Revision History:
;
;	  AN000	 version 4.00 - Jan. 1988

; The following routines form the console I/O group (funcs 1,2,6,7,8,9,10,11).
; They assume ES and DS NOTHING, while not strictly correct, this forces data
; references to be SS or CS relative which is desired.

;DOSCODE SEGMENT
;	ASSUME	SS:DOSDATA,CS:DOSCODE


;hkn; 	All the variables use SS override or DS. Therefore there is
;hkn;	no need to specifically set up any seg regs unless SS assumption is
;hkn;	not valid. 

; DOSCODE:51BAh (MSDOS 6.21, MSDOS.SYS)
; 08/11/2022
; DOSCODE:51A6h (MSDOS 5.0, MSDOS.SYS)

;
;----------------------------------------------------------------------------
;
; Procedure : $Std_Con_Input_No_Echo
;
;----------------------------------------------------------------------------
;

_$STD_CON_INPUT_NO_ECHO:   ;System call 8

; Inputs:
;	None
; Function:
;	Input character from console, no echo
; Returns:
;	AL = character

	push	ds
	push	si
INTEST:
	call	STATCHK
	jnz	short GET ; 08/09/2018
;*************************************************************************
;hkn; SS override
	cmp	byte [SS:PRINTER_FLAG],0  ; is printer idle?
	jnz	short no_sys_wait
	mov	ah,5			; get input status with system wait
	call	IOFUNC
no_sys_wait:
;**************************************************************************
	MOV	AH,84h
	INT	int_IBM	 ; int 2Ah

;;; 7/15/86  update the date in the idle loop
;;; Dec 19, 1986 D.C.L. changed following CMP to Byte Ptr from Word Ptr
;;;;		 to shorten loop in consideration of the PC Convertible

;hkn; SS override
	CMP	byte [SS:DATE_FLAG],-1	; date is updated may be every
	JNZ	short NoUpdate		; 65535 x ? ms if no one calls

	PUSH	AX
	PUSH	BX			; following is tricky,
	PUSH	CX			; it may be called by critical handler
	PUSH	DX			; at that time, DEVCALL is used by
					; other's READ or WRITE
	PUSH	DS			; save DS = SFT's segment

;hkn; READTIME must use ds = DOSDATA
;hkn;	PUSH	CS			; READTIME must use DS=CS

	PUSH	SS ; 04/05/2019
	POP	DS

	MOV	AX,0			; therefore, we save DEVCALL
	CALL	Save_Restore_Packet	; save DEVCALL packet
	;invoke	READTIME		; readtime
	call	READTIME
	MOV	AX,1
	CALL	Save_Restore_Packet	; restore DEVCALL packet

;	; MSDOS 3.3 (IBMDOS.COM, Offset 1F8Ch)
;	; (MSDOS 6.0 code does not contain IBM DOS FETCHI_TAG check)
;	push	bx
;	mov	bx,DATE_FLAG
;	add	bx,2  ; mov bx,FETCHI_FLAG
;	cmp	word [cs:bx],5872h
;	jz	short FETCHI_TAG_chk_ok
;	call	DOSINIT
;FETCHI_TAG_chk_ok:
;	pop	bx

	POP	DS			; restore DS
	POP	DX
	POP	CX
	POP	BX
	POP	AX
NoUpdate:

;hkn; SS override
	INC	word [SS:DATE_FLAG]

;;; 7/15/86 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	JMP	short INTEST
GET:
	XOR	AH,AH
	call	IOFUNC
	POP	SI
	POP	DS
;;; 7/15/86

;hkn; SS override
	; MSDOS 6.0
	MOV	BYTE [SS:SCAN_FLAG],0
	;
	CMP	AL,0	    ; extended code ( AL )
	JNZ	short noscan

;hkn; SS override
	;MOV	BYTE [SS:SCAN_FLAG],1 ; set this flag for ALT_Q key
	; 20/06/2023
	inc	byte [SS:SCAN_FLAG]
noscan:
	retn
;
;----------------------------------------------------------------------------
;
;**	$STD_CON_STRING_OUTPUT - Console String Output
;
;
;	ENTRY	(DS:DX) Point to output string '$' terminated
;	EXIT	none
;	USES	ALL
;
;----------------------------------------------------------------------------
;

_$STD_CON_STRING_OUTPUT:	;System call 9

	mov	si,dx
STRING_OUT1:	
	lodsb
	cmp	al,'$'
	je	short noscan
NEXT_STR1:
	call	OUTT
	jmp	short STRING_OUT1

;----------------------------------------------------------------------------
;
;**	$STD_CON_STRING_INPUT - Input Line from Console
;
;	$STD_CON_STRING_INPUT Fills a buffer from console input until CR
;
;	ENTRY	(ds:dx) = input buffer
;	EXIT	none
;	USES	ALL
;
;----------------------------------------------------------------------------

	; 15/01/2024

_$STD_CON_STRING_INPUT:		;System call 10

	; 15/01/2024
	;mov	ax,ss
	;mov	es,ax
	push	ss
	pop	es

	mov	si,dx
	xor	ch,ch
	lodsw

;	(AL) = the buffer length
;	(AH) = the template length

        or	al,al
        jz	short noscan	;Buffer is 0 length!!?
	mov	bl,ah		;Init template counter
        mov	bh,ch		;Init template counter

;	(BL) = the number of bytes in the template

        cmp	al,bl
        jbe	short NOEDIT	;If length of buffer inconsistent with contents
        cmp	byte [bx+si],c_CR ; 0Dh
        jz	short EDITON	;If CR correctly placed EDIT is OK

; The number of chars in the template is >= the number of chars in buffer or
; there is no CR at the end of the template. This is an inconsistant state
; of affairs. Pretend that the template was empty:
;

NOEDIT:	
	mov	bl,ch		;Reset buffer
EDITON: 
	mov	dl,al
	dec	dx		;DL is # of bytes we can put in the buffer

;	Top level. We begin to read a line in.

NEWLIN: 
	mov	al,[SS:CARPOS]
	mov	[SS:STARTPOS],al ;Remember position in raw buffer

	push	si
	mov	di,INBUF ;Build the new line here
	mov	byte [SS:INSMODE],ch ;Insert mode off
	mov	bh,ch		;No chars from template yet
	mov	dh,ch		;No chars to new line yet
	call	_$STD_CON_INPUT_NO_ECHO ;Get first char
	cmp	al,c_LF		; 0Ah	;Linefeed 
	jnz	short GOTCH

;	This is the main loop of reading in a character and processing it.
;
;	(BH) = the index of the next byte in the template
;	(BL) = the length of the template
;	(DH) = the number of bytes in the buffer
;	(DL) = the length of the buffer

GETCH:
	call	_$STD_CON_INPUT_NO_ECHO
GOTCH:
;
; Brain-damaged Tim Patterson ignored ^F in case his BIOS did not flush the
; input queue.
;
        cmp	al,"F"-"@"  ; CMP AL, 6  ; Ignore ^F
	jz	short GETCH

;	If the leading char is the function-key lead byte

	;cmp	al,[SS:ESCCHAR]

	; 04/05/2019 - Retro DOS v4.0

;hkn; 	ESCCHAR is in TABLE seg (DOSCODE)

	CMP	AL,[cs:ESCCHAR]
        jz	short ESCAPE	;change reserved keyword DBM 5-7-87

;	Rubout and ^H are both destructive backspaces.

        cmp	al,c_DEL ; 7FH
        ;jz	short BACKSPJ
        ; 15/01/2024
	je	short BACKSP
	cmp	al,c_BS  ; 8
        ;jz	short BACKSPJ
        ; 15/01/2024
	je	short BACKSP

	; 04/05/2019 -	MSDOS 6.0, also MSDOS 6.21 has bug (bullshit) here. 
	;		Two NOPs -instead of a JMP short, as two bytes-
	;	   	after CMP and a CMP again!
	;		
	;		-It would be better if they use a 'JMP short' to 
	;	      	DOSCODE:5279h from DOSCODE:5271h and leave NOPs
	;		between them. Then, they would be able use a patch
	;		between 5271h and 5279h when if it will be required.
	;		I think Tim Patterson would not do this CMP mistake!-
	;	
	; (MSDOS.SYS, from DOSCODE:5271h to DOSCODE:5279h)

	; 08/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	;
	; (Note: nops below might be used for patching code for Windows 3.1)

;DOSCODE:526D	cmp     al, 8
;DOSCODE:526F	jz      short BACKSPJ
;DOSCODE:5271	cmp     al, 17h
;DOSCODE:5273	nop
;DOSCODE:5274	nop
;DOSCODE:5275	cmp     al, 15h
;DOSCODE:5277	nop
;DOSCODE:5278	nop
;DOSCODE:5279	cmp     al, 0Dh
;DOSCODE:527B	jz      short ENDLIN
;DOSCODE:527D	cmp     al, 0Ah
;DOSCODE:527F	jz      short PHYCRLF
	
	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	; DOSCODE:525Dh

; 16/12/2022
%if 0
	; MSDOS 6.0
;	^W deletes backward once and then backs up until a letter is before the
;	cursor

	CMP     AL,"W"-"@" ; 17h

;	The removal of the comment characters before the jump statement will
;	cause ^W to backup a word.

;***	JZ	short WordDel
	NOP
	NOP

	CMP     AL,"U"-"@" ; 15h

;	The removal of the comment characters before the jump statement will
;	cause ^U to clear a line.

;***	JZ	short LineDel
	NOP
	NOP

%endif

;	CR terminates the line.

        cmp	al,c_CR ; 0Dh
        jz	short ENDLIN

;	LF goes to a new line and keeps on reading.

        cmp	al,c_LF ; 0Ah
	jz	short PHYCRLF

;	^X (or ESC) deletes the line and starts over

	; MSDOS 3.3
	;cmp	al,[ss:CANCHAR] ; 1Bh
	;jz	short KILNEW

	; MSDOS 6.0 (& MSDOS 6.21)

;hkn; 	CANCHAR is in TABLE seg (DOSCODE), so CS override

	cmp	al,[cs:CANCHAR] ; 1Bh
	jz	short KILNEW
	
	;cmp	al,CANCEL ; 1Bh	; Retro DOS v3.0
	;jz	short KILNEW

; Otherwise, we save the input character.

SAVCH:	
	cmp	dh,dl
	jnb	short BUFFUL		; buffer is full.
        stosb
	inc	dh                      ; increment count in buffer.
	call	BUFOUT			; Print control chars nicely

        cmp	byte [SS:INSMODE], 0
	jnz	short GETCH		; insertmode => don't advance template
        cmp	bh,bl
        jnb	short GETCH		; no more characters in template
        inc	si                      ; Skip to next char in template
        inc	bh                      ; remember position in template
        jmp	short GETCH

	; 15/01/2024
;BACKSPJ: 
	;jmp	short BACKSP

BUFFUL: 
	mov	al, 7			; Bell to signal full buffer
	call	OUTT
	jmp	short GETCH

ESCAPE: 
	;transfer OEMFunctionKey
	JMP	OEMFunctionKey		; let the OEM's handle the key dispatch

ENDLIN:
        stosb				; Put the CR in the buffer
	call	OUTT                    ; Echo it
        pop	di                      ; Get start of user buffer
        mov	[di-1], dh		; Tell user how many bytes
        inc	dh			; DH is length including CR

COPYNEW:
	; (IBMDOS.COM, MSDOS 2.0, STRIN.ASM)
	;mov	bp, es
	;mov	bx, ds
	;mov	es, bx
	;mov	ds, bp
	;mov	si, INBUF
	;mov	cl, dh
	;rep	movsb
	;retn

	; CPMIO.ASM (MSDOS 6.0)
	; (IBMDOS.COM, MSDOS 3.3, Offset 2061h) 
	;SAVE	<DS,ES>
	PUSH	DS
	PUSH	ES
	;RESTORE <DS,ES>		; XCHG ES,DS
	POP	DS
	POP	ES

;;hkn; INBUF is in DOSDATA
        MOV     SI,INBUF
        MOV     CL,DH                   ; set up count
        REP     MOVSB                   ; Copy final line to user buffer
OLDBAK_RETN:
        RETN

;	Output a CRLF to the user screen and do NOT store it into the buffer

PHYCRLF:
	CALL	CRLF
        JMP	short GETCH

	; MSDOS 6.0 (& MSDOS 3.3, IBMDOS.COM, 1987)

; DOSCODE:52CAh (MSDOS 621, MSDOS.SYS)

	; Note: Following routines were not used in IBMDOS.COM
	;	-CRTL+W, CRTL+U is not activated-
	;	but they were in the kernel code!?)

	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	; DOSCODE:52B6h

;;;;;;;;

; 16/12/2022
%if 0
;
; Delete the previous line
;
LineDel:
	OR      DH,DH
	JZ	short GETCH	 ; 06/12/2022
	Call    BackSpace
	JMP	short LineDel

%endif

;
; delete the previous word.
;
WordDel:
WordLoop:
;	Call    BackSpace               ; backspace the one spot
;	OR      DH,DH
;	JZ	short GetChj
;	MOV     AL,[ES:DI-1]
;	cmp     al,'0'
;	jb	short GetChj
;	cmp     al,'9'
;	jbe	short WordLoop
;	OR      AL,20h
;	CMP     AL,'a'
;	JB	short GetChj
;	CMP     AL,'z'
;	JBE	short WordLoop
;GetChj: 
;	JMP	GETCH

; 16/12/2022
%if 0
	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	; (Worddel is not called or jumped from anywhere!)
WordDel:
WordLoop:
	Call    BackSpace               ; backspace the one spot
	OR      DH,DH
	JZ	short GetChj
	MOV     AL,[ES:DI-1]
	cmp     al,'0'
	jb	short GetChj
	cmp     al,'9'
	jbe	short WordLoop
	OR      AL,20h
	CMP     AL,'a'
	JB	short GetChj
	CMP     AL,'z'
	JBE	short WordLoop
GetChj: 
	JMP	GETCH

%endif

;;;;;;;;

; DOSCODE:52F3h (MSDOS 621, MSDOS.SYS)

; The user wants to throw away what he's typed in and wants to start over.
; We print the backslash and then go to the next line and tab to the correct
; spot to begin the buffered input.

KILNEW:
        mov	al,'\'
        call	OUTT            ;Print the CANCEL indicator
        pop	si		;Remember start of edit buffer
PUTNEW:
	call	CRLF            ;Go to next line on screen
	mov	al,[SS:STARTPOS]
	call	TAB             ;Tab over
        JMP     NEWLIN		;Start over again

;	Destructively back up one character position

BACKSP:
	; 09/09/2018
	Call    BackSpace
	JMP     short GETCH	; 15/01/2024

	; 15/01/2024
;User really wants an ESC character in his line
TWOESC:	
	mov	al,[cs:ESCCHAR] ; 10/06/2019
	jmp	short SAVCH

BackSpace:
	or	dh,dh
	jz	short OLDBAK	;No chars in line, do nothing to line
	call	BACKUP          ;Do the backup
	mov	al,[es:di]	;Get the deleted char
        cmp	al,20h	; ' '
	jnb	short OLDBAK	;Was a normal char
        cmp	al,c_HT ; 9
	jz	short BAKTAB	;Was a tab, fix up users display
;; 9/27/86 fix for ctrl-U backspace
	CMP     AL,"U"-"@" ; 15h ; ctrl-U is a section symbol not ^U
	JZ	short OLDBAK
       	CMP     AL,"T"-"@" ; 14h ; ctrl-T is a paragraphs symbol not ^T
	JZ	short OLDBAK
;; 9/27/86 fix for ctrl-U backspace
        call	BACKMES         ;Was a control char, zap the '^'
OLDBAK:
        cmp	byte [SS:INSMODE], 0
	jnz	short OLDBAK_RETN ;In insert mode, done
	or	bh,bh
        jz	short OLDBAK_RETN 
				;Not advanced in template, stay where we are
	dec	bh		;Go back in template
        dec	si
	retn
BAKTAB:
        push	di
        dec	di		;Back up one char
        std			;Go backward
        mov	cl,dh		;Number of chars currently in line
        mov	al,20h	; ' '
        push	bx
        mov	bl,7		;Max
        jcxz	FIGTAB		;At start, do nothing
FNDPOS:
        scasb			;Look back
	jbe	short CHKCNT
	cmp	byte [es:di+1],9
	jz	short HAVTAB	;Found a tab
	dec	bl		;Back one char if non tab control char
CHKCNT:
        loop	FNDPOS
FIGTAB:		
	sub	bl,[SS:STARTPOS]
HAVTAB:
	sub	bl,dh
	add	cl,bl
	and	cl,7		;CX has correct number to erase
	cld			;Back to normal
	pop	bx
	pop	di
	jz	short OLDBAK	;Nothing to erase
TABBAK:
	call	BACKMES
	loop	TABBAK		;Erase correct number of chars
	jmp	short OLDBAK

BACKUP:
        dec	dh		;Back up in line
        dec	di
BACKMES:
        mov	al,c_BS ; 8	;Backspace
        call	OUTT
        mov	al,20h ; ' '	;Erase
        call	OUTT
        mov	al,c_BS ; 8	;Backspace
	jmp	OUTT		;Done

	; 15/01/2024
;User really wants an ESC character in his line
;TWOESC:	
;	mov	al,[cs:ESCCHAR] ; 10/06/2019
;	jmp	SAVCH

;Copy the rest of the template
COPYLIN:
        mov	cl,bl		;Total size of template
	sub	cl,bh		;Minus position in template, is number to move
        jmp	short COPYEACH

COPYSTR:
	call	FINDOLD         ;Find the char
	jmp	short COPYEACH  ;Copy up to it

;Copy one char from template to line
COPYONE:
        mov	cl,1
;Copy CX chars from template to line
COPYEACH:
        mov	byte [SS:INSMODE],0	;All copies turn off insert mode
	cmp	dh,dl
        jz	short GETCH2		;At end of line, can't do anything
        cmp	bh,bl
        jz	short GETCH2		;At end of template, can't do anything
        lodsb
        stosb
	call	BUFOUT
        inc	bh			;Ahead in template
        inc	dh			;Ahead in line
        loop	COPYEACH
GETCH2:
        jmp	GETCH

;Skip one char in template
SKIPONE:
	cmp	bh,bl
	jz	short GETCH2		;At end of template
	inc	bh			;Ahead in template
	inc	si
        ;jmp	GETCH
	; 15/01/2024
	jmp	short GETCH2

SKIPSTR:
	call	FINDOLD                 ;Find out how far to go
        add	si,cx			;Go there
        add	bh,cl
        ;jmp	GETCH
	; 15/01/2024
	jmp	short GETCH2

;Get the next user char, and look ahead in template for a match
;CX indicates how many chars to skip to get there on output
;NOTE: WARNING: If the operation cannot be done, the return
;       address is popped off and a jump to GETCH is taken.
;       Make sure nothing extra on stack when this routine
;       is called!!! (no PUSHes before calling it).

FINDOLD:
        call	_$STD_CON_INPUT_NO_ECHO

	; STRIN.ASM (MSDOS 2.11, 19/07/2018) 

	;CMP	AL,[SS:ESCCHAR]	
	;JNZ	SHORT FINDSETUP

	; CPMIO.ASM (MSDOS 6.0, 04/05/2019 - Retro DOS v4.0)

;hkn; ESCCHAR is in TABLE seg (DOSCODE), so CS override

	CMP	AL,[CS:ESCCHAR]		; did he type a function key?
	JNZ	SHORT FINDSETUP		; no, set up for scan

	CALL	_$STD_CON_INPUT_NO_ECHO	; eat next char
        JMP	SHORT NOTFND		; go try again
FINDSETUP:
	mov	cl,bl
        sub	cl,bh		;CX is number of chars to end of template
	jz	short NOTFND	;At end of template
        dec	cx		;Cannot point past end, limit search
        jz	short NOTFND	;If only one char in template, forget it
	push	es
	push	ds
	pop	es
	push	di
	mov	di,si		;Template to ES:DI
	inc	di
	repne	scasb		;Look
	pop	di
	pop	es
	jnz	short NOTFND	;Didn't find the char
        not	cl		;Turn how far to go into how far we went
        add	cl,bl		;Add size of template
        sub	cl,bh		;Subtract current pos, result distance to skip
FINDOLD_RETN:
	retn

NOTFND:
	pop	bp              ;Chuck return address
	;jmp	GETCH
	; 15/01/2024
GETCH2_j:
	jmp	short GETCH2

REEDIT:
	mov	al,'@'		;Output re-edit character
	call	OUTT
	pop	di
	push	di
	push	es
	push	ds
	call	COPYNEW		;Copy current line into template
	pop	ds
	pop	es
	pop	si
	mov	bl,dh		;Size of line is new size template
	jmp	PUTNEW		;Start over again

EXITINS:
ENTERINS:
	not	byte [SS:INSMODE]
	;jmp	GETCH
	; 15/01/2024
	jmp	short GETCH2_j

;Put a real live ^Z in the buffer (embedded)
CTRLZ:
	mov	al,"Z"-"@" ; 1Ah
        jmp	SAVCH

;Output a CRLF
CRLF:
	mov	al,c_CR ; 0Dh 
	call	OUTT
	mov	al,c_LF ; 0Ah
	jmp	OUTT

;
;----------------------------------------------------------------------------
;
;**	$RAW_CON_IO - Do Raw Console I/O
;
;	Input or output raw character from console, no echo
;
;	ENTRY	DL = -1 if input
;		   =  output character if output
;	EXIT	(AL) = input character if input
;	USES	all
;
;----------------------------------------------------------------------------
; 20/07/2018 - Retro DOS v3.0

; 04/05/2019 - Retro DOS v4.0
; DOSCODE:541Ch (MSDOS 6.21, MSDOS.SYS)

; 08/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:5408h (MSDOS 5.0, MSDOS.SYS)

_$RAW_CON_IO:			; System call 6
	MOV	AL,DL
	CMP	AL,-1
	JNZ	SHORT RAWOUT ; 16/12/2022
	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;jz	short rci1
	;jmp	short RAWOUT
	; 16/12/202
	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;nop
rci1:
			; Get pointer to register save area
	LES	DI,[SS:USER_SP] ; 12/03/2018
	XOR	BX,BX
    	;CALL	GET_IO_FCB	; MSDOS 2.11 (Retro DOS v2.0)
	CALL	GET_IO_SFT	; MSDOS 3.3 & MSDOS 6.0
        ;JC	SHORT RET17
        jc	short FINDOLD_RETN
	MOV	AH,1
	CALL	IOFUNC
	JNZ	SHORT RESFLG
	CALL	SPOOLINT
	;OR	BYTE [ES:DI+16H],40H
	OR	BYTE [ES:DI+user_env.user_F],40H ; Set user's zero flag
	XOR	AL,AL
RET17:
	RETN

RESFLG:
	;AND	BYTE [ES:DI+16H],0FFH-40H  ; 0BFh
	AND	BYTE [ES:DI+user_env.user_F],0FFH-40H
				; Reset user's zero flag
;RILP:
rci0:
	CALL	SPOOLINT
;
;----------------------------------------------------------------------------
;
;**	$Raw_CON_INPUT - Raw Console Input
;
;	Input raw character from console, no echo
;
;	ENTRY	none
;	EXIT	(al) = character
;	USES	all
;
;----------------------------------------------------------------------------
;

;rci0:	invoke	SPOOLINT

	;entry	$RAW_CON_INPUT

	; 04/05/2019 - Retro DOS v4.0

; DOSCODE:544Bh (MSDOS 6.21, MSDOS.SYS)

_$RAW_CON_INPUT:		; System call 7
	push	bx
	XOR	BX,BX
	;CALL	GET_IO_FCB	; MSDOS 2.11 (Retro DOS v2.0)
	CALL	GET_IO_SFT	; MSDOS 3.3 & MSDOS 6.0
	pop	bx
	JC	SHORT RET17
	MOV	AH,1
	CALL	IOFUNC
	;JZ	SHORT RILP	; MSDOS 2.11
	;XOR	AH,AH
        ;CALL	IOFUNC
        ;RETN
	jnz	short rci5	; MSDOS 3.3 & MSDOS 6.0
	MOV	AH,84h
	INT	int_IBM  ; int 2Ah
	JMP	short rci0
rci5:	
	XOR	AH,AH
	;CALL	IOFUNC
	;RETN
	; 18/12/2022
	jmp	IOFUNC

;       Output the character in AL to stdout
;
	;entry	RAWOUT
RAWOUT:
	PUSH    BX
	MOV     BX,1

	;CALL	GET_IO_FCB	; MSDOS 2.11 (Retro DOS v2.0)
	CALL	GET_IO_SFT	; MSDOS 3.3 & MSDOS 6.0
	JC	SHORT RAWRET1

	;
	; MSDOS 2.11
        ;TEST	BYTE [SI+18H],080H	; output to file?
        ;JZ	SHORT RAWNORM		; if so, do normally
        ;PUSH	DS
        ;PUSH	SI
        ;LDS	SI,[SI+19H]		; output to special?
	;TEST	BYTE [SI+4],ISSPEC
	;POP	SI
	;
        
	; MSDOS 3.3 & MSDOS 6.0
	;mov	bx,[si+5]
	MOV	BX,[SI+SF_ENTRY.sf_flags] ;hkn; DS set up by get_io_sft
 ;
 ; If we are a network handle OR if we are not a local device then go do the
 ; output the hard way.
 ;	
	;and	bx,8080h
	AND	BX,sf_isnet+devid_device
	;cmp	bx,80h
	CMP	BX,devid_device
	jnz     short RAWNORM
	push    ds
	;lds	bx,[si+7]
	LDS	BX,[SI+SF_ENTRY.sf_devptr] ; output to special?
	;test	byte [bx+4],10h
	TEST	BYTE [BX+SYSDEV.ATT],ISSPEC
	;

	POP	DS
	JZ	SHORT RAWNORM		; if not, do normally

	INT	int_fastcon  ; int 29h	; quickly output the char

	;JMP	SHORT RAWRET
;RAWNORM:
;	CALL    RAWOUT3
RAWRET: 
	CLC
RAWRET1:
	POP     BX
RAWRET2:
	RETN
RAWNORM:
	CALL    RAWOUT3
	jmp	short RAWRET

;	Output the character in AL to handle in BX
;
;	entry	RAWOUT2

RAWOUT2:
	;CALL	GET_IO_FCB	; MSDOS 2.11 (Retro DOS v2.0)
	;JC	SHORT RET18
	CALL	GET_IO_SFT	; MSDOS 3.3 & MSDOS 6.0
	JC	SHORT RAWRET2
RAWOUT3:
	PUSH	AX
	JMP	SHORT RAWOSTRT
ROLP:
	CALL	SPOOLINT

	; 01/05/2019 - Retro DOS v4.0

	; MSDOS 6.0
	;OR	word [ss:DOS34_FLAG],CTRL_BREAK_FLAG ; 001000000000b
	; 17/12/2022
	or	byte [ss:DOS34_FLAG+1],(CTRL_BREAK_FLAG>>8) ; 02h
	;or	word [ss:DOS34_FLAG],200h
				;AN002; set control break
	;invoke DSKSTATCHK
	call	DSKSTATCHK	;AN002; check control break
RAWOSTRT:
	MOV	AH,3
	CALL	IOFUNC
	JZ	SHORT ROLP

	; MSDOS 6.0
;SR;
; IOFUNC now returns ax = 0ffffh if there was an I24 on a status call and
;the user failed. We do not send a char if this happens. We however return
;to the caller with carry clear because this DOS call does not return any
;status. 
;
	inc	ax		;fail on I24 if ax = -1
	POP	AX
	jz	short nosend	;yes, do not send char
	MOV	AH,2
	call	IOFUNC
nosend:
	CLC			; Clear carry indicating successful
	retn

	; MSDOS 3.3 & MSDOS 2.11
	;POP	AX
	;MOV	AH,2
        ;CALL	IOFUNC
	;CLC			; Clear carry indicating successful
;RET18:    
	;RETN

;;10/08/2018
; 20/07/2018 - Retro DOS v3.0
; ---------------------------------------------------------------------------
; Retro DOS v2.0 (MSDOS 2.11) - OUTMES
; ---------------------------------------------------------------------------

; This routine is called at DOS init

;;	;procedure OUTMES,NEAR ; String output for internal messages
;;OUTMES:
;;	;LODS	CS:BYTE PTR [SI]
;;	CS	LODSB
;;	CMP     AL,"$" ; 24h
;;	JZ	SHORT RET18
;;	CALL	OUTT
;;	JMP     SHORT OUTMES

; ---------------------------------------------------------------------------

; 20/07/2018 - Retro DOS v3.0

; IBMDOS.COM (MSDOS 3.3 kernel) - Offset 2252h

;
;----------------------------------------------------------------------------
;
; Inputs:
;	AX=0 save the DEVCALL request packet
;	  =1 restore the DEVCALL request packet
; Function:
;	save or restore the DEVCALL packet
; Returns:
;	none
;
;----------------------------------------------------------------------------
;

; 04/05/2019 - Retro DOS v4.0
; DOSCODE:54B9h (MSDOS 6.21, MSDOS.SYS)

; 08/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:54A5h (MSDOS 5.0, MSDOS.SYS)

; 12/05/2019

	; 15/01/2024

Save_Restore_Packet:
	PUSH	DS
	PUSH	ES
	PUSH	SI
	PUSH	DI

	; 16/12/2022
	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	; 09/09/2018
	mov	di,FAKE_STACK_2F
	mov	si,DEVCALL
	mov	si,DEVCALL
	;
	; 21/09/2023
	or	ax,ax 
	;CMP	AX,0		; save packet
	JZ	short save_packet ; 16/12/2022
	;je	short set_seg

	; MSDOS 6.0
restore_packet:
;	MOV	SI,OFFSET DOSDATA:Packet_Temp	;source
;	MOV	DI,OFFSET DOSDATA:DEVCALL	;destination
	; MSDOS 3.3
	;mov	si,FAKE_STACK_2F ; DOS_TEMP ; Packed_Temp 
	;mov	di,DEVCALL  ; 09/09/2018
	;
	;JMP	short set_seg

	; 16/12/2022	
	; 09/09/2018
	xchg	si,di  ; DI = offset DEVCALL, SI = offset FAKE_STACK_2F

; 16/12/2022
%if 0
	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	cmp	ax,0		; save packet
	jz	short save_packet
	mov	si,FAKE_STACK_2F ; 07/12/2022
	mov	di,DEVCALL 
	jmp	short set_seg

	; MSDOS 6.0
save_packet:
;	MOV	DI,OFFSET DOSDATA:Packet_Temp	;destination
;	MOV	SI,OFFSET DOSDATA:DEVCALL	;source
	; 09/09/2018
	; MSDOS 3.3
	;mov	di,FAKE_STACK_2F ; DOS_TEMP ; Packed_Temp 
	;mov	si,DEVCALL ; 09/09/2018

	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	mov	di,FAKE_STACK_2F ; DOS_TEMP ; Packed_Temp 
	mov	si,DEVCALL
%endif

; 15/01/2024
; 16/12/2022
save_packet:
;set_seg:
	; MSDOS 3.3
	;mov	ax,cs

	; MSDOS 6.0
	;MOV	AX,SS		; set DS,ES to DOSDATA
	;MOV	DS,AX
	;MOV	ES,AX
	; 15/01/2024
	push	ss
	pop	ds
	push	ds
	pop	es

	MOV	CX,11		; 11 words to move
	REP	MOVSW

	POP	DI
	POP	SI
	POP	ES
	POP	DS
	retn

;============================================================================
; CPMIO2.ASM, MSDOS 6.0, 1991
;============================================================================
; 20/07/2018 - Retro DOS v3.0
; 01/05/2019 - Retro DOS v4.0

;hkn; 	All the variables use SS override or DS. Therefore there is
;hkn;	no need to specifically set up any seg regs unless SS assumption is
;hkn;	not valid. 

;
;----------------------------------------------------------------------------
;
;**	$STD_CON_INPUT - System Call 1
;
;	Input character from console, echo
;
;	ENTRY	none
;	EXIT	(al) = character
;	USES	ALL
;
;----------------------------------------------------------------------------
;

_$STD_CON_INPUT:	;System call 1
	
	CALL	_$STD_CON_INPUT_NO_ECHO
	PUSH	AX
	CALL	OUTT
	POP	AX
CON_INPUT_RETN:	
	RETN

;
;----------------------------------------------------------------------------
;
;**	$STD_CON_OUTPUT - System Call 2
;
;	Output character to console
;
;	ENTRY	(dl) = character
;	EXIT	none
;	USES	all
;
;----------------------------------------------------------------------------
;

; DOSCODE:54E9h (MSDOS 6.21, MSDOS.SYS)

; 08/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:54D5h (MSDOS 5.0, MSDOS.SYS)

_$STD_CON_OUTPUT:	;System call 2

	MOV	AL,DL
OUTT:
	CMP	AL,20H ; " "
	JB	SHORT CTRLOUT
	CMP	AL,c_DEL ; 7Fh
	JZ	SHORT OUTCH
OUTCHA:	
	;INC	BYTE PTR [CARPOS]
	INC	BYTE [SS:CARPOS]
OUTCH:
	PUSH	DS
	PUSH	SI
	;INC	BYTE PTR [CHARCO]		;invoke statchk...
	;AND	BYTE PTR [CHARCO],00111111B	;AN000; every 64th char
	INC	BYTE [SS:CHARCO]	
	;AND	BYTE [SS:CHARCO],00111111B
	; 01/05/2019 - Retro DOS v4.0
	and	byte [SS:CHARCO],3Fh
	JNZ	SHORT OUTSKIP

	PUSH	AX
	CALL	STATCHK
	POP	AX
OUTSKIP:
	CALL	RAWOUT				;output the character

	POP	SI
	POP	DS

	;TEST	BYTE PTR [PFLAG],-1
	;retz
	TEST	BYTE [SS:PFLAG],0FFh
	JZ	SHORT CON_INPUT_RETN

	PUSH	BX
	PUSH	DS
	PUSH	SI
	MOV	BX,1
	; 20/07/2018 - Retro DOS v3.0
	; MSDOS 3.3
	; MSDOS 6.0 (CPMIO2.ASM)
	CALL	GET_IO_SFT		;hkn; GET_IO_SFT will set up DS:SI
					;hkn; to sft entry
	JC	SHORT TRIPOPJ

	; 01/05/2019 - Retro DOS v4.0

	;mov	bx,[si+5]
	MOV	BX,[SI+SF_ENTRY.sf_flags]
	;test	bx,8000h
	;TEST	BX,sf_isnet	; 8000h		; output to NET?
	test	bh,(sf_isnet>>8) ; 80h
	JNZ	short TRIPOPJ 			; if so, no echo
	;;test	bx,80h
	;TEST	BX,devid_device 		; output to file?
	test	bl,devid_device ; 80h
	JZ	SHORT TRIPOPJ 			; if so, no echo
	; 14/03/2018
	;call	GET_IO_FCB	 	; IBMDOS.COM, MSDOS 2.11
	;jc	short TRIPOPJ
	; MSDOS 2.11
	;test	byte [SI+18H], 80h
	;jz	short TRIPOPJ
	MOV	BX,4
	CALL	GET_IO_SFT
	JC	SHORT TRIPOPJ
	;;test	word [si+5], 800h
	;TEST	word [SI+SF_ENTRY.sf_flags],sf_net_spool ; 800H
	;test	byte [si+6],8 ; 08/11/2022
	test	byte [SI+SF_ENTRY.sf_flags+1],(sf_net_spool>>8) ; 8 
						; StdPrn redirected?
	;;JZ	SHORT LISSTRT2J			; No, OK to echo
	;jz	LISSTRT2 ; 10/08/2018 
	; 16/12/2022
	jnz	short outch1
	jmp	LISSTRT2
	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;jz	short LISSTRT2J
outch1:
	;MOV	BYTE [PFLAG],0
	MOV	BYTE [SS:PFLAG],0		; If a spool, NEVER echo
	; MSDOS 2.11
	;mov	bx,4
	;jmp	short LISSTRT2
	
TRIPOPJ:
	; 20/07/2018
	JMP	TRIPOP

	; 16/12/2022
	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
;LISSTRT2J:
;	JMP	LISSTRT2

CTRLOUT:
	CMP	AL,c_CR ; 0Dh
	JZ	SHORT ZERPOS
	CMP	AL,c_BS ; 8
	JZ	SHORT BACKPOS
	CMP	AL,c_HT ; 9
	JNZ	SHORT OUTCH
	;MOV	AL,[CARPOS]
	MOV	AL,[SS:CARPOS]
	OR	AL,0F8H
	NEG	AL
TAB:
	PUSH	CX
	MOV	CL,AL
	MOV	CH,0
	JCXZ	POPTAB
TABLP:
	MOV	AL," "
	CALL	OUTT
	LOOP	TABLP
POPTAB:
	POP	CX

	RETN

ZERPOS:
	;MOV	BYTE PTR [CARPOS],0
	MOV	BYTE [SS:CARPOS],0
	; 10/08/2018
	JMP	short OUTCH ; 04/05/2019
	
	; 18/12/2022
;OUTJ:	
	;JMP	OUTT

BACKPOS:
	;DEC	BYTE PTR [CARPOS]
	DEC	BYTE [SS:CARPOS]
	JMP	OUTCH

BUFOUT:
	CMP	AL," "
	JAE	SHORT OUTJ		;Normal char
	CMP	AL,9
	JZ	SHORT OUTJ		;OUT knows how to expand tabs
	;DOS 3.3  7/14/86
	CMP	AL,"U"-"@" ; 15h	; turn ^U to section symbol
	JZ	short CTRLU
	CMP	AL,"T"-"@" ; 14h	; turn ^T to paragraph symbol
	JZ	short CTRLU
NOT_CTRLU:
	;DOS 3.3  7/14/86
	PUSH	AX
	MOV	AL,"^"
	CALL	OUTT		;Print '^' before control chars
	POP	AX
	OR	AL,40H		;Turn it into Upper case mate
CTRLU:
	;CALL	OUTT
	; 18/12/2022
OUTJ:
	jmp	OUTT
;BUFOUT_RETN:
	;RETN

;
;----------------------------------------------------------------------------
;
;**	$STD_AUX_INPUT - System Call 3
;
;	$STD_AUX_INPUT returns a character from Aux Input
;
;	ENTRY	none
;	EXIT	(al) = character
;	USES	all
;
;----------------------------------------------------------------------------
;

	; 08/11/2022 Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)

_$STD_AUX_INPUT:	;System call 3

	CALL	STATCHK
	MOV	BX,3
	CALL	GET_IO_SFT	; 20/07/2018 - MSDOS 3.3 (MSDOS 6.0)
	;CALL	GET_IO_FCB	; 14/03/2018 - MSDOS 2.11
	;retc
	; 16/12/2022
	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;JC	SHORT BUFOUT_RETN
	;JMP	SHORT TAISTRT
	; 07/12/2022
	jnc	SHORT TAISTRT
	retn	

AUXILP:
	CALL	SPOOLINT
TAISTRT:
	MOV	AH,1
	CALL	IOFUNC
	JZ	SHORT AUXILP
	XOR	AH,AH
	; 16/12/2022
	;CALL	IOFUNC
	;RETN
	; 07/12/2022
	jmp	IOFUNC

;
;----------------------------------------------------------------------------
;
;**	$STD_AUX_OUTPUT - Output character to AUX
;
;	ENTRY	(dl) = character
;	EXIT	none
;	USES	all
;
;----------------------------------------------------------------------------
;

_$STD_AUX_OUTPUT:	;System call 4

	PUSH	BX
	MOV	BX,3
	JMP	SHORT SENDOUT

;
;----------------------------------------------------------------------------
;
;**	$STD_PRINTER_OUTPUT - Output character to printer
;
;	ENTRY	(dl) = character
;	EXIT	none
;	USES	all
;
;----------------------------------------------------------------------------
;

_$STD_PRINTER_OUTPUT:	;System call 5

	PUSH	BX
	MOV	BX,4

SENDOUT:
	MOV	AL,DL
	PUSH	AX
	CALL	STATCHK
	POP	AX
	PUSH	DS
	PUSH	SI
LISSTRT2:
	CALL	RAWOUT2
TRIPOP:
	POP	SI
	POP	DS
	POP	BX
SCIS_RETN:	; 20/07/2018
	RETN
;
;----------------------------------------------------------------------------
;
;**	$STD_CON_INPUT_STATUS - System Call 11
;
;	Check console input status
;
;	ENTRY	none
;	EXIT	AL = -1 character available, = 0 no character
;	USES	all
;
;----------------------------------------------------------------------------
;

_$STD_CON_INPUT_STATUS:		;System call 11

	CALL	STATCHK
	MOV	AL,0		; no xor!!
	;retz
	JZ	SHORT SCIS_RETN ; 15/04/2018
	OR	AL,-1
;SCIS_RETN:
	RETN

;
;----------------------------------------------------------------------------
;
;**	$STD_CON_INPUT_FLUSH - System Call 12
;
;	Flush console input buffer and perform call in AL
;
;	ENTRY	(AL) = DOS function to be called after flush (1,6,7,8,10)
;	EXIT	(al) = 0 iff (al) was not one of the supported fcns
;		return arguments for the fcn supplied in (AL)
;	USES	all
;
;----------------------------------------------------------------------------
;

_$STD_CON_INPUT_FLUSH:		;System call 12

	PUSH	AX
	PUSH	DX
	XOR	BX,BX
	CALL	GET_IO_SFT	; 20/07/2018 - MSDOS 3.3 (MSDOS 6.0)
	;CALL	GET_IO_FCB	; 14/03/2018 - MSDOS 2.11
	JC	SHORT BADJFNCON
	MOV	AH,4
	CALL	IOFUNC

BADJFNCON:
	POP	DX
	POP	AX
	MOV	AH,AL
	CMP	AL,1
	JZ	SHORT REDISPJ
	CMP	AL,6
	JZ	SHORT REDISPJ
	CMP	AL,7
	JZ	SHORT REDISPJ
	CMP	AL,8
	JZ	SHORT REDISPJ
	CMP	AL,10
	JZ	SHORT REDISPJ
	MOV	AL,0
	RETN

REDISPJ:
	CLI
	;transfer REDISP
	JMP	REDISP

;============================================================================
; FCBIO.ASM, MSDOS 6.0, 1991
;============================================================================
; 20/07/2018 - Retro DOS v3.0
; 17/05/2019 - Retro DOS v4.0

;**	FCBIO.ASM - Ancient 1.0 1.1 FCB system calls
;
;	$GET_FCB_POSITION
;	$FCB_DELETE
;	$GET_FCB_FILE_LENGTH
;	$FCB_CLOSE
;	$FCB_RENAME
;	SaveFCBInfo
;	ResetLRU
;	SetOpenAge
;	LRUFCB
;	FCBRegen
;	BlastSFT
;	CheckFCB
;	SFTFromFCB
;	FCBHardErr
;
;	Revision history:
;
;		Created: ARR 4 April 1983"
;			 MZ  6 June  1983 completion of functions
;			 MZ 15 Dec   1983 Brain damaged programs close FCBs multiple
;					  times.  Change so successive closes work by
;					  always returning OK.	Also, detect I/O to
;					  already closed FCB and return EOF.
;			 MZ 16 Jan   1984 More braindamage.  Need to separate info
;					  out of sft into FCB for reconnection
;
;		A000	 version 4.00  Jan. 1988

;Break <$Get_FCB_Position - set random record fields to current pos>
;----------------------------------------------------------------------------
;
;   $Get_FCB_Position - look at an FCB, retrieve the current position from the
;	extent and next record field and set the random record field to point
;	to that record
;
;   Inputs:	DS:DX point to a possible extended FCB
;   Outputs:	The random record field of the FCB is set to the current record
;   Registers modified: all
;
;----------------------------------------------------------------------------
;

_$GET_FCB_POSITION:
	call	GetExtended		; point to FCB
	call	GetExtent		; DX:AX is current record
	;mov	[si+21h],ax
	MOV	[SI+SYS_FCB.RR],AX 	; drop in low order piece
	;mov	[si+23h],dl
	MOV	[SI+SYS_FCB.RR+2],DL	; drop in high order piece
	;cmp	word [si+0Eh],64
	CMP	word [SI+SYS_FCB.RECSIZ],64
	JAE	short GetFCBBye
	;mov	[si+24h],dh
	MOV	[SI+SYS_FCB.RR+2+1],DH	; Set 4th byte only if record size < 64
GoodPath:	; 16/12/2022
GetFCBBye:
	jmp	FCB_RET_OK

;Break <$FCB_Delete - remove several files that match the input FCB>
;----------------------------------------------------------------------------
;
;**	$FCB_Delete - Delete from FCB Template
;
;	given an FCB, remove all directory entries in the current
;	directory that have names that match the FCB's ?  marks.
;
;	ENTRY	(DS:DX) = address of FCB
;	EXIT	entries matching the FCB are deleted
;		(al) = ff iff no entries were deleted
;	USES	all
;
;----------------------------------------------------------------------------
;
	; 08/11/2022 Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)

_$FCB_DELETE:		; System call 19
					; OpenBuf is in DOSDATA
	MOV	DI,OPENBUF 		; appropriate place 

	call	TransFCB		; convert FCB to path
	JC	short BadPath 		; signal no deletions

	push	SS
	pop	DS			; SS is DOSDATA

	call	DOS_DELETE		; wham
	;JC	short BadPath
	; 16/12/2022
	jnc 	short GoodPath
;GoodPath:
;	;jmp	FCB_RET_OK		; do a good return
;	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
;	jmp	short GetFCBBye

BadPath:
	; Error code is in AX

	jmp	FCB_RET_ERR		; let someone else signal the error

;Break <$Get_FCB_File_Length - return the length of a file>
;----------------------------------------------------------------------------
;
;   $Get_FCB_File_Length - set the random record field to the length of the
;	file in records (rounded up if partial).
;
;   Inputs:	DS:DX - point to a possible extended FCB
;   Outputs:	Random record field updated to reflect the number of records
;   Registers modified: all
;
;----------------------------------------------------------------------------
;
	; 15/01/2024

_$GET_FCB_FILE_LENGTH:

	call	GetExtended		; get real FCB pointer
					; DX points to Input FCB

					; OpenBuf is in DOSDATA
	MOV	DI,OPENBUF		; appropriate buffer

	push	ds			; save pointer to true FCB
	push	si
	call	TransFCB		; Trans name DS:DX, sets SATTRIB
	pop	si
	pop	ds
	JC	short BadPath
	push	ds			; save pointer
	push	si
	push	ss		
	pop	ds
	call	GET_FILE_INFO		; grab the info
	pop	si			; get pointer back
	pop	ds
	JC	short BadPath 		; invalid something
	; 15/01/2024
	;MOV	DX,BX (*)		; get high order size
	;MOV	AX,DI (**)		; get low order size
	mov	ax,bx ; hw of file size
	;
	;mov	bx,[si+0Eh]
	MOV	BX,[SI+SYS_FCB.RECSIZ]	; get his record size
	OR	BX,BX			; empty record => 0 size for file
	JNZ	short GetSize 		; not empty
	;MOV	BX,128
	mov	bl,128	; 15/01/2024
GetSize:
	; 15/01/2024
	;MOV	DI,AX			; save low order word
	;MOV	AX,DX			; move high order for divide
	;xchg	ax,dx ; (*)
	; ax = hw of file size

	XOR	DX,DX			; clear out high
	DIV	BX			; wham
	PUSH	AX			; save dividend
	MOV	AX,DI ; (**)		; get low order piece
	DIV	BX			; wham
	MOV	CX,DX			; save remainder
	POP	DX			; get high order dividend
	JCXZ	LengthStore		; no roundup
	ADD	AX,1
	ADC	DX,0			; 32-bit increment
LengthStore:
	;mov	[si+21h],ax
	MOV	[SI+SYS_FCB.RR],AX	; store low order
	;mov	[si+23h],dl
	MOV	[SI+SYS_FCB.RR+2],DL	; store high order
	OR	DH,DH
	JZ	short GoodPath		; not storing insignificant zero
	;mov	[si+24h],dh
	MOV	[SI+SYS_FCB.RR+3],DH	; save that high piece
	; 16/12/2022
GoodRet:
	;jmp	FCB_RET_OK
	jmp	short GoodPath

;Break <$FCB_Close - close a file>
;----------------------------------------------------------------------------
;
;   $FCB_Close - given an FCB, look up the SFN and close it. Do not free it
;	as the FCB may be used for further I/O
;
;   Inputs:	DS:DX point to FCB
;   Outputs:	AL = FF if file was not found on disk
;   Registers modified: all
;
;----------------------------------------------------------------------------
;

	; 16/01/2024

_$FCB_CLOSE:		; System call 16

	XOR	AL,AL			; default search attributes
	call	GetExtended		; DS:SI point to real FCB
	JZ	short NoAttr		; not extended
	MOV	AL,[SI-1]		; get attributes
NoAttr:
					; SS override
	MOV	[SS:ATTRIB],AL		; stash away found attributes
	call	SFTFromFCB
	JC	short GoodRet 		; MZ 16 Jan Assume death

	; If the sharer is present, then the SFT is not regenable. Thus, 
	; there is no need to set the SFT's attribute.

	;;; 9/8/86 F.C. save SFT attribute and restore it back when close is 
	;;; done

	;mov	al,[es:di+4]
	MOV	AL,[ES:DI+SF_ENTRY.sf_attr]
	XOR	AH,AH
	PUSH	AX

	;;; 9/8/86 F.C. save SFT attribute and restore it back when close is 
	;;; done

	call	CheckShare
	JNZ	short NoStash
	MOV	AL,[SS:ATTRIB]
	;mov	[es:di+4],al
	MOV	[ES:DI+SF_ENTRY.sf_attr],AL ; attempted attribute for close
NoStash:

; 16/01/2024
%if 0
	;mov	ax,[si+14h]
	MOV	AX,[SI+SYS_FCB.FDATE] ; move in the time and date
	;mov	[es:di+0Fh],ax
	MOV	[ES:DI+SF_ENTRY.sf_date],AX
	;mov	ax,[si+16h]
	MOV	AX,[SI+SYS_FCB.FTIME]
	;mov	[es:di+0Dh],ax
	MOV	[ES:DI+SF_ENTRY.sf_time],AX
	;mov	ax,[si+10h]
	MOV	AX,[SI+SYS_FCB.FILSIZ]
	;mov	[es:di+11h],ax
	MOV	[ES:DI+SF_ENTRY.sf_size],AX
	;mov	ax,[si+12h]
	MOV	AX,[SI+SYS_FCB.FILSIZ+2]
	;mov	[es:di+13h],ax
	MOV	[ES:DI+SF_ENTRY.sf_size+2],AX
	;or	word [es:di+5],4000h
	; 17/12/2022
	or	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_close_nodate>>8) ; 40h
	;OR	word [ES:DI+SF_ENTRY.sf_flags],sf_close_nodate
%else
	; 16/01/2024 (PCDOS 7.1 IBMDOS.COM)
	push	ds
	;lds	ax,[si+14h]
	lds	ax,[si+SYS_FCB.FDATE]	; move in the time and date
	;mov	[es:di+0Fh],ax
	mov	[es:di+SF_ENTRY.sf_date],ax
	;mov	[es:di+0Dh],ds		
	mov	[es:di+SF_ENTRY.sf_time],ds
	pop	ds
	;lds	ax,[si+10h]
	lds	ax,[si+SYS_FCB.FILSIZ]
	;mov	[es:di+11h],ax
	mov	[es:di+SF_ENTRY.sf_size],ax
	;mov	[es:di+13h],ds
	mov	[es:di+SF_ENTRY.sf_size+2],ds
	; 16/01/2024
	;;or	word [es:di+5], 4000h
	;or	word [es:di+SF_ENTRY.sf_flags], sf_close_nodate
	or	byte [es:di+SF_ENTRY.sf_flags+1],(sf_close_nodate>>8) ; 40h
%endif

	push	ss
	pop	ds
	call	DOS_CLOSE	; wham
	LES	DI,[THISSFT]

	;;; 9/8/86 F.C. restore SFT attribute
	POP	CX
	;mov	[es:di+4],cl
	MOV	[ES:DI+SF_ENTRY.sf_attr],CL
	;;; 9/8/86 F.C. restore SFT attribute

	PUSHF
	;test	word [es:di],0FFFFh
	;cmp	word [ES:DI+SF_ENTRY.sf_ref_count],0
				; zero ref count gets blasted
	cmp	word [ES:DI],0
	jnz     short CloseOK
	PUSH	AX
	MOV	AL,'M' ; 4Dh
	call	BlastSFT
	POP	AX
CloseOK:
	POPF
	JNC	short GoodRet
	;cmp	al,6
	CMP	AL,error_invalid_handle
	JZ	short GoodRet
	;mov	al,2
	MOV	AL,error_file_not_found
fren90:
	; 16/12/2022
fcb_close_err:
	jmp	FCB_RET_ERR

;
;----------------------------------------------------------------------------
;
;**	$FCB_Rename - Rename a File
;
;	$FCB_Rename - rename a file in place within a directory. Renames
;	multiple files copying from the meta characters.
;
;	ENTRY	DS:DX point to an FCB. The normal name field is the source
;		    name of the files to be renamed. Starting at offset 11h
;		    in the FCB is the destination name.
;	EXIT	AL = 0 -> no error occurred and all files were renamed
;		AL = FF -> some files may have been renamed but:
;			rename to existing file or source file not found
;	USES	ALL
;
;----------------------------------------------------------------------------
;
	; 08/11/2022 Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)

_$FCB_RENAME:		; System call 23

	call	GetExtended		; get pointer to real FCB
	push	dx
	MOV	AL,[SI] 		; get drive byte
	ADD	SI,10h			; point to destination

					; RenBuf is in DOSDATA
	MOV	DI,RENBUF		; point to destination buffer
	push	word [SI]
	push	ds
	;push	di			; save source pointer for TransFCB
	; 16/01/2024 - BugFix !
	push	si
	MOV	[SI],AL			; drop in real drive
	MOV	DX,SI			; let TransFCB know where the FCB is
	call	TransFCB		; munch this pathname
	pop	si
	pop	ds	
	pop	WORD [SI]		; get path back
	pop	dx			; Original FCB pointer
	JC	short fren90		; bad path -> error

					; SS override for WFP_Start & Ren_WFP
	MOV	SI,[ss:WFP_START]	; get pointer
	MOV	[ss:REN_WFP],SI		; stash it

					; OpenBuf is in DOSDATA
	MOV	DI,OPENBUF		; appropriate spot
	call	TransFCB		; wham
					; NOTE that this call is pointing
					;  back to the ORIGINAL FCB so
					;  SATTRIB gets set correctly
	JC	short fren90		; error
	call	DOS_RENAME
	JC	short fren90
	; 16/12/2022
	jmp	FCB_RET_OK
	
;	Error -
;
;	(al) = error code

	; 16/12/2022
;fren90:	
;	;jmp	FCB_RET_ERR
;	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
;	jmp	short fcb_close_err

;Break <Misbehavior fixers>
;
;   FCBs suffer from several problems. First, they are maintained in the
;   user's space so he may move them at will. Second, they have a small
;   reserved area that may be used for system information. Third, there was
;   never any "rules for behavior" for FCBs; there was no protocol for their
;   usage.
;
;   This results in the following misbehavior:
;
;	infinite opens of the same file:
;
;	While (TRUE) {			While (TRUE) {
;	    FCBOpen (FCB);		    FCBOpen (FCB);
;	    Read (FCB); 		    Write (FCB);
;	    }				    }
;
;	infinite opens of different files:
;
;	While (TRUE) {			While (TRUE) {
;	    FCBOpen (FCB[i++]); 	    FCBOpen (FCB[i++]);
;	    Read (FCB); 		    Write (FCB);
;	    }				    }
;
;	multiple closes of the same file:
;
;	FCBOpen (FCB);
;	while (TRUE)
;	    FCBClose (FCB);
;
;	I/O after closing file:
;
;	FCBOpen (FCB);
;	while (TRUE) {
;	    FCBWrite (FCB);
;	    FCBClose (FCB);
;	    }
;
;   The following is am implementation of a methodology for emulating the
;   above with the exception of I/O after close. We are NOT attempting to
;   resolve that particular misbehavior. We will enforce correct behaviour in
;   FCBs when they refer to a network file or when there is file sharing on
;   the local machine.
;
;   The reserved fields of the FCB (10 bytes worth) is divided up into various
;   structures depending on the file itself and the state of operations of the
;   OS. The information contained in this reserved field is enough to
;   regenerate the SFT for the local non-shared file. It is assumed that this
;   regeneration procedure may be expensive. The SFT for the FCB is
;   maintained in a LRU cache as the ONLY performance inprovement.
;
;   No regeneration of SFTs is attempted for network FCBs.
;
;   To regenerate the SFT for a local FCB, it is necessary to determine if the
;   file sharer is working. If the file sharer is present then the SFT is not
;   regenerated.
;
;   Finally, if there is no local sharing, the full name of the file is no
;   longer available. We can make up for this by using the following
;   information:
;
;	The Drive number (from the DPB).
;	The physical sector of the directory that contains the entry.
;	The relative position of the entry in the sector.
;	The first cluster field.
;	The last used SFT.
;      OR In the case of a device FCB
;	The low 6 bits of sf_flags (indicating device type)
;	The pointer to the device header
;
;   We read in the particular directory sector and examine the indicated
;   directory entry. If it matches, then we are kosher; otherwise, we fail.
;
;   Some key items need to be remembered:
;
;	Even though we are caching SFTs, they may contain useful sharing
;	information. We enforce good behavior on the FCBs.
;
;	Network support must not treat FCBs as impacting the ref counts on
;	open VCs. The VCs may be closed only at process termination.
;
;	If this is not an installed version of the DOS, file sharing will
;	always be present.
;
;	We MUST always initialize lstclus to = firclus when regenerating a
;	file. Otherwise we start allocating clusters up the wazoo.
;
;	Always initialize, during regeneration, the mode field to both isFCB
;	and open_for_both. This is so the FCB code in the sharer can find the
;	proper OI record.
;
;   The test bits are:
;
;	00 -> local file
;	40 -> sharing local
;	80 -> network
;	C0 -> local device

;Break	<SaveFCBInfo - store pertinent information from an SFT into the FCB>
;----------------------------------------------------------------------------
;
;   SaveFCBInfo - given an FCB and its associated SFT, copy the relevant
;	pieces of information into the FCB to allow for subsequent
;	regeneration. Poke LRU also.
;
;   Inputs:	ThisSFT points to a complete SFT.
;		DS:SI point to the FCB (not an extended one)
;   Outputs:	The relevant reserved fields in the FCB are filled in.
;		DS:SI preserved
;		ES:DI point to sft
;   Registers modified: All
;
;
;----------------------------------------------------------------------------
;

	; 20/01/2024
	; 08/11/2022 Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)

SaveFCBInfo:

	LES	DI,[SS:THISSFT]		; SS override
	call	IsSFTNet
	JZ	short SaveLocal		; if not network then save local info
;
;----- In net support -----
;
	; 17/05/2019 - Retro DOS v4.0

	; MSDOS 3.3
	;;mov	ax,[es:di+1Dh]
	;mov	ax,[es:di+SF_ENTRY.sf_dirsec]
	;;mov	[si+1Ah],ax
	;mov	[si+fcb_net_handle],ax
	;push	es
	;push	di
	;;les	di,[es:di+19h]
	;LES	DI,[ES:DI+sf_netid]
	;;mov	[si+1Ch],di
	;MOV	[SI+fcb_netID],DI	; save net ID
	;;mov 	[si+1Eh],es
	;MOV	[SI+fcb_netID+2],ES
	;pop	di
	;pop	es

	; MSDOS 6.0
	;mov	ax,[es:di+0Bh]
	MOV	AX,[ES:DI+sf_serial_ID] ;AN000;;IFS. save IFS ID
	;mov	[si+1Ch],ax
	MOV	[SI+fcb_netID],ax	;AN000;;IFS.
	
	;mov	bl,80h
	MOV	BL,FCBNETWORK
;
;----- END In net support -----
;
	jmp	SHORT SaveSFN

SaveLocal:
	;IF	Installed
	call	CheckShare
	;JZ	short SaveNoShare	; no sharer
	;JMP	short SaveShare		; sharer present
	; 16/12/2022
	; 28/07/2019
	jnz	short SaveShare
	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;JZ	short SaveNoShare	; no sharer
	;JMP	short SaveShare		; sharer present

SaveNoShare:
	;;test 	word [es:di+5],80h
	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
	test	byte [ES:DI+SF_ENTRY.sf_flags],devid_device ; 80h	
	JNZ	short SaveNoShareDev	; Device

	; Save no sharing local file information

	;;mov	ax,[es:di+1Dh]  ; MSDOS 3.3
	;mov	ax,[es:di+1Bh]  ; MSDOS 6.0
	MOV	AX,[ES:DI+SF_ENTRY.sf_dirsec] ; get directory sector F.C.
	;mov	[si+1Dh],ax
	MOV	[SI+fcb_nsl_dirsec],AX

	; MSDOS 6.0

	;SR; Store high byte of directory sector
	;mov	ax,[es:di+1Dh]
	mov	ax,[es:di+SF_ENTRY.sf_dirsec+2] ; get high word
	
	; SR;
	; We have to store the read-only and archive attributes of the file.
	; We extract it from the SFT and store it in the top two bits of the 
	; sector number ( sector number == 22 bits only )

	;mov	bl,[es:di+4]
	mov	bl,[es:di+SF_ENTRY.sf_attr]
	mov	bh,bl
	ror	bl,1
	shl	bh,1
	or	bl,bh
	and	bl,0C0h
	or	al,bl
	;mov	[si+18h],al ; 08/11/2022
	mov	[si+fcb_sfn],al	; sector number = 22 bits

	; MSDOS 6.0 (& MSDOS 3.3)
	;mov	al,[es:di+1Fh]
	MOV	AL,[ES:DI+SF_ENTRY.sf_dirpos] ; location in sector
	;mov	[si+1Fh],al
	MOV	[SI+fcb_nsl_dirpos],AL
	;mov	ax,[es:di+0Bh]
	MOV	AX,[ES:DI+SF_ENTRY.sf_firclus] ; first cluster
	;mov	[si+1Bh],ax
	MOV	[SI+fcb_nsl_firclus],AX
	MOV	BL,0

	; Create the bits field from the dirty/device bits of the flags word 
	; and the mode byte

SetFCBBits:
	;mov	ax,[es:di+5]
	MOV	AX,[ES:DI+SF_ENTRY.sf_flags]
	AND	AL,0C0h 		; mask off drive bits
	;or	al,[es:di+2]
	OR	AL,[ES:DI+SF_ENTRY.sf_mode] ; stick in open mode
	;mov	[si+1Ah], al
	MOV	[SI+fcb_nsl_bits],AL	; save dirty info

	; MSDOS 6.0
	
	; SR;
	; Check if we came here for local file or device. If for local file, 
	; skip setting of SFT index
	
	or	bl,bl
	jz	short SaveNoSFN		; do not save SFN if local file

	JMP	short SaveSFN 		; go and save SFN

	; Save no sharing local device information

SaveNoShareDev:
	; 20/01/2024
	;;mov	ax,[es:di+7]
	;MOV	AX,[ES:DI+SF_ENTRY.sf_devptr]
	;;mov	[si+1Ah],ax
	;MOV	[SI+fcb_nsld_drvptr],AX
	;;mov	ax,[es:di+9]
	;MOV	AX,[ES:DI+SF_ENTRY.sf_devptr+2]
	;MOV	[SI+fcb_nsld_drvptr+2],AX
	; 20/01/2024 (PCDOS 7.1 IBMDOS.COM)
	push	es
	les	ax,[es:di+SF_ENTRY.sf_devptr]
	mov	[si+fcb_nsld_drvptr],ax
	mov	[si+fcb_nsld_drvptr+2],es
	pop	es
	
	;mov	bl,40h
	MOV	BL,FCBDEVICE
	; 28/12/2022
	JMP	short SetFCBBits	; go and save SFN

SaveShare:
	;ENDIF

;----- In share support -----

	;call	far [ss:ShSave]
	Call	far [ss:JShare+(10*4)] ; 10 = ShSave ; SS Override

;----- end in share support -----

	; 17/05/2019

SaveSFN:
	;lea	ax,[di-6]
	LEA	AX,[DI-SFT.SFTable]
	
	; Adjust for offset to table.
	
	SUB	AX,[SS:SFTFCB]		; SS override for SftFCB

	push	bx			;bx = FCB type (net/Share or local)
	;;mov	bl,53 ; MSDOS 3.3
	;mov	bl,59 ; MSDOS 6.0
	MOV	BL,SF_ENTRY.size
	DIV	BL
	;mov	[si+18h],al
	MOV	[SI+fcb_sfn],AL		; last used SFN
	pop	bx			;restore bx

SaveNoSFN:
	;mov	ax,[es:di+5]
	MOV	AX,[ES:DI+SF_ENTRY.sf_flags]
	AND	AL,3Fh			; get real drive
	OR	AL,BL
	;mov	[si+19h],al
	MOV	[SI+fcb_l_drive],AL

	MOV	AX,[SS:FCBLRU]		; get lru count
	INC	AX
	;mov	[es:di+15h],ax
	MOV	[ES:DI+sf_LRU],AX
	JNZ	short SimpleStuff
	
	; lru flag overflowed. Run through all FCB sfts and adjust:  
	; LRU < 8000H get set to 0. Others -= 8000h. This LRU = 8000h
	
	;mov	bx,15h
	MOV	BX,SF_ENTRY.sf_position
	call	ResetLRU

	; Set new LRU to AX
SimpleStuff:
	MOV	[SS:FCBLRU],AX
	retn

;Break	<ResetLRU - reset overflowed lru counts>
;----------------------------------------------------------------------------
;
;   ResetLRU - during lru updates, we may wrap at 64K. We must walk the
;   entire set of SFTs and subtract 8000h from their lru counts and truncate
;   at 0.
;
;   Inputs:	BX is offset into SFT field where lru firld is kept
;		ES:DI point to SFT currently being updated
;   Outputs:	All FCB SFTs have their lru fields truncated
;		AX has 8000h
;   Registers modified: none
;
;----------------------------------------------------------------------------
;

	; 17/05/2019 - Retro DOS v4.0
ResetLRU:
	; ResetLRU is only called from fcbio.asm. So SS can be assumed to be 
	; DOSDATA

	MOV	AX,8000h
	push	es
	push	di
	;LES	DI,[CS:SFTFCB]		; get pointer to head
	LES	DI,[SS:SFTFCB] ; MSDOS 6.0
	;mov	cx,[es:di+4]
	MOV	CX,[ES:DI+SFT.SFCount]
	;lea	di,[di+6]
	LEA	DI,[DI+SFT.SFTable] 	; point at table
ovScan:
	SUB	[ES:DI+BX],AX		; decrement lru count
	JA	short ovLoop
	MOV	[ES:DI+BX],AX		; truncate at 0
ovLoop:
	;;add	di,53	; MSDOS 3.3
	;add	di,59	; MSDOS 6.0	
	ADD	DI,SF_ENTRY.size	; advance to next
	LOOP	ovScan
	pop	di
	pop	es
	MOV	[ES:DI+BX],AX
	retn

;IF  0  ; We dont need this routine any more.
;
;Break	<SetOpenAge - update the open age of a SFT>
;----------------------------------------------------------------------------
;
;   SetOpenAge - In order to maintain the first N open files in the FCB cache,
;   we keep the 'open age' or an LRU count based on opens. We update the
;   count here and fill in the appropriate field.
;
;   Inputs:	ES:DI point to SFT
;   Outputs:	ES:DI has the open age field filled in.
;		If open age has wraparound, we will have subtracted 8000h
;		    from all open ages.
;   Registers modified: AX
;
;----------------------------------------------------------------------------
;
;SetOpenAge:
;	; 20/07/2018 - Retro DOS v3.0
;	; MSDOS 3.3 - IBMDOS.COM, Offset 2597h 
;	; (& MSDOS 6.0, FCBIO.ASM)
;
;	; SetOpenAge is called from fcbio2.asm. SS can be assumed to be valid.
;
;	MOV	AX,[CS:OpenLRU]	; SS override
;	INC	AX
;	;mov	[es:di+17h],ax
;	MOV	[ES:DI+sf_OpenAge],AX
;	JNZ	short SetDone
;	;mov	bx,17h
;	MOV	BX,SF_ENTRY.sf_position+2 ; mov bx,sf_OpenAge
;	call	ResetLRU
;SetDone:
;	MOV	[CS:OpenLRU],AX
;	retn
;
;ENDIF	; SetOpenAge no longer needed

; 21/07/2018 - Retro DOS v3.0
; LRUFCB for MSDOS 6.0 !

;Break	<LRUFCB - perform LRU on FCB sfts>
;----------------------------------------------------------------------------
;
;   LRUFCB - find LRU fcb in cache. Set ThisSFT and return it. We preserve
;	the first keepcount sfts if they are network sfts or if sharing is
;	loaded.  If carry is set then NO BLASTING is NECESSARY.
;
;   Inputs:	none
;   Outputs:	ES:DI point to SFT
;		ThisSFT points to SFT
;		SFT is zeroed
;		Carry set of closes failed
;   Registers modified: none
;
;----------------------------------------------------------------------------
;
; MSDOS 6.0
;IF 0	; rewritten this routine
;
;LRUFCB: ; MSDOS 3.3 - IBMDOS.COM (1987) - Offset 25ADh
;	call	save_world
;	
; Find nth oldest NET/SHARE FCB. We want to find its age for the second scan
; to find the lease recently used one that is younger than the open age.  We
; operate be scanning the list n times finding the least age that is greater
; or equal to the previous minimum age.
;
;   BP is the count of times we need to go through this loop.
;   AX is the current acceptable minimum age to consider
;
;	mov	bp,[CS:KEEPCOUNT]	; k = keepcount;
;	XOR	AX,AX			; low = 0;
;
; If we've scanned the table n times, then we are done.
;
;lru1:
;	CMP	bp,0			; while (k--) {
;	JZ	short lru75
;	DEC	bp
;
; Set up for scan.
;
;   AX is the minimum age for consideration
;   BX is the minimum age found during the scan
;   SI is the position of the entry that corresponds to BX
;
;	MOV	BX,-1			;     min = 0xffff;
;	MOV	si,BX			;     pos = 0xffff;
;	LES	DI,[CS:SFTFCB]		;     for (CX=FCBCount; CX>0; CX--)
;	;mov	cx,[es:di+4]
;	MOV	CX,[ES:DI+SFT.SFCount]
;	;lea	di,[di+6]
;	LEA	DI,[DI+SFT.SFTable]
;
; Innermost loop.  If the current entry is free, then we are done.  Or, if the
; current entry is busy (indicating a previous aborted allocation), then we
; are done.  In both cases, we use the found entry.
;
;lru2:
;	cmp	word [es:di],0
;	;cmp	word [es:di+SF_ENTRY.sf_ref_count],0
;	jz	short lru25
;	;cmp	word [es:di],-1
;	;cmp	word [es:di+SF_ENTRY.sf_ref_count],sf_busy
;	cmp	word [es:di],sf_busy
;	jnz	short lru3
;
; The entry is usable without further scan.  Go and use it.
;
;lru25:
;	MOV	si,DI			;	      pos = i;
;	JMP	short lru11		;	      goto got;
;
; See if the entry is for the network or for the sharer.
;
;  If for the sharer or network then
;	if the age < current minimum AND >= allowed minimum then
;	    this entry becomes current minimum
;
;lru3:
;	;test	word [es:di+5],8000h
;	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet 
;					;	  if (!net[i]
;	JNZ	short lru35
;if installed
;	call	CheckShare		;		&& !sharing)
;	JZ	short lru5		;	  else
;ENDIF
;
; This SFT is for the net or is for the sharer. See if it less than the
; current minimum.
;
;lru35:
;	;mov	dx,[es:di+17h]
;	MOV	DX,[ES:DI+sf_OpenAge]
;	CMP	DX,AX			;	  if (age[i] >= low &&
;	JB	short lru5
;	CMP	DX,BX
;	JAE	short lru5		;	      age[i] < min) {
;
; entry is new minimum.  Remember his age.
;
;	mov	bx,DX			;	      min = age[i];
;	mov	si,di			;	      pos = i;
;
; End of loop.	gp back for more
;
;lru5:
;	;add	di,53
;	add	di,SF_ENTRY.size
;	loop	lru2			;	      }
;
; The scan is complete. If we have successfully found a new minimum (pos != -1)
; set then threshold value to this new minimum + 1. Otherwise, the scan is
; complete.  Go find LRU.
;
;lru6:	
;	cmp	si,-1			; position not -1?
;	jz	short lru75		; no, done with everything
;	lea	ax,[bx+1]		; set new threshold age
;	jmp	short lru1		; go and loop for more
;lru65:	
;	stc
;	jmp	short LRUDead		;	  return -1;
;
; Main loop is done. We have AX being the age+1 of the nth oldest sharer or
; network entry. We now make a second pass through to find the LRU entry
; that is local-no-share or has age >= AX
;
;lru75:
;	mov	bx,-1			; min = 0xffff;
;	mov	si,bx			; pos = 0xffff;
;	LES	DI,[CS:SFTFCB]		; for (CX=FCBCount; CX>0; CX--)
;	;mov	cx,[es:di+4]
;	MOV	CX,[ES:DI+SFT.SFCount]
;	;lea	di,[di+6]
;	LEA	DI,[DI+SFT.SFTable]
;
; If this is is local-no-share then go check for LRU else if age >= threshold
; then check for lru.
;
;lru8:
;	;test	word [es:di+5],8000h
;	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
;	jnz	short lru85		; is for network, go check age
;	call	CheckShare		; sharer here?
;	jz	short lru86		; no, go check lru
;
; Network or sharer.  Check age
;
;lru85:
;	;cmp	[es:di+17h],ax
;	cmp	[es:di+sf_OpenAge],ax
;	jb	short lru9		; age is before threshold, skip it
;
; Check LRU
;
;lru86:
;	;cmp	[es:di+15h],bx
;	cmp	[es:di+sf_LRU],bx	; is LRU less than current LRU?
;	jae	short lru9		; no, skip this
;	mov	si,di			; remember position
;	;mov	bx,[es:di+15h]
;	mov	bx,[es:di+sf_LRU]	; remember new minimum LRU
;
; Done with this entry, go back for more.
;
;lru9:
;	;add	di, 53
;	add	di,SF_ENTRY.size
;	loop	lru8
;
; Scan is complete. If we found NOTHING that satisfied us then we bomb
; out. The conditions here are:
;
;  No local-no-shares AND all net/share entries are older than threshold
;
;lru10:
;	cmp	si,-1			; if no one f
;	jz	short lru65		;     return -1;
;lru11:
;	mov	di,si
;	MOV	[CS:THISSFT],DI		; set thissft
;	MOV	[CS:THISSFT+2],ES
;
; If we have sharing or thisSFT is a net sft, then close it until ref count
; is 0.
;
;	;test	word [es:di+5],8000h
;	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
;	JNZ	short LRUClose
;IF INSTALLED
;	call	CheckShare
;	JZ	short LRUDone
;ENDIF
;
; Repeat close until ref count is 0
;
;LRUClose:
;	push	ss
;	pop	ds
;	LES	DI,[THISSFT]
;	cmp     word [es:di],0
;	;CMP	word [ES:DI+SFT.sf_ref_count],0 ; is ref count still <> 0?
;	JZ	short LRUDone 		; nope, all done
;	call	DOS_CLOSE
;	jnc	short LRUClose		; no error => clean up
;	;cmp	al,6
;	cmp	al,error_invalid_handle
;	jz	short LRUClose
;	stc
;	JMP	short LRUDead
;LRUDone:
;	XOR	AL,AL
;	call	BlastSFT		; fill SFT with 0 (AL), 'C' cleared
;
;LRUDead:
;	call	restore_world
;	LES     DI,[CS:THISSFT]
;	jnc	short LRUFCB_retn
;LRUFCB_err:
;	; mov	al, 23h	
;	MOV	AL,error_FCB_unavailable
;LRUFCB_retn:	
;	retn:
;
;ENDIF	; LRUFCB has been rewritten below.

; 17/05/2019 - Retro DOS v4.0
; LRUFCB for MSDOS 6.0 !
;----------------------------------------------------------------------------
;
; LruFCB -- allocate the LRU SFT from the SFT Table. The LRU scheme
; maintains separate counts for net/Share and local SFTs. We allocate a 
; net/Share SFT only if we do not find a local SFT. This helps keep
; net/Share SFTs which cannot be regenerated for as long as possible. We
; optimize regeneration operations by keeping track of the current local
; SFT. This avoids scanning of the SFTs as long as we have at least one 
; local SFT in the SFT Block.
;
; Inputs: al = 0 => Regenerate SFT operation
;	    = 1 => Allocate new SFT for Open/Create
;
; Outputs: Carry clear
;	 	es:di = Address of allocated SFT
;	  	ThisSFT = Address of allocated SFT
;
;	  carry set if closes of net/Share files failed 
;		al = error_FCB_unavailable
;
; Registers affected: None
;
;----------------------------------------------------------------------------

;LruFCB	PROC	NEAR
LRUFCB:
	; 17/05/2019 - Retro DOS v4.0
	; DOSCODE:5805h (MSDOS 6.21, MSDOS.SYS)

	; 08/11/2022 Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; DOSCODE:57F1h (MSDOS 5.0, MSDOS.SYS)

	; 20/01/2024

	push	es	; * (MSDOS 6.21)
	
	call	save_world
	
	;getdseg <ds>		;ds = DOSDATA
	mov	ds,[cs:DosDSeg]

	or	al,al		;Check if regenerate allocation
	jnz	short lru1	;Try to find SFT to use

	; This is a regen call. If LocalSFT contains the address of a valid
	; local SFT, just return that SFT to reuse

	; 20/01/2024
	;mov	di,[LocalSFT]
	;or	di,[LocalSFT+2]	;is address == 0?
	;jz	short lru1	;invalid local SFT, find one

	; We have found a valid local SFT. Recycle this SFT

	les	di,[LocalSFT]

	; 20/01/2024 (PCDOS 7.1 IBMDOS.COM)
	mov	cx,es
	or	cx,di		; is address == 0?
	jz	short lru1	; invalid local SFT, find one

gotlocalSFT:
	mov	[THISSFT],di
	mov	[THISSFT+2],es
	clc
	jmp	LRUDone		;clear up SFT and return

lru1:
	les	di,[SFTFCB]	;es:di = SF Table for FCBs
	;mov	cx,[es:di+4]
	mov	cx,[es:di+SFT.SFCount]	;cx = number of SFTs
	;lea	di,[di+6]
	lea	di,[di+SFT.SFTable]	;es:di = first SFT

	; We scan through all the SFTs scanning for a free one. It also 
	; remembers the LRU SFT for net/Share SFTs and local SFTs separately.
	; bx = min. LRU for local SFTs
	; si = pos. of local SFT with min. LRU
	; dx = min. LRU for net/Share SFTs
	; bp = pos. of net/Share SFT with min. LRU

	mov	bx,-1		; init. to 0xffff ( max. LRU value )
	mov	si,bx
	mov	dx,bx
	mov	bp,bx

findSFT:
	;See if this SFT is a free one. If so, return it
	or	word [es:di],0
	;or	word [es:di+SF_ENTRY.sf_ref_count],0 ;reference count = 0 ?
	jz	short gotSFT	;yes, SFT is free
	;;cmp	word [es:di],-1
	;cmp	word [es:di+SF_ENTRY.sf_ref_count],sf_busy ;Is it busy?
	cmp	word [es:di],sf_busy ; -1 
	jz	short gotSFT	;no, can use it

	; Check if this SFT is local and store its address in LocalSFT. Can be
	; used for a later regen.

	; 16/12/2022
	; 08/11/2022
	;test	byte [es:di+6],80h
	test	byte [es:di+SF_ENTRY.sf_flags+1],(sf_isnet>>8) ; 80h
	; 08/11/2022 Retro DOS v4.0 (MSDOS 5.0 MSDOS.SYS compatibility)
	;;test	word [es:di+5],8000h
	;test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet ; network SFT?
	jnz	short lru5	;yes, get net/Share LRU

;IF installed
	call	CheckShare	;Share present?
;ENDIF
	jnz	short lru5	;yes, get net/Share LRU

	;Local SFT, register its address

	; !!HACK!!!
	; There is a slightly dirty hack out here in a desperate bid to save
	; code space. There is similar code duplicated at label 'gotSFT'. We
	; enter from there if al = 0, update the LocalSFT variable, and since
	; al = 0, we jump out of the loop to the exit point. I have commented
	; out the code that previously existed at label 'gotSFT'

hackpoint:
	mov	[LocalSFT],di
	mov	[LocalSFT+2],es	;store local SFT address

	or	al,al		;Is operation = REGEN?
	jz	short gotlocalSFT ;yes, return this SFT for reuse

	;Get LRU for local files
	
	;cmp	[es:di+15h],bx
	cmp	[es:di+sf_LRU],bx ;SFT.LRU < min?
	jae	short lru4	;no, skip 

	;mov	bx,[es:di+15h]
	mov	bx,[es:di+sf_LRU] ;yes, store new minimum
	mov	si,di		;store SFT position
lru4:
	;add	di,59
	add	di,SF_ENTRY.size ;go to next SFT
	loop	findSFT
	
	; 20/01/2024
	dec	cx ; -1

	; Check whether we got a net/Share or local SFT. If local SFT
	; available, we will reuse it instead of net/Share LRU

	mov	di,si
	;cmp	si,-1		;local SFT available?
	cmp	si,cx ; 20/01/2024
	jnz	short gotSFT	;yes, return it

	;No local SFT, see if we got a net/Share SFT

	mov	di,bp

	cmp	bp,cx ; -1 ; 20/01/2024
	;cmp	bp,-1		;net/Share SFT available?
	jnz	short gotnetSFT	;yes, return it
noSFT:
	; NB: This error should never occur. We always must have an LRU SFT.
	; This error can occur only if the SFT has been corrupted or the LRU
	; count is not maintained properly.

	jmp	short errorbadSFT ;error, no FCB available.

	; Handle the LRU for net/Share SFTs
lru5:
	;cmp	[es:di+15h],dx
	cmp	[es:di+sf_LRU],dx ;SFT.LRU < min?
	jae	short lru4	;no, skip

	;mov	dx,[es:di+15h]
	mov	dx,[es:di+sf_LRU] ;yes, store new minimum

	mov	bp,di		;store SFT position
	jmp	short lru4	;continue with next SFT

gotSFT:
	or	al,al
	jz	short hackpoint	;save es:di in LocalSFT

	; HACK!!!
	; The code here differs from the code at 'hackpoint' only in the
	; order of the check for al. If al = 0, we can jump to 'hackpoint'
	; and then from there jump out to 'gotlocalSFT'. The original code
	; has been commented out below and replaced by the code just above.

;If regen, then this SFT can be registered as a local one ( even if free ).
;
;	or	al,al		  ;Regen?
;	jnz	short notlocaluse ;yes, register it and return
;
;Register this SFT as a local one
;
;	mov	[LocalSFT],di
;	mov	[LocalSFT+2],es
;	jmp	gotlocalSFT	;return to caller
;
;notlocaluse:

	; The caller is probably going to use this SFT for a net/Share file.
	; We will come here only on a Open/Create when the caller($FCB_OPEN)
	; does not really know whether it is a local file or not. We
	; invalidate LocalSFT if the SFT we are going to use was previously
	; registered as a local SFT that can be recycled.

	mov	ax,es
	cmp	[LocalSFT],di		;Offset same?
	jne	short notinvalid
	cmp	[LocalSFT+2],ax		;Segments same?
	;je	short zerolocalSFT	;no, no need to invalidate
	; 20/01/2024 (PCDOS 7.1 IBMDOS.COM)
	jne	short notinvalid
zerolocalSFT:	
	xor	ax,ax ; 0
	mov	[LocalSFT],ax
	mov	[LocalSFT+2],ax
	
notinvalid:
	jmp	gotlocalSFT

	; The SFT we are going to use was registered in the LocalSFT variable.
	; Invalidate this variable i.e LocalSFT = NULL

;zerolocalSFT:
	;xor	ax,ax ; 0
	;mov	[LocalSFT],ax
	;mov	[LocalSFT+2],ax
	;
	;jmp	gotlocalSFT

gotnetSFT:
	; We have an SFT that is currently net/Share. If it is going to be
	; used for a regen, we know it has to be a local SFT. Update the
	; LocalSFT variable

	or	al,al
	jnz	short closenet

	mov	[LocalSFT],di
	mov	[LocalSFT+2],es	;store local SFT address
closenet:
	mov	[THISSFT],di	; set thissft
	mov	[THISSFT+2],es

	; If we have sharing or thisSFT is a net sft, then close it until ref
	; count is 0.
	; NB: We come here only if it is a net/Share SFT that is going to be
	; recycled -- no need to check for this.

LRUClose:
	cmp	word [es:di],0
	;cmp	word [es:di+SF_ENTRY.sf_ref_count],0 ; is ref count still <> 0?
	jz	short LRUDone	; nope, all done

	call	DOS_CLOSE
	jnc	short LRUClose	; no error => clean up

	; Bugbug: I dont know why we are trying to close after we get an
	; error closing. Seems like we could have a potential infinite loop
	; here. This has to be verified.

	cmp	al,error_invalid_handle ; 6
	je	short LRUClose
errorbadSFT:
	stc
	JMP	short LRUDead
LRUDone:
	XOR	AL,AL
	call	BlastSFT		; fill SFT with 0 (AL), 'C' cleared

LRUDead:
	call	restore_world		; use macro
	
	pop	es ; * (MSDOS 6.21)

	;getdseg <es>
	mov	es,[cs:DosDSeg]
	les	di,[es:THISSFT]		;es:di points at allocated SFT

	;;retnc
	;jc	short LruFCB_err
	;retn

	; 16/12/2022
	; 08/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	jnc	short LruFCB_retn
	;jc	short LruFCB_err
	;retn
		
LruFCB_err:
	MOV	AL,error_FCB_unavailable ; 23h
LruFCB_retn:
	retn
	
;LruFCB	ENDP

; 17/05/2019 - Retro DOS v4.0

; DOSCODE:58F3h (MSDOS 6.21, MSDOS.SYS)

; --------------------------------------------------------------------------
;**** RegenCopyName -- This function copies the filename from the FCB to
; SFT and also to DOS local buffers. There was duplicate code in FCBRegen
; to copy the name to different destinations
;
; Inputs: ds:si = source string
;	 es:di = destination string
;	 cx = length of string
;
; Outputs: String copied to destination
;
; Registers affected: cx,di,si
; --------------------------------------------------------------------------

RegenCopyName:
CopyName:
	lodsb			;load character
	call	UCase		; convert char to upper case
StuffChar2:
	STOSB			;store converted character
	LOOP	CopyName	;
DoneName:
	retn

; --------------------------------------------------------------------------

	; 09/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
FCBRegen:
	; called from SFTFromFCB. SS already DOSDATA

	; General data filling. Mode is sf_isFCB + open_for_both, date/time 
	; we do not fill, size we do no fill, position we do not fill,
	; bit 14 of flags = TRUE, other bits = FALSE

	;mov	al,[si+19h]
	MOV	AL,[SI+fcb_l_drive]

	; We discriminate based on the first two bits in the reserved field.
	
	;test	al,80h
	test	AL,FCBSPECIAL		; check for no sharing test
	JZ	short RegenNoSharing	; yes, go regen from no sharing

	; The FCB is for a network or a sharing based system. At this point 
	; we have already closed the SFT for this guy and reconnection is 
	; impossible.
	;
	; Remember that he may have given us a FCB with bogus information in
	; it. Check to see if sharing is present or if the redir is present.
	; If either is around, presume that we have cycled out the FCB and 
	; give the hard error. Otherwise, just return with carry set.

	call	CheckShare		; test for sharer
	JNZ	short RegenFail		; yep, fail this.
	
	;mov	ax,1100h
	MOV	AX,MultNET<<8		; install check on multnet
	int     2Fh	; Multiplex - NETWORK REDIRECTOR - INSTALLATION CHECK
			; Return: AL = 00h  not installed, OK to install
			; 01h  not installed, not OK to install
			; FFh  installed
	OR	AL,AL			; is it there?
	JZ	short RegenDead		; no, just fail the operation
RegenFail:
	; 17/05/2019 - Retro DOS v4.0
	;MOV	AX,[CS:USER_IN_AX]	; SS override
	mov	ax,[SS:USER_IN_AX] ; MSDOS 6.0

	;cmp	ah,10h
	cmp	AH,FCB_CLOSE
	jz	short RegenDead
	call	FCBHardErr		; massive hard error.
RegenDead:
	STC				; carry set
FCBRegen_retn:
	retn

	; Local FCB without sharing. Check to see if sharing is loaded. If 
	; so fail the operation.

RegenNoSharing:
	call	CheckShare		; Sharing around?
	JNZ	short RegenFail
	
	; Find an SFT for this guy.
	
	; 17/05/2019 - Retro DOS v4.0

	; MSDOS 3.3
	;call	LRUFCB
	;jc	short FCBRegen_retn
	
	; MSDOS 6.0
	push	ax
	mov	al,0			;indicate it is a regen operation
	call	LRUFCB
	pop	ax
	jc	short FCBRegen_retn

	;mov	word [es:di+2],8002h
	MOV	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB+open_for_both+SHARING_COMPAT
	AND	AL,3Fh			; get drive number for flags
	CBW
	;or	ax,4000h
	OR	AX,sf_close_nodate	; normal FCB operation

	; The bits field consists of the upper two bits (dirty and device) 
	; from the SFT and the low 4 bits from the open mode.

	;mov	cl,[si+1Ah]
	MOV	CL,[SI+fcb_nsl_bits]	; stick in dirty bits.
	MOV	CH,CL
	AND	CH,0C0h 		; mask off the dirty/device bits
	OR	AL,CH
	;and	cl,0Fh
	AND	CL,access_mask		; get the mode bits
	;mov	[es:di+2],cl
	MOV	[ES:DI+SF_ENTRY.sf_mode],CL
	;mov	[es:di+5],ax
	MOV	[ES:DI+SF_ENTRY.sf_flags],AX ; initial flags
	;MOV	AX,[CS:PROC_ID]		; SS override
	mov	ax,[ss:PROC_ID] ; MSDOS 6.0
	;mov	[es:di+31h],ax
	MOV	[ES:DI+SF_ENTRY.sf_PID],AX
	push	ds
	push	si
	push	es
	push	di
	push	ss
	pop	es
	MOV	DI,NAME1		; NAME1 is in DOSDATA

	MOV	CX,8
	INC	SI			; Skip past drive byte to name in FCB

	; MSDOS 3.3
;RegenCopyName:
	;lodsb
	;call	UCase
	;stosb
	;loop	RegenCopyName

	; MSDOS 6.0
	call	RegenCopyName		;copy the name to NAME1

	push	ss	; SS is DOSDATA
	pop	ds

	;mov	byte [ATTRIB],16h
	MOV	byte [ATTRIB],attr_hidden+attr_system+attr_directory
					; Must set this to something interesting
					; to call DEVNAME.
	call	DEVNAME 		; check for device
	pop	si
	pop	es
	pop	si
	pop	ds
	JC	short RegenFileNoSharing ; not found on device list => file

	; Device found. We can ignore disk-specific info

	;mov	[es:di+5],bh
	MOV	[ES:DI+SF_ENTRY.sf_flags],BH ; device parms
	;mov	byte [es:di+4],0
	MOV	byte [ES:DI+SF_ENTRY.sf_attr],0 ; attribute
					; SS override
	;LDS	SI,[CS:DEVPT]		; get device driver
	lds	si,[ss:DEVPT] ; MSDOS 6.0
	;mov	[es:di+7],si
	MOV	[ES:DI+SF_ENTRY.sf_devptr],SI
	;mov	[es:di+9],ds
	MOV	[ES:DI+SF_ENTRY.sf_devptr+2],DS
	retn				; carry is clear

RegenDeadJ:
	JMP	short RegenDead

	; File found. Just copy in the remaining pieces.

RegenFileNoSharing:
	;mov	ax,[es:di+5]
	MOV	AX,[ES:DI+SF_ENTRY.sf_flags]
	AND	AX,03Fh
	push	ds
	push	si
	call	FIND_DPB
	;mov	[es:di+7],si
	MOV	[ES:DI+SF_ENTRY.sf_devptr],SI
	;mov	[es:di+9],ds
	MOV	[ES:DI+SF_ENTRY.sf_devptr+2],DS
	pop	si
	pop	ds
	jc	short RegenDeadJ	; if find DPB fails, then drive
					; indicator was bogus
	;mov	ax,[si+1Dh]
	MOV	AX,[SI+fcb_nsl_dirsec]
	;;mov	[es:di+1Dh],ax ; MSDOS 3.3
	;mov	[es:di+1Bh],ax ; MSDOS 6.0
	MOV	[ES:DI+SF_ENTRY.sf_dirsec],AX

	; MSDOS 6.0

	; SR;
	; Extract the read-only and archive bits from the top 2 bits of the sector
	; number

	;mov	al,[si+18h]
	mov	al,[si+fcb_sfn]
	and	al,0C0h		;get the 2 attribute bits
	mov	ah,al
	rol	ah,1
	shr	al,1
	or	al,ah
	and	al,03Fh		;mask off unused bits
	;mov	[es:di+4],al
	mov	[es:di+SF_ENTRY.sf_attr],al

	; SR;
	; Update the higher word of the directory sector from the FCB

	;;mov	al,[si+18h]
	mov	al,[si+fcb_sfn]
	and	al,03Fh		;mask off top 2 bits -- attr bits
	sub	ah,ah
	;mov	[es:di+1Dh],ax
	mov	[es:di+SF_ENTRY.sf_dirsec+2],ax ;update high word

	; MSDOS 6.0 (& MSDOS 3.3)
	;mov	ax,[si+1Bh]
	MOV	AX,[SI+fcb_nsl_firclus]
	;mov	[es:di+0Bh],ax
	MOV	[ES:DI+SF_ENTRY.sf_firclus],AX
	;;mov	[es:di+1Bh],ax ; MSDOS 3.3
	;mov	[es:di+35h],ax ; MSDOS 6.0
	MOV	[ES:DI+SF_ENTRY.sf_lstclus],AX
	;mov	al,[si+1Fh]
	MOV	AL,[SI+fcb_nsl_dirpos]
	;mov  	[es:di+1Fh],al
	MOV	[ES:DI+SF_ENTRY.sf_dirpos],AL
	;INC	word [ES:DI+SF_ENTRY.sf_ref_count]
	inc	word [ES:DI]		; Increment reference count.
					; Existing FCB entries would be
					; flushed unnecessarily because of
					; check in CheckFCB of the ref_count.
					; July 22/85 - BAS
	;lea	si,[si+1]
	LEA	SI,[SI+SYS_FCB.name]
	;lea	di,[di+20h]
	LEA	DI,[DI+SF_ENTRY.sf_name]
	;mov	cx,11
	MOV	CX,SYS_FCB.EXTENT-SYS_FCB.name ; 12-1
	
	; MSDOS 6.0
	call	RegenCopyName	;copy name to SFT 
	
	; MSDOS 3.3
;RegenCopyName2:
	;lodsb
	;call    UCase
	;stosb
	;loop    RegenCopyName2

	clc
	retn

; 17/05/2019 - Retro DOS v4.0

;**	BlastSFT - FIll SFT with Garbage
; --------------------------------------------------------------------------
;	BlastSFT is used when an SFT is no longer needed; it's called with
;	various garbage values to put into the SFT.  I don't know why,
;	presumably to help with debugging (jgl).  We clear the few fields
;	necessary to show that the SFT is free after filling it.
;
;	ENTRY	(es:di) = address of SFT
;		(al) = fill character
;	EXIT	(ax) = -1
;		'C' clear
;	USES	AX, CX, Flags

BlastSFT:
	push	di
	;mov	cx,53 ; MSDOS 3.3
	;mov	cx,59 ; MSDOS 6.0
	mov	cx,SF_ENTRY.size
	rep	stosb
	pop	di
	sub	ax,ax	; 0		; clear 'C'-----------------;
	mov	[es:di],ax
	;mov	[es:di+SF_ENTRY.sf_ref_count],ax ; set ref count    ;
	;mov	[es:di+15h],ax
	mov	[es:di+sf_LRU],ax	; set lru		    ;
	dec	ax	; -1					    ;
	;mov	[es:di+17h],ax ; 0FFFFh ; -1
	mov	[es:di+sf_OpenAge],ax	; set open age to -1	    ;
BlastSFT_retn:
	retn				; return with 'C' clear     ;

;Break	<CheckFCB - see if the SFT pointed to by the FCB is still OK>
; --------------------------------------------------------------------------
;
;   CheckFCB - examine an FCB and its contents to see if it needs to be
;   regenerated.
;
;   Inputs:	DS:SI point to FCB (not extended)
;		AL is SFT index
;   Outputs:	Carry Set - FCB needs to be regened
;		Carry clear - FCB is OK. ES:DI point to SFT
;   Registers modified: AX and BX
;
; --------------------------------------------------------------------------

	; 21/01/2024
	; 09/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; DOSCODE:59F0h (MSDOS 5.0, MSDOS.SYS)
CheckFCB:
		
	; called from $fcb_open and sftfromfcb. SS already set up to DOSDATA

	; MSDOS 3.3

	; LES	DI,[CS:SFTFCB]

	; MSDOS 6.0
	
	; SR;
	; We check if the given FCB is for a local file. If so, we return a 
	; bad SFT status forcing the caller to regenerate the SFT.

	;test	byte [si+19h],0C0h
	test	byte [si+fcb_l_drive],FCBNETWORK|FCBSHARE|FCBDEVICE
	jz	short BadSFT		;Local file, return bad SFT
	LES     DI,[SS:SFTFCB]		; SS override

	; MSDOS 6.0 (& MSDOS 3.3)
	;cmp	[es:di+4],al
	CMP	[ES:DI+SFT.SFCount],AL
	JC	short BadSFT
	;;mov	bl,53 ; MSDOS 3.3
	;mov	bl,59 ; MSDOS 6.0
	MOV	BL,SF_ENTRY.size
	MUL	BL
	;lea	di,[di+6]
	LEA	DI,[DI+SFT.SFTable]
	ADD	DI,AX
	;MOV	AX,[CS:PROC_ID]	; MSDOS 3.3
	mov	ax,[SS:PROC_ID] ; MSDOS 6.0  ; SS override
	;cmp	[es:di+31h],ax
	CMP	[ES:DI+SF_ENTRY.sf_PID],AX
	JNZ	short BadSFT		; must match process
	cmp	word [es:di],0
	;CMP	word [ES:DI+SF_ENTRY.sf_ref_count],0
	JZ	short BadSFT		; must also be in use
	;mov	al,[si+19h]
	MOV	AL,[SI+fcb_l_drive]
	;test	al,80h
	test	AL,FCBSPECIAL		; a special FCB?
	JZ	short CheckNoShare	; No. try local or device

	; Since we are a special FCB, try NOT to use a bogus test instruction.
	; FCBSHARE is a superset of FCBNETWORK.

	PUSH	AX
	;and	al,0C0h
	AND	AL,FCBMASK
	;cmp	al,0C0h
	CMP	AL,FCBSHARE		; net FCB?
	POP	AX
	JNZ	short CheckNet		; yes
;
;----- In share support -----
;
	;call	far [cs:JShare+(11*4)]
	Call    far [ss:JShare+(11*4)] ; 11 = ShChk ; SS Override
	JC	short BadSFT

; 21/01/2024
%if 0
	JMP	SHORT CheckD
;
;----- End in share support -----
;
	; 09/11/2022
	; (There is not any procedure/sub
	;  which calls or jumps to CheckFirClus here)
	;;;
CheckFirClus:
	;cmp     bx,[es:di+0Bh]
	; 07/12/2022
	CMP	BX,[ES:DI+SF_ENTRY.sf_firclus]
	JNZ	short BadSFT
	;;;
%endif

CheckD: 
	AND	AL,3Fh
	;mov	ah,[es:di+5]
	MOV	AH,[ES:DI+SF_ENTRY.sf_flags]
	AND	AH,3Fh
	CMP	AH,AL
	; 16/12/2022
	jz	short BlastSFT_retn	; carry is clear
	; 09/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;jnz	short BadSFT
;CheckD_retn:
	;retn
BadSFT: 
	STC
	retn
				
CheckNet:
	; 17/05/2019 - Retro DOS v4.0
	
;----- In net support -----

	; MSDOS 3.3
	;;mov	ax,[si+1Ah]
	;mov	ax,[si+fcb_net_handle]
	;;cmp	ax,[es:di+1Dh]
	;cmp	ax,[ES:DI+SF_ENTRY.sf_dirsec]
	;jnz	short BadSFT
	;;cmp	ax,[es:di+19h]
	;cmp	ax,[ES:DI+sf_netid]
	;jnz     short BadSFT
	;;mov	ax,[si+1Eh]
	;mov	ax,[si+fcb_l_attr]
	;;cmp	ax,[es:di+1Bh]
	;cmp	ax,[es:di+SF_ENTRY.sf_lstclus]
	;jnz     short BadSFT

	; MSDOS 6.0
	;mov	ax,[si+1Ch]
	MOV	AX,[SI+fcb_netID]	;AN000;IFS.DOS 4.00
	; 09/11/2022
	;cmp	ax,[es:di+0Bh] 
	CMP	AX,[ES:DI+sf_serial_ID]	;AN000;IFS.DOS 4.00
	JNZ	short BadSFT

;----- END In net support -----

CheckNet_retn:
	retn

CheckNoShare:

; 16/12/2022
;	; 09/11/2022 (following test instruction is nonsense!)
;	; (I am leaving it here for MSDOS 5.0 MSDOS.SYS compatibility)
;	;test	al,40h
;	test	AL,FCBDEVICE		; Device?
;	;jnz	short $+2 ; 09/11/2022
;	JNZ	short CheckNoShareDev 	; Yes

	; MSDOS 3.3 - IBMDOS.COM - Offset 27EFh
	;;mov	bx,[si+1Dh]
	;MOV	BX,[SI+fcb_nsl_dirsec]
	;;cmp	bx,[es:di+1Dh]
	;cmp	bx,[ES:DI+SF_ENTRY.sf_dirsec]
	;jnz	short BadSFT
	;;mov	bl,[si+1Fh]
	;MOV	bl,[SI+fcb_nsl_dirpos]
	;;cmp	bl,[es:di+1Fh]
	;cmp	bl,[ES:DI+SF_ENTRY.sf_dirpos]
	;jnz	short BadSFT
	;;mov	bl,[si+1Ah]
	;MOV	bl,[SI+fcb_nsl_bits]
	;;mov	bh,[es:di+5]
	;MOV	bh,[ES:DI+SF_ENTRY.sf_flags]
	;xor	bh,bl
	;and	bh,0C0h
	;jnz	short BadSFT
	;;xor	bl,[es:di+2]
	;xor	bl,[ES:DI+SF_ENTRY.sf_mode]
	;and	bl,0Fh
	;jnz	short BadSFT
	;push	di
	;push	si
	;;lea	di,[di+20h]  ; MSDOS 3.3
	;LEA	DI,[DI+SF_ENTRY.sf_name]
	;;lea	si,[si+1]
	;LEA	SI,[SI+SYS_FCB.name]
	;;mov	cx,11
	;MOV	CX,SYS_FCB.EXTENT-SYS_FCB.name ; 12-1
	;repe	cmpsb
	;pop	si
	;pop	di
	;jnz	short BadSFT
	;;mov	bx,[si+1Bh]
	;MOV	bX,[SI+fcb_nsl_firclus]
	;jmp	short CheckFirClus

	; MSDOS 6.0

	; SR;
	; The code below to match a local FCB with its SFT can no longer be
	; used. We just return a no-match status. This check is done right
	; at the top.

CheckNoShareDev:
	;mov	bx,[si+1Ah]
	MOV	BX,[SI+fcb_nsld_drvptr]
	;cmp	bx,[es:di+7]
	CMP	BX,[ES:DI+SF_ENTRY.sf_devptr]
	JNZ	short BadSFT
	;mov	bx,[si+1Ch]
	MOV	BX,[SI+fcb_nsld_drvptr+2]
	;cmp	bx,[es:di+9]
	CMP	BX,[ES:DI+SF_ENTRY.sf_devptr+2]
	JNZ	short BadSFT
	JMP	short CheckD

;Break	<SFTFromFCB - take a FCB and obtain a SFT from it>
;----------------------------------------------------------------------------
;
;   SFTFromFCB - the workhorse of this compatability crap. Check to see if
;	the SFT for the FCB is Good. If so, make ThisSFT point to it. If not
;	good, get one from the cache and regenerate it. Overlay the LRU field
;	with PID
;
;   Inputs:	DS:SI point to FCB
;   Outputs:	ThisSFT point to appropriate SFT
;		Carry clear -> OK ES:DI -> SFT
;		Carry set -> error in ax
;   Registers modified: ES,DI, AX
;
;----------------------------------------------------------------------------

SFTFromFCB:
	; called from fcbio and $fcb_close. SS already set up to DOSDATA

	; 17/05/2019 - Retro DOS v4.0

	push	ax
	push	bx
	;mov	al,[si+18h]
	MOV	AL,[SI+fcb_sfn] 	; set SFN for check
	call	CheckFCB
	pop	bx
	pop	ax
	;MOV	[CS:THISSFT],DI		; SS override
	;MOV	[CS:THISSFT+2],ES
	MOV	[SS:THISSFT],DI		; SS override
	MOV	[SS:THISSFT+2],ES
	JNC	short Set_SFT		; no problems, just set thissft
	
	; 09/11/2022 (MSDOS 5.0)
	; 31/05/2019
	push	es ; * (MSDOS 6.21) & (MSDOS 5.0)
	call	save_world
	call	FCBRegen
	call	restore_world		; use macro restore world
	pop	es ; * (MSDOS 6.21) ; 31/05/2019 ; 09/11/2022 (MSDOS 5.0)	

	;MOV	AX,[CS:EXTERR]		; SS override
	MOV	AX,[SS:EXTERR]		; SS override
	jc	short CheckNet_retn

Set_SFT: 
	;LES	DI,[CS:THISSFT]		; SS override for THISSFT & PROC_ID
	les	di,[ss:THISSFT]
	;PUSH	word [CS:PROC_ID]	; set process id
	push	word [ss:PROC_ID]
	;pop	word [es:di+31h]
	POP     word [ES:DI+SF_ENTRY.sf_PID]
	retn				; carry is clear

;Break	<FCBHardErr - generate INT 24 for hard errors on FCBS>
;----------------------------------------------------------------------------
;
;   FCBHardErr - signal to a user app that he is trying to use an
;	unavailable FCB.
;
;   Inputs:	none.
;   Outputs:	none.
;   Registers modified: all
;
;----------------------------------------------------------------------------

FCBHardErr:
	; 17/05/2019 - Retro DOS v4.0
	mov	es,[cs:DosDSeg]
	;
	;mov	ax,23h
	MOV	AX,error_FCB_unavailable
	;;mov	byte [cs:ALLOWED],8
	;MOV	byte [CS:ALLOWED],Allowed_FAIL
	mov	byte [es:ALLOWED],Allowed_FAIL	
	
	;LES	BP,[CS:THISDPB]
	les	bp,[es:THISDPB]
	
	MOV	DI,1			; Fake some registers
	MOV	CX,DI
	;mov	dx,[es:bp+0Bh]
	MOV	DX,[ES:BP+DPB.FIRST_SECTOR]
	call	HARDERR
	STC
	retn

;============================================================================
; FCBIO2.ASM, MSDOS 6.0, 1991
;============================================================================
; 21/07/2018 - Retro DOS v3.0
; 17/05/2019 - Retro DOS v4.0

;**	FCBIO2.ASM - Ancient 1.0 1.1 FCB system calls
;
;	GetRR
;	GetExtent
;	SetExtent
;	GetExtended
;	GetRecSize
;	FCBIO
;	$FCB_OPEN
;	$FCB_CREATE
;	$FCB_RANDOM_WRITE_BLOCK
;	$FCB_RANDOM_READ_BLOCK
;	$FCB_SEQ_READ
;	$FCB_SEQ_WRITE
;	$FCB_RANDOM_READ
;	$FCB_RANDOM_WRITE
;
;	Revision history:
;
;		Created: ARR 4 April 1983
;			 MZ  6 June  1983 completion of functions
;			 MZ 15 Dec   1983 Brain damaged programs close FCBs multiple
;				  times.  Change so successive closes work by
;				  always returning OK.	Also, detect I/O to
;				  already closed FCB and return EOF.
;		 MZ 16 Jan   1984 More braindamage.  Need to separate info
;				  out of sft into FCB for reconnection
;
;	    A000   version 4.00	Jan. 1988

; Defintions for FCBOp flags

RANDOM	equ 2				; random operation
FCBREAD equ 4				; doing a read
BLOCK	equ 8				; doing a block I/O

;Break <GetRR - return the random record field in DX:AX>
;---------------------------------------------------------------------------
;
;   GetRR - correctly load DX:AX with the random record field (3 or 4 bytes)
;	from the FCB pointed to by DS:SI
;
;   Inputs:	DS:SI point to an FCB
;		BX has record size
;   Outputs:	DX:AX contain the contents of the random record field
;   Registers modified: none
;---------------------------------------------------------------------------

GetRR:
	;mov	ax,[si+21h]
	MOV	AX,[SI+SYS_FCB.RR]	; get low order part
	;mov	dx,[si+23h]
	MOV	DX,[SI+SYS_FCB.RR+2]	; get high order part
	CMP	BX,64			; ignore MSB of RR if recsiz > 64
	JB	short GetRRBye
GetExtent_bye:	; 21/01/2024
	XOR	DH,DH
GetRRBye:
	retn

;Break <GetExtent - retrieve next location for sequential IO>
;---------------------------------------------------------------------------
;
;   GetExtent - Construct the next record to perform I/O from the EXTENT and
;	NR fields in the FCB.
;
;   Inputs:	DS:SI - point to FCB
;   Outputs:	DX:AX contain the contents of the random record field
;   Registers modified: none
;---------------------------------------------------------------------------

GetExtent:
	;mov	al,[si+20h]
	MOV	AL,[SI+SYS_FCB.NR]	; get low order piece
	;mov	dx,[si+0Ch]
	MOV	DX,[SI+SYS_FCB.EXTENT]	; get high order piece
	SHL	AL,1
	SHR	DX,1
	RCR	AL,1	; move low order bit of DL to high order of AH
	MOV	AH,DL
	MOV	DL,DH
	; 21/01/2024
	;XOR	DH,DH
	;retn
	jmp	short GetExtent_bye

;Break <SetExtent - update the extent/NR field>
;---------------------------------------------------------------------------
;
;   SetExtent - change the position of an FCB by filling in the extent/NR
;	fields
;
;   Inputs:	DS:SI point to FCB
;		DX:AX is a record location in file
;   Outputs:	Extent/NR fields are filled in
;   Registers modified: CX
;---------------------------------------------------------------------------

SetExtent:
	push	ax
	push	dx
	MOV	CX,AX
	AND	AL,7FH			; next rec field
	;mov	[si+20h],al
	MOV	[SI+SYS_FCB.NR],AL
	AND	CL,80H			; save upper bit
	SHL	CX,1
	RCL	DX,1			; move high bit of CX to low bit of DX
	MOV	AL,CH
	MOV	AH,DL
	;mov	[si+0Ch], ax
	MOV	[SI+SYS_FCB.EXTENT],AX	; all done
	pop	dx
	pop	ax
	retn

;Break <GetExtended - find FCB in potential extended fcb>
;---------------------------------------------------------------------------
;
;   GetExtended - Make DS:SI point to FCB from DS:DX
;
;   Inputs:	DS:DX point to a possible extended FCB
;   Outputs:	DS:SI point to the FCB part
;		zeroflag set if not extended fcb
;   Registers modified: SI
;---------------------------------------------------------------------------

GetExtended:
	MOV	SI,DX			; point to Something
	CMP	BYTE [SI],-1		; look for extention
	JNZ	short GetBye		; not there
	ADD	SI,7			; point to FCB
GetBye:
	CMP	SI,DX			; set condition codes
getextd_retn:
	retn

;Break <GetRecSize - return in BX the FCB record size>
;---------------------------------------------------------------------------
;
;   GetRecSize - return in BX the record size from the FCB at DS:SI
;
;   Inputs:	DS:SI point to a non-extended FCB
;   Outputs:	BX contains the record size
;   Registers modified: None
;---------------------------------------------------------------------------

	; 22/01/2024
	; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
GetRecSize:
	;mov	bx,[si+0Eh]
	MOV	BX,[SI+SYS_FCB.RECSIZ]	; get his record size
	OR	BX,BX			; is it nul?
	;jz	short getextd_retn
	; 22/01/2024 (BugFix)
	jnz	short getextd_retn
	;MOV	BX,128			; use default size
	mov	bl,128
	;mov	[si+0Eh],bx
	MOV	[SI+SYS_FCB.RECSIZ],BX	; stuff it back
	retn
; 23/01/2024 - Retro DOS v5.0
; PCDOS 7.1 IBMDOS.COM - DOSCODE:61B3h
; 23/01/2024 - Retro DOS v4.2
; MSDOS 6.22 MSDOS.SYS - DOSCODE:5DC1h
; 23/01/2024 - Retro DOS v4.1
; MSDOS 5.0 MSDOS.SYS - DOSCODE:5DADh

; 22/07/2018 - Retro DOS v3.0

;BREAK <$FCB_Random_write_Block - write a block of records to a file >
;----------------------------------------------------------------------------
;
;   $FCB_Random_Write_Block - retrieve a location from the FCB, seek to it
;	and write a number of blocks from it.
;
;   Inputs:	DS:DX point to an FCB
;   Outputs:	AL = 0 write was successful and the FCB position is updated
;		AL <> 0 Not enough room on disk for the output
;
;----------------------------------------------------------------------------

_$FCB_RANDOM_WRITE_BLOCK:
	;mov	AL,0Ah
	MOV	AL,RANDOM+BLOCK
	JMP	short FCBIO	; 23/01/2024

;BREAK <$FCB_Random_Read_Block - read a block of records to a file >
;----------------------------------------------------------------------------
;
;   $FCB_Random_Read_Block - retrieve a location from the FCB, seek to it
;	and read a number of blocks from it.
;
;   Inputs:	DS:DX point to an FCB
;   Outputs:	AL = error codes defined above
;
;----------------------------------------------------------------------------

_$FCB_RANDOM_READ_BLOCK:
	;mov	AL,0Eh
	MOV	AL,RANDOM+FCBREAD+BLOCK
	JMP	short FCBIO	; 23/01/2024

;BREAK <$FCB_Seq_Read - read the next record from a file >
;----------------------------------------------------------------------------
;
;   $FCB_Seq_Read - retrieve the next record from an FCB and read it into
;	memory
;
;   Inputs:	DS:DX point to an FCB
;   Outputs:	AL = error codes defined above
;
;----------------------------------------------------------------------------

_$FCB_SEQ_READ:
	;mov	AL,4
	MOV	AL,FCBREAD
	JMP	short FCBIO	; 23/01/2024

;BREAK <$FCB_Seq_Write - write the next record to a file >
;----------------------------------------------------------------------------
;
;   $FCB_Seq_Write - retrieve the next record from an FCB and write it to the
;	file
;
;   Inputs:	DS:DX point to an FCB
;   Outputs:	AL = error codes defined above
;
;----------------------------------------------------------------------------

_$FCB_SEQ_WRITE:
	MOV	AL,0
	JMP	short FCBIO	; 23/01/2024

;BREAK <$FCB_Random_Read - Read a single record from a file >
;----------------------------------------------------------------------------
;
;   $FCB_Random_Read - retrieve a location from the FCB, seek to it and read a
;	record from it.
;
;   Inputs:	DS:DX point to an FCB
;   Outputs:	AL = error codes defined above
;
;----------------------------------------------------------------------------

_$FCB_RANDOM_READ:
	;mov	AL,6
	MOV	AL,RANDOM+FCBREAD
	; 23/01/2024
	;jmp	FCBIO 		; single block
	jmp	short FCBIO

;BREAK <$FCB_Random_Write - write a single record to a file >
;----------------------------------------------------------------------------
;
;   $FCB_Random_Write - retrieve a location from the FCB, seek to it and write
;	a record to it.
;
;   Inputs:	DS:DX point to an FCB
;   Outputs:	AL = error codes defined above
;
;----------------------------------------------------------------------------

_$FCB_RANDOM_WRITE:
	;mov	AL,2
	MOV	AL,RANDOM
	; 23/01/2024
	;;jmp	FCBIO
	;jmp	short FCBIO

;BREAK <FCBIO - do internal FCB I/O>
;---------------------------------------------------------------------------
;
;   FCBIO - look at FCBOP and merge all FCB operations into a single routine.
;
;   Inputs:	FCBOP flags which operations need to be performed
;		DS:DX point to FCB
;		CX may have count of number of records to xfer
;   Outputs:	AL has error code
;   Registers modified: all
;---------------------------------------------------------------------------

	; 09/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; DOSCODE:5B17h (MSDOS 5.0 MSDOS.SYS)

	; 23/01/2024
	; DOSCODE:5B2Bh (MSDOS 6.22 MSDOS.SYS)

	; 23/01/2024 - Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
	; DOSCODE:61C9h (PCDOS 7.1 IBMDOS.COM)

FCBIO:

FEOF	EQU	1
FTRIM	EQU	2

%define	FCBErr	byte [bp-1]  ; byte
%define	cRec	word [bp-3]  ; word
;%define RecPos	word [bp-7]  ; dword
%define RecPosL	word [bp-7]  ; word
%define RecPosH	word [bp-5]  ; word
%define	RecSize	word [bp-9]  ; word
;%define bPos	word [bp-13] ; dword
%define bPosL	word [bp-13] ; word
%define bPosH	word [bp-11] ; word
%define cByte	word [bp-15] ; word
%define cResult word [bp-17] ; word
%define	cRecRes	word [bp-19] ; word
%define	FCBOp	byte [bp-20] ; byte
; 23/01/2024
%define bPos bp-13

	;Enter

	push	bp
	mov	bp,sp
	sub	sp,20
	;mov	[bp-20],al
	MOV	FCBOp,AL
	;mov	byte [bp-1],0
	MOV	FCBErr,0		;   FCBErr = 0;
	call	GetExtended		;   FCB = GetExtended ();
	;test	byte [bp-20],8
	TEST	FCBOp,BLOCK		;   if ((OP&BLOCK) == 0)
	JNZ	short GetPos
	MOV	CX,1			;	cRec = 1;
GetPos:
	;mov	[bp-3],cx
	MOV	cRec,CX 		;*Tail coalesce
	call	GetExtent		;   RecPos = GetExtent ();
	call	GetRecSize		;   RecSize = GetRecSize ();
	;mov	[bp-9],bx
	MOV	RecSize,BX
	;test	byte [bp-20],2
	TEST	FCBOp,RANDOM		;   if ((OP&RANDOM) <> 0)
	JZ	short GetRec
	call	GetRR			;	RecPos = GetRR ();
GetRec:
	;mov	[bp-7],ax
	MOV	RecPosL,AX		;*Tail coalesce
	;mov	[bp-5],dx
	MOV	RecPosH,DX
	call	SetExtent		;   SetExtent (RecPos);
	;mov	ax,[bp-5]
	MOV	AX,RecPosH		;   bPos = RecPos * RecSize;
	MUL	BX
	MOV	DI,AX
	;mov	ax,[bp-7]
	MOV	AX,RecPosL
	MUL	BX
	ADD	DX,DI
	;mov	[bp-13],ax
	MOV	bPosL,AX
	;mov	[bp-11],dx
	MOV	bPosH,DX
	;mov	ax,[bp-3]
	MOV	AX,cRec 		;   cByte = cRec * RecSize;
	MUL	BX
	;mov	[bp-15],ax
	MOV	cByte,AX

;hkn; 	SS override
	ADD	AX,[SS:DMAADD]		;   if (cByte+DMA > 64K) {
	ADC	DX,0
	JZ	short DoOper
	;mov	byte [bp-1],2
	MOV	FCBErr,FTRIM		;	FCBErr = FTRIM;

;hkn; 	SS override
	MOV	AX,[SS:DMAADD]		;	cRec = (64K-DMA)/RecSize;
	NEG	AX
	JNZ	short DoDiv
	DEC	AX
DoDiv:
	XOR	DX,DX
	DIV	BX
	;mov	[bp-3],ax
	MOV	cRec,AX
	MUL	BX			;	cByte = cRec * RecSize;
	;mov	[bp-15],ax
	MOV	cByte,AX		;	}
DoOper:
	XOR	BX,BX
	;mov	[bp-17],bx
	MOV	cResult,BX		;   cResult = 0;
	;cmp	[bp-15],bx
	CMP	cByte,BX		;   if (cByte <> 0 ||
	JNZ	short DoGetExt
	;test	byte [bp-1],2
	TEST	FCBErr,FTRIM		;	(FCBErr&FTRIM) == 0) {
	;JZ	short DoGetExt
	;JMP	short SkipOp
	; 16/12/2022
	jnz	short SkipOp
	; 09/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;JZ	short DoGetExt
	;JMP	short SkipOp
DoGetExt:
	call	SFTFromFCB		;	if (!SFTFromFCB (SFT,FCB))
	JNC	short ContinueOp
FCBDeath:
	call	FCB_RET_ERR		; signal error, map for extended
	;mov	word [bp-19],0
	MOV	cRecRes,0		; no bytes transferred
	;mov	byte [bp-1],1
	MOV	FCBErr,FEOF		;	    return FTRIM;
	JMP	FCBSave 		; bam!
ContinueOp:
	; 23/01/2024
	; (PCDOS 7.1 IBMDOS.COM)
	;
	;;mov	ax,[si+10h]
	;MOV	AX,[SI+SYS_FCB.FILSIZ]
	;;mov	[es:di+11h],ax
	;MOV	[ES:DI+SF_ENTRY.sf_size],AX
	;;mov	ax,[si+12h]
	;MOV	AX,[SI+SYS_FCB.FILSIZ+2]
	;;mov	[es:di+13h],ax
	;MOV	[ES:DI+SF_ENTRY.sf_size+2],AX
	;;;
	push	ds
	lds	ax,[si+SYS_FCB.FILSIZ]
	mov	[es:di+SF_ENTRY.sf_size],ax
	mov	[es:di+SF_ENTRY.sf_size+2],ds
	lds	ax,[bPos] ; lds ax,[bp-13]
	mov	dx,ds
	pop	ds
	;;;
	;;mov	ax,[bp-13]
	;MOV	AX,bPosL
	;;mov	dx,[bp-11]
	;MOV	DX,bPosH

	;mov	[es:di+15h],ax
	MOV	[ES:DI+SF_ENTRY.sf_position],AX
	;xchg	dx,[es:di+17h]
	XCHG	[ES:DI+SF_ENTRY.sf_position+2],DX
	PUSH	DX			; save away Open age.
	;mov	cx,[bp-15]
	MOV	CX,cByte		;	cResult =

;hkn; DOS_Read is in DOSCODE
	MOV	DI,DOS_READ		;	    *(OP&FCBRead ? DOS_Read
	;test	byte [bp-20],4
	TEST	FCBOp,FCBREAD		;		 : DOS_Write)(cRec);
	JNZ	short DoContext

;hkn; DOS_Write is in DOSCODE
	MOV	DI,DOS_WRITE
DoContext:
	push	bp
	push	ds
	push	si

;hkn; SS is DOSDATA
	push	ss
	pop	ds

;; Fix for disk full
	CALL	DI	; DOS_READ or DOS_WRITE
	
	pop	si
	pop	ds
	pop	bp
	JC	short FCBDeath
	
	CMP	BYTE [SS:DISK_FULL],0	; treat disk full as error
	JZ	short NODSKFULL
	MOV	BYTE [SS:DISK_FULL],0	; clear the flag

	; (MSDOS 5.0-6.22 MSDOS.SYS) ; 23/01/2024
	;mov	byte [bp-1],1 
	MOV	FCBErr,FEOF		; set disk full flag

	; 23/01/2024
	; (PCDOS 7.1 IBMDOS.COM)
	;;mov	byte [bp-1],1 
	;MOV	FCBErr,FEOF		; set disk full flag

NODSKFULL:
;; Fix for disk full
	;mov	[bp-17],cx
	MOV	cResult,CX
	call	SaveFCBInfo		;	SaveFCBInfo (FCB);
	;pop	word [es:di+17h]	
	POP	WORD [ES:DI+SF_ENTRY.sf_position+2] ; restore open age
			       ; (sf_OpenAge = SF_ENTRY.sf_position+2)

	; 23/01/2024
	; (PCDOS 7.1 IBMDOS.COM)
	;
	;;mov	ax,[es:di+11h]
	;MOV	AX,[ES:DI+SF_ENTRY.sf_size]
	;;mov	[si+10h],ax
	;MOV	[SI+SYS_FCB.FILSIZ],AX
	;;mov	ax,[es:di+13h]
	;MOV	AX,[ES:DI+SF_ENTRY.sf_size+2]
	;;mov	[si+12h],ax
	;MOV	[SI+SYS_FCB.FILSIZ+2],AX
	;;;
	push	es
	les	ax,[es:di+SF_ENTRY.sf_size]
	mov	[si+SYS_FCB.FILSIZ],ax
	mov	[si+SYS_FCB.FILSIZ+2],es
	pop	es
	;;;
					;	}
SkipOp:
	;mov	ax,[bp-17]
	MOV	AX,cResult		;   cRecRes = cResult / RecSize;
	XOR	DX,DX
	;div	word [bp-9]
	DIV	RecSize
	;mov	[bp-19],ax
	MOV	cRecRes,AX
	;add	[bp-7],ax
	ADD	RecPosL,AX		;   RecPos += cRecResult;
	;adc	word [bp-5],0
	ADC	RecPosH,0

; If we have not gotten the expected number of records, we signal an EOF
; condition. On input, this is EOF. On output this is usually disk full.
; BUT... Under 2.0 and before, all device output IGNORED this condition. So
; do we.

	;cmp	ax,[bp-3]
	CMP	AX,cRec 		;   if (cRecRes <> cRec)
	JZ	short TryBlank
	;test	byte [bp-20],4
	TEST	FCBOp,FCBREAD		;	if (OP&FCBRead || !DEVICE)
	JNZ	short SetEOF
	; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; MSDOS 3.3
	;;test	word [es:di+5],80h
	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
	;JNZ	short TryBlank
	; MSDOS 5.0 & MSDOS 6.0
	;test	byte [es:di+5],80h
	test	byte [ES:DI+SF_ENTRY.sf_flags],devid_device
	jnz	short TryBlank

SetEOF:
	;mov	byte [bp-1],1
	MOV	FCBErr,FEOF		;	FCBErr = FEOF;
TryBlank:				;
	OR	DX,DX			;   if (cResult%RecSize <> 0) {
	JZ	short SetExt
	;add	word [bp-7],1
	ADD	RecPosL,1		;	RecPos++;
	;adc	word [bp-5],0
	ADC	RecPosH,0
	;test	byte [bp-20],4
	TEST	FCBOp,FCBREAD		;	if(OP&FCBRead) <> 0) {
	JZ	short SetExt
	;inc	word [bp-19]
	INC	cRecRes 		;	cRecRes++;
	;mov	byte [bp-1],3
	MOV	FCBErr,FTRIM+FEOF	;	FCBErr = FTRIM | FEOF;
	;mov	cx,[bp-9]
	MOV	CX,RecSize		;	Blank (RecSize-cResult%RecSize,
	SUB	CX,DX			;	       DMA+cResult);
	XOR	AL,AL
;hkn; 	SS override
	les     di,[ss:DMAADD]
	;add	di,[bp-17]
	ADD	DI,cResult
	REP	STOSB			;   }	}
SetExt:
	;mov	dx,[bp-5]
	MOV	DX,RecPosH
	;mov	ax,[bp-7]
	MOV	AX,RecPosL
	;test	byte [bp-20],2
	TEST	FCBOp,RANDOM		;   if ((OP&Random) == 0 ||
	JZ	short DoSetExt
	;test	byte [bp-20],8
	TEST	FCBOp,BLOCK		;	(OP&BLOCK) <> 0)
	JZ	short TrySetRR
DoSetExt:
	call	SetExtent		;	SetExtent (RecPos, FCB);
TrySetRR:
	;test	byte [bp-20],8
	TEST	FCBOp,BLOCK		;   if ((op&BLOCK) <> 0)
	JZ	short TryReturn
	;mov	[si+21h],ax
	MOV	[SI+SYS_FCB.RR],AX	;	FCB->RR = RecPos;
	;mov	[si+23h],dl
	MOV	[SI+SYS_FCB.RR+2],DL
	;cmp	word [si+0Eh],64
	CMP	word [SI+SYS_FCB.RECSIZ],64
	JAE	short TryReturn
	;mov	[si+24h],dh
	MOV	[SI+SYS_FCB.RR+2+1],DH	; Set 4th byte only if record size < 64
TryReturn: 
	;test	byte [bp-20],4
	TEST	FCBOp,FCBREAD		;   if (!(FCBOP & FCBREAD)) {
	JNZ	short FCBSave
	push	ds			;	FCB->FDate = date;
	call	DATE16			;	FCB->FTime = time;
	pop	ds
	;mov	[si+14h],ax
	MOV	[SI+SYS_FCB.FDATE],AX
	;mov	[si+16h],dx
	MOV	[SI+SYS_FCB.FTIME],DX	;	}
FCBSave: 
	;test	byte [bp-20],8
	TEST	FCBOp,BLOCK		;   if ((op&BLOCK) <> 0)
	jz	short DoReturn
	;mov	cx,[bp-19]
	MOV	CX,cRecRes		;	user_CX = cRecRes;
	call    Get_User_Stack
	;mov	[si+4],cx
	MOV	[SI+user_env.user_CX],CX
DoReturn:
	;mov	al,[bp-1]
	MOV	AL,FCBErr		;   return (FCBERR);
	;Leave	
	mov     sp,bp
	pop     bp
	retn

; 22/07/2018 - Retro DOS v3.0

;Break <$FCB_Open - open an old-style FCB>
;---------------------------------------------------------------------------
;
;   $FCB_Open - CPM compatability file open. The user has formatted an FCB
;	for us and asked to have the rest filled in.
;
;   Inputs:	DS:DX point to an unopenned FCB
;   Outputs:	AL indicates status 0 is ok FF is error
;		FCB has the following fields filled in:
;		    Time/Date Extent/NR Size
;---------------------------------------------------------------------------

_$FCB_OPEN:			; System call 15

	MOV	AX,SHARING_COMPAT+open_for_both

;hkn; DOS_Open is in DOSCODE
	MOV	CX,DOS_OPEN

; The following is common code for Creation and openning of FCBs. AX is
; either attributes (for create) or open mode (for open)... DS:DX points to
; the FCB

DoAccess:
	push	ds
	push	dx
	push	cx
	push	ax			; save FCB pointer away

;hkn; 	OpenBuf is in DOSDATA
	MOV	DI,OPENBUF
	call	TransFCB		; crunch the fcb
	pop	ax
	pop	cx
	pop	dx
	pop	ds			; get fcb
	JNC	short FindFCB		; everything seems ok
FCBOpenErr:
	; AL has error code
	jmp	FCB_RET_ERR
FindFCB:
	call	GetExtended		; DS:SI will point to FCB

	; 17/05/2019 - Retro DOS v4.0

	; MSDOS 3.3
	;call	LRUFCB
	;jc	short HardMessage

	; MSDOS 6.0
	push	ax
	mov	al,1			;indicate Open/Create operation
	call	LRUFCB			; get a sft entry (no error)
	pop	ax
	jc	short HardMessage
	
	;mov	word [es:di+2],8000h
	mov	word [es:di+SF_ENTRY.sf_mode],sf_isFCB
	push	ds
	push	si	
	push	bx			; save fcb pointer
	MOV	SI,CX

;hkn; SS is DOSDATA
	push	ss
	pop	ds			    ; let DOS_Open see variables
	CALL	SI ; DOS_OPEN or DOS_CREATE ; go open the file
	pop	bx
	pop	si
	pop	ds			; get fcb

;hkn; SS override
	LES	DI,[SS:THISSFT]		; get sf pointer
	JNC	short FCBOK		; operation succeeded
failopen:
	PUSH	AX
	MOV	AL,"R"	; 52h		; clear out field (free sft)
	call	BlastSFT
	POP	AX
	;cmp	ax,4
	CMP	AX,error_too_many_open_files
	JZ	short HardMessage
	;cmp	ax,24h
	CMP	AX,error_sharing_buffer_exceeded
	jnz	short DeadFCB
HardMessage:
	PUSH	AX
	call	FCBHardErr
	POP	AX
DeadFCB:
	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;jmp	FCB_RET_ERR
	jmp	short FCBOpenErr
FCBOK:
	; MSDOS 6.0
	call	IsSFTNet		;AN007;F.C. >32mb  Non Fat file?
	JNZ	short FCBOK2		;AN007;F.C. >32mb  yes
	call	CheckShare		;AN000;F.C. >32mb  share around?
	JNZ	short FCBOK2		;AN000;F.C. >32mb  yes
;SR;
; If we reach here, we know we have got a local SFT. Let's update the 
; LocalSFT variable to reflect this.

	mov	[ss:LocalSFT],di
	mov	[ss:LocalSFT+2],es; Store the SFT address
;;SR;
;; The check below is not valid anymore since we regenerate for media > 32M.
;;
;;	CMP	WORD [ES:DI+SF_ENTRY.sf_dirsec+2],0 
;;					       ;AN000;F.C. >32mb  if dirsec >32mb
;;	JZ	short FCBOK2		       ;AN000;F.C. >32mb    then error
;;	MOV	AX,error_sys_comp_not_loaded   ;AN000;F.C. >32mb
;;	JMP	short failopen		       ;AN000;F.C. >32mb

FCBOK2:
	; MSDOS 6.0 (& MSDOS 3.3)
	inc	word [es:di]
	;INC	word [ES:DI+SF_ENTRY.sf_ref_count] ; increment reference count
	call	SaveFCBInfo
	; MSDOS 3.3
	;call	SetOpenAge
	; MSDOS 6.0 (& MSDOS 3.3)
	;test	word [es:di+5],80h
	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
	test	byte [ES:DI+SF_ENTRY.sf_flags],devid_device  ; 28/07/2019
	JNZ	short FCBNoDrive	; do not munge drive on devices
	MOV	AL,[SI]			; get drive byte
	call	GETTHISDRV		; convert
	;INC	AL
	; 17/12/2022
	inc	ax
	MOV	[SI],AL			; stash in good drive letter

FCBNoDrive:
	;mov	word [si+0Eh],128
	MOV	word [SI+SYS_FCB.RECSIZ],80h ; stuff in default record size

	; 23/01/2024
	; (PCDOS 7.1 IBMDOS.COM)
	;;;
	;;mov	ax,[es:di+0Dh]
	;MOV	AX,[ES:DI+SF_ENTRY.sf_time] ; set time
	;;mov	[si+16h],ax
	;MOV	[SI+SYS_FCB.FTIME],AX
	;;mov	ax,[es:di+0Fh]
	;MOV	AX,[ES:DI+SF_ENTRY.sf_date] ; set date
	;;mov	[si+14h],ax
	;MOV	[SI+SYS_FCB.FDATE],AX
	;;mov	ax,[es:di+11h]
	;MOV	AX,[ES:DI+SF_ENTRY.sf_size] ; set sizes
	;;mov	[si+10h],ax
	;MOV	[SI+SYS_FCB.FILSIZ],AX
	;;mov	ax,[es:di+13h]
	;MOV	AX,[ES:DI+SF_ENTRY.sf_size+2]
	;;mov	[si+12h],ax
	;MOV	[SI+SYS_FCB.FILSIZ+2],AX
	;
	push	es
	;les	ax,[es:di+0Dh]
	les	ax,[es:di+SF_ENTRY.sf_time]
	;mov	[si+16h],ax
	mov	[si+SYS_FCB.FTIME],ax	; set time
	;mov	[si+14h],es
	mov	[si+SYS_FCB.FDATE],es	; set date
	pop	es
	push	es
	;les	ax,[es:di+11h]
	les	ax,[es:di+SF_ENTRY.sf_size] ; set size
	;mov	[si+10h],ax
	mov	[si+SYS_FCB.FILSIZ],ax
	;mov	[si+12h],ax
	mov	[si+SYS_FCB.FILSIZ+2],es
	pop	es
	;;;
	
	XOR	AX,AX			; convenient zero
	;mov	[si+0Ch],ax
	MOV	[SI+SYS_FCB.EXTENT],AX	; point to beginning of file

; We must scan the set of FCB SFTs for one that appears to match the current
; one.	We cheat and use CheckFCB to match the FCBs.

;hkn; 	SS override
	LES	DI,[SS:SFTFCB]		; get the pointer to head of the list
	;mov	ah,[es:di+4]
	MOV	AH,[ES:DI+SFT.SFCount]	; get number of SFTs to scan
OpenScan:
	;cmp	al,[si+18h]
	CMP	AL,[SI+fcb_sfn]		; don't compare ourselves
	JZ	short SkipCheck
	push	ax			; preserve count
	call	CheckFCB		; do they match
	pop	ax			; get count back
	JNC	short OpenFound		; found a match!
SkipCheck:
	INC	AL			; advance to next FCB
	CMP	AL,AH			; table full?
	JNZ	short OpenScan		; no, go for more
OpenDone:
	xor	al,al			; return success
	retn

; The SFT at ES:DI is the one that is already in use for this FCB. We set the
; FCB to use this one. We increment its ref count. We do NOT close it at all.
; Consider:
;
;   open (foo)	delete (foo) open (bar)
;
; This causes us to recycle (potentially) bar through the same local SFT as
; foo even though foo is no longer needed; this is due to the server closing
; foo for us when we delete it. Unfortunately, we cannot see this closure.
; If we were to CLOSE bar, the server would then close the only reference to
; bar and subsequent I/O would be lost to the redirector.
;
; This gets solved by NOT closing the sft, but zeroing the ref count
; (effectively freeing the SFT) and informing the sharer (if relevant) that
; the SFT is no longer in use. Note that the SHARER MUST keep its ref counts
; around. This will allow us to access the same file through multiple network
; connections and NOT prematurely terminate when the ref count on one
; connection goes to zero.

OpenFound:
	;mov	[si+18h],al
	MOV	[SI+fcb_sfn],AL 	; assign with this
	inc	word [es:di]
	;INC	word [ES:DI+SF_ENTRY.sf_ref_count]
					; remember this new invocation
	; 24/01/2024
	push	ss
	pop	ds
	
	;MOV	AX,[SS:FCBLRU]		; update LRU counts
	mov	ax,[FCBLRU] ; 24/01/2024
	;mov	[es:di+15h],ax
	MOV	[ES:DI+sf_LRU],AX
;
; We have an FCB sft that is now of no use. We release sharing info and then
; blast it to prevent other reuse.
;
	;push	ss
	;pop	ds

	LES	DI,[THISSFT]
	dec	word [es:di]
	;DEC	word [ES:DI+SF_ENTRY.sf_ref_count]
					; free the newly allocated SFT
	call	ShareEnd
	MOV	AL,'C'	 ; 43h
	call	BlastSFT
	JMP	short OpenDone

;BREAK	<$FCB_Create - create a new directory entry>
;----------------------------------------------------------------------------
;
;   $FCB_Create - CPM compatability file create. The user has formatted an
;	FCB for us and asked to have the rest filled in.
;
;   Inputs:	DS:DX point to an unopenned FCB
;   Outputs:	AL indicates status 0 is ok FF is error
;		FCB has the following fields filled in:
;		    Time/Date Extent/NR Size
;----------------------------------------------------------------------------

_$FCB_CREATE:		; System call 22

;hkn; DOS_Create is in DOSCODE
	MOV	CX,DOS_CREATE		; routine to call
	XOR	AX,AX			; attributes to create
	call	GetExtended		; get extended FCB
	JZ	short DoAccessJ		; not an extended FCB
	MOV	AL,[SI-1]		; get attributes
DoAccessJ:
	JMP	DoAccess		; do dirty work

;============================================================================
; SEARCH.ASM, MSDOS 6.0, 1991
;============================================================================
; 22/07/2018 - Retro DOS v3.0
; 17/05/2019 - Retro DOS v4.0

; DOSCODE:5DDFh (MSDOS 6.21, MSDOS.SYS)

; 09/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:5DCBh (MSDOS 5.0, MSDOS.SYS)

;**	Search.asm
;----------------------------------------------------------------------------
;	Directory search system calls.
;	These will be passed direct text of the pathname from the user. 
;	They will need to be passed through the macro expander prior to
;	being sent through the low-level stuff. 
;	I/O specs are defined in DISPATCH. The system calls are:
;
;	$Dir_Search_First	  written
;	$Dir_Search_Next	  written
;	$Find_First	  written
;	$Find_Next		  written
;	PackName		  written
;
;	Modification history:
;
;	  Created: ARR 4 April 1983

;----------------------------------------------------------------------------
; Procedure Name : $DIR_SEARCH_FIRST
;
; Inputs:
;	DS:DX Points to unopenned FCB
; Function:
;	Directory is searched for first matching entry and the directory
;	entry is loaded at the disk transfer address
; Returns:
;	AL = -1 if no entries matched, otherwise 0
;----------------------------------------------------------------------------

	; IBMDOS.COM (MSDOS 3.3) - Offset 2B88h

	; 24/01/2024
	; MSDOS 5.0 MSDOS.SYS - DOSCODE:5DCBh
	; MSDOS 6.22 MSDOS.SYS - DOSCODE:5DDFh
	; PCDOS 7.1 IBMDOS.COM - DOSCODE:647Bh

_$DIR_SEARCH_FIRST:
	MOV	[SS:THISFCB],DX
	MOV	[SS:THISFCB+2],DS
	MOV	SI,DX
	CMP	BYTE [SI],0FFH
	JNZ	short NORMFCB4
	ADD	SI,7			; Point to drive select byte
NORMFCB4:
	push	word [SI]		; Save original drive byte for later

	push	ss
	pop	es			; get es to address DOSGroup

	MOV	DI,OPENBUF		; appropriate buffer
	call	TransFCB		; convert the FCB, set SATTRIB EXTFCB
	JNC	short SearchIt		; no error, go and look
	pop	bx			; Clean stack

; Error code is in AX

	; 09/11/2022
dcf_errj:
	jmp	FCB_RET_ERR		; error

SearchIt:
	push	ss
	pop	ds			; get ready for search
	;push	word [DMAADD]
	;push	word [DMAADD+2]
	; 24/01/2024
	les	di,[DMAADD]
	push	di
	push	es
	MOV	WORD [DMAADD],SEARCHBUF
	MOV	WORD [DMAADD+2],DS
	; MSDOS 3.3
	;call	DOS_SEARCH_FIRST
	; MSDOS 6.0
	call	GET_FAST_SEARCH		; search
	pop	word [DMAADD+2]
	pop	word [DMAADD]
	JNC	short SearchSet		; no error, transfer info
	pop	bx			; Clean stack

; Error code is in AX

	; 09/11/2022
	;jmp	FCB_RET_ERR
	jmp	short dcf_errj

;----------------------------------------------------------------------------
;
; Procedure Name : $DIR_SEARCH_NEXT
;
; Inputs:
;	DS:DX points to unopenned FCB returned by $DIR_SEARCH_FIRST
; Function:
;	Directory is searched for the next matching entry and the directory
;	entry is loaded at the disk transfer address
; Returns:
;	AL = -1 if no entries matched, otherwise 0
;----------------------------------------------------------------------------

	; 24/01/2024
	; MSDOS 5.0 MSDOS.SYS - DOSCODE:5E5Fh
	; MSDOS 6.22 MSDOS.SYS - DOSCODE:5E73h
	; PCDOS 7.1 IBMDOS.COM - DOSCODE:6517h

_$DIR_SEARCH_NEXT:
	MOV	[SS:THISFCB],DX
	MOV	[SS:THISFCB+2],DS
	MOV	byte [SS:SATTRIB],0
	MOV	byte [SS:EXTFCB],0

	push	ss
	pop	es

	MOV	DI,SEARCHBUF

	MOV	SI,DX
	CMP	BYTE [SI],0FFh
	JNZ	short NORMFCB6
	ADD	SI,6
	LODSB

	MOV	[SS:SATTRIB],AL
	DEC	byte [SS:EXTFCB]
NORMFCB6:
	LODSB				; Get original user drive byte
	push	ax			; Put it on stack
	MOV	AL,[SI+20]		; Get correct search contin drive byte
	STOSB				; Put in correct place
	MOV	CX,20/2
	REP	MOVSW			; Transfer in rest of search contin info

	push	ss
	pop	ds

	;push	word [DMAADD]
	;push	word [DMAADD+2]
	; 24/01/2024
	les	di,[DMAADD]
	push	di
	push	es
	MOV	WORD [DMAADD],SEARCHBUF
	MOV	WORD [DMAADD+2],DS
	call	DOS_SEARCH_NEXT 	; Find it
	pop	word [DMAADD+2]
	pop	word [DMAADD]
	JC	short SearchNoMore
	; 24/01/2024
	;JMP	SearchSet		; Ok set return

;;;	; 24/01/2024

; The search was successful (or the search-next). We store the information
; into the user's FCB for continuation.

SearchSet:
	MOV	SI,SEARCHBUF
	LES	DI,[THISFCB]		; point to the FCB
	TEST	byte [EXTFCB],0FFh
	JZ	short NORMFCB1
	ADD	DI,7			; Point past the extension
NORMFCB1:
	pop	bx			; Get original drive byte
	OR	BL,BL
	JNZ	short SearchDrv
	MOV	BL,[CURDRV]
	INC	BL
SearchDrv:
	LODSB				; Get correct search contin drive byte
	XCHG	AL,BL			; Search byte to BL, user byte to AL
	INC	DI
	;STOSB				; Store the correct "user" drive byte
					;  at the start of the search info
	MOV	CX,20/2
	REP	MOVSW			; Rest of search cont info, SI -> entry
	XCHG	AL,BL			; User drive byte back to BL, search
					;   byte to AL
	STOSB				; Search contin drive byte at end of
					;   contin info
	LES	DI,[DMAADD]
	TEST	byte [EXTFCB],0FFh
	JZ	short NORMFCB2
	MOV	AL,0FFh
	STOSB
	INC	AL
	;MOV	CX,5
	; 17/12/2022
	mov	cl,5
	REP	STOSB
	MOV	AL,[SATTRIB]
	STOSB
NORMFCB2:
	MOV	AL,BL			; User Drive byte
	STOSB
	;MOV	CX,16			; 32 / 2 words of dir entry
	; 17/12/2022
	mov	cl,16
	REP	MOVSW
	jmp	FCB_RET_OK
;;;

SearchNoMore:
	LES	DI,[THISFCB]
	TEST	byte [EXTFCB],0FFh
	JZ	short NORMFCB8
	ADD	DI,7			; Point past the extension
NORMFCB8:
	pop	bx			; Get original drive byte
	MOV	[ES:DI],BL		; Store the correct "user" drive byte
					;  at the right spot
; error code is in AX

	jmp	FCB_RET_ERR

; 17/05/2019 - Retro DOS v4.0

; DOSCODE:5EE6h (MSDOS 6.21, MSDOS.SYS)

;---------------------------------------------------------------------------
;
;   Procedure Name : $FIND_FIRST
; 
;   Assembler usage:
;	    MOV AH, FindFirst
;	    LDS DX, name
;	    MOV CX, attr
;	    INT 21h
;	; DMA address has datablock
;
;   Error Returns:
;	    AX = error_path_not_found
;	       = error_no_more_files
;---------------------------------------------------------------------------

	; 09/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; DOSCODE:5ED2h (MSDOS 5.0, MSDOS.SYS)

	; 24/01/2024
	; DOSCODE:5EE6h (MSDOS 6.22, MSDOS.SYS)

_$FIND_FIRST:
	MOV	SI,DX			; get name in appropriate place
	MOV	[SS:SATTRIB],CL		; Search attribute to correct loc

	MOV	DI,OPENBUF		; appropriate buffer

	call	TransPathSet		; convert the path
	JNC	short Find_it 		; no error, go and look
FindError:
	;mov	al,3
	mov	al, error_path_not_found ; error and map into one.
	; 09/11/2022
FF_errj:
	jmp	SYS_RET_ERR
Find_it:
	push	ss
	pop	ds

	;push	word [DMAADD]
	;push	word [DMAADD+2]
	; 24/01/2024 (PCDOS 7.1 IBMDOS.COM)
	les	di,[DMAADD]
	push	di
	push	es
	MOV	WORD [DMAADD],SEARCHBUF
	MOV	WORD [DMAADD+2],DS
	; MSDOS 3.3
	;call	DOS_SEARCH_FIRST
	; MSDOS 6.0
	call	GET_FAST_SEARCH 	; search
	pop	word [DMAADD+2]
	pop	word [DMAADD]
	
	; 16/12/2022
	;JNC	short FindSet 		; no error, transfer info
	jc	short FF_errj	; jmp SYS_RET_ERR
	;
	;jmp	SYS_RET_ERR
	; 09/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
;FFF_errj:
	;jmp	short FF_errj	; jmp SYS_RET_ERR

FindSet:
	MOV	SI,SEARCHBUF
	LES	DI,[DMAADD]
	MOV	CX,21
	REP	MOVSB
	PUSH	SI			; Save pointer to start of entry
	;mov	al,[si+0Bh]
	MOV	AL,[SI+dir_entry.dir_attr]
	STOSB
	;add	si,16h ; 22
	ADD	SI,dir_entry.dir_time
	MOVSW				; dir_time
	MOVSW				; dir_date
	INC	SI
	INC	SI			; Skip dir_first
	MOVSW				; dir_size (2 words)
	MOVSW
	POP	SI			; Point back to dir_name
 	CALL	PackName
	jmp	SYS_RET_OK		; bye with no errors

;---------------------------------------------------------------------------
;
;   Procedure Name : $FIND_NEXT
;
;   Assembler usage:
;	; dma points at area returned by find_first
;	    MOV AH, findnext
;	    INT 21h
;	; next entry is at dma
;
;   Error Returns:
;	    AX = error_no_more_files
;---------------------------------------------------------------------------

	; 09/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)

	; 24/01/2024
	; DOSCODE:5F3Eh (MSDOS 6.22, MSDOS.SYS)

_$FIND_NEXT:
	push	ss
	pop	es

	MOV	DI,SEARCHBUF

	LDS	SI,[SS:DMAADD]

	MOV	CX,21
	REP	MOVSB			; Put the search continuation info
					;  in the right place
	push	ss
	pop	ds			; get ready for search
	
	;push	word [DMAADD]
	;push	word [DMAADD+2]
	; 24/01/2024
	les	di,[DMAADD]
	push	di
	push	es
	MOV	WORD [DMAADD],SEARCHBUF
	MOV	WORD [DMAADD+2],DS
	call	DOS_SEARCH_NEXT 	; Find it
	pop	word [DMAADD+2]
	pop	word [DMAADD]
	JNC	short FindSet 		; No error, set info
	;jmp	SYS_RET_ERR
	; 16/12/2022
	jmp	short FF_errj	; jmp SYS_RET_ERR
	; 09/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;jmp	short FFF_errj	; jmp SYS_RET_ERR

;---------------------------------------------------------------------------
;**	PackName - Convert file names from FCB to ASCIZ format.
;
;	PackName transfers a file name from DS:SI to ES:DI and converts it to
;	the ASCIZ format.
;
;	ENTRY	(DS:SI) = 11 character FCB or dir entry name
;		(ES:DI) = destination area (13 bytes)
;	EXIT	(ds:SI) and (es:DI) advanced
;	USES	al, CX, SI, DI, Flags  (BUGBUG - not verified - jgl)
;---------------------------------------------------------------------------

	; 25/01/2024 - Retro DOS v4.2
	; MSDOS 6.22 MSDOS.SYS - DOSCODE:5F70h

PackName:
;	Move over 8 characters to cover the name component, then trim it's
;	trailing blanks.

	;MOV	CX,8			; Pack the name
	;REP	MOVSB			; Move all of it
	; 25/01/2024
	mov	cx,4
	rep	movsw
main_kill_tail:
	CMP	BYTE [ES:DI-1]," "
	JNZ	short find_check_dot
	DEC	DI			; Back up over trailing space
	INC	CX
	CMP	CX,8
	JB	short main_kill_tail
find_check_dot:
	;CMP	WORD [SI],(" " << 8) | " "
	cmp     word [si],2020h 
	JNZ	short got_ext 		; Some chars in extension
	CMP	BYTE [SI+2]," "
	JZ	short find_done		; No extension
got_ext:
	MOV	AL,"."	; 2Eh
	STOSB
	;MOV	CX,3
	;; 18/12/2022
	;;mov	cl,3
	;;REP	MOVSB
	;movsb
	;movsb
	;movsb
	; 25/01/2024
	movsw
	movsb
ext_kill_tail:
	CMP	BYTE [ES:DI-1]," "
	JNZ	short find_done
	DEC	DI			; Back up over trailing space
	JMP	short ext_kill_tail
find_done:
	XOR	AX,AX
	STOSB				; NUL terminate
	retn

;---------------------------------------------------------------------------

; 24/01/2024
%if 0
	; 17/05/2019 - Retro DOS v4.0
GET_FAST_SEARCH:
	; 22/07/2018
	; MSDOS 6.0
	; 17/12/2022
	OR	byte [ss:DOS34_FLAG+1],(SEARCH_FASTOPEN>>8)  ; 04h
	;OR	word [ss:DOS34_FLAG],SEARCH_FASTOPEN  ; 400h
					;FO.trigger fastopen ;AN000;
	;call	DOS_SEARCH_FIRST
	;retn
	; 17/12/2022
	jmp	DOS_SEARCH_FIRST
%endif

;============================================================================
; PATH.ASM, MSDOS 6.0, 1991
;============================================================================
; 06/08/2018 - Retro DOS v3.0
; 17/05/2019 - Retro DOS v4.0

; DOSCODE:5FB0h (MSDOS 6.21, MSDOS.SYS)

;**	Directory related system calls. These will be passed direct text of the
;	pathname from the user. They will need to be passed through the macro
;	expander prior to being sent through the low-level stuff. I/O specs are
;	defined in DISPATCH. The system calls are:
;
;	$CURRENT_DIR  Written
;	$RMDIR	  Written
;	$CHDIR	  Written
;	$MKDIR	  Written
;
;
;	Modification history:
;
;	    Created: ARR 4 April 1983
;		 MZ 10 May 1983     CurrentDir implemented
;		 MZ 11 May 1983     RmDir, ChDir, MkDir implemented
;		 EE 19 Oct 1983     RmDir no longer allows you to delete a
;				    current directory.
;		 MZ 19 Jan 1983     Brain damaged applications rely on success

;	I_Need	ThisCDS,DWORD		; pointer to Current CDS
;	I_Need	WFP_Start,WORD		; pointer to beginning of directory text
;	I_Need	Curr_Dir_End,WORD	; offset to end of directory part
;	I_Need	OpenBuf,128		; temp spot for translated name
;	I_need	fSplice,BYTE		; TRUE => do splice
;	I_Need	NoSetDir,BYTE		; TRUE => no exact match on splice
;	I_Need	cMeta,BYTE
;	I_Need	DrvErr,BYTE					;AN000;

;BREAK <$CURRENT_DIR - dump the current directory into user space>
;----------------------------------------------------------------------------
;
;   Procedure Name : $CURRENT_DIR
;
;   Assembler usage:
;		LDS	SI,area
;		MOV	DL,drive
;		INT	21h
;	    ; DS:SI is a pointer to 64 byte area that contains drive
;	    ; current directory.
;   Error returns:
;	    AX = error_invalid_drive
;
;----------------------------------------------------------------------------

	; 06/08/2018 - Retro DOS v3.0
	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 2D4Eh

	; 25/01/2024 - Retro DOS v4.2
	; MSDOS 5.0 MSDOS.SYS - DOSCODE:5F9Ch
	; MSDOS 6.22 MSDOS.SYS - DOSCODE:5FB0h
	; Windows ME IO.SYS - BIOSCODE:6393h
	; PCDOS 7.1 IBMDOS.COM - DOSCODE:6664h

_$CURRENT_DIR:
	call	ECritDisk
	MOV	AL,DL			; get drive number (0=def, 1=A)
	call	GetVisDrv		; grab it
	JNC	short CurrentValidate 	; no error -> go and validate dir
CurdirErr:
	call	LCritDisk

	; MSDOS 3.3
	;mov	al,0Fh
	
	; MSDOS 6.0
	push	ds
	mov	ds,[cs:DosDSeg]
	mov	al,[DrvErr]		;IFS.			;AN000;
	pop	ds

curdir_errj:
	jmp	SYS_RET_ERR		;IFS. make noise	;AN000;

CurrentValidate:
	push	ds			; save destination
	push	si
	
	;LDS	SI,[CS:THISCDS] ; MSDOS 3.3
	
	; MSDOS 6.0
	mov     ds,[cs:DosDSeg]
	; 25/01/2024 (PCDOS 7.1 IBMDOS.COM)
	mov	byte [NoSetDir],0 ; *
	
	; 25/01/2024
	;lds     si,[THISCDS]

; 16/12/2022
%if 0
	; 09/11/2022 (following test instruction is nonsense!)
	; (I am leaving it here for MSDOS 5.0 MSDOS.SYS compatibility)

	;test	word [si+43h],8000h
	TEST	word [SI+curdir.flags],curdir_isnet
	;jnz	short $+2  ; 09/11/2022	
	jnz	short DoCheck
%endif

; Random optimization nuked due to some utilities using GetCurrentDir to do
; media check.
;	CMP	word [SI+curdir.ID],0
;	JZ	short GetDst
DoCheck:
	;MOV	byte [cs:NoSetDir],0	; interested only in contents

	; 25/01/2024
	; MSDOS 6.0
	;push	ds
	;mov	ds,[cs:DosDSeg]
	;mov	byte [NoSetDir],0 ; *
	;pop	ds

	MOV	DI,OPENBUF
	call	ValidateCDS		; output is ES:DI -> CDS

	push	es	 		; swap source and destination
	push	di
	pop	si
	pop	ds
GetDst:
	pop	di
	pop	es			; get real destination
	JC	short CurdirErr
	;ADD	SI,curdir.text ; add si,0 ; 09/08/2018
	;
	; 09/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	; DOSCODE:5FE2h (MSDOS 5.0, MSDOS.SYS)
	; 16/12/2022
	;add	si,0  ; add si,curdir.text
	;
	;add	si,[si+4Fh] ; 17/05/2019
	ADD	SI,[SI+curdir.end]
	CMP	BYTE [SI],'\'	; 5Ch	; root or subdirs present?
	JNZ	short CurrentCopy
	INC	SI
CurrentCopy:
;	call	FStrCpy
;; 10/29/86 E5 char
	PUSH	AX
	LODSB				; get char
	OR	AL,AL
	JZ	short FOK
	CMP	AL,05H
	JZ	short FCHANGE
	JMP	short FFF
FCPYNEXT:
	LODSB				; get char
FFF:
	CMP	AL,'\'			; beginning of directory
	JNZ	short FOK		; no
	STOSB				; put into user's buffer
	LODSB				; 1st char of dir is 05?
	CMP	AL,05H
	JNZ	short FOK		; no
FCHANGE:
	MOV	AL,0E5H			; make it E5
FOK:
	STOSB				; put into user's buffer
	OR	AL,AL			; final char
	JNZ	short FCPYNEXT		; no
	POP	AX

;; 10/29/86 E5 char
	xor	AL,AL			; MZ 19 Jan 84
	call	LCritDisk
	jmp	SYS_RET_OK		; no more, bye!

; 17/05/2019 - Retro DOS v4.0

; DOSCODE:6029h (MSDOS 6.21, MSDOS.SYS)

;BREAK <$RmDir -- Remove a directory>
;----------------------------------------------------------------------------
;
; Procedure Name : $RmDir
;
; Inputs:
;	DS:DX Points to asciz name
; Function:
;	Delete directory if empty
; Returns:
;	STD XENIX Return
;	AX = error_path_not_found If path bad
;	AX = error_access_denied If
;		Directory not empty
;		Path not directory
;		Root directory specified
;		Directory malformed (. and .. not first two entries)
;		User tries to delete a current directory
;	AX = error_current_directory
;
;----------------------------------------------------------------------------

	; 10/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; DOSCODE:6015h (MSDOS 5.0, MSDOS.SYS)

_$RMDIR:
	push	dx			; Save ptr to name
	push	ds
	mov	si,dx			; Load ptr into si
	mov	di,OPENBUF		; di = ptr to buf for trans name
	push	di
	call	TransPathNoSet		; Translate the name
	pop	di			; di = ptr to buf for trans name
	jnc	short rmlset		; If transpath succeeded, continue
	pop	ds
	pop	dx			; Restore the name
	;mov	al,3
	mov	al,error_path_not_found ; Otherwise, return an error
	; 16/12/2022
rmdir_errj: ; 10/08/2018
chdir_errj:
	jmp	short curdir_errj
	;jmp	SYS_RET_ERR
rmlset:
	CMP	byte [ss:CMETA],-1	;   if (cMeta >= 0)
	Jnz	short rmerr		;	return (-1);
	push	ss
	pop	es
	xor	al,al			; al = 0 , ie drive a:
rmloop: 
	call	GetCDSFromDrv		; Get curdir for drive in al
	jc	short rmcont		; If error, exit loop & cont normally
	call	StrCmp			; Are the 2 paths the same?
	jz	short rmerr		; Yes, report error.
	inc	al			; No, inc al to next drive number
	jmp	short rmloop		; Go check next drive.
rmerr:
	pop	ds
	pop	dx			; Restore the name
	;mov	al,10h
	mov	al,error_current_directory ; error
	; 16/12/2022
	; 10/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
;chdir_errj:
	jmp	short rmdir_errj
rmcont:
	pop	ds
	pop	dx			; Restore the name
	MOV	SI,DOS_RMDIR
	JMP	DoDirCall

; 17/05/2019 - Retro DOS v4.0

; DOSCODE:6065h (MSDOS 6.21, MSDOS.SYS)

;BREAK <$ChDir -- Change current directory on a drive>
;----------------------------------------------------------------------------
;
; $ChDir - Top-level change directory system call.  This call is responsible
; for setting up the CDS for the specified drive appropriately.  There are
; several cases to consider:
;
;   o	Local, simple CDS.  In this case, we take the input path and convert
;	it into a WFP.	We verify the existance of this directory and then
;	copy the WFP into the CDS and set up the ID field to point to the
;	directory cluster.
;   o	Net CDS.  We form the path from the root (including network prefix)
;	and verify its existance (via DOS_Chdir).  If successful, we copy the
;	WFP back into the CDS.
;   o	SUBST'ed CDS.  This is no different than the local, simple CDS.
;   o	JOIN'ed CDS.  This is trouble as there are two CDS's at work.  If we
;	call TransPath, we will get the PHYSICAL CDS that the path refers to
;	and the PHYSICAL WFP that the input path refers to.  This is perfectly
;	good for the validation but not for currency.  We call TransPathNoSet
;	to process the path but to return the logical CDS and the logical
;	path.  We then copy the logical path into the logical CDS.
;
; Inputs:
;	DS:DX Points to asciz name
; Returns:
;	STD XENIX Return
;	AX = chdir_path_not_found if error
;
;----------------------------------------------------------------------------

_$CHDIR:
	MOV	DI,OPENBUF		; spot for translated name
	MOV	SI,DX			; get source
	call	TransPath		; go munge the path and get real CDS
	JNC	short ChDirCrack	; no errors, try path
ChDirErrP:
	;mov	al,3
	MOV	AL,error_path_not_found
ChDirErr:
	;jmp	SYS_RET_ERR 	; oops!
	; 10/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	jmp	short chdir_errj

ChDirCrack:
	CMP	byte [CMETA],-1		; No meta chars allowed.
	JNZ	short ChDirErrP

; We cannot do a ChDir (yet) on a raw CDS. This is treated as a path not
; found.

	LES	DI,[THISCDS]
	CMP	DI,-1			;   if (ThisCDS == NULL)
	JZ	short ChDirErrP		;	error ();

; Find out if the directory exists.

	call	DOS_CHDIR
	;Jc	short ChDirErr
	; 16/12/2022
	jc	short chdir_errj
;
; Get back CDS to see if a join as seen. Set the currency pointer (only if
; not network). If one was seen, all we need to do is copy in the text
;
	LES	DI,[THISCDS]
	;test	word [es:di+43h],2000h
	; 17/12/2022
	test	byte [ES:DI+curdir.flags+1],curdir_splice>>8
	;TEST	word [ES:DI+curdir.flags],curdir_splice
	JZ	short GotCDS

; The CDS was joined. Let's go back and grab the logical CDS.

	push	es	
	push	di
	push	cx			; save CDS and cluster...
	call	Get_User_Stack		; get original text
	
	;mov	di,[si+6]
	MOV	DI,[SI+user_env.user_DX]
	;mov	ds,[si+0Eh]
	MOV	DS,[SI+user_env.user_DS]
	
	MOV	SI,OPENBUF		; spot for translated name
	XCHG	SI,DI
	XOR	AL,AL			; do no splicing
	push	di
	call	TransPathNoSet		; Munge path
	pop	si

; There should NEVER be an error here.

;IF FALSE
;	JNC SKipErr
;	fmt <>,<>,<"$p: Internal CHDIR error\n">
;SkipErr:
;ENDIF
	LES	DI,[THISCDS]		; get new CDS
	;mov	word [es:di+49h],-1
	MOV	word [ES:DI+curdir.ID],-1
					; no valid cluster here...
	pop	cx
	pop	di
	pop	es

; ES:DI point to the physical CDS, CX is the ID (local only)

GotCDS:

; wfp_start points to the text. See if it is long enough

	; MSDOS 3.3
	;push	ss
	;pop	ds
	;mov	si,[WFP_START]
	;push	cx
	;call	DStrLen
	;cmp	cx,67 ; cmp cx,DIRSTRLEN
	;pop	cx
	;ja	short ChDirErrP

	; MSDOS 6.0
	CALL	Check_PathLen		;PTM.		;AN000;
	JA	short ChDirErrP
	; MSDOS 3.3 & MSDOS 6.0
	;TEST	word [ES:DI+curdir.flags],curdir_isnet ; 8000h
	; 17/12/2022
	test	byte [ES:DI+curdir.flags+1],curdir_isnet>>8
	JNZ	short SkipRecency
	; MSDOS 6.0
	;test	word [es:di+43h],2000h
	; 17/12/2022
	test	byte [ES:DI+curdir.flags+1],curdir_splice>>8
	;TEST	word [ES:DI+curdir.flags],curdir_splice 
					;PTM. for Join and Subst ;AN000;
	JZ	short setdirclus	;PTM.		;AN000;
	MOV	CX,-1			;PTM.		;AN000;
setdirclus:
	;mov	[es:di+49h],cx
	MOV	[ES:DI+curdir.ID],CX
	LES	DI,[THISCDS]		; get logical CDS
SkipRecency:
	call	FStrCpy
	XOR	AL,AL
mkdir_ok:
	jmp	SYS_RET_OK

; 17/05/2019 - Retro DOS v4.0

; DOSCODE:60E1h (MSDOS 6.21, MSDOS.SYS)

;BREAK <$MkDir - Make a directory entry>
;---------------------------------------------------------------------------
;
; Procedure Name : $MkDir
; Inputs:
;	DS:DX Points to asciz name
; Function:
;	Make a new directory
; Returns:
;	STD XENIX Return
;	AX = mkdir_path_not_found if path bad
;	AX = mkdir_access_denied  If
;		Directory cannot be created
;		Node already exists
;		Device name given
;		Disk or directory(root) full
;---------------------------------------------------------------------------

	; 10/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)

_$MKDIR:
	MOV	SI,DOS_MKDIR
DoDirCall:
	MOV	DI,OPENBUF		; spot for translated name

	push	si
	MOV	SI,DX			; get source
	call	TransPath		; go munge the path
	pop	si
	JNC	short MkDirCrack	; no errors, try path
MkErrP:
	MOV	AL,error_path_not_found	; oops!
MkErr:
	jmp	SYS_RET_ERR
MkDirCrack:
	CMP	byte [SS:CMETA],-1
	JNZ	short MkErrP

	; MSDOS 3.3
	;push	ss
	;pop	ds
	;call	si
	;jb	short MkErr
	;;jmp	short mkdir_ok
	;jmp	SYS_RET_OK

	; MSDOS 6.0
	PUSH	SI			;PTM.			;AN000;
	CALL	Check_PathLen		;PTM. check path len > 67 ? ;AN000;
	POP	SI			;PTM.			;AN000;
	JBE	short pathok		;PTM.			;AN000;
	;mov	al,5
	MOV	AL,error_access_denied	;PTM. ops!
	;jmp	SYS_RET_ERR		;PTM.
	jmp	short MkErr
pathok:
	CALL	SI			; go get file
	JC	short MkErr		; no errors
	; 16/12/2022
	; 10/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	jmp	short mkdir_ok
	;jmp	SYS_RET_OK

;----------------------------------------------------------------------------
;
; Procedure Name : Check_PathLen
;
; Inputs:
;	nothing
; Function:
;	check if final path length greater than 67
; Returns:
;	Above flag set if > 67
;
;---------------------------------------------------------------------------

Check_PathLen:
	; 09/09/2018
	;mov	SI,[WFP_START]
	MOV	SI,[SS:WFP_START] ; MSDOS 6.0
Check_PathLen2:
	push	ss
	pop	ds
	;mov	SI,[WFP_START]	  ; MSDOS 3.3
	push	CX	
	CALL	DStrLen
	CMP	CX,DIRSTRLEN ; 67
	POP	CX
	retn

;============================================================================
; IOCTL.ASM, MSDOS 6.0, 1991
;============================================================================
; 07/08/2018 - Retro DOS v3.0
; 17/05/2019 - Retro DOS v4.0

;**	IOCTL system call.
;----------------------------------------------------------------------------
;	$IOCTL
;
;	  Revision history:
;
;		Created: ARR 4 April 1983
;
;		GenericIOCTL added:		KGS	22 April 1985
;
;		A000	version 4.00	Jan. 1988
;
;		Used jump table to dispatch IOCTL functions. HKN 3/12/90
;

;BREAK <IOCTL - munge on a handle to do device specific stuff>
;---------------------------------------------------------------------------
;
;   Assembler usage:
;	    MOV     BX, Handle
;	    MOV     DX, Data
;
;	(or LDS     DX,BUF
;	    MOV     CX,COUNT)
;
;	    MOV     AH, Ioctl
;	    MOV     AL, Request
;	    INT     21h
;
;   AH = 0  Return a combination of low byte of sf_flags and device driver
;	    attribute word in DX, handle in BX:
;	    DH = high word of device driver attributes
;	    DL = low byte of sf_flags
;	 1  Set the bits contained in DX to sf_flags.  DH MUST be 0.  Handle
;	    in BX.
;	 2  Read CX bytes from the device control channel for handle in BX
;	    into DS:DX.  Return number read in AX.
;	 3  Write CX bytes to the device control channel for handle in BX from
;	    DS:DX.  Return bytes written in AX.
;	 4  Read CX bytes from the device control channel for drive in BX
;	    into DS:DX.  Return number read in AX.
;	 5  Write CX bytes to the device control channel for drive in BX from
;	    DS:DX.  Return bytes written in AX.
;	 6  Return input status of handle in BX. If a read will go to the
;	    device, AL = 0FFh, otherwise 0.
;	 7  Return output status of handle in BX. If a write will go to the
;	    device, AL = 0FFh, otherwise 0.
;	 8  Given a drive in BX, return 1 if the device contains non-
;	    removable media, 0 otherwise.
;	 9  Return the contents of the device attribute word in DX for the
;	    drive in BX.  0200h is the bit for shared.	1000h is the bit for
;	    network. 8000h is the bit for local use.
;	 A  Return 8000h if the handle in BX is for the network or not.
;	 B  Change the retry delay and the retry count for the system. BX is
;	    the count and CX is the delay.
;
;   Error returns:
;	    AX = error_invalid_handle
;	       = error_invalid_function
;	       = error_invalid_data
;
;-------------------------------------------------------------------------------
;
;   This is the documentation copied from DOS 4.0 it is much better
;   than the above
;
;	There are several basic forms of IOCTL calls:
;
;
;	** Get/Set device information:	**
;
;	ENTRY	(AL) = function code
;		  0 - Get device information
;		  1 - Set device information
;		(BX) = file handle
;		(DX) = info for "Set Device Information"
;	EXIT	'C' set if error
;		  (AX) = error code
;		'C' clear if OK
;		  (DX) = info for "Get Device Information"
;	USES	ALL
;
;
;	**  Read/Write Control Data From/To Handle  **
;
;	ENTRY	(AL) = function code
;		  2 - Read device control info
;		  3 - Write device control info
;		(BX) = file handle
;		(CX) = transfer count
;		(DS:DX) = address for data
;	EXIT	'C' set if error
;		  (AX) = error code
;		'C' clear if OK
;		  (AX) = count of bytes transfered
;	USES	ALL
;
;
;	**  Read/Write Control Data From/To Block Device  **
;
;	ENTRY	(AL) = function code
;		  4 - Read device control info
;		  5 - Write device control info
;		(BL) = Drive number (0=default, 1='A', 2='B', etc)
;		(CX) = transfer count
;		(DS:DX) = address for data
;	EXIT	'C' set if error
;		  (AX) = error code
;		'C' clear if OK
;		  (AX) = count of bytes transfered
;	USES	ALL
;
;
;	**  Get Input/Output Status  **
;
;	ENTRY	(AL) = function code
;		  6 - Get Input status
;		  7 - Get Output Status
;		(BX) = file handle
;	EXIT	'C' set if error
;		  (AX) = error code
;		'C' clear if OK
;		  (AL) = 00 if not ready
;		  (AL) = FF if ready
;	USES	ALL
;
;
;	**  Get Drive Information  **
;
;	ENTRY	(AL) = function code
;		  8 - Check for removable media
;		  9 - Get device attributes
;		(BL) = Drive number (0=default, 1='A', 2='B', etc)
;	EXIT	'C' set if error
;		  (AX) = error code
;		'C' clear if OK
;		  (AX) = 0/1 media is removable/fixed (func. 8)
;		  (DX) = device attribute word (func. 9)
;	USES	ALL
;
;
;	**  Get Redirected bit	**
;
;	ENTRY	(AL) = function code
;		  0Ah - Network stuff
;		(BX) = file handle
;	EXIT	'C' set if error
;		  (AX) = error code
;		'C' clear if OK
;		  (DX) = SFT flags word, 8000h set if network file
;	USES	ALL
;
;
;	**  Change sharer retry parameters  **
;
;	ENTRY	(AL) = function code
;		  0Bh - Set retry parameters
;		(CX) = retry loop count
;		(DX) = number of retries
;	EXIT	'C' set if error
;		  (AX) = error code
;		'C' clear if OK
;	USES	ALL
;
;
;   =================================================================
;
;	**  New Standard Control  **
;
;	ALL NEW IOCTL FACILITIES SHOULD USE THIS FORM.	THE OTHER
;	FORMS ARE OBSOLETE.
;
;   =================================================================
;
;	ENTRY	(AL) = function code
;		  0Ch - Control Function subcode
;		(BX) = File Handle
;		(CH) = Category Indicator
;		(CL) = Function within category
;		(DS:DX) = address for data, if any
;		(SI) = Passed to device as argument, use depends upon function
;		(DI) = Passed to device as argument, use depends upon function
;	EXIT	'C' set if error
;		  (AX) = error code
;		'C' clear if OK
;		  (SI) = Return value, meaning is function dependent
;		  (DI) = Return value, meaning is function dependent
;		  (DS:DX) = Return address, use is function dependent
;	USES	ALL
;
;    ============== Generic IOCTL Definitions for DOS 3.2 ============
;     (See inc\ioctl.inc for more info)
;
;	ENTRY	(AL) = function code
;		  0Dh - Control Function subcode
;		(BL) = Drive Number (0 = Default, 1= 'A')
;		(CH) = Category Indicator
;		(CL) = Function within category
;		(DS:DX) = address for data, if any
;		(SI) = Passed to device as argument, use depends upon function
;		(DI) = Passed to device as argument, use depends upon function
;
;	EXIT	'C' set if error
;		  (AX) = error code
;		'C' clear if OK
;		  (DS:DX) = Return address, use is function dependent
;	USES	ALL
;
;---------------------------------------------------------------------------
	
	; 17/05/2019 - Retro DOS v4.0
	; DOSCODE:611Eh (MSDOS 6.21, MSDOS.SYS)

	; 11/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; DOSCODE:610Ah (MSDOS 5.0, MSDOS.SYS)

IOCTLJMPTABLE:	;label	word
	; MSDOS 3.3 (& MSDOS 6.0)
	dw	ioctl_getset_data	; 0
	dw	ioctl_getset_data   	; 1
	dw	ioctl_control_string	; 2
	dw	ioctl_control_string	; 3
	dw	ioctl_get_dev		; 4
	dw	ioctl_get_dev		; 5
	dw	ioctl_status		; 6
	dw	ioctl_status		; 7
	dw	ioctl_rem_media		; 8
	dw	ioctl_drive_attr	; 9
	dw	ioctl_handle_redir	; A
	dw	Set_Retry_Parameters	; B
	dw	GENERICIOCTLHANDLE	; C
	dw	GENERICIOCTL		; D
	; MSDOS 6.0 (& MSDOS 3.3)
	dw	ioctl_drive_owner	; E
	dw	ioctl_drive_owner	; F
	; MSDOS 6.0
	dw	query_handle_support	; 10h
	dw	query_device_support	; 11h

	; 11/11/2022
_$IOCTL:
	MOV	SI,DS			; Stash DS for calls 2,3,4 and 5
	push	ss
	pop	ds			;hkn; SS is DOSDATA

	; MSDOS 3.3
	;cmp	al,0Fh 
	; MSDOS 6.0
	cmp	al,11h			; al must be between 0 & 11h
	ja	short ioctl_bad_funj2	; if not bad function #

	; 14/01/2024
	; 28/05/2019
	;push	AX	; 14/01/2024	; Need to save AL for generic IOCTL
	mov	di,ax			; di NOT a PARM
	and	di,0FFh			; di = al
	shl	di,1			; di = index into jmp table
	;pop	AX			; Restore AL for generic IOCTL

	jmp	word [CS:DI+IOCTLJMPTABLE]

ioctl_bad_funj2:
	JMP	ioctl_bad_fun  ; 10/08/2018

;--------------------------------------------------------------------------
;
; IOCTL: AL = 0,1
;
; ENTRY: DS = DOSDATA
;
;--------------------------------------------------------------------------

ioctl_getset_data:
	; MSDOS 6.0
	call	SFFromHandle		; ES:DI -> SFT
	JNC	short ioctl_check_permissions ; have valid handle
ioctl_bad_handle:
	;mov	al,6
	mov	al,error_invalid_handle
ioctl_error:
	jmp	SYS_RET_ERR

ioctl_check_permissions:
	CMP	AL,0
	;mov	al,[es:di+5]
	MOV	AL,[ES:DI+SF_ENTRY.sf_flags]; Get low byte of flags
	JZ	short ioctl_read	; read the byte

	or	dh,dh
	JZ	short ioctl_check_device ; can I set with this data?
	;mov	al,0Dh
	mov	al,error_invalid_data	; no DH <> 0
	;jmp	SYS_RET_ERR
	jmp	short ioctl_error

ioctl_check_device:
	test	AL,devid_device  ; 80h	; can I set this handle?
	jz	short ioctl_bad_funj2
	OR	DL,devid_device 	; Make sure user doesn't turn off the
					;   device bit!! He can muck with the
					;   others at will.
	MOV	byte [EXTERR_LOCUS],errLOC_SerDev ; 4
	MOV	BYTE [ES:DI+SF_ENTRY.sf_flags],DL  ;AC000;MS.; Set flags
ioctl_ok:
	jmp	SYS_RET_OK

ioctl_read:
	MOV	byte [EXTERR_LOCUS],errLOC_Disk  ; 2
	XOR	AH,AH
	test	AL,devid_device 	; Should I set high byte
	JZ	short ioctl_no_high	; no
	MOV	byte [EXTERR_LOCUS],errLOC_SerDev ; 4
	;les	di,[es:di+7]
	LES	DI,[ES:DI+SF_ENTRY.sf_devptr] ; Get device pointer
	;mov	ah,[es:di+5]
	MOV	AH,[ES:DI+SYSDEV.ATT+1] ; Get high byte
ioctl_no_high:
	MOV	DX,AX
ioctl_set_dx:	; 16/12/2022
	call	Get_User_Stack
	;mov	[si+6],dx
	MOV	[SI+user_env.user_DX],DX
	;;jmp	SYS_RET_OK
	; 11/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
ioctl_ok_j:
	; 16/12/2022
	jmp	SYS_RET_OK_clc	 ; (after 'Get_User_Stack') 
	;jmp	short ioctl_ok
	; 26/07/2019
	;jmp	SYS_RET_OK_clc

;--------------------------------------------------------------------------
;
; IOCTL: AL = 2,3
;
; ENTRY: DS = DOSDATA
;	 SI = user's DS
;
;--------------------------------------------------------------------------

	; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
ioctl_control_string:
	call	SFFromHandle		; ES:DI -> SFT
	JC	short ioctl_bad_handle	; invalid handle
	; 07/12/2022
	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device ; can I?
	;jz	short ioctl_bad_funj2			; No it is a file
	; MSDOS 5.0 & MSDOS 6.0
	test	byte [ES:DI+SF_ENTRY.sf_flags],devid_device ; can I?
	jz	short ioctl_bad_funj2			; No it is a file
	MOV	byte [EXTERR_LOCUS],errLOC_SerDev
	LES	DI,[ES:DI+SF_ENTRY.sf_devptr] ; Get device pointer
	XOR	BL,BL			; Unit number of char dev = 0
	JMP	ioctl_do_string

;--------------------------------------------------------------------------
;
; IOCTL: AL = 6,7
;
; ENTRY: DS = DOSDATA
;
;--------------------------------------------------------------------------

ioctl_status:
	MOV	AH,1
	SUB	AL,6			; 6=0,7=1
	JZ	short ioctl_get_status
	MOV	AH,3
ioctl_get_status:
	PUSH	AX
	call	GET_IO_SFT
	POP	AX
	;JNC	short DO_IOFUNC
	;JMP	short ioctl_bad_handle	; invalid SFT
	; 16/12/2022
	jc	short ioctl_bad_handle
DO_IOFUNC:
	call	IOFUNC
	MOV	AH,AL
	MOV	AL,0FFH
	;JNZ	short ioctl_status_ret
	; 29/01/2024
	jnz	short ioctl_ok
	INC	AL
ioctl_status_ret:
	;jmp	SYS_RET_OK
	; 11/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;jmp	short ioctl_ok_j
	; 16/12/2022
	jmp	short ioctl_ok

;--------------------------------------------------------------------------
;
; IOCTL: AL = B
;
; ENTRY: DS = DOSDATA
;
;--------------------------------------------------------------------------

Set_Retry_Parameters:
	; 09/09/2018
	MOV	[RetryLoop],CX		; 0 retry loop count allowed
	OR	DX,DX			; zero retries not allowed
	JZ	short ioctl_bad_fun
	MOV	[RetryCount],DX		; Set new retry count
doneok:
	;jmp	SYS_RET_OK		; Done
	; 11/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;jmp	short ioctl_status_ret
	; 16/12/2022
	jmp	short ioctl_ok	 ; jmp SYS_RET_OK

;--------------------------------------------------------------------------
;
; Generic IOCTL entry point. AL = C, D, 10h, 11h
;
;	here we invoke the Generic IOCTL using the IOCTL_Req structure.
;	SI:DX -> Users Device Parameter Table
;	IOCALL -> IOCTL_Req structure
;
; 	If on entry AL >= IOCTL_QUERY_HANDLE the function is a
;	QueryIOCtlSupport call ELSE it's a standard generic IOCtl
;	call.
;
; BUGBUG: Don't push anything on the stack between GENERIOCTL: and 
;         the call to Check_If_Net because Check_If_Net gets our
;         return address off the stack if the drive is invalid.
;
;--------------------------------------------------------------------------

query_handle_support:	; Entry point for handles
GENERICIOCTLHANDLE:
	call	SFFromHandle		; Get SFT for device.
	jc	short ioctl_bad_handlej

	;test	word [es:di+5],8000h
	;TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet	; M031;
	;test	byte [es:di+6],80h
	test	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
	jnz	short ioctl_bad_fun	; Cannot do this over net.

	mov	byte [EXTERR_LOCUS],errLOC_SerDev ; 4
	;les	di,[es:di+7]
	les	di,[es:di+SF_ENTRY.sf_devptr]	; Get pointer to device.
	jmp	short Do_GenIOCTL

query_device_support:	; Entry point for devices:
GENERICIOCTL:
	mov	byte [EXTERR_LOCUS],errLOC_Disk ; 2
	cmp	ch,IOC_DC ; 8		; Only disk devices are allowed to use
	jne	short ioctl_bad_fun	; no handles with Generic IOCTL.

	CALL	Check_If_Net		; ES:DI := Get_hdr_block of device in BL
	JNZ	short ioctl_bad_fun	; There are no "net devices", and they

Do_GenIOCTL:
	;TEST	word [ES:DI+SYSDEV.ATT],DEV320 
					; Can device handle Generic IOCTL funcs
	; 09/09/2018
	;test	byte [es:di+4],40h
	TEST	byte [ES:DI+SYSDEV.ATT],DEV320 ; 0040h
	jz	short ioctl_bad_fun

	; 17/05/2019 - Retro DOS v4.0

	; MSDOS 6.0
	;mov	byte [IOCALL_REQFUNC],19 ; 13h
	mov	byte [IOCALL_REQFUNC],GENIOCTL ; Assume real Request
	;cmp	al,10h
	cmp	AL,IOCTL_QUERY_HANDLE	; See if this is just a query
	jl	short SetIOCtlBlock
	
	;TEST	word [ES:DI+SYSDEV.ATT],IOQUERY ; See if device supports a query
	;test	byte [es:di+4],80h 
	TEST	byte [ES:DI+SYSDEV.ATT],IOQUERY ; See if device supports a query
	jz	short ioctl_bad_fun	; No support for query 
	;
	;mov	byte [IOCALL_REQFUNC],19h	
	mov	byte [IOCALL_REQFUNC],IOCTL_QUERY ; Just a query (5.00)

SetIOCtlBlock:
	PUSH	ES			; DEVIOCALL2 expects Device header block
	PUSH	DI			; in DS:SI
					; Setup Generic IOCTL Request Block
	;mov	byte [IOCALL_REQLEN],23
	mov	byte [IOCALL_REQLEN],IOCTL_REQ.size
	; 07/09/2018 (MSDOS 3.3)
	;;mov	byte [IOCALL_REQFUNC],19
	;mov	byte [IOCALL_REQFUNC],GENIOCTL ; 07/09/2018
	;
	MOV	[IOCALL_REQUNIT],BL
	MOV	[IOCALL+IOCTL_REQ.MAJORFUNCTION],CH
	MOV	[IOCALL+IOCTL_REQ.MINORFUNCTION],CL
	MOV	[IOCALL+IOCTL_REQ.REG_SI],SI
	MOV	[IOCALL+IOCTL_REQ.REG_DI],DI
	MOV	[IOCALL+IOCTL_REQ.GENERICIOCTL_PACKET],DX
	MOV	[IOCALL+IOCTL_REQ.GENERICIOCTL_PACKET+2],SI

;hkn; IOCALL is in DOSDATA
	MOV	BX,IOCALL

	PUSH	SS
	POP	ES
					; DS:SI -> Device header.
	POP	SI
	POP	DS
	; 10/08/2018
	jmp	ioctl_do_IO		; Perform Call to device driver

ioctl_bad_fun:
	mov	al, error_invalid_function  ; 1
	jmp	SYS_RET_ERR	

ioctl_bad_handlej:
	jmp	ioctl_bad_handle

;---------------------------------------------------------------------------
;
; IOCTL: AL = 8
;
; ENTRY: DS = DOSDATA
;
; BUGBUG: Don't push anything on the stack between ioctl_rem_media: and 
;         the call to Check_If_Net because Check_If_Net gets our
;         return address off the stack if the drive is invalid.
;
;-------------------------------------------------------------------------

	; 30/01/2024
ioctl_rem_media:
	; MSDOS 3.3 (& MSDOS 6.0)
	CALL	Check_If_Net
	JNZ	short ioctl_bad_fun	; There are no "net devices", and they
					;   certainly don't know how to do this
					;   call.
	;test	word [es:di+4],800h
	;TEST	word [ES:DI+SYSDEV.ATT],DEVOPCL ; See if device can
	;test	byte [es:di+5],8
	TEST	byte [es:di+SYSDEV.ATT+1],(DEVOPCL>>8)
	JZ	short ioctl_bad_fun		; NO

;hkn; SS override for IOCALL
	; 30/01/2024
	; ds = ss = DOSDATA segment ('Get_Driver_BL' in 'Check_If_Net')
	;MOV	byte [SS:IOCALL_REQFUNC],DEVRMD ; 15
	mov	byte [IOCALL_REQFUNC],DEVRMD ; 15
	MOV	AL,REMHL  ; 13
	MOV	AH,BL			; Unit number
	;MOV	[SS:IOCALL_REQLEN],AX
	mov	[IOCALL_REQLEN],ax	
	XOR	AX,AX
	;MOV	[SS:IOCALL_REQSTAT],AX
	mov	[IOCALL_REQSTAT],ax ; 0
	
	PUSH	ES
	POP	DS
	MOV	SI,DI			; DS:SI -> driver
	PUSH	SS
	POP	ES

;hkn; IOCALL is in DOSDATA (msconst.asm)
	; 30/01/2024
	; (ds <> ss, ss = DOSDATA segment)
	MOV	BX,IOCALL		; ES:BX -> Call header
	push	ds
	push	si
	call	DEVIOCALL2
	pop	si
	pop	ds

;hkn; SS override
	MOV	AX,[SS:IOCALL_REQSTAT]	; Get Status word
	;AND	AX,STBUI ; 200h		; Mask to busy bit
	; 29/01/2024
	and	ah,STBUI>>8
	MOV	CL,9
	SHR	AX,CL			; Busy bit to bit 0
ioctl_da_ok_j:	; 11/11/2022
	jmp	SYS_RET_OK

;-------------------------------------------------------------------------
;
; IOCTL: AL = 9
;
; ENTRY: DS = DOSDATA
;
;-------------------------------------------------------------------------

ioctl_drive_attr:
	; MSDOS 3.3 (& MSDOS 6.0)
	mov	al,bl
	call	GETTHISDRV
	jc	short ioctl_drv_err
	call	Get_Driver_BL
	; MSDOS 6.0
	JC	short ioctl_drv_err	; drive not valid

	;mov	dx,[es:di+4]
	mov	dx,[es:di+SYSDEV.ATT]	
					; get device attribute word
	MOV	BL,AL			; Phys letter to BL (A=0)

;hkn; SS override
	;LES	DI,[SS:THISCDS]
	; 30/01/2024
	les	di,[THISCDS] ; (Get_Driver_BL)

	;test	word [es:di+43h],8000h
	;TEST	word [ES:DI+curdir.flags],curdir_isnet
	;test	byte [es:di+44h],80h
	TEST	byte [ES:DI+curdir.flags+1],(curdir_isnet>>8)
	JZ	short IOCTLShare

	;or	dx,1000h ; (MSDOS 3.3)

;	Net devices don't return a device attribute word.
;	Bit 12 = 1, meaning net device, all others = 0.

	MOV	DX,1000h ; MSDOS 6.0

IOCTLShare:
	; 30/01/2024
	; ds = ss = DOSDATA segment
	;push	ss
	;pop	ds

	MOV	SI,OPENBUF
	ADD	BL,"A"	; 41h
	MOV	[SI],BL
	MOV	WORD [SI+1],003AH ; ":",0
	MOV	AX,0300h
	CLC
	;INT	int_IBM
	int     2Ah	; Microsoft Networks - CHECK DIRECT I/O
			; DS:SI -> ASCIZ disk device name 
			; (may be full path or only drive
			; specifier--must include the colon)
			; Return: CF clear if absolute disk access allowed
	JNC	short IOCTLLocal	; Not shared
	;OR	DX,0200H		; Shared, bit 9
	; 17/12/2022
	or	dh,02h
IOCTLLocal:
	;test	word [es:di+43h],1000h
	;TEST	word [ES:DI+curdir.flags],curdir_local
	;test	byte [es:di+44h],10h
	TEST	byte [ES:DI+curdir.flags+1],(curdir_local>>8)
	;JZ	short ioctl_set_DX
	; 16/12/2022
	jz	short _ioctl_set_DX
	;OR	DX,8000h
	; 17/12/2022
	or	dh,80h
;ioctl_set_DX:
_ioctl_set_DX:
	; 16/12/2022
	jmp	ioctl_set_dx
; 16/12/2022
%if 0	
	call	Get_User_Stack
	MOV	[SI+user_env.user_DX],DX
	;;jmp	SYS_RET_OK
	;; 25/06/2019
	;jmp	SYS_RET_OK_clc
	; 11/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
ioctl_gd_ok_j:
	jmp	short ioctl_da_ok_j
%endif

ioctl_drv_err:
	mov	al,error_invalid_drive ; 0Fh
ioctl_gd_err_j:	; 11/11/2022
	jmp	SYS_RET_ERR

;--------------------------------------------------------------------------
;
; IOCTL: AL = A
;
; ENTRY: DS = DOSDATA
;
;--------------------------------------------------------------------------

ioctl_handle_redir:
	call	SFFromHandle		; ES:DI -> SFT
	JNC	short ioctl_got_sft	; have valid handle
	jmp	ioctl_bad_handle ; 10/08/2018

ioctl_got_sft:
	;mov	dx,[es:di+5]
	MOV	DX,[ES:DI+SF_ENTRY.sf_flags] ; Get flags
	;JMP	short ioctl_set_DX	; pass dx to user and return
	; 16/12/2022
	jmp	short _ioctl_set_DX

	; 16/12/2022
;ioctl_bad_funj:
	;JMP	ioctl_bad_fun

;--------------------------------------------------------------------------
;
; IOCTL: AL= 4,5
;
; ENTRY: DS = DOSDATA
;	 SI = user's DS
;
;
; BUGBUG: Don't push anything on the stack between ioctl_get_dev: and 
;         the call to Check_If_Net because Check_If_Net gets our
;         return address off the stack if the drive is invalid.
;
;-------------------------------------------------------------------------

ioctl_get_dev:
	CALL	Check_If_Net
	;JNZ	short ioctl_bad_funj	; There are no "net devices", and they
					; certainly don't know how to do this
					; call.
	; 16/12/2022
	jz	short ioctl_do_string
ioctl_bad_funj:
	JMP	ioctl_bad_fun

ioctl_do_string:
	;test	word [es:di+4],4000h
	;TEST	word [ES:DI+SYSDEV.ATT],DEVIOCTL; See if device accepts control
	;test	byte [es:di+5],40h
	TEST	byte [ES:DI+SYSDEV.ATT+1],(DEVIOCTL>>8)
	JZ	short ioctl_bad_funj		; NO
					; assume IOCTL read
	MOV	byte [IOCALL_REQFUNC],DEVRDIOCTL  ; 3

	TEST	AL,1			; is it func. 4/5 or 2/3
	JZ	short ioctl_control_call ; it is read. goto ioctl_control_call

					; it is an IOCTL write
	MOV	byte [IOCALL_REQFUNC],DEVWRIOCTL ; 12

ioctl_control_call:
	MOV	AL,DRDWRHL ; 22
ioctl_setup_pkt:
	MOV	AH,BL			; Unit number
	MOV	[IOCALL_REQLEN],AX
	XOR	AX,AX
	MOV	[IOCALL_REQSTAT],AX
	MOV	[IOMED],AL
	MOV	[IOSCNT],CX
	MOV	[IOXAD],DX
	MOV	[IOXAD+2],SI
	PUSH	ES
	POP	DS
	MOV	SI,DI			; DS:SI -> driver
	PUSH	SS
	POP	ES

	MOV	BX,IOCALL		; ES:BX -> Call header
ioctl_do_IO:
	call	DEVIOCALL2

;hkn; SS override for IOCALL
	;test	word [SS:IOCALL_REQSTAT],8000h
	;TEST	word [SS:IOCALL_REQSTAT],STERR ;Error?
	;test	byte [SS:IOCALL_REQSTAT+1],80h
	TEST	byte [SS:IOCALL_REQSTAT+1],(STERR>>8)
	JNZ	short ioctl_string_err

;hkn; SS override
	MOV	AX,[SS:IOSCNT]		; Get actual bytes transferred
	; 16/12/2022
	jmp	SYS_RET_OK
	; 11/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;jmp	short ioctl_gd_ok_j

ioctl_string_err:
	MOV	DI,[SS:IOCALL_REQSTAT]	;Get Error
device_err:
	AND	DI,STECODE ; 00FFh	; mask out irrelevant bits
	MOV	AX,DI
	call	SET_I24_EXTENDED_ERROR

;hkn; use SS override
;hkn;	mov	ax,[CS:EXTERR]
	mov	ax,[SS:EXTERR]
	;jmp	SYS_RET_ERR
	; 11/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	jmp	short ioctl_gd_err_j

; 17/05/2019 - Retro DOS v4.0

;--------------------------------------------------------------------------
; Proc name : Get_Driver_BL
;
;	DS is DOSDATA
;	BL is drive number (0=default)
;	Returns pointer to device in ES:DI, unit number in BL if carry clear
;	No regs modified
;
;---------------------------------------------------------------------------

	; 30/01/2024
Get_Driver_BL:
	PUSH	AX
	MOV	AL,BL			; Drive
	call	GETTHISDRV
	jc	short ioctl_bad_drv
	XOR	BL,BL			; Unit zero on Net device
	MOV	byte [EXTERR_LOCUS],errLOC_Net ; 3
	LES	DI,[THISCDS]
	;test	word [es:di+43h],8000h
	;TEST	word [ES:DI+curdir.flags],curdir_isnet
	;test	byte [es:di+44h],80h
	TEST	byte [ES:DI+curdir.flags+1],(curdir_isnet>>8)
	;les	di,[es:di+45h]
	LES	DI,[ES:DI+curdir.devptr] ; ES:DI -> Dpb or net dev
	JNZ	short got_dev_ptr	 ; Is net
	MOV	byte [EXTERR_LOCUS],errLOC_Disk ; 2
	;mov	bl,[es:di+1]
	MOV	BL,[ES:DI+DPB.UNIT]	; Unit number
	;les	di,[es:di+13h]
	LES	DI,[ES:DI+DPB.DRIVER_ADDR] ; Driver addr
got_dev_ptr:
	; 30/01/2024
	; cf=0
	;CLC
ioctl_bad_drv:
	POP	AX
	retn

;-------------------------------------------------------------------------
; Proc Name : Check_If_Net:
;
;
; Checks if the device is over the net or not. Returns result in ZERO flag.
; If no device is found, the return address is popped off the stack, and a
; jump is made to ioctl_drv_err.
;
; On Entry:
; Registers same as those for Get_Driver_BL
;
; On Exit:
; ZERO flag	- set if not a net device
;		- reset if net device
; ES:DI -> the device
;
;
; BUGBUG: This function assumes the following stack setup on entry
;
;	  SP+2 -> Error return address
;	  SP   -> Normal return address
;
;-------------------------------------------------------------------------

	; 30/01/2024 - Retro DOS v5.0
	; MSDOS 6.22 MSDOS.SYS - DOSCODE:639Ch
	; PCDOS 7.1 IBMDOS.COM - DOSCODE:6A91h
	; Windows ME IO.SYS - BIOSCODE:68E1h

Check_If_Net:
	; MSDOS 3.3 (& MSDOS 6.0)
	CALL	Get_Driver_BL
	JC	short ioctl_drv_err_pop	; invalid drive letter

; 30/01/2024 ('Get_Driver_BL' returns with
;	      'curdir_isnet' condition/ZF, no need to a second test)
%if 0
	;;;
	; (PCDOS 7.1 IBMDOS.COM, Windows ME IO.SYS)
	PUSH	ES
	PUSH	DI
	LES	DI,[THISCDS]
	;test	word [es:di+43h],8000h
	;TEST	word [ES:DI+curdir.flags],curdir_isnet
	;test	byte [es:di+44h],80h
	TEST	byte [ES:DI+curdir.flags+1],(curdir_isnet>>8)
	POP	DI
	POP	ES
	;;;
%endif
	retn

ioctl_drv_err_pop:
	pop	ax			; pop off return address
	jmp	ioctl_drv_err

ioctl_bad_funj3:
	jmp	ioctl_bad_fun

ioctl_string_errj:
	jmp	short ioctl_string_err  ; 25/05/2019

;--------------------------------------------------------------------------
;
; IOCTL: AL = E, F
;
; ENTRY: DS = DOSDATA
;
;
; BUGBUG: Don't push anything on the stack between ioctl_drive_owner: and 
;         the call to Check_If_Net because Check_If_Net gets our
;         return address off the stack if the drive is invalid.
;
;--------------------------------------------------------------------------

ioctl_drive_owner:
	; MSDOS 3.3 (& MSDOS 6.0)
	Call	Check_If_Net
	JNZ	short ioctl_bad_funj3 	; There are no "net devices", and they
					;   certainly don't know how to do this
					;   call.
	;TEST	word [ES:DI+SYSDEV.ATT],DEV320	; See if device can handle this
	; 09/09/2018
	;test	byte [es:di+4],40h
	TEST	byte [ES:DI+SYSDEV.ATT],DEV320 ; 0040h
	JZ	short ioctl_bad_funj3 	; NO
	;mov	byte [IOCALL_REQFUNC],23
	mov	byte [IOCALL_REQFUNC],DEVGETOWN	; default to get owner
	cmp	al,0Eh			; Get Owner ?
	jz	short GetOwner
SetOwner:
	MOV	byte [IOCALL_REQFUNC],DEVSETOWN ; 24
GetOwner:
	MOV	AL,OWNHL ; 13
	MOV	AH,BL			; Unit number
	MOV	[IOCALL_REQLEN],AX
	XOR	AX,AX
	MOV	[IOCALL_REQSTAT],AX
	PUSH	ES
	POP	DS
	MOV	SI,DI			; DS:SI -> driver
	PUSH	SS
	POP	ES
	MOV	BX,IOCALL		; ES:BX -> Call header
	push	ds
	push	si
	call	DEVIOCALL2
	pop	si
	pop	ds
;hkn; SS override
	;TEST	word [SS:IOCALL_REQSTAT],STERR ;Error?
	;test	byte [SS:IOCALL_REQSTAT+1],80h
	TEST	byte [SS:IOCALL_REQSTAT+1],(STERR>>8)
	jnz	short ioctl_string_errj
	MOV	AL,[SS:IOCALL_REQUNIT]	; Get owner returned by device
					; owner returned is 1-based.
	jmp	SYS_RET_OK

;============================================================================
; DELETE.ASM, MSDOS 6.0, 1991
;============================================================================
; 07/08/2018 - Retro DOS v3.0
; 17/05/2019 - Retro DOS v4.0

;	TITLE	DOS_DELETE - Internal DELETE call for MS-DOS
;	NAME	DOS_DELETE

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	DELETE.ASM - Low level routine for deleting files
;----------------------------------------------------------------------------
;		DOS_DELETE
;		REN_DEL_Check
;		FastOpen_Delete	       ; DOS 3.3
;		FastOpen_Update	       ; DOS 3.3

;   Revision history:
;
;   A000  version 4.00	Jan. 1988
;   A001  Fastopen Rename fix	April 1989

;Installed = TRUE

;	i_need	NoSetDir,BYTE
;	i_need	Creating,BYTE
;	i_need	DELALL,BYTE
;	i_need	THISDPB,DWORD
;	i_need	THISSFT,DWORD
;	i_need	THISCDS,DWORD
;	i_need	CURBUF,DWORD
;	i_need	ATTRIB,BYTE
;	i_need	SATTRIB,BYTE
;	i_need	WFP_START,WORD
;	i_need	REN_WFP,WORD			 ;BN001
;	i_need	NAME1,BYTE			 ;BN001
;	i_need	FoundDel,BYTE
;	i_need	AUXSTACK,BYTE
;	i_need	VOLCHNG_FLAG,BYTE
;	i_need	JShare,DWORD
;	i_need	FastOpenTable,BYTE		  ; DOS 3.3
;	i_need	FastTable,BYTE			  ; DOS 4.00
;
;	i_need	Del_ExtCluster,WORD		  ; DOS 4.00
;
;	i_need	SAVE_BX,WORD			  ; DOS 4.00
;	i_need	DMAADD,DWORD
;	i_need	RENAMEDMA,BYTE

;----------------------------------------------------------------------------
;
; Procedure Name : DOS_DELETE
;
; Inputs:
;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
;		terminated)
;	[CURR_DIR_END] Points to end of Current dir part of string
;		( = -1 if current dir not involved, else
;		 Points to first char after last "/" of current dir part)
;	[THISCDS] Points to CDS being used
;		(Low word = -1 if NUL CDS (Net direct request))
;	[SATTRIB] Is attribute of search, determines what files can be found
; Function:
;	Delete the specified file(s)
; Outputs:
;	CARRY CLEAR
;		OK
;	CARRY SET
;	    AX is error code
;		error_file_not_found
;			Last element of path not found
;		error_path_not_found
;			Bad path (not in curr dir part if present)
;		error_bad_curr_dir
;			Bad path in current directory part of path
;		error_access_denied
;			Attempt to delete device or directory
;		***error_sharing_violation***
;			Deny both access required, generates an INT 24.
;			This error is NOT returned. The INT 24H is generated,
;			  and the file is ignored (not deleted). Delete will
;			  simply continue on looking for more files.
;			  Carry will NOT be set in this case.
; DS preserved, others destroyed
;
;----------------------------------------------------------------------------

FILEFOUND   equ 01h
FILEDELETED equ 10h


	; 12/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; DOSCODE:63E9h (MSDOS 5.0, MSDOS.SYS)

	; 30/01/2024

DOS_DELETE:

;hkn; DOS_Delete is called from file.asm and fcbio.asm. DS has been set up 
;hkn; appropriately at this point.

	call	TestNet
	JNC	short LOCAL_DELETE

;IF NOT Installed
;	transfer NET_DELETE
;ELSE
	;MOV	AX,(MultNET SHL 8) | 19
	;INT	2FH
	;return

	mov	ax,1113h
	int     2Fh 	; Multiplex - NETWORK REDIRECTOR - DELETE REMOTE FILE
			; SS = DS = DOS CS, SDA first filename pointer -> 
			;		fully-qualified filename in DOS CS
			; SDA CDS pointer -> current directory structure for drive with file
			; Return: CF set on error
	retn
;ENDIF

LOCAL_DELETE:
	MOV	byte [FOUNDDEL],0	; No files found and no files deleted
	call	ECritDisk
	;mov	word [CREATING],0E500h
	MOV	WORD [CREATING],DIRFREE*256+0 ; Assume not del *.*
	MOV	SI,[WFP_START]
SKPNUL:
	LODSB
	OR	AL,AL
	JNZ	short SKPNUL		; go to end
	SUB	SI,4			; Back over possible "*.*"
	CMP	WORD [SI],2E2Ah ; "*."
	JNZ	short TEST_QUEST
	CMP	BYTE [SI+2],"*"
	JZ	short CHECK_ATTS
TEST_QUEST:
	SUB	SI,9		; Back over possible "????????.???"
	XCHG	DI,SI

	push	ss
	;pop	ds ; ! Retro DOS v3.0 BUG !
	pop	es ; 17/05/2019

	MOV	AX,"??" ; 3F3Fh
	MOV	CX,4		; four sets of "??"
	REPE	SCASW
	JNZ	short NOT_ALL
	XCHG	DI,SI
	LODSW
	CMP	AX,3F2Eh ; ".?"
	JNZ	short NOT_ALL
	LODSW
	CMP	AX,"??"
	JNZ	short NOT_ALL
CHECK_ATTS:
	MOV	AL,[SATTRIB]
	;and	al,1Fh
	AND	AL,attr_hidden+attr_system+attr_directory+attr_volume_id+attr_read_only
					; Look only at hidden bits
	;cmp	al,1Fh
	CMP	AL,attr_hidden+attr_system+attr_directory+attr_volume_id+attr_read_only
					; All must be set
	JNZ	short NOT_ALL

; NOTE WARNING DANGER-----
;    This DELALL stuff is not safe. It allows directories to be deleted.
;	It should ONLY be used by FORMAT in the ROOT directory.

	MOV	byte [DELALL],0		; DEL *.* - flag deleting all
NOT_ALL:
	MOV	byte [NoSetDir],1
	call	GetPathNoSet
	JNC	short Del_found
	JNZ	short _bad_path
	OR	CL,CL
	JZ	short _bad_path
No_file:
	MOV	AX,error_file_not_found
ErrorReturn:
	STC
	;call	LCritDisk
	;retn
	; 18/12/2022
	jmp	LCritDisk

_bad_path:
	MOV	AX,error_path_not_found
	JMP	short ErrorReturn

Del_found:
	JNZ	short NOT_DIR		; Check for dir specified
	CMP	byte [DELALL],0		; DelAll = 0 allows delete of dir.
	JZ	short NOT_DIR
Del_access_err:
	MOV	AX,error_access_denied
	JMP	short ErrorReturn

NOT_DIR:
	OR	AH,AH			; Check if device name
	JS	short Del_access_err	; Can't delete I/O devices

; Main delete loop. CURBUF+2:BX points to a matching directory entry.

DELFILE:
	OR	byte [FOUNDDEL],FILEFOUND ; file found, not deleted yet

; If we are deleting the Volume ID, then we set VOLUME_CHNG flag to make
; DOS issue a build BPB call the next time this drive is accessed.

	PUSH	DS
	MOV	AH,[DELALL]
	LDS	DI,[CURBUF]
	
;hkn; SS override
	TEST	byte [SS:ATTRIB],attr_read_only ; are we deleting RO files too?
	JNZ	short DoDelete		; yes

	TEST	byte [BX+dir_entry.dir_attr],attr_read_only
	JZ	short DoDelete		; not read only

	; 30/01/2024 (PCDOS 7.1 IBMDOS.COM)
Skip_it:
	POP	DS
	JMP	SHORT DELNXT		; Skip it (Note ES:BP not set)

DoDelete:
	call	REN_DEL_Check		; Sets ES:BP = [THISDPB]
	;JNC	short DEL_SHARE_OK
	;POP	DS
	;JMP	SHORT DELNXT		; Skip it
	; 30/01/2024
	jc	short Skip_it

DEL_SHARE_OK:
	; 17/05/2019 - Retro DOS v4.0
	; MSDOS 6.0
	;test	byte [di+5],40h
	TEST	byte [DI+BUFFINFO.buf_flags],buf_dirty
					;LB. if already dirty		  ;AN000;
	JNZ	short yesdirty		;LB.  don't increment dirty count ;AN000;
	call	INC_DIRTY_COUNT		;LB.				  ;AN000;
	;or	byte [di+5],40h
	OR	byte [DI+BUFFINFO.buf_flags],buf_dirty
yesdirty:
	mov	[bx],ah 
	;MOV	[BX+dir_entry.dir_name],AH ; Put in E5H or 0
	MOV	BX,[SI] 		; Get firclus pointer
	POP	DS
	OR	byte [FOUNDDEL],FILEDELETED ; 10h ; Deleted file

	CMP	BX,2
	JB	short DELNXT		; File has invalid FIRCLUS (too small)
	;cmp	bx,[es:bp+0Dh]
	CMP	BX,[ES:BP+DPB.MAX_CLUSTER]
	JA	short DELNXT		; File has invalid FIRCLUS (too big)

	call	RELEASE 		; Free file data
	JC	short No_fileJ

; DOS 3.3  FastOpen

	CALL	FastOpen_Delete 	; delete the dir info in fastopen

; DOS 3.3  FastOpen

DELNXT:
	LES	BP,[THISDPB]		; Possible to get here without this set
	call	GETENTRY		; Registers need to be reset
	JC	short No_fileJ
	call	NEXTENT
	JNC	short DELFILE
	LES	BP,[THISDPB]		; NEXTENT sets ES=DOSGROUP
	; 12/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;MOV	AL,[ES:BP+DPB.DRIVE]
	;;mov	al,[es:bp+0]
	; 15/12/2022
	MOV	AL,[ES:BP]
	call	FLUSHBUF
	JC	short No_fileJ
;
; Now we need to test FoundDel for our flags. The cases to consider are:
;
;   not found not deleted		file not found
;   not found	  deleted		*** impossible ***
;	found not deleted		access denied (read-only)
;	found	  deleted		no error
;
	TEST	byte [FOUNDDEL],FILEDELETED ; did we delete a file?
	JZ	short DelError		; no, figure out what's wrong.
; We set VOLCHNG_FLAG to indicate that we have changed the volume label
; and to force the DOS to issue a media check.
	TEST	byte [ATTRIB],attr_volume_id ; 8
	jz	short No_Set_Flag
	PUSH	AX
	PUSH	ES
	PUSH	DI
	LES	DI,[THISCDS]
	MOV	AH,[ES:DI]		; Get drive
	SUB	AH,'A'                  ; Convert to 0-based
	mov	[VOLCHNG_FLAG],AH
	
	; MSDOS 6.0
	XOR	BH,BH			;>32mb delete volume id from boot record ;AN000;
	call	Set_Media_ID		;>32mb set volume id to boot record	 ;AN000;
	 
	call	FATREAD_CDS		; force media check
	POP	DI
	POP	ES
	POP	AX
No_Set_Flag:
	;call	LCritDisk		; carry is clear
	;retn
	; 18/12/2022
	jmp	LCritDisk
DelError:
	TEST	byte [FOUNDDEL],FILEFOUND ; not deleted. Did we find file?
	JNZ	short Del_access_errJ 	; yes. Access denied
No_fileJ:
	JMP	No_file ; 10/08/2018 		; Nope
Del_access_errJ:
	JMP	Del_access_err ; 10/08/2018

; 08/08/2018 - Retro DOS v3.0

;Break	<REN_DEL_Check - check for access for rename and delete>
;---------------------------------------------------------------------------
; Procedure Name : REN_DEL_Check
;
; Inputs:
;	[THISDPB] set
;	[CURBUF+2]:BX points to entry
;	[CURBUF+2]:SI points to firclus field of entry
;	[WFP_Start] points to name
; Function:
;	Check for Exclusive access on given file.
;	  Used by RENAME, SET_FILE_INFO, and DELETE.
; Outputs:
;	ES:BP = [THISDPB]
;	NOTE: The WFP string pointed to by [WFP_Start] Will be Modified.  The
;		last element will be loaded from the directory entry.  This is
;		so the name given to the sharer doesn't have any meta chars in
;		it.
;	Carry set if sharing violation, INT 24H generated
;	    NOTE THAT AX IS NOT error_sharing_violation.
;		This is because input AX is preserved.
;		Caller must set the error if needed.
;	Carry clear
;		OK
; AX,DS,BX,SI,DI preserved
;---------------------------------------------------------------------------

REN_DEL_Check:

	PUSH	DS
	PUSH	DI
	PUSH	AX
	PUSH	BX
	PUSH	SI		; Save CURBUF pointers
	
	push	ss
	pop	es

;hkn; context ES will assume ES to DOSDATA
;hkn; ASSUME	ES:DOSGROUP

;hkn; SS override
	MOV	DI,[SS:WFP_START] ; ES:DI -> WFP
	MOV	SI,BX

;hkn; SS override
	MOV	DS,[SS:CURBUF+2] ; DS:SI -> entry (FCB style name)
	MOV	BX,DI		; Set backup limit for skipback
	;ADD	BX,2		; Skip over d: to point to leading '\'
	; 31/01/2024
	inc	bx
	inc	bx
	call	StrLen		; CX is length of ES:DI including NUL
	DEC	CX		; Don't include nul in count
	ADD	DI,CX		; Point to NUL at end of string
	call	SkipBack	; Back up one element
	INC	DI		; Point to start of last element

	; 17/05/2019 - Retro DOS v4.0
;hkn; SS override
	; MSDOS 6.0
	MOV	[SS:SAVE_BX],DI	;IFS. save for DOS_RENAME   ;AN000;
	;
	call	PackName	; Transfer name from entry to ASCIZ tail.
	POP	SI		; Get back entry pointers
	POP	BX
	PUSH	BX
	PUSH	SI		; Back on stack
	
	push	ss
	pop	ds

;hkn; context DS will assume ES to DOSDATA
;hkn; ASSUME	DS:DOSGROUP

; Close the file if possible by us.
;
;if installed
	Call	far [JShare+(13*4)] ; 13 = ShCloseFile
;else
;	Call	ShCloseFile
;endif
	MOV	[THISSFT+2],DS

;hkn; AUXSTACK is in DOSDATA
	MOV	word [THISSFT],AUXSTACK-SF_ENTRY.size  ; RENAMEDMA+(384-59)
				; Scratch space
	XOR	AH,AH		; Indicate file to DOOPEN (high bit off)
	call	DOOPEN		; Fill in SFT for share check
	LES	DI,[THISSFT]
	;mov	word [es:di+2],10h
	MOV	word [ES:DI+SF_ENTRY.sf_mode],SHARING_DENY_BOTH ; 10h
				; requires exclusive access
	;MOV	word [ES:DI+SF_ENTRY.sf_ref_count],1 ; Pretend open
	mov	word [ES:DI],1
	call	ShareEnter
	jc	short CheckDone
	LES	DI,[THISSFT]
	;MOV	word [ES:DI+SF_ENTRY.sf_ref_count],0
	mov	word [ES:DI],0	; Pretend closed and free
	
	call	ShareEnd	; Tell sharer we're done with THISSFT
	CLC
CheckDone:
	LES	BP,[THISDPB]
	POP	SI
	POP	BX
	POP	AX
	POP	DI
	POP	DS
	retn

;Break	<FastOpen_Delete - delete dir info in fastopen>
;---------------------------------------------------------------------------
; Procedure Name : FastOpen_Delete
; Inputs:
;	None
; Function:
;	Call FastOpen to delete the dir info.
; Outputs:
;	None
;---------------------------------------------------------------------------

	; 31/01/2024

FastOpen_Delete:
	PUSHF			; save flag
	PUSH	SI		; save registers
	push	di ; 31/01/2024 (PCDOS 7.1 IBMDOS.COM)
	PUSH	BX
	PUSH	AX
	;mov	si,[WFP_START] ; MSDOS 3.3
;hkn; SS override
	; 17/05/2019 - Retro DOS v4.0
	; MSDOS 6.0
	MOV	SI,[ss:WFP_START] ; ds:si points to path name
	
	MOV	AL,FONC_delete	; al = 3

; 31/01/2024 (PCDOS 7.1 IBMDOS.COM)
%if 0 
fastinvoke:
;hkn; FastTable is in DOSDATA
	MOV	BX,FastTable+2
	CALL	far [BX]	; call fastopen
	POP	AX		; restore registers
	POP	BX
	;pop	di ; 31/01/2024 (PCDOS 7.1 IBMDOS.COM)
	POP	SI
	POPF			; restore flag
	retn
%else
	jmp	short fastinvoke ; 31/01/2024
%endif

	; 13/11/2022 Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; DOSCODE:65A0h (MSDOS 5.0 MSDOS.SYS)

	; 31/01/2024 Retro DOS v5.0 (Modified PCDOS 7.1 IBMDOS.COM)
	; DOSCODE:65B4h (MSDOS 6.22 MSDOS.SYS)
	; DOSCODE:6D07h (PCDOS 7.1 IBMDOS.COM)

;Break	<FastOpen_Rename - Rename directory>	   ; PTR 5622
;---------------------------------------------------------------------------
; PROCEDURE Name : FastOpen_Rename
;
; Inputs:
;	 REN_WFP   = Path Name
;	 NAME1	   = New Name
; Function:
;	Call FastOpen to rename the dir entry in the cache
; Outputs:
;	None
;---------------------------------------------------------------------------

FastOpen_Rename:
	; 17/05/2019 - Retro DOS v4.0
	; 08/08/2018 - Retro DOS v3.0
	; MSDOS 6.0
	PUSHF			;AN001 save flag
	PUSH	SI		;AN001 save registers
	PUSH	DI		;AN001
	PUSH	BX		;AN001
	PUSH	AX		;AN001
	;
;hkn; SS override
	MOV	SI,[SS:REN_WFP]	;AN001	;;AN001  ds:si-->Path name addrs

;hkn; NAME1 is in DOSDATA
	MOV	DI,NAME1	;;AN001  ds:di-->New name addrs
	;mov	al,6
	MOV	AL,FONC_Rename	;;AN001  al = 6

fastinvoke:	; 31/01/2024 (PCDOS 7.1 IBMDOS.COM)
	
;hkn; FastTable is in DOSDATA
	MOV	BX,FastTable+2
	CALL	far [BX]	;;AN001  call fastopen
	
	POP	AX		; restore registers  ;AN001
	POP	BX				     ;AN001
	POP	DI				     ;AN001
	POP	SI				     ;AN001
	POPF			; restore flag	     ;AN001
	retn					     ;AN001

;Break	<FastOpen_Update - update dir info in fastopen>
;---------------------------------------------------------------------------
; Procedure Name : FastOpen_Update
;
; Inputs:
;	DL     drive number (A=0,B=1,,,)
;	CX     first cluster #
;	AH     0 updates dir entry
;	       1 updates CLUSNUM , BP = new CLUSNUM
;	ES:DI  directory entry
; Function:
;	Call FastOpen to update the dir info.
; Outputs:
;	None
;---------------------------------------------------------------------------

FastOpen_Update:
	PUSHF			; save flag
	PUSH	SI
	push	di ; 31/01/2024 (PCDOS 7.1 IBMDOS.COM)
	PUSH	BX		; save regs
	PUSH	AX
	MOV	AL,FONC_update	; al = 4
	JMP	short fastinvoke

	; 17/05/2019

	; MSDOS 6.0
;entry Fast_Dispatch		; future fastxxxx entry	;AN000;
;---------------------------------------------------------------------------
Fast_Dispatch:
;hkn; FastTable is in DOSDATA
	MOV	SI,FastTable+2	; index to the	     ;AN000;
;hkn; use SS override
	CALL	far [SS:SI]	; RMFD call fastopen
	retn

;============================================================================
; RENAME.ASM, MSDOS 6.0, 1991
;============================================================================
; 08/08/2018 - Retro DOS v3.0
; 17/05/2019 - Retro DOS v4.0

;	TITLE	DOS_RENAME - Internal RENAME call for MS-DOS
;	NAME	DOS_RENAME

;**	Low level routine for renaming files
;----------------------------------------------------------------------------
;	DOS_RENAME
;
;	Modification history:
;
;	    Created: ARR 30 March 1983

;----------------------------------------------------------------------------
;
; Procedure Name : DOS_RENAME
;
; Inputs:
;	[WFP_START] Points to SOURCE WFP string ("d:/" must be first 3
;		chars, NUL terminated)
;	[CURR_DIR_END] Points to end of Current dir part of string [SOURCE]
;		( = -1 if current dir not involved, else
;		 Points to first char after last "/" of current dir part)
;	[REN_WFP] Points to DEST WFP string ("d:/" must be first 3
;		chars, NUL terminated)
;	[THISCDS] Points to CDS being used
;		(Low word = -1 if NUL CDS (Net direct request))
;	[SATTRIB] Is attribute of search, determines what files can be found
; Function:
;	Rename the specified file(s)
;	NOTE: This routine uses most of AUXSTACK as a temp buffer.
; Outputs:
;	CARRY CLEAR
;	    OK
;	CARRY SET
;	    AX is error code
;		error_file_not_found
;			No match for source, or dest path invalid
;		error_not_same_device
;			Source and dest are on different devices
;		error_access_denied
;			Directory specified (not simple rename),
;			Device name given, Destination exists.
;			NOTE: In third case some renames may have
;			 been done if metas.
;		error_path_not_found
;			Bad path (not in curr dir part if present)
;			SOURCE ONLY
;		error_bad_curr_dir
;			Bad path in current directory part of path
;			SOURCE ONLY
;		error_sharing_violation
;			Deny both access required, generates an INT 24.
; DS preserved, others destroyed
;
;----------------------------------------------------------------------------

	; 14/11/2022 Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)

	; 31/01/2024

DOS_RENAME:

;hkn; DOS_RENAME is called from file.asm and fcbio.asm. DS has been set up
;hkn; at this point to DOSDATA.

	call	TestNet
	JNC	short LOCAL_RENAME

;IF NOT Installed
;	transfer NET_RENAME
;ELSE
	;MOV	AX,(MultNET SHL 8) OR 17
	;INT	2FH
	;return

	mov     ax, 1111h
	int     2Fh 	; Multiplex - NETWORK REDIRECTOR - RENAME REMOTE FILE
			; SS = DS = DOS CS, 
			; SDA first filename pointer = offset of fully-qualified old name
			; SDA CDS pointer -> current directory
			; Return: CF set on error
	retn
;ENDIF

LOCAL_RENAME:
	MOV	byte [EXTERR_LOCUS],errLOC_Disk ; 2
	MOV	SI,[WFP_START]
	MOV	DI,[REN_WFP]
	MOV	AL,[SI]
	MOV	AH,[DI]
	OR	AX,2020H		; Lower case
	CMP	AL,AH
	JZ	short SAMEDRV
	MOV	AX,error_not_same_device ; 11h
	STC
	retn

SAMEDRV:
	PUSH	WORD [DMAADD+2]
	PUSH	WORD [DMAADD]
	MOV	[DMAADD+2],DS

;hkn; RENAMEDMA is in DOSDATA
	MOV	WORD [DMAADD],RENAMEDMA
	MOV	byte [FOUND_DEV],0	; Rename fails on DEVS, assume not a dev
	call	ECritDisk
	call	DOS_SEARCH_FIRST	; Sets [NoSetDir] to 1, [CURBUF+2]:BX
					;    points to entry
	JNC	short Check_Dev
	CMP	AX,error_no_more_files ; 12h
	JNZ	short GOTERR
	MOV	AX,error_file_not_found ; 2
GOTERR:
	STC
RENAME_POP:
	POP	WORD [DMAADD]
	POP	WORD [DMAADD+2]
	;call	LCritDisk
	;retn
	; 16/12/2022
	jmp	LCritDisk

Check_Dev:
	; 17/05/2019 - Retro DOS v4.0
	;mov	ax,5
	MOV	AX,error_access_denied	; Assume error
	
	; MSDOS 6.0
	PUSH	DS			      ;PTM.			    ;AN000;
	LDS	SI,[DMAADD]		      ;PTM.  check if source a dir  ;AN000;
	;add	si,21
	ADD	SI,find_buf.attr	      ;PTM.			    ;AN000;
	;test	byte [si+11],10h
	TEST	byte [SI+dir_entry.dir_attr],attr_directory ;PTM.	    ;AN000;
	JZ	short notdir		      ;PTM.			    ;AN000;
	MOV	SI,[REN_WFP]		      ;PTM.  if yes, make sure path ;AN000;
	call	Check_PathLen2		      ;PTM.   length < 67	    ;AN000;
notdir:
	POP	DS			      ;PTM.			    ;AN000;
	JA	short GOTERR		      ;PTM.			    ;AN000;

	; MSDOS 3.3 & MSDOS 6.0
	CMP	byte [FOUND_DEV],0
	JNZ	short GOTERR

; At this point a source has been found. There is search continuation info (a
; la DOS_SEARCH_NEXT) for the source at RENAMEDMA, together with the first
; directory entry found.
; [THISCDS], [THISDPB], and [THISDRV] are set and will remain correct
; throughout the RENAME since it is known at this point that the source and
; destination are both on the same device.
; [SATTRIB] is also set.

	MOV	SI,BX
	;add	si,26
	ADD	SI,dir_entry.dir_first
	call	REN_DEL_Check
	JNC	short REN_OK1
	MOV	AX,error_sharing_violation  ; 20h
	JMP	short RENAME_POP

;------------------------------------------------------------------------------
; Check if the source is a file or directory. If file, delete the entry
; from the Fastopen cache. If directory, rename it later
;------------------------------------------------------------------------------

REN_OK1:				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; MSDOS 6.0
	; 31/01/2024 (PCDOS 7.1 IBMDOS.COM)
	;PUSH	SI
	LDS	SI,[DMAADD]		;BN00X; PTM. check if source a dir ;AN000;
	;add	si,21
	ADD	SI,find_buf.attr	;;BN00XPTM.P5520		;AN000;
	;test	byte [si+11],10h
	TEST	byte [SI+dir_entry.dir_attr],attr_directory ;;BN00XPTM. ;AN000;
	;JZ	short NOT_DIR1		;;BN00XPTM.			;AN000;
	jnz	short SWAP_SOURCE ; 31/01/2024
	;POP	SI			;BN00X
	;JMP	SHORT SWAP_SOURCE	;BN00X
;NOT_DIR1:				;;BN00X it is a file, delete the entry
	;POP	SI

	; MSDOS 3.3 (& MSDOS 6.0)
	call	FastOpen_Delete 	; delete dir info in fastopen DOS 3.3
SWAP_SOURCE:
	; MSDOS 3.3
	;MOV	SI,[REN_WFP]
	;MOV	[WFP_START],SI
	; MSDOS 6.0
	MOV	AX,[WFP_START]		; Swap source and destination
	MOV	SI,[REN_WFP]		; Swap source and destination
	MOV	[WFP_START],SI		; WFP_START = Destination path
	MOV	[REN_WFP],AX		; REN_WFP   = Source path
	; MSDOS 3.3 (& MSDOS 6.0)
	MOV	word [CURR_DIR_END],-1	; No current dir on dest
	;mov	word [CREATING],0E5FFh
	MOV	WORD [CREATING],DIRFREE*256+0FFh  ; Creating, not DEL *.*
					; A rename is like a CREATE_NEW as far
					; as the destination is concerned.
	call	GetPathNoSet

;   If this GETPATH fails due to file not found, we know all renames will work
;   since no files match the destination name. If it fails for any other
;   reason, the rename fails on a path not found, or whatever (also fails if
;   we find a device or directory). If the GETPATH succeeds, we aren't sure
;   if the rename should fail because we haven't built an explicit name by
;   substituting for the meta chars in it. In this case the destination file
;   spec with metas is in [NAME1] and the explicit source name is at RENAMEDMA
;   in the directory entry part.
	
	JC	short NODEST
	
	; MSDOS 6.0
	;JZ	short BAD_ACC 		; Dest string is a directory	;AC000;
	; !! MSDOS 3.3 !!
	;JZ	short BAD_ACC ; !!	; Dest string is a directory

	OR	AH,AH			; Device?
	JNS	short SAVEDEST		; No, continue
BAD_ACC:
	MOV	AX,error_access_denied
	STC
RENAME_CLEAN:
	PUSHF				; Save carry state
	PUSH	AX			; and error code (if carry set)
	MOV	AL,[THISDRV]
	call	FLUSHBUF
	POP	AX
	CMP	byte [FAILERR],0
	JNZ	short BAD_ERR		; User FAILed to I 24
	POPF
	JMP	RENAME_POP

BAD_ERR:
	POP	AX			; Saved flags
	; 16/12/202
	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
BAD_PATH: ; *
	MOV	AX,error_path_not_found
	JMP	GOTERR

NODEST:
	JNZ	short BAD_PATH
	CMP	byte [FAILERR],0
	JNZ	short BAD_PATH		; Search for dest failed 
					; because user FAILed on I 24
	; 14/11/2022
	OR	CL,CL
	;JNZ	short SAVEDEST
	; 17/05/2019
	jz	short BAD_PATH ; *
;BAD_PATH: ; *
;	MOV	AX,error_path_not_found
;	;STC
;	;JMP	RENAME_POP
;	; 17/05/2019
;	jmp	GOTERR 

; 16/12/2022
%if 0
	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	or	cl,cl
	jnz	short SAVEDEST
	;jz	short BAD_PATH ; *
BAD_PATH: ; *
	;mov	ax,3
	mov	ax,error_path_not_found
	stc
	jmp	RENAME_POP
%endif

SAVEDEST:
	push	ss
	pop	es

;hkn; NAME1 & NAME2 is in DOSDATA
	MOV	DI,NAME2
	MOV	SI,NAME1

	MOV	CX,11
	REP	MOVSB			; Save dest with metas at NAME2
	MOV	AX,[DIRSTART]
	MOV	[DESTSTART],AX
BUILDDEST:
	; 31/01/2024
	;push	ss
	;pop	es			; needed due to JMP BUILDDEST below

;hkn; RENAMEDMA, NAME1, NAME2 in DOSDATA
	MOV	BX,RENAMEDMA+21		; Source of replace chars
	MOV	DI,NAME1		; Real dest name goes here
	MOV	SI,NAME2		; Raw dest

	MOV	CX,11

	; 17/05/2019 - Retro DOS v4.0
	
	; MSDOS 6.0
	CALL	NEW_RENAME		;IFS. replace ? chars	;AN000;

	; MSDOS 3.3

; 08/08/2018 - Retro DOS v3.0
; MSDOS 6.0 
;---------------------------------------------------------------------------
;Procedure: NEW_RENAME
;
;Input: DS:SI -> raw string with ?
;	ES:DI -> destination string
;	DS:BX -> source string
;Function: replace ? chars of raw string with chars in source string and
;	   put in destination string
;Output: ES:DI-> new string
;---------------------------------------------------------------------------
;
;NEW_RENAME:
;NEWNAM:
;	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 341Ah
;	LODSB
;	CMP	AL,"?"
;	JNZ	short NOCHG
;	MOV	AL,[BX] 		; Get replace char
;NOCHG:
;	STOSB
;	INC	BX			; Next replace char
;	LOOP	NEWNAM
;	; MSDOS 6.0
;	;retn

	; MSDOS 3.3 & MSDOS 6.0
	;mov	byte [ATTRIB],16h
	MOV	byte [ATTRIB],attr_all	; Stop duplicates with any attributes
	MOV	byte [CREATING],0FFH
	call	DEVNAME 		; Check if we built a device name
	JNC	short BAD_ACC
	MOV	BX,[DESTSTART]
	LES	BP,[THISDPB]
	call	SETDIRSRCH		; Reset search to start of dir
	JC	short BAD_ACC 		; Screw up
	call	FINDENTRY		; See if new name already exists
	JNC	short BAD_ACC 		; Error if found
	CMP	byte [FAILERR],0
	JNZ	short BAD_ACCJ		; Find failed because user FAILed to I 24
	MOV	AX,[DESTSTART]		; DIRSTART of dest
	CMP	AX,[RENAMEDMA+15]	; DIRSTART of source
	JZ	short SIMPLE_RENAME	; If =, just give new name

	;mov	al,[RENAMEDMA+32]
	MOV	AL,[RENAMEDMA+21+dir_entry.dir_attr]
	TEST	AL,attr_directory ; 10h
	JNZ	short BAD_ACCJ		; Can only do a simple rename on dirs,
					; otherwise the . and .. entries get
					; wiped.
	MOV	[ATTRIB],AL
	MOV	[THISSFT+2],DS

;hkn; AUXSTACK is in DOSDATA
	;mov	si,RENAMEDMA+145h
	MOV	SI,AUXSTACK-SF_ENTRY.size  ; RENAMEDMA+325
	MOV	[THISSFT],SI
	;mov	word [SI+2],2
	MOV	word [SI+SF_ENTRY.sf_mode],SHARING_COMPAT+open_for_both
	XOR	CX,CX			; Set "device ID" for call into makenode
	call	RENAME_MAKE		; This is in mknode
	JNC	short GOT_DEST
BAD_ACCJ:
	JMP	BAD_ACC

GOT_DEST:
	push	bx
	LES	DI,[THISSFT]		; RENAME_MAKE entered this into sharing
	call	ShareEnd		; we need to remove it.
	pop	bx

; A zero length entry with the correct new name has now been made at
;   [CURBUF+2]:BX.

	LES	DI,[CURBUF]

	; MSDOS 6.0
	;test	byte [es:di+5],40h
	TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty  
					;LB. if already dirty		  ;AN000;
	JNZ	short yesdirty1		;LB.  don't increment dirty count ;AN000;
	call	INC_DIRTY_COUNT 	;LB.				  ;AN000;
	;or	byte [es:di+5],40h
	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
yesdirty1:
	MOV	DI,BX
	;add	di,11
	ADD	DI,dir_entry.dir_attr	; Skip name

;hkn; RENAMEDMA is in DOSDATA
	;mov	si,[RENAMEDMA+32]
	MOV	SI,RENAMEDMA+21+dir_entry.dir_attr
	;mov	cx,21
	MOV	CX,dir_entry.size-dir_entry.dir_attr
	REP	MOVSB
	CALL	GET_SOURCE
	JC	short RENAME_OVER
	MOV	DI,BX
	MOV	ES,[CURBUF+2]
	MOV	AL,DIRFREE ; 0E5h
	STOSB				; "free" the source
	JMP	SHORT DIRTY_IT

SIMPLE_RENAME:
	CALL	GET_SOURCE		; Get the source back
	JC	short RENAME_OVER
	MOV	DI,BX
	MOV	ES,[CURBUF+2]

;hkn; NAME1 is in DOSDATA
	MOV	SI,NAME1		; New Name
	MOV	CX,11
	REP	MOVSB
DIRTY_IT:
	MOV	DI,[CURBUF]

	; MSDOS 6.0
	TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty  
					;LB. if already dirty		  ;AN000;
	JNZ	short yesdirty2		;LB.  don't increment dirty count ;AN000;
	call	INC_DIRTY_COUNT 	;LB.				  ;AN000;
	
	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty

;------------------------------------------------------------------------------
; Check if the source is a directory of file. If directory rename it to the
; the new name in the Fastopen cache buffer. If file name it has been
; previously deleted.
;------------------------------------------------------------------------------

yesdirty2:
	; MSDOS 6.0
	PUSH	SI
	LDS	SI,[DMAADD]		;;BN00XPTM. chek if source a dir ;AN000;
	ADD	SI,find_buf.attr	;;BN00XPTM.P5520		;AN000;
	TEST	byte [SI+dir_entry.dir_attr],attr_directory ;;BN00XPTM.	;AN000;
	JZ	short NOT_DIR2		;;BN00XPTM.			;AN000;
	call	FastOpen_Rename		;;BN00X rename dir entry in fastopen
	; 31/01/2024
	;POP	SI
	;JMP	SHORT NOT_DIRTY1
NOT_DIR2:				;;BN00X it is a file, delete the entry
	POP	SI
NOT_DIRTY1:				;;BN00X
NEXT_SOURCE:
;hkn; RENAMEDMA is in DOSDATA
	MOV	SI,RENAMEDMA+1		;Name

; WARNING! Rename_Next leaves the disk critical section *ALWAYS*. We need
; to enter it before going to RENAME_Next.

	call	ECritDisk
	MOV	byte [CREATING],0 ; Correct setting for search (we changed it
				  ;  to FF when we made the prev new file).
	call	RENAME_NEXT

; Note, now, that we have exited the previous ENTER and so are back to where
; we were before.

	JC	short RENAME_OVER

	;lea	si,[bx+26]
	LEA	SI,[BX+dir_entry.dir_first]
	call	REN_DEL_Check
	JNC	short REN_OK2
	MOV	AX,error_sharing_violation ; 20h
jmp_to_rename_clean: ; 28/12/2022
	JMP	RENAME_CLEAN ; 10/08/2018

;------------------------------------------------------------------------------
; Check if file or directory. If file, delete file from the Fastopen cache,
; if directory, rename directory name in the Fastopen cache.
;-----------------------------------------------------------------------------

REN_OK2:
	; MSDOS 6.0
	;mov	al,[RERNAMEDMA+32]
	MOV	AL,[RENAMEDMA+21+dir_entry.dir_attr] ; PTR P5622
	;test	al,10h
	TEST	AL,attr_directory	;;BN00X directory
	JZ	short Ren_Directory	;;BN00X no - file, delete it
	
	; MSDOS 3.3 & MSDOS 6.0
	call	FastOpen_Delete 	;;BN00X delete dir info in fastopen DOS 3.3
jmp_to_builddest: ; 28/12/2022
	; 31/01/2024
	push	ss
	pop	es
	JMP	BUILDDEST		;;BN00X

	; MSDOS 6.0
Ren_Directory:
	call	FastOpen_Rename 	;;BN00X delete dir info in fastopen DOS 3.3
	;JMP	BUILDDEST
	; 28/12/2022
	jmp	short jmp_to_builddest

RENAME_OVER:
	CLC
	;JMP	RENAME_CLEAN ; 10/08/2018
	; 28/12/2022
	jmp	short jmp_to_rename_clean

;----------------------------------------------------------------------------
; Procedure: GET_SOURCE
;
; Inputs:
;	RENAMEDMA has source info
; Function:
;	Re-find the source
; Output:
;	[CURBUF] set
;	[CURBUF+2]:BX points to entry
;	Carry set if error (currently user FAILed to I 24)
; DS preserved, others destroyed
;----------------------------------------------------------------------------

GET_SOURCE:
	MOV	BX,[RENAMEDMA+15]	; DirStart
	LES	BP,[THISDPB]
	call	SETDIRSRCH
	JC	short gs_ret_label	; retc
	call	STARTSRCH
	MOV	AX,[RENAMEDMA+13]	; Lastent
	;call	GETENT
	; 18/12/2022
	jmp	GETENT
;gs_ret_label:
	;retn

; MSDOS 6.0 
;---------------------------------------------------------------------------
;Procedure: NEW_RENAME
;
;Input: DS:SI -> raw string with ?
;	ES:DI -> destination string
;	DS:BX -> source string
;Function: replace ? chars of raw string with chars in source string and
;	   put in destination string
;Output: ES:DI-> new string
;---------------------------------------------------------------------------

NEW_RENAME:
	; 17/05/2019 - Retro DOS v4.0
NEWNAM:
	; DOSCODE:680Eh (MSDOS 6.21, MSDOS.SYS)
	LODSB
	CMP	AL,"?" ; 3Fh
	JNZ	short NOCHG
	MOV	AL,[BX] 		; Get replace char
NOCHG:
	STOSB
	INC	BX			; Next replace char
	LOOP	NEWNAM
	; MSDOS 6.0
gs_ret_label:	; 18/12/2022
	retn

;============================================================================
; FINFO.ASM, MSDOS 6.0, 1991
;============================================================================
; 08/08/2018 - Retro DOS v3.0
; 17/05/2019 - Retro DOS v4.0

;**	Low level routines for returning file information and setting file
;	attributes
;
;	GET_FILE_INFO
;	SET_FILE_ATTRIBUTE
;
;	Modification history:
;
;	    Created: ARR 30 March 1983
;
;	M025: Return access_denied if attempting to set
;	      attribute of root directory.
;

;SUBTTL GET_FILE_INFO -- Get File Information

;---------------------------------------------------------------------------
; Procedure Name : GET_FILE_INFO
;
; Inputs:
;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
;		terminated)
;	[CURR_DIR_END] Points to end of Current dir part of string
;		( = -1 if current dir not involved, else
;		 Points to first char after last "/" of current dir part)
;	[THISCDS] Points to CDS being used
;		(Low word = -1 if NUL CDS (Net direct request))
;	[SATTRIB] Is attribute of search, determines what files can be found
; Function:
;	Get Information about a file
; Returns:
;	CARRY CLEAR
;	    AX = Attribute of file
;	    CX = Time stamp of file
;	    DX = Date stamp of file
;	    BX:DI = Size of file (32 bit)
;	CARRY SET
;	    AX is error code
;		error_file_not_found
;			Last element of path not found
;		error_path_not_found
;			Bad path (not in curr dir part if present)
;		error_bad_curr_dir
;			Bad path in current directory part of path
; DS preserved, others destroyed
;---------------------------------------------------------------------------

	; 14/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)

GET_FILE_INFO:

;hkn; get_file_info is called from file.asm and fcbio.asm. DS has been set 
;hkn; to DOSDATA at this point. So DOSassume is OK.

	call	TestNet
	JNC	short LOCAL_INFO

;IF NOT Installed
;	transfer NET_GET_FILE_INFO
;ELSE
;	MOV	AX,(MultNET SHL 8) OR 15
;	INT	2FH
;	return

	mov     ax, 110Fh
	int     2Fh	; Multiplex - NETWORK REDIRECTOR - GET REMOTE FILE'S ATTRIBUTES
			; SS = DOS CS, SDA first filename pointer -> fully-qualified name of file
			; SDA CDS pointer -> current directory
			; Return: CF set on error, AX = file attributes
	retn
;ENDIF

LOCAL_INFO:
	call	ECritDisk
	MOV	byte [NoSetDir],1	; if we find a dir, don't change to it
	; MSDOS 3.3
	;call	GETPATH
	; MSDOS 6.0
	call	GET_FAST_PATH
	; MSDOS 3.3 & MSDOS 6.0
	JNC	short info_check_dev
NO_PATH:
	JNZ	short bad_path1
	OR	CL,CL
	JZ	short bad_path1
info_no_file:
	MOV	AX,error_file_not_found
BadRet:
	STC
JustRet:
	;call	LCritDisk
	;retn
	; 18/12/2022
	jmp	LCritDisk

bad_path1:
	MOV	AX,error_path_not_found
	jmp	short BadRet

info_check_dev:
	OR	AH,AH
	JS	short info_no_file	; device

	; MSDOS 6.0
;SR;
; If root dir then CurBuf == -1. Check for this case and return subdir attr
;for a root dir

	cmp	word [CURBUF],-1	;is it a root dir?
	jne	short not_root		;no, CurBuf ptr is valid

	xor	ah,ah
	mov	al,attr_directory ; 10h
	;clc
	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	; (DOSCODE:683Eh)
	; 16/12/2022
	;clc
	jmp	short JustRet

not_root:
	; MSDOS 3.3 (& MSDOS 6.0)
	PUSH	DS
	MOV	DS,[CURBUF+2]
	MOV	SI,BX
	XOR	BX,BX			; Assume size=0 (dir)
	MOV	DI,BX
	;mov	cx,[si+16h]
	MOV	CX,[SI+dir_entry.dir_time]
	;mov	dx,[si+18h]
	MOV	DX,[SI+dir_entry.dir_date]
	XOR	AH,AH
	;mov	al,[si+0Bh]
	MOV	AL,[SI+dir_entry.dir_attr]
	;test	al,10h
	TEST	AL,attr_directory
	JNZ	short NO_SIZE
	;mov	di,[si+1Ch]
	MOV	DI,[SI+dir_entry.dir_size_l]
	;mov	bx,[si+1Eh]
	MOV	BX,[SI+dir_entry.dir_size_h]
NO_SIZE:
	POP	DS
	;CLC
	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	; (DOSCODE:6864h)
	; 16/12/2022
	;clc
	jmp	short JustRet

;Break	<SET_FILE_ATTRIBUTE -- Set File Attribute>
;-------------------------------------------------------------------------------
; Procedure Name : SET_FILE_ATTRIBUTE
; Inputs:
;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
;		terminated)
;	[CURR_DIR_END] Points to end of Current dir part of string
;		( = -1 if current dir not involved, else
;		 Points to first char after last "/" of current dir part)
;	[THISCDS] Points to CDS being used
;		(Low word = -1 if NUL CDS (Net direct request))
;	[SATTRIB] is attribute of search (determines what files may be found)
;	AX is new attributes to give to file
; Function:
;	Set File Attributes
; Returns:
;	CARRY CLEAR
;	    No error
;	CARRY SET
;	    AX is error code
;		error_file_not_found
;			Last element of path not found
;		error_path_not_found
;			Bad path (not in curr dir part if present)
;		error_bad_curr_dir
;			Bad path in current directory part of path
;		error_access_denied
;			Attempt to set an attribute which cannot be set
;			(attr_directory, attr_volume_ID)
;		error_sharing_violation
;			Sharing mode of file did not allow the change
;			(this request requires exclusive write/read access)
;			(INT 24H generated)
; DS preserved, others destroyed
;----------------------------------------------------------------------------

SET_FILE_ATTRIBUTE:

;hkn; set_file_attr is called from file.asm. DS has been set 
;hkn; to DOSDATA at this point. So DOSassume is OK.

	TEST	AX,~attr_changeable ; 0FFD8h
	JZ	short set_look
_BAD_ACC:
	MOV	byte [EXTERR_LOCUS],errLOC_Unk ; 1
	MOV	byte [EXTERR_CLASS],errCLASS_Apperr ; 7
	MOV	byte [EXTERR_ACTION],errACT_Abort ; 4
	MOV	AX,error_access_denied ; 5
	STC
	retn

set_look:
	call	TestNet
	JNC	short LOCAL_SET

;IF NOT Installed
;	transfer NET_SEQ_SET_FILE_ATTRIBUTE
;ELSE
	PUSH	AX
	
	;MOV	AX,(MultNET SHL 8) OR 14
	;INT	2FH

	mov     ax, 110Eh
	int     2Fh	; Multiplex - NETWORK REDIRECTOR - SET REMOTE FILE'S ATTRIBUTES
			; SS = DOS CS, SDA first filename pointer -> fully-qualified name of file
			; SDA CDS pointer -> current directory
			; STACK: WORD new file attributes
			; Return: CF set on error

	POP	BX			; clean stack
	retn
;ENDIF

LOCAL_SET:
	call	ECritDisk
	PUSH	AX			; Save new attributes
	MOV	byte [NoSetDir],1	; if we find a dir, don't change to it
	call	GETPATH 		; get path through fastopen if there	;AC000;
	JNC	short set_check_device
	POP	BX			; Clean stack (don't zap AX)
	JMP	short NO_PATH

	; MSDOS 6.0
cannot_set_root:			; M025:
	mov	ax,error_access_denied	; M025: return error is attempting
	;stc				; M025: to set attr. of root
	;jmp	short OK_BYE		; M025:
	; 01/02/2024
	jmp	short BadRet

set_check_device:
	OR	AH,AH
	JNS	short set_check_share
	POP	AX
	call	LCritDisk
	JMP	short _BAD_ACC 		; device

set_check_share:
	POP	AX			; Get new attributes

	; MSDOS 6.0
	cmp	word [CURBUF], -1	; M025: Q: is this the root dir
	je	short cannot_set_root	; M025: Y: return error

	; MSDOS 3.3 & MSDOS 6.0
	call	REN_DEL_Check
	JNC	short set_do
	MOV	AX,error_sharing_violation ; 32
	jmp	short OK_BYE

set_do:
	; MSDOS 3.3 & MSDOS 6.0
	LES	DI,[CURBUF]
	AND	BYTE [ES:BX+dir_entry.dir_attr],~attr_changeable ; 0D8h
	OR	BYTE [ES:BX+dir_entry.dir_attr],AL

	; MSDOS 6.0
	TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty  
					;LB. if already dirty		  ;AN000;
	JNZ	short yesdirty3		;LB.  don't increment dirty count ;AN000;
	call	INC_DIRTY_COUNT 	;LB.				  ;AN000;
	
	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
yesdirty3:
	MOV	AL,[THISDRV]
;;;; 10/1/86 F.C update fastopen cache
	PUSH	DX
	PUSH	DI
	MOV	AH,0		  ; dir entry update
	MOV	DL,AL		  ; drive number A=0,B=1,,
	MOV	DI,BX		  ; ES:DI -> dir entry
	call	FastOpen_Update
	POP	DI
	POP	DX
;;;; 9/11/86 F.C update fastopen cache
	call	FLUSHBUF
	JNC	short OK_BYE
	MOV	AX,error_file_not_found
OK_BYE:
	;call	LCritDisk
	;retn
	; 16/12/2022
	jmp	LCritDisk

	; 17/05/2019 - Retro DOS v4.0

	; MSDOS 6.0
GET_FAST_PATH:
;hkn; use SS override for FastOpenFlg
	OR	byte [ss:FastOpenFlg],FastOpen_Set
					;FO. trigger fastopen	;AN000;
	call	GETPATH
	PUSHF			 	;FO.			;AN000;
	AND	byte [ss:FastOpenFlg],Fast_yes 
					;FO. clear all fastopen flags ;AN000;
	POPF				;FO.			;AN000;
	retn

;============================================================================
; DUP.ASM, MSDOS 6.0, 1991
;============================================================================
; 08/08/2018 - Retro DOS v3.0
; 17/05/2019 - Retro DOS v4.0

;** 	Low level DUP routine for use by EXEC when creating a new process.
;   	Exports the DUP to the server machine and increments the SFT ref count
;
;	DOS_DUP
;
;	Modification history:
;
;	  Created: ARR 30 March 1983

;BREAK <DOS_DUP -- DUP SFT across network>
;---------------------------------------------------------------------------
; Procedure Name : DOS_DUP
;
; Inputs:
;	[THISSFT] set to the SFT for the file being DUPed
;		(a non net SFT is OK, in this case the ref
;		 count is simply incremented)
; Function:
;	Signal to the devices that a logical open is occurring
; Returns:
;	ES:DI point to SFT
;    Carry clear
;	SFT ref_count is incremented
; Registers modified: None.
; NOTE:
;	This routine is called from $CREATE_PROCESS_DATA_BLOCK at DOSINIT
;	time with SS NOT DOSGROUP. There will be no Network handles at
;	that time.
;---------------------------------------------------------------------------

DOS_DUP:
	;LES	DI,[CS:THISSFT]  ; MSDOS 3.3

	; MSDOS 6.0
	mov	es,[cs:DosDSeg]
	les	di,[es:THISSFT]

	;Entry	Dos_Dup_Direct
DOS_Dup_Direct:
	call	IsSFTNet
	JNZ	short DO_INC
	call	DEV_OPEN_SFT
DO_INC:
	;INC	word [ES:DI+SF_ENTRY.sf_ref_count]
	inc	word [ES:DI]		; Clears carry (if this ever wraps
					;   we're in big trouble anyway)
	retn

;============================================================================
; CREATE.ASM, MSDOS 6.0, 1991
;============================================================================
; 08/08/2018 - Retro DOS v3.0
; 18/05/2019 - Retro DOS v4.0

;TITLE	DOS_CREATE/DOS_CREATE_NEW - Internal CREATE calls for MS-DOS
;NAME	DOS_CREATE
;----------------------------------------------------------------------------
;**	Internal Create and Create new to create a local or NET file and SFT.
;
;	DOS_CREATE
;	DOS_CREATE_NEW
;	SET_MKND_ERR
;	SET_Media_ID
;	SET_EXT_Mode
;
;	Revision history:
;
;	    A000 version 4.00	  Jan. 1988
;	    A001  D490 -- Change IOCTL subfunctios from 63h,43h to 66h, 46h

;Installed = TRUE

;	i_need	THISSFT,DWORD
;	i_need	THISCDS,DWORD
;	I_need	EXTERR,WORD
;	I_Need	ExtErr_locus,BYTE
;	I_need	JShare,DWORD
;	I_need	VOLCHNG_FLAG,BYTE
;	I_need	SATTRIB,BYTE
;	I_need	CALLVIDM,DWORD
;	I_need	EXTOPEN_ON,BYTE 		  ;AN000; extended open
;	I_need	NAME1,BYTE			  ;AN000;
;	I_need	NO_NAME_ID,BYTE 		  ;AN000;
;	I_need	Packet_Temp,WORD		  ;AN000;
;	I_need	DOS34_FLAG,WORD 		  ;AN000;
;	I_need	SAVE_BX,WORD			  ;AN000;

;***	DOS_CREATE - Create a File
;----------------------------------------------------------------------------
;	DOS_Create is called to create the specified file, truncating
;	the old one if it exists.
;
;	ENTRY	AX is Attribute to create
;		(ds) = DOSDATA
;		[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
;			terminated)
;		[CURR_DIR_END] Points to end of Current dir part of string
;			( = -1 if current dir not involved, else
;			 Points to first char after last "/" of current dir part)
;		[THISCDS] Points to CDS being used
;			(Low word = -1 if NUL CDS (Net direct request))
;		[THISSFT] Points to SFT to fill in if file created
;			(sf_mode field set so that FCB may be detected)
;		[SATTRIB] Is attribute of search, determines what files can be found
;
;	EXIT	sf_ref_count is NOT altered
;		CARRY CLEAR
;		    THISSFT filled in.
;			sf_mode = unchanged for FCB, sharing_compat + open_for_both
;		CARRY SET
;		    AX is error code
;			error_path_not_found
;				Bad path (not in curr dir part if present)
;			error_bad_curr_dir
;				Bad path in current directory part of path
;			error_access_denied
;				Attempt to re-create read only file , or
;				create a second volume id or create a dir
;			error_sharing_violation
;				The sharing mode was correct but not allowed
;				generates an INT 24
;	USES	all but DS
;----------------------------------------------------------------------------

	; 14/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; DOSCODE:6920h (MSDOS 5.0, MSDOS.SYS)

DOS_CREATE:
	; 18/05/2019 - Retro DOS v4.0
	; DOSCODE:6934h (MSDOS 6.21, MSDOS.SYS)

;hkn; dispatched to from file.asm and fcbio.asm. DS set up to DOSDATA at 
;hkn; this point.

	XOR	AH,AH		; Truncate is OK

;	Enter here from Dos_Create_New
;
;	(ah) = 0 iff truncate OK

Create_inter:
	TEST	AL,~(attr_all+attr_ignore+attr_volume_id) ; 80h
				; Mask out any meaningless bits
	JNZ	short AttErr
	TEST	AL,attr_volume_id
	JZ	short NoReset
	
	; MSDOS 6.0
	; 16/12/2022
	OR	byte [DOS34_FLAG],DBCS_VOLID ; 80h ;AN000;FOR dbcs volid
	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;or	word [DOS34_FLAG],DBCS_VOLID ; 80h 
	
	MOV	AL,attr_volume_id ; 8
NoReset:
	OR	AL,attr_archive ; File changed  ; 20h
	TEST	AL,attr_directory+attr_device ; 50h
	JZ	short ATT_OK
AttErr:
	MOV	AX,5		; Attribute problem
	MOV	byte [EXTERR_LOCUS],errLOC_Unk ; 1
	JMP	SHORT SET_MKND_ERR ; Gotta use MKDIR to make dirs, NEVER allow
				   ;	attr_device to be set.
ATT_OK:
	LES	DI,[THISSFT]
	PUSH	ES
	LES	SI,[THISCDS]
	CMP	SI,-1
	JNE	short TEST_RE_NET

;	No CDS, it must be redirected.

	POP	ES

	; MSDOS 6.0
;Extended open hooks
	;test	byte [EXTOPEN_ON],1
	TEST	byte [EXTOPEN_ON],EXT_OPEN_ON ;AN000;EO. from extended open
	JZ	short NOEXTOP 		    ;AN000;EO. no, do normal
IFS_extopen:				    ;AN000;EO.
	PUSH	AX			    ;AN000;EO. pass create attr
	;MOV	AX,(MultNET SHL 8) OR 46    ;AN000;EO. issue extended open verb
	mov	ax,112Eh
NOEXTOP2:	; 01/02/2024 (PCDOS 7.1 IBMDOS.COM)
	INT	2FH			    ;AN000;EO.
	POP	BX			    ;AN000;EO. trash bx
	MOV	byte [EXTOPEN_ON],0	    ;AN000;EO.
	retn				    ;AN000;EO.
NOEXTOP:				    ;AN000;
;Extended open hooks

;IF NOT Installed
;	transfer NET_SEQ_CREATE
;ELSE
	PUSH	AX

	;MOV	AX,(MultNET SHL 8) OR 24
	;INT	2FH

	mov	ax,1118h
	; 01/02/2024
	;int	2Fh	; Multiplex - NETWORK REDIRECTOR - CREATE/TRUNCATE FILE
			; ES:DI -> uninitialized SFT, SS = DOS CS
			; SDA first filename pointer -> fully-qualified name of file
			; STACK: WORD file creation mode???

	;POP	BX			; BX is trashed anyway
	;retn
	jmp	short NOEXTOP2 ; 01/02/2024
;ENDIF

;	We have a CDS. See if it's network

TEST_RE_NET:
	;;test	word [es:si+43h],8000h
	;TEST	word [ES:SI+curdir.flags],curdir_isnet
	; 07/12/2022
	;test	byte [es:si+44h],80h
	; 17/12/2022
	test	byte [ES:SI+curdir.flags+1],curdir_isnet>>8
	POP	ES
	JZ	short LOCAL_CREATE

	; MSDOS 6.0
	CALL	Set_EXT_mode		    ;AN000;EO.
	JC	SHORT dochk		    ;AN000;EO.
	;;or	word [es:di+2],2
	;OR	word [ES:DI+SF_ENTRY.sf_mode],SHARING_COMPAT+open_for_both ;IFS.
	; 17/12/2022
	or	byte [ES:DI+SF_ENTRY.sf_mode],SHARING_COMPAT+open_for_both ;IFS.

;Extended open hooks
dochk:
	TEST	byte [EXTOPEN_ON],EXT_OPEN_ON ;AN000;EO. from extended open
	JNZ	short IFS_extopen	    ;AN000;EO. yes, issue extended open
;Extended open hooks

;IF NOT Installed
;	transfer NET_CREATE
;ELSE
	PUSH	AX
	
	;MOV	AX,(MultNET SHL 8) OR 23
	;INT	2FH
	
	mov	ax,1117h
	
	; 01/02/2024
	;int	2Fh	; Multiplex - NETWORK REDIRECTOR - CREATE/TRUNCATE REMOTE FILE
			; ES:DI -> uninitialized SFT, SS = DOS CS
			; SDA first filename pointer -> fully-qualified name of file to open
			; SDA CDS pointer -> current directory
			; Return: CF set on error

	;POP	BX			; BX is trashed anyway
;nomore:
	;retn
	jmp	short NOEXTOP2 ; 01/02/2024
;ENDIF

;**	It's a local create. We have a local CDS for it.

LOCAL_CREATE:
	; MSDOS 6.0
	CALL	Set_EXT_mode	;AN000;EO. set mode if from extended open
	JC	short setdone	;AN000;EO.
	
	; MSDOS 3.3 & MSDOS 6.0
	; 17/12/2022
	;;or	word [es:di+2],2
	;OR	word [ES:DI+SF_ENTRY.sf_mode],SHARING_COMPAT+open_for_both
	;or	byte [es:di+2],2
	or	byte [ES:DI+SF_ENTRY.sf_mode],SHARING_COMPAT+open_for_both	
setdone:
	call	ECritDisk
	call	MakeNode
	JNC	short Create_ok
	mov	byte [VOLCHNG_FLAG],-1	; indicate no change in volume label
	call	LCritDisk

	;entry	SET_MKND_ERR
SET_MKND_ERR:

;	Looks up MakeNode errors and converts them. AL is MakeNode
;	error, SI is GETPATH bad spot return if path_not_found error.

;hkn; CRTERRTAB is in TABLE seg (DOSCODE)
	MOV     BX,CRTERRTAB
	;XLAT  ; MSDOS 3.3
	; 18/05/2019 - Retro DOS v4.0
	CS
	XLAT
CreatBadRet:
	STC
	retn

; 13/05/2019 - Retro DOS v4.0
; DOSCODE:69C4h (MSDOS 6.21, MSDOS.SYS)
; ---------------------------------------------------------------------------

;** Internal Create and Create new to create a local or NET file and SFT.

; 17/07/2018 - Retro DOS v3.0
; Offset 12B1h of IBMDOS.COM (MSDOS 3.3), 1987

;CRTERRTAB: ; 19/07/2018 - MSDOS 3.3	
;	db	0,5,52h,50h,3,5,20h

;CRTERRTAB: ; 18/05/2019 - MSDOS 6.0	
;	db	0,5,52h,50h,3,5,20h,2

; 08/08/2018

CRTERRTAB:	;LABEL BYTE	; Lookup table for MakeNode returns
	DB	0			; none
	DB	error_access_denied	; MakeNode error 1
	DB	error_cannot_make	; MakeNode error 2
	DB	error_file_exists	; MakeNode error 3
	DB	error_path_not_found	; MakeNode error 4
	DB	error_access_denied	; MakeNode error 5
	DB	error_sharing_violation ; MakeNode error 6
	; MSDOS 6.0
	DB	error_file_not_found	; MakeNode error 7

; ---------------------------------------------------------------------------

; We have just created a new file. This results in the truncation of old
; files. We must inform the sharer to slash all the open SFT's for this
; file to the current size.

; If we created a volume id on the diskette, set the VOLCHNG_FLAG to logical
; drive number to force a Build BPB after Media Check.

;;; FASTOPEN 8/29/86
Create_ok:
	call	FastOpen_Delete
;;; FASTOPEN 8/29/86
	mov	al,[SATTRIB]
	test	al,attr_volume_id
	jz	short NoVolLabel
	LES	DI,[THISCDS]
	;mov	ah,[ES:DI+curdir.text]	; get drive letter
	mov	ah,[ES:DI] ; 09/08/2018
	sub	ah,'A'	; 41h		; convert to drive number
	mov	[VOLCHNG_FLAG],ah	;Set flag to indicate volid change
	
	; 18/05/2019 - Retro DOS v4.0

	; MSDOS 6.0
	MOV	BH,1			;AN000;>32mb set volume id to boot record
	CALL	Set_Media_ID		;AN000;>32mb
	
	call	ECritDisk
	call	FATREAD_CDS		; force a media check
	call	LCritDisk

NoVolLabel:
	MOV	ax,2
	LES	DI,[THISSFT]
;if installed
	;call	JShare + 14 * 4
	call	far [JShare+(14*4)] ; 14 = ShSU
;else
;	Call	ShSU
;endif
	call	LCritDisk
	jmp	SET_SFT_MODE

;---------------------------------------------------------------------------
; Procedure Name : Dos_Create_New
;
; Inputs:
;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
;		terminated)
;	[CURR_DIR_END] Points to end of Current dir part of string
;		( = -1 if current dir not involved, else
;		 Points to first char after last "/" of current dir part)
;	[THISCDS] Points to CDS being used
;		(Low word = -1 if NUL CDS (Net direct request))
;	[THISSFT] Points to SFT to fill in if file created
;		(sf_mode field set so that FCB may be detected)
;	[SATTRIB] Is attribute of search, determines what files can be found
;	AX is Attribute to create
; Function:
;	Try to create the specified file truncating an old one that exists
; Outputs:
;	sf_ref_count is NOT altered
;	CARRY CLEAR
;	    THISSFT filled in.
;		sf_mode = sharing_compat + open_for_both for Non-FCB SFT
;	CARRY SET
;	    AX is error code
;		error_path_not_found
;			Bad path (not in curr dir part if present)
;		error_bad_curr_dir
;			Bad path in current directory part of path
;		error_access_denied
;			Create a second volume id or create a dir
;		error_file_exists
;			Already a file by this name
; DS preserved, others destroyed
;---------------------------------------------------------------------------

DOS_Create_New:
	MOV	AH,1		; Truncate is NOT OK
	JMP	Create_inter

; MSDOS 6.0
;---------------------------------------------------------------------------
; Procedure Name : Set_Media_ID
;
; Inputs:
;	NAME1= Volume ID
;	BH= 0, delete volume id
;	    1, set new volume id
;	DS= DOSGROUP
; Function:
;	Set Volume ID to DOS 4.00 Boot record.
; Outputs:
;	CARRY CLEAR
;	    volume id set
;	CARRY SET
;	    AX is error code
;---------------------------------------------------------------------------

	; 18/05/2019 - Retro DOS v4.0
Set_Media_ID:
	PUSH	AX		;AN000;;>32mb
	PUSH	ES		;AN000;;>32mb
	PUSH	DI		;AN000;;>32mb

	INC	AH		;AN000;;>32mb  bl=drive #
	MOV	BL,AH		;AN000;;>32mb  bl=drive # (A=1,B=2,,,)
	MOV	AL,0DH		;AN000;;>32mb  generic IOCTL
	MOV	CX,0866H	;AN001;;>32mb  get media id

;hkn; PACKET_TEMP is in DOSDATA
	MOV	DX,Packet_Temp	;AN000;>32mb

	PUSH	BX		;AN000;;>32mb
	PUSH	DX		;AN000;;>32mb
	XOR	BH,BH		;AN000;;>32mb

	;invoke	$IOCTL		;AN000;;>32mb
	call	_$IOCTL	

	POP	DX		;AN000;;>32mb
	POP	BX		;AN000;;>32mb
	JC	short geterr	;AN000;;>32mb

	OR	BH,BH		;AN000;;>32mb delete volume id
	JZ	short NoName	;AN000;>32mb yes

;hkn; NAME1 is in DOSDATA
	MOV	SI,NAME1	;AN000;>32mb

	JMP	SHORT doset	;AN000;>32mb yes
NoName: 			;AN000;

;hkn; NO_NAME_ID is in DOSDATA
	MOV	SI,NO_NAME_ID	;AN000;>32mb

doset:				;AN000;
	MOV	DI,DX		;AN000;;>32mb
	;add	di,6
	ADD	DI,MEDIA_ID_INFO.MEDIA_Label ;AN000;;>32mb

;hkn; ES & DS must point to SS
;hkn;	PUSH	CS		;AN000;;>32mb  move new volume id to packet
	PUSH	SS		;AN000;;>32mb  move new volume id to packet

	POP	DS		;AN000;;>32mb

;hkn;	PUSH	CS		;AN000;;>32mb
	PUSH	SS		;AN000;;>32mb

	POP	ES		;AN000;;>32mb
	MOV	CX,11		;AN000;;>32mb
	REP	MOVSB		;AN000;;>32mb
	MOV	CX,0846H	;AN001;;>32mb
	MOV	AL,0DH		;AN000;;>32mb
	XOR	BH,BH		;AN000;;>32mb
	;invoke	$IOCTL		;AN000;;>32mb  set volume id
	call	_$IOCTL	
geterr: 			;AN000;
;hkn;	PUSH	CS		;AN000;>32mb
	PUSH	SS		;AN000;>32mb

	POP	DS		;AN000;>32mb   ds= dosgroup

	POP	DI		;AN000;;>32mb
	POP	ES		;AN000;;>32mb
	POP	AX		;AN000;;>32mb
	retn			;AN000;>32mb

; MSDOS 6.0
;---------------------------------------------------------------------------
; Procedure Name : Set_EXT_mode
;
; Inputs:
;	[EXTOPEN_ON]= flag for extended open
;	SAVE_BX= mode specified in Extended Open
; Function:
;	Set mode in ThisSFT
; Outputs:
;	carry set,mode is set if from Extended Open
;	carry clear, mode not set yet
;---------------------------------------------------------------------------

; 13/05/2019 - Retro DOS v4.0

Set_EXT_mode:

;hkn; SS override
	TEST	byte [ss:EXTOPEN_ON],EXT_OPEN_ON ;AN000;EO. from extended open
	JZ	short NOTEX		    ;AN000;EO. no, do normal
	PUSH	AX			    ;AN000;EO.

;hkn; SS override
	MOV	AX,[ss:SAVE_BX]		    ;AN000;EO.
	;or	[es:di+2],ax
	OR	[ES:DI+SF_ENTRY.sf_mode],AX ;AN000;EO.
	POP	AX			    ;AN000;EO.
	STC				    ;AN000;EO.
NOTEX:					    ;AN000;
	retn				    ;AN000;EO.

;============================================================================
; OPEN.ASM, MSDOS 6.0, 1991
;============================================================================
; 08/08/2018 - Retro DOS v3.0
; 18/05/2019 - Retro DOS v4.0

;	TITLE	DOS_OPEN - Internal OPEN call for MS-DOS
;	NAME	DOS_OPEN

;**	OPEN.ASM - File Open
;----------------------------------------------------------------------------
;	Low level routines for openning a file from a file spec.
;	Also misc routines for sharing errors
;
;	DOS_Open
;	Check_Access_AX
;	SHARE_ERROR
;	SET_SFT_MODE
;	Code_Page_Mismatched_Error		   ; DOS 4.00
;
;	Revision history:
;
;	    Created: ARR 30 March 1983
;	    A000	version 4.00   Jan. 1988
;
;	M034 - The value in save_bx must be pushed on to the stack for
; 	       remote extended opens and not save_cx.
;
;	M035 - if open made from exec then we must set the appropriate bits
;	       on the stack before calling off to the redir.
;	M042 - Bit 11 of DOS34_FLAG set indicates that the redir knows how 
;	       to handle open from exec. In this case set the appropriate bit
;	       else do not.
;----------------------------------------------------------------------------	

;Installed = TRUE

;	i_need	NoSetDir,BYTE
;	i_need	THISSFT,DWORD
;	i_need	THISCDS,DWORD
;	i_need	CURBUF,DWORD
;	i_need	CurrentPDB,WORD
;	i_need	CURR_DIR_END,WORD
;	I_need	RetryCount,WORD
;	I_need	Open_Access,BYTE
;	I_need	fSharing,BYTE
;	i_need	JShare,DWORD
;	I_need	FastOpenFlg,byte
;	I_need	EXTOPEN_ON,BYTE 		  ;AN000;; DOS 4.00
;	I_need	ALLOWED,BYTE			  ;AN000;; DOS 4.00
;	I_need	EXTERR,WORD			  ;AN000;; DOS 4.00
;	I_need	EXTERR_LOCUS,BYTE		  ;AN000;; DOS 4.00
;	I_need	EXTERR_ACTION,BYTE		  ;AN000;; DOS 4.00
;	I_need	EXTERR_CLASS,BYTE		  ;AN000;; DOS 4.00
;	I_need	CPSWFLAG,BYTE			  ;AN000;; DOS 4.00
;	I_need	EXITHOLD,DWORD			  ;AN000;; DOS 4.00
;	I_need	THISDPB,DWORD			  ;AN000;; DOS 4.00
;	I_need	SAVE_CX,WORD			  ;AN000;; DOS 4.00
;	I_need	SAVE_BX,WORD			  ;M034
;
;	I_need	DOS_FLAG,BYTE
;	I_need	DOS34_FLAG,WORD			  ;M042

;Break	<DOS_Open - internal file access>
;---------------------------------------------------------------------------
; Procedure Name : DOS_Open
;
; Inputs:
;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
;		terminated)
;	[CURR_DIR_END] Points to end of Current dir part of string
;		( = -1 if current dir not involved, else
;		 Points to first char after last "/" of current dir part)
;	[THISCDS] Points to CDS being used
;		(Low word = -1 if NUL CDS (Net direct request))
;	[THISSFT] Points to SFT to fill in if file found
;		(sf_mode field set so that FCB may be detected)
;	[SATTRIB] Is attribute of search, determines what files can be found
;	AX is Access and Sharing mode
;	  High NIBBLE of AL (Sharing Mode)
;		sharing_compat	   file is opened in compatibility mode
;		sharing_deny_none  file is opened Multi reader, Multi writer
;		sharing_deny_read  file is opened Only reader, Multi writer
;		sharing_deny_write file is opened Multi reader, Only writer
;		sharing_deny_both  file is opened Only reader, Only writer
;	  Low NIBBLE of AL (Access Mode)
;		open_for_read	file is opened for reading
;		open_for_write	file is opened for writing
;		open_for_both	file is opened for both reading and writing.
;
;	  For FCB SFTs AL should = sharing_compat + open_for_both
;		(not checked)
; Function:
;	Try to open the specified file
; Outputs:
;	sf_ref_count is NOT altered
;	CARRY CLEAR
;	    THISSFT filled in.
;	CARRY SET
;	    AX is error code
;		error_file_not_found
;			Last element of path not found
;		error_path_not_found
;			Bad path (not in curr dir part if present)
;		error_bad_curr_dir
;			Bad path in current directory part of path
;		error_invalid_access
;			Bad sharing mode or bad access mode or bad combination
;		error_access_denied
;			Attempt to open read only file for writting, or
;			open a directory
;		error_sharing_violation
;			The sharing mode was correct but not allowed
;			generates an INT 24 on compatibility mode SFTs
; DS preserved, others destroyed
;----------------------------------------------------------------------------

; 18/05/2019 - Retro DOS v4.0
; DOSCODE:6A60h (MSDOS 6.21, MSDOS.SYS)
; 14/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:6A4Ch (MSDOS 5.0, MSDOS.SYS)

DOS_OPEN:
	; DS has been set up to DOSDATA in file.asm and fcbio2.asm. 

	MOV	byte [NoSetDir],0
	CALL	Check_Access_AX
	JC	short do_ret_label	    ; retc

	LES	DI,[THISSFT]
	XOR	AH,AH

	; sleaze! move only access/sharing mode in. Leave sf_isFCB unchanged

	MOV	[ES:DI+SF_ENTRY.sf_mode],AL ; For moment do this on FCBs too
	PUSH	ES
	LES	SI,[THISCDS]
	; 18/08/2018
	CMP	SI,-1
	JNZ	short TEST_RE_NET1
	POP	ES

	; MSDOS 6.0
;Extended open hooks
	TEST	byte [EXTOPEN_ON],EXT_OPEN_ON ;FT. from extnded open		;AN000;
	JZ	short _NOEXTOP 		    ;FT. no, do normal			;AN000;
_IFS_extopen:									;AN000;
	MOV	AL,[SAVE_BX]		    ; M034 - save_bx has original bx  
					    ; with which call was made. This
					    ; has the open access bits. 
	;;MOV	AL,[SAVE_CX]		    ; M034 - FT. al= create attribute
	
	PUSH	AX			    ;FT. pass create attr to IFS	;AN000;
	;mov	ax,112Eh
	;MOV	AX,(MultNET SHL 8) OR 46    ;FT. issue extended open verb	;AN000;
	mov	ax,(MultNET*256)+46 
	INT	2FH			    ;FT.				;AN000;
	POP	BX			    ;FT. trash bx			;AN000;
	MOV	byte [EXTOPEN_ON],0	    ;FT.				;AN000;

do_ret_label:
	retn				    ;FT.				;AN000;
_NOEXTOP:
;Extended open hooks
	;
;IF NOT Installed
	;transfer NET_SEQ_OPEN
;ELSE
	
do_net_int2f:
	test	byte [DOS_FLAG],EXECOPEN ; Q: was this open call made from exec
	jz	short not_exec_open	; N: just do net open
					; Y: check to see if redir is aware
					;    of this 
	
					; M042 - start
	;test	word [DOS34_FLAG],EXEC_AWARE_REDIR ; 800h
	test	byte [DOS34_FLAG+1],(EXEC_AWARE_REDIR>>8)
					; Q: does this redir know how to 
					;    this
	jz	short not_exec_open	; N: just do net open
					; Y: set bit 3 of access byte and 
					;    set sharing mode to DENY_WRITE
					; M042 - end
	
	; NOTE: This specific mode has not been set for the code assembled
	; under the "NOT Installed" conditional. Currently Installed is 
	; always one.
					; M035 - set the bits on the stack
	;mov	al,23h
	mov	AL,SHARING_DENY_WRITE+EXEC_OPEN
	
not_exec_open:
	; MSDOS 3.3 & MSDOS 6.0
	PUSH	AX

	;MOV	AX,(MultNET SHL 8) OR 22
	;INT	2FH

	mov     ax,1116h
	int     2Fh	; Multiplex - NETWORK REDIRECTOR - OPEN EXISTING REMOTE FILE
			; ES:DI -> uninitialized SFT, SS = DOS CS
			; SDA first filename pointer -> fully-qualified name of file to open
			; STACK: WORD file open mode
			; Return: CF set on error

	POP	BX			; clean stack
;do_ret_label: ; 09/08/2018
	retn
;ENDIF

TEST_RE_NET1:
	;TEST	word [ES:SI+curdir.flags],curdir_isnet
	; 17/12/2022
	test	byte [ES:SI+curdir.flags+1],curdir_isnet>>8
	POP	ES
	; 18/05/2019
	JZ	short LOCAL_OPEN

;Extended open hooks
	; MSDOS 6.0
	TEST	byte [EXTOPEN_ON],EXT_OPEN_ON ;FT. from extended open	;AN000;
	JNZ	short _IFS_extopen	      ;FT. isuue extended open	;AN000;
;Extended open hooks

;IF NOT Installed
;	transfer NET_OPEN
;ELSE
	jmp	short do_net_int2f
;ENDIF

LOCAL_OPEN:
	; MSDOS 3.3 & MSDOS 6.0
	call	ECritDisk

; DOS 3.3 FastOPen 6/16/86

	;or	byte [FastOpenFlg],5
	OR	byte [FastOpenFlg],FastOpen_Set+Special_Fill_Set ; only open can

	call	GETPATH

; DOS 3.3 FastOPen 6/16/86

	JNC	short Open_found
	JNZ	short bad_path2
	OR	CL,CL
	JZ	short bad_path2
OpenFNF:
	MOV	AX,error_file_not_found	; 2
OpenBadRet:
;hkn; FastOpenFlg is in DOSDATA use SS override
	; 12/08/2018
	;mov	byte [cs:FastOpenFlg],0 ; IBMDOS.COM (MSDOS 3.3) offset 36CAh
	; MSDOS 6.0
	AND	BYTE [SS:FastOpenFlg],Fast_yes    ;; DOS 3.3
	STC
	;call	LCritDisk
	; 16/12/2022
	jmp	LCritDisk
	;;JMP	Clear_FastOpen ; 10/08/2018
	;retn 	; 08/09/2018
	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;jmp	Clear_FastOpen

bad_path2:
	MOV	AX,error_path_not_found	; 3
	JMP	short OpenBadRet

Open_Bad_Access:
	MOV	AX,error_access_denied	; 5
	JMP	short OpenBadRet

Open_found:
	JZ	short Open_Bad_Access 	; test for directories
	OR	AH,AH
	JS	short open_ok		; Devices don't have attributes
	MOV	ES,[CURBUF+2]		; get buffer location
	;mov	al,[es:bx+0Bh]
	MOV	AL,[ES:BX+dir_entry.dir_attr]
	TEST	AL,attr_volume_id	; can't open volume ids
	JNZ	short Open_Bad_Access
	TEST	AL,attr_read_only	; check write on read only
	JZ	short open_ok

; The file is marked READ-ONLY. We verify that the open mode allows access to
; the read-only file. Unfortunately, with FCB's and net-FCB's we cannot
; determine at the OPEN time if such access is allowed. Thus, we defer such
; processing until the actual write operation:
;
; If FCB, then we change the mode to be read_only.
; If net_FCB, then we change the mode to be read_only.
; If not open for read then error.

	push	ds
	push	si
	LDS	SI,[THISSFT]
	;mov	cx,[si+2]
	MOV	CX,[SI+SF_ENTRY.sf_mode]
	; 17/12/2022
	;test	ch,80h
	test	ch,sf_isFCB>>8
	;TEST	CX,sf_isFCB ; 8000h	; is it FCB?
	JNZ	short ResetAccess	; yes, reset the access
	MOV	DL,CL
	AND	DL,SHARING_MASK	; 0F0h
	CMP	DL,SHARING_NET_FCB ; 70h ; is it net FCB?
	JNZ	short NormalOpen	; no
ResetAccess:
	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)	
	;AND	CX,~access_mask	; 0FFF0h ; clear access
	; 16/12/2022
	and	cl,0F0h ; 18/05/2019
;	OR	CX,open_for_read ; 0	; stick in open_for_read
	MOV	[SI+SF_ENTRY.sf_mode],CX
	JMP	SHORT FillSFT

; The SFT is normal. See if the requested access is open_for_read

NormalOpen:
	AND	CL,access_mask	;0Fh	; remove extras
	CMP	CL,open_for_read ; 0	; is it open for read?
	JZ	short FillSFT
	pop	si
	pop	ds
	JMP	short Open_Bad_Access
;
; All done, restore registers and fill the SFT.
;
FillSFT:
	pop	si
	pop	ds
open_ok:
	call	DOOPEN			; Fill in SFT

;hkn; FastOpenFlg is in DOSDATA. use SS override
	; 18/05/2019
	;and	byte [ss:FastOpenFlag],80h
	AND	BYTE [SS:FastOpenFlg],Fast_yes	;; DOS 3.3
	; 12/08/2018
	;and	byte [FastOpenFlg],Fast_yes	

	; MSDOS 6.0
	CALL	DO_SHARE_CHECK
	JNC	short SHARE_OK
	;call	LCritDisk
	; 16/12/2022
	jmp	LCritDisk
	;;JMP	short Clear_FastOpen
	;retn	; 18/05/2019
	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;jmp	short Clear_FastOpen	

	; MSDOS 3.3
;DO_SHARE_CHECK:
;	MOV	CX,[RetryCount]		; Get # tries to do
;OpenShareRetry:
;	push	cx			; Save number left to do
;	call	SHARE_CHECK		; Final Check
;	pop	cx			; CX = # left
;	JNC	short SHARE_OK		; No problem with access
;	call	Idle
;	LOOP	OpenShareRetry		; One more retry used up
;OpenShareFail:
;	LES	DI,[THISSFT]
;	call	SHARE_ERROR
;	JNC	short DO_SHARE_CHECK	; User wants more retry
	
	;12/08/2018
	;mov	byte [ss:FastOpenFlg],0
	;08/09/2018
	;mov	byte [FastOpenFlg],0
	;call	LCritDisk
	;JMP	short Clear_FastOpen
	;retn

SHARE_OK:
	; MSDOS 3.3 & MSDOS 6.0
	MOV	AX,3
	LES	DI,[THISSFT]
;if installed
	;call	JShare + 14 * 4
	call	far [JShare+(14*4)]  ; 14 = ShSU
;else
;	Call	ShSU
;endif
	call	LCritDisk
	
	;FallThru Set_SFT_Mode

;----------------------------------------------------------------------------
; Procedure Name : SET_SFT_MODE
;
; Finish SFT initialization for new reference. Set the correct mode.
;
;   Inputs:
;	ThisSFT points to SFT
;
;   Outputs:
;	Carry clear
;   Registers modified: AX.
;---------------------------------------------------------------------------

;hkn; called from create. DS already set up to DOSDATA.

SET_SFT_MODE:
	LES	DI,[THISSFT]
	call	DEV_OPEN_SFT
	;test	word [es:di+2],8000h
	; 17/12/2022
	;test	byte [es:di+3],80h
	test	byte [ES:DI+SF_ENTRY.sf_mode+1],sf_isFCB>>8
	;TEST	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB ; Clears carry
	JZ	short Clear_FastOpen	; sf_mode correct (retz)
	MOV	AX,[CurrentPDB]
	;mov	[es:di+31h],ax
	MOV	[ES:DI+SF_ENTRY.sf_PID],AX ; For FCB sf_PID=PDB

Clear_FastOpen:
	retn			       ;;;;; DOS 3.3

;----------------------------------------------------------------------------
; Procedure Name : SHARE_ERROR
;
; Called on sharing violations. ES:DI points to SFT. AX has error code
; If SFT is FCB or compatibility mode gens INT 24 error.
; Returns carry set AX=error_sharing_violation if user says ignore (can't
; really ignore). Carry clear if user wants a retry. ES, DI, DS preserved
;---------------------------------------------------------------------------

SHARE_ERROR:
	; 17/12/2022
	;test	byte [es:di+3],80h
	test	byte [ES:DI+SF_ENTRY.sf_mode+1],sf_isFCB>>8 ; 80h
	;TEST	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB ; 8000h
	JNZ	short _HARD_ERR
	MOV	CL,[ES:DI+SF_ENTRY.sf_mode]
	AND	CL,SHARING_MASK  ; 0F0h
	;CMP	CL,SHARING_COMPAT ; 0
	;JNE	short _NO_HARD_ERR
	; 21/09/2023
	jnz	short _NO_HARD_ERR
_HARD_ERR:
	call	SHARE_VIOLATION
	;retnc				; User wants retry
	jnc	short Clear_FastOpen
_NO_HARD_ERR:
	MOV	AX,error_sharing_violation  ; 20h
	STC
	retn

; MSDOS 6.0
;----------------------------------------------------------------------------
; Procedure Name : DO_SHARE_CHECK
;
; Input: THISDPB, WFP_Start, THISSFT set
; Functions: check file sharing mode is valid
; Output: carry set, error
;	  carry clear, share ok
;----------------------------------------------------------------------------

	; 18/05/2019 - Retro DOS v4.0
DO_SHARE_CHECK:
	call	ECritDisk		; enter critical section
OPN_RETRY:
	MOV	CX,[RetryCount]		; Get # tries to do
OpenShareRetry:
	push	cx			; Save number left to do
	call	SHARE_CHECK		; Final Check
	pop	cx			; CX = # left
	JNC	short Share_Ok2		; No problem with access
	call	Idle
	LOOP	OpenShareRetry		; One more retry used up
OpenShareFail:
	LES	DI,[THISSFT]
	call	SHARE_ERROR
	JNC	short OPN_RETRY		; User wants more retry
Share_Ok2:
	;call	LCritDisk		; leave critical section
	;retn
	; 18/12/2022
	jmp	LCritDisk

;-----------------------------------------------------------------------------
; Procedure Name : Check_Access
;
; Inputs:
;	AX is mode
;	  High NIBBLE of AL (Sharing Mode)
;		sharing_compat	   file is opened in compatibility mode
;		sharing_deny_none  file is opened Multi reader, Multi writer
;		sharing_deny_read  file is opened Only reader, Multi writer
;		sharing_deny_write file is opened Multi reader, Only writer
;		sharing_deny_both  file is opened Only reader, Only writer
;	  Low NIBBLE of AL (Access Mode)
;		open_for_read	file is opened for reading
;		open_for_write	file is opened for writing
;		open_for_both	file is opened for both reading and writing.
; Function:
;	Check this access mode for correctness
; Outputs:
;	[open_access] = AL input
;	Carry Clear
;		Mode is correct
;		AX unchanged
;	Carry Set
;		Mode is bad
;		AX = error_invalid_access
; No other registers effected
;----------------------------------------------------------------------------

Check_Access_AX:
	MOV	[OPEN_ACCESS],AL
	PUSH	BX

;	If sharing, then test for special sharing mode for FCBs

	MOV	BL,AL
	AND	BL,SHARING_MASK ; 0F0h
	CMP	byte [FSHARING],-1
	JNZ	short CheckShareMode	; not through server call, must be ok
	CMP	BL,SHARING_NET_FCB
	JZ	short CheckAccessMode	; yes, we have an FCB
CheckShareMode:
	CMP	BL,40h			; is this a good sharing mode?
	JA	short Make_Bad_Access
CheckAccessMode:
	MOV	BL,AL
	AND	BL,access_mask
	CMP	BL,2
	JA	short Make_Bad_Access
	POP	BX
	CLC
	retn

Make_Bad_Access:
	MOV	AX,error_invalid_access ; 0Ch
	POP	BX
	STC
	retn

;============================================================================
; DINFO.ASM, MSDOS 6.0, 1991
;============================================================================
; 08/08/2018 - Retro DOS v3.0
; 18/05/2019 - Retro DOS v4.0

;**	Low level routine for returning disk drive information from a local
;	  or NET device
;
;	DISK_INFO
;
;	  Modification history:
;
;		Created: ARR 30 March 1983

;	Break	<DISK_INFO -- Get Disk Drive Information>
;---------------------------------------------------------------------------
; Procedure Name : DISK_INFO
;
; Inputs:
;	[THISCDS] Points to the Macro List Structure of interest
;		(It MAY NOT be NUL, error not detected)
; Function:
;	Get Interesting Drive Information
; Returns:
;	DX = Number of free allocation units
;	BX = Total Number of allocation units on disk
;	CX = Sector size
;	AL = Sectors per allocation unit
;	AH = FAT ID BYTE
;	Carry set if error (currently user FAILed to I 24)
; Segs except ES preserved, others destroyed
;----------------------------------------------------------------------------

;hkn; called from getset.asm and misc.asm. DS has already been set up to 
;hkn; DOSDATA. 

DISK_INFO:
	; 08/08/2018 - Retro DOS v3.0
	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 37C5h

	call	TestNet
	JNC	short LOCAL_DSK_INFO

;IF NOT Installed
;	transfer NET_DISK_INFO
;ELSE
	;MOV	AX,(MultNET SHL 8) OR 12
	;INT	2FH
	;return

	mov     ax,110Ch
	int     2Fh	; Multiplex - NETWORK REDIRECTOR - GET DISK SPACE
			; ES:DI -> current directory
			; Return: AL = sectors per cluster, BX = total clusters
			; CX = bytes per sector, DX = number of available clusters
	retn
;ENDIF

LOCAL_DSK_INFO:
	MOV	byte [EXTERR_LOCUS],errLOC_Disk
	call	ECritDisk
	call	FATREAD_CDS		; perform media check.
	JC	short CRIT_LEAVE
	MOV	BX,2
	call	UNPACK			; Get first FAT sector into CURBUF
	JC	short CRIT_LEAVE
	LDS	SI,[CURBUF]
	;mov	ah,[si+20]
	MOV	AH,[SI+BUFINSIZ]	; get FAT ID BYTE

;hkn; SS is DOSDATA
	push	ss
	pop	ds
	;mov	cx,[es:bp+0Dh]
	MOV	CX,[ES:BP+DPB.MAX_CLUSTER]

; Examine the current free count. If it indicates that we have an invalid
; count, do the expensive calculation.

	;mov	dx,[es:bp+1Fh]
	MOV	DX,[ES:BP+DPB.FREE_CNT] ; get free count
	CMP	DX,-1			; is it valid?
	JZ	short DoScan

; Check to see if it is in a reasonable range. If so, trust it and return.
; Otherwise, we need to blast out an internal error message and then recompute
; the count.

	CMP	DX,CX			; is it in a reasonable range?
	JB	short GotVal		; yes, trust it.
DoScan:
	XOR	DX,DX
	DEC	CX
SCANFREE:
	call	UNPACK
	JC	short CRIT_LEAVE
	JNZ	short NOTFREECLUS
	INC	DX			; A free one
NOTFREECLUS:
	INC	BX			; Next cluster
	LOOP	SCANFREE
	DEC	BX			; BX was next cluster. Convert to
ReturnVals:
	DEC	BX			; count
	;mov	al,[es:bp+4]
	MOV	AL,[ES:BP+DPB.CLUSTER_MASK]
	INC	AL			; Sectors/cluster
	;mov	cx,[es:bp+2]
	MOV	CX,[ES:BP+DPB.SECTOR_SIZE] ; Bytes/sector
	;mov	[es:bp+1Fh],dx
	MOV	[ES:BP+DPB.FREE_CNT],DX
	CLC
CRIT_LEAVE:
	;call	LCritDisk
	;retn
	; 17/12/2022
	jmp	LCritDisk

; We have correctly computed everything previously. Load up registers for
; return.

GotVal: 
	MOV	BX,CX			; get cluster count
	JMP	short ReturnVals

;============================================================================
; ISEARCH.ASM, MSDOS 6.0, 1991
;============================================================================
; 22/07/2018 - Retro DOS v3.0

;	TITLE	DOS_SEARCH - Internal SEARCH calls for MS-DOS
;	NAME	DOS_SEARCH

;**	Low level routines for doing local and NET directory searches
;
;	DOS_SEARCH_FIRST
;	DOS_SEARCH_NEXT
;	RENAME_NEXT
;
;	Revision history:
;
;	    Created: ARR 30 March 1983
;	    A000	version 4.00  Jan. 1988
;	    A001	PTM 3564 -- search for fastopen

;Installed = TRUE

;--------------------------------------------------------------------------
;
; Procedure Name : DOS_SEARCH_FIRST
;
; Inputs:
;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
;		terminated)
;	[CURR_DIR_END] Points to end of Current dir part of string
;		( = -1 if current dir not involved, else
;		 Points to first char after last "/" of current dir part)
;	[THISCDS] Points to CDS being used
;		(Low word = -1 if NUL CDS (Net direct request))
;	[SATTRIB] Is attribute of search, determines what files can be found
;	[DMAADD] Points to 53 byte buffer
; Function:
;	Initiate a search for the given file spec
; Outputs:
;	CARRY CLEAR
;	    The 53 bytes ot DMAADD are filled in as follows:
;
;	LOCAL
;	    Drive Byte (A=1, B=2, ...) High bit clear
;		NEVER STORE DRIVE BYTE AFTER  found_it
;	    11 byte search name with Meta chars in it
;	    Search Attribute Byte, attribute of search
;	    WORD LastEnt value
;	    WORD DirStart
;	    4 byte pad
;	    32 bytes of the directory entry found
;	NET
;	    21 bytes First byte has high bit set
;	    32 bytes of the directory entry found
;
;	CARRY SET
;	    AX = error code
;		error_no_more_files
;			No match for this file
;		error_path_not_found
;			Bad path (not in curr dir part if present)
;		error_bad_curr_dir
;			Bad path in current directory part of path
; DS preserved, others destroyed
;---------------------------------------------------------------------------

; 24/01/2024
%if 1
	; 17/05/2019 - Retro DOS v4.0
GET_FAST_SEARCH:
	; 22/07/2018
	; MSDOS 6.0
	; 17/12/2022
	OR	byte [ss:DOS34_FLAG+1],(SEARCH_FASTOPEN>>8)  ; 04h
	;OR	word [ss:DOS34_FLAG],SEARCH_FASTOPEN  ; 400h
					;FO.trigger fastopen ;AN000;
	;call	DOS_SEARCH_FIRST
	;retn
	; 24/01/2024
	; 17/12/2022
	;jmp	DOS_SEARCH_FIRST
%endif

	; 14/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; DOSCODE:6C22h (MSDOS 5.0, MSDOS.SYS)

DOS_SEARCH_FIRST:
	; IBMDOS.COM (MSDOS 3.3 kernel) - Offset 3826h

	LES	DI,[THISCDS]
	CMP	DI,-1
	JNZ	short TEST_RE_NET2

;IF NOT Installed
;	transfer NET_SEQ_SEARCH_FIRST
;ELSE
	;mov	ax,1119h
	MOV	AX,(MultNET<<8)|25
	INT	2Fh
	retn
;ENDIF

TEST_RE_NET2:
	;test	word [es:di+43h],8000h
	; 17/12/2022
	;test	byte [es:di+44h],80h
	; 28/12/2022
	test	byte [ES:DI+curdir.flags+1],curdir_isnet>>8
	;TEST	word [ES:DI+curdir.flags],curdir_isnet
	JZ	short LOCAL_SEARCH_FIRST

;IF NOT Installed
;	transfer NET_SEARCH_FIRST
;ELSE
	;mov	ax,111Bh
	MOV	AX,(MultNET<<8)|27
	INT	2FH
	retn
;ENDIF
	; 18/05/2019 - Retro DOS v4.0
LOCAL_SEARCH_FIRST:
	call	ECritDisk
	; MSDOS 6.0
	;;test	word [DOS34_FLAG],400h
	; 17/12/2022
	;test	byte [DOS34_FLAG+1],04h
	test	byte [DOS34_FLAG+1],(SEARCH_FASTOPEN>>8)
	;TEST	word [DOS34_FLAG],SEARCH_FASTOPEN ;AN000;
	JZ	short NOFN			;AN000;
	;or	byte [FastOpenFlg],1
	OR	byte [FastOpenFlg],FastOpen_Set	;AN000;
NOFN:						;AN000;
	MOV	byte [NoSetDir],1	; if we find a dir, don't change to it

; 03/02/2024
%if 0
	; MSDOS 6.0
	CALL	CHECK_QUESTION		;AN000;;FO. is '?' in path
	JNC	short norm_GETPATH	;AN000;;FO. no
%else
	; 03/02/2024
	push	ss
	pop	ds			;AN000;;FO. ds:si -> final path
	mov	si,[WFP_START]		;AN000;;FO.
getnext:				;AN000;
	lodsb				;AN000;;FO. get char
	or	al,al			;AN000;;FO. is it null
	jz	short NO_Question	;AN000;;FO. yes
	cmp	al,'?'                  ;AN000;;FO. is '?'
	jne	short getnext 		;AN000;;FO. no
%endif
	;and	byte [FastOpenFlg],80h
	AND	byte [FastOpenFlg],Fast_yes ;AN000;;FO. reset fastopen
NO_Question:	; 03/02/2024
norm_GETPATH:
	call	GETPATH
	; BX = offset NAME1
;_getdone:
	JNC	short find_check_dev
	JNZ	short bad_path3
	OR	CL,CL
	JZ	short bad_path3
find_no_more:
	;mov	ax,12h
	MOV	AX,error_no_more_files
BadBye:
	; MSDOS 6.0
	AND	byte [SS:FastOpenFlg],Fast_yes  ;AN000;;FO. reset fastopen

	STC
	;call	LCritDisk
	;retn
	; 18/12/2022
	jmp	LCritDisk

bad_path3:
	;mov	ax,3
	MOV	AX,error_path_not_found
	JMP	short BadBye

find_check_dev:
	OR	AH,AH
	JNS	short found_entry
	MOV	word [LASTENT],-1	; Cause DOS_SEARCH_NEXT to fail
	INC	byte [FOUND_DEV]	; Tell DOS_RENAME we found a device
found_entry:

; We set the physical drive byte here Instead of after found_it; Doing
; a search-next may not have wfp_start set correctly

	LES	DI,[DMAADD]
	MOV	SI,[WFP_START]		; get pointer to beginning
	LODSB
	SUB	AL,'A'-1                ; logical drive
	STOSB				; High bit not set (local)
found_it:
	LES	DI,[DMAADD]
	INC	DI

	; MSDOS 6.0
	PUSH	DS				  ;FO.;AN001; save ds
	;test	byte [FastOpenFlg],10h
	TEST	byte [FastOpenFlg],Set_For_Search ;FO.;AN001; from fastopen
	JZ	short notfast			  ;FO.;AN001;
	MOV	SI,BX				  ;FO.;AN001;
	MOV	DS,[CURBUF+2]			  ;FO.;AN001;
	JMP	SHORT movmov			  ;FO.;AN001;

notfast:
	MOV	SI,NAME1		; find_buf 2 = formatted name
movmov:
; Special E5 code
	MOVSB
	CMP	BYTE [ES:DI-1],5
	JNZ	short NOTKANJB
	MOV	BYTE [ES:DI-1],0E5H
NOTKANJB:
	;MOV	CX,10
	;REP	MOVSB
	; 03/02/2024
	mov	cx,5
	rep	movsw

	; 08/09/2018
	POP	DS			;FO.;AN001; restore ds

	MOV	AL,[ATTRIB]
	STOSB
	PUSH	AX			; Save AH device info
	MOV	AX,[LASTENT]
	STOSW
	MOV	AX,[DIRSTART]
	STOSW
; 4 bytes of 21 byte cont structure left for NET stuff
	ADD	DI,4
	POP	AX			; Recover AH device info
	OR	AH,AH
	JS	short DOSREL		; Device entry is DOSGROUP relative
	CMP	WORD [CURBUF],-1
	JNZ	short OKSTORE

	; MSDOS 6.0
	TEST	byte [FastOpenFlg],Set_For_Search
					;AN000;;FO. from fastopen and is good
	JNZ	short OKSTORE		;AN000;;FO.

	; The user has specified the root directory itself, rather than some
	; contents of it. We can't "find" that.

	MOV	WORD [ES:DI-8],-1	; Cause DOS_SEARCH_NEXT to fail by
					;   stuffing a -1 at Lastent
	JMP	find_no_more

OKSTORE:
	MOV	DS,[CURBUF+2]
DOSREL:
	; BX = offset NAME1 (from GETPATH)
	MOV	SI,BX			; SI-> start of entry

; NOTE: DOS_RENAME depends on BX not being altered after this point

	;;mov	cx,32
	;MOV	CX,dir_entry.size
	; 03/02/2024
	mov	cx,dir_entry.size>>1
;;;;; 7/29/86
	MOV	AX,DI			; save the 1st byte addr
	;REP	MOVSB
	rep	movsw
	;
	MOV	DI,AX			; restore 1st byte addr
	CMP	BYTE [ES:DI],05H	; special char check
	JNZ	short NO05
	MOV	BYTE [ES:DI],0E5H	; convert it back to E5
NO05:

;;;;; 7/29/86

;hkn; FastOpenflg is in DOSDATA use SS
	; 16/12/2022
	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	; MSDOS 6.0
	;AND	byte [SS:FastOpenFlg],Fast_yes ;AN000;;FO. reset fastopen
	; 18/05/2019 - Retro DOS v4.0
	push	ss
	pop	ds
	; 16/12/2022
	AND	byte [FastOpenFlg],Fast_yes

;hkn; SS is DOSDATA
	;push	ss
	;pop	ds
	CLC
	;call	LCritDisk
	;retn
	; 16/12/2022
	jmp	LCritDisk

;BREAK <DOS_SEARCH_NEXT - scan for subsequent matches>
;----------------------------------------------------------------------------
;
; Procedure Name : DOS_SEARCH_NEXT
;
; Inputs:
;	[DMAADD] Points to 53 byte buffer returned by DOS_SEARCH_FIRST
;	    (only first 21 bytes must have valid information)
; Function:
;	Look for subsequent matches
; Outputs:
;	CARRY CLEAR
;	    The 53 bytes at DMAADD are updated for next call
;		(see DOS_SEARCH_FIRST)
;	CARRY SET
;	    AX = error code
;		error_no_more_files
;			No more files to find
; DS preserved, others destroyed
;---------------------------------------------------------------------------

;hkn; called from search.asm. DS already set up at this point.

DOS_SEARCH_NEXT:
	LES	DI,[DMAADD]
	MOV	AL,[ES:DI]
	TEST	AL,80H			; Test for NET
	JZ	short LOCAL_SEARCH_NEXT
;IF NOT Installed
;	transfer NET_SEARCH_NEXT
;ELSE
	;mov	ax,111Ch
	MOV	AX,(MultNET<<8)|28
	INT	2FH  ; Multiplex - NETWORK REDIRECTOR - FINDNEXT
		     ; SS = DS = DOS CS, [DTA] = 21-byte findfirst search data
		     ; Return: CF set on error, AX = DOS error code
		     ; CF clear if successful
	retn
;ENDIF

LOCAL_SEARCH_NEXT:
	;AL is drive A=1
	;mov	byte [EXTERR_LOCUS],2
	MOV	byte [EXTERR_LOCUS],errLOC_Disk
	call	ECritDisk

;hkn; DummyCDS is in DOSDATA
	MOV     word [THISCDS],DUMMYCDS
;hkn; Segment address is DOSDATA - use ds
;hkn;	MOV     WORD [THISCDS+2],CS
	mov	[THISCDS+2],DS

	ADD	AL,'A'-1
	call	InitCDS

;	call	GETTHISDRV		; Set CDS pointer

	JC	short No_files		; Bogus drive letter
	LES	DI,[THISCDS]		; Get CDS pointer
	;les	bp,[es:di+45h]
	LES	BP,[ES:DI+curdir.devptr] ; Get DPB pointer
	call	GOTDPB			; [THISDPB] = ES:BP

	; 16/12/2022
	mov	al,[ES:BP]
	; 14/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;mov	AL,[ES:BP+DPB.DRIVE] ; mov al,[ES:BP+0]
	mov	[THISDRV],AL
	;mov	word [CREATING],0E500h
	MOV	WORD [CREATING],(DIRFREE*256)+0
	MOV	byte [NoSetDir],1	; if we find a dir, don't change to it
	LDS	SI,[DMAADD]
	LODSB				; Drive Byte

	;entry	RENAME_NEXT		; Entry used by DOS_RENAME
RENAME_NEXT:
	;context ES
	push	ss
	pop	es			; THIS BLOWS ES:BP POINTER TO DPB

;hkn; NAME1 is in DOSDATA
	MOV	DI,NAME1

	MOV	CX,11
	REP	MOVSB			; Search name
	LODSB				; Attribute

;hkn; SS override
	MOV	[SS:ATTRIB],AL
	LODSW				; LastEnt
	OR	AX,AX
	; 03/02/2024
	;JNS	short cont_load
	js	short No_files
;No_files:
	;JMP	find_no_more

cont_load:
	PUSH	AX			; Save LastEnt
	LODSW				; DirStart
	MOV	BX,AX

;hkn; SS is DOSDATA
	;context DS
	push	ss
	pop	ds
	LES	BP,[THISDPB]		; Recover ES:BP
	;invoke	SetDirSrch
	call	SETDIRSRCH
	JNC	short SEARCH_GOON
	POP	AX			; Clean stack
	;JMP	short No_files
	; 03/02/2024
No_files:
	JMP	find_no_more

SEARCH_GOON:
	call	STARTSRCH
	POP	AX
	call	GETENT
	JC	short No_files
	call	NEXTENT
	JC	short No_files
	XOR	AH,AH			; If Search_Next, can't be a DEV
	JMP	found_it ; 10/08/2018

; MSDOS 6.0
;---------------------------------------------------------------------------
;
; Procedure Name : CHECK_QUESTION
;
; Input: [WFP_START]= pointer to final path
; Function: check '?' char
; Output: carry clear, if no '?'
;	 carry set, if '?' exists
;---------------------------------------------------------------------------

; 03/02/2024
%if 0
	; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
CHECK_QUESTION:
;hkn;	wfp_start is in DOSDATA;hkn;	MOV	WORD PTR ThisCDS+2,CS
;hkn;	PUSH	CS			;AN000;;FO.
	push	ss
	POP	DS			;AN000;;FO. ds:si -> final path
	; 16/12/2022
	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	MOV	SI,[WFP_START]		;AN000;;FO.
	;mov	si,[ss:WFP_START]
getnext:				;AN000;
	LODSB				;AN000;;FO. get char
	OR	AL,AL			;AN000;;FO. is it null
	JZ	short NO_Question	;AN000;;FO. yes
	CMP	AL,'?'                  ;AN000;;FO. is '?'
	JNZ	short getnext 		;AN000;;FO. no
	STC				;AN000;;FO.
NO_Question:				;AN000;
	retn				;AN000;;FO.
%endif

;============================================================================
; ABORT.ASM, MSDOS 6.0, 1991
;============================================================================
; 23/07/2018 - Retro DOS v3.0
; 18/05/2019 - Retro DOS v4.0

;**
;
; Internal Abort call closes all handles and FCBs associated with a process.
;  If process has NET resources a close all is sent out over the net.
;
;   DOS_ABORT
;
;   Modification history:
;
;       Created: ARR 30 March 1983
;
;	M038	SR	10/16/90	Free SFT with the PSP of the process
;				being terminated only if it is busy.
;

;Break   <DOS_ABORT -- CLOSE all files for process>
;--------------------------------------------------------------------------
;
; Procedure Name : DOS_ABORT
;
; Inputs:
;       [CurrentPDB] set to PID of process aborting
; Function:
;       Close all files and free all SFTs for this PID
; Returns:
;       None
; All destroyed except stack
;---------------------------------------------------------------------------

DOS_ABORT:
	MOV     ES,[SS:CurrentPDB]	; SS override
	MOV     CX,[ES:PDB.JFN_Length]  ; Number of JFNs
reset_free_jfn:
	MOV     BX,CX
	PUSH    CX
	DEC     BX                      ; get jfn (start with last one)

	CALL	_$CLOSE
	POP     CX
	LOOP    reset_free_jfn          ; and do 'em all

; Note: We do need to explicitly close FCBs. Reasons are as follows: If we
; are running in the no-sharing no-network environment, we are simulating the
; 2.0 world and thus if the user doesn't close the file, that is his problem
; BUT... the cache remains in a state with garbage that may be reused by the
; next process. We scan the set and blast the ref counts of the FCBs we own.
;
; If sharing is loaded, then the following call to close process will
; correctly close all FCBs. We will then need to walk the list AFTER here.
;
; Finally, the following call to NET_Abort will cause an EOP to be sent to all
; known network resources. These resources are then responsible for cleaning
; up after this process.
;
; Sleazy, eh?

	;context DS			; SS is DOSDATA
	push	ss
	pop	ds  ; 09/09/2018

	;CallInstall Net_Abort, MultNET, 29
	mov	ax,111Dh
	int     2Fh 	; Multiplex - NETWORK REDIRECTOR 
			;	    - CLOSE ALL REMOTE FILES FOR PROCESS
			; DS???, SS = DOS CS
;if installed
	call	far [JShare+(4*4)]	; 4 = MFTCloseP
;else
;	call 	MFTCloseP
;endif

; Scan the FCB cache for guys that belong to this process and zap their ref
; counts.
					; SS override
	les     di,[ss:SFTFCB]		; grab the pointer to the table
	;mov	cx,[es:di+4]
	mov     cx,[es:di+SFT.SFCount]
	jcxz    FCBScanDone
	;lea	di,[di+6]
	LEA     DI,[DI+SFT.SFTable]	; point at table
	mov     ax,[SS:PROC_ID]		; SS override
FCBTest:
	;cmp	[es:di+31h],ax
	cmp	[es:di+SF_ENTRY.sf_PID],ax ; is this one of ours
	jnz	short FCBNext		; no, skip it
	mov	word [es:di],0
	;mov	word [es:di+SF_ENTRY.sf_ref_count],0  ; yes, blast ref count
FCBNext:
	add     di,SF_ENTRY.size ; 59 (for MSDOS 6.0)
	loop    FCBTest
FCBScanDone:

; Walk the SFT to eliminate all busy SFT's for this process.

	XOR     BX,BX
Scan:
	push    bx
	call	SFFromSFN
	pop     bx
	;jnc	short Scan1
	;retn

	; 18/12/2022
	;jc	short NO_Question ; retn
	; 03/02/2024
	jc	short RET2

;M038
; Do what the comment above says, check for busy state

Scan1:
	;cmp	word [es:di],0
	;jz	short scan_next  ; MSDOS 3.3
	; MSDOS 6.0
	cmp	word [es:di],sf_busy ; -1
	;cmp	word [es:di+SF_ENTRY.sf_ref_count],sf_busy
				; Is Sft busy? ;M038
	jnz	short scan_next
;
; we have a SFT that is busy. See if it is for the current process
;
	mov     ax,[SS:PROC_ID]		; SS override
	;cmp	[es:di+31h],ax
	cmp	[es:di+SF_ENTRY.sf_PID],ax
	jnz	short scan_next
	mov     ax,[SS:USER_ID]		; SS override
	;cmp	[es:di+2Fh],ax
	cmp	[es:di+SF_ENTRY.sf_UID],ax
	jnz	short scan_next

; This SFT is labelled as ours.

	mov	word [es:di],0
	;mov	word [es:di+SF_ENTRY.sf_ref_count],0
scan_next:
	inc     bx
	jmp     short Scan

;============================================================================
; CLOSE.ASM, MSDOS 6.0, 1991
;============================================================================
; 23/07/2018 - Retro DOS v3.0
; 18/05/2019 - Retro DOS v4.0

;**	Internal Close and Commit calls to close a local or NET SFT.
;
;	DOS_CLOSE
;	DOS_COMMIT
;	FREE_SFT
;	SetSFTTimes
;
;	Revision history:
;
;	   AN000  version 4.00	Jan. 1988
;	   A005   PTM 3718 --- lost clusters when fastopen installed
;	   A011   PTM 4766 --- C2 fastopen problem

;Installed = TRUE

;Break <DOS_CLOSE -- CLOSE FILE from SFT>
;---------------------------------------------------------------------------
;
; Procedure Name : DOS_CLOSE
;
; Inputs:
;	[THISSFT] set to the SFT for the file being used
; Function:
;	Close the indicated file via the SFT
; Returns:
;	sf_ref_count decremented otherwise
;	ES:DI point to SFT
;	Carry set if error
;	    AX has error code
; DS preserved, others destroyed
;---------------------------------------------------------------------------

;hkn; DOS_CLOSE called from fcbio.asm and handle.asm. DS already set up.

; 18/05/2019 - Retro DOS v4.0
; DOSCODE:6E2Eh (MSDOS 6.21, MSDOS.SYS)

; 14/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:6E1Ah (MSDOS 5.0, MSDOS.SYS)

; 23/07/2018 - IBMDOS.COM (MSDOS 3.3), 1987 - Offset 39D0h

DOS_CLOSE:
	LES	DI,[THISSFT]
	;mov	bx,[ES:DI+5]
	MOV	BX,[ES:DI+SF_ENTRY.sf_flags]

; Network closes are handled entirely by the net code.

	;;test	bx,8000h
	;TEST	BX,sf_isnet
	; 17/12/2022
	;test	bh,80h
	test	bh,(sf_isnet>>8)
	JZ	short LocalClose

	;CallInstall Net_Close,MultNET,6
	mov     ax,1106h
	int     2Fh	; Multiplex - NETWORK REDIRECTOR - CLOSE REMOTE FILE
			; ES:DI -> SFT
			; SFT DPB field -> DPB of drive containing file
			; Return: CF set on error, AX = DOS error code
			; CF clear if successful
RET2:		; 03/02/2024
	retn

; All closes release the sharing information.
; No commit releases sharing information
;
; All closes decrement the ref count.
; No commit decrements the ref count.

LocalClose:
	call	ECritDisk
	CALL	SetSFTTimes
	CALL	FREE_SFT		; dec ref count or mark as busy

;hkn; SS is DOSDATA
	;Context DS
	push	ss
	pop	ds

	push	ax
	push	bx
	call	ShareEnd
	pop	bx
	pop	ax

; Commit enters here. AX from commit MUST be <> 1, BX is flags word

CloseEntry:
	PUSH	AX

; File clean or device does not get stamped nor disk looked at.

	;test	bx,0C0h
	; 17/12/2022
	test	bl,devid_file_clean+devid_device
	;TEST	BX,devid_file_clean+devid_device
	JZ	short rdir
	; 14/11/2022
	JMP	FREE_SFT_OK		; either clean or device
	;jnz	short FREE_SFT_OK ; 24/07/2019	

; Retrieve the directory entry for the file

rdir:
	CALL	DirFromSFT
	;mov	al,5
	MOV	AL,error_access_denied
	JNC	short clook
	; 14/11/2022
	JMP	CloseFinish		; pretend the close worked.
	;jc	short CloseFinish ; 24/07/2019
clook:

; ES:DI points to entry
; DS:SI points to SFT
; ES:BX points to buffer header

	push	di
	push	si
	;lea	si,[si+20h]
	LEA	SI,[SI+SF_ENTRY.sf_name]

; ES:DI point to directory entry
; DS:SI point to unpacked name

	call	XCHGP

; ES:DI point to unpacked name
; DS:SI point to directory entry

	call	MetaCompare
	call	XCHGP
	pop	si
	pop	di
	JZ	short CLOSE_GO		; Name OK
Bye:	
	MOV	DI,SI
	PUSH	DS
	POP	ES			; ES:DI points to SFT
	PUSH	SS
	POP	DS
	STC
	;mov	al,2
	MOV	AL,error_file_not_found
	JMP	CloseFinish ; 24/07/2019

	; 18/05/2019 - Retro DOS v4.0
CLOSE_GO:
	; 03/02/2024
	;mov	al,[si+4]
	mov	al,[si+SF_ENTRY.sf_attr]
	
	; MSDOS 6.0
	;test	word [si+2],8000h
	;TEST	word [SI+SF_ENTRY.sf_mode],sf_isFCB ; FCB ?
	; 17/12/2022
	;test	byte [si+3],80h
	test	byte [SI+SF_ENTRY.sf_mode+1],(sf_isFCB>>8) ; FCB ?
	JZ	short nofcb		; no, set dir attr, sf_attr
	; MSDOS 3.3 & MSDOS 6.0
	;mov	ch,[es:di+0Bh]
	MOV	CH,[ES:DI+dir_entry.dir_attr]

	; 03/02/2024
	;;mov	al,[si+4]
	;MOV	AL,[SI+SF_ENTRY.sf_attr]

;hkn; SS override
	MOV	[SS:ATTRIB],AL
	; MSDOS 3.3
	;;call	MatchAttributes
	;;JNZ	short Bye		; attributes do not match
	; 18/05/2019
	JMP	SHORT setattr		;FT.
nofcb:
	; 03/02/2024
	; MSDOS 6.0
	;;mov	al,[si+4]
	;MOV	AL,[SI+SF_ENTRY.sf_attr] ;FT.		;AN000;

	MOV	[ES:DI+dir_entry.dir_attr],AL ;FT.	;AN000;
setattr:
	; MSDOS 3.3 (& MSDOS 6.0)
	;or	byte [es:di+0Bh],20h
	OR	BYTE [ES:DI+dir_entry.dir_attr],attr_archive ;Set archive
	; MSDOS 6.0
	;mov	ax,[es:di+1Ah]
	MOV	AX,[ES:DI+dir_entry.dir_first] ;AN011
					;F.O. save old first cluster
;hkn; SS override
	MOV	[SS:OLD_FIRSTCLUS],AX	;AN011;F.O. save old first cluster

; 03/02/2024
%if 0
	;mov	ax,[si+0Bh]
	MOV	AX,[SI+SF_ENTRY.sf_firclus]
	;mov	[es:di+1Ah],ax
	MOV	[ES:DI+dir_entry.dir_first],AX	;Set firclus pointer
	;mov	ax,[si+11h]
	MOV	AX,[SI+SF_ENTRY.sf_size]
	;mov	[es:di+1Ch],ax
	MOV	[ES:DI+dir_entry.dir_size_l],AX	;Set size
	;mov	ax,[si+13h]
	MOV	AX,[SI+SF_ENTRY.sf_size+2]
	;mov	[es:di+1Eh],ax
	MOV	[ES:DI+dir_entry.dir_size_h],AX
	;mov	ax,[si+0Fh]
	MOV	AX,[SI+SF_ENTRY.sf_date]
	;mov	[es:di+18h],ax
	MOV	[ES:DI+dir_entry.dir_date],AX	;Set date
	;mov	ax,[si+0Dh]
	MOV	AX,[SI+SF_ENTRY.sf_time]
	;mov	[es:di+16h],ax
	MOV	[ES:DI+dir_entry.dir_time],AX	;Set time
%else
	; 03/02/2024 - Retro DOS v4.2
	push	si
	add	si,0Bh
	lodsw	; [si+SF_ENTRY.sf_firclus]
	;mov	[es:di+1Ah],ax
	mov	[es:di+dir_entry.dir_first],ax	; Set first cluster
	lodsw	; [si+SF_ENTRY.sf_time]
	mov	[es:di+dir_entry.dir_time],ax	; Set time
	lodsw	; [si+SF_ENTRY.sf_date]
	mov	[es:di+dir_entry.dir_date],ax	; Set date
	lodsw	; [si+SF_ENTRY.sf_size]
	mov	[es:di+dir_entry.dir_size_l],ax	; Set size
	lodsw	; [si+SF_ENTRY.sf_size+2]
	mov	[es:di+dir_entry.dir_size_h],ax
	pop	si
%endif

	; MSDOS 6.0
;; File Tagging
	TEST	byte [ES:BX+BUFFINFO.buf_flags],buf_dirty
				  ;LB. if already dirty		    ;AN000;
	JNZ	short yesdirty4	  ;LB.  don't increment dirty count ;AN000;
	; 02/06/2019
	call	INC_DIRTY_COUNT   ;LB.				    ;AN000;
	; MSDOS 3.3 (& MSDOS 6.0)
	;or	byte [es:bx+5],40h
	OR	byte [ES:BX+BUFFINFO.buf_flags],buf_dirty ;Buffer dirty
yesdirty4:
	push	ds
	push	si
	; MSDOS 6.0
	;mov	cx,[si+0Bh]
	; 07/12/2022
	MOV	CX,[SI+SF_ENTRY.sf_firclus] ; do this for Fastopen
;hkn; SS override
	MOV	AL,[SS:THISDRV]
	; MSDOS 3.3 
	;push	ss
	;pop	ds
	;MOV	AL,[THISDRV]
;;; 10/1/86  update fastopen cache
	; MSDOS 3.3 & MSDOS 6.0
	PUSH	DX
	MOV	AH,0			; dir entry update
	MOV	DL,AL			; drive number A=0, B=1,,,
	; MSDOS 6.0
	OR	CX,CX			;AN005; first cluster 0; may be truncated
	JNZ	short do_update2	;AN005; no, do update
	MOV	AH,3			;AN005; do a delete cache entry
	;mov	di,[si+1Bh]
	MOV	DI,[SI+SF_ENTRY.sf_dirsec] ;AN005; cx:di = dir sector
	;mov	cx,[si+1Dh]
	MOV	CX,[SI+SF_ENTRY.sf_dirsec+2] ;AN005;
	;mov	dh,[si+1Fh]
	MOV	DH,[SI+SF_ENTRY.sf_dirpos] ;AN005; dh = dir pos
	JMP	SHORT do_update 	;AN011;F.O.
do_update2:				;AN011;F.O.
;hkn; SS override fort OLD_FIRSTCLUS
	; 
	CMP	CX,[SS:OLD_FIRSTCLUS]	;AN011;F.O. same as old first clusetr?
	JZ	short do_update		;AN011;F.O. yes
	MOV	AH,2			;AN011;F.O. delete the old entry
	MOV	CX,[SS:OLD_FIRSTCLUS]	;AN011;F.O.
do_update:				;AN005;
;hkn; SS is DOSDATA
	;Context DS
	push	ss
	pop	ds
	; MSDOS 3.3 & MSDOS 6.0
	call	FastOpen_Update 	; invoke fastopen
	POP	DX

;;; 10/1/86  update fastopen cache
	call	FLUSHBUF		; flush all relevant buffers
	pop	di
	pop	es
	;mov	al,5
	MOV	AL,error_access_denied
	JC	short CloseFinish
FREE_SFT_OK:
	CLC				; signal no error.
CloseFinish:

; Indicate to the device that the SFT is being closed.

;;;; 7/21/86
	PUSHF				; save flag from DirFromSFT
	call	DEV_CLOSE_SFT
	POPF
;;;; 7/21/86
;
; See if the ref count indicates that we have busied the SFT. If so, mark the
; SFT as being free. Note that we do NOT need to be in critSFT as we are ONLY
; going to be moving from busy to free.
;
	POP	CX			; get old ref count
	PUSHF
	; 03/02/2024
	;DEC	CX			; if cx != 1
	;JNZ	short NoFree		; then do NOT free SFT
	loop	NoFree ; PCDOS 7.1 IBMDOS.COM

	mov	[es:di],cx ; 0
	;MOV	[ES:DI+SF_ENTRY.sf_ref_Count],CX ; mov [es:di+0],cx
NoFree:
	call	LCritDisk
	POPF
	retn

;---------------------------------------------------------------------------
;
; Procedure Name : FREE_SFT
;
; ES:DI -> SFT. Decs sft_ref_count. If the count goes to 0, mark it as busy.
; Flags preserved. Return old ref count in AX
;
; Note that busy is indicated by the SFT ref count being -1.
;
;---------------------------------------------------------------------------

FREE_SFT:
	PUSHF		; Save carry state
	mov	ax,[es:di]
	;MOV	AX,[ES:DI+SF_ENTRY.sf_ref_count]
	DEC	AX
	JNZ	short SetCount
	DEC	AX
SetCount:
	xchg	ax,[es:di]
	;XCHG	AX,[ES:DI+SF_ENTRY.sf_ref_count]
	POPF
	retn

	; 18/05/2019 - Retro DOS v4.0

;----------------------------------------------------------------------------
;
; Procedure Name : DirFromSFT
;
;   DirFromSFT - locate a directory entry given an SFT.
;
;   Inputs:	ES:DI point to SFT
;		DS = DOSDATA
;   Outputs:
;		EXTERR_LOCUS = errLOC_Disk
;		CurBuf points to buffer
;		Carry Clear -> operation OK
;		    ES:DI point to entry
;		    ES:BX point to buffer
;		    DS:SI point to SFT
;		Carry SET   -> operation failed
;		    registers trashified
;   Registers modified: ALL
;----------------------------------------------------------------------------

DirFromSFT:
	;mov	byte [EXTERR_LOCUS],2
	MOV	byte [EXTERR_LOCUS],errLOC_Disk
	push	es
	push	di
	; MSDOS 3.3
	;;mov	dx,[es:di+1Dh]
	;MOV	dx,[ES:DI+SF_ENTRY.sf_dirsec]
	; MSDOS 6.0
	;mov	dx,[es:[di+1Dh]
	MOV	DX,[ES:DI+SF_ENTRY.sf_dirsec+2]  ;F.C. >32mb
	MOV	[HIGH_SECTOR],DX		 ;F.C. >32mb
	; 04/02/2024
	push	dx
	;mov	dx,[es:di+1Bh]
	MOV	DX,[ES:DI+SF_ENTRY.sf_dirsec]
	; 04/02/2024
	; 19/05/2019
	;PUSH	word [HIGH_SECTOR]	;F.C. >32mb
	; MSDOS 3.3 & MSDOS 6.0
	PUSH	DX
	call	FATREAD_SFT		; ES:BP points to DPB, [THISDRV] set
					; [THISDPB] set
	POP	DX
	POP	word [HIGH_SECTOR]	;F.C. >32mb
	JC	short PopDone
	; 22/09/2023
	;XOR	AL,AL	; *		; Pre read
	;;mov	byte [ALLOWED],18h
	;MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY ; *
	;call	GETBUFFR
	; 22/09/2023
	call	GETBUFFER ; * 		; Pre read
	JC	short PopDone
	pop	si
	pop	ds			; Get back SFT pointer

;hkn; SS override
	LES	DI,[SS:CURBUF]
	;or	byte [es:di+5],4
	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_isDIR
	MOV	BX,DI			; ES:BX point to buffer header
	;;lea	di,[di+16] ; MSDOS 3.3
	;lea	di,[di+20] ; MSDOS 6.0
	LEA	DI,[DI+BUFINSIZ] 	; Point to buffer
	;mov	al,32
	MOV	AL,dir_entry.size
	;mul	byte [si+1Fh] ; MSDOS 6.0
	MUL	byte [SI+SF_ENTRY.sf_dirpos]
	ADD	DI,AX			; Point at the entry
	retn				; carry is clear
PopDone:
	pop	di
	pop	es
PopDone_retn:
	retn

;----------------------------------------------------------------------------
;
;**	DOS_Commit - UPdate Directory Entries
;
;	ENTRY	same as DOS_CLOSE (??? BUGBUG - update this jgl)
;		(DS) = DOSGROUP
;	EXIT	Same as DOS_CLOSE except ref_count field is not altered
;	USES	all but DS
;
;----------------------------------------------------------------------------

; 14/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:6F72h (MSDOS 5.0, MSDOS.SYS)

DOS_COMMIT:
	;hkn; called from srvcall. DS already set up.
	LES	DI,[THISSFT]
	;mov	bx,[es:di+5]
	MOV	BX,[ES:DI+SF_ENTRY.sf_flags]
	;test	bx,0C0h
	; 17/12/2022
	test	bl,devid_file_clean+devid_device ;Clears carry
	;TEST	BX,devid_file_clean+devid_device ;Clears carry
	jnz	short PopDone_retn
	;test	bx,8000h
	; 17/12/2022
	;test	bh,80h
	test	bh,(sf_isnet>>8) ; 80h
	;TEST	BX,sf_isnet ; 8000h
	JZ	short LOCAL_COMMIT

;IF NOT Installed
;	transfer NET_COMMIT
;ELSE
	;mov	ax,1107h
	MOV	AX,(MultNET<<8)|7
	int     2Fh	; Multiplex - NETWORK REDIRECTOR - COMMIT REMOTE FILE
			; ES:DI -> SFT
			; SFT DPB field -> DPB of drive containing file
			; Return: CF set on error, AX = DOS error code
			; CF clear if successful
localcommit_retn: ; 18/12/2022	
	retn
;ENDIF

; Perform local commit operation by doing a close but not releaseing the SFT.
; There are three ways we can do this. One is to enter a critical section to
; protect a potential free. The second is to increment the ref count to mask
; the close decrementing.
;
; The proper way is to let the caller's of close decide if a decrement should
; be done. We do this by providing another entry into close after the
; decrement and after the share information release.

; DOSCODE:6FA0h (MSDOS 6.21, MSDOS.SYS)
; DOSCODE:6F8Ch (MSDOS 5.0, MSDOS.SYS) 

LOCAL_COMMIT:
	call	ECritDisk
	; MSDOS 6.0
	call	ECritDisk	;PTM.
	call	SetSFTTimes
	MOV	AX,-1
	call	CloseEntry
	; MSDOS 6.0
	PUSHF			;PTM.				;AN000;
	call	DEV_OPEN_SFT	;PTM.  increment device count	;AN000;
	POPF			;PTM.				;AN000;
	;call	LCritDisk	;PTM.				;AN000;
	; 18/12/2022
	jmp	LCritDisk
;localcommit_retn:
;	retn

;Break	<SetSFTTimes - signal a change in the times for an SFT>
;----------------------------------------------------------------------------
;
; Procedure Name : SetSFTTimes
;
;   SetSFTTimes - Examine the flags for a SFT and set the time appropriately.
;   Reflect these times in other SFT's for the same file.
;
;   Inputs:	ES:DI point to SFT
;		BX = sf_flags set apprpriately
;   Outputs:	Set sft times to current time if File & dirty & !nodate
;   Registers modified: All except ES:DI, BX, AX
;
;----------------------------------------------------------------------------

	; 04/02/2024 - Retro DOS v4.2

SetSFTTimes:

; 04/02/2024
%if 0
;	File clean or device does not get stamped nor disk looked at.
	
	;test	bx,0C0h
	; 17/12/2022
	test	bl,devid_file_clean+devid_device
	;TEST	BX,devid_file_clean+devid_device
	;retnz				; clean or device => no timestamp
	jnz	short localcommit_retn

;	file and dirty. See if date is good

	;test	bx,4000h
	; 17/12/2022
	;test	bh,40h
	test	bh,(sf_close_nodate>>8)
	;TEST	BX,sf_close_nodate
	;retnz				; nodate => no timestamp
	jnz	short localcommit_retn
%else
	; 04/02/2024
	; (PCDOS 7.1 IBMDOS.COM)
	;test	bx,40C0h
	test	bx,sf_close_nodate+devid_file_clean+devid_device
	jnz	short localcommit_retn
%endif

	push	ax
	push	bx
	call	DATE16			; Date/Time to AX/DX
	;mov	[es:di+0Fh],ax
	MOV	[ES:DI+SF_ENTRY.sf_date],AX
	;mov	[es:di+0Dh],dx
	MOV	[ES:DI+SF_ENTRY.sf_time],DX
	XOR	AX,AX
;if installed
	;call	JShare + 14 * 4
	call	far [JShare+(14*4)]	; 14 = ShSU
;else
;	call	ShSU
;endif
	pop	bx
	pop	ax
	retn

;============================================================================
; DIRCALL.ASM, MSDOS 6.0, 1991
;============================================================================
; 23/07/2018 - Retro DOS v3.0
; 18/05/2019 - Retro DOS v4.0

; DOSCODE:6FDAh (MSDOS 6.21, MSDOS.SYS)

;TITLE DIRCALL - Directory manipulation internal calls
;NAME  DIRCALL

;**	Low level directory manipulation routines for making removing and
;	  verifying local or NET directories
;
;	DOS_MKDIR
;	DOS_CHDIR
;	DOS_RMDIR
;
;	Modification history:
;
;		Created: ARR 30 March 1983

;BREAK <DOS_MkDir - Make a directory entry>
;---------------------------------------------------------------------------
;
; Procedure Name : DOS_MkDir
;
; Inputs:
;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
;		terminated)
;	[CURR_DIR_END] Points to end of Current dir part of string
;		( = -1 if current dir not involved, else
;		 Points to first char after last "/" of current dir part)
;	[THISCDS] Points to CDS being used
;		(Low word = -1 if NUL CDS (Net direct request))
; Function:
;	Make a new directory
; Returns:
;	Carry Clear
;		No error
;	Carry Set
;	    AX is error code
;		error_path_not_found
;			Bad path (not in curr dir part if present)
;		error_bad_curr_dir
;			Bad path in current directory part of path
;		error_access_denied
;			Already exists, device name
; DS preserved, Others destroyed
;---------------------------------------------------------------------------

;hkn; called from path.asm. DS already set up.

; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:6FC6h (MSDOS 5.0, MSDOS.SYS)

; 04/02/2024 - Retro DOS v4.2 (Modified MSDOS 6.22 MSDOS.SYS)
; DOSCODE:6FDAh (MSDOS 6.22, MSDOS.SYS)

DOS_MKDIR:
	call	TestNet
	JNC	short LOCAL_MKDIR

;IF NOT Installed
;	transfer NET_MKDIR
;ELSE
	;mov	ax,1103h
	MOV	AX,(MultNET<<8)|3
	int     2Fh	; Multiplex - NETWORK REDIRECTOR - MAKE REMOTE DIRECTORY
			; SS = DOS CS
			; SDA first filename pointer -> fully-qualified directory name
			; SDA CDS pointer -> current directory
			; Return: CF set on error, AX = DOS error code
			; CF clear if successful
	retn
;ENDIF

NODEACCERRJ:
	;mov	ax,5
	MOV	AX,error_access_denied
_BadRet:
	STC
	;call	LCritDisk
	;retn
	; 18/12/2022
	jmp	LCritDisk

PATHNFJ:
	call	LCritDisk
	jmp	SET_MKND_ERR	; Map the MakeNode error and return

LOCAL_MKDIR:
	call	ECritDisk

; MakeNode requires an SFT to fiddle with. We Use a temp spot (RENBUF)

	MOV	[THISSFT+2],SS

;hkn; DOSDATA
	MOV	WORD [THISSFT],RENBUF

;  NOTE: Need WORD PTR because MASM takes type of
;   TempSFT (byte) instead of type of sf_mft (word).

	;mov	word [RENBUF+33h],0 ; MSDOS 6.0
	MOV	WORD [RENBUF+SF_ENTRY.sf_MFT],0
				; make sure SHARER won't complain.
	;mov	al,10h
	MOV	AL,attr_directory
	call	MakeNode
	JC	short PATHNFJ
	CMP	AX,3
	JZ	short NODEACCERRJ ; Can't make a device into a directory
	LES	BP,[THISDPB]	; Makenode zaps this
	LDS	DI,[CURBUF]
	SUB	SI,DI
	PUSH	SI		; Pointer to dir_first

; 04/02/2024
%if 0
	; MSDOS 6.0
	;push	word [DI+8]
	PUSH	WORD [DI+BUFFINFO.buf_sector+2]	;F.C. >32mb
	; MSDOS 3.3 & MSDOS 6.0
	;push	word [di+6]
	PUSH	WORD [DI+BUFFINFO.buf_sector] ; Sector of new node
%else
	; 04/02/2024
	; (PCDOS 7.1 IBMDOS.COM)
	lds	ax,[di+BUFFINFO.buf_sector] ; Sector of new node
	push	ds
	push	ax
%endif

	push	ss
	pop	ds

	; 04/02/2024
	;PUSH	word [DIRSTART]	; Parent for .. entry
	XOR	AX,AX
	;MOV	[DIRSTART],AX	; Null directory
	xchg	ax,[DIRSTART]
	push	ax

	call	NEWDIR
	JC	short NODEEXISTSPOPDEL ; No room
	call	GETENT		; First entry
	JC	short NODEEXISTSPOPDEL ; Screw up
	LES	DI,[CURBUF]

	; MSDOS 6.0
	TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty  
				 ;LB. if already dirty		    ;AN000;
	JNZ	short yesdirty5	 ;LB.   don't increment dirty count ;AN000;
	call	INC_DIRTY_COUNT  ;LB.				    ;AN000;
	
	; MSDOS 3.3 & MSDOS 6.0
	;or	byte [es:di+5],40h  ; 07/12/2022
	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
yesdirty5:
	;;add	di,16 ; MSDOS 3.3
	;add	di,20 ; MSDOS 6.0
	ADD	DI,BUFINSIZ	; Point at buffer
	MOV	AX,202EH	; ". "
	MOV	DX,[DIRSTART]	; Point at itself
	call	SETDOTENT
	MOV	AX,2E2EH	; ".."
	POP	DX		; Parent
	call	SETDOTENT
	LES	BP,[THISDPB]
	; 22/09/2023
	;;mov	byte [ALLOWED],18h
	;MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY ; *
	POP	DX		; Entry sector
	; MSDOS 6.0
	POP	word [HIGH_SECTOR] ;F.C. >32mb

	;XOR	AL,AL ; *	; Pre read
	;call	GETBUFFR
	; 22/09/2023
	call	GETBUFFER ; *	; Pre read
	JC	short NODEEXISTSP
	MOV	DX,[DIRSTART]
	LDS	DI,[CURBUF]
	;or	byte [di+5],4
	OR	byte [DI+BUFFINFO.buf_flags],buf_isDIR
	POP	SI		; dir_first pointer
	ADD	SI,DI
	MOV	[SI],DX
	XOR	DX,DX
	MOV	[SI+2],DX	; Zero size
	MOV	[SI+4],DX
DIRUP:
	; MSDOS 6.0
	TEST	byte [DI+BUFFINFO.buf_flags],buf_dirty  
	;			 ;LB. if already dirty 		   ;AN000;
	JNZ	short yesdirty6	 ;LB.  don't increment dirty count ;AN000;
	call	INC_DIRTY_COUNT  ;LB.				   ;AN000;
	
	; MSDOS 3.3 & MSDOS 6.0
	;or	byte [di+5],40h
	OR	byte [DI+BUFFINFO.buf_flags],buf_dirty	; Dirty buffer
yesdirty6:
	push	ss
	pop	ds
	mov	al,[es:bp]
	;MOV	AL,[ES:BP+DPB.DRIVE]  ; mov al,[es:bp+0]
	call	FLUSHBUF
	;mov	ax,5
	MOV	AX,error_access_denied
	;call	LCritDisk
	;retn
	; 18/12/2022
	jmp	LCritDisk

NODEEXISTSPOPDEL:
	POP	DX		; Parent
	POP	DX		; Entry sector
	; MSDOS 6.0 
	POP	word [HIGH_SECTOR] ; F.C. >32mb
	LES	BP,[THISDPB]
	; 22/09/2023
	;;mov	byte [ALLOWED],18h
	;MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY ; *
	;XOR	AL,AL ; *	; Pre read
	;call	GETBUFFR
	; 22/09/2023
	call	GETBUFFER ; *	; Pre read
	JC	short NODEEXISTSP
	LDS	DI,[CURBUF]
	;or	byte [di+5],4
	OR	byte [DI+BUFFINFO.buf_flags],buf_isDIR
	POP	SI		; dir_first pointer
	ADD	SI,DI
	;sub	si,1Ah ; 26
	SUB	SI,dir_entry.dir_first	;Point back to start of dir entry
	MOV	BYTE [SI],0E5H	; Free the entry
	CALL	DIRUP		; Error doesn't matter since erroring anyway
NODEEXISTS:
	JMP	NODEACCERRJ ; 10/08/2018

NODEEXISTSP:
	POP	SI		; Clean stack
	JMP	short NODEEXISTS

; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)

;BREAK <DOS_ChDir -- Verify a directory>
;----------------------------------------------------------------------------
;
; Procedure Name : DOS_ChDir
;
; Inputs:
;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
;		terminated)
;	[CURR_DIR_END] Points to end of Current dir part of string
;		( = -1 if current dir not involved, else
;		 Points to first char after last "/" of current dir part)
;	[THISCDS] Points to CDS being used May not be NUL
; Function:
;	Validate the path for potential new current directory
; Returns:
;	NOTE:
;	    [SATTRIB] is modified by this call
;	Carry Clear
;	    CX is cluster number of the DIR, LOCAL CDS ONLY
;		Caller must NOT set ID fields on a NET CDS.
;	Carry Set
;	    AX is error code
;		error_path_not_found
;			Bad path
;		error_access_denied
;			device or file name
; DS preserved, Others destroyed
;----------------------------------------------------------------------------

;hkn; called from path.asm and dir2.asm. DS already set up.

; 18/05/2019 - Retro DOS v4.0
; DOSCODE:70DAh (MSDOS 6.21, MSDOS.SYS)

; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:70C6h (MSDOS 5.0, MSDOS.SYS)

DOS_CHDIR:
	call	TestNet
	JNC	short LOCAL_CHDIR

;IF NOT Installed
;	transfer NET_CHDIR
;ELSE
	;mov	ax,1105h
	MOV	AX,(MultNET<<8)|5
	int     2Fh	; Multiplex - NETWORK REDIRECTOR - CHDIR
			; SS = DOS CS
			; SDA first filename pointer -> fully-qualified directory name
			; SDA CDS pointer -> current directory
			; Return: CF set on error, AX = DOS error code
			; CF clear if successful
	retn
;ENDIF

LOCAL_CHDIR:
	call	ECritDisk
	; MSDOS 6.0
	;;test	word [es:di+43h],2000h
	;TEST	word [ES:DI+curdir.flags],curdir_splice ;PTM.
	; 17/12/2022
	;test	byte [es:di+44h],20h
	test	byte [ES:DI+curdir.flags+1],(curdir_splice>>8) ;PTM.
	JZ	short nojoin		   ;PTM.
	;mov	word [es:di+49h], 0FFFFh
	MOV	word [ES:DI+curdir.ID],0FFFFH ;PTM.
nojoin:
	; MSDOS 3.3 & MSDOS 6.0
	MOV	byte [NoSetDir],0 ; FALSE
	;mov	byte [SATTRIB],16h
	MOV	byte [SATTRIB],attr_directory+attr_system+attr_hidden
				; Dir calls can find these
; DOS 3.3  6/24/86 FastOpen
	OR	byte [FastOpenFlg],FastOpen_Set	; set fastopen flag
	call	GETPATH

	; 04/02/2024
	;PUSHF						;AN000;
	lahf						
	AND	byte [FastOpenFlg],Fast_yes ; clear it all ;AC000;
	;POPF						;AN000;
	sahf

; DOS 3.3  6/24/86 FastOpen

	; MSDOS 3.3
	;mov	byte [FastOpenFlg],0
	
	;mov	ax,3
	MOV	AX,error_path_not_found
	JC	short ChDirDone
	JNZ	short NOTDIRPATH	; Path not a DIR
	MOV	CX,[DIRSTART]		; Get cluster number
	CLC
ChDirDone:
	;call	LCritDisk
	;retn
	; 18/12/2022
	jmp	LCritDisk

;BREAK <DOS_RmDir -- Remove a directory>
;----------------------------------------------------------------------------
;
; Procedure Name : DOS_RmDir
;
; Inputs:
;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
;		terminated)
;	[CURR_DIR_END] Points to end of Current dir part of string
;		( = -1 if current dir not involved, else
;		 Points to first char after last "/" of current dir part)
;	[THISCDS] Points to CDS being used
;		(Low word = -1 if NUL CDS (Net direct request))
; Function:
;	Remove a directory
;	NOTE: Attempt to remove current directory must be detected by caller
; Returns:
;	NOTE:
;	    [SATTRIB] is modified by this call
;	Carry Clear
;		No error
;	Carry Set
;	    AX is error code
;		error_path_not_found
;			Bad path (not in curr dir part if present)
;		error_bad_curr_dir
;			Bad path in current directory part of path
;		error_access_denied
;			device or file name, root directory
;			Bad directory ('.' '..' messed up)
; DS preserved, Others destroyed
;----------------------------------------------------------------------------

;hkn; called from path.asm. DS already set up.

; 18/05/2019 - Retro DOS v4.0
; DOSCODE:711Fh (MSDOS 6.21, MSDOS.SYS)

; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:710Bh (MSDOS 5.0, MSDOS.SYS)

DOS_RMDIR:
	call	TestNet
	JNC	short LOCAL_RMDIR

;IF NOT Installed
;	transfer NET_RMDIR
;ELSE
	;mov	ax,1101h
	MOV	AX,(MultNET<<8)|1
	int	2Fh	; Multiplex - NETWORK REDIRECTOR - REMOVE REMOTE DIRECTORY
			; SS = DOS CS
			; SDA first filename pointer -> fully-qualified directory name
			; SDA CDS pointer -> current directory
			; Return: CF set on error, AX = DOS error code
			; CF clear if successful
	retn
;ENDIF

LOCAL_RMDIR:
	call	ECritDisk
	MOV	byte [NoSetDir],0
	;mov	byte [SATTRIB],16h
	MOV	byte [SATTRIB],attr_directory+attr_system+attr_hidden
					; Dir calls can find these
	call	GETPATH
	JC	short NOPATH		; Path not found
	JNZ	short NOTDIRPATH	; Path not a DIR
	MOV	DI,[DIRSTART]
	OR	DI,DI			; Root ?
	JNZ	short rmdir_get_buf	; No
	JMP	SHORT NOTDIRPATH

NOPATH:
	;mov	ax,3
	MOV	AX,error_path_not_found
	JMP	_BadRet

NOTDIRPATHPOP:
	POP	AX  ; MSDOS 6.0		;F.C. >32mb
	POP	AX
NOTDIRPATHPOP2:
	POP	AX
NOTDIRPATH:
	JMP	NODEACCERRJ

rmdir_get_buf:
	LDS	DI,[CURBUF]
	SUB	BX,DI		; Compute true offset
	PUSH	BX		; Save entry pointer
	
	; MSDOS 6.0
	;push	word [di+8]
	PUSH	WORD [DI+BUFFINFO.buf_sector+2] ;F.C. >32mb
	
	; MSDOS 3.3 (& MSDOS 6.0)
	;push	word [di+6]
	PUSH	WORD [DI+BUFFINFO.buf_sector] ; Save sector number

;hkn; SS is DOSDATA
	;context DS
	push	ss
	pop	ds
	;context ES
	push	ss
	pop	es

;hkn; NAME1 is in DOSDATA
	MOV	DI,NAME1
	MOV	AL,'?'
	MOV	CX,11
	REP	STOSB
	XOR	AL,AL
	STOSB				; Nul terminate it
	call	STARTSRCH		; Set search
	call	GETENTRY		; Get start of directory
	JC	short NOTDIRPATHPOP	; Screw up
	MOV	DS,[CURBUF+2]
	MOV	SI,BX
	LODSW
	;CMP	AX,(' ' SHL 8) OR '.'   ; First entry '.'?
	cmp	ax,202Eh ; ". "
	JNZ	short NOTDIRPATHPOP	; Nope
	;add	si,30
	ADD	SI,dir_entry.size-2 ; Next entry
	LODSW
	;CMP	AX,('.' SHL 8) OR '.'   ; Second entry '..'?
	;cmp	ax, '..'
	cmp	ax,2E2Eh
	JNZ	short NOTDIRPATHPOP	; Nope

;hkn; SS is DOSDATA
	;context DS
	push	ss
	pop	ds
	MOV	word [LASTENT],2	; Skip . and ..
	call	GETENTRY		; Get next entry
	JC	short NOTDIRPATHPOP	; Screw up
	;mov	byte [ATTRIB],16h
	MOV	byte [ATTRIB],attr_directory+attr_hidden+attr_system
	call	SRCH			; Do a search
	JNC	short NOTDIRPATHPOP	; Found another entry!
	CMP	byte [FAILERR],0
	JNZ	short NOTDIRPATHPOP	; Failure of search due to I 24 FAIL
	LES	BP,[THISDPB]
	MOV	BX,[DIRSTART]
	call	RELEASE 		; Release data in sub dir
	JC	short NOTDIRPATHPOP	; Screw up
	POP	DX			; Sector # of entry
	POP	word [HIGH_SECTOR] ; MSDOS 6.0	; F.C. >32mb
	; 22/09/2023
	;;mov	byte [ALLOWED],18h
	;MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY ; *
	;XOR	AL,AL ; *		; Pre read
	;call	GETBUFFR		; Get sector back
	call	GETBUFFER ; *		; Pre Read
	JC	short NOTDIRPATHPOP2	; Screw up
	LDS	DI,[CURBUF]
	;or	byte [di+5],4
	OR	byte [DI+BUFFINFO.buf_flags],buf_isDIR
	POP	BX			; Pointer to start of entry
	ADD	BX,DI			; Corrected
	MOV	BYTE [BX],0E5H		; Free the entry

;DOS 3.3 FastOpen  6/16/86  F.C.
	PUSH	DS

;hkn; SS is DOSDATA
	;context DS
	push	ss
	pop	ds

	; MSDOS 6.0
	call	FastOpen_Delete 	; call fastopen to delete an entry

;	; MSDOS 3.3
;_FastOpen_Delete:
;	push	ax
;	mov	si,[WFP_START]
;	mov	bx,FastTable
;	;mov	al,3  ; FONC_delete
;	mov	al,FONC_delete
;	call	far [BX+2]  ; FastTable+2
;	pop	ax

	POP	DS
;DOS 3.3 FastOpen  6/16/86  F.C.

	JMP	DIRUP			; In MKDIR, dirty buffer and flush

;============================================================================
; DISK.ASM, MSDOS 6.0, 1991
;============================================================================
; 23/07/2018 - Retro DOS v3.0 
; 04/05/2019 - Retro DOS v4.0

;	TITLE	DISK - Disk utility routines
;	NAME	Disk

;**	Low level Read and write routines for local SFT I/O on files and devs
;
;	SWAPCON
;	SWAPBACK
;	DOS_READ
;	DOS_WRITE
;	get_io_sft
;	DirRead
;	FIRSTCLUSTER
;	SET_BUF_AS_DIR
;	FATSecRd
;	DREAD
;	CHECK_WRITE_LOCK
;	CHECK_READ_LOCK
;
;	Revision history:
;
;		A000   version 4.00  Jan. 1988
;
;----------------------------------------------------------------------------
;
; M065 : B#5276. On raw read/write of a block of characters if a critical
;		error happens, DOS retries the entire block assuming that
;		zero characters were transferred. Modified the code to take
;		into account the number of characters transfered before
;		retrying the operation.
;
;----------------------------------------------------------------------------
;

;Installed = TRUE

;Break	<SwapCon, Swap Back - Old-style I/O to files>

; **** Drivers for file input from devices ****
;----------------------------------------------------------------------------
;   Indicate that there is no more I/O occurring through another SFT outside
;   of handles 0 and 1
;
;   Inputs:	DS is DOSDATA
;   Outputs:	CONSWAP is set to false.
;   Registers modified: none
;----------------------------------------------------------------------------

; IBMDOS.COM (MSDOS 3.3) - Offset 3CF8h

; DOSCODE:71E3h (MSDOS 6.21, MSDOS.SYS)
; 04/05/2019 - Retro DOS v4.0

; DOSCODE:71CFh (MSDOS 5.0, MSDOS.SYS)
; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)

SWAPBACK:
	MOV	BYTE [CONSWAP],0	; signal no conswaps
	retn

;----------------------------------------------------------------------------
;
; Procedure Name : SWAPCON
;
;   Copy ThisSFT to CONSFT for use by the 1-12 primitives.
;
;   Inputs:	ThisSFT as the sft of the desired file
;		DS is DOSDATA
;   Outputs:	CONSWAP is set.  CONSFT = ThisSFT.
;   Registers modified: none
;--------------------------------------------------------------------------

SWAPCON:
	; MSDOS 3.3
	;push	es
	;push	di
	;mov	byte [CONSWAP],1
	;les	di,[THISSFT]
	;mov	word [CONSFT],di
	;mov	word [CONSFT+2],es
	;pop	di
	;pop	es
	;retn

	; MSDOS 6.0
	mov	byte [CONSWAP],1	; ConSwap = TRUE
	push	ax
	mov	ax,[THISSFT]
	mov	[CONSFT],ax
	mov	ax,[THISSFT+2]
	mov	[CONSFT+2],ax
	pop	ax
	retn

; DOSCODE:71FDh (MSDOS 6.21, MSDOS.SYS)
; 04/05/2019 - Retro DOS v4.0

;Break	<DOS_READ -- MAIN READ ROUTINE AND DEVICE IN ROUTINES>
;-----------------------------------------------------------------------------
;
; Inputs:
;	ThisSFT set to the SFT for the file being used
;	[DMAADD] contains transfer address
;	CX = No. of bytes to read
;	DS = DOSDATA
; Function:
;	Perform read operation
; Outputs:
;    Carry clear
;	SFT Position and cluster pointers updated
;	CX = No. of bytes read
;	ES:DI point to SFT
;    Carry set
;	AX is error code
;	CX = 0
;	ES:DI point to SFT
; DS preserved, all other registers destroyed
;
;-----------------------------------------------------------------------------

;hkn; called from fcbio.asm, handle.asm and dev.asm. DS is be set up.

; DOSCODE:71E9h (MSDOS 5.0, MSDOS.SYS)
; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)

DOS_READ:
	LES	DI,[THISSFT]

; Verify that the sft has been opened in a mode that allows reading.

	;mov	al,[es:di+2]
	MOV	AL,[ES:DI+SF_ENTRY.sf_mode]
	;and	al,0Fh
	AND	AL,access_mask
	;cmp	al,1
	CMP	AL,open_for_write
	JNE	short READ_NO_MODE	; Is read or both
	jmp	SET_ACC_ERR

READ_NO_MODE:
	call	SETUP
	JCXZ	NoIORet 		; no bytes to read - fast return
	call	IsSFTNet
	JZ	short LOCAL_READ

;IF NOT Installed
;	transfer NET_READ
;ELSE
	;mov	ax,1108h
	MOV	AX,(MultNET<<8)|8
	int	2Fh	; Multiplex - NETWORK REDIRECTOR - READ FROM REMOTE FILE
			; ES:DI -> SFT
			; SFT DPB field -> DPB of drive containing file
			; CX = number of bytes, SS = DOS CS, SDA DTA field -> user buffer
			; Return: CF set on error, CX = bytes read
	retn
;ENDIF

; The user ended up requesting 0 bytes of input. We do nothing for this case
; except return immediately.

NoIORet:
	CLC
	retn

LOCAL_READ:
	;test	word [es:di+5],80h
	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device  ; Check for named device I/O
	test	byte [ES:DI+SF_ENTRY.sf_flags],devid_device ; 02/06/2019
	JNZ	short READDEV

	;mov	byte [EXTERR_LOCUS],2
	MOV	byte [EXTERR_LOCUS],errLOC_Disk
	call	ECritDisk
	call	DISKREAD

critexit:
	;call	LCritDisk
	;retn
	; 16/12/2022
	jmp	LCritDisk

; We are reading from a device. Examine the status of the device to see if we
; can short-circuit the I/O. If the device in the EOF state or if it is the
; null device, we can safely indicate no transfer.

READDEV:
	;mov	byte [EXTERR_LOCUS],4
	MOV	byte [EXTERR_LOCUS],errLOC_SerDev
	;mov	bl,[es:di+5]
	MOV	BL,[ES:DI+SF_ENTRY.sf_flags]
	LES	DI,[DMAADD]
	;test	bl,40h
	test	BL,devid_device_EOF	; End of file?
	JZ	short ENDRDDEVJ3
	;test	bl,4
	test	BL,devid_device_null	; NUL device?
	JZ	short TESTRAW 		; NO
	XOR	AL,AL			; Indicate EOF by setting zero
ENDRDDEVJ3:
	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility!)
	;JMP	short ENDRDDEVJ2
	; 16/12/2022
	jmp	ENDRDDEV ; 04/05/2019

; We need to hit the device. Figure out if we do a raw read or we do the
; bizarre std_con_string_input.

TESTRAW:
	;test	bl,20h
	test	BL,devid_device_raw	; Raw mode?
	JNZ	short DVRDRAW 		; Yes, let the device do all local editing
	;test	bl,1
	test	BL,devid_device_con_in	; Is it console device?
	JZ	short NOTRDCON
	JMP	READCON

DVRDRAW:
	PUSH	ES
	POP	DS			; Xaddr to DS:DI

	; 04/05/2019 - Retro DOS v4.0

	; MSDOS 6.0
;SR;
;Check for win386 presence -- if present, do polled read of characters

	test	byte [ss:IsWin386],1 ; 19/05/2019
	jz	short ReadRawRetry	;not present
	test	bl,devid_device_con_in	;is it console device
	jz	short ReadRawRetry	;no, do normal read
	jmp	do_polling		;yes, do win386 polling loop

ReadRawRetry:

; 07/02/2024
%if 0
	MOV	BX,DI			; DS:BX transfer addr
	; 06/02/2024 ; *
	;XOR	AX,AX			; Media Byte, unit = 0
	;;MOV	DX,AX			; Start at 0
	;; 06/02/2024
	;cwd
	;call	SETREAD
	; 06/02/2024 ; *
	call	SETREAD_X
%else
	call	SETREAD_XJ
%endif

;hkn; SS override
	LDS	SI,[SS:THISSFT]
	call	DEVIOCALL
	MOV	DX,DI			; DS:DX is preserved by INT 24
	MOV	AH,86H			; Read error

;hkn; SS override
	MOV	DI,[SS:DEVCALL_REQSTAT]
	; MSDOS 3.3
	;test	di,8000h
	;jz	short CRDROK
	; MSDOS 6.0
	or	di,di
	jns	short CRDROK		; no errors
	; MSDOS 3.3 (& MSDOS 6.0)
	call	CHARHARD

; 06/02/2024 - Retrro DOS v5.0
%if 0
	MOV	DI,DX			; DS:DI is Xaddr
	; 04/05/2019
	; MSDOS 6.0
	add	di,[ss:CALLSCNT]	; update ptr and count to reflect the	M065
	sub	cx,[ss:CALLSCNT]	; number of chars xferred		M065
%else
	mov	di,[ss:CALLSCNT]
	sub	cx,di			; update transfer count
	add	di,dx			; update pointer
%endif
	; MSDOS 3.3 (& MSDOS 6.0)
	OR	AL,AL
	JZ	short CRDROK		; Ignore
	CMP	AL,3
	JZ	short CRDFERR 		; fail.
	POP	DS			; Recover saved seg part of Xaddr
	JMP	short ReadRawRetry	; Retry

; We have encountered a device-driver error. We have informed the user of it
; and he has said for us to fail the system call.

CRDFERR:
	POP	DI			; Clean stack
DEVIOFERR:

;hkn; SS override
	LES	DI,[SS:THISSFT]
	jmp	SET_ACC_ERR_DS

CRDROK:
	POP	DI			; Chuck saved seg of Xaddr
	MOV	DI,DX

;hkn; SS override
	ADD	DI,[ss:CALLSCNT]	; Amount transferred
	;JMP	SHORT ENDRDDEVJ3
	; 16/12/2022
	jmp	short ENDRDDEVJ2

; We are going to do a cooked read on some character device. There is a
; problem here, what does the data look like? Is it a terminal device, line
; CR line CR line CR, or is it file data, line CR LF line CR LF? Does it have
; a ^Z at the end which is data, or is the ^Z not data?  In any event we're
; going to do this: Read in pieces up to CR (CRs included in data) or ^z (^z
; included in data). this "simulates" the way con works in cooked mode
; reading one line at a time. With file data, however, the lines will look
; like, LF line CR. This is a little weird.

NOTRDCON:
	;MOV	AX,ES
	;MOV	DS,AX
	; 07/02/2024
	push	es
	pop	ds

; 07/02/2024
%if 0
	MOV	BX,DI
	; 06/02/2024 ; *
	;;XOR	DX,DX
	;;MOV	AX,DX
	;; 06/02/2024
	;xor	ax,ax
	;cwd
	PUSH	CX
	MOV	CX,1
	;call	SETREAD
	; 06/02/2024 ; *
	call	SETREAD_X
	POP	CX
%else
	push	cx
	mov	cx,1
	call	SETREAD_XJ
	pop	cx
%endif

;hkn; SS override
	LDS	SI,[SS:THISSFT]
	;lds	si,[si+7]
	LDS	SI,[SI+SF_ENTRY.sf_devptr]
DVRDLP:
	call	DSKSTATCHK
	call	DEVIOCALL2
	PUSH	DI			; Save "count" done
	MOV	AH,86H

;hkn; SS override
	MOV	DI,[SS:DEVCALL_REQSTAT]
	
	; MSDOS 3.3
	;test	di,8000h
	;jz	short CRDOK
	; MSDOS 6.0
	or	di,di
	jns	short CRDOK
	
	call	CHARHARD
	POP	DI

;hkn; SS override
	MOV	word [SS:CALLSCNT],1
	CMP	AL,1
	JZ	short DVRDLP		; Retry
	CMP	AL,3
	JZ	short DEVIOFERR		; FAIL
	XOR	AL,AL			; Ignore, Pick some random character
	JMP	SHORT DVRDIGN

CRDOK:
	POP	DI

;hkn; SS override
	CMP	word [SS:CALLSCNT],1
	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility!)
	JNZ	short ENDRDDEVJ2
	; 16/12/2022
	;jnz	short ENDRDDEV ; 24/07/2019

	PUSH	DS

;hkn; SS override
	MOV	DS,[SS:CALLXAD+2]
	MOV	AL,[DI]			; Get the character we just read
	POP	DS
DVRDIGN:

;hkn; SS override
	INC	WORD [SS:CALLXAD]	; Next character
	MOV	word [SS:DEVCALL_REQSTAT],0
	INC	DI			; Next character
	CMP	AL,1Ah			; ^Z?
	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility!)
	JZ	short ENDRDDEVJ2	; Yes, done zero set (EOF)
	; 16/12/2022
	;jz	short ENDRDDEV ; 24/07/2019	
	CMP	AL,c_CR  ; 0Dh		; CR?
	LOOPNZ	DVRDLP			; Loop if no, else done
	INC	AX			; Resets zero flag so NOT EOF, unless
					;  AX=FFFF which is not likely
ENDRDDEVJ2:
	; 16/12/2022
	;JMP	short ENDRDDEV		; changed short to long for win386
	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	jmp	ENDRDDEV

	; 04/05/2019

	; MSDOS 6.0
;SR;
;Polling code for raw read on CON when WIN386 is present
;
;At this point -- ds:di is transfer address
;		  cx is count

do_polling:

; 07/02/2024
%if 0
	mov	bx,di			;ds:bx is Xfer address
	; 06/02/2024 ; *
	;xor	ax,ax
	;;mov	dx,ax
	;; 06/02/2024
	;cwd
	;call	SETREAD			;prepare device packet
	; 06/02/2024 ; *
	call	SETREAD_X
%else
	call	SETREAD_XJ
%endif

do_io:
;Change read to a NON-DESTRUCTIVE READ, NO WAIT

	mov	byte [es:bx+2],DEVRDND ; 5 ;Change command code
	push	ds
	lds	si,[ss:THISSFT]		;get device header
	call	DEVIOCALL		;call device driver
	pop	ds
	
	;test	word [es:bx+3],8000h
	; 16/12/2022
	;test	byte [es:bx+4],80h
	test	byte [es:bx+SRHEAD.REQSTAT+1],STERR>>8 
	;test	word [es:bx+SRHEAD.REQSTAT],STERR ;check if error
	jz	short check_busy	;no

	push	ds
	mov	dx,di

invoke_charhard:	; 07/02/2024
	;invoke charhard		;invoke int 24h handler
	call	CHARHARD
	mov	di,dx
	or	al,al
	jz	short pop_done_read	;ignore by user, assume read done
	cmp	al,3
	jz	short devrderr		;user asked to fail
	pop	ds
	jmp	short do_io		;user asked to retry

check_busy:
	;test	word [es:bx+3],200h
	; 16/12/2022
	test	byte [es:bx+SRHEAD.REQSTAT+1],02h
	;test	word [es:bx+SRHEAD.REQSTAT],0200h ;see if busy bit set
	jnz	short no_char		;yes, no character available

;Character is available. Read in 1 character at a time until all characters
;are read in or no character is available

	mov	byte [es:bx+2],DEVRD ; 4 ;command code is READ now
	mov	word [es:bx+18],1	;change count to 1 character
	push	ds
	lds	si,[ss:THISSFT]
	call	DEVIOCALL

	mov	dx,di
	mov	ah,86h
	;mov	di,[es:bx+3]
	mov	di,[es:bx+SRHEAD.REQSTAT] ;get returned status
	test	di,STERR ; 8000h	;was there an error during read?
	;jz	short next_char		;no,read next character
	; 07/02/2024
	jnz	short invoke_charhard

; 07/02/2024
%if 0
	;invoke	charhard		;invoke int 24h handler
	call	CHARHARD
	mov	di,dx			;restore di
	or	al,al			;
	jz	short pop_done_read	;ignore by user,assume read is done
	cmp	al,3
	jz	short devrderr		;user issued a 'fail',indicate error
	pop	ds
	jmp	short do_io		;user issued a retry
%endif

next_char:
	pop	ds
	mov	di,dx
	dec	cx			;decrement count
	;jcxz	done_read		;all characters read in
	; 07/02/2024
	jz	short done_read
	inc	word [es:bx+14]		;update transfer address
	jmp	short do_io		;read next character in

devrderr:
	pop	di			;discard segment address
	les	di,[ss:THISSFT]
	;transfer SET_ACC_ERR_DS	;indicate error
	jmp     SET_ACC_ERR_DS

no_char:
;Since no character is available, we let win386 switch the VM out

	push	ax
	mov	ah,84h	; Microsoft Networks - KEYBOARD BUSY LOOP
	int	2Ah			;indicate idle to WIN386

;When control returns from WIN386, we continue the raw read

	pop	ax
	jmp	do_io

pop_done_read:
	pop	ds
done_read:
	add	di,[ss:CALLSCNT] ; 19/05/2019

	; 16/12/2022

	;jmp	ENDRDDEVJ3	;jump back to normal DOS raw read exit
	;jmp	ENDRDDEV ; 04/05/2019

	; 04/05/2019 - Retro DOS v4.0
ENDRDDEV:
	push	ss
	pop	ds
	jmp	short endrddev1

	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;jmp	ENDRDDEVJ3	;jump back to normal DOS raw read exit

TRANBUF:
	LODSB
	STOSB
	CMP	AL,c_CR ; 0Dh	; Check for carriage return
	JNZ	short NORMCH
	MOV	BYTE [SI],c_LF ; 0Ah
NORMCH:
	CMP	AL,c_LF ; 0Ah
	LOOPNZ	TRANBUF
	JNZ	short ENDRDCON
	XOR	SI,SI		; Cause a new buffer to be read
	call	OUTT		; Transmit linefeed
	OR	AL,1		; Clear zero flag--not end of file
ENDRDCON:
;hkn; SS is DOSDATA
	push	ss
	pop	ds
	CALL	SWAPBACK
	MOV	[CONTPOS],SI

	; 16/12/2022
;ENDRDDEV:
;;hkn; SS is DOSDATA
;	push	ss
;	pop	ds
endrddev1:	; 04/05/2019
	MOV	[NEXTADD],DI
	JNZ	short SETSFTC 	; Zero set if Ctrl-Z found in input
	LES	DI,[THISSFT]
	;and	byte [es:di+5],0BFh
	AND	BYTE [ES:DI+SF_ENTRY.sf_flags],~devid_device_EOF
				; Mark as no more data available
SETSFTC:
	; 31/07/2019
	;call	SETSFT
	;retn
	jmp	SETSFT

; 16/12/2022
%if 0
	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
ENDRDDEV:
;hkn; SS is DOSDATA
	push	ss
	pop	ds
	MOV	[NEXTADD],DI
	JNZ	short SETSFTC 	; Zero set if Ctrl-Z found in input
	LES	DI,[THISSFT]
	;and	byte [es:di+5],0BFh
	AND	BYTE [ES:DI+SF_ENTRY.sf_flags],~devid_device_EOF
				; Mark as no more data available
SETSFTC:
	;call	SETSFT
	;retn
	jmp	SETSFT	
%endif

READCON:
	CALL	SWAPCON
	MOV	SI,[CONTPOS]
	OR	SI,SI
	JNZ	short TRANBUF
	CMP	BYTE [CONBUF],128 ; 80h
	JZ	short GETBUF
	MOV	WORD [CONBUF],0FF80H ; Set up 128-byte buffer with no template
GETBUF:
	PUSH	CX
	PUSH	ES
	PUSH	DI

;hkn; CONBUF is in DOSDATA
	MOV	DX,CONBUF

	call	_$STD_CON_STRING_INPUT	; Get input buffer
	POP	DI
	POP	ES
	POP	CX

;hkn; CONBUF is in DOSDATA
	MOV	SI,CONBUF+2

	CMP	BYTE [SI],1AH	; Check for Ctrl-Z in first character
	JNZ	short TRANBUF
	MOV	AL,1AH
	STOSB
	DEC	DI
	MOV	AL,c_LF
	call	OUTT		; Send linefeed
	XOR	SI,SI
	JMP	short ENDRDCON ; 04/05/2019

; 24/07/2018 - Retro DOS v3.0

;Break	<DOS_WRITE -- MAIN WRITE ROUTINE AND DEVICE OUT ROUTINES>
;---------------------------------------------------------------------------
;
; Procedure Name : DOS_WRITE
;
; Inputs:
;	ThisSFT set to the SFT for the file being used
;	[DMAADD] contains transfer address
;	CX = No. of bytes to write
; Function:
;	Perform write operation
;	NOTE: If CX = 0 on input, file is truncated or grown
;		to current sf_position
; Outputs:
;    Carry clear
;	SFT Position and cluster pointers updated
;	CX = No. of bytes written
;	ES:DI point to SFT
;    Carry set
;	AX is error code
;	CX = 0
;	ES:DI point to SFT
; DS preserved, all other registers destroyed
;---------------------------------------------------------------------------

;hkn; called from fcbio2.asm, handle.asm and dev.asm. DS is set up at this 
;hkn; point to DOSDATA.

; 04/05/2019 - Retro DOS v4.0
; DOSCODE:742Ch (MSDOS 6.21, MSDOS.SYS)

; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:7418h (MSDOS 5.0, MSDOS.SYS)

DOS_WRITE:
	LES	DI,[THISSFT]
	;mov	al,[ES:DI+2]
	MOV	AL,[ES:DI+SF_ENTRY.sf_mode]
	;and	al,0Fh
	AND	AL,access_mask
	;cmp	al,0
	CMP	AL,open_for_read
	JNE	short Check_FCB_RO		 ;Is write or both
BadMode:
	jmp	SET_ACC_ERR

; NOTE: The following check for writting to a Read Only File is performed
;	    ONLY on FCBs!!!!
;	We ALLOW writes to Read Only files via handles to allow a CREATE
;	    of a read only file which can then be written to.
;	This is OK because we are NOT ALLOWED to OPEN a RO file via handles
;	    for writting, or RE-CREATE an EXISTING RO file via handles. Thus,
;	    CREATing a NEW RO file, or RE-CREATing an existing file which
;	    is NOT RO to be RO, via handles are the only times we can write
;	    to a read-only file.

Check_FCB_RO:
	;;test	word [es:di+2],8000h
	;TEST	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB
	;JZ	short WRITE_NO_MODE	; Not an FCB
	
	;test	byte [es:di+3],80h
	TEST	byte [ES:DI+SF_ENTRY.sf_mode+1],(sf_isFCB>>8)
	JZ	short WRITE_NO_MODE	; Not an FCB

	;test	byte [es:di+4],1
	TEST	byte [ES:DI+SF_ENTRY.sf_attr],attr_read_only
	JNZ	short BadMode 		; Can't write to Read_Only files via FCB
WRITE_NO_MODE:
	call	SETUP
	call	IsSFTNet
	JZ	short LOCAL_WRITE

;IF NOT Installed
;	transfer NET_WRITE
;ELSE
	;mov	ax,1109h
	MOV	AX,(MultNET<<8)|9
	int	2Fh	; Multiplex - NETWORK REDIRECTOR - WRITE TO REMOTE FILE
			; ES:DI -> SFT
			; SFT DPB field -> DPB of drive containing file
			; CX = number of bytes, SS = DOS CS, SDA DTA field -> user buffer
			; Return: CF set on error, CX = bytes written
	retn
;ENDIF

LOCAL_WRITE:
	;;test	word [es:di+5],80h
	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
	;jnz	short WRTDEV

	;test	byte [es:di+5],80h
	TEST	byte [ES:DI+SF_ENTRY.sf_flags],devid_device ; Check for named device I/O
	jnz	short WRTDEV

	;mov	byte [EXTERR_LOCUS],2
	MOV	byte [EXTERR_LOCUS],errLOC_Disk
	call	ECritDisk

	call	DISKWRITE

	; 04/05/2019 - Retro DOS v4.0

	; MSDOS 6.0
; Extended Open
	JC	short nocommit
	
	LES	DI,[THISSFT]
	
	;;test	word [ES:DI+2],4000h
	;TEST	word [ES:DI+SF_ENTRY.sf_mode],AUTO_COMMIT_WRITE
	;JZ	short nocommit
	
	;test	byte [ES:DI+3],40h
	TEST	byte [ES:DI+SF_ENTRY.sf_mode+1],(AUTO_COMMIT_WRITE>>8)
	JZ	short nocommit
	
	PUSH	CX
	call	DOS_COMMIT
	POP	CX
nocommit:
; Extended Open
	;call	LCritDisk
	;retn
	; 18/12/2022
	jmp	LCritDisk

DVWRTRAW:
	XOR	AX,AX			; Media Byte, unit = 0
	call	SETWRITE
	PUSH	DS			; Save seg of transfer

;hkn; SS override
	LDS	SI,[SS:THISSFT]
	call	DEVIOCALL		; DS:SI -> DEVICE

	MOV	DX,DI			; Offset part of Xaddr saved in DX
	MOV	AH,87H

;hkn; SS override
	MOV	DI,[SS:DEVCALL_REQSTAT]

	; MSDOS 3.3
	;test	di,8000h
	;jz	short CWRTROK

	; MSDOS 6.0
	or	di,di
	jns	short CWRTROK
	
	; MSDOS 3.3 (& MSDOS 6.0)
	call	CHARHARD

	; 04/05/2019  - Retro DOS v4.0

	; MSDOS 6.0
	sub	cx,[ss:CALLSCNT]	; update ptr & count to reflect	M065
	mov	bx,dx			; number of chars xferred	M065
	add	bx,[ss:CALLSCNT]	;				M065
	mov	di,bx			;				M065
	
	; MSDOS 3.3
	;MOV	BX,DX			; Recall transfer addr		M065

	; MSDOS 3.3 (& MSDOS 6.0)
	OR	AL,AL
	JZ	short CWRTROK 		; Ignore
	CMP	AL,3
	JZ	short CWRFERR
	POP	DS			; Recover saved seg of transfer
	JMP	short DVWRTRAW		; Try again
CWRFERR:
	POP	AX			; Chuck saved seg of transfer
	JMP	CRDFERR 		; Will pop one more stack element
CWRTROK:
	POP	AX			; Chuck saved seg of transfer
	POP	DS
	MOV	AX,[CALLSCNT]		; Get actual number of bytes transferred
ENDWRDEV:
	LES	DI,[THISSFT]
	MOV	CX,AX
	;call	ADDREC
	;retn
	; 16/12/2022
	; 10/06/2019
	jmp	ADDREC
	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;call	ADDREC
	;retn
	
WRTNUL:
	MOV	DX,CX			; Entire transfer done
WRTCOOKJ:
	JMP	WRTCOOKDONE
WRTDEV:
	;mov	byte [EXTERR_LOCUS],4
	MOV	byte [EXTERR_LOCUS],errLOC_SerDev
	;or	byte [es:di+5],40h
	OR	BYTE [ES:DI+SF_ENTRY.sf_flags],devid_device_EOF
					; Reset EOF for input
	;mov	bl,[es:di+5]
	MOV	BL,[ES:DI+SF_ENTRY.sf_flags]
	XOR	AX,AX
	JCXZ	ENDWRDEV		; problem of creating on a device.
	PUSH	DS
	MOV	AL,BL
	LDS	BX,[DMAADD]		; Xaddr to DS:BX
	MOV	DI,BX			; Xaddr to DS:DI
	XOR	DX,DX			; Set starting point
	;test	al,20h
	test	AL,devid_device_raw	; Raw?
	;JZ	short TEST_DEV_CON
	;JMP	DVWRTRAW
	; 16/12/2022
	jnz	short DVWRTRAW
	; 17/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;JZ	short TEST_DEV_CON
	;JMP	short DVWRTRAW

TEST_DEV_CON:
	;test	al,2
	test	AL,devid_device_con_out ; Console output device?
	jnz	short WRITECON
	;test	al,4
	test	AL,devid_device_null
	JNZ	short WRTNUL
	MOV	AX,DX
	CMP	BYTE [BX],1Ah		; ^Z?
	JZ	short WRTCOOKJ		; Yes, transfer nothing
	PUSH	CX
	MOV	CX,1
	call	SETWRITE
	POP	CX

;hkn; SS override
	LDS	SI,[SS:THISSFT]
;
;SR; Removed X25 support from here
;
	;lds	si,[si+7]
	LDS	SI,[SI+SF_ENTRY.sf_devptr]
DVWRTLP:
	call	DSKSTATCHK
	call	DEVIOCALL2
	PUSH	DI
	MOV	AH,87H

;hkn; SS override
	MOV	DI,[SS:DEVCALL_REQSTAT]
	
	; MSDOS 3.3
	;test	di,8000h
	;jz	short CWROK

	; MSDOS 6.0
	or	di,di
	jns	short CWROK
	
	; MSDOS 3.3 (& MSDOS 6.0)
	call	CHARHARD
	POP	DI

;hkn; SS override
	MOV	word [SS:CALLSCNT],1
	CMP	AL,1
	JZ	short DVWRTLP 	; Retry
	OR	AL,AL
	JZ	short DVWRTIGN	; Ignore
	; 10/08/2018
	JMP	CRDFERR 	; Fail, pops one stack element
CWROK:
	POP	DI

;hkn; SS override
	CMP	word [SS:CALLSCNT],0
	JZ	short WRTCOOKDONE
DVWRTIGN:
	INC	DX

;hkn; SS override for CALLXAD
	INC	WORD [SS:CALLXAD]
	INC	DI
	PUSH	DS
	MOV	DS,[SS:CALLXAD+2]
	CMP	BYTE [DI],1Ah	; ^Z?
	POP	DS
	JZ	short WRTCOOKDONE

;hkn; SS override
	MOV	word [SS:DEVCALL_REQSTAT],0
	LOOP	DVWRTLP
WRTCOOKDONE:
	MOV	AX,DX
	POP	DS
	JMP	ENDWRDEV ; 10/08/2018

WRITECON:
	PUSH	DS

;hkn; SS is DOSDATA
	push	ss
	pop	ds
	CALL	SWAPCON
	POP	DS
	MOV	SI,BX
	PUSH	CX
WRCONLP:
	LODSB
	CMP	AL,1Ah		; ^Z?
	JZ	short CONEOF
	call	OUTT
	LOOP	WRCONLP
CONEOF:
	POP	AX			; Count
	SUB	AX,CX			; Amount actually written
	POP	DS
	CALL	SWAPBACK
	JMP	ENDWRDEV

;---------------------------------------------------------------------------
;
; Procedure Name : get_io_sft
;
;   Convert JFN number in BX to sf_entry in DS:SI We get the normal SFT if
;   CONSWAP is FALSE or if the handle desired is 2 or more. Otherwise, we
;   retrieve the sft from ConSFT which is set by SwapCon.
;
;---------------------------------------------------------------------------

; 04/05/2019 - Retro DOS v4.0
; DOSCODE:7583h (MSDOS 6.21, MSDOS.SYS)
; 17/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:756Fh (MSDOS 5.0, MSDOS.SYS)

GET_IO_SFT:
	;test	byte [SS:CONSWAP],0FFh
	cmp	byte [SS:CONSWAP],0			;smr;SS Override
	JNZ	short GetRedir
GetNormal:
	push	ss
	pop	ds
	PUSH	ES
	PUSH	DI
	call	SFFromHandle
	JC	short RET44P
	MOV	SI,ES
	MOV	DS,SI
	MOV	SI,DI
RET44P:
	POP	DI
	POP	ES
	retn
GetRedir:
	CMP	BX,1
	JA	short GetNormal
	LDS	SI,[SS:CONSFT]
	CLC
get_io_sft_retn:
	retn

;Break	<DIRREAD -- READ A DIRECTORY SECTOR>
;---------------------------------------------------------------------------
;
; Procedure Name : DIRREAD
;
; Inputs:
;	AX = Directory block number (relative to first block of directory)
;	ES:BP = Base of drive parameters
;	[DIRSEC] = First sector of first cluster of directory
;	[CLUSNUM] = Next cluster
;	[CLUSFAC] = Sectors/Cluster
; Function:
;	Read the directory block into [CURBUF].
; Outputs:
;	[NXTCLUSNUM] = Next cluster (after the one skipped to)
;	[SECCLUSPOS] Set
;	ES:BP unchanged
;	[CURBUF] Points to Buffer with dir sector
;	Carry set if error (user said FAIL to I 24)
; DS preserved, all other registers destroyed.
;---------------------------------------------------------------------------

;hkn; called from dir.asm. DS already set up to DOSDATA.

DIRREAD:

; Note that ClusFac is the sectors per cluster. This is NOT necessarily
; the same as what is in the DPB! In the case of the root directory, we have
; ClusFac = # sectors in the root directory. The root directory is detected
; by DIRStart = 0.

	XOR	DX,DX
	;CMP	word [DIRSTART],0
	; 21/09/2023
	cmp	[DIRSTART],dx ; 0
	jnz	short SubDir
	XCHG	AX,DX
	JMP	short DoRead

; Convert the sector number in AX into cluster and sector-within-cluster pair

SubDir:
	MOV	DL,AL
	;and	dl,[es:bp+4]
	AND	DL,[ES:BP+DPB.CLUSTER_MASK]

;	(DX) = sector-in-cluster

	;mov	cl,[es:bp+5]
	MOV	CL,[ES:BP+DPB.CLUSTER_SHIFT]
	SHR	AX,CL

;	(DX) = position in cluster
;	(AX) = number of clusters to skip

DoRead:
	MOV	[SECCLUSPOS],DL
	MOV	CX,AX
	MOV	AH,DL

;	(CX) = number of clusters to skip.
;	(AH) = remainder

	; 04/05/2019 - Retro DOS v4.0
	 
	; MSDOS 6.0
	;MOV	DX,[DIRSEC+2]	     	  ;>32mb
	;MOV	[HIGH_SECTOR],DX	  ;>32mb
	;MOV	DX,[DIRSEC]
	;ADD	DL,AH
	;ADC	DH,0
	;ADC	word [HIGH_SECTOR],0	  ;>32mb
	; 21/09/2023
	xor	bx,bx ; 0
	mov	dx,[DIRSEC]
	add	dl,ah
	adc	dh,bl ; 0
	adc	bx,[DIRSEC+2]
	mov	[HIGH_SECTOR],bx

	MOV	BX,[CLUSNUM]
	MOV	[NXTCLUSNUM],BX
	JCXZ	FIRSTCLUSTER
SKPCLLP:
	call	UNPACK
	jc	short get_io_sft_retn
	XCHG	BX,DI
	call	IsEOF			; test for eof based on fat size
	JAE	short HAVESKIPPED
	LOOP	SKPCLLP
HAVESKIPPED:
	MOV	[NXTCLUSNUM],BX
	MOV	DX,DI
	MOV	BL,AH
	call	FIGREC

	;entry	FIRSTCLUSTER

FIRSTCLUSTER:
	; 22/09/2023
	;;mov	byte [ALLOWED],18h
	;MOV	byte [ALLOWED],Allowed_RETRY+Allowed_FAIL ; *
	;XOR	AL,AL ; *	; Indicate pre-read
	;call	GETBUFFR
	call	GETBUFFER ; *	; pre-read
	jc	short get_io_sft_retn

	;entry	SET_BUF_AS_DIR

SET_BUF_AS_DIR:

;	Set the type of CURBUF to be a directory sector.
;	Only flags are modified.

	PUSH	DS
	PUSH	SI
	LDS	SI,[CURBUF]
	;or	byte [si+5],4
	OR	byte [SI+BUFFINFO.buf_flags],buf_isDIR	; Clears carry
	POP	SI
	POP	DS
dirread_retn:
	retn

;Break	<FATSECRD -- READ A FAT SECTOR>
;----------------------------------------------------------------------------
;
; Procedure Name : FATSECRD
; Inputs:
;	Same as DREAD
;	DS:BX = Transfer address
;	CX = Number of sectors
;	DX = Absolute record number
;	ES:BP = Base of drive parameters
; Function:
;	Calls BIOS to perform FAT read.
; Outputs:
;	Same as DREAD
;---------------------------------------------------------------------------

	; 04/05/2019 - Retro DOS v4.0
	; 18/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)	

FATSECRD:
;hkn; SS override
	;mov	byte [ss:ALLOWED],18h
	MOV	byte [SS:ALLOWED],Allowed_RETRY+Allowed_FAIL
	MOV	DI,CX
	;mov	cl,[es:bp+8]
	MOV	CL,[ES:BP+DPB.FAT_COUNT]
	; MSDOS 3.3
	;;mov	al,[es:bp+0Fh]
	;MOV	AL,[ES:BP+DPB.FAT_SIZE] 				
	;XOR	AH,AH
	; MSDOS 6.0
	;mov	ax,[es:bp+0Fh]
	MOV	AX,[ES:BP+DPB.FAT_SIZE] ;>32mb
	XOR	CH,CH	
	PUSH	DX
NXTFAT:
	; MSDOS 6.0
;hkn; SS override
	MOV	word [SS:HIGH_SECTOR],0	;>32mb FAT sectors cannot exceed
	PUSH	CX			;32mb
	PUSH	AX
	MOV	CX,DI
	call	DSKREAD
	POP	AX
	POP	CX
	JZ	short RET41P		; Carry clear
	ADD	DX,AX
	LOOP	NXTFAT
	POP	DX
	MOV	CX,DI

; NOTE FALL THROUGH

;Break	<DREAD -- DO A DISK READ>
;---------------------------------------------------------------------------
;
; Procedure Name : DREAD
;
; Inputs:
;	DS:BX = Transfer address
;	CX = Number of sectors
;	DX = Absolute record number	      (LOW)
;	[HIGH_SECTOR] = Absolute record number (HIGH)
;	ES:BP = Base of drive parameters
;	[ALLOWED] must be set in case call to HARDERR needed
; Function:
;	Calls BIOS to perform disk read. If BIOS reports
;	errors, will call HARDERRRW for further action.
; Outputs:
;	Carry set if error (currently user FAILED to INT 24)
; DS,ES:BP preserved. All other registers destroyed.
;---------------------------------------------------------------------------

	;entry	DREAD
DREAD:
	call	DSKREAD
	jz	short dirread_retn	; Carry clear
;hkn; SS override
	MOV	BYTE [SS:READOP],0
	call	HARDERRRW
	CMP	AL,1			; Check for retry
	JZ	short DREAD
	CMP	AL,3			; Check for FAIL
	CLC
	JNZ	short NO_CAR		; Ignore
	STC
NO_CAR:
	retn
RET41P: 
	POP	DX
	retn

; 24/07/2018 - Retro DOS v3.0

;Break	<CHECK_WRITE_LOCK>
;---------------------------------------------------------------------------
;
; Procedure Name : CHECK_WRITE_LOCK
;
; Inputs:
;	output of SETUP
;	ES:DI -> SFT
; Function:
;	check write lock
; Outputs:
;	Carry set if error
;	Carry clear if ok
;
;----------------------------------------------------------------------------

	; 04/05/2019 - Retro DOS v4.0
	; 18/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)

CHECK_WRITE_LOCK:
	; MSDOS 6.0
	;test	byte [es:di+4],8
	TEST	byte [ES:DI+SF_ENTRY.sf_attr],attr_volume_id ;volume id
	;JZ	short write_cont			     ;no
	;;call	SET_ACC_ERR_DS
	;;retn
	;;jnz	SET_ACC_ERR_DS
	; 19/08/2018
	;jz	short write_cont
	;jmp	SET_ACC_ERR_DS
	; 18/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	JZ	short write_cont
	;call	SET_ACC_ERR_DS
	;retn
	; 16/12/2022
	jmp	SET_ACC_ERR_DS

write_cont:				;
	PUSH	CX			;save reg
	OR	CX,CX			;
	JNZ	short Not_Truncate	;
	dec	cx			;(cx) = -1; check for lock on whole file
Not_Truncate:				;
	MOV	AL,80H			;check write access
	call	LOCK_CHECK		;check lock
	POP	CX			;restore reg
	JNC	short WRITE_OK		;lock ok
	call	WRITE_LOCK_VIOLATION	;issue I24
	JNC	short write_cont	;retry
WRITE_OK:				;
	retn				;

;Break	<CHECK_READ_LOCK>
;---------------------------------------------------------------------------
;
; Procedure Name : CHECK_READ_LOC
;
; Inputs:
;	ES:DI -> SFT
;	output of SETUP
; Function:
;	check read lock
; Outputs:
;	Carry set if error
;	Carry clear if ok
;----------------------------------------------------------------------------

CHECK_READ_LOCK:
	; MSDOS 6.0
	;test	byte [es:di+4],8
	TEST	byte [ES:DI+SF_ENTRY.sf_attr],attr_volume_id ;volume id
	;JZ	short do_retry			   	     ; no
	;;call	SET_ACC_ERR
	;;retn
	;;jnz	SET_ACC_ERR
	; 16/12/2022
	; 28/07/2019
	jz	short do_retry
	jmp	SET_ACC_ERR
	; 18/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;JZ	short do_retry
	;call	SET_ACC_ERR
	;retn
do_retry:				;
	xor	al,al			;check read access
	call	LOCK_CHECK		;check lock
	JNC	short READLOCK_OK 	;lock ok
	call	READ_LOCK_VIOLATION	;issue I24
	JNC	short do_retry		;retry
READLOCK_OK:				;
	retn				;

;============================================================================
; DISK2.ASM, MSDOS 6.0, 1991
;============================================================================
; 24/07/2018 - Retro DOS v3.0
; 04/05/2019 - Retro DOS v4.0

;	TITLE	DISK2 - Disk utility routines
;	NAME	Disk2

;**	Low level Read and write routines for local SFT I/O on files and devs
;
;	DskRead
;	DWRITE
;	DSKWRITE
;	HarderrRW
;	SETUP
;	BREAKDOWN
;	READ_LOCK_VIOLATION
;	WRITE_LOCK_VIOLATION
;	DISKREAD
;	SET_ACC_ERR_DS
;	SET_ACC_ERR
;	SETSFT
;	SETCLUS
;	AddRec
;
;	Revision history:
;
;		AN000 version 4.00 Jan. 1988
;		M039 DB 10/17/90 - Disk read/write optimization

; 04/05/2019 - Retro DOS v4.0
; DOSCODE:7699h (MSDOS 6.21, MSDOS.SYS)
; 18/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:7685h (MSDOS 5.0, MSDOS.SYS)

;Break	<DSKREAD -- PHYSICAL DISK READ>
;---------------------------------------------------------------------------
;
; Procedure Name : DSKREAD
;
; Inputs:
;	DS:BX = Transfer addr
;	CX = Number of sectors
;	[HIGH_SECTOR] = Absolute record number (HIGH)
;	DX = Absolute record number	       (LOW)
;	ES:BP = Base of drive parameters
; Function:
;	Call BIOS to perform disk read
; Outputs:
;	DI = CX on entry
;	CX = Number of sectors unsuccessfully transfered
;	AX = Status word as returned by BIOS (error code in AL if error)
;	Zero set if OK (from BIOS) (carry clear)
;	Zero clear if error (carry clear)
; SI Destroyed, others preserved
;---------------------------------------------------------------------------

DSKREAD:
	PUSH	CX
	;mov	ah,[es:bp+17h] ; 04/05/2019
	MOV	AH,[ES:BP+DPB.MEDIA]
	;mov	al,[es:bp+1]
	MOV	AL,[ES:BP+DPB.UNIT]
	PUSH	BX
	PUSH	ES
	call	SETREAD
	JMP	short DODSKOP

;Break	<DWRITE -- SEE ABOUT WRITING>
;--------------------------------------------------------------------------
;
; Procedure Name : DWRITE
;
; Inputs:
;	DS:BX = Transfer address
;	CX = Number of sectors
;	[HIGH_SECTOR] = Absolute record number (HIGH)
;	DX = Absolute record number	       (LOW)
;	ES:BP = Base of drive parameters
;	[ALLOWED] must be set in case HARDERR called
; Function:
;	Calls BIOS to perform disk write. If BIOS reports
;	errors, will call HARDERRRW for further action.
; Output:
;	Carry set if error (currently, user FAILed to I 24)
; BP preserved. All other registers destroyed.
;----------------------------------------------------------------------------

	;entry	DWRITE
DWRITE:
	CALL	DSKWRITE
	jz	short dw_ret_label	; Carry clear (retz)

;hkn; SS override
	MOV	BYTE [SS:READOP],1
	call	HARDERRRW
	CMP	AL,1		; Check for retry
	JZ	short DWRITE
	CMP	AL,3		; Check for FAIL
	CLC
	JNZ	short NO_CAR2 	; Ignore
	STC
NO_CAR2:
dw_ret_label:
	retn

;Break	<DSKWRITE -- PHYSICAL DISK WRITE>
;---------------------------------------------------------------------------
;
; Procedure Name : DSKWRITE
;
; Inputs:
;	DS:BX = Transfer addr
;	CX = Number of sectors
;	DX = Absolute record number	       (LOW)
;	[HIGH_SECTOR] = Absolute record number (HIGH)
;	ES:BP = Base of drive parameters
; Function:
;	Call BIOS to perform disk read
; Outputs:
;	DI = CX on entry
;	CX = Number of sectors unsuccessfully transfered
;	AX = Status word as returned by BIOS (error code in AL if error)
;	Zero set if OK (from BIOS) (carry clear)
;	Zero clear if error (carry clear)
; SI Destroyed, others preserved
;
;----------------------------------------------------------------------------

	;entry	DSKWRITE
DSKWRITE:
	PUSH	CX
	;mov	ah,[es:bp+17h] ; 04/05/2019
	MOV	AH,[ES:BP+DPB.MEDIA]
	;mov	al,[es:bp+1]
	MOV	AL,[ES:BP+DPB.UNIT]
	PUSH	BX
	PUSH	ES
	call	SETWRITE
DODSKOP:
	MOV	CX,DS		; Save DS
	POP	DS		; DS:BP points to DPB
	PUSH	DS

	;lds	si,[ds:bp+13h] ; 04/05/2019
	LDS	SI,[ds:BP+DPB.DRIVER_ADDR] ; 07/09/2018
	call	DEVIOCALL2

	MOV	DS,CX		; Restore DS
	POP	ES		; Restore ES
	POP	BX

;hkn; SS override
	MOV	CX,[SS:CALLSCNT] ; Number of sectors transferred
	POP	DI
	SUB	CX,DI
	NEG	CX		; Number of sectors not transferred

;hkn; SS override
	MOV	AX,[SS:DEVCALL_REQSTAT]
	;test	ax,8000h
	; 17/12/2022
	;test	ah,80h
	test	ah,(STERR>>8)
	;test	AX,STERR
	retn

;Break	<HardErrRW - map extended errors and call harderr>
;---------------------------------------------------------------------------
;
; Procedure Name : HardErrRW
;
; Inputs:
;	AX is error code from read or write
;	Other registers set as per HARDERR
; Function:
;	Checks the error code for special extended
;	errors and maps them if needed. Then invokes
;	Harderr
; Outputs:
;	Of HARDERR
; AX may be modified prior to call to HARDERR.
; No other registers altered.
;
;---------------------------------------------------------------------------

	; 18/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
HARDERRRW:
	;cmp	al,0Fh
	CMP	AL,error_I24_wrong_disk
	JNZ	short DO_ERR				; Nothing to do

	; MSDOS 3.3
	;push	ds
	;push	si
	;lds	si,[ss:CALLVIDRW]
	;mov	[ss:EXTERRPT+2], ds
	;mov	[ss:EXTERRPT], si
	;pop	si
	;pop	ds

	; MSDOS 6.0
	push	ax
	mov	ax,[SS:CALLVIDRW]		; get ptr lo  ;smr;SS Override
	mov	[ss:EXTERRPT],ax		; set ext err ptr lo
	mov	ax,[SS:CALLVIDRW+2]		; get ptr hi from dev
	mov	[ss:EXTERRPT+2],ax		; set ext err ptr hi
	pop	ax
DO_ERR:
	;;call	HARDERR
	;;retn
	; 16/12/2022
	; 10/06/2019
	jmp	HARDERR	
	; 18/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;call	HARDERR
	;retn

; 24/07/2018 - Retro DOS v3.0

;Break	<SETUP -- SETUP A DISK READ OR WRITE FROM USER>
;----------------------------------------------------------------------------
;
; Procedure Name : SETUP
;
; Inputs:
;	ES:DI point to SFT (value also in THISSFT)
;	DMAAdd contains transfer address
;	CX = Byte count
;	DS = DOSDATA
;   WARNING Stack must be clean, two ret addrs on stack, 1st of caller,
;		2nd of caller of caller.
; Outputs:
;	    CX = byte count
;	    [THISDPB] = Base of drive parameters if file
;		      = Pointer to device header if device or NET
;	    ES:DI Points to SFT
;	    [NEXTADD] = Displacement of disk transfer within segment
;	    [TRANS] = 0 (No transfers yet)
;	    BytPos = Byte position in file
;
;	The following fields are relevant to local files (not devices) only:
;
;	    SecPos = Position of first sector (local files only)
;	    [BYTSECPOS] = Byte position in first sector (local files only)
;	    [CLUSNUM] = First cluster (local files only)
;	    [SECCLUSPOS] = Sector within first cluster (local files only)
;	    [THISDRV] = Physical unit number (local files only)
;
;      RETURNS ONE LEVEL UP WITH:
;	   CX = 0
;	   CARRY = Clear
;	IF AN ERROR IS DETECTED
; All other registers destroyed
;----------------------------------------------------------------------------

;hkn; called from disk.asm. DS has been set up to DOSDATA.

; DOSCODE:770Bh (MSDOS 6.21, MSDOS.SYS)

; 18/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:76F7h (MSDOS 5.0, MSDOS.SYS)

SETUP:
	; IBMDOS.COM (MSDOS 3.3) - Offset 411Bh

	;lds 	si,[es:di+7]
	LDS	SI,[ES:DI+SF_ENTRY.sf_devptr]

;hkn; SS override
	MOV	[SS:THISDPB+2],DS

;hkn; SS is DOSDATA
	push	ss
	pop	ds

	MOV	[THISDPB],SI

	MOV	BX,[DMAADD]
	MOV	[NEXTADD],BX		;Set NEXTADD to start of Xaddr
	MOV	BYTE [TRANS],0		;No transferes
	;mov	ax,[es:di+15h]
	MOV	AX,[ES:DI+SF_ENTRY.sf_position]
	;mov	dx,[es:di+17h]
	MOV	DX,[ES:DI+SF_ENTRY.sf_position+2]
	MOV	[BYTPOS+2],DX		;Set it
	MOV	[BYTPOS],AX
	;test	word [es:di+5],8080h
	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet+devid_device
	JNZ	short NOSETSTUFF	;Following not done on devs or NET
	PUSH	ES
	LES	BP,[THISDPB]		;Point at the DPB

	; 18/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;;mov	bl,[es:bp+0]
	;MOV	BL,[ES:BP+DPB.DRIVE]
	; 05/12/2022
	mov	bl,[es:bp]
	
	MOV	[THISDRV],BL		;Set THISDRV
	;mov	bx,[es:bp+2]
	MOV	BX,[ES:BP+DPB.SECTOR_SIZE]

	;; MSDOS 3.3
	;cmp	dx,bx
	;jnb	short EOFERR
	;div	bx
	;mov	[SECPOS],ax
	;mov	[BYTSECPOS],dx
	;mov	dx,ax
	;;and	al,[es:bp+4]
	;AND	AL,[ES:BP+DPB.CLUSTER_MASK]
	;mov	[SECCLUSPOS],al
	;mov	ax,cx
	;;mov	cl,[es:bp+5]
	;MOV	CL,[ES:BP+DPB.CLUSTER_SHIFT]
	;shr	dx,cl
	;mov	[CLUSNUM],dx
	;pop	es
	;mov	cx,ax

	; 04/05/2019 - Retro DOS v4.0

	; MSDOS 6.0
;M039: Optimized this section.
        PUSH    CX			;SHR32 and DIV32 use CX.
	call	DIV32			;DX:AX/BX = CX:AX + DX (rem)
	MOV	[BYTSECPOS],DX
	MOV	[SECPOS],AX
	MOV	[SECPOS+2],CX
	MOV	DX,CX

	MOV	BX,AX
	;and	bl,[es:bp+4]
	AND	BL,[ES:BP+DPB.CLUSTER_MASK]
	MOV	[SECCLUSPOS],BL

	call	SHR32			;(DX:AX SHR dpb_cluster_shift)
	POP	CX			;CX = byte count.
	JNZ	short EOFERR		;cluster number above 64k
	;cmp	ax,[es:bp+0Dh]
	CMP	AX,[ES:BP+DPB.MAX_CLUSTER] ;>32mb  if > disk size ;AN000;
	JA	short EOFERR		   ;>32mb  then EOF       ;AN000;

	MOV	[CLUSNUM],AX
	POP	ES			; ES:DI point to SFT
;M039

NOSETSTUFF:
	MOV	AX,CX		; AX = Byte count.
	ADD	AX,[DMAADD]	; See if it will fit in one segment
	JNC	short setup_OK	; Must be less than 64
	MOV	AX,[DMAADD]
	NEG	AX		; Amount of room left in segment (know
				;    less than 64K since max value of CX
				;    is FFFF).
	JNZ	short NoDec
	DEC	AX
NoDec:
	MOV	CX,AX		; Can do this much
	JCXZ	NOROOM		; Silly user gave Xaddr of FFFF in segment
setup_OK:
	retn

EOFERR:
	POP	ES		; ES:DI point to SFT
	XOR	CX,CX		; No bytes read
;;;;;;;;;;; 7/18/86
	; MSDOS 3.3
	;MOV	BYTE [DISK_FULL],1 ; set disk full flag
;;;;;;;;;;;
NOROOM:
	POP	BX		; Kill return address
	CLC
	retn			; RETURN TO CALLER OF CALLER

;Break	<BREAKDOWN -- CUT A USER READ OR WRITE INTO PIECES>
;---------------------------------------------------------------------------
;
; Procedure Name : BREAKDOWN
;
; Inputs:
;	CX = Length of disk transfer in bytes
;	ES:BP = Base of drive parameters
;	[BYTSECPOS] = Byte position within first sector
;	DS = DOSDATA
; Outputs:
;	[BYTCNT1] = Bytes to transfer in first sector
;	[SECCNT] = No. of whole sectors to transfer
;	[BYTCNT2] = Bytes to transfer in last sector
; AX, BX, DX destroyed. No other registers affected.
;---------------------------------------------------------------------------

BREAKDOWN:
	MOV	AX,[BYTSECPOS]
	MOV	BX,CX
	OR	AX,AX
	JZ	short SAVFIR	; Partial first sector?
	;sub	ax,[es:bp+2]
	SUB	AX,[ES:BP+DPB.SECTOR_SIZE]
	NEG	AX		; Max number of bytes left in first sector
	SUB	BX,AX		; Subtract from total length
	JAE	short SAVFIR
	ADD	AX,BX		; Don't use all of the rest of the sector
	XOR	BX,BX		; And no bytes are left
SAVFIR:
	MOV	[BYTCNT1],AX
	MOV	AX,BX
	XOR	DX,DX
	;div	word [ES:BP+2]
	DIV	word [ES:BP+DPB.SECTOR_SIZE]  ; How many whole sectors?
	MOV	[SECCNT],AX
	MOV	[BYTCNT2],DX	; Bytes remaining for last sector
	; MSDOS 3.3
	;OR	DX,[BYTCNT1]	; SMR ONESECTORFIX BUGBUG
	;retnz			; NOT (BYTCNT1 = BYTCNT2 = 0)
	;CMP	AX,1
	;retnz
	;MOV	AX,[ES:BP+DPB.SECTOR_SIZE] ; Buffer EXACT one sector I/O
	;MOV	[BYTCNT2],AX
	;MOV	[SECCNT],DX	; DX = 0
_RET45:
	retn

; DOSCODE:77BFh (MSDOS 6.21, MSDOS.SYS)

;----------------------------------------------------------------------------
;
; Procedure Name : READ_LOCK_VIOLATION
;
; ES:DI points to SFT. This entry used by NET_READ
; Carry set if to return error (CX=0,AX=error_sharing_violation).
; Else do retrys.
; ES:DI,DS,CX preserved
;
;----------------------------------------------------------------------------

READ_LOCK_VIOLATION:
	MOV	byte [READOP],0
ERR_ON_CHECK:
	;;test	word [es:di+2],8000h
	;TEST	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB
	;JNZ	short HARD_ERR

	; 04/05/2019
	;test	byte [es:di+3],80h
	TEST	byte [ES:DI+SF_ENTRY.sf_mode+1],(sf_isFCB>>8)
	JNZ	short HARD_ERR

	;PUSH	CX
	;;mov	cl,[es:di+2]
	;MOV	CL,[ES:DI+SF_ENTRY.sf_mode]
	;;and	cl,0F0h
	;AND	CL,SHARING_MASK
	;;cmp	cl,0
	;CMP	CL,SHARING_COMPAT
	;POP	CX
	;JNE	short NO_HARD_ERR
	; 21/09/2023
	mov	al,[ES:DI+SF_ENTRY.sf_mode]
	and	al,SHARING_MASK
	;cmp	al,SHARING_COMPAT
	;jne	short NO_HARD_ERR
	jnz	short NO_HARD_ERR
HARD_ERR:
	call	LOCK_VIOLATION
	jnc	short _RET45		; User wants Retrys
NO_HARD_ERR:
	XOR	CX,CX			;No bytes transferred
	;mov	ax,21h
	MOV	AX,error_lock_violation
	STC
RET3:		; 06/02/2024
	retn

;----------------------------------------------------------------------------
;
; Procedure Name : WRITE_LOCK_VIOLATION
;
; Same as READ_LOCK_VIOLATION except for READOP.
; This entry used by NET_WRITE
;
;----------------------------------------------------------------------------

WRITE_LOCK_VIOLATION:
	MOV	byte [READOP],1
	JMP	short ERR_ON_CHECK

; 04/05/2019 - Retro DOS v4.0

; DOSCODE:77ECh (MSDOS 6.21, MSDOS.SYS)

;Break	<DISKREAD -- PERFORM USER DISK READ>
;----------------------------------------------------------------------------
;
; Procedure Name : DISKREAD
;
; Inputs:
;	Outputs of SETUP
; Function:
;	Perform disk read
; Outputs:
;    Carry clear
;	CX = No. of bytes read
;	ES:DI point to SFT
;	SFT offset and cluster pointers updated
;    Carry set
;	CX = 0
;	ES:DI point to SFT
;	AX has error code
;----------------------------------------------------------------------------

;hkn; called from disk.asm. DS already set up.

; 18/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:77D8h (MSDOS 5.0, MSDOS.SYS)

DISKREAD:
	;mov	ax,[es:di+11h]
	MOV	AX,[ES:DI+SF_ENTRY.sf_size]
	;mov	bx,[es:di+13h]
	MOV	BX,[ES:DI+SF_ENTRY.sf_size+2]
	SUB	AX,[BYTPOS]
	SBB	BX,[BYTPOS+2]
	JB	short RDERR		;Read starts past EOF
	JNZ	short ENUF		;More than 64k to EOF
	OR	AX,AX
	JZ	short RDERR		;Read starts at EOF
	CMP	AX,CX
	JAE	short ENUF		;I/O fits
	MOV	CX,AX			;Limit read to up til EOF
ENUF:
	; MSDOS 3.3
	;test	byte [es:di+4],8
	;TEST	byte [ES:DI+SF_ENTRY.sf_attr],attr_volume_id
	;jnz	short SET_ACC_ERR
	;call	LOCK_CHECK
	;jnb	short _READ_OK
	;call	READ_LOCK_VIOLATION
	;jnb	short ENUF
	;retn

	; MSDOS 6.0
	call	CHECK_READ_LOCK		;IFS. check read lock	;AN000;
	;JNC	short _READ_OK 		; There are no locks
	;retn
	; 06/02/2024
	jc	short RET3

_READ_OK:
	LES	BP,[THISDPB]
	CALL	BREAKDOWN
	MOV	CX,[CLUSNUM]

	call	FNDCLUS
     	; MSDOS 6.0			;M022 conditional removed here
	JC	short SET_ACC_ERR_DS	; fix to take care of I24 fail
					; migrated from 330a - HKN
	;OR	CX,CX
	;JZ	short SKIPERR
	; 06/02/2024
	jcxz	SKIPERR

RDERR:
	MOV	AH,0EH			;MS. read/data/fail ;AN000;
	jmp	WRTERR22

;RDLASTJ: 
	;JMP	RDLAST                  ;M039

SETSFTJ2: 
	JMP	SETSFT

CANOT_READ:
	; MSDOS 3.3
	;POP	CX		;M039.
	; MSDOS 3.3 & MSDOS 6.0
	POP	CX              ;Clean stack.
	POP	BX

	;entry	SET_ACC_ERR_DS
SET_ACC_ERR_DS:

;hkn; SS is DOSDATA
	;Context DS
	push	ss
	pop	ds

	;entry	SET_ACC_ERR
SET_ACC_ERR:
	XOR	CX,CX
	;mov	ax,5
	MOV	AX,error_access_denied
	STC
	retn

SKIPERR:
	MOV	[LASTPOS],DX
	MOV	[CLUSNUM],BX
	CMP	word [BYTCNT1],0
	JZ	short RDMID

	call	BUFRD
	JC	short SET_ACC_ERR_DS

RDMID:
	CMP	word [SECCNT],0
	;JZ	RDLAST ; 10/08/2018
	jz	short RDLAST

	call	NEXTSEC
	JC	short SETSFTJ2

	MOV	BYTE [TRANS],1		; A transfer is taking place
ONSEC:
	MOV	DL,[SECCLUSPOS]	; (dx/DL = Extent start) ((dh = ?))
	MOV	CX,[SECCNT]
	MOV	BX,[CLUSNUM]
RDLP:
	call	OPTIMIZE
	JC	short SET_ACC_ERR_DS

	PUSH	DI                      ;DI = Next physical cluster.
	PUSH	AX                      ;AX = # of sectors remaining.
	PUSH	BX			;[DMAADD+2]:BX = Transfer address.
	;mov	byte [ALLOWED],38h
	MOV	byte [ALLOWED],Allowed_RETRY+Allowed_FAIL+Allowed_IGNORE
	MOV	DS,[DMAADD+2]

	PUSH	DX                      ;[HIGH_SECTOR]:DX = phys. sector #.
	PUSH	CX                      ;CX = # of contiguous sectors to read.

	; 04/05/2019 - Retro DOS v4.0

	; MSDOS 6.0
	call	SET_RQ_SC_PARMS		;LB. do this for SC ;AN000;

	; MSDOS 3.3 (& MSDOS 6.0)
	call	DREAD

	; MSDOS 3.3 
	;pop	bx
	;pop	dx
	;jc	short CANOT_READ
	;add	bx,dx	; (bx = Extent end)
	;mov	al,[es:bp] ; mov al,[es:bp+0]
	;;mov	al,[ES:BP+DPB.DRIVE] 
	;call	SETVISIT
	; ->***
;M039
	; MSDOS 6.0 
	pop	cx
	pop	dx
	pop	WORD [ss:TEMP_VAR]
	jc	short CANOT_READ

	mov	[ss:TEMP_VAR2],ds

;       CX = # of contiguous sectors read. (These constitute a block of
;            sectors, also termed an "Extent".)
;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
;       [TEMP_VAR2]:[TEMP_VAR] = Transfer address (destination data address).
;       ES:BP -> Drive Parameter Block (DPB).
;
;	The Buffer Queue must now be scanned: the contents of any dirty
;	buffers must be "read" into the transfer memory block, so that the
;       transfer memory reflects the most recent data.

	call	DskRdBufScan

	;Context DS
	push	ss
	pop	ds
        
	pop	cx
        pop	bx

;       CX = # of sector remaining.
;       BX = Next physical cluster.

;M039

;;;;;;;;
;	; 25/07/2018 - Retro DOS v3.0
;	; ***->
;	; MSDOS 3.3
;	; IBMDOS.COM (1987) - Offset 42BDh
;bufq:
;;	DX = Extent start.
;;	BX = Extent end.
;;	 AL = Drive #.
;;     DS:DI-> 1st buffer in queue.
;
;	;or	byte [di+5],20h
;	or	byte [DI+BUFFINFO.buf_flags],buf_visit ; Bit 5 = reserved
;	;cmp	al,[di+4]	
;	cmp	al,[DI+BUFFINFO.buf_ID]
;	jnz	short bufq3
;	;cmp	[di+6],dx
;	cmp	[DI+BUFFINFO.buf_sector],dx
;	jb	short bufq3	; Jump if Extent start > buffer sector.
;	;cmp	[di+6],bx
;	cmp	[DI+BUFFINFO.buf_sector],bx
;	jnb	short bufq3	; Jump if Extent end >= buffer sector.
;	
;	; Buffer sector is in the Extent (contiguous sectors to read)
;
;;      Buffer's sector is in Extent: if it is dirty, copy its contents to
;;      transfer memory; otherwise, just re-position it in the buffer queue
;;      as MRU (Most Recently Used).
;
;	;test	byte [di+5],40h
;	test	byte [DI+BUFFINFO.buf_flags],buf_dirty ; Bit 6 = dirty flag
;	jz	short bufq2	; clear buffer, check the next buff sec
;	pop	ax ; transfer address
;	push	ax
;	push	di
;	push	dx
;	;sub	dx,[di+6]
;	sub	dx,[DI+BUFFINFO.buf_sector]
;	neg	dx
;
;;      DX = offset (in sectors) of buffer sector within Transfer memory
;;           block.
;
;	mov	si,di
;	mov	di,ax
;	mov	ax,dx
;	;mov	cx,[es:bp+6]	
;	mov     cx,[ES:BP+DPB.SECTOR_SIZE] ; CX = sector size (in bytes).
;	mul	cx
;	add	di,ax
;
;	lea	si,[si+16]
;	lea	si,[SI+BUFINSIZ] ;DS:SI -> buffer data.
;	shr	cx,1
;	push	es
;	mov	es,[SS:DMAADD+2]
;
;;      CX = sector size (in WORDs) ; CF=1 if odd # of bytes.
;;      DS:SI-> Buffer sector data.
;;      ES:DI-> Destination within Transfer memory block.
;
;	rep	movsw			;Copy buffer sector to Transfer memory
;	;adc	cx,0                    ;CX=1 if odd # of bytes, else CX=0.
;	;rep	movsb                   ;Copy last byte.
;	jnc	short bufq1
;	movsb
;bufq1:
;	pop	es
;	pop	dx
;	pop	di
;	mov	al,[es:bp]  ; mov al,[es:bp+0]
;	;mov	al,[ES:BP+DPB.DRIVE]
;bufq2:
;	call	SCANPLACE
;bufq3:
;	call	SKIPVISIT
;	jnz	short bufq
;	
;	push	ss
;	pop	ds
;	pop	cx
;	pop	cx
;	pop	bx	
;bufq4:
;;;;;;;
	JCXZ	RDLAST

	call	IsEOF			; test for eof on fat size
	JAE	short SETSFT

	MOV	DL,0
	INC	word [LASTPOS]		; We'll be using next cluster
	JMP	short RDLP ; 19/05/2019

RDLAST:
	MOV	AX,[BYTCNT2]
	OR	AX,AX
	JZ	short SETSFT
	MOV	[BYTCNT1],AX

	call	NEXTSEC
	JC	short SETSFT

	MOV	word [BYTSECPOS],0
	call	BUFRD
	; 10/08/2018

	JNC	short SETSFT
	JMP	SET_ACC_ERR_DS

;------------------------------------------------------------------------------
;
; Procedure Name : SETSFT
; Inputs:
;	[NEXTADD],[CLUSNUM],[LASTPOS] set to determine transfer size
;		and set cluster fields
; Function:
;	Update [THISSFT] based on the transfer
; Outputs:
;	sf_position, sf_lstclus, and sf_cluspos updated
;	ES:DI points to [THISSFT]
;	CX No. of bytes transferred
;	Carry clear
;
;----------------------------------------------------------------------------

	;entry	SETSFT

; 26/07/2018 - Retro DOS v3.0
SETSFT:
	LES	DI,[THISSFT]

; Same as SETSFT except ES:DI already points to SFT
	;entry	SETCLUS
SETCLUS:	
	MOV	CX,[NEXTADD]
	SUB	CX,[DMAADD]		; Number of bytes transfered
	;;test	word [es:di+5],80h
	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
	;JNZ	short ADDREC		; don't set clusters if device

	; 04/05/2019 - Retro DOS v4.0
	;test	byte [es:di+5],80h
	TEST	byte [ES:DI+SF_ENTRY.sf_flags],devid_device
	JNZ	short ADDREC		; don't set clusters if device

	MOV	AX,[CLUSNUM]
	;;mov	[es:di+1Bh],ax ; MSDOS 3.3
	;mov	[es:di+35h],ax ; MSDOS 6.0 (& MSDOS 6.21)
	MOV	[ES:DI+SF_ENTRY.sf_lstclus],AX
	MOV	AX,[LASTPOS]
	;mov	[es:di+19h],ax
	MOV	[ES:DI+SF_ENTRY.sf_cluspos],AX

;----------------------------------------------------------------------------
;
; Procedure : AddRec
; Inputs:
;	ES:DI points to SFT
;	CX is No. Bytes transferred
; Function:
;	Update the SFT offset based on the transfer
; Outputs:
;	sf_position updated to point to first byte after transfer
;	ES:DI points to SFT
;	CX No. of bytes transferred
;	Carry clear
;----------------------------------------------------------------------------

	;entry	AddRec
ADDREC:
	JCXZ	RET28		; If no records read,  don't change position
	;add	[es:di+15h],cx
	ADD	[ES:DI+SF_ENTRY.sf_position],CX  ; Update current position
	;adc	word [es:di+17h], 0
	ADC	WORD [ES:DI+SF_ENTRY.sf_position+2],0
RET28:	
	CLC
	retn

; 25/07/2018
; MSDOS 6.0
;Break   <DskRdBufScan -- Disk Read Buffer Scan>
;----------------------------------------------------------------------------
;
; Procedure Name : DskRdBufScan
;
; Inputs:
;       CX = # of contiguous sectors read. (These constitute a block of
;            sectors, also termed an "Extent".)
;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
;       [TEMP_VAR2]:[TEMP_VAR] = Transfer address (destination data address).
;       ES:BP -> Drive Parameter Block (DPB).
;
; Function:
;	The Buffer Queue is scanned: the contents of any dirty buffers are
;	"read" into the transfer memory block, so that the transfer memory
;	reflects the most recent data.
;
; Outputs:
;       Transfer memory updated as required.
;
; Uses:
;       DS,AX,BX,CX,SI,DI destroyed.
;       SS override for all global variables.
;
; Notes:
;       FIRST_BUFF_ADDR is set-up to contain the LAST buffer to check, rather
;	than the FIRST.
;----------------------------------------------------------------------------
;M039: Created

; 04/05/2019 - Retro DOS v4.0
; DOSCODE:78F0h (MSDOS 6.21, MSDOS.SYS)

; 18/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:78DCh (MSDOS 5.0, MSDOS.SYS) 

;procedure DskRdBufScan,NEAR
;
;ASSUME  DS:NOTHING

DskRdBufScan:
	cmp	word [ss:DirtyBufferCount],0 ; Any dirty buffers?
	je	short bufx		     ; -no, skip all work.

	mov     bx,[ss:HIGH_SECTOR]
	mov     si,bx
	add     cx,dx
	adc     si,0

	call	GETCURHEAD		;DS:DI -> 1st buf in queue.
	;mov	ax,[di+2]
	mov     ax,[di+BUFFINFO.buf_prev]
	mov     [ss:FIRST_BUFF_ADDR],ax
		
	; 18/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;;mov	al,[es:bp+0]
	;mov	al,[es:bp+DPB.DRIVE]
	; 15/12/2022
	mov	al,[es:bp]

;       BX:DX = Extent start.
;       SI:CX = Extent end + 1.
;          AL = Drive #.
;       DS:DI-> 1st buffer in queue.
;[FIRST_BUFF_ADDR] = Address offset of last buffer in queue.

bufq:	
	;cmp	al,[di+4]
	cmp     al,[di+BUFFINFO.buf_ID] ;Same drive?
	jne	short bufq1        	;  -no, jump.

;       Cmp32   bx,dx,<WORD PTR [di.buf_sector+2]>,<WORD PTR [di.buf_sector]>
;       ja	short bufq1		;Jump if Extent start > buffer sector.

	;cmp	bx,[di+8]
	cmp	bx,[di+BUFFINFO.buf_sector+2]
	jne	short bufq01
	;cmp	dx,[di+6]
	cmp	dx,[di+BUFFINFO.buf_sector]
bufq01:
	ja	short bufq1

;       Cmp32   si,cx,<WORD PTR [di.buf_sector+2]>,<WORD PTR [di.buf_sector]>
;       ja	short bufq2		;Jump if Extent end >= buffer sector.

	;cmp	si,[di+8]
	cmp	si,[di+BUFFINFO.buf_sector+2]
	jne	short bufq02
	;cmp	cx,[di+6]
	cmp	cx,[di+BUFFINFO.buf_sector]
bufq02:
	ja	short bufq2
bufq1:	
	cmp     di,[ss:FIRST_BUFF_ADDR]	;Scanned entire buffer queue?
	mov	di,[di]
	;mov	di,[di+BUFFINFO.buf_next] ; Set-up for next buffer.
	jne	short bufq		; -no, do next buffer
bufx:
	retn				;Exit.

;       Buffer's sector is in Extent: if it is dirty, copy its contents to
;	transfer memory; otherwise, just re-position it in the buffer queue
;       as MRU (Most Recently Used).

bufq2:	
	push	ax
	;test	byte [di+5],40h
	test	byte [di+BUFFINFO.buf_flags],buf_dirty ;Buffer dirty?
	jz	short bufq3                    ; -no, jump.

;       SaveReg <cx,dx,si,di,es>
	push	cx
	push	dx
	push	si
	push	di
	push	es

	mov     ax,dx
	;sub	ax,[di+6]
	sub	ax,[di+BUFFINFO.buf_sector]
	neg	ax

;       AX = offset (in sectors) of buffer sector within Transfer memory
;            block. (Note: the upper word of the sector # may be ignored
;	     since no more than 64k bytes will ever be read. This 64k limit
;            is imposed by the input parameters of the disk read operation.)

	;lea	si,[di+20]
	lea	si,[di+BUFINSIZ]	;DS:SI -> buffer data.
	;mov	cx,[es:bp+2]
	mov     cx,[es:bp+DPB.SECTOR_SIZE] ;CX = sector size (in bytes).
	mul     cx			;AX = offset (in bytes) of buf. sector
	mov     di,[ss:TEMP_VAR]
	add	di,ax
	mov	es,[ss:TEMP_VAR2]
	shr	cx,1

;	   CX = sector size (in WORDs) ; CF=1 if odd # of bytes.
;       DS:SI-> Buffer sector data.
;       ES:DI-> Destination within Transfer memory block.

	rep	movsw			;Copy buffer sector to Transfer memory
	;; 04/05/2019
	;;adc	cx,0                    ;CX=1 if odd # of bytes, else CX=0.
	;;rep	movsb                   ;Copy last byte.
	;jnc	short bufq03	
	;movsb
	; 18/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;adc	cx,0
	;rep	movsb
	; 22/09/2023
	jnc	short bufq03
	movsb
bufq03:
	;RestoreReg <es,di,si,dx,cx>
	pop	es
	pop	di
	pop	si
	pop	dx
	pop	cx

;       DS:DI -> current buffer.
bufq3:	
	mov     ax,di			;DS:AX -> Current buffer.
        ;invoke SCANPLACE
	call	SCANPLACE
	cmp	ax,[ss:FIRST_BUFF_ADDR] ;Last buffer?
	pop	ax
	;jne	short bufq		; -no, jump.
	;;jmp	short bufx		; -yes, exit.
	;; 12/06/2019
	;retn
	; 18/11/2022 (MSDOS 5.0 MSDOS.SYS compability)
	jne	short bufq
	jmp	short bufx

;EndProc DskRdBufScan

;============================================================================
; DISK3.ASM, MSDOS 6.0, 1991
;============================================================================
; 04/05/2019 - Retro DOS v4.0
; 24/07/2018 - Retro DOS v3.0

;Break   <DISKWRITE -- PERFORM USER DISK WRITE>
;----------------------------------------------------------------------------
;
; Procedure Name : DISKWRITE
;
; Inputs:
;       Outputs of SETUP
; Function:
;       Perform disk write
; Outputs:
;    Carry clear
;       CX = No. of bytes written
;       ES:DI point to SFT
;       SFT offset and cluster pointers updated
;    Carry set
;       CX = 0
;       ES:DI point to SFT
;       AX has error code
;----------------------------------------------------------------------------

;hkn; called by DOS_WRITE. DS already set up at this point.

; DOSCODE:797Ah (MSDOS 6.21, MSDOS.SYS)

; 20/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:7966h (MSDOS 5.0, MSDOS.SYS) 

DISKWRITE:
	; MSDOS 3.3
	; IBMDOS.COM - Offset 436Dh
	;;test	byte [es:di+4],8
	;TEST	byte [ES:DI+SF_ENTRY.sf_attr],attr_volume_id
	;jz	short write_cont
	;jmp	SET_ACC_ERR_DS
;write_cont:
	;push	cx
	;or	cx,cx
	;jnz	short Not_Truncate
	;;mov	cx,-1
	;dec	cx
;Not_Truncate:
	;call	LOCK_CHECK
	;pop	cx
	;jnb	short _WRITE_OK
	;call	WRITE_LOCK_VIOLATION
	;jnb	short DISKWRITE
	;retn

	; MSDOS 6.0
	call	CHECK_WRITE_LOCK	;IFS. check write lock	;AN000;
	; 19/08/2018
	JNC	short _WRITE_OK		;IFS. lock check ok	;AN000;
	retn

WRTEOFJ:
	JMP     WRTEOF

_WRITE_OK:
 	; 27/07/2018
	; IBMDOS.COM - Offset 438Eh
	
	; MSDOS 3.3 (& MSDOS 6.0)
	;and	word [es:di+5],0BFBFh
	AND     word [ES:DI+SF_ENTRY.sf_flags],~(sf_close_nodate|devid_file_clean)
				; Mark file as dirty, clear no date on close

	; 04/05/2019 - Retro DOS v4.0	

	; MSDOS 6.0
	; mov 	ax,[es:di+11h]
	MOV	AX,[ES:DI+SF_ENTRY.sf_size]		;M039
        MOV	[TEMP_VAR],AX                           ;M039
	;mov	ax,[es:di+13h]
	MOV	AX,[ES:DI+SF_ENTRY.sf_size+2]		;M039
        MOV	[TEMP_VAR2],AX                          ;M039

;	TEMP_VAR2:TEMP_VAR = Current file size (sf_size);M039

	; MSDOS 3.3 (& MSDOS 6.0)
	LES     BP,[THISDPB]

	call	BREAKDOWN

	MOV     AX,[BYTPOS]
	MOV     DX,[BYTPOS+2]
	JCXZ    WRTEOFJ                 ;Make the file length = sf_position
	ADD     AX,CX
	ADC     DX,0                    ;DX:AX = last byte to write + 1.

	;mov	bx,[es:bp+2]
	MOV     BX,[ES:BP+DPB.SECTOR_SIZE]

	; MSDOS 3.3
	;cmp	dx,bx
	;jnb	short WRTERR33
	;div	bx
	;mov	bx,ax
	;OR	DX,DX
	;JNZ	short CALCLUS
	;dec	ax
;CALCLUS:
	; MSDOS 3.3
	;mov	cl,[es:bp+5]
	;MOV	CL,[ES:BP+DPB.CLUSTER_SHIFT]
	;shr	ax,cl
	;push	ax
	;push	dx
	;push	es
	;les	di,[THISSFT]
	;;mov	ax,[es:di+11h]
	;;mov	dx,[es:di+13h]
	;mov	ax,[ES:DI+SF_ENTRY.sf_size]
	;mov	dx,[ES:DI+SF_ENTRY.sf_size+2]
	;pop	es
	;;DX:AX = current file size (in bytes).
	;;div	word [es:bp+2]
	;div	word [ES:BP+DPB.SECTOR_SIZE]
	;mov	cx,ax
	;or	dx,dx
	;jz	short NORND
	;inc	ax
;NORND:
	; MSDOS 6.0
	CALL	DIV32                   ;DX:AX/BX = CX:AX + DX (rem.).
	MOV	SI,AX
        MOV	[HIGH_SECTOR],CX

;       [HIGH_SECTOR]:SI = Last full sector to write.

	OR	DX,DX
	PUSH	DX			;M039: Free DX for use by SHR32
	MOV	DX,CX			;M039
	JNZ	short CALCLUS
	SUB	AX,1                    ;AX must be zero base indexed	;AC000;
	SBB	DX,0			;M039 ;F.C. >32mb		;AN000;

CALCLUS:
	; MSDOS 6.0
	CALL	SHR32                   ;F.C. >32mb			;AN000;
	POP	DX

;       AX = Last cluster to write.
;       DX = # of bytes in last sector to write (the "tail").
;       BX = [ES:BP+DPB.SECTOR_SIZE]

	PUSH	AX
	PUSH	DX
;M039
	mov	dx,[TEMP_VAR2]
	mov	ax,[TEMP_VAR]           ;DX:AX = current file size (in bytes).
	call	DIV32           	;DX:AX/BX = CX:AX + DX (rem.)
	mov	[TEMP_VAR2],cx
	mov	[VALSEC+2],cx
	mov	cx,ax
	mov	bx,si

;       [HIGH_SECTOR]:BX = Last full sector to write.
;          [VALSEC+2]:CX = Last full sector of current file.
;         [TEMP_VAR2]:CX = Last full sector of current file.
;                     DX = # of bytes in last sector of current file.
;M039
	OR	DX,DX
	JZ	short NORND
	;ADD	AX,1            	;Round up if any remainder	;AC000;
	;ADC	word [VALSEC+2],0
	; 22/09/2023
	inc	ax  ; 0FFFFh -> 0
	jnz	short NORND
	inc	word [VALSEC+2]
NORND:	
	; MSDOS 3.3 & MSDOS 6.0
	MOV     [VALSEC],AX

;       [VALSEC] = Last sector of current file.

	XOR     AX,AX
	MOV     [GROWCNT],AX
	MOV     [GROWCNT+2],AX
	POP     AX

	; MSDOS 6.0
	MOV	DI,[HIGH_SECTOR]        ;F.C. >32mb			;AN000;
	CMP	DI,[TEMP_VAR2]		;M039; F.C. >32mb		;AN000;
	JB	short NOGROW		;F.C. >32mb                     ;AN000;
	JZ	short lowsec		;F.C. >32mb                     ;AN000;
	SUB	BX,CX                   ;F.C. >32mb                     ;AN000;
	SBB	DI,[TEMP_VAR2]   	;M039; F.C. >32mb di:bx no. of sectors ;AN000;
	JMP	short yesgrow           ;F.C. >32mb                     ;AN000;
lowsec:
	;MOV	DI,0			;F.C. >32mb
	; 22/09/2023
	xor	di,di
	; MSDOS 3.3 & MSDOS 6.0
	SUB	BX,CX			; Number of full sectors
	JB	short NOGROW
	JZ	short TESTTAIL
yesgrow:
	; MSDOS 3.3 (& MSDOS 6.0)
	MOV     CX,DX
	XCHG    AX,BX
	;mul	word [es:bp+2]
	MUL	word [ES:BP+DPB.SECTOR_SIZE]  ; Bytes of full sector growth
	
	; MSDOS 6.0
	MOV	[HIGH_SECTOR],DX         ;F.C. >32mb save dx                    ;AN000;
	MOV	[TEMP_VAR2],AX    	 ;M039; F.C. >32mb save ax		;AN000;
	MOV	AX,DI                    ;F.C. >32mb                            ;AN000;
	;mul	word [es:bp+2]
	MUL	word [ES:BP+DPB.SECTOR_SIZE] ;F.C. >32mb do higher word multiply ;AN000;
	
	ADD	AX,[HIGH_SECTOR]         ;F.C. >32mb add lower value            ;AN000;
	MOV	DX,AX                    ;F.C. >32mb DX:AX is the result of     ;AN000;
	MOV	AX,[TEMP_VAR2]    	 ;M039; F.C. >32mb a 32 bit multiply	;AN000;

	; MSDOS 3.3 (& MSDOS 6.0)
	SUB     AX,CX			; Take off current "tail"
	SBB     DX,0			; 32-bit extension
	ADD     AX,BX			; Add on new "tail"
	ADC     DX,0			; ripple tim's head off
	JMP     SHORT SETGRW

HAVSTART:
	;int 3
	MOV     CX,AX
	call	SKPCLP
	;JCXZ	DOWRTJ
	; 16/12/2022
	jcxz	DOWRT
	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;jcxz	DOWRTJ

	call	ALLOCATE
	;JNC	short DOWRTJ
	; 16/12/2022
	jnc	short DOWRT
	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;jnc	short DOWRTJ

	;entry   WRTERR
WRTERR:
	MOV     AH,0FH			;MS. write/data/fail/abort      ;AN000;

	;entry WRTERR22
WRTERR22:
	MOV     AL,[THISDRV]		;MS.                            ;AN000;

	; 27/07/2018
WRTERR33:
	;MOV	CX,0			;No bytes transferred
	XOR     CX,CX
					
	LES     DI,[THISSFT]
	;CLC ; 19/05/2019
	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	; 16/12/2022
	;clc
	retn

	; 16/12/2022
	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
;DOWRTJ:
	;JMP	short DOWRT

ACC_ERRWJ:
	; 10/08/2018
	;JMP	SET_ACC_ERRW
	; 16/12/2022
	jmp	SET_ACC_ERR_DS
	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;jmp	SET_ACC_ERRW	

TESTTAIL:
	SUB     AX,DX
	JBE	short NOGROW
	XOR     DX,DX
SETGRW:
	MOV	[GROWCNT],AX
	MOV	[GROWCNT+2],DX
NOGROW:
	POP     AX
	MOV     CX,[CLUSNUM]    ; First cluster accessed
	call	FNDCLUS
	JC	short ACC_ERRWJ
	MOV     [CLUSNUM],BX
	MOV     [LASTPOS],DX

	SUB     AX,DX           ; Last cluster minus current cluster
	JZ	short DOWRT	; If we have last clus, we must have first
	JCXZ    HAVSTART        ; See if no more data
	PUSH    CX              ; No. of clusters short of first
	MOV     CX,AX
	call	ALLOCATE
	POP     CX
	JC	short WRTERR
	MOV     DX,[LASTPOS]
	INC     DX
	DEC     CX
	JZ	short NOSKIP
	call	SKPCLP
	JC	short ACC_ERRWJ
NOSKIP:
	MOV     [CLUSNUM],BX
	MOV     [LASTPOS],DX
DOWRT:
	CMP     word [BYTCNT1],0
	JZ	short WRTMID
	MOV     BX,[CLUSNUM]
	call	BUFWRT
	JC	short ACC_ERRWJ
WRTMID:
	MOV     AX,[SECCNT]
	OR      AX,AX
	; 20/11/2022
	JZ	short WRTLAST	; 24/07/2019	;M039
	ADD     [SECPOS],AX
	; 19/05/2019
	; MSDOS 6.0
	ADC	WORD [SECPOS+2],0	;F.C. >32mb 	;AN000;
	call	NEXTSEC
	; 16/12/2022
	JC	short ACC_ERRWJ
	;JC	short SET_ACC_ERRW	;M039
	MOV     BYTE [TRANS],1		; A transfer is taking place
	MOV     DL,[SECCLUSPOS] 	; (dx/DL = Extent start) ((dh = ?))
	MOV     BX,[CLUSNUM]
	MOV     CX,[SECCNT]
WRTLP:
	call	OPTIMIZE
	JC	short SET_ACC_ERRW
	; 16/12/2022
	;JC	short ACC_ERRWJ

;M039
;       DI = Next physical cluster.
;       AX = # sectors remaining.
;       [DMAADD+2]:BX = transfer address (source data address).
;       CX = # of contiguous sectors to write. (These constitute a block of
;	     sectors, also termed an "Extent".)
;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
;       ES:BP -> Drive Parameter Block (DPB).
;
;       Purge the Buffer Queue and the Secondary Cache of any buffers which
;	are in Extent; they are being over-written.

	push    di
	push    ax

	; MSDOS 3.3
	; IBMDOS.COM (1987) - Offset 4497h
	;push	dx
	;push	bx
	;mov	al,[es:bp]
	;;mov	AL,[ES:BP+DPB.DRIVE] ; mov al,[es:bp+0]
	;mov	bx,cx
	;add	bx,dx	; (bx = Extent end)

;	DX = Extent start.
;	BX = Extent end.
;	AL = Drive #.

	;call	SETVISIT

;wbufq1:
	;;or	byte [di+5],20h
	;or	byte [DI+BUFFINFO.buf_flags],buf_visit ; Bit 5 = reserved
	;;cmp	al,[di+4]	
	;cmp	al,[DI+BUFFINFO.buf_ID]
	;jnz	short wbufq2	; Jump if Extent start > buffer sector.
	;;cmp	[di+6],dx
	;cmp	[DI+BUFFINFO.buf_sector],dx
	;jb	short wbufq2
	;;cmp	[di+6],bx
	;cmp	[DI+BUFFINFO.buf_sector],bx
	;jnb	short wbufq2	; Jump if Extent end >= buffer sector.

	;; Buffer sector is in the Extent

	;;mov	word [di+4],20FFh
	;mov	word [DI+BUFFINFO.buf_ID],20FFh
	;				; .buf_ID,    AL = FFh (Free buffer)
	;				; .buf_flags, AH = 0, reset/clear
	;call	SCANPLACE
;wbufq2:
	;call	SKIPVISIT
	;jnz	short wbufq1
	;pop	bx
	;pop	dx

        ; MSDOS 6.0
	call	DskWrtBufPurge		;DS trashed.

;ASSUME DS:NOTHING
;M039
	; MSDOS 3.3 & MSDOS 6.0
;hkn; SS override for DMAADD and ALLOWED
	MOV     DS,[SS:DMAADD+2]
	;mov	byte [ss:ALLOWED],38h
	MOV	byte [SS:ALLOWED],Allowed_RETRY+Allowed_FAIL+Allowed_IGNORE

;	put logic from DWRITE in-line here so we can modify it
;	for DISK FULL conditions.

	; 20/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; DOSCODE:7AD8h (MSDOS 5.0 MSDOS.SYS)

	; 16/12/2022
	; MSDOS 3.3 (& MSDOS 5.0)
	;call	DWRITE

;DWRITE_OKAY:

	; 16/12/2022
	; MSDOS 5.0 (& MSDOS 3.3)
	;pop     cx
	;pop     bx
	;push    ss
	;pop     ds
	;jc      short SET_ACC_ERRW
	;jcxz    WRTLAST
	;mov     dl, 0
	;inc     word [LASTPOS]
	;jmp     short WRTLP

	; 16/12/2022
	; 20/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
DWRITE_LUP:
	; 23/07/2019 - Retro DOS v3.2

	; MSDOS 6.0
	call	DSKWRITE
	jz	short DWRITE_OKAY

;;	int	3

	cmp	al,error_handle_Disk_Full	; compressed volume full?
	jz	short DWRITE_DISK_FULL

	; 16/12/2022

;;hkn; SS override
	MOV	BYTE [SS:READOP],1
	call	HARDERRRW
	CMP	AL,1		; Check for retry
	JZ	short DWRITE_LUP

	; 16/12/2022
	; 23/07/2019
	;POP	CX ; *4*
	;POP	BX ; *5*
	;
	;push	ss
	;pop	ds
	;

	; 20/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)

	; 16/12/2022
	CMP	AL,3		; Check for FAIL
	CLC
	JNZ	short DWRITE_OKAY ; Ignore
	STC

DWRITE_OKAY:
	; 16/12/2022
	; 23/07/2019
	; MSDOS 3.3 (& MSDOS 6.0)
	POP	CX ; *4*
	POP	BX ; *5*

;       CX = # sectors remaining.
;       BX = Next physical cluster.

;hkn; SS override
        ;Context DS
	; 16/12/2022
	;push	ss
	;pop	ds

	; 16/12/2022
	jc	short SET_ACC_ERRW

	; 16/12/2022
	push	ss
	pop	ds

	JCXZ    WRTLAST

	;MOV	DL,0
	xor	dl,dl ; 23/07/2019
	INC     word [LASTPOS]	; We'll be using next cluster
	JMP     short WRTLP

	; 23/07/2019 - Retro DOS v3.2
	; 09/08/2018
	; MSDOS 6.0
DWRITE_DISK_FULL:
	;Context DS		;SQ 3-5-93 DS must be setup on return!
	; 16/12/2022
	push	ss
	pop	ds
	pop	cx		; unjunk stack
	pop	bx
	mov	byte [DISK_FULL],1
	;stc
	jmp	WRTERR ; 24/07/2019 ; go to disk full exit

	; 16/12/2022
SET_ACC_ERRW:
	jmp	SET_ACC_ERR_DS

WRTLAST:
	MOV     AX,[BYTCNT2]
	OR      AX,AX
	JZ	short FINWRT
	MOV     [BYTCNT1],AX
	call	NEXTSEC
	JC	short SET_ACC_ERRW
	MOV     word [BYTSECPOS],0
	call	BUFWRT
	JC	short SET_ACC_ERRW
FINWRT:
	LES     DI,[THISSFT]
	MOV     AX,[GROWCNT]
	MOV     CX,[GROWCNT+2]
	OR      AX,AX
	JNZ	short UPDATE_size
	JCXZ    SAMSIZ
UPDATE_size:
	;add	[es:di+11h],ax
	ADD     [ES:DI+SF_ENTRY.sf_size],AX
	;adc	[es:di+13h],cx
	ADC     [ES:DI+SF_ENTRY.sf_size+2],CX

; Make sure that all other SFT's see this growth also.

	MOV     AX,1
;if installed
	;Call	JShare + 14 * 4
	call    far [JShare+(14*4)]	; 14 = ShSU
;else
;	Call    ShSU
;endif

SAMSIZ:
	jmp	SETCLUS	; ES:DI already points to SFT

	; 16/12/2022
	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
;SET_ACC_ERRW:
	;jmp	SET_ACC_ERR_DS

WRTEOF:
	MOV     CX,AX
	OR      CX,DX
	JZ	short KILLFIL
	SUB     AX,1
	SBB     DX,0

	; MSDOS 3.3
	;;div	word [es:bp+2]
	;div	word [ES:BP+DPB.SECTOR_SIZE]
	;;mov	cl,[es:bp+5]
	;mov	cl,[ES:BP+DPB.CLUSTER_SHIFT] 
	;shr	ax,cl

	; MSDOS 6.0
	PUSH	BX
	;mov	bx,[es:bp+2]
	MOV	BX,[ES:BP+DPB.SECTOR_SIZE]    ;F.C. >32mb                       ;AN000;
	CALL	DIV32                         ;F.C. >32mb                       ;AN000;
	POP	BX			      ;F.C. >32mb			;AN000;
	MOV	DX,CX			      ;M039
        MOV	[HIGH_SECTOR],CX              ;M039: Probably extraneous, but not sure.
	CALL	SHR32                         ;F.C. >32mb                       ;AN000;

	MOV     CX,AX
	call	FNDCLUS
SET_ACC_ERRWJ2:
	JC	short SET_ACC_ERRW

	JCXZ    RELFILE
	call	ALLOCATE
	;JC	short WRTERRJ              ;;;;;;;;; disk full
	; 16/12/2022
	jnc	short UPDATE
	JMP	WRTERR
UPDATE:
	LES	DI,[THISSFT]
	MOV	AX,[BYTPOS]
	;mov	[es:di+11h],ax
	MOV	[ES:DI+SF_ENTRY.sf_size],AX
	MOV	AX,[BYTPOS+2]
	;mov	[es:di+13h],ax
	MOV	[ES:DI+SF_ENTRY.sf_size+2],AX
;
; Make sure that all other SFT's see this growth also.
;
	MOV     AX,2
;if installed
	;Call	JShare + 14 * 4
	call    far [JShare+(14*4)]	; 14 = ShSU
;else
;	Call    ShSU
;endif
	XOR     CX,CX
	jmp	ADDREC

	; 16/12/2022
;WRTERRJ: 
	;JMP	WRTERR

;;;;;;;;;;;;;;;; 7/18/86
;;;;;;;;;;;;;;;;

RELFILE:
	; MSDOS 6.0
	PUSH    ES                    ;AN002; BL Reset Lstclus and cluspos to
	LES     DI,[THISSFT]          ;AN002; BL beginning of file if current
	;cmp	dx,[es:di+19h]
	CMP     DX,[ES:DI+SF_ENTRY.sf_cluspos]	;AN002; BL cluspos is past EOF.
	JAE	short SKIPRESET	      		;AN002; BL
	;mov	[es:di+19h],0
	MOV     word [ES:DI+SF_ENTRY.sf_cluspos],0 ;AN002; BL
	;mov	dx,[es:di+0Bh]
	MOV     DX,[ES:DI+SF_ENTRY.sf_firclus]	;AN002; BL
	;mov	[es:di+35h],dx
	MOV     [ES:DI+SF_ENTRY.sf_lstclus],DX	;AN002; BL
SKIPRESET:                            		;AN002; BL
	POP     ES                    		;AN002; BL
;
	MOV     DX,0FFFFH
	call	RELBLKS
	; 16/12/2022
	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	jnc	short UPDATE
SET_ACC_ERRWJ:
	;JC	short SET_ACC_ERRWJ2
	;JMP	SHORT UPDATE
	; 16/12/2022
	jmp	SET_ACC_ERR_DS
	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;JC	short SET_ACC_ERRWJ2
	;JMP	SHORT UPDATE

KILLFIL:
	XOR     BX,BX
	PUSH    ES
	LES     DI,[THISSFT]
	;mov	[es:di+19h],bx
	MOV	[ES:DI+SF_ENTRY.sf_cluspos],BX
	;mov	[es:di+35h],bx ; 04/05/2019
	MOV	[ES:DI+SF_ENTRY.sf_lstclus],BX
	;xchg	bx,[es:di+0Bh]
	XCHG    BX,[ES:DI+SF_ENTRY.sf_firclus]
	POP	ES

	OR	BX,BX
	;JZ	short UPDATEJ
	; 16/12/2022
	jz	short UPDATE
	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;jz	short UPDATEJ

;; 10/23/86 FastOpen update
	PUSH	ES              ; since first cluster # is 0
	PUSH	BP              ; we must delete the old cache entry
	PUSH	AX
	PUSH	CX
	PUSH	DX
	LES	BP,[THISDPB]             ; get current DPB
	; 15/12/2022
	mov	dl,[ES:BP] ; mov dl,[es:bp+0]
	; 20/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;MOV	DL,[ES:BP+DPB.DRIVE]	; get current drive
	MOV	CX,BX                    ; first cluster #
	MOV	AH,2                     ; delete cache entry by drive:firclus
	call	FastOpen_Update          ; call fastopen
	POP	DX
	POP	CX
	POP	AX
	POP	BP
	POP	ES
;; 10/23/86 FastOpen update

	call	RELEASE
	JC	short SET_ACC_ERRWJ
UPDATEJ:
	; 20/11/2022
	JMP	short UPDATE ; 10/08/2018

;Break   <DskWrtBufPurge -- Disk Write Buffer Purge>
;----------------------------------------------------------------------------
;
; Procedure Name : DskWrtBufPurge
;
; Inputs:
;       CX = # of contiguous sectors to write. (These constitute a block of
;	     sectors, also termed an "Extent".)
;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
;       ES:BP -> Drive Parameter Block (DPB).
;
; Function:
;       Purge the Buffer Queue and the Secondary Cache of any buffers which
;	are in Extent; they are being over-written.
;
; Outputs:
;       (Same as Input.)
; Uses:
;       All registers except DS,AX,SI,DI preserved.
;       SS override for all global variables.
;----------------------------------------------------------------------------
;M039: Created

;procedure   DskWrtBufPurge,NEAR
;
;ASSUME  DS:NOTHING

; 04/05/2019 - Retro DOS v4.0
; DOSCODE:7C0Eh (MSDOS 6.21, MSDOS.SYS)

; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:7BD4h (MSDOS 5.0, MSDOS.SYS) 

DskWrtBufPurge:
	;SaveReg <bx,cx>
	push	bx
	push	cx

	mov	bx,[ss:HIGH_SECTOR]	;BX:DX = Extent start (sector #).
	mov	si,bx
	add	cx,dx
	adc	si,0                    ;SI:CX = Extent end + 1.

	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;;mov	al,[es:bp+0]
	;mov	al,[es:bp+DPB.DRIVE]
	; 15/12/2022
	mov	al,[es:bp]

;	BX:DX = Extent start.
;	SI:CX = Extent end + 1.
;	AL = Drive #

	cmp	word [ss:SC_CACHE_COUNT],0 ;Secondary cache in-use?
	je	short nosc		; -no, jump.

;	If any of the sectors to be written are in the secondary cache (SC),
;	invalidate the entire SC. (This is an optimization; we really only
;	need to invalidate those sectors which intersect, but that's slower.)

	cmp	al,[ss:CurSC_DRIVE]	;Same drive?
	jne	short nosc		; -no, jump.

	push    ax
	mov     ax,[ss:CurSC_SECTOR]
	mov     di,[ss:CurSC_SECTOR+2]	;DI:AX = SC start.

	;Cmp32	si,cx,di,ax		;Extent end < SC start?
	;jbe	short sc5		; -yes, jump.

	cmp	si,di
	jne	short sc01
	cmp	cx,ax
sc01: 
	jbe	short sc5	

	add	ax,[ss:SC_CACHE_COUNT]
	adc	di,0                    ;DI:AX = SC end + 1.
	
	;Cmp32	bx,dx,di,ax             ;Extent start > SC end?
	;jae	short sc5		; -yes, jump.

	cmp	bx,di
	jne	short sc02
	cmp	dx,ax
sc02:
	jnb	short sc5

	mov	word [ss:SC_STATUS],0	;Extent intersects SC: invalidate SC.
sc5:	
	pop     ax

;	Free any buffered sectors which are in Extent; they are being over-
;	written.

nosc:	
	call	GETCURHEAD		;DS:DI -> first buffer in queue.

_bufq:	
	;cmpo	al,[di+4]
	cmp     al,[di+BUFFINFO.buf_ID] ;Same drive?
	jne	short bufq5		; -no, jump.

;       Cmp32   bx,dx,<WORD PTR [di.buf_sector+2]>,<WORD PTR [di.buf_sector]>
;       ja	short bufq5		;Jump if Extent start > buffer sector.

	;cmp	bx,[di+8]
	cmp	bx,[di+BUFFINFO.buf_sector+2]
	jne	short bufq04
	;cmp	dx,[di+6]
	cmp	dx,[di+BUFFINFO.buf_sector]
bufq04:
	ja	short bufq5

;       Cmp32   si,cx,<WORD PTR [di.buf_sector+2]>,<WORD PTR [di.buf_sector]>
;       jbe	short bufq5		;Jump if Extent end < buffer sector.

	;cmp	si,[di+8]
	cmp	si,[di+BUFFINFO.buf_sector+2]
	jne	short bufq05
	;cmp	cx,[di+6]
	cmp	cx,[di+BUFFINFO.buf_sector]
bufq05:
	jbe	short bufq5

;	Buffer's sector is in Extent, so free it; it is being over-written.

	;test	byte [di+5],40h
	test	byte [di+BUFFINFO.buf_flags],buf_dirty ;Buffer dirty?
	jz	short bufq4		; -no, jump.
	call	DEC_DIRTY_COUNT		; -yes, decrement dirty count.
bufq4:
	;mov	word [di+4],20FFh
	mov     word [di+BUFFINFO.buf_ID],((buf_visit<<8)|0FFh)

	call	SCANPLACE
	jmp     short bufq6
bufq5: 
	mov     di,[di]
	;mov	di,[di+BUFFINFO.buf_next]
bufq6: 
	cmp	di,[ss:FIRST_BUFF_ADDR]	;Scanned entire buffer queue?
	jne	short _bufq		; --no, go do next buffer.
	
	;RestoreReg <cx,bx>
	pop	cx
	pop	bx
	retn

;EndProc DskWrtBufPurge

;Break   <DIV32 -- PERFORM 32 BIT DIVIDE>
;----------------------------------------------------------------------------
;
; Procedure Name : DIV32
;
; Inputs:
;       DX:AX = 32 bit dividend   BX= divisor
; Function:
;       Perform 32 bit division:  DX:AX/BX = CX:AX + DX (rem.)
; Outputs:
;       CX:AX = quotient , DX= remainder
; Uses:
;       All registers except AX,CX,DX preserved.
;----------------------------------------------------------------------------
;M039: DIV32 optimized for divisor of 512 (common sector size).

; 04/05/2019 - Retro DOS v4.0
; DOSCODE:7C94h (MSDOS 6.21, MSDOS.SYS)

; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:7C5Ah (MSDOS 5.0, MSDOS.SYS) 

DIV32:
	cmp	bx,512
	jne	short div5

	mov	cx,dx
	mov	dx,ax           ; CX:AX = Dividend
	and	dx,(512-1)      ; DX = Remainder
	mov	al,ah
	mov	ah,cl
	mov	cl,ch
	xor	ch,ch
	shr	cx,1
	rcr	ax,1
	retn
div5:	
	mov	cx,ax
	mov	ax,dx
	xor	dx,dx
	div	bx              ; 0:AX/BX
	xchg	cx,ax
	div	bx              ; DX:AX/BX
	retn

;Break   <SHR32 -- PERFORM 32 BIT SHIFT RIGHT>
;----------------------------------------------------------------------------
;
; Procedure Name : SHR32
;
; Inputs:
;	DX:AX = 32 bit sector number
; Function:
;       Perform 32 bit shift right
; Outputs:
;	AX = cluster number
;	ZF = 1 if no error
;	   = 0 if error (cluster number > 64k)
; Uses:
;       DX,CX
;---------------------------------------------------------------------------
; M017	- SHR32 rewritten for better performance
; M039	- Additional optimization

; 04/05/2019 - Retro DOS v4.0
; DOSCODE:7CBBh (MSDOS 6.21, MSDOS.SYS)
; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:7C81h (MSDOS 5.0, MSDOS.SYS) 

SHR32:
	;mov	cl,[es:bp+5]
	mov	cl,[ES:BP+DPB.CLUSTER_SHIFT]
	xor	ch,ch	    ;ZF=1
	jcxz	norota

rotashft2:
	shr	dx,1	    ;ZF reflects state of DX.
	rcr	ax,1	    ;ZF not affected.
	loop	rotashft2
norota:
	retn

;============================================================================
; DIR.ASM, MSDOS 6.0, 1991
;============================================================================
; 27/07/2018 - Retro DOS v3.0
; 19/05/2019 - Retro DOS v4.0 

;	TITLE	DIR - Directory and path cracking
;	NAME	Dir

;Break	<FINDENTRY -- LOOK FOR AN ENTRY>
;---------------------------------------------------------------------------
;
; Procedure Name : FINDENTRY,SEARCH
;
; Inputs:
;	[THISDPB] set
;	[SECCLUSPOS] = 0
;	[DIRSEC] = Starting directory sector number
;	[CLUSNUM] = Next cluster of directory
;	[CLUSFAC] = Sectors/Cluster
;	[NAME1] = Name to look for
; Function:
;	Find file name in disk directory.
;	"?" matches any character.
; Outputs:
;	Carry set if name not found
;	ELSE
;	Zero set if attributes match (always except when creating)
;	AH = Device ID (bit 7 set if not disk)
;	[THISDPB] = Base of drive parameters
;	DS = DOSGROUP
;	ES = DOSGROUP
;	[CURBUF+2]:BX = Pointer into directory buffer
;	[CURBUF+2]:SI = Pointer to First Cluster field in directory entry
;	[CURBUF] has directory record with match
;	[NAME1] has file name
;	[LASTENT] is entry number of the entry
; All other registers destroyed.
;----------------------------------------------------------------------------

;hkn; called from rename.asm and dir2.asm. DS must be already set up at
;hkn; this point.

SEARCH:
	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; DOSCODE:7C90h (MSDOS 5.0, MSDOS.SYS) 

	; 19/05/2019 - Retro DOS v4.0
	; DOSCODE:7CCA (MSDOS 6.21, MSDOS.SYS)

	; 27/07/2018 - Retro DOS v3.0
	; IBMDOS.COM (MSDOS 3.3) - Offset 45B3h 
	; 15/03/2018 - Retro DOS v2.0

	; 24/01/2024

	;entry	FindEntry
FINDENTRY:
	call	STARTSRCH
	MOV	AL,[ATTRIB]
	;and	al,9Eh
	AND	AL,~attr_ignore		; Ignore useless bits
	;cmp	al,8
	CMP	AL,attr_volume_id	; Looking for vol ID only ?
	JNZ	short NOTVOLSRCH	; No
	CALL	SETROOTSRCH		; Yes force search of root
NOTVOLSRCH:
	CALL	GETENTRY
	;JNC	short SRCH
	;JMP	SETESRET
	; 24/01/2024
	jc	short SETESRET

	;entry	Srch
SRCH:
	PUSH	DS
	MOV	DS,[CURBUF+2]

;	(DS:BX) = directory entry address

	mov	ah,[BX]
	;MOV	AH,[BX+dir_entry.dir_name] ; mov ah,[bx+0]
	OR	AH,AH			; End of directory?
	JZ	short FREE

;hkn; SS override
	CMP	AH,[SS:DELALL]		; Free entry?
	JZ	short FREE
	;test	byte [bx+0Bh],8
	TEST	byte [BX+dir_entry.dir_attr],attr_volume_id
					; Volume ID file?
	JZ	short CHKFNAM 		; NO

;hkn; SS override
	INC	BYTE [SS:VOLID]
CHKFNAM:
;	Context ES
	MOV	SI,SS
	MOV	ES,SI
	MOV	SI,BX

;hkn; NAME1 is in DOSDATA
	MOV	DI,NAME1
;;;;; 7/29/86

;hkn; SS override for NAME1
	;CMP	BYTE [SS:NAME1],0E5H	; special char check
	;JNZ	short NO_E5
	;MOV	BYTE [SS:NAME1],05H
	; 22/09/2023
	cmp	byte [es:di],0E5h
	jnz	short NO_E5
	mov	byte [es:di],05h
NO_E5:
;;;;; 7/29/86
	CALL	MetaCompare
	JZ	short FOUND
	POP	DS

	;entry	NEXTENT
NEXTENT:
	LES	BP,[THISDPB]
	CALL	NEXTENTRY
	JNC	short SRCH
	;JMP	SHORT SETESRET
	; 24/01/2024
SETESRET:
	PUSH	SS
	POP	ES
	retn
FREE:
	POP	DS
	MOV	CX,[LASTENT]
	CMP	CX,[ENTFREE]
	JAE	short TSTALL
	MOV	[ENTFREE],CX
TSTALL:
	CMP	AH,[DELALL]		; At end of directory?
NEXTENTJ:
	je	short NEXTENT 		; No - continue search
	MOV	[ENTLAST],CX
	STC
	JMP	SHORT SETESRET

FOUND:
; We have a file with a matching name. We must now consider the attributes:
; ATTRIB	Action
; ------	------
; Volume_ID	Is Volume_ID in test?
; Otherwise	If no create then Is ATTRIB+extra superset of test?
;		If create then Is ATTRIB equal to test?

	MOV	CH,[SI] 		; Attributes of file
	POP	DS
	MOV	AH,[ATTRIB]		; Attributes of search
	;and	ah,9Eh
	AND	AH,~attr_ignore
	;lea	si,[si+15]
	LEA	SI,[SI+dir_entry.dir_first-dir_entry.dir_attr]
					; point to first cluster field
	;test	ch,8
	TEST	CH,attr_volume_id	; Volume ID file?
	JZ	short check_one_volume_id ; Nope check other attributes
	;test	ah,8
	TEST	AH,attr_volume_id	; Can we find Volume ID?
	;JZ	short NEXTENTJ		; Nope, (not even $FCB_CREATE)
	; 16/12/2022
	jz	short NEXTENT ; 19/05/2019
	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;JZ	short NEXTENTJ
	XOR	AH,AH			; Set zero flag for $FCB_CREATE
	JMP	SHORT RETFF		; Found Volume ID
check_one_volume_id:
	;CMP	ah,8
	CMP	AH,attr_volume_id	; Looking only for Volume ID?
	;JZ	short NEXTENTJ		; Yes, continue search
	; 16/12/2022
	je	short NEXTENT ; 19/05/2019
	;JZ	short NEXTENTJ
	CALL	MatchAttributes
	JZ	SHORT RETFF
	TEST	BYTE [CREATING],-1	; Pass back mismatch if creating
	; 16/12/2022
	;JZ	short NEXTENTJ		; Otherwise continue searching
	jz	short NEXTENT ; 19/05/2019
RETFF:
	LES	BP,[THISDPB]
	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;MOV	AH,[ES:BP+DPB.DRIVE]  ; mov ah,[es:bp+0]
	; 15/12/2022
	MOV	AH,[ES:BP]
;SETESRET:
	;PUSH	SS
	;POP	ES
	;retn
	; 24/01/2024
	jmp	short SETESRET

;----------------------------------------------------------------------------
;
; Procedure Name : MetaCompare
;
; Inputs:
;	DS:SI -> 11 character FCB style name NO '?'
;	    Typically this is a directory entry. It MUST be in upper case
;	ES:DI -> 11 character FCB style name with possible '?'
;	    Typically this is a FCB or SFT. It MUST be in upper case
; Function:
;	Compare FCB style names allowing for ? match to any char
; Outputs:
;	Zero if match else NZ
; Destroys CX,SI,DI all others preserved
;----------------------------------------------------------------------------

	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; DOSCODE:7D3Fh (MSDOS 5.0, MSDOS.SYS) 

MetaCompare:
	MOV	CX,11
WILDCRD:
	REPE	CMPSB
	JZ	short MetaRet 		; most of the time we will fail.
CHECK_META:
	CMP	BYTE [ES:DI-1],"?"
	JZ	short WILDCRD
MetaRet:
 	retn				; Zero set, Match

;Break	<NEXTENTRY -- STEP THROUGH DIRECTORY>
;----------------------------------------------------------------------------
;
; Procedure Name : NEXTENTRY
;
; Inputs:
;	Same as outputs of GETENTRY, above
; Function:
;	Update BX, and [LASTENT] for next directory entry.
;	Carry set if no more.
;----------------------------------------------------------------------------

NEXTENTRY:
	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; DOSCODE:7D4Eh (MSDOS 5.0, MSDOS.SYS) 

	; 19/05/2019 - Retro DOS v4.0
	; DOSCODE:7D88h (MSDOS 6.21, MSDOS.SYS)

	; 27/07/2018 - Retro DOS v3.0
	; IBMDOS.COM (MSDOS 3.3) - Offset 4671h 
	; 15/03/2018 - Retro DOS v2.0

	MOV	AX,[LASTENT]
	CMP	AX,[ENTLAST]
	JZ	short NONE
	INC	AX
	;ADD	BX,32
	LEA	BX,[BX+32]
	CMP	BX,DX
	; 21/11/2022 - MSDOS 5.0 MSDOS.SYS (DOSCODE:7D5Dh)
	;JB	short HAVIT ; MSDOS 6.0 src (dir.asm)
	; 16/12/2022
	jne	short HAVIT ; MSDOS 6.21 (DOSCODE:7D97h)
	MOV	BL,[SECCLUSPOS]
	INC	BL
	CMP	BL,[CLUSFAC]
	JB	short SAMECLUS
	MOV	BX,[NXTCLUSNUM]
	call	IsEOF
	JAE	short NONE
	; 23/07/2019
	CMP	BX,2
	;JB	short NONE
	;JMP	short GETENT
	; 16/12/2022
	jnb	short GETENT
	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;JB	short NONE
	;JMP	short GETENT
NONE:
	STC
	retn
HAVIT:
	MOV	[LASTENT],AX
	CLC
nextentry_retn:
	retn
SAMECLUS:
	MOV	[SECCLUSPOS],BL
	MOV	[LASTENT],AX
	PUSH	DS
	LDS	DI,[CURBUF]
	; 19/05/2019
	; MSDOS 6.0
	;;mov	dx,[di+8]
	; 23/09/2023
	;MOV	DX,[DI+BUFFINFO.buf_sector+2]	;AN000; >32mb
;hkn; SS override
	;MOV	[SS:HIGH_SECTOR],DX 		;AN000; >32mb
	; 23/09/2023
	mov	si,[di+BUFFINFO.buf_sector+2]	
	
	;mov	dx,[di+6]
	MOV	DX,[DI+BUFFINFO.buf_sector]	;AN000; >32mb
	;inc	dx ; MSDOS 3.3
	; MSDOS 6.0
	;ADD	DX,1				;AN000; >32mb
	;ADC	word [SS:HIGH_SECTOR],0 	;AN000; >32mb
	; 23/09/2023
	inc	dx
	jnz	short nextexntry_fc
	inc	si
	;inc	word [SS:HIGH_SECTOR]
nextexntry_fc:
	; 23/09/2023
	mov	[SS:HIGH_SECTOR],si
	; MSDOS 3.3 & MSDOS 6.0
	POP	DS
	call	FIRSTCLUSTER
	XOR	BX,BX
	JMP	short SETENTRY

;----------------------------------------------------------------------------
;
; Procedure Name : GETENTRY
;
; Inputs:
;	[LASTENT] has directory entry
;	ES:BP points to drive parameters
;	[DIRSEC],[CLUSNUM],[CLUSFAC],[ENTLAST] set for DIR involved
; Function:
;	Locates directory entry in preparation for search
;	GETENT provides entry for passing desired entry in AX
; Outputs:
;	[CURBUF+2]:BX = Pointer to next directory entry in CURBUF
;	[CURBUF+2]:DX = Pointer to first byte after end of CURBUF
;	[LASTENT] = New directory entry number
;	[NXTCLUSNUM],[SECCLUSPOS] set via DIRREAD
;	Carry set if error (currently user FAILed to I 24)
;----------------------------------------------------------------------------

	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
GETENTRY:
	; 27/07/2018 - Retro DOS v3.0
	MOV	AX,[LASTENT]

	;entry	GETENT
GETENT:
	MOV	[LASTENT],AX
;
; Convert the entry number in AX into a byte offset from the beginning of the
; directory.
;
	mov	cl,5			; shift left by 5 = mult by 32
	rol	ax,cl			; keep hight order bits
	mov	dx,ax
	; 19/05/2019 - Retro DOS v4.0
	;and	ax,0FFE0h
	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;and	ax,~(32-1)		; mask off high order bits
	; 16/12/2022
	and	al,0E0h ; ~31
	and	dx,1Fh
	;and	dx,32-1			; mask off low order bits
;
; DX:AX contain the byte offset of the required directory entry from the
; beginning of the directory. Convert this to a sector number. Round the
; sector size down to a multiple of 32.
;
	;mov	bx,[es:bp+2]
	MOV	BX,[ES:BP+DPB.SECTOR_SIZE]
	and	bl,0E0h
	;AND	BL,255-31		; Must be multiple of 32
	DIV	BX
	MOV	BX,DX			; Position within sector
	PUSH	BX
	call	DIRREAD
	POP	BX
	;retc
	jc	short nextentry_retn	
SETENTRY:
	MOV	DX,[CURBUF]
	;add	dx,16 ; MSDOS 3.3
	;add	dx,20 ; MSDOS 6.0 
	ADD	DX,BUFINSIZ
	ADD	BX,DX
	;add	dx,[es:bp+2]
	ADD	DX,[ES:BP+DPB.SECTOR_SIZE]  ; Always clears carry
	; 29/12/2022
	; MSDOS 6.21 MSDOS.SYS contains a 'CLC' here, at DOSCODE:7E15h
	clc
	retn

;Break	<SETDIRSRCH SETROOTSRCH -- Set Search environments>
;----------------------------------------------------------------------------
;
; Procedure Name : SETDIRSRCH,SETROOTSRCH
;
; Inputs:
;	BX cluster number of start of directory
;	ES:BP Points to DPB
;	DI next cluster number from fastopen extended info. DOS 3.3 only
; Function:
;	Set up a directory search
; Outputs:
;	[DIRSTART] = BX
;	[CLUSFAC],[CLUSNUM],[SECCLUSPOS],[DIRSEC] set
;	Carry set if error (currently user FAILed to I 24)
; destroys AX,DX,BX
;----------------------------------------------------------------------------

	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
SETDIRSRCH:
	OR	BX,BX
	JZ	short SETROOTSRCH
	MOV	[DIRSTART],BX
	;mov	al,[es:bp+4]
	MOV	AL,[ES:BP+DPB.CLUSTER_MASK]
	INC	AL
	MOV	[CLUSFAC],AL

; DOS 3.3 for FastOPen	F.C. 6/12/86
	;SAVE	<SI>
	push	si
	;test	byte [FastOpenFlg],2
	TEST	byte [FastOpenFlg],Lookup_Success
	JNZ	short UNP_OK

; DOS 3.3 for FastOPen	F.C. 6/12/86
	;invoke	UNPACK
	call	UNPACK
	JNC	short UNP_OK
	;RESTORE <SI>
	pop	si
	;return
	retn

UNP_OK:
	MOV	[CLUSNUM],DI
	MOV	DX,BX
	XOR	BL,BL
	MOV	[SECCLUSPOS],BL
	;invoke	FIGREC
	call	FIGREC
	;RESTORE <SI>
	pop	si
	
	; 19/05/2019 - Retro DOS v4.0

	; MSDOS 6.0
	;PUSH	DX			   ;AN000; >32mb
	;MOV	DX,[HIGH_SECTOR]	   ;AN000; >32mb
	;MOV	[DIRSEC+2],DX		   ;AN000; >32mb
	;POP	DX			   ;AN000; >32mb

	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;push	dx
	;mov	dx,[HIGH_SECTOR]
	;mov	[DIRSEC+2],dx
	;pop	dx
	;MOV	[DIRSEC],dx
	; 16/12/2022
	mov	ax,[HIGH_SECTOR]
	mov	[DIRSEC+2],AX
	MOV	[DIRSEC],DX

	; 16/12/2022
	; cf=0 (at the return of FIGREC)
	;CLC
	retn

	;entry	SETROOTSRCH
SETROOTSRCH:
	XOR	AX,AX
	MOV	[DIRSTART],AX
	; 22/09/2023
	mov	[DIRSEC+2],ax ; 0
	MOV	[SECCLUSPOS],AL
	DEC	AX
	MOV	[CLUSNUM],AX
	;mov	ax,[es:bp+0Bh]
	MOV	AX,[ES:BP+DPB.FIRST_SECTOR]
	; 19/05/2019
	;;mov	dx,[es:bp+10h] ; MSDOS 3.3
	;mov	dx,[es:bp+11h] ; MSDOS 6.0
	MOV	DX,[ES:BP+DPB.DIR_SECTOR]
	SUB	AX,DX
	MOV	[CLUSFAC],AL
	MOV	[DIRSEC],DX		      ;F.C. >32mb
	; 22/09/2023
	; MSDOS 6.0
	;MOV	WORD [DIRSEC+2],0	      ;F.C. >32mb
	CLC
	retn

;============================================================================
; DIR2.ASM, MSDOS 6.0, 1991
;============================================================================
; 27/07/2018 - Retro DOS v3.0
; 19/05/2019 - Retro DOS v4.0 

;	TITLE	DIR2 - Directory and path cracking
;	NAME	Dir2

;Break	<GETPATH -- PARSE A WFP>
;----------------------------------------------------------------------------
;
; Procedure Name : GETPATH
;
; Inputs:
;	[WFP_START] Points to WFP string ("d:\" must be first 3 chars, NUL
;		terminated; d:/ (note forward slash) indicates a real device).
;	[CURR_DIR_END] Points to end of Current dir part of string
;		( = -1 if current dir not involved, else
;		 Points to first char after last "/" of current dir part)
;	[THISCDS] Points to CDS being used
;	[SATTRIB] Is attribute of search, determines what files can be found
;	[NoSetDir] set
;	[THISDPB] set to DPB if disk otherwise garbage.
; Function:
;	Crack the path
; Outputs:
;	Sets EXTERR_LOCUS = errLOC_Disk if disk file
;	Sets EXTERR_LOCUS = errLOC_Unk if char device
;	ID1 field of [THISCDS] updated appropriately
;	[ATTRIB] = [SATTRIB]
;	ES:BP Points to DPB
;	Carry set if bad path
;	   SI Points to path element causing failure
;	   Zero set
;	      [DIRSTART],[DIRSEC],[CLUSNUM], and [CLUSFAC] are set up to
;	      start a search on the last directory
;	      CL is zero if there is a bad name in the path
;	      CL is non-zero if the name was simply not found
;		 [ENTFREE] may have free spot in directory
;		 [NAME1] is the name.
;		 CL = 81H if '*'s or '?' in NAME1, 80H otherwise
;	   Zero reset
;	      File in middle of path or bad name in path or attribute mismatch
;		or path too long or malformed path
;	ELSE
;	   [CurBuf] = -1 if root directory
;	   [CURBUF] contains directory record with match
;	   [CURBUF+2]:BX Points into [CURBUF] to start of entry
;	   [CURBUF+2]:SI Points into [CURBUF] to dir_first field for entry
;	   AH = device ID
;	      bit 7 of AH set if device SI and BX
;	      will point DOSGROUP relative The firclus
;	      field of the device entry contains the device pointer
;	   [NAME1] Has name looked for
;	   If last element is a directory zero is set and:
;	      [DIRSTART],[SECCLUSPOS],[DIRSEC],[CLUSNUM], and [CLUSFAC]
;	      are set up to start a search on it.
;	      unless [NoSetDir] is non zero in which case the return is
;	      like that for a file (except for zero flag)
;	   If last element is a file zero is reset
;	      [DIRSEC],[CLUSNUM],[CLUSFAC],[NXTCLUSNUM],[SECCLUSPOS],
;	      [LASTENT], [ENTLAST] are set to continue search of last
;	      directory for furthur matches on NAME1 via the NEXTENT
;	      entry point in FindEntry (or GETENT entry in GETENTRY in
;	      which case [NXTCLUSNUM] and [SECCLUSPOS] need not be valid)
; DS preserved, Others destroyed
;---------------------------------------------------------------------------

;hkn; called from delete.asm, finfo.asm, mknode.asm and rename.asm.
;hkn; DS already set up at this point.

	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
GETPATH:
	;mov	word [CREATING],0E500h
	MOV	WORD [CREATING],DIRFREE*256+0 ; Not Creating, not DEL *.*

; Same as GetPath only CREATING and DELALL already set

	;entry	GetPathNoSet
GetPathNoSet:
	;mov	byte [EXTERR_LOCUS],2	
	MOV	byte [EXTERR_LOCUS],errLOC_Disk
	MOV	word [CURBUF],-1	; initial setting

; See if the input indicates a device that has already been detected. If so,
; go build the guy quickly. Otherwise, let findpath find the device.

	MOV	DI,[WFP_START]		; point to the beginning of the name
	;cmp	word [DI+1],5C3Ah
	;CMP	WORD [DI+1],'\' << 8 + ':'
	cmp	word [DI+1],':\'
	JZ	short CrackIt

; Let ChkDev find it in the device list

	ADD	DI,3
	; 18/08/2018
	;MOV	SI,DI			; let CHKDEV see the original name
	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	; 16/12/2022
	;mov	si,di ; not required ! (it is written in CHKDEV proc already!)
	CALL	CHKDEV
	JC	short InternalError

Build_devJ:
	MOV	AL,[SATTRIB]
	MOV	[ATTRIB],AL
	;mov	byte [EXTERR_LOCUS],1
	MOV	byte [EXTERR_LOCUS],errLOC_Unk ; In the particular case of
					; "finding" a char device
					; set LOCUS to Unknown. This makes
					; certain idiotic problems reported
					; by a certain 3 letter OEM go away.

; Take name in name1 and pack it back into where wfp_start points. This
; guarantees wfp_start pointing to a canonical representation of a device.
; We are allowed to do this as GetPath is *ALWAYS* called before entering a
; wfp into the share set.
;
; We copy chars from name1 to wfp_start remembering the position of the last
; non-space seen +1.  This position is kept in DX.

;hkn; SS is DOSDATA
	push	ss
	pop	es

;hkn; NAME1 is in DOSDATA
	mov	si,NAME1
	mov	di,[WFP_START]
	mov	dx,di
	mov	cx,8			; 8 chars in device name
MoveLoop:
	lodsb
	stosb
	cmp	al," "
	jz	short NoSave

	mov	dx,di
NoSave:
	loop	MoveLoop

; DX is the position of the last seen non-space + 1. We terminate the name
; at this point.

	mov	di,dx
	mov	byte [di],0		; end of string
	call	Build_device_ent	; Clears carry sets zero
	INC	AL			; reset zero
	retn

InternalError:
InternalError_loop:
	JMP	short InternalError_loop	; freeze

; Start off at the correct spot. Optimize if the current dir part is valid.

CrackIt:
	MOV	SI,[CURR_DIR_END]	; get current directory pointer
	CMP	SI,-1			; valid?
	JNZ	short LOOK_SING		; Yes, use it.
	LEA	SI,[DI+3]		; skip D:\.
LOOK_SING:
	;mov	byte [ATTRIB],16h
	MOV	byte [ATTRIB],attr_directory+attr_system+attr_hidden
					; Attributes to search through Dirs
	LES	DI,[THISCDS]
	MOV	AX,-1
	;mov	bx,[es:di+73]
	MOV	BX,[ES:DI+curdir.ID]
	MOV	SI,[CURR_DIR_END]

; AX = -1
; BX = cluster number of current directory. THis number is -1 if the media
;      has been uncertainly changed.
; SI = offset in DOSGroup into path to end of current directory text. This
;      may be -1 if no current directory part has been used.

	CMP	SI,AX			; if Current directory is not part
	JZ	short NO_CURR_D		; then we must crack from root
	CMP	BX,AX			; is the current directory cluster valid

; DOS 3.3  6/25/86
	JZ	short NO_CURR_D		; no, crack form the root
	;test	byte [FastOpenFlg],1
	TEST	byte [FastOpenFlg],FastOpen_Set ; for fastopen ?
	JZ	short GOT_SEARCH_CLUSTER	; no
	PUSH	ES			; save registers
	PUSH	DI
	PUSH	CX
	PUSH	word [SI-1]		; save \ and 1st char of next element
	PUSH	SI
	PUSH	BX

	MOV	BYTE [SI-1],0		; call fastopen to look up cur dir info
	MOV	SI,[WFP_START]

;hkn; FastOpenTable, Dir_Info_Buff & FastOpen_Ext_Info are in DOSDATA
	MOV	BX,FastOpenTable
	MOV	DI,Dir_Info_Buff
	MOV	CX,FastOpen_Ext_Info
	;mov	al,1
	MOV	AL,FONC_Look_up
	PUSH	DS
	POP	ES
	;call	far [BX+2]
	CALL	far [BX+fastopen_entry.name_caching]
	JC	short GO_Chk_end1 	;fastopen not installed, or wrong drive.
					; Go to Got_Srch_cluster
	; 29/12/2022
	;CMP	BYTE [SI],0		;fastopen has current dir info?
	;JE	short GO_Chk_end	;yes. Go to got_search_cluster
	;stc
	;jmp	short GO_Chk_end	;Go to No_Curr_D

	cmp	byte [si],1
GO_Chk_end1:	; 29/12/2022
	cmc 
	; [si] = 0 -> cf = 0
	; [si] > 0 -> cf = 1

;GO_Chk_end1:
	; 29/12/2022
	;clc

GO_Chk_end:				; restore registers
	POP	BX
	POP	SI
	POP	word [SI-1]
	POP	CX
	POP	DI
	POP	ES
	JNC	short GOT_SEARCH_CLUSTER ; crack based on cur dir

; DOS 3.3  6/25/86
;
; We must cract the path beginning at the root. Advance pointer to beginning
; of path and go crack from root.

NO_CURR_D:
	MOV	SI,[WFP_START]
	LEA	SI,[SI+3]		; Skip "d:/"
	LES	BP,[THISDPB]		; Get ES:BP
	JMP	short ROOTPATH

; We are able to crack from the current directory part. Go set up for search
; of specified cluster.

GOT_SEARCH_CLUSTER:
	LES	BP,[THISDPB]		; Get ES:BP
	call	SETDIRSRCH
	;JC	short SETFERR
	;JMP	short FINDPATH
	; 16/12/2022
	jnc	short FINDPATH ; 17/08/2018
	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;JC	short SETFERR
	;JMP	short FINDPATH
SETFERR:
	XOR	CL,CL			; set zero
	STC
	retn

;---------------------------------------------------------------------------
;
; Procedure Name : ChkDev
;
; Check to see if the name at DS:DI is a device. Returns carry set if not a
;   device.
; Blasts CX,SI,DI,AX,BX
;---------------------------------------------------------------------------

CHKDEV:
	MOV	SI,DI
	MOV	DI,SS
	MOV	ES,DI

	MOV	DI,NAME1
	MOV	CX,9
TESTLOOP:
	call	GETLET

	CMP	AL,'.'
	JZ	short TESTDEVICE
	call	PATHCHRCMP
	JZ	short NOTDEV
	OR	AL,AL
	JZ	short TESTDEVICE

	STOSB
	LOOP	TESTLOOP
NOTDEV:
	STC
	retn

TESTDEVICE:
	;ADD	CX,2
	; 24/09/2023
	inc	cx
	inc	cx
	MOV	AL,' '
	REP	STOSB
	MOV	AX,SS
	MOV	DS,AX
	;call	DEVNAME
	;retn
	; 18/12/2022
	jmp	DEVNAME

;Break	<ROOTPATH, FINDPATH -- PARSE A PATH>
;----------------------------------------------------------------------------
;
; Procedure Name : ROOTPATH,FINDPATH
;
; Inputs:
;	Same as FINDPATH but,
;	SI Points to asciz string of path which is assumed to start at
;		the root (no leading '/').
; Function:
;	Search from root for path
; Outputs:
;	Same as FINDPATH but:
;	If root directory specified, [CURBUF] and [NAME1] are NOT set, and
;	[NoSetDir] is ignored.
;----------------------------------------------------------------------------

	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; DOSCODE:7F47h (MSDOS 5.0, MSDOS.SYS)

ROOTPATH:
	call	SETROOTSRCH
	; 24/09/2023
	xor	ah,ah
	;CMP	BYTE [SI],0
	cmp	[si],ah ; 0
	JNZ	short FINDPATH

; Root dir specified
	MOV	AL,[SATTRIB]
	MOV	[ATTRIB],AL
	; 24/09/2023
	;XOR	AH,AH			; Sets "device ID" byte, sets zero
					; (dir), clears carry.
	retn

; Inputs:
;	[ATTRIB] Set to get through directories
;	[SATTRIB] Set to find last element
;	ES:BP Points to DPB
;	SI Points to asciz string of path (no leading '/').
;	[SECCLUSPOS] = 0
;	[DIRSEC] = Phys sec # of first sector of directory
;	[CLUSNUM] = Cluster # of next cluster
;	[CLUSFAC] = Sectors per cluster
;	[NoSetDir] set
;	[CURR_DIR_END] Points to end of Current dir part of string
;		( = -1 if current dir not involved, else
;		 Points to first char after last "/" of current dir part)
;	[THISCDS] Points to CDS being used
;	[CREATING] and [DELALL] set
; Function:
;	Parse path name
; Outputs:
;	ID1 field of [THISCDS] updated appropriately
;	[ATTRIB] = [SATTRIB]
;	ES:BP Points to DPB
;	[THISDPB] = ES:BP
;	Carry set if bad path
;	   SI Points to path element causing failure
;	   Zero set
;	      [DIRSTART],[DIRSEC],[CLUSNUM], and [CLUSFAC] are set up to
;	      start a search on the last directory
;	      CL is zero if there is a bad name in the path
;	      CL is non-zero if the name was simply not found
;		 [ENTFREE] may have free spot in directory
;		 [NAME1] is the name.
;		 CL = 81H if '*'s or '?' in NAME1, 80H otherwise
;	   Zero reset
;	      File in middle of path or bad name in path
;		or path too long or malformed path
;	ELSE
;	   [CURBUF] contains directory record with match
;	   [CURBUF+2]:BX Points into [CURBUF] to start of entry
;	   [CURBUF+2]:SI Points to fcb_FIRCLUS field for entry
;	   [NAME1] Has name looked for
;	   AH = device ID
;	      bit 7 of AH set if device SI and BX
;	      will point DOSGROUP relative The firclus
;	      field of the device entry contains the device pointer
;	   If last element is a directory zero is set and:
;	      [DIRSTART],[SECCLUSPOS],[DIRSEC],[CLUSNUM], and [CLUSFAC]
;	      are set up to start a search on it,
;	      unless [NoSetDir] is non zero in which case the return is
;	      like that for a file (except for zero flag)
;	   If last element is a file zero is reset
;	      [DIRSEC],[CLUSNUM],[CLUSFAC],[NXTCLUSNUM],[SECCLUSPOS],
;	      [LASTENT], [ENTLAST] are set to continue search of last
;	      directory for furthur matches on NAME1 via the NEXTENT
;	      entry point in FindEntry (or GETENT entry in GETENTRY in
;	      which case [NXTCLUSNUM] and [SECCLUSPOS] need not be valid)
; Destroys all other registers

	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; DOSCODE:7F58h (MSDOS 5.0, MSDOS.SYS)

    	;entry	FINDPATH
FINDPATH:
	PUSH	ES			; Save ES:BP
	PUSH	SI
	MOV	DI,SI
	MOV	CX,[DIRSTART]		; Get start clus of dir being searched
	CMP	word [CURR_DIR_END],-1
	JZ	short NOIDS		; No current dir part
	CMP	DI,[CURR_DIR_END]
	JNZ	short NOIDS		; Not to current dir end yet
	LES	DI,[THISCDS]
	;mov	[es:di+73],cx
	MOV	[ES:DI+curdir.ID],CX	; Set current directory currency
NOIDS:

; Parse the name off of DS:SI into NAME1. AL = 1 if there was a meta
; character in the string. CX,DI may be destroyed.
;
;	invoke	NAMETRANS
;	MOV	CL,AL
;
; The above is the slow method. The name has *already* been munged by
; TransPath so no special casing needs to be done. All we do is try to copy
; the name until ., \ or 0 is hit.

	MOV	AX,SS
	MOV	ES,AX

;hkn; Name1 is in DOSDATA
	MOV	DI,NAME1
	MOV	AX,'  ' ; 2020h
	STOSB
	STOSW
	STOSW
	STOSW
	STOSW
	STOSW

;hkn; Name1 is in DOSDATA
	MOV	DI,NAME1
	XOR	AH,AH			; bits for CL
GetNam:
	; 19/05/2019 - Retro DOS v4.0
	;INC	CL ; ?*! ; MSDOS 6.0	;AN000; KK increment volid count

	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	; 16/12/2022
	;inc	cl ; not required !	
	
	LODSB
	CMP	AL,'.'	; 2Eh
	JZ	short _SetExt
	OR	AL,AL
	JZ	short _GetDone
	CMP	AL,'\'	; 5Ch
	JZ	short _GetDone
	CMP	AL,'?'	; 3Fh
	JNZ	short StoNam
	OR	AH,1
StoNam: 
	STOSB
	JMP	short GetNam
_SetExt:
	MOV	DI,NAME1+8
GetExt:
	LODSB
	OR	AL,AL
	JZ	short _GetDone
	CMP	AL,'\'
	JZ	short _GetDone
	CMP	AL,'?'
	JNZ	short StoExt
	OR	AH,1
StoExt: 
	STOSB
	JMP	short GetExt
_GetDone:
	DEC	SI
	MOV	CL,AH  ; 0 or 1 ; 29/12/2022
	OR	CL,80H
	POP	DI			; Start of this element
	POP	ES			; Restore ES:BP
	CMP	SI,DI
	JNZ	short check_device
	JMP	_BADPATH		; NUL parse (two delims most likely)
check_device:
	PUSH	SI			; Start of next element
	;MOV	AL,[SI]
	;OR	AL,AL
	; 23/09/2023
	cmp	byte [si],0
	JNZ	short NOT_LAST

; for last element of the path switch to the correct search attributes

	MOV	BH,[SATTRIB]
	MOV	[ATTRIB],BH

NOT_LAST:

; check name1 to see if we have a device...

	PUSH	ES			; Save ES:BP

;hkn; SS is DOSDATA
	;context ES
	push	ss
	pop	es
	call	DEVNAME 		; blast BX
	POP	ES			; Restore ES:BP
	JC	short FindFile		; Not a device
	OR	AL,AL			; Test next char again
	JZ	short GO_BDEV
	JMP	FILEINPATH		; Device name in middle of path

GO_BDEV:
	POP	SI			; Points to NUL at end of path
	JMP	Build_devJ

FindFile:
;;;; 7/28/86
	CMP	BYTE [NAME1],0E5H	; if 1st char = E5
	JNZ	short NOE5		; no
	MOV	BYTE [NAME1],05H	; change it to 05
NOE5:
;;;; 7/28/86
	PUSH	DI			; Start of this element
	PUSH	ES			; Save ES:BP
	PUSH	CX			; CL return from NameTrans
;DOS 3.3 FastOPen 6/12/86 F.C.

	CALL	LookupPath		; call fastopen to get dir entry
	JNC	short DIR_FOUND		; found dir entry

;DOS 3.3 FastOPen 6/12/86 F.C.
	call	FINDENTRY
DIR_FOUND:
	POP	CX
	POP	ES
	POP	DI
	JNC	short LOAD_BUF
	JMP	BADPATHPOP

LOAD_BUF:
	LDS	DI,[CURBUF]
	;test	byte [bx+0Bh],10h
	TEST	BYTE [BX+dir_entry.dir_attr],attr_directory
	JNZ	short GO_NEXT 		; DOS 3.3
	JMP	FILEINPATH		; Error or end of path

; if we are not setting the directory, then check for end of string

GO_NEXT:
;hkn; SS override
	CMP	BYTE [SS:NoSetDir],0
	JZ	short SetDir
	MOV	DX,DI			; Save pointer to entry
	MOV	CX,DS

;hkn; SS is DOSDATA
	;context DS
	push	ss
	pop	ds
	POP	DI			; Start of next element
	; 19/05/2019 - Retro DOS v4.0
	; MSDOS 6.0
	TEST	byte [FastOpenFlg],FastOpen_Set ;only DOSOPEN can take advantage of
	JZ	short _nofast			; the FastOpen
	TEST	byte [FastOpenFlg],Lookup_Success ; Lookup just happened
	JZ	short _nofast			; no
	MOV	DI,[Next_Element_Start]	; no need to insert it again
_nofast:
	CMP	BYTE [DI],0
	;;JNZ	short NEXT_ONE		; DOS 3.3
	;;JMP	_SETRET  ; retn		; Got it
	;retn	; 05/09/2018
	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;jmp	_SETRET
	; 16/12/2022
	jz	short _SETRET

NEXT_ONE:
	PUSH	DI			; Put start of next element back on stack
	MOV	DI,DX
	MOV	DS,CX			; Get back pointer to entry
SetDir:
	MOV	DX,[SI] 		; Dir_first

;DOS 3.3 FastOPen 6/12/86 F.C.
	PUSH	DS		      ; save [curbuf+2]
;hkn; SS is DOSDATA
	push	ss
	pop	ds		      ; set DS Dosgroup
	;test	byte [FastOpenFlg],2
	TEST	byte [FastOpenFlg],Lookup_Success
	JZ	short DO_NORMAL	      ; fastopen not in memory or path not
	MOV	BX,DX		      ; not found
	MOV	DI,[CLUSNUM]	      ; clusnum was set in LookupPath
	PUSH	AX		      ; save device id (AH)
	call	SETDIRSRCH
	POP	AX		      ; restore device id (AH)
	ADD	SP,2		      ; pop ds in stack
	JMP	short FAST_OPEN_SKIP

	; 16/12/2022
_SETRET:
	retn

DO_NORMAL:
	POP	DS			; DS = [curbuf + 2]
;DOS 3.3 FastOPen 6/12/86 F.C.

	SUB	BX,DI			; Offset into sector of start of entry
	SUB	SI,DI			; Offset into sector of dir_first
	PUSH	BX
	PUSH	AX
	PUSH	SI
	PUSH	CX
	;push	word [di+6]
	PUSH	WORD [DI+BUFFINFO.buf_sector]	;AN000;>32mb
	; 19/05/2019
	; MSDOS 6.0
	;push	word [di+8]
	PUSH	WORD [DI+BUFFINFO.buf_sector+2]	;AN000;>32mb
	MOV	BX,DX

;hkn; SS is DOSDATA
	;context DS
	push	ss
	pop	ds
	;invoke	SETDIRSRCH		; This uses UNPACK which might blow
	call	SETDIRSRCH		; the entry sector buffer
	; 19/05/2019
	; MSDOS 6.0
	POP	word [HIGH_SECTOR]
	POP	DX
	JC	short SKIP_GETB
	; 22/09/2023
	;;mov	byte [ALLOWED],18h
	;MOV	byte [ALLOWED],Allowed_RETRY+Allowed_FAIL ; *
	;XOR	AL,AL ; *
	;;invoke GETBUFFR		; Get the entry buffer back
	;call	GETBUFFR
	call	GETBUFFER ; * ; pre-read
SKIP_GETB:
	POP	CX
	POP	SI
	POP	AX
	POP	BX
	JNC	short SET_THE_BUF
	POP	DI			; Start of next element
	MOV	SI,DI			; Point with SI
	JMP	SHORT _BADPATH

SET_THE_BUF:
	call	SET_BUF_AS_DIR
	MOV	DI,[CURBUF]
	ADD	SI,DI			; Get the offsets back
	ADD	BX,DI
; DOS 3.3 FastOpen 6/12/86  F.C.
FAST_OPEN_SKIP:
	POP	DI			; Start of next element
	CALL	InsertPath		; insert dir entry info
; DOS 3.3 FastOpen 6/12/86  F.C.
	MOV	AL,[DI]
	OR	AL,AL
	JZ	short _SETRET		; At end
	INC	DI			; Skip over "/"
	MOV	SI,DI			; Point with SI
	call	PATHCHRCMP
	JNZ	short find_bad_name	; oops
	JMP	FINDPATH		; Next element

find_bad_name:
	DEC	SI			; Undo above INC to get failure point
_BADPATH:
	XOR	CL,CL			; Set zero
	JMP	SHORT BADPRET

FILEINPATH:
	POP	DI			; Start of next element

;hkn; SS is DOSDATA
	;context DS			; Got to from one place with DS gone
	push	ss
	pop	ds

; DOS 3.3 FastOpen
	;test	byte [FastOpenFlg],1
	TEST	byte [FastOpenFlg],FastOpen_Set  ; do this here is we don't want to
	JZ	short NO_FAST		; device info to fastopen
	;test	byte [FastOpenFlg],2
	TEST	byte [FastOpenFlg],Lookup_Success
	JZ	short NO_FAST
	MOV	DI,[Next_Element_Start]  ; This takes care of one time lookup
					 ; success
NO_FAST:
; DOS 3.3 FastOpen
	MOV	AL,[DI]
	OR	AL,AL
	JZ	short INCRET
	MOV	SI,DI			; Path too long
	JMP	SHORT BADPRET

INCRET:
; DOS 3.3 FasOpen 6/12/86  F.C.

	CALL   InsertPath		; insert dir entry info

; DOS 3.3 FasOpen 6/12/86  F.C.
	INC	AL			; Reset zero
	; 16/12/2022	
;_SETRET:
	retn

BADPATHPOP:
	POP	SI			; Start of next element
	MOV	AL,[SI]
	MOV	SI,DI			; Start of bad element
	OR	AL,AL			; zero if bad element is last, non-zero if path too long
BADPRET:
	MOV	AL,[SATTRIB]
	MOV	[ATTRIB],AL		; Make sure return correct
	STC
	retn

;Break	<STARTSRCH -- INITIATE DIRECTORY SEARCH>
;---------------------------------------------------------------------------
;
; Procedure Name : STARTSRCH
;
; Inputs:
;	[THISDPB] Set
; Function:
;	Set up a search for GETENTRY and NEXTENTRY
; Outputs:
;	ES:BP = Drive parameters
;	Sets up LASTENT, ENTFREE=ENTLAST=-1, VOLID=0
; Destroys ES,BP,AX
;--------------------------------------------------------------------------

STARTSRCH:
	LES	BP,[THISDPB]
	XOR	AX,AX
	MOV	[LASTENT],AX
	MOV	[VOLID],AL		; No volume ID found
	DEC	AX
	MOV	[ENTFREE],AX
	MOV	[ENTLAST],AX
	retn

;BREAK <MatchAttributes - the final check for attribute matching>
;----------------------------------------------------------------------------
; Procedure Name : MatchAttributes
;
; Input:    [Attrib] = attribute to search for
;	    CH = found attribute
; Output:   JZ <match>
;	    JNZ <nomatch>
; Registers modified: noneski
;----------------------------------------------------------------------------

MatchAttributes:
	PUSH	AX

;hkn; SS override
	MOV	AL,[ss:ATTRIB]		; AL <- SearchSet
	NOT	AL			; AL <- SearchSet'
	AND	AL,CH			; AL <- SearchSet' and FoundSet
	;and	al,16h
	AND	AL,attr_all	; AL <- SearchSet' and FoundSet and Important
;
; the result is non-zero if an attribute is not in the search set
; and in the found set and in the important set. This means that we do not
; have a match. Do a JNZ <nomatch> or JZ <match>
;
	POP	AX
	retn

; 19/05/2019 - Retro DOS v4.0
; DOSCODE:8148h (MSDOS 6.21, MSDOS.SYS)

; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:810Dh (MSDOS 5.0, MSDOS.SYS)

;Break <DevName - Look for name of device>
;---------------------------------------------------------------------------
;
; Procedure Name : DevName
;
; Inputs:
;	DS,ES:DOSDATA
;	Filename in NAME1
;	ATTRIB set so that we can error out if looking for Volume IDs
; Function:
;	Determine if file is in list of I/O drivers
; Outputs:
;	Carry set if not a device
;	ELSE
;	Zero flag set
;	BH = Bit 7,6 = 1, bit 5 = 0 (cooked mode)
;	     bits 0-4 set from low byte of attribute word
;	DEVPT = DWORD pointer to Device header of device
; BX destroyed, others preserved
;---------------------------------------------------------------------------

DEVNAME:
	; 28/07/2018 - Retro DOS v3.0
	; IBMDOS.COM (MSDOS 3.3) - Offset 49FBh

	PUSH	SI
	PUSH	DI
	PUSH	CX
	PUSH	AX

; E5 special code
	PUSH	WORD [NAME1]
	CMP	byte [NAME1],5
	JNZ	short NOKTR
	MOV	byte [NAME1],0E5h
NOKTR:
	;test	byte [ATTRIB],8
	TEST	byte [ATTRIB],attr_volume_id
					; If looking for VOL id don't find devs
	JNZ	short RET31

;hkn; NULDEV is in DOSDATA
	MOV	SI,NULDEV
LOOKIO:
	; 21/11/2022
	;test	byte [SI+SYSDEV.ATT+1],80h
	; 17/12/2022
	;test	byte [si+5],80h
	test	byte [SI+SYSDEV.ATT+1],(DEVTYP>>8)
	;;test	word [si+4],8000h
	;TEST	word [SI+SYSDEV.ATT],DEVTYP
	JZ	short SKIPDEV 		; Skip block devices (NET and LOCAL)
	MOV	AX,SI
	;add	si,10
	ADD	SI,SYSDEV.NAME

;hkn; NAME1 is in DOSDATA
	MOV	DI,NAME1
	MOV	CX,4			; All devices are 8 letters
	REPE	CMPSW			; Check for name in list
	MOV	SI,AX
	JZ	short IOCHK		; Found it?
SKIPDEV:
	LDS	SI,[SI]			; Get address of next device
	CMP	SI,-1			; At end of list?
	JNZ	short LOOKIO
RET31:	
	STC				; Not found
RETNV:	
	MOV	CX,SS
	MOV	DS,CX

	POP	WORD [NAME1]
	POP	AX
	POP	CX
	POP	DI
	POP	SI
	RETN

IOCHK:
;hkn; SS override for DEVPT
	MOV	[SS:DEVPT+2],DS		; Save pointer to device
	;mov	bh,[si+4]
	MOV	BH,[SI+SYSDEV.ATT]
	OR	BH,0C0h
	and	bh,0DFh
	;AND	BH,~(020h)		; Clears Carry
	MOV	[SS:DEVPT],SI
	JMP	short RETNV

;BREAK <Build_device_ent - Make a Directory entry>
;---------------------------------------------------------------------------
; Procedure Name : Build_device_ent
;
; Inputs:
;	[NAME1] has name
;	BH is attribute field (supplied by DEVNAME)
;	[DEVPT] points to device header (supplied by DEVNAME)
; Function:
;	Build a directory entry for a device at DEVFCB
; Outputs:
;	BX points to DEVFCB
;	SI points to dir_first field
;	AH = input BH
;	AL = 0
;	dir_first = DEVPT
;	Zero Set, Carry Clear
; DS,ES,BP preserved, others destroyed
;--------------------------------------------------------------------------

Build_device_ent:
	MOV	AX,"  " ; 2020h

;hkn; DEVFCB is in DOSDATA
	MOV	DI,DEVFCB+8		; Point to extent field

;	Fill dir_ext  BUGBUG - use ERRNZs for this stuff!

	STOSW
	STOSB				; Blank out extent field
	;mov	al,40h
	MOV	AL,attr_device

;	Fill Dir_attr

	STOSB				; Set attribute field
	XOR	AX,AX
	MOV	CX,10

; Fill dir_pad

	REP	STOSW			; Fill rest with zeros
	call	DATE16

;hkn; DEVFCB is in DOSDATA
	MOV	DI,DEVFCB+dir_entry.dir_time ; 09/08/2018
	XCHG	AX,DX

; Fill dir_time

	STOSW
	XCHG	AX,DX

; Fill dir_date

	STOSW
	MOV	SI,DI			; SI points to dir_first field
	MOV	AX,[DEVPT]

; Fill dir_first

	STOSW				; Dir_first points to device
	MOV	AX,[DEVPT+2]
;
; Fill dir_size_l
;
	STOSW
	MOV	AH,BH			; Put device atts in AH

;hkn; DEVFCB is in DOSDATA
	MOV	BX,DEVFCB
	XOR	AL,AL			; Set zero, clear carry
	retn

;Break	<ValidateCDS - given a CDS, validate the media and the current directory>
;----------------------------------------------------------------------------
;
;   ValidateCDS - Get current CDS. Splice it. Call FatReadCDS to check
;   media. If media has been changed, do DOS_Chdir to validate path.
;   If invalid, reset original CDS to root.
;
;   Inputs:	ThisCDS points to CDS of interest
;		SS:DI points to temp buffer
;   Outputs:	The current directory string is validated on the appropriate
;		    drive
;		ThisDPB changed
;		ES:DI point to CDS
;		Carry set if error (currently user FAILed to I 24)
;   Registers modified: all
;----------------------------------------------------------------------------

	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; DOSCODE:819Bh (MSDOS 5.0, MSDOS.SYS)

ValidateCDS:
	; 19/05/2019 - Retro DOS v4.0
	; 28/07/2018 - Retro DOS v3.0

   %define  Temp	[bp-2]	; word
   %define  SaveCDS	[bp-6]	; dword
   %define  SaveCDSL	[bp-6]	; word
   %define  SaveCDSH	[bp-4]	; word

	;Enter
	push	bp
	mov	bp,sp
	sub	sp,6

	MOV	Temp,DI

;hkn; SS override
	LDS	SI,[SS:THISCDS]
	MOV	SaveCDSL,SI
	MOV	SaveCDSH,DS
	;EnterCrit critDisk
	call	ECritDisk
	; 21/11/2022
	;test	byte [SI+curdir.flags+1],80h
	;test	word [si+67],8000h
	; 17/12/2022
	;test	byte [SI+68],80h
	test	byte [SI+curdir.flags+1],(curdir_isnet>>8)
	;TEST	word [SI+curdir.flags],curdir_isnet	; Clears carry
	JZ	short _DoSplice
	JMP	FatFail
_DoSplice:
	XOR	DL,DL
	XCHG	DL,[SS:NoSetDir]

;hkn; SS is DOSDATA
	;Context ES
	push	ss
	pop	es
	;Invoke	FStrcpy
	call	FStrCpy
	MOV	SI,Temp

;hkn; SS is DOSDATA
	;Context DS
	push	ss
	pop	ds	
	;Invoke	Splice
	call	Splice

 ;hkn; SS is DOSDATA
	;Context DS			;   FatReadCDS (ThisCDS);
	push	ss
	pop	ds
	MOV	[NoSetDir],DL
	LES	DI,[THISCDS]
	;SAVE	<BP>
	push	bp
	;Invoke	FATREAD_CDS
	call	FATREAD_CDS	
	;RESTORE <BP>
	pop	bp
	JC	short FatFail

	LDS	SI,[THISCDS]		;   if (ThisCDS->ID == -1) {
	;cmp	word [si+73],-1
	CMP	word [SI+curdir.ID],-1
	JNZ	short RestoreCDS

;hkn; SS is DOSDATA
	;Context ES
	push	ss
	pop	es

;hkn; SS override
	;SAVE	<wfp_Start>		;	t = wfp_Start;
	push	word [SS:WFP_START]
	;cmp	si,[bp-6]
	CMP	SI,SaveCDSL		; if not spliced
	JNZ	short DoChdir
	;mov	di,[bp-2]
	MOV	DI,Temp

;hkn; SS override
	MOV	[SS:WFP_START],DI	;	wfp_start = d;
	;Invoke	FStrCpy 		;	strcpy (d, ThisCDS->Text);
	call	FStrCpy
DoChdir:
;hkn; SS is DOSDATA
	;Context DS
	push	ss
	pop	ds
	;SAVE	<<WORD PTR SAttrib>,BP> ;	c = DOSChDir ();
	push	word [SATTRIB]
	push	bp
	;Invoke	DOS_ChDir
	call	DOS_CHDIR
	;RESTORE <BP,BX,wfp_start>	;	wfp_Start = t;
	pop	bp
	pop	bx
	pop	word [WFP_START]
	MOV	[SATTRIB],BL
	LDS	SI,SaveCDS
	JNC	short SetCluster	;	if (c == -1) {

;hkn; SS override for THISCDS
	MOV	[SS:THISCDS],SI		;	    ThisCDS = TmpCDS;
	MOV	[SS:THISCDS+2],DS
	XOR	CX,CX			;	    TmpCDS->text[3] = c = 0;
	MOV	[SI+3],CL		;	    }
SetCluster:
	;mov	word [si+73],0FFFFh
	MOV	word [SI+curdir.ID],-1	;	TmpCDS->ID = -1;
	LDS	SI,[SS:THISCDS]		;	ThisCDS->ID = c;
	; 21/11/2022
	;test	byte [si+curdir.flags+1],20h
	; 19/05/2019
	; MSDOS 6.0
	; 17/12/2022
	;test	byte [si+68],20h
	test	byte [SI+curdir.flags+1],(curdir_splice>>8)	
	;;test	word [si+67],2000h
	;TEST	word [SI+curdir.flags],curdir_splice ;AN000;;MS. for Join and Subst
	JZ	short _setdirclus		     ;AN000;;MS.
	MOV	CX,-1				     ;AN000;;MS.
_setdirclus:
	;mov	[si+73],cx
	MOV	[SI+curdir.ID],CX	;	}
RestoreCDS:
	LES	DI,SaveCDS
	MOV	[SS:THISCDS],DI
	MOV	[SS:THISCDS+2],ES
	CLC
FatFail:
	;LeaveCrit critDisk
	call	LCritDisk

	;les	di,[bp-6]
	LES	DI,SaveCDS
	;Leave
	mov	sp,bp
	pop	bp
	retn

; 28/07/2018 - Retro DOS v3.0
; IBMDOS.COM (MSDOS 3.3, 1987) - offset 43BDh

;Break	<CheckThisDevice - Check for being a device>
;---------------------------------------------------------------------------
;
;   CheckThisDevice - Examine the area at DS:SI to see if there is a valid
;   device specified. We will return carry if there is a device present. 
;   The forms of devices we will recognize are:
;
;	[path]device
;
;   Note that the drive letter has *already* been removed. All other forms
;   are not considered to be devices. If such a device is found we change
;   the source pointer to point to the device component.
;
;   Inputs:	ES is DOSDATA
;		DS:SI contains name
;   Outputs:	ES is DOSDATA
;		DS:SI point to name or device
;		Carry flag set if device was found
;		Carry flag reset otherwise
;   Registers Modified: all except ES:DI, DS
;----------------------------------------------------------------------------

CheckThisDevice:
	push	di
	push	si
	MOV	DI,SI

; Check for presence of \dev\ (Dam multiplan!)

	MOV	AL,[SI]
	call	PATHCHRCMP		; is it a path char?
	JNZ	short ParseDev		; no, go attempt to parse device
	INC	SI			; simulate LODSB

; We have the leading path separator. Look for DEV part.

	LODSW
	OR	AX,2020h
	cmp	ax,"de"
	;CMP	AX,"e"<< 8 + "d"
	JNZ	short NotDevice		; not "de", assume not device
	LODSB
	OR	AL,20h
	CMP	AL,"v"                  ; Not "v", assume not device
	JNZ	short NotDevice
	LODSB
	call	PATHCHRCMP		; do we have the last path separator?
	JNZ	short NotDevice		; no. go for it.

; DS:SI now points to a potential drive. Preserve them as NameTrans advances
; SI and DevName may destroy DS.

ParseDev:
	push	ds
	push	si			; preserve the source pointer
	call	NameTrans		; advance DS:SI
	CMP	BYTE [SI],0		; parse entire string?
	STC				; simulate a Carry return from DevName
	JNZ	short SkipSearch	; no parse. simulate a file return.

;hkn; SS is DOSDATA
	push	ss
	pop	ds

; M026 - start - fix ported from ROMDOS2 for bug # 2849
;
; SR;
; We have to set Attrib before invoking DevName. Otherwise, the value from
; a previous DOS call is used and DevName thinks it is not a device if the
; old call set the volume attribute bit.

	mov	al,[SATTRIB]
	mov	[ATTRIB],al		;set Attrib for DevName

; M026 - end

	call	DEVNAME

SkipSearch:
	pop	si
	pop	ds

; SI points to the beginning of the potential device. If we have a device
; then we do not change SI. If we have a file, then we reset SI back to the
; original value. At this point Carry set indicates FILE.

CheckReturn:
	pop	di			; get original SI
	JNC	short Check_Done	; if device then do not reset pointer
	MOV	SI,DI
Check_Done:
	pop	di
	CMC				; invert carry. Carry => device
	retn
NotDevice:
	STC
	JMP	short CheckReturn

;BREAK <LookupPath - call fastopen to get dir entry info>
;-----------------------------------------------------------------------------
;
; Procedure Name : LookupPath
;
; Output  DS:SI -> path name,
;	  ES:DI -> dir entry info buffer
;	  ES:CX -> extended dir info buffer
;
;	  carry flag clear : tables pointed by ES:DI and ES:CX are filled by
;			     FastOpen, DS:SI points to char just one after
;			     the last char of path name which is fully or
;			     partially found in FastOPen
;	  carry flag set : FastOpen not in memory or path name not found
;
;----------------------------------------------------------------------------

LookupPath:
;	PUSH	AX

;hkn; SS override
	;test	byte [ss:FastOpenFlg],1
	TEST	byte [ss:FastOpenFlg],FastOpen_Set  ; flg is set in DOSOPEN
	JNZ	short FASTINST			    ; and this routine is
NOLOOK:
	JMP	NOLOOKUP			    ; executed once

FASTINST:
;hkn; SS override
	;test	byte [ss:FastOpenFlg],8
	TEST	byte [ss:FastOpenFlg],No_Lookup	    ; no more lookup?
	JNZ	short NOLOOK			    ; yes

	MOV	BX,FastOpenTable		    ; get fastopen related tab

;hkn; SS override
	MOV	SI,[SS:WFP_START]		    ; si points to path name
	MOV	DI,Dir_Info_Buff
	MOV	CX,FastOpen_Ext_Info
	MOV	AL,FONC_Look_up 		    ; al = 1
	PUSH	DS
	POP	ES

;hkn; SS override
	;call	far [bx+2]
	CALL	far [BX+fastopen_entry.name_caching] ;call fastopen
	JC	short NOTFOUND			    ; fastopen not in memory

	LEA	BX,[SI-2]

;hkn; SS override
	CMP	BX,[SS:WFP_START]		    ; path found ?
	JZ	short NOTFOUND			    ; no

	; 19/05/2019 - Retro DOS v4.0

	; MSDOS 6.0				    ; fully or partially found
	CMP	BYTE [SI],0			    ;AN000;FO.
	JNZ	short parfnd			    ;AN000;FO.; partiallyfound
	PUSH	CX				    ;AN000;FO.; is attribute matched ?

;hkn; SS override for attrib/sattrib
	MOV	CL,[ss:ATTRIB]			    ;AN000;FO.;
	MOV	CH,[ss:SATTRIB]			    ;AN000;FO.; attrib=sattrib
	MOV	[ss:ATTRIB],CH			    ;AN000;FO.;
	;mov	ch,[es:di+0Bh]
	MOV	CH,[ES:DI+dir_entry.dir_attr]	    ;AN000;FO.;
	call	MatchAttributes 		    ;AN000;FO.;
;;;	MOV	[ss:ATTRIB],CL			    ;AN001;FO.; restore attrib
	POP	CX				    ;AN000;FO.;
	JNZ	short NOLOOKUP			    ;AN000;FO.; not matched
parfnd:

;hkn; SS override
	MOV	[SS:Next_Element_Start],SI	    ; save si
	MOV	BX,CX
	; MSDOS 6.0
	;mov	ax,[bx+7]
	MOV	AX,[BX+FEI.lastent]		    ;AN000;;FO. restore lastentry
;hkn; SS override for LASTENT, DIRSTART, CLUSNUM
	MOV	[SS:LASTENT],AX			    ;AN000;;FO.
	MOV	AX,[BX+FEI.dirstart]		    ;AN001;;FO. restore dirstart
	MOV	[SS:DIRSTART],AX		    ;AN001;;FO.
	; MSDOS 3.3 (& MSDOS 6.0)
	;;mov	ax,[bx+3] ; MSDOS 3.3
	;mov	ax,[bx+5] ; MSDOS 6.0
	MOV	AX,[BX+FEI.clusnum]		    ; restore next cluster num
	MOV	[SS:CLUSNUM],AX			    ;

	PUSH	ES				    ; save ES
;hkn; SS override
	LES	BX,[SS:THISDPB]			    ; put drive id
	mov	ah,[ES:BX] ; 15/08/2018
	;MOV	AH,[ES:BX+DPB.DRIVE]		    ; in AH for DOOPEN
	POP	ES				    ; pop ES
;SR;
; We cannot have a root dir if we have come here. So, we zero out CurBuf to
;indicate it is not a root dir

	mov	word [SS:CURBUF],0		    ; indicate not root dir
	MOV	WORD [SS:CURBUF+2],ES		    ; [curbuf+2].bx points to
	MOV	BX,DI				    ; start of entry
	;lea	si,[di+1Ah]
	LEA	SI,[DI+dir_entry.dir_first]	    ; [curbuf+2]:si points to
						    ; dir_first field in the
						    ; dir entry
;hkn; SS override for FastOpenFlg
	;or	byte [ss:FastOpenFlg],12h ; 29/12/2022
	OR	byte [SS:FastOpenFlg],Lookup_Success+Set_For_Search
;	POP	AX
	RETN
NOTFOUND:
	CMP	AX,-1				    ; not in memory ?
	JNZ	short Partial_Success 		    ; yes, in memory
	MOV	byte [SS:FastOpenFlg],0		    ; no more fastopen
Partial_Success:
	;and	byte [SS:FastOpenFlg],0FBh
	AND	byte [SS:FastOpenFlg],Special_Fill_Reset
NOLOOKUP:
;	POP	AX
	STC
	RETN

;BREAK <InsertPath - call fastopen to insert dir entry info>
;-----------------------------------------------------------------------------
;
; Procedure Name : InsertPath
; Input:  FastOpen_Set flag set when from DOSOPEN otherwise 0
;	  Lookup_Success flag set when got dir entry info from FASTOPEN
;	  DS = DOSDATA
; Output: FastOPen_Ext_Info is set and path dir info is inserted
;
;-----------------------------------------------------------------------------

	; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)

InsertPath:
	PUSHF
;hkn; SS override for FastOpenFlag
	;test	byte [SS:FastOpenFlg], 1
	TEST	byte [SS:FastOpenFlg],FastOpen_Set ;only DOSOPEN can take advantage of
	JZ	short GET_NEXT_ELEMENT		; the FastOpen
	;test	byte [ss:FastOpenFlg],2
	TEST	byte [SS:FastOpenFlg],Lookup_Success ; Lookup just happened
	JZ	short INSERT_DIR_INFO		; no
	;and	byte [ss:FastOpenFlg],0FDh
	AND	byte [SS:FastOpenFlg],Lookup_Reset  ; we got dir info from fastopen so
	MOV	DI,[SS:Next_Element_Start]	; no need to insert it again
	JMP	short GET_NEXT2
INSERT_DIR_INFO:				; save registers
	PUSH	DS
	PUSH	ES
	PUSH	BX
	PUSH	SI
	PUSH	DI
	PUSH	CX
	PUSH	AX

;hkn; SS override
	LDS	DI,[SS:CURBUF]			; DS:DI -> buffer header
	MOV	SI,FastOpen_Ext_Info
	;mov	ax,[di+6]
	MOV	AX,[DI+BUFFINFO.buf_sector]	; get directory sector
	; MSDOS 6.0
	;mov	[ss:si+1],ax
	MOV	[SS:SI+FEI.dirsec],AX 		;AN000; >32mb save dir sector
	; 19/05/2019 - Retro DOS v4.0
	MOV	AX,[DI+BUFFINFO.buf_sector+2]	;AN000; >32mb

;hkn; SS is DOSDATA
	push	ss
	pop	ds
	; MSDOS 3.3	
	;;mov	[si+1],ax	
	;MOV	[SI+FEI.dirsec],AX
	; MSDOS 6.0
	;mov	[si+3],ax
	MOV	[SI+FEI.dirsec+2],AX		;AN000;>32mb save high dir sector
	; MSDOS 3.3 (& MSDOS 6.0)
	MOV	AX,[CLUSNUM]		; save next cluster number
	;;mov	[si+5],ax ; MSDOS 6.0
	;mov	[si+3],ax ; MSDOS 3.3
	MOV	[SI+FEI.clusnum],AX
	; MSDOS 6.0
	MOV	AX,[LASTENT]		;AN000;FO. save lastentry for search first
	;mov	[si+7],ax
	MOV	[SI+FEI.lastent],AX	;AN000;FO.
	MOV	AX,[DIRSTART]		;AN001;FO. save  for search first
	;mov	[si+9],ax
	MOV	[SI+FEI.dirstart],AX	;AN001;FO.
	; MSDOS 3.3 (& MSDOS 6.0)
	MOV	AX,BX
	;;add	di,16  ; MSDOS 3.3
	;add	di,20  ; MSDOS 6.0
	ADD	DI,BUFINSIZ		; DS:DI -> start of data in buffer
	SUB	AX,DI			; AX=BX relative to start of sector
	;mov	cl,32
	MOV	CL,dir_entry.size
	DIV	CL
	;MOV	[SI+FEI.dirpos],AL	; save directory entry # in buffer
	mov	[si],al

	PUSH	DS
	POP	ES

	MOV	DS,[CURBUF+2]
	MOV	DI,BX			; DS:DI -> dir entry info
	;cmp	word [di+1Ah],0
	CMP	word [DI+dir_entry.dir_first],0 
					; never insert info when file is empty
	JZ	short SKIP_INSERT	; e.g. newly created file

	PUSH	SI			; ES:BX -> extended info
	POP	BX

	;mov	al,2
	MOV	AL,FONC_insert		; call fastopen insert operation
	MOV	SI,FastOpenTable
	;call	far [es:si+2]	 ; call dword ptr es:[si+2] ; 29/12/2022
	; 07/12/2022
	CALL	far [ES:SI+fastopen_entry.name_caching]

	CLC
SKIP_INSERT:
	POP	AX
	POP	CX			; restore registers
	POP	DI
	POP	SI
	POP	BX
	POP	ES
	POP	DS
GET_NEXT2:
	;or	[ss:FastOpenFlg],8
	OR	byte [SS:FastOpenFlg],No_Lookup
					; we got dir info from fastopen so
GET_NEXT_ELEMENT:
	POPF
	RETN

;============================================================================
; DEV.ASM (MSDOS 6.0, 1991)
;============================================================================
; 17/07/2018 - Retro DOS v3.0
; 30/04/2019 - Retro DOS v4.0

;**	Misc Routines to do 1-12 low level I/O and call devices

; Offset 12B8h of IBMDOS.COM (MSDOS 3.3), 1987

;DOSCODE:8401h (MSDOS 6.21, MSDOS.SYS)

;Public DEV001S, DEV001E 		; Pathgen labels
;DEV001s:
;		length of packets
LenTab:	 DB	DRDWRHL, DRDNDHL, DRDWRHL, DSTATHL, DFLSHL, DRDNDHL
;LenTab: db	22,14,22,13,15,14

;	Error Function

CmdTab:
	DB	86h, DEVRD	; 0 input
	DB	86h, DEVRDND	; 1 input status
	DB	87h, DEVWRT	; 2 output
	DB	87h, DEVOST	; 3 output status
	DB	86h, DEVIFL	; 4 input flush
	DB	86h, DEVRDND	; 5 input status with system WAIT

; Offset 12BEh of IBMDOS.COM (MSDOS 3.3), 1987

;CmdTab:
;	db	86h, 4
;	db	86h, 5
;	db	87h, 8
;	db	87h, 10
;	db	86h, 7
;	db	86h, 5

;DEV001E:

; 30/04/2019 - Retro DOS v4.0
; DOSCODE:8413h (MSDOS 6.21, MSDOS.SYS)

;Break	<IOFUNC -- DO FUNCTION 1-12 I/O>
;----------------------------------------------------------------------------
;
; Procedure Name : IOFUNC
;
; Inputs:
;	DS:SI Points to SFT
;	AH is function code
;		= 0 Input
;		= 1 Input Status
;		= 2 Output
;		= 3 Output Status
;		= 4 Flush
;		= 5 Input Status - System WAIT invoked for K09 if no char
;				   present.
;	AL = character if output
; Function:
;	Perform indicated I/O to device or file
; Outputs:
;	AL is character if input
;	If a status call
;		zero set if not ready
;		zero reset if ready (character in AL for input status)
; For regular files:
;	Input Status
;		Gets character but restores position
;		Zero set on EOF
;	Input
;		Gets character advances position
;		Returns ^Z on EOF
;	Output Status
;		Always ready
; AX altered, all other registers preserved
;----------------------------------------------------------------------------

; 21/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:83D8h (MSDOS 5.0, MSDOS.SYS)

IOFUNC:
	MOV	[SS:IOXAD+2],SS		; SS override for IOXAD, IOSCNT, 
					; DEVIOBUF
	MOV	WORD [SS:IOXAD],DEVIOBUF
	MOV	WORD [SS:IOSCNT],1
	MOV	WORD [SS:DEVIOBUF],AX
	;test	byte [si+6],80h
	;TEST	word [SI+SF_ENTRY.sf_flags],sf_isnet ; 8000h
	test	byte [SI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
	JZ	short IOTO22		;AN000;
	JMP	IOTOFILE		;AN000;
IOTO22:
	;test	word [si+5],80h
	;TEST	word [SI+SF_ENTRY.sf_flags],devid_device 
	test	byte [SI+SF_ENTRY.sf_flags],devid_device	
	JNZ	short IOTO33		;AN000;
	JMP	IOTOFILE		;AN000;
IOTO33:
	push	es ; * (MSDOS 6.21)
	call	save_world
	MOV	DX,DS
	MOV	BX,SS
	MOV	DS,BX
	MOV	ES,BX
	XOR	BX,BX
	cmp	ah,5		    ; system wait enabled?
	jnz	short _no_sys_wait
	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	; 16/12/2022
	or	bh,04h
	;or	bx,0400H	    ; Set bit 10 in status word for driver
				    ; It is up to device driver to carry out
				    ; appropriate action.
_no_sys_wait:
	MOV	[IOCALL_REQSTAT],BX
	XOR	BX,BX
	MOV	[IOMED],BL

	MOV	BL,AH		 	; get function
	MOV	AH,[cs:BX+LenTab]
	SHL	BX,1
	MOV	CX,[cs:BX+CmdTab]
	MOV	BX,IOCALL ; DOSDATA:037Ch
	MOV	[IOCALL_REQLEN],AH
	MOV	[IOCALL_REQFUNC],CH

	MOV	DS,DX
	CALL	DEVIOCALL
	MOV	DI,[SS:IOCALL_REQSTAT]	; SS override
	and	di,di
	js	short DevErr
OKDevIO:
	MOV	AX,SS
	MOV	DS,AX

	;cmp	ch,5
	CMP	CH,DEVRDND
	JNZ	short DNODRD
	MOV	AL,[IORCHR]
	MOV	[DEVIOBUF],AL

DNODRD: 
	MOV	AH,[IOCALL_REQSTAT+1]
	NOT	AH			; Zero = busy, not zero = ready
	;and	ah,2
	AND	AH,STBUI>>8

QuickReturn:				;AN000; 2/13/KK
	call	restore_world
	pop	es ; * (MSDOS 6.21)

	; SR;
	; We return ax = -1 if the user failed on I24. This is the case if 
	; IoStatFail = -1 (set after return from the I24)

	; MSDOS 6.0
	pushf
	mov	al,[ss:IoStatFail]	;assume fail error
	cbw				;sign extend to word
	cmp	ax,-1
	jne	short not_fail_ret
	inc	byte [ss:IoStatFail]
	popf
	retn

not_fail_ret:
	mov	ax,[ss:DEVIOBUF]	;ss override
	popf
	retn

DevErr:
	MOV	AH,CL
	call	CHARHARD
	CMP	AL,1
	JNZ	short NO_RETRY
	call	restore_world
	; 12/05/2019
	pop	es ; * (MSDOS 6.21)		
	JMP	IOFUNC	; 10/08/2018

NO_RETRY:
	; Know user must have wanted Ignore OR Fail. Make sure device shows ready
	; ready so that DOS doesn't get caught in a status loop when user 
	; simply wants to ignore the error.
	;
	; SR; If fail wanted by user set ax to special value (ax = -1). This 
	; should be checked by the caller on return

					; SS override
	and	byte [SS:IOCALL_REQSTAT+1],0FDh
	;AND	BYTE [SS:IOCALL_REQSTAT+1],~(STBUI>>8)

	; SR;
	; Check if user failed

	; MSDOS 6.0
	cmp	al,3
	jnz	short not_fail
	dec	byte [ss:IoStatFail]	;set flag indicating fail on I24
not_fail:
	JMP	short OKDevIO

IOTOFILE:
	OR	AH,AH
	JZ	short IOIN
	DEC	AH
	JZ	short IOIST
	DEC	AH
	JZ	short IOUT
IOUT_retn:	; 18/12/2022
	retn				; NON ZERO FLAG FOR OUTPUT STATUS
IOIST:
	;push	word [si+15h]
	PUSH	WORD [SI+SF_ENTRY.sf_position]   ; Save position
	;push	word [si+17h]
	PUSH	WORD [SI+SF_ENTRY.sf_position+2]
	CALL	IOIN
	;pop	word [si+17h]
	POP	WORD [SI+SF_ENTRY.sf_position+2] ; Restore position
	;pop	word [si+15h]
	POP	WORD [SI+SF_ENTRY.sf_position]
	retn
IOUT:
	CALL	SETXADDR
	call	DOS_WRITE
	;CALL	RESTXADDR	; If you change this into a jmp don't
	; 18/12/2022
	jmp	RESTXADDR
;IOUT_retn:
	;retn			; come crying to me when things don't
				; work ARR
IOIN:
	CALL	SETXADDR
					; SS override for DOS34_FLAG
	;OR	word [SS:DOS34_FLAG],Disable_EOF_I24	;AN000;
	;or	word [ss:DOS34_FLAG],40h
	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	; 16/12/2022
	or	byte [ss:DOS34_FLAG],40h 
	CALL	DOS_READ
	;AND	word [SS:DOS34_FLAG],NO_Disable_EOF_I24 ;AN000;
	;and	word [SS:DOS34_FLAG],0FFBFh
	; 21/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	; 16/12/2022
	and	byte [SS:DOS34_FLAG],0BFh ; 07/12/2022
	OR	CX,CX			; Check EOF
	CALL	RESTXADDR
					; SS override
	MOV	AL,[SS:DEVIOBUF]	; Get byte from trans addr
	jnz	short IOUT_retn	
	MOV	AL,1AH			; ^Z if no bytes
	retn

SETXADDR:
					; SS override
	POP	WORD [SS:CALLSCNT]	; Return address

	push	es ; * (MSDOS 6.21)

	call	save_world
					; SS override for DMAADD and THISSFT
	; 24/09/2023
	;PUSH	WORD [SS:DMAADD]	; Save Disk trans addr
	;PUSH	WORD [SS:DMAADD+2]
	MOV	[SS:THISSFT+2],DS

	push	ss
	pop	ds

	; 24/09/2023
	push	word [DMAADD]
	push	word [DMAADD+2]

	MOV	[THISSFT],SI		; Finish setting SFT pointer
	MOV	CX,[IOXAD+2]
	MOV	[DMAADD+2],CX
	MOV	CX,[IOXAD]
	MOV	[DMAADD],CX		; Set byte trans addr
	MOV	CX,[IOSCNT]		; ioscnt specifies length of buffer
	JMP	SHORT RESTRET		; RETURN ADDRESS

RESTXADDR:
	POP	WORD [CALLSCNT]		; Return address
	POP	WORD [DMAADD+2]		; Restore Disk trans addr
	POP	WORD [DMAADD]

	call	restore_world

	pop	es ; * (MSDOS 6.21)
					; SS override
RESTRET:
	JMP	WORD [SS:CALLSCNT]	; Return address

; DOSCODE:8569h (MSDOS 6.21, MSDOS.SYS)
; 21/11/2022
; DOSCODE:852Eh (MSDOS 5.0, MSDOS.SYS)

;Break <DEV_OPEN_SFT, DEV_CLOSE_SFT - OPEN or CLOSE A DEVICE>

;----------------------------------------------------------------------------
;**	Dev_Open_SFT - Open the Device for an SFT
;
;	Dev_Open_SFT issues an open call to the device associated with
;	the SFT.
;
;	ENTRY	(ES:DI) = SFT
;	EXIT	none
;	USES	all
;----------------------------------------------------------------------------

DEV_OPEN_SFT:
	push	es ; * (MSDOS 6.21)
	call	save_world
	;mov	al,0Dh	
	MOV	AL,DEVOPN
	JMP	SHORT DO_OPCLS

;----------------------------------------------------------------------------
; Procedure Name : DEV_CLOSE_SFT
;
; Inputs:
;	ES:DI Points to SFT
; Function:
;	Issue a CLOSE call to the correct device
; Outputs:
;	None
; ALL preserved
;----------------------------------------------------------------------------

DEV_CLOSE_SFT:
	push	es ; * (MSDOS 6.21)
	call	save_world
	;mov	al,0Eh	
	MOV	AL,DEVCLS

	; Main entry for device open and close. AL contains the function 
	; requested. Subtlety: if Sharing is NOT loaded then we do NOT issue 
	; open/close to block devices. This allows networks to function but 
	; does NOT hang up with bogus change-line code.

	;entry	DO_OPCLS
DO_OPCLS:
	; Is the SFT for the net? If so, no action necessary.

	; MSDOS 6.0
	;test	word [es:di+5],8000h
	;TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
	test	byte [es:di+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
	jnz	short OPCLS_DONE	; NOP on net SFTs
	XOR	AH,AH			; Unit
	;test	byte [es:di+5],80h
	TEST	byte [ES:DI+SF_ENTRY.sf_flags],devid_device
	;les	di,[es:di+7]
	LES	DI,[ES:DI+SF_ENTRY.sf_devptr] ; Get DPB or device
	JNZ	short GOT_DEV_ADDR

	; We are about to call device open/close on a block driver. If no 
	; sharing then just short circuit to done.
	
	; MSDOS 6.0
					; SS override
	CMP	byte [ss:fShare],1	;AN010; /NC or no SHARE
	JBE	short OPCLS_DONE	;AN010; yes

	; MSDOS 3.3 (& MSDOS 6.0)
	;mov	ah,[es:di+1]
	MOV	AH,[ES:DI+DPB.UNIT]	; (ah) = unit
	mov	cl,[es:di]
	;MOV	CL,[ES:DI+DPB.DRIVE]	; (cl) = drive
	;;les	di,[es:di+12h] ; MSDOS 3.3
	;les	di,[es:di+13h] ; MSDOS 6.0
	LES	DI,[ES:DI+DPB.DRIVER_ADDR] ; Get device
GOT_DEV_ADDR:				; ES:DI -> device
	;test	word [es:di+4],800h
	;TEST	word [ES:DI+SYSDEV.ATT],DEVOPCL
	test	byte [ES:DI+SYSDEV.ATT+1],(DEVOPCL>>8)
	JZ	short OPCLS_DONE	; Device can't
	PUSH	ES
	POP	DS
	MOV	SI,DI			; DS:SI -> device

OPCLS_RETRY:
	;Context ES
	push	ss
	pop	es
					; DEVCALL is in DOSDATA
	MOV	DI,DEVCALL

	MOV	BX,DI
	PUSH	AX
	;mov	al,13
	MOV	AL,DOPCLHL
	STOSB				; Length
	POP	AX
	XCHG	AH,AL
	STOSB				; Unit
	XCHG	AH,AL
	STOSB				; Command
	MOV	WORD [ES:DI],0		; Status
	PUSH	AX			; Save Unit,Command
	;invoke	DEVIOCALL2
	call	DEVIOCALL2

	;mov	di,[es:bx+3]
	MOV	DI,[ES:BX+SRHEAD.REQSTAT]
	;test	di,8000h
	;jz	short OPCLS_DONEP	
	and	di,di
	jns	short OPCLS_DONEP	; No error
	; 21/11/2022
	;test	word [si+4],8000h
	;TEST	word [SI+SYSDEV.ATT],DEVTYP
	;test	word [si+5],80h
	test	byte [SI+SYSDEV.ATT+1],(DEVTYP>>8)
	JZ	short BLKDEV
	MOV	AH,86H			; Read error in data, Char dev
	JMP	SHORT HRDERR
BLKDEV:
	MOV	AL,CL			; Drive # in AL
	MOV	AH,6			; Read error in data, Blk dev
HRDERR:
	;invoke	CHARHARD
	call	CHARHARD
	cmp	al,1
	jne	short OPCLS_DONEP	; IGNORE or FAIL
					;  Note that FAIL is essentually IGNORED
	POP	AX			; Get back Unit, Command
	JMP	short OPCLS_RETRY
OPCLS_DONEP:
	POP	AX			; Clean stack
OPCLS_DONE:
	call	restore_world
	pop	es ; * (MSDOS 6.21)
	retn

; 30/04/2019 - Retro DOS v4.0
; DOSCODE:85EAh (MSDOS 6.21, MSDOS.SYS)

; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:85AFh (MSDOS 5.0, MSDOS.SYS)

;Break	<DEVIOCALL, DEVIOCALL2 - CALL A DEVICE>
;----------------------------------------------------------------------------
;**	DevIoCall  - Call Device
;
;	ENTRY	DS:SI Points to device SFT
;		ES:BX Points to request data
;	EXIT	DS:SI -> Device driver
;	USES	DS:SI,AX
;----------------------------------------------------------------------------
;**	DevIoCall2 - Call Device
;
;	ENTRY	DS:SI Points to DPB
;		ES:BX Points to request data
;	EXIT	DS:SI -> Device driver
;	USES	DS:SI,AX
;----------------------------------------------------------------------------

DEVIOCALL:
					; SS override for CALLSSEC, 
	;lds	si,[si+7]		; CALLNEWSC, HIGH_SECTOR & CALLDEVAD
	LDS	SI,[SI+SF_ENTRY.sf_devptr]

	;entry	DEVIOCALL2
DEVIOCALL2:
	;EnterCrit critDevice
	call	ECritDevice

	; MSDOS 6.0
	;TEST	word [SI+SYSDEV.ATT],DEVTYP ;AN000; >32mb block device ?
	;test	byte [si+5],80h
	test	byte [si+SYSDEV.ATT+1],(DEVTYP>>8)
	jnz	short chardev2		;AN000; >32mb no

	; 16/12/2022
	; 22/11/2022
	mov	al,[ES:BX+SRHEAD.REQFUNC] ; [es:bx+2]
	cmp	al,DEVRD	; 4
	je	short chkext	
	cmp	al,DEVWRT	; 8
	je	short chkext
	cmp	al,DEVWRTV	; 9
	jne	short chardev2

	; 16/12/2022
	; 22/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;;cmp	byte [es:bx+2],4
	;CMP	byte [ES:BX+SRHEAD.REQFUNC],DEVRD  ;AN000; >32mb read ?
	;JZ	short chkext		;AN000; >32mb   yes
	;;cmp	byte [es:bx+2],8
	;CMP	byte [ES:BX+SRHEAD.REQFUNC],DEVWRT ;AN000; >32mb write ?
	;JZ	short chkext		;AN000; >32mb   yes
	;;cmp	byte [es:bx+2],9
	;CMP	byte [ES:BX+SRHEAD.REQFUNC],DEVWRTV
	;				;AN000; >32mb write/verify ?
	;JNZ	short chardev2		;AN000; >32mb no
chkext:
	CALL	RW_SC			;AN000;LB. use secondary cache if there
	JC	short dev_exit		;AN000;LB. done

	;test	byte [si+4],2
	TEST	byte [SI+SYSDEV.ATT],EXTDRVR ;AN000;>32mb extended driver?
	JZ	short chksector		;AN000;>32mb   no
	ADD	BYTE [ES:BX],8		;AN000;>32mb   make length to 30
	MOV	AX,[SS:CALLSSEC]	;AN000;>32mb
	MOV	word [SS:CALLSSEC],-1	;AN000;>32mb   old sector  =-1
	MOV	[SS:CALLNEWSC],AX	;AN000;>32mb   new sector  =
	MOV	AX,[SS:HIGH_SECTOR]	;AN000; >32mb  low sector,high sector
	MOV	[SS:CALLNEWSC+2],AX	;AN000; >32mb
	JMP	short chardev2		;AN000; >32mb
chksector:				;AN000; >32mb
	CMP	word [SS:HIGH_SECTOR],0	;AN000; >32mb   if >32mb
	JZ	short chardev2		;AN000; >32mb   then fake error
	;mov	word [es:bx+3],8107h
	MOV	word [ES:BX+SRHEAD.REQSTAT],STERR+STDON+error_I24_not_DOS_disk 
					;AN000; >32mb
	JMP	SHORT dev_exit		;AN000; >32mb

chardev2:				;AN000;
	; As above only DS:SI points to device header on entry, and DS:SI is 
	; preserved

	;mov	ax,[si+6]
	MOV	AX,[SI+SYSDEV.STRAT]
	MOV	[SS:CALLDEVAD],AX
	MOV	[SS:CALLDEVAD+2],DS
	CALL	far [SS:CALLDEVAD]

	;mov	ax,[si+8]
	MOV	AX,[SI+SYSDEV.INT]
	MOV	[SS:CALLDEVAD],AX
	CALL	far [SS:CALLDEVAD]

	; MSDOS 6.0
	CALL	VIRREAD 		;AN000;LB. move data from SC to buffer
	JC	short chardev2		;AN000;LB. bad sector or exceeds max sec

dev_exit:
	;LeaveCrit critDevice
	;call	LCritDevice
	;retn
	; 18/12/2022
	jmp	LCritDevice

; DOSCODE:8669h (MSDOS 6.21, MSDOS.SYS)
; 22/11/2022
; DOSCODE:862Eh (MSDOS 5.0, MSDOS.SYS)

;Break	<SETREAD, SETWRITE -- SET UP HEADER BLOCK>
;---------------------------------------------------------------------------
;
; Procedure Name : SETREAD, SETWRITE
;
; Inputs:
;	DS:BX = Transfer Address
;	CX = Record Count
;	DX = Starting Record
;	AH = Media Byte
;	AL = Unit Code
; Function:
;	Set up the device call header at DEVCALL
; Output:
;	ES:BX Points to DEVCALL
; No other registers effected
;
;---------------------------------------------------------------------------

SETREAD_XJ:
	;;;
	; 07/02/2024 - Retro DOS v4.2
	mov	bx,di
	jmp	short SETREAD_X
	;;;

SETREAD_XT:
	;;;
	; 07/02/2024 - Retro DOS v4.2
	mov	bx,TIMEBUF
	push	bx
SETREAD_XTC:
	mov	cx,6
	;;;
SETREAD_X:
	;;;
	; 06/02/2024 - Retro DOS v4.2
	xor	ax,ax
	;mov	dx,ax ; 0
	cwd
	;;;

; ------------------------------------

SETREAD:
	PUSH	DI
	PUSH	CX
	PUSH	AX
	MOV	CL,DEVRD ; mov cl,4
SETCALLHEAD:
	MOV	AL,DRDWRHL ; mov al,16h
	PUSH	SS
	POP	ES
					; DEVCALL is in DOSDATA
	MOV	DI,DEVCALL

	STOSB				; length
	POP	AX			; 
	STOSB				; Unit
	PUSH	AX
	MOV	AL,CL
	STOSB				; Command code
	XOR	AX,AX
	STOSW				; Status
	ADD	DI,8			; Skip link fields
	POP	AX
	XCHG	AH,AL
	STOSB				; Media byte
	XCHG	AL,AH
	PUSH	AX
	MOV	AX,BX
	STOSW

	MOV	AX,DS
	STOSW				; Transfer addr

	POP	CX			; Real AX
	POP	AX			; Real CX
	STOSW				; Count

	XCHG	AX,DX			; AX=Real DX, DX=real CX, CX=real AX
	STOSW				; Start
	XCHG	AX,CX
	XCHG	DX,CX
	POP	DI
					; DEVCALL is in DOSDATA
	MOV	BX,DEVCALL
	retn

	;entry	SETWRITE
SETWRITE:

; Inputs:
;	DS:BX = Transfer Address
;	CX = Record Count
;	DX = Starting Record
;	AH = Media Byte
;	AL = Unit Code
; Function:
;	Set up the device call header at DEVCALL
; Output:
;	ES:BX Points to DEVCALL
; No other registers effected

	PUSH	DI
	PUSH	CX
	PUSH	AX
	MOV	CL,DEVWRT ; mov cl,8
	ADD	CL,[SS:VERFLG]		; SS override
	JMP	SHORT SETCALLHEAD

; 30/04/2019 - Retro DOS v4.0
; DOSCODE:86A8h (MSDOS 6.21, MSDOS.SYS)
; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:866Dh (MSDOS 5.0, MSDOS.SYS)

;Break	<RW_SC -- Read Write Secondary Cache>
;---------------------------------------------------------------------------
;
; Procedure Name : RW_SC
;
; Inputs:
;	 [SC_CACHE_COUNT]= secondary cache count
;	 [SC_STATUS]= SC validity status
;	 [SEQ_SECTOR]= last sector read
; Function:
;	Read from or write through secondary cache
; Output:
;	ES:BX Points to DEVCALL
;	carry clear, I/O is not done
;		     [SC_FLAG]=1 if continuos sectors will be read
;	carry set, I/O is done
;
;----------------------------------------------------------------------------

RW_SC:
	; SS override for all variables used.
	
	CMP	word [ss:SC_CACHE_COUNT],0  ;AN000;LB. secondary cache exists?
	JZ	short scexit4		    ;AN000;LB. no, do nothing
	CMP	word [ss:CALLSCNT],1	    ;AN000;LB. sector count = 1 (buffer I/O)
	JNZ	short scexit4 		    ;AN000;LB. no, do nothing
	PUSH	CX			    ;AN000;LB.
	PUSH	DX			    ;AN000;LB. yes
	PUSH	DS			    ;AN000;LB. save registers
	PUSH	SI			    ;AN000;LB.
	PUSH	ES			    ;AN000;LB.
	PUSH	DI			    ;AN000;LB.

	MOV	DX,[ss:CALLSSEC]	    ;AN000;LB. starting sector
	CMP	BYTE [ss:DEVCALL_REQFUNC],DEVRD ;AN000;LB. read ?
	JZ	short doread		    ;AN000;LB. yes
	CALL	INVALIDATE_SC		    ;AN000;LB. invalidate SC
	JMP	scexit2 		    ;AN000;LB. back to normal
scexit4:				    ;AN000;
	CLC				    ;AN000;LB. I/O not done yet
	retn				    ;AN000;LB.
doread: 				    ;AN000;
	CALL	SC2BUF			    ;AN000;LB. check if in SC
	JC	short readSC		    ;AN000;LB.
	MOV	word [ss:DEVCALL_REQSTAT],STDON ;AN000;LB. fake done and ok
	STC				    ;AN000;LB. set carry
	JMP	short saveseq 		    ;AN000;LB. save seq. sector #
readSC: 				    ;AN000;
	MOV	AX,[ss:HIGH_SECTOR]   	    ;AN000;LB. subtract sector num from
	MOV	CX,[ss:CALLSSEC]	    ;AN000;LB. saved sequential sector
	SUB	CX,[ss:SEQ_SECTOR]    	    ;AN000;LB. number
	SBB	AX,[ss:SEQ_SECTOR+2]  	    ;AN000;LB.
	; 24/09/2023
	;CMP	AX,0			    ;AN000;LB. greater than 64K
	JNZ	short saveseq2		    ;AN000;LB. yes,save seq. sector #
chklow: 						
	CMP	CX,1			    ;AN000;LB. <= 1
	JA	short saveseq2		    ;AN000;LB. no, not sequential
	MOV	word [ss:SC_STATUS],-1	    ;AN000;LB. presume all SC valid
	MOV	AX,[ss:SC_CACHE_COUNT]	    ;AN000;LB. yes, sequential
	MOV	[ss:CALLSCNT],AX	    ;AN000;LB. read continuous sectors
readsr:
	MOV	AX,[ss:CALLXAD+2]	    ;AN000;LB. save buffer addr
	MOV	[ss:TEMP_VAR2],AX	    ;AN000;LB. in temp vars
	MOV	AX,[ss:CALLXAD]	    	    ;AN000;LB.
	MOV	[ss:TEMP_VAR],AX	    ;AN000;LB.

	MOV	AX,[ss:SC_CACHE_PTR]	    ;AN000;LB. use SC cache addr as
	MOV	[ss:CALLXAD],AX		    ;AN000;LB. transfer addr
	MOV	AX,[ss:SC_CACHE_PTR+2]	    ;AN000;LB.
	MOV	[ss:CALLXAD+2],AX	    ;AN000;LB.
	MOV	byte [ss:SC_FLAG],1	    ;AN000;LB. flag it for later;
	MOV	AL,[ss:SC_DRIVE]	    ;AN000;LB. current drive
	MOV	[ss:CurSC_DRIVE],AL	    ;AN000;LB. set current drive
	MOV	AX,[ss:CALLSSEC]	    ;AN000;LB. current sector
	MOV	[ss:CurSC_SECTOR],AX	    ;AN000;LB. set current sector
	MOV	AX,[ss:HIGH_SECTOR]	    ;AN000;LB.
	MOV	[ss:CurSC_SECTOR+2],AX	    ;AN000;LB.
saveseq2:				    ;AN000;
	CLC				    ;AN000;LB. clear carry
saveseq:				    ;AN000;	
	MOV	AX,[ss:HIGH_SECTOR]	    ;AN000;LB. save current sector #
	MOV	[ss:SEQ_SECTOR+2],AX	    ;AN000;LB. for access mode ref.
	MOV	AX,[ss:CALLSSEC]	    ;AN000;LB.	
	MOV	[ss:SEQ_SECTOR],AX 	    ;AN000;LB.	
	JMP	short scexit 		    ;AN000;LB.	
scexit2:				    ;AN000;LB.
	CLC				    ;AN000;LB.	clear carry
scexit: 				    ;AN000;		
	POP	DI			    ;AN000;LB.
	POP	ES			    ;AN000;LB. restore registers
	POP	SI			    ;AN000;LB.
	POP	DS			    ;AN000;LB.
	POP	DX			    ;AN000;LB.
	POP	CX			    ;AN000;LB.
	retn				    ;AN000;LB.

;Break	<IN_SC -- check if in secondary cache>
;--------------------------------------------------------------------------
;
; Procedure Name : IN_SC
;
; Inputs:  [SC_DRIVE]= requesting drive
;	   [CURSC_DRIVE]= current SC drive
;	   [CURSC_SECTOR]= starting scetor # of SC
;	   [SC_CACHE_COUNT]= SC count
;	   [HIGH_SECTOR]:DX= sector number
; Function:
;	Check if the sector is in secondary cache
; Output:
;	carry clear, in SC
;	   CX= the index in the secondary cache
;	carry set, not in SC
;
;---------------------------------------------------------------------------

	; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
IN_SC:
	; SS override for all variables used
	MOV	AL,[ss:SC_DRIVE]	    ;AN000;;LB. current drive
	CMP	AL,[ss:CurSC_DRIVE]	    ;AN000;;LB. same as SC drive
	JNZ	short outrange2		    ;AN000;;LB. no
	MOV	AX,[ss:HIGH_SECTOR]	    ;AN000;;LB. subtract sector num from
	MOV	CX,DX			    ;AN000;;LB. secondary starting sector
	SUB	CX,[ss:CurSC_SECTOR]        ;AN000;;LB. number
	SBB	AX,[ss:CurSC_SECTOR+2]      ;AN000;;LB.
	; 24/09/2023
	;CMP	AX,0			    ;AN000;;LB. greater than 64K
	JNZ	short outrange2		    ;AN000;;LB. yes
	CMP	CX,[ss:SC_CACHE_COUNT]	    ;AN000;;LB. greater than SC count
	JAE	short outrange2		    ;AN000;;LB. yes
	CLC				    ;AN000;;LB. clear carry
	;JMP	short inexit		    ;AN000;;LB. in SC
	; 16/12/2022
	retn	; 30/04/2019
	; 22/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;jmp	short inexit

outrange2:				    ;AN000;;LB. set carry
	STC				    ;AN000;;LB.
inexit: 				    ;AN000;;LB.
	retn				    ;AN000;;LB.

;Break	<INVALIDATE_SC - invalide secondary cache>
;---------------------------------------------------------------------------
;
; Procedure Name : Invalidate_Sc
;
; Inputs:  [SC_DRIVE]= requesting drive
;	   [CURSC_DRIVE]= current SC drive
;	   [CURSC_SECTOR]= starting scetor # of SC
;	   [SC_CACHE_COUNT]= SC count
;	   [SC_STATUS]= SC status word
;	   [HIGH_SECTOR]:DX= sector number
;
; Function:
;	invalidate secondary cache if in there
; Output:
;	[SC_STATUS] is updated
;---------------------------------------------------------------------------

INVALIDATE_SC:
	; SS override for all variables used

	CALL	IN_SC			    ;AN000;;LB. in secondary cache
	JC	short outrange		    ;AN000;;LB. no
	MOV	AX,1			    ;AN000;;LB. invalidate the sector
	SHL	AX,CL			    ;AN000;;LB. in the secondary cache
	NOT	AX			    ;AN000;;LB.
	AND	[ss:SC_STATUS],AX	    ;AN000;;LB. save the status
outrange:				    ;AN000;;LB.
	retn				    ;AN000;;LB.

; DOSCODE:87A5h (MSDOS 6.21, MSDOS.SYS)
; 22/11/2022
; DOSCODE:876Ah (MSDOS 5.0, MSDOS.SYS)

;Break	<VIRREAD- virtually read data into buffer>
;--------------------------------------------------------------------------
;
; Procedure Name : SC_FLAG
;
; Inputs:  SC_FLAG = 0, no sectors were read into SC
;		     1, continuous sectors were read into SC
; Function:
;	   Move data from SC to buffer
; Output:
;	 carry clear, data is moved to buffer
;	 carry set, bad sector or exceeds maximum sector
;	   SC_FLAG =0
;	   CALLSCNT=1
;	   SC_STATUS= -1 if succeeded
;     
;		       0 if failed
;--------------------------------------------------------------------------

VIRREAD:
	; SS override for all variables used

	CMP	byte [ss:SC_FLAG],0	    ;AN000;;LB. from SC fill
	JZ	short sc2end		    ;AN000;;LB. no
	MOV	AX,[ss:TEMP_VAR2]	    ;AN000;;LB. restore buffer addr
	MOV	[ss:CALLXAD+2],AX	    ;AN000;;LB.
	MOV	AX,[ss:TEMP_VAR]	    ;AN000;;LB.
	MOV	[ss:CALLXAD],AX		    ;AN000;;LB.
	MOV	byte [ss:SC_FLAG],0	    ;AN000;;LB. reset sc_flag
	MOV	word [ss:CALLSCNT],1	    ;AN000;;LB. one sector transferred

	;TEST	word [SS:DEVCALL_REQSTAT],STERR ;AN000;;LB. error?
	test	byte [ss:DEVCALL_REQSTAT+1],(STERR>>8) ; 80h
	JNZ	short scerror 		    ;AN000;;LB. yes
	PUSH	DS			    ;AN000;;LB.
	PUSH	SI			    ;AN000;;LB.
	PUSH	ES			    ;AN000;;LB.
	PUSH	DI			    ;AN000;;LB.
	PUSH	DX			    ;AN000;;LB.
	PUSH	CX			    ;AN000;;LB.
	XOR	CX,CX			    ;AN000;;LB. we want first sector in SC
	CALL	SC2BUF2 		    ;AN000;;LB. move data from SC to buf
	POP	CX
	POP	DX			    ;AN000;;LB.
	POP	DI			    ;AN000;;LB.
	POP	ES			    ;AN000;;LB.
	POP	SI			    ;AN000;;LB.
	POP	DS			    ;AN000;;LB.
	JMP	SHORT sc2end		    ;AN000;;LB. return
scerror:				    ;AN000;
	MOV	word [ss:CALLSCNT],1	    ;AN000;;LB. reset sector count to 1
	MOV	word [ss:SC_STATUS],0	    ;AN000;;LB. invalidate all SC sectors
	MOV	byte [ss:CurSC_DRIVE],-1    ;AN000;;LB. invalidate drive
	STC				    ;AN000;;LB. carry set
	retn				    ;AN000;;LB.
sc2end: 				    ;AN000;
	CLC				    ;AN000;;LB. carry clear
	retn				    ;AN000;;LB.

; 30/04/2019 - Retro  DOS v4.0
; DOSCODE:87FDh (MSDOS 6.21, MSDOS.SYS)
; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:87C2h (MSDOS 5.0, MSDOS.SYS)

;Break	<SC2BUF- move data from SC to buffer>
;----------------------------------------------------------------------------
;
; Procedure Name : SC2BUF
;
; Inputs:  [SC_STATUS] = SC validity status
;	   [SC_SECTOR_SIZE] = request sector size
;	   [SC_CACHE_PTR] = pointer to SC
; Function:
;	   Move data from SC to buffer
; Output:
;	   carry clear, in SC  and data is moved
;	   carry set, not in SC and data is not moved
;---------------------------------------------------------------------------

SC2BUF:
	; SS override for all variables used
	CALL	IN_SC			    ;AN000;LB. in secondary cache
	;JC	short noSC		    ;AN000;LB. no
	; 24/09/2023
	jc	short sexit
	MOV	AX,1			    ;AN000;LB. check if valid sector
	SHL	AX,CL			    ;AN000;LB. in the secondary cache
	TEST	[ss:SC_STATUS],AX	    ;AN000;LB.
	JZ	short noSC		    ;AN000;LB. invalid
;entry SC2BUF2
SC2BUF2:				    ;AN000;
	;MOV	AX,CX			    ;AN000;LB. times index with
	;MUL	word [ss:SC_SECTOR_SIZE]    ;AN000;LB. sector size
	; 24/09/2023
	mov	ax,[ss:SC_SECTOR_SIZE]
	xchg	ax,cx ; cx = [ss:SC_SECTOR_SIZE]
	mul	cx
	ADD	AX,[ss:SC_CACHE_PTR]	    ;AN000;LB. add SC starting addr
	ADC	DX,[ss:SC_CACHE_PTR+2]	    ;AN000;LB.
	MOV	DS,DX			    ;AN000;LB. DS:SI-> SC sector addr
	MOV	SI,AX			    ;AN000;LB.
	MOV	ES,[ss:CALLXAD+2]		    ;AN000;LB. ES:DI-> buffer addr
	MOV	DI,[ss:CALLXAD]		    ;AN000;LB.
	; 24/09/2023
	;MOV	CX,[ss:SC_SECTOR_SIZE]	    ;AN000;LB. count= sector size
	SHR	CX,1			    ;AN000;LB. may use DWORD move for 386
;entry MOVWORDS
MOVWORDS:				    ;AN000;
	CMP	byte [ss:DDMOVE],0	    ;AN000;LB. 386 ?
	JZ	short nodd		    ;AN000;LB. no
	SHR	CX,1			    ;AN000;LB. words/2
	DB	66H			    ;AN000;LB. use double word move
nodd:
	REP	MOVSW			    ;AN000;LB. move to buffer
	CLC				    ;AN000;LB. clear carry
	retn				    ;AN000;LB. exit
noSC:					    ;AN000;
	STC				    ;AN000;LB. set carry
sexit:					    ;AN000;
	retn				    ;AN000;LB.

;============================================================================
; MKNODE.ASM, MSDOS 6.0, 1991
;============================================================================
; 29/07/2018 - Retro DOS v3.0
; 19/05/2019 - Retro DOS v4.0

;	TITLE	MKNODE - Node maker
;	NAME	MKNODE

;**	MKNODE.ASM
;----------------------------------------------------------------------------
;	Low level routines for making a new local file system node
;	and filling in an SFT from a directory entry
;
;	BUILDDIR
;	SETDOTENT
;	MakeNode
;	NEWENTRY
;	FREEENT
;	NEWDIR
;	DOOPEN
;	RENAME_MAKE
;	CHECK_VIRT_OPEN
;
;	Revision history:
;
;	 AN000	version 4.0  Jan. 1988
;	 A004	PTM 3680  --- Make SFT NAME field offset same as 3.30

;Break   <BUILDDIR,NEWDIR -- ALLOCATE DIRECTORIES>
;----------------------------------------------------------------------------
;
; Procedure Name : BUILDDIR,NEWDIR
;
; Inputs:
;       ES:BP Points to DPB
;       [THISSFT] Set if using NEWDIR entry point
;               (used by ALLOCATE)
;       [LASTENT] current last valid entry number in directory if no free
;               entries
;       [DIRSTART] Points to first cluster of dir (0 means root)
; Function:
;       Grow directory if no free entries and not root
; Outputs:
;       CARRY SET IF FAILURE
;       ELSE
;          AX entry number of new entry
;          If a new dir [DIRSTART],[CLUSFAC],[CLUSNUM],[DIRSEC] set
;               AX = first entry of new dir
;       GETENT should be called to set [LASTENT]
;
;----------------------------------------------------------------------------

; 19/05/2019 - Retro DOS v4.0
; DOSCODE:8845h (MSDOS 6.21, MSDOS.SYS)
; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:880Ah (MSDOS 6.21, MSDOS.SYS)

; 24/09/2023 - Retro DOS v4.2 (Modified MSDOS 6.21 MSDOS.SYS)
; DOSCODE:8845h (MSDOS 6.22, MSDOS.SYS)

BUILDDIR:
	; 29/07/2018 - Retro DOS v3.0
	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 4E66h

        MOV     AX,[ENTFREE]
        CMP     AX,-1 ; 0FFFFh
	;JZ	short CHECK_IF_ROOT
        ;CLC
        ;retn
	; 24/09/2023
	jne	short builddir_cmc_retn  ; cf=1 (will be 0)

CHECK_IF_ROOT:
        CMP     word [DIRSTART],0
        JNZ	short NEWDIR
        ;STC
	; 24/09/2023
	; [DIRSTART]=0, cf=0, zf=1 (cf will be 1 after cmc instruction)
builddir_cmc_retn:
	; 24/09/2023
	cmc	; cf=1 <-> cf=0
builddir_retn:
        retn				; Can't grow root

	;entry   NEWDIR
NEWDIR: 
	MOV     BX,[DIRSTART]
        OR      BX,BX
        JZ	short NULLDIR
	call	GETEOF
        jc	short builddir_retn	; Screw up
NULLDIR:
        MOV     CX,1
	call	ALLOCATE
        jc	short  builddir_retn
        MOV     DX,[DIRSTART]
        OR      DX,DX
        JNZ	short ADDINGDIR
	call	SETDIRSRCH
        jc	short  builddir_retn
        MOV     word [LASTENT],-1
        JMP     SHORT GOTDIRREC
ADDINGDIR:
        PUSH    BX
        MOV     BX,[CLUSNUM]
        call	IsEOF
        POP     BX
        JB	short NOTFIRSTGROW
;;;; 10/17/86 update CLUSNUM in the fastopen cache
        MOV     [CLUSNUM],BX
	; 24/09/2023
	;PUSH	CX ; (not necessary)
	PUSH	AX
	PUSH	BP
        MOV     AH,1			; CLUSNUM update
	; 15/12/2022
	mov	dl,[ES:BP] ; 09/09/2018
        ; 22/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;;mov	dl,[es:bp+0]
	;MOV	DL,[ES:BP+DPB.DRIVE]	; drive #
        MOV     CX,[DIRSTART]		; first cluster #
        MOV     BP,BX 			; CLUSNUM
	call	FastOpen_Update
        POP     BP
        POP     AX
	; 24/09/2023
        ;POP	CX

;;;; 10/17/86 update CLUSNUM in the fastopen cache
NOTFIRSTGROW:
        MOV     DX,BX
        XOR     BL,BL
	call	FIGREC
GOTDIRREC:
	;mov	cl,[es:bp+4]
        MOV     CL,[ES:BP+DPB.CLUSTER_MASK]
        INC     CL
        XOR     CH,CH
ZERODIR:
        PUSH    CX
	; 22/09/2023
	;;mov	byte [ALLOWED],18h
        ;MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY ; *
        MOV     AL,0FFH
        ;call	GETBUFFR
        call	GETBUFFRD ; *
	JNC	short GET_SSIZE
        POP     CX
        retn

GET_SSIZE:
	;mov	cx,[es:bp+2]
        MOV     CX,[ES:BP+DPB.SECTOR_SIZE]
        PUSH    ES
        LES     DI,[CURBUF]
	;or	byte [es:di+5],4
        OR      byte [ES:DI+BUFFINFO.buf_flags],buf_isDIR
        PUSH    DI
	;;add	di,16	; MSDOS 3.3
	;add	di,20	; MSDOS 6.0	
        ADD     DI,BUFINSIZ
        XOR     AX,AX
        SHR     CX,1
        REP     STOSW
        JNC	short EVENZ
        STOSB
EVENZ:
        POP     DI

	; MSDOS 6.0
	TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
					;LB. if already dirty		  ;AN000;
        JNZ	short yesdirty7		;LB.  don't increment dirty count ;AN000;
        call	INC_DIRTY_COUNT		;LB. 				  ;AN000;
        
	;or	byte [es:di+5],40h
	OR      byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
yesdirty7:
        POP	ES
        POP	CX

	; 19/05/2019 - Retro DOS v4.0

	; MSDOS 3.3
	;INC	DX

	; MSDOS 6.0
	; 24/09/2023
	;add	dx,1
	;;adc	word [HIGH_SECTOR],0
	;; 24/09/2023
	;; ax=0
	;adc	[HIGH_SECTOR],ax ; 0
	; 24/09/2023
	inc	dx
	jnz	short loop_zerodir
	inc	word [HIGH_SECTOR]
loop_zerodir:
        LOOP    ZERODIR

        MOV     AX,[LASTENT]
        INC     AX
	; 24/09/2023
	; cf=0
	;CLC
        retn

;--------------------------------------------------------------------------
;
; Procedure Name : SETDOTENT
;
; set up a . or .. directory entry for a directory.
;
;   Inputs:     ES:DI point to the beginning of a directory entry.
;               AX contains ". " or ".."
;               DX contains first cluster of entry
;
;----------------------------------------------------------------------------

SETDOTENT:
;	Fill in name field
        STOSW
        MOV     CX,4
        MOV     AX,"  " ; 2020h
        REP     STOSW
        STOSB

;	Set up attribute
	;mov	al, 10h
        MOV     AL,attr_directory
        STOSB

;	Initialize time and date of creation
        ADD     DI,10
        MOV     SI,[THISSFT]
	;mov	ax,[si+0Dh]
        MOV     AX,[SI+SF_ENTRY.sf_time]
        STOSW
	;mov	ax,[si+0Fh]
        MOV     AX,[SI+SF_ENTRY.sf_date]
	STOSW

;	Set up first cluster field
        MOV     AX,DX
        STOSW

;	0 file size
        XOR     AX,AX
        STOSW
        STOSW
        retn

;Break   <MAKENODE -- CREATE A NEW NODE>
;---------------------------------------------------------------------------
;
; Procedure Name : MakeNode
;
; Inputs:
;       AL - attribute to create
;       AH = 0 if it is ok to truncate a file already by this name
;	AH != 0 if truncation not allowed (prexisting file is an error)
;               (AH ignored on dirs and devices)
;
;        NOTE: When making a DIR or volume ID, AH need not be set since
;               a name already existant is ALWAYS an error in these cases.
;
;       [WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
;               terminated)
;       [CURR_DIR_END] Points to end of Current dir part of string
;               ( = -1 if current dir not involved, else
;                Points to first char after last "/" of current dir part)
;       [THISCDS] Points to CDS being used
;       [THISSFT] Points to an empty SFT. EXCEPT sf_mode filled in.
; Function:
;       Make a new node
; Outputs:
;       Sets EXTERR_LOCUS = errLOC_Disk or errLOC_Unk via GetPathNoset
;       CARRY SET IF ERROR
;          AX = 1 A node by this name exists and is a directory
;          AX = 2 A new node could not be created
;          AX = 3 A node by this name exists and is a disk file
;               (AH was NZ on input)
;          AX = 4 Bad Path
;               SI return from GetPath maintained
;          AX = 5 Attribute mismatch
;          AX = 6 Sharing Violation
;               (INT 24 generated ALWAYS since create is always compat mode
;          AX = 7 file not found for Extended Open (not exists and fails)
;       ELSE
;          AX = 0 Disk Node
;          AX = 3 Device Node (error in some cases)
;          [DIRSTART],[DIRSEC],[CLUSFAC],[CLUSNUM] set to directory
;               containing new node.
;          [CURBUF+2]:BX Points to entry
;          [CURBUF+2]:SI Points to entry.dir_first
;          [THISSFT] is filled in
;               sf_mode = unchanged.
;          Attribute byte in entry is input AL
; DS preserved, others destroyed
;
;-------------------------------------------------------------------------

; 19/05/2019 - Retro DOS v4.0
; DOSCODE:8925h (MSDOS 6.21, MSDOS.SYS)

; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:88EAh (MSDOS 5.0, MSDOS.SYS)

MakeNode:
	;mov	word [CREATING],0E5FFh
	MOV	WORD [CREATING],DIRFREE*256 + 0FFh ; Creating, not DEL *.*
        PUSH    AX              ; Save AH value
	MOV	byte [NoSetDir],0
	MOV	[SATTRIB],AL
	call	GetPathNoSet
        MOV     DL,CL           ; Save CL info
        MOV     CX,AX           ; Device ID to CH
        POP     AX              ; Get back AH
        JNC	short make_exists ; File existed
        JNZ	short make_err_4 ; Path bad
        CMP     DL,80h          ; Check "CL" return from GETPATH
        JZ	short make_type	; Name simply not found, and no metas
make_err_4:
        MOV     AL,4            ; case 1 bad path
make_err_ret:
        XOR     AH,AH
        STC
;make_retn:	; 22/11/2022
        retn

        ;entry	RENAME_MAKE     ; Used by DOS_RENAME to "copy" a node
RENAME_MAKE:
make_type:
;Extended Open hooks
	; MSDOS 6.0
	;TESTB	EXTOPEN_ON,EXT_OPEN_ON	;FT. from extended open		;AN000;
	test	byte [EXTOPEN_ON],EXT_OPEN_ON ; 1
	JZ	short make_type2	;FT. no				;AN000;
	OR	byte [EXTOPEN_ON],EXT_FILE_NOT_EXISTS ; 4
					;FT. set for extended open ;AN000;
	;TESTB	EXTOPEN_FLAG,0F0H	;FT. not exists and fails	;AN000;
	test	byte [EXTOPEN_FLAG],0F0h
	JNZ	short make_type2	;FT. no				;AN000;
	STC				;FT. set carry			;AN000;
	MOV    AX,7			;FT. file not found		;AN000;
	; 22/11/2022
make_retn:
	;return
	retn				;FT.				;AN000;

;	Extended Open hooks

make_type2:
        LES     DI,[THISSFT]
        XOR     AX,AX           ; nothing exists Disk Node
        STC                     ; Not found
        JMP     short make_new

; The node exists. It may be either a device, directory or file:
;   Zero set => directory
;   High bit of CH on => device
;   else => file

make_exists:
        JZ	short make_exists_dir
        MOV     AL,3            ; file exists type 3  (error or device node)
	;test	byte [ATTRIB],18h
	TEST	byte [ATTRIB],attr_volume_id+attr_directory
        JNZ	short make_err_ret_5
				; Cannot already exist as Disk or Device Node
                                ;       if making DIR or Volume ID
        OR      CH,CH
        JS	short make_share ; No further checks on attributes if device
        OR      AH,AH
        JNZ	short make_err_ret ; truncating NOT OK (AL = 3)
        PUSH    CX              ; Save device ID
        MOV     ES,[CURBUF+2]
	;mov	ch,[es:bx+0Bh]
        MOV     CH,[ES:BX+dir_entry.dir_attr] ; Get file attributes
	;test	ch,1
	test	CH,attr_read_only
        JNZ	short make_err_ret_5P ; Cannot create on read only files
	call	MatchAttributes
        POP     CX              ; Devid back in CH
        JNZ	short make_err_ret_5 ; Attributes not ok
        XOR     AL,AL           ; AL = 0, Disk Node
make_share:
        XOR     AH,AH
        PUSH    AX              ; Save Disk or Device node
        PUSH    CX              ; Save Device ID
        MOV     AH,CH           ; Device ID to AH
        CALL    DOOPEN          ; Fill in SFT for share check
        LES     DI,[THISSFT]
	push	si
	push	bx		; Save CURBUF pointers
	call	ShareEnter
        jnc	short MakeEndShare

; User failed request.
	pop	bx
	pop	si
	pop	cx
	pop	ax

Make_Share_ret:
        MOV     AL,6
        JMP	short make_err_ret

make_err_ret_5P:
        POP     CX              ; Get back device ID
make_err_ret_5:
        MOV     AL,5            ; Attribute mismatch
        ; 22/11/2022
	JMP     short make_err_ret

make_exists_dir:
        MOV     AL,1            ; exists as directory, always an error
	; 22/11/2022
	JMP     short make_err_ret

make_save:
        PUSH    AX              ; Save whether Disk or File
        MOV     AX,CX           ; Device ID to AH
        CALL    NEWENTRY
        POP     AX              ; 0 if Disk, 3 if File
        jnc	short make_retn
        MOV     AL,2            ; create failed case 2
make_save_retn:
        retn

make_new:
        call    make_save
        jc	short make_save_retn	; case 2 fail
	;test	byte [ATTRIB],10h
	test	BYTE [ATTRIB],attr_directory
        jnz	short make_save_retn	; Don't "open" directories,
					; so don't tell the sharer about them
	push	ax
	push	bx
	push	si		
        call	ShareEnter
	pop	si
	pop	bx
	pop	ax
	jnc	short make_save_retn

; We get here by having the user FAIL a share problem. Typically a failure of
; this nature is an out-of-space or an internal error. We clean up as best as
; possible: delete the newly created directory entry and return share_error.

        PUSH    AX
        LES     DI,[CURBUF]
	;mov	byte [es:bx],0E5h
	MOV	BYTE [ES:BX],DIRFREE	; nuke newly created entry.
	
	; MSDOS 6.0
	;test	byte [es:di+5],40h
	TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty  
					;LB. if already dirty		  ;AN000;
        JNZ	short yesdirty8		;LB.  don't increment dirty count ;AN000;
	; 22/11/2022
	call	INC_DIRTY_COUNT		;LB.				  ;AN000;
	;or	byte [es:di+5],40h
        OR      byte [ES:DI+BUFFINFO.buf_flags],buf_dirty ; flag buffer as dirty
yesdirty8:
        LES     BP,[THISDPB]
	; 15/12/2022
        mov	al,[ES:BP]
	; 22/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;;mov	al,[es:bp+0]
	;MOV	AL,[ES:BP+DPB.DRIVE]	; get drive for flush
        call	FLUSHBUF		; write out buffer.
        POP     AX
        jmp	short Make_Share_ret

; We have found an existing file. We have also entered it into the share set.
; At this point we need to call newentry to correctly address the problem of
; getting rid of old data (create an existing file) or creating a new
; directory entry (create a new file). Unfortunately, this operation may
; result in an INT 24 that the user doesn't return from, thus locking the file
; irretrievably into the share set. The correct solution is for us to LEAVE
; the share set now, do the operation and then reassert the share access.
;
; We are allowed to do this! There is no window! After all, we are in
; critDisk here and for someone else to get in, they must enter critDisk also.

	; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; DOSCODE:89C8h (MSDOS 5.0, MSDOS.SYS)

MakeEndShare:
        LES     DI,[THISSFT]		; grab SFT
        XOR     AX,AX
	call	ECritSFT
	xchg	AX,[ES:DI]
	;XCHG	AX,[ES:DI+SF_ENTRY.sf_ref_count]
	push	ax
	push	di
	push	es
        PUSHF
        call	ShareEnd                ; remove sharing
        POPF
	pop	es
	pop	di
        pop	word [ES:DI]	
	;pop	word [ES:DI+SF_ENTRY.sf_ref_count]
	call	LCritSFT
	; 22/11/2022
	; DOSCODE:89E4h (MSDOS 5.0, MSDOS.SYS)
	pop	bx
	pop	si
	pop	cx
	pop	ax
        CALL    make_save

; If the user failed, we do not reenter into the sharing set.

        jc	short make_save_retn	; bye if error
	push	ax
	push	bx
	push	si
        PUSHF
        call	ShareEnter
        POPF
	pop	si
	pop	bx
	pop	ax

; If Share_check fails, then we have an internal ERROR!!!!!

makeendshare_retn:
        retn

;---------------------------------------------------------------------------
;
; Procedure Name : NEWENTRY
;
; Inputs:
;       [THISSFT] set
;       [THISDPB] set
;       [LASTENT] current last valid entry number in directory if no free
;               entries
;       [VOLID] set if a volume ID was found during search
;	Attrib Contains attributes for new file
;       [DIRSTART] Points to first cluster of dir (0 means root)
;       CARRY FLAG INDICATES STATUS OF SEARCH FOR FILE
;               NC means file existed (device)
;               C  means file did not exist
;       AH = Device ID byte
;       If FILE
;           [CURBUF+2]:BX points to start of directory entry
;           [CURBUF+2]:SI points to dir_first of directory entry
;       If device
;           DS:BX points to start of "fake" directory entry
;           DS:SI points to dir_first of "fake" directory entry
;               (has DWORD pointer to device header)
; Function:
;       Make a new directory entry
;       If an old one existed it is truncated first
; Outputs:
;       Carry set if error
;               Can't grow dir, atts didn't match, attempt to make 2nd
;               vol ID, user FAILed to I 24
;       else
;               outputs of DOOPEN
; DS, BX, SI preserved (meaning on SI BX, not value), others destroyed
;
;----------------------------------------------------------------------------

	; 22/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; DOSCODE:89F9h (MSDOS 5.0, MSDOS.SYS)

NEWENTRY:
        LES     BP,[THISDPB]
        JNC	short EXISTENT	
        CMP     byte [FAILERR],0
	;STC
        ;jnz	short makeendshare_retn	; User FAILed, node might exist
        ; 24/09/2023
	jnz	short ERRRET3
	CALL    BUILDDIR        ; Try to build dir
        jc	short makeendshare_retn	; Failed
        call	GETENT          ; Point at that free entry
        jc	short makeendshare_retn	; Failed
        JMP     SHORT FREESPOT

ERRRET3:
        STC
newentry_retn:
        retn

EXISTENT:
        OR      AH,AH           ; Check if file is I/O device
        JNS	short NOT_DEV1
        JMP     DOOPEN          ; If so, proceed with open

NOT_DEV1:
        call	FREEENT		; Free cluster chain
        jc	short newentry_retn ; Failed
FREESPOT:
	;test	byte [ATTRIB],8
	test	BYTE [ATTRIB],attr_volume_id
        JZ	short NOTVOLID
        CMP     BYTE [VOLID],0
        JNZ	short ERRRET3	; Can't create a second volume ID
NOTVOLID:
        MOV     ES,[CURBUF+2]
        MOV     DI,BX

        MOV     SI,NAME1

        MOV     CX,5
        REP     MOVSW
        MOVSB                   ; Move name into dir entry
	MOV	AL,[ATTRIB]
	STOSB                   ; Attributes

;; File Tagging for Create DOS 4.00
        MOV     CL,5            ;FT. assume normal FBUGBUG	;AN000;
;; File Tagging for Create DOS 4.00

        XOR     AX,AX
        REP     STOSW           ; Zero pad
        call	DATE16
        XCHG    AX,DX
        STOSW                   ; dir_time
        XCHG    AX,DX
        STOSW                   ; dir_date
        XOR     AX,AX
        PUSH    DI              ; Correct SI input value
				; 	(recomputed for new buffer)
        STOSW                   ; Zero dir_first and size
        STOSW
        STOSW
updnxt:
	MOV	SI,[CURBUF]

	; 19/05/2019 - Retro DOS v4.0

	; MSDOS 6.0
	TEST	byte [ES:SI+BUFFINFO.buf_flags],buf_dirty
				;LB. if already dirty		  ;AN000;
        JNZ	short yesdirty9	;LB.  don't increment dirty count ;AN000;
        call	INC_DIRTY_COUNT	;LB.				  ;AN000;
        
	;or	byte [es:si+5],40h
	OR      byte [ES:SI+BUFFINFO.buf_flags],buf_dirty
yesdirty9:
        LES     BP,[THISDPB]
	; 15/12/2022
	MOV	AL,[ES:BP]
	; 22/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;;mov	al,[es:bp+0]
	;MOV	AL,[ES:BP+DPB.DRIVE] ; Sets AH value again (in AL)
        PUSH    AX
        PUSH    BX

; If we have a file, we need to increment the open ref. count so that
; we have some protection against invalid media changes if an Int 24
; error occurs.
; Do nothing for a device.

	push	es
	push	di
        LES     DI,[THISSFT]
	;test	word [es:di+5],80h
	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
	test	byte [ES:DI+SF_ENTRY.sf_flags],devid_device
        jnz	short GotADevice
	push	ds
	push	bx
        LDS     BX,[THISDPB]
	;mov	[es:di+7],bx
        MOV     [ES:DI+SF_ENTRY.sf_devptr],BX
        MOV     BX,DS
	;mov	[es:di+9],bx
        MOV     [ES:DI+SF_ENTRY.sf_devptr+2],BX
	pop	bx
	pop	ds ; need to use DS for segment later on
	call	DEV_OPEN_SFT    ; increment ref. count
        mov	byte [VIRTUAL_OPEN],1; set flag
GotADevice:
	pop	di
	pop	es

        call	FLUSHBUF
        Call    CHECK_VIRT_OPEN ; decrement ref. count            ;AN000;
        POP     BX
        POP     AX
        POP     SI              ; Get SI input back
        MOV     AH,AL           ; Get I/O driver number back
	jnc	short DOOPEN    ; Failed
	retn
	
;NOTE FALL THROUGH

; DOSCODE:8AE4h (MSDOS 6.21, MSDOS.SYS)

; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:8AA9h (MSDOS 5.0, MSDOS.SYS)

; DOOPEN
;----------------------------------------------------------------------------
;
; Inputs:
;       [THISDPB] points to DPB if file
;       [THISSFT] points to SFT being used
;       AH = Device ID byte
;       If FILE
;           [CURBUF+2]:BX points to start of directory entry
;           [CURBUF+2]:SI points to dir_first of directory entry
;       If device
;           DS:BX points to start of "fake" directory entry
;           DS:SI points to dir_first of "fake" directory entry
;               (has DWORD pointer to device header)
; Function:
;       Fill in SFT from dir entry
; Outputs:
;       CARRY CLEAR
;       sf_ref_count and sf_mode fields not altered
;       sf_flags high byte = 0
;       sf_flags low byte = AH except
;       sf_flags Bit 6 set (not dirty or not EOF)
;       sf_attr sf_date sf_time sf_name set from entry
;       sf_position = 0
;       If device
;           sf_devptr = dword at dir_first (pointer to device header)
;           sf_size = 0
;       If file
;           sf_firclus sf_size set from entry
;           sf_devptr = [THISDPB]
;           sf_cluspos = 0
;           sf_lstclus = sf_firclus
;           sf_dirsec sf_dirpos set
; DS,SI,BX preserved, others destroyed
;
;----------------------------------------------------------------------------

	;entry	DOOPEN
DOOPEN:
;	Generate and store attribute

        MOV     DH,AH           ; AH to different place
        LES     DI,[THISSFT]
	;add	di,4
        ADD     DI,SF_ENTRY.sf_attr ; Skip ref_count and mode fields
	; 24/09/2023
	xor	ax,ax
	;XOR	AL,AL		; Assume it's a device, devices have an
				;   attribute of 0 (for R/O testing etc).
        OR      DH,DH           ; See if our assumption good.
        JS	short DEV_SFT1	; If device DS=DOSGROUP
        MOV     DS,[CURBUF+2]
	;mov	al,[BX+0Bh]
        MOV     AL,[BX+dir_entry.dir_attr]
				; If file, get attrib from dir entry
DEV_SFT1:
        STOSB                   ; sf_attr, ES:DI -> sf_flags

;	Generate and store flags word

	; 24/09/2023
	;XOR	AX,AX
        ; ah=0
	MOV     AL,DH
	;or	al,40h
        OR      AL,devid_file_clean
        STOSW                   ; sf_flags, ES:DI -> sf_devptr

;	Generate and store device pointer

        PUSH    DS
	;lds	ax,[bx+1Ah]
        LDS     AX,[BX+dir_entry.dir_first] ; Assume device
        OR      DH,DH
        JS	short DEV_SFT2

;hkn; SS override
        LDS     AX,[SS:THISDPB]	; Was file
DEV_SFT2:
        STOSW 			; store offset
        MOV     AX,DS
        POP     DS
	STOSW			; store segment
				; ES:DI -> sf_firclus

;	Generate pointer to, generate and store first cluster 
;	(irrelevant for devices)

        PUSH    SI              ; Save pointer to dir_first
        MOVSW                   ; dir_first -> sf_firclus
                                ; DS:SI -> dir_size_l, ES:DI -> sf_time

;	Copy time/date of last modification

	;sub	si,6
        SUB     SI,dir_entry.dir_size_l - dir_entry.dir_time 
				; DS:SI->dir_time
        MOVSW                   ; dir_time -> sf_time
                                ; DS:SI -> dir_date, ES:DI -> sf_date
        MOVSW                   ; dir_date -> sf_date
                                ; DS:SI -> dir_first, ES:DI -> sf_size

;	Generate and store file size (0 for devices)

        LODSW                   ; skip dir_first, DS:SI -> dir_size_l
        LODSW                   ; dir_size_l in AX , DS:SI -> dir_size_h
        MOV     CX,AX           ; dir_size_l in CX
        LODSW                   ; dir_size_h (size AX:CX), DS:SI -> ????
        OR      DH,DH
        JNS	short FILE_SFT1
        XOR     AX,AX
        MOV     CX,AX           ; Devices are open ended
FILE_SFT1:
        XCHG    AX,CX
        STOSW                   ; Low word of sf_size
        XCHG    AX,CX
        STOSW                   ; High word of sf_size
                                ; ES:DI -> sf_position
; Initialize position to 0

        XOR     AX,AX
        STOSW
        STOSW                   ; sf_position
                                ; ES:DI -> sf_cluspos

; Generate cluster optimizations for files

        OR      DH,DH
        JS	short DEV_SFT3
        STOSW                   ; sf_cluspos ; 19h
	;mov	ax,[bx+1Ah]
        MOV     AX,[BX+dir_entry.dir_first]
	; 19/05/2019
	; MSDOS 3.3
	;STOSW 			; sf_lstclus ; 1Bh
	; MSDOS 6.0
        PUSH	DI              ;AN004; save dirsec offset
	;sub	di,1Bh
        SUB	DI,SF_ENTRY.sf_dirsec	;AN004; es:di -> SFT
	;mov	[es:di+35h],ax
        MOV	[ES:DI+SF_ENTRY.sf_lstclus],AX	;AN004; save it
        POP	DI              ;AN004; restore dirsec offset

; DOS 3.3  FastOpen  6/13/86

	PUSH	DS

;hkn; SS is DOSDATA
	push	ss
	pop	ds
	;test	byte [FastOpenFlg],4
	TEST	byte [FastOpenFlg],Special_Fill_Set
	JZ	short Not_FastOpen

;hkn; FastOpen_Ext_Info is in DOSDATA
        MOV     SI,FastOpen_Ext_Info

	;mov	ax,[si+1]
        MOV     AX,[SI+FEI.dirsec]
        STOSW                   ; sf_dirsec
	; MSDOS 6.0
	;mov	ax,[si+3]
        MOV	AX,[SI+FEI.dirsec+2]
				;;; changed for >32mb
        STOSW                   ; sf_dirsec
	; 19/08//2018
	mov	al,[SI]
        ;MOV	AL,[SI+FEI.dirpos] ; mov al,[SI+0]
        STOSB                   ; sf_dirpos
        POP	DS
        ;JMP	short Next_Name
	; 24/09/2023
	jmp	short FILE_SFT2  ; cf=0 (after 'test' instruction)

; DOS 3.3  FastOpen  6/13/86

Not_FastOpen:
        ;POP     DS		; normal path

;hkn; SS override
	;MOV	SI,[SS:CURBUF]	; DS:SI->buffer header
	; 16/12/2022
	; 28/07/2019
	mov	si,[CURBUF]
	pop	ds
	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;pop	ds
	;mov	si,[ss:CURBUF]
	
	;mov	ax,[si+6]
        MOV     AX,[SI+BUFFINFO.buf_sector]     ;F.C. >32mb ;AN000;
        STOSW                   ; sf_dirsec     ;F.C. >32mb ;AN000;
	; 19/05/2019        
	; MSDOS 6.0
	;mov	ax,[si+8]
	MOV	AX,[SI+BUFFINFO.buf_sector+2]	;F.C. >32mb ;AN000;
        STOSW                   ; sf_dirsec     ;F.C. >32mb ;AN000;
        
	MOV     AX,BX
	;;add	si,16	; MSDOS 3.3	
	;add	si,20	; MSDOS 6.0
        ADD     SI,BUFINSIZ     ; DS:SI-> start of data in buffer
        SUB     AX,SI           ; AX = BX relative to start of sector
        ;mov	cl,32
	MOV     CL,dir_entry.size
        DIV     CL
        STOSB                   ; sf_dirpos
Next_Name:
        JMP     SHORT FILE_SFT2

	; 24/09/2023
	; cf=0 (after 'or' instruction)
DEV_SFT3:
	;add	di,7
        ADD     DI,SF_ENTRY.sf_name-SF_ENTRY.sf_cluspos
FILE_SFT2:

; Copy in the object's name

        MOV     SI,BX           ; DS:SI points to dir_name
        MOV     CX,11
        REP     MOVSB           ; sf_name
        POP     SI              ; recover DS:SI -> dir_first

;hkn; SS is DOSDATA
        push	ss
	pop	ds
	; 24/09/2023
	; cf=0
        ;CLC
        retn

;---------------------------------------------------------------------------
;
; Procedure Name : FREEENT
;
; Inputs:
;       ES:BP -> DPB
;       [CURBUF] Set
;       [CURBUF+2]:BX points to directory entry
;       [CURBUF+2]:SI points to above dir_first
; Function:
;       Free the cluster chain for the entry if present
; Outputs:
;       Carry set if error (currently user FAILed to I 24)
;       (NOTE dir_firclus and dir_size_l/h are wrong)
; DS BX SI ES BP preserved (BX,SI in meaning, not value) others destroyed
;---------------------------------------------------------------------------

	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
FREEENT:
        PUSH    DS
        LDS     DI,[CURBUF]
        MOV     CX,[SI]         ; Get pointer to clusters
	; 19/05/2019 - Retro DOS v4.0
	; MSDOS 6.0
	MOV	DX,[DI+BUFFINFO.buf_sector+2]  ;F.C. >32mb	;AN000;
;hkn; SS override
        MOV	[SS:HIGH_SECTOR],DX		;F.C. >32mb	;AN000;
        MOV     DX,[DI+BUFFINFO.buf_sector]
        POP     DS
	CMP	CX,2
        JB	short RET1	; Was 0 length file (or mucked Firclus if CX=1)
	;cmp	cx,[es:bp+0Dh]
        CMP     CX,[ES:BP+DPB.MAX_CLUSTER]
        JA	short RET1	; Treat like zero length file (firclus mucked)
        SUB     BX,DI
        PUSH    BX              ; Save offset
	PUSH	word [HIGH_SECTOR] ;F.C. >32mb	;AN000;
        PUSH    DX              ; Save sector number
        MOV     BX,CX
        call	RELEASE         ; Free any data allocated
        POP     DX
        POP	word [HIGH_SECTOR] ;F.C. >32mb	;AN000;
        JNC	short GET_BUF_BACK
        POP     BX
freeent_retn:
        retn			; Screw up

GET_BUF_BACK:
	; 22/09/2023
	;;mov	byte [ALLOWED],18h
        ;MOV	byte [ALLOWED],Allowed_RETRY+Allowed_FAIL ; *
        ;XOR	AL,AL ; *
	;call	GETBUFFR        ; Get sector back
	call	GETBUFFER ; * ; pre read      

	POP     BX              ; Get offset back
        jc	short freeent_retn
	call	SET_BUF_AS_DIR
        ADD     BX,[CURBUF]	; Correct it for new buffer
        MOV     SI,BX
	;add	si,1Ah
        ADD     SI,dir_entry.dir_first	; Get corrected SI
RET1:
        CLC
        retn

;---------------------------------------------------------------------------
;
; Procedure Name : CHECK_VIRT_OPEN
;
; CHECK_VIRT_OPEN checks to see if we had performed a "virtual open" (by
; examining the flag [VIRTUAL_OPEN] to see if it is 1). If we did, then
; it calls Dev_Close_SFT to decrement the ref. count. It also resets the
; flag [VIRTUAL_OPEN].
; No registers affected (including flags).
; On input, [THISSFT] points to current SFT.
;
;---------------------------------------------------------------------------

CHECK_VIRT_OPEN:
	PUSH    AX
        lahf                    ; preserve flags
        CMP     byte [VIRTUAL_OPEN],0
        JZ	short ALL_CLOSED
        mov     byte [VIRTUAL_OPEN],0	; reset flag
	push	es
	push	di
        LES     DI,[THISSFT]
        call	DEV_CLOSE_SFT
	pop	di
	pop	es

ALL_CLOSED:
        sahf                    ; restore flags
        POP     AX
        retn

;============================================================================
; ROM.ASM, MSDOS 6.0, 1991
;============================================================================
; 29/07/2018 - Retro DOS v3.0
; 20/05/2019 - Retro DOS v4.0

;	TITLE	ROM - Miscellaneous routines
;	NAME	ROM

;**	Misc Low level routines for doing simple FCB computations, Cache
;       reads and writes, I/O optimization, and FAT allocation/deallocation
;
;	SKPCLP
;	FNDCLUS
;	BUFSEC
;	BUFRD
;	BUFWRT
;	NEXTSEC
;	OPTIMIZE
;	FIGREC
;	ALLOCATE
;	RESTFATBYT
;	RELEASE
;	RELBLKS
;	GETEOF
;
;	Modification history:
;
;		Created: ARR 30 March 1983
;               M039: DB 10/25/90 - Disk read/write optimization.

;Break   <FNDCLUS -- Skip over allocation units>
;--------------------------------------------------------------------------
;
; Procedure Name : FNDCLUS
;
; Inputs:
;       CX = No. of clusters to skip
;       ES:BP = Base of drive parameters
;       [THISSFT] point to SFT
; Outputs:
;       BX = Last cluster skipped to
;       CX = No. of clusters remaining (0 unless EOF)
;       DX = Position of last cluster
;       Carry set if error (currently user FAILed to I 24)
; DI destroyed. No other registers affected.
;--------------------------------------------------------------------------

; 20/05/2019 - Retro DOS v4.0
; DOSCODE:8BF2h (MSDOS 6.21, MSDOS.SYS)
; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:8BB7h (MSDOS 5.0, MSDOS.SYS)

FNDCLUS:
	PUSH	ES
        LES     DI,[THISSFT]		; setup addressability to SFT
	;;mov	bx,[es:di+1Bh] ; MSDOS 3.3
	;mov	bx,[es:di+35h] ; MSDOS 6.0
	MOV	BX,[ES:DI+SF_ENTRY.sf_lstclus]
	;mov	dx,[es:di+19h]
        MOV     DX,[ES:DI+SF_ENTRY.sf_cluspos]
	OR	BX,BX
	JZ	short NOCLUS

        SUB     CX,DX
        JNB	short FINDIT

        ADD     CX,DX
        XOR     DX,DX
	;mov	bx,[es:di+0Bh]
        MOV     BX,[ES:DI+SF_ENTRY.sf_firclus]
FINDIT:
        POP	ES
	JCXZ	RET9

	;entry	SKPCLP
SKPCLP:
	call	UNPACK
        jc	short fndclus_retn	; retc

	; 09/09/2018

	; MSDOS 3.3
	;push	bx
	;mov	bx,di
	;call	IsEOF
	;pop	bx	
	;jae	short RET9

	; 20/05/2019 - Retro DOS v4.0

	; MSDOS 6.0
	xchg	bx,di
	call	IsEOF
	xchg	bx,di
	jae	short RET9

        XCHG    BX,DI
        INC     DX

	LOOP	SKPCLP			; RMFS
RET9:	
	CLC
        retn
NOCLUS:
        POP	ES
        INC	CX
        DEC	DX
        CLC

fndclus_retn:
        retn

;Break  <BUFSEC -- BUFFER A SECTOR AND SET UP A TRANSFER>
;--------------------------------------------------------------------------
;
; Procedure Name : BUFSEC
;
; Inputs:
;       AH = priority of buffer
;       AL = 0 if buffer must be read, 1 if no pre-read needed
;       ES:BP = Base of drive parameters
;       [CLUSNUM] = Physical cluster number
;       [SECCLUSPOS] = Sector position of transfer within cluster
;       [BYTCNT1] = Size of transfer
; Function:
;       Insure specified sector is in buffer, flushing buffer before
;       read if necessary.
; Outputs:
;       ES:DI = Pointer to buffer
;       SI = Pointer to transfer address
;       CX = Number of bytes
;       [NEXTADD] updated
;       [TRANS] set to indicate a transfer will occur
;       Carry set if error (user FAILed to I 24)
;--------------------------------------------------------------------------

BUFSEC:
        MOV     DX,[CLUSNUM]
        MOV     BL,[SECCLUSPOS]
	;mov	byte [ALLOWED],38h
        MOV     byte [ALLOWED],Allowed_FAIL+Allowed_RETRY+Allowed_IGNORE
        CALL    FIGREC
	call	GETBUFFR
        jc	short fndclus_retn

        MOV     BYTE [TRANS],1	; A transfer is taking place
        MOV     SI,[NEXTADD]
        MOV     DI,SI
        MOV     CX,[BYTCNT1]
        ADD     DI,CX
        MOV     [NEXTADD],DI
        LES     DI,[CURBUF]
	;or	byte [es:di+5],8
        OR      byte [ES:DI+BUFFINFO.buf_flags],buf_isDATA
	;;lea	di,[di+16] ; MSDOS 3.3 
	;lea	di,[di+20] ; MSDOS 6.0
        LEA     DI,[DI+BUFINSIZ]        ; Point to buffer
        ADD     DI,[BYTSECPOS]
        CLC
        retn

;Break   <BUFRD, BUFWRT -- PERFORM BUFFERED READ AND WRITE>

;---------------------------------------------------------------------------
;
; Procedure Name : BUFRD
;
; Do a partial sector read via one of the system buffers
; ES:BP Points to DPB
; Carry set if error (currently user FAILed to I 24)
;
; DS - set to DOSDATA
;
;----------------------------------------------------------------------------

	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; 20/05/2019 - Retro DOS v4.0
BUFRD:
        PUSH	ES
        xor	ax, ax			; pre-read sector
        CALL    BUFSEC
        JNC	short BUF_OK

BUF_IO_FAIL:				; this label used by BUFWRT also
        POP	ES
        JMP     SHORT RBUFPLACED

BUF_OK:
        MOV     BX,ES
        MOV     ES,[DMAADD+2]
        MOV     DS,BX
	XCHG    DI,SI
        SHR     CX,1
;M039
	; MSDOS 3.3
	;JNC	short EVENRD
	;MOVSB
;EVENRD:
	;REP     MOVSW

;	CX = # of whole WORDs ; CF=1 if odd # of bytes.
;       DS:SI-> Source within Buffer.
;       ES:DI-> Destination within Transfer memory block.

	; MSDOS 6.0
	rep	movsw			;Copy Buffer to Transfer memory.
	;adc	cx,0                    ;CX=1 if odd # of bytes, else CX=0.
	;rep	movsb                   ;Copy last byte.
	; 16/12/2022
	jnc	short EVENRD ; **** 20/05/2019
	movsb ; ****
	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;adc	cx,0
	;rep	movsb
;M039
EVENRD: ; ****
        POP	ES
;hkn; SS override
        LDS     DI,[SS:CURBUF]
	;;lea	bx,[di+16]
	;lea	bx,[di+20] ; MSDOS 6.0
	LEA     BX,[DI+BUFINSIZ]
        SUB     SI,BX                   ; Position in buffer
        call	PLACEBUF
	;cmp	si,[es:bp+2]
	CMP	SI,[ES:BP+DPB.SECTOR_SIZE] ; Read Last byte?
        JB	short RBUFPLACEDC	; No, leave buf where it is
;M039
	; MSDOS 3.3
	;call	PLACEHEAD               ; Make it prime candidate for chucking
                                        ;  even though it is MRU.
        ; MSDOS 6.0
	MOV	[ss:BufferQueue],DI	; Make it prime candidate for
;M039					; chucking even though it is MRU.

RBUFPLACEDC:
        CLC
RBUFPLACED:
	push	ss
	pop	ds
        retn

;----------------------------------------------------------------------------
;
; Procedure : BUFWRT
;
; Do a partial sector write via one of the system buffers
; ES:BP Points to DPB
; Carry set if error (currently user FAILed to I 24)
;
; DS - set to DOSDATA
;
;----------------------------------------------------------------------------

	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; 20/05/2019 - Retro DOS v4.0
BUFWRT:
        ;MOV     AX,[SECPOS]
        ; MSDOS 6.0
	;ADD	AX,1            	; Set for next sector
        ;MOV	[SECPOS],AX 		;F.C. >32mb	;AN000;
        ;ADC	word [SECPOS+2],0	;F.C. >32mb	;AN000;
        ; 24/09/2023
	inc	word [SECPOS]
	jnz	short bufw_secpos
	inc	word [SECPOS+2]
bufw_secpos:
	MOV	AX,[SECPOS+2]		;F.C. >32mb	;AN000;
        CMP	AX,[VALSEC+2]		;F.C. >32mb	;AN000;
        MOV	AL,1			;F.C. >32mb	;AN000;
        JA	short NOREAD		;F.C. >32mb	;AN000;
        JB	short _doread		;F.C. >32mb	;AN000;
        MOV	AX,[SECPOS]		;F.C. >32mb	;AN000;

	; MSDOS 3.3
	;INC	AX
	;MOV	[SECPOS],AX ; 09/09/2018

	; 20/05/2019
	; MSDOS 3.3 & MSDOS 6.0
        CMP     AX,[VALSEC]		; Has sector been written before?
        MOV     AL,1
        JA	short NOREAD		; Skip preread if SECPOS>VALSEC
_doread:
        XOR     AL,AL
NOREAD:
        PUSH	ES
        CALL    BUFSEC
	JC	short BUF_IO_FAIL
        MOV     DS,[DMAADD+2]
        SHR     CX,1
;M039
	; MSDOS 3.3
	;JNC	short EVENWRT ; 09/09/2018
	;MOVSB
;EVENWRT:
	;REP	MOVSW

;	CX = # of whole WORDs; CF=1 if odd # of bytes.
;       DS:SI-> Source within Transfer memory block.
;       ES:DI-> Destination within Buffer.

	; MSDOS 6.0
	rep	movsw			;Copy Transfer memory to Buffer.
	;adc	cx,0                    ;CX=1 if odd # of bytes, else CX=0.
	;rep	movsb                   ;Copy last byte.
	; 16/12/2022
	jnc	short EVENWRT ; **** 20/05/2019
	movsb ; ****
	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;adc	cx,0
	;rep	movsb
;M039
EVENWRT: ; ****
        POP	ES

;hkn; SS override
        LDS     BX,[SS:CURBUF]

	; MSDOS 6.0
        TEST	byte [BX+BUFFINFO.buf_flags],buf_dirty
					;LB. if already dirty		  ;AN000;
        JNZ	short yesdirty10	;LB.  don't increment dirty count ;AN000;
	call	INC_DIRTY_COUNT		;LB.				  ;AN000;
	
	;or	byte [bx+5],40h
        OR	byte [BX+BUFFINFO.buf_flags],buf_dirty
yesdirty10:
	;;lea	si,[bx+16]
	;lea	si,[bx+20] ; MSDOS 6.0
        LEA     SI,[BX+BUFINSIZ]
        SUB     DI,SI                   ; Position in buffer
;M039
	; MSDOS 3.3
	;MOV	SI,DI
	;MOV	DI,BX
	;call	PLACEBUF
	;;cmp	si,[es:bp+2]
	;CMP	SI,[ES:BP+DPB.SECTOR_SIZE] ; Written last byte?
	;JB	short WBUFPLACED	; No, leave buf where it is
	;call	PLACEHEAD               ; Make it prime candidate for chucking
                                        ;  even though it is MRU.
	; MSDOS 6.0
	;cmp	di,[es:bp+2]
	CMP	di,[ES:BP+DPB.SECTOR_SIZE] ; Written last byte?
        JB	short WBUFPLACED	; No, leave buf where it is
        MOV	[ss:BufferQueue],BX	; Make it prime candidate for
					; chucking even though it is MRU.
;M039

WBUFPLACED:
        CLC
	push	ss
	pop	ds
        retn

;Break   <NEXTSEC -- Compute next sector to read or write>
;---------------------------------------------------------------------------
;
; Procedure Name : NEXTSEC
;
; Compute the next sector to read or write
; ES:BP Points to DPB
;
;---------------------------------------------------------------------------

NEXTSEC:
	test	byte [TRANS],0FFh ; -1 
        JZ	short CLRET

        MOV     AL,[SECCLUSPOS]
        INC     AL
	;cmp	al,[es:bp+4]
        CMP     AL,[ES:BP+DPB.CLUSTER_MASK]
        JBE	short SAVPOS

        MOV     BX,[CLUSNUM]
        call	IsEOF
        JAE	short NONEXT

        call	UNPACK
        JC	short NONEXT
clusgot:
        MOV     [CLUSNUM],DI
        INC     word [LASTPOS]
        MOV     AL,0
SAVPOS:
        MOV     [SECCLUSPOS],AL
CLRET:
        CLC
        retn
NONEXT:
        STC
        retn

;Break	<OPTIMIZE -- DO A USER DISK REQUEST WELL>
;----------------------------------------------------------------------------
;
; Procedure Name : OPTIMIZE
;
; Inputs:
;       BX = Physical cluster
;       CX = No. of records
;       DL = sector within cluster
;       ES:BP = Base of drive parameters
;       [NEXTADD] = transfer address
; Outputs:
;       AX = No. of records remaining
;       BX = Transfer address
;       CX = No. or records to be transferred
;       DX = Physical sector address            (LOW)
;       [HIGH_SECTOR] = Physical sector address (HIGH)
;       DI = Next cluster
;       [CLUSNUM] = Last cluster accessed
;       [NEXTADD] updated
;       Carry set if error (currently user FAILed to I 24)
; ES:BP unchanged. Note that segment of transfer not set.
;
;---------------------------------------------------------------------------

	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
OPTIMIZE:
	PUSH    DX
        PUSH    BX
	;mov	al,[es:bp+4]
        MOV     AL,[ES:BP+DPB.CLUSTER_MASK]
        INC     AL              ; Number of sectors per cluster
        MOV     AH,AL
        SUB     AL,DL           ; AL = Number of sectors left in first cluster
        MOV     DX,CX
	;MOV	CX,0
	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	; 16/12/2022
	xor	cx,cx	; sub cx,cx
OPTCLUS:
; AL has number of sectors available in current cluster
; AH has number of sectors available in next cluster
; BX has current physical cluster
; CX has number of sequential sectors found so far
; DX has number of sectors left to transfer
; ES:BP Points to DPB
; ES:SI has FAT pointer

do_norm3:
        call	UNPACK
        JC	short OP_ERR
clusgot2:
	ADD	CL,AL
        ADC     CH,0
        CMP     CX,DX
        JAE	short BLKDON
        MOV     AL,AH
        INC     BX
        CMP     DI,BX
        JZ	short OPTCLUS
        DEC     BX
FINCLUS:
        MOV     [CLUSNUM],BX    ; Last cluster accessed
        SUB     DX,CX           ; Number of sectors still needed
        PUSH    DX
        MOV     AX,CX
	;mul	word[ES:BP+2]
        MUL	word [ES:BP+DPB.SECTOR_SIZE] 
				; Number of sectors times sector size
        MOV     SI,[NEXTADD]
        ADD     AX,SI           ; Adjust by size of transfer
        MOV     [NEXTADD],AX
        POP     AX              ; Number of sectors still needed
        POP     DX              ; Starting cluster
        SUB     BX,DX           ; Number of new clusters accessed
        ADD     [LASTPOS],BX
        POP     BX              ; BL = sector position within cluster
	call	FIGREC
        MOV     BX,SI
	; 24/09/2023
	; cf=0 (at the return of FIGREC)
	;CLC
        retn
OP_ERR:
        ADD     SP,4
	STC
        retn
BLKDON:
        SUB     CX,DX           ; Number of sectors in cluster we don't want
        SUB     AH,CL           ; Number of sectors in cluster we accepted
        DEC     AH              ; Adjust to mean position within cluster
        MOV     [SECCLUSPOS],AH
        MOV     CX,DX           ; Anyway, make the total equal to the request
        JMP     SHORT FINCLUS

;Break	<FIGREC -- Figure sector in allocation unit>
;---------------------------------------------------------------------------
;
; Procedure Name : FIGREC
;
; Inputs:
;       DX = Physical cluster number
;       BL = Sector position within cluster
;       ES:BP = Base of drive parameters
; Outputs:
;       DX = physical sector number           (LOW)
;       [HIGH_SECTOR] Physical sector address (HIGH)
; No other registers affected.
;
;---------------------------------------------------------------------------

	; 10/06/2019
	; 20/05/2019 - Retro DOS v4.0
	; DOSCODE:8D96h (MSDOS 6.21, MSDOS.SYS)
	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; DOSCODE:8D5Bh (MSDOS 5.0, MSDOS.SYS)	
FIGREC:
        PUSH    CX
	;mov	cl,[es:bp+5]
        MOV     CL,[ES:BP+DPB.CLUSTER_SHIFT]
        DEC     DX
        DEC     DX

	; MSDOS 3.3
	;SHL	DX,CL

;hkn; SS override HIGH_SECTOR
	; MSDOS 6.0
	MOV	word [SS:HIGH_SECTOR],0		;F.C. >32mb
	; 24/09/2023
	xor	ch,ch				;F.C. >32mb
	OR	CL,CL				;F.C. >32mb
	JZ	short noshift			;F.C. >32mb
	XOR	CH,CH				;F.C. >32mb
rotleft:					;F.C. >32mb
	CLC					;F.C. >32mb
	RCL	DX,1				;F.C. >32mb
	; 10/06/2019
	RCL	word [ss:HIGH_SECTOR],1		;F.C. >32mb
	LOOP	rotleft				;F.C. >32mb
noshift:
	; MSDOS 3.3 & MSDOS 6.0
        OR      DL,BL
	;add	dx,[es:bp+0Bh]
        ADD     DX,[ES:BP+DPB.FIRST_SECTOR]
	; MSDOS 6.0
	; 10/06/2019
	;ADC	word [ss:HIGH_SECTOR],0		;F.C. >32mb
	; 24/09/2023
	; cx=0
	ADC	word [ss:HIGH_SECTOR],cx ; 0

	; MSDOS 3.3 & MSDOS 6.0
	POP     CX
figrec_retn:
        retn

; 20/05/2019 - Retro DOS v4.0
; DOSCODE:8DC2h (MSDOS 6.21, MSDOS.SYS)

; 30/07/2018 - Retro DOS v3.0
; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 

;Break   <ALLOCATE -- Assign disk space>
;---------------------------------------------------------------------------
;
; Procedure Name : ALLOCATE - Allocate Disk Space
;
;   ALLOCATE is called to allocate disk clusters. The new clusters are
;   FAT-chained onto the end of the existing file.
;
;   The DPB contains the cluster # of the last free cluster allocated
;   (dpb_next_free). We start at this cluster and scan towards higher
;   numbered clusters, looking for the necessary free blocks.
;
;   Once again, fancy terminology gets in the way of correct coding. When
;   using next_free, start scanning AT THAT POINT and not the one following it.
;   This fixes the boundary condition bug when only free = next_free = 2.
;
;       If we get to the end of the disk without satisfaction:
;
;           if (dpb_next_free == 2) then we've scanned the whole disk.
;               return (insufficient_disk_space)
;           ELSE
;               dpb_next_free = 2; start scan over from the beginning.
;
;   Note that there is no multitasking interlock. There is no race when
;   examining the entrys in an in-core FAT block since there will be no
;   context switch. When UNPACK context switches while waiting for a FAT read
;   we are done with any in-core FAT blocks, so again there is no race. The
;   only special concern is that V2 and V3 MSDOS left the last allocated
;   cluster as "00"; marking it EOF only when the entire alloc request was
;   satisfied. We can't allow another activation to think this cluster is
;   free, so we give it a special temporary mark to show that it is, indeed,
;   allocated.
;
;   Note that when we run out of space this algorithem will scan from
;   dpb_next_free to the end, then scan from cluster 2 through the end,
;   redundantly scanning the later part of the disk. This only happens when
;   we run out of space, so sue me.
;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  A  T  T  E  R  S  O  N                ;
;                                                                          ;
;   The use of FATBYT and RESTFATBYT is somewhat mysterious. Here is the
;   explanation:
;
;   In the NUL file case (sf_firclus currently 0) ALLOCATE is called with
;   entry BX = 0. What needs to be done in this case is to stuff the cluster
;   number of the first cluster allocated in sf_firclus when the ALLOCATE is
;   complete. THIS VALUE IS SAVED TEMPORARILY IN CLUSTER 0, HENCE THE CURRENT
;   VALUE IN CLUSTER 0 MUST BE SAVED AND RESTORED. This is a side effect of
;   the fact that PACK and UNPACK don't treat requests for clusters 0 and 1 as
;   errors. This "stuff" is done by the call to PACK which is right before
;   the
;           LOOP   findfre         ; alloc more if needed
;   instruction when the first cluster is allocated to the nul file. The
;   value is recalled from cluster 0 and stored at sf_firclus at ads4:
;
;   This method is obviously useless (because it is non-reentrant) for
;   multitasking, and will have to be changed. Storing the required value on
;   the stack is recommended. Setting sf_firclus at the PACK of cluster 0
;   (instead of actually doing the PACK) is BAD because it doesn't handle
;   problems with INT 24 well.
;
;            C  A  V  E  A  T     P  A  T  T  E  R  S  O  N                ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;                                                                          ;
;       ENTRY   BX = Last cluster of file (0 if null file)
;               CX = No. of clusters to allocate
;               ES:BP = Base of drive parameters
;               [THISSFT] = Points to SFT
;
;       EXIT    'C' set if insufficient space
;                 [FAILERR] can be tested to see the reason for failure
;                 CX = max. no. of clusters that could be added to file
;               'C' clear if space allocated
;                 BX = First cluster allocated
;                 FAT is fully updated
;                 sf_FIRCLUS field of SFT set if file was null
;
;       USES    ALL but SI, BP

;callmagic  proc near
;       push    ds                             ;push segment of routine 
;       push    Offset MagicPatch              ;push offset for routine
;       retf                                   ;simulate jmp far
;                                              ;far return address is on
;                                              ;stack, so far return from
;                                              ;call will return this routine
;callmagic  endp


; 25/09/2023
%if 0
callmagic:
	push	ds
	push	MagicPatch
	retf	
%endif

ALLOCATE:
	; 10/09/2018
;BEGIN MAGICDRV MODIFICATIONS
;
;7/5/92 scottq
;
;This is the disk compression patch location which allows
;the disk compression software to fail allocations if the
;FAT would allows allocation, but the free space for compressed
;data would not.
;        
;;;	call    far ptr MAGICPATCH
;;; We cannot do a far call since we cannot have fix-ups[romdos,hidos],
;;; but we do know the segment and offset of the routine
;;; so simulate a far call to dosdata:magicpatch
;;; note dosassume above, so DS -> dosdata

	; MSDOS 6.0
        ;clc				;clear carry so we fall through
	;				;if no patch is present
	;push	cs			;push segment for far return
        ;call	callmagic		;this is a near call
        ;jnc	short Regular_Allocate_Path
	;jmp	Disk_Full_Return

; 25/09/2023
%if 0
	clc
	push	cs
	call	callmagic
	jnc	short Regular_Allocate_Path
	jmp	Disk_Full_Return
Regular_Allocate_Path:
%endif

	; 20/05/2019 - Retro DOS v4.0
;END MAGICDRV MODIFICATIONS

	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; DOSCODE:8D87h (MSDOS 5.0, MSDOS.SYS)

        PUSH    BX                      ; save (bx)
        XOR     BX,BX
	call	UNPACK
        MOV     [FATBYT],DI             ; save correct cluster 0 value
        POP     BX
        jc	short figrec_retn	; abort if error   [INTERR?]

        PUSH    CX
        PUSH    BX

        MOV     DX,BX
	;;mov	bx,[es:bp+1Ch]  ; MSDOS 3.3
	;mov	bx,[es:bp+1Dh]	; MSDOS 6.0
        mov     bx,[ES:BP+DPB.NEXT_FREE]
        cmp     bx,2
        ja	short FINDFRE

;   couldn't find enough free space beyond dpb_next_free, or dpb_next_free is
;   <2 or >dpb_max_clus. Reset it and restart the scan

ads1:
	;;mov	word [es:bp+1Ch],2 ; MSDOS 3.3
	;mov	word [es:bp+1Dh],2 ; MSDOS 6.0
        mov     word [ES:BP+DPB.NEXT_FREE],2
        mov     bx,1                    ; Counter next instruction so first
                                        ;       cluster examined is 2

;   Scanning both forwards and backwards for a free cluster
;
;       (BX) = forwards scan pointer
;       (CX) = clusters remaining to be allocated
;       (DX) = current last cluster in file
;       (TOS) = last cluster of file

FINDFRE:
        INC     BX
	;cmp	bx,[es:bp+0Dh]
        CMP	BX,[ES:BP+DPB.MAX_CLUSTER]
	ja	short ads7	; at end of disk
        call	UNPACK          ; check out this cluster
        jc	short ads4	; FAT error             [INTERR?]
        jnz	short FINDFRE	; not free, keep on truckin

;   Have found a free cluster. Chain it to the file
;
;       (BX) = found free cluster #
;       (DX) = current last cluster in file

	;;mov	[es:bp+1Ch],bx
	;mov	[es:bp+1Dh],bx ; MSDOS 6.0
        mov	[ES:BP+DPB.NEXT_FREE],bx ; next time start search here
        xchg    ax,dx           ; save (dx) in ax
        mov     dx,1            ; mark this free guy as "1"
	call	PACK            ; set special "temporary" mark
        jc	short ads4	; FAT error             [INTERR?]
	;;cmp	word [es:bp+1Eh],-1
        ;cmp	word [es:bp+1Fh],-1 ; MSDOS 6.0
	CMP	word [ES:BP+DPB.FREE_CNT],-1 ; Free count valid?
        JZ	short NO_ALLOC	; No
	;;dec	word [es:bp+1Eh]
        ;dec	word [es:bp+1Fh] ; MSDOS 6.0
        DEC     word [ES:BP+DPB.FREE_CNT] ; Reduce free count by 1
NO_ALLOC:
        xchg    ax,dx           ; (dx) = current last cluster in file
        XCHG    BX,DX
        MOV     AX,DX
	call	PACK            ; link free cluster onto file
                                ;  CAVEAT.. On Nul file, first pass stuffs
                                ;    cluster 0 with FIRCLUS value.
        jc	short ads4	; FAT error [INTERR?]
        xchg    BX,AX           ; (BX) = last one we looked at
        mov     dx,bx           ; (dx) = current end of file
        LOOP    FINDFRE         ; alloc more if needed

;   We've successfully extended the file. Clean up and exit
;
;       (BX) = last cluster in file

        MOV     DX,0FFFFH
	call	PACK            ; mark last cluster EOF

;   Note that FAT errors jump here to clean the stack and exit. This saves us
;   2 whole bytes. Hope its worth it...
;
;       'C' set if error
;       calling (BX) and (CX) pushed on stack

ads4:   
	POP     BX
        POP     CX              ; Don't need this stuff since we're successful
        jc	short figrec_retn
        call	UNPACK          ; Get first cluster allocated for return
                                ; CAVEAT... In nul file case, UNPACKs cluster 0.
        jc	short figrec_retn
	call	RESTFATBYT      ; Restore correct cluster 0 value
        jc	short figrec_retn
        XCHG    BX,DI           ; (DI) = last cluster in file upon our entry
        OR      DI,DI           ; clear 'C'
	jnz	short figrec_retn ; we were extending an existing file

;   We were doing the first allocation for a new file. Update the SFT cluster
;   info
dofastk:
	; 20/05/2019
	; MSDOS 6.0
	;push	dx ; * MSDOS 6.0
	;;mov	dl,[es:bp+0]
	;;MOV	DL,[ES:BP+DPB.DRIVE]	; get drive #
	;mov	dl,[es:bp]

	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	; DOSCODE:8DF9h (MSDOS 5.0, MSDOS.SYS)
	
	; 16/12/2022
	;push	dx ; *
	;mov	dl,[ES:BP+DPB.DRIVE] 
	; 15/12/2022
	;mov	dl,[es:bp]
	
	; MSDOS 3.3 & MSDOS 6.0
	PUSH	ES
	LES     DI,[THISSFT]
	;mov	[es:di+0Bh],bx
	MOV     [ES:DI+SF_ENTRY.sf_firclus],BX
	;;mov	[es:di+1Bh],bx ; MSDOS 3.3
	;mov	[es:di+35h],bx ; MSDOS 6.0
	MOV     [ES:DI+SF_ENTRY.sf_lstclus],BX
	POP	ES
	;retn

	;pop	dx ; * MSDOS 6.0

	; 16/12/2022
	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;pop	dx ; *

	retn	

;** we're at the end of the disk, and not satisfied. See if we've scanned ALL
;   of the disk...

ads7:   
	cmp	word [ES:BP+DPB.NEXT_FREE],2
	jnz	short ads1	; start scan from front of disk

;   Sorry, we've gone over the whole disk, with insufficient luck. Lets give
;   the space back to the free list and tell the caller how much he could have
;   had.  We have to make sure we remove the "special mark" we put on the last
;   cluster we were able to allocate, so it doesn't become orphaned.
;
;       (CX) = clusters remaining to be allocated
;       (TOS) = last cluster of file (before call to ALLOCATE)
;       (TOS+1) = # of clusters wanted to allocate

        POP     BX              ; (BX) = last cluster of file
        MOV     DX,0FFFFH
	call	RELBLKS         ; give back any clusters just alloced
        POP     AX              ; No. of clusters requested
                                ; Don't "retc". We are setting Carry anyway,
                                ;   Alloc failed, so proceed with return CX
                                ;   setup.
        SUB     AX,CX           ; AX=No. of clusters allocated
	call	RESTFATBYT      ; Don't "retc". We are setting Carry anyway,
                                ;   Alloc failed.
Disk_Full_Return:               ;label added for magic patch 8-6-92 scottq
        ; MSDOS 6.0
	MOV	byte [DISK_FULL],1 ;MS. indicating disk full
        STC
        retn

;-----------------------------------------------------------------------
;
; Procedure Name : RESTFATBYT
;
; SEE ALLOCATE CAVEAT
;       Carry set if error (currently user FAILed to I 24)
;-----------------------------------------------------------------------

RESTFATBYT:
        PUSH    BX
        PUSH    DX
        PUSH    DI
        XOR     BX,BX
        MOV     DX,[FATBYT]
	call	PACK
        POP     DI
        POP     DX
        POP     BX
; 16/12/2022
; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
;RELEASE_flush:
	retn

;Break	<RELEASE -- DEASSIGN DISK SPACE>
;---------------------------------------------------------------------------
;
; Procedure Name : RELEASE
;
; Inputs:
;       BX = Cluster in file
;       ES:BP = Base of drive parameters
; Function:
;       Frees cluster chain starting with [BX]
;       Carry set if error (currently user FAILed to I 24)
; AX,BX,DX,DI all destroyed. Other registers unchanged.
;
;-----------------------------------------------------------------------------

	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; 20/05/2019 - Retro DOS v4.0
RELEASE:
        XOR     DX,DX

	;entry	RELBLKS
RELBLKS:

;   Enter here with DX=0FFFFH to put an end-of-file mark in the first cluster
;   and free the rest in the chain.

	call	UNPACK
	jc	short RELEASE_flush
	jz	short RELEASE_flush
        MOV     AX,DI
        PUSH    DX
	call	PACK
        POP     DX
	jc	short RELEASE_flush
        OR      DX,DX
        JNZ	short NO_DEALLOC	; Was putting EOF mark
	;;cmp	word [es:bp+1Eh],-1 ; MSDOS 3.3
	;cmp	word [es:bp+1Fh],-1 ; MSDOS 6.0
	CMP     word [ES:BP+DPB.FREE_CNT],-1 ; Free count valid?
        JZ	short NO_DEALLOC	; No
        INC	word [ES:BP+DPB.FREE_CNT] ; Increase free count by 1
NO_DEALLOC:
        MOV     BX,AX
        dec     ax              ; check for "1"
	jz	short RELEASE_flush	; is last cluster of incomplete chain
	call	IsEOF
        JB	short RELEASE	; Carry clear if JMP not taken

	; 16/12/2022
; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
;%if 0
RELEASE_flush:
	; MSDOS 6.0
	mov	al,[es:bp]
	;MOV	AL,[ES:BP+DPB.DRIVE]
	push	si		; FLUSHBUF may trash these and we guarantee
	push	cx		;  them to be preserved.
	push	es
	push	bp
	call	FLUSHBUF	; commit buffers for this drive
	pop	bp
	pop	es
	pop	cx
	pop	si
;%endif
RET12:
	retn

;Break	<GETEOF -- Find the end of a file>
;------------------------------------------------------------------------
;
; Procedure Name : GETEOF
;
; Inputs:
;       ES:BP Points to DPB
;       BX = Cluster in a file
;       DS = CS
; Outputs:
;       BX = Last cluster in the file
;       Carry set if error (currently user FAILed to I 24)
; DI destroyed. No other registers affected.
;
;--------------------------------------------------------------------------

GETEOF:
	call	UNPACK
        jc	short RET12
        PUSH    BX
        MOV     BX,DI
	call	IsEOF
        POP     BX
        JAE     short RET12
        MOV     BX,DI
        JMP     short GETEOF

;============================================================================
; FCB.ASM, MSDOS 6.0, 1991
;============================================================================
; 30/07/2018 - Retro DOS v3.0
; 20/05/2019 - Retro DOS v4.0

;	TITLE	FCB - FCB parse calls for MSDOS
;	NAME	FCB

;**	FCB.ASM - Low level routines for parsing names into FCBs and analyzing
;		  filename characters
;
;	MakeFcb
;	NameTrans
;	PATHCHRCMP
;	GetLet
;	UCase
;	GetLet3
;	GetCharType
;	TESTKANJ
;	NORMSCAN
;	DELIM
;
;	Revision history:
;
;		A000  version 4.00  Jan. 1988
;	
;	M048 - access FILE_UCASE_TAB using DS rather than SS.

TableLook	EQU	-1

SCANSEPARATOR	EQU	1
DRVBIT		EQU	2
NAMBIT		EQU	4
EXTBIT		EQU	8

;----------------------------------------------------------------------------
;
; Procedure : MakeFcb
;
;----------------------------------------------------------------------------

	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; DOSCODE:8E77h (MSDOS 5.0, MSDOS.SYS)
MAKEFCB:
;hkn; SS override
	MOV	BYTE [SS:SpaceFlag],0
	XOR	DL,DL		; Flag--not ambiguous file name
	;test	al,2
	test	AL,DRVBIT	; Use current drive field if default?
	JNZ	short DEFDRV
	MOV	BYTE [ES:DI],0	; No - use default drive
DEFDRV:
	INC	DI
	MOV	CX,8
	;test	al,4
	test	AL,NAMBIT	; Use current name fields as default?
	XCHG	AX,BX		; Save bits in BX
	MOV	AL," "
	JZ	short FILLB	; If not, go fill with blanks
	ADD	DI,CX
	XOR	CX,CX		; Don't fill any
FILLB:
	REP	STOSB
	MOV	CL,3
	test	BL,EXTBIT	; Use current extension as default
	JZ	short FILLB2
	ADD	DI,CX
	XOR	CX,CX
FILLB2:
	REP	STOSB
	XCHG	AX,CX		; Put zero in AX
	STOSW
	STOSW			; Initialize two words after to zero
	SUB	DI,16		; Point back at start
	;test	bl,1
	test	BL,SCANSEPARATOR; Scan off separators if not zero
	JZ	short SKPSPC
	CALL	SCANB		; Peel off blanks and tabs
	CALL	DELIM		; Is it a one-time-only delimiter?
	JNZ	short NOSCAN
	INC	SI		; Skip over the delimiter
SKPSPC:
	CALL	SCANB		; Always kill preceding blanks and tabs
NOSCAN:
	CALL	GETLET
	JBE	short NODRV	; Quit if termination character
	CMP	BYTE [SI],":"	; Check for potential drive specifier
	JNZ	short NODRV
	INC	SI		; Skip over colon
	SUB	AL,"@"          ; Convert drive letter to drive number (A=1)
	JBE	short BADDRV	; Drive letter out of range

	PUSH	AX
	call	GetVisDrv
	POP	AX
	JNC	short HAVDRV

	; 20/05/2019 - Retro DOS v4.0
	; MSDOS 6.0
;hkn; SS override
	CMP	byte [SS:DrvErr],error_not_DOS_disk ; 1Ah
					; if not FAT drive ;AN000;
	JZ	short HAVDRV		; assume ok	   ;AN000;
BADDRV:
	MOV	DL,-1
HAVDRV:
	STOSB			; Put drive specifier in first byte
	INC	SI
	DEC	DI		; Counteract next two instructions
NODRV:
	DEC	SI		; Back up
	INC	DI		; Skip drive byte

	;entry	NORMSCAN
NORMSCAN:
	MOV	CX,8
	CALL	GETWORD 	; Get 8-letter file name
	CMP	BYTE [SI],"."
	JNZ	short NODOT
	INC	SI		; Skip over dot if present

	; 24/09/2023
	;mov	cx,3
	mov	cl,3	; ch=0

	; MSDOS 6.0
;hkn; SS override
	;TEST	word [SS:DOS34_FLAG],DBCS_VOLID2 ; 100h ;AN000;
	; 10/06/2019
	test	byte [SS:DOS34_FLAG+1],(DBCS_VOLID2>>8) ; 1
	JZ	short VOLOK				;AN000;
	MOVSB			; 2nd byte of DBCS	;AN000;
	; 24/09/2023
	;MOV	CX,2					;AN000;
	dec	cx  ; cx=2
	;JMP	SHORT contvol				;AN000;
VOLOK:
	;MOV	CX,3		; Get 3-letter extension
contvol:
	CALL	MUSTGETWORD
NODOT:
	MOV	AL,DL

	; MSDOS 6.0
	;and	word [ss:DOS34_FLAG],0FEFFh
	; 18/12/2022
	and	byte [ss:DOS34_FLAG+1],0FEh ; (~DBCS_VOLID2)>>8
	;and	word [ss:DOS34_FLAG],~DBCS_VOLID2 ; ### BUG FIX ###

	retn

NONAM:
	ADD	DI,CX
	DEC	SI
	retn

GETWORD:
	CALL	GETLET		
	JBE	short NONAM	; Exit if invalid character
	DEC	SI

;	UGH!!! Horrible bug here that should be fixed at some point:
;	If the name we are scanning is longer than CX, we keep on reading!

MUSTGETWORD:
	CALL	GETLET

;	If spaceFlag is set then we allow spaces in a pathname

;IF NOT TABLELOOK
;	JB	short FILLNAM  ; MSDOS 3.3
;ENDIF
	JNZ	short MustCheckCX

;hkn; SS override
	test	BYTE [SS:SpaceFlag],0FFh
	JZ	short FILLNAM
	CMP	AL," "
	JNZ	short FILLNAM

MustCheckCX:
	JCXZ	MUSTGETWORD
	DEC	CX
	CMP	AL,"*"          ; Check for ambiguous file specifier
	JNZ	short NOSTAR
	MOV	AL,"?"
	REP	STOSB
NOSTAR:
	STOSB
	CMP	AL,"?"
	JNZ	short MUSTGETWORD
	OR	DL,1		; Flag ambiguous file name
	JMP	short MUSTGETWORD
FILLNAM:
	MOV	AL," "
	REP	STOSB
	DEC	SI
	retn

SCANB:
	LODSB
	CALL	SPCHK
	JZ	short SCANB
	DEC	SI
scanb_retn:
	retn

;----------------------------------------------------------------------------
;
; Procedure Name : NameTrans
;
; NameTrans is used by FindPath to scan off an element of a path. We must
; allow spaces in pathnames
;
;   Inputs:	DS:SI points to start of path element
;   Outputs:	Name1 has unpacked name, uppercased
;		ES = DOSGroup
;		DS:SI advanced after name
;   Registers modified: DI,AX,DX,CX
;
;----------------------------------------------------------------------------

	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; 20/05/2019 - Retro DOS v4.0
NameTrans:
;hkn; SS override
	MOV	BYTE [SS:SpaceFlag],1
	push	ss
	pop	es

;hkn; NAME1 is in DOSDATA
	MOV	DI,NAME1
	PUSH	DI
	MOV	AX,'  '
	MOV	CX,5
	STOSB
	REP	STOSW		; Fill "FCB" at NAME1 with spaces
	XOR	AL,AL		; Set stuff for NORMSCAN
	MOV	DL,AL
	STOSB
	POP	DI

	CALL	NORMSCAN

;hkn; SS override for NAME1
	CMP	byte [SS:NAME1],0E5H
	jnz	short scanb_retn
	MOV	byte [SS:NAME1],5 ; Magic name translation
	retn

;Break	<GETLET, DELIM -- CHECK CHARACTERS AND CONVERT>
;============================================================================

; 20/05/2019 - Retro DOS v4.0
; DOSCODE:8FD2h (MSDOS 6.21, MSDOS.SYS)

;If TableLook

;hkn; Table	SEGMENT
;	PUBLIC	CharType
;----------------------------------------------------------------------------

; Character type table for file name scanning
; Table provides a mapping of characters to validity bits.
; Four bits are provided for each character. Values 7Dh and above
; have all bits set, so that part of the table is chopped off, and
; the translation routine is responsible for screening these values.
; The bit values are defined in DOSSYM.INC

;	      ; ^A and NUL
;CharType:
;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
;	      ; ^C and ^B
;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
;	      ; ^E and ^D
;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
;	      ; ^G and ^F
;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
;	      ; TAB and BS
;	 db   LOW ((NOT FFCB+FCHK+FDELIM+FSPCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
;	      ; ^K and ^J
;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
;	      ; ^M and ^L
;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
;	      ; ^O and ^N
;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
;	      ; ^Q and ^P
;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
;	      ; ^S and ^R
;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
;	      ; ^U and ^T
;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
;	      ; ^W and ^V
;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
;	      ; ^Y and ^X
;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
;	      ; ESC and ^Z
;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
;	      ; ^] and ^\
;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
;	      ; ^_ and ^^
;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
;	      ; ! and SPACE
;	 db   LOW (NOT FCHK+FDELIM+FSPCHK)
;	      ; # and "
;	 db   LOW (NOT FFCB+FCHK)
;	      ; $ - )
;	 db   3 dup (0FFh)
;	      ; + and *
;	 db   LOW ((NOT FFCB+FCHK+FDELIM) SHL 4) OR 0Fh
;	      ; - and '
;	 db   NOT (FFCB+FCHK+FDELIM)
;	      ; / and .
;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FCHK) AND 0Fh
;	      ; 0 - 9
;	 db   5 dup (0FFh)
;	      ; ; and :
;	 db   LOW ((NOT FFCB+FCHK+FDELIM) SHL 4) OR LOW (NOT FFCB+FCHK+FDELIM) AND 0Fh
;	      ; = and <
;	 db   LOW ((NOT FFCB+FCHK+FDELIM) SHL 4) OR LOW (NOT FFCB+FCHK+FDELIM) AND 0Fh
;	      ; ? and >
;	 db   NOT FFCB+FCHK+FDELIM
;	      ; A - Z
;	 db   13 dup (0FFh)
;	      ; \ and [
;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR 0Fh
;	      ; ^ and ]
;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
;	      ; _ - {
;	 db   15 dup (0FFh)
;	      ; } and |
;	 db   NOT FFCB+FCHK+FDELIM

;CharType_last equ ($ - CharType) * 2	; This is the value of the last
;					; character in the table

;FCHK	equ 1		; normal name char, no chks needed
;FDELIM	equ 2		; is a delimiter
;FSPCHK	equ 4		; set if character is not a space or equivalent
;FFCB	equ 8		; is valid in an FCB

; DOSCODE:8FD2h (MSDOS 6.21, MSDOS.SYS)
;----------------------------------------------------------------------------
; DOSCODE:8F76h (MSDOS 5.0, MSDOS.SYS)

CharType: ; 63 bytes
        db  66h, 66h, 66h, 66h, 06h, 66h, 66h, 66h ; 0-7
	db  66h, 66h, 66h, 66h, 66h, 66h, 66h, 66h ; 8-15
	db 0F8h,0F6h,0FFh,0FFh,0FFh, 4Fh,0F4h, 6Eh ; 16-23
	db 0FFh,0FFh,0FFh,0FFh,0FFh, 44h, 44h,0F4h ; 24-31
	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh ; 32-39
	db 0FFh,0FFh,0FFh,0FFh,0FFh, 6Fh, 66h,0FFh ; 40-47
	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh ; 48-55
	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0F4h	   ; 56-62

CharType_last equ ($ - CharType) * 2

; Offset 12CAh of IBMDOS.COM (MSDOS 3.3), 1987
;----------------------------------------------------------------------------
;CharType:
;       db 0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h
;	db 0F6h,0F0h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h
;	db 0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h
;	db 0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h
;	db 0F8h,0FFh,0F6h,0FFh,0FFh,0FFh,0FFh,0FFh
;	db 0FFh,0FFh,0FFh,0F4h,0F4h,0FFh,0FEh,0F6h
;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
;	db 0FFh,0FFh,0F4h,0F4h,0F4h,0F4h,0F4h,0FFh
;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
;	db 0FFh,0FFh,0FFh,0F6h,0F6h,0F6h,0FFh,0FFh
;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
;	db 0FFh,0FFh,0FFh,0FFh,0F4h,0FFh,0FFh,0FFh
;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
;	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh

;hkn; Table	ENDS

;ENDIF

; 20/05/2019 - Retro DOS v4.0
; DOSCODE:9011h (MSDOS 6.21, MSDOS.SYS)

; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:8FB5h (MSDOS 5.0, MSDOS.SYS)

;----------------------------------------------------------------------------
;
; Procedure Names : GetLet, UCase, GetLet3
;
; These routines take a character, convert it to upper case, and check
; for delimiters.  Three different entry points:
;	GetLet -  DS:[SI] = character to convert
;	UCase  -  AL = character to convert
;	GetLet3 - AL = character
;		  [BX] = translation table to use
;
;	Exit (in all cases) : AL = upper case character
;			      CY set if char is control char other than TAB
;			      ZF set if char is a delimiter
;	Uses : AX, flags
;
; NOTE: This routine exists in a fast table lookup version, and a slow
; inline version.  Return with carry set is only possible in the inline
; version. The table lookup version is the one in use.
;
;----------------------------------------------------------------------------

; This entry point has character at [SI]

	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5517h
GETLET:	
	LODSB

; This entry point has character in AL

	;entry	UCase
UCase:	
	; 09/08/2018
	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5518h
_UCase:
	PUSH	BX
	MOV	BX,FILE_UCASE_TAB+2

; Convert the character in AL to upper case

gl_0:
	CMP	AL,"a"
	JB	short gl_2	; Already upper case, go check type
	CMP	AL,"z"
	JA	short gl_1
	SUB	AL,20H		; Convert to upper case

; Map European character to upper case

gl_1:
	CMP	AL,80H
	JB	short gl_2	; Not EuroChar, go check type
	SUB	AL,80H		; translate to upper case with this index

	; M048 - Start 
	; Lantastic call Ucase thru int 2f without setting SS to DOSDATA.
	; So we shall set up DS and to access FILE_UCASE_TAB in BX and also 
	; preserve it.

	; 09/08/2018 - Retro DOS v3.0
	; MSDOS 3.3
	;;XLAT	BYTE [CS:BX]	; ds as file_ucase_tab is in DOSDATA
	;CS	XLAT

	; 20/05/2019 - Retro DOS v4.0

	; MSDOS 6.0
	push	ds
	;getdseg <ds>
	mov	ds,[cs:DosDSeg]
	XLAT			; ds as file_ucase_tab is in DOSDATA
	pop	ds

	; M048 - End

; Now check the type

;If TableLook
gl_2:
	; 20/05/2019 - Retro DOS v4.0
	PUSH	AX

	; MSDOS 3.3
	;mov	bx,CharType
	;; 09/08/2018
	;;xlat	byte [cs:bx]
	;cs	xlat	
	
	; MSDOS 6.0
	CALL	GetCharType	; returns type flags in AL
	
	;test	al,1	
	TEST	AL,FCHK 	; test for normal character
	POP	AX

	POP	BX
	RETN

; This entry has character in AL and lookup table in BX

	; MSDOS 6.0
;	;entry GetLet3
GETLET3: ; 10/08/2018
	PUSH	BX
	JMP	short gl_0
;ELSE
;
;gl_2:
;	POP	BX
;	CMP	AL,"."
;	retz
;	CMP	AL,'"'
;	retz
;	CALL	PATHCHRCMP
;	retz
;	CMP	AL,"["
;	retz
;	CMP	AL,"]"
;	retz
;ENDIF

;---------------------------------------------------------------------
;
; DELIM - check if character is a delimiter
;	Entry : AX = character to check
;	Exit  : ZF set if character is not a delimiter
;	Uses  : Flags
;
;--------------------------------------------------------------------

	;entry	DELIM
DELIM:
;IF TableLook
	; 20/05/2019 - Retro DOS v4.0
	PUSH	AX

	; MSDOS 3.3
	;push	bx
	;mov	bx,CharType
	;;09/08/2018
	;;xlat	byte [cs:bx]
	;cs	xlat
	;pop	bx

	; MSDOS 6.0
	CALL	GetCharType
	
	;test	al,2
	TEST	AL,FDELIM
	POP	AX
	RETN
;ELSE
;	CMP	AL,":"
;	retz
;
;	CMP	AL,"<"
;	retz
;	CMP	AL,"|"
;	retz
;	CMP	AL,">"
;	retz
;
;	CMP	AL,"+"
;	retz
;	CMP	AL,"="
;	retz
;	CMP	AL,";"
;	retz
;	CMP	AL,","
;	retz
;ENDIF

;-------------------------------------------------------------------------
;
;  SPCHK - checks to see if a character is a space or equivalent
;	Entry : AL = character to check
;	Exit  : ZF set if character is a space
;	Uses  : flags
;
;-------------------------------------------------------------------------

	;entry SPCHK
SPCHK:
;IF TableLook
	; 20/05/2019 - Retro DOS v4.0
	PUSH	AX

	; MSDOS 3.3
	;push	bx
	;mov	bx,CharType
	;; 09/08/2018
	;;xlat	byte [cs:bx]
	;cs	xlat
	;pop	bx

	; MSDOS 6.0
	CALL	GetCharType
	
	;test	al,4
	TEST	AL,FSPCHK
	POP	AX
	RETN
;ELSE
;	CMP	AL,9		; Filter out tabs too
;	retz
;; WARNING! " " MUST be the last compare
;	CMP	AL," "
;	return
;ENDIF

;-------------------------------------------------------------------------
;
;  GetCharType - return flag bits indicating character type
;	Bits are defined in DOSSYM.INC. Uses lookup table
;	defined above at label CharType.
;
;	Entry : AL = character to return type flags for
;	Exit  : AL = type flags
;	Uses  : AL, flags
;
;-------------------------------------------------------------------------

	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)

	; 20/05/2019 - Retro DOS v4.0
	; MSDOS 6.0
GetCharType:
	;cmp	al,7Eh
	cmp	al,CharType_last 	; beyond end of table?
	jae	short gct_90		; return standard value

	push	bx
	mov	bx,CharType		; load lookup table
	shr	al,1			; adjust for half-byte table entry size
	;xlat	cs:[bx] 		; get flags
	cs	xlat	
	pop	bx

; carry clear from previous shift means we want the low nibble.  Otherwise
; we have to shift the flags down to the low nibble

	jnc	short gct_80		; carry clear, no shift needed

	shr	al,1			; we want high nibble, shift it down
	shr	al,1
	shr	al,1
	shr	al,1
gct_80:
	and	al,0Fh			; clear the unused nibble
	retn
gct_90:
	mov	al,0Fh			; set all flags
	retn

;----------------------------------------------------------------------------
;
; Procedure : PATHCHRCMP
;
;----------------------------------------------------------------------------

PATHCHRCMP:
	CMP	AL,'/'
	JBE	short PathRet
	CMP	AL,'\'
	retn
GotFor:
	MOV	AL,'\'
	retn
PathRet:
	JZ	short GotFor
	retn

;============================================================================
; MSCRTLC.ASM, MSDOS 6.0, 1991
;============================================================================
; 30/07/2018 - Retro DOS v3.0
; 29/04/2019 - Retro DOS v4.0

; 15/03/2018 - Retro DOS v2.0 (MSDOS 2.11, CTRLC.ASM, 1983)

;**	MSCTRLC.ASM - ^C and error handler for MSDOS

;	TITLE	Control C detection, Hard error and EXIT routines
;	NAME	IBMCTRLC

;**	Low level routines for detecting special characters on CON input,
;	the ^C exit/int code, the Hard error INT 24 code, the
;	process termination code, and the INT 0 divide overflow handler.
;
;	FATAL
;	FATAL1
;	reset_environment
;	DSKSTATCHK
;	SPOOLINT
;	STATCHK
;	CNTCHAND
;	DIVOV
;	CHARHARD
;	HardErr
;
;	Revision history:
;
;	    AN000	version 4.0   Jan 1988
;	    A002	PTM    -- dir >lpt3 hangs
;	    A003	PTM 3957- fake version for IBMCAHE.COM
;
; 	M011: NEC's 8086 clone chip uses Intel's undocumented bit number in
;	      flags register. In order to return to user normally DOS used to
;	      move F202 into flags, which sets bit number 1 in flags uncondit-
;	      ionally. Now it is modified to maintain the state of bit 1.
;
; 	M024: suppressed fail and ignore options if not in the middle of int 
;	      24 and if Ctrl P or ctrl printscrn is pressed in routine 
;	      charhard.

; 29/04/2019 - Retro DOS v4.0
	; MSDOS 6.0
;		public	LowInt23Addr		
LowInt23Addr: ;	LABEL	DWORD
	DW	LowInt23, 0

;		public	LowInt24Addr
LowInt24Addr: ;	LABEL	DWORD
	DW	LowInt24, 0

;		public	LowInt28Addr
LowInt28Addr: ;	LABEL	DWORD
	DW	LowInt28, 0

;Break	<Checks for ^C in CON I/O>

; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; 05/05/2019 - Retro DOS v4.0

;---------------------------------------------------------------------------
;
; Procedure Name : DSKSTATCHK
;
; Check for ^C if only one level in
;
;---------------------------------------------------------------------------

        ;procedure DSKSTATCHK,NEAR ; Check for ^C if only one level in

DSKSTATCHK:        
	;CMP	BYTE [INDOS],1
        CMP     BYTE [SS:INDOS],1 ; 15/03/2018
	;retnz			; Do NOTHING
	; 16/12/2022
	JNZ	SHORT _RET37 ; Retro DOS v2.0 - 04/03/2018         
	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;jz	short _RET37 ; dskstatchk1
	;retn
;_RET37:
;dskstatchk1:
	PUSH    CX
        PUSH    ES
        PUSH    BX
        PUSH    DS
        PUSH    SI
        
	;PUSH	CS
        ;POP	ES
        ;PUSH	CS
        ;POP	DS

	MOV	BX,SS		; SS is DOSDATA. ES:BX must be set up
	MOV	ES,BX		; for deviocall2
	MOV	DS,BX

	; 16/12/2022
	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)

	; 05/05/2019
	;MOV	BYTE [ss:DSKSTCOM],DEVRDND
        ;MOV	BYTE [ss:DSKSTCALL],DRDNDHL
	;mov	word [ss:DSKSTST],0

	; 16/12/2022
	; 25/06/2019
	MOV	BYTE [DSKSTCOM],DEVRDND	 ; 5
        MOV	BYTE [DSKSTCALL],DRDNDHL ; 14
	mov	word [DSKSTST],0

        MOV     BX,DSKSTCALL

	;LDS	SI,[ss:BCON]
        ; 25/062019
	lds	si,[BCON]

; 16/12/2022
;	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
;	mov	byte [ss:DSKSTCOM],DEVRDND  ; 5
;       mov	byte [ss:DSKSTCALL],DRDNDHL ; 14
;	mov	word [ss:DSKSTST],0
;	mov	bx,DSKSTCALL
;	lds	si,[ss:BCON]

	CALL	DEVIOCALL2
 	; 15/03/2018
	;;test	word [ss:DSKSTST],200h
        ;TEST	WORD [SS:DSKSTST],STBUI
	; 05/05/2019
	test	byte [ss:DSKSTST+1],(STBUI>>8) ; 2
	jz	short _GotCh		; No characters available

        XOR     AL,AL                   ; Set zero
RET36:
        POP     SI
        POP     DS
        POP     BX
        POP     ES
        POP     CX
	; 16/12/2022
	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
_RET37:
        RETN

_GotCh:
        MOV     AL,[SS:DSKCHRET]	; SS override

        CMP     AL,"C"-"@" ; cmp al,3
        JNZ     SHORT RET36
        MOV     BYTE [SS:DSKSTCOM],DEVRD
        MOV     BYTE [SS:DSKSTCALL],DRDWRHL
        MOV     [SS:DSKCHRET],CL
	; 09/09/2018
	MOV	word [SS:DSKSTST],0
	MOV	word [SS:DSKSTCNT],1
	CALL	DEVIOCALL2              ; Eat the ^C
        POP     SI
        POP     DS
        POP     BX                      ; Clean stack
        POP     ES
        POP     CX
        JMP	CNTCHAND ; 10/08/2018

	; 05/05/2019
NOSTOP:
	; MSDOS 6.0
	CMP	AL,"P"-"@"
	JNZ	short check_next
				    	; SS override
	CMP	BYTE [SS:SCAN_FLAG],0	; ALT_Q ?
	JZ	short INCHKJ		; no
check_end:	; 24/09/2023
	retn
check_next:
	;IF	NOT TOGLPRN
	;CMP	AL,"N"-"@"
	;JZ	short INCHKJ
	;ENDIF

	CMP	AL,"C"-"@"
	; 24/09/2023
	;JZ	short INCHKJ
;check_end:
	;retn
	jnz	short check_end

	; 24/09/2023
	; 08/09/2018
INCHKJ:	; 10/08/2018
	jmp	INCHK

	; MSDOS 3.3
        ;CMP     AL,"P"-"@"  ; cmp al,16
        ;JZ	short INCHKJ

	; 15/04/2018
        ;;IF	NOT TOGLPRN
        ;CMP	AL,"N"-"@"
        ;JZ	SHORT INCHKJ
        ;;ENDIF
	
	;CMP     AL,"C"-"@"  ; cmp al,3
        ;JZ	short INCHKJ
	;RETN

;	; 08/09/2018
;INCHKJ:; 10/08/2018
;	JMP	INCHK

;----------------------------------------------------------------------------
;
; Procedure Name : SpoolInt
;
; SpoolInt - signal processes that the DOS is truly idle. We are allowed to
; do this ONLY if we are working on a 1-12 system call AND if we are not in
; the middle of an INT 24.
;
;----------------------------------------------------------------------------

SPOOLINT:
        PUSHF
	; 15/03/2018
        CMP     BYTE [SS:IDLEINT],0	; SS override
        JZ      SHORT POPFRET
        CMP     BYTE [SS:ERRORMODE],0
        JNZ     SHORT POPFRET		;No spool ints in error mode

	; 30/07/2018

	; Note that we are going to allow an external program to issue system 
	; calls at this time. We MUST preserve IdleInt across this.

	PUSH	WORD [SS:IDLEINT]

	; 05/05/2019 - Retro DOS v4.0
 
	; MSDOS 6.0
	cmp	byte [SS:DosHasHMA],0	; Q: is dos running in HMA (M021)
	jne	short do_low_int28	; Y: the int must be done from low mem
	INT	int_spooler  ; int 28h 	; N: Execute user int 28 handler
	jmp	short spool_ret_addr

do_low_int28:
	;call	far [ss:LowInt28Addr]
	call	far [cs:LowInt28Addr]	; 05/05/2019

spool_ret_addr:
	;INT	int_spooler		; INT 28h

	POP	WORD [SS:IDLEINT]
POPFRET:
        POPF
_RET18:  
	RETN

; 05/05/2019 - Retro DOS v4.0
; DOSCODE:9137h (MSDOS 6.21, MSDOS.SYS)
; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:90DBh (MSDOS 5.0, MSDOS.SYS)

;----------------------------------------------------------------------------
;
; Procedure Name : STATCHK
;
;----------------------------------------------------------------------------

STATCHK:
        CALL	DSKSTATCHK              ; Allows ^C to be detected under
                                        ; input redirection
        PUSH    BX
        XOR     BX,BX
        CALL	GET_IO_SFT
        POP     BX
        JC      SHORT _RET18

        MOV     AH,1
        CALL	IOFUNC
        JZ      SHORT SPOOLINT
        CMP     AL,'S'-'@'
        JNZ     SHORT NOSTOP

	; 05/05/2019
	; MSDOS 6.0			; SS override
	CMP	BYTE [SS:SCAN_FLAG],0	; AN000; ALT_R ?
	JNZ	short check_end		; AN000; yes

        XOR     AH,AH
        CALL	IOFUNC                  ; Eat Cntrl-S
        JMP     SHORT PAUSOSTRT
PRINTOFF:
PRINTON:
	NOT	BYTE [SS:PFLAG] ; 14/03/2018

	; 30/07/2018 - Retro DOS v3.0
	PUSH	BX
	MOV	BX,4
	call	GET_IO_SFT
	POP	BX
	jc	short _RET18
	PUSH	ES
	PUSH	DI
	PUSH	DS
	POP	ES
	MOV	DI,SI			; ES:DI -> SFT
	;test	word [es:di+5],800h
	;TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_net_spool
	; 05/05/2019
	test	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_net_spool>>8)
	JZ	short NORM_PR 		; Not redirected, echo is OK

	;Callinstall NetSpoolEchoCheck,MultNet,38,<AX>,<AX> 
					; See if allowed
	push	ax
	mov	ax,1126h
	int	2Fh	; Multiplex - NETWORK REDIRECTOR - ???
			; Return: CF set on error, AX = error code
			; STACK unchanged
	pop	ax

	JNC	short NORM_PR 		; Echo is OK

					; SS override
	MOV	BYTE [SS:PFLAG],0	; If not allowed, disable echo

	;Callinstall NetSpoolClose,MultNet,36,<AX>,<AX> ; and close

	push    ax
	mov     ax,1124h
	int     2Fh	; Multiplex - NETWORK REDIRECTOR - ???
			; ES:DI -> SFT, SS = DOS CS
	pop     ax

	JMP	SHORT RETP6
NORM_PR:
	CMP	BYTE [SS:PFLAG],0	; SS override
	JNZ	short PRNOPN
	call	DEV_CLOSE_SFT
	JMP	SHORT RETP6
PRNOPN:
	call	DEV_OPEN_SFT
RETP6:
	POP	DI
	POP	ES
STATCHK_RETN:
        RETN
PAUSOLP:
        CALL    SPOOLINT
PAUSOSTRT:
        MOV     AH,1
        CALL	IOFUNC
        JZ      SHORT PAUSOLP
INCHK:
        PUSH    BX
        XOR     BX,BX
        CALL	GET_IO_SFT
        POP     BX
        JC      SHORT STATCHK_RETN ; 30/07/2018
        XOR     AH,AH
        CALL	IOFUNC
	; 30/07/2018
	; MSDOS 3.3
        ;CMP	AL,'P'-'@' ;cmp al,16
        ;JNZ	SHORT NOPRINT

	;cmp	byte [SS:SCAN_FLAG],0
	;JZ	SHORT PRINTON	
	;mov	byte [ss:SCAN_FLAG],0

	; 05/05/2019
	; MSDOS 6.0
	CMP	AL,"P"-"@"
	;;;;  7/14/86	ALT_Q key fix
	JZ	short PRINTON		; no! must be CTRL_P
;NOPRINT:	
	;IF	NOT TOGLPRN
	;CMP	AL,"N"-"@"
	;JZ	short PRINTOFF
	;ENDIF
	CMP	AL,"C"-"@" ; cmp al,3 
	;retnz
	jnz	short STATCHK_RETN

	; !! NOTE: FALL THROUGH !!

;---------------------------------------------------------------------------
;
; Procedure Name : CNTHAND ( CTRLC_C HANDLER )
;
; "^C" and CR/LF is printed. Then the user registers are restored and the
; user CTRL-C handler is executed. At this point the top of the stack has 1)
; the interrupt return address should the user CTRL-C handler wish to allow
; processing to continue; 2) the original interrupt return address to the code
; that performed the function call in the first place. If the user CTRL-C
; handler wishes to continue, it must leave all registers unchanged and RET
; (not IRET) with carry CLEAR. If carry is SET then an terminate system call
; is simulated.
;
;---------------------------------------------------------------------------

CNTCHAND:
	; MSDOS 6.0			; SS override
					; AN002; from RAWOUT
	;TEST	word [SS:DOS34_FLAG],CTRL_BREAK_FLAG  
	;JNZ	short around_deadlock 	; AN002;

	; 05/05/2019 - Retro DOS v4.0
	; (MSDOS 6.21 MSDOS.SYS DOSCODE:91C4h, 29/12/2022)
	TEST	byte [SS:DOS34_FLAG+1],(CTRL_BREAK_FLAG>>8)  ; 2 
	JNZ	short around_deadlock 	; AN002;

        MOV     AL,3			; Display "^C"
        CALL	BUFOUT
        CALL	CRLF
around_deadlock:
        PUSH    SS
        POP     DS
        CMP     BYTE [CONSWAP],0
        JZ      SHORT NOSWAP
        CALL	SWAPBACK
NOSWAP:
	CLI				; Prepare to play with stack
	MOV	SS,[USER_SS]		; User stack now restored
	MOV	SP,[USER_SP]
        CALL	restore_world       ; User registers now restored

	; 30/07/2018 - Retro DOS v3.0 
	; MSDOS 3.3 (IBMDOS.COM - Offset 56ACh)
        ; 14/03/2018 - Retro DOS v2.0
	;MOV	BYTE [CS:INDOS],0	
        ;MOV	BYTE [CS:ERRORMODE],0
        ;MOV	[CS:ConC_Spsave],SP
	;clc	;30/07/2018
        ;INT	int_ctrl_c ; 23h    ; Execute user Ctrl-C handler
	;;int	23h	; DOS - CONTROL "C" EXIT ADDRESS
			; Return: return via RETF 2 with CF set
			; DOS will abort program with errorlevel 0
			; else
			; interrupted DOS call continues

	; 05/05/2019 - Retro DOS v4.0
	; MSDOS 6.0 (MSDOS 6.21, MSDOS.SYS,91ECh) 

	; CS was used to address these variables. We have to use DOSDATA
	
	pop	es ; *	; MSDOS 6.21 (MSDOS.SYS, DOSCODE:91ECh)
			; (pop es, after 'call restore_world')	
	push	ds
	;getdseg <ds>			; ds -> dosdata
	mov	ds,[cs:DosDSeg]
	mov	byte [INDOS],0		; Go to known state
	mov	byte [ERRORMODE],0
	mov	[ConC_Spsave],SP	; save his SP
	; User SP has changed because of push. Adjust for it
	add	word [ConC_Spsave],2

	cmp	byte [DosHasHMA],0	; Q: is dos running in HMA (M021)
 	pop	ds	; restore ds
	jne	short do_low_int23	; Y: the int must be done from low mem
	CLC				
	INT	int_ctrl_c  ; int 23h	; N: Execute user Ctrl-C handler
	jmp	short ctrlc_ret_addr

	; 05/05/2019
do_low_int23:
	clc
	call	far [cs:LowInt23Addr]	

	; 30/07/2018 

	; MSDOS 3.3 (IBMDOS.COM - Offset 56C0h)

; The user has returned to us. The circumstances we allow are:
;
;   IRET	We retry the operation by redispatching the system call
;   CLC/RETF	POP the stack and retry
;   ... 	Exit the current process with ^C exit
;
; User's may RETURN to us and leave interrupts on. 
; Turn 'em off just to be sure

ctrlc_ret_addr: ; 05/05/2019

	CLI

	; MSDOS 3.3 
	;MOV	[CS:USER_IN_AX],ax	; save the AX
	;PUSHF				; and the flags (maybe new call)
	;POP	AX

	; 05/05/2019
	; MSDOS 6.0

	; We have to use DOSDATA for these variables. Previously CS was used 

	push	ax
	mov	ax,ds
	;getdseg <ds>			; ds -> dosdata
	mov	ds,[cs:DosDSeg]
	mov	[TEMPSEG],ax
	pop	ax
	MOV	[USER_IN_AX],ax		; save the AX
	pushf				; and the flags (maybe new call)
	pop	ax

; See if the input stack is identical to the output stack

	; MSDOS 3.3
	;CMP	SP,[CS:ConC_Spsave]
	;JNZ     SHORT ctrlc_try_new ; current SP not the same as saved SP

	; MSDOS 6.0
	CMP	SP,[ConC_Spsave]
	JNZ     SHORT ctrlc_try_new ; current SP not the same as saved SP

; Repeat the operation by redispatching the system call.

ctrlc_repeat:
	; MSDOS 3.3
	;MOV	AX,[CS:USER_IN_AX]
	; 05/05/2019
	; MSDOS 6.0
	mov	ax,[USER_IN_AX]
	mov	ds,[TEMPSEG]		; restore ds and original sp
	; MSDOS 3.3 & MSDOS 6.0 
	;transfer COMMAND
COMMANDJ:
	JMP	COMMAND

; The current SP is NOT the same as the input SP. Presume that he 
; RETF'd leaving some flags on the stack and examine the input

ctrlc_try_new:
	ADD	SP,2			; pop those flags
	;;test	ax,1
	;TEST	AX,f_Carry		; did he return with carry?
	test	al,f_Carry ; test al,1
	JZ	short ctrlc_repeat	; no carry set, just retry

	; MSDOS 6.0
	mov	ds,[TEMPSEG]		; restore ds

	; Well...  time to abort the user.  
	; Signal a ^C exit and use the EXIT system call..

ctrlc_abort:
	; MSDOS 3.3
        ;;MOV	AX,(EXIT SHL 8) + 0
        ;MOV	AX, (EXIT*256) + 0  ; 4C00h
	;mov	byte [CS:DidCTRLC],0FFh ; 14/03/2018
        ;transfer COMMAND	    ; give up by faking $EXIT
	;;JMP	SHORT COMMANDJ
	;JMP	COMMAND

	; 05/05/2019 - Retro DOS v4.0
	; MSDOS 6.0
	MOV	AX,(EXIT<<8)+0  ; 4C00h
	push	ds
	;getdseg <ds>			; ds -> dosdata
	mov	ds,[cs:DosDSeg]	
	MOV	byte [DidCTRLC],-1 ; 0FFh
	pop	ds
	;transfer COMMAND		; give up by faking $EXIT
	JMP	SHORT COMMANDJ
	;JMP	COMMAND

;Break	<DIVISION OVERFLOW INTERRUPT>
;----------------------------------------------------------------------------
;
; Procedure Name : DIVOV
;
; Default handler for division overflow trap
;
;----------------------------------------------------------------------------

	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
DIVOV: 
	; 05/05/2019 - Retro DOS v4.0
	; 30/07/2018
	; 07/07/2018 - Retro DOS v3.0
	mov	si,DIVMES
	mov	bx,[cs:DivMesLen]
	;mov	ax,cs
	;mov	ss,ax
	; 05/05/2019
	;getdseg <ss>		; we are in an ISR, flag is CLI
	mov	ss,[cs:DosDSeg]
	mov     sp,AUXSTACK
	;call	RealDivOv ; MSDOS 3.3
	call	_OUTMES ; MSDOS 6.0
	jmp	short ctrlc_abort  ; Use Ctrl-C abort on divide overflow

; 30/07/2018

; MSDOS 6.0
;---------------------------------------------------------------------------
;
; Procedure Name : OutMes
;
;
; OutMes: perform message output
; Inputs:   SS:SI points to message
;	    BX has message length
; Outputs:  message to BCON
;
;Actually, cs:si points to the message now. The segment address is filled in
;at init. time ([dskchret+2]). This will be temporarily changed to DOSCODE. 
;NB. This procedure is called only from DIVOV. -SR
;
;---------------------------------------------------------------------------

;MSDOS 3.3
;---------------------------------------------------------------------------
; RealDivOv: perform actual divide overflow stuff.
; Inputs:   none
; Outputs:  message to BCON
;---------------------------------------------------------------------------

	; 05/05/2019 - Retro DOS v4.0
	; DOSCODE:926Ch (MSDOS 6.21, MSDOS.SYS)

	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; DOSCODE:9210h (MSDOS 5.0, MSDOS.SYS)

;---------------------------------------------------------------------------
;
; Procedure Name : OutMes
;
; OutMes: perform message output
; Inputs:   SS:SI points to message
;	    BX has message length
; Outputs:  message to BCON
;
;Actually, cs:si points to the message now. The segment address is filled in
;at init. time ([dskchret+2]). This will be temporarily changed to DOSCODE. 
;NB. This procedure is called only from DIVOV. -SR
;
;---------------------------------------------------------------------------

	; 30/07/2018
	; MSDOS 6.0
_OUTMES:
	; MSDOS 3.3
;RealDivOv:
	; 07/07/2018 - Retro DOS v3.0
        ;Context ES
	push	ss ; 05/05/2019
	;PUSH	CS ; 30/07/2018		; get ES addressability
	POP	ES
        ;Context DS
	push	ss ; 05/05/2019	
	;PUSH	CS ; 30/07/2018		; get DS addressability
	POP	DS
        MOV     BYTE [DSKSTCOM],DEVWRT
        MOV     BYTE [DSKSTCALL],DRDWRHL
        MOV     WORD [DSKSTST],0
	; BX = [DivMesLen] = 19
        MOV     [DSKSTCNT],BX
        MOV     BX,DSKSTCALL
        MOV     [DSKCHRET+1],SI		; transfer address (need an EQU)
	; 08/09/2018
	;mov	[DEVIOBUF_PTR],si
	; MSDOS 6.0
					; CS is used for string, fill in 
					; segment address 
	MOV	[DSKCHRET+3],CS

        LDS     SI,[BCON]
        CALL	DEVIOCALL2

	;; 14/03/2018
        ;;MOV	WORD [CS:DSKCHRET+1],DEVIOBUF
	;; 08/09/2018
	;mov	word [CS:DEVIOBUF_PTR],DEVIOBUF
        ;MOV	WORD [CS:DSKSTCNT],1
        
	; 05/05/2019 - Retro DOS v4.0 (MSDOS 6.0, MSDOS 6.21)

	; ES still points to DOSDATA. ES is
					; not destroyed by deviocall2. So use
					; ES override.

	MOV	WORD [ES:DSKCHRET+1],DEVIOBUF
	MOV	WORD [ES:DSKSTCNT],1

	RETN

;Break	<CHARHRD,HARDERR,ERROR -- HANDLE DISK ERRORS AND RETURN TO USER>
;---------------------------------------------------------------------------
;
; Procedure Name : CHARHARD
;
;
; Character device error handler
; Same function as HARDERR
;
;---------------------------------------------------------------------------

	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
CHARHARD:
	; 05/05/2019 - Retro DOS v4.0
	; 30/07/2018
	; 08/07/2018 - Retro DOS v3.0

	; MSDOS 6.0
		   			; M024 - start
	cmp	byte [SS:ERRORMODE], 0	; Q: are we in the middle of int 24
	;jne	short @f		; Y: allow fail
	jne	short chard1

	OR	AH,Allowed_RETRY ; 10h	; assume ctrl p

	test	byte [ss:PFLAG],-1	; Q: has ctrl p been pressed
	jnz	short ctrlp		; Y: 
;@@:
chard1:					; M024 - end
	; MSDOS 6.0 & MSDOS 3.3

; Character device error handler
; Same function as HARDERR

	;or	ah,38h
	or	ah,Allowed_IGNORE+Allowed_RETRY+Allowed_FAIL
ctrlp:			; SS override for Allowed and EXITHOLD
	mov	[SS:ALLOWED],ah

	; 15/03/2018
        MOV     [SS:EXITHOLD+2],ES
        MOV     [SS:EXITHOLD],BP
        PUSH    SI
	;and	di,0FFh
        AND     DI,STECODE
        MOV     BP,DS                   ;Device pointer is BP:SI
        CALL    FATALC
        POP     SI
	;return
        RETN

;---------------------------------------------------------------------------
;
; Procedure Name : HardErr
;
; Hard disk error handler. Entry conditions:
;	DS:BX = Original disk transfer address
;	DX = Original logical sector number
;	CX = Number of sectors to go (first one gave the error)
;	AX = Hardware error code
;	DI = Original sector transfer count	
;	ES:BP = Base of drive parameters
;	[READOP] = 0 for read, 1 for write
;	Allowed Set with allowed responses to this error (other bits MUST BE 0)
; Output:
;	[FAILERR] will be set if user responded FAIL
;
;--------------------------------------------------------------------------

	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
HARDERR:
	; 05/05/2019 - Retro DOS v4.0
	; 30/07/2018
	; 08/07/2018 - Retro DOS v3.0
	XCHG    AX,DI                   ; Error code in DI, count in AX
        ;and	di,0FFh
	AND     DI,STECODE              ; And off status bits
        ;CMP	DI,WRECODE		; Write Protect Error?
	;cmp	di,0
	cmp	DI,error_I24_write_protect ; Write Protect Error?
        JNZ     short NOSETWRPERR
        PUSH    AX
	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;MOV	AL,[ES:BP+DPB.DRIVE]
        ;;MOV	AL,[ES:BP+0]
	; 15/12/2022
	mov	al,[ES:BP]
        	; 15/03/2018
        MOV     [SS:WPERR],AL		; Flag drive with WP error
        POP     AX
NOSETWRPERR:
        SUB     AX,CX                   ; Number of sectors successfully transferred
        ADD     DX,AX                   ; First sector number to retry
        PUSH    DX
	; 08/07/2018
        ;MUL	word [ES:BP+2] 		; Number of bytes transferred
	MUL	word [ES:BP+DPB.SECTOR_SIZE]
        POP     DX
        ADD     BX,AX                   ; First address for retry
        XOR     AH,AH                   ; Flag disk section in error
        ;CMP	DX,[ES:BP+6] 		; In reserved area?
	CMP	DX,[ES:BP+DPB.FIRST_FAT]
        JB      SHORT ERRINT
        INC     AH                      ; Flag for FAT
        ;CMP	DX,[ES:BP+10H] ; MSDOS 3.3
	;cmp	dx,[ES:BP+11h] ; MSDOS 6.0 - 05/05/2019 	
	CMP	DX,[ES:BP+DPB.DIR_SECTOR]  ; In FAT?  
	JAE	short TESTDIR 		; No
		 ; Err in FAT must force recomp of freespace
	;mov	word [ES:BP+1Eh],-1 ; MSDOS 3.3
	;mov	word [ES:BP+1Fh],-1 ; MSDOS 6.0 - 05/05/2019 
	MOV	word [ES:BP+DPB.FREE_CNT],-1
	JMP	SHORT ERRINT
TESTDIR:
        INC     AH
        ;CMP	DX,[ES:BP+0BH]		; In directory?
	CMP	DX,[ES:BP+DPB.FIRST_SECTOR] 
        JB      SHORT ERRINT
        INC     AH                      ; Must be in data area
ERRINT:
        SHL     AH,1                    ; Make room for read/write bit
        OR      AH,[SS:READOP] ; 15/03/2018

	; 15/08/2018
					; SS override for allowed and EXITHOLD
	OR	AH,[SS:ALLOWED]		; Set the allowed_ bits

        ;entry   FATAL
FATAL:
	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;MOV	AL,[ES:BP+DPB.DRIVE]
        ;;MOV	AL,[ES:BP+0]		; Get drive number
	; 15/12/2022
	MOV	AL,[ES:BP]        

	;entry   FATAL1
FATAL1:  
	; 15/03/2018      
	MOV     [SS:EXITHOLD+2],ES
        MOV     [SS:EXITHOLD],BP	; The only things we preserve	
	;LES	SI,[ES:BP+12H] ; MSDOS 3.3
	;LES	SI,[ES:BP+13H] ; MSDOS 6.0 - 05/05/2019
	LES	SI,[ES:BP+DPB.DRIVER_ADDR]
        MOV     BP,ES                   ; BP:SI points to the device involved

	; DI has the INT-24-style extended error. We now map the error code 
	; for this into the normalized get extended error set by using the 
	; ErrMap24 table as a translate table. Note that we translate ONLY 
	; the device returned codes and leave all others beyond the look up 
	; table alone.

	; 08/07/2018 - Retro DOS v3.0
FATALC:
	call	SET_I24_EXTENDED_ERROR
	;cmp	di,0Ch
	CMP	DI,error_I24_gen_failure
	JBE	short GOT_RIGHT_CODE	; Error codes above gen_failure get
	MOV	DI,error_I24_gen_failure; mapped to gen_failure. Real codes
					;  Only come via GetExtendedError
;** ----------------------------------------------------------------
;
; Entry point used by REDIRector on Network I 24 errors.
;
;	ASSUME	DS:NOTHING,ES:NOTHING,SS:DOSDATA
;
; ALL I 24 regs set up. ALL Extended error info SET. ALLOWED Set.
;     EXITHOLD set for restore of ES:BP.
; ------------------------------------------------------------------
	;entry	NET_I24_ENTRY
NET_I24_ENTRY:
GOT_RIGHT_CODE:
	CMP     BYTE [SS:ERRORMODE],0	; No INT 24s if already INT 24
        JZ	SHORT NoSetFail
	MOV	AL,3
	JMP	short FailRet
NoSetFail:
        MOV     [SS:CONTSTK],SP		; SS override
        PUSH	SS
        POP	ES
    
	; Wango!!! We may need to free some user state info... In 
	; particular, we may have locked down a JFN for a user and he may 
	; NEVER return to us. Thus,we need to free it here and then 
	; reallocate it when we come back.

	CMP	word [SS:SFN],-1 ; 0FFFFh
	JZ	short _NoFree
	push	ds
	push	si
	LDS	SI,[SS:PJFN]
	MOV	BYTE [SI],0FFH
	pop	si
	pop	ds

_NoFree:
	CLI
					; Prepare to play with stack
        INC     BYTE [SS:ERRORMODE]	; Flag INT 24 in progress
        DEC     BYTE [SS:INDOS]		; INT 24 handler might not return

	; 05/05/2019 - Retro DOS v4.0 (MSDOS 6.0, MSDOS 6.21)

	;; Extended Open hooks
					; AN000;IFS.I24 error disabled
	;test	byte [ss:EXTOPEN_ON],2
	TEST	byte [ss:EXTOPEN_ON],EXT_OPEN_I24_OFF 
	JZ	short i24yes		; AN000;IFS.no
faili24:				; AN000;
	MOV	AL,3			; AN000;IFS.fake fail
	JMP	short passi24 		; AN000;IFS.exit
i24yes: 				; AN000;
	;; Extended Open hooks

        MOV     SS,[SS:USER_SS]
        MOV     SP,[ES:USER_SP]         ; User stack pointer restored

	;;int	24h	
        ;IN	int_fatal_abort		; Fatal error interrupt vector,
					; must preserve ES
	; 05/05/2019
	cmp	byte [es:DosHasHMA], 0	; Q: is dos running in HMA (M021)
	jne	short do_low_int24	; Y: the int must be done from low mem
	INT	int_fatal_abort 	; Fatal error interrupt vector, 
					; must preserve ES
	jmp	short criterr_ret_addr

do_low_int24:
	; 05/05/2019
	; MSDOS 6.0
	call    far [cs:LowInt24Addr]
criterr_ret_addr:
        MOV     [ES:USER_SP],SP         ; restore our stack
        MOV     [ES:USER_SS],SS
        MOV     BP,ES
        MOV     SS,BP
passi24:
        MOV     SP,[SS:CONTSTK]
        INC     BYTE [SS:INDOS]		; Back in the DOS
        MOV     BYTE [SS:ERRORMODE],0	; Back from INT 24
        STI
FailRet:
        LES     BP,[SS:EXITHOLD]
	
	; 08/07/2018

	; Triage the user's reply.

	CMP	AL,1
	JB	short CheckIgnore	; 0 => ignore
	JZ	short CheckRetry	; 1 => retry
	CMP	AL,3			; 3 => fail
	JNZ	short DoAbort 		; 2, invalid => abort

	; The reply was fail. See if we are allowed to fail.

				; SS override for ALLOWED, EXTOPEN_ON, 
				; ALLOWED, FAILERR, WPERR, SFN, pJFN
	;test	byte [ss:ALLOWED],8
	test	byte [ss:ALLOWED],Allowed_FAIL ; Can we?
	jz	short DoAbort	; No, do abort
DoFail:
	MOV	AL,3		; just in case...
				; AN000;EO. I24 error disabled
	; 05/05/2019
	;(MSDOS 6.0, MSCTRLC.ASM, 1991)
	test	byte [ss:EXTOPEN_ON],EXT_OPEN_I24_OFF ; 2
	jnz	short CleanUp 		; AN000;EO. no
	
	inc	byte [SS:FAILERR]	; Tell everybody
CleanUp:
	MOV	byte [SS:WPERR],-1
	CMP	word [SS:SFN],-1
	; 25/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;jnz	short CleanUp2
	;retn
	; 17/12/2022
	jz	short Cleanup_retn ; 08/07/2018 - Retro DOS v3.0
CleanUp2:
	push	ds
	push	si
	push	ax
	MOV	AX,[ss:SFN]
	LDS	SI,[ss:PJFN]
	MOV	[SI],AL
	pop	ax
	pop	si
	pop	ds
Cleanup_retn:
	retn

	; The reply was IGNORE. See if we are allowed to ignore.

CheckIgnore:
	;test	byte [ss:ALLOWED],20h
	test	byte [ss:ALLOWED],Allowed_IGNORE ; Can we?
	jz	short DoFail			 ; No, do fail
	jmp	short CleanUp

	; The reply was RETRY. See if we are allowed to retry.

CheckRetry:
	;test	byte [ss:ALLOWED],10h
	test	byte [ss:ALLOWED],Allowed_RETRY	; Can we?
	jz	short DoFail			; No, do fail
	JMP	short CleanUp

	; The reply was ABORT.
DoAbort:
	push	ss
	pop	ds

	CMP	byte [CONSWAP],0
	JZ	short NOSWAP2
	call	SWAPBACK
NOSWAP2:
	; See if we are to truly abort. If we are in the process of aborting, 
	; turn this abort into a fail.

	;test	[fAborting],0FFh
	;jnz	short DoFail

	cmp	byte [fAborting],0
	JNZ	short DoFail

	; Set return code

	MOV	BYTE [EXIT_TYPE],EXIT_HARD_ERROR ; 2
	XOR	AL,AL

	; we are truly aborting the process. Go restore information from 
	; the PDB as necessary.

	jmp	exit_inner

;** --------------------------------------------------------------------------
;
; reset_environment checks the DS value against the CurrentPDB. If they are
; different, then an old-style return is performed. If they are the same,
; then we release jfns and restore to parent. We still use the PDB at DS:0 as
; the source of the terminate addresses.
;
; Some subtlety: We are about to issue a bunch of calls that *may* generate
; INT 24s. We *cannot* allow the user to restart the abort process; we may
; end up aborting the wrong process or turn a terminate/stay/resident into a
; normal abort and leave interrupt handlers around. What we do is to set a
; flag that will indicate that if any abort code is seen, we just continue the
; operation. In essence, we dis-allow the abort response.
;
; output:   none.
; ----------------------------------------------------------------------------

	;entry	reset_environment
	
reset_environment:
	; 30/07/2018 - Retro DOS v3.0
	; IBMDOS.COM (MSDOS 3.3) - Offset 588Ah 

;***	invoke	Reset_Version		; AN007 ;MS. reset version number

	PUSH	DS			; save PDB of process

	; There are no critical sections in force. Although we may enter 
	; here with critical sections locked down, they are no longer 
	; relevant. We may safely free all allocated resources.

	MOV	AH,82h
		; Microsoft Networks - END DOS CRITICAL SECTIONS 0 THROUGH 7
	;int	2Ah 	
	INT	int_IBM

					; SS override
	MOV	byte [SS:fAborting],-1	; signal abort in progress

					; DOS 4.00 doesn't need it
	;CallInstall NetResetEnvironment, MultNET, 34  
					; Allow REDIR to clear some stuff
					; On process exit.
	mov     ax, 1122h
	int     2Fh	; Multiplex - NETWORK REDIRECTOR - PROCESS TERMINATION HOOK
			; SS = DOS CS
	;mov	al,22h	
	MOV	AL,int_terminate
	call	_$GET_INTERRUPT_VECTOR	; and who to go to

	POP	CX			; get ThisPDB
	push	es
	push	bx			; save return address

	MOV	BX,[SS:CurrentPDB] 	; get currentPDB
	MOV	DS,BX
	MOV	AX,[PDB.PARENT_PID]	; get parentPDB

	; AX = parentPDB, BX = CurrentPDB, CX = ThisPDB
	; Only free handles if AX <> BX and BX = CX and [exit_code].upper 
	; is not Exit_keep_process
	
	CMP	AX,BX
	JZ	short reset_return	; parentPDB = CurrentPDB
	CMP	BX,CX
	JNZ	short reset_return	; CurrentPDB <> ThisPDB
	PUSH	AX			; save parent

					; SS override
	;cmp	byte [SS:EXIT_TYPE],3
	CMP	BYTE [SS:EXIT_TYPE],EXIT_KEEP_PROCESS ; 15/08/2018
	JZ	short reset_to_parent 	; keeping this process

	; We are truly removing a process. Free all allocation blocks 
	; belonging to this PDB

	;invoke	arena_free_process
	call	arena_free_process

	; Kill off remainder of this process. Close file handles and signal 
	; to relevant network folks that this process is dead. Remember that 
	; CurrentPDB is STILL the current process!

	;invoke	DOS_ABORT
	call	DOS_ABORT

reset_to_parent:
					; SS override
	POP	word [SS:CurrentPDB]	; set up process as parent

reset_return:				; come here for normal return
	;Context DS			; DS is used to refer to DOSDATA  
	push	ss
	pop	ds	

	MOV	AL,-1

	; make sure that everything is clean In this case ignore any errors, 
	; we cannot "FAIL" the abort, the program being aborted is dead.

	;EnterCrit critDisk
	call	ECritDisk
	;invoke	FLUSHBUF
	call	FLUSHBUF
	;LeaveCrit critDisk
	call	LCritDisk

	; Decrement open ref. count if we had done a virtual open earlier.

	call	CHECK_VIRT_OPEN
	CLI
	MOV	BYTE [INDOS],0		; Go to known state
	MOV	BYTE [WPERR],-1		; Forget about WP error
	MOV	byte [fAborting],0	; let aborts occur
	POP	WORD [EXITHOLD]
	POP	WORD [EXITHOLD+2]

	; Snake into multitasking... Get stack from CurrentPDB person

	MOV	DS,[CurrentPDB]
	MOV	SS,[PDB.USER_STACK+2]
	MOV	SP,[PDB.USER_STACK]

	call	restore_world

	; 05/05/2019
	pop	es ; * ; MSDOS 6.21 (DOSCODE:94A8h, MSDOS.SYS)

	; MSDOS 6.0
	push	ax			; set up ds, but save ds in TEMPSEG 
	mov	ax,ds			; and not on stack.
	;getdseg <ds>			; ds -> dosdata
	mov	ds,[cs:DosDSeg] 
	mov	[TEMPSEG],ax
	pop	ax
					; set up ds to DOSDATA
	;MOV	[CS:USER_SP],AX ; MSDOS 3.3
	mov	[USER_SP],ax

	POP	AX			; suck off CS:IP of interrupt...
	POP	AX
	POP	AX

; M011 : BEGIN

	; MSDOS 3.3
;	MOV	AX,0F202h	; STI

	; MSDOS 6.0
	LAHF
	XCHG	AH,AL
	AND	AL,2
	MOV	AH,0F2h

; M011 : END

	; MSDOS 3.3 (& MSDOS 6.0)
	PUSH	AX
 
	;PUSH	word [CS:EXITHOLD+2]
	;PUSH	word [CS:EXITHOLD]
	
	; MSDOS 6.0
	PUSH	word [EXITHOLD+2]
	PUSH	word [EXITHOLD]

	;MOV	AX,[CS:USER_SP]

	; MSDOS 6.0
	MOV	AX,[USER_SP]
	mov	ds,[TEMPSEG]	; restore ds

	IRET			; Long return back to user terminate address

;---------------------------------------------------------------------------
;
; Procedure Name : SET_I24_EXTENDED_ERROR
;
; This routine handles extended error codes.
; Input : DI = error code from device
; Output: All EXTERR fields are set
;
;--------------------------------------------------------------------------

SET_I24_EXTENDED_ERROR:
	PUSH	AX
					; ErrMap24End is in DOSDATA
	MOV	AX,ErrMap24End
	SUB	AX,ErrMap24
					; Change to dosdata to access 
					; ErrMap24 and EXTERR -SR
	; 05/05/2019 - Retro DOS v4.0
	
	; MSDOS 6.0
	push	ds
	;getdseg <ds>			; ds ->dosdata
	mov	ds,[cs:DosDSeg]

	; AX is the index of the first unavailable error. Do not translate 
	; if greater or equal to AX.

	CMP	DI,AX
	MOV	AX,DI
	JAE	short NoTrans

	;MOV	AL,[CS:DI+ErrMap24]  ; MSDOS 3.3
	mov	al,[ErrMap24+di] ; MSDOS 6.0
	XOR	AH,AH
NoTrans:
	;MOV	[CS:EXTERR],AX
	mov	[EXTERR],AX
	pop	ds
	;assume	ds:nothing
	POP	AX

	; Now Extended error is set correctly. Translate it to get correct 
	; error locus class and recommended action.

	PUSH	SI
					; ERR_TABLE_24 is in DOSCODE 
	MOV	SI,ERR_TABLE_24
	call	CAL_LK			; Set other extended error fields
	POP	SI
	retn

;============================================================================
; FAT.ASM, MSDOS 6.0, 1991
;============================================================================
; 30/07/2018 - Retro DOS v3.0
; 20/05/2019 - Retro DOS v4.0

;	TITLE	FAT - FAT maintenance routines
;	NAME	FAT

;**	FAT.ASM
;----------------------------------------------------------------------------
;	Low level local device routines for performing disk change sequence,
;	setting cluster validity, and manipulating the FAT
;
;	IsEof
;	UNPACK
;	PACK
;	MAPCLUSTER
;	FATREAD_SFT
;	FATREAD_CDS
;	FAT_operation
;
;	Revision history:
;
;	  AN000  version Jan. 1988
;	   A001  PTM	      -- disk changed for look ahead buffers
;
;	M014 - if a request for pack\unpack cluster 0 is made we write\read
;	       from CL0FATENTRY rather than disk.

; DOSCODE:94FAh (MSDOS 6.21, MSDOS.SYS)

;Break <IsEOF - check the quantity in BX for EOF>
;----------------------------------------------------------------------------
;
; Procedure Name : IsEOF
;
; IsEOF - check the fat value in BX for eof.
;
;   Inputs:	ES:BP point to DPB
;		BX has fat value
;   Outputs:	JAE eof
;   Registers modified: none
;
;---------------------------------------------------------------------------

IsEOF:
	;cmp	word [es:bp+0Dh],0FF6h
	CMP	word [ES:BP+DPB.MAX_CLUSTER],4096-10 ; is this 16 bit fat?
	JAE	short EOF16			; yes, check for eof there

;J.K. 8/27/86
;Modified to accept 0FF0h as an eof. This is to handle the diskfull case
;of any media that has "F0"(Other) as a MediaByte.
;Hopely, this does not create any side effect for those who may use any value
;other than "FF8-FFF" as an EOF for their own file.

	cmp	bx,0FF0h
	je	short IsEOF_other

	CMP	BX,0FF8h		; do the 12 bit compare
IsEOF_other:
	retn
EOF16:
	CMP	BX,0FFF8h		; 16 bit compare
	retn

; DOSCODE:9511h (MSDOS 6.21, MSDOS.SYS)

;Break	<UNPACK -- UNPACK FAT ENTRIES>
;---------------------------------------------------------------------------
;
; Procedur Name : UNPACK
;
; Inputs:
;	BX = Cluster number (may be full 16-bit quantity)
;	ES:BP = Base of drive parameters
; Outputs:
;	DI = Contents of FAT for given cluster (may be full 16-bit quantity)
;	Zero set means DI=0 (free cluster)
;	Carry set means error (currently user FAILed to I 24)
; SI Destroyed, No other registers affected. Fatal error if cluster too big.
;
; NOTE: if BX = 0 then DI = contents of CL0FATENTRY
;
;----------------------------------------------------------------------------
	
	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; DOSCODE:94B5h (MSDOS 5.0, MSDOS.SYS)

	; 20/05/2019 - Retro DOS v4.0
UNPACK:
	; MSDOS 6.0			; M014 - Start
	or	bx, bx			; Q: are we unpacking cluster 0
	jnz	short up_cont		; N: proceed with normal unpack
	mov	di,[CL0FATENTRY]	; Y: return value in CL0FATENTRY
	or	di,di 			; return z if di=0
	retn				; done
up_cont:				; M014 - End
	; MSDOS 3.3 & MSDOS 6.0
	;cmp	bx,[es:bp+0Dh]
	CMP	BX,[ES:BP+DPB.MAX_CLUSTER]
	JA	short HURTFAT
	CALL	MAPCLUSTER
	jc	short _DoContext
	MOV	DI,[DI]
	JNZ	short High12		; MZ if high 12 bits, go get 'em
	MOV	SI,[ES:BP+DPB.MAX_CLUSTER] ; MZ is this 16-bit fat?
	CMP	SI,4096-10
	JB	short Unpack12		; MZ No, go 'AND' off bits
	OR	DI,DI			; MZ set zero condition code, clears carry
	JMP	SHORT _DoContext 	; MZ go do context
High12:
	SHR	DI,1
	SHR	DI,1
	SHR	DI,1
	SHR	DI,1
Unpack12:
	AND	DI,0FFFh		; Clears carry
_DoContext:
	PUSH	SS
	POP	DS
	retn
HURTFAT:
	;;mov	word [es:bp+1Eh],0FFFFh
	;mov	word [es:bp+1Fh],0FFFFh  ; MSDOS 6.0
	MOV	word [ES:BP+DPB.FREE_CNT],-1 ; Err in FAT must force recomp of freespace
	PUSH	AX
	MOV	AH,Allowed_FAIL+80h ; 88h

;hkn; SS override
	MOV	byte [SS:ALLOWED],Allowed_FAIL ; 8
;
; Signal Bad FAT to INT int_fatal_abort handler. We have an invalid cluster.
;
	MOV	DI,0FFFh		; In case INT int_fatal_abort returns (it shouldn't)
	call	FATAL
	CMP	AL,3
	CLC
	JNZ	short OKU_RET 		; Try to ignore bad FAT
	STC				; User said FAIL
OKU_RET:
	POP	AX
hurtfat_retn:
	retn

; DOSCODE:9565h (MSDOS 6.21, MSDOS.SYS)

;Break	<PACK -- PACK FAT ENTRIES>
;----------------------------------------------------------------------------
;
; Procedure Name : PACK
;
; Inputs:
;	BX = Cluster number
;	DX = Data
;	ES:BP = Pointer to drive DPB
; Outputs:
;	The data is stored in the FAT at the given cluster.
;	SI,DX,DI all destroyed
;	Carry set means error (currently user FAILed to I 24)
;	No other registers affected
;
; NOTE: if BX = 0 then data in DX is stored in CL0FATENTRY.
;
;---------------------------------------------------------------------------

	; 02/01/2024
	; 25/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; 20/05/2019 - Retro DOS v4.0
PACK:
	; MSDOS 6.0			; M014 - start
	or	bx,bx			; Q: are we packing cluster 0
	jnz	short p_cont		; N: proceed with normal pack
	mov	[CL0FATENTRY],dx	; Y: place value in CL0FATENTRY
	retn				; done
p_cont:					; M014 - end
	; MSDOS 3.3 & MSDOS 6.0
	CALL	MAPCLUSTER
	JC	short _DoContext
	MOV	SI,[DI]
	JZ	short ALIGNED 		; byte (not nibble) aligned
	PUSH	CX			; move data to upper 12 bits
	MOV	CL,4
	SHL	DX,CL
	POP	CX
	AND	SI,0FH			; leave in original low 4 bits
	JMP	SHORT PACKIN
ALIGNED:
	;cmp	word [es:bp+0Dh],0FF6h
	CMP	word [ES:BP+DPB.MAX_CLUSTER],4096-10 ; MZ 16 bit fats?
	JAE	short Pack16		; MZ yes, go clobber original data
	AND	SI,0F000h		; MZ leave in upper 4 bits of original
	AND	DX,0FFFh		; MZ store only 12 bits
	JMP	SHORT PACKIN		; MZ go store
Pack16:
	XOR	SI,SI			; MZ no original data
PACKIN:
	OR	SI,DX
	MOV	[DI],SI

;hkn; SS override
	LDS	SI,[SS:CURBUF]
	; MSDOS 6.0
	TEST	byte [SI+BUFFINFO.buf_flags],buf_dirty  
					;LB. if already dirty		  ;AN000;
	JNZ	short yesdirty11	;LB.  don't increment dirty count ;AN000;
	; 10/06/2019
	call	INC_DIRTY_COUNT		;LB.				  ;AN000;
	
	;or	byte [si+5],40h
	OR	byte [SI+BUFFINFO.buf_flags],buf_dirty  
yesdirty11:				;LB.				;AN000;
;hkn; SS override
	CMP	BYTE [SS:CLUSSPLIT],0	; 15/08/2018
;hkn; SS is DOSDATA
	push	ss
	pop	ds
	jz	short hurtfat_retn	; Carry clear
	PUSH	AX
	PUSH	BX
	PUSH	CX
	MOV	AX,[CLUSSAVE]
	MOV	DS,[CURBUF+2]
	;;add	si,16 ; MSDOS 3.3
	;add	si,20 ; MSDOS 6.0
	ADD	SI,BUFINSIZ
	MOV	[SI],AH
;hkn; SS is DOSDATA
	;Context DS
	push	ss
	pop	ds
	
	PUSH	AX
	
	; MSDOS 6.0
	MOV	DX,[CLUSSEC+2]		;F.C. >32mb			;AN000;
	MOV	[HIGH_SECTOR],DX	;F.C. >32mb			;AN000;

	; MSDOS 3.3 & MSDOS 6.0
	MOV	DX,[CLUSSEC]

	;MOV	SI,1	  ; *
	;XOR	AL,AL     ; *
	;call	GETBUFFRB ; *
	; 22/09/2023
	call	GETBUFFRA ; *

	POP	AX
	JC	short POPP_RET
	LDS	DI,[CURBUF]
	
	; MSDOS 6.0
	TEST	byte [DI+BUFFINFO.buf_flags],buf_dirty  
					;LB. if already dirty		  ;AN000;
	JNZ	short yesdirty12	;LB.  don't increment dirty count ;AN000;
	call	INC_DIRTY_COUNT 	;LB.				  ;AN000;
	
	;or	byte [di+5],40h
	OR	byte [DI+BUFFINFO.buf_flags],buf_dirty 
yesdirty12:
	;;add	di,16
	;add	di,20 ; MSDOS 6.0
	; 02/01/2024
	;ADD	DI,BUFINSIZ
	;DEC	DI
	add	di,BUFINSIZ-1 ; 19

	;add	di,[es:bp+2]
	ADD	DI,[ES:BP+DPB.SECTOR_SIZE]
	MOV	[DI],AL
	CLC
POPP_RET:
	PUSH	SS
	POP	DS
	POP	CX
	POP	BX
	POP	AX
	retn

; 31/07/2018 - Retro DOS v3.0

;Break	<MAPCLUSTER - BUFFER A FAT SECTOR>
;---------------------------------------------------------------------------
;
; Procedure Name : MAPCLUSTER
;
; Inputs:
;	ES:BP Points to DPB
;	BX Is cluster number
; Function:
;	Get a pointer to the cluster
; Outputs:
;	DS:DI Points to contents of FAT for given cluster
;	DS:SI Points to start of buffer
;	Zero Not set if cluster data is in high 12 bits of word
;	Zero set if cluster data is in low 12 or 16 bits
;	Carry set if failed.
; SI is destroyed.
;
;---------------------------------------------------------------------------

	; 20/05/2019 - Retro DOS v4.0
	; DOSCODE:9601h (MSDOS 6.21, MSDOS.SYS)
	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; DOSCODE:95A5h (MSDOS 5.0, MSDOS.SYS)

MAPCLUSTER:
	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5A15h
	MOV	BYTE [CLUSSPLIT],0
	;SAVE	<AX,BX,CX,DX>
	push	ax
	push	bx
	push	cx
	push	dx
	MOV	AX,BX			; AX = BX
	CMP	word [ES:BP+DPB.MAX_CLUSTER],4096-10  ; MZ 16 bit fat?
	JAE	short Map16		; MZ yes, do 16 bit algorithm
	SHR	AX,1			; AX = BX/2
Map16:	
	; MSDOS 6.0			; MZ skip prev => AX=2*BX
	XOR	DI,DI ; *		; >32mb fat ;AN000;
	; MSDOS 3.3 (& MSDOS 6.0)
	ADD	AX,BX			; AX = 1.5*fat = byte offset in fat
	ADC	DI,DI ; * MSDOS 6.0	; >32mb fat ;DI is zero before op;AN000;
	MOV	CX,[ES:BP+DPB.SECTOR_SIZE]

;IF FastDiv
;
; Gross hack: 99% of all disks have 512 bytes per sector. We test for this
; case and apply a really fast algorithm to get the desired results
;
; Divide method takes 157+4*4=173 (MOV and DIV)
; Fast method takes 39+20*4=119
;
; This saves a bunch.

	CMP	CX,512			; 4  Is this 512 byte sector?
	jne	short _DoDiv		; 4  for no jump
	MOV	DX,AX			; 2  get set for remainder
	AND	DX,512-1		; 4  Form remainder
	MOV	AL,AH			; 2  Quotient in formation in AL
	; MDOS 3.3
	;shr	al,1	
	; MDOS 6.0
	shr	di,1			; 2
	rcr	al,1			; 2
	; MDOS 3.3 (& MSDOS 6.0)
	xor	ah,ah			; 3
	jmp	short DivDone		; 16
_DoDiv:
;ENDIF
	; MSDOS 3.3
	;xor	dx,dx
	; MSDOS 6.0
	mov	dx,di			; 2
	; MSDOS 3.3 (& MSDOS 6.0)	
	DIV	CX			; 155 AX is FAT sector # DX is sector index
;IF FastDiv
DivDone:
;ENDIF
	;add	ax,[es:bp+6]
	ADD	AX,[ES:BP+DPB.FIRST_FAT]
	DEC	CX			; CX is sector size - 1
	;SAVE	<AX,DX,CX>
	push	ax
	push	dx
	push	cx
	MOV	DX,AX

	; MSDOS 6.0
	; 22/09/2023
	;MOV	word [HIGH_SECTOR],0 ; *! ;F.C. >32mb  low sector #
	;
	; MDOS 3.3 (& MSDOS 6.0)
	;XOR	AL,AL	   ; *
	;MOV	SI,1	   ; *
	;;invoke GETBUFFRB ; *
	;call	GETBUFFRB  ; *
	; 22/09/2023
	call	GETBUFFRC  ; *!

	;RESTORE <CX,AX,DX>		; CX is sec siz-1, AX is offset in sec
	pop	cx
	pop	ax
	pop	dx
	JC	short MAP_POP

	LDS	SI,[CURBUF]
	;;lea	di,[si+16]
	;lea	di,[si+20] ; MSDOS 6.0
	LEA	DI,[SI+BUFINSIZ]
	ADD	DI,AX
	CMP	AX,CX
	JNZ	short MAPRET
	MOV	AL,[DI]
	;Context DS		 	;hkn; SS is DOSDATA
	push	ss
	pop	ds	
	INC	BYTE [CLUSSPLIT]
	MOV	[CLUSSAVE],AL
	MOV	[CLUSSEC],DX
	; MSDOS 6.0
	MOV	WORD [CLUSSEC+2],0      ;F.C. >32mb	;AN000;
	INC	DX

	; 22/09/2023
	;MOV	word [HIGH_SECTOR],0 ; *! ;F.C. >32mb FAT sector <32mb ;AN000;
	;
	; MDOS 3.3 (& MSDOS 6.0)
	;XOR	AL,AL	   ; *
	;MOV	SI,1	   ; *
	;;invoke GETBUFFRB ; *
	;call	GETBUFFRB  ; *
	; 22/09/2023
	call	GETBUFFRC  ; *!
	JC	short MAP_POP

	LDS	SI,[CURBUF]
	LEA	DI,[SI+BUFINSIZ]
	MOV	AL,[DI]
	;Context DS			;hkn; SS is DOSDATA
	push	ss
	pop	ds
	MOV	[CLUSSAVE+1],AL

;hkn; CLUSSAVE is in DOSDATA
	MOV	DI,CLUSSAVE
MAPRET:
	;RESTORE <DX,CX,BX>
	pop	dx
	pop	cx
	pop	bx
	XOR	AX,AX			; MZ allow shift to clear carry
	CMP	word [ES:BP+DPB.MAX_CLUSTER],4096-10 ; MZ is this 16-bit fat?
	JAE	short MapSet		; MZ no, set flags
	MOV	AX,BX
MapSet:
	TEST	AL,1			; set zero flag if not on boundary
	;RESTORE <AX>
	pop	ax
	retn

MAP_POP:
	;RESTORE <DX,CX,BX,AX>
	pop	dx
	pop	cx
	pop	bx
	pop	ax
fatread_sft_retn: ; 17/12/2022
	retn

; 20/05/2019 - Retro DOS v4.0
; DOSCODE:96B3h (MSDOS 6.21, MSDOS.SYS)
; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:9657h (MSDOS 5.0, MSDOS.SYS)

;Break	<FATREAD_SFT/FATREAD_CDS -- CHECK DRIVE GET FAT>
;----------------------------------------------------------------------------
;
; Procedure Name : FATREAD_SFT
;
; Inputs:
;	ES:DI points to an SFT for the drive of intrest (local only,
;		giving a NET SFT will produce system crashing results).
;	DS DOSDATA
; Function:
;	Can be used by an SFT routine (like CLOSE) to invalidate buffers
;	if disk changed.
;	In other respects, same as FATREAD_CDS.
;	(note ES:DI destroyed!)
; Outputs:
;	Carry set if error (currently user FAILed to I 24)
; NOTE: This routine may cause FATREAD_CDS to "miss" a disk change
;	as far as invalidating curdir_ID is concerned.
;	Since getting a true disk changed on this call is a screw up
;	anyway, that's the way it goes.
;
;---------------------------------------------------------------------------

FATREAD_SFT:
	LES	BP,[ES:DI+SF_ENTRY.sf_devptr]
	; 27/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;MOV	AL,[ES:BP+DPB.DRIVE] ; [es:bp+0]
	; 15/12/2022
	mov	AL,[ES:BP]
	MOV	[THISDRV],AL
	call	GOTDPB			;Set THISDPB
	;CALL	FAT_GOT_DPB
	; 17/12/2022
	jmp	FAT_GOT_DPB
;fatread_sft_retn:
	;retn

;----------------------------------------------------------------------------
;
; Procedure Name : FATREAD_CDS
;
; Inputs:
;	DS:DOSDATA
;	ES:DI points to an CDS for the drive of intrest (local only,
;		giving a NET or NUL CDS will produce system crashing results).
; Function:
;	If disk may have been changed, media is determined and buffers are
;	flagged invalid. If not, no action is taken.
; Outputs:
;	ES:BP = Drive parameter block
;	THISDPB = ES:BP
;	THISDRV set
;	Carry set if error (currently user FAILed to I 24)
; DS preserved , all other registers destroyed
;
;---------------------------------------------------------------------------

	; 20/05/2019 - Retro DOS v4.0
	; DOSCODE:96C5h (MSDOS 6.21, MSDOS.SYS)
	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; DOSCODE:9669h (MSDOS 5.0, MSDOS.SYS)

FATREAD_CDS:
	PUSH	ES
	PUSH	DI
	;les	bp,[es:di+45h]
	LES	BP,[ES:DI+curdir.devptr]
	; 27/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;MOV	AL,[ES:BP+DPB.DRIVE] ; [es:bp+0]
	; 15/12/2022
	mov	AL,[ES:BP]
	MOV	[THISDRV],AL
	call	GOTDPB			;Set THISDPB
	CALL	FAT_GOT_DPB
	POP	DI			;Get back CDS pointer
	POP	ES
	jc	short fatread_sft_retn
	JNZ	short NO_CHANGE		;Media NOT changed

;	Media changed. We now need to find all CDS structures which use this
;	DPB and invalidate their ID pointers.

MED_CHANGE:
	XOR	AX,AX
	DEC	AX			; AX = -1
	PUSH	DS
	MOV	CL,[CDSCOUNT]
	XOR	CH,CH			; CX is number of structures
	;lds	si,[es:di+45h]
	LDS	SI,[ES:DI+curdir.devptr] ; Find all CDS with this devptr

;hkn; SS override

;	Find all CDSs with this DevPtr
;
;	(ax) = -1
;	(ds:si) = DevPtr

	LES	DI,[SS:CDSADDR]		; (es:di) = CDS pointer
frcd20: 
	;;test	word [es:di+43h],8000h
	;TEST	word [ES:DI+curdir.flags],curdir_isnet
	TEST	byte [ES:DI+curdir.flags+1],(curdir_isnet>>8)
	JNZ	short frcd25		; Leave NET guys alone!!

	; MSDOS 3.3
	;push	es
	;push	di
	;les	di,[es:di+45h]
	;;les	di,[ES:DI+curdir.devptr]
	;call	POINTCOMP
	;pop	di
	;pop	es
	;jnz	short frcd25

	; MSDOS 6.0
	cmp	si,[ES:DI+curdir.devptr]
	jne	short frcd25		; no match
	mov	bx,ds
	cmp	bx,[ES:DI+curdir.devptr+2]
	jne	short frcd25		; CDS not for this drive

	; MSDOS 3.3 (& MSDOS 6.0)
	;test	[es:di+49h],ax
	test	[ES:DI+curdir.ID],AX
	JZ	short frcd25		; If root (0), leave root
	;mov	[es:di+49h],ax
	MOV	[ES:DI+curdir.ID],AX	; else invalid
frcd25:	
	;;add	di,81  ; MSDOS 3.3
	;add	di,88  ; MSDOS 6.0	 
	ADD	DI,curdir.size		; Point to next CDS
	LOOP	frcd20
	POP	DS
NO_CHANGE:
	LES	BP,[THISDPB]
	CLC
	retn

;Break	<Fat_Operation - miscellaneous fat stuff>
;----------------------------------------------------------------------------
;
; Procedure Name : FAT_operation
;
;----------------------------------------------------------------------------

	; 03/01/2024
	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)

FAT_operation:
	; 31/07/2018 - Retro DOS v3.0
FATERR:
	;mov	word [es:bp+1Eh],-1
	;mov	word [es:bp+1Fh],-1 ; MSDOS 6.0
	MOV	word [ES:BP+DPB.FREE_CNT],-1 
					; Err in FAT must force recomp of freespace
	;and	di,0FFh
	AND	DI,STECODE		; Put error code in DI
	;mov	byte [ALLOWED],18h
	MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
	;mov	ah,1Ah
	MOV	AH,2+Allowed_FAIL+Allowed_RETRY ; While trying to read FAT
	MOV	AL,[THISDRV]		; Tell which drive
	call	FATAL1
	LES	BP,[THISDPB]
	CMP	AL,3
	JNZ	short FAT_GOT_DPB	; User said retry
	STC				; User said FAIL
	retn

FAT_GOT_DPB:
	;Context DS			;hkn; SS is DOSDATA
	push	ss			
	pop	ds
	;mov	al,0Fh
	MOV	AL,DMEDHL
	;mov	ah,[es:bp+1]
	MOV	AH,[ES:BP+DPB.UNIT] 
	MOV	[DEVCALL_REQLEN],AX ; 09/09/2018 
	MOV	BYTE [DEVCALL_REQFUNC],DEVMDCH
	MOV	word [DEVCALL_REQSTAT],0
	;;mov	al,[es:bp+16h]
	;mov	al,[es:bp+17h] ; MSDOS 6.0
	MOV	AL,[ES:BP+DPB.MEDIA]
	MOV	[CALLMED],AL
	PUSH	ES
	PUSH	DS

;hkn; DEVCALL is in DOSDATA
	MOV	BX,DEVCALL
	;;lds	si,[es:bp+12h]
	;lds	si,[es:bp+13h] ; MSDOS 6.0
	LDS	SI,[ES:BP+DPB.DRIVER_ADDR] ; DS:SI Points to device header
	POP	ES			; ES:BX Points to call header
	call	DEVIOCALL2
	;Context DS		 	;hkn; SS is DOSDATA
	push	ss
	pop	ds
	POP	ES			; Restore ES:BP
	MOV	DI,[DEVCALL_REQSTAT]
	;test	di,8000h
	;jnz	short FATERR
	or	di,di
	js	short FATERR		; have error
	XOR	AH,AH
	;xchg	ah,[es:bp+17h] ; MSDOS 3.3
	;xchg	ah,[es:bp+18h] ; MSDOS 6.0
	XCHG	AH,[ES:BP+DPB.FIRST_ACCESS] ; Reset dpb_first_access
	MOV	AL,[THISDRV]		; Use physical unit number
; See if we had changed volume id by creating one on the diskette
	cmp	[VOLCHNG_FLAG],AL
	jnz	short CHECK_BYT
	mov	byte [VOLCHNG_FLAG],-1
	jmp	GOGETBPB		; Need to get device driver to read in
					; new volume label.
CHECK_BYT:
	OR	AH,[CALLRBYT]
	;JNS	short CHECK_ZR		; ns = 0 or 1
	;JMP	short NEWDSK
	; 17/12/2022
	js	short NEWDSK
	; 27/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;JNS	short CHECK_ZR		; ns = 0 or 1
	;JMP	short NEWDSK

CHECK_ZR:
	JZ	short CHKBUFFDIRT	; jump if I don't know
	; 24/09/2023
	; cf=0 (after 'or' instruction)
	;CLC
	retn				; If Media not changed (NZ)

DISK_CHNG_ERR:
	PUSH	ES
	PUSH	BP
	;;les	bp,[es:bp+12h]
	;les	bp,[es:bp+13h] ; MSDOS 6.0
	LES	BP,[ES:BP+DPB.DRIVER_ADDR] ; Get device pointer
	;;test	word [es:bp+4],800h
	;TEST	word [ES:BP+SYSDEV.ATT],DEVOPCL ; Did it set vol id?
	test	byte [es:bp+SYSDEV.ATT+1],(DEVOPCL>>8)
	POP	BP
	POP	ES
	JZ	short FAIL_OPJ2		; Nope, FAIL
	PUSH	DS			; Save buffer pointer for ignore
	PUSH	DI
	push	ss			;hkn; SS is DOSDATA
	pop	ds
	;mov	byte [ALLOWED],18h
	MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
	PUSH	ES
	LES	DI,[CALLVIDM]		; Get volume ID pointer
	MOV	[EXTERRPT+2],ES
	POP	ES
	MOV	[EXTERRPT],DI
	;mov	ax,0Fh
	MOV	AX,error_I24_wrong_disk
	MOV	byte [READOP],1		; Write
	;invoke	HARDERR
	call	HARDERR
	POP	DI			; Get back buffer for ignore
	POP	DS
	CMP	AL,3
FAIL_OPJ2:
	JZ	short FAIL_OP
	JMP	FAT_GOT_DPB		; Retry

CHKBUFFDIRT:
	; 20/05/2019 - Retro DOS v4.0

	; MSDOS 3.3
	;lds	di,[BUFFHEAD]

	; MSDOS 6.0
	cmp	word [ss:DirtyBufferCount],0	; any dirty buffers ? ;hkn;
	je	short NEWDSK			; no, skip the check
	call	GETCURHEAD			; get pointer to first buffer
nbuffer:
	;cmp	al,[di+4]
	cmp	[di+BUFFINFO.buf_ID],al	; Unit OK ?
	jne	short lfnxt			; no, go for next buffer
	;test   byte [di+5],40h
	TEST	byte [di+BUFFINFO.buf_flags],buf_dirty	; is the buffer dirty ?
	jz	short lfnxt			; no, go for next buffer
	;Context DS
	push	ss
	pop	ds
	; 24/09/2023
	; cf=0 (after 'test' instruction)
	;clc
	retn

FAIL_OP:					; This label & code is here
	;Context DS				;  for reachability
	push	ss
	pop	ds
	STC
	retn

lfnxt:
	; 15/08/2018 - Retro DOS v3.0
	; MSDOS 3.3
	;lds	di,[di]

	; 20/05/2019 - Retro DOS v4.0
	mov	di,[di]
	;;mov	di,[di+BUFFINFO.buf_next]	; get next buffer
	
	; MSDOS 3.3
	;cmp	di,-1
	;jne	short nbuffer
	
	; MSDOS 6.0
	cmp	[ss:FIRST_BUFF_ADDR],di		; is this where we started ?;hkn;
	jne	short nbuffer			; no, check this guy also

; If no dirty buffers, assume Media changed
NEWDSK:
	;;mov	word [es:bp+1Eh],0FFFFh  ; MSDOS 3.3
	;mov	word [es:bp+1Fh],0FFFFh  ; MSDOS 6.0
	mov	word [ES:BP+DPB.FREE_CNT],-1	; Media changed, must
						;  recompute
	; MSDOS 3.3
	;call	SETVISIT
	; MSDOS 6.0
	call	 GETCURHEAD
nxbuffer:
	; MSDOS 3.3
	;or 	byte [di+5],20h
	; MSDOS 3.3 & MSDOS 6.0
	;cmp	[di+4],al
	cmp	[DI+BUFFINFO.buf_ID],al		; This drive ?
	jne	short lfnxt2
	;test	byte [di+5],40h
	TEST	byte [DI+BUFFINFO.buf_flags],buf_dirty
	jnz	short DISK_CHNG_ERR
	;mov	word [di+4],20FFh
	mov	word [DI+BUFFINFO.buf_ID],(buf_visit*256)+0FFh ; free up
	call	SCANPLACE
	; MSDOS 6.0
	jmp	short skpbuff
lfnxt2:
	mov	di,[di]
	;mov	di,[di+BUFFINFO.buf_next]
skpbuff:
	; MSDOS 6.0
	cmp	di,[ss:FIRST_BUFF_ADDR]					;hkn;
	jne	short nxbuffer

	CMP	word [ss:SC_CACHE_COUNT],0 ;LB.  look ahead buffers ?	;AN001;
	JZ	short GOGETBPB		;LB.  no			;AN001;
	CMP	AL,[ss:CurSC_DRIVE]	;LB.  same as changed drive	;AN001;
	JNZ	short GOGETBPB		;LB.  no			;AN001;
	MOV	byte [ss:CurSC_DRIVE],-1 ;LB.  invalidate look ahead buffers ;AN000;
;lfnxt2:
	; MSDOS 3.3
	;call	SKIPVISIT
	;jnz	short nxbuffer
GOGETBPB:
	; MSDOS 3.3 & MSDOS 6.0
	;;lds	di,[es:bp+12h]
	;lds	di,[es:bp+13h] ; MSDOS 6.0	
	LDS	DI,[ES:BP+DPB.DRIVER_ADDR]
	; 20/05/2019
	;test	word [di+4],2000h
	;TEST	word [DI+SYSDEV.ATT],ISFATBYDEV
	TEST	byte [DI+SYSDEV.ATT+1],(ISFATBYDEV>>8)
	JNZ	short GETFREEBUF
	;context DS	    		;hkn; SS is DOSDATA
	push	ss
	pop	ds
	MOV	BX,2
	CALL	UNPACK			; Read the first FAT sector into CURBUF
FAIL_OPJ:
	JC	short FAIL_OP
	LDS	DI,[CURBUF]
	JMP	SHORT GOTGETBUF

GETFREEBUF:
	PUSH	ES			; Get a free buffer for BIOS to use
	PUSH	BP
	; MSDOS 3.3
	;LDS	DI,[SS:BUFFHEAD] ; 15/08/2018
	; MSDOS 6.0
	XOR	DX,DX			;LB.  fake to get 1st	  ;AN000;
;hkn; SS override
	MOV	[SS:HIGH_SECTOR],DX ; 0	;LB.  buffer addr	  ;AN000;
	call	GETCURHEAD		;LB.			  ;AN000;
	; MSDOS 3.3 & MSDOS 6.0
	call	BUFWRITE
	POP	BP
	POP	ES
	;JC	short FAIL_OPJ
	jc	short FAIL_OP
GOTGETBUF:
	;;add	di,16
	;add	di,20 ; MSDOS 6.0
	ADD	DI,BUFINSIZ

;hkn; SS override
	MOV	[SS:CALLXAD+2],DS
	;Context DS			;hkn; SS is DOSDATA
	push	ss
	pop	ds
	MOV	[CALLXAD],DI
	;mov	al,16h
	MOV	AL,DBPBHL
	;mov	ah,[es:bp+1]
	MOV	AH,[ES:BP+DPB.UNIT]
	MOV	[DEVCALL_REQLEN],AX ; 09/09/2018
	MOV	BYTE [DEVCALL_REQFUNC],DEVBPB
	MOV	word [DEVCALL_REQSTAT],0
	;;mov	al,[es:bp+16h]
	;mov	al,[es:bp+17h]
	MOV	AL,[ES:BP+DPB.MEDIA]
	MOV	[CALLMED],AL
	PUSH	ES ; **
	PUSH	DS ; *
	;;
; 03/01/2023
%if 0
	;;push	word [es:bp+14h]
	;push	word [es:bp+15h] ; MSDOS 6.0
	PUSH	WORD [ES:BP+DPB.DRIVER_ADDR+2]
	;;push	word [es:bp+12h]
	;push	word [es:bp+13h] ; MSDOS 6.0
	PUSH	WORD [ES:BP+DPB.DRIVER_ADDR]

;hkn; DEVCALL is in DOSDATA
	MOV	BX,DEVCALL
	POP	SI
	POP	DS			; DS:SI Points to device header
%endif
	; 03/01/2024
	mov	bx,DEVCALL
	;lds	si,[es:bp+13h]
	lds	si,[es:bp+DPB.DRIVER_ADDR]
					; DS:SI Points to device header
	;;
	POP	ES ; *			; ES:BX Points to call header
	;invoke	DEVIOCALL2
	call	DEVIOCALL2
	POP	ES ; **			; Restore ES:BP
	;Context DS
	push	ss		 	;hkn; SS is DOSDATA
	pop	ds
	MOV	DI,[DEVCALL_REQSTAT]
	; MSDOS 3.3
	;test	di,8000h
	;jnz	short FATERRJ
	; MSDOS 6.0
	or	di,di
	js	short FATERRJ 		; have error
	;;mov	al,[es:bp+16h]
	;mov	al,[es:bp+17h]  ; MSDOS 6.0
	MOV	AL,[ES:BP+DPB.MEDIA]
	LDS	SI,[CALLBPB]
	;;mov	word [es:bp+1Ch],0
	;mov	word [es:bp+1Dh],0 ; MSDOS 6.0
	MOV	word [ES:BP+DPB.NEXT_FREE],0 ; recycle scanning pointer
	;invoke	$SETDPB
	call	_$SETDPB

;hkn; SS override
	LDS	DI,[SS:CALLXAD]		; Get back buffer pointer
	;mov	al,[es:bp+8]
	MOV	AL,[ES:BP+DPB.FAT_COUNT]

	; MSDOS 3.3
	;;mov	ah,[es:bp+0Fh]
	;MOV	AH,[ES:BP+DPB.FAT_SIZE]
	;;mov	[DI-8],ax
	;MOV	[DI+BUFFINFO.buf_wrtcnt-BUFINSIZ],AX

	; MSDOS 6.0
	;mov	[di-0Ah],al
	MOV	[DI+BUFFINFO.buf_wrtcnt-BUFINSIZ],AL 
						;>32mb		  ;AN000;
	;mov	ax,[es:bp+0Fh]
	MOV	AX,[ES:BP+DPB.FAT_SIZE]		;>32mb
	;mov	[di-9h],ax			  ;AC000;
	MOV	[DI+BUFFINFO.buf_wrtcntinc-BUFINSIZ],AX 
					;>32mb Correct buffer info ;AC000;
	;Context DS			;hkn; SS is DOSDATA
	push	ss
	pop	ds
	XOR	AL,AL			;Media changed (Z), Carry clear
	retn

FATERRJ: 
	JMP	FATERR

;============================================================================
; STDBUF.ASM
;============================================================================
; Retro DOS v2.0 - 12/03/2018

;
; Standard buffer management for MSDOS
;

;.xlist
;.xcref
;INCLUDE STDSW.ASM
;.cref
;.list

;TITLE	STDBUF - MSDOS buffer management
;NAME	STDBUF

;INCLUDE BUF.ASM

;============================================================================
; BUF.ASM
;============================================================================
; 31/07/2018 - Retro DOS v3.0
; Retro DOS v2.0 - 12/03/2018
;
; buffer management for MSDOS
;
;CODE	SEGMENT BYTE PUBLIC  'CODE'
;       ASSUME  SS:DOSGROUP,CS:DOSGROUP
;
;SUBTTL SETVISIT,SKIPVISIT -- MANAGE BUFFER SCANS
;
;SETVISIT:
;	; 31/07/2018 - Retro DOS v3.0
;	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5CAFh
;; Inputs:
;;      None
;; Function:
;;      Set up a scan of I/O buffers
;; Outputs:
;;      All visit flags = 0
;;              NOTE: This pre-scan is needed because a hard disk error
;;                    may cause a scan to stop in the middle leaving some
;;                    visit flags set, and some not set.
;;      DS:DI Points to [BUFFHEAD]
;; No other registers altered
;
;       LDS     DI,[SS:BUFFHEAD] ; 15/03/2018
;	PUSH    AX
;       ;;XOR	AX,AX	  ;; MSDOS 2.11
;	;mov	al,0DFh
;	mov	al,~buf_visit
;SETLOOP:
;       ;;MOV	[DI+7],AL ;; MSDOS 2.11
;	;and	[DI+5],al
;	AND	[DI+BUFFINFO.buf_flags],AL
;       LDS     DI,[DI]
;       CMP     DI,-1
;       JNZ     SHORT SETLOOP
;       POP     AX ; 09/09/2018
;	LDS     DI,[SS:BUFFHEAD] ; 15/03/2018
;SVISIT_RETN:
;       RETN
;
;SKIPVISIT:
;	; 31/07/2018 - Retro DOS v3.0
;	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5CC8h
;
;; Inputs:
;;      DS:DI Points to a buffer
;; Function:
;;      Skip visited buffers
;; Outputs:
;;      DS:DI Points to next unvisited buffer
;;      Zero is set if skip to LAST buffer
;; No other registers altered
;
;       CMP     DI,-1
;       ;retz
;       JZ	SHORT SVISIT_RETN
;
;	;;CMP	BYTE [DI+7],1 ;; MSDOS 2.11
;       ;;;retnz
;       ;;JNZ	SHORT SVISIT_RETN
;
;	;test	byte [di+5],20h
;	TEST	byte [DI+BUFFINFO.buf_flags],buf_visit	
;	JNZ	short SKIPLOOP
;	
;	push	ax
;	or	al,1
;	pop	ax
;	retn	
;
;SKIPLOOP:
;	LDS     DI,[DI]
;       JMP     SHORT SKIPVISIT

;============================================================================
; BUF.ASM, MSDOS 6.0, 1991
;============================================================================
; 31/07/2018 - Retro DOS v3.0
; 04/05/2019 - Retro DOS v4.0

;	TITLE	BUF - MSDOS buffer management
;	NAME	BUF

;**	BUF.ASM - Low level routines for buffer cache management
;
;	GETCURHEAD
;	ScanPlace
;	PLACEBUF
;	PLACEHEAD
;	PointComp
;	GETBUFFR
;	GETBUFFRB
;	FlushBuf
;	BufWrite
;	SET_RQ_SC_PARMS
;
;	Revision history:
;
;		AN000  version 4.00  Jan. 1988
;		A004   PTM 3765 -- Disk reset failed
;		M039 DB 10/17/90 - Disk write optimization
;		I001   5.0 PTR 722211 - Preserve CY when in buffer in HMA

;Break	<GETCURHEAD -- Get current buffer header>
;----------------------------------------------------------------------------
; Procedure Name : GetCurHead
; Inputs:
;	 No Inputs
; Function:
;	Returns the pointer to the first buffer in Queue
;	and updates FIRST_BUFF_ADDR
;       and invalidates LASTBUFFER (recency pointer)
; Outputs:
;	DS:DI = pointer to the first buffer in Queue
;	FIRST_BUFF_ADDR = offset ( DI ) of First buffer in Queue
;       LASTBUFFER = -1
; No other registers altered
;----------------------------------------------------------------------------

; 04/05/2019 - Retro DOS v4.0
; DOSCODE:98D2h (MSDOS 6.21, MSDOS.SYS)
; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:9876h (MSDOS 5.0, MSDOS.SYS)

GETCURHEAD:
	lds	di,[ss:BufferQueue]	; Pointer to the first buffer
	mov	word [ss:LastBuffer],-1	; invalidate last buffer
	mov	[ss:FIRST_BUFF_ADDR],di	;save first buffer addr
	retn

;Break	<SCANPLACE, PLACEBUF -- PUT A BUFFER BACK IN THE POOL>
;----------------------------------------------------------------------------
; Procedure Name : ScanPlace
; Inputs:
;	Same as PLACEBUF
; Function:
;	Save scan location and call PLACEBUF
; Outputs:
;	DS:DI Points to saved scan location
; All registers, except DS:DI, preserved.
;----------------------------------------------------------------------------
;M039: Rewritten to preserve registers.

;SCANPLACE:
;	; 31/07/2018 - Retro DOS v3.0
;	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5DDCh
;	push	es
;	les	si,[di]
;	;les	si,[DI+BUFFINFO.buf_link]
;	call	PLACEBUF
;	push	es
;	pop	ds
;	mov	di,si
;	pop	es
;scanplace_retn:
;	retn	
	
	; MSDOS 6.0
SCANPLACE:
	push	word [di]
	;push	word [di+BUFFINFO.buf_next] ;Save scan location
	call	PLACEBUF
	pop	di
	retn

;----------------------------------------------------------------------------
; Procedure Name : PlaceBuf
; Input:
;	DS:DI points to buffer (DS->BUFFINFO array, DI=offset in array)
; Function:
;	Remove buffer from queue and re-insert it in proper place.
; NO registers altered
;----------------------------------------------------------------------------

;procedure PLACEBUF,NEAR

	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; 20/05/2019 - Retro DOS v4.0
PLACEBUF:
	; 31/07/2018 - Retro DOS v3.0

	; MSDOS 6.0
	push	AX			;Save only regs we modify	;AN000;
	push	BX							;AN000;
	; 23/09/2023
	;push	SI							;AN000;
	
	mov	ax,[di]
	;mov	ax,[di+BUFFINFO.buf_next]
	mov	bx,[ss:BufferQueue]	; bx = offset of head of list;smr;SS Override
	
	cmp	ax,bx				;Buf = last?		;AN000;
	je	short nret			;Yes, special case	;AN000;
	cmp	di,bx				;Buf = first?		;AN000;
	jne	short not_first 		;Yes, special case	;AN000;
	mov	[ss:BufferQueue],ax		;smr;SS Override
	jmp	short nret 			;Continue with repositioning;AN000;
not_first:
	; 23/09/2023
	push	si
	;mov	si,[di+2]
	mov	SI,[DI+BUFFINFO.buf_prev]	;No, SI = prior Buf	;AN000;
	mov	[si],ax
	;mov	[SI+BUFFINFO.buf_next],AX	; ax has di->buf_next	;AN000;
	xchg	si,ax
	;mov	[si+2],ax
	mov	[SI+BUFFINFO.buf_prev],AX	;			;AN000;
	
	mov	SI,[BX+BUFFINFO.buf_prev]	;SI-> last buffer	;AN000;
	mov	[si],di
	;mov	[SI+BUFFINFO.buf_next],DI	;Add Buf to end of list ;AN000;
	mov	[BX+BUFFINFO.buf_prev],DI				;AN000;
	mov	[DI+BUFFINFO.buf_prev],SI	;Update link in Buf too	;AN000;
	mov	[di],bx
	;mov	[DI+BUFFINFO.buf_next],BX				;AN000;
	; 23/09/2023
	pop	si
nret:	
	; 23/09/2023							;AN000;
	;pop	SI							;AN000;
	pop	BX							;AN000;
	pop	AX							;AN000;
									;AN000;
	;cmp	byte [di+4],0FFh
	cmp	byte [di+BUFFINFO.buf_ID],-1	; Buffer FREE?		;AN000;
        jne	short pbx			; M039: -no, jump.
	mov	[ss:BufferQueue],di		; M039: -yes, make it LRU.
pbx:	
	retn								;AN000;

	; 31/07/2018 - Retro DOS v3.0

	; MSDOS 3.3
	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5DDCh

;PLACEBUF:
;	; 15/03/2018 - Retro DOS v2.0 (MSDOS 2.11)
;	
;       CALL	save_world
;       LES     CX,[DI]
;       CMP     CX,-1           	; Buf is LAST?
;       JZ      SHORT NRET		; Buffer already last
;       MOV     BP,ES           	; Pointsave = Buf.nextbuf
;       PUSH    DS
;       POP     ES              	; Buf is ES:DI
;	; 15/03/2018
;       LDS     SI,[SS:BUFFHEAD] 	; Curbuf = HEAD
;       CALL    POINTCOMP       	; Buf == HEAD?
;       JNZ     SHORT BUFLOOP
;       MOV     [SS:BUFFHEAD],CX
;       MOV     [SS:BUFFHEAD+2],BP	; HEAD = Pointsave
;       JMP     SHORT LOOKEND
;BUFLOOP:
;	; 31/07/2018
;	mov	ax,ds
;	mov	bx,si
;	;lds	si,[SI+BUFFINFO.buf_link]
;       LDS     SI,[SI]
;       CALL    POINTCOMP
;       jnz	short BUFLOOP
;	;
;	mov	ds,ax
;	mov	si,bx
;	mov	[SI],cx
;	;mov	[SI+BUFFINFO.buf_link],cx   ; If Curbuf.nextbuf == buf
;	mov	[SI+2],bp
;	;mov	[BX+BUFFINFO.buf_link+2],bp ; Curbuf.nextbuf = Pointsave
;LOOKEND:
;	mov	ax,ds
;	mov	bx,si
;       LDS     SI,[SI]
;       CMP     SI,-1
;       jnz     short LOOKEND
;GOTHEEND:
;       mov	ds,ax
;	mov	[BX],di
;	MOV     [BX+2],ES 		; Curbuf.nextbuf = Buf
;       MOV     WORD [ES:DI],-1
;	;mov	word [ES:DI+BUFFINFO.buf_link],-1
;       MOV     WORD [ES:DI+2],-1 	; Buf is LAST
;	;mov	word [ES:DI+BUFFINFO.buf_link+2],-1
;NRET:
;       CALL	restore_world
;	
;	;cmp	byte [di+4],-1
;	cmp	byte [DI+BUFFINFO.buf_ID],-1  ; Free buffer ?
;	jnz     short scanplace_retn
;	call    PLACEHEAD
;	retn

;EndProc PLACEBUF

;M039 - Removed PLACEHEAD.
;----------------------------------------------------------------------------
; places buffer at head
;  NOTE:::::: ASSUMES THAT BUFFER IS CURRENTLY THE LAST
;	ONE IN THE LIST!!!!!!!
; BUGBUG ---- this routine can be removed because it has only
; BUGBUG ---- one instruction. This routine is called from
; BUGBUG ---- 3 places. ( Size = 3*3+6 = 15 bytes )
; BUGBUG ---- if coded in line = 3 * 5 = 15 bytes
; BUGBUG ---- But kept as it is for modularity
;----------------------------------------------------------------------------
;procedure   PLACEHEAD,NEAR
;	mov	word ptr [BufferQueue], di
;	ret
;EndProc PLACEHEAD
;M039

;----------------------------------------------------------------------------
; Procedure Name : PLACEHEAD
;
; SAME AS PLACEBUF except places buffer at head
;----------------------------------------------------------------------------

	; MSDOS 3.3 (Retro DOS v3.0)
	; 05/09/2018
	; MSDOS 2.11 (Retro DOS v2.0)
;PLACEHEAD:
;	; 31/07/2018 - Retro DOS v3.0
;	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5D4Ah
;
;       CALL	save_world
;       PUSH	DS
;       POP	ES
;	; 15/03/2018 - Retro DOS v2.0 (MSDOS 2.11)
;       LDS     SI,[SS:BUFFHEAD]
;	; 31/07/2018 - Retro DOS v3.0 (MSDOS 3.3)
;	CALL    POINTCOMP
;       JZ      SHORT GOTHEEND2
;	MOV	[ES:DI],SI
;	;mov	[ES:DI+BUFFINFO.buf_link],si
;       MOV	[ES:DI+2],DS
;	;mov	[ES:DI+BUFFINFO.buf_link+2],ds
;       MOV	[SS:BUFFHEAD],DI
;       MOV	[SS:BUFFHEAD+2],ES
;LOOKEND2:
;       mov	ax,ds
;	mov	bx,si
;	;lds	si,[SI+BUFFINFO.buf_link]
;       LDS     SI,[SI]
;       CALL    POINTCOMP
;       JNZ	SHORT LOOKEND2 ; 05/09/2018
;       mov	ds,ax
;	mov	word [bx],-1
;	;mov	word [BX+BUFFINFO.buf_link],-1
;	mov	word [bx+2],-1
;	;mov	word [BX+BUFFINFO.buf_link+2],-1
;GOTHEEND2:
;      	call	restore_world
;placehead_retn:
;	retn

; 20/05/2019 - Retro DOS v4.0
; DOSCODE:9928h (MSDOS 6.21, MSDOS.SYS)

;Break	<POINTCOMP -- 20 BIT POINTER COMPARE>
;----------------------------------------------------------------------------
;
; Procedure Name : PointComp
; Inputs:
;         DS:SI & ES:DI
; Function:
;          Checks for ((SI==DI) && (ES==DS))
;	   Assumes that pointers are normalized for the
;	   same segment
;
; Compare DS:SI to ES:DI (or DS:DI to ES:SI) for equality
; DO NOT USE FOR < or >
; No Registers altered
;
;----------------------------------------------------------------------------

POINTCOMP:
	; 31/07/2018 - Retro DOS v3.0
	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5D84h
	CMP	SI,DI
	jnz	short _ret_label	; return if nz
	;jnz	short placehead_retn 
	PUSH	CX
	PUSH	DX
	MOV	CX,DS
	MOV	DX,ES
	CMP	CX,DX
	POP	DX
	POP	CX
_ret_label:
	retn

; 01/08/2018 - Retro DOS v3.0
; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5D93h 

;Break	<GETBUFFR, GETBUFFRB -- GET A SECTOR INTO A BUFFER>

;**	GetBuffr - Get a non-FAT Sector into a Buffer
;----------------------------------------------------------------------------
;	GetBuffr does normal ( non-FAT ) sector buffering
;	It gets the specified local sector into one of the I/O buffers
;	and shuffles the queue
; 
;	ENTRY	(AL) = 0 means sector must be pre-read
;		       ELSE no pre-read
;		(DX) = Desired physical sector number	      (LOW)
;		HIGH_SECTOR = Desired physical sector number (HIGH)
;		(ES:BP) = Pointer to drive parameters
;		ALLOWED set in case of INT 24
;	EXIT	'C' set if error (user FAIL response to INT24)
;		'C' clear if OK
;		CURBUF Points to the Buffer for the sector
;		    the buffer type bits OF buf_flags = 0, caller must set it
;	USES	AX, BX, CX, SI, DI, Flags
;----------------------------------------------------------------------------

;**	GetBuffrb - Get a FAT Sector into a Buffer
;----------------------------------------------------------------------------
;	GetBuffrb reads a sector from the FAT file system's FAT table.
;	It gets the specified sector into one of the I/O buffers
;	and shuffles the queue. We need a special entry point so that
;	we can read the alternate FAT sector if the first read fails, also
;	so we can mark the buffer as a FAT sector.
; 
;	ENTRY	(AL) = 0 means sector must be pre-read
;		       ELSE no pre-read
;		(DX) = Desired physical sector number	     (LOW)
;		(SI) != 0
;		HIGH_SECTOR = Desired physical sector number (HIGH)
;		(ES:BP) = Pointer to drive parameters
;		ALLOWED set in case of INT 24
;	EXIT	'C' set if error (user FAIL response to INT24)
;		'C' clear if OK
;		CUR ddBUF Points to the Buffer for the sector
;		    the buffer type bits OF buf_flags = 0, caller must set it
;	USES	AX, BX, CX, SI, DI, Flags
;----------------------------------------------------------------------------

	; 22/09/2023 - RetroDOS v4.2 MSDOS.SYS (optimization)
GETBUFFRC:
	mov	word [HIGH_SECTOR],0
GETBUFFRA:
	xor	al,al
	mov	si,1
	jmp	short GETBUFFRB

	; 22/09/2023
GETBUFFER:
	xor	al,al
GETBUFFRD:
	;mov	byte [ALLOWED],18h
	mov	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY

	; 20/05/2019 - Retro DOS v4.0
	; DOSCODE:9937h (MSDOS 6.21, MSDOS.SYS)
	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; DOSCODE:98DBh (MSDOS 5.0, MSDOS.SYS)
GETBUFFR:
	XOR	SI,SI

;	This entry point is called for FAT buffering with SI != 0

GETBUFFRB:
	MOV	[PREREAD],AX			; save pre-read flag
	; 15/12/2022
	mov	al,[ES:BP]
	; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
	;MOV	AL,[ES:BP+DPB.DRIVE] ; mov al,[es:bp+0]
	LDS	DI,[LastBuffer]			; Get the recency pointer
	; MSDOS 6.0
;hkn; SS override
	MOV	CX,[SS:HIGH_SECTOR]		; F.C. >32mb	;AN000;

;	See if this is the buffer that was most recently returned.
;	A big performance win if it is.

	CMP	DI,-1				; Recency pointer valid?
	je	short getb5			; No
	;cmp	dx,[di+6]
	CMP	DX,[DI+BUFFINFO.buf_sector]
	JNZ	short getb5			; Wrong sector
	
	; MSDOS 6.0
	;cmp	cx,[di+8]
	CMP	CX,[DI+BUFFINFO.buf_sector+2]	; F.C. >32mb	;AN000;
	JNZ	short getb5			; F.C. >32mb	;AN000;
	
	;cmp	al,[di+4]
	CMP	AL,[DI+BUFFINFO.buf_ID]
	;JZ	getb35				; Just asked for same buffer
	jnz	short getb5
	;jmp	getb35
	; 17/12/2022
	; 28/07/2019
	jmp	getb35x
	; 07/12/2022 MSDOS 5.0 MSDOS.SYS compatibility)
	;jmp	getb35

;	It's not the buffer most recently returned. See if it's in the
;	cache.
;
;	(cx:dx) = sector #
;	(al) = drive #
;	(si) = 0 iff non fat sector, != 0 if FAT sector read
;	??? list may be incomplete ???

getb5:	
	; MSDOS 3.3
	;lds	di,[SS:BUFFHEAD]
	; MSDOS 6.0
	CALL	GETCURHEAD			; get Q Head
getb10:	
	;cmp	dx,[di+6]
	CMP	DX,[DI+BUFFINFO.buf_sector]
	jne	short getb12			; wrong sector lo
	
	; MSDOS 6.0
	;cmp	cx,[di+8]
	CMP	CX,[DI+BUFFINFO.buf_sector+2]
	jne	short getb12			; wrong sector hi
	
	;cmp	al,[di+4]
	CMP	AL,[DI+BUFFINFO.buf_ID]
	;je	short getb25 ; 05/09/2018	; Found the requested sector
	jne	short getb12
	jmp	getb25
getb12:	
	; MSDOS 3.3
	;;mov	di,[DI]
	;;;mov	di,[DI+BUFFINFO.buf_link]
	;
	; 15/08/2018
	;lds	di,[di]

	;cmp	di,-1 ; 0FFFFh
	;jne	short getb10
	;lds	di,[SS:BUFFHEAD]

	; MSDOS 6.0
	mov	di,[di]
	;mov	DI,[DI+BUFFINFO.BUF_NEXT]
	cmp	DI,[SS:FIRST_BUFF_ADDR]		; back at the front again?
	jne	short getb10			; no, continue looking

;	The requested sector is not available in the buffers. DS:DI now points
;	to the first buffer in the Queue. Flush the first buffer & read in the
;	new sector into it.
;
;	BUGBUG - what goes on here? Isn't the first guy the most recently
;	used guy? Shuld be for fast lookup. If he is, we shouldn't take
;	him, we should take LRU. And the above lookup shouldn't be
;	down a chain, but should be hashed.
;
;	(DS:DI) = first buffer in the queue
;	(CX:DX) = sector # we want
;	(si) = 0 iff non fat sector, != 0 if FAT sector read

	; MSDOS 3.3 & MSDOS 6.0
;hkn; SS override
	PUSH	CX  ; MSDOS 6.0
	push	si
	push	dx
	push	bp
	push	es
	CALL	BUFWRITE			; Write out the dirty buffer
	pop	es
	pop	bp
	pop	dx
	pop	si
	POP	word [SS:HIGH_SECTOR]  ; MSDOS 6.0
	;jc	short getbx			; if got hard error
	jnc	short getb13
	jmp	getbx

getb13:
	; MSDOS 6.0
	CALL	SET_RQ_SC_PARMS 		; set parms for secondary cache

;	We're ready to read in the buffer, if need be. If the caller
;	wanted to just *write* the buffer then we'll skip reading it in.

	XOR	AH,AH				; initial flags
;hkn; SS override
	;test	byte [ss:PREREAD],0FFh
	;jnz	short getb20
	CMP	[SS:PREREAD],ah ; 0		; am to Read in the new sector?
	JNZ	short getb20			; no, we're done
	;;lea	bx,[di+16] ; MSDOS 3.3
	;lea	bx,[di+20] ; MSDOS 6.0
	LEA	BX,[DI+BUFINSIZ] 		; (ds:bx) = data address
	;MOV	CX,1
	; 22/09/2023
	sub	cx,cx ; 0
	push	si
	push	di
	push	dx
	; MSDOS 6.0
	push	es ; ***

; Note: As far as I can tell, all disk reads into buffers go through
;	this point. -mrw 10/88
	
	;cmp	byte [ss:BuffInHMA],0	; is buffers in HMA?
	; 22/09/2023
	cmp	[ss:BuffInHMA],cl ; 0
	jz	short getb14
	push	ds ; **
	push	bx ; *
	lds	bx,[ss:LoMemBuff]	; Then let's read it into scratch buff
getb14:
;M039: Eliminated redundant HMA code.

	; 22/09/2023
	inc	cx ; cx = 1

	; MSDOS 3.3 (& MSDOS 6.0)
	OR	SI,SI			; FAT sector ?
	JZ	short getb15		

	call	FATSECRD
	;mov	ah,2
	MOV	AH,buf_isFAT		; Set buf_flags

	JMP	SHORT getb17		; Buffer is marked free if read barfs

getb15:
	call	DREAD			; Buffer is marked free if read barfs
	MOV	AH,0			; Set buf_flags to no type, DO NOT XOR!
getb17:
	; 17/12/2022	
; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
;%if 0
	; MSDOS 6.0							  ;I001
	pushf								  ;I001
	cmp	byte [SS:BuffInHMA],0	; did we read into scratch buff ? ;I001
	jz	short not_in_hma	; no				  ;I001
	;mov	cx,[es:bp+2]
	mov	cx,[ES:BP+DPB.SECTOR_SIZE]				  ;I001
	shr	cx,1							  ;I001
	popf				; Retrieve possible CY from DREAD ;I001
	mov	si,bx							  ;I001
	pop	di ; *							  ;I001
	pop	es ; **							  ;I001
	cld								  ;I001
	pushf				; Preserve possible CY from DREAD ;I001
	rep	movsw			; move the contents of scratch buf;I001
	push	es							  ;I001
	pop	ds							  ;I001
;%endif

; 17/12/2022
%if 0
	; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
	; MSDOS 5.0
	pushf
	cmp	byte [SS:BuffInHMA],0	; did we read into scratch buff ?
	jz	short not_in_hma	; no
	popf
	mov	cx,[ES:BP+DPB.SECTOR_SIZE]
	shr	cx,1
	mov	si,bx
	pop	di ; *
	pop	es ; **
	cld
	rep	movsw
	push	es
	pop	ds
	jmp	short getb19 ; 27/11/2022
%endif

not_in_hma:								  ;I001
	popf							 	  ;I001
getb19:
	pop	es ; ***
	pop	dx
	pop	di
	pop	si
	JC	short getbx

;	The buffer has the data setup in it (if we were to read)
;	Setup the various buffer fields
;
;	(ds:di) = buffer address
;	(es:bp) = DPB address
;	(HIGH_SECTOR:DX) = sector #
;	(ah) = BUF_FLAGS value
;	(si) = 0 if non fat sector, != 0 if FAT sector read

;hkn; SS override
getb20:	; MSDOS 6.0
	MOV	CX,[SS:HIGH_SECTOR]
	;mov	[di+8],cx
	MOV	[DI+BUFFINFO.buf_sector+2],CX
	; MSDOS 3.3 (& MSDOS 6.0)	
 	;mov	[di+6],dx
	MOV	[DI+BUFFINFO.buf_sector],DX
	;;mov	[di+0Ah],bp  ; MSDOS 3.3
	;mov	[di+0Dh],bp  ; MSDOS 6.0
	MOV	[DI+BUFFINFO.buf_DPB],BP
	;;mov	[di+0Ch],es
	;mov	[di+0Fh],es  ; MSDOS 6.0
	MOV	[DI+BUFFINFO.buf_DPB+2],ES
	; 15/12/2022
	mov	al,[es:bp]
	;mov	al,[es:bp+0]
	; 27/11/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;MOV	AL,[ES:BP+DPB.DRIVE]
	;mov	[di+4],ax
	MOV	[DI+BUFFINFO.buf_ID],AX		; Set ID and Flags
getb25:	
	; MSDOS 3.3
	;mov     ax,1

	; MSDOS 6.0
	;mov	byte [di+0Ah],1
	MOV	byte [DI+BUFFINFO.buf_wrtcnt],1	; Default to not a FAT sector ;AC000;
	XOR	AX,AX

	; MSDOS 3.3 (& MSDOS 6.0)
	OR	SI,SI				; FAT sector ?
	JZ	short getb30

	;mov	al,[es:bp+8]
	MOV	AL,[ES:BP+DPB.FAT_COUNT]	; update number of copies of
	
	; MSDOS 6.0
	MOV	[DI+BUFFINFO.buf_wrtcnt],AL	;  this sector present on disk
	;mov	ax,[es:bp+0Fh]
	MOV	AX,[ES:BP+DPB.FAT_SIZE]		; offset of identical FAT
						;  sectors
	; MSDOS 3.3
	;;mov	ah,[es:bp+0Fh]
	;MOV	AH,[ES:BP+DPB.FAT_SIZE]

;	BUGBUG - dos 6 can clean this up by not setting wrtcntinc unless wrtcnt
;		is set

getb30:	
	; MSDOS 6.0
	;mov	[di+0Bh],ax
	MOV	[DI+BUFFINFO.buf_wrtcntinc],AX

	; MSDOS 3.3
	;;mov	[di+8],ax ; 15/08/2018	
	;MOV	[DI+BUFFINFO.buf_wrtcnt],AX

	CALL	PLACEBUF

;hkn; SS override for next 4
getb35: 
	; 17/12/2022
	; 07/12/2022 MSDOS 5.0 MSDOS.SYS compatibility)
	; MSDOS 3.3 & MSDOS 5.0 & MSDOS 6.0
	;MOV	[SS:CURBUF+2],DS
	;MOV	[SS:LastBuffer+2],DS
	;MOV	[SS:CURBUF],DI
	;MOV	[SS:LastBuffer],DI
	;CLC

	; 17/12/2022
	; 07/12/2022
	; Retro DOS v4.0
	mov	[ss:LastBuffer+2],ds
	mov	[ss:LastBuffer],di
	clc
getb35x: ; 28/07/2019
	MOV	[ss:CURBUF+2],ds
	MOV	[ss:CURBUF],di

;	Return with 'C' set appropriately
;	(dx) = caller's original value

getbx:	
	push	ss
	pop	ds
	;retn
	; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
getbuffrb_retn:
;flushbuf_retn:	; 17/12/2022
	retn

;Break	<FLUSHBUF -- WRITE OUT DIRTY BUFFERS>
;----------------------------------------------------------------------------
; Input:
;	DS = DOSGROUP
;	AL = Physical unit number local buffers only
;	   = -1 for all units and all remote buffers
; Function:
;	Write out all dirty buffers for unit, and flag them as clean
;	Carry set if error (user FAILed to I 24)
;	    Flush operation completed.
; DS Preserved, all others destroyed (ES too)
;----------------------------------------------------------------------------

	; 20/05/2019 - Retro DOS v4.0
	; DOSCODE:9A35h (MSDOS 6.21, MSDOS.SYS)

	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; DOSCODE:99DAh (MSDOS 5.0, MSDOS.SYS)
FLUSHBUF:
	; MSDOS 3.3
	;;mov	ah,-1 ; 01/08/2018 - Retro DOS v3.0
	;lds	di,[BUFFHEAD]

	; MSDOS 6.0
	call	GETCURHEAD
	;TEST	word [ss:DOS34_FLAG],FROM_DISK_RESET ; from disk reset ? ;hkn;
	TEST	byte [ss:DOS34_FLAG],FROM_DISK_RESET ; 4
	jnz	short scan_buf_queue
	cmp	word [ss:DirtyBufferCount],0			;hkn;
	je	short end_scan
	
scan_buf_queue:
	call	CHECKFLUSH
	;push	ax  ; MSDOS 3.3
	; MSDOS 6.0
	;mov	ah,[di+4]
	mov	ah,[DI+BUFFINFO.buf_ID]
	cmp	[SS:WPERR],ah					;hkn;
	je	short free_the_buf
	;TEST	word [ss:DOS34_FLAG],FROM_DISK_RESET ; from disk reset ? ;hkn;
	TEST	byte [ss:DOS34_FLAG],FROM_DISK_RESET ; 4
	jz	short dont_free_the_buf
	; MSDOS 3.3
	;;mov	al,[di+4]
	;mov	al,[DI+BUFFINFO.buf_ID]
	;cmp	[SS:WPERR],al					;hkn;
	; 15/08/2018
	;jne	short dont_free_the_buf	
free_the_buf:
	; MSDOS 6.0 (& MSDOS 3.3)
	mov	word [DI+BUFFINFO.buf_ID],00FFh
dont_free_the_buf:
	;pop	ax  ; MSDOS 3.3 	   	

	; MSDOS 3.3
	;mov	di,[DI]
	;;mov	di,[DI+BUFFINFO.buf_link] ; .buf_next
	;
	; 15/08/2018
	;lds	di,[di]
	;
	;cmp	di,-1 ; 0FFFFh
	;jnz	short scan_buf_queue 
	
	; MSDOS 6.0
	mov	di,[di]
	;mov	di,[DI+BUFFINFO.buf_next] ; .buf_link
	cmp	di,[SS:FIRST_BUFF_ADDR]				;hkn;
	jne	short scan_buf_queue

end_scan:
	push	ss
	pop	ds
	; 01/08/2018 - Retro DOS v3.0
	;cmp	byte [FAILERR],0
	;jne	short bad_flush
	;retn
;bad_flush:
	;stc
	;retn

	; 17/12/2022
	; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
	; 01/08/2018 - Retro DOS v3.0
	cmp	byte [FAILERR],1
	cmc
flushbuf_retn:
	retn
	
	; 17/12/2022
	; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
	;cmp	byte [FAILERR],0
	;jne	short bad_flush
	;retn
;bad_flush:
	;stc
	;retn

;----------------------------------------------------------------------------
;
; Procedure Name : CHECKFLUSH
;
; Inputs : AL - Drive number, -1 means do not check for drive
;	   DS:DI - pointer to buffer
;
; Function : Write out a buffer if it is dirty
;
; Carry set if problem (currently user FAILed to I 24)
;
;----------------------------------------------------------------------------

CHECKFLUSH:
	; MSDOS 6.0
	mov	ah,-1	; 01/08/2018 Retro DOS v3.0
	;cmp	[di+4],ah
	CMP	[DI+BUFFINFO.buf_ID],AH
	jz	short flushbuf_retn	; Skip free buffer, carry clear
	CMP	AH,AL			; 
	JZ	short DOBUFFER		; do this buffer
	;cmp	al,[di+4]
	CMP	AL,[DI+BUFFINFO.buf_ID]
	CLC
	jnz	short flushbuf_retn	; Buffer not for this unit or SFT
DOBUFFER:
	;test	byte [di+5],40h
	TEST	byte [DI+BUFFINFO.buf_flags],buf_dirty
	jz	short flushbuf_retn	; Buffer not dirty, carry clear by TEST
	PUSH	AX
	;push	word [di+4]
	PUSH	WORD [DI+BUFFINFO.buf_ID]
	CALL	BUFWRITE
	POP	AX
	JC	short LEAVE_BUF		; Leave buffer marked free (lost).
	;and	ah,0BFh
	AND	AH,~buf_dirty		; Buffer is clean, clears carry
	;mov	[di+4],ax
	MOV	[DI+BUFFINFO.buf_ID],AX
LEAVE_BUF:
	POP	AX			; Search info
checkflush_retn:
	retn

;Break	<BUFWRITE -- WRITE OUT A BUFFER IF DIRTY>
;----------------------------------------------------------------------------
;
;	BufWrite writes a buffer to the disk, if it's dirty.
;
;	ENTRY	DS:DI Points to the buffer
;
;	EXIT	Buffer marked free
;		Carry set if error (currently user FAILed to I 24)
;
;	USES	All buf DS:DI
;		HIGH_SECTOR
;----------------------------------------------------------------------------

	; 20/05/2019 - Retro DOS v4.0
	; DOSCODE:9AA0h (MSDOS 6.21, MSDOS.SYS)


	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; DOSCODE:9A45h (MSDOS 5.0, MSDOS.SYS)

BUFWRITE:
	; 10/09/2018
	; 01/08/2018 - Retro DOS v3.0
	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5E94h
	MOV	AX,00FFH
	;xchg	ax,[di+4]
	XCHG	AX,[DI+BUFFINFO.buf_ID]	; Free, in case write barfs
	CMP	AL,0FFH
	jz      short checkflush_retn	; Buffer is free, carry clear.
	;test	ah,40h
	test	AH,buf_dirty
	jz      short checkflush_retn	; Buffer is clean, carry clear.
	; MSDOS 6.0
	call	DEC_DIRTY_COUNT 	; LB. decrement dirty count

;hkn; SS override
	CMP	AL,[SS:WPERR]
	jz      short checkflush_retn	; If in WP error zap buffer

;hkn; SS override
	; MSDOS 6.0
	MOV	[SS:SC_DRIVE],AL	;LB. set it for invalidation ;AN000;
	
	;;les	bp,[di+10] ; MSDOS 3.3
	;les	bp,[di+13] ; MSDOS 6.0
	LES	BP,[DI+BUFFINFO.buf_DPB]
	;;lea	bx,[di+16]
	;lea	bx,[di+20] ; MSDOS 6.0
	LEA	BX,[DI+BUFINSIZ]	; Point at buffer
	;mov	dx,[di+6]
	MOV	DX,[DI+BUFFINFO.buf_sector] ;F.C. >32mb		;AN000;
	
	; MSDOS 6.0
	;mov	cx,[di+8]
	MOV	CX,[DI+BUFFINFO.buf_sector+2] ;F.C. >32mb	;AN000;

;hkn; SS override
	MOV	[SS:HIGH_SECTOR],CX	;F.C. >32mb		;AN000;
	MOV	CL,[DI+BUFFINFO.buf_wrtcnt] ;>32mb		;AC000;
	; MSDOS 3.3
	;; mov	cx,[DI+8]
	;mov	cx,[DI+BUFFINFO.buf_wrtcnt]
	;MOV	AL,CH			; [DI+BUFFINFO.buf_wrtcntinc]
	XOR	CH,CH
	;;mov	ah,ch ; MSDOS 3.3

;hkn; SS override for ALLOWED
	;mov	byte [SS:ALLOWED],18h
	MOV	byte [SS:ALLOWED],Allowed_RETRY+Allowed_FAIL
	;test	byte [di+5],8
	; MSDOS 6.0 (& Retro DOS 3.0)
	;test	ah,8
	test	AH,buf_isDATA
	JZ	short NO_IGNORE
	;or	byte [SS:ALLOWED],20h
	OR	byte [SS:ALLOWED],Allowed_IGNORE
NO_IGNORE:
	;xor	ah,ah ; 10/09/2018 (MSDOS 3.3, Retro DOS v3.0)
	; MSDOS 6.0
	;mov	ax,[di+11]
	MOV	AX,[DI+BUFFINFO.buf_wrtcntinc]	;>32mb		;AC000;

	PUSH	DI		; Save buffer pointer
	XOR	DI,DI		; Indicate failure

	push	ds ; *
	push	bx ; **
WRTAGAIN:
	push	di ; ***
	push	cx ; ****
	push	ax ; *****
	;MOV	CX,1
	; 17/12/2022
	; ch = 0
	mov	cl,1 ; 24/07/2019
	; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
	;mov	cx,1
	push	bx ; ******
	push	dx ; *******
	push	ds ; ********

; Note: As far as I can tell, all disk reads into buffers go through this point. -mrw 10/88

	; MSDOS 6.0
	;cmp	byte [ss:BuffInHMA],0 ; 10/06/2019
	; 22/09/2023
	cmp	[ss:BuffInHMA],ch ; 0
	jz	short NBUFFINHMA
	push	cx
	push	es
	mov	si,bx
	mov	cx,[es:bp+DPB.SECTOR_SIZE]
	shr	cx,1
	les	di,[ss:LoMemBuff] ; 10/06/2019
	mov	bx,di
	cld
	rep	movsw
	push	es
	pop	ds
	pop	es
	pop	cx
NBUFFINHMA:
	call	DWRITE		; Write out the dirty buffer
	pop	ds ; ********
	pop	dx ; *******
	pop	bx ; ******
	pop	ax ; *****
	pop	cx ; ****
	pop	di ; ***
	JC	short NOSET
	INC	DI		; If at least ONE write succeedes, the operation
NOSET:				;	succeedes.
	ADD	DX,AX
	LOOP	WRTAGAIN
	pop	bx ; **
	pop	ds ; *
	;OR	DI,DI		; Clears carry
	;JNZ	short BWROK	; At least one write worked
	;STC			; DI never got INCed, all writes failed.
	; 22/09/2023
	cmp	di,1
BWROK:	
	POP	DI
	retn

;**	Set_RQ_SC_Parms - Set Secondary Cache Parameters
;----------------------------------------------------------------------------
;	Set_RQ_SC_Parms sets the sector size and drive number value
;	for the secondary cache. This updates SC_SECTOR_SIZE &
;	SC_DRIVE even if SC is disabled to save the testing
;	code and time
;
;	ENTRY	ES:BP = drive parameter block
;
;	EXIT	[SC_SECTOR_SIZE]= drive sector size
;		[SC_DRIVE]= drive #
;
;	USES	Flags
;----------------------------------------------------------------------------

; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; 04/05/2019 - Retro DOS v4.0

SET_RQ_SC_PARMS:
;hkn; SS override for all variables used in this procedure.
	push	ax
	;mov	ax,[es:bp+2]
	MOV	ax,[ES:BP+DPB.SECTOR_SIZE]	; save sector size
	MOV	[ss:SC_SECTOR_SIZE],ax
	;;mov	al,[es:bp+0]
	; 27/11/2022 MSDOS 5.0 MSDOS.SYS compatibility)
	;MOV	al,[ES:BP+DPB.DRIVE]		; save drive #
	; 15/12/2022
	mov	al,[ES:BP]
	MOV	[ss:SC_DRIVE],al
	pop	ax
srspx:	
	retn					;LB. return

;Break	<INC_DIRTY_COUNT-increment dirty count>
;----------------------------------------------------------------------------
; Input:
;	none
; Function:
;	increment dirty buffers count
; Output:
;	dirty buffers count is incremented
;
; All registers preserved
;----------------------------------------------------------------------------

INC_DIRTY_COUNT:
;; BUGBUG  ---- remove this routine
;; BUGBUG ---- only one instruction is needed (speed win, space loose)
	inc	word [ss:DirtyBufferCount]	;hkn;
	retn

;Break	<DEC_DIRTY_COUNT-decrement dirty count>
;----------------------------------------------------------------------------
; Input:
;	none
; Function:
;	decrement dirty buffers count
; Output:
;	dirty buffers count is decremented
;
; All registers preserved
;----------------------------------------------------------------------------

DEC_DIRTY_COUNT:
	cmp	word [ss:DirtyBufferCount],0 ;hkn;
	jz	short ddcx		; BUGBUG - shouldn't it be an
	dec	word [ss:DirtyBufferCount] 
					; error condition to underflow here? ;hkn;
ddcx:	
	retn

;============================================================================
; MSPROC.ASM, MSDOS 6.0, 1992
;============================================================================
; 02/08/2018 - Retro DOS v3.0
; 29/04/2019 - Retro DOS v4.0

; (15/04/2018 - RetrO DOS v2.0, MSDOS 2.11 - PROC.ASM - 1983)

; Pseudo EXEC system call for DOS

;	TITLE	MSPROC - process maintenance
;	NAME	MSPROC

; =========================================================================
;**	Process related system calls and low level routines for DOS 2.X.
;	I/O specs are defined in DISPATCH.
;
;	$WAIT
;	$EXEC
;	$Keep_process
;	Stay_resident
;	$EXIT
;	$ABORT
;	abort_inner
;
;	Modification history:
;
;		Created: ARR 30 March 1983
;		AN000	version 4.0 jan. 1988
;		A007	PTM 3957 - fake vesrion for IBMCACHE.COM
;		A008	PTM 4070 - fake version for MS WINDOWS
;
;		M000	added support for loading programs into UMBs 7/9/90
;
;		M004 - MS PASCAL 3.2 support. Please see under tag M003 in 
;		       dossym.inc. 7/30/90
;		M005 - Support for EXE programs with out STACK segment and 
;		       with resident size < 64K - 256 bytes. A 256 byte 
;		       stack is provided at the end of the program. Note that
;		       only SP is changed.
;		M020 - Fix for Rational bug for details see exepatch.asm
;
;		M028 - 4b04 implementation
;
;		M029 - Support for EXEs without stack rewritten. If EXE is
;			in memory block >= 64K, sp = 0. If memory block
;			obtained is <64K, point sp at the end of the memory
;			block. For EXEs smaller than 64K, 256 bytes are still
;			added for a stack segment which may be needed if it
;			is loaded in low memory situations.
;
;		M030 - Fixing bug in EXEPACPATCH & changing 4b04 to 4b05
;
;		M040 - Bug #3052. The environment sizing code would flag a
;			a bad environment if it reached 32767 bytes. Changed
;			to allow 32768 bytes of environment.
;
;		M047 - Release the allocated UMB when we failed to load a 
;		       COM file high. Also ensure that if the biggest block
;		       into which we load the com file is less than 64K then
;		       we provide atleast 256 bytes of stack to the user.
;
;		M050 - Made Lie table search CASE insensitive
;
;		M060 - Removed special version table from the kernal and
;                      put it in a device drive which puts the address
;                      in the DOS DATA area location UU_IFS_DOS_CALL
;		       as a DWORD.
;
;		M063 - Modified UMB support. If the HIGH_ONLY bit is set on
;		       entry do not try to load low if there is no space in
;		       UMBs.
;
;		M068 - Support for copy protect apps. Call ChkCopyProt to 
;		       set a20off_count. Set bit EXECA20BIT in DOS_FLAG. Also
;		       change return address to LeaveDos if AL=5.
;
;               20-Jul-1992 bens  Added ifdef RESTRICTED_BUILD code that
;                      controls building a version of MSDOS.SYS that only
;                      runs programs from a fixed list (defined in the
;                      file RESTRICT.INC).  Search for "RESTRICTED_BUILD"
;                      for details.  This feature is used to build a
;                      "special" version of DOS that can be handed out to
;                      OEM/ISV customers as part of a "service" disk.
;
; =========================================================================

;SAVEXIT  EQU  10

;BREAK	<$WAIT - return previous process error code>
; =========================================================================
;	$WAIT - Return previous process error code.
;
;	Assembler usage:
;
;	    MOV     AH, WaitProcess
;	    INT     int_command
;
;	ENTRY	none
;	EXIT	(ax) = exit code
;	USES	all
; =========================================================================

	; 20/05/2019 - Retro DOS v4.0
	; DOSCODE:9B55h (MSDOS 6.21, MSDOS.SYS)

	; 27/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; DOSCODE:9A5Ah (MSDOS 5.0, MSDOS.SYS)	
_$WAIT:
	; 02/08/2018 - Retro DOS v3.0
	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5E1h

	xor	AX,AX
	xchg	AX,[ss:exit_code]
	jmp	SYS_RET_OK

; =========================================================================
;BREAK <$exec - load/go a program>
;	EXEC.ASM - EXEC System Call
;
;
; Assembler usage:
;	    lds     DX, Name
;	    les     BX, Blk
;	    mov     AH, Exec
;	    mov     AL, FUNC
;	    int     INT_COMMAND
;
;	AL  Function
;	--  --------
;	 0  Load and execute the program.
;	 1  Load, create the program header but do not
;	    begin execution.
;	 3  Load overlay. No header created.
;
;	    AL = 0 -> load/execute program
;
;	    +---------------------------+
;	    | WORD segment address of	|
;	    | environment.		|
;	    +---------------------------+
;	    | DWORD pointer to ASCIZ	|
;	    | command line at 80h	|
;	    +---------------------------+
;	    | DWORD pointer to default	|
;	    | FCB to be passed at 5Ch	|
;	    +---------------------------+
;	    | DWORD pointer to default	|
;	    | FCB to be passed at 6Ch	|
;	    +---------------------------+
;
;	    AL = 1 -> load program
;
;	    +---------------------------+
;	    | WORD segment address of	|
;	    | environment.		|
;	    +---------------------------+
;	    | DWORD pointer to ASCIZ	|
;	    | command line at 80h	|
;	    +---------------------------+
;	    | DWORD pointer to default	|
;	    | FCB to be passed at 5Ch	|
;	    +---------------------------+
;	    | DWORD pointer to default	|
;	    | FCB to be passed at 6Ch	|
;	    +---------------------------+
;	    | DWORD returned value of	|
;	    | CS:IP			|
;	    +---------------------------+
;	    | DWORD returned value of	|
;	    | SS:IP			|
;	    +---------------------------+
;
;	    AL = 3 -> load overlay
;
;	    +---------------------------+
;	    | WORD segment address where|
;	    | file will be loaded.	|
;	    +---------------------------+
;	    | WORD relocation factor to |
;	    | be applied to the image.	|
;	    +---------------------------+
;
; Returns:
;	    AX = error_invalid_function
;	       = error_bad_format
;	       = error_bad_environment
;	       = error_not_enough_memory
;	       = error_file_not_found
; =========================================================================
;
;   Revision history:
;
;	 A000	version 4.00  Jan. 1988
;
; =========================================================================

Exec_Internal_Buffer		EQU	OPENBUF
Exec_Internal_Buffer_Size	EQU	(128+128+53+curdirLen)

; =========================================================================

;IF1		; warning message on buffers
;%out	Please make sure that the following are contiguous and of the
;%out	following sizes:
;%out
;%out	OpenBuf     128
;%out	RenBuf	    128
;%out	SearchBuf    53
;%out	DummyCDS    curdirLen
;ENDIF

; =========================================================================

; =========================================================================
;
; =========================================================================

	; 20/05/2019 - Retro DOS v4.0
	; DOSCODE:9B5Fh (MSDOS 6.21, MSDOS.SYS)

	; 30/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; DOSCODE:9B04h (MSDOS 5.0, MSDOS.SYS)
	
_$EXEC:
	; 02/08/2018 - Retro DOS v3.0
	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5EF1h

EXEC001S:
	;LocalVar    Exec_Blk		,DWORD
	;LocalVar    Exec_Func		,BYTE
	;LocalVar    Exec_Load_High	,BYTE
	;LocalVar    Exec_FH		,WORD
	;LocalVar    Exec_Rel_Fac	,WORD
	;LocalVar    Exec_Res_Len_Para	,WORD
	;LocalVar    Exec_Environ	,WORD
	;LocalVar    Exec_Size		,WORD
	;LocalVar    Exec_Load_Block	,WORD
	;LocalVar    Exec_DMA		,WORD
	;LocalVar    ExecNameLen 	,WORD
	;LocalVar    ExecName		,DWORD
	;
	;LocalVar    Exec_DMA_Save	,WORD
	;LocalVar    Exec_NoStack	,BYTE

	; MSDOS 3.3 (& MSDOS 6.0)
	;%define	Exec_Blk	dword [bp-4]
	%define		Exec_Blk	[bp-4] ; 09/08/2018
	%define		Exec_BlkL	word [bp-4]	
	%define		Exec_BlkH	word [bp-2]
	%define		Exec_Func	byte [bp-5]
	%define		Exec_Load_High	byte [bp-6]
	%define		Exec_FH		word [bp-8]
	%define		Exec_Rel_Fac	word [bp-10]
	%define		Exec_Res_Len_Para word [bp-12]
	%define		Exec_Environ	word [bp-14]
	%define		Exec_Size	word [bp-16]
	%define		Exec_Load_Block	word [bp-18]
	%define		Exec_DMA	word [bp-20]
	%define		ExecNameLen	word [bp-22]
	;%define	ExecName	dword [bp-26]
	%define		ExecName	[bp-26] ; 09/08/2018
	%define		ExecNameL	word [bp-26]	
	%define		ExecNameH	word [bp-24]
	; MSDOS 6.0
	%define		Exec_DMA_Save	word [bp-28]
	%define		Exec_NoStack	byte [bp-29]
	
	; ==================================================================
	; validate function
	; ==================================================================
		      	
	; M068 - Start
	;
	; Reset the A20OFF_COUNT to 0. This is done as there is a 
	; possibility that the count may not be decremented all the way to
	; 0. A typical case is if the program for which we intended to keep 
	; the A20  off for a sufficiently long time (A20OFF_COUNT int 21 
	; calls), exits pre-maturely due to error conditions.

	; MSDOS 6.0
	mov	byte [SS:A20OFF_COUNT], 0

	; If al=5 (ExecReady) we'll change the return address on the stack	
	; to be LeaveDos in msdisp.asm. This ensures that the EXECA20OFF
	; bit set in DOS_FLAG by ExceReady is not cleared in msdisp.asm

	cmp	al,5			; Q: is this ExecReady call
	;jne	short @f
	jne	short Exec_@f		; N: continue
					; Y: change ret addr. to LeaveDos.
	pop	cx			; Note CX is not input to ExecReady
	mov	cx,LeaveDOS
	push	cx
;@@:
Exec_@f:
	; M068 - End
	
	;Enter

	push	bp
	mov	bp,sp
	;;sub	sp,26	; MSDOS 3.3
	; 30/11/2022 (MSDOS 5.0, MSDOS.SYS compatibility)	
	;sub	sp,29	; MSDOS 6.0 (& MSDOS 6.21)
	; 17/12/2022
	; 20/05/2019
	sub	sp,30	; Retro DOS v4.0	

	; MSDOS 6.0
	cmp	AL,5			; only 0, 1, 3 or 5 are allowed ;M028
					; M030
	jna	short Exec_Check_2

	; MSDOS 3.3
	;cmp	AL,3
	;jna	short Exec_Check_2

Exec_Bad_Fun:
	mov	byte [ss:EXTERR_LOCUS],errLOC_Unk ; 1
					; Extended Error Locus	;smr;SS Override
	;mov	al,1
	mov	al,error_invalid_function

Exec_Ret_Err:
	;Leave
	mov	sp,bp
	pop	bp
	;transfer SYS_RET_ERR
	jmp	SYS_RET_ERR

	; MSDOS 6.0
ExecReadyJ:
	call	ExecReady		; M028
	jmp	norm_ovl		; do a Leave & xfer sysret_OK ; M028

Exec_Check_2:
	cmp	AL,2			
	je	short Exec_Bad_Fun

	; MSDOS 6.0
	cmp	al,4			; 2 & 4 are not allowed
	je	short Exec_Bad_Fun
	
	cmp	al,5			; M028 ; M030
	je	short ExecReadyJ	; M028

	;mov	[bp-4],bx
	mov	Exec_BlkL,BX		; stash args
	;mov	[bp-2],es
	mov	Exec_BlkH,ES
	;mov	[bp-5],al
	mov	Exec_Func,AL
	;mov	byte [bp-6],0
	mov	Exec_Load_High,0

	;mov	[bp-26],dx
	mov	ExecNameL,DX		; set up length of exec name
	;mov	[bp-24],ds
	mov	ExecNameH,DS
	mov	SI,DX			; move pointer to convenient place
	;invoke	DStrLen
	call	DStrLen
	;mov	[bp-22],cx
	mov	ExecNameLen,CX		; save length

	; MSDOS 6.0
	mov	al,[ss:AllocMethod]	; M063: save alloc method in 
	mov	[ss:ALLOCMSAVE],al	; M063: AllocMsave

	xor	AL,AL			; open for reading
	push	BP

	; MSDOS 6.0
	;or	byte [ss:DOS_FLAG],1
	or	byte [ss:DOS_FLAG],EXECOPEN ; this flag is set to indicate to 
					; the redir that this open call is
					; due to an exec.

	;invoke	$OPEN			; is the file there?
	call	_$OPEN

	; MSDOS 6.0
	pushf
	; 02/06/2019
	;and	byte [ss:DOS_FLAG],0FEh
	and	byte [ss:DOS_FLAG],~EXECOPEN ; reset flag
	popf

	pop	BP

	; MSDOS 3.3 & MSDOS 6.0
	jc	short Exec_Ret_Err

	;mov	[bp-8],ax
	mov	Exec_FH,AX
	mov	BX,AX
	xor	AL,AL
	;invoke	$Ioctl
	call	_$IOCTL
	jc	short Exec_BombJ

	;test	dl,80h
	test	DL,devid_ISDEV
	jz	short Exec_Check_Environ

	;mov	al,2
	mov	AL,error_file_not_found
Exec_BombJ:
	jmp	Exec_Bomb

BadEnv:
	;mov	al,0Ah
	mov	AL,error_bad_environment
	jmp	Exec_Bomb

Exec_Check_Environ:
	;mov	word [bp-18],0
	mov	Exec_Load_Block,0
	;mov	word [bp-14],0
	mov	Exec_Environ,0
					; overlays... no environment
	;test	byte [bp-5],2
	test	Exec_Func,exec_func_overlay
	jnz	short Exec_Read_Header

	;lds	si,[bp-4]
	lds	SI,Exec_Blk		; get block
	mov	ax,[SI]
	;mov	AX,[SI+EXEC1.ENVIRON]	; address of environ
	or	AX,AX
	jnz	short Exec_Scan_Env

	mov	DS,[SS:CurrentPDB]	;smr;SS Override
	;mov	ax,[44]
	mov	AX,[PDB.ENVIRON]

; MSDOS 6.0
;---------------------------------------------BUG 92 4/30/90-----------------
;
; Exec_environ is being correctly initialized after the environment has been
; allocated and copied form the parent's env. It must not be initialized here.
; Because if the call to $alloc below fails Exec_dealloc will deallocate the
; parent's environment.
;	mov	Exec_Environ,AX
;
;----------------------------------------------------------------------------

	;mov	[bp-14],ax
	;mov	Exec_Environ,ax

	or	AX,AX
	jz	short Exec_Read_Header

Exec_Scan_Env:
	mov	ES,AX
	xor	DI,DI
	;mov	cx,7FFFh ; MSDOS 3.3
	mov	CX,8000h ; MSDOS 6.0	; at most 32k of environment ;M040
	xor	AL,AL

Exec_Get_Environ_Len:
	repnz	scasb			; find that nul byte
	jnz	short BadEnv

	dec	CX			; Dec CX for the next nul byte test
	js	short BadEnv		; gone beyond the end of the environment

	scasb				; is there another nul byte?
	jnz	short Exec_Get_Environ_Len ; no, scan some more

	push	DI
	;lea	bx,[DI+11h]
	lea	BX,[DI+0Fh+2]
	;add	bx,[bp-22]
	add	BX,ExecNameLen		; BX <- length of environment
					; remember argv[0] length
					; round up and remember argc
	mov	CL,4
	shr	BX,CL			; number of paragraphs needed
	push	ES
	;invoke	$Alloc			; can we get the space?
	call	_$ALLOC
	pop	DS
	pop	CX

	;jnc	short Exec_Save_Environ
	;jmp	SHORT Exec_No_Mem	; nope... cry and sob
	; 17/12/2022
	jc	short Exec_No_Mem ; 02/06/2019
	; 30/11/2022 (MSDOS 5.0, MSDOS.SYS compatibility)
	;jnc	short Exec_Save_Environ
	;jmp	SHORT Exec_No_Mem

Exec_Save_Environ:
	mov	ES,AX
	;mov	[bp-14],ax
	mov	Exec_Environ,AX 	; save him for a rainy day
	xor	SI,SI
	mov	DI,SI
	rep	movsb			; copy the environment
	mov	AX,1
	stosw
	;lds	si,[bp-26]
	lds	SI,ExecName
	;mov	cx,[bp-22]
	mov	CX,ExecNameLen
	rep	movsb

Exec_Read_Header:
	; We read in the program header into the above data area and
	; determine where in this memory the image will be located.

	;Context DS
	push	ss
	pop	ds
	;mov	cx,26
	mov	CX,exec_header_len	; header size
	mov	DX,exec_signature
	push	ES
	push	DS
	call	ExecRead
	pop	DS
	pop	ES
	jc	short Exec_Bad_File

	or	AX,AX
	jz	short Exec_Bad_File
	;cmp	ax,26
	cmp	AX,exec_header_len	; did we read the right number?
	jnz	short Exec_Com_Filej	; yep... continue

	test	word [exec_max_BSS],-1 	; indicate load high?
	jnz	short Exec_Check_Sig

	;mov	byte [bp-6],0FFh
	mov	Exec_Load_High,-1

Exec_Check_Sig:
	mov	AX,[exec_signature]	; rms;NSS
	;cmp	ax,5A4Dh ; 'MZ'
	cmp	AX,exe_valid_signature	; zibo arises!
	jz	short Exec_Save_Start 	; assume com file if no signature

	;cmp	ax,4D5Ah ; 'ZM'
	cmp	AX,exe_valid_old_signature  ; zibo arises!
	jz	short Exec_Save_Start 	; assume com file if no signature

Exec_Com_Filej:
	jmp	Exec_Com_File

	; We have the program header... determine memory requirements

Exec_Save_Start:
	mov	AX,[exec_pages]		; get 512-byte pages	;rms;NSS
	mov	CL,5			; convert to paragraphs
	shl	AX,CL
	sub	AX,[exec_par_dir] 	; AX = size in paragraphs ;rms;NSS
	;mov	[bp-12],ax
	mov	Exec_Res_Len_Para,AX

		; Do we need to allocate memory?
		; Yes if function is not load-overlay

	;test	byte [bp-5],2
	test	Exec_Func,exec_func_overlay
	jz	short Exec_Allocate	; allocation of space

		; get load address from block

	;les	di,[bp-4]
	les	DI,Exec_Blk
	mov	ax,[es:di]
	;mov	AX,[ES:DI+EXEC3.load_addr]
	;mov	[bp-20],ax
	mov	Exec_DMA,AX

	; 17/12/2022
	;;mov	ax,[es:di+2]
	;mov	AX,[ES:DI+EXEC3.reloc_fac]
	;;mov	[bp-10],ax
	;mov	Exec_Rel_Fac,AX

	; 17/12/2022
	; 30/11/2022 (!most proper code!)
	;mov	dx,[es:di+2]
	mov	dx,[ES:DI+EXEC3.reloc_fac]
	;mov	[bp-10],dx
	mov	Exec_Rel_Fac,dx
	; ax = Exec_DMA
	jmp	Exec_Find_Res

; 17/12/2022
; 30/11/2022 (MSDOS 5.0, MSDOS.SYS compatibility)
; 27/09/2023
%if 0
	; 02/06/2019 - Retro DOS v4.0
	;mov	ax,[bp-20]  ; *+*
	mov	AX,Exec_DMA ; *+*
	; 10/08/2018
	jmp	Exec_Find_Res		; M000
%endif

Exec_No_Mem:
	;mov	al,8
	mov	AL,error_not_enough_memory
	jmp	short Exec_Bomb

Exec_Bad_File:
	;mov	al,0Bh
	mov	AL,error_bad_format

Exec_Bomb:
	;mov	bx,[bp-8]
	mov	BX,Exec_FH
	call	Exec_Dealloc
	;LeaveCrit CritMem
	call	LCritMEM
	;save	<AX,BP>
	push	ax
	push	bp
	;invoke	$CLOSE
	call	_$CLOSE
	;restore <BP,AX>
	pop	bp
	pop	ax
	jmp	Exec_Ret_Err

Exec_Chk_Mem: 

	; 24/09/2023
	; ds = DOSDATA
; 17/12/2022
; 30/11/2022 (MSDOS 5.0, MSDOS.SYS compatibility)
;%if 0
	; MSDOS 6.0    			; M063 - Start
	;mov	al,[ss:AllocMethod]	; save current alloc method in ax
	; 10/06/2019
	mov	al,[AllocMethod]
	;mov	bl,[ss:ALLOCMSAVE]
	mov	bl,[ALLOCMSAVE]
	;mov	[ss:AllocMethod],bl	; restore original allocmethod
	mov	[AllocMethod],bl
	
	test	bl,HIGH_ONLY ; 40h	; Q: was the HIGH_ONLY bit already set
	jnz	short Exec_No_Mem	; Y: no space in UMBs. Quit
	;				; N: continue
	;
	test	al,HIGH_ONLY		; Q: did we set the HIGH_ONLY bit
	jz	short Exec_No_Mem	; N: no memory 
	; 02/06/2019
	;mov	ax,[ss:SAVE_AX]		; Y: restore ax and
	mov	ax,[SAVE_AX]
	;jmp	short Exec_Norm_Alloc	;    Try again
					; M063 - End
	jmp	short Exec_Norm_Alloc1
;%endif

; 17/12/2022
%if 0
	; 30/11/2022 (MSDOS 5.0, MSDOS.SYS compatibility)
	; MSDOS 6.0    			; M063 - Start
	mov	al,[ss:AllocMethod]	; save current alloc method in ax
	mov	bl,[ss:ALLOCMSAVE]
	mov	[ss:AllocMethod],bl	; restore original allocmethod

	test	bl,HIGH_ONLY ; 40h	; Q: was the HIGH_ONLY bit already set
	jnz	short Exec_No_Mem	; Y: no space in UMBs. Quit
	;				; N: continue
	;
	test	al,HIGH_ONLY		; Q: did we set the HIGH_ONLY bit
	jz	short Exec_No_Mem	; N: no memory 

	mov	ax,[ss:SAVE_AX]		; Y: restore ax and
	jmp	short Exec_Norm_Alloc	;    Try again
					; M063 - End
%endif

Exec_Allocate:
	; 09/09/2018

	; M005 - START
	; If there is no STACK segment for this exe file and if this
	; not an overlay and the resident size is less than 64K - 
	; 256 bytes we shall add 256 bytes to the programs 
	; resident memory requirement and set Exec_SP to this value.
	
	; 17/12/2022
	sub	bx,bx ; 0	

	; MSDOS 6.0
	;;mov	byte [bp-29],0
	;mov	Exec_NoStack,0
	; 17/12/2022
	mov	Exec_NoStack,bl ; 0
	cmp	[exec_SS],bx ; 0
	;cmp	word [exec_SS],0	; Q: is there a stack seg
	jne	short ea1		; Y: continue normal processing
	cmp	[exec_SP],bx ; 0
	;cmp	word [exec_SP],0	; Q: is there a stack ptr
	jne	short ea1		; Y: continue normal processing

	;inc	byte [bp-29]
	inc	Exec_NoStack
	cmp	ax,1000h-10h		; Q: is this >= 64K-256 bytes
	jae	short ea1		; Y: don't set Exec_SP

	add	ax,10h			; add 10h paras to mem requirement
ea1:
	; M005 - END

	; MSDOS 6.0			; M000 - start
	; 20/05/2019
	; (ds = ss = DOSDATA)
	test	byte [AllocMethod],HIGH_FIRST ; 80h
					; Q: is the alloc strat high_first
	jz	short Exec_Norm_Alloc	; N: normal allocate
					; Y: set high_only bit
	or	byte [AllocMethod],HIGH_ONLY ; 40h
					; M000 - end
Exec_Norm_Alloc:
	mov	[SAVE_AX],ax		; M000: save ax for possible 2nd  
Exec_Norm_Alloc1:	; 02/06/2019
					; M000: attempt at allocating memory
	; MSDOS 3.3
	;push	ax			; M000

	mov	BX,0FFFFh		; see how much room in arena
	push	DS
	;invoke	$Alloc			; should have carry set and BX has max
	call	_$ALLOC
	pop	DS

	; MSDOS 6.0
	mov	AX,[SAVE_AX]		; M000
	; MSDOS 3.3
	;pop	ax			; M000

	add	AX,10h			; room for header
	cmp	BX,11h			; enough room for a header
	; MSDOS 6.0
	jb	short Exec_Chk_Mem	; M000
	; MSDOS 3.3	
	;jb	short Exec_No_Mem

	cmp	AX,BX			; is there enough for bare image?
	; MSDOS 6.0
	ja	short Exec_Chk_Mem	; M000
	; MSDOS 3.3
	;ja	short Exec_No_Mem

	;test	byte [bp-6],0FFh
	test	Exec_Load_High,-1	; if load high, use max
	jnz	short Exec_BX_Max	; use max

	; 09/09/2018

	add	AX,[exec_min_BSS] 	; go for min allocation;rms;NSS
	; MSDOS 6.0
	jc	short Exec_Chk_Mem		; M000
	; MSDOS 3.3
	;jc	short Exec_No_Mem

	cmp	AX,BX			; enough space?
	; MSDOS 6.0
	ja	short Exec_Chk_Mem	; M000: nope...	
	; MSDOS 3.3
	;ja	short Exec_No_Mem

	sub	AX,[exec_min_BSS] 	; rms;NSS
	add	AX,[exec_max_BSS] 	; go for the MAX
	jc	short Exec_BX_Max

	cmp	AX,BX
	jbe	short Exec_Got_Block

Exec_BX_Max:
	mov	AX,BX

Exec_Got_Block:
	; 03/08/2018 - Retro DOS v3.0

	push	DS
	mov	BX,AX
	;mov	[bp-16],bx
	mov	Exec_Size,BX
	;invoke	$Alloc			; get the space
	call	_$ALLOC
	pop	DS
	; MSDOS 6.0
	;jc	short Exec_Chk_Mem	; M000
	; MSDOS 3.3
	;;jc	short Exec_No_Mem
	; 20/05/2019
	jnc	short ea0
	jmp	Exec_Chk_Mem
ea0:
	; MSDOS 6.0
	mov	cl,[ALLOCMSAVE]		; M063: 
	mov	[AllocMethod],cl	; M063: restore allocmethod

;M029; Begin changes
; This code does special handling for programs with no stack segment. If so,
;check if the current block is larger than 64K. If so, we do not modify
;Exec_SP. If smaller than 64K, we make Exec_SP = top of block. In either
;case Exec_SS is not changed.

	; MSDOS 6.0
	;cmp	byte [bp-29],0
	cmp	Exec_NoStack,0
	;je	@f
	je	short ea2

	cmp	bx,1000h		; Q: >= 64K memory block
	;jae	@f			; Y: Exec_SP = 0
	jae	short ea2

;Make Exec_SP point at the top of the memory block

	mov	cl,4
	shl	bx,cl			; get byte offset
	sub	bx,100h			; take care of PSP
	mov	[exec_SP],bx		; Exec_SP = top of block
ea2:
;@@:
;M029; end changes

	;mov	[bp-18],ax
	mov	Exec_Load_Block,AX
	add	AX,10h
	;test	byte [bp-6],0FFh
	test	Exec_Load_High,-1
	jz	short Exec_Use_AX	; use ax for load info

	;add	ax,[bp-16]
	add	AX,Exec_Size		; go to end
	;sub	ax,[bp-12]
	sub	AX,Exec_Res_Len_Para	; drop off header
	sub	AX,10h			; drop off pdb

Exec_Use_AX:
	;mov	[bp-10],ax
	mov	Exec_Rel_Fac,AX 	; new segment
	;mov	[bp-20],ax
	mov	Exec_DMA,AX ; *+*	; beginning of dma

	; Determine the location in the file of the beginning of
	; the resident

; 17/12/2022
; 30/11/2022 (MSDOS 5.0, MSDOS.SYS compatibility)
;%if 0

Exec_Find_Res:
	; MSDOS 6.0
	;;mov	dx,[bp-20]
	;mov	DX,Exec_DMA ; *+*
	;;mov	[bp-28],dx
	;mov	Exec_DMA_Save,DX

	; 17/12/2022
	; AX = Exec_DMA

	; 02/06/2019 - Retro DOS v4.0
	;mov	[bp-28],ax ; *+*
	mov	Exec_DMA_Save,AX ; *+*

;%endif

; 17/12/2022
%if 0
	; 30/11/2022 (MSDOS 5.0, MSDOS.SYS compatibility)
Exec_Find_Res:
	;mov	dx,[bp-20]
	mov	DX,Exec_DMA ; *+*
	;mov	[bp-28],dx
	mov	Exec_DMA_Save,DX
%endif

	; MSDOS 3.3 (& MSDOS 6.0)
	mov	DX,[exec_par_dir]
	push	DX
	mov	CL,4
	shl	DX,CL			; low word of location
	pop	AX
	mov	CL,12
	shr	AX,CL			; high word of location
	mov	CX,AX			; CX <- high

		; Read in the resident image (first, seek to it)
	;mov	bx,[bp-8]
	mov	BX,Exec_FH
	push	DS
	xor	AL,AL
	;invoke	$Lseek			; Seek to resident
	call	_$LSEEK
	pop	DS
	jnc	short Exec_Big_Read

	jmp	Exec_Bomb

Exec_Big_Read:				; Read resident into memory
	;mov	bx,[bp-12]
	mov	BX,Exec_Res_Len_Para
	cmp	BX,1000h		; Too many bytes to read?
	jb	short Exec_Read_OK

	mov	BX,0FE0h		; Max in one chunk FE00 bytes

Exec_Read_OK:
	;sub	[bp-12],bx
	sub	Exec_Res_Len_Para,BX	; We read (soon) this many
	push	BX
	mov	CL,4
	shl	BX,CL			; Get count in bytes from paras
	mov	CX,BX			; Count in correct register
	push	DS
	;mov	ds,[bp-20]
	mov	DS,Exec_DMA		; Set up read buffer

	xor	DX,DX
	push	CX			; Save our count
	call	ExecRead
	pop	CX			; Get old count to verify
	pop	DS
	jc	short Exec_Bad_FileJ

	cmp	CX,AX			; Did we read enough?
	pop	BX			; Get paragraph count back
	jz	short ExecCheckEnd	; and do reloc if no more to read

	; The read did not match the request. If we are off by 512
	; bytes or more then the header lied and we have an error.

	sub	CX,AX
	cmp	CX,512
	jae	short Exec_Bad_FileJ

	; We've read in CX bytes... bump DTA location

ExecCheckEnd:
	;add	[bp-20],bx
	add	Exec_DMA,BX		; Bump dma address
	;test	word [bp-12],0FFFFh
	test	Exec_Res_Len_Para,-1
	jnz	short Exec_Big_Read

	; The image has now been read in. We must perform relocation
	; to the current location.

exec_do_reloc:
	;mov	cx,[bp-10]
	mov	CX,Exec_Rel_Fac
	mov	AX,[exec_SS]		; get initial SS ;rms;NSS
	add	AX,CX			; and relocate him
	mov	[exec_init_SS],AX 	; rms;NSS

	mov	AX,[exec_SP]		; initial SP ;rms;NSS
	mov	[exec_init_SP],AX 	; rms;NSS

	les	AX,[exec_IP]		; rms;NSS
	mov	[exec_init_IP],AX 	; rms;NSS
	mov	AX,ES			; rms;NSS
	add	AX,CX			; relocated...
	mov	[exec_init_CS],AX 	; rms;NSS

	xor	CX,CX
	mov	DX,[exec_rle_table]	; rms;NSS
	;mov	bx,[bp-8]
	mov	BX,Exec_FH
	push	DS
	xor	AX,AX
	;invoke	$Lseek
	call	_$LSEEK
	pop	DS
	jnc	short exec_get_entries

Exec_Bad_FileJ:
	jmp	Exec_Bad_File

exec_get_entries:
	mov	DX,[exec_rle_count]	; Number of entries left ;rms;NSS

exec_read_reloc:
	push	DX
	;mov	dx,OPENBUF
	mov	DX,Exec_Internal_Buffer
	;;mov	cx,388 ; MSDOS 3.3 ; (390>>2)<<2
	;mov	cx,396 ; MSDOS 6.0
	mov	CX,((Exec_Internal_Buffer_Size)/4)*4 ; (397>>2)<<2
	push	DS
	call	ExecRead
	pop	ES
	pop	DX
	jc	short Exec_Bad_FileJ

	;;mov	cx,97 ;  MSDOS 3.3 ; (390>>2)
	;mov	cx,99 ;  MSDOS 6.0
	mov	CX,(Exec_Internal_Buffer_Size)/4 ; (397>>2)
					; Pointer to byte location in header
	;mov	di,OPENBUF
	mov	DI,Exec_Internal_Buffer
	;mov	si,[bp-10]
	mov	SI,Exec_Rel_Fac 	; Relocate a single address

exec_reloc_one:
	or	DX,DX			; Any more entries?
	jz	short Exec_Set_PDBJ

exec_get_addr:
	lds	BX,[ES:DI]		; Get ra/sa of entry
	mov	AX,DS			; Relocate address of item

	; MSDOS 6.0
;;;;;;	add	AX,SI  ; MSDOS 3.3
	;add	ax,[bp-28]
	add	AX,Exec_DMA_Save

	mov	DS,AX
	add	[BX],SI
	add	DI,4
	dec	DX
	loop	exec_reloc_one		; End of internal buffer?

	; We've exhausted a single buffer's worth. Read in the next
	; piece of the relocation table.

	push	ES
	pop	DS
	jmp	short exec_read_reloc

Exec_Set_PDBJ:
	; MSDOS 6.0
	
	; We now determine if this is a buggy exe packed file and if 
	; so we patch in the right code. Note that fixexepatch will
	; point to a ret if dos loads low. The load segment as 
	; determined above will be in exec_dma_save
	
	push	es
	push	ax			; M030
	push	cx			; M030
	;mov	es,[bp-28]
	mov	es,Exec_DMA_Save
	mov	ax,[ss:exec_init_CS]	; M030
	mov	cx,[ss:exec_init_IP]	; M030
	call	word [ss:FixExePatch]
	; 30/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; (MSDOS 5.0 MSDOS.SYS does not contain 'Rational386Patch')
	;call	word [ss:Rational386PatchPtr]
	pop	cx			; M030
	pop	ax			; M030
	pop	es

	jmp	Exec_Set_PDB

Exec_No_Memj:
	jmp	Exec_No_Mem

	; we have a .COM file. First, determine if we are merely
	; loading an overlay.

Exec_Com_File:
	;test	byte [bp-5],2
	test	Exec_Func,exec_func_overlay
	jz	short Exec_Alloc_Com_File
	;lds	si,[bp-4]
	lds	SI,Exec_Blk		; get arg block
	lodsw				; get load address
	;mov	[bp-20],ax
	mov	Exec_DMA,AX
	mov	AX,0FFFFh
	jmp	short Exec_Read_Block	; read it all!

Exec_Chk_Com_Mem:			
	; MSDOS 6.0	     		; M063 - Start
	mov	al,[ss:AllocMethod]	; save current alloc method in ax
	mov	bl,[ss:ALLOCMSAVE]
	mov	[ss:AllocMethod],bl	; restore original allocmethod
	test	bl,HIGH_ONLY ; 40h	; Q: was the HIGH_ONLY bit already set
	jnz	short Exec_No_Memj	; Y: no space in UMBs. Quit
					; N: continue
	
	test	al,HIGH_ONLY		; Q: did we set the HIGH_ONLY bit
	jz	short Exec_No_Memj	; N: no memory 
	
	;mov	ax,[bp-18]
	mov	ax,Exec_Load_Block	; M047: ax = block we just allocated	
	xor	bx,bx			; M047: bx => free arena
	call	ChangeOwner		; M047: free this block
	
	jmp	short Exec_Norm_Com_Alloc
					; M063 - End
	
	; We must allocate the max possible size block (ick!)
	; and set up CS=DS=ES=SS=PDB pointer, IP=100, SP=max
	; size of block.

Exec_Alloc_Com_File:
	; MSDOS 6.0			; M000 -start
	test	byte [ss:AllocMethod],HIGH_FIRST ; 80h
					; Q: is the alloc strat high_first
	jz	short Exec_Norm_Com_Alloc ; N: normal allocate
					; Y: set high_only bit
	or	byte [ss:AllocMethod],HIGH_ONLY ; 40h
					; M000 - end
Exec_Norm_Com_Alloc:			; M000
	; MSDOS 3.3 (& MSDOS 6.0)
	mov	BX,0FFFFh
	;invoke	$Alloc			; largest piece available as error
	call	_$ALLOC
	or	BX,BX
	; MSDOS 6.0
	jz	short Exec_Chk_Com_Mem	; M000
	; MSDOS 3.3
	;jz	short Exec_No_Memj

	;mov	[bp-16],bx
	mov	Exec_Size,BX		; save size of allocation block
	push	BX
	;invoke	$ALLOC			; largest piece available
	call	_$ALLOC
	pop	BX			; get size of block...
	;mov	[bp-18],ax
	mov	Exec_Load_Block,AX

	add	AX,10h			; increment for header
	;mov	[bp-20],ax
	mov	Exec_DMA,AX

	xor	AX,AX			; presume 64K read...
	cmp	BX,1000h		; 64k or more in block?
	jae	short Exec_Read_Com	; yes, read only 64k

	mov	AX,BX			; convert size to bytes
	mov	CL,4
	shl	AX,CL
	; 17/12/2022
	; 30/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	;			(MSDOS 5.0, MSDOS.SYS compatibility)
	; MSDOS 5.0
	;cmp	AX,100h   
	; 02/06/2019 - Retro DOS v4.0
	; MSDOS 6.0
        ; 17/12/2022
	cmp	AX,200h                 ; enough memory for PSP and stack?
	jbe	short Exec_Chk_Com_Mem	; M000: jump if not
	;;jbe	short Exec_No_Memj	; M000: jump if not
	;; Retro DOS v3.0 modification (on MSDOS 6.0 code) -03/08/2018-
	;;jbe	short Exec_Chk_Com_Mem	; M000: jump if not
	;jbe	short Exec_No_Memj	; M000: jump if not

					; M047: size of the block is < 64K
	sub	ax,100h			; M047: reserve 256 bytes for stack

Exec_Read_Com:
	; MSDOS 3.3 (& MSDOS 6.0)
	sub	AX,100h 		; remember size of psp
Exec_Read_Block:
	push	AX			; save number to read
	;mov	bx,[bp-8]
	mov	BX,Exec_FH		; of com file
	xor	CX,CX			; but seek to 0:0
	mov	DX,CX
	xor	AX,AX			; seek relative to beginning
	;invoke	$Lseek			; back to beginning of file
	call	_$LSEEK
	pop	CX			; number to read
	;mov	ds,[bp-20]
	mov	DS,Exec_DMA
	xor	DX,DX
	push	CX
	call	ExecRead
	pop	SI			; get number of bytes to read
	jnc	short OkRead
	jmp	Exec_Bad_File

	; 10/09/2018
OkRead:
	cmp	AX,SI			; did we read them all?
	; MSDOS 6.0
	;jz	short Exec_Chk_Com_Mem	; M00: exactly the wrong number...no 
	; MSDOS 3.3
	;;jz	short Exec_No_Memj	; M00: exactly the wrong number...
	jne	short OkRead2
	jmp	Exec_Chk_Com_Mem
OkRead2:
	; MSDOS 6.0
	mov	bl,[ss:ALLOCMSAVE]	; M063
	mov	[ss:AllocMethod],bl	; M063: restore alloc method

	; MSDOS 3.3 (& MSDOS 6.0)
	;test	byte [bp-5],2
	test	Exec_Func,exec_func_overlay
	jnz	short Exec_Set_PDB	; no starto, chumo!

	;mov	ax,[bp-20]
	mov	AX,Exec_DMA
	sub	AX,10h
	mov	[SS:exec_init_CS],AX
	mov	word [SS:exec_init_IP],100h ; initial IP is 100h

	; SI is AT MOST FF00h. Add FE to account for PSP - word
	; of 0 on stack.

	add	SI,0FEh 		; make room for stack

	; MSDOS 6.0
	cmp	si,0FFFEh		; M047: Q: was there >= 64K available
	je	short Exec_St_Ok	; M047: Y: stack is fine
	add	si,100h			; M047: N: add the xtra 100h for stack

Exec_St_Ok:
	; MSDOS 3.3 (& MSDOS 6.0)
	mov	[SS:exec_init_SP],SI 	; max value for read is also SP!;smr;SS Override
	mov	[SS:exec_init_SS],AX 					;smr;SS Override
	mov	DS,AX
	mov	WORD [SI],0		; 0 for return

	; MSDOS 6.0

	; M068
	;
	; We now determine if this is a Copy Protected App. If so the 
	; A20OFF_COUNT is set to 6. Note that ChkCopyProt will point to a 
	; a ret if DOS is loaded low. Also DS contains the load segment.

	call	word [ss:ChkCopyProt]	

Exec_Set_PDB:
	; MSDOS 3.3 (& MSDOS 6.0)
	;mov	bx,[bp-8]
	mov	BX,Exec_FH		; we are finished with the file.
	call	Exec_Dealloc
	push	BP
	;invoke	$Close			; release the jfn
	call	_$CLOSE
	pop	BP
	call	Exec_Alloc
	;test	byte [bp-5],2
	test	Exec_Func,exec_func_overlay
	jz	short Exec_Build_Header

	; MSDOS 6.0
	call	Scan_Execname
	call	Scan_Special_Entries
;SR;
;The current lie strategy uses the PSP to store the lie version. However,
;device drivers are loaded as overlays and have no PSP. To handle them, we
;use the Sysinit flag provided by the BIOS as part of a structure pointed at
;by BiosDataPtr. If this flag is set, the overlay call has been issued from
;Sysinit and therefore must be a device driver load. We then get the lie 
;version for this driver and put it into the Sysinit PSP. When the driver
;issues the version check, it gets the lie version until the next overlay
;call is issued.

	cmp	byte [ss:DriverLoad],0	;was Sysinit processing done?
	je	short norm_ovl		;yes, no special handling
	push	si
	push	es
	les	si,[ss:BiosDataPtr]	;get ptr to BIOS data block
	 
	; (es:si points to 'SysinitPresent' address/flag in retrodos4.s) 
	cmp	byte [es:si],0		;in Sysinit?
	je	short sysinit_done	;no, Sysinit is finished
	
	mov	es,[ss:CurrentPDB]	;es = current PSP (Sysinit PSP)
	push	word [ss:SPECIAL_VERSION]
	pop	word [es:PDB.Version]	;store lie version in Sysinit PSP
		;;; PDB.VERSION
	jmp	short setver_done
sysinit_done:
	mov	byte [ss:DriverLoad],0	;Sysinit done,special handling off
setver_done:
	pop	es
	pop	si
norm_ovl:
	;leave
	mov	sp,bp		
	pop	bp

	;transfer SYS_RET_OK		; overlay load -> done
	jmp	SYS_RET_OK

Exec_Build_Header:
	;mov	dx,[bp-18]
	mov	DX,Exec_Load_Block
					; assign the space to the process
	;mov	si,1
	mov	SI,ARENA.OWNER		; pointer to owner field
	;mov	ax,[bp-14]
	mov	AX,Exec_Environ 	; get environ pointer
	or	AX,AX
	jz	short No_Owner		; no environment

	dec	AX			; point to header
	mov	DS,AX
	mov	[SI],DX 		; assign ownership
No_Owner:
	;mov	ax,[bp-18]
	;mov	AX,Exec_Load_Block	; get load block pointer
	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	; 17/12/2022
	mov	ax,dx ; 06/06/2019
	;mov	ax,Exec_Load_Block	; get load block pointer
	
	dec	AX
	mov	DS,AX			; point to header
	mov	[SI],DX 		; assign ownership

	; MSDOS 6.0
	push	DS			;AN000;MS. make ES=DS
	pop	ES			;AN000;MS.
	;mov	di,8
	mov	DI,ARENA.NAME		;AN000;MS. ES:DI points to destination
	call	Scan_Execname		;AN007;MS. parse execname
					;	   ds:si->name, cx=name length
	push	CX			;AN007;;MS. save for fake version
	push	SI			;AN007;;MS. save for fake version

MoveName:				;AN000;
	lodsb				;AN000;;MS. get char
	cmp	AL,'.'			;AN000;;MS. is '.' ,may be name.exe
	jz	short Mem_Done		;AN000;;MS. no, move to header
					;AN000;
	stosb				;AN000;;MS. move char
					; MSKK bug fix - limit length copied
	cmp	di,16 ; ARENAHEADERSIZE	; end of memory arena block?
	jae	short Mem_Done		; jump if so
	;
	loop	MoveName		;AN000;;MS. continue
Mem_Done:				;AN000;
	xor	AL,AL			;AN000;;MS. make ASCIIZ
	;cmp	di,16
	cmp	DI,ARENAHEADERSIZE ; 16 ;AN000;MS. if not all filled
	jae	short Fill8		;AN000;MS.
	
	stosb				;AN000;MS.
	
Fill8:					;AN000;
	pop	SI			;AN007;MS. ds:si -> file name
	pop	CX			;AN007;MS.
	
	call	Scan_Special_Entries	;AN007;MS.

	; MSDOS 3.3 (& MSDOS 6.0)
	push	DX
	;mov	si,[bp-16]
	mov	SI,Exec_Size
	add	SI,DX
	;Invoke	$Dup_PDB		; ES is now PDB
	call	_$DUP_PDB
	pop	DX

	;push	word [bp-14]
	push	Exec_Environ
	;pop	WORD [ES:2Ch]
	pop	word [ES:PDB.ENVIRON]

	; MSDOS 6.0			; *** Added for DOS 5.00
					; version number in PSP
 	push	word [ss:SPECIAL_VERSION] ; Set the DOS version number to
	pop	word [ES:PDB.Version]	; to be used for this application
		; PDB.VERSION

	; MSDOS 3.3 (& MSDOS 6.0)	; set up proper command line stuff
	;lds	si,[bp-4]
	lds	SI,Exec_Blk		; get the block
	push	DS			; save its location
	push	SI
	;lds	si,[si+6]
	lds	SI,[SI+EXEC0.5C_FCB]	; get the 5c fcb

	; DS points to user space 5C FCB

	mov	CX,12			; copy drive, name and ext
	push	CX
	mov	DI,5Ch
	mov	BL,[SI]
	rep	movsb

	; DI = 5Ch + 12 = 5Ch + 0Ch = 68h

	xor	AX,AX			; zero extent, etc for CPM
	stosw
	stosw

	; DI = 5Ch + 12 + 4 = 5Ch + 10h = 6Ch

	pop	CX
	pop	SI			; get block
	pop	DS
	push	DS			; save (again)
	push	SI
	;lds	si,[si+0Ah]
	lds	SI,[SI+EXEC0.6C_FCB]	; get 6C FCB

	; DS points to user space 6C FCB

	mov	BH,[SI] 		; do same as above
	rep	movsb
	stosw
	stosw
	pop	SI			; get block (last time)
	pop	DS
	;ld	si,[si+2]
	lds	SI,[SI+EXEC0.COM_LINE]	; command line

	; DS points to user space 80 command line

	or	CL,80h
	mov	DI,CX
	rep	movsb			; Wham!

	; Process BX into default AX (validity of drive specs on args).
	; We no longer care about DS:SI.

	dec	CL			; get 0FFh in CL
	mov	AL,BH
	xor	BH,BH
	;invoke	GetVisDrv
	call	GetVisDrv
	jnc	short Exec_BL

	mov	BH,CL

Exec_BL:
	mov	AL,BL
	xor	BL,BL
	;invoke	GetVisDrv
	call	GetVisDrv
	jnc	short Exec_Set_Return

	mov	BL,CL

Exec_Set_Return:
	;invoke	Get_User_Stack			; get his return address
	call	Get_User_Stack

	;push	word [si+14h]
	push	word [SI+user_env.user_CS]	; suck out the CS and IP
	;push	word [si+12h]
	push	word [SI+user_env.user_IP]
	;push	word [si+14h]
	push	word [SI+user_env.user_CS]	; suck out the CS and IP
	;push	word [si+12h]
	push	word [SI+user_env.user_IP]
	;pop	word [ES:0Ah]
	pop	WORD [ES:PDB.EXIT]
	;pop	word [ES:0Ch]
	pop	WORD [ES:PDB.EXIT+2]

	xor	AX,AX
	mov	DS,AX
					; save them where we can get them
					; later when the child exits.
	;pop	word [88h]
	pop	word [addr_int_terminate] ; 22h*4
	;pop	word [90h]
	pop	word [addr_int_terminate+2] ; (22h*4)+2

	mov	WORD [SS:DMAADD],80h	; SS Override
	mov	DS,[SS:CurrentPDB]	; SS Override
	mov	[SS:DMAADD+2],DS	; SS Override

	;test	byte [bp-5],1
	test	Exec_Func,exec_func_no_execute
	jz	short exec_go

	lds	SI,[SS:exec_init_SP]	; get stack SS Override
	;les	di,[bp-4]
	les	DI,Exec_Blk		; and block for return
	;mov	[es:di+10h],ds
	mov	[ES:DI+EXEC1.SS],DS	; return SS

	dec	SI			; 'push' default AX
	dec	SI
	mov	[SI],BX 		; save default AX reg
	;mov	[es:di+0Eh], si
	mov	[ES:DI+EXEC1.SP],SI	; return 'SP'

	lds	AX,[SS:exec_init_IP]	; SS Override
	;mov	[es:di+14h],ds
	mov	[ES:DI+EXEC1.CS],DS	; initial entry stuff
	;mov	[es:di+12h],ax
	mov	[ES:DI+EXEC1.IP],AX
	
	;leave
	mov	sp,bp
	pop	bp	

	;transfer SYS_RET_OK
	jmp	SYS_RET_OK

exec_go:
	lds	SI,[SS:exec_init_IP]	; get entry point SS Override
	les	DI,[SS:exec_init_SP]	; new stack SS Override
	mov	AX,ES

	; MSDOS 6.0
	cmp	byte [SS:DosHasHMA],0	; Q: is dos in HMA (M021)
	je	short Xfer_To_User	; N: transfer control to user

	push	ds			; Y: control must go to low mem stub
		
	mov	ds,[cs:DosDSeg]		;    where we disable a20 and Xfer 
					;    control to user 
	or	byte [DOS_FLAG],EXECA20OFF ; M068:
					; M004: Set bit to signal int 21
					; ah = 25 & ah= 49. See dossym.inc 
					; under TAG M003 & M009 for 
					; explanation
	mov	[A20OFF_PSP],dx		; M068: set the PSP for which A20 is
					; M068: going to be turned OFF.
	
	mov	ax,ds			; ax = segment of low mem stub
	pop	ds
	
	push	ax			; ret far into the low mem stub
	mov	ax,disa20_xfer
	push	ax
	mov	AX,ES			; restore ax
	retf

Xfer_To_User:
	; DS:SI points to entry point
	; AX:DI points to initial stack
	; DX has PDB pointer
	; BX has initial AX value

	cli
	; 15/08/2018
	mov	BYTE [SS:INDOS],0	; SS Override

	mov	SS,AX			; set up user's stack
	mov	SP,DI			; and SP
	sti

	push	DS			; fake long call to entry
	push	SI
	mov	ES,DX			; set up proper seg registers
	mov	DS,DX
	mov	AX,BX			; set up proper AX

	retf

; 04/08/2018 - Retro DOS v3.0

;----------------------------------------------------------------------------
;
;----------------------------------------------------------------------------

ExecRead:
	CALL	Exec_Dealloc
	;mov	bx,[bp-8]
	MOV	bx,Exec_FH

	PUSH	BP
	call	_$READ
	POP	BP

	;CALL	Exec_Alloc
	;retn
	; 18/12/2022
	;jmp	short Exec_Alloc

; 18/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS) 

;----------------------------------------------------------------------------
;
;----------------------------------------------------------------------------

Exec_Alloc:
	push	BX
	;mov	BX,[CS:CurrentPDB]  ; MSDOS 3.3
	; 20/05/2019 - Retro DOS v4.0
	; MSDOS 6.0
	mov	bx,[SS:CurrentPDB]  ; SS Override
	call	ChangeOwners
	call	LCritMEM
	pop	BX
	retn

;----------------------------------------------------------------------------
;
;----------------------------------------------------------------------------

Exec_Dealloc:
	push	BX
	;mov	bx,0
	sub	BX,BX		; (bx) = ARENA_OWNER_SYSTEM
	call	ECritMEM
	call	ChangeOwners
	pop	BX
	retn

; 18/12/2022
%if 0
;----------------------------------------------------------------------------
;
;----------------------------------------------------------------------------

Exec_Alloc:
	push	BX
	;mov	BX,[CS:CurrentPDB]  ; MSDOS 3.3
	; 20/05/2019 - Retro DOS v4.0
	; MSDOS 6.0
	mov	bx,[SS:CurrentPDB]  ; SS Override
	call	ChangeOwners
	call	LCritMEM
	pop	BX
	retn

%endif

;----------------------------------------------------------------------------
;
;----------------------------------------------------------------------------

ChangeOwners:
	pushf
	push	AX
	;mov	ax,[bp-14]
	mov	AX,Exec_Environ
	call	ChangeOwner
	;mov	ax,[bp-18]
	mov	AX,Exec_Load_Block
	call	ChangeOwner
	pop	AX
	popf
chgown_retn:
	retn

;----------------------------------------------------------------------------
;
;----------------------------------------------------------------------------

ChangeOwner:
	or	AX,AX			; is area allocated?
	jz	short chgown_retn	; no, do nothing
	dec	AX
	push	DS
	mov	DS,AX
	mov	[ARENA.OWNER],BX
	pop	DS
	retn

;----------------------------------------------------------------------------
;
;----------------------------------------------------------------------------

; 20/05/2019 - Retro DOS v4.0

	; MSDOS 6.0
Scan_Execname:
	lds	SI,ExecName		; DS:SI points to name
Scan_Execname1:				; M028
Save_Begin:				;
	mov	CX,SI			; CX= starting addr
Scan0:					;
	lodsb				; get char

	cmp	AL,':'			; is ':' , may be A:name
	jz	short Save_Begin	; yes, save si
	cmp	AL,'\'                  ; is '\', may be A:\name
	jz	short Save_Begin	; yes, save si
	cmp	AL,0			; is end of name
	jnz	short Scan0		; no, continue scanning
	sub	SI,CX			; get name's length
	xchg	SI,CX			; cx= length, si= starting addr

	retn

;----------------------------------------------------------------------------
;
;----------------------------------------------------------------------------

; 20/05/2019 - Retro DOS v4.0

; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:A0EDh (MSDOS 5.0, MSDOS.SYS)

	; MSDOS 6.0

Scan_Special_Entries:

	dec	CX			; cx= name length
;M060	mov	DI,[Special_Entries]	; es:di -> addr of special entries
					;reset to current version
	;mov	word [ss:SPECIAL_VERSION],1406h 
				; (MSDOS 6.21, MSDOS.SYS, DOSCODE:A14Eh)
	;mov	word [ss:SPECIAL_VERSION],5
				; (MSDOS 5.0, MSDOS.SYS, DOSCODE:A0EEh)

				; 5 for Retro DOS 4.0 (01/12/2022, MSDOS 5.0)
	mov	word [ss:SPECIAL_VERSION],(MINOR_VERSION<<8)+MAJOR_VERSION
				; 0005h for Retro DOS v4.1 (MSDOS 5.0)
				; 24/09/2023
				; 1606h for Retro DOS v4.2 (MSDOS 6.22)
;***	call	Reset_Version

;M060	push	SS
;M060	pop	ES

	les	DI,[SS:UU_IFS_DOS_CALL]	;M060; ES:DI --> Table in SETVER.SYS
	mov	AX,ES			;M060; First do a NULL ptr check to
	or	AX,DI			;M060; be sure the table exists
	jz	short End_List		;M060; If ZR then no table

GetEntries:
	mov	AL,[ES:DI]		; end of list
	or	AL,AL
	jz	short End_List		; yes

	mov	[ss:TEMP_VAR2],DI	; save di
	cmp	AL,CL			; same length ?
	jnz	short SkipOne 		; no

	inc	DI			; es:di -> special name
	push	CX			; save length and name addr
	push	SI

; M050 - BEGIN

	push	ax			; save len
sse_next_char:
	lodsb
	call	UCase
	scasb
	jne	short Not_Matched
	loop	sse_next_char
	
;	repz	cmpsb			; same name ?
;	jnz	short Not_Matched	; no

	pop	ax			; take len off the stack

; M050 - END

	mov	AX,[ES:DI]		; get special version
	mov	[ss:SPECIAL_VERSION],AX	; save it

;***	mov	AL,[ES:DI+2]		; get fake count
;***	mov	[ss:FAKE_COUNT],AL 	; save it

	pop	SI
	pop	CX
	; 18/12/2022
	;jmp	SHORT End_List

	; 18/12/2022
End_List:
	retn

Not_Matched:
	pop	ax			; get len from stack ; M050
	pop	SI			; restore si,cx
	pop	CX

SkipOne:
	mov	DI,[ss:TEMP_VAR2]	; restore old di use SS Override
	xor	AH,AH			; position to next entry
	add	DI,AX

	add	DI,3			; DI -> next entry length
;***	add	DI,4			; DI -> next entry length

	jmp	short GetEntries

	; 18/12/2022
;End_List:
	;retn

; 04/08/2018 - Retro DOS v3.0
; IBMDOS.COm (MSDOS 3.3, 1987) - Offset 633Dh

;----------------------------------------------------------------------------
;SUBTTL Terminate and stay resident handler
;
; Input:    DX is  an  offset  from  CurrentPDB  at which to
;	    truncate the current block.
;
; output:   The current block is truncated (expanded) to be [DX+15]/16
;	    paragraphs long.  An exit is simulated via resetting CurrentPDB
;	    and restoring the vectors.
;
;----------------------------------------------------------------------------

	; 20/05/2019 - Retro DOS v4.0
	; DOSCODE:A19Bh (MSDOS 6.21, MSDOS.SYS)

	; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS5.0 MSDOS.SYS)
	; DOSCODE:A13Bh (MSDOS 5.0, MSDOS.SYS)

_$KEEP_PROCESS:
	push	AX			; keep exit code around
	;mov	byte [SS:EXIT_TYPE],3
	mov	BYTE [SS:EXIT_TYPE],EXIT_KEEP_PROCESS
	mov	ES,[SS:CurrentPDB]
	cmp	DX,6h			; keep enough space around for system
	jae	short Keep_Shrink	; info

	mov	DX,6h

Keep_Shrink:
	mov	BX,DX
	push	BX
	push	ES
	call	_$SETBLOCK		; ignore return codes.
	pop	DS
	pop	BX
	jc	short Keep_Done		; failed on modification

	mov	AX,DS
	add	AX,BX
	;mov	[2],ax
	mov	[PDB.BLOCK_LEN],AX	;PBUGBUG

Keep_Done:
	pop	AX
	jmp	SHORT exit_inner	; and let abort take care of the rest

;----------------------------------------------------------------------------
;
;----------------------------------------------------------------------------

STAY_RESIDENT:
	;mov	ax,3100h
	mov	AX,(KEEP_PROCESS<<8)+0 ; Lower part is return code;PBUGBUG
	add	DX,15
	rcr	DX,1
	mov	CL,3
	shr	DX,CL

	jmp	COMMAND

;----------------------------------------------------------------------------
;SUBTTL $EXIT - return to parent process
;   Assembler usage:
;	    MOV     AL, code
;	    MOV     AH, Exit
;	    INT     int_command
;   Error return:
;	    None.
;
;----------------------------------------------------------------------------

	; 20/05/2019 - Retro DOS v4.0
	; DOSCODE:A1D3h (MSDOS 6.21, MSDOS.SYS)

	; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS5.0 MSDOS.SYS)
	; DOSCODE:A173h (MSDOS 5.0, MSDOS.SYS)
_$EXIT:
	; 04/08/2018 - Retro DOS v3.0
	; IBMDOSDOS.COM (MSDOS 3.3, 1987) - Offset 6375h
	xor	AH,AH
	xchg	AH,[SS:DidCTRLC]
	or	AH,AH
	;mov	BYTE [SS:EXIT_TYPE],0
	mov	BYTE [SS:EXIT_TYPE],EXIT_TERMINATE
	jz	short exit_inner
	;mov	BYTE [SS:EXIT_TYPE],1
	mov	BYTE [SS:EXIT_TYPE],EXIT_CTRL_C

	;entry	Exit_inner
exit_inner:
	call	Get_User_Stack		;PBUGBUG

	push	word [ss:CurrentPDB]
	;pop	word [si+14h]
	pop	word [SI+user_env.user_CS] ;PBUGBUG
	jmp	short abort_inner

;BREAK <$ABORT -- Terminate a process>
;----------------------------------------------------------------------------
; Inputs:
;	user_CS:00 must point to valid program header block
; Function:
;	Restore terminate and Cntrl-C addresses, flush buffers and transfer
;	to the terminate address
; Returns:
;	TO THE TERMINATE ADDRESS
;----------------------------------------------------------------------------

_$ABORT:
	xor	AL,AL
	;mov	byte [SS:EXIT_TYPE],0
	;mov	byte [SS:EXIT_TYPE],AL ; = 0
	mov	byte [SS:EXIT_TYPE],EXIT_ABORT

	; abort_inner must have AL set as the exit code! The exit type
	; is retrieved from exit_type. Also, the PDB at user_CS needs
	; to be correct as the one that is terminating.

abort_inner:
	mov	AH,[SS:EXIT_TYPE]
	mov	[SS:exit_code],AX
	call	Get_User_Stack

	;mov	ds,[si+14h]
	mov	DS,[SI+user_env.user_CS] ; set up old interrupts ;PBUGBUG
	xor	AX,AX
	mov	ES,AX
	;mov	si,10
	mov	SI,SAVEXIT
	;mov	di,88h
	mov	DI,addr_int_terminate
	movsw
	movsw
	movsw
	movsw
	movsw
	movsw
	jmp	reset_environment

;----------------------------------------------------------------------------
;
; fixexepatch will point to this is DOS loads low. 
;
;----------------------------------------------------------------------------
; MSDOS 6.0

; 29/04/2019 - Retro DOS v4.0
; DOSCODE:A221h (MSDOS 6.21, MSDOS.SYS)

; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS5.0 MSDOS.SYS)
; DOSCODE:A1C1h (MSDOS 5.0, MSDOS.SYS)

RetExePatch: ; proc near
	
	retn

;============================================================================
; ALLOC.ASM, MSDOS 6.0, 1991
;============================================================================
; 04/08/2018 - Retro DOS v3.0
; 14/05/2019 - Retro DOS v4.0

;	TITLE ALLOC.ASM - memory arena manager	NAME Alloc

;**
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;
;	Memory related system calls and low level routines for MSDOS 2.X.
;	I/O specs are defined in DISPATCH.
;
;	$ALLOC
;	$SETBLOCK
;	$DEALLOC
;	$AllocOper
;	arena_free_process
;	arena_next
;	check_signature
;	Coalesce
;
;	Modification history:
;
;	    Created: ARR 30 March 1983
;
;	    Revision: M000 - added support for allocing UMBs. 7/9/90
;		      M003 - added support for link/unlink UMBs from
;			     DOS arena chain. 7/18/90
;		      M009 - Added error returns invalid function and 
;			     arena trashed in set link state call.
;		      M010 - Release UMB arenas allocated to current PDB
;			     if UMB_HEAD is initialized.
;
;		      M016 - MACE utilities mkeyrate.com version 1.0 
;			     support. Please see under M009 in 
;			     ..\inc\dossym.inc. 8/31/90.
;
;		      M061 - In GetLastArena, if linking in UMBs check to make
;			     sure that umb_head arena is valid and also make
;			     sure that the previous arena is pointing to 
;			     umb_head.
;
;		      M064 - allow HIGH_ONLY bit to be set by a call to 
;			     set allloc strategy.
;			     use STRAT_MASK to mask out bits 6 & 7 of 
;			     bx in AllocSetStrat.
;
;		      M068 - use a count value (A20OFF_COUNT) rather than
;			     a bit to indicate to dos dispatcher to turn
;			     a20 off before iret. See M016.
;

;	BREAK	<memory allocation utility routines>


; 15/04/2018 - Retro DOS v2.0
;----------------------------------------------------------------------------
; xenix memory calls for MSDOS
;
; CAUTION: The following routines rely on the fact that arena_signature and
; arena_owner_system are all equal to zero and are contained in DI.
;
;INCLUDE DOSSEG.ASM

;CODE	SEGMENT BYTE PUBLIC  'CODE'
;       ASSUME  SS:DOSGROUP,CS:DOSGROUP

;.xlist
;.xcref
;INCLUDE DOSSYM.ASM
;INCLUDE DEVSYM.ASM
;.cref
;.list

;TITLE ALLOC.ASM - memory arena manager
;NAME Alloc

;SUBTTL memory allocation utility routines
;PAGE
;
; arena data
;
;       i_need  arena_head,WORD         ; seg address of start of arena
;       i_need  CurrentPDB,WORD         ; current process data block addr
;       i_need  FirstArena,WORD         ; first free block found
;       i_need  BestArena,WORD          ; best free block found
;       i_need  LastArena,WORD          ; last free block found
;       i_need  AllocMethod,BYTE        ; how to alloc first(best)last

;**	Arena_Free_Process
;----------------------------------------------------------------------------
;	Free all arena blocks allocated to a prOcess
;
;	ENTRY	(bx) = PID of process
;	EXIT	none
;	USES	????? BUGBUG
;----------------------------------------------------------------------------

	; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS5.0 MSDOS.SYS)
	; DOSCODE:A1C2h (MSDOS 5.0, MSDOS.SYS)

arena_free_process:
	; 14/05/2019 - Retro DOS v4.0
	; 04/08/2018 - Retro DOS v3.0
        MOV	AX,[SS:arena_head]
arena_free_process_start:
	MOV     DI,ARENA.SIGNATURE ; 0
	;MOV	AX,[SS:arena_head] ; 15/04/2018  
        CALL	check_signature         ; ES <- AX, check for valid block

arena_free_process_loop:
        ;retc
        JC	SHORT AFP_RETN	; Retro DOS v2.0 - 05/03/2018
	PUSH    ES
        POP     DS
	;cmp	[1],bx 
        CMP     [ARENA.OWNER],BX	; is block owned by pid?
        JNZ     SHORT arena_free_next	; no, skip to next
	;mov	[1],di
        MOV     [ARENA.OWNER],DI	; yes... free him

arena_free_next:
	;cmp	byte [di],5Ah ;'Z'
        CMP     BYTE [DI],arena_signature_end
                                        ; end of road, Jack?
        ;retz				; never come back no more
	;JZ	SHORT AFP_RETN  ; MSDOS 3.3 (& MSDOS 2.11)
	; 14/05/2019
	; MSDOS 6.0
	jz	short arena_chk_umbs
        
	CALL    arena_next              ; next item in ES/AX carry set if trash
        JMP     SHORT arena_free_process_loop

	; MSDOS 6.0
arena_chk_umbs:				; M010 - Start
	; 20/05/2019
	mov	ax,[ss:UMB_HEAD]	; ax = umb_head
	cmp	ax,0FFFFh		; Q: is umb_head initialized
	je	short ret_label		; N: we're done
	
	mov	di,ds			; di = last arena
	cmp	di,ax			; Q: is last arena above umb_head
	jae	short ret_label		; Y: we've scanned umbs also. done.
	jmp	short arena_free_process_start
					; M010 - End
;AFP_RETN:
;	RETN

;	BREAK	<Arena Helper Routines>

;**	Arena_Next - Find Next item in Arena
;----------------------------------------------------------------------------
;	ENTRY	DS - pointer to block head
;		(di) = 0
;	EXIT	AX,ES - pointers to next head
;		'C' set iff arena damaged
;----------------------------------------------------------------------------

arena_next:
        MOV     AX,DS                   ; AX <- current block
        ADD     AX,[ARENA.SIZE]		; AX <- AX + current block length
        INC     AX                      ; remember that header!

;       fall into check_signature and return
;
;       CALL    check_signature         ; ES <- AX, carry set if error
;       RETN

;**	Check_Signature - Check Memory Block Signature
;----------------------------------------------------------------------------
;	ENTRY	(AX) = address of block header
;		(di) = 0
;	EXIT	 ES = AX
;		'C' clear if signature good
;		'C' set if signature bad
;	USES	ES, Flags
;----------------------------------------------------------------------------

check_signature:        

	MOV     ES,AX                   ; ES <- AX
	;cmp	byte [es:di],4Dh ; 'M'
        CMP     BYTE [ES:DI],arena_signature_normal
                                        ; IF next signature = not_end THEN
        JZ      SHORT check_signature_ok ;   GOTO ok
	;cmp 	byte [es:di],5Ah ; 'Z'
        CMP     BYTE [ES:DI],arena_signature_end
                                        ; IF next signature = end then
        JZ      SHORT check_signature_ok ;   GOTO ok
        STC                             ; set error
ret_label: ; MSDOS 6.0
AFP_RETN:
 	; Retro DOS v2.0 - 05/03/2018
check_signature_ok:
COALESCE_RETN:
	RETN

;**	Coalesce - Combine free blocks ahead with current block
;----------------------------------------------------------------------------
;	Coalesce adds the block following the argument to the argument block,
;	iff it's free.  Coalesce is usually used to join free blocks, but
;	some callers (such as $setblock) use it to join a free block to it's
;	preceeding allocated block.
;
;	ENTRY	(ds) = pointer to the head of a free block
;		(di) = 0
;	EXIT	'C' clear if OK
;		  (ds) unchanged, this block updated
;		  (ax) = address of next block, IFF not at end
;		'C' set if arena trashed
;	USES	(cx)
;----------------------------------------------------------------------------
        
Coalesce:
	;cmp	byte [di],5Ah ; 'Z'
	CMP     BYTE [DI],arena_signature_end
                                        ; IF current signature = END THEN
        ;retz				;   GOTO ok
        jz	short COALESCE_RETN
	CALL    arena_next              ; ES, AX <- next block, Carry set if error
        ;retc				; IF no error THEN GOTO check
	jc	short COALESCE_RETN

coalesce_check:
	;cmp	[es:1],di
        CMP     [ES:ARENA.OWNER],DI
        ;retnz				; IF next block isnt free THEN return
        JNZ	SHORT COALESCE_RETN
	;mov	cx,[ES:3]
	MOV     CX,[ES:ARENA.SIZE]	; CX <- next block size
        INC     CX                      ; CX <- CX + 1 (for header size)
        ;ADD	[3],CX
	ADD     [ARENA.SIZE],CX		; current size <- current size + CX
        MOV     CL,[ES:DI]              ; move up signature
        MOV     [DI],CL
        JMP     SHORT Coalesce		; try again

; 04/08/2018 - Retro DOS v3.0
; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 641Fh

;	BREAK  <$Alloc - allocate space in memory>

; MSDOS 6.0
;----------------------------------------------------------------------------
;**	$Alloc - Allocate Memory Space
;
;	$Alloc services the INT21 that allocates memory space to a program.
;	Alloc returns a pointer to a free block of memory that
;	has the requested size in paragraphs.
;
;	If the allocation strategy is HIGH_FIRST or HIGH_ONLY memory is 
;	scanned from umb_head if not from arena_head. If the strategy is
; 	HIGH_FIRST the scan is continued from arena_head if a block of 
;	appropriate size is not found in the UMBs. If the strategy is 
;	HIGH_FIRST+HIGH_ONLY only the UMBs are scanned for memory.
;
;	In either case if bit 0 of UmbFlag is not initialized then the scan
;	starts from arena_head.
;
;	Assembler usage:
;           MOV     BX,size
;           MOV     AH,Alloc
;           INT     21h
;
;	BUGBUG - a lot can be done to improve performance. We can set marks
;	so that we start searching the arena at it's first non-trivial free
;	block, we can peephole the code, etc. (We can move some subr calls
;	inline, etc.) I assume that this is called rarely and that the arena
;	doesn't have too many memory objects in it beyond the first free one.
;	verify that this is true; if so, this can stay as is
;
;	ENTRY	(bx) = requested size, in bytes
;		(DS) = (ES) = DOSGROUP
;	EXIT	'C' clear if memory allocated
;		  (ax:0) = address of requested memory
;		'C' set if request failed
;		  (AX) = error_not_enough_memory
;		    (bx) = max size we could have allocated
;		  (ax) = error_arena_trashed
;	USES	All
;----------------------------------------------------------------------------

; MSDOS 2.11 (& MSDOS 3.3)
;----------------------------------------------------------------------------
;SUBTTL $Alloc - allocate space in memory
;
;   Assembler usage:
;           MOV     BX,size
;           MOV     AH,Alloc
;           INT     21h
;         AX:0 is pointer to allocated memory
;         BX is max size if not enough memory
;
;   Description:
;           Alloc returns  a  pointer  to  a  free  block of
;       memory that has the requested  size  in  paragraphs.
;
;   Error return:
;           AX = error_not_enough_memory
;              = error_arena_trashed
;----------------------------------------------------------------------------

; DOSCODE:A28Eh (MSDOS 6.21, MSDOS.SYS)

; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS5.0 MSDOS.SYS)
; DOSCODE:A22Eh (MSDOS 5.0, MSDOS.SYS)

_$ALLOC:
	; 25/05/2019 (Procedure has been checked and confirmed)
	; 14/05/2019 - Retro DOS v4.0
	; 04/08/2018 - Retro DOS v3.0
	;EnterCrit critMem
	call	ECritMEM ; MSDOS 3.3 & MSDOS 6.0

; 17/12/2022
; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
;%if 0
	; 14/05/2019
	push	ss
	pop	ds

	; MSDOS 6.0
	;mov	ax,[ss:arena_head]
	;mov	[ss:START_ARENA],ax	; assume LOW_FIRST

	mov	ax,[arena_head]
	mov	[START_ARENA],ax			
	
	;test	byte [ss:AllocMethod],HIGH_FIRST+HIGH_ONLY
	test	byte [AllocMethod],HIGH_FIRST+HIGH_ONLY
					; Q: should we start scanning from 
					;    UMB's
	jz	short norm_alloc	; N: scan from arena_head
		
	;;cmp	word [ss:UMB_HEAD],-1	; Q: Has umb_head been initialized
	;cmp	word [UMB_HEAD],-1
	;je	short norm_alloc	; N: scan from arena_head

	;test	byte [ss:UMBFLAG],LINKSTATE ; Q: are umb's linked
	test	byte [UMBFLAG],LINKSTATE ; 1
	jz	short norm_alloc	; N: scan from arena_head
	
	;mov	ax,[ss:UMB_HEAD]
	;mov	[ss:START_ARENA],ax	; start_arena = umb_head
	mov	ax,[UMB_HEAD]
	mov	[START_ARENA],ax
					; M000 - end
norm_alloc:
        XOR     AX,AX
        MOV     DI,AX
	; 15/03/2018
        ;MOV	[SS:FirstArena],AX	; init the options
        ;MOV	[SS:BestArena],AX
        ;MOV	[SS:LastArena],AX
	; 14/05/2019
	MOV	[FirstArena],AX		; init the options
        MOV	[BestArena],AX
        MOV	[LastArena],AX
        PUSH    AX                      ; alloc_max <- 0
	; 04/08/2018
start_scan:
	;MOV	AX,[SS:arena_head]	; AX <- beginning of arena
	;MOV	AX,[arena_head]

	; 14/05/2019	
	; MSDOS 6.0
	;mov	ax,[SS:START_ARENA]	; M000: AX <- beginning of arena
	mov	ax,[START_ARENA]

	; 27/09/2023 (BugFix) (*) 
	; ( jump from 'alloc_chk' (ds<>ss, ax = [SS:START_ARENA]))
start_scan_x:

	CALL    check_signature         ; ES <- AX, carry set if error
        JC      SHORT alloc_err		; IF error THEN GOTO err

;%endif

; 17/12/2022
%if 0
	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)

	; MSDOS 6.0
	mov	ax,[ss:arena_head]
	mov	[ss:START_ARENA],ax	; assume LOW_FIRST

	test	byte [ss:AllocMethod],HIGH_FIRST+HIGH_ONLY
					; Q: should we start scanning from 
					;    UMB's
	jz	short norm_alloc	; N: scan from arena_head
		
	;cmp	word [ss:UMB_HEAD],-1	; Q: Has umb_head been initialized
	;je	short norm_alloc	; N: scan from arena_head

	test	byte [ss:UMBFLAG],LINKSTATE ; Q: are umb's linked
	jz	short norm_alloc	; N: scan from arena_head
	
	mov	ax,[ss:UMB_HEAD]
	mov	[ss:START_ARENA],ax	; start_arena = umb_head
					; M000 - end
norm_alloc:
        XOR     AX,AX
        MOV     DI,AX
	; 15/03/2018
	MOV	[SS:FirstArena],AX	; init the options
	MOV	[SS:BestArena],AX
	MOV	[SS:LastArena],AX
        PUSH    AX                      ; alloc_max <- 0
	; 04/08/2018
start_scan:
	;MOV	AX,[SS:arena_head]	; AX <- beginning of arena
	; 14/05/2019	
	; MSDOS 6.0
	mov	ax,[SS:START_ARENA]	; M000: AX <- beginning of arena
	CALL    check_signature         ; ES <- AX, carry set if error
        JC      SHORT alloc_err		; IF error THEN GOTO err
%endif

alloc_scan:
        PUSH    ES
        POP     DS                      ; DS <- ES
        CMP     [ARENA.OWNER],DI ; 0
        JZ      SHORT alloc_free	; IF current block is free THEN examine

alloc_next:
	; MSDOS 6.0			; M000 - start 
	test	byte [ss:UMBFLAG],LINKSTATE ; Q: are umb's linked
	jz	short norm_strat	; N: see if we reached last arena
	
	test	byte [ss:AllocMethod],HIGH_FIRST
					; Q: is alloc strategy high_first
	jz	short norm_strat	; N: see if we reached last arena
	mov	ax,[ss:START_ARENA]
	cmp	ax,[ss:arena_head]	; Q: did we start scan from 
					;    arena_head
	jne	short norm_strat	; N: see if we reached last arena
	mov	ax,ds			; ax = current block
	cmp	ax,[ss:UMB_HEAD]	; Q: check against umb_head 
	jmp	short alloc_chk_end

norm_strat:
	;cmp	byte [di],5Ah ; 'Z'
        CMP     BYTE [DI],arena_signature_end
                                        ; IF current block is last THEN
alloc_chk_end:
        JZ      SHORT alloc_end		;   GOTO end
        CALL    arena_next              ; AX, ES <- next block, Carry set if error
        JNC     SHORT alloc_scan	; IF no error THEN GOTO scan

alloc_err:
        POP     AX

alloc_trashed:
	;LeaveCrit critMem
	call    LCritMEM ; MSDOS 3.3 & MSDOS 6.0	
        ;error	error_arena_trashed
	;mov	al,7
	MOV	AL,error_arena_trashed
alloc_errj:
	JMP	SYS_RET_ERR

alloc_end:
	; 18/05/2019
        CMP	WORD [SS:FirstArena],0
	jz	short alloc_chk 
	jmp	alloc_do_split

alloc_chk:
	; MSDOS 6.0
	mov	ax,[ss:arena_head]
	cmp	ax,[ss:START_ARENA]	; Q: started scanning from arena_head
	je	short alloc_fail	; Y: not enough memory
					; N:
					; Q: is the alloc strat HIGH_ONLY
	test 	byte [ss:AllocMethod],HIGH_ONLY
	jnz	short alloc_fail	; Y: return size of largest UMB
	
	mov	[ss:START_ARENA],ax	; N: start scanning from arena_head
	; 27/09/2023 (*)
	jmp	short start_scan_x ; (*) ; (BugFix)
	;jmp	short start_scan
					; M000 - end

alloc_fail:
        ;invoke Get_User_Stack
        CALL	Get_User_Stack
	POP     BX
        ;MOV	[SI].user_BX,BX
	;MOV	[SI+2],BX
	mov	[SI+user_env.user_BX],bx
	;LeaveCrit critMem
	call    LCritMEM ; MSDOS 3.3 & MSDOS 6.0
	;error	error_not_enough_memory
	;mov	al,8
	MOV	AL,error_not_enough_memory
	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	jmp	short alloc_errj
	;JMP	SYS_RET_ERR

alloc_free:
        CALL    Coalesce		; add following free block to current
        JC	SHORT alloc_err		; IF error THEN GOTO err
        MOV     CX,[ARENA.SIZE]
        POP     DX                      ; check for max found size
        CMP     CX,DX
        JNA     SHORT alloc_test
        MOV     DX,CX

alloc_test:
        PUSH    DX
        CMP     BX,CX                   ; IF BX > size of current block THEN
	JA      SHORT alloc_next	;   GOTO next

	; 15/03/2018
        CMP     WORD [SS:FirstArena],0
	JNZ	SHORT alloc_best
        MOV     [SS:FirstArena],DS	; save first one found	
alloc_best:
        CMP     WORD [SS:BestArena],0
        JZ      SHORT alloc_make_best	; initial best
        PUSH	ES
        MOV     ES,[SS:BestArena]
        CMP     [ES:ARENA.SIZE],CX	; is size of best larger than found?
        POP	ES
        JBE     SHORT alloc_last
alloc_make_best:
        MOV     [SS:BestArena],DS	; assign best
alloc_last:
        MOV     [SS:LastArena],DS 	; assign last
        JMP     alloc_next
;
; split the block high
;
alloc_do_split_high:
        MOV     DS,[SS:LastArena]
        MOV     CX,[ARENA.SIZE]
        SUB     CX,BX
        MOV     DX,DS
        JE      SHORT alloc_set_owner	; sizes are equal, no split
        ADD     DX,CX                   ; point to next block
        MOV     ES,DX                   ; no decrement!
        DEC     CX
        XCHG    BX,CX                   ; bx has size of lower block
        JMP     SHORT alloc_set_sizes	; cx has upper (requested) size
;
; we have scanned memory and have found all appropriate blocks
; check for the type of allocation desired; first and best are identical
; last must be split high
;
alloc_do_split:

; 17/12/2022
; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
;%if 0
	; 14/05/2019
	; MSDOS 6.0			; M000 - start
	;xor	cx,cx
	mov	cl,[ss:AllocMethod]
	;and	cx,STRAT_MASK ; 0FF3Fh	; mask off bit 7
	and	cl,3Fh
	;cmp	cx,BEST_FIT ; 1		; Q; is the alloc strategy best_fit
	cmp	cl,BEST_FIT
	ja	short alloc_do_split_high
;%endif

	; 17/12/2022
	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	; MSDOS 6.0 & MSDOS 5.0
	;xor	cx,cx
	;mov	cl,[ss:AllocMethod]
	;and	cx,STRAT_MASK ; 0FF3Fh	; mask off bit 7
	;cmp	cx,BEST_FIT ; 1		; Q; is the alloc strategy best_fit
	;ja	short alloc_do_split_high

	; 15/03/2018
        ;;CMP	BYTE [SS:AllocMethod], 1
	; 04/08/2018
	;CMP	BYTE [SS:AllocMethod],BEST_FIT
        ;JA	SHORT alloc_do_split_high
        
	MOV     DS,[SS:FirstArena]        
	JB      SHORT alloc_get_size
	MOV     DS,[SS:BestArena]

alloc_get_size:
        MOV     CX,[ARENA.SIZE]
        SUB     CX,BX                   ; get room left over
        MOV     AX,DS
        MOV     DX,AX                   ; save for owner setting
        JE      SHORT alloc_set_owner	; IF BX = size THEN (don't split)
        ADD     AX,BX
        INC     AX                      ; remember the header
        MOV     ES,AX                   ; ES <- DS + BX (new header location)
        DEC     CX                      ; CX <- size of split block
alloc_set_sizes:
        MOV     [ARENA.SIZE],BX		; current size <- BX
        MOV     [ES:ARENA.SIZE],CX      ; split size <- CX
	;mov	bl,4Dh ; 'M'
        MOV     BL,arena_signature_normal
        XCHG    BL,[DI]			; current signature <- 4D
        MOV     [ES:DI],BL		; new block sig <- old block sig
        MOV     [ES:ARENA.OWNER],DI

alloc_set_owner:
        MOV     DS,DX
        MOV     AX,[SS:CurrentPDB] ; 15/03/2018
        MOV     [ARENA.OWNER],AX
        MOV     AX,DS
        INC     AX
        POP     BX
	;LeaveCrit critMem
	call    LCritMEM ; MSDOS 3.3 & MSDOS 6.0
	
	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
alloc_ok:
        ;transfer SYS_RET_OK
	JMP	SYS_RET_OK

;	BREAK $SETBLOCK - change size of an allocated block (if possible)

; MSDOS 6.0
;----------------------------------------------------------------------------
;**	$SETBLOCK - Change size of an Allocated Block
;
;	Setblock changes the size of an allocated block. First, we coalesce
;	any following free space onto this block; then we try to trim the
;	block down to the size requested.
;
;	Note that if the guy wants to grow the block but that growth fails,
;	we still go ahead and coalesce any trailing free blocks onto it.
;	Thus the maximum-size-possible value that we return has already
;	been allocated! This is a bug, dare we fix it? BUGBUG
;
;	NOTE - $SETBLOCK is in bed with $ALLOC and jumps into $ALLOC to
;		finish it's work. For this reason we build the allocsf
;		structure on the frame, to make us compatible with $ALLOCs
;		code.
;
;	ENTRY	(es) = segment of old block
;		(bx) = newsize
;		(ah) = SETBLOCK
;
;	EXIT	'C' clear if OK
;		'C' set if error
;		  (ax) = error_invalid_block
;		       = error_arena_trashed
;		       = error_not_enough_memory
;		       = error_invalid_function
;		  (bx) = maximum size possible, iff (ax) = error_not_enough_memory
;	USES	???? BUGBUG
;----------------------------------------------------------------------------

; MSDOS 2.11 (& MSDOS 3.3)
;----------------------------------------------------------------------------
;SUBTTL $SETBLOCK - change size of an allocated block (if possible)
;
;   Assembler usage:
;           MOV     ES,block
;           MOV     BX,newsize
;           MOV     AH,setblock
;           INT     21h
;         if setblock fails for growing, BX will have the maximum
;         size possible
;   Error return:
;           AX = error_invalid_block
;              = error_arena_trashed
;              = error_not_enough_memory
;              = error_invalid_function
;----------------------------------------------------------------------------

_$SETBLOCK:        
	; 04/08/2018 - Retro DOS v3.0
	;EnterCrit   critMem
	call	ECritMEM ; MSDOS 3.3 & MSDOS 6.0

	MOV     DI,ARENA.SIGNATURE
        MOV     AX,ES
        DEC     AX
        CALL    check_signature
        JNC     SHORT setblock_grab

setblock_bad:
        JMP     alloc_trashed

setblock_grab:
        MOV     DS,AX
        CALL    Coalesce
        JC      SHORT setblock_bad
        MOV     CX,[ARENA.SIZE]
        PUSH    CX
        CMP     BX,CX
        JBE     SHORT alloc_get_size
        JMP     alloc_fail

;	BREAK $DEALLOC - free previously allocated piece of memory

; MSDOS 6.0
;----------------------------------------------------------------------------
;**	$DEALLOC - Free Heap Memory
;
;	ENTRY	(es) = address of item
;
;	EXIT	'C' clear of OK
;		'C' set if error
;		  (AX) = error_invalid_block
;	USES	???? BUGBUG

; MSDOS 2.11 (& MSDOS 3.3)
;----------------------------------------------------------------------------
;SUBTTL $DEALLOC - free previously allocated piece of memory
;
;   Assembler usage:
;           MOV     ES,block
;           MOV     AH,dealloc
;           INT     21h
;
;   Error return:
;           AX = error_invalid_block
;              = error_arena_trashed
;---------------------------------------------------------------------------- 

	; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
_$DEALLOC:
	; 14/05/2019 - Retro DOS v4.0    
	; 04/08/2018 - Retro DOS v3.0
	;EnterCrit   critMem
	call	ECritMEM ; MSDOS 3.3 & MSDOS 6.0

	; MSDOS 6.0			; M016, M068 - Start
	test	byte [ss:DOS_FLAG],EXECA20OFF
					; Q: was the previous call an int 21
					;    exec call
	jz	short deallocate	; N: continue
	cmp	byte [ss:A20OFF_COUNT], 0 ; Q: is count 0
	jne	short deallocate	; N: continue
	;mov	byte [ss:A20OFF_COUNT], 1 ; Y: set count to 1
	; 25/09/2023
	inc	byte [ss:A20OFF_COUNT]
deallocate:				; M016, M068 - End
	MOV     DI,ARENA.SIGNATURE ; = 0
        MOV     AX,ES
        DEC     AX
        CALL    check_signature
        JC      SHORT dealloc_err
        MOV     [ES:ARENA.OWNER],DI
	;LeaveCrit critMem
	call    LCritMEM ; MSDOS 3.3 & MSDOS 6.0
	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
        ;transfer SYS_RET_OK
dealloc_ok:
	jmp	short alloc_ok
	;JMP	SYS_RET_OK

dealloc_err:
	;LeaveCrit critMem
	call    LCritMEM ; MSDOS 3.3 & MSDOS 6.0
        ;error	error_invalid_block
	;mov	al,9
	MOV	AL,error_invalid_block
	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
dealloc_errj:
AllocOperErrj:	; 17/12/2022
	JMP	SYS_RET_ERR

;	BREAK $AllocOper - get/set allocation mechanism

; MSDOS 6.0
;----------------------------------------------------------------------------
;**	$AllocOper - Get/Set Allocation Mechanism
;
;	Assembler usage:
;           MOV     AH,AllocOper
;           MOV     BX,method
;           MOV     AL,func
;           INT     21h
;
;	ENTRY	
;		(al) = 0
;		  Get allocation Strategy in (ax)
;
;		(al) = 1, (bx) = method = zw0000xy
;		  Set allocation strategy.
;		   w  = 1  => HIGH_ONLY
;		   z  = 1  => HIGH_FIRST
;		   xy = 00 => FIRST_FIT
;		      = 01 => BEST_FIT
;		      = 10 => LAST_FIT
;
;		(al) = 2
;		  Get UMB link state in (al)
;
;		(al) = 3
;		  Set UMB link state
;		   (bx) = 0 => Unlink UMBs
;		   (bx) = 1 => Link UMBs
;
;
;	EXIT	'C' clear if OK
;
;		 if (al) = 0
;		  (ax) = existing method
;		 if (al) = 1
;		  Sets allocation strategy
;		 if (al) = 2
;		  (al) = 0 => UMBs not linked
;		  (al) = 1 => UMBs linked in
;		 if (al) = 3
;		  Links/Unlinks the UMBs into DOS chain
;
;		'C' set if error
;		  AX = error_invalid_function
;
;	Rev. M000 - added support for HIGH_FIRST in (al) = 1. 7/9/90
; 	Rev. M003 - added functions (al) = 2 and (al) = 3. 7/18/90
;	Rev. M009 - (al) = 3 will return 'invalid function' in ax if
;		    umbhead has'nt been initialized by sysinit and 'trashed
;		    arena' if an arena sig is damaged.
;----------------------------------------------------------------------------

; MSDOS 2.11 (& MSDOS 3.3)
;----------------------------------------------------------------------------
;SUBTTL $AllocOper - get/set allocation mechanism
;
;   Assembler usage:
;           MOV     AH,AllocOper
;           MOV     BX,method
;           MOV     AL,func
;           INT     21h
;
;   Error return:
;           AX = error_invalid_function
;----------------------------------------------------------------------------

	; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
_$ALLOCOPER:
	; 14/05/2019 - Retro DOS v4.0
	; MSDOS 6.0
	or	al,al ; 0
	jz	short AllocGetStrat
	; 17/12/2022
	;cmp	al,1
	;jz	short AllocSetStrat

	; 01/12/2022
	;cmp	al, 2
	;jb	short AllocSetStrat
	;ja	short AllocSetLink
	;;jmp	short AllocGetLink
;AllocGetLink:
	; MSDOS 6.0
	;mov	al,[ss:UMBFLAG]		; return link state in al
	;and 	al,LINKSTATE		
	;;transfer SYS_RET_OK
	;jmp	SYS_RET_OK

	cmp	al,2
	; 17/12/2022
	jb	short AllocSetStrat ; al = 1
	je	short AllocGetLink

	;cmp	al,2
	;jz	short AllocGetLink
	cmp	al,3
	jz	short AllocSetLink

	; 15/04/2018
	;CMP	AL,1
        ;JB	SHORT AllocOperGet
        ;JZ	SHORT AllocOperSet

AllocOperError:
	; 04/08/2018 - Retro DOS v3.0
	; MSDOS 3.3 (& MSDOS 6.0)	; Extended Error Locus	
	;mov	byte [ss:EXTERR_LOCUS],5
        MOV     byte [SS:EXTERR_LOCUS],errLOC_Mem
	;error	error_invalid_function
	;mov	al,1
	MOV	AL,error_invalid_function
	; 17/12/2022
;AllocOperErrj:
	;JMP	SYS_RET_ERR
	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;jmp	short dealloc_errj
	; 17/12/2022
	jmp	short AllocOperErrj

AllocArenaError:
	; MSDOS 6.0
	MOV     byte [SS:EXTERR_LOCUS],errLOC_Mem
					; M009: Extended Error Locus
	;error	error_arena_trashed	; M009:
	;mov	al,7
	MOV	AL,error_arena_trashed
	;JMP	SYS_RET_ERR
	jmp	short AllocOperErrj ; 17/12/2022

AllocGetStrat: 
	; MSDOS 6.0
AllocOperGet:
        MOV     AL,[SS:AllocMethod]
        XOR     AH,AH
	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;transfer SYS_RET_OK
AllocOperOk:
	; 17/12/2022
	;jmp	short dealloc_ok
	JMP	SYS_RET_OK

AllocSetStrat: 
	; 14/05/2019
	; MSDOS 6.0
	push	bx			; M000 - start
	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;and	bx,STRAT_MASK ; 0FF3Fh	; M064: mask off bit 6 & 7
	; 17/12/2022
	and	bl,3Fh
	cmp	bx,2			; BX must be 0-2
	;cmp	bl,2
	pop	bx			; M000 - end
	ja	short AllocOperError

AllocOperSet:
        MOV     [SS:AllocMethod],BL
  	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;transfer SYS_RET_OK
AllocOperOkj:
	jmp	short AllocOperOk
	;JMP	SYS_RET_OK

AllocGetLink:
	; MSDOS 6.0
	mov	al,[ss:UMBFLAG]		; return link state in al
	;and	al,1
	and 	al,LINKSTATE		
 	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;transfer SYS_RET_OK
AllocOperOkj2:
	; 17/12/2022
	jmp	short AllocOperOk
	;jmp	short AllocOperOkj
	;;JMP	SYS_RET_OK

AllocSetLink:
	; MSDOS 6.0			; M009 - start
	mov	cx,[ss:UMB_HEAD]	; cx = umb_head
	cmp	cx,0FFFFh		; Q: has umb_head been initialized
	je	short AllocOperError	; N: error
					; Y: continue
					; M009 - end
	cmp	bx,1			
	jb	short UnlinkUmbs
	jz	short LinkUmbs
	
	jmp	short AllocOperError
	
UnlinkUmbs:
	;test	byte [ss:UMBFLAG],1
	test	byte [ss:UMBFLAG],LINKSTATE ; Q: umbs unlinked?
	jz	short unlinked		; Y: return 
	
	call	GetLastArena		; get arena before umb_head in DS
	jc	short AllocArenaError	; M009: arena trashed
	
					; make it last
	mov	byte [0],arena_signature_end
	
	;and	byte [ss:UMBFLAG],0FEh
	and	byte [ss:UMBFLAG],~LINKSTATE ; indicate unlink'd state in umbflag
	
unlinked:
 	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;transfer SYS_RET_OK
	; 17/12/2022
	jmp	short AllocOperOk
	;jmp	short AllocOperOkj2
	;;JMP	SYS_RET_OK

LinkUmbs:
	test	byte [ss:UMBFLAG],LINKSTATE ; Q: umbs linked?
	jnz	short linked		; Y: return
	
	call	GetLastArena		; get arena before umb_head
	jc	short AllocArenaError	; M009: arena trashed
	
					; make it normal. M061: ds points to
					; arena before umb_head
	mov	byte [0],arena_signature_normal
	
	or	byte [ss:UMBFLAG],LINKSTATE ; indicate link'd state in umbflag
linked:
 	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;transfer SYS_RET_OK
	; 17/12/2022
	jmp	short AllocOperOk
	;jmp	short unlinked
	;;JMP	SYS_RET_OK

; MSDOS 6.0
;--------------------------------------------------------------------------
; Procedure Name : GetLastArena		-  M003
;
; Inputs	 : cx = umb_head
;
;
; Outputs	 : If UMBs are linked
;			ES = umb_head
;			DS = arena before umb_head
;		   else
;			DS = last arena
;			ES = next arena. will be umb_head if NC.
;
;		   CY if error
;
; Uses		 : DS, ES, DI, BX
;--------------------------------------------------------------------------

; 14/05/2019 - Retro DOS v4.0
; DOSCODE:A4D6h (MSDOS 6.21, MSDOS.SYS)

; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:A476h (MSDOS 5.0, MSDOS.SYS)
	
GetLastArena:
	push	ax			; save ax

	mov	ax,[ss:arena_head]
	mov	es,ax			; es = arena_head
	xor	di,di

	cmp     byte [es:di],arena_signature_end
					; Q: is this the last arena
	je	short GLA_done		; Y: return last arena in ES		
					
GLA_next:
	mov	ds,ax
	call	arena_next		; ax, es -> next arena
	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;jc	short GLA_err
	; 17/12/2022
	jc	short GLA_err2

	test	byte [ss:UMBFLAG],LINKSTATE ; Q: are UMBs linked
	jnz	short GLA_chkumb	; Y: terminating condition is 
					;    umb_head
					; N: terminating condition is 05Ah

	cmp     byte [es:di],arena_signature_end
					; Q: is this the last arena
	jmp	short GLA_@f
GLA_chkumb:
	cmp	ax,cx			; Q: is this umb_head
GLA_@f:
	jne	short GLA_next		; N: get next arena

GLA_done:
					; M061 - Start
	test	byte [ss:UMBFLAG],LINKSTATE ; Q: are UMBs linked
	jnz	short GLA_ret		; Y: we're done
					; N: let us confirm that the next 
					;    arena is umb_head
	mov	ds,ax
	call	arena_next		; ax, es -> next arena
	;jc	short GLA_err
	jc	short GLA_err2
	cmp	ax,cx			; Q: is this umb_head
	jne	short GLA_err		; N: error
					; M061 - End
GLA_ret:
	; 17/12/2022				
	;clc
	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;clc
	pop	ax			; M061
	retn				; M061

GLA_err:
	stc				; M061
GLA_err2:
	pop	ax
	retn

;============================================================================
; SRVCALL.ASM, MSDOS 6.0, 1991
;============================================================================
; 04/08/2018 - Retro DOS v3.0

;	TITLE SRVCALL - Server DOS call
;	NAME  SRVCALL

;**	SRVCALL.ASM - Server DOS call functions
;
;
;	$ServerCall
;
;	Modification history:
;
;	    Created: ARR 08 August 1983

;AsmVars <Installed>

;include dpl.asm

;Installed = TRUE

; 29/04/2019 - Retro DOS v4.0 (MSDOS 6.0, MSDOS 6.21)
; ---------------------------------------------------------------------------
; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)

;BREAK <ServerCall -- Server DOS call>

; DOSCODE:A517h (MSDOS 6.21, MSDOS.SYS)
; DOSCODE:A4B7h (MSDOS 5.0, MSDOS.SYS)

;hkn; TABLE	SEGMENT
;Public SRVC001S,SRVC001E
;SRVC001S label byte

SRVC001S:

SERVERTAB:	dw	SERVER_DISP
SERVERLEAVE:	dw	SERVERRETURN
SERVER_DISP:	db	(SERVER_DISP_END-SERVER_DISP-1)/2 ; = 11
		dw	SRV_CALL	; 0
		dw	COMMIT_ALL	; 1
		dw	CLOSE_NAME	; 2
		dw	CLOSE_UID	; 3
		dw	CLOSE_UID_PID	; 4
		dw	GET_LIST	; 5
		dw	GET_DOS_DATA	; 6
		dw	SPOOL_OPER	; 7
		dw	SPOOL_OPER	; 8
		dw	SPOOL_OPER	; 9
		dw	_$SetExtendedError  ; 10

SERVER_DISP_END:  ;  LABEL BYTE

;SRVC001E label byte

SRVC001E:

;hkn; TABLE	ENDS

;----------------------------------------------------------------------------
;
; Procedure Name : $ServerCall
;
; Inputs:
;	DS:DX -> DPL  (except calls 7,8,9)
; Function:
;	AL=0	Server DOS call
;	AL=1	Commit All files
;	AL=2	Close file by name (SHARING LOADED ONLY) DS:DX in DPL -> name
;	AL=3	Close all files for DPL_UID
;	AL=4	Close all files for DPL_UID/PID_PID
;	AL=5	Get open file list entry
;		    IN: BX File Index
;			CX User Index
;		    OUT:ES:DI -> Name
;			BX = UID
;		    CX = # locked blocks held by this UID
;	AL=6	Get DOS data area
;		    OUT: DS:SI -> Start
;			CX size in bytes of swap if indos
;			DX size in bytes of swap always
;	AL=7	Get truncate flag
;	AL=8	Set truncate flag
;	AL=9	Close all spool files
;	AL=10	SetExtendedError
;
;----------------------------------------------------------------------------

_$ServerCall:
	; 13/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; DOSCODE:A4D2h (MSDOS 5.0 MSDOS.SYS)		
	; 10/06/2019
	; 29/04/2019 - Retro DOS v4.0
	; DOSCODE:A532h (MSDOS 6.21 MSDOS.SYS)

	; 05/08/2018 - Retro DOS v3.0
	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 657Bh
	CMP	AL,7
	JB	short SET_STUFF
	CMP	AL,9
	JBE	short NO_SET_ID		; No DPL on calls 7,8,9
SET_STUFF:
	MOV	SI,DX			; Point to DPL with DS:SI
	;mov	bx,[si+12h]
	MOV	BX,[SI+DPL.UID]

	; MSDOS 6.0
;SR;
; WIN386 updates the USER_ID itself. If WIN386 is present we skip the updating
; of USER_ID

	test	byte [SS:IsWin386],1
	jnz	short skip_win386

;hkn; SS override for user_id and proc_id
	; 15/08/2018
	MOV	[SS:USER_ID],BX		; Set UID

skip_win386:
	MOV	BX,[SI+DPL.PID]
	MOV	[SS:PROC_ID],BX		; Set process ID
NO_SET_ID:
	; 10/06/2019 - Retro DOS v4.0
	PUSH	word [cs:SERVERLEAVE]	; push return address
	PUSH	word [cS:SERVERTAB]	; push table address
	PUSH	AX
	call	TableDispatch

;hkn; SS override
	;mov 	byte [SS:EXETERR_LOCUS],1
	MOV	byte [SS:EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus
	;error	error_invalid_function
	;mov	al,1
	MOV	AL,error_invalid_function
servercall_error:
	JMP	SYS_RET_ERR

SERVERRETURN:
	retn

; Commit - iterate through the open file list and make sure that the
; directory entries are correctly updated.

	; 01/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
COMMIT_ALL:
	XOR	BX,BX			;   for (i=0; ThisSFT=getSFT(i); i++)
	push	ss
	pop	ds
	call	ECritSFT		; Gonna scan SFT cache, lock it down
CommitLoop:
	push	bx
	call	SFFromSFN
	JC	short CommitDone
	cmp	word [es:di],0
	;CMP	word [ES:DI+SF_ENTRY.sf_Ref_Count],0
					; if (ThisSFT->refcount != 0)
	JZ	short CommitNext
	;cmp	word [es:di],0FFFFh ; -1
	cmp	word [ES:DI],sf_busy
	;CMP	word [ES:DI+SF_ENTRY.sf_Ref_Count],sf_busy  
					; BUSY SFTs have god knows what
	JZ	short CommitNext	;   in them.
	; 17/12/2022
	test	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_isnet>>8) ; 80h
	;TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet ; 8000h
	JNZ	short CommitNext	;  Skip Network SFTs so the SERVER
					;	doesn't deadlock
	MOV	[THISSFT],DI
	MOV	[THISSFT+2],ES
	call	DOS_COMMIT		;	DOSCommit ();
CommitNext:
	pop	bx
	INC	BX
	JMP	short CommitLoop
CommitDone:
	call	LCritSFT
	pop	bx
	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
Commit_Ok:
	jmp	SYS_RET_OK
	

CLOSE_NAME:

;if installed

;hkn; SS override
	;call	far [ss:MFTcloN]
	Call	far [SS:JShare+(5*4)] ; 5 = MFTcloN
;else
;	Call	MFTcloN
;endif

CheckReturns:
	JC	short func_err
	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;transfer SYS_RET_OK
Commit_Okj:
	jmp	short Commit_Ok
	;jmp	SYS_RET_OK

func_err:
	;transfer SYS_RET_ERR
	;jmp	SYS_RET_ERR
	jmp	short servercall_error

CLOSE_UID:

;if installed
;hkn; SS override
	;call	far [ss:MFTclU]
	Call	far [SS:JShare+(3*4)] ; 3 = MTFTclu
;else
;	Call	MFTclU
;endif
	JMP	short CheckReturns

CLOSE_UID_PID:

;if installed
;hkn; SS override
	;call	far [ss:MFTCloseP]
	Call	far [SS:JShare+(4*4)] ; 4 = MFTCloseP 
;else
;	Call	MFTCloseP
;endif
	JMP	short CheckReturns

GET_LIST:

;if installed
;hkn; SS override
	;call	far [ss:MFT_get]
	Call	far [SS:JShare+(9*4)] ; 9 = MFT_get
;else
;	Call	MFT_get
;endif
	JC	short func_err
	call	Get_User_Stack
	;mov	[si+2],bx
	MOV	[SI+user_env.user_BX],BX
	;mov	[si+10],di
	MOV	[SI+user_env.user_DI],DI
	;mov	[si+16],es
	MOV	[SI+user_env.user_ES],ES
SetCXOK:
	;mov	[si+4],cx
	MOV	[SI+user_env.user_CX],CX
	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;transfer SYS_RET_OK
Commit_Okj2:
	; 17/12/2022
	jmp	short Commit_Ok
	;jmp	short Commit_Okj
	;;jmp	SYS_RET_OK

SRV_CALL:
	POP	AX			; get rid of call to $srvcall
	push	ds
	push	si
	call	Get_User_Stack
	pop	di
	pop	es

; DS:SI point to stack
; ES:DI point to DPL

	call	XCHGP

; DS:SI point to DPL
; ES:DI point to stack
;
; We now copy the registers from DPL to save stack

	push	si
	MOV	CX,6
	REP	MOVSW			; Put in AX,BX,CX,DX,SI,DI
	INC	DI
	INC	DI			; Skip user_BP
	MOVSW				; DS
	MOVSW				; ES
	pop	si			; DS:SI -> DPL
	mov	ax,[SI]
	;MOV	AX,[SI+DPL.AX]
	;mov	bx,[si+2]
	MOV	BX,[SI+DPL.BX]
	;mov	cx,[si+4]
	MOV	CX,[SI+DPL.CX]
	;mov	dx,[si+6]
	MOV	DX,[SI+DPL.DX]
	;mov	di,[si+10]
	MOV	DI,[SI+DPL.DI]
	;mov	es,[si+14]
	MOV	ES,[SI+DPL.ES]
	;push	word [si+8]
	PUSH	word [SI+DPL.SI]
	;mov	ds,[si+12]
	MOV	DS,[SI+DPL.DS]
	POP	SI

;hkn; SS override for next 3
	MOV	[SS:SAVEDS],DS
	MOV	[SS:SAVEBX],BX
	MOV	byte [SS:FSHARING],-1	; set no redirect flag
	jmp	REDISP

GET_DOS_DATA:
	push	ss
	pop	es
	MOV     DI,SWAP_START
	MOV     CX,SWAP_END
	MOV     DX,SWAP_ALWAYS
	SUB     CX,DI
	SUB     DX,DI
	SHR     CX,1                    ; div by 2, remainder in carry
	ADC     CX,0                    ; div by 2 + round up
	SHL     CX,1                    ; round up to 2 boundary.
	call	Get_User_Stack
	;mov	[si+14],es
	MOV     [SI+user_env.user_DS],ES
	;mov	[si+8],di
	MOV     [SI+user_env.user_SI],DI
	;mov	[si+6],dx
	MOV     [SI+user_env.user_DX],DX
	JMP	short SetCXOK

SPOOL_OPER:
	;CallInstall NETSpoolOper,MultNET,37,AX,BX

	push    ax
	mov     ax,1125h
	int     2Fh	; Multiplex - NETWORK REDIRECTOR - REDIRECTED PRINTER MODE
			; STACK: WORD subfunction
			; Return: CF set on error, AX = error code
			; STACK unchanged
	pop	bx
	; 17/12/2022
	;JC	short func_err2
	jnc	short Commit_Okj2
	; 01/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;;jmp	SYS_RET_OK
	;jmp	short Commit_Okj2
	
func_err2:
	jmp	SYS_RET_ERR

;Break	<$SetExtendedError - set extended error for later retrieval>
;--------------------------------------------------------------------------
;
; Procedure Name : $SetExtendedError
;
; $SetExtendedError takes extended error information and loads it up for the
; next extended error call. This is used by interrupt-level proccessors to
; mask their actions.
;
;   Inputs: DS:SI points to DPL which contains all registers
;   Outputs: none
;
;---------------------------------------------------------------------------

_$SetExtendedError:

;hkn; SS override for all variables used

	mov	ax,[si]
	;MOV	AX,[SI+DPL.AX]
	MOV	[SS:EXTERR],AX
	;mov	ax,[si+10]
	MOV	AX,[SI+DPL.DI]
	MOV	[SS:EXTERRPT],AX
	;mov	ax,[si+14]
	MOV	AX,[SI+DPL.ES]
	MOV	[SS:EXTERRPT+2],AX
	;mov	ax,[si+2]
	MOV	AX,[SI+DPL.BX]
	MOV	[SS:EXTERR_ACTION],AX
	;mov	ax,[si+4]
	MOV	AX,[SI+DPL.CX]
	MOV	[SS:EXTERR_LOCUS],AH
	retn

;============================================================================
; UTIL.ASM, MSDOS 6.0, 1991
;============================================================================
; 05/08/2018 - Retro DOS v3.0
; 05/05/2019 - Retro DOS v4.0

;**	Handle related utilities for MSDOS 2.X.
;----------------------------------------------------------------------------
;	pJFNFromHandle	written
;	SFFromHandle	written
;	SFFromSFN	written
;	JFNFree 	written
;	SFNFree 	written
;
;	Modification history:
;
;	    Created: MZ 1 April 1983
;----------------------------------------------------------------------------

;	BREAK	<pJFNFromHandle - return pointer to JFN table entry>

;**	pJFNFromHandle - Translate Handle to Pointer to JFN
;----------------------------------------------------------------------------
;	pJFNFromHandle takes a file handle and turns that into a pointer to
;	the JFN entry (i.e., to a byte holding the internal file handle #)
;
;	NOTE:
;	  This routine is called from $CREATE_PROCESS_DATA_BLOCK which is called
;	  at DOSINIT time with SS NOT DOSGROUP
;
;	ENTRY	(bx) = handle
;	EXIT	'C' clear if ok
;		  (es:di) = address of JFN value
;		'C' set if error
;		  (ax) = error code
;	USES	AX, DI, ES, Flags
;----------------------------------------------------------------------------

	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)

pJFNFromHandle:
	; 05/05/2019 - Retro DOS v4.0
	;getdseg <es>			; es -> dosdata
	mov	es,[cs:DosDSeg]
	
	;MOV	ES,[cs:CurrentPDB]	; get user process data block
	mov	es,[es:CurrentPDB]

	;cmp	bx,[ES:32h]
	CMP	BX,[ES:PDB.JFN_Length]	; is handle greater than allocated
	JB	short pjfn10		; no, get offset
ReturnCarry_inv_hndl: ; 05/08/2018 - Retro DOS v3.0
	;mov	al,6
	MOV     AL,error_invalid_handle ; appropriate error
ReturnCarry:
	STC                             ; signal error
	retn				; go back
pjfn10: 
	;les	di,[es:34h]
	LES	DI,[ES:PDB.JFN_Pointer]	; get pointer to beginning of table
	ADD	DI,BX			; add in offset, clear 'C'
	;clc
pJFNFromHandle_error:
	retn

;BREAK <SFFromHandle - return pointer (or error) to SF entry from handle>
;----------------------------------------------------------------------------
;
; Procedure Name : SFFromHandle
;
; SFFromHandle - Given a handle, get JFN and then index into SF table
;
;   Input:      BX has handle
;   Output:     Carry Set
;                   AX has error code
;               Carry Reset
;                   ES:DI has pointer to SF entry
;   Registers modified: If error, AX,ES, else ES:DI
; NOTE:
;   This routine is called from $CREATE_PROCESS_DATA_BLOCK which is called
;       at DOSINIT time with SS NOT DOSGROUP
;
;----------------------------------------------------------------------------

	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)

SFFromHandle:
	CALL	pJFNFromHandle		; get jfn pointer
	;retc				; return if error
	jc	short pJFNFromHandle_error
	CMP     BYTE [ES:DI],-1		; unused handle
	;JNZ	short GetSF		; nope, suck out SF
	;;mov	al,6
	;MOV	AL,error_invalid_handle ; appropriate error
	;jmp	short ReturnCarry	; signal it
	; 17/12/2022
	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	jz	short ReturnCarry_inv_hndl ; Retro DOS v3.0 modification
	;JNZ	short GetSF		; nope, suck out SF
	;;mov	al,6
	;MOV	AL,error_invalid_handle ; appropriate error
	;jmp	short ReturnCarry	; signal it
GetSF:
	push	bx			; save handle
	MOV     BL,[ES:DI]		; get SFN
	XOR     BH,BH                   ; ignore upper half
	CALL    SFFromSFN               ; get real sf spot
	pop	bx			; restore
	retn                        	; say goodbye

;BREAK <SFFromSFN - index into SF table for SFN>

;**	SFFromSFN - Get an SF Table entry from an SFN
;----------------------------------------------------------------------------
;	SFFromSfn uses an SFN to index an entry into the SF table. This
;	is more than just a simple index instruction because the SF table
;	can be made up of multiple pieces chained together. We follow the
;	chain to the right piece and then do the index operation.
;
;   NOTE:
;	This routine is called from SFFromHandle which is called
;       at DOSINIT time with SS NOT DOSGROUP
;
;	ENTRY	BX has SF index
;	EXIT	'C' clear if OK
;		  ES:DI points to SF entry
;		'C' set if index too large
;	USES	BX, DI, ES
;----------------------------------------------------------------------------

	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)

SFFromSFN:
	; 05/05/2019 - Retro DOS v4.0
	;getdseg <es>			; es -> dosdata
	mov	es,[cs:DosDSeg]

	;LES	DI,[CS:SFT_ADDR]	; (es:di) = start of SFT table
	les	di,[es:SFT_ADDR]
sfsfn5:	
	;cmp	bx,[es:di+4]
	CMP	BX,[ES:DI+SFT.SFCount]	; is handle in this table?
	JB	short sfsfn7		; yes, go grab it
	;sub	bx,[es:di+4]
	SUB     BX,[ES:DI+SFT.SFCount]
	les	di,[es:di] ; 14/08/2018
	;LES	DI,[ES:DI+SFT.SFLink]	; get next table segment
	CMP     DI,-1                   ; end of tables?
	JNZ	short sfsfn5		; no, try again
	STC
	retn				; return with error, not found
sfsfn7:
	push	ax
	;mov	ax,53 ; MSDOS 3.3
	;mov	ax,59 ; MSDOS 6.0
	;MOV	AX,SF_ENTRY.size	; put it in a nice place
	
	; 17/12/2022
	mov	al,SF_ENTRY.size ; 28/05/2019
	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;mov	ax,SF_ENTRY.size ; 59
	
	MUL	BL			; (ax) = offset into this SF block
	ADD	DI,AX			; add base of SF block
	pop	ax
	;add	di,6
	ADD	DI,SFT.SFTable		; offset into structure, 'C' cleared
	retn				; return with 'C' clear

;	BREAK <JFNFree - return a jfn pointer if one is free>

;**	JFNFree - Find a Free JFN Slot
;----------------------------------------------------------------------------
;	JFNFree scansthrough the JFN table and returnsa pointer to a free slot
;
;	ENTRY	(ss) = DOSDATA
;	EXIT	'C' clear if OK
;		  (bx) = new handle
;		  (es:di) = pointer to JFN slot
;		'C' set if error
;		  (al) = error code
;	USES	bx, di, es, flags
;----------------------------------------------------------------------------

JFNFree:
	XOR	BX,BX			; (bx) = initial JFN to try
jfnf1:	
	CALL	pJFNFromHandle		; get the appropriate handle
	JC	short jfnf5		; no more handles
	CMP     BYTE [ES:DI],-1		; free?
	je	short jfnfx		; yes, carry is clear
	INC     BX                      ; no, next handle
	JMP	short jfnf1		; and try again

	; Error. 'C' set
jfnf5:	
	;mov	al,4
	MOV	AL,error_too_many_open_files
jfnfx:	
	retn				; bye

;	BREAK <SFNFree - Allocate a free SFN>

;**	SFNFree - Allocate a Free SFN/SFT
;----------------------------------------------------------------------------
;	SFNFree scans through the sf table looking for a free entry
;	If it finds one it partially allocates it by setting SFT_REF_COUNT = -1
;
;	The problem is that we want to mark the SFT busy so that other threads
;	can't allocate the SFT before we're finished marking it up.  However,
;	we can't just mark it busy because we may get blown out of our open
;	by INT24 and leave the thing orphaned.	To solve this we mark it
;	"allocation in progress" by setting SFT_REF_COUNT = -1.  If we see
;	an SFT with this value we look to see if it belongs to this user
;	and process.  If it does belong to us then it must be an orphan
;	and we reclaim it.
;
;	BUGBUG - improve the performance. I guess it's smaller to call SFFromSFN
;		over and over, but we could at least set a high water mark...
;		cause an N^2 loop calling slow SFFromSFN is real slow, too slow
;		even though this is not a frequently called routine - jgl
;
;	ENTRY	(ss) = DOSDATA
;	EXIT	'C' clear if no error
;		  (bx) = SFN
;		  (es:di) = pointer to SFT
;		  es:[di].SFT_REF_COUNT = -1
;		'C' set if error
;		  (al) = error code
;	USES	bx, di, es, Flags
;----------------------------------------------------------------------------

	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; DOSCODE:A682h (MSDOS 5.0 MSDOS.SYS)

SFNFree:
	; 12/08/2018
	; 05/08/2018 - Retro DOS v3.0
	;
	; MSDOS 6.0
	push	ax
	xor	bx,bx			; (bx) = SFN to consider
sfnf5:	
	push	bx
	call	SFFromSFN		; get the potential handle
	pop	bx
	jc	short sfnf95		; no more free SFNs
	cmp	word [ES:DI],0
	;cmp	word [ES:DI+SF_ENTRY.sf_Ref_Count],0 ; free?
	je	short sfnf20			; yep, got one
	
	;cmp	word [es:di],0FFFFh ; -1
	cmp	word [ES:DI],sf_busy
	;cmp	word [ES:DI+SF_ENTRY.sf_ref_count],sf_busy
	je	short sfnf10		; special busy mark
sfnf7:	
	inc	bx			; try the next one
	jmp	short sfnf5

;	The SFT has the special "busy" mark; if it belongs to us then
;	it was abandoned during a earlier call and we can use it.
;
;	(bx)	= SFN
;	(es:di) = pointer to SFT
;	(TOS)	= caller's (ax)

sfnf10:	
	mov	ax,[SS:USER_ID]
	;cmp	[es:di+2Fh],ax
	cmp	[ES:DI+SF_ENTRY.sf_UID],ax
	jnz	short sfnf7		; not ours
	mov	ax,[SS:PROC_ID]
	;cmp	[es:di+31h],ax
	cmp	[ES:DI+SF_ENTRY.sf_PID],ax
	jnz	short sfnf7		; can't use this one, try the next

;	We have an SFT to allocate
;
;	(bx)	= SFN
;	(es:di) = pointer to SFT
;	(TOS)	= caller's (ax)

sfnf20:
	; cf = 0 ;; Retro DOS v3.0

	;mov	word [es:di],0FFFFh
	mov	word [ES:DI],sf_busy
					; make sure that this is allocated
	;mov	word [ES:DI+SF_ENTRY.sf_ref_count],sf_busy

	mov	ax,[SS:USER_ID]
	;mov	[es:di+2Fh],ax
	mov	[ES:DI+SF_ENTRY.sf_UID],ax
	mov	ax,[SS:PROC_ID]
	;mov	[es:di+31h],ax
	mov	[ES:DI+SF_ENTRY.sf_PID],ax
sfnf21: ;; Retro DOS v3.0
	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;pop	ax
	;;clc
	;retn				; return with no error
	; 17/12/2022
	pop	ax
	;clc
	retn

;**	Error - no more free SFNs
;
;	'C' set
;	(TOS) = saved ax

sfnf95: 
	pop	ax
	;mov	al,4
	mov	al,error_too_many_open_files
	retn				; return with 'C' and error

;============================================================================
; HANDLE.ASM, MSDOS 6.0, 1991
;============================================================================
; 13/07/2018 - Retro DOS v3.0
; 20/05/2019 - Retro DOS v4.0

; DOSCODE:A72Bh (MSDOS 6.21, MSDOS.SYS)

;	BREAK <$Close - return a handle to the system>
;----------------------------------------------------------------------------
;
;**	$Close - Close a file Handle
;
;	BUGBUG - close gets called a LOT with invalid handles - sizzle that
;		path
;
;	Assembler usage:
;	    MOV     BX, handle
;	    MOV     AH, Close
;	    INT     int_command
;
;	ENTRY	(bx) = handle
;	EXIT	<normal INT21 return convention>
;	USES	all
;
;----------------------------------------------------------------------------

; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:A6CBh (MSDOS 5.0 MSDOS.SYS)

_$CLOSE:
;	Grab the SFT pointer from the JFN.

	call	CheckOwner		; get system file entry
	jc	short CloseError	; error return
	push	ss
	pop	ds			; For DOS_CLOSE
	MOV	[THISSFT],DI		; save offset of pointer
	MOV	[THISSFT+2],ES		; save segment value

; DS:SI point to JFN table entry.
; ES:DI point to SFT
;
; We now examine the user's JFN entry; If the file was a 70-mode file (network
; FCB, we examine the ref count on the SFT;  if it was 1, we free the JFN.
; If the file was not a net FCB, we free the JFN too.

	;CMP	word [ES:DI+SF_ENTRY.sf_ref_count],1
	cmp	word [ES:DI],1		; will the SFT become free?
	jz	short FreeJFN 		; yes, free JFN anyway.
	;mov	al,[ES:DI+2]
	MOV	AL,[ES:DI+SF_ENTRY.sf_mode]
	;and	al,0F0h
	AND	AL,SHARING_MASK
	;cmp	al,70h
	CMP	AL,SHARING_NET_FCB
	JZ	short PostFree		; 70-mode and big ref count => free it

; The JFN must be freed.  Get the pointer to it and replace the contents with
; -1.

FreeJFN:
	call	pJFNFromHandle		;   d = pJFN (handle);
	MOV	BYTE [ES:DI],0FFh	; release the JFN
PostFree:

; ThisSFT is correctly set, we have DS = DOSDATA. Looks OK for a DOS_CLOSE!

	call	DOS_CLOSE

; DOS_Close may return an error. If we see such an error, we report it but
; the JFN stays closed because DOS_Close always frees the SFT!

	JC	short CloseError
	;mov	ah,3Eh
	MOV	AH,CLOSE		; MZ Bogus multiplan fix
	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
CloseOk:
	jmp	SYS_RET_OK
CloseError:
	jmp	SYS_RET_ERR

;	BREAK <$Commit - commit the file>
;----------------------------------------------------------------------------
;
;**	$Commit - Commit a File
;
;	$Commit "commits" a file to disk - all of it's buffers are
;	flushed out.  BUGBUG - I'm pretty sure that $Commit doesn't update
;	the directory entry, etc., so this commit is pretty useless. check
;	and fix this!! jgl
;
;	Assembler usage:
;	    MOV     BX, handle
;	    MOV     AH, Commit
;	    INT     int_command
;
;	ENTRY	(bx) = handle
;	EXIT	none
;	USES	all
;;----------------------------------------------------------------------------

_$COMMIT:
;	Grab the SFT pointer from the JFN.

	call	CheckOwner		; get system file entry
	JC	short CommitError	; error return
	push	ss
	pop	ds			; For DOS_COMMIT
	MOV	[THISSFT],DI		; save offset of pointer
	MOV	[THISSFT+2],ES		; save segment value

;	ThisSFT is correctly set, we have DS = DOSDATA. Looks OK for a DOS_COMMIT
;
;	ES:DI point to SFT

	call	DOS_COMMIT
	JC	short CommitError
	; 07/12/2022
	;jc	short CloseError
	;mov	ah,68h
	MOV	AH,COMMIT
	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;jmp	SYS_RET_OK
CommitOk:
	jmp	short CloseOk	

CommitError:
	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;jmp	SYS_RET_ERR
	jmp	short CloseError

;	BREAK <$ExtHandle - extend handle count>

;**	$ExtHandle - Extend Handle Count
;----------------------------------------------------------------------------
;	Assembler usage:
;	    MOV     BX, Number of Opens Allowed (MAX=65534;66535 is
;	    MOV     AX, 6700H			 reserved to mark SFT
;	    INT     int_command 		 busy )
;
;	ENTRY	(bx) = new number of handles
;	EXIT	'C' clear if OK
;		'C' set iff err
;		  (ax) = error code
;			 AX = error_not_enough_memory
;			      error_too_many_open_files
;	USES	all
;----------------------------------------------------------------------------

_$ExtHandle:
	XOR	BP,BP			; 0: enlarge   1: shrink  2:psp
	;cmp	bx,20
	CMP	BX,FILPERPROC
	JAE	short exth2		; Don't set less than FilPerProc no
	MOV	BX,FILPERPROC
exth2:	
	MOV	ES,[ss:CurrentPDB]	; get user process data block;smr;SS Override
	;mov	cx,[ES:32h]
	MOV	CX,[ES:PDB.JFN_Length]	; get number of handle allowed
	CMP	BX,CX			; the requested == current
	JE	short ok_done 		; yes and exit
	JA	short larger		; go allocate new table

;	We're going to shrink the # of handles available

	MOV	BP,1			; shrink
	;mov	ds,[ES:36h]
	MOV	DS,[ES:PDB.JFN_Pointer+2] ;
	MOV	SI,BX			;
	SUB	CX,BX			; get difference

;	BUGBUG - code a SCASB here, should be a bit smaller
chck_handles:
	CMP	BYTE [SI],-1		; scan through handles to ensure close
	JNZ	short too_many_files	; status
	INC	SI
	LOOP	chck_handles
	CMP	BX,FILPERPROC		; = 20
	JA	short larger		; no

	MOV	BP,2			; psp
	;mov	di,24
	MOV	DI,PDB.JFN_TABLE	; es:di -> jfn table in psp
	PUSH	BX
	JMP	short movhandl

larger:
	CMP	BX,-1			; 65535 is not allowed
	JZ	short invalid_func	; 10/08/2018
	CLC
	PUSH	BX			; save requested number
	ADD	BX,0FH			; adjust to paragraph boundary
	MOV	CL,4
	;ror	bx,cl			; MSDOS 3.3
	RCR	BX,CL			; DOS 4.00 fix		;AC000;
	AND	BX,1FFFH		; clear most 3 bits

	PUSH	BP
	call	_$ALLOC			; allocate memory
	POP	BP
	JC	short no_memory		; not enough meory

	MOV	ES,AX			; es:di points to new table memory
	XOR	DI,DI
movhandl:
	MOV	DS,[ss:CurrentPDB] 	; get user PDB address	;smr;SS Override

	test	BP,3			; enlarge ?
	JZ	short enlarge 		; yes
	POP	CX			; cx = the amount you shrink
	PUSH	CX
	JMP	short copy_hand

;	Done.  'C' clear

; 17/12/2022
;ok_done:
;	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
;	;jmp	short CommitOk
;	; 17/12/2022
;	jmp	SYS_RET_OK

too_many_files:
	;mov	al,4
	MOV	AL,error_too_many_open_files
	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;jmp	SYS_RET_ERR
CommitErrorj:
	;jmp	short CommitError
	; 17/12/2022
	jmp	SYS_RET_ERR

; 17/12/2022 
ok_done:
	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;jmp	short CommitOk
	; 17/12/2022
	jmp	SYS_RET_OK

enlarge:
	;mov	cx,[32h]
	MOV	CX,[PDB.JFN_Length]	; get number of old handles
copy_hand:
	MOV	DX,CX
	;lds	si,[34h]
	LDS	SI,[PDB.JFN_Pointer]	; get old table pointer
	REP	MOVSB			; copy infomation to new table
	POP	CX			; get new number of handles
	PUSH	CX			; save it again
	SUB	CX,DX			; get the difference
	MOV	AL,-1			; set availability to handles
	REP	STOSB
	MOV	DS,[ss:CurrentPDB] 	; get user process data block;smr;SS Override
	;cmp	word [34h],0
	CMP	WORD [PDB.JFN_Pointer],0 ; check if original table pointer
	JNZ	short update_info	; yes, go update PDB entries
	PUSH	BP
	PUSH	DS			; save old table segment
	PUSH	ES			; save new table segment
	MOV	ES,[PDB.JFN_Pointer+2]	; get old table segment
	call	_$DEALLOC		; deallocate old table meomory
	POP	ES			; restore new table segment
	POP	DS			; restore old table segment
	POP	BP

update_info:
	test	BP,2			; psp?
	JZ	short non_psp 		; no
	;mov	word [34h],18h ; 24
	MOV	WORD [PDB.JFN_Pointer],PDB.JFN_TABLE ; restore
	JMP	short final
non_psp:
	;mov	word [34h],0
	MOV	WORD [PDB.JFN_Pointer],0 ; new table pointer offset always 0
final:
	;mov	[36h],es	
	MOV	[PDB.JFN_Pointer+2],ES	; update table pointer segment
	;pop	word [32h]
	POP	word [PDB.JFN_Length]	; restore new number of handles
	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;jmp	SYS_RET_OK
ok_done_j:
	jmp	short ok_done

no_memory:
	POP	BX			; clean stack
	;mov	al,8
	MOV	AL,error_not_enough_memory
	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;jmp	SYS_RET_ERR
CommitErrorj2:
	jmp	short CommitErrorj

invalid_func:
	;mov	al,1
	MOV	AL,error_invalid_function
	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;jmp	SYS_RET_ERR
CommitErrorj3:
	;jmp	short CommitErrorj2
	; 17/12/2022
	jmp	short CommitErrorj

; 20/05/2019 - Retro DOS v4.0
; DOSCODE:A83Ah (MSDOS 6.21, MSDOS.SYS)

; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:A7DAh (MSDOS 5.0 MSDOS.SYS)

;	BREAK <$READ - Read from a file handle>
;----------------------------------------------------------------------------
;
;**	$Read - Read from a File Handle
;
;   Assembler usage:
;
;	LDS	DX, buf
;	MOV	CX, count
;	MOV	BX, handle
;	MOV	AH, Read
;	INT	int_command
;	  AX has number of bytes read
;
;	ENTRY	(bx) = file handle
;		(cx) = byte count
;		(ds:dx) = buffer address
;	EXIT	Through system call return so that to user:
;		  'C' clear if OK
;		    (ax) = bytes read
;		  'C' set if error
;		    (ax) = error code
;
;----------------------------------------------------------------------------

_$READ:
	MOV	SI,DOS_READ
ReadDo:
	call	pJFNFromHandle
	JC	short ReadError

	MOV	AL,[ES:DI]
	call	CheckOwner		; get the handle
	JNC	short ReadSetup		; no errors do the operation

;	Have an error. 'C' set

ReadError:
	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;;jmp	SYS_RET_ERR		; go to error traps
	;jmp	short CommitErrorj3
	; 17/12/2022
	jmp	SYS_RET_ERR

ReadSetup:
	MOV	[ss:THISSFT],DI		; save offset of pointer;smr;SS Override
	MOV	[ss:THISSFT+2],ES	; save segment value	;smr;SS Override
	; 20/05/2019 - Retro DOS v4.0
	; MSDOS 6.0 
;; Extended Open
	;test	byte [es:di+3],20h
	test	byte [ES:DI+SF_ENTRY.sf_mode+1],(INT_24_ERROR>>8)
						 ;AN000;;EO. need i24
	JZ	short needi24 		     	 ;AN000;;EO. yes
	OR	byte [ss:EXTOPEN_ON],EXT_OPEN_I24_OFF ; 2
					;AN000;;EO. set it off;smr;SS Override
needi24:				;AN000;
;; Extended Open
	push	word [SS:DMAADD]
	push	word [SS:DMAADD+2]	;smr;SS Override

;;;;;	BAD SPOT FOR 286!!! SEGMENT ARITHMETIC!!!

	; 26/07/2019

	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;
	; (It is not necessary to call 'Align_Buffer' proc here/below because
	; there is not another caller; it is better to put the code in this proc
 	; here instead of calling it as a subroutine; but I have modified code
	; here for MSDOS 5.0 MSDOS.SYS address compatibility)

	; MSDOS 6.0
	CALL	Align_Buffer		;AN000;MS. align user's buffer
	
	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	; MSDOS 3.3
	;MOV	BX,DX			; copy offset
	;push	cx			; don't stomp on count
	;MOV	CL,4			; bits to shift bytes->para
	;SHR	BX,CL			; get number of paragraphs
	;pop	cx			; get count back
	;MOV	AX,DS			; get original segment
	;ADD	AX,BX			; get new segment
	;MOV	DS,AX			; in seg register
	;AND	DX,0Fh			; normalize offset
	;MOV	[ss:DMAADD],DX		; use user DX as offset	;smr;SS Override
	;MOV	[ss:DMAADD+2],DS 	; use user DS as segment for DMA
						;smr;SS Override
;;;;;	END BAD SPOT FOR 286!!! SEGMENT ARITHMETIC!!!
	
	push	ss			; go for DOS addressability
	pop	ds

	CALL	SI ; DOS_READ		; indirect call to operation

	pop	word [DMAADD+2]
	pop	word [DMAADD]
	;JNC	short READ_OK		;AN002;
	;JMP	short ReadError		;AN002; if error, say bye bye
	; 17/12/2022
	jc	short ReadError
	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;jnc	short READ_OK		;AN002;
	;jmp	short ReadError

READ_OK:
	MOV	AX,CX			; get correct return in correct reg
Read_Okj:
	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;;jmp	SYS_RET_OK		; successful return
	;jmp	short ok_done_j
	; 17/12/2022
	jmp	SYS_RET_OK

; 13/07/2018 - Retro DOS v3.0

;----------------------------------------------------------------------------

;   Input: DS:DX points to user's buffer addr
;   Function: rearrange segment and offset for READ/WRITE buffer
;   Output: [DMAADD] set

; 20/05/2019 - Retro DOS v4.0
; 26/07/2019
;	; MSDOS 6.0
;Align_Buffer:
;	MOV	BX,DX			; copy offset
;	push	cx			; don't stomp on count
;	MOV	CL,4			; bits to shift bytes->para
;	SHR	BX,CL			; get number of paragraphs
;	pop	cx			; get count back
;	MOV	AX,DS			; get original segment
;	ADD	AX,BX			; get new segment
;	MOV	DS,AX			; in seg register
;	AND	DX,0Fh			; normalize offset
;	MOV	[ss:DMAADD],DX		; use user DX as offset	;smr;SS Override
;	MOV	[ss:DMAADD+2],DS 	; use user DS as segment for DMA
;						;smr;SS Override
;	retn

; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
Align_Buffer:
	MOV	BX,DX			; copy offset
	push	cx			; don't stomp on count
	MOV	CL,4			; bits to shift bytes->para
	SHR	BX,CL			; get number of paragraphs
	pop	cx			; get count back
	MOV	AX,DS			; get original segment
	ADD	AX,BX			; get new segment
	MOV	DS,AX			; in seg register
	AND	DX,0Fh			; normalize offset
	MOV	[ss:DMAADD],DX		; use user DX as offset	;smr;SS Override
	MOV	[ss:DMAADD+2],DS 	; use user DS as segment for DMA
						;smr;SS Override
	retn

; 20/05/2019 - Retro DOS v4.0
; DOSCODE:A8A0h (MSDOS 6.21, MSDOS.SYS)

; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:A840h (MSDOS 5.0 MSDOS.SYS)

;BREAK <$WRITE - write to a file handle>
;----------------------------------------------------------------------------
;
;   Assembler usage:
;	    LDS     DX, buf
;	    MOV     CX, count
;	    MOV     BX, handle
;	    MOV     AH, Write
;	    INT     int_command
;	  AX has number of bytes written
;   Errors:
;	    AX = write_invalid_handle
;	       = write_access_denied
;
;   Returns in register AX
;
;----------------------------------------------------------------------------

_$WRITE:
	MOV	SI,DOS_WRITE
	JMP	short ReadDo

;BREAK <$LSEEK - move r/w pointer>
;----------------------------------------------------------------------------
;
;   Assembler usage:
;	    MOV     DX, offsetlow
;	    MOV     CX, offsethigh
;	    MOV     BX, handle
;	    MOV     AL, method
;	    MOV     AH, LSeek
;	    INT     int_command
;	  DX:AX has the new location of the pointer
;   Error returns:
;	    AX = error_invalid_handle
;	       = error_invalid_function
;   Returns in registers DX:AX
;
;----------------------------------------------------------------------------

; 21/05/2019 - Retro DOS v4.0
; DOSCODE:A8A5h (MSDOS 6.21, MSDOS.SYS)

; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:A845h (MSDOS 5.0 MSDOS.SYS)

_$LSEEK:
	call	CheckOwner		; get system file entry

	; 17/12/2022
;LSeekError:
	;JNC	short CHKOWN_OK		;AN002;
	;JMP	short ReadError		;AN002; error return
	; 17/12/2022
	; 02/06/2019
	jc	short ReadError
	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;JNC	short CHKOWN_OK		;AN002;
	;JMP	short ReadError		;AN002; error return

CHKOWN_OK:
					;AN002;
	CMP	AL,2			; is the seek value correct?
	JBE	short LSeekDisp		; yes, go dispatch
	;mov	byte [ss:EXTERR_LOCUS],1 
	MOV	byte [ss:EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus
					;smr;SS Override
	;mov	al,1
	mov	al,error_invalid_function ; invalid method
	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
LSeekError2:
	jmp	short ReadError

LSeekDisp:
	CMP	AL,1			; best way to dispatch; check middle
	JB	short LSeekStore	; just store CX:DX
	JA	short LSeekEOF		; seek from end of file
	;add	dx,[es:di+21]
	ADD	DX,[ES:DI+SF_ENTRY.sf_position]
	;adc	cx,[es:di+23]
	ADC	CX,[ES:DI+SF_ENTRY.sf_position+2]
LSeekStore:
	MOV	AX,CX			; AX:DX
	XCHG	AX,DX			; DX:AX is the correct value
LSeekSetpos:
	;mov	[es:di+21],ax
	MOV	[ES:DI+SF_ENTRY.sf_position],AX
	;mov	[es:di+23],dx
	MOV	[ES:DI+SF_ENTRY.sf_position+2],DX
	call	Get_User_Stack
	;mov	[si+6],dx
	MOV	[SI+user_env.user_DX],DX ; return DX:AX
	;jmp	SYS_RET_OK		; successful return
	; 25/06/2019
	;jmp	SYS_RET_OK_clc
	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;jmp	SYS_RET_OK_clc
LSeekOk:
	jmp     short Read_Okj

LSeekEOF:
	;;test	word [es:di+5],8000h
	;test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
	; 21/05/2019 - Retro DOS v4.0
	test	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
	JNZ	short Check_LSeek_Mode	; Is Net
LOCAL_LSeek:
	;add	dx,[es:di+17]
	ADD	DX,[ES:DI+SF_ENTRY.sf_size]
	;adc	cx,[es:di+19]
	ADC	CX,[ES:DI+SF_ENTRY.sf_size+2]
	JMP	short LSeekStore	; go and set the position

Check_LSeek_Mode:
	;;test	word [es:di+2],8000h
	;test	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB
	; 21/05/2019
	test	byte [ES:DI+SF_ENTRY.sf_mode+1],(sf_isFCB>>8)
	JNZ	short LOCAL_LSeek	; FCB treated like local file
	;mov	ax,[es:di+2]
	MOV	AX,[ES:DI+SF_ENTRY.sf_mode]
	;and	ax, 0F0h
	AND	AX,SHARING_MASK
	;cmp	ax,40h
	CMP	AX,SHARING_DENY_NONE
	JZ	short NET_LSEEK		; LSEEK exported in this mode
	;cmp	ax,30h
	CMP	AX,SHARING_DENY_READ
	JNZ	short LOCAL_LSeek	; Treated like local Lseek
NET_LSEEK:
;	JMP	short LOCAL_LSeek
; REMOVE ABOVE INSTRUCTION TO ENABLE DCR 142
	;CallInstall Net_Lseek,MultNET,33
	;JNC	short LSeekSetPos

	mov     ax,1121h
	int     2Fh	; Multiplex - NETWORK REDIRECTOR - SEEK FROM END OF REMOTE FILE
			; CX:DX = offset (in bytes) from end
			; ES:DI -> SFT, SFT DPB field -> DPB of drive with file
			; SS = DOS CS
			; Return: CF set on error
			; CF clear if successful, DX:AX = new file position
	jnb     short LSeekSetpos
	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;jmp	SYS_RET_ERR
;LSeekError3:
	; 17/12/2022
LSeekError:
	;jmp	short LSeekError2
DupErr:	; 17/12/2022
	jmp	SYS_RET_ERR

;BREAK <FileTimes - modify write times on a handle>
;----------------------------------------------------------------------------
;
;   Assembler usage:
;	    MOV AH, FileTimes (57H)
;	    MOV AL, func
;	    MOV BX, handle
;	; if AL = 1 then then next two are mandatory
;	    MOV CX, time
;	    MOV DX, date
;	    INT 21h
;	; if AL = 0 then CX/DX has the last write time/date
;	; for the handle.
;
;	AL=02		 get extended attributes
;	   BX=handle
;	   CX=size of buffer (0, return max size )
;	   DS:SI query list (si=-1, selects all EA)
;	   ES:DI buffer to hold EA list
;
;	AL=03		 get EA name list
;	   BX=handle
;	   CX=size of buffer (0, return max size )
;	   ES:DI buffer to hold name list
;
;	AL=04		 set extended attributes
;	   BX=handle
;	   ES:DI buffer of EA list
;
;
;   Error returns:
;	    AX = error_invalid_function
;	       = error_invalid_handle
;
;----------------------------------------------------------------------------

; 21/05/2019 - Retro DOS v4.0
; DOSCODE:A90Dh (MSDOS 6.21, MSDOS.SYS)

; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:A8ADh (MSDOS 5.0 MSDOS.SYS)

_$FILE_TIMES:
	; 13/07/2018 - Retro DOS v3.0

	; MSDOS 3.3
	;cmp	al,2			; correct subfunction ?
	;jb	short ft1

	;;mov	byte [ss:EXTERR_LOCUS], 1
	;mov	byte [ss:EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus
						;SS Overr
	;;mov	al,1
	;mov	al,error_invalid_function ; give bad return
	;jmp	SYS_RET_ERR

	; MSDOS 6.0
	cmp	al,2			; correct subfunction ?
	jae	short inval_func
;ft1:
	call	CheckOwner		; get sft
	; 17/12/2022
	jc	short LSeekError	; bad handle

	or	al,al			; get time/date ?
	jnz	short ft_set_time

;------ here we get the time & date from the sft for the user

	cli				; is this cli/sti reqd ? BUGBUG
	;mov	cx,[es:di+13]
	mov	cx,[es:di+SF_ENTRY.sf_time] ; get the time
	;mov	dx,[es:di+15]
	mov	dx,[es:di+SF_ENTRY.sf_date] ;  & date
	sti
	call	Get_User_Stack
	;mov	[si+4],cx
	mov	[si+user_env.user_CX],cx
	;mov	[si+6],dx
	mov	[si+user_env.user_DX],dx
	jmp	short ok_ret

;------ here we set the time in sft

ft_set_time:
	call    ECritSFT
	;mov	[es:di+13],cx
	mov	[es:di+SF_ENTRY.sf_time],cx ; drop in new time
	;mov	[es:di+15],dx
	mov	[es:di+SF_ENTRY.sf_date],dx ;  and date	

	xor	ax, ax
	call	far [ss:JShare+(14*4)] ; 14 = ShSU	; SS Override

;------ set the flags in SFT entry
	;and	word [es:di+5],0FFBFh
	; 18/12/2022
	;and	byte [es:di+5],0BFh
	and	byte [es:di+SF_ENTRY.sf_flags],~devid_file_clean
	;and	word [es:di+SF_ENTRY.sf_flags],~devid_file_clean 
							; mark file as dirty
	;or	word [es:di+5],4000h
	; 17/12/2022
	;or	byte [es:di+6],40h
	or	byte [es:di+SF_ENTRY.sf_flags+1],(sf_close_nodate>>8)
	;or	word [es:di+SF_ENTRY.sf_flags],sf_close_nodate
							; ask close not to
							;   bother about date
							;   and time
	call	LCritSFT
ok_ret:
	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	; 17/12/2022
	jmp	SYS_RET_OK
	;jmp	short LSeekOk

inval_func:
	;mov	byte [ss:EXTERR_LOCUS],1
	mov	byte [ss:EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus
						;SS Overr
	;mov	al,1
	mov	al,error_invalid_function ; give bad return
	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
ft_error:
	;;jmp	SYS_RET_ERR
	;jmp	short LSeekError3
	; 17/12/2022
	jmp	short LSeekError

; 21/05/2019 - Retro DOS v4.0
; DOSCODE:A95Bh (MSDOS 6.21, MSDOS.SYS)

; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:A8FBh (MSDOS 5.0 MSDOS.SYS)

;BREAK <$DUP - duplicate a jfn>
;----------------------------------------------------------------------------
;
;   Assembler usage:
;	    MOV     BX, fh
;	    MOV     AH, Dup
;	    INT     int_command
;	  AX has the returned handle
;   Errors:
;	    AX = dup_invalid_handle
;	       = dup_too_many_open_files
;
;----------------------------------------------------------------------------

_$DUP:
	MOV	AX,BX			; save away old handle in AX
	call	JFNFree 		; free handle? into ES:DI, new in BX
DupErrorCheck:
	JC	short DupErr		; nope, bye
	push	es
	push	di			; save away SFT
	pop	si			; into convenient place DS:SI
	pop	ds
	XCHG	AX,BX			; get back old handle
	call	CheckOwner		; get sft in ES:DI
	JC	short DupErr		; errors go home
	call	DOS_Dup_Direct
	call	pJFNFromHandle		; get pointer
	MOV	BL,[ES:DI]		; get SFT number
	MOV	[SI],BL			; stuff in new SFT
	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;jmp	SYS_RET_OK		; and go home
	jmp	short ok_ret

	; 17/12/2022
;DupErr:
	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;;jmp	SYS_RET_ERR
	;jmp	short ft_error

;BREAK <$DUP2 - force a dup on a particular jfn>
;----------------------------------------------------------------------------
;
;   Assembler usage:
;	    MOV     BX, fh
;	    MOV     CX, newfh
;	    MOV     AH, Dup2
;	    INT     int_command
;   Error returns:
;	    AX = error_invalid_handle
;
;----------------------------------------------------------------------------

_$DUP2:
	push	bx
	push	cx			; save source
	MOV	BX,CX			; get one to close
	call	_$CLOSE			; close destination handle
	pop	bx
	pop	ax			; old in AX, new in BX
	call	pJFNFromHandle		; get pointer
	JMP	short DupErrorCheck	; check error and do dup

;Break	<CheckOwner - verify ownership of handles from server>
;----------------------------------------------------------------------------
;   CheckOwner - Due to the ability of the server to close file handles for a
;   process without the process knowing it (delete/rename of open files, for
;   example), it is possible for the redirector to issue a call to a handle
;   that it soes not rightfully own. We check here to make sure that the
;   issuing process is the owner of the SFT. At the same time, we do a
;   SFFromHandle to really make sure that the SFT is good.
;
;	ENTRY	BX has the handle
;		User_ID is the current user
;	EXIT	Carry Clear => ES:DI points to SFT
;		Carry Set => AX has error code
;	USES	none
;----------------------------------------------------------------------------

	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; 21/05/2019 - Retro DOS v4.0
CheckOwner:
	; 13/07/2018 - Retro DOS v3.0

	call	SFFromHandle
	jc	short co_ret_label	; retc

	push	ax

	; MSDOS 6.0

;SR; WIN386 patch - Do not check for USER_ID for using handles since these 
;SR; are shared across multiple VMs in win386.

	test	byte [ss:IsWin386],1 ; 02/06/2019
	jz	short no_win386		;win386 is not present
	xor	ax,ax			;set the zero flag
	jmp	short _skip_win386	

no_win386:
	mov	ax,[SS:USER_ID]		;smr;SS Override
	;cmp	ax,[es:di+47]
	cmp	ax,[es:di+SF_ENTRY.sf_UID]

_skip_win386:
	pop	ax
	
	; 17/12/2022
	jz	short co_ret_label
	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;jnz	short CheckOwner_err
	;retn
	
CheckOwner_err:
	;mov	al,6
	mov	al,error_invalid_handle
	stc

co_ret_label:
	retn

;============================================================================
; MACRO.ASM, MSDOS 6.0, 1991
;============================================================================
; Retro	DOS v3.0 - 11/07/2018
; 21/05/2019 - Retro DOS v4.0

;	TITLE	MACRO - Pathname and macro related internal routines
;	NAME	MACRO

;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.

;**	MACRO.ASM
;
;	$AssignOper
;	FIND_DPB
;	InitCDS
;	$UserOper
;	GetVisDrv
;	GetThisDrv
;	GetCDSFromDrv
;
;   Revision history:
;
;	Created: MZ 4 April 1983
;		 MZ 18 April 1983   Make TransFCB handle extended FCBs
;		 AR 2 June 1983     Define/Delete macro for NET redir.
;		 MZ 3 Nov 83	    Fix InitCDS to reset length to 2
;		 MZ 4 Nov 83	    Fix NetAssign to use STRLEN only
;		 MZ 18 Nov 83	    Rewrite string processing for subtree
;				    aliasing.
;
;   MSDOS performs several types of name translation. First, we maintain for
;   each valid drive letter the text of the current directory on that drive.
;   For invalid drive letters, there is no current directory so we pretend to
;   be at the root. A current directory is either the raw local directory
;   (consisting of drive:\path) or a local network directory (consisting of
;   \\machine\path. There is a limit on the point to which a .. is allowed.
;
;   Given a path, MSDOS will transform this into a real from-the-root path
;   without . or .. entries. Any component that is > 8.3 is truncated to
;   this and all * are expanded into ?'s.
;
;   The second part of name translation involves subtree aliasing. A list of
;   subtree pairs is maintained by the external utility SUBST. The results of
;   the previous 'canonicalization' are then examined to see if any of the
;   subtree pairs is a prefix of the user path. If so, then this prefix is
;   replaced with the other subtree in the pair.
;
;   A third part involves mapping this "real" path into a "physical" path.  A
;   list of drive/subtree pairs are maintained by the external utility JOIN.
;   The output of the previous translation is examined to see if any of the
;   subtrees in this list are a prefix of the string. If so, then the prefix
;   is replaced by the appropriate drive letter. In this manner, we can
;   'mount' one device under another.
;
;   The final form of name translation involves the mapping of a user's
;   logical drive number into the internal physical drive. This is
;   accomplished by converting the drive number into letter:CON, performing
;   the above translation and then converting the character back into a drive
;   number.
;
;   There are two main entry points: TransPath and TransFCB. TransPath will
;   take a path and form the real text of the pathname with all . and ..
;   removed. TransFCB will translate an FCB into a path and then invoke
;   TransPath.
;
;	A000	version 4.00  Jan. 1988

;Installed = TRUE

;	I_need	ThisCDS,DWORD		; pointer to CDS used
;	I_need	CDSAddr,DWORD		; pointer to CDS table
;	I_need	CDSCount,BYTE		; number of CDS entries
;	I_need	CurDrv,BYTE		; current macro assignment (old
;					; current drive)
;	I_need	NUMIO,BYTE		; Number of physical drives
;	I_need	fSharing,BYTE		; TRUE => no redirection allowed
;	I_need	DummyCDS,80h		; buffer for dummy cds
;	I_need	DIFFNAM,BYTE		; flag for MyName being set
;	I_need	MYNAME,16		; machine name
;	I_need	MYNUM,WORD		; machine number
;	I_need	DPBHEAD,DWORD		; beginning of DPB chain
;	I_need	EXTERR_LOCUS,BYTE	; Extended Error Locus
;	I_need	DrvErr,BYTE		; drive error

;BREAK <$AssignOper -- Set up a Macro>
;----------------------------------------------------------------------------
; Inputs:
;	AL = 00 get assign mode 		    (ReturnMode)
;	AL = 01 set assign mode 		    (SetMode)
;	AL = 02 get attach list entry		    (GetAsgList)
;	AL = 03 Define Macro (attch start)
;	    BL = Macro type
;	       = 0 alias
;	       = 1 file/device
;	       = 2 drive
;	       = 3 Char device -> network
;	       = 4 File device -> network
;	    DS:SI -> ASCIZ source name
;	    ES:DI -> ASCIZ destination name
;	AL = 04 Cancel Macro
;	    DS:SI -> ASCIZ source name
;	AL = 05 Modified get attach list entry
;	AL = 06 Get ifsfunc item
;	AL = 07 set in_use of a drive's CDS
;	     DL = drive number, 0=default  0=A,,
;	AL = 08 reset in_use of a drive's CDS
;	     DL = drive number, 0=A, 1=B,,,
; Function:
;	Do macro stuff
; Returns:
;	Std Xenix style error return
;----------------------------------------------------------------------------

	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; 21/05/2019 - Retro DOS v4.0
_$AssignOper:
	; MSDOS 6.0
	CMP	AL,7			      ; set in_use ?		;AN000;
	JNZ	short chk08		      ; no			;AN000;
srinuse:								;AN000;
	PUSH	AX			      ; save al 		;AN000;
	MOV	AL,DL			      ; AL= drive id		;AN000;
	CALL	GetCDSFromDrv		      ; ds:si -> cds		;AN000;
	POP	AX			      ; 			;AN000;
	JC	short baddrv		      ; bad drive		;AN000;
	;cmp	word [si+45h],0
	CMP	WORD [SI+curdir.devptr],0     ; dpb ptr =0 ?		;AN000;
	JZ	short baddrv		      ;     no			;AN000;
	CMP	AL,7			      ; set ?			;AN000;
	JNZ	short resetdrv		      ; no			;AN000;
	;or	word [si+43h],4000h
	; 17/12/2022
	;or	byte [si+44h],40h
	or	byte [SI+curdir.flags+1],(curdir_inuse>>8)
	;OR	word [SI+curdir.flags],curdir_inuse ; set in_use	;AN000;
	JMP	SHORT okdone		      ; 			;AN000;
resetdrv:
	;and	word [si+43h],0BFFFh									;AN000;
	; 18/12/2022
	and	byte [SI+curdir.flags+1],0BFh ; (~curdir_inuse)>>8
	;AND	word [SI+curdir.flags],~curdir_inuse ; reset in_use	;AN000;
	JMP	SHORT okdone		      ; 			;AN000;

	; 17/12/2022
baddrv: 								;AN000;
	MOV	AX,error_invalid_drive	      ; error			;AN000;

	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;JMP	SHORT ASS_ERR		      ; 			;AN000;
	; 17/12/2022
	; 21/05/2019
ASS_ERR:
	jmp	SYS_RET_ERR

chk08:									;AN000;
	CMP	AL,8			      ; reset inuse ?		;AN000;
	JZ	short srinuse 		      ; yes			;AN000;

  ;IF	NOT INSTALLED
	;transfer NET_ASSOPER
  ;ELSE
	; MSDOS 3.3 (& MSDOS 6.0)
	PUSH	AX
	;mov	ax,111Eh
	;MOV	AX,(MultNET SHL 8) OR 30
	mov	ax,(MultNET*256)+30
	int     2Fh	; Multiplex - NETWORK REDIRECTOR - DO REDIRECTION
			; SS = DOS CS
			; STACK: WORD function to execute
			; Return: CF set on error, AX = error code
			; STACK unchanged
	POP	BX			; Don't zap error code in AX
	JC	short ASS_ERR
okdone:
	jmp	SYS_RET_OK

	; 17/12/2022
	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
;ASS_ERR:
	;jmp	SYS_RET_ERR

  ;ENDIF

;Break <FIND_DPB - Find a DPB from a drive number>
;----------------------------------------------------------------------------
;**	FIND_DPB - Find a DPB from a Drive #
;
;	ENTRY	AL has drive number A = 0
;	EXIT	'C' set
;		    No DPB for this drive number
;		'C' clear
;		    DS:SI points to DPB for drive
;	USES	SI, DS, Flags
;----------------------------------------------------------------------------

	; 21/05/2019 - Retro DOS v4.0
FIND_DPB:
	LDS	SI,[SS:DPBHEAD]		;smr;SS Override
fdpb5:	
	CMP	SI,-1
	JZ	short fdpb10
	cmp	al,[si]
	;CMP	AL,[SI+DPB.DRIVE]
	jz	short ret_label15	; Carry clear (retz)
	;;lds	si,[si+18h] ; MSDOS 3.3
	;lds	si,[si+19h] ; MSDOS 6.0
	LDS	SI,[SI+DPB.NEXT_DPB]
	JMP	short fdpb5
fdpb10:	
	STC
ret_label15:
	retn

;	Break <InitCDS - set up an empty CDS>
;----------------------------------------------------------------------------
;**	InitCDS - Setup an Empty CDS
;
;	ENTRY	ThisCDS points to CDS
;		AL has uppercase drive letter
;	EXIT	ThisCDS is now empty
;		(ES:DI) = CDS
;		'C' set if no DPB associated with drive
;	USES	AH,ES,DI, Flags
;----------------------------------------------------------------------------

; 21/05/2019 - Retro DOS v4.0
; DOSCODE:A9FDh (MSDOS 6.21, MSDOS.SYS)

; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:A99Dh (MSDOS 5.0, MSDOS.SYS)

InitCDS:
	; 19/08/2018
	; 05/08/2018 - Retro DOS v3.0
	; MSDOS 6.0
	push	ax			; save (AL) for caller
	LES	DI,[SS:THISCDS]		; (es:di) = CDS address
	;mov	word [es:di+67],0
	MOV	word [ES:DI+curdir.flags],0 ; "free" CDS
	SUB	AL,"A"-1                ; A = 1
	CMP	[SS:NUMIO],AL		;smr;SS Override
	JC	short icdsx		; Drive does not map a physical drive
	dec	ax			; (AL) = 0 if A, 1 if B, etc.
	PUSH	AX			; save drive number for later
	add	al,"A"
	MOV	AH,':'
	mov	[ES:DI],ax
	;MOV	[ES:DI+curdir.text],AX 	; set "x:"
	;mov	ax,"\"
	;mov	[es:di+2],ax
	;MOV	word [ES:DI+curdir.text+2],"\"	; NUL terminate
	mov	word [ES:DI+curdir.text+2],005Ch ; 19/08/2018
	;or	word [es:di+67],4000h
	;or	byte [es:di+68],40h
	OR	byte [ES:DI+curdir.flags+1],(curdir_inuse>>8)
	sub	ax,ax
	;MOV	[es:di+73],ax ; 0
	MOV	[ES:DI+curdir.ID],ax
	;mov	[es:di+75],ax ; 0
	MOV	[ES:DI+curdir.ID+2],ax
	mov	al,2
	;mov	[es:di+79],aX ; 2
	MOV	[ES:DI+curdir.end],ax
	POP	AX			; (al) = drive number
	push	ds
	push	si
	call	FIND_DPB
	JC	short icds5		; OOOOPPPPPSSSS!!!!
	;mov	[es:di+69],si
	MOV	[ES:DI+curdir.devptr],SI
	;mov	[es:di+71],ds
	MOV	[ES:DI+curdir.devptr+2],DS
icds5:	
	pop	si
	pop	ds
icdsx:	
	pop	ax
RET45:
	retn

;Break <$UserOper - get/set current user ID (for net)>
;----------------------------------------------------------------------------
;   $UserOper - retrieve or initiate a user id string.	MSDOS will only
;	maintain this string and do no verifications.
;
;   Inputs:	AL has function type (0-get 1-set 2-printer-set 3-printer-get
;				      4-printer-set-flags,5-printer-get-flags)
;		DS:DX is user string pointer (calls 1,2)
;		ES:DI is user buffer (call 3)
;		BX is assign index (calls 2,3,4,5)
;		CX is user number (call 1)
;		DX is flag word (call 4)
;   Outputs:	If AL = 0 then the current user string is written to DS:DX
;			and user CX is set to the user number
;		If AL = 3 then CX bytes have been put at input ES:DI
;		If AL = 5 then DX is flag word
;----------------------------------------------------------------------------

	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; 21/05/2019 - Retro DOS v4.0
_$UserOper:
	; 05/08/2018 - Retro DOS v3.0
	; MSDOS 6.0 (& MSDOS 3.3)
	PUSH	AX
	SUB	AL,1			; quick dispatch on 0,1
	POP	AX
	JB	short UserGet 		; return to user the string
	JZ	short UserSet 		; set the current user
	CMP	AL,5			; test for 2,3,4 or 5
	JBE	short UserPrint		; yep
	;mov	byte [ss:EXTERR_LOCUS],1
	MOV	byte [SS:EXTERR_LOCUS],errLOC_Unk ;smr;SS Override 
					; Extended Error Locus
	;error	error_invalid_function	; not 0,1,2,3
	;mov	al,1
	MOV	AL,error_invalid_function
useroper_error:
	; 17/12/2022
	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	JMP	SYS_RET_ERR
	;jmp	short ASS_ERR

UserGet:
; Transfer MYNAME to DS:DX
; Set Return CX to MYNUM
	PUSH	DS			; switch registers
	POP	ES
	MOV	DI,DX			; destination
	MOV	CX,[SS:MYNUM]		; Get number	;smr;SS Override
	call	Get_User_Stack
	;mov	[si+4],cx
	MOV	[SI+user_env.user_CX],CX ; Set number return
	push	ss			; point to DOSDATA
	pop	ds
	MOV	SI,MYNAME		; point source to user string
UserMove:
	MOV	CX,15
	REP	MOVSB			; blam.
	XOR	AX,AX			; 16th byte is 0
	STOSB
UserBye:
	jmp	SYS_RET_OK		; no errors here

UserSet:
; Transfer DS:DX to MYNAME
; CX to MYNUM
	MOV	[SS:MYNUM],CX				;smr;SS Override
	MOV	SI,DX			; user space has source
	push	ss
	pop	es
	MOV	DI,MYNAME		; point dest to user string
	INC	byte [SS:DIFFNAM]	; signal change ;smr;SS Override
	JMP	short UserMove

UserPrint:

  ;IF NOT Installed
  ;	transfer PRINTER_GETSET_STRING
  ;ELSE
	PUSH	AX
	;mov	ax,111Fh
	;MOV	AX,(MultNET SHL 8) OR 31
	mov	ax,(MultNET<<8)|31
	int     2Fh	; Multiplex - NETWORK REDIRECTOR - PRINTER SETUP
			; STACK: WORD function
			; Return: CF set on error, AX = error code
			; STACK unchanged
	POP	DX			; Clean stack
	;JNC	short OKPA
	jnc	short UserBye ; 21/05/2019
	; 17/12/2022
	jmp	short useroper_error
	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;jnb     short OKPA
	;jmp     short useroper_error

	; 17/12/2022
;OKPA:
;	jmp	short UserBye

  ;ENDIF


;Break	<GetVisDrv - return visible drive>
;----------------------------------------------------------------------------
;   GetVisDrv - correctly map non-spliced inuse drives
;
;   Inputs:	AL has drive identifier (0=default)
;   Outputs:	Carry Set - invalid drive/macro
;		Carry Clear - AL has physical drive (0=A)
;		    ThisCDS points to CDS
;   Registers modified: AL
;----------------------------------------------------------------------------

	; 21/05/2019 - Retro DOS v4.0
	; DOSCODE:AA9Fh (MSDOS 6.21, MSDOS.SYS)

	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; DOSCODE:AA3Fh (MSDOS 5.0, MSDOS.SYS)	
GetVisDrv:
	; 05/08/2018 - Retro DOS v3.0
	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 6839h
	CALL	GETTHISDRV		; get inuse drive
	jc	short RET45
	push	ds
	push	si
	LDS	SI,[SS:THISCDS]		;smr;SS Override
	;test	word [si+67],2000h
	; 17/12/2022
	;test	byte [si+68],20h
	test	byte [SI+curdir.flags+1],(curdir_splice>>8)
	;TEST	word [SI+curdir.flags],curdir_splice
	pop	si
	pop	ds
	jz	short RET45		; if not spliced, return OK
	; MSDOS 6.0
	;mov	byte [ss:DrvErr],0Fh
	MOV	byte [SS:DrvErr],error_invalid_drive ;IFS. ;AN000;smr;SS Override
	STC				; signal error
	retn

;Break <Getthisdrv - map a drive designator (0=def, 1=A...)>
;----------------------------------------------------------------------------
;   GetThisDrv - look through a set of macros and return the current drive and
;	macro pointer
;
;   Inputs:	AL has drive identifier (1=A, 0=default)
;   Outputs:
;		Carry Set - invalid drive/macro
;		Carry Clear - AL has physical drive (0=A)
;		   ThisCDS points to macro
;   Registers modified: AL
;----------------------------------------------------------------------------

	; 21/05/2019 - Retro DOS v4.0
	; DOSCODE:AABCh (MSDOS 6.21, MSDOS.SYS)

	; 02/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; DOSCODE:AA5Ch (MSDOS 5.0, MSDOS.SYS)	
GETTHISDRV:
	; 05/08/2018
	; 12/07/2018 - Retro DOS v3.0
	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 6850h
	; MSDOS 3.3 (& MSDOS 6.0)
	OR	AL,AL			; are we using default drive?
	JNZ	SHORT GTD10		; no, go get the CDS pointers
	MOV	AL,[SS:CURDRV]		; get the current drive
	;INC	ax			; Counteract next instruction
	; 04/09/2018
	;inc	al
	; 07/12/2022
	inc	ax
GTD10:	
	;DEC	AX
	; 02/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	dec	ax			; 0 = A
	;dec	al
	PUSH	DS			; save world
	PUSH	SI
	;mov	byte [ss:EXTERR_LOCUS],2
	MOV	BYTE [SS:EXTERR_LOCUS],errLOC_Disk		;smr;SS Override
	TEST	BYTE [SS:FSHARING],-1	; Logical or Physical?	;smr;SS Override
	JZ	SHORT GTD20		; Logical
	PUSH	AX
	PUSH	ES
	PUSH	DI
	MOV	WORD [SS:THISCDS],DUMMYCDS ;smr;SS Override
	;mov	[SS:THISCDS+2],CS ; MSDOS 3.3
	MOV	[SS:THISCDS+2],SS ; MSDOS 6.0 ;ThisCDS = &DummyCDS;smr;
	ADD	AL,'A'
	CALL	InitCDS			; InitCDS(c);
	;test	word [es:di+67],4000h
	; 17/12/2022
	;test	byte [es:di+68],40h
	test	byte [ES:DI+curdir.flags+1],(curdir_inuse>>8)
	;TEST	WORD [ES:DI+curdir.flags],curdir_inuse	; Clears carry
	POP	DI
	POP	ES
	POP	AX
	JZ	SHORT GTD30		; Not a physical drive.
	JMP	SHORT GTDX		; carry clear
GTD20:
	CALL	GetCDSFromDrv
	JC	SHORT GTD30	; Unassigned CDS -> return error already set
	;test	word [si+43h],4000h
	; 17/12/2022
	;test	byte [si+44h],40h
	test	byte [SI+curdir.flags+1],(curdir_inuse>>8)
	;TEST	WORD [SI+curdir.flags],curdir_inuse ; Clears Carry
	JNZ	SHORT GTDX		; carry clear
GTD30:	
	; 21/05/2019
	; MSDOS 6.0
	MOV	AL,error_invalid_drive	; invalid FAT drive
	MOV	BYTE [ss:DrvErr],AL	; save this for IOCTL
	; MSDOS 3.3 (.& MSDOS 6.0)
	MOV	BYTE [ss:EXTERR_LOCUS],errLOC_Unk
	STC
GTDX:	
	POP	SI			; restore world
	POP	DS
	RETN
 

;Break <GetCDSFromDrv - convert a drive number to a CDS pointer>
;----------------------------------------------------------------------------
;   GetCDSFromDrv - given a physical drive number, convert it to a CDS
;	pointer, returning an error if the drive number is greater than the
;	number of CDS's
;
;   Inputs:	AL is physical unit # A=0...
;   Outputs:	Carry Set if Bad Drive
;		Carry Clear
;		    DS:SI -> CDS
;		    [THISCDS] = DS:SI
;   Registers modified: DS,SI
;----------------------------------------------------------------------------

	; 21/05/2019 - Retro DOS v4.0
GetCDSFromDrv:
	CMP	AL,[SS:CDSCOUNT]	; is this a valid designator;smr;SS Override
	;JB	SHORT GetCDS	; cf=1	; yes, go get the macro
	;STC				; signal error
	;RETN				; bye
	; 23/09/2023
	cmc	; cf=1 <-> cf=0
	jc	short GetCDS_retn
GetCDS:
	; 23/09/2023
	;PUSH	BX
	PUSH	AX
	LDS	SI,[SS:CDSADDR]		; get pointer to table	;smr;SS Override
	;mov	bl,81 ; MSDOS 3.3
	;mov	bl,88 ; MSDOS 6.0 
	; 23/09/2023
	;MOV	BL,curdir.size		; size in convenient spot
	;MUL	BL			; get net offset
	mov	ah,curdir.size
	mul	ah
	ADD	SI,AX ; *		; convert to true pointer
	MOV	[SS:THISCDS],SI		; store convenient offset;smr;SS Override
	MOV	[SS:THISCDS+2],DS	; store convenient segment;smr;SS Override
	POP	AX
	; 23/09/2023
	;POP	BX
	; (cf must be 0 here) ; *
	;CLC				; no error
GetCDS_retn:
	RETN				; bye!

;============================================================================
; MACRO2.ASM, MSDOS 6.0, 1991
;============================================================================
; Retro	DOS v3.0 - 12/07/2018
; 22/05/2019 - Retro DOS v4.0

;BREAK <TransFCB - convert an FCB into a path, doing substitution>
;----------------------------------------------------------------------------
;   TransFCB - Copy an FCB from DS:DX into a reserved area doing all of the
;       gritty substitution.
;
;   Inputs:     DS:DX - pointer to FCB
;               ES:DI - point to destination
;   Outputs:    Carry Set - invalid path in final map
;               Carry Clear - FCB has been mapped into ES:DI
;                   Sattrib is set from possibly extended FCB
;                   ExtFCB set if extended FCB found
;   Registers modified: most
;----------------------------------------------------------------------------

	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
TransFCB:
	; 22/05/2019 - Retro DOS v4.0
	; 12/07/2018 - Retro DOS v3.0
	;LocalVar FCBTmp,16
	;ENTER
	push	bp
	mov	bp,sp
	;sub	sp,15	; MSDOS 3.3
	sub	sp,16	; MSDOS 6.0
	push	ss
	pop	es
	push	es
	push	di
	;lea	di,[bp-15] ; MSDOS 3.3
	;LEA	DI,FCBTmp 
	lea	di,[bp-16]		; point to FCB temp area
	mov	byte [SS:EXTFCB],0	; no extended FCB found ;smr;SS Override
	mov	byte [SS:SATTRIB],0	; default search attributes;smr;SS Override
	call	GetExtended             ; get FCB, extended or not
	; 06/12/2022
	jz	short GetDrive		; not an extended FCB, get drive
	mov	AL,[SI-1]               ; get attributes
	mov	[SS:SATTRIB],AL		; store search attributes;smr;SS Override
	mov	byte [SS:EXTFCB],-1	; signal extended FCB  ;smr;SS Override
GetDrive:
	lodsb				; get drive byte
	call	GETTHISDRV
	jc	short BadPack
	call	TextFromDrive           ; convert 0-based drive to text

; Scan the source to see if there are any illegal chars

	;mov	bx,CharType		; load lookup table
	mov	cx,11
	push	si			; back over name, ext
FCBScan:
	lodsb				; get a byte
	
	; 09/08/2018
	;;xlat	byte [es:bx]
	;es	xlat

	; 22/05/2019 - Retro DOS v4.0	
	call	GetCharType		; get flags

	;test	al,8	
	test	al,FFCB
	jz	short BadPack
NextCh: 
	loop	FCBScan
	pop	si
	mov	bx,di
	call	PackName                ; crunch the path
	pop	di			; get original destination
	pop	es
	push	ss			; get DS addressability
	pop	ds
	;lea	si,[bp-15] ; MSDOS 3.3
	;LEA	SI,FCBTmp		; point at new pathname
	lea	si,[bp-16]
	cmp	byte [bx],0
	jz	short BadPack
	push	bp
	call	TransPathSet            ; convert the path
	pop	bp
	jnc	short FCBRet		; bye with transPath error code
BadPack:
	STC
	;mov	al,3
	MOV     AL,error_path_not_found
FCBRet: 
	;LEAVE
	mov	sp,bp
	pop	bp
TransPath_retn:
	retn

; 12/07/2018 - Retro DOS v3.0

;BREAK <TransPath - copy a path, do string sub and put in current dir>
;----------------------------------------------------------------------------
;
;   TransPath - copy a path from DS:SI to ES:DI, performing component string
;       substitution, insertion of current directory and fixing . and ..
;       entries. Perform splicing. Allow input string to match splice
;       exactly.
;
;   TransPathSet - Same as above except No splicing is performed if input path
;       matches splice.
;
;   TransPathNoSet - No splicing/local using is performed at all.
;
;   The following anomalous behaviour is required:
;
;       Drive letters on devices are ignored. (set up DummyCDS)
;       Paths on devices are ignored. (truncate to 0-length)
;       Raw net I/O sets ThisCDS => NULL.
;       fSharing => dummyCDS and no subst/splice. Only canonicalize.
;
;   Other behaviour:
;
;       ThisCDS set up.
;       FatRead done on local CDS.
;       ValidateCDS done on local CDS.
;
;   Brief flowchart:
;
;       if fSharing then
;           set up DummyCDS (ThisCDS)
;           canonicalize (sets cMeta)
;           splice
;           fatRead
;           return
;       if \\ or d:\\ lead then
;           set up null CDS (ThisCDS)
;           canonicalize (sets cMeta)
;           return
;       if device then
;           set up dummyCDS (ThisCDS)
;           canonicalize (sets cMeta)
;           return
;       if file then
;           getCDS (sets (ThisCDS) from name)
;           validateCDS (may reset current dir)
;           Copy current dir
;           canonicalize (set cMeta)
;           splice
;           generate correct CDS (ThisCDS)
;           if local then
;               fatread
;           return
;
;   Inputs:     DS:SI - point to ASCIZ string path
;               DI - point to buffer in DOSDATA
;   Outputs:    Carry Set - invalid path specification: too many .., bad
;                   syntax, etc. or user FAILed to I 24.
;               WFP_Start - points to beginning of buffer
;               Curr_Dir_End - points to end of current dir in path
;               DS - DOSDATA
;   Registers modified: most
;
;----------------------------------------------------------------------------

; 22/05/2019
; 13/05/2019 - Retro DOS v4.0
; DOSCODE:AB99h (MSDOS 6.21, MSDOS.SYS)

; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:AB39h (MSDOS 5.0, MSDOS.SYS)

TransPath:
	XOR     AL,AL
	JMP     SHORT SetSplice
TransPathSet:
	MOV     AL,-1
SetSplice:
	MOV	[SS:NoSetDir],AL	;   NoSetDir = !fExact; ;smr;SS Override
	MOV     AL,-1
TransPathNoSet:
	MOV	[SS:FSPLICE],AL		;   fSplice = TRUE;     ;smr;SS Override
	MOV	byte [ss:CMETA],-1      			;smr;SS Override
	MOV     [SS:WFP_START],DI 				;smr;SS Override
	MOV	word [SS:CURR_DIR_END],-1 ; crack from start	;smr;SS Override
	push	ss
	pop	es
	;lea	bp,[di+134]
	LEA     BP,[DI+TEMPLEN]         ; end of buffer
;
; if this is through the server dos call, fsharing is set. We set up a
; dummy cds and let the operation go.
;
	TEST	byte [SS:FSHARING],-1	; if no sharing		;smr;SS Override
	JZ	short CheckUNC		; skip to UNC check
;
; ES:DI point to buffer
;
	CALL	DriveFromText           ; get drive and advance DS:SI
	call	GETTHISDRV              ; Set ThisCDS and convert to 0-based
	jc	short NoPath
	CALL	TextFromDrive		; drop in new
	LEA	BX,[DI+1]               ; backup limit
	CALL	Canonicalize            ; copy and canonicalize
	jc	short TransPath_retn	; errors
;
; Perform splices for net guys.
;
	push	ss
	pop	ds
	MOV     SI,[WFP_START] 		; point to name
	TEST	byte [FSPLICE],-1
	JZ	short NoServerSplice
	CALL    Splice
NoServerSplice:
	push	ss
	pop	ds                      ; for FATREAD
	LES     DI,[THISCDS]		; for fatread
	call	ECritDisk
	call	FATREAD_CDS
	call	LCritDisk
NoPath:
	;mov	al,3
	MOV     AL,error_path_not_found ; Set up for possible bad path error
	retn				; any errors are in Carry flag

; Let the network decide if the name is for a spooled device. It will map
; the name if so.

CheckUNC:
	MOV     WORD [SS:THISCDS],-1	; NULL thisCDS		;smr;SS Override
	;CallInstall NetSpoolCheck,MultNET,35
	mov	ax,1123h
	int	2Fh	; Multiplex - NETWORK REDIRECTOR - QUALIFY REMOTE FILENAME
			; DS:SI -> ASCIZ filename to canonicalize
			; ES:DI -> 128-byte buffer for qualified name
			; Return: CF set if not resolved
	JNC	short UNCDone

; At this point the name is either a UNC-style name (prefixed with two leading
; \\s) or is a local file/device. Remember that if a net-spooled device was
; input, then the name has been changed to the remote spooler by the above net
; call. Also, there may be a drive in front of the \\.

NO_CHECK:
	CALL    DriveFromText		; eat drive letter
	PUSH    AX                      ; save it
	MOV     AX,[SI]			; get first two bytes of path
	call    PATHCHRCMP              ; convert to normal form
	XCHG    AH,AL                   ; swap for second byte
	call    PATHCHRCMP              ; convert to normal form
	JNZ	short CheckDevice	; not a path char
	CMP     AH,AL                   ; are they same?
	JNZ	short CheckDevice	; nope

; We have a UNC request. We must copy the string up to the beginning of the
; local machine root path

	POP     AX
	MOVSW                           ; get the lead \\.
UNCCpy:
	LODSB                           ; get a byte
 	call	UCase                   ;AN000;; convert the char
	OR      AL,AL
	JZ	short UNCTerm		; end of string. All done.
	call    PATHCHRCMP              ; is it a path char?
	MOV     BX,DI                   ; backup position
	STOSB
	JNZ	short UNCCpy		; no, go copy
	CALL    Canonicalize            ; wham (and set cMeta)
UNCDone:
	push	ss
	pop	ds
 	retn				; return error code
UNCTerm:
	STOSB                           ;AN000;
	JMP	short UNCDone		;AN000;

CheckDevice:

; Check DS:SI for device. First eat any path stuff

	POP     AX                      ; retrieve drive info
	CMP     BYTE [SI],0		; check for null file
	JNZ	short CheckPath
	;mov	al,2 
	MOV     AL,error_file_not_found ; bad file error
	STC                             ; signal error on null input
	RETN				; bye!
CheckPath:
	push	ax
	push	bp			; save drive number


; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
%if 0
	; MSDOS 6.0
;;;BUGBUG BUG 10-26-1992 scottq
;;;This is a hack for the CDROM extensions (2.1) who scan looking
;;;for the following POP BP == 5Dh (restore <bp,ax>).
;;;The problem is that a direct call to CheckThisDevice can (and did)
;;;end up having a 5D in the opcode's displacement field. The
;;;scanning code would choke on this thinking it was a POP BP instruction.
;;;
;;;What we do here is do a call to a function that is less than 5Dh
;;;bytes away (and assert its not exactly 5D away) that jmps (transfers)
;;;to the correct function. This cannot accidently insert a 5Dh.
;;;
;;;More info:
;;;  This particular scan is begun at the UNCdone label for 32 bytes
;;;looking for pop BP, so you cannot put a 5D between here and there.
;;;
	call	no5Dshere
start5Dhack:
;following is replaced with 5Dhack code--Invoke CheckThisDevice         
backfrom5Dhack:

%endif
	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	; Note: 'call no5Dshere' is not required for MSDOS 5.0 MSDOS.SYS
	call    CheckThisDevice	; E8h,6Fh,0D6h

	pop	bp
	pop	ax			; get drive letter back
	JNC	short DoFile		; yes we have a file.

; We have a device. AX has drive letter. At this point we may fake a CDS ala
; sharing DOS call. We know by getting here that we are NOT in a sharing DOS
; call.

	MOV	byte [SS:FSHARING],-1	; simulate sharing dos call;smr;SS Override
	call	GETTHISDRV              ; set ThisCDS and init DUMMYCDS
	MOV     byte [SS:FSHARING],0	;                       ;smr;SS Override

; Now that we have noted that we have a device, we put it into a form that
; getpath can understand. Normally getpath requires d:\ to begin the input
; string. We relax this to state that if the d:\ is present then the path
; may be a file. If D:/ (note the forward slash) is present then we have
; a device.

	CALL    TextFromDrive
	MOV     AL,'/'                  ; path sep.
	STOSB
	call	StrCpy			; move remainder of string

	CLC                             ; everything OK.
	push	ss
	pop	ds                      ; remainder of OK stuff
DoFile_retn:
	retn

; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
%if 0

no5Dshere:
	; 10/08/2018
	jmp	CheckThisDevice		; snoop for device
%endif

;.erre (no5Dshere - start5Dhack - 5D)

; We have a file. Get the raw CDS.

DoFile:
	; MSDOS 3.3 (& MSDOS 6.0)

	call	GetVisDrv               ; get proper CDS
	;mov	al,3 
	MOV     AL,error_path_not_found ; Set up for possible bad file error
	jc	short DoFile_retn  ; CARRY set -> bogus drive/spliced

; ThisCDS has correct CDS. DS:SI advanced to point to beginning of path/file.
; Make sure that CDS has valid directory; ValidateCDS requires a temp buffer
; Use the one that we are going to use (ES:DI).

	;SAVE    <DS,SI,ES,DI>		; save all string pointers.
	push	ds
	push	si
	push	es
	push	di
	call	ValidateCDS             ; poke CDS and make everything OK
	;RESTORE <DI,ES,SI,DS>		; get back pointers
	pop	di
	pop	es
	pop	si
	pop	ds
	;mov	al,3
	MOV     AL,error_path_not_found ; Set up for possible bad path error
	;retc				; someone failed an operation
	jc	short DoFile_retn

; ThisCDS points to correct CDS. It contains the correct text of the
; current directory. Copy it in.

	push	ds
	push	si
	LDS     SI,[SS:THISCDS]		; point to CDS	;smr;SS Override
	MOV     BX,DI                   ; point to destination
	;add	bx,[si+79] ; MSDOS 6.0
	ADD     BX,[SI+curdir.end]	; point to backup limit
	;lea	bp,[di+134]
	LEA     BP,[DI+TEMPLEN]         ; regenerate end of buffer
					;AN000;
	call	FStrCpy                 ; copy string. ES:DI point to end
	DEC     DI                      ; point to NUL byte

; Make sure that there is a path char at end.

	MOV     AL,'\'
	CMP     [ES:DI-1],AL
	JZ	short GetOrig
	STOSB

; Now get original string.

GetOrig:
	DEC     DI                      ; point to path char
	pop	si
	pop	ds

; BX points to the end of the root part of the CDS (at where a path char
; should be). Now, we decide whether we use this root or extend it with the
; current directory. See if the input string begins with a leading \

	CALL    PathSep                 ; is DS:SI a path sep?
	JNZ	short PathAssure	; no, DI is correct. Assure a path char
	OR      AL,AL                   ; end of string?
	JZ	short DoCanon		; yes, skip.
;
; The string does begin with a \. Reset the beginning of the canonicalization
; to this root. Make sure that there is a path char there and advance the
; source string over all leading \'s.
;
	MOV     DI,BX                   ; back up to root point.
SkipPath:
	LODSB
	call    PATHCHRCMP
	JZ	short SkipPath
	DEC     SI
	OR      AL,AL
	JZ	short DoCanon

; DS:SI start at some file name. ES:DI points at some path char. Drop one in
; for yucks.

PathAssure:
	MOV     AL,'\'	; 5Ch
	STOSB

; ES:DI point to the correct spot for canonicalization to begin.
; BP is the max extent to advance DI
; BX is the backup limit for ..

DoCanon:
	CALL    Canonicalize            ; wham.
	;retc				; badly formatted path.
	jc	short DoFile_retn

; The string has been moved to ES:DI. Reset world to DOS context, pointers
; to wfp_start and do string substitution. BP is still the max position in
; buffer.

	push	ss
	pop	ds
	MOV     DI,[WFP_START]		; DS:SI point to string
	LDS     SI,[THISCDS]		; point to CDS
	CALL    PathPref                ; is there a prefix?
	JNZ	short DoSplice		; no, do splice

; We have a match. Check to see if we ended in a path char.

	MOV     AL,[SI-1]		; last char to match
	call    PATHCHRCMP              ; did we end on a path char? (root)
	JZ	short DoSplice		; yes, no current dir here.
Pathline:                               ; 2/13/KK
	CMP     BYTE [ES:DI],0		; end at NUL?
	JZ	short DoSplice
	INC     DI                      ; point to after current path char
	MOV     [SS:CURR_DIR_END],DI	; point to correct spot ;smr;SS Override

; Splice the result.

DoSplice:
	push	ss
	pop	ds			; back to DOSDATA
	MOV     SI,[WFP_START]		; point to beginning of string
	XOR     CX,CX
	TEST	byte [FSPLICE],-1
	JZ	short SkipSplice
	CALL    Splice                  ; replaces in place.
SkipSplice:

; The final thing is to assure ourselves that a FATREAD is done on the local
; device.

	push	ss
	pop	ds
	LES     DI,[THISCDS]		; point to correct drive
	;test	word [es:di+67],8000h
	; 17/12/2022
	;test	byte [es:di+68],80h
	test	byte [ES:DI+curdir.flags+1],curdir_isnet>>8 ; 04/12/2022
	;TEST	word [ES:DI+curdir.flags],curdir_isnet ; 8000h
	JNZ	short Done		; net, no fatread necessary (retnz)
	JCXZ    Done
	call	ECritDisk
	call	FATREAD_CDS
	call	LCritDisk
	;mov	al, 3
	MOV     AL,error_path_not_found ; Set up for possible bad path error
Done:   
	retn                         ; any errors in carry flag.

; 13/07/2018

;BREAK <Canonicalize - copy a path and remove . and .. entries>
;----------------------------------------------------------------------------
;   Canonicalize - copy path removing . and .. entries.
;
;   Inputs:     DS:SI - point to ASCIZ string path
;               ES:DI - point to buffer
;               BX - backup limit (offset from ES) points to slash
;               BP - end of buffer
;   Outputs:    Carry Set - invalid path specification: too many .., bad
;                   syntax, etc.
;               Carry Clear -
;                   DS:DI - advanced to end of string
;                   ES:DI - advanced to end of canonicalized form after nul
;   Registers modified: AX CX DX (in addition to those above)
;----------------------------------------------------------------------------

	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)

Canonicalize:

; We copy all leading path separators.

	LODSB                           ;   while (PathChr (*s))
	call    PATHCHRCMP
	JNZ	short CanonDec
	CMP     DI,BP                   ;       if (d > dlim)
	JAE	short CanonBad		;           goto error;
	STOSB
	JMP	short Canonicalize	;           *d++ = *s++;
CanonDec:
	DEC     SI

; Main canonicalization loop. We come here with DS:SI pointing to a textual
; component (no leading path separators) and ES:DI being the destination
; buffer.

CanonLoop:

; If we are at the end of the source string, then we need to check to see that
; a potential drive specifier is correctly terminated with a path sep char.
; Otherwise, do nothing

	XOR     AX,AX
	CMP     [SI],AL                 ;       if (*s == 0) {
	JNZ	short DoComponent
	CMP     BYTE [ES:DI-1],':'	;           if (d[-1] == ':')
	JNZ	short DoTerminate
	MOV     AL,'\'                  ;               *d++ = '\';
	STOSB
	MOV     AL,AH
DoTerminate:
	STOSB                           ;           *d++ = 0;
	CLC                             ;           return (0);
	retn

CanonBad:
	CALL	ScanPathChar            ; check for path chars in rest of string
	;mov	al,3
	MOV     AL,error_path_not_found ; Set up for bad path error
	JZ	short PathEnc		; path character encountered in string
	;mov	al,2
	MOV     AL,error_file_not_found ; Set bad file error
PathEnc:
	STC
CanonBad_retn:
	retn

; We have a textual component that we must copy. We uppercase it and truncate
; it to 8.3

DoComponent:                            ;           }
	CALL    CopyComponent		;       if (!CopyComponent (s, d))
	jc	short CanonBad_retn	;           return (-1);

; We special case the . and .. cases.  These will be backed up.

	;CMP	WORD PTR ES:[DI],'.' + (0 SHL 8)
	CMP	WORD [ES:DI],002Eh
	JZ	short Skip1
	;CMP	WORD PTR ES:[DI],'..'
	CMP     WORD [ES:DI],2E2Eh
	JNZ	short CanonNormal
	DEC     DI                      ;           d--;
Skip1:  
	CALL    SkipBack                ;           SkipBack ();
	;mov	al,3
	MOV     AL,error_path_not_found ; Set up for possible bad path error
	jc	short CanonBad_retn
	JMP     short CanonPath         ;           }

; We have a normal path. Advance destination pointer over it.

CanonNormal:                            ;       else
	ADD     DI,CX                   ;           d += ct;

; We have successfully copied a component. We are now pointing at a path
; sep char or are pointing at a nul or are pointing at something else.
; If we point at something else, then we have an error.

CanonPath:
	CALL    PathSep
	JNZ	short CanonBad		; something else...

; Copy the first path char we see.

	LODSB                           ; get the char
	call    PATHCHRCMP              ; is it path char?
	JNZ	short CanonDec		; no, go test for nul
	CMP     DI,BP                   ; beyond buffer end?
	JAE	short CanonBad		; yep, error.
	STOSB                           ; copy the one byte

; Skip all remaining path chars

CanonPathLoop:
	LODSB                           ; get next byte
	call    PATHCHRCMP              ; path char again?
	JZ	short CanonPathLoop	; yep, grab another
	DEC     SI                      ; back up
	JMP	short  CanonLoop	; go copy component

;BREAK <PathSep - determine if char is a path separator>
;----------------------------------------------------------------------------
;   PathSep - look at DS:SI and see if char is / \ or NUL
;   Inputs:     DS:SI - point to a char
;   Outputs:    AL has char from DS:SI (/ => \)
;               Zero set if AL is / \ or NUL
;               Zero reset otherwise
;   Registers modified: AL
;----------------------------------------------------------------------------

PathSep:
	MOV     AL,[SI]                 ; get the character
PathSepGotCh:				; already have character
	OR      AL,AL                   ; test for zero
	jz	short CanonBad_retn	; return if equal to zero (NUL)
	;call	PATHCHRCMP              ; check for path character
	;retn				; and return HIS determination
	; 18/12/2022
	jmp	PATHCHRCMP


;BREAK <SkipBack - move backwards to a path separator>
;----------------------------------------------------------------------------
;   SkipBack - look at ES:DI and backup until it points to a / \
;   Inputs:     ES:DI - point to a char
;               BX has current directory back up limit (point to a / \)
;   Outputs:    ES:DI backed up to point to a path char
;               AL has char from output ES:DI (path sep if carry clear)
;               Carry set if illegal backup
;               Carry Clear if ok
;   Registers modified: DI,AL
;----------------------------------------------------------------------------

SkipBack:
	CMP     DI,BX                   ;   while (TRUE) {
	JB	short SkipBad		;       if (d < dlim)
	DEC     DI                      ;           goto err;
	MOV     AL,[ES:DI]		;       if (pathchr (*--d))
	call    PATHCHRCMP              ;           break;
	JNZ	short SkipBack		;       }
	CLC                             ;   return (0);
	retn				;
SkipBad:                                ;err:
	;mov	al,3
	MOV     AL,error_path_not_found ; bad path error
	STC                             ;   return (-1);
	retn				;

;Break <CopyComponent - copy out a file path component>
;----------------------------------------------------------------------------
;   CopyComponent - copy a file component from a path string (DS:SI) into ES:DI
;
;   Inputs:     DS:SI - source path
;               ES:DI - destination
;               ES:BP - end of buffer
;   Outputs:    Carry Set - too long
;               Carry Clear - DS:SI moved past component
;                   CX has length of destination
;   Registers modified: AX,CX,DX
;----------------------------------------------------------------------------

	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)

CopyComponent:

%define CopyBP	 [BP]		; word
%define CopyD	 [BP+2]		; dword
%define CopyDoff [BP+2]		; word
%define CopyS	 [BP+6]		; dword
%define CopySoff [BP+6]		; word
%define CopyTemp [BP+10]	; byte

	SUB     SP,14                   ; room for temp buffer
	push	ds
	push	si
	push	es
	push	di
	push	bp
	MOV     BP,SP
	MOV     AH,'.'
	LODSB
	STOSB
	CMP     AL,AH                   ;   if ((*d++=*s++) == '.') {
	JNZ	short NormalComp
	CALL    PathSep                 ;       if (!pathsep(*s))
	JZ	short NulTerm
TryTwoDot:
	LODSB                           ;           if ((*d++=*s++) != '.'
	STOSB
	CMP     AL,AH
	JNZ	short CopyBad
	CALL    PathSep
	JNZ	short CopyBad		;               || !pathsep (*s))
NulTerm:                                ;               return -1;
	XOR     AL,AL                   ;       *d++ = 0;
	STOSB
	MOV     CopySoff,SI
	JMP     SHORT _GoodRet		;       }
NormalComp:                             ;   else {
	MOV     SI,CopySoff ; [bp+6]
	call	NameTrans               ;       s = NameTrans (s, Name1);
	CMP     SI,CopySoff             ;       if (s == CopySOff)
	JZ	short CopyBad		;           return (-1);
	TEST	byte [SS:FSHARING],-1	;       if (!fSharing) {;smr;SS Override
	JNZ	short DoPack
	AND     DL,1                    ;           cMeta += fMeta;
	ADD	[ss:CMETA],DL		;           if (cMeta > 0);smr;SS Override
	JG	short CopyBad		;               return (-1);
	JNZ	short DoPack		;           else
	OR      DL,DL                   ;           if (cMeta == 0 && fMeta == 0)
	JZ	short CopyBadPath	;               return (-1);
DoPack:                                 ;           }
	MOV     CopySoff,SI ; [bp+6]
	push	ss
	pop	ds
	MOV     SI,NAME1
	LEA     DI,CopyTemp ; [bp+10]
	push	di
	call	PackName                ;       PackName (Name1, temp);
	pop	di
	call	StrLen                  ;       if (strlen(temp)+d > bp)
	DEC     CX
	ADD     CX,CopyDoff ; [bp+2]
	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;cmp	cx,[bp+0]
	; 15/12/2022
	;cmp	cx,[bp]
	CMP	CX,CopyBP   ; [bp+0]
	JAE	short CopyBad		;           return (-1);
	MOV     SI,DI                   ;       strcpy (d, temp);
	LES     DI,CopyD    ; [bp+2]	
	call	FStrCpy
_GoodRet:				;       }
	CLC
	JMP     SHORT CopyEnd           ;   return 0;
CopyBad:
	STC
	CALL    ScanPathChar            ; check for path chars in rest of string
	;mov	al,2
	MOV     AL,error_file_not_found ; Set up for bad file error
	JNZ	short CopyEnd
CopyBadPath:
	STC
	;mov	al,3
	MOV     AL,error_path_not_found ; Set bad path error
CopyEnd:
	pop	bp
	pop	di
	pop	es
	pop	si
	pop	ds
	LAHF
	ADD     SP,14                   ; reclaim temp buffer
	call	StrLen
	DEC     CX
	SAHF
	retn

; 14/05/2019 - Retro DOS v4.0
; DOSCODE:AE22h (MSDOS 6.21, MSDOS.SYS)

; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:ADBFh (MSDOS 5.0, MSDOS.SYS)

;Break <Splice - pseudo mount by string substitution>
;----------------------------------------------------------------------------
;   Splice - take a string and substitute a prefix if one exists. Change
;       ThisCDS to point to physical drive CDS.
;   Inputs:     DS:SI point to string
;               NoSetDir = TRUE => exact matches with splice fail
;   Outputs:    DS:SI points to thisCDS
;               ES:DI points to DPB
;               String at DS:SI may be reduced in length by removing prefix
;               and substituting drive letter.
;               CX = 0 If no splice done
;               CX <> 0 otherwise
;               ThisCDS points to proper CDS if spliced, otherwise it is
;                   left alone
;               ThisDPB points to proper DPB
;   Registers modified: DS:SI, ES:DI, BX,AX,CX
;----------------------------------------------------------------------------

Splice:
	TEST	byte [SS:SPLICES],-1	;smr;SS Override
	JZ	short AllDone
	push	word [SS:THISCDS]
	push	word [SS:THISCDS+2]	; TmpCDS = ThisCDS;smr;SS Override
	push	ds
	push	si
	pop	di
	pop	es
	XOR     AX,AX                   ;   for (i=1; s = GetCDSFromDrv (i); i++)
SpliceScan:
	call	GetCDSFromDrv
	JC	short SpliceDone
	INC     AL
	; 17/12/2022
	;test	byte [si+68],20h
	test	byte [si+curdir.flags+1],curdir_splice>>8 ; 04/12/2022
	;;test	word [si+67],2000h
	;TEST	word [SI+curdir.flags],curdir_splice
	JZ	short SpliceScan 	;       if ( Spliced (i) ) {
	push	di
	CALL    PathPref                ;           if (!PathPref (s, d))
	JZ	short SpliceFound	;
SpliceSkip:
	pop	di
	JMP	short SpliceScan	;               continue;
SpliceFound:
	CMP     BYTE [ES:DI],0		;           if (*s || NoSetDir) {
	JNZ	short SpliceDo
	TEST	byte [ss:NoSetDir],-1			;smr;SS Override
	JNZ	short SpliceSkip
SpliceDo:
	MOV     SI,DI                   ;               p = src + strlen (p);
	push	es
	pop	ds
	pop	di
	CALL	TextFromDrive1          ;               src = TextFromDrive1(src,i);
	MOV     AX,[SS:CURR_DIR_END]			;smr;SS Override
	OR      AX,AX
	JS	short NoPoke
	ADD     AX,DI                   ;               curdirend += src-p;
	SUB     AX,SI
	MOV     [SS:CURR_DIR_END],AX			;smr;SS Override
NoPoke:
	CMP     BYTE [SI],0		;               if (*p)
	JNZ	short SpliceCopy	;                   *src++ = '\\';
	MOV     AL,"\"
	STOSB
SpliceCopy:                             ;               strcpy (src, p);
	call	FStrCpy
	ADD     SP,4                    ; throw away saved stuff
	OR      CL,1                    ; signal splice done.
	JMP     SHORT DoSet             ;               return;
SpliceDone:                             ;               }
	pop	word [SS:THISCDS+2]     ;   ThisCDS = TmpCDS;
	pop	word [SS:THISCDS]			;smr;SS Override
AllDone:
	XOR     CX,CX
DoSet:
	LDS     SI,[SS:THISCDS]		;   ThisDPB = ThisCDS->devptr;;smr;SS Override
	;les	di,[si+69]
	LES     DI,[SI+curdir.devptr]	
	MOV	[SS:THISDPB],DI				;smr;SS Override
	MOV	[SS:THISDPB+2],ES			;smr;SS Override
Splice_retn:
	retn

; 15/05/2019 - Retro DOS v4.0
; DOSCODE:AEA9h (MSDOS 6.21, MSDOS.SYS)

; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:AE46h (MSDOS 5.0, MSDOS.SYS)

;Break <$NameTrans - partially process a name>
;----------------------------------------------------------------------------
;   $NameTrans - allow users to see what names get mapped to. This call
;   performs only string substitution and canonicalization, not splicing.  Due
;   to Transpath playing games with devices, we need to insure that the output
;   has drive letter and : in it.
;
;   Inputs:     DS:SI - source string for translation
;               ES:DI - pointer to buffer
;   Outputs:
;       Carry Clear
;               Buffer at ES:DI is filled in with data
;               ES:DI point byte after nul byte at end of dest string in buffer
;       Carry Set
;               AX = error_path_not_found
;   Registers modified: all
;----------------------------------------------------------------------------

_$NameTrans:
	push	ds
	push	si
	push	es
	push	di
	push	cx ; MSDOS 6.0
	
	; MSDOS 6.0	
; M027 - Start
;
; Sattrib must be set up with default values here. Otherwise, the value from
; a previous DOS call is used for attrib and DevName thinks it is not a 
; device if the old call set the volume attribute bit. Note that devname in
; dir2.asm gets ultimately called by Transpath. See also M026. Also save
; and restore CX.

	;mov	ch,16h
	mov     ch,attr_hidden+attr_system+attr_directory
	call	SetAttrib

; M027 - End

	; MSDOS 3.3 (& MSDOS 6.0)
	MOV     DI,OPENBUF
	CALL    TransPath               ; to translation (everything)
	pop	cx ; MSDOS 6.0
	pop     di
	pop	es
	pop     si
	pop     ds
	JNC	short TransOK
	jmp	SYS_RET_ERR
TransOK:
	MOV     SI,OPENBUF
	push	ss
	pop	ds
;GotText:
	call	FStrCpy
	jmp	SYS_RET_OK

;Break   <DriveFromText - return drive number from a text string>
;----------------------------------------------------------------------------
;   DriveFromText - examine DS:SI and remove a drive letter, advancing the
;   pointer.
;
;   Inputs:     DS:SI point to a text string
;   Outputs:    AL has drive number
;               DS:SI advanced
;   Registers modified: AX,SI.
;----------------------------------------------------------------------------

DriveFromText:
	XOR     AL,AL                   ;       drive = 0;
	;CMP	BYTE [SI],0		;       if (*s &&
	; 23/09/2023
	cmp	[si],al ; 0
	jz	short Splice_retn
	CMP     BYTE [SI+1],':'		;           s[1] == ':') {
	jnz	short Splice_retn
	LODSW                           ;           drive = (*s | 020) - 'a'+1;
	OR      AL,20h
	;sub	al,60h
	SUB     AL,'a'-1                ;           s += 2;
	jnz	short Splice_retn
	MOV	AL,-1                   ; nuke AL...
	; 23/09/2023
	;dec	al ; -1
	retn				;           }

;Break   <TextFromDrive - convert a drive number to a text string>
;----------------------------------------------------------------------------
;   TextFromDrive - turn AL into a drive letter: and put it at es:di with
;   trailing :. TextFromDrive1 takes a 1-based number.
;
;   Inputs:     AL has 0-based drive number
;   Outputs:    ES:DI advanced
;   Registers modified: AX
;----------------------------------------------------------------------------

TextFromDrive:
	INC     AL
TextFromDrive1:
	;add	al,40h
	ADD     AL,'A'-1                ;   *d++ = drive-1+'A';
	MOV     AH,":"	; 3Ah           ;   strcat (d, ":");
	STOSW
PathPref_retn:
	retn

;Break   <PathPref - see if one path is a prefix of another>
;----------------------------------------------------------------------------
;   PathPref - compare DS:SI with ES:DI to see if one is the prefix of the
;   other.  Remember that only at a pathchar break are we allowed to have a
;   prefix: A:\ and A:\FOO
;
;   Inputs:     DS:SI potential prefix
;               ES:DI string
;   Outputs:    Zero set => prefix found
;                   DI/SI advanced past matching part
;               Zero reset => no prefix, DS/SI garbage
;   Registers modified: CX
;----------------------------------------------------------------------------

PathPref:
	call	DStrLen                 ; get length
	DEC     CX                      ; do not include nul byte
	REPZ    CMPSB                   ; compare
	jnz	short PathPref_retn	; if NZ then return NZ
	push	ax			; save char register
	MOV     AL,[SI-1]               ; get last byte to match
	call    PATHCHRCMP              ; is it a path char (Root!)
	JZ	short Prefix		; yes, match root (I hope)
NotSep:                                 ; 2/13/KK
	MOV     AL,[ES:DI]		; get next char to match
	CALL    PathSepGotCh            ; was it a pathchar?
Prefix:
	pop	ax			; get back original
	retn

;Break   <ScanPathChar - see if there is a path character in a string>
;----------------------------------------------------------------------------
;     ScanPathChar - search through the string (pointed to by DS:SI) for
;     a path separator.
;
;     Input:    DS:SI target string (null terminated)
;     Output:   Zero set => path separator encountered in string
;               Zero clear => null encountered
;     Registers modified: SI
;----------------------------------------------------------------------------

ScanPathChar:
	LODSB                           ; fetch a character
	call    PathSepGotCh
	JNZ	short ScanPathChar	; not \, / or NUL => go back for more
	;call	PATHCHRCMP              ; path separator?
	;retn
	; 18/12/2022
	jmp	PATHCHRCMP

;============================================================================
; FILE.ASM, MSDOS 6.0, 1991
;============================================================================
; 14/07/2018 - Retro DOS v3.0

; 13/05/2019 - Retro DOS v4.0
; DOSCODE:AF10h (MSDOS 6.21, MSDOS.SYS)

; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:AEADh (MSDOS 5.0, MSDOS.SYS)

; MSDOS 2.11
;BREAK <$Open - open a file handle>
;----------------------------------------------------------------------------
;   Assembler usage:
;           LDS     DX, Name
;           MOV     AH, Open
;           MOV     AL, access
;           INT     int_command
;
;       ACCESS          Function
;       ------          --------
;       open_for_read   file is opened for reading
;       open_for_write  file is opened for writing
;       open_for_both   file is opened for both reading and writing.
;
;   Error returns:
;           AX = error_invalid_access
;              = error_file_not_found
;              = error_access_denied
;              = error_too_many_open_files
;----------------------------------------------------------------------------

; MSDOS 6.0
;	BREAK <$Open - open a file from a path string>
;----------------------------------------------------------------------------
;
;**	$OPen - Open a File
;
;	given a path name in DS:DX and an open mode in AL, $Open opens the
;	file and and returns a handle
;
;	ENTRY	(DS:DX) = pointer to asciz name
;		(AL) = open mode
;	EXIT	'C' clear if OK
;		  (ax) = file handle
;		'C' set if error
;		  (ax) = error code
;	USES	all
;
;----------------------------------------------------------------------------

; 13/05/2019 - Retro DOS v4.0
; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)

_$OPEN:       
	xor	ah,ah  ; MSDOS 6.0	
_$Open2:
	;mov	ch,16h
	mov	ch,attr_hidden+attr_system+attr_directory
	call	SetAttrib
	mov	cx,DOS_OPEN

	;xor	ah,ah  ; MSDOS 3.3

	push	ax

;*	General file open/create code. The $CREATE call and the various
;	$OPEN calls all come here.
;
;	We'll share a lot of the standard stuff of allocating SFTs, cracking
;	path names, etc., and then dispatch to our individual handlers.
;	WARNING - this info and list is just a guess, not definitive - jgl
;
;	(TOS) = create mode
;	(CX) = address of routine to call to do actual function
;	(DS:DX) = ASCIZ name
;	SAttrib = Attribute mask

;	Get a free SFT and mark it "being allocated"

AccessFile:
	call	ECritSFT
	call	SFNFree			; get a free sfn
	call	LCritSFT
	jc	short OpenFailJ		; oops, no free sft's
	MOV	[SS:SFN],BX		; save the SFN for later;smr;SS Override
	MOV	[SS:THISSFT],DI		; save the SF offset	;smr;SS Override
	MOV	[SS:THISSFT+2],ES	; save the SF segment	;smr;SS Override

;	Find a free area in the user's JFN table.

	call	JFNFree			; get a free jfn
	jnc	short SaveJFN
OpenFailJ:
	JMP	OpenFail		; there were free JFNs... try SFN

SaveJFN:
	mov	[ss:PJFN],DI		; save the jfn offset	;smr;SS Override
	MOV	[ss:PJFN+2],ES		; save the jfn segment	;smr;SS Override
	MOV	[ss:JFN],BX		; save the jfn itself	;smr;SS Override

;	We have been given an JFN. We lock it down to prevent other tasks from
;	reusing the same JFN.

	MOV	BX,[ss:SFN]					;smr;SS Override
	MOV	[ES:DI],BL		; assign the JFN
	MOV	SI,DX			; get name in appropriate place
	MOV	DI,OPENBUF		; appropriate buffer
	push	cx			; save routine to call
	call	TransPath		; convert the path
	pop	bx			; (bx) = routine to call

	LDS	SI,[SS:THISSFT]					;smr;SS Override
	JC	short OpenCleanJ	; no error, go and open file
	CMP	byte [ss:CMETA],-1				;smr;SS Override
	JZ	short SetSearch
	;mov	al,2
	MOV	AL,error_file_not_found ; no meta chars allowed
OpenCleanJ:
	JMP	short OpenClean

SetSearch:
	pop	ax			; Mode (Open), Attributes (Create)

;	We need to get the new inheritance bits.

	xor	cx,cx
	; MSDOS 6.0
	;mov	[si+2],cx ; 0
	MOV	[SI+SF_ENTRY.sf_mode],cx ; initialize mode field to 0
	;mov    [si+51],cx ; 0
	MOV	[SI+SF_ENTRY.sf_MFT],cx	 ; clean out sharing info
	;
	CMP	BX,DOS_OPEN
	JNZ	short _DoOper
	;test   al,80h
	test	AL,SHARING_NO_INHERIT	; look for no inher
	JZ	short _DoOper ; 10/08/2018
	AND	AL,7Fh			; mask off inherit bit
	;mov	cx,1000h
	MOV	CX,sf_no_inherit
_DoOper:
	;; MSDOS 3.3
	;;mov	word [si+2], 0
	;;mov	word [si+33h], 0
	;MOV	word [SI+SF_ENTRY.sf_mode],0
	;MOV	word [SI+SF_ENTRY.sf_MFT],0

	; MSDOS 6.0
;**	Check if this is an extended open. If so you must set the
;	modes in sf_mode. Call Set_EXT_mode to do all this. See
;	Set_EXT_mode in creat.asm

	; MSDOS 6.0
	;SAVE	<di, es>                ;M022 conditional removed here
	push	di
	push	es
	push	ds
	pop	es
	push	si
	pop	di			; (es:di) = SFT address
	call	Set_EXT_mode
	;RESTORE <es, di>
	pop	es
	pop	di

	;Context DS
	push	ss
	pop	ds	

	push	cx
	CALL	BX			; blam!
	pop	cx
	LDS	SI,[THISSFT]
	JC	short OpenE2		;AN000;FT. chek extended open hooks first
	;jc	short OpenE ; MSDOS 3.3

;	The SFT was successfully opened. Remove busy mark.

OpenOK:
	;MOV	word [SI+SF_ENTRY.sf_ref_count],1
	mov	word [SI],1
	;or	[SI+5],cx
	OR	[SI+SF_ENTRY.sf_flags],CX ; set no inherit bit if necessary

; If the open mode is 70, we scan the system for other SFT's with the same
; contents. If we find one, then we can 'collapse' thissft onto the already
; opened one. Otherwise we use this new one. We compare uid/pid/mode/mft
;
; Since this is only relevant on sharer systems, we stick this code into the
; sharer.

	MOV	AX,[ss:JFN]				;smr;SS Override
	Call	far [ss:JShare+(12*4)]	; 12 = ShCol	;smr;SS Override

	MOV	word [ss:SFN],-1	; clear out sfn pointer	;smr;SS Override
	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
OpenOkj:
	jmp	SYS_RET_OK		; bye with no errors

	; MSDOS 6.0
;Extended Open hooks check
OpenE2:					;AN000;;EO.
	CMP	AX,error_invalid_parameter ;AN000;;EO. IFS extended open ?
	JNZ	short OpenE		;AN000;;EO. no.
	JMP	short OpenCritLeave	;AN000;;EO. keep handle

;	Extended Open hooks check
;
;	AL has error code.  Stack has argument to dos_open/dos_create.

OpenClean:
	pop	bx			; clean off stack
OpenE:
	;MOV	word [SI+SF_ENTRY.sf_ref_count],0 ; release SFT
	mov	word [SI],0
	LDS	SI,[ss:PJFN]		;smr;SS Override
	MOV	BYTE [SI],0FFh		; free the SFN...
	JMP	SHORT OpenCritLeave

OpenFail:
	STI
	pop	cx			; Clean stack
OpenCritLeave:
	MOV	word [SS:SFN],-1	; remove mark.

	; MSDOS 6.0
; File Tagging DOS 4.00
	CMP	word [SS:EXTERR],error_Code_Page_Mismatched
					;AN000;;FT. code page mismatch
	JNZ	short NORERR	  	;AN000;;FT. no
	jmp	From_GetSet		;AN000;;FT. yes
NORERR: 				;AN000;
; File Tagging DOS 4.00

	jmp	SYS_RET_ERR		; no free, return error

; MSDOS 2.11
;BREAK <$CREAT - creat a new file and open him for input>
;----------------------------------------------------------------------------
;   Assembler usage:
;           LDS     DX, name
;           MOV     AH, Creat
;           MOV     CX, access
;           INT     21h
;       ; AX now has the handle
;
;   Error returns:
;           AX = error_access_denied
;              = error_path_not_found
;              = error_too_many_open_files
;----------------------------------------------------------------------------

; MSDOS 6.0
;	BREAK <$Creat - create a brand-new file>
;----------------------------------------------------------------------------
;
;**	$Creat - Create a File
;
;	$Creat creates the directory entry specified in DS:DX and gives it the
;	initial attributes contained in CX
;
;	ENTRY	(DS:DX) = ASCIZ path name
;		(CX) = initial attributes
;	EXIT	'C' set if error
;		  (ax) = error code
;		'C' clear if OK
;		  (ax) = file handle
;	USES	all
;
;----------------------------------------------------------------------------

_$CREAT:
	push	cx			; Save attributes on stack
	mov	CX,DOS_CREATE		; routine to call
AccessSet:
	;mov	byte [ss:SATTRIB],6
	mov	byte [ss:SATTRIB],attr_hidden+attr_system ;smr;SS Override
	; 10/08/2018
	JMP	AccessFile		; use good ol' open

; MSDOS 6.0 (MSDOS 3.3)
;	BREAK <$CHMOD - change file attributes>
;----------------------------------------------------------------------------
;
;**	$CHMOD - Change File Attributes
;
;   Assembler usage:
;	    LDS     DX, name
;	    MOV     CX, attributes
;	    MOV     AL,func (0=get, 1=set)
;	    INT     21h
;   Error returns:
;	    AX = error_path_not_found
;	    AX = error_access_denied
;
;----------------------------------------------------------------------------

	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
_$CHMOD:
	; 05/08/2018 - Retro DOS v3.0
	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 6FCCh ,
	MOV	DI,OPENBUF		; appropriate buffer
	push	ax
	push	cx			; save function and attributes
	MOV	SI,DX			; get things in appropriate places
	call	TransPathSet		; get correct path
	pop	cx
	pop	ax			; and get function and attrs back
	JC	short ChModErr		; errors get mapped to path not found
	push	ss			; set up for later possible calls
	pop	ds
	CMP	byte [CMETA],-1
	JNZ	short ChModErr
	;mov	byte [SATTRIB],16h
	MOV	byte [SATTRIB],attr_hidden+attr_system+attr_directory
	SUB	AL,1			; fast way to discriminate
	JB	short ChModGet		; 0 -> go get value
	JZ	short ChModSet		; 1 -> go set value
	;mov	byte [EXTERR_LOCUS],1
	MOV	byte [EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus
	;mov	al,1
	mov	al,error_invalid_function ; bad value
	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
chmod_errj:	
	;;jmp	SYS_RET_ERR
	;jmp	short ChModE	
	jmp	short NORERR	; 06/12/2022
ChModGet:
	call	GET_FILE_INFO		; suck out the ol' info
	JC	short ChModE		; error codes are already set for ret
	call	Get_User_Stack		; point to user saved vaiables
	;mov	[SI+4],ax
	MOV	[SI+user_env.user_CX],AX ; return the attributes
	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility
OpenOkj2:
	; 17/12/2022
	;;jmp	SYS_RET_OK		; say sayonara
	;jmp	short OpenOkj
	; 25/06/2019
	jmp	SYS_RET_OK_clc

ChModSet:
	MOV	AX,CX			; get attrs in position
	call	SET_FILE_ATTRIBUTE	; go set
	JC	short ChModE		; errors are set
	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility
	;jmp	SYS_RET_OK
OpenOkj3:
	;jmp	short OpenOkj2
	; 17/12/2022
	jmp	SYS_RET_OK

; 17/12/2022
%if 0
ChModErr:
NotFound:	; 17/12/2022
	;mov	al,3
	mov	al,error_path_not_found
ChModE:
UnlinkE:	; 17/12/2022
	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;;jmp	SYS_RET_ERR
	;jmp	short chmod_errj
	; 17/12/2022
	jmp	short NORERR
%endif

; 22/05/2019 - Retro DOS v4.0
; DOSCODE:B039h (MSDOS 6.21, MSDOS.SYS)

; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:AFD6h (MSDOS 5.0, MSDOS.SYS)

;	BREAK <$UNLINK - delete a file entry>
;----------------------------------------------------------------------------
;
;**	$UNLINK - Delete a File
;
;
;	Assembler usage:
;	    LDS     DX, name
;	    IF VIA SERVER DOS CALL
;	     MOV     CX,SEARCH_ATTRIB
;	    MOV     AH, Unlink
;	    INT     21h
;
;	ENTRY	(ds:dx) = path name
;		(cx) = search_attribute, if via server_dos
;	EXIT	'C' clear if no error
;		'C' set if error
;		  (ax) = error code
;			= error_file_not_found
;			= error_access_denied
;
;----------------------------------------------------------------------------

_$UNLINK:
	push	cx			; Save possible CX input parm
	MOV	SI,DX			; Point at input string
	MOV	DI,OPENBUF		; temp spot for path
	call	TransPathSet		; go get normalized path
	pop	cx
	JC	short ChModErr		; badly formed path
	CMP	byte [ss:CMETA],-1	; meta chars?	;smr;SS Override
	JNZ	short NotFound
	push	ss
	pop	ds
	;mov	ch,6
	mov	ch,attr_hidden+attr_system ; unlink appropriate files
	call	SetAttrib
	call	DOS_DELETE		; remove that file
	;JC	short UnlinkE 		; error is there
	; 17/12/2022
	jc	short NORERR

	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
UnlinkOk:
	;jmp	SYS_RET_OK		; okey doksy
	jmp	short OpenOkj3

	; 17/12/2022
ChModErr:	; 17/12/2022
NotFound:
	;mov	al,3
	MOV	AL,error_path_not_found
ChModE:		; 17/12/2022
UnlinkE:
	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;;jmp	SYS_RET_ERR		; bye
	;jmp	short ChModE
	; 17/12/2022
	jmp	short NORERR

;BREAK <$RENAME - move directory entries around>
;----------------------------------------------------------------------------
;
;   Assembler usage:
;	    LDS     DX, source
;	    LES     DI, dest
;	    IF VIA SERVER DOS CALL
;	      MOV   CX,SEARCH_ATTRIB
;	    MOV     AH, Rename
;	    INT     21h
;
;   Error returns:
;	    AX = error_file_not_found
;	       = error_not_same_device
;	       = error_access_denied
;
;----------------------------------------------------------------------------

	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
_$RENAME:
	; MSDOS 3.3 (& MSDOS 6.0)
	push	cx
	push	ds
	push	dx			; save source and possible CX arg
	PUSH	ES
	POP	DS			; move dest to source
	MOV	SI,DI			; save for offsets
	MOV	DI,RENBUF
	call	TransPathSet		; munge the paths
	PUSH	word [ss:WFP_START]	; get pointer	;smr;SS Override
	POP	word [ss:REN_WFP]	; stash it	;smr;SS Override
	pop	si
	pop	ds
	pop	cx			; get back source and possible CX arg
epjc2:	
	JC	short ChModErr		; get old error
	CMP	byte [ss:CMETA],-1			;smr;SS Override
	JNZ	short NotFound
	push	cx			; Save possible CX arg
	MOV	DI,OPENBUF		; appropriate buffer
	call	TransPathSet		; wham
	pop	cx
	JC	short epjc2
	push	ss
	pop	ds
	CMP	byte [CMETA],-1
	JB	short NotFound

	; MSDOS 6.0
	PUSH	WORD [THISCDS]		   ;AN000;;MS.save thiscds
	PUSH	WORD [THISCDS+2]	   ;AN000;;MS.
	MOV	DI,OPENBUF		   ;AN000;;MS.
	PUSH	SS			   ;AN000;;MS.
	POP	ES			   ;AN000;;MS.es:di-> source
	XOR	AL,AL			   ;AN000;;MS.scan all CDS
rnloop: 				   ;AN000;
	call	GetCDSFromDrv		   ;AN000;;MS.
	JC	short dorn		   ;AN000;;MS.	end of CDS
	call	StrCmp			   ;AN000;;MS.	current dir ?
	JZ	short rnerr		   ;AN000;;MS.	yes
	INC	AL			   ;AN000;;MS.	next
	JMP	short rnloop		   ;AN000;;MS.
rnerr:					   ;AN000;
	ADD	SP,4			   ;AN000;;MS. pop thiscds
	;error	error_current_directory    ;AN000;;MS.
	mov	al,error_current_directory 
	;jmp	SYS_RET_ERR
	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	jmp	short UnlinkE
dorn:					   ;AN000;
	POP	WORD [SS:THISCDS+2]	   ;AN000;;MS.;PBUGBUG;SS REQD??
	POP	WORD [SS:THISCDS]	   ;AN000;;MS.;PBUGBUG;SS REQD??

	push	ss
	pop	ds

	; MSDOS 3.3 (& MSDOS 6.0)
	;mov	ch,16h
	mov	ch,attr_directory+attr_hidden+attr_system
					; rename appropriate files
	call	SetAttrib
	call	DOS_RENAME		; do the deed
	JC	short UnlinkE 		; errors

	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;jmp	SYS_RET_OK
	jmp	short UnlinkOk


; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)

; 14/07/2018 - Retro DOS v3.0
; MSDOS 3.3 (& MSDOS 6.0)

;Break <$CreateNewFile - Create a new directory entry>
;----------------------------------------------------------------------------
;   CreateNew - Create a new directory entry.  Return a file handle if there
;	was no previous directory entry, and fail if a directory entry with
;	the same name existed previously.
;
;   Inputs:	DS:DX point to an ASCIZ file name
;		CX contains default file attributes
;   Outputs:	Carry Clear:
;		    AX has file handle opened for read/write
;		Carry Set:
;		    AX has error code
;   Registers modified: All
;----------------------------------------------------------------------------

_$CreateNewFile:
	push	cx			; Save attributes on stack
	MOV	CX,DOS_Create_New	; routine to call
	JMP	AccessSet		; use good ol' open

;**	BinToAscii - convert a number to a string.
;----------------------------------------------------------------------------
;	BinToAscii converts a 16 bit number into a 4 ascii characters.
;	This routine is used to generate temp file names so we don't spend
;	the time and code needed for a true hex number, we just use
;	A thorugh O.
;
;	ENTRY	(ax) = value
;		(es:di) = destination
;	EXIT	(es:di) updated by 4
;	USES	cx, di, flags
;----------------------------------------------------------------------------

; MSDOS 3.3
;BinToAscii:
;	mov     cx,4
;bta5:
;	push    cx
;	mov     cl,4
;	rol     ax,cl
;	push    ax
;	and     al,0Fh
;	add     al,'0'
;	cmp     al,'9'
;	jbe     short bta6
;	add     al,7
;bta6: 
;	stosb
;	pop     ax
;	pop     cx
;	loop    bta5
;	retn

; MSDOS 6.0
BinToAscii:
	mov	cx,404h			; (ch) = digit counter, (cl) = shift cnt
bta5:	
	ROL	AX,CL			; move leftmost nibble into rightmost
	push	ax			; preserve remainder of digits
	AND	AL,0Fh			; grab low nibble
	ADD	AL,'A'			; turn into ascii
	STOSB				; drop in the character
	pop	ax			; (ax) = shifted number
	dec	ch
	jnz	short bta5		; process 4 digits
	retn

;Break	<$CreateTempFile - create a unique name>
;----------------------------------------------------------------------------
;   $CreateTemp - given a directory, create a unique name in that directory.
;	Method used is to get the current time, convert to a name and attempt
;	a create new. Repeat until create new succeeds.
;
;   Inputs:	DS:DX point to a null terminated directory name.
;		CX  contains default attributes
;   Outputs:	Unique name is appended to DS:DX directory.
;		AX has handle
;   Registers modified: all
;----------------------------------------------------------------------------

	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)

_$CreateTempFile:
	;Enter
	push	bp
	mov	bp,sp

	;LocalVar  EndPtr,DWORD
	;LocalVar  FilPtr,DWORD
	;LocalVar  Attr,WORD

	sub	sp,10

	;test	cx,0FFD8h
	test	CX,~attr_changeable
	JZ	short OKatts		; Ok if no non-changeable bits set

; We need this "hook" here to detect these cases (like user sets one both of
; vol_id and dir bits) because of the structure of the or $CreateNewFile loop
; below. The code loops on error_access_denied, but if one of the non
; changeable attributes is specified, the loop COULD be infinite or WILL be
; infinite because CreateNewFile will fail with access_denied always. Thus we
; need to detect these cases before getting to the loop.

	;mov	ax, 5
	MOV	AX,error_access_denied
	JMP	SHORT SETTMPERR

OKatts:
	;MOV	attr,CX 		; save attribute
	mov     [bp-10],cx
	;MOV	FilPtrL,DX		; pointer to file
	mov	[bp-8],dx
	;MOV	FilPtrH,DS
	mov	[bp-6],ds
	;MOV	EndPtrH,DS		; seg pointer to end of dir
	mov	[bp-2],ds
	PUSH	DS
	POP	ES			; destination for nul search
	MOV	DI,DX
	MOV	CX,DI
	NEG	CX			; number of bytes remaining in segment
	; MSDOS 6.0
	OR	CX,CX			;AN000;MS. cx=0 ? ds:dx on segment boundary
	JNZ	short okok		;AN000;MS. no
	;MOV	CX,-1			;AN000;MS.
	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	; 17/12/2022
	dec	cx  ; mov cx,-1
	;mov	cx,-1 ; 0FFFh
okok:					;AN000;
	XOR	AX,AX			;AN000;
	REPNZ	SCASB			;AN000;
					;AN000;
	DEC	DI			; point back to the null
	MOV	AL,[ES:DI-1]		; Get char before the NUL
	call	PATHCHRCMP		; Is it a path separator?
	JZ	short SETENDPTR		; Yes
STOREPTH:
	MOV	AL,'\'
	STOSB				; Add a path separator (and INC DI)
SETENDPTR:
	;MOV	EndPtrL,DI		; pointer to the tail
	mov	[bp-4],dl
CreateLoop:
	push	ss			; let ReadTime see variables
	pop	ds
	push	bp
	call	READTIME		; go get time
	pop	bp
;
; Time is in CX:DX. Go drop it into the string.
;
	;les	di,EndPtr		; point to the string
	les	di,[BP-4]
	mov	ax,cx
	call	BinToAscii		; store upper word
	mov	ax,dx
	call	BinToAscii		; store lower word
	xor	al,al
	STOSB				; nul terminate
	;LDS	DX,FilPtr		; get name
	lds	dx,[bp-8]
	;MOV	CX,Attr 		; get attr
	mov	cx,[bp-10]
	push	bp
	CALL	_$CreateNewFile		; try to create a new file
	pop	bp
	JNC	short CreateDone	; failed, go try again

; The operation failed and the error has been mapped in AX. Grab the extended
; error and figure out what to do.

	;; MSDOS 3.3			; M049 - start
;;	mov	ax,[ss:EXTERR]				;smr;SS Override
;;	cmp	al,error_file_exists
;;	jz	short CreateLoop	; file existed => try with new name
;;	cmp	al,error_access_denied
;;	jz	short CreateLoop	; access denied (attr mismatch)

	; MSDOS 6.0
	;cmp	al,50h
	CMP	AL,error_file_exists	; Q: did file already exist
	JZ	short CreateLoop	; Y: try again
	;cmp	al,5
	CMP	AL,error_access_denied	; Q: was it access denied
	JNZ	short SETTMPERR		; N: Error out
					; Y: Check to see if we got this due
					;    to the network drive. Note that
					;    the redir will set the exterr
					;    to error_cannot_make if this is 
					;    so. 
	CMP	byte [SS:EXTERR],error_net_access_denied ; M069
					; See if it's REALLY an att mismatch
	je	short SETTMPERR		; no, network error, stop
;M070
; If the user failed on an I24, we do not want to try again
;
	cmp	byte [SS:EXTERR],error_FAIL_I24 ;User failed on I24? ;M070
	;je	short SETTMPERR		;yes, do not try again ;M070

	;jmp	short CreateLoop	;attr mismatch, try again ;M070
	; 17/12/2022
	jne	short CreateLoop ; 10/06/2019 
	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;jz	short SETTMPERR
	;jmp	short CreateLoop

;;	MOV	AL,error_access_denied	; Return this "extended" error
					; M049 - end
SETTMPERR:
	STC
CreateDone:
	;Leave
	mov	sp,bp
	pop	bp
	JC	short CreateFail
	jmp	SYS_RET_OK		; success!
CreateFail:
	jmp	SYS_RET_ERR

;   SetAttrib will set the search attribute (SAttrib) either to the normal
;   (CH) or to the value in CL if the current system call is through
;   serverdoscall.
;
;   Inputs:	fSharing == FALSE => set sattrib to CH
;		fSharing == TRUE => set sattrib to CL
;   Outputs:	none
;   Registers changed:	CX

SetAttrib:
	test	byte [SS:FSHARING],-1		;smr;SS Override
	jnz	short Set
	mov	cl,ch
Set:
	mov	byte [ss:SATTRIB],cl		;smr;SS Override
	retn

; 14/07/2018 - Retro DOS v3.0
; MSDOS 6.0

; 29/04/2019 - Retro DOS v4.0

;Break	<Extended_Open- Extended open the file>
;----------------------------------------------------------------------------
; Input: AL= 0 reserved  AH=6CH
;	 BX= mode
;	 CL= create attribute  CH=search attribute (from server)
;	 DX= flag
;	 DS:SI = file name
;	 ES:DI = parm list
;			   DD  SET EA list (-1) null
;			   DW  n  parameters
;			   DB  type (TTTTTTLL)
;			   DW  IOMODE
; Function: Extended Open
; Output: carry clear
;		     AX= handle
;		     CX=1 file opened
;			2 file created/opened
;			3 file replaced/opened
;	  carry set: AX has error code
;----------------------------------------------------------------------------

	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
_$Extended_Open:			  ;AN000;
	;ASSUME	CS:DOSCODE,SS:DOSDATA	  ;AN000;
	MOV	[SS:EXTOPEN_FLAG],DX	  ;AN000;EO. save ext. open flag;smr;SS Override
	MOV	word [SS:EXTOPEN_IO_MODE],0 ;AN000;EO. initialize IO mode;smr;SS Override
	; 17/12/2022
	test	dh,0FEh ; 04/12/2022 
	;;test	dx,0FE00h
	;TEST	DX,RESERVED_BITS_MASK	  ;AN000;EO. reserved bits 0  ?
	JNZ	short ext_inval2	  ;AN000;EO. no
	MOV	AH,DL			  ;AN000;EO. make sure flag is right
	CMP	DL,0			  ;AN000;EO. all fail ?
	JZ	short ext_inval2	  ;AN000;EO. yes, error
	;and	dl,0Fh
	AND	DL,EXISTS_MASK		  ;AN000;EO. get exists action byte
	CMP	DL,2			  ;AN000;EO, > 02
	JA	short ext_inval2	  ;AN000;EO. yes ,error
	;and	ah,0F0h
	AND	AH,NOT_EXISTS_MASK	  ;AN000;EO. get no exists action byte
	CMP	AH,10H			  ;AN000;EO. > 10
	JA	short ext_inval2	  ;AN000;EO. yes error

	MOV	[SS:SAVE_ES],ES		  ;AN000;EO. save API parms;smr;SS Override
	MOV	[SS:SAVE_DI],DI		  ;AN000;EO.;smr;SS Override
	PUSH	word [SS:EXTOPEN_FLAG]	  ;AN000;EO.;smr;SS Override
	POP	word [SS:SAVE_DX]	  ;AN000;EO.;smr;SS Override
	MOV	[SS:SAVE_CX],CX		  ;AN000;EO.;smr;SS Override
	MOV	[SS:SAVE_BX],BX		  ;AN000;EO.;smr;SS Override
	MOV	[SS:SAVE_DS],DS		  ;AN000;EO.;smr;SS Override
	MOV	[SS:SAVE_SI],SI		  ;AN000;EO.;smr;SS Override
	MOV	DX,SI			  ;AN000;EO. ds:dx points to file name
	MOV	AX,BX			  ;AN000;EO. ax= mode
	JMP	SHORT goopen2		  ;AN000;;EO. do normal
ext_inval2:				  ;AN000;;EO.
	;mov	al,1
	mov	al,error_invalid_function ;AN000;EO.. invalid function
	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
eo_err:
	;jmp	SYS_RET_ERR
	jmp	short CreateFail

ext_inval_parm:				  ;AN000;EO..
	POP	CX			  ;AN000;EO..  pop up satck
	POP	SI			  ;AN000;EO..
	;error	error_invalid_data	  ;AN000;EO..  invalid parms
	;mov	al,13
	mov	al,error_invalid_data
	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;;jmp	SYS_RET_ERR
	;jmp	short eo_err
	; 17/12/2022
	jmp	short CreateFail

	; 17/12/2022	
;error_return:				  ;AN000;EO.
;	retn				  ;AN000;EO.. return with error

goopen2:				  ;AN000;
	; 17/12/2022
	;test	bh,20h				 
	test	bh,INT_24_ERROR>>8 ; 04/12/2022
	;;test	bx,2000h
	;TEST	BX,INT_24_ERROR		  ;AN000;EO.. disable INT 24 error ?
	JZ	short goopen		  ;AN000;EO.. no
	;or	byte [SS:EXTOPEN_ON],2
	OR	byte [SS:EXTOPEN_ON],EXT_OPEN_I24_OFF ;AN000;EO.. set bit to disable;smr;SS Override
goopen:					  ;AN000;
	;or	byte [SS:EXTOPEN_ON],1 
	OR	byte [SS:EXTOPEN_ON],EXT_OPEN_ON  ;AN000;EO.. set Extended Open active;smr;SS Override
	;AND	word [SS:EXTOPEN_FLAG],0FFh  ;AN000;EO.create new ?;smr;SS Override
	; 18/12/2022
	mov	byte [SS:EXTOPEN_FLAG+1],0 ; AND word [SS:EXTOPEN_FLAG],0FFh
	;cmp	word [SS:EXTOPEN_FLAG],10h
	CMP	word [SS:EXTOPEN_FLAG],EXT_EXISTS_FAIL+EXT_NEXISTS_CREATE ;AN000;FT.;smr;SS Override
	JNZ	short chknext 		  ;AN000;;EO. no
	call	_$CreateNewFile		  ;AN000;;EO. yes
	JC	short error_return	  ;AN000;;EO. error

	CMP	byte [SS:EXTOPEN_ON],0	  ;AN000;;EO. IFS does it;smr;SS Override
	JZ	short ok_return2	  ;AN000;;EO. yes
	;mov	word [SS:EXTOPEN_FLAG],2
	MOV	word [SS:EXTOPEN_FLAG],ACTION_CREATED_OPENED ;AN000;EO. creted/opened;smr;SS Override
	JMP	setXAttr		  ;AN000;;EO. set XAs

	; 17/12/2022
;ok_return2:
;	jmp	SYS_RET_OK		  ;AN000;;EO.

chknext:
	; 17/12/2022
	test	byte [SS:EXTOPEN_FLAG],EXT_EXISTS_OPEN ; 1
	;;test	word [SS:EXTOPEN_FLAG],1
	;TEST	word [SS:EXTOPEN_FLAG],EXT_EXISTS_OPEN ;AN000;;EO. exists open;smr;SS Override
	JNZ	short exist_open	  ;AN000;;EO. yes
	call	_$CREAT			  ;AN000;;EO. must be replace open
	JC	short error_return	  ;AN000;;EO. return with error
	CMP	byte [SS:EXTOPEN_ON],0	  ;AN000;;EO. IFS does it;smr;SS Override
	JZ	short ok_return2	  ;AN000;;EO. yes
	MOV	word [SS:EXTOPEN_FLAG],ACTION_CREATED_OPENED ;AN000;EO. prsume create/open;smr;SS Override
	TEST	byte [SS:EXTOPEN_ON],EXT_FILE_NOT_EXISTS ;AN000;;EO. file not exists ?;smr;SS Override
	JNZ	short setXAttr		  ;AN000;;EO. no
	MOV	word [SS:EXTOPEN_FLAG],ACTION_REPLACED_OPENED ;AN000;;EO. replaced/opened;smr;SS Override
	JMP	SHORT setXAttr		  ;AN000;;EO. set XAs
error_return2:
	STC 				  ; Set Carry again to flag error ;AN001;
error_return:	 ;17/12/2022
	retn				  ;AN000;;EO. return with error

	; 17/12/2022
ok_return:
ok_return2:
	jmp	SYS_RET_OK

exist_open:				  ;AN000;
	test	byte [SS:FSHARING],-1	  ;AN000;;EO. server doscall?;smr;SS Override
	jz	short noserver		  ;AN000;;EO. no
	MOV	CL,CH			  ;AN000;;EO. cl=search attribute
noserver:
	call	_$Open2			  ;AN000;;EO. do open
	JNC	short ext_ok		  ;AN000;;EO.
	CMP	byte [SS:EXTOPEN_ON],0	  ;AN000;;EO. error and IFS call;smr;SS Override
	JZ	short error_return2	  ;AN000;;EO. return with error
local_extopen:
	;cmp	ax,2
	CMP	AX,error_file_not_found   ;AN000;;EO. file not found error
	JNZ	short error_return2	  ;AN000;;EO. no,
	;;test	word [SS:EXTOPEN_FLAG],10h
	; 17/12/2022
	test	byte [SS:EXTOPEN_FLAG],EXT_NEXISTS_CREATE ; 10h
	;TEST	word [SS:EXTOPEN_FLAG],EXT_NEXISTS_CREATE ;AN000;;EO. want to fail;smr;SS Override
	;JNZ	short do_creat		  ;AN000;;EO. yes
	;JMP	short extexit 		  ;AN000;;EO. yes
	; 17/12/2022
	jz	short extexit ; 10/06/2019
	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;jnz	short do_creat
	;jmp	short extexit
do_creat:
	MOV	CX,[SS:SAVE_CX]		  ;AN000;;EO. get ds:dx for file name;smr;SS Override
	LDS	SI,[SS:SAVE_SI]		  ;AN000;;EO. cx = attribute;smr;SS Override
	MOV	DX,SI			  ;AN000;;EO.
	call	_$CREAT			  ;AN000;;EO. do create
	JC	short extexit 		  ;AN000;;EO. error
	;mov	word [SS:EXTOPEN_FLAG],2
	MOV	word [SS:EXTOPEN_FLAG],ACTION_CREATED_OPENED
					  ;AN000;;EO. is created/opened;smr;SS Override
	JMP	SHORT setXAttr		  ;AN000;;EO. set XAs

ext_ok:
	CMP	byte [SS:EXTOPEN_ON],0	  ;AN000;;EO. IFS call ?;smr;SS Override
	JZ	short ok_return		  ;AN000;;EO. yes
	;mov	word [SS:EXTOPEN_FLAG],1
	MOV	word [SS:EXTOPEN_FLAG],ACTION_OPENED ;AN000;;EO. opened;smr;SS Override
setXAttr:
	; 29/04/2019
	push	ax
	call	Get_User_Stack		  ;AN000;;EO.
	MOV	AX,[SS:EXTOPEN_FLAG]	  ;AN000;;EO.;smr;SS Override
	;mov	[si+4],ax
	MOV	[SI+user_env.user_CX],AX  ;AN000;;EO. set action code for cx
	pop	ax			  ;AN000;;EO.
	mov	[si],ax
	;MOV	[SI+user_env.user_AX],AX  ;AN000;;EO. set handle for ax
	; 17/12/2022
	jmp	short ok_return
;ok_return:				  ;AN000;
	;jmp	SYS_RET_OK		  ;AN000;;EO.

extexit2:				  ;AN000; ERROR RECOVERY
	POP	BX			  ;AN000;EO. close the handle
	PUSH	AX			  ;AN000;EO. save error code from set XA
	;cmp	word [SS:EXTOPEN_FLAG],2
	CMP	word [SS:EXTOPEN_FLAG],ACTION_CREATED_OPENED
					  ;AN000;EO. from create;smr;SS Override
	JNZ	short justopen		  ;AN000;EO.
	LDS	SI,[SS:SAVE_SI]		  ;AN000;EO. cx = attribute;smr;SS Override
	LDS	DX,[SI]			  ;AN000;EO.
	call	_$UNLINK 		  ;AN000;EO. delete the file
	JMP	SHORT reserror		  ;AN000;EO.

justopen:				  ;AN000;
	call	_$CLOSE			  ;AN000;EO. pretend never happend
reserror:				  ;AN000;
	POP	AX			  ;AN000;EO. restore error code from set XA
	JMP	SHORT extexit		  ;AN000;EO.

ext_file_unfound:			  ;AN000;
	;mov	ax,2
	MOV	AX,error_file_not_found   ;AN000;EO.
	JMP	SHORT extexit		  ;AN000;EO.
ext_inval:				  ;AN000;
	;mov	ax,1
	MOV	AX,error_invalid_function ;AN000;EO.
lockoperr:	; 17/12/2022
extexit:
	jmp	SYS_RET_ERR		  ;AN000;EO.

;============================================================================
; LOCK.ASM, MSDOS 6.0, 1991
;============================================================================
; 14/07/2018 - Retro DOS v3.0
; 22/05/2019 - Retro DOS v4.0

;BREAK <$LockOper - Lock Calls>
;----------------------------------------------------------------------------
;
;   Assembler usage:
;	    MOV     BX, Handle	       (DOS 3.3)
;	    MOV     CX, OffsetHigh
;	    MOV     DX, OffsetLow
;	    MOV     SI, LengthHigh
;	    MOV     DI, LengthLow
;	    MOV     AH, LockOper
;	    MOV     AL, Request
;	    INT     21h
;
;   Error returns:
;	    AX = error_invalid_handle
;	       = error_invalid_function
;	       = error_lock_violation
;
;   Assembler usage:
;	    MOV     AX, 5C??	       (DOS 4.00)
;
;				    0? lock all
;				    8? lock write
;				    ?2 lock multiple
;				    ?3 unlock multiple
;				    ?4 lock/read
;				    ?5 write/unlock
;				    ?6 add (lseek EOF/lock/write/unlock)
;	    MOV     BX, Handle
;	    MOV     CX, count or size
;	    LDS     DX, buffer
;	    INT     21h
;
;   Error returns:
;	    AX = error_invalid_handle
;	       = error_invalid_function
;	       = error_lock_violation
;
;----------------------------------------------------------------------------

	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
_$LockOper:
	CMP	AL,1
	JA	short lock_bad_func

	PUSH	DI			       ; Save LengthLow
	call	SFFromHandle		       ; ES:DI -> SFT
	JNC	short lock_do 		       ; have valid handle
	POP	DI			       ; Clean stack
	;mov	al,6
	mov	al,error_invalid_handle
	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
;lockoperr:
	;jmp	SYS_RET_ERR
	; 17/12/2022
	jmp	short lockoperr ; jmp SYS_RET_ERR

lock_bad_func:
	;mov	byte [ss:EXTERR_LOCUS],1
	MOV	byte [SS:EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus;smr;SS Override
	;mov	al,1
	mov	al,error_invalid_function
	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
lockoperrj:
	;jmp	SYS_RET_ERR
	jmp	short lockoperr

	; 22/05/2019 - Retro DOS v4.0

	; MSDOS 6.0 
; Align_buffer call has been deleted, since it corrupts the DTA (6/5/88) P5013
; Dead code deleted, MD, 23 Mar 90

;lock_do:
;	; MSDOS 3.3
;	or	al,al
;	pop	ax
;	jz	short DOS_Lock
;DOS_Unlock:
;	;test	word [es:di+5],8000h
;	test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
;	JZ	short LOCAL_UNLOCK
;	push    ax
;	mov     ax,110Bh
;	int     2Fh	; Multiplex - NETWORK REDIRECTOR - UNLOCK REGION OF FILE
;			; BX = file handle, CX:DX = starting offset, SI = high word of size
;			; STACK: WORD low word of size, ES:DI -> SFT for file
;			; SFT DPB field -> DPB of drive containing file
;			; Return: CF set error
;	pop     bx
;	jmp     short ValChk
;
;LOCAL_UNLOCK:
;	Call	far [ss:JShare+(7*4)]	; 7 = clr_block ;smr;SS Override
;ValChk:
;	JNC	short Lock_OK
;lockerror:
;	jmp	SYS_RET_ERR
;Lock_OK:
;	;MOV	AX,[SS:Temp_VAR] ;AN000;;MS. AX= number of bytes ;smr;SS Override
;	jmp	SYS_RET_OK
;DOS_Lock:
;	;test	word [es:di+5],8000h
;	test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
;	JZ	short LOCAL_LOCK
;	;CallInstall NET_XLock,MultNET,10
;	mov     ax, 110Ah
;	int     2Fh	; Multiplex - NETWORK REDIRECTOR - LOCK REGION OF FILE
;			; BX = file handle, CX:DX = starting offset, SI = high word of size
;			; STACK: WORD low word of size, ES:DI -> SFT
;			; SFT DPB field -> DPB of drive containing file, SS = DOS CS
;			; Return: CF set error
;	JMP	short ValChk
;
;LOCAL_LOCK:
;	Call	far [ss:JShare+(6*4)]	; 6 = Set_Block ;smr;SS Override
;	JMP	short ValChk

; 17/12/2022
LOCAL_UNLOCK:
	; MSDOS 3.3
	;Call	far [ss:JShare+(7*4)]	; 7 = clr_block ;smr;SS Override
	; MSDOS 6.0
	Call	far [JShare+(7*4)]	; 7 = clr_block ;smr;SS Override
ValChk:
	JNC	short Lock_OK
lockerror:
	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;;jmp	SYS_RET_ERR
	;jmp	short lockoperrj
	; 17/12/2022
	jmp	short lockoperr	; jmp SYS_RET_ERR
Lock_OK:
	;MOV	AX,[SS:TEMP_VAR] ;AN000;;MS. AX= number of bytes ;smr;SS Override
	; 10/06/2019
	mov	ax,[TEMP_VAR]
	jmp	SYS_RET_OK

	; 22/05/2019
lock_do:
	; MSDOS 6.0
	MOV	BX,AX				; save AX
	MOV	BP,Lock_Buffer			; get DOS LOCK buffer
	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;;mov	[bp+0],dx
	;MOV	[BP+LockBuf.Lock_position],DX	; set low offset
	; 15/12/2022
	mov	[bp],dx
	;mov	[bp+2],cx
	MOV	[BP+LockBuf.Lock_position+2],CX; set high offset
	POP	CX				; get low length
	;mov	[bp+4],cx
	MOV	[BP+LockBuf.Lock_length],CX	; set low length
	;mov	[bp+6],si
	MOV	[BP+LockBuf.Lock_length+2],SI	; set high length
	MOV	CX,1				; one range

;	PUSH	CS				;
;	POP	DS				; DS:DX points to

	push	ss
	pop	ds

	MOV	DX,BP				; Lock_Buffer
	;test	al,1
	TEST	AL,UNLOCK_ALL			; function 1
	;JNZ	short DOS_Unlock		; yes
	;JMP	short DOS_Lock			; function 0
	; 17/12/2022
	; 10/06/2019
	jz	short DOS_Lock
	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;JNZ	short DOS_Unlock
	;JMP	short DOS_Lock

DOS_Unlock:
	;;test	word [es:di+5],8000h
	;test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
	test	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
	JZ	short LOCAL_UNLOCK

lock_unlock: ; 22/05/2019
	
	;CallInstall Net_Xlock,MultNET,10
	
	; MSDOS 3.3
	;mov     ax,110Bh
	;int     2Fh	; Multiplex - NETWORK REDIRECTOR - UNLOCK REGION OF FILE
			; BX = file handle, CX:DX = starting offset, SI = high word of size
			; STACK: WORD low word of size, ES:DI -> SFT for file
			; SFT DPB field -> DPB of drive containing file
			; Return: CF set error
	; MSDOS 6.0
	mov     ax,110Ah
	int     2Fh 	; Multiplex - NETWORK REDIRECTOR - LOCK REGION OF FILE
			; BX = file handle, CX:DX = starting offset, SI = high word of size
			; STACK: WORD low word of size, ES:DI -> SFT
			; SFT DPB field -> DPB of drive containing file, SS = DOS CS
			; Return: CF set error

	JMP	SHORT ValChk

; 17/12/2022
%if 0
LOCAL_UNLOCK:
	; MSDOS 3.3
	;Call	far [ss:JShare+(7*4)]	; 7 = clr_block ;smr;SS Override
	; MSDOS 6.0
	Call	far [JShare+(7*4)]	; 7 = clr_block ;smr;SS Override
ValChk:
	JNC	short Lock_OK
lockerror:
	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;jmp	SYS_RET_ERR
	jmp	short lockoperrj
Lock_OK:
	;MOV	AX,[SS:TEMP_VAR] ;AN000;;MS. AX= number of bytes ;smr;SS Override
	; 10/06/2019
	mov	ax,[TEMP_VAR]
	jmp	SYS_RET_OK
%endif

DOS_Lock:
	;;test	word [es:di+5],8000h
	;test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
	test	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
	JZ	short LOCAL_LOCK

	;CallInstall NET_XLock,MultNET,10

	mov     ax,110Ah
	int     2Fh	; Multiplex - NETWORK REDIRECTOR - LOCK REGION OF FILE
			; BX = file handle, CX:DX = starting offset, SI = high word of size
			; STACK: WORD low word of size, ES:DI -> SFT
			; SFT DPB field -> DPB of drive containing file, SS = DOS CS
			; Return: CF set error

	JMP	short ValChk

LOCAL_LOCK:
	; MSDOS 3.3
	;Call	far [ss:JShare+(6*4)]	; 6 = Set_Block ;smr;SS Override
	; MSDOS 6.0
	Call	far [JShare+(6*4)]	; 6 = Set_Block ;smr;SS Override

	JMP	short ValChk

; 14/07/2018 - Retro DOS v3.0
; LOCK_CHECK
;MSDOS 6.0 (& MSDOS 3.3)

;----------------------------------------------------------------------------
; Inputs:
;	Outputs of SETUP
;	[USER_ID] Set
;	[PROC_ID] Set
; Function:
;	Check for lock violations on local I/O
;	Retries are attempted with sleeps in between
; Outputs:
;    Carry clear
;	Operation is OK
;    Carry set
;	A lock violation detected
; Outputs of SETUP preserved
;----------------------------------------------------------------------------

	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; 22/05/2019 - Retro DOS v4.0
LOCK_CHECK:
	MOV	BX,[RetryCount]	; Number retries
LockRetry:
	push	bx		; save regs
	push	ax ; MSDOS 6.0

	;MSDOS 3.3
	;Call	far [ss:JShare+(8*4)]	; 8 = chk_block
	;MSDOS 6.0
	Call	far [JShare+(8*4)]	; 8 = chk_block

	pop	ax ; MSDOS 6.0
	pop	bx		; restrore regs
	jnc	short lc_ret_label ; There are no locks (retnc)
LockN:
	call	Idle		; wait a while
	DEC	BX		; remember a retry
	JNZ	short LockRetry	; more retries left...
	STC
lc_ret_label:
	retn

; 14/07/2018 - Retro DOS v3.0
; LOCK_VIOLATION
;MSDOS 6.0 (& MSDOS 3.3)

;----------------------------------------------------------------------------
; Inputs:
;	[THISDPB] set
;	[READOP] indicates whether error on read or write
; Function:
;	Handle Lock violation on compatibility (FCB) mode SFTs
; Outputs:
;	Carry set if user says FAIL, causes error_lock_violation
;	Carry clear if user wants a retry
;
; DS, ES, DI, CX preserved, others destroyed
;----------------------------------------------------------------------------

LOCK_VIOLATION:
	PUSH	DS
	PUSH	ES
	PUSH	DI
	PUSH	CX
	;mov	ax,21h
	MOV	AX,error_lock_violation
	;mov	byte [ALLOWED],18h
	MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
	LES	BP,[THISDPB]
	MOV	DI,1		; Fake some registers
	MOV	CX,DI
	;mov	dx,[es:bp+11]
	MOV	DX,[ES:BP+DPB.FIRST_SECTOR]
	call	HARDERR
	POP	CX
	POP	DI
	POP	ES
	POP	DS
	CMP	AL,1
	jz	short lc_ret_label ; 1 = retry, carry clear
	STC
	retn

; 14/07/2018 - Retro DOS v3.0

;----------------------------------------------------------------------------

;	do a retz to return error

	; 22/05/2019 - Retro DOS v4.0
CheckShare:
	; MSDOS 3.3
	;cmp	byte [cs:fShare],0
	;retn

	; MSDOS 6.0
	push	ds			;smr;
	;getdseg <ds>			; ds -> dosdata
	mov	ds,[cs:DosDSeg]
	cmp	byte [fShare],0
	pop	ds			;smr;
	retn
	
;============================================================================
; SHARE.ASM, MSDOS 6.0, 1991
;============================================================================
; 14/07/2018 - Retro DOS v3.0
; 22/05/2019 - Retro DOS v4.0

; SHARE_CHECK
;----------------------------------------------------------------------------
; Inputs:
;       [THISSFT] Points to filled in local file/device SFT for new
;               instance of file sf_mode ALWAYS has mode (even on FCB SFTs)
;       [WFP_START] has full path of name
;       [USER_ID] Set
;       [PROC_ID] Set
; Function:
;       Check for sharing violations on local file/device access
; Outputs:
;    Carry clear
;       Sharing approved
;    Carry set
;       A sharing violation detected
;           AX is error code
; USES    ALL but DS
;----------------------------------------------------------------------------

	; 22/05/2019 - Retro DOS v4.0
SHARE_CHECK:
	; 26/07/2019
	call	far [JShare+(1*4)] 	; 1 = MFT_Enter
shchk_retn:
	retn

; SHARE_VIOLATION
;----------------------------------------------------------------------------
; Inputs:
;       [THISDPB] Set
;       AX has error code
; Function:
;       Handle Sharing errors
; Outputs:
;       Carry set if user says FAIL, causes error_sharing_violation
;       Carry clear if user wants a retry
;
; DS, ES, DI preserved, others destroyed
;----------------------------------------------------------------------------

SHARE_VIOLATION:
	PUSH    DS
	PUSH	ES
	PUSH    DI
	MOV     byte [READOP],0		; All share errors are reading
	;mov	byte [ALLOWED],18h
	MOV     byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
	LES     BP,[THISDPB]
	MOV     DI,1			; Fake some registers
	MOV     CX,DI
	;mov	dx,[es:bp+17]
	MOV     DX,[ES:BP+DPB.DIR_SECTOR]
	call	HARDERR
	POP     DI
	POP	ES
	POP     DS
	CMP     AL,1
	jz	short shchk_retn	; 1 = retry, carry clear
	STC
	retn

;----------------------------------------------------------------------------
;   ShareEnd - terminate sharing info on a particular SFT/UID/PID. This does
;       NOT perform a close, it merely asserts that the sharing information
;       for the SFT/UID/PID may be safely released.
;
;   Inputs:     ES:DI points to an SFT
;   Outputs:    None
;   Registers modified: all except DS,ES,DI
;----------------------------------------------------------------------------

ShareEnd:
	; 26/07/2019
	call	far [JShare+(2*4)]	; 2 = MFTClose
	retn

;Break <ShareEnter - attempt to enter a node into the sharing set>
;----------------------------------------------------------------------------
;   ShareEnter - perform a retried entry of a nodde into the sharing set. If
;   the max number of retries is exceeded, we notify the user via int 24.
;
;   Inputs:     ThisSFT points to the SFT
;               WFP_Start points to the WFP
;   Outputs:    Carry clear => successful entry
;               Carry set => failed system call
;   Registers modified: all
;----------------------------------------------------------------------------

ShareEnter:
	push	cx
retry:
	mov     cx,[RetryCount]
attempt:
	les     di,[THISSFT]		; grab sft
	XOR     AX,AX
 	;mov	[es:di+51],axfff
	MOV     [ES:DI+SF_ENTRY.sf_MFT],AX ; indicate free SFT
	push	cx
	call    SHARE_CHECK             ; attempt to enter into the sharing set
	pop	cx
	jnc	short done		; success, let the user see this
	call	Idle                    ; wait a while
	loop    attempt                 ; go back for another attempt
	call    SHARE_VIOLATION         ; signal the problem to the user
	jnc	short retry		; user said to retry, go do it
done:
	pop	cx
	retn

;============================================================================
; EXEPATCH.ASM (MSDOS 6.0, 1991)
;============================================================================
; 29/04/2019 - Retro DOS 4.0

;** EXEPATCH.ASM 
;----------------------------------------------------------------------------
;	Contains the foll:
;
;		- code to find and overlay buggy unpack code
;		- new code to be overlayed on buggy unpack code 
;		- old code sequence to identify buggy unpack code
;
;	Revision history:
;
;		Created: 5/14/90
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
;
; M020 : Fix for rational bug - for details see routine header
; M028 : 4b04 implementation
; M030 : Fixing bug in EXEPACKPATCH (EXEC_CS is an un-relocated value)
; M032 : set turnoff bit only if DOS in HMA.
; M033 : if IP < 2 then not exepacked.
; M046 : support for a 4th version of exepacked files.
; M068 : support for copy protected apps.
; M071 : use A20OFF_COUNT of 10.
;
;----------------------------------------------------------------------------

PATCH1_COM_OFFSET	EQU	06CH
PATCH1_OFFSET		EQU	028H
PATCH1_CHKSUM		EQU	0EF4EH
CHKSUM1_LEN		EQU	11CH/2 ; 142

PATCH2_COM_OFFSET	EQU	076H
PATCH2_OFFSET		EQU	032H

	; The strings that start at offset 076h have two possible 
	; check sums that are defined as PATCH2_CHKSUM PATCH2A_CHKSUM

PATCH2_CHKSUM		EQU	78B2H
CHKSUM2_LEN		EQU	119H/2
PATCH2A_CHKSUM		EQU	1C47H		; M046
CHKSUM2A_LEN		EQU	103H/2		; M046

PATCH3_COM_OFFSET	EQU	074H
PATCH3_OFFSET		EQU	032H
PATCH3_CHKSUM		EQU	4EDEH
CHKSUM3_LEN		EQU	117H/2

;**	Data structure passed for ExecReady call
;
;struc ERStruc
; .ER_Reserved:	resw	1	; reserved, should be zero
; .ER_Flags:	resw	1
; .ER_ProgName:	resd	1	; ptr to ASCIIZ str of prog name
; .ER_PSP:	resw	1	; PSP of the program
; .ER_StartAddr: resd	1	; Start CS:IP of the program
; .ER_ProgSize:	resd	1	; Program size including PSP
; .size:
;endstruc

;DOSCODE SEGMENT

	; 22/05/2019 - Retro DOS v4.0
	; DOSCODE:B3DDh (MSDOS 6.21, MSDOS.SYS)

	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; DOSCODE:B37Ah (MSDOS 5.0, MSDOS.SYS)

; M028 - BEGIN

;--------------------------------------------------------------------------
;
;	Procedure Name		: ExecReady
;
;	Input			: DS:DX -> ERStruc (see exe.inc)
;
;--------------------------------------------------------------------------

ExecReady:
	mov	si,dx			; move the pointer into a friendly one
	;;test	word [si+2],1
	; 17/12/2022
	test	byte [si+ERStruc.ER_Flags],ER_EXE ; 1
	;test	word [si+ERStruc.ER_Flags],ER_EXE ; COM or EXE ?
	jz	short er_setver		; only setver for .COM files

	;mov	ax,[si+8]
	mov	ax,[si+ERStruc.ER_PSP]
	add	ax,10h
	mov	es,ax

	;mov	cx,[si+10]
	mov	cx,[si+ERStruc.ER_StartAddr]   ; M030
	;mov	cx,[si+12]
	mov	ax,[si+ERStruc.ER_StartAddr+2] ; M030

	;call	[ss:FixExePatch]
	call	word [ss:FixExePatch] ; 28/12/2022
	
	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;call	[ss:Rational386PatchPtr]

er_setver:
	;;test	word [si+2],2		; Q: is this an overlay
	; 17/12/2022
	test	byte [si+ERStruc.ER_Flags],ER_OVERLAY ; 2
	;test	word [si+ERStruc.ER_Flags],ER_OVERLAY
	jnz	short er_chkdoshi	; Y: set A20OFF_COUNT if DOS high
					; N: set up lie version first
	push	ds
	push	si
	;lds	si,[si+4]
	lds	si,[si+ERStruc.ER_ProgName]
	call	Scan_Execname1
	call	Scan_Special_Entries
	pop	si
	pop	ds
	;mov	es,[si+8]
	mov	es,[si+ERStruc.ER_PSP]
	mov	ax,[ss:SPECIAL_VERSION]
	mov	[es:PDB.Version],ax

er_chkdoshi:
	cmp	byte [ss:DosHasHMA],0	; M032: Q: is dos in HMA (M021)
	je	short er_done		; M032: N: done

					; M068 - Start
	;mov	ax,[si+8]
	mov	ax,[si+ERStruc.ER_PSP]	; ax = PSP

	;or	byte [ss:DOS_FLAG],4
	or	byte [ss:DOS_FLAG],EXECA20OFF ; Set bit to signal int 21
					; ah = 25 & ah= 49. See dossym.inc 
					; under TAG M003 & M009 for 
					; explanation
	;;test	word [si+2],1
	; 17/12/2022
	test	byte [si+ERStruc.ER_Flags],ER_EXE ; 1
	;test	word [si+ERStruc.ER_Flags],ER_EXE ; Q: COM file
	jnz	short er_setA20		; N: inc a20off_count, set 
					;    a20off_psp and ret
   	push	ds
	mov	ds,ax			; DS = load segment of com file.
	call	IsCopyProt		; check if copy protected
	pop	ds

er_setA20:
	; We need to inc the A20OFF_COUNT here. Note that if the count
	; is non-zero at this point it indicates that the A20 is to be 
	; turned off for that many int 21 calls made by the app. In 
	; addition the A20 has to be turned off when we exit from this 
	; call. Hence the inc.

	inc	byte [ss:A20OFF_COUNT]		
	mov	[ss:A20OFF_PSP],ax	; set the PSP for which A20 is to be
					; turned OFF.
er_done:				; M068 - End
	xor	ax,ax
	retn

; M028 - END


; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
%if 0

;----------------------------------------------------------------------------
;
; procedure : Rational386Patch
;
; Older versions of the Rational DOS Extender have several bugs which trash
; 386 registers (usually just the high word of 32 bit registers) during
; interrupt processing. Lotus 123 3.1+ is a popular application that uses a
; version of the Rational extender with the 32 bit register trashing bugs.
;
; This routine applies patches to the Rational DOS Extender to work around
; most of the register trashing bugs.
;
; Note that there are additional register trashing bugs not fixed by these
; patches. In particular, the high word of ESP and the FS and GS registers
; may be modified on interrupts.
;
; There are two different Rational DOS Extender patchs in this module.
; Rational386Patch is to correct 386 register trashing bugs on 386 or later
; processors. This patch code is executed when MS-DOS is running on a 386
; or later processor, regardless of whether MS-DOS is running in the HMA
; or not.
;
; The other Rational patch routine (RationalPatch, below) fixes a register
; trashing problem on 286 processors, and is only executed if MS-DOS is
; running in the HMA.
;
; This patch detection and replacement is based on an example supplied by
; Ben Williams at Rational.
;
;----------------------------------------------------------------------------

; 22/05/2019 - Retro DOS v4.0
; DOSCODE:B448h (MSDOS 6.21, MSDOS.SYS)

;----------------------------------------------------------------------------
;
; INPUT : ES = segment where program got loaded
;
;----------------------------------------------------------------------------

rpFind1:
	db	0FAh, 0E4h, 21h, 60h, 33h, 0C0h, 0E6h, 43h, 8Bh, 16h

rpFind1Len equ	$ - rpFind1

;	cli
;	in	al, 21h
;	pusha
;	xor	ax, ax
;	out	43h, al
;	mov	dx, ...

rpFind1a:
	db	0B0h, 0Eh, 0E6h, 37h, 33h, 0C0h, 0E6h, 0F2h

rpFind1aLen equ	$ - rpFind1a

;	mov	al, 0Eh
;	out	37h, al
;	xor	ax, ax
;	out	0F2h, al

; bug # 1 -- loss of high EAX on 386+ if not VCPI or DPMI

rpFind2:
	db	0Fh, 20h, 0C0h

rpFind2Len equ	$ - rpFind2

;	mov	eax, cr0	;may be preceeded by PUSH CX (51h)

rpFind3:
	db	0Fh, 22h, 0C0h, 0EAh

rpFind3Len equ	$ - rpFind3

;	mov	cr0, eax	;may be preceeded by POP CX (59h)
;	jmp	far ptr xxx	;change far ptr to go to replace3
;	mov	ss, bx		;8E D3 ... and come back at or after this

; note, there is no rpRepl1 string

rpRepl2:
 	db	66h, 50h, 51h, 0Fh, 20h, 0C0h

rpRepl2Len equ	$ - rpRepl2

;	push	eax
;	push	cx
;	mov	eax, cr0

rpRepl3:
	db	8Eh, 0D3h, 59h, 66h, 58h

rpRepl3Len equ	$ - rpRepl3

;	mov	ss, bx
;	pop	cx
;	pop	eax

; bug # 2 -- loss of high EAX and ESI on 386+ only if VCPI

rpFind4:
	db	93h, 58h, 8Bh, 0CCh

rpFind4Len equ	$ - rpFind4

;	xchg	bx, ax
;	pop	ax
;	mov	cx, sp

rpFind5:
	db	0B8h, 0Ch, 0DEh, 0CDh, 67h, 8Bh, 0E1h, 0FFh, 0E3h

rpFind5Len equ	$ - rpFind5

;	mov	ax, DE0Ch
;	int	67h
;	mov	sp, cx
;	jmp	bx

rpRepl4:
	db	93h, 58h, 8Bh, 0CCh
	db	02Eh, 066h, 0A3h

rpRepl4o1Len equ $ - rpRepl4

	db	00h, 00h
	db	02Eh, 066h, 89h, 36h

rpRepl4o2Len equ $ - rpRepl4

	db	00h, 00h

rpRepl4Len equ	$ - rpRepl4

;	xchg	bx, ax
;	pop	ax
;	mov	cx, sp
;	mov	dword ptr cs:[xxxx], eax
;	mov	dword ptr cs:[xxxx], esi

rpRepl5:
	db	8Bh, 0E1h
	db	2Eh, 66h, 0A1h

rpRepl5o1Len equ $ - rpRepl5

	db	00h, 00h
	db	2Eh, 66h, 8Bh, 36h

rpRepl5o2Len equ $ - rpRepl5

	db	00h, 00h
	db	0FFh, 0E3h

rpRepl5Len equ	$ - rpRepl5

;	mov	sp, cx
;	mov	eax, dword ptr cs:[xxxx]
;	mov	esi, dword ptr cs:[xxxx]
;	jmp	bx

; bug # 3 -- loss of high EAX, EBX, ECX, EDX on 386+ only if VCPI

rpFind6:
	db	0FAh, 52h, 51h

rpFind6Len equ	$ - rpFind6

;	cli
;	push	dx
;	push	cx

rpFind7a:
	db	0B8h, 0Ch, 0DEh, 66h, 26h, 0FFh, 1Eh

rpFind7aLen equ	$ - rpFind7a

;	mov	ax, 0DE0Ch
;	call	fword ptr es:[xxxx]

rpFind7b:
	db	59h, 5Ah, 5Bh

rpFind7bLen equ	$ - rpFind7b

;	pop	cx
;	pop	dx
;	pop	bx

rpRepl6 :
	db	0FAh, 66h, 50h, 66h, 53h, 66h, 51h, 66h, 52h

rpRepl6Len equ	$ - rpRepl6

;	cli
;	push	eax
;	push	ebx
;	push	ecx
;	push	edx

rpRepl7:
	db	66h, 5Ah, 66h, 59h, 66h, 5Bh, 66h, 58h, 5Bh

rpRepl7Len equ	$ - rpRepl7

;	pop	edx
;	pop	ecx
;	pop	ebx
;	pop	eax
;	pop	bx

; bug # 4 -- loss of high EAX and EBX on 386+ only if VCPI

rpFind8:
 	db	60h, 06h, 1Eh, 0B8h, 00h, 00h, 8Eh, 0D8h

rpFind8Len equ	$ - rpFind8

;	pusha
;	push	es
;	push	ds
;	mov	ax, dgroup	;jump back to here from replace8
;	mov	ds, ax

rpFind9 :
	db	1Fh, 07h, 61h

rpFind9Len equ	$ - rpFind9

;	pop	ds
;	pop	es
;	popa

rpRepl8:
 	db	66h, 60h, 06h, 1Eh

rpRepl8Len equ	$ - rpRepl8

;	pushad
;	push	es
;	push	ds

rpRepl9:
	db	1Fh, 07h, 66h, 61h, 0C3h

rpRepl9Len equ	$ - rpRepl9

;	pop	ds
;	pop	es
;	popad
;	retn			;no need to jmp back to main-line

;----------------------------------------------------------------------------

struc SearchPair
 .sp_off1: resw 1	; offset of 1st search string
 .sp_len1: resw 1	; length of 1st search string
 .sp_off2: resw 1	; 2nd string
 .sp_len2: resw 1	; 2nd string
 .sp_diff: resw 1	; max difference between offsets
 .size:
endstruc

;rpBug1Strs SearchPair	<offset rpFind2, rpFind2Len, offset rpFind3, rpFind3Len, 20h>

rpBug1Strs:
	dw	rpFind2
	dw	rpFind2Len ; 3
	dw	rpFind3
	dw	rpFind3Len ; 4
	dw	20h

;rpBug2Strs SearchPair	<offset rpFind4, rpFind4Len, offset rpFind5, rpFind5Len, 80h>

rpBug2Strs:
	dw	rpFind4
	dw	rpFind4Len ; 4
	dw	rpFind5
	dw	rpFind5Len ; 9
	dw	80h

;rpBug3Strs SearchPair	<offset rpFind6, rpFind6Len, offset rpFind7a, rpFind7aLen, 80h>

rpBug3Strs:
	dw	rpFind6
	dw	rpFind6Len ; 3
	dw	rpFind7a
	dw	rpFind7aLen ; 7
	dw	80h

;rpBug4Strs SearchPair	<offset rpFind8, 4, offset rpFind9, rpFind9Len, 80h>

rpBug4Strs:
	dw	rpFind8
	dw	4
	dw	rpFind9
	dw	rpFind9Len ; 3
	dw	80h

;----------------------------------------------------------------------------

struc StackVars
 .sv_wVersion:	resw 1		; Rational extender version #
 .sv_cbCodeSeg: resw 1		; code seg size to scan
 .sv_pPatch:	resw 1		; offset of next avail patch byte
 .size:
endstruc

;----------------------------------------------------------------------------

; 22/05/2019 - Retro DOS v4.0

Rational386Patch:
	; Do a few quick checks to see if this looks like a Rational
	; Extended application. Hopefully this will quickly weed out
	; most non Rational apps.

	cmp	word [es:0],395		; version number goes here - versions
	jae	short rp3QuickOut	;   3.95+ don't need patching

	cmp	word [es:0Ch],20h	; always has this value here
	jne	short rp3QuickOut

	push	ax

	mov	ax,18h 			; extender has 18h at
	cmp	[es:24],ax		;   offsets 24, 28, & 36
	jne	short rp3QO_ax
	cmp	[es:28],ax
	jne	short rp3QO_ax
	cmp	[es:36],ax
	je	short rp3Maybe
rp3QO_ax:
	pop	ax
rp3QuickOut:
	retn

; It might be the rational extender, do more extensive checking

rp3Maybe:
	cld
	push	bx			; note ax pushed above
	push	cx
	push	dx
	push	si
	push	di
	push	es
	push	ds			; we use all of them
	push	bp
	sub	sp,StackVars.size  ; 6	; make space for stack variables
	mov	bp,sp

	push	cs
	pop	ds

	mov	ax,[es:0]		; save version #
	;mov	[bp+StackVars.sv_wVersion],ax
	mov	[bp],ax	
					; check that binary version # matches
	call	VerifyVersion		;   ascii string
	jne	short rp3Exit_j

; Looks like this is it, find where to put the patch code.  The
; patch will be located on top of Rational code specific to 80286
; processors, so these patchs MUST NOT be applied if running on
; an 80286 system.

	; Rational says the code to patch will never be beyond offset 46xxh

	mov	cx,4500h		; force search len to 4700h (searches
	;mov	[bp+2],cx
	mov	[bp+StackVars.sv_cbCodeSeg],cx	; start at offset 200h)

	mov	es,[es:20h]		; es=code segment

	mov	si,rpFind1		; string to find
	mov	dx,rpFind1Len ; 10	; length to match
	call	ScanCodeSeq		; look for code seq
	jz	short rpGotPatch

; According to Rational, some very old versions of the extender may not
; have the find1 code sequence. If the find1 code wasn't found above,
; try an alternative patch area which is on top of NEC 98xx switching code.

	mov	si,rpFind1a
	mov	dx,rpFind1aLen  ;8
	call	ScanCodeSeq
	jz	short rpGotPatch

rp3Exit_j:
	jmp	rp3Exit

; Found the location to write patch code! DI = offset in code seg.

rpGotPatch:
	;mov	[bp+4],di
	mov	[bp-StackVars.sv_pPatch],di	; save patch pointer

;----------------------------------------------------------------------------
; Bug # 1 -- loss of high EAX on 386+ if not VCPI or DPMI

	;cmp	word [bp+0],381
	;cmp	word [bp+StackVars.sv_wVersion],381 ; only need bug 1 if version
	cmp	word [bp],381
	jae	short rpBug2			;   < 3.81

	mov	bx,rpBug1Strs			; locate find2 & find3 code
	call	FindBadCode
	jc	short rpBug2

; si = rpFind2 offset, di = rpFind3 offset

	push	di
	mov	di,si				; rpFind2 offset
	mov	dx,rpFind2Len ; 3

	cmp	byte [es:di-1],51h	 	; find2 preceeded by push cx?
	jne	short rp_no_cx

	dec	di				;   yes, gobble up push cx too
	inc	dx
rp_no_cx:
	mov	si,rpRepl2			; patch out find2 sequence
	mov	cx,rpRepl2Len  ; 6
	call	GenPatch

	pop	di				; rpFind3 offset
	cmp	byte [es:di-1],59h 		; find3 preceeded by pop cx?
	jne	short rp_no_cx2

	mov	byte [es:di-1],90h		;   yes, no-op it
rp_no_cx2:
	;mov	ax,[bp+4]
	mov	ax,[bp+StackVars.sv_pPatch]	; change offset of far jmp
	;mov	[es:di+4],ax
	mov	[es:di+rpFind3Len],ax		;   to go to patch code

	push	di				; save find3 offset
	mov	si,rpRepl3			; copy repl3 to patch area
	mov	cx,rpRepl3Len ; 5
	call	CopyPatch

	pop	bx				; find3 offset
	add	bx,rpFind3Len+4	 ; 8		; skip over find3 and far jmp
	call	GenJump 			; jmp back from patch area
	;mov	[bp+4],di
	mov	[bp+StackVars.sv_pPatch], di	;   to main-line, update patch
						;   area pointer

;----------------------------------------------------------------------------
; Bug # 2 -- loss of high regs on 386+ under VCPI only

rpBug2:
	mov	bx,rpBug2Strs			; locate find4 & find5 code
	call	FindBadCode
	jc	short rpBug3

; si = rpFind4 offset, di = rpFind5 offset

	;push	word [bp+4]
	push	word [bp+StackVars.sv_pPatch]	; save current patch pointer
						;   (where repl4 goes)
	push	di				; save find5 offset

	mov	di,si
	mov	dx,rpFind4Len ; 4
	mov	si,rpRepl4
	mov	cx,rpRepl4Len ; 15
	call	GenPatch			; patch out find4 code

	pop	di				; find5 offset
	add	di,5				; keep 5 bytes of find5 code
	;mov	bx,[bp+4]
	mov	bx,[bp+StackVars.sv_pPatch]	; jump to patch area
	push	bx				; save repl5 location
	call	GenJump

	mov	si,rpRepl5			; copy repl5 code to patch
	mov	cx,rpRepl5Len  ; 15		;   area -- it has a jmp bx
	call	CopyPatch			;   so no need to jmp back to
						;   main-line code

; patches have been made, now update the patch code to store/load dwords just
; after the code in the patch area

	pop	di				; repl5 location
	pop	si				; repl4 location

	;mov	ax,[bp+4]
	mov	ax,[bp+StackVars.sv_pPatch]	; (where dwords go)

	;mov	[es:si+7],ax
	mov	[es:si+rpRepl4o1Len],ax		; offset for EAX
	;mov	[es:di+5],ax
	mov	[es:di+rpRepl5o1Len],ax
	add	ax,4
	;mov	[es:si+0Dh],ax
	mov	[es:si+rpRepl4o2Len],ax		; offset for ESI
	;mov	[es:di+0Bh],ax
	mov	[es:di+rpRepl5o2Len],ax

	;add	word [bp+4],8
	add	word [bp+StackVars.sv_pPatch],8	; reserve space for 2 dwords in
						; patch area

;----------------------------------------------------------------------------
; Bug # 3 -- loss of high regs on 386+ under VCPI only

rpBug3:
	mov	bx,rpBug3Strs			; locate find6 & find7a code
	call	FindBadCode
	jc	short rpBug4

	;add	di,9
	add	di,rpFind7aLen + 2		; skip over offset in find7a
	push	si				;   code and locate find7b
	mov	si,rpFind7b			;   sequence
	mov	dx,rpFind7bLen ; 3
	call	ScanCodeSeq_di
	pop	si
	jnz	short rpBug4

	push	di				; save find7b code offset

	mov	di,si
	mov	dx,rpFind6Len ; 3
	mov	si,rpRepl6
	mov	cx,rpRepl6Len ; 9
	call	GenPatch			; patch out find6 code

	pop	di
	mov	dx,rpFind7bLen ; 3
	mov	si,rpRepl7
	mov	cx,rpRepl7Len ; 9
	call	GenPatch			; patch out find7b code

;----------------------------------------------------------------------------
; Bug # 4 -- loss of high regs on 386+ under VCPI only

rpBug4:
	;cmp	word [bp+0],360
	;cmp	word [bp+StackVars.sv_wVersion],360 ; only applies if 
	cmp	word [bp],360
	jbe	short rp3Exit 			; version > 3.60 and < 3.95

	mov	bx,rpBug4Strs			; locate find8 & find9 code
	call	FindBadCode
	jc	short rp3Exit

	push	di				; save find9 code offset

	mov	di,si
	mov	dx,3
	mov	si,rpRepl8
	mov	cx,rpRepl8Len ; 4
	call	GenPatch			; patch out find8 code

	pop	di				; find9 offset
	;mov	bx,[bp+4]
	mov	bx,[bp+StackVars.sv_pPatch]	; patch find9 to jmp to
	call	GenJump 			;   patch area

	mov	si,rpRepl9			; copy replacement code to
	mov	cx,rpRepl9Len ; 5		;   patch area--it does a RET
	call	CopyPatch			;   so no jmp back to main-line

rp3Exit:
	add	sp,StackVars.size
	pop	bp
	pop	ds
	pop	es
	pop	di
	pop	si
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	retn

;----------------------------------------------------------------------------
;
; FindBadCode
;
; Searches Rational code segment looking for a pair of find strings (all
; patches have at least two find strings).
;
; Entry:
;	ES    = code segment to search
;	DS:BX = search pair structure for this search
;	[bp].sv_cbCodeSeg = length of code seg to search
;
; Exit:
;	CY flag clear if both strings found, and
;	SI    = offset in ES of 1st string
;	DI    = offset in ES of 2nd string
;	CY set if either string not found, or strings too far apart
;
; Used:
;	CX
;
;----------------------------------------------------------------------------

;struc SearchPair
; .sp_off1: resw 1	; offset of 1st search string
; .sp_len1: resw 1	; length of 1st search string
; .sp_off2: resw 1	; 2nd string
; .sp_len2: resw 1	; 2nd string
; .sp_diff: resw 1	; max difference between offsets
; .size:
;endstruc

FindBadCode:
	;mov	cx,[bp+2]
	mov	cx,[bp+StackVars.sv_cbCodeSeg]	; search length

	mov	si,[bx]	; mov si,[bx+0]
	;mov	si,[bx+Searchpair.sp_off1] ; ds:si -> search string
	
	;mov	dx,[bx+2]
	mov	dx,[bx+SearchPair.sp_len1] ; dx = search len
	call	ScanCodeSeq
	jnz	short fbc_error		; done if 1st not found

	push	di			; save 1st string offset

	;mov	si,[bx+4]
	mov	si,[bx+SearchPair.sp_off2]
	;mov	dx,[bx+6]
	mov	dx,[bx+SearchPair.sp_len2]
	call	ScanCodeSeq_di		; don't change flags after this!

	pop	si			; restore 1st string offset
	jnz	short fbc_error

	mov	ax,di			; sanity check that
	sub	ax,si			;   si < di && di - si <= allowed diff
	jc	short fbc_error
	;cmp	ax,[bx+8]
	cmp	ax,[bx+SearchPair.sp_diff]
	ja	short fbc_error

	clc
	retn

fbc_error:
	stc
	retn

;----------------------------------------------------------------------------
;
; GenPatch
;
; Generate a patch sequence. 1) insert a jump at the buggy code location
; (jumps to the patch code area), 2) copy the selected patch code to the
; patch area, 3) insert a jump from the patch area back to the main-line
; code.
;
; Entry:
;	ES:DI = start of buggy code to be patched
;	DX    = length of buggy code to be patched
;	DS:SI = replacement patch code
;	CX    = length of replacement patch code
;	[bp].sv_pPatch = offset in ES of where to copy patch code
;
; Exit:
;	DI, [bp].sv_pPatch = byte after generated patch code
;
; Used:
;	AX, BX, SI, Flags
;
;----------------------------------------------------------------------------

GenPatch:
	push	di			;save offset of buggy code

	;mov	bx,[bp+4]
	mov	bx,[bp+StackVars.sv_pPatch]
					;jump from buggy code to patch area
	call	GenJump

	call	CopyPatch		;copy replacement code to patch area

	pop	bx			;offset of buggy code + buggy code
	add	bx,dx			;  length = return from patch offset

	call	GenJump 		;jump from patch area back to main-
	;mov	[bp+4],di
	mov	[bp+StackVars.sv_pPatch],di
					;  line code, update patch pointer
	retn

;----------------------------------------------------------------------------
;
; CopyPatch
;
; Copies patch code to patch location.
;
; Entry:
;	DS:SI = patch code to be copied
;	ES    = segment of code to patch
;	CX    = length of code to copy
;	[bp].sv_pPatch = offset in ES of where to copy patch code
;
; Exit:
;	DI, [bp].sv_pPatch = byte after copied patch code
;
; Used:
;	SI, Flags
;
;----------------------------------------------------------------------------

CopyPatch:
	push	cx
	;mov	di,[bp+4]
	mov	di,[bp+StackVars.sv_pPatch] ;patch pointer is the dest offset
	cld
	rep movsb
	pop	cx
	;mov	[bp+4],di
	mov	[bp+StackVars.sv_pPatch],di ;update net pointer location
	retn

;----------------------------------------------------------------------------
;
; GenJump
;
; Generates a rel16 JMP instruction at location 'from' to location 'to'.
;
; Entry:
;	ES:DI = from location (where to put jmp instruction)
;	BX    = to location (where to jump to)
;
; Exit:
;	DI = byte after generated jump
;
; Used:
;	AX
;
;----------------------------------------------------------------------------

GenJump:
	mov	al,0E9h		; jmp rel16 opcode
	stosb

	mov	ax,bx		; calc offset to 'to' location
	sub	ax,di
	sub	ax,2

	stosw			; output offset

	retn

;----------------------------------------------------------------------------
;
; ScanCodeSeq
;
; Looks for a pattern pointed to by DS:SI & len DX in ES:200 to ES:200+CX-1
;
; returns in ES:DI the start of the pattern if Zero flag is set
;
;----------------------------------------------------------------------------

ScanCodeSeq:
	mov	di,200h
ScanCodeSeq_di:
	push	cx
	sub	cx,dx
	inc	cx
scsagain:
	push	si
	push	di
	push	cx
	mov	cx,dx
	rep	cmpsb
	pop	cx
	pop	di
	pop	si
	je	short scsfound
	inc	di
	loop	scsagain
scsfound:
	pop	cx
vvexit:		; 18/12/2022
	retn
	
;----------------------------------------------------------------------------
;
; VerifyVersion
;
; Checks whether the binary version from ES:0 matches the ASCII version
; from ES:2A.
;
;       Entry: AX = binary version number 
;       Exit : Z flag set if version numbers match
;
;----------------------------------------------------------------------------

VerifyVersion:
	mov	si,[es:2Ah]		; offset of version number
					;  in ascii
	mov	bl,10
	add	si,3			; point to last digit

	call	VVDigit
	jne	short vvexit
	call	VVDigit
	jne	short vvexit
	cmp	byte [es:si],'.'
	jne	short vvexit
	dec	si
	;call	VVDigit
	; 18/12/2022
	;jmp	short VVDigit
;vvexit:
	;retn
VVDigit:
	div	bl
	add	ah,'0'
	dec	si
	cmp	[es:si+1],ah
	mov	ah,0			; do not xor or sub we need Z
	retn

%endif

;-----------------------------------------------------------------------

; 23/05/2019 - Retro DOS v4.0
; DOSCODE:B702h (MSDOS 6.21, MSDOS.SYS)

; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:B3E0h (MSDOS 5.0, MSDOS.SYS)

exepatch_start:	 ; label byte

	; The following is the code that'll be layed over the buggy unpack
	; code.
str1:
	db  06h	  		;push	es		 
	db  8Ch,0D8h		;mov	ax,ds 

first_stop equ	$-str1
			
	db  2Bh, 0C2h		;sub	ax, dx			

first:  ; label	byte

	db  8Eh,0D8h		;mov	ds,ax			
	db  8Eh,0C0h		;mov	es,ax			
	db  0BFh,0Fh,00h	;mov	di,000FH
	db  57h	    		;push	di
	db  0B9h,10h,00h	;mov	cx,0010H
	db  0B0h,0FFh 		;mov	al,0FFH 		
	db  0F3h,0AEh 		;repz	scasb			
	db  47h	    		;inc	di			
	db  8Bh,0F7h  		;mov	si,di			
	db  5Fh	    		;pop	di
	db  58h	    		;pop	ax

second_stop equ	$-first

	db  2Bh,0C2h  		;sub	ax, dx			

second: ; label	byte

	db  8Eh,0C0h  		;mov	es,ax			
		    		;NextRec:				
	db  0B9h,04h,02h	;mov	cx, 0204h
		    		;norm_agn:				
	db  8Bh,0C6h		;mov	ax,si			
	db  0F7h,0D0h		;not	ax		
	db  0D3h,0E8h		;shr	ax,cl		
	db  74h,13h		;jz	short SI_ok			
	db  8Ch,0DAh		;mov	dx,ds			
	db  83h,0CEh,0F0h	;or	si,0FFF0H
	db  2Bh,0D0h		;sub	dx,ax			
	db  73h,08h		;jnc	short SItoDS			
	db  0F7h,0DAh		;neg	dx			
	db  0D3h,0E2h		;shl	dx,cl			
	db  2Bh,0F2h		;sub	si,dx			
	db  33h,0D2h		;xor	dx,dx			
				;SItoDS: 				
	db  8Eh,0DAh		;mov	ds,dx		
				;SI_ok:					
	db  87h,0F7h		;xchg	si,di			
	db  1Eh			;push	ds			
	db  06h			;push	es			
	db  1Fh			;pop	ds			
	db  07h			;pop	es			
	db  0FEh,0CDh		;dec	ch			
	db  75h,0DBh		;jnz	short norm_agn		
	db  0ACh		;lodsb			
	db  92h			;xchg	dx,ax
	db  4Eh			;dec	si
	db  0ADh		;lodsw			
	db  8Bh,0C8h		;mov	cx,ax		
	db  46h			;inc	si		
	db  8Ah,0C2h		;mov	al,dl		
	db  24h,0FEh		;and	al,0FEH		
	db  3Ch,0B0h		;cmp	al,RPTREC
	db  75h,05h		;jne	short TryEnum
	db  0ACh		;lodsb				
	db  0F3h,0AAh		;rep stosb			

;	db  0EBh,07h,90h	;jmp	short TryNext
	db  0EBh,06h		;jmp	short TryNext

				;TryEnum:
	db  3Ch,0B2h		;cmp	al,ENMREC
	db  75h,6Ch		;jne	short CorruptExe		
	db  0F3h,0A4h		;rep movsb			
				;TryNext:

	db  92h			;xchg	dx,ax
;	db  8Ah,0C2h		;mov	al,dl			

	db  0A8h,01h		;test	al,1			
	db  74h,0B9h		;jz	short NextRec			
	db  90h,90h		;nop,nop
	
last_stop equ $-second
size_str1 equ $-str1

	; The following is the code that we need to look for in the exe
	; file.

scan_patch1: ; label byte

	db  8Ch,0C3h		;mov	bx,es			
	db  8Ch,0D8h		;mov	ax,ds
	db  2Bh,0C2h		;sub	ax,dx
	db  8Eh,0D8h		;mov	ds,ax			
	db  8Eh,0C0h		;mov	es,ax			
	db  0BFh,0Fh,00h	;mov	di,000FH
	db  0B9h,10h,00h	;mov	cx,0010H
	db  0B0h,0FFh		;mov	al,0FFH
	db  0F3h,0AEh		;repz	scasb			
	db  47h			;inc	di			
	db  8Bh,0F7h		;mov	si,di
	db  8Bh,0C3h		;mov	ax,bx			
	db  2Bh,0C2h		;sub	ax, dx
	db  8Eh,0C0h		;mov	es,ax
	db  0BFh,0Fh,00h	;mov	di,000FH
				;NextRec:
	db  0B1h,04h		;mov	cl,4
	db  8Bh,0C6h		;mov	ax,si
	db  0F7h,0D0h		;not	ax		
	db  0D3h,0E8h		;shr	ax,cl		
	db  74h,09h		;jz	short SI_ok
	db  8Ch,0DAh		;mov	dx,ds
	db  2Bh,0D0h		;sub	dx,ax
	db  8Eh,0DAh		;mov	ds,dx		
	db  83h,0CEh,0F0h	;or	si,0FFF0H	       
	       			;SI_ok:
	db  8Bh,0C7h		;mov	ax,di		
	db  0F7h,0D0h		;not	ax
	db  0D3h,0E8h		;shr	ax,cl
	db  74h,09h		;jz	short DI_ok
	db  8Ch,0C2h		;mov	dx,es
	db  2Bh,0D0h		;sub	dx,ax
	db  8Eh,0C2h		;mov	es,dx
	db  83h,0CFh,0F0h	;or	di,0FFF0H
				;DI_ok:

size_scan_patch1 equ $-scan_patch1

scan_patch2: ; label byte
			
	db  8Ch,0C3h		;mov	bx,es			
	db  8Ch,0D8h		;mov	ax,ds
	db  48h			;dec	ax
	db  8Eh,0D8h		;mov	ds,ax			
	db  8Eh,0C0h		;mov	es,ax			
	db  0BFh,0Fh,00h	;mov	di,000FH
	db  0B9h,10h,00h	;mov	cx,0010H
	db  0B0h,0FFh		;mov	al,0FFH
	db  0F3h,0AEh		;repz	scasb			
	db  47h			;inc	di			
	db  8Bh,0F7h		;mov	si,di
	db  8Bh,0C3h		;mov	ax,bx			
	db  48h			;dec	ax
	db  8Eh,0C0h		;mov	es,ax
	db  0BFh,0Fh,00h	;mov	di,000FH		
				;NextRec:
	db  0B1h,04h		;mov	cl,4
	db  8Bh,0C6h		;mov	ax,si
	db  0F7h,0D0h		;not	ax		
	db  0D3h,0E8h		;shr	ax,cl		
	db  74h,0Ah		;jz	short SI_ok
	db  8Ch,0DAh		;mov	dx,ds
	db  2Bh,0D0h		;sub	dx,ax
	db  8Eh,0DAh		;mov	ds,dx		
	db  81h,0CEh,0F0h,0FFh
				;or	si,0FFF0H
				;SI_ok:
	db  8Bh,0C7h		;mov	ax,di		
	db  0F7h,0D0h		;not	ax
	db  0D3h,0E8h		;shr	ax,cl
	db  74h,0Ah		;jz	short DI_ok
	db  8Ch,0C2h		;mov	dx,es
	db  2Bh,0D0h		;sub	dx,ax
	db  8Eh,0C2h		;mov	es,dx
	db  81h,0CFh,0F0h,0FFh
				;or	di,0FFF0H
				;DI_ok:

size_scan_patch2 equ $-scan_patch2

scan_patch3: ; label byte

	db  8Ch,0C3h		;mov	bx,es			
	db  8Ch,0D8h		;mov	ax,ds
	db  48h			;dec	ax
	db  8Eh,0D8h		;mov	ds,ax			
	db  8Eh,0C0h		;mov	es,ax			
	db  0BFh,0Fh,00h	;mov	di,000FH
	db  0B9h,10h,00h	;mov	cx,0010H
	db  0B0h,0FFh		;mov	al,0FFH
	db  0F3h,0AEh		;repz	scasb			
	db  47h			;inc	di			
	db  8Bh,0F7h		;mov	si,di
	db  8Bh,0C3h		;mov	ax,bx			
	db  48h			;dec	ax
	db  8Eh,0C0h		;mov	es,ax
	db  0BFh,0Fh,00h	;mov	di,000FH		
				;NextRec:
	db  0B1h,04h		;mov	cl,4
	db  8Bh,0C6h		;mov	ax,si
	db  0F7h,0D0h		;not	ax		
	db  0D3h,0E8h		;shr	ax,cl		
	db  74h,09h		;jz	short SI_ok
	db  8Ch,0DAh		;mov	dx,ds
	db  2Bh,0D0h		;sub	dx,ax
	db  8Eh,0DAh		;mov	ds,dx	
	db  83h,0CEh,0F0h	;or	si,0FFF0H	
				;SI_ok:
	db  8Bh,0C7h		;mov	ax,di		
	db  0F7h,0D0h		;not	ax
	db  0D3h,0E8h		;shr	ax,cl
	db  74h,09h		;jz	short DI_ok
	db  8Ch,0C2h		;mov	dx,es
	db  2Bh,0D0h		;sub	dx,ax
	db  8Eh,0C2h		;mov	es,dx
	db  83h,0CFh,0F0h	;or	di,0FFF0H
				;DI_ok:

size_scan_patch3 equ $-scan_patch3

scan_com: ; label byte

	db  0ACh		;lodsb			
	db  8Ah,0D0h		;mov	dl,al		
	db  4Eh			;dec	si
	db  0ADh		;lodsw			
	db  8Bh,0C8h		;mov	cx,ax		
	db  46h			;inc	si		
	db  8Ah,0C2h		;mov	al,dl		
	db  24h,0FEh		;and	al,0FEH		
	db  3Ch,0B0h		;cmp	al,RPTREC
	db  75h,06h		;jne	short TryEnum
	db  0ACh		;lodsb				
	db  0F3h,0AAh		;rep stosb			
	db  0EBh,07h,90h	;jmp	short TryNext
				;TryEnum:
	db  3Ch,0B2h		;cmp	al,ENMREC
	db  75h,6Bh		;jne	short CorruptExe		
	db  0F3h,0A4h		;rep movsb			
				;TryNext:
	db  8Ah,0C2h		;mov	al,dl			
	db  0A8h,01h		;test	al,1			
;	db  74h,0BAh		;jz	short NextRec			

size_scan_com	equ	$-scan_com

;-----------------------------------------------------------------------

; 23/05/2019 - Retro DOS v4.0
; DOSCODE:B852h (MSDOS 6.21, MSDOS.SYS)

; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:B530h (MSDOS 5.0, MSDOS.SYS)

ExePatch:
	; 28/12/2022 - Retro DOS v4.1
	;call	ExePackPatch
	;;call	word [ss:RationalPatchPtr]
	;retn
	; 28/12/2022
	;jmp	short ExePackPatch

;-----------------------------------------------------------------------
;
; Procedure Name 	: ExePackPatch
;
; Inputs	 	: DS 			-> DOSDATA
;			  ES:0 			-> read in image
;			  ax:cx = start cs:ip of program
; Output		:		
;
;	1. If ES <= 0fffh
;	   2. if exepack signature ('RB') found
;	      3. if common code to patch compares (for 3 diff. versions)
;	       	 4. if rest of the code & checksum compares
;	  	    5. overlay buggy code with code in 
;		       doscode:str1.
;		 6. endif
;	      7. endif
;	   8. endif
;	9. endif
;
;
; Uses			: NONE
;
;-----------------------------------------------------------------------
		
	; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; 23/05/2019 - Retro DOS v4.0	
ExePackPatch:
	push	bx
	mov	bx,es			; bx has load segment
	cmp	bx,0FFFh		; Q: is the load segment > 64K
	jbe	short ep_cont		; N: 
	pop	bx			; Y: no need to patch
	retn
ep_cont:
	push	ds
	push	es
	push	ax
	push	cx
	push	si
	push	di
	
		; M033 - start
		; exepacked programs have an IP of 12h (>=2)

	sub	cx,2			; Q: is IP >=2 
	jnb	short epp_1		; N: exit
	jmp	ep_notpacked
					; ax:cx now points to location of
					; 'RB' if this is an exepacked file.
		; M033 - end
epp_1:
	mov	di,cx
	mov	es,ax
	mov	[ss:UNPACK_OFFSET],di	; save pointer to 'RB' in 
					; unpack_offset

	cmp	word [es:di],'RB' ; 4252h
	;ljne	ep_notpacked
	je	short epp_2
	jmp	ep_notpacked
epp_2:
	push	cs
	pop	ds			; set ds to cs

	;add	di,6Ch
	add	di,PATCH1_COM_OFFSET	; es:di -> points to place in packed 
					;          file where we hope to find
					;	   scan string. 

	call	chk_common_str		; check for match

	jnz	short ep_chkpatch2	; Q: does the patch match
					; N: check at patch2_offset
					; Y: check for rest of patch string
	mov	si,scan_patch1
					; ds:si -> scan string 
	mov	di,[ss:UNPACK_OFFSET]	; restore di to point to 'RB'

	;add	di,28h
	; 07/12/2022
	add	di,PATCH1_OFFSET	; es:di -> points to place in packed 
					;          file where we hope to find
					;	   scan string. 
	;mov	cx,68
	mov	cx,size_scan_patch1
	;mov	bx,142
	mov	bx,CHKSUM1_LEN
	;mov	ax,0EF4Eh
	mov	ax,PATCH1_CHKSUM
	call	chk_patchsum		; check if patch and chk sum compare
	jc	short ep_done1		; Q: did we pass the test
					; N: exit
					; Y: overlay code with new 
	mov	si,str1
	;mov	cx,102
	mov	cx,size_str1
	
	rep	movsb
ep_done1:
	jmp	ep_done

ep_chkpatch2:
	;mov	di,76h
	mov	di,PATCH2_COM_OFFSET	; es:di -> possible location of patch
					; in another version of unpack
	call	chk_common_str		; check for match

	jnz	short ep_chkpatch3	; Q: does the patch match
					; N: check for patch3_offset
					; Y: check for rest of patch string

	mov	si,scan_patch2
					; ds:si -> scan string 
	;mov	di,32h
	mov	di,PATCH2_OFFSET	; es:di -> points to place in packed 
					;          file where we hope to find
	;mov	cx,68			;	   scan string. 
	mov	cx,size_scan_patch2
	;mov	bx,140
	mov	bx,CHKSUM2_LEN
	;mov	ax,78B2h
	mov	ax,PATCH2_CHKSUM
	call	chk_patchsum		; check if patch and chk sum compare

					; M046 - Start
					; Q: did we pass the test
	jnc	short ep_patchcode2		; Y: overlay code with new 
					; N: try with a different chksum

	mov	si,scan_patch2
					; ds:si -> scan string 
	;mov	cx,68
	mov	cx,size_scan_patch2
	;mov	bx,129
	mov	bx,CHKSUM2A_LEN
	;mov	ax,1C47h
	mov	ax,PATCH2A_CHKSUM
	call	chk_patchsum		; check if patch and chk sum compare
					; Q: did we pass the test
	jc	short ep_notpacked		; N: try with a different chksum
					; Y: overlay code with new 
						
ep_patchcode2:			       	; M046 - End
	mov	si,str1
	;mov	cx,3
	mov	cx,first_stop
	rep	movsb
	mov	ax,4890h		; ax = opcodes for dec ax, nop
	stosw
	add	si,2
	;mov	cx,20
	mov	cx,second_stop
	rep	movsb
	stosw				; put in dec ax and nop
	add	si,2
	;mov	cx,75
	mov	cx,last_stop
	rep	movsb
	jmp	short ep_done

ep_chkpatch3:
	;mov	di,74h
	mov	di,PATCH3_COM_OFFSET	; es:di -> possible location of patch
					; in another version of unpack
	call	chk_common_str		; check for match

	jnz	short ep_notpacked	; Q: does the patch match
					; N: exit
					; Y: check for rest of patch string
	mov	si,scan_patch3
					; ds:si -> scan string 
	;mov	di,32h
	mov	di,PATCH3_OFFSET	; es:di -> points to place in packed 
					;          file where we hope to find
					;	   scan string. 
	;mov	cx,66
	mov	cx,size_scan_patch3
	;mov	bx,139
	mov	bx,CHKSUM3_LEN
	;mov	ax,4EDEh
	mov	ax,PATCH3_CHKSUM
	call	chk_patchsum		; check if patch and chk sum compare
	jc	short ep_notpacked	; Q: did we pass the test
					; N: exit
					; Y: overlay code with new 
	mov	si,str1
	;mv	cx,3
	mov	cx,first_stop
	rep	movsb
	mov	al,48h			; al = opcode for dec ax
	stosb
	add	si,2
	;mov	cx,20
	mov	cx,second_stop
	rep	movsb
	stosb				; put in dec ax
	add	si,2
	;mov	cx,75
	mov	cx,last_stop
	rep	movsb

ep_notpacked:
	;stc
ep_done:
	pop	di
	pop	si
	pop	cx
	pop	ax
	pop	es
	pop	ds
	pop	bx
	retn

;-------------------------------------------------------------------------
;
; 	Procedure Name	: chk_common_str
;
;	Input		: DS = DOSCODE
;			; ES:DI points to string in packed file
;
;	Output		; Z if match else NZ
;
;-------------------------------------------------------------------------

	; 23/05/2019 - Retro DOS v4.0
chk_common_str:
	mov	si,scan_com
					; ds:si -> scan string 
	;mov	cx,32
	mov	cx,size_scan_com

	repe	cmpsb	       

					; M046 - start
	; a fourth possible version of these exepacked programs have a 
	; 056h instead of 06Bh. See scan_com above
	;
	; 	db  75h, 6Bh		;jne CorruptExe		
	;
	; If the mismatch at this point is due to a 56h instead of 6Bh 
	; we shall try to match the rest of the string
	;

	jz	short ccs_done
	cmp	byte [es:di-1],56h
	jnz	short ccs_done

	repe	cmpsb	    
ccs_done:				; M046 - end
	retn

;-------------------------------------------------------------------------
;
;	Procedure Name	: chk_patchsum
;
;	Input		: DS:SI -> string we're looking for
;			: ES:DI -> offset in packed file
;			: CX 	= scan length
;			: BX	= length of check sum
;			: AX 	= value of check sum
;
;	Output		: if patch & check sum compare
;				NC
;			  else
;				CY
;
;	Uses		: AX, BX, CX, SI
;
;-------------------------------------------------------------------------

	; 23/05/2019 - Retro DOS v4.0
chk_patchsum:
	push	di

	repe	cmpsb			   

	jnz	short cp_fail		; Q: does the patch match
					; N: exit
					; Y:	

		; we do a check sum starting from the location of the 
		; exepack signature 'RB' up to 11c/2 bytes, the end of the
		; unpacking code.

	mov	di,[ss:UNPACK_OFFSET]	; di -> start of unpack code
	mov	cx,bx			; cx = length of check sum

	mov	bx,ax			; save check sum passed to us in bx
	xor	ax,ax
ep_chksum:
	add	ax,[es:di]
	add	di,2
	loop	ep_chksum

	pop	di			; restore di

	cmp	ax,bx		 	; Q: does the check sum match
	;jne	short cp_fail		; N: exit
					; Y: 
	; 25/09/2023
	;clc	
	;retn
	je	short ccs_done ; cf=0
	
cp_fail:
	stc
	retn

; 28/12/2022 - Retro DOS v4.1
%if 0
;--------------------------------------------------------------------------- 


; M020 : BEGIN
;
;---------------------------------------------------------------------------
;
; procedure : RationalPatch
;
; A routine (in Ration DOS extender) which is invoked at hardware interrupts
; clobbers CX register on 286 machines. (123 release 3 uses Rational DOS
; extender). This routine identifies Buggy Rational EXEs and fixes the bug.
;
; THE BUG is in the following code sequence:
;
;8b 0e 10 00	mov	cx, ds:[10h]		; delay count
;90		even				; word align
;e2 fe		loop	$			; wait		CLOBBERS CX
;e8 xx xx	call	set_A20			; enable A20
;
; This patch routine replaces the mov & the loop with a far call into a
; routine in DOS data segment which is in low memory (because A20 line
; is off). The routine (RatBugCode) in DOS data saves & restores CX around
; a mov & loop.
;
; Identification of Buggy Rational EXE
; ====================================
;
; (ALL OFFSETS ARE IN THE PROGRAM SECTION - EXCLUDING THE EXE HEADER)
;
; OFFSET				Contains
; ------				--------
; 0000h			100 times Version number in binary
;			bug exists in version 3.48 thru 3.83 (both inclusive)
;
; 000ah			the WORDS : 0000h, 0020h, 0000h, 0040h, 0001h
;
; 002ah			offset where version number is stored in ASCII
;				e.g. '3.48A'
;
; 0030h			offset of copyright string. Copyright strings either
;			start with "DOS/16M Copyright...." or
;			"Copyright.....". The string contains
;			"Rational Systems, Inc."
;
; 0020h			word : Paragraph offset of the buggy code segment
;				from the program image
; 0016h			word : size of buggy code segment
;
;	Buggy code is definite to start after offset 200h in its segment
;
;----------------------------------------------------------------------------

; 23/05/2019 - Retro DOS v4.0
; DOSCODE:B976h (MSDOS 6.21, MSDOS.SYS)

; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:B654h (MSDOS 5.0, MSDOS.SYS)

RScanPattern1:
	db	0, 0, 20h, 0, 0, 0, 40h, 0, 1, 0

RLen1 equ $ - RScanPattern1

RScanPattern2:
	db	8Bh, 0Eh, 10h, 00h, 90h, 0E2h, 0FEh, 0E8h

RLen2 equ $ - RScanPattern2

RScanPattern3:
	db	8Bh, 0Eh, 10h, 00h, 0E2h, 0FEh, 0E8h

RLen3 equ $ - RScanPattern2

; DOSCODE:B98Fh (MSDOS 6.21, MSDOS.SYS)
; DOSCODE:B66Dh (MSDOS 5.0, MSDOS.SYS)

;----------------------------------------------------------------------------
;
; INPUT : ES = segment where program got loaded
;
;----------------------------------------------------------------------------

RationalPatch:
	cld
	push	ax
	push	bx
	push	cx
	push	dx
	push	si
	push	di
	push	es
	push	ds			; we use all of them
	mov	di,0Ah			; look for pat1 at offset 0Ah
	push	cs
	pop	ds
	
	mov	si,RScanPattern1
	;mov	cx,10
	mov	cx,RLen1
	rep	cmpsb			; do we have the pattern ?
	jne	short rpexit
	mov	ax,[es:0]
	cmp	ax,348			; is it a buggy version ?
	jb	short rpexit
	cmp	ax,383			; is it a buggy version
	ja	short rpexit

	call	VerifyVersion
	jne	short rpexit

	mov	cx,[es:16h]		; Length of buggy code seg
	sub	cx,200h			; Length we search (we start
					;  at offset 200h)
	mov	es,[es:20h]		; es=buggy code segment
	mov	si,RScanPattern2
	;mov	dx,8	
	mov	dx,RLen2
	call	ScanCodeSeq		; look for code seq with nop
	jz	short rpfound

	mov	si,RScanPattern3
	;mov	dx,15
	mov	dx,RLen3
	call	ScanCodeSeq		; look for code seq w/o nop
	jnz	short rpexit

rpfound:
	
;	we set up a far call into DOS data
;	dx has the length of the code seq we were searching for

	mov	al,9Ah			; far call opcode
	stosb
	mov	ax,RatBugCode
	stosw
	mov	ax,ss
	stosw
	mov	cx,dx
	sub	cx,6			; filler (with NOPs)
	mov	al,90h
	rep	stosb
rpexit:
	pop	ds
	pop	es
	pop	di
	pop	si
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	retn

; M020 END

; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; (MSDOS 5.0 MSDOS.SYS compatibility)

; DOSCODE:B6D8h (MSDOS 5.0, MSDOS.SYS)

;----------------------------------------------------------------------------
;
; ScanCodeSeq
;
; Looks for a pattern pointed to by DS:SI & len DX in ES:200 to ES:200+CX-1
;
; returns in ES:DI the start of the pattern if Zero flag is set
;
;----------------------------------------------------------------------------

ScanCodeSeq:
	; 17/12/2022
	mov	di,200h
;ScanCodeSeq_di:
	push	cx
	sub	cx,dx
	inc	cx
	; 17/12/2022
	; 04/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;mov	di,200h
scsagain:
	push	si
	push	di
	push	cx
	mov	cx,dx
	rep	cmpsb
	pop	cx
	pop	di
	pop	si
	je	short scsfound
	inc	di
	loop	scsagain
scsfound:
	pop	cx
vvexit:		; 18/12/2022
	retn


; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; (MSDOS 5.0 MSDOS.SYS compatibility)

; DOSCODE:B6F0h (MSDOS 5.0, MSDOS.SYS)

;----------------------------------------------------------------------------
;
; VerifyVersion
;
; Checks whether the binary version from ES:0 matches the ASCII version
; from ES:2A.
;
;       Entry: AX = binary version number 
;       Exit : Z flag set if version numbers match
;
;----------------------------------------------------------------------------

VerifyVersion:
	mov	si,[es:2Ah]		; offset of version number
					;  in ascii
	mov	bl,10
	add	si,3			; point to last digit

	call	VVDigit
	jne	short vvexit
	call	VVDigit
	jne	short vvexit
	cmp	byte [es:si],'.' ; 2Eh
	jne	short vvexit
	dec	si
	;call	VVDigit
	; 18/12/2022
	;jmp	short VVDigit
;vvexit:
	;retn
VVDigit:
	div	bl
	add	ah,'0' ; 30h
	dec	si
	cmp	[es:si+1],ah
	mov	ah,0			; do not xor or sub we need Z
	retn

;--------------------------------------------------------------------------- 
%endif	; 28/12/2022

;---------------------------------------------------------------------------
;
;	M068
;
; 	Procedure Name	: IsCopyProt
;
;	Inputs		: DS:100 -> start of com file just read in
;
;	Outputs		: sets the A20OFF_COUNT variable to 10 if 
;			  the program loaded in DS:100 uses a MICROSOFT
;			  copy protect scheme that relies on the A20 line
;			  being turned off for it's scheme to work.
;
;			  Note: The int 21 function dispatcher will turn 
;				a20 off, if the A20OFF_COUNT is non-zero 
;				and dec the A20OFF_COUNT before	iretting 
;				to the user. 
;
;	Uses		: ES, DI, SI, CX
;
;---------------------------------------------------------------------------

; 23/05/2019 - Retro DOS v4.0

CPStartOffset	EQU	0175h
CPID1Offset	EQU	011Bh
CPID2Offset	EQU	0173h
CPID3Offset	EQU	0146h
CPID4Offset	EQU	0124h
ID1		EQU	05343h
ID2		EQU	05044h
ID3		EQU	0F413h
ID4		EQU	08000h

; DOSCODE:B9FAh (MSDOS 6.21, MSDOS.SYS)

; 04/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:B71Ch (MSDOS 5.0, MSDOS.SYS)

CPScanPattern:
	db	89h,26h,48h,01h		 ; mov [148],sp
	db	8Ch,0Eh,4Ch,01h		 ; mov [14C],cs
	db	0C7h,06h,4Ah,01h,00h,01h ; mov [14A],100h 
	db 	8Ch,0Eh,13h,01h		 ; mov [113],cs
	db	0B8h,20h,01h		 ; mov ax,120h
	db	0BEh,00h,01h		 ; mov si,100h

CPSPlen	EQU $ - CPScanPattern

; DOSCODE:BA12h (MSDOS 6.21, MSDOS.SYS)
; DOSCODE:B734h (MSDOS 5.0, MSDOS.SYS)

IsCopyProt:
	cmp	word [CPID1Offset],ID1
	jne	short CP_done

	cmp	word [CPID2Offset],ID2
	jne	short CP_done

	cmp	word [CPID3Offset],ID3
	jne	short CP_done

	cmp	word [CPID4Offset],ID4
	jne	short CP_done

	push	cs
	pop	es
	mov	di,CPScanPattern	; es:di -> Pattern to find

	mov	si,CPStartOffset	; ds:si -> possible location 
					; of pattern

	mov	cx,CPSPlen ; 24		; cx = length of pattern
	repe	cmpsb
	jnz	short CP_done

	mov	byte [ss:A20OFF_COUNT],0Ah ; M071
CP_done:
	retn
	
;DOSCODE ENDS

	;END

;----------------------------------------------------------------------------

;align 2 ; 05/09/2018 (Error!)

; 07/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
;align 16 ; 08/09/2018 (OK.)
align 2

; 06/08/2018 - Retro DOS v3.0
;============================================================================
; MSINIT.ASM
;============================================================================
; 22/04/2019 - Retro DOS v4.0 (MSINIT.ASM, MSDOS 6.0, 1991)
;
; MAIN ENTRY FOR DOS INITIALIZATION
;
	; 15/07/2018 - Retro DOS v3.0
	; (MSDOS 3.3, IBMDOS.COM, 1987)

; temp iret instruction


; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:B76Ah (MSDOS 5.0, MSDOS.SYS)

initiret: ; MSDOS 6.0
SYSBUF:
;IRETT: ; 06/05/2019
	iret

; 22/04/2019 - Retro DOS v4.0

; pointer to the BIOS data segment that will be available just to the
; initialization code

InitBioDataSeg:	dw 70h ; KERNEL_SEGMENT = 0070h

; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSCODE:B76Dh (MSDOS 5.0, MSDOS.SYS)

; Convert AX from a number of bytes to a number of paragraphs (round up).

ParaRound:
	add	ax, 15
	rcr	ax, 1
	shr	ax, 1
	shr	ax, 1
	shr	ax, 1
	retn

; MAIN ENTRY FOR DOS INITIALIZATION

	; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; DOSCODE:B779h (MSDOS 5.0, MSDOS.SYS)
	
	; 30/05/2019
	; 22/04/2019 - Retro DOS v4.0
	; 07/07/2018 - Retro DOS v3.0
	; Retro DOS v2.0 - 03/03/2018
	; 03/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	; MSDOS 5.0 - MSDOS.SYS, offset 79A9h
DOSINIT:
	; MSDOS 6.21 - MSDOS.SYS, offset 7C77h
	;
	; Far call from SYSINIT
	; DX = Memory size in paragraphs
	; DS:SI = [DEVICE_LIST] (SYSINIT.S) 
	;	  (Retro DOS v2.0, 16/03/2018)
	;
	; ES:DI = ptr to BIOS communication block (sysinit3.s)
	;	  (Retro DOS v4.0, 20/04/2019)

        CLI
        CLD

	; 03/11/2022
	;push	dx ; 30/05/2019		; save parameters from BIOS
	
	; 17/12/2022
	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;push	dx ; =*=		; save parameters from BIOS
	
	push	si
	push	ds
	push	di			;save di (ptr to BiosComBlock)

	mov	bx,es			;bx:di = ptr to BiosComBlock

; First, move the DOS data segment to its final location in low memory

	;;mov	ax,0BF69h ; MSDOS 6.21 MSDOS.SYS, file offset 7C7Fh
	;mov	ax,0BC77h ; MSDOS 5.0 MSDOS.SYS, file offset 79B1h	
	mov	ax,MEMSTRT		; get offset of end of init code

	;add	ax,15	; 0Fh		; round to nearest paragraph
	;and	ax,~15	; 0FFF0h	; boundary

	;mov	si,ax			; si = offset of DOSDATA in current 
					; code segment

	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	add	ax,15			; round to nearest paragraph
	and	ax,~15			; boundary

	mov	si,ax			; si = offset of DOSDATA in current 
					; code segment
	; 05/12/2022
	; 30/04/2019 - Retro DOS v4.0
	;xor	si,si
	
	mov	ax,cs
	mov	ds,ax			; ds = current code segment
					; DS:SI now points to dosdata

	;mov	es,[cs:0BA49h] ; MSDOS 6.21 IO.SYS, offset 7C8Eh 
	;mov	es,[cs:InitBioDataSeg]	; First access to DosDataSg in
					;  BData segment. Cannot use
					;  getdseg macro here!!!
	; 17/12/2022
	mov	es,[InitBioDataSeg]
	; 07/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;mov	es,[cs:InitBioDataSeg]  ; ds = cs !

	;mov	es,[es:3]
	mov	es,[es:DosDataSg]	; Get free location in low memory

	xor	di,di			; ES:DI now points to RAM data

	;mov	cx,4970  ; Offset 0BA78h in MSDOS 6.21 MSDOS.SYS)
	;mov	cx,4976  ; 25/05/2019
	; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	;mov	cx,4962
	;mov	cx,MSDAT001E		; get end of dosdata = size of dosdata
	mov	cx,DOSDATASIZE ; = 4962 for MSDOS 5.0 MSDOS.SYS
	rep	movsb			; move data to final location
	
	pop	di			; restore ptr to BiosComBlock
	pop	ds			; restore parms from BIOS
	pop	si
	; 17/12/2022
	;pop	dx ; 30/05/2019	
	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;pop	dx ; =*=		

	push	es
	push	ds
	pop	es			; es:si -> device chain
	pop	ds			; ds points to dosdata

;SR;
;We get a ptr to the BIOS exchange data block. This has been setup right 
;now so that the EXEC call knows when SysInit is present to do the special
;lie table handling for device drivers. This can be expanded later on to
;establish a communication block from the BIOS to the DOS.

	;mov	[1040h],di	; Offset 0BA87h in MSDOS 6.21 MSDOS.SYS)
	;mov	[1042h],bx
	mov	[BiosDataPtr],di
	mov	[BiosDataPtr+2],bx	; save ptr to BiosComBlock

	mov	[cs:DosDSeg],ds		; set pointer to dosdata in code seg

	; Set the segment of Lowint23/24/28Addr in msctrlc.asm to dosdata

	mov	[cs:LowInt23Addr+2],ds	; set pointers in code seg
	mov	[cs:LowInt24Addr+2],ds
	mov	[cs:LowInt28Addr+2],ds

	;mov	[346h],dx	; MSDOS 6.21 DOSDATA addresses
	;mov	[584h],sp
	;mov	[586h],ss
    	mov	[ENDMEM],dx	; =*=
	mov	[USER_SP],sp
	mov	[USER_SS],ss

	mov	ax,ds		; set up ss:sp to dosdata:dskstack
	mov	ss,ax

	;mov	sp,920h		; MSDOS 6.21 DOSDATA address
	;mov	sp,offset dosdata:dskstack
	mov	sp,DSKSTACK

;M023
; Init patch ptrs to default values

	;mov	word [1212h],RetExePatch
	;mov	word [1214h],RetExePatch
	;mov	word [61h],RetExePatch
	mov	word [FixExePatch],RetExePatch	; M023
	; 28/12/2022 - Retro DOS v4.1
	;mov	word [RationalPatchPtr],RetExePatch ; M023
	mov	word [ChkCopyProt],RetExePatch	; M068

; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
%if 0	; 19/09/2023

; Setup to call 386 Rational DOS Extender patch routine if running on
; a 386 or later. Unlike other patches, this is not dependent on MS-DOS
; running in the HMA.

	call	WhatCPUType	; get cpu type (0 < 286,1==286,2 >= 386)
	cmp	al,2		;   386 or later?
	mov	ax,Rational386Patch
	jae	short di_set_patch
	mov	ax,RetExePatch	; < 386, don't need this patch
di_set_patch:
	mov	[Rational386PatchPtr],ax ; patch routine or RET instr.

%endif
	; Set up the variable temp_dosloc to point to the dos code segment

	mov	ax,cs		; ax = current segment of DOS code

	; ax now holds segment of DOS code
	mov	[TEMP_DOSLOC],ax   ; store temp location of DOS

	mov	word [NULDEV+2],es ; nuldev -> points to device chain
	mov	word [NULDEV],si
;SR;
; There are some locations in the Win386 instance data structures
; which need to be set up with the DOS data segment. First, initialize
; the segment part of the instance table pointer in the SIS.

	;mov	[0FF2h],ds ; [Win386_Info+14+2]	
	mov	[Win386_Info+Win386_SIS.Instance_Data_Ptr+2],ds

; Now initialize the segment part of the pointer to the data in each
; instance table entry.

	push	si		; preserve pointer to device chain
	; 18/12/2022
	; cx = 0
	mov	cl,7
	;mov	cx,7		; There are 7 entries in the instance table
				; M019
	;mov	si,0FF6h ; offset (dosdata:Instance_Table+2)
	mov	si,Instance_Table+2 ; point si to segment field
Instance_init_loop:
	mov	[si],ds		; set offset in instance entry
	;add	si,6
	add	si,size_of_Win386_IIS ; move on to next entry
	loop	Instance_init_loop

;Initialize the WIN386 2.xx instance table with the DOS data segment value

	; 18/12/2022
	mov	cl,5
	;mov	cx,5		; There are five entries in the instance table

	;mov	si,(offset dosdata:OldInstanceJunk) + 6
	;mov	si,11EDh	; point si to segment field
	mov	si,OldInstanceJunk+6
OldInstance_init_loop:
	mov	[si],ds		; set offset in instance entry
	add	si,6		; move on to next entry
	loop	OldInstance_init_loop
	pop	si		; restore pointer to device chain

; End of WIN386 2.xx compatibility bullshit

; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
%if 0	
   	; 30/04/2019
	;push	es
	;pop	ds
			; ds:si points to console device

	; 24/04/2019 - Retro DOS v4.0

	; 15/07/2018
	; MSDOS 3.3 (IBMDOS.COM, 1987)
	; (Set INT 2Ah handler address to an 'IRET')

	; need crit vector inited to use deviocall
	;push	ds			; preserve segment of device chain
	push	es ; 30/04/2019

%endif
	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	push	es
	; 17/12/2022
	;pop	ds
	;push	ds

	xor	ax,ax
	mov	ds,ax			; point DS to int vector table
	mov	ax,initiret
	;mov	[0A8h],ax  ; [2Ah*4]
	mov	[addr_int_ibm],ax
	mov	ax,cs
	;mov	[0AAh],ax  ; [(2Ah*4)+2] 		
	mov	[addr_int_ibm+2],ax
	pop	ds			; restore segment of device chain

	call	CHARINIT  		; initialize console driver
	push	si			; save pointer to header

	push	ss			; move pointer to dos data...
	pop	es			; ...into ES

	;initialize sft for file 0 (CON)

        ; 07/07/2018 - Retro DOS v3.0
	; 24/04/2019 - Retro DOS v4.0
	;mov	di,SFTABL+6 
	MOV     DI,SFTABL+SFT.SFTable	; Point to sft 0
        MOV     AX,3
        STOSW           	; Refcount
        DEC     AL
        STOSW           	; Access rd/wr, compatibility
        XOR     AL,AL
        STOSB           	; attribute
	;mov	al,0C3h
	mov	al,devid_device_EOF|devid_device|ISCIN|ISCOUT
	STOSW			; flags
        mov	ax,si
        stosw			; device pointer in devptr	
        mov	ax,ds
	stosw
	xor	ax,ax	; 0
	stosw			; firclus
	stosw			; time
	stosw			; date
	dec	ax	; -1
	stosw			; size
	stosw
	inc	ax	; 0
	stosw			; position
	stosw
	;add	di,7
	add	di,SF_ENTRY.sf_name-SF_ENTRY.sf_cluspos
				; point at name
	;add	si,10
	add	si,SYSDEV.NAME	; sdevname
				; point to name
	mov	cx,4
	rep	movsw		; name
	mov	cl,3
	mov	al," "
	rep	stosb		; extension

	pop	si		; get back pointer to header

				; mark device as CON I/O
	; 15/07/2018
        ;OR	BYTE [SI+4],ISCIN|ISCOUT ; or byte [si+4],3
	OR	BYTE [SI+SYSDEV.ATT],ISCIN|ISCOUT
	; 12/03/2018
	;mov	[ss:32h],si
	MOV     [SS:BCON],SI
	;mov	[ss:34h],ds
        MOV     [SS:BCON+2],DS

	; initialize each device until the clock device is found

CHAR_INIT_LOOP:
        LDS     SI,[SI]			; AUX device
	call	CHARINIT 
       	;15/07/2018
	;test	byte [SI+4],8
	TEST    BYTE [SI+SYSDEV.ATT],ISCLOCK
        JZ      SHORT CHAR_INIT_LOOP
	; 12/03/2018
	;mov	[ss:2Eh],si
        MOV     [SS:BCLOCK],SI
	;mov	[ss:30h],ds
        MOV     [SS:BCLOCK+2],DS
        ;MOV	BP,MEMSTRT ; Retro DOS 3.0 ; ES:BP points to DPB

	;mov	bp,4970			; bp = pointer to free mem
	;mov	bp,4976  ; 25/05/2019 - Retro DOS v4.0
	; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0, MSDOS.SYS)
	;mov	bp,4962 ; (MSDOS 5.0 MSDOS.SYS)
	mov	bp,MSDAT001E		; es:bp points to dpb area

	mov	[ss:DPBHEAD],bp		; set offset of pointer to DPB's
	mov	[ss:DPBHEAD+2],es	; set segment of pointer to DPB's
PERDRV:
	;lds	si,[SI+SYSDEV.NEXT] ; 15/07/2018
        LDS	SI,[SI]			; Next device
        CMP	SI,-1	; 0FFFFh
	JZ	SHORT CONTINIT

        call	CHARINIT

	; Retro DOS v2.0 - 16/03/2018 (NOTE for 'CHARINIT' return):
	; [CALLUNIT] = Number of drives for (Disk) Block Dev Driver ([DRVMAX])
	;           (..When the command is 'DSK$INIT', as in 'CHARINIT')
	; [CALLBPB] = [DEVCALL.COUNT] = Address of the BPB (DEVCALL offset 18) 
	; (REF: MSDOS 3.3 MSBIO2.ASM, MSDATA.INC, MSDISK.ASM, MSBIO1.ASM)
	; (.. !DSK$IN' in MSBIO1.ASM)
	; DEVCALL.MEDIA = CALLUNIT (DEVCALL offset 13)

        ; 15/07/2018
	;test	word [SI+4],8000h		; DEVTYP
        ; 17/12/2022
	;test	byte [SI+5],80h
	test	byte [SI+SYSDEV.ATT+1],(DEVTYP>>8) ; 80h
	;TEST	word [SI+SYSDEV.ATT],DEVTYP ; 8000h
	JNZ     SHORT PERDRV			; Skip any other character devs

        MOV	CL,[SS:CALLUNIT] ; 12/03/2018
	XOR     CH,CH
        ; 07/07/2018
	;MOV	[SI+10],CL		; Number of units in name field
	mov	[si+SYSDEV.NAME],cl	; sdevname        
	MOV     DL,[SS:NUMIO]	; 15/03/2018
	XOR     DH,DH
	ADD	[SS:NUMIO],CL	; 12/03/2018
	PUSH    DS
        PUSH    SI
	LDS	BX,[SS:CALLBPB]	; 12/03/2018

PERUNIT:
        MOV     SI,[BX]                 ; DS:SI Points to BPB
        INC     BX
        INC     BX                      ; On to next BPB
	; 15/12/2022
	; 07/07/2018
        ;mov	[ES:BP+DPB.DRIVE],DL
	MOV     [ES:BP],DL
	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;;mov	[ES:BP+0],DL
	;mov	[ES:BP+DPB.DRIVE],DL

	;MOV	[ES:BP+1],DH
	MOV	[ES:BP+DPB.UNIT],DH
        PUSH    BX
        PUSH    CX
        PUSH    DX

        ;invoke	$SETDPB
        CALL	_$SETDPB		; build DPB!

	; 07/07/2018
	;MOV	AX,[ES:BP+2]
	mov	ax,[ES:BP+DPB.SECTOR_SIZE]
        ; 12/03/2018
	CMP	AX,[SS:MAXSEC]		; Q:is this the largest sector so far
	JBE     SHORT NOTMAX		; N:
	MOV	[SS:MAXSEC],AX		; Y: save it in maxsec
NOTMAX:					
	; set the next dpb field in the currently built bpb
	; and mark as never accessed
        
	; 24/04/2019
	mov	ax,bp			; get pointer to DPB
	;add	ax,33
	add	ax,DPBSIZ		; advance pointer to next DPB
					; set seg & offset of next DPB
	;mov	[es:bp+25],ax
	mov	[es:bp+DPB.NEXT_DPB],ax
	;mov	[es:bp+27],es
	mov	[es:bp+DPB.NEXT_DPB+2],es
					; mark as never accessed
	;mov	byte [es:bp+24],0FFh
	mov	byte [es:bp+DPB.FIRST_ACCESS],-1

	POP     DX
        POP     CX
        POP     BX
        MOV     AX,DS                   ; save segment of bpb array
        POP     SI
        POP     DS
					; ds:si -> device header
					; store it in the corresponding dpb
	; 07/07/2018
        ;MOV	[ES:BP+19],SI ; 24/04/2019
	mov	[ES:BP+DPB.DRIVER_ADDR],si
        ;MOV	[ES:BP+21],DS ; 24/04/2019
	mov	[ES:BP+DPB.DRIVER_ADDR+2],ds

        PUSH    DS			; save pointer to device header
        PUSH    SI
        INC     DH			; inc unit #
        INC     DL			; inc drive #
        MOV     DS,AX			; restore segment of BPB array
        ;add	bp,33 ; 24/04/2019
	ADD     BP,DPBSIZ		; advance pointer to next dpb
	LOOP    PERUNIT			; process all units in each driver
        
	POP     SI			; restore pointer to device header
        POP     DS
	JMP	PERDRV			; process all drivers in chain

CONTINIT:
	; 24/04/2019
	;sub	bp,33			; set link in last DPB to -1
	sub	bp,DPBSIZ		; back up to last dpb
					; set last link offset & segment
	;mov	word [bp+25],0FFFFh
	mov	word [bp+DPB.NEXT_DPB],-1
	;mov	word [bp+27],0FFFFh
	mov	word [bp+DPB.NEXT_DPB+2],-1
	;add	bp,33
	add	BP,DPBSIZ		; advance to free memory again
					; the DPB chain is done.  
	push	ss
	pop	ds

	mov	ax,bp
	call	ParaRound		; round up to segment

	mov	dx,ds			; dx = dosdata segment
	add	dx,ax			; dx = ds+ax first free segment

	mov	bx,0Fh
	
	; 24/05/2019
	;mov	cx,[ENDMEM]
	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	; 17/12/2022
	;mov	cx,[ENDMEM] 
					; set seg inpacketto dosdata					
	mov	[DSKCHRET+3],ds ; mov [DOSSEG_INIT],ds 

; Patch in the segments of the interrupt vectors with current code segment.
; Also patch in the segment of the pointers in the dosdata area.
;
; Note: Formerly, temp_dosloc was initialized to -1 until after these
; calls were done. The procedure patch_misc_segments is called multiple
; times, and relies on temp_dosloc being initialized to -1 as a flag
; for the first invocation. Thus, we must set it to -1 for this call.

	push	dx			; preserve first free segment

	mov	ax,[TEMP_DOSLOC]	; ax = segment to patch in 
	mov	es,ax			; es = segment of DOS
	mov	word [TEMP_DOSLOC],-1	; -1 means first call to patch_misc_segments

	call	patch_vec_segments	; uses AX as doscode segment
	call	patch_misc_segments	; patch in segments for sharer and 
					; other tables with seg in ES.
	; 17/12/2022
	; cx = 0
	mov	[TEMP_DOSLOC],es	; put back segment of dos code

	pop	dx			; restore first free segment

; We shall now proceed to set the offsets of the interrupt vectors handled
; by DOS to their appropriate values in DOSCODE. In case the DOS loads in
; HIMEM the offsets also will be patched to their appropriate values in the
; low_mem_stub by seg_reinit.

	;xor	ax,ax ; 0
	;mov	ds,ax
	;mov	es,ax
	; 17/12/2022
	; cx = 0
	;xor	cx,cx ; 0
	mov	ds,cx
	mov	es,cx

	; set the segment of int 24 vector that was 
	; left out by patch_vec_segments above.

	; 17/12/2022
; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
;%if 0
	; 24/05/2019
	;;mov	di,90h
	;;mov	di,4*int_fatal_abort
	;mov	di,addr_int_fatal_abort
	mov	di,addr_int_fatal_abort+2 ; 24/05/2019

	mov	ax,[ss:TEMP_DOSLOC]
	;mov	[di+2],ax  ; int 24h segment
	mov	[di],ax ; 24/05/2019

	;;mov	di,82h
	;mov	di,INTBASE+2

;%endif
	; 17/12/2022
	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;;mov	di,90h
	;;mov	di,4*int_fatal_abort
	;mov	di,addr_int_fatal_abort
	;mov	ax,[ss:TEMP_DOSLOC]
	;mov	[di+2],ax  ; int 24h segment
	;;mov	di,82h
	;mov	di,INTBASE+2

	; set default divide trap offset

	;mov	word ptr ds:[0],offset doscode:divov
	mov	word [0],DIVOV	

	; set vectors 20-28 and 2a-3f to point to iret.

	;mov	di,80h
	mov	di,INTBASE
	;mov	ax,offset doscode:irett
	mov	ax,IRETT

	; 17/12/2022
	; cx = 0
	mov	cl,9
	;mov	cx,9			; set 9 offsets (skip 2 between each)
					;   sets offsets for ints 20h-28h
iset1:
	stosw
	;add	di,2
	; 20/09/2023
	inc	di
	inc	di
	loop	iset1

	add	di,4			; skip vector 29h

;	mov	cx,6			; set 6 offsets (skip 2 between each)
;					;   sets offsets for ints 2ah-2fh
;iset2:
;	stosw
;	add	di,2
;	loop	iset2

; 30h & 31H is the CPM call entry point whose segment address is set up by
; patch_vec_segments above. So skip it.

;	add	di,8			; skip vector 30h & 31h 

	;;;
	; 06/05/2019 - Retro DOS v4.0
	;mov	cx,5			; set offsets for int 2Ah-2Eh
	; 17/12/2022
	mov	cl,5 ; 28/06/2019
	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;mov	cx,6
iset2:
	stosw
	;add	di,2
	; 20/09/2023
	inc	di
	inc	di
	loop	iset2

	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	; 17/12/2022
	add	di,12			; skip vectors 2Fh, 30h & 31h
	;add	di,8
	;;;

	; 17/12/2022
	mov	cl,14
	;mov	cx,14			; set 14 offsets (skip 2 between each)
					;   sets offsets for ints 32h-3fh
iset3:
	stosw
	;add	di,2
	; 20/09/2023
	inc	di
	inc	di
	loop	iset3

;if installed
	; set the offset of int2f handler
	;mov	word [0BCh],INT2F
	mov	word [02Fh*4],INT2F
	; set segment to doscode as we have to do int 2f to check for XMS
	mov	ax,[ss:TEMP_DOSLOC]	; get segment of doscode
	;mov	[0BEh],ax
	mov	[(02Fh*4)+2],ax
;endif
	; set up entry point call at vectors 30-31h. Note the segment of the 
	; long jump will be patched in by seg_reinit

	;mov	byte [C0h],0EAh
	mov	byte [ENTRYPOINT],mi_long_jmp
	;mov	byte [C1h],CALL_ENTRY
	mov	word [ENTRYPOINT+1],CALL_ENTRY

	mov	word [addr_int_abort],QUIT	; INT 20h
	mov	word [addr_int_command],COMMAND ; INT 21h
	mov	word [addr_int_terminate],100h	; INT 22h
	mov	word [addr_int_terminate+2],dx	
	mov	word [addr_int_disk_read],ABSDRD   ; INT 25h
	mov	word [addr_int_disk_write],ABSDWRT ; INT 26h 
	mov	word [addr_int_keep_process],STAY_RESIDENT ; INT 27h

	push	ss
	pop	ds
	
	; 24/05/2019
	;push	ss
	;pop	es
	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	; 17/12/2022
	;push	ss
	;pop	es

	push	dx			; remember address of arena

	inc	dx			; leave room for arena header
	;mov	[330h],dx
	mov     [CurrentPDB],dx		; set current pdb

	xor	di,di			; point es:di at end of memory
	mov	es,dx			; ...where psp will be
	xor	ax,ax
	;mov	cx,80h			; psp is 128 words
	; 17/12/2022
	mov	cl,128 ; 28/06/2019
	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;mov	cx,128

	rep	stosw			; zero out psp area
        mov     ax,[ENDMEM]
	
	; 17/12/2022
	; cx = 0
	call	SETMEM         	 	; build psp at dx; ax is memory size

	; ds, es now point to PSP

	push	ss
	pop	ds

	;mov	di,24
	mov	di,PDB.JFN_TABLE	; es:di -> pdb_jfn_table in psp
	xor	ax,ax
	stosw
	stosb				; 0,1 and 2 are con device
	mov	al,0FFh
	;mov	cx,FILPERPROC-3 ; 17
	; 17/12/2022
	; cx = 4
	mov	cl,FILPERPROC-3 ; 17
	rep	stosb			; rest are unused

	push	ss
	pop	es
					; must be set to print messages
	mov	[SFT_ADDR+2],ds     

; after this point the char device functions for con will work for
; printing messages

	; 24/04/2019 - Retro DOS v4.0

; 12/05/2019
;
;write_version_msg:
;
;	;if	(not ibm)
;	;mov	si,offset doscode:header
;	mov	si,HEADER
;outmes:
;	;lods	cs:byte ptr [si]
;	cs
;	lodsb
;	cmp	al,"$"
;	je	short outdone
;	call	OUTT
;	jmp	short outmes
;outdone:
;	push	ss			; out stomps on segments
;	pop	ds
;	push	ss
;	pop	es
;	;endif

	; at this point es is dosdata

	; Fill in the segment addresses of sysinitvar and country_cdpg 
	; in sysinittable (ms_data.asm)

	;mov	si,0D28h
	mov	si,SysInitTable

	; 17/12/2022
	; ds = es = ss

	; 17/12/2022
; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
;%if 0
	;;mov	[es:si+6],es
	;mov	[es:si+SYSI_EXT.Country_Tab+2],es
	;;mov	[es:si+2],es
	;mov	[es:si+SYSI_EXT.SysInitVars+2],es
	
	mov	[si+SYSI_EXT.Country_Tab+2],es
	mov	[si+SYSI_EXT.SysInitVars+2],es

	; buffhead -> dosdata:hashinitvar 

	;mov	[es:BUFFHEAD+2],es	; BUGBUG - unused, remove this
	mov	[BUFFHEAD+2],es
	;mov	si,offset dosdata:hashinitvar ; and all other references
	;mov	si,6Dh
	mov	si,HASHINITVAR
	;mov	[es:BUFFHEAD],si
	mov	[BUFFHEAD],si

        pop     dx                      ; restore address of arena

	;mov	[032Ch+2],dx
        mov     [DMAADD+2],dx

	;mov	[es:arena_head],dx
	mov	[arena_head],dx

;%endif

; 17/12/2022
%if 0
	; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
	;;;
	;mov	[es:si+6],es
	mov	[es:si+SYSI_EXT.Country_Tab+2],es
	;mov	[es:si+2],es
	mov	[es:si+SYSI_EXT.SysInitVars+2],es

	; buffhead -> dosdata:hashinitvar 

	mov	[es:BUFFHEAD+2],es	; BUGBUG - unused, remove this
	;mov	si,offset dosdata:hashinitvar ; and all other references
	;mov	si,6Dh
	mov	si,HASHINITVAR
	mov	[es:BUFFHEAD],si

        pop     dx                      ; restore address of arena

	;mov	[032Ch+2],dx
        mov     [DMAADD+2],dx

	mov	[es:arena_head],dx
	;;;
%endif

        mov     ds,dx

	;mov	byte [0],'Z'
	mov     byte [ARENA.SIGNATURE],arena_signature_end
        ;mov	word [1],0
	mov     word [ARENA.OWNER],arena_owner_system

        mov     ax,[ss:ENDMEM]
	sub	ax,dx
        dec     ax
        mov     [ARENA.SIZE],ax

	; point to sft 0

	;mov	di,offset dosdata:sftabl + sftable
	;mov	di,SFTABL+6
	mov	di,SFTABL+SFT.SFTable
        mov     ax,3
        stosw           		; adjust refcount

	; es:di is shared data area i.e., es:di -> dosdata:sysinttable

        ;mov	di,offset dosdata:sysinittable
	;mov	di,0D28h
	mov	di,SysInitTable	

	inc	dx			; advance dx from arena to psp
	mov	ds,dx			; point ds to psp

					; pass the address os seg_reinit 
					; in dx
	mov	dx,seg_reinit
	mov	cx,exepatch_start
	sub	cx,_$STARTCODE		; cx = (doscode - exepatch) - dosinit

	mov	ax,SYSBUF
	sub	ax,_$STARTCODE		; ax = size of doscode - dosinit
	
        mov     sp,[ss:USER_SP]		; use ss override for next 2
        mov     ss,[ss:USER_SS]

        retf

;
; END OF DOSINIT
;
;--------------------------------------------------------------------------

CHARINIT:
	; 24/04/2019 - Retro DOS v4.0
	; 07/07/2018 - Retro DOS v3.0
	;mov	byte [ss:035Ah],26 ; 1Ah
        MOV	BYTE [SS:DEVCALL_REQLEN],DINITHL
	;mov	byte [ss:035Bh],0
        MOV	BYTE [SS:DEVCALL_REQUNIT],0
	;mov	byte [ss:035Ch],0
        MOV	BYTE [SS:DEVCALL_REQFUNC],DEVINIT
	;mov	word [ss:035BD],0
        MOV	WORD [SS:DEVCALL_REQSTAT],0
        PUSH	ES
        PUSH	BX
        PUSH	AX
        MOV	BX,DEVCALL
        ;PUSH	CS
	PUSH	SS ; 30/04/2019
        POP	ES
        CALL	DEVIOCALL2	
	POP	AX
        POP	BX
        POP	ES
        RETN

; 25/04/2019 - Retro DOS v4.0

;-----------------------------------------------------------------------------
;
;	check_XMM: routine to check presence of XMM driver
;
;	Exit:   Sets up the XMM entry point in XMMcontrol in DOSDATA
;
;	USED:	none
;
;-----------------------------------------------------------------------------

check_XMM: ; proc near
;
; determine whether or not an XMM driver is installed
;
	push	ax
	;mov	ax,(XMM_MULTIPLEX<<8)+XMM_INSTALL_CHECK
	mov	ax,4300h
	int	2Fh
		; - Multiplex - XMS - INSTALLATION CHECK
		; Return: AL = 80h XMS driver installed
		; AL <> 80h no driver
	cmp	al,80h			; Q: installed
	jne	short cXMM_no_driver	; N: set error, quit
;
; get the XMM control functions entry point, save it, we
; need to call it later.
;
	push	bx
	push	dx
	push	ds
	push	es
	;mov	ax,(XMM_MULTIPLEX<<8)+XMM_FUNCTION_ADDR
	mov	ax,4310h
	int	2Fh
		; - Multiplex - XMS - GET DRIVER ADDRESS
		; Return: ES:BX -> driver entry point

	mov	ds,[cs:DosDSeg]

	mov	[XMMcontrol],bx
	mov	[XMMcontrol+2],es
cXMMexit:
	clc
	pop	es
	pop	ds
	pop	dx
	pop	bx
	pop	ax
	retn				; done
;
; set carry if XMM driver not present
;
cXMM_no_driver:
	stc
	pop	ax
	retn

;-----------------------------------------------------------------------------
;
; Procedure Name : seg_reinit
;
; Inputs	 : ES has final dos code location
;		   AX = 0 / 1
;
; Outputs	 : Patch in the sharer and other tables with seg in ES
;		   if AX =0
;		      if first entry
;			 patch segment & offset of vectors with stub
;			 and stub with segment in ES
;		      else
;			 patch stub with segment in ES
;
;		   else if AX = 1
;			patch segment of vectors with segment in ES	
;
; NOTE		 : This routine can be called at most twice!
;
; Regs Mod.	 : es, ax, di, cx, bx
;-----------------------------------------------------------------------------

num_entry: db	0		; keeps track of the # of times this routine
				; has been called. (0 or 1)

	; 04/11/2022 - Retro DOS v4.0 (ref: MSDOS 5.0)
	; MSDOS 5.0 MSDOS.SYS - DOSCODE:0BAB7h
	; 25/05/2019 - Retro DOS v4.0 (ref: MSDOS 6.21)
	; MSDOS 6.21 MSDOS.SYS - DOSCODE:0BDA5h

seg_reinit:	; proc	far
	push	ds

	mov	ds,[cs:DosDSeg]

	call	patch_misc_segments	; patch in segments for sharer and 
					; other tables with seg in ES.
	; 17/12/2022
	; cx = 0
	cmp	ax,cx ; 0
	;cmp	ax,0
	jne	short patch_vec_seg	; patch vectors with segment in es

	; 17/12/2022
	cmp	[cs:num_entry],cl ; 0
	;cmp	byte [cs:num_entry],0	; Q: is it the first call to this 
	jne	short second_entry	; N: just patch the stub with 
					;    segment in ES
					; Y: patch the vectors with stub 
	mov	ax,ds
	call	patch_vec_segments	; patch the segment of vectors
	call	patch_offset		; patch the offsets of vectors 
					; with those in the stub.
	; 17/12/2022
	; cx = 0
second_entry:
	mov	ax,es			; patch the stub with segment in es

	;mov	di,OFFSET DOSDATA:DOSINTTABLE
	;mov	di,1062h	; (same table addr for MSDOS 5.0 and MSDOS 6.21)
	mov	di,DOSINTTABLE
	; 17/12/2022
	; cx = 0
	;mov	cx,9
	mov	cl,9
	push	ds			
	pop	es			; es:di -> DOSINTTABLE

dosinttabloop:
	;add	di,2
	; 19/06/2023
	inc	di
	inc	di
	stosw
	loop	dosinttabloop	

; For ROMDOS, this routine will only be called when the DOS wants to
; use the HMA, so we don't want to check CS

;ifndef ROMDOS
	cmp	ax,0F000h		; Q: is the DOS running in the HMA
	jb	short sr_done		; N: done
;endif
	call	check_XMM		; Y: set up the XMS entry point
	jc	short sr_done		; failed to set up XMS do not do
					; A20 toggling in the stub.
	; 17/12/2022
	; cx = 0
	call	patch_in_nops		; enable the stub to check A20 state
; M021-
	;mov	byte [1211h],1
	mov	byte [DosHasHMA],1	; set flag telling DOS control of HMA 
				
					; set pointer to the routine that 
					; patches buggy exepacked code.
	;mov	[FixExePatch],offset DOSCODE:ExePatch
	mov	word [FixExePatch],ExePatch
					; M068: set pointer to the routine 
					; M068: that detects copy protected
					; M068: apps
	;mov	[ChkCopyProt],offset DOSCODE:IsCopyProt
	mov	word [ChkCopyProt],IsCopyProt

	; 19/09/2023
	jmp	short sr_done

; 28/12/2022 - Retro DOS v4.1
%if 0
;----------------------------------------------------------------------------

	; MSDOS 6.21 MSDOS.SYS - DOSCODE:0BDF1h

;	; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
;
;; M020 - begin
;
;	call	WhatCPUType
;	cmp	al,1
;	jne	short sr_done 		; we need Rational Patch only
;					;  on 286 systems
;	;mov	[RationalPatchPtr],offset DOSCODE:RationalPatch
;	mov	word [RationalPatchPtr],RationalPatch
;
;; M020 - end
;
;	jmp	short sr_done
;
;patch_vec_seg:				; patch vectors with segment in es
;	mov	ax,es
;	call	patch_vec_segments	; patch in DOSCODE for the segments
;					; NOTE we don't have to patch the 
;					; offsets as they have been already
;					; set to the doscode offsets at
;					; DOSINIT.
;sr_done:
;	mov	byte [cs:num_entry],1
;	pop	ds
;	retf	; ! far return !

;----------------------------------------------------------------------------
;
; Procedure Name : WhatCPUType
;
; Inputs	 : none
;
; Outputs	 : AL = 0 if CPU <  286
;		      = 1 if CPU == 286
;		      = 2 if CPU >= 386
;
; Regs. Mod.	 : AX
;
;----------------------------------------------------------------------------

WhatCPUType:
	; 25/04/2019 - Retro DOS v4.0
	;get_cpu_type	; done with a MACRO which can't be generated > once

	;CPUTYPE.INC (MSDOS 6.0, 1991)

; Note: this must be a macro, and not a subroutine in the BIOS since
; 	it is called from both CODE and SYSINITSEG.
;
;------GET_CPU_TYPE-----------------------------------May, 88 by M.Williamson
;  Returns: AX = 0 if 8086 or 8088
;              = 1 if 80286
;              = 2 if 80386

	; 04/11/2022
	; MSDOS 5.0 MSDOS.SYS - DOSCODE:0BB03h

Get_CPU_Type:	;macro
	pushf
	push	bx			; preserve bx
	xor	bx,bx			; init bx to zero

	xor	ax,ax			; 0000 into AX
	push	ax			; put it on the stack...
	popf				; ...then shove it into the flags
	pushf				; get it back out of the flags...
	pop	ax			; ...and into ax
	and	ax,0F000h		; mask off high four bits
	cmp	ax,0F000h		; was it all 1's?
	je	short cpu_8086		; aye; it's an 8086 or 8088

	mov	ax,0F000h		; now try to set the high four bits..
	push	ax
	popf
	pushf
	pop	ax			; ...and see what happens
	and	ax,0F000h		; any high bits set ?
	jz	short cpu_286		; nay; it's an 80286

cpu_386:				; bx starts as zero
	inc	bx			; inc twice if 386
cpu_286:				; just inc once if 286
	inc	bx
cpu_8086:				; don't inc at all if 086
	mov	ax,bx			; put CPU type value in ax
	pop	bx			; restore original bx
	popf
	
	;endm

	; 04/11/2022 (MSDOS 5.0 MSDOS.SYS)
	retn	; 19/09/2023

; 19/09/2023
;	; 04/11/2022
;	; MSDOS 5.0 MSDOS.SYS - DOSCODE:0BB27h
;	cmp	al,1
;	jne	short sr_done 		; we need Rational Patch only
;					;  on 286 systems
;	mov	word [RationalPatchPtr],RationalPatch

;----------------------------------------------------------------------------
%endif	; 28/12/2022

	; 19/09/2023
	;jmp	short sr_done

patch_vec_seg:				; patch vectors with segment in es
	mov	ax,es
	call	patch_vec_segments	; patch in DOSCODE for the segments
					; NOTE we don't have to patch the 
					; offsets as they have been already
					; set to the doscode offsets at
					; DOSINIT.
sr_done:
	mov	byte [cs:num_entry],1
	pop	ds
	retf	; ! far return !

;----------------------------------------------------------------------------
;
; Procedure Name : patch_vec_segments
;
; Inputs	 : ax -> has segment address to patch in
;		   ds -> DOSDATA
;
; Outputs	 : Patches in AX as the segment for the following vectors:
;			
;			0,20-28,3a-3f
;
; Regs. Mod.	 : DI,CX,DX,AX
;
;----------------------------------------------------------------------------

patch_vec_segments:

	push	es

	xor	cx,cx ; 0
	mov	es,cx

	;mov	di,82h
	mov	di,INTBASE+2		; di -> segment of int 20 vector

	mov	[es:2],ax		; segment of default divide trap handler

					; set vectors 20 & 21
	; 04/11/2022
	;mov	cx,2
	; 17/12/2022
	;mov	cl,2
ps_set1:
	stosw	; int 20h segment
	;add	di,2
	; 17/12/2022
	inc	di
	inc	di
	;loop	ps_set1

	; 17/12/2022
	stosw	; int 21h segment
	;inc	di
	;inc	di

	;add	di,4			; skip int 22h vector
	add	di,6 ; *

	stosw				; set int 23h
	add	di,6			; skip int 24h

					; set vectors 25-28 and 2a-3f 
	; 04/11/2022
	;mov	cx,4			; set 4 segments
	; 17/12/2022
	mov	cl,4
ps_set2:
	stosw				
	;add	di,2
	; 17/12/2022
	inc	di
	inc	di
	loop	ps_set2

	add	di,4			; skip int 29h vector (fast con) as it may
					;   already be set.
	; 04/11/2022
	;mov	cx,6			; set 6 segs (skip 2 between each)
	; 17/12/2022
	mov	cl,6			;  set segs for ints 2ah-2fh
ps_set3:
	stosw
	;add	di,2
	; 17/12/2022
	inc	di
	inc	di
	loop	ps_set3

; 30h & 31H is the CPM call entry point whose segment address is set up by
; below. So skip it.

	add	di,8			; skip vector 30h & 31h 
	
	; 04/11/2022
	;mov	cx,14			; set 14 segs (skip 2 between each)
	; 17/12/2022
	mov	cl,14			;   sets segs for ints 32h-3fh
ps_set4:
	stosw
	;add	di,2
	; 17/12/2022
	inc	di
	inc	di
	loop	ps_set4

; set offset of int2f

;if installed
;	mov	word ptr es:[02fh * 4],offset doscode:int2f
;endif
	;mov	[es:0C3h],ax
	mov	[es:ENTRYPOINT+3],ax
	; 17/12/2022
	; cx = 0
	pop	es
	retn

;---------------------------------------------------------------------------
;
; Procedure Name : patch_misc_segments
;
; Inputs	 : es = segment to patch in
;		   ds = dosdata
;
; outputs	 : patches in the sharer and other tables in the dos
;		   with right dos code segment in es
;
; Regs Mod	 : DI,SI,CX
;
;---------------------------------------------------------------------------

patch_misc_segments:

	push	bx
	push	es
	push	ax

	mov	ax,es			; ax - > DOS segment
	
	push	ds
	pop	es			; es -> DOSDATA
	
; initialize the jump table for the sharer...

	;mov	di,offset dosdata:jshare
	;mov	di,90h
	mov	di,JShare
	;mov	bx,[0AAAh]
	mov	bx,[TEMP_DOSLOC]	; bx = location to which the share
					; table was patched during the first
					; call to this routine
	mov	cx,15
jumptabloop:
	;add	di,2			; skip offset
	; 17/12/2022
	inc	di
	inc	di
	cmp	bx,-1 ; 0FFFFh		; Q: is this called for the 1st time
	je	short share_patch	; Y: patch in sharer table
					; N: 
	cmp	bx,[es:di]		; Q: has share been installed
	jne	short no_share_patch	; Y: don't patch in sharer table
share_patch:
	stosw				; drop in segment
no_share_patch:
	loop	jumptabloop
					; BUGBUG patching the country info 
					; with dosdata can be done inline
					; in dosinit.
					; for dos 3.3 country info
					; table address

	;mov	si,offset dosdata:country_cdpg
	;mov	si,122Ah   
	mov	si,COUNTRY_CDPG
					; initialize double word
					; pointers with dosdata in ds
	;mov	[si+4Fh],ds
	;mov	[si+54h],ds
	;mov	[si+59h],ds
	;mov	[si+5Eh],ds
	;mov	[si+80h],ds
	;mov	[si+63h],ds
	mov	[si+DOS_CCDPG.ccUcase_ptr+2],ds    
	mov	[si+DOS_CCDPG.ccFileUcase_ptr+2],ds 
	mov	[si+DOS_CCDPG.ccFileChar_ptr+2],ds
	mov	[si+DOS_CCDPG.ccCollate_ptr+2],ds
	mov	[si+DOS_CCDPG.ccMono_ptr+2],ds
	mov	[si+DOS_CCDPG.ccDBCS_ptr+2],ds	

					; fastopen routines are in doscode
					; so patch with doscode seg in ax

	;mov	si,offset dosdata:fastopentable
	;mov	si,0D30h
	mov	si,FastOpenTable

	; 17/12/2022
	; bx = [TEMP_DOSLOC]
	cmp	bx,-1
	;cmp	word [TEMP_DOSLOC],-1	; Q: first time 
	je	short fast_patch	; Y: patch segment
	;mov	cx,[TEMP_DOSLOC]
					; Q: has fastopen patched in it's
					;    segment
	; 17/12/2022
	cmp	bx,[si+fastopen_entry.name_caching+2]
	;;cmp	cx,[si+4]
	;cmp	cx,[si+fastopen_entry.name_caching+2]
	jne	short no_fast_patch	; Y: don't patch in doscode seg

fast_patch:
	;mov	[si+4],ax
	mov	[si+fastopen_entry.name_caching+2],ax
no_fast_patch:
	; 17/12/2022
	; cx = 0
	pop	ax
	pop	es
	pop	bx

	retn

;--------------------------------------------------------------------------
;
; Procedure Name : patch_offset
; 
; Inputs	 : NONE
;
; Outputs	 : Patches in the offsets in the low_mem_stub for vectors
;		   0,20-28,3a-3f, and 30,31
;
;
; Regs. Mod	 : AX,DI,CX
;--------------------------------------------------------------------------

patch_offset:
	push	es		; preserve es

	xor	ax,ax
	mov	es,ax
				; set default divide trap address
	;mov	word ptr es:[0],offset dosdata:ldivov	
	;mov	word [es:0],108Ah
	mov	word [es:0],ldivov

	;mov	di,80h
	mov	di,INTBASE	; di-> offset of int 20 handler
	;mov	ax,offset dosdata:lirett
	;mov	ax,10DAh
	mov	ax,lirett
				; set vectors 20 & 21 to point to iret.
	; 17/12/2022
	; cx = 0

	;mov	cx,2		; set 2 offsets (skip 2 between each)
po_iset1:
	stosw	; int 20h offset
	;add	di,2 ; *
	;loop	po_iset1
	; 17/12/2022
	inc	di
	inc	di
	stosw	; int 21h offset

	;add	di,4		; skip vector 22h
	; 17/12/2022
	add	di,6 ; *	

	stosw			; set offset of 23h
	;add	di,6		; skip 24h
	; 19/09/2023
	add	di,18		; skip 23h segment and int 24-25-26-27h

				; set vectors 25-28 and 2a-3f to iret.
	; 04/11/2022
	;mov	cx,4		; set 4 offsets (skip 2 between each)
	; 19/09/2023
	; 17/12/2022
	;mov	cl,4		;   sets offsets for ints 25h-28h
po_iset2:
	stosw		; set offset for int 28h ; 19/09/2023
	;add	di,2
	; 19/09/2023
	; 17/12/2022
	;inc	di
	;inc	di
	; 19/09/2023
	;loop	po_iset2

	;add	di,4		; skip vector 29h
	; 19/09/2023
	add	di,6	; skip int 28h segment and int 29h ; 19/09/2023

	; 04/11/2022
	;mov	cx,6		; set 6 offsets (skip 2 between each)
	; 17/12/2022
	;mov	cl,6		;   sets offsets for ints 2ah-2fh
	mov	cl,5		; sets offsets for ints 2Ah-2Eh
po_iset3:
	stosw
	;add	di,2
	; 17/12/2022
	inc	di
	inc	di
	loop	po_iset3

; 30h & 31H is the CPM call entry point whose offset address is set up by
; below. So skip it.

	;add	di,8		; skip vector 30h & 31h 
	; 17/12/2022
	add	di,12		; skip vector 2Fh, 30h & 31h

	; 04/11/2022
	;mov	cx,14		; set 14 offsets (skip 2 between each)
				;   sets offsets for ints 32h-3fh
	; 17/12/2022
	mov	cl,14 ; 26/06/2019
po_iset4:
	stosw
	;add	di,2
	; 17/12/2022
	inc	di
	inc	di
	loop	po_iset4

;if installed
	;mov	word ptr es:[02fh * 4],offset dosdata:lint2f
	;mov	word [es:0BCh],10C6h ; (MSDOS 5.0 & 6.21)
	mov	word [es:(2Fh*4)],lint2f
;endif

; set up entry point call at vectors 30-31h
	;mov	byte [es:0C0h],0EAh
	mov	byte [es:ENTRYPOINT],mi_long_jmp
	;mov	word [es:0C1h],10D0h

	mov	word [es:ENTRYPOINT+1],lcall_entry

							; 19/09/2023
	;mov	word [es:80h],1094h
	mov	word [es:addr_int_abort],lquit		; int 20h
	;mov	word [es:84h],109Eh
	mov	word [es:addr_int_command],lcommand	; int 21h
	;mov	word [es:94h],10A8h
	mov	word [es:addr_int_disk_read],labsdrd	; int 25h  
	;mov	word [es:98h],10B2h
	mov	word [es:addr_int_disk_write],labsdwrt	; int 26h
	;mov	word [es:9Ch],10BCh
	mov	word [es:addr_int_keep_process],lstay_resident	; int 27h

	; 17/12/2022
	; CX = 0
	pop	es		; restore es
	retn

;--------------------------------------------------------------------------
;
; 	Procedure Name	:	patch_in_nops
;
; 	Entry		: 	ES -> DOSDATA
;
;	Regs Mod	: 	cx, di
;
;	Description:
;		This routine patches in 2 nops at the offsets specified in 
;	patch_table. This basically enables the low mem stub to start 
;	making XMS calls.
;
;--------------------------------------------------------------------------

	; 04/11/2022
	; (MSDOS 5.0 MSDOS.SYS)
	; DOSCODE:0BC50h

patch_table:	; label	byte
	;dw	offset dosdata:i0patch
	;dw	offset dosdata:i20patch
	;dw	offset dosdata:i21patch
	;dw	offset dosdata:i25patch
	;dw	offset dosdata:i26patch
	;dw	offset dosdata:i27patch
	;dw	offset dosdata:i2fpatch
	;dw	offset dosdata:cpmpatch
	dw	i0patch
	dw	i20patch
	dw	i21patch
	dw	i25patch
	dw	i26patch
	dw	i27patch
	dw	i2fpatch
	dw	cpmpatch

patch_table_size equ ($-patch_table)/2

patch_in_nops:
	push	ax
	push	si
	mov	si,patch_table
	mov	ax,9090h ; nop, nop
	; 17/12/2022
	; cx = 0
	;mov	cx,8
	;mov	cx,patch_table_size ; 8
	mov	cl,patch_table_size ; 8
pin_loop:
	mov	di,[cs:si]
	stosw
	;add	si,2
	; 17/12/2022
	inc	si
	inc	si
	loop	pin_loop
	pop	si
	pop	ax
	retn

; 05/12/2022 (MSDOS 5.0 MSDOS.SYS compatibility)
; ---------------------------------------------------------------------------
; MSDOS 5.0 - MSDOS.SYS offset BC77h, file offset 7EA7h
; ---------------------------------------------------------------------------

	; 05/12/2022 - temporary ; (paragraph alinment)
DOSCODE_END:
	;times	9 db 0	; db 9 dup(0)
	; 18/12/2022
	dw	0  ;	times 2 db 0

;align 16
	; DOSCODE:BC80h	(MSDOS 5.0 MSDOS.SYS file offset 7EB0h)
	; MSDOS.SYS file offset: 32432 (start of DOSDATA)

; ---------------------------------------------------------------------------


;memstrt label word
; ---------------------------------------------------------------------------
; MSDOS 6.21 - MSDOS.SYS offset BF69h, file offset 8189h
; ---------------------------------------------------------------------------

MEMSTRT: ; 25/04/2019 - Retro DOS v4.0

; if not ROMDOS, then we close the dos code segment, otherwise we close
; the dos initialization segment

;ifndef ROMDOS

;doscode ends

;else

;;dosinitseg ends

;endif ; ROMDOS

;============================================================================

; DPUBLIC <ParaRound, cXMM_no_driver, cXMMexit, char_init_loop, charinit>
; DPUBLIC <check_XMM, continit, dosinttabloop, endlist>
; DPUBLIC <initiret, iset1, iset2, jumptabloop, nxtentry>
; DPUBLIC <notmax,  patch_offset, perdrv>
; DPUBLIC <perunit, po_iset1, po_iset2, po_iset3>
; DPUBLIC <ps_set1, ps_set2, ps_set3, seg_reinit>
; DPUBLIC <sr_done, version_fake_table, xxx>

;; burasý doscode sonu

;============================================================================
; DOSDATA
;============================================================================
; 29/04/2019 - Retro DOS 4.0

;[BITS 16]

;[ORG 0]

; 25/04/2019 - Retro DOS v4.0

;============================================================================
; DOSDATA - MSDOS 6.21 - MSDOS.SYS Offset 0BF70h, file offset 8190h
;============================================================================

;align 16
	; DOSDATA (MSDOS.SYS kernel DATA) segment starts here...
	; (4970 bytes for MSDOS 6.21)
	; (4976 bytes for Retro DOS v4.0, 25/05/2019 modification.)

;============================================================================
; MSCONST.ASM (MSDOS 6.0, 1991)
;============================================================================
; 03/11/2022 - Retro DOS 4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; 25/04/2019 - Retro DOS 4.0 (MSDOS 6.21)
; 16/07/2018 - Retro DOS 3.0	

;Break <Initialized data and data used at DOS initialization>
;----------------------------------------------------------------------------

; We need to identify the parts of the data area that are relevant to tasks
; and those that are relevant to the system as a whole. Under 3.0, the system
; data will be gathered with the system code. The process data under 2.x will
; be available for swapping and under 3.0 it will be allocated per-process.
;
; The data that is system data will be identified by [SYSTEM] in the comments
; describing that data item.

;DOSDATA SEGMENT

; 04/11/2022
;[ORG 0]

; ----------------------------------------------------------------------------
; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; ----------------------------------------------------------------------------
; DOSDATA segment start offset from beginning of MSDOS.SYS file: 32432 (7EB0h)
; (3DD0h+7EB0h = 0BC80h) - for MSDOS 5.0 kernel file -
; ----------------------------------------------------------------------------

; 04/11/2022

;DOSDATA:0000h

align 16

; ----------------------------------------------------------------------------
; 06/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; ----------------------------------------------------------------------------

segment .data  vstart=0 ; 06/12/2022
								
; ============================================================================

; 06/12/2022
;DOSDATASTART equ $
DOSDATASTART:


;hkn; add 4 bytes to get correct offsets since jmp has been removed in START

	;; 03/11/2022
	;jmp	DOSINIT		; MSDOS 5.0 - MSDOS.SYS (DOSDATA:0000h)

	; 04/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	;db	4 dup (?)	
	times	4 db 0

	; 29/04/2019 - Retro DOS v4.0 modification
	;dw 	_$STARTCODE ; DOSCODE offset and/or size of DOSDATA
	;dw	0

	;EVEN

;align 2

; WANGO!!! The following word is used by SHARE and REDIR to determin data
; area compatability. This location must be incremented EACH TIME the data
; area here gets mucked with.
;
; Also, do NOT change this position relative to DOSDATA:0.

MSCT001S:	; LABEL BYTE
	
DataVersion:	
	dw	1	;AC000; [SYSTEM] version number for DOS DATA

;hkn; add 8 bytes to get correct offsets since BugTyp, BugLev and "BUG " has 
;hkn; been removed to DOSCODE above

;M044
; First part of save area for saving last para of Window memory

WinoldPatch1:	; db 8 dup (?)	;M044
	times	8 db 0

	; MSDOS 6.21 DOSDATA:000Eh
MYNUM:			; Offset 000Eh
	dw	0	; [SYSTEM] A number that goes with MYNAME
FCBLRU: 		; [SYSTEM] LRU count for FCB cache
	dw	0
OpenLRU:
	dw	0	; [SYSTEM] LRU count for FCB cache opens
OEM_HANDLER: 		
	dd	-1	; [SYSTEM] Pointer to OEM handler code	

;	BUGBUG - who uses LeaveAddr?  What if we want to rework the
;;			way that we leave DOS???? - jgl

LeaveAddr:
	dw	LeaveDOS  ; <<OFFSET DOSCODE:LeaveDOS>> ; [SYSTEM]
RetryCount:		
	dw	3	; [SYSTEM] Share retries
RetryLoop:
	dw	1	; [SYSTEM] Share retries
LastBuffer:
	dd	-1	; [SYSTEM] Buffer queue recency pointer
CONTPOS:
	dw	0	; [SYSTEM] location in buffer of next read
arena_head:
	dw	0	; [SYSTEM] Segment # of first arena in memory

;; 16/07/2018
;;***************************************************************************
;; NOTE: INT 21H AH=52H !  (http://stanislavs.org/helppc/int_21-52.html)
;;***************************************************************************
;; INT 21,52 - Get Pointer to DOS "INVARS" (Undocumented)
;;
;;	AH = 52h
;;
;;	on return:
;;	ES:BX = pointer to DOS "invars", a table of pointers used by DOS.
;;		Known "invars" fields follow (varies with DOS version):
;;
;;	Offset Size		 Description
;;
;;	 -12   word   sharing retry count (DOS 3.1-3.3)
;;	 -10   word   sharing retry delay  (DOS 3.1-3.3)
;;	  -8   dword  pointer to current disk buffer (DOS 3.x)
;;	  -4   word   pointer in DOS code segment of unread CON input;
;;		      0 indicates no unread input (DOS 3.x)
;;	  -2   word   segment of first Memory Control Block (MCB)
;;	  00   dword  pointer to first DRIVE PARAMETER TABLE (A:) in chain
;;	  04   dword  pointer to DOS System File Table (SFT)
;;	  08   dword  pointer to $CLOCK device driver
;;	  0C   dword  pointer to CON device driver
;;	  10   byte   number of logical drives in system
;;	  11   word   maximum bytes/block of any block device
;;	  13   dword  pointer to DOS cache buffer header
;;	  17 18bytes  NUL device header, first 4 bytes of device header
;;		      point to the next device in device chain
;;
;;***************************************************************************

; The following block of data is used by SYSINIT. 
; Do not change the order or size of this block

;SYSINITVAR:
;----------------------------------------------------------------------------
SYSINITVARS:
DPBHEAD:
	dd	0	; [SYSTEM] Pointer to head of DPB-FAT list
SFT_ADDR:
	dd	SFTABL	; [SYSTEM] Pointer to first SFT table
BCLOCK:
	dd	0	; [SYSTEM] The CLOCK device
BCON:
	dd	0	; [SYSTEM] Console device entry points
MAXSEC:
	dw	128	; [SYSTEM] Maximum allowed sector size
BUFFHEAD:
	dd	0	; [SYSTEM] Pointer to head of buffer queue
CDSADDR:
	dd	0	; [SYSTEM] Pointer to curdir structure table
SFTFCB:
	dd	0	; [SYSTEM] pointer to FCB cache table
KEEPCOUNT:
	dw	0	; [SYSTEM] count of FCB opens to keep
NUMIO:
	db	0	; [SYSTEM] Number of disk tables
CDSCOUNT:
	db	0	; [SYSTEM] Number of CDS structures in above

; A fake header for the NUL device
NULDEV:
	dd	0	; [SYSTEM] Link to rest of device list
	;dw	8004h
	dw	DEVTYP|ISNULL ; [SYSTEM] Null device attributes
	dw	SNULDEV	; [SYSTEM] Strategy entry point
	dw	INULDEV	; [SYSTEM] Interrupt entry point
	db	"NUL     " ; [SYSTEM] Name of null device
SPLICES:
	db	0	; [SYSTEM] TRUE => splices being done

Special_Entries:
	dw	0	; [SYSTEM] address of special entries ;AN000;
UU_IFS_DOS_CALL:
	dd	0	; [SYSTEM] entry for IFS DOS service ;AN000;
; 
; UU_IFS_HEADER:
; 	dd	0	; [SYSTEM] IFS header chain ;AN000;

ChkCopyProt:
	dw	0	; M068
A20OFF_PSP:
	dw	0	; M068
BUFFERS_PARM1:
	dw	0	; [SYSTEM] value of BUFFERS= ,m	;AN000;
BUFFERS_PARM2:
	dw	0	; [SYSTEM] value of BUFFERS= ,n ;AN000;
BOOTDRIVE:
	db	0	; [SYSTEM] the boot drive ;AN000;
DDMOVE:
	db	0 	; [SYSTEM] 1 if we need DWORD move ;AN000;
EXT_MEM_SIZE:
	dw	0	; [SYSTEM] extended memory size	;AN000;

HASHINITVAR: ; LABEL   WORD	; AN000;
;
; Replaced by next two declarations
;
;UU_BUF_HASH_PTR:
;	dd	0	; [SYSTEM] buffer Hash table addr
;UU_BUF_HASH_COUNT:
;	dw	1	; [SYSTEM] number of Hash entries

BufferQueue:
	dd	0	; [SYSTEM] Head of the buffer Queue
DirtyBufferCount:
	dw	0	; [SYSTEM] Count of Dirty buffers in the Que
			; BUGBUG ---- change to byte
SC_CACHE_PTR:
	dd	0	; [SYSTEM] secondary cache pointer
SC_CACHE_COUNT:
	dw	0 	; [SYSTEM] secondary cache count
BuffInHMA:
	db	0	; Flag to indicate that buffs are in HMA
LoMemBuff:
	dd	0	; Ptr to intermediate buffer
			;  in Low mem when buffs are in HMA
;
; All variables which have UU_ as prefix can be reused for other
; purposes and can be renamed. All these variables were used for
; EMS support of Buffer Manager. Now they are useless for Buffer
; manager ---- MOHANS
;
	;I_am	UU_BUF_EMS_FIRST_PAGE,3,<0,0,0>  
UU_BUF_EMS_FIRST_PAGE:	
	db	0,0,0	; holds the first page above 640K

	;;I_am	UU_BUF_EMS_NPA640,WORD,<0> ; holds the number of pages 
;UU_BUF_EMS_NPA640:			   ; above 640K	
;	dw	0			

CL0FATENTRY:
	dw	-1	; M014:	Holds the data that
			; is used in pack/unpack rts.
			; in fat.asm if cluster 0 is specified.
			; SR;
IoStatFail:
	db	0	; IoStatFail has been added to 
			; record a fail on an I24 
			; issued from IOFUNC on a status call. 

;***	I_am	UU_BUF_EMS_MODE,BYTE,<-1>	; EMS mode 	;AN000;
;***	I_am	UU_BUF_EMS_HANDLE,BYTE		; buffer EMS handle ;AN000;
;***	I_am	UU_BUF_EMS_PAGE_FRAME,WORD ,<-1>; EMS page frame # ;AN000;
;***	I_am	UU_BUF_EMS_SEG_CNT,WORD,<1>	; EMS seg count	;AN000;
;***	I_am	UU_BUF_EMS_PFRAME,WORD		; EMS page frame seg address ;AN000;
;***	I_am	UU_BUF_EMS_RESERV,WORD,<0> 	; reserved	;AN000;
;
;***	I_am	UU_BUF_EMS_MAP_BUFF,1,<0>	; this is not used to save the 
						; state of the 	buffers page.
						; This one byte is retained to 
						; keep the size of this data 
						; block the same.;
ALLOCMSAVE:
	db	0	; M063: temp var. used to 
			; M063: save alloc method in
			; M063: msproc.asm
A20OFF_COUNT:
	db	0	; M068: indiactes the # of 
			; M068: int 21 calls for 
			; M068: which A20 is off
DOS_FLAG:
	db	0	; see DOSSYM.INC for Bit 
			; definitions
UNPACK_OFFSET:
	dw	0	; saves pointer to the start
			; of unpack code in exepatch.
			; asm.
UMBFLAG:
	db	0 	; M003: bit 0 indicates the 
			; M003: link state of the UMBs
			; M003: whether linked or not 
			; M003: to the DOS arena chain
SAVE_AX:
	dw	0	; M000: temp varibale to store ax
			; M000: in msproc.asm
UMB_HEAD:
	dw	-1	; M000: this is initialized to  
			; M000: the first umb arena by 
			; M000: BIOS sysinit.
START_ARENA:
	dw	1	; M000: this is the first arena 
			; M000: from which DOS will 
			; M000: start its scan for alloc.

; End of SYSINITVar block
;----------------------------------------------------------------------------

; 25/04/2019 - Retro DOS v4.0

; 16/07/2018
; MSDOS 3.3 (& MDOS 6.0)

;
; Sharer jump table
;

;PUBLIC	JShare
	;EVEN

;JShare	LABEL	DWORD
;	DW	OFFSET DOSCODE:BadCall, 0
;	DW	OFFSET DOSCODE:OKCall,  0  ;	1   MFT_enter
;	DW	OFFSET DOSCODE:OKCall,  0  ;	2   MFTClose
;	DW	OFFSET DOSCODE:BadCall, 0  ;	3   MFTclU
;	DW	OFFSET DOSCODE:BadCall, 0  ;	4   MFTCloseP
;	DW	OFFSET DOSCODE:BadCall, 0  ;	5   MFTCloN
;	DW	OFFSET DOSCODE:BadCall, 0  ;	6   set_block
;	DW	OFFSET DOSCODE:BadCall, 0  ;	7   clr_block
;	DW	OFFSET DOSCODE:OKCall,  0  ;	8   chk_block
;	DW	OFFSET DOSCODE:BadCall, 0  ;	9   MFT_get
;	DW	OFFSET DOSCODE:BadCall, 0  ;	10  ShSave
;	DW	OFFSET DOSCODE:BadCall, 0  ;	11  ShChk
;	DW	OFFSET DOSCODE:OKCall , 0  ;	12  ShCol
;	DW	OFFSET DOSCODE:BadCall, 0  ;	13  ShCloseFile
;	DW	OFFSET DOSCODE:BadCall, 0  ;	14  ShSU

align 2

JShare:
		DW	BadCall,0
MFT_enter:	DW	OKCall, 0  ; 1   MFT_enter
MFTClose:	DW	OKCall, 0  ; 2   MFTClose
MFTclU:		DW	BadCall,0  ; 3   MFTclU
MFTCloseP:	DW	BadCall,0  ; 4   MFTCloseP
MFTCloN:	DW	BadCall,0  ; 5   MFTCloN
set_block:	DW	BadCall,0  ; 6   set_block
clr_block:	DW	BadCall,0  ; 7   clr_block
chk_block:	DW	OKCall, 0  ; 8   chk_block
MFT_get:	DW	BadCall,0  ; 9   MFT_get
ShSave:		DW	BadCall,0  ; 10  ShSave
ShChk:		DW	BadCall,0  ; 11  ShChk
ShCol:		DW	OKCall, 0  ; 12  ShCol
ShCloseFile:	DW	BadCall,0  ; 13  ShCloseFile
ShSU:		DW	BadCall,0  ; 14  ShSU


;============================================================================
; CONST2.ASM (MSDOS 6.0, 1991)
;============================================================================
; 25/04/2019 - Retro DOS 4.0 
; 16/07/2018 - Retro DOS 3.0	

;Break <Initialized data and data used at DOS initialization>
;----------------------------------------------------------------------------

; We need to identify the parts of the data area that are relevant to tasks
; and those that are relevant to the system as a whole.  Under 3.0, the system
; data will be gathered with the system code.  The process data under 2.x will
; be available for swapping and under 3.0 it will be allocated per-process.
;
; The data that is system data will be identified by [SYSTEM] in the comments
; describing that data item.

;DOSDATA SEGMENT WORD PUBLIC 'DATA'

;
; Table of routines for assignable devices
;
; MSDOS allows assignment if the following standard devices:
;   stdin  (usually CON input)
;   stdout (usually CON output)
;   auxin  (usually AUX input)
;   auxout (usually AUX output)
;   stdlpt (usually PRN output)
;
; SPECIAL NOTE:
;   Status of a file is a strange idea. We choose to handle it in this manner:
;   If we're not at end-of-file, then we always say that we have a character.
;   Otherwise, we return ^Z as the character and set the ZERO flag. In this
;   manner we can support program written under the old DOS (they use ^Z as EOF
;   on devices) and programs written under the new DOS (they use the ZERO flag
;   as EOF).

; Default SFTs for boot up

		;PUBLIC	SFTABL

SFTABL:	   ; LABEL   DWORD		; [SYSTEM] file table
		DW -1			; [SYSTEM] link to next table
		DW -1			; [SYSTEM] link seg to next table
		DW sf_default_number	; [SYSTEM] Number of entries in table
		;times 295 db 0 ; MSDOS 6.0
		times (sf_default_number*sf_entry_size) db 0

; the next two variables relate to the position of the logical stdout/stdin
; cursor. They are only meaningful when stdin/stdout are assigned to the
; console.
		; DOSDATA:01F9h (MSDOS 6.21)
CARPOS:		db 0			; [SYSTEM] cursor position in stdin
STARTPOS:	db 0			; [SYSTEM] position of cursor at beginning
					;	   of buffered input call
INBUF:		times 128 db 0		; [SYSTEM] general device input buffer
CONBUF:		times 131 db 0		; [SYSTEM] The rest of INBUF and console buffer
		; DOSDATA:02FEh (MSDOS 6.21)
PFLAG:		db 0			; [SYSTEM] printer echoing flag
VERFLG:		db 0			; [SYSTEM] Initialize with verify off
CHARCO:		db 00000011b		; [SYSTEM] Allows statchks every 4 chars...
switch_character:
chSwitch:	db '/'			; UNUSED - obsolete datum, can be reused
AllocMethod:	db 0			; [SYSTEM] how to alloc first(best)last
fShare:		db 0			; [SYSTEM] TRUE => sharing installed
DIFFNAM:	db 1			; [SYSTEM] Indicates when MYNAME has changed
MYNAME:		times 16 db 20h		; [SYSTEM] My network name

; The following table is a list of addresses that the sharer patches to be
; PUSH AX to enable the critical sections

		; DOSDATA:0315h (MSDOS 6.21)

;PUBLIC	CritPatch

CritPatch:	; LABEL WORD

;IRP sect,<critDisk,critDevice>

;IF (NOT REDIRECTOR) AND (NOT SHAREF)
;
;SR; Change code patch address to a variable in data segment
;
;       dw OFFSET DOSDATA: redir_patch
;       dw OFFSET DOSDATA: redir_patch
;
;;hkn	Short_Addr  E&sect
;;hkn	Short_Addr  L&sect
;
;ELSE
;	DW	0
;	DW	0
;ENDIF
;ENDM
;	DW	0

	; 25/07/2019 - Retro DOS v4.0 (MSDOS 6.21)
 
	dw 	redir_patch
	dw 	redir_patch			
	dw	redir_patch
	dw 	redir_patch

	dw	0

; WARNING!!! PRINT and PSPRINT *REQUIRE* ErrorMode to precede INDOS.
; Also, IBM server 1.0 requires this also.

	;EVEN			; Force swap area to start on word boundry
align 2
	;PUBLIC	SWAP_START
SWAP_START:	; LABEL BYTE
ERRORMODE:	db 0		; Flag for INT 24 processing
INDOS:		db 0		; DOS status for interrupt processing
WPERR:		db -1		; Write protect error flag
EXTERR_LOCUS:	db 0		; Extended Error Locus
EXTERR:		dw 0		; Extended Error code

;WARNING Following two bytes Accessed as word in $GetExtendedError
EXTERR_ACTION:	db 0		; Extended Error Action
EXTERR_CLASS:	db 0		; Extended Error Class
; end warning
 
EXTERRPT:	dd 0		; Extended Error pointer

DMAADD:		dd 80h		; User's disk transfer address (disp/seg)
CurrentPDB:	dw 0		; Current process identifier
ConC_Spsave:	dw 0		; saved SP before ^C
exit_code:	dw 0		; exit code of last proc.
CURDRV:		db 0		; Default drive (init A)
CNTCFLAG:	db 0		; ^C check in dispatch disabled
;				; F.C. 2/17/86
CPSWFLAG:	db 0		; Code Page Switching Flag  DOS 4.00
CPSWSAVE:	db 0		; copy of above in case of ABORT
;align 2
SWAP_ALWAYS:	; 05/08/2018
USER_IN_AX:	dw 0		; User INPUT AX value (used for
				;   extended error type stuff.
				;   NOTE: does not have Correct value on
				;   1-12, OEM, Get/Set CurrentPDB,
				;   GetExtendedError system calls)
PROC_ID:	dw 0		; PID for sharing (0 = local)
USER_ID:	dw 0		; Machine for sharing (0 = local)
FirstArena:	dw 0		; first free block found
BestArena:	dw 0		; best free block found
LastArena:	dw 0		; last free block found
ENDMEM:		dw 0		; End of memory used in DOSINIT
LASTENT:	dw 0		; Last entry for directory search
FAILERR:	db 0		; NZ if user did FAIL on I 24
ALLOWED:	db 0		; Allowed I 24 answers (see allowed_)
NoSetDir:	db 0		; true -> do not set directory
DidCTRLC:	db 0		; true -> we did a ^C exit
SpaceFlag:	db 0		; true -> embedded spaces are allowed in FC

; Warning!  The following items are accessed as a WORD in TIME.ASM
	;EVEN
align 2
		; DOSDATA:0350h (MSDOS 6.21)
DAY:		db 0		; Day of month
MONTH:		db 0		; Month of year
YEAR:		dw 0		; Year (with century)
DAYCNT:		dw -1		; Day count from beginning of year
WEEKDAY:	db 0		; Day of week
; end warning

CONSWAP:	db 0		; TRUE => console was swapped during device read
IDLEINT:	db 1		; TRUE => idle int is allowed
fAborting:	db 0		; TRUE => abort in progress

; Combination of all device call parameters
	;PUBLIC	DEVCALL 	;
;DEVCALL SRHEAD	<>		; basic header for disk packet
DEVCALL: ; 08/08/2018
DEVCALL_REQLEN:  db 0 		;Length in bytes of request block
DEVCALL_REQUNIT: db 0		;Device unit number
DEVCALL_REQFUNC: db 0		;Type of request
DEVCALL_REQSTAT: dw 0		;Status Word
         times 8 db 0		;Reserved for queue links

	;PUBLIC	CALLUNIT
CALLUNIT: ; LABEL   BYTE	; unit number for disk
CALLFLSH: ; LABEL   WORD	;
CALLMED:	db 0		; media byte
CALLBR:	  ; LABEL   DWORD	;
	;PUBLIC	CALLXAD 	;
CALLXAD:  ; LABEL   DWORD	;
CALLRBYT:	db 0		;
	;PUBLIC	CALLVIDM	;
CALLVIDM: ; LABEL   DWORD	;
	times 3 db 0	;
	;PUBLIC CallBPB		;
CALLBPB:  ; LABEL   DWORD	;
CALLSCNT:			;
		dw 0		;
	;PUBLIC	CALLSSEC	;
CALLSSEC: ; LABEL   WORD	;
		dw 0		;
CALLVIDRW:	dd 0		;
;MSDOS 6.0
CALLNEWSC:	dd 0		; starting sector for >32mb
CALLDEVAD:	dd 0		; stash for device entry point

; Same as above for I/O calls	;
				;
	;PUBLIC	IOCall		;
;IOCALL	SRHEAD	<>		;
IOCALL:	; 07/08/2018
IOCALL_REQLEN:	db 0		;Length in bytes of request block	
IOCALL_REQUNIT:	db 0		;Device unit number
IOCALL_REQFUNC: db 0		;Type of request
IOCALL_REQSTAT: dw 0		;Status Word
	times 8	db 0		;Reserved for queue links
IOFLSH:	  ; LABEL   WORD	;
        ;PUBLIC  IORCHR		;
IORCHR:	  ; LABEL   BYTE	;
IOMED:		db 0		;
IOXAD:		dd 0		;
IOSCNT:		dw 0		;	
IOSSEC:		dw 0		;

; Call struct for DSKSTATCHK	;
DSKSTCALL:	db DRDNDHL 	; = 14
		db 0
DSKSTCOM:	db DEVRDND	; = 5
DSKSTST:	dw 0		;
	times 8	db 0		;
DSKCHRET:	db 0		;

;hkn; short_addr has been changed to provide offset in DOSCODE.
;hkn; deviobuf is in DATA seg (DOSDATA)
;hkn   short_addr  DEVIOBUF	;
	
DEVIOBUF_PTR	dw DEVIOBUF
DOSSEG_INIT	dw 0		; DOS segment set at Init
DSKSTCNT:	dw 1		;
		dw 0		;

CreatePDB:	db 0		; flag for creating a process

;MSDOS 6.0
Lock_Buffer:	; LABEL  DWORD	;MS. DOS Lock Buffer for Ext Lock
		dd 0		;MS. position
		dd 0		;MS. length

;hkn; the foll. was moved from dosmes.asm.

	;EVEN
align 2				; needed to maintain offsets

		; DOSDATA:03B2h (MSDOS 6.21)
USERNUM:
 		dw 0		; 24 bit user number
		db 0
;IF IBM
;IF IBMCOPYRIGHT
;OEMNUM:	DB 0		; 8 bit OEM number
;ELSE
;OEMNUM:	DB 0FFh		; 8 bit OEM number
;ENDIF
;ELSE
OEMNUM:		DB 0FFh
;ENDIF

;============================================================================
; MS_DATA.ASM (MSDOS 6.0, 1991)
;============================================================================
; 25/04/2019 - Retro DOS 4.0

; Retro DOS v4.0 NOTE: (by Erdogan Tan, 25/04/2019)
; ----------------------------------------------------------
; This data section which was named as uninitialized data
; (as overlayed by initialization code) but follows 
; initialized data section from DOSDATA:03B6h address
; (in otherwords, the method is different than MSDOS 3.3,
; and there is not overlaying..)
; **********************************************************
; Reference: MSDOS 6.21 kernel DOSDATA section (4970 bytes)
; follows DOSCODE section in the kernel file (MSDOS.SYS) 
; (it is located at offset 0BF70h, file offset 0BF70h-3DE0h) 
; but starts from offset 0 (ORG 0) and ends at offset 1370h.
; TIMEBUF is at offset 03B6h.
; **********************************************************	

;Break <Uninitialized data overlayed by initialization code>
;----------------------------------------------------------------------------
;DOSDATA    SEGMENT WORD PUBLIC 'DATA'
; Init code overlaps with data area below

; 	ORG     0

MSDAT001S:	; label byte

; DOSDATA:03B6h	; MSDOS 6.21 (MSDOS.SYS, file offset 0BF70h-3DE0h+3B6h)
TIMEBUF: ;	times 6 db 0
	times 3 dw	0		; Time read from clock device
DEVIOBUF:	dw	0		; Buffer for I/O under file assignment

; The following areas are used as temp buffer in EXEC system call

; DOSDATA:03BEh
OPENBUF: ;times 64  dw	0
	times	128 db	0		; buffer for name operations
RENBUF:	
	times	128 db	0		; buffer for rename destination

; Buffer for search calls
SEARCHBUF:	
	times	53  db	0		; internal search buffer
DUMMYCDS:  ;times 88 db 0
	times	curdirLen db 0

; End of contiguous buffer
 
; Temporary directory entry for use by many routines. Device directory
; entries (bogus) are built here.

; DOSDATA:054Bh

DEVFCB:	; LABEL   BYTE			; Uses NAME1, NAME2, combined

; WARNING..  do not alter position of NAME1 relative to DEVFCB
; without first examining BUILD_DEVICE_ENT. Look carefully at DOS_RENAME
; as well as it is the only guy who uses NAME2 and DESTSTART.

NAME1:	
        times 	12 db	0		; File name buffer
NAME2:
	times	13 db	0 		;
DESTSTART:
	dw	0			;
        ;DB      ((SIZE DIR_ENTRY) - ($ - DEVFCB)) DUP (?)
	;times	5  db	0
	times	((dir_entry.size)-($-DEVFCB)) db 0

; End Temporary directory entry.

ATTRIB:	db	0		; storage for file attributes
EXTFCB:	
	db	0		; TRUE => extended FCB in use
SATTRIB:
	db	0		; Storage for search attributes
OPEN_ACCESS:
	db	0		; access of open system call
FOUNDDEL:
	db	0		; true => file was deleted
FOUND_DEV:
	db	0		; true => search found a device
FSPLICE:
	db	0		; true => do a splice in transpath
FSHARING:
	db	0		; TRUE => no redirection
SECCLUSPOS:
	db	0		; Position of first sector within cluster
TRANS:	db	0		;
READOP:	db	0		;
THISDRV:
	db	0		;
CLUSFAC:
	db	0		;
CLUSSPLIT:
	db	0		;
INSMODE:
	db	0		; true => insert mode in buffered read
CMETA:	db	0		; count of meta'ed components found
VOLID:	db	0		;
EXIT_TYPE:
	db	0		; type of exit...
 
	;EVEN

align 2

; DOSDATA:057Eh

; WARNING - the following two items are accessed as a word

CREATING:
	db	0		; true => creating a file
DELALL:	db	0		; = 0 iff BUGBUG
				; = DIRFREE iff BUGBUG
EXITHOLD:
	dd	0		; Temp location for proc terminate
USER_SP:
	dw	0		; User SP for system call
USER_SS:
	dw	0		; User SS for system call
CONTSTK:
	dw	0		;
THISDPB:
	dd	0		;
CLUSSAVE:
	dw	0		;
CLUSSEC:
	dd	0		;>32mb			AC0000
PREREAD:
	dw	0		; 0 means preread; 1 means optional
FATBYT:	dw	0		; Used by ALLOCATE
FATBYTE:
	dw	0		; Used by $SLEAZEFUNC
; DOSDATA:059Ah
DEVPT:	dd	0		;
THISSFT:
	dd	0		; Address of user SFT
THISCDS:
	dd	0		; Address of current CDS
THISFCB:
	dd	0		; Address of user FCB
SFN:	dw	-1		; SystemFileNumber found for accessfile
JFN:	dw	0		; JobFileNumber found for accessfile
PJFN:	dd	0		; PointerJobFileNumber found for accessfile
WFP_START:
	dw	0		;
REN_WFP:
	dw	0		;
CURR_DIR_END:
	dw	0		;
NEXTADD:
	dw	0		;
LASTPOS:
	dw	0		;
CLUSNUM:
	dw	0		;
DIRSEC:	dd	0		;>32mb			AC0000
DIRSTART:
	dw	0		;
SECPOS:	dd	0		;>32mb Position of first sector accessed
VALSEC:	dd	0		;>32mb Number of valid (previously written)
                                ; sectors
BYTSECPOS:
	dw	0		; Position of first byte within sector
BYTPOS: ;times	4 db 0		; Byte position in file of access
        times	2 dw 0
BYTCNT1:
	dw	0		; No. of bytes in first sector
BYTCNT2:
	dw	0		; No. of bytes in last sector
SECCNT:	dw	0		; No. of whole sectors
; DOSDATA:05D8h
ENTFREE:
	dw	0		;
ENTLAST:
	dw	0		;
NXTCLUSNUM:
	dw	0		;
GROWCNT:
	dd	0		;
CURBUF:	dd	0		;
CONSFT:	dd	0		; SFT of console swapped guy.
SAVEBX:	dw	0		;
SAVEDS:	dw	0		;
RESTORE_TMP:
	dw	0		; return address for restore world
NSS:	dw	0
NSP:	dw	0
; DOSDATA:05F4h
EXTOPEN_FLAG:
	dw	0		;FT. extended open input flag	;AN000;
EXTOPEN_ON:
	db	0		;FT. extended open conditional flag ;AN000;
EXTOPEN_IO_MODE:
	dw	0		;FT. extended open io mode	;AN000;
SAVE_DI:
	dw	0		;FT. extended open saved DI	;AN000;
SAVE_ES:
	dw	0		;FT. extended open saved ES	;AN000;
SAVE_DX:
	dw	0		;FT. extended open saved DX	;AN000;
SAVE_CX:
	dw	0		;FT. extended open saved CX	;AN000;
SAVE_BX:
	dw	0		;FT. extended open saved BX	;AN000;
SAVE_SI:
	dw	0		;FT. extended open saved SI	;AN000;
SAVE_DS:
	dw	0		;FT. extended open saved DS	;AN000;

; DOSDATA:0607h

; HIGH_SECTOR is a hack to allow passing 32-bit sector numbers where
; we used to just pass 16 bits in a register. Now High_SECTOR holds
; the high 16, the low 16 are still in the register.

HIGH_SECTOR:	
	dw	0		;>32mb higher sector #		;AN000;
	; 25/09/2023
OffsetMagicPatch:
	;dw	MagicPatch	;scottq 8/6/92
	; 06/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
	dw	0
				;see dos\mpatch.asm
DISK_FULL:
	db	0		;>32mb indicating disk full when 1 ;AN000;
TEMP_VAR:
	dw	0		; temporary variable for everyone ;AN000;
TEMP_VAR2:
	dw	0		; temporary variable 2 for everyone ;AN000;
DrvErr:	db	0		; used to save drive error	;AN000;
DOS34_FLAG:
	dw	0		; common flag for DOS 3.4	;AN000;
NO_FILTER_PATH:
	dd	0		; pointer to original path	;AN000;
NO_FILTER_DPATH:
	dd	0		; pointer to original path of destination ;AN000;
; M008
AbsRdWr_SS:
	dw	0		; INT 25/26 user stack segment
AbsRdWr_SP:
	dw	0		; INT 25/26 user stack offset

	; I_am   UU_Callback_flag,BYTE,<0>  ; Unused
; M008
 
 
; make those pushes fast!!!

;EVEN

align 2

StackSize   equ 180h  ; 384	; gross but effective

;StackSize  equ 300h  ;	768	; This is a "trial" change IBM hasn't
;				; made up their minds about
 
; WARNING!!!! DskStack may grow into AUXSTACK due to interrupt service.
; This is NO problem as long as AUXSTACK comes immediately before DSKSTACK

RENAMEDMA:	; LABEL   BYTE	; See DOS_RENAME
 
        times	StackSize db	0	;
AUXSTACK:			; LABEL   BYTE
 
        times	StackSize db 	0	;
DSKSTACK:			; LABEL   BYTE
 
        times	StackSize db	0	;
IOSTACK:			; LABEL   BYTE

; DOSDATA:0AA0h 
 
; patch space for Boca folks.
; Say What????!!! This does NOT go into the swappable area!
; NOTE: We include the decl of ibmpatch in ms-dos even though it is not needed.
;       This allows the REDIRector to work on either IBM or MS-DOS.
 
IBMPATCH: ; label byte
PRINTER_FLAG:
	db	0		; [SYSTEM] status of PRINT utility
VOLCHNG_FLAG:
	db	0		; [SYSTEM] true if volume label created
VIRTUAL_OPEN:
	db	0		; [SYSTEM] non-zero if we opened a virtual file
 
; Following 4 variables moved to MSDATA.asm from MSTABLE.asm (P4986)

FSeek_drive:
	db	0		;AN000; fastseek drive #
FSeek_firclus:
	dw	0		;AN000; fastseek first cluster #
FSeek_logclus:
	dw	0		;AN000; fastseek logical cluster #
FSeek_logsave:
	dw	0		;AN000; fastseek returned log clus #

; DOSDATA:0AAAh

TEMP_DOSLOC:
	dw	-1		;stores the temporary location of dos
				;at SYSINIT time.
SWAP_END:  ; LABEL   BYTE
 
; THE FOLLOWING BYTE MUST BE HERE, IMMEDIATELY FOLLOWING SWAP_END. IT CANNOT
; BE USED. If the size of the swap data area is ODD, it will be rounded up
; to include this byte.
 
	db	0

; DOSDATA:0AADh
 
;hkn;	DB	(512+80+32-(SWAP_END-ibmpatch)) DUP (?)

;DOSDATA    ENDS

;============================================================================
; DOSTAB.ASM (MSDOS 6.0, 1991)
;============================================================================
; 27/04/2019 - Retro DOS 4.0
; 16/07/2018 - Retro DOS 3.0

;DOSDATA Segment

; DOSDATA:0AADh (MSDOS 6.21, MSDOS.SYS)

;
; upper case table
; ---------------------------------------------------------------------------
UCASE_TAB:	; label   byte
	dw	128
	db	128,154,069,065,142,065,143,128 
	db	069,069,069,073,073,073,142,143
	db	144,146,146,079,153,079,085,085
	db	089,153,154,155,156,157,158,159
	db	065,073,079,085,165,165,166,167
	db	168,169,170,171,172,173,174,175
	db	176,177,178,179,180,181,182,183
	db	184,185,186,187,188,189,190,191
	db	192,193,194,195,196,197,198,199
	db	200,201,202,203,204,205,206,207
	db	208,209,210,211,212,213,214,215
	db	216,217,218,219,220,221,222,223
	db	224,225,226,227,228,229,230,231
	db	232,233,234,235,236,237,238,239
	db	240,241,242,243,244,245,246,247
	db	248,249,250,251,252,253,254,255
;
; file upper case table
; ---------------------------------------------------------------------------
FILE_UCASE_TAB:	; label  byte
	dw	128
	db	128,154,069,065,142,065,143,128
	db	069,069,069,073,073,073,142,143
	db	144,146,146,079,153,079,085,085
	db	089,153,154,155,156,157,158,159
	db	065,073,079,085,165,165,166,167
	db	168,169,170,171,172,173,174,175
	db	176,177,178,179,180,181,182,183
	db	184,185,186,187,188,189,190,191
	db	192,193,194,195,196,197,198,199
	db	200,201,202,203,204,205,206,207
	db	208,209,210,211,212,213,214,215
	db	216,217,218,219,220,221,222,223
	db	224,225,226,227,228,229,230,231
	db	232,233,234,235,236,237,238,239
	db	240,241,242,243,244,245,246,247
	db	248,249,250,251,252,253,254,255
;
; file char list
; ---------------------------------------------------------------------------
FILE_CHAR_TAB:	; label  byte
	dw	22				; length
	db	1,0,255 			; include all
	db	0,0,20h 			; exclude 0 - 20h
	db	2,14,'."/\[]:|<>+=;,'           ; exclude 14 special
	;db	24 dup (?)			; reserved
	times	24 db 0

;
; collate table
; ---------------------------------------------------------------------------
COLLATE_TAB:	; label   byte
	dw	256
	db	0,1,2,3,4,5,6,7
	db	8,9,10,11,12,13,14,15
	db	16,17,18,19,20,21,22,23
	db	24,25,26,27,28,29,30,31
	db	" ","!",'"',"#","$","%","&","'"
	db	"(",")","*","+",",","-",".","/"
	db	"0","1","2","3","4","5","6","7"
	db	"8","9",":",";","<","=",">","?"
	db	"@","A","B","C","D","E","F","G"
	db	"H","I","J","K","L","M","N","O"
	db	"P","Q","R","S","T","U","V","W"
	db	"X","Y","Z","[","\","]","^","_"
	db	"`","A","B","C","D","E","F","G"
	db	"H","I","J","K","L","M","N","O"
	db	"P","Q","R","S","T","U","V","W"
	db	"X","Y","Z","{","|","}","~",127
	db	"C","U","E","A","A","A","A","C"
	db	"E","E","E","I","I","I","A","A"
	db	"E","A","A","O","O","O","U","U"
	db	"Y","O","U","$","$","$","$","$"
	db	"A","I","O","U","N","N",166,167
	db	"?",169,170,171,172,"!",'"','"'
	db	176,177,178,179,180,181,182,183
	db	184,185,186,187,188,189,190,191
	db	192,193,194,195,196,197,198,199
	db	200,201,202,203,204,205,206,207
	db	208,209,210,211,212,213,214,215
	db	216,217,218,219,220,221,222,223
	db	224,"S"
	db	226,227,228,229,230,231
	db	232,233,234,235,236,237,238,239
	db	240,241,242,243,244,245,246,247
	db	248,249,250,251,252,253,254,255

; ------------------------------------------------<MSKK01>----------------------

; DOSDATA:0CE3h

; 29/04/2019

; dbcs is not supported in DOS 3.3
;		   DBCS_TAB	    CC_DBCS <>
;
; DBCS for DOS 4.00			   2/12/KK

DBCS_TAB:	; label byte		;AN000;  2/12/KK
; ------------------------------------------------<MSKK01>----------------------
;ifdef	DBCS
; ifdef	  JAPAN
;		dw	6		; <MSKK01>
;		db	081h,09fh	; <MSKK01>
;		db	0e0h,0fch	; <MSKK01>
;		db	0,0		; <MSKK01>
;
;		db	0,0,0,0,0,0,0,0,0,0	; <MSKK01>
; endif
; ifdef	  TAIWAN
;		dw	4		; <TAIWAN>
;		db	081h,0FEh	; <TAIWAN>
;		db	0,0		; <TAIWAN>
;
;		db	0,0,0,0,0,0,0,0,0,0,0,0
; endif
; ifdef   KOREA                         ; Keyl
;               dw      4               ; <KOREA>
;               db      0A1h,0FEh       ; <KOREA>
;               db      0,0             ; <KOREA>
;
;		db	0,0,0,0,0,0,0,0,0,0,0,0
;  endif
;else
		dw	0		;AN000;  2/12/KK      max number
		;db	16 dup(0)	;AN000;  2/12/KK
		times	16 db 0

;		dw	6		;  2/12/KK
;		db	081h,09Fh	;  2/12/KK
;		db	0E0h,0FCh	;  2/12/KK
;		db	0,0		;  2/12/KK
;
;endif
; ------------------------------------------------<MSKK01>----------------------

; DOSDATA:0CF5h

; ---------------------------------------------------------------------------
;
;CASE MAPPER ROUTINE FOR 80H-FFH character range, DOS 3.3
;     ENTRY: AL = Character to map
;     EXIT:  AL = The converted character
; Alters no registers except AL and flags.
; The routine should do nothing to chars below 80H.
; ---------------------------------------------------------------------------
; Example:

MAP_CASE:
;Procedure MAP_CASE,FAR

	CMP	AL,80h
	JAE	short Map1	;Map no chars below 80H ever
	RETF
Map1:
	SUB	AL,80h		;Turn into index value
	PUSH	DS
	PUSH	BX
	MOV	BX,UCASE_TAB+2
FINISH:
	PUSH	CS		;Move to DS
	POP	DS
	XLAT			;Get upper case character
	POP	BX
	POP	DS
L_RET:	
	RETF

;EndProc MAP_CASE

; ---------------------------------------------------------------------------

; The variables for ECS version are moved here for the same data alignments
; as IBM-DOS and MS-DOS.

InterChar:
	db	0	; Interim character flag ( 1= interim)  ;AN000;
;------- NOTE: NEXT TWO BYTES SOMETIMES USED AS A WORD !! -------------------
DUMMY:	; LABEL   WORD
InterCon:  
	db	0	; Console in Interim mode ( 1= interim) ;AN000;
SaveCurFlg:
	db	0	; Print, do not advance cursor flag     ;AN000;

; ---------------------------------------------------------------------------

TEMPSEG:  dw	0	;hkn; used to store ds.
redir_patch:
	  db	0

; DOSDATA:0D0Dh

Mark1:	; label byte

;IF2
;	IF ((OFFSET MARK1) GT (OFFSET MSVERSION) )
;		%OUT !DATA CORRUPTION!MARK1 OFFSET TOO BIG. RE-ORGANIZE DATA.
;	ENDIF
;ENDIF

	  times 5 db 0

;############################################################################
;
; ** HACK FOR DOS 4.0 REDIR **
; 
; The redir requires the following:
;
;	MSVERS	offset D12H
;	YRTAB	offset D14H
; 	MONTAB	offset D1CH
;
; WARNING! WARNING!
; 
; MARK1 SHOULD NOT BE >= 0D12H. IF SOME VARIABLE IS TO BE ADDED ABOVE DO SO
; WITHOUT VIOLATING THIS AND UPDATE THE FOLL. LINE
;
; CURRENTLY MARK1 = 0D0DH
;
;############################################################################

	;ORG	0D12h

; DOSDATA:0D12h (MSDOS 6.21, MSDOS.SYS)

	;db	6
	;db	20

	; Offset 0C78h in IBMDOS.COM (MSDOS 3.3, 1987)
MSVERSION:				; MS-DOS version in hex for $GET_VERSION
MSMAJORV: DB	MAJOR_VERSION	; DOS_MAJOR_VERSION
MSMINORV: DB	MINOR_VERSION	; DOS_MINOR_VERSION  

; YRTAB & MONTAB moved from TABLE segment in ms_table.asm
;
;	I_am    YRTAB,8,<200,166,200,165,200,165,200,165>   
;	I_am    MONTAB,12,<31,28,31,30,31,30,31,31,30,31,30,31> 

; Days in year

YRTAB:   
	DB	200,166			; Leap year
	DB	200,165
	DB	200,165
	DB	200,165

; Days of each month

MONTAB:        
	DB      31                      ; January
february:
	DB	28 			; February--reset each 
					; time year changes
        DB      31                      ; March
        DB      30                      ; April
        DB      31                      ; May
        DB      30                      ; June
        DB      31                      ; July
        DB      31                      ; August
        DB      30                      ; September
        DB      31                      ; October
        DB      30                      ; November
        DB      31                      ; December

;----------------THE FOLL. BLOCK MOVED FROM TABLE SEG IN MS_TABLE.ASM-------

; SYS init extended table,   DOS 3.3   F.C. 5/29/86

SysInitTable:
	;dw	SYSINITVAR
	dw	SYSINITVARS	; pointer to sysinit var
        dw      0		; segment
        dw	COUNTRY_CDPG	; pointer to country tabl
        dw      0		; segment of pointer

; DOS 3.3 F.C. 6/12/86
; FASTOPEN communications area DOS 3.3   F.C. 5/29/86

FastTable:				; a better name
FastOpenTable:
	dw      2                       ; number of entries
	dw      FastRet			; pointer to ret instr.
	dw      0                       ; and will be modified by
	dw      FastRet			; FASTxxx when loaded in
	dw      0                       

; DOS 3.3 F.C. 6/12/86

FastFlg:				; flags
FastOpenFlg:
	db	0			; don't change the foll: order  

; FastOpen_Ext_Info is used as a temporary storage for saving dirpos,dirsec
; and clusnum which are filled by DOS 3.nc when calling FastOpen Insert
; or filled by FastOPen when calling FastOpen Lookup

FastOpen_Ext_Info: ; label  byte	;dirpos
	;db	SIZE FASTOPEN_EXTENDED_INFO dup(0)
	;times	11 db 0
	times	FEI.size db 0

; Dir_Info_Buff is a dir entry buffer which is filled by FastOPen
; when calling FastOpen Lookup

Dir_Info_Buff:	; label  byte
	;db   	SIZE dir_entry dup (0)
	;times	32 db 0
	times	dir_entry.size db 0

Next_Element_Start:
	dw	0			; save next element start offset
Del_ExtCluster:
	dw	0			; for dos_delete                       

; The following is a stack and its pointer for interrupt 2F which is used
; by NLSFUNC. There is no significant use of this stack, we are just trying
; not to destroy the INT 21 stack saved for the user.

USER_SP_2F:	; LABEL  WORD
	dw    	FAKE_STACK_2F

Packet_Temp:	; label  word		; temporary packet used by readtime
DOS_TEMP:	; label  word		; temporary word
FAKE_STACK_2F:  
	; dw  14 dup (0)		; 12 register temporary storage
	times 14 dw 0

Hash_Temp: 	;label  word		; temporary word             
	;dw   4 dup (0)			; temporary hash table during config.sys
	times 4 dw 0
            	
SCAN_FLAG:	
	db     0			; flag to indicate key ALT_Q
DATE_FLAG:
	dw     0                	; flag to update the date

FETCHI_TAG:	; label  word		; OBSOLETE - no longer used
	dw     0			; formerly part of IBM's piracy protection

MSG_EXTERROR:	; label  DWORD   ; for system message addr                                                       
	dd     0               		; for extended error                   
	dd     0			; for parser                           
	dd     0			; for critical errror                  
	dd     0			; for IFS                              
	dd     0			; for code reduction                   

SEQ_SECTOR:	; label  DWORD 		; last sector read                                                     
	dd     -1                                                        
SC_SECTOR_SIZE:
	dw	0			; sector size for SC                 
SC_DRIVE:
	db	0			; drive # for secondary cache        
CurSC_DRIVE:
	db	-1			; current SC drive                   
CurSC_SECTOR:
	dd	0			; current SC starting sector         
SC_STATUS:
	dw	0			; SC status word                     
SC_FLAG:
	db	0			; SC flag                            
AbsDskErr:
	dw	0			; Storage for Abs dsk read/write err
                                                          
NO_NAME_ID:	; label byte                                                           
	db	'NO NAME    '		; null media id                      

;hkn; moved from TABLE segment in kstrin.asm

KISTR001S:	; label	byte		; 2/17/KK
LOOKSIZ: DB	0			; 0 if byte, NZ if word	2/17/KK
KISTR001E:	; label	byte		; 2/17/KK

; the nul device driver used to be part of the code. However, since the 
; header is in the data, and the entry points are only given as an offset,
; the strategy and interrupt entry points must also be in the data now.

; DOSDATA:0DC6h

SNULDEV:
;procedure snuldev,far
	;or	word [es:bx+3],100h
	; 17/12/2022
	;or	byte [es:bx+4],01h
	; 05/01/2024 (Original MSDOS and RetroDOS DATA address compatibility)
	;or	byte [es:bx+SRHEAD.REQSTAT+1],(STDON>>8)
	or	word [es:bx+SRHEAD.REQSTAT],STDON ; set done bit
INULDEV:
	retf				; must not be a return!
;endproc snuldev

;M044
; Second part of save area for saving last para of Windows memory

WinoldPatch2:
	;db	8 dup (?)	; M044
	times	8 db 0	
UmbSave2:
	;db	5 dup (?)	; M062
	times	5 db 0
UmbSaveFlag:
	db	0		; M062

; DOSDATA:0DDBh

Mark2:	; label byte

;IF2
;	IF ((OFFSET MARK2) GT (OFFSET ERR_TABLE_21) )
;		%OUT !DATA CORRUPTION!MARK2 OFFSET TOO BIG. RE-ORGANIZE DATA.
;	ENDIF
;ENDIF

;############################################################################
;
; ** HACK FOR DOS 4.0 REDIR **
; 
; The redir requires the following:
;
;	ERR_TABLE_21	offset DDBH
;	ERR_TABLE_24	offset E5BH
; 	ErrMap24	offset EABH
;
; WARNING! WARNING!
;
; MARK2 SHOULD NOT BE >= 0DDBH. IF SOME VARIABLE IS TO BE ADDED ABOVE DO SO
; WITHOUT VIOLATING THIS AND UPDATE THE FOLL. LINE
;
; CURRENTLY MARK2 = 0DD0H
;
;############################################################################

	;ORG	0DDBh

; DOSDATA:0DDBh (MSDOS 6.21, MSDOS.SYS)

; ---------------------------------------------------------------------------
;
; The following table defines CLASS ACTION and LOCUS info for the INT 21H
; errors. Each entry is 4 bytes long:
;
;       Err#,Class,Action,Locus
;
; A value of 0FFh indicates a call specific value (ie. should already
; be set). AN ERROR CODE NOT IN THE TABLE FALLS THROUGH TO THE CATCH ALL AT
; THE END, IT IS ASSUMES THAT CLASS, ACTION, LOCUS IS ALREADY SET.
;
; ---------------------------------------------------------------------------

;ErrTab  Macro   err,class,action,locus
;ifidn <locus>,<0FFh>
;    DB  error_&err,errCLASS_&class,errACT_&action,0FFh
;ELSE
;    DB  error_&err,errCLASS_&class,errACT_&action,errLOC_&locus
;ENDIF
;ENDM

ERR_TABLE_21: ; LABEL   BYTE
    DB  error_invalid_function,       errCLASS_Apperr,    errACT_Abort,    0FFh
    DB  error_file_not_found,         errCLASS_NotFnd,    errACT_User,     errLOC_Disk
    DB  error_path_not_found,         errCLASS_NotFnd,    errACT_User,     errLOC_Disk
    DB  error_too_many_open_files,    errCLASS_OutRes,    errACT_Abort,    errLOC_Unk
    DB  error_access_denied,          errCLASS_Auth,      errACT_User,     0FFh
    DB  error_invalid_handle,         errCLASS_Apperr,    errACT_Abort,    errLOC_Unk
    DB  error_arena_trashed,          errCLASS_Apperr,    errACT_Panic,    errLOC_Mem
    DB  error_not_enough_memory,      errCLASS_OutRes,    errACT_Abort,    errLOC_Mem
    DB  error_invalid_block,          errCLASS_Apperr,    errACT_Abort,    errLOC_Mem
    DB  error_bad_environment,        errCLASS_Apperr,    errACT_Abort,    errLOC_Mem
    DB  error_bad_format,             errCLASS_BadFmt,    errACT_User,     errLOC_Unk
    DB  error_invalid_access,         errCLASS_Apperr,    errACT_Abort,    errLOC_Unk
    DB  error_invalid_data,           errCLASS_BadFmt,    errACT_Abort,    errLOC_Unk
    DB  error_invalid_drive,          errCLASS_NotFnd,    errACT_User,     errLOC_Disk
    DB  error_current_directory,      errCLASS_Auth,      errACT_User,     errLOC_Disk
    DB  error_not_same_device,        errCLASS_Unk,       errACT_User,     errLOC_Disk
    DB  error_no_more_files,          errCLASS_NotFnd,    errACT_User,     errLOC_Disk
    DB  error_file_exists,            errCLASS_Already,   errACT_User,     errLOC_Disk
    DB  error_sharing_violation,      errCLASS_Locked,    errACT_DlyRet,   errLOC_Disk
    DB  error_lock_violation,         errCLASS_Locked,    errACT_DlyRet,   errLOC_Disk
    DB  error_out_of_structures,      errCLASS_OutRes,    errACT_Abort,    0FFh
    DB  error_invalid_password,       errCLASS_Auth,      errACT_User,     errLOC_Unk
    DB  error_cannot_make,            errCLASS_OutRes,    errACT_Abort,    errLOC_Disk
    DB  error_not_supported,          errCLASS_BadFmt,    errACT_User,     errLOC_Net
    DB  error_already_assigned,       errCLASS_Already,   errACT_User,     errLOC_Net
    DB  error_invalid_parameter,      errCLASS_BadFmt,    errACT_User,     errLOC_Unk
    DB  error_FAIL_I24,               errCLASS_Unk,       errACT_Abort,    errLOC_Unk
    DB  error_sharing_buffer_exceeded,errCLASS_OutRes,    errACT_Abort,    errLOC_Mem
    ; MSDOS 6.0
    DB  error_handle_EOF,             errCLASS_OutRes,    errACT_Abort,    errLOC_Unk ;AN000;
    DB  error_handle_Disk_Full,       errCLASS_OutRes,    errACT_Abort,    errLOC_Unk ;AN000;
    DB  error_sys_comp_not_loaded,    errCLASS_Unk,       errACT_Abort,    errLOC_Disk ;AN001;
    DB  0FFh,                         0FFH,       	  0FFH,       	   0FFh

; MSDOS 3.3 (IBMDOS.COM, 1987) - Offset 0D2Ah
;ERR_TABLE_21:	db 1,7,4,0FFh
;		db 2,8,3,2
;		db 3,8,3,2
;		db 4,1,4,1
;		db 5,3,3,0FFh
;		db 6,7,4,1
;		db 7,7,5,5
;		db 8,1,4,5
;		db 9,7,4,5
;		db 0Ah,7,4,5
;		db 0Bh,9,3,1
;		db 0Ch,7,4,1
;		db 0Dh,9,4,1
;		db 0Fh,8,3,2
;		db 10h,3,3,2
;		db 11h,0Dh,3,2
;		db 12h,8,3,2
;		db 50h,0Ch,3,2
;		db 20h,0Ah,2,2
;		db 21h,0Ah,2,2
;		db 54h,1,4,0FFh
;		db 56h,3,3,1
;		db 52h,1,4,2
;		db 32h,9,3,3
;		db 55h,0Ch,3,3
;		db 57h,9,3,1
;		db 53h,0Dh,4,1
;		db 24h,1,4,5
; MSDOS 6.0 (MSDOS 6.21)
;		db 26h,1,4,1
;		db 27h,1,4,1
;		db 5Ah,0Dh,4,2
; MSDOS 6.0 & MSDOS 3.3
;		db 0FFh,0FFh,0FFh,0FFh

; DOSDATA:0E5Bh (MSDOS 6.21, MSDOS.SYS)

; ---------------------------------------------------------------------------
;
; The following table defines CLASS ACTION and LOCUS info for the INT 24H
; errors. Each entry is 4 bytes long:
;
;       Err#,Class,Action,Locus
;
; A Locus value of 0FFh indicates a call specific value (ie. should already
; be set). AN ERROR CODE NOT IN THE TABLE FALLS THROUGH TO THE CATCH ALL AT
; THE END.
;
; ---------------------------------------------------------------------------

ERR_TABLE_24: ; LABEL   BYTE
    DB  error_write_protect,          errCLASS_Media,     errACT_IntRet,   errLOC_Disk
    DB  error_bad_unit,               errCLASS_Intrn,     errACT_Panic,    errLOC_Unk
    DB  error_not_ready,              errCLASS_HrdFail,   errACT_IntRet,   0FFh
    DB  error_bad_command,            errCLASS_Intrn,     errACT_Panic,    errLOC_Unk
    DB  error_CRC,                    errCLASS_Media,     errACT_Abort,    errLOC_Disk
    DB  error_bad_length,             errCLASS_Intrn,     errACT_Panic,    errLOC_Unk
    DB  error_seek,                   errCLASS_HrdFail,   errACT_Retry,    errLOC_Disk
    DB  error_not_DOS_disk,           errCLASS_Media,     errACT_IntRet,   errLOC_Disk
    DB  error_sector_not_found,       errCLASS_Media,     errACT_Abort,    errLOC_Disk
    DB  error_out_of_paper,           errCLASS_TempSit,   errACT_IntRet,   errLOC_SerDev
    DB  error_write_fault,            errCLASS_HrdFail,   errACT_Abort,    0FFh
    DB  error_read_fault,             errCLASS_HrdFail,   errACT_Abort,    0FFh
    DB  error_gen_failure,            errCLASS_Unk,       errACT_Abort,    0FFh
    DB  error_sharing_violation,      errCLASS_Locked,    errACT_DlyRet,   errLOC_Disk
    DB  error_lock_violation,         errCLASS_Locked,    errACT_DlyRet,   errLOC_Disk
    DB  error_wrong_disk,             errCLASS_Media,     errACT_IntRet,   errLOC_Disk
    DB  error_not_supported,          errCLASS_BadFmt,    errACT_User,     errLOC_Net
    DB  error_FCB_unavailable,        errCLASS_Apperr,    errACT_Abort,    errLOC_Unk
    DB  error_sharing_buffer_exceeded,errCLASS_OutRes,    errACT_Abort,    errLOC_Mem
    DB	0FFh,                         errCLASS_Unk,       errACT_Panic,    0FFh

; MSDOS 3.3 (IBMDOS.COM, 1987) - Offset 0D9Eh
;ERR_TABLE_24:	db 13h,0Bh,7,2
;		db 14h,4,5,1
;		db 15h,5,7,0FFh
;		db 16h,4,5,1
;		db 17h,0Bh,4,2
;		db 18h,4,5,1
;		db 19h,5,1,2
;		db 1Ah,0Bh,7,2
;		db 1Bh,0Bh,4,2
;		db 1Ch,2,7,4
;		db 1Dh,5,4,0FFh
;		db 1Eh,5,4,0FFh
;		db 1Fh,0Dh,4,0FFh
;		db 20h,0Ah,2,2
;		db 21h,0Ah,2,2
;		db 22h,0Bh,7,2
;		db 32h,9,3,3
;		db 23h,7,4,1
;		db 24h,1,4,5
;		db 0FFh,0Dh,5,0FFh

; DOSDATA:0EABh (MSDOS 6.21, MSDOS.SYS)

; ---------------------------------------------------------------------------
;
; We need to map old int 24 errors and device driver errors into the new set
; of errors. The following table is indexed by the new errors
;
; ---------------------------------------------------------------------------

;Public  ErrMap24
ErrMap24: ; Label   BYTE
    DB  error_write_protect	; 0
    DB  error_bad_unit		; 1
    DB  error_not_ready		; 2
    DB  error_bad_command	; 3
    DB  error_CRC		; 4
    DB  error_bad_length	; 5
    DB  error_seek		; 6
    DB  error_not_DOS_disk	; 7
    DB  error_sector_not_found	; 8
    DB  error_out_of_paper	; 9
    DB  error_write_fault	; A
    DB  error_read_fault	; B
    DB  error_gen_failure	; C
    DB  error_gen_failure	; D  RESERVED
    DB  error_gen_failure	; E  RESERVED
    DB  error_wrong_disk	; F

;ErrMap24: db 13h, 14h, 15h, 16h, 17h, 18h, 19h, 1Ah
;	   db 1Bh, 1Ch, 1Dh, 1Eh, 1Fh, 1Fh, 1Fh, 22h
	
ErrMap24End: ; LABEL   BYTE

; DOSDATA:0E5Bh (MSDOS 6.21, MSDOS.SYS)

; ---------------------------------------------------------------------------

; 27/04/2019 - Retro DOS v4.0

FIRST_BUFF_ADDR:
	dw	0			; first buffer address               
SPECIAL_VERSION:
	dw	0			;AN006; used by INT 2F 47H
FAKE_COUNT:
	times 255 db 0			;AN008; fake version count
OLD_FIRSTCLUS:
	dw	0			;AN011; save old first cluster for fastopen

; ---------------------------------------------------------------------------

;smr; moved from TABLE segment in exec.asm

exec_init_SP: dw 0
exec_init_SS: dw 0
exec_init_IP: dw 0
exec_init_CS: dw 0

exec_signature:
	dw	0	; must contain 4D5A (yay zibo!)
exec_len_mod_512:
	dw	0	; low 9 bits of length
exec_pages:
	dw	0	; number of 512b pages in file
exec_rle_count:
	dw	0	; count of reloc entries
exec_par_dir:
	dw	0	; number of paragraphs before image
exec_min_BSS:
	dw	0	; minimum number of para of BSS
exec_max_BSS:
	dw	0	; max number of para of BSS
exec_SS:
	dw	0	; stack of image
exec_SP:
	dw	0	; SP of image
exec_chksum:
	dw	0	; checksum of file (ignored)
exec_IP:
	dw	0	; IP of entry
exec_CS:
	dw	0	; CS of entry
exec_rle_table:
	dw	0	; byte offset of reloc table

exec_header_len	equ $-exec_signature			;PBUGBUG

;smr; eom

; ---------------------------------------------------------------------------

;SR;
; WIN386 instance table for DOS

Win386_Info:
	db	3, 0
	dd	0, 0, 0
	dw	Instance_Table, 0

Instance_Table:
	dw	CONTPOS, 0, 2
	dw	BCON, 0, 4
	dw	CARPOS, 0, 106h
	dw	CHARCO, 0, 1
	dw	exec_init_SP, 0, 34	; M074
	dw	UMBFLAG,0,1		; M019
	dw	UMB_HEAD,0,2		; M019
	dw	0, 0

; M001; SR;
; M001; On DOSMGR call ( cx == 0 ), we need to return a table of offsets of 
; M001; some DOS variables. Note that the only really important variable in 
; M001; this is User_Id. The other variables are needed only to patch stuff 
; M001; which does not need to be done in DOS 5.0. 

; 29/12/2022
; (MSDOS 6.21 MSDOS.SYS DOSDATA:1022h)

Win386_DOSVars:
	db	5	;Major version 5 ; M001
	db	0	;Minor version 0 ; M001
	dw	SAVEDS	; M001
	dw	SAVEBX	; M001
	dw	INDOS	; M001
	dw	USER_ID	; M001
	dw	CritPatch ; M001
	dw	UMB_HEAD ; M012

;SR;
; Flag to indicate whether WIN386 is running or not

IsWin386: db	0

;M018
; This variable contains the path to the VxD device needed for Win386

VxDpath:  db	'c:\wina20.386',0	;M018

;End WIN386 support

; ---------------------------------------------------------------------------

;SR;
; These variables have been added for the special lie support for device
;drivers.
;

DriverLoad:	
	db	1	;initialized to do special handling
BiosDataPtr:
	dd	0

; 29/12/2022 - Retro DOS v4.1
%if 0

; 27/04/2019 - Retro DOS v4.0
; 04/11/2022
; DOSDATA:1044h (MSDOS 6.21 & MSDOS 5.0, MSDOS.SYS)

;------------------------------------------------------------------------
; Patch for Sidekick
;
; A documented method for finding the offset of the Errormode flag in the 
; dos swappable data area if for the app to scan in the dos segment (data) 
; for the following sequence of instructions.
;
; Ref: Part C, Article 11, pg 356 of MSDOS Encyclopedia
;
; The Offset of Errormode flag is 0320h
;
;------------------------------------------------------------------------

	db	036h, 0F6h, 06h, 020h, 03h, 0FFh ; test ss:[errormode], -1
	db	075h, 0Ch			 ; jnz  NearLabel
	db	036h, 0FFh, 036h, 058h, 03h	 ; push ss:[NearWord]
	db	0CDh, 028h			 ; int  28h

;--------------------------------------------------------------------------
; Patch for PortOfEntry - M036
;
; PortOfEntry by Sector Technology uses an un documented way of determining
; the offset of Errormode flag. The following patch is to support them in 
; DOS 5.0. The corresponding code is actually in msdisp.asm
;
;---------------------------------------------------------------------------

	db 	080h, 03Eh, 020h, 03h, 00h 	 ; cmp 	[errormode], 0
	db	075h, 037h			 ; jnz	NearLabel
	db 	0BCh, 0A0h, 0Ah		  	 ; mov	sp, dosdata:iostack

%endif ; 29/12/2022

; DOSDATA:105Dh (MSDOS 6.21, MSDOS.SYS)

;--------------------------------------------------------------------------

;*** New FCB Implementation
; This variable is used as a cache in the new FCB implementation to remember
;the address of a local SFT that can be recycled for a regenerate operation

LocalSFT: dd	0		; 0 to indicate invalid pointer

;DOSDATA ENDS

;============================================================================
; LMSTUB.ASM (MSDOS 6.0, 1991)
;============================================================================
; 27/04/2019 - Retro DOS 4.0

;DOSDATA  SEGMENT WORD PUBLIC 'DATA'

;---------------------------------------------------------------------------
;	Low Memory Stub for DOS when DOS runs in HMA
;----------------------------------------------------------------------------
	
	;db	90h

	;EVEN
align 2

; DOSDATA:1062h (MSDOS 6.21, MSDOS.SYS)

DOSINTTABLE:	; LABEL	DWORD

	;DW	OFFSET DOSCODE:DIVOV 		, 0
	;DW	OFFSET DOSCODE:QUIT 		, 0
	;DW	OFFSET DOSCODE:COMMAND		, 0
	;DW	OFFSET DOSCODE:ABSDRD		, 0
	;DW	OFFSET DOSCODE:ABSDWRT		, 0
	;DW	OFFSET DOSCODE:Stay_resident	, 0
	;DW	OFFSET DOSCODE:INT2F		, 0
	;DW	OFFSET DOSCODE:CALL_ENTRY	, 0
	;DW	OFFSET DOSCODE:IRETT		, 0
	
	dw	DIVOV 		, 0  ; DOSINTTABLE+0
	dw	QUIT 		, 0  ; DOSINTTABLE+4	
	dw	COMMAND		, 0  ; DOSINTTABLE+8
	dw	ABSDRD		, 0  ; DOSINTTABLE+12
	dw	ABSDWRT		, 0  ; DOSINTTABLE+16
	dw	STAY_RESIDENT	, 0  ; DOSINTTABLE+20
	dw	INT2F		, 0  ; DOSINTTABLE+24
	dw	CALL_ENTRY	, 0  ; DOSINTTABLE+28
	dw	IRETT		, 0  ; DOSINTTABLE+32

SS_Save: dw	0		; save user's stack segment
SP_Save: dw	0		; save user's stack offset

;-------------------------------------------------------------------------
;
; LOW MEM STUB:
;
; The low mem stub contains the entry points into DOS for all interrupts 
; handled by DOS. This stub is installed if the user specifies that the 
; DOS load in HIMEM. Each entry point does this.
;
; 	1. if jmp to 8 has been patched out
;	   2. if A20 OFF
;	      3. Enable A20
;	   4. else 
;	      5. just go to dos entry
;	   6. endif
;	7. else
;	   8. just go to dos entry
;	9. endif
;
;--------------------------------------------------------------------------

; 27/04/2019 - Retro DOS v4.0

; DOSDATA:108Ah (MSDOS 6.21, MSDOS.SYS)

;--------------------------------------------------------------------------
;
; DIVIDE BY 0 handler
;
;--------------------------------------------------------------------------

ldivov:
	; The following jump, skipping the XMS calls will be patched to 
	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is 
	; needed because the stub is installed even before the XMS driver
	; is loaded if the user specifies dos=high in the config.sys
i0patch:
	jmp	short divov_cont	

	call	EnsureA20ON		; we must turn on A20 if OFF	
divov_cont:
	jmp	far [cs:DOSINTTABLE]	; jmp to DOS

;------------------------------------------------------------------------
;
; INT 20 Handler
;
; Here we do not have to set up the stack to return here as the abort call
; will return to the address after the int 21 ah=4b call. This would be the
; common exit point if A20 had been OFF (for TOGGLE DOS) and the A20 line
; will be restored then.
;
;-------------------------------------------------------------------------

lquit:
	; The following jump, skipping the XMS calls will be patched to 
	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is 
	; needed because the stub is installed even before the XMS driver
	; is loaded if the user specifies dos=high in the config.sys
i20patch:
	jmp	short quit_cont	

	call	EnsureA20ON		; we must turn on A20 if OFF	
quit_cont:
	jmp	far [cs:DOSINTTABLE+4]	; jump to DOS

;--------------------------------------------------------------------------
;
; INT 21 Handler
;
;--------------------------------------------------------------------------

lcommand:
	; The following jump, skipping the XMS calls will be patched to 
	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is 
	; needed because the stub is installed even before the XMS driver
	; is loaded if the user specifies dos=high in the config.sys
i21patch:
	jmp	short command_cont	

	call	EnsureA20ON		; we must turn on A20 if OFF	
command_cont:
	jmp	far [cs:DOSINTTABLE+8]	; jmp to DOS

;------------------------------------------------------------------------
;
; INT 25 
;
;----------------------------------------------------------------------------

labsdrd:
	; The following jump, skipping the XMS calls will be patched to 
	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is 
	; needed because the stub is installed even before the XMS driver
	; is loaded if the user specifies dos=high in the config.sys
i25patch:
	jmp	short absdrd_cont	

	call	EnsureA20ON		; we must turn on A20 if OFF	
absdrd_cont:
	jmp	far [cs:DOSINTTABLE+12]	; jmp to DOS

;-------------------------------------------------------------------------
;
; INT 26
;
;-----------------------------------------------------------------------

labsdwrt:
	; The following jump, skipping the XMS calls will be patched to 
	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is 
	; needed because the stub is installed even before the XMS driver
	; is loaded if the user specifies dos=high in the config.sys
i26patch:
	jmp	short absdwrt_cont	

	call	EnsureA20ON		; we must turn on A20 if OFF	
absdwrt_cont:
	jmp	far [cs:DOSINTTABLE+16]	; jmp to DOS

;------------------------------------------------------------------------
;
; INT 27
;
;-----------------------------------------------------------------------

lstay_resident:
	; The following jump, skipping the XMS calls will be patched to 
	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is 
	; needed because the stub is installed even before the XMS driver
	; is loaded if the user specifies dos=high in the config.sys
i27patch:
	jmp	short sr_cont	

	call	EnsureA20ON		; we must turn on A20 if OFF	
sr_cont:
	jmp	far [cs:DOSINTTABLE+20]	; jmp to DOS

;-----------------------------------------------------------------------------
;
; INT 2f
;
;-------------------------------------------------------------------------

lint2f:
	; The following jump, skipping the XMS calls will be patched to 
	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is 
	; needed because the stub is installed even before the XMS driver
	; is loaded if the user specifies dos=high in the config.sys
i2fpatch:
	jmp	short int2f_cont	

	call	EnsureA20ON		; we must turn on A20 if OFF	
int2f_cont:
	jmp	far [cs:DOSINTTABLE+24]	; jmp to DOS

;-----------------------------------------------------------------------------
;
; CPM entry
;
;------------------------------------------------------------------------

lcall_entry:
	; The following jump, skipping the XMS calls will be patched to 
	; NOPS by SEG_REINIT if DOS successfully loads high. This jump is 
	; needed because the stub is installed even before the XMS driver
	; is loaded if the user specifies dos=high in the config.sys
cpmpatch:
	jmp	short callentry_cont	

	call	EnsureA20ON		; we must turn on A20 if OFF	
callentry_cont:
	jmp	far [cs:DOSINTTABLE+28]	; jmp to DOS

;--------------------------------------------------------------------------

lirett:
	iret

;---------------------------------------------------------------------------
;
; LowIntXX:
;
; Interrupts from DOS that pass control to a user program must be done from
; low memory, as the user program may change the state of the A20 line or
; they may require that the A20 line be OFF. The following piece of code is
; far call'd from the following places in DOS:
;
;	1. msctrlc.asm where dos issues an int 23h (ctrlc)
;	2. msctrlc.asm where dos issues an int 24h (critical error)
;	3. msctrlc.asm where dos issues an int 28h (idle int)
;
; The int 23 and int 24 handlers may decide to do a far return instead of an
; IRET ane leave the flags on the stack. Therefore we save the return address
; before doing the ints and then do a far junp back into DOS.
;
;---------------------------------------------------------------------------

DosRetAddr23:	dd	0
DosRetAddr24:	dd	0
DosRetAddr28:	dd	0

	; Execute int 23h from low memory
LowInt23:
					; save the return address that is on
					; the stack
	pop	word [cs:DosRetAddr23]
	pop	word [cs:DosRetAddr23+2]

	int	23h			; ctrl C
					; turn on A20 it has been turned OFF
					; by int 28/23/24 handler.

	call	EnsureA20ON		; M011: we must turn on A20 if OFF 

	jmp	far [cs:DosRetAddr23]	; jump back to DOS


	; Execute int 24h from low memory
LowInt24:
					; save the return address that is on
					; the stack
	pop	word [cs:DosRetAddr24]
	pop	word [cs:DosRetAddr24+2]

	int	24h			; crit error
					; turn on A20 it has been turned OFF
					; by int 28/23/24 handler.

	call	EnsureA20ON		; M011: we must turn on A20 if OFF	

	jmp	far [cs:DosRetAddr24]	; jump back to DOS


 
	; Execute int 28h from low memory
LowInt28:
	int	28h			; idle int
					; turn on A20 it has been turned OFF
					; by int 28/23/24 handler.

	call	EnsureA20ON		; M011: we must turn on A20 if OFF	

	retf

; DOSDATA:1115h (MSDOS 6.21, MSDOS.SYS)

;-------------------------------------------------------------------------
;
; int 21 ah=4b (exec) call will jump to the following label before xferring
; control to the exec'd program. We turn off A20 inorder to allow programs
; that have been packed by the faulty exepack utility to unpack correctly.
; This is so because exepac'd programs rely on address wrap.
;
;------------------------------------------------------------------------- 

disa20_xfer:
	call	XMMDisableA20		; disable A20

	; Look at msproc.asm at label exec_go for understanding the following:

	; DS:SI points to entry point
	; AX:DI points to initial stack
	; DX has PDB pointer
	; BX has initial AX value

	cli
	mov	byte [cs:INDOS],0	; SS Override

	mov	SS,AX			; set up user's stack
	mov	SP,DI			; and SP
	sti

	push	DS			; fake long call to entry
	push	SI
	mov	ES,DX			; set up proper seg registers
	mov	DS,DX
	mov	AX,BX			; set up proper AX
	retf

;-------------------------------------------------------------------------
;
; M003:
;
; If an int 21 ah=25 call is made immediately after an exec call, DOS will
; come here, turn A20 OFF restore user stack and registers before returning 
; to user. This is done in dos\msdisp.asm. This has been done to support 
; programs compiled with MS PASCAL 3.2. See under TAG M003 in DOSSYM.INC for 
; more info.	
;
; Also at this point DS is DOSDATA. So we can assume DS DOSDATA. Note that 
; SS is also DOS stack. It is important that we do the XMS call on DOS's 
; stack to avoid additional stack overhead for the user.
;
; -------------------------------------------------------------------------

disa20_iret:
	call	XMMDisableA20
	dec	byte [INDOS]
	mov	SS,[USER_SS]		; restore user stack
	mov	SP,[USER_SP]
	mov	BP,SP
	;mov	[BP+user_env.user_AX],AL
	mov	[bp],al
	mov	AX,[NSP]
	mov	[USER_SP],AX
	mov	AX,[NSS]
	mov	[USER_SS],AX

	pop	AX			; restore user regs
	pop	BX
	pop	CX
	pop	DX
	pop	SI
	pop	DI
	pop	BP
	pop	DS
	pop	ES
	iret

;**************************************************************************
;***	XMMDisableA20 - switch 20th address line			      
;									      
;	This routine is used to disable the 20th address line in 	      
;	the system using XMM calls.					      
;									      
;	ENTRY	none		;ds = _DATA				      
;	EXIT	A20 line disabled					      
;	USES	NOTHING					      
;									      
;**************************************************************************

XMMDisableA20:
	push	bx
	push	ax
	;mov	ah,XMM_LOCAL_DISABLE_A20
	mov	ah,6
	call	far [cs:XMMcontrol]
	pop	ax
	pop	bx
	retn

; The entry point in the BIOS XMS driver is defined here.

XMMcontrol:
	dd	0

;--------------------------------------------------------------------------
;
;***	EnsureA20ON - Ensures that A20 is ON
;									      
;	This routine is used to query the A20 state in		 	      
;	the system using XMM calls.					      
;									      
;	ENTRY: none		
;
;	EXIT : A20 will be ON
;		
; 	USES : NONE								      
;									      
;--------------------------------------------------------------------------

; 19/09/2023
;LowMemory:	; label dword		; Set equal to 0000:0080
;	dw	00080h
;	dw	00000h
;
;HighMemory:	; label dword
;	dw	00090h			; Set equal to FFFF:0090
;	dw	0FFFFh

EnsureA20ON:
	pushf
	push    ds
	push	es
	push	cx
	push	si
	push	di

	; 19/09/2023
	;lds	si,[cs:LowMemory]	; Compare the 4 words at 0000:0080
	;les	di,[cs:HighMemory]	; with the 4 at FFFF:0090

	xor	di,di
	mov	es,di
	dec	di
	mov	si,90h	; 0FFFFh:0090h	; HighMemory
	mov	ds,di
	mov	di,80h ; 0000h:0080h	; LowMemory
	
	mov	cx,4
	cld
	repe    cmpsw

	jz	short EA20_OFF
EA20_RET:
	pop	di
	pop	si
	pop	cx
	pop	es
	pop	ds
	popf
	retn

EA20_OFF:
	; We are going to do the XMS call on the DOS's AuxStack.
	; NOTE: ints are disabled at this point.

	push	bx
	push	ax

	mov	ax,ss			; save user's stack pointer
	mov	[cs:SS_Save],ax
	mov	[cs:SP_Save],sp
	mov	ax,cs
	mov	ss,ax
	mov	sp,AUXSTACK
					; ss:sp -> DOSDATA:AuxStack
	;mov	ah,XMM_LOCAL_ENABLE_A20
	mov	ah,5
	call	far [cs:XMMcontrol]
	or	ax,ax
	jz	short XMMerror		; AX = 0 fatal error

	mov	ax,[cs:SS_Save]		; restore user stack
	mov	ss,ax
	mov	sp,[cs:SP_Save]

	pop	ax
	pop	bx

	jmp	short EA20_RET

XMMerror:				; M006 - Start
	mov	ah,0Fh			; get video mode
	int	10h
	cmp	al,7			; Q: are we an MDA
	je	short XMMcont			; Y: do not change mode
	xor	ah,ah ; 0			; set video mode
	mov	al,02h			; 80 X 25 text
	int	10h
XMMcont:
	mov	ah,05h			; set display page
	xor	al,al			; page 0
	int	10h
	
	mov	si,XMMERRMSG
	push	cs
	pop	ds
	cld				; clear direction flag
XMMprnt:
	lodsb
	cmp	al,'$'			; indicates end of XMMERRMSG
	jz	short XMMStall		; function 0Eh	
	mov	ah,0Eh
	mov	bx,7
	int	10h
	jmp	short XMMprnt

XMMStall:
	sti				; allow the user to warm boot
	jmp	short XMMStall		; M006 - End

;---------------------------------------------------------------------------

; 27/04/2019 - Retro DOS v4.0

; retrodos4.s ; offset 0Ch in BIOS segment (0070h)
ALTAH	equ 0Ch

;This has been put in for WIN386 2.XX support. The format of the instance 
;table was different for this. Segments will be patched in at init time.

OldInstanceJunk:
	dw	70h	;segment of BIOS
	dw	0	;indicate stacks in SYSINIT area
	dw	6	;5 instance items

	;dw	0,offset dosdata:contpos, 2
	;dw	0,offset dosdata:bcon, 4
	;dw	0,offset dosdata:carpos,106h
	;dw	0,offset dosdata:charco, 1
	;dw	0,offset dosdata:exec_init_sp, 34               ;M032
	;dw	070h,offset BData:altah, 1	 ; altah byte in bios

	dw	0,CONTPOS,2
	dw	0,BCON,4
	dw	0,CARPOS,106h
	dw	0,CHARCO,1
	dw	0,exec_init_SP,34
	dw	70h,ALTAH,1	; altah byte in bios

;---------------------------------------------------------------------------

; M021-
;
; DosHasHMA - This flag is set by seg_reinit when the DOS actually
; 	takes control of the HMA. When running, this word is a reliable
;	indicator that the DOS is actually using HMA. You can't just use
;	CS, because ROMDOS uses HMA with CS < F000.

DosHasHMA:
	db	0
FixExePatch:
	dw	0		; M012

; 28/12/2022 - Retro DOS v4.1
;RationalPatchPtr:
;	dw	0		; M012

; End M021

;---------------------------------------------------------------------------

; 28/12/2022 - Retro DOS v4.1
%if 0

; M020 Begin

RatBugCode:	; proc	far
	push	cx
	mov	cx,[10h]
rbc_loop:
	;loop	$
	loop	rbc_loop
	pop	cx
	retf
		
; M020 End

%endif

;---------------------------------------------------------------------------
	
UmbSave1:
	;db	11 dup (?)	; M023
	times	11 db 0	

; DOSDATA:122Ah

Mark3:	; label byte

;IF2
;	IF ((OFFSET MARK3) GT (OFFSET COUNTRY_CDPG) )
;		%OUT !DATA CORRUPTION!MARK3 OFFSET TOO BIG. RE-ORGANIZE DATA.
;	ENDIF
;ENDIF

;############################################################################
;
; ** HACK FOR DOS 4.0 REDIR **
;
; The dos 4.X redir requires that country_cdpg is at offset 0122ah. Any new
; data variable that is to be added to DOSDATA must go in between Mark3
; COUNTRY_CDPG if it can. 
;
; MARK3 SHOULD NOT BE > 122AH 
;
; As of 9/6/90, this area is FULL!
;
;############################################################################
 
	;ORG	0122Ah

; DOSDATA:122Ah (MSDOS 6.21, MSDOS.SYS)

; The following table is used for DOS 3.3
;DOS country and code page information is defined here for DOS 3.3.
;The initial value for ccDosCountry is 1 (USA).
;The initial value for ccDosCodepage is 850.

; country and code page information
; ---------------------------------------------------------------------------
COUNTRY_CDPG:	; label  byte
	db   0,0,0,0,0,0,0,0		; reserved words
	db   '\COUNTRY.SYS',0		; path name of country.sys
	;db   51 dup (?)
	times 51 db 0
; ------------------------------------------------<MSKK01>-------------------
;ifdef	DBCS
;  ifdef JAPAN
;	dw   932			; system code page id (JAPAN)
;  endif
;  ifdef TAIWAN
;	dw   938			; system code page id (TAIWAN)
;  endif
;  ifdef KOREA
;	dw   934			; system code page id (KOREA IBM)
;  endif
;else
	dw   437			; system code page id
;endif
; ------------------------------------------------<MSKK01>-------------------
	dw   6				; number of entries
	db   SetUcase  ; 2		; Ucase type
	dw   UCASE_TAB			;pointer to upper case table
	dw   0				; segment of poiter
	db   SetUcaseFile  ; 4		; Ucase file char type
	dw   FILE_UCASE_TAB 		;pointer to file upper case table
	dw   0				; segment of poiter
	db   SetFileList ; 5		; valid file chars type
	dw   FILE_CHAR_TAB 		;pointer to valid file char tab
	dw   0				; segment of poiter
	db   SetCollate	; 6		; collate type
	dw   COLLATE_TAB		;pointer to collate table
	dw   0				; segment of poiter
	db   SetDBCS	; 7		;AN000; DBCS Ev			2/12/KK
	dw   DBCS_TAB			;AN000;pointer to DBCS Ev table	2/12/KK
	dw   0				;AN000; segment of pointer	2/12/KK
	db   SetCountryInfo  ; 1	; country info type
	dw   NEW_COUNTRY_SIZE		; extended country info size
; ------------------------------------------------<MSKK01>-------------------
;ifdef	DBCS
;	...... 
;else
	dw   1				; USA country id
	dw   437			; USA system code page id
	dw   0 				; date format
	db   '$',0,0,0,0		; currency symbol
	db   ',',0			; thousand separator
	db   '.',0			; decimal separator
	db   '-',0			; date separator
	db   ':',0			; time separator
	db   0				; currency format flag
	db   2				; # of digits in currency
	db   0 				; time format
	dw   MAP_CASE			; mono case routine entry point
	dw   0				; segment of entry point
	db   ',',0			; data list separator
	dw   0,0,0,0,0			; reserved
;endif
; ------------------------------------------------<MSKK01>-------------------

; 27/04/2019 - Retro DOS v4.0

;include msdos.cl2			; XMMERRMSG

; DOSDATA:12B8h (MSDOS 6.22, MSDOS.SYS) ; 17/01/2024

XMMERRMSG:
	db	0Dh,0Ah
	db	'A20 Hardware Error',0Dh,0Ah,'$'

; DOSDATA ends

; 05/11/2022
;----------------------------------------------------------------------------
; End of MSDOS 5.0 MSDOS.SYS /// Retro DOS v4.0 (2022) - 05/11/2022
;----------------------------------------------------------------------------

; 28/12/2022 - Retro DOS v4.1
; (windows 3.1 and Rational Extender patches are removed/disabled)
; (Windows 3.1 does not use the patches below if DOS version is MSDOS 5.0)
;----------------------------------------------------------------------------
%if 0

;----------------------------------------------------------------------------
; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)

;============================================================================
; WPATCH.INC (MSDOS 6.0, 1991)  ;;; Windows 3.1 patches ;;;
;============================================================================
; 27/04/2019 - Retro DOS 4.0

;DOSDATA Segment

; DOSDATA:12CFh (MSDOS 6.21, MSDOS.SYS)

; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSDATA:12CFh (MSDOS 5.0, MSDOS.SYS)

; first and second DOS patches
;	Non-console device read/write (system calls 3Fh and 40h)
;
; Code in disk.asm, 2 locations, one for read, one for write
;	DVRDLP:
;	DVWRTLP:
;
;
; 036h	lds	si,SS:[????]				  ; ThisSFT
;	lds	si,si+7 				  ; sf_devptr
; 0E8h	call	????		<- "simulate" int28 event ; DSKSTATCHK

DOSP1_ID:	db	036h,0C5h,036h
DOSP1_THISSFT:	db	036h,005h,0C5h,074h,007h,0E8h
DOSP1_ID_LEN	equ	$-DOSP1_ID

		db	90h, 90h

DOSP12_ID:	db	036h,0C5h,036h
DOSP12_THISSFT:	db	036h,005h,0C5h,074h,007h,0E8h
DOSP12_ID_LEN	equ	$-DOSP1_ID

; DOSDATA:12E3h

; Third/Fourth DOS patch - System call 3Fh (Read) from console
;
; Code in disk.asm, 1 location
;	GETBUF:
;
; 051h	push	cx	<- begin special int28 mode
;	push	es
;	push	di
;	mov	dx,???? ; offset dosgroup:CONBUF
;	call	????	; $STD_CON_STRING_INPUT
;	pop	di
;	pop	es
; 059h	pop	cx	<- end special int28 mode

DOSP3_ID:	db	051h,006h,057h,0BAh
DOSP3_CONBUF:	db	029h,002h,0E8h
DOSP3_ID_LEN	equ	$-DOSP3_ID
		db	09Ah,0E3h,05Fh,007h	; ???? , pop di, pop es
DOSP4_ID:	db	059h			; pop cx
DOSP4_ID_OFF	equ	(DOSP4_ID - DOSP3_ID)
	
; DOSDATA:12EFh

; Fifth DOS patch - System call 40h (Write) to console
;
; Code in disk.asm, 1 location
;
;		push	cx
;      WRCONLP: lodsb
;		cmp	al,1Ah
;		jz	????
;		call	????	<- "simulate" int28 event
;		loop	WRCONLP
;      CONEOF:	pop	ax

DOSP5_ID:	db	051h			; push cx
		db	0ACh,03Ch,01Ah,074h,005h
		db	0E8h			; call
DOSP5_ID_LEN	equ	$-DOSP5_ID

; DOSDATA:12F6h

; Seventh DOS patch - System call entry, patch USER_ID with VMid for share
;
; Code in disp.asm, 1 location
;
;
;	mov [SaveDS],ds
;	mov [SaveBX],bx
;	mov bx,cs
;	mov ds,bx
;	inc [indos]
;	xor ax,ax
;	mov [USER_ID],AX	<- Patch to set USER_ID to VMID

DOSP7_ID:	db	02Eh,08Ch,01Eh
DOSP7_SAVEDS:	db	07Eh,05h		; mov [SaveDS],ds
		db	02Eh,089h,01Eh
DOSP7_SAVEBX:	db	07Ch,05h		; mov [SaveBX],bx
		db	08Ch,0CBh		; mov bx,cs
		db	08Eh,0DBh		; mov ds,bx
		db	0FEh,006h
DOSP7_INDOS:	db	0CFh,002h		; inc [indos]
		db	033h,0C0h		; xor ax,ax
DOSP7_ID_LEN	equ	$-DOSP7_ID

; DOSDATA:130Ah

; Eighth DOS patch - OWNER check in handle calls. For share, need to NOP test
;
; Code in handle.asm, 1 location in routine CheckOwner
;
;
;
;	push	ax
;	mov	ax,ss:[USER_ID]     <- patch to XOR AX,AX to set zero
;	cmp	ax,es:[di.sf_UID]   <- NOP
;	pop	ax
;	jz	????

DOSP8_ID:	db	050h			; push ax
		db	036h,0A1h
DOSP8_USER_ID:	db	0EAh,002h		; mov  ax,ss:[USER_ID]
		db	026h,03Bh,045h		; cmp  ax,es:[di+2F]
DOSP8_ID_LEN	equ	$-DOSP8_ID
		db	02Fh,058h		; pop  ax

; DOSDATA:1314h

; 10th, 11th, 12th DOS patch - System call 3Fh (Read) in raw mode
;
;   Take RAW read to STDIN SFT and turn it into a polling loop doing
;   a yeild when a character is not ready to be read.
;
; Code in disk.asm, 3 locations
;
;   DVRDRAW:
;	    PUSH    ES
;	    POP     DS
;   ReadRawRetry:				<- Patch 10
;	    MOV     BX,DI
;	    XOR     AX,AX			<- Reenter #2
;	    MOV     DX,AX
;	    call    SETREAD
;	    PUSH    DS				<- Reenter #1
;	    LDS     SI,[THISSFT]
;	    call    DEVIOCALL
;	    MOV     DX,DI
;	    MOV     AH,86H
;	    MOV     DI,[DEVCALL.REQSTAT]
;	    TEST    DI,STERR
;	    JZ	    CRDROK
;	    call    CHARHARD
;	    MOV     DI,DX
;	    OR	    AL,AL
;	    JZ	    CRDROK
;	    CMP     AL,3
;	    JZ	    CRDFERR
;	    POP     DS
;	    JMP     ReadRawRetry
;
;   CRDFERR:
;	    POP     DI				<- Patch 11
;   DEVIOFERR:
;	    LES     DI,[THISSFT]
;	    jmp     SET_ACC_ERR_DS
;
;   CRDROK:
;	    POP     DI				<- Patch 12
;	    MOV     DI,DX
;	    ADD     DI,[CALLSCNT]
;	    JMP     SHORT ENDRDDEVJ3

DOSP10_ID:		db	006H,01FH
DOSP10_LOC_OFFSET	equ	$-DOSP10_ID
DOSP10_LOC:		db	08BH,0DFH
DOSP10_REENT2_OFFSET	equ	$-DOSP10_LOC
			db	033H,0C0H,08BH,0D0H,0E8H
DOSP10_ID_LEN		equ	$-DOSP10_ID
			db	0DFH,00EH
DOSP10_REENT1_OFFSET	equ	$-DOSP10_LOC
			db	01EH,036H,0C5H,036H,036H,005H,0E8H,0AFH,00EH
			db	08BH,0D7H,0B4H,086H,036H,08BH,03EH
DOSP10_PACKVAL_OFFSET	equ	$-DOSP10_ID
			db	009H,003H
			db	0F7H,0C7H,000H,080H,074H,019H,0E8H,047H,017H
			db	08BH,0FAH,00AH,0C0H,074H,010H,03CH,003H,074H,003H
			db	01FH,0EBH,0CFH
DOSP11_LOC_OFFSET	equ	$-DOSP10_ID
			db	05FH
DOSP11_REENT_OFFSET	equ	$-DOSP10_LOC
			db	036H,0C4H,03EH,036H,005H,0E9H,0A1H,004H

DOSP12_LOC_OFFSET	equ	$-DOSP10_ID
			db	05FH,08BH,0FAH
; DOSDATA:1353h

; 13th DOS patch - Actually a SYSINIT patch. Patches the stack fault code
;		which prints the fatal stack fault error on DOS >= 3.20.
;
;	    Sets focus to current VM so user can see fatal message.
;
;
;	l0: lodsb		<- Setfocus here
;	    cmp al, '$'
;	    je l1
;	    mov bl, 7
;	    mov ah, 0Eh
;	    int 10h
;	    jmp l0
;	l1: jmp $

DOSP13_ID:	db	0ACh			; l0: lodsb
		db	03Ch,024h		;     cmp al, '$'
		db	074h,008h		;     je l1
		db	0B3h,007h		;     mov bl, 7
		db	0B4h,00Eh		;     mov ah, 0Eh
		db	0CDh,010h		;     int 10h
		db	0EBh,0F3h		;     jmp l0
		db	0EBh,0FEh		; l1: jmp $
DOSP13_ID_LEN	equ	$-DOSP13_ID

; 05/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
; DOSDATA:1362h (MSDOS 5.0 MSDOS.SYS)

; 06/12/2022
;DOSDATASIZE	equ  $ - DOSDATASTART ; 4962 bytes (1362h)

; DOSDATA ends

;============================================================================
; MPATCH.ASM (MSDOS 6.0, 1993)
;============================================================================
; 27/04/2019 - Retro DOS 4.0

;mpatch.asm -- holds data patch location for callouts 
; -- allocate cluster in rom.asm
;
; This area is pointed to by OffsetMagicPatch[609h] in fixed DOS data.
; Currently, this location is used only by magicdrv.sys's patch to
; cluster allocation, however it can be expanded to be used by other
; patches. This is important since we have an easy-access pointer to
; this location in OffsetMagicPatch. Magicdrv.sys is guaranteed to
; only patch out a far call/retf, so any space after that could be
; used as a patch by using OffsetMagicPatch+6. See rom.asm on how
; to call out here.
;
; Currently, we allocate only the minimum space required for the 6
; byte magicdrv patch, so if you change the dos data, you may want
; to reserve space here if your new data will be position dependent
; and would prohibit growing of this table.
;       
;history	-	created 8-7-92 by scottq
;		-	added Rational386PatchPtr 2-1-93 by jimmat
;
;Exported Functions
;==================
;MagicPatch     -       callout patched by magidrv.sys for cluster allocations

; DosData Segment

; DOSDATA:1362h (MSDOS 6.21, MSDOS.SYS)

; ---------------------------------------------------------------------------

; Rational386PatchPtr points to either a RET instruction (80286 or less) or
; a routine to fix buggy versions of the Rational DOS Extender (80386 or
; greater). Added to this file because it needed to be somewhere and is
; 'patch' related.

Rational386PatchPtr:
	dw	0	; points to patch routine or RET instr.
; ---------------------------------------------------------------------------

MagicPatch:
;MagicPatch proc far
        retf            ;default is to just return to allocate
        nop             ;however, this code will be patched
        nop             ;by magicdrv.sys to
        nop             ; call far ?:?     
        nop             ; retf or perhaps just jmp far
        nop             ;retf/nop take one byte, so we need six instructions
                        ;for 6 byte patch
;MagicPatch endp

; ---------------------------------------------------------------------------

;DosData Ends

; DOSDATA:136Ah

;----------------------------------------------------------------------------

;DOSDATALAST SEGMENT

; 29/04/2019 - Retro DOS v4.0

;----------------------------------------------------------------------------
; 25/05/2019 - Retro DOS v4.0 Modification (paragraph alignment)

;db 0,1,12,64,19,0 ; ! Magic numbers !

;align 16

; !!! DOSDATA:1370h ; Retro DOS v4.0 only!

;----------------------------------------------------------------------------

%endif	; 05/11/2022

; 05/12/2022
;MSDAT001E:	; label byte

; 05/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 MSDOS.SYS)
DOSDATAEND equ $
DOSDATASIZE equ DOSDATAEND - DOSDATASTART ; = 4962 for MSDOS 5.0 MSDOS.SYS
MSDAT001E equ DOSDATAEND - DOSDATASTART

;DOSDATALAST ENDS

; Retro DOS v4.0 by Erdogan Tan (Redevelopment of MSDOS 5.0 KERNEL via NASM)
; DECEMBER 2022, ISTANBUL - TURKIYE.
;============================================================================
;	END
;============================================================================
; Retro DOS v4.0 by Erdogan Tan (Redevelopment of MSDOS 6.21 KERNEL via NASM)
; -----------------------------
; MAY 2019, ISTANBUL - TURKIYE.