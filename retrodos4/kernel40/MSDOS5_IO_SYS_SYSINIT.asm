

;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2013 Hex-Rays, <support@hex-rays.com>	    |
; |			 Licensed to: Freeware version			    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	668F4B20F6E29BE5E81D1D351DA48C22
; Input	CRC32 :	5A0CE9FB

; File Name   :	C:\Users\Erdoðan\Desktop\SYSINIT.BIN
; Format      :	Binary file
; Base Address:	0000h Range: 0000h - 3D20h Loaded length: 00003D20h

		.386
		.model flat

; ===========================================================================

; Segment type:	Pure code
seg000		segment	byte public 'CODE' use16
		assume cs:seg000
		assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing
SYSINIT$	dw 0			; ...
stackcount	dw 0			; ...
stackat		dw 0			; ...
stacksize	dw 0			; ...
stacks		dd 0			; ...
firstentry	dw offset stacks	; ...
lastentry	dw 48h			; ...
					; stacks+(defaultcount*entrysize)-entrysize
nextentry	dw 48h			; ...
					; stacks+(defaultcount*entrysize)-entrysize
old02		dd 0			; ...
; ---------------------------------------------------------------------------

int02:					; ...
		push	ax
		push	es
		mov	ax, 0F000h
		mov	es, ax
		assume es:nothing

loc_1D:					; ...
		cmp	byte ptr es:0FFFEh, 0F9h ; 'ù'
		pop	es
		assume es:nothing

loc_24:					; ...
		jnz	short normal02
		in	al, 62h		; PC/XT	PPI port C. Bits:
					; 0-3: values of DIP switches
					; 5: 1=Timer 2 channel out
					; 6: 1=I/O channel check
					; 7: 1=RAM parity check	error occurred.

loc_28:					; ...
		test	al, 80h
		jz	short normal02
		pop	ax
		jmp	cs:old02
; ---------------------------------------------------------------------------

normal02:				; ...
		pop	ax
		call	near ptr do_int_stacks
		adc	al, [bx+si]
; ---------------------------------------------------------------------------
old08		dd 0			; ...
; ---------------------------------------------------------------------------

int08:					; ...
		call	near ptr do_int_stacks
		cmp	[bx+si], al	; ...
; ---------------------------------------------------------------------------
old09		dd 0			; ...
; ---------------------------------------------------------------------------

int09:					; ...
		jmp	short keyboard_lbl
; ---------------------------------------------------------------------------
		nop
; ---------------------------------------------------------------------------
byte_48		db 0			; ...
; ---------------------------------------------------------------------------

keyboard_lbl:				; ...
		call	near ptr do_int_stacks
; ---------------------------------------------------------------------------
off_4C		dw offset old09		; ...
old70		dd 0			; ...
; ---------------------------------------------------------------------------

int70:					; ...
		call	near ptr do_int_stacks
		dec	si
; ---------------------------------------------------------------------------
		db    0
; ---------------------------------------------------------------------------

int0A:					; ...
		jmp	short entry_int0A_stk
; ---------------------------------------------------------------------------
old0A		dd 0			; ...
		dw 424Bh
firstflag0A	db 0
; ---------------------------------------------------------------------------

loc_60:					; ...
		jmp	short intret_0A
; ---------------------------------------------------------------------------
byte_62		db 7 dup(0)		; ...
; ---------------------------------------------------------------------------

entry_int0A_stk:			; ...
		call	near ptr do_int_stacks
		pop	cx
; ---------------------------------------------------------------------------
		db    0
; ---------------------------------------------------------------------------

intret_0A:				; ...
		iret
; ---------------------------------------------------------------------------

int0B:
		jmp	short entry_int0B_stk
; ---------------------------------------------------------------------------
old0B		dd 0			; ...
		dw 424Bh
firstflag0B	db 0
; ---------------------------------------------------------------------------
		jmp	short intret_0B
; ---------------------------------------------------------------------------
		db 7 dup(0)
; ---------------------------------------------------------------------------

entry_int0B_stk:			; ...
		call	near ptr do_int_stacks
; ---------------------------------------------------------------------------
off_84		dw offset old0B		; ...
; ---------------------------------------------------------------------------

intret_0B:				; ...
		iret
; ---------------------------------------------------------------------------

int0C:					; ...
		jmp	short entry_int0C_stk
; ---------------------------------------------------------------------------
old0C		dd 0			; ...
		dw 424Bh
firstflag0C	db 0
; ---------------------------------------------------------------------------
		jmp	short intret_0C
; ---------------------------------------------------------------------------
		db 7 dup(0)
; ---------------------------------------------------------------------------

entry_int0C_stk:			; ...
		call	near ptr do_int_stacks
		mov	[bx+si], ax

intret_0C:				; ...
		iret
; ---------------------------------------------------------------------------

int0D:					; ...
		jmp	short entry_int0D_stk
; ---------------------------------------------------------------------------
old0D		dd 0			; ...
		dw 424Bh
firstflag0D	db 0
; ---------------------------------------------------------------------------
		jmp	short intret_0D
; ---------------------------------------------------------------------------
		db 7 dup(0)
; ---------------------------------------------------------------------------

entry_int0D_stk:			; ...
		call	near ptr do_int_stacks
; ---------------------------------------------------------------------------
		dw offset old0D
; ---------------------------------------------------------------------------

intret_0D:				; ...
		iret
; ---------------------------------------------------------------------------

int0E:					; ...
		jmp	short entry_int0E_stk
; ---------------------------------------------------------------------------
old0E		dd 0			; ...
word_BD		dw 424Bh		; ...
firstflag0E	db 0
; ---------------------------------------------------------------------------
		jmp	short intret_0E
; ---------------------------------------------------------------------------
		db 7 dup(0)
; ---------------------------------------------------------------------------

entry_int0E_stk:			; ...
		call	near ptr do_int_stacks
; ---------------------------------------------------------------------------
		dw offset old0E
; ---------------------------------------------------------------------------

intret_0E:				; ...
		iret
; ---------------------------------------------------------------------------

int72:					; ...
		jmp	short entry_int72_stk
; ---------------------------------------------------------------------------
old72		dd 0			; ...
		dw 424Bh
firstflag72	db 0
; ---------------------------------------------------------------------------
		jmp	short intret_72
; ---------------------------------------------------------------------------
		db 7 dup(0)
; ---------------------------------------------------------------------------

entry_int72_stk:			; ...
		call	near ptr do_int_stacks
		rol	word ptr [bx+si], 1

intret_72:				; ...
		iret
; ---------------------------------------------------------------------------

int73:					; ...
		jmp	short entry_int73_stk
; ---------------------------------------------------------------------------
old73		dd 0			; ...
		dw 424Bh
firstflag73	db 0
; ---------------------------------------------------------------------------
		jmp	short intret_73
; ---------------------------------------------------------------------------
		db 7 dup(0)
; ---------------------------------------------------------------------------

entry_int73_stk:			; ...
		call	near ptr do_int_stacks
; ---------------------------------------------------------------------------
		dw offset old73
; ---------------------------------------------------------------------------

intret_73:				; ...
		iret
; ---------------------------------------------------------------------------

int74:					; ...
		jmp	short entry_int74_stk
; ---------------------------------------------------------------------------
old74		dd 0			; ...
		dw 424Bh
firstflag74	db 0
; ---------------------------------------------------------------------------
		jmp	short intret_74
; ---------------------------------------------------------------------------
		db 7 dup(0)
; ---------------------------------------------------------------------------

entry_int74_stk:			; ...
		call	near ptr do_int_stacks
		add	[bx+di], ax

intret_74:				; ...
		iret
; ---------------------------------------------------------------------------

int76:					; ...
		jmp	short entry_int76_stk
; ---------------------------------------------------------------------------
old76		dd 0			; ...
		dw 424Bh
firstflag76	db 0
; ---------------------------------------------------------------------------
		jmp	short intret_76
; ---------------------------------------------------------------------------
		db 7 dup(0)
; ---------------------------------------------------------------------------

entry_int76_stk:			; ...
		call	near ptr do_int_stacks
		sbb	[bx+di], ax

intret_76:				; ...
		iret
; ---------------------------------------------------------------------------

int77:
		jmp	short entry_int77_stk
; ---------------------------------------------------------------------------
old77		dd 0
		dw 424Bh
firstflag77	db 0
; ---------------------------------------------------------------------------
		jmp	short intret_77
; ---------------------------------------------------------------------------
		db 7 dup(0)
; ---------------------------------------------------------------------------

entry_int77_stk:			; ...
		call	near ptr do_int_stacks
		xor	[bx+di], ax

intret_77:				; ...
		iret

; =============== S U B	R O U T	I N E =======================================


do_int_stacks	proc far		; ...
		push	ax
		push	bp
		push	es
		mov	es, word ptr cs:stacks+2
		mov	bp, cs:nextentry
		mov	al, 1
		xchg	al, es:[bp+0]
		cmp	al, 0
		jnz	short notfree02
		sub	cs:nextentry, 8

found02:				; ...
		mov	es:[bp+2], sp
		mov	word ptr es:[bp+4], ss
		mov	ax, bp
		mov	bp, es:[bp+6]
		cmp	es:[bp+0], ax
		jnz	short foundbad02
		push	bp
		mov	bp, sp
		mov	ax, [bp+8]
		pop	bp
		push	es
		pop	ss
		mov	sp, bp
		mov	bp, ax
		mov	bp, cs:[bp+0]
		pushf
		call	dword ptr cs:[bp+0]
		mov	bp, sp
		mov	bp, es:[bp+0]
		mov	ss, word ptr es:[bp+4]
		mov	sp, es:[bp+2]
		mov	byte ptr es:[bp+0], 0
		mov	cs:nextentry, bp
		pop	es
		pop	bp
		pop	ax
		add	sp, 2
		iret
; ---------------------------------------------------------------------------

notfree02:				; ...
		cmp	al, 1
		jz	short findnext02
		xchg	al, es:[bp+0]

findnext02:				; ...
		call	longpath
		jmp	short found02
; ---------------------------------------------------------------------------

foundbad02:				; ...
		cmp	bp, cs:firstentry
		jb	short findnext02
		mov	bp, ax
		mov	byte ptr es:[bp+0], 3
		jmp	short findnext02
do_int_stacks	endp


; =============== S U B	R O U T	I N E =======================================


longpath	proc near		; ...
		mov	bp, cs:lastentry

lploopp:				; ...
		cmp	byte ptr es:[bp+0], 0
		jnz	short inuse
		mov	al, 1
		xchg	al, es:[bp+0]
		cmp	al, 0
		jz	short found
		cmp	al, 1
		jz	short inuse
		mov	es:[bp+0], al

inuse:					; ...
		cmp	bp, cs:firstentry
		jz	short fatal
		sub	bp, 8
		jmp	short lploopp
; ---------------------------------------------------------------------------

found:					; ...
		retn
; ---------------------------------------------------------------------------

fatal:					; ...
		push	ds
		mov	ax, 0F000h
		mov	ds, ax
		assume ds:nothing
		cmp	byte ptr ds:0FFFEh, 0F9h

loc_200:
		pop	ds
		assume ds:nothing
		jnz	short skip_nmis
		mov	al, 7
		out	72h, al		; CMOS Memory/RTC Index	Register (Extended RAM)

skip_nmis:				; ...
		cli
		mov	al, 0FFh
		out	21h, al		; Interrupt controller,	8259A.
		out	0A1h, al	; Interrupt Controller #2, 8259A
		mov	si, cs
		mov	ds, si
		mov	si, offset fatal_msg ; "\r\n\a\r\nInternal stack overflow\r\nSy"...
		push	ax
		push	ds
		mov	ax, 70h
		mov	ds, ax
		assume ds:nothing
		test	byte ptr ds:8D0h, 1
		pop	ds
		assume ds:nothing
		pop	ax
		jz	short fatal_loop
		call	far ptr	70h:8D1h

fatal_loop:				; ...
		lodsb
		cmp	al, '$'
		jz	short fatal_done
		mov	bl, 7
		mov	ah, 0Eh
		int	10h		; - VIDEO - WRITE CHARACTER AND	ADVANCE	CURSOR (TTY WRITE)
					; AL = character, BH = display page (alpha modes)
					; BL = foreground color	(graphics modes)
		jmp	short fatal_loop
; ---------------------------------------------------------------------------

fatal_done:				; ...
		jmp	short fatal_done
longpath	endp

; ---------------------------------------------------------------------------
fatal_msg	db 0Dh,0Ah		; ...
		db 7,0Dh,0Ah
		db 'Internal stack overflow',0Dh,0Ah
		db 'System halted',0Dh,0Ah,'$'
; ---------------------------------------------------------------------------

SYSINIT:				; ...
		jmp	GOINIT
; ---------------------------------------------------------------------------
runhigh		db 0			; ...
DOSINFO		dd 0			; ...
dosinit		dw 0			; ...
					; dos_temp_location
CURRENT_DOS_LOCATION dw	0		; ...
DEVICE_LIST	dd 0			; ...
sysi_country	dd 0			; ...
dos_segreinit	dd 0			; ...
lo_doscod_size	dw 0			; ...
hi_doscod_size	dw 0			; ...
def_php		dw 0			; ...
_seg_reinit_ptr	dw 32h			; ...
temp_bcode_seg	dw 2C7h			; ...
fake_floppy_drv	db 0			; ...
stack_count	dw 9			; ...
stack_size	dw 128			; ...
stack_addr	dd 0			; ...
MEMORY_SIZE	dw 1			; ...
RPLMemTop	dw 0			; ...
DEFAULT_DRIVE	db 0			; ...
buffers		dw 0FFFFh		; ...
h_buffers	dw 0			; ...
singlebuffersize dw 0			; ...
FILES		db 8			; ...
FCBS		db 4			; ...
KEEP		db 0			; ...
NUM_CDS		db 5			; ...
top_of_cdss	dw 0			; ...
ALLOCLIM	dw 0			; ...
DirStrng	db 'A', ':', '\', 0     ; ...
command_line	db 2, 0			; ...
		db 'P'
		db 0
		db 124 dup(0)
ZERO		db 0			; ...
sepchr		db 0			; ...
linecount	dw 0			; ...
showcount	db '     ',0Dh,0Ah,'$'  ; ...
buffer_linenum	dw 0			; ...
sys_model_byte	db 0FFh			; ...
sys_scnd_model_byte db 0		; ...
buf_prev_off	dw 0			; ...
COMEXE		dw 0			; ...
EXEC0_COM_LINE	dw offset command_line
		dw 46Dh			; SYSINIT segment
EXEC0_5C_FCB	dw offset DEFAULT_DRIVE
		dw 46Dh
EXEC0_6C_FCB	dw offset ZERO		; default fcb at 6Ch
		dw 46Dh
multi_pass_id	db 0			; ...
install_flag	dw 0			; ...
config_size	dw 0			; ...
sysinit_base_ptr dd 0			; ...
sysinit_ptr	dd 0			; ...
checksum	dw 0			; ...
ldexec_fcb	db 14h dup(20h)		; ...
ldexec_line	db 0			; ...
ldexec_start	db 20h			; ...
ldexec_parm	db 80 dup(0)		; ...
instexe		dw 0			; ...
iexec_ldexec_line dw offset ldexec_line
iexec_ldexec_line_seg dw 46Dh		; ...
iexec_ldexec_5c_fcb dw offset ldexec_fcb
iexec_ldexec_5c_fcb_seg	dw 46Dh		; ...
iexec_ldexec_6c_fcb dw offset ldexec_fcb
iexec_ldexec_6c_fcb_seg	dw 46Dh		; ...
com_level	db 0			; ...
cmmt		db 0			; ...
cmmt1		db 0			; ...
cmmt2		db 0			; ...
cmd_indicator	db 0			; ...
donotshownum	db 0			; ...
count		dw 0			; ...
org_count	dw 0			; ...
chrptr		dw 0			; ...
cntryfilehandle	dw 0			; ...
old_area	dw 0			; ...
impossible_owner_size dw 0		; ...
memlo		dw 0			; ...
memhi		dw 0			; ...
ldoff		dw 0
area		dw 0			; ...
packet		db 24			; ...
		db 0
		db 0
		dw 0
		db 8 dup(0)
unitcount	db 0			; ...
break_addr	db 4 dup(0)		; ...
bpb_addr	db 4 dup(0)		; ...
devdrivenum	db 0			; ...
configmsgflag	dw 0			; ...
toomanydrivesflag db 0			; ...
BCodeSeg	dw 2C7h			; ...
BiosComBlock	dd 7008FDh		; ...
tempstack	db 128 dup(0)		; ...
; ---------------------------------------------------------------------------

GOINIT:					; ...
		mov	ah, 0C0h
		int	15h		; SYSTEM - GET CONFIGURATION (XT after 1/10/86,AT mdl 3x9,CONV,XT286,PS)
		jb	short no_rom_config
		cmp	ah, 0
		jnz	short no_rom_config
		mov	al, es:[bx+2]
		mov	cs:sys_model_byte, al
		mov	al, es:[bx+3]
		mov	cs:sys_scnd_model_byte,	al
		jmp	short move_myself
; ---------------------------------------------------------------------------

no_rom_config:				; ...
		mov	ax, 0F000h
		mov	ds, ax
		assume ds:nothing
		mov	al, ds:0FFFEh
		mov	cs:sys_model_byte, al
		int	11h		; check_for_fake_floppy
					;
					; EQUIPMENT DETERMINATION
					; Return: AX = equipment flag bits
		test	ax, 1
		jnz	short move_myself
		push	es
		xor	cl, cl
		mov	ah, 8
		mov	dl, 0
		int	13h		; DISK - DISK -	GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)
					; DL = drive number
					; Return: CF set on error, AH =	status code, BL	= drive	type
					; DL = number of consecutive drives
					; DH = maximum value for head number, ES:DI -> drive parameter
		pop	es
		jb	short move_myself
		cmp	cl, 0
		jz	short move_myself
		or	dl, dl
		jnz	short move_myself
		mov	cs:fake_floppy_drv, 1

move_myself:				; ...
		cld
		xor	si, si
		mov	di, si
		mov	cx, cs:MEMORY_SIZE
		push	cs
		pop	ds
		assume ds:nothing
		dec	cx
		xor	bx, bx
		mov	es, bx

loc_4E2:				; [es:(2Fh*4)] ; INT 2Fh address (0:0BCh)
		mov	bx, word ptr es:old0E+3
		mov	es, es:word_BD+1 ; [es:((2Fh*4)+2)] ; INT 2Fh segment (0:0BEh)
		assume es:nothing
		cmp	word ptr es:[bx+3], 'PR' ; check for 'RPL'
		jnz	short NoRPL
		cmp	byte ptr es:[bx+5], 'L'
		jnz	short NoRPL
		mov	dx, cx
		push	dx
		mov	ax, 4A06h
		int	2Fh
		pop	ax
		mov	cx, dx
		cmp	dx, ax
		jz	short NoRPL
		mov	cs:RPLMemTop, dx
		dec	cx

NoRPL:					; ...
		mov	ax, 3D20h	; SI_end (SYSINIT code size)
		call	_off_to_para
		sub	cx, ax
		sub	cx, 0A00h	; (SYSINITSEG-DOSBIOCODESEG)*10h
		mov	ax, 1A60h
		call	_off_to_para
		sub	cx, ax
		mov	es, cx
		assume es:nothing
		mov	cx, 3D20h	; sysinit code size
		shr	cx, 1
		rep movsw
		push	es
		mov	ax, offset SYSIN
		push	ax
		retf
; ---------------------------------------------------------------------------

SYSIN:					; ...
		mov	ax, 70h
		mov	ds, ax
		assume ds:nothing
		mov	word ptr ds:8FBh, cs ; [MoveDOSIntoHMA+2]
		mov	byte ptr ds:8FDh, 1 ; [SysinitPresent]
		mov	ax, 3D20h	; SI_end
		call	_off_to_para
		mov	cx, cs
		add	ax, cx
		mov	es, ax
		xor	si, si
		mov	di, si
		mov	ds, cs:CURRENT_DOS_LOCATION
		assume ds:nothing
		mov	cx, 5000h
		rep movsw
		mov	cs:CURRENT_DOS_LOCATION, es
		mov	ax, ds:stackcount+1 ; mov ax, [3]
		mov	cs:dosinit, ax
		call	_off_to_para
		sub	cs:CURRENT_DOS_LOCATION, ax
		mov	ax, es
		add	ax, 0A00h
		mov	es, ax
		assume es:nothing
		xchg	ax, cs:temp_bcode_seg
		mov	ds, ax
		mov	si, 30h	; '0'
		mov	di, si
		mov	cx, 1A60h
		sub	cx, si
		shr	cx, 1
		rep movsw
		mov	ax, es
		call	dword ptr cs:_seg_reinit_ptr
		les	di, cs:BiosComBlock
		assume es:nothing
		lds	si, cs:DEVICE_LIST
		mov	dx, cs:MEMORY_SIZE
		cli
		mov	ax, cs
		mov	ss, ax

locstack:				; ...
		mov	sp, offset locstack
		sti
		call	dword ptr cs:dosinit
		mov	cs:def_php, ds
		mov	cs:hi_doscod_size, ax
		mov	cs:lo_doscod_size, cx
		mov	word ptr cs:dos_segreinit, dx
		mov	ax, es:[di]
		mov	word ptr cs:DOSINFO, ax
		mov	ax, es:[di+2]
		mov	word ptr cs:DOSINFO+2, ax
		mov	ax, es:[di+4]
		mov	word ptr cs:sysi_country, ax
		mov	ax, es:[di+6]
		mov	word ptr cs:sysi_country+2, ax
		mov	es, cs:CURRENT_DOS_LOCATION
		mov	word ptr cs:dos_segreinit+2, es
		cmp	cs:RPLMemTop, 0
		jz	short NoRPLArena
		mov	bx, 0FFFFh
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		mov	es, ax
		push	es
		sub	ax, cs:RPLMemTop
		neg	ax
		dec	ax
		mov	bx, ax
		mov	ah, 4Ah
		int	21h		; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
					; ES = segment address of block	to change
					; BX = new size	in paragraphs
		mov	bx, 0FFFFh
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		dec	ax
		mov	es, ax
		mov	es:SYSINIT$+1, 8
		mov	word ptr es:stacks, 'PR'
		mov	word ptr es:stacks+2, 'L'
		mov	es:firstentry, 0
		mov	es:lastentry, 0
		pop	es
		mov	ah, 49h
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed

NoRPLArena:				; ...
		les	di, cs:DOSINFO
		clc
		mov	ah, 88h
		int	15h		; Get Extended Memory Size
					; Return: CF clear on success
					; AX = size of memory above 1M in K
		jb	short no_ext_memory
		mov	es:[di+45h], ax
		or	ax, ax
		jz	short no_ext_memory
		call	ClrVDISKHeader

no_ext_memory:				; ...
		mov	ax, es:[di+10h]
		add	ax, 20		; bufinsiz
		mov	cs:singlebuffersize, ax
		mov	al, cs:DEFAULT_DRIVE
		mov	es:[di+43h], al

get_cpu_type:
		pushf
		push	bx
		xor	bx, bx
		xor	ax, ax
		push	ax
		popf
		pushf
		pop	ax
		and	ax, 0F000h
		cmp	ax, 0F000h
		jz	short cpu_8086
		mov	ax, 0F000h
		push	ax
		popf
		pushf
		pop	ax
		and	ax, 0F000h
		jz	short cpu_286

cpu_386:
		inc	bx

cpu_286:				; ...
		inc	bx

cpu_8086:				; ...
		mov	ax, bx
		pop	bx
		popf
		cmp	ax, 2
		jnz	short not_386_system
		mov	byte ptr es:[di+44h], 1

not_386_system:				; ...
		mov	al, es:[di+20h]
		mov	cs:devdrivenum,	al
		mov	ax, cs
		sub	ax, 11h
		mov	cx, cs:singlebuffersize
		shr	cx, 1
		shr	cx, 1
		shr	cx, 1
		shr	cx, 1
		inc	cx
		sub	ax, cx
		mov	cs:top_of_cdss,	ax
		push	es
		push	di
		les	di, es:[di+12h]
		mov	word ptr es:[di+4], 0
		mov	word ptr es:[di], 0
		mov	es:[di+2], ax
		mov	es, ax
		xor	ax, ax
		mov	di, ax
		mov	es:[di], ax
		mov	es:[di+2], ax
		mov	word ptr es:[di+4], 0FFh
		mov	word ptr es:[di+6], 0
		mov	word ptr es:[di+8], 0
		pop	di
		pop	es
		push	cs
		pop	ds
		call	TempCDS
		mov	ds, cs:def_php
		call	far ptr	70h:89Bh
		sti
		cld
		mov	bx, cs
		sub	bx, 10h
		mov	es, bx
		assume es:nothing
		xor	si, si		; ...

loc_70E:				; ...
		mov	di, si

loc_710:				; ...
		mov	cx, 128
		rep movsw
		mov	word ptr es:36h, es
		mov	ah, 50h
		int	21h		; DOS -	2+ internal - SET PSP SEGMENT
					; BX = segment address of new PSP
		push	ds
		push	cs
		pop	ds
		mov	dx, offset int24
		mov	ax, 2524h
		int	21h		; DOS -	SET INTERRUPT VECTOR
					; AL = interrupt number
					; DS:DX	= new vector to	be used	for specified interrupt
		cmp	ds:toomanydrivesflag, 0
		jz	short no_err
		mov	dx, offset TooManyDrivesMsg ; "WARNING!	Logical	drives past Z: exist a"...
		call	print

no_err:					; ...
		pop	ds
		mov	dl, cs:DEFAULT_DRIVE
		or	dl, dl
		jz	short nodrvset
		dec	dl
		mov	ah, 0Eh
		int	21h		; DOS -	SELECT DISK
					; DL = new default drive number	(0 = A,	1 = B, etc.)
					; Return: AL = number of logical drives

nodrvset:				; ...
		call	doconf
		cmp	cs:runhigh, 0
		jz	short dont_install_stub
		mov	es, cs:CURRENT_DOS_LOCATION
		assume es:nothing
		xor	ax, ax
		call	cs:dos_segreinit
		jmp	short do_multi_pass
; ---------------------------------------------------------------------------

dont_install_stub:			; ...
		xor	bx, bx
		call	MovDOSLo
; ---------------------------------------------------------------------------
		mov	ax, (offset SYSINIT$+1)
		mov	es, cs:CURRENT_DOS_LOCATION
		call	cs:dos_segreinit

do_multi_pass:				; ...
		call	AllocFreeMem
		inc	cs:multi_pass_id
		call	multi_pass
		call	ShrinkUMB
		call	UnlinkUMB
		inc	cs:multi_pass_id
		call	multi_pass
		call	endfile
		mov	ax, 70h
		mov	es, ax
		assume es:nothing
		mov	byte ptr es:8FDh, 0 ; [es:SysinitPresent]
		test	cs:install_flag, 1
		jz	short dolast
		inc	cs:multi_pass_id
		call	multi_pass

dolast:					; ...
		cmp	cs:runhigh, 0FFh
		jnz	short _@@
		call	LoadDOSHiOrLo

_@@:					; ...
		cmp	cs:runhigh, 0
		jz	short ConfigDone ; _@@@
		call	CPMHack

ConfigDone:				; ...
		mov	cs:donotshownum, 1
		mov	es, cs:area
		assume es:nothing
		mov	ah, 49h
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		test	cs:install_flag, 2
		jz	short skip_free_sysinitbase
		push	es
		push	bx
		mov	es, cs:old_area
		mov	bx, cs:impossible_owner_size
		mov	ah, 4Ah
		int	21h		; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
					; ES = segment address of block	to change
					; BX = new size	in paragraphs
		mov	ax, es
		dec	ax
		mov	es, ax
		mov	es:SYSINIT$+1, 8
		mov	word ptr es:stacks, 'DS'
		pop	bx
		pop	es

skip_free_sysinitbase:			; ...
		cmp	cs:runhigh, 0
		jz	short _@@@@
		call	InstVDiskHeader

_@@@@:					; ...
		push	cs
		pop	ds
		mov	si, (offset command_line+1)
		push	ds
		pop	es
		mov	di, si
		mov	cl, 0FFh

_@_loop:				; ...
		inc	cl
		lodsb
		stosb
		or	al, al
		jnz	short _@_loop
		dec	di
		mov	al, 0Dh
		stosb
		mov	ds:command_line, cl

retry:					; "\\COMMAND.COM"
		mov	dx, offset commnd
		push	dx
		mov	bx, 0FFFFh
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		jb	short memerrjx
		mov	es, ax
		assume es:nothing
		mov	ah, 49h
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		mov	bp, bx
		mov	bx, ds:MEMORY_SIZE
		mov	ax, cs
		sub	bx, ax
		add	bx, 11h
		sub	bp, bx
		jb	short memerrjx
		mov	ax, 3D00h
		stc
		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
					; DS:DX	-> ASCIZ filename
					; AL = access mode
					; 0 - read
		jb	short comerr
		mov	bx, ax
		xor	cx, cx
		xor	dx, dx
		mov	ax, 4202h
		stc
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from end of file
		jb	short comerr
		add	ax, 15
		adc	dx, 0
		call	_off_to_para
		mov	cl, 12
		shl	dx, cl
		or	ax, dx
		add	ax, 10h
		cmp	ax, bp
		jb	short okld

memerrjx:				; ...
		jmp	memerr
; ---------------------------------------------------------------------------

okld:					; ...
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		pop	dx
		push	cs
		pop	es
		assume es:nothing
		mov	bx, offset COMEXE
		mov	word ptr [bx+4], cs
		mov	word ptr [bx+8], cs
		mov	word ptr [bx+12], cs
		xor	ax, ax
		mov	ah, 4Bh
		stc
		int	21h		; DOS -	2+ - LOAD OR EXECUTE (EXEC)
					; DS:DX	-> ASCIZ filename
					; ES:BX	-> parameter block
					; AL = subfunc:	load & execute program

comerr:					; ...
		mov	dx, offset badcom ; "Command Interpreter"
		call	badfil
; START	OF FUNCTION CHUNK FOR multi_pass

stall:					; ...
		jmp	short stall
; END OF FUNCTION CHUNK	FOR multi_pass

; =============== S U B	R O U T	I N E =======================================


AllocFreeMem	proc near		; ...
		mov	bx, 0FFFFh
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		mov	cs:area, ax
		mov	cs:memhi, ax
		retn
AllocFreeMem	endp

; ---------------------------------------------------------------------------
DOSLOMSG	db 'HMA not available : Loading DOS low',0Dh,0Ah,'$' ; ...
FEmsg		db 'Fatal Error:Cannot allocate Memory for DOS',0Dh,0Ah,'$' ; ...

; =============== S U B	R O U T	I N E =======================================


LoadDOSHiOrLo	proc near		; ...
		call	TryToMovDOSHi
		jb	short LdngLo
		retn
; ---------------------------------------------------------------------------

LdngLo:					; ...
		push	cs
		pop	ds
		mov	ah, 9
		mov	dx, offset DOSLOMSG ; "HMA not available : Loading DOS low\r\n"...
		int	21h		; DOS -	PRINT STRING
					; DS:DX	-> string terminated by	"$"
		mov	bx, 1
		call	MovDOSLo
; ---------------------------------------------------------------------------
		mov	es, cs:CURRENT_DOS_LOCATION
		xor	ax, ax
		call	cs:dos_segreinit
		mov	cs:runhigh, 0
		retn
LoadDOSHiOrLo	endp


; =============== S U B	R O U T	I N E =======================================


TryToMovDOSHi	proc near		; ...
		call	MovDOSHi
		jb	short ttldhx
		mov	es, cs:CURRENT_DOS_LOCATION
		xor	ax, ax
		call	cs:dos_segreinit
		mov	cs:runhigh, 1
		clc

ttldhx:					; ...
		retn
TryToMovDOSHi	endp


; =============== S U B	R O U T	I N E =======================================


MovDOSHi	proc near		; ...
		call	AllocHMA
		jb	short mdhx
		mov	ax, 0FFFFh
		mov	es, ax
		assume es:nothing
		call	MovBIOS
		mov	cx, cs:hi_doscod_size
		call	MovDOS
		call	SaveFreeHMAPtr
		clc

mdhx:					; ...
		retn
MovDOSHi	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn

MovDOSLo	proc near		; ...
		call	AllocMemForDOS
MovDOSLo	endp

; ---------------------------------------------------------------------------
		mov	es, ax
		assume es:nothing
		call	MovBIOS
		mov	cx, cs:lo_doscod_size
		call	MovDOS
		retn

; =============== S U B	R O U T	I N E =======================================


MovBIOS		proc near		; ...
		mov	ds, cs:temp_bcode_seg
		mov	si, 30h
		mov	di, si
		mov	cx, 1A60h
		sub	cx, si
		shr	cx, 1
		rep movsw
		push	es
		push	di
		mov	ax, es
		mov	cs:BCodeSeg, ax
		call	dword ptr cs:_seg_reinit_ptr
		pop	di
		pop	es
		retn
MovBIOS		endp


; =============== S U B	R O U T	I N E =======================================


MovDOS		proc near		; ...
		push	es
		push	di
		lds	si, dword ptr cs:dosinit
		rep movsb
		pop	bx
		mov	ax, cs:dosinit
		sub	ax, bx
		call	_off_to_para
		pop	bx
		sub	bx, ax
		mov	cs:CURRENT_DOS_LOCATION, bx
		retn
MovDOS		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn

AllocMemForDOS	proc near		; ...
		mov	ax, 1A60h
		sub	ax, 30h
		add	ax, cs:lo_doscod_size
		add	ax, 15
		call	_off_to_para
		or	bx, bx
		mov	bx, ax
		jz	short update_arena
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		jb	short FatalErr
		sub	ax, 3
		mov	es, ax
		mov	word ptr es:loc_1D+4, 8	; [es:20h+ARENA.OWNER]
		mov	word ptr es:loc_28, 'CS' ; [es:20h+ARENA.NAME]
		retn
; ---------------------------------------------------------------------------

update_arena:				; ...
		push	ds
		push	di
		push	cx
		push	dx
		lds	di, cs:DOSINFO
		dec	di
		dec	di
		mov	es, word ptr [di]
		mov	cx, es:stackcount+1
		cmp	cx, bx
		jb	short FatalErr
		mov	dl, byte ptr es:SYSINIT$
		mov	ax, es
		add	ax, bx
		mov	[di], ax
		mov	ds, ax
		mov	byte ptr ds:SYSINIT$, dl
		mov	ds:SYSINIT$+1, 0
		sub	cx, bx
		mov	ds:stackcount+1, cx
		mov	ax, es
		sub	ax, 3
		pop	dx
		pop	cx
		pop	di
		pop	ds
		retn
; ---------------------------------------------------------------------------

FatalErr:				; ...
		push	cs
		pop	ds
		mov	dx, offset FEmsg ; "Fatal Error:Cannot allocate	Memory for "...
		mov	ah, 9
		int	21h		; DOS -	PRINT STRING
					; DS:DX	-> string terminated by	"$"
		cli
		hlt
AllocMemForDOS	endp ; sp-analysis failed


; =============== S U B	R O U T	I N E =======================================


AllocHMA	proc near		; ...
		push	ds
		mov	ax, 70h
		mov	ds, ax
		assume ds:nothing
		call	IsXMSLoaded
		jnz	short grabhma_error
		mov	ax, 4310h
		int	2Fh		; - Multiplex -	XMS - GET DRIVER ADDRESS
					; Return: ES:BX	-> driver entry	point
		mov	ds:0Eh,	bx
		mov	word ptr ds:10h, es
		mov	ah, 1
		mov	dx, 0FFFFh
		call	dword ptr ds:0Eh
		dec	ax
		jz	short allocHMA_1
		mov	ah, 88h
		int	15h		; Get Extended Memory Size
					; Return: CF clear on success
					; AX = size of memory above 1M in K
		cmp	ax, 64
		jb	short grabhma_error

allocHMA_1:				; ...
		mov	ah, 5
		call	dword ptr ds:0Eh
		dec	ax
		jnz	short grabhma_error
		call	IsVDiskInstalled
		jz	short grabhma_error
		mov	ax, 0FFFFh
		mov	es, ax
		assume es:nothing
		mov	word ptr es:10h, 1234h
		cmp	word ptr es:10h, 1234h
		jnz	short grabhma_error
		clc
		pop	ds
		assume ds:nothing
		retn
; ---------------------------------------------------------------------------

grabhma_error:				; ...
		stc
		pop	ds
		retn
AllocHMA	endp


; =============== S U B	R O U T	I N E =======================================


IsXMSLoaded	proc near		; ...
		mov	ax, 4300h
		int	2Fh		; - Multiplex -	XMS - INSTALLATION CHECK
					; Return: AL = 80h XMS driver installed
					; AL <>	80h no driver
		cmp	al, 80h
		retn
IsXMSLoaded	endp

; ---------------------------------------------------------------------------

FTryToMovDOSHi:
		push	ax
		push	bx
		push	cx
		push	dx
		push	si
		push	di
		push	ds
		push	es
		cmp	cs:runhigh, 0FFh
		jnz	short _ftymdh_1
		call	TryToMovDOSHi

_ftymdh_1:				; ...
		pop	es
		assume es:nothing
		pop	ds
		pop	di
		pop	si
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		retf
; ---------------------------------------------------------------------------
StartVDHead	dd 0			; ...
		dw 8000h
		dw 0
		dw 0
		db 1
		db 7 dup(0)
VDiskSig1	db 'VDISK'              ; ...
aV3_3		db '  V3.3'
		db 15 dup(0)
		dw 0
		db 11h
VDInt19		db 0EAh
OldVDInt19	dw 2 dup(0)		; ...
VDiskHMAHead	db 3 dup(0)		; ...
VDiskSig2	db 'VDISK'              ; ...
		db '3.3'
		dw 128
		db 1
		dw 1
		db 1
		dw 64
		dw 512
		db 0FEh
		dw 6
		dw 8
		dw 1
		dw 0
		dw 440h

; =============== S U B	R O U T	I N E =======================================


InstVDiskHeader	proc near		; ...
		xor	ax, ax
		mov	ds, ax
		mov	ax, word ptr ds:byte_62+2 ; [19h*4]
		mov	cs:OldVDInt19, ax
		mov	ax, word ptr ds:byte_62+4 ; [19h*4+2]
		mov	cs:OldVDInt19+2, ax
		mov	ah, 48h
		mov	bx, 4		; (EndVDHead-StartVDHead+15)>>4
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		dec	ax
		mov	es, ax
		mov	es:SYSINIT$+1, 8
		mov	word ptr es:stacks, 'CS'
		inc	ax
		mov	es, ax
		cli
		mov	word ptr ds:byte_62+2, 47 ; [19h*4],(VDInt19-StartVDHead)
		mov	word ptr ds:byte_62+4, ax ; [19h*4+2]
		mov	cx, 52
		mov	si, offset StartVDHead
		xor	di, di
		push	cs
		pop	ds
		cld
		rep movsb
		sti
		push	di
		push	es
		mov	ax, 0FFFFh
		mov	es, ax
		assume es:nothing
		mov	di, 10h
		mov	cx, 32
		mov	si, offset VDiskHMAHead
		rep movsb
		pop	di
		pop	es
		assume es:nothing
		retn
InstVDiskHeader	endp

; ---------------------------------------------------------------------------
dummy		db 8 dup(0)		; ...
gdt		db 8 dup(0)
src_desc	dw 0FFFFh
src_desc_lo_word dw 0			; ...
src_desc_hi_byte db 0			; ...
		db 93h
		dw 0
tgt_desc	dw 0FFFFh
		dw 0
		db 10h
		db 93h
		dw 0
rombios_code	db 8 dup(0)
temp_stack	db 8 dup(0)
ClrdVDISKHead	db 32 dup(0)		; ...

; =============== S U B	R O U T	I N E =======================================


ClrVDISKHeader	proc near		; ...
		push	es
		mov	ax, cs
		mov	dx, ax
		mov	cl, 12
		shr	dx, cl
		mov	cl, 4
		shl	ax, cl
		add	ax, offset ClrdVDISKHead
		adc	dl, 0
		mov	cs:src_desc_lo_word, ax	; [cs:src_desc+desc.lo_word]
		mov	cs:src_desc_hi_byte, dl	; [cs:src_desc+desc.hi_byte]
		mov	cx, 16
		push	cs
		pop	es
		mov	si, offset dummy ; bmove
		mov	ah, 87h
		int	15h		; EXTENDED MEMORY - BLOCK MOVE (AT,XT286,PS)
					; CX = number of words to move,	ES:SI -> global	descriptor table
					; Return: CF set on error, AH =	status
		pop	es
		retn
ClrVDISKHeader	endp


; =============== S U B	R O U T	I N E =======================================


SaveFreeHMAPtr	proc near		; ...
		mov	bx, es
		mov	ax, 0FFFFh
		sub	ax, bx
		add	di, 15
		and	di, 0FFF0h
		mov	cl, 4
		shl	ax, cl
		sub	di, ax
		push	ds
		mov	ax, 70h
		mov	ds, ax
		assume ds:nothing
		mov	ds:8F7h, di	; [FreeHMAPtr]

loc_BE5:				; ...
		mov	byte ptr ds:0Dh, 0FFh
		pop	ds
		assume ds:nothing
		retn
SaveFreeHMAPtr	endp


; =============== S U B	R O U T	I N E =======================================


IsVDiskInstalled proc near		; ...
		xor	ax, ax
		mov	ds, ax
		mov	ds, word ptr ds:old70 ;	...
		mov	si, 18		; [19*4+2]
		mov	cx, 5		; VLEN1
		push	cs
		pop	es
		mov	di, offset VDiskSig1 ; "VDISK"
		repe cmpsb
		jz	short ivdins_retn
		mov	ax, 0FFFFh
		mov	ds, ax
		assume ds:nothing
		mov	si, 13h
		mov	di, offset VDiskSig2 ; "VDISK"
		mov	cx, 5		; VLEN2
		repe cmpsb

ivdins_retn:				; ...
		retn
IsVDiskInstalled endp


; =============== S U B	R O U T	I N E =======================================


CPMHack		proc near		; ...
		push	ds
		mov	cx, 0FFFFh
		mov	es, cx
		assume es:nothing
		xor	cx, cx
		mov	ds, cx
		assume ds:nothing
		mov	si, 0C0h
		mov	di, 0D0h
		mov	cx, 5
		cld
		rep movsb
		pop	ds
		retn
CPMHack		endp


; =============== S U B	R O U T	I N E =======================================


_off_to_para	proc near		; ...
		shr	ax, 1
		shr	ax, 1		; ...
		shr	ax, 1		; ...
		shr	ax, 1
		retn
_off_to_para	endp


; =============== S U B	R O U T	I N E =======================================


TempCDS		proc near		; ...
		les	di, ds:DOSINFO
		assume es:nothing
		mov	cl, es:[di+20h]
		xor	ch, ch
		mov	es:[di+21h], cl
		mov	al, cl
		mov	ah, 88
		mul	ah
		call	ParaRound
		mov	si, ds:top_of_cdss
		sub	si, ax
		mov	ds:ALLOCLIM, si
		mov	es:[di+18h], si
		mov	ax, si
		mov	word ptr es:[di+16h], 0
		lds	si, es:[di]
		mov	es, ax
		xor	di, di

fooset:					; ...
		mov	ax, word ptr cs:DirStrng
		stosw
		mov	ax, word ptr cs:DirStrng+2
		stosw
		inc	cs:DirStrng
		xor	ax, ax
		push	cx
		mov	cx, 63
		rep stosb
		cmp	si, 0FFFFh
		jz	short fooset_zero
		cmp	cs:fake_floppy_drv, 1
		jnz	short normcds
		cmp	byte ptr [si], 1 ; if dpb_drive	= 0 (a)	or 1 (b)
		ja	short normcds
		mov	cl, 3
		rep stosw
		pop	cx
		jmp	short get_next_dpb
; ---------------------------------------------------------------------------

fooset_zero:				; ...
		mov	cl, 3
		rep stosw
		pop	cx
		jmp	short fincds
; ---------------------------------------------------------------------------

normcds:				; ...
		pop	cx
		cmp	byte ptr [si+8], 0
		jz	short setnormcds
		mov	ax, 4000h

setnormcds:				; ...
		stosw
		mov	ax, si
		stosw
		mov	ax, ds
		stosw

get_next_dpb:				; ...
		lds	si, [si+19h]

fincds:					; ...
		mov	ax, 0FFFFh
		stosw
		stosw
		stosw
		mov	ax, 2
		stosw
		mov	al, 0
		stosb
		stosw
		stosw
		stosw
		loop	fooset
		mov	cs:DirStrng, 'A'
		retn
TempCDS		endp


; =============== S U B	R O U T	I N E =======================================


endfile		proc near		; ...
		push	ds
		mov	ax, 70h
		mov	ds, ax
		assume ds:nothing
		cmp	word ptr ds:52Fh, 0 ; [multrk_flag]
		jnz	short multrk_flag_done
		or	word ptr ds:52Fh, 80h

multrk_flag_done:			; ...
		pop	ds
		assume ds:nothing
		mov	ax, cs:top_of_cdss
		mov	cs:ALLOCLIM, ax
		push	cs
		pop	ds
		call	round
		mov	al, cs:FILES
		sub	al, 5
		jbe	short dofcbs
		push	ax
		mov	al, 'F'
		call	setdevmark
		pop	ax
		xor	ah, ah
		mov	bx, cs:memlo
		mov	dx, cs:memhi
		lds	di, cs:DOSINFO
		lds	di, [di+4]	; SYSI.SFT
		mov	[di], bx	; [di+SF.SFLink]
		mov	[di+2],	dx	; [di+SF.SFLink+2]
		push	cs
		pop	ds
		les	di, dword ptr cs:memlo
		mov	word ptr es:[di], 0FFFFh
		mov	es:[di+4], ax	; [es:di+SF.SFCount]
		mov	bl, 59		; SF_ENTRY.size
		mul	bl
		mov	cx, ax
		add	cs:memlo, ax
		mov	ax, 6
		add	cs:memlo, ax
		or	cs:setdevmarkflag, 2
		call	round		; ...
		add	di, ax
		xor	ax, ax
		rep stosb

dofcbs:					; ...
		push	cs
		pop	ds
		call	round
		mov	al, 'X'
		call	setdevmark
		mov	al, cs:FCBS
		xor	ah, ah
		mov	bx, cs:memlo
		mov	dx, cs:memhi
		lds	di, cs:DOSINFO
		mov	[di+1Ah], bx	; [di+SYSI_FCB]
		mov	[di+1Ch], dx	; [di+SYSI_FCB+2]
		mov	bl, cs:KEEP
		xor	bh, bh
		mov	[di+1Eh], bx	; [di+SYSI_KEEP]
		push	cs
		pop	ds
		les	di, dword ptr ds:memlo
		mov	word ptr es:[di], 0FFFFh
		mov	es:[di+4], ax	; [es:di+SF.SFCount]
		mov	bl, 59		; SF_ENTRY.size
		mov	cx, ax
		mul	bl
		add	ds:memlo, ax
		mov	ax, 6
		add	ds:memlo, ax
		or	ds:setdevmarkflag, 2
		call	round
		add	di, ax
		mov	al, 'A'

fillloop:				; ...
		push	cx
		mov	cx, 59		; SF_ENTRY.size
		cld
		rep stosb
		mov	word ptr es:[di-3Bh], 0
		mov	word ptr es:[di-26h], 0
		mov	word ptr es:[di-24h], 0
		pop	cx
		loop	fillloop
		cmp	ds:buffers, 0FFFFh
		jz	short dodefaultbuff
		jmp	dobuff
; ---------------------------------------------------------------------------

dodefaultbuff:				; ...
		mov	ds:h_buffers, 0
		mov	ds:buffers, 2
		push	ax
		push	ds
		les	bp, cs:DOSINFO
		les	bp, es:[bp+0]
		push	cs
		pop	ds

nextdpb:				; ...
		mov	bl, es:[bp+0]
		inc	bl
		mov	ax, 4408h
		int	21h		; DOS -	2+ - IOCTL -
		or	ax, ax
		jnz	short nosetbuf
		xor	bx, bx
		mov	bl, es:[bp+0]
		inc	bl
		mov	dx, offset devp_specialfunc ; deviceparameters
		mov	ax, 440Dh	; (IOCTL<<8)|GENERIC_IOCTL
		mov	cx, 860h
		int	21h		; DOS -	2+ - IOCTL -
		jb	short nosetbuf
		mov	bx, word ptr ds:devparms_9+6 ; deviceparameters+15
					; (totalsectors, 16bit)
		mov	ax, ds:devparms_7 ; deviceparameters+7
					; (bytespersector)
		xor	dx, dx
		mov	cx, 512
		div	cx
		mul	bx
		or	dx, dx
		jnz	short setbuf
		cmp	ax, 720
		jbe	short nosetbuf

setbuf:					; ...
		mov	ds:buffers, 3
		jmp	short chk_memsize_for_buffers
; ---------------------------------------------------------------------------

nosetbuf:				; ...
		cmp	word ptr es:[bp+19h], 0FFFFh ; [es:bp+DPB.NEXT_DPB]
		jz	short chk_memsize_for_buffers
		les	bp, es:[bp+19h]	; [es:bp+DPB.NEXT_DPB]
		jmp	short nextdpb
; ---------------------------------------------------------------------------

chk_memsize_for_buffers:		; ...
		cmp	ds:MEMORY_SIZE,	2000h
		jbe	short bufset
		mov	ds:buffers, 5
		cmp	ds:MEMORY_SIZE,	4000h
		jbe	short bufset
		mov	ds:buffers, 10
		cmp	ds:MEMORY_SIZE,	8000h
		jbe	short bufset
		mov	ds:buffers, 15

bufset:					; ...
		pop	ds
		pop	ax

dobuff:					; ...
		lds	bx, cs:DOSINFO
		mov	ax, cs:buffers
		mov	[bx+3Fh], ax
		mov	ax, cs:h_buffers
		mov	[bx+41h], ax
		lds	bx, [bx+12h]
		call	round
		mov	al, 'B'
		call	setdevmark
		push	ds
		push	bx
		call	set_buffer
		pop	bx
		pop	ds
		cmp	cs:h_buffers, 0
		jz	short xif16
		call	round
		mov	cx, cs:memlo
		mov	[bx+6],	cx
		mov	cx, cs:memhi
		mov	[bx+8],	cx
		mov	cx, cs:h_buffers
		mov	[bx+10], cx
		mov	ax, 512
		mul	cx
		mov	cs:memlo, ax
		or	cs:setdevmarkflag, 2
		call	round

xif16:					; ...
		call	round
		push	ax
		mov	ax, 'L'
		call	setdevmark
		pop	ax
		les	di, cs:DOSINFO
		mov	cl, es:[di+20h]	; [es:di+SYSI_NUMIO]
		cmp	cl, cs:NUM_CDS
		jnb	short gotncds
		mov	cl, cs:NUM_CDS

gotncds:				; ...
		xor	ch, ch
		mov	es:[di+21h], cl	; [es:di+SYSI_NCDS]
		mov	ax, cs:memhi
		mov	es:[di+18h], ax	; [es:di+SYSI_CDS+2]
		mov	ax, cs:memlo
		mov	es:[di+16h], ax	; [es:di+SYSI_CDS]
		mov	al, cl
		mov	ah, 88		; curdirlen ; curdir_list.size
		mul	ah
		call	ParaRound
		add	cs:memhi, ax
		or	cs:setdevmarkflag, 2
		call	round
		lds	si, es:[di]
		les	di, es:[di+16h]	; [es:di+SYSI_CDS]
		call	fooset
		push	cs
		pop	ds
		cmp	word ptr ds:stack_addr,	0FFFFh
		jz	short doinstallstack
		cmp	ds:sys_scnd_model_byte,	0
		jnz	short doinstallstack
		cmp	ds:sys_model_byte, 0FEh
		jnb	short skipstack

doinstallstack:				; ...
		mov	ax, ds:stack_count
		or	ax, ax
		jz	short skipstack
		call	round
		mov	al, 'S'
		call	setdevmark
		mov	ax, ds:memhi
		mov	es, ax
		push	cs
		pop	ds
		xor	si, si
		xor	di, di
		mov	cx, offset SYSINIT ; endstackcode
		mov	ds:memlo, cx
		call	round
		rep movsb
		push	ds
		mov	ax, 70h
		mov	ds, ax
		assume ds:nothing
		mov	word ptr ds:8C0h, offset nextentry ; [NextStack]
		mov	word ptr ds:8C2h, es ; [NextStack+2]
		mov	ax, cs:memlo
		mov	word ptr cs:stack_addr,	ax
		mov	ds:8C6h, ax	; [IT_StackLoc]
		mov	ax, cs:memhi
		mov	word ptr cs:stack_addr+2, ax
		mov	ds:8C8h, ax	; [IT_StackLoc+2]
		mov	ax, 8
		add	ax, cs:stack_size
		mul	cs:stack_count
		mov	ds:8CAh, ax	; [IT_StackSize]
		pop	ds
		assume ds:nothing
		call	ParaRound
		add	cs:memhi, ax
		or	cs:setdevmarkflag, 2
		call	round
		call	stackinit

skipstack:				; ...
		push	cs
		pop	ds
endfile		endp ; sp-analysis failed


loc_F9B:				; ...
		mov	al, ds:FILES
		xor	ah, ah
		mov	cx, ax
		xor	bx, bx
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		mov	bx, 2

rcclloop:				; ...
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		inc	bx
		loop	rcclloop
		mov	dx, offset condev ; "CON"
		mov	al, 2
		mov	ah, 3Dh
		stc
		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
					; DS:DX	-> ASCIZ filename
					; AL = access mode
					; 2 - read & write
		jnb	short goaux
		call	badfil		; ...
		jmp	short goaux2	; ...
; ---------------------------------------------------------------------------

goaux:					; ...
		push	ax
		mov	bx, 1		; ...
		mov	ah, 3Eh		; ...
		int	21h		; ...
					; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		pop	ax
		mov	bx, ax
		mov	ah, 45h

loc_FD0:				; ...
		int	21h		; DOS -
		mov	ah, 45h
		int	21h		; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
					; BX = file handle to duplicate

goaux2:					; ...
		mov	dx, offset auxdev ; "AUX"
		mov	al, 2
		call	open_dev
		mov	dx, offset prndev ; "PRN"
		mov	al, 1
		call	open_dev
		push	ax
		push	bx
		push	dx
		push	es
		mov	al, 0FFh
		mov	dx, 2F2h
		out	dx, al
		inc	dx
		out	dx, al
		inc	dx
		out	dx, al
		inc	dx
		out	dx, al
		inc	dx

loc_FF7:				; ...
		out	dx, al
		inc	dx
		out	dx, al
		mov	ax, 0F000h	; ...

loc_FFD:				; ...
		mov	es, ax
		assume es:nothing
		cmp	byte ptr es:0FFFEh, 0FCh
		jz	short startrearm
		mov	ah, 0C0h
		int	15h		; SYSTEM - GET CONFIGURATION (XT after 1/10/86,AT mdl 3x9,CONV,XT286,PS)
		jb	short finishrearm
		test	byte ptr es:[bx+5], 40h
		jz	short finishrearm

startrearm:				; ...
		mov	al, 0FFh
		mov	dx, 6F2h
		out	dx, al
		inc	dx
		out	dx, al
		inc	dx
		out	dx, al
		inc	dx
		inc	dx
		out	dx, al
		inc	dx
		out	dx, al

finishrearm:				; ...
		pop	es
		assume es:nothing
		pop	dx
		pop	bx
		pop	ax
		push	ax
		mov	ax, ds:memhi
		sub	ax, ds:area
		mov	ds:impossible_owner_size, ax
		mov	al, 'T'
		call	setdevmark
		pop	ax
		mov	di, ds:memhi
		mov	es, di
		mov	word ptr ds:sysinit_base_ptr+2,	di
		xor	di, di
		mov	word ptr ds:sysinit_base_ptr, di
		mov	si, offset sysinit_base
		mov	cx, 128
		add	ds:memlo, cx
		or	cs:setdevmarkflag, 2
		call	round
		rep movsb
		mov	word ptr ds:sysinit_ptr, offset	sysinitptr
		mov	word ptr ds:sysinit_ptr+2, cs
		or	ds:install_flag, 2
		call	round
		mov	bx, ds:memhi
		mov	ax, ds:area
		mov	ds:old_area, ax
		mov	es, ax
		sub	bx, ax
		mov	ah, 4Ah
		int	21h		; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
					; ES = segment address of block	to change
					; BX = new size	in paragraphs
		push	es
		mov	ax, es
		dec	ax
		mov	es, ax
		mov	es:SYSINIT$+1, 8
		mov	word ptr es:stacks, 'DS'
		pop	es
		mov	bx, 0FFFFh
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		mov	ds:memhi, ax
		mov	ds:memlo, 0
		mov	es, ax
		assume es:nothing
		mov	bx, ds:top_of_cdss
		sub	bx, ax
		dec	bx
		dec	bx
		mov	ah, 4Ah
		int	21h		; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
					; ES = segment address of block	to change
					; BX = new size	in paragraphs
		mov	bx, 0FFFFh
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		mov	ds:area, ax
		mov	es, ds:memhi
		assume es:nothing
		mov	ah, 49h
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		retn

; =============== S U B	R O U T	I N E =======================================


do_install_exec	proc near		; ...
		push	si
		push	es
		push	ds
		pop	es
		pop	ds
		mov	dx, si
		xor	cx, cx
		cld
		mov	cs:ldexec_start, ' ' ; 20h
		mov	di, offset ldexec_parm

installfilename:			; ...
		lodsb
		cmp	al, 0
		jz	short got_installparm
		jmp	short installfilename
; ---------------------------------------------------------------------------

got_installparm:			; ...
		lodsb
		mov	es:[di], al
		cmp	al, 0Ah		; LF
		jz	short done_installparm
		inc	cl
		inc	di
		jmp	short got_installparm
; ---------------------------------------------------------------------------

done_installparm:			; ...
		mov	cs:ldexec_line,	cl
		cmp	cl, 0
		jnz	short install_seg_set
		mov	cs:ldexec_start, 0Dh ; CR

install_seg_set:			; ...
		mov	cs:SYSINIT$, 0	; mov word [cs:0],0
		mov	ax, cs
		mov	cs:instexe, ax	; iexec.environ
		mov	cs:iexec_ldexec_line_seg, ax ; iexec.ldexec_line+2
		mov	cs:iexec_ldexec_5c_fcb_seg, ax ; iexec.ldexec_5c_fcb+2
		mov	cs:iexec_ldexec_6c_fcb_seg, ax ; iexec.ldexec_6c_fcb+2
		call	sum_up
		mov	es:checksum, ax
		xor	ax, ax
		mov	ah, 4Bh
		mov	bx, offset instexe
		push	es
		push	ds
		jmp	cs:sysinit_base_ptr
do_install_exec	endp

; ---------------------------------------------------------------------------

sysinitptr:				; ...
		pop	si
		push	es
		push	ds
		pop	es
		pop	ds
		jnb	short install_exit_ret
		push	si
		call	badload
		pop	si
		jmp	short sysinitptr_retn
; ---------------------------------------------------------------------------

install_exit_ret:			; ...
		mov	ah, 4Dh
		int	21h		; DOS -	2+ - GET EXIT CODE OF SUBPROGRAM (WAIT)
		cmp	ah, 3
		jz	short sysinitptr_retn
		call	error_line
		stc

sysinitptr_retn:			; ...
		retn

; =============== S U B	R O U T	I N E =======================================


ParaRound	proc near		; ...
		add	ax, 15
		rcr	ax, 1
		shr	ax, 1
		shr	ax, 1
		shr	ax, 1
		retn
ParaRound	endp

; ---------------------------------------------------------------------------

sysinit_base:				; ...
		mov	word ptr cs:loc_60+1, ss ; sysinit_base_ss = 61
		mov	word ptr cs:byte_62+1, sp ; sysinit_base_sp = 63
		int	21h		; DOS -	PROGRAM	TERMINATION
		mov	ss, word ptr cs:loc_60+1
		mov	sp, word ptr cs:byte_62+1
		pop	ds
		pop	es
		jb	short sysinit_base_end
		call	sum_up
		cmp	es:checksum, ax
		jz	short sysinit_base_end
		mov	ah, 9
		push	cs
		pop	ds
		mov	dx, 65h		; mem_alloc_err_msgx-sysinit_base
		int	21h		; DOS -	PRINT STRING
					; DS:DX	-> string terminated by	"$"

_stall:					; ...
		jmp	short _stall
; ---------------------------------------------------------------------------

sysinit_base_end:			; ...
		jmp	es:sysinit_ptr

; =============== S U B	R O U T	I N E =======================================


sum_up		proc near		; ...
		push	ds
		mov	ax, es:top_of_cdss
		mov	ds, ax
		xor	si, si
		xor	ax, ax
		mov	cx, es:config_size
		shr	cx, 1
		jz	short sum_sys_code

sum1:					; ...
		add	ax, [si]
		inc	si
		inc	si
		loop	sum1

sum_sys_code:				; ...
		mov	si, 5A6h	; locstack
					; starting after the stack
		mov	cx, 3D20h	; SI_end
					; is the label at the end of sysinit
		sub	cx, si
		shr	cx, 1

sum2:					; ...
		add	ax, es:[si]
		inc	si
		inc	si
		loop	sum2
		pop	ds
		retn
sum_up		endp

; ---------------------------------------------------------------------------
_sysinit_base_ss dw 0			; sysinit_base_ss equ $-sysinit_base
_sysinit_base_sp dw 0			; sysinit_base_sp equ $-sysinit_base
mem_alloc_err_msgx db 0Dh,0Ah
		db 'Memory allocation error $'

; =============== S U B	R O U T	I N E =======================================


set_buffer	proc near		; ...
		xor	dl, dl
		call	GetBufferAddr
		jz	short set_buff_1
		mov	dl, 1

set_buff_1:				; ...
		mov	[bx], di	; [bx+BUFFINF.Buff_Queue]
		mov	word ptr [bx+2], es ; [bx+BUFFINF.Buff_Queue+2]
		mov	word ptr [bx+4], 0 ; [bx+BUFFINF.Dirty_Buff_Count]
		mov	ax, di
		mov	cx, cs:buffers
		push	di

nxt_buff:				; ...
		call	set_buffer_info
		mov	di, ax
		loop	nxt_buff
		sub	di, cs:singlebuffersize
		pop	cx
		mov	es:[di], cx	; [es:di+buffinfo.buf_next]
		xchg	cx, di
		mov	es:[di+2], cx	; [es:di+buffinfo.buf_prev]
		or	dl, dl
		jz	short set_buff_2
		mov	byte ptr [bx+12], 1
		mov	ax, cs:memhi
		mov	word ptr [bx+13], 0
		mov	[bx+15], ax
		mov	ax, cs:singlebuffersize
		sub	ax, 20

set_buff_2:				; ...
		add	cs:memlo, ax
		or	cs:setdevmarkflag, 2
		call	round
		retn
set_buffer	endp


; =============== S U B	R O U T	I N E =======================================


GetBufferAddr	proc near		; ...
		push	bx
		push	dx
		mov	ax, cs:singlebuffersize
		mul	cs:buffers
		add	ax, 0Fh
		and	ax, 0FFF0h
		mov	bx, ax
		mov	ax, 4A02h
		int	2Fh
		cmp	di, 0FFFFh
		jnz	short got_hma
		mov	di, 0
		mov	es, cs:memhi

got_hma:				; ...
		pop	dx
		pop	bx
		retn
GetBufferAddr	endp


; =============== S U B	R O U T	I N E =======================================


set_buffer_info	proc near		; ...
		push	cs:buf_prev_off
		pop	word ptr es:[di+2] ; [es:di+buffinfo.buf_prev]
		mov	cs:buf_prev_off, ax
		add	ax, cs:singlebuffersize
		mov	es:[di], ax	; [es:di+buffinfo.buf_next]
		mov	word ptr es:[di+4], 0FFh ; [es:di+buffinfo.buf_ID]
		mov	word ptr es:[di+6], 0 ;	[es:di+buffinfo.buf_sector]
		mov	word ptr es:[di+8], 0 ;	[es:di+buffinfo.buf_sector+2]
		retn
set_buffer_info	endp


; =============== S U B	R O U T	I N E =======================================


stackinit	proc near		; ...
		push	ax
		push	ds
		push	es
		push	bx
		push	cx
		push	dx
		push	di
		push	si
		push	bp
		mov	ax, cs:stack_count
		mov	es:stackcount, ax
		mov	ax, ds:stack_size
		mov	es:stacksize, ax
		mov	ax, word ptr cs:stack_addr
		mov	word ptr es:stacks, ax
		mov	ax, word ptr cs:stack_addr+2
		mov	word ptr es:stacks+2, ax
		mov	bp, word ptr es:stacks
		mov	es:firstentry, bp
		mov	ax, 8
		mov	cx, es:stackcount
		mul	cx
		add	ax, bp
		mov	es:stackat, ax
		mov	bx, ax
		sub	bx, 2
		mov	di, es:stackat
		mov	ax, es:stacksize
		mul	cx
		mov	cx, ax
		xor	ax, ax
		push	es
		pop	ds
		mov	es, word ptr ds:stacks+2
		cld
		rep stosb
		mov	cx, ds:stackcount

buildloop:				; ...
		mov	byte ptr es:[bp+0], 0
		mov	es:[bp+1], al
		mov	es:[bp+2], ax
		mov	es:[bp+4], ax
		add	bx, ds:stacksize
		mov	es:[bp+6], bx
		mov	es:[bx], bp
		add	bp, 8
		loop	buildloop
		sub	bp, 8
		mov	ds:lastentry, bp
		mov	ds:nextentry, bp
		push	ds
		mov	ax, 0F000h
		mov	ds, ax
		assume ds:nothing
		cmp	byte ptr ds:0FFFEh, 0F9h
		pop	ds
		assume ds:nothing
		jnz	short skip_disablenmis
		mov	al, 7
		out	72h, al		; CMOS Memory/RTC Index	Register (Extended RAM)

skip_disablenmis:			; ...
		xor	ax, ax
		mov	es, ax
		cli

stkinit_02:				; 02h*4
		mov	si, 8
		mov	di, 642h	; INT19OLD02
		mov	bx, offset old02
		mov	dx, offset int02
		call	new_init_loop

stkinit_08:				; 08h*4
		mov	si, 32
		mov	di, 647h	; INT19OLD08
		mov	bx, offset old08
		mov	dx, offset int08
		call	new_init_loop

stkinit_09:				; 09h*4
		mov	si, 36
		mov	di, 64Ch	; INT19OLD09
		mov	bx, offset old09
		mov	dx, offset int09
		call	new_init_loop

stkinit_70:				; 70h*4
		mov	si, 448
		mov	di, 66Ah	; INT19OLD70
		mov	bx, offset old70
		mov	dx, offset int70
		call	new_init_loop

stkinit_0A:				; 0Ah*4
		mov	si, 40
		push	ds
		lds	bx, es:[si]
		push	ds
		pop	dx
		cmp	dx, 0
		jz	short int_0A_first
		cmp	byte ptr [bx], 0CFh
		jz	short int_0A_first
		cmp	word ptr [bx+6], 424Bh
		jz	short int_0A_not_first
		cmp	dx, 0F000h
		jnz	short int_0A_not_first
		push	es
		push	dx
		mov	dx, 0F000h
		mov	es, dx
		assume es:nothing
		cmp	bx, es:0FF01h
		pop	dx
		pop	es
		assume es:nothing
		jz	short int_0A_first

int_0A_not_first:			; ...
		pop	ds
		mov	di, 651h	; INT19OLD0A
		mov	bx, offset old0A
		mov	dx, offset int0A
		call	new_init_loop
		jmp	short int_0A_end
; ---------------------------------------------------------------------------

int_0A_first:				; ...
		pop	ds

int_0A_end:				; ...
		mov	si, 44		; 0Bh*4
		push	ds
		lds	bx, es:[si]
		push	ds
		pop	dx
		cmp	dx, 0
		jz	short int_0B_first
		cmp	byte ptr [bx], 0CFh
		jz	short int_0B_first
		cmp	word ptr [bx+6], 424Bh
		jz	short int_0B_not_first
		cmp	dx, 0F000h
		jnz	short int_0B_not_first
		push	es
		push	dx
		mov	dx, 0F000h
		mov	es, dx
		assume es:nothing
		cmp	bx, es:0FF01h
		pop	dx
		pop	es
		assume es:nothing
		jz	short int_0B_first

int_0B_not_first:			; ...
		pop	ds
		mov	di, 656h	; INT19OLD0B
		mov	bx, 71h	; 'q'
		mov	dx, 6Fh	; 'o'
		call	new_init_loop
		jmp	short int_0B_end
; ---------------------------------------------------------------------------

int_0B_first:				; ...
		pop	ds

int_0B_end:				; ...
		mov	si, 48		; 0Ch*4
		push	ds
		lds	bx, es:[si]
		push	ds
		pop	dx
		cmp	dx, 0
		jz	short int_0C_first
		cmp	byte ptr [bx], 0CFh
		jz	short int_0C_first
		cmp	word ptr [bx+6], 424Bh
		jz	short int_0C_not_first
		cmp	dx, 0F000h
		jnz	short int_0C_not_first
		push	es
		push	dx
		mov	dx, 0F000h
		mov	es, dx
		assume es:nothing
		cmp	bx, es:0FF01h
		pop	dx
		pop	es
		assume es:nothing
		jz	short int_0C_first

int_0C_not_first:			; ...
		pop	ds
		mov	di, 65Bh	; INT19OLD0C
		mov	bx, offset old0C
		mov	dx, offset int0C
		call	new_init_loop
		jmp	short int_0C_end
; ---------------------------------------------------------------------------

int_0C_first:				; ...
		pop	ds

int_0C_end:				; ...
		mov	si, 52		; 0Dh*4
		push	ds
		lds	bx, es:[si]
		push	ds
		pop	dx
		cmp	dx, 0
		jz	short int_0D_first
		cmp	byte ptr [bx], 0CFh ; 'Ï'
		jz	short int_0D_first
		cmp	word ptr [bx+6], 424Bh
		jz	short int_0D_not_first
		cmp	dx, 0F000h
		jnz	short int_0D_not_first
		push	es
		push	dx
		mov	dx, 0F000h
		mov	es, dx
		assume es:nothing
		cmp	bx, es:0FF01h
		pop	dx
		pop	es
		assume es:nothing
		jz	short int_0D_first

int_0D_not_first:			; ...
		pop	ds
		mov	di, 660h	; INT19OLD0D
		mov	bx, offset old0D
		mov	dx, offset int0D
		call	new_init_loop
		jmp	short int_0D_end
; ---------------------------------------------------------------------------

int_0D_first:				; ...
		pop	ds

int_0D_end:				; ...
		mov	si, 56		; 0Eh*4
		push	ds
		lds	bx, es:[si]
		push	ds
		pop	dx
		cmp	dx, 0
		jz	short int_0E_first
		cmp	byte ptr [bx], 0CFh
		jz	short int_0E_first
		cmp	word ptr [bx+6], 424Bh
		jz	short int_0E_not_first
		cmp	dx, 0F000h
		jnz	short int_0E_not_first
		push	es
		push	dx
		mov	dx, 0F000h
		mov	es, dx
		assume es:nothing
		cmp	bx, es:0FF01h
		pop	dx
		pop	es
		assume es:nothing
		jz	short int_0E_first

int_0E_not_first:			; ...
		pop	ds
		mov	di, 665h	; INT19OLD0E
		mov	bx, offset old0E
		mov	dx, offset int0E
		call	new_init_loop
		jmp	short int_0E_end
; ---------------------------------------------------------------------------

int_0E_first:				; ...
		pop	ds

int_0E_end:				; ...
		mov	si, 456		; 72h*4
		push	ds
		lds	bx, es:[si]
		push	ds
		pop	dx
		cmp	dx, 0
		jz	short int_72_first
		cmp	byte ptr [bx], 0CFh
		jz	short int_72_first
		cmp	word ptr [bx+6], 424Bh
		jz	short int_72_not_first
		cmp	dx, 0F000h
		jnz	short int_72_not_first
		push	es
		push	dx
		mov	dx, 0F000h
		mov	es, dx
		assume es:nothing
		cmp	bx, es:0FF01h
		pop	dx
		pop	es
		assume es:nothing
		jz	short int_72_first

int_72_not_first:			; ...
		pop	ds
		mov	di, 66Fh	; INT19OLD72
		mov	bx, offset old72
		mov	dx, offset int72
		call	new_init_loop
		jmp	short int_72_end
; ---------------------------------------------------------------------------

int_72_first:				; ...
		pop	ds

int_72_end:				; ...
		mov	si, 460		; 73h*4
		push	ds
		lds	bx, es:[si]
		push	ds
		pop	dx
		cmp	dx, 0
		jz	short int_73_first
		cmp	byte ptr [bx], 0CFh
		jz	short int_73_first
		cmp	word ptr [bx+6], 424Bh
		jz	short int_73_not_first
		cmp	dx, 0F000h
		jnz	short int_73_not_first
		push	es
		push	dx
		mov	dx, 0F000h
		mov	es, dx
		assume es:nothing
		cmp	bx, es:0FF01h
		pop	dx
		pop	es
		assume es:nothing
		jz	short int_73_first

int_73_not_first:			; ...
		pop	ds
		mov	di, 674h	; INT19OLD73
		mov	bx, offset old73
		mov	dx, offset int73
		call	new_init_loop
		jmp	short int_73_end
; ---------------------------------------------------------------------------

int_73_first:				; ...
		pop	ds

int_73_end:				; ...
		mov	si, 464		; 74h*4
		push	ds
		lds	bx, es:[si]
		push	ds
		pop	dx
		cmp	dx, 0
		jz	short int_74_first
		cmp	byte ptr [bx], 0CFh
		jz	short int_74_first
		cmp	word ptr [bx+6], 424Bh
		jz	short int_74_not_first
		cmp	dx, 0F000h
		jnz	short int_74_not_first
		push	es
		push	dx
		mov	dx, 0F000h
		mov	es, dx
		assume es:nothing
		cmp	bx, es:0FF01h
		pop	dx
		pop	es
		assume es:nothing
		jz	short int_74_first

int_74_not_first:			; ...
		pop	ds
		mov	di, 679h	; INT19OLD74
		mov	bx, offset old74
		mov	dx, offset int74
		call	new_init_loop
		jmp	short int_74_end
; ---------------------------------------------------------------------------

int_74_first:				; ...
		pop	ds

int_74_end:				; ...
		mov	si, 472		; 76h*4
		push	ds
		lds	bx, es:[si]
		push	ds
		pop	dx
		cmp	dx, 0
		jz	short int_76_first
		cmp	byte ptr [bx], 0CFh
		jz	short int_76_first
		cmp	word ptr [bx+6], 424Bh
		jz	short int_76_not_first
		cmp	dx, 0F000h
		jnz	short int_76_not_first
		push	es
		push	dx
		mov	dx, 0F000h
		mov	es, dx
		assume es:nothing
		cmp	bx, es:0FF01h
		pop	dx
		pop	es
		assume es:nothing
		jz	short int_76_first

int_76_not_first:			; ...
		pop	ds
		mov	di, 67Eh	; INT19OLD76
		mov	bx, offset old76
		mov	dx, offset int76
		call	new_init_loop
		jmp	short int_76_end
; ---------------------------------------------------------------------------

int_76_first:				; ...
		pop	ds

int_76_end:				; ...
		mov	si, 476		; 77h*4
		push	ds
		lds	bx, es:[si]
		push	ds
		pop	dx
		cmp	dx, 0
		jz	short int_77_first
		cmp	byte ptr [bx], 0CFh
		jz	short int_77_first
		cmp	word ptr [bx+6], 424Bh
		jz	short int_77_not_first
		cmp	dx, 0F000h
		jnz	short int_77_not_first
		push	es
		push	dx
		mov	dx, 0F000h
		mov	es, dx
		assume es:nothing
		cmp	bx, es:0FF01h
		pop	dx
		pop	es
		assume es:nothing
		jz	short int_77_first

int_77_not_first:			; ...
		pop	ds
		mov	di, 683h
		mov	bx, 131h
		mov	dx, 12Fh
		call	new_init_loop
		jmp	short int_77_end
; ---------------------------------------------------------------------------

int_77_first:				; ...
		pop	ds

int_77_end:				; ...
		push	ds
		mov	ax, 0F000h
		mov	ds, ax
		assume ds:nothing
		cmp	byte ptr ds:0FFFEh, 0F9h
		pop	ds
		assume ds:nothing
		jnz	short skip_enablenmis
		mov	al, 27h
		out	72h, al		; CMOS Memory/RTC Index	Register (Extended RAM)

skip_enablenmis:			; ...
		sti
		mov	ax, 70h
		mov	ds, ax
		assume ds:nothing
		mov	byte ptr ds:640h, 1
		pop	bp
		pop	si
		pop	di
		pop	dx
		pop	cx
		pop	bx
		pop	es
		pop	ds
		assume ds:nothing
		pop	ax
		retn
stackinit	endp


; =============== S U B	R O U T	I N E =======================================


new_init_loop	proc near		; ...
		mov	ax, es:[si]
		mov	[bx], ax
		mov	ax, es:[si+2]
		mov	[bx+2],	ax
		push	ds
		mov	ax, 70h
		mov	ds, ax
		assume ds:nothing
		mov	ax, es:[si]
		mov	[di], ax
		mov	ax, es:[si+2]
		mov	[di+2],	ax
		pop	ds
		assume ds:nothing
		mov	es:[si], dx
		mov	word ptr es:[si+2], ds
		retn
new_init_loop	endp


; =============== S U B	R O U T	I N E =======================================


setdevmark	proc near		; ...
		push	es
		push	cx
		mov	cx, cs:memhi
		mov	cs:devmark_addr, cx
		mov	es, cx
		mov	byte ptr es:SYSINIT$, al ; [es:0]
		inc	cx
		mov	es:SYSINIT$+1, cx ; [es:1]
		pop	cx
		pop	es
		inc	cs:memhi
		retn
setdevmark	endp

; ---------------------------------------------------------------------------
		db 0
multdeviceflag	db 0			; ...
devmark_addr	dw 0			; ...
setdevmarkflag	db 0			; ...
driver_units	db 0
badparm_ptr	dd 0			; ...
					; SYSPARSE - Local Data
_$P_ORDINAL	dw 0			; ...
_$P_RC		dw 0			; ...
_$P_SI_Save	dw 0			; ...
_$P_DX		dw 0			; ...
_$P_Terminator	db 0			; ...
_$P_DBCSEV_OFF	dw 0			; ...
_$P_DBCSEV_SEG	dw 0			; ...
_$P_Flags	dw 0			; ...
_$P_SaveSI_Cmpx	dw 0			; ...
_$P_KEYorSW_Ptr	dw 0			; ...
_$P_Save_EOB	dw 0			; ...
_$P_Found_SYNONYM dw 0			; ...
_$P_STRING_BUF	db 128 dup(0)		; ...
_$P_Char_CAP_Ptr db 0FFh		; ...
		dw 0
		dw 0
_$P_FileSp_Char	db '[', ']', '|', '<', '>', '+', '=', ';', '"' ; ...
_$P_err_flag	db 0			; ...

; =============== S U B	R O U T	I N E =======================================


SysParse	proc near		; ...
		mov	cs:_$P_Flags, 0
		cld
		mov	cs:_$P_ORDINAL,	cx
		mov	cs:_$P_RC, 0
		mov	cs:_$P_Found_SYNONYM, 0
		mov	cs:_$P_DX, 0
		mov	word ptr cs:_$P_FileSp_Char, ']['
		mov	word ptr cs:_$P_FileSp_Char+2, '<|'
		mov	word ptr cs:_$P_FileSp_Char+4, '+>'
		mov	word ptr cs:_$P_FileSp_Char+6, ';='
		call	_$P_Skip_Delim
		jnb	short _$P_Start
		mov	ax, 0FFFFh
		push	bx
		mov	bx, es:[di]
		cmp	cl, es:[bx]
		jnb	short _$P_Fin
		mov	ax, 2

_$P_Fin:				; ...
		pop	bx
		jmp	_$P_Single_Exit
; ---------------------------------------------------------------------------

_$P_Start:				; ...
		mov	cs:_$P_SaveSI_Cmpx, si
		push	bx
		push	di
		push	bp
		lea	bx, _$P_STRING_BUF
		test	byte ptr cs:_$P_Flags+1, 20h
		jnz	short _$P_Pack_End

_$P_Pack_Loop:				; ...
		lodsb
		call	_$P_Chk_Switch
		jb	short _$P_Pack_End_BY_EOL
		call	_$P_Chk_EOL
		jz	short _$P_Pack_End_BY_EOL
		call	_$P_Chk_Delim
		jnz	short _$P_PL01
		test	byte ptr cs:_$P_Flags+1, 20h
		jnz	short _$P_Pack_End_backup_si
		call	_$P_Skip_Delim
		jmp	short _$P_Pack_End
; ---------------------------------------------------------------------------

_$P_Pack_End_backup_si:			; ...
		test	byte ptr cs:_$P_Flags+1, 41h
		jz	short _$P_Pack_End
		dec	si
		jmp	short _$P_Pack_End
; ---------------------------------------------------------------------------

_$P_PL01:				; ...
		mov	cs:[bx], al
		cmp	al, 3Dh	; '='   ; _$P_Keyword
		jnz	short _$P_PL00
		or	byte ptr cs:_$P_Flags+1, 1

_$P_PL00:				; ...
		inc	bx
		call	_$P_Chk_DBCS
		jnb	short _$P_Pack_Loop
		lodsb
		mov	cs:[bx], al
		inc	bx
		jmp	short _$P_Pack_Loop
; ---------------------------------------------------------------------------

_$P_Pack_End_BY_EOL:			; ...
		dec	si

_$P_Pack_End:				; ...
		mov	cs:_$P_SI_Save,	si
		mov	byte ptr cs:[bx], 0
		mov	cs:_$P_Save_EOB, bx
		mov	bx, es:[di]
		lea	si, _$P_STRING_BUF
		cmp	byte ptr cs:[si], 2Fh ;	'/' ; _$P_Switch
		jz	short _$P_SW_Manager
		cmp	byte ptr cs:[si], 22h ;	'"' ; _$P_DQuote
		jz	short _$P_Positional_Manager
		test	byte ptr cs:_$P_Flags+1, 1
		jnz	short _$P_Key_Manager

_$P_Positional_Manager:			; ...
		mov	al, es:[bx+1]	; [es:bx+_$P_PARMSX_Blk.MaxP]
		xor	ah, ah
		cmp	cs:_$P_ORDINAL,	ax
		jnb	short _$P_Too_Many_Error
		mov	ax, cs:_$P_ORDINAL
		shl	ax, 1
		inc	bx
		inc	bx
		add	bx, ax
		mov	bx, es:[bx]
		call	_$P_Chk_Pos_Control
		jmp	short _$P_Return_to_Caller
; ---------------------------------------------------------------------------

_$P_Too_Many_Error:			; ...
		mov	cs:_$P_RC, 1
		jmp	short _$P_Return_to_Caller
; ---------------------------------------------------------------------------

_$P_SW_Manager:				; ...
		mov	al, es:[bx+1]	; [es:bx+_$P_PARMSX_Blk.MaxP]
		xor	ah, ah
		inc	ax
		shl	ax, 1
		add	bx, ax
		mov	cl, es:[bx]
		xor	ch, ch
		or	cx, cx
		jz	short _$P_SW_Not_Found
		inc	bx

_$P_SW_Mgr_Loop:			; ...
		push	bx
		mov	bx, es:[bx]
		call	_$P_Chk_SW_Control
		pop	bx
		jnb	short _$P_Return_to_Caller
		inc	bx
		inc	bx
		loop	_$P_SW_Mgr_Loop

_$P_SW_Not_Found:			; ...
		mov	cs:_$P_RC, 3
		jmp	short _$P_Return_to_Caller
; ---------------------------------------------------------------------------

_$P_Key_Manager:			; ...
		mov	al, es:[bx+1]
		xor	ah, ah
		inc	ax
		shl	ax, 1
		add	bx, ax
		mov	al, es:[bx]
		xor	ah, ah
		shl	ax, 1
		inc	ax
		add	bx, ax
		mov	cl, es:[bx]
		xor	ch, ch
		or	cx, cx
		jz	short _$P_Key_Not_Found
		inc	bx

_$P_Key_Mgr_Loop:			; ...
		push	bx
		mov	bx, es:[bx]
		call	_$P_Chk_Key_Control
		pop	bx
		jnb	short _$P_Return_to_Caller
		inc	bx
		inc	bx
		loop	_$P_Key_Mgr_Loop

_$P_Key_Not_Found:			; ...
		mov	cs:_$P_RC, 4

_$P_Return_to_Caller:			; ...
		pop	bp
		pop	di
		pop	bx
		mov	cx, cs:_$P_ORDINAL
		mov	ax, cs:_$P_RC
		mov	si, cs:_$P_SI_Save
		mov	dx, cs:_$P_DX
		mov	bl, cs:_$P_Terminator

_$P_Single_Exit:			; ...
		clc
		retn
SysParse	endp


; =============== S U B	R O U T	I N E =======================================


_$P_Chk_Pos_Control proc near		; ...
		push	ax
		mov	ax, es:[bx]
		test	ax, 2
		jnz	short _$P_CPC00
		inc	cs:_$P_ORDINAL

_$P_CPC00:				; ...
		cmp	byte ptr cs:[si], 0
		jnz	short _$P_CPC01
		test	ax, 1
		jnz	short _$P_CPC02
		mov	cs:_$P_RC, 2
		jmp	short _$P_CPC_Exit
; ---------------------------------------------------------------------------

_$P_CPC02:				; ...
		push	ax
		mov	al, 3
		mov	ah, 0FFh
		call	_$P_Fill_Result
		pop	ax
		jmp	short _$P_CPC_Exit
; ---------------------------------------------------------------------------

_$P_CPC01:				; ...
		call	_$P_Check_Match_Flags

_$P_CPC_Exit:				; ...
		pop	ax
		retn
_$P_Chk_Pos_Control endp


; =============== S U B	R O U T	I N E =======================================


_$P_Chk_Key_Control proc near		; ...
		stc
		retn
_$P_Chk_Key_Control endp


; =============== S U B	R O U T	I N E =======================================


_$P_Search_KEYorSW proc	near		; ...
		push	bp
		push	cx
		mov	cl, es:[bx+8]	; [es:bx+_$P_Control_Blk.nid]
		xor	ch, ch
		or	cx, cx
		jz	short _$P_KEYorSW_Not_Found
		lea	bp, [bx+9]	; [es:bx+_$P_Control_Blk.KEYorSW]

_$P_KEYorSW_Loop:			; ...
		call	_$P_String_Comp
		jnb	short _$P_KEYorSW_Found
		call	_$P_MoveBP_NUL
		loop	_$P_KEYorSW_Loop

_$P_KEYorSW_Not_Found:			; ...
		stc
		jmp	short _$P_KEYorSW_Exit
; ---------------------------------------------------------------------------

_$P_KEYorSW_Found:			; ...
		mov	cs:_$P_Found_SYNONYM, bp
		clc

_$P_KEYorSW_Exit:			; ...
		pop	cx
		pop	bp
		retn
_$P_Search_KEYorSW endp


; =============== S U B	R O U T	I N E =======================================


_$P_MoveBP_NUL	proc near		; ...
		cmp	byte ptr es:[bp+0], 0
		jz	short _$P_MBP_Exit
		inc	bp
		jmp	short _$P_MoveBP_NUL ; _$P_MBP_Loop
; ---------------------------------------------------------------------------

_$P_MBP_Exit:				; ...
		inc	bp
		retn
_$P_MoveBP_NUL	endp


; =============== S U B	R O U T	I N E =======================================


_$P_Chk_SW_Control proc	near		; ...
		or	byte ptr cs:_$P_Flags+1, 10h
		call	_$P_Search_KEYorSW
		jb	short _$P_Chk_SW_Err0
		and	byte ptr cs:_$P_Flags+1, 0EFh
		push	ax
		mov	ax, cs:_$P_KEYorSW_Ptr
		sub	ax, si
		add	cs:_$P_SaveSI_Cmpx, ax
		pop	ax
		mov	si, cs:_$P_KEYorSW_Ptr
		cmp	byte ptr cs:[si], 0
		jnz	short _$P_CSW00
		cmp	byte ptr cs:[si-1], 3Ah	; ':'
		jnz	short _$P_Chk_if_data_required
		mov	cs:_$P_RC, 9
		jmp	short _$P_Chk_SW_Exit
; ---------------------------------------------------------------------------

_$P_Chk_if_data_required:		; ...
		cmp	word ptr es:[bx], 0
		jz	short _$P_Chk_SW_Exit
		test	word ptr es:[bx], 1
		jnz	short _$P_Chk_SW_Exit
		mov	cs:_$P_RC, 2
		jmp	short _$P_Chk_SW_Exit
; ---------------------------------------------------------------------------

_$P_CSW00:				; ...
		call	_$P_Check_Match_Flags
		clc
		jmp	short _$P_Chk_SW_Single_Exit
; ---------------------------------------------------------------------------

_$P_Chk_SW_Err0:			; ...
		stc
		jmp	short _$P_Chk_SW_Single_Exit
; ---------------------------------------------------------------------------

_$P_Chk_SW_Exit:			; ...
		push	ax
		mov	al, 3
		mov	ah, 0FFh
		call	_$P_Fill_Result
		pop	ax
		clc

_$P_Chk_SW_Single_Exit:			; ...
		retn
_$P_Chk_SW_Control endp


; =============== S U B	R O U T	I N E =======================================


_$P_Fill_Result	proc near		; ...
		push	di
		mov	di, es:[bx+4]	; [es:bx+_$P_Control_Blk.Result_Buf]
		mov	cs:_$P_DX, di
		mov	es:[di], al	; es:di+_$P_Result_Blk.Type]
		mov	es:[di+1], ah	; [es:di+_$P_Result_Blk.Item_Tag]
		push	ax
		mov	ax, cs:_$P_Found_SYNONYM
		mov	es:[di+2], ax	; [es:di+_$P_Result_Blk.SYNONYM_Ptr]
		pop	ax

_$P_RLT04:				; _$P_Number
		cmp	al, 1
		jnz	short _$P_RLT00

_$P_RLT02:				; ...
		mov	es:[di+4], dx	; [es:di+_$P_Result_Blk.Picked_Val]
		mov	es:[di+6], cx	; [es:di+_$P_Result_Blk.Picked_Val+2]
		jmp	short _$P_RLT_Exit
; ---------------------------------------------------------------------------

_$P_RLT00:				; ...
		cmp	al, 2		; _$P_List_Idx
		jnz	short _$P_RLT01
		mov	es:[di+4], dx
		jmp	short _$P_RLT_Exit
; ---------------------------------------------------------------------------

_$P_RLT01:				; ...
		cmp	al, 7		; _$P_Date_F
		jz	short _$P_RLT02
		cmp	al, 8		; _$P_Time_F
		jz	short _$P_RLT02
		cmp	al, 6		; _$P_Drive
		jnz	short _$P_RLT03
		mov	es:[di+4], dl	; [es:di+_$P_Result_Blk.Picked_Val]
		jmp	short _$P_RLT_Exit
; ---------------------------------------------------------------------------

_$P_RLT03:				; ...
		cmp	al, 4		; _$P_Complex
		jnz	short _$P_RLT05
		mov	ax, cs:_$P_SaveSI_Cmpx
		inc	ax
		mov	es:[di+4], ax
		mov	word ptr es:[di+6], ds
		jmp	short _$P_RLT_Exit
; ---------------------------------------------------------------------------

_$P_RLT05:				; ...
		mov	es:[di+4], si	; [es:di+_$P_Result_Blk.Picked_Val]
		mov	word ptr es:[di+6], cs ; [es:di+_$P_Result_Blk.Picked_Val+2]
		push	ax
		test	byte ptr es:[bx+2], 1 ;	[es:bx+_$P_Control_Blk.Function_Flag]
		jz	short _$P_RLT_CAP00
		mov	al, 4		; _$P_DOSTBL_File
		jmp	short _$P_RLT_CAP02
; ---------------------------------------------------------------------------

_$P_RLT_CAP00:				; ...
		test	byte ptr es:[bx+2], 2 ;	[es:bx+_$P_Control_Blk.Function_Flag]
		jz	short $P_RLT_CAP01
		mov	al, 2		; _$P_DOSTBL_Char

_$P_RLT_CAP02:				; ...
		call	_$P_Do_CAPS_String

$P_RLT_CAP01:				; ...
		pop	ax
		test	byte ptr es:[bx+2], 10h	; [es:bx+_$P_Control_Blk.Function_Flag]
		jz	short _$P_RLT_Exit
		call	_$P_Remove_Colon

_$P_RLT_Exit:				; ...
		pop	di
		retn
_$P_Fill_Result	endp


; =============== S U B	R O U T	I N E =======================================


_$P_Check_Match_Flags proc near		; ...
		mov	cs:_$P_err_flag, 0 ; _$P_NULL
		push	ax
		mov	ax, es:[bx]	; [es:bx+_$P_Control_Blk.Match_Flag]
		or	ax, ax
		jnz	short _$P_Mat
		push	ax
		push	bx
		push	dx
		push	di
		mov	cs:_$P_RC, 9	; _$P_Syntax
		mov	ah, 0FFh	; _$P_No_Tag
		mov	al, 3		; _$P_String
		call	_$P_Fill_Result
		pop	di
		pop	dx
		pop	bx
		pop	ax
		jmp	short _$P_Bridge
; ---------------------------------------------------------------------------

_$P_Mat:				; ...
		jmp	short _$P_Match03
; ---------------------------------------------------------------------------

_$P_Bridge:				; ...
		jmp	short _$P_Match_Exit
; ---------------------------------------------------------------------------
		db  90h	; 
; ---------------------------------------------------------------------------

_$P_Match03:				; ...
		test	ax, 8000h	; _$P_Num_Val
		jz	short _$P_Match04
		mov	cs:_$P_RC, 0	; _$P_No_Error
		call	_$P_Value
		cmp	cs:_$P_RC, 9	; _$P_Syntax
		jnz	short _$P_Match_Exit

_$P_Match04:				; ...
		test	ax, 4000h	; _$P_SNum_Val
		jz	short _$P_Match05
		mov	cs:_$P_RC, 0
		call	_$P_SValue
		cmp	cs:_$P_RC, 9
		jnz	short _$P_Match_Exit

_$P_Match05:				; ...
		test	ax, 100h	; _$P_Drv_Only
		jz	short _$P_Match06
		mov	cs:_$P_RC, 0
		call	_$P_File_Format
		call	_$P_Drive_Format
		cmp	cs:_$P_RC, 9
		jnz	short _$P_Match_Exit

_$P_Match06:				; ...
		test	ax, 200h	; _$P_File_Spc
		jz	short _$P_Match07
		mov	cs:_$P_RC, 0
		call	_$P_File_Format
		cmp	cs:_$P_RC, 9
		jnz	short _$P_Match_Exit

_$P_Match07:				; ...
		test	ax, 2000h	; _$P_Simple_S
		jz	short _$P_Match_Exit
		mov	cs:_$P_RC, 0
		call	_$P_Simple_String

_$P_Match_Exit:				; ...
		cmp	cs:_$P_err_flag, 1 ; _$P_error_filespec
		jnz	short _$P_Match2_Exit
		cmp	cs:_$P_RC, 0
		jnz	short _$P_Match2_Exit
		mov	cs:_$P_RC, 9

_$P_Match2_Exit:			; ...
		pop	ax
		retn
_$P_Check_Match_Flags endp


; =============== S U B	R O U T	I N E =======================================


_$P_Remove_Colon proc near		; ...
		push	ax
		push	si

_$P_RCOL_Loop:				; ...
		mov	al, cs:[si]
		or	al, al
		jz	short _$P_RCOL_Exit
		cmp	al, 3Ah	; ':'   ; _$P_Colon
		jnz	short _$P_RCOL00
		cmp	byte ptr cs:[si+1], 0 ;	_$P_NULL
		jnz	short _$P_RCOL00
		mov	byte ptr cs:[si], 0
		jmp	short _$P_RCOL_Exit
; ---------------------------------------------------------------------------

_$P_RCOL00:				; ...
		call	_$P_Chk_DBCS
		jnb	short _$P_RCOL01
		inc	si

_$P_RCOL01:				; ...
		inc	si
		jmp	short _$P_RCOL_Loop
; ---------------------------------------------------------------------------

_$P_RCOL_Exit:				; ...
		pop	si
		pop	ax
		retn
_$P_Remove_Colon endp


; =============== S U B	R O U T	I N E =======================================


_$P_Do_CAPS_String proc	near		; ...
		push	si
		push	dx
		mov	dl, al

_$P_DCS_Loop:				; ...
		mov	al, cs:[si]
		call	_$P_Chk_DBCS
		jb	short _$P_DCS00
		or	al, al
		jz	short _$P_DCS_Exit
		call	_$P_Do_CAPS_Char
		mov	cs:[si], al
		jmp	short _$P_DCS01
; ---------------------------------------------------------------------------

_$P_DCS00:				; ...
		inc	si

_$P_DCS01:				; ...
		inc	si
		jmp	short _$P_DCS_Loop
; ---------------------------------------------------------------------------

_$P_DCS_Exit:				; ...
		pop	dx
		pop	si
		retn
_$P_Do_CAPS_String endp


; =============== S U B	R O U T	I N E =======================================


_$P_Do_CAPS_Char proc near		; ...
		cmp	al, 80h		; _$P_ASCII80
		jnb	short _$P_DCC_Go
		cmp	al, 'a'
		jb	short _$P_CAPS_Ret
		cmp	al, 'z'
		ja	short _$P_CAPS_Ret
		and	al, 0DFh	; _$P_Make_Upper
		jmp	short _$P_CAPS_Ret
; ---------------------------------------------------------------------------

_$P_DCC_Go:				; ...
		push	bx
		push	es
		push	di
		lea	di, _$P_Char_CAP_Ptr
		cmp	cs:[di], dl
		jz	short _$P_DCC01
		push	ax
		push	cx
		push	dx
		push	cs
		pop	es
		mov	ah, 65h		; _$P_DOS_Get_TBL
		mov	al, dl
		mov	bx, 0FFFFh	; _$P_DOSTBL_Def
		mov	cx, 5		; _$P_DOSTBL_BL
		mov	dx, 0FFFFh
		int	21h		; DOS -	4.x internal - COUNTRY-DEPENDENT FILENAME CAPITALIZATION
					; AL = function	-
		pop	dx
		pop	cx
		pop	ax

_$P_DCC01:				; ...
		mov	bx, cs:[di+1]	; [cs:di+_$P_DOS_TBL.Off]
		mov	es, word ptr cs:[di+3] ; [cs:di+_$P_DOS_TBL.Seg]
		inc	bx
		inc	bx
		sub	al, 80h		; _$P_ASCII80
		xlat	byte ptr es:[bx]
		pop	di
		pop	es
		pop	bx

_$P_CAPS_Ret:				; ...
		retn
_$P_Do_CAPS_Char endp


; =============== S U B	R O U T	I N E =======================================


_$P_SValue	proc near		; ...
		push	ax
		or	byte ptr cs:_$P_Flags+1, 80h ; _$P_Signed
		and	byte ptr cs:_$P_Flags+1, 0FDh ;	0FFh-_$P_Neg
		mov	al, cs:[si]
		cmp	al, '+'         ; _$P_Plus
		jz	short _$P_SVal00
		cmp	al, '-'         ; _$P_Minus
		jnz	short _$P_Sval01
		or	byte ptr cs:_$P_Flags+1, 2 ; [cs:_$P_Flags2],
					; _$P_Neg

_$P_SVal00:				; ...
		inc	si

_$P_Sval01:				; ...
		call	_$P_Value
		pop	ax
		retn
_$P_SValue	endp


; =============== S U B	R O U T	I N E =======================================


_$P_Value	proc near		; ...
		push	ax
		push	cx
		push	dx
		push	si
		xor	cx, cx		;  cx =	higher 16 bits
		xor	dx, dx		; dx = lower 16	bits
		push	bx

_$P_Value_Loop:				; ...
		mov	al, cs:[si]	; get (numeric)	character
		or	al, al		; end of line ?
		jz	short _$P_Value00
		call	_$P_0099	; make asc(0..9) to bin(0..9)
		jb	short _$P_Value_Err0
		xor	ah, ah
		mov	bp, ax		; save binary number
		shl	dx, 1		; 2*x
		rcl	cx, 1
		call	_$P_Check_OVF	; Overflow occurred ?
		jb	short _$P_Value_Err0 ; then error, exit
		mov	bx, dx
		mov	ax, cx
		shl	dx, 1		; 4*x
		rcl	cx, 1
		call	_$P_Check_OVF
		jb	short _$P_Value_Err0
		shl	dx, 1		; 8*x
		rcl	cx, 1
		call	_$P_Check_OVF
		jb	short _$P_Value_Err0
		add	dx, bx		; 10*x
		adc	cx, ax
		call	_$P_Check_OVF
		jb	short _$P_Value_Err0
		add	dx, bp		; Add the current one degree decimal
		adc	cx, 0
		call	_$P_Check_OVF
		jb	short _$P_Value_Err0
		inc	si
		jmp	short _$P_Value_Loop
; ---------------------------------------------------------------------------

_$P_Value_Err0:				; ...
		pop	bx
		jmp	_$P_Value_Err
; ---------------------------------------------------------------------------

_$P_Value00:				; ...
		pop	bx
		test	byte ptr cs:_$P_Flags+1, 2 ; _$P_Neg
		jz	short _$P_Value01 ; was	it negative ?
		not	cx		; Make 2's complement
		not	dx
		add	dx, 1
		adc	cx, 0

_$P_Value01:				; ...
		mov	si, es:[bx+6]	; [es:bx+_$P_Control_Blk.Value_List]
		mov	al, es:[si]
		cmp	al, 0		; _$P_nval_None
		jnz	short _$P_Value02
		mov	al, 1		; _$P_Number
		mov	ah, 0FFh	; _$P_No_Tag
		jmp	short _$P_Value_Exit
; ---------------------------------------------------------------------------
		nop

_$P_Value02:				; ...
		inc	si
		mov	al, es:[si]
		cmp	al, 0		; _$P_No_nrng
		jz	short _$P_Value_Err
		inc	si

_$P_Val02_Loop:				; ...
		test	byte ptr cs:_$P_Flags+1, 80h ; _$P_Signed
		jnz	short _$P_Val02_Sign
		cmp	cx, es:[si+3]	; [es:si+_$P_Val_List.Val_XH]
		jb	short _$P_Val02_Next
		ja	short _$P_Val_In
		cmp	dx, es:[si+1]	; [es:si+_$P_Val_List.Val_XL]
		jb	short _$P_Val02_Next

_$P_Val_In:				; ...
		cmp	cx, es:[si+7]	; [es:si+_$P_Val_List.Val_YH]
		ja	short _$P_Val02_Next
		jb	short _$P_Val_Found
		cmp	dx, es:[si+5]	; [es:si+_$P_Val_List.Val_YL]
		ja	short _$P_Val02_Next
		jmp	short _$P_Val_Found
; ---------------------------------------------------------------------------

_$P_Val02_Sign:				; ...
		cmp	cx, es:[si+3]	; [es:si+_$P_Val_List.Val_XH]
		jl	short _$P_Val02_Next
		jg	short _$P_SVal_In
		cmp	dx, es:[si+1]	; [es:si+_$P_Val_List.Val_XL]
		jl	short _$P_Val02_Next

_$P_SVal_In:				; ...
		cmp	cx, es:[si+7]	; [es:si+_$P_Val_List.Val_YH]
		jg	short _$P_Val02_Next
		jl	short _$P_Val_Found
		cmp	dx, es:[si+5]	; [es:si+_$P_Val_List.Val_YL]
		jg	short _$P_Val02_Next
		jmp	short _$P_Val_Found
; ---------------------------------------------------------------------------

_$P_Val02_Next:				; ...
		add	si, 9		; _$P_Len_Range
		dec	al
		jnz	short _$P_Val02_Loop
		mov	cs:_$P_RC, 6	; _$P_Out_Of_Range
		mov	al, 1		; _$P_Number
		mov	ah, 0FFh	; _$P_No_Tag
		jmp	short _$P_Value_Exit
; ---------------------------------------------------------------------------

_$P_Val_Found:				; ...
		mov	al, 1		; _$P_Number
		mov	ah, es:[si]	; found	ITEM_TAG set
		jmp	short _$P_Value_Exit
; ---------------------------------------------------------------------------

_$P_Value_Err:				; ...
		mov	cs:_$P_RC, 9	; _$P_Syntax
		mov	al, 3		; _$P_String
		mov	ah, 0FFh	; _$P_No_Tag

_$P_Value_Exit:				; ...
		call	_$P_Fill_Result
		pop	si
		pop	dx
		pop	cx
		pop	ax
		retn
_$P_Value	endp


; =============== S U B	R O U T	I N E =======================================


_$P_Check_OVF	proc near		; ...
		pushf
		test	byte ptr cs:_$P_Flags+1, 2 ; [cs:_$P_Flags2],
					; _$P_Neg
		jnz	short _$P_COVF
		popf
		retn
; ---------------------------------------------------------------------------

_$P_COVF:				; ...
		popf
		jo	short _$P_COVF00
		clc
		retn
; ---------------------------------------------------------------------------

_$P_COVF00:				; ...
		stc
		retn
_$P_Check_OVF	endp


; =============== S U B	R O U T	I N E =======================================


_$P_0099	proc near		; ...
		cmp	al, '0'
		jb	short _$P_0099Err
		cmp	al, '9'
		ja	short _$P_0099Err
		sub	al, '0'
		clc
		retn
; ---------------------------------------------------------------------------

_$P_0099Err:				; ...
		stc
		retn
_$P_0099	endp


; =============== S U B	R O U T	I N E =======================================


_$P_Simple_String proc near		; ...
		push	ax
		push	bx
		push	dx
		push	di
		mov	di, es:[bx+6]	; [es:bx+_$P_Control_Blk.Value_List]
		mov	al, es:[di]	; get nval
		or	al, al		; no value list	?
		jnz	short _$P_Sim00	; then
		mov	ah, 0FFh	; _$P_No_Tag
		jmp	short _$P_Sim_Exit
; ---------------------------------------------------------------------------

_$P_Sim00:				; ...
		cmp	al, 3		; _$P_nval_String
		jnz	short _$P_Sim01	; syntax error
		inc	di
		mov	al, es:[di]	; al = nrng
		mov	ah, 9		; _$P_Len_Range
		mul	ah
		inc	ax		; ax = (nrng*9)+1
		add	di, ax
		mov	al, es:[di]	; get nnval
		mov	ah, 5		; _$P_Len_Value
		mul	ah
		inc	ax
		add	di, ax		; di points to nstrval
		mov	al, es:[di]	; get nstrval c
		inc	di
		inc	di		; di points to 1st string in list

_$P_Sim_Loop:				; ...
		mov	bp, es:[di]	; get string pointer
		call	_$P_String_Comp
		jnb	short _$P_Sim_Found
		add	di, 3		; _$P_Len_String
		dec	al
		jnz	short _$P_Sim_Loop
		mov	cs:_$P_RC, 8	; _$P_Not_In_Str
		mov	ah, 0FFh	; No ITEM_TAG set
		jmp	short _$P_Sim_Exit
; ---------------------------------------------------------------------------

_$P_Sim_Found:				; ...
		mov	ah, es:[di-1]	; set item_tag
		mov	al, 2		; _$P_List_Idx
		mov	dx, es:[di]	; get address of STRING
		jmp	short _$P_Sim_Exit0
; ---------------------------------------------------------------------------

_$P_Sim01:				; ...
		mov	cs:_$P_RC, 9	; _$P_Syntax
		mov	ah, 0FFh	; _$P_No_Tag

_$P_Sim_Exit:				; ...
		mov	al, 3		; _$P_String

_$P_Sim_Exit0:				; ...
		call	_$P_Fill_Result
		pop	di
		pop	dx
		pop	bx
		pop	ax
		retn
_$P_Simple_String endp


; =============== S U B	R O U T	I N E =======================================


_$P_String_Comp	proc near		; ...

arg_1AC4	= word ptr  1AC6h

		push	ax
		push	bp
		push	dx
		push	si
		mov	dl, 2		; $P_DOSTBL_Char
					; (use character case map table)

_$P_SCOM_Loop:				; ...
		mov	al, cs:[si]	; get command character
		call	_$P_Chk_DBCS
		jb	short _$P_SCOM00
		call	_$P_Do_CAPS_Char
		test	byte ptr cs:_$P_Flags+1, 8 ; _$P_Key_Cmp
					; (keyword search ?)
		jz	short _$P_SCOM04
		cmp	al, '='         ; _$P_Keyword
					; ("=" is delimiter)
		jnz	short _$P_SCOM03
		cmp	byte ptr es:[bp+1], 0 ;	_$P_NULL
		jnz	short _$P_SCOM_Differ
		jmp	short _$P_SCOM05 ; (keyword found in synonym list)
; ---------------------------------------------------------------------------

_$P_SCOM04:				; ...
		test	byte ptr cs:_$P_Flags+1, 10h ; _$P_SW_Cmp
					; (switch search ?)
		jz	short _$P_SCOM03
		cmp	al, ':'         ; _$P_Colon
					; (/:" is delimiter, at	end of switch on command line)
		jnz	short _$P_SCOM03
		cmp	byte ptr es:[bp+0], 0 ;	_$P_NULL
		jnz	short _$P_SCOM_Differ

_$P_SCOM05:				; ...
		inc	si
		jmp	short _$P_SCOM_Same
; ---------------------------------------------------------------------------

_$P_SCOM03:				; ...
		cmp	al, es:[bp+0]
		jnz	short _$P_SCOM_Differ0
		or	al, al
		jz	short _$P_SCOM_Same
		inc	si
		inc	bp
		jmp	short _$P_SCOM01
; ---------------------------------------------------------------------------

_$P_SCOM00:				; ...
		cmp	al, es:[bp+0]
		jnz	short _$P_SCOM_Differ
		inc	si
		mov	al, cs:[si]
		inc	bp
		cmp	al, es:[bp+0]
		jnz	short _$P_SCOM_Differ
		inc	si
		inc	bp

_$P_SCOM01:				; ...
		jmp	short _$P_SCOM_Loop
; ---------------------------------------------------------------------------

_$P_SCOM_Differ0:			; ...
		test	byte ptr cs:_$P_Flags+1, 40h ; [cs:_$P_Flags2],
					; _$P_SW
		jz	short _$P_not_applicable
		test	word ptr es:[bx+2], 20h	; [es:bx+_$P_Control_Blk.Function_Flag],
					; _$P_colon_is_not_necessary
		jz	short _$P_not_applicable
		cmp	byte ptr es:[bp+0], 0 ;	_$P_NULL
		jz	short _$P_SCOM_Same

_$P_not_applicable:			; ...
		test	word ptr es:[bx], 10h ;	_$P_Ig_Colon
		jz	short _$P_SCOM_Differ
		cmp	al, ':'         ; _$P_Colon
		jnz	short _$P_SCOM02
		cmp	byte ptr es:[bp+0], 0 ;	_$P_NULL
		jnz	short _$P_SCOM_Differ
		jmp	short _$P_SCOM_Same
; ---------------------------------------------------------------------------

_$P_SCOM02:				; ...
		cmp	al, 0		; _$P_NULL
		jnz	short _$P_SCOM_Differ
		cmp	byte ptr es:[bp+0], ':' ; _$P_Colon
		jz	short _$P_SCOM_Same

_$P_SCOM_Differ:			; ...
		stc
		jmp	short _$P_SCOM_Exit
; ---------------------------------------------------------------------------

_$P_SCOM_Same:				; ...
		mov	cs:_$P_KEYorSW_Ptr, si
		clc

_$P_SCOM_Exit:				; ...
		pop	si
		pop	dx
		pop	bp
		pop	ax
		retn
_$P_String_Comp	endp


; =============== S U B	R O U T	I N E =======================================


_$P_File_Format	proc near		; ...
		push	ax
		push	di
		push	si
		mov	di, cs:_$P_SaveSI_Cmpx
		mov	al, cs:[si]
		or	al, al
		jz	short _$P_FileF_Err
		call	_$P_FileSp_Chk
		jnz	short _$P_FileF03
		mov	cs:_$P_err_flag, 1 ; _$P_error_filespec
		pop	si
		mov	byte ptr cs:[si], 0 ; _$P_NULL
		pop	di
		jmp	short _$P_FileF02
; ---------------------------------------------------------------------------

_$P_FileF_Err:				; ...
		pop	si
		mov	byte ptr cs:[si], 0 ; _$P_NULL
		pop	di
		test	word ptr es:[bx], 1 ; _$P_Optional
		jnz	short _$P_FileF02
		mov	cs:_$P_RC, 2	; _$P_Op_Missing
		jmp	short _$P_FileF02
; ---------------------------------------------------------------------------

_$P_FileF03:				; ...
		pop	ax
		push	si

_$P_FileF_Loop1:			; ...
		mov	al, cs:[si]	; load character (not special char)
		or	al, al		; end of line ?
		jz	short _$P_FileF_RLT
		call	_$P_FileSp_Chk
		jz	short _$P_FileF00
		call	_$P_Chk_DBCS
		jnb	short _$P_FileF01
		inc	di
		inc	si

_$P_FileF01:				; ...
		inc	di
		inc	si
		jmp	short _$P_FileF_Loop1
; ---------------------------------------------------------------------------

_$P_FileF00:				; ...
		mov	cs:_$P_Terminator, al
		mov	byte ptr cs:[si], 0 ; update end of string
		inc	di
		mov	cs:_$P_SI_Save,	di

_$P_FileF_RLT:				; ...
		pop	si
		pop	di

_$P_FileF02:				; ...
		pop	ax
		test	ax, 200h	; _$P_File_Spc
		jz	short _$P_Drv_Only_Exit
		push	ax
		mov	ah, 0FFh	; _$P_No_Tag
		mov	al, 5		; _$P_File_Spec
		call	_$P_Fill_Result
		pop	ax

_$P_Drv_Only_Exit:			; ...
		retn
_$P_File_Format	endp


; =============== S U B	R O U T	I N E =======================================


_$P_FileSp_Chk	proc near		; ...
		push	bx
		push	cx
		lea	bx, _$P_FileSp_Char
		mov	cx, 9		; _$P_FileSp_Len

_$P_FileSp_Loop:			; ...
		cmp	al, cs:[bx]
		jz	short _$P_FileSp_Exit
		inc	bx
		loop	_$P_FileSp_Loop
		inc	cx

_$P_FileSp_Exit:			; ...
		pop	cx
		pop	bx
		retn
_$P_FileSp_Chk	endp


; =============== S U B	R O U T	I N E =======================================


_$P_Drive_Format proc near		; ...
		push	ax
		push	dx
		mov	al, cs:[si]
		or	al, al
		jz	short _$P_Drv_Exit
		call	_$P_Chk_DBCS
		jb	short _$P_Drv_Err
		cmp	word ptr cs:[si+1], ':' ; _$P_Colon
		jz	short _$P_DrvF00
		test	word ptr es:[bx], 10h ;	_$P_Ig_Colon
		jz	short _$P_Drv_Err
		cmp	byte ptr cs:[si+1], 0 ;	_$P_NULL
		jnz	short _$P_Drv_Err

_$P_DrvF00:				; ...
		or	al, 20h		; _$P_Make_Lower
					; (lower case)
		cmp	al, 'a'         ; drive letter must
					; in range of "a" - "z"
		jb	short _$P_Drv_Err
		cmp	al, 'z'
		ja	short _$P_Drv_Err
		sub	al, 60h		; "a"-1
		mov	dl, al
		mov	ah, 0FFh
		mov	al, 6
		call	_$P_Fill_Result
		jmp	short _$P_Drv_Exit
; ---------------------------------------------------------------------------

_$P_Drv_Err:				; ...
		mov	cs:_$P_RC, 9	; _$P_Syntax

_$P_Drv_Exit:				; ...
		pop	dx
		pop	ax
		retn
_$P_Drive_Format endp


; =============== S U B	R O U T	I N E =======================================


_$P_Skip_Delim	proc near		; ...
		lodsb
		call	_$P_Chk_EOL	; is it	EOL character ?
		jz	short _$P_Skip_Delim_CY
		call	_$P_Chk_Delim	; is it	one of delimiters ?
		jnz	short _$P_Skip_Delim_NCY ; if no, exit w/ CY off
		test	byte ptr cs:_$P_Flags+1, 20h ; _$P_Extra
					; extra	delim or comma found ?
		jz	short _$P_Skip_Delim ; if no, loop
		test	byte ptr cs:_$P_Flags+1, 41h ; [cs:_$P_Flags2],
					; _$P_SW+_$P_equ
		jz	short _$P_Exit_At_Extra	; no switch, no	keyword
		dec	si
		jmp	short _$P_Exit_At_Extra
; ---------------------------------------------------------------------------

_$P_Skip_Delim_CY:			; ...
		stc			; indicate EOL
		jmp	short _$P_Skip_Delim_Exit
; ---------------------------------------------------------------------------

_$P_Skip_Delim_NCY:			; ...
		clc			; indicate non delim

_$P_Skip_Delim_Exit:			; ...
		dec	si		; in this case,	need
					; backup index pointer
		retn
; ---------------------------------------------------------------------------

_$P_Exit_At_Extra:			; ...
		clc			; indicate extra delim
		retn
_$P_Skip_Delim	endp


; =============== S U B	R O U T	I N E =======================================


_$P_Chk_EOL	proc near		; ...
		push	bx
		push	cx
		cmp	al, 0Dh		; _$P_CR
		jz	short _$P_Chk_EOL_Exit
		cmp	al, 0		; _$P_NUL
		jz	short _$P_Chk_EOL_Exit
		cmp	al, 0Ah		; _$P_LF
		jz	short _$P_Chk_EOL_Exit
		cmp	byte ptr es:[di+2], 2 ;	[es:di+_$P_PARMS_Blk.Num_Extra],
					; _$P_I_Have_EOL
		jb	short _$P_Chk_EOL_Exit
		xor	bx, bx
		mov	bl, es:[di+3]	; [es:di+_$P_PARMS_Blk.Len_Extra_Delim]
		add	bx, 4		; _$P_Len_PARMS
		cmp	byte ptr es:[bx+di], 0 ; _$P_I_Use_Default
					; No extra EOL character ?
		jz	short _$P_Chk_EOL_NZ
		xor	cx, cx
		mov	cl, es:[bx+di]	; Check	extra EOL character

_$P_Chk_EOL_Loop:			; ...
		inc	bx
		cmp	al, es:[bx+di]
		jz	short _$P_Chk_EOL_Exit
		loop	_$P_Chk_EOL_Loop

_$P_Chk_EOL_NZ:				; ...
		cmp	al, 0Dh		; _$P_CR
					; reset	ZF

_$P_Chk_EOL_Exit:			; ...
		pop	cx
		pop	bx
		retn
_$P_Chk_EOL	endp


; =============== S U B	R O U T	I N E =======================================


_$P_Chk_Delim	proc near		; ...
		push	bx
		push	cx
		mov	cs:_$P_Terminator, ' ' ; _$P_Space
		and	byte ptr cs:_$P_Flags+1, 0DFh ;	0FFh-_$P_Extra
		cmp	al, 20h	; ' '   ; _$P_Space
		jz	short _$P_Chk_Delim_Exit
		cmp	al, 9		; _$P_TAB
		jz	short _$P_Chk_Delim_Exit
		cmp	al, 2Ch	; ','   ; _$P_Comma
		jz	short _$P_Chk_Delim_Exit0

_$P_Chk_Delim00:			; _$P_DBSP1
		cmp	al, 20h	; ' '
		jnz	short _$P_Chk_Delim01
		cmp	byte ptr [si], 20h ; ' ' ; _$P_DBSP2
		jnz	short _$P_Chk_Delim01
		mov	al, 20h	; ' '   ; _$P_Space
		inc	si
		cmp	al, al
		jmp	short _$P_Chk_Delim_Exit
; ---------------------------------------------------------------------------

_$P_Chk_Delim01:			; ...
		cmp	byte ptr es:[di+2], 1 ;	[es:di-_$P_PARMS_Blk.Num_Extra],
					; _$P_I_Have_Delim
		jb	short _$P_Chk_Delim_Exit
		xor	cx, cx
		mov	cl, es:[di+3]	; ; [es:di+_$P_PARMS_Blk.Len_Extra_Delim]
		or	cx, cx
		jz	short _$P_Chk_Delim_NZ
		mov	bx, 3		; _$P_Len_PARMS-1

_$P_Chk_Delim_Loop:			; ...
		inc	bx
		cmp	al, es:[bx+di]
		jz	short _$P_Chk_Delim_Exit0
		loop	_$P_Chk_Delim_Loop

_$P_Chk_Delim_NZ:			; ...
		cmp	al, 20h	; ' '   ; _$P_Space

_$P_Chk_Delim_Exit:			; ...
		pop	cx
		pop	bx
		retn
; ---------------------------------------------------------------------------

_$P_Chk_Delim_Exit0:			; ...
		mov	cs:_$P_Terminator, al
		test	byte ptr cs:_$P_Flags+1, 1 ; [cs:_$P_Flags2],
					; _$P_equ
		jnz	short _$P_No_Set_Extra
		or	byte ptr cs:_$P_Flags+1, 20h ; _$P_Extra

_$P_No_Set_Extra:			; ...
		cmp	al, al
		jmp	short _$P_Chk_Delim_Exit
_$P_Chk_Delim	endp


; =============== S U B	R O U T	I N E =======================================


_$P_Chk_Switch	proc near		; ...
		lea	bp, _$P_STRING_BUF
		cmp	bx, bp
		jz	short _$P_STRUC_L2
		cmp	al, '/'         ; _$P_Switch
		jnz	short _$P_STRUC_L5
		stc
		jmp	short _$P_STRUC_L1
; ---------------------------------------------------------------------------

_$P_STRUC_L5:				; ...
		clc
		jmp	short _$P_STRUC_L1
; ---------------------------------------------------------------------------

_$P_STRUC_L2:				; ...
		cmp	al, '/'         ; _$P_Switch
		jnz	short _$P_STRUC_L12
		or	byte ptr cs:_$P_Flags+1, 40h ; _$P_SW

_$P_STRUC_L12:				; ...
		clc

_$P_STRUC_L1:				; ...
		retn
_$P_Chk_Switch	endp


; =============== S U B	R O U T	I N E =======================================


_$P_Chk_DBCS	proc near		; ...
		push	ds
		push	si
		push	bx
		cmp	cs:_$P_DBCSEV_SEG, 0 ; ALREADY SET ?
		jnz	short _$P_DBCS00
		push	ax
		push	ds
		push	cx
		push	dx
		push	di
		push	bp
		push	es
		xor	si, si
		mov	ds, si
		mov	ax, 6300h	; _$P_DOS_GetEV
		int	21h		; DOS -	3.2+ only - GET	DOUBLE BYTE CHARACTER SET LEAD TABLE
		mov	bx, ds
		or	bx, bx
		pop	es
		pop	bp
		pop	di
		pop	dx
		pop	cx
		pop	ds
		pop	ax
		jz	short _$P_NON_DBCS
		mov	cs:_$P_DBCSEV_OFF, si ;	save EV	offset
		mov	cs:_$P_DBCSEV_SEG, bx ;	save EV	segment

_$P_DBCS00:				; ...
		mov	si, cs:_$P_DBCSEV_OFF
		mov	ds, cs:_$P_DBCSEV_SEG

_$P_DBCS_LOOP:				; ...
		cmp	word ptr [si], 0 ; zero	vector ?
		jz	short _$P_NON_DBCS ; then exit
		cmp	al, [si]
		jb	short _$P_DBCS01
		cmp	al, [si+1]
		ja	short _$P_DBCS01
		stc			; indicate DBCS	and exit
		jmp	short _$P_DBCS_EXIT
; ---------------------------------------------------------------------------

_$P_DBCS01:				; ...
		inc	si
		inc	si
		jmp	short _$P_DBCS_LOOP
; ---------------------------------------------------------------------------

_$P_NON_DBCS:				; ...
		clc			; indicate SBCS

_$P_DBCS_EXIT:				; ...
		pop	bx
		pop	si
		pop	ds
		retn
_$P_Chk_DBCS	endp

; ---------------------------------------------------------------------------
buf_parms	dw offset buf_parmsx	; ...
					; buffer = [n |	n,m] {/e}
		db 1			; an extra delimiter list
		db 1			; length is 1
		db ';'                  ; delimiter
buf_parmsx	dw 201h			; ...
					; min 1, max 2 positionals
		dw offset buf_pos1
		dw offset buf_pos2
		db 1			; one switch
		dw offset sw_x_ctrl
		db 0			; no keywords
buf_pos1	dw 8000h		; ...
					; numeric value??
		dw 0			; function
		dw offset result_val	; result value buffer
		dw offset buf_range_1	; value	list
		db 0			; no switches/keywords
buf_range_1	db 1			; ...
					; range	definition
		db 1			; 1 definition of range
		db 1			; item tag for this range
		dd 1			; numeric min
		dd 99			; numeric max
buf_pos2	dw 8001h		; ...
					; optional num.
		dw 0
		dw offset result_val
		dw offset buf_range_2
		db 0
buf_range_2	db 1			; ...
		db 1
		db 1
		dd 0
		dd 8
sw_x_ctrl	dw 0			; ...
					; ; followed by	one switch
		dw 0
		dw offset result_val
		dw offset noval
		db 1
switch_x	db '/X',0               ; ...
p_buffers	dw 0			; ...
p_h_buffers	dw 0			; ...
p_buffer_slash_x db 0			; ...
noval		db 0			; ...
result_val	db 0			; ...
					; type returned
result_val_itag	db 0			; ...
					; item tag returned
result_val_swoff dw 0			; ...
					; es:offset of the switch defined
rv_dword	dd 0			; ...
brk_parms	dw offset brk_parmsx	; ...
					; break	= [ on | off ]
		db 1			; an extra delimiter list
		db 1			; length is 1
		db ';'                  ; delimiter
brk_parmsx	dw 101h			; ...
					; min,max = 1 positional
		dw offset brk_pos
		db 0			; no switches
		db 0			; no keywords
brk_pos		dw 2000h		; ...
		dw 0
		dw offset result_val
		dw offset on_off_string
		db 0
on_off_string	db 3			; ...
					; signals that there is	a string choice
		db 0			; no range definition
		db 0			; no numeric values choice
		db 2			; 2 strings for	choice
		db 1			; the 1st string tag
		dw offset on_string	; "ON"
		db 2			; the 2nd string tag
		dw offset _off_string	; "OFF"
on_string	db 'ON',0               ; ...
_off_string	db 'OFF',0              ; ...
p_ctrl_break	db 0			; ...
cntry_parms	dw offset cntry_parmsx	; ...
					; country = n {m {path}}
					; or country = n,,path
		db 1
		db 1
		db ';'
cntry_parmsx	dw 301h			; ...
					; min 1, max 3 pos.
		dw offset cntry_pos1
		dw offset cntry_pos2
		dw offset cntry_pos3
		db 0			; no switches
		db 0			; no keywords
cntry_pos1	dw 8000h		; ...
		dw 0
		dw offset result_val
		dw offset cc_range
		db 0
cc_range	db 1			; ...
		db 1
		db 1
		dd 1
		dd 999
cntry_pos2	dw 8001h		; ...
		dw 0
		dw offset result_val
		dw offset cc_range
		db 0
cntry_pos3	dw 201h			; ...
		dw 0
		dw offset result_val
		dw offset noval
		db 0
p_cntry_code	dw 0			; ...
p_code_page	dw 0			; ...
files_parms	dw offset files_parmsx	; ...
					; files	= n
		db 1
		db 1
		db ';'
files_parmsx	dw 101h			; ...
					; min,max 1 positional
		dw offset files_pos
		db 0			; no switches
		db 0			; no keywords
files_pos	dw 8000h		; ...
		dw 0
		dw offset result_val
		dw offset files_range
		db 0
files_range	db 1			; ...
		db 1
		db 1
		dd 8
		dd 255
p_files		db 0			; ...
fcbs_parms	dw offset fcbs_parmsx	; ...
					; fcbs = n,m
		db 1
		db 1
		db ';'
fcbs_parmsx	dw 201h			; ...
					; min,max = 2 positional
		dw offset fcbs_pos_1
		dw offset fcbs_pos_2
		db 0			; no switches
		db 0			; no keywords
fcbs_pos_1	dw 8000h		; ...
		dw 0
		dw offset result_val
		dw offset fcbs_range
		db 0
fcbs_range	db 1			; ...
		db 1
		db 1
		dd 1
		dd 255
fcbs_pos_2	dw 8000h		; ...
		dw 0
		dw offset result_val
		dw offset fcbs_keep_range
		db 0
fcbs_keep_range	db 1			; ...
		db 1
		db 1
		dd 0
		dd 255
p_fcbs		db 0			; ...
p_keep		db 0			; ...
ldrv_parms	dw offset ldrv_parmsx	; ...
					; lastdrive = x
		db 1
		db 1
		db ';'
ldrv_parmsx	dw 101h			; ...
					;  min,max = 1 positional
		dw offset ldrv_pos
		db 0			; no switches
		db 0			; no keywords
ldrv_pos	dw 110h			; ...
		dw 10h
		dw offset result_val
		dw offset noval
		db 0
p_ldrv		db 0			; ...
stks_parms	dw offset stks_parmsx	; ...
					; stacks = n,m
		db 1
		db 1
		db ';'
stks_parmsx	dw 202h			; ...
		dw offset stks_pos_1
		dw offset stks_pos_2
		db 0			; no switches
		db 0			; no keywords
stks_pos_1	dw 8000h		; ...
		dw 0
		dw offset result_val
		dw offset stks_range
		db 0
stks_range	db 1			; ...
		db 1
		db 1
		dd 0
		dd 64
stks_pos_2	dw 8000h		; ...
		dw 0
		dw offset result_val
		dw offset stk_size_range
		db 0
stk_size_range	db 1			; ...
		db 1
		db 1
		dd 0
		dd 512
p_stack_count	dw 0			; ...
p_stack_size	dw 0			; ...
mtrk_parms	dw offset mtrk_parmsx	; ...
					; multitrack = [ on | off ]
		db 1
		db 1
		db ';'
mtrk_parmsx	dw 101h			; ...
					; min,max = 1 positional
		dw offset mtrk_pos
		db 0			; no switches
		db 0			; no keywords
mtrk_pos	dw 2000h		; ...
		dw 0
		dw offset result_val
		dw offset on_off_string
		db 0
p_mtrk		db 0			; ...
swit_parms	dw offset swit_parmsx	; ...
					; switches=/k
		db 1
		db 1
		db ';'
swit_parmsx	dw 0			; ...
					; no positionals
		db 3			; # of switches
		dw offset swit_k_ctrl	; /k control
		dw offset swit_t_ctrl	; /t control
		dw offset swit_w_ctrl	; /w control
		db 0			; no keywords
swit_k_ctrl	dw 0			; ...
		dw 0
		dw offset result_val
		dw offset noval
		db 1
swit_k		db '/K',0               ; ...
swit_t_ctrl	dw 0			; ...
		dw 0
		dw offset result_val
		dw offset noval
		db 1
swit_t		db '/T',0               ; ...
swit_w_ctrl	dw 0			; ...
		dw 0
		dw offset result_val
		dw offset noval
		db 1
swit_w		db '/W',0               ; ...
p_swit_k	db 0			; ...
p_swit_t	db 0			; ...
p_swit_w	db 0			; ...
dos_parms	dw offset dos_parmsx	; ...
		db 1
		db 1
		db ';'
dos_parmsx	db 1			; ...
					; min parameters
		db 2			; max parameters
		dw offset dos_pos
		dw offset dos_pos
		db 0			; no switches
		db 0			; no keywords
dos_pos		dw 2000h		; ...
		dw 0
		dw offset result_val
		dw offset dos_strings
		db 0
		dw 2000h
		dw 0
		dw offset result_val
		dw offset dos_strings
		db 0
dos_strings	db 3			; ...
					; signals that there is	a string choice
		db 0			; no range definition
		db 0			; no numeric values choice
		db 4			; 4 strings for	choice
		db 1			; the 1st string tag
		dw offset hi_string	; "HIGH"
		db 2			; the 2nd string tag
		dw offset lo_string	; "LOW"
		db 3
		dw offset umb_string	; "UMB"
		db 4
		dw offset noumb_string	; "NOUMB"
hi_string	db 'HIGH',0             ; ...
lo_string	db 'LOW',0              ; ...
umb_string	db 'UMB',0              ; ...
noumb_string	db 'NOUMB',0            ; ...
p_dos_hi	db 0			; local	variable
					; ; BUGBUG : I dont know whether PARSER	uses
					; this variable	or not
DevSize		dw 0			; ...
DevLoadAddr	dw 0			; ...
DevLoadEnd	dw 0			; ...
DevEntry	dd 0			; ...
DevBrkAddr	dd 0			; ...
DevUMB		db 0			; ...
DevUMBAddr	dw 0			; ...
DevUMBSize	dw 0			; ...
DevUMBFree	dw 0			; ...
DevXMSAddr	dd 0			; ...
DevExecAddr	dw 0			; ...
DevExecReloc	dw 0			; ...
DeviceHi	db 0			; ...
DevSizeOption	dw 0			; ...
Int12Lied	db 0			; ...
OldInt12Mem	dw 0			; ...
ThreeComName	db 'PROTMAN$'           ; ...
FirstUMBLinked	db 0			; ...
DevDOSData	dw 0			; ...
DevCmdLine	dw 0, 0			; ...
DevSavedDelim	db 0			; ...

; =============== S U B	R O U T	I N E =======================================


doconf		proc near		; ...
		push	cs
		pop	ds
		mov	ax, 3700h
		int	21h		; DOS -	2+ internal - GET SWITCHAR/AVAILDEV
					; Return: AL = FFh unsupported subfunction
					; DL = current switch character
		mov	ds:command_line+1, dl ;	set in default command line
		mov	dx, offset config ; "\\CONFIG.SYS"
		mov	ax, 3D00h
		stc			; in case of int 24
		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
					; DS:DX	-> ASCIZ filename
					; AL = access mode
					; 0 - read
		jnb	short noprob
		mov	ds:multi_pass_id, 11
		retn
; ---------------------------------------------------------------------------

noprob:					; ...
		mov	bx, ax		; get file size	(note <	64k!!)
					; File handle
		xor	cx, cx
		xor	dx, dx
		mov	ax, 4202h
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from end of file
		mov	ds:count, ax
		xor	dx, dx		; reset	pointer	to beginning of	file
		mov	ax, 4200h
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from beginning of	file
		mov	dx, ds:top_of_cdss ; use current alloclim value
		mov	ax, ds:count
		mov	ds:config_size,	ax
		call	ParaRound
		sub	dx, ax
		sub	dx, 11h
		mov	ds:top_of_cdss,	dx
		call	TempCDS
		mov	dx, cs:top_of_cdss
		mov	ds, dx
		mov	es, dx
		xor	dx, dx
		mov	cx, cs:count
		mov	ah, 3Fh
		stc
		int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
					; BX = file handle, CX = number	of bytes to read
					; DS:DX	-> buffer
		pushf			; find the eof mark in the file.
					; if present,then trim length.
		push	ax
		push	di
		push	cx
		mov	al, 1Ah		; eof mark
		mov	di, dx		; point	to buffer
		jcxz	short puteol	; no chars
		repne scasb		; find end
		jnz	short puteol	; none found and count exhausted
		dec	di		; backup past 1Ah

puteol:					; ...
		mov	al, 0Dh		; cr
		stosb
		mov	al, 0Ah		; lf
		stosb
		sub	di, dx		; difference moved
		mov	cs:count, di	; new count
		pop	cx
		pop	di
		pop	ax
		push	cs
		pop	ds
		push	ax
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		pop	ax
		popf
		jb	short conferr	; we've got a problem
		cmp	cx, ax
		jz	short getcom	; couldn't read the file

conferr:				; ...
		mov	dx, offset config ; want to print config error
		call	badfil

endconv:				; ...
		retn
doconf		endp


; =============== S U B	R O U T	I N E =======================================


multi_pass	proc near		; ...

; FUNCTION CHUNK AT 0899 SIZE 00000002 BYTES
; FUNCTION CHUNK AT 278E SIZE 0000025B BYTES
; FUNCTION CHUNK AT 2A1C SIZE 0000000C BYTES
; FUNCTION CHUNK AT 34D5 SIZE 0000000B BYTES

		push	cs
		pop	ds
		cmp	ds:multi_pass_id, 10
		jnb	short endconv
		push	ds:top_of_cdss
		pop	es
		mov	si, ds:org_count
		mov	ds:count, si
		xor	si, si
		mov	ds:chrptr, si
		mov	ds:linecount, si
		call	getchr
		jmp	short conflp
; ---------------------------------------------------------------------------

getcom:					; ...
		call	organize
		call	getchr

conflp:					; ...
		jb	short endconv
		inc	ds:linecount
		mov	ds:multdeviceflag, 0
		mov	ds:setdevmarkflag, 0
		cmp	al, 0Ah		; lf
		jz	short blank_line ; ignore this line
		mov	ah, al
		call	getchr
		jnb	short tryi
		cmp	ds:multi_pass_id, 2
		jnb	short endconv
		jmp	badop
; ---------------------------------------------------------------------------

coff:					; ...
		push	cs
		pop	ds
		call	newline
		jmp	short conflp
; ---------------------------------------------------------------------------

blank_line:				; ...
		call	getchr
		jmp	short conflp
; ---------------------------------------------------------------------------
		push	cs
		pop	ds

tryi:					; ...
		cmp	ds:multi_pass_id, 0 ; install command
					; the initial pass for DOS=HI
		jnz	short not_init_pass
		jmp	multi_try_doshi
; ---------------------------------------------------------------------------

not_init_pass:				; ...
		cmp	ds:multi_pass_id, 2 ; the second pass was for ifs=
		jz	short multi_pass_coff ;	now it is NOPs
		cmp	ds:multi_pass_id, 3 ; the third	pass for install= ?
		jz	short multi_try_i
		cmp	ah, 'H'         ; CONFIG_DOS
		jz	short multi_pass_coff
		cmp	ah, 'I'         ; CONFIG_INSTALL
		jnz	short tryb
		or	ds:install_flag, 1 ; have_install_cmd

multi_pass_coff2:
		jmp	short coff
; ---------------------------------------------------------------------------

multi_try_i:				; ...
		cmp	ah, 'I'         ; CONFIG_INSTALL
		jnz	short multi_pass_filter
		call	do_install_exec
		jmp	short coff
; ---------------------------------------------------------------------------

multi_pass_filter:			; ...
		cmp	ah, 'Y'         ; CONFIG_COMMENT
		jz	short multi_pass_adjust
		cmp	ah, 'Z'         ; CONFIG_UNKNOWN
		jz	short multi_pass_adjust
		cmp	ah, '0'         ; CONFIG_REM
		jnz	short multi_pass_coff ;	ignore the rest	of the commands

multi_pass_adjust:			; ...
		dec	ds:chrptr
		inc	ds:count

multi_pass_coff:			; ...
		jmp	short coff	; to handle next install= commands.
; ---------------------------------------------------------------------------

tryb:					; ...
		cmp	ah, 'B'         ; buffer command
					; CONFIG_BUFFERS
		jnz	short tryc
		mov	ds:p_buffer_slash_x, 0
		mov	di, offset buf_parms
		xor	cx, cx
		mov	dx, cx

do7:					; ...
		call	sysinit_parse
		jnb	short if7
		call	badparm_p
		jmp	short sr7
; ---------------------------------------------------------------------------

if7:					; ...
		cmp	ax, 0FFFFh	; _$P_RC_EOL
					; end of line?
		jz	short en7
		cmp	ds:result_val_swoff, offset switch_x ; "/X"
		jnz	short if11
		jmp	short en11
; ---------------------------------------------------------------------------

if11:					; ...
		mov	ax, word ptr ds:rv_dword
		cmp	cx, 1
		jnz	short if13
		mov	ds:p_buffers, ax
		jmp	short en11
; ---------------------------------------------------------------------------

if13:					; ...
		mov	ds:p_h_buffers,	ax

en11:					; ...
		jmp	short do7
; ---------------------------------------------------------------------------

en7:					; ...
		cmp	ds:p_buffers, 99
		jbe	short if18
		call	badparm_p
		mov	ds:p_h_buffers,	0
		jmp	short sr7
; ---------------------------------------------------------------------------

if18:					; ...
		mov	ax, ds:p_buffers ; we don't have any problem.
		mov	ds:buffers, ax	; now,let's set it really.
		mov	ax, ds:p_h_buffers
		mov	ds:h_buffers, ax
		mov	ax, ds:linecount
		mov	ds:buffer_linenum, ax ;	save the line number for the future use

sr7:					; ...
		jmp	coff
; ---------------------------------------------------------------------------

tryc:					; ...
		cmp	ah, 'C'         ; break command
					; CONFIG_BREAK
		jnz	short trym
		mov	di, offset brk_parms
		xor	cx, cx
		mov	dx, cx

do22:					; ...
		call	sysinit_parse
		jnb	short if22
		call	badparm_p
		jmp	short sr22
; ---------------------------------------------------------------------------

if22:					; ...
		cmp	ax, 0FFFFh	; _$P_RC_EOL
		jz	short en22
		cmp	ds:result_val_itag, 1
		jnz	short if26
		mov	ds:p_ctrl_break, 1 ; turn it on
		jmp	short en26
; ---------------------------------------------------------------------------

if26:					; ...
		mov	ds:p_ctrl_break, 0 ; turn it off

en26:					; ...
		jmp	short do22
; ---------------------------------------------------------------------------

en22:					; ...
		mov	ah, 33h		; SET_CTRL_C_TRAPPING
		mov	al, 1
		mov	dl, ds:p_ctrl_break
		int	21h		; DOS -	EXTENDED CONTROL-BREAK CHECKING
					; AL = 00h get state / 01h set state / 02h set AND get
					; DL = 00h for OFF or 01h for ON

sr22:					; ...
		jmp	coff
; ---------------------------------------------------------------------------

trym:					; ...
		cmp	ah, 'M'         ; multitrack command
					; CONFIG_MULTITRACK
		jnz	short tryu
		mov	di, offset mtrk_parms
		xor	cx, cx
		mov	dx, cx

do31:					; ...
		call	sysinit_parse
		jnb	short if31
		call	badparm_p
		jmp	short sr31
; ---------------------------------------------------------------------------

if31:					; ...
		cmp	ax, 0FFFFh	; _$P_RC_EOL
					; end of line?
		jz	short en31
		cmp	ds:result_val_itag, 1
		jnz	short if35
		mov	ds:p_mtrk, 1	; turn it on temporarily
		jmp	short en35
; ---------------------------------------------------------------------------

if35:					; ...
		mov	ds:p_mtrk, 0	; turn it off temporarily

en35:					; ...
		jmp	short do31
; ---------------------------------------------------------------------------

en31:					; ...
		push	ds
		mov	ax, 70h		; DOSBIODATASEG	(DOS BIOS Data Segment)
		mov	ds, ax
		assume ds:nothing
		cmp	cs:p_mtrk, 0
		jnz	short if39
		mov	word ptr ds:52Fh, 1 ; [multrk_flag],
					; multrk_off2
		jmp	short en39
; ---------------------------------------------------------------------------

if39:					; ...
		mov	word ptr ds:52Fh, 80h ;	[multrk_flag],
					; multrk_on

en39:					; ...
		pop	ds
		assume ds:nothing

sr31:					; ...
		jmp	coff
; ---------------------------------------------------------------------------

multi_try_doshi:			; ...
		cmp	ah, 'H'         ; DOS=HIGH/LOW command
					; CONFIG_DOS
		jz	short it_is_h
		jmp	multi_pass_filter
; ---------------------------------------------------------------------------

it_is_h:				; ...
		mov	di, offset dos_parms
		xor	cx, cx
		mov	dx, cx

h_do_parse:				; ...
		call	sysinit_parse
		jnb	short h_parse_ok
		call	badparm_p
		jmp	short h_end
; ---------------------------------------------------------------------------

h_parse_ok:				; ...
		cmp	ax, 0FFFFh	; _$P_RC_EOL
					; end of line?
		jz	short h_end
		call	ProcDOS
		jmp	short h_do_parse
; ---------------------------------------------------------------------------

h_end:					; ...
		jmp	coff
; ---------------------------------------------------------------------------

tryu:					; ...
		cmp	ah, 'U'         ; devicehigh command
					; CONFIG_DEVICEHIGH
		jnz	short tryd
		mov	word ptr cs:badparm_ptr, si
		mov	word ptr cs:badparm_ptr+2, es
		call	ParseSize
		jnb	short tryu_0
		call	badparm_p
		jmp	coff
; ---------------------------------------------------------------------------

tryu_0:					; ...
		push	si
		push	es

tryu_3:					; ...
		mov	al, es:[si]
		cmp	al, 0Dh		; cr
		jz	short tryu_4
		cmp	al, 0Ah		; lf
		jz	short tryu_4
		call	delim
		jz	short tryu_4
		inc	si
		jmp	short tryu_3
; ---------------------------------------------------------------------------

tryu_4:					; ...
		mov	cs:DevSavedDelim, al
		mov	byte ptr es:[si], 0
		pop	es
		pop	si

NrmTst:
		mov	cs:DeviceHi, 0
		cmp	cs:DevUMB, 0
		jz	short LoadDevice
		mov	cs:DeviceHi, 1
		jmp	short LoadDevice
; ---------------------------------------------------------------------------

tryd:					; ...
		cmp	ah, 'D'         ; device command
					; CONFIG_DEVICE
		jz	short gotd
		jmp	tryq
; ---------------------------------------------------------------------------

gotd:					; ...
		mov	cs:DeviceHi, 0
		mov	cs:DevSizeOption, 0
		mov	cs:DevSavedDelim, 20h ;	' '

LoadDevice:				; ...
		mov	bx, cs
		mov	ds, bx
		mov	word ptr cs:bpb_addr, si
		mov	word ptr cs:bpb_addr+2,	es
		mov	cs:DevCmdLine, si
		mov	cs:DevCmdLine+2, es
		call	round
		call	SizeDevice
		jb	short BadFile

DevConvLoad:
		call	InitDevLoad
		mov	ax, cs:DevLoadAddr
		add	ax, cs:DevSize
		jb	short NoMem
		cmp	cs:DevLoadEnd, ax
		jnb	short LoadDev

NoMem:					; ...
		jmp	memerr
; ---------------------------------------------------------------------------

BadFile:				; ...
		cmp	byte ptr es:[si], 0Dh ;	cr
		jnz	short tryd_2
		jmp	badop
; ---------------------------------------------------------------------------

tryd_2:					; ...
		call	badload
		jmp	coff
; ---------------------------------------------------------------------------

LoadDev:				; ...
		push	es
		pop	ds
		mov	dx, si		; ds:dx	points to file name
		call	ExecDev		; load device driver using exec	call
		push	ds
		pop	es		; es:si	back to	config.sys
		push	cs
		pop	ds		; ds back to sysinit
		jb	short BadFile

goodld:					; ...
		push	es
		push	si
		call	RemoveNull
		push	es
		push	si
		push	cs
		pop	es
		push	ds
		push	si
		lds	si, cs:DevEntry	; peeks	the header attribute
		test	word ptr [si+4], 8000h
		jnz	short got_device_com_cont
		lds	si, cs:DOSINFO	; ds:si	-> sys_var
		cmp	byte ptr [si+32], 26 ; [si+SYSI_NUMIO]
					; no more than 26 drive	number
		jb	short got_device_com_cont
		pop	si
		pop	ds
		pop	si
		pop	es
		jmp	short badnumblock
; ---------------------------------------------------------------------------

got_device_com_cont:			; ...
		pop	si
		pop	ds
		call	LieInt12Mem
		call	UpdatePDB	; update the PSP:2 value
		cmp	cs:multdeviceflag, 0
		jnz	short skip_pass_limit
		mov	word ptr cs:break_addr,	0
		mov	bx, cs:DevLoadEnd
		mov	word ptr cs:break_addr+2, bx

skip_pass_limit:			; ...
		mov	bx, 6		; SYSDEV.STRAT
		call	calldev
		mov	bx, 8		; SYSDEV.INT
		call	calldev
		call	TrueInt12Mem
		mov	ax, word ptr cs:break_addr
		mov	word ptr cs:DevBrkAddr,	ax
		mov	ax, word ptr cs:break_addr+2
		mov	word ptr cs:DevBrkAddr+2, ax
		cmp	cs:DevUMB, 0
		jz	short tryd_3
		call	AllocUMB

tryd_3:					; ...
		cmp	cs:runhigh, 0FFh
		jnz	short tryd_4
		call	TryToMovDOSHi	; move DOS into	HMA if reqd

tryd_4:					; ...
		pop	si
		pop	ds
		mov	byte ptr [si], 0
		push	cs
		pop	ds
		jmp	short was_device_com
; ---------------------------------------------------------------------------

badnumblock:				; ...
		push	cs
		pop	ds
		mov	dx, offset badblock ; "\r\nToo many block devices\r\n$"
		call	print

erase_dev_do:				; ...
		pop	si		; modified to show message "error in config.sys..."
		pop	es
		push	cs
		pop	ds
		cmp	cs:configmsgflag, 0
		jz	short no_error_line_msg
		call	error_line
		mov	cs:configmsgflag, 0

no_error_line_msg:			; ...
		jmp	coff
; ---------------------------------------------------------------------------

was_device_com:				; ...
		mov	ax, word ptr cs:DevBrkAddr+2
		cmp	ax, cs:DevLoadEnd
		jbe	short breakok
		pop	si
		pop	es
		jmp	BadFile
; ---------------------------------------------------------------------------

breakok:				; ...
		lds	dx, cs:DevEntry
		mov	si, dx
		les	di, cs:DOSINFO
		mov	ax, [si+4]	; [si+SYSDEV.ATT]
		test	ax, 8000h	; DEVTYP
					; test if block	dev
		jz	short isblock
		or	cs:setdevmarkflag, 2 ; for_devmark
		call	DevSetBreak

jc_edd:					; ...
		jb	short erase_dev_do
		test	ax, 1		; ISCIN
					; is it	a console in?
		jz	short tryclk
		mov	es:[di+12], dx	; [es:di+SYSI_CON]
		mov	word ptr es:[di+14], ds	; [es:di+SYSI_CON+2]

tryclk:					; ...
		test	ax, 8		; ISCLOCK
					; is it	a clock	device?
		jz	short golink
		mov	es:[di+8], dx	; [es:di+SYSI_CLOCK]
		mov	word ptr es:[di+10], ds	; [es:di+SYSI_CLOCK+2]

golink:					; ...
		jmp	linkit
; ---------------------------------------------------------------------------

isblock:				; ...
		mov	al, cs:unitcount
		or	al, al
		jz	short erase_dev_do
		mov	[si+10], al	; [si+SYSDEV.NAME]
					; number of units in name field
		cbw
		mov	cx, ax
		mov	dh, ah
		mov	dl, es:[di+32]	; [es:di+SYSI_NUMIO]
					; get number of	devices
		mov	ah, dl
		add	ah, al
		cmp	ah, 26		; check	for too	many devices
		jbe	short ok_block
		jmp	badnumblock
; ---------------------------------------------------------------------------

ok_block:				; ...
		or	cs:setdevmarkflag, 2 ; for_devmark
		call	DevSetBreak
		jb	short jc_edd
		add	es:[di+32], al	; [es:di+SYSI_NUMIO]
					; update the amount
		add	cs:devdrivenum,	al ; remember amount for next device
		lds	bx, dword ptr cs:bpb_addr ; point to bpb array

perunit:				; ...
		les	bp, cs:DOSINFO
		les	bp, es:[bp+0]	; [es:bp+SYSI_DPB]

scandpb:				; ...
		cmp	word ptr es:[bp+25], 0FFFFh ; [es:bp+DPB.NEXT_DPB]
		jz	short foundpb
		les	bp, es:[bp+25]	; [es:bp+DPB.NEXT_DPB]
		jmp	short scandpb
; ---------------------------------------------------------------------------

foundpb:				; ...
		mov	ax, word ptr cs:DevBrkAddr
		mov	es:[bp+25], ax	; [es:bp+DPB.NEXT_DPB]
		mov	ax, word ptr cs:DevBrkAddr+2
		mov	es:[bp+27], ax	; [es:bp+DPB.NEXT_DPB+2]
		les	bp, cs:DevBrkAddr
		add	word ptr cs:DevBrkAddr,	33 ; DPBSIZ
		call	RoundBreakAddr
		mov	word ptr es:[bp+25], 0FFFFh
		mov	byte ptr es:[bp+24], 0FFh ; [es:bp+DPB.FIRST_ACCESS]
		mov	si, [bx]	; ds:si	points to bpb
		inc	bx
		inc	bx
		mov	es:[bp+0], dx
		mov	ah, 53h		; SETDPB
		int	21h		; DOS -	2+ internal - TRANSLATE	BIOS PARAMETER BLOCK
					; DS:SI	-> BPB (BIOS Parameter Block)
					; ES:BP	-> buffer for DOS Drive	Parameter Block
		mov	ax, es:[bp+2]	; [es:bp+DPB.SECTOR_SIZE]
		push	es
		les	di, cs:DOSINFO
		cmp	ax, es:[di+10h]	; [es:di+SYSI_MAXSEC]
		pop	es
		ja	short bad_bpb_size_sector

iblk_1:
		push	ds
		push	dx
		lds	dx, cs:DevEntry
		mov	es:[bp+13h], dx	; [es:bp+DPB.DRIVER_ADDR]
		mov	word ptr es:[bp+15h], ds ; [es:bp+DPB.DRIVER_ADDR+2]
		pop	dx
		pop	ds
		inc	dx
		inc	dh
		loop	perunit
		push	cs
		pop	ds
		call	TempCDS		; set cds for new drives

linkit:					; ...
		les	di, cs:DOSINFO	; es:di	= dos (SYSVARS)	table
		mov	cx, es:[di+22h]	; [es:di+SYSI_DEV]
		mov	dx, es:[di+24h]	; [es:di+SYSI_DEV+2]
					; dx:cx	= head of list
		lds	si, cs:DevEntry	; ds:si	= device location
		mov	es:[di+22h], si	; set head of list in dos
		mov	word ptr es:[di+24h], ds
		mov	ax, [si]	; get pointer to next device
		mov	word ptr cs:DevEntry, ax ; and save it
		mov	[si], cx	; link in the driver
		mov	[si+2],	dx

enddev:
		pop	si
		pop	es
		inc	ax		; ax = ffff (no	more devs if yes)?
		jz	short coffj3
		inc	cs:multdeviceflag ; possibly multiple device driver
		call	DevBreak
		jmp	goodld
; ---------------------------------------------------------------------------

coffj3:					; ...
		mov	cs:multdeviceflag, 0 ; reset the flag
		call	DevBreak
		jmp	coff
; ---------------------------------------------------------------------------

bad_bpb_size_sector:			; ...
		pop	si
		pop	es
		mov	dx, offset badsiz_pre ;	"\r\nSector size too large in file $"
		mov	bx, offset crlfm ; "\r\n$"
		call	prnerr
		jmp	coff
; ---------------------------------------------------------------------------

tryq:					; ...
		cmp	ah, 'Q'         ; country command
					; CONFIG_COUNTRY
		jz	short tryq_cont
		jmp	tryf
; ---------------------------------------------------------------------------

tryq_cont:				; ...
		mov	byte ptr cs:cntry_drv, 0 ; reset the drive,path	to default value
		mov	cs:p_code_page,	0
		mov	di, offset cntry_parms
		xor	cx, cx
		mov	dx, cx

do52:					; ...
		call	sysinit_parse
		jnb	short if52
		call	cntry_error
		mov	cs:p_cntry_code, 0FFFFh	; show message and end the search loop
					; signals that parse error
		jmp	short sr52	; then end the search loop
; ---------------------------------------------------------------------------

if52:					; ...
		cmp	ax, 0FFFFh	; _$P_RC_EOL
					; end of line?
		jz	short sr52
		cmp	cs:result_val, 1 ; [cs:result_val+_$P_Result_Blk.Type],
					; _$P_number ; numeric?
		jnz	short if56
		mov	ax, word ptr cs:rv_dword ; [cs:result_val+_$P_Result_Blk.Picked_Val]
		cmp	cx, 1
		jnz	short if57
		mov	cs:p_cntry_code, ax
		jmp	short en57
; ---------------------------------------------------------------------------

if57:					; ...
		mov	cs:p_code_page,	ax

en57:					; ...
		jmp	short en56
; ---------------------------------------------------------------------------

if56:					; ...
		push	ds
		push	es
		push	si
		push	di
		push	cs
		pop	es
		lds	si, cs:rv_dword
		mov	di, offset cntry_drv ; "A:"
		call	move_asciiz
		pop	di
		pop	si
		pop	es
		pop	ds

en56:					; ...
		jmp	short do52
; ---------------------------------------------------------------------------

sr52:					; ...
		cmp	cs:p_cntry_code, 0FFFFh	; had a	parse error?
		jnz	short tryq_open
		jmp	coff
; ---------------------------------------------------------------------------

tryqbad:				; ...
		stc
		mov	dx, offset badcountry ;	"\r\nInvalid country code or code page\r"...
		jmp	tryqchkerr
; ---------------------------------------------------------------------------

tryq_open:				; ...
		cmp	byte ptr cs:cntry_drv, 0 ; "A:"
		jz	short tryq_def
		mov	dx, offset cntry_drv ; "A:"
		jmp	short tryq_openit
; ---------------------------------------------------------------------------

tryq_def:				; ...
		mov	dx, offset cntry_root

tryq_openit:				; ...
		mov	ax, 3D00h
		stc
		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
					; DS:DX	-> ASCIZ filename
					; AL = access mode
					; 0 - read
		jb	short tryqfilebad
		mov	cs:cntryfilehandle, ax ; save file handle
		mov	bx, ax
		mov	ax, cs:p_cntry_code
		mov	dx, cs:p_code_page ; now,ax=country id,bx=filehandle
		mov	cx, cs:memhi
		add	cx, 384		; need 6k buffer to handle country.sys
		cmp	cx, cs:ALLOCLIM
		ja	short tryqmemory ; cannot allocate the buffer for country.sys
		mov	si, offset cntry_drv ; ds:si ->	cntry_drv
		cmp	byte ptr [si], 0 ; default path?
		jnz	short tryq_set_for_dos
		inc	si
		inc	si

tryq_set_for_dos:			; ...
		les	di, cs:sysi_country
		push	di
		add	di, 8		; country_cdpg_info.ccPath_CountrySys
		call	move_asciiz	; set the path to country.sys in dos
		pop	di		; es:di	-> country info	tab again.
		mov	cx, cs:memhi
		mov	ds, cx
		xor	si, si		; ds:si	-> 2k buffer to	be used
		call	setdoscountryinfo ; now	do the job!!!
		jnb	short tryqchkerr
		cmp	cx, 0FFFFh
		jz	short tryqbad

tryqfilebad:				; ...
		push	cs
		pop	es
		cmp	byte ptr cs:cntry_drv, 0 ; is the default file used?
		jz	short tryqdefbad
		mov	si, offset cntry_drv ; "A:"
		jmp	short tryqbadload
; ---------------------------------------------------------------------------

tryqdefbad:				; ...
		mov	si, offset cntry_root ;	es:si -> \country.sys in sysinit_seg

tryqbadload:				; ...
		call	badload
		mov	cx, cs:top_of_cdss
		mov	es, cx
		jmp	short coffj4
; ---------------------------------------------------------------------------

tryqmemory:				; ...
		mov	dx, offset insufmemory ; "\r\nInsufficient memory for COUNTRY.SYS"...

tryqchkerr:				; ...
		mov	cx, cs:top_of_cdss
		mov	es, cx
		push	cs
		pop	ds
		jnb	short coffj4
		call	print
		call	error_line

coffj4:					; ...
		mov	bx, cs:cntryfilehandle
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		jmp	coff		; close	a file.
multi_pass	endp			; don't care even if it fails.


; =============== S U B	R O U T	I N E =======================================


cntry_error	proc near		; ...
		cmp	ax, 6		; _$P_Out_Of_Range
		jnz	short if64
		mov	dx, offset badcountry ;	"\r\nInvalid country code or code page\r"...
		jmp	short en64
; ---------------------------------------------------------------------------

if64:					; ...
		mov	dx, offset badcountrycom ; "\r\nError in COUNTRY command\r\n$"

en64:					; ...
		call	print
		call	error_line
		retn
cntry_error	endp

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR multi_pass

tryf:					; ...
		cmp	ah, 'F'         ; files command
					; CONFIG_FILES
		jnz	short tryl
		mov	di, offset files_parms
		xor	cx, cx
		mov	dx, cx

do67:					; ...
		call	sysinit_parse
		jnb	short if67
		call	badparm_p
		jmp	short sr67
; ---------------------------------------------------------------------------

if67:					; ...
		cmp	ax, 0FFFFh	; _$P_RC_EOL
					; end of line?
		jz	short en67	; then end the $endloop
		mov	al, byte ptr cs:rv_dword ; [cs:result_val+_$P_Result_Blk.Picked_Val]
		mov	cs:p_files, al	; save it temporarily
		jmp	short do67
; ---------------------------------------------------------------------------

en67:					; ...
		mov	al, cs:p_files
		mov	cs:FILES, al	; no error. really set the value now.

sr67:					; ...
		jmp	coff
; ---------------------------------------------------------------------------

tryl:					; ...
		cmp	ah, 'L'         ; lastdrive command
					; CONFIG_LASTDRIVE
		jnz	short tryp
		mov	di, offset ldrv_parms
		xor	cx, cx
		mov	dx, cx

do73:					; ...
		call	sysinit_parse
		jnb	short if73
		call	badparm_p
		jmp	short sr73
; ---------------------------------------------------------------------------

if73:					; ...
		cmp	ax, 0FFFFh	; _$P_RC_EOL
		jz	short en73
		mov	al, byte ptr cs:rv_dword ; [cs:rv_byte]
					; pick up drive	number
		mov	cs:p_ldrv, al	; save it temporarily
		jmp	short do73
; ---------------------------------------------------------------------------

en73:					; ...
		mov	al, cs:p_ldrv
		mov	cs:NUM_CDS, al	; no error. really set the value now.

sr73:					; ...
		jmp	coff
; ---------------------------------------------------------------------------

tryp:					; ...
		cmp	ah, 'P'         ; setting drive parameters
					; CONFIG_DRIVPARM
		jnz	short tryk
		call	parseline
		jb	short trypbad
		call	setparms
		call	diddleback
		jb	short trypbad
		jmp	coff
; ---------------------------------------------------------------------------

trypbad:				; ...
		jmp	badop
; ---------------------------------------------------------------------------

tryk:					; ...
		cmp	ah, 'K'         ; setting internal stack parameters
					; CONFIG_STACKS
		jz	short do_tryk
		jmp	trys
; ---------------------------------------------------------------------------

do_tryk:				; ...
		mov	di, offset stks_parms
		xor	cx, cx
		mov	dx, cx

do79:					; ...
		call	sysinit_parse
		jnb	short if79
		mov	dx, offset badstack ; "\r\nInvalid STACK parameters\r\n$"
		call	print
		call	error_line
		jmp	sr79
; ---------------------------------------------------------------------------

if79:					; ...
		cmp	ax, 0FFFFh	; _$P_RC_EOL
		jz	short en79
		mov	ax, word ptr cs:rv_dword ; [cs:result_val+_$P_Result_Blk.Picked_Val]
		cmp	cx, 1
		jnz	short if83
		mov	cs:p_stack_count, ax
		jmp	short en83
; ---------------------------------------------------------------------------

if83:					; ...
		mov	cs:p_stack_size, ax

en83:					; ...
		jmp	short do79
; ---------------------------------------------------------------------------

en79:					; ...
		cmp	cs:p_stack_count, 0
		jz	short if87
		cmp	cs:p_stack_count, 8 ; mincount
		jb	short ll88
		cmp	cs:p_stack_size, 32 ; minsize
		jnb	short if88

ll88:					; ...
		mov	cs:p_stack_count, 0FFFFh ; invalid

if88:					; ...
		jmp	short en87
; ---------------------------------------------------------------------------

if87:					; ...
		cmp	cs:p_stack_size, 0
		jz	short en87
		mov	cs:p_stack_count, 0FFFFh ; invalid

en87:					; ...
		cmp	cs:p_stack_count, 0FFFFh ; invalid?
		jnz	short if94
		mov	cs:stack_count,	9 ; defaultcount
					; reset	to default value.
		mov	cs:stack_size, 128 ; defaultsize
		mov	word ptr cs:stack_addr,	0
		mov	dx, offset badstack ; "\r\nInvalid STACK parameters\r\n$"
		call	print
		call	error_line
		jmp	short sr79
; ---------------------------------------------------------------------------

if94:					; ...
		mov	ax, cs:p_stack_count
		mov	cs:stack_count,	ax
		mov	ax, cs:p_stack_size
		mov	cs:stack_size, ax
		mov	word ptr cs:stack_addr,	0FFFFh ; -1
					; stacks= been accepted.

sr79:					; ...
		jmp	coff
; ---------------------------------------------------------------------------

trys:					; ...
		cmp	ah, 'S'         ; shell command
					; CONFIG_SHELL
		jnz	short tryx
		mov	cs:command_line+1, 0 ; zap length,first	byte of	command-line
		mov	di, (offset commnd+1) ;	we already have	the first char
		mov	[di-1],	al	; of the new shell in AL, save it now

storeshell:				; ...
		call	getchr
		or	al, al		; this is the normal case: "organize"
		jz	short getshparms ; put a ZERO right after the filename
		cmp	al, 20h	; ' '   ; this may happen if there are no args
		jb	short endofshell ; I suppose...
		mov	[di], al
		inc	di
		jmp	short storeshell
; ---------------------------------------------------------------------------

endofshell:				; ...
		mov	byte ptr [di], 0 ;  zero-terminate the filename	(or
					; the command-line as the case may be)
		call	getchr
		cmp	al, 0Ah		; lf
		jnz	short endofline
		call	getchr

endofline:				; ...
		jmp	conflp
; ---------------------------------------------------------------------------

getshparms:				; ...
		mov	byte ptr [di], 0 ; zero-terminate the filename
		mov	di, (offset command_line+1) ; prepare to process the command-line

parmloop:				; ...
		call	getchr
		cmp	al, 20h	; ' '
		jb	short endofshell
		mov	[di], al
		inc	di
		jmp	short parmloop
; ---------------------------------------------------------------------------

tryx:					; ...
		cmp	ah, 'X'         ; fcbs command
					; CONFIG_FCBS
		jnz	short tryy
		mov	di, offset fcbs_parms
		xor	cx, cx
		mov	dx, cx

do98:					; ...
		call	sysinit_parse
		jnb	short if98
		call	badparm_p
		jmp	short sr98
; ---------------------------------------------------------------------------

if98:					; ...
		cmp	ax, 0FFFFh	; _$P_RC_EOL
		jz	short en98
		mov	al, byte ptr cs:rv_dword ; [cs:result_val+_$P_Result_Blk.Picked_Val]
		cmp	cx, 1		; the first positional?
		jnz	short if102
		mov	cs:p_fcbs, al
		jmp	short en102
; ---------------------------------------------------------------------------

if102:					; ...
		mov	cs:p_keep, al

en102:					; ...
		jmp	short do98
; ---------------------------------------------------------------------------

en98:					; ...
		mov	al, cs:p_fcbs
		mov	cs:FCBS, al
		mov	cs:KEEP, 0

sr98:					; ...
		jmp	coff
; ---------------------------------------------------------------------------

tryy:					; ...
		cmp	ah, 'Y'         ; comment command
					; CONFIG_COMMENT
		jnz	short try0

donothing:				; ...
		dec	cs:chrptr
		inc	cs:count
		jmp	coff
; ---------------------------------------------------------------------------

try0:					; ...
		cmp	ah, '0'         ; rem command
					; CONFIG_REM
		jz	short donothing

try1:					; switches command
		cmp	ah, '1'         ; CONFIG_SWITCHES
		jz	short do_try1

skip_it5:
		jmp	tryz
; ---------------------------------------------------------------------------

do_try1:				; ...
		mov	di, offset swit_parms
		xor	cx, cx
		mov	dx, cx

do110:					; ...
		call	sysinit_parse
		jnb	short if110
		call	badparm_p
		jmp	short sr110
; ---------------------------------------------------------------------------

if110:					; ...
		cmp	ax, 0FFFFh	; _$P_RC_EOL
		jz	short en110	; jmp to $endloop for semantic check
		cmp	cs:result_val_swoff, offset swit_k ; [cs:result_val+_$P_Result_Blk.SYNONYM_Ptr]
		jnz	short if115
		mov	cs:p_swit_k, 1
		jmp	short do110
; ---------------------------------------------------------------------------

if115:					; ...
		cmp	cs:result_val_swoff, offset swit_t ; [cs:result_val+_$P_Result_Blk.SYNONYM_Ptr]
		jnz	short if116
		mov	cs:p_swit_t, 1
		jmp	short do110
; ---------------------------------------------------------------------------

if116:					; ...
		cmp	cs:result_val_swoff, offset swit_w ; [cs:result_val+_$P_Result_Blk.SYNONYM_Ptr]
		jnz	short do110
		mov	cs:p_swit_w, 1
		jmp	short do110
; ---------------------------------------------------------------------------

en110:					; ...
		cmp	cs:p_swit_k, 1	;  if /k entered
		push	ds
		mov	ax, 70h		; DOSBIODATASEG
		mov	ds, ax
		assume ds:nothing
		jnz	short if117
		mov	byte ptr ds:4E5h, 0 ; [keyrd_func]
					; use the conventional keyboard	functions
		mov	byte ptr ds:4E6h, 1 ; [keysts_func]

if117:					; ...
		mov	al, cs:p_swit_t
		mov	ds:4F2h, al	; [t_switch]
		cmp	cs:p_swit_w, 0
		jz	short skip_dos_flag
		push	es
		push	bx
		mov	ah, 52h		; GET_IN_VARS
		int	21h		; DOS -	2+ internal - GET LIST OF LISTS
					; Return: ES:BX	-> DOS list of lists
		or	byte ptr es:intret_0B, 2 ; [es:86h]
					; [es:DOS_FLAG_OFFSET],SUPPRESS_WINA20
		pop	bx
		pop	es

skip_dos_flag:				; ...
		pop	ds
		assume ds:nothing

sr110:					; ...
		jmp	coff
; ---------------------------------------------------------------------------

tryz:					; ...
		cmp	ah, 0FFh	; bogus	command
					; null command?
					; (BUGBUG - who	sets FFh anyway?)
		jz	short tryz_donothing
		dec	ds:chrptr
		inc	ds:count
		jmp	short badop
; ---------------------------------------------------------------------------

tryz_donothing:				; ...
		jmp	donothing
; END OF FUNCTION CHUNK	FOR multi_pass

; =============== S U B	R O U T	I N E =======================================


sysinit_parse	proc near		; ...
		push	es
		push	ds
		push	es
		pop	ds
		push	cs
		pop	es
		mov	word ptr cs:badparm_ptr+2, ds
		mov	word ptr cs:badparm_ptr, si
		mov	dx, 0
		call	SysParse
		cmp	ax, 0		; _$P_No_Error
		jz	short ll4
		cmp	ax, 0FFFFh	; _$P_RC_EOL
		jnz	short if4

ll4:					; ...
		clc
		jmp	short en4
; ---------------------------------------------------------------------------

if4:					; ...
		stc

en4:					; ...
		pop	ds
		pop	es
		retn
sysinit_parse	endp

; ---------------------------------------------------------------------------

badop_p:
		push	cs
		pop	ds
		mov	dx, offset badopm ; "\r\nUnrecognized command in CONFIG.SYS"
		call	print
		call	error_line
		retn
; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR multi_pass

badop:					; ...
		mov	dx, offset badopm ; "\r\nUnrecognized command in CONFIG.SYS"
		call	print
		call	error_line
		jmp	coff
; END OF FUNCTION CHUNK	FOR multi_pass

; =============== S U B	R O U T	I N E =======================================


badparm_p	proc near		; ...
		push	ds
		push	dx
		push	si
		push	cs
		pop	ds
		mov	dx, offset badparm ; "\r\nBad command or parameters - $"
		call	print
		lds	si, ds:badparm_ptr

do1:					; ...
		mov	dl, [si]
		cmp	dl, 0Dh		; cr
		jz	short en1
		mov	ah, 2		; STD_CON_OUTPUT
		int	21h		; DOS -	DISPLAY	OUTPUT
					; DL = character to send to standard output
		inc	si
		jmp	short do1
; ---------------------------------------------------------------------------

en1:					; ...
		push	cs
		pop	ds
		mov	dx, offset crlfm ; "\r\n$"
		call	print
		call	error_line
		pop	si
		pop	dx
		pop	ds
		retn
badparm_p	endp


; =============== S U B	R O U T	I N E =======================================


getchr		proc near		; ...
		push	cx
		mov	cx, ds:count
		jcxz	short nochar
		mov	si, ds:chrptr
		mov	al, es:[si]
		dec	ds:count
		inc	ds:chrptr
		clc

get_ret:				; ...
		pop	cx
		retn
; ---------------------------------------------------------------------------

nochar:					; ...
		stc
		jmp	short get_ret
getchr		endp

; ---------------------------------------------------------------------------

incorrect_order:			; "\r\nIncorrect order in CONFIG.SYS line "...
		mov	dx, offset badorder
		call	print
		call	showlinenum
		retn

; =============== S U B	R O U T	I N E =======================================


error_line	proc near		; ...
		push	cs
		pop	ds
		mov	dx, offset errorcmd ; "Error in	CONFIG.SYS line	$"
		call	print
		call	showlinenum
		retn
error_line	endp


; =============== S U B	R O U T	I N E =======================================


showlinenum	proc near		; ...
		push	es
		push	ds
		push	di
		push	cs
		pop	es
		push	cs
		pop	ds
		mov	di, (offset showcount+4) ; di -> the least significant decimal field.
		mov	cx, 10		;  decimal divide factor
		mov	ax, cs:linecount

sln_loop:				; ...
		cmp	ax, 10
		jb	short sln_last
		xor	dx, dx
		div	cx
		or	dl, '0'         ; add "0" (= 30h) to make it an ascii.
		mov	[di], dl
		dec	di
		jmp	short sln_loop
; ---------------------------------------------------------------------------

sln_last:				; ...
		or	al, '0'
		mov	[di], al
		mov	dx, di
		call	print		; show it.
		pop	di
		pop	ds
		pop	es
		retn
showlinenum	endp


; =============== S U B	R O U T	I N E =======================================


ProcDOS		proc near		; ...
		xor	ah, ah
		mov	al, cs:result_val_itag ; [cs:result_val+_$P_Result_Blk.Item_Tag]
		dec	ax
		jz	short pd_hi
		dec	ax
		jz	short pd_lo
		dec	ax
		jz	short pd_umb
		mov	cs:DevUMB, 0
		retn
; ---------------------------------------------------------------------------

pd_umb:					; ...
		mov	cs:DevUMB, 0FFh
		retn
; ---------------------------------------------------------------------------

pd_lo:					; ...
		mov	cs:runhigh, 0
		retn
; ---------------------------------------------------------------------------

pd_hi:					; ...
		mov	cs:runhigh, 0FFh
		retn
ProcDOS		endp


; =============== S U B	R O U T	I N E =======================================


LieInt12Mem	proc near		; ...
		mov	ax, cs:ALLOCLIM	; lie INT 12 as	alloclim
		call	IsIt3Com	; Is it	3Com driver?
		jz	short lim_set	; yes, lie to him differently
		cmp	cs:DeviceHi, 0	;  Is the DD being loaded in UMB
		jz	short limx	; no, don't lie
		mov	ax, cs:DevLoadEnd ; lie	INT 12 as end of UMB

lim_set:				; ...
		call	SetInt12Mem

limx:					; ...
		retn
LieInt12Mem	endp


; =============== S U B	R O U T	I N E =======================================


SetInt12Mem	proc near		; ...
		push	ds
		mov	bx, 40h
		mov	ds, bx		; ROM BIOS Data	Segment
		assume ds:nothing
		mov	bx, ds:13h	; INT 12 memory	variable
		mov	cs:OldInt12Mem,	bx
		mov	cl, 6
		shr	ax, cl		; convert paras	into Ks
		mov	ds:13h,	ax	; Lie
		mov	cs:Int12Lied, 0FFh ; mark that we are lying
		pop	ds
		assume ds:nothing
		retn
SetInt12Mem	endp


; =============== S U B	R O U T	I N E =======================================


TrueInt12Mem	proc near		; ...
		cmp	cs:Int12Lied, 0	; were we lying	so far?
		mov	cs:Int12Lied, 0	; reset	it anyway
		jz	short timx	; no, we weren't
		push	ds
		mov	ax, 40h
		mov	ds, ax
		assume ds:nothing
		mov	ax, cs:OldInt12Mem
		mov	ds:13h,	ax
		pop	ds
		assume ds:nothing

timx:					; ...
		retn
TrueInt12Mem	endp


; =============== S U B	R O U T	I N E =======================================


IsIt3Com	proc near		; ...
		push	ds
		push	es
		push	si
		lds	si, cs:DevEntry	; ptr to device	header
		add	si, 10		; SYSDEV.NAME
		push	cs
		pop	es
		mov	di, offset ThreeComName	; "PROTMAN$"
		mov	cx, 8		; name length
		repe cmpsb
		pop	si
		pop	es
		pop	ds
		retn
IsIt3Com	endp


; =============== S U B	R O U T	I N E =======================================


UpdatePDB	proc near		; ...
		push	ds
		mov	ah, 62h
		int	21h		; DOS -	3+ - GET PSP ADDRESS
		mov	ds, bx
		mov	bx, cs:ALLOCLIM
		mov	ds:stackcount, bx ; [PDB.BLOCK_LEN]
		pop	ds
		retn
UpdatePDB	endp


; =============== S U B	R O U T	I N E =======================================


InitDevLoad	proc near		; ...
		cmp	cs:DeviceHi, 0	; Are we loading in UMB	?
		jz	short InitForLo	; no, init for lo mem

InitForConv:				; Do we	have space left	in the
		call	SpaceInUMB	; current UMB ?
		jnb	short InitForHi	; yes, we have
		call	ShrinkUMB	; shrink the current UMB in use
		call	GetUMBForDev	; else try to allocate new UMB
		jb	short InitForLo	; we didn't succeed, so load
					; in low memory

InitForHi:				; ...
		mov	ax, cs:DevUMBFree ; get	Para addr of free mem
		mov	dx, cs:DevUMBAddr ; UMB	start addr
		add	dx, cs:DevUMBSize ; DX = UMB End addr
		jmp	short idl1
; ---------------------------------------------------------------------------

InitForLo:				; ...
		mov	cs:DeviceHi, 0	; in case we failed to load
					; into UMB indicate that
					; we are loading low
		mov	ax, cs:memhi	; AX = start of	Low memory
		mov	dx, cs:ALLOCLIM	; DX = End of Low memory

idl1:					; ...
		call	DevSetMark	; setup	a sub-arena for	DD
		mov	cs:DevLoadAddr,	ax ; init the Device load address
		mov	cs:DevLoadEnd, dx ; init the limit of the block
		mov	word ptr cs:DevEntry, 0	; init Entry point to DD
		mov	word ptr cs:DevEntry+2,	ax
		retn
InitDevLoad	endp


; =============== S U B	R O U T	I N E =======================================


SpaceInUMB	proc near		; ...
		mov	ax, cs:DevUMBSize
		add	ax, cs:DevUMBAddr ; End	of UMB
		sub	ax, cs:DevUMBFree ; - Free = Remaining space
		or	ax, ax		; Nospace ?
		jnz	short spcinumb1
		stc
		retn
; ---------------------------------------------------------------------------

spcinumb1:				; ...
		dec	ax		; space	for sub-arena
		cmp	ax, cs:DevSize	; do we	have space ?
		retn
SpaceInUMB	endp


; =============== S U B	R O U T	I N E =======================================


GetUMBForDev	proc near		; ...
		mov	bx, 0FFFFh
		mov	ax, 4800h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		or	bx, bx
		jz	short gufd_err
		dec	bx
		cmp	cs:DevSize, bx
		ja	short gufd_err
		inc	bx
		mov	ax, 4800h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		jb	short gufd_err
		push	ds
		dec	ax
		mov	ds, ax
		assume ds:nothing
		mov	word ptr ds:1, 8 ; [ARENA.OWNER]
		mov	word ptr ds:8, 4453h ; 'SD'
					; [ARENA.NAME]
		inc	ax
		pop	ds
		assume ds:nothing
		mov	cs:DevUMBSize, bx
		mov	cs:DevUMBAddr, ax
		mov	cs:DevUMBFree, ax
		clc
		retn
; ---------------------------------------------------------------------------

gufd_err:				; ...
		xor	ax, ax
		mov	cs:DevUMBSize, ax
		mov	cs:DevUMBAddr, ax
		mov	cs:DevUMBFree, ax
		stc
		retn
GetUMBForDev	endp


; =============== S U B	R O U T	I N E =======================================


DevSetMark	proc near		; ...
		push	es
		push	di
		push	ds
		push	si
		mov	es, ax
		mov	byte ptr es:SYSINIT$, 'D' ; [es:devmark.id],
					; devmark_device
		inc	ax
		mov	es:SYSINIT$+1, ax ; [es:devmark.seg]
		push	ax
		lds	si, dword ptr cs:bpb_addr ; command line is still there
		mov	di, si
		cld

dsm_again:				; ...
		lodsb
		cmp	al, ':'
		jnz	short isit_slash
		mov	di, si
		jmp	short dsm_again
; ---------------------------------------------------------------------------

isit_slash:				; ...
		cmp	al, '\'
		jnz	short isit_null
		mov	di, si
		jmp	short dsm_again
; ---------------------------------------------------------------------------

isit_null:				; ...
		or	al, al
		jnz	short dsm_again
		mov	si, di
		mov	di, 8		; devmark.filename
		mov	cx, 8		; maximum 8 characters

dsm_next_char:				; ...
		lodsb
		or	al, al
		jz	short blankout
		cmp	al, '.'
		jz	short blankout
		stosb
		loop	dsm_next_char

blankout:				; ...
		jcxz	short dsm_exit
		mov	al, 20h	; ' '
		rep stosb		; blank	out the	rest

dsm_exit:				; ...
		pop	ax
		pop	si
		pop	ds
		pop	di
		pop	es
		retn
DevSetMark	endp


; =============== S U B	R O U T	I N E =======================================


SizeDevice	proc near		; ...
		push	es
		pop	ds
		mov	dx, si
		mov	ax, 3D00h
		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
					; DS:DX	-> ASCIZ filename
					; AL = access mode
					; 0 - read
		jb	short sd_err
		mov	bx, ax
		mov	ax, 4202h	; seek
		xor	cx, cx
		mov	dx, cx		; to end of file
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from end of file
		jb	short sd_close	; did seek fail	(impossible)
		add	ax, 15		; para convert
		adc	dx, 0
		test	dx, 0FFF0h	; size > 0ffff paras ?
		jz	short szdev1	; no
		mov	cs:DevSize, 0FFFFh ; invalid device size
		jmp	short sd_close	; assuming that	we fail	later
; ---------------------------------------------------------------------------

szdev1:					; ...
		mov	cl, 4		; convert it to	paras
		shr	ax, cl
		mov	cl, 12
		shl	dx, cl
		or	ax, dx
		cmp	ax, cs:DevSizeOption
		ja	short szdev2
		mov	ax, cs:DevSizeOption

szdev2:					; ...
		mov	cs:DevSize, ax	; save file size
		clc

sd_close:				; ...
		pushf
		mov	ax, 3E00h
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		popf

sd_err:					; ...
		retn
SizeDevice	endp


; =============== S U B	R O U T	I N E =======================================


ExecDev		proc near		; ...
		mov	bx, cs:DevLoadAddr
		mov	cs:DevExecAddr,	bx
		mov	cs:DevExecReloc, bx
		mov	bx, cs
		mov	es, bx
		mov	bx, offset DevExecAddr
		mov	al, 3
		mov	ah, 4Bh
		int	21h		; DOS -	2+ - LOAD OR EXECUTE (EXEC)
					; DS:DX	-> ASCIZ filename
					; ES:BX	-> parameter block
					; AL = subfunc:	called by MSC spawn(P_NOWAIT,...) when running DOS 4.x.
		retn
ExecDev		endp


; =============== S U B	R O U T	I N E =======================================


RemoveNull	proc near		; ...
		mov	bl, es:[si]
		or	bl, bl		; null ?
		jz	short rn_gotnull
		inc	si
		jmp	short RemoveNull
; ---------------------------------------------------------------------------

rn_gotnull:				; ...
		mov	bl, cs:DevSavedDelim
		mov	es:[si], bl	; replace null with blank
		retn
RemoveNull	endp


; =============== S U B	R O U T	I N E =======================================


RoundBreakAddr	proc near		; ...
		mov	ax, word ptr cs:DevBrkAddr
		call	ParaRound
		add	word ptr cs:DevBrkAddr+2, ax
		mov	word ptr cs:DevBrkAddr,	0
		mov	ax, cs:DevLoadEnd
		cmp	word ptr cs:DevBrkAddr+2, ax
		jbe	short rba_ok
		jmp	memerr
; ---------------------------------------------------------------------------

rba_ok:					; ...
		retn
RoundBreakAddr	endp


; =============== S U B	R O U T	I N E =======================================


DevSetBreak	proc near		; ...
		push	ax
		mov	ax, word ptr cs:DevBrkAddr+2 ; remove the init code
		cmp	cs:multdeviceflag, 0
		jnz	short set_break_continue ; do not check	it.
		cmp	ax, cs:DevLoadAddr
		jnz	short set_break_continue ; if not same,	then o.k.
		cmp	word ptr cs:DevBrkAddr,	0
		jz	short break_failed ; [DevBrkAddr+2]=[memhi] & [DevBrkAddr]=0

set_break_continue:			; ...
		call	RoundBreakAddr
		pop	ax
		clc
		retn
; ---------------------------------------------------------------------------

break_failed:				; ...
		pop	ax
		stc
		retn
DevSetBreak	endp


; =============== S U B	R O U T	I N E =======================================


DevBreak	proc near		; ...
		push	ds
		mov	ax, cs:DevLoadAddr
		mov	bx, word ptr cs:DevBrkAddr+2
		dec	ax		; seg of sub-arena
		mov	ds, ax
		inc	ax		; Back to Device segment
		sub	ax, bx
		neg	ax		; size of device in paras
		mov	ds:stackcount+1, ax ; [devmark.size]
		cmp	cs:DeviceHi, 0
		jz	short db_lo
		mov	cs:DevUMBFree, bx ; update Free	ptr in UMB
		jmp	short db_exit
; ---------------------------------------------------------------------------

db_lo:					; ...
		mov	cs:memhi, bx
		mov	cs:memlo, 0

db_exit:				; ...
		pop	ds
		retn
DevBreak	endp


; =============== S U B	R O U T	I N E =======================================


ParseSize	proc near		; ...
		mov	cs:DevSizeOption, 0 ; init the value
		mov	cs:DevCmdLine, si
		mov	cs:DevCmdLine+2, es
		call	SkipDelim
		cmp	word ptr es:[si], 4953h	; 'SI'
		jnz	short ps_no_size
		cmp	word ptr es:[si+2], 455Ah ; 'ZE'
		jnz	short ps_no_size
		mov	al, es:[si+4]
		call	delim
		jnz	short ps_no_size
		add	si, 5
		call	GetHexNum
		jb	short ps_err
		mov	cs:DevSizeOption, ax
		call	SkipDelim

ps_no_size:				; ...
		clc
		retn
; ---------------------------------------------------------------------------

ps_err:					; ...
		stc
		retn
ParseSize	endp


; =============== S U B	R O U T	I N E =======================================


SkipDelim	proc near		; ...
		mov	al, es:[si]
		call	delim
		jnz	short sd_ret
		inc	si
		jmp	short SkipDelim
; ---------------------------------------------------------------------------

sd_ret:					; ...
		retn
SkipDelim	endp


; =============== S U B	R O U T	I N E =======================================


GetHexNum	proc near		; ...
		xor	ax, ax
		xor	dx, dx

ghn_next:				; ...
		mov	bl, es:[si]
		cmp	bl, 0Dh
		jz	short ghn_err
		cmp	bl, 0Ah
		jz	short ghn_err
		push	ax
		mov	al, bl
		call	delim
		pop	ax
		jz	short ghn_into_paras
		call	GetNibble
		jb	short ghn_err
		mov	cx, 4

ghn_shift1:				; ...
		shl	ax, 1
		rcl	dx, 1
		loop	ghn_shift1
		or	al, bl
		inc	si
		jmp	short ghn_next
; ---------------------------------------------------------------------------

ghn_into_paras:				; ...
		add	ax, 15
		adc	dx, 0
		test	dx, 0FFF0h
		jnz	short ghn_err
		mov	cx, 4

ghn_shift2:				; ...
		clc
		rcr	dx, 1
		rcr	ax, 1
		loop	ghn_shift2
		clc
		retn
; ---------------------------------------------------------------------------

ghn_err:				; ...
		stc
		retn
GetHexNum	endp


; =============== S U B	R O U T	I N E =======================================


GetNibble	proc near		; ...
		cmp	bl, '0'
		jb	short gnib_err
		cmp	bl, '9'
		ja	short is_it_hex
		sub	bl, '0'         ; clc
		retn
; ---------------------------------------------------------------------------

is_it_hex:				; ...
		cmp	bl, 'A'         ; 41h
		jb	short gnib_err
		cmp	bl, 'F'         ; 46h
		ja	short gnib_err
		sub	bl, 37h		; 'A'-10 ; clc
		retn
; ---------------------------------------------------------------------------

gnib_err:				; ...
		stc
		retn
GetNibble	endp


; =============== S U B	R O U T	I N E =======================================


AllocUMB	proc near		; ...
		call	InitAllocUMB	; link in the first UMB
		jb	short au_exit	; quit on error

au_next:				; ...
		call	umb_allocate	; allocate
		jb	short au_coalesce
		call	umb_insert	; & insert till	no UMBs
		jmp	short au_next
; ---------------------------------------------------------------------------

au_coalesce:				; ...
		call	umb_coalesce	; coalesce all UMBs

au_exit:				; ...
		retn
AllocUMB	endp


; =============== S U B	R O U T	I N E =======================================


InitAllocUMB	proc near		; ...
		call	IsXMSLoaded
		jnz	short iau_err	; quit on no XMS driver
		mov	ah, 52h		; get DOS DATA seg
		int	21h		; DOS -	2+ internal - GET LIST OF LISTS
					; Return: ES:BX	-> DOS list of lists
		mov	cs:DevDOSData, es ; & save it for later
		mov	ax, 4310h
		int	2Fh		; - Multiplex -	XMS - GET DRIVER ADDRESS
					; Return: ES:BX	-> driver entry	point
		mov	word ptr cs:DevXMSAddr,	bx
		mov	word ptr cs:DevXMSAddr+2, es
		cmp	cs:FirstUMBLinked, 0 ; have we already linked a	UMB?
		jnz	short ia_1	; quit if we already did it
		call	LinkFirstUMB	; else link the	first UMB
		jb	short iau_err
		mov	cs:FirstUMBLinked, 0FFh	; mark that 1st	UMB linked

ia_1:					; ...
		clc
		retn
; ---------------------------------------------------------------------------

iau_err:				; ...
		stc
		retn
InitAllocUMB	endp


; =============== S U B	R O U T	I N E =======================================


umb_allocate	proc near		; ...
		push	ax
		mov	ah, 10h		; XMM_REQUEST_UMB ; 16
		mov	dx, 0FFFFh	; try to allocate largest possible
		call	cs:DevXMSAddr	; dx now contains the size of
					; the largest UMB
		or	dx, dx
		jz	short ua_err
		mov	ah, 10h		; XMM_REQUEST_UMB ; 16
		call	cs:DevXMSAddr
		cmp	ax, 1		; Q: was the reqst successful
		jnz	short ua_err	; N: error
		clc

ua_done:				; ...
		pop	ax
		retn
; ---------------------------------------------------------------------------

ua_err:					; ...
		stc
		jmp	short ua_done
umb_allocate	endp


; =============== S U B	R O U T	I N E =======================================


umb_insert	proc near		; ...
		push	ds
		mov	ds, cs:DevDOSData
		mov	ds, word ptr ds:old0C+3	; [8Ch]
					; [UMB_ARENA]
		assume ds:nothing
		mov	ax, ds
		mov	es, ax
		assume es:nothing

ui_next:				; ...
		cmp	ax, bx		; Q: is	current	block above
					; new block
		ja	short ui_insert	; Y: insert it
					;
					; Q: is	current	block the last
		cmp	byte ptr es:0, 'Z' ; [es:ARENA.SIGNATURE],
					; arena_signature_end ;	'Z'
		jz	short ui_append	; Y: append new	block to chain
		mov	ds, ax		; N: get next block
		call	get_next
		jmp	short ui_next
; ---------------------------------------------------------------------------

ui_insert:				; ...
		mov	cx, ds		; ds = previous	arena
		inc	cx		; top of previous block
		sub	cx, bx
		neg	cx		; cx = size of used block
		mov	byte ptr ds:0, 'M' ; [ARENA.SIGNATURE],
					; arena_signature_normal ; 'M'
		mov	word ptr ds:1, 8 ; [ARENA.OWNER]
					; mark as system owned
		mov	ds:3, cx	; [ARENA.SIZE]
		mov	word ptr ds:8, 4353h ; [ARENA.NAME],
					; 'SC'
		mov	es, bx
		assume es:nothing
		mov	byte ptr es:SYSINIT$, 'M' ; [es:ARENA.SIGNATURE],
					; arena_signature_normal
		mov	es:SYSINIT$+1, 0 ; [es:ARENA.OWNER],
					; arena_owner_system
					; mark as free
		sub	dx, 2		; make room for	arena at
					; start	& end of new block
		mov	es:stackcount+1, dx ; [es:ARENA.SIZE]
		add	bx, dx
		inc	bx
		mov	es, bx		; es=arena at top of new block
		inc	bx		; ax contains arena just above this block
		sub	ax, bx		; ax = size of used block
		mov	byte ptr es:SYSINIT$, 4Dh ; 'M' ; [es:ARENA.SIGNATURE],
					; arena_signature_normal
		mov	es:SYSINIT$+1, 8 ; [es:ARENA.OWNER]
					; mark as system owned
		mov	es:stackcount+1, ax ; [es:ARENA.SIZE]
		mov	word ptr es:stacks, 4353h ; 'SC'
					; [es:ARENA.NAME]
		jmp	short ui_done
; ---------------------------------------------------------------------------

ui_append:				; ...
		add	ax, es:stackcount+1 ; [es:ARENA.SIZE]
					; ax=top of last block-1 para
		sub	es:stackcount+1, 1 ; reflect the space we are
					; going	to rsrv	on top of this block
					; for the next arena.
		mov	byte ptr es:SYSINIT$, 'M' ; [es:ARENA.SIGNATURE],
					; arena_signature_normal
		mov	cx, ax		; cx=top of prev block-1
		inc	ax
		sub	ax, bx		; ax=top of prev block -
					;    seg. address of new block
		neg	ax
		mov	es, cx		; ds = arena of	unused block
		mov	byte ptr es:SYSINIT$, 'M'
		mov	es:SYSINIT$+1, 8
		mov	es:stackcount+1, ax
		mov	word ptr es:stacks, 4353h ; 'SC'
		mov	es, bx
		mov	byte ptr es:SYSINIT$, 5Ah ; 'Z' ; [es:ARENA.SIGNATURE],
					; arena_signature_end
		mov	es:SYSINIT$+1, 0 ; arena_owner_system
					;  mark	as free
		dec	dx		; make room for	arena
		mov	es:stackcount+1, dx ; [es:ARENA.SIZE]

ui_done:				; ...
		pop	ds
		assume ds:nothing
		retn
umb_insert	endp


; =============== S U B	R O U T	I N E =======================================


umb_coalesce	proc near		; ...
		xor	di, di
		mov	es, cs:DevDOSData
		mov	es, word ptr es:old0C+3	; [es:UMB_ARENA]
					; es = UMB_HEAD
		assume es:nothing

uc_nextfree:				; ...
		mov	ax, es
		mov	ds, ax
		assume ds:nothing
		cmp	es:1, di	; [es:ARENA.OWNER]
					; Q: is	current	arena free
		jz	short uc_again	; Y: try to coalesce with next block
					; N: get next arena
		call	get_next	; es, ax = next	arena
		jb	short uc_done
		jmp	short uc_nextfree
; ---------------------------------------------------------------------------

uc_again:				; ...
		call	get_next	; ES, AX <- next block
		jb	short uc_done
		cmp	es:1, di	; [es:ARENA.OWNER]
					; Q: is	arena free
		jnz	short uc_nextfree
		mov	cx, es:3	; [es:ARENA.SIZE]
					; cx <-	next block size
		inc	cx		; cx <-	cx + 1 (for header size)
		add	ds:3, cx	; [ARENA.SIZE]
					; current size <- current size + cx
		mov	cl, es:[di]	; move up signature
		mov	[di], cl
		jmp	short uc_again	; try again
; ---------------------------------------------------------------------------

uc_done:				; ...
		retn
umb_coalesce	endp


; =============== S U B	R O U T	I N E =======================================


get_next	proc near		; ...
		cmp	byte ptr ds:0, 5Ah ; 'Z' ; arena_signature_end
		jz	short gn_err
		mov	ax, ds		; ax=current block
		add	ax, ds:3	; [ARENA.SIZE]
					; ax=ax	+ current block	length
		inc	ax
		mov	es, ax
		assume es:nothing
		clc
		retn
; ---------------------------------------------------------------------------

gn_err:					; ...
		stc
		retn
get_next	endp


; =============== S U B	R O U T	I N E =======================================


LinkFirstUMB	proc near		; ...
		call	umb_allocate
		jb	short lfu_err
		int	12h		; MEMORY SIZE -
					; Return: AX = number of contiguous 1K blocks of memory
		mov	cl, 6
		shl	ax, cl		; ax = size in paragraphs
		mov	cx, ax		; bx = segment of allocated UMB
					; dx = size of UMB
		sub	ax, bx
		neg	ax
		sub	cx, 1		; cx = first umb_arena
		mov	es, cx		; es = first umb_arena
		mov	byte ptr es:SYSINIT$, 4Dh ; 'M' ; [es:ARENA.SIGNATURE],
					; arena_signature_normal
		mov	es:SYSINIT$+1, 8
		mov	es:stackcount+1, ax ; [es:ARENA.SIZE]
		mov	word ptr es:stacks, 4353h ; 'SC'
					; [es:ARENA.NAME]
		mov	es, bx		; es has first free umb	seg
		mov	byte ptr es:SYSINIT$, 5Ah ; 'Z' ; [es:ARENA.SIGNATURE],
					; arena_signature_end
		mov	es:SYSINIT$+1, 0 ; [es:ARENA.OWNER],
					; arena_owner_system ; 0
					; mark as free
		dec	dx		; make room for	arena
		mov	es:stackcount+1, dx ; [es:ARENA.SIZE]
		mov	es, cs:DevDOSData
		mov	di, 8Ch		; UMB_ARENA
		mov	es:[di], cx	; initialize umb_head in DOS data segment
					; with the arena just below Top	of Mem
		mov	di, 24h		; DOS_ARENA
		mov	es, word ptr es:[di] ; es = start arena
		xor	di, di

scan_next:				; ...
		cmp	byte ptr es:[di], 'Z' ; arena_signature_end
		jz	short got_last
		mov	ax, es
		add	ax, es:stackcount+1 ; [es:ARENA.SIZE]
		inc	ax
		mov	es, ax
		jmp	short scan_next
; ---------------------------------------------------------------------------

got_last:				; ...
		sub	es:stackcount+1, 1 ; [es:3]
					; [es:ARENA.SIZE]
		mov	byte ptr es:SYSINIT$, 'M' ; [es:ARENA.SIGNATURE],
					; arena_signature_normal
		clc
		retn
; ---------------------------------------------------------------------------

lfu_err:				; ...
		stc
		retn
LinkFirstUMB	endp


; =============== S U B	R O U T	I N E =======================================


ShrinkUMB	proc near		; ...
		cmp	cs:DevUMBAddr, 0
		jz	short su_exit
		push	es
		push	bx
		mov	bx, cs:DevUMBFree
		sub	bx, cs:DevUMBAddr
		mov	es, cs:DevUMBAddr
		mov	ax, 4A00h
		int	21h		; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
					; ES = segment address of block	to change
					; BX = new size	in paragraphs
		mov	ax, es
		dec	ax
		mov	es, ax
		mov	es:SYSINIT$+1, 8 ; [es:1]
					; [es:ARENA.OWNER]
		pop	bx
		pop	es

su_exit:				; ...
		retn
ShrinkUMB	endp


; =============== S U B	R O U T	I N E =======================================


UnlinkUMB	proc near		; ...
		push	ds
		push	es
		cmp	cs:FirstUMBLinked, 0
		jz	short ulu_x	; nothing to unlink
		mov	es, cs:DevDOSData ; get	DOS data seg
		mov	ds, word ptr es:loc_24 ; [es:24h]
					; [es:DOS_ARENA]
		assume ds:nothing
		mov	di, word ptr es:old0C+3	; [es:8Ch]
					; [es:UMB_ARENA]

ulu_next:				; ...
		call	get_next
		jb	short ulu_x
		cmp	di, ax
		jz	short ulu_found
		mov	ds, ax
		assume ds:nothing
		jmp	short ulu_next
; ---------------------------------------------------------------------------

ulu_found:				; ...
		mov	byte ptr ds:SYSINIT$, 'Z' ; [ARENA.SIGNATURE],
					; arena_signature_end

ulu_x:					; ...
		pop	es
		pop	ds
		retn
UnlinkUMB	endp

; ---------------------------------------------------------------------------
insert_blank	db 0			; ...

; =============== S U B	R O U T	I N E =======================================


setparms	proc near		; ...
		push	ds
		push	ax
		push	bx
		push	cx
		push	dx
		push	cs
		pop	ds
		xor	bx, bx
		mov	bl, ds:drive
		inc	bl		; get it correct for ioctl call
					; (1=a,2=b...)
		mov	dx, offset devp_specialfunc ; deviceparameters
		mov	ah, 44h		; IOCTL
		mov	al, 0Dh		; GENERIC_IOCTL
		mov	ch, 8		; RAWIO
		mov	cl, 40h		; SET_DEVICE_PARAMETERS
		int	21h		; DOS -	2+ - IOCTL -
		test	ds:switches, 4	; flagec35
		jz	short eot_ok
		mov	cl, ds:drive	; which	drive was this for?
		mov	ax, 70h
		mov	ds, ax		; DOSBIODATASEG
		assume ds:nothing
		mov	al, 1		; assume drive 0
		shl	al, cl		; set proper bit depending on drive
		or	ds:531h, al	; [ec35_flag]
					; set the bit in the permanent flags

eot_ok:					; ...
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		pop	ds
		assume ds:nothing
		retn
setparms	endp


; =============== S U B	R O U T	I N E =======================================


diddleback	proc near		; ...
		push	ds
		push	cs
		pop	ds
		mov	ds:devp_cylinders, 80 ;	[deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS]
		mov	ds:devp_devtype, 2 ; [deviceparameters+A_DEVICEPARAMETERS.DP_DEVICETYPE],
					; DEV_3INCH720KB
		mov	ds:devp_devattr, 0 ; [deviceparameters+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES]
		mov	ds:switches, 0	; zero all switches
		pop	ds
		retn
diddleback	endp


; =============== S U B	R O U T	I N E =======================================


parseline	proc near		; ...
		push	ds
		push	cs
		pop	ds

nextswtch:				; ...
		cmp	al, 0Dh		; carriage return?
		jz	short done_line
		cmp	al, 0Ah		; linefeed?
		jz	short put_back	; put it back and done
		cmp	al, ' '         ; space?
		jbe	short getnext	; skip over space
		cmp	al, '/'
		jz	short getparm
		stc			; mark error invalid-character-in-input
		jmp	short exitpl
; ---------------------------------------------------------------------------

getparm:				; ...
		call	check_switch
		mov	ds:switches, bx	; save switches	read so	far
		jb	short swterr

getnext:				; ...
		call	getchr
		jb	short done_line
		jmp	short nextswtch
; ---------------------------------------------------------------------------

swterr:					; ...
		jmp	short exitpl
; ---------------------------------------------------------------------------

done_line:				; ...
		test	ds:switches, 8	; flagdrive
					; see if drive specified
		jnz	short okay
		stc
		jmp	short exitpl
; ---------------------------------------------------------------------------

okay:					; ...
		mov	ax, ds:switches
		and	ax, 3		; get flag bits	for changeline and non-rem
		mov	ds:devp_devattr, ax ; [deviceparameters+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES]
		mov	word ptr ds:devparms_20+12h, 0
		clc
		call	setdeviceparameters

exitpl:					; ...
		pop	ds
		retn
; ---------------------------------------------------------------------------

put_back:				; ...
		inc	ds:count	; one more char	to scan
		dec	ds:chrptr	; back up over linefeed
		jmp	short done_line
parseline	endp


; =============== S U B	R O U T	I N E =======================================


check_switch	proc near		; ...
		call	getchr
		jb	short err_check
		and	al, 0DFh	; convert it to	upper case
		cmp	al, 'A'
		jb	short err_check
		cmp	al, 'Z'
		ja	short err_check
		push	es
		push	cs
		pop	es
		mov	cl, byte ptr ds:switchlist ; get number	of valid switches
		mov	ch, 0
		mov	di, (offset switchlist+1) ; point to string of valid switches
		repne scasb
		pop	es
		jnz	short err_check
		mov	ax, 1
		shl	ax, cl		; set bit to indicate switch
		mov	bx, ds:switches	; get switches so far
		or	bx, ax		; save this with other switches
		mov	cx, ax
		test	ax, 0F8h	; switchnum
					; test against switches	that require number to follow
		jz	short done_swtch
		call	getchr
		jb	short err_swtch
		cmp	al, ':'
		jnz	short err_swtch
		call	getchr
		push	bx
		mov	cs:sepchr, 20h ; ' ' ; allow space separators
		call	getnum
		mov	cs:sepchr, 0
		pop	bx
		call	process_num

done_swtch:				; ...
		clc
		retn
; ---------------------------------------------------------------------------

err_swtch:				; ...
		xor	bx, cx		; remove this switch from the records

err_check:				; ...
		stc
		retn
check_switch	endp


; =============== S U B	R O U T	I N E =======================================


process_num	proc near		; ...
		test	ds:switches, cx	; if this switch has been done before,
					; ignore this one.
		jnz	short done_ret
		test	cx, 8		; flagdrive
		jz	short try_f
		mov	ds:drive, al
		jmp	short done_ret
; ---------------------------------------------------------------------------

try_f:					; ...
		test	cx, 80h		; flagff
		jz	short try_t	; flagff
		mov	ds:devp_devtype, al ; [deviceparameters+1]
					; [deviceparameters+A_DEVICEPARAMETERS.DP_DEVICETYPE]
		jmp	short done_ret
; ---------------------------------------------------------------------------

try_t:					; ...
		or	ax, ax
		jz	short done_ret	; if number entered was	0, assume default value
		test	cx, 10h		; flagcyln
		jz	short try_s
		mov	ds:devp_cylinders, ax ;	deviceparameters+4] [deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS]
		jmp	short done_ret
; ---------------------------------------------------------------------------

try_s:					; ...
		test	cx, 20h		; flagseclim
		jz	short try_h
		mov	ds:slim, ax
		jmp	short done_ret
; ---------------------------------------------------------------------------

try_h:					; ...
		mov	ds:hlim, ax

done_ret:				; ...
		clc
		retn
process_num	endp


; =============== S U B	R O U T	I N E =======================================


setdeviceparameters proc near		; ...
		push	es
		push	cs
		pop	es
		xor	bx, bx
		mov	bl, ds:devp_devtype ; [deviceparameters+A_DEVICEPARAMETERS.DP_DEVICETYPE]
		cmp	bl, 0		; DEV_5INCH
		jnz	short got_80
		mov	ds:devp_cylinders, 40 ;	[deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS]

got_80:					; ...
		shl	bx, 1		; get index into bpb table
		mov	si, ds:bpbtable[bx] ; [bpbtable+bx]
					; get address of bpb
		mov	di, offset devparms_7 ;	[deviceparameters+7]
					; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB]
					; es:di	-> bpb
		mov	cx, 31		; A_BPB.size
		cld
		rep movsb
		pop	es
		test	ds:switches, 20h ; flagseclim
		jz	short see_heads
		mov	ax, ds:slim
		mov	word ptr ds:devparms_20, ax ; [deviceparameters+20]
					; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_SECTORSPERTRACK]

see_heads:				; ...
		test	ds:switches, 40h ; flagheads
		jz	short heads_not_altered
		mov	ax, ds:hlim
		mov	word ptr ds:devparms_20+2, ax ;	[deviceparameters+22]
					; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_HEADS]

heads_not_altered:			; ...
		mov	ds:devparms_9, 2 ; [deviceparameters+9]
					; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_SECTORSPERCLUSTER]
		mov	bl, 0F0h	; get default mediabyte
		mov	bh, ds:devparms_17 ; [deviceparameters+17]
					; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_MEDIADESCRIPTOR]
		cmp	word ptr ds:devparms_20+2, 2 ; [deviceparameters+22]
		ja	short got_correct_mediad
		jnz	short only_one_head
		mov	bl, bh		; get mediadescriptor from bpb
		cmp	word ptr ds:devparms_20, 18 ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_SECTORSPERTRACK]
		jnz	short not_144m
		cmp	ds:devp_cylinders, 80
		jnz	short not_144m
		jmp	short got_one_secperclus_drive
; ---------------------------------------------------------------------------

not_144m:				; ...
		cmp	ds:devp_cylinders, 40 ;	[deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS]
		jnz	short got_correct_mediad
		cmp	word ptr ds:devparms_20, 8 ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_SECTORSPERTRACK]
		jnz	short got_correct_mediad
		mov	bl, 0FCh
		jmp	short got_correct_mediad
; ---------------------------------------------------------------------------

only_one_head:				; ...
		cmp	ds:devp_devtype, 0 ; [deviceparameters+A_DEVICEPARAMETERS.DP_DEVICETYPE],
					; DEV_5INCH ; 0
		jnz	short got_one_secperclus_drive
		mov	bl, 0FCh	; single sided 9 sector	media id
		cmp	word ptr ds:devparms_20, 8
		jnz	short got_one_secperclus_drive
		mov	bl, 0FEh	; 160K mediaid

got_one_secperclus_drive:		; ...
		mov	ds:devparms_9, 1 ; [deviceparameters+9]
					; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_SECTORSPERCLUSTER]

got_correct_mediad:			; ...
		mov	ds:devparms_17,	bl ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_MEDIADESCRIPTOR]
		mov	ax, ds:devp_cylinders ;	[deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS]
		mul	word ptr ds:devparms_20+2 ; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_HEADS]
		mul	word ptr ds:devparms_20	; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_SECTORSPERTRACK]
		mov	word ptr ds:devparms_9+6, ax ; [deviceparameters+15]
					; [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_TOTALSECTORS]
		clc
		retn
setdeviceparameters endp


; =============== S U B	R O U T	I N E =======================================


organize	proc near		; ...
		mov	cx, cs:count
		jcxz	short nochar1
		call	mapcase
		xor	si, si
		mov	di, si
		xor	ax, ax
		mov	cs:com_level, 0

org1:					; ...
		call	skip_comment
		jz	short end_commd_line ; found a comment string and skipped
		call	get2		; not a	comment	string.	then get a char.
		cmp	al, 0Ah		; lf
		jz	short end_commd_line ; starts with a blank line.
		cmp	al, 20h	; ' '
		jbe	short org1	; skip leading control characters
		jmp	short findit
; ---------------------------------------------------------------------------

end_commd_line:				; ...
		stosb			; store	line feed char in buffer for the linecount.
		mov	cs:com_level, 0	; reset	the command level.
		jmp	short org1
; ---------------------------------------------------------------------------

nochar1:				; ...
		stc
		retn
; ---------------------------------------------------------------------------

findit:					; ...
		push	cx
		push	si
		push	di
		mov	bp, si
		dec	bp
		mov	si, offset comtab ; prepare to search command table
		mov	ch, 0

findcom:				; ...
		mov	di, bp
		mov	cl, [si]
		inc	si
		jcxz	short nocom
		repe cmpsb
		lahf
		add	si, cx		; bump to next position	without	affecting flags
		sahf
		lodsb			; get indicator	letter
		jnz	short findcom
		cmp	byte ptr es:[di], 0Dh ;	the next char might be cr,lf
		jz	short gotcom0	; such as in "rem",cr,lf case.
		cmp	byte ptr es:[di], 0Ah
		jz	short gotcom0
		push	ax
		mov	al, es:[di]	; now the next char. should be a delim.
		call	delim
		pop	ax
		jnz	short findcom

gotcom0:				; ...
		pop	di
		pop	si
		pop	cx
		jmp	short gotcom
; ---------------------------------------------------------------------------

nocom:					; ...
		pop	di
		pop	si
		pop	cx
		mov	al, 5Ah	; 'Z'   ; CONFIG_UNKNOWN
		stosb			; save indicator char.

_skipline:				; ...
		call	get2
		cmp	al, 0Ah		; lf ; skip this bad command line
		jnz	short _skipline
		jmp	short end_commd_line ; handle next command line
; ---------------------------------------------------------------------------

gotcom:					; ...
		stosb
		mov	cs:cmd_indicator, al

org2:					; ...
		call	get2		; skip the command name	until delimiter
		cmp	al, 0Ah		; lf
		jz	short org21
		cmp	al, 0Dh		; cr
		jz	short org21
		call	delim
		jnz	short org2
		jmp	short org3
; ---------------------------------------------------------------------------

org21:					; ...
		dec	si		; if cr	or lf then undo	si, cx register
		inc	cx		; and continue

org3:					; ...
		cmp	cs:cmd_indicator, 59h ;	'Y' ; CONFIG_COMMENT
		jz	short get_cmt_token
		cmp	cs:cmd_indicator, 49h ;	'I' ; CONFIG_INSTALL
		jz	short org_file
		cmp	cs:cmd_indicator, 44h ;	'D' ; CONFIG_DEVICE
		jz	short org_file
		cmp	cs:cmd_indicator, 53h ;	'S' ; CONFIG_SHELL
		jz	short org_file
		cmp	cs:cmd_indicator, 31h ;	'1' ; CONFIG_SWITCHES
		jz	short org_switch

org31:
		jmp	org4
; ---------------------------------------------------------------------------

org_switch:				; ...
		call	skip_comment
		jz	short end_commd_line_brdg
		call	get2
		call	org_delim
		jz	short org_switch
		stosb
		jmp	org5
; ---------------------------------------------------------------------------

org_file:				; ...
		call	skip_comment	; get the filename and put 0 at	end
		jz	short org_put_zero
		call	get2		; not a	comment
		call	delim
		jz	short org_file	; skip the possible delimiters
		stosb			; copy the first non delim char	found in buffer

org_copy_file:				; ...
		call	skip_comment	; comment char in the filename?
		jz	short org_put_zero ; then stop copying filename	at that	point
		call	get2
		cmp	al, '/'         ; a switch char? (device=filename/xxx)
		jz	short end_file_slash ; this will be the	special	case.
		stosb			; save the char. in buffer
		call	delim
		jz	short end_copy_file
		cmp	al, ' '         ; 20h ; SPACE
		ja	short org_copy_file ; keep copying
		jmp	short end_copy_file ; otherwise, assume	end of the filename.
; ---------------------------------------------------------------------------

get_cmt_token:				; ...
		call	get2		; get the token. just max. 2 char.
		cmp	al, 20h	; ' '   ; skip white spaces or "=" char.
		jz	short get_cmt_token ; (we are allowing the other special
					; characters can used for comment id. char.)
		cmp	al, 9		; TAB
		jz	short get_cmt_token
		cmp	al, 3Dh	; '='   ;  = is special in this case.
		jz	short get_cmt_token
		cmp	al, 0Dh		; CR
		jz	short get_cmt_end ; cannot accept the carriage return
		cmp	al, 0Ah		; LF
		jz	short get_cmt_end
		mov	cs:cmmt1, al	; store	it
		mov	cs:cmmt, 1	; 1 char. so far.
		call	get2
		cmp	al, 20h	; ' '
		jz	short get_cmt_end
		cmp	al, 9
		jz	short get_cmt_end
		cmp	al, 0Dh
		jz	short get_cmt_end
		cmp	al, 0Ah
		jz	short end_commd_line_brdg
		mov	cs:cmmt2, al
		inc	cs:cmmt

get_cmt_end:				; ...
		call	get2
		cmp	al, 0Ah		; lf
		jnz	short get_cmt_end ; skip it.

end_commd_line_brdg:			; ...
		jmp	end_commd_line	; else jmp to end_commd_line
; ---------------------------------------------------------------------------

org_put_zero:				; ...
		mov	byte ptr es:[di], 0 ; make the filename	in front of
					; the comment string to	be an asciiz.
		inc	di
		jmp	end_commd_line	; (maybe null if device=/*)
; ---------------------------------------------------------------------------

end_file_slash:				; ...
		mov	byte ptr es:[di], 0 ; al = "/" option char.
		inc	di		; make a filename an asciiz
					; and store "/"	after that.
		stosb
		jmp	short org5	; continue with	the rest of the	line
; ---------------------------------------------------------------------------

end_copy_file:				; ...
		mov	byte ptr es:[di-1], 0 ;	make it	an asciiz and handle the next char.
		cmp	al, 0Ah		; lf
		jz	short end_commd_line_brdg
		jmp	short org5
; ---------------------------------------------------------------------------

org4:					; ...
		call	skip_comment
		jz	short end_commd_line_brdg
		call	get2
		call	org_delim	; skip delimiters except '/'
		jz	short org4
		jmp	short org51
; ---------------------------------------------------------------------------

org5:					; ...
		call	skip_comment	; rest of the line
					; comment?
		jz	short end_commd_line_brdg
		call	get2		; not a	comment.

org51:					; ...
		stosb			; copy the character
		cmp	al, 22h	; '"'   ; a quote ?
		jz	short at_quote
		cmp	al, 20h	; ' '
		ja	short org5
		cmp	cs:cmd_indicator, 55h ;	'U' ; CONFIG_DEVICEHIGH
		jnz	short not_dh
		cmp	al, 0Ah		; lf
		jz	short org_dhlf	; stuff	a blank	before the lf
		cmp	al, 0Dh		; cr
		jnz	short org5
		mov	byte ptr es:[di-1], 20h	; ' ' ; overwrite cr with blank
		stosb			; put cr after blank
		inc	cs:insert_blank	; indicate that	blank has been inserted
		jmp	short org5
; ---------------------------------------------------------------------------

not_dh:					; ...
		cmp	al, 0Ah		; line feed ?
		jz	short org1_brdg	; handles the next command line.
		jmp	short org5	; handles next char in this line.
; ---------------------------------------------------------------------------

org_dhlf:				; ...
		cmp	cs:insert_blank, 1 ; Q:has a blank already been	inserted
		jz	short org1_brdg	; Y:
		mov	byte ptr es:[di-1], 20h	; ' ' ; overwrite lf with blank
		stosb			; put lf after blank

org1_brdg:				; ...
		mov	cs:insert_blank, 0 ; clear blank indicator for devicehigh
		jmp	org1
; ---------------------------------------------------------------------------

at_quote:				; ...
		cmp	cs:com_level, 0
		jz	short up_level
		mov	cs:com_level, 0	; reset	it.
		jmp	short org5
; ---------------------------------------------------------------------------

up_level:				; ...
		inc	cs:com_level	; set it.
		jmp	short org5
organize	endp


; =============== S U B	R O U T	I N E =======================================


get2		proc near		; ...
		jcxz	short noget
		mov	al, es:[si]
		inc	si
		dec	cx
		retn
; ---------------------------------------------------------------------------

noget:					; ...
		pop	cx
		mov	cs:count, di
		mov	cs:org_count, di
		xor	si, si
		mov	cs:chrptr, si
		retn
get2		endp ; sp-analysis failed


; =============== S U B	R O U T	I N E =======================================


skip_comment	proc near		; ...
		jcxz	short noget	; get out of the organize routine.
		cmp	cs:com_level, 0	; only check it	if parameter level is 0.
					; (not inside quotations)
		jnz	short no_commt
		cmp	cs:cmmt, 1
		jb	short no_commt
		mov	al, es:[si]
		cmp	cs:cmmt1, al
		jnz	short no_commt
		cmp	cs:cmmt, 2
		jnz	short skip_cmmt
		mov	al, es:[si+1]
		cmp	cs:cmmt2, al
		jnz	short no_commt

skip_cmmt:				; ...
		jcxz	short noget	; get out of organize routine.
		mov	al, es:[si]
		inc	si
		dec	cx
		cmp	al, 0Ah		; line feed?
		jnz	short skip_cmmt

no_commt:				; ...
		retn
skip_comment	endp


; =============== S U B	R O U T	I N E =======================================


delim		proc near		; ...
		cmp	al, '/'         ; ibm will assume "/" as an delimeter.
		jz	short delim_ret
		cmp	al, 0		; special case for sysinit!!!
		jz	short delim_ret

org_delim:				; ...
		cmp	al, ' '         ; used by organize routine except for getting
					; the file name
		jz	short delim_ret
		cmp	al, 9		; TAB
		jz	short delim_ret
		cmp	al, '='
		jz	short delim_ret
		cmp	al, ','
		jz	short delim_ret
		cmp	al, ';'

delim_ret:				; ...
		retn
delim		endp


; =============== S U B	R O U T	I N E =======================================


newline		proc near		; ...
		call	getchr		; skip non-control characters
		jb	short nl_ret
		cmp	al, 0Ah		; look for line	feed
		jnz	short newline
		call	getchr

nl_ret:					; ...
		retn
newline		endp


; =============== S U B	R O U T	I N E =======================================


mapcase		proc near		; ...
		push	cx
		push	si
		push	ds
		push	es
		pop	ds
		xor	si, si

convloop:				; ...
		lodsb
		cmp	al, 'a'
		jb	short noconv
		cmp	al, 'z'
		ja	short noconv
		sub	al, 20h
		mov	[si-1],	al

noconv:					; ...
		loop	convloop
		pop	ds
		pop	si
		pop	cx
		retn
mapcase		endp


; =============== S U B	R O U T	I N E =======================================


round		proc near		; ...
		push	ax
		mov	ax, cs:memlo
		call	ParaRound	; para round up
		add	cs:memhi, ax
		mov	cs:memlo, 0
		mov	ax, cs:memhi	; ax = new memhi
		cmp	ax, cs:ALLOCLIM	; if new memhi >= alloclim, error
		jnb	short memerr
		test	cs:setdevmarkflag, 2 ; for_devmark
		jz	short skip_set_devmarksize
		push	es
		push	si
		mov	si, cs:devmark_addr
		mov	es, si
		sub	ax, si
		dec	ax
		mov	es:stackcount+1, ax ; [es:3]
					; paragraph
		and	cs:setdevmarkflag, 0FDh	; not_for_devmark
		pop	si
		pop	es

skip_set_devmarksize:			; ...
		pop	ax
		clc
		retn
round		endp

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR multi_pass

memerr:					; ...
		mov	dx, offset badmem ; "\r\nConfiguration too large for memory\"...
		push	cs
		pop	ds
		call	print
		jmp	stall
; END OF FUNCTION CHUNK	FOR multi_pass

; =============== S U B	R O U T	I N E =======================================


calldev		proc near		; ...
		mov	ds, word ptr cs:DevEntry+2
		add	bx, word ptr cs:DevEntry ; do a	little relocation
		mov	ax, [bx]
		push	word ptr cs:DevEntry
		mov	word ptr cs:DevEntry, ax
		mov	bx, offset packet
		call	cs:DevEntry	; call far [cs:DevEntry]
		pop	word ptr cs:DevEntry
		retn
calldev		endp


; =============== S U B	R O U T	I N E =======================================


todigit		proc near		; ...
		sub	al, '0'
		jb	short notdig
		cmp	al, 9
		ja	short notdig
		clc
		retn
; ---------------------------------------------------------------------------

notdig:					; ...
		stc
		retn
todigit		endp


; =============== S U B	R O U T	I N E =======================================


getnum		proc near		; ...
		push	bx
		xor	bx, bx		; running count	is zero

b2:					; ...
		call	todigit		; do we	have a digit ?
		jb	short badnum	; no, bomb
		xchg	ax, bx		; put total in ax
		push	bx		; save digit (0	to 9)
		mov	bx, 10		; base of arithmetic
		mul	bx		; shift	by one decimal digit
		pop	bx		; get back digit (0 to 9)
		add	al, bl		; get total
		adc	ah, 0		; make that 16 bits
		jb	short badnum	; too big a number
		xchg	ax, bx		; stash	total
		call	getchr		; get next digit
		jb	short b1	; no more characters
		cmp	al, 20h	; ' '   ; space?
		jz	short b15	; then end of digits
		cmp	al, 2Ch	; ','   ; ',' is a seperator!!!
		jz	short b15	; then end of digits.
		cmp	al, 9		; TAB
		jz	short b15
		cmp	al, cs:sepchr	; allow	0 or special separators
		jz	short b15
		cmp	al, 2Fh	; '/'   ; see if another switch follows
		nop			; cas -	remnant	of old bad code
		nop
		jz	short b15
		cmp	al, 0Ah		; line-feed?
		jz	short b15
		cmp	al, 0Dh		; carriage return?
		jz	short b15
		or	al, al		; end of line separator?
		jnz	short b2	; no, try as a valid char...

b15:					; ...
		inc	cs:count	; one more character to	s...
		dec	cs:chrptr	; back up over separator

b1:					; ...
		mov	ax, bx		; get proper count
		or	ax, ax		; clears carry,	sets zero accordingly
		pop	bx
		retn
; ---------------------------------------------------------------------------

badnum:					; ...
		mov	cs:sepchr, 0
		xor	ax, ax		; set zero flag, and ax	= 0
		pop	bx
		stc			; and carry set
		retn
getnum		endp


; =============== S U B	R O U T	I N E =======================================


setdoscountryinfo proc near		; ...
		push	di
		push	ax
		push	dx
		xor	cx, cx
		xor	dx, dx
		mov	ax, 512		; read 512 bytes
		call	readincontrolbuffer ; read the file header
		jb	short setdosdata_fail
		push	es
		push	si
		push	cs
		pop	es
		mov	di, offset country_file_signature ; db 0FFh,'COUNTRY'
		mov	cx, 8
		repe cmpsb
		pop	si
		pop	es
		jnz	short setdosdata_fail ;	signature mismatch
		add	si, 18		; si ->	county info type
		cmp	byte ptr [si], 1 ; only	accept type 1
					; (currently only 1 header type)
		jnz	short setdosdata_fail ;	cannot proceed.	error return
		inc	si		; si ->	file offset
		mov	dx, [si]	; get the info file offset.
		mov	cx, [si+2]
		mov	ax, 6144	; read 6144 bytes.
		call	readincontrolbuffer ; read info
		jb	short setdosdata_fail
		mov	cx, [si]	; get the # of country,
					; codepage combination entries
		cmp	cx, 438		; cannot handle	more than 438 entries.
		ja	short setdosdata_fail
		inc	si
		inc	si		; si ->	entry information packet
		pop	dx		; restore code page id
		pop	ax		; restore country id
		pop	di

setdoscntry_find:			; ...
		cmp	ax, [si+2]	; search for desired country_id,codepage_id.
					; compare country_id
		jnz	short setdoscntry_next
		cmp	dx, 0		; no user specified code page ?
		jz	short setdoscntry_any_codepage ; then no need to match code page id.
		cmp	dx, [si+4]	; compare code page id
		jz	short setdoscntry_got_it

setdoscntry_next:			; ...
		add	si, [si]	; next entry
		inc	si
		inc	si		; take a word for size of entry	itself
		loop	setdoscntry_find
		mov	cx, 0FFFFh	; signals that bad country id entered.

setdoscntry_fail:			; ...
		stc
		retn
; ---------------------------------------------------------------------------

setdosdata_fail:			; ...
		pop	si
		pop	cx
		pop	di
		jmp	short setdoscntry_fail
; ---------------------------------------------------------------------------

setdoscntry_any_codepage:		; ...
		mov	dx, [si+4]	; use the code_page_id of the country_id found.

setdoscntry_got_it:			; ...
		mov	cs:cntrycodepage_id, dx	; found	the matching entry
					; save code page id for	this country.
		mov	dx, [si+10]	; get the file offset of country data
		mov	cx, [si+12]
		mov	ax, 512		; read 512 bytes
		call	readincontrolbuffer
		jb	short setdoscntry_fail
		mov	cx, [si]	; get the number of entries to handle.
		inc	si
		inc	si		; si ->	first entry

setdoscntry_data:			; ...
		push	di		; es:di	-> dos_country_cdpg_info
		push	cx		; save # of entry left
		push	si		; si ->	current	entry in control buffer
		mov	al, [si+2]	; get data entry id
		call	getcountrydestination ;	get the	address	of destination in es:di
		jb	short setdoscntry_data_next ; no matching data entry id	in dos
		mov	dx, [si+4]	; get offset of	data
		mov	cx, [si+6]
		mov	ax, 4200h
		stc
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from beginning of	file
		jb	short setdosdata_fail
		mov	dx, 512
		mov	cx, 20
		mov	ah, 3Fh		; read the country.sys data
		stc
		int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
					; BX = file handle, CX = number	of bytes to read
					; DS:DX	-> buffer
		jb	short setdosdata_fail ;	read failure
		cmp	ax, cx
		jnz	short setdosdata_fail
		mov	dx, [si+4]	; get offset of	data again.
		mov	cx, [si+6]
		mov	ax, 4200h	; move pointer back again
		stc
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from beginning of	file
		jb	short setdosdata_fail
		push	si
		mov	si, 520		; (512+8)
					; get length of	the data from the file
		mov	cx, [si]
		pop	si
		mov	dx, 512
		add	cx, 10
		mov	ah, 3Fh
		stc
		int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
					; BX = file handle, CX = number	of bytes to read
					; DS:DX	-> buffer
		jb	short setdosdata_fail
		cmp	ax, cx
		jnz	short setdosdata_fail
		mov	al, [si+2]	; save data id for future use.
		mov	si, 520		; (512+8)
					; si-> data buffer + id	tag field
		mov	cx, [si]	; get the length of the	file
					; take care of a word for lenght of tab	itself.
		inc	cx
		inc	cx
		cmp	cx, 1528	; fit into the buffer?
		ja	short setdosdata_fail
		call	setdbcs_before_copy
		cmp	al, 1		; SetCountryInfo ; 1
					; is the data for setcountryinfo table?
		jnz	short setdoscntry_mov ;	no, don't worry
		push	word ptr es:[di+24] ; [es:di+country_cdpg_info.ccMono_Ptr-country_cdpg_info.ccCountryInfoLen]
		push	word ptr es:[di+26] ; [es:di+country_cdpg_info.ccMono_Ptr-country_cdpg_info.ccCountryInfoLen+2]
		push	di
		push	ax
		mov	ax, cs:cntrycodepage_id	; do not use the code page info	in country_info
		mov	[si+4],	ax	; use the saved	one for	this !!!!
		pop	ax

setdoscntry_mov:			; ...
		rep movsb		; copy the table into dos
		cmp	al, 1		; SetCountryInfo
					; was the ccmono_ptr saved?
		jnz	short setdoscntry_data_next
		pop	di
		pop	word ptr es:[di+26] ; [es:di+country_cdpg_info.ccMono_Ptr-country_cdpg_info.ccCountryInfoLen+2]
		pop	word ptr es:[di+24] ; [es:di+country_cdpg_info.ccMono_Ptr-country_cdpg_info.ccCountryInfoLen]

setdoscntry_data_next:			; ...
		pop	si		; restore control buffer pointer
		pop	cx		; restore # of entries left
		pop	di		; restore pointer to dso_country_cdpg
		add	si, [si]	; try to get the next entry
		inc	si
		inc	si		; take a word of entry length itself
		dec	cx
		cmp	cx, 0
		jz	short setdoscntry_ok
		jmp	setdoscntry_data
; ---------------------------------------------------------------------------

setdoscntry_ok:				; ...
		retn
setdoscountryinfo endp ; sp-analysis failed


; =============== S U B	R O U T	I N E =======================================


setdbcs_before_copy proc near		; ...
		cmp	al, 7		; SetDBCS ; 7
					; dbcs vector set?
		jnz	short sdbcsbc
		cmp	word ptr es:[di], 0 ; zero byte	data block?
		jz	short sdbcsbc
		push	di
		push	ax
		push	cx
		mov	cx, es:[di]	; load block length
		add	di, 2		; points actual	data
		xor	al, al		; fill bytes
		rep stosb		; clear	data block
		pop	cx
		pop	ax
		pop	di

sdbcsbc:				; ...
		retn
setdbcs_before_copy endp


; =============== S U B	R O U T	I N E =======================================


getcountrydestination proc near		; ...
		push	cx
		add	di, 74		; country_cdpg_info.ccNumber_of_entries
					; skip the reserved area, syscodepage etc.
		mov	cx, es:[di]	; get the number of entries
		inc	di
		inc	di		; si ->	the first start	entry id

getcntrydest:				; ...
		cmp	es:[di], al
		jz	short getcntrydest_ok
		cmp	byte ptr es:[di], 1 ; was it setcountryinfo entry?
		jz	short getcntrydest_1
		add	di, 5		; next data id
		jmp	short getcntrydest_loop
; ---------------------------------------------------------------------------

getcntrydest_1:				; ...
		add	di, 41		; NEW_COUNTRY_SIZE+3
					; next data id

getcntrydest_loop:			; ...
		loop	getcntrydest
		stc
		jmp	short getcntrydest_exit
; ---------------------------------------------------------------------------

getcntrydest_ok:			; ...
		cmp	al, 1		; select country info?
		jnz	short getcntrydest_ok1
		inc	di		; now di -> cccountryinfolen
		jmp	short getcntrydest_exit
; ---------------------------------------------------------------------------

getcntrydest_ok1:			; ...
		les	di, es:[di+1]	; get the destination in es:di

getcntrydest_exit:			; ...
		pop	cx
		retn
getcountrydestination endp


; =============== S U B	R O U T	I N E =======================================


readincontrolbuffer proc near		; ...
		push	ax		; move file pointer to cx:dx
					; # of bytes to	read
		mov	ax, 4200h
		stc
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from beginning of	file
		pop	cx		; # of bytes to	read
					; should be less than 1024 bytes
		jb	short ricb_exit
		xor	dx, dx		; ds:dx	-> control buffer
		xor	si, si
		mov	ah, 3Fh
		stc
		int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
					; BX = file handle, CX = number	of bytes to read
					; DS:DX	-> buffer

ricb_exit:				; ...
		retn
readincontrolbuffer endp


; =============== S U B	R O U T	I N E =======================================


set_country_path proc near
		push	si
		push	ds
		push	es
		pop	ds
		pop	es
		call	chk_drive_letter ; current ds:[si] is a	drive letter?
		jb	short scp_default_drv ;	no, use	current	default	drive.
		mov	al, [si]
		inc	si
		inc	si		; si ->	next char after	":"
		jmp	short scp_setdrv
; ---------------------------------------------------------------------------

scp_default_drv:			; ...
		mov	ah, 19h
		int	21h		; DOS -	GET DEFAULT DISK NUMBER
		add	al, 'A'         ; convert it to a character.

scp_setdrv:				; ...
		mov	byte ptr cs:cntry_drv, al ; set	the drive letter.
		mov	di, offset cntry_path ;	"COUNTRY.SYS"
		mov	al, [si]
		cmp	al, '\'
		jz	short scp_root_dir
		cmp	al, '/'         ; let's accept "/" as an directory delim
		jz	short scp_root_dir
		jmp	short scp_path
; ---------------------------------------------------------------------------

scp_root_dir:				; ...
		dec	di		; di ->	cntry_root

scp_path:				; ...
		call	move_asciiz	; copy it
		mov	di, offset cntry_drv ; "A:"
		push	ds
		push	es
		pop	ds
		pop	es
		pop	si
		retn
set_country_path endp


; =============== S U B	R O U T	I N E =======================================


chk_drive_letter proc near		; ...
		push	ax
		cmp	byte ptr [si], 'A'
		jb	short cdletter_no
		cmp	byte ptr [si], 'Z'
		ja	short cdletter_no
		cmp	byte ptr [si+1], ':'
		jnz	short cdletter_no
		jmp	short cdletter_exit
; ---------------------------------------------------------------------------

cdletter_no:				; ...
		stc

cdletter_exit:				; ...
		pop	ax
		retn
chk_drive_letter endp


; =============== S U B	R O U T	I N E =======================================


move_asciiz	proc near		; ...
		movsb
		cmp	byte ptr [si-1], 0 ; was it 0?
		jnz	short move_asciiz
		retn
move_asciiz	endp


; =============== S U B	R O U T	I N E =======================================


badfil		proc near		; ...
		push	cs
		pop	es
		mov	si, dx

badload:				; ...
		mov	dx, offset badld_pre ; "\r\nBad	or missing $"
		mov	bx, offset crlfm ; "\r\n$"

prnerr:					; ...
		push	cs
		pop	ds
		call	print

prn1:					; ...
		mov	dl, es:[si]
		or	dl, dl
		jz	short prn2
		mov	ah, 2		; STD_CON_OUTPUT
		int	21h		; DOS -	DISPLAY	OUTPUT
					; DL = character to send to standard output
		inc	si
		jmp	short prn1
; ---------------------------------------------------------------------------

prn2:					; ...
		mov	dx, bx
		call	print
		cmp	cs:donotshownum, 1 ; suppress line number when handling	command.com
		jz	short prnexit
		call	error_line

prnexit:				; ...
		retn
badfil		endp


; =============== S U B	R O U T	I N E =======================================


print		proc near		; ...
		mov	ah, 9
		int	21h		; DOS -	PRINT STRING
					; DS:DX	-> string terminated by	"$"
		retn
print		endp


; =============== S U B	R O U T	I N E =======================================


open_dev	proc near		; ...
		call	open_file
		jnb	short open_dev3

open_dev1:				; ...
		mov	dx, offset nuldev ; "NUL"
		call	open_file

of_retn:				; ...
		retn
; ---------------------------------------------------------------------------

open_dev3:				; ...
		mov	bx, ax
		xor	ax, ax
		mov	ah, 44h		; IOCTL
		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
					; BX = file or device handle
		test	dl, 10000000b	; 80h
		jnz	short of_retn
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		jmp	short open_dev1
open_dev	endp


; =============== S U B	R O U T	I N E =======================================


open_file	proc near		; ...
		mov	ah, 3Dh
		stc
		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
					; DS:DX	-> ASCIZ filename
					; AL = access mode
					; 0 - read
		retn
open_file	endp

; ---------------------------------------------------------------------------

int24:					; ...
		mov	al, 3
		iret
; ---------------------------------------------------------------------------
MsDosVersion5Copyr db 'MS DOS Version 5.00 (C)Copyright 1981-1991 Microsoft Corp License'
		db 'd Material - Property of Microsoft All rights reserved '
nuldev		db 'NUL',0              ; ...
condev		db 'CON',0              ; ...
auxdev		db 'AUX',0              ; ...
prndev		db 'PRN',0              ; ...
config		db '\CONFIG.SYS',0      ; ...
cntry_drv	db 'A:'                 ; ...
cntry_root	db '\'                  ; ...
cntry_path	db 'COUNTRY.SYS',0      ; ...
		db 52 dup(0)
country_file_signature db 0FFh		; ...
		db 'COUNTRY'
cntrycodepage_id dw 0			; ...
commnd		db '\COMMAND.COM',0     ; ...
		db 51 dup(0)
pathstring	db 64 dup(0)
comtab		db 7			; ...
aBuffers	db 'BUFFERS'
		db 'B'
		db 5
aBreak		db 'BREAK'
		db 'C'
		db 6
aDevice		db 'DEVICE'
		db 'D'
		db 10
aDevicehigh	db 'DEVICEHIGH'
		db 'U'
		db 5
aFiles		db 'FILES'
		db 'F'
		db 4
aFcbs		db 'FCBS'
		db 'X'
		db 9
aLastdrive	db 'LASTDRIVE'
		db 'L'
		db 10
aMultitrack	db 'MULTITRACK'
		db 'M'
		db 8
aDrivparm	db 'DRIVPARM'
		db 'P'
		db 6
aStacks		db 'STACKS'
		db 'K'
		db 7
aCountry	db 'COUNTRY'
		db 'Q'
		db 5
aShell		db 'SHELL'
		db 'S'
		db 7
aInstall	db 'INSTALL'
		db 'I'
		db 7
aComment	db 'COMMENT'
		db 'Y'
		db 3
aRem		db 'REM'
		db '0'
		db 8
aSwitches	db 'SWITCHES'
		db '1'
		db 3
aDos		db 'DOS'
		db 'H'
		db 0
devp_specialfunc db 0			; ...
devp_devtype	db 2			; ...
devp_devattr	dw 0			; ...
devp_cylinders	dw 80			; ...
devparms_6	db 0
devparms_7	dw 0			; ...
devparms_9	db 8 dup(0)		; ...
devparms_17	db 3 dup(0)		; ...
devparms_20	db 272 dup(0)		; ...
hlim		dw 2			; ...
slim		dw 9			; ...
drive		db 0			; ...
switches	dw 0			; ...
bpb48t		dw 512			; ...
		db 2
		dw 1
		db 2
		dw 112
		dw 720
		db 0FDh
		dw 2
		dw 9
		dw 2
		dd 0
		dd 0
bpb96t		dw 512			; ...
		db 1
		dw 1
		db 2
		dw 224
		dw 2400
		db 0F9h
		dw 7
		dw 15
		dw 2
		dd 0
		dd 0
bpb35		dw 512			; ...
		db 2
		dw 1
		db 2
		dw 112
		dw 1440
		db 0F9h
		dw 3
		dw 9
		dw 2
		dd 0
		dd 0
bpb35h		dw 512			; ...
		db 1
		dw 1
		db 2
		dw 224
		dw 2880
		db 0F0h
		dw 9
		dw 18
		dw 2
		dd 0
		dd 0
bpb288		dw 200h			; ...
		db 2
		dw 1
		db 2
		dw 240
		dw 5760
		db 0F0h
		dw 9
		dw 36
		dw 2
		dd 0
		dd 0
bpbtable	dw offset bpb48t	; ...
		dw offset bpb96t
		dw offset bpb35
		dw offset bpb35
		dw offset bpb35
		dw offset bpb35
		dw offset bpb35
		dw offset bpb35h
		dw offset bpb35
		dw offset bpb288
switchlist	db 8,'FHSTDICN',0       ; ...
badopm		db 0Dh,0Ah		; ...
		db 'Unrecognized command in CONFIG.SYS'
crlfm		db 0Dh,0Ah,'$'          ; ...
badparm		db 0Dh,0Ah		; ...
		db 'Bad command or parameters - $'
badsiz_pre	db 0Dh,0Ah		; ...
		db 'Sector size too large in file $'
badld_pre	db 0Dh,0Ah		; ...
		db 'Bad or missing $'
badcom		db 'Command Interpreter',0 ; ...
badcountry	db 0Dh,0Ah		; ...
		db 'Invalid country code or code page',0Dh,0Ah,'$'
badcountrycom	db 0Dh,0Ah		; ...
		db 'Error in COUNTRY command',0Dh,0Ah,'$'
insufmemory	db 0Dh,0Ah		; ...
		db 'Insufficient memory for COUNTRY.SYS file',0Dh,0Ah,'$'
badmem		db 0Dh,0Ah		; ...
		db 'Configuration too large for memory',0Dh,0Ah,'$'
badblock	db 0Dh,0Ah		; ...
		db 'Too many block devices',0Dh,0Ah,'$'
badstack	db 0Dh,0Ah		; ...
		db 'Invalid STACK parameters',0Dh,0Ah,'$'
badorder	db 0Dh,0Ah		; ...
		db 'Incorrect order in CONFIG.SYS line $'
errorcmd	db 'Error in CONFIG.SYS line $' ; ...
TooManyDrivesMsg db 'WARNING! Logical drives past Z: exist and will be ignored',0Dh,0Ah,'$' ; ...
		db 4 dup(0)
seg000		ends


		end
